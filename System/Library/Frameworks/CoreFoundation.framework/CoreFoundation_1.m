void CFNumberFormatterSetProperty(CFNumberFormatterRef formatter, CFNumberFormatterKey key, CFTypeRef value)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  int v12;
  CFIndex Length;
  CFIndex v14;
  uint64_t v15;
  unsigned int v16;
  CFIndex v17;
  CFIndex v18;
  uint64_t v19;
  unsigned int v20;
  CFIndex v21;
  CFIndex v22;
  CFIndex v23;
  const void *v24;
  CFTypeRef v25;
  CFIndex v26;
  CFIndex v27;
  CFIndex v28;
  CFIndex v29;
  CFIndex v30;
  CFIndex v31;
  CFIndex v32;
  CFTypeRef v33;
  CFIndex v34;
  CFIndex v35;
  CFIndex v36;
  CFIndex v37;
  CFIndex v38;
  CFIndex v39;
  CFIndex v40;
  int v41;
  double v42;
  unsigned int valuePtr;
  UniChar buffer[768];
  uint64_t v45;
  CFRange v46;
  CFRange v47;
  CFRange v48;
  CFRange v49;
  CFRange v50;
  CFRange v51;
  CFRange v52;
  CFRange v53;
  CFRange v54;
  CFRange v55;
  CFRange v56;
  CFRange v57;
  CFRange v58;
  CFRange v59;
  CFRange v60;
  CFRange v61;
  CFRange v62;
  CFRange v63;
  CFRange v64;

  v45 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  v42 = 0.0;
  v41 = 0;
  v6 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v6 != 57)
    _CFAssertMismatchedTypeID(0x39uLL, v6);
  if (CFEqual(CFSTR("kCFNumberFormatterFormattingContextKey"), key))
  {
    CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
    __cficu_unum_setContext(*((_QWORD *)formatter + 2), valuePtr, &v41);
  }
  v7 = *((_QWORD *)formatter + 4);
  if ((unint64_t)(v7 - 8) < 0xFFFFFFFFFFFFFFFDLL && v7 != 9 || CFSTR("kCFNumberFormatterIsLenientKey") == key)
  {
    if (CFSTR("kCFNumberFormatterCurrencyCodeKey") == key)
    {
      Length = CFStringGetLength((CFStringRef)value);
      if (Length >= 768)
        v14 = 768;
      else
        v14 = Length;
      v46.location = 0;
      v46.length = v14;
      CFStringGetCharacters((CFStringRef)value, v46, buffer);
      v15 = *((_QWORD *)formatter + 2);
      v16 = 5;
      goto LABEL_59;
    }
    if (CFSTR("kCFNumberFormatterDecimalSeparatorKey") == key)
    {
      v17 = CFStringGetLength((CFStringRef)value);
      if (v17 >= 768)
        v18 = 768;
      else
        v18 = v17;
      v47.location = 0;
      v47.length = v18;
      CFStringGetCharacters((CFStringRef)value, v47, buffer);
      v19 = *((_QWORD *)formatter + 2);
      v20 = 0;
      goto LABEL_109;
    }
    if (CFSTR("kCFNumberFormatterCurrencyDecimalSeparatorKey") == key)
    {
      v21 = CFStringGetLength((CFStringRef)value);
      if (v21 >= 768)
        v18 = 768;
      else
        v18 = v21;
      v48.location = 0;
      v48.length = v18;
      CFStringGetCharacters((CFStringRef)value, v48, buffer);
      v19 = *((_QWORD *)formatter + 2);
      v20 = 10;
      goto LABEL_109;
    }
    if (CFSTR("kCFNumberFormatterAlwaysShowDecimalSeparatorKey") == key)
    {
      v11 = *((_QWORD *)formatter + 2);
      v10 = &__kCFBooleanTrue == value;
      v12 = 2;
      goto LABEL_74;
    }
    if (CFSTR("kCFNumberFormatterGroupingSeparatorKey") == key)
    {
      v22 = CFStringGetLength((CFStringRef)value);
      if (v22 >= 768)
        v18 = 768;
      else
        v18 = v22;
      v49.location = 0;
      v49.length = v18;
      CFStringGetCharacters((CFStringRef)value, v49, buffer);
      v19 = *((_QWORD *)formatter + 2);
      v20 = 1;
      goto LABEL_109;
    }
    if (CFSTR("kCFNumberFormatterUseGroupingSeparatorKey") == key)
    {
      v11 = *((_QWORD *)formatter + 2);
      v10 = &__kCFBooleanTrue == value;
      v12 = 1;
      goto LABEL_74;
    }
    if (CFSTR("kCFNumberFormatterPercentSymbolKey") == key)
    {
      v23 = CFStringGetLength((CFStringRef)value);
      if (v23 >= 768)
        v18 = 768;
      else
        v18 = v23;
      v50.location = 0;
      v50.length = v18;
      CFStringGetCharacters((CFStringRef)value, v50, buffer);
      v19 = *((_QWORD *)formatter + 2);
      v20 = 3;
      goto LABEL_109;
    }
    if (CFSTR("kCFNumberFormatterZeroSymbolKey") == key)
    {
      v24 = (const void *)*((_QWORD *)formatter + 9);
      if (value)
        v25 = CFRetain(value);
      else
        v25 = 0;
      *((_QWORD *)formatter + 9) = v25;
      if (!v24)
        goto LABEL_110;
    }
    else
    {
      if (CFSTR("kCFNumberFormatterNaNSymbolKey") == key)
      {
        v26 = CFStringGetLength((CFStringRef)value);
        if (v26 >= 768)
          v18 = 768;
        else
          v18 = v26;
        v51.location = 0;
        v51.length = v18;
        CFStringGetCharacters((CFStringRef)value, v51, buffer);
        v19 = *((_QWORD *)formatter + 2);
        v20 = 15;
        goto LABEL_109;
      }
      if (CFSTR("kCFNumberFormatterInfinitySymbolKey") == key)
      {
        v27 = CFStringGetLength((CFStringRef)value);
        if (v27 >= 768)
          v18 = 768;
        else
          v18 = v27;
        v52.location = 0;
        v52.length = v18;
        CFStringGetCharacters((CFStringRef)value, v52, buffer);
        v19 = *((_QWORD *)formatter + 2);
        v20 = 14;
        goto LABEL_109;
      }
      if (CFSTR("kCFNumberFormatterMinusSignKey") == key)
      {
        v28 = CFStringGetLength((CFStringRef)value);
        if (v28 >= 768)
          v18 = 768;
        else
          v18 = v28;
        v53.location = 0;
        v53.length = v18;
        CFStringGetCharacters((CFStringRef)value, v53, buffer);
        v19 = *((_QWORD *)formatter + 2);
        v20 = 6;
        goto LABEL_109;
      }
      if (CFSTR("kCFNumberFormatterPlusSignKey") == key)
      {
        v29 = CFStringGetLength((CFStringRef)value);
        if (v29 >= 768)
          v18 = 768;
        else
          v18 = v29;
        v54.location = 0;
        v54.length = v18;
        CFStringGetCharacters((CFStringRef)value, v54, buffer);
        v19 = *((_QWORD *)formatter + 2);
        v20 = 7;
        goto LABEL_109;
      }
      if (CFSTR("kCFNumberFormatterCurrencySymbolKey") == key)
      {
        v30 = CFStringGetLength((CFStringRef)value);
        if (v30 >= 768)
          v18 = 768;
        else
          v18 = v30;
        v55.location = 0;
        v55.length = v18;
        CFStringGetCharacters((CFStringRef)value, v55, buffer);
        v19 = *((_QWORD *)formatter + 2);
        v20 = 8;
        goto LABEL_109;
      }
      if (CFSTR("kCFNumberFormatterExponentSymbolKey") == key)
      {
        v31 = CFStringGetLength((CFStringRef)value);
        if (v31 >= 768)
          v18 = 768;
        else
          v18 = v31;
        v56.location = 0;
        v56.length = v18;
        CFStringGetCharacters((CFStringRef)value, v56, buffer);
        v19 = *((_QWORD *)formatter + 2);
        v20 = 11;
        goto LABEL_109;
      }
      if (CFSTR("kCFNumberFormatterMinIntegerDigitsKey") == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        v11 = *((_QWORD *)formatter + 2);
        v10 = valuePtr;
        v12 = 4;
        goto LABEL_74;
      }
      if (CFSTR("kCFNumberFormatterMaxIntegerDigitsKey") == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        v11 = *((_QWORD *)formatter + 2);
        v10 = valuePtr;
        v12 = 3;
        goto LABEL_74;
      }
      if (CFSTR("kCFNumberFormatterMinFractionDigitsKey") == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        v11 = *((_QWORD *)formatter + 2);
        v10 = valuePtr;
        v12 = 7;
        goto LABEL_74;
      }
      if (CFSTR("kCFNumberFormatterMaxFractionDigitsKey") == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        v11 = *((_QWORD *)formatter + 2);
        v10 = valuePtr;
        v12 = 6;
        goto LABEL_74;
      }
      if (CFSTR("kCFNumberFormatterGroupingSizeKey") == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        v11 = *((_QWORD *)formatter + 2);
        v10 = valuePtr;
        v12 = 10;
        goto LABEL_74;
      }
      if (CFSTR("kCFNumberFormatterSecondaryGroupingSizeKey") == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        v11 = *((_QWORD *)formatter + 2);
        v10 = valuePtr;
        v12 = 15;
        goto LABEL_74;
      }
      if (CFSTR("kCFNumberFormatterRoundingModeKey") == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        v11 = *((_QWORD *)formatter + 2);
        v10 = valuePtr;
        v12 = 11;
        goto LABEL_74;
      }
      if (CFSTR("kCFNumberFormatterRoundingIncrementKey") == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberDoubleType, &v42);
        __cficu_unum_setDoubleAttribute(*((_QWORD *)formatter + 2), 12, v42);
        goto LABEL_110;
      }
      if (CFSTR("kCFNumberFormatterFormatWidthKey") == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        v11 = *((_QWORD *)formatter + 2);
        v10 = valuePtr;
        v12 = 13;
        goto LABEL_74;
      }
      if (CFSTR("kCFNumberFormatterPaddingPositionKey") == key)
      {
        CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
        v11 = *((_QWORD *)formatter + 2);
        v10 = valuePtr;
        v12 = 14;
        goto LABEL_74;
      }
      if (CFSTR("kCFNumberFormatterPaddingCharacterKey") == key)
      {
        v32 = CFStringGetLength((CFStringRef)value);
        if (v32 >= 768)
          v14 = 768;
        else
          v14 = v32;
        v57.location = 0;
        v57.length = v14;
        CFStringGetCharacters((CFStringRef)value, v57, buffer);
        v15 = *((_QWORD *)formatter + 2);
        v16 = 4;
        goto LABEL_59;
      }
      if (CFSTR("kCFNumberFormatterDefaultFormatKey") == key)
        goto LABEL_110;
      if (CFSTR("kCFNumberFormatterMultiplierKey") != key)
      {
        if (CFSTR("kCFNumberFormatterPositivePrefixKey") == key)
        {
          v34 = CFStringGetLength((CFStringRef)value);
          if (v34 >= 768)
            v14 = 768;
          else
            v14 = v34;
          v58.location = 0;
          v58.length = v14;
          CFStringGetCharacters((CFStringRef)value, v58, buffer);
          v15 = *((_QWORD *)formatter + 2);
          v16 = 0;
        }
        else if (CFSTR("kCFNumberFormatterPositiveSuffixKey") == key)
        {
          v35 = CFStringGetLength((CFStringRef)value);
          if (v35 >= 768)
            v14 = 768;
          else
            v14 = v35;
          v59.location = 0;
          v59.length = v14;
          CFStringGetCharacters((CFStringRef)value, v59, buffer);
          v15 = *((_QWORD *)formatter + 2);
          v16 = 1;
        }
        else if (CFSTR("kCFNumberFormatterNegativePrefixKey") == key)
        {
          v36 = CFStringGetLength((CFStringRef)value);
          if (v36 >= 768)
            v14 = 768;
          else
            v14 = v36;
          v60.location = 0;
          v60.length = v14;
          CFStringGetCharacters((CFStringRef)value, v60, buffer);
          v15 = *((_QWORD *)formatter + 2);
          v16 = 2;
        }
        else
        {
          if (CFSTR("kCFNumberFormatterNegativeSuffixKey") != key)
          {
            if (CFSTR("kCFNumberFormatterPerMillSymbolKey") == key)
            {
              v38 = CFStringGetLength((CFStringRef)value);
              if (v38 >= 768)
                v18 = 768;
              else
                v18 = v38;
              v62.location = 0;
              v62.length = v18;
              CFStringGetCharacters((CFStringRef)value, v62, buffer);
              v19 = *((_QWORD *)formatter + 2);
              v20 = 12;
            }
            else if (CFSTR("kCFNumberFormatterInternationalCurrencySymbolKey") == key)
            {
              v39 = CFStringGetLength((CFStringRef)value);
              if (v39 >= 768)
                v18 = 768;
              else
                v18 = v39;
              v63.location = 0;
              v63.length = v18;
              CFStringGetCharacters((CFStringRef)value, v63, buffer);
              v19 = *((_QWORD *)formatter + 2);
              v20 = 9;
            }
            else
            {
              if (CFSTR("kCFNumberFormatterCurrencyGroupingSeparatorKey") != key)
              {
                if (CFSTR("kCFNumberFormatterIsLenientKey") == key)
                {
                  v10 = &__kCFBooleanTrue == value;
                  *((_BYTE *)formatter + 80) = v10;
                  v11 = *((_QWORD *)formatter + 2);
                  v12 = 19;
                }
                else if (CFSTR("kCFNumberFormatterUseSignificantDigitsKey") == key)
                {
                  v11 = *((_QWORD *)formatter + 2);
                  v10 = &__kCFBooleanTrue == value;
                  v12 = 16;
                }
                else if (CFSTR("kCFNumberFormatterMinSignificantDigitsKey") == key)
                {
                  CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
                  v11 = *((_QWORD *)formatter + 2);
                  v10 = valuePtr;
                  v12 = 17;
                }
                else
                {
                  if (CFSTR("kCFNumberFormatterMaxSignificantDigitsKey") != key)
                  {
                    if (CFSTR("kCFNumberFormatterUsesCharacterDirectionKey") != key)
                    {
                      if (CFSTR("kCFNumberFormatterMinGroupingDigitsKey") != key)
                        goto LABEL_110;
                      CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
                      v10 = valuePtr;
                      if (valuePtr == -1)
                      {
                        v10 = 4294967294;
                        valuePtr = -2;
                      }
                      v11 = *((_QWORD *)formatter + 2);
                      v12 = 22;
                      goto LABEL_74;
                    }
                    *((_BYTE *)formatter + 82) = &__kCFBooleanTrue == value;
LABEL_110:
                    if (_CFExecutableLinkedOnOrAfter(6uLL))
                      CFNumberFormatterGetFormat(formatter);
                    return;
                  }
                  CFNumberGetValue((CFNumberRef)value, kCFNumberSInt32Type, &valuePtr);
                  v11 = *((_QWORD *)formatter + 2);
                  v10 = valuePtr;
                  v12 = 18;
                }
LABEL_74:
                __cficu_unum_setAttribute(v11, v12, v10);
                goto LABEL_110;
              }
              v40 = CFStringGetLength((CFStringRef)value);
              if (v40 >= 768)
                v18 = 768;
              else
                v18 = v40;
              v64.location = 0;
              v64.length = v18;
              CFStringGetCharacters((CFStringRef)value, v64, buffer);
              v19 = *((_QWORD *)formatter + 2);
              v20 = 17;
            }
LABEL_109:
            __cficu_unum_setSymbol(v19, v20, buffer, v18, &v41);
            goto LABEL_110;
          }
          v37 = CFStringGetLength((CFStringRef)value);
          if (v37 >= 768)
            v14 = 768;
          else
            v14 = v37;
          v61.location = 0;
          v61.length = v14;
          CFStringGetCharacters((CFStringRef)value, v61, buffer);
          v15 = *((_QWORD *)formatter + 2);
          v16 = 3;
        }
LABEL_59:
        __cficu_unum_setTextAttribute(v15, v16, buffer, v14, &v41);
        goto LABEL_110;
      }
      v24 = (const void *)*((_QWORD *)formatter + 8);
      if (value)
        v33 = CFRetain(value);
      else
        v33 = 0;
      *((_QWORD *)formatter + 8) = v33;
      *((_BYTE *)formatter + 81) = value != 0;
      if (!v24)
        goto LABEL_110;
    }
    CFRelease(v24);
    goto LABEL_110;
  }
}

void __cficu_unum_setAttribute(uint64_t a1, int a2, uint64_t a3)
{
  CFStringRef v6;
  const char *v7;

  unum_setAttribute();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v7 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, CFSTR("unum_setAttribute(%@, %s, %d);"), v6, v7, a3);
    CFRelease(v6);
  }
}

void CFNumberFormatterSetFormat(CFNumberFormatterRef formatter, CFStringRef formatString)
{
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  CFIndex Length;
  const void *v10;
  int v11;
  int v12;
  const void *v13;
  const __CFAllocator *v14;
  const __CFString *v15;
  int v16;
  UniChar chars[768];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 57)
    _CFAssertMismatchedTypeID(0x39uLL, v4);
  v5 = *((_QWORD *)formatter + 4);
  v6 = v5 > 9;
  v7 = (1 << v5) & 0x2E0;
  if (v6 || v7 == 0)
  {
    Length = CFStringGetLength(formatString);
    v10 = (const void *)*((_QWORD *)formatter + 5);
    if (v10)
    {
      if (CFEqual(v10, formatString) || Length >= 1025)
        return;
    }
    else if (Length > 1024)
    {
      return;
    }
    if ((int)__CFNumberFormatterApplyPattern((uint64_t)formatter, formatString) <= 0)
    {
      v16 = 0;
      v11 = __cficu_unum_toPattern(*((_QWORD *)formatter + 2), 0, chars, 768, &v16);
      if (v16 <= 0)
      {
        v12 = v11;
        if (v11 <= 768)
        {
          v13 = (const void *)*((_QWORD *)formatter + 5);
          if (v13)
            CFRelease(v13);
          v14 = CFGetAllocator(formatter);
          v15 = CFStringCreateWithCharacters(v14, chars, v12);
          *((_QWORD *)formatter + 5) = v15;
          if (*((_QWORD *)formatter + 7))
          {
            CFRelease(*((CFTypeRef *)formatter + 7));
            v15 = (const __CFString *)*((_QWORD *)formatter + 5);
          }
          *((_QWORD *)formatter + 7) = __CFNumberFormatterCreateCompressedString(v15, 1, 0);
        }
      }
    }
  }
}

uint64_t __CFNumberFormatterApplyPattern(uint64_t a1, CFStringRef theString)
{
  unint64_t v4;
  CFIndex Length;
  uint64_t v6;
  CFIndex v7;
  size_t v8;
  char *v9;
  UChar *CharactersPtr;
  const void *v12;
  const __CFAllocator *v13;
  int valuePtr;
  unsigned int v15;
  uint64_t v16;
  CFRange v17;

  v16 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32) - 5;
  if (v4 < 5 && ((0x17u >> v4) & 1) != 0)
    return 16;
  Length = CFStringGetLength(theString);
  v7 = Length;
  v8 = 2 * Length;
  if ((unint64_t)(2 * Length) < 0x101)
  {
    if (Length < 1)
    {
      v9 = 0;
    }
    else
    {
      MEMORY[0x1E0C80A78](Length, v6);
      v9 = (char *)&valuePtr - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v9, v8);
    }
  }
  else
  {
    v9 = (char *)malloc_type_malloc(2 * Length, 0x1000040BDFB0063uLL);
  }
  CharactersPtr = (UChar *)CFStringGetCharactersPtr(theString);
  if (!CharactersPtr)
  {
    v17.location = 0;
    v17.length = v7;
    CFStringGetCharacters(theString, v17, (UniChar *)v9);
    CharactersPtr = (UChar *)v9;
  }
  v15 = 0;
  __cficu_unum_applyPattern(*(_QWORD *)(a1 + 16), 0, CharactersPtr, v7, 0, (int *)&v15);
  if (v8 >= 0x101)
    free(v9);
  if (!*(_BYTE *)(a1 + 81))
  {
    v12 = *(const void **)(a1 + 64);
    if (v12)
      CFRelease(v12);
    *(_QWORD *)(a1 + 64) = 0;
    valuePtr = __cficu_unum_getAttribute(*(_QWORD *)(a1 + 16), 9);
    if (valuePtr == 1)
      return v15;
    v13 = CFGetAllocator((CFTypeRef)a1);
    *(_QWORD *)(a1 + 64) = CFNumberCreate(v13, kCFNumberSInt32Type, &valuePtr);
  }
  __cficu_unum_setAttribute(*(_QWORD *)(a1 + 16), 9, 1);
  return v15;
}

void __cficu_unum_applyPattern(uint64_t a1, int a2, UChar *a3, uint64_t a4, uint64_t a5, int *a6)
{
  CFStringRef v12;
  const void *v13;
  CFStringRef v14;
  CFStringRef v15;

  unum_applyPattern();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    v14 = ___CFICUCreateErrorStringWithComment(a6, 1);
    v15 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0);
    if (a5)
      ___CFICULogWithArguments(1, CFSTR("#warning non-NULL parseError ignored"));
    ___CFICULogWithArguments(1, CFSTR("unum_applyPattern(%@, %d, %@, %d, NULL, &%@); %@"), v12, a2, v15, a4, v13, v14);
    CFRelease(v15);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v14);
  }
}

CFNumberFormatterRef CFNumberFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFNumberFormatterStyle style)
{
  __objc2_class **v5;
  uint64_t v6;
  uint64_t Instance;
  unsigned int v8;
  const __CFString *Identifier;
  void *CStringPtr;
  uint64_t v11;
  void *System;
  const char *v13;
  unint64_t v14;
  const __CFDictionary *AppleICUNumberSymbolsPref;
  const __CFDictionary *v16;
  CFTypeID v17;
  unint64_t v18;
  const void *v19;
  unint64_t v20;
  int v22;
  const __CFDictionary *AppleICUNumberFormatStringsPref;
  const __CFDictionary *v24;
  CFTypeID v25;
  unint64_t v26;
  __CFString *v27;
  const __CFString *Value;
  const __CFString *v29;
  CFTypeID v30;
  unsigned int v31;
  const __CFString *v32;
  void *v33;
  uint64_t v34;
  const void *v35;
  int v36;
  const __CFString *v37;
  int v38;
  int v39;
  CFMutableStringRef Mutable;
  int v41;
  CFRange result;
  int v43;
  char buffer[768];
  UniChar chars[768];
  char v46[768];
  uint64_t v47;
  CFRange v48;

  v5 = (__objc2_class **)allocator;
  v47 = *MEMORY[0x1E0C80C00];
  if (!allocator)
  {
    v6 = _CFGetTSD(1u);
    if (v6)
      v5 = (__objc2_class **)v6;
    else
      v5 = &__kCFAllocatorSystemDefault;
  }
  Instance = _CFRuntimeCreateInstance(v5, 0x39uLL, 72, 0);
  if (Instance)
  {
    if (!locale)
      locale = CFLocaleGetSystem();
    *(_QWORD *)(Instance + 32) = style;
    if ((unint64_t)style >= (kCFNumberFormatterCurrencyAccountingStyle|kCFNumberFormatterDecimalStyle))
    {
      v8 = 1;
      *(_QWORD *)(Instance + 32) = 1;
      if (locale)
        goto LABEL_10;
    }
    else
    {
      v8 = dword_182C8A4B4[style];
      if (locale)
      {
LABEL_10:
        Identifier = CFLocaleGetIdentifier(locale);
        goto LABEL_13;
      }
    }
    Identifier = &stru_1E1337B18;
LABEL_13:
    CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
    if (!CStringPtr && (CStringPtr = buffer, !CFStringGetCString(Identifier, buffer, 768, 0x600u))
      || (v41 = 0,
          v11 = __cficu_unum_open(v8, 0, 0, (uint64_t)CStringPtr, 0, &v41),
          (*(_QWORD *)(Instance + 16) = v11) == 0))
    {
      CFRelease((CFTypeRef)Instance);
      return 0;
    }
    if (style)
    {
      if (locale)
      {
LABEL_18:
        System = (void *)CFRetain(locale);
LABEL_22:
        *(_QWORD *)(Instance + 24) = System;
        v14 = *(_QWORD *)(Instance + 32);
        if (v14 > 9 || ((1 << v14) & 0x2E1) == 0)
        {
          AppleICUNumberFormatStringsPref = (const __CFDictionary *)_CFLocaleGetAppleICUNumberFormatStringsPref(System, v13);
          if (AppleICUNumberFormatStringsPref)
          {
            v24 = AppleICUNumberFormatStringsPref;
            v25 = CFGetTypeID(AppleICUNumberFormatStringsPref);
            if (v25 == CFDictionaryGetTypeID())
            {
              v26 = v14 - 1;
              v27 = v26 > 9 ? CFSTR("0") : (__CFString *)*((_QWORD *)&off_1E12E5AF8 + v26);
              Value = (const __CFString *)CFDictionaryGetValue(v24, v27);
              if (Value)
              {
                v29 = Value;
                v30 = CFGetTypeID(Value);
                if (v30 == CFStringGetTypeID())
                {
                  if (v26 > 9)
                    v31 = 0;
                  else
                    v31 = dword_182C8A4E0[v26];
                  v32 = CFLocaleGetIdentifier(*(CFLocaleRef *)(Instance + 24));
                  v33 = (void *)CFStringGetCStringPtr(v32, 0x600u);
                  if (!v33)
                  {
                    if (CFStringGetCString(v32, v46, 768, 0x600u))
                      v33 = v46;
                    else
                      v33 = 0;
                  }
                  v43 = 0;
                  v34 = __cficu_unum_open(v31, 0, 0, (uint64_t)v33, 0, &v43);
                  if (v34)
                  {
                    v35 = (const void *)v34;
                    v43 = 0;
                    v36 = __cficu_unum_toPattern(v34, 0, chars, 768, &v43);
                    if (v43 <= 0 && v36 <= 768)
                    {
                      v37 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, chars, v36);
                      v43 = 0;
                      v38 = __cficu_unum_toPattern(*(_QWORD *)(Instance + 16), 0, chars, 768, &v43);
                      if (v43 <= 0)
                      {
                        v39 = v38;
                        if (v38 <= 768)
                        {
                          Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
                          CFStringAppendCharacters(Mutable, chars, v39);
                          result.location = 0;
                          result.length = 0;
                          v48.location = 0;
                          v48.length = v39;
                          if (CFStringFindWithOptions(Mutable, v37, v48, 0, &result))
                          {
                            CFStringReplace(Mutable, result, v29);
                            __CFNumberFormatterApplyPattern(Instance, Mutable);
                          }
                          CFRelease(Mutable);
                        }
                      }
                      CFRelease(v37);
                    }
                    __cficu_unum_close(v35);
                  }
                }
              }
            }
          }
        }
        AppleICUNumberSymbolsPref = (const __CFDictionary *)_CFLocaleGetAppleICUNumberSymbolsPref(*(void **)(Instance + 24), v13);
        if (AppleICUNumberSymbolsPref)
        {
          v16 = AppleICUNumberSymbolsPref;
          v17 = CFGetTypeID(AppleICUNumberSymbolsPref);
          if (v17 == CFDictionaryGetTypeID())
            CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)__CFNumberFormatterApplySymbolPrefs, (void *)Instance);
        }
        v18 = *(_QWORD *)(Instance + 32);
        if (v18 > 9 || ((1 << v18) & 0x2E0) == 0)
        {
          v41 = 0;
          v22 = __cficu_unum_toPattern(*(_QWORD *)(Instance + 16), 0, chars, 768, &v41);
          if (v41 <= 0 && v22 <= 768)
            *(_QWORD *)(Instance + 40) = CFStringCreateWithCharacters((CFAllocatorRef)v5, chars, v22);
        }
        v19 = *(const void **)(Instance + 40);
        if (v19)
        {
          *(_QWORD *)(Instance + 48) = CFRetain(v19);
          *(_QWORD *)(Instance + 56) = __CFNumberFormatterCreateCompressedString(*(CFStringRef *)(Instance + 40), 1, 0);
        }
        v20 = *(_QWORD *)(Instance + 32);
        if (v20 > 9 || ((1 << v20) & 0x2E0) == 0)
        {
          *(_DWORD *)chars = __cficu_unum_getAttribute(*(_QWORD *)(Instance + 16), 9);
          if (*(_DWORD *)chars != 1)
          {
            *(_QWORD *)(Instance + 64) = CFNumberCreate((CFAllocatorRef)v5, kCFNumberSInt32Type, chars);
            __cficu_unum_setAttribute(*(_QWORD *)(Instance + 16), 9, 1);
          }
        }
        __cficu_unum_setAttribute(*(_QWORD *)(Instance + 16), 19, 0);
        __cficu_unum_setContext(*(_QWORD *)(Instance + 16), 256, &v41);
        return (CFNumberFormatterRef)Instance;
      }
    }
    else
    {
      v41 = 0;
      __cficu_unum_applyPattern(v11, 0, word_182F202DC, 1, 0, &v41);
      __cficu_unum_setAttribute(*(_QWORD *)(Instance + 16), 3, 42);
      __cficu_unum_setAttribute(*(_QWORD *)(Instance + 16), 6, 0);
      if (locale)
        goto LABEL_18;
    }
    System = CFLocaleGetSystem();
    goto LABEL_22;
  }
  return (CFNumberFormatterRef)Instance;
}

uint64_t __cficu_unum_getAttribute(uint64_t a1, int a2)
{
  uint64_t Attribute;
  CFStringRef v5;
  const char *v6;

  Attribute = unum_getAttribute();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v6 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, CFSTR("unum_getAttribute(%@, %s);
    CFRelease(v5);
  }
  return Attribute;
}

void __cficu_unum_setContext(uint64_t a1, uint64_t a2, int *a3)
{
  CFStringRef v6;
  CFStringRef v7;

  unum_setContext();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v7 = ___CFICUCreateErrorStringWithComment(a3, 1);
    ___CFICULogWithArguments(1, CFSTR("unum_setContext(%@, %d, &%@);"), v6, a2, v7);
    CFRelease(v7);
    CFRelease(v6);
  }
}

uint64_t _CFLocaleGetAppleICUNumberSymbolsPref(void *a1, const char *a2)
{
  return objc_msgSend(a1, "_prefForKey:", CFSTR("AppleICUNumberSymbols"));
}

uint64_t __cficu_unum_open(unsigned int a1, UChar *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v12;
  const void *v13;
  const void *v14;
  CFStringRef v15;
  CFStringRef v16;
  const char *v17;

  v12 = unum_open();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v13 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"numFmt", v12);
    v14 = (const void *)___CFICUCreateVariableNameForStatus(a6);
    v15 = ___CFICUCreateErrorStringWithComment((int *)a6, 1);
    v16 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
    if (a5)
      ___CFICULogWithArguments(1, CFSTR("#warning non-NULL parseErr ignored"));
    if (a1 > 0x11)
      v17 = "<unknown UNumberFormatStyle>";
    else
      v17 = off_1E1334290[a1];
    ___CFICULogWithArguments(1, CFSTR("UNumberFormat *%@ = unum_open(%s, %@, %d, \"%s\", NULL, &%@); %@"),
      v13,
      v17,
      v16,
      a3,
      a4,
      v14,
      v15);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v16);
    CFRelease(v15);
  }
  return v12;
}

CFLocaleRef CFNumberFormatterGetLocale(CFNumberFormatterRef formatter)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 57)
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  return (CFLocaleRef)*((_QWORD *)formatter + 3);
}

void __cficu_unum_setTextAttribute(uint64_t a1, unsigned int a2, UChar *a3, uint64_t a4, int *a5)
{
  CFStringRef v10;
  const void *v11;
  CFStringRef v12;
  CFStringRef v13;
  CFStringRef v14;
  const char *v15;

  unum_setTextAttribute();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v10 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v11 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    v12 = ___CFICUCreateErrorStringWithComment(a5, 1);
    v13 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0);
    v14 = v13;
    if (a2 > 7)
      v15 = "<unknown UNumberFormatTextAttribute>";
    else
      v15 = off_1E1334320[a2];
    ___CFICULogWithArguments(1, CFSTR("unum_setTextAttribute(%@, %s, %@, %d, &%@); %@"), v10, v15, v13, a4, v11, v12);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v14);
    CFRelease(v12);
  }
}

CFStringRef CFNumberFormatterCreateStringWithNumber(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberRef number)
{
  const __CFAllocator *v5;
  uint64_t v6;
  unint64_t v7;
  CFTypeID v8;
  double v9;
  const void *v10;
  const __CFNumber *v12;
  double v13;
  CFNumberType Type2;
  const __CFString *v15;
  size_t v16;
  int v17;
  CFIndex v18;
  int v19;
  UniChar *Typed;
  uint64_t v21;
  size_t v22;
  UniChar *v23;
  const __CFString *Identifier;
  int v25;
  double __y;
  double valuePtr;
  _BYTE v28[2];
  _BYTE v29[1536];
  char __s[768];
  uint64_t v31;

  v5 = allocator;
  v31 = *MEMORY[0x1E0C80C00];
  if (!allocator)
  {
    v6 = _CFGetTSD(1u);
    if (v6)
      v5 = (const __CFAllocator *)v6;
    else
      v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  v7 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v7 != 57)
    _CFAssertMismatchedTypeID(0x39uLL, v7);
  v8 = CFGetTypeID(number);
  if (CF_IS_OBJC(v8, (__objc2_class **)number))
  {
    -[__CFNumber doubleValue](number, "doubleValue");
    if (v9 == 0.0)
    {
      v10 = (const void *)*((_QWORD *)formatter + 9);
      if (v10)
        return (CFStringRef)CFRetain(v10);
    }
    __y = 0.0;
    valuePtr = 1.0;
    v12 = (const __CFNumber *)*((_QWORD *)formatter + 8);
    v13 = 1.0;
    if (v12)
    {
      if (CFNumberGetValue(v12, kCFNumberFloat64Type, &valuePtr))
        v13 = valuePtr;
      else
        valuePtr = 1.0;
    }
    if (modf(v13, &__y) < 0.00000011920929)
    {
      v13 = floor(v13);
      valuePtr = v13;
    }
    if (-[__CFNumber _getCString:length:multiplier:](number, "_getCString:length:multiplier:", __s, 768, v13))
    {
      v25 = 0;
      v16 = strlen(__s);
      v17 = __cficu_unum_formatDecimal(*((_QWORD *)formatter + 2), __s, v16, (uint64_t)v29, 768, 0, &v25);
      v18 = v17;
      v19 = v25;
      if (v25 == 15 || v17 >= 769)
      {
        v21 = v17 + 2;
        Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * v21, 0x1000040BDFB0063, 0);
        v25 = 0;
        v22 = strlen(__s);
        v18 = (int)__cficu_unum_formatDecimal(*((_QWORD *)formatter + 2), __s, v22, (uint64_t)(Typed + 1), v21, 0, &v25);
        v19 = v25;
      }
      else
      {
        Typed = 0;
      }
      if (v19 <= 0)
      {
        if (Typed)
          v23 = Typed;
        else
          v23 = (UniChar *)v28;
        if (*((_BYTE *)formatter + 82)
          && (Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3)),
              CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
        {
          *v23 = 8207;
          ++v18;
        }
        else if (Typed)
        {
          v23 = Typed + 1;
        }
        else
        {
          v23 = (UniChar *)v29;
        }
        v15 = CFStringCreateWithCharacters(v5, v23, v18);
        if (!Typed)
          return v15;
        goto LABEL_25;
      }
      v15 = 0;
      if (Typed)
LABEL_25:
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    Type2 = _CFNumberGetType2((unint64_t *)number);
    CFNumberGetValue(number, Type2, v28);
    return CFNumberFormatterCreateStringWithValue(v5, formatter, Type2, v28);
  }
  return v15;
}

CFStringRef CFNumberFormatterCreateStringWithValue(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFNumberType numberType, const void *valuePtr)
{
  const __CFAllocator *v7;
  uint64_t v8;
  unint64_t v9;
  const __CFNumber *v10;
  double v11;
  const void *v12;
  double v13;
  uint64_t v14;
  float v15;
  float v16;
  int v17;
  CFIndex v18;
  int v19;
  UniChar *Typed;
  uint64_t v21;
  int v22;
  unint64_t v23;
  size_t v24;
  int v25;
  uint64_t v26;
  size_t v27;
  const __CFString *v28;
  UniChar *v29;
  const __CFString *Identifier;
  UniChar *v31;
  char v33;
  __int16 v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  double __y;
  double valuePtra;
  char __s[769];
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _BYTE v52[2];
  _QWORD v53[193];

  v7 = allocator;
  v53[192] = *MEMORY[0x1E0C80C00];
  if (!allocator)
  {
    v8 = _CFGetTSD(1u);
    if (v8)
      v7 = (const __CFAllocator *)v8;
    else
      v7 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  v9 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v9 != 57)
    _CFAssertMismatchedTypeID(0x39uLL, v9);
  __y = 0.0;
  valuePtra = 1.0;
  v10 = (const __CFNumber *)*((_QWORD *)formatter + 8);
  v11 = 1.0;
  if (v10)
  {
    if (CFNumberGetValue(v10, kCFNumberFloat64Type, &valuePtra))
      v11 = valuePtra;
    else
      valuePtra = 1.0;
  }
  if (modf(v11, &__y) < 0.00000011920929)
  {
    v11 = floor(v11);
    valuePtra = v11;
  }
  v45 = 0;
  if ((unint64_t)numberType > kCFNumberDoubleType)
  {
LABEL_28:
    if ((numberType & 0xFFFFFFFFFFFFFFFBLL) != 0xA)
    {
      v28 = 0;
      switch(numberType)
      {
        case kCFNumberSInt8Type:
        case kCFNumberCharType:
          v33 = *(_BYTE *)valuePtr;
          if (!*(_BYTE *)valuePtr)
          {
            v12 = (const void *)*((_QWORD *)formatter + 9);
            if (v12)
              return (CFStringRef)CFRetain(v12);
          }
          if (v11 != 1.0)
            v33 = (int)(v11 * (double)v33);
          v49 = 0;
          v50 = 0;
          v51 = 0;
          _CFBigNumInitWithInt8((uint64_t)&v49, v33);
          goto LABEL_34;
        case kCFNumberSInt16Type:
        case kCFNumberShortType:
          v34 = *(_WORD *)valuePtr;
          if (!*(_WORD *)valuePtr)
          {
            v12 = (const void *)*((_QWORD *)formatter + 9);
            if (v12)
              return (CFStringRef)CFRetain(v12);
          }
          if (v11 != 1.0)
            v34 = (int)(v11 * (double)v34);
          v49 = 0;
          v50 = 0;
          v51 = 0;
          _CFBigNumInitWithInt16((uint64_t)&v49, v34);
          goto LABEL_34;
        case kCFNumberSInt32Type:
        case kCFNumberIntType:
          if (!*(_DWORD *)valuePtr)
          {
            v12 = (const void *)*((_QWORD *)formatter + 9);
            if (v12)
              return (CFStringRef)CFRetain(v12);
          }
          if (v11 == 1.0)
            v35 = *(_DWORD *)valuePtr;
          else
            v35 = (int)(v11 * (double)*(int *)valuePtr);
          v49 = 0;
          v50 = 0;
          v51 = 0;
          _CFBigNumInitWithInt32((uint64_t)&v49, v35);
          goto LABEL_34;
        case kCFNumberMaxType|kCFNumberSInt8Type:
          v38 = valuePtr;
          v36 = *(_QWORD *)valuePtr;
          v37 = v38[1];
          if (!(v37 | v36))
          {
            v12 = (const void *)*((_QWORD *)formatter + 9);
            if (v12)
              return (CFStringRef)CFRetain(v12);
          }
          v39 = v37;
          v40 = v36;
          *(_OWORD *)&v41 = (__int128)(v11 * (double)*(__int128 *)&v39);
          if (v11 == 1.0)
            v43 = v37;
          else
            v43 = v41;
          if (v11 == 1.0)
            v44 = v36;
          else
            v44 = v42;
          v49 = 0;
          v50 = 0;
          v51 = 0;
          _CFBigNumInitWithInt128((uint64_t)&v49, v43, v44);
          goto LABEL_34;
        default:
          return v28;
      }
      return v28;
    }
LABEL_29:
    if (*(_QWORD *)valuePtr || (v12 = (const void *)*((_QWORD *)formatter + 9)) == 0)
    {
      if (v11 == 1.0)
        v23 = *(_QWORD *)valuePtr;
      else
        v23 = (uint64_t)(v11 * (double)*(uint64_t *)valuePtr);
      v49 = 0;
      v50 = 0;
      v51 = 0;
      _CFBigNumInitWithInt64((uint64_t)&v49, v23);
LABEL_34:
      _CFBigNumToCString((uint64_t)&v49, 0, 1, __s, 0x300uLL);
      v45 = 0;
      v24 = strlen(__s);
      v25 = __cficu_unum_formatDecimal(*((_QWORD *)formatter + 2), __s, v24, (uint64_t)v53, 768, 0, &v45);
      v18 = v25;
      if (v45 != 15 && v25 < 769)
      {
        Typed = 0;
LABEL_39:
        v19 = v45;
        goto LABEL_40;
      }
      v26 = v25 + 2;
      Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * v26, 0x1000040BDFB0063, 0);
      v45 = 0;
      v27 = strlen(__s);
      v22 = __cficu_unum_formatDecimal(*((_QWORD *)formatter + 2), __s, v27, (uint64_t)(Typed + 1), v26, 0, &v45);
LABEL_38:
      v18 = v22;
      goto LABEL_39;
    }
    return (CFStringRef)CFRetain(v12);
  }
  if (((1 << numberType) & 0x810) != 0)
    goto LABEL_29;
  if (((1 << numberType) & 0x1020) == 0)
  {
    if (((1 << numberType) & 0x2040) != 0)
    {
      if (*(double *)valuePtr != 0.0 || (v12 = (const void *)*((_QWORD *)formatter + 9)) == 0)
      {
        v13 = *(double *)valuePtr * v11;
        v14 = *((_QWORD *)formatter + 2);
        goto LABEL_24;
      }
      return (CFStringRef)CFRetain(v12);
    }
    goto LABEL_28;
  }
  v15 = *(float *)valuePtr;
  if (*(float *)valuePtr == 0.0)
  {
    v12 = (const void *)*((_QWORD *)formatter + 9);
    if (v12)
      return (CFStringRef)CFRetain(v12);
  }
  if (v11 != 1.0)
  {
    v16 = v11 * v15;
    v15 = v16;
  }
  v14 = *((_QWORD *)formatter + 2);
  v13 = v15;
LABEL_24:
  v17 = __cficu_unum_formatDouble(v14, (uint64_t)v53, 768, 0, &v45, v13);
  v18 = v17;
  v19 = v45;
  if (v45 == 15 || v17 >= 769)
  {
    v21 = v17 + 2;
    Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * v21, 0x1000040BDFB0063, 0);
    v45 = 0;
    v22 = __cficu_unum_formatDouble(*((_QWORD *)formatter + 2), (uint64_t)(Typed + 1), v21, 0, &v45, v13);
    goto LABEL_38;
  }
  Typed = 0;
LABEL_40:
  if (v19 > 0)
  {
    v28 = 0;
    if (!Typed)
      return v28;
    goto LABEL_54;
  }
  if (Typed)
    v29 = Typed;
  else
    v29 = (UniChar *)v52;
  if (*((_BYTE *)formatter + 82)
    && (Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3)),
        CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
  {
    *v29 = 8207;
    ++v18;
  }
  else
  {
    if (Typed)
      v31 = Typed;
    else
      v31 = (UniChar *)v52;
    v29 = v31 + 1;
  }
  v28 = CFStringCreateWithCharacters(v7, v29, v18);
  if (Typed)
LABEL_54:
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  return v28;
}

uint64_t __cficu_unum_formatDecimal(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  uint64_t v14;
  CFStringRef v15;
  const void *v16;
  CFTypeRef v17;
  CFStringRef v18;
  int v19;
  void *v20;
  const void *v21;

  v14 = unum_formatDecimal();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v15 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v16 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a7);
    v17 = ___CFICUCreateVariableNameForUCharOutput("result", a4, a5);
    v18 = ___CFICUCreateErrorStringWithComment(a7, 1);
    if (a2)
    {
      v19 = a3;
      if ((_DWORD)a3 == -1)
        v19 = strlen(a2);
      v20 = (void *)CFStringCreateWithBytes(0, (const UInt8 *)a2, v19, 0x8000100u, 0);
    }
    else
    {
      v20 = (void *)CFRetain(CFSTR("NULL"));
    }
    v21 = v20;
    if (a6)
      ___CFICULogWithArguments(1, CFSTR("#warning non-NULL pos ignored."));
    ___CFICULogWithArguments(1, CFSTR("unum_formatDecimal(%@, \"%@\", %d, %@, %d, NULL, &%@); %@"),
      v15,
      v21,
      a3,
      v17,
      a5,
      v16,
      v18);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
    CFRelease(v21);
    CFRelease(v18);
  }
  return v14;
}

uint64_t __cficu_unum_formatDouble(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12;
  CFStringRef v13;
  const void *v14;
  CFTypeRef v15;
  CFStringRef v16;
  CFStringRef v17;

  v12 = unum_formatDouble();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    v15 = ___CFICUCreateVariableNameForUCharOutput("result", a2, a3);
    v16 = ___CFICUCreateArgumentForDouble(a6);
    v17 = ___CFICUCreateErrorStringWithComment(a5, 1);
    if (a4)
      ___CFICULogWithArguments(1, CFSTR("#warning non-NULL pos ignored."));
    ___CFICULogWithArguments(1, CFSTR("unum_formatDouble(%@, %@, %@, %d, NULL, &%@); %@"), v13, v16, v15, a3, v14, v17);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
  }
  return v12;
}

void *_CFBigNumToCString(uint64_t a1, int a2, int a3, char *a4, size_t a5)
{
  size_t v5;
  char *v6;
  char v8;
  size_t v9;
  char *i;
  const char *v12;
  char __str[46];
  uint64_t v14;

  v5 = a5;
  v6 = a4;
  v14 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a1 + 20) & 0x80) != 0)
  {
    v8 = 45;
  }
  else
  {
    if (!a3)
      goto LABEL_6;
    v8 = 43;
  }
  *a4 = v8;
  v6 = a4 + 1;
  v5 = a5 - 1;
LABEL_6:
  snprintf(__str, 0x2EuLL, "%09u%09u%09u%09u%09u", *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 4), *(_DWORD *)a1);
  if (a2)
  {
    memset(v6, 48, v5);
    if (v5 >= 0x2E)
      v9 = 46;
    else
      v9 = v5;
    return memmove(&v6[v5 - v9], &__str[-v9 + 46], v9);
  }
  else
  {
    for (i = __str; *i == 48; ++i)
      ;
    if (*i)
      v12 = i;
    else
      v12 = i - 1;
    return (void *)strlcpy(v6, v12, v5);
  }
}

uint64_t _CFBigNumInitWithInt64(uint64_t result, unint64_t a2)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  if ((a2 & 0x8000000000000000) != 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -(uint64_t)a2;
  }
  *(_DWORD *)result = a2 % 0xDE0B6B3A7640000 % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 % 0xDE0B6B3A7640000 / 0x3B9ACA00;
  *(_DWORD *)(result + 8) = a2 / 0xDE0B6B3A7640000;
  return result;
}

uint64_t _CFLocaleGetAppleICUNumberFormatStringsPref(void *a1, const char *a2)
{
  return objc_msgSend(a1, "_prefForKey:", CFSTR("AppleICUNumberFormatStrings"));
}

uint64_t _CFBigNumInitWithInt32(uint64_t result, unsigned int a2)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  if ((a2 & 0x80000000) != 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -a2;
  }
  *(_DWORD *)result = a2 % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 / 0x3B9ACA00;
  return result;
}

__n128 _CFBigNumInitWithInt128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned __int32 v8;
  __n128 result;

  LODWORD(v3) = a2;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  if (a3 < 0)
  {
    *(_DWORD *)(a1 + 20) |= 0xFFu;
    v3 = -a2;
  }
  v5 = __udivti3();
  v6 = __udivti3();
  v7 = __udivti3();
  v8 = __udivti3();
  result.n128_u32[0] = 1486618624 * v7 + 402653184 * v6 + v3 - 1000000000 * v8;
  result.n128_u32[1] = v8;
  result.n128_u64[1] = __PAIR64__(v6, v7);
  *(__n128 *)a1 = result;
  *(_DWORD *)(a1 + 16) = v5;
  return result;
}

void __cficu_unum_setSymbol(uint64_t a1, unsigned int a2, UChar *a3, uint64_t a4, int *a5)
{
  CFStringRef v10;
  const void *v11;
  CFStringRef v12;
  CFStringRef v13;
  const char *v14;

  unum_setSymbol();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v10 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v11 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    v12 = ___CFICUCreateErrorStringWithComment(a5, 1);
    v13 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0);
    v14 = ___CFICUGetEnumStringForUNumberFormatSymbol(a2);
    ___CFICULogWithArguments(1, CFSTR("unum_setSymbol(%@, %s, %@, %d, &%@); %@"), v10, v14, v13, a4, v11, v12);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v13);
    CFRelease(v12);
  }
}

void __cficu_unum_setDoubleAttribute(uint64_t a1, int a2, double a3)
{
  CFStringRef v6;
  CFStringRef v7;
  const char *v8;

  unum_setDoubleAttribute();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v7 = ___CFICUCreateArgumentForDouble(a3);
    v8 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, CFSTR("unum_setDoubleAttribute(%@, %s, %@);"), v6, v8, v7);
    CFRelease(v6);
    CFRelease(v7);
  }
}

uint64_t CompareLocaleToLegacyCodesEntries(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

id _NSObjectLoadWeak(id *a1, _BYTE *a2)
{
  if (*a2)
    return *a1;
  else
    return objc_loadWeakRetained(a1);
}

CFBitVectorRef CFBitVectorCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex numBits)
{
  return (CFBitVectorRef)__CFBitVectorInit((__objc2_class **)allocator, 0, bytes, numBits);
}

void _CFSetSetCapacity(__objc2_class **a1, uint64_t a2)
{
  if (!CF_IS_OBJC(0x11uLL, a1))
    CFBasicHashSetCapacity((uint64_t)a1, a2);
}

uint64_t __CFStartSearchPathEnumeration()
{
  return sysdir_start_search_path_enumeration_private();
}

CFRunLoopTimerRef CFRunLoopTimerCreateWithHandler(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, void *block)
{
  CFRunLoopTimerContext v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v7.version = 0;
  v7.info = block;
  v7.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C80928];
  v7.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C80958];
  v7.copyDescription = 0;
  return CFRunLoopTimerCreate(allocator, fireDate, interval, flags, order, (CFRunLoopTimerCallBack)_runLoopTimerWithBlockContext, &v7);
}

CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double v15;
  double v16;
  double v17;
  __objc2_class **v18;
  uint64_t Instance;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  double v25;
  uint64_t v26;
  double Current;
  double v28;
  double v29;
  uint64_t v30;
  uint64_t (*v31)(uint64_t);
  pthread_mutexattr_t v33;
  uint64_t v34;

  v7 = MEMORY[0x1E0C80A78](allocator, flags);
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v18 = (__objc2_class **)v7;
  v34 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  Instance = _CFRuntimeCreateInstance(v18, 0x2FuLL, 176, 0);
  v20 = Instance;
  if (Instance)
  {
    v21 = (unint64_t *)(Instance + 8);
    v22 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      v23 = __ldaxr(v21);
      if (v23 != v22)
        break;
      if (__stlxr(v22 | 8, v21))
        goto LABEL_11;
      v24 = 1;
LABEL_12:
      v22 = v23;
      if (v24)
      {
        *(_WORD *)(Instance + 16) &= ~1u;
        *(_QWORD *)v33.__opaque = 0;
        v33.__sig = 0;
        pthread_mutexattr_init(&v33);
        pthread_mutexattr_settype(&v33, 2);
        pthread_mutex_init((pthread_mutex_t *)(v20 + 24), &v33);
        pthread_mutexattr_destroy(&v33);
        *(_QWORD *)(v20 + 88) = 0;
        *(_QWORD *)(v20 + 96) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
        *(_QWORD *)(v20 + 136) = v13;
        if (v15 < 0.0)
          v15 = 0.0;
        *(_QWORD *)(v20 + 120) = 0;
        if (v17 <= 4039289860.0)
          v25 = v17;
        else
          v25 = 4039289860.0;
        *(double *)(v20 + 104) = v25;
        *(double *)(v20 + 112) = v15;
        v26 = mach_absolute_time();
        Current = CFAbsoluteTimeGetCurrent();
        v28 = Current;
        if (v25 >= Current)
        {
          v29 = v25 - Current;
          if (v25 - v28 > 504911232.0)
            v29 = 504911232.0;
          *(_QWORD *)(v20 + 128) = __CFTimeIntervalToTSR(v29) + v26;
        }
        else
        {
          *(_QWORD *)(v20 + 128) = v26;
        }
        *(_QWORD *)(v20 + 144) = v11;
        if (v9)
        {
          v30 = v9[1];
          v31 = (uint64_t (*)(uint64_t))v9[2];
          if (v31)
            v30 = v31(v30);
          *(_QWORD *)(v20 + 160) = v30;
          *(_OWORD *)(v20 + 168) = *((_OWORD *)v9 + 1);
          *(_QWORD *)(v20 + 184) = v9[4];
        }
        kdebug_trace();
        return (CFRunLoopTimerRef)v20;
      }
    }
    __clrex();
LABEL_11:
    v24 = 0;
    goto LABEL_12;
  }
  return (CFRunLoopTimerRef)v20;
}

uint64_t __CFRunLoopTimerDeallocate(uint64_t a1)
{
  *(_WORD *)(a1 + 16) |= 4u;
  CFRunLoopTimerInvalidate((CFRunLoopTimerRef)a1);
  CFRelease(*(CFTypeRef *)(a1 + 96));
  *(_QWORD *)(a1 + 96) = 0;
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 24));
}

void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer)
{
  unint64_t *v2;
  char v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  CFIndex Count;
  uint64_t v10;
  unint64_t v11;
  const void **v12;
  size_t v13;
  const void **v14;
  CFIndex v15;
  const void *v16;
  const __CFString **v17;
  CFIndex v18;
  const __CFString *v19;
  const void *v20;
  void (*v21)(uint64_t);
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (CF_IS_OBJC(0x2FuLL, (__objc2_class **)timer))
  {
    -[__CFRunLoopTimer invalidate](timer, "invalidate");
    return;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
  if ((*((_WORD *)timer + 8) & 4) == 0)
    CFRetain(timer);
  v2 = (unint64_t *)((char *)timer + 8);
  v3 = atomic_load((unint64_t *)timer + 1);
  if ((v3 & 8) != 0)
  {
    v4 = *((_QWORD *)timer + 11);
    v5 = *((_QWORD *)timer + 20);
    *((_QWORD *)timer + 20) = 0;
    v6 = atomic_load(v2);
    while (1)
    {
      v7 = __ldaxr(v2);
      if (v7 != v6)
        break;
      if (__stlxr(v6 & 0xFFFFFFFFFFFFFFF7, v2))
        goto LABEL_15;
      v8 = 1;
LABEL_16:
      v6 = v7;
      if (v8)
      {
        if (v4)
        {
          Count = CFSetGetCount(*((CFSetRef *)timer + 12));
          MEMORY[0x1E0C80A78](Count, v10);
          v12 = (const void **)((char *)v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0));
          if (v11 >= 0x200)
            v13 = 512;
          else
            v13 = v11;
          bzero((char *)v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0), v13);
          CFSetGetValues(*((CFSetRef *)timer + 12), v12);
          if (Count >= 1)
          {
            v14 = v12;
            v15 = Count;
            do
            {
              v16 = *v14++;
              CFRetain(v16);
              --v15;
            }
            while (v15);
          }
          CFRetain((CFTypeRef)v4);
          pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
          pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
          if (Count < 1)
          {
            CFRunLoopRemoveTimer((CFRunLoopRef)v4, timer, CFSTR("kCFRunLoopCommonModes"));
            pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
          }
          else
          {
            v17 = (const __CFString **)v12;
            v18 = Count;
            do
            {
              v19 = *v17++;
              CFRunLoopRemoveTimer((CFRunLoopRef)v4, timer, v19);
              --v18;
            }
            while (v18);
            CFRunLoopRemoveTimer((CFRunLoopRef)v4, timer, CFSTR("kCFRunLoopCommonModes"));
            pthread_mutex_unlock((pthread_mutex_t *)(v4 + 16));
            do
            {
              v20 = *v12++;
              CFRelease(v20);
              --Count;
            }
            while (Count);
          }
          CFRelease((CFTypeRef)v4);
          pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
        }
        v21 = (void (*)(uint64_t))*((_QWORD *)timer + 22);
        if (v21)
          v21(v5);
        goto LABEL_34;
      }
    }
    __clrex();
LABEL_15:
    v8 = 0;
    goto LABEL_16;
  }
LABEL_34:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
  if ((*((_WORD *)timer + 8) & 4) == 0)
    CFRelease(timer);
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  char v6;
  unsigned __int8 v7;
  unint64_t v8;
  char v9;
  __CFRunLoop *v10;
  uint64_t v11;
  CFSetRef Copy;
  pthread_mutex_t *v13;
  const __CFSet *v14;
  __CFRunLoop *v15;
  __CFSet *Mutable;
  CFArrayCallBacks v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v6 = atomic_load((unint64_t *)rl + 1);
  if ((v6 & 4) == 0)
  {
    v7 = atomic_load(__CFMainThreadHasExited);
    if ((v7 & 1) != 0 && CFRunLoopGetMain() == rl)
    {
      if (CFRunLoopAddTimer_onceToken != -1)
        dispatch_once(&CFRunLoopAddTimer_onceToken, &__block_literal_global_22);
      _CFRunLoopError_MainThreadHasExited();
    }
    else
    {
      v8 = _CFGetNonObjCTypeID((unint64_t *)rl);
      if (v8 != 43)
        _CFAssertMismatchedTypeID(0x2BuLL, v8);
      v9 = atomic_load((unint64_t *)timer + 1);
      if ((v9 & 8) != 0)
      {
        v10 = (__CFRunLoop *)*((_QWORD *)timer + 11);
        if (!v10 || v10 == rl)
        {
          pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
          if (mode == CFSTR("kCFRunLoopCommonModes"))
          {
            v14 = (const __CFSet *)*((_QWORD *)rl + 76);
            if (v14)
              Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14);
            else
              Copy = 0;
            Mutable = (__CFSet *)*((_QWORD *)rl + 77);
            if (!Mutable)
            {
              Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
              *((_QWORD *)rl + 77) = Mutable;
            }
            CFSetAddValue(Mutable, timer);
            if (!Copy)
              goto LABEL_32;
            v17.version = (CFIndex)rl;
            v17.retain = (CFArrayRetainCallBack)timer;
            CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemToCommonModes, &v17);
            goto LABEL_31;
          }
          v11 = __CFRunLoopCopyMode((uint64_t)rl, mode, 1);
          if (!v11)
          {
LABEL_32:
            pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
            return;
          }
          Copy = (CFSetRef)v11;
          v13 = (pthread_mutex_t *)(v11 + 16);
          pthread_mutex_lock((pthread_mutex_t *)(v11 + 16));
          if (!*((_QWORD *)Copy + 15))
          {
            *(_OWORD *)&v17.version = *(_OWORD *)&kCFTypeArrayCallBacks.version;
            *(_OWORD *)&v17.release = *(_OWORD *)&kCFTypeArrayCallBacks.release;
            v17.equal = 0;
            *((_QWORD *)Copy + 15) = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &v17);
          }
          if (CFSetContainsValue(*((CFSetRef *)timer + 12), *((const void **)Copy + 10)))
          {
LABEL_17:
            pthread_mutex_unlock(v13);
LABEL_31:
            CFRelease(Copy);
            goto LABEL_32;
          }
          pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
          v15 = (__CFRunLoop *)*((_QWORD *)timer + 11);
          if (v15)
          {
            if (v15 != rl)
            {
              pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
              goto LABEL_17;
            }
          }
          else
          {
            *((_QWORD *)timer + 11) = rl;
          }
          CFSetAddValue(*((CFMutableSetRef *)timer + 12), *((const void **)Copy + 10));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
          os_unfair_lock_lock((os_unfair_lock_t)rl + 171);
          __CFRepositionTimerInMode((uint64_t)Copy, timer, 0);
          os_unfair_lock_unlock((os_unfair_lock_t)rl + 171);
          if (!_CFExecutableLinkedOnOrAfter(7uLL) && _CFRunLoopGetButDontCreateCurrent() != rl)
            CFRunLoopWakeUp(rl);
          goto LABEL_17;
        }
      }
    }
  }
}

void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  unint64_t v6;
  uint64_t v7;
  CFSetRef Copy;
  pthread_mutex_t *v9;
  const __CFArray *v10;
  CFIndex FirstIndexOfValue;
  CFIndex v12;
  const __CFSet *v13;
  const __CFSet *v14;
  _QWORD context[3];
  CFRange v16;

  context[2] = *MEMORY[0x1E0C80C00];
  v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == CFSTR("kCFRunLoopCommonModes"))
  {
    v13 = (const __CFSet *)*((_QWORD *)rl + 77);
    if (v13 && CFSetContainsValue(v13, timer))
    {
      v14 = (const __CFSet *)*((_QWORD *)rl + 76);
      if (!v14)
      {
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), timer);
        goto LABEL_21;
      }
      Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14);
      CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), timer);
      if (Copy)
      {
        context[0] = rl;
        context[1] = timer;
        CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveItemFromCommonModes, context);
LABEL_14:
        CFRelease(Copy);
      }
    }
  }
  else
  {
    v7 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
    if (v7)
    {
      Copy = (CFSetRef)v7;
      v9 = (pthread_mutex_t *)(v7 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v7 + 16));
      v10 = (const __CFArray *)*((_QWORD *)Copy + 15);
      if (v10)
      {
        v16.length = CFArrayGetCount(*((CFArrayRef *)Copy + 15));
        v16.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v10, v16, timer);
        if (FirstIndexOfValue != -1)
        {
          v12 = FirstIndexOfValue;
          pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
          CFSetRemoveValue(*((CFMutableSetRef *)timer + 12), *((const void **)Copy + 10));
          if (!CFSetGetCount(*((CFSetRef *)timer + 12)))
            *((_QWORD *)timer + 11) = 0;
          pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
          CFArrayRemoveValueAtIndex(v10, v12);
          __CFArmNextTimerInMode((uint64_t)Copy);
        }
      }
      pthread_mutex_unlock(v9);
      goto LABEL_14;
    }
  }
LABEL_21:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
}

void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate)
{
  unint64_t *v2;
  double v3;
  double v4;
  unint64_t *v5;
  unint64_t v6;
  char v7;
  double v8;
  uint64_t v9;
  double Current;
  double v11;
  double v12;
  CFIndex Count;
  uint64_t v14;
  unint64_t v15;
  const void **v16;
  size_t v17;
  const void **v18;
  CFIndex v19;
  const void *v20;
  char *v21;
  const __CFString **v22;
  CFIndex v23;
  const __CFString *v24;
  uint64_t *v25;
  CFIndex v26;
  char *v27;
  _QWORD v28[520];

  v2 = (unint64_t *)((uint64_t (*)(CFRunLoopTimerRef))MEMORY[0x1E0C80A78])(timer);
  v4 = v3;
  v5 = v2;
  v28[518] = *MEMORY[0x1E0C80C00];
  v6 = _CFGetNonObjCTypeID(v2);
  if (v6 != 47)
    _CFAssertMismatchedTypeID(0x2FuLL, v6);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v7 = atomic_load(v5 + 1);
  if ((v7 & 8) != 0)
  {
    if (v4 <= 4039289860.0)
      v8 = v4;
    else
      v8 = 4039289860.0;
    v9 = mach_absolute_time();
    Current = CFAbsoluteTimeGetCurrent();
    v11 = Current;
    if (v8 >= Current)
    {
      v12 = v8 - Current;
      if (v8 - v11 > 504911232.0)
        v12 = 504911232.0;
      v9 += __CFTimeIntervalToTSR(v12);
    }
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 3));
    if (v5[11])
    {
      Count = CFSetGetCount((CFSetRef)v5[12]);
      MEMORY[0x1E0C80A78](Count, v14);
      v16 = (const void **)((char *)v28 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0));
      if (v15 >= 0x200)
        v17 = 512;
      else
        v17 = v15;
      bzero((char *)v28 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0), v17);
      CFSetGetValues((CFSetRef)v5[12], v16);
      if (Count >= 1)
      {
        v18 = v16;
        v19 = Count;
        do
        {
          v20 = *v18++;
          CFRetain(v20);
          --v19;
        }
        while (v19);
      }
      v21 = (char *)CFRetain((CFTypeRef)v5[11]);
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 3));
      pthread_mutex_lock((pthread_mutex_t *)(v21 + 16));
      if (Count < 1)
      {
        os_unfair_lock_lock((os_unfair_lock_t)v21 + 171);
        v5[16] = v9;
        *((double *)v5 + 13) = v8;
        os_unfair_lock_unlock((os_unfair_lock_t)v21 + 171);
      }
      else
      {
        v28[0] = v28;
        v22 = (const __CFString **)v16;
        v23 = Count;
        do
        {
          v24 = *v22;
          *v22 = (const __CFString *)__CFRunLoopCopyMode((uint64_t)v21, *v22, 0);
          ++v22;
          CFRelease(v24);
          --v23;
        }
        while (v23);
        os_unfair_lock_lock((os_unfair_lock_t)v21 + 171);
        v5[16] = v9;
        *((double *)v5 + 13) = v8;
        v25 = (uint64_t *)v16;
        v26 = Count;
        do
        {
          if (*v25)
            __CFRepositionTimerInMode(*v25, v5, 1);
          ++v25;
          --v26;
        }
        while (v26);
        os_unfair_lock_unlock((os_unfair_lock_t)v21 + 171);
        do
        {
          v27 = (char *)*v16;
          if (*v16)
          {
            pthread_mutex_unlock((pthread_mutex_t *)(v27 + 16));
            CFRelease(v27);
          }
          ++v16;
          --Count;
        }
        while (Count);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v21 + 16));
      if (!v21 || _CFRunLoopGetButDontCreateCurrent() != v21)
        CFRunLoopWakeUp((CFRunLoopRef)v21);
      CFRelease(v21);
    }
    else
    {
      v5[16] = v9;
      *((double *)v5 + 13) = v8;
      pthread_mutex_unlock((pthread_mutex_t *)(v5 + 3));
    }
    kdebug_trace();
  }
}

void __CFRepositionTimerInMode(uint64_t a1, const void *a2, int a3)
{
  const __CFArray *v4;
  const __CFArray *v6;
  CFIndex FirstIndexOfValue;
  CFIndex v8;
  CFIndex v9;
  CFIndex v10;
  CFRange v11;

  if (a2)
  {
    v4 = *(const __CFArray **)(a1 + 120);
    if (v4)
    {
      v6 = *(const __CFArray **)(a1 + 120);
      if (a3)
      {
        v11.length = CFArrayGetCount(v6);
        v11.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v11, a2);
        if (FirstIndexOfValue != -1)
        {
          v8 = FirstIndexOfValue;
          CFRetain(a2);
          CFArrayRemoveValueAtIndex(v4, v8);
          v9 = __CFRunLoopInsertionIndexInTimerArray(v4, (uint64_t)a2);
          CFArrayInsertValueAtIndex(v4, v9, a2);
          __CFArmNextTimerInMode(a1);
          CFRelease(a2);
        }
      }
      else
      {
        v10 = __CFRunLoopInsertionIndexInTimerArray(v6, (uint64_t)a2);
        CFArrayInsertValueAtIndex(v4, v10, a2);
        __CFArmNextTimerInMode(a1);
      }
    }
  }
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length;
  CFIndex location;
  const CFArrayCallBacks *v7;
  uint64_t v8;
  CFIndex i;
  const void *v10;
  unsigned int (*equal)(const void *, const void *);
  unsigned int v12;
  int v13;
  char v14;
  int v15;
  const CFArrayCallBacks *v16;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
    goto LABEL_2;
  v12 = atomic_load((unint64_t *)theArray + 1);
  v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
LABEL_2:
      v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }
    v14 = atomic_load((unint64_t *)theArray + 1);
    v15 = v14 & 3;
    if (v15)
      v16 = 0;
    else
      v16 = (const CFArrayCallBacks *)((char *)theArray + 48);
    if (v15 == 2)
      v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    else
      v7 = v16;
  }
  else
  {
    v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_3:
  if (length < 1)
    return -1;
  v8 = 0;
  for (i = location; ; ++i)
  {
    v10 = (const void *)-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", i);
    if (v10 == value)
      break;
    equal = (unsigned int (*)(const void *, const void *))v7->equal;
    if (equal && equal(value, v10))
      return i;
    ++v8;
    if (!--length)
      return -1;
  }
  return v8 + location;
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
    -[__CFArray removeObjectAtIndex:](theArray, "removeObjectAtIndex:", idx);
  else
    _CFArrayReplaceValues((unint64_t)theArray, idx, 1, 0, 0);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  v6[0] = value;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
    -[__CFArray insertObject:atIndex:](theArray, "insertObject:atIndex:", value, idx);
  else
    _CFArrayReplaceValues((unint64_t)theArray, idx, 0, v6, 1);
}

BOOL __CFDataEqual(unint64_t *a1, unint64_t *a2)
{
  size_t v2;
  char v3;
  const void *v4;
  char v6;
  const void *v7;

  v2 = a1[2];
  if (v2 != a2[2])
    return 0;
  v3 = atomic_load(a1 + 1);
  if ((v3 & 4) != 0)
    v4 = (const void *)(((unint64_t)a1 + 63) & 0xFFFFFFFFFFFFFFF0);
  else
    v4 = (const void *)a1[5];
  v6 = atomic_load(a2 + 1);
  if ((v6 & 4) != 0)
    v7 = (const void *)(((unint64_t)a2 + 63) & 0xFFFFFFFFFFFFFFF0);
  else
    v7 = (const void *)a2[5];
  return v4 == v7 || memcmp(v4, v7, v2) == 0;
}

uint64_t _CFNonObjCEqual(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  _UNKNOWN **v37;
  uint64_t (*v38)(unint64_t *, unint64_t *);

  if (a1 == a2)
    return 1;
  if (!a2)
    _CFNonObjCEqual_cold_1();
  if (((unint64_t)a2 & 0x8000000000000000) != 0)
  {
    v4 = 0;
    v5 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)a2 & 0xC000000000000007) == 0)
      v5 = 0;
    v6 = v5 ^ (unint64_t)a2;
    do
    {
      if ((v6 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v4))
        break;
      ++v4;
    }
    while (v4 != 7);
    v7 = v4 | v6;
    v8 = v4 & 7;
    v9 = (v7 >> 55) + 8;
    if (v8 == 7)
      LODWORD(v8) = v9;
    v10 = 22;
    switch((int)v8)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          _CFNonObjCEqual_cold_5();
        goto LABEL_19;
      case 1:
        goto LABEL_20;
      case 2:
        goto LABEL_18;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_19;
      case 6:
        v10 = 42;
        break;
      default:
        if ((_DWORD)v8 == 20)
        {
LABEL_19:
          v10 = 1;
        }
        else if ((_DWORD)v8 == 22)
        {
LABEL_18:
          v10 = 7;
        }
        else
        {
LABEL_20:
          v10 = objc_msgSend(a2, "_cfTypeID");
        }
        break;
    }
  }
  else
  {
    v12 = atomic_load(a2 + 1);
    v10 = (v12 >> 8) & 0x3FF;
  }
  if (CF_IS_OBJC(v10, (__objc2_class **)a2))
    return objc_msgSend(a2, "isEqual:", a1);
  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    v13 = 0;
    v14 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0)
      v14 = 0;
    v15 = v14 ^ (unint64_t)a1;
    do
    {
      if ((v15 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v13))
        break;
      ++v13;
    }
    while (v13 != 7);
    v16 = v13 | v15;
    v17 = v13 & 7;
    v18 = (v16 >> 55) + 8;
    if (v17 == 7)
      LODWORD(v17) = v18;
    v19 = 22;
    switch((int)v17)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          _CFNonObjCEqual_cold_4();
        goto LABEL_39;
      case 1:
        goto LABEL_40;
      case 2:
        goto LABEL_38;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_39;
      case 6:
        v19 = 42;
        break;
      default:
        if ((_DWORD)v17 == 20)
        {
LABEL_39:
          v19 = 1;
        }
        else if ((_DWORD)v17 == 22)
        {
LABEL_38:
          v19 = 7;
        }
        else
        {
LABEL_40:
          v19 = objc_msgSend(a1, "_cfTypeID");
        }
        break;
    }
  }
  else
  {
    v20 = atomic_load(a1 + 1);
    v19 = (v20 >> 8) & 0x3FF;
  }
  if (((unint64_t)a2 & 0x8000000000000000) != 0)
  {
    v21 = 0;
    v22 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)a2 & 0xC000000000000007) == 0)
      v22 = 0;
    v23 = v22 ^ (unint64_t)a2;
    do
    {
      if ((v23 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v21))
        break;
      ++v21;
    }
    while (v21 != 7);
    v24 = v21 | v23;
    v25 = v21 & 7;
    v26 = (v24 >> 55) + 8;
    if (v25 == 7)
      LODWORD(v25) = v26;
    v27 = 22;
    switch((int)v25)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          _CFNonObjCEqual_cold_3();
        goto LABEL_57;
      case 1:
        goto LABEL_58;
      case 2:
        goto LABEL_56;
      case 3:
        goto LABEL_60;
      case 4:
      case 5:
        goto LABEL_57;
      case 6:
        v27 = 42;
        goto LABEL_60;
      default:
        if ((_DWORD)v25 == 20)
        {
LABEL_57:
          v27 = 1;
        }
        else if ((_DWORD)v25 == 22)
        {
LABEL_56:
          v27 = 7;
        }
        else
        {
LABEL_58:
          v27 = objc_msgSend(a2, "_cfTypeID");
        }
        break;
    }
  }
  else
  {
    v28 = atomic_load(a2 + 1);
    v27 = (v28 >> 8) & 0x3FF;
  }
  if (v19 != v27)
    return 0;
LABEL_60:
  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    v29 = 0;
    v30 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0)
      v30 = 0;
    v31 = v30 ^ (unint64_t)a1;
    do
    {
      if ((v31 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v29))
        break;
      ++v29;
    }
    while (v29 != 7);
    v32 = v29 | v31;
    v33 = v29 & 7;
    v34 = (v32 >> 55) + 8;
    if (v33 == 7)
      LODWORD(v33) = v34;
    v35 = 22;
    switch((int)v33)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          _CFNonObjCEqual_cold_2();
        goto LABEL_78;
      case 1:
        goto LABEL_79;
      case 2:
        goto LABEL_77;
      case 3:
        goto LABEL_81;
      case 4:
      case 5:
        goto LABEL_78;
      case 6:
        v35 = 42;
        goto LABEL_81;
      default:
        if ((_DWORD)v33 == 20)
        {
LABEL_78:
          v35 = 1;
          goto LABEL_81;
        }
        if ((_DWORD)v33 == 22)
        {
LABEL_77:
          v35 = 7;
          goto LABEL_81;
        }
LABEL_79:
        v35 = objc_msgSend(a1, "_cfTypeID");
        break;
    }
  }
  else
  {
    v36 = atomic_load(a1 + 1);
    v35 = (v36 >> 8) & 0x3FF;
  }
  if (v35 <= 0x47)
LABEL_81:
    v37 = &__CFRuntimeBuiltinClassTable + v35;
  else
    v37 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v35 - 72) >> 6] + 8 * (((_DWORD)v35 - 72) & 0x3F));
  v38 = (uint64_t (*)(unint64_t *, unint64_t *))*((_QWORD *)*v37 + 5);
  if (v38)
    return v38(a1, a2);
  else
    return 0;
}

void __CFArmNextTimerInMode(uint64_t a1)
{
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v4;
  CFIndex v5;
  unint64_t v6;
  unint64_t v7;
  const void *ValueAtIndex;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  dispatch_time_t v13;
  dispatch_time_t v14;

  v2 = *(const __CFArray **)(a1 + 120);
  if (!v2)
  {
    v7 = -1;
    v6 = -1;
    goto LABEL_34;
  }
  Count = CFArrayGetCount(v2);
  if (Count < 1)
  {
    v6 = -1;
  }
  else
  {
    v4 = Count;
    v5 = 0;
    v6 = -1;
    v7 = -1;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 120), v5);
      if ((*((_WORD *)ValueAtIndex + 8) & 1) == 0)
      {
        v9 = *((_QWORD *)ValueAtIndex + 16);
        v10 = __CFTimeIntervalToTSR(*((double *)ValueAtIndex + 15));
        if (v9 > v6)
          break;
        v11 = v9 + v10;
        if (__CFADD__(v9, v10))
          v11 = -1;
        if (v9 < v7)
          v7 = v9;
        if (v11 < v6)
          v6 = v11;
      }
      ++v5;
    }
    while (v4 != v5);
    if (v7 != -1)
    {
      if (v6 != *(_QWORD *)(a1 + 192) || v7 != *(_QWORD *)(a1 + 184))
      {
        mach_absolute_time();
        kdebug_trace();
        v12 = __CFTSRToNanoseconds(v6 - v7);
        v13 = __CFTSRToDispatchTime(v7);
        if (v12)
        {
          v14 = v13;
          if (*(_BYTE *)(a1 + 176) && *(_DWORD *)(a1 + 172))
          {
            mk_timer_cancel();
            *(_BYTE *)(a1 + 176) = 0;
          }
          dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 152), v14, 0xFFFFFFFFFFFFFFFFLL, v12);
          *(_BYTE *)(a1 + 169) = 1;
        }
        else
        {
          if (*(_BYTE *)(a1 + 169))
          {
            dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 152), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x378uLL);
            *(_BYTE *)(a1 + 169) = 0;
          }
          if (*(_DWORD *)(a1 + 172))
          {
            mk_timer_arm();
            *(_BYTE *)(a1 + 176) = 1;
          }
        }
      }
      goto LABEL_34;
    }
  }
  if (*(_BYTE *)(a1 + 176) && *(_DWORD *)(a1 + 172))
  {
    mk_timer_cancel();
    *(_BYTE *)(a1 + 176) = 0;
  }
  v7 = -1;
  if (*(_BYTE *)(a1 + 169))
  {
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 152), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x14DuLL);
    *(_BYTE *)(a1 + 169) = 0;
  }
LABEL_34:
  *(_QWORD *)(a1 + 184) = v7;
  *(_QWORD *)(a1 + 192) = v6;
}

unint64_t __CFTimeIntervalToTSR(double a1)
{
  if (CFDateGetTypeID_initOnce != -1)
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
  if (*(double *)&__CFTSRRate * a1 <= 4.61168602e18)
    return (unint64_t)(*(double *)&__CFTSRRate * a1);
  else
    return 0x3FFFFFFFFFFFFFFFLL;
}

uint64_t __CFRunLoopInsertionIndexInTimerArray(const __CFArray *a1, uint64_t a2)
{
  CFIndex Count;
  uint64_t v5;
  _QWORD *ValueAtIndex;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  BOOL v13;
  _BOOL8 v14;

  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v5 = Count;
  if ((unint64_t)Count >= 0x101)
  {
    if (*((_QWORD *)CFArrayGetValueAtIndex(a1, Count - 1) + 16) <= *(_QWORD *)(a2 + 128))
      return v5;
    ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
    result = 0;
    if (*(_QWORD *)(a2 + 128) < ValueAtIndex[16])
      return result;
  }
  v8 = 0;
  v9 = 2 << flsl(v5);
  do
  {
    if (v9 >= 0)
      v10 = v9;
    else
      v10 = v9 + 1;
    if (v8 + (v10 >> 1) >= v5)
    {
      v14 = 0;
    }
    else
    {
      v11 = *((_QWORD *)CFArrayGetValueAtIndex(a1, v8 + (v10 >> 1)) + 16);
      v12 = *(_QWORD *)(a2 + 128);
      v13 = v11 > v12;
      v14 = v11 <= v12;
      if (!v13)
        v8 += v10 >> 1;
    }
    v13 = v9 <= 1;
    v9 = v10 >> 1;
  }
  while (!v13);
  return v14 + v8;
}

dispatch_time_t __CFTSRToDispatchTime(unint64_t a1)
{
  unint64_t v1;
  int64_t v2;

  v1 = vcvtmd_u64_f64(*(double *)&__CF1_TSRRate * (double)a1 * 1000000000.0);
  if (v1 >= 0x7FFFFFFFFFFFFFFELL)
    v2 = 0x7FFFFFFFFFFFFFFELL;
  else
    v2 = v1;
  return dispatch_time(1uLL, v2);
}

unint64_t __CFTSRToNanoseconds(unint64_t a1)
{
  return vcvtmd_u64_f64(*(double *)&__CF1_TSRRate * (double)a1 * 1000000000.0);
}

const void *_CFRunLoopIsCurrent(const void *result)
{
  if (result)
    return (const void *)(_CFRunLoopGetButDontCreateCurrent() == result);
  return result;
}

const void *_CFRunLoopGetButDontCreateCurrent()
{
  const void *result;
  _opaque_pthread_t *v1;

  result = (const void *)_CFGetTSDCreateIfNeeded(0xAu, 0);
  if (!result)
  {
    v1 = pthread_self();
    return _CFRunLoopCacheLookup(v1, 0);
  }
  return result;
}

void CFAttributedStringSetAttributes(CFMutableAttributedStringRef aStr, CFRange range, CFDictionaryRef replacement, Boolean clearOtherAttributes)
{
  __objc2_class **v4;
  int v5;
  int v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  int v14;
  const __CFAllocator *v15;
  CFMutableDictionaryRef AttributesDictionary;
  unint64_t Count;
  unint64_t v18;
  const void **v19;
  const void **v20;
  __CFDictionary *ValueAtIndex;
  __CFDictionary *v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  const void **v26;
  const void **v27;
  unint64_t v28;
  const void *v29;
  const void *v30;
  const void *v31;
  uint64_t v32;
  const __CFAllocator *v33;
  __CFDictionary *v34;
  const void **v35;
  const void **v36;
  unint64_t v37;
  const void *v38;
  const void *v39;
  const void *v40;
  uint64_t v41;
  uint64_t v42;
  void *values[2];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  void *keys[2];
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  uint64_t v107;

  v4 = (__objc2_class **)MEMORY[0x1E0C80A78](aStr, range.location);
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v13 = (uint64_t *)v4;
  v107 = *MEMORY[0x1E0C80C00];
  v14 = CF_IS_OBJC(0x3EuLL, v4);
  if (v6)
  {
    if (v14)
    {
      objc_msgSend(v13, "setAttributes:range:", v8, v12, v10);
    }
    else if (v10)
    {
      v15 = CFGetAllocator(v13);
      AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v15, v8);
      CFRunArrayReplace((_QWORD *)v13[3], v12, v10, AttributesDictionary, v10);
      CFRelease(AttributesDictionary);
    }
    return;
  }
  if (v14)
  {
    objc_msgSend(v13, "addAttributes:range:", v8, v12, v10);
    return;
  }
  Count = CFDictionaryGetCount(v8);
  if (Count)
  {
    v18 = Count;
    v106 = 0u;
    v105 = 0u;
    v104 = 0u;
    v103 = 0u;
    v102 = 0u;
    v101 = 0u;
    v100 = 0u;
    v99 = 0u;
    v98 = 0u;
    v97 = 0u;
    v96 = 0u;
    v95 = 0u;
    v94 = 0u;
    v93 = 0u;
    v92 = 0u;
    v91 = 0u;
    v90 = 0u;
    v89 = 0u;
    v88 = 0u;
    v87 = 0u;
    v86 = 0u;
    v85 = 0u;
    v84 = 0u;
    v83 = 0u;
    v82 = 0u;
    v81 = 0u;
    v80 = 0u;
    v79 = 0u;
    v78 = 0u;
    v77 = 0u;
    v76 = 0u;
    *(_OWORD *)keys = 0u;
    if (Count >= 0xFFFFFFFFFFFFFFFLL)
      CFAttributedStringSetAttributes_cold_1();
    if (Count > 0x100)
    {
      v20 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
      v73 = 0u;
      v74 = 0u;
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v55 = 0u;
      v56 = 0u;
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      v49 = 0u;
      v50 = 0u;
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      *(_OWORD *)values = 0u;
      v44 = 0u;
      v19 = (const void **)malloc_type_malloc(8 * v18, 0xC0040B8AA526DuLL);
    }
    else
    {
      v73 = 0uLL;
      v74 = 0uLL;
      v71 = 0uLL;
      v72 = 0uLL;
      v69 = 0uLL;
      v70 = 0uLL;
      v67 = 0uLL;
      v68 = 0uLL;
      v65 = 0uLL;
      v66 = 0uLL;
      v63 = 0uLL;
      v64 = 0uLL;
      v61 = 0uLL;
      v62 = 0uLL;
      v59 = 0uLL;
      v60 = 0uLL;
      v57 = 0uLL;
      v58 = 0uLL;
      v55 = 0uLL;
      v56 = 0uLL;
      v53 = 0uLL;
      v54 = 0uLL;
      v51 = 0uLL;
      v52 = 0uLL;
      v49 = 0uLL;
      v50 = 0uLL;
      v47 = 0uLL;
      v48 = 0uLL;
      v45 = 0uLL;
      v46 = 0uLL;
      v19 = (const void **)values;
      v20 = (const void **)keys;
      *(_OWORD *)values = 0uLL;
      v44 = 0uLL;
    }
    CFDictionaryGetKeysAndValues(v8, v20, v19);
    if (v10)
    {
      while (1)
      {
        v41 = 0;
        v42 = 0;
        ValueAtIndex = (__CFDictionary *)CFRunArrayGetValueAtIndex(v13[3], v12, &v41, 0);
        v22 = ValueAtIndex;
        v24 = v41;
        v23 = v42;
        v25 = v41 == v12 && v42 <= v10;
        if (!v25)
          goto LABEL_23;
        v26 = v20;
        v27 = v19;
        v28 = v18;
        if (CFGetRetainCount(ValueAtIndex) != 1)
          break;
        do
        {
          v30 = *v26++;
          v29 = v30;
          v31 = *v27++;
          CFDictionarySetValue(v22, v29, v31);
          --v28;
        }
        while (v28);
LABEL_31:
        v12 += v42;
        v10 -= v42;
        if (!v10)
          goto LABEL_32;
      }
      v24 = v41;
      v23 = v42;
LABEL_23:
      v25 = v24 < v12;
      v32 = v24 - v12;
      if (v25)
      {
        v23 += v32;
        v41 = v12;
        v42 = v23;
      }
      if (v23 > v10)
        v42 = v10;
      v33 = CFGetAllocator(v13);
      v34 = __CFAttributedStringCreateAttributesDictionary(v33, v22);
      v35 = v20;
      v36 = v19;
      v37 = v18;
      do
      {
        v39 = *v35++;
        v38 = v39;
        v40 = *v36++;
        CFDictionarySetValue(v34, v38, v40);
        --v37;
      }
      while (v37);
      CFRunArrayReplace((_QWORD *)v13[3], v41, v42, v34, v42);
      CFRelease(v34);
      goto LABEL_31;
    }
LABEL_32:
    if (v20 != (const void **)keys)
      free(v20);
    if (v19 != (const void **)values)
      free(v19);
  }
}

CFArrayRef _arrayDeepImmutableCopy(const __CFAllocator *a1, CFArrayRef theArray)
{
  unint64_t Count;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *Typed;
  size_t v10;
  unint64_t v12;
  CFPropertyListRef DeepCopy;
  CFArrayRef v14;
  const void **v15;
  const void *v16;
  _QWORD v17[2];
  CFRange v18;

  v17[1] = *MEMORY[0x1E0C80C00];
  Count = CFArrayGetCount(theArray);
  if (!Count)
    return CFArrayCreate(a1, 0, 0, &kCFTypeArrayCallBacks);
  v6 = Count;
  if (Count >> 60)
    _arrayDeepImmutableCopy_cold_1();
  MEMORY[0x1E0C80A78](Count, v5);
  Typed = (char *)v17 - v8;
  if (v7 >= 0x200)
    v10 = 512;
  else
    v10 = v7;
  bzero((char *)v17 - v8, v10);
  if (v6 > 0x100)
  {
    Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v6, 0xC0040B8AA526DLL, 0);
    if (!Typed)
      _arrayDeepImmutableCopy_cold_2();
  }
  else
  {
    bzero(Typed, 8 * v6);
  }
  v18.location = 0;
  v18.length = v6;
  CFArrayGetValues(theArray, v18, (const void **)Typed);
  v12 = 0;
  while (1)
  {
    DeepCopy = CFPropertyListCreateDeepCopy(a1, *(CFPropertyListRef *)&Typed[8 * v12], 0);
    if (!DeepCopy)
      break;
    *(_QWORD *)&Typed[8 * v12++] = DeepCopy;
    if (v6 == v12)
    {
      v12 = v6;
      goto LABEL_15;
    }
  }
  if (v6 == v12)
  {
LABEL_15:
    v14 = CFArrayCreate(a1, (const void **)Typed, v6, &kCFTypeArrayCallBacks);
    if (!v12)
      goto LABEL_20;
    goto LABEL_18;
  }
  v14 = 0;
  if (!v12)
    goto LABEL_20;
LABEL_18:
  v15 = (const void **)Typed;
  do
  {
    v16 = *v15++;
    CFRelease(v16);
    --v12;
  }
  while (v12);
LABEL_20:
  if (v6 >= 0x101)
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  return v14;
}

CFPropertyListRef CFPropertyListCreateDeepCopy(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  CFMutableArrayRef Mutable;
  CFTypeID v7;
  unint64_t Count;
  uint64_t v9;
  CFIndex v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *Typed;
  size_t v15;
  CFAbsoluteTime AbsoluteTime;
  CFIndex v18;
  CFIndex v19;
  const void *ValueAtIndex;
  CFPropertyListRef DeepCopy;
  const void *v22;
  CFNumberType Type2;
  const void **v24;
  uint64_t v25;
  CFStringRef Copy;
  CFPropertyListRef v27;
  CFMutableDictionaryRef v29;
  uint64_t i;
  const void **v31;
  CFIndex v32;
  _QWORD valuePtr[2];
  __int128 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  valuePtr[0] = 1;
  v34 = 0u;
  v35 = 0;
  valuePtr[1] = 200;
  Mutable = 0;
  if (__CFPropertyListIsValidAux(propertyList, valuePtr))
  {
    if (((unint64_t)propertyList & 0x8000000000000000) == 0 || mutabilityOption == 2)
    {
      v7 = CFGetTypeID(propertyList);
      switch(v7)
      {
        case 0x12uLL:
          Count = CFDictionaryGetCount((CFDictionaryRef)propertyList);
          if (!Count)
          {
            if (mutabilityOption)
              return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            else
              return CFDictionaryCreate(allocator, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          }
          v10 = Count;
          if (((Count >> 59) & 0xF) != 0)
            CFPropertyListCreateDeepCopy_cold_1();
          v11 = 2 * Count;
          MEMORY[0x1E0C80A78](Count, v9);
          Typed = (char *)valuePtr - v13;
          if (v12 >= 0x200)
            v15 = 512;
          else
            v15 = v12;
          bzero((char *)valuePtr - v13, v15);
          if (v11 > 0x100)
          {
            Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 16 * v10, 0xC0040B8AA526DLL, 0);
            if (!Typed)
              CFPropertyListCreateDeepCopy_cold_2();
          }
          else
          {
            bzero(Typed, 16 * v10);
          }
          v24 = (const void **)&Typed[8 * v10];
          CFDictionaryGetKeysAndValues((CFDictionaryRef)propertyList, (const void **)Typed, v24);
          if (v10 < 1)
            goto LABEL_55;
          v25 = 0;
          break;
        case 0x13uLL:
          if (!mutabilityOption)
            return _arrayDeepImmutableCopy(allocator, (CFArrayRef)propertyList);
          v18 = CFArrayGetCount((CFArrayRef)propertyList);
          Mutable = CFArrayCreateMutable(allocator, 0, &kCFTypeArrayCallBacks);
          if (!Mutable)
            return Mutable;
          if (v18 < 1)
          {
            v19 = 0;
          }
          else
          {
            v19 = 0;
            while (1)
            {
              ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)propertyList, v19);
              DeepCopy = CFPropertyListCreateDeepCopy(allocator, ValueAtIndex, mutabilityOption);
              if (!DeepCopy)
                break;
              v22 = DeepCopy;
              CFArrayAppendValue(Mutable, DeepCopy);
              CFRelease(v22);
              if (v18 == ++v19)
                return Mutable;
            }
          }
          if (v19 == v18)
            return Mutable;
          CFRelease(Mutable);
          return 0;
        case 0x14uLL:
          if (mutabilityOption == 2)
            return CFDataCreateMutableCopy(allocator, 0, (CFDataRef)propertyList);
          else
            return CFDataCreateCopy(allocator, (CFDataRef)propertyList);
        case 0x15uLL:
          CFRetain(propertyList);
          return propertyList;
        case 0x16uLL:
          Type2 = _CFNumberGetType2((unint64_t *)propertyList);
          CFNumberGetValue((CFNumberRef)propertyList, Type2, valuePtr);
          return CFNumberCreate(allocator, Type2, valuePtr);
        default:
          if (v7 == 7)
          {
            if (mutabilityOption == 2)
              return CFStringCreateMutableCopy(allocator, 0, (CFStringRef)propertyList);
            else
              return CFStringCreateCopy(allocator, (CFStringRef)propertyList);
          }
          else
          {
            if (v7 != 42)
              return 0;
            AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)propertyList);
            return CFDateCreate(allocator, AbsoluteTime);
          }
      }
      while (1)
      {
        Copy = CFStringCreateCopy(allocator, *(CFStringRef *)&Typed[8 * v25]);
        if (!Copy)
          break;
        *(_QWORD *)&Typed[8 * v25] = Copy;
        v27 = CFPropertyListCreateDeepCopy(allocator, v24[v25], mutabilityOption);
        if (!v27)
        {
          CFRelease(*(CFTypeRef *)&Typed[8 * v25]);
          break;
        }
        v24[v25++] = v27;
        if (v10 == v25)
          goto LABEL_50;
      }
      if (v10 == v25)
      {
LABEL_50:
        if (mutabilityOption)
          v29 = CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        else
          v29 = CFDictionaryCreate(allocator, (const void **)Typed, (const void **)&Typed[8 * v10], v10, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        Mutable = v29;
        v31 = (const void **)Typed;
        v32 = v10;
        do
        {
          if (mutabilityOption)
            CFDictionarySetValue(Mutable, *v31, v31[v10]);
          CFRelease(*v31);
          CFRelease(v31[v10]);
          ++v31;
          --v32;
        }
        while (v32);
        goto LABEL_61;
      }
      if (v25)
      {
        for (i = 0; i != v25; ++i)
        {
          CFRelease(*(CFTypeRef *)&Typed[8 * i]);
          CFRelease(v24[i]);
        }
      }
LABEL_55:
      Mutable = 0;
LABEL_61:
      if (v11 >= 0x101)
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
    else
    {
      return propertyList;
    }
  }
  return Mutable;
}

void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  char v6;
  unsigned __int8 v7;
  unint64_t v8;
  char v9;
  __CFRunLoop *v10;
  uint64_t v11;
  CFSetRef Copy;
  pthread_mutex_t *v13;
  const __CFArray *v14;
  CFIndex v15;
  CFIndex v16;
  _QWORD *ValueAtIndex;
  const __CFSet *v18;
  __CFSet *Mutable;
  _QWORD context[3];
  CFRange v21;

  context[2] = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v6 = atomic_load((unint64_t *)rl + 1);
  if ((v6 & 4) == 0)
  {
    v7 = atomic_load(__CFMainThreadHasExited);
    if ((v7 & 1) != 0 && CFRunLoopGetMain() == rl)
    {
      if (CFRunLoopAddObserver_onceToken != -1)
        dispatch_once(&CFRunLoopAddObserver_onceToken, &__block_literal_global_19);
      _CFRunLoopError_MainThreadHasExited();
    }
    else
    {
      v8 = _CFGetNonObjCTypeID((unint64_t *)rl);
      if (v8 != 43)
        _CFAssertMismatchedTypeID(0x2BuLL, v8);
      v9 = atomic_load((unint64_t *)observer + 1);
      if ((v9 & 8) != 0)
      {
        v10 = (__CFRunLoop *)*((_QWORD *)observer + 10);
        if (!v10 || v10 == rl)
        {
          pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
          if (mode == CFSTR("kCFRunLoopCommonModes"))
          {
            v18 = (const __CFSet *)*((_QWORD *)rl + 76);
            if (v18)
              Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v18);
            else
              Copy = 0;
            Mutable = (__CFSet *)*((_QWORD *)rl + 77);
            if (!Mutable)
            {
              Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
              *((_QWORD *)rl + 77) = Mutable;
            }
            CFSetAddValue(Mutable, observer);
            if (!Copy)
              goto LABEL_33;
            context[0] = rl;
            context[1] = observer;
            CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemToCommonModes, context);
          }
          else
          {
            v11 = __CFRunLoopCopyMode((uint64_t)rl, mode, 1);
            if (!v11)
            {
LABEL_33:
              pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
              return;
            }
            Copy = (CFSetRef)v11;
            v13 = (pthread_mutex_t *)(v11 + 16);
            pthread_mutex_lock((pthread_mutex_t *)(v11 + 16));
            v14 = (const __CFArray *)*((_QWORD *)Copy + 14);
            if (!v14)
            {
              v14 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
              *((_QWORD *)Copy + 14) = v14;
            }
            v21.length = CFArrayGetCount(v14);
            v21.location = 0;
            if (!CFArrayContainsValue(v14, v21, observer))
            {
              v15 = CFArrayGetCount(*((CFArrayRef *)Copy + 14)) + 1;
              do
              {
                v16 = v15 - 1;
                if (v15 == 1)
                  break;
                ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)Copy + 14), v15 - 2);
                v15 = v16;
              }
              while (ValueAtIndex[13] > *((_QWORD *)observer + 13));
              CFArrayInsertValueAtIndex(*((CFMutableArrayRef *)Copy + 14), v16, observer);
              *((_QWORD *)Copy + 18) |= *((_QWORD *)observer + 12);
              __CFRunLoopObserverSchedule((uint64_t)observer, (uint64_t)rl);
            }
            pthread_mutex_unlock(v13);
          }
          CFRelease(Copy);
          goto LABEL_33;
        }
      }
    }
  }
}

CFSetRef CFSetCreateCopy(CFAllocatorRef allocator, CFSetRef theSet)
{
  uint64_t Copy;
  const __CFSet *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  int v10;

  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
    return (CFSetRef)-[__CFSet copyWithZone:](theSet, "copyWithZone:", 0);
  Copy = CFBasicHashCreateCopy((__objc2_class **)allocator, (uint64_t)theSet);
  v6 = (const __CFSet *)Copy;
  if (!Copy)
    return v6;
  v7 = (unint64_t *)(Copy + 8);
  v8 = atomic_load((unint64_t *)(Copy + 8));
  do
  {
    v9 = __ldaxr(v7);
    if (v9 == v8)
    {
      if (!__stlxr(v8 | 0x40, v7))
      {
        v10 = 1;
        goto LABEL_10;
      }
    }
    else
    {
      __clrex();
    }
    v10 = 0;
LABEL_10:
    v8 = v9;
  }
  while (!v10);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)Copy, 0x11uLL);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  return v6;
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  uint64_t v3;
  __objc2_class **v4;
  __objc2_class **v5;
  __objc2_class **v6;
  CFIndex Count;
  const void **v8;
  void **Typed;
  objc_class **Copy;
  uint64_t Generic;
  CFIndex i;
  _OWORD v14[128];
  void *values[2];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;

  v3 = MEMORY[0x1E0C80A78](allocator, capacity);
  v5 = v4;
  v6 = (__objc2_class **)v3;
  v47 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x12uLL, v4))
  {
    if (&__kCFAllocatorSystemDefault == v6
      || !v6 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault())
    {
      return (CFMutableDictionaryRef)objc_msgSend(v5, "_cfMutableCopy");
    }
    Count = CFDictionaryGetCount((CFDictionaryRef)v5);
    v46 = 0u;
    v45 = 0u;
    v44 = 0u;
    v43 = 0u;
    v42 = 0u;
    v41 = 0u;
    v40 = 0u;
    v39 = 0u;
    v38 = 0u;
    v37 = 0u;
    v36 = 0u;
    v35 = 0u;
    v34 = 0u;
    v33 = 0u;
    v32 = 0u;
    v31 = 0u;
    v30 = 0u;
    v29 = 0u;
    v28 = 0u;
    v27 = 0u;
    v26 = 0u;
    v25 = 0u;
    v24 = 0u;
    v23 = 0u;
    v22 = 0u;
    v21 = 0u;
    v20 = 0u;
    v19 = 0u;
    v18 = 0u;
    v17 = 0u;
    v16 = 0u;
    *(_OWORD *)values = 0u;
    memset(v14, 0, 512);
    if (Count >= 257)
    {
      Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
      v8 = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
    }
    else
    {
      v8 = (const void **)v14;
      Typed = values;
    }
    CFDictionaryGetKeysAndValues((CFDictionaryRef)v5, v8, (const void **)Typed);
    Generic = __CFDictionaryCreateGeneric(v6, (uint64_t)&kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    Copy = (objc_class **)Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (i = 0; i < Count; ++i)
        CFBasicHashAddValue((uint64_t)Copy, (unint64_t)v8[i], (uint64_t)Typed[i]);
    }
    if (v8 != (const void **)v14 && v8 != (const void **)Typed)
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v8);
    if (Typed != values)
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
  else
  {
    Copy = (objc_class **)CFBasicHashCreateCopy(v6, (uint64_t)v5);
  }
  if (Copy)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 0x12uLL);
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
  }
  return (CFMutableDictionaryRef)Copy;
}

uint64_t CFBasicHashCreateCopy(__objc2_class **a1, uint64_t a2)
{
  __int16 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t Typed;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t Instance;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(const CFAllocatorRef, uint64_t);
  const CFAllocatorRef *v26;
  char v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t (*v32)(const CFAllocatorRef, uint64_t);
  const CFAllocatorRef *v33;
  char v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  void *__src;
  const CFAllocatorRef *v41;

  v4 = *(_WORD *)(a2 + 18);
  v5 = 56;
  if ((v4 & 4) == 0)
    v5 = 48;
  if ((v4 & 0x18) != 0)
    v6 = v5 + 8;
  else
    v6 = v5;
  v7 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a2 + 26)];
  if (v7 < 1)
  {
    v9 = 0;
    v10 = 0;
    goto LABEL_21;
  }
  if ((unint64_t)(v7 - 0x1000000000000000) >> 61 != 7)
    goto LABEL_82;
  Typed = CFAllocatorAllocateTyped(a1, 8 * v7, 1211813924, 0);
  if (!Typed)
    return 0;
  v9 = Typed;
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  if ((*(_WORD *)(a2 + 18) & 4) != 0)
  {
    v11 = CFAllocatorAllocateTyped(a1, 8 * v7, 1211813924, 0);
    if (!v11)
      return 0;
    v10 = v11;
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
  }
  else
  {
    v10 = 0;
  }
  v12 = *(unsigned __int16 *)(a2 + 18);
  if ((v12 & 0x18) == 0)
  {
LABEL_21:
    v14 = 0;
    goto LABEL_22;
  }
  v13 = CFAllocatorAllocateTyped(a1, v7 << ((v12 >> 5) & 3), 1211813924, 0);
  if (!v13)
    return 0;
  v14 = (void *)v13;
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
LABEL_22:
  Instance = _CFRuntimeCreateInstance(a1, 3uLL, v6 - 16, 0);
  v16 = Instance;
  if (Instance)
  {
    v17 = *(_QWORD *)(a2 + 32);
    *(_OWORD *)(Instance + 16) = *(_OWORD *)(a2 + 16);
    *(_QWORD *)(Instance + 32) = v17 & 0xFFFFFFFFFFFFFFF7;
    *(_WORD *)(Instance + 16) = 1;
    if (v7)
    {
      v18 = *(unsigned __int16 *)(a2 + 18);
      if ((v18 & 4) != 0)
        v19 = *(_QWORD *)(a2 + 8 * ((v18 >> 2) & 1) + 40);
      else
        v19 = 0;
      if ((v18 & 0x18) != 0)
        v20 = *(void **)(a2 + (v18 & 0x18) + 40);
      else
        v20 = 0;
      v21 = *(_QWORD *)(a2 + 40);
      *(_QWORD *)(Instance + 40) = v9;
      if (v10)
        *(_QWORD *)(Instance + 8 * (((unint64_t)*(unsigned __int16 *)(Instance + 18) >> 2) & 1) + 40) = v10;
      __src = v20;
      if (v14)
        *(_QWORD *)(Instance + (*(_WORD *)(Instance + 18) & 0x18) + 40) = v14;
      if (v7 >= 1)
      {
        v22 = 0;
        v41 = (const CFAllocatorRef *)(Instance - 16);
        do
        {
          v23 = *(_QWORD *)(v21 + 8 * v22);
          if ((unint64_t)(v23 - 1) > 0xFFFFFFFFFFFFFFFDLL)
          {
            *(_QWORD *)(*(_QWORD *)(v16 + 40) + 8 * v22) = v23;
            if (v10)
            {
              v38 = *(unsigned __int16 *)(v16 + 18);
              if ((v38 & 4) == 0)
                goto LABEL_81;
              *(_QWORD *)(*(_QWORD *)(v16 + 8 * ((v38 >> 2) & 1) + 40) + 8 * v22) = v23;
            }
          }
          else
          {
            if (v23 == 2814029233)
              v23 = 0;
            if (v23 == 2780474809)
              v24 = -1;
            else
              v24 = v23;
            if ((*(_QWORD *)(v16 + 32) & 2) == 0)
            {
              v25 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(v16 + 24) >> 39) & 0x1FLL]
                                                                            + 8
                                                                            * ((*(_QWORD *)(v16 + 24) >> 34) & 0x1FLL));
              if (v25)
              {
                v26 = &kCFAllocatorSystemDefault;
                if ((v16 & 0x8000000000000000) == 0)
                {
                  v27 = atomic_load((unint64_t *)(v16 + 8));
                  v28 = (v27 & 0x80) == 0;
                  v26 = v41;
                  if (!v28)
                    v26 = &kCFAllocatorSystemDefault;
                }
                v24 = v25(*v26, v24);
              }
            }
            if (v24)
              v29 = v24;
            else
              v29 = 2814029233;
            if (v29 == -1)
              v29 = 2780474809;
            *(_QWORD *)(*(_QWORD *)(v16 + 40) + 8 * v22) = v29;
            if (v10)
            {
              v30 = *(_QWORD *)(v19 + 8 * v22);
              if (v30 == 2814029233)
                v30 = 0;
              if (v30 == 2780474809)
                v31 = -1;
              else
                v31 = v30;
              if ((*(_QWORD *)(v16 + 32) & 2) == 0)
              {
                v32 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(v16 + 27) >> 5) & 0x1F]
                                                                              + 8 * (*(_DWORD *)(v16 + 27) & 0x1FLL));
                if (v32)
                {
                  v33 = &kCFAllocatorSystemDefault;
                  if ((v16 & 0x8000000000000000) == 0)
                  {
                    v34 = atomic_load((unint64_t *)(v16 + 8));
                    v28 = (v34 & 0x80) == 0;
                    v33 = v41;
                    if (!v28)
                      v33 = &kCFAllocatorSystemDefault;
                  }
                  v31 = v32(*v33, v31);
                }
              }
              v35 = *(unsigned __int16 *)(v16 + 18);
              if ((v35 & 4) == 0)
              {
LABEL_81:
                __break(1u);
LABEL_82:
                CFBasicHashCreateCopy_cold_1();
              }
              v36 = *(_QWORD *)(v16 + 8 * ((v35 >> 2) & 1) + 40);
              if (v31)
                v37 = v31;
              else
                v37 = 2814029233;
              if (v37 == -1)
                v37 = 2780474809;
              *(_QWORD *)(v36 + 8 * v22) = v37;
            }
          }
          ++v22;
        }
        while (v7 != v22);
      }
      if (v14 && __src)
        memmove(v14, __src, v7 << (((unint64_t)*(unsigned __int16 *)(v16 + 18) >> 5) & 3));
    }
  }
  return v16;
}

_DWORD *_NSDictionaryI_mutableCopyWithZone(_QWORD *a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  char *v7;
  char *v8;
  _DWORD *v9;
  size_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = a1[1] & 0x1FFFFFFFFFFFFFFLL;
  if (v3)
    v4 = 2 * v3;
  else
    v4 = 1;
  v5 = MEMORY[0x1E0C80A78](v4, a2);
  v7 = (char *)&v11 - v6;
  v11 = 0;
  if (v3 >= 0x81)
  {
    v7 = (char *)_CFCreateArrayStorage(v5, 0, &v11);
    v8 = v7;
  }
  else
  {
    v8 = 0;
  }
  objc_msgSend(a1, "getObjects:andKeys:count:", &v7[8 * v3], v7, v3, v11, v12);
  v9 = __NSDictionaryM_new((uint64_t)v7, (uint64_t)&v7[8 * v3], v3, 2uLL);
  free(v8);
  return v9;
}

void sub_182B297F8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t __CFRunLoopObserverSchedule(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;

  v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v5 = *(_QWORD *)(a1 + 88);
  if (!v5)
    *(_QWORD *)(a1 + 80) = a2;
  *(_QWORD *)(a1 + 88) = v5 + 1;
  return pthread_mutex_unlock(v4);
}

dispatch_data_t _CFDataCreateDispatchData(void *a1)
{
  const __CFAllocator *v3;
  CFDataRef Copy;
  const UInt8 *BytePtr;
  size_t v6;
  _QWORD v7[6];

  v7[5] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)a1))
    return (dispatch_data_t)objc_msgSend(a1, "_createDispatchData");
  v3 = CFGetAllocator(a1);
  Copy = CFDataCreateCopy(v3, (CFDataRef)a1);
  BytePtr = CFDataGetBytePtr(Copy);
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)Copy))
    v6 = -[__CFData length](Copy, "length");
  else
    v6 = *((_QWORD *)Copy + 2);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = ___CFDataCreateDispatchData_block_invoke;
  v7[3] = &__block_descriptor_40_e5_v8__0l;
  v7[4] = Copy;
  return dispatch_data_create(BytePtr, v6, 0, v7);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  char v5;
  _BOOL4 ShouldUseAllocator;
  const __CFAllocator *v7;
  CFAllocatorRef v8;
  char v9;
  const CFAllocatorRef *v10;
  char v11;
  uint64_t v12;
  const UInt8 *BytePtr;
  char v14;

  if (!dyld_program_sdk_at_least())
    goto LABEL_25;
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
    return (CFDataRef)-[__CFData copy](theData, "copy");
  v5 = atomic_load((unint64_t *)theData + 1);
  if ((v5 & 1) == 0)
  {
    ShouldUseAllocator = __CFDataShouldUseAllocator((__objc2_class **)allocator);
    v7 = 0;
    if (ShouldUseAllocator)
      v8 = allocator;
    else
      v8 = 0;
    v9 = atomic_load((unint64_t *)theData + 1);
    if ((v9 & 8) != 0)
    {
      if (((unint64_t)theData & 0x8000000000000000) != 0)
      {
        v10 = &kCFAllocatorSystemDefault;
      }
      else
      {
        v11 = atomic_load((unint64_t *)theData + 1);
        if (v11 < 0)
          v10 = &kCFAllocatorSystemDefault;
        else
          v10 = (const CFAllocatorRef *)((char *)theData - 16);
      }
      v7 = *v10;
    }
    if (v8 == v7)
    {
      v14 = atomic_load((unint64_t *)theData + 1);
      if ((v14 & 4) != 0 || !*((_QWORD *)theData + 4))
        return (CFDataRef)CFRetain(theData);
    }
  }
LABEL_25:
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
    v12 = -[__CFData length](theData, "length");
  else
    v12 = *((_QWORD *)theData + 2);
  BytePtr = CFDataGetBytePtr(theData);
  return (CFDataRef)__CFDataInit((__objc2_class **)allocator, 0, v12, BytePtr, v12, 0);
}

CFMutableDictionaryRef __CFAttributedStringCreateAttributesDictionary(const __CFAllocator *a1, CFDictionaryRef theDict)
{
  if (theDict)
    return CFDictionaryCreateMutableCopy(a1, 0, theDict);
  else
    return CFDictionaryCreateMutable(a1, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

void CFRunArrayReplace(_QWORD *a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5)
{
  const void *v6;
  uint64_t *v10;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  CFTypeRef *v31;
  const void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t *v36;
  __int128 v37;
  uint64_t v38;
  CFTypeRef v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v6 = a4;
    v10 = (uint64_t *)a1[2];
    v42 = 0;
    v43 = 0;
    if (a5)
      v11 = a4;
    else
      v11 = 0;
    os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
    if (*v10 >= 2)
    {
      __CFRunArrayMakeNewList(a1, v10);
      v10 = (uint64_t *)a1[2];
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    v12 = blockForLocation((uint64_t)v10, a2, &v42);
    v13 = v12;
    v10[1] -= a3;
    v41 = a2;
    if (v43 - a2 + v42 >= a3)
      v14 = a3;
    else
      v14 = v43 - a2 + v42;
    v15 = &v10[2 * v12];
    v17 = v15[6];
    v16 = v15 + 6;
    v18 = v17 - v14;
    *v16 = v17 - v14;
    if (v17 == v14)
    {
      CFRelease((CFTypeRef)v10[2 * v12 + 7]);
      v18 = *v16;
    }
    if (v18)
      v19 = v13 + 1;
    else
      v19 = v13;
    v20 = a3 - v14;
    if (v20)
    {
      v21 = (uint64_t)&v10[2 * v13 + 8];
      do
      {
        v22 = *(_QWORD *)v21;
        if (v20 >= *(_QWORD *)v21)
          v23 = *(_QWORD *)v21;
        else
          v23 = v20;
        *(_QWORD *)v21 = v22 - v23;
        if (v22 <= v20)
          CFRelease(*(CFTypeRef *)(v21 + 8));
        v21 += 16;
        ++v13;
        v20 -= v23;
      }
      while (v20);
    }
    if (v13)
      v13 -= v10[2 * v13 + 6] != 0;
    if (v19 > v13)
    {
      v6 = v11;
LABEL_47:
      if (v6)
        CFRunArrayInsert(a1, v41, a5, v6);
      return;
    }
    v24 = v19 - 1;
    if (v19 < 1)
    {
      if (!v11)
        goto LABEL_40;
    }
    else
    {
      if (v19 == v10[4])
      {
        v25 = v10[5] - v10[2 * v24 + 6];
        v10[4] = v24;
        v10[5] = v25;
      }
      if (!v11)
      {
LABEL_37:
        v29 = v13 + 1;
        if (v13 + 1 < v10[2])
        {
          v30 = (uint64_t)&v10[2 * v29 + 6];
          v32 = *(const void **)(v30 + 8);
          v31 = (CFTypeRef *)(v30 + 8);
          if (CFEqual((CFTypeRef)v10[2 * v24 + 7], v32))
          {
            v10[2 * v24 + 6] += v10[2 * v29 + 6];
            CFRelease(*v31);
            v6 = 0;
            ++v13;
            goto LABEL_41;
          }
        }
LABEL_40:
        v6 = 0;
LABEL_41:
        if (v19 <= v13)
        {
          v33 = v10[2];
          v34 = v33 + ~v13;
          if (v34 >= 1)
          {
            v35 = &v10[2 * v13 + 8];
            v36 = &v10[2 * v19 + 6];
            do
            {
              v37 = *(_OWORD *)v35;
              v35 += 2;
              *(_OWORD *)v36 = v37;
              v36 += 2;
              --v34;
            }
            while (v34);
            v33 = v10[2];
          }
          v38 = v33 + v19 - (v13 + 1);
          v10[2] = v38;
          __CFRunArraySetBlockCapacity(a1, v38);
        }
        goto LABEL_47;
      }
      v26 = &v10[2 * v24];
      if (CFEqual((CFTypeRef)v26[7], v11))
      {
        v26[6] += a5;
        v10[1] += a5;
        goto LABEL_37;
      }
    }
    v27 = v10[2];
    if (v13 + 1 < v27)
    {
      v28 = &v10[2 * v13 + 2];
      if (CFEqual((CFTypeRef)v28[7], v11))
      {
        v28[6] += a5;
        v10[1] += a5;
        if (v19 < 1)
          goto LABEL_40;
        goto LABEL_37;
      }
      v27 = v10[2];
    }
    if (v19 < v27)
    {
      v39 = CFRetain(v6);
      v6 = 0;
      v40 = &v10[2 * v19];
      v40[6] = a5;
      v40[7] = (uint64_t)v39;
      v10[1] += a5;
      ++v19;
    }
    goto LABEL_41;
  }
}

const void *_CFRunLoopCacheLookup(_opaque_pthread_t *a1, int a2)
{
  const void *v3;
  const __CFDictionary *v4;
  __CFDictionary *Mutable;
  uint64_t v6;
  const void *v7;
  const void *v8;
  const void *Value;

  v3 = a1;
  if (pthread_equal(a1, 0))
    v3 = (const void *)pthread_main_thread_np();
  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  v4 = (const __CFDictionary *)__CFRunLoops;
  if (a2 && !__CFRunLoops)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
    v6 = pthread_main_thread_np();
    v7 = (const void *)__CFRunLoopCreate(v6);
    v8 = (const void *)pthread_main_thread_np();
    CFDictionarySetValue(Mutable, v8, v7);
    while (!__ldaxr((unint64_t *)&__CFRunLoops))
    {
      if (!__stlxr((unint64_t)Mutable, (unint64_t *)&__CFRunLoops))
        goto LABEL_10;
    }
    __clrex();
    CFRelease(Mutable);
LABEL_10:
    CFRelease(v7);
    os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
    v4 = (const __CFDictionary *)__CFRunLoops;
  }
  if (v4)
    Value = CFDictionaryGetValue(v4, v3);
  else
    Value = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  return Value;
}

BOOL __NSOrderedSetChunkIterate(void *a1, uint64_t a2, unint64_t a3, unint64_t a4, void *a5, uint64_t a6, unint64_t *a7, void *a8, pthread_mutex_t *a9)
{
  unint64_t *v14;
  unint64_t v15;
  _BOOL4 v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _BOOL4 v29;
  _BOOL4 v30;
  unint64_t *v32;
  unint64_t v33;
  _BOOL4 v34;
  unint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t *v38;
  pthread_mutex_t *v39;
  id v40;
  unint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  uint64_t v45;

  v40 = a8;
  v42 = a6;
  v45 = *MEMORY[0x1E0C80C00];
  v44 = 0;
  v43 = 0x7FFFFFFFFFFFFFFFLL;
  if (a7)
    v14 = a7;
  else
    v14 = (unint64_t *)&v43;
  if ((a2 & 0x2000000000000000) != 0)
  {
    v15 = atomic_load(v14);
    if (v15 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v16 = v15 >= a3;
      v17 = v15 <= a4;
      if ((a2 & 2) != 0)
        v16 = v17;
      if (!v16)
        return 0;
    }
  }
  v41 = v14;
  v37 = (void *)_CFAutoreleasePoolPush();
  v38 = &v36;
  v19 = MEMORY[0x1E0C80A78](v37, v18);
  v21 = (char *)&v36 - v20;
  MEMORY[0x1E0C80A78](v19, v22);
  v24 = (char *)&v36 - v23;
  if ((a2 & 0x1000000000000000) != 0
    && !objc_msgSend(a5, "__getContainmentVector:inRange:", (char *)&v36 - v23, a3, a4 - a3 + 1))
  {
    goto LABEL_46;
  }
  objc_msgSend(a1, "getObjects:range:", v21, a3, a4 - a3 + 1);
  if (a4 - a3 == -1)
    goto LABEL_46;
  v25 = 0;
  v39 = a9;
  while (1)
  {
    v26 = a4 - a3 - v25;
    if ((a2 & 2) == 0)
      v26 = v25;
    if ((a2 & 0x1000000000000000) != 0 && !v24[v26])
      goto LABEL_33;
    if ((a2 & 2) != 0)
      v27 = a4 - v25;
    else
      v27 = v25 + a3;
    if ((a2 & 0x6000000000000000) == 0)
    {
      __NSORDEREDSET_IS_CALLING_OUT_TO_A_BLOCK__(v42);
      goto LABEL_27;
    }
    if ((__NSORDEREDSET_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(v42) & 1) != 0)
      break;
LABEL_27:
    if (v44)
      goto LABEL_46;
    if ((a2 & 0x2000000000000000) != 0)
    {
      v28 = atomic_load(v41);
      if (v28 != 0x7FFFFFFFFFFFFFFFLL)
      {
        v29 = v28 >= a3;
        v30 = v28 <= a4;
        if ((a2 & 2) == 0)
          v30 = v29;
        if (!v30)
          goto LABEL_46;
      }
    }
LABEL_33:
    if (++v25 >= a4 - a3 + 1)
      goto LABEL_46;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((a2 & 0x4000000000000000) != 0)
    {
      if (v39)
      {
        pthread_mutex_lock(v39);
        objc_msgSend(v40, "addIndex:", v27);
        pthread_mutex_unlock(v39);
      }
      else
      {
        objc_msgSend(v40, "addIndex:", v27);
      }
    }
    goto LABEL_27;
  }
  v32 = v41;
  while (1)
  {
    v33 = atomic_load(v32);
    if (v33 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v34 = v33 < v27;
      if ((a2 & 2) == 0)
        v34 = v27 < v33;
      if (!v34)
        break;
    }
    while (1)
    {
      v32 = v41;
      v35 = __ldxr(v41);
      if (v35 != v33)
        break;
      if (!__stxr(v27, v41))
        goto LABEL_46;
    }
    __clrex();
  }
LABEL_46:
  _CFAutoreleasePoolPop(v37);
  return v44 != 0;
}

uint64_t __NSORDEREDSET_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

void sub_182B2B40C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182B2BC84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  objc_end_catch();
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL _CFPrefsDirectMode()
{
  _BOOL8 result;

  result = 1;
  if ((isCFPrefsD & 1) == 0 && !forceDirect)
  {
    if (_CFPrefsProcessPathRequiresDirectMode_onceToken != -1)
      dispatch_once(&_CFPrefsProcessPathRequiresDirectMode_onceToken, &__block_literal_global_142);
    if (_CFPrefsProcessPathRequiresDirectMode_onBlacklist)
    {
      return 1;
    }
    else
    {
      if (_CFPrefsDirectMode_onceToken != -1)
        dispatch_once(&_CFPrefsDirectMode_onceToken, &__block_literal_global_43);
      return forceDirect != 0;
    }
  }
  return result;
}

void sub_182B2C288(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182B2CEE0(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x182B2CE4CLL);
  }
  _Unwind_Resume(a1);
}

void sub_182B2D5A8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t _CFPrefsEncodeValueIntoMessage(xpc_object_t xdict, char *key, __objc2_class **cf, _QWORD *a4)
{
  uint64_t v4;
  CFIndex Length;
  xpc_object_t v11;
  const __CFData *Data;
  const __CFData *v13;
  const UInt8 *BytePtr;
  size_t v15;
  size_t v16;
  CFStringRef v17;
  char buffer[1024];
  uint64_t v20;

  v4 = 0;
  v20 = *MEMORY[0x1E0C80C00];
  if (!key || !cf)
    return v4;
  if (&__kCFBooleanTrue == cf || &__kCFBooleanFalse == cf)
  {
    xpc_dictionary_set_BOOL(xdict, key, &__kCFBooleanTrue == cf);
    Length = 1;
  }
  else
  {
    if (&__kCFNull == cf)
    {
      v11 = xpc_null_create();
      xpc_dictionary_set_value(xdict, key, v11);
      xpc_release(v11);
      return 1;
    }
    if (CFGetTypeID(cf) == 7)
    {
      bzero(buffer, 0x400uLL);
      if (CFStringGetCString((CFStringRef)cf, buffer, 1024, 0x8000100u))
      {
        xpc_dictionary_set_string(xdict, key, buffer);
      }
      else
      {
        v4 = (uint64_t)_CFXPCCreateXPCObjectFromCFObject((__CFString *)cf);
        if (!v4)
          goto LABEL_24;
        xpc_dictionary_set_value(xdict, key, (xpc_object_t)v4);
        xpc_release((xpc_object_t)v4);
      }
      v4 = 1;
LABEL_24:
      Length = CFStringGetLength((CFStringRef)cf);
      if (!a4)
        return v4;
      goto LABEL_25;
    }
    Data = CFPropertyListCreateData((CFAllocatorRef)&__kCFAllocatorSystemDefault, cf, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (!Data)
    {
      v16 = strlen(key);
      v17 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)key, v16, 0x8000100u, 0);
      _CFPrefsValidateValueForKey(cf, (uint64_t)v17);
      if (v17)
        CFRelease(v17);
      return 0;
    }
    v13 = Data;
    BytePtr = CFDataGetBytePtr(Data);
    v15 = CFDataGetLength(v13);
    xpc_dictionary_set_data(xdict, key, BytePtr, v15);
    Length = CFDataGetLength(v13);
    CFRelease(v13);
  }
  v4 = 1;
  if (!a4)
    return v4;
LABEL_25:
  if ((_DWORD)v4 && Length)
  {
    *a4 += Length;
    return 1;
  }
  return v4;
}

void sub_182B2DD30(_Unwind_Exception *exception_object)
{
  char v1;

  if ((v1 & 1) != 0)
    objc_end_catch();
  _Unwind_Resume(exception_object);
}

void sub_182B2E2BC(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t _plistSizeIsAppropriateToRead(unint64_t a1)
{
  NSObject *v2;
  uint64_t result;
  NSObject *v4;

  if (a1 - 0x7FFFFFFFFFFFFFFFLL <= 0x8000000000000001)
  {
    _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
    v2 = _CFPrefsClientLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      _plistSizeIsAppropriateToRead_cold_1();
LABEL_11:
    _CFSetTSD(0xFu, 0, 0);
    return 0;
  }
  if (_plistSizeIsAppropriateToRead_onceToken != -1)
    dispatch_once(&_plistSizeIsAppropriateToRead_onceToken, &__block_literal_global_169);
  result = 1;
  if (a1 >= 0x400000 && _plistSizeIsAppropriateToRead_isSizeLimitedProcess)
  {
    _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
    v4 = _CFPrefsClientLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      _plistSizeIsAppropriateToRead_cold_2();
    goto LABEL_11;
  }
  return result;
}

void sub_182B2E418(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t __NSCheckReentrancy(objc_class *a1, const char *a2)
{
  uint64_t result;
  uint64_t v5;
  NSException *v6;

  result = _CFGetTSD(3u);
  if ((objc_class *)result == a1)
  {
    v5 = __CFExceptionProem(a1, a2);
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@: invalid re-entrancy into cache %p"), v5, a1);
    v6 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
    objc_exception_throw(v6);
  }
  return result;
}

uint64_t _CFAppVersionCheck(CFTypeRef cf2, const void *a2)
{
  uint64_t result;

  if (_bundleInfo_onceToken != -1)
    dispatch_once(&_bundleInfo_onceToken, &__block_literal_global_25);
  result = CFEqual((CFTypeRef)_bundleInfo_info_0, cf2);
  if ((_DWORD)result)
  {
    if (!a2)
      return 1;
    result = CFEqual((CFTypeRef)_bundleInfo_info_1, a2);
    if ((_DWORD)result)
      return 1;
  }
  return result;
}

CFIndex CFArrayBSearchValues(CFArrayRef theArray, CFRange range, const void *value, CFComparatorFunction comparator, void *context)
{
  CFIndex location;
  CFIndex length;
  CFIndex v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;

  location = range.location;
  if (range.length >= 1)
  {
    length = range.length;
    v11 = range.location + range.length;
    if (((uint64_t (*)(uint64_t, const void *, void *))comparator)(-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", range.location + range.length - 1), value, context) < 0)
    {
      return v11;
    }
    else if ((((uint64_t (*)(const void *, uint64_t, void *))comparator)(value, -[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location), context) & 0x8000000000000000) == 0)
    {
      v12 = flsl(length);
      v13 = 1 << (v12 - 1);
      if (((uint64_t (*)(uint64_t, const void *, void *))comparator)(-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location + v13 - 1), value, context) >= 0)v14 = -1;
      else
        v14 = length - v13;
      if (v12 != 1)
      {
        v15 = v12 - 2;
        do
        {
          v14 += (1 << v15) & (unint64_t)(((uint64_t (*)(uint64_t, const void *, void *))comparator)(-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", v14 + location + (1 << v15)), value, context) >> 63);
          --v15;
        }
        while (v15 != -1);
      }
      location += v14 + 1;
    }
  }
  return location;
}

CFPlugInRef CFBundleGetPlugIn(CFPlugInRef bundle)
{
  if (!*((_BYTE *)bundle + 72))
    return 0;
  return bundle;
}

uint64_t _CFURLGetVolumePropertyFlags(__objc2_class **a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  __int16 v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  if (_CFURLHasFileURLScheme(a1, &v13))
  {
    __CFURLResourceInfoPtr(a1);
    result = _FSURLGetVolumePropertyFlags();
    if ((_DWORD)result)
      return result;
  }
  else if (!v13)
  {
    CFLog(4, (uint64_t)CFSTR("_CFURLGetVolumePropertyFlags failed because it was passed a URL which has no scheme"), v5, v6, v7, v8, v9, v10, v12);
  }
  *a3 = 0;
  return 1;
}

void CFURLClearResourcePropertyCache(CFURLRef url)
{
  __CFURLResourceInfoPtr((__objc2_class **)url);
  _FSURLClearResourcePropertyCacheForKey();
}

void CFURLClearResourcePropertyCacheForKey(CFURLRef url, CFStringRef key)
{
  __CFURLResourceInfoPtr((__objc2_class **)url);
  _FSURLClearResourcePropertyCacheForKey();
}

void CFURLSetTemporaryResourcePropertyForKey(CFURLRef url, CFStringRef key, CFTypeRef propertyValue)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  if (_CFURLHasFileURLScheme((__objc2_class **)url, &v11))
  {
    __CFURLResourceInfoPtr((__objc2_class **)url);
    _FSURLSetResourcePropertyForKey();
  }
  else if (!v11)
  {
    CFLog(4, (uint64_t)CFSTR("CFURLSetTemporaryResourcePropertyForKey failed because it was passed a URL which has no scheme"), v4, v5, v6, v7, v8, v9, v10);
  }
}

Boolean CFURLSetResourcePropertyForKey(CFURLRef url, CFStringRef key, CFTypeRef propertyValue, CFErrorRef *error)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  if (_CFURLHasFileURLScheme((__objc2_class **)url, &v13))
  {
    __CFURLResourceInfoPtr((__objc2_class **)url);
    _FSURLSetResourcePropertyForKey();
  }
  else if (!v13)
  {
    CFLog(4, (uint64_t)CFSTR("CFURLSetResourcePropertyForKey failed because it was passed a URL which has no scheme"), v5, v6, v7, v8, v9, v10, v12);
  }
  return 1;
}

Boolean CFURLSetResourcePropertiesForKeys(CFURLRef url, CFDictionaryRef keyedPropertyValues, CFErrorRef *error)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v11;
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  if (_CFURLHasFileURLScheme((__objc2_class **)url, &v12))
  {
    __CFURLResourceInfoPtr((__objc2_class **)url);
    _FSURLSetResourcePropertiesForKeys();
  }
  else if (!v12)
  {
    CFLog(4, (uint64_t)CFSTR("CFURLSetResourcePropertiesForKeys failed because it was passed a URL which has no scheme"), v4, v5, v6, v7, v8, v9, v11);
  }
  return 1;
}

const __CFURL *_CFURLIsItemPromiseAtURL(__objc2_class **a1)
{
  const __CFURL *v1;
  CFStringRef PathComponent;
  CFTypeRef cf[2];

  v1 = (const __CFURL *)a1;
  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (_CFURLIsFileURL(a1))
    {
      cf[0] = 0;
      if (CFURLIsFileReferenceURL(v1)
        && _CFURLCopyResourcePropertyForKeyFromCache((__objc2_class **)v1, (uint64_t)CFSTR("NSURLNameKey"), cf))
      {
        PathComponent = (CFStringRef)cf[0];
        if (!cf[0])
          return 0;
      }
      else
      {
        PathComponent = CFURLCopyLastPathComponent(v1);
        cf[0] = PathComponent;
        if (!PathComponent)
          return 0;
      }
      v1 = (const __CFURL *)_CFURLIsPromiseName(PathComponent);
      CFRelease(cf[0]);
      return v1;
    }
    return 0;
  }
  return v1;
}

uint64_t _CFURLCopyResourcePropertyForKeyFromCache(__objc2_class **a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  if (_CFURLHasFileURLScheme(a1, &v13))
  {
    __CFURLResourceInfoPtr(a1);
    return _FSURLCopyResourcePropertyForKeyFromCache();
  }
  else
  {
    if (!v13)
      CFLog(4, (uint64_t)CFSTR("_CFURLCopyResourcePropertyForKeyFromCache failed because it was passed a URL which has no scheme"), v5, v6, v7, v8, v9, v10, v12);
    *a3 = 0;
    return 1;
  }
}

uint64_t __CFURLEndResourcePropertyCacheAccess(__objc2_class **a1)
{
  __CFURLResourceInfoPtr(a1);
  return _FSURLEndResourcePropertyCacheAccess();
}

uint64_t _CFURLCopyResourcePropertyValuesAndFlags(__objc2_class **a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  __int16 v16;
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  if (_CFURLHasFileURLScheme(a1, &v17))
  {
    __CFURLResourceInfoPtr(a1);
    result = _FSURLCopyResourcePropertyValuesAndFlags();
    if ((_DWORD)result)
      return result;
  }
  else if (!v17)
  {
    CFLog(4, (uint64_t)CFSTR("_CFURLCopyResourcePropertyValuesAndFlags failed because it was passed a URL which has no scheme"), v9, v10, v11, v12, v13, v14, v16);
  }
  *a3 = 0;
  *a6 = 0;
  return 1;
}

Boolean CFURLCopyResourcePropertyForKey(CFURLRef url, CFStringRef key, void *propertyValueTypeRefPtr, CFErrorRef *error)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int16 v13;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  if (!_CFURLHasFileURLScheme((__objc2_class **)url, &v14))
  {
    if (!v14)
      CFLog(4, (uint64_t)CFSTR("CFURLCopyResourcePropertyForKey failed because it was passed a URL which has no scheme"), v6, v7, v8, v9, v10, v11, v13);
    goto LABEL_6;
  }
  __CFURLResourceInfoPtr((__objc2_class **)url);
  if (!_FSURLCopyResourcePropertyForKey())
LABEL_6:
    *(_QWORD *)propertyValueTypeRefPtr = 0;
  return 1;
}

__objc2_class **__CFURLResourceInfoPtr(__objc2_class **result)
{
  unint64_t *v1;

  if (result)
  {
    v1 = (unint64_t *)result;
    if (!CF_IS_OBJC(0x1DuLL, result))
      return (__objc2_class **)atomic_load(v1 + 6);
    result = (__objc2_class **)objc_msgSend(v1, "_cfurl");
    v1 = (unint64_t *)result;
    if (result)
      return (__objc2_class **)atomic_load(v1 + 6);
  }
  return result;
}

uint64_t __CFURLBeginResourcePropertyCacheAccess(__objc2_class **a1)
{
  __CFURLResourceInfoPtr(a1);
  return _FSURLBeginResourcePropertyCacheAccess();
}

CFDictionaryRef CFURLCopyResourcePropertiesForKeys(CFURLRef url, CFArrayRef keys, CFErrorRef *error)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFDictionaryRef result;
  const __CFAllocator *v11;
  __int16 v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  if (_CFURLHasFileURLScheme((__objc2_class **)url, &v13))
  {
    __CFURLResourceInfoPtr((__objc2_class **)url);
    result = (CFDictionaryRef)_FSURLCopyResourcePropertiesForKeys();
    if (result)
      return result;
  }
  else if (!v13)
  {
    CFLog(4, (uint64_t)CFSTR("CFURLCopyResourcePropertiesForKeys failed because it was passed a URL which has no scheme"), v4, v5, v6, v7, v8, v9, v12);
  }
  v11 = CFGetAllocator(url);
  return CFDictionaryCreate(v11, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

void _CFURLPromiseSetPhysicalURL(const __CFURL *a1, const __CFURL *a2)
{
  const __CFURL *v4;
  __objc2_class **v5;

  if (a1 && _CFURLIsFileURL((__objc2_class **)a1))
  {
    if (a2 == a1)
    {
      v5 = &__kCFNull;
      v4 = a1;
      goto LABEL_8;
    }
    v4 = a1;
    if (a2)
    {
      v5 = (__objc2_class **)a2;
LABEL_8:
      _CFURLSetPermanentResourcePropertyForKey(v4, CFSTR("_NSURLPromisePhysicalURLKey"), v5);
      return;
    }
    CFURLClearResourcePropertyCacheForKey(a1, CFSTR("_NSURLPromisePhysicalURLKey"));
  }
}

__objc2_class **_CFURLPromiseCopyPhysicalURL(__objc2_class **result)
{
  const __CFURL *v1;
  _QWORD v2[2];

  v2[1] = *MEMORY[0x1E0C80C00];
  v2[0] = 0;
  if (result)
  {
    v1 = (const __CFURL *)result;
    if (_CFURLIsFileURL(result))
    {
      CFURLCopyResourcePropertyForKey(v1, CFSTR("_NSURLPromisePhysicalURLKey"), v2, 0);
      result = (__objc2_class **)v2[0];
      if ((__objc2_class **)v2[0] == &__kCFNull)
        return (__objc2_class **)CFRetain(v1);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL _CFURLIsFileURL(__objc2_class **a1)
{
  return _CFURLHasFileURLScheme(a1, 0);
}

uint64_t _CFURLIsPromiseName(const __CFString *a1)
{
  if (a1 && CFStringGetLength(a1) >= 1 && CFStringGetCharacterAtIndex(a1, 0) == 46)
    return CFStringHasSuffix(a1, CFSTR(".icloud"));
  else
    return 0;
}

CFTypeRef _CFRunLoopGet2(uint64_t a1)
{
  CFTypeRef v2;
  Class v3;
  Class v4;
  const void *v5;

  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  v2 = *(CFTypeRef *)(a1 + 672);
  if (v2)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  }
  else
  {
    v3 = objc_lookUpClass("NSRunLoop");
    if (v3 && (v4 = v3, (objc_opt_respondsToSelector() & 1) != 0))
    {
      v5 = (const void *)-[objc_class _new:](v4, "_new:", a1);
      if (v5)
        v2 = CFRetain(v5);
      else
        v2 = 0;
      *(_QWORD *)(a1 + 672) = v2;
    }
    else
    {
      v2 = *(CFTypeRef *)(a1 + 672);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
    if (!v2)
      _CFRunLoopGet2_cold_1();
  }
  return v2;
}

CFArrayRef CFBundleCopyResourceURLsOfType(CFBundleRef bundle, CFStringRef resourceType, CFStringRef subDirName)
{
  if (bundle)
    return _CFBundleCopyFindResources((unint64_t *)bundle, 0, (uint64_t)subDirName, 0, resourceType, subDirName, 0, 1, 0, 0);
  else
    return CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
}

void _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants(CFDataRef theData, const __CFString *a2, _QWORD *a3, _DWORD *a4, _QWORD *a5, _DWORD *a6)
{
  CFSetRef v9;
  const __CFSet *v10;
  __CFSet *Mutable;
  const __CFString *ProductNameSuffix;
  const __CFString *PlatformNameSuffix;
  __CFString *Append3;
  __CFString *v15;
  __CFString *Append2;
  __CFString *v17;
  int Filtered;
  const __CFDictionary *Value;
  const __CFDictionary *v20;
  CFIndex v21;
  void *v22;
  CFIndex Count;
  CFNumberRef v24;
  CFIndex Length;
  _QWORD v29[9];
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t valuePtr;
  uint64_t *p_valuePtr;
  uint64_t v36;
  int v37;
  CFDictionaryRef theDict;
  CFDictionaryRef *p_theDict;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  CFIndex v46;
  void *v47;
  CFNumberRef v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v9 = _CFPropertyListCopyTopLevelKeys(&__kCFAllocatorSystemDefault, theData, 0, 0);
  if (!v9)
    goto LABEL_15;
  v10 = v9;
  Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 5, &kCFTypeSetCallBacks);
  ProductNameSuffix = (const __CFString *)_CFBundleGetProductNameSuffix();
  PlatformNameSuffix = _CFBundleGetPlatformNameSuffix();
  Append3 = _CFStringCreateAppend3(a2, ProductNameSuffix, PlatformNameSuffix);
  v15 = _CFStringCreateAppend3(a2, PlatformNameSuffix, ProductNameSuffix);
  Append2 = _CFStringCreateAppend2(a2, PlatformNameSuffix);
  v17 = _CFStringCreateAppend2(a2, ProductNameSuffix);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, Append3);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, v15);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, Append2);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, v17);
  _CFBundleAddProvenanceKeyPathIfPresent(v10, Mutable, a2);
  if (CFSetGetCount(Mutable) < 1)
    goto LABEL_9;
  theDict = 0;
  Filtered = _CFPropertyListCreateFiltered((const __CFAllocator *)&__kCFAllocatorSystemDefault, theData, 0, Mutable, (CFTypeRef *)&theDict, 0);
  if (!theDict)
    Filtered = 0;
  if (Filtered == 1)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("LocProvenance"));
    v20 = Value;
    if (Value && (v21 = CFDictionaryGetCount(Value), v21 == CFSetGetCount(Mutable)))
    {
      v22 = (void *)CFRetain(v20);
    }
    else
    {
      Count = CFSetGetCount(Mutable);
      v22 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      LOBYTE(valuePtr) = 3;
      v24 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt8Type, &valuePtr);
      Length = CFStringGetLength(CFSTR("LocProvenance"));
      v42 = MEMORY[0x1E0C809B0];
      v43 = 3221225472;
      v44 = (uint64_t)___CFBundleCopyLocTableProvenanceForDeviceAndPlatformVariants_block_invoke;
      v45 = &__block_descriptor_56_e13_v24__0r_v8_16l;
      v46 = Length + 1;
      v47 = v22;
      v48 = v24;
      CFSetApply(Mutable, (uint64_t)&v42);
      CFRelease(v24);
    }
    CFRelease(theDict);
  }
  else
  {
LABEL_9:
    v22 = 0;
  }
  CFRelease(Append3);
  CFRelease(v15);
  CFRelease(Append2);
  CFRelease(v17);
  CFRelease(v10);
  CFRelease(Mutable);
  if (v22)
  {
    if (CFDictionaryGetCount((CFDictionaryRef)v22))
    {
      v42 = 0;
      v43 = (uint64_t)&v42;
      v44 = 0x2020000000;
      LODWORD(v45) = 0;
      theDict = 0;
      p_theDict = &theDict;
      v40 = 0x2020000000;
      v41 = 0;
      valuePtr = 0;
      p_valuePtr = &valuePtr;
      v36 = 0x2020000000;
      v37 = 0;
      v30 = 0;
      v31 = &v30;
      v32 = 0x2020000000;
      v33 = 0;
      v29[0] = MEMORY[0x1E0C809B0];
      v29[1] = 3221225472;
      v29[2] = ___CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants_block_invoke;
      v29[3] = &unk_1E1335CE8;
      v29[7] = &v30;
      v29[8] = v22;
      v29[4] = &v42;
      v29[5] = &theDict;
      v29[6] = &valuePtr;
      CFDictionaryApply(v22, (uint64_t)v29);
      *a3 = p_theDict[3];
      *a4 = *(_DWORD *)(v43 + 24);
      *a5 = v31[3];
      *a6 = *((_DWORD *)p_valuePtr + 6);
      CFRelease(v22);
      _Block_object_dispose(&v30, 8);
      _Block_object_dispose(&valuePtr, 8);
      _Block_object_dispose(&theDict, 8);
      _Block_object_dispose(&v42, 8);
    }
    else
    {
      *a3 = 0;
      *a5 = 0;
      *a4 = 0;
      *a6 = 0;
      CFRelease(v22);
    }
  }
  else
  {
LABEL_15:
    *a3 = 0;
    *a5 = 0;
    *a4 = 0;
    *a6 = 0;
  }
}

void sub_182B3010C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  uint64_t v30;

  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose((const void *)(v30 - 152), 8);
  _Unwind_Resume(a1);
}

void _CFBundleAddProvenanceKeyPathIfPresent(const __CFSet *a1, __CFSet *a2, const __CFString *value)
{
  __CFString *Append3;

  if (CFSetContainsValue(a1, value))
  {
    Append3 = _CFStringCreateAppend3(CFSTR("LocProvenance"), CFSTR(":"), value);
    CFSetAddValue(a2, Append3);
    CFRelease(Append3);
  }
}

__CFString *_CFStringCreateAppend3(const __CFString *a1, const __CFString *a2, const __CFString *a3)
{
  CFIndex Length;
  CFIndex v7;
  CFIndex v8;
  __CFString *MutableCopy;

  Length = CFStringGetLength(a1);
  v7 = CFStringGetLength(a2) + Length;
  v8 = CFStringGetLength(a3);
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7 + v8, a1);
  CFStringAppend(MutableCopy, a2);
  CFStringAppend(MutableCopy, a3);
  return MutableCopy;
}

__CFString *_CFStringCreateAppend2(const __CFString *a1, const __CFString *a2)
{
  CFIndex Length;
  CFIndex v5;
  __CFString *MutableCopy;

  Length = CFStringGetLength(a1);
  v5 = CFStringGetLength(a2);
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5 + Length, a1);
  CFStringAppend(MutableCopy, a2);
  return MutableCopy;
}

__n128 _CFBundleGetStringsSources@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const __CFString *a3@<X2>, const __CFArray *a4@<X3>, uint64_t a5@<X8>)
{
  os_unfair_lock_s *v10;
  int v11;
  const __CFDictionary *v12;
  _OWORD *Value;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  BOOL v17;
  uint64_t v18;
  const __CFURL *v19;
  const void *v20;
  const __CFURL *v21;
  int v22;
  CFDataRef MappedOrLoadedPlistData;
  const void *UnlocalizedDebugDescription;
  NSObject *v25;
  const void *v26;
  unint64_t v27;
  CFTypeRef *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  CFIndex v33;
  const __CFString *ValueAtIndex;
  CFURLRef v35;
  CFURLRef v36;
  const void *v37;
  __n128 result;
  CFURLRef v39;
  CFIndex v40;
  const __CFData *v41;
  const __CFString *v42;
  CFTypeRef v43;
  const __CFURL *v44;
  const __CFURL *v45;
  CFIndex Count;
  CFStringRef v47;
  CFStringRef v48;
  const void *v49;
  const __CFArray *v50;
  CFIndex v51;
  CFIndex FirstIndexOfValue;
  const __CFArray *v53;
  CFIndex v54;
  CFStringRef v55;
  int v56;
  CFStringRef v57;
  int v58;
  int v59;
  _BOOL4 v60;
  BOOL v61;
  int v62;
  _BOOL4 v64;
  const __CFString *v65;
  CFTypeRef v66;
  CFTypeRef v67;
  NSObject *v68;
  __int128 v69;
  __int128 v70;
  const void *v71;
  const void *v72;
  const void *v73;
  const __CFData *v74;
  const __CFString *v75;
  int v76;
  int v77;
  NSObject *v78;
  __int128 v79;
  __int128 v80;
  CFTypeRef v81;
  const __CFURL *v82;
  const __CFURL *v83;
  unsigned int v84;
  unsigned int FileVersionForStringsResourceURL;
  int v86;
  const __CFString *cf2;
  const __CFString *v88;
  unsigned int v89;
  unsigned int v90;
  const __CFData *theData;
  CFTypeRef *v92;
  int v93;
  CFTypeRef *v94;
  int v95[2];
  CFTypeRef *theArray;
  const __CFArray *theArraya;
  int v98;
  CFTypeRef v99;
  int v100;
  CFTypeRef cf;
  BOOL v102;
  _BYTE v103[32];
  __int128 v104;
  __int128 v105;
  uint64_t v106;
  uint64_t v107;
  CFRange v108;
  CFRange v109;

  v107 = *MEMORY[0x1E0C80C00];
  v10 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  *(_QWORD *)(a5 + 64) = 0;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  v11 = 1;
  *(_BYTE *)(a5 + 67) = 1;
  v12 = *(const __CFDictionary **)(a1 + 168);
  if (v12)
  {
    Value = CFDictionaryGetValue(v12, a3);
    if (Value)
    {
      *(_OWORD *)a5 = *Value;
      v14 = Value[1];
      v15 = Value[2];
      v16 = Value[3];
      *(_QWORD *)(a5 + 64) = *((_QWORD *)Value + 8);
      *(_OWORD *)(a5 + 32) = v15;
      *(_OWORD *)(a5 + 48) = v16;
      *(_OWORD *)(a5 + 16) = v14;
      *(_OWORD *)&v103[16] = Value[1];
      v104 = Value[2];
      v105 = Value[3];
      v106 = *((_QWORD *)Value + 8);
      *(_OWORD *)v103 = *Value;
      _CFBundleRetainStringsSources((uint64_t)v103);
      v11 = 0;
    }
  }
  os_unfair_lock_unlock(v10);
  if (a4)
    v17 = 0;
  else
    v17 = *(_BYTE *)(a1 + 54) == 0;
  v18 = v17;
  if (!*(_QWORD *)(a5 + 56))
  {
    if ((v11 & 1) != 0)
    {
      v19 = CFBundleCopyResourceURL((CFBundleRef)a1, a3, CFSTR("loctable"), 0);
    }
    else
    {
      v20 = *(const void **)(a5 + 48);
      if (!v20)
        goto LABEL_27;
      v19 = (const __CFURL *)CFRetain(v20);
    }
    v21 = v19;
    if (v19)
    {
      if (v18 | a2)
        v22 = v11;
      else
        v22 = 0;
      LOBYTE(v99) = 0;
      cf = 0;
      MappedOrLoadedPlistData = _CFBundleCreateMappedOrLoadedPlistData(v19, v22, v18, (BOOL *)&v99, (CFErrorRef *)&cf);
      *(_QWORD *)(a5 + 56) = MappedOrLoadedPlistData;
      if (MappedOrLoadedPlistData)
      {
        *(_BYTE *)(a5 + 66) = (_BYTE)v99;
      }
      else
      {
        UnlocalizedDebugDescription = (const void *)_CFErrorCreateUnlocalizedDebugDescription(cf);
        v25 = _CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v103 = 138412802;
          *(_QWORD *)&v103[4] = a1;
          *(_WORD *)&v103[12] = 2112;
          *(_QWORD *)&v103[14] = a3;
          *(_WORD *)&v103[22] = 2112;
          *(_QWORD *)&v103[24] = UnlocalizedDebugDescription;
          _os_log_error_impl(&dword_182A8C000, v25, OS_LOG_TYPE_ERROR, "loctable failed to load for bundle: %@, table: %@: %@", v103, 0x20u);
        }
        CFRelease(UnlocalizedDebugDescription);
        CFRelease(cf);
      }
      v26 = *(const void **)(a5 + 48);
      if (v26)
        CFRelease(v26);
      *(_QWORD *)(a5 + 48) = v21;
    }
  }
LABEL_27:
  v28 = (CFTypeRef *)(a5 + 8);
  v27 = *(_QWORD *)(a5 + 8);
  if (a4)
  {
    if (v27)
    {
      CFRelease((CFTypeRef)v27);
      *v28 = 0;
    }
    if (*(_QWORD *)a5)
    {
      CFRelease(*(CFTypeRef *)a5);
      *(_QWORD *)a5 = 0;
    }
    v29 = *(const void **)(a5 + 16);
    if (v29)
    {
      CFRelease(v29);
      *(_QWORD *)(a5 + 16) = 0;
    }
    v30 = *(const void **)(a5 + 32);
    if (v30)
    {
      CFRelease(v30);
      *(_QWORD *)(a5 + 32) = 0;
    }
    v92 = (CFTypeRef *)(a5 + 8);
    v31 = *(const void **)(a5 + 24);
    if (v31)
    {
      CFRelease(v31);
      *(_QWORD *)(a5 + 24) = 0;
    }
    v94 = (CFTypeRef *)(a5 + 24);
    theArray = (CFTypeRef *)(a5 + 32);
    v89 = a2;
    v32 = *(const void **)(a5 + 40);
    if (v32)
    {
      CFRelease(v32);
      *(_QWORD *)(a5 + 40) = 0;
    }
    if (CFArrayGetCount(a4) >= 1)
    {
      v33 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a4, v33);
        v35 = CFBundleCopyResourceURLForLocalization((CFBundleRef)a1, a3, CFSTR("strings"), 0, ValueAtIndex);
        v36 = CFBundleCopyResourceURLForLocalization((CFBundleRef)a1, a3, CFSTR("stringsdict"), 0, ValueAtIndex);
        if ((unint64_t)v35 | (unint64_t)v36)
          break;
        if (++v33 >= CFArrayGetCount(a4))
          goto LABEL_51;
      }
      v39 = v36;
      *(_QWORD *)a5 = v35;
      *(_QWORD *)(a5 + 8) = CFRetain(ValueAtIndex);
      *(_QWORD *)(a5 + 24) = v39;
      *(_QWORD *)(a5 + 32) = CFRetain(ValueAtIndex);
    }
LABEL_51:
    if (*v92)
      goto LABEL_142;
    if (*(_QWORD *)(a5 + 56))
    {
      if (CFArrayGetCount(a4) >= 2 && CFArrayGetCount(a4) >= 1)
      {
        v40 = 0;
        while (1)
        {
          *(_QWORD *)v103 = 0;
          cf = 0;
          v41 = *(const __CFData **)(a5 + 56);
          v42 = (const __CFString *)CFArrayGetValueAtIndex(a4, v40);
          _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants(v41, v42, v103, &v99, &cf, &v100);
          v43 = cf;
          if (*(_QWORD *)v103 | (unint64_t)cf)
            break;
          if (++v40 >= CFArrayGetCount(a4))
            goto LABEL_140;
        }
        *v92 = *(CFTypeRef *)v103;
        *theArray = v43;
      }
LABEL_140:
      if ((unint64_t)*v92 | (unint64_t)*theArray)
        goto LABEL_142;
    }
    else if (*theArray)
    {
LABEL_154:
      _CFBundleLoadNonLocTableData(a1, (uint64_t)a3, a5, 0, v89);
      v79 = *(_OWORD *)(a5 + 48);
      v104 = *(_OWORD *)(a5 + 32);
      v105 = v79;
      v106 = *(_QWORD *)(a5 + 64);
      v80 = *(_OWORD *)(a5 + 16);
      *(_OWORD *)v103 = *(_OWORD *)a5;
      *(_OWORD *)&v103[16] = v80;
      _CFBundleIngestResultForBundleCache(a1, a3, 0, (uint64_t)v103);
      return result;
    }
    v72 = CFArrayGetValueAtIndex(a4, 0);
    *v92 = CFRetain(v72);
    v73 = CFArrayGetValueAtIndex(a4, 0);
    *theArray = CFRetain(v73);
LABEL_142:
    v74 = *(const __CFData **)(a5 + 56);
    if (v74)
    {
      cf = 0;
      v100 = 0;
      v99 = 0;
      v98 = 0;
      if (*(_QWORD *)(a5 + 8))
        v75 = *(const __CFString **)(a5 + 8);
      else
        v75 = *(const __CFString **)(a5 + 32);
      _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants(v74, v75, &cf, &v100, &v99, &v98);
      v76 = _useLoctableInsteadOfFileBasedOnVersion((CFTypeRef *)a5, v92, v100, cf);
      v77 = _useLoctableInsteadOfFileBasedOnVersion(v94, theArray, v98, v99);
      if (!(v76 | v77))
      {
        CFRelease(*(CFTypeRef *)(a5 + 56));
        *(_QWORD *)(a5 + 56) = 0;
      }
      if (!v76 && *(_QWORD *)a5 || *v94 && !v77)
      {
        v78 = _CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
        {
          v81 = *v92;
          *(_DWORD *)v103 = 138412802;
          *(_QWORD *)&v103[4] = a1;
          *(_WORD *)&v103[12] = 2112;
          *(_QWORD *)&v103[14] = a3;
          *(_WORD *)&v103[22] = 2112;
          *(_QWORD *)&v103[24] = v81;
          _os_log_debug_impl(&dword_182A8C000, v78, OS_LOG_TYPE_DEBUG, "loctable overridden by installed files. Bundle: %@, table: %@, language: %@", v103, 0x20u);
        }
      }
    }
    goto LABEL_154;
  }
  if (v27 | *(_QWORD *)(a5 + 32))
  {
    if (*(_BYTE *)(a5 + 68))
    {
      v37 = *(const void **)(a5 + 56);
      if (v37)
      {
        CFRelease(v37);
        *(_QWORD *)(a5 + 56) = 0;
      }
    }
    _CFBundleLoadNonLocTableData(a1, (uint64_t)a3, a5, 0, a2);
    return result;
  }
  v44 = CFBundleCopyResourceURL((CFBundleRef)a1, a3, CFSTR("strings"), 0);
  v45 = CFBundleCopyResourceURL((CFBundleRef)a1, a3, CFSTR("stringsdict"), 0);
  theData = *(const __CFData **)(a5 + 56);
  if (theData)
  {
    theArraya = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(a1);
    Count = CFArrayGetCount(theArraya);
    if (v44)
    {
      v47 = _CFBundleCopyLanguageForStringsResourceURL(v44);
      if (v45)
      {
LABEL_62:
        v48 = _CFBundleCopyLanguageForStringsResourceURL(v45);
LABEL_77:
        FileVersionForStringsResourceURL = _CFBundleGetFileVersionForStringsResourceURL(v44);
        v84 = _CFBundleGetFileVersionForStringsResourceURL(v45);
        LOBYTE(v98) = 0;
        v102 = 0;
        _CFBundleGetLocTableProvenanceForLanguage(theData, CFSTR("none"), &v98, &v102);
        *(_QWORD *)v95 = Count - 1;
        if (Count < 1)
          goto LABEL_123;
        v82 = v45;
        v83 = v44;
        v90 = a2;
        v54 = 0;
        v86 = 0;
        v55 = v48;
        v56 = 0;
        v57 = v47;
        v58 = 0;
        v59 = v98;
        v60 = v102;
        cf2 = v55;
        v88 = v57;
        if ((_BYTE)v98)
          v61 = v57 == 0;
        else
          v61 = 0;
        v62 = v61;
        v93 = v62;
        v64 = v102 && v55 == 0;
        while (1)
        {
          v65 = (const __CFString *)CFArrayGetValueAtIndex(theArraya, v54);
          *(_QWORD *)v103 = 0;
          LODWORD(v99) = 0;
          cf = 0;
          v100 = 0;
          if (v58 | v59 && v56 | v60)
          {
            if (v56)
              goto LABEL_102;
          }
          else
          {
            _CFBundleGetMostAppropriateLocTableDeviceAndPlatformSpecificVariants(theData, v65, v103, &v99, &cf, &v100);
            if (v56)
              goto LABEL_102;
          }
          if (cf2 && CFEqual(v65, cf2) && v84 >= v100)
            break;
          if (cf)
          {
            v66 = CFRetain(cf);
            v86 = 1;
            goto LABEL_101;
          }
          v56 = 0;
          if (v58)
            goto LABEL_103;
LABEL_113:
          if (v88 && CFEqual(v65, v88) && FileVersionForStringsResourceURL >= v99)
          {
            *(_QWORD *)a5 = CFRetain(v83);
            v67 = CFRetain(v65);
          }
          else
          {
            if (!*(_QWORD *)v103)
            {
              v58 = 0;
              goto LABEL_104;
            }
            v67 = CFRetain(*(CFTypeRef *)v103);
            v86 = 1;
          }
          *(_QWORD *)(a5 + 8) = v67;
          if ((v56 & 1) == 0)
            *(_BYTE *)(a5 + 67) = 0;
LABEL_103:
          v58 = 1;
LABEL_104:
          if (cf)
            CFRelease(cf);
          if (*(_QWORD *)v103)
            CFRelease(*(CFTypeRef *)v103);
          if (((v58 | v93) & (v56 | v64) & 1) == 0)
          {
            v17 = *(_QWORD *)v95 == v54++;
            if (!v17)
              continue;
          }
          a2 = v90;
          v45 = v82;
          v44 = v83;
          v48 = cf2;
          v47 = v88;
          if (!v86)
          {
LABEL_123:
            v68 = _CFBundleLocalizedStringLogger();
            if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
              _CFBundleGetStringsSources_cold_1();
            *(_BYTE *)(a5 + 68) = 1;
          }
          if (v47)
            CFRelease(v47);
          if (v48)
            CFRelease(v48);
          v53 = theArraya;
LABEL_131:
          CFRelease(v53);
          goto LABEL_132;
        }
        *(_QWORD *)(a5 + 24) = CFRetain(v82);
        v66 = CFRetain(v65);
LABEL_101:
        *(_QWORD *)(a5 + 32) = v66;
LABEL_102:
        v56 = 1;
        if (v58)
          goto LABEL_103;
        goto LABEL_113;
      }
    }
    else
    {
      v47 = 0;
      if (v45)
        goto LABEL_62;
    }
    v48 = 0;
    goto LABEL_77;
  }
  if (v44)
  {
    *(_QWORD *)a5 = CFRetain(v44);
    *(_QWORD *)(a5 + 8) = _CFBundleCopyLanguageForStringsResourceURL(v44);
  }
  if (v45)
  {
    *(_QWORD *)(a5 + 24) = CFRetain(v45);
    *(_QWORD *)(a5 + 32) = _CFBundleCopyLanguageForStringsResourceURL(v45);
  }
  if (*v28)
  {
    v49 = *(const void **)(a5 + 32);
    if (v49)
    {
      if (!CFEqual(*v28, v49))
      {
        v50 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(a1);
        v51 = CFArrayGetCount(v50);
        v108.location = 0;
        v108.length = v51;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v50, v108, *(const void **)(a5 + 8));
        v109.location = 0;
        v109.length = v51;
        if (FirstIndexOfValue < CFArrayGetFirstIndexOfValue(v50, v109, *(const void **)(a5 + 32)))
          *(_BYTE *)(a5 + 67) = 0;
        v53 = v50;
        goto LABEL_131;
      }
    }
  }
LABEL_132:
  if (v44)
    CFRelease(v44);
  if (v45)
    CFRelease(v45);
  _CFBundleLoadNonLocTableData(a1, (uint64_t)a3, a5, 1, a2);
  v69 = *(_OWORD *)(a5 + 48);
  v104 = *(_OWORD *)(a5 + 32);
  v105 = v69;
  v106 = *(_QWORD *)(a5 + 64);
  v70 = *(_OWORD *)(a5 + 16);
  *(_OWORD *)v103 = *(_OWORD *)a5;
  *(_OWORD *)&v103[16] = v70;
  _CFBundleIngestResultForBundleCache(a1, a3, 1, (uint64_t)v103);
  if (*(_BYTE *)(a5 + 68))
  {
    v71 = *(const void **)(a5 + 56);
    if (v71)
    {
      CFRelease(v71);
      *(_QWORD *)(a5 + 56) = 0;
    }
  }
  return result;
}

void _CFBundleLoadNonLocTableData(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  CFDataRef MappedOrLoadedPlistData;
  NSObject *v11;
  const __CFURL *v12;
  CFDataRef v13;
  NSObject *v14;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  CFTypeRef v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 54))
    a4 = 0;
  cf = 0;
  if (!*(_QWORD *)(a3 + 16))
  {
    if (*(_QWORD *)a3)
    {
      MappedOrLoadedPlistData = _CFBundleCreateMappedOrLoadedPlistData(*(const __CFURL **)a3, a4, a5, (BOOL *)(a3 + 64), (CFErrorRef *)&cf);
      *(_QWORD *)(a3 + 16) = MappedOrLoadedPlistData;
      if (!MappedOrLoadedPlistData)
      {
        v11 = _CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412802;
          v17 = a1;
          v18 = 2112;
          v19 = a2;
          v20 = 2112;
          v21 = cf;
          _os_log_error_impl(&dword_182A8C000, v11, OS_LOG_TYPE_ERROR, "Unable to load .strings file: %@ / %@: %@", buf, 0x20u);
        }
        if (cf)
          CFRelease(cf);
        cf = 0;
      }
    }
  }
  if (!*(_QWORD *)(a3 + 40))
  {
    v12 = *(const __CFURL **)(a3 + 24);
    if (v12)
    {
      v13 = _CFBundleCreateMappedOrLoadedPlistData(v12, a4, a5, (BOOL *)(a3 + 65), (CFErrorRef *)&cf);
      *(_QWORD *)(a3 + 40) = v13;
      if (!v13)
      {
        v14 = _CFBundleLocalizedStringLogger();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412802;
          v17 = a1;
          v18 = 2112;
          v19 = a2;
          v20 = 2112;
          v21 = cf;
          _os_log_error_impl(&dword_182A8C000, v14, OS_LOG_TYPE_ERROR, "Unable to load .stringsdict file: %@ / %@: %@", buf, 0x20u);
        }
        if (cf)
          CFRelease(cf);
      }
    }
  }
}

__CFArray *_CFBundleCopyLocalizationsForPreferences(const __CFArray *a1, const __CFArray *a2, int a3)
{
  __CFArray *Mutable;
  const __CFString *ValueAtIndex;

  if (!a1 || CFArrayGetCount(a1) < 1)
    goto LABEL_10;
  Mutable = _CFBundleCopyPreferredLanguagesInList(a1, 0, a2, a3, 0, 0);
  if (CFArrayGetCount(Mutable) || CFArrayGetCount(a1) < 1)
  {
    if (CFArrayGetCount(Mutable))
      goto LABEL_9;
    ValueAtIndex = CFSTR("en");
  }
  else
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, 0);
  }
  CFArrayAppendValue(Mutable, ValueAtIndex);
LABEL_9:
  if (!Mutable)
  {
LABEL_10:
    Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(Mutable, CFSTR("en"));
  }
  return Mutable;
}

CFURLRef CFBundleCopyResourceURL(CFURLRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  if (bundle)
    return _CFBundleCopyFindResources((unint64_t *)bundle, 0, (uint64_t)resourceType, resourceName, resourceType, subDirName, 0, 0, 0, 0);
  return bundle;
}

__CFArray *_CFBundleCopyPreferredLanguagesInList(const __CFArray *a1, void *a2, CFArrayRef theArray, int a4, unint64_t a5, __CFBundle *a6)
{
  const __CFArray *v11;
  __CFArray *MutableArrayOfFallbackLanguages;
  CFArrayRef v13;
  CFArrayRef v14;
  __CFBundle *MainBundle;
  CFURLRef v16;
  CFURLRef v17;
  NSObject *v18;
  __CFString *Mutable;
  __CFString *v20;
  __CFString *v21;
  __CFString *v22;
  __CFString *v23;
  _BOOL8 v24;
  const __CFDictionary *InfoDictionary;
  _BOOL4 v26;
  NSObject *v27;
  const char *v29;
  void *v30;
  unint64_t v31;
  void *values;
  _BYTE buf[12];
  __int16 v34;
  __CFString *v35;
  __int16 v36;
  void *v37;
  __int16 v38;
  __CFString *v39;
  __int16 v40;
  __CFString *v41;
  __int16 v42;
  _BOOL8 v43;
  __int16 v44;
  const char *v45;
  __int16 v46;
  __CFString *v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  values = a2;
  if (!a4)
    goto LABEL_5;
  if (CFBundleAllowMixedLocalizations_once != -1)
    dispatch_once(&CFBundleAllowMixedLocalizations_once, &__block_literal_global_16);
  if (CFBundleAllowMixedLocalizations_allowMixed)
  {
LABEL_5:
    v11 = 0;
    goto LABEL_6;
  }
  if (CFBundleFollowParentLocalization_once != -1)
    dispatch_once(&CFBundleFollowParentLocalization_once, &__block_literal_global_135);
  if (CFBundleFollowParentLocalization_followParent == 1)
  {
    v11 = (const __CFArray *)_CFBundleCopyXPCBootstrapMainBundleLanguages();
    if (!v11)
      goto LABEL_6;
LABEL_28:
    if (CFArrayGetCount(v11) >= 1)
    {
      MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)v11);
      if (MutableArrayOfFallbackLanguages)
        goto LABEL_30;
    }
    goto LABEL_6;
  }
  MainBundle = CFBundleGetMainBundle();
  v11 = MainBundle;
  if (!MainBundle)
    goto LABEL_6;
  v16 = CFBundleCopyBundleURL(MainBundle);
  if (!v16)
    goto LABEL_5;
  v17 = v16;
  if (a5 && CFEqual((CFTypeRef)a5, v16))
    v11 = 0;
  else
    v11 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(v11);
  CFRelease(v17);
  if (v11)
    goto LABEL_28;
LABEL_6:
  if (!theArray || CFArrayGetCount(theArray) < 1)
  {
    MutableArrayOfFallbackLanguages = 0;
LABEL_11:
    if (a2)
    {
      v13 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
      MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)v13);
      CFRelease(v13);
    }
    goto LABEL_13;
  }
  MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)theArray);
  if (!MutableArrayOfFallbackLanguages)
    goto LABEL_11;
LABEL_13:
  if (!MutableArrayOfFallbackLanguages)
  {
    *(_QWORD *)buf = CFSTR("en_US");
    v14 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)buf, 1, &kCFTypeArrayCallBacks);
    MutableArrayOfFallbackLanguages = _CFBundleCreateMutableArrayOfFallbackLanguages((uint64_t)a1, (uint64_t)v14);
    CFRelease(v14);
    if (!MutableArrayOfFallbackLanguages)
      MutableArrayOfFallbackLanguages = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  }
LABEL_30:
  v18 = _CFBundleResourceLogger();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG) && a5 | (unint64_t)a6)
  {
    v30 = values;
    v31 = a5;
    Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    v20 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    v21 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    v22 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    v23 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    if (a6)
      CFStringAppendFormat(Mutable, 0, CFSTR("%@"), a6);
    else
      CFStringAppendFormat(Mutable, 0, CFSTR("%@"), v31);
    _onelineFormatArray(v20, a1);
    _onelineFormatArray(v21, theArray);
    _onelineFormatArray(v22, v11);
    _onelineFormatArray(v23, MutableArrayOfFallbackLanguages);
    if (CFBundleAllowMixedLocalizations_once != -1)
      dispatch_once(&CFBundleAllowMixedLocalizations_once, &__block_literal_global_16);
    v24 = CFBundleAllowMixedLocalizations_allowMixed != 0;
    v26 = a6
       && (InfoDictionary = CFBundleGetInfoDictionary(a6)) != 0
       && CFDictionaryGetValue(InfoDictionary, CFSTR("_CFBundleUseAppleLocalizations")) == &__kCFBooleanTrue;
    v27 = _CFBundleResourceLogger();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
    {
      v29 = "";
      *(_DWORD *)buf = 138479619;
      *(_QWORD *)&buf[4] = Mutable;
      v34 = 2114;
      if (v26)
        v29 = "(use Apple Locs)";
      v35 = v20;
      v36 = 2114;
      v37 = v30;
      v38 = 2114;
      v39 = v21;
      v40 = 2114;
      v41 = v22;
      v42 = 2050;
      v43 = v24;
      v44 = 2082;
      v45 = v29;
      v46 = 2114;
      v47 = v23;
      _os_log_debug_impl(&dword_182A8C000, v27, OS_LOG_TYPE_DEBUG, "Language lookup at %{private}@\n\tLocalizations : %{public}@\n\tDev language  : %{public}@\n\tUser prefs    : %{public}@\n\tMain bundle   : %{public}@\n\tAllow mixed   : %{public}lu %{public}s\n\tResult        : %{public}@\n", buf, 0x52u);
    }
    CFRelease(Mutable);
    CFRelease(v20);
    CFRelease(v21);
    CFRelease(v23);
    CFRelease(v22);
  }
  if (v11)
    CFRelease(v11);
  return MutableArrayOfFallbackLanguages;
}

CFBundleRef CFBundleGetMainBundle(void)
{
  const char *v0;
  const __CFString *v1;
  const __CFURL *v2;
  const __CFURL *v3;
  const __CFURL *v4;
  const __CFURL *v5;
  _QWORD *Main;
  int32x4_t v7;
  int v8;
  NSObject *v10;
  _BOOL4 v11;
  uint64_t v12;
  CFIndex Count;
  const __CFString *v14;
  const __CFString *v15;
  const __CFDictionary *InfoDictFromMainExecutable;
  const __CFDictionary *v17;
  uint64_t v18;
  const void *v19;
  const __CFString *v20;
  const __CFString *v21;
  const void *v22;
  uint64_t v23;
  CFMutableDictionaryRef Mutable;
  CFTypeRef v25;
  const __CFString *Value;
  const __CFString *v27;
  const __CFDictionary *InfoDictionary;
  __CFBundle *v29;
  _QWORD v31[130];

  v31[129] = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)&_mainBundleLock);
  if ((_initedMainBundle & 1) == 0)
  {
    _initedMainBundle = 1;
    v0 = _CFProcessPath();
    if (v0)
    {
      v1 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v0);
      v2 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, kCFURLPOSIXPathStyle, 0);
      if (!v2)
      {
        if (!v1)
          goto LABEL_58;
        goto LABEL_57;
      }
      v3 = v2;
      v4 = _CFBundleCopyBundleURLForExecutableURL(v2);
      if (!v4)
      {
LABEL_54:
        if (v1)
          CFRelease(v1);
        v1 = (const __CFString *)v3;
LABEL_57:
        CFRelease(v1);
        goto LABEL_58;
      }
      v5 = v4;
      Main = _CFBundleCreateMain((const __CFAllocator *)&__kCFAllocatorSystemDefault, v4);
      _mainBundle = (uint64_t)Main;
      if (!Main)
      {
LABEL_53:
        CFRelease(v5);
        goto LABEL_54;
      }
      *((_BYTE *)Main + 52) = 1;
      if (!*((_DWORD *)Main + 12))
      {
        v8 = _CFBundleGrokBinaryType(v3, v7);
        Main = (_QWORD *)_mainBundle;
        *(_DWORD *)(_mainBundle + 48) = v8;
        if (v8 != 1 && v8 != 6)
          *((_BYTE *)Main + 64) = 1;
      }
      if (!Main[7])
      {
        Main[7] = -5;
        v10 = _CFBundleLoadingLogger();
        v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
        Main = (_QWORD *)_mainBundle;
        if (v11)
        {
          CFBundleGetMainBundle_cold_1(_mainBundle, v10, v31);
          Main = (_QWORD *)v31[0];
        }
      }
      CFBundleGetInfoDictionary((CFBundleRef)Main);
      v12 = _mainBundle;
      if (*(_QWORD *)(_mainBundle + 24))
      {
        Count = CFDictionaryGetCount(*(CFDictionaryRef *)(_mainBundle + 24));
        v12 = _mainBundle;
        if (Count)
        {
          if (*(_DWORD *)(_mainBundle + 48) == 2)
          {
            v14 = _CFBundleCopyExecutableName((CFBundleRef)_mainBundle, 0, 0);
            v15 = v14;
            if (v1)
            {
              if (v14 && CFStringHasSuffix(v1, v14))
                goto LABEL_43;
            }
            InfoDictFromMainExecutable = _CFBundleCreateInfoDictFromMainExecutable();
            if (InfoDictFromMainExecutable)
            {
              v17 = InfoDictFromMainExecutable;
              if (CFDictionaryGetCount(InfoDictFromMainExecutable) < 1)
              {
                CFRelease(v17);
              }
              else
              {
                v18 = _mainBundle;
                v19 = *(const void **)(_mainBundle + 24);
                if (v19)
                {
                  CFRelease(v19);
                  v18 = _mainBundle;
                }
                *(_QWORD *)(v18 + 24) = v17;
              }
            }
            if (v15)
LABEL_43:
              CFRelease(v15);
          }
LABEL_44:
          v23 = _mainBundle;
          if (!*(_QWORD *)(_mainBundle + 24))
          {
            Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            v23 = _mainBundle;
            *(_QWORD *)(_mainBundle + 24) = Mutable;
          }
          if (v1 && !*(_QWORD *)(v23 + 104))
          {
            v25 = CFRetain(v1);
            v23 = _mainBundle;
            *(_QWORD *)(_mainBundle + 104) = v25;
          }
          Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v23 + 24), CFSTR("CFBundleIdentifier"));
          if (Value)
          {
            v27 = Value;
            bzero(v31, 0x402uLL);
            if (!CFStringGetCString(v27, (char *)v31, 1024, 0x8000100u))
            {
              LOBYTE(v31[0]) = 0;
              __CFBundleMainID = (uint64_t)strdup((const char *)v31);
            }
          }
          os_unfair_lock_unlock((os_unfair_lock_t)&_mainBundleLock);
          InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)_mainBundle);
          _CFBundleInitPlugIn((void *)_mainBundle, InfoDictionary, 0);
          _CFPlugInHandleDynamicRegistration((__CFBundle *)_mainBundle);
          os_unfair_lock_lock((os_unfair_lock_t)&_mainBundleLock);
          goto LABEL_53;
        }
      }
      if (*(_BYTE *)(v12 + 53))
      {
        if (*(_BYTE *)(v12 + 53) == 3)
          *(_BYTE *)(v12 + 53) = 4;
        goto LABEL_37;
      }
      v20 = _CFBundleCopyExecutableName((CFBundleRef)v12, 0, 0);
      v21 = v20;
      if (v1 && v20)
      {
        if (!CFStringHasSuffix(v1, v20))
          *(_BYTE *)(_mainBundle + 53) = 4;
      }
      else
      {
        v12 = _mainBundle;
        *(_BYTE *)(_mainBundle + 53) = 4;
        if (!v21)
          goto LABEL_37;
      }
      CFRelease(v21);
      v12 = _mainBundle;
LABEL_37:
      if ((*(_DWORD *)(v12 + 48) | 4) == 6)
      {
        v22 = *(const void **)(v12 + 24);
        if (v22)
          CFRelease(v22);
        *(_QWORD *)(_mainBundle + 24) = _CFBundleCreateInfoDictFromMainExecutable();
      }
      goto LABEL_44;
    }
  }
LABEL_58:
  v29 = (__CFBundle *)_mainBundle;
  os_unfair_lock_unlock((os_unfair_lock_t)&_mainBundleLock);
  return v29;
}

CFURLRef CFBundleCopyBundleURL(CFBundleRef bundle)
{
  unint64_t v2;
  CFURLRef result;

  v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  result = (CFURLRef)*((_QWORD *)bundle + 2);
  if (result)
  {
    CFRetain(result);
    return (CFURLRef)*((_QWORD *)bundle + 2);
  }
  return result;
}

CFMutableArrayRef _CFBundleCopyFindResources(unint64_t *a1, const __CFURL *a2, uint64_t a3, const __CFString *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, int a8, char a9, uint64_t a10)
{
  uint64_t v15;
  unint64_t v16;
  int v17;
  const __CFString *v18;
  const __CFArray *ArrayBySeparatingStrings;
  CFIndex v20;
  CFIndex v21;
  CFIndex v22;
  int v23;
  const __CFString *v24;
  const __CFString *v25;
  int v26;
  CFStringRef Copy;
  CFRange v28;
  const __CFString *v29;
  const __CFString *v30;
  uint64_t v31;
  __CFArray *v33;
  CFIndex Length;
  __CFString *MutableCopy;
  _BOOL4 v36;
  _BOOL4 v37;
  int v38;
  const __CFString *v39;
  int v40;
  const __CFString *v41;
  __CFString *v42;
  int v43;
  __CFArray *v44;
  const __CFString *v45;
  __CFArray *v46;
  const __CFString *v47;
  const __CFURL *v48;
  const __CFString *v49;
  const __CFString *v50;
  CFTypeID v51;
  os_unfair_lock_s *v52;
  const __CFDictionary *v53;
  const __CFString *v54;
  CFIndex Count;
  const void **v56;
  const void **v57;
  __CFArray *v58;
  const __CFString *v59;
  uint64_t Resources;
  const __CFArray *v61;
  const __CFURL *v62;
  const __CFString *v63;
  const __CFString *v64;
  const __CFURL *v65;
  const __CFString *v66;
  const __CFString *v67;
  const __CFURL *v68;
  const __CFURL *v69;
  int v70;
  const __CFString *v71;
  NSObject *v72;
  const __CFURL *v73;
  __CFString *Mutable;
  __CFString *v75;
  __CFString *v76;
  CFTypeID v77;
  CFIndex v78;
  const void *ValueAtIndex;
  NSObject *v80;
  const __CFArray *v81;
  CFStringRef v82;
  CFIndex v83;
  int HasPrefix;
  uint64_t v85;
  CFIndex v86;
  const __CFString *v87;
  uint64_t v88;
  const __CFString *v89;
  const void **v90;
  const void **v91;
  const __CFString *v92;
  const __CFString *v93;
  uint64_t v94;
  const __CFURL *v95;
  const __CFURL *v96;
  const __CFString *v97;
  const __CFURL *v98;
  const __CFString *v99;
  const __CFString *v100;
  CFAllocatorRef allocator;
  char v102;
  __CFArray *cf;
  __CFString *v104;
  int v105;
  uint64_t range;
  char buffer[4];
  __CFString *v109;
  __int16 v110;
  __CFString *v111;
  __int16 v112;
  __CFString *v113;
  uint64_t v114;
  CFRange v115;
  CFRange v116;

  v15 = (uint64_t)a1;
  v114 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v16 = _CFGetNonObjCTypeID(a1);
    if (v16 != 31)
      _CFAssertMismatchedTypeID(0x1FuLL, v16);
  }
  v17 = dyld_program_sdk_at_least();
  v105 = a8;
  if (!a6 || !v17)
  {
LABEL_16:
    if (!a4)
    {
LABEL_24:
      Copy = 0;
      v29 = 0;
      goto LABEL_40;
    }
LABEL_17:
    range = -1;
    Copy = _CFCreateLastPathComponent((const __CFAllocator *)&__kCFAllocatorSystemDefault, a4, &range);
    v28.length = range;
    if (range < 1)
    {
      v29 = 0;
    }
    else
    {
      v28.location = 0;
      v29 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, a4, v28);
      if (range >= 1 && !CFStringGetLength(Copy))
      {
        v96 = a2;
        v30 = v29;
        v31 = range;
        if (v31 == CFStringGetLength(a4) - 1)
        {
          CFRelease(Copy);
          v29 = v30;
          Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v30);
        }
        else
        {
          v29 = v30;
        }
        a2 = v96;
      }
    }
    if (CFStringGetFileSystemRepresentation(Copy, buffer, 1026))
    {
      CFRelease(Copy);
      Copy = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer);
    }
    if (Copy)
    {
      Length = CFStringGetLength(Copy);
      if (a5 && Length >= 1 && CFStringGetLength(a5) >= 1)
      {
        MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, Copy);
        if (CFStringGetCharacterAtIndex(a5, 0) != 46)
          CFStringAppendCharacters(MutableCopy, &_CFBundleCopyFindResources_extensionSep, 1);
        CFStringAppend(MutableCopy, a5);
      }
      else
      {
        if (CFStringGetLength(Copy) < 1)
        {
          v102 = 0;
          if (!a5)
            goto LABEL_49;
LABEL_41:
          if (CFStringGetLength(a5) >= 1)
          {
            MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("_CFBT_"));
            if (CFStringGetCharacterAtIndex(a5, 0) != 46)
              CFStringAppendCharacters(MutableCopy, &_CFBundleCopyFindResources_extensionSep, 1);
            CFStringAppend(MutableCopy, a5);
LABEL_50:
            v104 = MutableCopy;
            if (a6)
            {
              v36 = CFStringGetLength(a6) != 0;
              if (v29)
              {
LABEL_52:
                v37 = CFStringGetLength(v29) != 0;
LABEL_55:
                v38 = !v36;
                if (!v36 || v37)
                {
                  v40 = !v37;
                  if (((v36 | v40) & 1) != 0)
                  {
                    v41 = v104;
                    if (((v38 | v40) & 1) != 0)
                    {
                      v42 = 0;
                    }
                    else
                    {
                      v42 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, a6);
                      _CFAppendPathComponent2(v42, v29);
                    }
                    goto LABEL_63;
                  }
                  v39 = v29;
                }
                else
                {
                  v39 = a6;
                }
                v42 = (__CFString *)CFRetain(v39);
                v41 = v104;
LABEL_63:
                LOBYTE(range) = 0;
                if (v15)
                  v43 = _CFBundleLayoutVersion(v15);
                else
                  v43 = 0;
                LOBYTE(range) = v43;
                if (a2)
                {
                  v44 = _CFBundleCopyLanguageSearchListInDirectory(a2, (unsigned __int8 *)&range);
                  v43 = range;
                }
                else
                {
                  v44 = 0;
                }
                if (v43 <= 1)
                {
                  if (!v43)
                  {
                    v45 = CFSTR("Resources");
                    goto LABEL_81;
                  }
                  if (v43 == 1)
                  {
                    v45 = CFSTR("Support Files/Resources");
                    goto LABEL_81;
                  }
                }
                else
                {
                  switch(v43)
                  {
                    case 13:
                      v45 = CFSTR("WrappedBundle");
                      goto LABEL_81;
                    case 12:
                      v45 = CFSTR("WrappedBundle/Contents/Resources");
                      goto LABEL_81;
                    case 2:
                      v45 = CFSTR("Contents/Resources");
                      goto LABEL_81;
                  }
                }
                v45 = &stru_1E1337B18;
LABEL_81:
                cf = v44;
                v97 = v45;
                v46 = _copyResourceURLsFromBundle(v15, a2, v44, v45, v42, v41, a7, v105, a9, v43, a10);
                v33 = v46;
                if (v46)
                {
                  v47 = Copy;
                  v48 = a2;
                  v49 = v29;
                  v50 = a4;
                  v51 = CFGetTypeID(v46);
                  if (v51 != CFArrayGetTypeID())
                  {
                    a4 = v50;
                    v29 = v49;
                    a2 = v48;
                    Copy = v47;
                    goto LABEL_88;
                  }
                  a4 = v50;
                  v29 = v49;
                  a2 = v48;
                  Copy = v47;
                  if (CFArrayGetCount(v33))
                    goto LABEL_88;
                }
                if ((range & 0xFD) == 0)
                {
                  if (v15)
                  {
                    allocator = *(CFAllocatorRef *)(v15 + 192);
                    CFRetain(allocator);
                  }
                  else
                  {
                    v62 = CFURLCopyAbsoluteURL(a2);
                    v63 = a5;
                    v64 = Copy;
                    v65 = a2;
                    v66 = v29;
                    v67 = a4;
                    v68 = v62;
                    allocator = (CFAllocatorRef)CFURLCopyFileSystemPath(v62, kCFURLPOSIXPathStyle);
                    v69 = v68;
                    a4 = v67;
                    v29 = v66;
                    a2 = v65;
                    Copy = v64;
                    a5 = v63;
                    CFRelease(v69);
                  }
                  if ((_BYTE)range && !CFEqual(CFSTR("/Library/Spotlight"), allocator))
                  {
LABEL_174:
                    CFRelease(allocator);
                    if (!v15)
                      goto LABEL_120;
                    goto LABEL_89;
                  }
                  if (v33)
                    CFRelease(v33);
                  v70 = range;
                  if ((_BYTE)range)
                  {
                    v71 = v104;
                  }
                  else
                  {
                    v71 = v104;
                    if (v42)
                    {
                      if (CFEqual(v42, CFSTR("Resources")))
                      {
LABEL_157:
                        v82 = &stru_1E1337B18;
                        goto LABEL_170;
                      }
                      v70 = range;
                    }
                  }
                  v81 = cf;
                  if (v70 == 2 && v42)
                  {
                    if (CFEqual(v42, CFSTR("Contents/Resources")))
                      goto LABEL_157;
                    v70 = range;
                    v81 = cf;
                  }
                  if (!v70
                    && v42
                    && (v83 = CFStringGetLength(v42), v81 = cf, v83 >= 11)
                    && (HasPrefix = CFStringHasPrefix(v42, CFSTR("Resources/")), v81 = cf, HasPrefix))
                  {
                    v93 = v29;
                    v100 = a4;
                    v85 = -10;
                    v86 = 10;
                  }
                  else
                  {
                    if (range != 2 || !v42)
                    {
                      v87 = &stru_1E1337B18;
                      goto LABEL_173;
                    }
                    if (CFStringGetLength(v42) < 20 || !CFStringHasPrefix(v42, CFSTR("Contents/Resources/")))
                    {
                      v87 = &stru_1E1337B18;
                      v81 = cf;
                      goto LABEL_173;
                    }
                    v93 = v29;
                    v100 = a4;
                    v85 = -19;
                    v86 = 19;
                  }
                  v116.length = CFStringGetLength(v42) + v85;
                  v116.location = v86;
                  v82 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v42, v116);
                  a4 = v100;
                  v29 = v93;
LABEL_170:
                  CFRelease(v42);
                  v42 = (__CFString *)v82;
                  v81 = cf;
                  v71 = v104;
                  v87 = v97;
LABEL_173:
                  v33 = _copyResourceURLsFromBundle(v15, a2, v81, v87, v42, v71, a7, v105, a9, range, a10);
                  goto LABEL_174;
                }
LABEL_88:
                if (!v15)
                {
LABEL_120:
                  if ((v102 & 1) == 0)
                    CFRelease(Copy);
                  if (v42)
                    CFRelease(v42);
                  if (v29)
                    CFRelease(v29);
                  if (cf)
                    CFRelease(cf);
                  CFRelease(v104);
                  v72 = _CFBundleResourceLogger();
                  if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
                  {
                    v73 = a2;
                    Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
                    v75 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
                    v76 = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
                    if (v15)
                    {
                      CFStringAppendFormat(Mutable, 0, CFSTR("%@"), v15);
                    }
                    else if (v73)
                    {
                      CFStringAppendFormat(Mutable, 0, CFSTR("CFURL %@"), v73);
                    }
                    if (a4)
                      CFStringAppend(v75, a4);
                    if (a5)
                      CFStringAppendFormat(v75, 0, CFSTR(" type: %@"), a5);
                    if (a6)
                      CFStringAppendFormat(v75, 0, CFSTR(" path: %@"), a6);
                    if (a7)
                      CFStringAppendFormat(v75, 0, CFSTR(" localization: %@"), a7);
                    if (v33)
                    {
                      v77 = CFGetTypeID(v33);
                      if (v77 == CFArrayGetTypeID())
                      {
                        if (CFArrayGetCount(v33) >= 1)
                        {
                          v78 = 0;
                          do
                          {
                            ValueAtIndex = CFArrayGetValueAtIndex(v33, v78);
                            CFStringAppendFormat(v76, 0, CFSTR("%@, "), ValueAtIndex);
                            ++v78;
                          }
                          while (v78 < CFArrayGetCount(v33));
                        }
                      }
                      else
                      {
                        CFStringAppendFormat(v76, 0, CFSTR("%@"), v33);
                      }
                    }
                    else
                    {
                      CFStringAppendFormat(v76, 0, CFSTR("None"), v88);
                    }
                    v80 = _CFBundleResourceLogger();
                    if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
                    {
                      *(_DWORD *)buffer = 138478339;
                      v109 = Mutable;
                      v110 = 2114;
                      v111 = v75;
                      v112 = 2114;
                      v113 = v76;
                      _os_log_debug_impl(&dword_182A8C000, v80, OS_LOG_TYPE_DEBUG, "Resource lookup at %{private}@\n\tRequest       : %{public}@\n\tResult        : %{public}@\n", (uint8_t *)buffer, 0x20u);
                    }
                    CFRelease(Mutable);
                    CFRelease(v75);
                    CFRelease(v76);
                  }
                  return v33;
                }
LABEL_89:
                v52 = (os_unfair_lock_s *)(v15 + 200);
                os_unfair_lock_lock((os_unfair_lock_t)(v15 + 200));
                v53 = *(const __CFDictionary **)(v15 + 208);
                if (!v53 || !v105 && v33)
                  goto LABEL_119;
                v89 = Copy;
                v92 = v29;
                v54 = a5;
                Count = CFDictionaryGetCount(v53);
                v56 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
                v57 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
                v91 = v56;
                CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(v15 + 208), v56, v57);
                v90 = v57;
                if (Count < 1)
                {
                  v58 = v33;
                  a5 = v54;
                  v29 = v92;
                }
                else
                {
                  v98 = a2;
                  v58 = 0;
                  do
                  {
                    LOBYTE(v88) = a9;
                    v59 = a7;
                    Resources = _CFBundleCopyFindResources(*v57, 0);
                    if (Resources)
                    {
                      v61 = (const __CFArray *)Resources;
                      if (!v105)
                        goto LABEL_101;
                      if (!v58)
                        v58 = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v33);
                      v115.length = CFArrayGetCount(v61);
                      v115.location = 0;
                      CFArrayAppendArray(v58, v61, v115);
                      CFRelease(v61);
                    }
                    ++v57;
                    --Count;
                    a7 = v59;
                  }
                  while (Count);
                  v61 = v33;
LABEL_101:
                  a5 = v54;
                  v29 = v92;
                  if (v58)
                  {
                    Copy = v89;
                    if (v61)
                      CFRelease(v61);
                    a7 = v59;
                    a2 = v98;
                    goto LABEL_118;
                  }
                  v58 = v61;
                  a7 = v59;
                  a2 = v98;
                }
                Copy = v89;
LABEL_118:
                free(v91);
                free(v90);
                v33 = v58;
                v52 = (os_unfair_lock_s *)(v15 + 200);
LABEL_119:
                os_unfair_lock_unlock(v52);
                goto LABEL_120;
              }
            }
            else
            {
              v36 = 0;
              if (v29)
                goto LABEL_52;
            }
            v37 = 0;
            goto LABEL_55;
          }
LABEL_49:
          MutableCopy = (__CFString *)CFRetain(CFSTR("_CFBAF_"));
          goto LABEL_50;
        }
        MutableCopy = (__CFString *)CFRetain(Copy);
      }
      v102 = 0;
      goto LABEL_50;
    }
LABEL_40:
    v102 = 1;
    if (!a5)
      goto LABEL_49;
    goto LABEL_41;
  }
  v99 = a4;
  v18 = a5;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)&__kCFAllocatorSystemDefault, a6, CFSTR("/"));
  v20 = CFArrayGetCount(ArrayBySeparatingStrings);
  if (v20 < 1)
  {
    CFRelease(ArrayBySeparatingStrings);
    a5 = v18;
    if (!a4)
      goto LABEL_24;
    goto LABEL_17;
  }
  v21 = v20;
  v94 = v15;
  v95 = a2;
  v22 = 0;
  v23 = 0;
  do
  {
    v24 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v22);
    v25 = v24;
    if (v22 || CFStringCompare(v24, &stru_1E1337B18, 0))
    {
      if (CFStringCompare(v25, CFSTR("."), 0))
      {
        if (CFStringCompare(v25, CFSTR(".."), 0))
          ++v23;
        else
          --v23;
        if (v23 < 0)
        {
          CFRelease(ArrayBySeparatingStrings);
          v26 = v105;
          goto LABEL_26;
        }
      }
    }
    ++v22;
  }
  while (v21 != v22);
  CFRelease(ArrayBySeparatingStrings);
  a4 = v99;
  a5 = v18;
  v15 = v94;
  a2 = v95;
  v26 = v105;
  if ((v23 & 0x80000000) == 0)
    goto LABEL_16;
LABEL_26:
  if (v26)
    return CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  return 0;
}

CFTypeID CFArrayGetTypeID(void)
{
  return 19;
}

uint64_t _CFBundleResourceLogger()
{
  if (_CFBundleResourceLogger_onceToken != -1)
    dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
  return _CFBundleResourceLogger__log;
}

__CFArray *_copyResourceURLsFromBundle(uint64_t a1, const __CFURL *a2, const __CFArray *a3, const __CFString *a4, const __CFString *a5, const __CFString *a6, const __CFString *a7, int a8, char a9, char a10, uint64_t a11)
{
  __CFArray *Mutable;
  const __CFString *MutableCopy;
  __CFString *v19;
  const __CFURL *v20;
  CFIndex Length;
  const __CFDictionary *Table;
  const __CFDictionary *v23;
  const __CFString *v24;
  const __CFDictionary *v25;
  _BOOL4 v26;
  BOOL v27;
  CFTypeID v28;
  CFTypeID v29;
  CFIndex Count;
  CFIndex i;
  const __CFString *ValueAtIndex;
  CFIndex v33;
  CFIndex v34;
  BOOL v35;
  const __CFArray *v36;
  CFMutableStringRef v37;
  const __CFDictionary *v38;
  const void *Value;
  CFTypeID v40;
  CFTypeID TypeID;
  const __CFArray *v42;
  int v43;
  CFMutableStringRef v44;
  __CFArray *v45;
  const __CFURL *v46;
  const __CFString *v47;
  __CFString *v48;
  CFIndex v49;
  const __CFURL *v50;
  CFIndex j;
  const __CFString *v52;
  const __CFString *v53;
  CFURLRef RelativeURLFromBaseAndPath;
  int HasPrefix;
  int v56;
  const __CFString *v57;
  const __CFURL *v58;
  const __CFString *v59;
  CFIndex v60;
  const __CFString *v61;
  Boolean v62;
  __CFString *v64;
  const __CFString *theString;
  const __CFURL *v66;
  const __CFArray *v67;
  uint64_t v68;
  CFRange result;
  CFTypeRef cf;
  char v73;
  uint64_t v74;
  CFRange v75;
  CFRange v76;
  CFRange v77;
  CFRange v78;
  CFRange v79;
  CFRange v80;
  CFRange v81;

  v74 = *MEMORY[0x1E0C80C00];
  v73 = 0;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  cf = 0;
  theString = a4;
  MutableCopy = CFStringCreateMutableCopy(0, 0, a4);
  v19 = (__CFString *)MutableCopy;
  v20 = a2;
  v67 = a3;
  v68 = a1;
  if (a10 == 1)
  {
    Length = CFStringGetLength(MutableCopy);
    _CFAppendPathComponent2(v19, CFSTR("Non-localized Resources"));
    Table = _copyQueryTable(a1, a2, a3, v19, a5);
    v23 = Table;
    v24 = a5;
    if (a11)
      _CFBundleFindResourcesWithPredicate(Mutable, Table, a11, &v73);
    else
      cf = CFDictionaryGetValue(Table, a6);
    v75.length = CFStringGetLength(v19) - Length;
    v75.location = Length;
    CFStringDelete(v19, v75);
    if (cf || v73)
      goto LABEL_12;
    a1 = v68;
    if (v23)
      CFRelease(v23);
  }
  v25 = _copyQueryTable(a1, v20, a3, v19, a5);
  v23 = v25;
  v24 = a5;
  if (a11)
    _CFBundleFindResourcesWithPredicate(Mutable, v25, a11, &v73);
  else
    cf = CFDictionaryGetValue(v25, a6);
LABEL_12:
  if (v24)
    v26 = CFStringGetLength(v24) > 0;
  else
    v26 = 0;
  v66 = v20;
  if (a7)
    v27 = CFStringGetLength(a7) > 0;
  else
    v27 = 0;
  if (!a9 || !cf)
  {
    if (cf)
    {
      v29 = CFGetTypeID(cf);
      if (v29 == CFArrayGetTypeID())
      {
        v76.length = CFArrayGetCount((CFArrayRef)cf);
        v76.location = 0;
        CFArrayAppendArray(Mutable, (CFArrayRef)cf, v76);
      }
      else
      {
        CFArrayAppendValue(Mutable, cf);
      }
    }
    goto LABEL_52;
  }
  v28 = CFGetTypeID(cf);
  if (v28 == CFStringGetTypeID())
    cf = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, &cf, 1, &kCFTypeArrayCallBacks);
  else
    CFRetain(cf);
  result.location = 0;
  result.length = 0;
  if (a8)
  {
    Count = CFArrayGetCount((CFArrayRef)cf);
    if (Count <= 0)
    {
      CFRelease(cf);
LABEL_52:
      v36 = v67;
      goto LABEL_53;
    }
  }
  else
  {
    Count = 1;
  }
  v64 = v19;
  for (i = 0; Count != i; ++i)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, i);
    v33 = CFStringGetLength(ValueAtIndex);
    v34 = v33;
    if (v26)
    {
      v77.location = 0;
      v77.length = v33;
      if (CFStringFindWithOptions(ValueAtIndex, v24, v77, 0, &result))
        v35 = result.location == 0;
      else
        v35 = 1;
      if (v35)
        goto LABEL_46;
    }
    else
    {
      if (!v33)
        goto LABEL_46;
      v78.location = 0;
      v78.length = v33;
      if (!CFStringFindWithOptions(ValueAtIndex, CFSTR(".lproj"), v78, 0, &result) || result.location + 7 >= v34)
        goto LABEL_46;
    }
    if (!a7)
      break;
    if (CFStringGetLength(a7) < 1)
      break;
    v79.location = 0;
    v79.length = v34;
    if (!CFStringFindWithOptions(ValueAtIndex, a7, v79, 8uLL, &result))
      break;
    v80.location = result.length + result.location;
    v80.length = 1;
    if (!CFStringFindWithOptions(ValueAtIndex, CFSTR("."), v80, 0, &result))
      break;
    v27 = 0;
LABEL_46:
    CFArrayAppendValue(Mutable, ValueAtIndex);
  }
  CFRelease(cf);
  v36 = v67;
  if (!a8 && CFArrayGetCount(Mutable))
    v27 = 0;
  v19 = v64;
LABEL_53:
  cf = 0;
  CFRelease(v23);
  if (v27)
  {
    v37 = CFStringCreateMutableCopy(0, 0, a7);
    _CFAppendPathExtension2(v37, CFSTR("lproj"));
    if (v24 && CFStringGetLength(v24) >= 1)
      _CFAppendPathComponent2(v37, v24);
    v38 = _copyQueryTable(v68, v66, v36, v19, v37);
    CFRelease(v37);
    Value = CFDictionaryGetValue(v38, a6);
    cf = Value;
    if (Value)
    {
      v40 = CFGetTypeID(Value);
      TypeID = CFStringGetTypeID();
      v42 = (const __CFArray *)cf;
      if (v40 == TypeID)
      {
        CFArrayAppendValue(Mutable, cf);
      }
      else
      {
        v81.length = CFArrayGetCount((CFArrayRef)cf);
        v81.location = 0;
        CFArrayAppendArray(Mutable, v42, v81);
      }
    }
    CFRelease(v38);
  }
  if (CFArrayGetCount(Mutable) < 1)
  {
    if (a8)
      v45 = (__CFArray *)CFRetain(Mutable);
    else
      v45 = 0;
  }
  else
  {
    v43 = _CFGetSlash();
    if (v68)
    {
      v44 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, *(CFStringRef *)(v68 + 192));
    }
    else
    {
      v46 = CFURLCopyAbsoluteURL(v66);
      v47 = CFURLCopyFileSystemPath(v46, kCFURLPOSIXPathStyle);
      v44 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v47);
      CFRelease(v46);
      CFRelease(v47);
    }
    if (theString && CFStringGetLength(theString))
      _CFAppendPathComponent2(v44, theString);
    _CFAppendTrailingPathSlash2(v44);
    if (a8)
    {
      v48 = v19;
      v49 = CFArrayGetCount(Mutable);
      v50 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v44, kCFURLPOSIXPathStyle, 1u);
      v45 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
      if (v49 >= 1)
      {
        for (j = 0; j != v49; ++j)
        {
          v52 = (const __CFString *)CFArrayGetValueAtIndex(Mutable, j);
          v53 = _CFGetSlashStr();
          RelativeURLFromBaseAndPath = _CFBundleCreateRelativeURLFromBaseAndPath(v52, v50, v43, v53);
          CFArrayAppendValue(v45, RelativeURLFromBaseAndPath);
          CFRelease(RelativeURLFromBaseAndPath);
        }
      }
      CFRelease(v50);
      v19 = v48;
    }
    else
    {
      HasPrefix = CFStringHasPrefix(a6, CFSTR("_CFBT_"));
      v56 = CFStringHasPrefix(a6, CFSTR("_CFBAF_")) | HasPrefix;
      v57 = (const __CFString *)CFArrayGetValueAtIndex(Mutable, 0);
      if (v56)
      {
        v58 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v44, kCFURLPOSIXPathStyle, 1u);
        v59 = _CFGetSlashStr();
        v45 = _CFBundleCreateRelativeURLFromBaseAndPath(v57, v58, v43, v59);
        CFRelease(v58);
      }
      else
      {
        CFStringAppend(v44, v57);
        v60 = CFStringGetLength(v57);
        if (CFStringGetCharacterAtIndex(v57, v60 - 1) == v43)
        {
          v61 = v44;
          v62 = 1;
        }
        else
        {
          v61 = v44;
          v62 = 0;
        }
        v45 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v61, kCFURLPOSIXPathStyle, v62);
      }
    }
    CFRelease(v44);
  }
  if (v19)
    CFRelease(v19);
  CFRelease(Mutable);
  return v45;
}

CFDictionaryRef _copyQueryTable(uint64_t a1, CFURLRef relativeURL, const __CFArray *cf, const __CFString *a4, const __CFString *a5)
{
  const __CFArray *v7;
  __CFString *MutableCopy;
  const __CFDictionary *v11;
  __CFDictionary *Value;
  __CFDictionary *QueryTableAtPath;
  const __CFURL *v14;

  v7 = cf;
  if (a1 && !cf)
  {
    v7 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle(a1);
    goto LABEL_7;
  }
  if (cf)
    CFRetain(cf);
  if (a1)
  {
LABEL_7:
    if (a5)
    {
      MutableCopy = CFStringCreateMutableCopy(0, 0, a4);
      _CFAppendPathComponent2(MutableCopy, a5);
    }
    else
    {
      MutableCopy = (__CFString *)CFRetain(a4);
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 176));
    v11 = *(const __CFDictionary **)(a1 + 184);
    if (v11)
    {
      Value = (__CFDictionary *)CFDictionaryGetValue(v11, MutableCopy);
      if (Value)
      {
        QueryTableAtPath = Value;
        CFRetain(Value);
LABEL_15:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 176));
        goto LABEL_17;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 184) = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    }
    QueryTableAtPath = _createQueryTableAtPath(*(const __CFString **)(a1 + 192), v7, a4, a5, *(_BYTE *)(a1 + 55));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 184), MutableCopy, QueryTableAtPath);
    goto LABEL_15;
  }
  v14 = CFURLCopyAbsoluteURL(relativeURL);
  MutableCopy = (__CFString *)CFURLCopyFileSystemPath(v14, kCFURLPOSIXPathStyle);
  CFRelease(v14);
  QueryTableAtPath = _createQueryTableAtPath(MutableCopy, v7, a4, a5, 0);
LABEL_17:
  CFRelease(MutableCopy);
  if (v7)
    CFRelease(v7);
  if (QueryTableAtPath)
    return QueryTableAtPath;
  else
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

CFTypeRef _CFBundleCopyLanguageSearchListInBundle(uint64_t a1)
{
  os_unfair_lock_s *v2;
  __CFArray *v3;
  const __CFArray *v4;
  const __CFArray *v5;
  __CFString *DevelopmentRegion;
  void *ValueAtIndex;
  CFIndex Count;
  CFRange v9;
  const __CFString *v10;
  const __CFString *v11;
  CFTypeRef v12;
  CFRange v14;
  CFRange v15;
  CFRange v16;
  CFRange v17;

  v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v3 = *(__CFArray **)(a1 + 40);
  if (v3)
    goto LABEL_33;
  os_unfair_lock_unlock(v2);
  v4 = (const __CFArray *)_CFBundleCopyBundleLocalizations(a1, 0);
  v5 = (const __CFArray *)_CFBundleCopyUserLanguages();
  DevelopmentRegion = (__CFString *)CFBundleGetDevelopmentRegion((CFBundleRef)a1);
  v3 = _CFBundleCopyPreferredLanguagesInList(v4, DevelopmentRegion, v5, 1, *(_QWORD *)(a1 + 16), (__CFBundle *)a1);
  if (!CFArrayGetCount(v3))
  {
    CFRelease(v3);
    v3 = _CFBundleCopyPreferredLanguagesInList(v4, CFSTR("en_US"), v5, 1, *(_QWORD *)(a1 + 16), (__CFBundle *)a1);
  }
  if (!CFArrayGetCount(v3) && v4 && CFArrayGetCount(v4) >= 1)
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(v4, 0);
    CFRelease(v3);
    v3 = _CFBundleCopyPreferredLanguagesInList(v4, ValueAtIndex, v5, 1, *(_QWORD *)(a1 + 16), (__CFBundle *)a1);
  }
  if (v5)
    CFRelease(v5);
  if (DevelopmentRegion)
  {
    v14.length = CFArrayGetCount(v3);
    v14.location = 0;
    if (!CFArrayContainsValue(v3, v14, DevelopmentRegion))
      CFArrayAppendValue(v3, DevelopmentRegion);
    if (!v4)
      goto LABEL_25;
    goto LABEL_24;
  }
  if (v4)
  {
    Count = CFArrayGetCount(v4);
    v15.location = 0;
    v15.length = Count;
    if (CFArrayContainsValue(v4, v15, CFSTR("en")))
    {
      v9.length = CFArrayGetCount(v3);
      v10 = CFSTR("en");
    }
    else
    {
      v16.location = 0;
      v16.length = Count;
      if (CFArrayContainsValue(v4, v16, CFSTR("English")))
      {
        v9.length = CFArrayGetCount(v3);
        v10 = CFSTR("English");
      }
      else
      {
        v17.location = 0;
        v17.length = Count;
        if (!CFArrayContainsValue(v4, v17, CFSTR("en_US")))
        {
LABEL_24:
          CFRelease(v4);
          goto LABEL_25;
        }
        v9.length = CFArrayGetCount(v3);
        v10 = CFSTR("en_US");
      }
    }
    v9.location = 0;
    if (!CFArrayContainsValue(v3, v9, v10))
      CFArrayAppendValue(v3, v10);
    goto LABEL_24;
  }
LABEL_25:
  if (!CFArrayGetCount(v3))
  {
    if (_defaultLocalization)
      v11 = (const __CFString *)_defaultLocalization;
    else
      v11 = CFSTR("en");
    CFArrayAppendValue(v3, v11);
  }
  os_unfair_lock_lock_with_options();
  if (*(_QWORD *)(a1 + 40))
  {
    CFRelease(v3);
    v3 = *(__CFArray **)(a1 + 40);
  }
  else
  {
    *(_QWORD *)(a1 + 40) = v3;
  }
LABEL_33:
  v12 = CFRetain(v3);
  os_unfair_lock_unlock(v2);
  return v12;
}

uint64_t _CFBundleLayoutVersion(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 53);
}

__CFArray *_CFBundleCreateMutableArrayOfFallbackLanguages(uint64_t a1, uint64_t a2)
{
  const __CFArray *v2;
  const __CFArray *v3;
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  void *v7;
  void *v8;
  CFIndex v9;
  void *v10;
  void *v11;
  __CFArray *Mutable;
  int v13;
  uint64_t v14;
  const char **v15;
  CFStringRef v16;
  CFStringRef v17;
  _OWORD v19[256];
  uint64_t v20;

  v2 = (const __CFArray *)MEMORY[0x1E0C80A78](a1, a2);
  v4 = v3;
  v5 = v2;
  v20 = *MEMORY[0x1E0C80C00];
  Count = CFArrayGetCount(v2);
  v7 = malloc_type_malloc(8 * Count, 0x10040436913F5uLL);
  v8 = ___CFBundleCreateMutableArrayOfFallbackLanguages_block_invoke((int)v7, v5, (uint64_t)v7);
  v9 = CFArrayGetCount(v4);
  v10 = malloc_type_malloc(8 * v9, 0x10040436913F5uLL);
  v11 = ___CFBundleCreateMutableArrayOfFallbackLanguages_block_invoke((int)v10, v4, (uint64_t)v10);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  if (v8)
  {
    if (v11)
    {
      memset(v19, 0, 512);
      v13 = ualoc_localizationsToUse();
      if (v13 >= 1)
      {
        v14 = v13;
        v15 = (const char **)v19;
        do
        {
          v16 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, *v15, 0x8000100u);
          if (v16)
          {
            v17 = v16;
            CFArrayAppendValue(Mutable, v16);
            CFRelease(v17);
          }
          ++v15;
          --v14;
        }
        while (v14);
      }
    }
  }
  if (v7)
    free(v7);
  if (v8)
    free(v8);
  if (v10)
    free(v10);
  if (v11)
    free(v11);
  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

CFTypeRef _CFBundleRetainStringsSources(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  CFTypeRef result;

  v2 = *(const void **)a1;
  if (v2)
    CFRetain(v2);
  v3 = *(const void **)(a1 + 8);
  if (v3)
    CFRetain(v3);
  v4 = *(const void **)(a1 + 16);
  if (v4)
    CFRetain(v4);
  v5 = *(const void **)(a1 + 24);
  if (v5)
    CFRetain(v5);
  v6 = *(const void **)(a1 + 32);
  if (v6)
    CFRetain(v6);
  v7 = *(const void **)(a1 + 40);
  if (v7)
    CFRetain(v7);
  v8 = *(const void **)(a1 + 48);
  if (v8)
    CFRetain(v8);
  result = *(CFTypeRef *)(a1 + 56);
  if (result)
    return CFRetain(result);
  return result;
}

const void *_CFBundleCopyBundleLocalizations(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  const void *v5;

  v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  os_unfair_lock_lock_with_options();
  if (!*(_BYTE *)(a1 + 128))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    if (CFBundleGetMainBundle() != (CFBundleRef)a1)
      goto LABEL_8;
    if (CFBundleFollowParentLocalization_once != -1)
      dispatch_once(&CFBundleFollowParentLocalization_once, &__block_literal_global_135);
    if (CFBundleFollowParentLocalization_followParent != 1
      || (v5 = _CFBundleCopyXPCBootstrapMainBundleLanguages()) == 0)
    {
LABEL_8:
      v5 = _copyBundleLocalizationsFromResources((__CFBundle *)a1, a2);
    }
    os_unfair_lock_lock_with_options();
    if (!*(_BYTE *)(a1 + 128))
    {
      *(_QWORD *)(a1 + 120) = CFRetain(v5);
      *(_BYTE *)(a1 + 128) = 1;
      goto LABEL_12;
    }
    CFRelease(v5);
  }
  v5 = CFRetain(*(CFTypeRef *)(a1 + 120));
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  return v5;
}

uint64_t __CFArrayCreate0(__objc2_class **a1, uint64_t *a2, uint64_t a3, const CFArrayCallBacks *a4)
{
  uint64_t Init;
  uint64_t v8;
  unsigned int v9;
  int v10;
  const CFArrayCallBacks *v11;
  char v12;
  int v13;
  const CFArrayCallBacks *v14;
  char v15;
  int v16;
  char v17;
  BOOL v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  Init = __CFArrayCreateInit(a1, 0, a3, a4);
  v8 = Init;
  v9 = atomic_load((unint64_t *)(Init + 8));
  v10 = (v9 >> 2) & 3;
  if (v10)
  {
    if (v10 == 1)
    {
      v11 = &kCFTypeArrayCallBacks;
    }
    else
    {
      v12 = atomic_load((unint64_t *)(Init + 8));
      v13 = v12 & 3;
      if (v13)
        v14 = 0;
      else
        v14 = (const CFArrayCallBacks *)(Init + 48);
      if (v13 == 2)
        v11 = (const CFArrayCallBacks *)(Init + 48);
      else
        v11 = v14;
    }
  }
  else
  {
    v11 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  v15 = atomic_load((unint64_t *)(Init + 8));
  v16 = v15 & 3;
  if (v16 == 2)
  {
    v20 = (_QWORD *)(*(_QWORD *)(Init + 40) + 8 * **(_QWORD **)(Init + 40) + 16);
  }
  else if (v16)
  {
    v20 = 0;
  }
  else
  {
    v17 = atomic_load((unint64_t *)(Init + 8));
    v18 = (~v17 & 0xC) == 0;
    v19 = 48;
    if (v18)
      v19 = 88;
    v20 = (_QWORD *)(Init + v19);
  }
  if (v11->retain)
  {
    if (a3 >= 1)
    {
      v21 = a3;
      do
      {
        v22 = *a2++;
        *v20++ = ((uint64_t (*)(__objc2_class **, uint64_t))v11->retain)(a1, v22);
        --v21;
      }
      while (v21);
    }
  }
  else if (a3 >= 1)
  {
    v23 = a3;
    do
    {
      v24 = *a2++;
      *v20++ = v24;
      --v23;
    }
    while (v23);
  }
  *(_QWORD *)(v8 + 16) = a3;
  return v8;
}

const __CFString *_CFGetSlashStr()
{
  return CFSTR("/");
}

void _CFBundleIngestResultForBundleCache(uint64_t a1, const void *a2, int a3, uint64_t a4)
{
  os_unfair_lock_s *v8;
  const __CFDictionary *v9;
  CFTypeRef *Value;
  CFTypeRef *v11;
  BOOL v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  int v17;
  BOOL v18;
  const void *v19;
  const void *v20;
  BOOL v21;
  _OWORD *v22;
  const void *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  BOOL v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v8 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  v9 = *(const __CFDictionary **)(a1 + 168);
  if (v9)
  {
    Value = (CFTypeRef *)CFDictionaryGetValue(v9, a2);
    v11 = Value;
    v12 = a3 != 0;
    if (a3 && Value)
    {
      v13 = *(const void **)(a4 + 8);
      v15 = *(const void **)(a4 + 24);
      v14 = *(const void **)(a4 + 32);
      v16 = *(const void **)(a4 + 40);
      v17 = *(unsigned __int8 *)(a4 + 65);
      if (Value[1])
        v18 = 1;
      else
        v18 = v13 == 0;
      if (!v18)
      {
        if (*Value)
          _CFBundleIngestResultForBundleCache_cold_4();
        if (Value[2])
          _CFBundleIngestResultForBundleCache_cold_3();
        v19 = *(const void **)a4;
        v20 = *(const void **)(a4 + 16);
        if (v20 && *(_BYTE *)(a4 + 64))
        {
          v11[2] = CFRetain(v20);
          *((_BYTE *)v11 + 64) = 1;
        }
        if (v19)
          *v11 = CFRetain(v19);
        v11[1] = CFRetain(v13);
      }
      if (v11[4])
        v21 = 1;
      else
        v21 = v14 == 0;
      if (!v21)
      {
        if (v11[3])
          _CFBundleIngestResultForBundleCache_cold_2();
        if (v11[5])
          _CFBundleIngestResultForBundleCache_cold_1();
        if (v16 && v17)
        {
          v11[5] = CFRetain(v16);
          *((_BYTE *)v11 + 65) = 1;
        }
        if (v15)
          v11[3] = CFRetain(v15);
        v11[4] = CFRetain(v14);
      }
      goto LABEL_44;
    }
    if (Value)
      goto LABEL_44;
  }
  else
  {
    v28 = xmmword_1E1335D28;
    v29 = *(_OWORD *)&off_1E1335D38;
    *(_QWORD *)&v30 = 0;
    *(_QWORD *)(a1 + 168) = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, (const CFDictionaryValueCallBacks *)&v28);
    v12 = a3 != 0;
  }
  v22 = malloc_type_malloc(0x48uLL, 0x1060040C3D82AC4uLL);
  if (!v22)
    goto LABEL_44;
  v23 = v22;
  *v22 = *(_OWORD *)a4;
  v24 = *(_OWORD *)(a4 + 16);
  v25 = *(_OWORD *)(a4 + 32);
  v26 = *(_OWORD *)(a4 + 48);
  *((_QWORD *)v22 + 8) = *(_QWORD *)(a4 + 64);
  v22[2] = v25;
  v22[3] = v26;
  v22[1] = v24;
  if (!v12)
  {
    *((_WORD *)v22 + 32) = 0;
    *(_QWORD *)v22 = 0;
    *((_QWORD *)v22 + 1) = 0;
    *((_QWORD *)v22 + 3) = 0;
    *((_QWORD *)v22 + 4) = 0;
LABEL_35:
    *((_QWORD *)v22 + 2) = 0;
    goto LABEL_36;
  }
  if (!*(_BYTE *)(a4 + 64))
    goto LABEL_35;
LABEL_36:
  if (*(_BYTE *)(a4 + 65))
    v27 = v12;
  else
    v27 = 0;
  if (!v27)
    *((_QWORD *)v22 + 5) = 0;
  if (!*(_BYTE *)(a4 + 66))
    *((_QWORD *)v22 + 7) = 0;
  v29 = v22[1];
  v30 = v22[2];
  v31 = v22[3];
  v32 = *((_QWORD *)v22 + 8);
  v28 = *v22;
  _CFBundleRetainStringsSources((uint64_t)&v28);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 168), a2, v23);
LABEL_44:
  os_unfair_lock_unlock(v8);
}

CFURLRef CFBundleCopyResourceURLForLocalization(CFURLRef bundle, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName, CFStringRef localizationName)
{
  if (bundle)
    return _CFBundleCopyFindResources((unint64_t *)bundle, 0, (uint64_t)resourceType, resourceName, resourceType, subDirName, localizationName, 0, 1, 0);
  return bundle;
}

uint64_t _useLoctableInsteadOfFileBasedOnVersion(CFTypeRef *a1, CFTypeRef *a2, unsigned int a3, CFTypeRef cf)
{
  const __CFURL *v7;

  if (!cf)
    return 0;
  v7 = (const __CFURL *)*a1;
  if (v7)
  {
    if (_CFBundleGetFileVersionForStringsResourceURL(v7) >= a3)
      return 0;
    if (*a1)
      CFRelease(*a1);
  }
  *a1 = 0;
  if (*a2)
    CFRelease(*a2);
  *a2 = CFRetain(cf);
  return 1;
}

const __CFURL *_CFBundleGetFileVersionForStringsResourceURL(const __CFURL *result)
{
  const __CFString *v1;
  const __CFString *ProductNameSuffix;
  const __CFString *PlatformNameSuffix;
  CFTypeRef cf;
  unsigned int v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v5 = 0;
    result = (const __CFURL *)CFURLCopyLastPathComponent(result);
    if (result)
    {
      v1 = (const __CFString *)result;
      cf = 0;
      ProductNameSuffix = (const __CFString *)_CFBundleGetProductNameSuffix();
      PlatformNameSuffix = _CFBundleGetPlatformNameSuffix();
      _CFBundleSplitFileName(v1, (__CFString **)&cf, 0, 0, ProductNameSuffix, PlatformNameSuffix, 2, (int *)&v5);
      if (cf)
        CFRelease(cf);
      CFRelease(v1);
      return (const __CFURL *)v5;
    }
  }
  return result;
}

CFDataRef _CFDataCreateFromURL(CFURLRef url, CFErrorRef *a2)
{
  int v3;
  CFErrorRef v4;
  CFDataRef result;
  SInt32 errorCode;
  CFDataRef resourceData[2];

  resourceData[1] = *(CFDataRef *)MEMORY[0x1E0C80C00];
  resourceData[0] = 0;
  errorCode = 0;
  v3 = CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, url, resourceData, 0, 0, &errorCode);
  if (!a2 || v3)
    return resourceData[0];
  v4 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("NSOSStatusErrorDomain"), errorCode, 0);
  result = 0;
  *a2 = v4;
  return result;
}

CFStringRef _CFBundleCopyLanguageForStringsResourceURL(const __CFURL *a1)
{
  const __CFString *v1;
  CFStringRef v2;
  CFRange v4;
  CFRange result;
  uint64_t v6;
  CFRange v7;
  CFRange v8;
  CFRange v9;

  v6 = *MEMORY[0x1E0C80C00];
  v1 = CFURLCopyPath(a1);
  v7.length = CFStringGetLength(v1);
  result.location = 0;
  result.length = 0;
  v4.location = 0;
  v4.length = 0;
  v7.location = 0;
  if (CFStringFindWithOptions(v1, CFSTR(".lproj"), v7, 4uLL, &result)
    && (v8.length = result.location, v8.location = 0, CFStringFindWithOptions(v1, CFSTR("/"), v8, 4uLL, &v4)))
  {
    v9.location = v4.length + v4.location;
    v9.length = result.location - (v4.length + v4.location);
    v2 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, v9);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void _onelineFormatArray(__CFString *a1, const __CFArray *a2)
{
  CFRange v4;
  CFRange v5;

  CFStringAppend(a1, CFSTR("["));
  if (a2)
  {
    v4.length = CFArrayGetCount(a2);
    v4.location = 0;
    CFArrayApplyFunction(a2, v4, (CFArrayApplierFunction)_onelineFormatArrayApply, a1);
    if (CFArrayGetCount(a2) >= 1)
    {
      v5.location = CFStringGetLength(a1) - 2;
      v5.length = 2;
      CFStringDelete(a1, v5);
    }
  }
  else
  {
    CFStringAppend(a1, CFSTR("<null>"));
  }
  CFStringAppend(a1, CFSTR("]"));
}

_QWORD *_CFBundleCreateMain(const __CFAllocator *a1, const __CFURL *a2)
{
  return _CFBundleCreate(a1, a2, 3, 0);
}

CFTypeRef _CFBundleCopyXPCBootstrapMainBundleLanguages()
{
  CFTypeRef result;

  if (_CFBundleCopyXPCBootstrapMainBundleLanguages_onceToken != -1)
    dispatch_once(&_CFBundleCopyXPCBootstrapMainBundleLanguages_onceToken, &__block_literal_global_141);
  result = (CFTypeRef)_CFBundleCopyXPCBootstrapMainBundleLanguages_result;
  if (_CFBundleCopyXPCBootstrapMainBundleLanguages_result)
    return CFRetain((CFTypeRef)_CFBundleCopyXPCBootstrapMainBundleLanguages_result);
  return result;
}

void CFBundleGetMainBundle_cold_1(uint64_t a1, NSObject *a2, _QWORD *a3)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 56);
  v5 = 138543618;
  v6 = a1;
  v7 = 2048;
  v8 = v4;
  _os_log_debug_impl(&dword_182A8C000, a2, OS_LOG_TYPE_DEBUG, "main bundle %{public}@ getting handle %p", (uint8_t *)&v5, 0x16u);
  *a3 = _mainBundle;
}

CFIndex _CFAttributedStringGetLength(uint64_t a1)
{
  return CFStringGetLength(*(CFStringRef *)(a1 + 16));
}

void sub_182B341F0(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182B34748(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182B34A80(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182B34E44(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182B35490(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182B358DC(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

__objc2_class **__NSOrderedSetImmutablePlaceholder()
{
  return &___immutablePlaceholderOrderedSet;
}

void sub_182B35DDC(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182B36534(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

uint64_t _NSIsNSOrderedSet(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*MethodImplementation)(uint64_t, char *);

  if (a1)
  {
    v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
      return MethodImplementation(v1, sel_isNSOrderedSet__);
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }
  return a1 & 1;
}

__objc2_class **__NSOrderedSetMutablePlaceholder()
{
  return &___mutablePlaceholderOrderedSet;
}

unint64_t *__NSOrderedSetM_new(id *a1, unint64_t a2, char a3)
{
  unint64_t *result;
  unint64_t *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  id v11;
  NSMutableArray *v12;
  uint64_t v13;
  void *v14;
  objc_class *v15;
  size_t v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  result = (unint64_t *)CFBasicHashCreate(&__kCFAllocatorSystemDefault, 0x7000u, __NSOrderedSetMCB);
  if (result)
  {
    v7 = result;
    v16[0] = 0;
    v8 = _CFCreateArrayStorage(a2, 0, v16);
    if (v8)
    {
      v9 = v8;
      v10 = 0;
      if (a1 && a2)
      {
        v10 = 0;
        do
        {
          if (CFBasicHashAddValue((uint64_t)v7, (unint64_t)*a1, (uint64_t)*a1))
          {
            if ((a3 & 1) == 0)
              v11 = *a1;
            v9[v10++] = *a1;
          }
          ++a1;
          --a2;
        }
        while (a2);
      }
      v12 = [NSMutableArray alloc];
      v13 = -[NSArray _initByAdoptingBuffer:count:size:](v12, "_initByAdoptingBuffer:count:size:", v9, v10, v16[0]);
      if (v13)
      {
        v14 = (void *)v13;
        v15 = (objc_class *)objc_opt_self();
        result = (unint64_t *)__CFAllocateObject(v15, 0);
        if (result)
        {
          result[2] = (unint64_t)v7;
          result[3] = (unint64_t)v14;
          atomic_store(0, result + 1);
          return result;
        }
        CFRelease(v7);

        return 0;
      }
      if ((a3 & 1) == 0 && ((v10 - 1) & 0x8000000000000000) == 0)
      {
        do

        while (v10);
      }
      free(v9);
    }
    CFRelease(v7);
    return 0;
  }
  return result;
}

_QWORD *__NSArrayM_transferNew(void *a1, int a2, int a3)
{
  objc_class *v6;
  _QWORD *v7;
  _QWORD *v8;

  v6 = (objc_class *)objc_opt_self();
  v7 = __CFAllocateObject(v6, 0);
  v8 = v7;
  if (v7)
  {
    v7[2] = a1;
    *((_DWORD *)v7 + 6) = 0;
    *((_DWORD *)v7 + 7) = a3;
    *((_DWORD *)v7 + 8) = 1;
    *((_DWORD *)v7 + 9) = a2;
  }
  else
  {
    free(a1);
  }
  return v8;
}

char *__NSOrderedSetI_new(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  id v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  void *v24;
  unint64_t v25;
  objc_class *v26;
  char *v27;
  objc_class *v28;
  size_t v30;
  uint64_t v31;
  char *v34;
  _QWORD *__src;

  v4 = 0;
  v5 = 1;
  v6 = 2;
  v7 = 4;
  if (a2 < 0xFFFFFFFF)
  {
    v8 = 2;
  }
  else
  {
    v7 = 8;
    v8 = 8;
  }
  if (a2 >= 0xFFFF)
    v9 = v8;
  else
    v9 = 1;
  if (a2 >= 0xFFFF)
    v6 = v7;
  if (a2 >= 0xFF)
    v10 = v9;
  else
    v10 = 0;
  if (a2 >= 0xFF)
    v5 = v6;
  while (__NSOrderedSetCapacities[v4] < a2)
  {
    if (++v4 == 64)
    {
      __break(1u);
      break;
    }
  }
  if (!a2)
  {
    v28 = (objc_class *)objc_opt_self();
    v27 = (char *)__CFAllocateObject(v28, 0);
    v27[14] = 0;
    *((_WORD *)v27 + 6) = 0;
    *((_DWORD *)v27 + 2) = 0;
    v27[15] &= 3u;
    v27[15] &= 0xFCu;
    return v27;
  }
  v11 = __NSOrderedSetSizes[v4];
  v30 = v11 * v5;
  v12 = (char *)malloc_type_calloc(1uLL, v11 * v5 + 8 * a2, 0x3C0B7052uLL);
  v13 = 0;
  v14 = 0;
  v34 = &v12[8 * a2];
  __src = v12;
  if (v11 <= 1)
    v15 = 1;
  else
    v15 = v11;
  v31 = v15;
LABEL_22:
  v16 = *(void **)(a1 + 8 * v13);
  v17 = objc_msgSend(v16, "hash", v30);
  v18 = v11;
  if (!v4)
    goto LABEL_24;
  v18 = v11;
  if (v4 == 63)
    goto LABEL_24;
  v18 = v17 % v11;
  v21 = v31;
  v22 = v17 % v11;
  while (2)
  {
    switch(v10)
    {
      case 0:
        v23 = v34[v22];
        if (!v34[v22])
          goto LABEL_50;
        goto LABEL_38;
      case 1:
        v23 = *(unsigned __int16 *)&v34[2 * v22];
        if (!*(_WORD *)&v34[2 * v22])
          goto LABEL_50;
        goto LABEL_38;
      case 2:
        v23 = *(unsigned int *)&v34[4 * v22];
        if (!*(_DWORD *)&v34[4 * v22])
          goto LABEL_50;
        goto LABEL_38;
      case 8:
        v23 = *(_QWORD *)&v34[8 * v22];
        if (v23)
        {
LABEL_38:
          v24 = (void *)__src[v23 - 1];
          if (v24 == v16 || (objc_msgSend(v24, "isEqual:", v16) & 1) != 0)
            goto LABEL_48;
          if (v22 + 1 >= v11)
            v25 = v11;
          else
            v25 = 0;
          v22 = v22 + 1 - v25;
          if (!--v21)
          {
            v18 = v11;
            goto LABEL_24;
          }
          continue;
        }
LABEL_50:
        v18 = v22;
LABEL_24:
        v19 = *(_QWORD *)(a1 + 8 * v13);
        __src[v14] = v19;
        if ((a3 & 1) == 0 && v19 >= 1)
          v20 = (id)v19;
        ++v14;
        switch(v10)
        {
          case 0:
            v34[v18] = v14;
            break;
          case 1:
            *(_WORD *)&v34[2 * v18] = v14;
            break;
          case 2:
            *(_DWORD *)&v34[4 * v18] = v14;
            break;
          case 8:
            *(_QWORD *)&v34[8 * v18] = v14;
            break;
          default:
            break;
        }
LABEL_48:
        if (++v13 != a2)
          goto LABEL_22;
        v26 = (objc_class *)objc_opt_self();
        v27 = (char *)__CFAllocateObject(v26, v30 + 8 * v14);
        v27[14] = BYTE6(v14);
        *((_WORD *)v27 + 6) = WORD2(v14);
        *((_DWORD *)v27 + 2) = v14;
        v27[15] = v27[15] & 3 | (4 * v4);
        v27[15] = v27[15] & 0xFC | v10 & 3;
        memmove(v27 + 16, __src, 8 * v14);
        memmove(&v27[8 * v14 + 16], v34, v30);
        free(__src);
        return v27;
      default:
        goto LABEL_24;
    }
  }
}

uint64_t __createOrderedSet(void *a1, uint64_t a2)
{
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v3[0] = a2;
  return objc_msgSend(a1, "initWithObjects:count:", v3, 1);
}

CFStringRef _CFStringCreateWithFormatAndArgumentsAux(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 *a5)
{
  return _CFStringCreateWithFormatAndArgumentsReturningMetadata(a1, a2, 0, a3, 0, 0, a4, 0, a5);
}

void sub_182B384E8(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

uint64_t __createDictionary(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  _QWORD v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  v4 = a3;
  v5[0] = a2;
  return objc_msgSend(a1, "initWithObjects:forKeys:count:", v5, &v4, 1);
}

CFIndex CFURLGetBytes(CFURLRef url, UInt8 *buffer, CFIndex bufferLength)
{
  const __CFString *v6;
  CFStringEncoding v7;
  CFIndex Length;
  CFIndex usedBufLen[2];
  CFRange v11;

  usedBufLen[1] = *MEMORY[0x1E0C80C00];
  usedBufLen[0] = 0;
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
  {
    v6 = CFURLGetString(url);
    v7 = 134217984;
  }
  else
  {
    v6 = (const __CFString *)atomic_load((unint64_t *)url + 3);
    v7 = *((_DWORD *)url + 5);
  }
  Length = CFStringGetLength(v6);
  v11.location = 0;
  v11.length = Length;
  if (CFStringGetBytes(v6, v11, v7, 0, 0, buffer, bufferLength, usedBufLen) == Length)
    return usedBufLen[0];
  else
    return -1;
}

uint64_t _NSIsNSTimeZone(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*MethodImplementation)(uint64_t, char *);

  if (a1)
  {
    v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
      return MethodImplementation(v1, sel_isNSTimeZone__);
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }
  return a1 & 1;
}

void sub_182B38A4C(_Unwind_Exception *a1)
{
  free(0);
  _Unwind_Resume(a1);
}

uint64_t _CFRunLoop01(uint64_t a1, const void *a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;

  v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v5 = CFSetContainsValue(*(CFSetRef *)(a1 + 608), a2);
  pthread_mutex_unlock(v4);
  return v5;
}

uint64_t doAccess(uint64_t a1, uint64_t a2, int a3, CFStringRef theString)
{
  CFIndex Length;
  CFIndex v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v16;
  int v17;
  const UniChar *CharactersPtr;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  CFIndex v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  CFRange v33;

  Length = CFStringGetLength(theString);
  v9 = Length;
  if (Length >= a2)
    v10 = a2;
  else
    v10 = Length;
  if (a2 >= 0)
    v11 = v10;
  else
    v11 = 0;
  v12 = *(_QWORD *)(a1 + 16);
  if (a3)
  {
    if (v11 >= v12 || (v13 = *(_QWORD *)(a1 + 32), v11 < v13))
    {
      if (v11 >= Length && v12 == Length)
      {
        result = 0;
        *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 44);
        return result;
      }
      goto LABEL_21;
    }
    v17 = v11 - v13;
LABEL_30:
    *(_DWORD *)(a1 + 40) = v17;
    return 1;
  }
  if (v11 <= v12)
  {
    v16 = *(_QWORD *)(a1 + 32);
    if (v11 > v16)
    {
      v17 = v11 - v16;
      goto LABEL_30;
    }
  }
  if (!v11 && !*(_QWORD *)(a1 + 32))
  {
    result = 0;
    *(_DWORD *)(a1 + 40) = 0;
    return result;
  }
LABEL_21:
  CharactersPtr = CFStringGetCharactersPtr(theString);
  *(_QWORD *)(a1 + 48) = CharactersPtr;
  if (CharactersPtr)
  {
    if (v11 > 2147483646)
    {
      v19 = v11 - 0x7FFFFFFF;
      if (a3)
      {
        v19 = v10;
        v32 = 0;
      }
      else
      {
        v32 = 0x7FFFFFFF;
      }
      *(_QWORD *)(a1 + 32) = v19;
      *(_DWORD *)(a1 + 40) = v32;
      *(_QWORD *)(a1 + 48) = &CharactersPtr[v19];
    }
    else
    {
      v19 = 0;
      *(_QWORD *)(a1 + 32) = 0;
      *(_DWORD *)(a1 + 40) = v11;
    }
    v20 = v9 - v19;
    if (v9 - v19 > 2147483646)
    {
      v20 = 0x7FFFFFFF;
      *(_QWORD *)(a1 + 16) = v19 + 0x7FFFFFFF;
      *(_DWORD *)(a1 + 44) = 0x7FFFFFFF;
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v9;
      *(_DWORD *)(a1 + 44) = v20;
    }
LABEL_57:
    *(_DWORD *)(a1 + 28) = v20;
    return 1;
  }
  result = *(_QWORD *)(a1 + 88);
  if (result)
  {
    if (a3)
    {
      v21 = *(_QWORD *)(a1 + 16);
      v22 = v11;
    }
    else
    {
      v22 = *(_QWORD *)(a1 + 32);
      v21 = v11;
    }
    v23 = v22 - v21;
    if (v23 < 0)
      v23 = -v23;
    if ((unint64_t)v23 <= 0x10)
    {
      v24 = *(_DWORD *)(a1 + 124);
      if (v24 <= 4)
        *(_DWORD *)(a1 + 124) = ++v24;
      goto LABEL_40;
    }
LABEL_39:
    v24 = 0;
    *(_DWORD *)(a1 + 124) = 0;
LABEL_40:
    *(_QWORD *)(a1 + 48) = result;
    v25 = (int)v24;
    if (a3)
    {
      *(_QWORD *)(a1 + 32) = v11;
      v26 = _bufferSizes[v24];
      *(_QWORD *)(a1 + 16) = v11 + v26;
      if (v11 + v26 <= v9)
      {
        if (v11 + v26 < v9)
        {
          v9 = __pinIndex(v11 + v26, v9, theString, a3, 1);
          *(_QWORD *)(a1 + 16) = v9;
          v11 = *(_QWORD *)(a1 + 32);
        }
        else
        {
          LODWORD(v9) = v11 + v26;
        }
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v9;
      }
      v29 = 0;
      v30 = v9 - v11;
      v31 = v9 - v11;
    }
    else
    {
      if (v11 >= v9)
        v27 = v9;
      else
        v27 = v11;
      *(_QWORD *)(a1 + 16) = v27;
      v28 = _bufferSizes[v25];
      v11 = v27 - v28;
      *(_QWORD *)(a1 + 32) = v27 - v28;
      if (v27 - v28 < 0)
      {
        v11 = 0;
        *(_QWORD *)(a1 + 32) = 0;
      }
      else if (v27 != v28)
      {
        v11 = __pinIndex(v27 - v28, v9, theString, 0, 1);
        *(_QWORD *)(a1 + 32) = v11;
        v27 = *(_QWORD *)(a1 + 16);
      }
      v29 = v27 - v11;
      v30 = v29;
      v31 = v29;
    }
    *(_DWORD *)(a1 + 40) = v29;
    *(_DWORD *)(a1 + 44) = v30;
    v33.length = v31;
    v33.location = v11;
    CFStringGetCharacters(theString, v33, *(UniChar **)(a1 + 48));
    v20 = *(_DWORD *)(a1 + 44);
    goto LABEL_57;
  }
  result = (uint64_t)malloc_type_malloc(0x400uLL, 0x1000040BDFB0063uLL);
  *(_QWORD *)(a1 + 88) = result;
  if (result)
    goto LABEL_39;
  return result;
}

CFIndex __pinIndex(CFIndex idx, CFIndex a2, CFStringRef theString, int a4, int a5)
{
  int v8;
  CFIndex v9;

  if (idx < 0)
    return 0;
  if (idx <= a2)
  {
    if (idx < a2 && idx && a5 && (CFStringGetCharacterAtIndex(theString, idx) & 0xFC00) == 0xDC00)
    {
      v8 = CFStringGetCharacterAtIndex(theString, idx - 1) & 0xFC00;
      if (a4)
        v9 = idx - 1;
      else
        v9 = idx + 1;
      if (v8 == 55296)
        return v9;
      else
        return idx;
    }
    else
    {
      return idx;
    }
  }
  return a2;
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)_CFStreamCreateWithFile((__objc2_class **)alloc, fileURL, 1);
}

void _extractCFPDBits(void *a1, void *a2, void *a3, uint64_t a4)
{
  __int128 *data;
  __int128 v8;
  _BOOL4 v9;
  uint64_t v10;
  void *value;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  void *v15;
  Class Class;
  int v17;
  char *string_ptr;
  uint64_t v19;
  const char *v20;
  const __CFString *v21;
  void *v22;
  const char *p_buffer;
  _QWORD v25[6];
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  _QWORD applier[5];
  size_t length;
  size_t *p_length;
  uint64_t v33;
  uint64_t v34;
  char v35;
  __int16 v36;
  __int128 buffer;
  int pid[4];
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    length = 0;
    buffer = 0u;
    *(_OWORD *)pid = 0u;
    data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
    if (data && length == 32)
    {
      v8 = data[1];
      buffer = *data;
      *(_OWORD *)pid = v8;
    }
    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        value = xpc_dictionary_get_value(a1, "connection");
        if (!value || (value = object_getClass(value), value != (void *)MEMORY[0x1E0C812E0]))
          _extractCFPDBits_cold_1((uint64_t)value, v12, v13);
      }
      xpc_connection_get_audit_token();
    }
    v10 = pid[1];
    v39 = 0u;
    v40 = 0u;
    buffer = 0u;
    *(_OWORD *)pid = 0u;
    v9 = (_DWORD)v10 != -1 && proc_name(v10, &buffer, 0x40u) >= 0;
  }
  else
  {
    v9 = 0;
    v39 = 0u;
    v40 = 0u;
    buffer = 0u;
    *(_OWORD *)pid = 0u;
    v10 = 0xFFFFFFFFLL;
  }
  v36 = 0;
  v35 = 0;
  v14 = toCString((const __CFString *)objc_msgSend(a3, "domain"), (char *)&v36 + 1, "no domain");
  v15 = toCString((const __CFString *)objc_msgSend(a3, "user"), (char *)&v36, "no user");
  if (!a2)
    goto LABEL_16;
  Class = object_getClass(a2);
  if (Class == (Class)MEMORY[0x1E0C81390])
  {
    string_ptr = (char *)xpc_string_get_string_ptr(a2);
    v17 = 0;
  }
  else
  {
    if (Class != (Class)MEMORY[0x1E0C812F8])
    {
LABEL_16:
      v17 = 0;
      string_ptr = "no key";
      goto LABEL_19;
    }
    length = 0;
    p_length = &length;
    v33 = 0x2020000000;
    v19 = MEMORY[0x1E0C809B0];
    v34 = 0;
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 3221225472;
    applier[2] = ___extractCFPDBits_block_invoke;
    applier[3] = &unk_1E12E1650;
    applier[4] = &length;
    xpc_dictionary_apply(a2, applier);
    string_ptr = (char *)malloc_type_calloc(1uLL, p_length[3] + 3, 0x358531DDuLL);
    *string_ptr = 91;
    v26 = 0;
    v27 = &v26;
    v28 = 0x2020000000;
    v29 = 1;
    v25[0] = v19;
    v25[1] = 3221225472;
    v25[2] = ___extractCFPDBits_block_invoke_2;
    v25[3] = &unk_1E1336748;
    v25[4] = &v26;
    v25[5] = string_ptr;
    xpc_dictionary_apply(a2, v25);
    string_ptr[*((int *)v27 + 6)] = 93;
    _Block_object_dispose(&v26, 8);
    _Block_object_dispose(&length, 8);
    v17 = 1;
  }
LABEL_19:
  if (objc_msgSend(a3, "byHost"))
    v20 = "kCFPreferencesCurrentHost";
  else
    v20 = "kCFPreferencesAnyHost";
  v21 = (const __CFString *)objc_msgSend(a3, "copyUncanonicalizedPath");
  v22 = toCString(v21, &v35, "no uncanonicalized path");
  if (v9)
    p_buffer = (const char *)&buffer;
  else
    p_buffer = "unknown process name";
  (*(void (**)(uint64_t, uint64_t, const char *, void *, char *, void *, const char *, void *, _BYTE))(a4 + 16))(a4, v10, p_buffer, v14, string_ptr, v15, v20, v22, objc_msgSend(a3, "managed"));
  if (v21)
    CFRelease(v21);
  if (HIBYTE(v36))
    free(v14);
  if ((_BYTE)v36)
    free(v15);
  if (v35)
    free(v22);
  if (v17)
    free(string_ptr);
}

void sub_182B391DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a17, 8);
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

BOOL _CFPrefsEqualKeyOrSource(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2;
  __objc2_class *Class;
  __objc2_class *v5;
  _QWORD *v6;
  __objc2_class *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  BOOL v12;
  const void *v13;
  const void *v14;
  BOOL v15;
  _BOOL8 v16;
  const void *v17;
  const void *v18;

  if (a1 == a2)
    return 1;
  v2 = a2;
  Class = (__objc2_class *)object_getClass(a1);
  v5 = (__objc2_class *)object_getClass(v2);
  if (Class != CFPDSourceLookUpKey && v5 != CFPDSourceLookUpKey)
    return 0;
  if (Class == CFPDSourceLookUpKey)
    v6 = a1;
  else
    v6 = v2;
  if (Class == CFPDSourceLookUpKey)
  {
    v7 = v5;
  }
  else
  {
    v2 = a1;
    v7 = Class;
  }
  if (v7 == CFPDSourceLookUpKey)
  {
    v10 = (const void *)v6[1];
    v11 = (const void *)v2[1];
    if (v10 != v11)
    {
      v12 = !v10 || v11 == 0;
      if (v12 || !CFEqual(v10, v11))
        return 0;
    }
    v13 = (const void *)v6[2];
    v14 = (const void *)v2[2];
    if (v13 != v14)
    {
      if (v13)
        v15 = v14 == 0;
      else
        v15 = 1;
      if (v15)
        return 0;
      return CFEqual(v13, v14) != 0;
    }
    return 1;
  }
  v8 = (const void *)v6[2];
  if (v8)
  {
    if (v7 != CFPDCloudSource)
      return 0;
    v9 = (const void *)v2[20];
    if (v8 != v9 && (!v9 || !CFEqual(v8, v9)))
      return 0;
  }
  else if (v7 == CFPDCloudSource)
  {
    return 0;
  }
  v17 = (const void *)objc_msgSend(v2, "copyUncanonicalizedPath");
  v18 = (const void *)v6[1];
  if (v18 == v17 || v17 == 0 || v18 == 0)
  {
    v16 = v18 == v17;
    if (!v17)
      return v16;
  }
  else
  {
    v16 = CFEqual(v18, v17) != 0;
  }
  CFRelease(v17);
  return v16;
}

uint64_t _CFPrefsHashKeyOrSource(uint64_t a1)
{
  __objc2_class *Class;
  const __CFString *v3;
  const __CFString *v4;
  CFIndex Length;
  CFIndex v6;
  CFIndex v7;
  CFStringRef v8;
  const void *v9;
  const void *v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  CFIndex v14;
  CFIndex v15;
  CFIndex v16;
  const __CFString *v17;
  uint64_t v18;
  const void *v19;
  _QWORD v21[3];
  CFStringRef v22;
  CFStringRef v23;
  const __CFString *v24;
  uint64_t v25;
  CFRange v26;
  CFRange v27;
  CFRange v28;
  CFRange v29;

  v25 = *MEMORY[0x1E0C80C00];
  Class = (__objc2_class *)object_getClass((id)a1);
  v22 = 0;
  v23 = 0;
  v24 = 0;
  if (Class == CFPDSourceLookUpKey)
  {
    v4 = *(const __CFString **)(a1 + 8);
    if (v4)
    {
      Length = CFStringGetLength(v4);
      v6 = Length;
      if (Length >= 80)
        v7 = 80;
      else
        v7 = Length;
      v26.location = 0;
      v26.length = v7;
      v22 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)(a1 + 8), v26);
      v27.location = v6 - v7;
      v27.length = v7;
      v8 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)(a1 + 8), v27);
    }
    else
    {
      v8 = &stru_1E1337B18;
      v22 = &stru_1E1337B18;
    }
    v23 = v8;
    v10 = *(const void **)(a1 + 16);
    if (v10)
      v11 = (const __CFString *)CFRetain(v10);
    else
      v11 = &stru_1E1337B18;
    v24 = v11;
  }
  else
  {
    if (Class == CFPDCloudSource)
    {
      v9 = *(const void **)(a1 + 160);
      if (v9)
        v3 = (const __CFString *)CFRetain(v9);
      else
        v3 = &stru_1E1337B18;
    }
    else
    {
      v3 = 0;
    }
    v12 = (const __CFString *)objc_msgSend((id)a1, "copyUncanonicalizedPath");
    if (v12)
    {
      v13 = v12;
      v14 = CFStringGetLength(v12);
      v15 = v14;
      if (v14 >= 80)
        v16 = 80;
      else
        v16 = v14;
      v28.location = 0;
      v28.length = v16;
      v22 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v28);
      v29.location = v15 - v16;
      v29.length = v16;
      v23 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v29);
      CFRelease(v13);
    }
    else
    {
      v22 = &stru_1E1337B18;
      v23 = &stru_1E1337B18;
    }
    if (v3)
      v17 = v3;
    else
      v17 = &stru_1E1337B18;
    v24 = v17;
  }
  v18 = 0;
  memset(v21, 0, sizeof(v21));
  do
  {
    v19 = *(CFStringRef *)((char *)&v22 + v18 * 8);
    v21[v18] = CFHash(v19);
    if (v19)
      CFRelease(v19);
    ++v18;
  }
  while (v18 != 3);
  return CFHashBytes((uint64_t)v21, 24);
}

void *toCString(const __CFString *a1, char *a2, void *a3)
{
  const __CFString *v5;
  CFTypeID v6;
  CFStringRef v7;
  CFStringEncoding SystemEncoding;
  const char *CStringPtr;
  char v10;
  CFIndex Length;
  CFIndex v12;
  char *v13;

  if (!a1)
    goto LABEL_10;
  v5 = a1;
  v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID())
  {
    v7 = CFCopyDescription(v5);
    if (!v7)
      goto LABEL_10;
    v5 = v7;
    CFAutorelease(v7);
  }
  SystemEncoding = CFStringGetSystemEncoding();
  CStringPtr = CFStringGetCStringPtr(v5, SystemEncoding);
  if (!CStringPtr)
  {
    Length = CFStringGetLength(v5);
    v12 = CFStringGetMaximumSizeForEncoding(Length, SystemEncoding) + 1;
    v10 = 1;
    v13 = (char *)malloc_type_calloc(v12, 1uLL, 0x100004077774924uLL);
    if (CFStringGetCString(v5, v13, v12, SystemEncoding))
    {
      a3 = v13;
      goto LABEL_11;
    }
    free(v13);
LABEL_10:
    v10 = 0;
    goto LABEL_11;
  }
  v10 = 0;
  a3 = (void *)CStringPtr;
LABEL_11:
  *a2 = v10;
  return a3;
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, *(uint64_t *)&bytes.byte0, *(uint64_t *)&bytes.byte8, 0);
}

NSFileSecurity *_CFFileSecurityCreateFromFilesec(uint64_t a1, uint64_t a2)
{
  if (a2)
    return -[NSFileSecurity initWithFileSec:]([NSFileSecurity alloc], "initWithFileSec:", a2);
  else
    return 0;
}

CFFileSecurityRef CFFileSecurityCreateCopy(CFAllocatorRef allocator, CFFileSecurityRef fileSec)
{
  CFFileSecurityRef result;
  _filesec *v3;

  result = filesec_dup((filesec_t)-[__CFFileSecurity _filesec](fileSec, "_filesec"));
  if (result)
  {
    v3 = result;
    result = -[NSFileSecurity initWithFileSec:]([NSFileSecurity alloc], "initWithFileSec:", result);
    if (!result)
    {
      filesec_free(v3);
      return 0;
    }
  }
  return result;
}

CFArrayRef _CFURLComponentsCopyQueryItems(void *a1)
{
  return __CFURLComponentsCopyQueryItems(a1, 0);
}

void __CFBasicHashIncSlotCount(uint64_t a1)
{
  __asm { BR              X9 }
}

void sub_182B39A24(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v20;
  const void *v21;
  uint64_t v22;
  unsigned int v23;

  v23 = *(unsigned __int8 *)(v22 + v20);
  if (v23 > 0x7E)
  {
    CFGetAllocator(v21);
    __asm { BR              X10 }
  }
  *(_BYTE *)(v22 + v20) = v23 + 1;
}

Boolean CFBitVectorContainsBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (!range.length)
    return 0;
  v5 = 0;
  v4 = value;
  __CFBitVectorInternalMap((uint64_t)bv, range.location, range.length, (uint64_t (*)(_QWORD, uint64_t, uint64_t))__CFBitVectorCountBits, (uint64_t)&v4);
  return v5 != 0;
}

void CFBitVectorGetBits(CFBitVectorRef bv, CFRange range, UInt8 *bytes)
{
  _QWORD v3[5];

  v3[4] = *MEMORY[0x1E0C80C00];
  if (range.length)
  {
    v3[0] = bytes;
    v3[1] = range.location & 7;
    v3[2] = range.length;
    v3[3] = 1;
    __CFBitVectorInternalMap((uint64_t)bv, range.location, range.length, (uint64_t (*)(_QWORD, uint64_t, uint64_t))__CFBitVectorGetBits, (uint64_t)v3);
  }
}

void CFBitVectorSetCount(CFMutableBitVectorRef bv, CFIndex count)
{
  CFIndex v4;
  char v5;
  BOOL v6;
  CFIndex v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  CFAllocatorRef v12;
  CFIndex v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v4 = *((_QWORD *)bv + 2);
  v5 = atomic_load((unint64_t *)bv + 1);
  v6 = (v5 & 0xC) != 4 || count <= v4;
  if (!v6)
  {
    v7 = count;
    if ((unint64_t)count <= 1)
      v7 = 1;
    v8 = v7 + 63;
    v6 = v7 < -63;
    v9 = v7 + 126;
    if (!v6)
      v9 = v8;
    v10 = v9 >> 6;
    v11 = v9 & 0xFFFFFFFFFFFFFFC0;
    v12 = CFGetAllocator(bv);
    *((_QWORD *)bv + 3) = v11;
    *((_QWORD *)bv + 4) = __CFSafelyReallocateWithAllocatorTyped(v12, *((_QWORD *)bv + 4), (8 * v10) | 1, 0x100004077774924, 0, 0);
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
  }
  v13 = count - v4;
  if (count > v4)
  {
    v14 = v4 / 8;
    v15 = (v4 & 7) + v13;
    v16 = (v4 | 0xFFFFFFFFFFFFFFF8) + v13;
    v17 = (255 << ((v4 & 7) - v15 + 8)) >> (v4 & 7);
    if (v15 > 7)
      LOBYTE(v17) = 0xFFu >> (v4 & 7);
    else
      v16 = 0;
    *(_BYTE *)(*((_QWORD *)bv + 4) + v14) &= ~(_BYTE)v17;
    if (v16 >= 0)
      v18 = v16;
    else
      v18 = v16 + 7;
    v19 = v18 & 0xFFFFFFFFFFFFFFF8;
    v20 = v14 + 1;
    if ((unint64_t)(v16 + 7) >= 0xF)
    {
      v21 = v18 >> 3;
      do
      {
        *(_BYTE *)(*((_QWORD *)bv + 4) + v20++) = 0;
        --v21;
      }
      while (v21);
    }
    if (v19 != v16)
      *(_BYTE *)(*((_QWORD *)bv + 4) + v20) &= ~(255 << (v19 - v16 + 8));
  }
  *((_QWORD *)bv + 2) = count;
}

uint64_t __CFBitVectorInternalMap(uint64_t result, uint64_t a2, uint64_t a3, uint64_t (*a4)(_QWORD, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;

  if (a3)
  {
    v7 = result;
    v8 = a2 / 8;
    v9 = (a2 & 7) + a3;
    if (v9 <= 7)
      v10 = 0;
    else
      v10 = (a2 | 0xFFFFFFFFFFFFFFF8) + a3;
    if (v9 <= 7)
      v11 = (255 << (8 - a3)) >> (a2 & 7);
    else
      v11 = 0xFFu >> (a2 & 7);
    result = a4(*(unsigned __int8 *)(*(_QWORD *)(result + 32) + v8), v11, a5);
    *(_BYTE *)(*(_QWORD *)(v7 + 32) + v8) = *(_BYTE *)(*(_QWORD *)(v7 + 32) + v8) & ~(_BYTE)v11 | result & v11;
    if (v10 >= 0)
      v12 = v10;
    else
      v12 = v10 + 7;
    v13 = v12 & 0xFFFFFFFFFFFFFFF8;
    v14 = v8 + 1;
    if ((unint64_t)(v10 + 7) >= 0xF)
    {
      v15 = v12 >> 3;
      do
      {
        --v15;
        result = a4(*(unsigned __int8 *)(*(_QWORD *)(v7 + 32) + v14), 255, a5);
        *(_BYTE *)(*(_QWORD *)(v7 + 32) + v14++) = result;
      }
      while (v15);
    }
    if (v13 != v10)
    {
      v16 = 255 << (v13 - v10 + 8);
      result = a4(*(unsigned __int8 *)(*(_QWORD *)(v7 + 32) + v14), v16, a5);
      *(_BYTE *)(*(_QWORD *)(v7 + 32) + v14) = *(_BYTE *)(*(_QWORD *)(v7 + 32) + v14) & ~(_BYTE)v16 | result & v16;
    }
  }
  return result;
}

uint64_t __CFBitVectorGetBits(uint64_t result, int a2, uint64_t a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  _BYTE *v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;

  v3 = a2 & result;
  v4 = *(_QWORD *)(a3 + 8);
  v5 = 8 - v4;
  if (8 - v4 >= *(_QWORD *)(a3 + 16))
    v5 = *(_QWORD *)(a3 + 16);
  if (v4 >= 1)
  {
    if (!*(_BYTE *)(a3 + 24))
    {
      **(_BYTE **)a3 |= v3 >> (8 - v4);
      v4 = *(_QWORD *)(a3 + 8);
      ++*(_QWORD *)a3;
      *(_QWORD *)(a3 + 16) -= v4;
      *(_BYTE *)(a3 + 24) = 0;
    }
    v3 <<= v4;
  }
  if (v5 < 8)
  {
    v7 = v3;
    v9 = v5;
  }
  else
  {
    v6 = *(_BYTE **)a3;
    do
    {
      v7 = 0;
      *v6 = v3;
      v8 = *(_QWORD *)(a3 + 8);
      v6 = (_BYTE *)(*(_QWORD *)a3 + 1);
      *(_QWORD *)a3 = v6;
      *(_QWORD *)(a3 + 16) -= v8;
      v9 = v5 - 8;
      LOBYTE(v3) = 0;
      v10 = (unint64_t)v5 > 0xF;
      v5 -= 8;
    }
    while (v10);
  }
  if (v9 >= 1)
  {
    **(_BYTE **)a3 = v7;
    *(_QWORD *)(a3 + 16) -= v9;
  }
  return result;
}

uint64_t __CFBitVectorCountBits(uint64_t result, unsigned int a2, uint64_t a3)
{
  int v3;

  if (*(_DWORD *)a3)
    v3 = result;
  else
    v3 = ~(_DWORD)result;
  *(_QWORD *)(a3 + 8) += __CFBitVectorCountBits___CFNibbleBitCount[v3 & a2 & 0xFLL]
                       + (unint64_t)__CFBitVectorCountBits___CFNibbleBitCount[(unint64_t)(v3 & a2) >> 4];
  return result;
}

CFStringRef CFURLCopyUserName(CFURLRef anURL)
{
  return _CFURLCopyUserName((uint64_t)anURL, 1);
}

CFStringRef CFURLCopyPassword(CFURLRef anURL)
{
  return _CFURLCopyPassword((uint64_t)anURL, 1);
}

CFMutableStringRef CFBundleCopyLocalizedStringForLocalization(unint64_t *a1, void *a2, void *a3, __CFString *a4, const void *a5)
{
  return _CFBundleCopyLocalizedStringForLocalizationAndTableURL(a1, a2, a3, a4, a5, 0);
}

void CFRunLoopTimerGetContext(CFRunLoopTimerRef timer, CFRunLoopTimerContext *context)
{
  unint64_t v4;
  __int128 v5;
  __int128 v6;

  v4 = _CFGetNonObjCTypeID((unint64_t *)timer);
  if (v4 != 47)
    _CFAssertMismatchedTypeID(0x2FuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v5 = *(_OWORD *)((char *)timer + 152);
  v6 = *(_OWORD *)((char *)timer + 168);
  context->copyDescription = (CFStringRef (__cdecl *)(const void *))*((_QWORD *)timer + 23);
  *(_OWORD *)&context->version = v5;
  *(_OWORD *)&context->retain = v6;
}

Boolean CFRunLoopTimerIsValid(CFRunLoopTimerRef timer)
{
  uint64_t v2;
  unint64_t v3;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (CF_IS_OBJC(0x2FuLL, (__objc2_class **)timer))
  {
    LOBYTE(v2) = -[__CFRunLoopTimer isValid](timer, "isValid");
  }
  else
  {
    v3 = atomic_load((unint64_t *)timer + 1);
    return (v3 >> 3) & 1;
  }
  return v2;
}

CFTimeInterval CFRunLoopTimerGetInterval(CFRunLoopTimerRef timer)
{
  CFTimeInterval result;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (!CF_IS_OBJC(0x2FuLL, (__objc2_class **)timer))
    return *((double *)timer + 14);
  -[__CFRunLoopTimer timeInterval](timer, "timeInterval");
  return result;
}

void *__CFFireTimer(void *a1, uint64_t a2)
{
  void *v3;
  const char *v4;
  void *v5;
  id v6;
  id v7;

  v3 = *(void **)(a2 + 8);
  v4 = *(const char **)(a2 + 16);
  v5 = (void *)_CFAutoreleasePoolPush();
  v6 = a1;
  v7 = v3;
  objc_msgSend(v3, v4, a1);

  return _CFAutoreleasePoolPop(v5);
}

BOOL __CFRunLoopDoTimers(uint64_t a1, uint64_t a2, unint64_t a3)
{
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  __CFArray *Mutable;
  unint64_t *ValueAtIndex;
  char v12;
  unint64_t *v13;
  CFIndex v14;
  CFIndex v15;
  BOOL v16;
  char *v17;

  kdebug_trace();
  v6 = *(const __CFArray **)(a2 + 120);
  if (!v6)
    goto LABEL_16;
  Count = CFArrayGetCount(v6);
  if (Count < 1)
    goto LABEL_16;
  v8 = Count;
  v9 = 0;
  Mutable = 0;
  do
  {
    ValueAtIndex = (unint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 120), v9);
    v12 = atomic_load(ValueAtIndex + 1);
    if ((v12 & 8) != 0)
    {
      v13 = ValueAtIndex;
      if ((ValueAtIndex[2] & 1) == 0 && ValueAtIndex[16] <= a3)
      {
        if (!Mutable)
          Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
        CFArrayAppendValue(Mutable, v13);
      }
    }
    ++v9;
  }
  while (v8 != v9);
  if (Mutable)
  {
    v14 = CFArrayGetCount(Mutable);
    if (v14 < 1)
    {
      v16 = 0;
    }
    else
    {
      v15 = 0;
      v16 = 0;
      do
      {
        v17 = (char *)CFArrayGetValueAtIndex(Mutable, v15);
        v16 = (v16 | __CFRunLoopDoTimer(a1, a2, v17)) != 0;
        ++v15;
      }
      while (v14 != v15);
    }
    CFRelease(Mutable);
  }
  else
  {
LABEL_16:
    v16 = 0;
  }
  kdebug_trace();
  return v16;
}

void sub_182B3ACD4(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182B3ACF4(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x182B3AC88);
}

uint64_t __CFRunLoopDoTimer(uint64_t a1, uint64_t a2, char *cf)
{
  char v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  uint64_t (*v11)(_QWORD);
  uint64_t v12;
  double v13;
  unint64_t v14;
  uint64_t (*v15)(uint64_t, uint64_t);
  void *v16;
  char v17;
  double v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  const void *v23;
  CFIndex Count;
  uint64_t v25;
  unint64_t v26;
  const void **v27;
  size_t v28;
  const void **v29;
  CFIndex v30;
  const void *v31;
  const __CFString **v32;
  CFIndex v33;
  const __CFString *v34;
  uint64_t v35;
  os_unfair_lock_s *v36;
  double Current;
  os_unfair_lock_s *v38;
  double v39;
  uint64_t *v40;
  CFIndex v41;
  const void **v42;
  char *v43;
  os_unfair_lock_t v44;
  unint64_t v45;
  void (*v46)(uint64_t);
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  CFRetain(cf);
  pthread_mutex_lock((pthread_mutex_t *)(cf + 24));
  v6 = atomic_load((unint64_t *)cf + 1);
  if ((v6 & 8) == 0
    || (v7 = *((_QWORD *)cf + 16), v7 > mach_absolute_time())
    || (v8 = *((_WORD *)cf + 8), (v8 & 1) != 0)
    || *((_QWORD *)cf + 11) != a1)
  {
    v9 = 0;
    atomic_load((unint64_t *)cf + 1);
LABEL_6:
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    goto LABEL_7;
  }
  v12 = *((_QWORD *)cf + 20);
  v11 = (uint64_t (*)(_QWORD))*((_QWORD *)cf + 21);
  if (v11)
  {
    v12 = v11(*((_QWORD *)cf + 20));
    v46 = (void (*)(uint64_t))*((_QWORD *)cf + 22);
    v8 = *((_WORD *)cf + 8);
  }
  else
  {
    v46 = 0;
  }
  v13 = *((double *)cf + 14);
  *((_WORD *)cf + 8) = v8 | 1;
  *(_QWORD *)(a2 + 184) = -1;
  *(_QWORD *)(a2 + 192) = -1;
  pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
  os_unfair_lock_lock_with_options();
  v14 = *((_QWORD *)cf + 16);
  v44 = (os_unfair_lock_t)(a1 + 684);
  v45 = v14;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 684));
  __CFArmNextTimerInMode(a2);
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  v15 = (uint64_t (*)(uint64_t, uint64_t))*((_QWORD *)cf + 18);
  v16 = (void *)_CFAutoreleasePoolPush();
  kdebug_trace();
  __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(v15, (uint64_t)cf, v12);
  kdebug_trace();
  __CFRunLoopPerCalloutARPEnd(v16);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (v13 == 0.0)
    CFRunLoopTimerInvalidate((CFRunLoopTimerRef)cf);
  if (v46)
    v46(v12);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(cf + 24));
  *((_WORD *)cf + 8) &= ~1u;
  v17 = atomic_load((unint64_t *)cf + 1);
  if ((v17 & 8) == 0)
  {
    v9 = 1;
    goto LABEL_6;
  }
  if (v45 < *((_QWORD *)cf + 16))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    __CFArmNextTimerInMode(a2);
LABEL_47:
    v9 = 1;
    goto LABEL_7;
  }
  v18 = *((double *)cf + 14);
  if (v18 <= 0.0)
  {
    v22 = 0x7FFFFFFFFFFFFFFFLL;
    if (v45 >= 0x7FFFFFFFFFFFFFFFLL)
      goto LABEL_34;
    goto LABEL_32;
  }
  if (v18 > 504911232.0)
    v18 = 504911232.0;
  v19 = __CFTimeIntervalToTSR(v18);
  if ((v19 ^ 0x7FFFFFFFFFFFFFFFLL) <= v45)
  {
    v22 = 0x7FFFFFFFFFFFFFFFLL;
    goto LABEL_34;
  }
  v20 = v19;
  if (!v19)
LABEL_32:
    __CFRunLoopDoTimer_cold_1();
  v21 = mach_absolute_time();
  v22 = v45 - v20;
  do
    v22 += v20;
  while (v22 <= v21);
LABEL_34:
  v23 = (const void *)*((_QWORD *)cf + 11);
  if (!v23)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    v36 = v44;
    os_unfair_lock_lock(v44);
    *((_QWORD *)cf + 16) = v22;
    Current = CFAbsoluteTimeGetCurrent();
    *((double *)cf + 13) = Current + __CFTimeIntervalUntilTSR(v22);
    os_unfair_lock_unlock(v36);
    goto LABEL_47;
  }
  CFRetain(*((CFTypeRef *)cf + 11));
  Count = CFSetGetCount(*((CFSetRef *)cf + 12));
  MEMORY[0x1E0C80A78](Count, v25);
  v27 = (const void **)((char *)&v44 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v26 >= 0x200)
    v28 = 512;
  else
    v28 = v26;
  bzero((char *)&v44 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0), v28);
  CFSetGetValues(*((CFSetRef *)cf + 12), v27);
  if (Count < 1)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
  }
  else
  {
    v29 = v27;
    v30 = Count;
    do
    {
      v31 = *v29++;
      CFRetain(v31);
      --v30;
    }
    while (v30);
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 24));
    v32 = (const __CFString **)v27;
    v33 = Count;
    do
    {
      v34 = *v32;
      v35 = __CFRunLoopCopyMode((uint64_t)v23, *v32, 0);
      *v32 = (const __CFString *)v35;
      if (v35)
        pthread_mutex_lock((pthread_mutex_t *)(v35 + 16));
      CFRelease(v34);
      ++v32;
      --v33;
    }
    while (v33);
  }
  v38 = v44;
  os_unfair_lock_lock(v44);
  *((_QWORD *)cf + 16) = v22;
  v39 = CFAbsoluteTimeGetCurrent();
  *((double *)cf + 13) = v39 + __CFTimeIntervalUntilTSR(v22);
  if (Count < 1)
  {
    os_unfair_lock_unlock(v38);
  }
  else
  {
    v40 = (uint64_t *)v27;
    v41 = Count;
    do
    {
      if (*v40)
        __CFRepositionTimerInMode(*v40, cf, 1);
      ++v40;
      --v41;
    }
    while (v41);
    os_unfair_lock_unlock(v44);
    v42 = v27 - 1;
    do
    {
      v43 = (char *)v42[Count];
      if (v43)
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v43 + 16));
        CFRelease(v42[Count]);
      }
      --Count;
    }
    while ((unint64_t)(Count + 1) > 1);
  }
  CFRelease(v23);
  v9 = 1;
LABEL_7:
  CFRelease(cf);
  return v9;
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(uint64_t (*result)(uint64_t, uint64_t), uint64_t a2, uint64_t a3))(uint64_t, uint64_t)
{
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t))result(a2, a3);
  return result;
}

double __CFTimeIntervalUntilTSR(unint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v5;

  if (CFDateGetTypeID_initOnce != -1)
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
  v2 = mach_absolute_time();
  v3 = v2 - a1;
  if (v2 <= a1)
  {
    v5 = a1 - v2;
    if (CFDateGetTypeID_initOnce != -1)
      dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
    return *(double *)&__CF1_TSRRate * (double)v5;
  }
  else
  {
    if (CFDateGetTypeID_initOnce != -1)
      dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
    return -(*(double *)&__CF1_TSRRate * (double)v3);
  }
}

uint64_t _runLoopTimerWithBlockContext(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t _CFPrefsMessageSenderIsSandboxed(void *a1)
{
  _xpc_connection_s *remote_connection;
  _xpc_connection_s *value;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  remote_connection = xpc_dictionary_get_remote_connection(a1);
  if (!remote_connection)
  {
    value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
    if (!value
      || (remote_connection = value, value = object_getClass(value), value != (_xpc_connection_s *)MEMORY[0x1E0C812E0]))
    {
      _CFPrefsMessageSenderIsSandboxed_cold_1((uint64_t)value, v4, v5);
    }
  }
  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v12 = 1;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___CFPrefsMessageSenderIsSandboxed_block_invoke;
  v8[3] = &unk_1E1336848;
  v8[4] = a1;
  v8[5] = &v9;
  withClientContext(remote_connection, (uint64_t)v8);
  v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_182B3B9E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const __CFString *_CFPrefsCopyUsernameForMobileUser()
{
  if (!eduModeEnabled())
    return CFSTR("mobile");
  if (_CFPrefsCopyUsernameForMobileUser_onceToken != -1)
    dispatch_once(&_CFPrefsCopyUsernameForMobileUser_onceToken, &__block_literal_global_30);
  return (const __CFString *)CFRetain((CFTypeRef)_CFPrefsCopyUsernameForMobileUser_mobileUserName);
}

void sub_182B3C33C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 208), 8);
  _Unwind_Resume(a1);
}

BOOL withClientContext(_xpc_connection_s *a1, uint64_t a2)
{
  os_unfair_lock_s *context;
  os_unfair_lock_s *v5;
  os_unfair_lock_s *v6;
  int v7;

  os_unfair_lock_lock((os_unfair_lock_t)&_globalContextLock);
  context = (os_unfair_lock_s *)xpc_connection_get_context(a1);
  if (!context)
    withClientContext_cold_1();
  v5 = context;
  v6 = context + 12;
  os_unfair_lock_lock(context + 12);
  v7 = BYTE1(v5[14]._os_unfair_lock_opaque);
  os_unfair_lock_unlock((os_unfair_lock_t)&_globalContextLock);
  if (v7)
    (*(void (**)(uint64_t, os_unfair_lock_s *))(a2 + 16))(a2, v5);
  os_unfair_lock_unlock(v6);
  return v7 != 0;
}

uint64_t _CFPrefsSandboxCheckForMessage(void *a1)
{
  __int128 *data;
  __int128 v3;
  void *value;
  uint64_t v5;
  uint64_t v6;
  size_t length;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  length = 0;
  v9 = 0u;
  v10 = 0u;
  data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
  if (data && length == 32)
  {
    v3 = data[1];
    v9 = *data;
    v10 = v3;
  }
  else
  {
    if (!xpc_dictionary_get_remote_connection(a1))
    {
      value = xpc_dictionary_get_value(a1, "connection");
      if (!value || (value = object_getClass(value), value != (void *)MEMORY[0x1E0C812E0]))
        _CFPrefsSandboxCheckForMessage_cold_1((uint64_t)value, v5, v6);
    }
    xpc_connection_get_audit_token();
  }
  return sandbox_check_by_audit_token();
}

uint64_t _CFPrefsGetFixedUpDomainForMessage(void *a1, const void *a2, char a3, const char **a4)
{
  const char *string;
  const char *v9;
  CFStringRef v10;
  const __CFString *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  string = xpc_dictionary_get_string(a1, "CFPreferencesDomain");
  if (!string)
    return 0;
  v9 = string;
  v10 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, string, 0x8000100u);
  if (v10)
  {
    v11 = v10;
    if (CFEqual(v10, CFSTR("kCFPreferencesAnyApplication"))
      || CFEqual(CFSTR("Apple Global Domain"), v11)
      || CFEqual(CFSTR(".GlobalPreferences"), v11))
    {
      CFRelease(v11);
      v9 = "kCFPreferencesAnyApplication";
      xpc_dictionary_set_string(a1, "CFPreferencesDomain", "kCFPreferencesAnyApplication");
      v11 = CFSTR("kCFPreferencesAnyApplication");
    }
    if ((CFStringFind(v11, CFSTR(".."), 0).location != -1 || CFStringGetCharacterAtIndex(v11, 0) == 47)
      && !xpc_dictionary_get_BOOL(a1, "CFPreferencesShouldWriteSynchronously"))
    {
      if (_CFPrefsIsAppleInternal_onceToken != -1)
        dispatch_once(&_CFPrefsIsAppleInternal_onceToken, &__block_literal_global_163);
      if (_CFPrefsIsAppleInternal_internal == 1)
      {
        v12 = _CFPrefsDaemonLog();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          _CFPrefsGetFixedUpDomainForMessage_cold_1((uint64_t)v9, v12, v13, v14, v15, v16, v17, v18);
      }
    }
    if (CFEqual(v11, CFSTR("kCFPreferencesCurrentApplication"))
      || a2 && CFEqual(a2, CFSTR("kCFPreferencesAnyUser")) && (a3 & 1) == 0)
    {
      CFRelease(v11);
      v9 = 0;
    }
    else if (v11)
    {
      v19 = _CFPrefsDInternString(v11);
      CFRelease(v11);
      if (!a4)
        return v19;
      goto LABEL_18;
    }
  }
  v19 = 0;
  if (a4)
LABEL_18:
    *a4 = v9;
  return v19;
}

void sub_182B3CD7C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

const void *_CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded(void *a1)
{
  const void *result;
  const void *v3;
  _xpc_connection_s *remote_connection;
  _xpc_connection_s *value;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[7];
  size_t length[2];

  length[1] = *MEMORY[0x1E0C80C00];
  xpc_dictionary_set_value(a1, "CFPreferencesAuditToken", 0);
  length[0] = 0;
  result = xpc_dictionary_get_data(a1, "CFPreferencesAuditTokenToImpersonate", length);
  if (result && length[0] == 32)
  {
    v3 = result;
    remote_connection = xpc_dictionary_get_remote_connection(a1);
    if (!remote_connection)
    {
      value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
      if (!value
        || (remote_connection = value, value = object_getClass(value), value != (_xpc_connection_s *)MEMORY[0x1E0C812E0]))
      {
        _CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded_cold_1((uint64_t)value, v6, v7);
      }
    }
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ___CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded_block_invoke;
    v8[3] = &unk_1E13369A0;
    v8[4] = a1;
    v8[5] = v3;
    v8[6] = length[0];
    return (const void *)withClientContext(remote_connection, (uint64_t)v8);
  }
  return result;
}

CFStringRef _CFPrefsCopyFixedUpUserForMessage(void *a1, BOOL *a2, _BYTE *a3)
{
  _xpc_connection_s *remote_connection;
  _xpc_connection_s *value;
  uint64_t v8;
  uint64_t v9;
  const char *string;
  const char *v11;
  const __CFString *v12;
  uid_t euid;
  char isRootOrRoleAccountUserName;
  CFStringRef Copy;

  remote_connection = xpc_dictionary_get_remote_connection(a1);
  if (!remote_connection)
  {
    value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
    if (!value
      || (remote_connection = value, value = object_getClass(value), value != (_xpc_connection_s *)MEMORY[0x1E0C812E0]))
    {
      _CFPrefsCopyFixedUpUserForMessage_cold_1((uint64_t)value, v8, v9);
    }
  }
  string = xpc_dictionary_get_string(a1, "CFPreferencesUser");
  v11 = string;
  if (string)
  {
    if (strcmp(string, "mobile") || (string = (const char *)_CFPrefsCopyUsernameForMobileUser()) == 0)
      string = (const char *)CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v11, 0x8000100u);
  }
  if (string)
    v12 = (const __CFString *)string;
  else
    v12 = CFSTR("kCFPreferencesAnyUser");
  if (CFEqual(v12, CFSTR("kCFPreferencesCurrentUser")))
  {
    CFRelease(v12);
    euid = xpc_connection_get_euid(remote_connection);
    v12 = _CFPrefsCopyUserNameForUID(euid);
    isRootOrRoleAccountUserName = euid < 0x1F5;
  }
  else
  {
    isRootOrRoleAccountUserName = _isRootOrRoleAccountUserName(v12);
  }
  *a3 = isRootOrRoleAccountUserName;
  if (v12)
  {
    Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
    CFRelease(v12);
  }
  else
  {
    Copy = 0;
  }
  *a2 = v11 != 0;
  return Copy;
}

void CFBagAddValue(CFMutableBagRef theBag, const void *value)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v10;

  v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0)
    CFLog(3, (uint64_t)CFSTR("%s(): immutable collection %p given to mutating function"), v2, v3, v4, v5, v6, v7, (__int16)"void CFBagAddValue(CFMutableBagRef, const void *)");
  CFBasicHashAddValue((uint64_t)theBag, (unint64_t)value, (uint64_t)value);
}

uint64_t _CFPrefsDaemonLog()
{
  if (makeLogHandles_logToken != -1)
    dispatch_once(&makeLogHandles_logToken, &__block_literal_global_143);
  return daemonHandle;
}

uint64_t _CFPrefsDecodeKeyValuePairFromXPCMessage(void *a1, _QWORD *a2, _QWORD *a3, int *a4)
{
  uint64_t result;
  void *v9;
  xpc_object_t v10;
  int v11;

  if (xpc_dictionary_get_BOOL(a1, "MultiKeySet"))
  {
    result = (uint64_t)xpc_dictionary_get_value(a1, "Value");
    if (!result)
      return result;
    v9 = (void *)result;
    v10 = xpc_string_create("MultipleKeys");
    v11 = 1;
    if (a2)
      goto LABEL_4;
LABEL_12:
    xpc_release(v10);
    if (!a3)
      goto LABEL_6;
    goto LABEL_5;
  }
  result = (uint64_t)xpc_dictionary_get_value(a1, "Key");
  if (!result)
    return result;
  v10 = (xpc_object_t)result;
  xpc_retain((xpc_object_t)result);
  result = (uint64_t)xpc_dictionary_get_value(a1, "Value");
  if (!result)
    return result;
  v9 = (void *)result;
  v11 = 0;
  if (!a2)
    goto LABEL_12;
LABEL_4:
  *a2 = v10;
  if (a3)
  {
LABEL_5:
    xpc_retain(v9);
    *a3 = v9;
  }
LABEL_6:
  if (a4)
    *a4 = v11;
  return 1;
}

void sub_182B3EEF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182B3F014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182B3F29C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

BOOL eduModeEnabled()
{
  BOOL v1;
  uint32_t multiuser_mode;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if (eduModeOverride)
    return 1;
  multiuser_mode = 0;
  if (host_check_multiuser_mode(0, &multiuser_mode))
    v1 = 1;
  else
    v1 = multiuser_mode == 0;
  return !v1;
}

CFStringRef _CFPrefsCopyFixedUpContainerForMessage(void *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  const char *string;
  const __CFArray *value;
  CFDataRef v11;
  _BOOL4 v12;
  BOOL v13;
  _xpc_connection_s *remote_connection;
  _xpc_connection_s *v15;
  int v16;
  CFStringRef v17;
  __int128 *data;
  __int128 v19;
  void *Class;
  uint64_t v21;
  uint64_t v22;
  int v24;
  int v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char buffer[1026];
  __int128 v35;
  __int128 v36;
  void *v37;
  __int128 *p_length;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  CFDataRef v42;
  BOOL v43;
  __int128 length;
  __int128 v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  string = xpc_dictionary_get_string(a1, "CFPreferencesContainer");
  bzero(buffer, 0x402uLL);
  value = (const __CFArray *)xpc_dictionary_get_value(a1, "CFPreferencesHostBundleIdentifier");
  v11 = _CFXPCCreateCFObjectFromXPCObject(value);
  v12 = xpc_dictionary_get_BOOL(a1, "CFPreferencesCurrentApplicationDomain");
  if (!a2)
    _CFPrefsCopyFixedUpContainerForMessage_cold_1();
  v13 = v12;
  if (!v12)
  {
    *(_QWORD *)&length = 0;
    *((_QWORD *)&length + 1) = &length;
    *(_QWORD *)&v45 = 0x2020000000;
    BYTE8(v45) = 0;
    remote_connection = xpc_dictionary_get_remote_connection(a1);
    if (!remote_connection)
    {
      v15 = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
      remote_connection = v15;
      if (!v15 || object_getClass(v15) != (Class)MEMORY[0x1E0C812E0])
        __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
    }
    *(_QWORD *)&v35 = MEMORY[0x1E0C809B0];
    *((_QWORD *)&v35 + 1) = 3221225472;
    *(_QWORD *)&v36 = ___CFPrefsGetSuiteContainer_block_invoke;
    *((_QWORD *)&v36 + 1) = &unk_1E1336D10;
    v39 = a2;
    v40 = buffer;
    v37 = a1;
    p_length = &length;
    v43 = v13;
    v41 = 1026;
    v42 = v11;
    withClientContext(remote_connection, (uint64_t)&v35);
    v16 = *(unsigned __int8 *)(*((_QWORD *)&length + 1) + 24);
    _Block_object_dispose(&length, 8);
    if (v16)
      string = buffer;
  }
  if (v11)
    CFRelease(v11);
  if (!string || !*string)
  {
    v17 = 0;
    if (!a4 || !a5)
      return v17;
    *(_QWORD *)&length = 0;
    v35 = 0u;
    v36 = 0u;
    data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", (size_t *)&length);
    if (data && (_QWORD)length == 32)
    {
      v19 = data[1];
      v35 = *data;
      v36 = v19;
    }
    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        Class = xpc_dictionary_get_value(a1, "connection");
        if (!Class || (Class = object_getClass(Class), Class != (void *)MEMORY[0x1E0C812E0]))
          _CFPrefsCopyFixedUpContainerForMessage_cold_2((uint64_t)Class, v21, v22);
      }
      xpc_connection_get_audit_token();
    }
    length = v35;
    v45 = v36;
    v17 = 0;
    if (sandbox_container_path_for_audit_token() || !buffer[0])
      return v17;
    if (_CFPrefsSandboxCheckForMessage_0(a1) && _CFPrefsSandboxCheckForMessage_0(a1))
      return CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer);
    return 0;
  }
  if (!strncmp(string, "kCFPreferencesNoContainer", 0x19uLL))
    return 0;
  getpid();
  if (sandbox_check())
    return CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, string);
  v24 = open(string, 1074790400, string);
  v25 = v24;
  if (v24 < 0)
  {
    v26 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      _CFPrefsCopyFixedUpContainerForMessage_cold_3((uint64_t)string, v26, v27, v28, v29, v30, v31, v32);
    return CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, string);
  }
  if (fcntl(v24, 50, buffer) == -1)
    v17 = 0;
  else
    v17 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer);
  close(v25);
  return v17;
}

void sub_182B3FA2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_182B3FC94(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

xpc_object_t _CFPrefsGetEntitlementForMessageWithLockedContext(void *a1, char *key, uint64_t a3)
{
  xpc_object_t v5;
  __int128 *data;
  __int128 v9;
  void *value;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  const __CFArray *array;
  const __CFArray *v16;
  uint64_t v17;
  int v18;
  const char *v19;
  size_t v20;
  _BOOL4 v21;
  char v22;
  xpc_object_t v23;
  void *v24;
  size_t length;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
    _CFPrefsGetEntitlementForMessageWithLockedContext_cold_1();
  v5 = *(xpc_object_t *)(a3 + 32);
  if (v5)
  {
    if (key)
      return xpc_dictionary_get_value(v5, key);
  }
  else
  {
    length = 0;
    v26 = 0u;
    v27 = 0u;
    data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
    if (data && length == 32)
    {
      v9 = data[1];
      v26 = *data;
      v27 = v9;
    }
    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        value = xpc_dictionary_get_value(a1, "connection");
        if (!value || (value = object_getClass(value), value != (void *)MEMORY[0x1E0C812E0]))
          _CFPrefsGetEntitlementForMessageWithLockedContext_cold_3((uint64_t)value, v11, v12);
      }
      xpc_connection_get_audit_token();
    }
    v13 = (void *)xpc_copy_entitlement_for_token();
    if (!v13)
      goto LABEL_27;
    v14 = v13;
    array = (const __CFArray *)xpc_dictionary_get_array(v13, "com.apple.security.application-groups");
    if (array)
    {
      v16 = array;
      if (xpc_array_get_count(array))
        *(_QWORD *)(a3 + 40) = _CFXPCCreateCFObjectFromXPCObject(v16);
    }
    v17 = 0;
    v18 = 0;
    v5 = 0;
    do
    {
      v19 = entitlementsWeCareAbout[v17];
      if (key)
      {
        v20 = strlen(entitlementsWeCareAbout[v17]);
        v21 = strncmp(v19, key, v20) == 0;
        v22 = v21 | v18;
        v18 |= v21;
      }
      else
      {
        v22 = 1;
      }
      v23 = xpc_dictionary_get_value(v14, v19);
      if (v23)
      {
        v24 = v23;
        if (!v5)
          v5 = xpc_dictionary_create(0, 0, 0);
        xpc_dictionary_set_value(v5, v19, v24);
      }
      ++v17;
    }
    while (v17 != 6);
    if ((v22 & 1) == 0)
      _CFPrefsGetEntitlementForMessageWithLockedContext_cold_2();
    xpc_release(v14);
    if (!v5)
    {
LABEL_27:
      if (_CFPrefsGetEntitlementForMessageWithLockedContext_onceToken != -1)
        dispatch_once(&_CFPrefsGetEntitlementForMessageWithLockedContext_onceToken, &__block_literal_global_162);
      v5 = xpc_retain((xpc_object_t)_CFPrefsGetEntitlementForMessageWithLockedContext_emptyEntitlements);
    }
    *(_QWORD *)(a3 + 32) = v5;
    if (key)
      return xpc_dictionary_get_value(v5, key);
  }
  return 0;
}

uint64_t _isRootOrRoleAccountUserName(const __CFString *a1)
{
  _BOOL8 v2;
  const char *CStringPtr;
  passwd *v4;
  BOOL v5;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  uint64_t v8;
  size_t v9;
  char *v10;
  int CString;
  passwd *v12;
  BOOL v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (CFEqual(a1, CFSTR("root")))
    return 1;
  if (!CFStringGetLength(a1) || CFStringGetCharacterAtIndex(a1, 0) != 95)
    return 0;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2020000000;
  v19 = 0;
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    v4 = getpwnam(CStringPtr);
    if (v4)
      v5 = v4->pw_uid < 0x1F5;
    else
      v5 = 0;
    *((_BYTE *)v17 + 24) = v5;
  }
  else
  {
    Length = CFStringGetLength(a1);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    v9 = MaximumSizeForEncoding + 1;
    if ((unint64_t)(MaximumSizeForEncoding + 1) < 0x101)
    {
      if (MaximumSizeForEncoding == -1)
      {
        v10 = 0;
      }
      else
      {
        MEMORY[0x1E0C80A78](MaximumSizeForEncoding, v8);
        v10 = (char *)&v15 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
        bzero(v10, v9);
      }
    }
    else
    {
      v10 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0x100004077774924uLL);
    }
    bzero(v10, v9);
    CString = CFStringGetCString(a1, v10, v9, 0x8000100u);
    if (v10 && CString)
    {
      v12 = getpwnam(v10);
      if (v12)
        v13 = v12->pw_uid < 0x1F5;
      else
        v13 = 0;
      *((_BYTE *)v17 + 24) = v13;
    }
    if (v9 >= 0x101)
      free(v10);
  }
  v2 = *((_BYTE *)v17 + 24) != 0;
  _Block_object_dispose(&v16, 8);
  return v2;
}

void sub_182B400F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 72), 8);
  _Unwind_Resume(a1);
}

void sub_182B402C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v10;
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v10 - 88), 8);
  _Unwind_Resume(a1);
}

void DEBUG_READ(void *a1, void *a2, uint64_t a3)
{
  NSObject *v6;
  _QWORD v7[6];

  v7[5] = *MEMORY[0x1E0C80C00];
  v6 = _CFPrefsDaemonLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = __DEBUG_READ_block_invoke;
    v7[3] = &__block_descriptor_40_e29_v64__0i8_12_20_28_36_44_52B60l;
    v7[4] = a3;
    _extractCFPDBits(a1, 0, a2, (uint64_t)v7);
  }
}

uint64_t checkFileWriteData(_OWORD *a1, uint64_t a2, int a3, const char *a4, unsigned int a5)
{
  __int128 v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  stat v14;
  _OWORD v15[64];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v8 = a1[1];
  v15[0] = *a1;
  v15[1] = v8;
  v9 = sandbox_check_by_audit_token();
  if ((_DWORD)v9)
  {
    v10 = openat(a3, a4, 536871426, a5);
    if ((v10 & 0x80000000) == 0)
    {
      v11 = v10;
      bzero(v15, 0x400uLL);
      fcntl(v11, 50, v15);
      v9 = sandbox_check_by_audit_token();
      memset(&v14, 0, sizeof(v14));
      v12 = fstat(v11, &v14);
      close(v11);
      if (!v12 && !v14.st_size)
        unlinkat(a3, a4, 2048);
    }
  }
  return v9;
}

uint64_t __notifyFunc_block_invoke(uint64_t result, uint64_t a2)
{
  _BYTE *v2;

  v2 = (_BYTE *)(a2 + 55);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_BYTE *)(a2 + 55);
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24))
    v2 = (_BYTE *)(a2 + 56);
  *v2 = 1;
  return result;
}

uint64_t __notifyFunc_block_invoke_3(uint64_t result, uint64_t a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_BYTE *)(a2 + 56);
  *(_BYTE *)(a2 + 56) = 0;
  *(_BYTE *)(a2 + 55) = 0;
  return result;
}

CFURLRef _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser(const __CFString *a1, const void *a2)
{
  const char *CStringPtr;
  CFStringEncoding FastestEncoding;
  int current_persona;
  xpc_object_t v7;
  void *v8;
  NSObject *v9;
  const __CFArray *v10;
  const __CFDictionary *v11;
  const __CFString *Value;
  CFURLRef v13;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  xpc_object_t v18;
  char buffer[1024];
  int v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  if (a1)
  {
    CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
    if (!CStringPtr)
    {
      FastestEncoding = CFStringGetFastestEncoding(a1);
      CStringPtr = buffer;
      if (!CFStringGetCString(a1, buffer, 1024, FastestEncoding))
        CStringPtr = 0;
    }
  }
  else
  {
    CStringPtr = 0;
  }
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v18 = xpc_dictionary_create(0, 0, 0);
  current_persona = voucher_get_current_persona();
  v42 = 0;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v37 = 0u;
  v36 = 0u;
  v35 = 0u;
  v34 = 0u;
  v33 = 0u;
  v32 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 2;
  if (current_persona != -1)
    kpersona_info();
  container_query_create();
  container_query_set_class();
  if (CStringPtr)
  {
    v7 = xpc_string_create(CStringPtr);
    container_query_set_identifiers();
    xpc_release(v7);
  }
  container_query_set_persona_unique_string();
  container_query_operation_set_flags();
  container_query_set_uid();
  if ((container_query_iterate_results_sync() & 1) == 0)
  {
    container_query_get_last_error();
    v8 = (void *)container_error_copy_unlocalized_description();
    v9 = _CFOSLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser_cold_1((uint64_t)CStringPtr, (uint64_t)v8, v9);
    free(v8);
    xpc_release((xpc_object_t)v16[3]);
    v16[3] = 0;
  }
  container_query_free();
  v10 = (const __CFArray *)v16[3];
  _Block_object_dispose(&v15, 8);
  if (!v10)
    return 0;
  v11 = _CFXPCCreateCFObjectFromXPCObject(v10);
  xpc_release(v10);
  if (!v11)
    return 0;
  Value = (const __CFString *)CFDictionaryGetValue(v11, a2);
  if (Value)
    v13 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, Value, kCFURLPOSIXPathStyle, 1u);
  else
    v13 = 0;
  CFRelease(v11);
  return v13;
}

void sub_182B416C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFStringRef _CFURLCopyHostName(uint64_t a1, int a2)
{
  const __CFString *v4;
  char v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFAllocator *v9;
  CFStringRef v10;
  CFRange v11;

  while (1)
  {
    if (!a1)
      _CFURLCopyHostName_cold_1();
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1))
    {
      v7 = (const __CFString *)objc_msgSend((id)a1, "host");
      v6 = v7;
      if (v7)
        CFRetain(v7);
      return v6;
    }
    v4 = _retainedComponentString(a1, 8, 1, a2);
    if (v4)
      break;
    if (*(_QWORD *)(a1 + 32))
    {
      v5 = *(_BYTE *)(a1 + 16);
      a1 = *(_QWORD *)(a1 + 32);
      if ((v5 & 0x1F) == 0)
        continue;
    }
    return 0;
  }
  v6 = v4;
  if ((*(_BYTE *)(a1 + 17) & 4) == 0)
    return v6;
  v9 = CFGetAllocator((CFTypeRef)a1);
  v11.length = CFStringGetLength(v6) - 2;
  v11.location = 1;
  v10 = CFStringCreateWithSubstring(v9, v6, v11);
  CFRelease(v6);
  return v10;
}

Boolean CFRunLoopTimerDoesRepeat(CFRunLoopTimerRef timer)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)timer);
  if (v2 != 47)
    _CFAssertMismatchedTypeID(0x2FuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  return *((double *)timer + 14) > 0.0;
}

void _legacyStreamRunLoop_workThread(dispatch_semaphore_t *a1)
{
  __CFString *v2;
  __CFRunLoopSource *v3;
  CFRunLoopSourceContext context;

  pthread_setname_np("com.apple.CFStream.LegacyThread");
  sLegacyRL = (uint64_t)CFRunLoopGetCurrent();
  v2 = (__CFString *)CFStringCreateWithFormat(0, 0, CFSTR("<< CFStreamLegacySource for Runloop %p >>"), sLegacyRL);
  context.version = 0;
  context.info = v2;
  context.retain = CFRetain;
  context.release = CFRelease;
  context.copyDescription = CFCopyDescription;
  context.equal = CFEqual;
  context.hash = CFHash;
  context.schedule = 0;
  context.cancel = 0;
  context.perform = (void (__cdecl *)(void *))_perform;
  v3 = CFRunLoopSourceCreate(0, 0, &context);
  CFRelease(v2);
  CFRunLoopAddSource((CFRunLoopRef)sLegacyRL, v3, CFSTR("kCFRunLoopDefaultMode"));
  CFRelease(v3);
  dispatch_semaphore_signal(*a1);
  while (1)
    CFRunLoopRunInMode(CFSTR("kCFRunLoopDefaultMode"), 1.0e30, 1u);
}

void __CFSocketManager(uint64_t a1, uint64_t a2)
{
  void *Typed;
  char *v3;
  CFIndex v4;
  int v5;
  int v6;
  unint64_t v7;
  const __CFData *v8;
  const __CFData *v9;
  const __CFArray *v10;
  int Count;
  CFIndex v12;
  UInt8 *MutableBytePtr;
  uint64_t v14;
  unsigned int *ValueAtIndex;
  unint64_t v16;
  int v17;
  int v18;
  CFIndex v19;
  UInt8 *v20;
  CFIndex v21;
  uint64_t v22;
  int *v23;
  unint64_t v24;
  int *v25;
  __CFArray *v26;
  CFIndex v27;
  CFIndex v28;
  CFIndex i;
  int *v30;
  CFIndex v31;
  CFIndex v32;
  CFIndex j;
  int *v34;
  CFIndex v35;
  uint64_t v36;
  CFIndex k;
  __CFSocket *v38;
  int v39;
  CFIndex v40;
  UInt8 *v41;
  _BYTE *v42;
  _BYTE *v43;
  unint64_t v44;
  _BOOL4 v46;
  __darwin_time_t v47;
  BOOL v48;
  const __CFArray *v49;
  CFIndex v50;
  __objc2_class **v51;
  __objc2_class **v52;
  unint64_t *v53;
  unint64_t v54;
  char v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  int v59;
  __objc2_class *v60;
  const __CFArray *MutableCopy;
  __objc2_class *v62;
  char v63;
  char *v64;
  CFIndex v65;
  __objc2_class **v66;
  __objc2_class **v67;
  _BOOL4 v68;
  unint64_t *v69;
  char v70;
  int v71;
  sockaddr *v72;
  sockaddr *v73;
  size_t v74;
  char v75;
  int v76;
  int v77;
  int v78;
  const __CFAllocator *v79;
  CFIndex v80;
  sockaddr *v81;
  int v82;
  const __CFAllocator *v83;
  CFIndex v84;
  const UInt8 *p_sa_len;
  pthread_mutex_t *v86;
  char v87;
  int64_t v88;
  __CFData *v89;
  unint64_t v90;
  UInt8 *v91;
  CFDataRef v92;
  pthread_mutex_t *v93;
  char v94;
  CFDataRef v95;
  unint64_t v96;
  unint64_t v97;
  int v98;
  const __CFAllocator *v99;
  const __CFData *v100;
  CFDataRef v101;
  CFDataRef v102;
  const __CFAllocator *v103;
  __CFArray *v104;
  const __CFAllocator *v105;
  const __CFAllocator *v106;
  int v107;
  int64_t v108;
  __CFData *v109;
  unint64_t v110;
  UInt8 *v111;
  CFDataRef v112;
  char v113;
  pthread_mutex_t *v114;
  unint64_t v115;
  unint64_t v116;
  int v117;
  __CFArray *v118;
  const __CFAllocator *v119;
  const __CFAllocator *v120;
  int64_t v121;
  __CFData *v122;
  unint64_t v123;
  UInt8 *v124;
  __objc2_class *v125;
  unint64_t v126;
  unint64_t v127;
  int v128;
  char v129;
  unint64_t v130;
  unint64_t v131;
  int v132;
  sockaddr *v133;
  int v134;
  const __CFAllocator *v135;
  unint64_t v136;
  unint64_t v137;
  __objc2_class *v138;
  const __CFArray *v139;
  __objc2_class *v140;
  char v141;
  char *v142;
  int64_t v143;
  UInt8 *v144;
  CFSocketNativeHandle Native;
  ssize_t v146;
  unint64_t v147;
  unint64_t v148;
  int v149;
  sockaddr *v150;
  __objc2_class *v151;
  ssize_t v152;
  char *v153;
  int v154;
  int64_t v155;
  __CFData *v156;
  unint64_t v157;
  UInt8 *v158;
  unint64_t v159;
  unint64_t v160;
  uint64_t v161;
  void *v162;
  char *v163;
  __CFArray *theArray;
  __int128 *v165;
  int v166;
  __CFArray *Mutable;
  uint64_t idx;
  timeval v169;
  timeval v170;
  __int128 v171;
  char v172[256];
  socklen_t v173;
  sockaddr v174;
  sockaddr context[2048];
  int v176;
  sockaddr v177[17];
  CFRange v178;
  CFRange v179;
  CFRange v180;

  MEMORY[0x1E0C80A78](a1, a2);
  pthread_setname_np("com.apple.CFSocket.private");
  Typed = (void *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 4, 0x100004052888210, 0);
  v3 = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 4, 0x100004052888210, 0);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  theArray = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  v165 = 0;
  v4 = 0;
  v171 = 0uLL;
  v170.tv_sec = 0;
  *(_QWORD *)&v170.tv_usec = 0;
  v161 = 1;
  while (1)
  {
LABEL_2:
    os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
    ++__CFSocketManagerIteration;
    v5 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
    v6 = 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds);
    if (v5 <= v6)
      v5 = v6;
    v7 = v161;
    if (v5 > 32 * (int)v161)
    {
      v7 = (unint64_t)(v5 + 31) >> 5;
      Typed = (void *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, Typed, 4 * (int)v7, 0x100004052888210, 0, 0);
      v3 = (char *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, v3, 4 * (int)v7, 0x100004052888210, 0, 0);
    }
    v161 = v7;
    bzero(Typed, 4 * (int)v7);
    bzero(v3, 4 * (int)v7);
    v8 = (const __CFData *)__CFWriteSocketsFds;
    v178.length = CFDataGetLength((CFDataRef)__CFWriteSocketsFds);
    v178.location = 0;
    CFDataGetBytes(v8, v178, (UInt8 *)Typed);
    v9 = (const __CFData *)__CFReadSocketsFds;
    v179.length = CFDataGetLength((CFDataRef)__CFReadSocketsFds);
    v179.location = 0;
    CFDataGetBytes(v9, v179, (UInt8 *)v3);
    if ((__CFReadSocketsTimeoutInvalid & 1) == 0)
    {
      *(_QWORD *)&context[0].sa_len = 0;
      __CFReadSocketsTimeoutInvalid = 1;
      v10 = (const __CFArray *)__CFReadSockets;
      v180.length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
      v180.location = 0;
      CFArrayApplyFunction(v10, v180, (CFArrayApplierFunction)_calcMinTimeout_locked, context);
      if (*(_QWORD *)&context[0].sa_len)
      {
        v171 = *(_OWORD *)*(_QWORD *)&context[0].sa_len;
        v165 = &v171;
      }
      else
      {
        v165 = 0;
      }
    }
    if (v165)
      gettimeofday(&v170, 0);
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
    v166 = select_DARWIN_EXTSN();
    if (!v166)
    {
      *(_QWORD *)&context[0].sa_data[6] = 0;
      *(_QWORD *)&context[0].sa_len = 0;
      gettimeofday((timeval *)context, 0);
      os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
      Count = CFArrayGetCount((CFArrayRef)__CFReadSockets);
      if (Count >= 1)
      {
        v12 = 0;
        MutableBytePtr = 0;
        v14 = Count;
        do
        {
          ValueAtIndex = (unsigned int *)CFArrayGetValueAtIndex((CFArrayRef)__CFReadSockets, v12);
          if (*((_QWORD *)ValueAtIndex + 34) || ValueAtIndex[70] || *((_QWORD *)ValueAtIndex + 41))
          {
            v16 = ValueAtIndex[38];
            if ((v16 & 0x80000000) == 0 && (int)v16 < v5)
            {
              CFArraySetValueAtIndex(theArray, v4, ValueAtIndex);
              if (!MutableBytePtr)
                MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)__CFReadSocketsFds);
              ++v4;
              if (__darwin_check_fd_set_overflow(v16, MutableBytePtr, 1))
                *(_DWORD *)&MutableBytePtr[(v16 >> 3) & 0x1FFFFFFC] &= ~(1 << v16);
            }
          }
          ++v12;
        }
        while (v14 != v12);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
    }
    if ((v166 & 0x80000000) == 0)
      break;
    if (*__error() == 9)
    {
      v26 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
      os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
      v27 = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
      if (v27 >= 1)
      {
        v28 = v27;
        for (i = 0; i != v28; ++i)
        {
          v30 = (int *)CFArrayGetValueAtIndex((CFArrayRef)__CFWriteSockets, i);
          if (!__CFNativeSocketIsValid(v30[38]))
            CFArrayAppendValue(v26, v30);
        }
      }
      v31 = CFArrayGetCount((CFArrayRef)__CFReadSockets);
      if (v31 >= 1)
      {
        v32 = v31;
        for (j = 0; j != v32; ++j)
        {
          v34 = (int *)CFArrayGetValueAtIndex((CFArrayRef)__CFReadSockets, j);
          if (!__CFNativeSocketIsValid(v34[38]))
            CFArrayAppendValue(v26, v34);
        }
      }
      v35 = CFArrayGetCount(v26);
      if (v35)
      {
        v36 = v35;
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
        if (v36 >= 1)
        {
          for (k = 0; k != v36; ++k)
          {
            v38 = (__CFSocket *)CFArrayGetValueAtIndex(v26, k);
            CFSocketInvalidate(v38);
          }
        }
      }
      else
      {
        clearInvalidFileDescriptors((UInt8 *)__CFReadSocketsFds);
        clearInvalidFileDescriptors((UInt8 *)__CFWriteSocketsFds);
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
      }
      CFRelease(v26);
    }
  }
  v17 = HIDWORD(__CFWakeupSocketPair);
  if (__darwin_check_fd_set_overflow(SHIDWORD(__CFWakeupSocketPair), v3, 1)
    && ((*(_DWORD *)&v3[((unint64_t)v17 >> 3) & 0x1FFFFFFFFFFFFFFCLL] >> v17) & 1) != 0)
  {
    recv(SHIDWORD(__CFWakeupSocketPair), v172, 0x100uLL, 0);
  }
  idx = v4;
  v162 = Typed;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
  v18 = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
  v163 = v3;
  if (v18 < 1)
  {
    v21 = 0;
  }
  else
  {
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = v18;
    do
    {
      v23 = (int *)CFArrayGetValueAtIndex((CFArrayRef)__CFWriteSockets, v19);
      v24 = v23[38];
      if ((v24 & 0x80000000) == 0 && (int)v24 < v5)
      {
        v25 = v23;
        if (__darwin_check_fd_set_overflow(v23[38], v162, 1) && (*((_DWORD *)v162 + (v24 >> 5)) & (1 << v24)) != 0)
        {
          CFArraySetValueAtIndex(Mutable, v21, v25);
          if (!v20)
            v20 = CFDataGetMutableBytePtr((CFMutableDataRef)__CFWriteSocketsFds);
          ++v21;
          if (__darwin_check_fd_set_overflow(v24, v20, 1))
            *(_DWORD *)&v20[4 * (v24 >> 5)] &= ~(1 << v24);
        }
        v3 = v163;
      }
      ++v19;
    }
    while (v22 != v19);
  }
  v39 = CFArrayGetCount((CFArrayRef)__CFReadSockets);
  v169.tv_sec = 0;
  *(_QWORD *)&v169.tv_usec = 0;
  if (v165)
    gettimeofday(&v169, 0);
  if (v39 >= 1)
  {
    v40 = 0;
    v41 = 0;
    do
    {
      v42 = CFArrayGetValueAtIndex((CFArrayRef)__CFReadSockets, v40);
      v43 = v42;
      v44 = *((unsigned int *)v42 + 38);
      v46 = (v44 & 0x80000000) == 0 && (int)v44 < v5;
      v42[352] = 0;
      if (v166
        && v165
        && v46
        && (!__darwin_check_fd_set_overflow(v44, v3, 1) || ((*(_DWORD *)&v3[(v44 >> 3) & 0x1FFFFFFC] >> v44) & 1) == 0))
      {
        v47 = *((_QWORD *)v43 + 42);
        if (v47 || *((_DWORD *)v43 + 86))
        {
          v48 = v169.tv_sec <= v47;
          if (v169.tv_sec == v47)
            v48 = v169.tv_usec <= *((_DWORD *)v43 + 86);
          if (!v48)
            v43[352] = 1;
        }
      }
      if (v46
        && (__darwin_check_fd_set_overflow(v44, v3, 1) && ((*(_DWORD *)&v3[(v44 >> 3) & 0x1FFFFFFC] >> v44) & 1) != 0
         || v43[352]))
      {
        CFArraySetValueAtIndex(theArray, idx, v43);
        if (!v41)
          v41 = CFDataGetMutableBytePtr((CFMutableDataRef)__CFReadSocketsFds);
        ++idx;
        if (__darwin_check_fd_set_overflow(v44, v41, 1))
          *(_DWORD *)&v41[4 * (v44 >> 5)] &= ~(1 << v44);
      }
      ++v40;
    }
    while (v39 != v40);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  v49 = theArray;
  if (v21 < 1)
    goto LABEL_125;
  v50 = 0;
  while (1)
  {
    v51 = (__objc2_class **)CFArrayGetValueAtIndex(Mutable, v50);
    if (&__kCFNull == v51)
      goto LABEL_103;
    v52 = v51;
    *(_DWORD *)&context[0].sa_len = 0;
    *(_DWORD *)&v177[0].sa_len = 4;
    if (!CFSocketIsValid((CFSocketRef)v51))
      goto LABEL_102;
    if (((_BYTE)v52[2] & 0x40) != 0
      || getsockopt(*((_DWORD *)v52 + 38), 0xFFFF, 4103, context, (socklen_t *)&v177[0].sa_len))
    {
      *(_DWORD *)&context[0].sa_len = 0;
    }
    pthread_mutex_lock((pthread_mutex_t *)(v52 + 3));
    v53 = (unint64_t *)(v52 + 1);
    v54 = atomic_load((unint64_t *)v52 + 1);
    v55 = atomic_load((unint64_t *)v52 + 1);
    if ((v55 & 0x10) == 0)
      goto LABEL_101;
    v56 = 8;
    if (((_DWORD)v52[2] & 4) == 0)
      v56 = 12;
    if ((~(*((_DWORD *)v52 + 4) >> 8) & v56 & v54) == 0)
    {
LABEL_101:
      pthread_mutex_unlock((pthread_mutex_t *)(v52 + 3));
      goto LABEL_102;
    }
    *((_DWORD *)v52 + 40) = *(_DWORD *)&context[0].sa_len;
    v57 = atomic_load((unint64_t *)v52 + 1);
    do
    {
      v58 = __ldaxr(v53);
      if (v58 == v57)
      {
        if (!__stlxr(v57 | 0x40, v53))
        {
          v59 = 1;
          goto LABEL_111;
        }
      }
      else
      {
        __clrex();
      }
      v59 = 0;
LABEL_111:
      v57 = v58;
    }
    while (!v59);
    CFRunLoopSourceSignal((CFRunLoopSourceRef)v52[24]);
    v60 = (__objc2_class *)CFRetain(v52[25]);
    MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (CFArrayRef)v52[25]);
    v62 = v52[24];
    if (v62)
    {
      if (CFRunLoopSourceIsValid((CFRunLoopSourceRef)v52[24]))
      {
        CFRetain(v62);
        v63 = 0;
        goto LABEL_117;
      }
      v62 = 0;
    }
    v63 = 1;
LABEL_117:
    pthread_mutex_unlock((pthread_mutex_t *)(v52 + 3));
    v64 = __CFSocketCopyRunLoopToWakeUp((__CFRunLoopSource *)v62, MutableCopy);
    if ((v63 & 1) == 0)
      CFRelease(v62);
    if (v64)
    {
      CFRunLoopWakeUp((CFRunLoopRef)v64);
      CFRelease(v64);
    }
    pthread_mutex_lock((pthread_mutex_t *)(v52 + 3));
    v3 = v163;
    if (v60 == v52[25])
    {
      v52[25] = (__objc2_class *)MutableCopy;
      CFRelease(v60);
      MutableCopy = 0;
    }
    v49 = theArray;
    pthread_mutex_unlock((pthread_mutex_t *)(v52 + 3));
    CFRelease(v60);
    if (MutableCopy)
      CFRelease(MutableCopy);
LABEL_102:
    CFArraySetValueAtIndex(Mutable, v50, &__kCFNull);
LABEL_103:
    if (++v50 == v21)
    {
LABEL_125:
      if (idx < 1)
        goto LABEL_286;
      v65 = 0;
      while (1)
      {
        v66 = (__objc2_class **)CFArrayGetValueAtIndex(v49, v65);
        if (&__kCFNull == v66)
          goto LABEL_269;
        v67 = v66;
        if (v166)
          v68 = *((_BYTE *)v66 + 352) != 0;
        else
          v68 = 1;
        if (!CFSocketIsValid((CFSocketRef)v66))
          goto LABEL_268;
        v69 = (unint64_t *)(v67 + 1);
        v70 = atomic_load((unint64_t *)v67 + 1);
        if ((~v70 & 3) == 0)
        {
          v173 = 256;
          if (*((_DWORD *)v67 + 39) == 1)
          {
            v71 = *((_DWORD *)v67 + 38);
            v72 = context;
            v73 = context;
            v74 = 0x8000;
            goto LABEL_141;
          }
          v72 = (sockaddr *)malloc_type_malloc(0xFFFFuLL, 0x1B7BAAFAuLL);
          if (v72)
          {
            v71 = *((_DWORD *)v67 + 38);
            v73 = v72;
            v74 = 0xFFFFLL;
LABEL_141:
            v82 = recvfrom(v71, v73, v74, 0, &v174, &v173);
            if (v82 > 0)
            {
              v83 = CFGetAllocator(v67);
              v84 = v82;
              p_sa_len = &v72->sa_len;
LABEL_154:
              v92 = CFDataCreate(v83, p_sa_len, v84);
              if (v72 && v72 != context)
                free(v72);
              v93 = (pthread_mutex_t *)(v67 + 3);
              pthread_mutex_lock((pthread_mutex_t *)(v67 + 3));
              v94 = atomic_load((unint64_t *)v67 + 1);
              if ((v94 & 0x10) == 0)
              {
                v95 = v92;
                goto LABEL_187;
              }
              v96 = atomic_load(v69);
              while (2)
              {
                v97 = __ldaxr(v69);
                if (v97 == v96)
                {
                  if (!__stlxr(v96 | 0x20, v69))
                  {
                    v98 = 1;
                    goto LABEL_165;
                  }
                }
                else
                {
                  __clrex();
                }
                v98 = 0;
LABEL_165:
                v96 = v97;
                if (v98)
                {
                  if ((int)v173 >= 1)
                  {
                    v99 = CFGetAllocator(v67);
                    v100 = CFDataCreate(v99, &v174.sa_len, (int)v173);
                    goto LABEL_171;
                  }
                  if (*((_DWORD *)v67 + 39) == 1)
                  {
                    v101 = (CFDataRef)v67[22];
                    if (v101)
                    {
LABEL_170:
                      v100 = (const __CFData *)CFRetain(v101);
LABEL_171:
                      v102 = v100;
                      if (!v100)
                        goto LABEL_172;
LABEL_173:
                      v104 = (__CFArray *)v67[32];
                      if (!v104)
                      {
                        v105 = CFGetAllocator(v67);
                        v104 = CFArrayCreateMutable(v105, 0, &kCFTypeArrayCallBacks);
                        v67[32] = (__objc2_class *)v104;
                      }
                      if (!v67[33])
                      {
                        v106 = CFGetAllocator(v67);
                        v67[33] = (__objc2_class *)CFArrayCreateMutable(v106, 0, &kCFTypeArrayCallBacks);
                        v104 = (__CFArray *)v67[32];
                      }
                      CFArrayAppendValue(v104, v92);
                      CFRelease(v92);
                      CFArrayAppendValue((CFMutableArrayRef)v67[33], v102);
                      CFRelease(v102);
                      if (v82 >= 1)
                      {
                        v107 = *((_DWORD *)v67 + 4);
                        if ((v107 & 3) != 0 && (v107 & 0x300) == 0 && *((int *)v67 + 46) >= 1)
                        {
                          os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
                          __CFReadSocketsTimeoutInvalid = 0;
                          v108 = *((unsigned int *)v67 + 38);
                          if ((v108 & 0x80000000) == 0)
                          {
                            v109 = (__CFData *)__CFReadSocketsFds;
                            v110 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
                            if ((uint64_t)v110 <= v108)
                            {
                              v130 = v110 >> 5;
                              v131 = 4 * (((unint64_t)(v108 + 32) >> 5) - (v110 >> 5));
                              CFDataIncreaseLength(v109, v131);
                              v111 = CFDataGetMutableBytePtr(v109);
                              bzero(&v111[4 * v130], v131);
                            }
                            else
                            {
                              v111 = CFDataGetMutableBytePtr(v109);
                            }
                            if (!__darwin_check_fd_set_overflow(v108, v111, 1)
                              || ((*(_DWORD *)&v111[((unint64_t)v108 >> 3) & 0x1FFFFFFC] >> v108) & 1) == 0)
                            {
                              if (__darwin_check_fd_set_overflow(v108, v111, 1))
                                *(_DWORD *)&v111[4 * (v108 >> 5)] |= 1 << v108;
                              v132 = __CFWakeupSocketPair;
                              if ((_DWORD)__CFWakeupSocketPair != -1)
                              {
                                v177[0].sa_len = 114;
                                v133 = v177;
                                goto LABEL_236;
                              }
                            }
                          }
                          goto LABEL_237;
                        }
                      }
                      goto LABEL_238;
                    }
                    v176 = 256;
                    v129 = atomic_load((unint64_t *)v67 + 1);
                    v101 = (CFDataRef)v67[22];
                    if ((v129 & 0x10) != 0)
                    {
                      if (v101)
                        goto LABEL_170;
                      v134 = *((_DWORD *)v67 + 38);
                      if (v134 != -1)
                      {
                        if (getpeername(v134, v177, (socklen_t *)&v176) || v176 <= 0)
                        {
                          v101 = (CFDataRef)v67[22];
                        }
                        else
                        {
                          v135 = CFGetAllocator(v67);
                          v101 = CFDataCreate(v135, &v177[0].sa_len, v176);
                          v67[22] = (__objc2_class *)v101;
                        }
                        goto LABEL_215;
                      }
                    }
                    else
                    {
LABEL_215:
                      if (v101)
                        goto LABEL_170;
                    }
                  }
LABEL_172:
                  v103 = CFGetAllocator(v67);
                  v102 = CFDataCreate(v103, 0, 0);
                  goto LABEL_173;
                }
                continue;
              }
            }
          }
          else
          {
            v82 = 0;
          }
          v83 = CFGetAllocator(v67);
          p_sa_len = 0;
          v84 = 0;
          goto LABEL_154;
        }
        v75 = atomic_load(v69);
        if ((v75 & 3) != 2)
        {
          v86 = (pthread_mutex_t *)(v67 + 3);
          pthread_mutex_lock((pthread_mutex_t *)(v67 + 3));
          v87 = atomic_load((unint64_t *)v67 + 1);
          if ((v87 & 0x10) != 0 && (*((_BYTE *)v67 + 17) & 1) == 0)
          {
            if (v68)
            {
              if (!v67[38] && !v67[41])
              {
                *((_DWORD *)v67 + 86) = 0;
                v67[42] = 0;
                goto LABEL_149;
              }
LABEL_206:
              v126 = atomic_load(v69);
              while (2)
              {
                v127 = __ldaxr(v69);
                if (v127 == v126)
                {
                  if (!__stlxr(v126 | 0x20, v69))
                  {
                    v128 = 1;
                    goto LABEL_212;
                  }
                }
                else
                {
                  __clrex();
                }
                v128 = 0;
LABEL_212:
                v126 = v127;
                if (v128)
                  goto LABEL_238;
                continue;
              }
            }
            v125 = v67[37];
            if (!v125)
              goto LABEL_206;
            if (*((_BYTE *)v67 + 320))
              goto LABEL_206;
            v143 = (char *)v125 - (char *)v67[38];
            if (v143 < 1)
              goto LABEL_206;
            v144 = CFDataGetMutableBytePtr((CFMutableDataRef)v67[36]);
            Native = CFSocketGetNative((CFSocketRef)v67);
            v146 = read(Native, (char *)v67[38] + (_QWORD)v144, v143);
            if (!v146)
            {
LABEL_256:
              *((_BYTE *)v67 + 320) = 1;
              goto LABEL_206;
            }
            if (v146 == -1)
            {
              if (*__error() != 35)
              {
                *((_DWORD *)v67 + 81) = *__error();
                goto LABEL_256;
              }
LABEL_149:
              os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
              __CFReadSocketsTimeoutInvalid = 0;
              v88 = *((unsigned int *)v67 + 38);
              if ((v88 & 0x80000000) == 0)
              {
                v89 = (__CFData *)__CFReadSocketsFds;
                v90 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
                if ((uint64_t)v90 <= v88)
                {
                  v147 = v90 >> 5;
                  v148 = 4 * (((unint64_t)(v88 + 32) >> 5) - (v90 >> 5));
                  CFDataIncreaseLength(v89, v148);
                  v91 = CFDataGetMutableBytePtr(v89);
                  bzero(&v91[4 * v147], v148);
                }
                else
                {
                  v91 = CFDataGetMutableBytePtr(v89);
                }
                if (!__darwin_check_fd_set_overflow(v88, v91, 1)
                  || ((*(_DWORD *)&v91[((unint64_t)v88 >> 3) & 0x1FFFFFFC] >> v88) & 1) == 0)
                {
                  if (__darwin_check_fd_set_overflow(v88, v91, 1))
                    *(_DWORD *)&v91[4 * (v88 >> 5)] |= 1 << v88;
                  v149 = __CFWakeupSocketPair;
                  if ((_DWORD)__CFWakeupSocketPair != -1)
                  {
                    context[0].sa_len = 114;
                    v150 = context;
                    goto LABEL_264;
                  }
                }
              }
            }
            else
            {
              v151 = v67[37];
              v152 = (ssize_t)v67[38] + v146;
              v67[38] = (__objc2_class *)v152;
              if (v151 == (__objc2_class *)v152)
              {
                *((_DWORD *)v67 + 86) = 0;
                v67[42] = 0;
                goto LABEL_206;
              }
              *(_QWORD *)&context[0].sa_data[6] = 0;
              *(_QWORD *)&context[0].sa_len = 0;
              gettimeofday((timeval *)context, 0);
              v153 = (char *)v67[34] + *(_QWORD *)&context[0].sa_len;
              v67[42] = (__objc2_class *)v153;
              v154 = *((_DWORD *)v67 + 70) + *(_DWORD *)&context[0].sa_data[6];
              *((_DWORD *)v67 + 86) = v154;
              if (v154 >= 1000000)
              {
                v67[42] = (__objc2_class *)(v153 + 1);
                *((_DWORD *)v67 + 86) = v154 - 1000000;
              }
              os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
              __CFReadSocketsTimeoutInvalid = 0;
              v155 = *((unsigned int *)v67 + 38);
              if ((v155 & 0x80000000) == 0)
              {
                v156 = (__CFData *)__CFReadSocketsFds;
                v157 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
                if ((uint64_t)v157 <= v155)
                {
                  v159 = v157 >> 5;
                  v160 = 4 * (((unint64_t)(v155 + 32) >> 5) - (v157 >> 5));
                  CFDataIncreaseLength(v156, v160);
                  v158 = CFDataGetMutableBytePtr(v156);
                  bzero(&v158[4 * v159], v160);
                }
                else
                {
                  v158 = CFDataGetMutableBytePtr(v156);
                }
                if (!__darwin_check_fd_set_overflow(v155, v158, 1)
                  || ((*(_DWORD *)&v158[((unint64_t)v155 >> 3) & 0x1FFFFFFC] >> v155) & 1) == 0)
                {
                  if (__darwin_check_fd_set_overflow(v155, v158, 1))
                    *(_DWORD *)&v158[4 * (v155 >> 5)] |= 1 << v155;
                  v149 = __CFWakeupSocketPair;
                  if ((_DWORD)__CFWakeupSocketPair != -1)
                  {
                    v177[0].sa_len = 114;
                    v150 = v177;
LABEL_264:
                    send(v149, v150, 1uLL, 0);
                  }
                }
              }
            }
            os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
          }
          v114 = v86;
          goto LABEL_267;
        }
        *(_DWORD *)&v177[0].sa_len = 256;
        v76 = accept(*((_DWORD *)v67 + 38), context, (socklen_t *)&v177[0].sa_len);
        if (v76 == -1)
          goto LABEL_268;
        v77 = v76;
        v78 = *(_DWORD *)&v177[0].sa_len;
        v79 = CFGetAllocator(v67);
        if (v78 < 1)
        {
          v81 = 0;
          v80 = 0;
        }
        else
        {
          v80 = *(int *)&v177[0].sa_len;
          v81 = context;
        }
        v112 = CFDataCreate(v79, &v81->sa_len, v80);
        v93 = (pthread_mutex_t *)(v67 + 3);
        pthread_mutex_lock((pthread_mutex_t *)(v67 + 3));
        v113 = atomic_load((unint64_t *)v67 + 1);
        if ((v113 & 0x10) == 0)
        {
          close(v77);
          v95 = v112;
LABEL_187:
          CFRelease(v95);
          v114 = v93;
LABEL_267:
          pthread_mutex_unlock(v114);
          goto LABEL_268;
        }
        v115 = atomic_load(v69);
        do
        {
          v116 = __ldaxr(v69);
          if (v116 == v115)
          {
            if (!__stlxr(v115 | 0x20, v69))
            {
              v117 = 1;
              goto LABEL_194;
            }
          }
          else
          {
            __clrex();
          }
          v117 = 0;
LABEL_194:
          v115 = v116;
        }
        while (!v117);
        v118 = (__CFArray *)v67[32];
        if (!v118)
        {
          v119 = CFGetAllocator(v67);
          v118 = CFArrayCreateMutable(v119, 0, 0);
          v67[32] = (__objc2_class *)v118;
        }
        if (!v67[33])
        {
          v120 = CFGetAllocator(v67);
          v67[33] = (__objc2_class *)CFArrayCreateMutable(v120, 0, &kCFTypeArrayCallBacks);
          v118 = (__CFArray *)v67[32];
        }
        CFArrayAppendValue(v118, (const void *)v77);
        CFArrayAppendValue((CFMutableArrayRef)v67[33], v112);
        CFRelease(v112);
        if (((_DWORD)v67[2] & 0x202) == 2 && *((int *)v67 + 46) >= 1)
        {
          os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
          __CFReadSocketsTimeoutInvalid = 0;
          v121 = *((unsigned int *)v67 + 38);
          if ((v121 & 0x80000000) == 0)
          {
            v122 = (__CFData *)__CFReadSocketsFds;
            v123 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
            if ((uint64_t)v123 <= v121)
            {
              v136 = v123 >> 5;
              v137 = 4 * (((unint64_t)(v121 + 32) >> 5) - (v123 >> 5));
              CFDataIncreaseLength(v122, v137);
              v124 = CFDataGetMutableBytePtr(v122);
              bzero(&v124[4 * v136], v137);
            }
            else
            {
              v124 = CFDataGetMutableBytePtr(v122);
            }
            if (!__darwin_check_fd_set_overflow(v121, v124, 1)
              || ((*(_DWORD *)&v124[((unint64_t)v121 >> 3) & 0x1FFFFFFC] >> v121) & 1) == 0)
            {
              if (__darwin_check_fd_set_overflow(v121, v124, 1))
                *(_DWORD *)&v124[4 * (v121 >> 5)] |= 1 << v121;
              v132 = __CFWakeupSocketPair;
              if ((_DWORD)__CFWakeupSocketPair != -1)
              {
                v174.sa_len = 114;
                v133 = &v174;
LABEL_236:
                send(v132, v133, 1uLL, 0);
              }
            }
          }
LABEL_237:
          os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
        }
LABEL_238:
        CFRunLoopSourceSignal((CFRunLoopSourceRef)v67[24]);
        v138 = (__objc2_class *)CFRetain(v67[25]);
        v139 = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (CFArrayRef)v67[25]);
        v140 = v67[24];
        if (v140)
        {
          if (CFRunLoopSourceIsValid((CFRunLoopSourceRef)v67[24]))
          {
            CFRetain(v140);
            v141 = 0;
            goto LABEL_243;
          }
          v140 = 0;
        }
        v141 = 1;
LABEL_243:
        pthread_mutex_unlock((pthread_mutex_t *)(v67 + 3));
        v142 = __CFSocketCopyRunLoopToWakeUp((__CFRunLoopSource *)v140, v139);
        if ((v141 & 1) == 0)
          CFRelease(v140);
        if (v142)
        {
          CFRunLoopWakeUp((CFRunLoopRef)v142);
          CFRelease(v142);
        }
        pthread_mutex_lock((pthread_mutex_t *)(v67 + 3));
        v49 = theArray;
        if (v138 == v67[25])
        {
          v67[25] = (__objc2_class *)v139;
          CFRelease(v138);
          v139 = 0;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(v67 + 3));
        CFRelease(v138);
        if (v139)
          CFRelease(v139);
LABEL_268:
        CFArraySetValueAtIndex(v49, v65, &__kCFNull);
LABEL_269:
        if (++v65 == idx)
        {
LABEL_286:
          v4 = 0;
          Typed = v162;
          goto LABEL_2;
        }
      }
    }
  }
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
  size_t length;
  CFIndex location;
  CFIndex v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  char v24;
  unint64_t v25;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    -[__CFData getBytes:range:](theData, "getBytes:range:", buffer, location, length);
  }
  else
  {
    if (location < 0)
    {
      v11 = dyld_program_sdk_at_least();
      if ((_DWORD)v11)
        CFDataGetBytes_cold_7(v11, v12, v13);
      v20 = _CFOSLog();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
        CFDataGetBytes_cold_8();
    }
    else
    {
      v7 = *((_QWORD *)theData + 2);
      if (location <= v7)
      {
        if ((length & 0x8000000000000000) != 0)
        {
          v17 = dyld_program_sdk_at_least();
          if ((_DWORD)v17)
            CFDataGetBytes_cold_5(v17, v18, v19);
          v22 = _CFOSLog();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
            CFDataGetBytes_cold_6();
        }
        else if ((uint64_t)(location + length) > v7)
        {
          v14 = dyld_program_sdk_at_least();
          if ((_DWORD)v14)
            CFDataGetBytes_cold_3(v14, v15, v16);
          v23 = _CFOSLog();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
            CFDataGetBytes_cold_4();
        }
      }
      else
      {
        v8 = dyld_program_sdk_at_least();
        if ((_DWORD)v8)
          CFDataGetBytes_cold_1(v8, v9, v10);
        v21 = _CFOSLog();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
          CFDataGetBytes_cold_2();
      }
    }
    v24 = atomic_load((unint64_t *)theData + 1);
    if ((v24 & 4) != 0)
      v25 = ((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0;
    else
      v25 = *((_QWORD *)theData + 5);
    memmove(buffer, (const void *)(v25 + location), length);
  }
}

__CFArray *__CFArrayCreateMutableCopy0(__objc2_class **a1, uint64_t a2, unint64_t *a3)
{
  uint64_t v6;
  const CFArrayCallBacks *v7;
  uint64_t Init;
  __CFArray *v9;
  uint64_t i;
  unsigned int v12;
  int v13;
  char v14;
  int v15;

  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)a3))
    v6 = objc_msgSend(a3, "count");
  else
    v6 = a3[2];
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)a3))
    goto LABEL_5;
  v12 = atomic_load(a3 + 1);
  v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
LABEL_5:
      v7 = &kCFTypeArrayCallBacks;
      goto LABEL_6;
    }
    v14 = atomic_load(a3 + 1);
    v15 = v14 & 3;
    if (v15 != 2 && v15)
      v7 = 0;
    else
      v7 = (const CFArrayCallBacks *)(a3 + 6);
  }
  else
  {
    v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_6:
  Init = __CFArrayCreateInit(a1, 2, a2, v7);
  v9 = (__CFArray *)Init;
  if (!a2)
    _CFArraySetCapacity(Init, v6);
  if (v6 >= 1)
  {
    for (i = 0; i != v6; ++i)
      CFArrayAppendValue(v9, (const void *)objc_msgSend(a3, "objectAtIndex:", i));
  }
  return v9;
}

void _CFArraySetCapacity(uint64_t a1, uint64_t a2)
{
  char v4;
  _QWORD *v5;
  uint64_t v6;
  const CFAllocatorRef *v7;
  char v8;
  const __CFAllocator *v9;
  uint64_t v10;
  _QWORD *Typed;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;

  if (!CF_IS_OBJC(0x13uLL, (__objc2_class **)a1))
  {
    v4 = atomic_load((unint64_t *)(a1 + 8));
    if ((v4 & 3) == 2)
    {
      v5 = *(_QWORD **)(a1 + 40);
      if (a2 >= 4)
      {
        if (flsl(a2) == 31)
          v6 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v6 = 1 << flsl(a2);
      }
      else
      {
        v6 = 4;
      }
      if (a1 < 0)
      {
        v7 = &kCFAllocatorSystemDefault;
      }
      else
      {
        v8 = atomic_load((unint64_t *)(a1 + 8));
        if (v8 < 0)
          v7 = &kCFAllocatorSystemDefault;
        else
          v7 = (const CFAllocatorRef *)(a1 - 16);
      }
      v9 = *v7;
      if (v5)
      {
        v10 = v5[1];
        Typed = (_QWORD *)CFAllocatorAllocateTyped(*v7, 8 * v6 + 16, 3380702267, 0);
        if (Typed)
        {
          v12 = Typed;
          memmove(Typed, v5, 8 * v10 + 16);
          CFAllocatorDeallocate(v9, v5);
          if (__CFOASafe)
            __CFSetLastAllocationEventName();
LABEL_24:
          v12[1] = v6;
          *(_QWORD *)(a1 + 40) = v12;
          return;
        }
      }
      else
      {
        v13 = CFAllocatorAllocateTyped(*v7, 8 * v6 + 16, 2017679120, 0);
        if (v13)
        {
          v12 = (_QWORD *)v13;
          if (__CFOASafe)
            __CFSetLastAllocationEventName();
          if (v6 >= 0)
            v14 = v6;
          else
            v14 = v6 + 1;
          *v12 = v14 >> 1;
          goto LABEL_24;
        }
      }
      __CFArrayHandleOutOfMemory(8 * v6 + 16);
    }
  }
}

Boolean CFSocketIsValid(CFSocketRef s)
{
  unint64_t v2;
  unsigned int v3;

  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v3 = atomic_load((unint64_t *)s + 1);
  return (v3 >> 4) & 1;
}

Boolean CFRunLoopSourceIsValid(CFRunLoopSourceRef source)
{
  unint64_t v2;
  unsigned int v3;

  v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46)
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v3 = atomic_load((unint64_t *)source + 1);
  return (v3 >> 3) & 1;
}

char *__CFSocketCopyRunLoopToWakeUp(__CFRunLoopSource *a1, CFArrayRef theArray)
{
  int Count;
  char *ValueAtIndex;
  CFIndex i;
  char *v7;
  int v8;
  int v9;
  uint64_t v10;
  __CFRunLoop *v11;
  const __CFString *v12;
  const __CFString *v13;
  int IsWaiting;
  int v15;
  _BOOL4 v16;

  if (!a1)
    return 0;
  Count = CFArrayGetCount(theArray);
  if (Count < 1)
    return 0;
  ValueAtIndex = (char *)CFArrayGetValueAtIndex(theArray, 0);
  if (ValueAtIndex && Count != 1)
  {
    for (i = 1; i < Count; ++i)
    {
      v7 = (char *)CFArrayGetValueAtIndex(theArray, i);
      if (v7 != ValueAtIndex)
        break;
    }
    if (v7 != ValueAtIndex)
      ValueAtIndex = 0;
  }
  if (ValueAtIndex)
  {
    CFRetain(ValueAtIndex);
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v10 = Count;
    do
    {
      v11 = (__CFRunLoop *)CFArrayGetValueAtIndex(theArray, (CFIndex)ValueAtIndex);
      v12 = CFRunLoopCopyCurrentMode(v11);
      if (v12)
      {
        v13 = v12;
        if (CFRunLoopContainsSource(v11, a1, v12))
        {
          IsWaiting = CFRunLoopIsWaiting(v11);
          v15 = v9 ? v8 : (int)ValueAtIndex;
          v16 = IsWaiting != 0;
          if (IsWaiting)
          {
            v8 = (int)ValueAtIndex;
          }
          else
          {
            v9 = 1;
            v8 = v15;
          }
        }
        else
        {
          v16 = 0;
        }
        CFRelease(v13);
        if (v16)
          break;
      }
      ++ValueAtIndex;
    }
    while ((uint64_t)ValueAtIndex < v10);
    ValueAtIndex = (char *)CFArrayGetValueAtIndex(theArray, v8);
    CFRetain(ValueAtIndex);
    CFArrayRemoveValueAtIndex(theArray, v8);
    CFArrayAppendValue(theArray, ValueAtIndex);
  }
  return ValueAtIndex;
}

SInt32 CFMessagePortSendRequest(CFMessagePortRef remote, SInt32 msgid, CFDataRef data, CFTimeInterval sendTimeout, CFTimeInterval rcvTimeout, CFStringRef replyMode, CFDataRef *returnData)
{
  unint64_t v14;
  CFRunLoopRef Current;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  __objc2_class **v24;
  int v25;
  mach_port_t Port;
  mach_port_t v27;
  const UInt8 *BytePtr;
  int Length;
  char *Message;
  mach_msg_header_t *v31;
  int v32;
  const __CFAllocator *v33;
  __CFRunLoopSource *RunLoopSource;
  __CFRunLoop *v35;
  char v36;
  double v37;
  mach_msg_timeout_t v38;
  mach_msg_option_t v39;
  mach_msg_return_t v40;
  mach_port_name_t msgh_local_port;
  uint64_t v42;
  uint64_t v43;
  double v44;
  __objc2_class **Value;
  __objc2_class **v46;
  BOOL v47;
  int v48;
  const __CFData *v49;
  CFDataRef *v50;
  __CFRunLoop *rl;
  __int128 v52;
  CFTypeRef (__cdecl *v53)(CFTypeRef);
  void (__cdecl *v54)(CFTypeRef);
  CFStringRef (*v55)(unint64_t *);
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v14 = _CFGetNonObjCTypeID((unint64_t *)remote);
  if (v14 != 35)
    _CFAssertMismatchedTypeID(0x23uLL, v14);
  Current = CFRunLoopGetCurrent();
  if (data && CFDataGetLength(data) >= 1610612737)
  {
    CFLog(4, (uint64_t)CFSTR("*** CFMessagePortSendRequest: CFMessagePort cannot send more than %lu bytes of data"), v16, v17, v18, v19, v20, v21, 0);
    return -4;
  }
  os_unfair_lock_lock((os_unfair_lock_t)remote + 28);
  v22 = atomic_load((unint64_t *)remote + 1);
  if ((v22 & 1) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
    return -3;
  }
  v50 = returnData;
  rl = Current;
  CFRetain(remote);
  if (!*((_QWORD *)remote + 6))
  {
    *(_QWORD *)&v52 = 0;
    *((_QWORD *)&v52 + 1) = remote;
    v53 = CFRetain;
    v54 = CFRelease;
    v55 = __CFMessagePortCopyDescription;
    v24 = (__objc2_class **)CFGetAllocator(remote);
    *((_QWORD *)remote + 6) = _CFMachPortCreateReply(v24, (uint64_t)__CFMessagePortReplyCallBack, &v52, 0);
  }
  v25 = *((_DWORD *)remote + 10);
  *((_DWORD *)remote + 10) = v25 + 1;
  Port = CFMachPortGetPort(*((CFMachPortRef *)remote + 3));
  if (replyMode)
  {
    v27 = CFMachPortGetPort(*((CFMachPortRef *)remote + 6));
    if (data)
    {
LABEL_11:
      BytePtr = CFDataGetBytePtr(data);
      Length = CFDataGetLength(data);
      goto LABEL_14;
    }
  }
  else
  {
    v27 = 0;
    if (data)
      goto LABEL_11;
  }
  BytePtr = 0;
  Length = -1;
LABEL_14:
  Message = __CFMessagePortCreateMessage(0, Port, v27, v25 + 1, msgid, BytePtr, Length);
  if (!Message)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
    CFRelease(remote);
    return -4;
  }
  v31 = (mach_msg_header_t *)Message;
  v32 = ~v25;
  if (replyMode)
  {
    CFDictionarySetValue(*((CFMutableDictionaryRef *)remote + 4), (const void *)v32, &__kCFNull);
    v33 = CFGetAllocator(remote);
    RunLoopSource = CFMachPortCreateRunLoopSource(v33, *((CFMachPortRef *)remote + 6), -100);
    v35 = rl;
    if (CFRunLoopContainsSource(rl, RunLoopSource, replyMode))
    {
      v36 = 1;
    }
    else
    {
      CFRunLoopAddSource(rl, RunLoopSource, replyMode);
      v36 = 0;
    }
  }
  else
  {
    RunLoopSource = 0;
    v36 = 1;
    v35 = rl;
  }
  if (sendTimeout >= 864000.0)
  {
    v38 = 0;
    v39 = 1;
  }
  else
  {
    v37 = sendTimeout * 1000.0;
    if (sendTimeout * 1000.0 < 1.0)
      v37 = 0.0;
    v38 = vcvtmd_u64_f64(v37);
    v39 = 17;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
  v40 = mach_msg(v31, v39, v31->msgh_size, 0, 0, v38, 0);
  os_unfair_lock_lock((os_unfair_lock_t)remote + 28);
  if (!v40)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v31);
    if (replyMode)
    {
      _CFMachPortInstallNotifyPort(v35, replyMode);
      v42 = mach_absolute_time();
      v43 = __CFTimeIntervalToTSR(rcvTimeout) + v42;
      do
      {
        v44 = __CFTimeIntervalUntilTSR(v43);
        CFRunLoopRunInMode(replyMode, v44, 1u);
        Value = (__objc2_class **)CFDictionaryGetValue(*((CFDictionaryRef *)remote + 4), (const void *)v32);
        v46 = Value;
        if (Value)
          v47 = &__kCFNull == Value;
        else
          v47 = 1;
        v48 = v47;
      }
      while (v47 && v43 >= mach_absolute_time() && CFMessagePortIsValid(remote));
      if ((v36 & 1) == 0)
        CFRunLoopRemoveSource(rl, RunLoopSource, replyMode);
      if (RunLoopSource)
        CFRelease(RunLoopSource);
      if (v48)
      {
        CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)remote + 4), (const void *)v32);
        CFRelease(remote);
        if (CFMessagePortIsValid(remote))
          return -2;
        else
          return -5;
      }
      if (v50)
      {
        if (&__kCFBooleanFalse == v46)
          v49 = 0;
        else
          v49 = (const __CFData *)CFRetain(v46);
        *v50 = v49;
      }
      CFDictionaryRemoveValue(*((CFMutableDictionaryRef *)remote + 4), (const void *)v32);
    }
    CFRelease(remote);
    return 0;
  }
  if (replyMode)
  {
    if ((v40 - 268435459) <= 4 && ((1 << (v40 - 3)) & 0x13) != 0)
    {
      msgh_local_port = v31->msgh_local_port;
      if (msgh_local_port - 1 <= 0xFFFFFFFD && (v31->msgh_bits & 0x1F00) == 0x1200)
      {
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], msgh_local_port);
        v31->msgh_local_port = 0;
      }
    }
  }
  if ((v36 & 1) == 0)
    CFRunLoopRemoveSource(v35, RunLoopSource, replyMode);
  if (RunLoopSource)
    CFRelease(RunLoopSource);
  os_unfair_lock_unlock((os_unfair_lock_t)remote + 28);
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v31);
  CFRelease(remote);
  if (v40 == 268435460)
    return -1;
  else
    return -4;
}

mach_port_t CFMachPortGetPort(CFMachPortRef port)
{
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) != 0)
    return 0;
  if (CF_IS_OBJC(0x24uLL, (__objc2_class **)port))
    return -[__CFMachPort machPort](port, "machPort");
  return *((_DWORD *)port + 5);
}

uint64_t _CFRunLoopSetPerCalloutAutoreleasepoolEnabled(uint64_t a1)
{
  *((_BYTE *)CFRunLoopGetCurrent() + 681) = a1;
  return a1;
}

void CFRunLoopRun(void)
{
  CFRunLoopRef Current;
  int v1;

  do
  {
    Current = CFRunLoopGetCurrent();
    v1 = CFRunLoopRunSpecific((uint64_t)Current, CFSTR("kCFRunLoopDefaultMode"), 0, 1.0e10);
    if ((__CF_FORK_STATE & 2) == 0)
      __CF_USED();
    if ((__CF_FORK_STATE & 1) != 0)
      __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  }
  while ((v1 - 3) < 0xFFFFFFFE);
}

void _CFStreamSignalEvent(char *cf, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v10;
  unint64_t v11;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __CFRunLoopSource *v16;
  __CFRunLoop *Current;
  const __CFString *v18;
  const __CFString *v19;
  int v20;
  _OWORD *Typed;
  CFAllocatorRef v24;
  const void *v25;
  uint64_t v26;

  v8 = a4;
  v10 = *((_QWORD *)cf + 2);
  v11 = v10 & 0x1F;
  if ((v10 & 0x1F) == 0)
  {
    CFLog(3, (uint64_t)CFSTR("Stream %p is sending an event before being opened"), (uint64_t)a3, a4, a5, a6, a7, a8, (__int16)cf);
    goto LABEL_7;
  }
  if ((v10 & 0x1E) == 6)
  {
LABEL_7:
    v13 = 0;
    goto LABEL_8;
  }
  v13 = a2;
  if (v11 == 1)
  {
    if ((a2 & 1) != 0)
    {
      v10 = v10 & 0xFFFFFFE0 | 2;
      *((_QWORD *)cf + 2) = v10;
    }
    goto LABEL_22;
  }
  if (v11 != 5)
  {
    v13 = a2 & 0xFFFFFFFFFFFFFFFELL;
LABEL_22:
    if (v11 <= 4 && (v13 & 0x10) != 0 && (v10 & 0x1E) != 6)
      *((_QWORD *)cf + 2) = v10 & 0xFFFFFFE0 | 5;
    goto LABEL_30;
  }
  v13 = a2 & 8;
LABEL_30:
  if ((v13 & 8) != 0)
  {
    if (**((uint64_t **)cf + 6) > 1)
    {
      CFRetain(a3);
      v25 = (const void *)*((_QWORD *)cf + 3);
      if (v25)
        CFRelease(v25);
      *((_QWORD *)cf + 3) = a3;
    }
    else
    {
      Typed = (_OWORD *)*((_QWORD *)cf + 3);
      if (!Typed)
      {
        v24 = CFGetAllocator(cf);
        Typed = (_OWORD *)CFAllocatorAllocateTyped(v24, 16, 0x1000040D9A13B51, 0);
        *((_QWORD *)cf + 3) = Typed;
      }
      *Typed = *a3;
    }
    v26 = *((_QWORD *)cf + 2);
    if ((v26 & 0x1F) != 7)
      *((_QWORD *)cf + 2) = v26 & 0xFFFFFFE0 | 7;
  }
LABEL_8:
  v14 = *((_QWORD *)cf + 4);
  if (v14 && (*(_QWORD *)(v14 + 48) & v13) != 0 && (*(_QWORD *)(v14 + 72) & v13) == 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    v15 = *((_QWORD *)cf + 4);
    if (v15 && (v16 = *(__CFRunLoopSource **)(v15 + 56)) != 0)
    {
      CFRetain(*(CFTypeRef *)(v15 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      *(_QWORD *)(*((_QWORD *)cf + 4) + 72) |= v13;
      if (v8
        && (cf[16] & 0x40) == 0
        && (Current = CFRunLoopGetCurrent(), (v18 = CFRunLoopCopyCurrentMode(Current)) != 0)
        && (v19 = v18, v20 = CFRunLoopContainsSource(Current, v16, v18), CFRelease(v19), v20))
      {
        _cfstream_solo_signalEventSync((uint64_t)cf);
      }
      else
      {
        CFRunLoopSourceSignal(v16);
        _wakeUpRunLoop((uint64_t)cf);
      }
      CFRelease(v16);
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
    }
  }
}

CFRunLoopRunResult CFRunLoopRunInMode(CFRunLoopMode mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled)
{
  int v3;
  CFRunLoopRef Current;

  v3 = returnAfterSourceHandled;
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  Current = CFRunLoopGetCurrent();
  return CFRunLoopRunSpecific((uint64_t)Current, mode, v3, seconds);
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  CFRunLoopRef result;
  _opaque_pthread_t *v1;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  result = (CFRunLoopRef)_CFGetTSD(0xAu);
  if (!result)
  {
    v1 = pthread_self();
    return (CFRunLoopRef)_CFRunLoopGet0(v1);
  }
  return result;
}

const void *_CFRunLoopGet0(_opaque_pthread_t *a1)
{
  _opaque_pthread_t *v1;
  const __CFDictionary *v2;
  __CFDictionary *Mutable;
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *Value;
  const void *v9;
  _opaque_pthread_t *v10;

  v1 = a1;
  if (pthread_equal(a1, 0))
    v1 = (_opaque_pthread_t *)pthread_main_thread_np();
  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  v2 = (const __CFDictionary *)__CFRunLoops;
  if (!__CFRunLoops)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
    v4 = pthread_main_thread_np();
    v5 = (const void *)__CFRunLoopCreate(v4);
    v6 = (const void *)pthread_main_thread_np();
    CFDictionarySetValue(Mutable, v6, v5);
    while (!__ldaxr((unint64_t *)&__CFRunLoops))
    {
      if (!__stlxr((unint64_t)Mutable, (unint64_t *)&__CFRunLoops))
        goto LABEL_9;
    }
    __clrex();
    CFRelease(Mutable);
LABEL_9:
    CFRelease(v5);
    v2 = (const __CFDictionary *)__CFRunLoops;
  }
  Value = CFDictionaryGetValue(v2, v1);
  if (Value)
  {
    v9 = Value;
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  }
  else
  {
    v9 = (const void *)__CFRunLoopCreate((uint64_t)v1);
    kdebug_trace();
    CFDictionarySetValue((CFMutableDictionaryRef)__CFRunLoops, v1, v9);
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
    if (v9)
      CFRelease(v9);
  }
  v10 = pthread_self();
  if (pthread_equal(v1, v10))
  {
    _CFSetTSD(0xAu, (uint64_t)v9, 0);
    if (!_CFGetTSD(0xBu))
      _CFSetTSD(0xBu, 3, (uint64_t)__CFFinalizeRunLoop);
  }
  return v9;
}

uint64_t __CFRunLoopCreate(uint64_t a1)
{
  uint64_t Instance;
  uint64_t result;
  mach_port_name_t v4;
  __CFSet *Mutable;
  const void *v6;
  uint64_t v7;
  mach_port_name_t name;
  pthread_mutexattr_t v9;
  mach_port_options_t options;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  Instance = _CFRuntimeCreateInstance(&__kCFAllocatorSystemDefault, 0x2BuLL, 672, 0);
  if (!Instance)
    return Instance;
  v9.__sig = 0;
  *(_QWORD *)v9.__opaque = 0;
  pthread_mutexattr_init(&v9);
  pthread_mutexattr_settype(&v9, 2);
  pthread_mutex_init((pthread_mutex_t *)(Instance + 16), &v9);
  pthread_mutexattr_destroy(&v9);
  name = 0;
  *(_OWORD *)&options.flags = xmmword_182C8B2E8;
  options.reserved[1] = 0;
  result = mach_port_construct(*MEMORY[0x1E0C83DA0], &options, Instance, &name);
  if ((_DWORD)result)
  {
    v7 = snprintf((char *)&v9, 0x100uLL, "*** The system has no mach ports available. You may be able to diagnose which application(s) are using ports by using 'top' or Activity Monitor. (%d) ***", result);
    qword_1EDCD1038 = (uint64_t)&v9;
    __THE_SYSTEM_HAS_NO_PORTS_AVAILABLE__(v7);
  }
  v4 = name;
  *(_DWORD *)(Instance + 80) = name;
  if (v4)
  {
    *(_WORD *)(Instance + 84) = 0;
    *(_BYTE *)(Instance + 339) = 1;
    Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
    *(_QWORD *)(Instance + 608) = Mutable;
    CFSetAddValue(Mutable, CFSTR("kCFRunLoopDefaultMode"));
    *(_QWORD *)(Instance + 632) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
    *(_QWORD *)(Instance + 600) = a1;
    *(_DWORD *)(Instance + 684) = 0;
    *(_BYTE *)(Instance + 681) = 1;
    v6 = (const void *)__CFRunLoopCopyMode(Instance, CFSTR("kCFRunLoopDefaultMode"), 1);
    if (v6)
      CFRelease(v6);
    return Instance;
  }
  __break(1u);
  return result;
}

void _wakeUpRunLoop(uint64_t a1)
{
  const __CFArray *v1;
  const __CFArray *v2;
  CFIndex Count;
  __CFRunLoop *v4;
  CFIndex v5;
  __CFRunLoop *ValueAtIndex;
  uint64_t v7;
  __CFRunLoop *v8;
  BOOL v9;
  CFIndex v10;
  CFRunLoopMode v11;
  CFRunLoopMode v12;
  const void *v13;

  v1 = _CFStreamCopyRunLoopsAndModes(a1);
  if (!v1)
    return;
  v2 = v1;
  Count = CFArrayGetCount(v1);
  if (Count == 2)
    goto LABEL_3;
  v5 = Count;
  if (Count < 3)
    goto LABEL_23;
  ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, 0);
  if (ValueAtIndex)
  {
    v4 = ValueAtIndex;
    v7 = 4;
    do
    {
      v8 = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, v7 - 2);
      v9 = v8 == v4 && v7 < v5;
      v7 += 2;
    }
    while (v9);
    if (v8 != v4)
      v4 = 0;
    if (v4)
      goto LABEL_4;
  }
  v10 = 0;
  while (1)
  {
    v4 = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, v10);
    v11 = CFRunLoopCopyCurrentMode(v4);
    if (v11)
      break;
LABEL_21:
    v10 += 2;
    if (v10 >= v5)
      goto LABEL_3;
  }
  v12 = v11;
  v13 = CFArrayGetValueAtIndex(v2, v10 + 1);
  if (!CFEqual(v12, v13) || !CFRunLoopIsWaiting(v4))
  {
    CFRelease(v12);
    goto LABEL_21;
  }
  CFRelease(v12);
  if (v4)
  {
LABEL_4:
    CFRunLoopWakeUp(v4);
    goto LABEL_23;
  }
LABEL_3:
  v4 = (__CFRunLoop *)CFArrayGetValueAtIndex(v2, 0);
  if (v4)
    goto LABEL_4;
LABEL_23:
  CFRelease(v2);
}

CFArrayRef _CFStreamCopyRunLoopsAndModes(uint64_t a1)
{
  CFArrayRef Copy;
  pthread_mutex_t *v2;
  const __CFAllocator *v3;

  Copy = (CFArrayRef)a1;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 32))
    {
      v2 = (pthread_mutex_t *)(a1 + 56);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      if (*(_QWORD *)(*((_QWORD *)Copy + 4) + 64))
      {
        v3 = CFGetAllocator(Copy);
        Copy = CFArrayCreateCopy(v3, *(CFArrayRef *)(*((_QWORD *)Copy + 4) + 64));
      }
      else
      {
        Copy = 0;
      }
      pthread_mutex_unlock(v2);
    }
    else
    {
      return 0;
    }
  }
  return Copy;
}

Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  unint64_t v6;
  pthread_mutex_t *v7;
  uint64_t v8;
  _QWORD *v9;
  pthread_mutex_t *v10;
  const __CFSet *v11;
  Boolean v12;
  const __CFSet *v13;
  const __CFSet *v14;

  v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v7 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == CFSTR("kCFRunLoopCommonModes"))
  {
    v13 = (const __CFSet *)*((_QWORD *)rl + 77);
    if (v13)
    {
      v12 = CFSetContainsValue(v13, source);
      goto LABEL_18;
    }
LABEL_13:
    v12 = 0;
    goto LABEL_18;
  }
  v8 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (!v8)
    goto LABEL_13;
  v9 = (_QWORD *)v8;
  v10 = (pthread_mutex_t *)(v8 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 16));
  v11 = (const __CFSet *)v9[12];
  if (v11 && CFSetContainsValue(v11, source))
  {
    v12 = 1;
  }
  else
  {
    v14 = (const __CFSet *)v9[13];
    if (v14)
      v12 = CFSetContainsValue(v14, source) != 0;
    else
      v12 = 0;
  }
  pthread_mutex_unlock(v10);
  CFRelease(v9);
LABEL_18:
  pthread_mutex_unlock(v7);
  return v12;
}

void _cfstream_solo_signalEventSync(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD block[6];

  block[5] = *MEMORY[0x1E0C80C00];
  if ((CFGetTypeID((CFTypeRef)a1) & 0xFFFFFFFFFFFFFFFELL) == 0x26)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    if (*(_BYTE *)(a1 + 136))
    {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
    }
    else
    {
      v8 = *(NSObject **)(a1 + 128);
      if (v8)
      {
        dispatch_retain(*(dispatch_object_t *)(a1 + 128));
        CFRetain((CFTypeRef)a1);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        CFRetain((CFTypeRef)a1);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ___signalEventQueue_block_invoke;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = a1;
        dispatch_async(v8, block);
        dispatch_release(v8);
      }
      else
      {
        CFRetain((CFTypeRef)a1);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        _signalEventSync(a1);
      }
      CFRelease((CFTypeRef)a1);
    }
  }
  else
  {
    CFLog(3, (uint64_t)CFSTR("Expected a read or write stream for %p"), v2, v3, v4, v5, v6, v7, a1);
  }
}

void _cfstream_shared_signalEventSync(const void *a1)
{
  CFTypeID v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFIndex Count;
  CFIndex v10;
  _QWORD *ValueAtIndex;
  uint64_t v12;
  NSObject *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  __CFRunLoopSource *v17;
  _QWORD block[6];

  block[5] = *MEMORY[0x1E0C80C00];
  v2 = CFGetTypeID(a1);
  if (v2 == CFArrayGetTypeID())
  {
    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count < 1)
    {
      v10 = 0;
      v13 = 0;
      v12 = 0;
    }
    else
    {
      v10 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v10);
        if (!*((_BYTE *)ValueAtIndex + 136))
        {
          v12 = (uint64_t)ValueAtIndex;
          if (*(_QWORD *)(ValueAtIndex[4] + 72))
            break;
        }
        if (Count == ++v10)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
          return;
        }
      }
      CFRetain(ValueAtIndex);
      v13 = *(NSObject **)(v12 + 128);
      if (v13)
        dispatch_retain(*(dispatch_object_t *)(v12 + 128));
      *(_BYTE *)(v12 + 136) = 1;
    }
    if (v10 < Count)
    {
      while (1)
      {
        v14 = (char *)CFArrayGetValueAtIndex((CFArrayRef)a1, v10);
        if (v14 != (char *)v12)
        {
          v15 = v14;
          if (!v14[136])
          {
            if (*(_QWORD *)(*((_QWORD *)v14 + 4) + 72))
              break;
          }
        }
        if (Count == ++v10)
          goto LABEL_18;
      }
      pthread_mutex_lock((pthread_mutex_t *)(v14 + 56));
      v16 = *((_QWORD *)v15 + 4);
      if (v16 && (v17 = *(__CFRunLoopSource **)(v16 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v16 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(v15 + 56));
        CFRunLoopSourceSignal(v17);
        CFRelease(v17);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(v15 + 56));
      }
    }
LABEL_18:
    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
    if (v12)
    {
      if (v13)
      {
        CFRetain((CFTypeRef)v12);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ___signalEventQueue_block_invoke;
        block[3] = &__block_descriptor_40_e5_v8__0l;
        block[4] = v12;
        dispatch_async(v13, block);
        dispatch_release(v13);
      }
      else
      {
        _signalEventSync(v12);
      }
      CFRelease((CFTypeRef)v12);
    }
  }
  else
  {
    CFLog(3, (uint64_t)CFSTR("Expected an array for %p"), v3, v4, v5, v6, v7, v8, (__int16)a1);
  }
}

uint64_t _signalEventSync(uint64_t a1)
{
  pthread_mutex_t *v2;
  _QWORD *v3;
  unint64_t v4;
  uint64_t (*v5)(uint64_t, unint64_t, uint64_t);
  uint64_t (*v6)(_QWORD);
  uint64_t v7;
  uint64_t (*v8)(uint64_t);
  uint64_t result;
  unint64_t i;
  uint64_t v11;
  unint64_t v12;

  *(_QWORD *)(a1 + 16) |= 0x40uLL;
  v2 = (pthread_mutex_t *)(a1 + 56);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  v3 = *(_QWORD **)(a1 + 32);
  if (v3 && (v4 = v3[9]) != 0)
  {
    v5 = (uint64_t (*)(uint64_t, unint64_t, uint64_t))v3[5];
    v7 = v3[1];
    v6 = (uint64_t (*)(_QWORD))v3[2];
    if (v6)
    {
      v7 = v6(v3[1]);
      v3 = *(_QWORD **)(a1 + 32);
      v8 = (uint64_t (*)(uint64_t))v3[3];
      v4 = v3[9];
    }
    else
    {
      v8 = 0;
    }
    v3[9] = 0;
    *(_BYTE *)(a1 + 136) = 0;
    result = pthread_mutex_unlock(v2);
    if (v4)
    {
      for (i = 1; i <= v4; i *= 2)
      {
        pthread_mutex_lock(v2);
        if ((i & v4) != 0 && (v11 = *(_QWORD *)(a1 + 32)) != 0)
        {
          v12 = *(_QWORD *)(v11 + 48) & i;
          result = pthread_mutex_unlock(v2);
          if (v12)
            result = v5(a1, i, v7);
        }
        else
        {
          result = pthread_mutex_unlock(v2);
        }
      }
    }
    if (v8)
      result = v8(v7);
  }
  else
  {
    *(_BYTE *)(a1 + 136) = 0;
    result = pthread_mutex_unlock(v2);
  }
  *(_QWORD *)(a1 + 16) &= ~0x40uLL;
  return result;
}

void CFReadStreamSignalEvent(char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CFStreamSignalEvent(a1, a2, a3, 1, a5, a6, a7, a8);
}

char *__CFMessagePortPerform(int *a1, unint64_t a2, const __CFAllocator *a3, uint64_t a4)
{
  os_unfair_lock_s *v8;
  char v9;
  uint64_t (*v10)(_QWORD);
  uint64_t v11;
  void (*v12)(uint64_t);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL4 v19;
  CFIndex v20;
  unint64_t v21;
  int v22;
  BOOL v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unint64_t v29;
  const UInt8 *v30;
  unint64_t v31;
  int v32;
  _BOOL4 v34;
  CFDataRef v35;
  uint64_t (*v36)(uint64_t, uint64_t, CFDataRef, uint64_t);
  const __CFData *v37;
  const __CFData *v38;
  int64_t Length;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  size_t v46;
  uint64_t v47;
  char *Message;
  char *v49;
  void *v50;
  const UInt8 *BytePtr;
  uint64_t v52;
  unsigned int v53;
  BOOL v54;
  int v55;
  int v56;
  BOOL v57;
  BOOL v58;
  BOOL v59;
  uint64_t v60;
  _BOOL4 v61;
  vm_address_t address[2];

  address[1] = *MEMORY[0x1E0C80C00];
  address[0] = 0;
  v8 = (os_unfair_lock_s *)(a4 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a4 + 112));
  v9 = atomic_load((unint64_t *)(a4 + 8));
  if ((v9 & 1) == 0)
  {
    os_unfair_lock_unlock(v8);
    return 0;
  }
  v11 = *(_QWORD *)(a4 + 128);
  v10 = *(uint64_t (**)(_QWORD))(a4 + 136);
  if (v10)
  {
    v11 = v10(*(_QWORD *)(a4 + 128));
    v12 = *(void (**)(uint64_t))(a4 + 144);
  }
  else
  {
    v12 = 0;
  }
  os_unfair_lock_unlock(v8);
  if (a2 < 0x18)
    goto LABEL_7;
  v28 = *a1;
  if (*a1 < 0)
  {
    if (a2 >= 0x3C)
    {
      LODWORD(v31) = a1[1];
      if (v31 >= 0x3C)
      {
        v32 = a1[11];
        v19 = v32 != -252513032 && v32 != -118164752;
        v34 = a1[6] != 1;
        goto LABEL_78;
      }
    }
    goto LABEL_7;
  }
  if (a1[5] == 1128680784)
  {
    if (a2 >= 0x38)
    {
      v29 = 56;
      goto LABEL_38;
    }
LABEL_7:
    LOWORD(v19) = 0;
LABEL_100:
    CFLog(4, (uint64_t)CFSTR("*** CFMessagePort: dropping corrupt request Mach message (0b%d%d%d%d%d%d)"), v13, v14, v15, v16, v17, v18, v19);
    mach_msg_destroy((mach_msg_header_t *)a1);
    return 0;
  }
  if (a2 < 0x3C)
    goto LABEL_7;
  v29 = 60;
LABEL_38:
  v31 = a1[1];
  if (v29 > v31)
    goto LABEL_7;
  if (a1[5] != 1128680784)
  {
    if (a1[11] == -252513032)
    {
      v19 = 0;
      goto LABEL_76;
    }
    v52 = 11;
LABEL_75:
    v19 = a1[v52] != -118164752;
LABEL_76:
    v34 = 0;
    if (a1[5] == 1128680784)
      goto LABEL_77;
LABEL_78:
    v53 = 4060;
    goto LABEL_79;
  }
  if (a1[10] != -252513032)
  {
    v52 = 10;
    goto LABEL_75;
  }
  v34 = 0;
  v19 = 0;
LABEL_77:
  v53 = 4056;
LABEL_79:
  v54 = v53 < v31;
  if (!v34 && v53 >= v31)
  {
    if (v28 < 0)
    {
      v55 = a1[14];
      v58 = (v55 - 1610612737) < 0x9FFFFFFE || a1[10] != v55;
      v57 = v58;
      goto LABEL_98;
    }
    if (a1[5] == 1128680784)
    {
      v55 = a1[13];
      if ((v55 - 1610612737) >= 0x9FFFFFFE)
      {
        v56 = -56;
LABEL_94:
        v59 = v56 + (int)v31 < v55;
        goto LABEL_95;
      }
    }
    else
    {
      v55 = a1[14];
      if ((v55 - 1610612737) >= 0x9FFFFFFE)
      {
        v56 = -60;
        goto LABEL_94;
      }
    }
    v59 = 1;
LABEL_95:
    v57 = v59;
    goto LABEL_96;
  }
  v57 = 0;
  v55 = 0;
  if (v28 < 0)
    goto LABEL_98;
LABEL_96:
  if (a1[5] != 1128680784)
  {
LABEL_98:
    v60 = 11;
    goto LABEL_99;
  }
  v60 = 10;
LABEL_99:
  v61 = a1[v60 + 2] < 1;
  if (v34 || v19 || v54 || v57 || v61)
    goto LABEL_100;
  if (*a1 < 0)
  {
    v26 = a1[12];
    v30 = *(const UInt8 **)(a1 + 7);
    v20 = a1[10];
  }
  else
  {
    v20 = v55 & ~(v55 >> 31);
    v21 = (unint64_t)a1 + a1[1];
    v22 = a1[5];
    v23 = v22 == 1128680784;
    if (v22 == 1128680784)
      v24 = 40;
    else
      v24 = 44;
    v25 = (unint64_t)a1 + v20 + v24 + 16;
    if (v23)
    {
      v26 = a1[11];
      if (v25 > v21)
      {
LABEL_35:
        v35 = 0;
        goto LABEL_45;
      }
      v27 = 10;
    }
    else
    {
      v26 = a1[12];
      if (v25 > v21)
        goto LABEL_35;
      v27 = 11;
    }
    v30 = (const UInt8 *)&a1[v27 + 4];
  }
  v35 = CFDataCreateWithBytesNoCopy(a3, v30, v20, (CFAllocatorRef)&__kCFAllocatorNull);
LABEL_45:
  v36 = *(uint64_t (**)(uint64_t, uint64_t, CFDataRef, uint64_t))(a4 + 96);
  if (v36)
    v37 = (const __CFData *)v36(a4, v26, v35, v11);
  else
    v37 = (const __CFData *)(*(uint64_t (**)(uint64_t, uint64_t, CFDataRef, uint64_t, unint64_t, _QWORD))(a4 + 104))(a4, v26, v35, v11, ((unint64_t)a1 + a1[1] + 3) & 0xFFFFFFFFFFFFFFFCLL, 0);
  v38 = v37;
  if (!v37)
  {
    LODWORD(v46) = -1;
    goto LABEL_56;
  }
  Length = CFDataGetLength(v37);
  if (Length >= 1610612737)
  {
    CFLog(4, (uint64_t)CFSTR("*** CFMessagePort reply: CFMessagePort cannot send more than %lu bytes of data"), v40, v41, v42, v43, v44, v45, 0);
    CFRelease(v38);
    v38 = 0;
LABEL_55:
    LODWORD(v46) = 0;
    goto LABEL_56;
  }
  v46 = Length;
  if (Length <= 3999)
  {
    address[0] = (vm_address_t)CFDataGetBytePtr(v38);
    goto LABEL_56;
  }
  address[0] = 0;
  if (vm_allocate(*MEMORY[0x1E0C83DA0], address, Length, 335544321))
    goto LABEL_55;
  v50 = (void *)address[0];
  BytePtr = CFDataGetBytePtr(v38);
  memmove(v50, BytePtr, v46);
LABEL_56:
  if (*a1 < 0 || a1[5] != 1128680784)
    v47 = 11;
  else
    v47 = 10;
  Message = __CFMessagePortCreateMessage(1, a1[2], 0, -a1[v47 + 2], v26, (const void *)address[0], v46);
  v49 = Message;
  if ((*(_DWORD *)Message & 0x80000000) != 0)
    Message[36] = 1;
  if (v35)
    CFRelease(v35);
  if (*a1 < 0)
    mach_vm_deallocate(*MEMORY[0x1E0C83DA0], *(_QWORD *)(a1 + 7), a1[10]);
  if (v38)
    CFRelease(v38);
  if (v12)
    v12(v11);
  return v49;
}

char *__CFMessagePortCreateMessage(int a1, int a2, int a3, int a4, int a5, const void *a6, int a7)
{
  char *v7;
  unsigned int v15;
  size_t v16;
  char *Typed;
  int v18;
  int v19;
  int v20;
  int v21;

  if ((a7 - 1610612737) < 0x9FFFFFFE)
    return 0;
  if (a7 == -1)
    v15 = 0;
  else
    v15 = (a7 + 7) & 0xFFFFFFF8;
  if (v15 >= 0xFA1)
    v16 = 60;
  else
    v16 = v15 + 60;
  Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v16, 1304999177, 0);
  v7 = Typed;
  if (Typed)
  {
    bzero(Typed, v16);
    *((_DWORD *)v7 + 2) = a2;
    *((_DWORD *)v7 + 3) = a3;
    if (a1)
      v18 = 18;
    else
      v18 = 19;
    if (a3)
      v19 = 5376;
    else
      v19 = 0;
    v20 = v19 | v18;
    *(_DWORD *)v7 = v20;
    *((_DWORD *)v7 + 1) = v16;
    *(_QWORD *)(v7 + 20) = 1667657072;
    *((_DWORD *)v7 + 11) = -252513032;
    *((_DWORD *)v7 + 12) = a5;
    *((_DWORD *)v7 + 13) = a4;
    *((_DWORD *)v7 + 14) = a7;
    if (v15 > 0xFA0)
    {
      *(_DWORD *)v7 = v20 | 0x80000000;
      *((_DWORD *)v7 + 6) = 1;
      v21 = v7[38];
      *(_QWORD *)(v7 + 28) = a6;
      *((_DWORD *)v7 + 9) = (v21 << 16) | 0x1000100;
      *((_DWORD *)v7 + 10) = a7;
    }
    else if (a6 && a7 >= 1)
    {
      memmove(v7 + 60, a6, a7);
    }
  }
  return v7;
}

uint64_t _CFMachPortCreateReply(__objc2_class **a1, uint64_t a2, __int128 *a3, _BYTE *a4)
{
  ipc_space_t *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  mach_port_name_t name;
  mach_port_options_t options;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a4)
    *a4 = 1;
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) != 0)
    return 0;
  name = 0;
  *(_OWORD *)&options.flags = xmmword_182C89DA0;
  options.reserved[1] = 0;
  v8 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  v9 = mach_port_construct(*MEMORY[0x1E0C83DA0], &options, 0, &name);
  if (!(_DWORD)v9)
  {
    result = _CFMachPortCreateWithPort4(a1, name, a2, a3, a4, 1);
    if (!result)
    {
      if (name)
      {
        mach_port_mod_refs(*v8, name, 1u, -1);
        mach_port_deallocate(*v8, name);
      }
      return 0;
    }
    v19 = (unint64_t *)(result + 8);
    v20 = atomic_load((unint64_t *)(result + 8));
    while (1)
    {
      v21 = __ldaxr(v19);
      if (v21 != v20)
        break;
      if (__stlxr(v20 | 2, v19))
        goto LABEL_18;
      v22 = 1;
LABEL_19:
      v20 = v21;
      if (v22)
      {
        v23 = atomic_load(v19);
        while (1)
        {
          v24 = __ldaxr(v19);
          if (v24 != v23)
            break;
          if (__stlxr(v23 | 4, v19))
            goto LABEL_25;
          v25 = 1;
LABEL_26:
          v23 = v24;
          if (v25)
            return result;
        }
        __clrex();
LABEL_25:
        v25 = 0;
        goto LABEL_26;
      }
    }
    __clrex();
LABEL_18:
    v22 = 0;
    goto LABEL_19;
  }
  v10 = v9;
  v11 = _CFOSLog();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    _CFMachPortCreateReply_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
  return 0;
}

void _outputStreamCallbackFunc(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;

  v5 = (id)objc_msgSend(a3, "retainedDelegate");
  if ((objc_opt_respondsToSelector() & 1) != 0)
    objc_msgSend(v5, "stream:handleEvent:", a1, a2);

}

Boolean CFRunLoopIsWaiting(CFRunLoopRef rl)
{
  unint64_t v2;
  unsigned int v3;

  v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v3 = atomic_load((unint64_t *)rl + 1);
  return (v3 >> 1) & 1;
}

void _inputStreamCallbackFunc(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;

  v5 = (id)objc_msgSend(a3, "retainedDelegate");
  if ((objc_opt_respondsToSelector() & 1) != 0)
    objc_msgSend(v5, "stream:handleEvent:", a1, a2);

}

uint64_t __CFGetNextSearchPathEnumeration(uint64_t a1, char *a2, int64_t a3)
{
  unsigned int v5;
  char __source[1024];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a3 > 1023)
  {
    return MEMORY[0x186DB0B7C](a1, a2);
  }
  else
  {
    v5 = MEMORY[0x186DB0B7C](a1, __source);
    strlcpy(a2, __source, a3);
  }
  return v5;
}

void CFMergeSortArray(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  _QWORD *v39;
  const char *v40;
  uint64_t v41;
  _QWORD v42[9];

  v42[8] = *MEMORY[0x1E0C80C00];
  if (a2 < 2 || a3 < 1)
    return;
  if ((unsigned __int128)(a2 * (__int128)a3) >> 64 != (a2 * a3) >> 63)
  {
    v17 = CFLog(3, (uint64_t)CFSTR("Unable to mergesort array - count: %ld elementSize: %ld overflows"), a3, a4, a5, a6, a7, a8, a2);
    v39 = (_QWORD *)&unk_1EDCD1000;
    v40 = "merge sort - count/elementSize overflow";
LABEL_23:
    v39[7] = v40;
    __break(1u);
    goto LABEL_24;
  }
  v11 = a3 * a2;
  if (__CFADD__(a1, a3 * a2))
  {
    v17 = CFLog(3, (uint64_t)CFSTR("Unable to mergesort array - list: %lu count: %ld elementSize: %ld - array access overflows"), a3, a4, a5, a6, a7, a8, (__int16)a1);
    v39 = (_QWORD *)&unk_1EDCD1000;
    v40 = "merge sort - array access overflow";
    goto LABEL_23;
  }
  MEMORY[0x1E0C80A78](a1, a2);
  v15 = (char *)&v42[-1] - v14;
  v16 = (char *)&v42[-1] - v14;
  if ((unint64_t)a2 > 0x1000)
  {
    v17 = (uint64_t)malloc_type_malloc(8 * a2, 0x100004000313F17uLL);
    v16 = (char *)v17;
    if (!v17)
LABEL_24:
      CFMergeSortArray_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
  }
  v42[0] = MEMORY[0x1E0C809B0];
  v42[1] = 0x40000000;
  v42[2] = __CFMergeSortArray_block_invoke;
  v42[3] = &__block_descriptor_tmp_25;
  v42[4] = a4;
  v42[5] = a1;
  v42[6] = a3;
  v42[7] = a5;
  CFSortIndexes((uint64_t)v16, a2, 16, (uint64_t)v42);
  MEMORY[0x1E0C80A78](v25, v26);
  v34 = (char *)&v42[-1] - v33;
  v35 = (char *)&v42[-1] - v33;
  if (v36 < a2)
    v35 = (char *)malloc_type_malloc(a3 * a2, 0x973A3909uLL);
  v41 = (uint64_t)&v41;
  if (__CFADD__(v35, v11))
  {
    v17 = CFLog(3, (uint64_t)CFSTR("Unable to mergesort array - list: %lu count: %ld elementSize: %ld - array store overflows"), v27, v28, v29, v30, v31, v32, (__int16)a1);
    v39 = &unk_1EDCD1000;
    v40 = "merge sort - overflow array storage";
    goto LABEL_23;
  }
  v37 = 0;
  v38 = v35;
  do
  {
    if (a3 == 8)
      *(_QWORD *)&v35[8 * v37] = a1[*(_QWORD *)&v16[8 * v37]];
    else
      memmove(v38, (char *)a1 + *(_QWORD *)&v16[8 * v37] * a3, a3);
    ++v37;
    v38 += a3;
  }
  while (a2 != v37);
  memmove(a1, v35, a3 * a2);
  if (v34 != v35)
    free(v35);
  if (v15 != v16)
    free(v16);
}

void CFXNotificationRegistrarRemoveRemoteToken(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  const __CFDictionary *v5;
  void *value;
  _OWORD v7[3];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  memset(v7, 0, sizeof(v7));
  v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  v5 = *(const __CFDictionary **)(a1 + 88);
  if (v5)
  {
    value = 0;
    if (CFDictionaryGetValueIfPresent(v5, a2, (const void **)&value))
    {
      if (*(_DWORD *)(a1 + 156) > value
        && *(_DWORD *)(*(_QWORD *)(a1 + 144) + 56 * value + 40) == HIDWORD(value))
      {
        _CFXNotificationRegistrarInvalidateObserver(a1, value, -1, -1, (unsigned int *)v7);
      }
    }
  }
  os_unfair_lock_unlock(v4);
  _CFXNotificationDisposalListRelease((unsigned int *)v7);
}

unint64_t *_CFXNotificationRemoveObservers(unint64_t *result, const __CFString *a2, const __CFString *a3, uint64_t a4)
{
  unint64_t *v7;
  unint64_t *v8;
  char v9;
  void *v10;
  char v11;
  const __CFString *v12;

  if (a2 && a3 && a4)
  {
    v7 = result;
    v8 = result + 1;
    v9 = atomic_load(result + 1);
    if ((v9 & 2) == 0 || (__CFIsDistNoteDaemon & 1) == 0)
    {
      v10 = (void *)_CFAutoreleasePoolPush();
      v11 = atomic_load(v8);
      if ((v11 & 1) != 0)
        v12 = CFSTR("kCFNotificationAnyObject");
      else
        v12 = a3;
      CFXNotificationRegistrarRemove(v7[2], a2, v12, a4);
      return (unint64_t *)_CFAutoreleasePoolPop(v10);
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

void CFXNotificationRegistrarRemove(uint64_t a1, const __CFString *cf1, const __CFString *a3, uint64_t a4)
{
  unsigned int v7;
  const __CFString *v8;
  __CFString *v9;
  int v10;
  CFHashCode v11;
  unint64_t v12;

  v7 = *(unsigned __int8 *)(a1 + 24);
  v8 = CFSTR("kCFNotificationAnyName");
  if (cf1)
  {
    v9 = (__CFString *)cf1;
    if (CFSTR("kCFNotificationAnyName") == cf1)
    {
      v8 = cf1;
    }
    else if (CFEqual(cf1, CFSTR("kCFNotificationAnyName")))
    {
      v9 = CFSTR("kCFNotificationAnyName");
    }
  }
  else
  {
    v9 = CFSTR("kCFNotificationAnyName");
  }
  v10 = (v7 >> 1) & 1;
  if (a3)
  {
    if (!v10)
    {
      v11 = CFHash(v9);
LABEL_12:
      v12 = ((unint64_t)a3 >> 5) & 0x7F;
      goto LABEL_18;
    }
    if (CFSTR("kCFNotificationAnyObject") != a3 && CFEqual(a3, CFSTR("kCFNotificationAnyObject")))
      a3 = CFSTR("kCFNotificationAnyObject");
    v11 = CFHash(v9);
  }
  else
  {
    a3 = CFSTR("kCFNotificationAnyObject");
    v11 = CFHash(v9);
    if (!v10)
      goto LABEL_12;
  }
  v12 = CFHash(a3);
LABEL_18:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationRegistrarRemoveNames(a1, a1 + 32, 0, v9, v11, a3, v12, v10, a4);
  if (v9 == v8)
  {
    _CFXNotificationRegistrarRemoveObjects(a1, a1 + 48, a3, v12, v10, a4);
    if (a3 == CFSTR("kCFNotificationAnyObject"))
    {
      _CFXNotificationRegistrarRemoveNames(a1, a1 + 64, 1, v9, v11, a3, v12, v10, a4);
      _CFXNotificationRegistrarRemoveObservers(a1, (unsigned int *)(a1 + 80), a4);
    }
  }
  else if (a3 == CFSTR("kCFNotificationAnyObject"))
  {
    _CFXNotificationRegistrarRemoveNames(a1, a1 + 64, 1, v9, v11, a3, v12, v10, a4);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
  unint64_t v8;
  char v9;
  char v10;
  const __CFString *v11;
  char v12;
  const __CFString *v13;
  const void *v14;
  CFTypeID TypeID;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFTypeID v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int16 v29;

  v8 = _CFGetNonObjCTypeID((unint64_t *)center);
  if (v8 != 52)
    _CFAssertMismatchedTypeID(0x34uLL, v8);
  v9 = atomic_load((unint64_t *)center + 1);
  if ((v9 & 2) == 0)
  {
LABEL_3:
    v10 = atomic_load((unint64_t *)center + 1);
    if (observer || (v10 & 1) == 0)
    {
      if (name)
        v11 = name;
      else
        v11 = CFSTR("kCFNotificationAnyName");
      v12 = atomic_load((unint64_t *)center + 1);
      if ((object == 0) | v12 & 1)
        v13 = CFSTR("kCFNotificationAnyObject");
      else
        v13 = (const __CFString *)object;
      if (observer)
        v14 = observer;
      else
        v14 = (const void *)kCFXNotificationPlaceholderObserver;
      _CFXNotificationRemoveObservers((unint64_t *)center, v11, v13, (uint64_t)v14);
    }
    return;
  }
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (name)
    {
      TypeID = CFStringGetTypeID();
      if (TypeID != CFGetTypeID(name))
      {
        CFLog(4, (uint64_t)CFSTR("*** Attempt to unregister for a distributed notification with a non-string name ignored."), v16, v17, v18, v19, v20, v21, v29);
        return;
      }
    }
    if (object)
    {
      v22 = CFStringGetTypeID();
      if (v22 != CFGetTypeID(object))
      {
        CFLog(4, (uint64_t)CFSTR("*** Attempt to unregister for a distributed notification (%@) with a non-string object ignored."), v23, v24, v25, v26, v27, v28, (__int16)name);
        return;
      }
    }
    goto LABEL_3;
  }
}

void _CFXNotificationRegistrarRecycleNameRegistration(uint64_t a1, uint64_t *a2, unsigned int a3, int a4)
{
  uint64_t v8;
  uint64_t v10;
  unint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  const void **v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  unsigned int v23;
  _DWORD *v24;

  v8 = *(_QWORD *)(a1 + 96);
  if (a3 != -1)
  {
    v10 = *a2;
    if (*a2)
    {
      v11 = *(_QWORD *)(v8 + 40 * a3 + 16) % (unint64_t)*((unsigned int *)a2 + 2);
      v12 = (unsigned int *)(v8 + 40 * a3);
      v13 = *v12;
      v14 = v12[1];
      if (*(_DWORD *)(v10 + 4 * v11) == a3)
        *(_DWORD *)(v10 + 4 * v11) = v14;
      if (v13 != -1)
        *(_DWORD *)(v8 + 40 * v13 + 4) = v14;
      if (v14 != -1)
        *(_DWORD *)(v8 + 40 * v14) = v13;
    }
  }
  v15 = v8 + 40 * a3;
  v17 = *(_QWORD *)(v15 + 8);
  v16 = (const void **)(v15 + 8);
  if (v17)
    _CFXNotificationRegistrarRemoveCachedName(v16);
  if (!a4)
  {
    v18 = v8 + 40 * a3;
    v21 = *(void **)(v18 + 24);
    v20 = (_QWORD *)(v18 + 24);
    v19 = v21;
    if (v21)
    {
      free(v19);
      *v20 = 0;
    }
  }
  --*((_DWORD *)a2 + 3);
  if (a3 != -1)
  {
    v22 = *(_QWORD *)(a1 + 96);
    v23 = *(_DWORD *)(a1 + 112);
    if (v23 != -1)
      *(_DWORD *)(v22 + 40 * v23) = a3;
    v24 = (_DWORD *)(v22 + 40 * a3);
    *v24 = -1;
    v24[1] = v23;
    *(_DWORD *)(a1 + 112) = a3;
  }
  --*(_DWORD *)(a1 + 104);
}

void _CFXNotificationRegistrarRemoveCachedName(const void **a1)
{
  __CFDictionary *NamePool;

  os_unfair_lock_lock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  NamePool = _CFXNotificationRegistrarGetNamePool();
  if (CFDictionaryGetValue(NamePool, *a1) == (const void *)1)
    CFDictionaryRemoveValue(NamePool, *a1);
  *a1 = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) != 0)
    return 0;
  if (CFNotificationCenterGetDarwinNotifyCenter_static_init != -1)
    dispatch_once(&CFNotificationCenterGetDarwinNotifyCenter_static_init, &__block_literal_global_11);
  return (CFNotificationCenterRef)__darwinCenter;
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
  __int16 v6;
  unint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  char v15;
  __CFString *v16;
  __CFString *v17;

  v6 = suspensionBehavior;
  v12 = _CFGetNonObjCTypeID((unint64_t *)center);
  if (v12 != 52)
    _CFAssertMismatchedTypeID(0x34uLL, v12);
  v13 = 2;
  switch(v6 & 0xF)
  {
    case 1:
      goto LABEL_11;
    case 2:
      v13 = 4;
      if ((v6 & 0x400) == 0)
        goto LABEL_13;
      goto LABEL_12;
    case 3:
      v13 = 8;
LABEL_11:
      if ((v6 & 0x400) != 0)
        goto LABEL_12;
      goto LABEL_13;
    case 4:
      v13 = 1;
      if ((v6 & 0x400) == 0)
        goto LABEL_13;
      goto LABEL_12;
    default:
      if ((v6 & 0xF) == 0xELL)
        v13 = 65537;
      else
        v13 = 4;
      if ((v6 & 0x400) == 0)
        goto LABEL_13;
LABEL_12:
      v13 |= 0x400uLL;
      objc_opt_self();
LABEL_13:
      if (name)
        v14 = name;
      else
        v14 = CFSTR("kCFNotificationAnyName");
      v15 = atomic_load((unint64_t *)center + 1);
      if ((object == 0) | v15 & 1)
        v16 = CFSTR("kCFNotificationAnyObject");
      else
        v16 = (__CFString *)object;
      if (observer)
        v17 = (__CFString *)observer;
      else
        v17 = (__CFString *)kCFXNotificationPlaceholderObserver;
      _CFXNotificationRegisterObserver((CFIndex)center, v14, v16, v13 | 0x80000, v17, callBack, 0);
      return;
  }
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  if (CFNotificationCenterGetLocalCenter_static_init != -1)
    dispatch_once(&CFNotificationCenterGetLocalCenter_static_init, &__block_literal_global_7);
  return (CFNotificationCenterRef)__taskCenter;
}

void __initDayChangedNotification()
{
  if (__initDayChangedNotification_onceToken != -1)
    dispatch_once(&__initDayChangedNotification_onceToken, &__block_literal_global_31);
}

CFTimeInterval CFDateGetTimeIntervalSinceDate(CFDateRef theDate, CFDateRef otherDate)
{
  CFTimeInterval result;

  -[__CFDate timeIntervalSinceDate:](theDate, "timeIntervalSinceDate:", otherDate);
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  uint64_t length;
  CFIndex location;
  uint64_t v12;
  unint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  _BYTE *v18;
  _BYTE *v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 *v24;
  __int128 *v25;
  char v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __CFString *v36;
  CFStringRef Copy;
  CFIndex v38;
  int v39;
  _BOOL4 v40;
  unsigned int v41;
  uint64_t v42;
  char v43;
  char v44;
  uint64_t v45;
  char **p_data;
  char **v47;
  char *v48;
  uint64_t v49;
  char *v50;
  unint64_t v51;
  UInt8 *v52;
  CFStringEncoding v53;
  unint64_t v54;
  char *v55;
  unint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  UniChar *v60;
  unint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  CFStringRef v64;
  CFStringCompareFlags v65;
  CFStringRef theStringa;
  __int128 v67;
  CFRange result;
  _BYTE __src[992];
  uint64_t v70;
  CFRange v71;
  CFRange v72;
  CFRange v73;

  length = rangeToSearch.length;
  location = rangeToSearch.location;
  v70 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    return -[__CFString replaceOccurrencesOfString:withString:options:range:](theString, "replaceOccurrencesOfString:withString:options:range:", stringToFind, replacementString, compareOptions, location, length);
  result.location = 0;
  result.length = 0;
  if (length < 1)
    return 0;
  theStringa = theString;
  v64 = replacementString;
  v12 = 0;
  v13 = 0;
  v14 = compareOptions;
  v15 = (location + length);
  v65 = compareOptions;
  v16 = 62;
  v17 = __src;
  while (1)
  {
    v73.location = location;
    v73.length = length;
    if (!CFStringFindWithOptionsAndLocale(theStringa, stringToFind, v73, compareOptions, 0, &result))
      break;
    if (((v14 >> 2) & 1) != 0)
    {
      length = result.location - location;
    }
    else
    {
      location = result.length + result.location;
      length = v15 - (result.length + result.location);
    }
    if ((uint64_t)v13 >= v16)
    {
      v16 = 2 * v16 + 8;
      if (v17 == __src)
        v18 = 0;
      else
        v18 = v17;
      v19 = (_BYTE *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, v18, 16 * v16, 0x1000040451B5BE8, 0, 0);
      v20 = v17 == __src;
      v17 = v19;
      if (v20)
        memmove(v19, __src, 0x3E0uLL);
      compareOptions = v65;
    }
    *(CFRange *)&v17[v12] = result;
    ++v13;
    v12 += 16;
    if (length <= 0)
      goto LABEL_20;
  }
  if (!v12)
    return 0;
LABEL_20:
  if ((v14 & 4) != 0)
  {
    v21 = (v13 - 1);
    if ((int)v21 >= 1)
    {
      v22 = 0;
      v23 = v21 - 1;
      v24 = (__int128 *)v17;
      v25 = (__int128 *)&v17[16 * v21];
      do
      {
        v67 = *v24;
        *v24++ = *v25;
        *v25-- = v67;
      }
      while (++v22 < v23--);
    }
  }
  v27 = atomic_load((unint64_t *)&theStringa->info);
  if ((v27 & 1) != 0)
  {
    v36 = (__CFString *)v64;
    if (v64 == theStringa)
    {
      Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theStringa);
      v36 = (__CFString *)Copy;
    }
    else
    {
      Copy = 0;
    }
    v38 = CFStringGetLength(v36);
    if (v38 < 1)
    {
      v40 = 0;
    }
    else
    {
      if (CF_IS_OBJC(7uLL, (__objc2_class **)v36))
      {
        v39 = -[__CFString _encodingCantBeStoredInEightBitCFString](v36, "_encodingCantBeStoredInEightBitCFString");
      }
      else
      {
        v41 = atomic_load((unint64_t *)&v36->info);
        v39 = (v41 >> 4) & 1;
      }
      v40 = v39 != 0;
    }
    v42 = __CFStringChangeSizeMultiple((uint64_t)theStringa, (uint64_t)v17, v13, v38, v40);
    v43 = atomic_load((unint64_t *)&theStringa->info);
    v44 = atomic_load((unint64_t *)&theStringa->info);
    v45 = v44 & 0x60;
    p_data = &theStringa->data;
    if ((v43 & 0x10) != 0)
    {
      if (v45)
      {
        v48 = *p_data;
      }
      else
      {
        v59 = atomic_load((unint64_t *)&theStringa->info);
        v48 = (char *)&p_data[(v59 & 5) != 4];
      }
      v60 = (UniChar *)&v48[2 * *(_QWORD *)v17];
      v72.location = 0;
      v72.length = v38;
      CFStringGetCharacters(v36, v72, v60);
      if (v13 >= 2)
      {
        v61 = v13 - 1;
        v62 = (uint64_t *)(v17 + 16);
        do
        {
          v48 += 2 * (v38 - *(v62 - 1));
          v63 = *v62;
          v62 += 2;
          memmove(&v48[2 * v63], v60, 2 * v38);
          --v61;
        }
        while (v61);
      }
    }
    else
    {
      if (v45)
      {
        v47 = (char **)*p_data;
      }
      else
      {
        v49 = atomic_load((unint64_t *)&theStringa->info);
        v47 = &p_data[(v49 & 5) != 4];
      }
      v50 = (char *)v47 + *(_QWORD *)v17;
      v51 = atomic_load((unint64_t *)&theStringa->info);
      v52 = (UInt8 *)&v50[(v51 >> 2) & 1];
      v53 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding(v42);
        v53 = __CFDefaultEightBitStringEncoding;
      }
      v71.location = 0;
      v71.length = v38;
      CFStringGetBytes(v36, v71, v53, 0, 0, v52, v38, 0);
      v54 = atomic_load((unint64_t *)&theStringa->info);
      if (v13 >= 2)
      {
        v55 = (char *)v47 + ((v54 >> 2) & 1);
        v56 = v13 - 1;
        v57 = (uint64_t *)(v17 + 16);
        do
        {
          v55 += v38 - *(v57 - 1);
          v58 = *v57;
          v57 += 2;
          memmove(&v55[v58], v52, v38);
          --v56;
        }
        while (v56);
      }
    }
    if (Copy)
      CFRelease(Copy);
  }
  else
  {
    v28 = _CFOSLog();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
      CFStringFindAndReplace_cold_1(v28, v29, v30, v31, v32, v33, v34, v35);
  }
  if (v17 != __src)
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17);
  return v13;
}

CFMutableBitVectorRef CFBitVectorCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableBitVectorRef)__CFBitVectorInit((__objc2_class **)allocator, 1, 0, 0);
}

id _CFURLComponentsCreate()
{
  return (id)+[NSURLComponents _components](&off_1EDCDC9E8, "_components");
}

void __CFAllocatorDeallocate(_QWORD *ptr)
{
  const __CFAllocator *v2;
  void (*v3)(uint64_t);
  void (*v4)(_QWORD *, uint64_t);
  uint64_t v5;
  void (*v6)(uint64_t);

  v2 = (const __CFAllocator *)ptr[16];
  v3 = (void (*)(uint64_t))ptr[20];
  if (v2 == (const __CFAllocator *)939)
  {
    v4 = (void (*)(_QWORD *, uint64_t))ptr[24];
    v5 = ptr[18];
    if (v4)
    {
      v6 = (void (*)(uint64_t))ptr[20];
      v4(ptr, v5);
      v3 = v6;
    }
    if (v3)
      v3(v5);
  }
  else
  {
    if (v3)
      v3(ptr[18]);
    CFAllocatorDeallocate(v2, ptr);
  }
}

CFStringRef _CFErrorCreateLocalizedDescription(_QWORD *a1)
{
  char v2;
  char v3;
  uint64_t (*v4)(_QWORD *, const __CFString *);
  const void *v5;
  uint64_t v6;
  __CFBundle *v7;
  const void *v8;
  const void *v9;
  const __CFString *v10;
  CFStringRef v11;
  const __CFString *v12;
  const void *v13;
  const void *v14;
  __CFBundle *BundleWithIdentifier;
  const __CFString *v16;
  CFStringRef v17;
  CFStringRef v18;
  const __CFString *v19;
  const __CFString *v20;
  int v21;
  uint64_t v22;
  const __CFString *v23;
  const __CFString *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;

  v2 = 1;
  do
  {
    v3 = v2;
    if ((v2 & 1) != 0)
    {
      v4 = (uint64_t (*)(_QWORD *, const __CFString *))_CFErrorCopyUserInfoKeyFromUserInfo;
      v5 = _CFErrorCopyUserInfoKeyFromUserInfo(a1, CFSTR("NSLocalizedDescription"));
    }
    else
    {
      v4 = (uint64_t (*)(_QWORD *, const __CFString *))_CFErrorCopyUserInfoKeyFromCallBack;
      v5 = _CFErrorCopyUserInfoKeyFromCallBack(a1, (uint64_t)CFSTR("NSLocalizedDescription"));
    }
    if (v5)
      return (CFStringRef)v5;
    v6 = v4(a1, CFSTR("NSLocalizedFailure"));
    if (v6)
    {
      v11 = (CFStringRef)v6;
      v13 = _CFErrorCopyUserInfoKey(a1, CFSTR("NSLocalizedFailureReason"));
      if (v13)
      {
        v14 = v13;
        BundleWithIdentifier = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.CoreFoundation"));
        if (!BundleWithIdentifier
          || (v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("%@ %@"), CFSTR("%@ %@"), CFSTR("Error")),
              v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v16, v11, v14),
              CFRelease(v16),
              !v17))
        {
          v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@ %@"), v11, v14);
        }
        CFRelease(v11);
        CFRelease(v14);
        return v17;
      }
      return v11;
    }
    v2 = 0;
  }
  while ((v3 & 1) != 0);
  v7 = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.CoreFoundation"));
  v8 = _CFErrorCopyUserInfoKey(a1, CFSTR("NSLocalizedFailureReason"));
  v9 = v8;
  if (v7)
  {
    if (v8)
    {
      v10 = CFBundleCopyLocalizedString(v7, CFSTR("The operation couldn\\U2019t be completed. %@"), CFSTR("The operation couldn\\U2019t be completed. %@"), CFSTR("Error"));
      v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v10, v9);
      v12 = v10;
    }
    else
    {
      v19 = (const __CFString *)_CFErrorCopyUserInfoKey(a1, CFSTR("NSDescription"));
      if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
        v20 = (const __CFString *)objc_msgSend(a1, "domain");
      else
        v20 = (const __CFString *)a1[3];
      if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
        v23 = (const __CFString *)objc_msgSend(a1, "domain");
      else
        v23 = (const __CFString *)a1[3];
      v9 = CFBundleCopyLocalizedString(v7, v20, v23, CFSTR("Error"));
      if (v19)
      {
        v24 = CFBundleCopyLocalizedString(v7, CFSTR("The operation couldn\\U2019t be completed. (%@ error %ld - %@)"), CFSTR("The operation couldn\\U2019t be completed. (%@ error %ld - %@)"), CFSTR("Error"));
        if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
          v25 = objc_msgSend(a1, "code");
        else
          v25 = a1[2];
        v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v24, v9, v25, v19);
        CFRelease(v24);
      }
      else
      {
        v19 = CFBundleCopyLocalizedString(v7, CFSTR("The operation couldn\\U2019t be completed. (%@ error %ld.)"), CFSTR("The operation couldn\\U2019t be completed. (%@ error %ld.)"), CFSTR("Error"));
        if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
          v26 = objc_msgSend(a1, "code");
        else
          v26 = a1[2];
        v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v19, v9, v26);
      }
      v12 = v19;
    }
    CFRelease(v12);
LABEL_48:
    CFRelease(v9);
    return v11;
  }
  if (v8)
  {
    v18 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("The operation couldn\\U2019t be completed. %@"), v8);
LABEL_47:
    v11 = v18;
    goto LABEL_48;
  }
  v9 = _CFErrorCopyUserInfoKey(a1, CFSTR("NSDescription"));
  v21 = CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1);
  if (v9)
  {
    if (v21)
      v22 = objc_msgSend(a1, "domain");
    else
      v22 = a1[3];
    if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
      v28 = objc_msgSend(a1, "code");
    else
      v28 = a1[2];
    v18 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("The operation couldn\\U2019t be completed. (%@ error %ld - %@)"), v22, v28, v9);
    goto LABEL_47;
  }
  if (v21)
    v27 = objc_msgSend(a1, "domain");
  else
    v27 = a1[3];
  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
    v30 = objc_msgSend(a1, "code");
  else
    v30 = a1[2];
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("The operation couldn\\U2019t be completed. (%@ error %ld.)"), v27, v30);
}

CFStringRef CFBundleCopyLocalizedString(CFBundleRef bundle, CFStringRef key, CFStringRef value, CFStringRef tableName)
{
  return _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption((unint64_t *)bundle, (void *)key, (void *)value, (__CFString *)tableName, 0, 0, 0);
}

CFBundleRef CFBundleGetBundleWithIdentifier(CFStringRef bundleID)
{
  uint64_t v1;

  return _CFBundleGetBundleWithIdentifier((__CFString *)bundleID, v1);
}

CFStringRef CFBundleCopyLocalizationForLocalizationInfo(unsigned int a1, unsigned int a2, int a3, int a4)
{
  CFStringRef result;
  unint64_t v8;
  unsigned int v9;
  BOOL v10;
  unint64_t v11;
  int v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  unsigned int v18;

  result = _CFBundleCopyLocaleAbbreviationForRegionCode(a2);
  if (!result)
  {
    result = _CFBundleCopyLanguageAbbreviationForLanguageCode(a1);
    if (!result)
    {
      v8 = 0;
      do
      {
        if (__CFBundleScriptCodesArray[v8] == a3)
        {
          if (__CFBundleStringEncodingsArray[v8] == a4)
            v9 = v8;
          else
            v9 = -1;
        }
        else
        {
          v9 = -1;
        }
        if (v9 != -1)
          break;
        v10 = v8++ >= 0x97;
      }
      while (!v10);
      v11 = 0;
      do
      {
        v12 = __CFBundleScriptCodesArray[v11];
        v13 = v11 + 1;
        if (v12 == a3)
          break;
        v10 = v11++ >= 0x97;
      }
      while (!v10);
      v14 = 0;
      if (v12 == a3)
        v15 = v13 - 1;
      else
        v15 = -1;
      do
      {
        v16 = __CFBundleStringEncodingsArray[v14];
        v17 = v14 + 1;
        if (v16 == a4)
          break;
        v10 = v14++ >= 0x97;
      }
      while (!v10);
      result = _CFBundleCopyLanguageAbbreviationForLanguageCode(v9);
      if (!result)
      {
        if (v16 == a4)
          v18 = v17 - 1;
        else
          v18 = -1;
        result = _CFBundleCopyLanguageAbbreviationForLanguageCode(v18);
        if (!result)
          return _CFBundleCopyLanguageAbbreviationForLanguageCode(v15);
      }
    }
  }
  return result;
}

CFStringRef _CFBundleCopyLocaleAbbreviationForRegionCode(unsigned int a1)
{
  const char *v1;

  if (a1 <= 0x6C
    && __CFBundleLocaleAbbreviationsArray
    && (v1 = (const char *)(__CFBundleLocaleAbbreviationsArray + 6 * a1), *v1))
  {
    return CFStringCreateWithCStringNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull);
  }
  else
  {
    return 0;
  }
}

void sub_182B47A30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182B47DFC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v2 - 168) = v1;
  free(*(void **)(v2 - 168));
  _Unwind_Resume(a1);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  uint64_t v5;
  size_t v8;

  v5 = *(_QWORD *)&encoding;
  v8 = strlen(cStr);
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)cStr, v8, v5, 0x18u, contentsDeallocator, 0);
}

void log_client_activity(void *a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  __int128 *data;
  __int128 v8;
  void *value;
  uint64_t v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  _BOOL4 v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  size_t v18;
  __int16 v19;
  __int128 *p_buffer;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int128 buffer;
  int pid[4];
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v6 = _CFPrefsDaemonLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v18 = 0;
    buffer = 0u;
    *(_OWORD *)pid = 0u;
    data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &v18);
    if (data && v18 == 32)
    {
      v8 = data[1];
      buffer = *data;
      *(_OWORD *)pid = v8;
    }
    else
    {
      if (!xpc_dictionary_get_remote_connection(a1))
      {
        value = xpc_dictionary_get_value(a1, "connection");
        if (!value || (value = object_getClass(value), value != (void *)MEMORY[0x1E0C812E0]))
          log_client_activity_cold_1((uint64_t)value, v10, v11);
      }
      xpc_connection_get_audit_token();
    }
    v12 = pid[1];
    v27 = 0u;
    v28 = 0u;
    buffer = 0u;
    *(_OWORD *)pid = 0u;
    if (v12 != -1 && (proc_name(v12, &buffer, 0x40u) & 0x80000000) == 0)
    {
      v13 = _CFPrefsDaemonLog();
      v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
      if (a3)
      {
        if (v14)
        {
          LODWORD(v18) = 67240962;
          HIDWORD(v18) = v12;
          v19 = 2082;
          p_buffer = &buffer;
          v21 = 2082;
          v22 = a2;
          v23 = 2082;
          v24 = a3;
          v15 = "Process %{public}d (%{public}s) %{public}s for domain %{public}s";
          v16 = v13;
          v17 = 38;
LABEL_17:
          _os_log_debug_impl(&dword_182A8C000, v16, OS_LOG_TYPE_DEBUG, v15, (uint8_t *)&v18, v17);
        }
      }
      else if (v14)
      {
        LODWORD(v18) = 67240706;
        HIDWORD(v18) = v12;
        v19 = 2082;
        p_buffer = &buffer;
        v21 = 2082;
        v22 = a2;
        v15 = "Process %{public}d (%{public}s) %{public}s";
        v16 = v13;
        v17 = 28;
        goto LABEL_17;
      }
    }
  }
}

void sub_182B484BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 72), 8);
  _Unwind_Resume(a1);
}

CFMachPortRef CFMachPortCreate(CFAllocatorRef allocator, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMachPortRef)_CFMachPortCreate4((__objc2_class **)allocator, (uint64_t)callout, (__int128 *)&context->version, shouldFreeInfo, 1);
}

void CFBundleGetPackageInfo(CFBundleRef bundle, UInt32 *packageType, UInt32 *packageCreator)
{
  const __CFURL *v6;
  const __CFDictionary *InfoDictionary;

  v6 = CFBundleCopyBundleURL(bundle);
  InfoDictionary = CFBundleGetInfoDictionary(bundle);
  if (!_CFBundleGetPackageInfoInDirectoryWithInfoDictionary(v6, InfoDictionary, (int *)packageType, packageCreator))
  {
    if (packageType)
      *packageType = 1112425548;
    if (packageCreator)
      *packageCreator = 1061109567;
  }
  if (v6)
    CFRelease(v6);
}

__CFArray *_CFBundleCopyLanguageSearchListInDirectory(const __CFURL *a1, unsigned __int8 *a2)
{
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  __CFString *Value;
  __CFString *v7;
  CFTypeID v8;
  const void *v9;
  const void *v10;
  CFTypeID v11;
  const __CFURL *v12;
  const __CFArray *v13;
  __CFArray *MutableCopy;
  const __CFArray *v15;
  __CFArray *v16;
  unsigned __int8 v18;
  uint64_t v19;
  CFRange v20;
  CFRange v21;

  v19 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  v4 = _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, a1, &v18);
  v5 = v4;
  if (!v4)
  {
    v7 = 0;
    v10 = 0;
    goto LABEL_11;
  }
  Value = (__CFString *)CFDictionaryGetValue(v4, CFSTR("CFBundleDevelopmentRegion"));
  v7 = Value;
  if (Value)
  {
    v8 = CFGetTypeID(Value);
    if (v8 != CFStringGetTypeID() || !CFStringGetLength(v7))
      v7 = 0;
  }
  v9 = CFDictionaryGetValue(v5, CFSTR("CFBundleLocalizations"));
  if (!v9)
    goto LABEL_9;
  v10 = v9;
  CFRetain(v9);
  v11 = CFGetTypeID(v10);
  if (v11 != CFArrayGetTypeID())
  {
    CFRelease(v10);
LABEL_9:
    v10 = (const void *)_copyAppleLocalizations(v5);
  }
LABEL_11:
  v12 = _CFBundleCopyResourcesDirectoryURLInDirectory(a1, v18);
  v13 = (const __CFArray *)_CFBundleCopyLProjDirectoriesForURL((uint64_t)&__kCFAllocatorSystemDefault, v12);
  CFRelease(v12);
  if (v10 && v13)
  {
    MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (CFArrayRef)v10);
    v21.length = CFArrayGetCount(v13);
    v21.location = 0;
    CFArrayAppendArray(MutableCopy, v13, v21);
    CFRelease(v13);
    v13 = MutableCopy;
LABEL_16:
    CFRelease(v10);
    goto LABEL_17;
  }
  if (v10)
  {
    v13 = (const __CFArray *)CFRetain(v10);
    goto LABEL_16;
  }
  if (!v13)
    v13 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeArrayCallBacks);
LABEL_17:
  v15 = (const __CFArray *)_CFBundleCopyUserLanguages();
  v16 = _CFBundleCopyPreferredLanguagesInList(v13, v7, v15, 1, (unint64_t)a1, 0);
  if (v15)
    CFRelease(v15);
  CFRelease(v13);
  if (v7)
  {
    v20.length = CFArrayGetCount(v16);
    v20.location = 0;
    if (CFArrayGetFirstIndexOfValue(v16, v20, v7) < 0)
      CFArrayAppendValue(v16, v7);
  }
  if (!CFArrayGetCount(v16))
    CFArrayAppendValue(v16, CFSTR("en"));
  if (v5)
    CFRelease(v5);
  if (a2)
    *a2 = v18;
  return v16;
}

uint64_t _CFBundleGetPackageInfoInDirectoryWithInfoDictionary(CFURLRef baseURL, const __CFDictionary *a2, int *a3, _DWORD *a4)
{
  const __CFURL *v8;
  const __CFData *v9;
  const __CFURL *v10;
  const __CFURL *v11;
  unsigned int *BytePtr;
  int v13;
  uint64_t v14;
  uint64_t v15;
  const __CFDictionary *v16;
  const __CFString *Value;
  const __CFString *v18;
  CFTypeID v19;
  CFTypeID v20;
  BOOL v21;
  char v22;
  const __CFURL *v23;
  const __CFString *v24;
  CFIndex Length;
  CFIndex v26;
  uint64_t v27;
  CFIndex v28;
  unint64_t v29;
  char *v30;
  int v31;
  int v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  UInt8 buffer[4];
  CFDataRef resourceData;
  CFIndex usedBufLen[258];
  CFRange v48;
  CFRange v49;
  CFRange v50;

  usedBufLen[257] = *MEMORY[0x1E0C80C00];
  resourceData = 0;
  v8 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("Contents/PkgInfo"), baseURL);
  CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v8, &resourceData, 0, 0, 0);
  CFRelease(v8);
  v9 = resourceData;
  if (!resourceData)
  {
    v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("Support%20Files/PkgInfo"), baseURL);
    CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10, &resourceData, 0, 0, 0);
    CFRelease(v10);
    v9 = resourceData;
    if (!resourceData)
    {
      v11 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("PkgInfo"), baseURL);
      CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v11, &resourceData, 0, 0, 0);
      CFRelease(v11);
      v9 = resourceData;
      if (!resourceData)
        goto LABEL_14;
    }
  }
  if (CFDataGetLength(v9) < 8)
  {
    if (resourceData)
      CFRelease(resourceData);
LABEL_14:
    v16 = a2;
    if (!a2)
    {
      v16 = _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, baseURL, 0);
      if (!v16)
      {
        v21 = 0;
        goto LABEL_42;
      }
    }
    Value = (const __CFString *)CFDictionaryGetValue(v16, CFSTR("CFBundlePackageType"));
    v18 = (const __CFString *)CFDictionaryGetValue(v16, CFSTR("CFBundleSignature"));
    *(_DWORD *)buffer = 0;
    usedBufLen[0] = 0;
    if (Value && (v19 = CFGetTypeID(Value), v19 == CFStringGetTypeID()) && CFStringGetLength(Value) == 4)
    {
      v48.location = 0;
      v48.length = 4;
      v14 = 0;
      if (CFStringGetBytes(Value, v48, 0, 0, 0, buffer, 4, usedBufLen) == 4 && usedBufLen[0] == 4)
      {
        if (a3)
          *a3 = bswap32(*(unsigned int *)buffer);
        v14 = 1;
      }
    }
    else
    {
      v14 = 0;
    }
    if (v18 && (v20 = CFGetTypeID(v18), v20 == CFStringGetTypeID()) && CFStringGetLength(v18) == 4)
    {
      v49.location = 0;
      v49.length = 4;
      v13 = 0;
      if (CFStringGetBytes(v18, v49, 0, 0, 0, buffer, 4, usedBufLen) == 4)
      {
        v15 = v14;
        if (usedBufLen[0] == 4)
        {
          if (a4)
            *a4 = bswap32(*(unsigned int *)buffer);
          v13 = 1;
          v15 = 1;
        }
        goto LABEL_35;
      }
    }
    else
    {
      v13 = 0;
    }
    v15 = v14;
LABEL_35:
    if (!a2)
      CFRelease(v16);
    goto LABEL_37;
  }
  BytePtr = (unsigned int *)CFDataGetBytePtr(resourceData);
  if (a3)
    *a3 = bswap32(*BytePtr);
  if (a4)
    *a4 = bswap32(BytePtr[1]);
  if (resourceData)
    CFRelease(resourceData);
  v13 = 1;
  LODWORD(v14) = 1;
  v15 = 1;
LABEL_37:
  v21 = (_DWORD)v14 != 0;
  LOBYTE(v16) = v13 != 0;
  if (v13 && (_DWORD)v14)
    return v15;
  if ((_DWORD)v15)
  {
LABEL_43:
    if (a4 && (v16 & 1) == 0)
      *a4 = 1061109567;
    if (a3)
      v22 = v21;
    else
      v22 = 1;
    if ((v22 & 1) != 0)
      return 1;
    v23 = CFURLCopyAbsoluteURL(baseURL);
    v24 = CFURLCopyFileSystemPath(v23, kCFURLPOSIXPathStyle);
    CFRelease(v23);
    if (!v24)
      goto LABEL_107;
    Length = CFStringGetLength(v24);
    if (Length >= 1026)
      v26 = 1026;
    else
      v26 = Length;
    v50.location = 0;
    v50.length = v26;
    CFStringGetCharacters(v24, v50, (UniChar *)usedBufLen);
    CFRelease(v24);
    v27 = _CFStartOfPathExtension(usedBufLen, v26);
    v28 = v26 - v27;
    v29 = (v26 - v27) & 0xFFFFFFFFFFFFFFFELL;
    switch(v29)
    {
      case 4uLL:
        if (*((_WORD *)usedBufLen + v27) != 46)
          goto LABEL_107;
        v30 = (char *)usedBufLen + 2 * v27;
        if (*((_WORD *)v30 + 1) != 97 || *((_WORD *)v30 + 2) != 112 || *((_WORD *)usedBufLen + v27 + 3) != 112)
          goto LABEL_107;
        if (v28 == 4)
        {
LABEL_62:
          v32 = 1095782476;
LABEL_108:
          *a3 = v32;
          return 1;
        }
        v31 = *((unsigned __int16 *)&usedBufLen[1] + v27);
        break;
      case 6uLL:
        if (*((_WORD *)usedBufLen + v27) != 46)
          goto LABEL_107;
        if (*((_WORD *)usedBufLen + v27 + 1) != 100)
          goto LABEL_107;
        v33 = (char *)usedBufLen + 2 * v27;
        if (*((_WORD *)v33 + 2) != 101)
          goto LABEL_107;
        if (*((_WORD *)v33 + 3) != 98)
          goto LABEL_107;
        v34 = (char *)usedBufLen + 2 * v27;
        if (*((_WORD *)v34 + 4) != 117 || *((_WORD *)v34 + 5) != 103)
          goto LABEL_107;
        if (v28 == 6)
          goto LABEL_62;
        v31 = *((unsigned __int16 *)&usedBufLen[1] + v27 + 2);
        break;
      case 8uLL:
        if (*((_WORD *)usedBufLen + v27) != 46)
          goto LABEL_107;
        if (*((_WORD *)usedBufLen + v27 + 1) == 112)
        {
          v35 = (char *)usedBufLen + 2 * v27;
          if (*((_WORD *)v35 + 2) == 114 && *((_WORD *)v35 + 3) == 111)
          {
            v36 = (char *)usedBufLen + 2 * v27;
            if (*((_WORD *)v36 + 4) == 102 && *((_WORD *)v36 + 5) == 105)
            {
              v37 = (char *)usedBufLen + 2 * v27;
              if (*((_WORD *)v37 + 6) == 108
                && *((_WORD *)v37 + 7) == 101
                && (v28 == 8 || *((_WORD *)&usedBufLen[2] + v27) == 47))
              {
                goto LABEL_62;
              }
            }
          }
        }
        if (*((_WORD *)usedBufLen + v27 + 1) != 115
          || *((_WORD *)usedBufLen + v27 + 2) != 101
          || (v38 = (char *)usedBufLen + 2 * v27, *((_WORD *)v38 + 3) != 114)
          || *((_WORD *)v38 + 4) != 118
          || (v39 = (char *)usedBufLen + 2 * v27, *((_WORD *)v39 + 5) != 105)
          || *((_WORD *)v39 + 6) != 99
          || *((_WORD *)&usedBufLen[1] + v27 + 3) != 101)
        {
LABEL_107:
          v32 = 1112425548;
          goto LABEL_108;
        }
        if (v28 == 8)
          goto LABEL_62;
        v31 = *((unsigned __int16 *)&usedBufLen[2] + v27);
        break;
      default:
        if (v29 == 10 && *((_WORD *)usedBufLen + v27) == 46 && *((_WORD *)usedBufLen + v27 + 1) == 102)
        {
          v40 = (char *)usedBufLen + 2 * v27;
          if (*((_WORD *)v40 + 2) == 114 && *((_WORD *)v40 + 3) == 97)
          {
            v41 = (char *)usedBufLen + 2 * v27;
            if (*((_WORD *)v41 + 4) == 109 && *((_WORD *)v41 + 5) == 101)
            {
              v42 = (char *)usedBufLen + 2 * v27;
              if (*((_WORD *)v42 + 6) == 119 && *((_WORD *)v42 + 7) == 111)
              {
                v43 = (char *)usedBufLen + 2 * v27;
                if (*((_WORD *)v43 + 8) == 114
                  && *((_WORD *)v43 + 9) == 107
                  && (v28 == 10 || *((_WORD *)&usedBufLen[2] + v27 + 2) == 47))
                {
                  v32 = 1179473739;
                  goto LABEL_108;
                }
              }
            }
          }
        }
        goto LABEL_107;
    }
    if (v31 == 47)
      goto LABEL_62;
    goto LABEL_107;
  }
LABEL_42:
  if (_CFBundleURLLooksLikeBundle(baseURL))
    goto LABEL_43;
  return 0;
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryInDirectory(const __CFAllocator *a1, CFURLRef url, _BYTE *a3)
{
  size_t v6;
  uint64_t v7;
  const __CFURL *v8;
  int BundleVersionForURL;
  char v10;
  CFMutableDictionaryRef v11;
  UInt8 buffer[1026];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026))
  {
    v11 = 0;
    v10 = 0;
    if (!a3)
      return v11;
    goto LABEL_5;
  }
  v6 = strlen((const char *)buffer);
  v8 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, v6, 1u);
  if (!v8)
    v8 = (const __CFURL *)CFRetain(url);
  BundleVersionForURL = _CFBundleGetBundleVersionForURL((uint64_t)v8, v7);
  v10 = BundleVersionForURL;
  v11 = _CFBundleCopyInfoDictionaryInDirectoryWithVersion(a1, v8, 0, 0, 0, BundleVersionForURL);
  CFRelease(v8);
  if (a3)
LABEL_5:
    *a3 = v10;
  return v11;
}

uint64_t _CFBundleURLLooksLikeBundle(const __CFURL *a1)
{
  uint64_t result;

  result = (uint64_t)_CFBundleCreateIfLooksLikeBundle((const __CFAllocator *)&__kCFAllocatorSystemDefault, a1);
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 1;
  }
  return result;
}

BOOL _CFLocaleGetCalendarDirection()
{
  int AppBooleanValue;
  _BOOL8 v1;
  __CFBundle *MainBundle;
  const __CFArray *v3;
  const __CFArray *v4;
  const __CFArray *v5;
  const __CFString *ValueAtIndex;
  const __CFDictionary *ComponentsFromLocaleIdentifier;
  const __CFString *Value;
  Boolean keyExistsAndHasValidFormat;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  keyExistsAndHasValidFormat = 0;
  AppBooleanValue = CFPreferencesGetAppBooleanValue(CFSTR("NSLocaleCalendarDirectionIsRightToLeft"), CFSTR("kCFPreferencesAnyApplication"), &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat)
    return AppBooleanValue != 0;
  MainBundle = CFBundleGetMainBundle();
  v3 = CFBundleCopyBundleLocalizations(MainBundle);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = CFBundleCopyPreferredLocalizationsFromArray(v3);
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, 0);
  ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier(0, ValueAtIndex);
  Value = (const __CFString *)CFDictionaryGetValue(ComponentsFromLocaleIdentifier, CFSTR("kCFLocaleLanguageCodeKey"));
  if (Value)
    v1 = CFLocaleGetLanguageCharacterDirection(Value) == kCFLocaleLanguageDirectionRightToLeft;
  else
    v1 = 0;
  CFRelease(ComponentsFromLocaleIdentifier);
  CFRelease(v5);
  CFRelease(v4);
  return v1;
}

CFDictionaryRef CFLocaleCreateComponentsFromLocaleIdentifier(CFAllocatorRef allocator, CFLocaleIdentifier localeID)
{
  __CFDictionary *Mutable;
  int Language;
  CFStringRef v6;
  int Script;
  CFStringRef v8;
  int Country;
  CFStringRef v10;
  int Variant;
  CFStringRef v12;
  uint64_t v13;
  const char *v14;
  size_t v16;
  CFStringRef v17;
  size_t v18;
  CFStringRef v19;
  CFStringRef v20;
  uint64_t v21;
  const __CFDictionary *Copy;
  CFIndex usedBufLen;
  int v25;
  char __s[100];
  UInt8 bytes[257];
  UInt8 buffer[257];
  uint64_t v29;
  CFRange v30;

  v29 = *MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable(allocator, 10, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v25 = 0;
  if (localeID)
  {
    usedBufLen = 0;
    v30.length = CFStringGetLength(localeID);
    v30.location = 0;
    CFStringGetBytes(localeID, v30, 0x600u, 0x3Fu, 1u, buffer, 256, &usedBufLen);
    buffer[usedBufLen] = 0;
    Language = uloc_getLanguage();
    if (v25 <= 0 && Language >= 1)
    {
      v6 = CFStringCreateWithBytes(allocator, bytes, Language, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, CFSTR("kCFLocaleLanguageCodeKey"), v6);
      CFRelease(v6);
    }
    v25 = 0;
    Script = uloc_getScript();
    if (v25 <= 0 && Script >= 1)
    {
      v8 = CFStringCreateWithBytes(allocator, bytes, Script, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, CFSTR("kCFLocaleScriptCodeKey"), v8);
      CFRelease(v8);
    }
    v25 = 0;
    Country = uloc_getCountry();
    if (v25 <= 0 && Country >= 1)
    {
      v10 = CFStringCreateWithBytes(allocator, bytes, Country, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, CFSTR("kCFLocaleCountryCodeKey"), v10);
      CFRelease(v10);
    }
    v25 = 0;
    Variant = uloc_getVariant();
    if (v25 <= 0 && Variant >= 1)
    {
      v12 = CFStringCreateWithBytes(allocator, bytes, Variant, 0x600u, 1u);
      CFDictionaryAddValue(Mutable, CFSTR("kCFLocaleVariantCodeKey"), v12);
      CFRelease(v12);
    }
    v25 = 0;
    uloc_openKeywords();
    v13 = uenum_next();
    if (v13 && v25 <= 0)
    {
      v14 = (const char *)v13;
      while (1)
      {
        if ((int)uloc_getKeywordValue() < 1 || v25 > 0)
          goto LABEL_29;
        v16 = strlen(v14);
        v17 = CFStringCreateWithBytes(allocator, (const UInt8 *)v14, v16, 0x600u, 1u);
        v18 = strlen(__s);
        v19 = CFStringCreateWithBytes(allocator, (const UInt8 *)__s, v18, 0x600u, 1u);
        v20 = v19;
        if (v17 && v19)
        {
          CFDictionaryAddValue(Mutable, v17, v19);
        }
        else if (!v17)
        {
          goto LABEL_27;
        }
        CFRelease(v17);
LABEL_27:
        if (v20)
          CFRelease(v20);
LABEL_29:
        v21 = uenum_next();
        if (v21)
        {
          v14 = (const char *)v21;
          if (v25 < 1)
            continue;
        }
        break;
      }
    }
    uenum_close();
  }
  Copy = CFDictionaryCreateCopy(allocator, Mutable);
  CFRelease(Mutable);
  return Copy;
}

CFArrayRef CFBundleCopyBundleLocalizations(CFBundleRef bundle)
{
  return (CFArrayRef)_CFBundleCopyBundleLocalizations((uint64_t)bundle, 0);
}

CFLocaleLanguageDirection CFLocaleGetLanguageCharacterDirection(CFStringRef isoLangCode)
{
  return +[NSLocale characterDirectionForLanguage:](NSLocale, "characterDirectionForLanguage:", isoLangCode);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return _CFPreferencesGetAppBooleanValueWithContainer((uint64_t)key, (uint64_t)applicationID, 0, keyExistsAndHasValidFormat);
}

CFArrayRef CFBundleCopyLocalizationsForPreferences(CFArrayRef locArray, CFArrayRef prefArray)
{
  const __CFArray *v4;
  __CFArray *v5;

  if (prefArray)
    return _CFBundleCopyLocalizationsForPreferences(locArray, prefArray, 0);
  v4 = (const __CFArray *)_CFBundleCopyUserLanguages();
  if (!v4)
    v4 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeArrayCallBacks);
  v5 = _CFBundleCopyLocalizationsForPreferences(locArray, v4, 0);
  CFRelease(v4);
  return v5;
}

CFArrayRef CFBundleCopyPreferredLocalizationsFromArray(CFArrayRef locArray)
{
  const __CFArray *v2;
  __CFArray *v3;

  v2 = (const __CFArray *)_CFBundleCopyUserLanguages();
  if (!v2)
    v2 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeArrayCallBacks);
  v3 = _CFBundleCopyLocalizationsForPreferences(locArray, v2, 1);
  CFRelease(v2);
  return v3;
}

CFTypeRef _CFBundleCopyUserLanguages()
{
  const void *v0;
  CFPropertyListRef v1;
  CFTypeRef v2;
  BOOL v3;
  CFTypeID v4;
  CFTypeRef v5;

  os_unfair_lock_lock((os_unfair_lock_t)&_CFBundleUserLanguagesLock);
  v0 = (const void *)_CFBundleUserLanguages;
  if (_CFBundleUserLanguages)
    goto LABEL_15;
  v1 = CFPreferencesCopyAppValue(CFSTR("AppleLanguages"), CFSTR("kCFPreferencesCurrentApplication"));
  if (!v1)
    v1 = CFPreferencesCopyAppValue(CFSTR("NSLanguages"), CFSTR("kCFPreferencesCurrentApplication"));
  v2 = (CFTypeRef)_CFBundleUserLanguages;
  if (_CFBundleUserLanguages)
    v3 = 1;
  else
    v3 = v1 == 0;
  if (!v3)
  {
    v2 = CFRetain(v1);
    _CFBundleUserLanguages = (uint64_t)v2;
  }
  if (v2)
  {
    v4 = CFGetTypeID(v2);
    if (v4 != CFArrayGetTypeID())
    {
      CFRelease((CFTypeRef)_CFBundleUserLanguages);
      _CFBundleUserLanguages = 0;
    }
  }
  if (v1)
    CFRelease(v1);
  v0 = (const void *)_CFBundleUserLanguages;
  if (_CFBundleUserLanguages)
LABEL_15:
    v5 = CFRetain(v0);
  else
    v5 = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleUserLanguagesLock);
  return v5;
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)_CFPreferencesCopyAppValueWithContainerAndConfiguration((uint64_t)key, (uint64_t)applicationID, 0, 0);
}

CFIndex CFBitVectorGetFirstIndexOfBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  if (range.length < 1)
    return -1;
  while (((*(unsigned __int8 *)(*((_QWORD *)bv + 4) + range.location / 8) >> (~LOBYTE(range.location) & 7)) & 1) != value)
  {
    ++range.location;
    if (!--range.length)
      return -1;
  }
  return range.location;
}

SEL __methodDescriptionForSelector(Class cls, SEL name)
{
  objc_class *Superclass;
  Protocol **v5;
  Protocol **v6;
  uint64_t v7;
  Protocol *v8;
  BOOL isMetaClass;
  SEL v10;
  Protocol *v11;
  BOOL v12;
  objc_method *InstanceMethod;
  objc_method *v14;
  SEL v15;
  unsigned int outCount;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (cls)
  {
    Superclass = cls;
    while (1)
    {
      outCount = 0;
      v5 = class_copyProtocolList(Superclass, &outCount);
      v6 = v5;
      if (outCount)
        break;
      if (v5)
LABEL_10:
        free(v6);
      Superclass = class_getSuperclass(Superclass);
      if (!Superclass)
        goto LABEL_12;
    }
    v7 = 0;
    while (1)
    {
      v8 = v6[v7];
      isMetaClass = class_isMetaClass(Superclass);
      v10 = protocol_getMethodDescription(v8, name, 1, !isMetaClass).name;
      if (v10)
        break;
      v11 = v6[v7];
      v12 = class_isMetaClass(Superclass);
      v10 = protocol_getMethodDescription(v11, name, 0, !v12).name;
      if (v10)
        break;
      if (++v7 >= (unint64_t)outCount)
        goto LABEL_10;
    }
    v15 = v10;
    free(v6);
  }
  else
  {
LABEL_12:
    InstanceMethod = class_getInstanceMethod(cls, name);
    if (InstanceMethod)
    {
      v14 = InstanceMethod;
      v15 = method_getName(InstanceMethod);
      method_getTypeEncoding(v14);
    }
    else
    {
      return 0;
    }
  }
  return v15;
}

uint64_t CFArrayApply(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  void *v7;
  uint64_t v8;
  BOOL v9;
  char v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v4 = a3 - 1;
  if (a3 >= 1)
  {
    v7 = (void *)result;
    do
    {
      v8 = objc_msgSend(v7, "objectAtIndex:", a2);
      v10 = 0;
      result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(a4 + 16))(a4, v8, &v10);
      if (v10)
        v9 = 1;
      else
        v9 = v4 == 0;
      --v4;
      ++a2;
    }
    while (!v9);
  }
  return result;
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode(CFAllocatorRef allocator, uint32_t lcid)
{
  return (CFLocaleIdentifier)+[NSLocale localeIdentifierFromWindowsLocaleCode:](NSLocale, "localeIdentifierFromWindowsLocaleCode:", *(_QWORD *)&lcid);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, (byte6 << 48) | ((unint64_t)byte7 << 56) | (byte5 << 40) | (byte4 << 32) | ((unint64_t)byte3 << 24) | ((unint64_t)byte2 << 16) | ((unint64_t)byte1 << 8) | byte0, byte8 | ((unint64_t)byte9 << 8) | ((unint64_t)byte10 << 16) | ((unint64_t)byte11 << 24) | ((unint64_t)byte12 << 32) | ((unint64_t)byte13 << 40) | ((unint64_t)byte14 << 48) | ((unint64_t)byte15 << 56), 1);
}

CFStringRef CFStringCreateWithPascalString(CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)pStr, *pStr + 1, *(uint64_t *)&encoding, 4u, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
}

void sub_182B4A768(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

objc_class *__NSArrayParameterCheckIterate(objc_class *result, const char *a2, uint64_t a3, uint64_t a4, void *a5)
{
  objc_class *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  NSException *v14;
  objc_class *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  NSException *v19;
  const char *v20;
  const char *v21;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  if ((a4 & 0x1000000000000000) != 0)
  {
    v6 = result;
    if (!a5)
    {
      v13 = __CFExceptionProem(result, a2);
      CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@: index set is nil"), v13);
      v14 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
      objc_exception_throw(v14);
    }
    v7 = objc_msgSend(a5, "lastIndex");
    result = (objc_class *)-[objc_class count](v6, "count");
    if ((v7 & 0x8000000000000000) != 0 || v7 != 0x7FFFFFFFFFFFFFFFLL && (unint64_t)result <= v7)
    {
      if (result)
      {
        v15 = result;
        v8 = _os_log_pack_size();
        v10 = (char *)v22 - ((MEMORY[0x1E0C80A78](v8, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
        v17 = _os_log_pack_fill();
        v18 = PROEM_SEL_0(a2);
        v15 = (objc_class *)((char *)v15 - 1);
        __os_log_helper_1_2_4_8_32_8_32_8_0_8_0(v17, (uint64_t)"NSArray", (uint64_t)v18, v7, (uint64_t)v15);
        v21 = PROEM_SEL_0(a2);
        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** -[%s %s]: index %lu beyond bounds [0 .. %lu]"), "NSArray", v21, v7, v15);
      }
      else
      {
        v8 = _os_log_pack_size();
        v10 = (char *)v22 - ((MEMORY[0x1E0C80A78](v8, v9) + 15) & 0xFFFFFFFFFFFFFFF0);
        v11 = _os_log_pack_fill();
        v12 = PROEM_SEL_0(a2);
        __os_log_helper_1_2_3_8_32_8_32_8_0(v11, (uint64_t)"NSArray", (uint64_t)v12, v7);
        v20 = PROEM_SEL_0(a2);
        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** -[%s %s]: index %lu beyond bounds for empty array"), "NSArray", v20, v7);
      }
      v19 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:](NSException, "exceptionWithName:reason:userInfo:osLogPack:size:", CFSTR("NSRangeException"), _CFAutoreleasePoolAddObject(), 0, v10, v8);
      objc_exception_throw(v19);
    }
  }
  return result;
}

void sub_182B4B824(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182B4C2B4(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182B4C92C(_Unwind_Exception *a1)
{
  free(0);
  _Unwind_Resume(a1);
}

void sub_182B4D388(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 96), 8);
  free(0);
  _Unwind_Resume(a1);
}

uint64_t _NSIsNSIndexSet()
{
  Class Class;

  if (_NSIndexSetClass || (Class = objc_getClass("NSIndexSet"), (_NSIndexSetClass = (uint64_t)Class) != 0))
    LOBYTE(Class) = objc_opt_isKindOfClass();
  return Class & 1;
}

void sub_182B4D984(_Unwind_Exception *a1)
{
  uint64_t v1;

  free(*(void **)(v1 - 160));
  _Unwind_Resume(a1);
}

void _CFCharacterSetCompact(unint64_t *cf)
{
  char v2;
  unint64_t v3;
  uint64_t i;
  unint64_t v5;
  unint64_t *v6;
  char v7;

  v2 = atomic_load(cf + 1);
  if ((v2 & 0x70) == 0x30 && cf[3])
    __CFCSetMakeCompact(cf);
  v3 = cf[5];
  if (v3 && *(_DWORD *)(v3 + 8))
  {
    for (i = 0; i != 16; ++i)
    {
      v5 = cf[5];
      if (v5)
      {
        if (((*(_DWORD *)(v5 + 8) >> (i + 1)) & 1) != 0
          && *(unsigned __int8 *)(v5 + 12) >= (i + 1))
        {
          v6 = *(unint64_t **)(*(_QWORD *)v5 + 8 * i);
          if (v6)
          {
            v7 = atomic_load(v6 + 1);
            if ((v7 & 0x70) == 0x30)
            {
              if (v6[3])
                __CFCSetMakeCompact(v6);
            }
          }
        }
      }
    }
  }
}

void __CFApplySurrogatesInString(uint64_t a1, CFStringRef theString, void (*a3)(uint64_t, uint64_t, uint64_t))
{
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  UniChar v12;
  uint64_t v13;
  uint64_t v15;
  CFIndex v16;
  CFIndex v17;
  UniChar v19;
  uint64_t v20;
  uint64_t v21;
  CFIndex v22;
  uint64_t v23;
  _OWORD v24[8];
  CFStringRef theStringa;
  const UniChar *v26;
  const char *v27;
  uint64_t v28;
  CFIndex v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CFRange v33;
  CFRange v34;

  v32 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(theString);
  theStringa = theString;
  v28 = 0;
  v29 = Length;
  CharactersPtr = CFStringGetCharactersPtr(theString);
  CStringPtr = 0;
  v26 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
  v30 = 0;
  v31 = 0;
  v27 = CStringPtr;
  if (Length >= 1)
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    memset(v24, 0, sizeof(v24));
    do
    {
      if (v26)
      {
        v12 = v26[v28 + v9];
      }
      else if (v27)
      {
        v12 = v27[v28 + v9];
      }
      else
      {
        v13 = v30;
        if (v31 <= v9 || v30 > v9)
        {
          v15 = v9 - 4;
          if (v9 < 4)
            v15 = 0;
          v16 = v15 + 64;
          if (v15 + 64 >= v29)
            v16 = v29;
          v30 = v15;
          v31 = v16;
          v33.location = v28 + v15;
          v33.length = v16 - v15;
          CFStringGetCharacters(theStringa, v33, (UniChar *)v24);
          v13 = v30;
        }
        v12 = *((_WORD *)v24 + v9 - v13);
      }
      v17 = v9 + 1;
      if (v12 >> 10 == 54 && v17 < Length)
      {
        if (v26)
        {
          v19 = v26[v28 + v17];
        }
        else if (v27)
        {
          v19 = v27[v28 + v17];
        }
        else
        {
          if (v31 <= v17 || (v20 = v30, v30 > v17))
          {
            v21 = v9 - 3;
            if (v9 < 3)
              v21 = 0;
            v22 = v21 + 64;
            if (v21 + 64 >= v29)
              v22 = v29;
            v30 = v21;
            v31 = v22;
            v34.location = v28 + v21;
            v34.length = v22 - v21;
            CFStringGetCharacters(theStringa, v34, (UniChar *)v24);
            v20 = v30;
          }
          v19 = *((_WORD *)v24 + v17 - v20);
        }
        if (v19 >> 10 == 55)
        {
          v23 = (v12 << 10) + v19 - 56613888;
          if (v10 + v11 == v23)
          {
            ++v10;
          }
          else
          {
            if (v10 >= 1)
              a3(a1, v11, v10);
            v11 = v23;
            v10 = 1;
          }
        }
      }
      else
      {
        v17 = v9;
      }
      v9 = v17 + 1;
    }
    while (v17 + 1 < Length);
    if (v10 >= 1)
      a3(a1, v11, v10);
  }
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  CFIndex Length;
  uint64_t v5;
  unint64_t *Instance;
  CFMutableCharacterSetRef Mutable;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  CFAllocatorRef v15;
  UniChar *Typed;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int16 *v21;
  __int16 v22;
  int v23;
  _WORD *v24;
  _WORD *v25;
  unint64_t v26;
  unint64_t v27;
  char v28;
  unint64_t *v29;
  unint64_t v30;
  unint64_t v31;
  int v32;
  CFRange v34;

  Length = CFStringGetLength(theString);
  if (Length > 63)
    goto LABEL_39;
  v5 = Length;
  Instance = (unint64_t *)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x19uLL, 32, 0);
  Mutable = (CFMutableCharacterSetRef)Instance;
  if (!Instance)
    return Mutable;
  v8 = Instance + 1;
  v9 = atomic_load(Instance + 1);
  do
  {
    v10 = __ldaxr(v8);
    if (v10 == v9)
    {
      if (!__stlxr(v9 & 0xFFFFFFFFFFFFFFFELL, v8))
      {
        v11 = 1;
        goto LABEL_9;
      }
    }
    else
    {
      __clrex();
    }
    v11 = 0;
LABEL_9:
    v9 = v10;
  }
  while (!v11);
  v12 = atomic_load(v8);
  do
  {
    v13 = __ldaxr(v8);
    if (v13 == v12)
    {
      if (!__stlxr(v12 & 0xFFFFFFFFFFFFFF8FLL | 0x20, v8))
      {
        v14 = 1;
        goto LABEL_16;
      }
    }
    else
    {
      __clrex();
    }
    v14 = 0;
LABEL_16:
    v12 = v13;
  }
  while (!v14);
  Instance[2] = 0;
  Instance[5] = 0;
  v15 = CFGetAllocator(Instance);
  Typed = (UniChar *)CFAllocatorAllocateTyped(v15, 128, 0x1000040BDFB0063, 0);
  *((_QWORD *)Mutable + 3) = Typed;
  *((_QWORD *)Mutable + 4) = v5;
  v34.location = 0;
  v34.length = v5;
  CFStringGetCharacters(theString, v34, Typed);
  qsort(*((void **)Mutable + 3), v5, 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
  v17 = v5;
  if (v5 >= 2)
  {
    v18 = 0;
    v19 = *((_QWORD *)Mutable + 3);
    v20 = v5 - 1;
    v21 = (unsigned __int16 *)(v19 + 2);
    do
    {
      v23 = *v21++;
      v22 = v23;
      if (*(unsigned __int16 *)(v19 + 2 * v18) != v23)
      {
        ++v18;
        *(_WORD *)(v19 + 2 * v18) = v22;
      }
      --v20;
    }
    while (v20);
    v17 = v18 + 1;
  }
  *((_QWORD *)Mutable + 4) = v17;
  if (!v5)
  {
    v26 = atomic_load(v8);
    while (1)
    {
      v27 = __ldaxr(v8);
      if (v27 != v26)
        break;
      if (__stlxr(v26 | 4, v8))
        goto LABEL_35;
      v28 = 1;
LABEL_36:
      v26 = v27;
      if ((v28 & 1) != 0)
        return Mutable;
    }
    __clrex();
LABEL_35:
    v28 = 0;
    goto LABEL_36;
  }
  if (v5 >= 2)
  {
    v24 = (_WORD *)*((_QWORD *)Mutable + 3);
    if ((unsigned __int16)*v24 >> 10 <= 0x36u)
    {
      v25 = &v24[v5];
      if ((unsigned __int16)*(v25 - 1) >> 10 >= 0x37u)
      {
        while ((*v24 & 0xF800 | 0x400) != 0xDC00)
        {
          if (++v24 >= v25)
            return Mutable;
        }
        CFRelease(Mutable);
LABEL_39:
        Mutable = CFCharacterSetCreateMutable(alloc);
        CFCharacterSetAddCharactersInString(Mutable, theString);
        __CFCSetMakeCompact((unint64_t *)Mutable);
        v29 = (unint64_t *)((char *)Mutable + 8);
        v30 = atomic_load((unint64_t *)Mutable + 1);
        while (2)
        {
          v31 = __ldaxr(v29);
          if (v31 == v30)
          {
            if (!__stlxr(v30 & 0xFFFFFFFFFFFFFFFELL, v29))
            {
              v32 = 1;
              goto LABEL_45;
            }
          }
          else
          {
            __clrex();
          }
          v32 = 0;
LABEL_45:
          v30 = v31;
          if (v32)
            return Mutable;
          continue;
        }
      }
    }
  }
  return Mutable;
}

void CFCharacterSetUnion(CFMutableCharacterSetRef theSet, CFCharacterSetRef theOtherSet)
{
  __objc2_class **v2;
  uint64_t v3;
  uint64_t v4;
  __objc2_class **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  char v13;
  char v14;
  char v15;
  char v16;
  __objc2_class *v17;
  unsigned int v18;
  char v19;
  uint64_t v20;
  const __CFData *BitmapRepresentation;
  const __CFData *v22;
  const UInt8 *BytePtr;
  const UInt8 *v24;
  uint64_t v25;
  __objc2_class *v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  unint64_t *v32;
  char v33;
  char v34;
  char v35;
  int v36;
  __CFCharacterSet *v37;
  CFRange v38;
  const __CFAllocator *v39;
  const __CFString *v40;
  __objc2_class *v41;
  unsigned int v42;
  uint64_t v43;
  char v44;
  __objc2_class *v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  char v49;
  char v50;
  char v51;
  const __CFAllocator *v52;
  unint64_t v53;
  unint64_t v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  int v61;
  uint64_t i;
  __objc2_class *v63;
  const __CFAllocator *v64;
  const __CFAllocator *v65;
  uint64_t k;
  unint64_t v67;
  unint64_t v68;
  int v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  unsigned int v76;
  const __CFCharacterSet *v77;
  __objc2_class *v78;
  __objc2_class *v79;
  CFAllocatorRef v80;
  uint64_t v81;
  __objc2_class *isa;
  CFAllocatorRef v83;
  uint64_t v84;
  CFAllocatorRef v85;
  uint64_t v86;
  const __CFAllocator *v87;
  CFAllocatorRef v88;
  uint64_t v89;
  const __CFAllocator *v90;
  uint64_t v91;
  uint64_t j;
  __objc2_class *v93;
  const __CFAllocator *v94;
  const __CFAllocator *v95;
  CFAllocatorRef v96;
  char v97;
  uint64_t v98;
  _BOOL4 v99;
  unint64_t v100;
  unint64_t v101;
  int v102;
  char v103;
  unint64_t v104;
  unint64_t v105;
  int v106;
  uint64_t v107;
  uint64_t Typed;
  CFAllocatorRef v109;
  unint64_t v110;
  unint64_t v111;
  char v112;
  unint64_t v113;
  int BitmapForPlane;
  int v115;
  __objc2_class *v116;
  __objc2_class *v117;
  CFAllocatorRef v118;
  uint64_t v119;
  CFAllocatorRef v120;
  uint64_t v121;
  uint64_t v122;
  const __CFAllocator *v123;
  CFMutableCharacterSetRef Mutable;
  __objc2_class *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  int8x16_t __b[512];
  uint64_t v130;
  CFRange v131;
  CFRange v132;

  v2 = (__objc2_class **)MEMORY[0x1E0C80A78](theSet, theOtherSet);
  v4 = v3;
  v5 = v2;
  v130 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x19uLL, v2))
  {
    objc_msgSend(v5, "formUnionWithCharacterSet:", v4);
    return;
  }
  v12 = (unint64_t *)(v5 + 1);
  v13 = atomic_load((unint64_t *)v5 + 1);
  if ((v13 & 1) == 0)
  {
    CFLog(3, (uint64_t)CFSTR("%s: Immutable character set passed to mutable function"), v6, v7, v8, v9, v10, v11, (__int16)"void CFCharacterSetUnion(CFMutableCharacterSetRef, CFCharacterSetRef)");
    if (dyld_program_sdk_at_least())
      CFCharacterSetUnion_cold_1();
  }
  v14 = atomic_load(v12);
  if ((v14 & 0x70) == 0)
  {
    v15 = atomic_load(v12);
    if ((v15 & 1) == 0)
    {
      v16 = atomic_load(v12);
      if ((v16 & 8) == 0 && CFCharacterSetGetPredefined((CFCharacterSetPredefinedSet)v5[3]) == (CFCharacterSetRef)v5)
        return;
    }
  }
  v17 = v5[5];
  if (!v17 || !LODWORD(v17->superclass) && !BYTE5(v17->superclass))
  {
    v18 = atomic_load(v12);
    switch((v18 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (v5[4])
          goto LABEL_18;
        break;
      case 3u:
      case 4u:
        if (v5[3])
          goto LABEL_18;
        break;
      default:
        goto LABEL_18;
    }
    v19 = atomic_load(v12);
    if ((v19 & 8) != 0)
      return;
  }
LABEL_18:
  if (!CF_IS_OBJC(0x19uLL, (__objc2_class **)v4))
  {
    v20 = 0;
    goto LABEL_34;
  }
  v20 = objc_msgSend((id)v4, "_expandedCFCharacterSet");
  if (v20)
  {
LABEL_34:
    if (v20)
      v4 = v20;
    v30 = *(_QWORD *)(v4 + 40);
    if (!v30 || !*(_DWORD *)(v30 + 8) && !*(_BYTE *)(v30 + 13))
    {
      v31 = atomic_load((unint64_t *)(v4 + 8));
      switch((v31 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(_QWORD *)(v4 + 32))
            goto LABEL_41;
          break;
        case 3u:
        case 4u:
          if (*(_QWORD *)(v4 + 24))
            goto LABEL_41;
          break;
        default:
          goto LABEL_41;
      }
      v48 = atomic_load((unint64_t *)(v4 + 8));
      if ((v48 & 8) == 0)
      {
LABEL_196:
        if (__CFCheckForExapendedSet == 1)
          __CFCheckForExpandedSet((const char *)v5);
        return;
      }
      v49 = atomic_load(v12);
      if ((v49 & 0x70) == 0x20 && v5[3]
        || (v50 = atomic_load(v12), (v50 & 0x70) == 0x30) && v5[3]
        || (v51 = atomic_load(v12), (v51 & 0x70) == 0x40) && v5[3])
      {
        v52 = CFGetAllocator(v5);
        CFAllocatorDeallocate(v52, v5[3]);
      }
      v53 = atomic_load(v12);
      while (1)
      {
        v54 = __ldaxr(v12);
        if (v54 != v53)
          break;
        if (__stlxr(v53 & 0xFFFFFFFFFFFFFF8FLL | 0x10, v12))
          goto LABEL_75;
        v55 = 1;
LABEL_76:
        v53 = v54;
        if (v55)
        {
          v5[4] = 0;
          v56 = atomic_load((unint64_t *)v5 + 1);
          while (1)
          {
            v57 = __ldaxr(v12);
            if (v57 != v56)
              break;
            if (__stlxr(v56 | 8, v12))
              goto LABEL_82;
            v58 = 1;
LABEL_83:
            v56 = v57;
            if (v58)
            {
              v59 = atomic_load(v12);
              while (1)
              {
                v60 = __ldaxr(v12);
                if (v60 != v59)
                  break;
                if (__stlxr(v59 & 0xFFFFFFFFFFFFFFFBLL, v12))
                  goto LABEL_89;
                v61 = 1;
LABEL_90:
                v59 = v60;
                if (v61)
                {
                  if (v5[5])
                  {
                    for (i = 0; i != 16; ++i)
                    {
                      v63 = v5[5];
                      if (((LODWORD(v63->superclass) >> i) & 2) != 0)
                        CFRelease(*((CFTypeRef *)&v63->isa->isa + i));
                    }
                    v64 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v64, v5[5]->isa);
                    v65 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v65, v5[5]);
                    v5[5] = 0;
                  }
                  goto LABEL_196;
                }
              }
              __clrex();
LABEL_89:
              v61 = 0;
              goto LABEL_90;
            }
          }
          __clrex();
LABEL_82:
          v58 = 0;
          goto LABEL_83;
        }
      }
      __clrex();
LABEL_75:
      v55 = 0;
      goto LABEL_76;
    }
LABEL_41:
    v32 = (unint64_t *)(v4 + 8);
    v33 = atomic_load((unint64_t *)(v4 + 8));
    if ((v33 & 0x70) == 0)
    {
      v41 = v5[5];
      if (!v41 || !LODWORD(v41->superclass) && !BYTE5(v41->superclass))
      {
        v42 = atomic_load(v12);
        switch((v42 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (v5[4])
              goto LABEL_42;
            break;
          case 3u:
          case 4u:
            if (v5[3])
              goto LABEL_42;
            break;
          default:
            goto LABEL_42;
        }
        v100 = atomic_load(v12);
        while (1)
        {
          v101 = __ldaxr(v12);
          if (v101 != v100)
            break;
          if (__stlxr(v100 & 0xFFFFFFFFFFFFFF8FLL, v12))
            goto LABEL_155;
          v102 = 1;
LABEL_156:
          v100 = v101;
          if (v102)
          {
            v5[3] = *(__objc2_class **)(v4 + 24);
            v103 = atomic_load((unint64_t *)(v4 + 8));
            if ((v103 & 8) != 0)
            {
              v104 = atomic_load(v12);
              while (1)
              {
                v105 = __ldaxr(v12);
                if (v105 != v104)
                  break;
                if (__stlxr(v104 | 8, v12))
                  goto LABEL_163;
                v106 = 1;
LABEL_164:
                v104 = v105;
                if (v106)
                  goto LABEL_165;
              }
              __clrex();
LABEL_163:
              v106 = 0;
              goto LABEL_164;
            }
LABEL_165:
            v107 = *(_QWORD *)(v4 + 40);
            if (v107 && *(_BYTE *)(v107 + 13))
            {
              Typed = (uint64_t)v5[5];
              if (!Typed)
              {
                v109 = CFGetAllocator(v5);
                Typed = CFAllocatorAllocateTyped(v109, 16, 0x1080040FC6463CFLL, 0);
                v5[5] = (__objc2_class *)Typed;
                *(_QWORD *)Typed = 0;
                *(_QWORD *)(Typed + 6) = 0;
              }
              *(_BYTE *)(Typed + 13) = 1;
            }
            v110 = atomic_load(v12);
            while (2)
            {
              v111 = __ldaxr(v12);
              if (v111 == v110)
              {
                if (!__stlxr(v110 & 0xFFFFFFFFFFFFFFFBLL, v12))
                {
                  v112 = 1;
                  goto LABEL_176;
                }
              }
              else
              {
                __clrex();
              }
              v112 = 0;
LABEL_176:
              v110 = v111;
              if ((v112 & 1) != 0)
                goto LABEL_196;
              continue;
            }
          }
        }
        __clrex();
LABEL_155:
        v102 = 0;
        goto LABEL_156;
      }
    }
LABEL_42:
    v34 = atomic_load(v32);
    v35 = atomic_load(v32);
    if ((v34 & 0x70) == 0x10)
    {
      v36 = *(_DWORD *)(v4 + 24);
      if ((v35 & 8) != 0)
      {
        v43 = *(_QWORD *)(v4 + 32);
        if (v36)
        {
          v131.location = 0;
          v131.length = *(unsigned int *)(v4 + 24);
          CFCharacterSetAddCharactersInRange((CFMutableCharacterSetRef)v5, v131);
        }
        v38.location = (v36 + v43);
        v38.length = (1114112 - LODWORD(v38.location));
        v37 = (__CFCharacterSet *)v5;
      }
      else
      {
        v38.length = *(_QWORD *)(v4 + 32);
        v37 = (__CFCharacterSet *)v5;
        v38.location = *(unsigned int *)(v4 + 24);
      }
      CFCharacterSetAddCharactersInRange(v37, v38);
LABEL_106:
      v70 = *(_QWORD *)(v4 + 40);
      if (v70)
      {
        v71 = *(unsigned __int8 *)(v70 + 13);
        if (*(_DWORD *)(v70 + 8))
        {
          v72 = 0;
          v73 = 8;
          while (1)
          {
            v74 = *(_QWORD *)(v4 + 40);
            if (v74)
            {
              v75 = 1 << (v72 + 1);
              if ((*(_DWORD *)(v74 + 8) & v75) != 0)
              {
                v76 = (v72 + 1);
                if (*(unsigned __int8 *)(v74 + 12) >= v76)
                {
                  v77 = *(const __CFCharacterSet **)(*(_QWORD *)v74 + 8 * v72);
                  if (v77)
                    break;
                }
              }
            }
LABEL_134:
            ++v72;
            v73 += 8;
            if (v72 == 16)
              goto LABEL_196;
          }
          v78 = v5[5];
          if (!v71)
          {
            if (v78)
            {
              if (BYTE4(v78->superclass) < v76)
              {
                BYTE4(v78->superclass) = v76;
                isa = v78->isa;
                v83 = CFGetAllocator(v5);
                if (isa)
                {
                  v84 = __CFSafelyReallocateWithAllocatorTyped(v83, v5[5]->isa, v73, 0x6004044C4A2DFLL, 0, 0);
                  goto LABEL_130;
                }
LABEL_129:
                v84 = CFAllocatorAllocateTyped(v83, v73, 0x6004044C4A2DFLL, 0);
LABEL_130:
                v78 = v5[5];
                v78->isa = (__objc2_class *)v84;
              }
              if (((uint64_t)v78->superclass & v75) == 0)
              {
                v90 = CFGetAllocator(v5);
                *((_QWORD *)&v5[5]->isa->isa + v72) = CFCharacterSetCreateMutable(v90);
                v78 = v5[5];
                LODWORD(v78->superclass) |= v75;
              }
              CFCharacterSetUnion(*((CFMutableCharacterSetRef *)&v78->isa->isa + v72), v77);
              goto LABEL_134;
            }
            v88 = CFGetAllocator(v5);
            v89 = CFAllocatorAllocateTyped(v88, 16, 0x1080040FC6463CFLL, 0);
            v5[5] = (__objc2_class *)v89;
            *(_WORD *)(v89 + 12) = v76;
            *(_DWORD *)(v89 + 8) = 0;
            v83 = CFGetAllocator(v5);
            goto LABEL_129;
          }
          if (v78)
          {
            if (BYTE4(v78->superclass) >= v76)
            {
LABEL_125:
              if (((uint64_t)v78->superclass & v75) == 0)
              {
                v87 = CFGetAllocator(v5);
                *((_QWORD *)&v5[5]->isa->isa + v72) = CFCharacterSetCreateMutable(v87);
                v78 = v5[5];
                LODWORD(v78->superclass) |= v75;
              }
              CFCharacterSetIntersect(*((CFMutableCharacterSetRef *)&v78->isa->isa + v72), v77);
              goto LABEL_134;
            }
            BYTE4(v78->superclass) = v76;
            v79 = v78->isa;
            v80 = CFGetAllocator(v5);
            if (v79)
            {
              v81 = __CFSafelyReallocateWithAllocatorTyped(v80, v5[5]->isa, v73, 0x6004044C4A2DFLL, 0, 0);
LABEL_124:
              v78 = v5[5];
              v78->isa = (__objc2_class *)v81;
              goto LABEL_125;
            }
          }
          else
          {
            v85 = CFGetAllocator(v5);
            v86 = CFAllocatorAllocateTyped(v85, 16, 0x1080040FC6463CFLL, 0);
            v5[5] = (__objc2_class *)v86;
            *(_WORD *)(v86 + 12) = v76;
            *(_DWORD *)(v86 + 8) = 0;
            v80 = CFGetAllocator(v5);
          }
          v81 = CFAllocatorAllocateTyped(v80, v73, 0x6004044C4A2DFLL, 0);
          goto LABEL_124;
        }
        if (*(_BYTE *)(v70 + 13))
        {
          v91 = (uint64_t)v5[5];
          if (v91)
          {
            if (!*(_DWORD *)(v91 + 8))
            {
LABEL_145:
              *(_BYTE *)(v91 + 13) = 1;
              goto LABEL_196;
            }
            for (j = 0; j != 16; ++j)
            {
              v93 = v5[5];
              if (((LODWORD(v93->superclass) >> j) & 2) != 0)
                CFRelease(*((CFTypeRef *)&v93->isa->isa + j));
            }
            v94 = CFGetAllocator(v5);
            CFAllocatorDeallocate(v94, v5[5]->isa);
            v95 = CFGetAllocator(v5);
            CFAllocatorDeallocate(v95, v5[5]);
            v5[5] = 0;
          }
          v96 = CFGetAllocator(v5);
          v91 = CFAllocatorAllocateTyped(v96, 16, 0x1080040FC6463CFLL, 0);
          v5[5] = (__objc2_class *)v91;
          *(_QWORD *)v91 = 0;
          *(_QWORD *)(v91 + 6) = 0;
          goto LABEL_145;
        }
      }
      v97 = atomic_load((unint64_t *)(v4 + 8));
      if ((v97 & 0x70) != 0)
        goto LABEL_196;
      v98 = *(_QWORD *)(v4 + 40);
      if (v98)
        v99 = *(unsigned __int8 *)(v98 + 13) != 0;
      else
        v99 = 0;
      v113 = 1;
      while (1)
      {
        BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(v4 + 24), v113, __b, v99);
        if (BitmapForPlane != 255)
          break;
LABEL_195:
        if (++v113 == 17)
          goto LABEL_196;
      }
      v115 = BitmapForPlane;
      v116 = v5[5];
      if (v116)
      {
        if (v113 <= BYTE4(v116->superclass))
        {
LABEL_188:
          if (((uint64_t)v116->superclass & (1 << v113)) != 0)
          {
            v122 = (v113 - 1);
          }
          else
          {
            v123 = CFGetAllocator(v5);
            Mutable = CFCharacterSetCreateMutable(v123);
            v122 = (v113 - 1);
            *((_QWORD *)&v5[5]->isa->isa + v122) = Mutable;
            v116 = v5[5];
            LODWORD(v116->superclass) |= 1 << v113;
          }
          v125 = v116->isa;
          v126 = *((_QWORD *)&v125->isa + v122);
          if (v115 == 1)
          {
            v132.location = 0;
            v132.length = 0x10000;
            CFCharacterSetAddCharactersInRange(*((CFMutableCharacterSetRef *)&v125->isa + v122), v132);
          }
          else
          {
            __CFCSetMakeBitmap(*((char **)&v125->isa + v122));
            v127 = 0;
            v128 = *(_QWORD *)(v126 + 24);
            do
            {
              *(_DWORD *)(v128 + v127 * 4) |= __b[0].u32[v127];
              ++v127;
            }
            while (v127 != 2048);
          }
          goto LABEL_195;
        }
        BYTE4(v116->superclass) = v113;
        v117 = v116->isa;
        v118 = CFGetAllocator(v5);
        if (v117)
        {
          v119 = __CFSafelyReallocateWithAllocatorTyped(v118, v5[5]->isa, 8 * v113, 0x6004044C4A2DFLL, 0, 0);
LABEL_187:
          v116 = v5[5];
          v116->isa = (__objc2_class *)v119;
          goto LABEL_188;
        }
      }
      else
      {
        v120 = CFGetAllocator(v5);
        v121 = CFAllocatorAllocateTyped(v120, 16, 0x1080040FC6463CFLL, 0);
        v5[5] = (__objc2_class *)v121;
        *(_BYTE *)(v121 + 12) = v113;
        *(_BYTE *)(v121 + 13) = 0;
        *(_DWORD *)(v121 + 8) = 0;
        v118 = CFGetAllocator(v5);
      }
      v119 = CFAllocatorAllocateTyped(v118, 8 * v113, 0x6004044C4A2DFLL, 0);
      goto LABEL_187;
    }
    if ((v35 & 0x70) == 0x20)
    {
      v39 = CFGetAllocator(v5);
      v40 = CFStringCreateWithCharactersNoCopy(v39, *(const UniChar **)(v4 + 24), *(_QWORD *)(v4 + 32), (CFAllocatorRef)&__kCFAllocatorNull);
      CFCharacterSetAddCharactersInString((CFMutableCharacterSetRef)v5, v40);
      CFRelease(v40);
      goto LABEL_106;
    }
    __CFCSetMakeBitmap((char *)v5);
    v44 = atomic_load((unint64_t *)(v4 + 8));
    v45 = v5[3];
    if ((v44 & 0x70) == 0x30)
    {
      v46 = 0;
      v47 = *(_QWORD *)(v4 + 24);
      do
      {
        *(_DWORD *)((char *)&v45->isa + v46) |= *(_DWORD *)(v47 + v46);
        v46 += 4;
      }
      while (v46 != 0x2000);
    }
    else
    {
      __CFCSetGetBitmap(v4, __b);
      for (k = 0; k != 2048; ++k)
        *(_DWORD *)((char *)&v45->isa + k * 4) |= __b[0].u32[k];
    }
    v67 = atomic_load(v12);
    while (1)
    {
      v68 = __ldaxr(v12);
      if (v68 != v67)
        break;
      if (__stlxr(v67 & 0xFFFFFFFFFFFFFFFBLL, v12))
        goto LABEL_104;
      v69 = 1;
LABEL_105:
      v67 = v68;
      if (v69)
        goto LABEL_106;
    }
    __clrex();
LABEL_104:
    v69 = 0;
    goto LABEL_105;
  }
  BitmapRepresentation = CFCharacterSetCreateBitmapRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFCharacterSetRef)v4);
  if (BitmapRepresentation)
  {
    v22 = BitmapRepresentation;
    if (CFDataGetLength(BitmapRepresentation))
    {
      BytePtr = CFDataGetBytePtr(v22);
      if (BytePtr)
      {
        v24 = BytePtr;
        __CFCSetMakeBitmap((char *)v5);
        v25 = 0;
        v26 = v5[3];
        do
        {
          *(_DWORD *)((char *)&v26->isa + v25) |= *(_DWORD *)&v24[v25];
          v25 += 4;
        }
        while (v25 != 0x2000);
        v27 = atomic_load(v12);
        while (1)
        {
          v28 = __ldaxr(v12);
          if (v28 != v27)
            break;
          if (__stlxr(v27 & 0xFFFFFFFFFFFFFFFBLL, v12))
            goto LABEL_30;
          v29 = 1;
LABEL_31:
          v27 = v28;
          if (v29)
            goto LABEL_32;
        }
        __clrex();
LABEL_30:
        v29 = 0;
        goto LABEL_31;
      }
    }
LABEL_32:
    CFRelease(v22);
  }
}

uint64_t CFUniCharGetBitmapForPlane(unsigned int a1, unsigned int a2, _BYTE *a3, int a4)
{
  char *BitmapPtrForPlane;
  unsigned int v9;
  char v10;
  char v11;
  int v12;
  char *v13;
  unsigned int v14;
  char v15;
  char v16;
  BOOL v17;
  unsigned int i;
  char v19;
  uint64_t j;
  unint64_t v21;
  int v22;
  unint64_t v23;
  char v24;
  char v25;
  char v26;
  char v27;
  char v28;
  unint64_t v29;
  uint64x2_t v30;
  uint64x2_t v31;
  uint64_t k;
  int v34;
  uint64_t v35;
  char v36;
  char v37;
  char v38;

  BitmapPtrForPlane = (char *)CFUniCharGetBitmapPtrForPlane(a1, a2);
  if (BitmapPtrForPlane)
  {
    v9 = 8193;
    if ((a4 & 1) != 0)
    {
      do
      {
        v10 = *BitmapPtrForPlane++;
        *a3++ = ~v10;
        --v9;
      }
      while (v9 > 1);
    }
    else
    {
      do
      {
        v11 = *BitmapPtrForPlane++;
        *a3++ = v11;
        --v9;
      }
      while (v9 > 1);
    }
LABEL_6:
    LOBYTE(v12) = 0;
    return v12;
  }
  if (a1 == 12)
  {
    if (a2 > 0xE)
    {
      if (a2 - 15 <= 1)
      {
        for (i = 2049; i > 1; --i)
        {
          *(_DWORD *)a3 = a4 << 31 >> 31;
          a3 += 4;
        }
        LOBYTE(v12) = 0;
        if (a4)
          v19 = 63;
        else
          v19 = -64;
        *(a3 - 5) = v19;
        return v12;
      }
    }
    else
    {
      v13 = (char *)*(&__CFUniCharLegalCharacterSetBitmap + a2);
      if (v13)
      {
        v14 = 8193;
        if ((a4 & 1) != 0)
        {
          do
          {
            LOBYTE(v12) = 0;
            v15 = *v13++;
            *a3++ = v15;
            --v14;
          }
          while (v14 > 1);
        }
        else
        {
          do
          {
            LOBYTE(v12) = 0;
            v16 = *v13++;
            *a3++ = ~v16;
            --v14;
          }
          while (v14 > 1);
        }
        return v12;
      }
      if (a2 == 14)
      {
        v29 = 0;
        *a3 = 2;
        v30 = (uint64x2_t)vdupq_n_s64(0x1FFFuLL);
        do
        {
          v31 = (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v29), (int8x16_t)xmmword_182CF9700);
          if ((vmovn_s64((int64x2_t)vcgtq_u64(v30, v31)).u8[0] & 1) != 0)
            a3[v29 + 1] = (((v29 - 15) < 0xFFFFFFF4) ^ a4) << 31 >> 31;
          if ((vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0x1FFFuLL), v31)).i32[1] & 1) != 0)
            a3[v29 + 2] = (((v29 - 14) < 0xFFFFFFF4) ^ a4) << 31 >> 31;
          LOBYTE(v12) = 0;
          v29 += 2;
        }
        while (v29 != 0x2000);
        return v12;
      }
    }
    v17 = a4 == 0;
    v12 = -1;
  }
  else
  {
    if ((a1 < 4 || a1 == 15) && !a2)
    {
      memset(a3, a4 << 31 >> 31, 0x2000uLL);
      if (a1 != 15 && a1 != 3)
        goto LABEL_33;
      for (j = 0; j != 7; ++j)
      {
        v21 = (unsigned __int16)word_182CF9714[j];
        v22 = 1 << (v21 & 7);
        v23 = v21 >> 3;
        v24 = a3[v23];
        v25 = v24 & ~(_BYTE)v22;
        v26 = v24 | v22;
        if (a4)
          v26 = v25;
        a3[v23] = v26;
      }
      if (a1 != 15)
      {
LABEL_33:
        v27 = a3[1];
        if (a4)
        {
          a3[1] = v27 & 0xFD;
          a3[4] &= ~1u;
          a3[20] &= ~1u;
          a3[720] &= ~1u;
          a3[1029] &= ~0x80u;
          a3[1035] &= ~0x80u;
          v28 = a3[1536] & 0xFE;
        }
        else
        {
          a3[1] = v27 | 2;
          a3[4] |= 1u;
          a3[20] |= 1u;
          a3[720] |= 1u;
          a3[1029] |= 0x80u;
          a3[1035] |= 0x80u;
          v28 = a3[1536] | 1;
        }
        a3[1536] = v28;
        for (k = 0x2000; k != 8204; ++k)
        {
          v34 = 1 << (k & 7);
          v35 = (unsigned __int16)k >> 3;
          v36 = a3[v35];
          v37 = v36 & ~(_BYTE)v34;
          v38 = v36 | v34;
          if (a4)
            v38 = v37;
          a3[v35] = v38;
        }
      }
      goto LABEL_6;
    }
    v17 = a4 == 0;
    v12 = 1;
  }
  if (v17)
    return -v12;
  return v12;
}

CFCharacterSetRef CFCharacterSetCreateInvertedSet(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  unint64_t *Copy;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  int v9;

  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
    return (CFCharacterSetRef)(id)-[__CFCharacterSet invertedSet](theSet, "invertedSet");
  Copy = __CFCharacterSetCreateCopy(alloc, (unint64_t *)theSet, 1, 1);
  CFCharacterSetInvert((CFMutableCharacterSetRef)Copy);
  v6 = Copy + 1;
  v7 = atomic_load(Copy + 1);
  do
  {
    v8 = __ldaxr(v6);
    if (v8 == v7)
    {
      if (!__stlxr(v7 & 0xFFFFFFFFFFFFFFFELL, v6))
      {
        v9 = 1;
        goto LABEL_9;
      }
    }
    else
    {
      __clrex();
    }
    v9 = 0;
LABEL_9:
    v7 = v8;
  }
  while (!v9);
  return (CFCharacterSetRef)Copy;
}

unint64_t *__CFCharacterSetCreateCopy(CFAllocatorRef alloc, unint64_t *cf, char a3, int a4)
{
  char v8;
  unint64_t *Mutable;

  if (a4 && CF_IS_OBJC(0x19uLL, (__objc2_class **)cf))
    return (unint64_t *)objc_msgSend(cf, "mutableCopy");
  if ((a3 & 1) == 0)
  {
    v8 = atomic_load(cf + 1);
    if ((v8 & 1) == 0)
      return (unint64_t *)CFRetain(cf);
  }
  Mutable = (unint64_t *)CFCharacterSetCreateMutable(alloc);
  _CFCharacterSetInitCopyingSet((char *)alloc, Mutable, (uint64_t)cf, a3);
  return Mutable;
}

CFMutableCharacterSetRef CFCharacterSetCreateMutable(CFAllocatorRef alloc)
{
  CFMutableCharacterSetRef result;
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  int v11;

  result = (CFMutableCharacterSetRef)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x19uLL, 32, 0);
  if (result)
  {
    v2 = (unint64_t *)((char *)result + 8);
    v3 = atomic_load((unint64_t *)result + 1);
    while (1)
    {
      v4 = __ldaxr(v2);
      if (v4 != v3)
        break;
      if (__stlxr(v3 | 1, v2))
        goto LABEL_7;
      v5 = 1;
LABEL_8:
      v3 = v4;
      if (v5)
      {
        v6 = atomic_load(v2);
        while (1)
        {
          v7 = __ldaxr(v2);
          if (v7 != v6)
            break;
          if (__stlxr(v6 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v2))
            goto LABEL_14;
          v8 = 1;
LABEL_15:
          v6 = v7;
          if (v8)
          {
            *((_QWORD *)result + 5) = 0;
            *((_QWORD *)result + 2) = 0;
            *((_QWORD *)result + 3) = 0;
            v9 = atomic_load((unint64_t *)result + 1);
            while (1)
            {
              v10 = __ldaxr(v2);
              if (v10 != v9)
                break;
              if (__stlxr(v9 | 4, v2))
                goto LABEL_21;
              v11 = 1;
LABEL_22:
              v9 = v10;
              if (v11)
                return result;
            }
            __clrex();
LABEL_21:
            v11 = 0;
            goto LABEL_22;
          }
        }
        __clrex();
LABEL_14:
        v8 = 0;
        goto LABEL_15;
      }
    }
    __clrex();
LABEL_7:
    v5 = 0;
    goto LABEL_8;
  }
  return result;
}

char *_CFCharacterSetInitCopyingSet(char *alloc, unint64_t *cf, uint64_t a3, char a4)
{
  const __CFAllocator *v6;
  char v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  char v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  char v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  unsigned int v23;
  void *Typed;
  unsigned __int8 *v25;
  unint64_t v26;
  unint64_t v27;
  char v28;
  char *v29;
  uint64_t v30;
  int32x4_t v31;
  int32x4_t v32;
  int8x16_t v33;
  uint8x16_t v34;
  int32x4_t v35;
  int32x4_t v36;
  int32x4_t v37;
  int8x16_t v38;
  int16x8_t v39;
  int16x8_t v40;
  size_t v41;
  void *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  const void *v49;
  const void *Copy;
  unint64_t v51;
  uint64_t v52;
  CFAllocatorRef v53;
  uint64_t v54;
  CFAllocatorRef v55;
  uint64_t v56;
  unint64_t v57;
  int v58;
  uint64_t v59;
  char v60;
  CFAllocatorRef v61;

  v6 = (const __CFAllocator *)alloc;
  v7 = atomic_load((unint64_t *)(a3 + 8));
  v8 = v7 & 0x70;
  v9 = cf + 1;
  v10 = atomic_load(cf + 1);
  do
  {
    v11 = __ldaxr(v9);
    if (v11 == v10)
    {
      if (!__stlxr(v10 & 0xFFFFFFFFFFFFFF8FLL | v8, v9))
      {
        v12 = 1;
        goto LABEL_7;
      }
    }
    else
    {
      __clrex();
    }
    v12 = 0;
LABEL_7:
    v10 = v11;
  }
  while (!v12);
  v13 = atomic_load((unint64_t *)(a3 + 8));
  v14 = atomic_load(v9);
  v15 = v13 & 4;
  do
  {
    v16 = __ldaxr(v9);
    if (v16 == v14)
    {
      if (!__stlxr(v14 & 0xFFFFFFFFFFFFFFFBLL | v15, v9))
      {
        v17 = 1;
        goto LABEL_14;
      }
    }
    else
    {
      __clrex();
    }
    v17 = 0;
LABEL_14:
    v14 = v16;
  }
  while (!v17);
  v18 = atomic_load((unint64_t *)(a3 + 8));
  v19 = atomic_load(v9);
  v20 = v18 & 8;
  do
  {
    v21 = __ldaxr(v9);
    if (v21 == v19)
    {
      if (!__stlxr(v19 & 0xFFFFFFFFFFFFFFF7 | v20, v9))
      {
        v22 = 1;
        goto LABEL_21;
      }
    }
    else
    {
      __clrex();
    }
    v22 = 0;
LABEL_21:
    v19 = v21;
  }
  while (!v22);
  cf[2] = *(_QWORD *)(a3 + 16);
  v23 = atomic_load((unint64_t *)(a3 + 8));
  switch((v23 >> 4) & 7)
  {
    case 0u:
      cf[3] = *(_QWORD *)(a3 + 24);
      goto LABEL_43;
    case 1u:
      *((_DWORD *)cf + 6) = *(_DWORD *)(a3 + 24);
      cf[4] = *(_QWORD *)(a3 + 32);
      goto LABEL_43;
    case 2u:
      Typed = (void *)CFAllocatorAllocateTyped(alloc, 128, 0x1000040BDFB0063, 0);
      cf[3] = (unint64_t)Typed;
      cf[4] = *(_QWORD *)(a3 + 32);
      alloc = (char *)memmove(Typed, *(const void **)(a3 + 24), 2 * *(_QWORD *)(a3 + 32));
      goto LABEL_43;
    case 3u:
      v25 = *(unsigned __int8 **)(a3 + 24);
      if (v25)
      {
        if ((a4 & 1) == 0)
        {
          alloc = (char *)__CFCreateCompactBitmap((uint64_t)alloc, v25);
          if (alloc)
          {
            cf[3] = (unint64_t)alloc;
            v26 = atomic_load(cf + 1);
            while (1)
            {
              v27 = __ldaxr(v9);
              if (v27 != v26)
                break;
              if (__stlxr(v26 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v9))
                goto LABEL_34;
              v28 = 1;
LABEL_35:
              v26 = v27;
              if ((v28 & 1) != 0)
                goto LABEL_43;
            }
            __clrex();
LABEL_34:
            v28 = 0;
            goto LABEL_35;
          }
        }
        v43 = (void *)CFAllocatorAllocateTyped(v6, 0x2000, 0x100004077774924, 0);
        alloc = (char *)memmove(v43, *(const void **)(a3 + 24), 0x2000uLL);
        cf[3] = (unint64_t)v43;
      }
      else
      {
        cf[3] = 0;
      }
LABEL_43:
      v44 = *(_QWORD *)(a3 + 40);
      if (!v44)
        return alloc;
      if (!*(_DWORD *)(v44 + 8))
      {
        if (*(_BYTE *)(v44 + 13))
        {
          alloc = (char *)cf[5];
          if (!alloc)
            goto LABEL_70;
          goto LABEL_67;
        }
        return alloc;
      }
      v45 = 0;
      v46 = 1;
      break;
    case 4u:
      v29 = *(char **)(a3 + 24);
      if (v29)
      {
        v30 = 0;
        v31 = (int32x4_t)xmmword_182C87B30;
        v32 = 0uLL;
        v33.i64[0] = -1;
        v33.i64[1] = -1;
        v34.i64[0] = 0xFEFEFEFEFEFEFEFELL;
        v34.i64[1] = 0xFEFEFEFEFEFEFEFELL;
        v35.i64[0] = 0x2000000020;
        v35.i64[1] = 0x2000000020;
        v36 = 0uLL;
        v37 = 0uLL;
        do
        {
          v38 = (int8x16_t)vcgtq_u8(v34, (uint8x16_t)vaddq_s8(*(int8x16_t *)&v29[v30], v33));
          v39 = vmovl_s8(*(int8x8_t *)v38.i8);
          v40 = vmovl_high_s8(v38);
          v37 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v40), (int8x16_t)vaddq_s32(v37, v35), (int8x16_t)v37);
          v36 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v40.i8), (int8x16_t)vaddq_s32(v36, v35), (int8x16_t)v36);
          v32 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v39), (int8x16_t)vaddq_s32(v32, v35), (int8x16_t)v32);
          v31 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v39.i8), (int8x16_t)vaddq_s32(v31, v35), (int8x16_t)v31);
          v30 += 16;
        }
        while (v30 != 256);
        v41 = vaddvq_s32(vaddq_s32(vaddq_s32(v31, v36), vaddq_s32(v32, v37)));
        v42 = (void *)CFAllocatorAllocateTyped(alloc, v41, 1792907336, 0);
        alloc = (char *)memmove(v42, v29, v41);
        cf[3] = (unint64_t)v42;
      }
      goto LABEL_43;
    default:
      goto LABEL_43;
  }
  while (2)
  {
    v47 = *(_QWORD *)(a3 + 40);
    if (v47)
    {
      v48 = 1 << v46;
      if ((*(_DWORD *)(v47 + 8) & (1 << v46)) != 0
        && *(unsigned __int8 *)(v47 + 12) >= v46)
      {
        v49 = *(const void **)(*(_QWORD *)v47 + v45);
        if (v49)
        {
          Copy = (const void *)__CFCharacterSetCreateCopy(v6, v49);
          v51 = cf[5];
          if (!v51)
          {
            v55 = CFGetAllocator(cf);
            v56 = CFAllocatorAllocateTyped(v55, 16, 0x1080040FC6463CFLL, 0);
            cf[5] = v56;
            *(_WORD *)(v56 + 12) = v46;
            *(_DWORD *)(v56 + 8) = 0;
            v53 = CFGetAllocator(cf);
            goto LABEL_55;
          }
          if (*(unsigned __int8 *)(v51 + 12) < v46)
          {
            *(_BYTE *)(v51 + 12) = v46;
            v52 = *(_QWORD *)v51;
            v53 = CFGetAllocator(cf);
            if (v52)
            {
              v54 = __CFSafelyReallocateWithAllocatorTyped(v53, *(_QWORD *)cf[5], v45 + 8, 0x6004044C4A2DFLL, 0, 0);
              goto LABEL_56;
            }
LABEL_55:
            v54 = CFAllocatorAllocateTyped(v53, v45 + 8, 0x6004044C4A2DFLL, 0);
LABEL_56:
            v51 = cf[5];
            *(_QWORD *)v51 = v54;
          }
          if ((*(_DWORD *)(v51 + 8) & v48) != 0)
            CFRelease(*(CFTypeRef *)(*(_QWORD *)v51 + v45));
          if (Copy)
          {
            *(_QWORD *)(*(_QWORD *)cf[5] + v45) = CFRetain(Copy);
            v57 = cf[5];
            v58 = *(_DWORD *)(v57 + 8) | v48;
          }
          else
          {
            v57 = cf[5];
            v58 = *(_DWORD *)(v57 + 8) & ~v48;
          }
          *(_DWORD *)(v57 + 8) = v58;
          CFRelease(Copy);
        }
      }
    }
    ++v46;
    v45 += 8;
    if (v46 != 17)
      continue;
    break;
  }
  v59 = *(_QWORD *)(a3 + 40);
  if (v59)
  {
    alloc = (char *)cf[5];
    if (*(_BYTE *)(v59 + 13))
    {
      if (alloc)
        goto LABEL_67;
LABEL_70:
      v61 = CFGetAllocator(cf);
      alloc = (char *)CFAllocatorAllocateTyped(v61, 16, 0x1080040FC6463CFLL, 0);
      cf[5] = (unint64_t)alloc;
      *(_QWORD *)(alloc + 6) = 0;
      *(_QWORD *)alloc = 0;
LABEL_67:
      v60 = 1;
LABEL_74:
      alloc[13] = v60;
      return alloc;
    }
  }
  else
  {
    alloc = (char *)cf[5];
  }
  if (alloc)
  {
    v60 = 0;
    goto LABEL_74;
  }
  return alloc;
}

void CFCharacterSetInvert(CFMutableCharacterSetRef theSet)
{
  unint64_t *v2;
  char v3;
  char v4;
  char v5;
  char v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  char v10;
  uint64_t v11;
  uint64_t i;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BYTE *v17;
  char v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  uint64_t v23;
  CFAllocatorRef v24;
  BOOL v25;
  CFAllocatorRef v26;
  void *Typed;
  CFAllocatorRef v28;

  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    -[__CFCharacterSet invert](theSet, "invert");
    return;
  }
  v2 = (unint64_t *)((char *)theSet + 8);
  v3 = atomic_load((unint64_t *)theSet + 1);
  if ((v3 & 1) == 0)
  {
    CFLog(3, CFSTR("%s: Immutable character set passed to mutable function"));
    if (dyld_program_sdk_at_least())
      CFCharacterSetInvert_cold_1();
  }
  v4 = atomic_load(v2);
  if ((v4 & 0x70) != 0
    || (v5 = atomic_load(v2), (v5 & 1) != 0)
    || (v6 = atomic_load(v2), (v6 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    v7 = atomic_load(v2);
    while (1)
    {
      v8 = __ldaxr(v2);
      if (v8 != v7)
        break;
      if (__stlxr(v7 & 0xFFFFFFFFFFFFFFFBLL, v2))
        goto LABEL_15;
      v9 = 1;
LABEL_16:
      v7 = v8;
      if (v9)
      {
        v10 = atomic_load(v2);
        if ((v10 & 0x70) == 0x30)
        {
          v11 = *((_QWORD *)theSet + 3);
          if (v11)
          {
            for (i = 0; i != 0x2000; i += 16)
              *(int8x16_t *)(v11 + i) = vmvnq_s8(*(int8x16_t *)(v11 + i));
          }
          else
          {
            v26 = CFGetAllocator(theSet);
            Typed = (void *)CFAllocatorAllocateTyped(v26, 0x2000, 654288840, 0);
            *((_QWORD *)theSet + 3) = Typed;
            memset(Typed, 255, 0x2000uLL);
          }
LABEL_44:
          v23 = *((_QWORD *)theSet + 5);
          if (!v23)
          {
            v28 = CFGetAllocator(theSet);
            v23 = CFAllocatorAllocateTyped(v28, 16, 0x1080040FC6463CFLL, 0);
            *((_QWORD *)theSet + 5) = v23;
            *(_QWORD *)(v23 + 6) = 0;
            *(_QWORD *)v23 = 0;
          }
          goto LABEL_46;
        }
        v13 = atomic_load(v2);
        if ((v13 & 0x70) == 0x40)
        {
          v14 = 0;
          LODWORD(v15) = 0;
          v16 = *((_QWORD *)theSet + 3);
          do
          {
            if (*(unsigned __int8 *)(v16 + v14) == 255)
            {
              *(_BYTE *)(v16 + v14) = 0;
            }
            else if (*(_BYTE *)(v16 + v14))
            {
              LODWORD(v15) = v15 + 32;
            }
            else
            {
              *(_BYTE *)(v16 + v14) = -1;
            }
            ++v14;
          }
          while (v14 != 256);
          if ((int)v15 >= 1)
          {
            v17 = (_BYTE *)(v16 + 256);
            v15 = v15;
            do
            {
              *v17 = ~*v17;
              ++v17;
              --v15;
            }
            while (v15);
          }
          goto LABEL_44;
        }
        v18 = atomic_load(v2);
        v19 = atomic_load(v2);
        v20 = v18 & 8;
        while (2)
        {
          v21 = __ldaxr(v2);
          if (v21 == v19)
          {
            if (!__stlxr((v19 & 0xFFFFFFFFFFFFFFF7 | v20) ^ 8, v2))
            {
              v22 = 1;
              goto LABEL_40;
            }
          }
          else
          {
            __clrex();
          }
          v22 = 0;
LABEL_40:
          v19 = v21;
          if (v22)
          {
            v23 = *((_QWORD *)theSet + 5);
            if (!v23)
            {
              v24 = CFGetAllocator(theSet);
              v23 = CFAllocatorAllocateTyped(v24, 16, 0x1080040FC6463CFLL, 0);
              *((_QWORD *)theSet + 5) = v23;
              *(_QWORD *)v23 = 0;
              *(_QWORD *)(v23 + 6) = 0;
              v25 = 1;
              goto LABEL_47;
            }
LABEL_46:
            v25 = *(_BYTE *)(v23 + 13) == 0;
LABEL_47:
            *(_BYTE *)(v23 + 13) = v25;
            return;
          }
          continue;
        }
      }
    }
    __clrex();
LABEL_15:
    v9 = 0;
    goto LABEL_16;
  }
}

void CFCharacterSetAddCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
  unint64_t *v4;
  char v5;
  char v6;
  char v7;
  char v8;
  uint64_t v9;
  unsigned int v10;
  char v11;
  CFIndex Length;
  CFIndex v13;
  char v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  char v18;
  size_t v19;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v22;
  int64_t v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  UniChar v27;
  int64_t v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int64_t v33;
  CFIndex v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  uint64_t v38;
  UniChar *Typed;
  CFAllocatorRef v40;
  char v41;
  UniChar *v42;
  UniChar *v43;
  UniChar *v44;
  unint64_t v45;
  unint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned __int16 *v52;
  __int16 v53;
  int v54;
  const __CFAllocator *v55;
  unint64_t v56;
  unint64_t v57;
  int v58;
  UniChar buffer[8];
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  CFStringRef theStringa;
  const UniChar *v68;
  const char *v69;
  uint64_t v70;
  CFIndex v71;
  int64_t v72;
  int64_t v73;
  uint64_t v74;
  CFRange v75;
  CFRange v76;

  v74 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    -[__CFCharacterSet addCharactersInString:](theSet, "addCharactersInString:", theString);
    return;
  }
  v4 = (unint64_t *)((char *)theSet + 8);
  v5 = atomic_load((unint64_t *)theSet + 1);
  if ((v5 & 1) == 0)
  {
    CFLog(3, CFSTR("%s: Immutable character set passed to mutable function"));
    if (dyld_program_sdk_at_least())
      CFCharacterSetAddCharactersInString_cold_1();
  }
  v6 = atomic_load(v4);
  if ((v6 & 0x70) != 0
    || (v7 = atomic_load(v4), (v7 & 1) != 0)
    || (v8 = atomic_load(v4), (v8 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    v9 = *((_QWORD *)theSet + 5);
    if (v9)
    {
      if (*(_DWORD *)(v9 + 8) || *(_BYTE *)(v9 + 13))
        goto LABEL_18;
    }
    v10 = atomic_load(v4);
    switch((v10 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*((_QWORD *)theSet + 4))
          goto LABEL_18;
        break;
      case 3u:
      case 4u:
        if (*((_QWORD *)theSet + 3))
          goto LABEL_18;
        break;
      default:
        goto LABEL_18;
    }
    v11 = atomic_load(v4);
    if ((v11 & 8) == 0)
    {
LABEL_18:
      Length = CFStringGetLength(theString);
      if (!Length)
        return;
      v13 = Length;
      v14 = atomic_load(v4);
      if ((v14 & 8) != 0)
        goto LABEL_31;
      v15 = *((_QWORD *)theSet + 5);
      if (v15 && (*(_DWORD *)(v15 + 8) || *(_BYTE *)(v15 + 13)))
      {
LABEL_27:
        v18 = atomic_load(v4);
        v17 = (v18 & 0x70) == 0x20 ? *((_QWORD *)theSet + 4) : 64;
      }
      else
      {
        v16 = atomic_load(v4);
        switch((v16 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (*((_QWORD *)theSet + 4))
              goto LABEL_27;
            break;
          case 3u:
          case 4u:
            if (*((_QWORD *)theSet + 3))
              goto LABEL_27;
            break;
          default:
            goto LABEL_27;
        }
        v17 = 0;
      }
      v19 = v17 + Length;
      if (v17 + Length > 63)
      {
LABEL_31:
        __CFCSetMakeBitmap((char *)theSet);
        v65 = 0u;
        v66 = 0u;
        v63 = 0u;
        v64 = 0u;
        v61 = 0u;
        v62 = 0u;
        *(_OWORD *)buffer = 0u;
        v60 = 0u;
        theStringa = theString;
        v70 = 0;
        v71 = v13;
        CharactersPtr = CFStringGetCharactersPtr(theString);
        CStringPtr = 0;
        v68 = CharactersPtr;
        if (!CharactersPtr)
          CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
        v72 = 0;
        v73 = 0;
        v69 = CStringPtr;
        if (v13 < 1)
        {
          v24 = 0;
        }
        else
        {
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v25 = 64;
          do
          {
            if ((unint64_t)v23 >= 4)
              v26 = 4;
            else
              v26 = v23;
            if (v68)
            {
              v27 = v68[v23 + v70];
            }
            else if (v69)
            {
              v27 = v69[v70 + v23];
            }
            else
            {
              v28 = v72;
              if (v73 <= v23 || v72 > v23)
              {
                v30 = -v26;
                v31 = v26 + v22;
                v32 = v25 - v26;
                v33 = v23 + v30;
                v34 = v33 + 64;
                if (v33 + 64 >= v71)
                  v34 = v71;
                v72 = v33;
                v73 = v34;
                if (v71 < v32)
                  v32 = v71;
                v75.length = v32 + v31;
                v75.location = v33 + v70;
                CFStringGetCharacters(theStringa, v75, buffer);
                v28 = v72;
              }
              v27 = buffer[v23 - v28];
            }
            if ((v27 & 0xF800 | 0x400) == 0xDC00)
              v24 = 1;
            else
              *(_BYTE *)(*((_QWORD *)theSet + 3) + (v27 >> 3)) |= 1 << (v27 & 7);
            ++v23;
            --v22;
            ++v25;
          }
          while (v13 != v23);
        }
        v35 = atomic_load(v4);
        while (1)
        {
          v36 = __ldaxr(v4);
          if (v36 != v35)
            break;
          if (__stlxr(v35 & 0xFFFFFFFFFFFFFFFBLL, v4))
            goto LABEL_63;
          v37 = 1;
LABEL_64:
          v35 = v36;
          if (v37)
          {
            if (__CFCheckForExapendedSet == 1)
              __CFCheckForExpandedSet((const char *)theSet);
            if ((v24 & 1) != 0)
              __CFApplySurrogatesInString((uint64_t)theSet, theString, (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetAddCharactersInRange);
            return;
          }
        }
        __clrex();
LABEL_63:
        v37 = 0;
        goto LABEL_64;
      }
      v38 = *((_QWORD *)theSet + 3);
      if (v38)
      {
        Typed = (UniChar *)(v38 + 2 * *((_QWORD *)theSet + 4));
      }
      else
      {
        v40 = CFGetAllocator(theSet);
        Typed = (UniChar *)CFAllocatorAllocateTyped(v40, 128, 0x1000040BDFB0063, 0);
      }
      v76.location = 0;
      v76.length = v13;
      CFStringGetCharacters(theString, v76, Typed);
      if (v13 < 2)
      {
        v41 = 0;
      }
      else
      {
        v41 = 0;
        v42 = Typed;
        v43 = &Typed[v13];
        do
        {
          if ((*v42 & 0xF800 | 0x400) == 0xDC00)
          {
            memmove(v42, v42 + 1, (char *)v43-- - (char *)(v42 + 1));
            v41 = 1;
          }
          else
          {
            ++v42;
          }
        }
        while (v42 < v43);
        v19 = v17 + v43 - Typed;
      }
      v44 = (UniChar *)*((_QWORD *)theSet + 3);
      if (!v19)
      {
        if (!v44)
        {
          v55 = CFGetAllocator(theSet);
          CFAllocatorDeallocate(v55, Typed);
        }
        goto LABEL_99;
      }
      if (v44)
        goto LABEL_90;
      v45 = atomic_load(v4);
      while (1)
      {
        v46 = __ldaxr(v4);
        if (v46 != v45)
          break;
        if (__stlxr(v45 & 0xFFFFFFFFFFFFFF8FLL | 0x20, v4))
          goto LABEL_87;
        v47 = 1;
LABEL_88:
        v45 = v46;
        if (v47)
        {
          *((_QWORD *)theSet + 3) = Typed;
          v44 = Typed;
LABEL_90:
          *((_QWORD *)theSet + 4) = v19;
          qsort(v44, v19, 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
          v48 = *((_QWORD *)theSet + 4);
          if (v48 >= 2)
          {
            v49 = 0;
            v50 = *((_QWORD *)theSet + 3);
            v51 = v48 - 1;
            v52 = (unsigned __int16 *)(v50 + 2);
            do
            {
              v54 = *v52++;
              v53 = v54;
              if (*(unsigned __int16 *)(v50 + 2 * v49) != v54)
              {
                ++v49;
                *(_WORD *)(v50 + 2 * v49) = v53;
              }
              --v51;
            }
            while (v51);
            v48 = v49 + 1;
          }
          *((_QWORD *)theSet + 4) = v48;
LABEL_99:
          v56 = atomic_load(v4);
          while (2)
          {
            v57 = __ldaxr(v4);
            if (v57 == v56)
            {
              if (!__stlxr(v56 & 0xFFFFFFFFFFFFFFFBLL, v4))
              {
                v58 = 1;
                goto LABEL_105;
              }
            }
            else
            {
              __clrex();
            }
            v58 = 0;
LABEL_105:
            v56 = v57;
            if (v58)
            {
              if ((v41 & 1) != 0)
                __CFApplySurrogatesInString((uint64_t)theSet, theString, (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetAddCharactersInRange);
              return;
            }
            continue;
          }
        }
      }
      __clrex();
LABEL_87:
      v47 = 0;
      goto LABEL_88;
    }
  }
}

void CFCharacterSetRemoveCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
  CFIndex length;
  unint64_t location;
  unint64_t *v5;
  char v6;
  unint64_t v7;
  char v8;
  char v9;
  char v10;
  char v11;
  uint64_t v12;
  unsigned int v13;
  char v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t i;
  uint64_t v19;
  const __CFAllocator *v20;
  const __CFAllocator *v21;
  uint64_t v22;
  const __CFAllocator *v23;
  uint64_t v24;
  unsigned int v25;
  char v26;
  unint64_t v27;
  CFIndex v28;
  unint64_t v29;
  unint64_t v30;
  char v31;
  CFIndex v32;
  int v33;
  int v34;
  uint64_t v35;
  __int16 v36;
  int v37;
  BOOL v38;
  uint64_t v39;
  CFIndex v40;
  uint64_t *v41;
  uint64_t v42;
  CFAllocatorRef v43;
  uint64_t Typed;
  uint64_t v45;
  unsigned int v46;
  unint64_t *v47;
  unint64_t v48;
  unsigned int v49;
  uint64_t v50;
  const __CFAllocator *v51;
  CFMutableCharacterSetRef Mutable;
  __CFCharacterSet *v53;
  char v54;
  char v55;
  uint64_t v56;
  CFIndex v57;
  uint64_t v58;
  CFAllocatorRef v59;
  _WORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned __int16 *v65;
  __int16 v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  char v70;
  uint64_t v71;
  unsigned __int16 v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  char v79;
  unint64_t v80;
  unint64_t v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  char v85;
  unint64_t v86;
  unint64_t v87;
  int v88;
  unint64_t v89;
  unint64_t v90;
  char v91;
  CFIndex v92;
  uint64_t v93;
  uint64_t v94;
  CFRange v95;
  CFRange v96;

  length = theRange.length;
  location = theRange.location;
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    -[__CFCharacterSet removeCharactersInRange:](theSet, "removeCharactersInRange:", location, length);
    return;
  }
  v5 = (unint64_t *)((char *)theSet + 8);
  v6 = atomic_load((unint64_t *)theSet + 1);
  if ((v6 & 1) == 0)
  {
    CFLog(3, CFSTR("%s: Immutable character set passed to mutable function"));
    if (dyld_program_sdk_at_least())
      CFCharacterSetRemoveCharactersInRange_cold_1();
  }
  if (location >> 16 > 0x10 || length >= 1114113 || (v7 = location + length, location + length >= 0x110001))
  {
    CFLog(3, CFSTR("%s: Range (location: %ld, length: %ld) outside of valid Unicode range (0x0 - 0x10FFFF)"));
    qword_1EDCD1038 = (uint64_t)"CFCharacterSet range is outside of valid Unicode range (0x0 - 0x10FFFF)";
LABEL_169:
    __break(1u);
    return;
  }
  v8 = atomic_load(v5);
  if ((v8 & 0x70) != 0
    || (v9 = atomic_load(v5), (v9 & 1) != 0)
    || (v10 = atomic_load(v5), (v10 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    if (length)
    {
      v11 = atomic_load(v5);
      if ((v11 & 8) == 0)
      {
        v12 = *((_QWORD *)theSet + 5);
        if (!v12 || !*(_DWORD *)(v12 + 8) && !*(_BYTE *)(v12 + 13))
        {
          v13 = atomic_load(v5);
          switch((v13 >> 4) & 7)
          {
            case 1u:
            case 2u:
              if (*((_QWORD *)theSet + 4))
                goto LABEL_22;
              break;
            case 3u:
            case 4u:
              if (*((_QWORD *)theSet + 3))
                goto LABEL_22;
              break;
            default:
              goto LABEL_22;
          }
          return;
        }
      }
LABEL_22:
      v14 = atomic_load(v5);
      if ((v14 & 8) == 0)
        goto LABEL_23;
      v24 = *((_QWORD *)theSet + 5);
      if (!v24 || !*(_DWORD *)(v24 + 8) && !*(_BYTE *)(v24 + 13))
      {
        v25 = atomic_load(v5);
        switch((v25 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (*((_QWORD *)theSet + 4))
              goto LABEL_47;
            break;
          case 3u:
          case 4u:
            if (*((_QWORD *)theSet + 3))
              goto LABEL_47;
            break;
          default:
            goto LABEL_47;
        }
        v80 = atomic_load(v5);
        while (1)
        {
          v81 = __ldaxr(v5);
          if (v81 != v80)
            break;
          if (__stlxr(v80 & 0xFFFFFFFFFFFFFF8FLL | 0x10, v5))
            goto LABEL_137;
          v82 = 1;
LABEL_138:
          v80 = v81;
          if (v82)
          {
            *((_DWORD *)theSet + 6) = location;
            *((_QWORD *)theSet + 4) = length;
            v83 = atomic_load((unint64_t *)theSet + 1);
            while (1)
            {
              v84 = __ldaxr(v5);
              if (v84 != v83)
                break;
              if (__stlxr(v83 & 0xFFFFFFFFFFFFFFFBLL, v5))
                goto LABEL_144;
              v85 = 1;
LABEL_145:
              v83 = v84;
              if ((v85 & 1) != 0)
                return;
            }
            __clrex();
LABEL_144:
            v85 = 0;
            goto LABEL_145;
          }
        }
        __clrex();
LABEL_137:
        v82 = 0;
        goto LABEL_138;
      }
LABEL_47:
      v26 = atomic_load(v5);
      if ((v26 & 0x70) == 0x10)
      {
        v27 = *((unsigned int *)theSet + 6);
        v28 = *((_QWORD *)theSet + 4);
        if (v27 == location)
        {
          if (v28 >= length)
            v28 = length;
          *((_QWORD *)theSet + 4) = v28;
          v29 = atomic_load((unint64_t *)theSet + 1);
          while (1)
          {
            v30 = __ldaxr(v5);
            if (v30 != v29)
              break;
            if (__stlxr(v29 & 0xFFFFFFFFFFFFFFFBLL, v5))
              goto LABEL_56;
            v31 = 1;
LABEL_57:
            v29 = v30;
            if ((v31 & 1) != 0)
              return;
          }
          __clrex();
LABEL_56:
          v31 = 0;
          goto LABEL_57;
        }
        if (v27 >= location || (uint64_t)location > (uint64_t)(v28 + v27))
        {
          if (v27 > location && v7 >= v27)
          {
            *((_DWORD *)theSet + 6) = location;
            *((_QWORD *)theSet + 4) = v27 - location + v28;
            v77 = atomic_load((unint64_t *)theSet + 1);
            while (1)
            {
              v78 = __ldaxr(v5);
              if (v78 != v77)
                break;
              if (__stlxr(v77 & 0xFFFFFFFFFFFFFFFBLL, v5))
                goto LABEL_128;
              v79 = 1;
LABEL_129:
              v77 = v78;
              if ((v79 & 1) != 0)
                return;
            }
            __clrex();
LABEL_128:
            v79 = 0;
            goto LABEL_129;
          }
LABEL_23:
          v92 = length;
          v94 = location;
          __CFCSetMakeBitmap((char *)theSet);
          v93 = location + length;
          v15 = v7 - 1;
          if ((location >> 16) <= 1)
            v16 = 1;
          else
            v16 = location >> 16;
          if (v16 <= v15 >> 16)
          {
            v32 = (unsigned __int16)location;
            v33 = v15 >> 16;
            v34 = (unsigned __int16)v93;
            v35 = (unsigned __int16)v93;
            v36 = 8 * v16;
            v37 = (v15 >> 16) + 1;
            do
            {
              if (v34)
                v38 = v33 == v16;
              else
                v38 = 0;
              if (v38)
                v39 = v35;
              else
                v39 = 0x10000;
              v40 = v39 - v32;
              v41 = (uint64_t *)*((_QWORD *)theSet + 5);
              if (v41 && *((_BYTE *)v41 + 13))
              {
                if (!(_BYTE)v16)
                  goto LABEL_169;
                if (v16 <= 0x10u)
                {
                  if (*((unsigned __int8 *)v41 + 12) < v16)
                  {
                    *((_BYTE *)v41 + 12) = v16;
                    v42 = *v41;
                    v43 = CFGetAllocator(theSet);
                    if (v42)
                      Typed = __CFSafelyReallocateWithAllocatorTyped(v43, **((_QWORD **)theSet + 5), v36 & 0x7F8, 0x6004044C4A2DFLL, 0, 0);
                    else
                      Typed = CFAllocatorAllocateTyped(v43, v36 & 0x7F8, 0x6004044C4A2DFLL, 0);
                    v41 = (uint64_t *)*((_QWORD *)theSet + 5);
                    *v41 = Typed;
                    v35 = (unsigned __int16)v93;
                  }
                  if (((_DWORD)v41[1] & (1 << v16)) != 0)
                  {
                    v50 = v16 - 1;
                  }
                  else
                  {
                    v51 = CFGetAllocator(theSet);
                    Mutable = CFCharacterSetCreateMutable(v51);
                    v35 = (unsigned __int16)v93;
                    v50 = v16 - 1;
                    *(_QWORD *)(**((_QWORD **)theSet + 5) + 8 * v50) = Mutable;
                    v41 = (uint64_t *)*((_QWORD *)theSet + 5);
                    *((_DWORD *)v41 + 2) |= 1 << v16;
                  }
                  v34 = (unsigned __int16)v93;
                  v53 = *(__CFCharacterSet **)(*v41 + 8 * v50);
                  if (v53)
                  {
                    v96.location = v32;
                    v96.length = v40;
                    CFCharacterSetAddCharactersInRange(v53, v96);
                    v35 = (unsigned __int16)v93;
                  }
                }
              }
              else
              {
                if (!(_BYTE)v16)
                  goto LABEL_169;
                if (v16 <= 0x10u)
                {
                  if (v41)
                  {
                    if (((*((_DWORD *)v41 + 2) >> v16) & 1) != 0
                      && *((unsigned __int8 *)v41 + 12) >= v16)
                    {
                      v45 = *v41;
                      v46 = v16 - 1;
                      v47 = *(unint64_t **)(v45 + 8 * v46);
                      if (v47)
                      {
                        v95.location = v32;
                        v95.length = v40;
                        CFCharacterSetRemoveCharactersInRange(*(CFMutableCharacterSetRef *)(v45 + 8 * v46), v95);
                        v35 = (unsigned __int16)v93;
                        v48 = v47[5];
                        if (!v48 || !*(_DWORD *)(v48 + 8) && !*(_BYTE *)(v48 + 13))
                        {
                          v49 = atomic_load(v47 + 1);
                          switch((v49 >> 4) & 7)
                          {
                            case 1u:
                            case 2u:
                              if (!v47[4])
                                goto LABEL_95;
                              break;
                            case 3u:
                            case 4u:
                              if (!v47[3])
                              {
LABEL_95:
                                v54 = atomic_load(v47 + 1);
                                if ((v54 & 8) == 0)
                                {
                                  CFRelease(v47);
                                  v35 = (unsigned __int16)v93;
                                  *(_DWORD *)(*((_QWORD *)theSet + 5) + 8) &= ~(1 << v16);
                                }
                              }
                              break;
                            default:
                              break;
                          }
                        }
                      }
                    }
                  }
                }
              }
              ++v16;
              v36 += 8;
            }
            while (v37 != v16);
          }
          v17 = *((_QWORD *)theSet + 5);
          if (v17 && !*(_DWORD *)(v17 + 8) && !*(_BYTE *)(v17 + 13))
          {
            for (i = 0; i != 16; ++i)
            {
              v19 = *((_QWORD *)theSet + 5);
              if (((*(_DWORD *)(v19 + 8) >> i) & 2) != 0)
                CFRelease(*(CFTypeRef *)(*(_QWORD *)v19 + 8 * i));
            }
            v20 = CFGetAllocator(theSet);
            CFAllocatorDeallocate(v20, **((void ***)theSet + 5));
            v21 = CFGetAllocator(theSet);
            CFAllocatorDeallocate(v21, *((void **)theSet + 5));
            *((_QWORD *)theSet + 5) = 0;
          }
          if (v94 < 0x10000)
          {
            if (v93 <= 0x10000)
              v22 = v92;
            else
              v22 = 0x10000 - v94;
            if (v94 || v22 != 0x10000)
            {
              v71 = *((_QWORD *)theSet + 3);
              v72 = v22 + v94 - 1;
              v73 = (unsigned __int16)v94 >> 3;
              v74 = v72;
              v75 = v72 >> 3;
              v76 = 255 << (v94 & 7);
              if ((_DWORD)v75 == (_DWORD)v73)
              {
                *(_BYTE *)(v71 + v73) &= ~((0xFFu >> (~(_BYTE)v74 & 7)) & v76);
              }
              else
              {
                *(_BYTE *)(v71 + v73) &= ~(_BYTE)v76;
                *(_BYTE *)(v71 + v75) &= -256 >> (~(_BYTE)v74 & 7);
                if (((unint64_t)(unsigned __int16)v94 >> 3) + 1 < (v74 >> 3))
                  bzero((void *)(v73 + v71 + 1), (v75 - v73 - 2) + 1);
              }
            }
            else
            {
              v23 = CFGetAllocator(theSet);
              CFAllocatorDeallocate(v23, *((void **)theSet + 3));
              *((_QWORD *)theSet + 3) = 0;
            }
          }
          v86 = atomic_load(v5);
          while (1)
          {
            v87 = __ldaxr(v5);
            if (v87 != v86)
              break;
            if (__stlxr(v86 & 0xFFFFFFFFFFFFFFFBLL, v5))
              goto LABEL_154;
            v88 = 1;
LABEL_155:
            v86 = v87;
            if (v88)
            {
              if (__CFCheckForExapendedSet == 1)
                __CFCheckForExpandedSet((const char *)theSet);
              return;
            }
          }
          __clrex();
LABEL_154:
          v88 = 0;
          goto LABEL_155;
        }
        if ((uint64_t)(v28 + v27) < (uint64_t)v7)
          *((_QWORD *)theSet + 4) = v7 - v27;
        v89 = atomic_load(v5);
        while (1)
        {
          v90 = __ldaxr(v5);
          if (v90 != v89)
            break;
          if (__stlxr(v89 & 0xFFFFFFFFFFFFFFFBLL, v5))
            goto LABEL_165;
          v91 = 1;
LABEL_166:
          v89 = v90;
          if ((v91 & 1) != 0)
            return;
        }
        __clrex();
LABEL_165:
        v91 = 0;
        goto LABEL_166;
      }
      v55 = atomic_load(v5);
      if ((v55 & 0x70) != 0x20)
        goto LABEL_23;
      v56 = *((_QWORD *)theSet + 4);
      v57 = v56 + length;
      if (v56 + length > 63)
        goto LABEL_23;
      v58 = *((_QWORD *)theSet + 3);
      if (!v58)
      {
        v59 = CFGetAllocator(theSet);
        v58 = CFAllocatorAllocateTyped(v59, 128, 0x1000040BDFB0063, 0);
        *((_QWORD *)theSet + 3) = v58;
        v56 = *((_QWORD *)theSet + 4);
        v57 = v56 + length;
      }
      *((_QWORD *)theSet + 4) = v57;
      v60 = (_WORD *)(v58 + 2 * v56);
      do
      {
        *v60++ = location++;
        --length;
      }
      while (length);
      qsort(*((void **)theSet + 3), *((_QWORD *)theSet + 4), 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
      v61 = *((_QWORD *)theSet + 4);
      if (v61 >= 2)
      {
        v62 = 0;
        v63 = *((_QWORD *)theSet + 3);
        v64 = v61 - 1;
        v65 = (unsigned __int16 *)(v63 + 2);
        do
        {
          v67 = *v65++;
          v66 = v67;
          if (*(unsigned __int16 *)(v63 + 2 * v62) != v67)
          {
            ++v62;
            *(_WORD *)(v63 + 2 * v62) = v66;
          }
          --v64;
        }
        while (v64);
        v61 = v62 + 1;
      }
      *((_QWORD *)theSet + 4) = v61;
      v68 = atomic_load((unint64_t *)theSet + 1);
      while (1)
      {
        v69 = __ldaxr(v5);
        if (v69 != v68)
          break;
        if (__stlxr(v68 & 0xFFFFFFFFFFFFFFFBLL, v5))
          goto LABEL_114;
        v70 = 1;
LABEL_115:
        v68 = v69;
        if ((v70 & 1) != 0)
          return;
      }
      __clrex();
LABEL_114:
      v70 = 0;
      goto LABEL_115;
    }
  }
}

void CFCharacterSetAddCharactersInRange(CFMutableCharacterSetRef theSet, CFRange theRange)
{
  CFIndex length;
  unint64_t location;
  unint64_t *v5;
  char v6;
  unint64_t v7;
  char v8;
  char v9;
  char v10;
  char v11;
  uint64_t v12;
  unsigned int v13;
  char v14;
  uint64_t v15;
  unsigned int v16;
  char v17;
  unint64_t v18;
  CFIndex v19;
  CFIndex v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  char v24;
  uint64_t v25;
  CFIndex v26;
  uint64_t Typed;
  CFAllocatorRef v28;
  _WORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int16 *v34;
  __int16 v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  char v39;
  int64_t v40;
  unint64_t v41;
  unint64_t v42;
  char v43;
  uint64_t v44;
  int v45;
  unsigned __int16 v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  char v55;
  unint64_t v56;
  unint64_t v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  char v61;

  length = theRange.length;
  location = theRange.location;
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    -[__CFCharacterSet addCharactersInRange:](theSet, "addCharactersInRange:", location, length);
    return;
  }
  v5 = (unint64_t *)((char *)theSet + 8);
  v6 = atomic_load((unint64_t *)theSet + 1);
  if ((v6 & 1) == 0)
  {
    CFLog(3, CFSTR("%s: Immutable character set passed to mutable function"));
    if (dyld_program_sdk_at_least())
      CFCharacterSetAddCharactersInRange_cold_1();
  }
  if (location >> 16 > 0x10 || length >= 1114113 || (v7 = location + length, location + length >= 0x110001))
  {
    CFLog(3, CFSTR("%s: Range (location: %ld, length: %ld) outside of valid Unicode range (0x0 - 0x10FFFF)"));
    qword_1EDCD1038 = (uint64_t)"CFCharacterSet range is outside of valid Unicode range (0x0 - 0x10FFFF)";
    __break(1u);
    return;
  }
  v8 = atomic_load(v5);
  if ((v8 & 0x70) != 0
    || (v9 = atomic_load(v5), (v9 & 1) != 0)
    || (v10 = atomic_load(v5), (v10 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    if (length)
    {
      v11 = atomic_load(v5);
      if ((v11 & 8) != 0)
      {
        v12 = *((_QWORD *)theSet + 5);
        if (!v12 || !*(_DWORD *)(v12 + 8) && !*(_BYTE *)(v12 + 13))
        {
          v13 = atomic_load(v5);
          switch((v13 >> 4) & 7)
          {
            case 1u:
            case 2u:
              if (*((_QWORD *)theSet + 4))
                goto LABEL_22;
              break;
            case 3u:
            case 4u:
              if (*((_QWORD *)theSet + 3))
                goto LABEL_22;
              break;
            default:
              goto LABEL_22;
          }
          return;
        }
      }
LABEL_22:
      v14 = atomic_load(v5);
      if ((v14 & 8) != 0)
        goto LABEL_75;
      v15 = *((_QWORD *)theSet + 5);
      if (!v15 || !*(_DWORD *)(v15 + 8) && !*(_BYTE *)(v15 + 13))
      {
        v16 = atomic_load(v5);
        switch((v16 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (*((_QWORD *)theSet + 4))
              goto LABEL_28;
            break;
          case 3u:
          case 4u:
            if (*((_QWORD *)theSet + 3))
              goto LABEL_28;
            break;
          default:
            goto LABEL_28;
        }
        v50 = atomic_load(v5);
        while (1)
        {
          v51 = __ldaxr(v5);
          if (v51 != v50)
            break;
          if (__stlxr(v50 & 0xFFFFFFFFFFFFFF8FLL | 0x10, v5))
            goto LABEL_89;
          v52 = 1;
LABEL_90:
          v50 = v51;
          if (v52)
          {
            *((_DWORD *)theSet + 6) = location;
            *((_QWORD *)theSet + 4) = length;
            v53 = atomic_load((unint64_t *)theSet + 1);
            while (1)
            {
              v54 = __ldaxr(v5);
              if (v54 != v53)
                break;
              if (__stlxr(v53 & 0xFFFFFFFFFFFFFFFBLL, v5))
                goto LABEL_96;
              v55 = 1;
LABEL_97:
              v53 = v54;
              if ((v55 & 1) != 0)
                return;
            }
            __clrex();
LABEL_96:
            v55 = 0;
            goto LABEL_97;
          }
        }
        __clrex();
LABEL_89:
        v52 = 0;
        goto LABEL_90;
      }
LABEL_28:
      v17 = atomic_load(v5);
      if ((v17 & 0x70) == 0x10)
      {
        v18 = *((unsigned int *)theSet + 6);
        v19 = *((_QWORD *)theSet + 4);
        if (location == v18)
        {
          if (v19 <= length)
            v20 = length;
          else
            v20 = *((_QWORD *)theSet + 4);
          *((_QWORD *)theSet + 4) = v20;
          v21 = atomic_load((unint64_t *)theSet + 1);
          while (1)
          {
            v22 = __ldaxr(v5);
            if (v22 != v21)
              break;
            if (__stlxr(v21 & 0xFFFFFFFFFFFFFFFBLL, v5))
              goto LABEL_38;
            v23 = 1;
LABEL_39:
            v21 = v22;
            if ((v23 & 1) != 0)
              return;
          }
          __clrex();
LABEL_38:
          v23 = 0;
          goto LABEL_39;
        }
        if (location <= v18 || (uint64_t)location > (uint64_t)(v19 + v18))
        {
          if (location < v18 && v7 >= v18)
          {
            *((_DWORD *)theSet + 6) = location;
            v40 = v19 + v18;
            if (v40 <= (uint64_t)v7)
              v40 = location + length;
            *((_QWORD *)theSet + 4) = v40 - location;
            v41 = atomic_load((unint64_t *)theSet + 1);
            while (1)
            {
              v42 = __ldaxr(v5);
              if (v42 != v41)
                break;
              if (__stlxr(v41 & 0xFFFFFFFFFFFFFFFBLL, v5))
                goto LABEL_72;
              v43 = 1;
LABEL_73:
              v41 = v42;
              if ((v43 & 1) != 0)
                return;
            }
            __clrex();
LABEL_72:
            v43 = 0;
            goto LABEL_73;
          }
          goto LABEL_75;
        }
        if ((uint64_t)(v19 + v18) < (uint64_t)v7)
          *((_QWORD *)theSet + 4) = v7 - v18;
        v59 = atomic_load(v5);
        while (1)
        {
          v60 = __ldaxr(v5);
          if (v60 != v59)
            break;
          if (__stlxr(v59 & 0xFFFFFFFFFFFFFFFBLL, v5))
            goto LABEL_117;
          v61 = 1;
LABEL_118:
          v59 = v60;
          if ((v61 & 1) != 0)
            return;
        }
        __clrex();
LABEL_117:
        v61 = 0;
        goto LABEL_118;
      }
      v24 = atomic_load(v5);
      if ((v24 & 0x70) != 0x20 || (v25 = *((_QWORD *)theSet + 4), v26 = v25 + length, v25 + length > 63))
      {
LABEL_75:
        __CFCSetMakeBitmap((char *)theSet);
        __CFCSetAddNonBMPPlanesInRange(theSet, location, length);
        if (!(location >> 16))
        {
          v44 = *((_QWORD *)theSet + 3);
          if (v7 >> 16)
            v45 = -(int)location;
          else
            LOWORD(v45) = length;
          v46 = v45 + location - 1;
          if (v46 == (unsigned __int16)location)
          {
            *(_BYTE *)(v44 + (location >> 3)) |= 1 << (location & 7);
          }
          else
          {
            v47 = location >> 3;
            v48 = v46 >> 3;
            v49 = 255 << (location & 7);
            if ((_DWORD)v47 == v48)
            {
              *(_BYTE *)(v44 + v47) |= (0xFFu >> (~(_BYTE)v46 & 7)) & v49;
            }
            else
            {
              *(_BYTE *)(v44 + v47) |= v49;
              *(_BYTE *)(v44 + (v46 >> 3)) |= 0xFFu >> (~(_BYTE)v46 & 7);
              if ((int)v47 + 1 < v48)
                memset((void *)(v44 + (location >> 3) + 1), 255, v48 - v47 - 2 + 1);
            }
          }
        }
        v56 = atomic_load(v5);
        while (1)
        {
          v57 = __ldaxr(v5);
          if (v57 != v56)
            break;
          if (__stlxr(v56 & 0xFFFFFFFFFFFFFFFBLL, v5))
            goto LABEL_106;
          v58 = 1;
LABEL_107:
          v56 = v57;
          if (v58)
          {
            if (__CFCheckForExapendedSet == 1)
              __CFCheckForExpandedSet((const char *)theSet);
            return;
          }
        }
        __clrex();
LABEL_106:
        v58 = 0;
        goto LABEL_107;
      }
      Typed = *((_QWORD *)theSet + 3);
      if (!Typed)
      {
        v28 = CFGetAllocator(theSet);
        Typed = CFAllocatorAllocateTyped(v28, 128, 0x1000040BDFB0063, 0);
        *((_QWORD *)theSet + 3) = Typed;
        v25 = *((_QWORD *)theSet + 4);
        v26 = v25 + length;
      }
      *((_QWORD *)theSet + 4) = v26;
      v29 = (_WORD *)(Typed + 2 * v25);
      do
      {
        *v29++ = location++;
        --length;
      }
      while (length);
      qsort(*((void **)theSet + 3), *((_QWORD *)theSet + 4), 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
      v30 = *((_QWORD *)theSet + 4);
      if (v30 >= 2)
      {
        v31 = 0;
        v32 = *((_QWORD *)theSet + 3);
        v33 = v30 - 1;
        v34 = (unsigned __int16 *)(v32 + 2);
        do
        {
          v36 = *v34++;
          v35 = v36;
          if (*(unsigned __int16 *)(v32 + 2 * v31) != v36)
          {
            ++v31;
            *(_WORD *)(v32 + 2 * v31) = v35;
          }
          --v33;
        }
        while (v33);
        v30 = v31 + 1;
      }
      *((_QWORD *)theSet + 4) = v30;
      v37 = atomic_load((unint64_t *)theSet + 1);
      while (1)
      {
        v38 = __ldaxr(v5);
        if (v38 != v37)
          break;
        if (__stlxr(v37 & 0xFFFFFFFFFFFFFFFBLL, v5))
          goto LABEL_58;
        v39 = 1;
LABEL_59:
        v37 = v38;
        if ((v39 & 1) != 0)
          return;
      }
      __clrex();
LABEL_58:
      v39 = 0;
      goto LABEL_59;
    }
  }
}

void __CFCSetMakeBitmap(char *cf)
{
  unint64_t *v2;
  char v3;
  const __CFAllocator *v4;
  int8x16_t *Typed;
  char v6;
  char v7;
  void *v8;
  char v9;
  unsigned int NumberOfPlanes;
  unsigned int v11;
  unsigned __int8 v12;
  uint64_t *v13;
  uint64_t v14;
  CFAllocatorRef v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  CFAllocatorRef v21;
  CFAllocatorRef v22;
  uint64_t v23;
  CFAllocatorRef v24;
  uint64_t v25;
  _BYTE *v26;
  unsigned int v27;
  int BitmapForPlane;
  uint64_t *v29;
  uint64_t v30;
  CFAllocatorRef v31;
  uint64_t v32;
  CFAllocatorRef v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const __CFAllocator *v37;
  CFMutableCharacterSetRef Mutable;
  uint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  int v55;

  v2 = (unint64_t *)(cf + 8);
  v3 = atomic_load((unint64_t *)cf + 1);
  if ((v3 & 0x70) != 0x30 || !*((_QWORD *)cf + 3))
  {
    v4 = CFGetAllocator(cf);
    Typed = (int8x16_t *)CFAllocatorAllocateTyped(v4, 0x2000, 3746228942, 0);
    __CFCSetGetBitmap((uint64_t)cf, Typed);
    v6 = atomic_load(v2);
    if ((v6 & 0x70) != 0)
    {
      v7 = atomic_load(v2);
      if ((v7 & 0x70) == 0x40 && (v8 = (void *)*((_QWORD *)cf + 3)) != 0
        || (v9 = atomic_load(v2), (v9 & 0x70) == 0x20) && (v8 = (void *)*((_QWORD *)cf + 3)) != 0)
      {
        CFAllocatorDeallocate(v4, v8);
        *((_QWORD *)cf + 3) = 0;
      }
      else
      {
        v17 = atomic_load(v2);
        if ((v17 & 0x70) == 0x10)
        {
          v18 = *((_QWORD *)cf + 5);
          if (v18 && *(_DWORD *)(v18 + 8))
          {
            __CFCSetAddNonBMPPlanesInRange(cf, *((unsigned int *)cf + 6), *((_QWORD *)cf + 4));
          }
          else
          {
            v19 = atomic_load((unint64_t *)cf + 1);
            __CFCSetAddNonBMPPlanesInRange(cf, *((unsigned int *)cf + 6), *((_QWORD *)cf + 4));
            if ((v19 & 8) != 0)
            {
              v20 = *((_QWORD *)cf + 5);
              if (!v20)
              {
                v21 = CFGetAllocator(cf);
                v20 = CFAllocatorAllocateTyped(v21, 16, 0x1080040FC6463CFLL, 0);
                *((_QWORD *)cf + 5) = v20;
                *(_QWORD *)v20 = 0;
                *(_QWORD *)(v20 + 6) = 0;
              }
              *(_BYTE *)(v20 + 13) = 1;
            }
          }
        }
      }
      goto LABEL_73;
    }
    NumberOfPlanes = CFUniCharGetNumberOfPlanes(*((_DWORD *)cf + 6));
    if (NumberOfPlanes < 2)
    {
LABEL_73:
      v50 = atomic_load(v2);
      while (1)
      {
        v51 = __ldaxr(v2);
        if (v51 != v50)
          break;
        if (__stlxr(v50 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v2))
          goto LABEL_78;
        v52 = 1;
LABEL_79:
        v50 = v51;
        if (v52)
        {
          *((_QWORD *)cf + 3) = Typed;
          v53 = atomic_load((unint64_t *)cf + 1);
          while (1)
          {
            v54 = __ldaxr(v2);
            if (v54 != v53)
              break;
            if (__stlxr(v53 & 0xFFFFFFFFFFFFFFF7, v2))
              goto LABEL_85;
            v55 = 1;
LABEL_86:
            v53 = v54;
            if (v55)
              return;
          }
          __clrex();
LABEL_85:
          v55 = 0;
          goto LABEL_86;
        }
      }
      __clrex();
LABEL_78:
      v52 = 0;
      goto LABEL_79;
    }
    v11 = NumberOfPlanes;
    v12 = NumberOfPlanes - 1;
    v13 = (uint64_t *)*((_QWORD *)cf + 5);
    if (v13)
    {
      if (*((unsigned __int8 *)v13 + 12) < v12)
      {
        *((_BYTE *)v13 + 12) = v12;
        v14 = *v13;
        v15 = CFGetAllocator(cf);
        if (v14)
          v16 = __CFSafelyReallocateWithAllocatorTyped(v15, **((_QWORD **)cf + 5), 8 * v12, 0x6004044C4A2DFLL, 0, 0);
        else
          v16 = CFAllocatorAllocateTyped(v15, 8 * v12, 0x6004044C4A2DFLL, 0);
        **((_QWORD **)cf + 5) = v16;
      }
    }
    else
    {
      v22 = CFGetAllocator(cf);
      v23 = CFAllocatorAllocateTyped(v22, 16, 0x1080040FC6463CFLL, 0);
      *((_QWORD *)cf + 5) = v23;
      *(_BYTE *)(v23 + 12) = v12;
      *(_BYTE *)(v23 + 13) = 0;
      *(_DWORD *)(v23 + 8) = 0;
      if (v12)
      {
        v24 = CFGetAllocator(cf);
        v25 = CFAllocatorAllocateTyped(v24, 8 * v12, 0x6004044C4A2DFLL, 0);
        v23 = *((_QWORD *)cf + 5);
      }
      else
      {
        v25 = 0;
      }
      *(_QWORD *)v23 = v25;
    }
    v26 = 0;
    v27 = 1;
    while (1)
    {
      if (!v26)
        v26 = (_BYTE *)CFAllocatorAllocateTyped(v4, 0x2000, 111259299, 0);
      BitmapForPlane = CFUniCharGetBitmapForPlane(*((_DWORD *)cf + 6), v27, v26, 0);
      if (BitmapForPlane == 255)
        goto LABEL_70;
      if (BitmapForPlane == 1)
        memset(v26, 255, 0x2000uLL);
      if (!(_BYTE)v27)
      {
        __break(1u);
        return;
      }
      if (v27 <= 0x10u)
        break;
LABEL_69:
      v26 = 0;
LABEL_70:
      if (++v27 == v11)
      {
        if (v26)
          CFAllocatorDeallocate(v4, v26);
        goto LABEL_73;
      }
    }
    v29 = (uint64_t *)*((_QWORD *)cf + 5);
    if (v29)
    {
      if (*((unsigned __int8 *)v29 + 12) >= v27)
        goto LABEL_44;
      *((_BYTE *)v29 + 12) = v27;
      v30 = *v29;
      v31 = CFGetAllocator(cf);
      if (v30)
      {
        v32 = __CFSafelyReallocateWithAllocatorTyped(v31, **((_QWORD **)cf + 5), 8 * v27, 0x6004044C4A2DFLL, 0, 0);
LABEL_43:
        v29 = (uint64_t *)*((_QWORD *)cf + 5);
        *v29 = v32;
LABEL_44:
        if (((_DWORD)v29[1] & (1 << v27)) != 0)
        {
          v36 = v27 - 1;
        }
        else
        {
          v37 = CFGetAllocator(cf);
          Mutable = CFCharacterSetCreateMutable(v37);
          v36 = v27 - 1;
          *(_QWORD *)(**((_QWORD **)cf + 5) + 8 * v36) = Mutable;
          v29 = (uint64_t *)*((_QWORD *)cf + 5);
          *((_DWORD *)v29 + 2) |= 1 << v27;
        }
        v39 = *(_QWORD *)(*v29 + 8 * v36);
        if (v39)
        {
          v40 = (unint64_t *)(v39 + 8);
          v41 = atomic_load((unint64_t *)(v39 + 8));
          while (1)
          {
            v42 = __ldaxr(v40);
            if (v42 != v41)
              break;
            if (__stlxr(v41 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v40))
              goto LABEL_53;
            v43 = 1;
LABEL_54:
            v41 = v42;
            if (v43)
            {
              *(_QWORD *)(v39 + 24) = v26;
              v44 = atomic_load((unint64_t *)(v39 + 8));
              while (1)
              {
                v45 = __ldaxr(v40);
                if (v45 != v44)
                  break;
                if (__stlxr(v44 & 0xFFFFFFFFFFFFFFF7, v40))
                  goto LABEL_60;
                v46 = 1;
LABEL_61:
                v44 = v45;
                if (v46)
                {
                  v47 = atomic_load(v40);
                  while (1)
                  {
                    v48 = __ldaxr(v40);
                    if (v48 != v47)
                      break;
                    if (__stlxr(v47 & 0xFFFFFFFFFFFFFFFBLL, v40))
                      goto LABEL_67;
                    v49 = 1;
LABEL_68:
                    v47 = v48;
                    if (v49)
                      goto LABEL_69;
                  }
                  __clrex();
LABEL_67:
                  v49 = 0;
                  goto LABEL_68;
                }
              }
              __clrex();
LABEL_60:
              v46 = 0;
              goto LABEL_61;
            }
          }
          __clrex();
LABEL_53:
          v43 = 0;
          goto LABEL_54;
        }
        goto LABEL_69;
      }
      v35 = 8 * v27;
    }
    else
    {
      v33 = CFGetAllocator(cf);
      v34 = CFAllocatorAllocateTyped(v33, 16, 0x1080040FC6463CFLL, 0);
      *((_QWORD *)cf + 5) = v34;
      *(_WORD *)(v34 + 12) = v27;
      *(_DWORD *)(v34 + 8) = 0;
      v31 = CFGetAllocator(cf);
      v35 = 8 * v27;
    }
    v32 = CFAllocatorAllocateTyped(v31, v35, 0x6004044C4A2DFLL, 0);
    goto LABEL_43;
  }
}

void __CFCSetAddNonBMPPlanesInRange(CFTypeRef cf, unint64_t a2, int a3)
{
  unint64_t v3;
  int v4;
  uint64_t v6;
  int v7;
  CFIndex v8;
  uint64_t v9;
  __int16 v10;
  BOOL v11;
  uint64_t v12;
  CFIndex v13;
  uint64_t *v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t v20;
  CFAllocatorRef v21;
  uint64_t v22;
  const __CFAllocator *v23;
  __CFCharacterSet *Mutable;
  uint64_t *v25;
  uint64_t v26;
  CFAllocatorRef v27;
  uint64_t Typed;
  CFAllocatorRef v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  CFAllocatorRef v34;
  uint64_t v35;
  uint64_t v36;
  const __CFAllocator *v37;
  CFMutableCharacterSetRef v38;
  __CFCharacterSet *v39;
  char v40;
  uint64_t i;
  uint64_t v42;
  const __CFAllocator *v43;
  const __CFAllocator *v44;
  int v45;
  _BOOL4 v46;
  CFRange v47;
  CFRange v48;
  CFRange v49;

  v3 = a2 >> 16;
  if (((int)a2 + a3 - 1) >> 16 >= 16)
    v4 = 16;
  else
    v4 = ((int)a2 + a3 - 1) >> 16;
  if ((int)v3 <= 16)
  {
    v6 = *((_QWORD *)cf + 5);
    if (v6)
      v46 = *(_BYTE *)(v6 + 13) != 0;
    else
      v46 = 0;
    if (v3 <= 1)
      v7 = 1;
    else
      v7 = a2 >> 16;
    if (v7 <= v4)
    {
      v8 = (unsigned __int16)a2;
      v45 = (unsigned __int16)(a2 + a3);
      v9 = (unsigned __int16)(a2 + a3);
      v10 = 8 * v7;
      while (1)
      {
        if (v45)
          v11 = v4 == v7;
        else
          v11 = 0;
        v12 = 0x10000;
        if (v11)
          v12 = v9;
        v13 = v12 - v8;
        if (v46)
        {
          if (!(_BYTE)v7)
            goto LABEL_72;
          if (v7 > 0x10u
            || (v14 = (uint64_t *)*((_QWORD *)cf + 5)) == 0
            || ((*((_DWORD *)v14 + 2) >> v7) & 1) == 0
            || *((unsigned __int8 *)v14 + 12) < v7
            || (v15 = *v14, (v16 = *(unint64_t **)(v15 + 8 * (v7 - 1))) == 0))
          {
            v23 = CFGetAllocator(cf);
            Mutable = CFCharacterSetCreateMutable(v23);
            v48.location = v8;
            v48.length = v13;
            CFCharacterSetAddCharactersInRange(Mutable, v48);
            v25 = (uint64_t *)*((_QWORD *)cf + 5);
            if (v25)
            {
              if (*((unsigned __int8 *)v25 + 12) < v7)
              {
                *((_BYTE *)v25 + 12) = v7;
                v26 = *v25;
                v27 = CFGetAllocator(cf);
                if (v26)
                {
                  Typed = __CFSafelyReallocateWithAllocatorTyped(v27, **((_QWORD **)cf + 5), v10 & 0x7F8, 0x6004044C4A2DFLL, 0, 0);
                  goto LABEL_43;
                }
LABEL_42:
                Typed = CFAllocatorAllocateTyped(v27, v10 & 0x7F8, 0x6004044C4A2DFLL, 0);
LABEL_43:
                v25 = (uint64_t *)*((_QWORD *)cf + 5);
                *v25 = Typed;
              }
              v31 = 1 << v7;
              if (((_DWORD)v25[1] & (1 << v7)) != 0)
                CFRelease(*(CFTypeRef *)(*v25 + 8 * (v7 - 1)));
              if (Mutable)
              {
                *(_QWORD *)(**((_QWORD **)cf + 5) + 8 * (v7 - 1)) = CFRetain(Mutable);
                v32 = *((_QWORD *)cf + 5);
                v33 = *(_DWORD *)(v32 + 8) | v31;
              }
              else
              {
                v32 = *((_QWORD *)cf + 5);
                v33 = *(_DWORD *)(v32 + 8) & ~v31;
              }
              *(_DWORD *)(v32 + 8) = v33;
              CFRelease(Mutable);
              goto LABEL_58;
            }
            v29 = CFGetAllocator(cf);
            v30 = CFAllocatorAllocateTyped(v29, 16, 0x1080040FC6463CFLL, 0);
            *((_QWORD *)cf + 5) = v30;
            *(_WORD *)(v30 + 12) = v7;
            *(_DWORD *)(v30 + 8) = 0;
            v27 = CFGetAllocator(cf);
            goto LABEL_42;
          }
          v47.location = v8;
          v47.length = v13;
          CFCharacterSetRemoveCharactersInRange(*(CFMutableCharacterSetRef *)(v15 + 8 * (v7 - 1)), v47);
          v17 = v16[5];
          if (!v17 || !*(_DWORD *)(v17 + 8) && !*(_BYTE *)(v17 + 13))
          {
            v18 = atomic_load(v16 + 1);
            switch((v18 >> 4) & 7)
            {
              case 1u:
              case 2u:
                if (!v16[4])
                  goto LABEL_61;
                break;
              case 3u:
              case 4u:
                if (!v16[3])
                {
LABEL_61:
                  v40 = atomic_load(v16 + 1);
                  if ((v40 & 8) == 0)
                  {
                    CFRelease(v16);
                    *(_DWORD *)(*((_QWORD *)cf + 5) + 8) &= ~(1 << v7);
                  }
                }
                break;
              default:
                break;
            }
          }
        }
        else
        {
          if (!(_BYTE)v7)
          {
LABEL_72:
            __break(1u);
            return;
          }
          if (v7 <= 0x10u)
          {
            v19 = (uint64_t *)*((_QWORD *)cf + 5);
            if (v19)
            {
              if (*((unsigned __int8 *)v19 + 12) < v7)
              {
                *((_BYTE *)v19 + 12) = v7;
                v20 = *v19;
                v21 = CFGetAllocator(cf);
                if (v20)
                {
                  v22 = __CFSafelyReallocateWithAllocatorTyped(v21, **((_QWORD **)cf + 5), v10 & 0x7F8, 0x6004044C4A2DFLL, 0, 0);
                  goto LABEL_52;
                }
LABEL_51:
                v22 = CFAllocatorAllocateTyped(v21, v10 & 0x7F8, 0x6004044C4A2DFLL, 0);
LABEL_52:
                v19 = (uint64_t *)*((_QWORD *)cf + 5);
                *v19 = v22;
              }
              if (((_DWORD)v19[1] & (1 << v7)) != 0)
              {
                v36 = v7 - 1;
              }
              else
              {
                v37 = CFGetAllocator(cf);
                v38 = CFCharacterSetCreateMutable(v37);
                v36 = v7 - 1;
                *(_QWORD *)(**((_QWORD **)cf + 5) + 8 * v36) = v38;
                v19 = (uint64_t *)*((_QWORD *)cf + 5);
                *((_DWORD *)v19 + 2) |= 1 << v7;
              }
              v39 = *(__CFCharacterSet **)(*v19 + 8 * v36);
              if (v39)
              {
                v49.location = v8;
                v49.length = v13;
                CFCharacterSetAddCharactersInRange(v39, v49);
              }
              goto LABEL_58;
            }
            v34 = CFGetAllocator(cf);
            v35 = CFAllocatorAllocateTyped(v34, 16, 0x1080040FC6463CFLL, 0);
            *((_QWORD *)cf + 5) = v35;
            *(_WORD *)(v35 + 12) = v7;
            *(_DWORD *)(v35 + 8) = 0;
            v21 = CFGetAllocator(cf);
            goto LABEL_51;
          }
        }
LABEL_58:
        ++v7;
        v10 += 8;
        if (v4 + 1 == v7)
        {
          v6 = *((_QWORD *)cf + 5);
          break;
        }
      }
    }
    if (v6 && !*(_DWORD *)(v6 + 8) && !*(_BYTE *)(v6 + 13))
    {
      for (i = 0; i != 16; ++i)
      {
        v42 = *((_QWORD *)cf + 5);
        if (((*(_DWORD *)(v42 + 8) >> i) & 2) != 0)
          CFRelease(*(CFTypeRef *)(*(_QWORD *)v42 + 8 * i));
      }
      v43 = CFGetAllocator(cf);
      CFAllocatorDeallocate(v43, **((void ***)cf + 5));
      v44 = CFGetAllocator(cf);
      CFAllocatorDeallocate(v44, *((void **)cf + 5));
      *((_QWORD *)cf + 5) = 0;
    }
  }
}

void __CFCSetGetBitmap(uint64_t a1, int8x16_t *__b)
{
  char v4;
  const void *v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int BitmapForPlane;
  char *v13;
  size_t v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;
  int v18;
  unint64_t v19;
  char v20;
  char v21;
  char v22;
  unint64_t v23;
  uint64_t v24;
  unsigned __int16 v25;
  uint64_t v26;
  int8x16_t *v27;
  int8x16_t *v28;
  unsigned int v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  char *v33;
  size_t v34;
  uint64_t v35;
  int v36;
  int v37;
  unint64_t v38;
  uint64_t v39;
  int v40;

  v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 0x70) == 0x30 && (v5 = *(const void **)(a1 + 24)) != 0)
  {
    memmove(__b, v5, 0x2000uLL);
  }
  else
  {
    v6 = atomic_load((unint64_t *)(a1 + 8));
    if ((v6 & 8) != 0)
      v7 = -1;
    else
      v7 = 0;
    memset(__b, v7, 0x2000uLL);
    v8 = *(_QWORD *)(a1 + 40);
    if (v8 && (*(_DWORD *)(v8 + 8) || *(_BYTE *)(v8 + 13)))
    {
LABEL_14:
      v10 = atomic_load((unint64_t *)(a1 + 8));
      switch((v10 >> 4) & 7)
      {
        case 0u:
          BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(a1 + 24), 0, __b, (v6 >> 3) & 1);
          if (BitmapForPlane == 255 && (v6 & 8) != 0)
          {
            v33 = (char *)__b;
            v34 = 0x2000;
            goto LABEL_42;
          }
          if (BitmapForPlane == 1 && (v6 & 8) == 0)
          {
            v13 = (char *)__b;
            v14 = 0x2000;
            goto LABEL_23;
          }
          break;
        case 1u:
          v23 = *(unsigned int *)(a1 + 24);
          if (!WORD1(v23))
          {
            v24 = *(_QWORD *)(a1 + 32);
            if ((uint64_t)(v24 + v23) >= 0x10000)
              LODWORD(v24) = -(int)v23;
            v25 = v23 + v24 - 1;
            if ((v6 & 8) != 0)
            {
              v35 = (unsigned __int16)v23 >> 3;
              v36 = v25 >> 3;
              v37 = 255 << (v23 & 7);
              if (v36 == (_DWORD)v35)
              {
                __b->i8[v35] &= ~((0xFFu >> (~(_BYTE)v25 & 7)) & v37);
              }
              else
              {
                __b->i8[v35] &= ~(_BYTE)v37;
                __b->i8[v25 >> 3] &= -256 >> (~(_BYTE)v25 & 7);
                if (((unint64_t)(unsigned __int16)v23 >> 3) + 1 < v36)
                {
                  v33 = &__b->i8[(v23 >> 3) + 1];
                  v34 = v36 - (v23 >> 3) - 2 + 1;
LABEL_42:
                  bzero(v33, v34);
                }
              }
            }
            else if (v25 == (unsigned __int16)v23)
            {
              __b->i8[v23 >> 3] |= 1 << (v23 & 7);
            }
            else
            {
              v38 = v23 >> 3;
              v39 = v25 >> 3;
              v40 = 255 << (v23 & 7);
              if (*(_DWORD *)(a1 + 24) >> 3 == (_DWORD)v39)
              {
                __b->i8[v39] |= (0xFFu >> (~(_BYTE)v25 & 7)) & v40;
              }
              else
              {
                __b->i8[v38] |= v40;
                __b->i8[v25 >> 3] |= 0xFFu >> (~(_BYTE)v25 & 7);
                if ((int)v38 + 1 < v39)
                {
                  v13 = &__b->i8[(v38 + 1)];
                  v14 = (v39 - v38 - 2) + 1;
LABEL_23:
                  memset(v13, 255, v14);
                }
              }
            }
          }
          break;
        case 2u:
          v15 = *(_QWORD *)(a1 + 32);
          if (v15)
          {
            v16 = *(unsigned __int16 **)(a1 + 24);
            do
            {
              v17 = *v16++;
              v18 = 1 << (v17 & 7);
              v19 = (unint64_t)v17 >> 3;
              v20 = __b->i8[v19];
              v21 = v20 | v18;
              v22 = v20 & ~(_BYTE)v18;
              if ((v6 & 8) == 0)
                v22 = v21;
              __b->i8[v19] = v22;
              --v15;
            }
            while (v15);
          }
          break;
        case 4u:
          v26 = 0;
          v27 = *(int8x16_t **)(a1 + 24);
          v28 = v27 + 16;
          do
          {
            v29 = v27->u8[v26];
            if ((v29 + 1) > 1u)
            {
              v31 = *v28;
              v32 = v28[1];
              v28 += 2;
              *__b = v31;
              __b[1] = v32;
            }
            else
            {
              v30 = vdupq_n_s8(v29);
              *__b = v30;
              __b[1] = v30;
            }
            __b += 2;
            ++v26;
          }
          while ((_DWORD)v26 != 256);
          break;
        default:
          return;
      }
    }
    else
    {
      v9 = atomic_load((unint64_t *)(a1 + 8));
      switch((v9 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(_QWORD *)(a1 + 32))
            goto LABEL_14;
          break;
        case 3u:
        case 4u:
          if (*(_QWORD *)(a1 + 24))
            goto LABEL_14;
          break;
        default:
          goto LABEL_14;
      }
    }
  }
}

void __CFCSetMakeCompact(unint64_t *cf)
{
  unint64_t *v1;
  char v2;
  unsigned __int8 *v4;
  CFAllocatorRef v5;
  _OWORD *v6;
  _OWORD *v7;
  const __CFAllocator *v8;
  unint64_t v9;
  unint64_t v10;
  int v11;

  v1 = cf + 1;
  v2 = atomic_load(cf + 1);
  if ((v2 & 0x70) == 0x30)
  {
    v4 = (unsigned __int8 *)cf[3];
    if (v4)
    {
      v5 = CFGetAllocator(cf);
      v6 = __CFCreateCompactBitmap((uint64_t)v5, v4);
      if (v6)
      {
        v7 = v6;
        v8 = CFGetAllocator(cf);
        CFAllocatorDeallocate(v8, v4);
        v9 = atomic_load(cf + 1);
        while (1)
        {
          v10 = __ldaxr(v1);
          if (v10 != v9)
            break;
          if (__stlxr(v9 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v1))
            goto LABEL_9;
          v11 = 1;
LABEL_10:
          v9 = v10;
          if (v11)
          {
            cf[3] = (unint64_t)v7;
            return;
          }
        }
        __clrex();
LABEL_9:
        v11 = 0;
        goto LABEL_10;
      }
    }
  }
}

uint64_t CFUniCharGetNumberOfPlanes(unsigned int a1)
{
  uint64_t result;

  result = 15;
  if (a1 != 1 && a1 != 108)
  {
    if (a1 >= 4)
    {
      if (a1 == 12)
      {
        return 17;
      }
      else
      {
        if (a1 - 16 < 0x54)
          a1 += 85;
        if (a1 > 0x63)
          a1 -= 85;
        return LODWORD(__CFUniCharBitmapDataArray[2 * a1 - 8]);
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

CFStringRef CFURLCopyParameterString(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  _QWORD v3[6];

  v3[5] = *MEMORY[0x1E0C80C00];
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = __CFURLCopyParameterString_block_invoke_24;
  v3[3] = &__block_descriptor_40_e5_v8__0l;
  v3[4] = anURL;
  if (CFURLCopyParameterString_onceToken != -1)
    dispatch_once(&CFURLCopyParameterString_onceToken, v3);
  return 0;
}

uint64_t _CFMZEnabled()
{
  return 0;
}

void _CFPrefsRegisterUserDefaultsInstance(uint64_t a1)
{
  _CFPrefsRegisterUserDefaultsInstanceWithCloudConfigurationURL(a1, 0);
}

uint64_t _CFPreferencesAppSynchronizeWithContainer(__CFString *a1, const __CFString *a2)
{
  void *v4;
  uint64_t v5;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v4 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v5 = -[_CFXPreferences appSynchronizeWithIdentifier:container:]((uint64_t)v4, a1, a2);

  return v5;
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  void *v2;
  Boolean v3;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v2 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v3 = -[_CFXPreferences appSynchronizeWithIdentifier:container:]((uint64_t)v2, (__CFString *)applicationID, 0);

  return v3;
}

void sub_182B52F38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

char *__NSMakeSpecialForwardingCaptureBlock(const char *a1, uint64_t a2)
{
  char *v2;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  __int16 v14;

  v2 = 0;
  if (a1 && a2)
  {
    v5 = strnlen(a1, 0x400uLL);
    if (v5 == 1024)
    {
      CFLog(3, (uint64_t)CFSTR("Error: Attempt to make special forwarding block with a signature that is too large."), v6, v7, v8, v9, v10, v11, v14);
      return 0;
    }
    else
    {
      v12 = v5 + 1;
      v2 = (char *)malloc_type_calloc(1uLL, v5 + 89, 0x41F7ACABuLL);
      *(_QWORD *)v2 = MEMORY[0x1E0C809A0];
      *((_DWORD *)v2 + 3) = 0;
      *((_DWORD *)v2 + 2) = -1023410174;
      *(_OWORD *)(v2 + 40) = xmmword_182DC6F80;
      *((_QWORD *)v2 + 2) = __forwarding_prep_b___;
      *((_QWORD *)v2 + 3) = v2 + 40;
      *((_QWORD *)v2 + 4) = a2;
      *((_QWORD *)v2 + 7) = copyBlock;
      *((_QWORD *)v2 + 8) = destroyBlock;
      *((_QWORD *)v2 + 9) = v2 + 88;
      *((_QWORD *)v2 + 10) = 256;
      strlcpy(v2 + 88, a1, v12);
      *((_QWORD *)v2 + 4) = _Block_copy(*((const void **)v2 + 4));
    }
  }
  return v2;
}

void sub_182B532DC(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void _CFPrefsSynchronizeForProcessTermination()
{
  uint64_t v0;
  id v1;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v0 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v0 = objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v1 = (id)v0;
  -[_CFXPreferences synchronizeEverything](v0);

}

void sub_182B5348C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _CFXPreferencesRegisterDefaultValues(uint64_t a1)
{
  void *v2;
  id v3;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v2 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v3 = v2;
  objc_msgSend(v2, "registerDefaultValues:", a1);

}

void withKeysAndValues(const __CFDictionary *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t Count;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  const void **v9;
  const void **v10;
  const void **v11;
  CFStringRef v12;
  NSException *v13;
  _QWORD v14[2];
  size_t v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    Count = CFDictionaryGetCount(a1);
    v6 = 2 * Count;
    if (((Count >> 59) & 0xF) != 0)
    {
      v12 = CFStringCreateWithFormat(0, 0, CFSTR("*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt"), v6);
      v13 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSGenericException"), v12, 0);
      CFRelease(v12);
      objc_exception_throw(v13);
    }
    if (Count)
    {
      v7 = MEMORY[0x1E0C80A78](v6, v4);
      v9 = (const void **)((char *)v15 - v8);
      v15[0] = 0;
      if (v7 >= 0x101)
      {
        v10 = (const void **)_CFCreateArrayStorage(v7, 0, v15);
        v9 = v10;
      }
      else
      {
        v10 = 0;
      }
    }
    else
    {
      MEMORY[0x1E0C80A78](v6, v4);
      v9 = (const void **)v14;
      v10 = 0;
      v15[0] = 0;
    }
    v11 = &v9[Count];
    CFDictionaryGetKeysAndValues(a1, v9, v11);
  }
  else
  {
    MEMORY[0x1E0C80A78](0, a2);
    v11 = (const void **)v14;
    v10 = 0;
    Count = 0;
    v15[0] = 0;
    v9 = (const void **)v14;
  }
  (*(void (**)(uint64_t, const void **, const void **, unint64_t))(a2 + 16))(a2, v9, v11, Count);
  free(v10);
}

void sub_182B537F8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182B53AA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  objc_end_catch();
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182B53DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v10;
  va_list va;

  va_start(va, a10);
  objc_end_catch();
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v10 - 104), 8);
  _Unwind_Resume(a1);
}

void sub_182B53E28(uint64_t a1, int a2)
{
  if (a2)
    objc_terminate();
  JUMPOUT(0x182B53E20);
}

Boolean CFPreferencesAppValueIsForced(CFStringRef key, CFStringRef applicationID)
{
  os_unfair_lock *v4;
  Boolean v5;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v4 = (os_unfair_lock *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v5 = -[_CFXPreferences appValueIsForcedForKey:appIdentifier:](v4, (uint64_t)key, (__CFString *)applicationID);

  return v5;
}

void sub_182B53FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182B54174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  objc_end_catch();
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182B541C0(uint64_t a1, int a2)
{
  if (a2)
    objc_terminate();
  JUMPOUT(0x182B541B8);
}

const __CFString *_CFStringCopyBundleUnloadingProtectedString(uint64_t a1)
{
  const char *CStringPtrInternal;
  int8x16_t *v4;
  size_t v5;

  if (a1 < 0)
    return (const __CFString *)a1;
  CStringPtrInternal = (const char *)_CFStringGetCStringPtrInternal(a1, 0x8000100u, 1, 1);
  if (!CStringPtrInternal)
    return _CFStringSlowPathCopyBundleUnloadingProtectedString((const __CFString *)a1);
  v4 = (int8x16_t *)CStringPtrInternal;
  strlen(CStringPtrInternal);
  if (!_dyld_is_memory_immutable())
    return _CFStringSlowPathCopyBundleUnloadingProtectedString((const __CFString *)a1);
  if (*(__objc2_class **)a1 == __CFConstantStringClassReferencePtr)
    return (const __CFString *)a1;
  v5 = strlen(v4->i8);
  return (const __CFString *)__CFStringCreateImmutableFunnel3(&__kCFAllocatorSystemDefault, v4, v5, 134217984, 0x18u, (const __CFAllocator *)&__kCFAllocatorNull, 0);
}

void sub_182B55428(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182B55808(_Unwind_Exception *a1)
{
  uint64_t v1;

  free(*(void **)(v1 - 168));
  _Unwind_Resume(a1);
}

void sub_182B5586C(uint64_t a1, int a2)
{
  if (!a2)
    JUMPOUT(0x182B55870);
  objc_terminate();
}

void sub_182B5587C(void *exc_buf, int a2)
{
  uint64_t v2;

  if (a2)
  {
    objc_begin_catch(exc_buf);
    if (!v2)
      JUMPOUT(0x182B556C0);
    JUMPOUT(0x182B556A8);
  }
  JUMPOUT(0x182B55864);
}

CFStringRef createDeepCopyOfValueForKey(CFStringRef cf, uint64_t a2)
{
  const __CFString *v2;
  CFTypeID v5;

  v2 = cf;
  if (((unint64_t)cf & 0x8000000000000000) == 0
    && &__kCFBooleanFalse != (__objc2_class **)cf
    && &__kCFBooleanTrue != (__objc2_class **)cf)
  {
    v5 = CFGetTypeID(cf);
    if (v5 == CFStringGetTypeID())
    {
      return CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2);
    }
    else
    {
      cf = (CFStringRef)CFPropertyListCreateDeepCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2, 0);
      if (!cf)
      {
        _CFPrefsValidateValueForKey(v2, a2);
        return 0;
      }
    }
  }
  return cf;
}

void sub_182B561CC(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182B56200(_Unwind_Exception *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x182B55E94);
  }
  _Unwind_Resume(exc_buf);
}

void sub_182B5627C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t _CFPrefsReadOnly()
{
  return forceReadOnly;
}

void sub_182B564AC(_Unwind_Exception *a1)
{
  int v1;

  if (v1)
    objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182B564C4(uint64_t a1, int a2)
{
  if (a2)
    objc_terminate();
  JUMPOUT(0x182B564D0);
}

void _addBackstopValuesForIdentifierAndSource(const void *a1, os_unfair_lock_s *a2)
{
  CFArrayRef v4;
  void *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  CFStringRef v19;
  NSException *v20;
  uint64_t v21;
  uint64_t v22;
  void *values;
  size_t v24[4];
  _OWORD v25[2];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (CFEqual(a1, CFSTR("NSRegistrationDomain")))
  {
    values = CFSTR("en-001");
    v4 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    v25[0] = xmmword_1E13331C8;
    v25[1] = *(_OWORD *)off_1E13331D8;
    v24[0] = (size_t)v4;
    v24[1] = (size_t)CFSTR("en_001");
    v24[2] = (size_t)v4;
    v24[3] = (size_t)CFSTR("macintosh");
    if (a2)
      -[CFPrefsSource setValues:forKeys:count:copyValues:removeValuesForKeys:count:from:](a2, (uint64_t)v24, (uint64_t)v25, 4uLL, 1, 0, 0, 0);
    CFRelease(v4);
  }
  else if (CFEqual(a1, CFSTR("NSArgumentDomain")))
  {
    if (getDefaultArguments_onceToken != -1)
      dispatch_once(&getDefaultArguments_onceToken, &__block_literal_global_219);
    v5 = (void *)getDefaultArguments___NSDefaultArguments;
    if (getDefaultArguments___NSDefaultArguments)
    {
      v6 = objc_msgSend((id)getDefaultArguments___NSDefaultArguments, "count");
      v8 = v6;
      if (v6 >> 60)
      {
        v19 = CFStringCreateWithFormat(0, 0, CFSTR("*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt"), v6);
        v20 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSGenericException"), v19, 0);
        CFRelease(v19);
        objc_exception_throw(v20);
      }
      if (v6 <= 1)
        v9 = 1;
      else
        v9 = v6;
      v10 = MEMORY[0x1E0C80A78](v6, v7);
      v13 = (char *)&v22 - v12;
      *(_QWORD *)&v25[0] = 0;
      if (v8 > 0x100)
      {
        v16 = (char *)_CFCreateArrayStorage(v9, 0, (size_t *)v25);
        MEMORY[0x1E0C80A78](v16, v18);
        v15 = (char *)&v21;
        v24[0] = 0;
        v17 = (char *)_CFCreateArrayStorage(v9, 0, v24);
        v13 = v16;
      }
      else
      {
        MEMORY[0x1E0C80A78](v10, v11);
        v15 = (char *)&v22 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
        v16 = 0;
        v17 = 0;
        v24[0] = 0;
      }
      if (v8 >= 0x101)
        v15 = v17;
      objc_msgSend(v5, "getObjects:andKeys:count:", v13, v15, v8);
      if (a2)
        -[CFPrefsSource setValues:forKeys:count:copyValues:removeValuesForKeys:count:from:](a2, (uint64_t)v13, (uint64_t)v15, v8, 0, 0, 0, 0);
      free(v17);
      free(v16);
    }
  }
}

void sub_182B5684C(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

const __CFString *_CFStringSlowPathCopyBundleUnloadingProtectedString(const __CFString *a1)
{
  CFIndex Length;
  CFIndex v3;
  uint64_t FastestEncoding;
  uint64_t CStringPtrInternal;
  int8x16_t *v6;
  int64_t v7;
  uint64_t v8;
  void *v9;
  const UniChar *CharactersPtr;
  size_t MaximumSizeForEncoding;
  uint64_t v13;
  size_t v14;
  int8x16_t *v15;
  void *ImmutableFunnel3;
  CFIndex v17[2];
  CFRange v18;

  v17[1] = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  if (!Length)
    return &stru_1E1337B18;
  v3 = Length;
  FastestEncoding = CFStringGetFastestEncoding(a1);
  CStringPtrInternal = _CFStringGetCStringPtrInternal((uint64_t)a1, FastestEncoding, 0, 1);
  if (!CStringPtrInternal)
  {
    CharactersPtr = CFStringGetCharactersPtr(a1);
    if (CharactersPtr)
    {
      v6 = (int8x16_t *)CharactersPtr;
      v7 = 2 * v3;
      v8 = 256;
      return (const __CFString *)__CFStringCreateImmutableFunnel3(&__kCFAllocatorSystemDefault, v6, v7, v8, 2u, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
    }
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v3, FastestEncoding);
    v14 = MaximumSizeForEncoding;
    v17[0] = 0;
    if (MaximumSizeForEncoding < 0x101)
    {
      if (MaximumSizeForEncoding)
      {
        MEMORY[0x1E0C80A78](MaximumSizeForEncoding, v13);
        v15 = (int8x16_t *)((char *)v17 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0));
        bzero(v15, v14);
      }
      else
      {
        v15 = 0;
      }
    }
    else
    {
      v15 = (int8x16_t *)malloc_type_malloc(MaximumSizeForEncoding, 0x100004077774924uLL);
    }
    v18.location = 0;
    v18.length = v3;
    if (CFStringGetBytes(a1, v18, FastestEncoding, 0, 0, (UInt8 *)v15, v14, v17))
      ImmutableFunnel3 = (void *)__CFStringCreateImmutableFunnel3(&__kCFAllocatorSystemDefault, v15, v17[0], FastestEncoding, 2u, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
    else
      ImmutableFunnel3 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, a1);
    v9 = ImmutableFunnel3;
    if (v14 >= 0x101)
      free(v15);
    return (const __CFString *)v9;
  }
  v6 = (int8x16_t *)CStringPtrInternal;
  v7 = v3;
  v8 = FastestEncoding;
  return (const __CFString *)__CFStringCreateImmutableFunnel3(&__kCFAllocatorSystemDefault, v6, v7, v8, 2u, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
}

void _CFPreferencesSetAppValueWithContainerAndConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v10;
  id v11;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v10 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v11 = v10;
  objc_msgSend(v10, "setValue:forKey:appIdentifier:container:configurationURL:", a2, a1, a3, a4, a5);

}

uint64_t __CFURLReservedPtr(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 40);
    if (v1)
      return *(_QWORD *)v1;
    else
      return 0;
  }
  return result;
}

Boolean CFPropertyListIsValid(CFPropertyListRef plist, CFPropertyListFormat format)
{
  _QWORD v3[2];
  __int128 v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v3[0] = 1;
  v4 = 0u;
  v5 = 0;
  v3[1] = format;
  return __CFPropertyListIsValidAux(plist, v3);
}

CFIndex _CFNonObjCStringGetBytes(CFStringRef theString, CFRange range, uint64_t a3, unsigned int a4, int a5, UniChar *buffer, uint64_t a7, int64_t *a8)
{
  CFIndex length;
  CFIndex location;
  char v16;
  int v17;
  char v18;
  char **p_data;
  char *v20;
  unint64_t v21;
  char v23;
  int v24;
  int v25;
  CFRange v26;

  length = range.length;
  location = range.location;
  v16 = atomic_load((unint64_t *)&theString->info);
  if ((v16 & 0x10) != 0)
    goto LABEL_36;
  v17 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    v17 = __CFDefaultEightBitStringEncoding;
  }
  if (v17 != (_DWORD)a3)
  {
    if (v17 == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      v17 = __CFDefaultEightBitStringEncoding;
    }
    if (v17 != 1536)
      goto LABEL_36;
    switch(BYTE1(a3))
    {
      case 0:
        if (a3 <= 0x22 && ((1 << a3) & 0x600000032) != 0 || (_DWORD)a3 == 152)
          goto LABEL_36;
        goto LABEL_5;
      case 1:
        if ((_DWORD)a3 != 134217984)
          goto LABEL_36;
        goto LABEL_5;
      case 2:
        if ((_DWORD)a3 == 518)
          goto LABEL_36;
        goto LABEL_5;
      case 6:
        if ((_DWORD)a3 != 1536)
          goto LABEL_36;
        goto LABEL_5;
      case 8:
      case 0xC:
        goto LABEL_36;
      case 0xA:
        if ((a3 - 2561) > 0xF)
          goto LABEL_5;
        v24 = 1 << (a3 - 1);
        v25 = 32785;
        break;
      case 0xB:
        if ((a3 - 3059) > 0xC)
          goto LABEL_5;
        v24 = 1 << (a3 + 13);
        v25 = 4099;
        break;
      default:
        if (((unsigned __int16)a3 & 0xFF00u) > 0xC00)
          goto LABEL_36;
        goto LABEL_5;
    }
    if ((v24 & v25) != 0)
    {
LABEL_36:
      v26.location = location;
      v26.length = length;
      return __CFStringEncodeByteStream(theString, v26, a5, a3, a4, buffer, a7, a8);
    }
  }
LABEL_5:
  v18 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v18 & 0x60) != 0)
  {
    v20 = *p_data;
    if (buffer)
    {
LABEL_7:
      if (length >= a7)
        length = a7;
      v21 = atomic_load((unint64_t *)&theString->info);
      memmove(buffer, &v20[location + ((v21 >> 2) & 1)], length);
    }
  }
  else
  {
    v23 = atomic_load((unint64_t *)&theString->info);
    v20 = (char *)&p_data[(v23 & 5) != 4];
    if (buffer)
      goto LABEL_7;
  }
  if (a8)
    *a8 = length;
  return length;
}

uint64_t CFStorageGetCount(uint64_t a1)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(a1 + 144);
  v2 = *(_DWORD *)(a1 + 24);
  if (v2 == -1)
    return v1 / *(_QWORD *)(a1 + 16);
  else
    return v1 >> v2;
}

CFURLRef CFURLCreateAbsoluteURLWithBytes(CFAllocatorRef alloc, const UInt8 *relativeURLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL, Boolean useCompatibilityMode)
{
  const __CFString *v11;
  __CFString *v12;
  int CharacterAtIndex;
  const __CFString *v14;
  const __CFURL *v15;
  unint64_t *v16;
  const __CFURL *v17;
  int v19;
  const __CFString *v20;
  const __CFString *v21;
  unsigned int v22;
  unsigned int v23;
  CFIndex *v24;
  const __CFAllocator *v25;
  const __CFString *v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFString *v29;
  uint64_t v30;
  CFIndex v31;
  CFIndex v32;
  __CFString *Mutable;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  char v37;
  CFIndex *v38;
  CFIndex v39;
  CFIndex v40;
  UniChar *Typed;
  UniChar *v42;
  const __CFString *v43;
  CFIndex v44;
  CFMutableStringRef MutableCopy;
  unsigned int v46;
  int v47;
  char v48;
  unsigned int v49;
  _QWORD v50[18];
  _QWORD v51[19];
  CFRange v52;
  CFRange v53;
  CFRange v54;

  v51[18] = *MEMORY[0x1E0C80C00];
  if (useCompatibilityMode)
  {
    v49 = 0;
    v48 = 0;
    if (dyld_program_sdk_at_least())
      v11 = _CFURLCreateURLStringWithBytes(alloc, (UInt8 *)relativeURLBytes, length, encoding);
    else
      v11 = CFStringCreateWithBytes(alloc, relativeURLBytes, length, encoding, 0);
    v12 = (__CFString *)v11;
    if (!v11)
      return 0;
    if (!baseURL)
    {
      v19 = 0;
      goto LABEL_33;
    }
    if (CFStringGetLength(v11) >= 1)
    {
      CharacterAtIndex = CFStringGetCharacterAtIndex(v12, 0);
      if (CharacterAtIndex == 63 || CharacterAtIndex == 35)
      {
        if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)baseURL))
          v14 = CFURLGetString(baseURL);
        else
          v14 = (const __CFString *)atomic_load((unint64_t *)baseURL + 3);
        v31 = CFStringGetLength(v14);
        v32 = CFStringGetLength(v12);
        Mutable = CFStringCreateMutable(alloc, v32 + v31);
        CFStringAppend(Mutable, v14);
        CFStringAppend(Mutable, v12);
LABEL_28:
        v19 = 1;
        goto LABEL_32;
      }
    }
    v47 = 0;
    _parseComponents(v12, baseURL, (unsigned int *)&v47, v51, &v48);
    if ((v47 & 1) == 0)
    {
      CFRetain(v12);
      v20 = v12;
      goto LABEL_17;
    }
    v28 = CFURLCopyScheme(baseURL);
    if (v28)
    {
      v29 = v28;
      v30 = v51[1];
      if (CFStringGetLength(v28) == v30 && CFStringHasPrefix(v12, v29))
      {
        v54.length = CFStringGetLength(v12) + ~v30;
        v54.location = v30 + 1;
        v20 = CFStringCreateWithSubstring(alloc, v12, v54);
        v47 = 0;
        _parseComponents(v20, baseURL, (unsigned int *)&v47, v51, &v48);
        CFRelease(v29);
LABEL_17:
        if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)baseURL))
        {
          v46 = 0;
          v21 = CFURLGetString(baseURL);
          _parseComponents(v21, 0, &v46, v50, &v48);
          v23 = v46;
          v22 = v47;
          v24 = v50;
          v25 = alloc;
          v26 = v20;
          v27 = v21;
        }
        else
        {
          v22 = v47;
          v27 = (const __CFString *)atomic_load((unint64_t *)baseURL + 3);
          v23 = *((_DWORD *)baseURL + 4);
          v24 = (CFIndex *)((char *)baseURL + 56);
          v25 = alloc;
          v26 = v20;
        }
        Mutable = (__CFString *)resolveAbsoluteURLString(v25, v26, v22, (uint64_t)v51, v27, v23, v24);
        if (v20)
          CFRelease(v20);
        goto LABEL_28;
      }
      CFRetain(v12);
      CFRelease(v29);
    }
    else
    {
      CFRetain(v12);
    }
    v19 = 0;
    Mutable = v12;
LABEL_32:
    CFRelease(v12);
    v12 = Mutable;
    if (Mutable)
    {
LABEL_33:
      _parseComponents(v12, 0, &v49, v51, &v48);
      v34 = v49;
      if ((v49 & 0x20) == 0)
        goto LABEL_41;
      v35 = 0;
      v36 = 32;
      do
      {
        v37 = v36;
        v36 >>= 1;
        v35 += v34 & 1;
        v34 >>= 1;
      }
      while ((v37 & 2) == 0);
      v38 = &v51[2 * v35];
      v39 = *v38;
      v40 = v38[1];
      Typed = (UniChar *)CFAllocatorAllocateTyped(alloc, 2 * v40 + 2, 0x1000040BDFB0063, 0);
      v52.location = v39;
      v52.length = v40;
      CFStringGetCharacters(v12, v52, Typed);
      v42 = &Typed[v40];
      *v42 = 0;
      v43 = _resolvedPath((char *)Typed, (unint64_t)v42, 47, 1, 0, alloc);
      if (CFStringGetLength(v43) != v40)
      {
        if (!v19)
        {
          v44 = CFStringGetLength(v12);
          MutableCopy = CFStringCreateMutableCopy(alloc, v44, v12);
          CFRelease(v12);
          v12 = MutableCopy;
        }
        v53.location = v39;
        v53.length = v40;
        CFStringReplace(v12, v53, v43);
      }
      CFRelease(v43);
      if (v12)
      {
LABEL_41:
        v16 = _CFURLCreateWithURLString((__objc2_class **)alloc, v12, 0, 0);
        CFRelease(v12);
        if (v16)
          *((_DWORD *)v16 + 5) = encoding;
        return (CFURLRef)v16;
      }
      CFRelease(0);
    }
    return 0;
  }
  v15 = CFURLCreateWithBytes(alloc, relativeURLBytes, length, encoding, baseURL);
  v16 = (unint64_t *)v15;
  if (v15 && baseURL)
  {
    v17 = CFURLCopyAbsoluteURL(v15);
    CFRelease(v16);
    return v17;
  }
  return (CFURLRef)v16;
}

const __CFString *_CFURLCreateURLStringWithBytes(const __CFAllocator *a1, UInt8 *bytes, size_t numBytes, CFStringEncoding encoding)
{
  const __CFString *v7;
  int v8;
  int v9;
  const __CFString *v10;
  const char *CStringPtr;
  UInt8 *v12;
  int v13;
  CFIndex Length;
  CFIndex v15;
  CFIndex usedBufLen[2];
  CFRange v18;

  usedBufLen[1] = *MEMORY[0x1E0C80C00];
  v7 = 0;
  switch(BYTE1(encoding))
  {
    case 0:
      v7 = 0;
      if ((encoding > 0x22 || ((1 << encoding) & 0x600000032) == 0) && encoding != 152)
        goto LABEL_20;
      return v7;
    case 1:
      if (encoding != 134217984)
        return 0;
      goto LABEL_20;
    case 2:
      if (encoding != 518)
        goto LABEL_20;
      return 0;
    case 6:
      if (encoding == 1536)
        goto LABEL_20;
      return 0;
    case 8:
    case 0xC:
      return v7;
    case 0xA:
      if (encoding - 2561 > 0xF)
        goto LABEL_20;
      v8 = 1 << (encoding - 1);
      v9 = 32785;
      break;
    case 0xB:
      if (encoding - 3059 > 0xC)
        goto LABEL_20;
      v8 = 1 << (encoding + 13);
      v9 = 4099;
      break;
    default:
      if ((encoding & 0xFF00) <= 0xC00)
        goto LABEL_20;
      return 0;
  }
  if ((v8 & v9) != 0)
    return 0;
LABEL_20:
  v10 = CFStringCreateWithBytes(a1, bytes, numBytes, encoding, 0);
  v7 = v10;
  if (!v10)
    return v7;
  CStringPtr = CFStringGetCStringPtr(v10, encoding);
  if (CStringPtr)
  {
    v12 = (UInt8 *)CStringPtr;
    v13 = 0;
    if (strlen(CStringPtr) != numBytes)
      goto LABEL_31;
  }
  else
  {
    Length = CFStringGetLength(v7);
    v15 = CFStringGetMaximumSizeForEncoding(Length, encoding) + 1;
    v12 = (UInt8 *)malloc_type_malloc(v15, 0x9CDD8CAFuLL);
    if (!v12)
    {
      v13 = 0;
      goto LABEL_32;
    }
    usedBufLen[0] = 0;
    v18.location = 0;
    v18.length = Length;
    CFStringGetBytes(v7, v18, encoding, 0, 0, v12, v15, usedBufLen);
    if (usedBufLen[0] != numBytes)
    {
      free(v12);
      v13 = 0;
LABEL_31:
      v12 = 0;
      goto LABEL_32;
    }
    v13 = 1;
  }
  if (memcmp(bytes, v12, numBytes))
  {
LABEL_32:
    CFRelease(v7);
    v7 = 0;
  }
  if (v13)
    free(v12);
  return v7;
}

CFIndex _loadStringsDictTable(const void *a1, void *a2, void *a3, CFDictionaryRef theDict, uint64_t a5, CFTypeRef *a6)
{
  CFIndex Count;
  int StringsFromData;
  CFIndex result;

  Count = CFDictionaryGetCount(theDict);
  StringsFromData = _loadStringsFromData(a1, a2, a3, *(const __CFData **)(a5 + 40), *(unsigned __int8 *)(a5 + 65), theDict, (_BYTE *)a5);
  if (a6 && StringsFromData && !*a6)
    *a6 = CFRetain(*(CFTypeRef *)(a5 + 24));
  result = CFDictionaryGetCount(theDict);
  if (result > Count)
    *(_BYTE *)(a5 + 75) = 1;
  return result;
}

uint64_t _loadStringsFromData(const void *a1, void *a2, void *a3, const __CFData *a4, int a5, const __CFDictionary *a6, _BYTE *a7)
{
  void *v14;
  char v15;
  const __CFSet *Mutable;
  uint64_t v17;
  CFIndex Count;
  const __CFDictionary *StringsFromPlistData;
  const __CFDictionary *v20;
  CFIndex v21;
  BOOL v22;
  _QWORD v24[7];
  _QWORD v25[5];
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v26 = 0;
  v27 = &v26;
  v28 = 0x2020000000;
  v29 = 0;
  if (a7[73])
  {
    v14 = 0;
    v15 = 1;
    if (!a3)
    {
      Mutable = 0;
      goto LABEL_11;
    }
    Mutable = 0;
    if (a7[72])
      goto LABEL_11;
  }
  else if (!a3)
  {
    v14 = 0;
    Mutable = 0;
    v15 = 1;
    goto LABEL_11;
  }
  if (_dictionaryContainsAllKeysInSet((uint64_t)a6, a3))
  {
    v17 = 0;
    goto LABEL_20;
  }
  Count = CFSetGetCount((CFSetRef)a3);
  Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeSetCallBacks);
  v25[0] = MEMORY[0x1E0C809B0];
  v25[1] = 3221225472;
  v25[2] = ___loadStringsFromData_block_invoke;
  v25[3] = &__block_descriptor_40_e13_v24__0r_v8_16l;
  v25[4] = Mutable;
  CFSetApply(a3, (uint64_t)v25);
  v15 = 0;
  v14 = a3;
LABEL_11:
  StringsFromPlistData = (const __CFDictionary *)__CFBundleCreateStringsFromPlistData(a1, Mutable, a4, a5, a2);
  v20 = StringsFromPlistData;
  if (StringsFromPlistData)
  {
    if (CFGetTypeID(StringsFromPlistData) == 18)
    {
      if ((v15 & 1) != 0)
      {
        v21 = CFDictionaryGetCount(a6);
        CFDictionaryApplyFunction(v20, (CFDictionaryApplierFunction)__CFStringsDictAddFunction, a6);
        v22 = CFDictionaryGetCount(a6) > v21;
        *((_BYTE *)v27 + 24) = v22;
        a7[74] = 1;
      }
      else
      {
        v24[0] = MEMORY[0x1E0C809B0];
        v24[1] = 3221225472;
        v24[2] = ___loadStringsFromData_block_invoke_2;
        v24[3] = &unk_1E1335DA0;
        v24[4] = &v26;
        v24[5] = v20;
        v24[6] = a6;
        CFSetApply(v14, (uint64_t)v24);
      }
    }
    CFRelease(v20);
  }
  if (Mutable)
    CFRelease(Mutable);
  v17 = *((unsigned __int8 *)v27 + 24);
LABEL_20:
  _Block_object_dispose(&v26, 8);
  return v17;
}

void sub_182B58378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _loadStringsInOrder(const void *a1, void *a2, void *a3, CFDictionaryRef theDict, uint64_t a5, CFTypeRef *a6)
{
  int StringsFromData;

  if (*(_BYTE *)(a5 + 67))
  {
    if (*(_BYTE *)(a5 + 77))
    {
      _loadStringsDictTable(a1, a2, a3, theDict, a5, a6);
    }
    else if (*(_BYTE *)(a5 + 78))
    {
      _loadLocTable(a1, a2, *(CFTypeRef *)(a5 + 32), a3, theDict, a5, (CFURLRef *)a6);
    }
  }
  if (*(_BYTE *)(a5 + 76))
  {
    StringsFromData = _loadStringsFromData(a1, a2, a3, *(const __CFData **)(a5 + 16), *(unsigned __int8 *)(a5 + 64), *(const __CFDictionary **)(a5 + 88), (_BYTE *)a5);
    if (a6 && StringsFromData && !*a6)
      *a6 = CFRetain(*(CFTypeRef *)a5);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a5 + 88), (CFDictionaryApplierFunction)__CFStringsDictAddFunction, theDict);
  }
  else if (*(_BYTE *)(a5 + 78))
  {
    _loadLocTable(a1, a2, *(CFTypeRef *)(a5 + 8), a3, theDict, a5, (CFURLRef *)a6);
  }
  if (!*(_BYTE *)(a5 + 67))
  {
    if (*(_BYTE *)(a5 + 77))
    {
      _loadStringsDictTable(a1, a2, a3, theDict, a5, a6);
    }
    else if (*(_BYTE *)(a5 + 78))
    {
      _loadLocTable(a1, a2, *(CFTypeRef *)(a5 + 32), a3, theDict, a5, (CFURLRef *)a6);
    }
  }
}

void _loadLocTable(const void *a1, void *a2, CFTypeRef cf1, void *a4, void *a5, uint64_t a6, CFURLRef *a7)
{
  const void *v13;
  NSSet *v14;
  CFTypeRef StringsFromPlistData;
  const __CFDictionary *ValueWithKeyPath;
  const __CFDictionary *v17;
  CFIndex Count;
  const __CFSet *Mutable;
  uint64_t v20;
  CFTypeRef v21;
  const __CFString *v22;
  BOOL v23;
  char v24;
  CFTypeRef cf;
  _QWORD v26[8];
  _QWORD v27[6];
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  char v31;
  void *values[3];

  values[1] = *(void **)MEMORY[0x1E0C80C00];
  values[0] = (void *)cf1;
  if (cf1)
  {
    v13 = *(const void **)(a6 + 80);
    if (!v13 || !CFEqual(cf1, v13))
    {
      v28 = 0;
      v29 = &v28;
      v30 = 0x2020000000;
      v31 = 0;
      if (!a4 || *(_BYTE *)(a6 + 73) && *(_BYTE *)(a6 + 72))
      {
        cf = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 1, &kCFTypeArrayCallBacks);
        v14 = -[NSSet initWithObjects:count:]([NSSet alloc], "initWithObjects:count:", &cf, 1);
        StringsFromPlistData = __CFBundleCreateStringsFromPlistData(a1, (const __CFSet *)v14, *(const __CFData **)(a6 + 56), *(unsigned __int8 *)(a6 + 66), a2);
        ValueWithKeyPath = (const __CFDictionary *)_CFPropertyListGetValueWithKeyPath(StringsFromPlistData, (const __CFString *)values[0]);
        v17 = ValueWithKeyPath;
        if (ValueWithKeyPath && CFGetTypeID(ValueWithKeyPath) == 18 && CFDictionaryGetCount(v17) >= 1)
        {
          v23 = 0;
          _CFBundleGetLocTableProvenanceForLanguage(*(const __CFData **)(a6 + 56), (const __CFString *)values[0], &v24, &v23);
          if (v23)
            *(_BYTE *)(a6 + 75) = 1;
          CFDictionaryApplyFunction(v17, (CFDictionaryApplierFunction)__CFStringsDictAddFunction, a5);
          *((_BYTE *)v29 + 24) = 1;
          *(_BYTE *)(a6 + 74) = 1;
          *(_QWORD *)(a6 + 80) = CFRetain(values[0]);
        }
        CFRelease(cf);

        if (StringsFromPlistData)
          CFRelease(StringsFromPlistData);
      }
      else
      {
        if (_dictionaryContainsAllKeysInSet((uint64_t)a5, a4))
        {
LABEL_23:
          _Block_object_dispose(&v28, 8);
          return;
        }
        Count = CFSetGetCount((CFSetRef)a4);
        Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeSetCallBacks);
        v20 = MEMORY[0x1E0C809B0];
        v27[0] = MEMORY[0x1E0C809B0];
        v27[1] = 3221225472;
        v27[2] = ___loadLocTable_block_invoke;
        v27[3] = &__block_descriptor_48_e13_v24__0r_v8_16l;
        v27[4] = values[0];
        v27[5] = Mutable;
        CFSetApply(a4, (uint64_t)v27);
        v21 = __CFBundleCreateStringsFromPlistData(a1, Mutable, *(const __CFData **)(a6 + 56), *(unsigned __int8 *)(a6 + 66), a2);
        v26[0] = v20;
        v26[1] = 3221225472;
        v26[2] = ___loadLocTable_block_invoke_2;
        v26[3] = &unk_1E1335D58;
        v26[6] = a6;
        v26[7] = a5;
        v26[4] = &v28;
        v26[5] = v21;
        CFSetApply(Mutable, (uint64_t)v26);
        if (v21)
          CFRelease(v21);
        CFRelease(Mutable);
      }
      if (a7 && !*a7)
      {
        if (*((_BYTE *)v29 + 24))
        {
          v22 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("/LocTable/%@.lproj"), values[0]);
          *a7 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v22, kCFURLPOSIXPathStyle, 1u);
          CFRelease(v22);
        }
      }
      goto LABEL_23;
    }
  }
}

void sub_182B58850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

uint64_t _dictionaryContainsAllKeysInSet(uint64_t a1, void *a2)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 1;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___dictionaryContainsAllKeysInSet_block_invoke;
  v4[3] = &unk_1E1335DC8;
  v4[4] = &v5;
  v4[5] = a1;
  CFSetApply(a2, (uint64_t)v4);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_182B58948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFTypeRef __CFBundleCreateStringsFromPlistData(CFTypeRef cf, const __CFSet *a2, const __CFData *a3, int a4, void *a5)
{
  uint64_t v9;
  const __CFAllocator *v10;
  void *v11;
  CFOptionFlags v12;
  const __CFAllocator *v13;
  CFPropertyListRef v14;
  CFTypeID TypeID;
  NSObject *v16;
  CFErrorRef v17;
  NSObject *v18;
  const char *v19;
  NSObject *v20;
  uint32_t v21;
  NSObject *v22;
  CFTypeRef v24;
  CFErrorRef error;
  uint8_t buf[4];
  const __CFSet *v27;
  __int16 v28;
  CFTypeRef v29;
  __int16 v30;
  CFErrorRef v31;
  __int16 v32;
  CFErrorRef v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  error = 0;
  if (!a2)
  {
    v12 = (unint64_t)(a4 != 0) << 16;
    v13 = CFGetAllocator(cf);
    v14 = CFPropertyListCreateWithData(v13, a3, v12, 0, &error);
    if (v14)
    {
      v11 = (void *)v14;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID == CFGetTypeID(v11))
        return v11;
      v16 = _CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        __CFBundleCreateStringsFromPlistData_cold_1();
      v17 = (CFErrorRef)v11;
      goto LABEL_18;
    }
    if (error)
    {
      v22 = _CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412802;
        v27 = (const __CFSet *)cf;
        v28 = 2112;
        v29 = a5;
        v30 = 2112;
        v31 = error;
        v19 = "Unable to load .strings file: %@ / %@: %@";
        v20 = v22;
        v21 = 32;
        goto LABEL_22;
      }
LABEL_17:
      v17 = error;
LABEL_18:
      CFRelease(v17);
    }
    return 0;
  }
  v24 = 0;
  if (a4)
    v9 = 65537;
  else
    v9 = 1;
  v10 = CFGetAllocator(cf);
  if (!_CFPropertyListCreateFiltered(v10, a3, v9, a2, &v24, &error))
  {
    if (error)
    {
      v18 = _CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138413058;
        v27 = a2;
        v28 = 2112;
        v29 = cf;
        v30 = 2112;
        v31 = (CFErrorRef)a5;
        v32 = 2112;
        v33 = error;
        v19 = "Unable to read key-paths %@ from .strings file: %@ / %@: %@";
        v20 = v18;
        v21 = 42;
LABEL_22:
        _os_log_error_impl(&dword_182A8C000, v20, OS_LOG_TYPE_ERROR, v19, buf, v21);
        goto LABEL_17;
      }
      goto LABEL_17;
    }
    return 0;
  }
  return v24;
}

CFTypeRef CFBundleGetValueForInfoDictionaryKey(CFBundleRef bundle, CFStringRef key)
{
  CFTypeRef result;
  const __CFDictionary *LocalInfoDictionary;

  result = 0;
  if (bundle)
  {
    if (key)
    {
      LocalInfoDictionary = CFBundleGetLocalInfoDictionary(bundle);
      if (!LocalInfoDictionary || (result = CFDictionaryGetValue(LocalInfoDictionary, key)) == 0)
      {
        result = CFBundleGetInfoDictionary(bundle);
        if (result)
          return CFDictionaryGetValue((CFDictionaryRef)result, key);
      }
    }
  }
  return result;
}

CFDictionaryRef CFBundleGetLocalInfoDictionary(CFBundleRef bundle)
{
  unint64_t v2;
  void *ValueWithKeyPath;
  CFTypeID TypeID;
  CFMutableDictionaryRef v6;
  const __CFSet *v7;
  CFTypeID v8;
  CFTypeRef cf[2];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  CFTypeRef v14[2];
  CFDataRef data[2];
  __int128 v16;
  CFDataRef theData[2];
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  os_unfair_lock_lock_with_options();
  ValueWithKeyPath = (void *)*((_QWORD *)bundle + 4);
  if (!ValueWithKeyPath)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
    v18 = 0;
    v16 = 0u;
    *(_OWORD *)theData = 0u;
    *(_OWORD *)v14 = 0u;
    *(_OWORD *)data = 0u;
    _CFBundleGetStringsSources((uint64_t)bundle, 1, CFSTR("InfoPlist"), 0, (uint64_t)v14);
    if (data[0])
    {
      ValueWithKeyPath = (void *)CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, data[0], 1uLL, 0, 0);
      if (!ValueWithKeyPath)
        goto LABEL_20;
      TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(ValueWithKeyPath))
      {
        v6 = 0;
LABEL_19:
        CFRelease(ValueWithKeyPath);
        ValueWithKeyPath = v6;
LABEL_20:
        v11 = v16;
        v12 = *(_OWORD *)theData;
        v13 = v18;
        *(_OWORD *)cf = *(_OWORD *)v14;
        v10 = *(_OWORD *)data;
        _CFBundleReleaseStringsSources_0((uint64_t)cf);
        os_unfair_lock_lock_with_options();
        if (*((_QWORD *)bundle + 4))
        {
          if (ValueWithKeyPath)
            CFRelease(ValueWithKeyPath);
          ValueWithKeyPath = (void *)*((_QWORD *)bundle + 4);
        }
        else
        {
          *((_QWORD *)bundle + 4) = ValueWithKeyPath;
        }
        goto LABEL_3;
      }
    }
    else
    {
      ValueWithKeyPath = 0;
      if (!theData[1] || !v14[1])
        goto LABEL_20;
      v7 = CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, &v14[1], 1, &kCFTypeSetCallBacks);
      cf[0] = 0;
      ValueWithKeyPath = 0;
      if (_CFPropertyListCreateFiltered((const __CFAllocator *)&__kCFAllocatorSystemDefault, theData[1], 1, v7, cf, 0))
      {
        ValueWithKeyPath = (void *)_CFPropertyListGetValueWithKeyPath(cf[0], (const __CFString *)v14[1]);
        if (ValueWithKeyPath)
        {
          v8 = CFDictionaryGetTypeID();
          if (v8 == CFGetTypeID(ValueWithKeyPath))
            CFRetain(ValueWithKeyPath);
          else
            ValueWithKeyPath = 0;
        }
      }
      if (cf[0])
        CFRelease(cf[0]);
      CFRelease(v7);
      if (!ValueWithKeyPath)
        goto LABEL_20;
    }
    _CFBundleInfoPlistProcessInfoDictionary(ValueWithKeyPath);
    v6 = _parseBundleStrings((uint64_t)bundle, (CFDictionaryRef)ValueWithKeyPath);
    if (!v6)
      goto LABEL_20;
    goto LABEL_19;
  }
LABEL_3:
  os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
  return (CFDictionaryRef)ValueWithKeyPath;
}

void _CFBundleGetLocTableProvenanceForLanguage(const __CFData *a1, const __CFString *a2, _BYTE *a3, BOOL *a4)
{
  NSSet *v8;
  const __CFNumber *ValueWithKeyPath;
  const __CFNumber *v10;
  char v11;
  _BOOL4 v12;
  const __CFSet *v13;
  const __CFSet *v14;
  char valuePtr;
  CFTypeRef cf;
  CFTypeRef v17[2];

  v17[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  v17[0] = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("LocProvenance"));
  CFStringAppend((CFMutableStringRef)v17[0], CFSTR(":"));
  CFStringAppend((CFMutableStringRef)v17[0], a2);
  v8 = -[NSSet initWithObjects:count:]([NSSet alloc], "initWithObjects:count:", v17, 1);
  cf = 0;
  if (!_CFPropertyListCreateFiltered(0, a1, 0, (const __CFSet *)v8, &cf, 0))
    goto LABEL_10;
  ValueWithKeyPath = (const __CFNumber *)_CFPropertyListGetValueWithKeyPath(cf, (const __CFString *)v17[0]);
  valuePtr = 0;
  if (ValueWithKeyPath
    && (v10 = ValueWithKeyPath, CFGetTypeID(ValueWithKeyPath) == 22)
    && CFNumberGetValue(v10, kCFNumberCharType, &valuePtr))
  {
    v11 = valuePtr;
    *a3 = valuePtr & 1;
    *a4 = (v11 & 2) != 0;
    v12 = 1;
  }
  else
  {
    v12 = CFEqual(a2, CFSTR("none")) != 0;
  }
  if (cf)
    CFRelease(cf);
  if (!v12)
  {
LABEL_10:
    v13 = _CFPropertyListCopyTopLevelKeys(&__kCFAllocatorSystemDefault, a1, 0, 0);
    if (v13)
    {
      v14 = v13;
      if (CFSetContainsValue(v13, a2))
      {
        *a3 = 1;
        *a4 = 1;
      }
      CFRelease(v14);
    }
  }
  CFRelease(v17[0]);

}

void ___loadLocTable_block_invoke_2(uint64_t a1, const __CFString *a2)
{
  const void *ValueWithKeyPath;
  const void *v5;
  const void *ValueAtIndex;

  ValueWithKeyPath = _CFPropertyListGetValueWithKeyPath(*(const void **)(a1 + 40), a2);
  if (ValueWithKeyPath)
  {
    v5 = ValueWithKeyPath;
    if (CFGetTypeID(ValueWithKeyPath) == 18)
      *(_BYTE *)(*(_QWORD *)(a1 + 48) + 75) = 1;
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, 1);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 56), ValueAtIndex, v5);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

const void *_CFPropertyListGetValueWithKeyPath(const void *a1, const __CFString *cf)
{
  const void *result;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  uint64_t v9;
  const __CFString *ValueAtIndex;
  CFTypeID v11;
  const void *Value;
  SInt32 IntValue;

  result = 0;
  if (a1 && cf)
  {
    if (CFGetTypeID(cf) == 19)
      ArrayBySeparatingStrings = (const __CFArray *)CFRetain(cf);
    else
      ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)&__kCFAllocatorSystemDefault, cf, CFSTR(":"));
    v6 = ArrayBySeparatingStrings;
    Count = CFArrayGetCount(ArrayBySeparatingStrings);
    if (Count >= 1)
    {
      v8 = Count;
      v9 = 1;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, v9 - 1);
        v11 = CFGetTypeID(a1);
        if (v11 == 19)
        {
          IntValue = CFStringGetIntValue(ValueAtIndex);
          Value = CFArrayGetValueAtIndex((CFArrayRef)a1, IntValue);
        }
        else
        {
          if (v11 != 18)
          {
            a1 = 0;
            break;
          }
          Value = CFDictionaryGetValue((CFDictionaryRef)a1, ValueAtIndex);
        }
        a1 = Value;
        if (v9 < v8)
        {
          ++v9;
          if (Value)
            continue;
        }
        break;
      }
    }
    CFRelease(v6);
    return a1;
  }
  return result;
}

CFMutableDictionaryRef _parseBundleStrings(uint64_t a1, CFDictionaryRef theDict)
{
  CFIndex Count;
  CFMutableDictionaryRef Mutable;
  _QWORD v7[7];

  v7[6] = *MEMORY[0x1E0C80C00];
  Count = CFDictionaryGetCount(theDict);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[2] = ___parseBundleStrings_block_invoke;
  v7[3] = &__block_descriptor_tmp_117;
  v7[4] = a1;
  v7[5] = Mutable;
  CFDictionaryApply(theDict, (uint64_t)v7);
  return Mutable;
}

CFStringTokenizerTokenType CFStringTokenizerAdvanceToNextToken(CFStringTokenizerRef tokenizer)
{
  return __NLStringTokenizerAdvanceToNextToken(*((_QWORD *)tokenizer + 2));
}

void destroyBlock(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 32), 7);
}

uint64_t _CFURLComponentsSetScheme(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setScheme:", a2);
  return 1;
}

void sub_182B59274(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
  JUMPOUT(0x182B5926CLL);
}

uint64_t _CFURLComponentsSchemeIsValid(const __CFString *a1)
{
  CFIndex Length;
  CFIndex v3;
  uint64_t v4;
  const __CFString *CharactersPtr;
  UniChar isa;
  const char *CStringPtr;
  CFRange v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  UniChar v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v25;
  uint64_t v26;
  UniChar buffer[8];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  CFStringRef theString[2];
  __int128 v37;
  __int128 v38;
  CFIndex v39;
  uint64_t v40;
  CFRange v41;

  v40 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  Length = CFStringGetLength(a1);
  v3 = Length - 1;
  if (Length < 1)
    return 0;
  v4 = Length;
  v37 = 0u;
  v35 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  *(_OWORD *)buffer = 0u;
  theString[0] = a1;
  v39 = 0;
  v38 = (unint64_t)Length;
  CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(a1);
  theString[1] = CharactersPtr;
  if (CharactersPtr)
  {
    *((_QWORD *)&v38 + 1) = 0;
    v39 = 0;
    *(_QWORD *)&v37 = 0;
    isa = (UniChar)CharactersPtr->isa;
  }
  else
  {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
    *((_QWORD *)&v38 + 1) = 0;
    v39 = 0;
    *(_QWORD *)&v37 = CStringPtr;
    if (CStringPtr)
    {
      isa = *CStringPtr;
    }
    else
    {
      v9.length = v4 >= 64 ? 64 : v4;
      v39 = v9.length;
      v9.location = 0;
      CFStringGetCharacters(a1, v9, buffer);
      isa = buffer[-*((_QWORD *)&v38 + 1)];
    }
  }
  if ((unsigned __int16)((isa & 0xFFDF) - 91) < 0xFFE6u)
    return 0;
  if ((unint64_t)v4 >= 2)
  {
    v11 = 0;
    v10 = 0;
    v12 = -1;
    v13 = 65;
    v14 = 1;
    do
    {
      if (v14 >= 4)
        v15 = 4;
      else
        v15 = v14;
      if (theString[1])
      {
        v16 = *((_WORD *)&theString[1]->isa + v11 + *((_QWORD *)&v37 + 1) + 1);
      }
      else if ((_QWORD)v37)
      {
        v16 = *(char *)(v37 + *((_QWORD *)&v37 + 1) + v11 + 1);
      }
      else
      {
        if (v39 <= v11 + 1 || (v17 = *((_QWORD *)&v38 + 1), *((uint64_t *)&v38 + 1) > v11 + 1))
        {
          v18 = -v15;
          v19 = v15 + v12;
          v20 = v13 - v15;
          v21 = v11 + v18;
          v22 = v21 + 1;
          v23 = v21 + 65;
          if (v23 >= (uint64_t)v38)
            v23 = v38;
          *((_QWORD *)&v38 + 1) = v22;
          v39 = v23;
          if ((uint64_t)v38 < v20)
            v20 = v38;
          v41.length = v20 + v19;
          v41.location = v22 + *((_QWORD *)&v37 + 1);
          CFStringGetCharacters(theString[0], v41, buffer);
          v17 = *((_QWORD *)&v38 + 1);
        }
        v16 = buffer[v11 + 1 - v17];
      }
      if (v16 > 0x7Fu)
        break;
      if ((unsigned __int16)(v16 - 48) >= 0xAu && (unsigned __int16)((v16 & 0xFFDF) - 65) >= 0x1Au)
      {
        v25 = v16;
        v26 = (1 << v16) & 0x680000000000;
        if (v25 > 0x2E || v26 == 0)
          break;
      }
      ++v14;
      v10 = v11 + 2 >= v4;
      ++v11;
      --v12;
      ++v13;
    }
    while (v3 != v11);
  }
  else
  {
    return 1;
  }
  return v10;
}

__CFBundle *_CFBundleGetBundleWithIdentifierAndLibraryName(void *a1, const __CFString *a2)
{
  __CFBundle *v3;

  if (a2)
    _CFBundleEnsureBundlesUpToDateWithHint(a2);
  os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  v3 = _CFBundleGetFromTablesLocked(a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  return v3;
}

void _CFBundleEnsureBundlesUpToDateWithHint(const __CFString *a1)
{
  __CFArray *v2;
  __CFArray *v3;

  CFBundleGetMainBundle();
  v2 = _CFBundleDYLDCopyLoadedImagePathsForHint(a1);
  if (v2)
  {
    v3 = v2;
    _CFBundleEnsureBundlesExistForImagePaths(v2);
    CFRelease(v3);
  }
}

void _CFBundleEnsureBundlesExistForImagePaths(const __CFArray *a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex i;
  const void *ValueAtIndex;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v3 = Count;
    for (i = 0; i != v3; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      _CFBundleEnsureBundleExistsForImagePath((uint64_t)ValueAtIndex, 1);
    }
  }
}

__CFArray *_CFBundleDYLDCopyLoadedImagePathsForHint(const __CFString *a1)
{
  uint32_t v2;
  uint64_t Length;
  const char *v4;
  mach_header_64 *v5;
  uint64_t location;
  int v7;
  uint32_t v10;
  const char *image_name;
  const char *v12;
  char *v13;
  char *v14;
  CFStringRef v15;
  const __CFString *v16;
  char *v17;
  __CFArray *v18;
  CFIndex Count;
  CFIndex v20;
  CFIndex i;
  const __CFString *ValueAtIndex;
  CFStringRef v23;
  CFStringRef v24;
  mach_header_64 *v26;
  const char *v27;
  uint32_t v28;
  const __CFString *cf;
  __CFArray *theArray;
  CFRange result;
  uint64_t v32;
  CFRange v33;
  CFRange v34;
  CFRange v35;
  CFRange v36;
  CFRange v37;

  v32 = *MEMORY[0x1E0C80C00];
  v2 = _dyld_image_count();
  theArray = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  Length = CFStringGetLength(a1);
  result.location = 0;
  result.length = 0;
  v4 = _CFProcessPath();
  v5 = _NSGetMachExecuteHeader();
  location = 0;
  if (Length >= 15)
  {
    v33.location = 0;
    v33.length = Length;
    if (!CFStringFindWithOptions(a1, CFSTR(".framework"), v33, 0xDuLL, &result)
      || (location = result.location, result.location < 1)
      || result.length <= 0)
    {
      v34.location = 0;
      v34.length = Length;
      if (!CFStringFindWithOptions(a1, CFSTR("framework"), v34, 0xDuLL, &result)
        || (location = result.location, result.location < 1)
        || result.length <= 0)
      {
        v35.location = 0;
        v35.length = Length;
        v7 = CFStringFindWithOptions(a1, CFSTR("fw"), v35, 0xDuLL, &result);
        if (result.length <= 0 || result.location <= 0 || v7 == 0)
          location = 0;
        else
          location = result.location;
      }
    }
  }
  if (v2)
  {
    v10 = 0;
    v28 = v2;
    v26 = v5;
    v27 = v4;
    do
    {
      image_name = _dyld_get_image_name(v10);
      v12 = _CFBundleNormalizedPath(image_name);
      if (v12)
      {
        v13 = (char *)v12;
        if ((!v4 || strcmp(v12, v4)) && v5 != (mach_header_64 *)_dyld_get_image_header(v10))
        {
          v14 = strrchr(v13, 47);
          if (v14)
          {
            v15 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14 + 1);
            if (v15)
            {
              v16 = v15;
              v17 = __CFgetenvIfNotRestricted("DYLD_IMAGE_SUFFIX");
              cf = v16;
              v18 = _CFBundleDYLDCreateLoadedImagePathVariants(v17, v16);
              Count = CFArrayGetCount(v18);
              if (Count >= 1)
              {
                v20 = Count;
                for (i = 0; i != v20; ++i)
                {
                  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v18, i);
                  v36.location = 0;
                  v36.length = Length;
                  if (!CFStringFindWithOptions(a1, ValueAtIndex, v36, 0xDuLL, 0))
                  {
                    if (location < 1)
                      continue;
                    v37.location = 0;
                    v37.length = location;
                    if (!CFStringFindWithOptions(a1, ValueAtIndex, v37, 0xDuLL, 0))
                      continue;
                  }
                  v23 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
                  if (v23)
                  {
                    v24 = v23;
                    CFArrayAppendValue(theArray, v23);
                    CFRelease(v24);
                  }
                }
              }
              CFRelease(v18);
              CFRelease(cf);
              v2 = v28;
              v5 = v26;
              v4 = v27;
            }
          }
        }
      }
      ++v10;
    }
    while (v10 != v2);
  }
  return theArray;
}

const char *_CFBundleNormalizedPath(const char *result)
{
  const char *v1;
  int v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    if (!strncmp(result, "/private/preboot/Cryptexes/OS/", 0x1EuLL))
    {
      return v1 + 29;
    }
    else
    {
      v2 = strncmp(v1, "/System/Cryptexes/OS/", 0x15uLL);
      v3 = 20;
      if (v2)
        v3 = 0;
      return &v1[v3];
    }
  }
  return result;
}

uint64_t _CFXNotificationCenterCreate(__objc2_class **a1, int *a2)
{
  uint64_t Instance;
  uint64_t v5;
  int v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  _xpc_endpoint_s *v22;
  const char *v23;
  int v24;
  qos_class_t v25;
  NSObject *v26;
  NSObject *v27;
  _xpc_connection_s *v28;
  _xpc_connection_s *v29;
  _QWORD v31[6];

  v31[5] = *MEMORY[0x1E0C80C00];
  if (*a2 == 1)
  {
    if ((__CF_FORK_STATE & 2) == 0)
      __CF_USED();
    if ((__CF_FORK_STATE & 1) != 0)
      __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
    if ((__CF_FORK_STATE & 1) != 0)
      return 0;
  }
  Instance = _CFRuntimeCreateInstance(a1, 0x34uLL, 16, 0);
  v5 = Instance;
  if (Instance)
  {
    v6 = *a2;
    if (*a2 != 1)
      goto LABEL_17;
    v7 = (unint64_t *)(Instance + 8);
    v8 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      v9 = __ldaxr(v7);
      if (v9 != v8)
        break;
      if (__stlxr(v8 | 2, v7))
        goto LABEL_14;
      v10 = 1;
LABEL_15:
      v8 = v9;
      if (v10)
      {
        v6 = *a2;
LABEL_17:
        if (v6 == 2)
        {
          v11 = (unint64_t *)(Instance + 8);
          v12 = atomic_load((unint64_t *)(Instance + 8));
          while (1)
          {
            v13 = __ldaxr(v11);
            if (v13 != v12)
              break;
            if (__stlxr(v12 | 1, v11))
              goto LABEL_23;
            v14 = 1;
LABEL_24:
            v12 = v13;
            if (v14)
              goto LABEL_25;
          }
          __clrex();
LABEL_23:
          v14 = 0;
          goto LABEL_24;
        }
LABEL_25:
        v15 = (unint64_t *)(Instance + 8);
        v16 = atomic_load((unint64_t *)(Instance + 8));
        while (2)
        {
          v17 = __ldaxr(v15);
          if (v17 == v16)
          {
            if (!__stlxr(v16 & 0xFFFFFFFFFFFFFFF7, v15))
            {
              v18 = 1;
              goto LABEL_31;
            }
          }
          else
          {
            __clrex();
          }
          v18 = 0;
LABEL_31:
          v16 = v17;
          if (v18)
          {
            if ((*a2 - 1) >= 2)
              v19 = 1;
            else
              v19 = 2;
            CFXNotificationRegistrarCreate(&__kCFAllocatorSystemDefault, v19);
            *(_QWORD *)(v5 + 16) = v20;
            if (*a2 == 1)
            {
              v21 = _CFProcessPath();
              if (v21)
              {
                if (!strcmp("/usr/sbin/distnoted", v21))
                  __CFIsDistNoteDaemon = 1;
              }
            }
            *(_QWORD *)(v5 + 24) = 0;
            if (*a2 == 1 && (__CFIsDistNoteDaemon & 1) == 0)
            {
              v22 = (_xpc_endpoint_s *)*((_QWORD *)a2 + 4);
              v23 = (const char *)*((_QWORD *)a2 + 2);
              v24 = *((unsigned __int8 *)a2 + 9);
              v25 = qos_class_main();
              v26 = dispatch_queue_attr_make_with_qos_class(0, v25, 0);
              v27 = dispatch_queue_create("com.apple.notification_center.server_conn", v26);
              if (v22)
              {
                v28 = xpc_connection_create_from_endpoint(v22);
                *(_QWORD *)(v5 + 24) = v28;
                xpc_connection_set_target_queue(v28, v27);
              }
              else
              {
                *(_QWORD *)(v5 + 24) = xpc_connection_create_mach_service(v23, v27, 2 * (v24 != 0));
              }
              dispatch_release(v27);
              v29 = *(_xpc_connection_s **)(v5 + 24);
              v31[0] = MEMORY[0x1E0C809B0];
              v31[1] = 3221225472;
              v31[2] = ____CFXNotificationCenterSetupConnection_block_invoke;
              v31[3] = &__block_descriptor_40_e33_v16__0__NSObject_OS_xpc_object__8l;
              v31[4] = v5;
              xpc_connection_set_event_handler(v29, v31);
              xpc_connection_activate(*(xpc_connection_t *)(v5 + 24));
            }
            return v5;
          }
          continue;
        }
      }
    }
    __clrex();
LABEL_14:
    v10 = 0;
    goto LABEL_15;
  }
  return v5;
}

void CFXNotificationRegistrarCreate(__objc2_class **a1, uint64_t a2)
{
  uint64_t Instance;

  Instance = _CFRuntimeCreateInstance(a1, 0x46uLL, 160, 0);
  *(_QWORD *)(Instance + 24) = a2;
  *(_DWORD *)(Instance + 16) = 0;
  *(_DWORD *)(Instance + 112) = -1;
  *(_DWORD *)(Instance + 136) = -1;
  *(_DWORD *)(Instance + 160) = -1;
  *(_DWORD *)(Instance + 80) = -1;
  atomic_store(1u, (unsigned int *)(Instance + 168));
}

void __CFInitialize()
{
  uint64_t v0;
  const char *v1;
  char *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  CFTypeID TypeID;
  CFTypeID v7;
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID v11;
  CFTypeID v12;
  CFTypeID v13;
  CFTypeID v14;
  char *v15;
  char *v16;
  void *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  if (!__CFInitialized && (__CFInitializing & 1) == 0)
  {
    v0 = 0;
    __CFInitializing = 1;
    __CFProphylacticAutofsAccess = 1;
    do
    {
      v1 = (&__CFEnv)[v0];
      if (v1)
      {
        v2 = getenv(v1);
        if (v2)
          (&__CFEnv)[v0 + 1] = v2;
      }
      v0 += 2;
    }
    while (v0 != 22);
    __exceptionInit();
    objc_setForwardHandler(_CF_forwarding_prep_0, 0);
    objc_setEnumerationMutationHandler((void (__cdecl *)(id))__NSFastEnumerationMutationHandler);
    v21[0] = 0;
    _CFStringGetUserDefaultEncoding((_DWORD *)v21 + 1, v21);
    pthread_atfork((void (*)(void))__cf_atfork_prepare, 0, __cf_atfork_child);
    v3 = getenv("NSObjCMessageLoggingEnabled");
    if (v3 && (*v3 | 0x20) == 0x79)
      instrumentObjcMessageSends();
    _CFRuntimeBridgeClasses(0, "__NSCFType");
    v4 = __CFRuntimeBuiltinObjCClassTable[0];
    v5 = 1u;
    do
      __CFRuntimeBuiltinObjCClassTable[v5++] = v4;
    while (v5 != 72);
    _CFRuntimeBridgeClasses(7uLL, "__NSCFString");
    _CFRuntimeBridgeClasses(0x10uLL, "NSNull");
    _CFRuntimeBridgeClasses(0x11uLL, "__NSCFSet");
    _CFRuntimeBridgeClasses(0x12uLL, "__NSCFDictionary");
    _CFRuntimeBridgeClasses(0x13uLL, "__NSCFArray");
    _CFRuntimeBridgeClasses(0x14uLL, "__NSCFData");
    _CFRuntimeBridgeClasses(0x15uLL, "__NSCFBoolean");
    _CFRuntimeBridgeClasses(0x16uLL, "__NSCFNumber");
    CFNumberGetTypeID();
    __CFCharacterSetInitialize();
    TypeID = CFMachPortGetTypeID();
    _CFRuntimeBridgeClasses(TypeID, "NSMachPort");
    v7 = CFURLGetTypeID();
    _CFRuntimeBridgeClasses(v7, "NSURL");
    v8 = CFRunLoopTimerGetTypeID();
    _CFRuntimeBridgeClasses(v8, "__NSCFTimer");
    v9 = CFAttributedStringGetTypeID();
    _CFRuntimeBridgeClasses(v9, "__NSCFAttributedString");
    v10 = CFLocaleGetTypeID();
    _CFRuntimeBridgeClasses(v10, "__NSCFLocale");
    v11 = CFErrorGetTypeID();
    _CFRuntimeBridgeClasses(v11, "__NSCFError");
    v12 = CFCharacterSetGetTypeID();
    _CFRuntimeBridgeClasses(v12, "__NSCFCharacterSet");
    v13 = CFReadStreamGetTypeID();
    _CFRuntimeBridgeClasses(v13, "__NSCFInputStream");
    v14 = CFWriteStreamGetTypeID();
    _CFRuntimeBridgeClasses(v14, "__NSCFOutputStream");
    _CFProcessPath();
    *MEMORY[0x1E0C80CD8] = _CFAutoreleasePoolPush;
    *MEMORY[0x1E0C80D18] = _CFAutoreleasePoolPop;
    __CFOAInitialize();
    __CFStringInitializeSystemEncoding();
    __CFMakeNSBlockClasses();
    v15 = getenv("NSZombieEnabled");
    if (v15 && (*v15 | 0x20) == 0x79 && !__CFZombieEnabled)
    {
      __CFZombieEnabled = -1;
      __CFZombifyNSObject();
    }
    v16 = getenv("NSDeallocateZombies");
    if (v16 && (*v16 | 0x20) == 0x79)
      __CFDeallocateZombies = -1;
    __CFProphylacticAutofsAccess = 0;
    _os_log_set_nscf_formatter();
    v17 = _CFGetHandleForInsertedOrInterposingLibrary("libclang_rt.tsan");
    if (v17)
    {
      v18 = v17;
      __cf_tsanRegisterTagFunction = (uint64_t (*)(_QWORD))dlsym(v17, "__tsan_external_register_tag");
      __cf_tsanAssignTagFunction = (uint64_t (*)(void))dlsym(v18, "__tsan_external_assign_tag");
      __cf_tsanReadFunction = (uint64_t (*)(_QWORD, _QWORD, _QWORD))dlsym(v18, "__tsan_external_read");
      v19 = dlsym(v18, "__tsan_external_write");
      __cf_tsanWriteFunction = (uint64_t (*)(_QWORD, _QWORD, _QWORD))v19;
      if (!__cf_tsanRegisterTagFunction
        || !__cf_tsanAssignTagFunction
        || !__cf_tsanReadFunction
        || !v19
        || (__CFTSANTagMutableArray = __cf_tsanRegisterTagFunction("NSMutableArray"),
            __CFTSANTagMutableDictionary = __cf_tsanRegisterTagFunction("NSMutableDictionary"),
            __CFTSANTagMutableSet = __cf_tsanRegisterTagFunction("NSMutableSet"),
            __CFTSANTagMutableOrderedSet = __cf_tsanRegisterTagFunction("NSMutableOrderedSet"),
            v20 = __cf_tsanRegisterTagFunction("NSMutableData"),
            __CFTSANTagMutableData = v20,
            !__CFTSANTagMutableArray)
        || !__CFTSANTagMutableDictionary
        || !__CFTSANTagMutableSet
        || !__CFTSANTagMutableOrderedSet
        || !v20)
      {
        __cf_tsanRegisterTagFunction = 0;
        __cf_tsanAssignTagFunction = 0;
        __cf_tsanReadFunction = 0;
        __cf_tsanWriteFunction = 0;
        __CFTSANTagMutableArray = 0;
        __CFTSANTagMutableDictionary = 0;
        __CFTSANTagMutableSet = 0;
        __CFTSANTagMutableOrderedSet = 0;
        __CFTSANTagMutableData = 0;
      }
    }
    __CFInitializing = 0;
    __CFInitialized = 1;
  }
}

CFTypeID CFLocaleGetTypeID(void)
{
  return 55;
}

void _CFRuntimeBridgeClasses(unint64_t a1, const char *a2)
{
  Class FutureClass;
  uint64_t *v5;
  uint64_t v6;

  os_unfair_lock_lock_with_options();
  if (a1 > 0x47)
  {
    v6 = __CFRuntimeClassTables[(((int)a1 - 72) >> 6) + 16];
    FutureClass = objc_getFutureClass(a2);
    v5 = (uint64_t *)(v6 + 8 * (((_DWORD)a1 - 72) & 0x3F));
  }
  else
  {
    FutureClass = objc_getFutureClass(a2);
    v5 = &__CFRuntimeBuiltinObjCClassTable[a1];
  }
  *v5 = (uint64_t)FutureClass;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
}

uint64_t fileOpen(void *a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  CFTypeID v8;
  CFTypeID TypeID;
  _BOOL4 v10;
  int v11;
  int v12;
  off_t v13;
  int v14;
  uint64_t result;
  UInt8 buffer[1026];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v8 = CFGetTypeID(a1);
  TypeID = CFReadStreamGetTypeID();
  v10 = v8 == TypeID;
  *a3 = 1;
  if (!*(_QWORD *)a4)
  {
    if (*(_QWORD *)(a4 + 16))
      constructCFFD(a4, v10, a1);
    return 1;
  }
  if (!CFURLGetFileSystemRepresentation(*(CFURLRef *)a4, 1u, buffer, 1026))
  {
    v14 = 2;
    goto LABEL_19;
  }
  if (v8 == TypeID)
    v11 = 0;
  else
    v11 = 1537;
  if ((*(_QWORD *)(a4 + 24) & 8) != 0)
    v12 = open((const char *)buffer, v11 & 0x3F7 | 8, 438);
  else
    v12 = open((const char *)buffer, v11, 438);
  *(_DWORD *)(a4 + 8) = v12;
  if ((v12 & 0x80000000) == 0)
  {
    v13 = *(_QWORD *)(a4 + 32);
    if ((v13 == -1 || lseek(v12, v13, 0) != -1) && (!*(_QWORD *)(a4 + 16) || constructCFFD(a4, v10, a1)))
      return 1;
  }
  *(_QWORD *)(a4 + 24) |= 0x20uLL;
  v14 = *__error();
LABEL_19:
  result = 0;
  *(_DWORD *)(a2 + 8) = v14;
  *(_QWORD *)a2 = 1;
  return result;
}

CFTypeID CFReadStreamGetTypeID(void)
{
  return 38;
}

const char *_CFProcessPath()
{
  const char *result;
  uint64_t v1;
  uint64_t v2;
  char *v3;
  char *v4;
  uint64_t v5;
  char v6[1040];
  uint32_t bufsize[2];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  result = (const char *)__CFProcessPath;
  if (!__CFProcessPath)
  {
    getpid();
    bufsize[1] = 0;
    bufsize[0] = 1026;
    v1 = csops();
    MEMORY[0x1E0C80A78](v1, v2);
    if (!_NSGetExecutablePath(v6, bufsize))
    {
      v3 = strdup(v6);
      __CFProcessPath = (uint64_t)v3;
      v4 = strrchr(v3, 47);
      if (v4)
        v5 = (uint64_t)(v4 + 1);
      else
        v5 = (uint64_t)v3;
      __CFprogname = v5;
    }
    result = (const char *)__CFProcessPath;
    if (!__CFProcessPath)
    {
      result = "";
      __CFProcessPath = (uint64_t)"";
      __CFprogname = (uint64_t)"";
    }
  }
  return result;
}

CFTypeID CFCharacterSetGetTypeID(void)
{
  return 25;
}

CFTypeID CFRunLoopTimerGetTypeID(void)
{
  return 47;
}

CFTypeID CFMachPortGetTypeID(void)
{
  return 36;
}

objc_uncaught_exception_handler __exceptionInit()
{
  objc_setExceptionPreprocessor((objc_exception_preprocessor)__exceptionPreprocess);
  objc_setExceptionMatcher((objc_exception_matcher)__exceptionMatch);
  return objc_setUncaughtExceptionHandler((objc_uncaught_exception_handler)__handleUncaughtException);
}

uint64_t __CFStringInitializeSystemEncoding()
{
  __CFIsReadyToInitializeSystemEncoding = 1;
  return CFStringGetSystemEncoding();
}

void __CFOAInitialize()
{
  void (*v0)(void);

  if (__CFgetenv("OAKeepAllocationStatistics"))
  {
    v0 = (void (*)(void))__CFOAInitialize_dyfunc;
    if (__CFOAInitialize_dyfunc == -1)
    {
      v0 = (void (*)(void))dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_OAInitialize");
      __CFOAInitialize_dyfunc = (uint64_t)v0;
      if (!v0)
        return;
    }
    else if (!__CFOAInitialize_dyfunc)
    {
      return;
    }
    v0();
    __CFObjectAllocRecordAllocationFunction = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_OARecordAllocationEvent");
    __CFObjectAllocSetLastAllocEventNameFunction = (uint64_t (*)(void))dlsym((void *)0xFFFFFFFFFFFFFFFELL, "_OASetLastAllocationEventName");
    __CFOAInitializeNSObject();
    __CFOASafe = 1;
  }
}

void __CFMakeNSBlockClasses()
{
  objc_class *v0;
  objc_class *v1;
  objc_class *v2;
  objc_class *v3;
  objc_class *v4;
  objc_class *v5;
  objc_class *v6;
  objc_class *v7;
  objc_class *v8;
  objc_class *v9;
  objc_class *v10;
  Block_callbacks_RR v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (objc_lookUpClass("__NSStackBlock__"))
  {
    v0 = (objc_class *)objc_opt_class();
    v1 = objc_lookUpClass("__NSStackBlock__");
    class_setSuperclass(v1, v0);
    v2 = objc_lookUpClass("__NSMallocBlock__");
    class_setSuperclass(v2, v0);
    v3 = objc_lookUpClass("__NSAutoBlock__");
    class_setSuperclass(v3, v0);
    v4 = objc_lookUpClass("__NSGlobalBlock__");
    class_setSuperclass(v4, v0);
  }
  else
  {
    objc_lookUpClass("__NSStackBlock");
    v5 = (objc_class *)MEMORY[0x1E0C809B0];
    objc_initializeClassPair();
    objc_lookUpClass("__NSMallocBlock");
    v6 = (objc_class *)MEMORY[0x1E0C809A0];
    objc_initializeClassPair();
    objc_lookUpClass("__NSAutoBlock");
    v7 = (objc_class *)MEMORY[0x1E0C80988];
    objc_initializeClassPair();
    objc_lookUpClass("__NSFinalizingBlock");
    v8 = (objc_class *)MEMORY[0x1E0C80990];
    objc_initializeClassPair();
    objc_lookUpClass("__NSGlobalBlock");
    v9 = (objc_class *)MEMORY[0x1E0C80998];
    objc_initializeClassPair();
    objc_lookUpClass("__NSBlockVariable");
    v10 = (objc_class *)MEMORY[0x1E0C809B8];
    objc_initializeClassPair();
    objc_registerClassPair(v5);
    objc_registerClassPair(v6);
    objc_registerClassPair(v7);
    objc_registerClassPair(v8);
    objc_registerClassPair(v9);
    objc_registerClassPair(v10);
  }
  v11 = *(Block_callbacks_RR *)ymmword_1E1335A10;
  _Block_use_RR2(&v11);
}

void __CFCharacterSetInitialize()
{
  if (__CFCharacterSetInitialize_initOnce != -1)
    dispatch_once(&__CFCharacterSetInitialize_initOnce, &__block_literal_global_0);
}

uint64_t _CFStringGetUserDefaultEncoding(_DWORD *a1, _DWORD *a2)
{
  int v4;
  char *v5;
  char *v6;
  uint64_t result;
  int v8;
  char *v9;
  char __str[32];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v4 = _CFGetEUID();
  v5 = __CFgetenv("__CF_USER_TEXT_ENCODING");
  v9 = v5;
  if (v5)
  {
    if (strtol_l(v5, &v9, 0, 0) == v4 && *v9 == 58)
    {
      v6 = ++v9;
      goto LABEL_8;
    }
    v9 = 0;
  }
  if (v4 < 1)
    goto LABEL_14;
  snprintf(__str, 0x20uLL, "0x%X:0:0", v4);
  setenv("__CF_USER_TEXT_ENCODING", __str, 1);
  v6 = v9;
  if (!v9)
    goto LABEL_14;
LABEL_8:
  result = strtol_l(v6, &v9, 0, 0);
  if ((result & 0xFFFFFFFE) == 4)
    v8 = 0;
  else
    v8 = result;
  *a1 = v8;
  if (*v9 != 58)
  {
LABEL_14:
    result = 0;
    *a1 = 0;
    if (!a2)
      return result;
    goto LABEL_15;
  }
  if (!a2)
    return result;
  result = strtol_l(++v9, 0, 0, 0);
LABEL_15:
  *a2 = result;
  return result;
}

void *_CFGetHandleForInsertedOrInterposingLibrary(const char *a1)
{
  if (!a1)
    _CFGetHandleForInsertedOrInterposingLibrary_cold_1();
  if (dyld_has_inserted_or_interposing_libraries())
    return _CFGetHandleForLoadedLibrary(a1);
  else
    return 0;
}

CFTypeID CFWriteStreamGetTypeID(void)
{
  return 39;
}

CFTypeID CFAttributedStringGetTypeID(void)
{
  return 62;
}

void sub_182B5AD3C(_Unwind_Exception *a1)
{
  free(0);
  _Unwind_Resume(a1);
}

void _CFGetPathExtensionRangesFromPathComponentUniChars(const __CFString *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  UniChar *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  UniChar v17;
  CFIndex v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  CFIndex v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  CFRange v26;
  CFIndex v27;
  uint64_t v28;
  UniChar *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  unsigned int v33;
  unint64_t v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  UniChar *v40;
  CFRange v41;
  char *v42;
  UniChar *v43;
  UniChar v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  CFIndex v49;
  UniChar *v50;
  __int16 v51;
  uint64_t v52;
  uint64_t v53;
  CFIndex v54;
  uint64_t v55;
  CFIndex v56;
  CFRange v57;
  CFIndex v58;
  uint64_t v59;
  CFIndex v60;
  char *v61;
  CFIndex v62;
  int64_t v63;
  uint64_t v64;
  __int16 v65;
  uint64_t v67;
  uint64_t v68;
  CFIndex v69;
  uint64_t v70;
  CFIndex v71;
  CFRange v72;
  CFIndex v73;
  int64_t v74;
  int64_t v75;
  uint64_t v76;
  __int16 v77;
  uint64_t v79;
  uint64_t v80;
  CFIndex v81;
  uint64_t v82;
  CFIndex v83;
  CFRange v84;
  CFIndex v85;
  __int16 v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  CFIndex v90;
  _BOOL4 v91;
  _BOOL4 v92;
  int64_t v93;
  UniChar buffer[8];
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  CFStringRef theString[2];
  __int128 v103;
  CFIndex v104;
  uint64_t v105;
  CFIndex length;
  uint64_t v107;
  CFRange v108;

  v107 = *MEMORY[0x1E0C80C00];
  theString[0] = 0;
  v103 = 0u;
  v100 = 0u;
  v101 = 0u;
  v98 = 0u;
  v99 = 0u;
  v96 = 0u;
  v97 = 0u;
  *(_OWORD *)buffer = 0u;
  v95 = 0u;
  v104 = a2;
  v105 = 0;
  theString[1] = a1;
  length = 0;
  if (!((unint64_t)a3 | (unint64_t)a4))
    return;
  if (a2 < 2)
    goto LABEL_58;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = a2 - 1;
  v11 = 1 - a2;
  v12 = a2 + 63;
  v13 = &buffer[a2 - 1];
  v14 = 2 - 2 * a2;
  while (1)
  {
    v15 = a2 + v8;
    if (v10 >= 0x3F)
      v16 = 63;
    else
      v16 = v10;
    if (theString[1])
    {
      v17 = *((_WORD *)theString[1] + v15 + *((_QWORD *)&v103 + 1) - 1);
    }
    else if ((_QWORD)v103)
    {
      v17 = *(char *)(v103 + *((_QWORD *)&v103 + 1) + a2 + v8 - 1);
    }
    else
    {
      v18 = v15 - 1;
      v19 = length > v18 && v9 <= v18;
      if (!v19)
      {
        v20 = ~v16;
        v21 = v16 ^ 0x3F;
        v22 = v12 - v16;
        v23 = v16 + v7;
        v24 = a2 + v8 + v20;
        v25 = a2 + v8 + v21;
        if (v25 >= v104)
          v25 = v104;
        v105 = v24;
        length = v25;
        v26.location = v24 + *((_QWORD *)&v103 + 1);
        if (v104 >= v22)
          v27 = v22;
        else
          v27 = v104;
        v26.length = v11 + v23 + v27;
        v28 = v11;
        v29 = v13;
        CFStringGetCharacters(theString[0], v26, buffer);
        v13 = v29;
        v11 = v28;
        v9 = v105;
      }
      v17 = v13[v8 - v9];
    }
    v30 = 0;
    v31 = v17;
    v32 = -1;
    if (v31 > 8233)
    {
      v33 = v31 - 8234;
      v19 = v33 > 0x3F;
      v34 = (1 << v33) & 0xF00000000000001FLL;
      v35 = v19 || v34 == 0;
      v36 = 0;
      v37 = -1;
      if (!v35)
        goto LABEL_61;
      goto LABEL_35;
    }
    if (v31 > 1563)
    {
      if ((v31 - 8206) < 2)
      {
LABEL_37:
        v36 = 0;
        goto LABEL_60;
      }
      v36 = 0;
      v37 = -1;
      if (v31 == 1564)
        goto LABEL_61;
      goto LABEL_35;
    }
    if (v31 == 32)
      goto LABEL_37;
    if (v31 == 46)
      break;
    v36 = 0;
    v37 = -1;
    if (v31 == 47)
      goto LABEL_61;
LABEL_35:
    --v10;
    v14 += 2;
    --v12;
    --v8;
    ++v7;
    if (a2 + v8 <= 1)
    {
      v30 = 0;
      v36 = 0;
LABEL_89:
      v32 = -1;
      goto LABEL_61;
    }
  }
  if (!v8)
  {
    v30 = 0;
    v36 = 0;
    goto LABEL_60;
  }
  v38 = a2 + v8;
  v39 = a2 + v8 - 1;
  if (v39 > 2)
    goto LABEL_66;
  if (theString[1])
  {
    v40 = (UniChar *)theString[1] + *((_QWORD *)&v103 + 1);
  }
  else
  {
    if ((uint64_t)v39 > length || v9 >= 1)
    {
      if (v104 >= 64)
        v41.length = 64;
      else
        v41.length = v104;
      v105 = 0;
      length = v41.length;
      v41.location = *((_QWORD *)&v103 + 1);
      if ((_QWORD)v103)
      {
        if (v41.length)
        {
          v42 = (char *)(v103 + *((_QWORD *)&v103 + 1));
          v43 = buffer;
          do
          {
            v44 = *v42++;
            *v43++ = v44;
            --v41.length;
          }
          while (v41.length);
        }
      }
      else
      {
        v45 = v11;
        CFStringGetCharacters(theString[0], v41, buffer);
        v11 = v45;
      }
    }
    v9 = v105;
    v40 = &buffer[-v105];
  }
  if (*v40 != 46)
    goto LABEL_66;
  v30 = v38 - 2;
  if (v38 == 2)
    goto LABEL_59;
  if (v40[1] != 46)
  {
LABEL_66:
    v37 = a2 + v8;
    v36 = -v8;
    if (!a4)
    {
LABEL_88:
      v30 = 0;
      goto LABEL_89;
    }
    v46 = v38 + 63;
    v47 = v11 - v8;
    while (1)
    {
      if (v39 >= 0x40)
        v48 = 64;
      else
        v48 = v39;
      v49 = v38 - 1;
      if (v38 - 1 < 2)
        goto LABEL_88;
      if (theString[1])
      {
        v50 = (UniChar *)theString[1] + v38 + *((_QWORD *)&v103 + 1);
      }
      else
      {
        if ((_QWORD)v103)
        {
          v51 = *(char *)(v103 + *((_QWORD *)&v103 + 1) + v38 - 2);
          goto LABEL_77;
        }
        if (length < v49 || v9 >= v49)
        {
          v52 = -v48;
          v53 = v48 + v47;
          v54 = v46 - v48;
          v55 = v38 + v52;
          v56 = v55 + 63;
          if (v55 + 63 >= v104)
            v56 = v104;
          v105 = v55 - 1;
          length = v56;
          v57.location = v55 + *((_QWORD *)&v103 + 1) - 1;
          if (v104 >= v54)
            v58 = v54;
          else
            v58 = v104;
          v57.length = v58 + v53;
          CFStringGetCharacters(theString[0], v57, buffer);
          v9 = v105;
        }
        v50 = &buffer[v38 - v9];
      }
      v51 = *(v50 - 2);
LABEL_77:
      v14 += 2;
      ++v47;
      --v46;
      --v39;
      --v38;
      if (v51 != 32)
      {
        v59 = 0;
        v60 = 1 - v49;
        v61 = (char *)buffer - v14;
        v62 = v49 + 63;
        v63 = v49 - 1;
        while (1)
        {
          v64 = (unint64_t)v63 >= 0x3F ? 63 : v63;
          if (theString[1])
          {
            v65 = *((_WORD *)&theString[1]->isa + v63 + *((_QWORD *)&v103 + 1));
          }
          else if ((_QWORD)v103)
          {
            v65 = *(char *)(v103 + *((_QWORD *)&v103 + 1) + v63);
          }
          else
          {
            if (length <= v63 || v9 > v63)
            {
              v67 = -v64;
              v68 = v64 + v60;
              v69 = v62 - v64;
              v70 = v63 + v67;
              v71 = v70 + 64;
              if (v70 + 64 >= v104)
                v71 = v104;
              v105 = v70;
              length = v71;
              v72.location = v70 + *((_QWORD *)&v103 + 1);
              if (v104 >= v69)
                v73 = v69;
              else
                v73 = v104;
              v72.length = v73 + v68;
              CFStringGetCharacters(theString[0], v72, buffer);
              v9 = v105;
            }
            v65 = *(_WORD *)&v61[-2 * v9];
          }
          if (v65 == 32 || v65 == 46)
            break;
          ++v59;
          --v62;
          v61 -= 2;
          ++v60;
          v32 = -1;
          v19 = v63-- <= 1;
          if (v19)
          {
LABEL_135:
            v30 = 0;
            goto LABEL_61;
          }
        }
        v93 = v63 + 1;
        v74 = -v63;
        v75 = v63 + 64;
        while (1)
        {
          v76 = (unint64_t)v63 >= 0x3F ? 63 : v63;
          if (theString[1])
          {
            v77 = *((_WORD *)&theString[1]->isa + v63 + *((_QWORD *)&v103 + 1));
          }
          else if ((_QWORD)v103)
          {
            v77 = *(char *)(v103 + *((_QWORD *)&v103 + 1) + v63);
          }
          else
          {
            if (length <= v63 || v9 > v63)
            {
              v79 = -v76;
              v80 = v76 + v74;
              v81 = v75 - v76;
              v82 = v63 + v79;
              v83 = v82 + 64;
              if (v82 + 64 >= v104)
                v83 = v104;
              v105 = v82;
              length = v83;
              v84.location = v82 + *((_QWORD *)&v103 + 1);
              if (v104 >= v81)
                v85 = v81;
              else
                v85 = v104;
              v84.length = v85 + v80;
              CFStringGetCharacters(theString[0], v84, buffer);
              v9 = v105;
            }
            v77 = *(_WORD *)&v61[-2 * v9];
          }
          if (v77 != 32)
            break;
          --v75;
          v61 -= 2;
          ++v74;
          v32 = -1;
          v19 = v63-- <= 1;
          if (v19)
            goto LABEL_135;
        }
        if (theString[1])
        {
          v86 = *((_WORD *)&theString[1]->isa + *((_QWORD *)&v103 + 1) + v63);
          v87 = v93;
        }
        else
        {
          v87 = v93;
          if ((_QWORD)v103)
          {
            v86 = *(char *)(v103 + *((_QWORD *)&v103 + 1) + v63);
          }
          else
          {
            if (length <= v63 || v9 > v63)
            {
              v88 = 63;
              if ((unint64_t)v63 < 0x3F)
                v88 = v63;
              v89 = v63 - v88 + 64;
              if (v89 >= v104)
                v89 = v104;
              v105 = v63 - v88;
              length = v89;
              v90 = v75 - v88;
              if (v104 < v75 - v88)
                v90 = v104;
              v108.length = v88 + v90 - v63;
              v108.location = v63 - v88 + *((_QWORD *)&v103 + 1);
              CFStringGetCharacters(theString[0], v108, buffer);
              v9 = v105;
            }
            v86 = *(_WORD *)&v61[-2 * v9];
          }
        }
        v91 = v86 == 46;
        v92 = v59 != 0;
        if (v91 && v92)
          v30 = v59;
        else
          v30 = 0;
        if (v91 && v92)
          v32 = v87;
        else
          v32 = -1;
        goto LABEL_61;
      }
    }
  }
LABEL_58:
  v30 = 0;
LABEL_59:
  v36 = 0;
  v32 = -1;
LABEL_60:
  v37 = -1;
LABEL_61:
  if (a3)
  {
    *a3 = v37;
    a3[1] = v36;
  }
  if (a4)
  {
    *a4 = v32;
    a4[1] = v30;
  }
}

void sub_182B5B784(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void __CFUUIDDeallocate(uint64_t a1)
{
  os_unfair_lock_lock_with_options();
  if (_uniquedUUIDs)
    CFDictionaryRemoveValue((CFMutableDictionaryRef)_uniquedUUIDs, (const void *)(a1 + 16));
  os_unfair_lock_unlock((os_unfair_lock_t)&_uniquedUUIDsLock);
}

uint64_t _CFStringGetFileSystemRepresentation(__CFString *a1, _BYTE *a2, uint64_t a3)
{
  if (CFStringGetLength(a1))
    return -[__CFString getFileSystemRepresentation:maxLength:](a1, "getFileSystemRepresentation:maxLength:", a2, a3);
  if (!a3)
    return 0;
  *a2 = 0;
  return 1;
}

uint64_t parseIntegerTag(uint64_t a1, CFNumberRef *a2)
{
  unint64_t v4;
  unint64_t v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  CFErrorRef Error;
  int v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  int v21;
  BOOL v22;
  int v23;
  _BOOL4 v24;
  int v25;
  unsigned __int8 *v26;
  int v27;
  uint64_t result;
  CFNumberRef v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unsigned __int8 *v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  char v37;
  int v38;
  CFErrorRef v39;
  const __CFAllocator *v40;
  CFNumberType v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD valuePtr[3];

  valuePtr[2] = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = *(unsigned __int8 **)(a1 + 8);
    goto LABEL_23;
  }
  v6 = *(unsigned __int8 **)(a1 + 16);
  v7 = (unsigned __int8 *)(v5 + 1);
  v8 = -(uint64_t)v5;
  while (1)
  {
    v9 = *(v7 - 1);
    if (v9 < 0x21 || v9 - 127 < 0x22)
      goto LABEL_19;
    if ((uint64_t)(v4 + v8) < 3 || (v9 & 0xFE) != 0xE2)
      break;
    v10 = *v7;
    v11 = v7[1];
    if (v9 == 226 && v10 == 128)
    {
      if (v11 != 175 && (v11 - 80) > 0x3B)
        break;
    }
    else if (v9 == 226 && v10 == 129)
    {
      if (v11 != 159)
        break;
    }
    else if (v9 != 227 || v10 != 128 || v11 != 128)
    {
      break;
    }
LABEL_19:
    *(_QWORD *)(a1 + 8) = v7++;
    --v8;
    if (!(v4 + v8))
    {
      v5 = v4;
      goto LABEL_23;
    }
  }
  v6 = v7 - 1;
  v5 = -v8;
LABEL_23:
  if (v6 == (unsigned __int8 *)v4)
    goto LABEL_98;
  v12 = *v6;
  if (v12 == 60)
  {
    v43 = lineNumber((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840, CFSTR("Encountered empty <integer> on line %u"), v43);
    goto LABEL_99;
  }
  v14 = v12 == 45;
  if (v12 == 45 || v12 == 43)
  {
    v15 = v6 + 1;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if ((unint64_t)(v6 + 1) >= v4)
    {
LABEL_48:
      v6 = v15;
    }
    else
    {
      v16 = &v6[v4 - v5];
      v17 = v4 - 1 - v5;
      v18 = v4 - 1 - (_QWORD)v6;
      do
      {
        v19 = *v15;
        if (v19 >= 0x21 && v19 - 127 >= 0x22)
        {
          if (v18 < 3 || (v19 & 0xFE) != 0xE2)
            goto LABEL_48;
          v20 = v15[1];
          v21 = v15[2];
          if (v19 == 226 && v20 == 128)
          {
            if (v21 != 175 && (v21 - 80) > 0x3B)
              goto LABEL_48;
          }
          else if (v19 == 226 && v20 == 129)
          {
            if (v21 != 159)
              goto LABEL_48;
          }
          else if (v19 != 227 || v20 != 128 || v21 != 128)
          {
            goto LABEL_48;
          }
        }
        *(_QWORD *)(a1 + 8) = ++v15;
        --v18;
        --v17;
      }
      while (v17);
      v6 = v16;
    }
  }
  else
  {
    v14 = 0;
  }
  if (v6 == (unsigned __int8 *)v4)
    goto LABEL_98;
  if (*v6 == 48)
  {
    if ((unint64_t)(v6 + 1) >= v4)
    {
      v23 = 0;
      v24 = 1;
    }
    else
    {
      v22 = (v6[1] | 0x20) == 120;
      if ((v6[1] | 0x20) == 0x78)
      {
        ++v6;
        v23 = 1;
      }
      else
      {
        v23 = 0;
      }
      v24 = !v22;
    }
    *(_QWORD *)(a1 + 8) = ++v6;
  }
  else
  {
    v23 = 0;
    v24 = 0;
  }
  if (v6 == (unsigned __int8 *)v4)
  {
LABEL_98:
    v45 = lineNumber((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840, CFSTR("Premature end of file after <integer> on line %u"), v45);
    goto LABEL_99;
  }
  v25 = *v6;
  if (v25 == 48)
  {
    v26 = v6 + 1;
    while (1)
    {
      *(_QWORD *)(a1 + 8) = v26;
      if (v26 == (unsigned __int8 *)v4)
        goto LABEL_98;
      v27 = *v26++;
      v25 = v27;
      if (v27 != 48)
      {
        v6 = v26 - 1;
        v24 = 1;
        break;
      }
    }
  }
  if (!v24 || v25 != 60)
  {
    if (v25 != 60)
    {
      v30 = 0;
      v31 = 0x1999999999999999;
      if (v23)
        v31 = 0xFFFFFFFFFFFFFFFLL;
      v32 = 10;
      if (v23)
        v32 = 16;
      v33 = v6 + 1;
      do
      {
        v34 = (char)v25;
        v35 = v34 - 48;
        if ((v34 - 48) > 0x36)
        {
LABEL_114:
          v49 = lineNumber((unint64_t *)a1);
          Error = __CFPropertyListCreateError(3840, CFSTR("Unknown character '%c' (0x%x) in <integer> on line %u"), v34, v34, v49);
          goto LABEL_99;
        }
        if (((1 << v35) & 0x3FF) == 0)
        {
          if (((1 << v35) & 0x7E0000) != 0)
          {
            v36 = -55;
          }
          else
          {
            if (((1 << v35) & 0x7E000000000000) == 0)
              goto LABEL_114;
            v36 = -87;
          }
          if ((v23 & 1) == 0)
          {
            v48 = lineNumber((unint64_t *)a1);
            Error = __CFPropertyListCreateError(3840, CFSTR("Hex digit in non-hex <integer> on line %u"), v48);
            goto LABEL_99;
          }
          v35 = v36 + v34;
        }
        if (v31 < v30 || __CFADD__(v30 * v32, v35))
        {
          v46 = lineNumber((unint64_t *)a1);
          Error = __CFPropertyListCreateError(3840, CFSTR("Integer overflow in <integer> on line %u"), v46);
          goto LABEL_99;
        }
        v30 = v30 * v32 + v35;
        v37 = v14 ^ 1;
        if ((unint64_t)v30 < 0x8000000000000001)
          v37 = 1;
        if ((v37 & 1) == 0)
        {
          v47 = lineNumber((unint64_t *)a1);
          Error = __CFPropertyListCreateError(3840, CFSTR("Integer underflow in <integer> on line %u"), v47);
          goto LABEL_99;
        }
        *(_QWORD *)(a1 + 8) = v33;
        if (v33 == (unsigned __int8 *)v4)
          goto LABEL_98;
        v38 = *v33++;
        LOBYTE(v25) = v38;
      }
      while (v38 != 60);
      result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"integer", 7uLL);
      if (!(_DWORD)result)
        return result;
      if (*(_BYTE *)(a1 + 80))
      {
        *a2 = 0;
        return 1;
      }
      if (((v30 < 0) & ~v14) != 0)
      {
        valuePtr[0] = 0;
        valuePtr[1] = v30;
        v40 = *(const __CFAllocator **)(a1 + 32);
        v41 = kCFNumberMaxType|kCFNumberSInt8Type;
      }
      else
      {
        if (v14)
          v42 = -v30;
        else
          v42 = v30;
        valuePtr[0] = v42;
        v40 = *(const __CFAllocator **)(a1 + 32);
        v41 = kCFNumberSInt64Type;
      }
      goto LABEL_102;
    }
    v44 = lineNumber((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840, CFSTR("Incomplete <integer> on line %u"), v44);
LABEL_99:
    v39 = Error;
    result = 0;
    *(_QWORD *)(a1 + 24) = v39;
    return result;
  }
  LODWORD(valuePtr[0]) = 0;
  result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"integer", 7uLL);
  if (!(_DWORD)result)
    return result;
  if (!*(_BYTE *)(a1 + 80))
  {
    v40 = *(const __CFAllocator **)(a1 + 32);
    v41 = kCFNumberSInt32Type;
LABEL_102:
    v29 = CFNumberCreate(v40, v41, valuePtr);
    goto LABEL_103;
  }
  v29 = 0;
LABEL_103:
  *a2 = v29;
  return 1;
}

Boolean CFMessagePortIsValid(CFMessagePortRef ms)
{
  unint64_t v2;
  char v3;
  Boolean v4;
  __CFMachPort *v5;
  __CFMachPort *v6;

  v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35)
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  v3 = atomic_load((unint64_t *)ms + 1);
  if ((v3 & 1) == 0)
    return 0;
  CFRetain(ms);
  v5 = (__CFMachPort *)*((_QWORD *)ms + 3);
  if (v5 && !CFMachPortIsValid(v5) || (v6 = (__CFMachPort *)*((_QWORD *)ms + 6)) != 0 && !CFMachPortIsValid(v6))
  {
    CFMessagePortInvalidate(ms);
    v4 = 0;
  }
  else
  {
    v4 = 1;
  }
  CFRelease(ms);
  return v4;
}

void __CFTSDFinalize(unint64_t a1)
{
  unint64_t StatusReg;
  void *v3;
  uint64_t i;
  _DWORD *v5;
  void (*v6)(void);

  if (pthread_main_np() == 1)
    atomic_store(1u, __CFMainThreadHasExited);
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  *(_QWORD *)(StatusReg + 440) = a1;
  if ((a1 | 0x1000) != 0x1000)
  {
    ++*(_DWORD *)a1;
    v3 = (void *)_CFAutoreleasePoolPush();
    for (i = 0; i != 560; i += 8)
    {
      v5 = (_DWORD *)(a1 + i);
      if (*(_QWORD *)(a1 + i + 8))
      {
        v6 = (void (*)(void))*((_QWORD *)v5 + 71);
        if (v6)
        {
          *((_QWORD *)v5 + 1) = 0;
          v6();
        }
      }
    }
    _CFAutoreleasePoolPop(v3);
    if (*(_DWORD *)a1 == 3)
    {
      free((void *)a1);
      *(_QWORD *)(StatusReg + 440) = 4096;
    }
  }
}

void __CFFinalizeRunLoop(unint64_t a1)
{
  const __CFDictionary *v1;
  pthread_t v2;
  const void *Value;
  uint64_t v4;
  __CFDictionary *v5;
  pthread_t v6;
  _opaque_pthread_t *v7;
  const void *v8;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  __CFString *ValueAtIndex;
  __CFDictionary *v13;
  pthread_t v14;

  if (a1 > 1)
  {
    _CFSetTSD(0xBu, a1 - 1, (uint64_t)__CFFinalizeRunLoop);
    return;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  v1 = (const __CFDictionary *)__CFRunLoops;
  if (!__CFRunLoops)
    goto LABEL_14;
  v2 = pthread_self();
  Value = CFDictionaryGetValue(v1, v2);
  if (!Value)
  {
    v13 = (__CFDictionary *)__CFRunLoops;
    v14 = pthread_self();
    CFDictionaryRemoveValue(v13, v14);
LABEL_14:
    os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
    return;
  }
  v4 = (uint64_t)Value;
  CFRetain(Value);
  v5 = (__CFDictionary *)__CFRunLoops;
  v6 = pthread_self();
  CFDictionaryRemoveValue(v5, v6);
  os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  v7 = (_opaque_pthread_t *)pthread_main_thread_np();
  if (_CFRunLoopGet0b(v7) != (const void *)v4)
  {
    v8 = *(const void **)(v4 + 672);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(v4 + 672) = 0;
    }
    v9 = CFRunLoopCopyAllModes((CFRunLoopRef)v4);
    Count = CFArrayGetCount(v9);
    if (Count)
    {
      v11 = Count - 1;
      do
      {
        ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(v9, v11);
        __CFRunLoopRemoveAllSources(v4, ValueAtIndex);
        --v11;
      }
      while (v11 != -1);
    }
    __CFRunLoopRemoveAllSources(v4, CFSTR("kCFRunLoopCommonModes"));
    CFRelease(v9);
  }
  atomic_store(1u, (unsigned __int8 *)(v4 + 680));
  CFRelease((CFTypeRef)v4);
}

uint64_t __CFRunLoopObserverDeallocate(uint64_t a1)
{
  CFRunLoopObserverInvalidate((CFRunLoopObserverRef)a1);
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
}

void CFRunLoopObserverInvalidate(CFRunLoopObserverRef observer)
{
  unint64_t v2;
  unint64_t *v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  const __CFString *ValueAtIndex;
  void (*v14)(uint64_t);

  v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45)
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  pthread_mutex_lock((pthread_mutex_t *)((char *)observer + 16));
  CFRetain(observer);
  v3 = (unint64_t *)((char *)observer + 8);
  v4 = atomic_load((unint64_t *)observer + 1);
  if ((v4 & 8) != 0)
  {
    v5 = *((_QWORD *)observer + 10);
    v6 = *((_QWORD *)observer + 16);
    *((_QWORD *)observer + 16) = 0;
    v7 = atomic_load(v3);
    while (1)
    {
      v8 = __ldaxr(v3);
      if (v8 != v7)
        break;
      if (__stlxr(v7 & 0xFFFFFFFFFFFFFFF7, v3))
        goto LABEL_12;
      v9 = 1;
LABEL_13:
      v7 = v8;
      if (v9)
      {
        if (v5)
        {
          CFRetain((CFTypeRef)v5);
          pthread_mutex_unlock((pthread_mutex_t *)((char *)observer + 16));
          pthread_mutex_lock((pthread_mutex_t *)(v5 + 16));
          v10 = CFRunLoopCopyAllModes((CFRunLoopRef)v5);
          Count = CFArrayGetCount(v10);
          if (Count)
          {
            v12 = Count - 1;
            do
            {
              ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v12);
              CFRunLoopRemoveObserver((CFRunLoopRef)v5, observer, ValueAtIndex);
              --v12;
            }
            while (v12 != -1);
          }
          CFRunLoopRemoveObserver((CFRunLoopRef)v5, observer, CFSTR("kCFRunLoopCommonModes"));
          pthread_mutex_unlock((pthread_mutex_t *)(v5 + 16));
          CFRelease(v10);
          CFRelease((CFTypeRef)v5);
          pthread_mutex_lock((pthread_mutex_t *)((char *)observer + 16));
        }
        v14 = (void (*)(uint64_t))*((_QWORD *)observer + 18);
        if (v14)
          v14(v6);
        goto LABEL_21;
      }
    }
    __clrex();
LABEL_12:
    v9 = 0;
    goto LABEL_13;
  }
LABEL_21:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)observer + 16));
  CFRelease(observer);
}

void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  unint64_t v6;
  pthread_mutex_t *v7;
  uint64_t v8;
  const __CFArray **v9;
  pthread_mutex_t *v10;
  const __CFArray *v11;
  CFIndex FirstIndexOfValue;
  const __CFSet *v13;
  const __CFSet *v14;
  const __CFSet *v15;
  const __CFSet *Copy;
  _QWORD context[3];
  CFRange v18;

  context[2] = *MEMORY[0x1E0C80C00];
  v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v7 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == CFSTR("kCFRunLoopCommonModes"))
  {
    v14 = (const __CFSet *)*((_QWORD *)rl + 77);
    if (v14 && CFSetContainsValue(v14, observer))
    {
      v15 = (const __CFSet *)*((_QWORD *)rl + 76);
      if (!v15)
      {
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), observer);
        goto LABEL_20;
      }
      Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15);
      CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), observer);
      if (Copy)
      {
        context[0] = rl;
        context[1] = observer;
        CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveItemFromCommonModes, context);
        v13 = Copy;
LABEL_13:
        CFRelease(v13);
      }
    }
  }
  else
  {
    v8 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
    if (v8)
    {
      v9 = (const __CFArray **)v8;
      v10 = (pthread_mutex_t *)(v8 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v8 + 16));
      if (v9[14])
      {
        CFRetain(observer);
        v11 = v9[14];
        v18.length = CFArrayGetCount(v11);
        v18.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v11, v18, observer);
        if (FirstIndexOfValue != -1)
        {
          CFArrayRemoveValueAtIndex(v9[14], FirstIndexOfValue);
          __CFRunLoopObserverCancel((uint64_t)observer);
        }
        CFRelease(observer);
      }
      pthread_mutex_unlock(v10);
      v13 = (const __CFSet *)v9;
      goto LABEL_13;
    }
  }
LABEL_20:
  pthread_mutex_unlock(v7);
}

uint64_t __CFRunLoopObserverCancel(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;

  v2 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v3 = *(_QWORD *)(a1 + 88) - 1;
  *(_QWORD *)(a1 + 88) = v3;
  if (!v3)
    *(_QWORD *)(a1 + 80) = 0;
  return pthread_mutex_unlock(v2);
}

void __CFRunLoopSourceRemoveFromRunLoop(uint64_t a1, uint64_t a2)
{
  __CFRunLoopSource *v4;
  pthread_mutex_t *v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  const __CFString *ValueAtIndex;

  if (*(_QWORD *)(a2 + 8) != a1)
  {
    v4 = *(__CFRunLoopSource **)a2;
    v5 = (pthread_mutex_t *)(a1 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    v6 = CFRunLoopCopyAllModes((CFRunLoopRef)a1);
    Count = CFArrayGetCount(v6);
    if (Count)
    {
      v8 = Count - 1;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, v8);
        CFRunLoopRemoveSource((CFRunLoopRef)a1, v4, ValueAtIndex);
        --v8;
      }
      while (v8 != -1);
    }
    CFRunLoopRemoveSource((CFRunLoopRef)a1, v4, CFSTR("kCFRunLoopCommonModes"));
    pthread_mutex_unlock(v5);
    CFRelease(v6);
    *(_QWORD *)(a2 + 8) = a1;
  }
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  pthread_mutex_t *v9;
  const __CFSet *v10;
  const __CFSet *v11;
  mach_port_name_t v12;
  mach_port_name_t v13;
  __CFBag *v14;
  char v15;
  BOOL v16;
  const __CFSet *v17;
  const __CFSet *v18;
  const __CFSet *Copy;
  _QWORD context[3];

  context[2] = *MEMORY[0x1E0C80C00];
  v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == CFSTR("kCFRunLoopCommonModes"))
  {
    v17 = (const __CFSet *)*((_QWORD *)rl + 77);
    if (v17 && CFSetContainsValue(v17, source))
    {
      v18 = (const __CFSet *)*((_QWORD *)rl + 76);
      if (v18)
      {
        Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v18);
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), source);
        if (Copy)
        {
          context[0] = rl;
          context[1] = source;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveItemFromCommonModes, context);
          CFRelease(Copy);
        }
      }
      else
      {
        CFSetRemoveValue(*((CFMutableSetRef *)rl + 77), source);
      }
    }
    goto LABEL_31;
  }
  v7 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (!v7)
  {
LABEL_31:
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
    return;
  }
  v8 = v7;
  v9 = (pthread_mutex_t *)(v7 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 16));
  v10 = *(const __CFSet **)(v8 + 96);
  if (v10 && CFSetContainsValue(v10, source)
    || (v11 = *(const __CFSet **)(v8 + 104)) != 0 && CFSetContainsValue(v11, source))
  {
    CFRetain(source);
    if (*((_QWORD *)source + 13) == 1)
    {
      v12 = (*((uint64_t (**)(_QWORD))source + 20))(*((_QWORD *)source + 14));
      if (v12)
      {
        v13 = v12;
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v8 + 128), (const void *)v12);
        mach_port_extract_member(*MEMORY[0x1E0C83DA0], v13, *(_DWORD *)(v8 + 136));
      }
    }
    CFSetRemoveValue(*(CFMutableSetRef *)(v8 + 96), source);
    CFSetRemoveValue(*(CFMutableSetRef *)(v8 + 104), source);
    pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
    v14 = (__CFBag *)*((_QWORD *)source + 12);
    if (v14)
      CFBagRemoveValue(v14, rl);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
    v15 = 0;
    if (*((_QWORD *)source + 13))
      v16 = 1;
    else
      v16 = *((_QWORD *)source + 21) == 0;
  }
  else
  {
    v16 = 1;
    v15 = 1;
  }
  pthread_mutex_unlock(v9);
  CFRelease((CFTypeRef)v8);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  if (!v16)
    (*((void (**)(_QWORD, CFRunLoopRef, CFRunLoopMode))source + 21))(*((_QWORD *)source + 14), rl, mode);
  if ((v15 & 1) == 0)
    CFRelease(source);
}

CFArrayRef CFRunLoopCopyAllModes(CFRunLoopRef rl)
{
  unint64_t v2;
  CFIndex Count;
  CFMutableArrayRef Mutable;

  v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  Count = CFSetGetCount(*((CFSetRef *)rl + 79));
  Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeArrayCallBacks);
  CFSetApplyFunction(*((CFSetRef *)rl + 79), (CFSetApplierFunction)__CFRunLoopGetModeName, Mutable);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  return Mutable;
}

void _CFStreamScheduleWithRunLoop(char *cf, void *a2, const __CFString *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFRunLoopSourceRef v9;
  CFArrayRef v10;
  const __CFDictionary *Mutable;
  const __CFArray *Value;
  CFMutableArrayRef v13;
  char *ValueAtIndex;
  char *v15;
  pthread_mutex_t *v16;
  uint64_t v17;
  const void *v18;
  uint64_t v19;
  const void *v20;
  const __CFAllocator *v21;
  const void *v22;
  CFTypeRef v23;
  const __CFArray *v24;
  CFIndex Count;
  CFIndex FirstIndexOfValue;
  uint64_t v27;
  __CFRunLoopSource *v28;
  __CFRunLoop *v29;
  const __CFString *v30;
  CFRunLoopSourceRef v31;
  uint64_t v32;
  const void *v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  const void *v37;
  __CFRunLoop *v38;
  const __CFString *v39;
  __CFArray *v40;
  const __CFAllocator *v41;
  void (*v42)(char *, void *, const __CFString *, _QWORD);
  uint64_t v43;
  uint64_t v44;
  __CFRunLoopSource *v45;
  CFRunLoopSourceContext v46;
  void *values[3];
  CFRange v48;

  values[2] = *(void **)MEMORY[0x1E0C80C00];
  v6 = *((_QWORD *)cf + 6);
  v7 = *((_QWORD *)cf + 4);
  if (!v7)
  {
    _initializeClient(cf);
    v7 = *((_QWORD *)cf + 4);
    if (!v7)
      return;
  }
  if (!*(_QWORD *)(v7 + 56))
  {
    values[0] = a2;
    values[1] = (void *)a3;
    v10 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 2, &kCFTypeArrayCallBacks);
    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    Mutable = (const __CFDictionary *)sSharedSources;
    if (!sSharedSources)
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      sSharedSources = (uint64_t)Mutable;
    }
    Value = (const __CFArray *)CFDictionaryGetValue(Mutable, v10);
    if (!Value)
    {
      *(_OWORD *)&v46.copyDescription = xmmword_1E12E6C18;
      *(_OWORD *)&v46.hash = unk_1E12E6C28;
      *(_OWORD *)&v46.cancel = xmmword_1E12E6C38;
      v46.version = 0;
      *(_OWORD *)&v46.retain = *(_OWORD *)&off_1E12E6C08;
      v13 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
      CFDictionaryAddValue((CFMutableDictionaryRef)sSharedSources, v10, v13);
      v46.info = v13;
      v31 = CFRunLoopSourceCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &v46);
      pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
      v32 = *((_QWORD *)cf + 4);
      if (v32)
      {
        v33 = *(const void **)(v32 + 56);
        if (v33)
        {
          CFRetain(*(CFTypeRef *)(v32 + 56));
          v32 = *((_QWORD *)cf + 4);
        }
        *(_QWORD *)(v32 + 56) = v31;
        if (v31)
          CFRetain(v31);
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
        if (v33)
        {
          CFRelease(v33);
          CFRelease(v33);
        }
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      }
      CFRunLoopAddSource((CFRunLoopRef)a2, v31, a3);
      CFRelease(v31);
      goto LABEL_57;
    }
    v13 = Value;
    ValueAtIndex = (char *)CFArrayGetValueAtIndex(Value, 0);
    if (ValueAtIndex)
    {
      v15 = ValueAtIndex;
      v16 = (pthread_mutex_t *)(ValueAtIndex + 56);
      pthread_mutex_lock((pthread_mutex_t *)(ValueAtIndex + 56));
      v17 = *((_QWORD *)v15 + 4);
      if (v17)
      {
        v18 = *(const void **)(v17 + 56);
        if (v18)
        {
          CFRetain(*(CFTypeRef *)(v17 + 56));
          pthread_mutex_unlock(v16);
          pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
          v19 = *((_QWORD *)cf + 4);
          if (v19)
          {
            v20 = *(const void **)(v19 + 56);
            if (v20)
            {
              CFRetain(*(CFTypeRef *)(v19 + 56));
              *(_QWORD *)(*((_QWORD *)cf + 4) + 56) = v18;
              CFRetain(v18);
              pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
              CFRelease(v20);
              CFRelease(v20);
LABEL_55:
              CFRelease(v18);
              goto LABEL_56;
            }
            *(_QWORD *)(v19 + 56) = v18;
            CFRetain(v18);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
          goto LABEL_55;
        }
      }
      pthread_mutex_unlock(v16);
    }
LABEL_56:
    CFRetain(v13);
LABEL_57:
    CFArrayAppendValue(v13, cf);
    CFDictionaryAddValue((CFMutableDictionaryRef)sSharedSources, cf, v10);
    CFRelease(v10);
    CFRelease(v13);
    *((_QWORD *)cf + 2) |= 0x100uLL;
    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
    goto LABEL_58;
  }
  if ((cf[17] & 1) != 0)
  {
    v21 = CFGetAllocator(cf);
    v46.version = 0;
    v46.info = cf;
    *(_OWORD *)&v46.retain = 0uLL;
    v46.copyDescription = CFCopyDescription;
    memset(&v46.equal, 0, 32);
    v46.perform = (void (__cdecl *)(void *))_cfstream_solo_signalEventSync;
    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    v22 = CFDictionaryGetValue((CFDictionaryRef)sSharedSources, cf);
    v23 = CFRetain(v22);
    v24 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)sSharedSources, v23);
    Count = CFArrayGetCount(v24);
    v48.location = 0;
    v48.length = Count;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v24, v48, cf);
    if (FirstIndexOfValue != -1)
    {
      CFArrayRemoveValueAtIndex(v24, FirstIndexOfValue);
      --Count;
    }
    if (!Count)
    {
      pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
      v27 = *((_QWORD *)cf + 4);
      if (v27 && (v28 = *(__CFRunLoopSource **)(v27 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v27 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
        v29 = (__CFRunLoop *)CFArrayGetValueAtIndex((CFArrayRef)v23, 0);
        v30 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v23, 1);
        CFRunLoopRemoveSource(v29, v28, v30);
        CFRelease(v28);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, v23);
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, cf);
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    v34 = *((_QWORD *)cf + 4);
    if (v34)
    {
      v35 = *(void **)(v34 + 56);
      if (v35)
      {
        CFRetain(*(CFTypeRef *)(v34 + 56));
        *(_QWORD *)(*((_QWORD *)cf + 4) + 56) = 0;
        pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
        CFRelease(v35);
        if (!Count)
          CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v35);
        CFRelease(v35);
        goto LABEL_41;
      }
      *(_QWORD *)(v34 + 56) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
LABEL_41:
    *((_QWORD *)cf + 2) &= ~0x100uLL;
    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
    v9 = CFRunLoopSourceCreate(v21, 0, &v46);
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    v36 = *((_QWORD *)cf + 4);
    if (v36)
    {
      v37 = *(const void **)(v36 + 56);
      if (v37)
      {
        CFRetain(*(CFTypeRef *)(v36 + 56));
        v36 = *((_QWORD *)cf + 4);
      }
      *(_QWORD *)(v36 + 56) = v9;
      if (v9)
        CFRetain(v9);
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      if (v37)
      {
        CFRelease(v37);
        CFRelease(v37);
      }
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
    }
    v38 = (__CFRunLoop *)CFArrayGetValueAtIndex((CFArrayRef)v23, 0);
    v39 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v23, 1);
    CFRunLoopAddSource(v38, v9, v39);
    CFRelease(v23);
    goto LABEL_50;
  }
  pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
  v8 = *((_QWORD *)cf + 4);
  if (v8)
  {
    v9 = *(CFRunLoopSourceRef *)(v8 + 56);
    if (v9)
    {
      CFRetain(*(CFTypeRef *)(v8 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
LABEL_50:
      CFRunLoopAddSource((CFRunLoopRef)a2, v9, a3);
      CFRelease(v9);
      goto LABEL_58;
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
LABEL_58:
  pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
  v40 = *(__CFArray **)(*((_QWORD *)cf + 4) + 64);
  if (!v40)
  {
    v41 = CFGetAllocator(cf);
    v40 = CFArrayCreateMutable(v41, 0, &kCFTypeArrayCallBacks);
    *(_QWORD *)(*((_QWORD *)cf + 4) + 64) = v40;
  }
  CFArrayAppendValue(v40, a2);
  CFArrayAppendValue(*(CFMutableArrayRef *)(*((_QWORD *)cf + 4) + 64), a3);
  pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
  if (v6)
  {
    v42 = *(void (**)(char *, void *, const __CFString *, _QWORD))(v6 + 120);
    if (v42)
    {
      *((_QWORD *)cf + 2) |= 0x40uLL;
      v42(cf, a2, a3, *((_QWORD *)cf + 5));
      *((_QWORD *)cf + 2) &= ~0x40uLL;
    }
  }
  v43 = *((_QWORD *)cf + 4);
  if (v43 && *(_QWORD *)(v43 + 72))
  {
    pthread_mutex_lock((pthread_mutex_t *)(cf + 56));
    v44 = *((_QWORD *)cf + 4);
    if (v44 && (v45 = *(__CFRunLoopSource **)(v44 + 56)) != 0)
    {
      CFRetain(*(CFTypeRef *)(v44 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
      CFRunLoopSourceSignal(v45);
      CFRelease(v45);
      _wakeUpRunLoop((uint64_t)cf);
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(cf + 56));
    }
  }
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  char v6;
  unsigned __int8 v7;
  unint64_t v8;
  mach_port_name_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  pthread_mutex_t *v20;
  const __CFSet *v21;
  uint64_t v22;
  const __CFSet *v23;
  const __CFSet *Copy;
  __CFSet *Mutable;
  const __CFSet *v26;
  mach_port_name_t v27;
  mach_port_name_t v28;
  __CFBag *v29;
  uint64_t v30;
  _QWORD v31[7];
  mach_port_type_t ptype[2];
  CFRunLoopSourceRef v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v6 = atomic_load((unint64_t *)rl + 1);
  if ((v6 & 4) == 0)
  {
    v7 = atomic_load(__CFMainThreadHasExited);
    if ((v7 & 1) != 0 && CFRunLoopGetMain() == rl)
    {
      if (CFRunLoopAddSource_onceToken != -1)
        dispatch_once(&CFRunLoopAddSource_onceToken, &__block_literal_global_12_0);
      _CFRunLoopError_MainThreadHasExited();
    }
    else
    {
      v8 = _CFGetNonObjCTypeID((unint64_t *)rl);
      if (v8 != 43)
        _CFAssertMismatchedTypeID(0x2BuLL, v8);
      if (*((_QWORD *)source + 13) == 1)
      {
        v9 = (*((uint64_t (**)(_QWORD))source + 20))(*((_QWORD *)source + 14));
        ptype[0] = 0;
        v10 = mach_port_type(*MEMORY[0x1E0C83DA0], v9, ptype);
        if (!(_DWORD)v10 && (ptype[0] & 0x20000) == 0)
        {
          v31[0] = MEMORY[0x1E0C809B0];
          v31[1] = 3221225472;
          v31[2] = __CFRunLoopAddSource_block_invoke_2;
          v31[3] = &__block_descriptor_56_e5_v8__0l;
          v31[4] = source;
          v31[5] = rl;
          v31[6] = mode;
          if (CFRunLoopAddSource_onceToken_15 != -1)
            dispatch_once(&CFRunLoopAddSource_onceToken_15, v31);
          __CFRunLoopError_AddingSourceLackingReceiveRight(v10, v11, v12, v13, v14, v15, v16);
        }
      }
      v17 = atomic_load((unint64_t *)source + 1);
      if ((v17 & 8) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
        if (mode == CFSTR("kCFRunLoopCommonModes"))
        {
          v23 = (const __CFSet *)*((_QWORD *)rl + 76);
          if (v23)
            Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v23);
          else
            Copy = 0;
          Mutable = (__CFSet *)*((_QWORD *)rl + 77);
          if (!Mutable)
          {
            Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
            *((_QWORD *)rl + 77) = Mutable;
          }
          CFSetAddValue(Mutable, source);
          if (!Copy)
            goto LABEL_42;
          *(_QWORD *)ptype = rl;
          v33 = source;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemToCommonModes, ptype);
          v26 = Copy;
          goto LABEL_41;
        }
        v18 = __CFRunLoopCopyMode((uint64_t)rl, mode, 1);
        if (!v18)
        {
LABEL_42:
          pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
          return;
        }
        v19 = v18;
        v20 = (pthread_mutex_t *)(v18 + 16);
        pthread_mutex_lock((pthread_mutex_t *)(v18 + 16));
        v21 = *(const __CFSet **)(v19 + 96);
        if (!v21)
        {
          *(_QWORD *)(v19 + 96) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
          *(_QWORD *)(v19 + 104) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
          *(_QWORD *)(v19 + 128) = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0);
          v21 = *(const __CFSet **)(v19 + 96);
        }
        if (CFSetContainsValue(v21, source) || CFSetContainsValue(*(CFSetRef *)(v19 + 104), source))
          goto LABEL_40;
        v22 = *((_QWORD *)source + 13);
        if (v22 == 1)
        {
          CFSetAddValue(*(CFMutableSetRef *)(v19 + 104), source);
          v27 = (*((uint64_t (**)(_QWORD))source + 20))(*((_QWORD *)source + 14));
          if (v27)
          {
            v28 = v27;
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v19 + 128), (const void *)v27, source);
            mach_port_insert_member(*MEMORY[0x1E0C83DA0], v28, *(_DWORD *)(v19 + 136));
          }
        }
        else if (!v22)
        {
          CFSetAddValue(*(CFMutableSetRef *)(v19 + 96), source);
        }
        pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
        v29 = (__CFBag *)*((_QWORD *)source + 12);
        if (!v29)
        {
          v29 = CFBagCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeBagCallBacks);
          *((_QWORD *)source + 12) = v29;
        }
        CFBagAddValue(v29, rl);
        pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
        if (*((_QWORD *)source + 13))
        {
LABEL_40:
          pthread_mutex_unlock(v20);
          v26 = (const __CFSet *)v19;
LABEL_41:
          CFRelease(v26);
          goto LABEL_42;
        }
        v30 = *((_QWORD *)source + 20);
        pthread_mutex_unlock(v20);
        CFRelease((CFTypeRef)v19);
        pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
        if (v30)
          (*((void (**)(_QWORD, CFRunLoopRef, CFRunLoopMode))source + 20))(*((_QWORD *)source + 14), rl, mode);
      }
    }
  }
}

CFMutableBagRef CFBagCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFBagCallBacks *callBacks)
{
  objc_class **Generic;
  __CFBag *v4;

  Generic = (objc_class **)__CFBagCreateGeneric((__objc2_class **)allocator, (uint64_t)callBacks);
  v4 = (__CFBag *)Generic;
  if (Generic)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Generic, 4uLL);
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
  }
  return v4;
}

uint64_t __CFBagCreateGeneric(__objc2_class **a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  __int128 v4;
  uint64_t v5;
  uint64_t v7[5];
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v2 = *(_QWORD *)(a2 + 8);
    v3 = *(_QWORD *)(a2 + 16);
    v4 = *(_OWORD *)(a2 + 32);
    v5 = *(_QWORD *)(a2 + 24);
  }
  else
  {
    v2 = 0;
    v3 = 0;
    v5 = 0;
    v4 = 0uLL;
  }
  v8 = v4;
  v10 = v5;
  v11 = v5;
  v7[0] = v2;
  v7[1] = v2;
  v7[2] = v3;
  v7[3] = v3;
  v7[4] = v4;
  v9 = 0;
  return CFBasicHashCreate(a1, 0x2002u, v7);
}

uint64_t __CFMachPortGetPort(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

void readDataSchedule(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const UInt8 *BytePtr;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;

  if (!*(_BYTE *)(a4 + 16))
  {
    *(_BYTE *)(a4 + 16) = 1;
    if (CFReadStreamGetStatus((CFReadStreamRef)a1) == kCFStreamStatusOpen)
    {
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)a4);
      if ((unint64_t)&BytePtr[CFDataGetLength(*(CFDataRef *)a4)] <= *(_QWORD *)(a4 + 8))
        v12 = 16;
      else
        v12 = 2;
      CFReadStreamSignalEvent(a1, v12, 0, v7, v8, v9, v10, v11);
    }
  }
}

CFStreamStatus CFReadStreamGetStatus(CFReadStreamRef stream)
{
  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
    return -[__CFReadStream streamStatus](stream, "streamStatus");
  else
    return _CFStreamGetStatus((uint64_t)stream);
}

uint64_t __CFRunLoopRemoveAllSources(uint64_t a1, __CFString *a2)
{
  uint64_t v4;
  const __CFSet **v5;
  pthread_mutex_t *v6;
  const __CFSet *v7;
  const __CFSet *v8;
  const __CFSet *v9;
  const __CFSet *v10;
  const void *v11;
  const __CFSet *v12;
  const __CFSet *Copy;
  const __CFSet *v14;
  uint64_t context;
  __CFString *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if (a2 == CFSTR("kCFRunLoopCommonModes"))
  {
    if (*(_QWORD *)(a1 + 616))
    {
      v12 = *(const __CFSet **)(a1 + 608);
      if (v12)
      {
        Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
        if (Copy)
        {
          v14 = Copy;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopRemoveSourcesFromCommonMode, (void *)a1);
          v11 = v14;
LABEL_12:
          CFRelease(v11);
        }
      }
    }
  }
  else
  {
    v4 = __CFRunLoopCopyMode(a1, a2, 0);
    if (v4)
    {
      v5 = (const __CFSet **)v4;
      v6 = (pthread_mutex_t *)(v4 + 16);
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
      v7 = v5[12];
      if (v7)
      {
        v8 = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
        context = a1;
        v17 = a2;
        CFSetApplyFunction(v8, (CFSetApplierFunction)__CFRunLoopRemoveSourceFromMode, &context);
        CFRelease(v8);
      }
      v9 = v5[13];
      if (v9)
      {
        v10 = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9);
        context = a1;
        v17 = a2;
        CFSetApplyFunction(v10, (CFSetApplierFunction)__CFRunLoopRemoveSourceFromMode, &context);
        CFRelease(v10);
      }
      pthread_mutex_unlock(v6);
      v11 = v5;
      goto LABEL_12;
    }
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
}

unint64_t *__CFMessagePortCreateRemote(__objc2_class **a1, const __CFString *a2, int a3, int a4)
{
  CFStringRef SanitizedStringName;
  CFStringRef v8;
  uint64_t Instance;
  unint64_t *v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  CFMachPortRef v21;
  int IsValid;
  CFMachPortRef v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  __CFDictionary *Mutable;
  void *value;
  mach_port_t special_port[2];
  void *ptr;
  CFMachPortContext context;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  memset(&context, 0, sizeof(context));
  *(_QWORD *)special_port = 0;
  ptr = 0;
  SanitizedStringName = __CFMessagePortCreateSanitizedStringName(a2, (UInt8 **)&ptr);
  if (!SanitizedStringName)
    return 0;
  v8 = SanitizedStringName;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (!a3)
  {
    value = 0;
    if (__CFAllRemoteMessagePorts)
    {
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllRemoteMessagePorts, v8, (const void **)&value))
      {
        CFRetain(value);
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
        CFRelease(v8);
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
        IsValid = CFMessagePortIsValid((CFMessagePortRef)value);
        v10 = (unint64_t *)value;
        if (IsValid)
          return v10;
LABEL_29:
        v21 = (CFMachPortRef)v10;
        goto LABEL_30;
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  Instance = _CFRuntimeCreateInstance(a1, 0x23uLL, 104, 0);
  v10 = (unint64_t *)Instance;
  if (!Instance)
  {
    CFRelease(v8);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    return v10;
  }
  v11 = (unint64_t *)(Instance + 8);
  v12 = atomic_load((unint64_t *)(Instance + 8));
  do
  {
    v13 = __ldaxr(v11);
    if (v13 == v12)
    {
      if (!__stlxr(v12 & 0xFFFFFFFFFFFFFFFELL, v11))
      {
        v14 = 1;
        goto LABEL_10;
      }
    }
    else
    {
      __clrex();
    }
    v14 = 0;
LABEL_10:
    v12 = v13;
  }
  while (!v14);
  v15 = atomic_load(v11);
  do
  {
    v16 = __ldaxr(v11);
    if (v16 == v15)
    {
      if (!__stlxr(v15 & 0xFFFFFFFFFFFFFFFDLL, v11))
      {
        v17 = 1;
        goto LABEL_17;
      }
    }
    else
    {
      __clrex();
    }
    v17 = 0;
LABEL_17:
    v15 = v16;
  }
  while (!v17);
  v18 = atomic_load(v11);
  do
  {
    v19 = __ldaxr(v11);
    if (v19 == v18)
    {
      if (!__stlxr(v18 | 4, v11))
      {
        v20 = 1;
        goto LABEL_24;
      }
    }
    else
    {
      __clrex();
    }
    v20 = 0;
LABEL_24:
    v18 = v19;
  }
  while (!v20);
  *(_DWORD *)(Instance + 112) = 0;
  *(_QWORD *)(Instance + 16) = v8;
  *(_QWORD *)(Instance + 32) = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
  if (a3)
    *((_DWORD *)v10 + 11) = a4;
  context.version = 0;
  context.info = v10;
  memset(&context.retain, 0, 24);
  task_get_special_port(*MEMORY[0x1E0C83DA0], 4, &special_port[1]);
  if (bootstrap_look_up2())
  {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    goto LABEL_29;
  }
  v24 = CFMachPortCreateWithPort((CFAllocatorRef)a1, special_port[0], (CFMachPortCallBack)__CFMessagePortDummyCallback, &context, 0);
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
  if (!v24)
    goto LABEL_29;
  v10[3] = (unint64_t)v24;
  v25 = atomic_load(v10 + 1);
  while (2)
  {
    v26 = __ldaxr(v11);
    if (v26 == v25)
    {
      if (!__stlxr(v25 | 1, v11))
      {
        v27 = 1;
        goto LABEL_45;
      }
    }
    else
    {
      __clrex();
    }
    v27 = 0;
LABEL_45:
    v25 = v26;
    if (!v27)
      continue;
    break;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (!a3)
  {
    value = 0;
    if (!__CFAllRemoteMessagePorts)
      goto LABEL_51;
    if (CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllRemoteMessagePorts, v8, (const void **)&value))
    {
      CFRetain(value);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      CFRelease(v10);
      return (unint64_t *)value;
    }
    Mutable = (__CFDictionary *)__CFAllRemoteMessagePorts;
    if (!__CFAllRemoteMessagePorts)
    {
LABEL_51:
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
      __CFAllRemoteMessagePorts = (uint64_t)Mutable;
    }
    CFDictionaryAddValue(Mutable, v8, v10);
  }
  CFRetain(v24);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  CFMachPortSetInvalidationCallBack(v24, (CFMachPortInvalidationCallBack)__CFMessagePortInvalidationCallBack);
  if (CFMachPortIsValid(v24))
  {
    CFRelease(v24);
    return v10;
  }
  CFRelease(v10);
  v21 = v24;
LABEL_30:
  CFRelease(v21);
  return 0;
}

CFMachPortRef CFMachPortCreateWithPort(CFAllocatorRef allocator, mach_port_t portNum, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMachPortRef)_CFMachPortCreateWithPort4((__objc2_class **)allocator, portNum, (uint64_t)callout, (__int128 *)&context->version, shouldFreeInfo, 1);
}

void CFMachPortSetInvalidationCallBack(CFMachPortRef port, CFMachPortInvalidationCallBack callout)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  mach_port_type_t ptype;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v4 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v4 != 36)
    _CFAssertMismatchedTypeID(0x24uLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (callout)
    {
      ptype = 0;
      if (mach_port_type(*MEMORY[0x1E0C83DA0], *((_DWORD *)port + 5), &ptype) || (ptype & 0x50000) == 0)
        CFLog(3, (uint64_t)CFSTR("*** WARNING: CFMachPortSetInvalidationCallBack() called on a CFMachPort with a Mach port (0x%x) which does not have any send rights.  This is not going to work.  Callback function: %p"), v5, v6, v7, v8, v9, v10, *((_DWORD *)port + 5));
    }
    os_unfair_lock_lock((os_unfair_lock_t)port + 24);
    if (callout && *((_DWORD *)port + 4))
    {
      if (*((_QWORD *)port + 4))
      {
        CFLog(4, (uint64_t)CFSTR("CFMachPortSetInvalidationCallBack(): attempt to set invalidation callback (%p) on invalid CFMachPort (%p) thwarted"), v11, v12, v13, v14, v15, v16, (__int16)callout);
      }
      else
      {
        v17 = *((_QWORD *)port + 8);
        os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
        ((void (*)(CFMachPortRef, uint64_t))callout)(port, v17);
        os_unfair_lock_lock((os_unfair_lock_t)port + 24);
      }
    }
    else
    {
      *((_QWORD *)port + 4) = callout;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
  }
}

uint64_t _CFMachPortCreate4(__objc2_class **a1, uint64_t a2, __int128 *a3, _BYTE *a4, int a5)
{
  ipc_space_t *v10;
  uint64_t inserted;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  mach_port_name_t name;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (a4)
    *a4 = 1;
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) != 0)
    return 0;
  name = 0;
  v10 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  inserted = mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, &name);
  if (!(_DWORD)inserted)
  {
    inserted = mach_port_insert_right(*v10, name, name, 0x14u);
    if (!(_DWORD)inserted)
    {
      result = _CFMachPortCreateWithPort4(a1, name, a2, a3, a4, a5);
      if (!result)
      {
        if (name)
        {
          mach_port_mod_refs(*v10, name, 1u, -1);
          mach_port_deallocate(*v10, name);
        }
        return 0;
      }
      v21 = (unint64_t *)(result + 8);
      v22 = atomic_load((unint64_t *)(result + 8));
      while (1)
      {
        v23 = __ldaxr(v21);
        if (v23 != v22)
          break;
        if (__stlxr(v22 | 2, v21))
          goto LABEL_22;
        v24 = 1;
LABEL_23:
        v22 = v23;
        if (v24)
        {
          v25 = atomic_load(v21);
          while (1)
          {
            v26 = __ldaxr(v21);
            if (v26 != v25)
              break;
            if (__stlxr(v25 | 4, v21))
              goto LABEL_29;
            v27 = 1;
LABEL_30:
            v25 = v26;
            if (v27)
              return result;
          }
          __clrex();
LABEL_29:
          v27 = 0;
          goto LABEL_30;
        }
      }
      __clrex();
LABEL_22:
      v24 = 0;
      goto LABEL_23;
    }
  }
  if (name)
  {
    mach_port_mod_refs(*v10, name, 1u, -1);
    v12 = _CFOSLog();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      _CFMachPortCreate4_cold_2((int *)&name, inserted, v12);
  }
  else
  {
    v13 = _CFOSLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      _CFMachPortCreate4_cold_1(inserted, v13, v14, v15, v16, v17, v18, v19);
  }
  return 0;
}

CFRunLoopSourceRef CFMachPortCreateRunLoopSource(CFAllocatorRef allocator, CFMachPortRef port, CFIndex order)
{
  unint64_t v6;
  os_unfair_lock_s *v7;
  __CFRunLoopSource *v8;
  __CFRunLoopSource *v9;
  int IsValid;
  CFRunLoopSourceRef v11;
  CFRunLoopSourceContext v13;

  v13.perform = (void (__cdecl *)(void *))*MEMORY[0x1E0C80C00];
  v6 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v6 != 36)
    _CFAssertMismatchedTypeID(0x24uLL, v6);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0 && CFMachPortIsValid(port))
  {
    v7 = (os_unfair_lock_s *)((char *)port + 96);
    os_unfair_lock_lock((os_unfair_lock_t)port + 24);
    if (*((_DWORD *)port + 4))
    {
LABEL_9:
      v8 = 0;
LABEL_18:
      os_unfair_lock_unlock(v7);
      return v8;
    }
    v9 = (__CFRunLoopSource *)*((_QWORD *)port + 5);
    if (v9)
    {
      IsValid = CFRunLoopSourceIsValid(v9);
      v11 = (CFRunLoopSourceRef)*((_QWORD *)port + 5);
      if (IsValid)
      {
        if (v11)
          goto LABEL_17;
      }
      else
      {
        CFRelease(v11);
        *((_QWORD *)port + 5) = 0;
      }
    }
    v13.retain = CFRetain;
    v13.release = CFRelease;
    v13.copyDescription = (CFStringRef (__cdecl *)(const void *))__CFMachPortCopyDescription;
    v13.equal = (Boolean (__cdecl *)(const void *, const void *))__CFMachPortEqual;
    v13.version = 1;
    v13.info = port;
    v13.hash = (CFHashCode (__cdecl *)(const void *))__CFMachPortHash;
    v13.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMachPortGetPort;
    v13.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMachPortPerform;
    v11 = CFRunLoopSourceCreate(allocator, order, &v13);
    *((_QWORD *)port + 5) = v11;
    if (!v11)
      goto LABEL_9;
LABEL_17:
    v8 = (__CFRunLoopSource *)CFRetain(v11);
    goto LABEL_18;
  }
  return 0;
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  uint64_t Instance;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  size_t v13;
  const void *(__cdecl *retain)(const void *);
  pthread_mutexattr_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (!context)
    CFRunLoopSourceCreate_cold_1();
  Instance = _CFRuntimeCreateInstance((__objc2_class **)allocator, 0x2EuLL, 168, 0);
  v7 = Instance;
  if (Instance)
  {
    v8 = (unint64_t *)(Instance + 8);
    v9 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      v10 = __ldaxr(v8);
      if (v10 != v9)
        break;
      if (__stlxr(v9 | 8, v8))
        goto LABEL_12;
      v11 = 1;
LABEL_13:
      v9 = v10;
      if (v11)
      {
        atomic_store(0, (unint64_t *)(Instance + 88));
        v16.__sig = 0;
        *(_QWORD *)v16.__opaque = 0;
        pthread_mutexattr_init(&v16);
        pthread_mutexattr_settype(&v16, 2);
        pthread_mutex_init((pthread_mutex_t *)(v7 + 16), &v16);
        pthread_mutexattr_destroy(&v16);
        *(_QWORD *)(v7 + 80) = order;
        v12 = 72;
        if (context->version != 1)
          v12 = 0;
        if (context->version)
          v13 = v12;
        else
          v13 = 80;
        memmove((void *)(v7 + 104), context, v13);
        retain = context->retain;
        if (retain)
          *(_QWORD *)(v7 + 112) = ((uint64_t (*)(void *))retain)(context->info);
        return (CFRunLoopSourceRef)v7;
      }
    }
    __clrex();
LABEL_12:
    v11 = 0;
    goto LABEL_13;
  }
  return (CFRunLoopSourceRef)v7;
}

uint64_t _CFMachPortCreateWithPort4(__objc2_class **a1, mach_port_name_t name, uint64_t a3, __int128 *a4, _BYTE *a5, int a6)
{
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  mach_port_type_t v15;
  NSObject *v16;
  _BOOL4 v17;
  CFIndex Count;
  CFIndex v19;
  CFIndex v20;
  _DWORD *ValueAtIndex;
  uint64_t v22;
  uint64_t Instance;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  uint64_t (*v27)(uint64_t);
  __CFArray *Mutable;
  NSObject *v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  NSObject *v34;
  _QWORD v36[4];
  mach_port_name_t v37;
  _QWORD handler[5];
  mach_port_name_t v39;
  mach_port_type_t ptype;
  uint8_t buf[4];
  uint64_t v42;
  __int16 v43;
  int v44;
  __int16 v45;
  uint64_t v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (a5)
    *a5 = 1;
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) != 0)
    return 0;
  ptype = 0;
  v12 = mach_port_type(*MEMORY[0x1E0C83DA0], name, &ptype);
  if ((_DWORD)v12)
    v13 = 1;
  else
    v13 = (ptype & 0x70000) == 0;
  if (v13)
  {
    v14 = v12;
    v15 = ptype & 0xFFEFFFFF;
    v16 = _CFOSLog();
    v17 = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    if (v15)
    {
      if (v17)
      {
        *(_DWORD *)buf = 134218496;
        v42 = name;
        v43 = 1024;
        v44 = v14;
        v45 = 2048;
        v46 = ptype;
        _os_log_error_impl(&dword_182A8C000, v16, OS_LOG_TYPE_ERROR, "*** CFMachPortCreateWithPort(): bad Mach port parameter (0x%lx) or unsupported mysterious kind of Mach port (%d, %ld)", buf, 0x1Cu);
      }
    }
    else if (v17)
    {
      _CFMachPortCreateWithPort4_cold_1(name, v14, v16);
    }
    return 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMachPortsLock);
  if (__CFAllMachPorts && (Count = CFArrayGetCount((CFArrayRef)__CFAllMachPorts), Count >= 1))
  {
    v19 = Count;
    v20 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)__CFAllMachPorts, v20);
      if (ValueAtIndex)
      {
        v22 = (uint64_t)ValueAtIndex;
        if (ValueAtIndex[5] == name)
          break;
      }
      if (v19 == ++v20)
        goto LABEL_22;
    }
    CFRetain(ValueAtIndex);
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
    v32 = 1;
  }
  else
  {
LABEL_22:
    Instance = _CFRuntimeCreateInstance(a1, 0x24uLL, 104, 0);
    if (!Instance)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
      v33 = _CFOSLog();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        _CFMachPortCreateWithPort4_cold_2(v33);
      return 0;
    }
    v22 = Instance;
    *(_DWORD *)(Instance + 20) = name;
    *(_QWORD *)(Instance + 48) = a3;
    *(_DWORD *)(Instance + 96) = 0;
    if (a4)
    {
      v24 = *a4;
      v25 = a4[1];
      *(_QWORD *)(Instance + 88) = *((_QWORD *)a4 + 4);
      *(_OWORD *)(Instance + 72) = v25;
      *(_OWORD *)(Instance + 56) = v24;
      v26 = *((_QWORD *)a4 + 1);
      v27 = (uint64_t (*)(uint64_t))*((_QWORD *)a4 + 2);
      if (v27)
      {
        v26 = v27(v26);
        v27 = (uint64_t (*)(uint64_t))*((_QWORD *)a4 + 2);
      }
      *(_QWORD *)(v22 + 64) = v26;
      *(_QWORD *)(v22 + 104) = v27;
      *(_QWORD *)(v22 + 112) = *((_QWORD *)a4 + 3);
      *(_QWORD *)(v22 + 72) = 0xAAAAAAAAAACCCAAALL;
      *(_QWORD *)(v22 + 80) = 0xAAAAAAAAAABBBAAALL;
    }
    *(_DWORD *)(v22 + 16) = 0;
    Mutable = (__CFArray *)__CFAllMachPorts;
    if (!__CFAllMachPorts)
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
      __CFAllMachPorts = (uint64_t)Mutable;
    }
    CFArrayAppendValue(Mutable, (const void *)v22);
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
    if (a5)
      *a5 = 0;
    if (a6 && (ptype & 0x50000) != 0)
    {
      _cfmp_record_intent_to_invalidate(0, name);
      if (_CFMachPortQueue_onceToken != -1)
        dispatch_once(&_CFMachPortQueue_onceToken, &__block_literal_global_17);
      v29 = dispatch_source_create(MEMORY[0x1E0C80DA0], name, 1uLL, (dispatch_queue_t)_CFMachPortQueue___CFMachPortQueue);
      if (v29)
      {
        v30 = v29;
        v31 = MEMORY[0x1E0C809B0];
        handler[0] = MEMORY[0x1E0C809B0];
        handler[1] = 3221225472;
        handler[2] = ___CFMachPortCreateWithPort4_block_invoke;
        handler[3] = &unk_1E12E57A8;
        v39 = name;
        handler[4] = v29;
        dispatch_source_set_cancel_handler(v29, handler);
        v36[0] = v31;
        v36[1] = 3221225472;
        v36[2] = ___CFMachPortCreateWithPort4_block_invoke_2;
        v36[3] = &__block_descriptor_36_e5_v8__0l;
        v37 = name;
        dispatch_source_set_event_handler(v30, v36);
        *(_QWORD *)(v22 + 24) = v30;
        dispatch_resume(v30);
      }
    }
    v32 = 0;
  }
  if (!CFMachPortIsValid((CFMachPortRef)v22))
  {
    v34 = _CFOSLog();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      _CFMachPortCreateWithPort4_cold_3(v22, v32, v34);
    CFRelease((CFTypeRef)v22);
    return 0;
  }
  return v22;
}

Boolean CFMachPortIsValid(CFMachPortRef port)
{
  kern_return_t v3;
  mach_port_type_t ptype;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x24uLL, (__objc2_class **)port))
    return -[__CFMachPort isValid](port, "isValid");
  if (*((_DWORD *)port + 4))
    return 0;
  ptype = 0;
  v3 = mach_port_type(*MEMORY[0x1E0C83DA0], *((_DWORD *)port + 5), &ptype);
  return (ptype & 0x70000) != 0 && v3 == 0;
}

void _cfmp_record_intent_to_invalidate(char a1, int a2)
{
  _DWORD *v4;
  void *v5;
  __CFSet *v6;

  if (a2)
  {
    v4 = malloc_type_calloc(1uLL, 8uLL, 0x1000040789AEA99uLL);
    if (!v4)
      _cfmp_record_intent_to_invalidate_cold_1();
    v5 = v4;
    *v4 = a2;
    *((_BYTE *)v4 + 4) = a1;
    if (_cfmp_records_oGuard != -1)
      dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
    v6 = (__CFSet *)_cfmp_records_oRecords;
    os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
    if (CFSetGetValue(v6, v5))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
      free(v5);
    }
    else
    {
      CFSetAddValue(v6, v5);
      os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
    }
  }
}

void __CF_USED()
{
  unsigned __int8 v0;

  do
    v0 = __ldaxr((unsigned __int8 *)&__CF_FORK_STATE);
  while (__stlxr(v0 | 2, (unsigned __int8 *)&__CF_FORK_STATE));
}

CFStringRef __CFMessagePortCreateSanitizedStringName(const __CFString *a1, UInt8 **a2)
{
  UInt8 *Typed;
  CFIndex v5;
  CFStringRef v6;
  CFIndex usedBufLen[2];
  CFRange v9;

  usedBufLen[1] = *MEMORY[0x1E0C80C00];
  usedBufLen[0] = 0;
  Typed = (UInt8 *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 129, 179708275, 0);
  v9.length = CFStringGetLength(a1);
  v9.location = 0;
  CFStringGetBytes(a1, v9, 0x8000100u, 0, 0, Typed, 128, usedBufLen);
  v5 = usedBufLen[0];
  Typed[usedBufLen[0]] = 0;
  if (strlen((const char *)Typed) != v5)
  {
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    Typed = 0;
    v6 = 0;
    if (!a2)
      return v6;
LABEL_5:
    *a2 = Typed;
    return v6;
  }
  v6 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed, v5, 0x8000100u, 0);
  if (a2)
    goto LABEL_5;
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  return v6;
}

void *__CFRunLoopDeallocate(mach_port_context_t a1)
{
  mach_port_name_t v1;
  unsigned __int8 *v2;
  _opaque_pthread_t *v5;
  const void *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  const __CFSet *v11;
  CFTypeRef *v12;
  CFTypeRef *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  char __str[256];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v2 = (unsigned __int8 *)(a1 + 680);
  if (!atomic_load((unsigned __int8 *)(a1 + 680)))
    __CFRunLoopDeallocate_cold_1();
  kdebug_trace();
  atomic_store(0, v2);
  v5 = (_opaque_pthread_t *)pthread_main_thread_np();
  v6 = _CFRunLoopGet0b(v5);
  if (v6 == (const void *)a1)
  {
    __break(1u);
    goto LABEL_24;
  }
  v7 = (unint64_t *)(a1 + 8);
  v8 = atomic_load((unint64_t *)(a1 + 8));
  do
  {
    v9 = __ldaxr(v7);
    if (v9 == v8)
    {
      if (!__stlxr(v8 | 4, v7))
      {
        v10 = 1;
        goto LABEL_9;
      }
    }
    else
    {
      __clrex();
    }
    v10 = 0;
LABEL_9:
    v8 = v9;
  }
  while (!v10);
  v11 = *(const __CFSet **)(a1 + 632);
  if (v11)
  {
    CFSetApplyFunction(v11, (CFSetApplierFunction)__CFRunLoopCleanseSources, (void *)a1);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 632), (CFSetApplierFunction)__CFRunLoopDeallocateSources, (void *)a1);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 632), (CFSetApplierFunction)__CFRunLoopDeallocateObservers, (void *)a1);
    CFSetApplyFunction(*(CFSetRef *)(a1 + 632), (CFSetApplierFunction)__CFRunLoopDeallocateTimers, (void *)a1);
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v12 = *(CFTypeRef **)(a1 + 640);
  if (v12)
  {
    do
    {
      v13 = (CFTypeRef *)*v12;
      CFRelease(v12[1]);
      _Block_release(v12[2]);
      free(v12);
      v12 = v13;
    }
    while (v13);
  }
  v14 = *(const void **)(a1 + 616);
  if (v14)
    CFRelease(v14);
  v15 = *(const void **)(a1 + 608);
  if (v15)
    CFRelease(v15);
  v16 = *(const void **)(a1 + 632);
  if (v16)
    CFRelease(v16);
  v1 = *(_DWORD *)(a1 + 80);
  LODWORD(v6) = mach_port_destruct(*MEMORY[0x1E0C83DA0], v1, -1, a1);
  if ((_DWORD)v6)
  {
LABEL_24:
    snprintf(__str, 0x100uLL, "*** Unable to destruct port. (0x%x, %d, %p) ***", v1, (_DWORD)v6, (const void *)a1);
    qword_1EDCD1038 = (uint64_t)__str;
    __break(1u);
  }
  *(_DWORD *)(a1 + 80) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  return memset((void *)(a1 + 16), 140, 0x2A0uLL);
}

const void *_CFRunLoopGet0b(_opaque_pthread_t *a1)
{
  const void *v1;
  const void *Value;

  v1 = a1;
  if (pthread_equal(a1, 0))
    v1 = (const void *)pthread_main_thread_np();
  os_unfair_lock_lock((os_unfair_lock_t)&loopsLock);
  if (__CFRunLoops)
    Value = CFDictionaryGetValue((CFDictionaryRef)__CFRunLoops, v1);
  else
    Value = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&loopsLock);
  return Value;
}

uint64_t __CFSocketSchedule(uint64_t a1, const void *a2)
{
  pthread_mutex_t *v4;
  char v5;
  const __CFArray *v6;
  __CFArray *MutableCopy;
  int v8;
  char v10;

  v4 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  v5 = atomic_load((unint64_t *)(a1 + 8));
  if ((v5 & 0x10) == 0)
    return pthread_mutex_unlock(v4);
  v6 = *(const __CFArray **)(a1 + 200);
  MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v6);
  CFArrayAppendValue(MutableCopy, a2);
  *(_QWORD *)(a1 + 200) = MutableCopy;
  CFRelease(v6);
  v8 = *(_DWORD *)(a1 + 184);
  *(_DWORD *)(a1 + 184) = v8 + 1;
  if (v8)
    return pthread_mutex_unlock(v4);
  v10 = atomic_load((unint64_t *)(a1 + 8));
  return __CFSocketEnableCallBacks(a1, v10 & 0xF, 1);
}

void boundPairWriteSchedule(int a1, CFTypeRef cf, uint64_t a3, uint64_t a4)
{
  const void *v6;
  CFTypeRef v7;

  if (a4)
  {
    v6 = *(const void **)(a4 + 64);
    if (v6)
      CFRelease(v6);
    if (cf)
      v7 = CFRetain(cf);
    else
      v7 = 0;
    *(_QWORD *)(a4 + 64) = v7;
    ++*(_WORD *)(a4 + 52);
  }
}

void boundPairReadSchedule(int a1, CFTypeRef cf, uint64_t a3, uint64_t a4)
{
  const void *v6;
  CFTypeRef v7;

  if (a4)
  {
    v6 = *(const void **)(a4 + 16);
    if (v6)
      CFRelease(v6);
    if (cf)
      v7 = CFRetain(cf);
    else
      v7 = 0;
    *(_QWORD *)(a4 + 16) = v7;
    ++*(_WORD *)(a4 + 4);
  }
}

CFSocketRef CFSocketCreateWithNative(CFAllocatorRef allocator, CFSocketNativeHandle sock, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  char v7;
  int64_t v10;
  __CFData *v11;
  unint64_t v12;
  UInt8 *MutableBytePtr;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFDictionary *Mutable;
  unint64_t *Instance;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  _QWORD *v38;
  CFMutableArrayRef v39;
  _QWORD *v40;
  qos_class_t v42;
  const void *(__cdecl *retain)(const void *);
  void *info;
  char *v45;
  unint64_t v46;
  unint64_t v47;
  __int16 v48;
  pthread_t v49;
  socklen_t v50;
  void *value;
  pthread_attr_t callBacks;
  uint64_t v53;

  v7 = callBackTypes;
  v53 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  value = 0;
  v50 = 4;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
  if (!__CFReadSockets)
  {
    __CFWriteSockets = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0);
    __CFReadSockets = (uint64_t)CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0);
    __CFWriteSocketsFds = (uint64_t)CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    __CFReadSocketsFds = (uint64_t)CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
    if (socketpair(1, 2, 0, (int *)&__CFWakeupSocketPair) < 0
      || (v48 = 1, fcntl(__CFWakeupSocketPair, 2) < 0)
      || (v48 = 1, fcntl(SHIDWORD(__CFWakeupSocketPair), 2) < 0))
    {
      close(__CFWakeupSocketPair);
      close(SHIDWORD(__CFWakeupSocketPair));
      __CFWakeupSocketPair = -1;
      CFLog(4, (uint64_t)CFSTR("*** Could not create wakeup socket pair for CFSocket!!!"), v14, v15, v16, v17, v18, v19, v48);
    }
    else
    {
      LODWORD(callBacks.__sig) = 1;
      ioctl(__CFWakeupSocketPair, 0x8004667EuLL, &callBacks);
      ioctl(SHIDWORD(__CFWakeupSocketPair), 0x8004667EuLL, &callBacks);
      v10 = HIDWORD(__CFWakeupSocketPair);
      if ((__CFWakeupSocketPair & 0x8000000000000000) == 0)
      {
        v11 = (__CFData *)__CFReadSocketsFds;
        v12 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
        if ((uint64_t)v12 <= v10)
        {
          v46 = v12 >> 5;
          v47 = 4 * (((unint64_t)(v10 + 32) >> 5) - (v12 >> 5));
          CFDataIncreaseLength(v11, v47);
          MutableBytePtr = CFDataGetMutableBytePtr(v11);
          bzero(&MutableBytePtr[4 * v46], v47);
        }
        else
        {
          MutableBytePtr = CFDataGetMutableBytePtr(v11);
        }
        if ((!__darwin_check_fd_set_overflow(v10, MutableBytePtr, 1)
           || ((*(_DWORD *)&MutableBytePtr[((unint64_t)v10 >> 3) & 0x1FFFFFFC] >> v10) & 1) == 0)
          && __darwin_check_fd_set_overflow(v10, MutableBytePtr, 1))
        {
          *(_DWORD *)&MutableBytePtr[4 * (v10 >> 5)] |= 1 << v10;
        }
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllSocketsLock);
  Mutable = (const __CFDictionary *)__CFAllSockets;
  if (!__CFAllSockets)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
    __CFAllSockets = (uint64_t)Mutable;
  }
  if (sock != -1 && CFDictionaryGetValueIfPresent(Mutable, (const void *)sock, (const void **)&value))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
    CFRetain(value);
    return (CFSocketRef)value;
  }
  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  Instance = (unint64_t *)_CFRuntimeCreateInstance((__objc2_class **)allocator, 0x3DuLL, 344, 0);
  value = Instance;
  if (!Instance)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
    return 0;
  }
  v22 = Instance + 1;
  v23 = atomic_load(Instance + 1);
  do
  {
    v24 = __ldaxr(v22);
    if (v24 == v23)
    {
      if (!__stlxr(v23 & 0xFFFFFFFFFFFFFFF0 | v7 & 0xF, v22))
      {
        v25 = 1;
        goto LABEL_27;
      }
    }
    else
    {
      __clrex();
    }
    v25 = 0;
LABEL_27:
    v23 = v24;
  }
  while (!v25);
  if (sock != -1)
  {
    v26 = (unint64_t *)((char *)value + 8);
    v27 = atomic_load((unint64_t *)value + 1);
    while (1)
    {
      v28 = __ldaxr(v26);
      if (v28 != v27)
        break;
      if (__stlxr(v27 | 0x10, v26))
        goto LABEL_34;
      v29 = 1;
LABEL_35:
      v27 = v28;
      if (v29)
        goto LABEL_36;
    }
    __clrex();
LABEL_34:
    v29 = 0;
    goto LABEL_35;
  }
LABEL_36:
  v30 = (unint64_t *)((char *)value + 8);
  v31 = atomic_load((unint64_t *)value + 1);
  while (2)
  {
    v32 = __ldaxr(v30);
    if (v32 == v31)
    {
      if (!__stlxr(v31 & 0xFFFFFFFFFFFFFFBFLL, v30))
      {
        v33 = 1;
        goto LABEL_42;
      }
    }
    else
    {
      __clrex();
    }
    v33 = 0;
LABEL_42:
    v31 = v32;
    if (!v33)
      continue;
    break;
  }
  v34 = (unint64_t *)((char *)value + 8);
  v35 = atomic_load((unint64_t *)value + 1);
  while (2)
  {
    v36 = __ldaxr(v34);
    if (v36 == v35)
    {
      if (!__stlxr(v35 & 0xFFFFFFFFFFFFFFDFLL, v34))
      {
        v37 = 1;
        goto LABEL_49;
      }
    }
    else
    {
      __clrex();
    }
    v37 = 0;
LABEL_49:
    v35 = v36;
    if (!v37)
      continue;
    break;
  }
  v38 = value;
  *((_DWORD *)value + 4) = v7 & 0x73 | *((_DWORD *)value + 4) & 0xFFFFFF00 | 0x80;
  v38[3] = 850045857;
  *((_OWORD *)v38 + 2) = 0u;
  *((_OWORD *)v38 + 3) = 0u;
  *((_OWORD *)v38 + 4) = 0u;
  v38[10] = 0;
  v38[11] = 850045857;
  *((_OWORD *)v38 + 6) = 0u;
  *((_OWORD *)v38 + 7) = 0u;
  *((_OWORD *)v38 + 8) = 0u;
  v38[18] = 0;
  *((_DWORD *)v38 + 38) = sock;
  if (sock == -1)
  {
    *((_DWORD *)v38 + 39) = 0;
    v38[26] = callout;
    *((_DWORD *)v38 + 70) = 0;
    v38[34] = 0;
    *((_DWORD *)v38 + 86) = 0;
    v38[42] = 0;
  }
  else
  {
    if (getsockopt(sock, 0xFFFF, 4104, (char *)v38 + 156, &v50))
      *((_DWORD *)value + 39) = 0;
    *(_OWORD *)&callBacks.__sig = *(_OWORD *)&kCFTypeArrayCallBacks.version;
    *(_QWORD *)&callBacks.__opaque[8] = kCFTypeArrayCallBacks.release;
    *(_QWORD *)&callBacks.__opaque[16] = 0;
    *(_QWORD *)&callBacks.__opaque[24] = CFEqual;
    v39 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (const CFArrayCallBacks *)&callBacks);
    v40 = value;
    *((_QWORD *)value + 25) = v39;
    v40[26] = callout;
    *((_DWORD *)v40 + 70) = 0;
    v40[34] = 0;
    *((_DWORD *)v40 + 86) = 0;
    v40[42] = 0;
    CFDictionaryAddValue((CFMutableDictionaryRef)__CFAllSockets, (const void *)sock, v40);
  }
  if (!__CFSocketManagerThread)
  {
    v49 = 0;
    memset(&callBacks, 0, sizeof(callBacks));
    pthread_attr_init(&callBacks);
    pthread_attr_setscope(&callBacks, 1);
    pthread_attr_setdetachstate(&callBacks, 2);
    v42 = qos_class_main();
    pthread_attr_set_qos_class_np(&callBacks, v42, 0);
    pthread_create(&v49, &callBacks, (void *(__cdecl *)(void *))__CFSocketManager, 0);
    pthread_attr_destroy(&callBacks);
    __CFSocketManagerThread = (uint64_t)v49;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
  if (context)
  {
    info = context->info;
    retain = context->retain;
    if (retain)
      info = (void *)((uint64_t (*)(void *))retain)(context->info);
    pthread_mutex_lock((pthread_mutex_t *)((char *)value + 24));
    v45 = (char *)value;
    *(_OWORD *)((char *)value + 232) = *(_OWORD *)&context->retain;
    *((_QWORD *)v45 + 31) = context->copyDescription;
    *((_QWORD *)v45 + 28) = info;
    pthread_mutex_unlock((pthread_mutex_t *)(v45 + 24));
  }
  return (CFSocketRef)value;
}

void __CFSocketPerformV0(uint64_t a1)
{
  pthread_mutex_t *v2;
  unint64_t *v3;
  char v4;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  const __CFArray *v9;
  const void *v10;
  unsigned int ValueAtIndex;
  const __CFArray *v12;
  const void *v13;
  void (*v14)(void);
  const void *v15;
  _BOOL4 v16;
  uint64_t v17;
  unsigned int v18;
  char v19;
  char v20;
  char v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  void (*v29)(uint64_t, uint64_t, const void *, int *, uint64_t);
  int v30;
  int *v31;
  uint64_t v32;
  int v33;
  const void *v34;
  const __CFData *v35;
  int Length;
  char *v37;
  char v38;
  unsigned int v39;
  const __CFArray *v40;
  CFTypeRef v41;
  const __CFArray *MutableCopy;
  void *v43;
  char v44;
  const __CFArray *v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  const __CFData *theData;
  void (*v50)(uint64_t);
  unsigned int v51;
  char v52;
  int v53;
  unsigned int v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v2 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  v3 = (unint64_t *)(a1 + 8);
  v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 0x10) == 0)
  {
    pthread_mutex_unlock(v2);
    return;
  }
  atomic_load(v3);
  v5 = atomic_load(v3);
  v6 = atomic_load(v3);
  v7 = v5 & (v6 << 26 >> 31);
  v8 = atomic_load(v3);
  if ((v5 & 3) == 2)
  {
    v12 = *(const __CFArray **)(a1 + 256);
    if (v12 && CFArrayGetCount(v12) >= 1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 256), 0);
      v10 = 0;
      goto LABEL_11;
    }
LABEL_12:
    v10 = 0;
    v13 = 0;
    ValueAtIndex = -1;
    goto LABEL_13;
  }
  if ((v5 & 3) != 3)
    goto LABEL_12;
  v9 = *(const __CFArray **)(a1 + 256);
  if (!v9 || CFArrayGetCount(v9) < 1)
    goto LABEL_12;
  v10 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 256), 0);
  CFRetain(v10);
  ValueAtIndex = -1;
LABEL_11:
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 256), 0);
  v13 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 264), 0);
  CFRetain(v13);
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 264), 0);
LABEL_13:
  v14 = *(void (**)(void))(a1 + 232);
  theData = (const __CFData *)v10;
  if (v14)
  {
    v50 = *(void (**)(uint64_t))(a1 + 240);
    v47 = *(_QWORD *)(a1 + 224);
    v14();
  }
  else
  {
    v47 = 0;
    v50 = 0;
  }
  v15 = v13;
  v16 = 0;
  v52 = v5;
  v53 = 0;
  v17 = (v8 >> 6) & 1;
  v54 = ValueAtIndex;
  v18 = atomic_load(v3);
  v19 = atomic_load(v3);
  v20 = atomic_load(v3);
  v46 = v20;
  v21 = atomic_load(v3);
  if ((v21 & 0x40) != 0)
    v16 = (*(_BYTE *)(a1 + 18) & 1) == 0;
  v51 = v7 & 3 | (8 * v17);
  v22 = v19 & 3;
  v23 = atomic_load(v3);
  do
  {
    v24 = __ldaxr(v3);
    if (v24 == v23)
    {
      if (!__stlxr(v23 & 0xFFFFFFFFFFFFFFDFLL, v3))
      {
        v25 = 1;
        goto LABEL_24;
      }
    }
    else
    {
      __clrex();
    }
    v25 = 0;
LABEL_24:
    v23 = v24;
  }
  while (!v25);
  v26 = atomic_load(v3);
  do
  {
    v27 = __ldaxr(v3);
    if (v27 == v26)
    {
      if (!__stlxr(v26 & 0xFFFFFFFFFFFFFFBFLL, v3))
      {
        v28 = 1;
        goto LABEL_31;
      }
    }
    else
    {
      __clrex();
    }
    v28 = 0;
LABEL_31:
    v26 = v27;
  }
  while (!v28);
  v48 = *(_QWORD *)(a1 + 224);
  if ((v21 & 0x40) != 0)
  {
    v53 = *(_DWORD *)(a1 + 160);
    *(_DWORD *)(a1 + 16) |= 0x10000u;
  }
  v29 = *(void (**)(uint64_t, uint64_t, const void *, int *, uint64_t))(a1 + 208);
  pthread_mutex_unlock(v2);
  v30 = v16 & (v18 >> 2);
  if (v30 == 1)
  {
    if (v53)
    {
      if (v29)
      {
        v31 = &v53;
        v32 = a1;
        goto LABEL_41;
      }
    }
    else if (v29)
    {
      v32 = a1;
      v31 = 0;
LABEL_41:
      v29(v32, 4, 0, v31, v48);
    }
    v33 = 1;
  }
  else
  {
    v33 = 0;
  }
  switch(v22)
  {
    case 2:
      v34 = v15;
      v35 = theData;
      if (v54 != -1)
      {
        if (v30)
        {
          v33 = 1;
          if (!CFSocketIsValid((CFSocketRef)a1) || !v29)
            break;
        }
        else if (!v29)
        {
          goto LABEL_69;
        }
        v29(a1, 2, v34, (int *)&v54, v48);
        goto LABEL_69;
      }
      break;
    case 3:
      v34 = v15;
      v35 = theData;
      if (theData)
      {
        if (!v30 || CFSocketIsValid((CFSocketRef)a1))
        {
          Length = CFDataGetLength(theData);
          if (v29)
            v29(a1, 3, v34, (int *)theData, v48);
          if (!Length && *(_DWORD *)(a1 + 156) == 1)
            CFSocketInvalidate((CFSocketRef)a1);
        }
LABEL_69:
        v33 = 1;
      }
      break;
    case 1:
      v34 = v15;
      v35 = theData;
      if ((v46 & 0x20) != 0)
      {
        if (v30)
        {
          v33 = 1;
          if (!CFSocketIsValid((CFSocketRef)a1) || !v29)
            break;
        }
        else if (!v29)
        {
          goto LABEL_69;
        }
        v33 = 1;
        v29(a1, 1, 0, 0, v48);
      }
      break;
    default:
      v34 = v15;
      v35 = theData;
      break;
  }
  if ((v18 & 8) != 0 && (v21 & 0x40) != 0 && !v53 && (!v33 || CFSocketIsValid((CFSocketRef)a1)) && v29)
    v29(a1, 8, 0, 0, v48);
  if (v50)
    v50(v47);
  if (v35)
    CFRelease(v35);
  if (v34)
    CFRelease(v34);
  pthread_mutex_lock(v2);
  v37 = 0;
  v38 = atomic_load(v3);
  if ((v52 & 2) != 0)
  {
    v39 = v51;
    if ((v38 & 0x10) != 0)
    {
      v40 = *(const __CFArray **)(a1 + 256);
      if (v40 && CFArrayGetCount(v40) >= 1)
      {
        CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 192));
        v41 = CFRetain(*(CFTypeRef *)(a1 + 200));
        MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, *(CFArrayRef *)(a1 + 200));
        v43 = *(void **)(a1 + 192);
        if (v43)
        {
          if (CFRunLoopSourceIsValid(*(CFRunLoopSourceRef *)(a1 + 192)))
          {
            CFRetain(v43);
            v44 = 0;
            goto LABEL_94;
          }
          v43 = 0;
        }
        v44 = 1;
LABEL_94:
        pthread_mutex_unlock(v2);
        v37 = __CFSocketCopyRunLoopToWakeUp((__CFRunLoopSource *)v43, MutableCopy);
        if ((v44 & 1) == 0)
          CFRelease(v43);
        pthread_mutex_lock(v2);
        if (v41 == *(CFTypeRef *)(a1 + 200))
        {
          *(_QWORD *)(a1 + 200) = MutableCopy;
          CFRelease(v41);
          v45 = (const __CFArray *)v41;
LABEL_100:
          CFRelease(v45);
        }
        else
        {
          CFRelease(v41);
          if (MutableCopy)
          {
            v45 = MutableCopy;
            goto LABEL_100;
          }
        }
      }
      else
      {
        v37 = 0;
      }
    }
  }
  else
  {
    v39 = v51;
  }
  __CFSocketEnableCallBacks(a1, *(_DWORD *)(a1 + 16) & v39, 0);
  if (v37)
  {
    CFRunLoopWakeUp((CFRunLoopRef)v37);
    CFRelease(v37);
  }
}

uint64_t __CFSocketEnableCallBacks(uint64_t a1, uint64_t a2, int a3)
{
  char v6;
  unsigned __int8 v7;
  int v8;
  unsigned __int8 v9;
  unint64_t v10;
  int v11;
  _BOOL4 v13;
  _BOOL4 v14;
  uint64_t v15;
  unsigned int v16;
  _BOOL4 v17;
  unsigned int v18;
  BOOL v19;
  _BOOL4 v20;
  BOOL v21;
  _BOOL4 v22;
  char v23;
  const __CFArray *v24;
  int64_t v25;
  __CFData *v26;
  unint64_t v27;
  UInt8 *MutableBytePtr;
  unint64_t v29;
  unint64_t v30;
  const __CFArray *v31;
  int64_t v32;
  __CFData *v33;
  unint64_t v34;
  UInt8 *v35;
  unint64_t v36;
  unint64_t v37;
  char v38;
  char v39;
  uint64_t v40;
  CFRange v41;
  CFRange v42;

  v40 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (!a2)
    return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
  v6 = atomic_load((unint64_t *)(a1 + 8));
  if ((v6 & 0x10) != 0 && *(int *)(a1 + 184) >= 1)
  {
    v7 = atomic_load((unint64_t *)(a1 + 8));
    v8 = v7 & 3;
    v9 = atomic_load((unint64_t *)(a1 + 8));
    v10 = a2 & v9 & 0xF;
    if (a3)
      *(_DWORD *)(a1 + 16) &= (~(_DWORD)v10 << 8) | 0xFFFF00FF;
    if (v8 == 2 || *(_DWORD *)(a1 + 156) != 1)
    {
      v11 = *(_DWORD *)(a1 + 16) | 0x10000;
      *(_DWORD *)(a1 + 16) = v11;
      if ((v11 & 0x10000) != 0)
        goto LABEL_18;
    }
    else
    {
      v11 = *(_DWORD *)(a1 + 16);
      if ((v11 & 0x10000) != 0)
        goto LABEL_18;
    }
    if ((v10 & 4) != 0)
    {
      v13 = 0;
      v14 = (v11 & 0x400) == 0;
      goto LABEL_21;
    }
LABEL_18:
    v14 = 0;
    v13 = v10 >= 8 && (v11 & 0x800) == 0;
LABEL_21:
    v15 = v7 & v10 & 3;
    v16 = v11 & 0x100;
    v17 = v16 == 0;
    v18 = v16 >> 8;
    v19 = v15 == 0;
    if (v15)
      v20 = v17;
    else
      v20 = 0;
    if (v19)
      LOBYTE(v18) = 1;
    v21 = v8 == 0;
    if (v8)
      v22 = v20;
    else
      v22 = 0;
    if (v21)
      v23 = 1;
    else
      v23 = v18;
    if (v14 || v13 || v22)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
      if (v14 || v13)
      {
        if (a3)
        {
          v24 = (const __CFArray *)__CFWriteSockets;
          v41.length = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
          v41.location = 0;
          if (CFArrayGetFirstIndexOfValue(v24, v41, (const void *)a1) == -1)
            CFArrayAppendValue((CFMutableArrayRef)__CFWriteSockets, (const void *)a1);
        }
        v25 = *(unsigned int *)(a1 + 152);
        if ((v25 & 0x80000000) == 0)
        {
          v26 = (__CFData *)__CFWriteSocketsFds;
          v27 = 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds);
          if ((uint64_t)v27 <= v25)
          {
            v29 = v27 >> 5;
            v30 = 4 * (((unint64_t)(v25 + 32) >> 5) - (v27 >> 5));
            CFDataIncreaseLength(v26, v30);
            MutableBytePtr = CFDataGetMutableBytePtr(v26);
            bzero(&MutableBytePtr[4 * v29], v30);
          }
          else
          {
            MutableBytePtr = CFDataGetMutableBytePtr(v26);
          }
          if (!__darwin_check_fd_set_overflow(v25, MutableBytePtr, 1)
            || ((*(_DWORD *)&MutableBytePtr[((unint64_t)v25 >> 3) & 0x1FFFFFFC] >> v25) & 1) == 0)
          {
            if (__darwin_check_fd_set_overflow(v25, MutableBytePtr, 1))
              *(_DWORD *)&MutableBytePtr[4 * (v25 >> 5)] |= 1 << v25;
            if ((_DWORD)__CFWakeupSocketPair != -1)
            {
              v38 = 119;
              send(__CFWakeupSocketPair, &v38, 1uLL, 0);
            }
          }
        }
      }
      if ((v23 & 1) == 0)
      {
        if (a3)
        {
          v31 = (const __CFArray *)__CFReadSockets;
          v42.length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
          v42.location = 0;
          if (CFArrayGetFirstIndexOfValue(v31, v42, (const void *)a1) == -1)
            CFArrayAppendValue((CFMutableArrayRef)__CFReadSockets, (const void *)a1);
        }
        __CFReadSocketsTimeoutInvalid = 0;
        v32 = *(unsigned int *)(a1 + 152);
        if ((v32 & 0x80000000) == 0)
        {
          v33 = (__CFData *)__CFReadSocketsFds;
          v34 = 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds);
          if ((uint64_t)v34 <= v32)
          {
            v36 = v34 >> 5;
            v37 = 4 * (((unint64_t)(v32 + 32) >> 5) - (v34 >> 5));
            CFDataIncreaseLength(v33, v37);
            v35 = CFDataGetMutableBytePtr(v33);
            bzero(&v35[4 * v36], v37);
          }
          else
          {
            v35 = CFDataGetMutableBytePtr(v33);
          }
          if (!__darwin_check_fd_set_overflow(v32, v35, 1)
            || ((*(_DWORD *)&v35[((unint64_t)v32 >> 3) & 0x1FFFFFFC] >> v32) & 1) == 0)
          {
            if (__darwin_check_fd_set_overflow(v32, v35, 1))
              *(_DWORD *)&v35[4 * (v32 >> 5)] |= 1 << v32;
            if ((_DWORD)__CFWakeupSocketPair != -1)
            {
              v39 = 114;
              send(__CFWakeupSocketPair, &v39, 1uLL, 0);
            }
          }
        }
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
    }
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
}

void CFDataIncreaseLength(CFMutableDataRef theData, CFIndex extraLength)
{
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    -[__CFData increaseLengthBy:](theData, "increaseLengthBy:", extraLength);
  }
  else if (extraLength < 0)
  {
    __break(1u);
  }
  else
  {
    CFDataSetLength(theData, *((_QWORD *)theData + 2) + extraLength);
  }
}

uint64_t _CFExtensionUniCharsIsValidToAppend(const __CFString *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFRange v15;
  uint64_t v16;
  uint64_t result;
  unsigned int v18;
  unint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t i;
  uint64_t v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  CFRange v32;
  uint64_t v33;
  _OWORD v34[8];
  CFStringRef theString[2];
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  theString[0] = 0;
  v36 = 0u;
  memset(v34, 0, sizeof(v34));
  v37 = a2;
  v38 = 0;
  theString[1] = a1;
  v39 = 0;
  if (!a2)
    return 0;
  v2 = a2 - 1;
  if (a2 < 1)
    return 1;
  v3 = 0;
  v4 = 1 - a2;
  v5 = a2 + 63;
  v6 = a2 - 1;
  while (1)
  {
    v7 = (unint64_t)v6 >= 0x3F ? 63 : v6;
    if (theString[1])
    {
      v8 = *((_WORD *)&theString[1]->isa + v6 + *((_QWORD *)&v36 + 1));
    }
    else if ((_QWORD)v36)
    {
      v8 = *(char *)(v36 + *((_QWORD *)&v36 + 1) + v6);
    }
    else
    {
      v9 = v39 > v6 && v3 <= v6;
      if (!v9)
      {
        v10 = -v7;
        v11 = v7 + v4;
        v12 = v5 - v7;
        v13 = v6 + v10;
        v14 = v13 + 64;
        if (v13 + 64 >= v37)
          v14 = v37;
        v38 = v13;
        v39 = v14;
        v15.location = v13 + *((_QWORD *)&v36 + 1);
        if (v37 >= v12)
          v16 = v12;
        else
          v16 = v37;
        v15.length = v16 + v11;
        CFStringGetCharacters(theString[0], v15, (UniChar *)v34);
        v3 = v38;
      }
      v8 = *((_WORD *)v34 + v6 - v3);
    }
    result = 0;
    if (v8 <= 0x2029u)
      break;
    v18 = v8 - 8234;
    v9 = v18 > 0x3F;
    v19 = (1 << v18) & 0xF00000000000001FLL;
    if (!v9 && v19 != 0)
      return result;
LABEL_35:
    ++v4;
    --v5;
    v9 = v6-- <= 0;
    if (v9)
      return 1;
  }
  if (v8 > 0x61Bu)
  {
    if (v8 - 8206 < 2 || v8 == 1564)
      return result;
    goto LABEL_35;
  }
  if (v8 == 32)
    return result;
  if (v8 != 46)
  {
    if (v8 == 47)
      return result;
    goto LABEL_35;
  }
  if (v6 >= v2)
    return 0;
  v21 = v6 + 64;
  v22 = -v6;
  for (i = v6 + 1; ; --i)
  {
    v24 = (unint64_t)v6 >= 0x40 ? 64 : v6;
    v25 = i - 1;
    if (i - 1 < 1)
      break;
    if (theString[1])
    {
      v26 = *((_WORD *)theString[1] + i + *((_QWORD *)&v36 + 1) - 2);
    }
    else if ((_QWORD)v36)
    {
      v26 = *(char *)(v36 + *((_QWORD *)&v36 + 1) + i - 2);
    }
    else
    {
      if (v39 < v25 || v3 >= v25)
      {
        v27 = -v24;
        v28 = v24 + v22;
        v29 = v21 - v24;
        v30 = i + v27;
        v31 = v30 + 63;
        if (v30 + 63 >= v37)
          v31 = v37;
        v38 = v30 - 1;
        v39 = v31;
        v32.location = v30 + *((_QWORD *)&v36 + 1) - 1;
        if (v37 >= v29)
          v33 = v29;
        else
          v33 = v37;
        v32.length = v33 + v28;
        CFStringGetCharacters(theString[0], v32, (UniChar *)v34);
        v3 = v38;
      }
      v26 = *((_WORD *)&v34[-1] + i - v3 + 6);
    }
    result = 0;
    ++v22;
    --v21;
    --v6;
    if (v26 == 47)
      return result;
  }
  return 1;
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
  _CFPreferencesSetAppValueWithContainerAndConfiguration((uint64_t)key, (uint64_t)value, (uint64_t)applicationID, 0, 0);
}

uint64_t _CFRuntimeRegisterClass(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  unsigned int v21;

  if ((*(_BYTE *)a1 & 8) != 0 && !*(_QWORD *)(a1 + 80))
  {
    CFLog(4, (uint64_t)CFSTR("*** _CFRuntimeRegisterClass() given inconsistent class '%s'.  Program will crash soon."), a3, a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 8));
    return 0;
  }
  os_unfair_lock_lock_with_options();
  if (dword_1ECCFAFE8 >= 1024)
  {
    CFLog(4, (uint64_t)CFSTR("*** CoreFoundation class table full; registration failing for class '%s'.  Program will crash soon."),
      v9,
      v10,
      v11,
      v12,
      v13,
      v14,
      *(_QWORD *)(a1 + 8));
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
    return 0;
  }
  v15 = dword_1ECCFAFE8;
  v16 = (uint64_t)dword_1ECCFAFE8 >> 6;
  v17 = (_QWORD *)__CFRuntimeClassTables[dword_1ECCFAFE8 >> 6];
  if (!v17)
  {
    v17 = malloc_type_calloc(0x40uLL, 8uLL, 0x2004093837F09uLL);
    v18 = malloc_type_calloc(0x40uLL, 8uLL, 0x100004000313F17uLL);
    __dmb(0xBu);
    v19 = &__CFRuntimeClassTables[v16];
    *v19 = v17;
    v19[16] = v18;
    if (!v17)
      _CFRuntimeRegisterClass_cold_1();
  }
  v20 = v15 + 72;
  v17[v15 & 0x3F] = a1;
  *(_QWORD *)(__CFRuntimeClassTables[v16 + 16] + 8 * (v15 & 0x3F)) = qword_1ECCFACA0;
  do
    v21 = __ldxr((unsigned int *)&dword_1ECCFAFE8);
  while (__stxr(v21 + 1, (unsigned int *)&dword_1ECCFAFE8));
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
  return v20;
}

unint64_t *_CFURLCreateCopyAppendingPathComponent(__objc2_class **a1, const __CFString *a2, int a3)
{
  return __CFURLCreateCopyAppendingPathComponent(0, a1, a2, a3, CFSTR(";?/"));
}

CFRange CFURLGetByteRangeForComponent(CFURLRef url, CFURLComponentType component, CFRange *rangeIncludingSeparators)
{
  CFURLRef v5;
  uint64_t v6;
  CFIndex v7;
  CFIndex v8;
  uint64_t v9;
  unint64_t v10;
  CFIndex v11;
  BOOL v12;
  CFIndex *v13;
  unint64_t v14;
  BOOL v15;
  CFIndex v16;
  CFIndex v17;
  CFIndex v18;
  const __CFString *v19;
  CFIndex Length;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CFIndex v25;
  const __CFString *v26;
  CFIndex v27;
  CFIndex v28;
  CFIndex location;
  const __CFString *v30;
  const __CFString *v31;
  const __CFString *v32;
  const __CFString *v33;
  const __CFString *v34;
  CFIndex v35;
  const __CFString *v36;
  CFIndex v37;
  CFIndex v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  char v44;
  CFIndex v45;
  CFIndex v46;
  CFIndex v47[2];
  CFRange result;
  CFRange v49;
  CFRange v50;
  CFRange v51;
  CFRange v52;
  CFRange v53;
  CFRange v54;
  CFRange v55;

  v5 = url;
  v47[1] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
    v5 = (CFURLRef)-[__CFURL _cfurl](v5, "_cfurl");
  v46 = 0;
  v47[0] = 0;
  v6 = *((unsigned int *)v5 + 4);
  if ((v6 & 0x4000) == 0)
  {
    if (component == kCFURLComponentResourceSpecifier)
    {
      if ((v6 & 1) != 0)
        v17 = *((_QWORD *)v5 + 8);
      else
        v17 = 0;
      v19 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      Length = CFStringGetLength(v19);
      if (v17 + 1 == Length)
        v11 = Length;
      else
        v11 = v17;
      if (v17 + 1 == Length)
        v18 = 0;
      else
        v18 = Length - v17;
      if (v17 + 1 == Length)
        v7 = 0;
      else
        v7 = Length - v17 - 1;
      if (v17 + 1 == Length)
        v8 = -1;
      else
        v8 = v17 + 1;
      goto LABEL_60;
    }
    if (component == kCFURLComponentScheme)
    {
      if ((v6 & 1) != 0)
      {
        v8 = *((_QWORD *)v5 + 7);
        v7 = *((_QWORD *)v5 + 8);
      }
      else
      {
        v7 = 0;
        v8 = -1;
      }
      v11 = 0;
      v18 = v7 + 1;
      goto LABEL_60;
    }
    v18 = 0;
    v7 = 0;
    v11 = -1;
    goto LABEL_29;
  }
  v9 = component - 1;
  if ((unint64_t)(component - 1) > 0xB || ((0xDFFu >> v9) & 1) == 0)
    goto LABEL_83;
  v10 = qword_182CF9688[v9];
  if ((v10 & v6) == 0)
  {
    if (component == kCFURLComponentScheme || component == kCFURLComponentParameterString)
      goto LABEL_56;
    v21 = 0;
    v22 = 1;
    do
    {
      if ((v22 & v6) != 0)
        v21 = v22;
      if (2 * v22 > 256)
        break;
      v23 = v10 & (2 * v22);
      v22 *= 2;
    }
    while (!v23);
    if (!v21)
    {
LABEL_56:
      if (!rangeIncludingSeparators)
      {
        v7 = 0;
        goto LABEL_76;
      }
      v11 = 0;
      v18 = 0;
      v7 = 0;
      v25 = 0;
      v8 = -1;
LABEL_63:
      v26 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      v49.location = 0;
      v49.length = v11;
      CFStringGetBytes(v26, v49, *((_DWORD *)v5 + 5), 0, 0, 0, 0, &rangeIncludingSeparators->location);
      if (v8 == -1)
      {
        v46 = -1;
        v47[0] = v25;
        v32 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
        v52.location = v11;
        v52.length = v18;
        CFStringGetBytes(v32, v52, *((_DWORD *)v5 + 5), 0, 0, 0, 0, &rangeIncludingSeparators->length);
      }
      else
      {
        v27 = v25 + v8;
        v28 = v18 + v11;
        if (v8 == v11)
        {
          location = rangeIncludingSeparators->location;
        }
        else
        {
          v45 = 0;
          v33 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
          v53.location = v11;
          v53.length = v8 - v11;
          CFStringGetBytes(v33, v53, *((_DWORD *)v5 + 5), 0, 0, 0, 0, &v45);
          location = v45 + v11;
        }
        v46 = location;
        v34 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
        v54.location = v8;
        v54.length = v7;
        CFStringGetBytes(v34, v54, *((_DWORD *)v5 + 5), 0, 0, 0, 0, v47);
        if (v28 == v27)
        {
          v35 = v47[0] + v46;
        }
        else
        {
          v45 = 0;
          v36 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
          v55.location = v27;
          v55.length = v28 - v27;
          CFStringGetBytes(v36, v55, *((_DWORD *)v5 + 5), 0, 0, 0, 0, &v45);
          v35 = v47[0] + v46 + v45;
        }
        rangeIncludingSeparators->length = v35 - rangeIncludingSeparators->location;
      }
LABEL_77:
      v37 = v46;
      v38 = v47[0];
      goto LABEL_98;
    }
    if (v21 == 1)
    {
      if ((v6 & 1) != 0)
        v24 = *((_QWORD *)v5 + 8);
      else
        v24 = 0;
      if ((v6 & 0x20) != 0)
      {
        v42 = 0;
        v43 = 32;
        do
        {
          v44 = v43;
          v43 >>= 1;
          v42 += v6 & 1;
          LODWORD(v6) = v6 >> 1;
        }
        while ((v44 & 2) == 0);
        v41 = *((_QWORD *)v5 + 2 * v42 + 7);
      }
      else
      {
        v41 = -1;
      }
      v18 = 0;
      v7 = 0;
      if (v24 + 1 == v41)
        v11 = v24 + 1;
      else
        v11 = v24 + 3;
    }
    else
    {
      if ((v6 & v21) == 0)
        goto LABEL_83;
      if ((v21 & 1) != 0)
      {
        v39 = 0;
      }
      else
      {
        LODWORD(v39) = 0;
        do
        {
          v40 = v21;
          LODWORD(v21) = v21 >> 1;
          v39 = (v6 & 1) + v39;
          LODWORD(v6) = v6 >> 1;
        }
        while ((v40 & 2) == 0);
      }
      v18 = 0;
      v7 = 0;
      v11 = *((_QWORD *)v5 + 2 * v39 + 8) + *((_QWORD *)v5 + 2 * v39 + 7);
    }
LABEL_29:
    v8 = -1;
    goto LABEL_60;
  }
  v11 = 0;
  v12 = 0;
  v7 = 0;
  v13 = (CFIndex *)((char *)v5 + 56);
  v8 = -1;
  v14 = 1;
  while (v12)
  {
    if ((v14 & v6) != 0)
      goto LABEL_17;
    v12 = 1;
LABEL_23:
    v15 = v14 >= 0x81;
    v14 *= 2;
    if (v15)
      goto LABEL_25;
  }
  v12 = (v14 & v10) != 0;
  if ((v14 & v6) == 0)
    goto LABEL_23;
  if ((v14 & v10) == 0)
  {
    v12 = 0;
    v11 = v13[1] + *v13;
LABEL_22:
    v13 += 2;
    goto LABEL_23;
  }
LABEL_17:
  if (v14 <= v10)
  {
    if (v8 == -1)
    {
      v7 = v13[1];
      v12 = 1;
      v8 = *v13;
    }
    else
    {
      v7 = *v13 - v8 + v13[1];
      v12 = 1;
    }
    goto LABEL_22;
  }
  v16 = *v13;
  if (*v13 == -1)
LABEL_25:
    v16 = v7 + v8;
  v18 = v16 - v11;
LABEL_60:
  if (v11 != -1)
  {
    if (rangeIncludingSeparators)
    {
      v25 = v7;
      goto LABEL_63;
    }
    if (v8 != -1)
    {
      v30 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      v50.location = 0;
      v50.length = v8;
      CFStringGetBytes(v30, v50, *((_DWORD *)v5 + 5), 0, 0, 0, 0, &v46);
      v31 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
      v51.location = v8;
      v51.length = v7;
      CFStringGetBytes(v31, v51, *((_DWORD *)v5 + 5), 0, 0, 0, 0, v47);
      goto LABEL_77;
    }
LABEL_76:
    v46 = -1;
    v47[0] = v7;
    goto LABEL_77;
  }
LABEL_83:
  v38 = 0;
  if (rangeIncludingSeparators)
    *rangeIncludingSeparators = (CFRange)xmmword_182C87F40;
  v37 = -1;
LABEL_98:
  result.length = v38;
  result.location = v37;
  return result;
}

CFPlugInRef CFPlugInCreate(CFAllocatorRef allocator, CFURLRef plugInURL)
{
  __CFBundle *v2;
  int32_t v4;
  int32_t v5;

  v2 = CFBundleCreate(allocator, plugInURL);
  if (!atomic_load(CFPlugInCreate_checkedLinkage))
  {
    v4 = NSVersionOfLinkTimeLibrary("System");
    v5 = NSVersionOfLinkTimeLibrary("CoreFoundation");
    if (v4 == -1 && v5 == -1 || v5 != -1 && v5 < 24576000 || v4 != -1 && v4 < 5832704)
      atomic_store(1u, CFPlugInCreate_doDynamicRegistrationAtCreateTime);
    atomic_store(1u, CFPlugInCreate_checkedLinkage);
  }
  if (v2)
  {
    if (atomic_load(CFPlugInCreate_doDynamicRegistrationAtCreateTime))
    {
      if (*(_BYTE *)__CFBundleGetPlugInData((uint64_t)v2)
        && *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)v2) + 3)
        && !CFBundleIsExecutableLoaded(v2))
      {
        CFBundleLoadExecutable(v2);
      }
    }
  }
  return v2;
}

const __CFDictionary *_CFCopyVersionDictionary(CFStringRef filePath)
{
  const __CFURL *v1;
  const __CFURL *v2;
  const __CFDictionary *v3;
  CFStringRef v4;
  CFStringRef v5;
  const void *Value;
  const __CFString *v7;
  const void *v8;
  const void *v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  CFStringRef Copy;
  CFStringRef StringWithValidatedFormat;
  CFStringRef v15;
  void *v16;
  const void *v17;
  const __CFString *format;
  CFTypeRef cf;
  CFDataRef resourceData[2];

  resourceData[1] = *(CFDataRef *)MEMORY[0x1E0C80C00];
  v1 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, filePath, kCFURLPOSIXPathStyle, 0);
  if (!v1)
    return 0;
  v2 = v1;
  resourceData[0] = 0;
  if (!CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, resourceData, 0, 0, 0))
  {
    CFRelease(v2);
    return 0;
  }
  v3 = (const __CFDictionary *)CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, resourceData[0], 1uLL, 0, 0);
  CFRelease(resourceData[0]);
  CFRelease(v2);
  if (v3)
  {
    cf = 0;
    v4 = _CFCopyLocalizedVersionKey((CFBundleRef *)&cf, CFSTR("Version"));
    v5 = _CFCopyLocalizedVersionKey((CFBundleRef *)&cf, CFSTR("Build"));
    format = _CFCopyLocalizedVersionKey((CFBundleRef *)&cf, CFSTR("FullVersionString"));
    if (cf)
      CFRelease(cf);
    Value = CFDictionaryGetValue(v3, CFSTR("ProductBuildVersionOverride"));
    if (Value)
      CFDictionarySetValue(v3, CFSTR("ProductBuildVersion"), Value);
    v7 = (const __CFString *)CFDictionaryGetValue(v3, CFSTR("ProductVersion"));
    v8 = CFDictionaryGetValue(v3, CFSTR("ProductVersionExtra"));
    v9 = v8;
    if (v7 && v8)
      v7 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@ %@"), v7, v8);
    v10 = (const __CFString *)CFDictionaryGetValue(v3, CFSTR("ProductBuildVersion"));
    v11 = CFSTR("?");
    if (v7)
      v12 = v7;
    else
      v12 = CFSTR("?");
    Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
    if (v10)
      v11 = v10;
    StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@ %@"), format, 0, v12, v11);
    v15 = StringWithValidatedFormat;
    if (StringWithValidatedFormat && !CFEqual(StringWithValidatedFormat, CFSTR("FullVersionString")))
      v16 = (void *)CFRetain(v15);
    else
      v16 = (void *)CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@ %@ (%@ %@)"), v4, v12, v5, v11);
    v17 = v16;
    if (v7 && v9)
      CFRelease(v7);
    if (v15)
      CFRelease(v15);
    CFDictionarySetValue(v3, CFSTR("Version"), v4);
    CFDictionarySetValue(v3, CFSTR("Build"), v5);
    CFDictionarySetValue(v3, CFSTR("FullVersionString"), v17);
    CFDictionarySetValue(v3, CFSTR("ShortVersionString"), Copy);
    CFRelease(v4);
    CFRelease(v5);
    CFRelease(format);
    CFRelease(v17);
    CFRelease(Copy);
  }
  return v3;
}

CFStringRef _CFCopyLocalizedVersionKey(CFBundleRef *a1, CFStringRef key)
{
  __CFBundle *v4;
  CFStringRef v5;
  const __CFString *Copy;
  const __CFURL *v7;

  if (a1 && (v4 = *a1) != 0)
  {
    v5 = CFBundleCopyLocalizedString(*a1, key, key, CFSTR("SystemVersion"));
  }
  else
  {
    Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("/System/Library/CoreServices/SystemVersion.bundle"));
    v7 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, Copy, kCFURLPOSIXPathStyle, 0);
    CFRelease(Copy);
    if (!v7)
      return (CFStringRef)CFRetain(key);
    v4 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
    CFRelease(v7);
    if (!v4)
      return (CFStringRef)CFRetain(key);
    v5 = CFBundleCopyLocalizedString(v4, key, key, CFSTR("SystemVersion"));
    if (!a1)
    {
      CFRelease(v4);
      if (v5)
        return v5;
      return (CFStringRef)CFRetain(key);
    }
  }
  *a1 = v4;
  if (v5)
    return v5;
  return (CFStringRef)CFRetain(key);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  CFBundleRef MainBundle;
  CFBundleRef v5;
  const void *v6;

  if (!bundleURL)
    return 0;
  MainBundle = CFBundleGetMainBundle();
  if (!MainBundle)
    return (CFBundleRef)_CFBundleCreate(allocator, bundleURL, 0, 0);
  v5 = MainBundle;
  v6 = (const void *)*((_QWORD *)MainBundle + 2);
  if (!v6 || !CFEqual(v6, bundleURL))
    return (CFBundleRef)_CFBundleCreate(allocator, bundleURL, 0, 0);
  CFRetain(v5);
  return v5;
}

CFStringRef CFStringCreateStringWithValidatedFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef validFormatSpecifiers, CFStringRef format, CFErrorRef *errorPtr, ...)
{
  return _CFStringCreateStringWithValidatedFormatAux(alloc, (uint64_t)formatOptions, 0, (uint64_t)validFormatSpecifiers);
}

CFStringRef _CFStringCreateStringWithValidatedFormatAux(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFMutableStringRef Mutable;
  CFStringRef Copy;

  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  Mutable[1].info = Mutable[1].info & 0xF | 0x780;
  if (__CFStringAppendFormatCore(Mutable, 0, 0, a2, 0, a3, a4))
    Copy = CFStringCreateCopy(a1, Mutable);
  else
    Copy = 0;
  CFRelease(Mutable);
  return Copy;
}

uint64_t decomposeToRFC1808(uint64_t a1, const __CFString **a2)
{
  const __CFAllocator *v4;
  int v5;
  uint64_t v6;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  uint64_t v12;

  v4 = CFGetAllocator((CFTypeRef)a1);
  v5 = CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1);
  v6 = a1;
  if (v5)
    v6 = objc_msgSend((id)a1, "_cfurl");
  if ((*(_BYTE *)(v6 + 17) & 0x40) == 0)
    return 0;
  v8 = CFURLCopyPath((CFURLRef)a1);
  if (v8)
  {
    v9 = v8;
    a2[5] = (const __CFString *)CFStringCreateArrayBySeparatingStrings(v4, v8, CFSTR("/"));
    CFRelease(v9);
  }
  else
  {
    a2[5] = 0;
  }
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1))
    v10 = (const __CFString *)objc_msgSend((id)a1, "baseURL");
  else
    v10 = *(const __CFString **)(a1 + 32);
  a2[9] = v10;
  if (v10)
  {
    CFRetain(v10);
    v11 = 0;
  }
  else
  {
    v11 = _retainedComponentString(a1, 1, 1, 0);
  }
  *a2 = v11;
  a2[1] = _retainedComponentString(a1, 2, 0, 0);
  a2[2] = _retainedComponentString(a1, 4, 0, 0);
  a2[3] = _retainedComponentString(a1, 8, 0, 0);
  if ((*(_BYTE *)(a1 + 16) & 0x10) != 0)
    v12 = CFURLGetPortNumber((CFURLRef)a1);
  else
    v12 = -1;
  a2[4] = (const __CFString *)v12;
  a2[6] = 0;
  a2[7] = _retainedComponentString(a1, 128, 0, 0);
  a2[8] = _retainedComponentString(a1, 256, 0, 0);
  return 1;
}

uint64_t _CFPreferencesGetAppIntegerValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, BOOL *a4)
{
  const __CFNumber *v5;
  const __CFNumber *v6;
  CFTypeID v7;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v10;
  _BOOL4 v11;
  uint64_t v12;
  uint64_t result;
  int IsFloatType;
  uint64_t v15;
  uint64_t valuePtr;
  UniChar buffer[8];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  const __CFNumber *v25;
  const UniChar *v26;
  const char *v27;
  uint64_t v28;
  CFIndex Length;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v5 = (const __CFNumber *)_CFPreferencesCopyAppValueWithContainerAndConfiguration(a1, a2, a3, 0);
  if (v5)
  {
    v6 = v5;
    valuePtr = 0;
    v7 = CFGetTypeID(v5);
    if (v7 == 22)
    {
      IsFloatType = CFNumberIsFloatType(v6);
      if (a4)
        *a4 = IsFloatType == 0;
      CFNumberGetValue(v6, kCFNumberCFIndexType, &valuePtr);
      goto LABEL_22;
    }
    if (v7 != 7)
    {
      if (v7 != CFBooleanGetTypeID())
      {
        valuePtr = 0;
        if (a4)
          *a4 = 0;
        goto LABEL_22;
      }
      if (a4)
        *a4 = 1;
      v12 = v6 == (const __CFNumber *)&__kCFBooleanTrue;
LABEL_21:
      valuePtr = v12;
LABEL_22:
      CFRelease(v6);
      return valuePtr;
    }
    v15 = 0;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    *(_OWORD *)buffer = 0u;
    v18 = 0u;
    v25 = v6;
    v28 = 0;
    Length = CFStringGetLength((CFStringRef)v6);
    CharactersPtr = CFStringGetCharactersPtr((CFStringRef)v6);
    CStringPtr = 0;
    v26 = CharactersPtr;
    if (!CharactersPtr)
      CStringPtr = CFStringGetCStringPtr((CFStringRef)v6, 0x600u);
    v30 = 0;
    v31 = 0;
    v27 = CStringPtr;
    if (__CFStringScanInteger(buffer, 0, (int *)&v15 + 1, 0, &v15))
    {
      v10 = SHIDWORD(v15);
      v11 = CFStringGetLength((CFStringRef)v6) == v10;
      if (!a4)
        goto LABEL_9;
    }
    else
    {
      v11 = 0;
      if (!a4)
      {
LABEL_9:
        if (v11)
          v12 = (int)v15;
        else
          v12 = 0;
        goto LABEL_21;
      }
    }
    *a4 = v11;
    goto LABEL_9;
  }
  result = 0;
  if (a4)
    *a4 = 0;
  return result;
}

SInt32 CFURLGetPortNumber(CFURLRef anURL)
{
  const __CFString *v2;
  char v3;
  const __CFNumber *v4;
  const __CFString *v6;
  int Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  int v10;
  _DWORD v11[49];

  *(_QWORD *)&v11[47] = *MEMORY[0x1E0C80C00];
  while (1)
  {
    if (!anURL)
      CFURLGetPortNumber_cold_1();
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
      break;
    v2 = _retainedComponentString((uint64_t)anURL, 16, 1, 0);
    if (v2)
    {
      v6 = v2;
      memset(v11, 0, 132);
      Length = CFStringGetLength(v2);
      *(_QWORD *)&v11[33] = v6;
      *(_QWORD *)&v11[39] = 0;
      *(_QWORD *)&v11[41] = Length;
      CharactersPtr = CFStringGetCharactersPtr(v6);
      CStringPtr = 0;
      *(_QWORD *)&v11[35] = CharactersPtr;
      if (!CharactersPtr)
        CStringPtr = CFStringGetCStringPtr(v6, 0x600u);
      *(_QWORD *)&v11[43] = 0;
      *(_QWORD *)&v11[45] = 0;
      *(_QWORD *)&v11[37] = CStringPtr;
      v10 = 0;
      if (!__CFStringScanInteger((UniChar *)&v11[1], 0, &v10, 0, (uint64_t *)v11) || v10 != Length)
        v11[0] = -1;
      CFRelease(v6);
      return v11[0];
    }
    if (*((_QWORD *)anURL + 4))
    {
      v3 = *((_BYTE *)anURL + 16);
      anURL = (CFURLRef)*((_QWORD *)anURL + 4);
      if ((v3 & 0x1F) == 0)
        continue;
    }
    return -1;
  }
  v4 = (const __CFNumber *)-[__CFURL port](anURL, "port");
  v11[1] = 0;
  if (!v4)
    return -1;
  if (CFNumberGetValue(v4, kCFNumberSInt32Type, &v11[1]))
    return v11[1];
  else
    return -1;
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  const UniChar *CharactersPtr;
  uint64_t CStringPtrInternal;
  int v5;
  SInt32 v6;
  UniChar buffer[8];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  CFStringRef v15;
  const UniChar *v16;
  uint64_t v17;
  uint64_t v18;
  CFIndex Length;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v15 = str;
  v18 = 0;
  Length = CFStringGetLength(str);
  CharactersPtr = CFStringGetCharactersPtr(v15);
  CStringPtrInternal = 0;
  v16 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtrInternal = _CFStringGetCStringPtrInternal((uint64_t)str, 0x600u, 0, 1);
  v6 = 0;
  *(_OWORD *)buffer = 0u;
  v8 = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v20 = 0;
  v21 = 0;
  v17 = CStringPtrInternal;
  if (__CFStringScanInteger(buffer, 0, &v5, 0, (uint64_t *)&v6))
    return v6;
  else
    return 0;
}

uint64_t __CFStringScanInteger(UniChar *buffer, uint64_t a2, int *a3, int a4, uint64_t *a5)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  UniChar v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  UniChar v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int16 v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  int v65;
  CFRange v66;
  CFRange v67;
  CFRange v68;
  CFRange v69;
  CFRange v70;
  CFRange v71;

  v9 = *a3;
  if ((*a3 & 0x80000000) == 0)
    goto LABEL_4;
LABEL_17:
  v13 = -1;
  while (v13 == 12288
       || (unsigned __int16)(v13 - 0x2000) < 0xCu
       || v13 < 0x21u
       || (unsigned __int16)(v13 - 127) <= 0x21u)
  {
    v9 = *a3 + 1;
    *a3 = v9;
    if (v9 < 0)
      goto LABEL_17;
LABEL_4:
    v10 = v9;
    v11 = *((_QWORD *)buffer + 20);
    if (v11 <= v10)
      goto LABEL_17;
    v12 = *((_QWORD *)buffer + 17);
    if (v12)
    {
      v13 = *(_WORD *)(v12 + 2 * (*((_QWORD *)buffer + 19) + v10));
    }
    else
    {
      v14 = *((_QWORD *)buffer + 18);
      if (v14)
      {
        v13 = *(char *)(v14 + *((_QWORD *)buffer + 19) + v10);
      }
      else
      {
        if (*((_QWORD *)buffer + 22) <= v10 || (v15 = *((_QWORD *)buffer + 21), v15 > v10))
        {
          v16 = v10 - 4;
          if (v10 < 4)
            v16 = 0;
          if (v16 + 64 < v11)
            v11 = v16 + 64;
          *((_QWORD *)buffer + 21) = v16;
          *((_QWORD *)buffer + 22) = v11;
          v66.location = *((_QWORD *)buffer + 19) + v16;
          v66.length = v11 - v16;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v66, buffer);
          v15 = *((_QWORD *)buffer + 21);
        }
        v13 = buffer[v10 - v15];
      }
    }
  }
  if (v13 == 45 || v13 == 43)
  {
    do
    {
      v23 = *a3;
      v24 = v23 + 1;
      *a3 = v23 + 1;
      if ((int)v23 < -1 || (v22 = *((_QWORD *)buffer + 20), v22 <= v24))
      {
        v19 = -1;
      }
      else
      {
        v25 = *((_QWORD *)buffer + 17);
        if (v25)
        {
          v19 = *(_WORD *)(v25 + 2 * (*((_QWORD *)buffer + 19) + v24));
        }
        else
        {
          v18 = *((_QWORD *)buffer + 18);
          if (v18)
          {
            v19 = *(char *)(v18 + *((_QWORD *)buffer + 19) + v24);
          }
          else
          {
            if (*((_QWORD *)buffer + 22) <= v24 || (v20 = *((_QWORD *)buffer + 21), v20 > v24))
            {
              v21 = v24 - 4;
              if (v24 < 4)
                v21 = 0;
              if (v21 + 64 < v22)
                v22 = v21 + 64;
              *((_QWORD *)buffer + 21) = v21;
              *((_QWORD *)buffer + 22) = v22;
              v67.location = *((_QWORD *)buffer + 19) + v21;
              v67.length = v22 - v21;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v67, buffer);
              v20 = *((_QWORD *)buffer + 21);
            }
            v19 = buffer[v24 - v20];
          }
        }
      }
    }
    while (v19 == 12288
         || (unsigned __int16)(v19 - 0x2000) < 0xCu
         || v19 < 0x21u
         || (unsigned __int16)(v19 - 127) < 0x22u);
    v17 = v13 == 45;
    v13 = v19;
  }
  else
  {
    v17 = 0;
  }
  if ((unsigned __int16)(v13 - 58) < 0xFFF6u)
    return 0;
  v65 = a4;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  while (1)
  {
    if (v27)
    {
      if (v29 > 0xCCCCCCCCCCCCCCBLL && (v29 != 0xCCCCCCCCCCCCCCCLL || v13 - v17 - 48 >= 7))
      {
        if (v17)
          v29 = 0x8000000000000000;
        else
          v29 = 0x7FFFFFFFFFFFFFFFLL;
        while (1)
        {
          v30 = *a3;
          v31 = v30 + 1;
          *a3 = v30 + 1;
          if ((int)v30 < -1)
            break;
          v32 = *((_QWORD *)buffer + 20);
          if (v32 <= v31)
            break;
          v33 = *((_QWORD *)buffer + 17);
          if (v33)
          {
            v13 = *(_WORD *)(v33 + 2 * (*((_QWORD *)buffer + 19) + v31));
          }
          else
          {
            v34 = *((_QWORD *)buffer + 18);
            if (v34)
            {
              v13 = *(char *)(v34 + *((_QWORD *)buffer + 19) + v31);
            }
            else
            {
              if (*((_QWORD *)buffer + 22) <= v31 || (v35 = *((_QWORD *)buffer + 21), v35 > v31))
              {
                v36 = v31 - 4;
                if (v31 < 4)
                  v36 = 0;
                if (v36 + 64 < v32)
                  v32 = v36 + 64;
                *((_QWORD *)buffer + 21) = v36;
                *((_QWORD *)buffer + 22) = v32;
                v68.location = *((_QWORD *)buffer + 19) + v36;
                v68.length = v32 - v36;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v68, buffer);
                v35 = *((_QWORD *)buffer + 21);
              }
              v13 = buffer[v31 - v35];
            }
          }
          if ((unsigned __int16)(v13 - 58) < 0xFFF6u)
          {
            v37 = 0;
            v17 = 0;
            goto LABEL_122;
          }
        }
        v17 = 0;
LABEL_135:
        v37 = 0;
LABEL_136:
        if (!a5)
          return 1;
        goto LABEL_137;
      }
      v29 = 10 * v29 + v13 - 48;
      v38 = *a3;
      v39 = v38 + 1;
      *a3 = v38 + 1;
      if ((int)v38 < -1)
        goto LABEL_135;
      v40 = *((_QWORD *)buffer + 20);
      if (v40 <= v39)
        goto LABEL_135;
      v41 = *((_QWORD *)buffer + 17);
      if (v41)
      {
        v37 = 0;
        v13 = *(_WORD *)(v41 + 2 * (*((_QWORD *)buffer + 19) + v39));
      }
      else
      {
        v50 = *((_QWORD *)buffer + 18);
        if (v50)
        {
          v37 = 0;
          v13 = *(char *)(v50 + *((_QWORD *)buffer + 19) + v39);
        }
        else
        {
          if (*((_QWORD *)buffer + 22) <= v39 || (v59 = *((_QWORD *)buffer + 21), v59 > v39))
          {
            v60 = v39 - 4;
            if (v39 < 4)
              v60 = 0;
            if (v60 + 64 < v40)
              v40 = v60 + 64;
            *((_QWORD *)buffer + 21) = v60;
            *((_QWORD *)buffer + 22) = v40;
            v70.location = *((_QWORD *)buffer + 19) + v60;
            v70.length = v40 - v60;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v70, buffer);
            v59 = *((_QWORD *)buffer + 21);
          }
          v37 = 0;
          v13 = buffer[v39 - v59];
        }
      }
      goto LABEL_122;
    }
    if (v28 > 214748363)
      break;
    v42 = v13 - 48;
    v43 = v13 - 48;
LABEL_84:
    if (v42 >= 0xAu)
      v45 = -1;
    else
      v45 = v43;
    v28 = v45 + 10 * v28;
    v46 = *a3;
    v47 = v46 + 1;
    *a3 = v46 + 1;
    if ((int)v46 < -1)
      goto LABEL_149;
    v48 = *((_QWORD *)buffer + 20);
    if (v48 <= v47)
      goto LABEL_149;
    v49 = *((_QWORD *)buffer + 17);
    if (v49)
    {
      v27 = 0;
      v13 = *(_WORD *)(v49 + 2 * (*((_QWORD *)buffer + 19) + v47));
    }
    else
    {
      v51 = *((_QWORD *)buffer + 18);
      if (v51)
      {
        v27 = 0;
        v13 = *(char *)(v51 + *((_QWORD *)buffer + 19) + v47);
      }
      else
      {
        if (*((_QWORD *)buffer + 22) <= v47 || (v61 = *((_QWORD *)buffer + 21), v61 > v47))
        {
          v62 = v47 - 4;
          if (v47 < 4)
            v62 = 0;
          if (v62 + 64 < v48)
            v48 = v62 + 64;
          *((_QWORD *)buffer + 21) = v62;
          *((_QWORD *)buffer + 22) = v48;
          v71.location = *((_QWORD *)buffer + 19) + v62;
          v71.length = v48 - v62;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v71, buffer);
          v61 = *((_QWORD *)buffer + 21);
        }
        v27 = 0;
        v13 = buffer[v47 - v61];
      }
    }
    v37 = 1;
LABEL_132:
    if ((unsigned __int16)(v13 - 58) <= 0xFFF5u)
      goto LABEL_136;
  }
  if (v28 == 214748364)
  {
    v42 = v13 - 48;
    v43 = v13 - 48;
    v44 = (unsigned __int16)(v13 - 48) >= 0xAu ? -1 : v13 - 48;
    if (v44 - v17 < 7)
      goto LABEL_84;
  }
  if (v65)
  {
    v37 = 0;
    v29 = v28;
LABEL_122:
    v27 = 1;
    goto LABEL_132;
  }
  if (v17)
    v28 = 0x80000000;
  else
    v28 = 0x7FFFFFFF;
  while (1)
  {
    v52 = *a3;
    v53 = v52 + 1;
    *a3 = v52 + 1;
    if ((int)v52 < -1)
      break;
    v54 = *((_QWORD *)buffer + 20);
    if (v54 <= v53)
      break;
    v55 = *((_QWORD *)buffer + 17);
    if (v55)
    {
      v13 = *(_WORD *)(v55 + 2 * (*((_QWORD *)buffer + 19) + v53));
    }
    else
    {
      v56 = *((_QWORD *)buffer + 18);
      if (v56)
      {
        v13 = *(char *)(v56 + *((_QWORD *)buffer + 19) + v53);
      }
      else
      {
        if (*((_QWORD *)buffer + 22) <= v53 || (v57 = *((_QWORD *)buffer + 21), v57 > v53))
        {
          v58 = v53 - 4;
          if (v53 < 4)
            v58 = 0;
          if (v58 + 64 < v54)
            v54 = v58 + 64;
          *((_QWORD *)buffer + 21) = v58;
          *((_QWORD *)buffer + 22) = v54;
          v69.location = *((_QWORD *)buffer + 19) + v58;
          v69.length = v54 - v58;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v69, buffer);
          v57 = *((_QWORD *)buffer + 21);
        }
        v13 = buffer[v53 - v57];
      }
    }
    v37 = 1;
    if ((unsigned __int16)(v13 - 58) < 0xFFF6u)
    {
      v27 = 0;
      v17 = 0;
      goto LABEL_132;
    }
  }
  v17 = 0;
LABEL_149:
  v37 = 1;
  if (!a5)
    return 1;
LABEL_137:
  if (v65)
  {
    if (v37)
      v63 = v28;
    else
      v63 = v29;
    if (v17)
      v63 = -v63;
    *a5 = v63;
  }
  else
  {
    if (v17)
      v64 = -v28;
    else
      v64 = v28;
    *(_DWORD *)a5 = v64;
  }
  return 1;
}

const void *_CFCopySystemVersionDictionaryValue(const void *a1)
{
  const __CFDictionary *v2;
  const void *Value;
  const void *v4;

  v2 = (const __CFDictionary *)_CFCopyServerVersionDictionary();
  if (!v2)
  {
    v2 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
    if (!v2)
      return 0;
  }
  Value = CFDictionaryGetValue(v2, a1);
  v4 = Value;
  if (Value)
    CFRetain(Value);
  CFRelease(v2);
  return v4;
}

CFTypeRef _CFCopySystemVersionDictionary()
{
  CFTypeRef result;

  if (_CFCopySystemVersionDictionary_onceToken != -1)
    dispatch_once(&_CFCopySystemVersionDictionary_onceToken, &__block_literal_global_16);
  result = (CFTypeRef)_CFCopySystemVersionDictionary_result;
  if (_CFCopySystemVersionDictionary_result)
    return CFRetain((CFTypeRef)_CFCopySystemVersionDictionary_result);
  return result;
}

CFTypeRef _CFCopyServerVersionDictionary()
{
  CFTypeRef result;

  if (_CFCopyServerVersionDictionary_onceToken != -1)
    dispatch_once(&_CFCopyServerVersionDictionary_onceToken, &__block_literal_global_24);
  result = (CFTypeRef)_CFCopyServerVersionDictionary_result;
  if (_CFCopyServerVersionDictionary_result)
    return CFRetain((CFTypeRef)_CFCopyServerVersionDictionary_result);
  return result;
}

void CFURLGetPortNumber_cold_1()
{
  __assert_rtn("CFURLGetPortNumber", "CFURL.c", 3642, "anURL");
}

Boolean CFFileSecurityGetOwner(CFFileSecurityRef fileSec, uid_t *owner)
{
  return -[__CFFileSecurity getOwner:](fileSec, "getOwner:", owner);
}

Boolean CFFileSecurityGetMode(CFFileSecurityRef fileSec, mode_t *mode)
{
  return -[__CFFileSecurity getMode:](fileSec, "getMode:", mode);
}

Boolean CFFileSecurityGetGroup(CFFileSecurityRef fileSec, gid_t *group)
{
  return -[__CFFileSecurity getGroup:](fileSec, "getGroup:", group);
}

void __NSCacheValueRelease(void *cf, uint64_t a2)
{
  void *v4;
  uint64_t v5;

  if (*(_BYTE *)(a2 + 28))
  {
    if (dyld_program_sdk_at_least() && *(_BYTE *)(a2 + 27))
    {
      if (__NSCacheValueRelease_oGuard != -1)
        dispatch_once(&__NSCacheValueRelease_oGuard, &__block_literal_global_120);
      v4 = *(void **)(a2 + 8);
      v5 = __NSCacheValueRelease_oMoribundCache;
    }
    else
    {
      v4 = *(void **)(a2 + 8);
      v5 = a2;
    }
    __NSCacheCallDelegateWillEvictObjectCallbackWithValue(v4, v5, (uint64_t)cf);
  }
  if (*(_BYTE *)(a2 + 24) != 1
    && (objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0
    && (objc_opt_respondsToSelector() & 1) != 0)
  {
    objc_msgSend(cf, "discardContentIfPossible");
  }
  CFRelease(cf);
}

uint64_t __NSCacheCallDelegateWillEvictObjectCallbackWithValue(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  v6 = _CFGetTSD(3u);
  _CFSetTSD(3u, a2, 0);
  objc_msgSend(a1, "cache:willEvictObject:", a2, a3);
  return _CFSetTSD(3u, v6, 0);
}

void sub_182B63AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,id location)
{
  id *v35;

  objc_destroyWeak(v35);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t _canDup()
{
  char v0;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v0 = 1;
  }
  else
  {
    if (_canDup_once != -1)
      dispatch_once(&_canDup_once, &__block_literal_global_326);
    v0 = _canDup_canDup ^ 1;
  }
  return v0 & 1;
}

void _CFPrefsApplyChangesQueueToDictionary(void *a1, __CFDictionary *a2)
{
  size_t count;
  size_t v5;
  char v6;
  size_t v7;
  objc_class *v8;
  const __CFArray *value;
  CFDataRef v10;
  size_t v11;
  xpc_object_t v12;
  const void *v13;
  size_t length;
  const UInt8 *bytes_ptr;
  const __CFData *v16;
  CFTypeID v17;
  NSObject *v18;

  if (!a1)
    _CFPrefsApplyChangesQueueToDictionary_cold_1();
  if (object_getClass(a1) != (Class)MEMORY[0x1E0C812C8])
    _CFPrefsApplyChangesQueueToDictionary_cold_4();
  count = xpc_array_get_count(a1);
  v5 = count;
  if ((count & 1) != 0)
    _CFPrefsApplyChangesQueueToDictionary_cold_3();
  if (count)
  {
    v6 = 0;
    v7 = 0;
    v8 = (objc_class *)MEMORY[0x1E0C812E8];
    while (1)
    {
      value = (const __CFArray *)xpc_array_get_value(a1, v7);
      v10 = _CFXPCCreateCFObjectFromXPCObject(value);
      v11 = v7 + 1;
      v12 = xpc_array_get_value(a1, v11);
      if (object_getClass(v12) == v8)
      {
        length = xpc_data_get_length(v12);
        bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v12);
        v16 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes_ptr, length, (CFAllocatorRef)&__kCFAllocatorNull);
        v13 = CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16, 0, 0, 0);
        CFRelease(v16);
        if (!v10)
          goto LABEL_13;
      }
      else
      {
        v13 = _CFXPCCreateCFObjectFromXPCObject((const __CFArray *)v12);
        if (!v10)
          goto LABEL_13;
      }
      if (v13)
      {
        v17 = CFGetTypeID(v13);
        if (v17 == CFNullGetTypeID())
          CFDictionaryRemoveValue(a2, v10);
        else
          CFDictionarySetValue(a2, v10, v13);
LABEL_19:
        CFRelease(v10);
        if (!v13)
          goto LABEL_16;
LABEL_15:
        CFRelease(v13);
        goto LABEL_16;
      }
LABEL_13:
      v6 = 1;
      if (v10)
        goto LABEL_19;
      if (v13)
        goto LABEL_15;
LABEL_16:
      v7 = v11 + 1;
      if (v7 >= v5)
      {
        if ((v6 & 1) != 0)
        {
          v18 = _CFPrefsDaemonLog();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
            _CFPrefsApplyChangesQueueToDictionary_cold_2();
        }
        return;
      }
    }
  }
}

unint64_t *_CFDataCreateFixedMutableWithBuffer(__objc2_class **a1, unint64_t a2, const UInt8 *a3, const void *a4)
{
  return __CFDataInit(a1, 1, a2, a3, 0, a4);
}

void _registerTypeLocked(const __CFString *a1, const __CFString *cf, const void *a3)
{
  CFTypeID v6;
  int Count;
  CFTypeID v8;
  const void *v9;
  CFIndex i;
  const __CFString *ValueAtIndex;
  CFTypeID v12;
  const __CFAllocator *v13;
  void *v14;
  NSObject *v15;
  CFTypeID v16;
  CFTypeID v17;
  const __CFAllocator *v18;
  void *v19;
  uint8_t buf[4];
  void *v21;
  __int16 v22;
  const void *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v6 = CFGetTypeID(cf);
  if (v6 == CFArrayGetTypeID())
    Count = CFArrayGetCount((CFArrayRef)cf);
  else
    Count = 0;
  v8 = CFGetTypeID(a1);
  if (v8 == CFStringGetTypeID()
    && (v9 = CFUUIDCreateFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1)) != 0)
  {
    if (Count)
      goto LABEL_7;
  }
  else
  {
    v9 = CFRetain(a1);
    if (Count)
    {
LABEL_7:
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, i);
          v12 = CFGetTypeID(ValueAtIndex);
          if (v12 != CFStringGetTypeID()
            || (v13 = CFGetAllocator(a3), (v14 = CFUUIDCreateFromString(v13, ValueAtIndex)) == 0))
          {
            v14 = (void *)CFRetain(ValueAtIndex);
          }
          if (_CFBundlePluginLogger_onceToken != -1)
            dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
          v15 = _CFBundlePluginLogger__log;
          if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138543618;
            v21 = v14;
            v22 = 2114;
            v23 = v9;
            _os_log_debug_impl(&dword_182A8C000, v15, OS_LOG_TYPE_DEBUG, "Registering factory %{public}@ type %{public}@", buf, 0x16u);
          }
          _CFPlugInRegisterPlugInTypeLocked(v14, v9);
          if (v14)
            CFRelease(v14);
        }
      }
      goto LABEL_31;
    }
  }
  v16 = CFGetTypeID(cf);
  if (v16 != CFArrayGetTypeID())
  {
    v17 = CFGetTypeID(cf);
    if (v17 != CFStringGetTypeID() || (v18 = CFGetAllocator(a3), (v19 = CFUUIDCreateFromString(v18, cf)) == 0))
      v19 = (void *)CFRetain(cf);
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
      _registerTypeLocked_cold_1();
    _CFPlugInRegisterPlugInTypeLocked(v19, v9);
    if (v19)
      CFRelease(v19);
  }
LABEL_31:
  if (v9)
    CFRelease(v9);
}

CFUUIDRef CFUUIDCreateFromString(CFAllocatorRef alloc, CFStringRef uuidStr)
{
  CFIndex Length;
  CFIndex v5;
  CFIndex v6;
  int v7;
  CFIndex v9;
  BOOL v10;
  CFIndex v12;
  uint64_t v13;
  unsigned int v14;
  char v15;
  char v16;
  int v17;
  char v18;
  uint64_t v19;
  unsigned int v20;
  char v21;
  char v22;
  int v23;
  char v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  char v28;
  char v29;
  int v30;
  char v31;
  unint64_t v32;
  uint64_t v33;
  unsigned int v34;
  char v35;
  char v36;
  int v37;
  char v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  UniChar *v42;
  char v43;
  char v44;
  int v45;
  char v46;
  uint64_t v47;
  CFIndex v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  char v52;
  int v53;
  char v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  UniChar *v58;
  char v59;
  char v60;
  int v61;
  char v62;
  uint64_t v63;
  CFIndex v64;
  uint64_t v65;
  uint64_t v66;
  char v67;
  char v68;
  int v69;
  char v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  UniChar *v74;
  char v75;
  char v76;
  int v77;
  char v78;
  uint64_t v79;
  CFIndex v80;
  uint64_t v81;
  unsigned int v82;
  char v83;
  char v84;
  int v85;
  char v86;
  uint64_t v87;
  unsigned int v88;
  UniChar *v89;
  char v90;
  char v91;
  int v92;
  char v93;
  CFIndex v94;
  uint64_t v95;
  unsigned int v96;
  char v97;
  char v98;
  int v99;
  char v100;
  uint64_t v101;
  uint64_t v102;
  char v103;
  char v104;
  int v105;
  char v106;
  uint64_t v107;
  uint64_t v108;
  char v109;
  char v110;
  int v111;
  char v112;
  uint64_t v113;
  uint64_t v114;
  char v115;
  char v116;
  int v117;
  char v118;
  uint64_t v119;
  uint64_t v120;
  UniChar *v121;
  char v122;
  char v123;
  int v124;
  char v125;
  UniChar v126[100];
  uint64_t v127;
  CFRange v128;

  v127 = *MEMORY[0x1E0C80C00];
  if (!uuidStr)
    return 0;
  Length = CFStringGetLength(uuidStr);
  if (Length <= 100)
  {
    v5 = Length;
    if (Length)
      goto LABEL_5;
    return 0;
  }
  v5 = 100;
LABEL_5:
  v128.location = 0;
  v128.length = v5;
  CFStringGetCharacters(uuidStr, v128, v126);
  v6 = 0;
  v7 = v126[0];
  if (v126[0] - 48 >= 0xA && v126[0] - 97 >= 6)
  {
    v9 = 0;
    while (v9 < v5 && (v7 - 71) <= 0xFFFFFFF9)
    {
      v7 = v126[v9 + 1];
      v6 = v9 + 1;
      v10 = (v7 - 48) >= 0xA && (v7 - 97) > 5;
      ++v9;
      if (!v10)
        goto LABEL_20;
    }
    v6 = v9;
  }
LABEL_20:
  v12 = v6 + 1;
  if (v6 + 1 >= v5)
  {
    v14 = 0;
    goto LABEL_32;
  }
  v13 = 0;
  LOBYTE(v14) = 0;
  v15 = 1;
  while (1)
  {
    v16 = v15;
    v17 = v126[v6 + v13];
    v18 = v17 - 48;
    if ((v17 - 48) >= 0xA)
      break;
LABEL_27:
    v15 = 0;
    v14 = (v18 | (16 * v14));
    v13 = 1;
    if ((v16 & 1) == 0)
      goto LABEL_31;
  }
  if ((v17 - 97) <= 5)
  {
    v18 = v17 - 87;
    goto LABEL_27;
  }
  if ((v17 - 65) <= 5)
  {
    v18 = v17 - 55;
    goto LABEL_27;
  }
  v14 = 0;
LABEL_31:
  v12 = v6 + 3;
  v6 += 2;
LABEL_32:
  if (v12 >= v5)
  {
    v25 = 0;
    goto LABEL_44;
  }
  v19 = 0;
  LOBYTE(v20) = 0;
  v21 = 1;
  while (2)
  {
    v22 = v21;
    v23 = v126[v6 + v19];
    v24 = v23 - 48;
    if ((v23 - 48) < 0xA)
    {
LABEL_39:
      v21 = 0;
      v20 = (v24 | (16 * v20));
      v19 = 1;
      if ((v22 & 1) == 0)
        goto LABEL_43;
      continue;
    }
    break;
  }
  if ((v23 - 97) <= 5)
  {
    v24 = v23 - 87;
    goto LABEL_39;
  }
  if ((v23 - 65) <= 5)
  {
    v24 = v23 - 55;
    goto LABEL_39;
  }
  v20 = 0;
LABEL_43:
  v12 = v6 + 3;
  v6 += 2;
  v25 = (unint64_t)v20 << 8;
LABEL_44:
  if (v12 >= v5)
  {
    v32 = 0;
    goto LABEL_56;
  }
  v26 = 0;
  LOBYTE(v27) = 0;
  v28 = 1;
  while (2)
  {
    v29 = v28;
    v30 = v126[v6 + v26];
    v31 = v30 - 48;
    if ((v30 - 48) < 0xA)
    {
LABEL_51:
      v28 = 0;
      v27 = (v31 | (16 * v27));
      v26 = 1;
      if ((v29 & 1) == 0)
        goto LABEL_55;
      continue;
    }
    break;
  }
  if ((v30 - 97) <= 5)
  {
    v31 = v30 - 87;
    goto LABEL_51;
  }
  if ((v30 - 65) <= 5)
  {
    v31 = v30 - 55;
    goto LABEL_51;
  }
  v27 = 0;
LABEL_55:
  v12 = v6 + 3;
  v6 += 2;
  v32 = (unint64_t)v27 << 16;
LABEL_56:
  if (v12 >= v5)
  {
    v39 = 0;
    goto LABEL_68;
  }
  v33 = 0;
  LOBYTE(v34) = 0;
  v35 = 1;
  while (2)
  {
    v36 = v35;
    v37 = v126[v6 + v33];
    v38 = v37 - 48;
    if ((v37 - 48) < 0xA)
    {
LABEL_63:
      v35 = 0;
      v34 = (v38 | (16 * v34));
      v33 = 1;
      if ((v36 & 1) == 0)
        goto LABEL_67;
      continue;
    }
    break;
  }
  if ((v37 - 97) <= 5)
  {
    v38 = v37 - 87;
    goto LABEL_63;
  }
  if ((v37 - 65) <= 5)
  {
    v38 = v37 - 55;
    goto LABEL_63;
  }
  v34 = 0;
LABEL_67:
  v12 = v6 + 3;
  v6 += 2;
  v39 = (unint64_t)v34 << 24;
LABEL_68:
  if (v6 + 2 >= v5)
  {
    v47 = 0;
    goto LABEL_80;
  }
  v40 = 0;
  LOBYTE(v41) = 0;
  v42 = &v126[v12];
  v43 = 1;
  while (2)
  {
    v44 = v43;
    v45 = v42[v40];
    v46 = v45 - 48;
    if ((v45 - 48) < 0xA)
    {
LABEL_75:
      v43 = 0;
      v41 = (v46 | (16 * v41));
      v40 = 1;
      if ((v44 & 1) == 0)
        goto LABEL_79;
      continue;
    }
    break;
  }
  if ((v45 - 97) <= 5)
  {
    v46 = v45 - 87;
    goto LABEL_75;
  }
  if ((v45 - 65) <= 5)
  {
    v46 = v45 - 55;
    goto LABEL_75;
  }
  v41 = 0;
LABEL_79:
  v12 = v6 + 3;
  v47 = v41 << 32;
LABEL_80:
  v48 = v12 + 1;
  if (v12 + 1 >= v5)
  {
    v55 = 0;
    goto LABEL_92;
  }
  v49 = 0;
  LOBYTE(v50) = 0;
  v51 = 1;
  while (2)
  {
    v52 = v51;
    v53 = v126[v12 + v49];
    v54 = v53 - 48;
    if ((v53 - 48) < 0xA)
    {
LABEL_87:
      v51 = 0;
      v50 = (v54 | (16 * v50));
      v49 = 1;
      if ((v52 & 1) == 0)
        goto LABEL_91;
      continue;
    }
    break;
  }
  if ((v53 - 97) <= 5)
  {
    v54 = v53 - 87;
    goto LABEL_87;
  }
  if ((v53 - 65) <= 5)
  {
    v54 = v53 - 55;
    goto LABEL_87;
  }
  v50 = 0;
LABEL_91:
  v48 = v12 + 3;
  v12 += 2;
  v55 = v50 << 40;
LABEL_92:
  if (v12 + 2 >= v5)
  {
    v63 = 0;
    goto LABEL_104;
  }
  v56 = 0;
  LOBYTE(v57) = 0;
  v58 = &v126[v48];
  v59 = 1;
  while (2)
  {
    v60 = v59;
    v61 = v58[v56];
    v62 = v61 - 48;
    if ((v61 - 48) < 0xA)
    {
LABEL_99:
      v59 = 0;
      v57 = (v62 | (16 * v57));
      v56 = 1;
      if ((v60 & 1) == 0)
        goto LABEL_103;
      continue;
    }
    break;
  }
  if ((v61 - 97) <= 5)
  {
    v62 = v61 - 87;
    goto LABEL_99;
  }
  if ((v61 - 65) <= 5)
  {
    v62 = v61 - 55;
    goto LABEL_99;
  }
  v57 = 0;
LABEL_103:
  v48 = v12 + 3;
  v63 = v57 << 48;
LABEL_104:
  v64 = v48 + 1;
  if (v48 + 1 >= v5)
  {
    v71 = 0;
    goto LABEL_116;
  }
  v65 = 0;
  LOBYTE(v66) = 0;
  v67 = 1;
  while (2)
  {
    v68 = v67;
    v69 = v126[v48 + v65];
    v70 = v69 - 48;
    if ((v69 - 48) < 0xA)
    {
LABEL_111:
      v67 = 0;
      v66 = (v70 | (16 * v66));
      v65 = 1;
      if ((v68 & 1) == 0)
        goto LABEL_115;
      continue;
    }
    break;
  }
  if ((v69 - 97) <= 5)
  {
    v70 = v69 - 87;
    goto LABEL_111;
  }
  if ((v69 - 65) <= 5)
  {
    v70 = v69 - 55;
    goto LABEL_111;
  }
  v66 = 0;
LABEL_115:
  v64 = v48 + 3;
  v48 += 2;
  v71 = v66 << 56;
LABEL_116:
  if (v48 + 2 >= v5)
  {
    v79 = 0;
    goto LABEL_128;
  }
  v72 = 0;
  LOBYTE(v73) = 0;
  v74 = &v126[v64];
  v75 = 1;
  while (2)
  {
    v76 = v75;
    v77 = v74[v72];
    v78 = v77 - 48;
    if ((v77 - 48) < 0xA)
    {
LABEL_123:
      v75 = 0;
      v73 = (v78 | (16 * v73));
      v72 = 1;
      if ((v76 & 1) == 0)
        goto LABEL_127;
      continue;
    }
    break;
  }
  if ((v77 - 97) <= 5)
  {
    v78 = v77 - 87;
    goto LABEL_123;
  }
  if ((v77 - 65) <= 5)
  {
    v78 = v77 - 55;
    goto LABEL_123;
  }
  v73 = 0;
LABEL_127:
  v79 = v73;
  v64 = v48 + 3;
LABEL_128:
  v80 = v64 + 1;
  if (v64 + 1 >= v5)
    goto LABEL_139;
  v81 = 0;
  LOBYTE(v82) = 0;
  v83 = 1;
  while (2)
  {
    v84 = v83;
    v85 = v126[v64 + v81];
    v86 = v85 - 48;
    if ((v85 - 48) < 0xA)
    {
LABEL_135:
      v83 = 0;
      v82 = (v86 | (16 * v82));
      v81 = 1;
      if ((v84 & 1) == 0)
        goto LABEL_138;
      continue;
    }
    break;
  }
  if ((v85 - 97) <= 5)
  {
    v86 = v85 - 87;
    goto LABEL_135;
  }
  if ((v85 - 65) <= 5)
  {
    v86 = v85 - 55;
    goto LABEL_135;
  }
  v82 = 0;
LABEL_138:
  v79 |= (unint64_t)v82 << 8;
  v80 = v64 + 3;
  v64 += 2;
LABEL_139:
  if (v64 + 2 >= v5)
    goto LABEL_150;
  v87 = 0;
  LOBYTE(v88) = 0;
  v89 = &v126[v80];
  v90 = 1;
  while (2)
  {
    v91 = v90;
    v92 = v89[v87];
    v93 = v92 - 48;
    if ((v92 - 48) < 0xA)
    {
LABEL_146:
      v90 = 0;
      v88 = (v93 | (16 * v88));
      v87 = 1;
      if ((v91 & 1) == 0)
        goto LABEL_149;
      continue;
    }
    break;
  }
  if ((v92 - 97) <= 5)
  {
    v93 = v92 - 87;
    goto LABEL_146;
  }
  if ((v92 - 65) <= 5)
  {
    v93 = v92 - 55;
    goto LABEL_146;
  }
  v88 = 0;
LABEL_149:
  v79 |= (unint64_t)v88 << 16;
  v80 = v64 + 3;
LABEL_150:
  v94 = v80 + 1;
  if (v80 + 1 >= v5)
    goto LABEL_161;
  v95 = 0;
  LOBYTE(v96) = 0;
  v97 = 1;
  while (2)
  {
    v98 = v97;
    v99 = v126[v80 + v95];
    v100 = v99 - 48;
    if ((v99 - 48) < 0xA)
    {
LABEL_157:
      v97 = 0;
      v96 = (v100 | (16 * v96));
      v95 = 1;
      if ((v98 & 1) == 0)
        goto LABEL_160;
      continue;
    }
    break;
  }
  if ((v99 - 97) <= 5)
  {
    v100 = v99 - 87;
    goto LABEL_157;
  }
  if ((v99 - 65) <= 5)
  {
    v100 = v99 - 55;
    goto LABEL_157;
  }
  v96 = 0;
LABEL_160:
  v79 |= (unint64_t)v96 << 24;
  v94 = v80 + 3;
  v80 += 2;
LABEL_161:
  if (v94 >= v5)
    goto LABEL_172;
  v101 = 0;
  LOBYTE(v102) = 0;
  v103 = 1;
  while (2)
  {
    v104 = v103;
    v105 = v126[v80 + v101];
    v106 = v105 - 48;
    if ((v105 - 48) < 0xA)
    {
LABEL_168:
      v103 = 0;
      v102 = (v106 | (16 * v102));
      v101 = 1;
      if ((v104 & 1) == 0)
        goto LABEL_171;
      continue;
    }
    break;
  }
  if ((v105 - 97) <= 5)
  {
    v106 = v105 - 87;
    goto LABEL_168;
  }
  if ((v105 - 65) <= 5)
  {
    v106 = v105 - 55;
    goto LABEL_168;
  }
  v102 = 0;
LABEL_171:
  v79 |= v102 << 32;
  v94 = v80 + 3;
  v80 += 2;
LABEL_172:
  if (v94 >= v5)
    goto LABEL_183;
  v107 = 0;
  LOBYTE(v108) = 0;
  v109 = 1;
  while (2)
  {
    v110 = v109;
    v111 = v126[v80 + v107];
    v112 = v111 - 48;
    if ((v111 - 48) < 0xA)
    {
LABEL_179:
      v109 = 0;
      v108 = (v112 | (16 * v108));
      v107 = 1;
      if ((v110 & 1) == 0)
        goto LABEL_182;
      continue;
    }
    break;
  }
  if ((v111 - 97) <= 5)
  {
    v112 = v111 - 87;
    goto LABEL_179;
  }
  if ((v111 - 65) <= 5)
  {
    v112 = v111 - 55;
    goto LABEL_179;
  }
  v108 = 0;
LABEL_182:
  v79 |= v108 << 40;
  v94 = v80 + 3;
  v80 += 2;
LABEL_183:
  if (v94 >= v5)
    goto LABEL_194;
  v113 = 0;
  LOBYTE(v114) = 0;
  v115 = 1;
  while (2)
  {
    v116 = v115;
    v117 = v126[v80 + v113];
    v118 = v117 - 48;
    if ((v117 - 48) < 0xA)
    {
LABEL_190:
      v115 = 0;
      v114 = (v118 | (16 * v114));
      v113 = 1;
      if ((v116 & 1) == 0)
        goto LABEL_193;
      continue;
    }
    break;
  }
  if ((v117 - 97) <= 5)
  {
    v118 = v117 - 87;
    goto LABEL_190;
  }
  if ((v117 - 65) <= 5)
  {
    v118 = v117 - 55;
    goto LABEL_190;
  }
  v114 = 0;
LABEL_193:
  v79 |= v114 << 48;
  v94 = v80 + 3;
  v80 += 2;
LABEL_194:
  if (v94 >= v5)
    return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, v25 | v32 | v39 | v14 | v47 | v55 | v63 | v71, v79, 0);
  v119 = 0;
  LOBYTE(v120) = 0;
  v121 = &v126[v80];
  v122 = 1;
  while (2)
  {
    v123 = v122;
    v124 = v121[v119];
    v125 = v124 - 48;
    if ((v124 - 48) < 0xA)
    {
LABEL_201:
      v122 = 0;
      v120 = (v125 | (16 * v120));
      v119 = 1;
      if ((v123 & 1) == 0)
        goto LABEL_204;
      continue;
    }
    break;
  }
  if ((v124 - 97) <= 5)
  {
    v125 = v124 - 87;
    goto LABEL_201;
  }
  if ((v124 - 65) <= 5)
  {
    v125 = v124 - 55;
    goto LABEL_201;
  }
  v120 = 0;
LABEL_204:
  v79 |= v120 << 56;
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, v25 | v32 | v39 | v14 | v47 | v55 | v63 | v71, v79, 0);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  const __CFUUID *v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6 = &v5;
  v7 = 0x2800000000;
  v8 = 0;
  v9 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __CFUUIDCreate_block_invoke;
  v4[3] = &unk_1E1332F18;
  v4[4] = &v5;
  os_unfair_lock_lock_with_options();
  __CFUUIDCreate_block_invoke((uint64_t)v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&_uniquedUUIDsLock);
  v2 = (const __CFUUID *)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, v6[3], v6[4], 0);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_182B652DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CFUUIDCreateWithBytesPrimitive(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v4;
  _QWORD v6[8];
  char v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = ____CFUUIDCreateWithBytesPrimitive_block_invoke;
  v6[3] = &unk_1E1332F40;
  v6[6] = a2;
  v6[7] = a3;
  v6[4] = &v8;
  v6[5] = a1;
  v7 = a4;
  os_unfair_lock_lock_with_options();
  ____CFUUIDCreateWithBytesPrimitive_block_invoke((uint64_t)v6);
  os_unfair_lock_unlock((os_unfair_lock_t)&_uniquedUUIDsLock);
  v4 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v4;
}

void sub_182B653CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

CFAllocatorRef CFAllocatorCreate(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  uint64_t v3;
  CFAllocatorAllocateCallBack allocate;
  void *info;
  CFAllocatorRetainCallBack retain;
  char *Impl;
  uint64_t v8;
  CFIndex version;

  v3 = (uint64_t)allocator;
  if (allocator && allocator != (CFAllocatorRef)939 && *(_QWORD *)allocator != qword_1ECCFACA8)
    return 0;
  allocate = context->allocate;
  info = context->info;
  retain = context->retain;
  if (retain)
    info = (void *)((uint64_t (*)(void *))retain)(context->info);
  if (v3)
  {
    if (v3 == 939)
    {
      if (allocate)
      {
        Impl = (char *)((uint64_t (*)(uint64_t, _QWORD, void *))allocate)(224, 0, info);
        if (Impl)
        {
          v3 = 939;
LABEL_17:
          *(_QWORD *)Impl = 0;
          *((_QWORD *)Impl + 1) = 0;
          __CFRuntimeSetRC((uint64_t)Impl, 1u);
          _CFRuntimeSetInstanceTypeID((uint64_t)Impl, 2uLL);
          *(_QWORD *)Impl = qword_1ECCFACA8;
          *((_QWORD *)Impl + 2) = __CFAllocatorCustomSize;
          *((_QWORD *)Impl + 3) = __CFAllocatorCustomMalloc;
          *((_QWORD *)Impl + 4) = __CFAllocatorCustomCalloc;
          *((_QWORD *)Impl + 5) = __CFAllocatorCustomValloc;
          *((_QWORD *)Impl + 6) = __CFAllocatorCustomFree;
          *((_QWORD *)Impl + 7) = __CFAllocatorCustomRealloc;
          *((_QWORD *)Impl + 8) = __CFAllocatorCustomDestroy;
          *((_QWORD *)Impl + 9) = "Custom CFAllocator";
          *((_QWORD *)Impl + 10) = 0;
          *((_QWORD *)Impl + 11) = 0;
          *((_QWORD *)Impl + 12) = __CFAllocatorZoneIntrospect;
          *((_DWORD *)Impl + 26) = 6;
          *((_QWORD *)Impl + 14) = 0;
          *((_QWORD *)Impl + 15) = 0;
          version = context->version;
          *((_QWORD *)Impl + 16) = v3;
          *((_QWORD *)Impl + 17) = version;
          *((_QWORD *)Impl + 18) = info;
          *((_QWORD *)Impl + 19) = retain;
          *((_OWORD *)Impl + 10) = *(_OWORD *)&context->release;
          *((_QWORD *)Impl + 22) = allocate;
          *(_OWORD *)(Impl + 184) = *(_OWORD *)&context->reallocate;
          *((_QWORD *)Impl + 25) = context->preferredSize;
          *((_QWORD *)Impl + 26) = 0;
          *((_QWORD *)Impl + 27) = 0;
          return (CFAllocatorRef)Impl;
        }
        return (CFAllocatorRef)Impl;
      }
      return 0;
    }
  }
  else
  {
    v8 = _CFGetTSD(1u);
    if (v8)
      v3 = v8;
    else
      v3 = (uint64_t)&__kCFAllocatorSystemDefault;
  }
  Impl = (char *)_CFAllocatorAllocateImpl((malloc_zone_t *)v3, 0xE0uLL, 0x10F00406A531AB1uLL, 0);
  if (Impl)
  {
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
    goto LABEL_17;
  }
  return (CFAllocatorRef)Impl;
}

void __CFRuntimeSetRC(uint64_t a1, unsigned __int16 a2)
{
  unint64_t v2;

  v2 = atomic_load((unint64_t *)(a1 + 8));
  atomic_store(v2 & 0xFFFFFFFFFFFFLL | ((unint64_t)a2 << 48), (unint64_t *)(a1 + 8));
}

void _CFPlugInRegisterPlugInTypeLocked(void *key, const void *a2)
{
  CFMutableArrayRef *v3;
  CFMutableArrayRef *v4;
  const __CFDictionary *Mutable;
  void *Value;
  CFArrayCallBacks v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (_factoriesByFactoryID
    && (v3 = (CFMutableArrayRef *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, key)) != 0
    && (v4 = v3, *((_BYTE *)v3 + 24)))
  {
    CFArrayAppendValue(v3[7], a2);
    Mutable = (const __CFDictionary *)_factoriesByTypeID;
    if (!_factoriesByTypeID)
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      _factoriesByTypeID = (uint64_t)Mutable;
    }
    Value = (void *)CFDictionaryGetValue(Mutable, a2);
    if (!Value)
    {
      memset(&v7, 0, sizeof(v7));
      Value = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &v7);
      CFDictionarySetValue((CFMutableDictionaryRef)_factoriesByTypeID, a2, Value);
      CFRelease(Value);
    }
    CFArrayAppendValue((CFMutableArrayRef)Value, v4);
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
      _CFPlugInRegisterPlugInTypeLocked_cold_2();
  }
  else
  {
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR))
      _CFPlugInRegisterPlugInTypeLocked_cold_1();
  }
}

void *allocatePurgeable(int64_t a1, uint64_t a2, uint64_t a3)
{
  int64_t v5;
  vm_size_t v6;
  vm_address_t v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v8[0] = 0;
  if (a1 <= 0)
    v5 = *MEMORY[0x1E0C85AD8];
  else
    v5 = a1;
  v6 = (*MEMORY[0x1E0C85AD8] + v5 - 1) & -*MEMORY[0x1E0C85AD8];
  if (vm_allocate(*MEMORY[0x1E0C83DA0], v8, v6, -268435453))
  {
    *(_BYTE *)(a3 + 25) = 1;
    *(_QWORD *)(a3 + 16) = a1;
    return malloc_type_malloc(a1, 0xB0F897C4uLL);
  }
  else
  {
    *(_QWORD *)(a3 + 16) = v6;
    return (void *)v8[0];
  }
}

unint64_t *__CFBinaryPlistCreateDataUsingExternalBufferAllocator(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const void *v11;
  const UInt8 *Typed;
  UInt8 *v13;
  unint64_t *FixedMutableWithBuffer;
  unint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  CFErrorRef Error;

  v8 = __CFBinaryPlistWriteOrPresize(a1, 0, a3, a4, 1, a5);
  if (v8 < 1)
    return 0;
  v9 = v8;
  v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, v8);
  if (!v10)
  {
    if (!a5)
      return 0;
    Error = __CFPropertyListCreateError(3851, CFSTR("Binary property list writing could not be completed because an allocator could not be created."));
    goto LABEL_13;
  }
  v11 = (const void *)v10;
  Typed = (const UInt8 *)CFAllocatorAllocateTyped(v10, v9, 120675696, 0);
  if (!Typed)
  {
    CFRelease(v11);
    if (!a5)
      return 0;
    Error = __CFPropertyListCreateError(3851, CFSTR("Binary property list writing could not be completed because an external buffer could not be allocated."));
    goto LABEL_13;
  }
  v13 = (UInt8 *)Typed;
  FixedMutableWithBuffer = _CFDataCreateFixedMutableWithBuffer(&__kCFAllocatorSystemDefault, v9, Typed, v11);
  if (!FixedMutableWithBuffer)
  {
    CFAllocatorDeallocate((CFAllocatorRef)v11, v13);
    if (!a5)
      return 0;
    Error = __CFPropertyListCreateError(3851, CFSTR("Binary property list writing could not be completed because a CFMutableDataRef using the external buffer could not be allocated."));
LABEL_13:
    v15 = 0;
    *a5 = Error;
    return v15;
  }
  v15 = FixedMutableWithBuffer;
  CFRelease(v11);
  if (v9 != __CFBinaryPlistWriteOrPresize(a1, v15, v16, v17, 0, a5))
  {
    CFRelease(v15);
    return 0;
  }
  return v15;
}

BOOL CFPreferencesIsManaged(const __CFString *a1, int a2)
{
  const __CFString *v3;
  _BOOL8 IsUserManaged;
  const __CFString *v5;

  v3 = a1;
  if (CFEqual(a1, CFSTR("kCFPreferencesAnyUser"))
    || CFEqual(v3, CFSTR("kCFPreferencesCurrentUser")) && !cfprefsdEuid())
  {
    return _CFPrefsIsUserManaged(CFSTR("kCFPreferencesAnyUser"), a2);
  }
  if (CFEqual(v3, CFSTR("kCFPreferencesCurrentUser")))
  {
    if (_CFPrefsCurrentProcessIsCFPrefsD())
      v5 = _CFPrefsDCopyCurrentUserName();
    else
      v5 = CFCopyUserName();
    v3 = v5;
  }
  else
  {
    CFRetain(v3);
  }
  IsUserManaged = _CFPrefsIsUserManaged(v3, a2);
  CFRelease(v3);
  return IsUserManaged;
}

BOOL _CFPrefsIsUserManaged(const __CFString *a1, int a2)
{
  const __CFDictionary *ManagedStateCache;
  const __CFNumber *Value;
  int v6;
  NSObject *v7;
  __CFDictionary *v8;
  CFNumberRef v9;
  stat v11;
  UInt8 valuePtr[1024];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)&managedPreferencesLock);
  ManagedStateCache = locked_getManagedStateCache(a2);
  Value = (const __CFNumber *)CFDictionaryGetValue(ManagedStateCache, a1);
  *(_DWORD *)valuePtr = 0;
  if (!Value || !CFNumberGetValue(Value, kCFNumberIntType, valuePtr) || (v6 = *(_DWORD *)valuePtr) == 0)
  {
    bzero(valuePtr, 0x400uLL);
    if (_CFPrefsGetPathForManagedBundleID(0, a1, a2, valuePtr))
    {
      memset(&v11, 0, sizeof(v11));
      if (stat((const char *)valuePtr, &v11))
        v6 = 2;
      else
        v6 = 1;
    }
    else
    {
      v6 = 0;
    }
    v7 = _CFPrefsClientLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      _CFPrefsIsUserManaged_cold_1(v6, (uint64_t)a1, v7);
    v11.st_dev = v6;
    v8 = locked_getManagedStateCache(a2);
    v9 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberIntType, &v11);
    CFDictionarySetValue(v8, a1, v9);
    CFRelease(v9);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&managedPreferencesLock);
  return v6 == 1;
}

CFMutableDictionaryRef locked_getManagedStateCache(int a1)
{
  CFMutableDictionaryRef result;

  if (a1)
  {
    result = (CFMutableDictionaryRef)locked_getManagedStateCache_knownContainerizedManagedPrefsStates;
    if (!locked_getManagedStateCache_knownContainerizedManagedPrefsStates)
    {
      result = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      locked_getManagedStateCache_knownContainerizedManagedPrefsStates = (uint64_t)result;
    }
  }
  else
  {
    result = (CFMutableDictionaryRef)locked_getManagedStateCache_knownManagedPrefsStates;
    if (!locked_getManagedStateCache_knownManagedPrefsStates)
    {
      result = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      locked_getManagedStateCache_knownManagedPrefsStates = (uint64_t)result;
    }
  }
  return result;
}

CFArrayRef CFLocaleCopyPreferredLanguages(void)
{
  return (CFArrayRef)(id)+[NSLocale _preferredLanguagesForCurrentUser:](NSLocale, "_preferredLanguagesForCurrentUser:", 0);
}

CFRange CFStringTokenizerGetCurrentTokenRange(CFStringTokenizerRef tokenizer)
{
  CFIndex CurrentTokenRange;
  CFIndex v2;
  CFRange result;

  CurrentTokenRange = __NLStringTokenizerGetCurrentTokenRange(*((_QWORD *)tokenizer + 2));
  result.length = v2;
  result.location = CurrentTokenRange;
  return result;
}

uint64_t __CFCanonicalNameHash(char *a1)
{
  char v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = *a1;
  if (!*a1)
    return 0;
  v2 = 0;
  v3 = 1;
  do
  {
    v2 += v1 + 32 * ((v1 - 65) < 0x1Au);
    v1 = a1[v3];
    v4 = v3 + 1;
    if (!v1)
      break;
  }
  while (v3++ < 256);
  return (v4 - 1) * v2;
}

uint64_t _CFURLComponentsGetRangeOfQuery(void *a1)
{
  uint64_t result;

  result = objc_msgSend(a1, "rangeOfQuery");
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    return -1;
  return result;
}

uint64_t _CFURLComponentsGetRangeOfPath(void *a1)
{
  uint64_t result;

  result = objc_msgSend(a1, "rangeOfPath");
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    return -1;
  return result;
}

id _CFURLComponentsCreateWithURL(uint64_t a1, uint64_t a2, int a3)
{
  return (id)+[NSURLComponents _componentsWithUrl:resolvingAgainstBaseURL:](&off_1EDCDC9E8, "_componentsWithUrl:resolvingAgainstBaseURL:", a2, a3 != 0);
}

uint64_t _CFURLComponentsCreateWithStringInternal()
{
  return 0;
}

uint64_t _CFURLComponentsSetPath(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setPath:", a2);
  return 1;
}

uint64_t _CFURLComponentsGetURLPathAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1)
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  return *(_QWORD *)(sURLAllowedCharacterSets + 24);
}

CFArrayRef _CFURLComponentsCopyPercentEncodedQueryItems(void *a1)
{
  return __CFURLComponentsCopyQueryItems(a1, 1);
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)_CFStreamCreateWithFile((__objc2_class **)alloc, fileURL, 0);
}

uint64_t _CFURLComponentsSetPercentEncodedQueryItems(void *a1, const __CFArray *a2, const __CFArray *a3)
{
  __CFURLComponentsSetQueryItems(a1, a2, a3);
  return 1;
}

uint64_t __CFStringCreateCollator(const __CFLocale *a1)
{
  const __CFString *Value;
  uint64_t v2;
  char buffer[16];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  Value = (const __CFString *)CFLocaleGetValue(a1, CFSTR("locale:collator id"));
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  *(_OWORD *)buffer = 0u;
  v5 = 0u;
  CFStringGetCString(Value, buffer, 128, 0x600u);
  v2 = ucol_open();
  ucol_setAttribute();
  ucol_setAttribute();
  ucol_setAttribute();
  ucol_setAttribute();
  ucol_setAttribute();
  return v2;
}

void __ResetUDateFormat(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  void *v6;
  const void *v7;
  const __CFLocale *v8;
  const __CFString *Identifier;
  const __CFTimeZone *v10;
  uint64_t *v11;
  const __CFString *Name;
  NSObject *v13;
  CFIndex Length;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  __objc2_class **v19;
  __objc2_class **v20;
  BOOL v21;
  int v22;
  BOOL v23;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  __objc2_class **v31;
  BOOL v32;
  int v33;
  CFIndex v34;
  uint64_t v35;
  CFIndex v36;
  size_t v37;
  _BYTE *v38;
  UChar *CharactersPtr;
  CFTypeRef Value;
  const char *v41;
  const __CFDictionary *AppleICUDateTimeSymbolsPref;
  const char *v43;
  const __CFDictionary *v44;
  CFTypeID v45;
  const void *AppleFirstWeekdayPref;
  const char *v47;
  const void *v48;
  CFTypeID v49;
  const void *v50;
  const void *AppleMinDaysInFirstWeekPref;
  const char *v52;
  const void *v53;
  CFTypeID v54;
  const void *v55;
  const void *AppleICUForce24HourTimePref;
  const char *v57;
  const void *v58;
  CFTypeID v59;
  const void *v60;
  const void *AppleICUForce12HourTimePref;
  const char *v62;
  const void *v63;
  CFTypeID v64;
  const void *v65;
  const __CFDictionary *AppleICUDateFormatStringsPref;
  const char *v67;
  const __CFDictionary *v68;
  CFTypeID v69;
  unint64_t v70;
  __CFString *v71;
  const void *v72;
  const void *v73;
  CFTypeID v74;
  const void *v75;
  const __CFDictionary *AppleICUTimeFormatStringsPref;
  const __CFDictionary *v77;
  CFTypeID v78;
  unint64_t v79;
  __CFString *v80;
  const void *v81;
  const void *v82;
  CFTypeID v83;
  const void *v84;
  CFTypeRef v85;
  uint64_t Calendar;
  const __CFString *v87;
  const void *UCalendar;
  __objc2_class **v89;
  const __CFTimeZone *v90;
  const __CFString *v91;
  CFIndex v92;
  CFIndex v93;
  const __CFDate *v94;
  double v95;
  __CFCalendar *v96;
  int FirstWeekday;
  uint64_t v98;
  __CFCalendar *v99;
  int MinimumDaysInFirstWeek;
  uint64_t v101;
  const __CFString *v102;
  uint64_t v103;
  double v104;
  double v105;
  const __CFDictionary *v106;
  const __CFNumber *v107;
  const __CFNumber *v108;
  CFTypeID v109;
  const __CFDictionary *v110;
  const __CFNumber *v111;
  const __CFNumber *v112;
  CFTypeID v113;
  int v114;
  int v115;
  const __CFString *v116;
  uint64_t v117;
  int v118;
  int v119;
  uint64_t v120;
  int v121;
  const __CFString *v122;
  const __CFString *ForcedString;
  uint64_t v124;
  uint64_t v125;
  int v126;
  int v127;
  const void *v128;
  int v129;
  const __CFString *v130;
  const __CFString *v131;
  CFIndex v132;
  uint64_t v133;
  CFIndex v134;
  size_t v135;
  _BYTE *v136;
  UChar *v137;
  const void *v138;
  const __CFAllocator *v139;
  const void *v140;
  CFTypeRef v141;
  __CFString *v142;
  __CFString *v143;
  __CFString *v144;
  __CFString *v145;
  __CFString *v146;
  __CFString *v147;
  __CFString *v148;
  __CFString *v149;
  __CFString *v150;
  __CFString *v151;
  _BYTE v152[12];
  int v153;
  void *v154;
  int v155;
  int v156[384];
  UChar v157[768];
  char v158[768];
  int v159[384];
  _QWORD v160[194];
  CFRange v161;
  CFRange v162;
  CFRange v163;
  CFRange v164;
  CFRange v165;
  CFRange v166;
  CFRange v167;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v4 = v3;
  v5 = v2;
  v160[192] = *MEMORY[0x1E0C80C00];
  v6 = (void *)MEMORY[0x186DB02F4]();
  v7 = *(const void **)(v5 + 16);
  if (v7)
    __cficu_udat_close(v7);
  *(_QWORD *)(v5 + 16) = 0;
  v158[0] = 0;
  v8 = *(const __CFLocale **)(v5 + 24);
  if (v8)
    Identifier = CFLocaleGetIdentifier(v8);
  else
    Identifier = &stru_1E1337B18;
  CFStringGetCString(Identifier, v158, 768, 0x600u);
  v157[0] = 0;
  v11 = (uint64_t *)(v5 + 88);
  v10 = *(const __CFTimeZone **)(v5 + 88);
  if (v10)
  {
    Name = CFTimeZoneGetName(v10);
    if (!Name)
    {
      v13 = _CFOSLog();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        __ResetUDateFormat_cold_1(v11, v13);
      goto LABEL_233;
    }
  }
  else
  {
    Name = CFSTR("GMT");
  }
  if (CFStringGetLength(Name) <= 768)
    Length = CFStringGetLength(Name);
  else
    Length = 768;
  v161.location = 0;
  v161.length = Length;
  CFStringGetCharacters(Name, v161, v157);
  v15 = *(_QWORD *)(v5 + 40);
  if (v15 > 3)
    v16 = 0;
  else
    v16 = dword_182C87F50[v15];
  switch(*(_QWORD *)(v5 + 32))
  {
    case 0:
      v17 = -1;
      v18 = 1;
      break;
    case 1:
      v18 = 0;
      v17 = 3;
      break;
    case 2:
      v18 = 0;
      v17 = 2;
      break;
    case 3:
      v18 = 0;
      v17 = 1;
      break;
    default:
      v18 = 0;
      v17 = 0;
      break;
  }
  v19 = *(__objc2_class ***)(v5 + 72);
  v20 = *(__objc2_class ***)(v5 + 80);
  if (v19)
    v21 = v19 == &__kCFBooleanTrue;
  else
    v21 = 0;
  v22 = !v21;
  if (v20)
    v23 = v20 == &__kCFBooleanTrue;
  else
    v23 = 0;
  if (!v23 && v4 == 0)
    v25 = v22;
  else
    v25 = 1;
  if (v15)
    v26 = v25;
  else
    v26 = 1;
  if (v26)
    v27 = v16;
  else
    v27 = v16 | 0x80;
  v155 = 0;
  v28 = __cficu_udat_open(v17, v27, (uint64_t)v158, v157, Length, 0, 0, &v155);
  if (v28)
    v29 = v155 <= 0;
  else
    v29 = 0;
  if (v29)
  {
    v30 = v28;
    if ((v22 & 1) == 0)
      __cficu_udat_setContext(v28, 259, &v155);
    v153 = v18;
    v31 = *(__objc2_class ***)(v5 + 64);
    if (v31)
      v32 = &__kCFBooleanTrue == v31;
    else
      v32 = 0;
    v33 = v32;
    __cficu_udat_setLenient(v30, v33);
    if (!*(_QWORD *)(v5 + 40) && !*(_QWORD *)(v5 + 32))
      __cficu_udat_applyPattern(v30, 0, 0, 0);
    if (v22 && *(__objc2_class ***)(v5 + 80) == &__kCFBooleanTrue)
    {
      v34 = CFStringGetLength(*(CFStringRef *)(v5 + 48));
      v36 = v34;
      v37 = 2 * v34;
      if ((unint64_t)(2 * v34) < 0x101)
      {
        if (v34 < 1)
        {
          v38 = 0;
        }
        else
        {
          MEMORY[0x1E0C80A78](v34, v35);
          v38 = &v152[-((v37 + 15) & 0xFFFFFFFFFFFFFFF0)];
          bzero(v38, v37);
        }
      }
      else
      {
        v38 = malloc_type_malloc(2 * v34, 0x1000040BDFB0063uLL);
      }
      CharactersPtr = (UChar *)CFStringGetCharactersPtr(*(CFStringRef *)(v5 + 48));
      if (!CharactersPtr)
      {
        v162.location = 0;
        v162.length = v36;
        CFStringGetCharacters(*(CFStringRef *)(v5 + 48), v162, (UniChar *)v38);
        CharactersPtr = (UChar *)v38;
      }
      __cficu_udat_applyPattern(v30, 0, CharactersPtr, v36);
      if (v37 >= 0x101)
        free(v38);
    }
    Value = CFLocaleGetValue(*(CFLocaleRef *)(v5 + 24), CFSTR("calendar"));
    if (Value && CFEqual(Value, CFSTR("gregorian")))
    {
      v155 = 0;
      __cficu_udat_set2DigitYearStart(v30, &v155, -6.31152e11);
    }
    *(_QWORD *)(v5 + 16) = v30;
    AppleICUDateTimeSymbolsPref = (const __CFDictionary *)_CFLocaleGetAppleICUDateTimeSymbolsPref(*(void **)(v5 + 24), v41);
    if (AppleICUDateTimeSymbolsPref)
    {
      v44 = AppleICUDateTimeSymbolsPref;
      v45 = CFGetTypeID(AppleICUDateTimeSymbolsPref);
      if (v45 == CFDictionaryGetTypeID())
        CFDictionaryApplyFunction(v44, (CFDictionaryApplierFunction)__CFDateFormatterStoreSymbolPrefs, (void *)v5);
    }
    AppleFirstWeekdayPref = (const void *)_CFLocaleGetAppleFirstWeekdayPref(*(void **)(v5 + 24), v43);
    if (AppleFirstWeekdayPref)
    {
      v48 = AppleFirstWeekdayPref;
      v49 = CFGetTypeID(AppleFirstWeekdayPref);
      if (v49 == CFDictionaryGetTypeID())
      {
        v50 = *(const void **)(v5 + 512);
        if (v50)
          CFRelease(v50);
        *(_QWORD *)(v5 + 512) = CFRetain(v48);
      }
    }
    AppleMinDaysInFirstWeekPref = (const void *)_CFLocaleGetAppleMinDaysInFirstWeekPref(*(void **)(v5 + 24), v47);
    if (AppleMinDaysInFirstWeekPref)
    {
      v53 = AppleMinDaysInFirstWeekPref;
      v54 = CFGetTypeID(AppleMinDaysInFirstWeekPref);
      if (v54 == CFDictionaryGetTypeID())
      {
        v55 = *(const void **)(v5 + 520);
        if (v55)
          CFRelease(v55);
        *(_QWORD *)(v5 + 520) = CFRetain(v53);
      }
    }
    AppleICUForce24HourTimePref = (const void *)_CFLocaleGetAppleICUForce24HourTimePref(*(void **)(v5 + 24), v52);
    if (AppleICUForce24HourTimePref)
    {
      v58 = AppleICUForce24HourTimePref;
      v59 = CFGetTypeID(AppleICUForce24HourTimePref);
      if (v59 == CFBooleanGetTypeID())
      {
        v60 = *(const void **)(v5 + 480);
        if (v60)
          CFRelease(v60);
        *(_QWORD *)(v5 + 480) = CFRetain(v58);
      }
    }
    AppleICUForce12HourTimePref = (const void *)_CFLocaleGetAppleICUForce12HourTimePref(*(void **)(v5 + 24), v57);
    if (AppleICUForce12HourTimePref)
    {
      v63 = AppleICUForce12HourTimePref;
      v64 = CFGetTypeID(AppleICUForce12HourTimePref);
      if (v64 == CFBooleanGetTypeID())
      {
        v65 = *(const void **)(v5 + 488);
        if (v65)
          CFRelease(v65);
        *(_QWORD *)(v5 + 488) = CFRetain(v63);
      }
    }
    AppleICUDateFormatStringsPref = (const __CFDictionary *)_CFLocaleGetAppleICUDateFormatStringsPref(*(void **)(v5 + 24), v62);
    if (AppleICUDateFormatStringsPref)
    {
      v68 = AppleICUDateFormatStringsPref;
      v69 = CFGetTypeID(AppleICUDateFormatStringsPref);
      if (v69 == CFDictionaryGetTypeID())
      {
        v70 = *(_QWORD *)(v5 + 40) - 1;
        v71 = v70 > 3 ? CFSTR("0") : off_1E12E1480[v70];
        v72 = CFDictionaryGetValue(v68, v71);
        if (v72)
        {
          v73 = v72;
          v74 = CFGetTypeID(v72);
          if (v74 == CFStringGetTypeID())
          {
            v75 = *(const void **)(v5 + 464);
            if (v75)
              CFRelease(v75);
            *(_QWORD *)(v5 + 464) = CFRetain(v73);
          }
        }
      }
    }
    AppleICUTimeFormatStringsPref = (const __CFDictionary *)_CFLocaleGetAppleICUTimeFormatStringsPref(*(void **)(v5 + 24), v67);
    if (AppleICUTimeFormatStringsPref)
    {
      v77 = AppleICUTimeFormatStringsPref;
      v78 = CFGetTypeID(AppleICUTimeFormatStringsPref);
      if (v78 == CFDictionaryGetTypeID())
      {
        v79 = *(_QWORD *)(v5 + 32) - 1;
        v80 = v79 > 3 ? CFSTR("0") : off_1E12E1480[v79];
        v81 = CFDictionaryGetValue(v77, v80);
        if (v81)
        {
          v82 = v81;
          v83 = CFGetTypeID(v81);
          if (v83 == CFStringGetTypeID())
          {
            v84 = *(const void **)(v5 + 472);
            if (v84)
              CFRelease(v84);
            *(_QWORD *)(v5 + 472) = CFRetain(v82);
          }
        }
      }
    }
    v85 = *(CFTypeRef *)(v5 + 104);
    if (!v85)
      v85 = CFLocaleGetValue(*(CFLocaleRef *)(v5 + 24), CFSTR("calendar"));
    v159[0] = 0;
    Calendar = __cficu_udat_getCalendar(*(_QWORD *)(v5 + 16));
    if (!*(_QWORD *)(v5 + 96) && !*(_QWORD *)(v5 + 104)
      || (v87 = CFLocaleGetIdentifier(*(CFLocaleRef *)(v5 + 24)),
          (UCalendar = (const void *)__CFCalendarCreateUCalendar(0, v87, *(const __CFTimeZone **)(v5 + 88))) == 0))
    {
      UCalendar = (const void *)__cficu_ucal_clone(Calendar, v159);
    }
    v89 = *(__objc2_class ***)(v5 + 64);
    if (v89)
    {
      v159[0] = 0;
      __cficu_ucal_setAttribute((uint64_t)UCalendar, 0, &__kCFBooleanTrue == v89);
    }
    v90 = (const __CFTimeZone *)*v11;
    v154 = v6;
    if (v90)
    {
      v159[0] = 0;
      v91 = CFTimeZoneGetName(v90);
      v92 = CFStringGetLength(v91);
      if (v92 >= 768)
        v93 = 768;
      else
        v93 = v92;
      v163.location = 0;
      v163.length = v93;
      CFStringGetCharacters(v91, v163, (UniChar *)v160);
      __cficu_ucal_setTimeZone((uint64_t)UCalendar, (UChar *)v160, v93, v159);
    }
    v94 = *(const __CFDate **)(v5 + 128);
    if (v94)
    {
      v159[0] = 0;
      v95 = CFDateGetAbsoluteTime(v94) + 978307200.0;
    }
    else
    {
      if (!v85 || !CFEqual(v85, CFSTR("gregorian")))
      {
LABEL_133:
        v96 = *(__CFCalendar **)(v5 + 96);
        if (v96)
        {
          FirstWeekday = CFCalendarGetFirstWeekday(v96);
          v98 = (uint64_t)UCalendar;
        }
        else
        {
          v106 = *(const __CFDictionary **)(v5 + 512);
          if (!v106
            || (v107 = (const __CFNumber *)CFDictionaryGetValue(v106, v85)) == 0
            || (v108 = v107, v109 = CFGetTypeID(v107), v109 != CFNumberGetTypeID())
            || (v160[0] = 0, !CFNumberGetValue(v108, kCFNumberCFIndexType, v160)))
          {
LABEL_136:
            v99 = *(__CFCalendar **)(v5 + 96);
            if (v99)
            {
              MinimumDaysInFirstWeek = CFCalendarGetMinimumDaysInFirstWeek(v99);
              v101 = (uint64_t)UCalendar;
            }
            else
            {
              v110 = *(const __CFDictionary **)(v5 + 520);
              if (!v110
                || (v111 = (const __CFNumber *)CFDictionaryGetValue(v110, v85)) == 0
                || (v112 = v111, v113 = CFGetTypeID(v111), v113 != CFNumberGetTypeID())
                || (v160[0] = 0, !CFNumberGetValue(v112, kCFNumberCFIndexType, v160)))
              {
LABEL_139:
                __cficu_udat_setCalendar(*(_QWORD *)(v5 + 16), (uint64_t)UCalendar);
                __cficu_ucal_close(UCalendar);
                if ((v25 & 1) != 0)
                {
                  __substituteFormatStringFromPrefsDF(v5, 0);
                  __substituteFormatStringFromPrefsDF(v5, 1);
                  __ApplyUDateFormatSymbol(v5);
                  v6 = v154;
                }
                else
                {
                  v6 = v154;
                  if (*(_QWORD *)(v5 + 40))
                  {
                    v102 = *(const __CFString **)(v5 + 464);
                    if (!v102
                      || (CFStringGetLength(v102) > 767
                        ? (v103 = 768)
                        : (v103 = CFStringGetLength(*(CFStringRef *)(v5 + 464))),
                          v164.location = 0,
                          v164.length = v103,
                          CFStringGetCharacters(*(CFStringRef *)(v5 + 464), v164, (UniChar *)v160),
                          v103 == -1))
                    {
                      v159[0] = 0;
                      v114 = __cficu_udat_toPatternRelativeDate(*(_QWORD *)(v5 + 16), (const UniChar *)v160, 768, v159);
                      if (v159[0] > 0)
                        v115 = -1;
                      else
                        v115 = v114;
                      v103 = v115;
                    }
                    if (!*(_QWORD *)(v5 + 32)
                      || (v116 = *(const __CFString **)(v5 + 472)) == 0
                      || (CFStringGetLength(v116) > 767
                        ? (v117 = 768)
                        : (v117 = CFStringGetLength(*(CFStringRef *)(v5 + 472))),
                          v165.location = 0,
                          v165.length = v117,
                          CFStringGetCharacters(*(CFStringRef *)(v5 + 472), v165, (UniChar *)v159),
                          v117 == -1))
                    {
                      v156[0] = 0;
                      v118 = __cficu_udat_toPatternRelativeTime(*(_QWORD *)(v5 + 16), (const UniChar *)v159, 768, v156);
                      if (v156[0] > 0)
                        v119 = -1;
                      else
                        v119 = v118;
                      v117 = v119;
                    }
                    v156[0] = 0;
                    __cficu_udat_applyPatternRelative(*(_QWORD *)(v5 + 16), (UChar *)((unint64_t)v160 & ~(v103 >> 63)), v103 & ~(v103 >> 63), (UChar *)((unint64_t)v159 & ~(v117 >> 63)), v117 & ~(v117 >> 63), v156);
                  }
                  else
                  {
                    __substituteFormatStringFromPrefsDF(v5, 0);
                    __substituteFormatStringFromPrefsDF(v5, 1);
                  }
                  __ApplyUDateFormatSymbol(v5);
                  if (*(_QWORD *)(v5 + 40))
                  {
                    v155 = 0;
                    v120 = __cficu_udat_toPatternRelativeDate(v30, (const UniChar *)v160, 768, &v155);
                    v121 = 0;
                    if ((v153 & 1) == 0)
                      v121 = __cficu_udat_toPatternRelativeTime(v30, (const UniChar *)v159, 768, &v155);
                    if (v155 <= 0 && (int)v120 <= 768 && v121 <= 768)
                    {
                      v122 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UniChar *)v159, v121);
                      ForcedString = (const __CFString *)__CFDateFormatterCreateForcedString((_QWORD *)v5, v122);
                      v124 = CFStringGetLength(ForcedString);
                      if (v124 <= 768)
                      {
                        v125 = v124;
                        v166.location = 0;
                        v166.length = v124;
                        CFStringGetCharacters(ForcedString, v166, (UniChar *)v159);
                        v155 = 0;
                        __cficu_udat_applyPatternRelative(v30, (UChar *)v160, v120, (UChar *)v159, v125, &v155);
                        v155 = 0;
                        v126 = __cficu_udat_toPattern(v30, 0, (const UniChar *)v156, 768, &v155);
                        if (v155 <= 0)
                        {
                          v127 = v126;
                          if (v126 <= 768)
                          {
                            v128 = *(const void **)(v5 + 48);
                            if (v128)
                              CFRelease(v128);
                            *(_QWORD *)(v5 + 48) = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UniChar *)v156, v127);
                          }
                        }
                      }
                      CFRelease(ForcedString);
                      CFRelease(v122);
                      v6 = v154;
                    }
                    goto LABEL_207;
                  }
                }
                v155 = 0;
                v129 = __cficu_udat_toPattern(v30, 0, (const UniChar *)v160, 768, &v155);
                if (v155 <= 0 && v129 <= 768)
                {
                  v130 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UniChar *)v160, v129);
                  v131 = (const __CFString *)__CFDateFormatterCreateForcedString((_QWORD *)v5, v130);
                  v132 = CFStringGetLength(v131);
                  if (v132 <= 1024)
                  {
                    v134 = v132;
                    v135 = 2 * v132;
                    if ((unint64_t)(2 * v132) < 0x101)
                    {
                      if (v132 < 1)
                      {
                        v136 = 0;
                      }
                      else
                      {
                        MEMORY[0x1E0C80A78](v132, v133);
                        v136 = &v152[-((v135 + 15) & 0xFFFFFFFFFFFFFFF0)];
                        bzero(v136, v135);
                      }
                    }
                    else
                    {
                      v136 = malloc_type_malloc(2 * v132, 0x1000040BDFB0063uLL);
                    }
                    v137 = (UChar *)CFStringGetCharactersPtr(v131);
                    if (!v137)
                    {
                      v167.location = 0;
                      v167.length = v134;
                      CFStringGetCharacters(v131, v167, (UniChar *)v136);
                      v137 = (UChar *)v136;
                    }
                    __cficu_udat_applyPattern(*(_QWORD *)(v5 + 16), 0, v137, v134);
                    v138 = *(const void **)(v5 + 48);
                    if (v138)
                      CFRelease(v138);
                    v139 = CFGetAllocator((CFTypeRef)v5);
                    *(_QWORD *)(v5 + 48) = CFStringCreateCopy(v139, v131);
                    if (v135 >= 0x101)
                      free(v136);
                  }
                  CFRelease(v131);
                  CFRelease(v130);
                }
LABEL_207:
                v140 = *(const void **)(v5 + 56);
                if (v140)
                  CFRelease(v140);
                v141 = *(CFTypeRef *)(v5 + 48);
                if (v141)
                  v141 = CFRetain(v141);
                *(_QWORD *)(v5 + 56) = v141;
                v142 = *(__CFString **)(v5 + 64);
                if (v142)
                  __CFDateFormatterSetProperty(v5, CFSTR("kCFDateFormatterIsLenientKey"), v142, 1);
                v143 = *(__CFString **)(v5 + 72);
                if (v143)
                  __CFDateFormatterSetProperty(v5, CFSTR("kCFDateFormatterDoesRelativeDateFormattingKey"), v143, 1);
                v144 = *(__CFString **)(v5 + 96);
                if (v144)
                  __CFDateFormatterSetProperty(v5, CFSTR("kCFDateFormatterCalendarKey"), v144, 1);
                v145 = *(__CFString **)(v5 + 104);
                if (v145)
                  __CFDateFormatterSetProperty(v5, CFSTR("kCFDateFormatterCalendarIdentifierKey"), v145, 1);
                if (*v11)
                  __CFDateFormatterSetProperty(v5, CFSTR("kCFDateFormatterTimeZoneKey"), (__CFString *)*v11, 1);
                v146 = *(__CFString **)(v5 + 112);
                if (v146)
                  __CFDateFormatterSetProperty(v5, CFSTR("kCFDateFormatterTwoDigitStartDateKey"), v146, 1);
                v147 = *(__CFString **)(v5 + 120);
                if (v147)
                  __CFDateFormatterSetProperty(v5, CFSTR("kCFDateFormatterDefaultDateKey"), v147, 1);
                v148 = *(__CFString **)(v5 + 128);
                if (v148)
                  __CFDateFormatterSetProperty(v5, CFSTR("kCFDateFormatterGregorianStartDateKey"), v148, 1);
                v149 = *(__CFString **)(v5 + 296);
                if (v149)
                  __CFDateFormatterSetProperty(v5, CFSTR("kCFDateFormatterAmbiguousYearStrategyKey"), v149, 1);
                v150 = *(__CFString **)(v5 + 304);
                if (v150)
                  __CFDateFormatterSetProperty(v5, CFSTR("kCFDateFormatterUsesCharacterDirectionKey"), v150, 1);
                v151 = *(__CFString **)(v5 + 312);
                if (v151)
                  __CFDateFormatterSetProperty(v5, CFSTR("kCFDateFormatterFormattingContextKey"), v151, 1);
                goto LABEL_233;
              }
              v159[0] = 0;
              MinimumDaysInFirstWeek = v160[0];
              v101 = (uint64_t)UCalendar;
            }
            __cficu_ucal_setAttribute(v101, 2u, MinimumDaysInFirstWeek);
            goto LABEL_139;
          }
          v159[0] = 0;
          FirstWeekday = v160[0];
          v98 = (uint64_t)UCalendar;
        }
        __cficu_ucal_setAttribute(v98, 1u, FirstWeekday);
        goto LABEL_136;
      }
      v159[0] = 0;
      v104 = __cficu_ucal_getGregorianChange(Calendar, v159);
      if (v159[0] <= 0)
        v105 = v104 / 1000.0 - 978307200.0;
      else
        v105 = -1.31976e10;
      v95 = v105 + 978307200.0;
      v159[0] = 0;
    }
    __cficu_ucal_setGregorianChange((uint64_t)UCalendar, v159, v95 * 1000.0);
    goto LABEL_133;
  }
LABEL_233:
  objc_autoreleasePoolPop(v6);
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)-[__CFLocale objectForKey:](locale, "objectForKey:", key);
}

void __CFDateFormatterSetProperty(uint64_t a1, const __CFString *cf1, __CFString *theArray, int a4)
{
  const __CFArray *v8;
  CFTypeRef v9;
  __objc2_class **v10;
  const void *v11;
  CFAllocatorRef v12;
  void *v13;
  id CopyWithNewCalendarIdentifier;
  const void *v15;
  const __CFString *Identifier;
  const __CFDictionary *ComponentsFromLocaleIdentifier;
  __CFDictionary *MutableCopy;
  const __CFString *LocaleIdentifierFromComponents;
  const __CFAllocator *v20;
  CFLocaleRef v21;
  CFTypeRef v22;
  CFTypeRef v23;
  void *v24;
  const void *v25;
  CFTypeRef v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  CFIndex Length;
  uint64_t v31;
  uint64_t v32;
  CFIndex v33;
  uint64_t v34;
  UniChar *v35;
  const UniChar *CharactersPtr;
  UChar *v37;
  CFStringRef Copy;
  CFIndex v39;
  uint64_t v40;
  uint64_t v41;
  CFIndex v42;
  uint64_t v43;
  UniChar *v44;
  const UniChar *v45;
  UChar *v46;
  CFStringRef v47;
  int valuePtr;
  int v49;
  uint64_t v50;
  CFRange v51;
  CFRange v52;

  v50 = *MEMORY[0x1E0C80C00];
  v49 = 0;
  if (CFSTR("kCFDateFormatterIsLenientKey") == cf1)
  {
    if (a4)
      return;
    v8 = *(const __CFArray **)(a1 + 64);
    *(_QWORD *)(a1 + 64) = 0;
    if (theArray)
      v9 = CFRetain(theArray);
    else
      v9 = 0;
    *(_QWORD *)(a1 + 64) = v9;
LABEL_59:
    __ResetUDateFormat(a1, 0);
    goto LABEL_60;
  }
  if (CFSTR("kCFDateFormatterDoesRelativeDateFormattingKey") == cf1)
  {
    if (a4)
      return;
    v8 = *(const __CFArray **)(a1 + 72);
    *(_QWORD *)(a1 + 72) = 0;
    if (&__kCFBooleanTrue == (__objc2_class **)theArray)
      v10 = (__objc2_class **)theArray;
    else
      v10 = &__kCFBooleanFalse;
    if (v10)
      v10 = (__objc2_class **)CFRetain(v10);
    *(_QWORD *)(a1 + 72) = v10;
    goto LABEL_59;
  }
  if (CFSTR("kCFDateFormatterCalendarKey") == cf1)
  {
    if (a4)
    {
      v8 = 0;
    }
    else
    {
      v8 = *(const __CFArray **)(a1 + 96);
      *(_QWORD *)(a1 + 96) = 0;
    }
    v12 = CFGetAllocator(*(CFTypeRef *)(a1 + 24));
    v13 = *(void **)(a1 + 24);
    CFCalendarGetIdentifier((CFCalendarRef)theArray);
    CopyWithNewCalendarIdentifier = _CFLocaleCreateCopyWithNewCalendarIdentifier((uint64_t)v12, v13);
    v15 = *(const void **)(a1 + 24);
    if (v15)
      CFRelease(v15);
    *(_QWORD *)(a1 + 24) = CopyWithNewCalendarIdentifier;
    if (a4)
      goto LABEL_60;
    *(_QWORD *)(a1 + 96) = CFDateFormatterCopyProperty((CFDateFormatterRef)a1, cf1);
    goto LABEL_59;
  }
  if (CFSTR("kCFDateFormatterCalendarIdentifierKey") == cf1)
  {
    if (a4)
    {
      v8 = 0;
    }
    else
    {
      v8 = *(const __CFArray **)(a1 + 104);
      *(_QWORD *)(a1 + 104) = 0;
    }
    Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a1 + 24));
    ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier((CFAllocatorRef)&__kCFAllocatorSystemDefault, Identifier);
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, ComponentsFromLocaleIdentifier);
    CFDictionarySetValue(MutableCopy, CFSTR("calendar"), theArray);
    LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy);
    CFRelease(MutableCopy);
    CFRelease(ComponentsFromLocaleIdentifier);
    v20 = CFGetAllocator(*(CFTypeRef *)(a1 + 24));
    v21 = CFLocaleCreate(v20, LocaleIdentifierFromComponents);
    CFRelease(LocaleIdentifierFromComponents);
    CFRelease(*(CFTypeRef *)(a1 + 24));
    *(_QWORD *)(a1 + 24) = v21;
    if (a4)
      goto LABEL_60;
    *(_QWORD *)(a1 + 104) = CFDateFormatterCopyProperty((CFDateFormatterRef)a1, cf1);
    goto LABEL_59;
  }
  if (CFSTR("kCFDateFormatterTimeZoneKey") == cf1)
  {
    v8 = *(const __CFArray **)(a1 + 88);
    if (v8 == (const __CFArray *)theArray)
      return;
    if (a4)
    {
      v11 = *(const void **)(a1 + 88);
      v8 = 0;
    }
    else
    {
      v11 = 0;
      *(_QWORD *)(a1 + 88) = 0;
    }
    if (theArray)
      v24 = (void *)CFRetain(theArray);
    else
      v24 = CFTimeZoneCopyDefault();
    *(_QWORD *)(a1 + 88) = v24;
    if (v11)
      CFRelease(v11);
    if (!a4)
    {
      v25 = *(const void **)(a1 + 88);
      *(_QWORD *)(a1 + 88) = CFDateFormatterCopyProperty((CFDateFormatterRef)a1, cf1);
      __ResetUDateFormat(a1, 0);
      if (v25)
        CFRelease(v25);
    }
    goto LABEL_60;
  }
  if (CFSTR("kCFDateFormatterDefaultFormatKey") == cf1)
    return;
  if (CFSTR("kCFDateFormatterTwoDigitStartDateKey") == cf1)
  {
    if (a4)
      return;
    v8 = *(const __CFArray **)(a1 + 112);
    *(_QWORD *)(a1 + 112) = 0;
    if (theArray)
      v22 = CFRetain(theArray);
    else
      v22 = 0;
    *(_QWORD *)(a1 + 112) = v22;
    goto LABEL_60;
  }
  if (CFSTR("kCFDateFormatterDefaultDateKey") == cf1)
  {
    if (a4)
      return;
    v8 = *(const __CFArray **)(a1 + 120);
    *(_QWORD *)(a1 + 120) = 0;
    if (theArray)
      v23 = CFRetain(theArray);
    else
      v23 = 0;
    *(_QWORD *)(a1 + 120) = v23;
    goto LABEL_60;
  }
  if (CFSTR("kCFDateFormatterGregorianStartDateKey") == cf1)
  {
    if (a4)
      return;
    v8 = *(const __CFArray **)(a1 + 128);
    *(_QWORD *)(a1 + 128) = 0;
    if (theArray)
      v26 = CFRetain(theArray);
    else
      v26 = 0;
    *(_QWORD *)(a1 + 128) = v26;
    goto LABEL_59;
  }
  if (CFSTR("kCFDateFormatterEraSymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 136);
      *(_QWORD *)(a1 + 136) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 0, 0, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 136) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 0, 0);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 0;
    goto LABEL_111;
  }
  if (CFSTR("kCFDateFormatterLongEraSymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 144);
      *(_QWORD *)(a1 + 144) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 7u, 0, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 144) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 7u, 0);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 7;
    goto LABEL_111;
  }
  if (CFSTR("kCFDateFormatterMonthSymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 152);
      *(_QWORD *)(a1 + 152) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 1u, 0, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 152) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 1u, 0);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 1;
    goto LABEL_111;
  }
  if (CFSTR("kCFDateFormatterShortMonthSymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 160);
      *(_QWORD *)(a1 + 160) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 2u, 0, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 160) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 2u, 0);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 2;
    goto LABEL_111;
  }
  if (CFSTR("kCFDateFormatterVeryShortMonthSymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 168);
      *(_QWORD *)(a1 + 168) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 8u, 0, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 168) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 8u, 0);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 8;
    goto LABEL_111;
  }
  if (CFSTR("kCFDateFormatterStandaloneMonthSymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 176);
      *(_QWORD *)(a1 + 176) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 0xAu, 0, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 176) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 0xAu, 0);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 10;
    goto LABEL_111;
  }
  if (CFSTR("kCFDateFormatterShortStandaloneMonthSymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 184);
      *(_QWORD *)(a1 + 184) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 0xBu, 0, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 184) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 0xBu, 0);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 11;
    goto LABEL_111;
  }
  if (CFSTR("kCFDateFormatterVeryShortStandaloneMonthSymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 192);
      *(_QWORD *)(a1 + 192) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 0xCu, 0, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 192) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 0xCu, 0);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 12;
    goto LABEL_111;
  }
  if (CFSTR("kCFDateFormatterWeekdaySymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 200);
      *(_QWORD *)(a1 + 200) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 3u, 1, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 200) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 3u, 1u);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 3;
    goto LABEL_131;
  }
  if (CFSTR("kCFDateFormatterShortWeekdaySymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 208);
      *(_QWORD *)(a1 + 208) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 4u, 1, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 208) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 4u, 1u);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 4;
    goto LABEL_131;
  }
  if (CFSTR("kCFDateFormatterVeryShortWeekdaySymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 216);
      *(_QWORD *)(a1 + 216) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 9u, 1, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 216) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 9u, 1u);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 9;
    goto LABEL_131;
  }
  if (CFSTR("kCFDateFormatterStandaloneWeekdaySymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 224);
      *(_QWORD *)(a1 + 224) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 0xDu, 1, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 224) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 0xDu, 1u);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 13;
    goto LABEL_131;
  }
  if (CFSTR("kCFDateFormatterShortStandaloneWeekdaySymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 232);
      *(_QWORD *)(a1 + 232) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 0xEu, 1, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 232) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 0xEu, 1u);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 14;
    goto LABEL_131;
  }
  if (CFSTR("kCFDateFormatterVeryShortStandaloneWeekdaySymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 240);
      *(_QWORD *)(a1 + 240) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 0xFu, 1, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 240) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 0xFu, 1u);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 15;
LABEL_131:
    v29 = 1;
    goto LABEL_112;
  }
  if (CFSTR("kCFDateFormatterQuarterSymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 248);
      *(_QWORD *)(a1 + 248) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 0x10u, 0, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 248) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 0x10u, 0);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 16;
    goto LABEL_111;
  }
  if (CFSTR("kCFDateFormatterShortQuarterSymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 256);
      *(_QWORD *)(a1 + 256) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 0x11u, 0, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 256) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 0x11u, 0);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 17;
    goto LABEL_111;
  }
  if (CFSTR("kCFDateFormatterStandaloneQuarterSymbolsKey") == cf1)
  {
    if (!a4)
    {
      v8 = *(const __CFArray **)(a1 + 264);
      *(_QWORD *)(a1 + 264) = 0;
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 0x12u, 0, (CFArrayRef)theArray);
      *(_QWORD *)(a1 + 264) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 0x12u, 0);
      goto LABEL_60;
    }
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 18;
LABEL_111:
    v29 = 0;
LABEL_112:
    __CFDateFormatterSetSymbolsArray(v27, v28, v29, (CFArrayRef)theArray);
    return;
  }
  if (CFSTR("kCFDateFormatterShortStandaloneQuarterSymbolsKey") != cf1)
  {
    if (CFSTR("kCFDateFormatterAMSymbolKey") == cf1)
    {
      if (a4)
      {
        v8 = 0;
      }
      else
      {
        v8 = *(const __CFArray **)(a1 + 280);
        *(_QWORD *)(a1 + 280) = 0;
      }
      Length = CFStringGetLength(theArray);
      v32 = Length;
      if (Length >= 768)
        v33 = 768;
      else
        v33 = Length;
      MEMORY[0x1E0C80A78](Length, v31);
      v35 = (UniChar *)((char *)&valuePtr - v34);
      CharactersPtr = CFStringGetCharactersPtr(theArray);
      if (CharactersPtr)
      {
        v37 = (UChar *)CharactersPtr;
      }
      else
      {
        v51.location = 0;
        v51.length = v33;
        CFStringGetCharacters(theArray, v51, v35);
        v37 = v35;
        v32 = v33;
      }
      __cficu_udat_setSymbols(*(_QWORD *)(a1 + 16), 5u, 0, v37, v32, &v49);
      if (!a4)
      {
        Copy = 0;
        if (theArray)
          Copy = CFStringCreateCopy(0, theArray);
        *(_QWORD *)(a1 + 280) = Copy;
      }
    }
    else if (CFSTR("kCFDateFormatterPMSymbolKey") == cf1)
    {
      if (a4)
      {
        v8 = 0;
      }
      else
      {
        v8 = *(const __CFArray **)(a1 + 288);
        *(_QWORD *)(a1 + 288) = 0;
      }
      v39 = CFStringGetLength(theArray);
      v41 = v39;
      if (v39 >= 768)
        v42 = 768;
      else
        v42 = v39;
      MEMORY[0x1E0C80A78](v39, v40);
      v44 = (UniChar *)((char *)&valuePtr - v43);
      v45 = CFStringGetCharactersPtr(theArray);
      if (v45)
      {
        v46 = (UChar *)v45;
      }
      else
      {
        v52.location = 0;
        v52.length = v42;
        CFStringGetCharacters(theArray, v52, v44);
        v41 = v42;
        v46 = v44;
      }
      __cficu_udat_setSymbols(*(_QWORD *)(a1 + 16), 5u, 1, v46, v41, &v49);
      if (!a4)
      {
        v47 = 0;
        if (theArray)
          v47 = CFStringCreateCopy(0, theArray);
        *(_QWORD *)(a1 + 288) = v47;
      }
    }
    else if (CFSTR("kCFDateFormatterAmbiguousYearStrategyKey") == cf1)
    {
      v8 = *(const __CFArray **)(a1 + 296);
      *(_QWORD *)(a1 + 296) = 0;
      *(_QWORD *)(a1 + 296) = CFRetain(theArray);
    }
    else if (CFSTR("kCFDateFormatterUsesCharacterDirectionKey") == cf1)
    {
      v8 = *(const __CFArray **)(a1 + 304);
      *(_QWORD *)(a1 + 304) = CFRetain(theArray);
    }
    else
    {
      if (!CFEqual(cf1, CFSTR("kCFDateFormatterFormattingContextKey")))
        return;
      if (a4)
      {
        v8 = 0;
      }
      else
      {
        v8 = *(const __CFArray **)(a1 + 312);
        *(_QWORD *)(a1 + 312) = 0;
      }
      valuePtr = 0;
      CFNumberGetValue((CFNumberRef)theArray, kCFNumberIntType, &valuePtr);
      __cficu_udat_setContext(*(_QWORD *)(a1 + 16), valuePtr, &v49);
      if (!a4)
        *(_QWORD *)(a1 + 312) = CFRetain(theArray);
    }
    goto LABEL_60;
  }
  if (a4)
  {
    v27 = *(_QWORD *)(a1 + 16);
    v28 = 19;
    goto LABEL_111;
  }
  v8 = *(const __CFArray **)(a1 + 272);
  *(_QWORD *)(a1 + 272) = 0;
  __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), 0x13u, 0, (CFArrayRef)theArray);
  *(_QWORD *)(a1 + 272) = __CFDateFormatterCopySymbolsArray(*(_QWORD *)(a1 + 16), 0x13u, 0);
LABEL_60:
  if (v8)
    CFRelease(v8);
}

void __cficu_udat_applyPattern(uint64_t a1, int a2, UChar *a3, uint64_t a4)
{
  CFStringRef v8;
  CFStringRef v9;

  udat_applyPattern();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v8 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0);
    v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, CFSTR("udat_applyPattern(%@, %d, %@, %d);"), v9, a2, v8, a4);
    CFRelease(v8);
    CFRelease(v9);
  }
}

void __substituteFormatStringFromPrefsDF(uint64_t a1, int a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  const __CFString *v5;
  BOOL v6;
  int v9;
  const __CFString *Identifier;
  const char *CStringPtr;
  int v12;
  int v13;
  uint64_t v14;
  const void *v15;
  int v16;
  const __CFString *v17;
  int v18;
  int v19;
  CFMutableStringRef Mutable;
  CFIndex Length;
  uint64_t v22;
  uint64_t v23;
  UniChar *v24;
  UChar *CharactersPtr;
  CFRange v26;
  int v27;
  UniChar v28[768];
  char v29[768];
  uint64_t v30;
  CFRange v31;
  CFRange v32;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = 40;
  if (a2)
    v2 = 32;
  v3 = *(_QWORD *)(a1 + v2);
  v4 = 464;
  if (a2)
    v4 = 472;
  v5 = *(const __CFString **)(a1 + v4);
  if (v3)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (!v6)
  {
    if (v3 >= 5)
      v9 = -1;
    else
      v9 = 4 - v3;
    Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a1 + 24));
    CStringPtr = CFStringGetCStringPtr(Identifier, 0x600u);
    if (!CStringPtr)
    {
      if (CFStringGetCString(Identifier, v29, 768, 0x600u))
        CStringPtr = v29;
      else
        CStringPtr = 0;
    }
    v27 = 0;
    if (a2)
      v12 = v9;
    else
      v12 = -1;
    if (a2)
      v13 = -1;
    else
      v13 = v9;
    v14 = __cficu_udat_open(v12, v13, (uint64_t)CStringPtr, 0, 0, 0, 0, &v27);
    if (v14)
    {
      v15 = (const void *)v14;
      v27 = 0;
      v16 = __cficu_udat_toPattern(v14, 0, v28, 768, &v27);
      if (v27 <= 0 && v16 <= 768)
      {
        v17 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v28, v16);
        v27 = 0;
        v18 = __cficu_udat_toPattern(*(_QWORD *)(a1 + 16), 0, v28, 768, &v27);
        if (v27 <= 0)
        {
          v19 = v18;
          if (v18 <= 768)
          {
            Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
            CFStringAppendCharacters(Mutable, v28, v19);
            v26.location = 0;
            v26.length = 0;
            v32.location = 0;
            v32.length = v19;
            if (CFStringFindWithOptions(Mutable, v17, v32, 0, &v26))
            {
              CFStringReplace(Mutable, v26, v5);
              Length = CFStringGetLength(Mutable);
              MEMORY[0x1E0C80A78](Length, v22);
              v24 = (UniChar *)((char *)&v26 - ((v23 + 15) & 0x3FFFFFFF0));
              CharactersPtr = (UChar *)CFStringGetCharactersPtr(Mutable);
              if (!CharactersPtr)
              {
                v31.length = (int)Length;
                v31.location = 0;
                CFStringGetCharacters(Mutable, v31, v24);
                CharactersPtr = v24;
              }
              v27 = 0;
              __cficu_udat_applyPattern(*(_QWORD *)(a1 + 16), 0, CharactersPtr, Length);
            }
            CFRelease(Mutable);
          }
        }
        CFRelease(v17);
      }
      __cficu_udat_close(v15);
    }
  }
}

CFTypeRef CFDateFormatterCopyProperty(CFDateFormatterRef formatter, CFDateFormatterKey key)
{
  unint64_t v4;
  CFTypeRef result;
  const __CFAllocator *v6;
  int isLenient;
  CFTypeRef *v8;
  const __CFLocale *v9;
  CFLocaleKey *v10;
  uint64_t Calendar;
  double v12;
  uint64_t v13;
  unsigned int v14;
  CFAbsoluteTime v15;
  const __CFAllocator *v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int Symbols;
  CFIndex v24;
  const __CFAllocator *v25;
  int v26;
  UniChar valuePtr[768];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v4);
  v26 = 0;
  if (CFSTR("kCFDateFormatterIsLenientKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 8);
    if (result)
      return CFRetain(result);
    isLenient = __cficu_udat_isLenient(*((_QWORD *)formatter + 2));
    v8 = (CFTypeRef *)&kCFBooleanTrue;
    if (!isLenient)
      v8 = (CFTypeRef *)&kCFBooleanFalse;
LABEL_42:
    result = *v8;
    return CFRetain(result);
  }
  if (CFSTR("kCFDateFormatterDoesRelativeDateFormattingKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 9);
    if (result)
      return CFRetain(result);
LABEL_41:
    v8 = (CFTypeRef *)&kCFBooleanFalse;
    goto LABEL_42;
  }
  if (CFSTR("kCFDateFormatterCalendarKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 12);
    if (result)
      return CFRetain(result);
    v9 = (const __CFLocale *)*((_QWORD *)formatter + 3);
    v10 = (CFLocaleKey *)&kCFLocaleCalendarKey;
    goto LABEL_47;
  }
  if (CFSTR("kCFDateFormatterCalendarIdentifierKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 13);
    if (result)
      return CFRetain(result);
    v9 = (const __CFLocale *)*((_QWORD *)formatter + 3);
    v10 = (CFLocaleKey *)&kCFLocaleCalendarIdentifierKey;
LABEL_47:
    result = CFLocaleGetValue(v9, *v10);
    if (result)
      return CFRetain(result);
    return result;
  }
  if (CFSTR("kCFDateFormatterTimeZoneKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 11);
    if (result)
      return CFRetain(result);
    return result;
  }
  if (CFSTR("kCFDateFormatterDefaultFormatKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 7);
    if (result)
      return CFRetain(result);
    return result;
  }
  if (CFSTR("kCFDateFormatterTwoDigitStartDateKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 14);
    if (result)
      return CFRetain(result);
    return result;
  }
  if (CFSTR("kCFDateFormatterDefaultDateKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 15);
    if (result)
      return CFRetain(result);
    return result;
  }
  if (CFSTR("kCFDateFormatterGregorianStartDateKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 16);
    if (result)
      return CFRetain(result);
    Calendar = __cficu_udat_getCalendar(*((_QWORD *)formatter + 2));
    v12 = __cficu_ucal_getGregorianChange(Calendar, &v26);
    if (v26 > 0)
      return 0;
    v15 = v12 / 1000.0 - 978307200.0;
    v16 = CFGetAllocator(formatter);
    return CFDateCreate(v16, v15);
  }
  if (CFSTR("kCFDateFormatterEraSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 17);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 0;
    goto LABEL_79;
  }
  if (CFSTR("kCFDateFormatterLongEraSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 18);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 7;
    goto LABEL_79;
  }
  if (CFSTR("kCFDateFormatterMonthSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 19);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 1;
    goto LABEL_79;
  }
  if (CFSTR("kCFDateFormatterShortMonthSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 20);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 2;
    goto LABEL_79;
  }
  if (CFSTR("kCFDateFormatterVeryShortMonthSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 21);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 8;
    goto LABEL_79;
  }
  if (CFSTR("kCFDateFormatterStandaloneMonthSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 22);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 10;
    goto LABEL_79;
  }
  if (CFSTR("kCFDateFormatterShortStandaloneMonthSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 23);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 11;
    goto LABEL_79;
  }
  if (CFSTR("kCFDateFormatterVeryShortStandaloneMonthSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 24);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 12;
    goto LABEL_79;
  }
  if (CFSTR("kCFDateFormatterWeekdaySymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 25);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 3;
    goto LABEL_93;
  }
  if (CFSTR("kCFDateFormatterShortWeekdaySymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 26);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 4;
    goto LABEL_93;
  }
  if (CFSTR("kCFDateFormatterVeryShortWeekdaySymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 27);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 9;
    goto LABEL_93;
  }
  if (CFSTR("kCFDateFormatterStandaloneWeekdaySymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 28);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 13;
    goto LABEL_93;
  }
  if (CFSTR("kCFDateFormatterShortStandaloneWeekdaySymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 29);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 14;
    goto LABEL_93;
  }
  if (CFSTR("kCFDateFormatterVeryShortStandaloneWeekdaySymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 30);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 15;
LABEL_93:
    v17 = 1;
    return __CFDateFormatterCopySymbolsArray(v13, v14, v17);
  }
  if (CFSTR("kCFDateFormatterQuarterSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 31);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 16;
    goto LABEL_79;
  }
  if (CFSTR("kCFDateFormatterShortQuarterSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 32);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 17;
    goto LABEL_79;
  }
  if (CFSTR("kCFDateFormatterStandaloneQuarterSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 33);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 18;
    goto LABEL_79;
  }
  if (CFSTR("kCFDateFormatterShortStandaloneQuarterSymbolsKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 34);
    if (result)
      return CFRetain(result);
    v13 = *((_QWORD *)formatter + 2);
    v14 = 19;
LABEL_79:
    v17 = 0;
    return __CFDateFormatterCopySymbolsArray(v13, v14, v17);
  }
  if (CFSTR("kCFDateFormatterAMSymbolKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 35);
    if (result)
      return CFRetain(result);
    v18 = __cficu_udat_countSymbols(*((_QWORD *)formatter + 2), 5u);
    if (v18 < 2)
      return 0;
    v19 = v18;
    v20 = *((_QWORD *)formatter + 2);
    v21 = 0;
    goto LABEL_108;
  }
  if (CFSTR("kCFDateFormatterPMSymbolKey") == key)
  {
    result = (CFTypeRef)*((_QWORD *)formatter + 36);
    if (result)
      return CFRetain(result);
    v22 = __cficu_udat_countSymbols(*((_QWORD *)formatter + 2), 5u);
    if (v22 < 2)
      return 0;
    v19 = v22;
    v20 = *((_QWORD *)formatter + 2);
    v21 = 1;
LABEL_108:
    Symbols = __cficu_udat_getSymbols(v20, 5u, v21, valuePtr, 768, &v26);
    result = 0;
    if (v19 <= 0x300 && v26 <= 0)
    {
      v24 = Symbols;
      v25 = CFGetAllocator(formatter);
      return CFStringCreateWithCharacters(v25, valuePtr, v24);
    }
    return result;
  }
  if (CFSTR("kCFDateFormatterAmbiguousYearStrategyKey") != key)
  {
    if (CFSTR("kCFDateFormatterUsesCharacterDirectionKey") != key)
    {
      if (CFEqual(key, CFSTR("kCFDateFormatterFormattingContextKey")))
      {
        result = (CFTypeRef)*((_QWORD *)formatter + 39);
        if (!result)
        {
          *(_DWORD *)valuePtr = __cficu_udat_getContext(*((_QWORD *)formatter + 2), 1, &v26);
          v6 = CFGetAllocator(formatter);
          return CFNumberCreate(v6, kCFNumberIntType, valuePtr);
        }
        return CFRetain(result);
      }
      return 0;
    }
    result = (CFTypeRef)*((_QWORD *)formatter + 38);
    if (result)
      return CFRetain(result);
    goto LABEL_41;
  }
  result = (CFTypeRef)*((_QWORD *)formatter + 37);
  if (result)
    return CFRetain(result);
  return result;
}

CFTypeRef __CFDateFormatterCreateForcedString(_QWORD *a1, const __CFString *a2)
{
  const __CFBoolean *v4;
  int v5;
  CFTypeRef v6;
  const __CFBoolean *v7;
  const __CFCharacterSet *v8;
  const __CFLocale *v9;
  int v10;
  _QWORD v12[7];
  int v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  CFRange result;
  uint64_t v23;
  CFRange v24;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  v4 = (const __CFBoolean *)a1[61];
  if (v4)
    v5 = (CFBooleanGetValue(v4) != 0) << 29;
  else
    v5 = 0;
  v7 = (const __CFBoolean *)a1[60];
  if (v7 && CFBooleanGetValue(v7))
  {
    v5 = 0x40000000;
  }
  else if (!v5)
  {
    return CFRetain(a2);
  }
  if (__CFDateFormatterCreateForcedString_onceToken != -1)
    dispatch_once(&__CFDateFormatterCreateForcedString_onceToken, &__block_literal_global_31);
  result = (CFRange)xmmword_182C87F40;
  v8 = (const __CFCharacterSet *)__CFDateFormatterCreateForcedString_hourCharacters;
  v24.length = CFStringGetLength(a2);
  v24.location = 0;
  if (CFStringFindCharacterFromSet(a2, v8, v24, 0, &result) && result.location != -1)
  {
    v18 = 0;
    v19 = &v18;
    v20 = 0x2020000000;
    v21 = 0;
    v14 = 0;
    v15 = (int *)&v14;
    v16 = 0x2020000000;
    v17 = 0;
    v9 = (const __CFLocale *)a1[3];
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = ____CFDateFormatterCreateForcedString_block_invoke_2;
    v12[3] = &unk_1E12E1460;
    v12[5] = &v18;
    v12[6] = a2;
    v13 = v5;
    v12[4] = &v14;
    v10 = useTemplatePatternGenerator(v9, (uint64_t)v12);
    v6 = (CFTypeRef)v19[3];
    if (v10)
    {
      if (v6)
      {
        if (v15[6] > 0)
        {
LABEL_23:
          _Block_object_dispose(&v14, 8);
          _Block_object_dispose(&v18, 8);
          return v6;
        }
        goto LABEL_21;
      }
    }
    else if (v6)
    {
LABEL_21:
      CFRelease((CFTypeRef)v19[3]);
    }
    v6 = CFRetain(a2);
    goto LABEL_23;
  }
  return CFRetain(a2);
}

void sub_182B68E48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10;
  va_list va;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v10 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __cficu_udat_getSymbols(uint64_t a1, unsigned int a2, uint64_t a3, const UniChar *a4, uint64_t a5, int *a6)
{
  uint64_t Symbols;
  CFStringRef v13;
  const void *v14;
  CFTypeRef v15;
  CFStringRef v16;
  CFStringRef v17;
  const char *v18;

  Symbols = udat_getSymbols();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    v15 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a4, a5);
    v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    if (*a6 <= 0)
      v17 = CFStringCreateWithCharacters(0, a4, (int)Symbols);
    else
      v17 = 0;
    v18 = ___CFICUGetEnumStringForUDateFormatSymbolType(a2);
    ___CFICULogWithArguments(1, CFSTR("udat_getSymbols(%@, %s, %d, %@, %d, &%@); // %d %@ %@"),
      v13,
      v18,
      a3,
      v15,
      a5,
      v14,
      Symbols,
      v17,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    if (v17)
      CFRelease(v17);
    CFRelease(v16);
  }
  return Symbols;
}

uint64_t __cficu_udat_countSymbols(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  CFStringRef v5;
  const char *v6;

  v4 = udat_countSymbols();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v6 = ___CFICUGetEnumStringForUDateFormatSymbolType(a2);
    ___CFICULogWithArguments(1, CFSTR("udat_countSymbols(%@, %s);
    CFRelease(v5);
  }
  return v4;
}

void __cficu_ucal_setAttribute(uint64_t a1, unsigned int a2, int a3)
{
  CFStringRef v6;
  NSObject *v7;
  const char *v8;
  int v9;
  CFStringRef v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  ucal_setAttribute();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v7 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        if (a2 > 4)
          v8 = "<unknown UCalendarAttribute>";
        else
          v8 = off_1E1333F80[a2];
        v9 = 138412802;
        v10 = v6;
        v11 = 2080;
        v12 = v8;
        v13 = 1024;
        v14 = a3;
        _os_log_debug_impl(&dword_182A8C000, v7, OS_LOG_TYPE_DEBUG, "ucal_setAttribute(%@, %s, %d);",
          (uint8_t *)&v9,
          0x1Cu);
      }
      CFRelease(v6);
    }
  }
}

uint64_t _CFLocaleGetAppleICUForce24HourTimePref(void *a1, const char *a2)
{
  return objc_msgSend(a1, "_prefForKey:", CFSTR("AppleICUForce24HourTime"));
}

uint64_t _CFLocaleGetAppleICUForce12HourTimePref(void *a1, const char *a2)
{
  return objc_msgSend(a1, "_prefForKey:", CFSTR("AppleICUForce12HourTime"));
}

void __cficu_ucal_close(const void *a1)
{
  CFStringRef v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (!os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    ucal_close();
    return;
  }
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
  }
  else
  {
    v2 = 0;
  }
  ucal_close();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled != 1)
    goto LABEL_16;
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  v3 = _NSCFCalendarLogger__logger;
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    __cficu_ucal_close_cold_1((uint64_t)v2, v3, v4, v5, v6, v7, v8, v9);
    if (!v2)
      return;
  }
  else
  {
LABEL_16:
    if (!v2)
      return;
  }
  CFRelease(v2);
}

uint64_t __cficu_udat_getCalendar(uint64_t a1)
{
  uint64_t Calendar;
  const void *v3;
  CFStringRef v4;

  Calendar = udat_getCalendar();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v3 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"cal", Calendar);
    v4 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, CFSTR("const UCalendar *%@ = udat_getCalendar(%@);"), v3, v4);
    CFRelease(v4);
    CFRelease(v3);
  }
  return Calendar;
}

void __cficu_udat_set2DigitYearStart(uint64_t a1, int *a2, double a3)
{
  CFStringRef v6;
  const void *v7;
  CFStringRef v8;
  CFStringRef v9;

  udat_set2DigitYearStart();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    v8 = ___CFICUCreateArgumentForDouble(a3);
    v9 = ___CFICUCreateErrorStringWithComment(a2, 1);
    ___CFICULogWithArguments(1, CFSTR("udat_set2DigitYearStart(%@, %@, &%@); %@"), v6, v8, v7, v9);
    CFRelease(v7);
    CFRelease(v6);
    CFRelease(v8);
    CFRelease(v9);
  }
}

void __ApplyUDateFormatSymbol(uint64_t a1)
{
  uint64_t v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  const __CFArray *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  char v18;
  const __CFString *v19;
  CFIndex Length;
  uint64_t v21;
  uint64_t v22;
  CFIndex v23;
  uint64_t v24;
  UniChar *v25;
  const UniChar *CharactersPtr;
  UChar *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  _OWORD v32[9];
  _OWORD v33[9];
  _DWORD v34[8];
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  CFRange v39;

  v2 = 0;
  v38 = *MEMORY[0x1E0C80C00];
  v37 = 0;
  *(_QWORD *)&v3 = 0x100000001;
  *((_QWORD *)&v3 + 1) = 0x100000001;
  v35 = v3;
  v36 = 0u;
  *(_QWORD *)&v36 = 0x100000001;
  v4 = *(_OWORD *)(a1 + 152);
  v33[0] = *(_OWORD *)(a1 + 136);
  v33[1] = v4;
  v5 = *(_OWORD *)(a1 + 184);
  v33[2] = *(_OWORD *)(a1 + 168);
  v33[3] = v5;
  v6 = *(_OWORD *)(a1 + 216);
  v33[4] = *(_OWORD *)(a1 + 200);
  v33[5] = v6;
  v7 = *(_OWORD *)(a1 + 248);
  v33[6] = *(_OWORD *)(a1 + 232);
  v33[7] = v7;
  v33[8] = *(_OWORD *)(a1 + 264);
  memset(v34, 0, sizeof(v34));
  v8 = *(_OWORD *)(a1 + 336);
  v32[0] = *(_OWORD *)(a1 + 320);
  v32[1] = v8;
  v9 = *(_OWORD *)(a1 + 368);
  v32[2] = *(_OWORD *)(a1 + 352);
  v32[3] = v9;
  v10 = *(_OWORD *)(a1 + 400);
  v32[4] = *(_OWORD *)(a1 + 384);
  v32[5] = v10;
  v11 = *(_OWORD *)(a1 + 432);
  v32[6] = *(_OWORD *)(a1 + 416);
  v12 = *(_OWORD *)(a1 + 448);
  v32[7] = v11;
  v32[8] = v12;
  do
  {
    v13 = (const __CFArray *)*((_QWORD *)v33 + v2);
    if (v13 || (v13 = (const __CFArray *)*((_QWORD *)v32 + v2)) != 0)
      __CFDateFormatterSetSymbolsArray(*(_QWORD *)(a1 + 16), dword_182C87EF4[v2], v34[v2], v13);
    ++v2;
  }
  while (v2 != 18);
  v30 = 0;
  v31 = 0;
  v14 = *(_QWORD *)(a1 + 280);
  if (v14 || (v14 = *(_QWORD *)(a1 + 496)) != 0)
    v30 = v14;
  v15 = *(_QWORD *)(a1 + 288);
  if (v15 || (v15 = *(_QWORD *)(a1 + 504)) != 0)
    v31 = v15;
  v16 = 0;
  v17 = 1;
  do
  {
    v18 = v17;
    v19 = (const __CFString *)*(&v30 + v16);
    if (v19)
    {
      Length = CFStringGetLength((CFStringRef)*(&v30 + v16));
      v22 = Length;
      if (Length >= 768)
        v23 = 768;
      else
        v23 = Length;
      MEMORY[0x1E0C80A78](Length, v21);
      v25 = (UniChar *)((char *)&v28 - v24);
      CharactersPtr = CFStringGetCharactersPtr(v19);
      if (CharactersPtr)
      {
        v27 = (UChar *)CharactersPtr;
      }
      else
      {
        v39.location = 0;
        v39.length = v23;
        CFStringGetCharacters(v19, v39, v25);
        v22 = v23;
        v27 = v25;
      }
      v29 = 0;
      __cficu_udat_setSymbols(*(_QWORD *)(a1 + 16), 5u, v16, v27, v22, &v29);
    }
    v17 = 0;
    v16 = 1;
  }
  while ((v18 & 1) != 0);
}

void __cficu_udat_setCalendar(uint64_t a1, uint64_t a2)
{
  CFStringRef v4;
  CFStringRef v5;

  udat_setCalendar();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v4 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a2);
    ___CFICULogWithArguments(1, CFSTR("udat_setCalendar(%@, %@);"), v4, v5);
    CFRelease(v4);
    CFRelease(v5);
  }
}

uint64_t __cficu_udat_open(int a1, int a2, uint64_t a3, UChar *a4, uint64_t a5, UChar *a6, uint64_t a7, void *a8)
{
  uint64_t v16;
  const void *v17;
  CFStringRef v18;
  CFStringRef v19;
  CFStringRef v20;
  const char *v21;
  const char *v22;
  const void *v24;

  v16 = udat_open();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v24 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", v16);
    v17 = (const void *)___CFICUCreateVariableNameForStatus(a8);
    v18 = ___CFICUCreateErrorStringWithComment((int *)a8, 1);
    v19 = ___CFICUCreateArgumentForUCharInput(a4, a5, 0);
    v20 = ___CFICUCreateArgumentForUCharInput(a6, a7, 1);
    v21 = ___CFICUGetEnumStringForUDateFormatStyle(a1);
    v22 = ___CFICUGetEnumStringForUDateFormatStyle(a2);
    ___CFICULogWithArguments(1, CFSTR("UDateFormat *%@ = udat_open(%s, %s, \"%s\", %@, %d, %@, %d, &%@); %@"),
      v24,
      v21,
      v22,
      a3,
      v19,
      a5,
      v20,
      a7,
      v17,
      v18);
    CFRelease(v19);
    CFRelease(v20);
    CFRelease(v24);
    CFRelease(v17);
    CFRelease(v18);
  }
  return v16;
}

void __cficu_ucal_setTimeZone(uint64_t a1, UChar *a2, int32_t a3, int *a4)
{
  CFStringRef v8;
  const void *v9;
  CFStringRef v10;
  CFStringRef v11;
  NSObject *v12;
  int v13;
  CFStringRef v14;
  __int16 v15;
  CFStringRef v16;
  __int16 v17;
  int32_t v18;
  __int16 v19;
  const void *v20;
  __int16 v21;
  CFStringRef v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  ucal_setTimeZone();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v8 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v9 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      v10 = ___CFICUCreateErrorStringWithComment(a4, 1);
      v11 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v12 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v13 = 138413314;
        v14 = v8;
        v15 = 2112;
        v16 = v11;
        v17 = 1024;
        v18 = a3;
        v19 = 2112;
        v20 = v9;
        v21 = 2112;
        v22 = v10;
        _os_log_debug_impl(&dword_182A8C000, v12, OS_LOG_TYPE_DEBUG, "ucal_setTimeZone(%@, %@, %d, &%@); %@",
          (uint8_t *)&v13,
          0x30u);
      }
      CFRelease(v11);
      CFRelease(v8);
      CFRelease(v9);
      CFRelease(v10);
    }
  }
}

void __cficu_ucal_setGregorianChange(uint64_t a1, int *a2, double a3)
{
  CFStringRef v6;
  const void *v7;
  CFStringRef v8;
  CFStringRef v9;
  NSObject *v10;
  int v11;
  CFStringRef v12;
  __int16 v13;
  CFStringRef v14;
  __int16 v15;
  const void *v16;
  __int16 v17;
  CFStringRef v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  ucal_setGregorianChange();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      v8 = ___CFICUCreateArgumentForDouble(a3);
      v9 = ___CFICUCreateErrorStringWithComment(a2, 1);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v10 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v11 = 138413058;
        v12 = v6;
        v13 = 2112;
        v14 = v8;
        v15 = 2112;
        v16 = v7;
        v17 = 2112;
        v18 = v9;
        _os_log_debug_impl(&dword_182A8C000, v10, OS_LOG_TYPE_DEBUG, "ucal_setGregorianChange(%@, %@, &%@); %@",
          (uint8_t *)&v11,
          0x2Au);
      }
      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }
}

double __cficu_ucal_getGregorianChange(uint64_t a1, int *a2)
{
  double v4;
  double v5;
  CFStringRef v6;
  const void *v7;
  CFStringRef v8;
  NSObject *v9;
  int v11;
  CFStringRef v12;
  __int16 v13;
  const void *v14;
  __int16 v15;
  double v16;
  __int16 v17;
  CFStringRef v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  ucal_getGregorianChange();
  v5 = v4;
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      v8 = ___CFICUCreateErrorStringWithComment(a2, 0);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v9 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v11 = 138413058;
        v12 = v6;
        v13 = 2112;
        v14 = v7;
        v15 = 2048;
        v16 = v5;
        v17 = 2112;
        v18 = v8;
        _os_log_debug_impl(&dword_182A8C000, v9, OS_LOG_TYPE_DEBUG, "ucal_getGregorianChange(%@, &%@); // %f %@",
          (uint8_t *)&v11,
          0x2Au);
      }
      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
    }
  }
  return v5;
}

uint64_t _CFLocaleGetAppleICUTimeFormatStringsPref(void *a1, const char *a2)
{
  return objc_msgSend(a1, "_prefForKey:", CFSTR("AppleICUTimeFormatStrings"));
}

uint64_t _CFLocaleGetAppleICUDateFormatStringsPref(void *a1, const char *a2)
{
  return objc_msgSend(a1, "_prefForKey:", CFSTR("AppleICUDateFormatStrings"));
}

void __cficu_udat_setLenient(uint64_t a1, int a2)
{
  CFStringRef v4;

  udat_setLenient();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v4 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, CFSTR("udat_setLenient(%@, %d);"), v4, a2);
    CFRelease(v4);
  }
}

uint64_t _CFLocaleGetAppleMinDaysInFirstWeekPref(void *a1, const char *a2)
{
  return objc_msgSend(a1, "_prefForKey:", CFSTR("AppleMinDaysInFirstWeek"));
}

uint64_t _CFLocaleGetAppleICUDateTimeSymbolsPref(void *a1, const char *a2)
{
  return objc_msgSend(a1, "_prefForKey:", CFSTR("AppleICUDateTimeSymbols"));
}

uint64_t _CFLocaleGetAppleFirstWeekdayPref(void *a1, const char *a2)
{
  return objc_msgSend(a1, "_prefForKey:", CFSTR("AppleFirstWeekday"));
}

uint64_t __cficu_udat_toPattern(uint64_t a1, int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  uint64_t v10;
  CFStringRef v11;
  const void *v12;
  CFTypeRef v13;
  CFStringRef v14;
  CFStringRef v15;
  CFStringRef v16;

  v10 = udat_toPattern();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v12 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    v13 = ___CFICUCreateVariableNameForUCharOutput("pattern", (uint64_t)a3, a4);
    v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    v15 = v14;
    if (*a5 < 1)
    {
      v16 = CFStringCreateWithCharacters(0, a3, (int)v10);
      ___CFICULogWithArguments(1, CFSTR("udat_toPattern(%@, %d, %@, %d, &%@); // %d %@ %@"),
        v11,
        a2,
        v13,
        a4,
        v12,
        v10,
        v16,
        v15);
      if (v16)
        CFRelease(v16);
    }
    else
    {
      ___CFICULogWithArguments(1, CFSTR("udat_toPattern(%@, %d, %@, %d, &%@); // %d %@ %@"),
        v11,
        a2,
        v13,
        a4,
        v12,
        v10,
        0,
        v14);
    }
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v15);
  }
  return v10;
}

id _CFLocaleCreateCopyWithNewCalendarIdentifier(uint64_t a1, void *a2)
{
  return (id)objc_msgSend(a2, "_localeWithNewCalendarIdentifier:");
}

void __cficu_udat_setContext(uint64_t a1, int a2, void *a3)
{
  const void *v6;
  const void *v7;
  CFStringRef v8;
  CFStringRef v9;
  const char *v10;

  udat_setContext();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v6 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v7 = (const void *)___CFICUCreateVariableNameForStatus(a3);
    v8 = ___CFICUCreateErrorStringWithComment((int *)a3, 1);
    v9 = v8;
    if ((a2 - 256) > 4)
      v10 = "<unknown UDisplayContext>";
    else
      v10 = off_1E1334378[a2 - 256];
    ___CFICULogWithArguments(1, CFSTR("udat_setContext(%@, %s, %@); %@"), v6, v10, v7, v8);
    CFRelease(v6);
    CFRelease(v7);
    CFRelease(v9);
  }
}

uint64_t __cficu_udat_toPatternRelativeDate(uint64_t a1, const UniChar *a2, uint64_t a3, int *a4)
{
  uint64_t v8;
  CFStringRef v9;
  const void *v10;
  CFTypeRef v11;
  CFStringRef v12;
  CFStringRef v13;
  CFStringRef v14;

  v8 = udat_toPatternRelativeDate();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
    v11 = ___CFICUCreateVariableNameForUCharOutput("pattern", (uint64_t)a2, a3);
    v12 = ___CFICUCreateErrorStringWithComment(a4, 0);
    v13 = v12;
    if (*a4 < 1)
    {
      v14 = CFStringCreateWithCharacters(0, a2, (int)v8);
      ___CFICULogWithArguments(1, CFSTR("udat_toPatternRelativeDate(%@,  %@, %d, &%@); // %d %@ %@"),
        v9,
        v11,
        a3,
        v10,
        v8,
        v14,
        v13);
      if (v14)
        CFRelease(v14);
    }
    else
    {
      ___CFICULogWithArguments(1, CFSTR("udat_toPatternRelativeDate(%@,  %@, %d, &%@); // %d %@ %@"),
        v9,
        v11,
        a3,
        v10,
        v8,
        0,
        v12);
    }
    CFRelease(v9);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v13);
  }
  return v8;
}

void __cficu_udat_applyPatternRelative(uint64_t a1, UChar *a2, uint64_t a3, UChar *a4, uint64_t a5, int *a6)
{
  CFStringRef v12;
  const void *v13;
  CFStringRef v14;
  CFStringRef v15;
  CFStringRef v16;

  udat_applyPatternRelative();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    v14 = ___CFICUCreateErrorStringWithComment(a6, 1);
    v15 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
    v16 = ___CFICUCreateArgumentForUCharInput(a4, a5, 1);
    ___CFICULogWithArguments(1, CFSTR("udat_applyPatternRelative(%@, %@, %d, %@, %d, &%@); %@"),
      v12,
      v15,
      a3,
      v16,
      a5,
      v13,
      v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v14);
  }
}

uint64_t __cficu_udat_toPatternRelativeTime(uint64_t a1, const UniChar *a2, uint64_t a3, int *a4)
{
  uint64_t v8;
  CFStringRef v9;
  const void *v10;
  CFTypeRef v11;
  CFStringRef v12;
  CFStringRef v13;
  CFStringRef v14;

  v8 = udat_toPatternRelativeTime();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
    v11 = ___CFICUCreateVariableNameForUCharOutput("pattern", (uint64_t)a2, a3);
    v12 = ___CFICUCreateErrorStringWithComment(a4, 0);
    v13 = v12;
    if (*a4 < 1)
    {
      v14 = CFStringCreateWithCharacters(0, a2, (int)v8);
      ___CFICULogWithArguments(1, CFSTR("udat_toPatternRelativeTime(%@,  %@, %d, &%@); // %d %@ %@"),
        v9,
        v11,
        a3,
        v10,
        v8,
        v14,
        v13);
      if (v14)
        CFRelease(v14);
    }
    else
    {
      ___CFICULogWithArguments(1, CFSTR("udat_toPatternRelativeTime(%@,  %@, %d, &%@); // %d %@ %@"),
        v9,
        v11,
        a3,
        v10,
        v8,
        0,
        v12);
    }
    CFRelease(v9);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v13);
  }
  return v8;
}

uint64_t __cficu_udat_getContext(uint64_t a1, int a2, void *a3)
{
  uint64_t Context;
  const void *v7;
  const void *v8;
  const void *v9;
  CFStringRef v10;
  CFStringRef v11;
  const char *v12;

  Context = udat_getContext();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v7 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v8 = (const void *)___CFICUCreateVariableName("cxt");
    v9 = (const void *)___CFICUCreateVariableNameForStatus(a3);
    v10 = ___CFICUCreateErrorStringWithComment((int *)a3, 1);
    v11 = v10;
    v12 = "<unknown UDisplayContextType>";
    if (a2 == 1)
      v12 = "UDISPCTX_TYPE_CAPITALIZATION";
    if (!a2)
      v12 = "UDISPCTX_TYPE_DIALECT_HANDLING";
    ___CFICULogWithArguments(1, CFSTR("UDisplayContext %@ = udat_getContext(%@, %s, %@); %@"), v8, v7, v12, v9, v10);
    CFRelease(v7);
    CFRelease(v8);
    CFRelease(v9);
    CFRelease(v11);
  }
  return Context;
}

CFDictionaryRef CFBundleCopyInfoDictionaryInDirectory(CFURLRef bundleURL)
{
  return _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, bundleURL, 0);
}

uint64_t _CFAppVersionCheckLessThan(CFTypeRef cf2, int a2, double a3)
{
  unint64_t v5;
  unsigned int active_platform;
  uint64_t result;

  if (!cf2)
    _CFAppVersionCheckLessThan_cold_1();
  if (a2 != -1)
  {
    v5 = a2;
    active_platform = dyld_get_active_platform();
    if (_CFPlatformExecutableLinkedOnOrAfter(v5, active_platform))
      return 0;
  }
  if (_bundleInfo_onceToken != -1)
    dispatch_once(&_bundleInfo_onceToken, &__block_literal_global_25);
  if (!_bundleInfo_info_0)
    _CFAppVersionCheckLessThan_cold_2();
  result = CFEqual((CFTypeRef)_bundleInfo_info_0, cf2);
  if ((_DWORD)result)
    return *(double *)&_bundleInfo_info_2 < a3 || a3 < 0.0;
  return result;
}

uint64_t _CFPlatformExecutableLinkedOnOrAfter(unint64_t a1, unsigned int a2)
{
  if (a2 != 6)
    _CFBuildVersionForCFSystemVersion(a1, a2);
  return dyld_program_sdk_at_least();
}

void CFNotificationCenterRemoveEveryObserver(CFNotificationCenterRef center, const void *observer)
{
  CFNotificationCenterRemoveObserver(center, observer, 0, 0);
}

void sub_182B6AE68(_Unwind_Exception *a1)
{
  free(0);
  _Unwind_Resume(a1);
}

uint64_t _CFPredicatePolicyData_setFlags(uint64_t result)
{
  _cfprediacateelements_flags = result;
  return result;
}

BOOL __CFStringIsEightBit(uint64_t a1)
{
  unsigned int v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return ((v1 >> 4) & 1) == 0;
}

void sub_182B6B664(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFUUIDBytes result;

  v2 = _CFGetNonObjCTypeID((unint64_t *)uuid);
  if (v2 != 34)
    _CFAssertMismatchedTypeID(0x22uLL, v2);
  v3 = *((_QWORD *)uuid + 2);
  v4 = *((_QWORD *)uuid + 3);
  result.byte8 = v4;
  result.byte9 = BYTE1(v4);
  result.byte10 = BYTE2(v4);
  result.byte11 = BYTE3(v4);
  result.byte12 = BYTE4(v4);
  result.byte13 = BYTE5(v4);
  result.byte14 = BYTE6(v4);
  result.byte15 = HIBYTE(v4);
  result.byte0 = v3;
  result.byte1 = BYTE1(v3);
  result.byte2 = BYTE2(v3);
  result.byte3 = BYTE3(v3);
  result.byte4 = BYTE4(v3);
  result.byte5 = BYTE5(v3);
  result.byte6 = BYTE6(v3);
  result.byte7 = HIBYTE(v3);
  return result;
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesSynchronizeWithContainer((__CFString *)applicationID, userName, hostName, 0);
}

Boolean CFURLStartAccessingSecurityScopedResource(CFURLRef url)
{
  return MEMORY[0x186DAF31C](url) != 0;
}

double CFGetSystemUptime()
{
  if (CFDateGetTypeID_initOnce != -1)
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
  return *(double *)&__CF1_TSRRate * (double)mach_absolute_time();
}

BOOL _CFDictionaryIsMutable(uint64_t a1)
{
  unsigned int v3;

  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)a1))
    return 0;
  v3 = atomic_load((unint64_t *)(a1 + 8));
  return ((v3 >> 6) & 1) == 0;
}

uint64_t __CFBitVectorInit(__objc2_class **a1, char a2, const void *a3, int64_t a4)
{
  uint64_t Instance;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  void *Typed;
  size_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  int v19;

  Instance = _CFRuntimeCreateInstance(a1, 0x18uLL, 24, 0);
  v9 = Instance;
  if (Instance)
  {
    if ((unint64_t)a4 <= 1)
      v10 = 1;
    else
      v10 = a4;
    v12 = v10 + 63;
    v11 = v10 < -63;
    v13 = v10 + 126;
    if (!v11)
      v13 = v12;
    *(_QWORD *)(Instance + 24) = v13 & 0xFFFFFFFFFFFFFFC0;
    Typed = (void *)CFAllocatorAllocateTyped(a1, (8 * (v13 >> 6)) | 1, 0x100004077774924, 0);
    *(_QWORD *)(v9 + 32) = Typed;
    if (__CFOASafe)
    {
      __CFSetLastAllocationEventName();
      Typed = *(void **)(v9 + 32);
    }
    if (Typed)
    {
      bzero(Typed, *(_QWORD *)(v9 + 24) / 8 + 1);
      *(_QWORD *)(v9 + 16) = a4;
      if (a3)
      {
        if ((a4 & 7) != 0)
          v15 = a4 / 8 + 1;
        else
          v15 = a4 / 8;
        memmove(*(void **)(v9 + 32), a3, v15);
      }
      v16 = (unint64_t *)(v9 + 8);
      v17 = atomic_load((unint64_t *)(v9 + 8));
      while (1)
      {
        v18 = __ldaxr(v16);
        if (v18 != v17)
          break;
        if (__stlxr(v17 & 0xFFFFFFFFFFFFFFF3 | (4 * (a2 & 3)), v16))
          goto LABEL_20;
        v19 = 1;
LABEL_21:
        v17 = v18;
        if (v19)
          return v9;
      }
      __clrex();
LABEL_20:
      v19 = 0;
      goto LABEL_21;
    }
    CFRelease((CFTypeRef)v9);
    return 0;
  }
  return v9;
}

uint64_t _CFURLComponentsSetQuery(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setQuery:", a2);
  return 1;
}

CFMutableCharacterSetRef CFCharacterSetCreateMutableCopy(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFMutableCharacterSetRef)__CFCharacterSetCreateCopy(alloc, (unint64_t *)theSet, 1, 1);
}

uint64_t _CFURLComponentsGetURLQueryAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1)
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  return *(_QWORD *)(sURLAllowedCharacterSets + 32);
}

uint64_t __CFStringGetExtendedPictographicSequenceComponent(UniChar *buffer, int64_t a2, int64_t a3, uint64_t *a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  int64_t v9;
  int64_t v10;
  int64_t v11;
  uint64_t v12;
  UChar32 LongCharacterFromInlineBuffer;
  uint64_t v14;
  uint64_t *v15;
  _BOOL4 v16;
  _BOOL4 v17;
  BOOL v18;
  int64_t v19;
  int64_t v20;
  UChar32 v21;
  int64_t v22;
  int64_t v24;
  uint64_t v25;
  uint64_t v26;

  result = 0;
  v26 = *MEMORY[0x1E0C80C00];
  if (a3 < 0 || a3 >= a2)
    return result;
  v24 = a3;
  v7 = 0;
  v8 = 0;
  v9 = -1;
  v25 = 0;
  v10 = -1;
  v11 = -1;
  v12 = -1;
  while (1)
  {
    LongCharacterFromInlineBuffer = __CFStringGetLongCharacterFromInlineBuffer(buffer, a2, a3, &v24);
    if (u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_GRAPHEME_EXTEND)
      || u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_EMOJI_MODIFIER))
    {
      v14 = v7 + 1;
      if (v7 > 63)
        goto LABEL_21;
      v12 = v24;
      v11 = v24;
      goto LABEL_8;
    }
    if (LongCharacterFromInlineBuffer == 8205)
    {
      if (v11 != -1 || v10 != -1)
        break;
      v11 = -1;
      v12 = v24;
      v10 = v24;
      goto LABEL_19;
    }
    if (!u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_EXTENDED_PICTOGRAPHIC)
      || v9 != -1
      || v10 != -1
      || v11 != -1)
    {
      break;
    }
    v12 = v24;
    v10 = -1;
    v9 = v24;
LABEL_19:
    v14 = v7;
LABEL_8:
    v8 += v25;
    v7 = v14;
    a3 = v12 - 1;
    v24 = v12 - 1;
    if (v12 < 1)
      goto LABEL_21;
  }
  v14 = v7;
LABEL_21:
  if (v9 != -1)
  {
    v15 = a4;
    if (a4)
    {
      v16 = v11 != -1;
      v17 = v10 == -1;
      v18 = !v16 || !v17;
      if (v16 && v17)
        v19 = v11 - v9;
      else
        v19 = 0;
      v8 += v19;
      if (!v18)
        v12 = v9;
LABEL_28:
      *v15 = v12;
      v15[1] = v8;
      v15[2] = v11;
      v15[3] = v10;
      result = 1;
      v15[4] = v9;
      return result;
    }
    return 1;
  }
  if (v10 == -1 && v11 == -1)
    return 0;
  v20 = v8 + v12;
  v24 = v8 + v12;
  v25 = 0;
  if (v8 + v12 >= a2)
    return 0;
  do
  {
    v21 = __CFStringGetLongCharacterFromInlineBuffer(buffer, a2, v20, &v24);
    if (u_hasBinaryProperty(v21, UCHAR_GRAPHEME_EXTEND) || u_hasBinaryProperty(v21, UCHAR_EMOJI_MODIFIER))
    {
      result = 0;
      if (v10 != -1 || v14 > 62)
        return result;
      ++v14;
      v10 = -1;
      v22 = v24;
      v9 = -1;
    }
    else if (v21 == 8205)
    {
      if (v10 != -1)
        return 0;
      v9 = -1;
      v22 = v24;
      v10 = v24;
    }
    else
    {
      result = u_hasBinaryProperty(v21, UCHAR_EXTENDED_PICTOGRAPHIC);
      if (!(_DWORD)result)
        return result;
      v22 = v24;
      v9 = v24;
    }
    v8 += v25;
    v20 = v22 + v25;
    v24 = v22 + v25;
    v25 = 0;
  }
  while (v9 == -1 && v20 < a2);
  result = 0;
  if (v9 != -1 && v14 <= 63)
  {
    v15 = a4;
    if (a4)
      goto LABEL_28;
    return 1;
  }
  return result;
}

uint64_t CFStringGetRangeOfCharacterClusterAtIndex(__CFString *a1, int64_t a2, uint64_t a3)
{
  CFIndex Length;
  unsigned int v7;
  int64_t v8;
  char v9;
  uint64_t v11;
  const __CFString *CharactersPtr;
  uint64_t CStringPtrInternal;
  uint64_t v14;
  uint64_t ComposedRange;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  UniChar *v20;
  uint64_t v21;
  UniChar v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  UniChar *v27;
  uint64_t v28;
  UniChar v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  UniChar *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  UniChar *v40;
  int v41;
  _BOOL4 v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  UniChar *v46;
  uint64_t v47;
  UniChar v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  UniChar *v53;
  uint64_t v54;
  UniChar v55;
  uint64_t v56;
  int64_t v57;
  uint64_t v58;
  int64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int64_t v64;
  int64_t v66;
  uint64_t v67;
  int v68;
  UniChar *v69;
  uint64_t v71;
  UniChar *v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  uint64_t v77;
  uint64_t v78;
  UniChar v79;
  uint64_t v80;
  uint64_t v81;
  int64_t v82;
  uint64_t v83;
  int64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  int64_t v94;
  char *v95;
  uint64_t v96;
  uint64_t v97;
  unsigned __int8 *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unsigned __int16 v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unsigned __int8 *v109;
  uint64_t v110;
  int64_t v111;
  uint64_t v112;
  uint64_t v113;
  int64_t v114;
  uint64_t v115;
  int64_t v116;
  int64_t v117;
  int64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  UChar32 LongCharacterFromInlineBuffer;
  uint64_t v124;
  int64_t v125;
  int64_t v126;
  uint64_t v127;
  uint64_t v129;
  int64_t v130;
  _BOOL4 v131;
  _BOOL4 v132;
  uint64_t v133;
  uint64_t v134;
  UChar32 v135;
  uint64_t v136;
  unint64_t v137;
  int64_t v138;
  int64_t v139;
  int64_t v140;
  int64_t v141;
  BOOL v142;
  uint64_t v143;
  int64_t v144;
  UChar32 v145;
  int64_t v146;
  _BOOL4 v147;
  _BOOL4 v148;
  uint64_t v149;
  UniChar *v150;
  int64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  int64_t v158;
  char *v159;
  int64_t v160;
  int64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  unsigned int v165;
  uint64_t v166;
  int64_t v167;
  int64_t v168;
  uint64_t BitmapPtrForPlane;
  _BOOL4 v170;
  __int128 v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  int64_t v175;
  int64_t v176;
  UniChar buffer[8];
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  CFStringRef theString[2];
  __int128 v186;
  __int128 v187;
  uint64_t v188;
  uint64_t v189;
  CFRange v190;
  CFRange v191;
  CFRange v192;
  CFRange v193;
  CFRange v194;
  CFRange v195;
  CFRange v196;
  CFRange v197;
  CFRange v198;
  CFRange v199;
  CFRange v200;
  CFRange v201;
  CFRange v202;

  v189 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  if (a3 == 1)
    v7 = 110;
  else
    v7 = 8;
  if (Length <= a2)
    return -1;
  v8 = Length;
  v188 = 0;
  v186 = 0u;
  v187 = 0u;
  v184 = 0u;
  *(_OWORD *)theString = 0u;
  v182 = 0u;
  v183 = 0u;
  v180 = 0u;
  v181 = 0u;
  v178 = 0u;
  v179 = 0u;
  *(_OWORD *)buffer = 0u;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)a1)
    || (v9 = atomic_load((unint64_t *)&a1->info), (v9 & 0x10) != 0))
  {
    BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(v7, 0);
    v11 = CFUniCharGetBitmapPtrForPlane(5u, 0);
    if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP)
      CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP = CFUniCharGetUnicodePropertyDataForPlane(0, 0);
    theString[0] = a1;
    *((_QWORD *)&v186 + 1) = 0;
    *(_QWORD *)&v187 = v8;
    CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(a1);
    CStringPtrInternal = 0;
    theString[1] = CharactersPtr;
    if (!CharactersPtr)
      CStringPtrInternal = _CFStringGetCStringPtrInternal((uint64_t)a1, 0x600u, 1, 1);
    *((_QWORD *)&v187 + 1) = 0;
    v188 = 0;
    *(_QWORD *)&v186 = CStringPtrInternal;
    v14 = BitmapPtrForPlane;
    ComposedRange = _CFStringInlineBufferGetComposedRange(buffer, a2, a3, BitmapPtrForPlane, v7);
    v17 = ComposedRange;
    v18 = v16;
    v165 = v7;
    v166 = a3;
    if (a3 > 2)
    {
      a2 = ComposedRange;
      goto LABEL_208;
    }
    v162 = v16;
    if (ComposedRange < 0 || (v19 = v187, (uint64_t)v187 <= ComposedRange))
    {
      LOWORD(v23) = 0;
      v24 = v11;
      goto LABEL_22;
    }
    v20 = (UniChar *)theString[1];
    if (theString[1])
    {
      v21 = *((_QWORD *)&v186 + 1) + ComposedRange;
    }
    else
    {
      if ((_QWORD)v186)
      {
        v22 = *(char *)(v186 + *((_QWORD *)&v186 + 1) + ComposedRange);
        goto LABEL_27;
      }
      if (v188 <= ComposedRange || (v133 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) > ComposedRange))
      {
        v134 = ComposedRange - 4;
        if ((unint64_t)ComposedRange < 4)
          v134 = 0;
        if (v134 + 64 < (uint64_t)v187)
          v19 = v134 + 64;
        *((_QWORD *)&v187 + 1) = v134;
        v188 = v19;
        v199.location = *((_QWORD *)&v186 + 1) + v134;
        v199.length = v19 - v134;
        CFStringGetCharacters(theString[0], v199, buffer);
        v133 = *((_QWORD *)&v187 + 1);
      }
      v21 = v17 - v133;
      v20 = buffer;
    }
    v22 = v20[v21];
LABEL_27:
    v23 = v22;
    if (v18 < 2 || (v22 & 0xFC00) != 0xD800 || (v25 = v17 + 1, v26 = v187, (uint64_t)v187 <= (uint64_t)(v17 + 1)))
    {
      v24 = v11;
      goto LABEL_34;
    }
    v27 = (UniChar *)theString[1];
    if (theString[1])
    {
      v28 = *((_QWORD *)&v186 + 1) + v25;
    }
    else
    {
      if ((_QWORD)v186)
      {
        v29 = *(char *)(v186 + *((_QWORD *)&v186 + 1) + v25);
LABEL_286:
        v24 = v11;
        if (v29 >> 10 == 55)
        {
          v23 = (v23 << 10) + v29 - 56613888;
          v24 = CFUniCharGetBitmapPtrForPlane(5u, HIWORD(v23));
        }
LABEL_34:
        if (v23 == 8205)
        {
LABEL_35:
          v30 = v17;
          while (1)
          {
            a2 = v30;
            v31 = v30 - 2;
            if (v30 < 2)
            {
LABEL_121:
              v18 = v17 - a2 + v162;
              v64 = v162 + v17;
              if (v18 < 2 || v64 >= v8)
              {
LABEL_207:
                v14 = BitmapPtrForPlane;
LABEL_208:
                v91 = a2 + v18;
                if (a2 + v18 <= 5)
                  v92 = 5;
                else
                  v92 = a2 + v18;
                v93 = v92 - 5;
                if (v92 - 5 <= a2)
                {
                  v163 = v18;
                  v94 = a2 + 6;
                  v95 = (char *)&v175 + 6;
                  v96 = 5 - v92;
                  v97 = v92 + 59;
                  v98 = (unsigned __int8 *)&__CFTranscodingHintLength;
                  while (1)
                  {
                    v99 = v92 - 5;
                    v100 = v93 >= 4 ? 4 : v93;
                    v101 = v187;
                    if ((uint64_t)v187 > v99)
                    {
                      if (theString[1])
                      {
                        v102 = *((_WORD *)theString[1] + v92 + *((_QWORD *)&v186 + 1) - 5);
                      }
                      else if ((_QWORD)v186)
                      {
                        v102 = *(char *)(v186 + *((_QWORD *)&v186 + 1) + v92 - 5);
                      }
                      else
                      {
                        if (v188 <= v99 || (v103 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) > v99))
                        {
                          v104 = -5 - v100;
                          v159 = v95;
                          v160 = a2;
                          v105 = v100 + v96;
                          v106 = v97 - v100;
                          v107 = v92 + v104;
                          v108 = v107 + 64;
                          if (v107 + 64 >= (uint64_t)v187)
                            v108 = v187;
                          *((_QWORD *)&v187 + 1) = v107;
                          v188 = v108;
                          if ((uint64_t)v187 >= v106)
                            v101 = v106;
                          v198.length = v101 + v105;
                          v109 = v98;
                          v198.location = v107 + *((_QWORD *)&v186 + 1);
                          CFStringGetCharacters(theString[0], v198, buffer);
                          v98 = v109;
                          v95 = v159;
                          a2 = v160;
                          v103 = *((_QWORD *)&v187 + 1);
                        }
                        v102 = *(_WORD *)&v95[2 * v92 + -2 * v103];
                      }
                      if ((v102 & 0xFFF0) == 0xF860)
                      {
                        v110 = v98[v102 - 63584];
                        if (v92 + v110 - 4 >= v91)
                          break;
                      }
                    }
                    ++v93;
                    ++v92;
                    --v96;
                    ++v97;
                    if (v94 == v92)
                    {
                      v18 = v163;
                      v14 = BitmapPtrForPlane;
                      goto LABEL_233;
                    }
                  }
                  v115 = v110 + v92;
                  v116 = v115 - 5;
                  v18 = v163;
                  v14 = BitmapPtrForPlane;
                  if (v115 - 5 < v8)
                  {
                    a2 = v92 - 5;
                    v117 = v115 - 4;
                    v118 = v92 - 4;
                    while (v118 <= v116)
                    {
                      v119 = _CFStringInlineBufferGetComposedRange(buffer, v118, v166, BitmapPtrForPlane, v165);
                      v118 = v119 + v120;
                      if (v118 > v117)
                      {
                        v117 = v119;
                        break;
                      }
                    }
                    v18 = v117 - v92 + 5;
                  }
                }
LABEL_233:
                if (v18 == 2)
                {
                  if (!__CFStringIsRegionalIndicatorAtIndex(buffer, a2))
                    goto LABEL_242;
                  v111 = v8;
                  v112 = 0;
                  do
                  {
                    v113 = v112;
                    v114 = a2 + v112;
                    if (a2 + v112 < 2)
                      break;
                    v112 -= 2;
                  }
                  while (__CFStringIsRegionalIndicatorAtIndex(buffer, v113 - 2 + a2));
                  if (a2 > v114 && (-(int)v113 & 3) != 0)
                  {
                    a2 -= 2;
                    v18 = 4;
                    v8 = v111;
                    goto LABEL_252;
                  }
                  v8 = v111;
                  if (a2 + 4 > v111)
                  {
LABEL_242:
                    v18 = 2;
                    goto LABEL_252;
                  }
                  if (__CFStringIsRegionalIndicatorAtIndex(buffer, a2 + 2))
                    v18 = 4;
                  else
                    v18 = 2;
                }
LABEL_252:
                v121 = v166;
                if ((a2 & 0x8000000000000000) == 0 && a2 < v8)
                {
                  v122 = v18;
                  v175 = 0;
                  v176 = 0;
                  LongCharacterFromInlineBuffer = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, a2, &v175);
                  v124 = 0;
                  v125 = v176;
                  while (LongCharacterFromInlineBuffer == 8205
                       || u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_GRAPHEME_EXTEND)
                       || u_hasBinaryProperty(LongCharacterFromInlineBuffer, UCHAR_EMOJI_MODIFIER)
                       || u_getIntPropertyValue(LongCharacterFromInlineBuffer, UCHAR_GRAPHEME_CLUSTER_BREAK) == 10)
                  {
                    v125 = v175;
                    if (!v175)
                      goto LABEL_334;
                    v124 += v176;
                    if (v124 >= 64)
                      goto LABEL_334;
                    LongCharacterFromInlineBuffer = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, v175 - 1, &v175);
                  }
                  v171 = xmmword_182C87F40;
                  v172 = -1;
                  v173 = -1;
                  v174 = -1;
                  v126 = v175;
                  v127 = 0;
                  if (__CFStringGetExtendedPictographicSequenceComponent(buffer, v8, v175, (uint64_t *)&v171))
                  {
                    do
                    {
                      v126 = v171;
                      v127 += *((_QWORD *)&v171 + 1);
                      v175 = v171 - 1;
                      v176 = 0;
                    }
                    while (v173 != -1
                         && __CFStringGetExtendedPictographicSequenceComponent(buffer, v8, v171 - 1, (uint64_t *)&v171));
                  }
                  if (v172 == -1 && v173 == -1)
                  {
                    v132 = v127 == 0;
                    if (v124 < 1 || v127)
                    {
                      v167 = v175;
                      v135 = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, v175, &v175);
                      if (u_getIntPropertyValue(v135, UCHAR_GRAPHEME_CLUSTER_BREAK) == 11)
                      {
                        v130 = v175;
                        v129 = v176;
                      }
                      else
                      {
                        v129 = 0;
                        v130 = v167;
                      }
                      v131 = v124 > 0;
                      goto LABEL_298;
                    }
                  }
                  else
                  {
                    v129 = 0;
                    v126 = v174;
                    v127 += v171 - v174;
                    v130 = v174 + 1;
                    v131 = v124 > 0;
                    v132 = v127 == 0;
                    if (v124 < 1 || v127)
                    {
LABEL_298:
                      if (v129 || !v132)
                      {
                        v170 = v131;
                        v168 = v130;
                        v164 = v129;
                        v138 = v130 + v129;
                        if (v132)
                          v139 = v138;
                        else
                          v139 = v126 + v127;
                        if (v132)
                        {
                          v127 = 0;
                          v140 = v138;
                        }
                        else
                        {
                          v140 = v126;
                        }
                        v175 = v139;
                        v176 = 0;
                        if (__CFStringGetExtendedPictographicSequenceComponent(buffer, v8, v139, (uint64_t *)&v171))
                        {
                          do
                          {
                            if (v127 >= 1 && v173 == -1)
                              break;
                            v127 += *((_QWORD *)&v171 + 1);
                            v175 += *((_QWORD *)&v171 + 1);
                          }
                          while ((__CFStringGetExtendedPictographicSequenceComponent(buffer, v8, v175, (uint64_t *)&v171) & 1) != 0);
                        }
                        v161 = v140;
                        if (v170)
                        {
                          v141 = v127 + v140;
                          v142 = v127 + v140 < v125 + v124;
                          if (v127 + v140 >= v125 + v124)
                            v143 = 0;
                          else
                            v143 = v124;
                          if (v142)
                            v141 = v125;
                          v144 = v141 + v143;
                          v175 = v141 + v143;
                          v176 = 0;
                        }
                        else
                        {
                          v144 = v175;
                          v143 = v176;
                        }
                        if (v144 < v8)
                        {
                          v145 = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, v144, &v175);
                          do
                          {
                            if (v145 != 8205
                              && !u_hasBinaryProperty(v145, UCHAR_GRAPHEME_EXTEND)
                              && !u_hasBinaryProperty(v145, UCHAR_EMOJI_MODIFIER)
                              && u_getIntPropertyValue(v145, UCHAR_GRAPHEME_CLUSTER_BREAK) != 10)
                            {
                              break;
                            }
                            v143 += v176;
                            v175 += v176;
                            v145 = __CFStringGetLongCharacterFromInlineBuffer(buffer, v8, v175, &v175);
                          }
                          while (v143 < 64);
                        }
                        v146 = v168;
                        if (v127 >= 1)
                        {
                          if (v164 <= 0)
                            v146 = v161;
                          v147 = a2 >= v146;
                          v148 = a2 + v122 <= v127 + (v164 & ~(v164 >> 63)) + (v143 & ~(v143 >> 63)) + v146;
                          if (v147 && v148)
                            v18 = v127 + (v164 & ~(v164 >> 63)) + (v143 & ~(v143 >> 63));
                          else
                            v18 = v122;
                          if (v147 && v148)
                            a2 = v146;
                          goto LABEL_335;
                        }
                      }
                    }
                  }
LABEL_334:
                  v18 = v122;
                }
LABEL_335:
                if (a2 >= 1 && v18 == 1)
                {
                  v149 = v187;
                  if ((uint64_t)v187 <= a2)
                    goto LABEL_348;
                  v150 = (UniChar *)theString[1];
                  if (theString[1])
                  {
                    v151 = *((_QWORD *)&v186 + 1) + a2;
                    goto LABEL_340;
                  }
                  if ((_QWORD)v186)
                    goto LABEL_348;
                  if (v188 <= a2 || (v157 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) > a2))
                  {
                    v158 = a2 - 4;
                    if ((unint64_t)a2 < 4)
                      v158 = 0;
                    if (v158 + 64 < (uint64_t)v187)
                      v149 = v158 + 64;
                    *((_QWORD *)&v187 + 1) = v158;
                    v188 = v149;
                    v202.location = *((_QWORD *)&v186 + 1) + v158;
                    v202.length = v149 - v158;
                    CFStringGetCharacters(theString[0], v202, buffer);
                    v157 = *((_QWORD *)&v187 + 1);
                  }
                  v151 = a2 - v157;
                  v150 = buffer;
LABEL_340:
                  if (v150[v151] != 8205)
                  {
LABEL_348:
                    v18 = 1;
                  }
                  else
                  {
                    v152 = _CFStringInlineBufferGetComposedRange(buffer, a2 - 1, v121, v14, v165);
                    if (a2 == v152 + v153)
                      v18 = v153 + 1;
                    else
                      v18 = 1;
                    if (a2 == v152 + v153)
                      a2 = v152;
                  }
                }
                v154 = a2 + v18;
                if (a2 + v18 < v8 && (v154 & 0x8000000000000000) == 0)
                {
                  v155 = v187;
                  if ((uint64_t)v187 > v154
                    && !theString[1]
                    && !(_QWORD)v186
                    && (v188 <= v154 || *((uint64_t *)&v187 + 1) > v154))
                  {
                    v156 = v154 - 4;
                    if ((unint64_t)v154 < 4)
                      v156 = 0;
                    if (v156 + 64 < (uint64_t)v187)
                      v155 = v156 + 64;
                    *((_QWORD *)&v187 + 1) = v156;
                    v188 = v155;
                    v201.location = *((_QWORD *)&v186 + 1) + v156;
                    v201.length = v155 - v156;
                    CFStringGetCharacters(theString[0], v201, buffer);
                  }
                }
                return a2;
              }
              while (2)
              {
                v66 = v64 - 1;
                if (v64 < 1 || (v67 = v187, (uint64_t)v187 < v64))
                {
                  LOWORD(v68) = 0;
                  goto LABEL_129;
                }
                if (theString[1])
                {
                  v69 = (UniChar *)theString[1] + *((_QWORD *)&v186 + 1) + v66;
                }
                else
                {
                  if ((_QWORD)v186)
                  {
                    LOWORD(v68) = *(char *)(v186 + *((_QWORD *)&v186 + 1) + v66);
                    goto LABEL_129;
                  }
                  if (v188 < v64 || (v83 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) >= v64))
                  {
                    v84 = v64 - 5;
                    if ((unint64_t)v64 < 5)
                      v84 = 0;
                    if (v84 + 64 < (uint64_t)v187)
                      v67 = v84 + 64;
                    *((_QWORD *)&v187 + 1) = v84;
                    v188 = v67;
                    v195.location = *((_QWORD *)&v186 + 1) + v84;
                    v195.length = v67 - v84;
                    CFStringGetCharacters(theString[0], v195, buffer);
                    v83 = *((_QWORD *)&v187 + 1);
                  }
                  v69 = &buffer[v66 - v83];
                }
                v68 = *v69;
                if (v68 != 847 && v68 != 8205)
                {
LABEL_129:
                  if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                    || !*(_BYTE *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                                 + ((unint64_t)(unsigned __int16)v68 >> 8))
                    || *(_BYTE *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                                + (*(unsigned __int8 *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                                                      + ((unint64_t)(unsigned __int16)v68 >> 8)) << 8)
                                - 256
                                + v68
                                + 256) != 9
                    || (unsigned __int16)v68 == 3021 && !_CFStringIsJoiningPulliAtIndex(buffer, v64 - 1, 0, v8))
                  {
LABEL_206:
                    v18 = v64 - a2;
                    goto LABEL_207;
                  }
                  if (v64 < 0)
                  {
LABEL_150:
                    LOWORD(v76) = 0;
                    goto LABEL_183;
                  }
                }
                v71 = v187;
                if ((uint64_t)v187 <= v64)
                  goto LABEL_150;
                if (theString[1])
                {
                  v72 = (UniChar *)theString[1] + *((_QWORD *)&v186 + 1) + v64;
                  goto LABEL_146;
                }
                if ((_QWORD)v186)
                {
                  LOWORD(v73) = *(char *)(v186 + *((_QWORD *)&v186 + 1) + v64);
                  goto LABEL_153;
                }
                if (v188 <= v64 || (v81 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) > v64))
                {
                  v82 = v64 - 4;
                  if ((unint64_t)v64 < 4)
                    v82 = 0;
                  if (v82 + 64 < (uint64_t)v187)
                    v71 = v82 + 64;
                  *((_QWORD *)&v187 + 1) = v82;
                  v188 = v71;
                  v194.location = *((_QWORD *)&v186 + 1) + v82;
                  v194.length = v71 - v82;
                  CFStringGetCharacters(theString[0], v194, buffer);
                  v81 = *((_QWORD *)&v187 + 1);
                }
                v72 = &buffer[v64 - v81];
LABEL_146:
                v73 = *v72;
                if (v73 != 8205)
                {
LABEL_153:
                  v74 = v64;
                  goto LABEL_154;
                }
                v74 = v64 + 1;
                v75 = v187;
                if ((uint64_t)v187 <= v64 + 1)
                {
                  LOWORD(v76) = 0;
                  goto LABEL_182;
                }
                if (theString[1])
                {
                  LOWORD(v73) = *((_WORD *)&theString[1]->isa + *((_QWORD *)&v186 + 1) + v74);
                }
                else if ((_QWORD)v186)
                {
                  LOWORD(v73) = *(char *)(v186 + *((_QWORD *)&v186 + 1) + v74);
                }
                else
                {
                  if (v188 <= v74 || (v89 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) > v74))
                  {
                    v90 = v64 - 3;
                    if ((unint64_t)v64 < 3)
                      v90 = 0;
                    if (v90 + 64 < (uint64_t)v187)
                      v75 = v90 + 64;
                    *((_QWORD *)&v187 + 1) = v90;
                    v188 = v75;
                    v197.location = *((_QWORD *)&v186 + 1) + v90;
                    v197.length = v75 - v90;
                    CFStringGetCharacters(theString[0], v197, buffer);
                    v89 = *((_QWORD *)&v187 + 1);
                  }
                  LOWORD(v73) = buffer[v74 - v89];
                }
LABEL_154:
                v76 = (unsigned __int16)v73;
                if ((unsigned __int16)v73 >> 10 == 54)
                {
                  v77 = v74 + 1;
                  v78 = v187;
                  if ((uint64_t)v187 > v74 + 1)
                  {
                    if (theString[1])
                    {
                      v79 = *((_WORD *)&theString[1]->isa + *((_QWORD *)&v186 + 1) + v77);
                    }
                    else if ((_QWORD)v186)
                    {
                      v79 = *(char *)(v186 + *((_QWORD *)&v186 + 1) + v77);
                    }
                    else
                    {
                      if (v188 <= v77 || (v87 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) > v77))
                      {
                        v88 = v74 - 3;
                        if ((unint64_t)v74 < 3)
                          v88 = 0;
                        if (v88 + 64 < (uint64_t)v187)
                          v78 = v88 + 64;
                        *((_QWORD *)&v187 + 1) = v88;
                        v188 = v78;
                        v196.location = *((_QWORD *)&v186 + 1) + v88;
                        v196.length = v78 - v88;
                        CFStringGetCharacters(theString[0], v196, buffer);
                        v87 = *((_QWORD *)&v187 + 1);
                      }
                      v79 = buffer[v77 - v87];
                    }
                    if (v79 >> 10 == 55)
                    {
                      v76 = (v76 << 10) + v79 - 56613888;
                      v80 = CFUniCharGetBitmapPtrForPlane(5u, HIWORD(v76));
                      v64 = v74;
                      goto LABEL_184;
                    }
                    goto LABEL_182;
                  }
                  v64 = v74;
                  v80 = v11;
                }
                else
                {
LABEL_182:
                  v64 = v74;
LABEL_183:
                  v80 = v11;
                }
LABEL_184:
                if (!v80)
                  goto LABEL_206;
                if (((*(unsigned __int8 *)(v80 + ((unsigned __int16)v76 >> 3)) >> (v76 & 7)) & 1) == 0)
                  goto LABEL_206;
                v85 = _CFStringInlineBufferGetComposedRange(buffer, v64, v166, BitmapPtrForPlane, v7);
                v64 = v85 + v86;
                if (v85 + v86 >= v8)
                  goto LABEL_206;
                continue;
              }
            }
            v32 = v30 - 1;
            v33 = v187;
            if ((uint64_t)v187 >= a2)
            {
              v35 = (UniChar *)theString[1];
              if (theString[1])
              {
                v36 = *((_QWORD *)&v186 + 1) + v32;
              }
              else
              {
                if ((_QWORD)v186)
                {
                  LOWORD(v34) = *(char *)(v186 + *((_QWORD *)&v186 + 1) + v32);
                  goto LABEL_47;
                }
                if (v188 < a2 || (v56 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) >= a2))
                {
                  v57 = a2 - 5;
                  if ((unint64_t)a2 < 5)
                    v57 = 0;
                  if (v57 + 64 < (uint64_t)v187)
                    v33 = v57 + 64;
                  *((_QWORD *)&v187 + 1) = v57;
                  v188 = v33;
                  v190.location = *((_QWORD *)&v186 + 1) + v57;
                  v190.length = v33 - v57;
                  CFStringGetCharacters(theString[0], v190, buffer);
                  v56 = *((_QWORD *)&v187 + 1);
                }
                v36 = v32 - v56;
                v35 = buffer;
              }
              v34 = v35[v36];
              if (v34 == 847)
                goto LABEL_67;
              if (v34 == 3021)
              {
                if (!_CFStringIsJoiningPulliAtIndex(buffer, a2 - 1, 0, v8))
                  goto LABEL_121;
                LOWORD(v34) = 3021;
              }
            }
            else
            {
              LOWORD(v34) = 0;
            }
LABEL_47:
            v37 = (unsigned __int16)v34;
            v38 = CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP;
            if (CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
              && *(_BYTE *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP + (v37 >> 8))
              && *(_BYTE *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP
                          + (*(unsigned __int8 *)(CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP + (v37 >> 8)) << 8)
                          - 256
                          + v37
                          + 256) == 9)
            {
              goto LABEL_67;
            }
            if ((_DWORD)v37 != 8205)
              goto LABEL_121;
            v39 = v187;
            if ((uint64_t)v187 <= v31)
            {
              v43 = 0;
              if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP)
                goto LABEL_64;
              goto LABEL_61;
            }
            if (theString[1])
            {
              v40 = (UniChar *)theString[1] + *((_QWORD *)&v186 + 1) + v31;
            }
            else
            {
              if ((_QWORD)v186)
              {
                LOWORD(v41) = *(char *)(v186 + *((_QWORD *)&v186 + 1) + v31);
LABEL_60:
                v43 = (unsigned __int16)v41;
                v38 = CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP;
                if (!CFStringGetRangeOfCharacterClusterAtIndex_combClassBMP)
                {
LABEL_64:
                  v42 = v38 == 9;
                  goto LABEL_65;
                }
LABEL_61:
                if (*(_BYTE *)(v38 + ((unint64_t)v43 >> 8)))
                  LODWORD(v38) = *(unsigned __int8 *)(v38
                                                    + (*(unsigned __int8 *)(v38 + ((unint64_t)v43 >> 8)) << 8)
                                                    - 256
                                                    + v43
                                                    + 256);
                else
                  LODWORD(v38) = 0;
                goto LABEL_64;
              }
              if (v188 <= v31 || (v58 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) > v31))
              {
                v59 = a2 - 6;
                if ((unint64_t)v31 < 4)
                  v59 = 0;
                if (v59 + 64 < (uint64_t)v187)
                  v39 = v59 + 64;
                *((_QWORD *)&v187 + 1) = v59;
                v188 = v39;
                v191.location = *((_QWORD *)&v186 + 1) + v59;
                v191.length = v39 - v59;
                CFStringGetCharacters(theString[0], v191, buffer);
                v58 = *((_QWORD *)&v187 + 1);
              }
              v40 = &buffer[v31 - v58];
            }
            v41 = *v40;
            if (v41 != 847)
              goto LABEL_60;
            v42 = 1;
LABEL_65:
            if ((unint64_t)a2 < 3)
              goto LABEL_121;
            v32 = v31;
            if (!v42)
              goto LABEL_121;
LABEL_67:
            v44 = _CFStringInlineBufferGetComposedRange(buffer, v32 - 1, v166, BitmapPtrForPlane, v7);
            v30 = v44;
            if (v44 < 0 || (v45 = v187, (uint64_t)v187 <= v44))
            {
              LOWORD(v49) = 0;
              goto LABEL_73;
            }
            v46 = (UniChar *)theString[1];
            if (theString[1])
            {
              v47 = *((_QWORD *)&v186 + 1) + v44;
            }
            else
            {
              if ((_QWORD)v186)
              {
                v48 = *(char *)(v186 + *((_QWORD *)&v186 + 1) + v44);
                goto LABEL_79;
              }
              if (v188 <= v44 || (v60 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) > v44))
              {
                v61 = v44 - 4;
                if ((unint64_t)v44 < 4)
                  v61 = 0;
                if (v61 + 64 < (uint64_t)v187)
                  v45 = v61 + 64;
                *((_QWORD *)&v187 + 1) = v61;
                v188 = v45;
                v192.location = *((_QWORD *)&v186 + 1) + v61;
                v192.length = v45 - v61;
                CFStringGetCharacters(theString[0], v192, buffer);
                v60 = *((_QWORD *)&v187 + 1);
              }
              v47 = v30 - v60;
              v46 = buffer;
            }
            v48 = v46[v47];
LABEL_79:
            v49 = v48;
            if (v48 >> 10 == 55)
            {
              if (v30)
              {
                v51 = v187;
                if ((uint64_t)v187 >= v30)
                {
                  v52 = v30 - 1;
                  v53 = (UniChar *)theString[1];
                  if (theString[1])
                  {
                    v54 = *((_QWORD *)&v186 + 1) + v52;
                    goto LABEL_84;
                  }
                  if ((_QWORD)v186)
                  {
                    v55 = *(char *)(v186 + *((_QWORD *)&v186 + 1) + v52);
                  }
                  else
                  {
                    if (v188 < v30 || (v62 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) >= v30))
                    {
                      v63 = v30 - 5;
                      if ((unint64_t)v30 < 5)
                        v63 = 0;
                      if (v63 + 64 < (uint64_t)v187)
                        v51 = v63 + 64;
                      *((_QWORD *)&v187 + 1) = v63;
                      v188 = v51;
                      v193.location = *((_QWORD *)&v186 + 1) + v63;
                      v193.length = v51 - v63;
                      CFStringGetCharacters(theString[0], v193, buffer);
                      v62 = *((_QWORD *)&v187 + 1);
                    }
                    v54 = v52 - v62;
                    v53 = buffer;
LABEL_84:
                    v55 = v53[v54];
                  }
                  v50 = v11;
                  if (v55 >> 10 == 54)
                  {
                    v49 = (v49 << 10) + v55 - 56613888;
                    v50 = CFUniCharGetBitmapPtrForPlane(5u, HIWORD(v49));
                    --v30;
                  }
                  goto LABEL_74;
                }
              }
            }
LABEL_73:
            v50 = v11;
LABEL_74:
            if (!v50 || ((*(unsigned __int8 *)(v50 + ((unsigned __int16)v49 >> 3)) >> (v49 & 7)) & 1) == 0)
              goto LABEL_121;
          }
        }
LABEL_22:
        if (!v24 || ((*(unsigned __int8 *)(v24 + ((unsigned __int16)v23 >> 3)) >> (v23 & 7)) & 1) == 0)
        {
          a2 = v17;
          v18 = v162;
          goto LABEL_208;
        }
        goto LABEL_35;
      }
      if (v188 <= v25 || (v136 = *((_QWORD *)&v187 + 1), *((uint64_t *)&v187 + 1) > v25))
      {
        v137 = v17 - 3;
        if (v17 < 3)
          v137 = 0;
        if ((uint64_t)(v137 + 64) < (uint64_t)v187)
          v26 = v137 + 64;
        *((_QWORD *)&v187 + 1) = v137;
        v188 = v26;
        v200.location = *((_QWORD *)&v186 + 1) + v137;
        v200.length = v26 - v137;
        CFStringGetCharacters(theString[0], v200, buffer);
        v136 = *((_QWORD *)&v187 + 1);
      }
      v28 = v25 - v136;
      v27 = buffer;
    }
    v29 = v27[v28];
    goto LABEL_286;
  }
  return a2;
}

uint64_t __CFStringGetLongCharacterFromInlineBuffer(UniChar *buffer, int64_t a2, int64_t a3, int64_t *a4)
{
  int64_t v5;
  int64_t v8;
  uint64_t v9;
  UniChar v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  int64_t v15;
  int64_t v16;
  int64_t v18;
  int64_t v19;
  uint64_t v20;
  UniChar v21;
  int64_t v22;
  int64_t v23;
  uint64_t v24;
  UniChar v25;
  uint64_t v26;
  uint64_t v27;
  int64_t v28;
  int64_t v29;
  int64_t v30;
  int64_t v31;
  CFRange v32;
  CFRange v33;
  CFRange v34;

  if ((a3 & 0x8000000000000000) == 0)
  {
    v5 = a3;
    if (a3 < a2)
    {
      v8 = *((_QWORD *)buffer + 20);
      if (v8 <= a3)
      {
        v11 = 0;
      }
      else
      {
        v9 = *((_QWORD *)buffer + 17);
        if (v9)
        {
          v10 = *(_WORD *)(v9 + 2 * (*((_QWORD *)buffer + 19) + a3));
        }
        else
        {
          v14 = *((_QWORD *)buffer + 18);
          if (v14)
          {
            v10 = *(char *)(v14 + *((_QWORD *)buffer + 19) + a3);
          }
          else
          {
            if (*((_QWORD *)buffer + 22) <= a3 || (v15 = *((_QWORD *)buffer + 21), v15 > a3))
            {
              v16 = a3 - 4;
              if ((unint64_t)a3 < 4)
                v16 = 0;
              if (v16 + 64 < v8)
                v8 = v16 + 64;
              *((_QWORD *)buffer + 21) = v16;
              *((_QWORD *)buffer + 22) = v8;
              v32.location = *((_QWORD *)buffer + 19) + v16;
              v32.length = v8 - v16;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v32, buffer);
              v15 = *((_QWORD *)buffer + 21);
            }
            v10 = buffer[v5 - v15];
          }
        }
        v11 = v10;
        if ((v10 & 0xFC00) != 0xD800 || a2 - 1 <= v5)
        {
          v12 = 1;
          if (v5 && (v10 & 0xFC00) == 0xDC00)
          {
            v18 = *((_QWORD *)buffer + 20);
            if (v18 < v5)
              goto LABEL_9;
            v19 = v5 - 1;
            v20 = *((_QWORD *)buffer + 17);
            if (v20)
            {
              v21 = *(_WORD *)(v20 + 2 * (*((_QWORD *)buffer + 19) + v19));
            }
            else
            {
              v27 = *((_QWORD *)buffer + 18);
              if (v27)
              {
                v21 = *(char *)(v27 + *((_QWORD *)buffer + 19) + v19);
              }
              else
              {
                if (*((_QWORD *)buffer + 22) < v5 || (v30 = *((_QWORD *)buffer + 21), v30 >= v5))
                {
                  v31 = v5 - 5;
                  if ((unint64_t)v5 < 5)
                    v31 = 0;
                  if (v31 + 64 < v18)
                    v18 = v31 + 64;
                  *((_QWORD *)buffer + 21) = v31;
                  *((_QWORD *)buffer + 22) = v18;
                  v34.location = *((_QWORD *)buffer + 19) + v31;
                  v34.length = v18 - v31;
                  CFStringGetCharacters(*((CFStringRef *)buffer + 16), v34, buffer);
                  v30 = *((_QWORD *)buffer + 21);
                }
                v21 = buffer[v19 - v30];
              }
            }
            if (v21 >> 10 != 54)
              goto LABEL_9;
            v11 = v11 + (v21 << 10) - 56613888;
            v12 = 2;
            --v5;
          }
LABEL_10:
          if (a4)
            goto LABEL_11;
          return v11;
        }
        v22 = v5 + 1;
        v23 = *((_QWORD *)buffer + 20);
        if (v23 > v5 + 1)
        {
          v24 = *((_QWORD *)buffer + 17);
          if (v24)
          {
            v25 = *(_WORD *)(v24 + 2 * (*((_QWORD *)buffer + 19) + v22));
          }
          else
          {
            v26 = *((_QWORD *)buffer + 18);
            if (v26)
            {
              v25 = *(char *)(v26 + *((_QWORD *)buffer + 19) + v22);
            }
            else
            {
              if (*((_QWORD *)buffer + 22) <= v22 || (v28 = *((_QWORD *)buffer + 21), v28 > v22))
              {
                v29 = v5 - 3;
                if ((unint64_t)v5 < 3)
                  v29 = 0;
                if (v29 + 64 < v23)
                  v23 = v29 + 64;
                *((_QWORD *)buffer + 21) = v29;
                *((_QWORD *)buffer + 22) = v23;
                v33.location = *((_QWORD *)buffer + 19) + v29;
                v33.length = v23 - v29;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v33, buffer);
                v28 = *((_QWORD *)buffer + 21);
              }
              v25 = buffer[v22 - v28];
            }
          }
          if (v25 >> 10 == 55)
          {
            v11 = ((_DWORD)v11 << 10) + v25 - 56613888;
            v12 = 2;
            goto LABEL_10;
          }
        }
      }
LABEL_9:
      v12 = 1;
      goto LABEL_10;
    }
  }
  v11 = 0;
  if (a4)
  {
    v12 = 0;
    v5 = -1;
LABEL_11:
    *a4 = v5;
    a4[1] = v12;
  }
  return v11;
}

uint64_t _CFStringInlineBufferGetComposedRange(UniChar *buffer, int64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v7;
  uint64_t v9;
  int64_t v10;
  uint64_t v11;
  UniChar v12;
  unsigned int v13;
  uint64_t BitmapPtrForPlane;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  UniChar v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  UniChar v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int64_t v31;
  int64_t v32;
  unsigned int v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  UniChar v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  UniChar v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  UniChar v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  UniChar v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unsigned int v77;
  uint64_t v78;
  int64_t v79;
  uint64_t v80;
  UniChar v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  BOOL v90;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  CFRange v96;
  CFRange v97;
  CFRange v98;
  CFRange v99;
  CFRange v100;
  CFRange v101;
  CFRange v102;
  CFRange v103;

  v7 = a2;
  v9 = a2 + 1;
  if (a2 < 0)
    goto LABEL_160;
  v10 = *((_QWORD *)buffer + 20);
  if (v10 <= a2)
  {
    v13 = 0;
LABEL_6:
    BitmapPtrForPlane = a4;
    goto LABEL_7;
  }
  v11 = *((_QWORD *)buffer + 17);
  if (v11)
  {
    v12 = *(_WORD *)(v11 + 2 * (*((_QWORD *)buffer + 19) + a2));
  }
  else
  {
    v30 = *((_QWORD *)buffer + 18);
    if (v30)
    {
      v12 = *(char *)(v30 + *((_QWORD *)buffer + 19) + a2);
    }
    else
    {
      if (*((_QWORD *)buffer + 22) <= a2 || (v31 = *((_QWORD *)buffer + 21), v31 > a2))
      {
        v32 = a2 - 4;
        if ((unint64_t)a2 < 4)
          v32 = 0;
        if (v32 + 64 < v10)
          v10 = v32 + 64;
        *((_QWORD *)buffer + 21) = v32;
        *((_QWORD *)buffer + 22) = v10;
        v98.location = *((_QWORD *)buffer + 19) + v32;
        v98.length = v10 - v32;
        CFStringGetCharacters(*((CFStringRef *)buffer + 16), v98, buffer);
        v31 = *((_QWORD *)buffer + 21);
      }
      v12 = buffer[v7 - v31];
    }
  }
  v13 = v12;
  if (a3 == 4 && v12 >= 0x530u && (unsigned __int16)(v12 >> 4) < 0x195u)
    goto LABEL_69;
  if (v12 >> 10 != 54)
    goto LABEL_6;
  v35 = *((_QWORD *)buffer + 20);
  if (v35 <= v9)
    goto LABEL_6;
  v36 = *((_QWORD *)buffer + 17);
  if (v36)
  {
    v37 = *(_WORD *)(v36 + 2 * (*((_QWORD *)buffer + 19) + v9));
  }
  else
  {
    v92 = *((_QWORD *)buffer + 18);
    if (v92)
    {
      v37 = *(char *)(v92 + *((_QWORD *)buffer + 19) + v9);
    }
    else
    {
      if (*((_QWORD *)buffer + 22) <= v9 || (v93 = *((_QWORD *)buffer + 21), v93 > v9))
      {
        v94 = v7 - 3;
        if ((unint64_t)v9 < 4)
          v94 = 0;
        if (v94 + 64 < v35)
          v35 = v94 + 64;
        *((_QWORD *)buffer + 21) = v94;
        *((_QWORD *)buffer + 22) = v35;
        v103.location = *((_QWORD *)buffer + 19) + v94;
        v103.length = v35 - v94;
        CFStringGetCharacters(*((CFStringRef *)buffer + 16), v103, buffer);
        v93 = *((_QWORD *)buffer + 21);
      }
      v37 = buffer[v9 - v93];
    }
  }
  BitmapPtrForPlane = a4;
  if (v37 >> 10 == 55)
  {
    v9 = v7 + 2;
    v13 = (v13 << 10) + v37 - 56613888;
    BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(a5, HIWORD(v13));
  }
LABEL_7:
  if (v7)
  {
    while (1)
    {
      if (a3 == 4 && v13 >= 0x530 && v13 >> 4 < 0x195)
        goto LABEL_69;
      if (HIWORD(v13))
        goto LABEL_31;
      if ((v13 & 0xFC00) != 0xDC00)
        break;
      v15 = *((_QWORD *)buffer + 20);
      if (v15 < v7)
        break;
      v16 = v7 - 1;
      v17 = *((_QWORD *)buffer + 17);
      if (v17)
      {
        v18 = *(_WORD *)(v17 + 2 * (*((_QWORD *)buffer + 19) + v16));
      }
      else
      {
        v19 = *((_QWORD *)buffer + 18);
        if (v19)
        {
          v18 = *(char *)(v19 + *((_QWORD *)buffer + 19) + v16);
        }
        else
        {
          if (*((_QWORD *)buffer + 22) < v7 || (v20 = *((_QWORD *)buffer + 21), v20 >= v7))
          {
            v21 = v7 - 5;
            if ((unint64_t)v7 < 5)
              v21 = 0;
            if (v21 + 64 < v15)
              v15 = v21 + 64;
            *((_QWORD *)buffer + 21) = v21;
            *((_QWORD *)buffer + 22) = v15;
            v96.location = *((_QWORD *)buffer + 19) + v21;
            v96.length = v15 - v21;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v96, buffer);
            v20 = *((_QWORD *)buffer + 21);
          }
          v18 = buffer[v16 - v20];
        }
      }
      if (v18 >> 10 != 54)
        break;
      v13 = v13 + (v18 << 10) - 56613888;
      v22 = CFUniCharGetBitmapPtrForPlane(a5, HIWORD(v13));
      if (v7 == 1)
      {
        v7 = 0;
        goto LABEL_69;
      }
      BitmapPtrForPlane = v22;
      if (v22)
      {
LABEL_32:
        v23 = (*(unsigned __int8 *)(BitmapPtrForPlane + ((unsigned __int16)v13 >> 3)) >> (v13 & 7)) & 1;
        goto LABEL_33;
      }
LABEL_29:
      LOBYTE(v23) = 0;
LABEL_33:
      if (v13 != 8205
        && (v13 & 0xFFFFFFFE) != 0xFF9E
        && (v13 & 0x1FFFF0) != 0xF870
        && v13 - 127995 >= 5
        && (v23 & 1) == 0
        && v13 - 917536 > 0x5F)
      {
        v7 = v16;
        goto LABEL_69;
      }
      v7 = v16 - 1;
      v24 = *((_QWORD *)buffer + 20);
      if (v24 >= v16)
      {
        v26 = *((_QWORD *)buffer + 17);
        if (v26)
        {
          v25 = *(_WORD *)(v26 + 2 * (*((_QWORD *)buffer + 19) + v7));
        }
        else
        {
          v27 = *((_QWORD *)buffer + 18);
          if (v27)
          {
            v25 = *(char *)(v27 + *((_QWORD *)buffer + 19) + v7);
          }
          else
          {
            if (*((_QWORD *)buffer + 22) < v16 || (v28 = *((_QWORD *)buffer + 21), v28 >= v16))
            {
              v29 = v16 - 5;
              if ((unint64_t)v7 < 4)
                v29 = 0;
              if (v29 + 64 < v24)
                v24 = v29 + 64;
              *((_QWORD *)buffer + 21) = v29;
              *((_QWORD *)buffer + 22) = v24;
              v97.location = *((_QWORD *)buffer + 19) + v29;
              v97.length = v24 - v29;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v97, buffer);
              v28 = *((_QWORD *)buffer + 21);
            }
            v25 = buffer[v7 - v28];
          }
        }
      }
      else
      {
        v25 = 0;
      }
      v13 = v25;
      if (v16 <= 1)
        goto LABEL_69;
    }
    BitmapPtrForPlane = a4;
LABEL_31:
    v16 = v7;
    if (BitmapPtrForPlane)
      goto LABEL_32;
    goto LABEL_29;
  }
LABEL_69:
  v33 = v13 - 44032;
  if (v13 - 4352 >= 0xFA && v33 >> 4 > 0x2BA)
    goto LABEL_160;
  if (v13 >> 5 >= 0x8B)
  {
    if (v13 >> 3 >= 0x235)
    {
      if (v13 >> 10 >= 0x2B)
      {
        HIDWORD(v38) = -1227133513 * v33;
        LODWORD(v38) = -1227133513 * v33;
        if ((v38 >> 2) < 0x924924A)
          v34 = 3;
        else
          v34 = 4;
      }
      else
      {
        v34 = 2;
      }
    }
    else
    {
      v34 = 1;
    }
  }
  else
  {
    v34 = 0;
  }
  if (v7 >= 1)
  {
    v39 = -v7;
    v40 = v7 + 64;
    v41 = v34;
    while (1)
    {
      if ((unint64_t)v7 >= 5)
        v42 = 5;
      else
        v42 = v7;
      v43 = *((_QWORD *)buffer + 20);
      if (v43 < v7)
        goto LABEL_123;
      v44 = *((_QWORD *)buffer + 17);
      if (v44)
      {
        v45 = *(_WORD *)(v44 + 2 * (v7 + *((_QWORD *)buffer + 19)) - 2);
      }
      else
      {
        v46 = *((_QWORD *)buffer + 18);
        if (v46)
        {
          v45 = *(char *)(v46 + *((_QWORD *)buffer + 19) + v7 - 1);
        }
        else
        {
          if (*((_QWORD *)buffer + 22) < v7 || (v47 = *((_QWORD *)buffer + 21), v47 >= v7))
          {
            v48 = -v42;
            v49 = v42 + v39;
            v50 = v40 - v42;
            v51 = v7 + v48;
            v52 = v51 + 64;
            if (v51 + 64 >= v43)
              v52 = *((_QWORD *)buffer + 20);
            *((_QWORD *)buffer + 21) = v51;
            *((_QWORD *)buffer + 22) = v52;
            if (v43 >= v50)
              v43 = v50;
            v99.length = v43 + v49;
            v99.location = v51 + *((_QWORD *)buffer + 19);
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v99, buffer);
            v47 = *((_QWORD *)buffer + 21);
          }
          v45 = buffer[v7 - 1 - v47];
        }
      }
      if ((unsigned __int16)((unsigned __int16)(v45 - 4352) >> 4) > 0xC6Au || (unsigned __int16)(v45 + 21504) > 0x65F9u)
        goto LABEL_123;
      if (v41 == 2)
        break;
      v53 = v45 >> 5;
      if (v41 == 1)
      {
        if (v53 >= 0x8B)
        {
          if (v45 >> 10 >= 0x2Bu)
          {
            HIDWORD(v54) = -1840706560 - 1227133513 * v45;
            LODWORD(v54) = HIDWORD(v54);
            if ((v54 >> 2) >= 0x924924A)
              goto LABEL_123;
            v41 = 3;
            goto LABEL_121;
          }
          if (v45 > 0x11A2u)
            goto LABEL_123;
          goto LABEL_118;
        }
      }
      else if (v53 > 0x8A)
      {
        goto LABEL_123;
      }
      v41 = 0;
LABEL_121:
      --v7;
      ++v39;
      --v40;
      if ((unint64_t)(v7 + 1) <= 1)
      {
        v7 = 0;
        goto LABEL_123;
      }
    }
    if (v45 - 4448 >= 0x43)
    {
      if (v45 >> 10 < 0x2Bu)
      {
        if (v45 >> 5 < 0x8Bu)
          goto LABEL_123;
        v41 = 2;
      }
      else
      {
        HIDWORD(v55) = -1840706560 - 1227133513 * v45;
        LODWORD(v55) = HIDWORD(v55);
        if ((v55 >> 2) < 0x924924A)
          v41 = 3;
        else
          v41 = 4;
      }
      goto LABEL_121;
    }
LABEL_118:
    v41 = 1;
    goto LABEL_121;
  }
LABEL_123:
  if ((v9 & 0x8000000000000000) == 0)
  {
    v56 = *((_QWORD *)buffer + 20);
    if (v56 > v9)
    {
      v57 = -v9;
      v58 = v9 + 64;
      while (2)
      {
        v59 = (unint64_t)v9 >= 4 ? 4 : v9;
        v60 = *((_QWORD *)buffer + 17);
        if (v60)
        {
          v61 = *(_WORD *)(v60 + 2 * (v9 + *((_QWORD *)buffer + 19)));
        }
        else
        {
          v62 = *((_QWORD *)buffer + 18);
          if (v62)
          {
            v61 = *(char *)(v62 + *((_QWORD *)buffer + 19) + v9);
          }
          else
          {
            if (*((_QWORD *)buffer + 22) <= v9 || (v63 = *((_QWORD *)buffer + 21), v63 > v9))
            {
              v64 = -v59;
              v65 = v59 + v57;
              v66 = v58 - v59;
              v67 = v9 + v64;
              v68 = v67 + 64;
              if (v67 + 64 >= v56)
                v68 = v56;
              *((_QWORD *)buffer + 21) = v67;
              *((_QWORD *)buffer + 22) = v68;
              if (v56 >= v66)
                v56 = v66;
              v100.length = v56 + v65;
              v100.location = v67 + *((_QWORD *)buffer + 19);
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v100, buffer);
              v63 = *((_QWORD *)buffer + 21);
            }
            v61 = buffer[v9 - v63];
          }
        }
        if (v61
          && (v61 - 4352 < 0xFA || (unsigned __int16)((unsigned __int16)(v61 + 21504) >> 4) <= 0x2BAu))
        {
          switch(v34)
          {
            case 1:
            case 3:
              if (v61 - 4448 <= 0x99)
              {
                if (v61 >> 3 < 0x235u)
                  v34 = 1;
                else
                  v34 = 2;
                goto LABEL_159;
              }
              break;
            case 2:
            case 4:
              if (v61 - 4520 < 0x52)
              {
                v34 = 2;
                goto LABEL_159;
              }
              break;
            default:
              if (v61 >> 5 >= 0x8Bu)
              {
                if (v61 >> 3 >= 0x235u)
                {
                  if (v61 >> 10 < 0x2Bu)
                    break;
                  HIDWORD(v69) = -1227133513 * v61 - 1840706560;
                  LODWORD(v69) = HIDWORD(v69);
                  if ((v69 >> 2) < 0x924924A)
                    v34 = 3;
                  else
                    v34 = 4;
                }
                else
                {
                  v34 = 1;
                }
              }
              else
              {
                v34 = 0;
              }
LABEL_159:
              ++v9;
              v56 = *((_QWORD *)buffer + 20);
              --v57;
              ++v58;
              if (v56 > v9)
                continue;
              break;
          }
        }
        break;
      }
    }
  }
LABEL_160:
  do
  {
    v70 = v9;
    if (v9 < 0)
      break;
    v71 = *((_QWORD *)buffer + 20);
    if (v71 <= v9)
      break;
    v72 = *((_QWORD *)buffer + 17);
    if (v72)
    {
      v73 = *(_WORD *)(v72 + 2 * (*((_QWORD *)buffer + 19) + v9));
    }
    else
    {
      v74 = *((_QWORD *)buffer + 18);
      if (v74)
      {
        v73 = *(char *)(v74 + *((_QWORD *)buffer + 19) + v9);
      }
      else
      {
        if (*((_QWORD *)buffer + 22) <= v9 || (v75 = *((_QWORD *)buffer + 21), v75 > v9))
        {
          v76 = v9 - 4;
          if ((unint64_t)v9 < 4)
            v76 = 0;
          if (v76 + 64 < v71)
            v71 = v76 + 64;
          *((_QWORD *)buffer + 21) = v76;
          *((_QWORD *)buffer + 22) = v71;
          v101.location = *((_QWORD *)buffer + 19) + v76;
          v101.length = v71 - v76;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v101, buffer);
          v75 = *((_QWORD *)buffer + 21);
        }
        v73 = buffer[v9 - v75];
      }
    }
    v77 = v73;
    if (!v73 || a3 == 4 && (unsigned __int16)((unsigned __int16)(v73 - 1328) >> 5) < 0xA1u)
      break;
    if (v73 >> 10 != 54)
      goto LABEL_194;
    v78 = v9 + 1;
    v79 = *((_QWORD *)buffer + 20);
    if (v79 <= (uint64_t)(v70 + 1))
      goto LABEL_194;
    v80 = *((_QWORD *)buffer + 17);
    if (v80)
    {
      v81 = *(_WORD *)(v80 + 2 * (*((_QWORD *)buffer + 19) + v78));
    }
    else
    {
      v82 = *((_QWORD *)buffer + 18);
      if (v82)
      {
        v81 = *(char *)(v82 + *((_QWORD *)buffer + 19) + v78);
      }
      else
      {
        if (*((_QWORD *)buffer + 22) <= v78 || (v83 = *((_QWORD *)buffer + 21), v83 > v78))
        {
          v84 = v70 - 3;
          if (v70 < 3)
            v84 = 0;
          if ((uint64_t)(v84 + 64) < v79)
            v79 = v84 + 64;
          *((_QWORD *)buffer + 21) = v84;
          *((_QWORD *)buffer + 22) = v79;
          v102.location = *((_QWORD *)buffer + 19) + v84;
          v102.length = v79 - v84;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v102, buffer);
          v83 = *((_QWORD *)buffer + 21);
        }
        v81 = buffer[v78 - v83];
      }
    }
    if (v81 >> 10 == 55)
    {
      v77 = (v77 << 10) + v81 - 56613888;
      v85 = CFUniCharGetBitmapPtrForPlane(a5, HIWORD(v77));
      v86 = 2;
      if (v85)
        goto LABEL_195;
    }
    else
    {
LABEL_194:
      v85 = a4;
      v86 = 1;
      if (a4)
      {
LABEL_195:
        v87 = (*(unsigned __int8 *)(v85 + ((unsigned __int16)v77 >> 3)) >> (v77 & 7)) & 1;
        goto LABEL_196;
      }
    }
    LOBYTE(v87) = 0;
LABEL_196:
    v9 = v86 + v70;
    v90 = v77 != 8205 && (v77 & 0xFFFFFFFE) != 65438 && (v77 & 0x1FFFF0) != 63600 && v77 - 127995 >= 5;
  }
  while (!v90 || (v87 & 1) != 0 || v77 - 917536 < 0x60);
  return v7;
}

BOOL __CFStringIsRegionalIndicatorAtIndex(UniChar *buffer, int64_t a2)
{
  int64_t v4;
  uint64_t v5;
  UniChar *v6;
  int64_t v7;
  int64_t v8;
  uint64_t v9;
  UniChar v10;
  int64_t v12;
  int64_t v13;
  uint64_t v14;
  int64_t v15;
  int64_t v16;
  CFRange v17;
  CFRange v18;

  if (a2 < 0)
    return 0;
  v4 = *((_QWORD *)buffer + 20);
  if (v4 <= a2)
    return 0;
  v5 = *((_QWORD *)buffer + 17);
  if (v5)
  {
    v6 = (UniChar *)(v5 + 2 * (*((_QWORD *)buffer + 19) + a2));
  }
  else
  {
    if (*((_QWORD *)buffer + 18))
      return 0;
    if (*((_QWORD *)buffer + 22) <= a2 || (v12 = *((_QWORD *)buffer + 21), v12 > a2))
    {
      v13 = a2 - 4;
      if ((unint64_t)a2 < 4)
        v13 = 0;
      if (v13 + 64 < v4)
        v4 = v13 + 64;
      *((_QWORD *)buffer + 21) = v13;
      *((_QWORD *)buffer + 22) = v4;
      v17.location = *((_QWORD *)buffer + 19) + v13;
      v17.length = v4 - v13;
      CFStringGetCharacters(*((CFStringRef *)buffer + 16), v17, buffer);
      v12 = *((_QWORD *)buffer + 21);
    }
    v6 = &buffer[a2 - v12];
  }
  if (*v6 != 55356)
    return 0;
  v7 = a2 + 1;
  v8 = *((_QWORD *)buffer + 20);
  if (v8 <= a2 + 1)
  {
    v10 = 0;
  }
  else
  {
    v9 = *((_QWORD *)buffer + 17);
    if (v9)
    {
      v10 = *(_WORD *)(v9 + 2 * (*((_QWORD *)buffer + 19) + v7));
    }
    else
    {
      v14 = *((_QWORD *)buffer + 18);
      if (v14)
      {
        v10 = *(char *)(v14 + *((_QWORD *)buffer + 19) + v7);
      }
      else
      {
        if (*((_QWORD *)buffer + 22) <= v7 || (v15 = *((_QWORD *)buffer + 21), v15 > v7))
        {
          v16 = a2 - 3;
          if ((unint64_t)a2 < 3)
            v16 = 0;
          if (v16 + 64 < v8)
            v8 = v16 + 64;
          *((_QWORD *)buffer + 21) = v16;
          *((_QWORD *)buffer + 22) = v8;
          v18.location = *((_QWORD *)buffer + 19) + v16;
          v18.length = v8 - v16;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v18, buffer);
          v15 = *((_QWORD *)buffer + 21);
        }
        v10 = buffer[v7 - v15];
      }
    }
  }
  return (unsigned __int16)(v10 + 8730) < 0x1Au;
}

CFArrayRef CFPreferencesCopyKeyList(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFArrayRef)_CFPreferencesCopyKeyListWithContainer((__CFString *)applicationID, userName, hostName, 0);
}

BOOL __CFNumberEqual(const __CFNumber *a1, const __CFNumber *a2, void *a3)
{
  return CFNumberCompare(a1, a2, a3) == kCFCompareEqualTo;
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  CFNumberRef v20;
  BOOL v21;
  CFComparisonResult v22;
  int8x16_t v23;
  int8x16_t v24;
  float64x2_t v25;
  int8x16_t v26;
  double v27;
  double v28;
  int8x16_t v29;
  int8x16_t v30;
  float64x2_t v31;
  double v32;
  double v33;
  double v34;
  unint64_t v35;
  double v36;
  unint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x16uLL, (__objc2_class **)number))
    return -[__CFNumber compare:](number, "compare:", otherNumber);
  if (CF_IS_OBJC(0x16uLL, (__objc2_class **)otherNumber))
    return -[__CFNumber _reverseCompare:](otherNumber, "_reverseCompare:", number);
  if (((unint64_t)number & 0x8000000000000000) == 0)
    goto LABEL_16;
  v6 = 0;
  v7 = *MEMORY[0x1E0DE7C58];
  if ((~(unint64_t)number & 0xC000000000000007) == 0)
    v7 = 0;
  v8 = v7 ^ (unint64_t)number;
  v9 = v8 & 7;
  while (v9 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v6))
  {
    if (++v6 == 7)
      goto LABEL_16;
  }
  if (v6 == 3)
  {
    v10 = 0xFFFFFFFFFFFFFFFLL;
    if (v9 == 7)
      v10 = 0xFFFFFFFFFFFFFLL;
    v11 = v10 & (v8 >> 3);
  }
  else
  {
LABEL_16:
    LOBYTE(v11) = atomic_load((unint64_t *)number + 1);
  }
  v12 = __CFNumberCanonicalTypes[v11 & 7];
  if (((unint64_t)otherNumber & 0x8000000000000000) == 0)
    goto LABEL_28;
  v13 = 0;
  v14 = *MEMORY[0x1E0DE7C58];
  if ((~(unint64_t)otherNumber & 0xC000000000000007) == 0)
    v14 = 0;
  v15 = v14 ^ (unint64_t)otherNumber;
  v16 = v15 & 7;
  while (v16 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v13))
  {
    if (++v13 == 7)
      goto LABEL_28;
  }
  if (v13 == 3)
  {
    v17 = 0xFFFFFFFFFFFFFFFLL;
    if (v16 == 7)
      v17 = 0xFFFFFFFFFFFFFLL;
    v18 = v17 & (v15 >> 3);
  }
  else
  {
LABEL_28:
    LOBYTE(v18) = atomic_load((unint64_t *)otherNumber + 1);
  }
  v19 = __CFNumberTypeTable[__CFNumberCanonicalTypes[v18 & 7]] & 0x20;
  if ((__CFNumberTypeTable[v12] & 0x20) == 0)
  {
    if (!v19)
    {
      v36 = 0.0;
      v37 = 0;
      v34 = 0.0;
      v35 = 0;
      __CFNumberGetValue((uint64_t)number, 17, (uint64_t)&v36);
      __CFNumberGetValue((uint64_t)otherNumber, 17, (uint64_t)&v34);
      if (*(uint64_t *)&v36 >= *(uint64_t *)&v34)
      {
        if (*(uint64_t *)&v36 <= *(uint64_t *)&v34)
        {
          if (v37 >= v35)
            return (unint64_t)(v37 > v35);
          return -1;
        }
        return 1;
      }
      return -1;
    }
LABEL_36:
    if (v19)
      v20 = number;
    else
      v20 = otherNumber;
    if (!v19)
      otherNumber = number;
    v32 = 0.0;
    v33 = 0.0;
    __CFNumberGetValue((uint64_t)otherNumber, 6, (uint64_t)&v33);
    if (v33 < -1.70141183e38)
      goto LABEL_42;
    if (v33 >= 1.70141183e38)
      goto LABEL_63;
    v36 = 0.0;
    v37 = 0;
    v34 = 0.0;
    v35 = 0;
    __CFNumberGetValue((uint64_t)otherNumber, 17, (uint64_t)&v36);
    __CFNumberGetValue((uint64_t)v20, 17, (uint64_t)&v34);
    if (*(uint64_t *)&v36 < *(uint64_t *)&v34)
    {
LABEL_47:
      v22 = kCFCompareLessThan;
LABEL_52:
      v21 = v19 == 0;
      goto LABEL_64;
    }
    if (*(uint64_t *)&v36 > *(uint64_t *)&v34)
      goto LABEL_51;
    if (v37 < v35)
      goto LABEL_47;
    if (v37 > v35)
    {
LABEL_51:
      v22 = kCFCompareGreaterThan;
      goto LABEL_52;
    }
    *(double *)v29.i64 = v33;
    v30.i64[0] = 1.0;
    v31.f64[0] = NAN;
    v31.f64[1] = NAN;
    v29.i64[0] = vbslq_s8((int8x16_t)vnegq_f64(v31), v30, v29).u64[0];
    if (v34 < 0.0)
      *(double *)v30.i64 = -1.0;
    if (*(double *)v29.i64 >= *(double *)v30.i64)
    {
      if (*(double *)v30.i64 < *(double *)v29.i64)
      {
LABEL_63:
        v21 = v19 == 0;
        v22 = kCFCompareGreaterThan;
LABEL_64:
        if (v21)
          return v22;
        else
          return -(uint64_t)v22;
      }
      __CFNumberGetValue((uint64_t)v20, 6, (uint64_t)&v32);
      if (v33 >= v32)
      {
        if (v32 >= v33)
          return 0;
        goto LABEL_63;
      }
    }
LABEL_42:
    v21 = v19 == 0;
    v22 = kCFCompareLessThan;
    goto LABEL_64;
  }
  if (!v19)
    goto LABEL_36;
  v36 = 0.0;
  v34 = 0.0;
  __CFNumberGetValue((uint64_t)number, 6, (uint64_t)&v36);
  __CFNumberGetValue((uint64_t)otherNumber, 6, (uint64_t)&v34);
  *(double *)v23.i64 = v36;
  v24.i64[0] = 1.0;
  v25.f64[0] = NAN;
  v25.f64[1] = NAN;
  v26 = (int8x16_t)vnegq_f64(v25);
  v25.f64[0] = v34;
  v27 = *(double *)vbslq_s8(v26, v24, (int8x16_t)v25).i64;
  v28 = *(double *)vbslq_s8(v26, v24, v23).i64;
  if (v28 < v27)
    return -1;
  if (v27 < v28)
    return 1;
  if (v36 < v34)
    return -1;
  return (unint64_t)(v34 < v36);
}

CFStringRef __CFNumberCopyFormattingDescription(uint64_t number)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v8[2];
  char v9[128];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if ((number & 0x8000000000000000) == 0)
    goto LABEL_12;
  v1 = 0;
  v2 = *MEMORY[0x1E0DE7C58];
  if ((~number & 0xC000000000000007) == 0)
    v2 = 0;
  v3 = v2 ^ number;
  v4 = v3 & 7;
  while (v4 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v1))
  {
    if (++v1 == 7)
      goto LABEL_12;
  }
  if (v1 == 3)
  {
    v5 = 0xFFFFFFFFFFFFFFFLL;
    if (v4 == 7)
      v5 = 0xFFFFFFFFFFFFFLL;
    v6 = v5 & (v3 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v6) = atomic_load((unint64_t *)(number + 8));
  }
  if ((__CFNumberTypeTable[__CFNumberCanonicalTypes[v6 & 7]] & 0x20) != 0)
    return __CFNumberCreateFormattingDescriptionAsFloat64((const __CFAllocator *)&__kCFAllocatorSystemDefault, (CFNumberRef)number);
  v8[0] = 0;
  v8[1] = 0;
  __CFNumberGetValue(number, 17, (uint64_t)v8);
  emit128(v9, v8, 0);
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%s"), v9);
}

char *emit128(char *result, uint64_t *a2, int a3)
{
  uint64_t v3;
  unint64_t v4;
  char v5;
  BOOL v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t *v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;

  v3 = *a2;
  v4 = a2[1];
  if (*a2 < 0)
  {
    v6 = v4 == 0;
    v4 = -(uint64_t)v4;
    if (v6)
      v3 = -v3;
    else
      v3 = ~v3;
    v5 = 45;
    goto LABEL_8;
  }
  if (a3)
  {
    v5 = 43;
LABEL_8:
    *result++ = v5;
  }
  v7 = 0;
  v8 = 0;
  do
  {
    while (1)
    {
      v9 = 0;
      v10 = (uint64_t *)((char *)&powersOf10 + 16 * v7);
      v13 = *v10;
      v11 = (unint64_t *)(v10 + 1);
      v12 = v13;
      v14 = (_QWORD *)((char *)&neg_powersOf10 + 16 * v7);
      v15 = v14 + 1;
      while (v12 < v3 || v12 <= v3 && *v11 <= v4)
      {
        v3 += __CFADD__(v4, *v15) + *v14;
        v4 += *v15;
        ++v9;
      }
      v8 |= v9;
      if (!v8)
        break;
      *result++ = v9 + 48;
      ++v7;
      v8 = 1;
      if (v7 == 39)
        goto LABEL_19;
    }
    ++v7;
  }
  while (v7 != 39);
  *result++ = 48;
LABEL_19:
  *result = 0;
  return result;
}

Boolean CFCharacterSetIsSupersetOfSet(CFCharacterSetRef theSet, CFCharacterSetRef theOtherset)
{
  __objc2_class **v2;
  unint64_t *v3;
  unint64_t *v4;
  unint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  unint64_t v10;
  unsigned int v11;
  char v12;
  unint64_t v13;
  unsigned int v14;
  char v15;
  char v16;
  char v17;
  char v18;
  char v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  char v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  int IsEqualBitmap;
  unsigned __int8 v27;
  unsigned __int8 v28;
  char v29;
  char v30;
  unint64_t *Copy;
  char v32;
  char v33;
  unint64_t v34;
  int v35;
  int64_t v36;
  int64_t v37;
  int64_t v38;
  unint64_t v39;
  int v40;
  unsigned int v41;
  _BOOL4 v42;
  int v43;
  uint64_t v44;
  __int32 v45;
  __int32 v46;
  int v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t i;
  __int32 v54;
  __int32 v55;
  uint64_t v56;
  int64_t v57;
  uint64_t v58;
  char v59;
  uint64_t v61;
  int8x16_t __b[512];
  int8x16_t v63[512];
  uint64_t v64;

  v2 = (__objc2_class **)MEMORY[0x1E0C80A78](theSet, theOtherset);
  v4 = v3;
  v5 = (unint64_t *)v2;
  v64 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x19uLL, v2))
  {
    v6 = objc_msgSend(v5, "_expandedCFCharacterSet");
    if (!v6)
      goto LABEL_47;
  }
  else
  {
    v6 = 0;
  }
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)v4))
  {
    v7 = objc_msgSend(v4, "_expandedCFCharacterSet");
    if (!v7)
      goto LABEL_47;
  }
  else
  {
    v7 = 0;
  }
  if (v6)
    v5 = (unint64_t *)v6;
  if (v7)
    v4 = (unint64_t *)v7;
  v8 = v5[5];
  if (!v8 || !*(_DWORD *)(v8 + 8) && !*(_BYTE *)(v8 + 13))
  {
    v9 = atomic_load(v5 + 1);
    switch((v9 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (v5[4])
          goto LABEL_18;
        break;
      case 3u:
      case 4u:
        if (v5[3])
          goto LABEL_18;
        break;
      default:
        goto LABEL_18;
    }
    v12 = atomic_load(v5 + 1);
    if ((v12 & 8) == 0)
    {
      v13 = v4[5];
      if (!v13 || !*(_DWORD *)(v13 + 8) && !*(_BYTE *)(v13 + 13))
      {
        v14 = atomic_load(v4 + 1);
        switch((v14 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (v4[4])
              goto LABEL_103;
            break;
          case 3u:
          case 4u:
            if (v4[3])
              goto LABEL_103;
            break;
          default:
            goto LABEL_103;
        }
        v59 = atomic_load(v4 + 1);
        if ((v59 & 8) == 0)
          goto LABEL_47;
      }
LABEL_103:
      LOBYTE(IsEqualBitmap) = 0;
      return IsEqualBitmap;
    }
    goto LABEL_97;
  }
LABEL_18:
  v10 = v4[5];
  if (!v10 || !*(_DWORD *)(v10 + 8) && !*(_BYTE *)(v10 + 13))
  {
    v11 = atomic_load(v4 + 1);
    switch((v11 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (v4[4])
          goto LABEL_34;
        break;
      case 3u:
      case 4u:
        if (v4[3])
          goto LABEL_34;
        break;
      default:
        goto LABEL_34;
    }
    v15 = atomic_load(v4 + 1);
    if ((v15 & 8) == 0)
      goto LABEL_97;
  }
LABEL_34:
  v16 = atomic_load(v5 + 1);
  if ((v16 & 0x70) == 0 || (v17 = atomic_load(v4 + 1), (v17 & 0x70) == 0))
  {
    v27 = atomic_load(v5 + 1);
    v28 = atomic_load(v4 + 1);
    if (((v28 ^ v27) & 0x70) != 0)
      goto LABEL_47;
    if (v5[3] != v4[3])
      goto LABEL_47;
    v29 = atomic_load(v5 + 1);
    if ((v29 & 8) != 0)
      goto LABEL_47;
    v30 = atomic_load(v4 + 1);
    if ((v30 & 8) != 0)
      goto LABEL_47;
    goto LABEL_97;
  }
  v18 = atomic_load(v5 + 1);
  if ((v18 & 0x70) != 0x10)
  {
    v19 = atomic_load(v4 + 1);
    if ((v19 & 0x70) != 0x10)
    {
      v34 = v5[5];
      if (v34)
        v35 = *(_DWORD *)(v34 + 8);
      else
        v35 = 0;
      v39 = v4[5];
      if (v39)
      {
        v40 = *(_DWORD *)(v39 + 8);
        if (v34)
          goto LABEL_56;
      }
      else
      {
        v40 = 0;
        if (v34)
        {
LABEL_56:
          v41 = *(unsigned __int8 *)(v34 + 13) != 0;
          if (v39)
            goto LABEL_57;
          goto LABEL_64;
        }
      }
      v41 = 0;
      if (v39)
      {
LABEL_57:
        v42 = *(unsigned __int8 *)(v39 + 13) == 0;
        if (v41)
          v43 = ~v35 & 0x1FFFE;
        else
          v43 = v35;
        if (*(_BYTE *)(v39 + 13))
          v40 = ~v40 & 0x1FFFE;
        goto LABEL_68;
      }
LABEL_64:
      if (v41)
        v43 = ~v35 & 0x1FFFE;
      else
        v43 = v35;
      v42 = 1;
LABEL_68:
      __CFCSetGetBitmap((uint64_t)v5, v63);
      __CFCSetGetBitmap((uint64_t)v4, __b);
      v44 = 0;
      while (v44 != 2048)
      {
        v45 = __b[0].i32[v44];
        v46 = v63[0].i32[v44++];
        if ((v45 & ~v46) != 0)
          goto LABEL_103;
      }
      if (v40)
      {
        if ((v40 & ~v43) == 0)
        {
          v61 = v41 - 1;
          v47 = (int)(v41 << 31) >> 31;
          v48 = 1;
          while (1)
          {
            v49 = v5[5];
            if (v49)
            {
              if ((*(_DWORD *)(v49 + 8) & (1 << v48)) != 0
                && *(unsigned __int8 *)(v49 + 12) >= v48)
              {
                v50 = *(_QWORD *)(*(_QWORD *)v49 + 8 * (v48 - 1));
                if (v50)
                {
                  v51 = v4[5];
                  if (v51
                    && (*(_DWORD *)(v51 + 8) & (1 << v48)) != 0
                    && *(unsigned __int8 *)(v51 + 12) >= v48
                    && (v52 = *(_QWORD *)(*(_QWORD *)v51 + 8 * (v48 - 1))) != 0)
                  {
                    __CFCSetGetBitmap(v50, v63);
                    __CFCSetGetBitmap(v52, __b);
                    for (i = 0; i != 2048; ++i)
                    {
                      LOBYTE(IsEqualBitmap) = 0;
                      v54 = __b[0].i32[i] ^ (v42 - 1);
                      v55 = v63[0].i32[i] ^ v47;
                      if ((v54 & ~v55) != 0)
                        return IsEqualBitmap;
                    }
                  }
                  else if (!v42)
                  {
                    __CFCSetGetBitmap(v50, v63);
                    IsEqualBitmap = __CFCSetIsEqualBitmap((uint64_t)v63, v61);
                    if (!IsEqualBitmap)
                      return IsEqualBitmap;
                  }
                }
              }
            }
            if (++v48 == 17)
              goto LABEL_97;
          }
        }
        goto LABEL_103;
      }
      goto LABEL_97;
    }
  }
  v20 = atomic_load(v5 + 1);
  v21 = atomic_load(v4 + 1);
  if (((v21 ^ v20) & 0x70) != 0)
  {
LABEL_47:
    Copy = __CFCharacterSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, 1, 1);
    CFCharacterSetIntersect((CFMutableCharacterSetRef)Copy, (CFCharacterSetRef)v4);
    __CFCharacterSetEqual((uint64_t)Copy, (uint64_t)v4);
    v33 = v32;
    CFRelease(Copy);
    LOBYTE(IsEqualBitmap) = v33;
    return IsEqualBitmap;
  }
  v22 = atomic_load(v5 + 1);
  v23 = atomic_load(v4 + 1);
  if ((v22 & 8) != 0)
  {
    v36 = *((unsigned int *)v4 + 6);
    if ((v23 & 8) != 0)
    {
      v58 = *((unsigned int *)v5 + 6);
      if (v36 > v58)
        goto LABEL_103;
      v38 = v5[4] + v58;
      v36 += v4[4];
    }
    else
    {
      v37 = *((unsigned int *)v5 + 6);
      if ((uint64_t)(v4[4] + v36) <= v37)
        goto LABEL_97;
      v38 = v5[4] + v37;
    }
    LOBYTE(IsEqualBitmap) = v38 <= v36;
    return IsEqualBitmap;
  }
  if ((v23 & 8) != 0)
  {
    v56 = *((unsigned int *)v5 + 6);
    if ((_DWORD)v56 || v5[4] != 1114112)
    {
      v57 = *((unsigned int *)v4 + 6);
      if ((_DWORD)v57 || v56 < *((_DWORD *)v4 + 8))
      {
        if ((uint64_t)(v5[4] + v56) <= v57)
        {
          LOBYTE(IsEqualBitmap) = v4[4] + v57 == 1114112;
          return IsEqualBitmap;
        }
        goto LABEL_103;
      }
    }
LABEL_97:
    LOBYTE(IsEqualBitmap) = 1;
    return IsEqualBitmap;
  }
  v24 = *((unsigned int *)v4 + 6);
  v25 = *((unsigned int *)v5 + 6);
  if (v24 < v25)
    goto LABEL_103;
  LOBYTE(IsEqualBitmap) = (uint64_t)(v5[4] + v25) >= (uint64_t)(v4[4] + v24);
  return IsEqualBitmap;
}

void CFBundleUnloadExecutable(CFBundleRef bundle)
{
  _CFBundleUnloadExecutable((uint64_t)bundle, 0);
}

CFDictionaryRef CFPreferencesCopyMultiple(CFArrayRef keysToFetch, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesCopyMultipleWithContainer((uint64_t)keysToFetch, (__CFString *)applicationID, userName, hostName, 0);
}

os_unfair_lock_s *__directCFPrefsD_block_invoke()
{
  CFPrefsDaemon *v0;
  _BOOL4 v1;
  os_unfair_lock_s *result;

  v0 = [CFPrefsDaemon alloc];
  if (__CFProcessIsRestricted())
    v1 = 0;
  else
    v1 = getenv("__CFPreferencesTestDaemon") != 0;
  result = -[CFPrefsDaemon initWithRole:testMode:](v0, 3, v1);
  directCFPrefsD_daemon = (uint64_t)result;
  return result;
}

void _CFPreferencesFlushCachesForIdentifier(__CFString *a1, const void *a2)
{
  _xpc_connection_s **v4;
  _xpc_connection_s **v5;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v4 = (_xpc_connection_s **)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v5 = v4;
  -[_CFXPreferences flushCachesForAppIdentifier:user:](v4, a1, a2);

}

uint64_t CFPREFERENCES_IS_WAITING_FOR_SYSTEM_CFPREFSD(const os_unfair_lock *a1, uint64_t a2)
{
  os_unfair_lock_assert_not_owner(a1 + 17);
  os_unfair_lock_assert_not_owner(a1 + 18);
  os_unfair_lock_assert_not_owner(a1 + 19);
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

uint64_t CFPREFERENCES_IS_WAITING_FOR_DIRECT_CFPREFSD(const os_unfair_lock *a1, uint64_t a2)
{
  os_unfair_lock_assert_not_owner(a1 + 17);
  os_unfair_lock_assert_not_owner(a1 + 18);
  os_unfair_lock_assert_not_owner(a1 + 19);
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

void sub_182B6FCA0(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182B700B0()
{
  _Unwind_Exception *v0;

  objc_end_catch();
  _Unwind_Resume(v0);
}

void sub_182B700C8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *exc_buf)
{
  _Unwind_Exception *v10;

  if (a2)
  {
    objc_begin_catch(a1);
    JUMPOUT(0x182B70088);
  }
  _Unwind_Resume(v10);
}

void sub_182B700E0()
{
  _Unwind_Exception *v0;

  _Unwind_Resume(v0);
}

void sub_182B700E8()
{
  _Unwind_Exception *v0;

  objc_end_catch();
  _Unwind_Resume(v0);
}

void sub_182B70100()
{
  _Unwind_Exception *v0;

  objc_end_catch();
  _Unwind_Resume(v0);
}

void sub_182B70118(uint64_t a1, int a2)
{
  if (!a2)
    JUMPOUT(0x182B70120);
  objc_terminate();
}

uint64_t _CFPrefsDomainSizeAcceptabilityForByteCount(unint64_t a1)
{
  unsigned int v1;

  if (a1 < 0x400001)
    v1 = 1;
  else
    v1 = 2;
  if (a1 > 0x300000)
    return v1;
  else
    return 0;
}

unint64_t _CFLogvEx3(void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 *a7)
{
  unint64_t result;
  uint64_t v15;

  if (!os_log_shim_enabled())
    return _CFLogvEx2Predicate(a1, a2, a3, a4, a5, a6, a7, 1);
  result = _CFGetTSD(2u);
  if (result <= 3)
  {
    v15 = result;
    _CFSetTSD(2u, result + 1, 0);
    if (a5 <= 7)
      os_log_shim_with_CFString();
    _CFSetTSD(2u, v15, 0);
    result = also_do_stderr(0);
    if ((_DWORD)result)
      return _CFLogvEx2Predicate(a1, a2, a3, a4, a5, a6, a7, 0);
  }
  return result;
}

BOOL also_do_stderr(int a1)
{
  int v1;
  pid_t v2;
  int v4;
  unsigned int v5;
  stat v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (issetugid() || !getenv("CFLOG_FORCE_STDERR"))
    {
      memset(&v6, 0, sizeof(v6));
      if (fstat(2, &v6) < 0)
        return 0;
      if ((v6.st_mode & 0xB000) != 0x8000)
      {
        v1 = v6.st_mode & 0xF000;
        if (v1 != 4096 && v1 != 0x2000)
          return 0;
      }
    }
    return 1;
  }
  memset(&v6, 0, 64);
  v2 = getpid();
  if (proc_pidinfo(v2, 13, 0, &v6, 64) == 64 && (v6.st_atimespec.tv_sec & 2) != 0
    || getenv("OS_ACTIVITY_DT_MODE")
    || getenv("CFLOG_FORCE_DISABLE_STDERR"))
  {
    return 0;
  }
  if (!__CFProcessIsRestricted() && getenv("CFLOG_FORCE_STDERR"))
    return 1;
  memset(&v6, 0, sizeof(v6));
  v4 = fstat(2, &v6);
  if ((v4 & 0x80000000) == 0)
  {
    v5 = v6.st_mode & 0xF000;
    if (v5 >= 0x8000)
    {
      if (v5 != 49152 && v5 != 0x8000)
        return 0;
    }
    else if (v5 != 4096 && v5 != 0x2000)
    {
      return 0;
    }
  }
  return v4 >= 0;
}

uint64_t __CFProcessIsRestricted()
{
  return issetugid();
}

unint64_t _CFLogvEx2Predicate(void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 *a7, int a8)
{
  unint64_t result;
  uint64_t v17;
  const __CFString *v18;
  const __CFString *v19;
  CFIndex Length;
  CFIndex v21;
  char *v22;
  char *v23;
  int CString;
  size_t v25;
  BOOL v26;

  result = _CFGetTSD(2u);
  if (result <= 3)
  {
    v17 = result;
    _CFSetTSD(2u, result + 1, 0);
    if (a6)
    {
      v18 = _CFStringCreateWithFormatAndArgumentsAux2((const __CFAllocator *)&__kCFAllocatorSystemDefault, a2, a3, a4, 0, a6, a7);
      if (v18)
      {
        v19 = v18;
        Length = CFStringGetLength(v18);
        v21 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
        v22 = (char *)malloc_type_malloc(v21, 0xF04F014BuLL);
        if (v22)
        {
          v23 = v22;
          CString = CFStringGetCString(v19, v22, v21, 0x8000100u);
          v25 = strlen(v23);
          if (a5 <= 7)
          {
            if (CString)
              v26 = v25 == 0;
            else
              v26 = 1;
            if (!v26 && v25 <= 0x1000000)
            {
              if (a1)
              {
                a1(a5, v23, v25, 1);
              }
              else if (a8)
              {
                __CFLogCStringLegacy(a5, v23, v25, 1);
              }
              else
              {
                __CFLogCString((uint64_t)v23, v25);
              }
            }
          }
          free(v23);
        }
        CFRelease(v19);
      }
    }
    return _CFSetTSD(2u, v17, 0);
  }
  return result;
}

void __CFLogCString(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  char *__s[2];

  __s[1] = *(char **)MEMORY[0x1E0C80C00];
  v5 = 0;
  __s[0] = 0;
  v4 = 0;
  _populateBanner(__s, (char **)&v5, (char **)&v4);
  _logToStderr(__s[0], a1, a2);
  if (v4)
    free(v4);
  if (v5)
    free(v5);
  if (__s[0])
    free(__s[0]);
}

void _logToStderr(char *__s, uint64_t a2, uint64_t a3)
{
  char *v5;
  int v6;
  _BOOL4 v7;
  int v8;
  int v9;
  _QWORD v10[7];

  v5 = __s;
  v10[6] = *MEMORY[0x1E0C80C00];
  v10[0] = __s;
  if (__s)
  {
    __s = (char *)strlen(__s);
    v6 = 2;
  }
  else
  {
    v6 = 1;
  }
  v7 = v5 == 0;
  v10[1] = __s;
  v10[2] = a2;
  v10[3] = a3;
  v10[4] = "\n";
  v8 = *(unsigned __int8 *)(a3 + a2 - 1);
  v10[5] = v8 != 10;
  if (v8 == 10)
    v9 = v6;
  else
    v9 = v6 + 1;
  os_unfair_lock_lock((os_unfair_lock_t)&_logToStderr_lock);
  writev(2, (const iovec *)&v10[2 * v7], v9);
  os_unfair_lock_unlock((os_unfair_lock_t)&_logToStderr_lock);
}

uint64_t _populateBanner(char **a1, char **a2, char **a3)
{
  CFAbsoluteTime Current;
  int tm_mon;
  int tm_year;
  int tm_mday;
  int tm_hour;
  int tm_min;
  int tm_sec;
  double v12;
  _opaque_pthread_t *v13;
  unsigned int v14;
  int v15;
  int v16;
  const char *v17;
  pid_t v18;
  _opaque_pthread_t *v19;
  mach_port_t v20;
  __uint64_t v23;
  tm v24;
  time_t v25;
  long double __y[3];

  __y[1] = *(long double *)MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  v25 = vcvtmd_s64_f64(Current + 978307200.0);
  memset(&v24, 0, sizeof(v24));
  localtime_r(&v25, &v24);
  tm_mon = v24.tm_mon;
  tm_year = v24.tm_year;
  tm_hour = v24.tm_hour;
  tm_mday = v24.tm_mday;
  tm_sec = v24.tm_sec;
  tm_min = v24.tm_min;
  v12 = modf(Current, __y);
  v23 = 0;
  if (pthread_threadid_np(0, &v23))
  {
    v13 = pthread_self();
    v23 = pthread_mach_thread_np(v13);
  }
  v14 = vcvtmd_s64_f64(v12 * 1000.0);
  v15 = tm_mon + 1;
  v16 = tm_year + 1900;
  v17 = (const char *)*_CFGetProgname();
  v18 = getpid();
  asprintf(a1, "%04d-%02d-%02d %02d:%02d:%02d.%03d %s[%d:%llu] ", v16, v15, tm_mday, tm_hour, tm_min, tm_sec, v14, v17, v18, v23);
  v19 = pthread_self();
  v20 = pthread_mach_thread_np(v19);
  asprintf(a3, "%x", v20);
  return asprintf(a2, "%04d-%02d-%02d %02d:%02d:%02d.%03d", v16, v15, tm_mday, tm_hour, tm_min, tm_sec, v14);
}

uint64_t *_CFGetProgname()
{
  if (!__CFprogname)
    _CFProcessPath();
  return &__CFprogname;
}

void sub_182B711F4(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t _CFPrefsEncodeKeyValuePairsIntoMessage(xpc_object_t xdict, __objc2_class ***a2, __objc2_class ***a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v6;
  const __CFString **v8;
  uint64_t result;
  __objc2_class **v11;
  xpc_object_t v12;
  char v13;
  const __CFString *v14;
  __objc2_class **v15;
  uint64_t v16;
  char buffer[1026];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a4 <= 0)
    _CFPrefsEncodeKeyValuePairsIntoMessage_cold_1();
  v6 = a4;
  v8 = (const __CFString **)a2;
  v16 = 0;
  if (a4 == 1)
  {
    result = _CFPrefsEncodeValueIntoMessage(xdict, "Key", *a2, &v16);
    if ((_DWORD)result)
    {
      if (*a3)
        v11 = *a3;
      else
        v11 = &__kCFNull;
      result = _CFPrefsEncodeValueIntoMessage(xdict, "Value", v11, &v16);
    }
  }
  else
  {
    v12 = xpc_dictionary_create(0, 0, 0);
    v13 = 1;
    do
    {
      v14 = *v8;
      if (*v8)
      {
        bzero(buffer, 0x402uLL);
        if ((v13 & 1) != 0 && CFStringGetCString(v14, buffer, 1026, 0x8000100u))
        {
          if (*a3)
            v15 = *a3;
          else
            v15 = &__kCFNull;
          v13 = _CFPrefsEncodeValueIntoMessage(v12, buffer, v15, &v16);
        }
        else
        {
          v13 = 0;
        }
      }
      ++a3;
      ++v8;
      --v6;
    }
    while (v6);
    xpc_dictionary_set_BOOL(xdict, "MultiKeySet", 1);
    xpc_dictionary_set_value(xdict, "Value", v12);
    xpc_release(v12);
    result = v13 & 1;
  }
  if (a5)
    *a5 = v16;
  return result;
}

void sub_182B71404(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182B71520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_182B71908(_Unwind_Exception *a1)
{
  uint64_t v1;

  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 88));
  _Unwind_Resume(a1);
}

uint64_t CFPREFERENCES_IS_WAITING_FOR_USER_CFPREFSD(const os_unfair_lock *a1, uint64_t a2)
{
  os_unfair_lock_assert_not_owner(a1 + 17);
  os_unfair_lock_assert_not_owner(a1 + 18);
  os_unfair_lock_assert_not_owner(a1 + 19);
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

void sub_182B71CE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 72));
  _Unwind_Resume(a1);
}

CFIndex CFDictionaryGetCountOfKey(CFDictionaryRef theDict, const void *key)
{
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
    return -[__CFDictionary countForKey:](theDict, "countForKey:", key);
  else
    return CFBasicHashGetCountOfKey((uint64_t)theDict, (unint64_t)key);
}

void __CFNumberFormatterDeallocate(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  v2 = (const void *)a1[2];
  if (v2)
    __cficu_unum_close(v2);
  v3 = (const void *)a1[3];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[5];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[6];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)a1[7];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a1[8];
  if (v7)
    CFRelease(v7);
  v8 = (const void *)a1[9];
  if (v8)
    CFRelease(v8);
}

void __cficu_unum_close(const void *a1)
{
  CFStringRef v2;

  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    unum_close();
    ___CFICULogWithArguments(1, CFSTR("unum_close(%@);"), v2);
    CFRelease(v2);
  }
  else
  {
    unum_close();
  }
}

void sub_182B72438(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

void CFStringCapitalize(CFMutableStringRef theString, CFLocaleRef locale)
{
  uint64_t *p_info;
  unsigned int v5;
  char v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  char **p_data;
  char *v20;
  uint64_t length;
  uint64_t v22;
  uint64_t v23;
  char IsMemberOf;
  uint64_t v25;
  char v26;
  char **v27;
  char *v28;
  char v29;
  char **v30;
  unint64_t v31;
  char v32;
  unint64_t v33;
  char *v34;
  unint64_t v35;
  int v36;
  char v37;
  char v38;
  char v39;
  unsigned int ConditionalCaseMappingFlags;
  unsigned int v41;
  uint64_t v42;
  BOOL v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char v49;
  char v50;
  int v51;
  char v52;
  char v53;
  char v54;
  char v55;
  char v56;
  char v57;
  char v58;
  char v59;
  uint64_t BitmapPtrForPlane;
  char **v61;
  uint64_t v62;
  uint64_t v63;
  __int16 v64;
  _WORD v65[7];
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  p_info = &theString->info;
  v5 = atomic_load((unint64_t *)&theString->info);
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfCapitalize:](theString, "_cfCapitalize:", locale);
    return;
  }
  v6 = atomic_load((unint64_t *)p_info);
  if ((v6 & 1) == 0)
  {
    v7 = _CFOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      CFStringCapitalize_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    return;
  }
  v15 = atomic_load((unint64_t *)&theString->info);
  v16 = v15 & 5;
  v17 = atomic_load((unint64_t *)&theString->info);
  v18 = v17 & 0x60;
  if (v16 == 4)
  {
    p_data = &theString->data;
    if (v18)
    {
      v20 = *p_data;
    }
    else
    {
      v22 = atomic_load((unint64_t *)&theString->info);
      v20 = (char *)&p_data[(v22 & 5) != 4];
    }
    length = *v20;
  }
  else if ((v17 & 0x60) != 0)
  {
    length = theString->length;
  }
  else
  {
    length = (uint64_t)theString->data;
  }
  BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x6Du, 0);
  if (locale)
    locale = (CFLocaleRef)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 0);
  v23 = 0;
  IsMemberOf = 0;
  if (locale)
  {
    v25 = BitmapPtrForPlane;
    goto LABEL_21;
  }
  v25 = BitmapPtrForPlane;
  if (((v5 >> 4) & 1) != 0)
  {
LABEL_21:
    if (v23 >= length)
      return;
    if (((v5 >> 4) & 1) == 0)
    {
      v62 = 0;
      v63 = 0;
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, 0, 1);
    }
    v29 = atomic_load((unint64_t *)&theString->info);
    v30 = &theString->data;
    v61 = &theString->data;
    if ((v29 & 0x60) != 0)
    {
      v31 = (unint64_t)*v30;
    }
    else
    {
      v39 = atomic_load((unint64_t *)&theString->info);
      v31 = (unint64_t)&v30[(v39 & 5) != 4];
    }
    ConditionalCaseMappingFlags = 0;
    while (1)
    {
      v41 = *(unsigned __int16 *)(v31 + 2 * v23);
      v42 = v23 + 1;
      if ((v41 & 0xFC00) == 0xD800 && v42 < length)
      {
        v51 = *(unsigned __int16 *)(v31 + 2 * v42);
        if ((v51 & 0xFC00) == 0xDC00)
          v41 = v51 + (v41 << 10) - 56613888;
      }
      if (!locale && (v41 == 931 ? (v44 = IsMemberOf == 0) : (v44 = 1), v44))
        ConditionalCaseMappingFlags = 0;
      else
        ConditionalCaseMappingFlags = CFUniCharGetConditionalCaseMappingFlags(v41, v31, v23, length, 2 * (IsMemberOf == 0), (unsigned __int16 *)locale, ConditionalCaseMappingFlags);
      v45 = CFUniCharMapCaseTo(v41, &v64, 8, 2 * (IsMemberOf == 0), ConditionalCaseMappingFlags, (unsigned __int16 *)locale);
      v46 = v45 - 1;
      if (v45 >= 1)
        *(_WORD *)(v31 + 2 * v23) = v64;
      if (v41 >= 0x10000)
      {
        v47 = v45 - 2;
        if (v45 == 2)
        {
          ++v23;
          *(_WORD *)(v31 + 2 * v23) = v65[0];
        }
        else
        {
          v48 = v45 - 1;
          if (v45 == 1)
          {
            v62 = v23 + 1;
            v63 = 1;
            __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, 0, 1);
            v53 = atomic_load((unint64_t *)&theString->info);
            if ((v53 & 0x60) != 0)
            {
              v31 = (unint64_t)*v61;
            }
            else
            {
              v58 = atomic_load((unint64_t *)&theString->info);
              v31 = (unint64_t)&v61[(v58 & 5) != 4];
            }
            v25 = BitmapPtrForPlane;
            --length;
          }
          else if (v45)
          {
            v62 = v23 + 1;
            v63 = 0;
            __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, v47, 1);
            v54 = atomic_load((unint64_t *)&theString->info);
            if ((v54 & 0x60) != 0)
            {
              v31 = (unint64_t)*v61;
            }
            else
            {
              v59 = atomic_load((unint64_t *)&theString->info);
              v31 = (unint64_t)&v61[(v59 & 5) != 4];
            }
            memmove((void *)(v31 + 2 * v23 + 2), v65, 2 * v48);
            length += v47;
            v23 += v48;
            v25 = BitmapPtrForPlane;
          }
          else
          {
            v62 = v23;
            v63 = 2;
            __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, 0, 1);
            v49 = atomic_load((unint64_t *)&theString->info);
            if ((v49 & 0x60) != 0)
            {
              v31 = (unint64_t)*v61;
            }
            else
            {
              v57 = atomic_load((unint64_t *)&theString->info);
              v31 = (unint64_t)&v61[(v57 & 5) != 4];
            }
            v25 = BitmapPtrForPlane;
            length -= 2;
          }
        }
        if ((CFUniCharIsMemberOf(v41, 0x6Du) & 1) != 0)
          goto LABEL_98;
LABEL_95:
        if ((CFUniCharIsMemberOf(v41, 7u) & 1) != 0)
          IsMemberOf = 1;
        else
          IsMemberOf = CFUniCharIsMemberOf(v41, 6u);
        goto LABEL_98;
      }
      if (!v45)
        break;
      if (v45 < 2)
        goto LABEL_82;
      v62 = v23 + 1;
      v63 = 0;
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, v46, 1);
      v50 = atomic_load((unint64_t *)&theString->info);
      if ((v50 & 0x60) != 0)
      {
        v31 = (unint64_t)*v61;
      }
      else
      {
        v56 = atomic_load((unint64_t *)&theString->info);
        v31 = (unint64_t)&v61[(v56 & 5) != 4];
      }
      memmove((void *)(v31 + 2 * v23 + 2), v65, 2 * v46);
      length += v46;
      v23 += v46;
      if (!v25)
        goto LABEL_95;
LABEL_86:
      if (((*(unsigned __int8 *)(v25 + ((unint64_t)v41 >> 3)) >> (v41 & 7)) & 1) == 0)
        goto LABEL_95;
LABEL_98:
      if (++v23 >= length)
        return;
    }
    v62 = v23;
    v63 = 1;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v62, 1, 0, 1);
    v52 = atomic_load((unint64_t *)&theString->info);
    if ((v52 & 0x60) != 0)
    {
      v31 = (unint64_t)*v61;
    }
    else
    {
      v55 = atomic_load((unint64_t *)&theString->info);
      v31 = (unint64_t)&v61[(v55 & 5) != 4];
    }
    --length;
LABEL_82:
    if (!v25)
      goto LABEL_95;
    goto LABEL_86;
  }
  v26 = atomic_load((unint64_t *)&theString->info);
  v27 = &theString->data;
  if ((v26 & 0x60) != 0)
  {
    v28 = *v27;
  }
  else
  {
    v32 = atomic_load((unint64_t *)&theString->info);
    v28 = (char *)&v27[(v32 & 5) != 4];
  }
  v33 = atomic_load((unint64_t *)&theString->info);
  if (length >= 1)
  {
    v23 = 0;
    IsMemberOf = 0;
    v34 = &v28[(v33 >> 2) & 1];
    do
    {
      if (v34[v23] < 0)
        goto LABEL_21;
      v35 = v34[v23];
      v36 = v34[v23];
      if ((v35 - 65) > 0x19u)
      {
        if ((v36 - 97) > 0x19)
        {
          if (BitmapPtrForPlane)
          {
            if (((1 << (v36 & 7)) & *(unsigned __int8 *)(BitmapPtrForPlane + (v35 >> 3))) == 0)
              IsMemberOf = 0;
          }
          else
          {
            IsMemberOf = 0;
          }
          goto LABEL_38;
        }
        if (IsMemberOf)
          v38 = 0;
        else
          v38 = -32;
        v37 = v35 + v38;
      }
      else
      {
        v37 = v36 + 32 * (IsMemberOf != 0);
      }
      v34[v23] = v37;
      IsMemberOf = 1;
LABEL_38:
      ++v23;
    }
    while (length != v23);
  }
}

id _NSObjectStoreWeak(id *location, id obj, _BYTE *a3)
{
  id v5;
  id v6;

  if (!obj)
  {
    if (*location)
    {
      if (*a3)
      {
        v5 = 0;
        *location = 0;
        return v5;
      }
      objc_storeWeakOrNil(location, 0);
    }
    return 0;
  }
  v5 = obj;
  if (*a3)
    *location = 0;
  v6 = objc_storeWeakOrNil(location, obj);
  if (v6)
  {
    *a3 = 0;
    return v6;
  }
  else
  {
    *a3 = 1;
    *location = v5;
  }
  return v5;
}

const __CFString *_CFPrefsCopyUserNameForUID(uid_t a1)
{
  int v2;
  const void *v3;
  const __CFString *v5;
  const __CFString *v6;
  _QWORD v7[4];
  int v8;
  _QWORD block[4];
  uid_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = cfprefsdEuid();
  if (v2 != a1)
  {
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = ___CFPrefsCopyUserNameForUID_block_invoke_2;
    v7[3] = &__block_descriptor_36_e5_v8__0l;
    v8 = v2;
    if (_CFPrefsCopyUserNameForUID_onceToken_83 != -1)
      dispatch_once(&_CFPrefsCopyUserNameForUID_onceToken_83, v7);
    if (_CFPrefsCopyUserNameForUID_otherCommonUID == a1)
    {
      v3 = (const void *)_CFPrefsCopyUserNameForUID_otherCommonUIDName;
      if (_CFPrefsCopyUserNameForUID_otherCommonUIDName)
        return (const __CFString *)CFRetain(v3);
      return 0;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&_CFPrefsCopyUserNameForUID___cacheLock);
    if (_CFPrefsCopyUserNameForUID___cacheKey == a1 && _CFPrefsCopyUserNameForUID___hasCache == 1)
    {
      v5 = (const __CFString *)_CFPrefsCopyUserNameForUID___cachedResult;
    }
    else
    {
      v6 = _calculateUserNameForUID(a1);
      v5 = v6;
      if (!v6)
      {
LABEL_17:
        os_unfair_lock_unlock((os_unfair_lock_t)&_CFPrefsCopyUserNameForUID___cacheLock);
        return v5;
      }
      _CFPrefsCopyUserNameForUID___cacheKey = a1;
      _CFPrefsCopyUserNameForUID___hasCache = 1;
      _CFPrefsCopyUserNameForUID___cachedResult = (uint64_t)v6;
    }
    CFRetain(v5);
    goto LABEL_17;
  }
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___CFPrefsCopyUserNameForUID_block_invoke;
  block[3] = &__block_descriptor_36_e5_v8__0l;
  v10 = a1;
  if (_CFPrefsCopyUserNameForUID_onceToken != -1)
    dispatch_once(&_CFPrefsCopyUserNameForUID_onceToken, block);
  v3 = (const void *)_CFPrefsCopyUserNameForUID_ourUIDName;
  if (_CFPrefsCopyUserNameForUID_ourUIDName)
    return (const __CFString *)CFRetain(v3);
  return 0;
}

uint64_t cfprefsdEuid()
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) == 0)
    return geteuid();
  if (cfprefsdEuid_onceToken != -1)
    dispatch_once(&cfprefsdEuid_onceToken, &__block_literal_global_40);
  return cfprefsdEuid_euid;
}

Boolean CFFileSecurityCopyAccessControlList(CFFileSecurityRef fileSec, acl_t *accessControlList)
{
  return -[__CFFileSecurity copyAccessControlList:](fileSec, "copyAccessControlList:", accessControlList);
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet setObject:](theSet, "setObject:", value);
  }
  else
  {
    v10 = atomic_load((unint64_t *)theSet + 1);
    if ((v10 & 0x40) != 0)
      CFLog(3, (uint64_t)CFSTR("%s(): immutable collection %p given to mutating function"), v4, v5, v6, v7, v8, v9, (__int16)"void CFSetSetValue(CFMutableSetRef, const void *)");
    CFBasicHashSetValue((uint64_t)theSet, (unint64_t)value, (uint64_t)value);
  }
}

const void *_CFBundleCreateIfLooksLikeBundle(const __CFAllocator *a1, const __CFURL *a2)
{
  _QWORD *v2;
  const void *v3;

  v2 = _CFBundleCreate(a1, a2, 1, 0);
  v3 = v2;
  if (v2 && _CFBundleEffectiveLayoutVersion((uint64_t)v2) - 3 <= 1)
  {
    CFRelease(v3);
    return 0;
  }
  return v3;
}

void CFPlugInRemoveInstanceForFactory(CFUUIDRef factoryID)
{
  _BYTE *Value;

  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByFactoryID
    && (Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryID)) != 0
    && Value[24])
  {
    _CFPFactoryRemoveInstanceLocked((uint64_t)Value);
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
      CFPlugInRemoveInstanceForFactory_cold_2();
  }
  else
  {
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR))
      CFPlugInRemoveInstanceForFactory_cold_1();
  }
  os_unfair_recursive_lock_unlock();
}

void _CFPFactoryRemoveInstanceLocked(uint64_t a1)
{
  const void *v1;
  uint64_t PlugInData;
  __CFSet *v3;
  CFSetCallBacks v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v1 = *(const void **)(a1 + 40);
  if (v1 && *(_BYTE *)__CFBundleGetPlugInData(*(_QWORD *)(a1 + 40)))
  {
    PlugInData = __CFBundleGetPlugInData((uint64_t)v1);
    --*(_DWORD *)(PlugInData + 8);
    if (!*(_DWORD *)(__CFBundleGetPlugInData((uint64_t)v1) + 8) && *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)v1) + 1))
    {
      os_unfair_recursive_lock_lock_with_options();
      v3 = (__CFSet *)_plugInsToUnload;
      if (!_plugInsToUnload)
      {
        memset(&v4, 0, 24);
        v4.copyDescription = kCFTypeSetCallBacks.copyDescription;
        *(_OWORD *)&v4.equal = *(_OWORD *)&kCFTypeSetCallBacks.equal;
        v3 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &v4);
        _plugInsToUnload = (uint64_t)v3;
      }
      CFSetAddValue(v3, v1);
      if (_CFBundlePluginLogger_onceToken != -1)
        dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
      if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
        _CFPFactoryRemoveInstanceLocked_cold_1();
      os_unfair_recursive_lock_unlock();
    }
    CFRelease(v1);
  }
}

void CFPlugInAddInstanceForFactory(CFUUIDRef factoryID)
{
  _BYTE *Value;

  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByFactoryID
    && (Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryID)) != 0
    && Value[24])
  {
    _CFPFactoryAddInstanceLocked(Value);
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
      CFPlugInAddInstanceForFactory_cold_2();
  }
  else
  {
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR))
      CFPlugInAddInstanceForFactory_cold_1();
  }
  os_unfair_recursive_lock_unlock();
}

_QWORD *_CFPFactoryAddInstanceLocked(_QWORD *result)
{
  const void *v1;
  uint64_t PlugInData;

  v1 = (const void *)result[5];
  if (v1)
  {
    result = (_QWORD *)__CFBundleGetPlugInData(result[5]);
    if (*(_BYTE *)result)
    {
      if (!*(_DWORD *)(__CFBundleGetPlugInData((uint64_t)v1) + 8))
      {
        if (*(_BYTE *)(__CFBundleGetPlugInData((uint64_t)v1) + 1))
          _CFPlugInUnscheduleForUnloading(v1);
      }
      PlugInData = __CFBundleGetPlugInData((uint64_t)v1);
      ++*(_DWORD *)(PlugInData + 8);
      return CFRetain(v1);
    }
  }
  return result;
}

void *__cdecl CFPlugInInstanceCreate(CFAllocatorRef allocator, CFUUIDRef factoryUUID, CFUUIDRef typeUUID)
{
  const void *Value;
  uint64_t v7;
  const __CFArray *v8;
  uint64_t (*FunctionPointerForName)(uint64_t, uint64_t);
  NSObject *v10;
  uint64_t v11;
  uint64_t PlugInData;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;
  CFRange v34;

  v33 = *MEMORY[0x1E0C80C00];
  os_unfair_recursive_lock_lock_with_options();
  if (!_factoriesByFactoryID
    || (Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryUUID)) == 0
    || (v7 = (uint64_t)Value, !*((_BYTE *)Value + 24)))
  {
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR))
      CFPlugInInstanceCreate_cold_1();
    goto LABEL_27;
  }
  v8 = (const __CFArray *)*((_QWORD *)Value + 7);
  v34.length = CFArrayGetCount(v8);
  v34.location = 0;
  if ((CFArrayGetFirstIndexOfValue(v8, v34, typeUUID) & 0x80000000) != 0)
  {
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR))
      CFPlugInInstanceCreate_cold_4();
    goto LABEL_27;
  }
  if (!*(_BYTE *)(v7 + 24))
  {
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    v17 = _CFBundlePluginLogger__log;
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
      CFPlugInInstanceCreate_cold_2(v7, v17, v18, v19, v20, v21, v22, v23);
    goto LABEL_27;
  }
  FunctionPointerForName = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 32);
  if (!FunctionPointerForName)
  {
    FunctionPointerForName = (uint64_t (*)(uint64_t, uint64_t))CFBundleGetFunctionPointerForName(*(CFBundleRef *)(v7 + 40), *(CFStringRef *)(v7 + 48));
    *(_QWORD *)(v7 + 32) = FunctionPointerForName;
    if (!FunctionPointerForName)
    {
      if (_CFBundlePluginLogger_onceToken != -1)
        dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
      v10 = _CFBundlePluginLogger__log;
      if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR))
      {
        v24 = *(_QWORD *)(v7 + 16);
        v26 = *(_QWORD *)(v7 + 40);
        v25 = *(_QWORD *)(v7 + 48);
        v27 = 138543874;
        v28 = v25;
        v29 = 2114;
        v30 = v24;
        v31 = 2114;
        v32 = v26;
        _os_log_error_impl(&dword_182A8C000, v10, OS_LOG_TYPE_ERROR, "Cannot find function pointer %{public}@ for factory %{public}@ in %{public}@", (uint8_t *)&v27, 0x20u);
      }
      FunctionPointerForName = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 32);
      if (!FunctionPointerForName)
      {
LABEL_27:
        v13 = 0;
        goto LABEL_28;
      }
    }
  }
  v11 = *(_QWORD *)(v7 + 40);
  if (v11 && *(_BYTE *)__CFBundleGetPlugInData(*(_QWORD *)(v7 + 40)))
  {
    PlugInData = __CFBundleGetPlugInData(v11);
    ++*(_DWORD *)(PlugInData + 12);
  }
  os_unfair_recursive_lock_unlock();
  v13 = (void *)__CFPLUGIN_IS_CALLING_OUT_TO_A_FACTORY_FUNCTION__(FunctionPointerForName, (uint64_t)allocator, (uint64_t)typeUUID);
  if (_CFBundlePluginLogger_onceToken != -1)
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
    CFPlugInInstanceCreate_cold_3();
  os_unfair_recursive_lock_lock_with_options();
  v14 = *(_QWORD *)(v7 + 40);
  if (v14 && *(_BYTE *)__CFBundleGetPlugInData(*(_QWORD *)(v7 + 40)))
  {
    v15 = __CFBundleGetPlugInData(v14);
    --*(_DWORD *)(v15 + 12);
  }
LABEL_28:
  os_unfair_recursive_lock_unlock();
  return v13;
}

void _CFBundleEnsureBundleExistsForImagePath(uint64_t a1, uint64_t a2)
{
  const __CFURL *v2;
  const __CFURL *v3;
  os_unfair_lock_s *v4;
  uint64_t v5;
  os_unfair_lock_s *v6;
  int v7;
  const __CFDictionary *InfoDictionary;

  v2 = __CFBundleCopyFrameworkURLForExecutablePath(a1, a2);
  if (v2)
  {
    v3 = v2;
    v4 = (os_unfair_lock_s *)_CFBundleCreate(&__kCFAllocatorSystemDefault, v2, 4, 0);
    if (v4)
    {
      v5 = (uint64_t)v4;
      v6 = v4 + 24;
      os_unfair_lock_lock(v4 + 24);
      if (!*(_BYTE *)(v5 + 52))
      {
        _CFBundleDlfcnCheckLoaded(v5);
        v7 = *(_DWORD *)(v5 + 48);
        if (v7 != 6 && v7 != 1)
        {
          if (!v7)
            *(_DWORD *)(v5 + 48) = 4;
          *(_BYTE *)(v5 + 64) = 1;
        }
        if (!*(_BYTE *)(v5 + 52))
        {
          if (_CFBundleLoadingLogger_onceToken != -1)
            dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
          if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_DEBUG))
            _CFBundleEnsureBundleExistsForImagePath_cold_2();
        }
      }
      os_unfair_lock_unlock(v6);
      InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)v5);
      _CFBundleInitPlugIn((void *)v5, InfoDictionary, 0);
      _CFPlugInHandleDynamicRegistration(v5);
    }
    else
    {
      if (_CFBundleLoadingLogger_onceToken != -1)
        dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
      if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_DEBUG))
        _CFBundleEnsureBundleExistsForImagePath_cold_1();
    }
    CFRelease(v3);
  }
}

const __CFURL *_CFURLExists(const __CFURL *url)
{
  char v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  if (url)
  {
    if (_CFGetFileProperties((const __CFAllocator *)&__kCFAllocatorSystemDefault, url, &v1, 0, 0, 0, 0, 0))return 0;
    else
      return (const __CFURL *)(v1 != 0);
  }
  return url;
}

_QWORD *_CFBundleCreate(const __CFAllocator *a1, const __CFURL *a2, int a3, const __CFSet *a4)
{
  CFURLRef NormalizedURL;
  uint64_t v8;
  CFURLRef v9;
  char v10;
  char v11;
  char v12;
  char v13;
  char v14;
  char v15;
  _QWORD *v16;
  char v17;
  int BundleVersionForURL;
  char v19;
  uint64_t Instance;
  const __CFURL *v21;
  const __CFDictionary *InfoDictionary;
  CFStringRef Identifier;
  __CFString *v24;
  _QWORD *v25;
  _QWORD *v26;
  CFURLRef v27;
  __CFBundle *v29;
  __CFBundle *v30;
  const __CFString *v31;
  int v32;
  int v33;
  int v34;
  _BOOL4 v35;
  _BOOL4 v36;
  const void *Value;
  const void *v38;
  CFTypeID v39;
  const void *v40;
  NSObject *v41;
  char v42;
  stat v43;
  stat v44;
  char v45[1024];
  char buffer[4];
  const void *v47;
  __int16 v48;
  _QWORD *v49;
  __int16 v50;
  CFURLRef v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  NormalizedURL = _CFBundleCreateNormalizedURL(a1, a2);
  if (!NormalizedURL)
  {
    if (_CFBundleResourceLogger_onceToken != -1)
      dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
    if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_ERROR))
      _CFBundleCreate_cold_1();
    return 0;
  }
  v9 = NormalizedURL;
  v10 = 0;
  v11 = 1;
  v12 = 0;
  v13 = 0;
  v14 = 1;
  v15 = 1;
  switch(a3)
  {
    case 0:
      goto LABEL_11;
    case 1:
      v10 = 0;
      v14 = 0;
      v15 = 0;
      goto LABEL_9;
    case 2:
      v14 = 0;
      v15 = 0;
      v10 = 1;
LABEL_9:
      v13 = 1;
      goto LABEL_15;
    case 3:
      goto LABEL_15;
    case 4:
      v12 = 1;
LABEL_11:
      os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      v16 = _CFBundleCopyFromTablesForURLLocked(v9);
      os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      if (v16)
      {
        CFRelease(v9);
        return v16;
      }
      v10 = 0;
      v11 = 0;
      v13 = 0;
      v15 = v12;
LABEL_15:
      v42 = v15;
      v17 = v11;
      BundleVersionForURL = _CFBundleGetBundleVersionForURL((uint64_t)v9, v8);
      v19 = BundleVersionForURL;
      if (BundleVersionForURL != 3)
        goto LABEL_23;
      v45[0] = 0;
      *(_DWORD *)buffer = 0;
      if (_CFGetFileProperties(a1, v9, v45, buffer, 0, 0, 0, 0))
      {
        CFRelease(v9);
        if (_CFBundleLoadingLogger_onceToken != -1)
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
          _CFBundleCreate_cold_5();
        return 0;
      }
      if (!v45[0] || (*(_WORD *)buffer & 0xF000) != 0x4000)
      {
        if (_CFBundleLoadingLogger_onceToken != -1)
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_DEBUG))
          _CFBundleCreate_cold_2();
        v27 = v9;
        goto LABEL_40;
      }
LABEL_23:
      Instance = _CFRuntimeCreateInstance((__objc2_class **)a1, 0x1FuLL, 208, 0);
      if (!Instance)
      {
        CFRelease(v9);
        if (_CFBundleLoadingLogger_onceToken != -1)
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
          _CFBundleCreate_cold_3();
        return 0;
      }
      v16 = (_QWORD *)Instance;
      *(_QWORD *)(Instance + 16) = v9;
      *(_BYTE *)(Instance + 53) = v19;
      *(_DWORD *)(Instance + 48) = 0;
      *(_BYTE *)(Instance + 54) = v13;
      *(_BYTE *)(Instance + 55) = v10;
      *(_DWORD *)(Instance + 96) = 0;
      *(_DWORD *)(Instance + 112) = 0;
      *(_DWORD *)(Instance + 176) = 0;
      v21 = CFURLCopyAbsoluteURL(v9);
      v16[24] = CFURLCopyFileSystemPath(v21, kCFURLPOSIXPathStyle);
      CFRelease(v21);
      *((_DWORD *)v16 + 50) = 0;
      if (a4)
        _CFBundleLoadLimitedInfoDictionary((uint64_t)v16, a4);
      InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)v16);
      Identifier = CFBundleGetIdentifier((CFBundleRef)v16);
      __dmb(0xBu);
      if ((v14 & 1) != 0)
      {
        v24 = (__CFString *)Identifier;
        os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
        v25 = _CFBundleCopyFromTablesForURLLocked((void *)v16[2]);
        if (v25)
        {
          v26 = v25;
          os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
          CFRelease(v16);
          return v26;
        }
        v29 = _CFBundleGetFromTablesLocked(v24);
        if (!v29
          || (v30 = v29,
              v31 = (const __CFString *)*((_QWORD *)v29 + 24),
              !CFStringGetFileSystemRepresentation((CFStringRef)v16[24], buffer, 1024))
          || !CFStringGetFileSystemRepresentation(v31, v45, 1024))
        {
LABEL_60:
          if ((v42 & 1) != 0 || (*(_QWORD *)v45 = 0, _CFBundleInitPlugIn(v16, InfoDictionary, v45)))
          {
            if ((v17 & 1) == 0)
              _CFBundleAddToTablesLocked((const void **)v16, v24);
            os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
            if ((v42 & 1) == 0)
              _CFPlugInHandleDynamicRegistration((__CFBundle *)v16);
            return v16;
          }
          Value = CFDictionaryGetValue(InfoDictionary, CFSTR("CFPlugInFactories"));
          if (Value)
          {
            v38 = Value;
            v39 = CFGetTypeID(Value);
            if (v39 == CFDictionaryGetTypeID())
              v40 = v38;
            else
              v40 = 0;
          }
          else
          {
            v40 = 0;
          }
          if (_CFBundleLoadingLogger_onceToken != -1)
            dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
          v41 = _CFBundleLoadingLogger__log;
          if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buffer = 138543874;
            v47 = v40;
            v48 = 2114;
            v49 = v16;
            v50 = 2114;
            v51 = *(CFURLRef *)v45;
            _os_log_error_impl(&dword_182A8C000, v41, OS_LOG_TYPE_ERROR, "More than one bundle with the same factory UUID detected: %{public}@ in %{public}@ and %{public}@", (uint8_t *)buffer, 0x20u);
          }
          os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
          CFRelease(v16);
          v27 = *(CFURLRef *)v45;
          if (!*(_QWORD *)v45)
            return 0;
LABEL_40:
          CFRelease(v27);
          return 0;
        }
        v32 = open(buffer, 0);
        v33 = open(v45, 0);
        v34 = v33;
        if (v32 < 1 || v33 < 1)
        {
          v35 = 0;
          v36 = 0;
          if (v32 < 1)
          {
LABEL_56:
            if (v34 >= 1)
              close(v34);
            if (v36)
            {
              os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
              CFRelease(v16);
              return CFRetain(v30);
            }
            goto LABEL_60;
          }
        }
        else
        {
          memset(&v44, 0, sizeof(v44));
          memset(&v43, 0, sizeof(v43));
          v35 = !fstat(v32, &v44) && !fstat(v34, &v43) && v44.st_dev == v43.st_dev && v44.st_ino == v43.st_ino;
        }
        close(v32);
        v36 = v35;
        goto LABEL_56;
      }
      if ((v17 & 1) == 0)
        _CFBundleCreate_cold_4();
      return v16;
    default:
      v13 = 0;
      v14 = 1;
      v15 = 1;
      goto LABEL_15;
  }
}

_QWORD *_CFBundleCopyFromTablesForURLLocked(void *key)
{
  _QWORD *Value;
  _QWORD *v3;

  if (!_bundlesByURL)
    return 0;
  Value = CFDictionaryGetValue((CFDictionaryRef)_bundlesByURL, key);
  v3 = Value;
  if (Value)
  {
    if (Value[2])
    {
      CFRetain(Value);
      return v3;
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)_bundlesByURL, key);
    return 0;
  }
  return v3;
}

uint64_t _CFGetFileProperties(const __CFAllocator *a1, CFURLRef url, char *a3, _DWORD *a4, off_t *a5, CFDateRef *a6, uid_t *a7, __CFArray **a8)
{
  int v15;
  char v16;
  _BOOL4 v17;
  uint64_t result;
  off_t st_size;
  uid_t st_uid;
  __CFArray *v21;
  stat v22;
  UInt8 buffer[1026];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024))
    return 0xFFFFFFFFLL;
  if (!a3 && !a4 && !a5 && !a6 && !a7 && !a8)
    return 0;
  memset(&v22, 0, sizeof(v22));
  v15 = stat((const char *)buffer, &v22);
  if (!v15)
  {
    v17 = (v22.st_mode & 0xF000) == 0x4000;
    v16 = 1;
    if (!a3)
      goto LABEL_15;
    goto LABEL_14;
  }
  if (*__error() != 2)
    return *__error();
  v16 = 0;
  v17 = 0;
  if (a3)
LABEL_14:
    *a3 = v16;
LABEL_15:
  if (!a4)
  {
    if (!a5)
      goto LABEL_26;
    if (v15)
      goto LABEL_22;
LABEL_24:
    st_size = v22.st_size;
    goto LABEL_25;
  }
  if (!v15)
  {
    *a4 = v22.st_mode;
    if (!a5)
      goto LABEL_26;
    goto LABEL_24;
  }
  *a4 = 0;
  if (a5)
  {
LABEL_22:
    st_size = 0;
LABEL_25:
    *a5 = st_size;
  }
LABEL_26:
  if (!a6)
  {
    if (!a7)
      goto LABEL_36;
    if (v15)
      goto LABEL_32;
LABEL_34:
    st_uid = v22.st_uid;
    goto LABEL_35;
  }
  if (!v15)
  {
    *a6 = CFDateCreate(a1, (double)v22.st_mtimespec.tv_sec - 978307200.0 + (double)v22.st_mtimespec.tv_nsec * 0.000000001);
    if (!a7)
      goto LABEL_36;
    goto LABEL_34;
  }
  *a6 = 0;
  if (a7)
  {
LABEL_32:
    st_uid = -1;
LABEL_35:
    *a7 = st_uid;
  }
LABEL_36:
  if (!a8)
    return 0;
  if (v15 || !v17)
  {
    result = 0;
    *a8 = 0;
  }
  else
  {
    v21 = _CFCreateContentsOfDirectory((uint64_t)a1, (uint64_t)buffer);
    result = 0;
    *a8 = v21;
  }
  return result;
}

uint64_t _CFBundleGetBundleVersionForURL(uint64_t a1, uint64_t a2)
{
  const __CFURL *v2;
  const __CFURL *v3;
  const __CFString *v4;
  const __CFString *v5;
  int HasSuffix;
  CFIndex Length;
  CFIndex v8;
  CFIndex v9;
  CFIndex v10;
  CFIndex v11;
  const __CFURL *v12;
  const __CFURL *v13;
  _BOOL4 v14;
  int v15;
  const __CFURL *v16;
  const __CFURL *v17;
  const __CFString *v18;
  ssize_t v19;
  char *v20;
  char *v21;
  NSObject *v22;
  unsigned __int8 v23;
  NSObject *v24;
  int v25;
  char v26;
  char v27;
  NSObject *v29;
  int v30;
  int v31;
  int v32;
  _BOOL4 v33;
  _BOOL4 v34;
  NSObject *v35;
  CFStringRef string;
  _QWORD v37[6];
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  char v41;
  _QWORD v42[15];
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  char v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  char v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  char v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  char v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  char v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  char v66;
  char __s2[1024];
  char __s1[1024];
  char buffer[1026];
  char __s[1026];
  char v71[1026];
  uint64_t v72;

  v2 = (const __CFURL *)MEMORY[0x1E0C80A78](a1, a2);
  v72 = *MEMORY[0x1E0C80C00];
  v3 = CFURLCopyAbsoluteURL(v2);
  v4 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
  v5 = CFURLGetString(v2);
  HasSuffix = CFStringHasSuffix(v5, CFSTR(".framework/"));
  Length = CFStringGetLength(CFSTR("Resources"));
  v8 = CFStringGetLength(CFSTR("Contents"));
  v9 = CFStringGetLength(CFSTR("Support Files"));
  v10 = CFStringGetLength(CFSTR("WrappedBundle"));
  v11 = CFStringGetLength(CFSTR("Wrapper"));
  v63 = 0;
  v64 = &v63;
  v65 = 0x2000000000;
  v66 = 0;
  v59 = 0;
  v60 = &v59;
  v61 = 0x2000000000;
  v62 = 0;
  v55 = 0;
  v56 = &v55;
  v57 = 0x2000000000;
  v58 = 0;
  v51 = 0;
  v52 = &v51;
  v53 = 0x2000000000;
  v54 = 0;
  v47 = 0;
  v48 = &v47;
  v49 = 0x2000000000;
  v50 = 0;
  v43 = 0;
  v44 = &v43;
  v45 = 0x2000000000;
  v46 = 0;
  v42[0] = MEMORY[0x1E0C809B0];
  v42[1] = 0x40000000;
  v42[2] = ___CFBundleGetBundleVersionForURL_block_invoke;
  v42[3] = &unk_1E12E1238;
  v42[10] = Length;
  v42[11] = v8;
  v42[4] = &v63;
  v42[5] = &v59;
  v42[12] = v9;
  v42[13] = v11;
  v42[6] = &v55;
  v42[7] = &v47;
  v42[14] = v10;
  v42[8] = &v51;
  v42[9] = &v43;
  string = v4;
  _CFIterateDirectory(v4, 0, 0, (uint64_t)v42);
  if (*((_BYTE *)v44 + 24))
  {
    v71[0] = 0;
    v12 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("Wrapper"), v2);
    v13 = v12;
    if (v12)
    {
      v14 = _CFIsResourceAtURL(v12, v71);
      v15 = v71[0];
      CFRelease(v13);
      if (v14)
      {
        if (v15)
        {
          *((_BYTE *)v48 + 24) = 1;
          v16 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("WrappedBundle"), v2);
          v71[0] = 0;
          if (_CFIsResourceAtURL(v16, v71) && v71[0])
            *((_BYTE *)v52 + 24) = 1;
          CFRelease(v16);
          if (*((_BYTE *)v48 + 24) && *((_BYTE *)v52 + 24))
            *((_BYTE *)v44 + 24) = 0;
        }
      }
    }
  }
  if (!*((_BYTE *)v48 + 24) || !*((_BYTE *)v52 + 24))
  {
    if (HasSuffix)
    {
      if (*((_BYTE *)v64 + 24))
      {
LABEL_24:
        v23 = 0;
        goto LABEL_45;
      }
      if (*((_BYTE *)v60 + 24))
      {
LABEL_29:
        v23 = 2;
        goto LABEL_45;
      }
    }
    else
    {
      if (*((_BYTE *)v60 + 24))
        goto LABEL_29;
      if (*((_BYTE *)v64 + 24))
        goto LABEL_24;
    }
    if (*((_BYTE *)v56 + 24))
      v23 = 1;
    else
      v23 = 3;
    goto LABEL_45;
  }
  v17 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3, CFSTR("WrappedBundle"), 1u);
  v18 = CFURLCopyFileSystemPath(v17, kCFURLPOSIXPathStyle);
  CFRelease(v17);
  v38 = 0;
  v39 = &v38;
  v40 = 0x2000000000;
  v41 = 0;
  v37[0] = MEMORY[0x1E0C809B0];
  v37[1] = 0x40000000;
  v37[2] = ___CFBundleGetBundleVersionForURL_block_invoke_2;
  v37[3] = &unk_1E12E1260;
  v37[4] = &v38;
  v37[5] = v8;
  _CFIterateDirectory(v18, 0, 0, (uint64_t)v37);
  if (!CFStringGetFileSystemRepresentation(v18, v71, 1024)
    || !CFStringGetFileSystemRepresentation(v4, buffer, 1024))
  {
LABEL_35:
    v25 = 0;
    goto LABEL_36;
  }
  v19 = readlink(v71, __s, 0x3FFuLL);
  if (v19 < 2 || __s[0] == 47)
  {
    v24 = _CFBundleResourceLogger();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      _CFBundleGetBundleVersionForURL_cold_1();
    goto LABEL_35;
  }
  __s[v19] = 0;
  v20 = strrchr(__s, 46);
  v21 = strrchr(buffer, 46);
  if (!v21 || !v20)
  {
    if ((unint64_t)v21 | (unint64_t)v20)
    {
      v29 = _CFBundleResourceLogger();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        _CFBundleGetBundleVersionForURL_cold_4();
      goto LABEL_49;
    }
LABEL_50:
    v25 = 1;
    goto LABEL_51;
  }
  if (!strcmp(v20 + 1, v21 + 1))
    goto LABEL_50;
  v22 = _CFBundleResourceLogger();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    _CFBundleGetBundleVersionForURL_cold_3();
LABEL_49:
  v25 = 0;
LABEL_51:
  v30 = open(v71, 0);
  v31 = open(buffer, 0);
  v32 = v31;
  if (v30 < 1 || v31 < 1)
  {
    v33 = 0;
    v34 = 0;
    if (v30 < 1)
      goto LABEL_61;
  }
  else
  {
    v33 = fcntl(v30, 50, __s1) != -1
       && fcntl(v32, 50, __s2) != -1
       && strncmp(__s1, __s2, 0x400uLL)
       && strnstr(__s1, __s2, 0x400uLL) == __s1;
  }
  close(v30);
  v34 = v33;
LABEL_61:
  if (v32 >= 1)
    close(v32);
  if (v34)
  {
    v26 = 1;
    goto LABEL_37;
  }
  v35 = _CFBundleResourceLogger();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    _CFBundleGetBundleVersionForURL_cold_2();
LABEL_36:
  v26 = 0;
LABEL_37:
  CFRelease(v18);
  v27 = v26 ^ 1;
  if (!v25)
    v27 = 1;
  if ((v27 & 1) != 0)
  {
    v23 = 3;
  }
  else if (*((_BYTE *)v39 + 24))
  {
    v23 = 12;
  }
  else
  {
    v23 = 13;
  }
  _Block_object_dispose(&v38, 8);
LABEL_45:
  CFRelease(v3);
  CFRelease(string);
  _Block_object_dispose(&v43, 8);
  _Block_object_dispose(&v47, 8);
  _Block_object_dispose(&v51, 8);
  _Block_object_dispose(&v55, 8);
  _Block_object_dispose(&v59, 8);
  _Block_object_dispose(&v63, 8);
  return v23;
}

void sub_182B756D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  _Block_object_dispose(&a17, 8);
  _Block_object_dispose(&a36, 8);
  _Block_object_dispose(&a40, 8);
  _Block_object_dispose(&a44, 8);
  _Block_object_dispose(&a48, 8);
  _Block_object_dispose(&a52, 8);
  _Block_object_dispose(&a56, 8);
  _Unwind_Resume(a1);
}

__CFBundle *_CFBundleGetBundleWithIdentifier(__CFString *a1, uint64_t a2)
{
  __CFBundle *MainBundle;
  __CFBundle *v5;
  const __CFDictionary *InfoDictionary;
  const void *Value;
  const void *v8;
  CFTypeID v9;
  CFStringRef v10;
  CFStringRef v11;
  __CFBundle *v13;

  if (a1)
  {
    MainBundle = CFBundleGetMainBundle();
    if (MainBundle)
    {
      v5 = MainBundle;
      InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
      if (InfoDictionary)
      {
        Value = CFDictionaryGetValue(InfoDictionary, CFSTR("CFBundleIdentifier"));
        if (Value)
        {
          v8 = Value;
          v9 = CFGetTypeID(Value);
          if (v9 == CFStringGetTypeID())
          {
            if (CFEqual(v8, a1))
              return v5;
          }
        }
      }
    }
    os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    v5 = _CFBundleGetFromTablesLocked(a1);
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    if (a2 && !v5)
    {
      v10 = _CFBundleCopyLoadedImagePathForPointer();
      if (v10)
      {
        v11 = v10;
        _CFBundleEnsureBundleExistsForImagePath((uint64_t)v10, 0);
        CFRelease(v11);
      }
      os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      v5 = _CFBundleGetFromTablesLocked(a1);
      os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    }
    if (v5)
      return v5;
    _CFBundleEnsureBundlesUpToDateWithHint(a1);
    os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    v5 = _CFBundleGetFromTablesLocked(a1);
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    if (v5)
      return v5;
  }
  _CFBundleEnsureAllBundlesUpToDate();
  os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  v13 = _CFBundleGetFromTablesLocked(a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  return v13;
}

__CFBundle *_CFBundleGetFromTablesLocked(void *key)
{
  __CFBundle *ValueAtIndex;
  const __CFArray *Value;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  BOOL v7;
  int v8;

  ValueAtIndex = 0;
  if (key && _bundlesByIdentifier)
  {
    Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_bundlesByIdentifier, key);
    if (Value && (v3 = Value, Count = CFArrayGetCount(Value), Count >= 1))
    {
      v5 = Count;
      v6 = 0;
      do
      {
        ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v3, v6++);
        if (CFBundleIsExecutableLoaded(ValueAtIndex))
          v7 = ValueAtIndex == 0;
        else
          v7 = 1;
        v8 = v7;
      }
      while (v8 == 1 && v6 < v5);
      if (v8)
        return (__CFBundle *)CFArrayGetValueAtIndex(v3, 0);
    }
    else
    {
      return 0;
    }
  }
  return ValueAtIndex;
}

Boolean CFBundleIsExecutableLoaded(CFBundleRef bundle)
{
  unint64_t v2;
  os_unfair_lock_s *v3;
  Boolean v4;

  v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  v3 = (os_unfair_lock_s *)((char *)bundle + 96);
  os_unfair_lock_lock_with_options();
  v4 = *((_BYTE *)bundle + 52);
  os_unfair_lock_unlock(v3);
  return v4;
}

void _CFBundleAddToTablesLocked(const void **value, const void *a2)
{
  __CFArray *v4;
  __CFDictionary *Mutable;
  const __CFDictionary *v6;
  const __CFArray *v7;
  const __CFArray *v8;
  CFIndex Count;
  UInt32 VersionNumber;
  UInt32 v11;
  CFIndex v12;
  __CFBundle *ValueAtIndex;
  __CFArray *v14;
  __CFArray *v15;
  __CFArray *v16;
  CFIndex v17;
  _QWORD *v18;
  CFStringRef v19;
  CFArrayCallBacks callBacks;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)value + 54))
  {
    v4 = (__CFArray *)_allBundles;
    if (!_allBundles)
    {
      *(_OWORD *)&callBacks.version = *(_OWORD *)&kCFTypeArrayCallBacks.version;
      *(_OWORD *)&callBacks.release = *(_OWORD *)&kCFTypeArrayCallBacks.release;
      callBacks.equal = CFEqual;
      v4 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &callBacks);
      _allBundles = (uint64_t)v4;
    }
    CFArrayAppendValue(v4, value);
    Mutable = (__CFDictionary *)_bundlesByURL;
    if (!_bundlesByURL)
    {
      memset(&callBacks, 0, 24);
      callBacks.copyDescription = kCFTypeDictionaryValueCallBacks.copyDescription;
      callBacks.equal = CFEqual;
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, (const CFDictionaryValueCallBacks *)&callBacks);
      _bundlesByURL = (uint64_t)Mutable;
    }
    CFDictionarySetValue(Mutable, value[2], value);
    if (a2)
    {
      v6 = (const __CFDictionary *)_bundlesByIdentifier;
      if (!_bundlesByIdentifier)
      {
        v6 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        _bundlesByIdentifier = (uint64_t)v6;
      }
      v7 = (const __CFArray *)CFDictionaryGetValue(v6, a2);
      if (!v7)
      {
        memset(&callBacks, 0, 24);
        callBacks.copyDescription = kCFTypeArrayCallBacks.copyDescription;
        callBacks.equal = CFEqual;
        v14 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &callBacks);
        CFArrayAppendValue(v14, value);
        CFDictionarySetValue((CFMutableDictionaryRef)_bundlesByIdentifier, a2, v14);
        v15 = v14;
LABEL_28:
        CFRelease(v15);
        return;
      }
      v8 = v7;
      Count = CFArrayGetCount(v7);
      VersionNumber = CFBundleGetVersionNumber((CFBundleRef)value);
      if (Count < 1)
      {
        v12 = 0;
      }
      else
      {
        v11 = VersionNumber;
        v12 = 0;
        while (1)
        {
          ValueAtIndex = (__CFBundle *)CFArrayGetValueAtIndex(v8, v12);
          if (v11 >= CFBundleGetVersionNumber(ValueAtIndex))
            break;
          if (Count == ++v12)
          {
            v12 = Count;
            break;
          }
        }
      }
      CFArrayInsertValueAtIndex(v8, v12, value);
      if (_CFBundleResourceLogger_onceToken != -1)
        dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
      if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_DEBUG))
      {
        v16 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
        if (CFArrayGetCount(v8) >= 1)
        {
          v17 = 0;
          do
          {
            v18 = CFArrayGetValueAtIndex(v8, v17);
            v19 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("Bundle %p at %@"), v18, v18[2]);
            CFArrayAppendValue(v16, v19);
            CFRelease(v19);
            ++v17;
          }
          while (v17 < CFArrayGetCount(v8));
        }
        if (_CFBundleResourceLogger_onceToken != -1)
          dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
        if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_DEBUG))
          _CFBundleAddToTablesLocked_cold_1();
        v15 = v16;
        goto LABEL_28;
      }
    }
  }
}

uint64_t _CFPlugInHandleDynamicRegistration(__CFBundle *a1)
{
  uint64_t result;
  uint64_t v3;
  const __CFDictionary *InfoDictionary;
  const __CFString *Value;
  const __CFString *v6;
  CFTypeID v7;
  uint64_t (*FunctionPointerForName)(uint64_t);

  result = __CFBundleGetPlugInData((uint64_t)a1);
  if (*(_BYTE *)result)
  {
    v3 = result;
    result = CFBundleIsExecutableLoaded(a1);
    if ((_DWORD)result)
    {
      if (*(_BYTE *)(v3 + 3))
      {
        os_unfair_recursive_lock_lock_with_options();
        if (!*(_BYTE *)(v3 + 2))
        {
          *(_BYTE *)(v3 + 3) = 0;
          InfoDictionary = CFBundleGetInfoDictionary(a1);
          Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, CFSTR("CFPlugInDynamicRegisterFunction"));
          if (!Value || (v6 = Value, v7 = CFGetTypeID(Value), v7 != CFStringGetTypeID()) || CFStringGetLength(v6) <= 0)
            v6 = CFSTR("CFPlugInDynamicRegister");
          *(_WORD *)(v3 + 1) = 256;
          FunctionPointerForName = (uint64_t (*)(uint64_t))CFBundleGetFunctionPointerForName(a1, v6);
          if (FunctionPointerForName)
            __CFPLUGIN_IS_CALLING_OUT_TO_A_DYNAMIC_REGISTRATION_FUNCTION__(FunctionPointerForName, (uint64_t)a1);
          *(_BYTE *)(v3 + 2) = 0;
          if (*(_BYTE *)(v3 + 1))
          {
            if (!*(_DWORD *)(v3 + 8))
              CFBundleUnloadExecutable(a1);
          }
        }
        return os_unfair_recursive_lock_unlock();
      }
    }
  }
  return result;
}

uint64_t __CFBundleGetPlugInData(uint64_t a1)
{
  return a1 + 72;
}

uint64_t _CFBundleInitPlugIn(void *a1, CFDictionaryRef theDict, _QWORD *a3)
{
  const __CFDictionary *Value;
  const __CFDictionary *v7;
  CFTypeID v8;
  const __CFString *v9;
  const __CFString *v10;
  CFTypeID v11;
  const __CFAllocator *v13;
  CFMutableArrayRef v14;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  CFTypeID v17;
  uint64_t v18;
  char context;
  CFArrayCallBacks callBacks;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  memset(&callBacks, 0, sizeof(callBacks));
  if (!theDict)
    return 1;
  Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("CFPlugInFactories"));
  v7 = Value;
  if (Value)
  {
    v8 = CFGetTypeID(Value);
    if (v8 != CFDictionaryGetTypeID())
      v7 = 0;
  }
  v9 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("CFPlugInDynamicRegistration"));
  v10 = v9;
  if (v9)
  {
    v11 = CFGetTypeID(v9);
    if (v11 != CFStringGetTypeID())
    {
      LODWORD(v10) = 0;
      if (v7)
        goto LABEL_12;
      goto LABEL_11;
    }
    LODWORD(v10) = CFStringCompare(v10, CFSTR("YES"), 1uLL) == kCFCompareEqualTo;
  }
  if (v7)
    goto LABEL_12;
LABEL_11:
  if (!(_DWORD)v10)
    return 1;
LABEL_12:
  context = 0;
  if (v7)
  {
    CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)_searchForDummyUUID, &context);
    if (context)
    {
      if (_CFBundlePluginLogger_onceToken != -1)
        dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
      if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
        _CFBundleInitPlugIn_cold_1();
      return 1;
    }
  }
  os_unfair_recursive_lock_lock_with_options();
  if (*(_BYTE *)(__CFBundleGetPlugInData((uint64_t)a1) + 4))
    goto LABEL_19;
  if (!dyld_program_sdk_at_least()
    || (v18 = 0, !v7)
    || (CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)_searchForExistingFactoryLocked, &v18), !v18))
  {
    *(_BYTE *)__CFBundleGetPlugInData((uint64_t)a1) = 1;
    *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)a1) + 1) = 1;
    *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)a1) + 2) = 0;
    *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)a1) + 3) = (_BYTE)v10;
    *(_DWORD *)(__CFBundleGetPlugInData((uint64_t)a1) + 8) = 0;
    *(_DWORD *)(__CFBundleGetPlugInData((uint64_t)a1) + 12) = 0;
    *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)a1) + 4) = 1;
    v13 = CFGetAllocator(a1);
    v14 = CFArrayCreateMutable(v13, 0, &callBacks);
    *(_QWORD *)(__CFBundleGetPlugInData((uint64_t)a1) + 16) = v14;
    if (v7)
      CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)_registerFactoryLocked, a1);
    v15 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("CFPlugInTypes"));
    if (v15)
    {
      v16 = v15;
      v17 = CFGetTypeID(v15);
      if (v17 == CFDictionaryGetTypeID())
        CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)_registerTypeLocked, a1);
    }
LABEL_19:
    os_unfair_recursive_lock_unlock();
    return 1;
  }
  if (a3)
    *a3 = v18;
  os_unfair_recursive_lock_unlock();
  return 0;
}

const __CFURL *__CFBundleCopyFrameworkURLForExecutablePath(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  const __CFString *v5;
  CFMutableStringRef MutableWithExternalCharactersNoCopy;
  CFIndex Length;
  CFIndex v8;
  uint64_t v9;
  uint64_t PathComponent;
  const __CFString *v11;
  uint64_t v12;
  uint64_t v13;
  __CFString *v14;
  CFIndex v15;
  const __CFURL *v16;
  char v18[2052];
  UniChar buffer[1026];
  uint64_t v20;
  CFRange v21;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v4 = v3;
  v5 = (const __CFString *)v2;
  v20 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x804uLL);
  bzero(v18, 0x804uLL);
  MutableWithExternalCharactersNoCopy = CFStringCreateMutableWithExternalCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, 0);
  Length = CFStringGetLength(v5);
  if (Length >= 1026)
    v8 = 1026;
  else
    v8 = Length;
  v21.location = 0;
  v21.length = v8;
  CFStringGetCharacters(v5, v21, buffer);
  v9 = _CFLengthAfterDeletingPathExtension(buffer, v8);
  _CFStartOfLastPathComponent(buffer, v9);
  __memmove_chk();
  PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, v9);
  if (v4)
    v11 = &stru_1E1337B18;
  else
    v11 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v18);
  if (PathComponent >= 1)
  {
    do
    {
      v12 = _CFStartOfLastPathComponent(buffer, PathComponent);
      if (PathComponent <= v12)
        break;
      CFStringSetExternalCharactersNoCopy(MutableWithExternalCharactersNoCopy, &buffer[v12], PathComponent - v12, 1026 - v12);
      if (!v4 && CFEqual(MutableWithExternalCharactersNoCopy, CFSTR("Resources")))
      {
        v16 = 0;
        goto LABEL_26;
      }
      if (CFEqual(MutableWithExternalCharactersNoCopy, CFSTR("Support Files"))
        || CFEqual(MutableWithExternalCharactersNoCopy, CFSTR("Contents")))
      {
        if (v4
          || (v13 = _CFStartOfLastPathComponent(buffer, PathComponent),
              CFStringSetExternalCharactersNoCopy(MutableWithExternalCharactersNoCopy, &buffer[v13], PathComponent - v13, 1026 - v13), CFStringHasPrefix(MutableWithExternalCharactersNoCopy, v11)))
        {
          v15 = _CFLengthAfterDeletingLastPathComponent(buffer, PathComponent);
          v14 = MutableWithExternalCharactersNoCopy;
          goto LABEL_22;
        }
      }
      else if (CFStringHasSuffix(MutableWithExternalCharactersNoCopy, CFSTR(".framework"))
             && (v4 || CFStringHasPrefix(MutableWithExternalCharactersNoCopy, v11)))
      {
        v14 = MutableWithExternalCharactersNoCopy;
        v15 = PathComponent;
LABEL_22:
        CFStringSetExternalCharactersNoCopy(v14, buffer, v15, 1026);
        v16 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableWithExternalCharactersNoCopy, kCFURLPOSIXPathStyle, 1u);
        if (_CFBundleCouldBeBundle(v16))
          goto LABEL_25;
        CFRelease(v16);
        break;
      }
      PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, PathComponent);
    }
    while (PathComponent > 0);
  }
  v16 = 0;
LABEL_25:
  if (!v4)
LABEL_26:
    CFRelease(v11);
  CFStringSetExternalCharactersNoCopy(MutableWithExternalCharactersNoCopy, 0, 0, 0);
  CFRelease(MutableWithExternalCharactersNoCopy);
  return v16;
}

CFURLRef _CFBundleCopyBundleURLForExecutableURL(const __CFURL *a1)
{
  const __CFURL *v1;
  const __CFString *v2;
  const __CFString *v3;
  CFIndex Length;
  CFIndex v5;
  uint64_t PathComponent;
  uint64_t v7;
  uint64_t v8;
  CFStringRef v10;
  const __CFString *PlatformExecutablesSubdirectoryName;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFStringRef v15;
  CFURLRef v16;
  UniChar buffer[1026];
  uint64_t v19;
  CFRange v20;

  v19 = *MEMORY[0x1E0C80C00];
  v1 = _CFBundleCopyResolvedURLForExecutableURL(a1);
  v2 = CFURLCopyFileSystemPath(v1, kCFURLPOSIXPathStyle);
  if (v2)
  {
    v3 = v2;
    Length = CFStringGetLength(v2);
    if (Length >= 1026)
      v5 = 1026;
    else
      v5 = Length;
    v20.location = 0;
    v20.length = v5;
    CFStringGetCharacters(v3, v20, buffer);
    PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, v5);
    if (PathComponent >= 1)
    {
      v7 = PathComponent;
      v8 = _CFStartOfLastPathComponent(buffer, PathComponent);
      if (v8 < 1 || v7 <= v8)
        goto LABEL_21;
      v10 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, &buffer[v8], v7 - v8);
      PlatformExecutablesSubdirectoryName = _CFBundleGetPlatformExecutablesSubdirectoryName();
      if (!CFEqual(v10, PlatformExecutablesSubdirectoryName))
      {
        CFRelease(v10);
        goto LABEL_21;
      }
      v12 = _CFLengthAfterDeletingLastPathComponent(buffer, v7);
      if (v12 < 1)
      {
LABEL_16:
        v16 = 0;
LABEL_22:
        CFRelease(v10);
LABEL_24:
        CFRelease(v3);
        goto LABEL_25;
      }
      v13 = v12;
      v14 = _CFStartOfLastPathComponent(buffer, v12);
      if (v14 >= 1 && v13 > v14)
      {
        v15 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, &buffer[v14], v13 - v14);
        if (CFEqual(v15, CFSTR("Executables")))
        {
          v13 = _CFLengthAfterDeletingLastPathComponent(buffer, v13);
          CFRelease(v15);
          if (v13 < 1)
            goto LABEL_16;
        }
        else
        {
          CFRelease(v15);
        }
      }
      v7 = _CFLengthAfterDeletingLastPathComponent(buffer, v13);
      CFRelease(v10);
      if (v7 >= 1)
      {
LABEL_21:
        v10 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, v7, (CFAllocatorRef)&__kCFAllocatorNull);
        v16 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10, kCFURLPOSIXPathStyle, 1u);
        goto LABEL_22;
      }
    }
    v16 = 0;
    goto LABEL_24;
  }
  v16 = 0;
LABEL_25:
  CFRelease(v1);
  return v16;
}

uint64_t _CFStartOfLastPathComponent(_WORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;

  if (a2 < 2)
    return 0;
  v2 = a2;
  do
  {
    v3 = v2 - 1;
    if (v2 == 1)
      break;
    v4 = (unsigned __int16)a1[v2-- - 2];
  }
  while (v4 != 47);
  if (a2 >= 3 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A)
    return 2;
  else
    return 0;
}

CFURLRef _CFBundleCopyResolvedURLForExecutableURL(const __CFURL *a1)
{
  const __CFURL *v1;
  const __CFString *v2;
  const __CFString *v3;
  CFIndex Length;
  CFIndex v5;
  CFIndex PathComponent;
  CFIndex v8;
  const __CFString *v9;
  CFStringRef v10;
  const __CFString *v11;
  BOOL v12;
  CFURLRef v13;
  const __CFURL *v15;
  const __CFURL *v16;
  const __CFURL *v17;
  const __CFURL *v18;
  UniChar buffer[1026];
  uint64_t v20;
  CFRange v21;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = CFURLCopyAbsoluteURL(a1);
  v2 = CFURLCopyFileSystemPath(v1, kCFURLPOSIXPathStyle);
  if (!v2)
    return v1;
  v3 = v2;
  Length = CFStringGetLength(v2);
  if (Length >= 1026)
    v5 = 1026;
  else
    v5 = Length;
  v21.location = 0;
  v21.length = v5;
  CFStringGetCharacters(v3, v21, buffer);
  PathComponent = _CFLengthAfterDeletingLastPathComponent(buffer, v5);
  if (PathComponent < 1 || PathComponent + 1 >= v5)
  {
    CFRelease(v3);
    return v1;
  }
  v8 = PathComponent;
  v9 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, PathComponent);
  v10 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, &buffer[v8 + 1], v5 + ~v8);
  v11 = v10;
  if (v9)
    v12 = v10 == 0;
  else
    v12 = 1;
  if (v12)
  {
    v13 = 0;
    if (!v9)
    {
      if (!v10)
        goto LABEL_18;
      goto LABEL_17;
    }
  }
  else
  {
    v15 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, kCFURLPOSIXPathStyle, 1u);
    if (v15)
    {
      v16 = v15;
      v17 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v11, kCFURLPOSIXPathStyle, 0, v15);
      if (v17)
      {
        v18 = v17;
        v13 = CFURLCopyAbsoluteURL(v17);
        CFRelease(v18);
      }
      else
      {
        v13 = 0;
      }
      CFRelease(v16);
    }
    else
    {
      v13 = 0;
    }
  }
  CFRelease(v9);
  if (v11)
LABEL_17:
    CFRelease(v11);
LABEL_18:
  CFRelease(v3);
  if (v13)
  {
    CFRelease(v1);
    return v13;
  }
  return v1;
}

uint64_t _CFLengthAfterDeletingLastPathComponent(unsigned __int16 *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t result;
  unsigned int v7;

  if (a2 >= 2)
  {
    v3 = a2;
    while (1)
    {
      v4 = v3 - 1;
      if (v3 == 1)
        break;
      v5 = a1[v3-- - 2];
      if (v5 == 47)
      {
        result = v4 - 1;
        if (v4 == 1)
          return v4;
        if (a1[1] == 58)
        {
          v7 = *a1;
          if (v7 - 65 >= 0x1A)
          {
            if (v7 >= 0x61 && v4 == 3 && v7 <= 0x7A)
              return v4;
          }
          else if (v4 == 3)
          {
            return v4;
          }
        }
        return result;
      }
    }
    if (a2 >= 3 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A)
      return 2;
  }
  return 0;
}

const __CFString *_CFBundleGetPlatformExecutablesSubdirectoryName()
{
  return CFSTR("MacOS");
}

BOOL _CFBundleCouldBeBundle(CFURLRef url)
{
  int v1;
  _BOOL8 result;
  int v3;
  char v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v4 = 0;
  v3 = 0;
  v1 = _CFGetFileProperties((const __CFAllocator *)&__kCFAllocatorSystemDefault, url, &v4, &v3, 0, 0, 0, 0);
  result = 0;
  if (!v1)
  {
    if (v4)
      return (v3 & 0xF000) == 0x4000 && (v3 & 0x124) != 0;
    else
      return 0;
  }
  return result;
}

uint64_t _CFLengthAfterDeletingPathExtension(_WORD *a1, uint64_t a2)
{
  uint64_t result;

  result = _CFStartOfPathExtension(a1, a2);
  if (!result)
    return a2;
  return result;
}

uint64_t _CFStartOfPathExtension(_WORD *a1, uint64_t a2)
{
  unsigned __int16 *v3;
  int v4;

  if (a2 < 2)
    return 0;
  v3 = &a1[a2 - 1];
  while (--a2)
  {
    if (*(v3 - 1) == 47)
      return 0;
    v4 = *v3--;
    if (v4 == 46)
    {
      if (a2 == 2 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A)
        return 0;
      return a2;
    }
  }
  return a2;
}

CFStringRef _CFBundleCopyLoadedImagePathForPointer()
{
  const char *v0;
  const char *v1;
  CFStringRef v2;
  NSObject *v3;

  v0 = (const char *)dyld_image_path_containing_address();
  v1 = _CFBundleNormalizedPath(v0);
  if (v1)
    v2 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1);
  else
    v2 = 0;
  v3 = _CFBundleLoadingLogger();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    _CFBundleCopyLoadedImagePathForPointer_cold_1();
  return v2;
}

uint64_t _CFBundleLoadExecutableAndReturnError(uint64_t a1, int a2, _QWORD *a3)
{
  unint64_t v6;
  CFTypeRef *v7;
  const __CFURL *v8;
  int32x4_t v9;
  int v10;
  uint64_t v11;
  int v13;
  uint64_t Bundle;
  const __CFAllocator *v15;
  __CFBundle *v16;
  CFIndex v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v6 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v6 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v6);
  v18[0] = 0;
  if (a3)
    v7 = (CFTypeRef *)v18;
  else
    v7 = 0;
  v8 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (!v8)
    *(_DWORD *)(a1 + 48) = 7;
  _CFBundleDlfcnCheckLoaded(a1);
  if (!*(_DWORD *)(a1 + 48))
  {
    v13 = _CFBundleGrokBinaryType(v8, v9);
    *(_DWORD *)(a1 + 48) = v13;
    if (v13 != 1 && v13 != 6)
      *(_BYTE *)(a1 + 64) = 1;
  }
  if (v8)
    CFRelease(v8);
  v10 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  if (!v10)
  {
    switch(*(_DWORD *)(a1 + 48))
    {
      case 0:
      case 3:
      case 6:
      case 8:
        Bundle = _CFBundleDlfcnLoadBundle(a1, a2, v7);
        goto LABEL_29;
      case 2:
        if (_CFBundleLoadingLogger_onceToken != -1)
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        if (!os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
          goto LABEL_26;
        _CFBundleLoadExecutableAndReturnError_cold_2();
        if (!a3)
          return 0;
        goto LABEL_27;
      case 4:
        Bundle = _CFBundleDlfcnLoadFramework(a1, v7);
LABEL_29:
        v11 = Bundle;
        if ((_DWORD)Bundle)
        {
          if (*(_BYTE *)(a1 + 72))
            _CFPlugInHandleDynamicRegistration(a1);
          return v11;
        }
        if (a3)
          goto LABEL_40;
        return 0;
      case 7:
        if (_CFBundleLoadingLogger_onceToken != -1)
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
        {
          _CFBundleLoadExecutableAndReturnError_cold_3();
          if (!a3)
            return 0;
        }
        else if (!a3)
        {
          return 0;
        }
        v15 = CFGetAllocator((CFTypeRef)a1);
        v16 = (__CFBundle *)a1;
        v17 = 4;
        goto LABEL_39;
      default:
        if (_CFBundleLoadingLogger_onceToken != -1)
          dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
        if (os_log_type_enabled((os_log_t)_CFBundleLoadingLogger__log, OS_LOG_TYPE_ERROR))
        {
          _CFBundleLoadExecutableAndReturnError_cold_1();
          if (!a3)
            return 0;
        }
        else
        {
LABEL_26:
          if (!a3)
            return 0;
        }
LABEL_27:
        v15 = CFGetAllocator((CFTypeRef)a1);
        v16 = (__CFBundle *)a1;
        v17 = 3584;
LABEL_39:
        v18[0] = _CFBundleCreateErrorDebug(v15, v16, v17, 0);
LABEL_40:
        v11 = 0;
        *a3 = v18[0];
        return v11;
    }
  }
  _CFPlugInUnscheduleForUnloading((const void *)a1);
  return 1;
}

uint64_t _CFBundleDlfcnCheckLoaded(uint64_t a1)
{
  uint64_t result;
  const __CFURL *v3;
  const __CFURL *v4;
  void *v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  UInt8 *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  UInt8 buffer[1026];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_assert_owner((const os_unfair_lock *)(a1 + 96));
  result = *(unsigned __int8 *)(a1 + 52);
  if (!*(_BYTE *)(a1 + 52))
  {
    v3 = CFBundleCopyExecutableURL((CFBundleRef)a1);
    if (v3)
    {
      v4 = v3;
      if (CFURLGetFileSystemRepresentation(v3, 1u, buffer, 1026))
      {
        v5 = dlopen((const char *)buffer, 277);
        if (v5)
        {
          if (!*(_QWORD *)(a1 + 56))
          {
            *(_QWORD *)(a1 + 56) = v5;
            v6 = _CFBundleLoadingLogger();
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
            {
              v8 = *(_QWORD *)(a1 + 56);
              v9 = 138544130;
              v10 = a1;
              v11 = 2082;
              v12 = buffer;
              v13 = 1024;
              v14 = 277;
              v15 = 2048;
              v16 = v8;
              _os_log_debug_impl(&dword_182A8C000, v6, OS_LOG_TYPE_DEBUG, "dlfcn check load bundle %{public}@, dlopen of %{public}s mode 0x%x getting handle %p", (uint8_t *)&v9, 0x26u);
            }
          }
          *(_BYTE *)(a1 + 52) = 1;
        }
        else
        {
          v7 = _CFBundleLoadingLogger();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
            _CFBundleDlfcnCheckLoaded_cold_1();
        }
      }
      CFRelease(v4);
    }
    return *(unsigned __int8 *)(a1 + 52);
  }
  return result;
}

CFURLRef _CFBundleCopyExecutableURLInDirectory2(CFBundleRef bundle, CFURLRef url, const __CFString *a3, int a4)
{
  const __CFDictionary *InfoDictionary;
  const __CFString *v9;
  CFURLRef v10;
  int v11;
  const __CFString *v12;
  const __CFString *v13;
  char *v14;
  CFStringRef v15;
  CFStringRef v16;
  const __CFString *v17;
  const __CFURL *v18;
  const __CFURL *v19;
  const __CFURL *v20;
  CFStringRef v21;
  char v23;
  uint64_t v24;
  CFRange v25;

  v24 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  if (bundle)
  {
    InfoDictionary = CFBundleGetInfoDictionary(bundle);
    v23 = *((_BYTE *)bundle + 53);
    if (!a3 && !a4)
    {
      os_unfair_lock_lock_with_options();
      v9 = (const __CFString *)*((_QWORD *)bundle + 13);
      if (v9)
      {
        CFRetain(*((CFTypeRef *)bundle + 13));
        os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
        v10 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, kCFURLPOSIXPathStyle, 0);
        CFRelease(v9);
        if (v10)
          return v10;
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
      }
      v11 = 1;
LABEL_13:
      v13 = _CFBundleCopyExecutableName(bundle, url, InfoDictionary);
      if (!v13)
      {
        v10 = 0;
        goto LABEL_36;
      }
      v12 = v13;
      if (!url)
        goto LABEL_31;
      goto LABEL_15;
    }
  }
  else
  {
    InfoDictionary = _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, url, &v23);
  }
  v11 = 0;
  v12 = a3;
  if (!a3)
    goto LABEL_13;
  if (!url)
    goto LABEL_31;
LABEL_15:
  v14 = __CFgetenvIfNotRestricted("DYLD_IMAGE_SUFFIX");
  if (v14)
  {
    v15 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14, 0x8000100u);
    if (CFStringHasSuffix(v12, CFSTR(".dylib")))
    {
      v25.length = CFStringGetLength(v12) - 6;
      v25.location = 0;
      v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v25);
      v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@%@.dylib"), v12, v15);
      CFRelease(v16);
    }
    else
    {
      v17 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@%@"), v12, v15);
    }
    v18 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17, kCFURLPOSIXPathStyle, 0, url);
    v10 = v18;
    if (v18 && !_binaryLoadable(v18))
    {
      CFRelease(v10);
      v10 = 0;
    }
    CFRelease(v17);
    CFRelease(v15);
    if (v10)
      goto LABEL_26;
  }
  v19 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, kCFURLPOSIXPathStyle, 0, url);
  if (!v19)
  {
LABEL_31:
    v10 = 0;
    if (bundle && !a3)
    {
      v10 = 0;
      *((_DWORD *)bundle + 12) = 7;
LABEL_35:
      CFRelease(v12);
      goto LABEL_36;
    }
    goto LABEL_34;
  }
  v10 = v19;
  if (!_binaryLoadable(v19))
  {
    CFRelease(v10);
    goto LABEL_31;
  }
LABEL_26:
  if (v11)
  {
    v20 = CFURLCopyAbsoluteURL(v10);
    v21 = CFURLCopyFileSystemPath(v20, kCFURLPOSIXPathStyle);
    CFRelease(v20);
    os_unfair_lock_lock_with_options();
    if (!*((_QWORD *)bundle + 13))
      *((_QWORD *)bundle + 13) = CFRetain(v21);
    os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
    CFRelease(v21);
  }
LABEL_34:
  if (!a3)
    goto LABEL_35;
LABEL_36:
  if (!bundle && InfoDictionary)
    CFRelease(InfoDictionary);
  return v10;
}

const UInt8 *_CFCopyHomeDirURLForUser(const char *a1, int a2)
{
  char *v4;
  size_t v5;
  const UInt8 *pw_dir;
  int has_internal_diagnostics;
  __CFString *v8;
  passwd *v9;
  uid_t v10;
  size_t v11;
  int v12;
  __CFString *v13;
  uint64_t v14;
  const __CFString *v15;
  char *v16;
  const UInt8 *v17;
  size_t v18;
  int v19;
  __CFString *v20;
  const void *v21;
  NSObject *v22;
  uid_t v24;
  _QWORD v25[2];
  void (*v26)(uint64_t);
  void *v27;
  uint64_t *v28;
  uint64_t v29;
  _QWORD v30[4];

  v30[3] = *MEMORY[0x1E0C80C00];
  if (issetugid())
    v4 = 0;
  else
    v4 = __CFgetenv("CFFIXED_USER_HOME");
  v29 = 0;
  v30[0] = &v29;
  v30[1] = 0x2000000000;
  v30[2] = 0;
  v25[0] = MEMORY[0x1E0C809B0];
  v25[1] = 0x40000000;
  v26 = ___CFCopyHomeDirURLForUser_block_invoke;
  v27 = &unk_1E12E5DB0;
  v28 = &v29;
  if (!issetugid() && v4)
  {
    v5 = strlen(v4);
    pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v4, v5, 1u);
    if (pw_dir)
      goto LABEL_35;
    v26((uint64_t)v25);
    has_internal_diagnostics = os_variant_has_internal_diagnostics();
    v8 = *(__CFString **)(v30[0] + 24);
    if (has_internal_diagnostics)
      CFStringAppendFormat(v8, 0, CFSTR("CFURLCreateFromFileSystemRepresentation failed to create URL for CFFIXED_USER_HOME value: %s"), v4);
    else
      CFStringAppend(v8, CFSTR("CFURLCreateFromFileSystemRepresentation failed to create URL for CFFIXED_USER_HOME value"));
  }
  if (a1)
  {
    *__error() = 0;
    v9 = getpwnam(a1);
    if (!v9)
      goto LABEL_26;
  }
  else
  {
    v24 = 0;
    __CFGetUGIDs(&v24, 0);
    *__error() = 0;
    v10 = v24;
    if (!v24)
      v10 = getuid();
    v9 = getpwuid(v10);
    if (!v9)
    {
      v14 = *__error();
      v26((uint64_t)v25);
      CFStringAppendFormat(*(CFMutableStringRef *)(v30[0] + 24), 0, CFSTR("getpwuid failed with code: %d"), v14);
      pw_dir = 0;
      goto LABEL_27;
    }
  }
  pw_dir = (const UInt8 *)v9->pw_dir;
  if (pw_dir)
  {
    v11 = strlen(v9->pw_dir);
    pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, pw_dir, v11, 1u);
  }
  if (!((unint64_t)a1 | (unint64_t)pw_dir))
  {
    v26((uint64_t)v25);
    if (v9->pw_dir)
    {
      v12 = os_variant_has_internal_diagnostics();
      v13 = *(__CFString **)(v30[0] + 24);
      if (v12)
      {
        CFStringAppendFormat(v13, 0, CFSTR("CFURLCreateFromFileSystemRepresentation failed to create URL for upwd->pw_dir value: %s"), v9->pw_dir);
        pw_dir = 0;
        goto LABEL_27;
      }
      v15 = CFSTR("CFURLCreateFromFileSystemRepresentation failed to create URL for upwd->pw_dir value");
    }
    else
    {
      v13 = *(__CFString **)(v30[0] + 24);
      v15 = CFSTR("upwd->pw_dir is NULL");
    }
    CFStringAppend(v13, v15);
LABEL_26:
    pw_dir = 0;
  }
LABEL_27:
  if (!pw_dir && a2)
  {
    v16 = __CFgetenv("HOME");
    v17 = (const UInt8 *)v16;
    if (v16)
    {
      v18 = strlen(v16);
      pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17, v18, 1u);
      if (pw_dir)
        goto LABEL_35;
      v26((uint64_t)v25);
      v19 = os_variant_has_internal_diagnostics();
      v20 = *(__CFString **)(v30[0] + 24);
      if (v19)
      {
        CFStringAppendFormat(v20, 0, CFSTR("CFURLCreateFromFileSystemRepresentation failed to create URL for HOME value: %s"), v17);
        pw_dir = 0;
        goto LABEL_35;
      }
      CFStringAppend(v20, CFSTR("CFURLCreateFromFileSystemRepresentation failed to create URL for HOME value"));
    }
    pw_dir = 0;
  }
LABEL_35:
  v21 = *(const void **)(v30[0] + 24);
  if (v21)
  {
    if (!pw_dir)
    {
      v22 = _CFOSLog();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        _CFCopyHomeDirURLForUser_cold_1((uint64_t)v30, v22);
      pw_dir = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)"/var/empty", 10, 1u);
      v21 = *(const void **)(v30[0] + 24);
    }
    CFRelease(v21);
  }
  _Block_object_dispose(&v29, 8);
  return pw_dir;
}

void sub_182B77564(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  _Unwind_Resume(exception_object);
}

char *__CFgetenv(char *__s1)
{
  uint64_t v2;
  const char *v3;

  v2 = 0;
  while (1)
  {
    v3 = (&__CFEnv)[v2];
    if (v3)
    {
      if (!strcmp(__s1, v3))
        break;
    }
    v2 += 2;
    if (v2 == 22)
      return getenv(__s1);
  }
  return (&__CFEnv)[v2 + 1];
}

CFURLRef CFBundleCopyExecutableURL(CFBundleRef bundle)
{
  return _CFBundleCopyExecutableURLInDirectory2(bundle, *((CFURLRef *)bundle + 2), 0, 0);
}

uint64_t _CFBundleLoadingLogger()
{
  if (_CFBundleLoadingLogger_onceToken != -1)
    dispatch_once(&_CFBundleLoadingLogger_onceToken, &__block_literal_global_98);
  return _CFBundleLoadingLogger__log;
}

const __CFString *_CFBundleCopyExecutableName(CFBundleRef bundle, CFURLRef relativeURL, CFDictionaryRef theDict)
{
  const __CFDictionary *InfoDictionary;
  const __CFString *Value;
  CFTypeID v7;
  const __CFURL *v8;
  const __CFString *v9;
  CFIndex Length;
  CFIndex PathComponent2;
  uint64_t v12;
  CFRange v14;

  InfoDictionary = theDict;
  if (bundle && !theDict)
    InfoDictionary = CFBundleGetInfoDictionary(bundle);
  if (bundle && !relativeURL)
    relativeURL = (CFURLRef)*((_QWORD *)bundle + 2);
  if (InfoDictionary
    && ((Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, CFSTR("CFBundleExecutable"))) != 0
     || (Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, CFSTR("NSExecutable"))) != 0)
    && (v7 = CFGetTypeID(Value), v7 == CFStringGetTypeID())
    && CFStringGetLength(Value) >= 1)
  {
    CFRetain(Value);
  }
  else if (relativeURL
         && (v8 = CFURLCopyAbsoluteURL(relativeURL),
             v9 = CFURLCopyFileSystemPath(v8, kCFURLPOSIXPathStyle),
             CFRelease(v8),
             v9))
  {
    Length = CFStringGetLength(v9);
    PathComponent2 = _CFStartOfLastPathComponent2(v9);
    v12 = _CFLengthAfterDeletingPathExtension2(v9);
    Value = 0;
    if (PathComponent2 <= Length && v12 <= Length && v12 > PathComponent2)
    {
      v14.location = PathComponent2;
      v14.length = v12 - PathComponent2;
      Value = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, v14);
    }
    CFRelease(v9);
  }
  else
  {
    return 0;
  }
  return Value;
}

uint64_t _binaryLoadable(const __CFURL *a1)
{
  uint64_t result;
  UInt8 buffer[1024];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if ((_CFURLExists(a1) & 1) != 0)
    return 1;
  result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024);
  if ((_DWORD)result)
    return _dyld_shared_cache_contains_path((const char *)buffer);
  return result;
}

char *__CFgetenvIfNotRestricted(char *a1)
{
  if (issetugid())
    return 0;
  else
    return __CFgetenv(a1);
}

uint64_t _CFPlugInUnscheduleForUnloading(const void *a1)
{
  os_unfair_recursive_lock_lock_with_options();
  if (_plugInsToUnload)
    CFSetRemoveValue((CFMutableSetRef)_plugInsToUnload, a1);
  if (_CFBundlePluginLogger_onceToken != -1)
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
    _CFPlugInUnscheduleForUnloading_cold_1();
  return os_unfair_recursive_lock_unlock();
}

uint64_t __CFPLUGIN_IS_CALLING_OUT_TO_A_FACTORY_FUNCTION__(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

void *_CFBundleDlfcnGetSymbolByNameWithSearch(uint64_t a1, const __CFString *a2, int a3)
{
  os_unfair_lock_s *v6;
  void *v7;
  void *v8;
  void *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  void *v19;
  __int16 v20;
  char *v21;
  char buffer[1026];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  if (!CFStringGetCString(a2, buffer, 1024, 0x8000100u) || (v7 = *(void **)(a1 + 56)) == 0)
  {
LABEL_11:
    v9 = 0;
    goto LABEL_12;
  }
  v8 = dlsym(v7, buffer);
  v9 = v8;
  if (a3 && !v8)
    v9 = dlsym((void *)0xFFFFFFFFFFFFFFFELL, buffer);
  v10 = _CFBundleLoadingLogger();
  v11 = v10;
  if (!v9)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      _CFBundleDlfcnGetSymbolByNameWithSearch_cold_1();
    goto LABEL_11;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    v12 = *(_QWORD *)(a1 + 56);
    v14 = 138544130;
    v15 = a1;
    v16 = 2048;
    v17 = v12;
    v18 = 2048;
    v19 = v9;
    v20 = 2082;
    v21 = buffer;
    _os_log_debug_impl(&dword_182A8C000, v11, OS_LOG_TYPE_DEBUG, "bundle %{public}@ handle %p dlsym returns symbol %p for %{public}s", (uint8_t *)&v14, 0x2Au);
  }
LABEL_12:
  os_unfair_lock_unlock(v6);
  return v9;
}

uint64_t _CFBundleDlfcnLoadBundle(uint64_t a1, int a2, CFTypeRef *a3)
{
  os_unfair_lock_s *v6;
  int v7;
  uint64_t v8;
  const __CFURL *v9;
  const __CFURL *v10;
  int v11;
  void *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  const __CFAllocator *v16;
  void *v17;
  NSObject *v18;
  const __CFAllocator *v19;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  UInt8 *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  void *v29;
  UInt8 buffer[1026];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock_with_options();
  v7 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock(v6);
  if (v7)
    return 1;
  cf = 0;
  v9 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  v10 = v9;
  if (!v9 || !CFURLGetFileSystemRepresentation(v9, 1u, buffer, 1026))
  {
    v15 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadBundle_cold_1();
      if (!a3)
      {
LABEL_19:
        v8 = 0;
        if (!v10)
          goto LABEL_31;
        goto LABEL_30;
      }
    }
    else if (!a3)
    {
      goto LABEL_19;
    }
    v16 = CFGetAllocator((CFTypeRef)a1);
    cf = _CFBundleCreateError(v16, (__CFBundle *)a1, 4);
    goto LABEL_19;
  }
  if (a2)
    v11 = 265;
  else
    v11 = 262;
  v12 = dlopen((const char *)buffer, v11);
  v13 = _CFBundleLoadingLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138544130;
    v23 = a1;
    v24 = 2082;
    v25 = buffer;
    v26 = 1024;
    v27 = v11;
    v28 = 2048;
    v29 = v12;
    _os_log_debug_impl(&dword_182A8C000, v13, OS_LOG_TYPE_DEBUG, "dlfcn load bundle %{public}@, dlopen of %{public}s mode 0x%x returns handle %p", buf, 0x26u);
  }
  os_unfair_lock_lock_with_options();
  if (!v12)
  {
    *(_QWORD *)(a1 + 56) = 0;
    os_unfair_lock_unlock(v6);
    v17 = dlerror();
    v18 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadBundle_cold_2();
      if (!v17)
      {
LABEL_24:
        if (a3)
        {
          _CFBundleDlfcnPreflight((unsigned __int8 *)a1, (CFErrorRef *)&cf);
          if (!cf)
          {
            v19 = CFGetAllocator((CFTypeRef)a1);
            cf = _CFBundleCreateErrorDebug(v19, (CFBundleRef)a1, 3588, v17);
          }
        }
        if (v17)
          CFRelease(v17);
        v8 = 0;
        goto LABEL_30;
      }
    }
    else if (!v17)
    {
      goto LABEL_24;
    }
    v17 = (void *)CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const char *)v17);
    goto LABEL_24;
  }
  if (v12 == *(void **)(a1 + 56))
  {
    v14 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      _CFBundleDlfcnLoadBundle_cold_3();
    os_unfair_lock_unlock(v6);
    dlclose(v12);
    os_unfair_lock_lock_with_options();
  }
  *(_QWORD *)(a1 + 56) = v12;
  v8 = 1;
  *(_BYTE *)(a1 + 52) = 1;
  os_unfair_lock_unlock(v6);
LABEL_30:
  CFRelease(v10);
LABEL_31:
  if (!a3 || (_DWORD)v8)
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    *a3 = cf;
  }
  return v8;
}

uint64_t _CFBundleEffectiveLayoutVersion(uint64_t a1)
{
  uint64_t v1;
  const __CFDictionary *InfoDictionary;
  CFURLRef v5;
  int32x4_t v6;
  const __CFURL *v7;
  int v8;

  v1 = *(unsigned __int8 *)(a1 + 53);
  if (!*(_BYTE *)(a1 + 53))
  {
    InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)a1);
    if (InfoDictionary && CFDictionaryGetCount(InfoDictionary))
    {
      return 0;
    }
    else
    {
      v5 = CFBundleCopyExecutableURL((CFBundleRef)a1);
      if (v5)
      {
        v7 = v5;
        v8 = *(_DWORD *)(a1 + 48);
        if (!v8)
        {
          v8 = _CFBundleGrokBinaryType(v7, v6);
          *(_DWORD *)(a1 + 48) = v8;
        }
        v1 = 4;
        if (v8 != 1 && v8 != 6)
        {
          v1 = 0;
          *(_BYTE *)(a1 + 64) = 1;
        }
        CFRelease(v7);
      }
      else
      {
        return 4;
      }
    }
  }
  return v1;
}

void _CFBundleEnsureAllBundlesUpToDate()
{
  __CFArray *v0;
  __CFArray *v1;

  CFBundleGetMainBundle();
  v0 = _CFBundleDYLDCopyLoadedImagePathsIfChanged();
  if (v0)
  {
    v1 = v0;
    _CFBundleEnsureBundlesExistForImagePaths(v0);
    CFRelease(v1);
  }
}

__CFArray *_CFBundleDYLDCopyLoadedImagePathsIfChanged()
{
  uint32_t v0;
  __CFArray *Mutable;
  int v2;
  const char *v3;
  mach_header_64 *v4;
  uint32_t v5;
  const char *image_name;
  const char *v7;
  const char *v8;
  char *v9;
  char *v10;
  int64_t v11;
  uint64_t v12;
  int64_t i;
  int v14;
  BOOL v15;
  uint64_t v16;
  CFStringRef v17;
  CFStringRef v18;

  v0 = _dyld_image_count();
  if (v0 != _CFBundleDYLDCopyLoadedImagePathsIfChanged__cachedDYLDImageCount)
  {
    v2 = v0;
    v3 = _CFProcessPath();
    v4 = _NSGetMachExecuteHeader();
    Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    if (!v2)
    {
LABEL_37:
      _CFBundleDYLDCopyLoadedImagePathsIfChanged__cachedDYLDImageCount = v2;
      return Mutable;
    }
    v5 = 0;
    while (1)
    {
      image_name = _dyld_get_image_name(v5);
      v7 = _CFBundleNormalizedPath(image_name);
      v8 = v7;
      v9 = 0;
      if (!v5 && v7)
      {
        v10 = strdup(v7);
        v9 = v10;
        if (!v10)
          goto LABEL_27;
        v11 = strlen(v10);
        v12 = 0;
        if (v11 >= 1)
        {
          for (i = 0; i < v11; ++i)
          {
            v9[v12] = v9[i];
            while (i < v11 - 1 && v9[i] == 47)
            {
              v14 = v9[i + 1];
              if (v14 != 47)
              {
                v15 = v14 == 46 && i < v11 - 2;
                if (!v15 || v9[i + 2] != 47)
                  break;
              }
              if (v14 == 47)
                v16 = 1;
              else
                v16 = 2;
              i += v16;
            }
            ++v12;
          }
        }
        v9[v12] = 0;
      }
      if (!v8)
        goto LABEL_34;
LABEL_27:
      if (v3)
      {
        if (!strcmp(v8, v3))
          goto LABEL_34;
        if (v9 && !strcmp(v9, v3))
        {
LABEL_35:
          free(v9);
          goto LABEL_36;
        }
      }
      if (v4 != (mach_header_64 *)_dyld_get_image_header(v5))
      {
        v17 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v8);
        if (v17)
        {
          v18 = v17;
          CFArrayAppendValue(Mutable, v17);
          CFRelease(v18);
        }
      }
LABEL_34:
      if (v9)
        goto LABEL_35;
LABEL_36:
      if (++v5 == v2)
        goto LABEL_37;
    }
  }
  return 0;
}

uint64_t _CFStartOfLastPathComponent2(const __CFString *a1)
{
  CFIndex Length;
  CFIndex v3;
  uint64_t v4;
  CFIndex v5;
  int CharacterAtIndex;

  Length = CFStringGetLength(a1);
  if (Length < 2)
    return 0;
  v4 = Length;
  v5 = Length;
  do
  {
    v3 = v5 - 1;
    if (v5 == 1)
      break;
    CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v5 - 2);
    v5 = v3;
  }
  while (CharacterAtIndex != 47);
  if (v4 >= 3 && _hasDrive(a1))
    return 2;
  else
    return 0;
}

void _CFBundleDlfcnCheckLoaded_cold_1()
{
  uint64_t v0;
  os_log_t v1;
  uint8_t v2[12];
  __int16 v3;
  uint64_t v4;
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_8();
  v3 = 2082;
  v4 = v0;
  v5 = 1024;
  v6 = 277;
  _os_log_debug_impl(&dword_182A8C000, v1, OS_LOG_TYPE_DEBUG, "dlfcn check load bundle %{public}@, dlopen of %{public}s mode 0x%x no handle", v2, 0x1Cu);
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  void *v3;
  const __CFTimeZone *v4;

  v3 = (void *)_CFAutoreleasePoolPush();
  v4 = (const __CFTimeZone *)(id)+[NSTimeZone _timeZoneWithSecondsFromGMT:](NSTimeZone, "_timeZoneWithSecondsFromGMT:", vcvtmd_s64_f64(ti));
  _CFAutoreleasePoolPop(v3);
  return v4;
}

Boolean CFURLResourceIsReachable(CFURLRef url, CFErrorRef *error)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int IsReachable;
  __CFError *v10;
  __int16 v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  if (!_CFURLHasFileURLScheme((__objc2_class **)url, &v13))
  {
    if (v13)
    {
      if (error)
      {
LABEL_7:
        v10 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 262, 0);
        LOBYTE(IsReachable) = 0;
        goto LABEL_8;
      }
    }
    else
    {
      CFLog(4, (uint64_t)CFSTR("CFURLResourceIsReachable failed because it was passed a URL which has no scheme"), v3, v4, v5, v6, v7, v8, v12);
      if (error)
        goto LABEL_7;
    }
    LOBYTE(IsReachable) = 0;
    return IsReachable;
  }
  IsReachable = _FSURLResourceIsReachable();
  if (!IsReachable && error)
  {
    v10 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 4, 0);
LABEL_8:
    *error = v10;
  }
  return IsReachable;
}

void sub_182B78850(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void CFBurstTrieCursorRelease(void *a1)
{
  if (a1)
    free(a1);
}

__CFArray *CFCopySearchPathForDirectoriesInDomains(uint64_t a1, uint64_t a2, int a3)
{
  __CFArray *Mutable;
  uint64_t started;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  const char *v9;
  const UInt8 *v10;
  const UInt8 *v11;
  size_t v12;
  CFURLRef v13;
  CFURLRef v14;
  UInt8 buffer[1026];
  char __s[1026];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  started = sysdir_start_search_path_enumeration_private();
  v6 = MEMORY[0x186DB0B7C](started, __s);
  if ((_DWORD)v6)
  {
    v7 = v6;
    v8 = -1;
    do
    {
      v9 = __s;
      if (a3 && __s[0] == 126)
      {
        if ((v8 & 0x8000000000000000) != 0)
        {
          v10 = CFCopyHomeDirectoryURLForUser(0);
          if (v10)
          {
            v11 = v10;
            CFURLGetFileSystemRepresentation((CFURLRef)v10, 1u, buffer, 1026);
            v8 = strlen((const char *)buffer);
            CFRelease(v11);
          }
        }
        if (strlen(__s) + v8 > 0x401)
          goto LABEL_12;
        v9 = (const char *)buffer;
        buffer[v8] = 0;
        __strlcat_chk();
      }
      v12 = strlen(v9);
      v13 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v9, v12, 1u);
      if (v13)
      {
        v14 = v13;
        CFArrayAppendValue(Mutable, v13);
        CFRelease(v14);
      }
LABEL_12:
      v7 = MEMORY[0x186DB0B7C](v7, __s);
    }
    while ((_DWORD)v7);
  }
  return Mutable;
}

const UInt8 *CFCopyHomeDirectoryURLForUser(const __CFString *a1)
{
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  uint64_t v4;
  UInt8 *Typed;
  CFIndex Bytes;
  const char *v8;
  const UInt8 *v9;
  CFIndex usedBufLen;
  UInt8 buffer[128];
  uint64_t v12;
  CFRange v13;

  v12 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return _CFCopyHomeDirURLForUser(0, 1);
  Length = (int)CFStringGetLength(a1);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  usedBufLen = 0;
  v4 = MaximumSizeForEncoding << 32;
  if ((int)MaximumSizeForEncoding > 126)
    Typed = (UInt8 *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, ((MaximumSizeForEncoding << 32) + 0x100000000) >> 32, 1826429807, 0);
  else
    Typed = buffer;
  v13.location = 0;
  v13.length = Length;
  Bytes = CFStringGetBytes(a1, v13, 0x8000100u, 0, 1u, Typed, v4 >> 32, &usedBufLen);
  v8 = 0;
  if (Bytes == Length)
  {
    Typed[usedBufLen] = 0;
    v8 = (const char *)Typed;
  }
  v9 = _CFCopyHomeDirURLForUser(v8, 0);
  if (buffer != Typed)
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  return v9;
}

void ___bundleInfo_block_invoke()
{
  __CFBundle *MainBundle;
  const __CFDictionary *InfoDictionary;
  const __CFDictionary *v2;
  const __CFString *Value;
  const __CFString *v4;
  CFStringRef Copy;
  const __CFString *v6;

  MainBundle = CFBundleGetMainBundle();
  if (MainBundle && (InfoDictionary = CFBundleGetInfoDictionary(MainBundle)) != 0)
  {
    v2 = InfoDictionary;
    Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, CFSTR("CFBundleIdentifier"));
    v4 = (const __CFString *)CFDictionaryGetValue(v2, CFSTR("CFBundleShortVersionString"));
    if (Value)
      Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Value);
    else
      Copy = &stru_1E1337B18;
    _bundleInfo_info_0 = (uint64_t)Copy;
    if (v4)
      v6 = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4);
    else
      v6 = &stru_1E1337B18;
  }
  else
  {
    v6 = &stru_1E1337B18;
    _bundleInfo_info_0 = (uint64_t)&stru_1E1337B18;
  }
  _bundleInfo_info_1 = (uint64_t)v6;
  _bundleInfo_info_2 = CFStringGetDoubleValue(v6);
}

double CFStringGetDoubleValue(CFStringRef str)
{
  const UniChar *CharactersPtr;
  uint64_t CStringPtrInternal;
  int v4;
  double result;
  int v6;
  double v7;
  UniChar buffer[8];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  CFStringRef v16;
  const UniChar *v17;
  uint64_t v18;
  uint64_t v19;
  CFIndex Length;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v16 = str;
  v19 = 0;
  Length = CFStringGetLength(str);
  CharactersPtr = CFStringGetCharactersPtr(v16);
  CStringPtrInternal = 0;
  v17 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtrInternal = _CFStringGetCStringPtrInternal((uint64_t)str, 0x600u, 0, 1);
  v7 = 0.0;
  *(_OWORD *)buffer = 0u;
  v9 = 0u;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v18 = CStringPtrInternal;
  v21 = 0;
  v22 = 0;
  v4 = __CFStringScanDouble(buffer, 0, &v6, &v7);
  result = v7;
  if (!v4)
    return 0.0;
  return result;
}

void sub_182B78FCC(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182B79BE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  free(*(void **)(v1 - 384));
  free(*(void **)(v1 - 376));
  _Unwind_Resume(a1);
}

CFIndex CFBinaryHeapGetCount(CFBinaryHeapRef heap)
{
  return *((_QWORD *)heap + 2);
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
  -[__CFCalendar setTimeZone:](calendar, "setTimeZone:", tz);
}

uint64_t _CFURLComponentsSetHost(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setHost:", a2);
  return 1;
}

CFRunLoopObserverRef CFRunLoopObserverCreateWithHandler(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, void *block)
{
  CFRunLoopObserverContext v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v6.version = 0;
  v6.info = block;
  v6.retain = (const void *(__cdecl *)(const void *))MEMORY[0x1E0C80928];
  v6.release = (void (__cdecl *)(const void *))MEMORY[0x1E0C80958];
  v6.copyDescription = 0;
  return CFRunLoopObserverCreate(allocator, activities, repeats, order, (CFRunLoopObserverCallBack)_runLoopObserverWithBlockContext, &v6);
}

CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context)
{
  int v9;
  uint64_t Instance;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  unint64_t v24;
  int v25;
  void *info;
  const void *(__cdecl *retain)(const void *);
  pthread_mutexattr_t v29;
  uint64_t v30;

  v9 = repeats;
  v30 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  Instance = _CFRuntimeCreateInstance((__objc2_class **)allocator, 0x2DuLL, 144, 0);
  v13 = Instance;
  if (Instance)
  {
    v14 = (unint64_t *)(Instance + 8);
    v15 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      v16 = __ldaxr(v14);
      if (v16 != v15)
        break;
      if (__stlxr(v15 | 8, v14))
        goto LABEL_11;
      v17 = 1;
LABEL_12:
      v15 = v16;
      if (v17)
      {
        v18 = atomic_load(v14);
        while (1)
        {
          v19 = __ldaxr(v14);
          if (v19 != v18)
            break;
          if (__stlxr(v18 & 0xFFFFFFFFFFFFFFFELL, v14))
            goto LABEL_18;
          v20 = 1;
LABEL_19:
          v18 = v19;
          if (v20)
          {
            v21 = atomic_load(v14);
            if (v9)
            {
              while (1)
              {
                v22 = __ldaxr(v14);
                if (v22 != v21)
                  break;
                if (__stlxr(v21 | 2, v14))
                  goto LABEL_25;
                v23 = 1;
LABEL_26:
                v21 = v22;
                if ((v23 & 1) != 0)
                  goto LABEL_34;
              }
              __clrex();
LABEL_25:
              v23 = 0;
              goto LABEL_26;
            }
            while (2)
            {
              v24 = __ldaxr(v14);
              if (v24 == v21)
              {
                if (!__stlxr(v21 & 0xFFFFFFFFFFFFFFFDLL, v14))
                {
                  v25 = 1;
                  goto LABEL_33;
                }
              }
              else
              {
                __clrex();
              }
              v25 = 0;
LABEL_33:
              v21 = v24;
              if (v25)
              {
LABEL_34:
                v29.__sig = 0;
                *(_QWORD *)v29.__opaque = 0;
                pthread_mutexattr_init(&v29);
                pthread_mutexattr_settype(&v29, 2);
                pthread_mutex_init((pthread_mutex_t *)(v13 + 16), &v29);
                pthread_mutexattr_destroy(&v29);
                *(_QWORD *)(v13 + 80) = 0;
                *(_QWORD *)(v13 + 88) = 0;
                *(_QWORD *)(v13 + 96) = activities;
                *(_QWORD *)(v13 + 104) = order;
                *(_QWORD *)(v13 + 112) = callout;
                if (context)
                {
                  info = context->info;
                  retain = context->retain;
                  if (retain)
                    info = (void *)((uint64_t (*)(void *))retain)(info);
                  *(_QWORD *)(v13 + 128) = info;
                  *(_OWORD *)(v13 + 136) = *(_OWORD *)&context->retain;
                  *(_QWORD *)(v13 + 152) = context->copyDescription;
                }
                return (CFRunLoopObserverRef)v13;
              }
              continue;
            }
          }
        }
        __clrex();
LABEL_18:
        v20 = 0;
        goto LABEL_19;
      }
    }
    __clrex();
LABEL_11:
    v17 = 0;
    goto LABEL_12;
  }
  return (CFRunLoopObserverRef)v13;
}

CFCharacterSetRef CFCharacterSetCreateWithBitmapRepresentation(CFAllocatorRef alloc, CFDataRef theData)
{
  unint64_t *Instance;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  CFIndex Length;
  int64_t v14;
  char *v15;
  const UInt8 *v16;
  _OWORD *v17;
  _OWORD *v18;
  unint64_t v19;
  unint64_t v20;
  char v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  CFCharacterSetRef result;
  unsigned __int8 *BytePtr;
  _OWORD *v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  void *Typed;
  const UInt8 *v32;
  uint64_t v33;
  unsigned __int8 *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  CFAllocatorRef v39;
  uint64_t v40;
  CFAllocatorRef v41;
  uint64_t v42;
  uint64_t v43;
  const __CFAllocator *v44;
  CFMutableCharacterSetRef Mutable;
  char *v46;
  CFCharacterSetRef v47;
  unint64_t *v48;
  unint64_t v49;
  unint64_t v50;
  char v51;
  unint64_t *v52;
  unint64_t v53;
  unint64_t v54;
  int v55;
  unint64_t *v56;
  unint64_t v57;
  unint64_t v58;
  char v59;
  void *v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t v63;
  char v64;
  BOOL v65;

  Instance = (unint64_t *)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x19uLL, 32, 0);
  v5 = Instance;
  if (!Instance)
    return (CFCharacterSetRef)v5;
  v6 = Instance + 1;
  v7 = atomic_load(Instance + 1);
  do
  {
    v8 = __ldaxr(v6);
    if (v8 == v7)
    {
      if (!__stlxr(v7 & 0xFFFFFFFFFFFFFFFELL, v6))
      {
        v9 = 1;
        goto LABEL_8;
      }
    }
    else
    {
      __clrex();
    }
    v9 = 0;
LABEL_8:
    v7 = v8;
  }
  while (!v9);
  v10 = atomic_load(v6);
  do
  {
    v11 = __ldaxr(v6);
    if (v11 == v10)
    {
      if (!__stlxr(v10 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v6))
      {
        v12 = 1;
        goto LABEL_15;
      }
    }
    else
    {
      __clrex();
    }
    v12 = 0;
LABEL_15:
    v10 = v11;
  }
  while (!v12);
  Instance[2] = 0;
  Instance[5] = 0;
  if (!theData || (Length = CFDataGetLength(theData), Length < 1))
  {
    v5[3] = 0;
    v22 = atomic_load(v5 + 1);
    while (1)
    {
      v23 = __ldaxr(v6);
      if (v23 != v22)
        break;
      if (__stlxr(v22 | 4, v6))
        goto LABEL_33;
      v24 = 1;
LABEL_34:
      v22 = v23;
      if (v24)
        return (CFCharacterSetRef)v5;
    }
    __clrex();
LABEL_33:
    v24 = 0;
    goto LABEL_34;
  }
  v14 = Length;
  if ((unint64_t)Length >> 13)
  {
    BytePtr = (unsigned __int8 *)CFDataGetBytePtr(theData);
    v27 = __CFCreateCompactBitmap((uint64_t)alloc, BytePtr);
    if (v27)
    {
      v5[3] = (unint64_t)v27;
      v28 = atomic_load(v5 + 1);
      while (1)
      {
        v29 = __ldaxr(v6);
        if (v29 != v28)
          break;
        if (__stlxr(v28 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v6))
          goto LABEL_42;
        v30 = 1;
LABEL_43:
        v28 = v29;
        if (v30)
          goto LABEL_47;
      }
      __clrex();
LABEL_42:
      v30 = 0;
      goto LABEL_43;
    }
    Typed = (void *)CFAllocatorAllocateTyped(alloc, 0x2000, 865737595, 0);
    v32 = CFDataGetBytePtr(theData);
    memmove(Typed, v32, 0x2000uLL);
    v5[3] = (unint64_t)Typed;
LABEL_47:
    v33 = v14 - 0x2000;
    if (v14 <= 0x2000)
      return (CFCharacterSetRef)v5;
    result = (CFCharacterSetRef)CFDataGetBytePtr(theData);
    if (v14 == 8193)
      return (CFCharacterSetRef)v5;
    v34 = (unsigned __int8 *)result;
LABEL_50:
    v35 = v34[0x2000];
    if (!v34[0x2000])
    {
      __break(1u);
      return result;
    }
    if (v35 > 0x10)
    {
      v36 = 0;
LABEL_64:
      v34 += 8193;
      if ((unint64_t)v33 <= 0x2000)
      {
        v46 = (char *)CFAllocatorAllocateTyped(alloc, 0x2000, 263798340, 0);
        memmove(v46, v34, v33 - 1);
        bzero(&v46[v33 - 1], 8193 - v33);
        result = (CFCharacterSetRef)__CFCreateCompactBitmap((uint64_t)alloc, (unsigned __int8 *)v46);
        if (result)
        {
          v47 = result;
          CFAllocatorDeallocate(alloc, v46);
          *(_QWORD *)(v36 + 24) = v47;
          v48 = (unint64_t *)(v36 + 8);
          v49 = atomic_load((unint64_t *)(v36 + 8));
          while (1)
          {
            v50 = __ldaxr(v48);
            if (v50 != v49)
              break;
            if (__stlxr(v49 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v48))
              goto LABEL_71;
            v51 = 1;
LABEL_72:
            v49 = v50;
            if ((v51 & 1) != 0)
              goto LABEL_98;
          }
          __clrex();
LABEL_71:
          v51 = 0;
          goto LABEL_72;
        }
        *(_QWORD *)(v36 + 24) = v46;
        v56 = (unint64_t *)(v36 + 8);
        v57 = atomic_load((unint64_t *)(v36 + 8));
        while (1)
        {
          v58 = __ldaxr(v56);
          if (v58 != v57)
            break;
          if (__stlxr(v57 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v56))
            goto LABEL_88;
          v59 = 1;
LABEL_89:
          v57 = v58;
          if ((v59 & 1) != 0)
            goto LABEL_98;
        }
        __clrex();
LABEL_88:
        v59 = 0;
        goto LABEL_89;
      }
      result = (CFCharacterSetRef)__CFCreateCompactBitmap((uint64_t)alloc, v34);
      if (result)
      {
        *(_QWORD *)(v36 + 24) = result;
        v52 = (unint64_t *)(v36 + 8);
        v53 = atomic_load((unint64_t *)(v36 + 8));
        while (1)
        {
          v54 = __ldaxr(v52);
          if (v54 != v53)
            break;
          if (__stlxr(v53 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v52))
            goto LABEL_80;
          v55 = 1;
LABEL_81:
          v53 = v54;
          if (v55)
            goto LABEL_98;
        }
        __clrex();
LABEL_80:
        v55 = 0;
        goto LABEL_81;
      }
      v60 = (void *)CFAllocatorAllocateTyped(alloc, 0x2000, 1506995671, 0);
      result = (CFCharacterSetRef)memmove(v60, v34, 0x2000uLL);
      *(_QWORD *)(v36 + 24) = v60;
      v61 = (unint64_t *)(v36 + 8);
      v62 = atomic_load((unint64_t *)(v36 + 8));
      while (1)
      {
        v63 = __ldaxr(v61);
        if (v63 != v62)
          break;
        if (__stlxr(v62 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v61))
          goto LABEL_96;
        v64 = 1;
LABEL_97:
        v62 = v63;
        if ((v64 & 1) != 0)
        {
LABEL_98:
          v65 = v33 <= 8194;
          v33 -= 8193;
          if (v65)
            return (CFCharacterSetRef)v5;
          goto LABEL_50;
        }
      }
      __clrex();
LABEL_96:
      v64 = 0;
      goto LABEL_97;
    }
    v37 = v5[5];
    if (v37)
    {
      if (*(unsigned __int8 *)(v37 + 12) >= v35)
      {
LABEL_60:
        if ((*(_DWORD *)(v37 + 8) & (1 << v35)) != 0)
        {
          v43 = (v35 - 1);
        }
        else
        {
          v44 = CFGetAllocator(v5);
          Mutable = CFCharacterSetCreateMutable(v44);
          v43 = (v35 - 1);
          *(_QWORD *)(*(_QWORD *)v5[5] + 8 * v43) = Mutable;
          v37 = v5[5];
          *(_DWORD *)(v37 + 8) |= 1 << v35;
        }
        v36 = *(_QWORD *)(*(_QWORD *)v37 + 8 * v43);
        goto LABEL_64;
      }
      *(_BYTE *)(v37 + 12) = v35;
      v38 = *(_QWORD *)v37;
      v39 = CFGetAllocator(v5);
      if (v38)
      {
        v40 = __CFSafelyReallocateWithAllocatorTyped(v39, *(_QWORD *)v5[5], 8 * v35, 0x6004044C4A2DFLL, 0, 0);
LABEL_59:
        v37 = v5[5];
        *(_QWORD *)v37 = v40;
        goto LABEL_60;
      }
    }
    else
    {
      v41 = CFGetAllocator(v5);
      v42 = CFAllocatorAllocateTyped(v41, 16, 0x1080040FC6463CFLL, 0);
      v5[5] = v42;
      *(_BYTE *)(v42 + 12) = v35;
      *(_BYTE *)(v42 + 13) = 0;
      *(_DWORD *)(v42 + 8) = 0;
      v39 = CFGetAllocator(v5);
    }
    v40 = CFAllocatorAllocateTyped(v39, 8 * v35, 0x6004044C4A2DFLL, 0);
    goto LABEL_59;
  }
  v15 = (char *)CFAllocatorAllocateTyped(alloc, 0x2000, 2153428176, 0);
  v16 = CFDataGetBytePtr(theData);
  memmove(v15, v16, v14);
  bzero(&v15[v14], 0x2000 - v14);
  v17 = __CFCreateCompactBitmap((uint64_t)alloc, (unsigned __int8 *)v15);
  if (v17)
  {
    v18 = v17;
    CFAllocatorDeallocate(alloc, v15);
    v5[3] = (unint64_t)v18;
    v19 = atomic_load(v5 + 1);
    while (1)
    {
      v20 = __ldaxr(v6);
      if (v20 != v19)
        break;
      if (__stlxr(v19 & 0xFFFFFFFFFFFFFF8FLL | 0x40, v6))
        goto LABEL_25;
      v21 = 1;
LABEL_26:
      v19 = v20;
      if ((v21 & 1) != 0)
        return (CFCharacterSetRef)v5;
    }
    __clrex();
LABEL_25:
    v21 = 0;
    goto LABEL_26;
  }
  v5[3] = (unint64_t)v15;
  return (CFCharacterSetRef)v5;
}

_OWORD *__CFCreateCompactBitmap(uint64_t a1, unsigned __int8 *a2)
{
  _OWORD *v2;
  uint64_t v3;
  int v4;
  unsigned __int8 *v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  _OWORD *Typed;
  uint64_t v11;
  _OWORD *v12;
  int v13;
  __int128 v14;
  _OWORD *v15;
  _BYTE __src[256];
  uint64_t v18;

  v2 = a2;
  v3 = 0;
  v4 = 0;
  v18 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  do
  {
    v6 = *v5;
    if ((v6 + 1) <= 1u)
    {
      v7 = 32;
      v8 = 1;
      while (v5[v8] == v6)
      {
        --v7;
        ++v8;
        if (v7 <= 1)
        {
          __src[v3] = v6;
          goto LABEL_9;
        }
      }
    }
    __src[v3] = v4 + 1;
    if (v4++ > 127)
      return 0;
LABEL_9:
    v5 += 32;
    ++v3;
  }
  while (v3 != 256);
  Typed = (_OWORD *)CFAllocatorAllocateTyped(a1, 32 * v4 + 256, 1807271846, 0);
  v15 = Typed;
  if (v4 < 1)
  {
    memmove(Typed, __src, 0x100uLL);
  }
  else
  {
    v11 = 0;
    v12 = Typed + 16;
    do
    {
      v13 = __src[v11];
      *((_BYTE *)Typed + v11) = v13;
      if (v13 && v13 != 255)
      {
        v14 = v2[1];
        *v12 = *v2;
        v12[1] = v14;
        v12 += 2;
      }
      v2 += 2;
      ++v11;
    }
    while (v11 != 256);
  }
  return v15;
}

void CFXNotificationRegisteredObserverSetDistributedConnection(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  os_unfair_lock_s *v6;

  v6 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(_DWORD *)(a1 + 156) > a2)
    _CFXNotificationRegisteredObserverSetDistributedConnection((_QWORD *)a1, SHIDWORD(a2), a2, a3);
  os_unfair_lock_unlock(v6);
}

_QWORD *_CFXNotificationRegisteredObserverSetDistributedConnection(_QWORD *result, int a2, unsigned int a3, _QWORD *object)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  v4 = result[18];
  if (*(_DWORD *)(v4 + 56 * a3 + 40) == a2)
  {
    v6 = v4 + 56 * a3;
    v8 = *(_QWORD **)(v6 + 32);
    v7 = v6 + 32;
    result = v8;
    *(_DWORD *)(v7 + 12) |= 0x2000u;
    if (v8 != object)
    {
      if (result)
        xpc_release(result);
      result = xpc_retain(object);
      *(_QWORD *)v7 = result;
    }
  }
  return result;
}

uint64_t __CFCalendarCreateUCalendar(const void *a1, CFLocaleIdentifier localeID, const __CFTimeZone *a3)
{
  const __CFString *LocaleIdentifierFromComponents;
  const __CFDictionary *ComponentsFromLocaleIdentifier;
  __CFDictionary *MutableCopy;
  char *CStringPtr;
  uint64_t v9;
  char *v10;
  const __CFString *Name;
  unint64_t Length;
  CFIndex v13;
  uint64_t v14;
  UChar v16[512];
  char v17[516];
  int v18;
  uint64_t v19;
  CFRange v20;

  LocaleIdentifierFromComponents = localeID;
  v19 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier((CFAllocatorRef)&__kCFAllocatorSystemDefault, localeID);
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, ComponentsFromLocaleIdentifier);
    CFDictionarySetValue(MutableCopy, CFSTR("calendar"), a1);
    LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy);
    CFRelease(MutableCopy);
    CFRelease(ComponentsFromLocaleIdentifier);
  }
  MEMORY[0x1E0C80A78](a1, localeID);
  CStringPtr = (char *)CFStringGetCStringPtr(LocaleIdentifierFromComponents, 0x600u);
  v10 = CStringPtr;
  if (CStringPtr
    || (CStringPtr = (char *)CFStringGetCString(LocaleIdentifierFromComponents, v17, 512, 0x600u),
        v10 = v17,
        (_DWORD)CStringPtr))
  {
    MEMORY[0x1E0C80A78](CStringPtr, v9);
    Name = CFTimeZoneGetName(a3);
    Length = CFStringGetLength(Name);
    if (Length >= 0x200)
      v13 = 512;
    else
      v13 = Length;
    v20.location = 0;
    v20.length = v13;
    CFStringGetCharacters(Name, v20, v16);
    v18 = 0;
    v14 = __cficu_ucal_open(v16, v13, (uint64_t)v10, 0, &v18);
    if (a1)
      CFRelease(LocaleIdentifierFromComponents);
  }
  else
  {
    if (a1)
      CFRelease(LocaleIdentifierFromComponents);
    return 0;
  }
  return v14;
}

uint64_t __cficu_ucal_open(UChar *a1, int32_t a2, uint64_t a3, int a4, void *a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  CFStringRef v13;
  CFStringRef v14;
  NSObject *v15;
  const char *v17;
  int v18;
  const void *v19;
  __int16 v20;
  CFStringRef v21;
  __int16 v22;
  int32_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  const void *v29;
  __int16 v30;
  CFStringRef v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v10 = ucal_open();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v11 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"cal", v10);
      v12 = (const void *)___CFICUCreateVariableNameForStatus(a5);
      v13 = ___CFICUCreateErrorStringWithComment((int *)a5, 1);
      v14 = ___CFICUCreateArgumentForUCharInput(a1, a2, 0);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v15 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v17 = "<unknown UCalendarType>";
        v18 = 138413826;
        v22 = 1024;
        v19 = v11;
        if (a4 == 1)
          v17 = "UCAL_GREGORIAN";
        v20 = 2112;
        v21 = v14;
        if (!a4)
          v17 = "UCAL_TRADITIONAL";
        v23 = a2;
        v24 = 2080;
        v25 = a3;
        v26 = 2080;
        v27 = v17;
        v28 = 2112;
        v29 = v12;
        v30 = 2112;
        v31 = v13;
        _os_log_debug_impl(&dword_182A8C000, v15, OS_LOG_TYPE_DEBUG, "UCalendar *%@ = ucal_open(%@, %d, \"%s\", %s, &%@); %@",
          (uint8_t *)&v18,
          0x44u);
      }
      CFRelease(v11);
      CFRelease(v14);
      CFRelease(v12);
      CFRelease(v13);
    }
  }
  return v10;
}

CFMessagePortRef CFMessagePortCreateRemote(CFAllocatorRef allocator, CFStringRef name)
{
  return (CFMessagePortRef)__CFMessagePortCreateRemote((__objc2_class **)allocator, name, 0, 0);
}

CFStringRef CFURLCopyQueryString(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  const __CFString *String;
  const __CFString *v5;
  int v6;
  const __CFAllocator *v7;
  CFStringRef v8;
  const __CFString *v9;

  String = _unescapedQueryString((uint64_t)anURL);
  if (!String)
    return 0;
  v5 = String;
  v6 = *((_DWORD *)anURL + 5);
  v7 = CFGetAllocator(anURL);
  if (v6 == 134217984)
    v8 = CFURLCreateStringByReplacingPercentEscapes(v7, v5, charactersToLeaveEscaped);
  else
    v8 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v7, v5, charactersToLeaveEscaped, *((_DWORD *)anURL + 5));
  v9 = v8;
  CFRelease(v5);
  return v9;
}

const __CFString *_unescapedQueryString(uint64_t a1)
{
  const __CFString *v2;
  int v3;
  const void *v4;
  const void *v5;

  while (1)
  {
    if (!a1)
      _unescapedQueryString_cold_1();
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1))
      break;
    v2 = _retainedComponentString(a1, 128, 0, 0);
    if (v2)
      return v2;
    v3 = *(_DWORD *)(a1 + 16);
    if ((v3 & 0x4000) == 0)
      return 0;
    v4 = 0;
    if ((v3 & 0x3F) == 0)
    {
      a1 = *(_QWORD *)(a1 + 32);
      if (a1)
        continue;
    }
    return (const __CFString *)v4;
  }
  v5 = (const void *)objc_msgSend((id)a1, "query");
  v4 = v5;
  if (v5)
    CFRetain(v5);
  return (const __CFString *)v4;
}

Boolean CFBundleGetPackageInfoInDirectory(CFURLRef url, UInt32 *packageType, UInt32 *packageCreator)
{
  return _CFBundleGetPackageInfoInDirectoryWithInfoDictionary(url, 0, (int *)packageType, packageCreator);
}

void sub_182B7BBF8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

CFTypeRef _CFBundleCopyInfoPlistURL(uint64_t a1)
{
  os_unfair_lock_s *v2;
  const void *v3;
  CFTypeRef v4;

  v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  v3 = *(const void **)(a1 + 216);
  if (v3)
    v4 = CFRetain(v3);
  else
    v4 = 0;
  os_unfair_lock_unlock(v2);
  return v4;
}

BOOL CFAttributedStringGetBidiLevelsAndResolvedDirections(const __CFAttributedString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  const __CFString *String;
  const char *CStringPtr;
  const __CFString *v14;
  int64_t v15;
  uint64_t UnicodePropertyDataForPlane;
  int64_t v17;
  UniChar *v18;
  int64_t v19;
  UniChar v20;
  unsigned int v21;
  unsigned int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  int64_t v27;
  int64_t v28;
  UniChar *v29;
  int64_t v30;
  UniChar v31;
  const void *v32;
  uint64_t v33;
  char v34;
  _OWORD *v35;
  void **v36;
  CFIndex v37;
  CFTypeRef AttributeAndLongestEffectiveRange;
  CFIndex v39;
  int64_t v40;
  int64_t v41;
  CFIndex v42;
  uint64_t v43;
  int64_t v44;
  uint64_t v45;
  int64_t v46;
  UniChar v47;
  unsigned int v48;
  int64_t v49;
  uint64_t v50;
  uint64_t v51;
  int64_t v52;
  int64_t v53;
  int v54;
  CFIndex v55;
  uint64_t v56;
  CFIndex Count;
  CFIndex v58;
  CFIndex v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  const __CFNumber *ValueAtIndex;
  int location;
  uint64_t v65;
  int v66;
  uint64_t j;
  int v68;
  char v69;
  uint64_t v70;
  int v71;
  __int16 v72;
  CFIndex v73;
  uint64_t v74;
  uint64_t i;
  uint64_t v76;
  __int16 v77;
  _WORD *v78;
  uint64_t k;
  uint64_t v80;
  __int16 v81;
  UniChar *Typed;
  UniChar *v83;
  CFStringRef v84;
  const __CFString *v85;
  int v86;
  int64_t v87;
  int64_t v88;
  uint64_t v89;
  UniChar *v90;
  int64_t v91;
  CFIndex v92;
  int64_t v93;
  int64_t v94;
  CFRange v95;
  const char *v96;
  UniChar *v97;
  UniChar v98;
  CFRange v99;
  const char *v100;
  UniChar v101;
  CFStringRef v102;
  CFURLRef v103;
  char v104;
  void **v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  uint64_t v109;
  __int16 v110;
  __int16 v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  void **v118;
  void *v119;
  int64_t v120;
  int64_t v121;
  UniChar *v122;
  UniChar *v123;
  uint64_t v124;
  UniChar *v125;
  CFIndex v126;
  CFRange v127;
  const char *v128;
  UniChar *v129;
  UniChar v130;
  int64_t v131;
  int64_t v132;
  int64_t v133;
  UniChar *v134;
  int64_t v135;
  UniChar v136;
  CFRange v137;
  const char *v138;
  UniChar v139;
  int64_t v140;
  int64_t v141;
  __int16 v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  const void *Levels;
  __int16 v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  void **v157;
  void *v158;
  int ParaLevel;
  int64_t v160;
  int64_t v161;
  uint64_t v162;
  uint64_t v163;
  char v164;
  __int16 v166;
  _BYTE *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  void *v172;
  int v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  char v177;
  int64_t v178;
  void *v179;
  CFIndex v180;
  char v181;
  char v183;
  uint64_t inRange;
  uint64_t v185;
  int v186;
  uint64_t range;
  void **range_8;
  void **range_8a;
  uint64_t numChars;
  uint64_t v191;
  _OWORD *ptr;
  _OWORD *ptra;
  _OWORD *ptrb;
  CFIndex loc;
  CFRange values;
  int valuePtr;
  CFRange longestEffectiveRange;
  UErrorCode code;
  UniChar buffer[8];
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  CFStringRef theString;
  const UniChar *CharactersPtr;
  const char *v210;
  uint64_t v211;
  int64_t v212;
  int64_t v213;
  int64_t v214;
  _QWORD v215[2];
  int v216;
  _QWORD v217[2];
  int v218;
  _QWORD v219[2];
  int v220;
  _OWORD v221[5];
  _OWORD v222[2];
  uint64_t v223;
  uint64_t v224;
  CFRange v225;
  CFRange v226;
  CFRange v227;
  CFRange v228;
  CFRange v229;
  CFRange v230;

  v173 = a4;
  v224 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v14 = CFSTR("attributedString cannot be NULL");
LABEL_285:
    CFLog(3, (uint64_t)v14, a3, a4, a5, a6, a7, a8, v166);
    return 0;
  }
  if (!a5)
  {
    v14 = CFSTR("bidiLevels cannot be NULL");
    goto LABEL_285;
  }
  v9 = a6;
  v10 = a3;
  String = CFAttributedStringGetString(a1);
  v206 = 0u;
  v207 = 0u;
  v204 = 0u;
  v205 = 0u;
  v202 = 0u;
  v203 = 0u;
  *(_OWORD *)buffer = 0u;
  v201 = 0u;
  theString = String;
  v211 = a2;
  v212 = v10;
  CharactersPtr = CFStringGetCharactersPtr(String);
  if (CharactersPtr)
    CStringPtr = 0;
  else
    CStringPtr = CFStringGetCStringPtr(String, 0x600u);
  v213 = 0;
  v214 = 0;
  v210 = CStringPtr;
  if (!ubidi_open())
  {
    v14 = CFSTR("ubidi_open return NULL object");
    goto LABEL_285;
  }
  if (v10 <= 0)
  {
    ubidi_close();
    return 0;
  }
  v167 = (_BYTE *)a5;
  v15 = 0;
  UnicodePropertyDataForPlane = 0;
  v176 = a2 - 1;
  v177 = -1;
  v168 = v10;
  v169 = a2;
  v170 = v9;
  do
  {
    v178 = v15 + 1;
    if (v15 < 0 || (v17 = v212, v212 <= v15))
    {
      v21 = 0;
      goto LABEL_17;
    }
    v18 = (UniChar *)CharactersPtr;
    if (CharactersPtr)
    {
      v19 = v211 + v15;
    }
    else
    {
      if (v210)
      {
        v20 = v210[v211 + v15];
        goto LABEL_33;
      }
      if (v214 <= v15 || (v131 = v213, v213 > v15))
      {
        v132 = v15 - 4;
        if ((unint64_t)v15 < 4)
          v132 = 0;
        if (v132 + 64 < v212)
          v17 = v132 + 64;
        v213 = v132;
        v214 = v17;
        v226.location = v211 + v132;
        v226.length = v17 - v132;
        CFStringGetCharacters(theString, v226, buffer);
        v131 = v213;
      }
      v19 = v15 - v131;
      v18 = buffer;
    }
    v20 = v18[v19];
LABEL_33:
    v21 = v20;
    if (v20 >> 10 != 54)
      goto LABEL_17;
    v28 = v212;
    if (v212 <= v178)
      goto LABEL_17;
    v29 = (UniChar *)CharactersPtr;
    if (CharactersPtr)
    {
      v30 = v211 + v178;
LABEL_37:
      v31 = v29[v30];
      goto LABEL_223;
    }
    if (!v210)
    {
      if (v214 <= v178 || (v140 = v213, v213 > v178))
      {
        v141 = v15 - 3;
        if ((unint64_t)v178 < 4)
          v141 = 0;
        if (v141 + 64 < v212)
          v28 = v141 + 64;
        v213 = v141;
        v214 = v28;
        v227.location = v211 + v141;
        v227.length = v28 - v141;
        CFStringGetCharacters(theString, v227, buffer);
        v140 = v213;
      }
      v30 = v178 - v140;
      v29 = buffer;
      goto LABEL_37;
    }
    v31 = v210[v211 + v178];
LABEL_223:
    if (v31 >> 10 == 55)
    {
      v133 = v212;
      if (v212 <= v178)
      {
        v136 = 0;
      }
      else
      {
        v134 = (UniChar *)CharactersPtr;
        if (CharactersPtr)
        {
          v135 = v211 + v178;
        }
        else
        {
          if (v210)
          {
            v136 = v210[v211 + v178];
            goto LABEL_236;
          }
          if (v214 <= v178 || (v160 = v213, v213 > v178))
          {
            v161 = v15 - 3;
            if ((unint64_t)v15 < 3)
              v161 = 0;
            if (v161 + 64 < v212)
              v133 = v161 + 64;
            v213 = v161;
            v214 = v133;
            v228.location = v211 + v161;
            v228.length = v133 - v161;
            CFStringGetCharacters(theString, v228, buffer);
            v160 = v213;
          }
          v135 = v178 - v160;
          v134 = buffer;
        }
        v136 = v134[v135];
      }
LABEL_236:
      v178 = v15 + 2;
      v21 = (v21 << 10) + v136 - 56613888;
    }
LABEL_17:
    if ((HIWORD(v21) & 0x1F) != v177)
    {
      UnicodePropertyDataForPlane = CFUniCharGetUnicodePropertyDataForPlane(1u, HIWORD(v21) & 0x1F);
      v177 = BYTE2(v21) & 0x1F;
    }
    if (UnicodePropertyDataForPlane)
    {
      v22 = *(unsigned __int8 *)(UnicodePropertyDataForPlane + BYTE1(v21));
      if (v22 >= 0x13)
        v22 = *(unsigned __int8 *)(UnicodePropertyDataForPlane + (v22 << 8) - 4864 + v21 + 256);
    }
    else
    {
      v22 = 1;
    }
    v23 = v22 == 13;
    v24 = v178;
    if (!v23 && v178 != v10)
      goto LABEL_265;
    v25 = v176;
    range = v176 + 1;
    v171 = v176 + 1 - a2;
    if (v9)
      v26 = (void *)(v9 + v171);
    else
      v26 = 0;
    code = U_ZERO_ERROR;
    v27 = v178;
    if (v173 == -1)
    {
      if (v26)
        v27 = v178;
      v25 = v176;
    }
    v172 = v26;
    v223 = 0;
    v180 = v27 + a2;
    v174 = v27 + a2 - 1;
    v175 = UnicodePropertyDataForPlane;
    memset(v222, 0, sizeof(v222));
    memset(v221, 0, sizeof(v221));
    v220 = -1;
    v219[0] = -1;
    v219[1] = -1;
    v218 = -1;
    v217[1] = -1;
    v217[0] = -1;
    inRange = v174 - v25;
    if (v174 - v25 < 1)
    {
      v186 = 0;
      v181 = 0;
      v119 = 0;
      v36 = (void **)v221;
      ptrb = v222;
      goto LABEL_187;
    }
    v32 = 0;
    v33 = 0;
    v191 = 0;
    v181 = 0;
    v186 = 0;
    v34 = 0;
    v35 = v222;
    v36 = (void **)v221;
    v185 = 10;
    v37 = v176 + 1;
    do
    {
      range_8 = v36;
      ptr = v35;
      v215[0] = -1;
      v215[1] = -1;
      v216 = -1;
      if (v32 && (v34 & 1) != 0)
        CFRelease(v32);
      longestEffectiveRange.location = 0;
      longestEffectiveRange.length = 0;
      loc = v37;
      v229.location = v176 + 1;
      v229.length = inRange;
      AttributeAndLongestEffectiveRange = CFAttributedStringGetAttributeAndLongestEffectiveRange(a1, v37, CFSTR("NSLink"), v229, &longestEffectiveRange);
      v39 = longestEffectiveRange.length + longestEffectiveRange.location;
      if (!AttributeAndLongestEffectiveRange)
        goto LABEL_75;
      numChars = v39 - v37;
      if (v39 - v37 < 1)
        goto LABEL_74;
      v40 = v37 - v211;
      v41 = loc - v211 + numChars;
      v42 = v211 - loc;
      v43 = loc - v211 + 64;
      v44 = loc - v211;
      while (1)
      {
        if ((unint64_t)v44 >= 4)
          v45 = 4;
        else
          v45 = v44;
        if (v44 < 0 || (v46 = v212, v212 <= v44))
        {
          v48 = 0;
          v47 = 0;
          goto LABEL_66;
        }
        if (CharactersPtr)
        {
          v47 = CharactersPtr[v44 + v211];
        }
        else if (v210)
        {
          v47 = v210[v211 + v44];
        }
        else
        {
          if (v214 <= v44 || (v49 = v213, v213 > v44))
          {
            v50 = v45 + v42;
            v51 = v43 - v45;
            v52 = v44 - v45;
            v53 = v52 + 64;
            if (v52 + 64 >= v212)
              v53 = v212;
            v213 = v52;
            v214 = v53;
            if (v212 >= v51)
              v46 = v51;
            v225.length = v46 + v50;
            v225.location = v52 + v211;
            CFStringGetCharacters(theString, v225, buffer);
            v49 = v213;
          }
          v47 = buffer[v44 - v49];
        }
        v48 = v47;
        if (v47 > 0x7Fu)
          break;
LABEL_66:
        v54 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v48 + 60);
        if ((v54 & 0x4000) != 0)
          goto LABEL_75;
        if (v48 > 0x7F)
        {
          if (__maskrune(v48, 0x500uLL))
            goto LABEL_73;
        }
        else if ((v54 & 0x500) != 0)
        {
          goto LABEL_73;
        }
        if (v47 > 0x2Eu || ((1 << v47) & 0x680000000000) == 0)
          break;
LABEL_73:
        ++v44;
        --v42;
        ++v43;
        if (v44 >= v41)
          goto LABEL_74;
      }
      if ((v40 & 0x8000000000000000) == 0 && v41 <= v212)
      {
        if (CharactersPtr)
        {
          v83 = (UniChar *)&CharactersPtr[v211 + v40];
        }
        else
        {
          if (numChars > 64)
            goto LABEL_131;
          if (v41 > v214 || (v93 = v213, v40 < v213))
          {
            v94 = v40 + 64;
            if (v40 + 64 >= v212)
              v94 = v212;
            v213 = v40;
            v214 = v94;
            v95.location = v211 + v40;
            v95.length = v94 - v40;
            if (v210)
            {
              if (v95.length)
              {
                v96 = &v210[v95.location];
                v97 = buffer;
                do
                {
                  v98 = *v96++;
                  *v97++ = v98;
                  --v95.length;
                }
                while (v95.length);
              }
              v93 = v40;
            }
            else
            {
              CFStringGetCharacters(theString, v95, buffer);
              v93 = v213;
            }
          }
          v83 = &buffer[v40 - v93];
        }
        v102 = CFStringCreateWithCharactersNoCopy(0, v83, numChars, (CFAllocatorRef)&__kCFAllocatorNull);
        if (!v102)
          goto LABEL_75;
        v85 = v102;
        v86 = 0;
LABEL_167:
        v103 = CFURLCreateWithString(0, v85, 0);
        if (!v103)
        {
          CFRelease(v85);
          if ((v86 & 1) != 0)
            goto LABEL_171;
          goto LABEL_75;
        }
        CFRelease(v103);
        CFRelease(v85);
        if (v86)
          CFAllocatorDeallocate(0, v83);
LABEL_74:
        valuePtr = 8;
        values.location = 0;
        values.location = (CFIndex)CFNumberCreate(0, kCFNumberIntType, &valuePtr);
        v34 = 1;
        v32 = CFArrayCreate(0, (const void **)&values, 1, &kCFTypeArrayCallBacks);
        CFRelease((CFTypeRef)values.location);
        if (!v32)
          goto LABEL_75;
        goto LABEL_78;
      }
LABEL_131:
      Typed = (UniChar *)CFAllocatorAllocateTyped(0, 2 * numChars, 0x1000040BDFB0063, 0);
      v83 = Typed;
      if (CharactersPtr)
      {
        memmove(Typed, &CharactersPtr[v211 + v40], 2 * numChars);
      }
      else
      {
        v87 = v40 - v213;
        if (v40 < v213 || v214 <= v40)
        {
          if (v41 <= v213 || v41 >= v214)
          {
            v91 = v40;
            v90 = Typed;
            v92 = numChars;
          }
          else
          {
            v91 = v40;
            v92 = v213 - v40;
            memmove(&Typed[v213 - v40], buffer, 2 * (v41 - v213));
            v90 = v83;
          }
        }
        else
        {
          v88 = v40;
          if (numChars >= v214 - v40)
            v89 = v214 - v40;
          else
            v89 = numChars;
          memmove(Typed, &buffer[v87], 2 * v89);
          v90 = &v83[v89];
          v91 = v89 + v88;
          v92 = numChars - v89;
        }
        if (v92 >= 1)
        {
          v99.location = v211 + v91;
          if (v210)
          {
            v100 = &v210[v99.location];
            do
            {
              v101 = *v100++;
              *v90++ = v101;
              --v92;
            }
            while (v92);
          }
          else
          {
            v99.length = v92;
            CFStringGetCharacters(theString, v99, v90);
          }
        }
      }
      v84 = CFStringCreateWithCharactersNoCopy(0, v83, numChars, (CFAllocatorRef)&__kCFAllocatorNull);
      if (v84)
      {
        v85 = v84;
        v86 = 1;
        goto LABEL_167;
      }
LABEL_171:
      CFAllocatorDeallocate(0, v83);
LABEL_75:
      values.location = 0;
      values.length = 0;
      v230.location = v176 + 1;
      v230.length = inRange;
      v32 = CFAttributedStringGetAttributeAndLongestEffectiveRange(a1, loc, CFSTR("NSWritingDirection"), v230, &values);
      v34 = 0;
      v55 = values.length + values.location;
      if (v39 < values.length + values.location)
        v55 = v39;
      numChars = v55 - loc;
LABEL_78:
      v56 = v185;
      v35 = ptr;
      if (v186 + 2 <= (int)v185)
      {
        v36 = range_8;
      }
      else
      {
        v179 = (void *)CFAllocatorAllocateTyped(0, 16 * (_DWORD)v185, 0x10040436913F5, 0);
        memcpy(v179, range_8, 8 * (int)v185);
        v35 = (_OWORD *)CFAllocatorAllocateTyped(0, 8 * (_DWORD)v185, 0x100004052888210, 0);
        memcpy(v35, ptr, 4 * (int)v185);
        if ((v181 & 1) != 0)
        {
          CFAllocatorDeallocate(0, range_8);
          CFAllocatorDeallocate(0, ptr);
        }
        v181 = 1;
        v36 = (void **)v179;
        v56 = (2 * v185);
      }
      v185 = v56;
      if (!v32)
      {
        if (v33 >= 1)
        {
          v74 = CFAllocatorAllocateTyped(0, 10, 0x1000040BDFB0063, 0);
          for (i = 0; i != v33; ++i)
          {
            v76 = *((int *)v217 + i);
            if (v76 > 8)
              v77 = 0;
            else
              v77 = *(_WORD *)&aHI[2 * v76 + 4];
            *(_WORD *)(v74 + 2 * i) = v77;
            *((_DWORD *)v217 + i) = -1;
          }
          v78 = (_WORD *)(v74 + 2 * v33);
          v33 = 0;
          v73 = loc;
LABEL_125:
          *v78 = 0;
          v36[v186] = (void *)v74;
          *((_DWORD *)v35 + v186++) = v73 - range;
          goto LABEL_127;
        }
LABEL_116:
        v73 = loc;
        goto LABEL_127;
      }
      ptra = v35;
      Count = CFArrayGetCount((CFArrayRef)v32);
      if (Count < 1)
        goto LABEL_116;
      v58 = Count;
      v183 = v34;
      range_8a = v36;
      v59 = 0;
      v60 = 0;
      v61 = 0;
      v62 = 0;
      while (2)
      {
        LODWORD(values.location) = 0;
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)v32, v59);
        CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &values);
        location = values.location;
        if (LODWORD(values.location) == LODWORD(v219[0]))
        {
          v65 = 0;
LABEL_91:
          if (LODWORD(values.location) == *((_DWORD *)v217 + v65))
          {
            if (v33 >= 1)
            {
              for (j = 0; j < v33; ++j)
              {
                v68 = *((_DWORD *)v217 + j);
                if (location != v68)
                {
                  *((_DWORD *)v215 + v61++) = v68;
                  *((_DWORD *)v217 + j) = -1;
                  --v33;
                }
              }
            }
            goto LABEL_106;
          }
          v69 = 1;
          if (v62)
            goto LABEL_106;
LABEL_101:
          v70 = CFAllocatorAllocateTyped(0, 10, 0x1000040BDFB0063, 0);
          v62 = v70;
          v71 = values.location;
          if (LODWORD(values.location) > 9)
            v72 = 0;
          else
            v72 = *(_WORD *)&aFG[2 * SLODWORD(values.location)];
          *(_WORD *)(v70 + 2 * v60++) = v72;
          *((_DWORD *)v217 + v33++) = v71;
          if ((v69 & 1) == 0)
            *((_DWORD *)v219 + v191++) = v71;
        }
        else
        {
          v65 = 0;
          while (v65 != 3)
          {
            v66 = *((_DWORD *)v219 + ++v65);
            if (LODWORD(values.location) == v66)
              goto LABEL_91;
          }
          v69 = 0;
          if (!v62)
            goto LABEL_101;
        }
LABEL_106:
        if (++v59 != v58)
          continue;
        break;
      }
      if (v62)
      {
        *(_WORD *)(v62 + 2 * v60) = 0;
        v36 = range_8a;
        range_8a[v186] = (void *)v62;
        v35 = ptra;
        v73 = loc;
        *((_DWORD *)ptra + v186++) = loc - range;
      }
      else
      {
        v73 = loc;
        v35 = ptra;
        v36 = range_8a;
      }
      if (v61 >= 1)
      {
        v74 = CFAllocatorAllocateTyped(0, 10, 0x1000040BDFB0063, 0);
        for (k = 0; k != v61; ++k)
        {
          v80 = *((int *)v215 + k);
          if (v80 > 8)
            v81 = 0;
          else
            v81 = *(_WORD *)&aHI[2 * v80 + 4];
          *(_WORD *)(v74 + 2 * k) = v81;
        }
        v78 = (_WORD *)(v74 + 2 * v61);
        v34 = v183;
        goto LABEL_125;
      }
      v34 = v183;
LABEL_127:
      v37 = numChars + v73;
    }
    while (v37 < v180);
    v104 = v34 ^ 1;
    if (!v32)
      v104 = 1;
    if ((v104 & 1) == 0)
      CFRelease(v32);
    ptrb = v35;
    if (v33 < 1)
    {
      v119 = 0;
      v10 = v168;
    }
    else
    {
      v105 = v36;
      v106 = CFAllocatorAllocateTyped(0, 10, 0x1000040BDFB0063, 0);
      v107 = (void *)v106;
      v108 = 0;
      UnicodePropertyDataForPlane = v175;
      do
      {
        v109 = *((int *)v217 + v108);
        if (v109 > 8)
          v110 = 0;
        else
          v110 = *(_WORD *)&aHI[2 * v109 + 4];
        *(_WORD *)(v106 + 2 * v108++) = v110;
      }
      while (v33 != v108);
      *(_WORD *)(v106 + 2 * v33) = 0;
      ubidi_setContext();
      v111 = code;
      if (code >= U_ILLEGAL_ARGUMENT_ERROR)
      {
        u_errorName(code);
        CFLog(3, (uint64_t)CFSTR("ubidi_setContext() failed with errorCode: %d -- %s"), v112, v113, v114, v115, v116, v117, v111);
        v10 = v168;
        v118 = v105;
        LODWORD(v105) = v186;
        goto LABEL_258;
      }
      v119 = v107;
      v10 = v168;
      v36 = v105;
    }
LABEL_187:
    v120 = range - v211;
    if (range - v211 >= 0)
    {
      v121 = v212;
      if (v120 + inRange <= v212)
      {
        if (CharactersPtr)
        {
          v118 = v36;
          v107 = 0;
        }
        else
        {
          if (inRange > 64)
            goto LABEL_189;
          if (v120 + inRange > v214 || v120 < v213)
          {
            if (v120 + 64 < v212)
              v121 = v120 + 64;
            v213 = range - v211;
            v214 = v121;
            v127.length = v121 - v120;
            if (v210)
            {
              if (v127.length)
              {
                v128 = &v210[v176 + 1];
                v129 = buffer;
                do
                {
                  v130 = *v128++;
                  *v129++ = v130;
                  --v127.length;
                }
                while (v127.length);
              }
            }
            else
            {
              v127.location = v176 + 1;
              CFStringGetCharacters(theString, v127, buffer);
            }
          }
          v118 = v36;
          v107 = 0;
        }
        goto LABEL_249;
      }
    }
LABEL_189:
    v118 = v36;
    v122 = (UniChar *)CFAllocatorAllocateTyped(0, 2 * inRange, 0x1000040BDFB0063, 0);
    v123 = v122;
    if (CharactersPtr)
    {
      memmove(v122, &CharactersPtr[v211 + v120], 2 * inRange);
      goto LABEL_191;
    }
    if (v120 < v213 || v214 <= v120)
    {
      if (v120 + inRange <= v213 || v120 + inRange >= v214)
      {
        v125 = v122;
        v126 = inRange;
      }
      else
      {
        v126 = v213 - v120;
        memmove(&v122[v213 - v120], buffer, 2 * (v120 + inRange - v213));
        v125 = v123;
      }
    }
    else
    {
      if (inRange >= v214 - v120)
        v124 = v214 - v120;
      else
        v124 = inRange;
      memmove(v122, &buffer[v120 - v213], 2 * v124);
      v125 = &v123[v124];
      v120 += v124;
      v126 = inRange - v124;
    }
    if (v126 < 1)
      goto LABEL_191;
    v137.location = v211 + v120;
    if (!v210)
    {
      v137.length = v126;
      CFStringGetCharacters(theString, v137, v125);
LABEL_191:
      v107 = v123;
LABEL_249:
      UnicodePropertyDataForPlane = v175;
      goto LABEL_250;
    }
    v138 = &v210[v137.location];
    UnicodePropertyDataForPlane = v175;
    do
    {
      v139 = *v138++;
      *v125++ = v139;
      --v126;
    }
    while (v126);
    v107 = v123;
LABEL_250:
    code = U_ZERO_ERROR;
    ubidi_setParaWithControls();
    if (v119)
      CFAllocatorDeallocate(0, v119);
    v142 = code;
    if (code >= U_ILLEGAL_ARGUMENT_ERROR)
    {
      u_errorName(code);
      CFLog(3, (uint64_t)CFSTR("ubidi_setParaWithControls() failed with errorCode: %d -- %s"), v143, v144, v145, v146, v147, v148, v142);
      goto LABEL_256;
    }
    Levels = (const void *)ubidi_getLevels();
    v150 = code;
    if (code < U_ILLEGAL_ARGUMENT_ERROR)
    {
      if (Levels)
        memcpy(&v167[v171], Levels, inRange);
      LODWORD(v105) = v186;
      if (v172)
      {
        ParaLevel = ubidi_getParaLevel();
        memset(v172, ParaLevel, inRange);
      }
    }
    else
    {
      u_errorName(code);
      CFLog(3, (uint64_t)CFSTR("ubidi_getLevels() failed with errorCode: %d -- %s"), v151, v152, v153, v154, v155, v156, v150);
LABEL_256:
      LODWORD(v105) = v186;
    }
    if (v107)
LABEL_258:
      CFAllocatorDeallocate(0, v107);
    if ((int)v105 >= 1)
    {
      v105 = (void **)v105;
      v157 = v118;
      do
      {
        v158 = *v157++;
        CFAllocatorDeallocate(0, v158);
        v105 = (void **)((char *)v105 - 1);
      }
      while (v105);
    }
    a2 = v169;
    if ((v181 & 1) != 0)
    {
      CFAllocatorDeallocate(0, v118);
      CFAllocatorDeallocate(0, ptrb);
    }
    v176 = v174;
    v24 = v178;
    v9 = v170;
LABEL_265:
    v15 = v24;
  }
  while (v24 < v10);
  ubidi_close();
  if ((*v167 & 1) != 0)
    return 1;
  v162 = 1;
  do
  {
    v163 = v162;
    if (v10 == v162)
      break;
    v164 = v167[v162++];
  }
  while ((v164 & 1) == 0);
  return v163 < v10;
}

CFStringRef CFAttributedStringGetString(CFAttributedStringRef aStr)
{
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    return (CFStringRef)-[__CFAttributedString string](aStr, "string");
  else
    return (CFStringRef)*((_QWORD *)aStr + 2);
}

CFTypeRef CFAttributedStringGetAttributeAndLongestEffectiveRange(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange inRange, CFRange *longestEffectiveRange)
{
  CFIndex length;
  CFIndex location;
  CFTypeRef Attribute;
  CFIndex v13;
  CFIndex v14;
  CFTypeRef v15;
  CFIndex v16;
  CFTypeRef v17;
  CFIndex v18;
  CFIndex v19;
  CFRange v20;
  uint64_t v21;

  length = inRange.length;
  location = inRange.location;
  v21 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    return (CFTypeRef)-[__CFAttributedString attribute:atIndex:longestEffectiveRange:inRange:](aStr, "attribute:atIndex:longestEffectiveRange:inRange:", attrName, loc, longestEffectiveRange, location, length);
  Attribute = CFAttributedStringGetAttribute(aStr, loc, attrName, longestEffectiveRange);
  if (longestEffectiveRange)
  {
    v20 = *longestEffectiveRange;
    v13 = location + length;
    do
    {
      v14 = v20.length + v20.location;
      if (v20.length + v20.location >= v13)
        break;
      v15 = CFAttributedStringGetAttribute(aStr, v20.length + v20.location, attrName, &v20);
    }
    while (v15 == Attribute || v15 && Attribute && CFEqual(v15, Attribute));
    v20 = *longestEffectiveRange;
    do
    {
      v16 = v20.location;
      if (v20.location <= location)
        break;
      v17 = CFAttributedStringGetAttribute(aStr, v20.location - 1, attrName, &v20);
    }
    while (v17 == Attribute || v17 && Attribute && CFEqual(v17, Attribute));
    if (v16 <= location)
      v18 = location;
    else
      v18 = v16;
    if (v13 >= v14)
      v19 = v14;
    else
      v19 = v13;
    longestEffectiveRange->location = v18;
    longestEffectiveRange->length = v19 - v18;
  }
  return Attribute;
}

uint64_t __CFStringValidateFormatSpec(const __CFString *a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v6;
  const __CFAllocator *v7;
  CFIndex Length;
  _QWORD *v9;
  _BYTE *v10;
  int FormatSpecifiersInString;
  int v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  _QWORD *v17;
  _BYTE *v18;
  void *ptr;
  UniChar *v20;
  unsigned __int8 *v21;
  uint64_t v22;
  _OWORD v23[30];
  uint64_t v24;
  _BYTE v25[1952];
  UniChar v26[400];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v6 = _CFGetTSD(1u);
  if (v6)
    v7 = (const __CFAllocator *)v6;
  else
    v7 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  v21 = 0;
  v22 = 0;
  ptr = 0;
  v20 = 0;
  v17 = 0;
  v18 = 0;
  v24 = 0;
  memset(v23, 0, sizeof(v23));
  Length = CFStringGetLength(a1);
  __CFStringSetUpFormatAndSpecBuffers((uint64_t)a1, Length, &v21, &v20, (UniChar **)&ptr, v26, (uint64_t *)&v18, (uint64_t)v25, (uint64_t *)&v17, (uint64_t)v23);
  v9 = v17;
  v10 = v18;
  FormatSpecifiersInString = __CFStringFindFormatSpecifiersInString((uint64_t)v21, (uint64_t)v20, Length, (uint64_t)v18, (uint64_t)v17, &v22);
  v12 = __CFStringValidateFormatSpecBuffers(a2, 1, 1, (uint64_t)v10, FormatSpecifiersInString, v22, a3);
  if (ptr && ptr != v26)
    CFAllocatorDeallocate(v7, ptr);
  if (v10 != v25)
    CFAllocatorDeallocate(v7, v10);
  v13 = v22;
  if (v22 >= 1)
  {
    v14 = 0;
    do
    {
      v15 = (const void *)v9[v14];
      if (v15)
      {
        CFRelease(v15);
        v13 = v22;
      }
      ++v14;
    }
    while (v14 < v13);
  }
  if (v9 != (_QWORD *)v23)
    CFAllocatorDeallocate(v7, v9);
  if (v12)
    return a3 + 1;
  else
    return -1;
}

uint64_t __CFStringValidateFormat(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  CFErrorRef *v3;
  uint64_t v4;
  uint64_t v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;
  uint64_t v9;
  const __CFAllocator *v10;
  CFIndex Length;
  CFIndex v12;
  unsigned __int16 *v13;
  _QWORD *v14;
  int FormatSpecifiersInString;
  _BYTE *v16;
  _QWORD *v17;
  int v18;
  int v19;
  int v20;
  CFStringRef v21;
  __CFDictionary *Mutable;
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  uint64_t v26;
  uint64_t v27;
  const void *v28;
  CFErrorRef *v30;
  _QWORD *v31;
  _QWORD *v32;
  _BYTE *v33;
  unsigned __int16 *v34;
  void *v35;
  void *ptr;
  UniChar *v37;
  unsigned __int8 *v38;
  UniChar *v39;
  unsigned __int8 *v40;
  uint64_t v41;
  uint64_t v42;
  _OWORD v43[30];
  uint64_t v44;
  _OWORD v45[30];
  uint64_t v46;
  _BYTE v47[1952];
  _BYTE v48[1952];
  UniChar v49[400];
  UniChar v50[400];
  uint64_t v51;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v30 = v3;
  v5 = v4;
  v7 = v6;
  v8 = (const __CFString *)v2;
  v51 = *MEMORY[0x1E0C80C00];
  v41 = 0;
  v42 = 0;
  v9 = _CFGetTSD(1u);
  if (v9)
    v10 = (const __CFAllocator *)v9;
  else
    v10 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  v39 = 0;
  v40 = 0;
  v37 = 0;
  v38 = 0;
  v35 = 0;
  ptr = 0;
  v33 = 0;
  v34 = 0;
  v31 = 0;
  v32 = 0;
  v46 = 0;
  memset(v45, 0, sizeof(v45));
  v44 = 0;
  memset(v43, 0, sizeof(v43));
  Length = CFStringGetLength(v7);
  __CFStringSetUpFormatAndSpecBuffers((uint64_t)v7, Length, &v40, &v39, (UniChar **)&ptr, v50, (uint64_t *)&v34, (uint64_t)v48, (uint64_t *)&v32, (uint64_t)v45);
  v12 = CFStringGetLength(v8);
  __CFStringSetUpFormatAndSpecBuffers((uint64_t)v8, v12, &v38, &v37, (UniChar **)&v35, v49, (uint64_t *)&v33, (uint64_t)v47, (uint64_t *)&v31, (uint64_t)v43);
  v13 = v34;
  v14 = v32;
  FormatSpecifiersInString = __CFStringFindFormatSpecifiersInString((uint64_t)v40, (uint64_t)v39, Length, (uint64_t)v34, (uint64_t)v32, &v42);
  v16 = v33;
  v17 = v31;
  v18 = __CFStringFindFormatSpecifiersInString((uint64_t)v38, (uint64_t)v37, v12, (uint64_t)v33, (uint64_t)v31, &v41);
  v19 = __CFStringValidateFormatSpecBuffers(v13, FormatSpecifiersInString, v42, (uint64_t)v16, v18, v41, v5);
  v20 = v19;
  if (v30 && (v19 & 1) == 0)
  {
    v21 = CFStringCreateWithFormat(v10, 0, CFSTR("Format '%@' does not match expected '%@'"), v7, v8);
    Mutable = CFDictionaryCreateMutable(v10, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(Mutable, CFSTR("NSDebugDescription"), v21);
    *v30 = CFErrorCreate(v10, CFSTR("NSCocoaErrorDomain"), 2048, Mutable);
    CFRelease(Mutable);
    CFRelease(v21);
  }
  if (ptr && ptr != v50)
    CFAllocatorDeallocate(v10, ptr);
  if (v35 && v35 != v49)
    CFAllocatorDeallocate(v10, v35);
  if (v13 != (unsigned __int16 *)v48)
    CFAllocatorDeallocate(v10, v13);
  if (v16 != v47)
    CFAllocatorDeallocate(v10, v16);
  v23 = v42;
  if (v42 >= 1)
  {
    v24 = 0;
    do
    {
      v25 = (const void *)v14[v24];
      if (v25)
      {
        CFRelease(v25);
        v23 = v42;
      }
      ++v24;
    }
    while (v24 < v23);
  }
  v26 = v41;
  if (v41 >= 1)
  {
    v27 = 0;
    do
    {
      v28 = (const void *)v17[v27];
      if (v28)
      {
        CFRelease(v28);
        v26 = v41;
      }
      ++v27;
    }
    while (v27 < v26);
  }
  if (v14 != (_QWORD *)v45)
    CFAllocatorDeallocate(v10, v14);
  if (v17 != (_QWORD *)v43)
    CFAllocatorDeallocate(v10, v17);
  if (v20)
    return v5 + FormatSpecifiersInString;
  else
    return -1;
}

void __CFStringSetUpFormatAndSpecBuffers(uint64_t a1, CFIndex a2, unsigned __int8 **a3, UniChar **a4, UniChar **a5, UniChar *a6, uint64_t *a7, uint64_t a8, uint64_t *a9, uint64_t a10)
{
  uint64_t v18;
  __objc2_class **v19;
  char v20;
  char v21;
  uint64_t v22;
  UniChar **v23;
  UniChar *v24;
  UniChar *v25;
  uint64_t v26;
  unint64_t v27;
  unsigned __int8 *v28;
  uint64_t v29;
  int v30;
  int v31;
  unsigned __int16 *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  uint64_t Typed;
  __objc2_class **v41;
  CFRange v42;

  v18 = _CFGetTSD(1u);
  v19 = &__kCFAllocatorSystemDefault;
  if (v18)
    v19 = (__objc2_class **)v18;
  v41 = v19;
  if (!CF_IS_OBJC(7uLL, (__objc2_class **)a1))
  {
    v20 = atomic_load((unint64_t *)(a1 + 8));
    v21 = atomic_load((unint64_t *)(a1 + 8));
    v22 = v21 & 0x60;
    v23 = (UniChar **)(a1 + 16);
    if ((v20 & 0x10) == 0)
    {
      if (v22)
      {
        v24 = *v23;
      }
      else
      {
        v26 = atomic_load((unint64_t *)(a1 + 8));
        v24 = (UniChar *)&v23[(v26 & 5) != 4];
      }
      *a3 = (unsigned __int8 *)v24;
      if (v24)
      {
        v27 = atomic_load((unint64_t *)(a1 + 8));
        v28 = &(*a3)[(v27 >> 2) & 1];
        *a3 = v28;
        if (v28)
          goto LABEL_16;
      }
      goto LABEL_22;
    }
    if (v22)
    {
      v25 = *v23;
    }
    else
    {
      v29 = atomic_load((unint64_t *)(a1 + 8));
      v25 = (UniChar *)&v23[(v29 & 5) != 4];
    }
    *a4 = v25;
  }
  v28 = *a3;
  if (*a3)
    goto LABEL_16;
LABEL_22:
  if (*a4)
    goto LABEL_23;
  if (a2 <= 400)
  {
    *a5 = a6;
  }
  else
  {
    Typed = CFAllocatorAllocateTyped(v41, 2 * a2, 0x1000040BDFB0063, 0);
    *a5 = (UniChar *)Typed;
    if ((UniChar *)Typed == a6 || __CFOASafe == 0)
    {
      a6 = (UniChar *)Typed;
    }
    else
    {
      __CFSetLastAllocationEventName();
      a6 = *a5;
    }
  }
  v42.location = 0;
  v42.length = a2;
  CFStringGetCharacters((CFStringRef)a1, v42, a6);
  *a4 = *a5;
  v28 = *a3;
  if (!*a3)
  {
LABEL_23:
    if (a2 >= 1)
    {
      v30 = 0;
      v32 = *a4;
      do
      {
        v33 = *v32++;
        if (v33 == 37)
          ++v30;
        --a2;
      }
      while (a2);
      goto LABEL_28;
    }
LABEL_39:
    *a7 = a8;
    *a9 = a10;
    return;
  }
LABEL_16:
  if (a2 < 1)
    goto LABEL_39;
  v30 = 0;
  do
  {
    v31 = *v28++;
    if (v31 == 37)
      ++v30;
    --a2;
  }
  while (a2);
LABEL_28:
  v34 = (2 * v30) | 1u;
  if ((int)v34 < 62)
    goto LABEL_39;
  v35 = CFAllocatorAllocateTyped(v41, 32 * ((2 * v30) | 1u), 0x10000408E5DAE1CLL, 0);
  *a7 = v35;
  if (v35 != a8 && __CFOASafe != 0)
    __CFSetLastAllocationEventName();
  v37 = CFAllocatorAllocateTyped(v41, 8 * v34, 0x6004044C4A2DFLL, 0);
  *a9 = v37;
  if (v37 != a10 && __CFOASafe != 0)
    __CFSetLastAllocationEventName();
}

uint64_t __CFStringFindFormatSpecifiersInString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  _DWORD *v16;
  _BYTE *v17;
  int v18;
  __int16 *v19;
  unsigned int v20;
  char v21;
  int v22;
  int v23;
  int v24;
  _DWORD *v25;
  uint64_t v26;
  unsigned __int8 v27;
  unsigned __int8 v28;
  unsigned int v29;
  BOOL v31;
  _BOOL4 v32;
  _DWORD *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  unsigned __int16 *v38;
  unsigned __int8 *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  __int16 v44;
  int v45;
  int v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  int v50;
  _QWORD *v51;
  char v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  unsigned int v58;
  int v59;
  uint64_t v60;
  BOOL v61;
  uint64_t v62;
  int v63;
  uint64_t v64;
  size_t v65;
  CFTypeRef v66;
  uint64_t v67;
  __int16 v68;
  __int16 v69;
  __int16 v70;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  _BYTE *v75;
  _DWORD *v76;
  int v77;
  uint64_t v78;
  int v79;
  _DWORD *v80;
  __int16 *v81;
  int8x16_t __s;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  if (a3 >= 1)
  {
    LODWORD(v9) = 0;
    LODWORD(v10) = 0;
    if (a5)
      v11 = a6 == 0;
    else
      v11 = 1;
    v12 = !v11;
    v13 = xmmword_182C98E20;
    v78 = a4;
    v77 = v12;
    while (1)
    {
      v14 = a4 + 32 * (int)v10;
      *(_DWORD *)(v14 + 4) = v9;
      v15 = (int *)(v14 + 4);
      *(_OWORD *)(v14 + 8) = v13;
      v16 = (_DWORD *)(v14 + 8);
      *(_DWORD *)v14 = 0;
      v17 = (_BYTE *)(v14 + 26);
      *(_DWORD *)(v14 + 24) = -1;
      v18 = v9;
      v9 = (int)v9;
      if (a1)
      {
        if ((int)v9 < a3)
        {
          do
          {
            if (*(_BYTE *)(a1 + v9) == 37)
              break;
            ++v9;
          }
          while (v9 < a3);
          goto LABEL_17;
        }
      }
      else if ((int)v9 < a3)
      {
        do
        {
          if (*(_WORD *)(a2 + 2 * v9) == 37)
            break;
          ++v9;
        }
        while (v9 < a3);
LABEL_17:
        if (v18 != (_DWORD)v9)
        {
          LODWORD(v10) = v10 + (~(_DWORD)v10 >> 31);
          goto LABEL_124;
        }
      }
      v19 = (__int16 *)(v14 + 2);
      LODWORD(v9) = v18 + 1;
      if (v18 + 1 >= (int)a3)
        goto LABEL_117;
      v20 = 0;
      v21 = 0;
      v22 = 0;
      v23 = 0;
      v24 = 0;
      v76 = (_DWORD *)(v14 + 20);
      v25 = (_DWORD *)(v14 + 16);
      v75 = (_BYTE *)(v14 + 25);
      v26 = -1;
      v27 = -1;
      v28 = -1;
      v80 = (_DWORD *)(v14 + 16);
LABEL_20:
      if (a1)
        v29 = *(unsigned __int8 *)(a1 + (int)v9);
      else
        v29 = *(unsigned __int16 *)(a2 + 2 * (int)v9);
      LODWORD(v9) = v9 + 1;
      if (v26 < 0)
      {
        v81 = v19;
        while (2)
        {
          if (v24)
            v34 = v25;
          else
            v34 = (_DWORD *)(v14 + 12);
          v79 = v24;
          while (2)
          {
            if (v29 - 49 < 9)
            {
              v35 = 0;
              if ((int)v9 <= (int)a3)
                v36 = a3;
              else
                v36 = v9;
              v37 = v36 - (uint64_t)(int)v9;
              v38 = (unsigned __int16 *)(a2 + 2 * (int)v9);
              v39 = (unsigned __int8 *)(a1 + (int)v9);
              do
              {
                v40 = (unsigned __int128)(v35 * (__int128)10) >> 64;
                v41 = 10 * v35;
                if (v40 != v41 >> 63)
                  goto LABEL_120;
                v42 = v29 - 48;
                v43 = __OFADD__(v41, v42);
                v35 = v41 + v42;
                if (v43)
                  goto LABEL_120;
                if (!v37)
                {
                  *v81 = 43;
                  LODWORD(v9) = v36;
                  goto LABEL_120;
                }
                if (a1)
                  v29 = *v39;
                else
                  v29 = *v38;
                LODWORD(v9) = v9 + 1;
                --v37;
                ++v38;
                ++v39;
              }
              while (v29 - 48 < 0xA);
              if (v29 == 36)
              {
                v25 = (_DWORD *)(v14 + 16);
                v24 = v79;
                if (v35 <= 127)
                {
                  a4 = v78;
                  if (v28 == 254)
                  {
                    v28 = v35 - 1;
                    *v75 = v35 - 1;
                  }
                  else if (v27 == 254)
                  {
                    *v17 = v35 - 1;
                    v27 = v35 - 1;
                  }
                  else
                  {
                    *(_BYTE *)(v14 + 24) = v35 - 1;
                  }
LABEL_115:
                  v12 = v77;
                  goto LABEL_116;
                }
                a4 = v78;
                v12 = v77;
              }
              else
              {
                v25 = (_DWORD *)(v14 + 16);
                v24 = v79;
                if (v35 <= 0x7FFFFFFF)
                {
                  *v34 = v35;
                  continue;
                }
LABEL_120:
                a4 = v78;
LABEL_121:
                v12 = v77;
              }
              goto LABEL_122;
            }
            break;
          }
          switch(v29)
          {
            case ' ':
              a4 = v78;
              if ((v20 & 4) == 0)
              {
                v20 |= 8u;
                *v76 = v20;
              }
              goto LABEL_94;
            case '#':
              v23 = 1;
              goto LABEL_93;
            case '*':
              v27 = -2;
              *v17 = -2;
              goto LABEL_93;
            case '+':
              v20 = v20 & 0xFFFFFFF3 | 4;
              goto LABEL_86;
            case '-':
              v20 = v20 & 0xFFFFFFFC | 2;
LABEL_86:
              *v76 = v20;
              goto LABEL_93;
            case '.':
              a4 = v78;
              if ((int)v9 >= (int)a3)
              {
                *v81 = 43;
                goto LABEL_121;
              }
              if (a1)
                v29 = *(unsigned __int8 *)(a1 + (int)v9);
              else
                v29 = *(unsigned __int16 *)(a2 + 2 * (int)v9);
              LODWORD(v9) = v9 + 1;
              v24 = 1;
              if (v29 != 42)
                continue;
              v28 = -2;
              *v75 = -2;
LABEL_93:
              a4 = v78;
LABEL_94:
              v12 = v77;
LABEL_116:
              v19 = v81;
LABEL_71:
              if ((int)v9 >= (int)a3)
              {
LABEL_117:
                *v19 = 43;
                goto LABEL_122;
              }
              goto LABEL_20;
            case '0':
              a4 = v78;
              if (v24)
              {
                *v25 = 0;
                v24 = 1;
                goto LABEL_94;
              }
              v24 = 0;
              if ((v20 & 2) == 0)
              {
                v20 |= 1u;
                *v76 = v20;
              }
              goto LABEL_115;
            case '@':
              a4 = v78;
              if (v23)
              {
                v23 = 0;
                v26 = (int)v9;
                goto LABEL_94;
              }
              *v81 = 37;
              *(_WORD *)v14 = 4;
              goto LABEL_121;
            case 'A':
            case 'a':
              goto LABEL_135;
            case 'C':
              *v81 = 41;
              v68 = 2;
              goto LABEL_190;
            case 'D':
            case 'U':
            case 'd':
            case 'i':
            case 'u':
              v74 = a5;
              v51 = a6;
              if (_CFExecutableLinkedOnOrAfter(8uLL))
                *v76 |= 0x20u;
              if ((v29 & 0xFFDF) == 0x55)
                v52 = 4;
              else
                v52 = 1;
              *(_BYTE *)(v78 + 32 * (int)v10 + 28) = v52;
              a6 = v51;
              a5 = v74;
              v13 = xmmword_182C98E20;
              goto LABEL_146;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              v72 = a6;
              v73 = a5;
              if (_CFExecutableLinkedOnOrAfter(8uLL))
                *v76 |= 0x20u;
              if (v29 - 65 >= 0x1A)
                v49 = v29;
              else
                v49 = v29 + 32;
              *(_BYTE *)(v78 + 32 * (int)v10 + 28) = ((v49 & 0xFFFE) == 102) | (2 * ((v49 & 0xFFFD) == 101));
              a6 = v72;
              a5 = v73;
              v13 = xmmword_182C98E20;
              if (v79 && *v80 == -1 && *v75 == 255)
                *v80 = 0;
LABEL_135:
              *v81 = 34;
              a4 = v78;
              if (*(_WORD *)v14 != 5)
                *(_WORD *)v14 = 4;
              goto LABEL_148;
            case 'L':
              v44 = 5;
              goto LABEL_74;
            case 'O':
            case 'X':
            case 'o':
            case 'x':
LABEL_146:
              *v81 = 33;
              goto LABEL_147;
            case 'P':
              v69 = 40;
              goto LABEL_189;
            case 'S':
              v69 = 38;
              goto LABEL_189;
            case '[':
              if (!v22)
                v26 = (int)v9;
              v22 = 1;
              goto LABEL_93;
            case 'c':
              *v81 = 33;
              v70 = 1;
              goto LABEL_187;
            case 'h':
              a4 = v78;
              if ((int)v9 < (int)a3
                && (!a1 ? (v46 = *(unsigned __int16 *)(a2 + 2 * (int)v9)) : (v46 = *(unsigned __int8 *)(a1 + (int)v9)),
                    v46 == 104))
              {
                LODWORD(v9) = v9 + 1;
                v47 = 1;
              }
              else
              {
                v47 = 2;
              }
              goto LABEL_114;
            case 'j':
            case 'q':
            case 't':
            case 'z':
              v44 = 4;
LABEL_74:
              *(_WORD *)v14 = v44;
              goto LABEL_93;
            case 'l':
              a4 = v78;
              if ((int)v9 < (int)a3)
              {
                v45 = a1 ? *(unsigned __int8 *)(a1 + (int)v9) : *(unsigned __int16 *)(a2 + 2 * (int)v9);
                if (v45 == 108)
                  LODWORD(v9) = v9 + 1;
              }
              v47 = 4;
LABEL_114:
              *(_WORD *)v14 = v47;
              goto LABEL_115;
            case 'n':
              v69 = 42;
              goto LABEL_189;
            case 'p':
              *v81 = 35;
              v70 = 4;
LABEL_187:
              *(_WORD *)v14 = v70;
LABEL_147:
              a4 = v78;
LABEL_148:
              v53 = (v9 - v18);
              *v16 = v53;
              v12 = v77;
              if (!v77)
                goto LABEL_124;
              v54 = *v15;
              v55 = a5;
              v56 = a6;
              if (a1)
              {
                if ((int)v53 >= 1)
                {
                  v57 = 0;
                  v58 = 0;
                  while (1)
                  {
                    v59 = *(unsigned __int8 *)(a1 + v57 + v54);
                    if (v59 == 36)
                    {
                      if ((v58 & 0x80000000) == 0)
                      {
                        v60 = v58;
                        while (1)
                        {
                          v61 = v60-- < 1;
                          if (v61)
                            break;
                          if (__s.u8[v60] - 48 >= 0xA)
                            goto LABEL_160;
                        }
                        LODWORD(v60) = -1;
                        goto LABEL_160;
                      }
                    }
                    else
                    {
                      __s.i8[v58] = v59;
                    }
                    LODWORD(v60) = v58;
LABEL_160:
                    v58 = v60 + 1;
                    if (++v57 >= v53 || (int)v60 >= 127)
                      goto LABEL_179;
                  }
                }
LABEL_178:
                v58 = 0;
                goto LABEL_179;
              }
              if ((int)v53 < 1)
                goto LABEL_178;
              v62 = 0;
              v58 = 0;
              break;
            case 's':
              v69 = 39;
LABEL_189:
              *v81 = v69;
              v68 = 4;
LABEL_190:
              *(_WORD *)v14 = v68;
              goto LABEL_120;
            default:
              *v81 = 32;
              LODWORD(v10) = v10 + (~(_DWORD)v10 >> 31);
              a4 = v78;
              v12 = v77;
              goto LABEL_124;
          }
          break;
        }
        while (2)
        {
          v63 = *(unsigned __int16 *)(a2 + 2 * (v62 + v54));
          if (v63 == 36)
          {
            if ((v58 & 0x80000000) == 0)
            {
              v64 = v58;
              while (1)
              {
                v61 = v64-- < 1;
                if (v61)
                  break;
                if (__s.u8[v64] - 48 >= 0xA)
                  goto LABEL_174;
              }
              LODWORD(v64) = -1;
LABEL_174:
              v58 = v64 + 1;
              if (++v62 >= v53 || (int)v64 >= 127)
              {
LABEL_179:
                __s.i8[v58] = 0;
                v65 = strlen(__s.i8);
                v66 = __CFStringCreateImmutableFunnel3(0, &__s, v65, 134217984, 8u, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
                a6 = v56;
                v67 = (*v56)++;
                a5 = v55;
                *(_QWORD *)(v55 + 8 * v67) = v66;
                a4 = v78;
                v12 = v77;
                v13 = xmmword_182C98E20;
                goto LABEL_124;
              }
              continue;
            }
          }
          else
          {
            __s.i8[v58] = v63;
          }
          break;
        }
        LODWORD(v64) = v58;
        goto LABEL_174;
      }
      if (v29 >= 0x30 && v29 - 58 >= 7)
      {
        v31 = v29 == 95 || v29 - 91 >= 6;
        v32 = !v31;
        if (v29 <= 0x7A && !v32)
          goto LABEL_71;
      }
      if (v29 == 93)
      {
        if (v22)
          v21 = 1;
        goto LABEL_71;
      }
      if (v29 != 64)
      {
        v26 = -1;
        goto LABEL_71;
      }
      v50 = v20 | 0x40;
      if (!v21)
        v50 = v20;
      *v76 = v50 | 0x10;
      *v19 = 37;
      *(_WORD *)v14 = 4;
LABEL_122:
      *v16 = v9 - v18;
      if (v12)
      {
        v48 = (*a6)++;
        *(_QWORD *)(a5 + 8 * v48) = 0;
      }
LABEL_124:
      v10 = (v10 + 1);
      if ((int)v9 >= a3)
        return v10;
    }
  }
  return 0;
}

uint64_t __CFStringValidateFormatSpecBuffers(unsigned __int16 *a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  int v8;

  if (a3 > a6 || (v7 = a2, a5 - a7 < a2))
  {
    if (a2)
      return 0;
  }
  else if (a2 >= 1)
  {
    while (1)
    {
      v8 = *((unsigned __int8 *)a1 + 24);
      if (v8 == 255)
        LOBYTE(v8) = a7;
      if (a5 <= (char)v8
        || a1[1] != *(unsigned __int16 *)(a4 + 32 * (char)v8 + 2)
        || *a1 != *(unsigned __int16 *)(a4 + 32 * (char)v8))
      {
        break;
      }
      LOBYTE(a7) = a7 + 1;
      a1 += 16;
      if (!--v7)
        return 1;
    }
    return 0;
  }
  return 1;
}

const __CFString *_CFURLCopyUserName(uint64_t a1, int a2)
{
  const __CFString *v4;
  char v5;
  const void *v6;
  const void *v7;

  while (1)
  {
    if (!a1)
      _CFURLCopyUserName_cold_1();
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1))
      break;
    v4 = _retainedComponentString(a1, 2, 1, a2);
    if (v4)
      return v4;
    if (*(_QWORD *)(a1 + 32))
    {
      v5 = *(_BYTE *)(a1 + 16);
      a1 = *(_QWORD *)(a1 + 32);
      if ((v5 & 0x1F) == 0)
        continue;
    }
    return 0;
  }
  v7 = (const void *)objc_msgSend((id)a1, "user");
  v6 = v7;
  if (v7)
    CFRetain(v7);
  return (const __CFString *)v6;
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromComponents(CFAllocatorRef allocator, CFDictionaryRef dictionary)
{
  CFIndex Count;
  uint64_t v4;
  unint64_t v5;
  const void **v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  const __CFString **v10;
  UInt8 *v11;
  CFTypeRef *v12;
  CFIndex v13;
  const __CFString **v14;
  const char *v16;
  const char *v17;
  const char *v18;
  void *v19;
  UInt8 *v20;
  const char *v21;
  const char *v22;
  void *v23;
  const char *v24;
  const char *v25;
  UInt8 *v26;
  int v27;
  __CFString *v28;
  UInt8 *v29;
  const __CFString *Identifier;
  char *v31;
  CFTypeRef v32[2];
  CFAllocatorRef v33;
  UInt8 *v34;
  const __CFString *v35;
  UInt8 *v36;
  UInt8 *v37;
  int v38;
  char *v39;
  char v40[514];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!dictionary)
    return 0;
  v33 = allocator;
  Count = CFDictionaryGetCount(dictionary);
  v32[1] = v32;
  MEMORY[0x1E0C80A78](Count, v4);
  v5 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
  v6 = (CFTypeRef *)((char *)v32 - v5);
  if ((unint64_t)(8 * Count) >= 0x200)
    v7 = 512;
  else
    v7 = 8 * Count;
  bzero((char *)v32 - v5, v7);
  MEMORY[0x1E0C80A78](v8, v9);
  v10 = (const __CFString **)((char *)v32 - v5);
  bzero(v10, v7);
  CFDictionaryGetKeysAndValues(dictionary, (const void **)v10, v6);
  if (Count >= 1)
  {
    v11 = 0;
    v34 = 0;
    v36 = 0;
    v37 = 0;
    v35 = CFSTR("kCFLocaleCountryCodeKey");
    v32[0] = CFSTR("kCFLocaleVariantCodeKey");
    v12 = (CFTypeRef *)v10;
    v13 = Count;
    v14 = (const __CFString **)v6;
    while (!CFEqual(CFSTR("kCFLocaleLanguageCodeKey"), *v12))
    {
      if (CFEqual(CFSTR("kCFLocaleScriptCodeKey"), *v12))
      {
        v37 = __CStringFromString(*v14);
        goto LABEL_15;
      }
      if (CFEqual(v35, *v12))
      {
        v36 = __CStringFromString(*v14);
        goto LABEL_15;
      }
      if (CFEqual(v32[0], *v12))
      {
        v34 = __CStringFromString(*v14);
        goto LABEL_15;
      }
LABEL_16:
      ++v14;
      ++v12;
      if (!--v13)
        goto LABEL_20;
    }
    v11 = __CStringFromString(*v14);
LABEL_15:
    *v12 = 0;
    goto LABEL_16;
  }
  v36 = 0;
  v37 = 0;
  v34 = 0;
  v11 = 0;
LABEL_20:
  v39 = 0;
  v16 = "";
  v17 = "_";
  if (v11)
    v18 = (const char *)v11;
  else
    v18 = "";
  v19 = v36;
  v20 = v37;
  if (v37)
    v21 = "_";
  else
    v21 = "";
  if (v37)
    v22 = (const char *)v37;
  else
    v22 = "";
  v23 = v34;
  if ((unint64_t)v36 | (unint64_t)v34)
    v24 = "_";
  else
    v24 = "";
  if (v36)
    v25 = (const char *)v36;
  else
    v25 = "";
  if (v34)
    v16 = (const char *)v34;
  else
    v17 = "";
  asprintf(&v39, "%s%s%s%s%s%s%s", v18, v21, v22, v24, v25, v17, v16);
  __strlcpy_chk();
  free(v11);
  free(v20);
  free(v19);
  free(v23);
  free(v39);
  if (Count >= 1)
  {
    do
    {
      if (*v10)
      {
        v26 = __CStringFromString(*v10);
        v27 = strcmp((const char *)v26, "kCFLocaleCalendarKey");
        v28 = (__CFString *)*v6;
        if (v27)
        {
          v29 = __CStringFromString(v28);
        }
        else
        {
          Identifier = CFCalendarGetIdentifier((CFCalendarRef)v28);
          v29 = __CStringFromString(Identifier);
          v31 = strdup("calendar");
          free(v26);
          v26 = (UInt8 *)v31;
        }
        v38 = 0;
        uloc_setKeywordValue();
        free(v26);
        free(v29);
      }
      ++v6;
      ++v10;
      --Count;
    }
    while (Count);
  }
  return CFStringCreateWithCString(v33, v40, 0x600u);
}

UInt8 *__CStringFromString(const __CFString *a1)
{
  CFIndex Length;
  UInt8 *v3;
  CFIndex maxBufLen[2];
  CFRange v6;
  CFRange v7;

  maxBufLen[1] = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  Length = CFStringGetLength(a1);
  maxBufLen[0] = 0;
  v6.location = 0;
  v6.length = Length;
  CFStringGetBytes(a1, v6, 0x600u, 0x3Fu, 0, 0, 0, maxBufLen);
  v3 = (UInt8 *)malloc_type_malloc(maxBufLen[0] + 1, 0x449D2309uLL);
  v7.location = 0;
  v7.length = Length;
  CFStringGetBytes(a1, v7, 0x600u, 0x3Fu, 0, v3, maxBufLen[0], maxBufLen);
  v3[maxBufLen[0]] = 0;
  return v3;
}

const __CFString *_CFURLCopyPassword(uint64_t a1, int a2)
{
  const __CFString *v4;
  char v5;
  const void *v6;
  const void *v7;

  while (1)
  {
    if (!a1)
      _CFURLCopyPassword_cold_1();
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1))
      break;
    v4 = _retainedComponentString(a1, 4, 1, a2);
    if (v4)
      return v4;
    if (*(_QWORD *)(a1 + 32))
    {
      v5 = *(_BYTE *)(a1 + 16);
      a1 = *(_QWORD *)(a1 + 32);
      if ((v5 & 0x1F) == 0)
        continue;
    }
    return 0;
  }
  v7 = (const void *)objc_msgSend((id)a1, "password");
  v6 = v7;
  if (v7)
    CFRetain(v7);
  return (const __CFString *)v6;
}

uint64_t CFBurstTrieCursorGetPayload(uint64_t a1, _DWORD *a2)
{
  int v2;

  if (*(_QWORD *)(a1 + 17) != 1)
    return 0;
  v2 = *(_DWORD *)(a1 + 12);
  if (!v2)
    return 0;
  if (a2)
    *a2 = v2;
  return 1;
}

BOOL _CFOperatingSystemVersionIsAtLeastVersion(_QWORD *a1)
{
  uint64_t v3;

  if (_CFOperatingSystemVersionGetCurrent_onceToken != -1)
    dispatch_once(&_CFOperatingSystemVersionGetCurrent_onceToken, &__block_literal_global_32);
  if ((uint64_t)_CFOperatingSystemVersionGetCurrent_version < *a1)
    return 0;
  if ((uint64_t)_CFOperatingSystemVersionGetCurrent_version > *a1)
    return 1;
  v3 = a1[1];
  if (*((uint64_t *)&_CFOperatingSystemVersionGetCurrent_version + 1) < v3)
    return 0;
  if (*((uint64_t *)&_CFOperatingSystemVersionGetCurrent_version + 1) > v3)
    return 1;
  return qword_1ECCFA450 >= a1[2];
}

objc_class *__NSOrderedSetParameterCheckIterate(objc_class *result, const char *a2, uint64_t a3, uint64_t a4, void *a5)
{
  objc_class *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  NSException *v14;
  objc_class *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  NSException *v19;
  const char *v20;
  const char *v21;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  if ((a4 & 0x1000000000000000) != 0)
  {
    v6 = result;
    if (!a5)
    {
      v13 = __CFExceptionProem(result, a2);
      CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@: index set is nil"), v13);
      v14 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
      objc_exception_throw(v14);
    }
    v7 = objc_msgSend(a5, "lastIndex");
    result = (objc_class *)-[objc_class count](v6, "count");
    if ((v7 & 0x8000000000000000) != 0 || v7 != 0x7FFFFFFFFFFFFFFFLL && (unint64_t)result <= v7)
    {
      if (result)
      {
        v15 = result;
        v8 = _os_log_pack_size();
        v10 = (char *)v22 - ((MEMORY[0x1E0C80A78](v8, v16) + 15) & 0xFFFFFFFFFFFFFFF0);
        v17 = _os_log_pack_fill();
        v18 = PROEM_SEL_1(a2);
        v15 = (objc_class *)((char *)v15 - 1);
        __os_log_helper_1_2_4_8_32_8_32_8_0_8_0(v17, (uint64_t)"NSOrderedSet", (uint64_t)v18, v7, (uint64_t)v15);
        v21 = PROEM_SEL_1(a2);
        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** -[%s %s]: index %lu beyond bounds [0 .. %lu]"), "NSOrderedSet", v21, v7, v15);
      }
      else
      {
        v8 = _os_log_pack_size();
        v10 = (char *)v22 - ((MEMORY[0x1E0C80A78](v8, v9) + 15) & 0xFFFFFFFFFFFFFFF0);
        v11 = _os_log_pack_fill();
        v12 = PROEM_SEL_1(a2);
        __os_log_helper_1_2_3_8_32_8_32_8_0(v11, (uint64_t)"NSOrderedSet", (uint64_t)v12, v7);
        v20 = PROEM_SEL_1(a2);
        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** -[%s %s]: index %lu beyond bounds for empty array"), "NSOrderedSet", v20, v7);
      }
      v19 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:](NSException, "exceptionWithName:reason:userInfo:osLogPack:size:", CFSTR("NSRangeException"), _CFAutoreleasePoolAddObject(), 0, v10, v8);
      objc_exception_throw(v19);
    }
  }
  return result;
}

CFArrayRef CFPlugInFindFactoriesForPlugInTypeInPlugIn(CFUUIDRef typeUUID, CFPlugInRef plugIn)
{
  const __CFArray *Value;
  const __CFArray *v5;
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex v8;
  __CFBundle **ValueAtIndex;
  __CFBundle **v10;
  __CFBundle *v11;
  __CFBundle *v12;
  NSObject *v13;
  CFIndex v15;
  int v16;
  CFIndex v17;
  __int16 v18;
  CFUUIDRef v19;
  __int16 v20;
  CFPlugInRef v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByTypeID
    && (Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByTypeID, typeUUID)) != 0)
  {
    v5 = Value;
    Count = CFArrayGetCount(Value);
    Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    if (Count >= 1)
    {
      v8 = 0;
      while (1)
      {
        ValueAtIndex = (__CFBundle **)CFArrayGetValueAtIndex(v5, v8);
        v10 = ValueAtIndex;
        v11 = ValueAtIndex[5];
        if (v11)
          CFRetain(ValueAtIndex[5]);
        if (v11 == plugIn)
          break;
        if (v11)
          goto LABEL_9;
LABEL_10:
        if (Count == ++v8)
          goto LABEL_17;
      }
      v12 = v10[2];
      if (v12)
        CFRetain(v12);
      CFArrayAppendValue(Mutable, v12);
      CFRelease(v12);
      if (!v11)
        goto LABEL_10;
LABEL_9:
      CFRelease(v11);
      goto LABEL_10;
    }
  }
  else
  {
    Mutable = 0;
  }
LABEL_17:
  os_unfair_recursive_lock_unlock();
  if (_CFBundlePluginLogger_onceToken != -1)
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  v13 = _CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
  {
    if (Mutable)
      v15 = CFArrayGetCount(Mutable);
    else
      v15 = 0;
    v16 = 134349570;
    v17 = v15;
    v18 = 2114;
    v19 = typeUUID;
    v20 = 2114;
    v21 = plugIn;
    _os_log_debug_impl(&dword_182A8C000, v13, OS_LOG_TYPE_DEBUG, "%{public}ld factories found for requested plugin type %{public}@ in plugin %{public}@", (uint8_t *)&v16, 0x20u);
  }
  return Mutable;
}

uint64_t _CFLocaleCopyPreferred()
{
  return +[NSLocale _newLocaleAsIfCurrent:overrides:disableBundleMatching:](NSLocale, "_newLocaleAsIfCurrent:overrides:disableBundleMatching:", 0, 0, 1);
}

uint64_t CFStringHashNSString(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  unsigned int v7;
  _WORD v9[32];
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = objc_msgSend(a1, "length");
  v3 = v2;
  v4 = v9;
  if (v2 >= 97)
  {
    objc_msgSend(a1, "getCharacters:range:", v9, 0, 32);
    objc_msgSend(a1, "getCharacters:range:", &v10, ((unint64_t)v2 >> 1) - 16, 32);
    objc_msgSend(a1, "getCharacters:range:", &v11, v2 - 32, 32);
    v5 = (unsigned __int16 *)&v12;
    v6 = (unsigned __int16 *)&v12;
LABEL_5:
    v4 = v9;
    do
    {
      v3 = v4[3] + 67503105 * v3 + 257 * (257 * (257 * *v4 + v4[1]) + v4[2]);
      v4 += 4;
    }
    while (v4 < v6);
    goto LABEL_9;
  }
  objc_msgSend(a1, "getCharacters:range:", v9, 0, v2);
  v5 = &v9[v2];
  if ((uint64_t)(v2 & 0xFFFFFFFFFFFFFFFCLL) >= 1)
  {
    v6 = &v9[v2 & 0xFFFFFFFFFFFFFFFCLL];
    goto LABEL_5;
  }
LABEL_9:
  while (v4 < v5)
  {
    v7 = *v4++;
    v3 = 257 * v3 + v7;
  }
  return (v3 << (v2 & 0x1F)) + v3;
}

void __CFBundleDeallocate(_QWORD *a1)
{
  const __CFDictionary *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;

  v3 = (const void *)a1[2];
  v2 = (const __CFDictionary *)a1[3];
  a1[2] = 0;
  if (v2)
    CFDictionaryGetValue(v2, CFSTR("CFBundleIdentifier"));
  _CFBundleUnloadExecutable((uint64_t)a1, 0);
  _CFBundleDeallocatePlugIn((uint64_t)a1);
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[3];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[4];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)a1[5];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a1[13];
  if (v7)
    CFRelease(v7);
  v8 = (const void *)a1[27];
  if (v8)
    CFRelease(v8);
  v9 = (const void *)a1[18];
  if (v9)
    CFRelease(v9);
  v10 = (const void *)a1[19];
  if (v10)
    CFRelease(v10);
  v11 = (const void *)a1[20];
  if (v11)
    CFRelease(v11);
  v12 = (const void *)a1[21];
  if (v12)
    CFRelease(v12);
  v13 = (const void *)a1[24];
  if (v13)
    CFRelease(v13);
  v14 = (const void *)a1[23];
  if (v14)
    CFRelease(v14);
  v15 = (const void *)a1[15];
  if (v15)
    CFRelease(v15);
  v16 = (const void *)a1[17];
  if (v16)
    CFRelease(v16);
  v17 = (const void *)a1[26];
  if (v17)
    CFRelease(v17);
}

void _CFBundleUnloadExecutable(uint64_t a1, int a2)
{
  unint64_t v4;
  int v5;

  v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  if (!a2)
    _CFPlugInUnloadScheduledPlugIns();
  os_unfair_lock_lock_with_options();
  v5 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  if (v5)
  {
    _CFPlugInUnscheduleForUnloading((const void *)a1);
    _CFPlugInWillUnload(a1);
    os_unfair_lock_lock_with_options();
    if (*(_BYTE *)(a1 + 52) && (*(_DWORD *)(a1 + 48) != 4 || _CFExecutableLinkedOnOrAfter(5uLL)))
      _CFBundleDlfcnUnload(a1);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  }
}

uint64_t _CFPlugInUnloadScheduledPlugIns()
{
  CFIndex Count;
  CFIndex v1;
  const void **Typed;
  uint64_t i;
  uint64_t v4;
  NSObject *v5;
  uint8_t buf[4];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  os_unfair_recursive_lock_lock_with_options();
  if (_plugInsToUnload)
  {
    Count = CFSetGetCount((CFSetRef)_plugInsToUnload);
    if (Count >= 1)
    {
      v1 = Count;
      Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0x2004093837F09, 0);
      CFSetGetValues((CFSetRef)_plugInsToUnload, Typed);
      for (i = 0; i != v1; ++i)
      {
        v4 = (uint64_t)Typed[i];
        if (!*(_DWORD *)(__CFBundleGetPlugInData(v4) + 12))
        {
          if (_CFBundlePluginLogger_onceToken != -1)
            dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
          v5 = _CFBundlePluginLogger__log;
          if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138543362;
            v8 = v4;
            _os_log_debug_impl(&dword_182A8C000, v5, OS_LOG_TYPE_DEBUG, "PlugIn %{public}@ is about to be unloaded", buf, 0xCu);
          }
          _CFBundleUnloadExecutable(v4, 1);
        }
      }
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
  }
  return os_unfair_recursive_lock_unlock();
}

uint64_t _CFBundleDeallocatePlugIn(uint64_t a1)
{
  uint64_t PlugInData;
  NSObject *v3;
  int Count;
  unint64_t v5;
  _BYTE *ValueAtIndex;

  PlugInData = __CFBundleGetPlugInData(a1);
  os_unfair_recursive_lock_lock_with_options();
  if (*(_BYTE *)PlugInData)
  {
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    v3 = _CFBundlePluginLogger__log;
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
      _CFBundleDeallocatePlugIn_cold_1(a1, v3);
    Count = CFArrayGetCount(*(CFArrayRef *)(PlugInData + 16));
    if (Count >= 1)
    {
      v5 = Count + 1;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(PlugInData + 16), (v5 - 2));
        _CFPFactoryDisableLocked(ValueAtIndex);
        --v5;
      }
      while (v5 > 1);
    }
    CFRelease(*(CFTypeRef *)(PlugInData + 16));
    *(_BYTE *)PlugInData = 0;
  }
  return os_unfair_recursive_lock_unlock();
}

void CFRunLoopTimerSetTolerance(CFRunLoopTimerRef timer, CFTimeInterval tolerance)
{
  double v4;
  double v5;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (CF_IS_OBJC(0x2FuLL, (__objc2_class **)timer))
  {
    -[__CFRunLoopTimer setTolerance:](timer, "setTolerance:", tolerance);
  }
  else
  {
    v4 = *((double *)timer + 14);
    if (v4 <= 0.0)
    {
      v5 = 0.0;
      if (tolerance >= 0.0)
        v5 = tolerance;
    }
    else
    {
      v5 = v4 * 0.5;
      if (v5 > tolerance)
        v5 = tolerance;
    }
    *((double *)timer + 15) = v5;
  }
}

uint64_t CFStorageGetValueAtIndex(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t Byte;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  CFAllocatorRef v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40[2];

  v40[1] = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 128);
  os_unfair_lock_lock_with_options();
  v7 = *(_QWORD *)(a1 + 104);
  v8 = *(_QWORD *)(a1 + 112);
  v9 = *(_QWORD *)(a1 + 120);
  os_unfair_lock_unlock(v6);
  if (v7 && !*(_BYTE *)(v7 + 12))
  {
    if (!*(_QWORD *)(v7 + 24))
    {
      v19 = CFGetAllocator((CFTypeRef)a1);
      v20 = *(_QWORD *)v7;
      v21 = *MEMORY[0x1E0C85AD8];
      if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
        v22 = *MEMORY[0x1E0C85AD8];
      else
        v22 = v21 + 1;
      if (v20 <= v22 >> 1)
      {
        v32 = v20 + 63;
        v31 = v20 < -63;
        v33 = v20 + 126;
        if (!v31)
          v33 = v32;
        v24 = v33 & 0xFFFFFFFFFFFFFFC0;
      }
      else
      {
        v23 = (v20 + v21 - 1) & -(int)v21;
        if (*(_QWORD *)(a1 + 136) >= v23)
          v24 = v23;
        else
          v24 = *(_QWORD *)(a1 + 136);
      }
      if (v24 > *(_QWORD *)(v7 + 16))
      {
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
        if (v24 > *(_QWORD *)(v7 + 16))
        {
          *(_QWORD *)(v7 + 24) = __CFSafelyReallocateWithAllocatorTyped(v19, *(_QWORD *)(v7 + 24), v24, 1893177561, 0, 0);
          if (__CFOASafe)
            __CFSetLastAllocationEventName();
          *(_QWORD *)(v7 + 16) = v24;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
      }
    }
    v34 = a2 - v8;
    if (a2 >= v8 && v9 + v8 > a2)
    {
      if (a3)
      {
        *a3 = v8;
        a3[1] = v9;
      }
      v35 = *(_QWORD *)(v7 + 24);
      v36 = *(_DWORD *)(a1 + 24);
      if (v36 == -1)
      {
        v37 = *(_QWORD *)(a1 + 16) * v34;
        if (!v35)
          goto LABEL_3;
      }
      else
      {
        v37 = v34 << v36;
        if (!v35)
          goto LABEL_3;
      }
      return v35 + v37;
    }
  }
LABEL_3:
  v39 = 0;
  v40[0] = 0;
  v38 = 0;
  v10 = *(_DWORD *)(a1 + 24);
  if (v10 == -1)
    v11 = *(_QWORD *)(a1 + 16) * a2;
  else
    v11 = a2 << v10;
  Byte = __CFStorageFindByte((_QWORD *)a1, a1 + 144, v11, 0, v40, &v38, 1);
  v13 = v40[0];
  v14 = v38;
  if (v40[0])
  {
    v15 = *(_QWORD *)v40[0];
    v16 = *(_DWORD *)(a1 + 24);
    if (v16 == -1)
    {
      v25 = *(_QWORD *)(a1 + 16);
      v17 = v38 / v25;
      v18 = v15 / v25;
    }
    else
    {
      v17 = v38 >> v16;
      v18 = v15 >> v16;
    }
  }
  else
  {
    v17 = 0;
    v18 = 0;
  }
  os_unfair_lock_lock_with_options();
  *(_QWORD *)(a1 + 104) = v13;
  *(_QWORD *)(a1 + 112) = v17;
  *(_QWORD *)(a1 + 120) = v18;
  os_unfair_lock_unlock(v6);
  v26 = *(_DWORD *)(a1 + 24);
  if (v26 != -1)
  {
    v27 = v14 >> v26;
    v28 = v39 >> v26;
    if (!a3)
      return Byte;
    goto LABEL_23;
  }
  v29 = *(_QWORD *)(a1 + 16);
  v27 = v14 / v29;
  v28 = v39 / v29;
  if (a3)
  {
LABEL_23:
    *a3 = v27;
    a3[1] = v28;
  }
  return Byte;
}

char *CFStorageGetValues(char *result, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5;
  char *v7;
  os_unfair_lock_s *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  CFAllocatorRef v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  const void *Byte;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  pthread_mutex_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41[2];

  v41[1] = *MEMORY[0x1E0C80C00];
  if (a3 >= 1)
  {
    v5 = a3;
    v7 = result;
    v8 = (os_unfair_lock_s *)(result + 128);
    v37 = (pthread_mutex_t *)(result + 32);
    v38 = (uint64_t)(result + 144);
    while (1)
    {
      os_unfair_lock_lock_with_options();
      v10 = (uint64_t *)*((_QWORD *)v7 + 13);
      v9 = *((_QWORD *)v7 + 14);
      v11 = *((_QWORD *)v7 + 15);
      os_unfair_lock_unlock(v8);
      if (!v10)
        break;
      if (!v10[3])
      {
        v12 = CFGetAllocator(v7);
        v13 = *v10;
        v14 = *MEMORY[0x1E0C85AD8];
        if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
          v15 = *MEMORY[0x1E0C85AD8];
        else
          v15 = v14 + 1;
        if (v13 <= v15 >> 1)
        {
          v19 = v13 + 63;
          v22 = v13 < -63;
          v20 = v13 + 126;
          if (!v22)
            v20 = v19;
          v17 = v20 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          v16 = (v13 + v14 - 1) & -(int)v14;
          if (*((_QWORD *)v7 + 17) >= v16)
            v17 = v16;
          else
            v17 = *((_QWORD *)v7 + 17);
        }
        if (v17 > v10[2])
        {
          pthread_mutex_lock(v37);
          if (v17 > v10[2])
          {
            v10[3] = __CFSafelyReallocateWithAllocatorTyped(v12, v10[3], v17, 1893177561, 0, 0);
            if (__CFOASafe)
              __CFSetLastAllocationEventName();
            v10[2] = v17;
          }
          pthread_mutex_unlock(v37);
        }
      }
      v18 = *((unsigned int *)v7 + 6);
      v21 = a2 - v9;
      v22 = a2 < v9 || v11 + v9 <= a2;
      if (v22)
        goto LABEL_31;
      v23 = v18 == 0xFFFFFFFFLL ? *((_QWORD *)v7 + 2) * v21 : v21 << v18;
      v24 = v10[3];
      if (!v24)
        goto LABEL_31;
      Byte = (const void *)(v24 + v23);
LABEL_42:
      if (v5 >= v9 - a2 + v11)
        v35 = v9 - a2 + v11;
      else
        v35 = v5;
      if (v18 == 0xFFFFFFFFLL)
        v36 = *((_QWORD *)v7 + 2) * v35;
      else
        v36 = v35 << v18;
      result = (char *)memmove(a4, Byte, v36);
      a4 += v36;
      a2 += v35;
      v22 = v5 <= v35;
      v5 -= v35;
      if (v22)
        return result;
    }
    v18 = *((unsigned int *)v7 + 6);
LABEL_31:
    v40 = 0;
    v41[0] = 0;
    v39 = 0;
    if (v18 == 0xFFFFFFFFLL)
      v26 = *((_QWORD *)v7 + 2) * a2;
    else
      v26 = a2 << v18;
    Byte = (const void *)__CFStorageFindByte(v7, v38, v26, 0, v41, &v39, 0);
    v27 = v41[0];
    v28 = v39;
    if (v41[0])
    {
      v29 = *(_QWORD *)v41[0];
      v30 = *((_DWORD *)v7 + 6);
      if (v30 == -1)
      {
        v33 = *((_QWORD *)v7 + 2);
        v31 = v39 / v33;
        v32 = v29 / v33;
      }
      else
      {
        v31 = v39 >> v30;
        v32 = v29 >> v30;
      }
    }
    else
    {
      v31 = 0;
      v32 = 0;
    }
    os_unfair_lock_lock_with_options();
    *((_QWORD *)v7 + 13) = v27;
    *((_QWORD *)v7 + 14) = v31;
    *((_QWORD *)v7 + 15) = v32;
    os_unfair_lock_unlock(v8);
    v18 = *((unsigned int *)v7 + 6);
    if ((_DWORD)v18 == -1)
    {
      v34 = *((_QWORD *)v7 + 2);
      v9 = v28 / v34;
      v11 = v40 / v34;
    }
    else
    {
      v9 = v28 >> v18;
      v11 = v40 >> v18;
    }
    goto LABEL_42;
  }
  return result;
}

const __CFURL *_CFBundleCopyFrameworkURLForExecutablePath(uint64_t a1)
{
  return __CFBundleCopyFrameworkURLForExecutablePath(a1, 0);
}

uint64_t _NSIsNSValue(uint64_t a1)
{
  uint64_t (*MethodImplementation)(uint64_t, char *);
  Class Class;

  if (_NSValueClass || (Class = objc_getClass("NSValue"), (_NSValueClass = (uint64_t)Class) != 0))
  {
    if (a1)
    {
      MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
      if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
        return MethodImplementation(a1, sel_isNSValue__);
      LOBYTE(Class) = objc_opt_isKindOfClass();
    }
    else
    {
      LOBYTE(Class) = 0;
    }
  }
  return Class & 1;
}

CFURLRef *_CFBundleCreateWithExecutableURLIfLooksLikeBundle(const __CFAllocator *a1, const __CFURL *a2)
{
  const __CFURL *v4;
  CFURLRef v5;
  const __CFURL *v6;
  CFURLRef *Unique;
  CFURLRef *v8;
  const __CFURL *v9;
  CFURLRef NormalizedURL;
  const __CFURL *v11;
  CFURLRef *v12;
  CFURLRef *v13;
  UInt8 v15[1026];
  UInt8 buffer[1026];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = _CFBundleCopyBundleURLForExecutableURL(a2);
  v5 = _CFBundleCopyResolvedURLForExecutableURL(a2);
  v6 = v5;
  if (v4 && v5)
  {
    Unique = (CFURLRef *)_CFBundleCreateUnique(a1, v4);
    if (!Unique)
    {
      v12 = 0;
      goto LABEL_19;
    }
    v8 = Unique;
    v9 = _CFBundleCopyExecutableURLInDirectory2((CFBundleRef)Unique, Unique[2], 0, 1);
    NormalizedURL = _CFBundleCreateNormalizedURL(a1, v6);
    v11 = NormalizedURL;
    if (v9 && NormalizedURL)
    {
      if (!CFURLGetFileSystemRepresentation(v9, 1u, buffer, 1026)
        || !CFURLGetFileSystemRepresentation(v11, 1u, v15, 1026)
        || strcmp((const char *)buffer, (const char *)v15))
      {
        CFRelease(v8);
        v8 = 0;
      }
    }
    else
    {
      CFRelease(v8);
      v8 = 0;
      v12 = 0;
      if (!v9)
        goto LABEL_17;
    }
    CFRelease(v9);
    v12 = v8;
LABEL_17:
    if (v11)
      CFRelease(v11);
LABEL_19:
    CFRelease(v4);
    v13 = v12;
    if (!v6)
      return v13;
    goto LABEL_12;
  }
  v12 = 0;
  v13 = 0;
  if (v4)
    goto LABEL_19;
  if (v5)
LABEL_12:
    CFRelease(v6);
  return v13;
}

_QWORD *_CFBundleCreateUnique(const __CFAllocator *a1, const __CFURL *a2)
{
  return _CFBundleCreate(a1, a2, 1, 0);
}

void *__cdecl CFBundleGetFunctionPointerForName(CFBundleRef bundle, CFStringRef functionName)
{
  unint64_t v4;

  v4 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v4 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  if (CFBundleLoadExecutable(bundle))
    return _CFBundleDlfcnGetSymbolByNameWithSearch((uint64_t)bundle, functionName, 0);
  else
    return 0;
}

void *__cdecl CFBundleGetDataPointerForName(CFBundleRef bundle, CFStringRef symbolName)
{
  unint64_t v4;

  v4 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v4 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v4);
  if (CFBundleLoadExecutable(bundle))
    return _CFBundleDlfcnGetSymbolByNameWithSearch((uint64_t)bundle, symbolName, 0);
  else
    return 0;
}

Boolean CFBundleLoadExecutable(CFBundleRef bundle)
{
  return _CFBundleLoadExecutableAndReturnError((uint64_t)bundle, 0, 0);
}

uint64_t _CFStreamSetDispatchQueue(uint64_t a1, NSObject *a2)
{
  const __CFArray *v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex i;
  __CFRunLoop *ValueAtIndex;
  const __CFString *v10;
  pthread_mutex_t *v11;
  NSObject *v12;
  NSObject *v13;

  v4 = _CFStreamCopyRunLoopsAndModes(a1);
  if (v4)
  {
    v5 = v4;
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v7 = Count;
      for (i = 0; i < v7; i += 2)
      {
        ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v5, i);
        v10 = (const __CFString *)CFArrayGetValueAtIndex(v5, i + 1);
        _CFStreamUnscheduleFromRunLoop(a1, ValueAtIndex, v10);
      }
    }
    CFRelease(v5);
  }
  if (a2)
  {
    if (_legacyStreamRunLoop_sOnce != -1)
      dispatch_once(&_legacyStreamRunLoop_sOnce, &__block_literal_global_17);
    _CFStreamScheduleWithRunLoop((char *)a1, (void *)sLegacyRL, CFSTR("kCFRunLoopDefaultMode"));
    v11 = (pthread_mutex_t *)(a1 + 56);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    if (*(_QWORD *)(a1 + 32))
    {
      v12 = *(NSObject **)(a1 + 128);
      if (v12 != a2)
      {
        if (v12)
          dispatch_release(v12);
        *(_QWORD *)(a1 + 128) = a2;
        dispatch_retain(a2);
      }
    }
  }
  else
  {
    v11 = (pthread_mutex_t *)(a1 + 56);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    if (*(_QWORD *)(a1 + 32))
    {
      v13 = *(NSObject **)(a1 + 128);
      if (v13)
        dispatch_release(v13);
      *(_QWORD *)(a1 + 128) = 0;
    }
  }
  return pthread_mutex_unlock(v11);
}

void boundPairWriteUnschedule(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  BOOL v5;
  int v6;

  if (a4)
  {
    v4 = *(__int16 *)(a4 + 52);
    v5 = __OFSUB__(v4, 1);
    v6 = v4 - 1;
    if (v6 < 0 == v5)
      *(_WORD *)(a4 + 52) = v6;
  }
}

uint64_t _CFStreamUnscheduleFromRunLoop(uint64_t result, __CFRunLoop *a2, const __CFString *a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFRunLoopSource *v9;
  const void *Value;
  const __CFArray *v11;
  CFIndex Count;
  CFIndex FirstIndexOfValue;
  uint64_t v14;
  __CFRunLoopSource *v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  const __CFArray *v19;
  CFIndex v20;
  CFIndex v21;
  CFIndex v22;
  const void *ValueAtIndex;
  const void *v24;
  uint64_t (*v25)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD);
  CFRange v26;

  v3 = *(_QWORD *)(result + 32);
  if (!v3 || !*(_QWORD *)(v3 + 56))
    return result;
  v6 = result;
  v7 = *(_QWORD *)(result + 48);
  if ((*(_BYTE *)(result + 17) & 1) == 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)(result + 56));
    v8 = *(_QWORD *)(v6 + 32);
    if (v8 && (v9 = *(__CFRunLoopSource **)(v8 + 56)) != 0)
    {
      CFRetain(*(CFTypeRef *)(v8 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
      CFRunLoopRemoveSource(a2, v9, a3);
      CFRelease(v9);
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
    }
    goto LABEL_24;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
  Value = CFDictionaryGetValue((CFDictionaryRef)sSharedSources, (const void *)v6);
  v11 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)sSharedSources, Value);
  Count = CFArrayGetCount(v11);
  v26.location = 0;
  v26.length = Count;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v11, v26, (const void *)v6);
  if (FirstIndexOfValue != -1)
  {
    CFArrayRemoveValueAtIndex(v11, FirstIndexOfValue);
    --Count;
  }
  if (!Count)
  {
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 56));
    v14 = *(_QWORD *)(v6 + 32);
    if (v14 && (v15 = *(__CFRunLoopSource **)(v14 + 56)) != 0)
    {
      CFRetain(*(CFTypeRef *)(v14 + 56));
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
      CFRunLoopRemoveSource(a2, v15, a3);
      CFRelease(v15);
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, Value);
  }
  CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, (const void *)v6);
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 56));
  v16 = *(_QWORD *)(v6 + 32);
  if (v16)
  {
    v17 = *(void **)(v16 + 56);
    if (v17)
    {
      CFRetain(*(CFTypeRef *)(v16 + 56));
      *(_QWORD *)(*(_QWORD *)(v6 + 32) + 56) = 0;
      pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
      CFRelease(v17);
      if (!Count)
        CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v17);
      CFRelease(v17);
      goto LABEL_23;
    }
    *(_QWORD *)(v16 + 56) = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
LABEL_23:
  *(_QWORD *)(v6 + 16) &= ~0x100uLL;
  os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
LABEL_24:
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 56));
  v18 = *(_QWORD *)(v6 + 32);
  v19 = *(const __CFArray **)(v18 + 64);
  if (v19)
  {
    v20 = CFArrayGetCount(*(CFArrayRef *)(v18 + 64));
    if (v20 >= 2)
    {
      v21 = v20;
      v22 = 1;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v19, v22 - 1);
        if (CFEqual(ValueAtIndex, a2))
        {
          v24 = CFArrayGetValueAtIndex(v19, v22);
          if (CFEqual(v24, a3))
            break;
        }
        v22 += 2;
        if (v22 >= v21)
          goto LABEL_32;
      }
      CFArrayRemoveValueAtIndex(v19, v22 - 1);
      CFArrayRemoveValueAtIndex(v19, v22 - 1);
    }
  }
LABEL_32:
  result = pthread_mutex_unlock((pthread_mutex_t *)(v6 + 56));
  if (v7)
  {
    v25 = *(uint64_t (**)(uint64_t, __CFRunLoop *, const __CFString *, _QWORD))(v7 + 128);
    if (v25)
      return v25(v6, a2, a3, *(_QWORD *)(v6 + 40));
  }
  return result;
}

void _CFRunLoopSourceWakeUpRunLoops(uint64_t a1)
{
  unint64_t v2;
  pthread_mutex_t *v3;
  char v4;
  const __CFBag *v5;
  const __CFBag *Copy;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 46)
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  v3 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 8) != 0 && (v5 = *(const __CFBag **)(a1 + 96)) != 0)
  {
    Copy = CFBagCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5);
    pthread_mutex_unlock(v3);
    if (Copy)
    {
      CFBagApplyFunction(Copy, (CFBagApplierFunction)__CFRunLoopSourceWakeUpLoop, 0);
      CFRelease(Copy);
    }
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
}

void CFMachPortInvalidate(CFMachPortRef port)
{
  int v2;
  __CFRunLoopSource *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  NSObject *v7;
  void (*v8)(CFMachPortRef, uint64_t);
  uint64_t v9;
  void (*v10)(uint64_t);

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (CF_IS_OBJC(0x24uLL, (__objc2_class **)port))
    {
      -[__CFMachPort invalidate](port, "invalidate");
    }
    else
    {
      CFRetain(port);
      os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMachPortsLock);
      os_unfair_lock_lock((os_unfair_lock_t)port + 24);
      v2 = *((_DWORD *)port + 4);
      if (v2)
      {
        v3 = 0;
      }
      else
      {
        *((_DWORD *)port + 4) = 1;
        __dmb(0xBu);
        if (__CFAllMachPorts)
        {
          Count = CFArrayGetCount((CFArrayRef)__CFAllMachPorts);
          if (Count >= 1)
          {
            v5 = Count;
            v6 = 0;
            while (CFArrayGetValueAtIndex((CFArrayRef)__CFAllMachPorts, v6) != port)
            {
              if (v5 == ++v6)
                goto LABEL_18;
            }
            CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFAllMachPorts, v6);
          }
        }
LABEL_18:
        v7 = *((_QWORD *)port + 3);
        if (v7)
        {
          dispatch_source_cancel(v7);
          *((_QWORD *)port + 3) = 0;
        }
        v3 = (__CFRunLoopSource *)*((_QWORD *)port + 5);
        *((_QWORD *)port + 5) = 0;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMachPortsLock);
      if (!v2)
      {
        os_unfair_lock_lock((os_unfair_lock_t)port + 24);
        v8 = (void (*)(CFMachPortRef, uint64_t))*((_QWORD *)port + 4);
        v9 = *((_QWORD *)port + 8);
        v10 = (void (*)(uint64_t))*((_QWORD *)port + 14);
        *((_QWORD *)port + 8) = 0;
        if (v8)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
          v8(port, v9);
          os_unfair_lock_lock((os_unfair_lock_t)port + 24);
        }
        if (v3)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
          CFRunLoopSourceInvalidate(v3);
          CFRelease(v3);
          os_unfair_lock_lock((os_unfair_lock_t)port + 24);
        }
        if (v10)
        {
          if (v9)
          {
            os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
            v10(v9);
            os_unfair_lock_lock((os_unfair_lock_t)port + 24);
          }
        }
        *((_DWORD *)port + 4) = 2;
        __dmb(0xBu);
        os_unfair_lock_unlock((os_unfair_lock_t)port + 24);
      }
      CFRelease(port);
    }
  }
}

double __CFRunLoopSourceDeallocate(uint64_t a1)
{
  void (*v2)(_QWORD);
  double result;

  CFRunLoopSourceInvalidate((CFRunLoopSourceRef)a1);
  v2 = *(void (**)(_QWORD))(a1 + 128);
  if (v2)
    v2(*(_QWORD *)(a1 + 112));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_QWORD *)(a1 + 176) = 0;
  return result;
}

void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source)
{
  unint64_t v2;
  unint64_t *v3;
  char v4;
  const __CFBag *v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  _QWORD context[3];

  context[2] = *MEMORY[0x1E0C80C00];
  v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46)
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
  CFRetain(source);
  v3 = (unint64_t *)((char *)source + 8);
  v4 = atomic_load((unint64_t *)source + 1);
  if ((v4 & 8) != 0)
  {
    v5 = (const __CFBag *)*((_QWORD *)source + 12);
    v6 = atomic_load(v3);
    while (1)
    {
      v7 = __ldaxr(v3);
      if (v7 != v6)
        break;
      if (__stlxr(v6 & 0xFFFFFFFFFFFFFFF7, v3))
        goto LABEL_12;
      v8 = 1;
LABEL_13:
      v6 = v7;
      if (v8)
      {
        atomic_store(0, (unint64_t *)source + 11);
        if (v5)
        {
          *((_QWORD *)source + 12) = 0;
          pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
          context[0] = source;
          context[1] = 0;
          CFBagApplyFunction(v5, (CFBagApplierFunction)__CFRunLoopSourceRemoveFromRunLoop, context);
          CFRelease(v5);
          pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
        }
        goto LABEL_16;
      }
    }
    __clrex();
LABEL_12:
    v8 = 0;
    goto LABEL_13;
  }
LABEL_16:
  pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
  CFRelease(source);
}

void CFBagApplyFunction(CFBagRef theBag, CFBagApplierFunction applier, void *context)
{
  _QWORD v3[7];

  v3[6] = *MEMORY[0x1E0C80C00];
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = __CFBagApplyFunction_block_invoke;
  v3[3] = &__block_descriptor_48_e15_C40__0___qQQQ_8l;
  v3[4] = applier;
  v3[5] = context;
  CFBasicHashApply((uint64_t)theBag, (uint64_t)v3);
}

CFBagRef CFBagCreateCopy(CFAllocatorRef allocator, CFBagRef theBag)
{
  uint64_t Count;
  _OWORD *Typed;
  uint64_t Copy;
  uint64_t v7;
  uint64_t Generic;
  uint64_t i;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  _OWORD v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(4uLL, (__objc2_class **)theBag))
  {
    Count = CFBasicHashGetCount((uint64_t)theBag);
    memset(v15, 0, 512);
    if (Count >= 257)
      Typed = (_OWORD *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
    else
      Typed = v15;
    v7 = CFBasicHashGetCount((uint64_t)theBag);
    CFBasicHashGetElements((uint64_t)theBag, v7, 0, (uint64_t)Typed);
    Generic = __CFBagCreateGeneric((__objc2_class **)allocator, (uint64_t)&kCFTypeBagCallBacks);
    Copy = Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (i = 0; i < Count; ++i)
        CFBasicHashAddValue(Copy, *((_QWORD *)Typed + i), *((_QWORD *)Typed + i));
    }
    if (Count >= 257)
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
  else
  {
    Copy = CFBasicHashCreateCopy((__objc2_class **)allocator, (uint64_t)theBag);
  }
  if (Copy)
  {
    v10 = (unint64_t *)(Copy + 8);
    v11 = atomic_load((unint64_t *)(Copy + 8));
    while (1)
    {
      v12 = __ldaxr(v10);
      if (v12 != v11)
        break;
      if (__stlxr(v11 | 0x40, v10))
        goto LABEL_18;
      v13 = 1;
LABEL_19:
      v11 = v12;
      if (v13)
      {
        _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)Copy, 4uLL);
        if (__CFOASafe)
          __CFSetLastAllocationEventName();
        return (CFBagRef)Copy;
      }
    }
    __clrex();
LABEL_18:
    v13 = 0;
    goto LABEL_19;
  }
  return (CFBagRef)Copy;
}

double _CFOperatingSystemVersionGetCurrent@<D0>(uint64_t a1@<X8>)
{
  double result;

  if (_CFOperatingSystemVersionGetCurrent_onceToken != -1)
    dispatch_once(&_CFOperatingSystemVersionGetCurrent_onceToken, &__block_literal_global_32);
  result = *(double *)&_CFOperatingSystemVersionGetCurrent_version;
  *(_OWORD *)a1 = _CFOperatingSystemVersionGetCurrent_version;
  *(_QWORD *)(a1 + 16) = qword_1ECCFA450;
  return result;
}

CFIndex CFArrayGetLastIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length;
  CFIndex location;
  const CFArrayCallBacks *v7;
  CFIndex v8;
  const void *v9;
  unsigned int (*equal)(const void *, const void *);
  unsigned int v12;
  int v13;
  char v14;
  int v15;
  const CFArrayCallBacks *v16;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
    goto LABEL_2;
  v12 = atomic_load((unint64_t *)theArray + 1);
  v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
LABEL_2:
      v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }
    v14 = atomic_load((unint64_t *)theArray + 1);
    v15 = v14 & 3;
    if (v15)
      v16 = 0;
    else
      v16 = (const CFArrayCallBacks *)((char *)theArray + 48);
    if (v15 == 2)
      v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    else
      v7 = v16;
  }
  else
  {
    v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_3:
  if (!length)
    return -1;
  while (1)
  {
    v8 = length - 1;
    v9 = (const void *)-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location - 1 + length);
    if (v9 == value)
      return v8 + location;
    equal = (unsigned int (*)(const void *, const void *))v7->equal;
    if (equal)
    {
      if (equal(value, v9))
        break;
    }
    --length;
    if (!v8)
      return -1;
  }
  return location + length - 1;
}

void _cfmp_source_invalidated(int a1, int a2)
{
  const __CFSet *v4;
  _BYTE *Value;
  unint64_t v6;
  _DWORD v7[2];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (_cfmp_records_oGuard != -1)
    dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
  v4 = (const __CFSet *)_cfmp_records_oRecords;
  os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
  v7[0] = a2;
  v7[1] = a1;
  Value = CFSetGetValue(v4, v7);
  if (!Value)
  {
    _cfmp_log_failure((uint64_t)"not expecting invalidation", 0, a1, a2);
    goto LABEL_7;
  }
  if ((Value[5] & 2) == 0)
  {
    Value[5] |= 4u;
LABEL_7:
    os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
    return;
  }
  v6 = *(_QWORD *)Value;
  CFSetRemoveValue(v4, Value);
  os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
  _cfmp_cleanup(v6);
}

unint64_t _cfmp_cleanup(unint64_t name)
{
  mach_port_name_t v1;
  char v2;
  ipc_space_t *v3;

  v1 = name;
  v2 = BYTE5(name);
  v3 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  if (((name >> 40) & 0x10) != 0)
  {
    name = mach_port_mod_refs(*MEMORY[0x1E0C83DA0], name, 1u, -1);
    if ((v2 & 8) == 0)
    {
LABEL_3:
      if ((v2 & 0x20) == 0)
        return name;
      goto LABEL_7;
    }
  }
  else if ((name & 0x80000000000) == 0)
  {
    goto LABEL_3;
  }
  name = mach_port_deallocate(*v3, v1);
  if ((v2 & 0x20) == 0)
    return name;
LABEL_7:
  if ((v2 & 0x80) == 0)
  {
    if ((v2 & 0x40) == 0)
      return name;
    return mach_port_deallocate(*v3, v1);
  }
  name = mach_port_mod_refs(*v3, v1, 1u, -1);
  if ((v2 & 0x40) != 0)
    return mach_port_deallocate(*v3, v1);
  return name;
}

CFStringRef CFURLCopyFragment(CFURLRef anURL, CFStringRef charactersToLeaveEscaped)
{
  const __CFString *v4;
  const __CFString *v5;
  int v6;
  const __CFAllocator *v7;
  CFStringRef v8;
  const __CFString *v9;

  v4 = _unescapedFragment((__objc2_class **)anURL);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = *((_DWORD *)anURL + 5);
  v7 = CFGetAllocator(anURL);
  if (v6 == 134217984)
    v8 = CFURLCreateStringByReplacingPercentEscapes(v7, v5, charactersToLeaveEscaped);
  else
    v8 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v7, v5, charactersToLeaveEscaped, *((_DWORD *)anURL + 5));
  v9 = v8;
  CFRelease(v5);
  return v9;
}

const __CFString *_unescapedFragment(__objc2_class **a1)
{
  const void *v2;
  const void *v3;

  if (!CF_IS_OBJC(0x1DuLL, a1))
    return _retainedComponentString((uint64_t)a1, 256, 0, 0);
  v2 = (const void *)objc_msgSend(a1, "fragment");
  v3 = v2;
  if (v2)
    CFRetain(v2);
  return (const __CFString *)v3;
}

uint64_t _CFURLCopyComponents(__objc2_class **a1, uint64_t a2, uint64_t a3)
{
  __objc2_class **v5;
  CFStringRef v6;
  const __CFAllocator *v7;
  uint64_t result;
  const void *v9;
  const void *v10;
  uint64_t v11;
  const void *v12;
  const __CFArray *v13;
  int Count;
  const __CFArray *MutableCopy;
  const void *ValueAtIndex;
  CFStringRef v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _OWORD v21[2];
  uint64_t v22;

  v5 = a1;
  v22 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x1DuLL, a1))
    v5 = (__objc2_class **)objc_msgSend(v5, "_cfurl");
  if (a2 == 2)
  {
    v7 = CFGetAllocator(v5);
    memset(v21, 0, sizeof(v21));
    v19 = 0u;
    v20 = 0u;
    v18 = 0u;
    result = decomposeToRFC1808((uint64_t)v5, (const __CFString **)&v18);
    if (!(_DWORD)result)
      return result;
    v9 = (const void *)*((_QWORD *)&v18 + 1);
    *(_QWORD *)a3 = v18;
    if (v9)
    {
      v10 = (const void *)v19;
      if ((_QWORD)v19)
      {
        *(_QWORD *)(a3 + 8) = CFStringCreateWithFormat(v7, 0, CFSTR("%@:%@"), v9, (_QWORD)v19);
        CFRelease(v10);
        CFRelease(v9);
      }
      else
      {
        *(_QWORD *)(a3 + 8) = v9;
      }
    }
    else
    {
      *(_QWORD *)(a3 + 8) = 0;
    }
    v11 = v20;
    *(_QWORD *)(a3 + 16) = *((_QWORD *)&v19 + 1);
    *(_QWORD *)(a3 + 24) = v11;
    v13 = (const __CFArray *)*((_QWORD *)&v20 + 1);
    v12 = *(const void **)&v21[0];
    if (*(_QWORD *)&v21[0])
    {
      Count = CFArrayGetCount(*((CFArrayRef *)&v20 + 1));
      MutableCopy = CFArrayCreateMutableCopy(v7, Count, v13);
      *(_QWORD *)(a3 + 32) = MutableCopy;
      ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, Count - 1);
      v17 = CFStringCreateWithFormat(v7, 0, CFSTR("%@;%@"), ValueAtIndex, v12);
      CFArraySetValueAtIndex(*(CFMutableArrayRef *)(a3 + 32), Count - 1, v17);
      CFRelease(v17);
      if (v13)
        CFRelease(v13);
      CFRelease(v12);
    }
    else
    {
      *(_QWORD *)(a3 + 32) = *((_QWORD *)&v20 + 1);
    }
    *(_OWORD *)(a3 + 40) = *(_OWORD *)((char *)v21 + 8);
    *(_QWORD *)(a3 + 56) = *((_QWORD *)&v21[1] + 1);
    return 1;
  }
  if (a2 == 1)
    return decomposeToRFC1808((uint64_t)v5, (const __CFString **)a3);
  if (a2)
    return 0;
  if (!CF_IS_OBJC(0x1DuLL, v5))
  {
    if (v5[4])
      goto LABEL_8;
LABEL_16:
    v6 = CFURLCopyScheme((CFURLRef)v5);
    goto LABEL_17;
  }
  if (!objc_msgSend(v5, "baseURL"))
    goto LABEL_16;
LABEL_8:
  v6 = 0;
LABEL_17:
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = CFURLCopyResourceSpecifier((CFURLRef)v5);
  return 1;
}

uint64_t _CFURLGetEncoding(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

const __CFString *_CFURLCopyPath(__objc2_class **a1, int a2)
{
  __objc2_class **v3;

  v3 = a1;
  if (CF_IS_OBJC(0x1DuLL, a1))
    v3 = (__objc2_class **)objc_msgSend(v3, "_cfurl");
  return _retainedComponentString((uint64_t)v3, 32, 0, a2);
}

CFTimeZoneRef CFTimeZoneCopySystem(void)
{
  void *v0;
  NSTimeZone *v1;
  const __CFTimeZone *v2;

  v0 = (void *)_CFAutoreleasePoolPush();
  v1 = +[NSTimeZone systemTimeZone](NSTimeZone, "systemTimeZone");
  if (v1)
    v2 = (const __CFTimeZone *)CFRetain(v1);
  else
    v2 = 0;
  _CFAutoreleasePoolPop(v0);
  return v2;
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
  unsigned __int8 v6;
  unint64_t v7;
  const __CFString *Copy;
  const void *v9;
  CFTypeID TypeID;
  uint64_t Count;
  const void **v12;
  pthread_mutex_t *v13;
  const __CFString **v14;
  const void *v15;
  CFTypeID v16;
  uint64_t v17;
  const __CFString **v18;
  const void *v19;
  void *v20;
  const void *v21;
  _QWORD *v22;
  _QWORD *v23;
  CFRange v24;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v6 = atomic_load(__CFMainThreadHasExited);
  if ((v6 & 1) == 0 || CFRunLoopGetMain() != rl)
  {
    v7 = _CFGetNonObjCTypeID((unint64_t *)rl);
    if (v7 != 43)
      _CFAssertMismatchedTypeID(0x2BuLL, v7);
    if (CFGetTypeID(mode) == 7)
    {
      Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFStringRef)mode);
      pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
      v9 = (const void *)__CFRunLoopCopyMode((uint64_t)rl, Copy, 1);
      if (v9)
        CFRelease(v9);
      pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
      goto LABEL_30;
    }
    TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(mode))
    {
      Count = CFArrayGetCount((CFArrayRef)mode);
      v12 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
      v24.location = 0;
      v24.length = Count;
      CFArrayGetValues((CFArrayRef)mode, v24, v12);
      Copy = (const __CFString *)CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, Count, &kCFTypeSetCallBacks);
      v13 = (pthread_mutex_t *)((char *)rl + 16);
      pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
      if (Count >= 1)
      {
        v14 = (const __CFString **)v12;
        do
        {
          v15 = (const void *)__CFRunLoopCopyMode((uint64_t)rl, *v14, 1);
          if (v15)
            CFRelease(v15);
          ++v14;
          --Count;
        }
        while (Count);
      }
    }
    else
    {
      v16 = CFSetGetTypeID();
      if (v16 != CFGetTypeID(mode))
      {
        Copy = 0;
        goto LABEL_30;
      }
      v17 = CFSetGetCount((CFSetRef)mode);
      v12 = (const void **)malloc_type_malloc(8 * v17, 0xC0040B8AA526DuLL);
      CFSetGetValues((CFSetRef)mode, v12);
      Copy = (const __CFString *)CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v17, &kCFTypeSetCallBacks);
      v13 = (pthread_mutex_t *)((char *)rl + 16);
      pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
      if (v17 >= 1)
      {
        v18 = (const __CFString **)v12;
        do
        {
          v19 = (const void *)__CFRunLoopCopyMode((uint64_t)rl, *v18, 1);
          if (v19)
            CFRelease(v19);
          ++v18;
          --v17;
        }
        while (v17);
      }
    }
    pthread_mutex_unlock(v13);
    free(v12);
LABEL_30:
    v20 = _Block_copy(block);
    v21 = v20;
    if (Copy && v20)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
      v22 = malloc_type_malloc(0x18uLL, 0xE00400670D255uLL);
      *v22 = 0;
      v22[1] = Copy;
      v22[2] = v21;
      v23 = (_QWORD *)*((_QWORD *)rl + 81);
      if (!v23)
        v23 = (_QWORD *)((char *)rl + 640);
      *v23 = v22;
      *((_QWORD *)rl + 81) = v22;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
    }
    else
    {
      if (Copy)
        CFRelease(Copy);
      if (v21)
        _Block_release(v21);
    }
    return;
  }
  if (CFRunLoopPerformBlock_onceToken != -1)
    dispatch_once(&CFRunLoopPerformBlock_onceToken, &__block_literal_global_11_0);
  _CFRunLoopError_MainThreadHasExited();
}

void sub_182B82370(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFMutableDictionaryRef _CFPrefsCopyAppDictionaryWithContainer(__CFString *a1, const __CFString *a2)
{
  void *v4;
  CFMutableDictionaryRef v5;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v4 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v5 = -[_CFXPreferences copyDictionaryForApp:withContainer:]((uint64_t)v4, a1, a2);

  return v5;
}

CFDictionaryRef __CFXPreferencesCopyCurrentApplicationStateWithDeadlockAvoidance(_BYTE *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  CFMutableDictionaryRef v5;

  v2 = _CFGetTSD(0xFu);
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v3 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v4 = objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
    v3 = (void *)v4;
    if (!v2 && v4)
    {
      *a1 = 0;
      v5 = -[_CFXPreferences copyDictionaryForApp:withContainer:](v4, CFSTR("kCFPreferencesCurrentApplication"), 0);

      return v5;
    }
  }
  *a1 = 1;

  return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

void sub_182B826E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFStringRef CFStringCreateStringWithValidatedFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef validFormatSpecifiers, CFStringRef format, va_list arguments, CFErrorRef *errorPtr)
{
  return _CFStringCreateStringWithValidatedFormatAux(alloc, (uint64_t)formatOptions, 0, (uint64_t)validFormatSpecifiers);
}

void _CFPreferencesRegisterStandardUserDefaultsExists()
{
  if (_CFPreferencesRegisterStandardUserDefaultsExists_onceToken != -1)
    dispatch_once(&_CFPreferencesRegisterStandardUserDefaultsExists_onceToken, &__block_literal_global_155);
}

uint64_t ___deque_enumerateObjectsWithOptionsBlock_block_invoke(uint64_t a1)
{
  return __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(*(_QWORD *)(a1 + 32));
}

_QWORD *__mdict_enumerateKeysAndObjectsWithOptionsUsingBlock_block_invoke(_QWORD *result, uint64_t a2)
{
  void *v2;
  BOOL v3;
  _QWORD *v4;
  void *v5;

  v2 = *(void **)(result[5] + 8 * a2);
  if (v2)
    v3 = v2 == &___NSDictionaryM_DeletedMarker;
  else
    v3 = 1;
  if (!v3)
  {
    v4 = result;
    v5 = (void *)_CFAutoreleasePoolPush();
    __NSDICTIONARY_IS_CALLING_OUT_TO_A_BLOCK__(v4[4]);
    return _CFAutoreleasePoolPop(v5);
  }
  return result;
}

uint64_t _CFStringInitializeTaggedStrings(uint64_t a1)
{
  uint64_t result;

  result = _CFExecutableLinkedOnOrAfter(8uLL);
  if ((_DWORD)result)
  {
    if (*MEMORY[0x1E0DE7C50])
    {
      result = _objc_registerTaggedPointerClass();
      __CFTaggedStringClass = a1;
    }
  }
  return result;
}

void CFPreferencesSetValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  _CFPreferencesSetValueWithContainer((uint64_t)key, (uint64_t)value, (__CFString *)applicationID, userName, hostName, 0);
}

uint64_t _CFPrefsSizeOfValue(xpc_object_t xdict, int a2)
{
  Class Class;
  size_t length;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[5];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = 0;
  if (a2 == 1)
  {
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = ___CFPrefsSizeOfValue_block_invoke;
    v9[3] = &unk_1E12E1650;
    v9[4] = &v10;
    xpc_dictionary_apply(xdict, v9);
  }
  else if (!a2)
  {
    Class = object_getClass(xdict);
    if (Class == (Class)MEMORY[0x1E0C812D0])
    {
      v5 = v11;
      v6 = v11[3] + 1;
LABEL_12:
      v5[3] = v6;
      goto LABEL_13;
    }
    if (Class == (Class)MEMORY[0x1E0C81390])
    {
      length = xpc_string_get_length(xdict);
      goto LABEL_11;
    }
    if (Class == (Class)MEMORY[0x1E0C81350])
    {
      v11[3] = 0;
      goto LABEL_13;
    }
    if (Class == (Class)MEMORY[0x1E0C812E8])
    {
      length = xpc_data_get_length(xdict);
LABEL_11:
      v5 = v11;
      v6 = v11[3] + length;
      goto LABEL_12;
    }
  }
LABEL_13:
  v7 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v7;
}

void sub_182B8318C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _CFPrefsTemporaryFDToWriteTo(uint64_t a1, uint64_t a2)
{
  const __CFURL *v2;
  uid_t v3;
  gid_t v4;
  mode_t v5;
  int v6;
  unsigned int v7;
  NSObject *v8;
  int v9;
  mode_t v10;
  gid_t v11;
  uid_t v12;
  const __CFURL *v13;
  const __CFURL *v14;
  CFURLRef PathComponent;
  const __CFURL *v16;
  CFStringRef v17;
  const __CFString *v18;
  const __CFURL *v19;
  uint64_t v20;
  int *v21;
  NSObject *v22;
  NSObject *v23;
  int v24;
  NSObject *v25;
  statfs v27;
  UInt8 buffer[1026];
  UInt8 v29[1042];
  uint64_t v30;

  v2 = (const __CFURL *)MEMORY[0x1E0C80A78](a1, a2);
  v30 = *MEMORY[0x1E0C80C00];
  v7 = atomic_load(&dword_1EDCCE384);
  if (v7 == 1)
  {
    v8 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      _CFPrefsTemporaryFDToWriteTo_cold_1();
    *__error() = 28;
    return 0xFFFFFFFFLL;
  }
  v9 = v6;
  v10 = v5;
  v11 = v4;
  v12 = v3;
  v13 = v2;
  if (!CFURLGetFileSystemRepresentation(v2, 1u, buffer, 1026))
  {
    v22 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      _CFPrefsTemporaryFDToWriteTo_cold_2();
    return 0xFFFFFFFFLL;
  }
  v14 = CFURLCopyAbsoluteURL(v13);
  PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14);
  v16 = (const __CFURL *)CFRetain(PathComponent);
  v17 = CFURLCopyLastPathComponent(v14);
  CFRelease(v14);
  v18 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@.XXXXXXX"), v17);
  v19 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16, v18, 0);
  CFRelease(v18);
  if (v17)
    CFRelease(v17);
  if (!CFURLGetFileSystemRepresentation(v19, 1u, v29, 1026))
  {
    v23 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      _CFPrefsTemporaryFDToWriteTo_cold_3();
    goto LABEL_24;
  }
  if (!v9)
  {
LABEL_14:
    v20 = mkstemp((char *)v29);
    goto LABEL_15;
  }
  v20 = mkstemp_dprotected_np((char *)v29, v9, 0);
  v21 = __error();
  if ((_DWORD)v20 == -1 && *v21 == 45)
  {
    memset(&v27, 0, 512);
    if (!statfs((const char *)v29, &v27) && (v27.f_flags & 0x80) != 0)
      goto LABEL_21;
    goto LABEL_14;
  }
LABEL_15:
  if ((v20 & 0x80000000) != 0)
  {
LABEL_21:
    v24 = *__error();
    v25 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
      _CFPrefsTemporaryFDToWriteTo_cold_4(v24, (uint64_t)v29, v25);
    *__error() = v24;
LABEL_24:
    CFRelease(v19);
    CFRelease(PathComponent);
    CFRelease(v16);
    return 0xFFFFFFFFLL;
  }
  fchown(v20, v12, v11);
  fchmod(v20, v10);
  CFRelease(v19);
  CFRelease(PathComponent);
  CFRelease(v16);
  return v20;
}

const void *_CFErrorCreateLocalizedFailureReason(_QWORD *a1)
{
  return _CFErrorCopyUserInfoKey(a1, CFSTR("NSLocalizedFailureReason"));
}

void sub_182B83B54(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182B842CC(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  char v13;
  const char *v14;
  char v15;
  const char *v16;

  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary replaceObject:forKey:](theDict, "replaceObject:forKey:", value, key);
  }
  else
  {
    v12 = atomic_load((unint64_t *)theDict + 1);
    if ((v12 & 0x40) != 0)
      CFLog(3, (uint64_t)CFSTR("%s(): immutable collection %p given to mutating function"), v6, v7, v8, v9, v10, v11, (__int16)"void CFDictionaryReplaceValue(CFMutableDictionaryRef, const void *, const void *)");
    v13 = atomic_load((unint64_t *)theDict + 1);
    if ((v13 & 1) != 0)
    {
      v14 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        v14 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v14;
      }
      objc_msgSend(theDict, v14, key);
    }
    CFBasicHashReplaceValue((unint64_t)theDict, (unint64_t)key, (uint64_t)value);
    v15 = atomic_load((unint64_t *)theDict + 1);
    if ((v15 & 1) != 0)
    {
      v16 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        v16 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v16;
      }
      objc_msgSend(theDict, v16, key);
    }
  }
}

unint64_t CFBasicHashReplaceValue(unint64_t result, unint64_t a2, uint64_t a3)
{
  char v3;
  uint64_t v6;
  int v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v3 = atomic_load((unint64_t *)(result + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809 || a3 == 2814029233)
    goto LABEL_24;
  v6 = result;
  v8 = 0u;
  v9 = 0u;
  if (*(_BYTE *)(result + 26))
  {
    v7 = *(_WORD *)(result + 18) & 3;
    if ((*(_WORD *)(result + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          result = ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v8);
          break;
        case 2:
          result = ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v8);
          break;
        case 1:
          result = ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v8);
          break;
        default:
          goto LABEL_24;
      }
    }
    else if (v7 == 3)
    {
      result = ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v8);
    }
    else
    {
      if (v7 != 2)
      {
        if (v7 == 1)
        {
          result = ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v8);
          goto LABEL_21;
        }
LABEL_24:
        __break(1u);
      }
      result = ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v8);
    }
  }
  else
  {
    v8 = xmmword_182DC7A10;
    v9 = unk_182DC7A20;
  }
LABEL_21:
  if (*((_QWORD *)&v9 + 1))
    return __CFBasicHashReplaceValue(v6, v8, a2, a3);
  return result;
}

void CFReadStreamScheduleWithRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      -[__CFReadStream _scheduleInCFRunLoop:forMode:](stream, "_scheduleInCFRunLoop:forMode:", runLoop, runLoopMode);
    else
      -[__CFReadStream scheduleInRunLoop:forMode:](stream, "scheduleInRunLoop:forMode:", _CFRunLoopGet2((uint64_t)runLoop), runLoopMode);
  }
  else
  {
    _CFStreamScheduleWithRunLoop((char *)stream, runLoop, runLoopMode);
  }
}

id _CFURLComponentsCopyQuery(void *a1)
{
  return (id)objc_msgSend(a1, "query");
}

Boolean CFReadStreamSetClient(CFReadStreamRef stream, CFOptionFlags streamEvents, CFReadStreamClientCallBack clientCB, CFStreamClientContext *clientContext)
{
  _CFStreamDelegate *v9;
  const void *v10;

  if (!CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
    return _CFStreamSetClient(stream, streamEvents & 0xFFFFFFFFFFFFFFFBLL, (uint64_t)clientCB, (uint64_t)clientContext);
  if ((objc_opt_respondsToSelector() & 1) != 0)
    return -[__CFReadStream _setCFClientFlags:callback:context:](stream, "_setCFClientFlags:callback:context:", streamEvents, clientCB, clientContext);
  if (clientCB)
  {
    v9 = -[_CFStreamDelegate initWithStreamEvents:callback:context:]([_CFStreamDelegate alloc], "initWithStreamEvents:callback:context:", streamEvents, clientCB, clientContext);
    -[__CFReadStream setDelegate:](stream, "setDelegate:", v9);
    v10 = (const void *)objc_opt_class();
    objc_setAssociatedObject(stream, v10, v9, (void *)0x301);

  }
  else
  {
    -[__CFReadStream setDelegate:](stream, "setDelegate:", 0);
  }
  return 1;
}

uint64_t _CFStreamSetClient(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v6;
  BOOL v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(_QWORD);
  uint64_t v14;
  uint64_t (*v15)(void);
  uint64_t v16;
  void (*v17)(_QWORD *, uint64_t, _QWORD);

  if (a2)
    v6 = a3 == 0;
  else
    v6 = 1;
  v7 = v6 || a4 == 0;
  v8 = v7;
  if (v7)
    v9 = 0;
  else
    v9 = a2;
  if (v7)
    v10 = 0;
  else
    v10 = a3;
  v11 = a1[4];
  if (v11)
  {
LABEL_17:
    if (*(_QWORD *)(v11 + 40))
    {
      v12 = *(void (**)(_QWORD))(v11 + 24);
      if (v12)
      {
        v12(*(_QWORD *)(v11 + 8));
        v11 = a1[4];
      }
    }
    *(_QWORD *)(v11 + 40) = v10;
    if ((v8 & 1) != 0)
    {
      *(_OWORD *)(v11 + 24) = 0u;
      *(_OWORD *)(v11 + 8) = 0u;
    }
    else
    {
      *(_OWORD *)(v11 + 16) = *(_OWORD *)(a4 + 16);
      v14 = *(_QWORD *)(a4 + 8);
      *(_QWORD *)v11 = *(_QWORD *)a4;
      *(_QWORD *)(v11 + 32) = *(_QWORD *)(a4 + 32);
      v15 = *(uint64_t (**)(void))(a4 + 16);
      if (v15 && v14)
      {
        v14 = v15();
        v11 = a1[4];
      }
      *(_QWORD *)(v11 + 8) = v14;
    }
    if (*(_QWORD *)(v11 + 48) != v9)
    {
      v16 = a1[6];
      *(_QWORD *)(v11 + 48) = v9;
      v17 = *(void (**)(_QWORD *, uint64_t, _QWORD))(v16 + 112);
      if (v17)
        v17(a1, v9, a1[5]);
    }
    return 1;
  }
  if ((v8 & 1) == 0)
  {
    _initializeClient(a1);
    v11 = a1[4];
    if (!v11)
      return 0;
    goto LABEL_17;
  }
  return 1;
}

double _initializeClient(_QWORD *a1)
{
  CFAllocatorRef v2;
  _OWORD *Typed;
  double result;

  v2 = CFGetAllocator(a1);
  Typed = (_OWORD *)CFAllocatorAllocateTyped(v2, 80, 0x10A00402EE2ECADLL, 0);
  a1[4] = Typed;
  result = 0.0;
  *Typed = 0u;
  Typed[1] = 0u;
  Typed[2] = 0u;
  Typed[3] = 0u;
  Typed[4] = 0u;
  return result;
}

Boolean CFWriteStreamSetClient(CFWriteStreamRef stream, CFOptionFlags streamEvents, CFWriteStreamClientCallBack clientCB, CFStreamClientContext *clientContext)
{
  _CFStreamDelegate *v9;
  const void *v10;

  if (!CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
    return _CFStreamSetClient(stream, streamEvents & 0xFFFFFFFFFFFFFFFDLL, (uint64_t)clientCB, (uint64_t)clientContext);
  if ((objc_opt_respondsToSelector() & 1) != 0)
    return -[__CFWriteStream _setCFClientFlags:callback:context:](stream, "_setCFClientFlags:callback:context:", streamEvents, clientCB, clientContext);
  if (clientCB)
  {
    v9 = -[_CFStreamDelegate initWithStreamEvents:callback:context:]([_CFStreamDelegate alloc], "initWithStreamEvents:callback:context:", streamEvents, clientCB, clientContext);
    -[__CFWriteStream setDelegate:](stream, "setDelegate:", v9);
    v10 = (const void *)objc_opt_class();
    objc_setAssociatedObject(stream, v10, v9, (void *)0x301);

  }
  else
  {
    -[__CFWriteStream setDelegate:](stream, "setDelegate:", 0);
  }
  return 1;
}

os_log_t __makeLogHandles_block_invoke()
{
  os_log_t result;

  clientHandle = (uint64_t)os_log_create("com.apple.defaults", "User Defaults");
  result = os_log_create("com.apple.defaults", "cfprefsd");
  daemonHandle = (uint64_t)result;
  return result;
}

uint64_t _CFXNotificationGetTaskCenter()
{
  if (CFNotificationCenterGetLocalCenter_static_init != -1)
    dispatch_once(&CFNotificationCenterGetLocalCenter_static_init, &__block_literal_global_7);
  return __taskCenter;
}

void _CFNotificationCenterRegisterDependentNotificationList(__CFString ****a1)
{
  uint64_t v2;

  os_unfair_lock_lock((os_unfair_lock_t)&_dependentNotificationLock);
  v2 = 0;
  while ((&_unprocessedDependentNotificationLists)[v2])
  {
    if (++v2 == 8)
      _CFNotificationCenterRegisterDependentNotificationList_cold_1();
  }
  (&_unprocessedDependentNotificationLists)[v2] = a1;
  os_unfair_lock_unlock((os_unfair_lock_t)&_dependentNotificationLock);
}

uint64_t _CFURLComponentsSetPercentEncodedQuery(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setPercentEncodedQuery:", a2);
  return 1;
}

void sub_182B85AE0(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
  JUMPOUT(0x182B85AD8);
}

uint64_t __CFArrayCreateCopy0(__objc2_class **a1, unint64_t *a2)
{
  uint64_t v4;
  const CFArrayCallBacks *v5;
  uint64_t Init;
  uint64_t v7;
  unsigned int v8;
  int v9;
  const CFArrayCallBacks *v10;
  unsigned int v11;
  int v12;
  char v13;
  int v14;
  const CFArrayCallBacks *v15;
  char v16;
  int v17;
  char v18;
  int v19;
  char v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t i;
  uint64_t v25;
  uint64_t (*retain)(__objc2_class **, uint64_t);

  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)a2))
    v4 = objc_msgSend(a2, "count");
  else
    v4 = a2[2];
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)a2))
  {
LABEL_5:
    v5 = &kCFTypeArrayCallBacks;
    goto LABEL_6;
  }
  v11 = atomic_load(a2 + 1);
  v12 = (v11 >> 2) & 3;
  if (v12)
  {
    if (v12 != 1)
    {
      v13 = atomic_load(a2 + 1);
      v14 = v13 & 3;
      if (v14)
        v15 = 0;
      else
        v15 = (const CFArrayCallBacks *)(a2 + 6);
      if (v14 == 2)
        v5 = (const CFArrayCallBacks *)(a2 + 6);
      else
        v5 = v15;
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  v5 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
LABEL_6:
  Init = __CFArrayCreateInit(a1, 0, v4, v5);
  v7 = Init;
  v8 = atomic_load((unint64_t *)(Init + 8));
  v9 = (v8 >> 2) & 3;
  if (v9)
  {
    if (v9 == 1)
    {
      v10 = &kCFTypeArrayCallBacks;
    }
    else
    {
      v16 = atomic_load((unint64_t *)(Init + 8));
      v17 = v16 & 3;
      if (v17 != 2 && v17)
        v10 = 0;
      else
        v10 = (const CFArrayCallBacks *)(Init + 48);
    }
  }
  else
  {
    v10 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  v18 = atomic_load((unint64_t *)(Init + 8));
  v19 = v18 & 3;
  if (v19 == 2)
  {
    v23 = *(_QWORD *)(Init + 40) + 8 * **(_QWORD **)(Init + 40) + 16;
  }
  else if (v19)
  {
    v23 = 0;
  }
  else
  {
    v20 = atomic_load((unint64_t *)(Init + 8));
    v21 = (~v20 & 0xC) == 0;
    v22 = 48;
    if (v21)
      v22 = 88;
    v23 = Init + v22;
  }
  if (v4 >= 1)
  {
    for (i = 0; i != v4; ++i)
    {
      v25 = objc_msgSend(a2, "objectAtIndex:", i);
      retain = (uint64_t (*)(__objc2_class **, uint64_t))v10->retain;
      if (retain)
        v25 = retain(a1, v25);
      *(_QWORD *)(v23 + 8 * i) = v25;
    }
  }
  *(_QWORD *)(v7 + 16) = v4;
  return v7;
}

unint64_t *_CFURLCreateFromComponents(CFAllocatorRef alloc, uint64_t a2, uint64_t a3)
{
  const __CFString *v5;
  CFIndex v6;
  const __CFString *Length;
  __CFString *MutableCopy;
  const __CFString *v9;
  __CFString *Mutable;
  CFStringRef v11;
  const __CFURL *v12;
  __CFString *v13;
  int v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFArray *v18;
  const __CFString *ValueAtIndex;
  const __CFArray *v20;
  const __CFString *v21;
  __objc2_class **v22;
  const __CFString *v23;
  const __CFURL *v24;
  const __CFString *v25;
  uint64_t v26;
  const __CFArray *v27;
  const __CFString *v28;
  const __CFArray *v29;
  const __CFString *v30;
  unint64_t *v31;
  UniChar chars;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a2 == 2)
  {
    Mutable = CFStringCreateMutable(alloc, 0);
    MutableCopy = Mutable;
    v11 = *(CFStringRef *)a3;
    if (*(_QWORD *)a3)
    {
      CFStringAppend(Mutable, *(CFStringRef *)a3);
      CFStringAppend(MutableCopy, CFSTR("://"));
      v12 = 0;
    }
    else
    {
      v12 = *(const __CFURL **)(a3 + 56);
    }
    v15 = *(const __CFString **)(a3 + 8);
    if (v15)
    {
      CFStringAppend(MutableCopy, v15);
      CFStringAppend(MutableCopy, CFSTR("@"));
      v16 = *(const __CFString **)(a3 + 16);
      if (!v16)
      {
LABEL_26:
        v18 = *(const __CFArray **)(a3 + 32);
        if (!v18
          || (ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v18, 0), CFStringGetLength(ValueAtIndex)))
        {
          CFStringAppend(MutableCopy, CFSTR("/"));
        }
LABEL_29:
        v20 = *(const __CFArray **)(a3 + 32);
        if (v20)
        {
          v21 = CFStringCreateByCombiningStrings(alloc, v20, CFSTR("/"));
          CFStringAppend(MutableCopy, v21);
          CFRelease(v21);
        }
        if (*(_QWORD *)(a3 + 40))
        {
          CFStringAppend(MutableCopy, CFSTR("?"));
          CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 40));
        }
        if (*(_QWORD *)(a3 + 48))
        {
          CFStringAppend(MutableCopy, CFSTR("#"));
          CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 48));
        }
        if (!MutableCopy)
          goto LABEL_58;
LABEL_36:
        v22 = (__objc2_class **)alloc;
        v23 = MutableCopy;
        v24 = v12;
LABEL_62:
        v31 = _CFURLCreateWithURLString(v22, v23, 1, v24);
        goto LABEL_63;
      }
    }
    else
    {
      v16 = *(const __CFString **)(a3 + 16);
      if (!v16)
      {
        if (!v11)
          goto LABEL_29;
        goto LABEL_26;
      }
    }
    CFStringAppend(MutableCopy, v16);
    if (*(_QWORD *)(a3 + 24) != -1)
      CFStringAppendFormat(MutableCopy, 0, CFSTR(":%ld"), *(_QWORD *)(a3 + 24));
    goto LABEL_26;
  }
  if (a2 != 1)
  {
    if (!a2)
    {
      v5 = *(const __CFString **)a3;
      if (*(_QWORD *)a3)
      {
        chars = 58;
        v6 = CFStringGetLength(v5) + 1;
        Length = *(const __CFString **)(a3 + 8);
        if (Length)
          Length = (const __CFString *)CFStringGetLength(Length);
        MutableCopy = CFStringCreateMutableCopy(alloc, (CFIndex)Length + v6, *(CFStringRef *)a3);
        CFStringAppendCharacters(MutableCopy, &chars, 1);
        v9 = *(const __CFString **)(a3 + 8);
        if (v9)
          CFStringAppend(MutableCopy, v9);
        if (!MutableCopy)
          return 0;
        goto LABEL_61;
      }
      MutableCopy = *(__CFString **)(a3 + 8);
      if (MutableCopy)
      {
        CFRetain(*(CFTypeRef *)(a3 + 8));
LABEL_61:
        v22 = (__objc2_class **)alloc;
        v23 = MutableCopy;
        v24 = 0;
        goto LABEL_62;
      }
    }
    return 0;
  }
  v13 = CFStringCreateMutable(alloc, 0);
  MutableCopy = v13;
  if (*(_QWORD *)a3)
  {
    CFStringAppend(v13, *(CFStringRef *)a3);
    CFStringAppend(MutableCopy, CFSTR("://"));
    v12 = 0;
    v14 = 1;
  }
  else
  {
    v14 = 0;
    v12 = *(const __CFURL **)(a3 + 72);
  }
  v17 = *(const __CFString **)(a3 + 8);
  if (v17)
  {
    CFStringAppend(MutableCopy, v17);
    if (!*(_QWORD *)(a3 + 16))
      goto LABEL_39;
  }
  else if (!*(_QWORD *)(a3 + 16))
  {
    goto LABEL_40;
  }
  CFStringAppend(MutableCopy, CFSTR(":"));
  CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 16));
LABEL_39:
  CFStringAppend(MutableCopy, CFSTR("@"));
  v14 = 1;
LABEL_40:
  v25 = *(const __CFString **)(a3 + 24);
  if (v25)
  {
    CFStringAppend(MutableCopy, v25);
    v26 = *(_QWORD *)(a3 + 32);
    if (v26 == -1)
      goto LABEL_45;
  }
  else
  {
    v26 = *(_QWORD *)(a3 + 32);
    if (v26 == -1)
    {
      if (!v14)
        goto LABEL_49;
      goto LABEL_45;
    }
  }
  CFStringAppendFormat(MutableCopy, 0, CFSTR(":%ld"), v26);
LABEL_45:
  v27 = *(const __CFArray **)(a3 + 40);
  if (!v27
    || !CFArrayGetCount(v27)
    || (v28 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 40), 0), CFStringGetLength(v28)))
  {
    CFStringAppend(MutableCopy, CFSTR("/"));
  }
LABEL_49:
  v29 = *(const __CFArray **)(a3 + 40);
  if (v29)
  {
    v30 = CFStringCreateByCombiningStrings(alloc, v29, CFSTR("/"));
    CFStringAppend(MutableCopy, v30);
    CFRelease(v30);
  }
  if (*(_QWORD *)(a3 + 48))
  {
    CFStringAppend(MutableCopy, CFSTR(";"));
    CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 48));
  }
  if (*(_QWORD *)(a3 + 56))
  {
    CFStringAppend(MutableCopy, CFSTR("?"));
    CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 56));
  }
  if (*(_QWORD *)(a3 + 64))
  {
    CFStringAppend(MutableCopy, CFSTR("#"));
    CFStringAppend(MutableCopy, *(CFStringRef *)(a3 + 64));
  }
  if (MutableCopy)
    goto LABEL_36;
LABEL_58:
  v31 = 0;
LABEL_63:
  CFRelease(MutableCopy);
  return v31;
}

uint64_t ___plistSizeIsAppropriateToRead_block_invoke()
{
  const void *v0;
  uint64_t result;

  v0 = (const void *)_CFProcessNameString();
  result = CFEqual(v0, CFSTR("localizationswitcherd"));
  if ((_DWORD)result)
    _plistSizeIsAppropriateToRead_isSizeLimitedProcess = 1;
  return result;
}

uint64_t _CFProcessNameString()
{
  uint64_t v0;
  const char *v1;
  CFStringRef v2;

  if (!_CFProcessNameString___CFProcessNameString)
  {
    v0 = __CFprogname;
    if (!__CFprogname)
    {
      _CFProcessPath();
      v0 = __CFprogname;
    }
    if (v0)
      v1 = (const char *)v0;
    else
      v1 = "";
    v2 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, 0x8000100u);
    while (!__ldaxr((unint64_t *)&_CFProcessNameString___CFProcessNameString))
    {
      if (!__stlxr((unint64_t)v2, (unint64_t *)&_CFProcessNameString___CFProcessNameString))
        return _CFProcessNameString___CFProcessNameString;
    }
    __clrex();
    CFRelease(v2);
  }
  return _CFProcessNameString___CFProcessNameString;
}

void CFStringPad(CFMutableStringRef theString, CFStringRef padString, CFIndex length, CFIndex indexIntoPad)
{
  uint64_t *p_info;
  char v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  char **p_data;
  char *v23;
  uint64_t data;
  uint64_t v25;
  uint64_t v26;
  CFIndex v27;
  char v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  char **v32;
  char *v33;
  uint64_t v34;
  char v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t Bytes;
  char v39;
  char **v40;
  char *v41;
  char v42;
  unint64_t v43;
  CFIndex v44;
  UniChar *v45;
  CFStringEncoding v46;
  CFIndex v47;
  uint64_t v48;
  uint64_t v49;
  CFRange v50;
  CFRange v51;

  v49 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfPad:length:padIndex:](theString, "_cfPad:length:padIndex:", padString, length, indexIntoPad);
    return;
  }
  p_info = &theString->info;
  v9 = atomic_load((unint64_t *)&theString->info);
  if ((v9 & 1) == 0)
  {
    v10 = _CFOSLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      CFStringPad_cold_1(v10, v11, v12, v13, v14, v15, v16, v17);
    return;
  }
  v18 = atomic_load((unint64_t *)p_info);
  v19 = v18 & 5;
  v20 = atomic_load((unint64_t *)p_info);
  v21 = v20 & 0x60;
  if (v19 == 4)
  {
    p_data = &theString->data;
    if (v21)
    {
      v23 = *p_data;
    }
    else
    {
      v25 = atomic_load((unint64_t *)&theString->info);
      v23 = (char *)&p_data[(v25 & 5) != 4];
    }
    data = *v23;
  }
  else if ((v20 & 0x60) != 0)
  {
    data = theString->length;
  }
  else
  {
    data = (uint64_t)theString->data;
  }
  if (data > length)
  {
    v47 = length;
    v48 = data - length;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v47, 1, 0, 0);
    return;
  }
  if (data < length)
  {
    v26 = length - data;
    if (CF_IS_OBJC(7uLL, (__objc2_class **)padString))
    {
      v27 = CFStringGetLength(padString);
    }
    else
    {
      v28 = atomic_load((unint64_t *)&padString->info);
      v29 = v28 & 5;
      v30 = atomic_load((unint64_t *)&padString->info);
      v31 = v30 & 0x60;
      if (v29 == 4)
      {
        v32 = &padString->data;
        if (v31)
        {
          v33 = *v32;
        }
        else
        {
          v34 = atomic_load((unint64_t *)&padString->info);
          v33 = (char *)&v32[(v34 & 5) != 4];
        }
        v27 = *v33;
      }
      else if ((v30 & 0x60) != 0)
      {
        v27 = padString->length;
      }
      else
      {
        v27 = (CFIndex)padString->data;
      }
      v35 = atomic_load((unint64_t *)&theString->info);
      if ((v35 & 0x10) == 0)
      {
        v36 = atomic_load((unint64_t *)&padString->info);
        v37 = (v36 >> 4) & 1;
        goto LABEL_30;
      }
    }
    LODWORD(v37) = 1;
LABEL_30:
    v47 = data;
    v48 = 0;
    Bytes = __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v47, 1, v26, v37);
    v39 = atomic_load((unint64_t *)&theString->info);
    v40 = &theString->data;
    if ((v39 & 0x60) != 0)
    {
      v41 = *v40;
    }
    else
    {
      v42 = atomic_load((unint64_t *)&theString->info);
      v41 = (char *)&v40[(v42 & 5) != 4];
    }
    v43 = atomic_load((unint64_t *)&theString->info);
    if (v26 >= 1)
    {
      if (v26 >= v27 - indexIntoPad)
        v44 = v27 - indexIntoPad;
      else
        v44 = v26;
      v45 = (UniChar *)&v41[(data << v37) + ((v43 >> 2) & 1)];
      do
      {
        if ((_DWORD)v37)
        {
          v50.location = indexIntoPad;
          v50.length = v44;
          CFStringGetCharacters(padString, v50, v45);
        }
        else
        {
          v46 = __CFDefaultEightBitStringEncoding;
          if (__CFDefaultEightBitStringEncoding == -1)
          {
            __CFStringComputeEightBitStringEncoding(Bytes);
            v46 = __CFDefaultEightBitStringEncoding;
          }
          v51.location = indexIntoPad;
          v51.length = v44;
          Bytes = CFStringGetBytes(padString, v51, v46, 0, 0, (UInt8 *)v45, v26, 0);
        }
        indexIntoPad = 0;
        v45 = (UniChar *)((char *)v45 + (v44 << v37));
        v26 -= v44;
        if (v26 >= v44)
          v44 = v27;
        else
          v44 = v26;
      }
      while (v26 > 0);
    }
  }
}

CFDateRef CFDateFormatterCreateDateFromString(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep)
{
  const __CFAllocator *v7;
  uint64_t v8;
  unint64_t v9;
  CFAbsoluteTime at[2];

  v7 = allocator;
  at[1] = *(CFAbsoluteTime *)MEMORY[0x1E0C80C00];
  if (!allocator)
  {
    v8 = _CFGetTSD(1u);
    if (v8)
      v7 = (const __CFAllocator *)v8;
    else
      v7 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  v9 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v9 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v9);
  at[0] = 0.0;
  if (CFDateFormatterGetAbsoluteTimeFromString(formatter, string, rangep, at))
    return CFDateCreate(v7, at[0]);
  else
    return 0;
}

Boolean CFDateFormatterGetAbsoluteTimeFromString(CFDateFormatterRef formatter, CFStringRef string, CFRange *rangep, CFAbsoluteTime *atp)
{
  unint64_t v8;
  CFIndex length;
  CFIndex location;
  CFIndex v11;
  const UniChar *CharactersPtr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  UChar *v16;
  const void *v17;
  uint64_t Calendar;
  const void *v19;
  CFTypeRef v20;
  uint64_t v21;
  int v22;
  double Now;
  int v24;
  const __CFDate *v25;
  CFAbsoluteTime AbsoluteTime;
  double Millis;
  const __CFNumber *v28;
  double v29;
  int v30;
  int v31;
  double v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  const void *v38;
  double v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  double v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  double v49;
  double v50;
  uint64_t v51;
  BOOL v52;
  uint64_t v53;
  double v54;
  int v55;
  Boolean v56;
  unsigned int v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD valuePtr[2];
  CFRange v63;

  valuePtr[1] = *MEMORY[0x1E0C80C00];
  v8 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v8 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v8);
  if (rangep)
  {
    location = rangep->location;
    length = rangep->length;
  }
  else
  {
    length = CFStringGetLength(string);
    location = 0;
  }
  if (length >= 1024)
    v11 = 1024;
  else
    v11 = length;
  CharactersPtr = CFStringGetCharactersPtr(string);
  v14 = MEMORY[0x1E0C80A78](CharactersPtr, v13);
  v16 = (UChar *)((char *)&v60 - v15);
  if (v14)
  {
    v16 = (UChar *)(v14 + 2 * location);
  }
  else
  {
    v63.location = location;
    v63.length = v11;
    CFStringGetCharacters(string, v63, (UniChar *)((char *)&v60 - v15));
  }
  v61 = 0;
  v17 = (const void *)__cficu_udat_clone(*((_QWORD *)formatter + 2), (int *)&v61);
  Calendar = __cficu_udat_getCalendar((uint64_t)v17);
  v19 = (const void *)__cficu_ucal_clone(Calendar, (int *)&v61);
  v20 = CFDateFormatterCopyProperty(formatter, CFSTR("kCFDateFormatterCalendarIdentifierKey"));
  if (CFEqual(v20, CFSTR("chinese")) || CFEqual(v20, CFSTR("japanese")))
  {
    if (CFEqual(v20, CFSTR("chinese")))
    {
      __cficu_ucal_clear((uint64_t)v19);
      v21 = (uint64_t)v19;
      v22 = 1;
    }
    else
    {
      if (!CFEqual(v20, CFSTR("japanese")))
        goto LABEL_18;
      Now = __cficu_ucal_getNow();
      __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, Now);
      v24 = __cficu_ucal_get((uint64_t)v19, 0, (int *)&v61);
      __cficu_ucal_clear((uint64_t)v19);
      v21 = (uint64_t)v19;
      v22 = v24;
    }
    __cficu_ucal_set(v21, 0, v22);
  }
  else
  {
    __cficu_ucal_clear((uint64_t)v19);
    __cficu_ucal_set((uint64_t)v19, 1u, 12000);
    __cficu_udat_set2DigitYearStart((uint64_t)v17, (int *)&v61, 3.16516205e14);
  }
LABEL_18:
  v25 = (const __CFDate *)*((_QWORD *)formatter + 15);
  if (v25)
  {
    AbsoluteTime = CFDateGetAbsoluteTime(v25);
    __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, (AbsoluteTime + 978307200.0) * 1000.0);
  }
  __cficu_udat_parseCalendar((uint64_t)v17, (uint64_t)v19, v16, v11, (unsigned int *)&v61 + 1, (int *)&v61);
  Millis = __cficu_ucal_getMillis((uint64_t)v19, (int *)&v61);
  if (rangep)
    rangep->length = SHIDWORD(v61);
  if ((int)v61 > 0)
    goto LABEL_74;
  valuePtr[0] = 1;
  v28 = (const __CFNumber *)*((_QWORD *)formatter + 37);
  if (v28)
    CFNumberGetValue(v28, kCFNumberSInt64Type, valuePtr);
  if (CFEqual(v20, CFSTR("chinese")))
  {
    if ((int)__cficu_ucal_get((uint64_t)v19, 0, (int *)&v61) > 9)
      goto LABEL_73;
    switch(valuePtr[0])
    {
      case 0:
        goto LABEL_74;
      case 2:
        v29 = __cficu_ucal_getNow();
        __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, v29);
        v30 = __cficu_ucal_get((uint64_t)v19, 0, (int *)&v61);
        goto LABEL_66;
      case 3:
        v43 = (uint64_t)v19;
        v44 = Millis;
        v45 = 60;
        v46 = 29;
        v47 = 30;
        break;
      case 4:
        v43 = (uint64_t)v19;
        v44 = Millis;
        v45 = 60;
        v46 = 0;
        v47 = 59;
        break;
      case 5:
        v43 = (uint64_t)v19;
        v44 = Millis;
        v45 = 60;
        v46 = 59;
        v47 = 0;
        break;
      case 6:
        v43 = (uint64_t)v19;
        v44 = Millis;
        v45 = 60;
        v46 = 10;
        v47 = 49;
        break;
      case 7:
        v43 = (uint64_t)v19;
        v44 = Millis;
        v45 = 60;
        v46 = 49;
        v47 = 10;
        break;
      default:
        goto LABEL_73;
    }
    v48 = 1;
LABEL_45:
    v49 = __CFDateFormatterCorrectTimeToARangeAroundCurrentDate(v43, v45, v46, v47, v48, (int *)&v61, v44);
  }
  else if (CFEqual(v20, CFSTR("japanese")))
  {
    __cficu_ucal_clear((uint64_t)v19);
    __cficu_ucal_set((uint64_t)v19, 0, 1);
    __cficu_udat_parseCalendar((uint64_t)v17, (uint64_t)v19, v16, v11, 0, (int *)&v61);
    if (__cficu_ucal_getMillis((uint64_t)v19, (int *)&v61) == Millis)
      goto LABEL_73;
    __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, Millis);
    v31 = __cficu_ucal_get((uint64_t)v19, 1u, (int *)&v61);
    v32 = __cficu_ucal_getNow();
    __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, v32);
    v33 = __cficu_ucal_get((uint64_t)v19, 1u, (int *)&v61);
    v34 = __cficu_ucal_get((uint64_t)v19, 0, (int *)&v61);
    v30 = v34;
    switch(valuePtr[0])
    {
      case 0:
        goto LABEL_74;
      case 2:
        goto LABEL_66;
      case 4:
        if (v31 < v33)
          goto LABEL_74;
        goto LABEL_66;
      case 5:
        if (v31 <= v33)
          goto LABEL_66;
        if (v34 < 235)
          goto LABEL_74;
        v51 = (v34 - 1);
        break;
      case 6:
        if (v31 < v33 - 10)
          goto LABEL_74;
        goto LABEL_66;
      case 7:
        if (v31 <= v33 + 10)
        {
LABEL_66:
          v53 = (uint64_t)v19;
          v54 = Millis;
          goto LABEL_67;
        }
        if (v34 < 235)
          goto LABEL_74;
        v51 = (v34 - 1);
        do
        {
          if (v31 <= (int)__CFDateFormatterGetMaxYearGivenJapaneseEra((uint64_t)v19, v51, (int *)&v61))
            goto LABEL_81;
          v52 = v51-- < 235;
        }
        while (!v52);
        goto LABEL_74;
      default:
        goto LABEL_73;
    }
    while (v31 > (int)__CFDateFormatterGetMaxYearGivenJapaneseEra((uint64_t)v19, v51, (int *)&v61))
    {
      v52 = v51-- < 235;
      if (v52)
        goto LABEL_74;
    }
LABEL_81:
    v53 = (uint64_t)v19;
    v54 = Millis;
    v30 = v51;
LABEL_67:
    v55 = 1;
LABEL_68:
    v49 = __CFDateFormatterCorrectTimeWithTarget(v53, v30, v55, (int *)&v61, v54);
  }
  else
  {
    v35 = __cficu_ucal_get((uint64_t)v19, 1u, (int *)&v61);
    v36 = v35 - 12000;
    if ((v35 - 12000) > 0x63)
      goto LABEL_73;
    v37 = v35;
    if (!*((_QWORD *)formatter + 14))
    {
      switch(valuePtr[0])
      {
        case 0:
          goto LABEL_74;
        case 2:
          v50 = __cficu_ucal_getNow();
          __cficu_ucal_setMillis((uint64_t)v19, (int *)&v61, v50);
          v30 = (unsigned __int16)v37 % 0x64u + 100 * ((int)__cficu_ucal_get((uint64_t)v19, 1u, (int *)&v61) / 100);
          goto LABEL_87;
        case 3:
          v43 = (uint64_t)v19;
          v44 = Millis;
          v45 = 100;
          v46 = 50;
          v48 = 0;
          v47 = 49;
          goto LABEL_45;
        case 4:
          v43 = (uint64_t)v19;
          v44 = Millis;
          v45 = 100;
          v46 = 0;
          v47 = 99;
          goto LABEL_92;
        case 5:
          v43 = (uint64_t)v19;
          v44 = Millis;
          v45 = 100;
          v46 = 99;
          v47 = 0;
LABEL_92:
          v48 = 0;
          goto LABEL_45;
        case 6:
          v43 = (uint64_t)v19;
          v44 = Millis;
          v45 = 100;
          v46 = 9;
          v48 = 0;
          v47 = 90;
          goto LABEL_45;
        case 7:
          v43 = (uint64_t)v19;
          v44 = Millis;
          v45 = 100;
          v46 = 90;
          v48 = 0;
          v47 = 9;
          goto LABEL_45;
        default:
          if (!CFEqual(v20, CFSTR("gregorian")))
            goto LABEL_73;
          v58 = (unsigned __int16)v37 % 0x64u;
          if (v58 >= 0x32)
            v59 = 1900;
          else
            v59 = 2000;
          v30 = v59 + v58;
LABEL_87:
          v53 = (uint64_t)v19;
          v54 = Millis;
          v55 = 0;
          goto LABEL_68;
      }
    }
    v38 = (const void *)__cficu_ucal_clone((uint64_t)v19, (int *)&v61);
    __cficu_ucal_clear((uint64_t)v38);
    v39 = (CFDateGetAbsoluteTime(*((CFDateRef *)formatter + 14)) + 978307200.0) * 1000.0;
    __cficu_ucal_setMillis((uint64_t)v38, (int *)&v61, v39);
    v40 = __cficu_ucal_get((uint64_t)v38, 1u, (int *)&v61);
    v41 = v40;
    v42 = v40 % 100;
    if (v40 % 100 >= v36)
    {
      if (v36 >= v42)
      {
        __cficu_ucal_set((uint64_t)v19, 1u, v40);
        if (__cficu_ucal_getMillis((uint64_t)v19, (int *)&v61) < v39)
          v41 += 100;
      }
      else
      {
        v41 = v37 + v40 - v42 - 11900;
      }
    }
    else
    {
      v41 = v40 + v36 - v42;
    }
    __cficu_ucal_close(v38);
    __cficu_ucal_set((uint64_t)v19, 1u, v41);
    v49 = __cficu_ucal_getMillis((uint64_t)v19, (int *)&v61);
  }
  Millis = v49;
LABEL_73:
  if ((int)v61 <= 0)
  {
    if (atp)
      *atp = Millis / 1000.0 - 978307200.0;
    v56 = 1;
    if (v20)
      goto LABEL_75;
    goto LABEL_76;
  }
LABEL_74:
  v56 = 0;
  if (v20)
LABEL_75:
    CFRelease(v20);
LABEL_76:
  __cficu_udat_close(v17);
  __cficu_ucal_close(v19);
  return v56;
}

uint64_t __cficu_ucal_clone(uint64_t a1, int *a2)
{
  uint64_t v4;
  const void *v5;
  CFStringRef v6;
  const void *v7;
  CFStringRef v8;
  NSObject *v9;
  int v11;
  const void *v12;
  __int16 v13;
  CFStringRef v14;
  __int16 v15;
  const void *v16;
  __int16 v17;
  CFStringRef v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v4 = ucal_clone();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"cal", v4);
      v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      v8 = ___CFICUCreateErrorStringWithComment(a2, 1);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v9 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v11 = 138413058;
        v12 = v5;
        v13 = 2112;
        v14 = v6;
        v15 = 2112;
        v16 = v7;
        v17 = 2112;
        v18 = v8;
        _os_log_debug_impl(&dword_182A8C000, v9, OS_LOG_TYPE_DEBUG, "UCalendar *%@ = ucal_clone(%@, &%@); %@",
          (uint8_t *)&v11,
          0x2Au);
      }
      CFRelease(v5);
      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
    }
  }
  return v4;
}

void __CFDateFormatterDeallocate(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const void *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  const void *v31;
  const void *v32;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  const void *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  const void *v48;
  const void *v49;
  const void *v50;
  const void *v51;
  const void *v52;
  const void *v53;
  const void *v54;
  const void *v55;
  const void *v56;
  const void *v57;
  const void *v58;
  const void *v59;
  const void *v60;
  const void *v61;

  v2 = (const void *)a1[2];
  if (v2)
    __cficu_udat_close(v2);
  v3 = (const void *)a1[3];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[6];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[7];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)a1[8];
  if (v6)
    CFRelease(v6);
  v7 = (const void *)a1[9];
  if (v7)
    CFRelease(v7);
  v8 = (const void *)a1[11];
  if (v8)
    CFRelease(v8);
  v9 = (const void *)a1[12];
  if (v9)
    CFRelease(v9);
  v10 = (const void *)a1[13];
  if (v10)
    CFRelease(v10);
  v11 = (const void *)a1[14];
  if (v11)
    CFRelease(v11);
  v12 = (const void *)a1[15];
  if (v12)
    CFRelease(v12);
  v13 = (const void *)a1[16];
  if (v13)
    CFRelease(v13);
  v14 = (const void *)a1[17];
  if (v14)
    CFRelease(v14);
  v15 = (const void *)a1[18];
  if (v15)
    CFRelease(v15);
  v16 = (const void *)a1[19];
  if (v16)
    CFRelease(v16);
  v17 = (const void *)a1[20];
  if (v17)
    CFRelease(v17);
  v18 = (const void *)a1[21];
  if (v18)
    CFRelease(v18);
  v19 = (const void *)a1[22];
  if (v19)
    CFRelease(v19);
  v20 = (const void *)a1[23];
  if (v20)
    CFRelease(v20);
  v21 = (const void *)a1[24];
  if (v21)
    CFRelease(v21);
  v22 = (const void *)a1[25];
  if (v22)
    CFRelease(v22);
  v23 = (const void *)a1[26];
  if (v23)
    CFRelease(v23);
  v24 = (const void *)a1[27];
  if (v24)
    CFRelease(v24);
  v25 = (const void *)a1[28];
  if (v25)
    CFRelease(v25);
  v26 = (const void *)a1[29];
  if (v26)
    CFRelease(v26);
  v27 = (const void *)a1[30];
  if (v27)
    CFRelease(v27);
  v28 = (const void *)a1[31];
  if (v28)
    CFRelease(v28);
  v29 = (const void *)a1[32];
  if (v29)
    CFRelease(v29);
  v30 = (const void *)a1[33];
  if (v30)
    CFRelease(v30);
  v31 = (const void *)a1[34];
  if (v31)
    CFRelease(v31);
  v32 = (const void *)a1[35];
  if (v32)
    CFRelease(v32);
  v33 = (const void *)a1[36];
  if (v33)
    CFRelease(v33);
  v34 = (const void *)a1[37];
  if (v34)
    CFRelease(v34);
  v35 = (const void *)a1[38];
  if (v35)
    CFRelease(v35);
  v36 = (const void *)a1[39];
  if (v36)
    CFRelease(v36);
  v37 = (const void *)a1[40];
  if (v37)
    CFRelease(v37);
  v38 = (const void *)a1[42];
  if (v38)
    CFRelease(v38);
  v39 = (const void *)a1[43];
  if (v39)
    CFRelease(v39);
  v40 = (const void *)a1[48];
  if (v40)
    CFRelease(v40);
  v41 = (const void *)a1[49];
  if (v41)
    CFRelease(v41);
  v42 = (const void *)a1[41];
  if (v42)
    CFRelease(v42);
  v43 = (const void *)a1[44];
  if (v43)
    CFRelease(v43);
  v44 = (const void *)a1[50];
  if (v44)
    CFRelease(v44);
  v45 = (const void *)a1[45];
  if (v45)
    CFRelease(v45);
  v46 = (const void *)a1[46];
  if (v46)
    CFRelease(v46);
  v47 = (const void *)a1[47];
  if (v47)
    CFRelease(v47);
  v48 = (const void *)a1[51];
  if (v48)
    CFRelease(v48);
  v49 = (const void *)a1[52];
  if (v49)
    CFRelease(v49);
  v50 = (const void *)a1[53];
  if (v50)
    CFRelease(v50);
  v51 = (const void *)a1[54];
  if (v51)
    CFRelease(v51);
  v52 = (const void *)a1[55];
  if (v52)
    CFRelease(v52);
  v53 = (const void *)a1[57];
  if (v53)
    CFRelease(v53);
  v54 = (const void *)a1[58];
  if (v54)
    CFRelease(v54);
  v55 = (const void *)a1[59];
  if (v55)
    CFRelease(v55);
  v56 = (const void *)a1[60];
  if (v56)
    CFRelease(v56);
  v57 = (const void *)a1[61];
  if (v57)
    CFRelease(v57);
  v58 = (const void *)a1[62];
  if (v58)
    CFRelease(v58);
  v59 = (const void *)a1[63];
  if (v59)
    CFRelease(v59);
  v60 = (const void *)a1[64];
  if (v60)
    CFRelease(v60);
  v61 = (const void *)a1[65];
  if (v61)
    CFRelease(v61);
}

void __cficu_udat_close(const void *a1)
{
  CFStringRef v2;

  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    udat_close();
    ___CFICULogWithArguments(1, CFSTR("udat_close(%@);"), v2);
    CFRelease(v2);
  }
  else
  {
    udat_close();
  }
}

double __cficu_ucal_getMillis(uint64_t a1, int *a2)
{
  double v4;
  double v5;
  CFStringRef v6;
  const void *v7;
  CFStringRef v8;
  NSObject *v9;
  int v11;
  CFStringRef v12;
  __int16 v13;
  const void *v14;
  __int16 v15;
  double v16;
  __int16 v17;
  CFStringRef v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  ucal_getMillis();
  v5 = v4;
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      v8 = ___CFICUCreateErrorStringWithComment(a2, 0);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v9 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v11 = 138413058;
        v12 = v6;
        v13 = 2112;
        v14 = v7;
        v15 = 2048;
        v16 = v5;
        v17 = 2112;
        v18 = v8;
        _os_log_debug_impl(&dword_182A8C000, v9, OS_LOG_TYPE_DEBUG, "ucal_getMillis(%@, &%@); // %f %@",
          (uint8_t *)&v11,
          0x2Au);
      }
      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
    }
  }
  return v5;
}

void __cficu_udat_parseCalendar(uint64_t a1, uint64_t a2, UChar *a3, uint64_t a4, unsigned int *a5, int *a6)
{
  CFStringRef v12;
  CFStringRef v13;
  CFStringRef v14;
  const void *v15;
  CFStringRef v16;
  CFStringRef v17;
  CFStringRef v18;
  uint64_t v19;

  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    v12 = ___CFICUCreateArgumentForParsePosition(a5);
    udat_parseCalendar();
    v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v14 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a2);
    v15 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    v17 = ___CFICUCreateArgumentForUCharInput(a3, a4, 0);
    v18 = v17;
    if (a5)
      v19 = *a5;
    else
      v19 = 0xFFFFFFFFLL;
    ___CFICULogWithArguments(1, CFSTR("udat_parseCalendar(%@, %@, %@, %d, %@, &%@); // %d %@"),
      v13,
      v14,
      v17,
      a4,
      v12,
      v15,
      v19,
      v16);
    CFRelease(v12);
    CFRelease(v15);
    CFRelease(v14);
    CFRelease(v13);
    CFRelease(v18);
    CFRelease(v16);
  }
  else
  {
    udat_parseCalendar();
  }
}

uint64_t __cficu_udat_clone(uint64_t a1, int *a2)
{
  uint64_t v4;
  const void *v5;
  CFStringRef v6;
  const void *v7;
  CFStringRef v8;

  v4 = udat_clone();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dateFmt", v4);
    v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    v8 = ___CFICUCreateErrorStringWithComment(a2, 1);
    ___CFICULogWithArguments(1, CFSTR("UDateFormat *%@ = udat_clone(%@, &%@); %@"), v5, v6, v7, v8);
    CFRelease(v5);
    CFRelease(v6);
    CFRelease(v7);
    CFRelease(v8);
  }
  return v4;
}

void __cficu_ucal_set(uint64_t a1, unsigned int a2, int a3)
{
  CFStringRef v6;
  NSObject *v7;
  int v8;
  CFStringRef v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  ucal_set();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v7 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v8 = 138412802;
        v9 = v6;
        v10 = 2080;
        v11 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        v12 = 1024;
        v13 = a3;
        _os_log_debug_impl(&dword_182A8C000, v7, OS_LOG_TYPE_DEBUG, "ucal_set(%@, %s, %d);", (uint8_t *)&v8, 0x1Cu);
      }
      CFRelease(v6);
    }
  }
}

void __cficu_ucal_clear(uint64_t a1)
{
  CFStringRef v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  MEMORY[0x186DB0C9C]();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v3 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
        __cficu_ucal_clear_cold_1((uint64_t)v2, v3, v4, v5, v6, v7, v8, v9);
      CFRelease(v2);
    }
  }
}

uint64_t __cficu_ucal_get(uint64_t a1, unsigned int a2, int *a3)
{
  uint64_t v6;
  CFStringRef v7;
  const void *v8;
  CFStringRef v9;
  NSObject *v10;
  int v12;
  CFStringRef v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const void *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  CFStringRef v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v6 = ucal_get();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      v9 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v10 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v12 = 138413314;
        v13 = v7;
        v14 = 2080;
        v15 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        v16 = 2112;
        v17 = v8;
        v18 = 1024;
        v19 = v6;
        v20 = 2112;
        v21 = v9;
        _os_log_debug_impl(&dword_182A8C000, v10, OS_LOG_TYPE_DEBUG, "ucal_get(%@, %s, &%@); // %d %@",
          (uint8_t *)&v12,
          0x30u);
      }
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }
  return v6;
}

void client_context_finalizer(uint64_t a1)
{
  os_unfair_lock_s *v1;
  uint64_t v2;
  const void *v3;
  void *v4;
  const void *v5;

  v1 = (os_unfair_lock_s *)(a1 + 48);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 48));
  v2 = a1;
  if (*(_BYTE *)(a1 + 57))
    client_context_finalizer_cold_1();
  v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    v2 = a1;
  }
  v4 = *(void **)(v2 + 32);
  if (v4)
  {
    xpc_release(v4);
    v2 = a1;
  }
  v5 = *(const void **)(v2 + 40);
  if (v5)
    CFRelease(v5);
  os_unfair_lock_unlock(v1);

}

CFBundleRef _CFBundleGetMainBundleIfLooksLikeBundle()
{
  CFBundleRef result;

  result = CFBundleGetMainBundle();
  if (result)
  {
    if (*((unsigned __int8 *)result + 53) - 3 < 2)
      return 0;
  }
  return result;
}

void _CFPrefsSetDirectModeEnabled(char a1)
{
  forceDirect = a1;
  _CFPrefsResetPreferences(1);
}

CFDictionaryRef _CFURLCopyPropertyListRepresentation(unint64_t *a1)
{
  const __CFAllocator *v2;
  unint64_t *v3;
  void *v4;
  const void *v5;
  void *v6;
  CFIndex v7;
  const void *v8;
  const __CFAllocator *v9;
  CFDictionaryRef v10;
  unint64_t v11;
  uint64_t v12;
  int valuePtr;
  void *values[2];
  __int128 v16;
  void *keys[5];

  keys[4] = *(void **)MEMORY[0x1E0C80C00];
  v2 = CFGetAllocator(a1);
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1))
    v3 = (unint64_t *)objc_msgSend(a1, "baseURL");
  else
    v3 = (unint64_t *)a1[4];
  *(_OWORD *)values = 0u;
  v16 = 0u;
  keys[0] = CFSTR("_CFURLStringType");
  keys[1] = CFSTR("_CFURLString");
  keys[2] = CFSTR("_CFURLBaseStringType");
  keys[3] = CFSTR("_CFURLBaseURLString");
  valuePtr = 15;
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1))
  {
    values[0] = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
    v4 = (void *)CFURLGetString((CFURLRef)a1);
  }
  else
  {
    values[0] = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
    v5 = (const void *)atomic_load(a1 + 3);
    v4 = (void *)CFRetain(v5);
  }
  values[1] = v4;
  if (v3)
  {
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)v3))
    {
      valuePtr = 15;
      *(_QWORD *)&v16 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
      v6 = (void *)CFURLGetString((CFURLRef)v3);
    }
    else
    {
      valuePtr = 15;
      *(_QWORD *)&v16 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
      v8 = (const void *)atomic_load(v3 + 3);
      v6 = (void *)CFRetain(v8);
    }
    *((_QWORD *)&v16 + 1) = v6;
    v7 = 4;
  }
  else
  {
    v7 = 2;
  }
  v9 = CFGetAllocator(a1);
  v10 = CFDictionaryCreate(v9, (const void **)keys, (const void **)values, v7, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v11 = 0;
  v12 = 8 * v7;
  do
  {
    CFRelease(values[v11 / 8]);
    v11 += 8;
  }
  while (v12 != v11);
  return v10;
}

CFTypeID CFRunLoopSourceGetTypeID(void)
{
  return 46;
}

uint64_t _CFURLCopyFileURL(__objc2_class **a1)
{
  uint64_t v1;
  uint64_t v2;
  __objc2_class **v4;
  unsigned int v5;
  uint64_t v6;
  BOOL v7;
  size_t v8;
  uint64_t Instance;
  const void *v10;
  uint64_t v11;
  const __CFString *v12;
  uint64_t v13;
  const void *v14;
  const __CFAllocator *v15;
  CFStringRef Copy;
  uint64_t v17;
  int v18;

  v1 = (uint64_t)a1;
  if (CF_IS_OBJC(0x1DuLL, a1))
    v1 = objc_msgSend((id)v1, "_cfurl");
  if (*(_QWORD *)(v1 + 32) || !_CFURLHasFileURLScheme((__objc2_class **)v1, 0))
    return 0;
  v4 = (__objc2_class **)CFGetAllocator((CFTypeRef)v1);
  v5 = *(_DWORD *)(v1 + 16) & 0x1FF;
  if (v5)
  {
    v6 = 0;
    do
    {
      v6 += v5 & 1;
      v7 = v5 > 1;
      v5 >>= 1;
    }
    while (v7);
    v8 = 16 * v6;
  }
  else
  {
    v8 = 0;
  }
  Instance = _CFRuntimeCreateInstance(v4, 0x1DuLL, (v8 & 0xFF0) + 40, 0);
  v2 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 20) = 134217984;
    *(_QWORD *)(Instance + 16) = *(_QWORD *)(v1 + 16);
    v10 = (const void *)atomic_load((unint64_t *)(v1 + 24));
    atomic_store((unint64_t)CFRetain(v10), (unint64_t *)(v2 + 24));
    *(_QWORD *)(v2 + 32) = 0;
    *(_QWORD *)(v2 + 40) = 0;
    if ((*(_BYTE *)(v2 + 18) & 1) == 0)
    {
      v11 = *(_QWORD *)(v1 + 40);
      if (v11)
      {
        v12 = *(const __CFString **)(v11 + 8);
        if (v12)
        {
          _CFURLAllocateExtraDataspace((_QWORD *)v2);
          v13 = *(_QWORD *)(v2 + 40);
          if (v13)
          {
            v14 = *(const void **)(v13 + 8);
            if (v14)
              CFRelease(v14);
            v15 = CFGetAllocator((CFTypeRef)v2);
            Copy = CFStringCreateCopy(v15, v12);
            v13 = *(_QWORD *)(v2 + 40);
            *(_QWORD *)(v13 + 8) = Copy;
          }
          v17 = *(_QWORD *)(v1 + 40);
          if (v17)
          {
            v18 = *(_DWORD *)(v17 + 16);
            if (v18 && !v13)
            {
              _CFURLAllocateExtraDataspace((_QWORD *)v2);
              v13 = *(_QWORD *)(v2 + 40);
            }
          }
          else
          {
            v18 = 0;
          }
          if (v13)
            *(_DWORD *)(v13 + 16) = v18;
        }
      }
    }
    if (atomic_load((unint64_t *)(v1 + 48)))
      atomic_store(_FileCacheCreateShallowCopy(), (unint64_t *)(v2 + 48));
    memcpy((void *)(v2 + 56), (const void *)(v1 + 56), v8);
  }
  return v2;
}

CFStringRef CFDateFormatterGetFormat(CFDateFormatterRef formatter)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  return (CFStringRef)*((_QWORD *)formatter + 6);
}

CFMutableDictionaryRef _CFXPreferencesCopyDictionaryForSourceWithBundleID(__CFString *a1)
{
  void *v2;
  CFMutableDictionaryRef v3;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v2 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v3 = -[_CFXPreferences copyDictionaryForSourceWithIdentifier:]((uint64_t)v2, a1);

  return v3;
}

void sub_182B88524(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Boolean CFURLCanBeDecomposed(CFURLRef anURL)
{
  CFURLRef v1;

  v1 = anURL;
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
    v1 = (CFURLRef)-[__CFURL _cfurl](v1, "_cfurl");
  return (*((_DWORD *)v1 + 4) >> 14) & 1;
}

const __CFNumber *_CFURLCreateFromPropertyListRepresentation(__objc2_class **a1, CFTypeRef cf)
{
  const __CFString *Value;
  const __CFString *v5;
  CFTypeID v6;
  const __CFNumber *v7;
  const __CFNumber *v8;
  CFTypeID v9;
  const __CFString *v10;
  const __CFString *v11;
  CFTypeID v12;
  const __CFNumber *v13;
  const __CFNumber *v14;
  CFTypeID v15;
  uint64_t v16;
  CFIndex Length;
  _BOOL4 v18;
  const __CFURL *v19;
  const __CFURL *v20;
  uint64_t v21;
  const __CFNumber *v22;
  CFIndex v23;
  _BOOL4 v24;
  _QWORD valuePtr[2];

  valuePtr[1] = *MEMORY[0x1E0C80C00];
  if (CFGetTypeID(cf) != 18)
    return 0;
  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("_CFURLString"));
  if (!Value)
    return 0;
  v5 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 != CFStringGetTypeID())
    return 0;
  v7 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("_CFURLStringType"));
  v8 = v7;
  if (!v7)
    return v8;
  v9 = CFGetTypeID(v7);
  if (v9 != CFNumberGetTypeID())
    return 0;
  valuePtr[0] = 0;
  if (!CFNumberGetValue(v8, kCFNumberSInt32Type, valuePtr))
    return 0;
  v8 = 0;
  if (LODWORD(valuePtr[0]) > 0xF || ((1 << SLOBYTE(valuePtr[0])) & 0x8007) == 0)
    return v8;
  v10 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("_CFURLBaseURLString"));
  if (v10)
  {
    v11 = v10;
    v12 = CFGetTypeID(v10);
    if (v12 == CFStringGetTypeID())
    {
      v13 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("_CFURLBaseStringType"));
      if (v13)
      {
        v14 = v13;
        v15 = CFGetTypeID(v13);
        if (v15 == CFNumberGetTypeID())
        {
          if (CFNumberGetValue(v14, kCFNumberSInt32Type, (char *)valuePtr + 4))
          {
            v16 = HIDWORD(valuePtr[0]);
            if (HIDWORD(valuePtr[0]) < 3)
            {
              Length = CFStringGetLength(v11);
              v18 = CFStringGetCharacterAtIndex(v11, Length - 1) == 47;
              v19 = (const __CFURL *)_CFURLCreateWithFileSystemPath(a1, v11, v16, v18, 0);
LABEL_24:
              v20 = v19;
              goto LABEL_17;
            }
            if (HIDWORD(valuePtr[0]) == 15)
            {
              v19 = (const __CFURL *)_CFURLCreateWithURLString(a1, v11, 0, 0);
              goto LABEL_24;
            }
          }
        }
      }
    }
    return 0;
  }
  v20 = 0;
LABEL_17:
  v21 = SLODWORD(valuePtr[0]);
  if (LODWORD(valuePtr[0]) == 15)
  {
    v22 = (const __CFNumber *)_CFURLCreateWithURLString(a1, v5, 0, v20);
  }
  else
  {
    v23 = CFStringGetLength(v5);
    v24 = CFStringGetCharacterAtIndex(v5, v23 - 1) == 47;
    v22 = (const __CFNumber *)_CFURLCreateWithFileSystemPath(a1, v5, v21, v24, v20);
  }
  v8 = v22;
  if (v20)
    CFRelease(v20);
  return v8;
}

Boolean CFRunLoopContainsObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  unint64_t v6;
  pthread_mutex_t *v7;
  uint64_t v8;
  CFArrayRef *v9;
  pthread_mutex_t *v10;
  const __CFArray *v11;
  Boolean v12;
  const __CFSet *v13;
  CFRange v15;

  v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v7 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (mode == CFSTR("kCFRunLoopCommonModes"))
  {
    v13 = (const __CFSet *)*((_QWORD *)rl + 77);
    if (v13)
    {
      v12 = CFSetContainsValue(v13, observer);
      goto LABEL_15;
    }
LABEL_12:
    v12 = 0;
    goto LABEL_15;
  }
  v8 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (!v8)
    goto LABEL_12;
  v9 = (CFArrayRef *)v8;
  v10 = (pthread_mutex_t *)(v8 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(v8 + 16));
  v11 = v9[14];
  if (v11)
  {
    v15.length = CFArrayGetCount(v9[14]);
    v15.location = 0;
    v12 = CFArrayContainsValue(v11, v15, observer);
  }
  else
  {
    v12 = 0;
  }
  pthread_mutex_unlock(v10);
  CFRelease(v9);
LABEL_15:
  pthread_mutex_unlock(v7);
  return v12;
}

uint64_t CFStorageCreate(__objc2_class **a1, int64_t a2)
{
  uint64_t Instance;
  uint64_t v4;
  BOOL v5;
  int v6;

  Instance = _CFRuntimeCreateInstance(a1, 0x1AuLL, 168, 0);
  v4 = Instance;
  if (Instance)
  {
    *(_DWORD *)(Instance + 128) = 0;
    *(_QWORD *)(Instance + 16) = a2;
    v5 = (a2 & (a2 - 1)) != 0 || a2 <= 0;
    v6 = __clz(__rbit64(a2));
    if (v5)
      v6 = -1;
    *(_DWORD *)(Instance + 24) = v6;
    *(_QWORD *)(Instance + 32) = 850045857;
    *(_OWORD *)(Instance + 40) = 0u;
    *(_OWORD *)(Instance + 56) = 0u;
    *(_OWORD *)(Instance + 72) = 0u;
    *(_QWORD *)(Instance + 88) = 0;
    *(_QWORD *)(Instance + 136) = 12288;
    if (a2 && 12288 % a2)
      *(_QWORD *)(Instance + 136) = 12288 - 12288 % a2;
    *(_BYTE *)(Instance + 157) = 1;
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
  }
  return v4;
}

uint64_t _CFPrefsSetReadOnly(uint64_t result)
{
  forceReadOnly = (_DWORD)result != 0;
  return result;
}

xpc_object_t _CFXPCCreateXPCMessageWithCFObject(uint64_t a1)
{
  unint64_t v2;
  size_t v3;
  xpc_object_t v4;
  NSObject *alloc;
  char *keys;
  mach_vm_address_t address[2];

  address[1] = *MEMORY[0x1E0C80C00];
  v2 = __CFBinaryPlistWrite15(a1, 0);
  if (!v2)
    return 0;
  if (v2 <= 0x4000)
  {
    address[0] = 0;
    alloc = dispatch_data_create_alloc();
    __CFBinaryPlistWrite15(a1, 0);
LABEL_7:
    address[0] = (mach_vm_address_t)xpc_data_create_with_dispatch_data(alloc);
    dispatch_release(alloc);
    keys = "ECF19A18-7AA6-4141-B4DC-A2E5123B2B5C";
    v4 = xpc_dictionary_create((const char *const *)&keys, (xpc_object_t *)address, 1uLL);
    xpc_release((xpc_object_t)address[0]);
    return v4;
  }
  address[0] = 0;
  v3 = (v2 + *MEMORY[0x1E0C85AD8] - 1) & -*MEMORY[0x1E0C85AD8];
  if (!mach_vm_allocate(*MEMORY[0x1E0C83DA0], address, v3, 687865857))
  {
    __CFBinaryPlistWrite15(a1, 0);
    alloc = dispatch_data_create((const void *)address[0], v3, 0, (dispatch_block_t)*MEMORY[0x1E0C80CF8]);
    goto LABEL_7;
  }
  return 0;
}

uint64_t _CFBundleGetInfoDictionaryBoolean(const void *a1)
{
  __CFBundle *MainBundle;
  const __CFDictionary *InfoDictionary;
  const __CFBoolean *Value;
  const __CFBoolean *v5;
  CFTypeID v6;
  uint64_t v8;
  BOOL v9;
  int valuePtr;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
    if (InfoDictionary)
    {
      Value = (const __CFBoolean *)CFDictionaryGetValue(InfoDictionary, a1);
      if (Value)
      {
        v5 = Value;
        v6 = CFGetTypeID(Value);
        if (v6 == CFBooleanGetTypeID())
          return CFBooleanGetValue(v5);
        if (v6 == CFStringGetTypeID())
        {
          v8 = 1;
          if (CFStringCompare((CFStringRef)v5, CFSTR("true"), 1uLL))
            return CFStringCompare((CFStringRef)v5, CFSTR("YES"), 1uLL) == kCFCompareEqualTo;
          return v8;
        }
        if (v6 == CFNumberGetTypeID())
        {
          valuePtr = 0;
          if (CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr))
            v9 = valuePtr == 0;
          else
            v9 = 1;
          return !v9;
        }
      }
    }
  }
  return 0;
}

CFLocaleRef CFDateFormatterGetLocale(CFDateFormatterRef formatter)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  return (CFLocaleRef)*((_QWORD *)formatter + 3);
}

const void *CFCopySystemVersionString()
{
  const __CFDictionary *v0;
  const __CFDictionary *v1;
  const void *Value;
  const void *v3;

  v0 = (const __CFDictionary *)_CFCopySupplementalVersionDictionary();
  if (!v0)
    return 0;
  v1 = v0;
  Value = CFDictionaryGetValue(v0, CFSTR("FullVersionString"));
  v3 = Value;
  if (Value)
    CFRetain(Value);
  CFRelease(v1);
  return v3;
}

CFTypeRef _CFCopySupplementalVersionDictionary()
{
  CFTypeRef result;

  if (_CFCopySupplementalVersionDictionary_onceToken != -1)
    dispatch_once(&_CFCopySupplementalVersionDictionary_onceToken, &__block_literal_global_28);
  result = (CFTypeRef)_CFCopySupplementalVersionDictionary_result;
  if (_CFCopySupplementalVersionDictionary_result)
    return CFRetain((CFTypeRef)_CFCopySupplementalVersionDictionary_result);
  return result;
}

void CFStringGetParagraphBounds(CFStringRef string, CFRange range, CFIndex *parBeginIndex, CFIndex *parEndIndex, CFIndex *contentsEndIndex)
{
  CFIndex length;
  CFIndex location;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)string))
    -[__CFString getParagraphStart:end:contentsEnd:forRange:]((id)string, "getParagraphStart:end:contentsEnd:forRange:", parBeginIndex, parEndIndex, contentsEndIndex, location, length);
  else
    __CFStringGetLineOrParagraphBounds(string, location, length, parBeginIndex, (unint64_t)parEndIndex, contentsEndIndex, 0);
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
  uint64_t *p_info;
  char v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  char **p_data;
  char *v17;
  uint64_t length;
  uint64_t v19;
  const __CFString *CharactersPtr;
  char *v21;
  int v22;
  uint64_t *v23;
  char v24;
  char v25;
  char v26;
  char **v27;
  char *v28;
  char v29;
  unint64_t v30;
  int64_t v31;
  UniChar v32;
  uint64_t v33;
  BOOL v34;
  int64_t v35;
  int64_t v36;
  char v37;
  char **v38;
  char *v39;
  char v40;
  unint64_t v41;
  char *v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  UniChar v49;
  uint64_t v50;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int64_t v56;
  char v57;
  char v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  char v62;
  char **v63;
  uint64_t v64;
  uint64_t v65;
  UniChar buffer[8];
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  CFStringRef theStringa[2];
  __int128 v75;
  __int128 v76;
  int64_t v77;
  uint64_t v78;
  CFRange v79;
  CFRange v80;

  v78 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfTrimWS](theString, "_cfTrimWS");
  }
  else
  {
    v77 = 0;
    v75 = 0u;
    v76 = 0u;
    v73 = 0u;
    *(_OWORD *)theStringa = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    *(_OWORD *)buffer = 0u;
    p_info = &theString->info;
    v3 = atomic_load((unint64_t *)&theString->info);
    if ((v3 & 1) != 0)
    {
      v12 = atomic_load((unint64_t *)p_info);
      v13 = v12 & 5;
      v14 = atomic_load((unint64_t *)p_info);
      v15 = v14 & 0x60;
      if (v13 == 4)
      {
        p_data = &theString->data;
        if (v15)
        {
          v17 = *p_data;
        }
        else
        {
          v19 = atomic_load((unint64_t *)&theString->info);
          v17 = (char *)&p_data[(v19 & 5) != 4];
        }
        length = *v17;
      }
      else if ((v14 & 0x60) != 0)
      {
        length = theString->length;
      }
      else
      {
        length = (uint64_t)theString->data;
      }
      theStringa[0] = theString;
      *((_QWORD *)&v75 + 1) = 0;
      *(_QWORD *)&v76 = length;
      CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(theString);
      v21 = 0;
      theStringa[1] = CharactersPtr;
      if (!CharactersPtr)
      {
        v22 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          CharactersPtr = (const __CFString *)__CFStringComputeEightBitStringEncoding(0);
          v22 = __CFDefaultEightBitStringEncoding;
        }
        if (v22 != 1536)
        {
          if (v22 == -1)
          {
            __CFStringComputeEightBitStringEncoding(CharactersPtr);
            v22 = __CFDefaultEightBitStringEncoding;
          }
          if (v22 != 1536)
            goto LABEL_23;
        }
        v23 = &theString->info;
        v24 = atomic_load((unint64_t *)&theString->info);
        if ((v24 & 0x10) == 0 || (v25 = atomic_load((unint64_t *)v23), (v25 & 8) != 0))
        {
          v26 = atomic_load((unint64_t *)v23);
          v27 = &theString->data;
          if ((v26 & 0x60) != 0)
          {
            v28 = *v27;
          }
          else
          {
            v29 = atomic_load((unint64_t *)&theString->info);
            v28 = (char *)&v27[(v29 & 5) != 4];
          }
          v30 = atomic_load((unint64_t *)&theString->info);
          v21 = &v28[(v30 >> 2) & 1];
        }
        else
        {
LABEL_23:
          v21 = 0;
        }
      }
      *((_QWORD *)&v76 + 1) = 0;
      v77 = 0;
      *(_QWORD *)&v75 = v21;
      if (length < 1)
      {
LABEL_46:
        v64 = 0;
        v65 = length;
      }
      else
      {
        v31 = 0;
        while (1)
        {
          if (theStringa[1])
          {
            v32 = *((_WORD *)&theStringa[1]->isa + *((_QWORD *)&v75 + 1) + v31);
          }
          else if ((_QWORD)v75)
          {
            v32 = *(char *)(v75 + *((_QWORD *)&v75 + 1) + v31);
          }
          else
          {
            v33 = *((_QWORD *)&v76 + 1);
            v34 = v77 > v31 && *((_QWORD *)&v76 + 1) <= v31;
            if (!v34)
            {
              v35 = v31 - 4;
              if ((unint64_t)v31 < 4)
                v35 = 0;
              v36 = v35 + 64;
              if (v35 + 64 >= (uint64_t)v76)
                v36 = v76;
              *((_QWORD *)&v76 + 1) = v35;
              v77 = v36;
              v79.location = *((_QWORD *)&v75 + 1) + v35;
              v79.length = v36 - v35;
              CFStringGetCharacters(theStringa[0], v79, buffer);
              v33 = *((_QWORD *)&v76 + 1);
            }
            v32 = buffer[v31 - v33];
          }
          if (!CFUniCharIsMemberOf(v32, 3u))
            break;
          if (++v31 == length)
            goto LABEL_46;
        }
        v37 = atomic_load((unint64_t *)&theString->info);
        v38 = &theString->data;
        v63 = &theString->data;
        if ((v37 & 0x60) != 0)
        {
          v39 = *v38;
        }
        else
        {
          v40 = atomic_load((unint64_t *)&theString->info);
          v39 = (char *)&v38[(v40 & 5) != 4];
        }
        v41 = atomic_load((unint64_t *)&theString->info);
        v42 = &v39[(v41 >> 2) & 1];
        v43 = atomic_load((unint64_t *)&theString->info);
        v44 = (v43 >> 4) & 1;
        v45 = -length;
        v46 = length + 64;
        do
        {
          v47 = length;
          if ((unint64_t)length >= 5)
            v48 = 5;
          else
            v48 = length;
          v34 = length-- < 1;
          if (v34)
            break;
          if (theStringa[1])
          {
            v49 = *((_WORD *)theStringa[1] + v47 + *((_QWORD *)&v75 + 1) - 1);
          }
          else if ((_QWORD)v75)
          {
            v49 = *(char *)(v75 + *((_QWORD *)&v75 + 1) + v47 - 1);
          }
          else
          {
            v50 = *((_QWORD *)&v76 + 1);
            if (v77 < v47 || *((_QWORD *)&v76 + 1) >= v47)
            {
              v52 = -v48;
              v53 = v48 + v45;
              v54 = v46 - v48;
              v55 = v47 + v52;
              v56 = v55 + 64;
              if (v55 + 64 >= (uint64_t)v76)
                v56 = v76;
              *((_QWORD *)&v76 + 1) = v55;
              v77 = v56;
              if ((uint64_t)v76 < v54)
                v54 = v76;
              v80.length = v54 + v53;
              v80.location = v55 + *((_QWORD *)&v75 + 1);
              CFStringGetCharacters(theStringa[0], v80, buffer);
              v50 = *((_QWORD *)&v76 + 1);
            }
            v49 = buffer[v47 - 1 - v50];
          }
          ++v45;
          --v46;
        }
        while ((CFUniCharIsMemberOf(v49, 3u) & 1) != 0);
        memmove(v42, &v42[v31 << v44], (v47 - v31) << v44);
        v57 = atomic_load((unint64_t *)&theString->info);
        v58 = atomic_load((unint64_t *)&theString->info);
        v59 = v58 & 0x60;
        if ((v57 & 5) == 4)
        {
          if (v59)
          {
            v60 = *v63;
          }
          else
          {
            v62 = atomic_load((unint64_t *)&theString->info);
            v60 = (char *)&v63[(v62 & 5) != 4];
          }
          v61 = *v60;
        }
        else if (v59)
        {
          v61 = theString->length;
        }
        else
        {
          v61 = (uint64_t)*v63;
        }
        v64 = v47 - v31;
        v65 = v61 + v31 - v47;
      }
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v64, 1, 0, 0);
    }
    else
    {
      v4 = _CFOSLog();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
        CFStringTrimWhitespace_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    }
  }
}

CFNotificationCenterRef CFNotificationCenterGetDistributedCenter(void)
{
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) != 0)
    return 0;
  if (CFNotificationCenterGetDistributedCenter_static_init != -1)
    dispatch_once(&CFNotificationCenterGetDistributedCenter_static_init, &__block_literal_global_10);
  return (CFNotificationCenterRef)__hostCenter;
}

void CFSocketEnableCallBacks(CFSocketRef s, CFOptionFlags callBackTypes)
{
  unint64_t v4;

  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  __CFSocketEnableCallBacks((uint64_t)s, callBackTypes, 1);
}

CFTypeRef CFAttributedStringGetAttribute(CFAttributedStringRef aStr, CFIndex loc, CFStringRef attrName, CFRange *effectiveRange)
{
  const __CFDictionary *ValueAtIndex;

  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    return (CFTypeRef)-[__CFAttributedString attribute:atIndex:effectiveRange:](aStr, "attribute:atIndex:effectiveRange:", attrName, loc, effectiveRange);
  ValueAtIndex = (const __CFDictionary *)CFRunArrayGetValueAtIndex(*((_QWORD *)aStr + 3), loc, &effectiveRange->location, 0);
  return CFDictionaryGetValue(ValueAtIndex, attrName);
}

void *_CFUnsandboxedHomeDirectoryForCurrentUser()
{
  uid_t v0;
  uid_t v1;
  passwd *v2;
  const UInt8 *pw_dir;
  size_t v4;
  const UInt8 *v5;
  char *v6;
  size_t v7;
  size_t v8;
  void *v9;
  UInt8 buffer[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v0 = geteuid();
  v1 = getuid();
  if (v0)
    v1 = v0;
  v2 = getpwuid(v1);
  if (!v2
    || (pw_dir = (const UInt8 *)v2->pw_dir) == 0
    || (v4 = strnlen(v2->pw_dir, 0x400uLL),
        (v5 = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, pw_dir, v4, 1u)) == 0))
  {
    v6 = __CFgetenv("HOME");
    v5 = (const UInt8 *)v6;
    if (v6)
    {
      v7 = strnlen(v6, 0x400uLL);
      v5 = (const UInt8 *)CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, v7, 1u);
    }
  }
  bzero(buffer, 0x400uLL);
  CFURLGetFileSystemRepresentation((CFURLRef)v5, 1u, buffer, 1024);
  v8 = strnlen((const char *)buffer, 0x400uLL);
  v9 = malloc_type_malloc(v8 + 1, 0x100004077774924uLL);
  memmove(v9, buffer, v8);
  *((_BYTE *)v9 + v8) = 0;
  if (v5)
    CFRelease(v5);
  return v9;
}

void *CFBurstTrieCreateCursorForBytes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  int v7;

  v6 = malloc_type_calloc(0x21uLL, 1uLL, 0x5F15F5FuLL);
  CFBurstTrieSetCursorForBytes(a1, (uint64_t)v6, a2, a3);
  if (!v7 && v6)
  {
    free(v6);
    return 0;
  }
  return v6;
}

void CFBurstTrieSetCursorForBytes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 2056);
  if (v4)
  {
    if ((a4 & 0x8000000000000000) == 0 && (*(_DWORD *)(a1 + 2072) & 0x18) != 0)
    {
      *(_QWORD *)(a2 + 25) = a1;
      *(_QWORD *)(a2 + 17) = 1;
      *(_DWORD *)a2 = *(_DWORD *)(v4 + 4);
      *(_QWORD *)(a2 + 9) = 0;
      *(_QWORD *)(a2 + 4) = 0;
      if (a3)
      {
        if (a4)
          CFBurstTrieCursorAdvanceForBytes(a2);
      }
    }
  }
}

CFPropertyListRef CFPropertyListCreateFromXMLData(CFAllocatorRef allocator, CFDataRef xmlData, CFOptionFlags mutabilityOption, CFStringRef *errorString)
{
  CFTypeRef v5;
  const void *v6;
  CFTypeRef cf;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  if (errorString)
    *errorString = 0;
  cf = 0;
  v9[0] = 0;
  _CFPropertyListCreateWithData((__objc2_class **)allocator, xmlData, mutabilityOption, (CFErrorRef *)&cf, 1, 0, 0, v9);
  v5 = cf;
  v6 = (const void *)v9[0];
  if (errorString && cf)
  {
    *errorString = __copyErrorDebugDescription((__CFError *)cf);
    v5 = cf;
  }
  if (v5)
    CFRelease(v5);
  return v6;
}

CFMutableSetRef ___cfmp_records_block_invoke()
{
  CFMutableSetRef result;
  CFSetCallBacks v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1 = *(CFSetCallBacks *)byte_1E12E18C0;
  result = CFSetCreateMutable(0, 16, &v1);
  _cfmp_records_oRecords = (uint64_t)result;
  return result;
}

void _CFPreferencesSetValueWithContainer(uint64_t a1, uint64_t a2, __CFString *a3, const __CFString *a4, const void *a5, const __CFString *a6)
{
  const os_unfair_lock *v12;
  os_unfair_lock *v13;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v12 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v12 = (const os_unfair_lock *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v13 = (os_unfair_lock *)v12;
  -[_CFXPreferences setValue:forKey:identifier:user:host:container:](v12, a2, a1, a3, a4, a5, a6);

}

uint64_t CFStorageGetConstValueAtIndex(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  os_unfair_lock_s *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  CFAllocatorRef v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t Byte;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40[2];

  v40[1] = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 128);
  os_unfair_lock_lock_with_options();
  v7 = *(uint64_t **)(a1 + 104);
  v8 = *(_QWORD *)(a1 + 112);
  v9 = *(_QWORD *)(a1 + 120);
  os_unfair_lock_unlock(v6);
  if (!v7)
    goto LABEL_29;
  if (!v7[3])
  {
    v10 = CFGetAllocator((CFTypeRef)a1);
    v11 = *v7;
    v12 = *MEMORY[0x1E0C85AD8];
    if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
      v13 = *MEMORY[0x1E0C85AD8];
    else
      v13 = v12 + 1;
    if (v11 <= v13 >> 1)
    {
      v16 = v11 + 63;
      v19 = v11 < -63;
      v17 = v11 + 126;
      if (!v19)
        v17 = v16;
      v15 = v17 & 0xFFFFFFFFFFFFFFC0;
    }
    else
    {
      v14 = (v11 + v12 - 1) & -(int)v12;
      if (*(_QWORD *)(a1 + 136) >= v14)
        v15 = v14;
      else
        v15 = *(_QWORD *)(a1 + 136);
    }
    if (v15 > v7[2])
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
      if (v15 > v7[2])
      {
        v7[3] = __CFSafelyReallocateWithAllocatorTyped(v10, v7[3], v15, 1893177561, 0, 0);
        if (__CFOASafe)
          __CFSetLastAllocationEventName();
        v7[2] = v15;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
    }
  }
  v18 = a2 - v8;
  v19 = a2 < v8 || v9 + v8 <= a2;
  if (v19)
    goto LABEL_29;
  if (a3)
  {
    *a3 = v8;
    a3[1] = v9;
  }
  v20 = v7[3];
  v21 = *(_DWORD *)(a1 + 24);
  if (v21 == -1)
  {
    v22 = *(_QWORD *)(a1 + 16) * v18;
    if (v20)
      return v20 + v22;
LABEL_29:
    v39 = 0;
    v40[0] = 0;
    v38 = 0;
    v24 = *(_DWORD *)(a1 + 24);
    if (v24 == -1)
      v25 = *(_QWORD *)(a1 + 16) * a2;
    else
      v25 = a2 << v24;
    Byte = __CFStorageFindByte((_QWORD *)a1, a1 + 144, v25, 0, v40, &v38, 0);
    v26 = v40[0];
    v27 = v38;
    if (v40[0])
    {
      v28 = *(_QWORD *)v40[0];
      v29 = *(_DWORD *)(a1 + 24);
      if (v29 == -1)
      {
        v32 = *(_QWORD *)(a1 + 16);
        v30 = v38 / v32;
        v31 = v28 / v32;
      }
      else
      {
        v30 = v38 >> v29;
        v31 = v28 >> v29;
      }
    }
    else
    {
      v30 = 0;
      v31 = 0;
    }
    os_unfair_lock_lock_with_options();
    *(_QWORD *)(a1 + 104) = v26;
    *(_QWORD *)(a1 + 112) = v30;
    *(_QWORD *)(a1 + 120) = v31;
    os_unfair_lock_unlock(v6);
    v33 = *(_DWORD *)(a1 + 24);
    if (v33 == -1)
    {
      v37 = *(_QWORD *)(a1 + 16);
      v34 = v27 / v37;
      v35 = v39 / v37;
      if (!a3)
        return Byte;
    }
    else
    {
      v34 = v27 >> v33;
      v35 = v39 >> v33;
      if (!a3)
        return Byte;
    }
    *a3 = v34;
    a3[1] = v35;
    return Byte;
  }
  v22 = v18 << v21;
  if (!v20)
    goto LABEL_29;
  return v20 + v22;
}

uint64_t boundPairReadOpen(char *a1, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (*(_WORD *)(a4 + 4))
  {
    CFReadStreamSignalEvent(a1, 1uLL, 0, a4, a5, a6, a7, a8);
    if (boundPairReadCanRead(v12, a4))
      CFReadStreamSignalEvent(a1, 2uLL, 0, v13, v14, v15, v16, v17);
    _wakeReadStreamScheduledRunLoops();
  }
  *(_DWORD *)(a2 + 8) = 0;
  *a3 = 1;
  return 1;
}

uint64_t boundPairWriteOpen(char *a1, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*(_WORD *)(a4 + 52))
  {
    CFWriteStreamSignalEvent(a1, 1uLL, 0, a4, a5, a6, a7, a8);
    CFWriteStreamSignalEvent(a1, 4uLL, 0, v11, v12, v13, v14, v15);
    _wakeWriteStreamScheduledRunLoops();
  }
  *(_DWORD *)(a2 + 8) = 0;
  *a3 = 1;
  return 1;
}

void CFWriteStreamSignalEvent(char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CFStreamSignalEvent(a1, a2, a3, 1, a5, a6, a7, a8);
}

uint64_t boundPairWrite(char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFRunLoop *Current;
  const void *v18;
  CFTypeRef v19;
  uint64_t v20;
  __CFRunLoop *v21;
  unint64_t v22;

  if (a3 > 0)
  {
    v10 = a3;
    pthread_mutex_lock((pthread_mutex_t *)(a5 + 104));
    if (!a5)
      goto LABEL_5;
LABEL_3:
    if (!*(_BYTE *)(a5 + 48) && _cbCanWrite(*(_QWORD *)(a5 + 96)))
    {
      if (!*(_BYTE *)(a5 + 2))
      {
        v20 = (int)cbWrite(*(_QWORD *)(a5 + 96), a2, v10);
        goto LABEL_20;
      }
    }
    else
    {
LABEL_5:
      while (!*(_BYTE *)(a5 + 2))
      {
        if (*(_WORD *)(a5 + 4))
        {
          _CFReadStreamSignalEventDelayed(*(char **)(a5 + 32), 2uLL, 0, v12, v13, v14, v15, v16);
          _wakeReadStreamScheduledRunLoops();
        }
        Current = CFRunLoopGetCurrent();
        CFRunLoopAddSource(Current, *(CFRunLoopSourceRef *)(a5 + 56), *(CFRunLoopMode *)(a5 + 72));
        v18 = *(const void **)(a5 + 64);
        if (v18)
          CFRelease(v18);
        if (Current)
          v19 = CFRetain(Current);
        else
          v19 = 0;
        *(_QWORD *)(a5 + 64) = v19;
        *(_BYTE *)(a5 + 49) = 1;
        pthread_mutex_unlock((pthread_mutex_t *)(a5 + 104));
        CFRunLoopRunInMode(*(CFRunLoopMode *)(a5 + 72), 1.0e20, 1u);
        pthread_mutex_lock((pthread_mutex_t *)(a5 + 104));
        *(_BYTE *)(a5 + 49) = 0;
        CFRunLoopRemoveSource(Current, *(CFRunLoopSourceRef *)(a5 + 56), *(CFRunLoopMode *)(a5 + 72));
        if (a5)
          goto LABEL_3;
      }
    }
    v20 = -1;
LABEL_20:
    if (*(_BYTE *)(a5 + 1))
    {
      CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a5 + 8));
      v21 = *(__CFRunLoop **)(a5 + 16);
      if (v21)
        CFRunLoopWakeUp(v21);
    }
    if (*(_WORD *)(a5 + 4))
    {
      _CFReadStreamSignalEventDelayed(*(char **)(a5 + 32), 2uLL, 0, v12, v13, v14, v15, v16);
      _wakeReadStreamScheduledRunLoops();
    }
    if (!*(_WORD *)(a5 + 52))
      goto LABEL_32;
    if (*(_BYTE *)(a5 + 48) || !_cbCanWrite(*(_QWORD *)(a5 + 96)))
    {
      if (!*(_BYTE *)(a5 + 2))
      {
LABEL_32:
        pthread_mutex_unlock((pthread_mutex_t *)(a5 + 104));
        return v20;
      }
      v22 = 16;
    }
    else
    {
      v22 = 4;
    }
    CFWriteStreamSignalEvent(a1, v22, 0, v12, v13, v14, v15, v16);
    _wakeWriteStreamScheduledRunLoops();
    goto LABEL_32;
  }
  *(_DWORD *)(a4 + 8) = 22;
  *(_QWORD *)a4 = 1;
  if (*(_WORD *)(a5 + 52))
  {
    CFWriteStreamSignalEvent(a1, 8uLL, (_OWORD *)a4, a4, a5, a6, a7, a8);
    _wakeWriteStreamScheduledRunLoops();
  }
  return -1;
}

BOOL _cbCanWrite(uint64_t a1)
{
  return *(_DWORD *)(a1 + 36) != 0;
}

void _wakeWriteStreamScheduledRunLoops()
{
  const __CFArray *v0;
  const __CFArray *v1;

  v0 = (const __CFArray *)_CFWriteStreamCopyRunLoopsAndModes();
  if (v0)
  {
    v1 = v0;
    _wakeRunLoops(v0);
    CFRelease(v1);
  }
}

uint64_t boundPairRead(char *a1, char *a2, int a3, uint64_t a4, _BYTE *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  __CFRunLoop *Current;
  const void *v22;
  CFTypeRef v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  __CFRunLoop *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  if (*(_BYTE *)a6)
  {
    *(_DWORD *)(a4 + 8) = 22;
    *(_QWORD *)a4 = 1;
    if (*(_WORD *)(a6 + 4))
    {
      CFReadStreamSignalEvent(a1, 8uLL, (_OWORD *)a4, a4, (uint64_t)a5, a6, a7, a8);
      _wakeReadStreamScheduledRunLoops();
    }
    return -1;
  }
  pthread_mutex_lock((pthread_mutex_t *)(a6 + 104));
  while (1)
  {
    if (*(_BYTE *)a6)
    {
      v20 = *(unsigned __int8 *)(a6 + 3);
      goto LABEL_10;
    }
    if (_cbCanRead(*(_QWORD *)(a6 + 96)))
      break;
    v20 = *(unsigned __int8 *)(a6 + 3);
    if (v20 == 1)
      break;
LABEL_10:
    if (v20)
      break;
    if (*(_WORD *)(a6 + 52))
    {
      _CFWriteStreamSignalEventDelayed(*(char **)(a6 + 80), 4uLL, 0, v15, v16, v17, v18, v19);
      _wakeWriteStreamScheduledRunLoops();
    }
    Current = CFRunLoopGetCurrent();
    CFRunLoopAddSource(Current, *(CFRunLoopSourceRef *)(a6 + 8), *(CFRunLoopMode *)(a6 + 24));
    v22 = *(const void **)(a6 + 16);
    if (v22)
      CFRelease(v22);
    if (Current)
      v23 = CFRetain(Current);
    else
      v23 = 0;
    *(_QWORD *)(a6 + 16) = v23;
    *(_BYTE *)(a6 + 1) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)(a6 + 104));
    CFRunLoopRunInMode(*(CFRunLoopMode *)(a6 + 24), 1.0e20, 1u);
    pthread_mutex_lock((pthread_mutex_t *)(a6 + 104));
    *(_BYTE *)(a6 + 1) = 0;
    CFRunLoopRemoveSource(Current, *(CFRunLoopSourceRef *)(a6 + 8), *(CFRunLoopMode *)(a6 + 24));
  }
  v29 = cbRead(*(_QWORD *)(a6 + 96), a2, a3);
  if (!v29 && *(_BYTE *)(a6 + 3) == 1)
  {
    if (*(_WORD *)(a6 + 4))
    {
      CFReadStreamSignalEvent(*(char **)(a6 + 32), 0x10uLL, 0, v24, v25, v26, v27, v28);
      _wakeReadStreamScheduledRunLoops();
    }
    else
    {
      *a5 = 1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a6 + 104));
    return 0;
  }
  if (*(_BYTE *)a6)
  {
    if (*(_BYTE *)(a6 + 3) == 1)
    {
      v30 = 16;
      goto LABEL_28;
    }
  }
  else
  {
    _cbCanRead(*(_QWORD *)(a6 + 96));
    if (*(_BYTE *)(a6 + 3) == 1)
    {
      v30 = 2;
LABEL_28:
      CFReadStreamSignalEvent(a1, v30, 0, v24, v25, v26, v27, v28);
      _wakeReadStreamScheduledRunLoops();
    }
  }
  *(_DWORD *)(a4 + 8) = 0;
  *a5 = 0;
  if (*(_BYTE *)(a6 + 49))
  {
    CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a6 + 56));
    v31 = *(__CFRunLoop **)(a6 + 64);
    if (v31)
      CFRunLoopWakeUp(v31);
  }
  if (*(_WORD *)(a6 + 4) && !*(_BYTE *)(a6 + 3))
  {
    _CFWriteStreamSignalEventDelayed(*(char **)(a6 + 80), 4uLL, 0, v24, v25, v26, v27, v28);
    _wakeWriteStreamScheduledRunLoops();
  }
  if (*(_WORD *)(a6 + 52) && !*(_BYTE *)a6 && (_cbCanRead(*(_QWORD *)(a6 + 96)) || *(_BYTE *)(a6 + 3) == 1))
  {
    CFReadStreamSignalEvent(a1, 2uLL, 0, v32, v33, v34, v35, v36);
    _wakeReadStreamScheduledRunLoops();
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a6 + 104));
  return v29;
}

void _wakeReadStreamScheduledRunLoops()
{
  const __CFArray *v0;
  const __CFArray *v1;

  v0 = (const __CFArray *)_CFReadStreamCopyRunLoopsAndModes();
  if (v0)
  {
    v1 = v0;
    _wakeRunLoops(v0);
    CFRelease(v1);
  }
}

void _wakeRunLoops(const __CFArray *a1)
{
  CFIndex Count;
  CFIndex v3;
  CFIndex i;
  __CFRunLoop *ValueAtIndex;
  CFIndex v6;
  const void *v7;
  CFRunLoopMode v8;
  CFRunLoopMode v9;

  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v3 = Count;
    for (i = 0; i < v3; i = v6 + 1)
    {
      ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(a1, i);
      v6 = i + 1;
      v7 = CFArrayGetValueAtIndex(a1, v6);
      v8 = CFRunLoopCopyCurrentMode(ValueAtIndex);
      if (!v8)
        break;
      v9 = v8;
      if (CFEqual(v8, v7))
        CFRunLoopWakeUp(ValueAtIndex);
      CFRelease(v9);
    }
  }
}

size_t cbRead(uint64_t a1, char *a2, int a3)
{
  size_t v3;
  pthread_mutex_t *v7;
  unsigned int v8;
  _BYTE *v9;
  unsigned int v10;
  char *v11;
  _BYTE *v12;
  int64_t v13;
  uint64_t v14;
  int v15;
  size_t v16;
  uint64_t v18;
  int v19;
  size_t v20;
  unint64_t v21;

  v3 = 0;
  if (a1 && a2 && a3 >= 1)
  {
    v7 = (pthread_mutex_t *)(a1 + 40);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
    v8 = *(_DWORD *)(a1 + 32);
    v9 = (_BYTE *)*(unsigned int *)(a1 + 36);
    if (v8 <= v9)
    {
      v3 = 0;
    }
    else
    {
      v10 = v8 - (_DWORD)v9;
      if (v10 >= a3)
        v3 = a3;
      else
        v3 = v10;
      v11 = *(char **)(a1 + 8);
      v12 = *(_BYTE **)(a1 + 16);
      v13 = v12 - v11;
      if (v12 == v11)
      {
        if ((_DWORD)v9)
          cbRead_cold_3();
        v18 = *(_QWORD *)(a1 + 24);
        v19 = v18 - (_DWORD)v12;
        v20 = (v3 - (v18 - (_DWORD)v12));
        if (v3 <= (int)v18 - (int)v12)
        {
          __cbRead((uint64_t *)a1, a2, *(void **)(a1 + 16), v3);
          if (*(_QWORD *)(a1 + 8) > *(_QWORD *)(a1 + 24))
            cbRead_cold_2();
        }
        else
        {
          __cbRead((uint64_t *)a1, a2, *(void **)(a1 + 16), v18 - (_QWORD)v12);
          __cbRead((uint64_t *)a1, &a2[v19], *(void **)(a1 + 8), v20);
          if (*(_QWORD *)(a1 + 8) > *(_QWORD *)(a1 + 24))
            cbRead_cold_1();
        }
      }
      else if (v12 >= v11)
      {
        if ((_BYTE *)(v11 - &v12[*(_QWORD *)a1] + *(_QWORD *)(a1 + 24)) != v9)
          cbRead_cold_10();
        if (v13 <= v3)
        {
          v3 = v12 - v11;
          __cbRead((uint64_t *)a1, a2, v11, v13);
          v21 = *(_QWORD *)(a1 + 8);
          if (v21 != *(_QWORD *)(a1 + 16))
            cbRead_cold_9();
          if (v21 > *(_QWORD *)(a1 + 24))
            cbRead_cold_8();
        }
        else
        {
          __cbRead((uint64_t *)a1, a2, v11, v3);
          if (*(_QWORD *)(a1 + 8) > *(_QWORD *)(a1 + 24))
            cbRead_cold_7();
        }
      }
      else
      {
        if ((_BYTE *)(v11 - v12) != v9)
          cbRead_cold_6();
        v14 = *(_QWORD *)(a1 + 24);
        v15 = v14 - (_DWORD)v11;
        v16 = (v3 - (v14 - (_DWORD)v11));
        if (v3 <= (int)v14 - (int)v11)
        {
          __cbRead((uint64_t *)a1, a2, v11, v3);
          if (*(_QWORD *)(a1 + 8) > *(_QWORD *)(a1 + 24))
            cbRead_cold_5();
        }
        else
        {
          __cbRead((uint64_t *)a1, a2, v11, v14 - (_QWORD)v11);
          __cbRead((uint64_t *)a1, &a2[v15], *(void **)(a1 + 8), v16);
          if (*(_QWORD *)(a1 + 8) > *(_QWORD *)(a1 + 24))
            cbRead_cold_4();
        }
      }
    }
    pthread_mutex_unlock(v7);
  }
  return v3;
}

size_t cbWrite(uint64_t a1, char *a2, unsigned int a3)
{
  size_t v3;
  pthread_mutex_t *v7;
  size_t v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  size_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  size_t v19;

  v3 = 0;
  if (a1 && a2 && (int)a3 >= 1)
  {
    v7 = (pthread_mutex_t *)(a1 + 40);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
    v8 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v8)
    {
      if (v8 >= a3)
        v3 = a3;
      else
        v3 = v8;
      v10 = *(_BYTE **)(a1 + 8);
      v9 = *(_BYTE **)(a1 + 16);
      if (v9 == v10)
      {
        if ((_DWORD)v8 != *(_DWORD *)(a1 + 32))
          cbWrite_cold_1();
        v11 = *(_QWORD *)(a1 + 24);
        v12 = v11 - (_DWORD)v9;
        v13 = v3 - (v11 - (_DWORD)v9);
        if (v3 > (int)v11 - (int)v9)
        {
          __cbWrite((uint64_t *)a1, v9, a2, v11 - (_QWORD)v9);
          v14 = *(_DWORD *)(a1 + 36);
          if (v13 >= v14)
            v15 = v14;
          else
            v15 = v13;
          __cbWrite((uint64_t *)a1, *(void **)(a1 + 16), &a2[v12], v15);
          v3 = (v15 + v12);
          goto LABEL_27;
        }
      }
      else if (v9 >= v10)
      {
        v16 = *(_QWORD *)(a1 + 24) - (_QWORD)v9;
        if (&v10[v16 - *(_QWORD *)a1] != (_BYTE *)v8)
          cbWrite_cold_3();
        v17 = v3 - v16;
        if (v3 > v16)
        {
          __cbWrite((uint64_t *)a1, v9, a2, *(_QWORD *)(a1 + 24) - (_QWORD)v9);
          v18 = *(_DWORD *)(a1 + 36);
          if (v17 >= v18)
            v19 = v18;
          else
            v19 = v17;
          __cbWrite((uint64_t *)a1, *(void **)(a1 + 16), &a2[v16], v19);
          v3 = (v19 + v16);
          goto LABEL_27;
        }
      }
      else
      {
        if (v10 - v9 != v8)
          cbWrite_cold_2();
        if (v8 <= a3)
        {
          __cbWrite((uint64_t *)a1, v9, a2, *(unsigned int *)(a1 + 36));
          v3 = v8;
LABEL_27:
          pthread_mutex_unlock(v7);
          return v3;
        }
      }
      __cbWrite((uint64_t *)a1, v9, a2, v3);
      goto LABEL_27;
    }
    v3 = 0;
    goto LABEL_27;
  }
  return v3;
}

size_t __cbWrite(uint64_t *a1, void *__dst, void *__src, size_t __len)
{
  uint64_t v6;
  uint64_t v7;

  if (!__dst)
    __cbWrite_cold_1();
  if (!__src)
    __cbWrite_cold_2();
  if ((int)__len <= 0)
    __cbWrite_cold_3();
  memmove(__dst, __src, __len);
  v6 = *((unsigned int *)a1 + 8);
  *((_DWORD *)a1 + 9) -= __len;
  v7 = a1[2] + __len;
  if (v7 == *a1 + v6)
    v7 = *a1;
  a1[2] = v7;
  return __len;
}

size_t __cbRead(uint64_t *a1, void *__dst, void *__src, size_t __len)
{
  uint64_t v6;
  uint64_t v7;

  if (!__dst)
    __cbRead_cold_1();
  if (!__src)
    __cbRead_cold_2();
  if ((int)__len <= 0)
    __cbRead_cold_3();
  memmove(__dst, __src, __len);
  v6 = *((unsigned int *)a1 + 8);
  *((_DWORD *)a1 + 9) += __len;
  v7 = a1[1] + __len;
  if (v7 == *a1 + v6)
    v7 = *a1;
  a1[1] = v7;
  return __len;
}

Boolean CFReadStreamHasBytesAvailable(CFReadStreamRef stream)
{
  Boolean v2;
  uint64_t *v3;
  uint64_t (*v4)(CFReadStreamRef, char *, _QWORD);
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFRunLoopSource *v8;

  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
    return -[__CFReadStream hasBytesAvailable](stream, "hasBytesAvailable");
  if ((unint64_t)(_CFStreamGetStatus((uint64_t)stream) - 4) < 0xFFFFFFFFFFFFFFFELL)
    return 0;
  v3 = (uint64_t *)*((_QWORD *)stream + 6);
  v4 = (uint64_t (*)(CFReadStreamRef, char *, _QWORD))v3[8];
  if (!v4)
    return 1;
  *((_QWORD *)stream + 2) |= 0x40uLL;
  if (*v3 > 1)
  {
    v2 = v4(stream, (char *)stream + 24, *((_QWORD *)stream + 5));
    if (*((_QWORD *)stream + 3))
    {
      v5 = *((_QWORD *)stream + 2);
      if ((v5 & 0x1F) != 7)
        *((_QWORD *)stream + 2) = v5 & 0xFFFFFFE0 | 7;
      v6 = *((_QWORD *)stream + 4);
      if (v6 && (*(_BYTE *)(v6 + 48) & 8) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
        v7 = *((_QWORD *)stream + 4);
        if (v7 && (v8 = *(__CFRunLoopSource **)(v7 + 56)) != 0)
        {
          CFRetain(*(CFTypeRef *)(v7 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          *(_QWORD *)(*((_QWORD *)stream + 4) + 72) |= 8uLL;
          CFRunLoopSourceSignal(v8);
          CFRelease(v8);
          _wakeUpRunLoop((uint64_t)stream);
        }
        else
        {
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        }
      }
    }
  }
  else
  {
    v2 = ((uint64_t (*)(CFReadStreamRef, _QWORD))v4)(stream, *((_QWORD *)stream + 5));
  }
  *((_QWORD *)stream + 2) &= ~0x40uLL;
  return v2;
}

BOOL dataCanRead(uint64_t a1, uint64_t a2)
{
  const UInt8 *BytePtr;

  BytePtr = CFDataGetBytePtr(*(CFDataRef *)a2);
  return (unint64_t)&BytePtr[CFDataGetLength(*(CFDataRef *)a2)] > *(_QWORD *)(a2 + 8);
}

BOOL fileCanRead(uint64_t a1, uint64_t a2)
{
  return fdCanRead(*(_DWORD *)(a2 + 8));
}

BOOL fdCanRead(int a1)
{
  _OWORD *v2;
  unsigned int v3;
  size_t v4;
  int v5;
  _OWORD v7[8];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a1 >= 1024)
  {
    v3 = (a1 + 1) >> 5;
    if (((a1 + 1) & 0x1F) != 0)
      ++v3;
    v4 = 4 * v3;
    v2 = malloc_type_malloc(v4, 0xCE0D56CCuLL);
    bzero(v2, v4);
  }
  else
  {
    v2 = v7;
  }
  memset(v7, 0, sizeof(v7));
  if (__darwin_check_fd_set_overflow(a1, v2, 1))
    *(_DWORD *)((char *)v2 + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
  v5 = select_DARWIN_EXTSN();
  if (v2 != v7)
    free(v2);
  return v5 == 1;
}

BOOL boundPairReadCanRead(uint64_t a1, uint64_t a2)
{
  if (!a2)
    return 0;
  if (*(_BYTE *)a2)
    return 0;
  if (_cbCanRead(*(_QWORD *)(a2 + 96)))
    return 1;
  return *(_BYTE *)(a2 + 3) == 1;
}

BOOL _cbCanRead(_BOOL8 result)
{
  if (result)
    return *(_DWORD *)(result + 36) < *(_DWORD *)(result + 32);
  return result;
}

unint64_t _CFNumberFormatterGetFormatter(unint64_t *a1)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID(a1);
  if (v2 != 57)
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  return a1[2];
}

void CFXNotificationRegistrarAddRemoteToken(uint64_t a1, const void *a2, const __CFString *cf, __CFString *cf1, const __CFString *a5, int a6, void *a7, const void *a8)
{
  unsigned int v11;
  const __CFString *v12;
  int v13;
  const __CFString *v14;
  CFHashCode v15;
  CFHashCode v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  int v22;
  uint64_t v23;
  void *v24;
  const void *v25;
  void *v26;
  int v27;
  _DWORD *v28;
  const void *v29;
  __CFDictionary *Mutable;
  uint64_t v31;
  unint64_t v32;
  int v34[2];
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  _OWORD v41[3];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v11 = *(unsigned __int8 *)(a1 + 24);
  if (cf)
  {
    v12 = cf;
    if (CFSTR("kCFNotificationAnyName") != cf && CFEqual(cf, CFSTR("kCFNotificationAnyName")))
      v12 = CFSTR("kCFNotificationAnyName");
  }
  else
  {
    v12 = CFSTR("kCFNotificationAnyName");
  }
  v13 = (v11 >> 1) & 1;
  if (cf1)
  {
    if (v13 && CFSTR("kCFNotificationAnyObject") != cf1 && CFEqual(cf1, CFSTR("kCFNotificationAnyObject")))
      cf1 = CFSTR("kCFNotificationAnyObject");
  }
  else
  {
    cf1 = CFSTR("kCFNotificationAnyObject");
  }
  v14 = CFSTR("kCFNotificationAnyObserver");
  if (a5)
    v14 = a5;
  *(_QWORD *)v34 = v14;
  v15 = CFHash(v12);
  if (v13)
    v16 = CFHash(cf1);
  else
    v16 = ((unint64_t)cf1 >> 5) & 0x7F;
  v17 = (unsigned int *)(a1 + 168);
  do
    v18 = __ldaxr(v17);
  while (__stlxr(v18 + 1, v17));
  v19 = v18 << 32;
  v39 = -1;
  v40 = -1;
  v38 = -1;
  memset(v41, 0, sizeof(v41));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (v12 == CFSTR("kCFNotificationAnyName"))
  {
    if (cf1 == CFSTR("kCFNotificationAnyObject"))
    {
      v21 = (unsigned int *)(a1 + 80);
      v31 = v19;
      v32 = -1;
      v23 = a1;
      v24 = a7;
      v25 = a8;
      v22 = -1;
      goto LABEL_27;
    }
    v21 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, a1 + 48, cf1, v16, &v39, -1, v13) + 16);
    v22 = v39;
    LODWORD(v32) = -1;
    HIDWORD(v32) = v39;
LABEL_26:
    v31 = v19;
    v23 = a1;
    v24 = a7;
    v25 = a8;
LABEL_27:
    v26 = *(void **)v34;
    v27 = a6;
    goto LABEL_29;
  }
  if (cf1 != CFSTR("kCFNotificationAnyObject"))
  {
    v20 = _CFXNotificationRegistrarAddName(a1, a1 + 32, v12, v15, &v40, 0);
    v21 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, v20 + 24, cf1, v16, &v39, v40, v13) + 16);
    v22 = v39;
    v32 = __PAIR64__(v39, v40);
    goto LABEL_26;
  }
  v21 = (unsigned int *)(_CFXNotificationRegistrarAddName(a1, a1 + 64, v12, v15, &v40, 1) + 24);
  v24 = a7;
  v27 = a6 | 0x800;
  v22 = v40;
  v32 = __PAIR64__(v39, v40);
  v31 = v19;
  v23 = a1;
  v25 = a8;
  v26 = *(void **)v34;
LABEL_29:
  v28 = _CFXNotificationRegistrarAddObserver(v23, v21, v24, v25, v22, v26, &v38, v27, v31, v32, SHIDWORD(v32), (unsigned int *)v41);
  if (v28)
  {
    v29 = (const void *)(v19 | v38);
    Mutable = *(__CFDictionary **)(a1 + 88);
    if (!Mutable)
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0);
      *(_QWORD *)(a1 + 88) = Mutable;
    }
    CFDictionarySetValue(Mutable, a2, v29);
    *((_QWORD *)v28 + 4) = a2;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationDisposalListRelease((unsigned int *)v41);
}

__n128 CFBurstTrieCursorAdvanceForBytes(uint64_t a1)
{
  char v2;
  __n128 result;
  int v4;
  __n128 v5;

  if (*(_QWORD *)(a1 + 17) == 1)
  {
    v2 = *(_BYTE *)(a1 + 16);
    v5 = *(__n128 *)a1;
    advanceMapCursor(*(_QWORD *)(a1 + 25), a1);
    if (!v4)
    {
      *(_BYTE *)(a1 + 16) = v2;
      result = v5;
      *(__n128 *)a1 = v5;
    }
  }
  return result;
}

void advanceMapCursor(uint64_t a1, uint64_t a2)
{
  __asm { BR              X11 }
}

BOOL sub_182B8BBC4(uint64_t a1)
{
  int v1;
  _DWORD *v2;
  uint64_t v3;
  unsigned __int8 *v4;

  return v1 == *(_DWORD *)(*(_QWORD *)(a1 + 2056) + 4) && advanceCursorMappedLevel(a1, v2, v4, v3) != 0;
}

uint64_t advanceCursorMappedLevel(uint64_t a1, _DWORD *a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;

  v4 = 0;
  if (a3 && (a4 & 0x8000000000000000) == 0)
  {
    v5 = (*a2 & 0xFFFFFFFC) + *(_QWORD *)(a1 + 2056);
    if (a4)
    {
      *a2 = *(_DWORD *)(v5 + 4 * *a3);
      return advanceMapCursor();
    }
    a2[3] = *(_DWORD *)(v5 + 1024);
    return 1;
  }
  return v4;
}

uint64_t _CFPreferencesSynchronizeWithContainer(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  void *v8;
  uint64_t v9;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v8 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v9 = -[_CFXPreferences synchronizeIdentifier:user:host:container:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

void sub_182B8C334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __notifyFunc_block_invoke_4(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  __int128 v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4 = *(_OWORD *)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 48);
  v1 = *(_QWORD *)(a1 + 56);
  v5 = v2;
  return notifyFunc(v1, &v4);
}

void notifyFunc(_xpc_connection_s *a1, uint64_t *a2)
{
  _xpc_connection_s *v2;
  uint64_t v5;
  BOOL v6;
  BOOL v7;
  _xpc_connection_s *v8;
  _xpc_connection_s *v9;
  xpc_object_t v10;
  uint64_t v11;
  _QWORD v12[8];
  _QWORD v13[5];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = (_xpc_connection_s *)a2[2];
  if (v2 != a1)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v5 = MEMORY[0x1E0C809B0];
    v17 = 0;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __notifyFunc_block_invoke;
    v13[3] = &unk_1E13367B0;
    v13[4] = &v14;
    v6 = withClientContext(a1, (uint64_t)v13);
    if (*((_BYTE *)v15 + 24))
      v7 = 0;
    else
      v7 = v6;
    if (v7)
    {
      v8 = a1;
      v9 = v2;
      v10 = xpc_copy((xpc_object_t)a2[1]);
      v11 = *a2;
      if (_CFPrefsObservationConnectionQueue_onceToken != -1)
        dispatch_once(&_CFPrefsObservationConnectionQueue_onceToken, &__block_literal_global_344);
      v12[0] = v5;
      v12[1] = 3221225472;
      v12[2] = __notifyFunc_block_invoke_2;
      v12[3] = &unk_1E1336800;
      v12[4] = a1;
      v12[5] = v11;
      v12[6] = v10;
      v12[7] = v2;
      xpc_connection_send_message_with_reply(a1, v10, (dispatch_queue_t)_CFPrefsObservationConnectionQueue_observationQueue, v12);
    }
    _Block_object_dispose(&v14, 8);
  }
}

void sub_182B8C510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFBinaryHeapRef CFBinaryHeapCreate(CFAllocatorRef allocator, CFIndex capacity, const CFBinaryHeapCallBacks *callBacks, const CFBinaryHeapCompareContext *compareContext)
{
  return (CFBinaryHeapRef)__CFBinaryHeapCreateInit((__objc2_class **)allocator, 0, 0, (uint64_t)callBacks, (__int128 *)&compareContext->version);
}

uint64_t __NSCollectionsShouldCopy()
{
  return 0;
}

void CFRunLoopStop(CFRunLoopRef rl)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  if (*((_QWORD *)rl + 78))
  {
    *((_BYTE *)rl + *((unsigned __int8 *)rl + 84) + 85) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
    CFRunLoopWakeUp(rl);
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }
}

void CFStorageDeleteValues(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFAllocatorRef v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  int64_t *v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int64_t v20;
  int64_t v21;
  unsigned int *v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int v35;

  v6 = CFGetAllocator((CFTypeRef)a1);
  v7 = *(_DWORD *)(a1 + 24);
  if (v7 == -1)
  {
    v10 = *(_QWORD *)(a1 + 16);
    v8 = v10 * a2;
    v9 = v10 * a3;
  }
  else
  {
    v8 = a2 << v7;
    v9 = a3 << v7;
  }
  os_unfair_lock_lock_with_options();
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 128));
  v11 = __CFStorageDeleteUnfrozen((uint64_t)v6, a1, a1 + 144, v8, v9, 1);
  if (v11)
  {
    v12 = v11;
    if (v11 != a1 + 144)
    {
      v13 = *(_QWORD *)v11;
      v14 = *(_BYTE *)(v11 + 13);
      *(_QWORD *)(a1 + 160) = 0;
      v15 = (int64_t *)(a1 + 160);
      *(_QWORD *)(a1 + 144) = v13;
      *(_BYTE *)(a1 + 157) = v14;
      *(_QWORD *)(a1 + 168) = 0;
      *(_QWORD *)(a1 + 176) = 0;
      if (*(_BYTE *)(v11 + 13))
      {
        if (*(_BYTE *)(v11 + 12))
        {
          v16 = *(const void **)(v11 + 24);
          if (v16)
          {
            v17 = *MEMORY[0x1E0C85AD8];
            if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
              v18 = *MEMORY[0x1E0C85AD8];
            else
              v18 = v17 + 1;
            if (v13 <= v18 >> 1)
            {
              v31 = v13 + 63;
              v30 = v13 < -63;
              v32 = v13 + 126;
              if (!v30)
                v32 = v31;
              v20 = v32 & 0xFFFFFFFFFFFFFFC0;
            }
            else
            {
              v19 = (v13 + v17 - 1) & -(int)v17;
              if (*(_QWORD *)(a1 + 136) >= v19)
                v20 = v19;
              else
                v20 = *(_QWORD *)(a1 + 136);
            }
            if (v20 > *v15)
            {
              pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
              if (v20 > *(_QWORD *)(a1 + 160))
              {
                *(_QWORD *)(a1 + 168) = __CFSafelyReallocateWithAllocatorTyped(v6, *(_QWORD *)(a1 + 168), v20, 1893177561, 0, 0);
                if (__CFOASafe)
                  __CFSetLastAllocationEventName();
                *v15 = v20;
              }
              pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
              v16 = *(const void **)(v12 + 24);
            }
            memmove(*(void **)(a1 + 168), v16, *(_QWORD *)v12);
          }
        }
        else
        {
          *(_QWORD *)(a1 + 168) = *(_QWORD *)(v11 + 24);
          *(_QWORD *)(v11 + 16) = 0;
          *(_QWORD *)(v11 + 24) = 0;
          *(_QWORD *)(v11 + 32) = 0;
        }
      }
      else
      {
        v21 = *(_QWORD *)(v11 + 16);
        v22 = (unsigned int *)(v21 + 8);
        if (*(_DWORD *)(v21 + 8))
        {
          do
            v23 = __ldxr(v22);
          while (__stxr(v23 + 1, v22));
        }
        *v15 = v21;
        v24 = *(_QWORD *)(v11 + 24);
        v25 = (unsigned int *)(v24 + 8);
        if (*(_DWORD *)(v24 + 8))
        {
          do
            v26 = __ldxr(v25);
          while (__stxr(v26 + 1, v25));
        }
        *(_QWORD *)(a1 + 168) = v24;
        v27 = *(_QWORD *)(v11 + 32);
        if (v27)
        {
          v28 = (unsigned int *)(v27 + 8);
          if (*(_DWORD *)(v27 + 8))
          {
            do
              v29 = __ldxr(v28);
            while (__stxr(v29 + 1, v28));
          }
          *(_QWORD *)(a1 + 176) = v27;
        }
      }
    }
    v33 = (unsigned int *)(v12 + 8);
    if (*(_DWORD *)(v12 + 8))
    {
      do
      {
        v34 = __ldxr(v33);
        v35 = v34 - 1;
      }
      while (__stxr(v35, v33));
      if (!v35)
        __CFStorageDeallocateNode((const void *)a1, v12);
    }
  }
  else
  {
    __CFStorageClearRootNode(a1);
  }
}

uint64_t __CFStorageDeleteUnfrozen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int *v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  unsigned int *v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)a3 - a5;
  if (*(_QWORD *)a3 == a5)
    return 0;
  v7 = a3;
  if (*(_BYTE *)(a3 + 13))
  {
    *(_QWORD *)a3 = v6;
    v12 = *(_QWORD *)(a3 + 24);
    if (v12)
    {
      memmove((void *)(v12 + a4), (const void *)(v12 + a4 + a5), v6 - a4);
      if (a6)
      {
        v13 = *(_QWORD *)v7;
        v14 = *MEMORY[0x1E0C85AD8];
        if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
          v15 = *MEMORY[0x1E0C85AD8];
        else
          v15 = v14 + 1;
        if (v13 <= v15 >> 1)
        {
          v47 = v13 + 63;
          v28 = v13 < -63;
          v48 = v13 + 126;
          if (!v28)
            v48 = v47;
          v17 = v48 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          v16 = (v13 + v14 - 1) & -(int)v14;
          if (*(_QWORD *)(a2 + 136) >= v16)
            v17 = v16;
          else
            v17 = *(_QWORD *)(a2 + 136);
        }
        if (v17 != *(_QWORD *)(v7 + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v17 != *(_QWORD *)(v7 + 16))
          {
            *(_QWORD *)(v7 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(_QWORD *)(v7 + 24), v17, 1893177561, 0, 0);
            if (__CFOASafe)
              __CFSetLastAllocationEventName();
            *(_QWORD *)(v7 + 16) = v17;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        }
      }
    }
    goto LABEL_65;
  }
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v52 = 0uLL;
  v21 = (_QWORD *)(a3 + 16);
  v22 = a4 + a5;
  v53 = 0;
  do
  {
    v23 = v21[v20];
    if (!v23)
      break;
    v24 = *(_QWORD *)v23;
    if (a4 <= v19)
      v25 = v19;
    else
      v25 = a4;
    v26 = v24 + v19;
    if (v22 >= v24 + v19)
      v27 = v24 + v19;
    else
      v27 = a4 + a5;
    v28 = v27 <= v25;
    v29 = v27 - v25;
    if (v28)
      v30 = 0;
    else
      v30 = v29;
    if (v28)
      v31 = 0;
    else
      v31 = v25;
    if (!v30)
    {
      v33 = (unsigned int *)(v23 + 8);
      if (*(_DWORD *)(v23 + 8))
      {
        do
          v34 = __ldxr(v33);
        while (__stxr(v34 + 1, v33));
      }
LABEL_37:
      *((_QWORD *)&v52 + v18++) = v23;
      goto LABEL_38;
    }
    if (!*(_BYTE *)(v23 + 12))
      goto LABEL_31;
    if (*(_DWORD *)(v23 + 8) == 1)
    {
      *(_BYTE *)(v23 + 12) = 0;
LABEL_31:
      v32 = __CFStorageDeleteUnfrozen(a1, a2);
      goto LABEL_36;
    }
    v32 = __CFStorageDeleteFrozen(a1, a2, (uint64_t *)v23, v31 - v19, v30);
LABEL_36:
    v23 = v32;
    if (v32)
      goto LABEL_37;
LABEL_38:
    ++v20;
    v19 = v26;
  }
  while (v20 != 3);
  *(_QWORD *)v7 -= a5;
  v35 = *(_QWORD *)(v7 + 16);
  v36 = (unsigned int *)(v35 + 8);
  if (*(_DWORD *)(v35 + 8))
  {
    do
    {
      v37 = __ldxr(v36);
      v38 = v37 - 1;
    }
    while (__stxr(v38, v36));
    if (!v38)
      __CFStorageDeallocateNode((const void *)a2, v35);
  }
  v39 = *(_QWORD *)(v7 + 24);
  if (v39)
  {
    v40 = (unsigned int *)(v39 + 8);
    if (*(_DWORD *)(v39 + 8))
    {
      do
      {
        v41 = __ldxr(v40);
        v42 = v41 - 1;
      }
      while (__stxr(v42, v40));
      if (!v42)
        __CFStorageDeallocateNode((const void *)a2, v39);
    }
  }
  v43 = *(_QWORD *)(v7 + 32);
  if (v43)
  {
    v44 = (unsigned int *)(v43 + 8);
    if (*(_DWORD *)(v43 + 8))
    {
      do
      {
        v45 = __ldxr(v44);
        v46 = v45 - 1;
      }
      while (__stxr(v46, v44));
      if (!v46)
        __CFStorageDeallocateNode((const void *)a2, v43);
    }
  }
  *v21 = 0;
  *(_QWORD *)(v7 + 24) = 0;
  *(_QWORD *)(v7 + 32) = 0;
  if (v18 == 1)
    return v52;
  *(_OWORD *)v21 = v52;
  *(_QWORD *)(v7 + 32) = v53;
LABEL_65:
  v49 = *(_DWORD *)(v7 + 8);
  if (v49)
    *(_DWORD *)(v7 + 8) = v49 + 1;
  return v7;
}

uint64_t __CFDictionaryGetValueCallbacks@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v8 = 0u;
  result = __CFBasicHashGetCallbacks(a1, &v8);
  v4 = v8;
  v5 = v9;
  *a2 = 0;
  a2[1] = v4;
  v6 = v12;
  v7 = v10;
  a2[2] = v5;
  a2[3] = v6;
  a2[4] = v7;
  return result;
}

uint64_t __CFBasicHashGetCallbacks@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v3 = *(_QWORD *)(a1 + 24);
  v2 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(CFBasicHashCallBackPtrs[(v3 >> 39) & 0x1F] + 8 * ((v3 >> 34) & 0x1F));
  v5 = *(_QWORD *)(CFBasicHashCallBackPtrs[((v3 >> 24) >> 5) & 0x1F] + 8 * ((v3 >> 24) & 0x1F));
  v6 = *(_QWORD *)(*(uint64_t *)((char *)CFBasicHashCallBackPtrs + (HIBYTE(v3) & 0xF8)) + 8 * ((v3 >> 54) & 0x1F));
  v7 = *(_QWORD *)(CFBasicHashCallBackPtrs[(v3 >> 49) & 0x1F] + 8 * ((v3 >> 44) & 0x1F));
  v8 = *(_QWORD *)(CFBasicHashCallBackPtrs[((v2 >> 34) >> 5) & 0x1F] + 8 * ((v2 >> 34) & 0x1F));
  v9 = *(_QWORD *)(CFBasicHashCallBackPtrs[((v2 >> 24) >> 5) & 0x1F] + 8 * ((v2 >> 24) & 0x1F));
  result = (v2 >> 44) & 0x1F;
  v11 = *(_QWORD *)(CFBasicHashCallBackPtrs[((v2 >> 44) >> 5) & 0x1F] + 8 * result);
  *a2 = v4;
  a2[1] = v5;
  v12 = CFBasicHashCallBackPtrs[(v2 >> 54) >> 5];
  a2[2] = v6;
  a2[3] = v7;
  v13 = *(_QWORD *)(v12 + 8 * ((v2 >> 54) & 0x1F));
  v14 = *(_QWORD *)(CFBasicHashCallBackPtrs[((v2 >> 14) >> 5) & 0x1F] + 8 * ((v2 >> 14) & 0x1F));
  a2[4] = v8;
  a2[5] = v9;
  v15 = CFBasicHashCallBackPtrs[((v2 >> 4) >> 5) & 0x1F];
  a2[6] = v11;
  a2[7] = v13;
  v16 = *(_QWORD *)(v15 + 8 * ((v2 >> 4) & 0x1F));
  a2[8] = v14;
  a2[9] = v16;
  return result;
}

double __CFDictionaryGetKeyCallbacks@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double result;
  __int128 v7;
  __int128 v8;
  _OWORD v9[2];
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = 0u;
  v8 = 0u;
  memset(v9, 0, sizeof(v9));
  v7 = 0u;
  __CFBasicHashGetCallbacks(a1, &v7);
  v3 = *((_QWORD *)&v7 + 1);
  v4 = *((_QWORD *)&v8 + 1);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = v3;
  v5 = *((_QWORD *)&v10 + 1);
  *(_QWORD *)(a2 + 16) = v4;
  *(_QWORD *)(a2 + 24) = v5;
  result = *((double *)v9 + 1);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)((char *)v9 + 8);
  return result;
}

_DWORD *CFBurstTrieCreateFromMapBytes(_DWORD *result)
{
  _DWORD *v1;
  int v2;
  int v4;

  if (result)
  {
    v1 = result;
    v2 = *result;
    if (*result == 14531089 || v2 == -889275714)
    {
      result = malloc_type_malloc(0x830uLL, 0x1010040873DE71CuLL);
      *((_QWORD *)result + 257) = v1;
      v4 = v1[4];
      result[516] = v1[3];
LABEL_10:
      result[518] = v4;
      result[519] = v1[2];
      atomic_store(1u, result + 521);
      *((_BYTE *)result + 2088) = 0;
      return result;
    }
    if (v2 == -1161889074)
    {
      result = malloc_type_malloc(0x830uLL, 0x1010040873DE71CuLL);
      *((_QWORD *)result + 257) = v1;
      v4 = v1[4];
      result[516] = v1[3];
      result[517] = v1[1];
      goto LABEL_10;
    }
    return 0;
  }
  return result;
}

Boolean CFGregorianDateIsValid(CFGregorianDate gdate, CFOptionFlags unitFlags)
{
  uint64_t v2;
  SInt8 month;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;

  v2 = *(_QWORD *)&gdate.year;
  if ((unitFlags & 1) != 0 && gdate.year < 1)
    return 0;
  month = gdate.month;
  if ((unitFlags & 2) != 0 && (gdate.month - 1) > 0xBu)
    return 0;
  v4 = *(_QWORD *)&gdate.year >> 40;
  if ((unitFlags & 4) != 0 && (gdate.day - 1) > 0x1Eu)
    return 0;
  if ((unitFlags & 8) != 0 && (*(_QWORD *)&gdate.year >> 24) >> 27 > 2)
    return 0;
  if ((unitFlags & 0x10) == 0
    || (LOBYTE(gdate.year) = 0, (v2 & 0x8000000000000000) == 0) && *(int *)&gdate.month <= 1006632959)
  {
    if ((unitFlags & 0x20) == 0 || (LOBYTE(gdate.year) = 0, gdate.second >= 0.0) && gdate.second < 60.0)
    {
      if ((~(_BYTE)unitFlags & 7) != 0)
      {
        LOBYTE(gdate.year) = 1;
      }
      else
      {
        if ((gdate.month - 1) >= 0xCu)
        {
          gdate.year = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
          if (gdate.year)
            CFGregorianDateIsValid_cold_1(month);
        }
        v5 = ((int)v2 - 2001 + 1) % 400;
        if (v5 >= 0)
          v6 = ((int)v2 - 2001 + 1) % 400;
        else
          v6 = -v5;
        if ((v6 & 3) != 0)
        {
          v7 = 0;
        }
        else
        {
          v7 = 0;
          if (v6 != 100 && v6 != 200)
            v7 = v6 != 300;
        }
        if (BYTE4(v2) >= 0x10u)
        {
          __break(1u);
        }
        else
        {
          if (BYTE4(v2) != 2)
            v7 = 0;
          LOBYTE(gdate.year) = (daysInMonth[BYTE4(v2)] + v7) >= (char)v4;
        }
      }
    }
  }
  return gdate.year;
}

CFMutableDictionaryRef _CFPreferencesCopyMultipleWithContainer(uint64_t a1, __CFString *a2, const __CFString *a3, const void *a4, const __CFString *a5)
{
  os_unfair_lock *v10;
  CFMutableDictionaryRef v11;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v10 = (os_unfair_lock *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v11 = -[_CFXPreferences copyValuesForKeys:identifier:user:host:container:](v10, a1, a2, a3, a4, a5);

  return v11;
}

void sub_182B8D6AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFTimeZoneRef CFTimeZoneCreateWithName(CFAllocatorRef allocator, CFStringRef name, Boolean tryAbbrev)
{
  int v3;
  void *v6;
  const __CFTimeZone *v7;

  v3 = tryAbbrev;
  if (CFEqual(&stru_1E1337B18, name))
    return 0;
  v6 = (void *)_CFAutoreleasePoolPush();
  v7 = (const __CFTimeZone *)(id)+[NSTimeZone _timeZoneWithName:tryAbbrev:](NSTimeZone, "_timeZoneWithName:tryAbbrev:", name, v3 != 0);
  _CFAutoreleasePoolPop(v6);
  return v7;
}

void CFRunLoopSourceGetContext(CFRunLoopSourceRef source, CFRunLoopSourceContext *context)
{
  unint64_t v4;
  uint64_t v5;
  size_t v6;

  v4 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v4 != 46)
    _CFAssertMismatchedTypeID(0x2EuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v5 = 72;
  if (context->version != 1)
    v5 = 0;
  if (context->version)
    v6 = v5;
  else
    v6 = 80;
  memmove(context, (char *)source + 104, v6);
}

CFURLRef CFBundleCopySupportFilesDirectoryURL(CFBundleRef bundle)
{
  unint64_t v2;
  const __CFURL *v3;
  unsigned int v4;
  const __CFString *v5;
  const __CFString *v7;

  v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  v3 = (const __CFURL *)*((_QWORD *)bundle + 2);
  if (!v3)
    return 0;
  v4 = *((unsigned __int8 *)bundle + 53);
  if (v4 <= 0xB)
  {
    if (v4 == 1)
    {
      v5 = CFSTR("Support%20Files/");
      return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, v3);
    }
    if (v4 == 2)
    {
      v5 = CFSTR("Contents/");
      return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, v3);
    }
    return (CFURLRef)CFRetain(*((CFTypeRef *)bundle + 2));
  }
  if (v4 == 12)
  {
    v7 = CFSTR("WrappedBundle/Contents/");
    return _CFURLCreateResolvedDirectoryWithString((const __CFAllocator *)&__kCFAllocatorSystemDefault, v7, v3);
  }
  if (v4 == 13)
  {
    v7 = CFSTR("WrappedBundle/");
    return _CFURLCreateResolvedDirectoryWithString((const __CFAllocator *)&__kCFAllocatorSystemDefault, v7, v3);
  }
  return (CFURLRef)CFRetain(*((CFTypeRef *)bundle + 2));
}

void CFAllocatorGetContext(CFAllocatorRef allocator, CFAllocatorContext *context)
{
  CFAllocatorRef v3;
  uint64_t v4;
  malloc_zone_t *v5;

  v3 = allocator;
  if (!allocator)
  {
    v4 = _CFGetTSD(1u);
    if (v4)
      v3 = (CFAllocatorRef)v4;
    else
      v3 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
  }
  if (*(_QWORD *)v3 == qword_1ECCFACA8)
  {
    context->version = 0;
    v5 = (malloc_zone_t *)*((_QWORD *)v3 + 18);
    if (v5 == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder)
      v5 = malloc_default_zone();
    context->info = v5;
    *(_OWORD *)&context->retain = *(_OWORD *)((char *)v3 + 152);
    *(_OWORD *)&context->copyDescription = *(_OWORD *)((char *)v3 + 168);
    *(_OWORD *)&context->reallocate = *(_OWORD *)((char *)v3 + 184);
    context->preferredSize = (CFAllocatorPreferredSizeCallBack)*((_QWORD *)v3 + 25);
  }
}

void __magic_cookie_block_invoke()
{
  while (!magic_cookie_oValue)
    arc4random_buf(&magic_cookie_oValue, 4uLL);
}

uint64_t _CFURLComponentsSetFragment(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setFragment:", a2);
  return 1;
}

uint64_t _CFURLComponentsGetURLFragmentAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1)
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  return *(_QWORD *)(sURLAllowedCharacterSets + 40);
}

void __notifyFunc_block_invoke_2(uint64_t a1, id a2)
{
  uint64_t v3;
  _xpc_connection_s *v4;
  uint64_t v5;
  _QWORD v6[4];
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[5];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (object_getClass(a2) != (Class)MEMORY[0x1E0C81310])
  {
    v11 = 0;
    v12 = &v11;
    v13 = 0x2020000000;
    v14 = 0;
    v3 = MEMORY[0x1E0C809B0];
    v4 = *(_xpc_connection_s **)(a1 + 32);
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3221225472;
    v10[2] = __notifyFunc_block_invoke_3;
    v10[3] = &unk_1E13367B0;
    v10[4] = &v11;
    if (withClientContext(v4, (uint64_t)v10) && *((_BYTE *)v12 + 24))
    {
      v6[0] = v3;
      v6[1] = 3221225472;
      v6[2] = __notifyFunc_block_invoke_4;
      v6[3] = &unk_1E13367D8;
      v7 = *(_OWORD *)(a1 + 40);
      v5 = *(_QWORD *)(a1 + 32);
      v8 = *(_QWORD *)(a1 + 56);
      v9 = v5;
      -[CFPDSource observingConnectionsLockedSync:]((os_unfair_lock_s *)v7, (uint64_t)v6);
    }
    _Block_object_dispose(&v11, 8);
  }

}

void sub_182B8DF28(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 72), 8);
  _Unwind_Resume(a1);
}

void CFStringTokenizerSetString(CFStringTokenizerRef tokenizer, CFStringRef string, CFRange range)
{
  __NLStringTokenizerSetString(*((_QWORD *)tokenizer + 2), string, range.location, range.length);
}

id (__cdecl *_CFDoExceptionOperation(uint64_t a1, id (__cdecl *exception)(id)))(id)
{
  id (__cdecl *result)(id);

  if (a1 <= 139)
  {
    if (a1 == 100)
      return (id (__cdecl *)(id))__uncaughtExceptionHandler;
    if (a1 == 101)
    {
      result = 0;
      __uncaughtExceptionHandler = (uint64_t (*)(_QWORD))exception;
      return result;
    }
  }
  else
  {
    result = (id (__cdecl *)(id))__exceptionPreprocess;
    switch(a1)
    {
      case 160:
        return result;
      case 161:
        if (exception)
          result = exception;
        objc_setExceptionPreprocessor(result);
        break;
      case 140:
        objc_exception_throw(exception);
    }
  }
  return 0;
}

CFTypeRef CFReadStreamCopyProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName)
{
  CFTypeRef result;
  uint64_t (*v5)(CFReadStreamRef, CFStreamPropertyKey, _QWORD);

  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
    return (id)-[__CFReadStream propertyForKey:](stream, "propertyForKey:", propertyName);
  v5 = *(uint64_t (**)(CFReadStreamRef, CFStreamPropertyKey, _QWORD))(*((_QWORD *)stream + 6) + 96);
  if (!v5)
    return 0;
  *((_QWORD *)stream + 2) |= 0x40uLL;
  result = (CFTypeRef)v5(stream, propertyName, *((_QWORD *)stream + 5));
  *((_QWORD *)stream + 2) &= ~0x40uLL;
  return result;
}

void CFPreferencesFlushCaches()
{
  _CFPrefsResetPreferences(0);
}

int64_t __CFSocketRead(uint64_t a1, void *a2, int64_t a3, int *a4)
{
  pthread_mutex_t *v8;
  const __CFData *v9;
  CFIndex Length;
  const UInt8 *BytePtr;
  CFIndex v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const UInt8 *v16;
  uint64_t v17;
  int64_t v18;
  int v19;
  CFSocketNativeHandle Native;
  ssize_t v22;
  int *v23;
  int v24;
  CFRange v25;

  v8 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  *a4 = 0;
  v9 = *(const __CFData **)(a1 + 328);
  if (v9)
  {
    Length = CFDataGetLength(v9);
    if (Length < a3)
      a3 = Length;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 328));
    memcpy(a2, BytePtr, a3);
    v12 = CFDataGetLength(*(CFDataRef *)(a1 + 328));
    v13 = *(void **)(a1 + 328);
    if (a3 >= v12)
    {
      CFRelease(v13);
      *(_QWORD *)(a1 + 328) = 0;
    }
    else
    {
      v25.location = 0;
      v25.length = a3;
      CFDataReplaceBytes((CFMutableDataRef)v13, v25, 0, 0);
    }
  }
  else if (*(_QWORD *)(a1 + 296) && (v14 = *(_QWORD *)(a1 + 312), v15 = *(_QWORD *)(a1 + 304) - v14, v15 >= 1))
  {
    if (v15 < a3)
      a3 = *(_QWORD *)(a1 + 304) - v14;
    v16 = CFDataGetBytePtr(*(CFDataRef *)(a1 + 288));
    memcpy(a2, &v16[*(_QWORD *)(a1 + 312)], a3);
    v17 = *(_QWORD *)(a1 + 304);
    v18 = *(_QWORD *)(a1 + 312) + a3;
    *(_QWORD *)(a1 + 312) = v18;
    if (v18 == v17)
    {
      *(_QWORD *)(a1 + 304) = 0;
      *(_QWORD *)(a1 + 312) = 0;
    }
  }
  else
  {
    v19 = *(_DWORD *)(a1 + 324);
    if (v19)
    {
      *a4 = v19;
      a3 = -1;
    }
    else if (*(_BYTE *)(a1 + 320))
    {
      a3 = 0;
    }
    else
    {
      Native = CFSocketGetNative((CFSocketRef)a1);
      v22 = read(Native, a2, a3);
      a3 = v22;
      if (v22)
      {
        if (v22 < 0)
        {
          v23 = __error();
          v24 = *v23;
          *a4 = *v23;
          if (v24 != 35)
            *(_DWORD *)(a1 + 324) = v24;
        }
      }
      else
      {
        *(_BYTE *)(a1 + 320) = 1;
      }
    }
  }
  pthread_mutex_unlock(v8);
  return a3;
}

CFSocketNativeHandle CFSocketGetNative(CFSocketRef s)
{
  unint64_t v2;

  if (CFSocketGetTypeID_initOnce == -1)
  {
    if (!s)
      goto LABEL_4;
  }
  else
  {
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
    if (!s)
      goto LABEL_4;
  }
  v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
LABEL_4:
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (s)
    return *((_DWORD *)s + 38);
  else
    return -1;
}

uint64_t _CFURLComponentsCreateCopy(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "copy");
}

uint64_t _CFPreferencesCopyKeyListWithContainer(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  void *v8;
  uint64_t v9;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v8 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v9 = -[_CFXPreferences copyKeyListForIdentifier:user:host:container:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

void sub_182B8E9C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFCalendarRef CFCalendarCopyCurrent(void)
{
  return (CFCalendarRef)(id)+[NSCalendar _current](NSCalendar, "_current");
}

void CFStringNormalize(CFMutableStringRef theString, CFStringNormalizationForm theForm)
{
  CFMutableStringRef v2;
  unint64_t *p_info;
  char v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  char **p_data;
  unsigned __int8 **v18;
  uint64_t length;
  uint64_t v20;
  char v21;
  char v22;
  char **v23;
  char **v24;
  char v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  char v31;
  char **v32;
  char *v33;
  char v34;
  unint64_t v35;
  char v36;
  char *v37;
  char v38;
  unsigned __int16 *v39;
  uint64_t v40;
  uint64_t UnicodePropertyDataForPlane;
  uint64_t v42;
  unsigned int *Typed;
  unsigned int v44;
  unsigned __int16 *v45;
  BOOL v46;
  char v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  unsigned int v53;
  int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned __int16 *v59;
  unsigned int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  unsigned __int16 *v66;
  BOOL v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  _BOOL4 v74;
  unsigned __int16 *v75;
  uint64_t v76;
  unsigned int v77;
  uint64_t v78;
  unsigned int *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  unint64_t v90;
  unsigned int *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unsigned int v95;
  uint64_t v96;
  uint64_t v97;
  unsigned int v98;
  uint64_t v99;
  int v100;
  unint64_t v101;
  unsigned int *v102;
  uint64_t v103;
  unsigned __int16 *v104;
  unint64_t v105;
  unsigned __int16 *v106;
  unsigned __int16 *v107;
  unsigned int v109;
  uint64_t v110;
  int v111;
  uint64_t v112;
  uint64_t v113;
  unsigned int *v114;
  unsigned int v115;
  unsigned int *v116;
  unsigned int *v117;
  int v118;
  char v119;
  uint64_t v120;
  char v121;
  char *v122;
  char v123;
  char v124;
  char v125;
  uint64_t v126;
  char *v127;
  uint64_t v128;
  char v129;
  unsigned int *v130;
  char *v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int v134;
  char *v135;
  uint64_t v136;
  _BOOL4 v137;
  char v138;
  __CFString *v139;
  char **v140;
  unsigned int *v141;
  unsigned int v142;
  unsigned int *v143;
  unsigned int v144;
  uint64_t v145;
  uint64_t BitmapPtrForPlane;
  uint64_t v147;
  unsigned __int16 *v148;
  unsigned __int16 *v149;
  unsigned __int16 *v150;
  unint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  _QWORD v156[2];
  _QWORD __src[34];

  v2 = theString;
  __src[32] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfNormalize:](v2, "_cfNormalize:", theForm);
    return;
  }
  p_info = (unint64_t *)&v2->info;
  v4 = atomic_load((unint64_t *)&v2->info);
  if ((v4 & 1) == 0)
  {
    v5 = _CFOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      CFStringNormalize_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
    return;
  }
  v13 = atomic_load(p_info);
  v14 = v13 & 5;
  v15 = atomic_load(p_info);
  v16 = v15 & 0x60;
  if (v14 == 4)
  {
    p_data = &v2->data;
    if (v16)
    {
      v18 = (unsigned __int8 **)*p_data;
    }
    else
    {
      v20 = atomic_load((unint64_t *)&v2->info);
      v18 = (unsigned __int8 **)&p_data[(v20 & 5) != 4];
    }
    length = *(unsigned __int8 *)v18;
  }
  else if ((v15 & 0x60) != 0)
  {
    length = v2->length;
  }
  else
  {
    length = (uint64_t)v2->data;
  }
  v21 = atomic_load((unint64_t *)&v2->info);
  if ((v21 & 0x10) != 0)
    goto LABEL_25;
  if (theForm == kCFStringNormalizationFormC)
    return;
  v22 = atomic_load((unint64_t *)&v2->info);
  v23 = &v2->data;
  if ((v22 & 0x60) != 0)
  {
    v24 = (char **)*v23;
  }
  else
  {
    v25 = atomic_load((unint64_t *)&v2->info);
    v24 = &v23[(v25 & 5) != 4];
  }
  v26 = atomic_load((unint64_t *)&v2->info);
  if (length < 1)
  {
LABEL_25:
    v28 = 0;
    v137 = 1;
  }
  else
  {
    v27 = (v26 >> 2) & 1;
    if (*((char *)v24 + v27) < 0)
    {
      v137 = 0;
      v28 = 0;
    }
    else
    {
      v28 = 0;
      v29 = (uint64_t)v24 + v27 + 1;
      do
      {
        if (length - 1 == v28)
          return;
        v30 = *(char *)(v29 + v28++);
      }
      while ((v30 & 0x80000000) == 0);
      v137 = v28 >= length;
    }
    __src[0] = 0;
    __src[1] = 0;
    __CFStringChangeSizeMultiple((uint64_t)v2, (uint64_t)__src, 1, 0, 1);
  }
  if (v28 < length)
  {
    v31 = atomic_load((unint64_t *)&v2->info);
    v32 = &v2->data;
    if ((v31 & 0x60) != 0)
    {
      v33 = *v32;
    }
    else
    {
      v34 = atomic_load((unint64_t *)&v2->info);
      v33 = (char *)&v32[(v34 & 5) != 4];
    }
    v35 = (unint64_t)&v33[2 * length];
    v36 = atomic_load((unint64_t *)&v2->info);
    v140 = &v2->data;
    if ((v36 & 0x60) != 0)
    {
      v37 = *v32;
    }
    else
    {
      v38 = atomic_load((unint64_t *)&v2->info);
      v37 = (char *)&v32[(v38 & 5) != 4];
    }
    v39 = (unsigned __int16 *)&v37[2 * v28];
    BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(9u, 0);
    v40 = CFUniCharGetBitmapPtrForPlane(8u, 0);
    UnicodePropertyDataForPlane = CFUniCharGetUnicodePropertyDataForPlane(0, 0);
    if ((unint64_t)v39 < v35)
    {
      v153 = v40;
      v154 = UnicodePropertyDataForPlane;
      v136 = UnicodePropertyDataForPlane + 256;
      v42 = 64;
      Typed = (unsigned int *)__src;
      v139 = v2;
      while (1)
      {
        v44 = *v39;
        v45 = v39 + 1;
        v46 = (v44 & 0xFC00) != 0xD800 || (unint64_t)v45 >= v35;
        if (v46 || (v52 = *v45, (v52 & 0xFC00) != 0xDC00))
        {
          v47 = 1;
          v48 = *v39;
          v152 = 1;
          ++v39;
          v49 = BitmapPtrForPlane;
          if (!BitmapPtrForPlane)
            goto LABEL_52;
        }
        else
        {
          v48 = (v44 << 10) - 56613888 + v52;
          v39 += 2;
          v44 = (unsigned __int16)(((_WORD)v44 << 10) + 9216 + v52);
          v49 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v48));
          v47 = 0;
          v152 = 2;
          if (!v49)
            goto LABEL_52;
        }
        if (((*(unsigned __int8 *)(v49 + ((unint64_t)v44 >> 3)) >> (v44 & 7)) & 1) == 0)
          goto LABEL_52;
        v50 = v154;
        if ((v47 & 1) == 0)
          v50 = CFUniCharGetUnicodePropertyDataForPlane(0, HIWORD(v48));
        if (v50
          && *(_BYTE *)(v50 + ((unint64_t)v44 >> 8))
          && *(_BYTE *)(v50
                      + (*(unsigned __int8 *)(v50 + ((unint64_t)v44 >> 8)) << 8)
                      - 256
                      + v44
                      + 256)
          || (theForm & 2) != 0 && v48 - 55205 > 0xFFFFD45A)
        {
LABEL_52:
          v51 = 0;
          goto LABEL_53;
        }
        v51 = CFUniCharDecomposeCharacter(v48, Typed, 64);
LABEL_53:
        v151 = v35;
        if (!(((unint64_t)theForm >> 1) & 1 | v137) || (unint64_t)v39 >= v35 && v51)
          goto LABEL_124;
        if (v51 < 1)
        {
          v53 = (unsigned __int16)v48;
          if (v48 < 0x10000)
          {
            v55 = 1;
LABEL_64:
            v56 = v154;
            if (v154)
              goto LABEL_67;
            goto LABEL_120;
          }
        }
        else
        {
          v53 = *v39;
          if ((v53 & 0xFC00) != 0xD800
            || (unint64_t)(v39 + 1) >= v35
            || (v54 = v39[1], (v54 & 0xFC00) != 0xDC00))
          {
            v55 = 1;
            v48 = *v39;
            goto LABEL_64;
          }
          v48 = (v53 << 10) - 56613888 + v54;
          v53 = (unsigned __int16)(((_WORD)v53 << 10) + 9216 + v54);
        }
        v56 = CFUniCharGetUnicodePropertyDataForPlane(0, HIWORD(v48));
        v55 = 0;
        if (v56)
        {
LABEL_67:
          if (*(_BYTE *)(v56 + ((unint64_t)v53 >> 8))
            && *(_BYTE *)(v56
                        + (*(unsigned __int8 *)(v56 + ((unint64_t)v53 >> 8)) << 8)
                        - 256
                        + v53
                        + 256))
          {
            if (v51)
            {
              v148 = v39;
              v57 = 1;
              if (!v55)
                v57 = 2;
              v152 += v57;
            }
            else
            {
              v58 = 0x7FFFFFFFFFFFFFFELL;
              if (v55)
                v58 = 0x7FFFFFFFFFFFFFFFLL;
              v59 = &v39[v58];
              v148 = v59;
              if (v28 < 1)
              {
                v51 = 0;
              }
              else
              {
                v60 = *(v59 - 1);
                if ((v60 & 0xFC00) == 0xDC00 && v28 != 1 && (v61 = *(v59 - 2), (v61 & 0xFC00) == 0xD800))
                {
                  *Typed = v60 - 56613888 + (v61 << 10);
                  v28 -= 2;
                  v152 += 2;
                  v51 = 1;
                }
                else
                {
                  *Typed = v60;
                  ++v152;
                  v51 = 1;
                  --v28;
                }
              }
            }
            if (v55)
              v62 = 1;
            else
              v62 = 2;
            v63 = BitmapPtrForPlane;
            if ((v55 & 1) == 0)
              v63 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v48));
            if (v63 && ((*(unsigned __int8 *)(v63 + ((unint64_t)v53 >> 3)) >> (v53 & 7)) & 1) != 0)
            {
              v64 = CFUniCharDecomposeCharacter(v48, &Typed[v51], 64 - v51);
            }
            else
            {
              Typed[v51] = v48;
              v64 = 1;
            }
            v39 = &v148[v62];
            for (v51 += v64; ; v51 += v73)
            {
              if ((unint64_t)v39 >= v35)
                goto LABEL_120;
              v65 = *v39;
              v149 = v39;
              v66 = v39 + 1;
              v67 = (v65 & 0xFC00) != 0xD800 || (unint64_t)v66 >= v35;
              if (v67 || (v71 = *v66, (v71 & 0xFC00) != 0xDC00))
              {
                v68 = 1;
                v48 = v65;
                v69 = v154;
                if (!v154)
                  goto LABEL_119;
              }
              else
              {
                v48 = (v65 << 10) - 56613888 + v71;
                v65 = (unsigned __int16)(((_WORD)v65 << 10) + 9216 + v71);
                v69 = CFUniCharGetUnicodePropertyDataForPlane(0, HIWORD(v48));
                v68 = 0;
                if (!v69)
                  goto LABEL_119;
              }
              if (!*(_BYTE *)(v69 + ((unint64_t)v65 >> 8))
                || !*(_BYTE *)(v69
                             + (*(unsigned __int8 *)(v69 + ((unint64_t)v65 >> 8)) << 8)
                             - 256
                             + v65
                             + 256))
              {
                break;
              }
              if (v68)
                v70 = 1;
              else
                v70 = 2;
              if (v51 == v42)
              {
                v42 = v51 + 64;
                if (Typed == (unsigned int *)__src)
                {
                  Typed = (unsigned int *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 4 * (v51 + 64), 0x100004052888210, 0);
                  memmove(Typed, __src, 0x100uLL);
                }
                else
                {
                  Typed = (unsigned int *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, Typed, 4 * (v51 + 64), 0x100004052888210, 0, 0);
                }
              }
              v72 = BitmapPtrForPlane;
              if ((v68 & 1) == 0)
                v72 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v48));
              if (v72 && ((*(unsigned __int8 *)(v72 + ((unint64_t)v65 >> 3)) >> (v65 & 7)) & 1) != 0)
              {
                v73 = CFUniCharDecomposeCharacter(v48, &Typed[v51], 64 - v51);
              }
              else
              {
                Typed[v51] = v48;
                v73 = 1;
              }
              v39 = &v149[v70];
              v35 = v151;
              v152 += v70;
            }
            v35 = v151;
LABEL_119:
            v39 = v149;
          }
        }
LABEL_120:
        v74 = v137;
        if (v51 <= 1)
          v74 = 0;
        if (v74)
          CFUniCharPrioritySort(Typed, v51);
LABEL_124:
        if ((theForm & 1) != 0)
        {
          if (v51)
          {
            if (v51 >= 1)
              goto LABEL_130;
          }
          else if (CFUniCharIsMemberOf(v48, 0x64u))
          {
            *Typed = v48;
            v51 = 1;
LABEL_130:
            v75 = v39;
            do
            {
              v76 = CFUniCharCompatibilityDecompose((int *)Typed, v51, v42);
              if (!v76)
              {
                v42 += 64;
                if (Typed == (unsigned int *)__src)
                {
                  Typed = (unsigned int *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 4 * v42, 0x100004052888210, 0);
                  memmove(Typed, __src, 0x100uLL);
                }
                else
                {
                  Typed = (unsigned int *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, Typed, 4 * v42, 0x100004052888210, 0, 0);
                }
              }
            }
            while (v76 < v51);
            v51 = v76;
            v39 = v75;
            goto LABEL_138;
          }
          v51 = 0;
        }
LABEL_138:
        if ((theForm & 2) == 0)
          goto LABEL_228;
        v145 = v28;
        if (v51 >= 2)
        {
          v138 = 0;
          v77 = 0;
          v78 = *Typed;
          v143 = Typed - 1;
          v79 = Typed;
          v80 = 1;
          v150 = v39;
          do
          {
            v144 = v77;
            v141 = v79;
            v147 = v80;
            v81 = v80;
            v142 = v78;
            v82 = v78;
            v83 = v51;
LABEL_142:
            v84 = &v143[v81];
            while (1)
            {
              v85 = v84[1];
              v86 = v154;
              if (v85 >= 0x10000)
                v86 = CFUniCharGetUnicodePropertyDataForPlane(0, WORD1(v85));
              v77 = v86 && *(_BYTE *)(v86 + BYTE1(v85))
                  ? *(unsigned __int8 *)(v86
                                       + (*(unsigned __int8 *)(v86 + BYTE1(v85)) << 8)
                                       - 256
                                       + v85
                                       + 256)
                  : 0;
              if ((theForm & 1) == 0)
                break;
              if ((v82 - 4352) <= 0xFE
                && (((_DWORD)v82 << 24) | 0xFFFFFFu) < 0x14FFFFFF
                && (((_DWORD)v85 << 16) - 293011456) >= 0xFFE90001)
              {
                v84[1] = 65533;
                v88 = v81 + 1;
                if (v81 + 1 < v83 && (v89 = v84[2] - 4519, (v89 << 16) <= 0x1C0000))
                {
                  v88 = v81 + 2;
                  v84[2] = 65533;
                }
                else
                {
                  LOWORD(v89) = 0;
                }
                *v79 = 28 * (((((_DWORD)v85 << 16) - 291569664) >> 16) + 21 * v82)
                     + (__int16)v89
                     + 44032;
                if (v83 < 2)
                {
                  v93 = v88;
                }
                else
                {
                  v90 = v83 + 1;
                  v91 = &v143[v83];
                  v92 = -v83;
                  v93 = v88;
                  do
                  {
                    if (*v91 == 65533)
                    {
                      --v93;
                      memmove(v91, v91 + 1, 4 * (v83 + v92));
                      --v83;
                    }
                    --v90;
                    --v91;
                    ++v92;
                  }
                  while (v90 > 2);
                }
                v94 = v93;
                v79 = &Typed[v93];
                v82 = *v79;
                v81 = v94 + 1;
                if (v94 + 1 >= v83)
                {
                  v51 = v83;
                  LODWORD(v78) = *v79;
                  goto LABEL_191;
                }
                goto LABEL_142;
              }
              v87 = v153;
              if (v85 >= 0x10000)
                v87 = CFUniCharGetBitmapPtrForPlane(8u, WORD1(v85));
              if (v87 && ((*(unsigned __int8 *)(v87 + ((unsigned __int16)v85 >> 3)) >> (v85 & 7)) & 1) != 0)
              {
                v51 = v83;
                v147 = v81;
                v78 = v82;
                goto LABEL_174;
              }
              *v79 = v82;
              v79 = &Typed[v81++];
              ++v84;
              v82 = v85;
              if (v81 >= v83)
              {
                v51 = v83;
                LODWORD(v78) = v85;
                v79 = v84;
LABEL_191:
                v2 = v139;
                v28 = v145;
                v35 = v151;
                v39 = v150;
                goto LABEL_192;
              }
            }
            v78 = v142;
            v79 = v141;
LABEL_174:
            v2 = v139;
            v28 = v145;
            v35 = v151;
            if (v144 && v77 <= v144)
            {
              v77 = v144;
              v39 = v150;
            }
            else
            {
              v95 = v85;
              v96 = v78;
              v97 = CFUniCharPrecomposeCharacter(v78, v95);
              v78 = v96;
              v39 = v150;
              if ((_DWORD)v97 != 65533)
              {
                Typed[v147] = 65533;
                v138 = 1;
                v78 = v97;
                v77 = v144;
              }
            }
            v80 = v147 + 1;
          }
          while (v147 + 1 < v51);
LABEL_192:
          *v79 = v78;
          if ((v138 & 1) != 0 && v51 > 1)
          {
            v101 = v51 + 1;
            v102 = &Typed[v51 - 1];
            v103 = -v51;
            do
            {
              if (*v102 == 65533)
              {
                memmove(v102, v102 + 1, 4 * (v51 + v103));
                --v51;
                v35 = v151;
              }
              --v101;
              --v102;
              ++v103;
            }
            while (v101 > 2);
            v39 = v150;
          }
          goto LABEL_228;
        }
        if (v48 - 4352 < 0xFF)
        {
          if ((unint64_t)v39 >= v35)
            goto LABEL_228;
          if (((v48 << 24) | 0xFFFFFF) >= 0x14FFFFFF)
            goto LABEL_228;
          v98 = *v39 - 4449;
          if (v98 > 0x15)
            goto LABEL_228;
          v99 = v152 + 1;
          if ((unint64_t)(v39 + 1) >= v35)
          {
            LOWORD(v100) = 0;
            ++v152;
          }
          else
          {
            v100 = v39[1] - 4519;
            if ((v100 << 16) <= 0x1C0000)
              v99 = v152 + 2;
            v152 = v99;
            if ((v100 << 16) > 0x1C0000)
              LOWORD(v100) = 0;
          }
          *Typed = 28 * ((__int16)v98 + 21 * (char)v48) + (__int16)v100 + 44032;
LABEL_225:
          v114 = Typed + 1;
LABEL_230:
          v115 = 0;
          v116 = Typed;
          do
          {
            v117 = v116 + 1;
            if (*((_WORD *)v116 + 1))
              v118 = 2;
            else
              v118 = 1;
            v115 += v118;
            v116 = v117;
          }
          while (v117 < v114);
          v119 = 0;
          goto LABEL_237;
        }
        if ((unint64_t)v39 >= v35)
          goto LABEL_228;
        while (1)
        {
          v104 = v39;
          v105 = *v39;
          v106 = v104;
          v107 = v104 + 1;
          if ((v105 & 0xFC00) == 0xD800 && (unint64_t)v107 < v35)
          {
            v111 = *v107;
            if ((v111 & 0xFC00) == 0xDC00)
              break;
          }
          if (!v153
            || ((*(unsigned __int8 *)(v153 + (v105 >> 3)) >> (v105 & 7)) & 1) == 0
            || v154
            && *(_BYTE *)(v154 + (v105 >> 8))
            && *(_BYTE *)(v136 + (*(unsigned __int8 *)(v154 + (v105 >> 8)) << 8) - 256 + v105))
          {
            goto LABEL_227;
          }
LABEL_210:
          v109 = CFUniCharPrecomposeCharacter(v48, v105);
          if (v109 == 65533)
            goto LABEL_227;
          v48 = v109;
          v110 = 1;
          if (v105 >= 0x10000)
            v110 = 2;
          v39 = &v106[v110];
          v152 += v110;
          *Typed = v109;
          v51 = 1;
          if ((unint64_t)v39 >= v35)
            goto LABEL_225;
        }
        LODWORD(v105) = ((_DWORD)v105 << 10) - 56613888 + v111;
        v112 = CFUniCharGetBitmapPtrForPlane(8u, WORD1(v105));
        if (v112 && ((*(unsigned __int8 *)(v112 + ((unsigned __int16)v105 >> 3)) >> (v111 & 7)) & 1) != 0)
        {
          v113 = CFUniCharGetUnicodePropertyDataForPlane(0, WORD1(v105));
          if (v113 && *(_BYTE *)(v113 + BYTE1(v105)))
          {
            v28 = v145;
            if (*(_BYTE *)(v113 + (*(unsigned __int8 *)(v113 + BYTE1(v105)) << 8) - 256 + v111 + 256))
              goto LABEL_227;
          }
          else
          {
            v28 = v145;
          }
          goto LABEL_210;
        }
        v28 = v145;
LABEL_227:
        v39 = v106;
LABEL_228:
        if (v51 >= 1)
        {
          v114 = &Typed[v51];
          if ((_DWORD)v51)
            goto LABEL_230;
          v115 = 0;
          v119 = 1;
LABEL_237:
          v120 = v115;
          if (v152 != v115)
          {
            v156[0] = v28;
            v156[1] = v152;
            __CFStringChangeSizeMultiple((uint64_t)v2, (uint64_t)v156, 1, v115, 1);
            v152 = v120;
          }
          v121 = atomic_load((unint64_t *)&v2->info);
          if ((v121 & 0x60) != 0)
          {
            v122 = *v140;
          }
          else
          {
            v123 = atomic_load((unint64_t *)&v2->info);
            v122 = (char *)&v140[(v123 & 5) != 4];
          }
          v124 = atomic_load((unint64_t *)&v2->info);
          v125 = atomic_load((unint64_t *)&v2->info);
          v126 = v125 & 0x60;
          if ((v124 & 5) == 4)
          {
            if (v126)
            {
              v127 = *v140;
            }
            else
            {
              v129 = atomic_load((unint64_t *)&v2->info);
              v127 = (char *)&v140[(v129 & 5) != 4];
            }
            v128 = *v127;
          }
          else if (v126)
          {
            v128 = v2->length;
          }
          else
          {
            v128 = (uint64_t)*v140;
          }
          if ((v119 & 1) == 0)
          {
            v130 = Typed;
            v131 = &v122[2 * v28];
            do
            {
              v133 = *v130++;
              v132 = v133;
              if (v133 < 0x10000)
              {
                v135 = v131 + 2;
                LOWORD(v134) = v132;
              }
              else
              {
                v134 = ((v132 + 67043328) >> 10) - 10240;
                v135 = v131 + 4;
                *((_WORD *)v131 + 1) = v132 & 0x3FF | 0xDC00;
              }
              *(_WORD *)v131 = v134;
              v131 = v135;
            }
            while (v130 < v114);
          }
          v35 = (unint64_t)&v122[2 * v128];
          v39 = (unsigned __int16 *)&v122[2 * v28 + 2 * v120];
        }
        v28 += v152;
        if ((unint64_t)v39 >= v35)
        {
          if (Typed != (unsigned int *)__src)
            CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
          return;
        }
      }
    }
  }
}

uint64_t CFUniCharCompatibilityDecompose(int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int *v5;
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v11;
  int *v12;
  int v13;
  _DWORD v15[32];
  uint64_t v16;

  v3 = a2;
  v16 = *MEMORY[0x1E0C80C00];
  if (a2 >= 1)
  {
    v5 = a1;
    v6 = (unint64_t)&a1[a2];
    do
    {
      v7 = *v5;
      if (CFUniCharIsMemberOf(*v5, 0x64u))
      {
        v8 = __CFUniCharRecursivelyCompatibilityDecomposeCharacter(v7, v15);
        v3 = v3 + v8 - 1;
        if (v3 > a3)
          return 0;
        if (v8 > 1)
        {
          if ((uint64_t)(v6 - (_QWORD)v5) < 5)
            goto LABEL_10;
          v9 = (v6 - (unint64_t)v5) >> 2;
          do
            v5[v8 - 2 + v9] = v5[v9 - 1];
          while (v9-- > 2);
        }
        if (v8 >= 1)
        {
LABEL_10:
          v11 = v8 + 1;
          v12 = v15;
          do
          {
            v13 = *v12++;
            *v5++ = v13;
            --v11;
          }
          while (v11 > 1);
        }
      }
      else
      {
        ++v5;
      }
    }
    while ((unint64_t)v5 < v6);
  }
  return v3;
}

uint64_t __CFUniCharRecursivelyCompatibilityDecomposeCharacter(unsigned int a1, _DWORD *a2)
{
  char *v3;
  char *v4;
  char *v5;
  uint64_t v6;
  unint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;
  unsigned int v15;
  unsigned __int8 *BitmapPtrForPlane;
  uint64_t v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a1 - 130042 >= 0xFFFE04A6)
  {
    v3 = (char *)&__CFUniCharCompatibilityDecompositionTable;
    v4 = (char *)&__CFUniCharCompatibilityDecompositionTable + 30360;
    while (1)
    {
      v5 = &v3[8 * ((v4 - v3) >> 4)];
      if (*(_DWORD *)v5 <= a1)
        break;
      v4 = v5 - 8;
LABEL_7:
      if (v3 > v4)
        return 0;
    }
    if (*(_DWORD *)v5 < a1)
    {
      v3 = v5 + 8;
      goto LABEL_7;
    }
    v8 = *((unsigned int *)v5 + 1);
    v6 = (v8 >> 24) & 0x1F;
    v9 = v8 & 0xFFFFFF;
    v18 = v9;
    if ((_DWORD)v6)
    {
      v10 = (unsigned int *)((char *)&__CFUniCharCompatibilityMultipleDecompositionTable + 4 * v9);
      if ((_DWORD)v6 == 1)
        v11 = (unsigned int *)&v18;
      else
        v11 = v10;
      v12 = v6 + 1;
      for (i = 33 - v6; ; ++i)
      {
        v15 = *v11++;
        v14 = v15;
        BitmapPtrForPlane = (unsigned __int8 *)&__CFUniCharCanonicalDecomposableCharacterSetBitmapPlane0_0;
        if ((v15 < 0x10000
           || (BitmapPtrForPlane = (unsigned __int8 *)CFUniCharGetBitmapPtrForPlane(9u, BYTE2(v14))) != 0)
          && ((BitmapPtrForPlane[(unsigned __int16)v14 >> 3] >> (v14 & 7)) & 1) != 0)
        {
          v17 = __CFUniCharRecursivelyDecomposeCharacter(v14, a2, i);
        }
        else
        {
          if (!CFUniCharIsMemberOf(v14, 0x64u))
          {
            *a2++ = v14;
            goto LABEL_23;
          }
          v17 = __CFUniCharRecursivelyCompatibilityDecomposeCharacter(v14, a2);
        }
        a2 += v17;
        v6 = v6 + v17 - 1;
LABEL_23:
        if ((unint64_t)--v12 <= 1)
          return v6;
      }
    }
  }
  return 0;
}

CFMutableBitVectorRef CFBitVectorCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFBitVectorRef bv)
{
  return (CFMutableBitVectorRef)__CFBitVectorInit((__objc2_class **)allocator, 1, *((const void **)bv + 4), *((_QWORD *)bv + 2));
}

CFURLRef CFBundleCopyBuiltInPlugInsURL(CFBundleRef bundle)
{
  unint64_t v2;
  const __CFAllocator *v3;
  const __CFAllocator *v4;
  unsigned int v5;
  const __CFURL *v6;
  const __CFString *v7;
  const __CFAllocator *v8;
  const __CFURL *v9;
  const __CFString *v10;
  const __CFURL *v11;
  const __CFURL *v12;
  unsigned int v13;
  const __CFURL *v14;
  const __CFString *v15;
  const __CFAllocator *v16;
  const __CFURL *v17;
  const __CFString *v18;
  const __CFURL *v19;
  const __CFURL *v20;
  unsigned int v21;
  const __CFURL *v22;
  const __CFURL *v23;

  v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  v3 = CFGetAllocator(bundle);
  v4 = v3;
  v5 = *((unsigned __int8 *)bundle + 53);
  if (v5 <= 0xB)
  {
    if (v5 == 1)
    {
      v6 = (const __CFURL *)*((_QWORD *)bundle + 2);
      v7 = CFSTR("Support%20Files/PlugIns/");
      goto LABEL_13;
    }
    if (v5 == 2)
    {
      v6 = (const __CFURL *)*((_QWORD *)bundle + 2);
      v7 = CFSTR("Contents/PlugIns/");
LABEL_13:
      v11 = CFURLCreateWithString(v3, v7, v6);
      goto LABEL_14;
    }
LABEL_12:
    v6 = (const __CFURL *)*((_QWORD *)bundle + 2);
    v7 = CFSTR("PlugIns/");
    goto LABEL_13;
  }
  if (v5 == 12)
  {
    v8 = CFGetAllocator(bundle);
    v9 = (const __CFURL *)*((_QWORD *)bundle + 2);
    v10 = CFSTR("WrappedBundle/Contents/PlugIns/");
  }
  else
  {
    if (v5 != 13)
      goto LABEL_12;
    v8 = CFGetAllocator(bundle);
    v9 = (const __CFURL *)*((_QWORD *)bundle + 2);
    v10 = CFSTR("WrappedBundle/PlugIns/");
  }
  v11 = _CFURLCreateResolvedDirectoryWithString(v8, v10, v9);
LABEL_14:
  v12 = v11;
  if (v11 && (_CFURLExists(v11) & 1) != 0)
    return v12;
  v13 = *((unsigned __int8 *)bundle + 53);
  if (v13 > 0xB)
  {
    if (v13 == 12)
    {
      v16 = CFGetAllocator(bundle);
      v17 = (const __CFURL *)*((_QWORD *)bundle + 2);
      v18 = CFSTR("WrappedBundle/Contents/Plug-ins/");
    }
    else
    {
      if (v13 != 13)
        goto LABEL_26;
      v16 = CFGetAllocator(bundle);
      v17 = (const __CFURL *)*((_QWORD *)bundle + 2);
      v18 = CFSTR("WrappedBundle/Plug-ins/");
    }
    v19 = _CFURLCreateResolvedDirectoryWithString(v16, v18, v17);
    goto LABEL_28;
  }
  if (v13 == 1)
  {
    v14 = (const __CFURL *)*((_QWORD *)bundle + 2);
    v15 = CFSTR("Support%20Files/Plug-ins/");
    goto LABEL_27;
  }
  if (v13 != 2)
  {
LABEL_26:
    v14 = (const __CFURL *)*((_QWORD *)bundle + 2);
    v15 = CFSTR("Plug-ins/");
    goto LABEL_27;
  }
  v14 = (const __CFURL *)*((_QWORD *)bundle + 2);
  v15 = CFSTR("Contents/Plug-ins/");
LABEL_27:
  v19 = CFURLCreateWithString(v4, v15, v14);
LABEL_28:
  v20 = v19;
  if (v19)
  {
    v21 = _CFURLExists(v19);
    if (v12 || (v21 & 1) == 0)
    {
      if (v21)
        v22 = v20;
      else
        v22 = v12;
      if (v21)
        v23 = v12;
      else
        v23 = v20;
      CFRelease(v23);
      return v22;
    }
    else
    {
      return v20;
    }
  }
  return v12;
}

CFStreamStatus CFWriteStreamGetStatus(CFWriteStreamRef stream)
{
  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
    return -[__CFWriteStream streamStatus](stream, "streamStatus");
  else
    return _CFStreamGetStatus((uint64_t)stream);
}

Boolean CFBundlePreflightExecutable(CFBundleRef bundle, CFErrorRef *error)
{
  CFErrorRef *v4;
  const __CFURL *v5;
  int32x4_t v6;
  int v7;
  int v8;
  int v9;
  const __CFAllocator *v10;
  __CFBundle *v11;
  CFIndex v12;
  CFErrorRef ErrorDebug;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v15[0] = 0;
  if (error)
    v4 = (CFErrorRef *)v15;
  else
    v4 = 0;
  v5 = CFBundleCopyExecutableURL(bundle);
  os_unfair_lock_lock((os_unfair_lock_t)bundle + 24);
  if (!v5)
    *((_DWORD *)bundle + 12) = 7;
  _CFBundleDlfcnCheckLoaded((uint64_t)bundle);
  if (!*((_DWORD *)bundle + 12))
  {
    v9 = _CFBundleGrokBinaryType(v5, v6);
    *((_DWORD *)bundle + 12) = v9;
    if (v9 != 1 && v9 != 6)
      *((_BYTE *)bundle + 64) = 1;
  }
  if (v5)
    CFRelease(v5);
  v7 = *((unsigned __int8 *)bundle + 52);
  os_unfair_lock_unlock((os_unfair_lock_t)bundle + 24);
  if (v7)
  {
    LOBYTE(v8) = 1;
  }
  else
  {
    switch(*((_DWORD *)bundle + 12))
    {
      case 0:
      case 3:
      case 4:
      case 6:
      case 8:
        v8 = _CFBundleDlfcnPreflight((unsigned __int8 *)bundle, v4);
        if (error)
          goto LABEL_22;
        break;
      case 7:
        if (!error)
          goto LABEL_24;
        v10 = CFGetAllocator(bundle);
        v11 = bundle;
        v12 = 4;
        goto LABEL_21;
      default:
        if (error)
        {
          v10 = CFGetAllocator(bundle);
          v11 = bundle;
          v12 = 3584;
LABEL_21:
          ErrorDebug = _CFBundleCreateErrorDebug(v10, v11, v12, 0);
          v8 = 0;
          v15[0] = ErrorDebug;
LABEL_22:
          if (!v8)
            *error = (CFErrorRef)v15[0];
        }
        else
        {
LABEL_24:
          LOBYTE(v8) = 0;
        }
        break;
    }
  }
  return v8;
}

CFDictionaryRef CFBundleCopyInfoDictionaryForURL(CFURLRef url)
{
  int32x4_t v2;
  char v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v4 = 0;
  if (!_CFIsResourceAtURL(url, &v4))
    return 0;
  if (v4)
    return _CFBundleCopyInfoDictionaryInDirectory((const __CFAllocator *)&__kCFAllocatorSystemDefault, url, 0);
  return _CFBundleCopyInfoDictionaryInExecutable(url, v2);
}

BOOL _CFIsResourceAtURL(CFURLRef url, char *a2)
{
  int v3;
  _BOOL8 result;
  int v5;
  __int16 v6;
  BOOL v7;
  char v8;
  int v10;
  unsigned __int8 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v10 = 0;
  v3 = _CFGetFileProperties((const __CFAllocator *)&__kCFAllocatorSystemDefault, url, (char *)&v11, &v10, 0, 0, 0, 0);
  result = 0;
  if (!v3)
  {
    v5 = v11;
    v6 = v10;
    if (a2)
    {
      if (v11)
        v7 = (v10 & 0xF000) == 0x4000;
      else
        v7 = 0;
      v8 = v7;
      *a2 = v8;
    }
    return (v6 & 0x124) != 0 && v5 != 0;
  }
  return result;
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryInExecutable(const __CFURL *a1, int32x4_t a2)
{
  CFMutableDictionaryRef v3[2];

  v3[1] = *(CFMutableDictionaryRef *)MEMORY[0x1E0C80C00];
  v3[0] = 0;
  _CFBundleGrokFileType(a1, 0, 0, 0, 0, v3, 0, 0, a2, 0);
  return v3[0];
}

uint64_t _CFBundleGrokBinaryType(const __CFURL *a1, int32x4_t a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a1)
    v2 = 6;
  else
    v2 = 7;
  v8 = 0;
  if (_CFBundleGrokFileType(a1, 0, 0, &v8, 0, 0, 0, 0, a2, 0))
  {
    if (v8 == 4096)
      v3 = 1;
    else
      v3 = v2;
    if (v8 == 8)
      v4 = 3;
    else
      v4 = v3;
    if (v8 == 6)
      v5 = 4;
    else
      v5 = v2;
    if (v8 == 2)
      v6 = 2;
    else
      v6 = v5;
    if (v8 <= 7)
      return v6;
    else
      return v4;
  }
  return v2;
}

BOOL _CFBundleGrokFileType(const __CFURL *a1, const __CFData *a2, CFStringRef *a3, int *a4, const __CFArray **a5, CFMutableDictionaryRef *a6, char *a7, unsigned int *a8, int32x4_t a9, unsigned int *a10)
{
  int v17;
  int v18;
  unsigned __int16 *v19;
  ssize_t v20;
  CFIndex Length;
  const __CFData *v22;
  off_t v23;
  const UInt8 *BytePtr;
  unint64_t v25;
  int v26;
  const char *v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  int v35;
  CFStringRef v36;
  int v37;
  BOOL v38;
  uint64_t v39;
  uint64_t v41;
  BOOL v42;
  int v43;
  char v44;
  char *v45;
  __darwin_ct_rune_t v46;
  ssize_t v47;
  int v49;
  const char *v51;
  uint64_t v52;
  _BOOL4 v53;
  ssize_t i;
  char *v55;
  const char *v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  BOOL *v63;
  int v64;
  UInt8 *v65;
  uint64_t v66;
  int v67;
  _BOOL4 v68;
  char v69;
  int v70;
  int v71;
  int v72;
  unsigned int v73;
  int v74;
  int v75;
  unint64_t v76;
  int v77;
  uint64_t v78;
  int v79;
  unsigned int v80;
  CFMutableDictionaryRef *v81;
  int v82;
  int v83;
  unsigned int v84;
  uint64_t v85;
  int v86;
  ssize_t v87;
  uint64_t v89;
  const char *v90;
  char v91;
  int v92;
  int v93;
  const char *v94;
  unsigned int v95;
  int v96;
  CFStringRef *v97;
  uint64_t v98;
  int v99;
  uint64_t v100;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  char *v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  unint64_t v109;
  BOOL v110;
  signed int v111;
  int v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  int v116;
  CFNumberRef v117;
  int v118;
  char *v119;
  int v120;
  unsigned int v121;
  unsigned int v122;
  unsigned int v123;
  unsigned int *v127;
  unsigned int *v128;
  unsigned int *v129;
  BOOL *v130;
  BOOL *v131;
  BOOL *v132;
  BOOL *v133;
  CFNumberRef v134;
  int v135;
  int *v136;
  CFStringRef *v137;
  CFStringRef *v138;
  CFStringRef *v139;
  unsigned int v140;
  _DWORD *v141;
  off_t st_size;
  int v143;
  int v144;
  char *__s1;
  uint64_t v146;
  char v147;
  stat valuePtr;
  UInt8 buffer[1032];
  _DWORD v150[128];
  uint64_t v151;

  v151 = *MEMORY[0x1E0C80C00];
  v147 = 0;
  if (a5)
    *a5 = 0;
  if (a6)
    *a6 = 0;
  if (a7)
    *a7 = 0;
  if (a8)
    *a8 = 0;
  if (a10)
    *a10 = 0;
  if (!a1)
    goto LABEL_18;
  v17 = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026);
  a9.i8[8] = 0;
  a9.i8[9] = 0;
  a9.i8[10] = 0;
  a9.i8[11] = 0;
  a9.i8[12] = 0;
  a9.i8[13] = 0;
  a9.i8[14] = 0;
  a9.i8[15] = 0;
  memset(&valuePtr, 0, sizeof(valuePtr));
  if (!v17)
    goto LABEL_18;
  if (!stat((const char *)buffer, &valuePtr) && (valuePtr.st_mode & 0xF000) == 0x8000)
  {
    v18 = open((const char *)buffer, 0, 511);
    v144 = v18;
    if (v18 < 0)
    {
      st_size = 0;
      v143 = 0;
      v20 = 0;
      v19 = 0;
      if (!a2)
        goto LABEL_22;
    }
    else
    {
      v19 = (unsigned __int16 *)v150;
      v20 = read(v18, v150, 0x200uLL);
      v143 = 1;
      st_size = valuePtr.st_size;
      if (!a2)
        goto LABEL_22;
    }
  }
  else
  {
LABEL_18:
    st_size = 0;
    v20 = 0;
    v19 = 0;
    v143 = 0;
    v144 = -1;
    if (!a2)
      goto LABEL_22;
  }
  if (!v143)
  {
    Length = CFDataGetLength(a2);
    v22 = a2;
    v23 = Length;
    BytePtr = CFDataGetBytePtr(v22);
    v19 = (unsigned __int16 *)BytePtr;
    if (!v23)
    {
      v30 = 0;
      v27 = "txt";
      if (BytePtr)
      {
        v146 = 0;
        st_size = 0;
        v31 = v144;
        goto LABEL_517;
      }
LABEL_42:
      v31 = v144;
      goto LABEL_43;
    }
    st_size = v23;
    v20 = v23;
  }
LABEL_22:
  if (!v19)
  {
    v27 = 0;
    v30 = 0;
    goto LABEL_42;
  }
  v141 = (_DWORD *)((char *)v19 + 257);
  __s1 = (char *)v19;
  v146 = v20;
  if (v20 < 4)
  {
    v27 = 0;
    v30 = 0;
    goto LABEL_47;
  }
  v25 = 0;
  v26 = *(_DWORD *)v19;
  v27 = (char *)&__CFBundleMagicNumbersArray[62] + 3;
  v28 = bswap32(*(_DWORD *)v19);
  do
  {
    v29 = __CFBundleMagicNumbersArray[v25];
    v27 += 5;
    if (v29 == v28)
      break;
    v110 = v25++ >= 0x3F;
  }
  while (!v110);
  if (v29 != v28)
  {
    v27 = 0;
    v30 = 0;
    v31 = v144;
LABEL_30:
    v19 = (unsigned __int16 *)__s1;
    goto LABEL_31;
  }
  if (v26 == -1095041334 && v20 >= 8 && *((_WORD *)__s1 + 2))
  {
    v30 = 0;
    v27 = "class";
    v31 = v144;
LABEL_152:
    v19 = (unsigned __int16 *)__s1;
    goto LABEL_290;
  }
  if (v20 < 32)
    goto LABEL_226;
  if (a3)
    v63 = (BOOL *)&v147;
  else
    v63 = 0;
  *(_QWORD *)buffer = 0;
  if (a3)
    v147 = 0;
  if (a5)
    *a5 = 0;
  if (a6)
    *a6 = 0;
  if (a7)
    *a7 = 0;
  if (a8)
    *a8 = 0;
  if (a10)
    *a10 = 0;
  valuePtr.st_dev = 0;
  if (v26 > -17958195)
  {
    if (v26 > 561606473)
    {
      if (v26 == 561606474 || v26 == 1248819489)
      {
        v30 = 4096;
        v27 = "pef";
        v31 = v144;
LABEL_516:
        v19 = (unsigned __int16 *)__s1;
        goto LABEL_517;
      }
      goto LABEL_226;
    }
    if (v26 != -17958194)
    {
      if (v26 != -17958193)
        goto LABEL_226;
      v130 = v63;
      v135 = -17958193;
      v140 = *((_DWORD *)__s1 + 3);
      valuePtr.st_dev = *((_DWORD *)__s1 + 1);
      if (a5)
      {
        v134 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
        *(_QWORD *)buffer = v134;
      }
      else
      {
        v134 = 0;
      }
      if (a3 && v140 == 2)
        *v130 = _CFBundleGrokX11FromFile(v144, (uint64_t)__s1, v146, 0, 0, 1);
      if (a6)
        *a6 = _CFBundleCreateInfoDictFromFile(v144, (UInt8 *)__s1, v146, 0, 0, 1);
      if (a7 || a8 || a10)
      {
        v128 = a10;
        v112 = v144;
        v113 = (uint64_t)__s1;
        v114 = v146;
        v115 = 0;
LABEL_476:
        v116 = 1;
LABEL_498:
        _CFBundleGrokObjcImageInfoFromFile(v112, v113, v114, 0, v115, v116, a7, a8, v128);
      }
LABEL_499:
      v30 = v140;
      v117 = v134;
      if (a5 && v134)
      {
        *a5 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)buffer, 1, &kCFTypeArrayCallBacks);
        v117 = *(CFNumberRef *)buffer;
      }
      if (v117)
        CFRelease(v117);
      v26 = v135;
      goto LABEL_505;
    }
    v132 = v63;
    v135 = -17958194;
    v140 = *((_DWORD *)__s1 + 3);
    valuePtr.st_dev = *((_DWORD *)__s1 + 1);
    if (a5)
    {
      v134 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
      *(_QWORD *)buffer = v134;
    }
    else
    {
      v134 = 0;
    }
    if (a3 && v140 == 2)
      *v132 = _CFBundleGrokX11FromFile(v144, (uint64_t)__s1, v146, 0, 0, 0);
    if (a6)
      *a6 = _CFBundleCreateInfoDictFromFile(v144, (UInt8 *)__s1, v146, 0, 0, 0);
    if (!a7 && !a8 && !a10)
      goto LABEL_499;
    v128 = a10;
    v112 = v144;
    v113 = (uint64_t)__s1;
    v114 = v146;
    v115 = 0;
LABEL_497:
    v116 = 0;
    goto LABEL_498;
  }
  if (v26 > -822415875)
  {
    if (v26 != -822415874)
    {
      if (v26 != -805638658)
        goto LABEL_226;
      v131 = v63;
      v135 = -805638658;
      v138 = a3;
      v73 = *((_DWORD *)__s1 + 3);
      valuePtr.st_dev = bswap32(*((_DWORD *)__s1 + 1));
      if (a5)
      {
        v134 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
        *(_QWORD *)buffer = v134;
      }
      else
      {
        v134 = 0;
      }
      if (v138 && v73 == 0x2000000)
        *v131 = _CFBundleGrokX11FromFile(v144, (uint64_t)__s1, v146, 0, 1, 1);
      v140 = bswap32(v73);
      if (a6)
        *a6 = _CFBundleCreateInfoDictFromFile(v144, (UInt8 *)__s1, v146, 0, 1, 1);
      a3 = v138;
      if (a7 || a8 || a10)
      {
        v128 = a10;
        v112 = v144;
        v113 = (uint64_t)__s1;
        v114 = v146;
        v115 = 1;
        goto LABEL_476;
      }
      goto LABEL_499;
    }
    v133 = v63;
    v135 = -822415874;
    v139 = a3;
    v84 = *((_DWORD *)__s1 + 3);
    valuePtr.st_dev = bswap32(*((_DWORD *)__s1 + 1));
    if (a5)
    {
      v134 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
      *(_QWORD *)buffer = v134;
    }
    else
    {
      v134 = 0;
    }
    if (v139 && v84 == 0x2000000)
      *v133 = _CFBundleGrokX11FromFile(v144, (uint64_t)__s1, v146, 0, 1, 0);
    v140 = bswap32(v84);
    if (a6)
      *a6 = _CFBundleCreateInfoDictFromFile(v144, (UInt8 *)__s1, v146, 0, 1, 0);
    a3 = v139;
    if (!a7 && !a8 && !a10)
      goto LABEL_499;
    v128 = a10;
    v112 = v144;
    v113 = (uint64_t)__s1;
    v114 = v146;
    v115 = 1;
    goto LABEL_497;
  }
  if (v26 == -1095041334)
  {
    v127 = a8;
    v129 = a10;
    v64 = v144;
    v65 = (UInt8 *)__s1;
    v66 = v20;
    v67 = 1;
    goto LABEL_329;
  }
  if (v26 != -889275714)
  {
LABEL_226:
    v30 = 0;
    v31 = v144;
    goto LABEL_227;
  }
  v127 = a8;
  v129 = a10;
  v64 = v144;
  v65 = (UInt8 *)__s1;
  v66 = v20;
  v67 = 0;
LABEL_329:
  v81 = a6;
  v82 = v26;
  v83 = _CFBundleGrokMachTypeForFatFile(v64, v65, v66, v67, v63, a5, v81, a7, v127, v129);
  v26 = v82;
  v30 = v83;
LABEL_505:
  v31 = v144;
  v20 = v146;
  switch(v30)
  {
    case 1:
      v27 = "o";
      goto LABEL_516;
    case 2:
      if (v147)
        v27 = "x11app";
      else
        v27 = "tool";
      v30 = 2;
      goto LABEL_516;
    case 3:
    case 5:
    case 7:
      break;
    case 4:
      v27 = "core";
      goto LABEL_516;
    case 6:
      v27 = "dylib";
      goto LABEL_516;
    case 8:
      v27 = "bundle";
      goto LABEL_516;
    default:
      v31 = v144;
      if (v30 == 4096)
      {
        v27 = "pef";
        goto LABEL_516;
      }
      v20 = v146;
      break;
  }
LABEL_227:
  if (v28 <= 1112493394)
  {
    if (v28 > 626017349)
    {
      if (v28 > 808923190)
      {
        switch(v28)
        {
          case 808923191:
            if (v20 < 6)
              goto LABEL_444;
            v19 = (unsigned __int16 *)__s1;
            if (__s1[4] != 48)
              goto LABEL_442;
            break;
          case 1031365221:
            if (v20 >= 12)
            {
              v19 = (unsigned __int16 *)__s1;
              if (*((_DWORD *)__s1 + 1) == 544106855)
              {
                v74 = *((_DWORD *)__s1 + 2);
                if (v74 == 1701734764)
                  goto LABEL_290;
                v75 = 1953653104;
                goto LABEL_441;
              }
              goto LABEL_442;
            }
            goto LABEL_444;
          case 1094922544:
            v19 = (unsigned __int16 *)__s1;
            if (v20 < 6 || __s1[4] != 49)
              goto LABEL_442;
            break;
          default:
            goto LABEL_152;
        }
        if (*((unsigned __int8 *)v19 + 5) - 48 >= 0xA)
          goto LABEL_442;
        goto LABEL_290;
      }
      switch(v28)
      {
        case 626017350:
          if (v20 >= 6)
          {
            v19 = (unsigned __int16 *)__s1;
            if (__s1[4] != 45)
              goto LABEL_442;
            goto LABEL_290;
          }
          goto LABEL_444;
        case 675567430:
          if (v20 < 6)
            goto LABEL_444;
          v19 = (unsigned __int16 *)__s1;
          v74 = *((unsigned __int16 *)__s1 + 2);
          v75 = 22048;
          break;
        case 807842421:
          v19 = (unsigned __int16 *)__s1;
          if (v20 < 8)
            goto LABEL_442;
          v74 = *((_DWORD *)__s1 + 1);
          v75 = 298804878;
          break;
        default:
          goto LABEL_152;
      }
    }
    else
    {
      if (v28 < 0x10000)
      {
        if (v28 != -1991225785)
        {
          if (v28 != -791735840)
          {
            if (v28 != 12)
              goto LABEL_152;
            v19 = (unsigned __int16 *)__s1;
            if (v20 >= 6)
            {
              v74 = *((unsigned __int16 *)__s1 + 2);
              v75 = 20586;
              goto LABEL_441;
            }
LABEL_442:
            v27 = 0;
            goto LABEL_31;
          }
          if (v20 < 52)
            goto LABEL_152;
          v19 = (unsigned __int16 *)__s1;
          v94 = _CFBundleGrokFileTypeForOLEFile(v31, (uint64_t)__s1, v20, ((*((_DWORD *)__s1 + 12) << 9) + 512));
LABEL_430:
          v27 = v94;
          goto LABEL_517;
        }
        if (v20 >= 8)
        {
          v19 = (unsigned __int16 *)__s1;
          v74 = *((_DWORD *)__s1 + 1);
          v75 = 169478669;
          goto LABEL_441;
        }
LABEL_444:
        v27 = 0;
        goto LABEL_30;
      }
      if (v28 == 0x10000)
      {
        if (v20 >= 6)
        {
          v19 = (unsigned __int16 *)__s1;
          if (!__s1[4])
            goto LABEL_290;
          goto LABEL_442;
        }
        goto LABEL_444;
      }
      if (v28 != 592859725)
      {
        if (v28 != 622940243)
          goto LABEL_152;
        v19 = (unsigned __int16 *)__s1;
        if (v20 < 11)
          goto LABEL_442;
        v79 = v26;
        if (!strncmp(__s1 + 4, "-Adobe-", 7uLL))
        {
          v27 = "ps";
          goto LABEL_517;
        }
        v20 = v146;
        if ((unint64_t)v146 < 0xE)
        {
          v27 = 0;
        }
        else
        {
          if (!strncmp(__s1 + 4, "-AdobeFont", 0xAuLL))
          {
            v27 = "pfa";
            goto LABEL_517;
          }
          v27 = 0;
          v20 = v146;
        }
        v26 = v79;
        goto LABEL_31;
      }
      if (v20 < 6)
        goto LABEL_444;
      v19 = (unsigned __int16 *)__s1;
      v74 = *((unsigned __int16 *)__s1 + 2);
      v75 = 8268;
    }
LABEL_441:
    if (v74 != v75)
      goto LABEL_442;
LABEL_290:
    if (!a3)
      goto LABEL_56;
    if (v27)
      goto LABEL_518;
    goto LABEL_292;
  }
  if (v28 <= 1400141157)
  {
    if (v28 > 1230262091)
    {
      if (v28 == 1230262092)
      {
        if (v20 < 8)
          goto LABEL_444;
        v19 = (unsigned __int16 *)__s1;
        v74 = *((_DWORD *)__s1 + 1);
        v75 = 1397511241;
        goto LABEL_441;
      }
      if (v28 == 1347093252)
      {
        v19 = (unsigned __int16 *)__s1;
        v94 = _CFBundleGrokFileTypeForZipFile(v31, (uint64_t)__s1, v20, st_size);
        goto LABEL_430;
      }
      if (v28 != 1380533830)
        goto LABEL_152;
      if (v20 < 12)
        goto LABEL_444;
      v19 = (unsigned __int16 *)__s1;
      v80 = bswap32(*((_DWORD *)__s1 + 2));
      if (v80 == 1096173856)
      {
        v27 = "avi";
        goto LABEL_517;
      }
      if (v80 == 1463899717)
      {
        v27 = "wav";
        goto LABEL_517;
      }
    }
    else
    {
      if (v28 == 1112493395)
      {
        if (v20 < 8)
          goto LABEL_444;
        v19 = (unsigned __int16 *)__s1;
        v74 = *((_DWORD *)__s1 + 1);
        v75 = 1701998452;
        goto LABEL_441;
      }
      if (v28 != 1179603533)
      {
        if (v28 != 1195984440)
          goto LABEL_152;
        v19 = (unsigned __int16 *)__s1;
        if (v20 < 6)
          goto LABEL_442;
        v74 = *((unsigned __int16 *)__s1 + 2);
        if (v74 == 24887)
          goto LABEL_290;
        v75 = 24889;
        goto LABEL_441;
      }
      if (v20 < 12)
        goto LABEL_444;
      v19 = (unsigned __int16 *)__s1;
      v95 = bswap32(*((_DWORD *)__s1 + 2));
      if (v95 == 4278598)
      {
        v27 = "aifc";
        goto LABEL_517;
      }
      if (v95 == 1095321158)
      {
        v27 = "aiff";
        goto LABEL_517;
      }
    }
    v27 = 0;
    v20 = v146;
    goto LABEL_31;
  }
  if (v28 > 1734962543)
  {
    if (v28 != 1734962544)
    {
      if (v28 != 1920231012)
      {
        if (v28 != 2069656180)
          goto LABEL_152;
        v19 = (unsigned __int16 *)__s1;
        if (v20 >= 6 && __s1[4] == 102)
          goto LABEL_290;
        goto LABEL_442;
      }
      if (v20 >= 8)
      {
        v19 = (unsigned __int16 *)__s1;
        if (*((_DWORD *)__s1 + 1))
          goto LABEL_442;
        goto LABEL_290;
      }
      goto LABEL_444;
    }
    if (v20 < 8)
      goto LABEL_444;
    v19 = (unsigned __int16 *)__s1;
    v74 = *((_DWORD *)__s1 + 1);
    v75 = 1717794848;
    goto LABEL_441;
  }
  if (v28 == 1400141158)
  {
    if (v20 < 8)
      goto LABEL_444;
    v19 = (unsigned __int16 *)__s1;
    v74 = *((_DWORD *)__s1 + 1);
    v75 = 544491878;
    goto LABEL_441;
  }
  if (v28 != 1650812777)
  {
    if (v28 != 1667327590)
      goto LABEL_152;
    v19 = (unsigned __int16 *)__s1;
    if (v20 < 12 || __s1[4])
      goto LABEL_442;
    v74 = *((_DWORD *)__s1 + 2);
    v75 = 1668506980;
    goto LABEL_441;
  }
  if (v20 < 76)
    goto LABEL_444;
  v19 = (unsigned __int16 *)__s1;
  if (__s1[4] != 110
    || __s1[5] != 32
    || __s1[6] - 48 > 9
    || __s1[7] - 48 > 9)
  {
    goto LABEL_442;
  }
  v96 = v26;
  v97 = a3;
  if (__s1[8] - 48 > 9)
  {
    v27 = 0;
    v31 = v144;
  }
  else
  {
    if (__s1[9] != 32)
      goto LABEL_589;
    v98 = 0;
    do
    {
      v99 = __s1[v98 + 10];
      v100 = v98 + 11;
      ++v98;
    }
    while (v99 != 10 && v100 < v146);
    v102 = v98 + 9;
    v103 = v99 == 10 ? v102 : 0;
    if (v103 >= 0xA && (v104 = v103 + 62, (uint64_t)(v103 + 62) < v146) && __s1[v103 + 1] == 77 && __s1[v104] == 10)
    {
      v105 = __s1 + 1;
      v106 = MEMORY[0x1E0C80978];
      do
      {
        v107 = v105[v103];
        if (v105[v103] < 0)
          v108 = __maskrune(v107, 0x40000uLL);
        else
          v108 = *(_DWORD *)(v106 + 4 * v107 + 60) & 0x40000;
        v109 = v103 + 2;
        ++v103;
        if (v108)
          v110 = v109 >= v104;
        else
          v110 = 1;
      }
      while (!v110);
      if (v108)
        v27 = "uu";
      else
        v27 = 0;
    }
    else
    {
LABEL_589:
      v27 = 0;
    }
    a3 = v97;
    v31 = v144;
    v19 = (unsigned __int16 *)__s1;
  }
  v20 = v146;
  v26 = v96;
LABEL_31:
  if (!a3 || v27)
    goto LABEL_47;
  v32 = *v19;
  if (v20 < 5)
    goto LABEL_180;
  v33 = v32 >> 8;
  if (*((_BYTE *)v19 + 3) || *((_BYTE *)v19 + 4))
    goto LABEL_36;
  if (v33)
  {
    if (v33 == 1 && (v19[1] & 0xF7) == 1)
      goto LABEL_455;
  }
  else if ((v19[1] & 0xF6) == 2)
  {
LABEL_455:
    v27 = "tga";
    goto LABEL_518;
  }
LABEL_36:
  if ((unint64_t)v20 < 8)
  {
LABEL_180:
    v68 = 0;
    v69 = 0;
    goto LABEL_181;
  }
  v34 = *((_DWORD *)v19 + 1);
  v27 = "mov";
  if (v34 <= 1952539752)
  {
    if (v34 == 1329745730)
    {
      v27 = "cwk";
      goto LABEL_518;
    }
    if (v34 != 1668506729)
    {
      v35 = 1701079415;
      goto LABEL_259;
    }
LABEL_327:
    v27 = "qtif";
    goto LABEL_518;
  }
  if (v34 == 1952539753)
    goto LABEL_327;
  if (v34 == 1952539757)
    goto LABEL_518;
  v35 = 1987014509;
LABEL_259:
  if (v34 == v35)
    goto LABEL_518;
  if (v26 == 1768714338
    && (unsigned __int16)*((_DWORD *)v19 + 1) == 29811
    && (HIWORD(v34) & 0xFE) - 48 <= 9u
    && HIBYTE(v34) - 48 <= 9u)
  {
    v27 = "plist";
    if ((unint64_t)v20 < 0x18)
      goto LABEL_518;
    v76 = 8;
    do
    {
      v77 = strncmp((const char *)v19 + v76, "WebMainResource", 0xFuLL);
      if (!v77)
        break;
      if (v76 > 0x7E)
        break;
      v78 = v76 + 17;
      ++v76;
    }
    while (v78 <= v146);
    if (!v77)
      v27 = "webarchive";
    goto LABEL_517;
  }
  v68 = (unint64_t)v20 > 0xB;
  if (*v19 || (unint64_t)v20 < 0xC)
  {
    if (v32 == 19778 && (unint64_t)v20 >= 0x12)
    {
      v120 = *(_DWORD *)(v19 + 7);
      v27 = "bmp";
      if ((v120 - 12) <= 0x34 && ((1 << (v120 - 12)) & 0x10000010000001) != 0
        || v120 == 108
        || v120 == 124)
      {
        goto LABEL_518;
      }
      goto LABEL_372;
    }
  }
  else if (v34 == 1887007846)
  {
    v111 = bswap32(*((_DWORD *)v19 + 2));
    if (v111 > 1769172785)
    {
      v27 = "mp4";
      if ((v111 - 1836069937) < 2 || v111 == 1769172786 || v111 == 1769172845)
        goto LABEL_518;
    }
    else if (v111 > 1295275551)
    {
      if ((v111 - 1295275552) <= 0x30 && ((1 << (v111 - 32)) & 0x1010000000001) != 0)
      {
        v27 = "m4v";
        goto LABEL_518;
      }
    }
    else
    {
      switch(v111)
      {
        case 1295270176:
          v27 = "m4a";
          goto LABEL_518;
        case 1295270432:
          v27 = "m4b";
          goto LABEL_518;
        case 1295274016:
          v27 = "m4p";
          goto LABEL_518;
      }
    }
    if (HIWORD(v111) != 13159)
    {
      v27 = 0;
LABEL_593:
      v19 = (unsigned __int16 *)__s1;
LABEL_594:
      v20 = v146;
LABEL_47:
      if (!a3 || v27)
        goto LABEL_289;
      v136 = a4;
      v137 = a3;
      if (*(unsigned __int8 *)v19 == 239 && *((unsigned __int8 *)v19 + 1) == 187)
      {
        v37 = *((unsigned __int8 *)v19 + 2);
        v38 = v37 != 191;
        if (v37 == 191)
          v39 = 3;
        else
          v39 = 0;
      }
      else
      {
        v39 = 0;
        v38 = 1;
      }
      if (v20 >= 512)
        v41 = 512;
      else
        v41 = v20;
      v42 = 1;
      v43 = 1;
      v44 = 1;
      while (1)
      {
        if (v39 >= v41)
        {
          a4 = v136;
          a3 = v137;
LABEL_176:
          if (v44)
          {
            if (v20 >= 16)
            {
              v31 = v144;
              if (strncmp((const char *)v19, "StartFontMetrics", 0x10uLL))
                goto LABEL_179;
              v27 = "afm";
              goto LABEL_289;
            }
            v27 = "txt";
LABEL_198:
            v31 = v144;
            goto LABEL_518;
          }
          v27 = 0;
          if (v38 && v20 >= 512 && st_size >= 526)
          {
            if (v143)
            {
              v31 = v144;
              if (lseek(v144, 512, 0) == 512 && read(v144, v150, 0x200uLL) >= 14)
              {
                if (*(_DWORD *)((char *)&v150[2] + 2) != -16641792)
                {
LABEL_292:
                  v20 = v146;
                  goto LABEL_293;
                }
LABEL_287:
                v27 = "pict";
                goto LABEL_518;
              }
            }
            else if ((unint64_t)v20 >= 0x20E)
            {
              v31 = v144;
              if (*(_DWORD *)((char *)v141 + 265) != -16641792)
              {
LABEL_293:
                v27 = 0;
                if (v20 < 512 || st_size < 512)
                  goto LABEL_43;
                goto LABEL_521;
              }
              goto LABEL_287;
            }
            v27 = 0;
          }
LABEL_289:
          v31 = v144;
          goto LABEL_290;
        }
        v45 = (char *)v19 + v39;
        v46 = *v45;
        v47 = v39 + 14;
        if (v42 && v46 == 60 && v47 <= v20)
        {
          v49 = strncasecmp_l(v45 + 1, "!doctype html", 0xDuLL, 0);
          v20 = v146;
          if (v49)
            v27 = 0;
          else
            v27 = "html";
          if (!v43)
            goto LABEL_125;
        }
        else
        {
          v27 = 0;
          if (!v43)
            goto LABEL_125;
        }
        if (v46 != 60 || v47 > v20)
          goto LABEL_125;
        v51 = v45 + 1;
        if (!strncasecmp_l(v51, "!doctype html", 0xDuLL, 0)
          || !strncasecmp_l(v51, "head", 4uLL, 0)
          || !strncasecmp_l(v51, "title", 5uLL, 0)
          || !strncasecmp_l(v51, "script", 6uLL, 0)
          || !strncasecmp_l(v51, "html", 4uLL, 0))
        {
          v27 = "html";
LABEL_124:
          v20 = v146;
          goto LABEL_125;
        }
        if (strncasecmp_l(v51, "?xml", 4uLL, 0))
          goto LABEL_124;
        v52 = v39 + 4;
        v53 = v27 != 0;
        v20 = v146;
        if (!v27 && v39 <= 123)
        {
          for (i = v39 + 24; i <= v20; i = v57 + 21)
          {
            v55 = &__s1[v52];
            if (__s1[v52] == 60)
            {
              v56 = v55 + 1;
              if (!strncasecmp_l(v55 + 1, "abiword", 7uLL, 0))
              {
                v27 = "abw";
                goto LABEL_110;
              }
              if (!strncasecmp_l(v56, "!doctype svg", 0xCuLL, 0))
              {
                v27 = "svg";
                goto LABEL_110;
              }
              if (!strncasecmp_l(v56, "!doctype rdf", 0xCuLL, 0))
              {
                v27 = "rdf";
                goto LABEL_110;
              }
              if (!strncasecmp_l(v56, "!doctype x3d", 0xCuLL, 0))
              {
                v27 = "x3d";
                goto LABEL_110;
              }
              if (!strncasecmp_l(v56, "!doctype html", 0xDuLL, 0))
              {
                v27 = "html";
                goto LABEL_110;
              }
              if (!strncasecmp_l(v56, "!doctype posingfont", 0x13uLL, 0))
              {
                v27 = "sfont";
                goto LABEL_110;
              }
              if (strncasecmp_l(v56, "!doctype plist", 0xEuLL, 0))
              {
                v27 = 0;
LABEL_110:
                v57 = v52;
                v20 = v146;
                goto LABEL_111;
              }
              v57 = v52 + 14;
              v20 = v146;
              if (v52 + 30 <= v146)
              {
                do
                {
                  v58 = strncmp(&__s1[v57], "WebMainResource", 0xFuLL);
                  v20 = v146;
                  v59 = v57 + 1;
                  if (!v58)
                    break;
                  if (v57 > 254)
                    break;
                  v60 = v57 + 17;
                  ++v57;
                }
                while (v60 <= v146);
                if (v58)
                  v27 = "plist";
                else
                  v27 = "webarchive";
                v57 = v59;
              }
              else
              {
                v27 = "plist";
              }
            }
            else
            {
              v27 = 0;
              v57 = v52;
            }
LABEL_111:
            v52 = v57 + 1;
            v53 = v27 != 0;
            if (v27 || v57 > 126)
              break;
          }
        }
        if (!v53)
          v27 = "xml";
        v39 = v52;
LABEL_125:
        if (v46)
          v38 = 0;
        v19 = (unsigned __int16 *)__s1;
        if (v38 || v46 == 127)
        {
          v44 = 0;
          if (v38)
            goto LABEL_139;
        }
        else
        {
          if (v46 > 31)
            goto LABEL_137;
          if (v46 < 0)
          {
            v61 = __maskrune(v46, 0x4000uLL);
            v20 = v146;
            if (v61)
              goto LABEL_137;
          }
          else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v46 + 60) & 0x4000) != 0)
          {
            goto LABEL_137;
          }
          v44 = 0;
        }
LABEL_137:
        if ((v46 & 0x80000000) == 0)
        {
          if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v46 + 60) & 0x4000) != 0)
            goto LABEL_140;
LABEL_139:
          v43 = 0;
          goto LABEL_140;
        }
        v62 = __maskrune(v46, 0x4000uLL);
        v20 = v146;
        if (!v62)
          goto LABEL_139;
LABEL_140:
        v42 = v44 != 0;
        if (!v27)
        {
          ++v39;
          if (v38 | v44)
            continue;
        }
        a4 = v136;
        a3 = v137;
        if (v27)
          goto LABEL_289;
        goto LABEL_176;
      }
    }
    *(int8x8_t *)a9.i8 = vand_s8((int8x8_t)vdup_n_s32(v111), (int8x8_t)0xFDFF0000FFFELL);
    v27 = "3gp";
    if ((vmaxv_u16((uint16x4_t)vmovn_s32(vceqq_s32(vzip1q_s32(a9, vdupq_lane_s32(*(int32x2_t *)a9.i8, 0)), (int32x4_t)xmmword_182DB1550))) & 1) == 0&& (unsigned __int16)v111 != 26422)
    {
      if ((unsigned __int16)v111 == 12897)
        v27 = "3g2";
      else
        v27 = 0;
      goto LABEL_593;
    }
LABEL_595:
    v31 = v144;
    v19 = (unsigned __int16 *)__s1;
    goto LABEL_518;
  }
  if ((unint64_t)v20 < 0x14)
    goto LABEL_579;
  if (!strncmp((const char *)v19 + 6, "%!PS-AdobeFont", 0xEuLL))
  {
    v27 = "pfb";
    goto LABEL_518;
  }
  v20 = v146;
  if ((unint64_t)v146 < 0x28)
    goto LABEL_578;
  if (*(_DWORD *)(v19 + 17) == 1215195458 && v19[19] == 30821)
  {
    v27 = "hqx";
    goto LABEL_518;
  }
  if ((unint64_t)v146 < 0x80)
  {
LABEL_578:
    v68 = 1;
LABEL_579:
    v69 = 1;
    goto LABEL_181;
  }
  v27 = "bin";
  if (*(_DWORD *)(v19 + 51) == 1313423981)
    goto LABEL_198;
  if (!*(_BYTE *)v19 && v33 - 1 <= 0x3E && !__s1[74] && !__s1[82] && (st_size & 0x7F) == 0)
  {
    v19 = (unsigned __int16 *)__s1;
    v121 = bswap32(*(_DWORD *)(__s1 + 83));
    v122 = bswap32(*(_DWORD *)(__s1 + 87));
    v123 = ((v121 + 127) >> 7) + ((v122 + 127) >> 7) + 1;
    if (st_size != v123 << 7 || v123 <= 1 || v122 >= 0x800000 || v121 >= 0x800000)
      v27 = 0;
    goto LABEL_594;
  }
  if ((unint64_t)v146 >= 0x109 && *v141 == 1635021685)
  {
    v27 = "tar";
    if (v141[1] == 2105458 || (unsigned __int16)v141[1] == 114)
      goto LABEL_595;
  }
  v68 = 1;
  v69 = 1;
  v31 = v144;
  v19 = (unsigned __int16 *)__s1;
  v20 = v146;
LABEL_181:
  v70 = __rev16(v32);
  if (v70 > 18755)
  {
    if (v70 > 63233)
    {
      if (v70 > 65495)
      {
        if (v70 == 65496)
        {
          if (*((unsigned __int8 *)v19 + 2) == 255)
          {
            v27 = "jpeg";
            goto LABEL_518;
          }
          goto LABEL_370;
        }
        v72 = 65534;
      }
      else
      {
        if (v70 == 63234)
        {
          v27 = "dvi";
          goto LABEL_518;
        }
        v72 = 65279;
      }
      if (v70 == v72)
      {
        if (v68)
        {
          if (*(_DWORD *)v19 == -115712)
          {
            if (*((_DWORD *)v19 + 1) != 1744860160 || *((_DWORD *)v19 + 2) != 1828744192)
              goto LABEL_179;
          }
          else if (*(_DWORD *)v19 != 3997439 || *((_DWORD *)v19 + 1) != 7602280 || *((_DWORD *)v19 + 2) != 7077997)
          {
            goto LABEL_179;
          }
          v27 = "html";
          goto LABEL_518;
        }
LABEL_179:
        v27 = "txt";
        goto LABEL_518;
      }
      goto LABEL_370;
    }
    if (v70 == 18756)
    {
      if (*((_BYTE *)v19 + 2) == 51 && *((unsigned __int8 *)v19 + 3) < 0x20u)
      {
        v27 = "mp3";
        goto LABEL_518;
      }
    }
    else if (v70 == 29127 || v70 == 51057)
    {
      v27 = "cpio";
      goto LABEL_518;
    }
LABEL_370:
    v93 = v19[1];
    v27 = "tfm";
    if (v93 == 4352 || v93 == 4608)
      goto LABEL_518;
LABEL_372:
    v27 = 0;
    goto LABEL_47;
  }
  if (v70 <= 8992)
  {
    switch(v70)
    {
      case 474:
        if (*((unsigned __int8 *)v19 + 2) <= 1u && *((unsigned __int8 *)v19 + 3) - 1 < 0xF)
        {
          v27 = "sgi";
          goto LABEL_518;
        }
        break;
      case 8075:
        v27 = "gz";
        goto LABEL_518;
      case 8093:
        v27 = "Z";
        goto LABEL_518;
    }
    goto LABEL_370;
  }
  if (v70 > 17238)
  {
    if (v70 == 17239)
    {
      if (*((_BYTE *)v19 + 2) == 83)
      {
        v27 = "swc";
        goto LABEL_518;
      }
    }
    else if (v70 == 18007 && *((_BYTE *)v19 + 2) == 83)
    {
      v27 = "swf";
      goto LABEL_518;
    }
    goto LABEL_370;
  }
  if (v70 == 8993)
  {
    v85 = 0;
    do
    {
      v86 = *((unsigned __int8 *)v19 + v85 + 2);
      v87 = v85 + 3;
      ++v85;
    }
    while (v86 != 10 && v87 < v20);
    v27 = 0;
    if ((unint64_t)(v85 + 1) < 4 || v86 != 10)
      goto LABEL_47;
    do
    {
      if (*((_BYTE *)v19 + v85) == 47)
        v89 = v85;
      else
        v89 = 0;
      if ((unint64_t)(v85 + 1) < 4)
        break;
      --v85;
    }
    while (!v89);
    if (!v89)
      goto LABEL_372;
    v90 = (char *)v19 + v89 + 1;
    if (!strncmp(v90, "perl", 4uLL))
    {
      v27 = "pl";
    }
    else if (!strncmp(v90, "python", 6uLL))
    {
      v27 = "py";
    }
    else if (!strncmp(v90, "ruby", 4uLL))
    {
      v27 = "rb";
    }
    else
    {
      v27 = "sh";
    }
LABEL_517:
    if (!a3)
      goto LABEL_56;
    goto LABEL_518;
  }
  if (v70 != 16986)
    goto LABEL_370;
  v71 = *((unsigned __int8 *)v19 + 2);
  if ((v71 - 48) <= 9 && *((unsigned __int8 *)v19 + 3) - 48 < 0xA)
  {
    v27 = "bz";
    goto LABEL_518;
  }
  if (v71 != 104)
    goto LABEL_370;
  v91 = v69 ^ 1;
  if (*((unsigned __int8 *)v19 + 3) - 48 > 9)
    v91 = 1;
  if ((v91 & 1) != 0)
    goto LABEL_370;
  v92 = *((_DWORD *)v19 + 1);
  v27 = "bz2";
  if (v92 != 643383601 && v92 != 944075287)
    goto LABEL_370;
LABEL_518:
  if (strcmp(v27, "bz2"))
    goto LABEL_43;
  v20 = v146;
  if (v146 < 512 || st_size <= 511)
    goto LABEL_43;
LABEL_521:
  if (!v143)
  {
    v119 = (char *)v19 + v20;
    if (*(_DWORD *)((char *)v19 + v20 - 512) != 2037149547)
    {
      if (*((_DWORD *)v119 - 2) != 1634952291)
        goto LABEL_43;
      v118 = *((_DWORD *)v119 - 1);
LABEL_530:
      if (v118 != 1919118949)
        goto LABEL_43;
    }
LABEL_531:
    v27 = "dmg";
    goto LABEL_43;
  }
  if (lseek(v31, st_size - 512, 0) == st_size - 512 && read(v31, v150, 0x200uLL) >= 512)
  {
    if (v150[0] != 2037149547)
    {
      if (v150[126] != 1634952291)
        goto LABEL_43;
      v118 = v150[127];
      goto LABEL_530;
    }
    goto LABEL_531;
  }
LABEL_43:
  if (a3)
  {
    if (v27)
      v36 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v27, 0x8000100u, (CFAllocatorRef)&__kCFAllocatorNull);
    else
      v36 = 0;
    *a3 = v36;
  }
LABEL_56:
  if (a4)
    *a4 = v30;
  if ((v31 & 0x80000000) == 0)
    close(v31);
  return v27 != 0;
}

CFMutableDictionaryRef _CFBundleCreateInfoDictFromFile(int a1, UInt8 *a2, unint64_t st_size, int a4, int a5, int a6)
{
  uint64_t v8;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  UInt8 *v15;
  unsigned int v16;
  unsigned int v17;
  int *v18;
  unint64_t v19;
  unint64_t v20;
  BOOL v21;
  int v22;
  unint64_t v23;
  int v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  UInt8 *v29;
  unsigned int v30;
  UInt8 *v32;
  unint64_t v33;
  unsigned int v34;
  UInt8 *v35;
  int *v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  int v41;
  unint64_t v42;
  int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  unsigned int v47;
  UInt8 *v48;
  unsigned int v49;
  UInt8 *v51;
  CFIndex v52;
  unsigned int v53;
  UInt8 *v54;
  UInt8 *v56;
  UInt8 *v57;
  uint64_t v58;
  CFMutableDictionaryRef InfoDictFromData;
  unsigned int *v60;
  uint64_t v61;
  int v62;
  unsigned int v63;
  unsigned int v64;
  stat v65;
  uint64_t v66;

  LODWORD(v8) = a4;
  v66 = *MEMORY[0x1E0C80C00];
  memset(&v65, 0, sizeof(v65));
  if (a1 < 0 || fstat(a1, &v65))
  {
    v58 = 0;
  }
  else
  {
    v15 = (UInt8 *)mmap(0, v65.st_size, 1, 8194, a1, 0);
    if (v15 == (UInt8 *)-1)
    {
      v58 = -1;
    }
    else
    {
      st_size = v65.st_size;
      v58 = (uint64_t)v15;
      a2 = v15;
    }
  }
  v8 = v8;
  if (st_size <= (unint64_t)v8 + 32)
    goto LABEL_65;
  v12 = (unsigned int *)&a2[v8];
  v62 = a5;
  v60 = v12;
  v61 = v8;
  if (!a6)
  {
    v16 = v12[4];
    if (a5)
    {
      v16 = bswap32(v16);
      v17 = bswap32(v12[5]);
    }
    else
    {
      v17 = v12[5];
    }
    v36 = (int *)(v12 + 7);
    v37 = (unint64_t)v12 + v17 + 28;
    v57 = &a2[st_size];
    if (v37 <= (unint64_t)&a2[st_size])
      v38 = v37;
    else
      v38 = (unint64_t)&a2[st_size];
    if (v16)
      v39 = (unint64_t)v36 >= v38;
    else
      v39 = 1;
    if (v39)
      goto LABEL_65;
    v41 = 0;
    InfoDictFromData = 0;
    v42 = 28;
    v64 = v16;
    while (1)
    {
      v43 = *v36;
      if (a5)
        break;
      if (v43 == 1)
      {
        v44 = v36[12];
        goto LABEL_74;
      }
      v49 = v36[1];
LABEL_88:
      if (++v41 < v16)
      {
        v42 += v49;
        v36 = (int *)((char *)v12 + v42);
        if (v42 >= 0x1C && (unint64_t)v36 < v38)
          continue;
      }
      goto LABEL_66;
    }
    if (v43 == 0x1000000)
    {
      v44 = bswap32(v36[12]);
LABEL_74:
      v45 = 0;
      if (v44 && (unint64_t)v12 + v42 + 56 < v38)
      {
        v46 = v8 + v42;
        v47 = 1;
        while (1)
        {
          v48 = &a2[v46];
          if (!strncmp((const char *)&a2[v46 + 56], "__info_plist", 0x10uLL)
            && !strncmp((const char *)v48 + 72, "__TEXT", 0x10uLL))
          {
            break;
          }
          if (v47 < v44)
          {
            v46 += 68;
            ++v47;
            if ((unint64_t)(v48 + 124) < v38)
              continue;
          }
          v45 = 0;
          a5 = v62;
          v12 = v60;
          v8 = v61;
          goto LABEL_82;
        }
        v51 = &a2[v46];
        v52 = *(unsigned int *)&a2[v46 + 92];
        a5 = v62;
        v12 = v60;
        if (v62)
        {
          v52 = bswap32(v52);
          v53 = bswap32(*((_DWORD *)v51 + 24));
        }
        else
        {
          v53 = *((_DWORD *)v51 + 24);
        }
        v8 = v61;
        v16 = v64;
        v54 = (UInt8 *)v60 + v53;
        if (a2 <= v54 && &v54[v52] <= v57)
          InfoDictFromData = _CFBundleCreateInfoDictFromData(v54, v52);
        v45 = 1;
      }
      else
      {
LABEL_82:
        v16 = v64;
      }
      v49 = v36[1];
      if (!a5)
      {
LABEL_87:
        if (v45)
          goto LABEL_66;
        goto LABEL_88;
      }
    }
    else
    {
      v45 = 0;
      v49 = v36[1];
    }
    v49 = bswap32(v49);
    goto LABEL_87;
  }
  v13 = v12[4];
  if (a5)
  {
    v13 = bswap32(v13);
    v14 = bswap32(v12[5]);
  }
  else
  {
    v14 = v12[5];
  }
  v18 = (int *)(v12 + 8);
  v19 = (unint64_t)v12 + v14 + 32;
  v56 = &a2[st_size];
  if (v19 <= (unint64_t)&a2[st_size])
    v20 = v19;
  else
    v20 = (unint64_t)&a2[st_size];
  if (v13)
    v21 = (unint64_t)v18 >= v20;
  else
    v21 = 1;
  if (!v21)
  {
    v22 = 0;
    InfoDictFromData = 0;
    v23 = 32;
    v63 = v13;
    while (1)
    {
      v24 = *v18;
      if (a5)
        break;
      if (v24 == 25)
      {
        v25 = v18[16];
        goto LABEL_26;
      }
      v30 = v18[1];
LABEL_40:
      if (++v22 < v13)
      {
        v23 += v30;
        v18 = (int *)((char *)v12 + v23);
        if (v23 >= 0x20 && (unint64_t)v18 < v20)
          continue;
      }
      goto LABEL_66;
    }
    if (v24 == 419430400)
    {
      v25 = bswap32(v18[16]);
LABEL_26:
      v26 = 0;
      if (v25 && (unint64_t)v12 + v23 + 72 < v20)
      {
        v27 = v8 + v23;
        v28 = 1;
        while (1)
        {
          v29 = &a2[v27];
          if (!strncmp((const char *)&a2[v27 + 72], "__info_plist", 0x10uLL)
            && !strncmp((const char *)v29 + 88, "__TEXT", 0x10uLL))
          {
            break;
          }
          if (v28 < v25)
          {
            v27 += 80;
            ++v28;
            if ((unint64_t)(v29 + 152) < v20)
              continue;
          }
          v26 = 0;
          a5 = v62;
          v12 = v60;
          v8 = v61;
          goto LABEL_34;
        }
        v32 = &a2[v27];
        v33 = *(_QWORD *)&a2[v27 + 112];
        a5 = v62;
        if (v62)
        {
          v33 = bswap64(v33);
          v34 = bswap32(*((_DWORD *)v32 + 30));
        }
        else
        {
          v34 = *((_DWORD *)v32 + 30);
        }
        v12 = v60;
        v8 = v61;
        v13 = v63;
        v26 = 1;
        if (!HIDWORD(v33))
        {
          v35 = (UInt8 *)v60 + v34;
          if (a2 <= v35 && &v35[v33] <= v56)
          {
            InfoDictFromData = _CFBundleCreateInfoDictFromData(v35, v33);
            v26 = 1;
          }
        }
      }
      else
      {
LABEL_34:
        v13 = v63;
      }
      v30 = v18[1];
      if (!a5)
      {
LABEL_39:
        if (v26)
          goto LABEL_66;
        goto LABEL_40;
      }
    }
    else
    {
      v26 = 0;
      v30 = v18[1];
    }
    v30 = bswap32(v30);
    goto LABEL_39;
  }
LABEL_65:
  InfoDictFromData = 0;
LABEL_66:
  if (v58)
    munmap((void *)v58, v65.st_size);
  return InfoDictFromData;
}

CFMutableDictionaryRef _CFBundleCreateInfoDictFromMainExecutable()
{
  UInt8 *SectData;
  CFIndex v1;
  uint64_t v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v3[0] = 0;
  SectData = (UInt8 *)getsegbyname("__TEXT");
  if (SectData)
  {
    SectData = (UInt8 *)_CFBundleGetSectData("__TEXT", "__info_plist", v3);
    v1 = LODWORD(v3[0]);
  }
  else
  {
    v1 = 0;
  }
  return _CFBundleCreateInfoDictFromData(SectData, v1);
}

CFMutableDictionaryRef _CFBundleCreateInfoDictFromData(UInt8 *bytes, CFIndex length)
{
  CFMutableDictionaryRef Mutable;
  const __CFData *v3;
  const __CFData *v4;
  __CFDictionary *v5;
  CFTypeID TypeID;

  Mutable = 0;
  if (bytes && (_DWORD)length)
  {
    v3 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes, length, (CFAllocatorRef)&__kCFAllocatorNull);
    if (v3)
    {
      v4 = v3;
      v5 = (__CFDictionary *)CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3, 1uLL, 0, 0);
      if (v5)
      {
        Mutable = v5;
        TypeID = CFDictionaryGetTypeID();
        if (TypeID == CFGetTypeID(Mutable))
        {
          CFRelease(v4);
LABEL_10:
          _CFBundleInfoPlistProcessInfoDictionary(Mutable);
          return Mutable;
        }
        CFRelease(Mutable);
      }
      CFRelease(v4);
    }
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
      goto LABEL_10;
  }
  return Mutable;
}

const section_64 *_CFBundleGetSectData(const char *a1, const char *a2, uint64_t *a3)
{
  uint32_t v6;
  mach_header_64 *v7;
  const mach_header *v8;
  uint32_t v9;
  const section_64 *result;
  uint64_t size;
  const section_64 *v12;
  uint64_t addr;

  v6 = _dyld_image_count();
  v7 = _NSGetMachExecuteHeader();
  if (!v6)
  {
LABEL_5:
    result = 0;
    goto LABEL_6;
  }
  v8 = (const mach_header *)v7;
  v9 = 0;
  while (v8 != _dyld_get_image_header(v9))
  {
    if (v6 == ++v9)
      goto LABEL_5;
  }
  result = getsectbynamefromheader_64((const mach_header_64 *)v8, a1, a2);
  if (!result)
  {
LABEL_6:
    size = 0;
    if (!a3)
      return result;
    goto LABEL_7;
  }
  v12 = result;
  addr = result->addr;
  result = (const section_64 *)(_dyld_get_image_vmaddr_slide(v9) + addr);
  size = v12->size;
  if (!a3)
    return result;
LABEL_7:
  *a3 = size;
  return result;
}

uint64_t ___canDup_block_invoke()
{
  uint64_t result;

  getpid();
  result = sandbox_check();
  if ((_DWORD)result)
    _canDup_canDup = 1;
  return result;
}

void _CFBundleDlfcnGetSymbolByNameWithSearch_cold_1()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_6_0();
  dlerror();
  OUTLINED_FUNCTION_1_3(&dword_182A8C000, v0, v1, "dlsym cannot find symbol %{public}@ in %{public}@: %s", v2, v3, v4, v5, 2u);
  OUTLINED_FUNCTION_3_1();
}

void _CFPlugInUnscheduleForUnloading_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_6_1();
  OUTLINED_FUNCTION_4_1(&dword_182A8C000, v0, v1, "PlugIn %{public}@ is now unscheduled for unloading", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_6();
}

void _CFBundleCopyLoadedImagePathForPointer_cold_1()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_8();
  OUTLINED_FUNCTION_0_4(&dword_182A8C000, v0, v1, "dyld image path for pointer %p is %{public}@");
  OUTLINED_FUNCTION_4_0();
}

void OUTLINED_FUNCTION_5(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 220, a4);
}

void OUTLINED_FUNCTION_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

CFAbsoluteTime CFRunLoopTimerGetNextFireDate(CFRunLoopTimerRef timer)
{
  CFAbsoluteTime result;
  char v3;
  double v4;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (CF_IS_OBJC(0x2FuLL, (__objc2_class **)timer))
  {
    -[__CFRunLoopTimer _cffireTime](timer, "_cffireTime");
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)timer + 24));
    v3 = atomic_load((unint64_t *)timer + 1);
    v4 = 0.0;
    if ((v3 & 8) != 0)
      v4 = *((double *)timer + 13);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)timer + 24));
    return v4;
  }
  return result;
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  CFIndex length;
  CFIndex location;
  _QWORD *Instance;
  uint64_t v12;

  length = range.length;
  location = range.location;
  if (__CFSTLoadCoreNLP_once != -1)
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  if (!__CFSTLoadCoreNLP_isCoreNLPAvailable)
    return 0;
  Instance = (_QWORD *)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x28uLL, 8, 0);
  if (Instance)
  {
    v12 = __NLStringTokenizerCreate(alloc, string, location, length, options, locale);
    Instance[2] = v12;
    if (!v12)
    {
      CFRelease(Instance);
      return 0;
    }
  }
  return (CFStringTokenizerRef)Instance;
}

id _CFLocaleCopyNumberingSystemForLocaleIdentifier(uint64_t a1)
{
  return (id)+[NSLocale _numberingSystemForLocaleIdentifier:](NSLocale, "_numberingSystemForLocaleIdentifier:", a1);
}

void sub_182B93118(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182B93358(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182B93580(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFRunLoopMode mode)
{
  unint64_t v4;
  char v5;
  const __CFSet *v6;
  const __CFSet *Copy;
  _QWORD context[3];

  context[2] = *MEMORY[0x1E0C80C00];
  v4 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v4 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v5 = atomic_load((unint64_t *)rl + 1);
  if ((v5 & 4) == 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
    if (!CFSetContainsValue(*((CFSetRef *)rl + 76), mode))
    {
      v6 = (const __CFSet *)*((_QWORD *)rl + 77);
      if (v6)
      {
        Copy = CFSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6);
        CFSetAddValue(*((CFMutableSetRef *)rl + 76), mode);
        if (Copy)
        {
          context[0] = rl;
          context[1] = mode;
          CFSetApplyFunction(Copy, (CFSetApplierFunction)__CFRunLoopAddItemsToCommonMode, context);
          CFRelease(Copy);
        }
      }
      else
      {
        CFSetAddValue(*((CFMutableSetRef *)rl + 76), mode);
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
  }
}

void ___signalEventQueue_block_invoke(uint64_t a1)
{
  _signalEventSync(*(_QWORD *)(a1 + 32));
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

uint64_t __CFDateComponentsEqual(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  uint64_t result;
  const void *v7;
  const void *v8;

  if (!a1)
    __CFDateComponentsEqual_cold_1();
  if (!a2)
    __CFDateComponentsEqual_cold_2();
  if (a1[4] != a2[4]
    || a1[5] != a2[5]
    || a1[15] != a2[15]
    || a1[6] != a2[6]
    || a1[8] != a2[8]
    || a1[9] != a2[9]
    || a1[10] != a2[10]
    || a1[11] != a2[11]
    || a1[19] != a2[19]
    || a1[12] != a2[12]
    || a1[17] != a2[17]
    || a1[20] != a2[20]
    || a1[16] != a2[16]
    || a1[18] != a2[18]
    || a1[13] != a2[13]
    || a1[14] != a2[14])
  {
    return 0;
  }
  v2 = a1[7];
  if (v2)
  {
    if (v2 == 0x7FFFFFFFFFFFFFFFLL)
    {
      v3 = a2[7];
      if (!v3)
        goto LABEL_29;
    }
    else
    {
      v3 = a2[7];
    }
  }
  else
  {
    v3 = a2[7];
    if (v3 == 0x7FFFFFFFFFFFFFFFLL)
      goto LABEL_29;
  }
  if (v2 != v3)
    return 0;
LABEL_29:
  v4 = (const void *)a1[2];
  v5 = (const void *)a2[2];
  if (v4)
  {
    if (!v5)
      return 0;
    result = CFEqual(v4, v5);
    if (!(_DWORD)result)
      return result;
  }
  else if (v5)
  {
    return 0;
  }
  v7 = (const void *)a1[3];
  v8 = (const void *)a2[3];
  if (!v7)
    return !v8;
  if (!v8)
    return 0;
  result = CFEqual(v7, v8);
  if ((_DWORD)result)
    return 1;
  return result;
}

Boolean CFWriteStreamCanAcceptBytes(CFWriteStreamRef stream)
{
  Boolean v2;
  uint64_t Status;
  uint64_t *v4;
  uint64_t (*v5)(CFWriteStreamRef, char *, _QWORD);
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFRunLoopSource *v9;

  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
    return -[__CFWriteStream hasSpaceAvailable](stream, "hasSpaceAvailable");
  Status = _CFStreamGetStatus((uint64_t)stream);
  if (Status != 4 && Status != 2)
    return 0;
  v4 = (uint64_t *)*((_QWORD *)stream + 6);
  v5 = (uint64_t (*)(CFWriteStreamRef, char *, _QWORD))v4[10];
  if (!v5)
    return 1;
  *((_QWORD *)stream + 2) |= 0x40uLL;
  if (*v4 > 1)
  {
    v2 = v5(stream, (char *)stream + 24, *((_QWORD *)stream + 5));
    if (*((_QWORD *)stream + 3))
    {
      v6 = *((_QWORD *)stream + 2);
      if ((v6 & 0x1F) != 7)
        *((_QWORD *)stream + 2) = v6 & 0xFFFFFFE0 | 7;
      v7 = *((_QWORD *)stream + 4);
      if (v7 && (*(_BYTE *)(v7 + 48) & 8) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
        v8 = *((_QWORD *)stream + 4);
        if (v8 && (v9 = *(__CFRunLoopSource **)(v8 + 56)) != 0)
        {
          CFRetain(*(CFTypeRef *)(v8 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          *(_QWORD *)(*((_QWORD *)stream + 4) + 72) |= 8uLL;
          CFRunLoopSourceSignal(v9);
          CFRelease(v9);
          _wakeUpRunLoop((uint64_t)stream);
        }
        else
        {
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        }
      }
    }
  }
  else
  {
    v2 = ((uint64_t (*)(CFWriteStreamRef, _QWORD))v5)(stream, *((_QWORD *)stream + 5));
  }
  *((_QWORD *)stream + 2) &= ~0x40uLL;
  return v2;
}

void CFPreferencesRemoveSuitePreferencesFromApp(CFStringRef applicationID, CFStringRef suiteID)
{
  _CFPreferencesRemoveSuitePreferencesFromAppWithContainer((uint64_t)applicationID, (uint64_t)suiteID, 0);
}

CFTypeID CFSocketGetTypeID(void)
{
  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  return 61;
}

CFURLRef CFBundleCopyResourceURLInDirectory(CFURLRef bundleURL, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  size_t v8;
  const __CFURL *v9;
  uint64_t v10;
  const __CFURL *Resources;
  UInt8 buffer[1026];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!CFURLGetFileSystemRepresentation(bundleURL, 1u, buffer, 1026))
    return 0;
  v8 = strlen((const char *)buffer);
  v9 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, v8, 1u);
  if (!v9)
    v9 = (const __CFURL *)CFRetain(bundleURL);
  if (_CFBundleCouldBeBundle(v9))
  {
    Resources = _CFBundleCopyFindResources(0, bundleURL, v10, resourceName, resourceType, subDirName, 0, 0, 0, 0);
    if (!v9)
      return Resources;
    goto LABEL_9;
  }
  Resources = 0;
  if (v9)
LABEL_9:
    CFRelease(v9);
  return Resources;
}

void CFStreamCreateBoundPair(CFAllocatorRef alloc, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream, CFIndex transferBufferSize)
{
  uint64_t Typed;
  __CFReadStream *v9;
  void **v10[2];

  v10[1] = *(void ***)MEMORY[0x1E0C80C00];
  if (readStream)
    *readStream = 0;
  if (writeStream)
    *writeStream = 0;
  v10[0] = 0;
  if (cbInit(v10, transferBufferSize))
  {
    Typed = CFAllocatorAllocateTyped(alloc, 176, 0x10600400B962E3FLL, 0);
    *(_OWORD *)Typed = 0u;
    *(_OWORD *)(Typed + 16) = 0u;
    *(_OWORD *)(Typed + 32) = 0u;
    *(_OWORD *)(Typed + 48) = 0u;
    *(_OWORD *)(Typed + 64) = 0u;
    *(_OWORD *)(Typed + 80) = 0u;
    *(_OWORD *)(Typed + 96) = 0u;
    *(_OWORD *)(Typed + 112) = 0u;
    *(_OWORD *)(Typed + 128) = 0u;
    *(_OWORD *)(Typed + 144) = 0u;
    *(_OWORD *)(Typed + 160) = 0u;
    *(void ***)(Typed + 96) = v10[0];
    *(_QWORD *)(Typed + 88) = alloc;
    pthread_mutex_init((pthread_mutex_t *)(Typed + 104), 0);
    *(_QWORD *)(Typed + 168) = transferBufferSize;
    *(_QWORD *)(Typed + 24) = CFSTR("_kCFBoundPairReadPrivateRunLoopMode");
    *(_QWORD *)(Typed + 8) = CFRunLoopSourceCreate(alloc, 0, &_emptySourceCtxt);
    *(_QWORD *)(Typed + 72) = CFSTR("_kCFBoundPairWritePrivateRunLoopMode");
    *(_QWORD *)(Typed + 56) = CFRunLoopSourceCreate(alloc, 0, &_emptySourceCtxt);
    CFReadStreamCreate((__objc2_class **)alloc, (uint64_t)&boundPairReadCallBacks, Typed);
    CFWriteStreamCreate((__objc2_class **)alloc, boundPairWriteCallBacks, Typed);
    v9 = *(__CFReadStream **)(Typed + 32);
    if (v9 && *(_QWORD *)(Typed + 80))
    {
      if (readStream)
        *readStream = v9;
      if (writeStream)
        *writeStream = *(CFWriteStreamRef *)(Typed + 80);
    }
    else
    {
      boundPairCommonFinalize(Typed);
    }
  }
}

_QWORD *CFReadStreamCreate(__objc2_class **a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t Typed;
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t);
  _QWORD *v12;
  uint64_t (*v13)(_QWORD *, uint64_t);
  uint64_t v14;

  _CFStreamCreate(a1, 1);
  v7 = v6;
  if (v6)
  {
    Typed = CFAllocatorAllocateTyped(a1, 136, 0x108004021366E3ELL, 0);
    if (Typed)
    {
      v9 = Typed;
      if (*(_QWORD *)a2 == 1)
      {
        v13 = *(uint64_t (**)(_QWORD *, uint64_t))(a2 + 8);
        if (v13)
        {
          a3 = v13(v7, a3);
          v13 = *(uint64_t (**)(_QWORD *, uint64_t))(a2 + 8);
        }
        v7[5] = a3;
        v14 = 1;
      }
      else
      {
        if (!*(_QWORD *)a2)
        {
          v10 = *(_QWORD *)(a3 + 8);
          v11 = *(uint64_t (**)(uint64_t))(a3 + 16);
          if (v11)
          {
            v10 = v11(v10);
            v11 = *(uint64_t (**)(uint64_t))(a3 + 16);
          }
          v7[5] = v10;
          *(_QWORD *)v9 = 0;
          *(_QWORD *)(v9 + 8) = v11;
          *(_OWORD *)(v9 + 16) = *(_OWORD *)(a3 + 24);
          *(_OWORD *)(v9 + 32) = *(_OWORD *)(a2 + 8);
          *(_OWORD *)(v9 + 48) = *(_OWORD *)(a2 + 24);
          *(_QWORD *)(v9 + 64) = *(_QWORD *)(a2 + 40);
          *(_QWORD *)(v9 + 72) = 0;
          *(_QWORD *)(v9 + 80) = 0;
          *(_OWORD *)(v9 + 88) = *(_OWORD *)(a2 + 48);
          *(_QWORD *)(v9 + 104) = 0;
          *(_QWORD *)(v9 + 112) = 0;
          *(_QWORD *)(v9 + 120) = *(_QWORD *)(a2 + 64);
          v12 = (_QWORD *)(a2 + 72);
          goto LABEL_16;
        }
        v13 = *(uint64_t (**)(_QWORD *, uint64_t))(a2 + 8);
        if (v13)
        {
          a3 = v13(v7, a3);
          v13 = *(uint64_t (**)(_QWORD *, uint64_t))(a2 + 8);
        }
        v7[5] = a3;
        v14 = 2;
      }
      *(_QWORD *)v9 = v14;
      *(_QWORD *)(v9 + 8) = v13;
      *(_OWORD *)(v9 + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(v9 + 32) = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(v9 + 48) = *(_OWORD *)(a2 + 48);
      *(_QWORD *)(v9 + 64) = *(_QWORD *)(a2 + 64);
      *(_QWORD *)(v9 + 72) = 0;
      *(_QWORD *)(v9 + 80) = 0;
      *(_OWORD *)(v9 + 88) = *(_OWORD *)(a2 + 72);
      *(_OWORD *)(v9 + 104) = *(_OWORD *)(a2 + 88);
      *(_QWORD *)(v9 + 120) = *(_QWORD *)(a2 + 104);
      v12 = (_QWORD *)(a2 + 112);
LABEL_16:
      *(_QWORD *)(v9 + 128) = *v12;
      v7[6] = v9;
      return v7;
    }
    CFRelease(v7);
    return 0;
  }
  return v7;
}

_QWORD *CFWriteStreamCreate(__objc2_class **a1, uint64_t *a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *Typed;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  _QWORD *v13;
  uint64_t (*v14)(_QWORD *, uint64_t);

  _CFStreamCreate(a1, 0);
  v7 = v6;
  if (v6)
  {
    Typed = (_QWORD *)CFAllocatorAllocateTyped(a1, 136, 0x108004021366E3ELL, 0);
    if (Typed)
    {
      v9 = Typed;
      v10 = *a2;
      if (*a2 == 1 || v10)
      {
        *Typed = v10;
        v14 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
        if (v14)
        {
          a3 = v14(v7, a3);
          v14 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
        }
        v7[5] = a3;
        v9[1] = v14;
        *((_OWORD *)v9 + 1) = *((_OWORD *)a2 + 1);
        *((_OWORD *)v9 + 2) = *((_OWORD *)a2 + 2);
        v9[7] = 0;
        v9[8] = 0;
        v9[6] = 0;
        *(_OWORD *)(v9 + 9) = *((_OWORD *)a2 + 3);
        *(_OWORD *)(v9 + 11) = *((_OWORD *)a2 + 4);
        *(_OWORD *)(v9 + 13) = *((_OWORD *)a2 + 5);
        v9[15] = a2[12];
        v13 = a2 + 13;
      }
      else
      {
        v11 = *(_QWORD *)(a3 + 8);
        v12 = *(uint64_t (**)(uint64_t))(a3 + 16);
        if (v12)
        {
          v11 = v12(v11);
          v12 = *(uint64_t (**)(uint64_t))(a3 + 16);
        }
        v7[5] = v11;
        *v9 = 0;
        v9[1] = v12;
        *((_OWORD *)v9 + 1) = *(_OWORD *)(a3 + 24);
        *((_OWORD *)v9 + 2) = *(_OWORD *)(a2 + 1);
        v9[7] = 0;
        v9[8] = 0;
        v9[6] = 0;
        *(_OWORD *)(v9 + 9) = *(_OWORD *)(a2 + 3);
        *(_OWORD *)(v9 + 11) = *(_OWORD *)(a2 + 5);
        v9[13] = 0;
        v9[14] = 0;
        v9[15] = a2[7];
        v13 = a2 + 8;
      }
      v9[16] = *v13;
      v7[6] = v9;
    }
    else
    {
      CFRelease(v7);
      return 0;
    }
  }
  return v7;
}

uint64_t cbInit(void ***a1, unsigned int a2)
{
  uint64_t result;
  void **v5;
  void *v6;
  void **v7;
  void **v8;

  result = (uint64_t)malloc_type_malloc(0x68uLL, 0x10500408CE9FA50uLL);
  *a1 = (void **)result;
  if (result)
  {
    **a1 = malloc_type_malloc(a2, 0x91765FA5uLL);
    v5 = *a1;
    v6 = **a1;
    if (!v6)
    {
LABEL_5:
      free(v5);
      result = 0;
      *a1 = 0;
      return result;
    }
    v5[1] = v6;
    (*a1)[2] = **a1;
    v7 = *a1;
    *((_DWORD *)v7 + 8) = a2;
    *((_DWORD *)v7 + 9) = a2;
    v7[3] = (char *)*v7 + a2;
    if (pthread_mutex_init((pthread_mutex_t *)(*a1 + 5), 0))
    {
      free(**a1);
      **a1 = 0;
      (*a1)[1] = 0;
      (*a1)[2] = 0;
      v8 = *a1;
      v8[3] = 0;
      v8[4] = 0;
      v5 = *a1;
      goto LABEL_5;
    }
    return 1;
  }
  return result;
}

uint64_t boundPairWriteCreate(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(a2 + 80) = a1;
  return a2;
}

uint64_t boundPairReadCreate(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(a2 + 32) = a1;
  return a2;
}

xpc_object_t createErrorReply(const char *a1, xpc_object_t original)
{
  xpc_object_t reply;

  reply = xpc_dictionary_create_reply(original);
  if (!reply)
    reply = xpc_dictionary_create(0, 0, 0);
  populateErrorReply(a1, reply, 1u);
  return reply;
}

void populateErrorReply(const char *a1, xpc_object_t xdict, unsigned int a3)
{
  if (!xdict)
    populateErrorReply_cold_1();
  xpc_dictionary_set_value(xdict, "CFPreferencesPropertyList", 0);
  xpc_dictionary_set_string(xdict, "CFPreferencesErrorDescription", a1);
  xpc_dictionary_set_int64(xdict, "CFPreferencesErrorType", a3);
}

void _CFPrefsResetPreferences(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  os_activity_scope_state_s state;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = _os_activity_create(&dword_182A8C000, "Resetting CFPreferences/NSUserDefaults", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v2, &state);
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v3 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v3 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  objc_msgSend(v3, "resetPreferences:", a1);

  os_activity_scope_leave(&state);
}

void sub_182B94898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_182B94968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class _CFRuntimeInitStaticInstance(Class result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  Class v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  objc_class **v13;
  int v14;
  uint64_t v15;
  objc_class *v16;
  uint64_t (*v17)(Class);

  v8 = result;
  if (a2 > 0x47)
  {
    v10 = a2 - 72;
    if ((int)a2 - 72 >= dword_1ECCFAFE8)
      goto LABEL_19;
    v11 = __CFRuntimeClassTables[v10 >> 6];
    if (!v11)
      goto LABEL_19;
    v9 = (uint64_t *)(v11 + 8 * (v10 & 0x3F));
  }
  else
  {
    v9 = (uint64_t *)(&__CFRuntimeBuiltinClassTable + a2);
  }
  v12 = *v9;
  if (!*v9)
  {
LABEL_19:
    __break(1u);
    return result;
  }
  if ((*(_BYTE *)v12 & 8) != 0)
    return (Class)CFLog(3, (uint64_t)CFSTR("*** Cannot initialize a static instance to a class (%s) with custom ref counting"), a3, a4, a5, a6, a7, a8, *(_QWORD *)(v12 + 8));
  atomic_store(((_DWORD)a2 << 8) | 0x80, (unint64_t *)result + 1);
  *(_QWORD *)result = 0;
  if (a2 <= 0x47)
  {
    v13 = (objc_class **)&__CFRuntimeBuiltinObjCClassTable[a2];
LABEL_14:
    v16 = *v13;
    goto LABEL_16;
  }
  v14 = a2 - 72;
  if ((int)a2 - 72 < dword_1ECCFAFE8)
  {
    v15 = __CFRuntimeClassTables[(v14 >> 6) + 16];
    if (v15)
    {
      v13 = (objc_class **)(v15 + 8 * (v14 & 0x3F));
      goto LABEL_14;
    }
  }
  v16 = 0;
LABEL_16:
  result = object_setClass(result, v16);
  v17 = *(uint64_t (**)(Class))(v12 + 16);
  if (v17)
    return (Class)v17(v8);
  return result;
}

CFIndex CFDictionaryGetCountOfValue(CFDictionaryRef theDict, const void *value)
{
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
    return -[__CFDictionary countForObject:](theDict, "countForObject:", value);
  else
    return CFBasicHashGetCountOfValue((uint64_t)theDict, (unint64_t)value);
}

const char *_CFURLCStringIsPromiseName(const char *__s)
{
  const char *v1;
  size_t v2;

  if (__s)
  {
    v1 = __s;
    if (*__s == 46 && (v2 = strlen(__s), v2 >= 7))
      return (const char *)(*(_DWORD *)&v1[v2 - 7] == 1818454318 && *(_DWORD *)&v1[v2 - 4] == 1685417836);
    else
      return 0;
  }
  return __s;
}

void __CFStringGetLineOrParagraphBounds(CFStringRef theString, uint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5, uint64_t *a6, int a7)
{
  char v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char **p_data;
  char *v19;
  uint64_t length;
  uint64_t v21;
  const __CFString *CharactersPtr;
  char *v23;
  int v24;
  uint64_t *p_info;
  char v26;
  char v27;
  uint64_t v28;
  char v29;
  char **v30;
  char *v31;
  char v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  UniChar v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  UniChar *v40;
  uint64_t v41;
  UniChar v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  UniChar v46;
  BOOL v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  CFRange v53;
  uint64_t v54;
  BOOL v55;
  const __CFString *v57;
  char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  UniChar v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  int64_t v69;
  uint64_t v70;
  UniChar *v71;
  UniChar v72;
  uint64_t *v73;
  char v74;
  char v75;
  char v76;
  char **v77;
  char *v78;
  char v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  UniChar v84;
  BOOL v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t *v89;
  uint64_t v90;
  UniChar buffer[8];
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  CFStringRef theStringa[2];
  __int128 v100;
  __int128 v101;
  uint64_t v102;
  uint64_t v103;
  CFRange v104;
  CFRange v105;
  CFRange v106;
  CFRange v107;
  CFRange v108;
  CFRange v109;

  v103 = *MEMORY[0x1E0C80C00];
  v102 = 0;
  v100 = 0u;
  v101 = 0u;
  v98 = 0u;
  *(_OWORD *)theStringa = 0u;
  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  v92 = 0u;
  v93 = 0u;
  *(_OWORD *)buffer = 0u;
  v14 = atomic_load((unint64_t *)&theString->info);
  v15 = v14 & 5;
  v16 = atomic_load((unint64_t *)&theString->info);
  v17 = v16 & 0x60;
  if (v15 == 4)
  {
    p_data = &theString->data;
    if (v17)
    {
      v19 = *p_data;
    }
    else
    {
      v21 = atomic_load((unint64_t *)&theString->info);
      v19 = (char *)&p_data[(v21 & 5) != 4];
    }
    length = *v19;
    if (!a4)
      goto LABEL_87;
  }
  else if ((v16 & 0x60) != 0)
  {
    length = theString->length;
    if (!a4)
      goto LABEL_87;
  }
  else
  {
    length = (uint64_t)theString->data;
    if (!a4)
      goto LABEL_87;
  }
  if (!a2)
  {
    v28 = 0;
    goto LABEL_86;
  }
  theStringa[0] = theString;
  *((_QWORD *)&v100 + 1) = 0;
  *(_QWORD *)&v101 = length;
  CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(theString);
  v23 = 0;
  theStringa[1] = CharactersPtr;
  if (!CharactersPtr)
  {
    v24 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      v24 = __CFDefaultEightBitStringEncoding;
    }
    if (v24 != 1536)
    {
      if (v24 == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        v24 = __CFDefaultEightBitStringEncoding;
      }
      if (v24 != 1536)
        goto LABEL_21;
    }
    p_info = &theString->info;
    v26 = atomic_load((unint64_t *)&theString->info);
    if ((v26 & 0x10) == 0 || (v27 = atomic_load((unint64_t *)p_info), (v27 & 8) != 0))
    {
      v29 = atomic_load((unint64_t *)p_info);
      v30 = &theString->data;
      if ((v29 & 0x60) != 0)
      {
        v31 = *v30;
      }
      else
      {
        v32 = atomic_load((unint64_t *)&theString->info);
        v31 = (char *)&v30[(v32 & 5) != 4];
      }
      v33 = atomic_load((unint64_t *)&theString->info);
      v23 = &v31[(v33 >> 2) & 1];
    }
    else
    {
LABEL_21:
      v23 = 0;
    }
  }
  *((_QWORD *)&v101 + 1) = 0;
  v102 = 0;
  *(_QWORD *)&v100 = v23;
  v90 = length;
  if ((a2 & 0x8000000000000000) == 0)
  {
    v34 = v101;
    if ((uint64_t)v101 > a2)
    {
      if (theStringa[1])
      {
        v35 = 0;
        v36 = *((_WORD *)&theStringa[1]->isa + *((_QWORD *)&v100 + 1) + a2);
      }
      else if (v23)
      {
        v35 = 0;
        v36 = v23[*((_QWORD *)&v100 + 1) + a2];
      }
      else
      {
        v38 = a2 - 4;
        if ((unint64_t)a2 < 4)
          v38 = 0;
        if (v38 + 64 < (uint64_t)v101)
          v34 = v38 + 64;
        *((_QWORD *)&v101 + 1) = v38;
        v102 = v34;
        v104.location = *((_QWORD *)&v100 + 1) + v38;
        v104.length = v34 - v38;
        CFStringGetCharacters(theStringa[0], v104, buffer);
        v35 = *((_QWORD *)&v101 + 1);
        v36 = buffer[a2 - *((_QWORD *)&v101 + 1)];
      }
      v37 = a2 - 1;
      if (v36 != 10)
        goto LABEL_49;
      v39 = v101;
      if ((uint64_t)v101 < a2)
        goto LABEL_49;
      v40 = (UniChar *)theStringa[1];
      if (theStringa[1])
      {
        v41 = *((_QWORD *)&v100 + 1) + v37;
      }
      else
      {
        if ((_QWORD)v100)
        {
          v42 = *(char *)(v100 + *((_QWORD *)&v100 + 1) + v37);
          goto LABEL_47;
        }
        if (v102 < a2 || v35 >= a2)
        {
          v86 = a2 - 5;
          if ((unint64_t)a2 < 5)
            v86 = 0;
          if (v86 + 64 < (uint64_t)v101)
            v39 = v86 + 64;
          *((_QWORD *)&v101 + 1) = v86;
          v102 = v39;
          v107.location = *((_QWORD *)&v100 + 1) + v86;
          v107.length = v39 - v86;
          CFStringGetCharacters(theStringa[0], v107, buffer);
          v35 = *((_QWORD *)&v101 + 1);
        }
        v41 = v37 - v35;
        v40 = buffer;
      }
      v42 = v40[v41];
LABEL_47:
      if (v42 != 13)
        goto LABEL_49;
      v37 = a2 - 2;
      if (((a2 - 2) & 0x8000000000000000) == 0)
        goto LABEL_49;
LABEL_32:
      v28 = 0;
      length = v90;
      goto LABEL_86;
    }
  }
  v35 = 0;
  v37 = a2 - 1;
  if (a2 - 1 < 0)
    goto LABEL_32;
LABEL_49:
  v89 = a6;
  v43 = -v37;
  v44 = v37 + 64;
  while (1)
  {
    if ((unint64_t)v37 >= 4)
      v45 = 4;
    else
      v45 = v37;
    if ((uint64_t)v101 <= v37)
    {
      v46 = 0;
      goto LABEL_78;
    }
    if (theStringa[1])
    {
      v46 = *((_WORD *)&theStringa[1]->isa + v37 + *((_QWORD *)&v100 + 1));
    }
    else if ((_QWORD)v100)
    {
      v46 = *(char *)(v100 + *((_QWORD *)&v100 + 1) + v37);
    }
    else
    {
      v47 = v102 > v37 && v35 <= v37;
      if (!v47)
      {
        v48 = -v45;
        v49 = v45 + v43;
        v50 = v44 - v45;
        v51 = v37 + v48;
        v52 = v51 + 64;
        if (v51 + 64 >= (uint64_t)v101)
          v52 = v101;
        *((_QWORD *)&v101 + 1) = v51;
        v102 = v52;
        v53.location = v51 + *((_QWORD *)&v100 + 1);
        if ((uint64_t)v101 >= v50)
          v54 = v50;
        else
          v54 = v101;
        v53.length = v54 + v49;
        CFStringGetCharacters(theStringa[0], v53, buffer);
        v35 = *((_QWORD *)&v101 + 1);
      }
      v46 = buffer[v37 - v35];
    }
    if ((unsigned __int16)(v46 - 14) < 0x77u)
      goto LABEL_81;
    v55 = v46 == 10 || v46 == 13;
    if (v55 || v46 == 8233)
      break;
LABEL_78:
    if (a7 && (v46 == 8232 || v46 == 133))
      break;
LABEL_81:
    ++v43;
    --v44;
    v47 = v37-- <= 0;
    if (v47)
    {
      v28 = 0;
      goto LABEL_85;
    }
  }
  v28 = v37 + 1;
LABEL_85:
  a6 = v89;
  length = v90;
LABEL_86:
  *a4 = v28;
LABEL_87:
  if (!(a5 | (unint64_t)a6))
    return;
  theStringa[0] = theString;
  *((_QWORD *)&v100 + 1) = 0;
  *(_QWORD *)&v101 = length;
  v57 = (const __CFString *)CFStringGetCharactersPtr(theString);
  v58 = 0;
  theStringa[1] = v57;
  if (!v57)
  {
    v67 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      v67 = __CFDefaultEightBitStringEncoding;
    }
    if (v67 == 1536)
    {
      if (!theString)
        goto LABEL_142;
    }
    else
    {
      if (v67 == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        v67 = __CFDefaultEightBitStringEncoding;
      }
      v58 = 0;
      if (!theString || v67 != 1536)
        goto LABEL_89;
    }
    v73 = &theString->info;
    v74 = atomic_load((unint64_t *)&theString->info);
    if ((v74 & 0x10) == 0 || (v75 = atomic_load((unint64_t *)v73), (v75 & 8) != 0))
    {
      v76 = atomic_load((unint64_t *)v73);
      v77 = &theString->data;
      if ((v76 & 0x60) != 0)
      {
        v78 = *v77;
      }
      else
      {
        v79 = atomic_load((unint64_t *)&theString->info);
        v78 = (char *)&v77[(v79 & 5) != 4];
      }
      v80 = atomic_load((unint64_t *)&theString->info);
      v58 = &v78[(v80 >> 2) & 1];
      goto LABEL_89;
    }
LABEL_142:
    v58 = 0;
  }
LABEL_89:
  *((_QWORD *)&v101 + 1) = 0;
  v102 = 0;
  *(_QWORD *)&v100 = v58;
  v59 = a2 + a3 - (a3 != 0);
  if (v59 < 0 || (v60 = v101, (uint64_t)v101 <= v59))
  {
    v61 = 0;
    v62 = -1;
  }
  else
  {
    if (theStringa[1])
    {
      v61 = 0;
      v62 = *((_WORD *)&theStringa[1]->isa + *((_QWORD *)&v100 + 1) + v59);
    }
    else if (v58)
    {
      v61 = 0;
      v62 = v58[*((_QWORD *)&v100 + 1) + v59];
    }
    else
    {
      v81 = v59 - 4;
      if ((unint64_t)v59 < 4)
        v81 = 0;
      if (v81 + 64 < (uint64_t)v101)
        v60 = v81 + 64;
      *((_QWORD *)&v101 + 1) = v81;
      v102 = v60;
      v106.location = *((_QWORD *)&v100 + 1) + v81;
      v106.length = v60 - v81;
      CFStringGetCharacters(theStringa[0], v106, buffer);
      v61 = *((_QWORD *)&v101 + 1);
      v62 = buffer[v59 - *((_QWORD *)&v101 + 1)];
    }
    if (v62 == 10)
    {
      v82 = v59 - 1;
      if (v59 && (v83 = v101, (uint64_t)v101 >= v59))
      {
        if (theStringa[1])
        {
          v84 = *((_WORD *)&theStringa[1]->isa + *((_QWORD *)&v100 + 1) + v82);
        }
        else if ((_QWORD)v100)
        {
          v84 = *(char *)(v100 + *((_QWORD *)&v100 + 1) + v82);
        }
        else
        {
          if (v102 < v59 || v61 >= v59)
          {
            v87 = v59 - 5;
            if ((unint64_t)v59 < 5)
              v87 = 0;
            if (v87 + 64 < (uint64_t)v101)
              v83 = v87 + 64;
            *((_QWORD *)&v101 + 1) = v87;
            v102 = v83;
            v108.location = *((_QWORD *)&v100 + 1) + v87;
            v108.length = v83 - v87;
            CFStringGetCharacters(theStringa[0], v108, buffer);
            v61 = *((_QWORD *)&v101 + 1);
          }
          v84 = buffer[v82 - v61];
        }
      }
      else
      {
        v84 = -1;
      }
      v85 = v84 == 13;
      if (v84 == 13)
        v64 = v59 - 1;
      else
        v64 = a2 + a3 - (a3 != 0);
LABEL_184:
      v68 = 1;
      if (v85)
        v68 = 2;
      if (a6)
        goto LABEL_135;
      goto LABEL_136;
    }
  }
  if (length <= v59)
    v63 = a2 + a3 - (a3 != 0);
  else
    v63 = length;
  while (2)
  {
    v64 = v59;
    if ((unsigned __int16)(v62 - 14) < 0x77u)
    {
LABEL_104:
      if (v63 == v59)
      {
        v68 = 0;
        v64 = length;
        if (a6)
          goto LABEL_135;
        goto LABEL_136;
      }
      ++v59;
      v62 = -1;
      if (v64 >= -1 && (uint64_t)v101 > v59)
      {
        if (theStringa[1])
        {
          v62 = *((_WORD *)&theStringa[1]->isa + *((_QWORD *)&v100 + 1) + v64 + 1);
        }
        else if ((_QWORD)v100)
        {
          v62 = *(char *)(v100 + *((_QWORD *)&v100 + 1) + 1 + v64);
        }
        else
        {
          v59 = v64 + 1;
          if (v102 <= v64 + 1 || v61 > v59)
          {
            v65 = v64 - 3;
            if ((unint64_t)v59 < 4)
              v65 = 0;
            v66 = v65 + 64;
            if (v65 + 64 >= (uint64_t)v101)
              v66 = v101;
            *((_QWORD *)&v101 + 1) = v65;
            v102 = v66;
            v105.location = *((_QWORD *)&v100 + 1) + v65;
            v105.length = v66 - v65;
            CFStringGetCharacters(theStringa[0], v105, buffer);
            v61 = *((_QWORD *)&v101 + 1);
          }
          v62 = buffer[v64 + 1 - v61];
        }
      }
      continue;
    }
    break;
  }
  if (v62 == 10)
    goto LABEL_134;
  if (v62 != 13)
  {
    if (v62 == 8233 || a7 && (v62 == 133 || v62 == 8232))
      goto LABEL_134;
    goto LABEL_104;
  }
  if (v59 >= -1)
  {
    v69 = v59 + 1;
    v70 = v101;
    if ((uint64_t)v101 > v59 + 1)
    {
      if (theStringa[1])
      {
        v71 = (UniChar *)theStringa[1] + *((_QWORD *)&v100 + 1) + v59;
        goto LABEL_133;
      }
      if ((_QWORD)v100)
      {
        v72 = *(char *)(v100 + *((_QWORD *)&v100 + 1) + v59 + 1);
      }
      else
      {
        if (v102 <= v69 || v61 > v69)
        {
          v88 = v59 - 3;
          if ((unint64_t)v69 < 4)
            v88 = 0;
          if (v88 + 64 < (uint64_t)v101)
            v70 = v88 + 64;
          *((_QWORD *)&v101 + 1) = v88;
          v102 = v70;
          v109.location = *((_QWORD *)&v100 + 1) + v88;
          v109.length = v70 - v88;
          CFStringGetCharacters(theStringa[0], v109, buffer);
          v61 = *((_QWORD *)&v101 + 1);
        }
        v71 = &buffer[v59 - v61];
LABEL_133:
        v72 = v71[1];
      }
      v85 = v72 == 10;
      goto LABEL_184;
    }
  }
LABEL_134:
  v68 = 1;
  if (!a6)
    goto LABEL_136;
LABEL_135:
  *a6 = v64;
LABEL_136:
  if (a5)
    *(_QWORD *)a5 = v68 + v64;
}

void CFStorageInsertValues(uint64_t cf, uint64_t a2, uint64_t a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CFAllocatorRef v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t Node;
  uint64_t v15;
  BOOL v16;

  v4 = *(_DWORD *)(cf + 24);
  if (v4 == -1)
  {
    v7 = *(_QWORD *)(cf + 16);
    v5 = v7 * a3;
    v6 = v7 * a2;
  }
  else
  {
    v5 = a3 << v4;
    v6 = a2 << v4;
  }
  v8 = CFGetAllocator((CFTypeRef)cf);
  if (v5 >= 1)
  {
    v9 = (uint64_t)v8;
    v10 = *(_QWORD *)(cf + 136);
    do
    {
      if (v5 >= v10)
        v11 = v10;
      else
        v11 = v5;
      __CFStorageInsertUnfrozen(v9, cf, cf + 144, v6, v11, v6);
      if (v12)
      {
        v13 = v12;
        Node = __CFStorageCreateNode(v9, cf, *(_BYTE *)(cf + 157), *(_QWORD *)(cf + 144));
        v15 = *(_QWORD *)(cf + 176);
        *(_OWORD *)(Node + 16) = *(_OWORD *)(cf + 160);
        *(_QWORD *)(Node + 32) = v15;
        if (*(_BYTE *)(cf + 157))
        {
          os_unfair_lock_lock_with_options();
          *(_QWORD *)(cf + 104) = 0;
          *(_QWORD *)(cf + 112) = 0;
          *(_QWORD *)(cf + 120) = 0;
          os_unfair_lock_unlock((os_unfair_lock_t)(cf + 128));
          *(_BYTE *)(cf + 157) = 0;
        }
        *(_QWORD *)(cf + 160) = Node;
        *(_QWORD *)(cf + 168) = v13;
        *(_QWORD *)(cf + 176) = 0;
        *(_QWORD *)(cf + 144) = *v13 + *(_QWORD *)Node;
      }
      v6 += v11;
      v16 = v5 <= v11;
      v5 -= v11;
    }
    while (!v16);
  }
}

uint64_t __CFStorageInsertUnfrozen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int64_t v46;
  BOOL v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int64_t v55;
  uint64_t v56;
  uint64_t inserted;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int *v61;
  unsigned int v62;
  unsigned int v63;
  _QWORD *Node;
  uint64_t v65;
  _QWORD *v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  int64_t v76;
  uint64_t v77;
  os_unfair_lock_s *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  int64_t v86;
  int64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  int64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  uint64_t v103;

  if (!*(_BYTE *)(a3 + 13))
  {
    v22 = a4 - 1;
    v24 = a3 + 16;
    v23 = *(_QWORD *)(a3 + 16);
    v25 = *(_QWORD *)v23;
    if (*(_QWORD *)v23 < a4)
    {
      v22 -= v25;
      v23 = *(_QWORD *)(a3 + 24);
      v26 = v22 - *(_QWORD *)v23;
      if (v22 >= *(_QWORD *)v23)
      {
        v23 = *(_QWORD *)(a3 + 32);
        v32 = 2;
        v22 = v26;
      }
      else
      {
        v32 = 1;
      }
    }
    else
    {
      v32 = 0;
    }
    v55 = v22 + 1;
    if (*(_BYTE *)(v23 + 12))
    {
      if (*(_DWORD *)(v23 + 8) != 1)
      {
        v56 = a1;
        inserted = __CFStorageInsertFrozen(a1, a2, v23, v55, a5, a6);
LABEL_49:
        v59 = inserted;
        v60 = v58;
        if (v23 != inserted)
        {
          v61 = (unsigned int *)(v23 + 8);
          if (*(_DWORD *)(v23 + 8))
          {
            do
            {
              v62 = __ldxr(v61);
              v63 = v62 - 1;
            }
            while (__stxr(v63, v61));
            if (!v63)
              __CFStorageDeallocateNode((const void *)a2, v23);
          }
          *(_QWORD *)(v24 + 8 * v32) = v59;
        }
        if (v60)
        {
          if (*(_QWORD *)(a3 + 32))
          {
            Node = (_QWORD *)__CFStorageCreateNode(v56, a2, 0, 0);
            if (v32 == 1)
            {
              Node[2] = v60;
              Node[3] = *(_QWORD *)(a3 + 32);
            }
            else if (v32)
            {
              Node[2] = *(_QWORD *)(a3 + 32);
              Node[3] = v60;
            }
            else
            {
              Node[2] = *(_QWORD *)(a3 + 24);
              Node[3] = *(_QWORD *)(a3 + 32);
              *(_QWORD *)(a3 + 24) = v60;
            }
            *(_QWORD *)(a3 + 32) = 0;
            *(_QWORD *)a3 = **(_QWORD **)(a3 + 24) + **(_QWORD **)(a3 + 16);
            *Node = *(_QWORD *)Node[3] + *(_QWORD *)Node[2];
            return a3;
          }
          if (v25 >= a4)
            *(_QWORD *)(a3 + 32) = *(_QWORD *)(a3 + 24);
          *(_QWORD *)(v24 + 8 * v32 + 8) = v60;
        }
        v65 = *(_QWORD *)a3 + a5;
LABEL_65:
        *(_QWORD *)a3 = v65;
        return a3;
      }
      *(_BYTE *)(v23 + 12) = 0;
    }
    v56 = a1;
    inserted = __CFStorageInsertUnfrozen(a1, a2, v23, v55, a5, a6);
    goto LABEL_49;
  }
  v12 = *(_QWORD *)a3;
  v13 = *(_QWORD *)a3 + a5;
  v14 = *(_QWORD *)(a2 + 136);
  if (v13 > v14)
  {
    v15 = v12 - a4;
    if (!v15)
    {
      v16 = (uint64_t *)__CFStorageCreateNode(a1, a2, 1, a5);
      v17 = v16;
      if (v16)
      {
        v18 = *v16;
        v19 = *(_DWORD *)(a2 + 24);
        if (v19 == -1)
        {
          v77 = *(_QWORD *)(a2 + 16);
          v20 = a6 / v77;
          v21 = v18 / v77;
        }
        else
        {
          v20 = a6 >> v19;
          v21 = v18 >> v19;
        }
      }
      else
      {
        v20 = 0;
        v21 = 0;
      }
      v78 = (os_unfair_lock_s *)(a2 + 128);
      os_unfair_lock_lock_with_options();
      *(_QWORD *)(a2 + 104) = v17;
      goto LABEL_141;
    }
    if (a4)
    {
      v33 = a5 + a4;
      if (a5 + a4 > v14)
      {
        v35 = __CFStorageCreateNode(a1, a2, 1, v13 - v14);
        v36 = v35;
        v37 = *(_QWORD *)(a3 + 24);
        if (v37)
        {
          v38 = *(_QWORD *)a3;
          v39 = *(_QWORD *)(a2 + 136);
          v40 = *(_QWORD *)a3 + a5 - v39;
          v41 = (uint64_t *)MEMORY[0x1E0C85AD8];
          v42 = *MEMORY[0x1E0C85AD8];
          if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
            v43 = *MEMORY[0x1E0C85AD8];
          else
            v43 = v42 + 1;
          v44 = a1;
          if (v40 <= v43 >> 1)
          {
            v80 = v40 + 63;
            v47 = v40 < -63;
            v81 = v40 + 126;
            if (!v47)
              v81 = v80;
            v46 = v81 & 0xFFFFFFFFFFFFFFC0;
          }
          else
          {
            v45 = (v40 + v42 - 1) & -(int)v42;
            if (v39 >= v45)
              v46 = v45;
            else
              v46 = *(_QWORD *)(a2 + 136);
          }
          if (v46 > *(_QWORD *)(v35 + 16))
          {
            pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
            if (v46 > *(_QWORD *)(v36 + 16))
            {
              *(_QWORD *)(v36 + 24) = __CFSafelyReallocateWithAllocatorTyped(v44, *(_QWORD *)(v36 + 24), v46, 1893177561, 0, 0);
              if (__CFOASafe)
                __CFSetLastAllocationEventName();
              *(_QWORD *)(v36 + 16) = v46;
            }
            pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
            v39 = *(_QWORD *)(a2 + 136);
            v37 = *(_QWORD *)(a3 + 24);
            v38 = *(_QWORD *)a3;
          }
          memmove((void *)(*(_QWORD *)(v36 + 24) + a4 + a5 - v39), (const void *)(v37 + a4), v38 - a4);
          v82 = *(_QWORD *)(a2 + 136);
          v83 = *v41;
          if (*v41 >= 0)
            v84 = *v41;
          else
            v84 = v83 + 1;
          if (v82 <= v84 >> 1)
          {
            v92 = v82 + 63;
            v47 = v82 < -63;
            v93 = v82 + 126;
            if (!v47)
              v93 = v92;
            v86 = v93 & 0xFFFFFFFFFFFFFFC0;
          }
          else
          {
            v85 = (v82 + v83 - 1) & -(int)v83;
            if (v82 >= v85)
              v86 = v85;
            else
              v86 = *(_QWORD *)(a2 + 136);
          }
          if (v86 > *(_QWORD *)(a3 + 16))
          {
            pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
            if (v86 > *(_QWORD *)(a3 + 16))
            {
              *(_QWORD *)(a3 + 24) = __CFSafelyReallocateWithAllocatorTyped(v44, *(_QWORD *)(a3 + 24), v86, 1893177561, 0, 0);
              if (__CFOASafe)
                __CFSetLastAllocationEventName();
              *(_QWORD *)(a3 + 16) = v86;
            }
            pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
          }
        }
        v94 = a6 - a4;
        v95 = *(_QWORD *)a3;
        v96 = *(_DWORD *)(a2 + 24);
        if (v96 == -1)
        {
          v99 = *(_QWORD *)(a2 + 16);
          v97 = v94 / v99;
          v98 = v95 / v99;
        }
        else
        {
          v97 = v94 >> v96;
          v98 = v95 >> v96;
        }
        os_unfair_lock_lock_with_options();
        *(_QWORD *)(a2 + 104) = a3;
        *(_QWORD *)(a2 + 112) = v97;
        *(_QWORD *)(a2 + 120) = v98;
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 128));
        v65 = *(_QWORD *)(a2 + 136);
        goto LABEL_65;
      }
      v68 = __CFStorageCreateNode(a1, a2, 1, v15);
      v69 = v68;
      v70 = *(_QWORD *)(a3 + 24);
      if (v70)
      {
        v71 = *(_QWORD *)a3 - a4;
        v72 = (uint64_t *)MEMORY[0x1E0C85AD8];
        v73 = *MEMORY[0x1E0C85AD8];
        if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
          v74 = *MEMORY[0x1E0C85AD8];
        else
          v74 = v73 + 1;
        if (v71 <= v74 >> 1)
        {
          v87 = v71 + 63;
          if (v71 < -63)
            v87 = v71 + 126;
          v76 = v87 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          v75 = (v71 + v73 - 1) & -(int)v73;
          if (*(_QWORD *)(a2 + 136) >= v75)
            v76 = v75;
          else
            v76 = *(_QWORD *)(a2 + 136);
        }
        if (v76 > *(_QWORD *)(v68 + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v76 > *(_QWORD *)(v69 + 16))
          {
            *(_QWORD *)(v69 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(_QWORD *)(v69 + 24), v76, 1893177561, 0, 0);
            if (__CFOASafe)
              __CFSetLastAllocationEventName();
            *(_QWORD *)(v69 + 16) = v76;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
          v70 = *(_QWORD *)(a3 + 24);
          v71 = *(_QWORD *)a3 - a4;
        }
        memmove(*(void **)(v69 + 24), (const void *)(v70 + a4), v71);
        v88 = *v72;
        if (*v72 >= 0)
          v89 = *v72;
        else
          v89 = v88 + 1;
        if (v33 <= v89 >> 1)
        {
          v100 = v33 + 63;
          if (v33 < -63)
            v100 = v33 + 126;
          v91 = v100 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          v90 = (v33 + v88 - 1) & -(int)v88;
          if (*(_QWORD *)(a2 + 136) >= v90)
            v91 = v90;
          else
            v91 = *(_QWORD *)(a2 + 136);
        }
        if (v91 > *(_QWORD *)(a3 + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v91 > *(_QWORD *)(a3 + 16))
          {
            *(_QWORD *)(a3 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(_QWORD *)(a3 + 24), v91, 1893177561, 0, 0);
            if (__CFOASafe)
              __CFSetLastAllocationEventName();
            *(_QWORD *)(a3 + 16) = v91;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        }
      }
      *(_QWORD *)a3 = v33;
      v101 = a6 - a4;
      v102 = *(_DWORD *)(a2 + 24);
      if (v102 == -1)
      {
        v103 = *(_QWORD *)(a2 + 16);
        v20 = v101 / v103;
        v21 = v33 / v103;
      }
      else
      {
        v20 = v101 >> v102;
        v21 = v33 >> v102;
      }
    }
    else
    {
      v66 = (_QWORD *)__CFStorageCreateNode(a1, a2, 1, 0);
      *v66 = *(_QWORD *)a3;
      v66[2] = *(_QWORD *)(a3 + 16);
      v66[3] = *(_QWORD *)(a3 + 24);
      *(_QWORD *)a3 = a5;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v67 = *(_DWORD *)(a2 + 24);
      if (v67 == -1)
      {
        v79 = *(_QWORD *)(a2 + 16);
        v20 = a6 / v79;
        v21 = a5 / v79;
      }
      else
      {
        v20 = a6 >> v67;
        v21 = a5 >> v67;
      }
    }
    v78 = (os_unfair_lock_s *)(a2 + 128);
    os_unfair_lock_lock_with_options();
    *(_QWORD *)(a2 + 104) = a3;
LABEL_141:
    *(_QWORD *)(a2 + 112) = v20;
    *(_QWORD *)(a2 + 120) = v21;
    os_unfair_lock_unlock(v78);
    return a3;
  }
  v27 = *(_QWORD *)(a3 + 24);
  if (v27)
  {
    v28 = *MEMORY[0x1E0C85AD8];
    if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
      v29 = *MEMORY[0x1E0C85AD8];
    else
      v29 = v28 + 1;
    if (v13 <= v29 >> 1)
    {
      v48 = v13 + 63;
      v47 = v13 < -63;
      v49 = v13 + 126;
      if (!v47)
        v49 = v48;
      v31 = v49 & 0xFFFFFFFFFFFFFFC0;
    }
    else
    {
      v30 = (v13 + v28 - 1) & -(int)v28;
      if (v14 >= v30)
        v31 = v30;
      else
        v31 = *(_QWORD *)(a2 + 136);
    }
    if (v31 > *(_QWORD *)(a3 + 16))
    {
      pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
      if (v31 > *(_QWORD *)(a3 + 16))
      {
        *(_QWORD *)(a3 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(_QWORD *)(a3 + 24), v31, 1893177561, 0, 0);
        if (__CFOASafe)
          __CFSetLastAllocationEventName();
        *(_QWORD *)(a3 + 16) = v31;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
      v27 = *(_QWORD *)(a3 + 24);
      v12 = *(_QWORD *)a3;
    }
    memmove((void *)(v27 + a4 + a5), (const void *)(v27 + a4), v12 - a4);
    v13 = *(_QWORD *)a3 + a5;
  }
  *(_QWORD *)a3 = v13;
  v50 = a6 - a4;
  v51 = *(_DWORD *)(a2 + 24);
  if (v51 == -1)
  {
    v54 = *(_QWORD *)(a2 + 16);
    v52 = v50 / v54;
    v53 = v13 / v54;
  }
  else
  {
    v52 = v50 >> v51;
    v53 = v13 >> v51;
  }
  os_unfair_lock_lock_with_options();
  *(_QWORD *)(a2 + 104) = a3;
  *(_QWORD *)(a2 + 112) = v52;
  *(_QWORD *)(a2 + 120) = v53;
  os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 128));
  return a3;
}

CFMutableAttributedStringRef CFAttributedStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFAttributedStringRef aStr)
{
  CFIndex Length;

  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    return (CFMutableAttributedStringRef)-[__CFAttributedString mutableCopy](aStr, "mutableCopy");
  Length = CFStringGetLength(*((CFStringRef *)aStr + 2));
  return __CFAttributedStringCreateMutableWithSubstring(alloc, (CFStringRef *)aStr, 0, Length);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInRange(CFAllocatorRef alloc, CFRange theRange)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFIndex length;
  int location;
  CFCharacterSetRef result;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  unint64_t v24;
  unint64_t v25;
  int v26;

  length = theRange.length;
  location = theRange.location;
  if ((unint64_t)theRange.location >> 16 > 0x10
    || theRange.length >= 1114113
    || theRange.location + theRange.length >= 0x110001uLL)
  {
    result = (CFCharacterSetRef)CFLog(3, (uint64_t)CFSTR("%s: Range (location: %ld, length: %ld) outside of valid Unicode range (0x0 - 0x10FFFF)"), theRange.length, v2, v3, v4, v5, v6, (__int16)"CFCharacterSetRef CFCharacterSetCreateWithCharactersInRange(CFAllocatorRef, CFRange)");
    qword_1EDCD1038 = (uint64_t)"CFCharacterSet range is outside of valid Unicode range (0x0 - 0x10FFFF)";
    __break(1u);
    return result;
  }
  result = (CFCharacterSetRef)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x19uLL, 32, 0);
  if (!length)
  {
    if (!result)
      return result;
    v17 = (unint64_t *)((char *)result + 8);
    v18 = atomic_load((unint64_t *)result + 1);
    while (1)
    {
      v19 = __ldaxr(v17);
      if (v19 != v18)
        break;
      if (__stlxr(v18 & 0xFFFFFFFFFFFFFFFELL, v17))
        goto LABEL_27;
      v20 = 1;
LABEL_28:
      v18 = v19;
      if (v20)
      {
        v21 = atomic_load(v17);
        while (1)
        {
          v22 = __ldaxr(v17);
          if (v22 != v21)
            break;
          if (__stlxr(v21 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v17))
            goto LABEL_34;
          v23 = 1;
LABEL_35:
          v21 = v22;
          if (v23)
          {
            *((_QWORD *)result + 5) = 0;
            *((_QWORD *)result + 2) = 0;
            *((_QWORD *)result + 3) = 0;
            v24 = atomic_load((unint64_t *)result + 1);
            while (1)
            {
              v25 = __ldaxr(v17);
              if (v25 != v24)
                break;
              if (__stlxr(v24 | 4, v17))
                goto LABEL_41;
              v26 = 1;
LABEL_42:
              v24 = v25;
              if (v26)
                return result;
            }
            __clrex();
LABEL_41:
            v26 = 0;
            goto LABEL_42;
          }
        }
        __clrex();
LABEL_34:
        v23 = 0;
        goto LABEL_35;
      }
    }
    __clrex();
LABEL_27:
    v20 = 0;
    goto LABEL_28;
  }
  if (result)
  {
    v10 = (unint64_t *)((char *)result + 8);
    v11 = atomic_load((unint64_t *)result + 1);
    while (1)
    {
      v12 = __ldaxr(v10);
      if (v12 != v11)
        break;
      if (__stlxr(v11 & 0xFFFFFFFFFFFFFFFELL, v10))
        goto LABEL_11;
      v13 = 1;
LABEL_12:
      v11 = v12;
      if (v13)
      {
        v14 = atomic_load(v10);
        while (1)
        {
          v15 = __ldaxr(v10);
          if (v15 != v14)
            break;
          if (__stlxr(v14 & 0xFFFFFFFFFFFFFF8FLL | 0x10, v10))
            goto LABEL_18;
          v16 = 1;
LABEL_19:
          v14 = v15;
          if (v16)
          {
            *((_QWORD *)result + 2) = 0;
            *((_DWORD *)result + 6) = location;
            *((_QWORD *)result + 4) = length;
            *((_QWORD *)result + 5) = 0;
            return result;
          }
        }
        __clrex();
LABEL_18:
        v16 = 0;
        goto LABEL_19;
      }
    }
    __clrex();
LABEL_11:
    v13 = 0;
    goto LABEL_12;
  }
  return result;
}

CFStringEncoding CFStringConvertIANACharSetNameToEncoding(CFStringRef theString)
{
  CFStringEncoding v2;
  const char *CStringPtr;
  CFStringEncoding v4;
  CFStringEncoding result;
  char buffer[100];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding(theString);
    v2 = __CFDefaultEightBitStringEncoding;
  }
  CStringPtr = CFStringGetCStringPtr(theString, v2);
  if (!CStringPtr)
  {
    v4 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(0);
      v4 = __CFDefaultEightBitStringEncoding;
    }
    CStringPtr = buffer;
    if (!CFStringGetCString(theString, buffer, 100, v4))
      return -1;
  }
  result = __CFStringEncodingGetFromCanonicalName(CStringPtr);
  if (result == -1)
  {
    result = __CFStringEncodingGetFromICUName(CStringPtr);
    if (result == -1)
    {
      if (!strncasecmp(CStringPtr, "ms950", 5uLL))
        return __CFStringEncodingGetFromCanonicalName("cp950");
      return -1;
    }
  }
  return result;
}

uint64_t __CFStringEncodingGetFromCanonicalName(const char *a1)
{
  uint64_t i;
  char *v3;
  uint64_t result;
  const __CFDictionary *v5;
  uint64_t v6;
  int v7;
  const char *v8;
  unsigned __int16 v9;
  CFDictionaryKeyCallBacks v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (!strncasecmp_l(a1, "iso-8859-", 9uLL, 0))
  {
    v7 = strtol(a1 + 9, 0, 10);
    if ((v7 - 17) < 0xFFFFFFF0)
      return 0xFFFFFFFFLL;
    else
      return (v7 + 512);
  }
  if (!strncasecmp_l(a1, "cp", 2uLL, 0))
  {
    v8 = a1 + 2;
LABEL_22:
    v9 = strtol(v8, 0, 10);
    return __CFStringEncodingGetFromWindowsCodePage(v9);
  }
  if (!strncasecmp_l(a1, "windows-", 8uLL, 0))
  {
    v8 = a1 + 8;
    goto LABEL_22;
  }
  os_unfair_lock_lock_with_options();
  if (!__CFStringEncodingGetFromCanonicalName_mappingTable)
  {
    memset(&v10, 0, 32);
    *(_OWORD *)&v10.equal = xmmword_1E1334E58;
    __CFStringEncodingGetFromCanonicalName_mappingTable = (uint64_t)CFDictionaryCreateMutable(0, 0, &v10, 0);
    CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-7", (const void *)0x4000100);
    CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-8", (const void *)0x8000100);
    CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-16", (const void *)0x100);
    CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-16be", (const void *)0x10000100);
    CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-16le", (const void *)0x14000100);
    CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-32", (const void *)0xC000100);
    CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-32be", (const void *)0x18000100);
    CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, "utf-32le", (const void *)0x1C000100);
    for (i = 0; i != 98; ++i)
    {
      v3 = __CFCanonicalNameList[i];
      if (v3)
        CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromCanonicalName_mappingTable, v3, (const void *)(unsigned __int16)__CFKnownEncodingList[i]);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringEncodingGetFromCanonicalName_lock);
  result = strncasecmp_l(a1, "macintosh", 9uLL, 0);
  if ((_DWORD)result)
  {
    v5 = (const __CFDictionary *)__CFStringEncodingGetFromCanonicalName_mappingTable;
    if (strncasecmp_l(a1, "x-mac-", 6uLL, 0))
      v6 = 0;
    else
      v6 = 6;
    LODWORD(result) = CFDictionaryGetValue(v5, &a1[v6]);
    if ((_DWORD)result)
      return result;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t __CFStringEncodingGetFromWindowsCodePage(int a1)
{
  uint64_t result;
  uint64_t v3;
  const void *v4[2];

  v4[1] = *(const void **)MEMORY[0x1E0C80C00];
  if (a1 <= 64999)
  {
    if (a1)
    {
      if (a1 == 1200)
      {
        return 256;
      }
      else if (a1 == 1201)
      {
        return 268435712;
      }
      else
      {
LABEL_12:
        if ((a1 - 28591) > 0xF)
        {
          v4[0] = 0;
          os_unfair_lock_lock_with_options();
          if (!__CFStringEncodingGetFromWindowsCodePage_mappingTable)
          {
            v3 = 0;
            __CFStringEncodingGetFromWindowsCodePage_mappingTable = (uint64_t)CFDictionaryCreateMutable(0, 0, 0, 0);
            do
            {
              if (__CFWindowsCPList[v3])
                CFDictionarySetValue((CFMutableDictionaryRef)__CFStringEncodingGetFromWindowsCodePage_mappingTable, (const void *)(unsigned __int16)__CFWindowsCPList[v3], (const void *)(unsigned __int16)__CFKnownEncodingList[v3]);
              ++v3;
            }
            while (v3 != 98);
          }
          os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringEncodingGetFromWindowsCodePage_lock);
          if (CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFStringEncodingGetFromWindowsCodePage_mappingTable, (const void *)a1, v4))
          {
            return LODWORD(v4[0]);
          }
          else
          {
            return 0xFFFFFFFFLL;
          }
        }
        else
        {
          return (a1 - 28078);
        }
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    result = 134217984;
    switch(a1)
    {
      case 65000:
        result = 67109120;
        break;
      case 65001:
        return result;
      case 65005:
        result = 201326848;
        break;
      case 65006:
        result = 402653440;
        break;
      default:
        goto LABEL_12;
    }
  }
  return result;
}

char *CFStorageReplaceValues(char *result, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5;
  char *v7;
  os_unfair_lock_s *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  void *Byte;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  CFAllocatorRef v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  size_t v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  pthread_mutex_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42[2];

  v42[1] = *MEMORY[0x1E0C80C00];
  if (a3 >= 1)
  {
    v5 = a3;
    v7 = result;
    v8 = (os_unfair_lock_s *)(result + 128);
    v38 = (pthread_mutex_t *)(result + 32);
    v39 = (uint64_t)(result + 144);
    do
    {
      os_unfair_lock_lock_with_options();
      v10 = *((_QWORD *)v7 + 13);
      v9 = *((_QWORD *)v7 + 14);
      v11 = *((_QWORD *)v7 + 15);
      os_unfair_lock_unlock(v8);
      if (!v10 || *(_BYTE *)(v10 + 12))
        goto LABEL_5;
      if (!*(_QWORD *)(v10 + 24))
      {
        v21 = CFGetAllocator(v7);
        v22 = *(_QWORD *)v10;
        v23 = *MEMORY[0x1E0C85AD8];
        if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
          v24 = *MEMORY[0x1E0C85AD8];
        else
          v24 = v23 + 1;
        if (v22 <= v24 >> 1)
        {
          v33 = v22 + 63;
          v32 = v22 < -63;
          v34 = v22 + 126;
          if (!v32)
            v34 = v33;
          v26 = v34 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          v25 = (v22 + v23 - 1) & -(int)v23;
          if (*((_QWORD *)v7 + 17) >= v25)
            v26 = v25;
          else
            v26 = *((_QWORD *)v7 + 17);
        }
        if (v26 > *(_QWORD *)(v10 + 16))
        {
          pthread_mutex_lock(v38);
          if (v26 > *(_QWORD *)(v10 + 16))
          {
            *(_QWORD *)(v10 + 24) = __CFSafelyReallocateWithAllocatorTyped(v21, *(_QWORD *)(v10 + 24), v26, 1893177561, 0, 0);
            if (__CFOASafe)
              __CFSetLastAllocationEventName();
            *(_QWORD *)(v10 + 16) = v26;
          }
          pthread_mutex_unlock(v38);
        }
      }
      if ((v35 = a2 - v9, a2 >= v9)
        && v11 + v9 > a2
        && ((v28 = *((unsigned int *)v7 + 6), (_DWORD)v28 != -1)
          ? (v36 = v35 << v28)
          : (v36 = *((_QWORD *)v7 + 2) * v35),
            (v37 = *(_QWORD *)(v10 + 24)) != 0))
      {
        Byte = (void *)(v37 + v36);
      }
      else
      {
LABEL_5:
        v41 = 0;
        v42[0] = 0;
        v40 = 0;
        v12 = *((_DWORD *)v7 + 6);
        if (v12 == -1)
          v13 = *((_QWORD *)v7 + 2) * a2;
        else
          v13 = a2 << v12;
        Byte = (void *)__CFStorageFindByte(v7, v39, v13, 0, v42, &v40, 1);
        v15 = v42[0];
        v16 = v40;
        if (v42[0])
        {
          v17 = *(_QWORD *)v42[0];
          v18 = *((_DWORD *)v7 + 6);
          if (v18 == -1)
          {
            v27 = *((_QWORD *)v7 + 2);
            v19 = v40 / v27;
            v20 = v17 / v27;
          }
          else
          {
            v19 = v40 >> v18;
            v20 = v17 >> v18;
          }
        }
        else
        {
          v19 = 0;
          v20 = 0;
        }
        os_unfair_lock_lock_with_options();
        *((_QWORD *)v7 + 13) = v15;
        *((_QWORD *)v7 + 14) = v19;
        *((_QWORD *)v7 + 15) = v20;
        os_unfair_lock_unlock(v8);
        v28 = *((unsigned int *)v7 + 6);
        if ((_DWORD)v28 == -1)
        {
          v29 = *((_QWORD *)v7 + 2);
          v9 = v16 / v29;
          v11 = v41 / v29;
        }
        else
        {
          v9 = v16 >> v28;
          v11 = v41 >> v28;
        }
      }
      if (v5 >= v9 - a2 + v11)
        v30 = v9 - a2 + v11;
      else
        v30 = v5;
      if (v28 == 0xFFFFFFFFLL)
        v31 = *((_QWORD *)v7 + 2) * v30;
      else
        v31 = v30 << v28;
      result = (char *)memmove(Byte, a4, v31);
      a4 += v31;
      a2 += v30;
      v32 = v5 <= v30;
      v5 -= v30;
    }
    while (!v32);
  }
  return result;
}

uint64_t _CFDiscorporateMemoryMaterialize(uint64_t *a1)
{
  uint64_t v1;
  char v2;
  uint64_t result;
  int v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v1 = *a1;
  v5 = 0;
  if (v1)
  {
    v2 = 0;
    LODWORD(result) = 34;
  }
  else
  {
    LODWORD(result) = MEMORY[0x186DB1338](*MEMORY[0x1E0C83DA0], a1[2], 0, &v5);
    if ((_DWORD)result)
    {
      v2 = 0;
    }
    else
    {
      *a1 = a1[2];
      v2 = 1;
    }
  }
  if ((v2 & (v5 == 2)) != 0)
    return 2;
  else
    return result;
}

id _CFURLComponentsCopyFragment(void *a1)
{
  return (id)objc_msgSend(a1, "fragment");
}

uint64_t _CFDiscorporateMemoryDematerialize(uint64_t *a1)
{
  uint64_t v1;
  uint64_t result;
  int v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v1 = *a1;
  v4 = 1;
  if (!v1)
    return 34;
  MEMORY[0x186DB1338](*MEMORY[0x1E0C83DA0], v1, 0, &v4);
  result = 0;
  *a1 = 0;
  return result;
}

CFArrayRef CFBundleCopyResourceURLsOfTypeForLocalization(CFBundleRef bundle, CFStringRef resourceType, CFStringRef subDirName, CFStringRef localizationName)
{
  if (bundle)
    return _CFBundleCopyFindResources((unint64_t *)bundle, 0, (uint64_t)subDirName, 0, resourceType, subDirName, localizationName, 1, 1, 0);
  else
    return CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
}

void CFStreamCreatePairWithSocketToHost(CFAllocatorRef alloc, CFStringRef host, UInt32 port, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
  createPair((uint64_t)alloc, (uint64_t)host, *(uint64_t *)&port, 0, 0, readStream, writeStream);
}

void CFFileDescriptorEnableCallBacks(CFFileDescriptorRef f, CFOptionFlags callBackTypes)
{
  unint64_t v4;
  NSObject *v5;
  _QWORD block[7];

  block[6] = *MEMORY[0x1E0C80C00];
  if (CFFileDescriptorGetTypeID_initOnce != -1)
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  v4 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v4 != 60)
    _CFAssertMismatchedTypeID(0x3CuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    v5 = __fdQueue();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __CFFileDescriptorEnableCallBacks_block_invoke;
    block[3] = &__block_descriptor_tmp_8;
    block[4] = f;
    block[5] = callBackTypes;
    dispatch_sync(v5, block);
  }
}

uint64_t __fdQueue()
{
  NSObject *v0;

  if (!__fdQueue___fddq)
  {
    v0 = dispatch_queue_create("com.apple.CFFileDescriptor", 0);
    while (!__ldaxr((unint64_t *)&__fdQueue___fddq))
    {
      if (!__stlxr((unint64_t)v0, (unint64_t *)&__fdQueue___fddq))
        return __fdQueue___fddq;
    }
    __clrex();
    dispatch_release(v0);
  }
  return __fdQueue___fddq;
}

void sub_182B96F10(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

uint64_t _CFPrefsWritePlistToFDThenClose(void *a1, int a2, uid_t a3, gid_t a4, mode_t a5, int a6, int a7, const char *a8)
{
  size_t v16;
  char *v17;
  unsigned int v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v31;
  int v32;
  uint64_t v33;
  int v34;
  int *v35;
  NSObject *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  int v44;
  NSObject *v45;
  BOOL v46;
  NSObject *v47;
  NSObject *v48;
  NSObject *v49;
  const char *v50;
  int v51;
  uint8_t v52[4];
  uint8_t *v53;
  __int16 v54;
  _BYTE *v55;
  __int16 v56;
  int v57;
  _BYTE value[1024];
  uint8_t buf[4];
  int v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (a2 < 0)
  {
    v21 = _CFPrefsDaemonLog();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    *(_DWORD *)buf = 67109120;
    v60 = a2;
    _os_log_fault_impl(&dword_182A8C000, v21, OS_LOG_TYPE_FAULT, "Invalid file descriptor %d", buf, 8u);
LABEL_15:
    if (!buf[0])
      return 22;
LABEL_16:
    unlinkat(-2, (const char *)buf, 2048);
    return 22;
  }
  if (!a1)
  {
    v22 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
      _CFPrefsWritePlistToFDThenClose_cold_1(v22, v23, v24, v25, v26, v27, v28, v29);
    close(a2);
    goto LABEL_15;
  }
  v16 = objc_msgSend(a1, "length");
  v17 = (char *)objc_msgSend(a1, "bytes");
  if (fcntl(a2, 50, buf) < 0)
  {
    v20 = *__error();
    v31 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
      _CFPrefsWritePlistToFDThenClose_cold_2(a2, v31);
    goto LABEL_21;
  }
  v18 = atomic_load(&dword_1EDCCE384);
  if (v18 == 2)
  {
    v19 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
      _CFPrefsWritePlistToFDThenClose_cold_3();
    close(a2);
    if (buf[0])
      unlinkat(-2, (const char *)buf, 2048);
    return 28;
  }
  v51 = a7;
  if (v16)
  {
    v50 = a8;
    v32 = write(a2, v17, v16);
    v33 = v32;
    if (v32 != v16)
    {
      v34 = v32;
      do
      {
        v35 = __error();
        if (v34 == -1)
        {
          if (*v35 != 4 && *v35 != 35)
          {
            v20 = *__error();
            v42 = _CFPrefsDaemonLog();
            if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT))
              _CFPrefsWritePlistToFDThenClose_cold_8();
            goto LABEL_21;
          }
        }
        else
        {
          v17 += v33;
          v16 -= v33;
        }
        v34 = write(a2, v17, v16);
        v33 = v34;
      }
      while (v34 != v16);
    }
    a8 = v50;
    while (fsync(a2) < 0)
    {
      if (*__error() != 4)
      {
        v20 = *__error();
        v36 = _CFPrefsDaemonLog();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
          _CFPrefsWritePlistToFDThenClose_cold_7();
        goto LABEL_21;
      }
    }
  }
  if (byte_1EDCCE37B)
  {
    sleep(1u);
    byte_1EDCCE37B = 0;
  }
  fchown(a2, a3, a4);
  fchmod(a2, a5);
  v37 = v51;
  if ((objc_msgSend(a1, "validatePlist") & 1) != 0)
  {
    if (a6)
    {
      value[0] = 1;
      v38 = fsetxattr(a2, "com.apple.MobileBackup", value, 1uLL, 0, 0);
      if ((_DWORD)v38)
      {
        v39 = v38;
        v20 = *__error();
        v40 = _CFPrefsDaemonLog();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
          _CFPrefsWritePlistToFDThenClose_cold_5((uint64_t)buf, v39, v40);
LABEL_21:
        close(a2);
LABEL_22:
        if (buf[0])
          unlinkat(-2, (const char *)buf, 2048);
        return v20;
      }
      v37 = v51;
    }
    close(a2);
    v44 = renameat(-2, (const char *)buf, v37, a8);
    v20 = *__error();
    if (v44)
    {
      bzero(value, 0x400uLL);
    }
    else
    {
      v45 = _CFPrefsDaemonLog();
      v46 = os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG);
      bzero(value, 0x400uLL);
      if (!v46)
      {
LABEL_62:
        v48 = _CFPrefsDaemonLog();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
        {
          v49 = _CFPrefsDaemonLog();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
            _CFPrefsWritePlistToFDThenClose_cold_4();
        }
        return 0;
      }
    }
    if (v51 != -2 && fcntl(v51, 50, value) == -1)
      __strlcat_chk();
    __strlcat_chk();
    if (v44)
    {
      v47 = _CFPrefsDaemonLog();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)v52 = 136315650;
        v53 = buf;
        v54 = 2080;
        v55 = value;
        v56 = 1024;
        v57 = v20;
        _os_log_fault_impl(&dword_182A8C000, v47, OS_LOG_TYPE_FAULT, "error renaming file %s to %s (errno: %d).", v52, 0x1Cu);
      }
      goto LABEL_22;
    }
    goto LABEL_62;
  }
  v41 = _CFPrefsDaemonLog();
  if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
    _CFPrefsWritePlistToFDThenClose_cold_6();
  close(a2);
  if (buf[0])
    unlinkat(-2, (const char *)buf, 2048);
  return 47837;
}

uint64_t _CFPropertyListValidateData(const __CFData *a1, _QWORD *a2)
{
  const UInt8 *BytePtr;
  unint64_t Length;
  int v6;
  uint64_t result;
  CFTypeRef v8;
  int v9[2];
  char v10;
  CFTypeRef cf;
  _OWORD v12[2];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  memset(v12, 0, sizeof(v12));
  *(_QWORD *)v9 = 0;
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  if (Length >= 8
    && (v6 = Length, __CFDataGetBinaryPlistTopLevelInfo(a1, &v10, (unint64_t *)v9, (uint64_t)v12)))
  {
    cf = 0;
    result = __CFBinaryPlistCreateObjectFiltered(BytePtr, v6, *(unint64_t *)v9, (uint64_t)v12, &__kCFAllocatorSystemDefault, 0, 0, 0, 0, 0, 0, 0, (CFTypeID *)&cf);
    if (a2)
      *a2 = cf;
  }
  else
  {
    cf = 0;
    _CFPropertyListCreateWithData(&__kCFAllocatorSystemDefault, a1, 1u, 0, 1, 0, 0, &cf);
    v8 = cf;
    if (cf)
    {
      if (a2)
        *a2 = CFGetTypeID(cf);
      CFRelease(v8);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void CFBagRemoveAllValues(CFMutableBagRef theBag)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v8 = atomic_load((unint64_t *)theBag + 1);
  if ((v8 & 0x40) != 0)
    CFLog(3, (uint64_t)CFSTR("%s(): immutable collection %p given to mutating function"), v1, v2, v3, v4, v5, v6, (__int16)"void CFBagRemoveAllValues(CFMutableBagRef)");
  CFBasicHashRemoveAllValues((uint64_t)theBag);
}

CFStringRef CFStringConvertEncodingToIANACharSetName(CFStringEncoding encoding)
{
  const void *v2;
  const __CFString *Value;
  __CFDictionary *Mutable;
  char cStr[100];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = (const void *)encoding;
  os_unfair_lock_lock_with_options();
  if (!CFStringConvertEncodingToIANACharSetName_mappingTable
    || (Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)CFStringConvertEncodingToIANACharSetName_mappingTable, v2)) == 0)
  {
    if (__CFStringEncodingGetCanonicalName(encoding, cStr, 100))
    {
      Value = CFStringCreateWithCString(0, cStr, 0x600u);
      if (Value)
      {
        Mutable = (__CFDictionary *)CFStringConvertEncodingToIANACharSetName_mappingTable;
        if (!CFStringConvertEncodingToIANACharSetName_mappingTable)
        {
          Mutable = CFDictionaryCreateMutable(0, 0, 0, &kCFTypeDictionaryValueCallBacks);
          CFStringConvertEncodingToIANACharSetName_mappingTable = (uint64_t)Mutable;
        }
        CFDictionaryAddValue(Mutable, v2, Value);
        CFRelease(Value);
      }
    }
    else
    {
      Value = 0;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&CFStringConvertEncodingToIANACharSetName_lock);
  return Value;
}

BOOL __CFStringEncodingGetCanonicalName(int a1, char *__str, int64_t __size)
{
  unsigned int v4;
  unint64_t v5;
  int v6;
  __int16 *v7;
  unsigned int v8;
  __int16 *v9;
  char *v10;
  unsigned int v11;
  unsigned __int16 *v12;
  __int16 *v13;
  const char *v14;
  __int16 *v16;
  unsigned int v17;
  __int16 *v18;
  char *v19;
  unsigned int v20;
  unsigned __int16 *v21;
  __int16 *v22;

  v4 = ((a1 & 0xF00u) - 256) >> 8;
  if (v4 - 3 < 2)
  {
    v7 = (__int16 *)&unk_182DC759A;
    v8 = a1 & 0xFFF;
    v9 = __CFKnownEncodingList;
    while (1)
    {
      v10 = (char *)&v9[((char *)v7 - (char *)v9) >> 2];
      v11 = *(unsigned __int16 *)v10;
      if (v8 == v11)
        break;
      v12 = (unsigned __int16 *)(v10 - 2);
      v13 = (__int16 *)(v10 + 2);
      if (v8 < v11)
        v7 = (__int16 *)v12;
      else
        v9 = v13;
      if (v9 > v7)
        return 0;
    }
    if (v10 - (char *)__CFKnownEncodingList != -2
      && *(__int16 *)((char *)__CFWindowsCPList + v10 - (char *)__CFKnownEncodingList))
    {
      if ((a1 & 0xF00) == 0x400)
        v14 = "cp%d";
      else
        v14 = "windows-%d";
      v6 = snprintf(__str, __size, v14, *(unsigned __int16 *)((char *)__CFWindowsCPList + v10 - (char *)__CFKnownEncodingList));
      return v6 < __size;
    }
  }
  else
  {
    if (v4 == 1)
    {
      v6 = snprintf(__str, __size, "iso-8859-%u");
      return v6 < __size;
    }
    if (v4)
    {
      v16 = (__int16 *)&unk_182DC759A;
      v17 = a1 & 0xFFF;
      v18 = __CFKnownEncodingList;
      while (1)
      {
        v19 = (char *)&v18[((char *)v16 - (char *)v18) >> 2];
        v20 = *(unsigned __int16 *)v19;
        if (v17 == v20)
          break;
        v21 = (unsigned __int16 *)(v19 - 2);
        v22 = (__int16 *)(v19 + 2);
        if (v17 < v20)
          v16 = (__int16 *)v21;
        else
          v18 = v22;
        if (v18 > v16)
          return 0;
      }
      if (v19 - (char *)__CFKnownEncodingList != -2
        && *(char **)((char *)__CFCanonicalNameList + 4 * (v19 - (char *)__CFKnownEncodingList)))
      {
        v6 = snprintf(__str, __size, "%s%s");
        return v6 < __size;
      }
    }
    else
    {
      HIDWORD(v5) = a1 - 256;
      LODWORD(v5) = a1 - 256;
      if ((v5 >> 26) <= 7)
      {
        v6 = snprintf(__str, __size, "%s");
        return v6 < __size;
      }
    }
  }
  return 0;
}

CFFileDescriptorNativeDescriptor CFFileDescriptorGetNativeDescriptor(CFFileDescriptorRef f)
{
  unint64_t v2;

  if (CFFileDescriptorGetTypeID_initOnce != -1)
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  v2 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v2 != 60)
    _CFAssertMismatchedTypeID(0x3CuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) != 0)
    return -1;
  else
    return *((_DWORD *)f + 5);
}

uint64_t CFStringEncodingBytesToUnicode(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  uint64_t *v15;
  uint64_t *v16;
  int v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(uint64_t *, uint64_t, unint64_t, uint64_t, _QWORD, _QWORD, uint64_t *);
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  unsigned int v29;
  BOOL v30;
  int v32;
  uint64_t *v33;
  uint64_t v34;
  _QWORD v35[2];

  v35[1] = *MEMORY[0x1E0C80C00];
  v15 = (uint64_t *)__CFGetConverter();
  if (!v15)
    return 3;
  v16 = v15;
  v35[0] = 0;
  v17 = *(unsigned __int8 *)(*v15 + 20);
  if (v17 == 4)
    return __CFStringEncodingPlatformBytesToUnicode();
  if (v17 == 5)
    return __CFStringEncodingICUToUnicode(v15[1], a2, a3, a4, a5, a6, a7, a8);
  v33 = a5;
  if (a4 < 1)
  {
    v20 = 0;
    v19 = 0;
    v29 = 0;
    goto LABEL_50;
  }
  v19 = 0;
  v20 = 0;
  while (1)
  {
    if (a7 && a7 <= v19)
    {
LABEL_43:
      v29 = 0;
      goto LABEL_50;
    }
    v21 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))v16[2];
    if (v21)
    {
      if ((a2 & 0xC0) != 0)
        v21 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))v16[3];
      v22 = a7 ? a7 - v19 : 0;
      v23 = v21(v16, a2, a3 + v20, a4 - v20, a6 + 2 * v19, v22, v35);
    }
    else
    {
      v24 = a7 ? a7 - v19 : 0;
      v23 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))(*v16 + 8))(a2, a3 + v20, a4 - v20, a6 + 2 * v19, v24, v35);
    }
    v20 += v23;
    if (a4 > v20)
      break;
LABEL_42:
    v19 += v35[0];
    if (v20 >= a4)
      goto LABEL_43;
  }
  v34 = 0;
  if (!a7)
    goto LABEL_27;
  if (v35[0] + v19 == a7)
  {
    v29 = 2;
    goto LABEL_49;
  }
  if ((a2 & 0xC0) == 0 && v35[0] + v19 + 1 != a7)
  {
LABEL_27:
    if ((a2 & 1) == 0)
    {
      v29 = 1;
      goto LABEL_49;
    }
    goto LABEL_38;
  }
  v25 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, _QWORD, _QWORD, uint64_t *))v16[2];
  if (v25)
  {
    v32 = a2 & 1;
    if ((a2 & 0xC0) != 0)
      v26 = ((uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, _QWORD, _QWORD, uint64_t *))v16[3])(v16, a2, a3 + v20, a4 - v20, 0, 0, &v34);
    else
      v26 = v25(v16, a2, a3 + v20, a4 - v20, 0, 0, &v34);
  }
  else
  {
    v32 = a2 & 1;
    v26 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, _QWORD, _QWORD, uint64_t *))(*v16 + 8))(a2, a3 + v20, a4 - v20, 0, 0, &v34);
  }
  if (v26)
    v27 = 1;
  else
    v27 = v32 == 0;
  if (!v27)
  {
LABEL_38:
    v19 += v35[0];
    if (a7)
      v28 = a7 - v19;
    else
      v28 = 0;
    v20 += ((uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))v16[5])(a3 + v20, a4 - v20, a6 + 2 * v19, v28, v35);
    goto LABEL_42;
  }
  if (v26)
    v29 = 2;
  else
    v29 = 1;
LABEL_49:
  v19 += v35[0];
LABEL_50:
  if (v29)
    v30 = 0;
  else
    v30 = v20 < a4;
  if (!v30 || a7 == 0)
    result = v29;
  else
    result = 2;
  if (a8)
    *a8 = v19;
  if (v33)
    *v33 = v20;
  return result;
}

uint64_t __CFStringEncodingICUToUnicode(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  _QWORD *Typed;
  uint64_t v16;
  uint64_t v17;
  int v18;

  if ((a2 & 0xFF0000) == 0)
    goto LABEL_6;
  Typed = (_QWORD *)_CFGetTSD(7u);
  if (!Typed)
  {
    Typed = (_QWORD *)CFAllocatorAllocateTyped(0, 16, 0x1080040EF48E34ELL, 0);
    *Typed = 0;
    Typed[1] = 0;
    _CFSetTSD(7u, (uint64_t)Typed, (uint64_t)__CFICUThreadDataDestructor);
  }
  if (*(unsigned __int8 *)Typed <= (BYTE2(a2) - 1)
    || (v16 = *(_QWORD *)(Typed[1] + 8 * (BYTE2(a2) - 1))) == 0)
  {
LABEL_6:
    v17 = ucnv_open();
    if (!v17)
      return 3;
    v16 = v17;
    v18 = HIBYTE(a2);
    if ((a2 & 0xFF000001) == 1)
      v18 = 63;
    if (v18)
      ucnv_setSubstChars();
    else
      ucnv_setToUCallBack();
  }
  if (a7)
  {
    ucnv_toUnicode();
    if (a8)
      *a8 = (a6 - a6) >> 1;
    goto LABEL_20;
  }
  if (a4 < 1)
  {
    if (!a8)
      goto LABEL_20;
  }
  else
  {
    do
      ucnv_toUnicode();
    while (a3 < a3 + a4);
    if (!a8)
      goto LABEL_20;
  }
  *a8 = 0;
LABEL_20:
  if (a5)
    *a5 = a3 - a3;
  return __CFStringEncodingConverterReleaseICUConverter(v16, a2, 0);
}

uint64_t _CFWriteStreamCreateFromFileDescriptor(__objc2_class **a1, int a2)
{
  _OWORD v3[2];
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v4 = 0;
  memset(v3, 0, sizeof(v3));
  DWORD2(v3[0]) = a2;
  return _CFStreamCreateWithConstantCallbacks(a1, (uint64_t)v3, fileCallBacks, 0);
}

CFTypeRef _CFCopySystemVersionPlatformDictionary()
{
  CFTypeRef result;

  if (_CFCopySystemVersionPlatformDictionary_onceToken != -1)
    dispatch_once(&_CFCopySystemVersionPlatformDictionary_onceToken, &__block_literal_global_20);
  result = (CFTypeRef)_CFCopySystemVersionPlatformDictionary_result;
  if (_CFCopySystemVersionPlatformDictionary_result)
    return CFRetain((CFTypeRef)_CFCopySystemVersionPlatformDictionary_result);
  return result;
}

SInt32 CFAbsoluteTimeGetDayOfWeek(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  double SecondsFromGMT;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (tz)
    SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  else
    SecondsFromGMT = 0.0;
  v4 = vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0);
  v5 = ((unint64_t)~v4 * (unsigned __int128)0x2492492492492493uLL) >> 64;
  v6 = (~v4 - 7 * ((v5 + ((unint64_t)(~v4 - v5) >> 1)) >> 2)) ^ 7;
  if (v4 >= 0)
    return v4 % 7uLL + 1;
  else
    LODWORD(v7) = v6;
  return v7;
}

CFDictionaryRef CFBundleCopyLocalizedStringTableForLocalization(unint64_t *a1, __CFString *a2, const void *a3)
{
  unint64_t v6;
  const __CFArray *v7;
  CFDictionaryRef v8;
  const void *v10[2];

  v10[1] = *(const void **)MEMORY[0x1E0C80C00];
  v10[0] = a3;
  v6 = _CFGetNonObjCTypeID(a1);
  if (v6 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v6);
  CFBundleAllowMixedLocalizations();
  if (!a2 || CFEqual(a2, &stru_1E1337B18))
    a2 = CFSTR("Localizable");
  if (!a3)
  {
    v8 = _copyStringTable((uint64_t)a1, a2, 0, 0, 0, 0);
    if (v8)
      return v8;
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  v7 = CFArrayCreate(0, v10, 1, &kCFTypeArrayCallBacks);
  v8 = _copyStringTable((uint64_t)a1, a2, 0, v7, 0, 0);
  if (v7)
    CFRelease(v7);
  if (!v8)
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  return v8;
}

void _CFPreferencesSetBackupDisabled(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4, int a5)
{
  uint64_t v10;
  id v11;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v10 = objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v11 = (id)v10;
  -[_CFXPreferences setBackupDisabled:identifier:user:host:container:](v10, a5 != 0, a1, a2, a3, a4);

}

uint64_t _CFDiscorporateMemoryDeallocate(uint64_t a1)
{
  mach_vm_address_t v2;
  uint64_t v3;
  uint64_t v4;
  __int16 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v3 = mach_vm_deallocate(*MEMORY[0x1E0C83DA0], v2, *(_QWORD *)(a1 + 8));
    v4 = v3;
    if ((_DWORD)v3)
    {
      v5 = (unsigned __int16)mach_error_string(v3);
      CFLog(3, (uint64_t)CFSTR("CFDiscorporateMemoryDeallocate: mach_vm_deallocate returned %s"), v6, v7, v8, v9, v10, v11, v5);
    }
  }
  else
  {
    v4 = 0;
  }
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  return v4;
}

unint64_t __NSOrderedSetGetIndexPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  size_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  void *context;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  _QWORD block[13];
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44[3];
  char v45;
  _BYTE v46[128];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (!objc_msgSend(a1, "count"))
    return 0x7FFFFFFFFFFFFFFFLL;
  if ((a3 & 0x1000000000000000) != 0)
  {
    v7 = objc_msgSend(a4, "firstIndex");
    v37 = objc_msgSend(a4, "lastIndex");
  }
  else
  {
    v7 = 0;
    v37 = objc_msgSend(a1, "count") - 1;
  }
  v8 = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 != 0x7FFFFFFFFFFFFFFFLL && v37 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if ((a3 & 1) != 0)
    {
      v9 = __CFActiveProcessorCount();
      if (v9 < 2)
        a3 &= ~1uLL;
    }
    else
    {
      v9 = 1;
    }
    if ((a3 & 3) != 0)
    {
      v10 = (v37 - v7 + 1) / v9 / v9;
      if (v10 >= 0x10)
      {
        if (v10 <= 0x1000)
          v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0;
        else
          v11 = 4096;
      }
      else
      {
        v11 = 16;
      }
      v21 = v11 + v37 - v7;
      v22 = v21 / v11;
      if ((a3 & 1) != 0)
      {
        v44[0] = 0;
        v44[1] = (unint64_t)v44;
        v44[2] = 0x2020000000;
        v45 = 0;
        v40 = 0;
        v41 = &v40;
        v42 = 0x2020000000;
        v43 = 0x7FFFFFFFFFFFFFFFLL;
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ____NSOrderedSetGetIndexPassingTest_block_invoke;
        block[3] = &unk_1E12E6278;
        block[10] = v11;
        block[11] = v37;
        block[12] = a3;
        block[4] = a1;
        block[5] = a4;
        block[6] = a2;
        block[7] = v44;
        block[8] = &v40;
        block[9] = v7;
        dispatch_apply(v22, 0, block);
        v8 = atomic_load((unint64_t *)v41 + 3);
        _Block_object_dispose(&v40, 8);
        _Block_object_dispose(v44, 8);
      }
      else
      {
        v36 = a2;
        v44[0] = 0x7FFFFFFFFFFFFFFFLL;
        if (v11 <= v21)
        {
          v23 = v7;
          v24 = 0;
          v25 = v11 - 1;
          if (v22 <= 1)
            v26 = 1;
          else
            v26 = v21 / v11;
          v27 = v26 - 1;
          v28 = v23;
          v29 = v37;
          do
          {
            v30 = v27;
            if ((a3 & 2) != 0)
            {
              if (v25 >= v29 - v23)
                v32 = v23;
              else
                v32 = 1 - v11 + v29;
              v31 = v29;
            }
            else
            {
              if (v25 >= v29 - v23)
                v31 = v37;
              else
                v31 = v25 + v24 * v11 + v23;
              v32 = v28;
            }
            if (__NSOrderedSetChunkIterate(a1, a3, v32, v31, a4, v36, v44, 0, 0))
              break;
            ++v24;
            v27 = v30 - 1;
            v29 -= v11;
            v28 += v11;
          }
          while (v30);
        }
        return atomic_load(v44);
      }
      return v8;
    }
    v12 = (void *)_CFAutoreleasePoolPush();
    LOBYTE(v44[0]) = 0;
    v47 = 0u;
    v48 = 0u;
    v49 = 0u;
    v50 = 0u;
    v13 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v47, v46, 16);
    if (!v13)
      goto LABEL_56;
    v14 = v13;
    context = v12;
    v35 = v7;
    v15 = 0;
    v16 = 0;
    v17 = *(_QWORD *)v48;
LABEL_17:
    v18 = 0;
    while (1)
    {
      if (*(_QWORD *)v48 != v17)
        objc_enumerationMutation(a1);
      v19 = v16 + v18;
      v20 = *(_QWORD *)(*((_QWORD *)&v47 + 1) + 8 * v18);
      if ((a3 & 0x1000000000000000) == 0
        || v35 <= v19 && v19 <= v37 && objc_msgSend(a4, "containsIndex:", v16 + v18))
      {
        if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t *))(a2 + 16))(a2, v20, v16 + v18, v44) & 1) != 0)
        {
          v8 = v16 + v18;
LABEL_55:
          v12 = context;
LABEL_56:
          _CFAutoreleasePoolPop(v12);
          return v8;
        }
        if (LOBYTE(v44[0]))
          goto LABEL_31;
        if (v15 >= 0x3FF)
        {
          _CFAutoreleasePoolPop(context);
          context = (void *)_CFAutoreleasePoolPush();
          v15 = 0;
        }
        else
        {
          ++v15;
        }
      }
      if (v14 == ++v18)
      {
        v14 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v47, v46, 16);
        v16 += v18;
        if (v14)
          goto LABEL_17;
LABEL_31:
        v8 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_55;
      }
    }
  }
  return v8;
}

BOOL cffd_is_readable(unsigned int a1)
{
  size_t v2;
  void *v3;
  int v4;
  uint64_t v5;
  int v6;
  _BOOL8 v7;

  if (a1 >= 0x100000)
    __break(1u);
  v2 = ((a1 + 8) >> 3) + 7;
  v3 = malloc_type_malloc(v2, 0x56647412uLL);
  v4 = 1 << a1;
  v5 = a1 >> 5;
  while (1)
  {
    bzero(v3, v2);
    if (__darwin_check_fd_set_overflow(a1, v3, 1))
      *((_DWORD *)v3 + v5) |= v4;
    v6 = pselect_DARWIN_EXTSN();
    if ((v6 & 0x80000000) == 0)
      break;
    if (*__error() != 4 && *__error() != 35)
      goto LABEL_12;
  }
  if (v6 && __darwin_check_fd_set_overflow(a1, v3, 1))
  {
    v7 = (*((_DWORD *)v3 + v5) & v4) != 0;
    goto LABEL_13;
  }
LABEL_12:
  v7 = 0;
LABEL_13:
  free(v3);
  return v7;
}

void CFBitVectorSetAllBits(CFMutableBitVectorRef bv, CFBit value)
{
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  char v14;
  char v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  void *v19;
  int v20;

  v2 = *((_QWORD *)bv + 2);
  v3 = v2 + 7;
  if (v2 >= 0)
    v3 = *((_QWORD *)bv + 2);
  v4 = v3 >> 3;
  v5 = v2 - (v3 & 0xFFFFFFFFFFFFFFF8);
  if (v5 >= 1)
  {
    v6 = 255 << (8 - v5);
    v7 = (unint64_t)v5 >= 8;
    v8 = v5 - 8;
    if (!v7)
      v8 = 0;
    if (value)
    {
      if (v7)
        LOBYTE(v6) = -1;
      *(_BYTE *)(*((_QWORD *)bv + 4) + v4) |= v6;
      v9 = v8 & 0xFFFFFFFFFFFFFFF8;
      v10 = v4 + 1;
      if (v8 >= 8)
      {
        v11 = -(uint64_t)(v8 >> 3);
        do
        {
          *(_BYTE *)(*((_QWORD *)bv + 4) + v10++) = -1;
          v7 = __CFADD__(v11++, 1);
        }
        while (!v7);
      }
      if (v9 != v8)
      {
        v12 = 255 << (v9 - v8 + 8);
        v13 = *((_QWORD *)bv + 4);
        v14 = *(_BYTE *)(v13 + v10) | v12;
LABEL_25:
        *(_BYTE *)(v13 + v10) = v14;
      }
    }
    else
    {
      if (v7)
        v15 = 0;
      else
        v15 = ~(_BYTE)v6;
      *(_BYTE *)(*((_QWORD *)bv + 4) + v4) &= v15;
      v16 = v8 & 0xFFFFFFFFFFFFFFF8;
      v10 = v4 + 1;
      if (v8 >= 8)
      {
        v17 = -(uint64_t)(v8 >> 3);
        do
        {
          *(_BYTE *)(*((_QWORD *)bv + 4) + v10++) = 0;
          v7 = __CFADD__(v17++, 1);
        }
        while (!v7);
      }
      if (v16 != v8)
      {
        v18 = 255 << (v16 - v8 + 8);
        v13 = *((_QWORD *)bv + 4);
        v14 = *(_BYTE *)(v13 + v10) & ~(_BYTE)v18;
        goto LABEL_25;
      }
    }
  }
  v19 = (void *)*((_QWORD *)bv + 4);
  if (value)
    v20 = -1;
  else
    v20 = 0;
  memset(v19, v20, v4);
}

uint64_t _CFDiscorporateMemoryAllocate(uint64_t a1, uint64_t a2, int a3)
{
  char v3;
  mach_vm_size_t v5;
  mach_vm_address_t *v6;
  vm_map_t *v7;
  int v8;
  uint64_t result;

  v3 = a3;
  if (((a2 + *MEMORY[0x1E0C85AD8] - 1) & -*MEMORY[0x1E0C85AD8]) != 0)
    v5 = (a2 + *MEMORY[0x1E0C85AD8] - 1) & -*MEMORY[0x1E0C85AD8];
  else
    v5 = *MEMORY[0x1E0C85AD8];
  *(_QWORD *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  v6 = (mach_vm_address_t *)(a1 + 16);
  v7 = (vm_map_t *)MEMORY[0x1E0C83DA0];
  *(_OWORD *)a1 = 0u;
  if (a3)
    v8 = 687865859;
  else
    v8 = 687865857;
  result = mach_vm_allocate(*v7, v6, v5, v8);
  if ((_DWORD)result)
  {
    *v6 = 0;
  }
  else
  {
    *(_QWORD *)a1 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 8) = v5;
    *(_BYTE *)(a1 + 24) = v3;
  }
  return result;
}

CFRunLoopSourceRef CFSocketCreateRunLoopSource(CFAllocatorRef allocator, CFSocketRef s, CFIndex order)
{
  unint64_t v6;
  pthread_mutex_t *v7;
  char v8;
  __CFRunLoopSource *v9;
  __CFRunLoopSource *v10;
  int IsValid;
  CFRunLoopSourceRef v12;
  CFRunLoopSourceContext context;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v6 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v6 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v6);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v7 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  v8 = atomic_load((unint64_t *)s + 1);
  if ((v8 & 0x10) != 0)
  {
    v10 = (__CFRunLoopSource *)*((_QWORD *)s + 24);
    if (v10)
    {
      IsValid = CFRunLoopSourceIsValid(v10);
      v12 = (CFRunLoopSourceRef)*((_QWORD *)s + 24);
      if (IsValid)
      {
        if (v12)
        {
LABEL_16:
          CFRetain(v12);
          v9 = (__CFRunLoopSource *)*((_QWORD *)s + 24);
          goto LABEL_17;
        }
      }
      else
      {
        CFRelease(v12);
        *((_QWORD *)s + 24) = 0;
      }
    }
    context.version = 0;
    context.info = s;
    context.retain = CFRetain;
    context.release = CFRelease;
    context.copyDescription = CFCopyDescription;
    context.equal = CFEqual;
    context.hash = CFHash;
    context.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFSocketSchedule;
    context.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFSocketCancel;
    context.perform = (void (__cdecl *)(void *))__CFSocketPerformV0;
    v12 = CFRunLoopSourceCreate(allocator, order, &context);
    *((_QWORD *)s + 24) = v12;
    goto LABEL_16;
  }
  v9 = 0;
LABEL_17:
  pthread_mutex_unlock(v7);
  return v9;
}

uint64_t __CFBinaryHeapCreateInit(__objc2_class **a1, const void **a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  uint64_t Instance;
  uint64_t v11;
  uint64_t Typed;
  __int128 v13;
  __int128 v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  const void *v19;
  unint64_t v20;
  unint64_t v21;
  int v22;

  Instance = _CFRuntimeCreateInstance(a1, 0x17uLL, 104, 0);
  v11 = Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 24) = 4;
    Typed = CFAllocatorAllocateTyped(a1, 32, 0x80040B8603338, 0);
    *(_QWORD *)(v11 + 112) = Typed;
    if (__CFOASafe)
    {
      __CFSetLastAllocationEventName();
      Typed = *(_QWORD *)(v11 + 112);
    }
    if (Typed)
    {
      if (a4)
      {
        *(_OWORD *)(v11 + 40) = *(_OWORD *)(a4 + 8);
        *(_OWORD *)(v11 + 56) = *(_OWORD *)(a4 + 24);
      }
      if (a5)
      {
        v13 = *a5;
        v14 = a5[1];
        *(_QWORD *)(v11 + 104) = *((_QWORD *)a5 + 4);
        *(_OWORD *)(v11 + 88) = v14;
        *(_OWORD *)(v11 + 72) = v13;
      }
      v15 = (unint64_t *)(v11 + 8);
      v16 = atomic_load((unint64_t *)(v11 + 8));
      while (1)
      {
        v17 = __ldaxr(v15);
        if (v17 != v16)
          break;
        if (__stlxr(v16 & 0xFFFFFFFFFFFFFFF3 | 4, v15))
          goto LABEL_14;
        v18 = 1;
LABEL_15:
        v16 = v17;
        if (v18)
        {
          if (a3 >= 1)
          {
            do
            {
              v19 = *a2++;
              CFBinaryHeapAddValue((CFBinaryHeapRef)v11, v19);
              --a3;
            }
            while (a3);
          }
          v20 = atomic_load(v15);
          while (1)
          {
            v21 = __ldaxr(v15);
            if (v21 != v20)
              break;
            if (__stlxr(v20 & 0xFFFFFFFFFFFFFFF3 | 4, v15))
              goto LABEL_23;
            v22 = 1;
LABEL_24:
            v20 = v21;
            if (v22)
              return v11;
          }
          __clrex();
LABEL_23:
          v22 = 0;
          goto LABEL_24;
        }
      }
      __clrex();
LABEL_14:
      v18 = 0;
      goto LABEL_15;
    }
    CFRelease((CFTypeRef)v11);
    return 0;
  }
  return v11;
}

CFStringRef _CFPlugInRegisterFactoryFunctionByNameLocked(const void *a1, const void *a2, const __CFString *a3)
{
  _QWORD *Locked;
  uint64_t PlugInData;
  CFStringRef result;

  Locked = (_QWORD *)_CFPFactoryCommonCreateLocked(&__kCFAllocatorSystemDefault, a1);
  Locked[4] = 0;
  Locked[5] = CFRetain(a2);
  if (a2 && *(_BYTE *)__CFBundleGetPlugInData((uint64_t)a2))
  {
    PlugInData = __CFBundleGetPlugInData((uint64_t)a2);
    CFArrayAppendValue(*(CFMutableArrayRef *)(PlugInData + 16), Locked);
  }
  if (a3)
    result = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a3);
  else
    result = 0;
  Locked[6] = result;
  return result;
}

uint64_t _CFPFactoryCommonCreateLocked(__objc2_class **a1, const void *a2)
{
  uint64_t Instance;
  const void *v5;
  __CFDictionary *v6;
  CFDictionaryValueCallBacks v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  Instance = _CFRuntimeCreateInstance(a1, 0x20uLL, 48, 0);
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = CFRetain(a2);
    *(_BYTE *)(Instance + 24) = 1;
    *(_QWORD *)(Instance + 56) = CFArrayCreateMutable((CFAllocatorRef)a1, 0, &kCFTypeArrayCallBacks);
    v5 = *(const void **)(Instance + 16);
    v6 = (__CFDictionary *)_factoriesByFactoryID;
    if (!_factoriesByFactoryID)
    {
      memset(&v8, 0, sizeof(v8));
      v6 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &v8);
      _factoriesByFactoryID = (uint64_t)v6;
    }
    CFDictionarySetValue(v6, v5, (const void *)Instance);
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
      _CFPFactoryCommonCreateLocked_cold_1();
  }
  return Instance;
}

void CFCharacterSetRemoveCharactersInString(CFMutableCharacterSetRef theSet, CFStringRef theString)
{
  unint64_t *v4;
  char v5;
  char v6;
  char v7;
  char v8;
  uint64_t v9;
  unsigned int v10;
  char v11;
  CFIndex Length;
  CFIndex v13;
  char v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  char v18;
  size_t v19;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v22;
  int64_t v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  UniChar v27;
  int64_t v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int64_t v33;
  CFIndex v34;
  unint64_t v35;
  unint64_t v36;
  int v37;
  uint64_t v38;
  UniChar *Typed;
  CFAllocatorRef v40;
  char v41;
  UniChar *v42;
  uint64_t v43;
  UniChar *v44;
  UniChar *v45;
  unint64_t v46;
  unint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned __int16 *v53;
  __int16 v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  int v58;
  UniChar buffer[8];
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  CFStringRef theStringa;
  const UniChar *v68;
  const char *v69;
  uint64_t v70;
  CFIndex v71;
  int64_t v72;
  int64_t v73;
  uint64_t v74;
  CFRange v75;
  CFRange v76;

  v74 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    -[__CFCharacterSet removeCharactersInString:](theSet, "removeCharactersInString:", theString);
    return;
  }
  v4 = (unint64_t *)((char *)theSet + 8);
  v5 = atomic_load((unint64_t *)theSet + 1);
  if ((v5 & 1) == 0)
  {
    CFLog(3, CFSTR("%s: Immutable character set passed to mutable function"));
    if (dyld_program_sdk_at_least())
      CFCharacterSetRemoveCharactersInString_cold_1();
  }
  v6 = atomic_load(v4);
  if ((v6 & 0x70) != 0
    || (v7 = atomic_load(v4), (v7 & 1) != 0)
    || (v8 = atomic_load(v4), (v8 & 8) != 0)
    || CFCharacterSetGetPredefined(*((CFCharacterSetPredefinedSet *)theSet + 3)) != theSet)
  {
    v9 = *((_QWORD *)theSet + 5);
    if (v9)
    {
      if (*(_DWORD *)(v9 + 8) || *(_BYTE *)(v9 + 13))
        goto LABEL_18;
    }
    v10 = atomic_load(v4);
    switch((v10 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*((_QWORD *)theSet + 4))
          goto LABEL_18;
        break;
      case 3u:
      case 4u:
        if (*((_QWORD *)theSet + 3))
          goto LABEL_18;
        break;
      default:
        goto LABEL_18;
    }
    v11 = atomic_load(v4);
    if ((v11 & 8) != 0)
    {
LABEL_18:
      Length = CFStringGetLength(theString);
      if (!Length)
        return;
      v13 = Length;
      v14 = atomic_load(v4);
      if ((v14 & 8) == 0)
        goto LABEL_31;
      v15 = *((_QWORD *)theSet + 5);
      if (v15 && (*(_DWORD *)(v15 + 8) || *(_BYTE *)(v15 + 13)))
      {
LABEL_27:
        v18 = atomic_load(v4);
        v17 = (v18 & 0x70) == 0x20 ? *((_QWORD *)theSet + 4) : 64;
      }
      else
      {
        v16 = atomic_load(v4);
        switch((v16 >> 4) & 7)
        {
          case 1u:
          case 2u:
            if (*((_QWORD *)theSet + 4))
              goto LABEL_27;
            break;
          case 3u:
          case 4u:
            if (*((_QWORD *)theSet + 3))
              goto LABEL_27;
            break;
          default:
            goto LABEL_27;
        }
        v17 = 0;
      }
      v19 = v17 + Length;
      if (v17 + Length > 63)
      {
LABEL_31:
        __CFCSetMakeBitmap((char *)theSet);
        v65 = 0u;
        v66 = 0u;
        v63 = 0u;
        v64 = 0u;
        v61 = 0u;
        v62 = 0u;
        *(_OWORD *)buffer = 0u;
        v60 = 0u;
        theStringa = theString;
        v70 = 0;
        v71 = v13;
        CharactersPtr = CFStringGetCharactersPtr(theString);
        CStringPtr = 0;
        v68 = CharactersPtr;
        if (!CharactersPtr)
          CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
        v72 = 0;
        v73 = 0;
        v69 = CStringPtr;
        if (v13 < 1)
        {
          v24 = 0;
        }
        else
        {
          v22 = 0;
          v23 = 0;
          v24 = 0;
          v25 = 64;
          do
          {
            if ((unint64_t)v23 >= 4)
              v26 = 4;
            else
              v26 = v23;
            if (v68)
            {
              v27 = v68[v23 + v70];
            }
            else if (v69)
            {
              v27 = v69[v70 + v23];
            }
            else
            {
              v28 = v72;
              if (v73 <= v23 || v72 > v23)
              {
                v30 = -v26;
                v31 = v26 + v22;
                v32 = v25 - v26;
                v33 = v23 + v30;
                v34 = v33 + 64;
                if (v33 + 64 >= v71)
                  v34 = v71;
                v72 = v33;
                v73 = v34;
                if (v71 < v32)
                  v32 = v71;
                v75.length = v32 + v31;
                v75.location = v33 + v70;
                CFStringGetCharacters(theStringa, v75, buffer);
                v28 = v72;
              }
              v27 = buffer[v23 - v28];
            }
            if ((v27 & 0xF800 | 0x400) == 0xDC00)
              v24 = 1;
            else
              *(_BYTE *)(*((_QWORD *)theSet + 3) + (v27 >> 3)) &= ~(1 << (v27 & 7));
            ++v23;
            --v22;
            ++v25;
          }
          while (v13 != v23);
        }
        v35 = atomic_load(v4);
        while (1)
        {
          v36 = __ldaxr(v4);
          if (v36 != v35)
            break;
          if (__stlxr(v35 & 0xFFFFFFFFFFFFFFFBLL, v4))
            goto LABEL_63;
          v37 = 1;
LABEL_64:
          v35 = v36;
          if (v37)
          {
            if (__CFCheckForExapendedSet == 1)
              __CFCheckForExpandedSet((const char *)theSet);
            if ((v24 & 1) != 0)
              __CFApplySurrogatesInString((uint64_t)theSet, theString, (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetRemoveCharactersInRange);
            return;
          }
        }
        __clrex();
LABEL_63:
        v37 = 0;
        goto LABEL_64;
      }
      v38 = *((_QWORD *)theSet + 3);
      if (v38)
      {
        Typed = (UniChar *)(v38 + 2 * *((_QWORD *)theSet + 4));
      }
      else
      {
        v40 = CFGetAllocator(theSet);
        Typed = (UniChar *)CFAllocatorAllocateTyped(v40, 128, 0x1000040BDFB0063, 0);
      }
      v76.location = 0;
      v76.length = v13;
      CFStringGetCharacters(theString, v76, Typed);
      if (v13 < 2)
      {
        v41 = 0;
      }
      else
      {
        v41 = 0;
        v42 = &Typed[v13];
        v43 = -2 - (_QWORD)Typed;
        v44 = Typed;
        do
        {
          if ((*v44 & 0xF800 | 0x400) == 0xDC00)
          {
            memmove(v44, v44 + 1, ((uint64_t)v42-- + v43) >> 1);
            v41 = 1;
          }
          ++v44;
          v43 -= 2;
        }
        while (v44 < v42);
        v19 = v17 + v42 - Typed;
      }
      v45 = (UniChar *)*((_QWORD *)theSet + 3);
      if (!v45)
      {
        v46 = atomic_load(v4);
        while (1)
        {
          v47 = __ldaxr(v4);
          if (v47 != v46)
            break;
          if (__stlxr(v46 & 0xFFFFFFFFFFFFFF8FLL | 0x20, v4))
            goto LABEL_85;
          v48 = 1;
LABEL_86:
          v46 = v47;
          if (v48)
          {
            *((_QWORD *)theSet + 3) = Typed;
            v45 = Typed;
            goto LABEL_88;
          }
        }
        __clrex();
LABEL_85:
        v48 = 0;
        goto LABEL_86;
      }
LABEL_88:
      *((_QWORD *)theSet + 4) = v19;
      qsort(v45, v19, 2uLL, (int (__cdecl *)(const void *, const void *))chcompar);
      v49 = *((_QWORD *)theSet + 4);
      if (v49 >= 2)
      {
        v50 = 0;
        v51 = *((_QWORD *)theSet + 3);
        v52 = v49 - 1;
        v53 = (unsigned __int16 *)(v51 + 2);
        do
        {
          v55 = *v53++;
          v54 = v55;
          if (*(unsigned __int16 *)(v51 + 2 * v50) != v55)
          {
            ++v50;
            *(_WORD *)(v51 + 2 * v50) = v54;
          }
          --v52;
        }
        while (v52);
        v49 = v50 + 1;
      }
      *((_QWORD *)theSet + 4) = v49;
      v56 = atomic_load((unint64_t *)theSet + 1);
      while (1)
      {
        v57 = __ldaxr(v4);
        if (v57 != v56)
          break;
        if (__stlxr(v56 & 0xFFFFFFFFFFFFFFFBLL, v4))
          goto LABEL_99;
        v58 = 1;
LABEL_100:
        v56 = v57;
        if (v58)
        {
          if ((v41 & 1) != 0)
            __CFApplySurrogatesInString((uint64_t)theSet, theString, (void (*)(uint64_t, uint64_t, uint64_t))CFCharacterSetRemoveCharactersInRange);
          return;
        }
      }
      __clrex();
LABEL_99:
      v58 = 0;
      goto LABEL_100;
    }
  }
}

uint64_t __cf_atfork_prepare()
{
  uint64_t result;
  unsigned __int8 v1;
  unsigned __int8 v2;

  result = pthread_is_threaded_np();
  if ((_DWORD)result)
  {
    do
      v1 = __ldaxr((unsigned __int8 *)&__CF_FORK_STATE);
    while (__stlxr(v1 | 4, (unsigned __int8 *)&__CF_FORK_STATE));
  }
  else
  {
    do
      v2 = __ldaxr((unsigned __int8 *)&__CF_FORK_STATE);
    while (__stlxr(v2 & 0xFB, (unsigned __int8 *)&__CF_FORK_STATE));
  }
  return result;
}

uint64_t createPair(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7)
{
  if (a6)
    *a6 = 0;
  if (a7)
    *a7 = 0;
  pthread_mutex_lock(&CFNetworkSupport);
  if ((dword_1EDCCE510 & 1) == 0)
    initializeCFNetworkSupport();
  pthread_mutex_unlock(&CFNetworkSupport);
  return off_1EDCCE518(a1, a2, a3, a4, a5, a6, a7);
}

void *initializeCFNetworkSupport()
{
  void *result;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int16 v7;

  dword_1EDCCE510 |= 1u;
  off_1EDCCE518 = __CFLookupCFNetworkFunction("_CFSocketStreamCreatePair");
  off_1EDCCE520 = __CFLookupCFNetworkFunction("_CFErrorCreateWithStreamError");
  result = __CFLookupCFNetworkFunction("_CFStreamErrorFromCFError");
  off_1EDCCE528 = result;
  if (!off_1EDCCE518)
    result = (void *)CFLog(3, (uint64_t)CFSTR("CoreFoundation: failed to dynamically link symbol _CFSocketStreamCreatePair"), v1, v2, v3, v4, v5, v6, v7);
  if (!off_1EDCCE520)
    result = (void *)CFLog(3, (uint64_t)CFSTR("CoreFoundation: failed to dynamically link symbol _CFErrorCreateWithStreamError"), v1, v2, v3, v4, v5, v6, v7);
  if (!off_1EDCCE528)
    result = (void *)CFLog(3, (uint64_t)CFSTR("CoreFoundation: failed to dynamically link symbol _CFStreamErrorFromCFError"), v1, v2, v3, v4, v5, v6, v7);
  dword_1EDCCE510 |= 2u;
  return result;
}

void *__CFLookupCFNetworkFunction(char *__symbol)
{
  void *result;

  if (__CFLookupCFNetworkFunction_onceToken != -1)
    dispatch_once(&__CFLookupCFNetworkFunction_onceToken, &__block_literal_global_54);
  result = (void *)__CFLookupCFNetworkFunction_image;
  if (__CFLookupCFNetworkFunction_image)
    return dlsym((void *)__CFLookupCFNetworkFunction_image, __symbol);
  return result;
}

void sub_182B9A788(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

CFIndex _CFPreferencesGetUserIdentifierForUID(uid_t a1)
{
  const __CFDictionary *Mutable;
  CFIndex version;
  passwd *v3;
  int v4;
  NSObject *v5;
  CFDictionaryKeyCallBacks keyCallBacks;
  uid_t key;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  key = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&_cfprefsUsernameLock);
  Mutable = (const __CFDictionary *)_CFPreferencesGetUserIdentifierForUID__cfprefsUidToUsername;
  if (!_CFPreferencesGetUserIdentifierForUID__cfprefsUidToUsername)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, 0, 0);
    _CFPreferencesGetUserIdentifierForUID__cfprefsUidToUsername = (uint64_t)Mutable;
  }
  if (!_cfprefsUsernameToUid)
  {
    memset(&keyCallBacks, 0, 24);
    keyCallBacks.copyDescription = kCFCopyStringDictionaryKeyCallBacks.copyDescription;
    *(_OWORD *)&keyCallBacks.equal = *(_OWORD *)&kCFCopyStringDictionaryKeyCallBacks.equal;
    _cfprefsUsernameToUid = (uint64_t)CFDictionaryCreateMutable(0, 0, &keyCallBacks, 0);
    Mutable = (const __CFDictionary *)_CFPreferencesGetUserIdentifierForUID__cfprefsUidToUsername;
  }
  keyCallBacks.version = 0;
  if (CFDictionaryGetValueIfPresent(Mutable, &key, (const void **)&keyCallBacks))
  {
    version = (CFIndex)CFRetain((CFTypeRef)keyCallBacks.version);
  }
  else
  {
    *__error() = 0;
    v3 = getpwuid(key);
    if (v3)
    {
      keyCallBacks.version = (CFIndex)CFStringCreateWithFormat(0, 0, CFSTR("%s"), v3->pw_name);
      CFDictionarySetValue((CFMutableDictionaryRef)_CFPreferencesGetUserIdentifierForUID__cfprefsUidToUsername, (const void *)key, (const void *)keyCallBacks.version);
      CFDictionarySetValue((CFMutableDictionaryRef)_cfprefsUsernameToUid, (const void *)keyCallBacks.version, (const void *)key);
      version = keyCallBacks.version;
    }
    else
    {
      v4 = *__error();
      v5 = _CFPrefsClientLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        _CFPreferencesGetUserIdentifierForUID_cold_1((int *)&key, v4, v5);
      version = 0;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_cfprefsUsernameLock);
  return version;
}

void sub_182B9AD2C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  free(v2);
  free(v1);
  _Unwind_Resume(a1);
}

Boolean CFWriteStreamSetProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName, CFTypeRef propertyValue)
{
  Boolean result;
  uint64_t (*v7)(CFWriteStreamRef, CFStreamPropertyKey, CFTypeRef, _QWORD);

  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
    return -[__CFWriteStream setProperty:forKey:](stream, "setProperty:forKey:", propertyValue, propertyName);
  v7 = *(uint64_t (**)(CFWriteStreamRef, CFStreamPropertyKey, CFTypeRef, _QWORD))(*((_QWORD *)stream + 6)
                                                                                          + 104);
  if (!v7)
    return 0;
  *((_QWORD *)stream + 2) |= 0x40uLL;
  result = v7(stream, propertyName, propertyValue, *((_QWORD *)stream + 5));
  *((_QWORD *)stream + 2) &= ~0x40uLL;
  return result;
}

Boolean CFReadStreamSetProperty(CFReadStreamRef stream, CFStreamPropertyKey propertyName, CFTypeRef propertyValue)
{
  Boolean result;
  uint64_t (*v7)(CFReadStreamRef, CFStreamPropertyKey, CFTypeRef, _QWORD);

  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
    return -[__CFReadStream setProperty:forKey:](stream, "setProperty:forKey:", propertyValue, propertyName);
  v7 = *(uint64_t (**)(CFReadStreamRef, CFStreamPropertyKey, CFTypeRef, _QWORD))(*((_QWORD *)stream + 6)
                                                                                         + 104);
  if (!v7)
    return 0;
  *((_QWORD *)stream + 2) |= 0x40uLL;
  result = v7(stream, propertyName, propertyValue, *((_QWORD *)stream + 5));
  *((_QWORD *)stream + 2) &= ~0x40uLL;
  return result;
}

void boundPairReadClose(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v3;
  const void *v4;
  const void *v5;
  uint64_t v6;
  const void *v7;
  const void *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v6 = 0;
    v7 = 0;
    v3 = (pthread_mutex_t *)(a2 + 104);
    v8 = 0;
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    *(_BYTE *)(a2 + 2) = 1;
    if (!*(_BYTE *)(a2 + 50))
    {
      if (*(_WORD *)(a2 + 52))
      {
        setupScheduledStreamCloseBlock(&v6, *(CFTypeRef *)(a2 + 80), *(CFTypeRef *)(a2 + 56), *(CFTypeRef *)(a2 + 64));
      }
      else
      {
        v5 = *(const void **)(a2 + 56);
        v4 = *(const void **)(a2 + 64);
        v6 = 0;
        if (v5)
          CFRetain(v5);
        v7 = v5;
        if (v4)
          CFRetain(v4);
        v8 = v4;
      }
    }
    pthread_mutex_unlock(v3);
    performUnlockParamsAndDealloc((uint64_t)&v6);
  }
}

void performUnlockParamsAndDealloc(uint64_t a1)
{
  char *v2;
  CFTypeID v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeID TypeID;
  char *v10;
  char v11;
  __CFRunLoopSource *v12;
  __CFRunLoop *v13;
  const void *v14;
  const void *v15;

  v2 = *(char **)a1;
  if (v2)
  {
    v3 = CFGetTypeID(v2);
    TypeID = CFReadStreamGetTypeID();
    v10 = *(char **)a1;
    if (v3 == TypeID)
    {
      CFReadStreamSignalEvent(v10, 2uLL, 0, v4, v5, v6, v7, v8);
      v11 = 0;
      goto LABEL_6;
    }
    CFWriteStreamSignalEvent(v10, 0x10uLL, 0, v4, v5, v6, v7, v8);
  }
  v11 = 1;
LABEL_6:
  v12 = *(__CFRunLoopSource **)(a1 + 8);
  if (v12)
    CFRunLoopSourceSignal(v12);
  if (*(_QWORD *)a1)
  {
    if ((v11 & 1) != 0)
      _wakeWriteStreamScheduledRunLoops();
    else
      _wakeReadStreamScheduledRunLoops();
  }
  v13 = *(__CFRunLoop **)(a1 + 16);
  if (v13)
    CFRunLoopWakeUp(v13);
  if (*(_QWORD *)a1)
  {
    CFRelease(*(CFTypeRef *)a1);
    *(_QWORD *)a1 = 0;
  }
  v14 = *(const void **)(a1 + 8);
  if (v14)
  {
    CFRelease(v14);
    *(_QWORD *)(a1 + 8) = 0;
  }
  v15 = *(const void **)(a1 + 16);
  if (v15)
  {
    CFRelease(v15);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

uint64_t CFReadStreamCreateWithData(const __CFAllocator *a1, const __CFData *a2)
{
  CFDataRef Copy;
  uint64_t v4;
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  v6[1] = 0;
  v6[2] = 0;
  Copy = CFDataCreateCopy(a1, a2);
  v6[0] = Copy;
  v4 = _CFStreamCreateWithConstantCallbacks((__objc2_class **)a1, (uint64_t)v6, readDataCallBacks, 1);
  CFRelease(Copy);
  return v4;
}

void deletionStreamCallback(uint64_t a1, uint64_t a2, uint64_t a3, const __CFArray *a4, uint64_t a5)
{
  __CFArray *Mutable;
  CFIndex v8;
  char v9;
  __objc2_class **p_superclass;
  const void *ValueAtIndex;
  const __CFArray *Value;
  const __CFArray *v13;
  __objc2_class **v14;
  uint64_t Count;
  CFIndex i;
  const __CFArray *v17;
  CFIndex FirstIndexOfValue;
  CFIndex v19;
  CFIndex v20;
  CFIndex v21;
  uint64_t v22;
  void *v23;
  _QWORD v25[6];
  CFRange v26;
  CFRange v27;

  v25[5] = *MEMORY[0x1E0C80C00];
  dispatch_assert_queue_V2((dispatch_queue_t)fseventsQueue);
  os_unfair_lock_lock((os_unfair_lock_t)&dirWatcherLock);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  if (a3)
  {
    v8 = 0;
    v9 = 0;
    p_superclass = &OBJC_METACLASS___CFPDMirroredSource.superclass;
    do
    {
      if ((~*(_DWORD *)(a5 + 4 * v8) & 0x20200) == 0)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a4, v8);
        Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)dirWatcherTargets, ValueAtIndex);
        if (Value)
        {
          v13 = Value;
          v14 = p_superclass;
          Count = CFArrayGetCount(Value);
          if (Count >= 1)
          {
            for (i = 0; i != Count; ++i)
              *((_BYTE *)CFArrayGetValueAtIndex(v13, i) + 141) = 0;
            v9 = 1;
          }
          v27.location = 0;
          v27.length = Count;
          CFArrayAppendArray(Mutable, v13, v27);
          p_superclass = v14;
        }
        CFDictionaryRemoveValue((CFMutableDictionaryRef)dirWatcherTargets, ValueAtIndex);
        v17 = (const __CFArray *)p_superclass[46];
        v26.length = CFArrayGetCount(v17);
        v26.location = 0;
        FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v17, v26, ValueAtIndex);
        if (FirstIndexOfValue != -1)
          CFArrayRemoveValueAtIndex((CFMutableArrayRef)p_superclass[46], FirstIndexOfValue);
      }
      ++v8;
    }
    while (v8 != a3);
    if ((v9 & 1) != 0)
      _onqueue_locked_CFPrefsRecreateFileWatcher();
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&dirWatcherLock);
  v19 = CFArrayGetCount(Mutable);
  if (v19 >= 1)
  {
    v20 = v19;
    v21 = 0;
    v22 = MEMORY[0x1E0C809B0];
    do
    {
      v23 = (void *)CFArrayGetValueAtIndex(Mutable, v21);
      v25[0] = v22;
      v25[1] = 3221225472;
      v25[2] = __deletionStreamCallback_block_invoke;
      v25[3] = &unk_1E12E5C68;
      v25[4] = v23;
      objc_msgSend(v23, "lockedSync:", v25);
      ++v21;
    }
    while (v20 != v21);
  }
  CFRelease(Mutable);
}

CFIndex CFBitVectorGetLastIndexOfBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  CFIndex v3;
  int v4;

  v3 = range.length + range.location - 1;
  while (range.length)
  {
    --range.length;
    v4 = (*(unsigned __int8 *)(*((_QWORD *)bv + 4) + v3 / 8) >> (~(_BYTE)v3 & 7)) & 1;
    --v3;
    if (v4 == value)
      return v3 + 1;
  }
  return -1;
}

void _CFPreferencesAddSuitePreferencesToAppWithContainer(const void *a1, const void *a2, uint64_t a3)
{
  const os_unfair_lock *v6;
  os_unfair_lock *v7;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v6 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v6 = (const os_unfair_lock *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v7 = (os_unfair_lock *)v6;
  -[_CFXPreferences addSuitePreferences:toAppIdentifier:container:](v6, a2, a1, a3);

}

void sub_182B9B91C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  char v10;
  uint64_t v11;
  va_list va;

  va_start(va, a10);
  if ((v10 & 1) != 0)
    objc_end_catch();
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 88), 8);
  _Unwind_Resume(a1);
}

CFOptionFlags CFSocketGetSocketFlags(CFSocketRef s)
{
  unint64_t v2;

  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  return *((unsigned __int8 *)s + 16);
}

void CFStringTrim(CFMutableStringRef theString, CFStringRef trimString)
{
  uint64_t *p_info;
  char v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char **p_data;
  char *v19;
  CFIndex length;
  uint64_t v21;
  CFIndex v22;
  CFIndex v23;
  unint64_t v24;
  char v25;
  char **v26;
  char *v27;
  char v28;
  uint64_t v29;
  uint64_t *v30;
  unint64_t v31;
  char *v32;
  char v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  char v39;
  CFRange result;
  CFIndex v41;
  CFIndex v42;
  uint64_t v43;
  CFRange v44;
  CFRange v45;
  CFRange v46;

  v43 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfTrim:](theString, "_cfTrim:", trimString);
  }
  else
  {
    result.location = 0;
    result.length = 0;
    p_info = &theString->info;
    v5 = atomic_load((unint64_t *)&theString->info);
    if ((v5 & 1) != 0)
    {
      v14 = atomic_load((unint64_t *)p_info);
      v15 = v14 & 5;
      v16 = atomic_load((unint64_t *)p_info);
      v17 = v16 & 0x60;
      if (v15 == 4)
      {
        p_data = &theString->data;
        if (v17)
        {
          v19 = *p_data;
        }
        else
        {
          v21 = atomic_load((unint64_t *)&theString->info);
          v19 = (char *)&p_data[(v21 & 5) != 4];
        }
        length = *v19;
      }
      else if ((v16 & 0x60) != 0)
      {
        length = theString->length;
      }
      else
      {
        length = (CFIndex)theString->data;
      }
      v44.location = 0;
      v44.length = length;
      if (CFStringFindWithOptionsAndLocale(theString, trimString, v44, 8uLL, 0, &result))
      {
        do
        {
          v22 = result.length + result.location;
          v23 = length - (result.length + result.location);
          v45.location = result.length + result.location;
          v45.length = v23;
        }
        while (CFStringFindWithOptionsAndLocale(theString, trimString, v45, 8uLL, 0, &result));
      }
      else
      {
        v22 = 0;
        v23 = length;
      }
      if (v22 >= length)
      {
        v41 = 0;
        v42 = length;
      }
      else
      {
        v24 = atomic_load((unint64_t *)&theString->info);
        v25 = atomic_load((unint64_t *)&theString->info);
        v26 = &theString->data;
        if ((v25 & 0x60) != 0)
        {
          v27 = *v26;
        }
        else
        {
          v28 = atomic_load((unint64_t *)&theString->info);
          v27 = (char *)&v26[(v28 & 5) != 4];
        }
        v29 = (v24 >> 4) & 1;
        v30 = &theString->info;
        v31 = atomic_load((unint64_t *)&theString->info);
        v32 = &v27[(v31 >> 2) & 1];
        if (CFStringGetLength(trimString) < v23)
        {
          while (1)
          {
            v46.location = v22;
            v46.length = v23;
            if (!CFStringFindWithOptionsAndLocale(theString, trimString, v46, 0xCuLL, 0, &result))
              break;
            v23 = result.location - v22;
          }
        }
        memmove(v32, &v32[v22 << v29], v23 << v29);
        v33 = atomic_load((unint64_t *)v30);
        v34 = v33 & 5;
        v35 = atomic_load((unint64_t *)v30);
        v36 = v35 & 0x60;
        if (v34 == 4)
        {
          if (v36)
          {
            v37 = *v26;
          }
          else
          {
            v39 = atomic_load((unint64_t *)&theString->info);
            v37 = (char *)&v26[(v39 & 5) != 4];
          }
          v38 = *v37;
        }
        else if (v36)
        {
          v38 = theString->length;
        }
        else
        {
          v38 = (uint64_t)*v26;
        }
        v41 = v23;
        v42 = v38 - v23;
      }
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v41, 1, 0, 0);
    }
    else
    {
      v6 = _CFOSLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
        CFStringTrim_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
}

CFArrayRef __CFDateFormatterCopySymbolsArray(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFIndex v10;
  unint64_t v11;
  uint64_t v12;
  const void **v13;
  size_t v14;
  const void **v15;
  int Symbols;
  void *v17;
  CFArrayRef i;
  uint64_t v20;
  int v21;
  UniChar v22[768];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v21 = 0;
  v6 = __cficu_udat_countSymbols(a1, a2);
  v8 = (int)v6;
  if ((int)v6 <= (uint64_t)a3)
    return CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeArrayCallBacks);
  v20 = (uint64_t)&v20;
  v9 = a3;
  v10 = (int)v6 - (unint64_t)a3;
  MEMORY[0x1E0C80A78](v6, v7);
  v13 = (const void **)((char *)&v20 - v12);
  if (v11 >= 0x200)
    v14 = 512;
  else
    v14 = v11;
  bzero((char *)&v20 - v12, v14);
  if (v10 >= 1)
  {
    v15 = v13;
    do
    {
      v21 = 0;
      Symbols = __cficu_udat_getSymbols(a1, a2, v9, v22, 768, &v21);
      if ((unint64_t)v10 > 0x300
        || v21 > 0
        || (v17 = (void *)CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v22, Symbols)) == 0)
      {
        v17 = (void *)CFRetain(CFSTR("<error>"));
      }
      *v15++ = v17;
      ++v9;
    }
    while (v8 != v9);
  }
  for (i = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v10, &kCFTypeArrayCallBacks); v10; --v10)
    CFRelease(v13[v10 - 1]);
  return i;
}

void CFSocketSetSocketFlags(CFSocketRef s, CFOptionFlags flags)
{
  char v2;
  unint64_t v4;

  v2 = flags;
  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  *((_BYTE *)s + 16) = v2;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)s + 24));
}

CFArrayRef CFBundleCreateBundlesFromDirectory(CFAllocatorRef allocator, CFURLRef directoryURL, CFStringRef bundleType)
{
  __CFArray *Mutable;
  __CFArray *v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex i;
  const __CFURL *ValueAtIndex;
  CFBundleRef v11;

  Mutable = CFArrayCreateMutable(allocator, 0, &kCFTypeArrayCallBacks);
  v5 = _CFCreateContentsOfDirectory((uint64_t)allocator, 0);
  if (v5)
  {
    v6 = v5;
    Count = CFArrayGetCount(v5);
    if (Count >= 1)
    {
      v8 = Count;
      for (i = 0; i != v8; ++i)
      {
        ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v6, i);
        v11 = CFBundleCreate(allocator, ValueAtIndex);
        if (v11)
          CFArrayAppendValue(Mutable, v11);
      }
    }
    CFRelease(v6);
  }
  return Mutable;
}

__CFArray *_CFCreateContentsOfDirectory(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  const char *v3;
  const void *v4;
  const void *v5;
  const __CFURL *v6;
  const __CFURL *v7;
  UInt8 *v8;
  const __CFAllocator *v9;
  size_t v10;
  const __CFString *v11;
  const __CFString *v12;
  uint64_t Length;
  CFIndex v14;
  CFStringEncoding v15;
  char *v16;
  char *v17;
  int v18;
  char v19;
  DIR *v20;
  DIR *v21;
  __CFArray *Mutable;
  dirent *v23;
  unsigned int v24;
  size_t v25;
  char *d_name;
  char *v27;
  int v28;
  char *v29;
  char *v30;
  char *v31;
  unsigned int v32;
  BOOL v33;
  int v34;
  Boolean v36;
  BOOL v37;
  CFURLRef v38;
  int v39;
  const __CFString *v40;
  CFIndex bufLen;
  const __CFString *cf;
  int v44;
  int v45;
  char v46;
  dirent *v47;
  CFIndex usedBufLen;
  stat v49;
  char v50[1024];
  dirent v51;
  UInt8 v52[1026];
  UInt8 buffer;
  _BYTE v54[1041];
  CFRange v55;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v7 = v6;
  v8 = (UInt8 *)v3;
  v9 = (const __CFAllocator *)v2;
  *(_QWORD *)&v54[1025] = *MEMORY[0x1E0C80C00];
  if (v3)
  {
    v10 = strlen(v3);
    if (!v5)
    {
LABEL_15:
      v12 = 0;
      v18 = 0;
      usedBufLen = 0;
      v19 = 1;
      if (v8)
        goto LABEL_20;
      goto LABEL_18;
    }
  }
  else
  {
    v10 = 0;
    if (!v4)
      goto LABEL_15;
  }
  v11 = (const __CFString *)CFRetain(v5);
  if (!v11)
    goto LABEL_15;
  v12 = v11;
  Length = CFStringGetLength(v11);
  usedBufLen = Length;
  if (Length < 1)
    goto LABEL_17;
  v14 = Length;
  v15 = CFStringFileSystemEncoding();
  v55.location = 0;
  v55.length = v14;
  CFStringGetBytes(v12, v55, v15, 0, 0, &buffer, 1024, &usedBufLen);
  v54[usedBufLen - 1] = 0;
  v16 = buffer == 46 ? v54 : (char *)&buffer;
  v17 = strchr(v16, 46);
  if (v17)
  {
    v18 = 0;
    do
    {
      ++v18;
      v17 = strchr(v17 + 1, 46);
    }
    while (v17);
    v19 = 0;
    if (v8)
      goto LABEL_20;
  }
  else
  {
LABEL_17:
    v19 = 0;
    v18 = 0;
    if (v8)
      goto LABEL_20;
  }
LABEL_18:
  if (!CFURLGetFileSystemRepresentation(v7, 1u, v52, 1024))
  {
    if ((v19 & 1) != 0)
      return 0;
    v40 = v12;
LABEL_90:
    CFRelease(v40);
    return 0;
  }
  v8 = v52;
  v10 = strlen((const char *)v52);
LABEL_20:
  memset(&v51, 0, 512);
  v47 = 0;
  v46 = v19;
  if (__CFProphylacticAutofsAccess)
    v45 = open("/dev/autofs_nowait", 0);
  else
    v45 = -1;
  v20 = opendir((const char *)v8);
  if (!v20)
  {
    if ((v19 & 1) == 0)
      CFRelease(v12);
    if (v45 != -1)
      close(v45);
    return 0;
  }
  v21 = v20;
  cf = v12;
  Mutable = CFArrayCreateMutable(v9, 0, &kCFTypeArrayCallBacks);
  if (!readdir_r(v21, &v51, &v47))
  {
    bufLen = v10;
    v23 = v47;
    if (v47)
    {
      v44 = 0;
      while (1)
      {
        v24 = strlen(v23->d_name);
        if (v23->d_name[0] != 46 || v24 != 1 && (v24 != 2 || v23->d_name[1] != 46))
        {
          v25 = usedBufLen;
          if (usedBufLen <= v24)
          {
            if (usedBufLen < 1)
              goto LABEL_52;
            if (v23->d_name[v24 - 1] != 46)
            {
              d_name = v23->d_name;
              if (!v18)
              {
                v30 = strrchr(d_name, 46);
                goto LABEL_47;
              }
              v27 = strchr(d_name, 46);
              if (v27)
              {
                do
                {
                  v28 = 0;
                  v29 = v27;
                  while (1)
                  {
                    v29 = strchr(v29, 46);
                    if (!v29)
                      break;
                    if (v18 == ++v28)
                    {
                      v28 = v18;
                      break;
                    }
                  }
                  if (v28 == v18)
                    v30 = v27;
                  else
                    v30 = 0;
                  v31 = strchr(v27, 46);
                  if (!v31)
                    break;
                  v27 = v31;
                }
                while (!v30);
LABEL_47:
                if (!v30)
                  goto LABEL_69;
                if (buffer != 46)
                  ++v30;
                if (strlen(v30) != v25 || strncmp(v30, (const char *)&buffer, v25))
                  goto LABEL_69;
LABEL_52:
                if (!v7)
                {
                  v44 = 1;
                  v7 = CFURLCreateFromFileSystemRepresentation(v9, v8, bufLen, 1u);
                  v23 = v47;
                }
                v32 = ((v23->d_type >> 1) | (v23->d_type << 7));
                v33 = v32 > 7;
                v34 = (1 << v32) & 0xA5;
                if (v33 || v34 == 0)
                {
                  v36 = 0;
                }
                else if (v23->d_type == 4)
                {
                  v36 = 1;
                }
                else
                {
                  memset(&v49, 0, sizeof(v49));
                  __strlcpy_chk();
                  __strlcat_chk();
                  __strlcat_chk();
                  if (stat(v50, &v49))
                    v37 = 0;
                  else
                    v37 = (v49.st_mode & 0xF000) == 0x4000;
                  v36 = v37;
                  v23 = v47;
                }
                v38 = CFURLCreateFromFileSystemRepresentationRelativeToBase(v9, (const UInt8 *)v23->d_name, v23->d_namlen, v36, v7);
                CFArrayAppendValue(Mutable, v38);
                CFRelease(v38);
              }
            }
          }
        }
LABEL_69:
        if (!readdir_r(v21, &v51, &v47))
        {
          v23 = v47;
          if (v47)
            continue;
        }
        goto LABEL_77;
      }
    }
  }
  v44 = 0;
LABEL_77:
  v39 = closedir(v21);
  if (v45 != -1)
    close(v45);
  if (v39)
  {
    CFRelease(Mutable);
    if (v44)
      CFRelease(v7);
    v40 = cf;
    if ((v46 & 1) != 0)
      return 0;
    goto LABEL_90;
  }
  if ((v46 & 1) == 0)
    CFRelease(cf);
  if (v44)
    CFRelease(v7);
  return Mutable;
}

void CFWriteStreamScheduleWithRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      -[__CFWriteStream _scheduleInCFRunLoop:forMode:](stream, "_scheduleInCFRunLoop:forMode:", runLoop, runLoopMode);
    else
      -[__CFWriteStream scheduleInRunLoop:forMode:](stream, "scheduleInRunLoop:forMode:", _CFRunLoopGet2((uint64_t)runLoop), runLoopMode);
  }
  else
  {
    _CFStreamScheduleWithRunLoop((char *)stream, runLoop, runLoopMode);
  }
}

void _cfmp_record_nsmachport_is_interested(unsigned __int8 a1, int a2)
{
  const __CFSet *v4;
  _BYTE *Value;
  _DWORD v6[2];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (_cfmp_records_oGuard != -1)
      dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
    v4 = (const __CFSet *)_cfmp_records_oRecords;
    os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
    v6[0] = a2;
    v6[1] = a1;
    Value = CFSetGetValue(v4, v6);
    if (Value)
      Value[5] |= 0x20u;
    os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
  }
}

void _CFPreferencesRemoveSuitePreferencesFromAppWithContainer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const os_unfair_lock *v6;
  os_unfair_lock *v7;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v6 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v6 = (const os_unfair_lock *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v7 = (os_unfair_lock *)v6;
  -[_CFXPreferences removeSuite:fromApp:withContainer:](v6, a2, a1, a3);

}

void sub_182B9CCCC(_Unwind_Exception *exception_object)
{
  char v1;

  if ((v1 & 1) != 0)
    objc_end_catch();
  _Unwind_Resume(exception_object);
}

void sub_182B9CCF8(void *exc_buf, int a2)
{
  int v2;

  if (a2)
  {
    objc_begin_catch(exc_buf);
    if (!v2)
      JUMPOUT(0x182B9CC8CLL);
    JUMPOUT(0x182B9CC84);
  }
  JUMPOUT(0x182B9CCECLL);
}

uint64_t _CFURLComponentsSetPort(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setPort:", a2);
  return 1;
}

void sub_182B9CD30(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
  JUMPOUT(0x182B9CD28);
}

void ____initDayChangedNotification_block_invoke()
{
  qos_class_t v0;
  NSObject *global_queue;

  v0 = qos_class_main();
  global_queue = dispatch_get_global_queue(v0, 2uLL);
  __CFMidnightTimer = (uint64_t)dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, global_queue);
  dispatch_source_set_event_handler((dispatch_source_t)__CFMidnightTimer, &__block_literal_global_2);
  __postAndResetMidnight(0, 0);
  dispatch_resume((dispatch_object_t)__CFMidnightTimer);
}

void __postAndResetMidnight(int a1, int a2)
{
  uint64_t v4;
  __CFNotificationCenter *LocalCenter;
  unint64_t v6;
  NSObject *v7;
  dispatch_time_t v8;
  timespec v9;
  tm v10;
  timeval v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11.tv_sec = 0;
  *(_QWORD *)&v11.tv_usec = 0;
  memset(&v10, 0, sizeof(v10));
  gettimeofday(&v11, 0);
  localtime_r(&v11.tv_sec, &v10);
  v4 = (v10.tm_gmtoff + v11.tv_sec) / 86400;
  if (a1 && v4 < __CFLastLocalMidnightDay || a2 && v4 > __CFLastLocalMidnightDay)
  {
    LocalCenter = CFNotificationCenterGetLocalCenter();
    do
      v6 = __ldaxr((unint64_t *)&__CFMidnightNoteCount);
    while (__stlxr(v6 + 1, (unint64_t *)&__CFMidnightNoteCount));
    CFNotificationCenterPostNotification(LocalCenter, CFSTR("NSCalendarDayChangedNotification"), 0, 0, 1u);
  }
  gettimeofday(&v11, 0);
  localtime_r(&v11.tv_sec, &v10);
  __CFLastLocalMidnightDay = (v11.tv_sec + v10.tm_gmtoff) / 86400;
  v9.tv_sec = 86400 * __CFLastLocalMidnightDay - v10.tm_gmtoff + 86400;
  v9.tv_nsec = 0;
  v7 = __CFMidnightTimer;
  v8 = dispatch_walltime(&v9, 0);
  dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0xB2D05E00uLL);
}

void _CFXNotificationSetSuspended(uint64_t a1, int a2)
{
  unint64_t *v4;
  char v5;
  char v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  char v11;
  unint64_t v12;
  int v13;
  xpc_object_t v14;
  _xpc_connection_s *v15;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    v4 = (unint64_t *)(a1 + 8);
    v5 = atomic_load((unint64_t *)(a1 + 8));
    if ((v5 & 2) != 0)
    {
      v6 = atomic_load(v4);
      if ((v6 & 2) == 0 || (__CFIsDistNoteDaemon & 1) == 0)
      {
        v7 = atomic_load(v4);
        if (((v7 >> 3) & 1) != a2)
        {
          v8 = atomic_load(v4);
          if ((a2 & 1) != 0)
          {
            v9 = "suspend";
            while (1)
            {
              v10 = __ldaxr(v4);
              if (v10 != v8)
                break;
              if (__stlxr(v8 | 8, v4))
                goto LABEL_16;
              v11 = 1;
LABEL_17:
              v8 = v10;
              if ((v11 & 1) != 0)
                goto LABEL_27;
            }
            __clrex();
LABEL_16:
            v11 = 0;
            goto LABEL_17;
          }
          v9 = "unsuspend";
          while (1)
          {
            v12 = __ldaxr(v4);
            if (v12 != v8)
              break;
            if (__stlxr(v8 & 0xFFFFFFFFFFFFFFF7, v4))
              goto LABEL_25;
            v13 = 1;
LABEL_26:
            v8 = v12;
            if (v13)
            {
LABEL_27:
              v14 = xpc_dictionary_create(0, 0, 0);
              xpc_dictionary_set_string(v14, "method", v9);
              xpc_dictionary_set_uint64(v14, "version", 1uLL);
              v15 = *(_xpc_connection_s **)(a1 + 24);
              _CFSuddenTerminationDisable();
              xpc_connection_send_message(v15, v14);
              xpc_connection_send_barrier(v15, &__block_literal_global_99);
              xpc_release(v14);
              return;
            }
          }
          __clrex();
LABEL_25:
          v13 = 0;
          goto LABEL_26;
        }
      }
    }
    else
    {
      __break(1u);
    }
  }
}

void CFCharacterSetIntersect(CFMutableCharacterSetRef theSet, CFCharacterSetRef theOtherSet)
{
  __objc2_class **v2;
  uint64_t v3;
  uint64_t v4;
  __objc2_class **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  char v13;
  char v14;
  char v15;
  char v16;
  __objc2_class *v17;
  unsigned int v18;
  char v19;
  uint64_t v20;
  const __CFData *BitmapRepresentation;
  const __CFData *v22;
  const UInt8 *BytePtr;
  const UInt8 *v24;
  uint64_t v25;
  __objc2_class *v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  __objc2_class *v32;
  unsigned int v33;
  char v34;
  __objc2_class *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t j;
  unint64_t v39;
  unint64_t v40;
  int v41;
  uint64_t v42;
  const __CFCharacterSet *Mutable;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  __CFCharacterSet *v48;
  __objc2_class *v49;
  __objc2_class *v50;
  CFAllocatorRef v51;
  uint64_t v52;
  __objc2_class *v53;
  int v54;
  CFMutableCharacterSetRef v55;
  __objc2_class *v56;
  CFAllocatorRef v57;
  uint64_t v58;
  CFAllocatorRef v59;
  uint64_t v60;
  const __CFAllocator *v61;
  unint64_t *v62;
  __objc2_class *v63;
  uint64_t v64;
  unint64_t v65;
  unsigned int v66;
  CFMutableCharacterSetRef *v67;
  const __CFAllocator *v68;
  __objc2_class *v69;
  __objc2_class *v70;
  int v71;
  char v72;
  __objc2_class *v73;
  CFAllocatorRef v74;
  uint64_t v75;
  CFAllocatorRef v76;
  uint64_t v77;
  int superclass;
  char v79;
  char v80;
  const __CFAllocator *v81;
  CFMutableCharacterSetRef v82;
  __objc2_class *v83;
  _BOOL4 v84;
  __objc2_class *v85;
  uint64_t k;
  __objc2_class *v87;
  char v88;
  char v89;
  char v90;
  char v91;
  const __CFAllocator *v92;
  unint64_t v93;
  unint64_t v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  int v101;
  uint64_t i;
  __objc2_class *v103;
  __objc2_class *v104;
  uint64_t v105;
  uint64_t n;
  __objc2_class *v107;
  uint64_t v108;
  unint64_t v109;
  __objc2_class *v110;
  int v111;
  uint64_t v112;
  int BitmapForPlane;
  uint64_t v114;
  uint64_t v115;
  char v116;
  int v117;
  BOOL v118;
  __objc2_class *v119;
  __objc2_class *v120;
  CFAllocatorRef v121;
  uint64_t v122;
  CFAllocatorRef v123;
  uint64_t v124;
  int v125;
  __objc2_class *v126;
  uint64_t m;
  __objc2_class *v128;
  const __CFAllocator *v129;
  const __CFAllocator *v130;
  char v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  int v135;
  char v136;
  unint64_t v137;
  uint64_t v138;
  unint64_t v139;
  int v140;
  char v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  int v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  int v150;
  unint64_t *v151;
  const __CFAllocator *v152;
  unint64_t *Copy;
  __objc2_class *v154;
  __objc2_class *isa;
  CFAllocatorRef v156;
  uint64_t v157;
  CFAllocatorRef v158;
  uint64_t v159;
  __objc2_class *v160;
  int v161;
  uint64_t v162;
  uint64_t Typed;
  CFAllocatorRef v164;
  char v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  char v170;
  unsigned int v171;
  uint64_t v172;
  int v173;
  __CFCharacterSet *v174;
  __objc2_class *v175;
  __objc2_class *v176;
  CFAllocatorRef v177;
  uint64_t v178;
  __objc2_class *v179;
  __CFCharacterSet *v180;
  const void *v181;
  __objc2_class *v182;
  int v183;
  CFAllocatorRef v184;
  uint64_t v185;
  CFAllocatorRef v186;
  uint64_t v187;
  BOOL v188;
  __objc2_class *v189;
  uint64_t v190;
  uint64_t v191;
  const __CFAllocator *v192;
  CFMutableCharacterSetRef v193;
  CFAllocatorRef v194;
  uint64_t v195;
  const __CFAllocator *v196;
  unint64_t *v197;
  unint64_t v198;
  unsigned int v199;
  char v200;
  __objc2_class *v201;
  CFAllocatorRef v202;
  uint64_t v203;
  CFAllocatorRef v204;
  uint64_t v205;
  __objc2_class *v206;
  uint64_t ii;
  __objc2_class *v208;
  const __CFAllocator *v209;
  const __CFAllocator *v210;
  unsigned int v211;
  __objc2_class *v212;
  __objc2_class *v213;
  CFAllocatorRef v214;
  const void *v215;
  size_t v216;
  CFAllocatorRef v217;
  uint64_t v218;
  int32x4_t v219;
  char *v220;
  int32x4_t v221;
  int8x16_t v222;
  uint8x16_t v223;
  int32x4_t v224;
  int32x4_t v225;
  int32x4_t v226;
  int8x16_t v227;
  int16x8_t v228;
  int16x8_t v229;
  size_t v230;
  CFAllocatorRef v231;
  _BOOL4 v232;
  CFCharacterSetRef theOtherSeta;
  int8x16_t __b[512];
  uint64_t v235;

  v2 = (__objc2_class **)MEMORY[0x1E0C80A78](theSet, theOtherSet);
  v4 = v3;
  v5 = v2;
  v235 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x19uLL, v2))
  {
    objc_msgSend(v5, "formIntersectionWithCharacterSet:", v4);
    return;
  }
  v12 = (unint64_t *)(v5 + 1);
  v13 = atomic_load((unint64_t *)v5 + 1);
  if ((v13 & 1) == 0)
  {
    CFLog(3, (uint64_t)CFSTR("%s: Immutable character set passed to mutable function"), v6, v7, v8, v9, v10, v11, (__int16)"void CFCharacterSetIntersect(CFMutableCharacterSetRef, CFCharacterSetRef)");
    if (dyld_program_sdk_at_least())
      CFCharacterSetIntersect_cold_1();
  }
  v14 = atomic_load(v12);
  if ((v14 & 0x70) == 0)
  {
    v15 = atomic_load(v12);
    if ((v15 & 1) == 0)
    {
      v16 = atomic_load(v12);
      if ((v16 & 8) == 0 && CFCharacterSetGetPredefined((CFCharacterSetPredefinedSet)v5[3]) == (CFCharacterSetRef)v5)
        return;
    }
  }
  v17 = v5[5];
  if (!v17 || !LODWORD(v17->superclass) && !BYTE5(v17->superclass))
  {
    v18 = atomic_load(v12);
    switch((v18 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (!v5[4])
          goto LABEL_17;
        break;
      case 3u:
      case 4u:
        if (v5[3])
          break;
LABEL_17:
        v19 = atomic_load(v12);
        if ((v19 & 8) != 0)
          break;
        return;
      default:
        break;
    }
  }
  if (!CF_IS_OBJC(0x19uLL, (__objc2_class **)v4))
  {
    v20 = 0;
    goto LABEL_34;
  }
  v20 = objc_msgSend((id)v4, "_expandedCFCharacterSet");
  if (v20)
  {
LABEL_34:
    if (v20)
      v4 = v20;
    v30 = *(_QWORD *)(v4 + 40);
    if (!v30 || !*(_DWORD *)(v30 + 8) && !*(_BYTE *)(v30 + 13))
    {
      v31 = atomic_load((unint64_t *)(v4 + 8));
      switch((v31 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(_QWORD *)(v4 + 32))
            goto LABEL_41;
          goto LABEL_141;
        case 3u:
        case 4u:
          if (*(_QWORD *)(v4 + 24))
            goto LABEL_41;
LABEL_141:
          v88 = atomic_load((unint64_t *)(v4 + 8));
          if ((v88 & 8) != 0)
            goto LABEL_360;
          v89 = atomic_load(v12);
          if ((v89 & 0x70) == 0x20 && v5[3]
            || (v90 = atomic_load(v12), (v90 & 0x70) == 0x30) && v5[3]
            || (v91 = atomic_load(v12), (v91 & 0x70) == 0x40) && v5[3])
          {
            v92 = CFGetAllocator(v5);
            CFAllocatorDeallocate(v92, v5[3]);
          }
          v93 = atomic_load(v12);
          break;
        default:
          goto LABEL_41;
      }
      while (1)
      {
        v94 = __ldaxr(v12);
        if (v94 != v93)
          break;
        if (__stlxr(v93 & 0xFFFFFFFFFFFFFF8FLL | 0x30, v12))
          goto LABEL_154;
        v95 = 1;
LABEL_155:
        v93 = v94;
        if (v95)
        {
          v5[3] = 0;
          v96 = atomic_load((unint64_t *)v5 + 1);
          while (1)
          {
            v97 = __ldaxr(v12);
            if (v97 != v96)
              break;
            if (__stlxr(v96 & 0xFFFFFFFFFFFFFFF7, v12))
              goto LABEL_161;
            v98 = 1;
LABEL_162:
            v96 = v97;
            if (v98)
            {
              v5[2] = 0;
              v99 = atomic_load((unint64_t *)v5 + 1);
              while (1)
              {
                v100 = __ldaxr(v12);
                if (v100 != v99)
                  break;
                if (__stlxr(v99 | 4, v12))
                  goto LABEL_168;
                v101 = 1;
LABEL_169:
                v99 = v100;
                if (v101)
                {
                  if (v5[5])
                  {
                    for (i = 0; i != 16; ++i)
                    {
                      v103 = v5[5];
                      if (((LODWORD(v103->superclass) >> i) & 2) != 0)
                        CFRelease(*((CFTypeRef *)&v103->isa->isa + i));
                    }
LABEL_218:
                    v129 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v129, v5[5]->isa);
                    v130 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v130, v5[5]);
                    v5[5] = 0;
                  }
                  goto LABEL_360;
                }
              }
              __clrex();
LABEL_168:
              v101 = 0;
              goto LABEL_169;
            }
          }
          __clrex();
LABEL_161:
          v98 = 0;
          goto LABEL_162;
        }
      }
      __clrex();
LABEL_154:
      v95 = 0;
      goto LABEL_155;
    }
LABEL_41:
    v32 = v5[5];
    if (!v32 || !LODWORD(v32->superclass) && !BYTE5(v32->superclass))
    {
      v33 = atomic_load(v12);
      switch((v33 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (v5[4])
            goto LABEL_46;
          goto LABEL_220;
        case 3u:
        case 4u:
          if (v5[3])
            goto LABEL_46;
LABEL_220:
          v131 = atomic_load((unint64_t *)(v4 + 8));
          v132 = v131 & 0x70;
          v133 = atomic_load(v12);
          break;
        default:
          goto LABEL_46;
      }
      while (1)
      {
        v134 = __ldaxr(v12);
        if (v134 != v133)
          break;
        if (__stlxr(v133 & 0xFFFFFFFFFFFFFF8FLL | v132, v12))
          goto LABEL_225;
        v135 = 1;
LABEL_226:
        v133 = v134;
        if (v135)
        {
          v136 = atomic_load((unint64_t *)(v4 + 8));
          v137 = atomic_load(v12);
          v138 = v136 & 4;
          while (1)
          {
            v139 = __ldaxr(v12);
            if (v139 != v137)
              break;
            if (__stlxr(v137 & 0xFFFFFFFFFFFFFFFBLL | v138, v12))
              goto LABEL_232;
            v140 = 1;
LABEL_233:
            v137 = v139;
            if (v140)
            {
              v141 = atomic_load((unint64_t *)(v4 + 8));
              v142 = atomic_load(v12);
              v143 = v141 & 8;
              while (1)
              {
                v144 = __ldaxr(v12);
                if (v144 != v142)
                  break;
                if (__stlxr(v142 & 0xFFFFFFFFFFFFFFF7 | v143, v12))
                  goto LABEL_239;
                v145 = 1;
LABEL_240:
                v142 = v144;
                if (v145)
                {
                  v5[2] = *(__objc2_class **)(v4 + 16);
                  v146 = *(_QWORD *)(v4 + 40);
                  if (!v146 || !*(_DWORD *)(v146 + 8))
                    goto LABEL_349;
                  v147 = 0;
                  v148 = 1;
                  while (1)
                  {
                    v149 = *(_QWORD *)(v4 + 40);
                    if (v149)
                    {
                      v150 = 1 << v148;
                      if ((*(_DWORD *)(v149 + 8) & (1 << v148)) != 0
                        && *(unsigned __int8 *)(v149 + 12) >= v148)
                      {
                        v151 = *(unint64_t **)(*(_QWORD *)v149 + v147);
                        if (v151)
                          break;
                      }
                    }
LABEL_261:
                    ++v148;
                    v147 += 8;
                    if (v148 == 17)
                    {
                      v162 = *(_QWORD *)(v4 + 40);
                      if (v162)
                      {
                        Typed = (uint64_t)v5[5];
                        if (*(_BYTE *)(v162 + 13))
                        {
                          if (!Typed)
                          {
                            v164 = CFGetAllocator(v5);
                            Typed = CFAllocatorAllocateTyped(v164, 16, 0x1080040FC6463CFLL, 0);
                            v5[5] = (__objc2_class *)Typed;
                            *(_QWORD *)Typed = 0;
                            *(_QWORD *)(Typed + 6) = 0;
                          }
                          v165 = 1;
LABEL_348:
                          *(_BYTE *)(Typed + 13) = v165;
                          goto LABEL_349;
                        }
                      }
                      else
                      {
                        Typed = (uint64_t)v5[5];
                      }
                      if (Typed)
                      {
                        v165 = 0;
                        goto LABEL_348;
                      }
LABEL_349:
                      v211 = atomic_load((unint64_t *)(v4 + 8));
                      switch((v211 >> 4) & 7)
                      {
                        case 0u:
                          v5[3] = *(__objc2_class **)(v4 + 24);
                          goto LABEL_360;
                        case 1u:
                          *((_DWORD *)v5 + 6) = *(_DWORD *)(v4 + 24);
                          v5[4] = *(__objc2_class **)(v4 + 32);
                          goto LABEL_360;
                        case 2u:
                          v212 = *(__objc2_class **)(v4 + 32);
                          v5[4] = v212;
                          v213 = v5[3];
                          if (!v213)
                          {
                            v214 = CFGetAllocator(v5);
                            v213 = (__objc2_class *)CFAllocatorAllocateTyped(v214, 128, 0x1000040BDFB0063, 0);
                            v5[3] = v213;
                            v212 = v5[4];
                          }
                          v215 = *(const void **)(v4 + 24);
                          v216 = 2 * (_QWORD)v212;
                          goto LABEL_359;
                        case 3u:
                          v217 = CFGetAllocator(v5);
                          v213 = (__objc2_class *)CFAllocatorAllocateTyped(v217, 0x2000, 0x100004077774924, 0);
                          v5[3] = v213;
                          v215 = *(const void **)(v4 + 24);
                          v216 = 0x2000;
                          goto LABEL_359;
                        case 4u:
                          v218 = 0;
                          v219 = (int32x4_t)xmmword_182C87B30;
                          v220 = *(char **)(v4 + 24);
                          v221 = 0uLL;
                          v222.i64[0] = -1;
                          v222.i64[1] = -1;
                          v223.i64[0] = 0xFEFEFEFEFEFEFEFELL;
                          v223.i64[1] = 0xFEFEFEFEFEFEFEFELL;
                          v224.i64[0] = 0x2000000020;
                          v224.i64[1] = 0x2000000020;
                          v225 = 0uLL;
                          v226 = 0uLL;
                          do
                          {
                            v227 = (int8x16_t)vcgtq_u8(v223, (uint8x16_t)vaddq_s8(*(int8x16_t *)&v220[v218], v222));
                            v228 = vmovl_s8(*(int8x8_t *)v227.i8);
                            v229 = vmovl_high_s8(v227);
                            v226 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v229), (int8x16_t)vaddq_s32(v226, v224), (int8x16_t)v226);
                            v225 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v229.i8), (int8x16_t)vaddq_s32(v225, v224), (int8x16_t)v225);
                            v221 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_high_s16(v228), (int8x16_t)vaddq_s32(v221, v224), (int8x16_t)v221);
                            v219 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v228.i8), (int8x16_t)vaddq_s32(v219, v224), (int8x16_t)v219);
                            v218 += 16;
                          }
                          while (v218 != 256);
                          v230 = vaddvq_s32(vaddq_s32(vaddq_s32(v219, v225), vaddq_s32(v221, v226)));
                          v231 = CFGetAllocator(v5);
                          v213 = (__objc2_class *)CFAllocatorAllocateTyped(v231, v230, 0x100004077774924, 0);
                          v5[3] = v213;
                          v215 = v220;
                          v216 = v230;
LABEL_359:
                          memmove(v213, v215, v216);
                          break;
                        default:
                          goto LABEL_360;
                      }
                      goto LABEL_360;
                    }
                  }
                  v152 = CFGetAllocator(v5);
                  Copy = __CFCharacterSetCreateCopy(v152, v151, 1, 1);
                  v154 = v5[5];
                  if (v154)
                  {
                    if (BYTE4(v154->superclass) < v148)
                    {
                      BYTE4(v154->superclass) = v148;
                      isa = v154->isa;
                      v156 = CFGetAllocator(v5);
                      if (isa)
                      {
                        v157 = __CFSafelyReallocateWithAllocatorTyped(v156, v5[5]->isa, v147 + 8, 0x6004044C4A2DFLL, 0, 0);
                        goto LABEL_254;
                      }
LABEL_253:
                      v157 = CFAllocatorAllocateTyped(v156, v147 + 8, 0x6004044C4A2DFLL, 0);
LABEL_254:
                      v154 = v5[5];
                      v154->isa = (__objc2_class *)v157;
                    }
                    if (((uint64_t)v154->superclass & v150) != 0)
                      CFRelease(*(CFTypeRef *)((char *)&v154->isa->isa + v147));
                    if (Copy)
                    {
                      *(__objc2_class **)((char *)&v5[5]->isa->isa + v147) = (__objc2_class *)CFRetain(Copy);
                      v160 = v5[5];
                      v161 = LODWORD(v160->superclass) | v150;
                    }
                    else
                    {
                      v160 = v5[5];
                      v161 = (uint64_t)v160->superclass & ~v150;
                    }
                    LODWORD(v160->superclass) = v161;
                    CFRelease(Copy);
                    goto LABEL_261;
                  }
                  v158 = CFGetAllocator(v5);
                  v159 = CFAllocatorAllocateTyped(v158, 16, 0x1080040FC6463CFLL, 0);
                  v5[5] = (__objc2_class *)v159;
                  *(_WORD *)(v159 + 12) = v148;
                  *(_DWORD *)(v159 + 8) = 0;
                  v156 = CFGetAllocator(v5);
                  goto LABEL_253;
                }
              }
              __clrex();
LABEL_239:
              v145 = 0;
              goto LABEL_240;
            }
          }
          __clrex();
LABEL_232:
          v140 = 0;
          goto LABEL_233;
        }
      }
      __clrex();
LABEL_225:
      v135 = 0;
      goto LABEL_226;
    }
LABEL_46:
    __CFCSetMakeBitmap((char *)v5);
    v34 = atomic_load((unint64_t *)(v4 + 8));
    v35 = v5[3];
    if ((v34 & 0x70) == 0x30)
    {
      v36 = 0;
      v37 = *(_QWORD *)(v4 + 24);
      do
      {
        *(_DWORD *)((char *)&v35->isa + v36) &= *(_DWORD *)(v37 + v36);
        v36 += 4;
      }
      while (v36 != 0x2000);
    }
    else
    {
      __CFCSetGetBitmap(v4, __b);
      for (j = 0; j != 2048; ++j)
        *(_DWORD *)((char *)&v35->isa + j * 4) &= __b[0].u32[j];
    }
    v39 = atomic_load(v12);
    while (1)
    {
      v40 = __ldaxr(v12);
      if (v40 != v39)
        break;
      if (__stlxr(v39 & 0xFFFFFFFFFFFFFFFBLL, v12))
        goto LABEL_57;
      v41 = 1;
LABEL_58:
      v39 = v40;
      if (v41)
      {
        v42 = *(_QWORD *)(v4 + 40);
        if (v42 && *(_DWORD *)(v42 + 8))
        {
          Mutable = CFCharacterSetCreateMutable(0);
          v44 = 0;
          v45 = 1;
          while (1)
          {
            v46 = *(_QWORD *)(v4 + 40);
            if (v46)
            {
              v47 = 1 << v45;
              if ((*(_DWORD *)(v46 + 8) & (1 << v45)) != 0
                && *(unsigned __int8 *)(v46 + 12) >= v45)
              {
                v48 = *(__CFCharacterSet **)(*(_QWORD *)v46 + v44);
                if (v48)
                  break;
              }
            }
            v53 = v5[5];
            if (v53)
            {
              v54 = 1 << v45;
              if (((uint64_t)v53->superclass & (1 << v45)) != 0)
              {
                if (BYTE4(v53->superclass) >= v45)
                {
                  v55 = *(CFMutableCharacterSetRef *)((char *)&v53->isa->isa + v44);
                  if (v55)
                  {
                    if (!BYTE5(v53->superclass))
                    {
                      CFRelease(v55);
                      v70 = v5[5];
                      v71 = (uint64_t)v70->superclass & ~v54;
LABEL_114:
                      LODWORD(v70->superclass) = v71;
                      goto LABEL_121;
                    }
                    CFCharacterSetInvert(v55);
                    CFCharacterSetIntersect(v55, Mutable);
                    goto LABEL_112;
                  }
                }
                if (BYTE4(v53->superclass) >= v45
                  && *(__objc2_class **)((char *)&v53->isa->isa + v44))
                {
                  goto LABEL_121;
                }
              }
              if (!BYTE5(v53->superclass))
                goto LABEL_121;
              if (BYTE4(v53->superclass) < v45)
              {
                BYTE4(v53->superclass) = v45;
                v56 = v53->isa;
                v57 = CFGetAllocator(v5);
                if (v56)
                  v58 = __CFSafelyReallocateWithAllocatorTyped(v57, v5[5]->isa, v44 + 8, 0x6004044C4A2DFLL, 0, 0);
                else
                  v58 = CFAllocatorAllocateTyped(v57, v44 + 8, 0x6004044C4A2DFLL, 0);
                v53 = v5[5];
                v53->isa = (__objc2_class *)v58;
              }
              if (((uint64_t)v53->superclass & v54) != 0)
              {
                v67 = (CFMutableCharacterSetRef *)((char *)v53->isa + v44);
              }
              else
              {
                v68 = CFGetAllocator(v5);
                *(__objc2_class **)((char *)&v5[5]->isa->isa + v44) = (__objc2_class *)CFCharacterSetCreateMutable(v68);
                v53 = v5[5];
                LODWORD(v53->superclass) |= v54;
                v67 = (CFMutableCharacterSetRef *)((char *)v53->isa + 8 * v45 - 8);
              }
              v55 = *v67;
              if (BYTE5(v53->superclass))
                CFCharacterSetInvert(*v67);
              CFCharacterSetIntersect(v55, Mutable);
              v69 = v5[5];
              if (!v69 || !BYTE5(v69->superclass))
                goto LABEL_121;
LABEL_112:
              CFCharacterSetInvert(v55);
            }
LABEL_121:
            ++v45;
            v44 += 8;
            if (v44 == 128)
            {
              CFRelease(Mutable);
              v85 = v5[5];
              if (v85 && !LODWORD(v85->superclass))
              {
                for (k = 0; k != 16; ++k)
                {
                  v87 = v5[5];
                  if (((LODWORD(v87->superclass) >> k) & 2) != 0)
                    CFRelease(*((CFTypeRef *)&v87->isa->isa + k));
                }
                goto LABEL_218;
              }
              goto LABEL_360;
            }
          }
          if (*(_BYTE *)(v46 + 13))
            CFCharacterSetInvert(v48);
          v49 = v5[5];
          if (v49)
          {
            if (BYTE4(v49->superclass) < v45)
            {
              BYTE4(v49->superclass) = v45;
              v50 = v49->isa;
              v51 = CFGetAllocator(v5);
              if (v50)
              {
                v52 = __CFSafelyReallocateWithAllocatorTyped(v51, v5[5]->isa, v44 + 8, 0x6004044C4A2DFLL, 0, 0);
                goto LABEL_86;
              }
LABEL_85:
              v52 = CFAllocatorAllocateTyped(v51, v44 + 8, 0x6004044C4A2DFLL, 0);
LABEL_86:
              v49 = v5[5];
              v49->isa = (__objc2_class *)v52;
            }
            if (((uint64_t)v49->superclass & v47) == 0)
            {
              v61 = CFGetAllocator(v5);
              *(__objc2_class **)((char *)&v5[5]->isa->isa + v44) = (__objc2_class *)CFCharacterSetCreateMutable(v61);
              v49 = v5[5];
              LODWORD(v49->superclass) |= v47;
            }
            v62 = *(unint64_t **)((char *)&v49->isa->isa + v44);
            if (BYTE5(v49->superclass))
              CFCharacterSetInvert((CFMutableCharacterSetRef)v62);
            CFCharacterSetIntersect((CFMutableCharacterSetRef)v62, v48);
            v63 = v5[5];
            if (v63 && BYTE5(v63->superclass))
              CFCharacterSetInvert((CFMutableCharacterSetRef)v62);
            v64 = *(_QWORD *)(v4 + 40);
            if (v64 && *(_BYTE *)(v64 + 13))
              CFCharacterSetInvert(v48);
            v65 = v62[5];
            if (!v65 || !*(_DWORD *)(v65 + 8) && !*(_BYTE *)(v65 + 13))
            {
              v66 = atomic_load(v62 + 1);
              switch((v66 >> 4) & 7)
              {
                case 1u:
                case 2u:
                  if (!v62[4])
                    goto LABEL_116;
                  goto LABEL_121;
                case 3u:
                case 4u:
                  if (v62[3])
                    goto LABEL_121;
LABEL_116:
                  v72 = atomic_load(v62 + 1);
                  if ((v72 & 8) != 0)
                    goto LABEL_121;
                  v70 = v5[5];
                  if (v70)
                  {
                    if (BYTE4(v70->superclass) >= v45)
                    {
LABEL_126:
                      superclass = (int)v70->superclass;
                      if ((superclass & v47) != 0)
                      {
                        CFRelease(*(CFTypeRef *)((char *)&v70->isa->isa + v44));
                        v70 = v5[5];
                        superclass = (int)v70->superclass;
                      }
                      v71 = superclass & ~v47;
                      goto LABEL_114;
                    }
                    BYTE4(v70->superclass) = v45;
                    v73 = v70->isa;
                    v74 = CFGetAllocator(v5);
                    if (v73)
                    {
                      v75 = __CFSafelyReallocateWithAllocatorTyped(v74, v5[5]->isa, v44 + 8, 0x6004044C4A2DFLL, 0, 0);
LABEL_125:
                      v70 = v5[5];
                      v70->isa = (__objc2_class *)v75;
                      goto LABEL_126;
                    }
                  }
                  else
                  {
                    v76 = CFGetAllocator(v5);
                    v77 = CFAllocatorAllocateTyped(v76, 16, 0x1080040FC6463CFLL, 0);
                    v5[5] = (__objc2_class *)v77;
                    *(_WORD *)(v77 + 12) = v45;
                    *(_DWORD *)(v77 + 8) = 0;
                    v74 = CFGetAllocator(v5);
                  }
                  v75 = CFAllocatorAllocateTyped(v74, v44 + 8, 0x6004044C4A2DFLL, 0);
                  goto LABEL_125;
                default:
                  goto LABEL_121;
              }
            }
            goto LABEL_121;
          }
          v59 = CFGetAllocator(v5);
          v60 = CFAllocatorAllocateTyped(v59, 16, 0x1080040FC6463CFLL, 0);
          v5[5] = (__objc2_class *)v60;
          *(_WORD *)(v60 + 12) = v45;
          *(_DWORD *)(v60 + 8) = 0;
          v51 = CFGetAllocator(v5);
          goto LABEL_85;
        }
        v79 = atomic_load((unint64_t *)(v4 + 8));
        if ((v79 & 0x70) == 0)
        {
          v108 = *(_QWORD *)(v4 + 40);
          if (!v108 || !*(_BYTE *)(v108 + 13))
          {
            v109 = 1;
            while (1)
            {
              v110 = v5[5];
              if (v110)
              {
                v111 = 1 << v109;
                if (((uint64_t)v110->superclass & (1 << v109)) != 0 && v109 <= BYTE4(v110->superclass))
                {
                  v112 = *((_QWORD *)v110->isa + v109 - 1);
                  if (v112)
                  {
                    BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(v4 + 24), v109, __b, 0);
                    if (!BitmapForPlane)
                    {
                      __CFCSetMakeBitmap((char *)v112);
                      v114 = 0;
                      v115 = *(_QWORD *)(v112 + 24);
                      v116 = 1;
                      do
                      {
                        v117 = *(_DWORD *)(v115 + v114 * 4);
                        v118 = (v117 & __b[0].i32[v114]) == 0;
                        *(_DWORD *)(v115 + v114 * 4) = v117 & __b[0].i32[v114];
                        if (!v118)
                          v116 = 0;
                        ++v114;
                      }
                      while (v114 != 2048);
                      if (!v116)
                        goto LABEL_211;
LABEL_201:
                      v119 = v5[5];
                      if (v119)
                      {
                        if (v109 > BYTE4(v119->superclass))
                        {
                          BYTE4(v119->superclass) = v109;
                          v120 = v119->isa;
                          v121 = CFGetAllocator(v5);
                          if (v120)
                          {
                            v122 = __CFSafelyReallocateWithAllocatorTyped(v121, v5[5]->isa, 8 * v109, 0x6004044C4A2DFLL, 0, 0);
                            goto LABEL_207;
                          }
LABEL_206:
                          v122 = CFAllocatorAllocateTyped(v121, 8 * v109, 0x6004044C4A2DFLL, 0);
LABEL_207:
                          v119 = v5[5];
                          v119->isa = (__objc2_class *)v122;
                        }
                        v125 = (int)v119->superclass;
                        if ((v125 & v111) != 0)
                        {
                          CFRelease(*((CFTypeRef *)v119->isa + v109 - 1));
                          v119 = v5[5];
                          v125 = (int)v119->superclass;
                        }
                        LODWORD(v119->superclass) = v125 & ~v111;
                        goto LABEL_211;
                      }
                      v123 = CFGetAllocator(v5);
                      v124 = CFAllocatorAllocateTyped(v123, 16, 0x1080040FC6463CFLL, 0);
                      v5[5] = (__objc2_class *)v124;
                      *(_BYTE *)(v124 + 12) = v109;
                      *(_BYTE *)(v124 + 13) = 0;
                      *(_DWORD *)(v124 + 8) = 0;
                      v121 = CFGetAllocator(v5);
                      goto LABEL_206;
                    }
                    if (BitmapForPlane == 255)
                      goto LABEL_201;
                  }
                }
              }
LABEL_211:
              if (++v109 == 17)
              {
                v126 = v5[5];
                if (v126 && !LODWORD(v126->superclass))
                {
                  for (m = 0; m != 16; ++m)
                  {
                    v128 = v5[5];
                    if (((LODWORD(v128->superclass) >> m) & 2) != 0)
                      CFRelease(*((CFTypeRef *)&v128->isa->isa + m));
                  }
                  goto LABEL_218;
                }
                goto LABEL_360;
              }
            }
          }
        }
        v80 = atomic_load((unint64_t *)(v4 + 8));
        if ((v80 & 0x70) != 0x10)
        {
          v104 = v5[5];
          if (v104 && (LODWORD(v104->superclass) || BYTE5(v104->superclass)))
          {
            v105 = *(_QWORD *)(v4 + 40);
            if (!v105 || !*(_BYTE *)(v105 + 13))
            {
              for (n = 0; n != 16; ++n)
              {
                v107 = v5[5];
                if (((LODWORD(v107->superclass) >> n) & 2) != 0)
                  CFRelease(*((CFTypeRef *)&v107->isa->isa + n));
              }
              goto LABEL_218;
            }
          }
LABEL_360:
          if (__CFCheckForExapendedSet == 1)
            __CFCheckForExpandedSet((const char *)v5);
          return;
        }
        v81 = CFGetAllocator(v5);
        v82 = CFCharacterSetCreateMutable(v81);
        theOtherSeta = CFCharacterSetCreateMutable(0);
        __CFCSetAddNonBMPPlanesInRange(v82, *(unsigned int *)(v4 + 24), *(_QWORD *)(v4 + 32));
        v83 = v5[5];
        if (v83)
          v84 = BYTE5(v83->superclass) != 0;
        else
          v84 = 0;
        v166 = *((_QWORD *)v82 + 5);
        if (v166)
          v232 = *(unsigned __int8 *)(v166 + 13) != 0;
        else
          v232 = 0;
        v167 = 0;
        v168 = 8;
        v169 = 1;
        while (2)
        {
          v170 = v167 + 1;
          v171 = (v167 + 1);
          v172 = *((_QWORD *)v82 + 5);
          if (v172)
          {
            v173 = 1 << v170;
            if ((*(_DWORD *)(v172 + 8) & (1 << v170)) != 0 && *(unsigned __int8 *)(v172 + 12) >= v171)
            {
              v174 = *(__CFCharacterSet **)(*(_QWORD *)v172 + 8 * v167);
              if (v174)
              {
                v175 = v5[5];
                if (!v175)
                {
                  v194 = CFGetAllocator(v5);
                  v195 = CFAllocatorAllocateTyped(v194, 16, 0x1080040FC6463CFLL, 0);
                  v5[5] = (__objc2_class *)v195;
                  *(_WORD *)(v195 + 12) = v171;
                  *(_DWORD *)(v195 + 8) = 0;
                  v177 = CFGetAllocator(v5);
                  goto LABEL_309;
                }
                if (BYTE4(v175->superclass) < v171)
                {
                  BYTE4(v175->superclass) = v171;
                  v176 = v175->isa;
                  v177 = CFGetAllocator(v5);
                  if (v176)
                  {
                    v178 = __CFSafelyReallocateWithAllocatorTyped(v177, v5[5]->isa, v168, 0x6004044C4A2DFLL, 0, 0);
                    goto LABEL_310;
                  }
LABEL_309:
                  v178 = CFAllocatorAllocateTyped(v177, v168, 0x6004044C4A2DFLL, 0);
LABEL_310:
                  v175 = v5[5];
                  v175->isa = (__objc2_class *)v178;
                }
                if (((uint64_t)v175->superclass & v173) == 0)
                {
                  v196 = CFGetAllocator(v5);
                  *((_QWORD *)&v5[5]->isa->isa + v167) = CFCharacterSetCreateMutable(v196);
                  v175 = v5[5];
                  LODWORD(v175->superclass) |= v173;
                }
                v197 = (unint64_t *)*((_QWORD *)&v175->isa->isa + v167);
                if (v232)
                  CFCharacterSetInvert(v174);
                if (v84)
                {
                  CFCharacterSetInvert((CFMutableCharacterSetRef)v197);
                  CFCharacterSetIntersect((CFMutableCharacterSetRef)v197, v174);
                  CFCharacterSetInvert((CFMutableCharacterSetRef)v197);
                }
                else
                {
                  CFCharacterSetIntersect((CFMutableCharacterSetRef)v197, v174);
                }
                if (v232)
                  CFCharacterSetInvert(v174);
                v198 = v197[5];
                if (!v198 || !*(_DWORD *)(v198 + 8) && !*(_BYTE *)(v198 + 13))
                {
                  v199 = atomic_load(v197 + 1);
                  switch((v199 >> 4) & 7)
                  {
                    case 1u:
                    case 2u:
                      if (!v197[4])
                        goto LABEL_327;
                      break;
                    case 3u:
                    case 4u:
                      if (v197[3])
                        break;
LABEL_327:
                      v200 = atomic_load(v197 + 1);
                      if ((v200 & 8) != 0)
                        break;
                      v182 = v5[5];
                      if (v182)
                      {
                        if (BYTE4(v182->superclass) >= v171)
                        {
LABEL_335:
                          v183 = (int)v182->superclass;
                          if ((v183 & v173) == 0)
                            goto LABEL_287;
                          v181 = (const void *)*((_QWORD *)&v182->isa->isa + v167);
                          goto LABEL_286;
                        }
                        BYTE4(v182->superclass) = v171;
                        v201 = v182->isa;
                        v202 = CFGetAllocator(v5);
                        if (v201)
                        {
                          v203 = __CFSafelyReallocateWithAllocatorTyped(v202, v5[5]->isa, v168, 0x6004044C4A2DFLL, 0, 0);
LABEL_334:
                          v182 = v5[5];
                          v182->isa = (__objc2_class *)v203;
                          goto LABEL_335;
                        }
                      }
                      else
                      {
                        v204 = CFGetAllocator(v5);
                        v205 = CFAllocatorAllocateTyped(v204, 16, 0x1080040FC6463CFLL, 0);
                        v5[5] = (__objc2_class *)v205;
                        *(_WORD *)(v205 + 12) = v171;
                        *(_DWORD *)(v205 + 8) = 0;
                        v202 = CFGetAllocator(v5);
                      }
                      v203 = CFAllocatorAllocateTyped(v202, v168, 0x6004044C4A2DFLL, 0);
                      goto LABEL_334;
                    default:
                      break;
                  }
                }
LABEL_306:
                ++v169;
                ++v167;
                v168 += 8;
                if (v167 == 16)
                {
                  v206 = v5[5];
                  if (v206 && !LODWORD(v206->superclass))
                  {
                    for (ii = 0; ii != 16; ++ii)
                    {
                      v208 = v5[5];
                      if (((LODWORD(v208->superclass) >> ii) & 2) != 0)
                        CFRelease(*((CFTypeRef *)&v208->isa->isa + ii));
                    }
                    v209 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v209, v5[5]->isa);
                    v210 = CFGetAllocator(v5);
                    CFAllocatorDeallocate(v210, v5[5]);
                    v5[5] = 0;
                  }
                  CFRelease(v82);
                  CFRelease(theOtherSeta);
                  goto LABEL_360;
                }
                continue;
              }
            }
          }
          break;
        }
        v179 = v5[5];
        if (v179)
        {
          v173 = 1 << v170;
          if (((uint64_t)v179->superclass & (1 << v170)) == 0)
            goto LABEL_291;
          if (BYTE4(v179->superclass) >= v171)
          {
            v180 = (__CFCharacterSet *)*((_QWORD *)&v179->isa->isa + v167);
            if (v180)
            {
              if (!v84)
              {
                v181 = (const void *)*((_QWORD *)&v179->isa->isa + v167);
LABEL_286:
                CFRelease(v181);
                v182 = v5[5];
                v183 = (int)v182->superclass;
LABEL_287:
                LODWORD(v182->superclass) = v183 & ~v173;
                goto LABEL_306;
              }
LABEL_305:
              CFCharacterSetInvert(v180);
              CFCharacterSetIntersect(v180, theOtherSeta);
              CFCharacterSetInvert(v180);
              goto LABEL_306;
            }
          }
          if (BYTE4(v179->superclass) >= v171)
            v187 = *((_QWORD *)&v179->isa->isa + v167);
          else
LABEL_291:
            v187 = 0;
          if (v187)
            v188 = 0;
          else
            v188 = v84;
          if (!v188)
            goto LABEL_306;
          if (BYTE4(v179->superclass) < v171)
          {
            BYTE4(v179->superclass) = v171;
            v189 = v179->isa;
            v186 = CFGetAllocator(v5);
            if (v189)
            {
              v190 = __CFSafelyReallocateWithAllocatorTyped(v186, v5[5]->isa, v168, 0x6004044C4A2DFLL, 0, 0);
              goto LABEL_301;
            }
LABEL_300:
            v190 = CFAllocatorAllocateTyped(v186, v168, 0x6004044C4A2DFLL, 0);
LABEL_301:
            v179 = v5[5];
            v179->isa = (__objc2_class *)v190;
          }
          v191 = v167;
          if (((uint64_t)v179->superclass & (1 << v170)) == 0)
          {
            v192 = CFGetAllocator(v5);
            v193 = CFCharacterSetCreateMutable(v192);
            v191 = v169 - 1;
            *((_QWORD *)&v5[5]->isa->isa + v167) = v193;
            v179 = v5[5];
            LODWORD(v179->superclass) |= 1 << v170;
          }
          v180 = (__CFCharacterSet *)*((_QWORD *)&v179->isa->isa + v191);
          goto LABEL_305;
        }
        if (!v84)
          goto LABEL_306;
        v184 = CFGetAllocator(v5);
        v185 = CFAllocatorAllocateTyped(v184, 16, 0x1080040FC6463CFLL, 0);
        v5[5] = (__objc2_class *)v185;
        *(_WORD *)(v185 + 12) = v171;
        *(_DWORD *)(v185 + 8) = 0;
        v186 = CFGetAllocator(v5);
        goto LABEL_300;
      }
    }
    __clrex();
LABEL_57:
    v41 = 0;
    goto LABEL_58;
  }
  BitmapRepresentation = CFCharacterSetCreateBitmapRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFCharacterSetRef)v4);
  if (BitmapRepresentation)
  {
    v22 = BitmapRepresentation;
    if (CFDataGetLength(BitmapRepresentation))
    {
      BytePtr = CFDataGetBytePtr(v22);
      if (BytePtr)
      {
        v24 = BytePtr;
        __CFCSetMakeBitmap((char *)v5);
        v25 = 0;
        v26 = v5[3];
        do
        {
          *(_DWORD *)((char *)&v26->isa + v25) &= *(_DWORD *)&v24[v25];
          v25 += 4;
        }
        while (v25 != 0x2000);
        v27 = atomic_load(v12);
        while (1)
        {
          v28 = __ldaxr(v12);
          if (v28 != v27)
            break;
          if (__stlxr(v27 & 0xFFFFFFFFFFFFFFFBLL, v12))
            goto LABEL_30;
          v29 = 1;
LABEL_31:
          v27 = v28;
          if (v29)
            goto LABEL_32;
        }
        __clrex();
LABEL_30:
        v29 = 0;
        goto LABEL_31;
      }
    }
LABEL_32:
    CFRelease(v22);
  }
}

void ___isValidSpecialCase_block_invoke()
{
  void *v0;
  uint64_t (*v1)(const __CFString *, _QWORD);
  const void *v2;
  const void *v3;

  v0 = dlopen("/usr/lib/libMobileGestalt.dylib", 5);
  if (v0)
  {
    v1 = (uint64_t (*)(const __CFString *, _QWORD))dlsym(v0, "MGCopyAnswer");
    if (v1)
    {
      v2 = (const void *)v1(CFSTR("h63QSdBCiT/z0WU6rdQv6Q"), 0);
      if (v2)
      {
        v3 = v2;
        _isValidSpecialCase_useSpecialCase = CFEqual(v2, CFSTR("CH")) != 0;
        CFRelease(v3);
      }
      else
      {
        _isValidSpecialCase_useSpecialCase = 0;
      }
    }
  }
}

_QWORD *setupScheduledStreamCloseBlock(_QWORD *result, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4)
{
  _QWORD *v7;

  v7 = result;
  if (cf)
    result = CFRetain(cf);
  *v7 = cf;
  if (a3)
    result = CFRetain(a3);
  v7[1] = a3;
  if (a4)
    result = CFRetain(a4);
  v7[2] = a4;
  return result;
}

UInt8 *clearInvalidFileDescriptors(UInt8 *result)
{
  __CFData *v1;
  int v2;
  const void *v3;
  unsigned int i;
  uint64_t v5;

  if (result)
  {
    v1 = (__CFData *)result;
    v2 = 8 * CFDataGetLength((CFDataRef)result);
    result = CFDataGetMutableBytePtr(v1);
    if (v2 >= 1)
    {
      v3 = result;
      for (i = 0; i != v2; ++i)
      {
        result = (UInt8 *)__darwin_check_fd_set_overflow(i, v3, 1);
        if ((_DWORD)result)
        {
          v5 = i >> 5;
          if ((*((_DWORD *)v3 + v5) & (1 << i)) != 0)
          {
            result = (UInt8 *)__CFNativeSocketIsValid(i);
            if (!(_DWORD)result)
            {
              result = (UInt8 *)__darwin_check_fd_set_overflow(i, v3, 1);
              if ((_DWORD)result)
                *((_DWORD *)v3 + v5) &= ~(1 << i);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t _allObjectsInvokeFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void __collatorFinalize(uint64_t a1)
{
  const void *v2;
  uint64_t v3;

  v2 = (const void *)_CFGetTSD(8u);
  _CFSetTSD(9u, 0, 0);
  _CFSetTSD(8u, 0, 0);
  _CFSetTSD(0x11u, 0, 0);
  os_unfair_lock_lock_with_options();
  v3 = __CFDefaultCollatorsCount;
  if ((const void *)__CFDefaultCollatorLocale == v2 && __CFDefaultCollatorsCount <= 7)
  {
    ++__CFDefaultCollatorsCount;
    __CFDefaultCollators[v3] = a1;
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
    if (v2)
LABEL_8:
      CFRelease(v2);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
    if (a1)
      ucol_close();
    if (v2)
      goto LABEL_8;
  }
}

uint64_t __CFStorageFindByte(_QWORD *cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, _QWORD *a6, int a7)
{
  uint64_t v9;
  char *v10;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  unsigned int *v17;
  CFAllocatorRef v18;
  int64_t *Node;
  int64_t *v20;
  const void *v21;
  int64_t v22;
  uint64_t v23;
  uint64_t v24;
  int64_t v25;
  int64_t v26;
  unsigned int *v27;
  unsigned int v28;
  int64_t v29;
  unsigned int *v30;
  unsigned int v31;
  int64_t v32;
  unsigned int *v33;
  unsigned int v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  pthread_mutex_t *v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  CFAllocatorRef v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v51;
  int64_t v52;
  pthread_mutex_t *v53;

  v9 = a2;
  v10 = (char *)cf;
  if (!*(_BYTE *)(a2 + 13))
  {
    v53 = (pthread_mutex_t *)(cf + 4);
    while (1)
    {
      v12 = a3;
      v14 = v9 + 16;
      v13 = *(_QWORD **)(v9 + 16);
      v15 = a3 < *v13;
      a3 -= *v13;
      if (v15)
        break;
      v13 = *(_QWORD **)(v9 + 24);
      if (a3 < *v13)
      {
        v16 = 1;
LABEL_8:
        v9 = (uint64_t)v13;
        if (a7)
          goto LABEL_11;
        goto LABEL_53;
      }
      v9 = *(_QWORD *)(v9 + 32);
      v16 = 2;
      a3 -= *v13;
      if (a7)
      {
LABEL_11:
        if (*(_BYTE *)(v9 + 12))
        {
          v17 = (unsigned int *)(v9 + 8);
          if (*(_DWORD *)(v9 + 8) == 1)
          {
            *(_BYTE *)(v9 + 12) = 0;
          }
          else
          {
            v18 = CFGetAllocator(v10);
            Node = (int64_t *)__CFStorageCreateNode((uint64_t)v18, (uint64_t)v10, *(_BYTE *)(v9 + 13), *(_QWORD *)v9);
            v20 = Node;
            if (*(_BYTE *)(v9 + 13))
            {
              v21 = *(const void **)(v9 + 24);
              if (v21)
              {
                v22 = *Node;
                v23 = *MEMORY[0x1E0C85AD8];
                if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
                  v24 = *MEMORY[0x1E0C85AD8];
                else
                  v24 = v23 + 1;
                if (v22 <= v24 >> 1)
                {
                  v37 = v22 + 63;
                  if (v22 < -63)
                    v37 = v22 + 126;
                  v25 = v37 & 0xFFFFFFFFFFFFFFC0;
                }
                else
                {
                  v25 = (int)((v22 + v23 - 1) & -(int)v23);
                  if (cf[17] < v25)
                    v25 = cf[17];
                }
                if (v25 > Node[2])
                {
                  v51 = a7;
                  v38 = v53;
                  v52 = v25;
                  pthread_mutex_lock(v53);
                  if (v52 > v20[2])
                  {
                    v20[3] = __CFSafelyReallocateWithAllocatorTyped(v18, v20[3], v52, 1893177561, 0, 0);
                    if (__CFOASafe)
                      __CFSetLastAllocationEventName();
                    v38 = v53;
                    v20[2] = v52;
                  }
                  pthread_mutex_unlock(v38);
                  v21 = *(const void **)(v9 + 24);
                  v22 = *v20;
                  a7 = v51;
                }
                memmove((void *)v20[3], v21, v22);
              }
            }
            else
            {
              v26 = *(_QWORD *)(v9 + 16);
              v27 = (unsigned int *)(v26 + 8);
              if (*(_DWORD *)(v26 + 8))
              {
                do
                  v28 = __ldxr(v27);
                while (__stxr(v28 + 1, v27));
              }
              Node[2] = v26;
              v29 = *(_QWORD *)(v9 + 24);
              if (v29)
              {
                v30 = (unsigned int *)(v29 + 8);
                if (*(_DWORD *)(v29 + 8))
                {
                  do
                    v31 = __ldxr(v30);
                  while (__stxr(v31 + 1, v30));
                }
                Node[3] = v29;
              }
              v32 = *(_QWORD *)(v9 + 32);
              if (v32)
              {
                v33 = (unsigned int *)(v32 + 8);
                if (*(_DWORD *)(v32 + 8))
                {
                  do
                    v34 = __ldxr(v33);
                  while (__stxr(v34 + 1, v33));
                }
                Node[4] = v32;
              }
              if (*(_BYTE *)(v9 + 12))
              {
                *(_BYTE *)(Node[2] + 12) = 1;
                v35 = Node[3];
                if (v35)
                  *(_BYTE *)(v35 + 12) = 1;
                v36 = Node[4];
                if (v36)
                  *(_BYTE *)(v36 + 12) = 1;
              }
            }
            *(_QWORD *)(v14 + 8 * v16) = v20;
            if (!*v17)
              goto LABEL_52;
            do
            {
              v39 = __ldxr(v17);
              v40 = v39 - 1;
            }
            while (__stxr(v40, v17));
            if (v40)
            {
LABEL_52:
              v9 = (uint64_t)v20;
              v10 = (char *)cf;
            }
            else
            {
              __CFStorageDeallocateNode(cf, v9);
              v9 = (uint64_t)v20;
              v10 = (char *)cf;
            }
          }
        }
      }
LABEL_53:
      a4 = a4 + v12 - a3;
      if (*(_BYTE *)(v9 + 13))
        goto LABEL_54;
    }
    v16 = 0;
    a3 = v12;
    goto LABEL_8;
  }
LABEL_54:
  v41 = *(_QWORD *)v9;
  *a6 = a4;
  a6[1] = v41;
  *a5 = v9;
  v42 = CFGetAllocator(v10);
  v43 = *(_QWORD *)v9;
  v44 = *MEMORY[0x1E0C85AD8];
  if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
    v45 = *MEMORY[0x1E0C85AD8];
  else
    v45 = v44 + 1;
  if (v43 <= v45 >> 1)
  {
    v48 = v43 + 63;
    v15 = v43 < -63;
    v49 = v43 + 126;
    if (!v15)
      v49 = v48;
    v47 = v49 & 0xFFFFFFFFFFFFFFC0;
  }
  else
  {
    v46 = (v43 + v44 - 1) & -(int)v44;
    if (*((_QWORD *)v10 + 17) >= v46)
      v47 = v46;
    else
      v47 = *((_QWORD *)v10 + 17);
  }
  if (v47 > *(_QWORD *)(v9 + 16))
  {
    pthread_mutex_lock((pthread_mutex_t *)(v10 + 32));
    if (v47 > *(_QWORD *)(v9 + 16))
    {
      *(_QWORD *)(v9 + 24) = __CFSafelyReallocateWithAllocatorTyped(v42, *(_QWORD *)(v9 + 24), v47, 1893177561, 0, 0);
      if (__CFOASafe)
        __CFSetLastAllocationEventName();
      *(_QWORD *)(v9 + 16) = v47;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 32));
  }
  return *(_QWORD *)(v9 + 24) + a3;
}

void __CFSocketDeallocate(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = *(const void **)(a1 + 168);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 168) = 0;
  }
  v3 = *(const void **)(a1 + 288);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 288) = 0;
  }
  v4 = *(const void **)(a1 + 328);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 328) = 0;
  }
  *(_DWORD *)(a1 + 280) = 0;
  *(_QWORD *)(a1 + 272) = 0;
  *(_QWORD *)(a1 + 304) = 0;
  *(_QWORD *)(a1 + 312) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  *(_BYTE *)(a1 + 320) = 1;
  *(_DWORD *)(a1 + 324) = 0;
}

uint64_t __CFSocketCancel(uint64_t a1, const void *a2)
{
  pthread_mutex_t *v4;
  int v5;
  const __CFArray *v6;
  unsigned int FirstIndexOfValue;
  CFIndex v8;
  __CFData *v9;
  UInt8 *MutableBytePtr;
  const __CFArray *v11;
  unsigned int v12;
  CFIndex v13;
  __CFData *v14;
  UInt8 *v15;
  const void *v16;
  const __CFArray *MutableCopy;
  unsigned int v18;
  char v20;
  char v21;
  uint64_t v22;
  CFRange v23;
  CFRange v24;
  CFRange v25;

  v22 = *MEMORY[0x1E0C80C00];
  v4 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  v5 = *(_DWORD *)(a1 + 184) - 1;
  *(_DWORD *)(a1 + 184) = v5;
  if (!v5)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
    v6 = (const __CFArray *)__CFWriteSockets;
    v23.length = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
    v23.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v6, v23, (const void *)a1);
    if ((FirstIndexOfValue & 0x80000000) == 0)
    {
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFWriteSockets, FirstIndexOfValue);
      v8 = *(unsigned int *)(a1 + 152);
      if ((v8 & 0x80000000) == 0)
      {
        v9 = (__CFData *)__CFWriteSocketsFds;
        if (v8 < 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds))
        {
          MutableBytePtr = CFDataGetMutableBytePtr(v9);
          if (__darwin_check_fd_set_overflow(v8, MutableBytePtr, 1))
          {
            if ((*(_DWORD *)&MutableBytePtr[4 * (v8 >> 5)] & (1 << v8)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v8, MutableBytePtr, 1))
                *(_DWORD *)&MutableBytePtr[4 * (v8 >> 5)] &= ~(1 << v8);
              if ((_DWORD)__CFWakeupSocketPair != -1)
              {
                v20 = 120;
                send(__CFWakeupSocketPair, &v20, 1uLL, 0);
              }
            }
          }
        }
      }
    }
    v11 = (const __CFArray *)__CFReadSockets;
    v24.length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
    v24.location = 0;
    v12 = CFArrayGetFirstIndexOfValue(v11, v24, (const void *)a1);
    if ((v12 & 0x80000000) == 0)
    {
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFReadSockets, v12);
      __CFReadSocketsTimeoutInvalid = 0;
      v13 = *(unsigned int *)(a1 + 152);
      if ((v13 & 0x80000000) == 0)
      {
        v14 = (__CFData *)__CFReadSocketsFds;
        if (v13 < 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds))
        {
          v15 = CFDataGetMutableBytePtr(v14);
          if (__darwin_check_fd_set_overflow(v13, v15, 1))
          {
            if ((*(_DWORD *)&v15[4 * (v13 >> 5)] & (1 << v13)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v13, v15, 1))
                *(_DWORD *)&v15[4 * (v13 >> 5)] &= ~(1 << v13);
              if ((_DWORD)__CFWakeupSocketPair != -1)
              {
                v21 = 115;
                send(__CFWakeupSocketPair, &v21, 1uLL, 0);
              }
            }
          }
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  }
  v16 = *(const void **)(a1 + 200);
  if (v16)
  {
    MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, *(CFArrayRef *)(a1 + 200));
    v25.length = CFArrayGetCount(MutableCopy);
    v25.location = 0;
    v18 = CFArrayGetFirstIndexOfValue(MutableCopy, v25, a2);
    if ((v18 & 0x80000000) == 0)
      CFArrayRemoveValueAtIndex(MutableCopy, v18);
    *(_QWORD *)(a1 + 200) = MutableCopy;
    CFRelease(v16);
  }
  return pthread_mutex_unlock(v4);
}

uint64_t __CFRunLoopRemoveSourcesFromCommonMode(uint64_t a1, uint64_t a2)
{
  return __CFRunLoopRemoveAllSources(a2, a1);
}

void __CFRunLoopRemoveSourceFromMode(CFRunLoopSourceRef source, uint64_t a2)
{
  CFRunLoopRemoveSource(*(CFRunLoopRef *)a2, source, *(CFRunLoopMode *)(a2 + 8));
}

BOOL __CFNativeSocketIsValid(int a1)
{
  return (fcntl(a1, 3, 0) & 0x80000000) == 0 || *__error() != 9;
}

uint64_t __CFFromMacKorean(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  unint64_t v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  BOOL v20;
  _WORD *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  unsigned __int16 *v29;
  unsigned int v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  uint64_t v33;
  unsigned __int16 *v34;
  unsigned int v35;
  unsigned __int16 *v36;
  unsigned __int16 *v37;
  uint64_t v38;
  unsigned __int16 *v39;
  unsigned int v40;
  unsigned __int16 *v41;
  unsigned __int16 *v42;
  uint64_t v43;
  unsigned __int16 *v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  __int16 v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  __int16 *v54;
  __int16 v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int IsDecomposableCharacter_0;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  __int16 *v63;
  __int16 v64;
  unsigned __int16 v65;
  char *v66;
  char *v67;
  uint64_t v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  __int16 *v77;
  __int16 v78;
  __int16 v79;
  unsigned __int16 v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  __int16 *v90;
  __int16 v91;
  uint64_t v92;
  unsigned __int16 v93;
  unsigned int v94;
  uint64_t v95;
  uint64_t v96;
  char *v97;
  _WORD *v98;
  _WORD *v99;
  char v100;
  char *v101;
  char v102;
  char v103;
  char *v105;
  unsigned __int16 *v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  uint64_t v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  _BYTE v117[10];
  uint64_t v118;

  v118 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (a3 < 1)
    return 0;
  v9 = a3;
  v12 = 0;
  v13 = 0;
  v14 = (a1 & 0x200) == 0;
  if ((a1 & 0x200) != 0)
    v15 = 1;
  else
    v15 = 2;
  v16 = a1 & 0xC0;
  if ((a1 & 0x200) != 0)
    v17 = 3;
  else
    v17 = 4;
LABEL_8:
  if (!a5 || v12 < a5)
  {
    v18 = *a2;
    if (*a2 < 0 && ((a1 & 0x80) == 0 || (v18 + 123) > 0x1Au))
    {
      switch(*a2)
      {
        case -128:
          if (a5)
            *a4++ = 160;
          goto LABEL_15;
        case -127:
          if (a5)
            *a4++ = 8361;
          goto LABEL_15;
        case -126:
          v12 += v15;
          if (!a5)
            break;
          if (v12 > a5)
            return v13;
          *a4 = 8211;
          v21 = a4 + 1;
          if ((a1 & 0x200) != 0)
            goto LABEL_34;
          goto LABEL_40;
        case -125:
          if (a5)
            *a4++ = 169;
          goto LABEL_15;
        case -124:
          v12 += v15;
          if (!a5)
            break;
          if (v12 > a5)
            return v13;
          *a4 = -193;
          v21 = a4 + 1;
          if ((a1 & 0x200) == 0)
            goto LABEL_40;
          goto LABEL_34;
        default:
          if (v18 != 255)
          {
            if (v9 < 2)
              return v13;
            v22 = v17;
            v23 = v16;
            v24 = a2[1];
            v25 = v24 | (v18 << 8);
            if ((unsigned __int16)((v24 | ((_WORD)v18 << 8)) + 21070) >= 0xF39Bu)
            {
              v26 = (unsigned __int16 *)&MacKorean_to_uni_one_char;
              v27 = (unsigned __int16 *)&unk_182CF5E66;
              do
              {
                v28 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (v27 - v26)) >> 1;
                v29 = &v26[5 * v28];
                v30 = *v29;
                if (v30 <= v25)
                {
                  if (v30 + 4 > v25)
                  {
                    v56 = (uint64_t)&v26[5 * v28 + (int)(v25 - v30)];
                    v57 = *(unsigned __int16 *)(v56 + 2);
                    if (*(_WORD *)(v56 + 2))
                    {
                      v16 = v23;
                      v17 = v22;
                      if ((_DWORD)v16)
                      {
                        v58 = v14;
                        v115 = v15;
                        v112 = v16;
                        IsDecomposableCharacter_0 = __CFStringEncodingIsDecomposableCharacter_0(*(unsigned __int16 *)(v56 + 2), (a1 >> 7) & 1);
                        v17 = v22;
                        v16 = v112;
                        v15 = v115;
                        v14 = v58;
                        if (IsDecomposableCharacter_0)
                        {
                          v61 = __CFStringEncodingDecomposeCharacter_0(a1, v57, v117, v60, 63615, v58, v22, 8230);
                          v52 = *a6;
                          v12 = *a6 + v61;
                          *a6 = v12;
                          if (a5)
                          {
                            if (v12 > a5)
                              goto LABEL_197;
                            if (v61 >= 1)
                            {
                              v62 = v61 + 1;
                              v63 = (__int16 *)v117;
                              v14 = v58;
                              v15 = v115;
                              v16 = v112;
                              v17 = v22;
                              do
                              {
                                v64 = *v63++;
                                *a4++ = v64;
                                --v62;
                              }
                              while (v62 > 1);
                              v19 = 2;
                              goto LABEL_18;
                            }
                          }
                          v19 = 2;
                          v14 = v58;
                          v15 = v115;
                          v16 = v112;
                          v17 = v22;
                          goto LABEL_18;
                        }
                      }
                      if (a5)
                        *a4++ = v57;
LABEL_122:
                      v12 = *a6 + 1;
                      v19 = 2;
                      goto LABEL_17;
                    }
                    break;
                  }
                  v26 = v29 + 5;
                }
                else
                {
                  v27 = v29 - 5;
                }
              }
              while (v26 <= v27);
            }
            if ((unsigned __int16)(v25 + 21070) < 0xF38Fu)
              goto LABEL_70;
            v31 = (unsigned __int16 *)&MacKorean_to_uni_two_char;
            v32 = (unsigned __int16 *)&unk_182CF77A6;
            while (1)
            {
              v33 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v32 - v31)) >> 1;
              v34 = &v31[17 * v33];
              v35 = *v34;
              if (v35 <= v25)
              {
                if (v35 + 16 > v25)
                {
                  v65 = v31[17 * v33 + 1 + (int)(v25 - v35)];
                  if (v65)
                  {
                    v66 = (char *)&__CFTwoCharDecompSeqTable + 4 * (v65 & 0x7FFF);
                    v69 = *((unsigned __int16 *)v66 - 2);
                    v67 = v66 - 4;
                    v68 = v69;
                    v16 = v23;
                    v17 = v22;
                    if ((_DWORD)v16)
                    {
                      v105 = v67;
                      v110 = v22;
                      v113 = v16;
                      v116 = v15;
                      v108 = v14;
                      if ((__CFStringEncodingIsDecomposableCharacter_0(v68, (a1 >> 7) & 1) & 1) != 0)
                      {
                        v75 = __CFStringEncodingDecomposeCharacter_0(a1, v68, v117, v70, v71, v72, v73, v74);
                        v12 = v75 + !(((v65 & 0x8000u) != 0) & (a1 >> 9)) + *a6;
                        if (a5)
                        {
                          v14 = v108;
                          v15 = v116;
                          v16 = v113;
                          v17 = v22;
                          if (v12 <= a5)
                          {
                            if (v75 >= 1)
                            {
                              v76 = v75 + 1;
                              v77 = (__int16 *)v117;
                              do
                              {
                                v78 = *v77++;
                                *a4++ = v78;
                                --v76;
                              }
                              while (v76 > 1);
                            }
                            if ((((v65 & 0x8000u) != 0) & (a1 >> 9)) == 0)
                              *a4++ = *((_WORD *)v105 + 1);
                            goto LABEL_194;
                          }
                          return v13;
                        }
                        v19 = 2;
                        v14 = v108;
LABEL_187:
                        v15 = v116;
                        v16 = v113;
                        v17 = v110;
                        goto LABEL_17;
                      }
                      v12 = *a6;
                      v14 = v108;
                      v15 = v116;
                      v16 = v113;
                      v17 = v22;
                      v67 = v105;
                    }
                    if ((((v65 & 0x8000u) != 0) & (a1 >> 9)) != 0)
                      v92 = 1;
                    else
                      v92 = 2;
                    v12 += v92;
                    if (a5)
                    {
                      if (v12 > a5)
                        return v13;
                      *a4 = v68;
                      if ((((v65 & 0x8000u) != 0) & (a1 >> 9)) != 0)
                      {
                        ++a4;
                      }
                      else
                      {
                        a4[1] = *((_WORD *)v67 + 1);
                        a4 += 2;
                      }
                      goto LABEL_160;
                    }
LABEL_168:
                    v19 = 2;
                    goto LABEL_17;
                  }
LABEL_56:
                  if ((unsigned __int16)(v25 + 21112) < 0xF3C9u)
                    goto LABEL_70;
                  v36 = (unsigned __int16 *)&MacKorean_to_uni_three_char;
                  v37 = (unsigned __int16 *)&unk_182CF7AD6;
                  while (1)
                  {
                    v38 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v37 - v36)) >> 1;
                    v39 = &v36[17 * v38];
                    v40 = *v39;
                    if (v40 <= v25)
                    {
                      if (v40 + 16 > v25)
                      {
                        v80 = v36[17 * v38 + 1 + (int)(v25 - v40)];
                        if (!v80)
                        {
LABEL_63:
                          if ((unsigned __int16)(v25 + 21136) < 0xF57Fu)
                            goto LABEL_70;
                          v41 = (unsigned __int16 *)&MacKorean_to_uni_five_char;
                          v42 = (unsigned __int16 *)&unk_182CF7CB2;
                          while (1)
                          {
                            v43 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v42 - v41)) >> 1;
                            v44 = &v41[17 * v43];
                            v45 = *v44;
                            if (v45 <= v25)
                            {
                              if (v45 + 16 > v25)
                              {
                                v93 = v41[17 * v43 + 1 + (int)(v25 - v45)];
                                if (v93)
                                {
                                  v94 = ((v93 & 0x8000u) != 0) & (a1 >> 9);
                                  v95 = 4;
                                  if (!v94)
                                    v95 = 5;
                                  v12 += v95;
                                  if (!a5)
                                  {
                                    v19 = 2;
                                    v16 = v23;
                                    goto LABEL_185;
                                  }
                                  if (v12 <= a5)
                                  {
                                    if ((v94 & 1) == 0)
                                      *a4++ = __CFFiveCharDecompSeqTable[5 * (v93 & 0x7FFF)];
                                    v101 = (char *)&__CFFiveCharDecompSeqTable[5 * (v93 & 0x7FFF)];
                                    *(_DWORD *)a4 = *(_DWORD *)(v101 + 2);
                                    a4[2] = *((_WORD *)v101 + 3);
                                    v102 = v14 ^ 1;
                                    if ((v93 & 0x8000u) != 0)
                                      v102 = 0;
                                    if ((v102 & 1) != 0)
                                    {
                                      a4 += 3;
                                    }
                                    else
                                    {
                                      a4[3] = *((_WORD *)v101 + 4);
                                      a4 += 4;
                                    }
                                    v19 = 2;
                                    v16 = v23;
LABEL_185:
                                    v17 = v22;
LABEL_17:
                                    *a6 = v12;
LABEL_18:
                                    v13 += v19;
                                    a2 += v19;
                                    v20 = (uint64_t)v9 <= v19;
                                    v9 -= v19;
                                    if (!v20)
                                      goto LABEL_8;
                                  }
                                  return v13;
                                }
LABEL_70:
                                v16 = v23;
                                v17 = v22;
                                if ((v18 + 1) < 0xA2u)
                                  goto LABEL_73;
                                if ((v24 + 1) < 0xA2u)
                                  goto LABEL_73;
                                v107 = v14;
                                v114 = v15;
                                v111 = v16;
                                v46 = __CFFromKSX1001(v25);
                                v17 = v22;
                                v16 = v111;
                                v15 = v114;
                                v14 = v107;
                                v47 = v46;
                                if ((_DWORD)v46 == 65533)
                                {
LABEL_73:
                                  if ((unsigned __int16)(v25 + 13919) <= 0x5Du)
                                  {
                                    if (a5)
                                    {
                                      v48 = v25 + 5727;
                                      goto LABEL_79;
                                    }
                                    goto LABEL_80;
                                  }
                                  if ((unsigned __int16)(v25 + 351) <= 0x5Du)
                                  {
                                    if (a5)
                                    {
                                      v48 = v25 - 3907;
LABEL_79:
                                      *a4++ = v48;
                                    }
LABEL_80:
                                    ++v12;
LABEL_81:
                                    v19 = 2;
                                    goto LABEL_17;
                                  }
                                  if ((unsigned __int16)(v25 + 23703) > 0x1Cu)
                                  {
                                    if (v25 != 42566)
                                      return v13;
                                    v12 += v17;
                                    if (a5)
                                    {
                                      if (v12 > a5)
                                        return v13;
                                      if ((a1 & 0x200) == 0)
                                        *a4++ = -1951;
                                      *(_DWORD *)a4 = 538976288;
                                      a4[2] = 8224;
                                      a4 += 3;
                                      goto LABEL_81;
                                    }
                                  }
                                  else
                                  {
                                    v12 += v17;
                                    if (a5)
                                    {
                                      if (v12 > a5)
                                        return v13;
                                      if ((a1 & 0x200) == 0)
                                        *a4++ = -1951;
                                      *a4 = 40;
                                      if (v25 >= 0xA381)
                                        v79 = 62;
                                      else
                                        v79 = 65;
                                      a4[1] = v79 + v25 + 23703;
                                      a4[2] = 41;
                                      a4 += 3;
LABEL_160:
                                      v19 = 2;
                                      goto LABEL_17;
                                    }
                                  }
                                  v19 = 2;
                                  goto LABEL_17;
                                }
                                if (v111)
                                {
                                  v49 = __CFStringEncodingIsDecomposableCharacter_0(v46, (a1 >> 7) & 1);
                                  v17 = v22;
                                  v16 = v111;
                                  v15 = v114;
                                  v14 = v107;
                                  if (v49)
                                  {
                                    v51 = __CFStringEncodingDecomposeCharacter_0(a1, v47, v117, v50, 63615, v107, v22, 8230);
                                    v52 = *a6;
                                    v12 = *a6 + v51;
                                    *a6 = v12;
                                    if (!a5)
                                      goto LABEL_142;
                                    if (v12 <= a5)
                                    {
                                      if (v51 >= 1)
                                      {
                                        v53 = v51 + 1;
                                        v54 = (__int16 *)v117;
                                        v14 = v107;
                                        v15 = v114;
                                        v16 = v111;
                                        v17 = v22;
                                        do
                                        {
                                          v55 = *v54++;
                                          *a4++ = v55;
                                          --v53;
                                        }
                                        while (v53 > 1);
                                        v19 = 2;
                                        goto LABEL_18;
                                      }
LABEL_142:
                                      v19 = 2;
                                      v14 = v107;
                                      v15 = v114;
                                      v16 = v111;
                                      v17 = v22;
                                      goto LABEL_18;
                                    }
LABEL_197:
                                    *a6 = v52;
                                    return v13;
                                  }
                                }
                                if (a5)
                                  *a4++ = v47;
                                goto LABEL_122;
                              }
                              v41 = v44 + 17;
                            }
                            else
                            {
                              v42 = v44 - 17;
                            }
                            if (v41 > v42)
                              goto LABEL_70;
                          }
                        }
                        v106 = (unsigned __int16 *)((char *)&__CFThreeCharDecompSeqTable
                                                  + 6 * (v36[17 * v38 + 1 + (int)(v25 - v40)] & 0x7FFF));
                        v81 = *v106;
                        v16 = v23;
                        v17 = v22;
                        if ((_DWORD)v16)
                        {
                          v110 = v22;
                          v113 = v16;
                          v116 = v15;
                          v109 = v14;
                          if ((__CFStringEncodingIsDecomposableCharacter_0(v81, (a1 >> 7) & 1) & 1) != 0)
                          {
                            v87 = __CFStringEncodingDecomposeCharacter_0(a1, v81, v117, v82, v83, v84, v85, v86);
                            if ((((v80 & 0x8000u) != 0) & (a1 >> 9)) != 0)
                              v88 = 1;
                            else
                              v88 = 2;
                            v12 = v87 + v88 + *a6;
                            if (a5)
                            {
                              v14 = v109;
                              v15 = v116;
                              v16 = v113;
                              v17 = v22;
                              if (v12 <= a5)
                              {
                                if (v87 >= 1)
                                {
                                  v89 = v87 + 1;
                                  v90 = (__int16 *)v117;
                                  do
                                  {
                                    v91 = *v90++;
                                    *a4++ = v91;
                                    --v89;
                                  }
                                  while (v89 > 1);
                                }
                                *a4 = v106[1];
                                v103 = v109 ^ 1;
                                if ((v80 & 0x8000u) != 0)
                                  v103 = 0;
                                if ((v103 & 1) != 0)
                                {
                                  ++a4;
                                }
                                else
                                {
                                  a4[1] = v106[2];
                                  a4 += 2;
                                }
LABEL_194:
                                v19 = 2;
                                goto LABEL_17;
                              }
                              return v13;
                            }
                            v19 = 2;
                            v14 = v109;
                            goto LABEL_187;
                          }
                          v12 = *a6;
                          v14 = v109;
                          v15 = v116;
                          v16 = v113;
                          v17 = v22;
                        }
                        v96 = 2;
                        if ((((v80 & 0x8000u) != 0) & (a1 >> 9)) == 0)
                          v96 = 3;
                        v12 += v96;
                        if (a5)
                        {
                          if (v12 > a5)
                            return v13;
                          if ((((v80 & 0x8000u) != 0) & (a1 >> 9)) != 0)
                          {
                            v97 = (char *)&__CFThreeCharDecompSeqTable + 6 * (v80 & 0x7FFF);
                            *a4 = v106[1];
                            v98 = a4 + 1;
                          }
                          else
                          {
                            v97 = (char *)&__CFThreeCharDecompSeqTable + 6 * (v80 & 0x7FFF);
                            a4[1] = v106[1];
                            v99 = a4 + 1;
                            *a4 = v81;
                            a4 += 2;
                            v98 = a4;
                            v100 = v14 ^ 1;
                            if ((v80 & 0x8000u) != 0)
                              v100 = 0;
                            if ((v100 & 1) != 0)
                              goto LABEL_160;
                            a4 = v99;
                          }
                          a4 += 2;
                          *v98 = *((_WORD *)v97 + 2);
                          goto LABEL_81;
                        }
                        goto LABEL_168;
                      }
                      v36 = v39 + 17;
                    }
                    else
                    {
                      v37 = v39 - 17;
                    }
                    if (v36 > v37)
                      goto LABEL_63;
                  }
                }
                v31 = v34 + 17;
              }
              else
              {
                v32 = v34 - 17;
              }
              if (v31 > v32)
                goto LABEL_56;
            }
          }
          v12 += v15;
          if (a5)
          {
            if (v12 > a5)
              return v13;
            *a4 = 8230;
            v21 = a4 + 1;
            if ((a1 & 0x200) != 0)
            {
LABEL_34:
              a4 = v21;
            }
            else
            {
LABEL_40:
              a4[1] = -1921;
              a4 += 2;
            }
          }
          break;
      }
    }
    else
    {
      if (a5)
        *a4++ = v18;
LABEL_15:
      ++v12;
    }
    v19 = 1;
    goto LABEL_17;
  }
  return v13;
}

void CFStringGetLineBounds(CFStringRef theString, CFRange range, CFIndex *lineBeginIndex, CFIndex *lineEndIndex, CFIndex *contentsEndIndex)
{
  CFIndex length;
  CFIndex location;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    -[__CFString getLineStart:end:contentsEnd:forRange:]((id)theString, "getLineStart:end:contentsEnd:forRange:", lineBeginIndex, lineEndIndex, contentsEndIndex, location, length);
  else
    __CFStringGetLineOrParagraphBounds(theString, location, length, lineBeginIndex, (unint64_t)lineEndIndex, contentsEndIndex, 1);
}

void CFSocketInvalidate(CFSocketRef s)
{
  unint64_t v2;
  unint64_t *v3;
  char v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  const __CFArray *v14;
  unsigned int FirstIndexOfValue;
  CFIndex v16;
  __CFData *v17;
  UInt8 *MutableBytePtr;
  const __CFArray *v19;
  unsigned int v20;
  CFIndex v21;
  __CFData *v22;
  UInt8 *v23;
  const void *v24;
  const void *v25;
  const void *v26;
  const __CFArray *v27;
  __CFRunLoopSource *v28;
  uint64_t v29;
  void (*v30)(uint64_t);
  int Count;
  CFIndex v32;
  __CFRunLoop *ValueAtIndex;
  char v35;
  char v36;
  uint64_t v37;
  CFRange v38;
  CFRange v39;

  v37 = *MEMORY[0x1E0C80C00];
  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  CFRetain(s);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllSocketsLock);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  v3 = (unint64_t *)((char *)s + 8);
  v4 = atomic_load((unint64_t *)s + 1);
  if ((v4 & 0x10) == 0)
  {
    pthread_mutex_unlock((pthread_mutex_t *)((char *)s + 24));
    goto LABEL_64;
  }
  v5 = atomic_load(v3);
  do
  {
    v6 = __ldaxr(v3);
    if (v6 == v5)
    {
      if (!__stlxr(v5 & 0xFFFFFFFFFFFFFFEFLL, v3))
      {
        v7 = 1;
        goto LABEL_16;
      }
    }
    else
    {
      __clrex();
    }
    v7 = 0;
LABEL_16:
    v5 = v6;
  }
  while (!v7);
  v8 = atomic_load(v3);
  do
  {
    v9 = __ldaxr(v3);
    if (v9 == v8)
    {
      if (!__stlxr(v8 & 0xFFFFFFFFFFFFFFBFLL, v3))
      {
        v10 = 1;
        goto LABEL_23;
      }
    }
    else
    {
      __clrex();
    }
    v10 = 0;
LABEL_23:
    v8 = v9;
  }
  while (!v10);
  v11 = atomic_load(v3);
  do
  {
    v12 = __ldaxr(v3);
    if (v12 == v11)
    {
      if (!__stlxr(v11 & 0xFFFFFFFFFFFFFFDFLL, v3))
      {
        v13 = 1;
        goto LABEL_30;
      }
    }
    else
    {
      __clrex();
    }
    v13 = 0;
LABEL_30:
    v11 = v12;
  }
  while (!v13);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
  v14 = (const __CFArray *)__CFWriteSockets;
  v38.length = CFArrayGetCount((CFArrayRef)__CFWriteSockets);
  v38.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v14, v38, s);
  if ((FirstIndexOfValue & 0x80000000) == 0)
  {
    CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFWriteSockets, FirstIndexOfValue);
    v16 = *((unsigned int *)s + 38);
    if ((v16 & 0x80000000) == 0)
    {
      v17 = (__CFData *)__CFWriteSocketsFds;
      if (v16 < 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds))
      {
        MutableBytePtr = CFDataGetMutableBytePtr(v17);
        if (__darwin_check_fd_set_overflow(v16, MutableBytePtr, 1))
        {
          if ((*(_DWORD *)&MutableBytePtr[4 * (v16 >> 5)] & (1 << v16)) != 0)
          {
            if (__darwin_check_fd_set_overflow(v16, MutableBytePtr, 1))
              *(_DWORD *)&MutableBytePtr[4 * (v16 >> 5)] &= ~(1 << v16);
            if ((_DWORD)__CFWakeupSocketPair != -1)
            {
              v35 = 120;
              send(__CFWakeupSocketPair, &v35, 1uLL, 0);
            }
          }
        }
      }
    }
  }
  v19 = (const __CFArray *)__CFReadSockets;
  v39.length = CFArrayGetCount((CFArrayRef)__CFReadSockets);
  v39.location = 0;
  v20 = CFArrayGetFirstIndexOfValue(v19, v39, s);
  if ((v20 & 0x80000000) == 0)
  {
    CFArrayRemoveValueAtIndex((CFMutableArrayRef)__CFReadSockets, v20);
    __CFReadSocketsTimeoutInvalid = 0;
    v21 = *((unsigned int *)s + 38);
    if ((v21 & 0x80000000) == 0)
    {
      v22 = (__CFData *)__CFReadSocketsFds;
      if (v21 < 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds))
      {
        v23 = CFDataGetMutableBytePtr(v22);
        if (__darwin_check_fd_set_overflow(v21, v23, 1))
        {
          if ((*(_DWORD *)&v23[4 * (v21 >> 5)] & (1 << v21)) != 0)
          {
            if (__darwin_check_fd_set_overflow(v21, v23, 1))
              *(_DWORD *)&v23[4 * (v21 >> 5)] &= ~(1 << v21);
            if ((_DWORD)__CFWakeupSocketPair != -1)
            {
              v36 = 115;
              send(__CFWakeupSocketPair, &v36, 1uLL, 0);
            }
          }
        }
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  CFDictionaryRemoveValue((CFMutableDictionaryRef)__CFAllSockets, (const void *)*((int *)s + 38));
  if ((*((_BYTE *)s + 16) & 0x80) != 0)
    close(*((_DWORD *)s + 38));
  *((_DWORD *)s + 38) = -1;
  v24 = (const void *)*((_QWORD *)s + 22);
  if (v24)
  {
    CFRelease(v24);
    *((_QWORD *)s + 22) = 0;
  }
  v25 = (const void *)*((_QWORD *)s + 32);
  if (v25)
  {
    CFRelease(v25);
    *((_QWORD *)s + 32) = 0;
  }
  v26 = (const void *)*((_QWORD *)s + 33);
  if (v26)
  {
    CFRelease(v26);
    *((_QWORD *)s + 33) = 0;
  }
  *((_DWORD *)s + 46) = 0;
  v27 = (const __CFArray *)CFRetain(*((CFTypeRef *)s + 25));
  CFRelease(*((CFTypeRef *)s + 25));
  v28 = (__CFRunLoopSource *)*((_QWORD *)s + 24);
  *((_QWORD *)s + 24) = 0;
  *((_QWORD *)s + 25) = 0;
  v29 = *((_QWORD *)s + 28);
  v30 = (void (*)(uint64_t))*((_QWORD *)s + 30);
  *((_OWORD *)s + 14) = 0u;
  *((_OWORD *)s + 15) = 0u;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)s + 24));
  Count = CFArrayGetCount(v27);
  if (Count)
  {
    v32 = Count - 1;
    do
    {
      ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(v27, v32);
      CFRunLoopWakeUp(ValueAtIndex);
    }
    while ((_DWORD)v32--);
  }
  CFRelease(v27);
  if (v30)
    v30(v29);
  if (v28)
  {
    CFRunLoopSourceInvalidate(v28);
    CFRelease(v28);
  }
LABEL_64:
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllSocketsLock);
  CFRelease(s);
}

void CFMachPortGetContext(CFMachPortRef port, CFMachPortContext *context)
{
  unint64_t v4;
  __int128 v5;
  __int128 v6;

  v4 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v4 != 36)
    _CFAssertMismatchedTypeID(0x24uLL, v4);
  v5 = *(_OWORD *)((char *)port + 56);
  v6 = *(_OWORD *)((char *)port + 72);
  context->copyDescription = (CFStringRef (__cdecl *)(const void *))*((_QWORD *)port + 11);
  *(_OWORD *)&context->version = v5;
  *(_OWORD *)&context->retain = v6;
}

void CFCalendarSetLocale(CFCalendarRef calendar, CFLocaleRef locale)
{
  -[__CFCalendar setLocale:](calendar, "setLocale:", locale);
}

Boolean CFBundleLoadExecutableAndReturnError(CFBundleRef bundle, CFErrorRef *error)
{
  return _CFBundleLoadExecutableAndReturnError((uint64_t)bundle, 0, error);
}

void CFBagSetValue(CFMutableBagRef theBag, const void *value)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v10;

  v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0)
    CFLog(3, (uint64_t)CFSTR("%s(): immutable collection %p given to mutating function"), v2, v3, v4, v5, v6, v7, (__int16)"void CFBagSetValue(CFMutableBagRef, const void *)");
  CFBasicHashSetValue((uint64_t)theBag, (unint64_t)value, (uint64_t)value);
}

void sub_182BA12CC(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

uint64_t __CFArrayHash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

__CFString *__CFArrayCopyDescription(unint64_t a1)
{
  uint64_t v2;
  const CFAllocatorRef *v3;
  char v4;
  CFAllocatorRef v5;
  __CFString *Mutable;
  __CFString *v7;
  char v8;
  int v9;
  const __CFString *v10;
  const char *v11;
  unsigned int v12;
  int v13;
  const CFArrayCallBacks *v14;
  char v15;
  int v16;
  uint64_t i;
  char v18;
  uint64_t v19;
  char v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t (*copyDescription)(uint64_t);
  uint64_t v25;
  const void *v26;

  v2 = *(_QWORD *)(a1 + 16);
  if ((a1 & 0x8000000000000000) != 0)
  {
    v3 = &kCFAllocatorSystemDefault;
  }
  else
  {
    v4 = atomic_load((unint64_t *)(a1 + 8));
    if (v4 < 0)
      v3 = &kCFAllocatorSystemDefault;
    else
      v3 = (const CFAllocatorRef *)(a1 - 16);
  }
  v5 = *v3;
  Mutable = CFStringCreateMutable(*v3, 0);
  v7 = Mutable;
  v8 = atomic_load((unint64_t *)(a1 + 8));
  v9 = v8 & 3;
  if (v9)
  {
    if (v9 != 2)
      goto LABEL_13;
    v10 = CFSTR("<CFArray %p [%p]>{type = mutable-small, count = %lu, values = (%s");
  }
  else
  {
    v10 = CFSTR("<CFArray %p [%p]>{type = immutable, count = %lu, values = (%s");
  }
  v11 = "\n";
  if (!v2)
    v11 = "";
  CFStringAppendFormat(Mutable, 0, v10, a1, v5, v2, v11);
LABEL_13:
  v12 = atomic_load((unint64_t *)(a1 + 8));
  v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
      v14 = &kCFTypeArrayCallBacks;
    }
    else
    {
      v15 = atomic_load((unint64_t *)(a1 + 8));
      v16 = v15 & 3;
      if (v16 != 2 && v16)
        v14 = 0;
      else
        v14 = (const CFArrayCallBacks *)(a1 + 48);
    }
  }
  else
  {
    v14 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  if (v2 >= 1)
  {
    for (i = 0; i != v2; ++i)
    {
      atomic_load((unint64_t *)(a1 + 8));
      v18 = atomic_load((unint64_t *)(a1 + 8));
      if ((v18 & 3) != 0)
      {
        v19 = *(_QWORD *)(a1 + 40) + 8 * **(_QWORD **)(a1 + 40) + 16;
      }
      else
      {
        v20 = atomic_load((unint64_t *)(a1 + 8));
        v21 = (~v20 & 0xC) == 0;
        v22 = 48;
        if (v21)
          v22 = 88;
        v19 = a1 + v22;
      }
      v23 = *(_QWORD *)(v19 + 8 * i);
      copyDescription = (uint64_t (*)(uint64_t))v14->copyDescription;
      if (copyDescription && (v25 = copyDescription(v23)) != 0)
      {
        v26 = (const void *)v25;
        CFStringAppendFormat(v7, 0, CFSTR("\t%lu : %@\n"), i, v25);
        CFRelease(v26);
      }
      else
      {
        CFStringAppendFormat(v7, 0, CFSTR("\t%lu : <%p>\n"), i, v23);
      }
    }
  }
  CFStringAppend(v7, CFSTR(")}"));
  return v7;
}

void CFArrayExchangeValuesAtIndices(CFMutableArrayRef theArray, CFIndex idx1, CFIndex idx2)
{
  unint64_t *v6;
  char v7;
  char v8;
  int v9;
  char v10;
  BOOL v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char v15;
  char *v16;
  char v17;
  uint64_t v18;
  uint64_t v19;

  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    -[__CFArray exchangeObjectAtIndex:withObjectAtIndex:](theArray, "exchangeObjectAtIndex:withObjectAtIndex:", idx1, idx2);
  }
  else
  {
    v6 = (unint64_t *)((char *)theArray + 8);
    v7 = atomic_load((unint64_t *)theArray + 1);
    if ((v7 & 1 | 2) == 2)
    {
      v8 = atomic_load(v6);
      v9 = v8 & 3;
      if (v9 == 2)
      {
        v13 = (char *)(*((_QWORD *)theArray + 5) + 8 * **((_QWORD **)theArray + 5) + 16);
      }
      else if (v9)
      {
        v13 = 0;
      }
      else
      {
        v10 = atomic_load((unint64_t *)theArray + 1);
        v11 = (~v10 & 0xC) == 0;
        v12 = 48;
        if (v11)
          v12 = 88;
        v13 = (char *)theArray + v12;
      }
      v14 = &v13[8 * idx1];
    }
    else
    {
      v14 = 0;
    }
    atomic_load(v6);
    v15 = atomic_load(v6);
    if ((v15 & 3) != 0)
    {
      v16 = (char *)(*((_QWORD *)theArray + 5) + 8 * **((_QWORD **)theArray + 5) + 16);
    }
    else
    {
      v17 = atomic_load((unint64_t *)theArray + 1);
      v11 = (~v17 & 0xC) == 0;
      v18 = 48;
      if (v11)
        v18 = 88;
      v16 = (char *)theArray + v18;
    }
    v19 = *(_QWORD *)v14;
    *(_QWORD *)v14 = *(_QWORD *)&v16[8 * idx2];
    *(_QWORD *)&v16[8 * idx2] = v19;
    ++*((_QWORD *)theArray + 3);
  }
}

void _CFArraySortValues(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  CFIndex v6;
  void **Typed;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[2];
  void *values[2];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  CFRange v45;
  CFRange v46;

  v44 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)a1))
    v6 = objc_msgSend(a1, "count");
  else
    v6 = a1[2];
  if (v6 >= 2)
  {
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v20 = 0u;
    v21 = 0u;
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v14 = 0u;
    v15 = 0u;
    Typed = values;
    *(_OWORD *)values = 0u;
    v13 = 0u;
    if ((unint64_t)v6 >= 0x101)
      Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v6, 0x80040B8603338, 0);
    v45.location = 0;
    v45.length = v6;
    CFArrayGetValues((CFArrayRef)a1, v45, (const void **)Typed);
    v11[0] = a2;
    v11[1] = a3;
    CFQSortArray(Typed, v6, 8, (uint64_t)__CFArrayCompareValues, (uint64_t)v11, v8, v9, v10);
    v46.location = 0;
    v46.length = v6;
    CFArrayReplaceValues((CFMutableArrayRef)a1, v46, (const void **)Typed, v6);
    if (Typed != values)
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
}

uint64_t __CFAttributedStringEqual(CFStringRef *a1, _QWORD *a2)
{
  CFStringRef v4;
  const void *v5;
  uint64_t result;
  CFIndex Length;
  CFIndex v8;
  CFIndex location;
  CFIndex v10;
  CFIndex v11;
  CFIndex v12;
  CFDictionaryRef v13;
  CFDictionaryRef Attributes;
  CFIndex v15;
  CFRange v16;
  CFRange effectiveRange;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = a1[2];
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)a2))
    v5 = (const void *)objc_msgSend(a2, "string");
  else
    v5 = (const void *)a2[2];
  result = CFEqual(v4, v5);
  if ((_DWORD)result)
  {
    Length = CFStringGetLength(a1[2]);
    effectiveRange.location = 0;
    effectiveRange.length = 0;
    v16.location = 0;
    v16.length = 0;
    if (Length < 1)
    {
      return 1;
    }
    else
    {
      v8 = Length;
      location = 0;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      Attributes = 0;
      v15 = 0;
      while (1)
      {
        if (v15 >= v11 + v12)
        {
          Attributes = CFAttributedStringGetAttributes((CFAttributedStringRef)a1, v15, &effectiveRange);
          location = v16.location;
          v10 = v16.length;
        }
        if (v15 >= location + v10)
          v13 = CFAttributedStringGetAttributes((CFAttributedStringRef)a2, v15, &v16);
        result = CFEqual(Attributes, v13);
        if (!(_DWORD)result)
          break;
        location = v16.location;
        v10 = v16.length;
        v11 = effectiveRange.location;
        v12 = effectiveRange.length;
        if (effectiveRange.location + effectiveRange.length >= v16.location + v16.length)
          v15 = v16.location + v16.length;
        else
          v15 = effectiveRange.location + effectiveRange.length;
        if (v15 >= v8)
          return 1;
      }
    }
  }
  return result;
}

CFHashCode __CFAttributedStringHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 16));
}

__CFString *__CFAttributedStringCopyDescription(uint64_t a1, uint64_t a2)
{
  CFStringRef *v2;
  __CFString *Mutable;
  CFIndex Length;
  CFIndex v5;
  CFIndex location;
  const __CFDictionary *Attributes;
  const __CFString *v8;
  unint64_t Count;
  unint64_t v10;
  void **v11;
  void **v12;
  unint64_t v13;
  const char *v14;
  CFRange effectiveRange;
  void *values[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  void *keys[2];
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  uint64_t v81;

  v2 = (CFStringRef *)MEMORY[0x1E0C80A78](a1, a2);
  v81 = *MEMORY[0x1E0C80C00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  Length = CFStringGetLength(v2[2]);
  effectiveRange.location = 0;
  effectiveRange.length = 0;
  if (Length >= 1)
  {
    v5 = Length;
    location = 0;
    while (1)
    {
      Attributes = CFAttributedStringGetAttributes((CFAttributedStringRef)v2, location, &effectiveRange);
      v8 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2[2], effectiveRange);
      CFStringAppend(Mutable, v8);
      CFRelease(v8);
      CFStringAppendFormat(Mutable, 0, CFSTR(" %p {"), Attributes);
      Count = CFDictionaryGetCount(Attributes);
      v80 = 0u;
      v79 = 0u;
      v78 = 0u;
      v77 = 0u;
      v76 = 0u;
      v75 = 0u;
      v74 = 0u;
      v73 = 0u;
      v72 = 0u;
      v71 = 0u;
      v70 = 0u;
      v69 = 0u;
      v68 = 0u;
      v67 = 0u;
      v66 = 0u;
      v65 = 0u;
      v64 = 0u;
      v63 = 0u;
      v62 = 0u;
      v61 = 0u;
      v60 = 0u;
      v59 = 0u;
      v58 = 0u;
      v57 = 0u;
      v56 = 0u;
      v55 = 0u;
      v54 = 0u;
      v53 = 0u;
      v52 = 0u;
      v51 = 0u;
      v50 = 0u;
      *(_OWORD *)keys = 0u;
      if (Count >= 0xFFFFFFFFFFFFFFFLL)
        __CFAttributedStringCopyDescription_cold_1();
      v10 = Count;
      if (Count >= 0x101)
        break;
      v47 = 0uLL;
      v48 = 0uLL;
      v45 = 0uLL;
      v46 = 0uLL;
      v43 = 0uLL;
      v44 = 0uLL;
      v41 = 0uLL;
      v42 = 0uLL;
      v39 = 0uLL;
      v40 = 0uLL;
      v37 = 0uLL;
      v38 = 0uLL;
      v35 = 0uLL;
      v36 = 0uLL;
      v33 = 0uLL;
      v34 = 0uLL;
      v31 = 0uLL;
      v32 = 0uLL;
      v29 = 0uLL;
      v30 = 0uLL;
      v27 = 0uLL;
      v28 = 0uLL;
      v25 = 0uLL;
      v26 = 0uLL;
      v23 = 0uLL;
      v24 = 0uLL;
      v21 = 0uLL;
      v22 = 0uLL;
      v19 = 0uLL;
      v20 = 0uLL;
      *(_OWORD *)values = 0uLL;
      v18 = 0uLL;
      v11 = keys;
      v12 = values;
      CFDictionaryGetKeysAndValues(Attributes, (const void **)keys, (const void **)values);
      if (v10)
        goto LABEL_8;
LABEL_13:
      CFStringAppendFormat(Mutable, 0, CFSTR("} Len %ld\n"), effectiveRange.length);
      effectiveRange.location += effectiveRange.length;
      if (v11 != keys)
        free(v11);
      if (v12 != values)
        free(v12);
      location = effectiveRange.location;
      if (effectiveRange.location >= v5)
        return Mutable;
    }
    v11 = (void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
    v47 = 0u;
    v48 = 0u;
    v45 = 0u;
    v46 = 0u;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    *(_OWORD *)values = 0u;
    v18 = 0u;
    v12 = (void **)malloc_type_malloc(8 * v10, 0xC0040B8AA526DuLL);
    CFDictionaryGetKeysAndValues(Attributes, (const void **)v11, (const void **)v12);
LABEL_8:
    v13 = v10 - 1;
    do
    {
      if (v13)
        v14 = ", ";
      else
        v14 = "";
      CFStringAppendFormat(Mutable, 0, CFSTR("%@=%@%s"), v11[v13], v12[v13], v14);
      --v13;
    }
    while (v13 != -1);
    goto LABEL_13;
  }
  return Mutable;
}

CFAttributedStringRef CFAttributedStringCreateWithSubstring(CFAllocatorRef alloc, CFAttributedStringRef aStr, CFRange range)
{
  CFIndex length;
  CFIndex location;
  CFAttributedStringRef result;
  CFIndex v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    return (CFAttributedStringRef)-[__CFAttributedString _createAttributedSubstringWithRange:](aStr, "_createAttributedSubstringWithRange:", location, length);
  v8 = CFAttributedStringGetLength(aStr);
  if (location || length != v8)
  {
    result = __CFAttributedStringCreateMutableWithSubstring(alloc, (CFStringRef *)aStr, location, length);
    v9 = (unint64_t *)((char *)result + 8);
    v10 = atomic_load((unint64_t *)result + 1);
    while (1)
    {
      v11 = __ldaxr(v9);
      if (v11 != v10)
        break;
      if (__stlxr(v10 | 1, v9))
        goto LABEL_11;
      v12 = 1;
LABEL_12:
      v10 = v11;
      if (v12)
        return result;
    }
    __clrex();
LABEL_11:
    v12 = 0;
    goto LABEL_12;
  }
  return CFAttributedStringCreateCopy(alloc, aStr);
}

uint64_t _CFAttributedStringCreateWithRuns(__objc2_class **a1, const __CFString *a2, const __CFDictionary **a3, uint64_t a4, uint64_t a5)
{
  uint64_t Instance;
  CFIndex Length;
  uint64_t v12;
  CFMutableDictionaryRef Mutable;
  uint64_t *v14;
  const __CFDictionary *v15;
  CFMutableDictionaryRef AttributesDictionary;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  int v20;

  Instance = _CFRuntimeCreateInstance(a1, 0x3EuLL, 16, 0);
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = CFStringCreateCopy((CFAllocatorRef)a1, a2);
    *(_QWORD *)(Instance + 24) = CFRunArrayCreate(a1);
    Length = CFStringGetLength(*(CFStringRef *)(Instance + 16));
    if (Length)
    {
      v12 = Length;
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)a1, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFRunArrayInsert(*(CFTypeRef *)(Instance + 24), 0, v12, Mutable);
      CFRelease(Mutable);
    }
    if (a5 >= 1)
    {
      v14 = (uint64_t *)(a4 + 8);
      do
      {
        v15 = *a3++;
        AttributesDictionary = __CFAttributedStringCreateAttributesDictionary((const __CFAllocator *)a1, v15);
        CFRunArrayReplace(*(_QWORD **)(Instance + 24), *(v14 - 1), *v14, AttributesDictionary, *v14);
        CFRelease(AttributesDictionary);
        v14 += 2;
        --a5;
      }
      while (a5);
    }
    v17 = (unint64_t *)(Instance + 8);
    v18 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      v19 = __ldaxr(v17);
      if (v19 != v18)
        break;
      if (__stlxr(v18 | 1, v17))
        goto LABEL_12;
      v20 = 1;
LABEL_13:
      v18 = v19;
      if (v20)
        return Instance;
    }
    __clrex();
LABEL_12:
    v20 = 0;
    goto LABEL_13;
  }
  return Instance;
}

uint64_t _CFAttributedStringGetNumberOfRuns(const __CFAttributedString *a1, int a2)
{
  CFIndex Length;
  CFIndex v5;
  CFIndex v6;
  uint64_t v7;
  const __CFDictionary *AttributesAndLongestEffectiveRange;
  BOOL v9;
  CFRange longestEffectiveRange;
  uint64_t v12;
  CFRange v13;

  v12 = *MEMORY[0x1E0C80C00];
  Length = CFAttributedStringGetLength(a1);
  if (Length < 1)
    return 0;
  v5 = Length;
  v6 = 0;
  v7 = 0;
  do
  {
    longestEffectiveRange.location = 0;
    longestEffectiveRange.length = 0;
    v13.location = v6;
    v13.length = v5;
    AttributesAndLongestEffectiveRange = CFAttributedStringGetAttributesAndLongestEffectiveRange(a1, v6, v13, &longestEffectiveRange);
    if (a2 || CFDictionaryGetCount(AttributesAndLongestEffectiveRange) >= 1)
      ++v7;
    v6 += longestEffectiveRange.length;
    v9 = v5 <= longestEffectiveRange.length;
    v5 -= longestEffectiveRange.length;
  }
  while (!v9);
  return v7;
}

uint64_t _CFAttributedStringGetRuns(const __CFAttributedString *a1, int a2, uint64_t *a3, CFRange *a4)
{
  uint64_t result;
  CFIndex v9;
  CFIndex v10;
  uint64_t v11;
  BOOL v12;
  CFRange longestEffectiveRange;
  uint64_t v14;
  CFRange v15;

  v14 = *MEMORY[0x1E0C80C00];
  result = CFAttributedStringGetLength(a1);
  if (result >= 1)
  {
    v9 = result;
    v10 = 0;
    do
    {
      longestEffectiveRange.location = 0;
      longestEffectiveRange.length = 0;
      v15.location = v10;
      v15.length = v9;
      result = (uint64_t)CFAttributedStringGetAttributesAndLongestEffectiveRange(a1, v10, v15, &longestEffectiveRange);
      v11 = result;
      if (a2 || (result = CFDictionaryGetCount((CFDictionaryRef)result), result >= 1))
      {
        if (a3)
          *a3++ = v11;
        if (a4)
          *a4++ = longestEffectiveRange;
      }
      v10 += longestEffectiveRange.length;
      v12 = v9 <= longestEffectiveRange.length;
      v9 -= longestEffectiveRange.length;
    }
    while (!v12);
  }
  return result;
}

CFMutableStringRef CFAttributedStringGetMutableString(CFMutableAttributedStringRef aStr)
{
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    return (CFMutableStringRef)-[__CFAttributedString mutableString](aStr, "mutableString");
  else
    return 0;
}

void CFAttributedStringRemoveAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName)
{
  CFIndex length;
  CFIndex location;
  __CFDictionary *ValueAtIndex;
  __CFDictionary *v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  const __CFAllocator *v13;
  __CFDictionary *AttributesDictionary;
  CFIndex v15;
  CFIndex v16;
  uint64_t v17;

  length = range.length;
  location = range.location;
  v17 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
  {
    -[__CFAttributedString removeAttribute:range:](aStr, "removeAttribute:range:", attrName, location, length);
    return;
  }
  if (length)
  {
    while (1)
    {
      v15 = 0;
      v16 = 0;
      ValueAtIndex = (__CFDictionary *)CFRunArrayGetValueAtIndex(*((_QWORD *)aStr + 3), location, &v15, 0);
      v8 = ValueAtIndex;
      v10 = v15;
      v9 = v16;
      v11 = v15 == location && v16 <= length;
      if (!v11)
        goto LABEL_12;
      if (CFGetRetainCount(ValueAtIndex) != 1)
        break;
      CFDictionaryRemoveValue(v8, attrName);
LABEL_19:
      location += v16;
      length -= v16;
      if (!length)
        return;
    }
    v10 = v15;
    v9 = v16;
LABEL_12:
    v11 = v10 < location;
    v12 = v10 - location;
    if (v11)
    {
      v9 += v12;
      v15 = location;
      v16 = v9;
    }
    if (v9 > length)
      v16 = length;
    if (CFDictionaryContainsKey(v8, attrName))
    {
      v13 = CFGetAllocator(aStr);
      AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v13, v8);
      CFDictionaryRemoveValue(AttributesDictionary, attrName);
      CFRunArrayReplace(*((_QWORD **)aStr + 3), v15, v16, AttributesDictionary, v16);
      CFRelease(AttributesDictionary);
    }
    goto LABEL_19;
  }
}

void CFAttributedStringReplaceAttributedString(CFMutableAttributedStringRef aStr, CFRange range, CFAttributedStringRef replacement)
{
  CFIndex length;
  CFIndex location;
  const __CFString *v7;
  CFIndex v8;
  const __CFAllocator *v9;
  CFIndex v10;
  const __CFDictionary *Attributes;
  CFMutableDictionaryRef AttributesDictionary;
  CFRange effectiveRange;
  uint64_t v14;
  CFRange v15;

  length = range.length;
  location = range.location;
  v14 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
  {
    -[__CFAttributedString replaceCharactersInRange:withAttributedString:](aStr, "replaceCharactersInRange:withAttributedString:", location, length, replacement);
  }
  else
  {
    if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)replacement))
      v7 = (const __CFString *)-[__CFAttributedString string](replacement, "string");
    else
      v7 = (const __CFString *)*((_QWORD *)replacement + 2);
    v8 = CFStringGetLength(v7);
    if (v8 >= 1)
    {
      v9 = CFGetAllocator(aStr);
      v10 = 0;
      effectiveRange.location = 0;
      effectiveRange.length = 0;
      do
      {
        Attributes = CFAttributedStringGetAttributes(replacement, v10, &effectiveRange);
        AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v9, Attributes);
        CFRunArrayInsert(*((CFTypeRef *)aStr + 3), effectiveRange.location + location, effectiveRange.length, AttributesDictionary);
        CFRelease(AttributesDictionary);
        v10 = effectiveRange.location + effectiveRange.length;
        effectiveRange.location = v10;
      }
      while (v10 < v8);
    }
    if (length >= 1)
      CFRunArrayDelete(*((_QWORD **)aStr + 3), v8 + location, length);
    v15.location = location;
    v15.length = length;
    CFStringReplace(*((CFMutableStringRef *)aStr + 2), v15, v7);
  }
}

void CFAttributedStringBeginEditing(CFMutableAttributedStringRef aStr)
{
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    -[__CFAttributedString beginEditing](aStr, "beginEditing");
}

void CFAttributedStringEndEditing(CFMutableAttributedStringRef aStr)
{
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    -[__CFAttributedString endEditing](aStr, "endEditing");
}

BOOL _CFAttributedStringIsMutable(uint64_t a1)
{
  char v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 & 1) == 0;
}

BOOL __CFAttributedStringMtbl(uint64_t a1)
{
  char v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 & 1) == 0;
}

uint64_t _CFAttributedStringCheckAndReplace(uint64_t a1, CFIndex a2, CFIndex a3, const __CFString *a4)
{
  CFIndex Length;
  char v11;
  CFRange v12;

  Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length)
    return 3;
  v11 = atomic_load((unint64_t *)(a1 + 8));
  if ((v11 & 1) != 0)
    return 1;
  v12.location = a2;
  v12.length = a3;
  CFAttributedStringReplaceString((CFMutableAttributedStringRef)a1, v12, a4);
  return 0;
}

uint64_t _CFAttributedStringCheckAndReplaceAttributed(uint64_t a1, CFIndex a2, CFIndex a3, const __CFAttributedString *a4)
{
  CFIndex Length;
  char v11;
  CFRange v12;

  Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length)
    return 3;
  v11 = atomic_load((unint64_t *)(a1 + 8));
  if ((v11 & 1) != 0)
    return 1;
  v12.location = a2;
  v12.length = a3;
  if (a4)
    CFAttributedStringReplaceAttributedString((CFMutableAttributedStringRef)a1, v12, a4);
  else
    CFAttributedStringReplaceString((CFMutableAttributedStringRef)a1, v12, &stru_1E1337B18);
  return 0;
}

uint64_t _CFAttributedStringCheckAndSetAttributes(uint64_t a1, CFIndex a2, CFIndex a3, const __CFDictionary *a4, Boolean a5)
{
  CFIndex Length;
  char v13;
  CFRange v14;

  Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length)
    return 3;
  v13 = atomic_load((unint64_t *)(a1 + 8));
  if ((v13 & 1) != 0)
    return 1;
  v14.location = a2;
  v14.length = a3;
  CFAttributedStringSetAttributes((CFMutableAttributedStringRef)a1, v14, a4, a5);
  return 0;
}

uint64_t _CFAttributedStringCheckAndSetAttribute(uint64_t a1, CFIndex a2, CFIndex a3, const __CFString *a4, const void *a5)
{
  CFIndex Length;
  char v13;
  CFRange v14;

  Length = CFStringGetLength(*(CFStringRef *)(a1 + 16));
  if (a2 > Length || a2 + a3 > Length)
    return 3;
  v13 = atomic_load((unint64_t *)(a1 + 8));
  if ((v13 & 1) != 0)
    return 1;
  if (!a4)
    return 2;
  v14.location = a2;
  v14.length = a3;
  if (a5)
    CFAttributedStringSetAttribute((CFMutableAttributedStringRef)a1, v14, a4, a5);
  else
    CFAttributedStringRemoveAttribute((CFMutableAttributedStringRef)a1, v14, a4);
  return 0;
}

uint64_t __CFBagCreateTransfer(__objc2_class **a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v12[11];

  v12[10] = *MEMORY[0x1E0C80C00];
  v12[6] = (uint64_t)CFHash;
  v12[7] = 0;
  v12[0] = (uint64_t)__CFTypeCollectionRetain;
  v12[1] = (uint64_t)__CFTypeCollectionRetain;
  v12[2] = (uint64_t)__CFTypeCollectionRelease;
  v12[3] = (uint64_t)__CFTypeCollectionRelease;
  v12[4] = (uint64_t)CFEqual;
  v12[5] = (uint64_t)CFEqual;
  v12[8] = (uint64_t)CFCopyDescription;
  v12[9] = (uint64_t)CFCopyDescription;
  v5 = CFBasicHashCreate(a1, 0x2002u, v12);
  CFBasicHashSuppressRC(v5);
  if (a3 >= 1)
  {
    CFBasicHashSetCapacity(v5, a3);
    do
    {
      v6 = *a2++;
      CFBasicHashAddValue(v5, v6, v6);
      --a3;
    }
    while (a3);
  }
  CFBasicHashUnsuppressRC(v5);
  v7 = (unint64_t *)(v5 + 8);
  v8 = atomic_load((unint64_t *)(v5 + 8));
  do
  {
    v9 = __ldaxr(v7);
    if (v9 == v8)
    {
      if (!__stlxr(v8 | 0x40, v7))
      {
        v10 = 1;
        goto LABEL_10;
      }
    }
    else
    {
      __clrex();
    }
    v10 = 0;
LABEL_10:
    v8 = v9;
  }
  while (!v10);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)v5, 4uLL);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  return v5;
}

CFBagRef CFBagCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFBagCallBacks *callBacks)
{
  uint64_t Generic;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;

  Generic = __CFBagCreateGeneric((__objc2_class **)allocator, (uint64_t)callBacks);
  v7 = (unint64_t *)Generic;
  if (!Generic)
    return (CFBagRef)v7;
  if (numValues >= 1)
  {
    CFBasicHashSetCapacity(Generic, numValues);
    do
    {
      v8 = (unint64_t)*values++;
      CFBasicHashAddValue((uint64_t)v7, v8, v8);
      --numValues;
    }
    while (numValues);
  }
  v9 = v7 + 1;
  v10 = atomic_load(v7 + 1);
  do
  {
    v11 = __ldaxr(v9);
    if (v11 == v10)
    {
      if (!__stlxr(v10 | 0x40, v9))
      {
        v12 = 1;
        goto LABEL_11;
      }
    }
    else
    {
      __clrex();
    }
    v12 = 0;
LABEL_11:
    v10 = v11;
  }
  while (!v12);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)v7, 4uLL);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  return (CFBagRef)v7;
}

void CFBagGetValues(CFBagRef theBag, const void **values)
{
  uint64_t Count;

  Count = CFBasicHashGetCount((uint64_t)theBag);
  CFBasicHashGetElements((uint64_t)theBag, Count, 0, (uint64_t)values);
}

CFMutableBagRef CFBagCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFBagRef theBag)
{
  uint64_t Count;
  _OWORD *Typed;
  objc_class **Copy;
  uint64_t v8;
  uint64_t Generic;
  uint64_t i;
  _OWORD v12[128];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(4uLL, (__objc2_class **)theBag))
  {
    Count = CFBasicHashGetCount((uint64_t)theBag);
    memset(v12, 0, 512);
    if (Count >= 257)
      Typed = (_OWORD *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
    else
      Typed = v12;
    v8 = CFBasicHashGetCount((uint64_t)theBag);
    CFBasicHashGetElements((uint64_t)theBag, v8, 0, (uint64_t)Typed);
    Generic = __CFBagCreateGeneric((__objc2_class **)allocator, (uint64_t)&kCFTypeBagCallBacks);
    Copy = (objc_class **)Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (i = 0; i < Count; ++i)
        CFBasicHashAddValue((uint64_t)Copy, *((_QWORD *)Typed + i), *((_QWORD *)Typed + i));
    }
    if (Count >= 257)
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
  else
  {
    Copy = (objc_class **)CFBasicHashCreateCopy((__objc2_class **)allocator, (uint64_t)theBag);
  }
  if (Copy)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 4uLL);
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
  }
  return (CFMutableBagRef)Copy;
}

Boolean CFBagContainsValue(CFBagRef theBag, const void *value)
{
  return CFBasicHashGetCountOfKey((uint64_t)theBag, (unint64_t)value) > 0;
}

Boolean CFBagGetValueIfPresent(CFBagRef theBag, const void *candidate, const void **value)
{
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5 = 0u;
  v6 = 0u;
  CFBasicHashFindBucket((uint64_t)theBag, (unint64_t)candidate, (uint64_t *)&v5);
  if (!*((_QWORD *)&v6 + 1))
    return 0;
  if (value)
    *value = (const void *)v6;
  return 1;
}

BOOL _CFBagIsMutable(uint64_t a1)
{
  unsigned int v3;

  if (CF_IS_OBJC(4uLL, (__objc2_class **)a1))
    return 0;
  v3 = atomic_load((unint64_t *)(a1 + 8));
  return ((v3 >> 6) & 1) == 0;
}

void _CFBagSetCapacity(__objc2_class **a1, uint64_t a2)
{
  if (!CF_IS_OBJC(4uLL, a1))
    CFBasicHashSetCapacity((uint64_t)a1, a2);
}

void CFBagReplaceValue(CFMutableBagRef theBag, const void *value)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v10;

  v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0)
    CFLog(3, (uint64_t)CFSTR("%s(): immutable collection %p given to mutating function"), v2, v3, v4, v5, v6, v7, (__int16)"void CFBagReplaceValue(CFMutableBagRef, const void *)");
  CFBasicHashReplaceValue((unint64_t)theBag, (unint64_t)value, (uint64_t)value);
}

uint64_t __CFAllocatorGetAllocator(uint64_t result)
{
  if (*(_QWORD *)(result + 128) != 939)
    return *(_QWORD *)(result + 128);
  return result;
}

CFStringRef __CFAllocatorCopyDescription(uint64_t a1)
{
  const __CFAllocator *v1;

  v1 = *(const __CFAllocator **)(a1 + 128);
  if (v1 == (const __CFAllocator *)939)
    v1 = (const __CFAllocator *)a1;
  return CFStringCreateWithFormat(v1, 0, CFSTR("<CFAllocator %p [%p]>{info = %p}"), a1, v1, *(_QWORD *)(a1 + 144));
}

CFTypeID CFAllocatorGetTypeID(void)
{
  return 2;
}

void CFAllocatorSetDefault(CFAllocatorRef allocator)
{
  CFAllocatorRef v2;

  v2 = (CFAllocatorRef)_CFGetTSD(1u);
  if (!v2)
    v2 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
  if (allocator)
  {
    if (*(_QWORD *)allocator == qword_1ECCFACA8 && v2 != allocator)
    {
      CFRelease(v2);
      CFRetain(allocator);
      CFRetain(allocator);
      _CFSetTSD(1u, (uint64_t)allocator, 0);
    }
  }
}

void *_CFAllocatorAllocateImpl(malloc_zone_t *a1, size_t size, malloc_type_id_t type_id, uint64_t a4)
{
  void *(__cdecl *realloc)(_malloc_zone_t *, void *, size_t);
  void *(__cdecl *malloc)(_malloc_zone_t *, size_t);

  if (a1)
  {
    if (!size)
      return 0;
  }
  else
  {
    a1 = (malloc_zone_t *)_CFGetTSD(1u);
    if (!a1)
      a1 = (malloc_zone_t *)&__kCFAllocatorSystemDefault;
    if (!size)
      return 0;
  }
  if (a1->reserved1 != (void *)qword_1ECCFACA8)
    return malloc_type_zone_malloc(a1, size, type_id);
  realloc = a1[1].realloc;
  if (realloc)
    return (void *)((uint64_t (*)(size_t, malloc_type_id_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))realloc)(size, type_id, a4, a1->try_free_default);
  malloc = a1[1].malloc;
  if (malloc)
    return (void *)((uint64_t (*)(size_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))malloc)(size, a4, a1->try_free_default);
  return 0;
}

void *CFAllocatorReallocateImpl(malloc_zone_t *a1, malloc_zone_t *zone, uint64_t a3, malloc_type_id_t type_id, uint64_t a5)
{
  uint64_t (*realloc)(malloc_zone_t *, uint64_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *));
  void (__cdecl *try_free_default)(_malloc_zone_t *, void *);
  malloc_zone_t *v11;
  uint64_t v12;
  void *(__cdecl *valloc)(_malloc_zone_t *, size_t);
  void (__cdecl *destroy)(_malloc_zone_t *);
  void *(__cdecl *malloc)(_malloc_zone_t *, size_t);

  if (a1)
  {
    if (zone)
      goto LABEL_12;
  }
  else
  {
    a1 = (malloc_zone_t *)_CFGetTSD(1u);
    if (!a1)
      a1 = (malloc_zone_t *)&__kCFAllocatorSystemDefault;
    if (zone)
      goto LABEL_12;
  }
  if (a3 >= 1)
  {
    if (a1->reserved1 != (void *)qword_1ECCFACA8)
      return malloc_type_zone_malloc(a1, a3, type_id);
    realloc = (uint64_t (*)(malloc_zone_t *, uint64_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))a1[1].realloc;
    if (!realloc)
    {
      malloc = a1[1].malloc;
      if (malloc)
        return (void *)((uint64_t (*)(uint64_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))malloc)(a3, a5, a1->try_free_default);
      return 0;
    }
    try_free_default = a1->try_free_default;
    v11 = (malloc_zone_t *)a3;
    v12 = type_id;
    return (void *)realloc(v11, v12, a5, try_free_default);
  }
LABEL_12:
  if (zone && !a3)
  {
    if (a1->reserved1 == (void *)qword_1ECCFACA8)
    {
      valloc = a1[1].valloc;
      if (valloc)
        ((void (*)(malloc_zone_t *, void (__cdecl *)(_malloc_zone_t *, void *)))valloc)(zone, a1->try_free_default);
    }
    else
    {
      malloc_zone_free(a1, zone);
    }
    return 0;
  }
  if (zone || a3)
  {
    if (a1->reserved1 != (void *)qword_1ECCFACA8)
      return malloc_type_zone_realloc(a1, zone, a3, type_id);
    destroy = a1[1].destroy;
    if (destroy)
      return (void *)((uint64_t (*)(malloc_zone_t *, uint64_t, malloc_type_id_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))destroy)(zone, a3, type_id, a5, a1->try_free_default);
    realloc = (uint64_t (*)(malloc_zone_t *, uint64_t, uint64_t, void (__cdecl *)(_malloc_zone_t *, void *)))a1[1].calloc;
    if (realloc)
    {
      try_free_default = a1->try_free_default;
      v11 = zone;
      v12 = a3;
      return (void *)realloc(v11, v12, a5, try_free_default);
    }
  }
  return 0;
}

void *CFAllocatorAllocateBytes(malloc_zone_t *a1, size_t a2, uint64_t a3)
{
  return _CFAllocatorAllocateImpl(a1, a2, 0x100000000000000uLL, a3);
}

void *CFAllocatorReallocateBytes(malloc_zone_t *a1, malloc_zone_t *a2, uint64_t a3, uint64_t a4)
{
  return CFAllocatorReallocateImpl(a1, a2, a3, 0x100000000000000uLL, a4);
}

CFIndex CFAllocatorGetPreferredSizeForSize(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  uint64_t v5;
  uint64_t (*v6)(CFIndex, CFOptionFlags, _QWORD);

  if (!allocator)
  {
    allocator = (CFAllocatorRef)_CFGetTSD(1u);
    if (!allocator)
      allocator = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
  }
  if (*(_QWORD *)allocator != qword_1ECCFACA8)
    return malloc_good_size(size);
  v5 = 0;
  if (size >= 1)
  {
    v6 = (uint64_t (*)(CFIndex, CFOptionFlags, _QWORD))*((_QWORD *)allocator + 25);
    if (v6)
      v5 = v6(size, hint, *((_QWORD *)allocator + 18));
  }
  if (v5 <= size)
    return size;
  else
    return v5;
}

uint64_t _CFGetOutOfMemoryErrorCallBack()
{
  return 0;
}

void *__CFSafelyReallocateImpl(void *a1, size_t a2, malloc_type_id_t a3, uint64_t a4)
{
  void *v7;

  v7 = malloc_type_realloc(a1, a2, a3);
  if (!v7)
    __CFReallocationFailed((uint64_t)a1, a2, a4);
  return v7;
}

void *__CFSafelyReallocateWithAllocatorImpl(malloc_zone_t *a1, malloc_zone_t *a2, uint64_t a3, uint64_t a4, malloc_type_id_t type_id, uint64_t a6)
{
  void *result;

  result = CFAllocatorReallocateImpl(a1, a2, a3, type_id, a4);
  if (!result && (a2 || a3))
  {
    __CFReallocationFailed((uint64_t)a2, a3, a6);
    return 0;
  }
  return result;
}

CFTypeRef __CFNullCopyFormattingDescription()
{
  return CFRetain(CFSTR("null"));
}

CFStringRef __CFNullCopyDescription(const void *a1)
{
  CFAllocatorRef v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFNull %p [%p]>"), a1, v2);
}

uint64_t __CFAllocatorCustomSize()
{
  return 0;
}

void *__CFAllocatorCustomMalloc(malloc_zone_t *a1, size_t a2)
{
  return _CFAllocatorAllocateImpl(a1, a2, 0x28C574BCuLL, 0);
}

void *__CFAllocatorCustomCalloc(malloc_zone_t *a1, int a2, size_t size)
{
  void *Impl;
  void *v5;

  Impl = _CFAllocatorAllocateImpl(a1, size, 0xC7E02CA8uLL, 0);
  v5 = Impl;
  if (Impl)
    bzero(Impl, size);
  return v5;
}

unint64_t __CFAllocatorCustomValloc(malloc_zone_t *a1, unint64_t a2)
{
  _QWORD *v2;

  v2 = (_QWORD *)MEMORY[0x1E0C85AD8];
  if (~(2 * *MEMORY[0x1E0C85AD8]) <= a2)
    return 0;
  else
    return ((unint64_t)_CFAllocatorAllocateImpl(a1, *MEMORY[0x1E0C85AD8] + a2, 0x19AD8B8CuLL, 0) + *v2 - 1) & -*v2;
}

void *__CFAllocatorCustomRealloc(malloc_zone_t *a1, malloc_zone_t *a2, uint64_t a3)
{
  return CFAllocatorReallocateImpl(a1, a2, a3, 0xE716AB6EuLL, 0);
}

void *__CFAllocatorSystemAllocateTyped(size_t size, malloc_type_id_t type_id, uint64_t a3, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder)
    zone = malloc_default_zone();
  if (a3 == 1)
    return malloc_type_zone_calloc(zone, 1uLL, size, type_id);
  else
    return malloc_type_zone_malloc(zone, size, type_id);
}

void *__CFAllocatorSystemReallocateTyped(void *ptr, size_t size, malloc_type_id_t type_id, int a4, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder)
    zone = malloc_default_zone();
  return malloc_type_zone_realloc(zone, ptr, size, type_id);
}

uint64_t __CFAllocatorZoneIntrospectNoOp()
{
  return 0;
}

CFIndex __CFAllocatorCustomGoodSize(const __CFAllocator *a1, CFIndex a2)
{
  return CFAllocatorGetPreferredSizeForSize(a1, a2, 0);
}

uint64_t __CFAllocatorZoneIntrospectTrue()
{
  return 1;
}

uint64_t __CFAllocatorNullSize()
{
  return 0;
}

uint64_t __CFAllocatorNullMalloc()
{
  return 0;
}

uint64_t __CFAllocatorNullCalloc()
{
  return 0;
}

uint64_t __CFAllocatorNullValloc()
{
  return 0;
}

uint64_t __CFAllocatorNullRealloc()
{
  return 0;
}

uint64_t __CFAllocatorNullAllocate()
{
  return 0;
}

uint64_t __CFAllocatorNullReallocate()
{
  return 0;
}

uint64_t __CFAllocatorNullGoodSize(uint64_t a1, uint64_t a2)
{
  return a2;
}

double __os_log_helper_1_2_3_8_32_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result;

  *(_QWORD *)&result = 136315650;
  *(_DWORD *)a1 = 136315650;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2048;
  *(_QWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(_QWORD *)(a1 + 24) = a4;
  return result;
}

double __os_log_helper_1_2_4_8_32_8_0_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result;

  *(_QWORD *)&result = 136315906;
  *(_DWORD *)a1 = 136315906;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2048;
  *(_QWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(_QWORD *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 32) = 2048;
  *(_QWORD *)(a1 + 34) = a5;
  return result;
}

void sub_182BA3D10(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BA4174(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BA4A7C(_Unwind_Exception *a1)
{
  void **v1;

  free(*v1);
  _Unwind_Resume(a1);
}

void sub_182BA4E6C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void OUTLINED_FUNCTION_0(objc_class *a1, uint64_t a2)
{
  __CFRequireConcreteImplementation(a1, a2);
}

uint64_t (**__CFStringEncodingGetArabicConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter)
  {
    __CFStringEncodingPrecomposeLatinCharacter = (_UNKNOWN *)a2(4);
    __CFStringEncodingIsValidCombiningCharacterForLatin1 = (_UNKNOWN *)a2(3);
  }
  if (a1 > 517)
  {
    if (a1 != 518)
    {
      if (a1 == 1286)
        return __CFConverterWindowsArabic;
      return 0;
    }
    return __CFConverterISOLatinArabic;
  }
  else
  {
    if (a1 != 4)
    {
      if (a1 == 140)
        return __CFConverterMacFarsi;
      return 0;
    }
    return __CFConverterMacArabic;
  }
}

uint64_t __CFToMacArabic(uint64_t IsValidCombiningCharacterForLatin1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  char v11;
  uint64_t v12;
  unsigned int v13;
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  uint64_t v16;
  unsigned __int16 *v17;
  unsigned int v18;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  if (a3 < 1)
  {
    v12 = 0;
    goto LABEL_25;
  }
  v11 = IsValidCombiningCharacterForLatin1;
  v12 = 0;
  while (1)
  {
    if (a5 < 0)
    {
      if ((v11 & 0x10) == 0)
        goto LABEL_25;
      IsValidCombiningCharacterForLatin1 = *(unsigned __int16 *)(a2 + 2 * v12);
      if ((IsValidCombiningCharacterForLatin1 - 1619) >= 3)
      {
        IsValidCombiningCharacterForLatin1 = __CFStringEncodingIsValidCombiningCharacterForLatin1();
        if (!(_DWORD)IsValidCombiningCharacterForLatin1)
          goto LABEL_25;
      }
    }
    v13 = *(unsigned __int16 *)(a2 + 2 * v12);
    if (v13 <= 0x7F)
    {
      v20 = *(_WORD *)(a2 + 2 * v12);
      if (!a5)
        goto LABEL_20;
LABEL_19:
      *(_BYTE *)(a4 + v12) = v20;
      goto LABEL_20;
    }
    if ((unsigned __int16)(v13 - 10059) < 0xD955u)
      break;
    v14 = (unsigned __int16 *)&unk_182C4A1CC;
    v15 = (unsigned __int16 *)&macarabic_from_uni;
    while (1)
    {
      v16 = ((char *)v14 - (char *)v15) >> 3;
      v17 = &v15[2 * v16];
      v18 = *v17;
      if (v18 <= v13)
        break;
      v14 = v17 - 2;
LABEL_16:
      if (v15 > v14)
        goto LABEL_17;
    }
    if (v18 < v13)
    {
      v15 = v17 + 2;
      goto LABEL_16;
    }
    v20 = v15[2 * v16 + 1];
    if (a5)
      goto LABEL_19;
LABEL_20:
    if (++v12 == a3)
    {
      v12 = a3;
      goto LABEL_25;
    }
  }
LABEL_17:
  IsValidCombiningCharacterForLatin1 = __CFToISOArabic(IsValidCombiningCharacterForLatin1, v13, &v20);
  if ((_DWORD)IsValidCombiningCharacterForLatin1)
  {
    if (!a5)
      goto LABEL_20;
    goto LABEL_19;
  }
LABEL_25:
  *a6 = 0;
  return v12;
}

uint64_t __CFFromMacArabic(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t result;
  uint64_t v8;
  int v9;
  int v10;

  if (a5 >= a3 || a5 == 0)
    result = a3;
  else
    result = a5;
  if (result >= 1)
  {
    v8 = result;
    while (1)
    {
      v9 = *a2++;
      v10 = v9;
      if (v9 < 0)
        break;
      if (a5)
        goto LABEL_11;
LABEL_12:
      ++a4;
      if (!--v8)
        goto LABEL_17;
    }
    LOWORD(v10) = macarabic_to_uni[v10 - 128];
    if (!a5)
      goto LABEL_12;
LABEL_11:
    *a4 = v10;
    goto LABEL_12;
  }
  result = 0;
LABEL_17:
  *a6 = result;
  return result;
}

uint64_t __CFIsValidCombiningCharacterForArabic(int a1)
{
  if ((a1 - 1619) >= 3)
    return __CFStringEncodingIsValidCombiningCharacterForLatin1();
  else
    return 1;
}

uint64_t __CFToISOArabic(uint64_t a1, int a2, _BYTE *a3)
{
  uint64_t result;

  if (a2 < 0xA1)
    goto LABEL_2;
  if ((a2 - 1569) <= 0x31)
  {
    if ((a2 - 59) < 5u)
      return 0;
    LOBYTE(a2) = a2 - 96;
    goto LABEL_2;
  }
  result = 0;
  if (a2 <= 1547)
  {
    if (a2 == 164 || a2 == 173)
      goto LABEL_2;
  }
  else
  {
    switch(a2)
    {
      case 1548:
        LOBYTE(a2) = -84;
        goto LABEL_2;
      case 1563:
        LOBYTE(a2) = -69;
        goto LABEL_2;
      case 1567:
        LOBYTE(a2) = -65;
LABEL_2:
        *a3 = a2;
        return 1;
    }
  }
  return result;
}

uint64_t __CFToMacFarsi(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v8;
  uint64_t v12;
  unsigned int v13;
  char v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  uint64_t v17;
  unsigned __int16 *v18;
  unsigned int v19;
  char v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (a5 >= a3 || a5 == 0)
    v8 = a3;
  else
    v8 = a5;
  if (v8 < 1)
  {
    v12 = 0;
    goto LABEL_28;
  }
  v12 = 0;
  v21 = 0;
  while (1)
  {
    v13 = *(unsigned __int16 *)(a2 + 2 * v12);
    if (v13 <= 0x7F)
    {
      v21 = *(_WORD *)(a2 + 2 * v12);
      goto LABEL_22;
    }
    if (v13 - 1776 <= 9)
    {
      v14 = v13 - 64;
      goto LABEL_13;
    }
    if ((unsigned __int16)(v13 - 10059) < 0xD955u)
      break;
    v15 = (unsigned __int16 *)&unk_182C4A1CC;
    v16 = (unsigned __int16 *)&macarabic_from_uni;
    while (1)
    {
      v17 = ((char *)v15 - (char *)v16) >> 3;
      v18 = &v16[2 * v17];
      v19 = *v18;
      if (v19 <= v13)
        break;
      v15 = v18 - 2;
LABEL_20:
      if (v16 > v15)
        goto LABEL_21;
    }
    if (v19 < v13)
    {
      v16 = v18 + 2;
      goto LABEL_20;
    }
    v14 = v16[2 * v17 + 1];
LABEL_13:
    v21 = v14;
LABEL_22:
    if (a5)
      *(_BYTE *)(a4 + v12) = v21;
    if (++v12 == v8)
    {
      v12 = v8;
      goto LABEL_28;
    }
  }
LABEL_21:
  a1 = __CFToISOArabic(a1, v13, &v21);
  if ((_DWORD)a1)
    goto LABEL_22;
LABEL_28:
  *a6 = v12;
  return v12;
}

uint64_t __CFFromMacFarsi(uint64_t a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t result;
  uint64_t v8;
  unsigned __int8 v9;
  int v10;
  int v11;

  if (a5 >= a3 || a5 == 0)
    result = a3;
  else
    result = a5;
  if (result >= 1)
  {
    v8 = result;
    while (1)
    {
      v10 = *a2++;
      v9 = v10;
      v11 = v10;
      if (v10 < 0)
      {
        if ((v9 + 80) > 9u)
        {
          LOWORD(v11) = macarabic_to_uni[v11 - 128];
          if (!a5)
            goto LABEL_14;
LABEL_13:
          *a4 = v11;
          goto LABEL_14;
        }
        LOWORD(v11) = v9 + 1600;
      }
      if (a5)
        goto LABEL_13;
LABEL_14:
      ++a4;
      if (!--v8)
        goto LABEL_19;
    }
  }
  result = 0;
LABEL_19:
  *a6 = result;
  return result;
}

uint64_t __CFToWinArabic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8483 < 0xFFFFDF7D)
    return 0;
  v5 = (unsigned __int16 *)&cp1256_from_uni;
  v6 = (unsigned __int16 *)&unk_182C4A4AC;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromWinArabic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = cp1256_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinArabicPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned int v10;
  int v11;
  uint64_t result;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;

  v9 = *a2;
  if (v9 >= 0x80)
  {
    v11 = a2[1];
    if (v11 == 1621)
    {
      if (v9 != 1575)
        return 0;
      v10 = 1573;
    }
    else if (v11 == 1620)
    {
      result = 0;
      if (*a2 > 0x6C0u)
      {
        switch(v9)
        {
          case 0x6C1u:
            v10 = 1730;
            break;
          case 0x6D2u:
            v10 = 1747;
            break;
          case 0x6D5u:
            v10 = 1728;
            break;
          default:
            return result;
        }
      }
      else
      {
        switch(v9)
        {
          case 0x627u:
            v10 = 1571;
            break;
          case 0x648u:
            v10 = 1572;
            break;
          case 0x64Au:
            v10 = 1574;
            break;
          default:
            return result;
        }
      }
    }
    else
    {
      if (v11 != 1619 || v9 != 1575)
        return 0;
      v10 = 1570;
    }
  }
  else
  {
    v10 = __CFStringEncodingPrecomposeLatinCharacter(a2, a3, 0);
    if (v10 <= 0x7F)
      goto LABEL_33;
    if ((unsigned __int16)(v10 - 8483) < 0xDF7Du)
      return 0;
  }
  v13 = (unsigned __int16 *)&cp1256_from_uni;
  v14 = (unsigned __int16 *)&unk_182C4A4AC;
  while (1)
  {
    v15 = ((char *)v14 - (char *)v13) >> 3;
    v16 = &v13[2 * v15];
    v17 = *v16;
    if (v17 <= v10)
      break;
    v14 = v16 - 2;
LABEL_30:
    if (v13 > v14)
      return 0;
  }
  if (v17 < v10)
  {
    v13 = v16 + 2;
    goto LABEL_30;
  }
  LOBYTE(v10) = v13[2 * v15 + 1];
LABEL_33:
  if (!(_BYTE)v10)
    return 0;
  if (a5)
    *a4 = v10;
  *a6 = 1;
  return 2;
}

uint64_t __CFFromISOArabic(uint64_t a1, unsigned int a2, _WORD *a3)
{
  uint64_t result;

  if (a2 < 0xA1)
    goto LABEL_2;
  if (a2 < 0xC1)
  {
    result = 0;
    if ((int)a2 <= 172)
    {
      if (a2 == 164)
        goto LABEL_2;
      if (a2 == 172)
      {
        LOWORD(a2) = 1548;
        goto LABEL_2;
      }
    }
    else
    {
      switch(a2)
      {
        case 0xADu:
          goto LABEL_2;
        case 0xBBu:
          LOWORD(a2) = 1563;
          goto LABEL_2;
        case 0xBFu:
          LOWORD(a2) = 1567;
          goto LABEL_2;
      }
    }
  }
  else
  {
    result = 0;
    if (a2 <= 0xF2 && (a2 + 37) >= 5u)
    {
      LOWORD(a2) = a2 + 1376;
LABEL_2:
      *a3 = a2;
      return 1;
    }
  }
  return result;
}

uint64_t __CFToISOArabicPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  uint64_t result;
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v9 = a2[1];
  if (v9 == 1621)
  {
    if (*a2 == 1575)
    {
      v10 = 1573;
      goto LABEL_18;
    }
LABEL_17:
    v10 = 65533;
    goto LABEL_18;
  }
  if (v9 == 1620)
  {
    v11 = *a2;
    if (v11 > 0x6C0)
    {
      switch(v11)
      {
        case 0x6C1u:
          v10 = 1730;
          goto LABEL_18;
        case 0x6D2u:
          v10 = 1747;
          goto LABEL_18;
        case 0x6D5u:
          v10 = 1728;
          goto LABEL_18;
      }
    }
    else
    {
      switch(v11)
      {
        case 0x627u:
          v10 = 1571;
          goto LABEL_18;
        case 0x648u:
          v10 = 1572;
          goto LABEL_18;
        case 0x64Au:
          v10 = 1574;
          goto LABEL_18;
      }
    }
    goto LABEL_17;
  }
  if (v9 != 1619 || *a2 != 1575)
    goto LABEL_17;
  v10 = 1570;
LABEL_18:
  v14 = 0;
  v12 = __CFToISOArabic(a1, v10, &v14);
  result = 0;
  if (v12 && v14)
  {
    if (a5)
      *a4 = v14;
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t CFUniCharGetBidiCategory(uint64_t result, uint64_t a2, _BYTE *a3)
{
  unsigned __int16 *v4;
  uint64_t v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  unsigned int v8;
  int v10;
  BOOL v11;
  int v12;
  unint64_t v13;

  if (a2 >= 1)
  {
    v4 = (unsigned __int16 *)result;
    result = 0;
    v5 = -1;
    v6 = &v4[a2];
    do
    {
      v7 = v4 + 1;
      v8 = *v4;
      if ((v8 & 0xFC00) != 0xD800 || v7 >= v6)
      {
        ++v4;
      }
      else
      {
        v10 = *v7;
        v11 = (v10 & 0xFC00) == 56320;
        v12 = v10 + (v8 << 10) - 56613888;
        if (v11)
          v4 += 2;
        else
          ++v4;
        if (v11)
          v8 = v12;
      }
      if (v5 != (HIWORD(v8) & 0x1F))
      {
        result = CFUniCharGetUnicodePropertyDataForPlane(1u, HIWORD(v8) & 0x1F);
        v5 = HIWORD(v8) & 0x1F;
      }
      if (result)
      {
        v13 = *(unsigned __int8 *)(result + BYTE1(v8));
        if (v13 >= 0x13)
          LOBYTE(v13) = *(_BYTE *)(result + (((_DWORD)v13 << 8) - 4864) + v8 + 256);
      }
      else
      {
        LOBYTE(v13) = 1;
      }
      *a3 = v13;
      if (v8 < 0x10000)
      {
        ++a3;
      }
      else
      {
        a3[1] = v13;
        a3 += 2;
      }
    }
    while (v4 < v6);
  }
  return result;
}

uint64_t CFUniCharGetFirstBidiParagraphLength(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  if (a2 < 1)
    return 0;
  v2 = 0;
  while (1)
  {
    v3 = *(unsigned __int8 *)(a1 + v2);
    if (v3 == 13)
      break;
    if ((v3 - 11) <= 2)
      *(_BYTE *)(a1 + v2) = 0;
    if (a2 == ++v2)
      return a2;
  }
  a2 = v2 + 1;
  *(_BYTE *)(a1 + v2) = 10;
  return a2;
}

uint64_t CFUniCharApplyUnicodeBidiAlgorithm(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5;
  int v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned __int8 v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  int v25;
  BOOL v26;
  char v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  char v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  int v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  char v40;
  char v41;
  int v42;
  uint64_t v43;
  int v44;
  BOOL v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  char *v51;
  char *v52;
  uint64_t v53;
  char v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  int v58;
  char v59;
  unsigned int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  unsigned int v65;
  int v66;
  int v67;
  char *v68;
  _BYTE *v69;
  uint64_t v70;
  int v71;
  unsigned __int8 v72;
  int v73;
  int v74;
  int v75;
  _BOOL4 v76;
  int v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  uint64_t v81;

  if (a4 < 1)
    return result;
  v5 = a2;
  v6 = result;
  v7 = a2 + a4;
  if ((result & 1) != 0)
    v8 = 1;
  else
    v8 = 2;
  v75 = result & 1;
  v76 = !(result & 1);
  v77 = v8;
  v80 = result;
  v78 = a2 + a4;
  do
  {
    v9 = v7 - v5;
    if (v9 < 1)
    {
      result = resolveExplicit(v6, 0, v5, a3, 0, 0);
      v13 = 0;
      v12 = 0;
      v14 = 0;
      v15 = 0;
      v16 = v75;
      v17 = v77;
      goto LABEL_72;
    }
    v10 = 0;
    while (1)
    {
      v11 = *(unsigned __int8 *)(v5 + v10);
      if (v11 == 13)
        break;
      if ((v11 - 11) <= 2)
        *(_BYTE *)(v5 + v10) = 0;
      if (v9 == ++v10)
      {
        result = resolveExplicit(v6, 0, v5, a3, v9, 0);
        v12 = v9;
        goto LABEL_15;
      }
    }
    v18 = v10 + 1;
    *(_BYTE *)(v5 + v10) = 10;
    result = resolveExplicit(v6, 0, v5, a3, v10 + 1, 0);
    v12 = v18;
LABEL_15:
    v15 = 0;
    v19 = 0;
    v20 = v6;
    v17 = v77;
    do
    {
      v21 = *(_BYTE *)(v5 + v19);
      if ((v21 & 0x7F) == 0xA)
      {
        *(_BYTE *)(a3 + v19) = v6;
        v22 = v19 + 1;
        if (v19 + 1 != v12 || v6 == v80)
        {
          if (v22 >= v12 || (v42 = *(unsigned __int8 *)(a3 + v22), v6 == v42) || *(_BYTE *)(v5 + v22) == 10)
          {
            if (v15)
              ++v15;
            else
              v15 = 0;
            v41 = *(_BYTE *)(v5 + v19) | 0x80;
            goto LABEL_64;
          }
          if (v6 > v42)
            LOBYTE(v42) = v6;
          *(_BYTE *)(a3 + v19) = v42;
          if ((v42 & 1) != 0)
            v21 = 2;
          else
            v21 = 1;
          *(_BYTE *)(v5 + v19) = v21;
          v6 = *(unsigned __int8 *)(a3 + v22);
        }
        else
        {
          if ((v6 & 1) != 0)
            v21 = 2;
          else
            v21 = 1;
          *(_BYTE *)(v5 + v19) = v21;
        }
        v23 = 0x80;
      }
      else
      {
        v23 = 0;
      }
      v24 = (int)v19 - 1;
      v25 = *(unsigned __int8 *)(a3 + v19);
      if (v20 != v25)
      {
        v26 = v21 > 5u || ((1 << v21) & 0x26) == 0;
        if (v26)
        {
          if (v15 >= 1)
          {
            if (v6 <= v25)
              v27 = *(_BYTE *)(a3 + v19);
            else
              v27 = v6;
            v26 = (v27 & 1) == 0;
            v28 = 2;
            if (v26)
              v28 = 1;
            v29 = actionWeak[10 * v17 + v28] >> 4;
            if (v29 != 15)
            {
              v30 = v19 - v15;
              if ((int)v24 < v30)
                v30 = v19 - 1;
              v31 = v12;
              result = (uint64_t)memset((void *)(v5 + v24 - (v24 - v30)), v29, (v24 - v30) + 1);
              v12 = v31;
              v15 = 0;
              v25 = *(unsigned __int8 *)(a3 + v19);
            }
          }
          if (v20 <= v25)
            v32 = v25;
          else
            v32 = v20;
          if ((v32 & 1) != 0)
            v17 = 1;
          else
            v17 = 2;
        }
        v20 = v25;
      }
      v33 = v21;
      v34 = actionWeak[10 * v17 + v21];
      v35 = v34 >> 4;
      if (v35 != 15)
      {
        if (v15 >= 1)
        {
          v36 = v19 - v15;
          if ((int)v24 < v36)
            v36 = v19 - 1;
          v37 = (v24 - v36);
          v38 = (void *)(v5 + v24 - v37);
          v39 = v12;
          result = (uint64_t)memset(v38, v35, v37 + 1);
          v12 = v39;
        }
        v15 = 0;
      }
      v40 = v34 & 0xF;
      if ((v34 & 0xF) == 0xF)
        v40 = *(_BYTE *)(v5 + v19);
      v15 += (v34 >> 8) & 1;
      v17 = stateWeak[10 * v17 + v33];
      v41 = v40 | v23;
      v22 = v19 + 1;
LABEL_64:
      *(_BYTE *)(v5 + v19) = v41;
      v19 = v22;
    }
    while (v22 != v12);
    v16 = v6 & 1;
    v13 = 1;
    v14 = v12;
LABEL_72:
    v26 = v16 == 0;
    v43 = 2;
    if (v26)
      v43 = 1;
    v44 = actionWeak[10 * v17 + v43] >> 4;
    v45 = v44 == 15 || v15 < 1;
    v79 = v12;
    if (!v45)
    {
      v46 = v14 - v15;
      v47 = v14 - 1;
      if (v46 >= v47)
        v46 = v47;
      result = (uint64_t)memset((void *)(v5 - (v47 - v46) + v47), v44, (v47 - v46) + 1);
      v12 = v79;
    }
    if (v13)
    {
      v74 = v13;
      v48 = 0;
      v49 = 0;
      v50 = -1;
      v51 = (char *)v5;
      v52 = (char *)a3;
      v53 = v12;
      v54 = v80;
      v55 = v76;
      v81 = a3;
      do
      {
        v56 = *v51;
        v57 = v56;
        if ((v56 & 0x80) != 0)
        {
          v57 = v56 & 0x7F;
          *v51 = v56 & 0x7F;
        }
        v58 = v50;
        if (v57 == 10)
        {
          if (v49)
            ++v49;
          else
            v49 = 0;
          v59 = 10;
        }
        else
        {
          v60 = actionNeutrals[5 * v55 + v57];
          v61 = v60 >> 4;
          if (v60 >> 4)
          {
            if (v61 == 3)
            {
              if ((v54 & 1) != 0)
                v61 = 2;
              else
                v61 = 1;
            }
            if (v49 >= 1)
            {
              v62 = v48 - v49;
              if (v50 < v62)
                v62 = v50;
              result = (uint64_t)memset((void *)(v5 + v50 - (unint64_t)(v50 - v62)), v61, (v50 - v62) + 1);
              v12 = v79;
            }
            v49 = 0;
          }
          v59 = v60 & 0xF;
          if ((v60 & 0xF) != 0)
            *v51 = v59;
          else
            v59 = *v51;
          v49 += (v60 >> 8) & 1;
          v55 = stateNeutrals[5 * v55 + v57];
          v54 = *v52;
          a3 = v81;
        }
        *v51++ = v59 | v56 & 0x80;
        ++v52;
        v50 = v58 + 1;
        ++v48;
        --v53;
      }
      while (v53);
      v63 = v54 & 1;
      v64 = v12;
      v6 = v80;
      v7 = v78;
      v13 = v74;
    }
    else
    {
      v64 = 0;
      v49 = 0;
      v63 = v75;
      v55 = v76;
      v6 = v80;
      v7 = v78;
    }
    if (v63)
      v65 = 2;
    else
      v65 = 1;
    if (actionNeutrals[5 * v55 + v65] >> 4)
    {
      if (actionNeutrals[5 * v55 + v65] >> 4 != 3)
        v65 = actionNeutrals[5 * v55 + v65] >> 4;
      if (v49 >= 1)
      {
        v66 = v64 - v49;
        v67 = v64 - 1;
        if (v66 >= v67)
          v66 = v67;
        result = (uint64_t)memset((void *)(v5 - (v67 - v66) + v67), v65, (v67 - v66) + 1);
        v12 = v79;
      }
    }
    if (v13)
    {
      v68 = (char *)v5;
      v69 = (_BYTE *)a3;
      v70 = v12;
      LOBYTE(v71) = v6;
      do
      {
        v73 = *v68++;
        v72 = v73;
        if ((v73 & 0x80000000) == 0)
          v71 = *v69 + addLevel[4 * (*v69 & 1) - 1 + v72];
        *v69++ = v71;
        --v70;
      }
      while (v70);
    }
    v5 += v12;
    a3 += v12;
  }
  while (v5 < v7);
  return result;
}

uint64_t resolveExplicit(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  char v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v23;

  if (a5 >= 1)
  {
    v6 = a5;
    v10 = a1;
    v11 = 0;
    if ((a1 & 1) != 0)
      v12 = 2;
    else
      v12 = 1;
    v13 = v12 + a1;
    if ((a1 & 1) != 0)
      v14 = 1;
    else
      v14 = 2;
    v15 = v14 + a1;
    v23 = a6;
    v16 = a6;
    while (1)
    {
      v17 = *(unsigned __int8 *)(a3 + v11);
      if ((v17 - 14) < 2)
      {
        v18 = (v16 + 1);
        if (v13 > 0x3D)
        {
LABEL_24:
          LOBYTE(v17) = -118;
          *(_BYTE *)(a3 + v11) = -118;
LABEL_26:
          *(_BYTE *)(a4 + v11) = v10;
          if ((*(_BYTE *)(a3 + v11) & 0x7F) != 0xA)
          {
            if (a2)
              LOBYTE(v17) = a2;
            *(_BYTE *)(a3 + v11) = v17;
          }
          v16 = v18;
          goto LABEL_31;
        }
        *(_BYTE *)(a4 + v11) = v13;
        *(_BYTE *)(a3 + v11) = -118;
        v19 = *(unsigned __int8 *)(a4 + v11);
        v20 = 2 * (v17 != 15);
      }
      else
      {
        if ((v17 - 16) >= 2)
        {
          if (v17 == 18)
          {
            *(_BYTE *)(a3 + v11) = -118;
            if ((int)v16 <= v23)
              v21 = v11;
            else
              v21 = v6;
            if ((_DWORD)v16)
            {
              v6 = v21;
              v18 = v16 - ((int)v16 > v23);
            }
            else
            {
              v18 = 0;
            }
            LOBYTE(v17) = -118;
          }
          else
          {
            v18 = v16;
          }
          goto LABEL_26;
        }
        v18 = (v16 + 1);
        if (v15 > 0x3D)
          goto LABEL_24;
        *(_BYTE *)(a4 + v11) = v15;
        *(_BYTE *)(a3 + v11) = -118;
        v19 = *(unsigned __int8 *)(a4 + v11);
        v20 = v17 != 17;
      }
      v11 += resolveExplicit(v19, v20, a3 + v11 + 1, a4 + v11 + 1, v6 - (v11 + 1), v18);
LABEL_31:
      if (++v11 >= v6)
        return v11;
    }
  }
  return 0;
}

BOOL CFAttributedStringGetBidiLevels(const __CFAttributedString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return CFAttributedStringGetBidiLevelsAndResolvedDirections(a1, a2, a3, a4, a5, 0, a7, a8);
}

uint64_t CFUniCharGetDefaultWritingDirection()
{
  const __CFDictionary *v0;
  uint64_t v1;
  const __CFDictionary *v2;
  __CFBundle *MainBundle;
  const __CFArray *v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const __CFString *ValueAtIndex;

  v0 = __CFXPreferencesCopyCurrentApplicationState();
  v1 = CFUniCharGetDefaultWritingDirection_defaultDirection;
  if (CFUniCharGetDefaultWritingDirection_defaultDirection == 255)
  {
    v2 = v0;
    if ((__CFUniCharGetBooleanValueForKey(CFSTR("NSForceRightToLeftWritingDirection"), v0) & 1) != 0)
    {
      v1 = 1;
    }
    else
    {
      MainBundle = CFBundleGetMainBundle();
      if (MainBundle && (v4 = CFBundleCopyBundleLocalizations(MainBundle)) != 0)
      {
        v5 = v4;
        v6 = CFBundleCopyLocalizationsForPreferences(v4, 0);
        v1 = (uint64_t)v6;
        if (v6)
        {
          if (CFArrayGetCount(v6) >= 1
            && (ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v1, 0),
                CFLocaleGetLanguageCharacterDirection(ValueAtIndex) == kCFLocaleLanguageDirectionRightToLeft))
          {
            CFRelease((CFTypeRef)v1);
            v1 = __CFUniCharGetBooleanValueForKey(CFSTR("NSForceLeftToRightWritingDirection"), v2) ^ 1;
          }
          else
          {
            CFRelease((CFTypeRef)v1);
            v1 = 0;
          }
        }
        CFRelease(v5);
      }
      else
      {
        v1 = 0;
      }
    }
    CFUniCharGetDefaultWritingDirection_defaultDirection = v1;
    if (v2)
    {
      CFRelease(v2);
      return CFUniCharGetDefaultWritingDirection_defaultDirection;
    }
  }
  return v1;
}

uint64_t __CFUniCharGetBooleanValueForKey(CFStringRef key, CFDictionaryRef theDict)
{
  const __CFString *Value;
  const __CFString *v4;
  int v5;
  const __CFString *v6;
  CFTypeID v7;
  BOOL v8;
  uint64_t v9;
  CFIndex Length;
  CFIndex v12;
  int CharacterAtIndex;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  if (theDict && (Value = (const __CFString *)CFDictionaryGetValue(theDict, key)) != 0)
  {
    v4 = Value;
    v5 = 0;
  }
  else
  {
    v6 = (const __CFString *)CFPreferencesCopyAppValue(key, CFSTR("kCFPreferencesCurrentApplication"));
    if (!v6)
      return 0;
    v4 = v6;
    v5 = 1;
  }
  v7 = CFGetTypeID(v4);
  if (v7 == CFBooleanGetTypeID())
  {
    v8 = CFBooleanGetValue((CFBooleanRef)v4) == 0;
  }
  else
  {
    if (v7 != CFNumberGetTypeID())
    {
      if (v7 == CFStringGetTypeID() && (Length = CFStringGetLength(v4), Length >= 1))
      {
        v12 = Length;
        CharacterAtIndex = CFStringGetCharacterAtIndex(v4, 0);
        if ((CharacterAtIndex & 0xFFFFFFDF) == 0x59
          || (v9 = 0, v12 == 1) && (CharacterAtIndex - 49) <= 8)
        {
          v9 = 1;
        }
      }
      else
      {
        v9 = 0;
      }
      goto LABEL_15;
    }
    v14[0] = 0;
    if (CFNumberGetValue((CFNumberRef)v4, kCFNumberCFIndexType, v14))
      v8 = v14[0] == 0;
    else
      v8 = 1;
  }
  v9 = !v8;
LABEL_15:
  if (v5)
    CFRelease(v4);
  return v9;
}

void __CFRelativeDateTimeFormatterDeallocate(uint64_t a1)
{
  const void *v1;

  if (!a1)
    __CFRelativeDateTimeFormatterDeallocate_cold_1();
  v1 = *(const void **)(a1 + 32);
  if (v1)
    CFRelease(v1);
}

CFStringRef __CFRelativeDateTimeFormatterCopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  CFAllocatorRef v3;

  if (!a1)
    __CFRelativeDateTimeFormatterCopyDescription_cold_1();
  v2 = CFGetAllocator(a1);
  v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFRelativeDateTimeFormatter %p>[%p]"), a1, v3);
}

uint64_t _CFRelativeDateTimeFormatterGetTypeID()
{
  return 67;
}

_QWORD *_CFRelativeDateTimeFormatterCreate(__objc2_class **a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _QWORD *Instance;

  if (!a1)
  {
    a1 = (__objc2_class **)_CFGetTSD(1u);
    if (!a1)
      a1 = &__kCFAllocatorSystemDefault;
  }
  Instance = (_QWORD *)_CFRuntimeCreateInstance(a1, 0x43uLL, 32, 0);
  if (Instance)
  {
    Instance[4] = CFRetain(a2);
    Instance[5] = a5;
    Instance[2] = a4;
    Instance[3] = a3;
  }
  return Instance;
}

CFStringRef _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit(const __CFAllocator *a1, uint64_t a2, uint64_t a3, double a4)
{
  const __CFString *Identifier;
  void *CStringPtr;
  uint64_t v10;
  unsigned int v11;
  const void *v12;
  unint64_t v13;
  const void *v14;
  const void *v15;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  UniChar v23[138];
  int v24;
  char buffer[157];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a2 + 32));
  CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
  if (!CStringPtr)
  {
    CStringPtr = buffer;
    if (!CFStringGetCString(Identifier, buffer, 157, 0x600u))
      return 0;
  }
  v10 = 0;
  v11 = 0;
  switch(*(_QWORD *)(a2 + 24))
  {
    case 0:
      goto LABEL_10;
    case 1:
      v24 = 0;
      v12 = (const void *)__cficu_unum_open(5u, 0, 0, (uint64_t)CStringPtr, 0, &v24);
      v10 = (uint64_t)v12;
      if (v24 >= 1)
      {
        if (v12)
          __cficu_unum_close(v12);
        return 0;
      }
      v11 = 0;
LABEL_10:
      v24 = 0;
      v13 = *(_QWORD *)(a2 + 40);
      if (v13 >= 6)
        _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_4();
      v14 = (const void *)__cficu_ureldatefmt_open((uint64_t)CStringPtr, v10, v11, dword_182C86D24[v13], &v24);
      v15 = v14;
      if (v24 >= 1)
      {
        if (v14)
          __cficu_ureldatefmt_close(v14);
        return 0;
      }
      if (a3 <= 31)
      {
        switch(a3)
        {
          case 4:
            v17 = 0;
            goto LABEL_31;
          case 8:
            v17 = 2;
            goto LABEL_31;
          case 16:
            v17 = 4;
            goto LABEL_31;
        }
LABEL_45:
        _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_2();
      }
      if (a3 > 127)
      {
        if (a3 == 128)
        {
          v17 = 7;
          goto LABEL_31;
        }
        if (a3 == 4096)
        {
          v17 = 3;
          goto LABEL_31;
        }
        goto LABEL_45;
      }
      if (a3 == 32)
      {
        v17 = 5;
        goto LABEL_31;
      }
      if (a3 != 64)
        goto LABEL_45;
      v17 = 6;
LABEL_31:
      MEMORY[0x1E0C80A78](v14, v17);
      v24 = 0;
      v19 = *(_QWORD *)(a2 + 16);
      if (v19 == 1)
      {
        v20 = __cficu_ureldatefmt_format((uint64_t)v15, v18, v23, 128, &v24, a4);
      }
      else
      {
        if (v19)
          _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_3();
        v20 = __cficu_ureldatefmt_formatNumeric((uint64_t)v15, v18, v23, 128, &v24, a4);
      }
      v21 = v20;
      __cficu_ureldatefmt_close(v15);
      if (v24 > 0)
        return 0;
      if (!a1)
      {
        v22 = _CFGetTSD(1u);
        if (v22)
          a1 = (const __CFAllocator *)v22;
        else
          a1 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
      }
      return CFStringCreateWithCharacters(a1, v23, v21);
    case 2:
      v10 = 0;
      v11 = 1;
      goto LABEL_10;
    case 3:
      v10 = 0;
      v11 = 2;
      goto LABEL_10;
    default:
      _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_1();
  }
}

uint64_t (**__CFStringEncodingGetVietnameseConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_0)
    __CFStringEncodingPrecomposeLatinCharacter_0 = (_UNKNOWN *)a2(4);
  if (a1 == 1288)
    return __CFConverterWindowsVietnamese;
  else
    return 0;
}

uint64_t __CFToWindowsVietnamese(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8483 < 0xFFFFDF7D)
    return 0;
  v5 = (unsigned __int16 *)&WindowsVietnamese_from_uni;
  v6 = (unsigned __int16 *)&unk_182C87088;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromWindowsVietnamese(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = WindowsVietnamese_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWindowsVietnamesePrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_0(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8483) >= 0xDF7Du)
    {
      v11 = (unsigned __int16 *)&WindowsVietnamese_from_uni;
      v12 = (unsigned __int16 *)&unk_182C87088;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

uint64_t __CFIsValidCombiningCharacterForVietnamese(int a1)
{
  if ((a1 - 768) > 0x5F)
    return 0;
  else
    return (__CFVietnameseCombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
}

void __CFBinaryHeapDeallocate(uint64_t a1)
{
  const __CFAllocator *v2;
  char v3;

  v2 = CFGetAllocator((CFTypeRef)a1);
  CFBinaryHeapRemoveAllValues((CFBinaryHeapRef)a1);
  v3 = atomic_load((unint64_t *)(a1 + 8));
  if ((v3 & 0xC) == 4)
    CFAllocatorDeallocate(v2, *(void **)(a1 + 112));
}

#error "182BA8788: call analysis failed (funcsize=109)"

uint64_t __CFBinaryHeapHash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

__CFString *__CFBinaryHeapCopyDescription(_QWORD *a1)
{
  uint64_t v2;
  const __CFAllocator *v3;
  __CFString *Mutable;
  CFAllocatorRef v5;
  void **Typed;
  _BOOL4 v7;
  uint64_t i;
  void *v9;
  uint64_t (*v10)(void *);
  uint64_t v11;
  const void *v12;
  const __CFAllocator *v13;
  void *values[2];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  *(_OWORD *)values = 0u;
  v16 = 0u;
  v2 = a1[2];
  v3 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v3, 0);
  v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFBinaryHeap %p [%p]>{count = %lu, capacity = %lu, objects = (\n"), a1, v5, v2, a1[3], 0, 0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0, (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0,
    (unsigned __int128)0);
  if (v2 >= 129)
  {
    Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v2, 0x80040B8603338, 0);
    v7 = Typed != values;
    if (__CFOASafe && Typed != values)
    {
      __CFSetLastAllocationEventName();
      v7 = 1;
    }
    CFBinaryHeapGetValues((CFBinaryHeapRef)a1, (const void **)Typed);
  }
  else
  {
    Typed = values;
    CFBinaryHeapGetValues((CFBinaryHeapRef)a1, (const void **)values);
    if (v2 <= 0)
    {
      CFStringAppend(Mutable, CFSTR(")}"));
      return Mutable;
    }
    v7 = 0;
  }
  for (i = 0; i != v2; ++i)
  {
    v9 = Typed[i];
    v10 = (uint64_t (*)(void *))a1[7];
    if (v10 && (v11 = v10(Typed[i])) != 0)
    {
      v12 = (const void *)v11;
      CFStringAppendFormat(Mutable, 0, CFSTR("\t%lu : %@\n"), i, v11);
      CFRelease(v12);
    }
    else
    {
      CFStringAppendFormat(Mutable, 0, CFSTR("\t%lu : <%p>\n"), i, v9);
    }
  }
  CFStringAppend(Mutable, CFSTR(")}"));
  if (v7)
  {
    v13 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v13, Typed);
  }
  return Mutable;
}

CFTypeID CFBinaryHeapGetTypeID(void)
{
  return 23;
}

CFBinaryHeapRef CFBinaryHeapCreateCopy(CFAllocatorRef allocator, CFIndex capacity, CFBinaryHeapRef heap)
{
  return (CFBinaryHeapRef)__CFBinaryHeapCreateInit((__objc2_class **)allocator, *((const void ***)heap + 14), *((_QWORD *)heap + 2), (uint64_t)heap + 32, (__int128 *)((char *)heap + 72));
}

CFIndex CFBinaryHeapGetCountOfValue(CFBinaryHeapRef heap, const void *value)
{
  uint64_t v2;
  CFIndex v5;
  uint64_t v6;
  uint64_t (*v7)(const void *);

  v2 = *((_QWORD *)heap + 2);
  if (v2 < 1)
    return 0;
  v5 = 0;
  v6 = 0;
  v7 = (uint64_t (*)(const void *))*((_QWORD *)heap + 8);
  do
  {
    if (*(const void **)(*((_QWORD *)heap + 14) + 8 * v6) == value || v7 && !v7(value))
      ++v5;
    ++v6;
  }
  while (v2 != v6);
  return v5;
}

Boolean CFBinaryHeapContainsValue(CFBinaryHeapRef heap, const void *value)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t (*v6)(const void *);

  v2 = *((_QWORD *)heap + 2);
  if (v2 < 1)
    return 0;
  v5 = 0;
  v6 = (uint64_t (*)(const void *))*((_QWORD *)heap + 8);
  while (*(const void **)(*((_QWORD *)heap + 14) + 8 * v5) != value && (!v6 || v6(value)))
  {
    if (v2 == ++v5)
      return 0;
  }
  return 1;
}

const void *__cdecl CFBinaryHeapGetMinimum(CFBinaryHeapRef heap)
{
  if (*((uint64_t *)heap + 2) < 1)
    return 0;
  else
    return (const void *)**((_QWORD **)heap + 14);
}

Boolean CFBinaryHeapGetMinimumIfPresent(CFBinaryHeapRef heap, const void **value)
{
  if (!*((_QWORD *)heap + 2))
    return 0;
  if (value)
    *value = (const void *)**((_QWORD **)heap + 14);
  return 1;
}

void CFBinaryHeapGetValues(CFBinaryHeapRef heap, const void **values)
{
  __objc2_class **v4;
  uint64_t Init;
  const void *v6;

  if (*((_QWORD *)heap + 2))
  {
    v4 = (__objc2_class **)CFGetAllocator(heap);
    Init = __CFBinaryHeapCreateInit(v4, *((const void ***)heap + 14), *((_QWORD *)heap + 2), (uint64_t)heap + 32, (__int128 *)((char *)heap + 72));
    if (*(uint64_t *)(Init + 16) >= 1)
    {
      do
      {
        v6 = **(const void ***)(Init + 112);
        CFBinaryHeapRemoveMinimumValue((CFBinaryHeapRef)Init);
        *values++ = v6;
      }
      while (*(uint64_t *)(Init + 16) > 0);
    }
    CFRelease((CFTypeRef)Init);
  }
}

void CFBinaryHeapRemoveMinimumValue(CFBinaryHeapRef heap)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t (*v4)(unint64_t, unint64_t, _QWORD);
  CFAllocatorRef v5;
  void (*v6)(CFAllocatorRef, _QWORD);
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;

  v1 = *((_QWORD *)heap + 2);
  if (!v1)
    return;
  v3 = v1 - 1;
  *((_QWORD *)heap + 2) = v1 - 1;
  v4 = (uint64_t (*)(unint64_t, unint64_t, _QWORD))*((_QWORD *)heap + 8);
  v5 = CFGetAllocator(heap);
  v6 = (void (*)(CFAllocatorRef, _QWORD))*((_QWORD *)heap + 6);
  if (v6)
    v6(v5, **((_QWORD **)heap + 14));
  v7 = *((_QWORD *)heap + 14);
  v8 = *(_QWORD *)(v7 + 8 * v3);
  v9 = *((_QWORD *)heap + 2);
  if (v9 < 2)
  {
    v10 = 0;
    goto LABEL_24;
  }
  v10 = 0;
  v11 = 1;
  while (1)
  {
    v12 = v10;
    v7 = *((_QWORD *)heap + 14);
    v13 = *(_QWORD *)(v7 + 8 * v11);
    v14 = v11 + 1;
    if (v11 + 1 < v9)
      break;
    if (!v4 && v13 > v8)
      goto LABEL_23;
    v10 = v11;
    if (v4)
      goto LABEL_14;
LABEL_20:
    *(_QWORD *)(v7 + 8 * v12) = v13;
    v11 = (2 * v10) | 1;
    if (v11 >= v9)
    {
      v7 = *((_QWORD *)heap + 14);
      goto LABEL_24;
    }
  }
  v15 = *(_QWORD *)(v7 + 8 * v14);
  if (v4)
  {
    if (v4(*(_QWORD *)(v7 + 8 * v11), *(_QWORD *)(v7 + 8 * v14), *((_QWORD *)heap + 10)) == 1)
    {
      ++v11;
      v13 = v15;
    }
LABEL_14:
    v16 = v4(v13, v8, *((_QWORD *)heap + 10));
    v7 = *((_QWORD *)heap + 14);
    if (v16 == 1)
      goto LABEL_23;
    v9 = *((_QWORD *)heap + 2);
    v10 = v11;
    goto LABEL_20;
  }
  if (v13 <= v15)
  {
    v10 = v11;
  }
  else
  {
    v13 = *(_QWORD *)(v7 + 8 * v14);
    v10 = v11 + 1;
  }
  if (v13 <= v8)
    goto LABEL_20;
LABEL_23:
  v10 = v12;
LABEL_24:
  *(_QWORD *)(v7 + 8 * v10) = v8;
}

void CFBinaryHeapApplyFunction(CFBinaryHeapRef heap, CFBinaryHeapApplierFunction applier, void *context)
{
  __objc2_class **v6;
  uint64_t Init;
  uint64_t v8;

  if (*((_QWORD *)heap + 2))
  {
    v6 = (__objc2_class **)CFGetAllocator(heap);
    Init = __CFBinaryHeapCreateInit(v6, *((const void ***)heap + 14), *((_QWORD *)heap + 2), (uint64_t)heap + 32, (__int128 *)((char *)heap + 72));
    if (*(uint64_t *)(Init + 16) >= 1)
    {
      do
      {
        v8 = **(_QWORD **)(Init + 112);
        CFBinaryHeapRemoveMinimumValue((CFBinaryHeapRef)Init);
        ((void (*)(uint64_t, void *))applier)(v8, context);
      }
      while (*(uint64_t *)(Init + 16) > 0);
    }
    CFRelease((CFTypeRef)Init);
  }
}

void CFBinaryHeapAddValue(CFBinaryHeapRef heap, const void *value)
{
  CFAllocatorRef v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  CFAllocatorRef v8;
  uint64_t v9;
  uint64_t (*v10)(_QWORD, const void *, _QWORD);
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint64_t (*v15)(CFAllocatorRef, const void *);

  v4 = CFGetAllocator(heap);
  v5 = atomic_load((unint64_t *)heap + 1);
  if ((v5 & 0xC) == 4)
  {
    v6 = *((_QWORD *)heap + 2);
    if (v6 == *((_QWORD *)heap + 3))
    {
      v7 = v6 >= 3 ? 1 << flsl(v6 + 1) : 4;
      v8 = CFGetAllocator(heap);
      *((_QWORD *)heap + 3) = v7;
      *((_QWORD *)heap + 14) = __CFSafelyReallocateWithAllocatorTyped(v8, *((_QWORD *)heap + 14), 8 * v7, 0x80040B8603338, 0, 0);
      if (__CFOASafe)
        __CFSetLastAllocationEventName();
    }
  }
  v9 = *((_QWORD *)heap + 2);
  *((_QWORD *)heap + 2) = v9 + 1;
  if (v9 >= 1)
  {
    v10 = (uint64_t (*)(_QWORD, const void *, _QWORD))*((_QWORD *)heap + 8);
    while (1)
    {
      v11 = (v9 - 1) >> 1;
      v12 = *((_QWORD *)heap + 14);
      v13 = *(_QWORD *)(v12 + 8 * v11);
      if (!v10 && v13 <= (unint64_t)value)
        break;
      if (v10)
      {
        if (v10(*(_QWORD *)(v12 + 8 * v11), value, *((_QWORD *)heap + 10)) != 1)
          break;
        v12 = *((_QWORD *)heap + 14);
      }
      *(_QWORD *)(v12 + 8 * v9) = v13;
      v14 = v9 <= 2;
      v9 = (v9 - 1) >> 1;
      if (v14)
        goto LABEL_19;
    }
  }
  v11 = v9;
LABEL_19:
  v15 = (uint64_t (*)(CFAllocatorRef, const void *))*((_QWORD *)heap + 5);
  if (v15)
    value = (const void *)v15(v4, value);
  *(_QWORD *)(*((_QWORD *)heap + 14) + 8 * v11) = value;
}

void CFBinaryHeapRemoveAllValues(CFBinaryHeapRef heap)
{
  uint64_t v2;
  BOOL v3;
  uint64_t v4;
  void (*v5)(CFAllocatorRef, _QWORD);
  CFAllocatorRef v6;

  v2 = *((_QWORD *)heap + 2);
  if (*((_QWORD *)heap + 6))
    v3 = v2 < 1;
  else
    v3 = 1;
  if (!v3)
  {
    v4 = 0;
    do
    {
      v5 = (void (*)(CFAllocatorRef, _QWORD))*((_QWORD *)heap + 6);
      v6 = CFGetAllocator(heap);
      v5(v6, *(_QWORD *)(*((_QWORD *)heap + 14) + 8 * v4++));
    }
    while (v2 != v4);
  }
  *((_QWORD *)heap + 2) = 0;
}

CFStringRef __CFKeyedArchiverUIDCopyFormattingDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("@%u@"), *(unsigned int *)(a1 + 16));
}

CFStringRef __CFKeyedArchiverUIDCopyDescription(unsigned int *a1)
{
  CFAllocatorRef v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFKeyedArchiverUID %p [%p]>{value = %u}"), a1, v2, a1[4]);
}

uint64_t __CFBinaryPlistWriteToStream(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, 0);
}

uint64_t __CFBinaryPlistWriteToStreamWithEstimate(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, 0);
}

BOOL __CFBinaryPlistIsArray(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  _BOOL8 result;

  result = 0;
  if (a3 >= 8 && *(_QWORD *)(a4 + 24) - 1 >= a3)
    return (*(_BYTE *)(a1 + a3) & 0xF0) == 160;
  return result;
}

unint64_t __CFBinaryPlistIsDictionary(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  _BYTE *v6;
  char v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned __int8 v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unsigned int v15;
  unint64_t v16;
  BOOL v17;

  v4 = 0;
  if (a3 < 8)
    return v4;
  v5 = *(_QWORD *)(a4 + 24) - 1;
  if (v5 < a3)
    return v4;
  v4 = 0;
  v6 = (_BYTE *)(a1 + a3);
  if (a1 + a3 == -1)
    return v4;
  v7 = *v6;
  if ((*v6 & 0xF0) != 0xD0)
    return v4;
  v8 = v6 + 1;
  v4 = v7 & 0xF;
  if ((v7 & 0xF) == 0xF)
  {
    if (a1 + v5 < (unint64_t)v8)
      return 0;
    v9 = v8 + 1;
    v10 = *v8;
    if ((*v8 & 0xF0) != 0x10)
      return 0;
    v4 = 0;
    v11 = v10 & 0xF;
    v12 = 1 << (v10 & 0xF);
    if (__CFADD__(v12, v9) || (unint64_t)&v8[v12] > a1 + v5)
      return v4;
    switch((char)v12)
    {
      case 1:
        v4 = *v9;
        goto LABEL_23;
      case 2:
        v4 = __rev16(*(unsigned __int16 *)(v8 + 1));
        goto LABEL_23;
      case 4:
        v4 = bswap32(*(_DWORD *)(v8 + 1));
        goto LABEL_23;
      case 8:
        v4 = bswap64(*(_QWORD *)(v8 + 1));
        goto LABEL_22;
      default:
        if (v11 >= 8)
        {
          v4 = 0;
          v8 = &v9[v12];
          goto LABEL_28;
        }
        v4 = 0;
        if ((v12 & 0xFE) != 0)
          v13 = v12;
        else
          v13 = 1;
        v14 = v9;
        do
        {
          v15 = *v14++;
          v4 = v15 | (v4 << 8);
          --v13;
        }
        while (v13);
LABEL_22:
        if ((v4 & 0x8000000000000000) != 0)
          return 0;
LABEL_23:
        v8 = &v9[v12];
        break;
    }
  }
  if (v4)
  {
    v16 = 2 * v4;
    if (!is_mul_ok(v16, *(unsigned __int8 *)(a4 + 7)))
      return 0;
    v4 = v16 * *(unsigned __int8 *)(a4 + 7);
  }
LABEL_28:
  v17 = __CFADD__(v4, v8);
  LODWORD(v4) = a1 + v5 >= (unint64_t)&v8[v4 - 1];
  if (v17)
    return 0;
  else
    return v4;
}

uint64_t __CFBitVectorEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  BOOL v3;
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 == *(_QWORD *)(a2 + 16))
  {
    if (v2)
      v3 = v2 < -7;
    else
      v3 = 1;
    if (v3)
      return 1;
    v4 = v2 / 8;
    v5 = *(unsigned __int8 **)(a1 + 32);
    v6 = *(unsigned __int8 **)(a2 + 32);
    v7 = v4 + 1;
    while (1)
    {
      v9 = *v5++;
      v8 = v9;
      v10 = *v6++;
      if (v8 != v10)
        break;
      if (!--v7)
        return 1;
    }
  }
  return 0;
}

uint64_t __CFBitVectorHash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

__CFString *__CFBitVectorCopyDescription(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  __CFString *Mutable;
  CFAllocatorRef v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int v12;
  BOOL v13;

  v2 = a1[2];
  v3 = a1[4];
  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  v5 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFBitVector %p [%p]>{count = %lu, capacity = %lu, objects = (\n"), a1, v5, v2, a1[3]);
  v6 = 0;
  v7 = v2 + 63;
  if (v2 >= 0)
    v7 = v2;
  if (v2 >= 64)
  {
    v8 = 0;
    v9 = 0;
    v10 = v7 >> 6;
    do
    {
      CFStringAppendFormat(Mutable, 0, CFSTR("\t%lu : "), v9 << 6);
      v11 = 0;
      do
      {
        v12 = *(unsigned __int8 *)(v3 + ((v8 + v11) >> 3));
        CFStringAppendFormat(Mutable, 0, CFSTR("%u%u%u%u"), (v12 >> (v11 & 4 ^ 7)) & 1, (v12 >> (v11 & 4 ^ 6)) & 1, (v12 >> (v11 & 4 ^ 5)) & 1, (v12 >> (v11 & 4 ^ 4)) & 1);
        v13 = v11 >= 0x3C;
        v11 += 4;
      }
      while (!v13);
      CFStringAppend(Mutable, CFSTR("\n"));
      ++v9;
      v8 += 64;
    }
    while (v9 != v10);
    v6 = v10 << 6;
  }
  if (v6 < v2)
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("\t%lu : "), v6);
    do
    {
      CFStringAppendFormat(Mutable, 0, CFSTR("%u"), (*(unsigned __int8 *)(v3 + ((unint64_t)v6 >> 3)) >> (~(_BYTE)v6 & 7)) & 1);
      ++v6;
    }
    while (v2 != v6);
  }
  CFStringAppend(Mutable, CFSTR("\n)}"));
  return Mutable;
}

CFTypeID CFBitVectorGetTypeID(void)
{
  return 24;
}

CFBitVectorRef CFBitVectorCreateCopy(CFAllocatorRef allocator, CFBitVectorRef bv)
{
  return (CFBitVectorRef)__CFBitVectorInit((__objc2_class **)allocator, 0, *((const void **)bv + 4), *((_QWORD *)bv + 2));
}

CFIndex CFBitVectorGetCountOfBit(CFBitVectorRef bv, CFRange range, CFBit value)
{
  uint64_t v4;
  CFIndex v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (!range.length)
    return 0;
  v5 = 0;
  v4 = value;
  __CFBitVectorInternalMap((uint64_t)bv, range.location, range.length, (uint64_t (*)(_QWORD, uint64_t, uint64_t))__CFBitVectorCountBits, (uint64_t)&v4);
  return v5;
}

void CFBitVectorFlipBitAtIndex(CFMutableBitVectorRef bv, CFIndex idx)
{
  *(_BYTE *)(*((_QWORD *)bv + 4) + idx / 8) ^= 1 << (~(_BYTE)idx & 7);
}

void CFBitVectorFlipBits(CFMutableBitVectorRef bv, CFRange range)
{
  CFIndex v2;
  CFIndex v3;
  int64_t v4;
  char v5;
  uint64_t v6;
  unint64_t v7;
  CFIndex v8;
  uint64_t v9;

  if (range.length)
  {
    v2 = range.location / 8;
    v3 = (range.location & 7) + range.length;
    if (v3 <= 7)
      v4 = 0;
    else
      v4 = (range.location | 0xFFFFFFFFFFFFFFF8) + range.length;
    if (v3 <= 7)
      v5 = (255 << (8 - LOBYTE(range.length))) >> (range.location & 7);
    else
      v5 = 0xFFu >> (range.location & 7);
    *(_BYTE *)(*((_QWORD *)bv + 4) + v2) ^= v5;
    if (v4 >= 0)
      v6 = v4;
    else
      v6 = v4 + 7;
    v7 = v6 & 0xFFFFFFFFFFFFFFF8;
    v8 = v2 + 1;
    if ((unint64_t)(v4 + 7) >= 0xF)
    {
      v9 = v6 >> 3;
      do
      {
        *(_BYTE *)(*((_QWORD *)bv + 4) + v8) = ~*(_BYTE *)(*((_QWORD *)bv + 4) + v8);
        ++v8;
        --v9;
      }
      while (v9);
    }
    if (v7 != v4)
      *(_BYTE *)(*((_QWORD *)bv + 4) + v8) ^= 255 << (v7 - v4 + 8);
  }
}

void CFBitVectorSetBits(CFMutableBitVectorRef bv, CFRange range, CFBit value)
{
  CFIndex v3;
  char v4;
  CFIndex v5;
  char v6;
  int v7;
  BOOL v8;
  int64_t v9;
  uint64_t v10;
  unint64_t v11;
  CFIndex v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  BOOL v17;
  int64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;

  if (range.length)
  {
    v3 = range.location / 8;
    v4 = range.location & 7;
    v5 = (range.location & 7) + range.length;
    v6 = 8 - LOBYTE(range.length);
    if (value)
    {
      v7 = (255 << v6) >> v4;
      v8 = v5 <= 7;
      if (v5 <= 7)
        v9 = 0;
      else
        v9 = (range.location | 0xFFFFFFFFFFFFFFF8) + range.length;
      if (!v8)
        LOBYTE(v7) = 0xFFu >> (range.location & 7);
      *(_BYTE *)(*((_QWORD *)bv + 4) + v3) |= v7;
      if (v9 >= 0)
        v10 = v9;
      else
        v10 = v9 + 7;
      v11 = v10 & 0xFFFFFFFFFFFFFFF8;
      v12 = v3 + 1;
      if ((unint64_t)(v9 + 7) >= 0xF)
      {
        v13 = v10 >> 3;
        do
        {
          *(_BYTE *)(*((_QWORD *)bv + 4) + v12++) = -1;
          --v13;
        }
        while (v13);
      }
      if (v11 != v9)
      {
        v14 = *((_QWORD *)bv + 4);
        v15 = *(unsigned __int8 *)(v14 + v12) | (255 << (v11 - v9 + 8));
LABEL_29:
        *(_BYTE *)(v14 + v12) = v15;
      }
    }
    else
    {
      v16 = (255 << v6) >> v4;
      v17 = v5 <= 7;
      if (v5 <= 7)
        v18 = 0;
      else
        v18 = (range.location | 0xFFFFFFFFFFFFFFF8) + range.length;
      if (!v17)
        LOBYTE(v16) = 0xFFu >> (range.location & 7);
      *(_BYTE *)(*((_QWORD *)bv + 4) + v3) &= ~(_BYTE)v16;
      if (v18 >= 0)
        v19 = v18;
      else
        v19 = v18 + 7;
      v20 = v19 & 0xFFFFFFFFFFFFFFF8;
      v12 = v3 + 1;
      if ((unint64_t)(v18 + 7) >= 0xF)
      {
        v21 = v19 >> 3;
        do
        {
          *(_BYTE *)(*((_QWORD *)bv + 4) + v12++) = 0;
          --v21;
        }
        while (v21);
      }
      if (v20 != v18)
      {
        v15 = 255 << (v20 - v18 + 8);
        v14 = *((_QWORD *)bv + 4);
        LOBYTE(v15) = *(_BYTE *)(v14 + v12) & ~(_BYTE)v15;
        goto LABEL_29;
      }
    }
  }
}

uint64_t CFStringEncodingPrecomposeLatinCharacter(unsigned __int16 *a1, uint64_t a2, unint64_t *a3)
{
  unsigned int v5;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;

  if (a2 < 1)
    goto LABEL_18;
  v5 = *a1;
  if ((v5 & 0xF800 | 0x400) == 0xDC00)
  {
    if (a3)
      *a3 = 1;
    return (unsigned __int16)v5;
  }
  v7 = 1;
  if ((unint64_t)a2 >= 2)
  {
    while (1)
    {
      v8 = a1[v7];
      if ((v8 & 0xF800 | 0x400) == 0xDC00 || !CFUniCharIsMemberOf(a1[v7], 8u))
        break;
      v9 = CFUniCharPrecomposeCharacter(v5, v8);
      if (v9 == 65533 || HIWORD(v9) != 0)
        break;
      ++v7;
      v5 = v9;
      if (a2 == v7)
      {
        LOWORD(v5) = v9;
        v7 = a2;
        break;
      }
    }
  }
  if (a3)
    *a3 = v7;
  if (v7 <= 1)
LABEL_18:
    LOWORD(v5) = -3;
  return (unsigned __int16)v5;
}

uint64_t __CFFromASCII(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if ((a2 & 0x80) == 0)
    *a3 = a2;
  return (a2 >> 7) ^ 1;
}

uint64_t __CFFromISOLatin1(uint64_t a1, __int16 a2, _WORD *a3)
{
  *a3 = a2;
  return 1;
}

unint64_t __CFToISOLatin1Precompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unint64_t result;
  unint64_t v11;
  unint64_t v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v12[0] = 0;
  v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, v12);
  result = 0;
  if (v9 <= 0xFF)
  {
    result = 0;
    if ((_BYTE)v9)
    {
      v11 = v12[0];
      if ((uint64_t)v12[0] >= 2)
      {
        if (a5)
          *a4 = v9;
        *a6 = 1;
        return v11;
      }
    }
  }
  return result;
}

uint64_t __CFFromMacRoman(uint64_t a1, int a2, _WORD *a3)
{
  *a3 = __CFMacRomanCharToUnicharTable[a2];
  return 1;
}

unint64_t __CFToMacRomanPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  int v10;
  unint64_t result;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;
  unint64_t v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v18[0] = 0;
  v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, v18);
  if (v9 <= 0x7F)
  {
    v10 = v9;
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 1277) < 0x59Du)
    return 0;
  v13 = (unsigned __int16 *)&macRoman_from_uni;
  v14 = (unsigned __int16 *)&unk_182C87510;
  while (1)
  {
    v15 = ((char *)v14 - (char *)v13) >> 3;
    v16 = &v13[2 * v15];
    v17 = *v16;
    if (v17 <= v9)
      break;
    v14 = v16 - 2;
LABEL_16:
    if (v13 > v14)
      return 0;
  }
  if (v17 < v9)
  {
    v13 = v16 + 2;
    goto LABEL_16;
  }
  v10 = LOBYTE(v13[2 * v15 + 1]);
LABEL_3:
  result = v18[0];
  if (!v10 || (int64_t)v18[0] < 2)
    return 0;
  if (a5)
    *a4 = v10;
  *a6 = 1;
  return result;
}

uint64_t __CFToWinLatin1(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  unsigned __int16 *v3;
  unsigned __int16 *v4;
  uint64_t v5;
  unsigned __int16 *v6;
  unsigned int v7;
  char v9;

  if (a2 < 0x80 || a2 - 160 <= 0x5F)
  {
    v9 = a2;
    goto LABEL_12;
  }
  if (a2 - 8483 < 0xFFFFE02F)
    return 0;
  v3 = (unsigned __int16 *)&cp1252_from_uni;
  v4 = (unsigned __int16 *)&unk_182C8757C;
  while (1)
  {
    v5 = ((char *)v4 - (char *)v3) >> 3;
    v6 = &v3[2 * v5];
    v7 = *v6;
    if (v7 <= a2)
      break;
    v4 = v6 - 2;
LABEL_9:
    if (v3 > v4)
      return 0;
  }
  if (v7 < a2)
  {
    v3 = v6 + 2;
    goto LABEL_9;
  }
  v9 = v3[2 * v5 + 1];
LABEL_12:
  *a3 = v9;
  return 1;
}

BOOL __CFFromWinLatin1(uint64_t a1, int a2, _WORD *a3)
{
  if ((char)a2 < -96)
    a2 = cp1252_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinLatin1Precompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  int v10;
  uint64_t result;
  uint64_t v12;
  BOOL v13;
  int64_t v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  v15 = 0;
  v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, (unint64_t *)&v15);
  v10 = __CFToWinLatin1(v9, v9, &v16);
  result = 0;
  v12 = v15;
  if (v10)
    v13 = v16 == 0;
  else
    v13 = 1;
  if (!v13 && v15 >= 2)
  {
    if (a5)
      *a4 = v16;
    *a6 = 1;
    return v12;
  }
  return result;
}

uint64_t __CFToNextStepLatin(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;

  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 2) >= 0xA2u)
    {
      v4 = (unsigned __int16 *)&nextstep_from_tab;
      v5 = (unsigned __int16 *)&unk_182C877B8;
      do
      {
        v6 = ((char *)v5 - (char *)v4) >> 3;
        v7 = &v4[2 * v6];
        v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          v4 = v7 + 2;
        }
        else
        {
          v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

BOOL __CFFromNextStepLatin(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = NSToPrecompUnicodeTable[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

unint64_t __CFToNextStepLatinPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  int v10;
  unint64_t result;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;
  unint64_t v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v18[0] = 0;
  v9 = CFStringEncodingPrecomposeLatinCharacter(a2, a3, v18);
  if (v9 <= 0x7F)
  {
    v10 = v9;
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 2) < 0xA2u)
    return 0;
  v13 = (unsigned __int16 *)&nextstep_from_tab;
  v14 = (unsigned __int16 *)&unk_182C877B8;
  while (1)
  {
    v15 = ((char *)v14 - (char *)v13) >> 3;
    v16 = &v13[2 * v15];
    v17 = *v16;
    if (v17 <= v9)
      break;
    v14 = v16 - 2;
LABEL_16:
    if (v13 > v14)
      return 0;
  }
  if (v17 < v9)
  {
    v13 = v16 + 2;
    goto LABEL_16;
  }
  v10 = LOBYTE(v13[2 * v15 + 1]);
LABEL_3:
  result = v18[0];
  if (!v10 || (int64_t)v18[0] < 2)
    return 0;
  if (a5)
    *a4 = v10;
  *a6 = 1;
  return result;
}

uint64_t __CFToUTF8Len(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t result;
  unsigned __int16 *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  int v9;
  int v10;
  unsigned __int16 *v11;
  int v12;
  int v13;
  int v14;

  if (!a3)
    return 0;
  LODWORD(result) = 0;
  v4 = a2;
  do
  {
    v6 = *v4++;
    v5 = v6;
    v7 = a3 - 1;
    if ((v6 & 0xFC00) != 0xD800 || a3 == 1)
    {
      --a3;
    }
    else
    {
      v9 = *v4;
      v10 = v9 & 0xFC00;
      v11 = a2 + 2;
      v12 = v9 + (v5 << 10) - 56613888;
      a3 -= 2;
      if (v10 == 56320)
        v4 = v11;
      else
        a3 = v7;
      if (v10 == 56320)
        v5 = v12;
    }
    if (v5 < 0x10000)
      v13 = 3;
    else
      v13 = 4;
    if (v5 < 0x800)
      v13 = 2;
    if (v5 >= 0x80)
      v14 = v13;
    else
      v14 = 1;
    result = (v14 + result);
    a2 = v4;
  }
  while (a3);
  return result;
}

uint64_t __CFFromUTF8Len(__int16 a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned __int8 *v10;
  char v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v22[10];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v3 = a3;
    v6 = 0;
    v7 = a1 & 0xC0;
    while (1)
    {
      v8 = *a2;
      if (v3 <= (unsigned __int16)trailingBytesForUTF8[*a2])
        return v6;
      --v3;
      if ((~(_BYTE)v8 & 0xF8) == 0)
        break;
      v9 = (unsigned __int16)trailingBytesForUTF8[*a2];
      if ((a1 & 0x800) == 0)
      {
        v10 = &a2[v9];
        while (v10 > a2)
        {
          v11 = *v10--;
          if ((v11 & 0xC0) != 0x80)
            goto LABEL_5;
        }
        if ((char)v8 < -62 || v8 > 0xF4)
          break;
        if (*a2 > 0xEFu)
        {
          if (v8 == 240)
          {
            if (a2[1] < 0x90u)
              break;
          }
          else if (v8 == 244 && a2[1] >= 0x90u)
          {
            break;
          }
        }
        else if (v8 == 224)
        {
          if (a2[1] < 0xA0u)
            break;
        }
        else if (v8 == 237 && a2[1] > 0x9Fu)
        {
          break;
        }
      }
      v12 = 0;
      v13 = (unsigned __int16)trailingBytesForUTF8[*a2];
      switch(*a2)
      {
        case 0u:
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xAu:
        case 0xBu:
        case 0xCu:
        case 0xDu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x23u:
        case 0x24u:
        case 0x25u:
        case 0x26u:
        case 0x27u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x2Bu:
        case 0x2Cu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x3Fu:
        case 0x40u:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Bu:
        case 0x5Cu:
        case 0x5Du:
        case 0x5Eu:
        case 0x5Fu:
        case 0x60u:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
        case 0x7Bu:
        case 0x7Cu:
        case 0x7Du:
        case 0x7Eu:
        case 0x7Fu:
        case 0x80u:
        case 0x81u:
        case 0x82u:
        case 0x83u:
        case 0x84u:
        case 0x85u:
        case 0x86u:
        case 0x87u:
        case 0x88u:
        case 0x89u:
        case 0x8Au:
        case 0x8Bu:
        case 0x8Cu:
        case 0x8Du:
        case 0x8Eu:
        case 0x8Fu:
        case 0x90u:
        case 0x91u:
        case 0x92u:
        case 0x93u:
        case 0x94u:
        case 0x95u:
        case 0x96u:
        case 0x97u:
        case 0x98u:
        case 0x99u:
        case 0x9Au:
        case 0x9Bu:
        case 0x9Cu:
        case 0x9Du:
        case 0x9Eu:
        case 0x9Fu:
        case 0xA0u:
        case 0xA1u:
        case 0xA2u:
        case 0xA3u:
        case 0xA4u:
        case 0xA5u:
        case 0xA6u:
        case 0xA7u:
        case 0xA8u:
        case 0xA9u:
        case 0xAAu:
        case 0xABu:
        case 0xACu:
        case 0xADu:
        case 0xAEu:
        case 0xAFu:
        case 0xB0u:
        case 0xB1u:
        case 0xB2u:
        case 0xB3u:
        case 0xB4u:
        case 0xB5u:
        case 0xB6u:
        case 0xB7u:
        case 0xB8u:
        case 0xB9u:
        case 0xBAu:
        case 0xBBu:
        case 0xBCu:
        case 0xBDu:
        case 0xBEu:
        case 0xBFu:
          goto LABEL_34;
        case 0xC0u:
        case 0xC1u:
        case 0xC2u:
        case 0xC3u:
        case 0xC4u:
        case 0xC5u:
        case 0xC6u:
        case 0xC7u:
        case 0xC8u:
        case 0xC9u:
        case 0xCAu:
        case 0xCBu:
        case 0xCCu:
        case 0xCDu:
        case 0xCEu:
        case 0xCFu:
        case 0xD0u:
        case 0xD1u:
        case 0xD2u:
        case 0xD3u:
        case 0xD4u:
        case 0xD5u:
        case 0xD6u:
        case 0xD7u:
        case 0xD8u:
        case 0xD9u:
        case 0xDAu:
        case 0xDBu:
        case 0xDCu:
        case 0xDDu:
        case 0xDEu:
        case 0xDFu:
          goto LABEL_33;
        case 0xE0u:
        case 0xE1u:
        case 0xE2u:
        case 0xE3u:
        case 0xE4u:
        case 0xE5u:
        case 0xE6u:
        case 0xE7u:
        case 0xE8u:
        case 0xE9u:
        case 0xEAu:
        case 0xEBu:
        case 0xECu:
        case 0xEDu:
        case 0xEEu:
        case 0xEFu:
          goto LABEL_32;
        case 0xF0u:
        case 0xF1u:
        case 0xF2u:
        case 0xF3u:
        case 0xF4u:
        case 0xF5u:
        case 0xF6u:
        case 0xF7u:
          v12 = v8 << 6;
          v14 = *++a2;
          v8 = v14;
LABEL_32:
          v15 = *++a2;
          v12 = (v12 + v8) << 6;
          v8 = v15;
LABEL_33:
          v16 = *++a2;
          v13 = (v12 + v8) << 6;
          v8 = v16;
LABEL_34:
          ++a2;
          v12 = v13 + v8;
          break;
        default:
          break;
      }
      v3 -= v9;
      v17 = v12 - offsetsFromUTF8[v9];
      if (HIWORD(v17))
      {
        if (v17 < 0x110000)
        {
          if (v7 && CFUniCharIsMemberOf(v17, 0x65u))
          {
            v18 = CFUniCharDecomposeCharacter(v17, v22, 10);
            if (v18 >= 1)
            {
              do
              {
                if (v22[v18 - 1] < 0x10000)
                  v19 = 1;
                else
                  v19 = 2;
                v6 += v19;
              }
              while ((unint64_t)v18-- > 1);
            }
          }
          else
          {
            v6 += 2;
          }
          goto LABEL_9;
        }
      }
      else
      {
        if ((a1 & 0x80) == 0 && (v17 & 0xFFFFF800) == 0xD800)
          return v6;
        if (v7 && v17 >= 0x80 && CFUniCharIsMemberOf(v17, 0x65u))
        {
          v6 += CFUniCharDecomposeCharacter(v17, v22, 10);
          goto LABEL_9;
        }
      }
LABEL_8:
      ++v6;
LABEL_9:
      if (!v3)
        return v6;
    }
LABEL_5:
    if ((a1 & 1) == 0 && v8 != 169)
      return v6;
    ++a2;
    goto LABEL_8;
  }
  return 0;
}

CFURLRef _CFBundleCopyMainBundleExecutableURL(_BYTE *a1)
{
  const char *v2;
  const __CFString *v3;
  const __CFString *v4;
  CFURLRef v5;
  char v6;

  v2 = _CFProcessPath();
  if (v2 && (v3 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2)) != 0)
  {
    v4 = v3;
    v5 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3, kCFURLPOSIXPathStyle, 0);
    CFRelease(v4);
    if (!a1)
      return v5;
  }
  else
  {
    v5 = 0;
    if (!a1)
      return v5;
  }
  v6 = _mainBundle;
  if (_mainBundle)
    v6 = *(unsigned __int8 *)(_mainBundle + 53) - 5 < 0xFFFFFFFE;
  *a1 = v6;
  return v5;
}

uint64_t _CFBundleSupportsFHSBundles()
{
  return 0;
}

uint64_t _CFBundleSupportsFreestandingBundles()
{
  return 0;
}

CFURLRef _CFURLCreateResolvedDirectoryWithString(const __CFAllocator *a1, const __CFString *a2, const __CFURL *a3)
{
  const __CFURL *v4;
  const __CFURL *v5;
  const __CFString *v6;
  int v7;
  int v8;
  const __CFString *v9;
  CFURLRef v10;
  NSObject *v11;
  char v13[1024];
  char buffer[1024];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = CFURLCreateWithString(a1, a2, a3);
  v5 = CFURLCopyAbsoluteURL(v4);
  CFRelease(v4);
  v6 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
  CFRelease(v5);
  LODWORD(v5) = CFStringGetFileSystemRepresentation(v6, buffer, 1024);
  CFRelease(v6);
  if (!(_DWORD)v5)
    return 0;
  v7 = open(buffer, 0);
  if (v7 < 1)
    return 0;
  v8 = v7;
  if (fcntl(v7, 50, v13) == -1)
  {
    if (_CFBundleResourceLogger_onceToken != -1)
      dispatch_once(&_CFBundleResourceLogger_onceToken, &__block_literal_global);
    v11 = _CFBundleResourceLogger__log;
    if (os_log_type_enabled((os_log_t)_CFBundleResourceLogger__log, OS_LOG_TYPE_ERROR))
      _CFURLCreateResolvedDirectoryWithString_cold_1(v11);
    close(v8);
    return 0;
  }
  close(v8);
  v9 = CFStringCreateWithFileSystemRepresentation(a1, v13);
  v10 = CFURLCreateWithFileSystemPath(a1, v9, kCFURLPOSIXPathStyle, 1u);
  CFRelease(v9);
  return v10;
}

uint64_t _CFBundleResourceURLIsSafeForMapping(const __CFURL *a1)
{
  uint64_t result;
  statfs v3;
  UInt8 buffer[1026];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026);
  if ((_DWORD)result)
  {
    memset(&v3, 0, 512);
    return !statfs((const char *)buffer, &v3) && (v3.f_flags & 0x1200) == 4096;
  }
  return result;
}

CFDataRef _CFBundleCreateMappedOrLoadedPlistData(const __CFURL *a1, int a2, uint64_t a3, BOOL *a4, CFErrorRef *a5)
{
  int v9;
  CFDataRef result;

  v9 = _CFBundleResourceURLIsSafeForMapping(a1);
  if (!a2 || !v9)
  {
    *a4 = 0;
    return _CFDataCreateFromURL(a1, a5);
  }
  result = (CFDataRef)_CFBundleCreateMappedBPlistFile();
  *a4 = result != 0;
  if (!result)
    return _CFDataCreateFromURL(a1, a5);
  return result;
}

CFBundleRef _CFBundleMainBundleInfoDictionaryComesFromResourceFork()
{
  CFBundleRef result;

  result = CFBundleGetMainBundle();
  if (result)
    return (CFBundleRef)(*((_BYTE *)result + 65) != 0);
  return result;
}

void _CFBundleFlushBundleCaches(uint64_t a1)
{
  os_unfair_lock_s *v2;
  const void *v3;
  const __CFDictionary *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *Value;

  v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  v4 = *(const __CFDictionary **)(a1 + 24);
  v3 = *(const void **)(a1 + 32);
  *(_QWORD *)(a1 + 24) = 0;
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v5 = *(const void **)(a1 + 216);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 216) = 0;
  }
  v6 = *(const void **)(a1 + 104);
  if (v6)
  {
    CFRelease(v6);
    *(_QWORD *)(a1 + 104) = 0;
  }
  v7 = *(const void **)(a1 + 40);
  if (v7)
  {
    CFRelease(v7);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v8 = *(const void **)(a1 + 144);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 144) = 0;
  }
  v9 = *(const void **)(a1 + 152);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v10 = *(const void **)(a1 + 160);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 160) = 0;
  }
  if (*(_BYTE *)(a1 + 128))
  {
    *(_BYTE *)(a1 + 128) = 0;
    v11 = *(const void **)(a1 + 120);
    if (v11)
    {
      CFRelease(v11);
      *(_QWORD *)(a1 + 120) = 0;
    }
  }
  _CFBundleRefreshInfoDictionaryAlreadyLocked(a1);
  if (v4)
  {
    if (!*(_QWORD *)(a1 + 24))
      *(_QWORD *)(a1 + 24) = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    Value = CFDictionaryGetValue(v4, CFSTR("NSPrincipalClass"));
    if (Value)
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), CFSTR("NSPrincipalClass"), Value);
    CFRelease(v4);
  }
  _CFBundleFlushQueryTableCache(a1);
  os_unfair_lock_unlock(v2);
}

CFTypeID CFBundleGetTypeID(void)
{
  return 31;
}

CFBundleRef _CFBundleGetExistingBundleWithBundleURL(CFURLRef bundleURL)
{
  return CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, bundleURL);
}

_QWORD *_CFBundleCreateUniqueWithOptions(const __CFAllocator *a1, const __CFURL *a2, const __CFSet *a3, char a4)
{
  int v5;

  if ((a4 & 1) != 0)
    v5 = 2;
  else
    v5 = 1;
  return _CFBundleCreate(a1, a2, v5, a3);
}

UInt32 CFBundleGetVersionNumber(CFBundleRef bundle)
{
  const __CFDictionary *InfoDictionary;
  const __CFNumber *Value;
  const __CFNumber *v3;
  CFTypeID v4;
  int valuePtr;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  InfoDictionary = CFBundleGetInfoDictionary(bundle);
  Value = (const __CFNumber *)CFDictionaryGetValue(InfoDictionary, CFSTR("CFBundleNumericVersion"));
  if (Value)
  {
    v3 = Value;
    v4 = CFGetTypeID(Value);
    if (v4 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      CFNumberGetValue(v3, kCFNumberSInt32Type, &valuePtr);
      LODWORD(Value) = valuePtr;
    }
    else
    {
      LODWORD(Value) = 0;
    }
  }
  return Value;
}

uint64_t _CFBundleGetHasChanged()
{
  return 1;
}

uint64_t _CFBundleGetStringsFilesShared()
{
  return 0;
}

CFURLRef _CFBundleCopyAppStoreReceiptURLInDirectory(CFURLRef baseURL, unsigned int a2)
{
  if (baseURL && a2 <= 0xD && ((0x300Fu >> a2) & 1) != 0)
    return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, off_1E12E11C0[(char)a2], baseURL);
  else
    return 0;
}

CFURLRef _CFBundleCopyAppStoreReceiptURL(uint64_t a1)
{
  return _CFBundleCopyAppStoreReceiptURLInDirectory(*(CFURLRef *)(a1 + 16), *(unsigned __int8 *)(a1 + 53));
}

CFURLRef _CFBundleCopyWrappedBundleURL(uint64_t a1)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  if ((*(_BYTE *)(a1 + 53) & 0xFE) == 0xC)
    return _CFURLCreateResolvedDirectoryWithString((const __CFAllocator *)&__kCFAllocatorSystemDefault, CFSTR("WrappedBundle"), *(const __CFURL **)(a1 + 16));
  else
    return 0;
}

CFURLRef _CFBundleCopyWrapperContainerURL(uint64_t a1)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  if ((*(_BYTE *)(a1 + 53) & 0xFE) == 0xC)
    return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("Wrapper"), *(CFURLRef *)(a1 + 16));
  else
    return 0;
}

const __CFURL *CFBundleGetExecutableType(uint64_t a1)
{
  unint64_t v2;
  const __CFURL *result;
  int32x4_t v4;
  const __CFURL *v5;
  int v6;
  int v7;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  result = CFBundleCopyExecutableURL((CFBundleRef)a1);
  if (result)
  {
    v5 = result;
    if (!*(_DWORD *)(a1 + 48))
    {
      v7 = _CFBundleGrokBinaryType(result, v4);
      *(_DWORD *)(a1 + 48) = v7;
      if (v7 != 1 && v7 != 6)
        *(_BYTE *)(a1 + 64) = 1;
    }
    CFRelease(v5);
    v6 = *(_DWORD *)(a1 + 48) - 1;
    if (v6 > 7)
      return 0;
    else
      return (const __CFURL *)dword_182C87A28[v6];
  }
  else
  {
    *(_DWORD *)(a1 + 48) = 7;
  }
  return result;
}

CFErrorRef _CFBundleCreateErrorDebug(const __CFAllocator *a1, CFBundleRef bundle, CFIndex a3, void *a4)
{
  uint64_t v4;
  const __CFURL *v7;
  const __CFURL *v8;
  const __CFURL *v9;
  __CFBundle *BundleWithIdentifier;
  CFStringRef v11;
  CFStringRef v12;
  CFTypeRef ValueForInfoDictionaryKey;
  const __CFString *v14;
  CFStringRef StringWithValidatedFormat;
  CFStringRef v16;
  const __CFURL *v17;
  const __CFURL *v18;
  const __CFString *v19;
  CFIndex Length;
  CFIndex v21;
  uint64_t PathComponent;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFString *v26;
  CFIndex v27;
  CFErrorRef v28;
  CFIndex v31;
  void *userInfoValues[2];
  __int128 v34;
  __int128 v35;
  void *userInfoKeys[2];
  __int128 v37;
  __int128 v38;
  UniChar buffer[1026];
  uint64_t v40;
  CFRange v41;

  v40 = *MEMORY[0x1E0C80C00];
  v7 = CFBundleCopyBundleURL(bundle);
  v8 = CFURLCopyAbsoluteURL(v7);
  v9 = CFBundleCopyExecutableURL(bundle);
  BundleWithIdentifier = _CFBundleGetBundleWithIdentifier(CFSTR("com.apple.CoreFoundation"), v4);
  v11 = CFURLCopyFileSystemPath(v8, kCFURLPOSIXPathStyle);
  if (v9)
    v12 = CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle);
  else
    v12 = 0;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  *(_OWORD *)userInfoKeys = 0u;
  *(_OWORD *)userInfoValues = 0u;
  v34 = 0u;
  v31 = a3;
  if (!BundleWithIdentifier)
  {
    StringWithValidatedFormat = 0;
    v16 = 0;
    goto LABEL_32;
  }
  ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(bundle, CFSTR("CFBundleName"));
  if (ValueForInfoDictionaryKey)
  {
    v14 = (const __CFString *)CFRetain(ValueForInfoDictionaryKey);
  }
  else
  {
    v17 = CFBundleCopyBundleURL(bundle);
    if (!v17)
    {
      v23 = CFSTR("<unknown>");
      goto LABEL_18;
    }
    v18 = v17;
    v19 = CFURLCopyFileSystemPath(v17, kCFURLPOSIXPathStyle);
    Length = CFStringGetLength(v19);
    CFRelease(v18);
    if (Length >= 1026)
      v21 = 1026;
    else
      v21 = Length;
    v41.location = 0;
    v41.length = v21;
    CFStringGetCharacters(v19, v41, buffer);
    CFRelease(v19);
    if (Length < 1)
      PathComponent = 0;
    else
      PathComponent = _CFStartOfLastPathComponent(buffer, v21);
    v14 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, &buffer[PathComponent], v21 - PathComponent);
  }
  v23 = v14;
LABEL_18:
  switch(a3)
  {
    case 3584:
      v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr3584"), CFSTR("The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because its executable isn\\U2019t loadable."), CFSTR("Error"));
      v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr3584-C"), CFSTR("The bundle\\U2019s executable isn\\U2019t loadable."), CFSTR("Error"));
      v25 = CFSTR("BundleErr3584-R");
      goto LABEL_26;
    case 3585:
      v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr3585"), CFSTR("The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because it doesn\\U2019t contain a version for the current architecture."), CFSTR("Error"));
      v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr3585-C"), CFSTR("The bundle doesn\\U2019t contain a version for the current architecture."), CFSTR("Error"));
      v25 = CFSTR("BundleErr3585-R");
      v26 = CFSTR("Try installing a universal version of the bundle.");
      goto LABEL_27;
    case 3586:
      v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr3586"), CFSTR("The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because it isn\\U2019t compatible with the current application."), CFSTR("Error"));
      v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr3586-C"), CFSTR("The bundle isn\\U2019t compatible with this application."), CFSTR("Error"));
      v25 = CFSTR("BundleErr3586-R");
      v26 = CFSTR("Try installing a newer version of the bundle.");
      goto LABEL_27;
    case 3587:
      v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr3587"), CFSTR("The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because it is damaged or missing necessary resources."), CFSTR("Error"));
      v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr3587-C"), CFSTR("The bundle is damaged or missing necessary resources."), CFSTR("Error"));
      v25 = CFSTR("BundleErr3587-R");
      goto LABEL_26;
    case 3588:
      v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr3588"), CFSTR("The bundle \\U201c%@\\U201d couldn\\U2019t be loaded."), CFSTR("Error"));
      v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr3588-C"), CFSTR("The bundle couldn\\U2019t be loaded."), CFSTR("Error"));
      v25 = CFSTR("BundleErr3588-R");
      goto LABEL_26;
    default:
      if (a3 == 4)
      {
        v24 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr4"), CFSTR("The bundle \\U201c%@\\U201d couldn\\U2019t be loaded because its executable couldn\\U2019t be located."), CFSTR("Error"));
        v16 = CFBundleCopyLocalizedString(BundleWithIdentifier, CFSTR("BundleErr4-C"), CFSTR("The bundle\\U2019s executable couldn\\U2019t be located."), CFSTR("Error"));
        v25 = CFSTR("BundleErr4-R");
LABEL_26:
        v26 = CFSTR("Try reinstalling the bundle.");
LABEL_27:
        BundleWithIdentifier = (__CFBundle *)CFBundleCopyLocalizedString(BundleWithIdentifier, v25, v26, CFSTR("Error"));
        if (v24)
        {
          StringWithValidatedFormat = CFStringCreateStringWithValidatedFormat(a1, 0, CFSTR("%@"), v24, 0, v23);
          CFRelease(v24);
          goto LABEL_31;
        }
      }
      else
      {
        BundleWithIdentifier = 0;
        v16 = 0;
      }
      StringWithValidatedFormat = 0;
LABEL_31:
      CFRelease(v23);
      break;
  }
LABEL_32:
  if (v11)
  {
    userInfoKeys[0] = CFSTR("NSBundlePath");
    userInfoValues[0] = (void *)v11;
    v27 = 1;
    if (!v12)
      goto LABEL_35;
    goto LABEL_34;
  }
  v27 = 0;
  if (v12)
  {
LABEL_34:
    *(_QWORD *)((unint64_t)userInfoKeys | (8 * v27)) = CFSTR("NSFilePath");
    *(_QWORD *)((unint64_t)userInfoValues & 0xFFFFFFFFFFFFFFF7 | (8 * (v27++ & 1))) = v12;
  }
LABEL_35:
  if (StringWithValidatedFormat)
  {
    userInfoKeys[v27] = CFSTR("NSLocalizedDescription");
    userInfoValues[v27++] = (void *)StringWithValidatedFormat;
  }
  if (v16)
  {
    userInfoKeys[v27] = CFSTR("NSLocalizedFailureReason");
    userInfoValues[v27++] = (void *)v16;
  }
  if (BundleWithIdentifier)
  {
    userInfoKeys[v27] = CFSTR("NSLocalizedRecoverySuggestion");
    userInfoValues[v27++] = BundleWithIdentifier;
  }
  if (a4)
  {
    userInfoKeys[v27] = CFSTR("NSDebugDescription");
    userInfoValues[v27++] = a4;
  }
  v28 = CFErrorCreateWithUserInfoKeysAndValues(a1, CFSTR("NSCocoaErrorDomain"), v31, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, v27);
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  if (v9)
    CFRelease(v9);
  if (v11)
    CFRelease(v11);
  if (v12)
    CFRelease(v12);
  if (StringWithValidatedFormat)
    CFRelease(StringWithValidatedFormat);
  if (v16)
    CFRelease(v16);
  if (BundleWithIdentifier)
    CFRelease(BundleWithIdentifier);
  return v28;
}

CFErrorRef _CFBundleCreateError(const __CFAllocator *a1, __CFBundle *a2, CFIndex a3)
{
  return _CFBundleCreateErrorDebug(a1, a2, a3, 0);
}

CFArrayRef CFBundleCopyExecutableArchitectures(CFBundleRef bundle)
{
  CFArrayRef result;
  int32x4_t v2;
  CFArrayRef v3;
  const __CFArray *v4;

  result = CFBundleCopyExecutableURL(bundle);
  if (result)
  {
    v3 = result;
    v4 = _CFBundleCopyArchitecturesForExecutable(result, v2);
    CFRelease(v3);
    return v4;
  }
  return result;
}

uint64_t __CFBundleGetResourceData(uint64_t a1)
{
  return a1 + 64;
}

CFArrayRef CFBundleGetAllBundles(void)
{
  __CFArray *v0;
  __CFArray *v1;
  const __CFArray *v2;

  os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  if (CFBundleGetAllBundles__lastBundleList)
  {
    if (!CFEqual((CFTypeRef)CFBundleGetAllBundles__lastBundleList, (CFTypeRef)_allBundles))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      v0 = _CFBundleCopyAllBundles();
      os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
      CFBundleGetAllBundles__lastBundleList = (uint64_t)v0;
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    v1 = _CFBundleCopyAllBundles();
    os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
    if (CFBundleGetAllBundles__lastBundleList)
      CFRelease(v1);
    else
      CFBundleGetAllBundles__lastBundleList = (uint64_t)v1;
  }
  v2 = (const __CFArray *)CFBundleGetAllBundles__lastBundleList;
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  return v2;
}

__CFArray *_CFBundleCopyAllBundles()
{
  CFBundleRef MainBundle;
  CFIndex Count;
  __CFArray *MutableCopy;

  _CFBundleEnsureAllBundlesUpToDate();
  MainBundle = CFBundleGetMainBundle();
  os_unfair_lock_lock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  Count = CFArrayGetCount((CFArrayRef)_allBundles);
  MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count + 1, (CFArrayRef)_allBundles);
  os_unfair_lock_unlock((os_unfair_lock_t)&CFBundleGlobalDataLock);
  CFArrayInsertValueAtIndex(MutableCopy, 0, MainBundle);
  return MutableCopy;
}

CFURLRef CFBundleCopyPrivateFrameworksURL(CFBundleRef bundle)
{
  unint64_t v2;
  unsigned int v3;
  const __CFAllocator *v4;
  const __CFURL *v5;
  const __CFString *v6;
  const __CFAllocator *v7;
  const __CFURL *v8;
  const __CFString *v9;

  v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  v3 = *((unsigned __int8 *)bundle + 53);
  if (v3 > 0xB)
  {
    if (v3 == 12)
    {
      v7 = CFGetAllocator(bundle);
      v8 = (const __CFURL *)*((_QWORD *)bundle + 2);
      v9 = CFSTR("WrappedBundle/Contents/Frameworks/");
    }
    else
    {
      if (v3 != 13)
        goto LABEL_12;
      v7 = CFGetAllocator(bundle);
      v8 = (const __CFURL *)*((_QWORD *)bundle + 2);
      v9 = CFSTR("WrappedBundle/Frameworks/");
    }
    return _CFURLCreateResolvedDirectoryWithString(v7, v9, v8);
  }
  if (v3 == 1)
  {
    v4 = CFGetAllocator(bundle);
    v5 = (const __CFURL *)*((_QWORD *)bundle + 2);
    v6 = CFSTR("Support%20Files/Frameworks/");
    return CFURLCreateWithString(v4, v6, v5);
  }
  if (v3 != 2)
  {
LABEL_12:
    v4 = CFGetAllocator(bundle);
    v5 = (const __CFURL *)*((_QWORD *)bundle + 2);
    v6 = CFSTR("Frameworks/");
    return CFURLCreateWithString(v4, v6, v5);
  }
  v4 = CFGetAllocator(bundle);
  v5 = (const __CFURL *)*((_QWORD *)bundle + 2);
  v6 = CFSTR("Contents/Frameworks/");
  return CFURLCreateWithString(v4, v6, v5);
}

CFURLRef CFBundleCopySharedFrameworksURL(CFBundleRef bundle)
{
  unint64_t v2;
  unsigned int v3;
  const __CFAllocator *v4;
  const __CFURL *v5;
  const __CFString *v6;
  const __CFAllocator *v7;
  const __CFURL *v8;
  const __CFString *v9;

  v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  v3 = *((unsigned __int8 *)bundle + 53);
  if (v3 > 0xB)
  {
    if (v3 == 12)
    {
      v7 = CFGetAllocator(bundle);
      v8 = (const __CFURL *)*((_QWORD *)bundle + 2);
      v9 = CFSTR("WrappedBundle/Contents/SharedFrameworks/");
    }
    else
    {
      if (v3 != 13)
        goto LABEL_12;
      v7 = CFGetAllocator(bundle);
      v8 = (const __CFURL *)*((_QWORD *)bundle + 2);
      v9 = CFSTR("WrappedBundle/SharedFrameworks/");
    }
    return _CFURLCreateResolvedDirectoryWithString(v7, v9, v8);
  }
  if (v3 == 1)
  {
    v4 = CFGetAllocator(bundle);
    v5 = (const __CFURL *)*((_QWORD *)bundle + 2);
    v6 = CFSTR("Support%20Files/SharedFrameworks/");
    return CFURLCreateWithString(v4, v6, v5);
  }
  if (v3 != 2)
  {
LABEL_12:
    v4 = CFGetAllocator(bundle);
    v5 = (const __CFURL *)*((_QWORD *)bundle + 2);
    v6 = CFSTR("SharedFrameworks/");
    return CFURLCreateWithString(v4, v6, v5);
  }
  v4 = CFGetAllocator(bundle);
  v5 = (const __CFURL *)*((_QWORD *)bundle + 2);
  v6 = CFSTR("Contents/SharedFrameworks/");
  return CFURLCreateWithString(v4, v6, v5);
}

CFURLRef CFBundleCopySharedSupportURL(CFBundleRef bundle)
{
  unint64_t v2;
  unsigned int v3;
  const __CFAllocator *v4;
  const __CFURL *v5;
  const __CFString *v6;
  const __CFAllocator *v7;
  const __CFURL *v8;
  const __CFString *v9;

  v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  v3 = *((unsigned __int8 *)bundle + 53);
  if (v3 > 0xB)
  {
    if (v3 == 12)
    {
      v7 = CFGetAllocator(bundle);
      v8 = (const __CFURL *)*((_QWORD *)bundle + 2);
      v9 = CFSTR("WrappedBundle/Contents/SharedSupport/");
    }
    else
    {
      if (v3 != 13)
        goto LABEL_12;
      v7 = CFGetAllocator(bundle);
      v8 = (const __CFURL *)*((_QWORD *)bundle + 2);
      v9 = CFSTR("WrappedBundle/SharedSupport/");
    }
    return _CFURLCreateResolvedDirectoryWithString(v7, v9, v8);
  }
  if (v3 == 1)
  {
    v4 = CFGetAllocator(bundle);
    v5 = (const __CFURL *)*((_QWORD *)bundle + 2);
    v6 = CFSTR("Support%20Files/SharedSupport/");
    return CFURLCreateWithString(v4, v6, v5);
  }
  if (v3 != 2)
  {
LABEL_12:
    v4 = CFGetAllocator(bundle);
    v5 = (const __CFURL *)*((_QWORD *)bundle + 2);
    v6 = CFSTR("SharedSupport/");
    return CFURLCreateWithString(v4, v6, v5);
  }
  v4 = CFGetAllocator(bundle);
  v5 = (const __CFURL *)*((_QWORD *)bundle + 2);
  v6 = CFSTR("Contents/SharedSupport/");
  return CFURLCreateWithString(v4, v6, v5);
}

void OUTLINED_FUNCTION_0_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void _CFBundleFlushQueryTableCache(uint64_t a1)
{
  os_unfair_lock_s *v2;
  __CFDictionary *v3;

  v2 = (os_unfair_lock_s *)(a1 + 176);
  os_unfair_lock_lock_with_options();
  v3 = *(__CFDictionary **)(a1 + 184);
  if (v3)
    CFDictionaryRemoveAllValues(v3);
  os_unfair_lock_unlock(v2);
}

unint64_t *_CFBundleCopyResourceURLForLanguage(unint64_t *result, const __CFString *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5)
{
  if (result)
    return (unint64_t *)_CFBundleCopyFindResources(result, 0, (uint64_t)a3, a2, a3, a4, a5, 0, 1, 0);
  return result;
}

CFArrayRef CFBundleCopyResourceURLsOfTypeInDirectory(CFURLRef bundleURL, CFStringRef resourceType, CFStringRef subDirName)
{
  size_t v6;
  const __CFURL *v7;
  uint64_t v8;
  const __CFArray *Resources;
  UInt8 buffer[1026];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!CFURLGetFileSystemRepresentation(bundleURL, 1u, buffer, 1026))
    return 0;
  v6 = strlen((const char *)buffer);
  v7 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer, v6, 1u);
  if (!v7)
    v7 = (const __CFURL *)CFRetain(bundleURL);
  if (_CFBundleCouldBeBundle(v7))
  {
    Resources = _CFBundleCopyFindResources(0, bundleURL, v8, 0, resourceType, subDirName, 0, 1, 0, 0);
    if (!v7)
      return Resources;
    goto LABEL_9;
  }
  Resources = 0;
  if (v7)
LABEL_9:
    CFRelease(v7);
  return Resources;
}

uint64_t _CFBundleGetSupportedPlatforms()
{
  return 0;
}

const __CFString *_CFBundleGetCurrentPlatform()
{
  return CFSTR("iPhoneOS");
}

CFArrayRef CFBundleCopyExecutableArchitecturesForURL(CFURLRef url)
{
  __CFBundle *v2;
  int32x4_t v3;
  __CFBundle *v4;
  const __CFArray *v5;

  v2 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, url);
  if (!v2)
    return _CFBundleCopyArchitecturesForExecutable(url, v3);
  v4 = v2;
  v5 = CFBundleCopyExecutableArchitectures(v2);
  CFRelease(v4);
  return v5;
}

CFBundleRef _CFBundleAddResourceURL(uint64_t a1, const __CFURL *a2)
{
  CFBundleRef result;
  const void *v5;
  __CFDictionary *Mutable;

  result = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
  if (result)
  {
    v5 = result;
    if (result == (CFBundleRef)a1)
    {
      __break(1u);
    }
    else
    {
      os_unfair_lock_lock_with_options();
      Mutable = *(__CFDictionary **)(a1 + 208);
      if (!Mutable)
      {
        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(_QWORD *)(a1 + 208) = Mutable;
      }
      CFDictionarySetValue(Mutable, a2, v5);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 200));
      CFRelease(v5);
      _CFBundleFlushStringSourceCache(a1);
      return (CFBundleRef)1;
    }
  }
  return result;
}

uint64_t _CFBundleRemoveResourceURL(uint64_t a1, const void *a2)
{
  os_unfair_lock_s *v4;
  __CFDictionary *v5;
  uint64_t v6;

  v4 = (os_unfair_lock_s *)(a1 + 200);
  os_unfair_lock_lock_with_options();
  v5 = *(__CFDictionary **)(a1 + 208);
  if (v5)
  {
    CFDictionaryRemoveValue(v5, a2);
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  os_unfair_lock_unlock(v4);
  _CFBundleFlushStringSourceCache(a1);
  return v6;
}

void _CFBundleFindResourcesWithPredicate(__CFArray *a1, CFDictionaryRef theDict, uint64_t a3, _BYTE *a4)
{
  CFIndex Count;
  uint64_t v9;
  size_t v10;
  const void **v11;
  const void **v12;
  const void **v13;
  uint64_t v14;
  const void **v15;
  CFTypeRef *v16;
  CFTypeID v17;
  CFTypeID TypeID;
  const __CFArray *v19;
  BOOL v20;
  CFRange v21;

  Count = CFDictionaryGetCount(theDict);
  if (Count)
  {
    v9 = Count;
    v10 = 8 * Count;
    v11 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
    v12 = (const void **)malloc_type_malloc(v10, 0xC0040B8AA526DuLL);
    v13 = v12;
    if (v11 && v12)
    {
      CFDictionaryGetKeysAndValues(theDict, v11, v12);
      v14 = v9 - 1;
      if (v9 >= 1)
      {
        v15 = v11;
        v16 = v13;
        do
        {
          if ((*(unsigned int (**)(uint64_t, const void *, _BYTE *))(a3 + 16))(a3, *v15, a4))
          {
            v17 = CFGetTypeID(*v16);
            TypeID = CFStringGetTypeID();
            v19 = (const __CFArray *)*v16;
            if (v17 == TypeID)
            {
              CFArrayAppendValue(a1, *v16);
            }
            else
            {
              v21.length = CFArrayGetCount((CFArrayRef)*v16);
              v21.location = 0;
              CFArrayAppendArray(a1, v19, v21);
            }
          }
          if (*a4)
            v20 = 1;
          else
            v20 = v14 == 0;
          --v14;
          ++v16;
          ++v15;
        }
        while (!v20);
      }
      free(v11);
LABEL_19:
      free(v13);
      return;
    }
    if (v11)
      free(v11);
    if (v13)
      goto LABEL_19;
  }
}

void OUTLINED_FUNCTION_0_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

uint64_t __CFCharacterSetIsMutable(uint64_t a1)
{
  char v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

BOOL _CFCharacterSetIsValidRange(unint64_t a1, uint64_t a2)
{
  return a1 >> 16 <= 0x10 && a2 < 1114113 && a1 + a2 < 0x110001;
}

void __CFCharacterSetEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;
  char v8;
  char v9;
  char v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned __int8 v15;
  unsigned __int8 v16;
  char v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  char v23;
  char v24;
  char v25;
  char v26;
  char v27;
  uint64_t v28;
  int v29;
  int v30;
  unsigned int v31;
  char v32;
  int8x16_t *v33;
  char v34;
  uint64_t v35;
  char v36;
  unint64_t v37;
  int v38;
  int v39;
  int v40;
  int v41;
  unsigned __int16 v42;
  unsigned __int16 v43;
  BOOL v44;
  BOOL v45;
  BOOL v46;
  char v47;
  unint64_t v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  int BitmapForPlane;
  unsigned int v53;
  unsigned int v54;
  uint64_t k;
  uint64_t m;
  __int32 v58;
  unsigned int v59;
  unint64_t v60;
  int v61;
  char v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  int8x16_t *v66;
  uint64_t v67;
  unsigned int v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  unsigned int v73;
  unint64_t v74;
  unsigned __int16 v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char v80;
  unsigned __int16 v81;
  BOOL v82;
  char v83;
  BOOL v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char v90;
  int8x16_t *v91;
  char v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96;
  unsigned int v97;
  char v98;
  uint64_t v99;
  char v100;
  uint64_t v101;
  int8x16_t *v102;
  int8x16_t *v103;
  char v104;
  char v105;
  uint64_t v106;
  int v107;
  int v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  unsigned __int8 v114;
  int v115;
  uint64_t v116;
  uint64_t v117;
  char v118;
  uint64_t v119;
  int8x16_t *v120;
  uint64_t v121;
  char v122;
  char v123;
  int8x16_t *v124;
  uint64_t v125;
  uint64_t v126;
  char v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t i;
  __int32 v133;
  uint64_t j;
  uint64_t v136;
  unsigned int v137;
  unsigned int v138;
  uint64_t v139;
  BOOL v140;
  char v141;
  char v142;
  char v143;
  int8x16_t __b[512];
  int8x16_t v145[512];
  uint64_t v146;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v4 = v3;
  v5 = v2;
  v146 = *MEMORY[0x1E0C80C00];
  v6 = atomic_load((unint64_t *)(v2 + 8));
  v7 = atomic_load((unint64_t *)(v3 + 8));
  v8 = atomic_load((unint64_t *)(v2 + 8));
  if ((v8 & 4) != 0)
  {
    v9 = atomic_load((unint64_t *)(v3 + 8));
    if ((v9 & 4) != 0 && *(_QWORD *)(v2 + 16) != *(_QWORD *)(v3 + 16))
      return;
  }
  v10 = v7 ^ v6;
  v11 = *(_QWORD *)(v2 + 40);
  if (!v11 || !*(_DWORD *)(v11 + 8) && !*(_BYTE *)(v11 + 13))
  {
    v12 = atomic_load((unint64_t *)(v2 + 8));
    switch((v12 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*(_QWORD *)(v2 + 32))
          goto LABEL_19;
        break;
      case 3u:
      case 4u:
        if (*(_QWORD *)(v2 + 24))
          goto LABEL_19;
        break;
      default:
        goto LABEL_19;
    }
    v13 = *(_QWORD *)(v3 + 40);
    if (!v13 || !*(_DWORD *)(v13 + 8) && !*(_BYTE *)(v13 + 13))
    {
      v14 = atomic_load((unint64_t *)(v3 + 8));
      switch((v14 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(_QWORD *)(v3 + 32))
            goto LABEL_19;
          break;
        case 3u:
        case 4u:
          if (*(_QWORD *)(v3 + 24))
            goto LABEL_19;
          break;
        default:
          goto LABEL_19;
      }
      if ((v10 & 8) != 0)
        return;
    }
  }
LABEL_19:
  v15 = atomic_load((unint64_t *)(v2 + 8));
  v16 = atomic_load((unint64_t *)(v3 + 8));
  if (((v16 ^ v15) & 0x70) == 0)
  {
    v17 = atomic_load((unint64_t *)(v2 + 8));
    if ((v17 & 0x70) != 0x40)
    {
      v20 = atomic_load((unint64_t *)(v2 + 8));
      switch((v20 >> 4) & 7)
      {
        case 0u:
        case 1u:
          return;
        case 2u:
          if ((v10 & 8) == 0)
          {
            v109 = *(_QWORD *)(v2 + 32);
            if (*(_QWORD *)(v3 + 32) == v109 && !memcmp(*(const void **)(v2 + 24), *(const void **)(v3 + 24), 2 * v109))
              goto LABEL_205;
          }
          break;
        case 3u:
          if (__CFCSetIsEqualBitmap(*(_QWORD *)(v2 + 24), *(_QWORD *)(v3 + 24)))
            goto LABEL_205;
          break;
        default:
LABEL_205:
          __CFCSetIsEqualAnnex(v5, v4);
          break;
      }
      return;
    }
  }
  v18 = *(_QWORD *)(v2 + 40);
  if (!v18 || !*(_DWORD *)(v18 + 8) && !*(_BYTE *)(v18 + 13))
  {
    v19 = atomic_load((unint64_t *)(v2 + 8));
    switch((v19 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*(_QWORD *)(v2 + 32))
          goto LABEL_29;
        break;
      case 3u:
      case 4u:
        if (*(_QWORD *)(v2 + 24))
          goto LABEL_29;
        break;
      default:
        goto LABEL_29;
    }
LABEL_109:
    v67 = *(_QWORD *)(v2 + 40);
    if (v67 && (*(_DWORD *)(v67 + 8) || *(_BYTE *)(v67 + 13)))
    {
LABEL_189:
      v69 = 0;
    }
    else
    {
      v68 = atomic_load((unint64_t *)(v2 + 8));
      switch((v68 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (*(_QWORD *)(v2 + 32))
            goto LABEL_189;
          break;
        case 3u:
        case 4u:
          if (*(_QWORD *)(v2 + 24))
            goto LABEL_189;
          break;
        default:
          goto LABEL_189;
      }
      v69 = 1;
    }
    if (v3 == v2)
      v69 = 1;
    if (v69)
      v5 = v3;
    v104 = atomic_load((unint64_t *)(v5 + 8));
    if ((v104 & 0x70) == 0)
      return;
    v105 = atomic_load((unint64_t *)(v5 + 8));
    if ((v105 & 0x70) == 0x10)
      return;
    v106 = *(_QWORD *)(v5 + 40);
    if (v106)
    {
      v107 = *(unsigned __int8 *)(v106 + 13);
      v108 = *(_DWORD *)(v106 + 8);
      if (v107)
      {
        if (v108 != 131070)
          return;
      }
      else if (v108)
      {
        return;
      }
    }
    v123 = atomic_load((unint64_t *)(v5 + 8));
    if ((v123 & 0x70) == 0x30)
    {
      v124 = *(int8x16_t **)(v5 + 24);
      if (!v124)
      {
LABEL_243:
        v125 = *(_QWORD *)(v5 + 40);
        if (v125 && *(_BYTE *)(v125 + 13))
        {
          v126 = 1;
          while (1)
          {
            v127 = atomic_load((unint64_t *)(v5 + 8));
            if ((v127 & 0x70) == 0x30)
            {
              v128 = *(_QWORD *)(v5 + 40);
              if (v128)
              {
                if (*(_BYTE *)(v128 + 13))
                  v129 = 0;
                else
                  v129 = -1;
              }
              else
              {
                v129 = -1;
              }
              if (!__CFCSetIsEqualBitmap(v129, (uint64_t)v145))
                return;
            }
            else
            {
              if (!(_BYTE)v126)
              {
                __break(1u);
                return;
              }
              v130 = *(_QWORD *)(v5 + 40);
              if (v130
                && ((*(_DWORD *)(v130 + 8) >> v126) & 1) != 0
                && *(unsigned __int8 *)(v130 + 12) >= v126)
              {
                v131 = *(_QWORD *)(*(_QWORD *)v130 + 8 * (v126 - 1));
              }
              else
              {
                v131 = 0;
              }
              __CFCSetGetBitmap(v131, v145);
              if (v145 != (int8x16_t *)-1)
              {
                for (i = 0; i != 2048; ++i)
                {
                  v133 = v145[0].i32[i];
                  if (v133 != -1)
                    return;
                }
              }
            }
            if (++v126 == 16)
              return;
          }
        }
        return;
      }
    }
    else
    {
      v124 = v145;
      __CFCSetGetBitmap(v5, v145);
    }
    if (v124 == (int8x16_t *)-1)
      return;
    for (j = 0; j != 2048; ++j)
    {
      if (v124->i32[j])
        return;
    }
    goto LABEL_243;
  }
LABEL_29:
  v21 = *(_QWORD *)(v3 + 40);
  if (!v21 || !*(_DWORD *)(v21 + 8) && !*(_BYTE *)(v21 + 13))
  {
    v22 = atomic_load((unint64_t *)(v3 + 8));
    switch((v22 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (*(_QWORD *)(v3 + 32))
          break;
        goto LABEL_109;
      case 3u:
      case 4u:
        if (!*(_QWORD *)(v3 + 24))
          goto LABEL_109;
        break;
      default:
        break;
    }
  }
  v23 = atomic_load((unint64_t *)(v2 + 8));
  if ((v23 & 0x70) != 0)
  {
    v24 = atomic_load((unint64_t *)(v3 + 8));
    if ((v24 & 0x70) != 0)
    {
      v25 = atomic_load((unint64_t *)(v2 + 8));
      if ((v25 & 0x70) == 0x10 || (v26 = atomic_load((unint64_t *)(v3 + 8)), (v26 & 0x70) == 0x10))
      {
        v27 = atomic_load((unint64_t *)(v2 + 8));
        if ((v27 & 0x70) == 0x10)
          v28 = v2;
        else
          v28 = v3;
        if (v28 == v2)
          v5 = v3;
        v29 = *(_DWORD *)(v28 + 24);
        v30 = v29 + *(_DWORD *)(v28 + 32);
        v31 = atomic_load((unint64_t *)(v28 + 8));
        v32 = atomic_load((unint64_t *)(v5 + 8));
        if ((v32 & 0x70) == 0x30)
        {
          v33 = *(int8x16_t **)(v5 + 24);
        }
        else
        {
          v33 = v145;
          __CFCSetGetBitmap(v5, v145);
        }
        v70 = (v31 >> 3) & 1;
        v71 = v30 - 1;
        if ((v29 & 0xFF0000) != 0)
        {
          if (v70)
            v72 = -1;
          else
            v72 = 0;
          if (!__CFCSetIsEqualBitmap((uint64_t)v33, v72))
            return;
          v73 = (unsigned __int16)v29;
          v74 = BYTE2(v29);
        }
        else
        {
          if ((v71 & 0xFF0000) != 0)
            v75 = -1;
          else
            v75 = v30 - 1;
          if (!__CFCSetIsBitmapEqualToRange((uint64_t)v33, (unsigned __int16)v29, v75, v70))
            return;
          v73 = 0;
          v74 = 1;
        }
        v76 = (unsigned __int16)(v30 - 1);
        v77 = *(_QWORD *)(v5 + 40);
        if (v77)
          LODWORD(v77) = *(unsigned __int8 *)(v77 + 13) != 0;
        v78 = 0;
        v79 = ((v31 & 8) == 0) ^ v77;
        v139 = v79 ^ 1;
        v138 = v73;
        if (v73)
          v80 = 1;
        else
          v80 = ((v31 & 8) == 0) ^ v77;
        if (v74 == BYTE2(v71))
          v81 = v30 - 1;
        else
          v81 = -1;
        v82 = v76 == 0xFFFF;
        if (v76 == 0xFFFF)
          v83 = ((v31 & 8) == 0) ^ v77;
        else
          v83 = 1;
        v143 = v83;
        v84 = !v82 && v74 == BYTE2(v71);
        v141 = v80 | v84;
        v85 = v74 - 1;
        v86 = BYTE2(v71) - 1;
        v137 = v81;
        while (1)
        {
          v87 = v78 + 1;
          v88 = *(_QWORD *)(v5 + 40);
          if (v88
            && ((*(_DWORD *)(v88 + 8) >> v87) & 1) != 0
            && *(unsigned __int8 *)(v88 + 12) >= v87
            && (v89 = *(_QWORD *)(*(_QWORD *)v88 + 8 * v78)) != 0)
          {
            v90 = atomic_load((unint64_t *)(v89 + 8));
            if ((v90 & 0x70) == 0x30)
            {
              v91 = *(int8x16_t **)(v89 + 24);
            }
            else
            {
              v91 = v145;
              __CFCSetGetBitmap(v89, v145);
            }
            if (v87 < v74 || v87 > BYTE2(v71))
            {
              v93 = (uint64_t)v91;
              v94 = v139 << 63 >> 63;
LABEL_173:
              if (!__CFCSetIsEqualBitmap(v93, v94))
                return;
              goto LABEL_157;
            }
            if (v87 > v74 && v87 < BYTE2(v71))
            {
              v93 = (uint64_t)v91;
              v94 = v79 << 63 >> 63;
              goto LABEL_173;
            }
            if (v85 == v78)
            {
              v95 = (uint64_t)v91;
              v97 = v137;
              v96 = v138;
            }
            else
            {
              if (v86 != v78)
                goto LABEL_157;
              v97 = (unsigned __int16)v71;
              v95 = (uint64_t)v91;
              v96 = 0;
            }
            if (!__CFCSetIsBitmapEqualToRange(v95, v96, v97, v139))
              return;
          }
          else if (v87 < v74 || v87 > BYTE2(v71))
          {
            if ((v79 & 1) == 0)
              return;
          }
          else if (v87 <= v74 || v87 >= BYTE2(v71))
          {
            if (v85 == v78)
            {
              if ((v141 & 1) != 0)
                return;
            }
            else
            {
              v92 = v143;
              if (v86 != v78)
                v92 = 0;
              if ((v92 & 1) != 0)
                return;
            }
          }
          else if ((v79 & 1) != 0)
          {
            return;
          }
LABEL_157:
          if (++v78 == 15)
            return;
        }
      }
      v98 = atomic_load((unint64_t *)(v2 + 8));
      v99 = v98 & 0x70;
      v100 = atomic_load((unint64_t *)(v3 + 8));
      v101 = v100 & 0x70;
      if (v99 == 48 && v101 == 48)
      {
        v102 = *(int8x16_t **)(v2 + 24);
        v103 = *(int8x16_t **)(v3 + 24);
      }
      else
      {
        if (v99 == 48 || v101 == 48)
        {
          if (v101 == 48)
            v136 = v2;
          else
            v136 = v3;
          if (v101 == 48)
            v5 = v3;
          __CFCSetGetBitmap(v136, v145);
          if (!__CFCSetIsEqualBitmap(*(_QWORD *)(v5 + 24), (uint64_t)v145))
            return;
          v4 = v136;
LABEL_279:
          __CFCSetIsEqualAnnex(v5, v4);
          return;
        }
        __CFCSetGetBitmap(v2, v145);
        __CFCSetGetBitmap(v4, __b);
        v102 = v145;
        v103 = __b;
      }
      if (!__CFCSetIsEqualBitmap((uint64_t)v102, (uint64_t)v103))
        return;
      goto LABEL_279;
    }
  }
  v34 = atomic_load((unint64_t *)(v2 + 8));
  if ((v34 & 0x70) != 0)
    v35 = v3;
  else
    v35 = v2;
  if (v35 == v2)
    v5 = v3;
  v36 = atomic_load((unint64_t *)(v5 + 8));
  if ((v36 & 0x70) == 0x10)
  {
    v37 = 0;
    v38 = *(_DWORD *)(v5 + 24);
    v39 = v38 + *(_DWORD *)(v5 + 32);
    v40 = -v39;
    v41 = v39 - 1;
    if (BYTE2(v38) != BYTE2(v41))
      v42 = 0;
    else
      v42 = v38;
    if (BYTE2(*(_DWORD *)(v5 + 24)) != BYTE2(v41))
      v43 = -1;
    else
      v43 = v41;
    if ((_WORD)v38)
      v44 = BYTE2(*(_DWORD *)(v5 + 24)) == BYTE2(v41);
    else
      v44 = 0;
    v45 = (unsigned __int16)v40 == 0;
    if ((_WORD)v40)
      v46 = BYTE2(*(_DWORD *)(v5 + 24)) == BYTE2(v41);
    else
      v46 = 0;
    v47 = !v45 || v44;
    v48 = BYTE2(v41);
    if ((_WORD)v38)
      v46 = 1;
    v140 = v46;
    v142 = v47;
    v49 = v43;
    v50 = v42;
    v51 = (unsigned __int16)v41;
    while (1)
    {
      BitmapForPlane = CFUniCharGetBitmapForPlane(*(_DWORD *)(v35 + 24), v37, v145, (v10 & 8) == 0);
      if (v37 < BYTE2(v38) || v37 > v48)
      {
        if (BitmapForPlane)
        {
          if (BitmapForPlane == 1)
            return;
        }
        else
        {
          if (v145 == (int8x16_t *)-1)
            return;
          for (k = 0; k != 2048; ++k)
          {
            if (v145[0].i32[k])
              return;
          }
        }
      }
      else if (v37 <= BYTE2(v38) || v37 >= v48)
      {
        if (BitmapForPlane == 1)
        {
          if (v37 == BYTE2(v38))
          {
            if (v140)
              return;
          }
          else if ((v142 & 1) != 0)
          {
            return;
          }
        }
        else
        {
          if (BitmapForPlane == 255)
            return;
          if (v37 == BYTE2(v38))
          {
            v53 = (unsigned __int16)v38;
            v54 = v49;
          }
          else
          {
            v53 = v50;
            v54 = v51;
          }
          if (!__CFCSetIsBitmapEqualToRange((uint64_t)v145, v53, v54, 0))
            return;
        }
      }
      else if (BitmapForPlane)
      {
        if (BitmapForPlane == 255)
          return;
      }
      else if (v145 != (int8x16_t *)-1)
      {
        for (m = 0; m != 2048; ++m)
        {
          v58 = v145[0].i32[m];
          if (v58 != -1)
            return;
        }
      }
      if (++v37 == 16)
        return;
    }
  }
  v59 = *(_DWORD *)(v35 + 24);
  v60 = atomic_load((unint64_t *)(v35 + 8));
  v61 = CFUniCharGetBitmapForPlane(v59, 0, v145, (v60 >> 3) & 1);
  v62 = atomic_load((unint64_t *)(v5 + 8));
  v63 = v62 & 0x70;
  if (v61)
  {
    v64 = v61;
    if (v63 == 48)
    {
      if (v61 == 1)
        v65 = -1;
      else
        v65 = 0;
      v66 = *(int8x16_t **)(v5 + 24);
    }
    else
    {
      __CFCSetGetBitmap(v5, v145);
      if (v64 == 1)
        v65 = -1;
      else
        v65 = 0;
      v66 = v145;
    }
  }
  else if (v63 == 48)
  {
    v66 = *(int8x16_t **)(v5 + 24);
    v65 = (uint64_t)v145;
  }
  else
  {
    __CFCSetGetBitmap(v5, __b);
    v65 = (uint64_t)v145;
    v66 = __b;
  }
  if (__CFCSetIsEqualBitmap(v65, (uint64_t)v66))
  {
    v110 = atomic_load((unint64_t *)(v35 + 8));
    v111 = *(_QWORD *)(v5 + 40);
    if (v111)
      LODWORD(v111) = *(unsigned __int8 *)(v111 + 13) != 0;
    v112 = 0;
    v113 = (v110 >> 3) & 1 ^ v111;
    do
    {
      v114 = v112 + 1;
      v115 = CFUniCharGetBitmapForPlane(*(_DWORD *)(v35 + 24), (int)v112 + 1, v145, v113);
      v116 = *(_QWORD *)(v5 + 40);
      if (v116 && ((*(_DWORD *)(v116 + 8) >> v114) & 1) != 0 && *(unsigned __int8 *)(v116 + 12) >= v114)
      {
        v117 = *(_QWORD *)(*(_QWORD *)v116 + 8 * v112);
        if (!v115)
        {
LABEL_224:
          if (!v117)
            return;
          v122 = atomic_load((unint64_t *)(v117 + 8));
          if ((v122 & 0x70) == 0x30)
          {
            v120 = *(int8x16_t **)(v117 + 24);
            v121 = (uint64_t)v145;
          }
          else
          {
            __CFCSetGetBitmap(v117, __b);
            v121 = (uint64_t)v145;
            v120 = __b;
          }
LABEL_232:
          if (!__CFCSetIsEqualBitmap(v121, (uint64_t)v120))
            return;
          goto LABEL_233;
        }
      }
      else
      {
        v117 = 0;
        if (!v115)
          goto LABEL_224;
      }
      if (v117)
      {
        v118 = atomic_load((unint64_t *)(v117 + 8));
        if ((v118 & 0x70) == 0x30)
        {
          if (v115 == 1)
            v119 = -1;
          else
            v119 = 0;
          v120 = *(int8x16_t **)(v117 + 24);
          v121 = v119;
        }
        else
        {
          __CFCSetGetBitmap(v117, v145);
          if (v115 == 1)
            v121 = -1;
          else
            v121 = 0;
          v120 = v145;
        }
        goto LABEL_232;
      }
      if (v115 == 1)
        return;
LABEL_233:
      ++v112;
    }
    while (v112 != 15);
  }
}

unint64_t __CFCharacterSetHash(uint64_t a1, uint64_t a2)
{
  unint64_t *v2;
  unint64_t *v3;
  unint64_t *v4;
  char v5;
  unint64_t v6;
  unsigned int v7;
  char v8;
  int8x16_t *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  int v14;
  int8x16_t __b[512];
  uint64_t v16;

  v2 = (unint64_t *)MEMORY[0x1E0C80A78](a1, a2);
  v3 = v2;
  v16 = *MEMORY[0x1E0C80C00];
  v4 = v2 + 1;
  v5 = atomic_load(v2 + 1);
  if ((v5 & 4) == 0)
  {
    v6 = v2[5];
    if (v6 && (*(_DWORD *)(v6 + 8) || *(_BYTE *)(v6 + 13)))
    {
LABEL_7:
      v8 = atomic_load(v2 + 1);
      if ((v8 & 0x70) == 0x30)
      {
        v9 = (int8x16_t *)v2[3];
      }
      else
      {
        __CFCSetGetBitmap((uint64_t)v2, __b);
        v9 = __b;
      }
      v3[2] = CFHashBytes((uint64_t)v9, 0x2000);
    }
    else
    {
      v7 = atomic_load(v4);
      switch((v7 >> 4) & 7)
      {
        case 1u:
        case 2u:
          if (v2[4])
            goto LABEL_7;
          break;
        case 3u:
        case 4u:
          if (v2[3])
            goto LABEL_7;
          break;
        default:
          goto LABEL_7;
      }
      v14 = atomic_load(v2 + 1);
      v2[2] = (v14 << 28 >> 31);
    }
    v10 = atomic_load(v4);
    while (1)
    {
      v11 = __ldaxr(v4);
      if (v11 != v10)
        break;
      if (__stlxr(v10 | 4, v4))
        goto LABEL_16;
      v12 = 1;
LABEL_17:
      v10 = v11;
      if (v12)
        return v3[2];
    }
    __clrex();
LABEL_16:
    v12 = 0;
    goto LABEL_17;
  }
  return v3[2];
}

CFStringRef __CFCharacterSetCopyDescription(unint64_t *cf)
{
  unint64_t v2;
  unsigned int v3;
  unsigned int v4;
  const __CFString *v5;
  CFStringRef result;
  char v7;
  __CFString *Mutable;
  const __CFAllocator *v9;
  uint64_t v10;
  const __CFAllocator *v11;
  CFIndex Length;
  uint64_t i;
  const char *v14;

  v2 = cf[5];
  if (v2 && (*(_DWORD *)(v2 + 8) || *(_BYTE *)(v2 + 13)))
  {
LABEL_6:
    v4 = atomic_load(cf + 1);
    switch((v4 >> 4) & 7)
    {
      case 0u:
        switch(cf[3])
        {
          case 1uLL:
            v5 = CFSTR("<CFCharacterSet Predefined Control Set>");
            return (CFStringRef)CFRetain(v5);
          case 2uLL:
            v5 = CFSTR("<CFCharacterSet Predefined Whitespace Set>");
            return (CFStringRef)CFRetain(v5);
          case 3uLL:
            v5 = CFSTR("<CFCharacterSet Predefined WhitespaceAndNewline Set>");
            return (CFStringRef)CFRetain(v5);
          case 4uLL:
            v5 = CFSTR("<CFCharacterSet Predefined DecimalDigit Set>");
            return (CFStringRef)CFRetain(v5);
          case 5uLL:
            v5 = CFSTR("<CFCharacterSet Predefined Letter Set>");
            return (CFStringRef)CFRetain(v5);
          case 6uLL:
            v5 = CFSTR("<CFCharacterSet Predefined LowercaseLetter Set>");
            return (CFStringRef)CFRetain(v5);
          case 7uLL:
            v5 = CFSTR("<CFCharacterSet Predefined UppercaseLetter Set>");
            return (CFStringRef)CFRetain(v5);
          case 8uLL:
            v5 = CFSTR("<CFCharacterSet Predefined NonBase Set>");
            return (CFStringRef)CFRetain(v5);
          case 9uLL:
            v5 = CFSTR("<CFCharacterSet Predefined Decomposable Set>");
            return (CFStringRef)CFRetain(v5);
          case 0xAuLL:
            v5 = CFSTR("<CFCharacterSet Predefined AlphaNumeric Set>");
            return (CFStringRef)CFRetain(v5);
          case 0xBuLL:
            v5 = CFSTR("<CFCharacterSet Predefined Punctuation Set>");
            return (CFStringRef)CFRetain(v5);
          case 0xCuLL:
            v5 = CFSTR("<CFCharacterSet Predefined Illegal Set>");
            return (CFStringRef)CFRetain(v5);
          case 0xDuLL:
            v5 = CFSTR("<CFCharacterSet Predefined CapitalizedLetter Set>");
            return (CFStringRef)CFRetain(v5);
          case 0xEuLL:
            v5 = CFSTR("<CFCharacterSet Predefined Symbol Set>");
            return (CFStringRef)CFRetain(v5);
          case 0xFuLL:
            v5 = CFSTR("<CFCharacterSet Predefined Newline Set>");
            return (CFStringRef)CFRetain(v5);
          default:
            goto LABEL_14;
        }
      case 1u:
        v9 = CFGetAllocator(cf);
        return CFStringCreateWithFormat(v9, 0, CFSTR("<CFCharacterSet Range(%u, %ld)>"), *((unsigned int *)cf + 6), cf[4]);
      case 2u:
        v10 = cf[4];
        v11 = CFGetAllocator(cf);
        Length = CFStringGetLength(CFSTR("<CFCharacterSet Items("));
        Mutable = CFStringCreateMutable(v11, Length - v10 + 8 * v10 + 2);
        CFStringAppend(Mutable, CFSTR("<CFCharacterSet Items("));
        if (v10 >= 1)
        {
          for (i = 0; i != v10; ++i)
          {
            if (i)
              v14 = " ";
            else
              v14 = "";
            CFStringAppendFormat(Mutable, 0, CFSTR("%sU+%04X"), v14, *(unsigned __int16 *)(cf[3] + 2 * i));
          }
        }
        CFStringAppend(Mutable, CFSTR(")>"));
        goto LABEL_23;
      case 3u:
      case 4u:
        v5 = CFSTR("<CFCharacterSet Bitmap>");
        return (CFStringRef)CFRetain(v5);
      default:
LABEL_14:
        Mutable = 0;
LABEL_23:
        result = Mutable;
        break;
    }
  }
  else
  {
    v3 = atomic_load(cf + 1);
    switch((v3 >> 4) & 7)
    {
      case 1u:
      case 2u:
        if (cf[4])
          goto LABEL_6;
        break;
      case 3u:
      case 4u:
        if (cf[3])
          goto LABEL_6;
        break;
      default:
        goto LABEL_6;
    }
    v7 = atomic_load(cf + 1);
    if ((v7 & 8) != 0)
      v5 = CFSTR("<CFCharacterSet All>");
    else
      v5 = CFSTR("<CFCharacterSet Empty>");
    return (CFStringRef)CFRetain(v5);
  }
  return result;
}

unint64_t *_CFCharacterSetCreateCopy(const __CFAllocator *a1, unint64_t *a2)
{
  return __CFCharacterSetCreateCopy(a1, a2, 0, 0);
}

unint64_t *_CFCharacterSetCreateMutableCopy(const __CFAllocator *a1, uint64_t a2)
{
  unint64_t *Mutable;

  Mutable = (unint64_t *)CFCharacterSetCreateMutable(a1);
  _CFCharacterSetInitCopyingSet((char *)a1, Mutable, a2, 1);
  return Mutable;
}

uint64_t CFCharacterSetIsSurrogatePairMember(const __CFCharacterSet *a1, int a2, int a3)
{
  return CFCharacterSetIsLongCharacterMember(a1, a3 + (a2 << 10) - 56613888);
}

uint64_t __CFCSetIsEqualBitmap(uint64_t a1, uint64_t a2)
{
  uint64_t k;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t m;
  uint64_t i;
  int v9;
  uint64_t j;
  int v11;

  if (a1 != a2)
  {
    if (a1 && a2)
    {
      if (a1 == -1)
      {
        for (i = 0; i != 0x2000; i += 4)
        {
          v9 = *(_DWORD *)(a2 + i);
          if (v9 != -1)
            return 0;
        }
      }
      else if (a2 == -1)
      {
        for (j = 0; j != 0x2000; j += 4)
        {
          v11 = *(_DWORD *)(a1 + j);
          if (v11 != -1)
            return 0;
        }
      }
      else
      {
        for (k = 0; k != 0x2000; k += 4)
        {
          v3 = *(_DWORD *)(a1 + k);
          v4 = *(_DWORD *)(a2 + k);
          if (v3 != v4)
            return 0;
        }
      }
    }
    else if (a1 | a2)
    {
      if (a2)
        v5 = a2;
      else
        v5 = a1;
      if (v5 == -1)
        return 0;
      for (m = 0; m != 0x2000; m += 4)
      {
        if (*(_DWORD *)(v5 + m))
          return 0;
      }
    }
  }
  return 1;
}

Boolean CFCharacterSetHasMemberInPlane(CFCharacterSetRef theSet, CFIndex thePlane)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unint64_t v10;
  char v11;
  char v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  BOOL v18;
  uint64_t v19;
  _QWORD *v20;
  char v21;
  uint64_t v22;
  unint64_t v23;
  BOOL v24;
  unsigned int v26;
  int v27;
  BOOL v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  __int32 v33;
  uint64_t v35;
  int8x16_t __b[512];
  uint64_t v37;

  v2 = MEMORY[0x1E0C80A78](theSet, thePlane);
  v37 = *MEMORY[0x1E0C80C00];
  v4 = atomic_load((unint64_t *)(v2 + 8));
  if (v3 > 0x10)
    goto LABEL_2;
  v6 = v3;
  v7 = v2;
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)v2))
  {
    LOBYTE(v5) = objc_msgSend((id)v7, "hasMemberInPlane:", v6);
    return v5;
  }
  v5 = (v4 >> 3) & 1;
  v8 = *(_QWORD *)(v7 + 40);
  if (v8 && (*(_DWORD *)(v8 + 8) || *(_BYTE *)(v8 + 13)))
  {
LABEL_13:
    v10 = v4 & 8;
    v11 = atomic_load((unint64_t *)(v7 + 8));
    if ((v11 & 0x70) != 0)
    {
      v12 = atomic_load((unint64_t *)(v7 + 8));
      if ((v12 & 0x70) == 0x10)
      {
        v13 = v10 >> 3;
        v14 = *(unsigned int *)(v7 + 24);
        v15 = v14 >> 16;
        v16 = (v14 + *(_DWORD *)(v7 + 32) - 1) >> 16;
        if (!(_DWORD)v13)
        {
          LOBYTE(v5) = v15 <= v6 && v16 >= v6;
          return v5;
        }
        LOBYTE(v5) = 1;
        if (v15 > v6 || v16 < v6)
          return v5;
        if (v15 >= v6 || v16 <= v6)
        {
          v17 = (unsigned __int16)(v14 + *(_WORD *)(v7 + 32) - 1);
          if (v15 == v6)
          {
            if (!(unsigned __int16)*(_DWORD *)(v7 + 24))
            {
              v18 = (_DWORD)v15 != (_DWORD)v16 || v17 == 0xFFFF;
              goto LABEL_65;
            }
LABEL_88:
            LOBYTE(v5) = 1;
            return v5;
          }
          if (v17 != 0xFFFF)
            goto LABEL_88;
          if ((unsigned __int16)*(_DWORD *)(v7 + 24))
            v28 = (_DWORD)v15 == (_DWORD)v16;
          else
            v28 = 0;
LABEL_74:
          LOBYTE(v5) = v28;
          return v5;
        }
        goto LABEL_2;
      }
      if (v6)
      {
        v19 = *(_QWORD *)(v7 + 40);
        if (!v19)
          goto LABEL_2;
        if (((*(_DWORD *)(v19 + 8) >> v6) & 1) != 0
          && *(unsigned __int8 *)(v19 + 12) >= v6
          && (v20 = *(_QWORD **)(*(_QWORD *)v19 + 8 * (v6 - 1))) != 0)
        {
          v21 = atomic_load(v20 + 1);
          if ((v21 & 0x70) != 0x10)
          {
            v29 = atomic_load(v20 + 1);
            if ((v29 & 0x70) == 0x30)
            {
              v30 = *(_QWORD *)(v7 + 40);
              if (!v30 || !*(_BYTE *)(v30 + 13))
                goto LABEL_88;
              v28 = __CFCSetIsEqualBitmap(v20[3], -1) == 0;
              goto LABEL_74;
            }
            __CFCSetGetBitmap((uint64_t)v20, __b);
            v31 = *(_QWORD *)(v7 + 40);
            if (!v31 || !*(_BYTE *)(v31 + 13))
              goto LABEL_88;
            if (&v35 != (uint64_t *)-9)
            {
              v32 = 0;
              do
              {
                LOBYTE(v5) = v32 != 2048;
                if (v32 == 2048)
                  break;
                v33 = __b[0].i32[v32++];
              }
              while (v33 == -1);
              return v5;
            }
LABEL_2:
            LOBYTE(v5) = 0;
            return v5;
          }
          v22 = *(_QWORD *)(v7 + 40);
          if (!v22 || !*(_BYTE *)(v22 + 13) || *((_DWORD *)v20 + 6))
            goto LABEL_88;
          v18 = v20[4] == 0x10000;
        }
        else
        {
          v18 = *(_BYTE *)(v19 + 13) == 0;
        }
      }
      else
      {
        v26 = atomic_load((unint64_t *)(v7 + 8));
        v27 = (v26 >> 4) & 7;
        if (v27 != 4 && v27 != 3)
        {
          if (v27 == 2 && !*(_QWORD *)(v7 + 32))
            return v5;
          goto LABEL_88;
        }
        v18 = *(_QWORD *)(v7 + 24) == 0;
      }
    }
    else
    {
      v5 = *(_QWORD *)(v7 + 24);
      if (v5 == 1)
      {
        if (v6 == 14 || (v4 & 8) != 0)
          return v5;
        LODWORD(v5) = 1;
      }
      else
      {
        if (v5 < 4 || v5 == 15)
        {
          if (v6)
            v18 = v10 == 0;
          else
            v18 = 0;
          goto LABEL_65;
        }
        v23 = v10 >> 3;
        if (v5 == 12)
        {
          if ((_DWORD)v23)
            v24 = v6 - 14 >= 0xFFFFFFFFFFFFFFF5;
          else
            v24 = 0;
          LOBYTE(v5) = !v24;
          return v5;
        }
        if ((_DWORD)v23)
          goto LABEL_88;
      }
      v18 = CFUniCharGetBitmapPtrForPlane(v5, v6) == 0;
    }
LABEL_65:
    LOBYTE(v5) = !v18;
    return v5;
  }
  v9 = atomic_load((unint64_t *)(v7 + 8));
  switch((v9 >> 4) & 7)
  {
    case 1u:
    case 2u:
      if (*(_QWORD *)(v7 + 32))
        goto LABEL_13;
      break;
    case 3u:
    case 4u:
      if (*(_QWORD *)(v7 + 24))
        goto LABEL_13;
      break;
    default:
      goto LABEL_13;
  }
  return v5;
}

CFDataRef CFCharacterSetCreateBitmapRepresentation(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  uint64_t v5;
  int v6;
  _BOOL4 v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  CFIndex v12;
  __CFData *Mutable;
  int8x16_t *MutableBytePtr;
  UInt8 *v15;
  uint64_t v16;
  int8x16_t *v17;
  uint64_t v18;
  unsigned int v19;
  int32x4_t v20;
  UInt8 *v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t i;
  uint64_t j;
  char v27;
  char v28;
  unsigned int v29;
  unsigned int v30;
  char v31;
  uint64_t v32;
  int v33;
  int v34;
  int8x16_t *v35;
  UInt8 *v36;
  uint64_t v37;
  BOOL v38;
  CFIndex v39;
  int8x16_t *v40;
  int v41;
  UInt8 *v42;
  unint64_t v43;
  uint64_t v44;
  int BitmapForPlane;
  CFIndex v46;
  unsigned int v47;
  int v48;
  unsigned int v49;
  int v50;
  int v51;
  CFIndex v52;
  int8x16_t *v53;
  UInt8 *v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned __int16 v58;
  unsigned int v59;
  char v60;
  unsigned int v61;
  uint64_t v62;
  UInt8 *v63;
  unsigned __int16 v64;
  unsigned __int16 v65;
  char v66;
  uint64_t v67;
  unsigned int v68;
  int v69;
  int8x16_t *v70;
  char *v71;
  uint64_t v72;
  char v73;
  _BYTE *v74;
  uint64_t v75;
  int v76;
  int v77;
  _BYTE *v78;
  unsigned __int16 v79;
  unsigned int v80;
  _BYTE *v81;
  unint64_t v82;
  int v83;
  uint64_t v84;
  int v85;
  unsigned int v86;
  uint64_t v87;
  unsigned int v88;
  int32x4_t v89;
  _BYTE v90[16];
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
    return (CFDataRef)-[__CFCharacterSet _retainedBitmapRepresentation](theSet, "_retainedBitmapRepresentation");
  v5 = *((_QWORD *)theSet + 5);
  if (v5)
  {
    v6 = *(unsigned __int8 *)(v5 + 13);
    v7 = *(_BYTE *)(v5 + 13) != 0;
    v8 = *(_DWORD *)(v5 + 8);
    if (v8)
    {
      v9 = 0;
      v10 = 0;
      do
      {
        v11 = v9 + 1;
        if (v6
          || ((v8 >> (v9 + 1)) & 1) != 0 && v11 <= *(unsigned __int8 *)(v5 + 12) && *(_QWORD *)(*(_QWORD *)v5 + 8 * v9))
        {
          v90[v10++] = v11;
        }
        ++v9;
      }
      while (v9 != 16);
      v12 = 8193 * v10 + 0x2000;
      Mutable = CFDataCreateMutable(alloc, v12);
      CFDataSetLength(Mutable, v12);
      MutableBytePtr = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
      __CFCSetGetBitmap((uint64_t)theSet, MutableBytePtr);
      if (v10 > 0)
      {
        v15 = CFDataGetMutableBytePtr(Mutable);
        v16 = *((_QWORD *)theSet + 5);
        if (v16)
        {
          if (*(_DWORD *)(v16 + 8))
          {
            v17 = (int8x16_t *)v15;
            v18 = 0;
            if (v6)
              v19 = -1;
            else
              v19 = 0;
            v20 = vdupq_n_s32(v19);
            v21 = v15 + 8193;
            v89 = v20;
            do
            {
              v22 = v90[v18];
              v17[512].i8[0] = v22;
              if (!v22)
                __break(1u);
              v17 = (int8x16_t *)((char *)v17 + 8193);
              if (v22 <= 0x10
                && (v23 = *((_QWORD *)theSet + 5)) != 0
                && ((*(_DWORD *)(v23 + 8) >> v22) & 1) != 0
                && *(unsigned __int8 *)(v23 + 12) >= v22
                && (v24 = *(_QWORD *)(*(_QWORD *)v23 + 8 * (v22 - 1))) != 0)
              {
                __CFCSetGetBitmap(v24, v17);
                v20 = v89;
                if (v6)
                {
                  for (i = 0; i != 0x2000; i += 16)
                    *(int8x16_t *)&v21[i] = vmvnq_s8(*(int8x16_t *)&v21[i]);
                }
              }
              else
              {
                for (j = 0; j != 0x2000; j += 16)
                  *(int32x4_t *)&v21[j] = v20;
              }
              ++v18;
              v21 += 8193;
            }
            while (v18 != v10);
          }
        }
      }
      return Mutable;
    }
  }
  else
  {
    v7 = 0;
  }
  v27 = atomic_load((unint64_t *)theSet + 1);
  v28 = atomic_load((unint64_t *)theSet + 1);
  if ((v27 & 0x70) == 0)
  {
    if ((v28 & 8) != 0)
      v34 = 16;
    else
      v34 = CFUniCharGetNumberOfPlanes(*((_DWORD *)theSet + 6)) - 1;
    v39 = 8193 * v34 + 0x2000;
    Mutable = CFDataCreateMutable(alloc, v39);
    CFDataSetLength(Mutable, v39);
    v40 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
    __CFCSetGetBitmap((uint64_t)theSet, v40);
    if (v34 >= 1)
    {
      v41 = 0;
      v42 = CFDataGetMutableBytePtr(Mutable) + 0x2000;
      v43 = atomic_load((unint64_t *)theSet + 1);
      v44 = (v43 >> 3) & 1;
      do
      {
        BitmapForPlane = CFUniCharGetBitmapForPlane(*((_DWORD *)theSet + 6), ++v41, v42 + 1, v44);
        if (BitmapForPlane != 255)
        {
          *v42 = v41;
          if (BitmapForPlane == 1)
            memset(v42 + 1, 255, 0x2000uLL);
          v42 += 8193;
        }
      }
      while (v34 != v41);
      v46 = v42 - CFDataGetBytePtr(Mutable);
      if (v46 < v39)
        CFDataSetLength(Mutable, v46);
    }
    return Mutable;
  }
  if ((v28 & 0x70) == 0x10)
  {
    v29 = *((_DWORD *)theSet + 6);
    v30 = v29 + *((_DWORD *)theSet + 8) - 1;
    v31 = atomic_load((unint64_t *)theSet + 1);
    v32 = v31 & 8;
    if (v30 >= 0x10000)
    {
      v47 = HIWORD(v30);
      v48 = HIWORD(v29);
      if (v29 < 0x10000)
        v48 = 1;
      v49 = v47 - v48;
      if (v29 <= 0x10000)
        LOWORD(v29) = 0;
      if ((_WORD)v29)
        v50 = 16 - v49;
      else
        v50 = 15 - v49;
      if ((_WORD)v30 != 0xFFFF)
        ++v50;
      if ((unsigned __int16)v29 | (unsigned __int16)~(_WORD)v30)
        v51 = 16 - v49;
      else
        v51 = 15 - v49;
      if (v47 != v48)
        v51 = v50;
      if (v32)
        v33 = v51;
      else
        v33 = v49 + 1;
    }
    else
    {
      v33 = 2 * v32;
    }
    v52 = 8193 * v33 + 0x2000;
    Mutable = CFDataCreateMutable(alloc, v52);
    CFDataSetLength(Mutable, v52);
    v53 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
    __CFCSetGetBitmap((uint64_t)theSet, v53);
    if (v33 < 1)
      return Mutable;
    v54 = CFDataGetMutableBytePtr(Mutable);
    v55 = *((_DWORD *)theSet + 6);
    v56 = v55 + *((_DWORD *)theSet + 8) - 1;
    v57 = HIWORD(v56);
    if (v55 <= 0x10000)
      v58 = 0;
    else
      v58 = *((_DWORD *)theSet + 6);
    if (v55 < 0x10000)
      v59 = 1;
    else
      v59 = HIWORD(v55);
    v60 = atomic_load((unint64_t *)theSet + 1);
    if ((v60 & 8) == 0)
    {
      v61 = v57 - v59;
      if (v57 >= v59)
      {
        v62 = 0;
        v63 = v54 + 8194;
        do
        {
          *(v63 - 2) = v59 + v62;
          if ((_DWORD)v62)
            v64 = 0;
          else
            v64 = v58;
          if (v61 == (_DWORD)v62)
            v65 = v56;
          else
            v65 = -1;
          v66 = v64;
          if (v64 == v65)
          {
            v63[(v64 >> 3) - 1] |= 1 << (v64 & 7);
          }
          else
          {
            v67 = v64 >> 3;
            v68 = v65 >> 3;
            v69 = 255 << (v66 & 7);
            if ((_DWORD)v67 == v68)
            {
              v63[v67 - 1] |= (0xFFu >> (~(_BYTE)v65 & 7)) & v69;
            }
            else
            {
              v63[v67 - 1] |= v69;
              v63[(v65 >> 3) - 1] |= 0xFFu >> (~(_BYTE)v65 & 7);
              if ((int)v67 + 1 < v68)
                memset(&v63[v67], 255, v68 - v67 - 2 + 1);
            }
          }
          ++v62;
          v63 += 8193;
        }
        while (v61 + 1 != v62);
      }
      return Mutable;
    }
    v71 = (char *)(v54 + 0x2000);
    if (v59 < 2)
    {
      v73 = 1;
    }
    else
    {
      v72 = 0;
      do
      {
        *v71 = ++v72;
        memset(v71 + 1, 255, 0x2000uLL);
        v71 += 8193;
      }
      while (v59 - 1 != v72);
      v73 = v59;
    }
    if (v57 == v59)
    {
      if (v58 || (unsigned __int16)v56 != 0xFFFF)
      {
        *v71 = v73;
        v74 = v71 + 1;
        memset(v71 + 1, 255, 0x2000uLL);
        v75 = v58 >> 3;
        v76 = (unsigned __int16)v56 >> 3;
        v77 = 255 << (v58 & 7);
        if (v76 == (_DWORD)v75)
        {
          v74[v75] &= ~((0xFFu >> (~(_BYTE)v56 & 7)) & v77);
        }
        else
        {
          v74[v75] &= ~(_BYTE)v77;
          v74[(unsigned __int16)v56 >> 3] &= -256 >> (~(_BYTE)v56 & 7);
          if (((unint64_t)v58 >> 3) + 1 < v76)
            bzero(&v71[(v58 >> 3) + 2], v76 - (v58 >> 3) - 2 + 1);
        }
        v71 += 8193;
      }
      goto LABEL_132;
    }
    if (v57 <= v59)
    {
LABEL_132:
      if (!(v56 >> 20))
      {
        v86 = 15 - v57;
        if (v57 > 0xF)
          v86 = 0;
        v87 = -(uint64_t)(v86 + 1);
        v88 = v57 + 1;
        do
        {
          *v71 = v88;
          memset(v71 + 1, 255, 0x2000uLL);
          v71 += 8193;
          ++v88;
          v38 = __CFADD__(v87++, 1);
        }
        while (!v38);
      }
      return Mutable;
    }
    if (!v58)
    {
LABEL_120:
      if ((unsigned __int16)v56 != 0xFFFF)
      {
        v81 = v71 + 0x2000;
        *v71 = v73;
        bzero(v71 + 1, 0x2000uLL);
        v82 = (unint64_t)(unsigned __int16)v56 >> 3;
        v83 = 255 << (v56 & 7);
        if ((_DWORD)v82 == 0x1FFF)
        {
          *v81 = v83;
        }
        else
        {
          v71[v82 + 1] |= v83;
          *v81 = -1;
          if ((unsigned __int16)v56 >> 4 <= 0xFFEu)
          {
            v38 = v82 <= 0x1FFD;
            v85 = 8189 - v82;
            if (!v38)
              v85 = 0;
            memset(&v71[((unsigned __int16)v56 >> 3) + 2], 255, (v85 + 1));
          }
        }
        v71 += 8193;
      }
      goto LABEL_132;
    }
    *v71 = v73;
    v78 = v71 + 1;
    bzero(v71 + 1, 0x2000uLL);
    v79 = v58 - 1;
    if (v58 == 1)
    {
      LOBYTE(v80) = 1;
    }
    else
    {
      if ((unsigned __int16)(v58 - 1) > 7u)
      {
        v84 = v79 >> 3;
        *v78 = -1;
        v78[v84] |= 0xFFu >> (~(_BYTE)v79 & 7);
        if ((unsigned __int16)(v58 - 1) >= 0x10u)
        {
          if (v84 <= 2)
            LODWORD(v84) = 2;
          memset(v71 + 2, 255, (v84 - 1));
        }
        goto LABEL_119;
      }
      v80 = 0xFFu >> (v79 ^ 7);
    }
    *v78 = v80;
LABEL_119:
    v71 += 8193;
    goto LABEL_120;
  }
  if (v7)
  {
    Mutable = CFDataCreateMutable(alloc, 139280);
    CFDataSetLength(Mutable, 139280);
    v35 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
    __CFCSetGetBitmap((uint64_t)theSet, v35);
    v36 = CFDataGetMutableBytePtr(Mutable) + 0x2000;
    v37 = -16;
    do
    {
      *v36 = v37 + 17;
      memset(v36 + 1, 255, 0x2000uLL);
      v36 += 8193;
      v38 = __CFADD__(v37++, 1);
    }
    while (!v38);
  }
  else
  {
    Mutable = CFDataCreateMutable(alloc, 0x2000);
    CFDataSetLength(Mutable, 0x2000);
    v70 = (int8x16_t *)CFDataGetMutableBytePtr(Mutable);
    __CFCSetGetBitmap((uint64_t)theSet, v70);
  }
  return Mutable;
}

const char *__CFCheckForExpandedSet(const char *result)
{
  const char *v1;
  char v2;
  uint64_t v3;
  unsigned int v4;
  int v5;
  BOOL v6;

  v1 = result;
  v2 = __CFCheckForExpandedSet___CFNumberOfPlanesForLogging;
  if (__CFCheckForExpandedSet___CFNumberOfPlanesForLogging < 0)
  {
    result = getenv("CFCharacterSetCheckForExpandedSet");
    if (result)
      result = (const char *)strtol_l(result, 0, 0, 0);
    if ((unint64_t)(result - 1) >= 0x10)
      v2 = 0;
    else
      v2 = (char)result;
    __CFCheckForExpandedSet___CFNumberOfPlanesForLogging = v2;
  }
  if (v2)
  {
    v3 = *((_QWORD *)v1 + 5);
    if (v3)
    {
      v4 = *(_DWORD *)(v3 + 8);
      if (v4)
      {
        v5 = 0;
        while ((v4 & 1) == 0 || ++v5 < v2)
        {
          v6 = v4 > 1;
          v4 >>= 1;
          if (!v6)
            return result;
        }
        if ((__CFCheckForExpandedSet_warnedOnce & 1) == 0)
        {
          result = (const char *)CFLog(4, CFSTR("An expanded CFMutableCharacter has been detected.  Recommend to compact with CFCharacterSetCreateCopy"));
          __CFCheckForExpandedSet_warnedOnce = 1;
        }
      }
    }
  }
  return result;
}

void _CFCharacterSetFast(unint64_t *cf)
{
  char v2;
  unint64_t v3;
  uint64_t i;
  unint64_t v5;
  uint64_t v6;
  char v7;

  v2 = atomic_load(cf + 1);
  if ((v2 & 0x70) == 0x40 && cf[3])
    __CFCSetMakeBitmap((char *)cf);
  v3 = cf[5];
  if (v3 && *(_DWORD *)(v3 + 8))
  {
    for (i = 0; i != 16; ++i)
    {
      v5 = cf[5];
      if (v5)
      {
        if (((*(_DWORD *)(v5 + 8) >> (i + 1)) & 1) != 0
          && *(unsigned __int8 *)(v5 + 12) >= (i + 1))
        {
          v6 = *(_QWORD *)(*(_QWORD *)v5 + 8 * i);
          if (v6)
          {
            v7 = atomic_load((unint64_t *)(v6 + 8));
            if ((v7 & 0x70) == 0x40)
            {
              if (*(_QWORD *)(v6 + 24))
                __CFCSetMakeBitmap((char *)v6);
            }
          }
        }
      }
    }
  }
}

uint64_t _CFCharacterSetGetKeyedCodingType(uint64_t a1)
{
  unsigned int v3;
  int v4;
  uint64_t v5;

  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)a1))
    return 1;
  v3 = atomic_load((unint64_t *)(a1 + 8));
  v4 = (v3 >> 4) & 7;
  if (v4 == 2)
  {
    v5 = *(_QWORD *)(a1 + 40);
    if (!v5 || !*(_DWORD *)(v5 + 8) && !*(_BYTE *)(v5 + 13))
      return 4;
    return 1;
  }
  if (v4 == 1)
    return 3;
  if (v4)
    return 1;
  if (*(uint64_t *)(a1 + 24) >= 14)
    return 5;
  else
    return 2;
}

uint64_t _CFCharacterSetIsMutable(uint64_t a1)
{
  char v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

uint64_t _CFCharacterSetGetKeyedCodingBuiltinType(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t _CFCharacterSetGetKeyedCodingRange(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

CFStringRef _CFCharacterSetCreateKeyedCodingString(uint64_t a1)
{
  return CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(const UniChar **)(a1 + 24), *(_QWORD *)(a1 + 32));
}

uint64_t _CFCharacterSetIsInverted(uint64_t a1)
{
  unint64_t v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 >> 3) & 1;
}

uint64_t _CFCharacterSetSetIsInverted(uint64_t result, int a2)
{
  unint64_t *v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  int v6;

  v2 = (unint64_t *)(result + 8);
  v3 = atomic_load((unint64_t *)(result + 8));
  v4 = 8;
  if (!a2)
    v4 = 0;
  do
  {
    v5 = __ldaxr(v2);
    if (v5 == v3)
    {
      if (!__stlxr(v3 & 0xFFFFFFFFFFFFFFF7 | v4, v2))
      {
        v6 = 1;
        goto LABEL_8;
      }
    }
    else
    {
      __clrex();
    }
    v6 = 0;
LABEL_8:
    v3 = v5;
  }
  while (!v6);
  return result;
}

unint64_t *_CFCreateCharacterSetFromUSet(uint64_t a1, uint64_t a2)
{
  CFMutableCharacterSetRef Mutable;
  __CFCharacterSet *v3;
  int ItemCount;
  int v5;
  int i;
  int Item;
  const __CFString *v8;
  unint64_t *Copy;
  UniChar v11[2048];
  uint64_t v12;
  CFRange v13;

  MEMORY[0x1E0C80A78](a1, a2);
  v12 = *MEMORY[0x1E0C80C00];
  Mutable = CFCharacterSetCreateMutable(0);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  ItemCount = uset_getItemCount();
  if (ItemCount >= 1)
  {
    v5 = ItemCount;
    for (i = 0; i != v5; ++i)
    {
      Item = uset_getItem();
      if (Item <= 0)
      {
        v13.location = 0;
        v13.length = 1;
        CFCharacterSetAddCharactersInRange(v3, v13);
      }
      else
      {
        v8 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v11, Item, (CFAllocatorRef)&__kCFAllocatorNull);
        CFCharacterSetAddCharactersInString(v3, v8);
        CFRelease(v8);
      }
    }
  }
  Copy = __CFCharacterSetCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (unint64_t *)v3, 0, 1);
  CFRelease(v3);
  return Copy;
}

uint64_t __CFCSetIsEqualAnnex(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t i;
  int v19;
  int v20;
  char v21;
  uint64_t v22;
  uint64_t k;
  __int32 v24;
  __int32 v25;
  uint64_t n;
  __int32 v27;
  uint64_t m;
  __int32 v29;
  BOOL v30;
  uint64_t v31;
  uint64_t j;
  int v33;
  __int32 v34;
  int v35;
  uint64_t v36;
  char v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t result;
  int8x16_t __b[512];
  int8x16_t v45[512];
  uint64_t v46;

  v3 = MEMORY[0x1E0C80A78](a1, a2);
  v46 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(v3 + 40);
  if (!v4)
  {
    v6 = (uint64_t *)(v2 + 40);
    v7 = *(_QWORD *)(v2 + 40);
    if (!v7)
    {
LABEL_66:
      v36 = 0;
      while (1)
      {
        v37 = v36 + 1;
        v38 = (v36 + 1);
        v39 = *(_QWORD *)(v3 + 40);
        if (v39 && ((*(_DWORD *)(v39 + 8) >> v37) & 1) != 0 && *(unsigned __int8 *)(v39 + 12) >= v38)
          v40 = *(_QWORD *)(*(_QWORD *)v39 + 8 * v36);
        else
          v40 = 0;
        v41 = *v6;
        if (*v6 && ((*(_DWORD *)(v41 + 8) >> v37) & 1) != 0 && *(unsigned __int8 *)(v41 + 12) >= v38)
        {
          v42 = *(_QWORD *)(*(_QWORD *)v41 + 8 * v36);
          if (v40)
          {
LABEL_75:
            result = __CFCharacterSetEqual(v40, v42);
            if (!(_DWORD)result)
              return result;
          }
        }
        else
        {
          v42 = 0;
          if (v40)
            goto LABEL_75;
        }
        if (++v36 == 16)
          return 1;
      }
    }
    v8 = *(unsigned __int8 *)(v7 + 13);
    if (!*(_BYTE *)(v7 + 13))
      goto LABEL_63;
    goto LABEL_9;
  }
  v6 = (uint64_t *)(v2 + 40);
  v5 = *(_QWORD *)(v2 + 40);
  if (!v5)
  {
    if (!*(_BYTE *)(v4 + 13))
    {
      v7 = 0;
      goto LABEL_62;
    }
    goto LABEL_9;
  }
  v7 = *(_QWORD *)(v2 + 40);
  if ((*(_BYTE *)(v4 + 13) != 0) != (*(_BYTE *)(v5 + 13) != 0))
  {
LABEL_9:
    v9 = 1;
    while (1)
    {
      v10 = *(_QWORD *)(v3 + 40);
      if (v10
        && ((*(_DWORD *)(v10 + 8) >> v9) & 1) != 0
        && *(unsigned __int8 *)(v10 + 12) >= v9)
      {
        v11 = *(_QWORD *)(*(_QWORD *)v10 + 8 * v9 - 8);
      }
      else
      {
        v11 = 0;
      }
      v12 = *v6;
      if (*v6
        && ((*(_DWORD *)(v12 + 8) >> v9) & 1) != 0
        && *(unsigned __int8 *)(v12 + 12) >= v9)
      {
        v13 = *(_QWORD *)(*(_QWORD *)v12 + 8 * v9 - 8);
      }
      else
      {
        v13 = 0;
      }
      if (!(v11 | v13))
        return 0;
      if (v11)
      {
        v14 = atomic_load((unint64_t *)(v11 + 8));
        v15 = v14 & 0x70;
        if (v13)
        {
          v16 = atomic_load((unint64_t *)(v13 + 8));
          v17 = v16 & 0x70;
          if (v15 == 48 && v17 == 48)
          {
            for (i = 0; i != 0x2000; i += 4)
            {
              v19 = *(_DWORD *)(*(_QWORD *)(v11 + 24) + i);
              v20 = ~*(_DWORD *)(*(_QWORD *)(v13 + 24) + i);
              if (v19 != v20)
                return 0;
            }
          }
          else if (v15 == 48 || v17 == 48)
          {
            v30 = v17 == 48;
            if (v17 == 48)
              v31 = v11;
            else
              v31 = v13;
            if (!v30)
              v13 = v11;
            __CFCSetGetBitmap(v31, v45);
            for (j = 0; j != 2048; ++j)
            {
              v33 = *(_DWORD *)(*(_QWORD *)(v13 + 24) + j * 4);
              v34 = ~v45[0].i32[j];
              if (v33 != v34)
                return 0;
            }
          }
          else
          {
            __CFCSetGetBitmap(v11, v45);
            __CFCSetGetBitmap(v13, __b);
            for (k = 0; k != 2048; ++k)
            {
              v24 = v45[0].i32[k];
              v25 = ~__b[0].i32[k];
              if (v24 != v25)
                return 0;
            }
          }
        }
        else
        {
          if (v15 == 48)
          {
            v22 = *(_QWORD *)(v11 + 24);
LABEL_31:
            if (!__CFCSetIsEqualBitmap(v22, -1))
              return 0;
            goto LABEL_32;
          }
          __CFCSetGetBitmap(v11, v45);
          if (v45 != (int8x16_t *)-1)
          {
            for (m = 0; m != 2048; ++m)
            {
              v29 = v45[0].i32[m];
              if (v29 != -1)
                return 0;
            }
          }
        }
      }
      else
      {
        v21 = atomic_load((unint64_t *)(v13 + 8));
        if ((v21 & 0x70) == 0x30)
        {
          v22 = *(_QWORD *)(v13 + 24);
          goto LABEL_31;
        }
        __CFCSetGetBitmap(v13, v45);
        if (v45 != (int8x16_t *)-1)
        {
          for (n = 0; n != 2048; ++n)
          {
            v27 = v45[0].i32[n];
            if (v27 != -1)
              return 0;
          }
        }
      }
LABEL_32:
      if (++v9 == 17)
        return 1;
    }
  }
LABEL_62:
  v8 = *(_DWORD *)(v4 + 8);
  if (v5)
  {
LABEL_63:
    v35 = *(_DWORD *)(v7 + 8);
    goto LABEL_65;
  }
  v35 = 0;
LABEL_65:
  if (v8 == v35)
    goto LABEL_66;
  return 0;
}

uint64_t __CFCSetIsBitmapEqualToRange(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  unsigned int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  int *v19;
  int v21;
  int *v22;
  uint64_t i;
  int v24;

  if ((a3 ^ a2) <= 7)
  {
    if (a4)
      v4 = ~(((0xFFu >> (~(_BYTE)a3 & 7)) & (255 << (a2 & 7))) << 24 >> (~(_BYTE)a2 & 0x18));
    else
      v4 = ((0xFFu >> (~(_BYTE)a3 & 7)) & (255 << (a2 & 7))) << 24 >> (~(_BYTE)a2 & 0x18);
    v5 = a2 >> 5;
    if (a4)
      v6 = -1;
    else
      v6 = 0;
    if (*(_DWORD *)(a1 + 4 * v5) == v4)
    {
      v7 = a2 >> 5;
      goto LABEL_26;
    }
    return 0;
  }
  v8 = ((255 << (a2 & 7)) << (a2 & 0x18 ^ 0x18)) | (0xFFFFFFu >> (a2 & 0x18));
  v9 = (0xFFu >> (~(_BYTE)a3 & 7) << (a3 & 0x18 ^ 0x18)) | (0xFFFFFFFFLL << (32 - (a3 & 0x18)));
  v5 = a2 >> 5;
  v7 = a3 >> 5;
  if ((_DWORD)v5 == a3 >> 5)
  {
    v10 = bswap32(v9 & v8);
    if (a4)
      v11 = ~v10;
    else
      v11 = v10;
    v12 = *(_DWORD *)(a1 + 4 * v5);
    if (a4)
      v6 = -1;
    else
      v6 = 0;
  }
  else
  {
    v13 = bswap32(v8);
    if (a4)
      v14 = ~v13;
    else
      v14 = v13;
    if (a4)
      v6 = -1;
    else
      v6 = 0;
    if (*(_DWORD *)(a1 + 4 * v5) != v14)
      return 0;
    v12 = *(_DWORD *)(a1 + 4 * v7);
    v11 = bswap32(v9) ^ v6;
  }
  if (v12 != v11)
    return 0;
LABEL_26:
  v15 = 0;
  while (v5 != v15)
  {
    v16 = *(_DWORD *)(a1 + 4 * v15++);
    if (v16 != v6)
      return 0;
  }
  v17 = v7 + ~v5;
  if (a4)
    v18 = 0;
  else
    v18 = -1;
  v19 = (int *)(4 * v5 + a1 + 4);
  while (v17-- >= 1)
  {
    v21 = *v19++;
    if (v21 != v18)
      return 0;
  }
  if (v5 == v7)
    v22 = v19;
  else
    v22 = v19 + 1;
  for (i = v7 - 2047; i; ++i)
  {
    v24 = *v22++;
    if (v24 != v6)
      return 0;
  }
  return 1;
}

BOOL fdCanWrite(int a1)
{
  _OWORD *v2;
  unsigned int v3;
  size_t v4;
  int v5;
  _OWORD v7[8];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a1 >= 1024)
  {
    v3 = (a1 + 1) >> 5;
    if (((a1 + 1) & 0x1F) != 0)
      ++v3;
    v4 = 4 * v3;
    v2 = malloc_type_malloc(v4, 0x5DEC1D89uLL);
    bzero(v2, v4);
  }
  else
  {
    v2 = v7;
  }
  memset(v7, 0, sizeof(v7));
  if (__darwin_check_fd_set_overflow(a1, v2, 1))
    *(_DWORD *)((char *)v2 + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
  v5 = select_DARWIN_EXTSN();
  if (v2 != v7)
    free(v2);
  return v5 == 1;
}

uint64_t _CFReadStreamCreateFromFileDescriptor(__objc2_class **a1, int a2)
{
  _OWORD v3[2];
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v4 = 0;
  memset(v3, 0, sizeof(v3));
  DWORD2(v3[0]) = a2;
  return _CFStreamCreateWithConstantCallbacks(a1, (uint64_t)v3, fileCallBacks, 1);
}

CFWriteStreamRef CFWriteStreamCreateWithBuffer(CFAllocatorRef alloc, UInt8 *buffer, CFIndex bufferCapacity)
{
  _QWORD v4[4];
  _QWORD v5[5];

  v5[4] = *MEMORY[0x1E0C80C00];
  v4[0] = buffer;
  v4[1] = bufferCapacity;
  v4[2] = 0;
  v4[3] = 0;
  v5[0] = v4;
  v5[1] = v4;
  v5[2] = &__kCFAllocatorNull;
  v5[3] = 0;
  return (CFWriteStreamRef)_CFStreamCreateWithConstantCallbacks((__objc2_class **)alloc, (uint64_t)v5, writeDataCallBacks, 0);
}

CFStringRef fileCopyDescription(const void *a1, uint64_t a2)
{
  const __CFAllocator *v4;

  if (*(_QWORD *)a2)
    return CFCopyDescription(*(CFTypeRef *)a2);
  v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, 0, CFSTR("fd = %d"), *(unsigned int *)(a2 + 8));
}

BOOL fileCanWrite(uint64_t a1, uint64_t a2)
{
  return fdCanWrite(*(_DWORD *)(a2 + 8));
}

CFDataRef fileCopyProperty(const void *a1, CFTypeRef cf1, uint64_t a3)
{
  int v6;
  const void *v7;
  uint64_t v8;
  const __CFAllocator *v9;
  const __CFAllocator *v11;
  UInt8 bytes[4];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (CFEqual(cf1, CFSTR("kCFStreamPropertyFileCurrentOffset")))
  {
    if ((*(_BYTE *)(a3 + 24) & 8) == 0)
    {
      v6 = *(_DWORD *)(a3 + 8);
      if (v6 != -1)
        *(_QWORD *)(a3 + 32) = lseek(v6, 0, 1);
    }
    v8 = *(_QWORD *)(a3 + 32);
    v7 = (const void *)(a3 + 32);
    if (v8 != -1)
    {
      v9 = CFGetAllocator(a1);
      return CFNumberCreate(v9, kCFNumberSInt64Type, v7);
    }
  }
  else if (CFEqual(cf1, CFSTR("_kCFStreamPropertyFileNativeHandle")))
  {
    *(_DWORD *)bytes = *(_DWORD *)(a3 + 8);
    if (*(_DWORD *)bytes != -1)
    {
      v11 = CFGetAllocator(a1);
      return CFDataCreate(v11, bytes, 4);
    }
  }
  return 0;
}

uint64_t fileSetProperty(void *a1, CFTypeRef cf1, __objc2_class **a3, uint64_t a4)
{
  CFTypeID v8;
  uint64_t Value;
  int v10;
  uint64_t v11;

  if (CFEqual(cf1, CFSTR("kCFStreamPropertyAppendToFile"))
    && (v8 = CFGetTypeID(a1), v8 == CFWriteStreamGetTypeID())
    && CFWriteStreamGetStatus((CFWriteStreamRef)a1) == kCFStreamStatusNotOpen)
  {
    v11 = *(_QWORD *)(a4 + 24);
    if (&__kCFBooleanTrue == a3)
    {
      *(_QWORD *)(a4 + 24) = v11 | 8;
      *(_QWORD *)(a4 + 32) = -1;
    }
    else
    {
      *(_QWORD *)(a4 + 24) = v11 & 0xFFFFFFFFFFFFFFF7;
    }
    return 1;
  }
  else if (CFEqual(cf1, CFSTR("kCFStreamPropertyFileCurrentOffset")))
  {
    if ((*(_BYTE *)(a4 + 24) & 8) != 0)
      Value = 0;
    else
      Value = CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt64Type, (void *)(a4 + 32));
    v10 = *(_DWORD *)(a4 + 8);
    if (v10 != -1)
    {
      if (lseek(v10, *(_QWORD *)(a4 + 32), 0) == -1)
        return 0;
      else
        return Value;
    }
  }
  else
  {
    return 0;
  }
  return Value;
}

void fileSchedule(void *a1, __CFRunLoop *a2, const __CFString *a3, uint64_t a4)
{
  CFTypeID v8;
  BOOL v9;
  int v10;
  CFStreamStatus Status;
  __CFArray *Mutable;
  const __CFAllocator *v13;
  __CFRunLoopSource *RunLoopSource;
  const __CFAllocator *v15;

  v8 = CFGetTypeID(a1);
  v9 = v8 == CFReadStreamGetTypeID();
  v10 = v9;
  if (v9)
    Status = CFReadStreamGetStatus((CFReadStreamRef)a1);
  else
    Status = CFWriteStreamGetStatus((CFWriteStreamRef)a1);
  if ((*(_DWORD *)(a4 + 8) & 0x80000000) == 0 || Status == kCFStreamStatusNotOpen)
  {
    Mutable = *(__CFArray **)(a4 + 16);
    if (Status)
    {
      if (!Mutable)
        constructCFFD(a4, v10, a1);
      v13 = CFGetAllocator(a1);
      RunLoopSource = CFFileDescriptorCreateRunLoopSource(v13, *(CFFileDescriptorRef *)(a4 + 16), 0);
      CFRunLoopAddSource(a2, RunLoopSource, a3);
      CFRelease(RunLoopSource);
    }
    else
    {
      if (!Mutable)
      {
        v15 = CFGetAllocator(a1);
        Mutable = CFArrayCreateMutable(v15, 0, &kCFTypeArrayCallBacks);
        *(_QWORD *)(a4 + 16) = Mutable;
      }
      CFArrayAppendValue(Mutable, a2);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a4 + 16), a3);
    }
  }
}

void fileUnschedule(void *a1, __CFRunLoop *a2, const __CFString *a3, uint64_t a4)
{
  CFTypeID v8;
  CFStreamStatus Status;
  const __CFArray *v10;
  const __CFAllocator *v11;
  __CFRunLoopSource *RunLoopSource;
  CFIndex v13;
  CFIndex v14;
  CFIndex v15;
  CFIndex v16;
  const void *v17;
  const void *v18;
  CFIndex Count;
  CFIndex v20;
  CFIndex v21;
  const void *ValueAtIndex;
  const void *v23;

  v8 = CFGetTypeID(a1);
  if (v8 == CFReadStreamGetTypeID())
    Status = CFReadStreamGetStatus((CFReadStreamRef)a1);
  else
    Status = CFWriteStreamGetStatus((CFWriteStreamRef)a1);
  v10 = *(const __CFArray **)(a4 + 16);
  if (Status)
  {
    if (v10)
    {
      if ((*(_BYTE *)(a4 + 24) & 0x20) == 0)
      {
        v11 = CFGetAllocator(a1);
        RunLoopSource = CFFileDescriptorCreateRunLoopSource(v11, *(CFFileDescriptorRef *)(a4 + 16), 0);
        CFRunLoopRemoveSource(a2, RunLoopSource, a3);
        CFRelease(RunLoopSource);
        return;
      }
      Count = CFArrayGetCount(*(CFArrayRef *)(a4 + 16));
      if (Count >= 2)
      {
        v20 = Count;
        v21 = 1;
        while (1)
        {
          v16 = v21 - 1;
          ValueAtIndex = CFArrayGetValueAtIndex(v10, v21 - 1);
          if (CFEqual(ValueAtIndex, a2))
          {
            v23 = CFArrayGetValueAtIndex(v10, v21);
            if (CFEqual(v23, a3))
              break;
          }
          v21 += 2;
          if (v21 >= v20)
            return;
        }
LABEL_21:
        CFArrayRemoveValueAtIndex(v10, v16);
        CFArrayRemoveValueAtIndex(v10, v16);
      }
    }
  }
  else if (v10)
  {
    v13 = CFArrayGetCount(*(CFArrayRef *)(a4 + 16));
    if (v13 >= 2)
    {
      v14 = v13;
      v15 = 1;
      while (1)
      {
        v16 = v15 - 1;
        v17 = CFArrayGetValueAtIndex(v10, v15 - 1);
        if (CFEqual(v17, a2))
        {
          v18 = CFArrayGetValueAtIndex(v10, v15);
          if (CFEqual(v18, a3))
            break;
        }
        v15 += 2;
        if (v15 >= v14)
          return;
      }
      goto LABEL_21;
    }
  }
}

uint64_t constructCFFD(uint64_t a1, int a2, void *cf)
{
  const __CFAllocator *v6;
  __CFFileDescriptor *v7;
  __CFFileDescriptor *v8;
  CFOptionFlags v9;
  const __CFArray *v10;
  CFIndex Count;
  const __CFAllocator *v12;
  __CFRunLoopSource *RunLoopSource;
  CFIndex i;
  __CFRunLoop *ValueAtIndex;
  const __CFString *v16;
  uint64_t result;
  CFFileDescriptorContext v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v18.version = 0;
  v18.info = cf;
  v18.retain = (void *(__cdecl *)(void *))_fs_retain;
  v18.release = (void (__cdecl *)(void *))_fs_release;
  v18.copyDescription = (CFStringRef (__cdecl *)(void *))CFCopyDescription;
  v6 = CFGetAllocator(cf);
  v7 = CFFileDescriptorCreate(v6, *(_DWORD *)(a1 + 8), 0, (CFFileDescriptorCallBack)fileCallBack, &v18);
  if (v7)
  {
    v8 = v7;
    if (a2)
      v9 = 1;
    else
      v9 = 2;
    CFFileDescriptorEnableCallBacks(v7, v9);
    v10 = *(const __CFArray **)(a1 + 16);
    if (v10)
    {
      Count = CFArrayGetCount(v10);
      v12 = CFGetAllocator(cf);
      RunLoopSource = CFFileDescriptorCreateRunLoopSource(v12, v8, 0);
      if (Count >= 2)
      {
        for (i = 1; i < Count; i += 2)
        {
          ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), i - 1);
          v16 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), i);
          CFRunLoopAddSource(ValueAtIndex, RunLoopSource, v16);
        }
      }
      CFRelease(*(CFTypeRef *)(a1 + 16));
      CFRelease(RunLoopSource);
    }
    *(_QWORD *)(a1 + 16) = v8;
    return 1;
  }
  else
  {
    result = *(_QWORD *)(a1 + 16);
    if (result)
    {
      CFRelease((CFTypeRef)result);
      result = 0;
      *(_QWORD *)(a1 + 16) = 0;
    }
  }
  return result;
}

CFTypeRef _fs_retain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void _fs_release(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

void fileCallBack(int a1, uint64_t a2, void *cf)
{
  CFTypeID v5;
  uint64_t InfoPointer;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (cf)
  {
    v5 = CFGetTypeID(cf);
    if (v5 == CFReadStreamGetTypeID())
    {
      InfoPointer = CFReadStreamGetInfoPointer((uint64_t)cf);
      if (!InfoPointer)
        return;
    }
    else
    {
      InfoPointer = CFWriteStreamGetInfoPointer((uint64_t)cf);
      if (!InfoPointer)
        return;
    }
    v12 = *(_QWORD *)(InfoPointer + 24);
    if (a2 == 2)
    {
      *(_QWORD *)(InfoPointer + 24) = v12 | 1;
      CFWriteStreamSignalEvent((char *)cf, 4uLL, 0, v7, v8, v9, v10, v11);
    }
    else
    {
      *(_QWORD *)(InfoPointer + 24) = v12 | 2;
      CFReadStreamSignalEvent((char *)cf, 2uLL, 0, v7, v8, v9, v10, v11);
    }
  }
}

CFStringRef readDataCopyDescription(uint64_t a1, CFTypeRef *a2)
{
  return CFCopyDescription(*a2);
}

uint64_t dataGetBuffer(char *a1, CFIndex a2, CFIndex *a3, uint64_t a4, BOOL *a5, uint64_t a6)
{
  const UInt8 *BytePtr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFIndex v18;
  BOOL v19;
  uint64_t v20;

  BytePtr = CFDataGetBytePtr(*(CFDataRef *)a6);
  v18 = (CFIndex)&BytePtr[CFDataGetLength(*(CFDataRef *)a6) - *(_QWORD *)(a6 + 8)];
  v19 = v18 <= a2;
  if (v18 >= a2)
    v18 = a2;
  *a3 = v18;
  *a5 = v19;
  *(_DWORD *)(a4 + 8) = 0;
  v20 = *(_QWORD *)(a6 + 8);
  *(_QWORD *)(a6 + 8) = v20 + *a3;
  if (*(_BYTE *)(a6 + 16) && !*a5)
    CFReadStreamSignalEvent(a1, 2uLL, 0, v13, v14, v15, v16, v17);
  return v20;
}

CFStringRef writeDataCopyDescription(uint64_t a1, uint64_t a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFWriteDataContext %p>"), a2);
}

BOOL dataCanWrite(uint64_t a1, uint64_t a2)
{
  return *(__objc2_class ***)(a2 + 16) != &__kCFAllocatorNull
      || *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8) > *(_QWORD *)(*(_QWORD *)(a2 + 8) + 16);
}

void writeDataSchedule(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;

  if (!*(_BYTE *)(a4 + 24))
  {
    *(_BYTE *)(a4 + 24) = 1;
    if (CFWriteStreamGetStatus((CFWriteStreamRef)a1) == kCFStreamStatusOpen)
    {
      if (*(__objc2_class ***)(a4 + 16) == &__kCFAllocatorNull)
      {
        if (*(_QWORD *)(*(_QWORD *)(a4 + 8) + 8) <= *(_QWORD *)(*(_QWORD *)(a4 + 8) + 16))
          v11 = 16;
        else
          v11 = 4;
      }
      else
      {
        v11 = 4;
      }
      CFWriteStreamSignalEvent(a1, v11, 0, v6, v7, v8, v9, v10);
    }
  }
}

void sub_182BB02D0(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BB090C(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BB0D6C(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BB11C8(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BB1934(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BB2EAC(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BB4E2C(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BB5488(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BB5900(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BB5F4C(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BB63C4(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BB6838(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_0_2(objc_class *a1, uint64_t a2)
{
  __CFRequireConcreteImplementation(a1, a2);
}

void _CFDataInit(unint64_t *a1, int a2, unint64_t a3, const UInt8 *a4, CFIndex a5, int a6)
{
  char v8;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  char v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  _BOOL4 v20;
  void *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  CFRange v29;

  v8 = a2;
  a1[2] = 0;
  v10 = a1 + 1;
  v11 = atomic_load(a1 + 1);
  do
  {
    v12 = __ldaxr(v10);
    if (v12 == v11)
    {
      if (!__stlxr(v11 & 0xFFFFFFFFFFFFFFEFLL | (4 * a2) & 0x10, v10))
      {
        v13 = 1;
        goto LABEL_7;
      }
    }
    else
    {
      __clrex();
    }
    v13 = 0;
LABEL_7:
    v11 = v12;
  }
  while (!v13);
  if ((a2 & 2) != 0 && (a2 & 1) != 0)
  {
    a1[3] = 16;
    v14 = atomic_load(a1 + 1);
    while (1)
    {
      v15 = __ldaxr(v10);
      if (v15 != v14)
        break;
      if (__stlxr(v14 | 3, v10))
        goto LABEL_15;
      v16 = 1;
LABEL_16:
      v14 = v15;
      if ((v16 & 1) != 0)
        goto LABEL_25;
    }
    __clrex();
LABEL_15:
    v16 = 0;
    goto LABEL_16;
  }
  a1[3] = a3;
  v17 = atomic_load(a1 + 1);
  while (2)
  {
    v18 = __ldaxr(v10);
    if (v18 == v17)
    {
      if (!__stlxr(v17 & 0xFFFFFFFFFFFFFFFCLL | 1, v10))
      {
        v19 = 1;
        goto LABEL_24;
      }
    }
    else
    {
      __clrex();
    }
    v19 = 0;
LABEL_24:
    v17 = v18;
    if (!v19)
      continue;
    break;
  }
LABEL_25:
  if (a6)
  {
    a1[5] = (unint64_t)a4;
    a1[2] = a5;
    goto LABEL_42;
  }
  v20 = 0;
  if ((a2 & 2) == 0 && (a2 & 1) != 0)
    v20 = _CFExecutableLinkedOnOrAfter(6uLL) == 0;
  v21 = __CFDataAllocate((uint64_t)a1, a1[3], v20);
  a1[5] = (unint64_t)v21;
  if (__CFOASafe)
  {
    __CFSetLastAllocationEventName();
    v21 = (void *)a1[5];
  }
  if (v21)
  {
    v22 = atomic_load(v10);
    v23 = 64;
    if (v20)
      v23 = 0;
    while (1)
    {
      v24 = __ldaxr(v10);
      if (v24 != v22)
        break;
      if (__stlxr(v22 & 0xFFFFFFFFFFFFFFBFLL | v23, v10))
        goto LABEL_39;
      v25 = 1;
LABEL_40:
      v22 = v24;
      if (v25)
      {
        v29.location = 0;
        v29.length = 0;
        CFDataReplaceBytes((CFMutableDataRef)a1, v29, a4, a5);
LABEL_42:
        v26 = atomic_load(v10);
        while (2)
        {
          v27 = __ldaxr(v10);
          if (v27 == v26)
          {
            if (!__stlxr(v26 & 0xFFFFFFFFFFFFFFFCLL | v8 & 3, v10))
            {
              v28 = 1;
              goto LABEL_48;
            }
          }
          else
          {
            __clrex();
          }
          v28 = 0;
LABEL_48:
          v26 = v27;
          if (v28)
            return;
          continue;
        }
      }
    }
    __clrex();
LABEL_39:
    v25 = 0;
    goto LABEL_40;
  }
}

uint64_t _CFDataFindBytes(const __CFData *a1, const __CFData *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  const UInt8 *BytePtr;
  unsigned __int8 *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t result;
  unint64_t v18;
  unsigned __int8 *v19;

  BytePtr = CFDataGetBytePtr(a1);
  v11 = (unsigned __int8 *)CFDataGetBytePtr(a2);
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)a1))
    v12 = -[__CFData length](a1, "length");
  else
    v12 = *((_QWORD *)a1 + 2);
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)a2))
    v13 = -[__CFData length](a2, "length");
  else
    v13 = *((_QWORD *)a2 + 2);
  v14 = ((a5 << 63 >> 63) & (a4 - v13)) + a3;
  if (a4 > v13)
  {
    v15 = v13;
  }
  else
  {
    v14 = a3;
    v15 = a4;
  }
  if ((a5 & 2) != 0)
  {
    a3 = v14;
    v16 = v15;
  }
  else
  {
    v16 = a4;
  }
  if (v16 >= v12 - a3)
    v16 = v12 - a3;
  result = -1;
  if (v13 - 1 < v16 && v12)
  {
    v18 = (unint64_t)&BytePtr[a3];
    v19 = __CFDataSearchBoyerMoore(v18, v16, v11, v13, a5 & 1);
    if (v19)
      return (uint64_t)&v19[a3 - v18];
    else
      return -1;
  }
  return result;
}

unsigned __int8 *__CFDataSearchBoyerMoore(unint64_t a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  int64x2_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _BYTE *v23;
  _BYTE *v24;
  unint64_t v25;
  unint64_t v26;
  unsigned __int8 *v27;
  int v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v35;
  uint64_t v36;
  char v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  unsigned __int8 *v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unsigned __int8 *v48;
  _BYTE v50[12];
  int v51;
  _BYTE v52[2048];
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  bzero(v52, 0x800uLL);
  if (a4 >> 60)
    goto LABEL_65;
  v12 = MEMORY[0x1E0C80A78](v10, v11);
  v15 = (uint64_t *)&v50[-v14];
  if (a4 <= 0x100)
  {
    MEMORY[0x1E0C80A78](v12, v13);
    v16 = (uint64_t *)&v50[-((8 * a4 + 15) & 0xFFFFFFFFFFFFFFF0)];
    goto LABEL_7;
  }
  v17 = (uint64_t *)malloc_type_malloc(8 * a4, 0x100004000313F17uLL);
  if (!v17 || (v15 = v17, (v18 = (uint64_t *)malloc_type_malloc(8 * a4, 0x100004000313F17uLL)) == 0))
LABEL_65:
    __CFDataHandleOutOfMemory(8 * a4);
  v16 = v18;
LABEL_7:
  v19 = vdupq_n_s64(a4);
  v20 = 0;
  if (a5)
  {
    do
    {
      *(int64x2_t *)&v52[v20] = v19;
      v20 += 16;
    }
    while (v20 != 2048);
    v51 = a5;
    v21 = (a4 - 1);
    if ((int)a4 - 1 >= 0)
    {
      v22 = a4;
      do
      {
        *(_QWORD *)&v52[8 * a3[v21]] = v21;
        --v21;
        --v22;
      }
      while (v22);
    }
    v23 = malloc_type_malloc(a4, 0x100004077774924uLL);
    if (!v23)
      __CFDataHandleOutOfMemory(a4);
    v24 = v23;
    memmove(v23, a3, a4);
    v25 = a4 - 1;
    if (a4 > 1)
    {
      v35 = 0;
      if (a4 >> 1 <= 1)
        v36 = 1;
      else
        v36 = a4 >> 1;
      do
      {
        v37 = v24[v35];
        v24[v35] = v24[v25];
        v24[v25] = v37;
        ++v35;
        --v25;
      }
      while (v36 != v35);
      _computeGoodSubstringShift((uint64_t)v24, a4, v15, v16);
      v38 = &v15[a4 - 1];
      v39 = v15;
      do
      {
        v40 = *v39;
        *v39++ = *v38;
        *v38-- = v40;
        --v36;
      }
      while (v36);
    }
    else
    {
      _computeGoodSubstringShift((uint64_t)v24, a4, v15, v16);
    }
    free(v24);
    if (v51)
    {
      v41 = &a3[a4];
      v42 = (unsigned __int8 *)(a1 + a2 - a4);
      if ((unint64_t)v42 < a1 || (uint64_t)a4 < 1)
      {
        v43 = a3;
      }
      else
      {
        v43 = a3;
        do
        {
          v44 = *v42;
          if ((_DWORD)v44 == *v43)
          {
            ++v42;
            ++v43;
          }
          else
          {
            v45 = *(_QWORD *)&v52[8 * v44];
            v46 = v15[v43 - a3];
            if (v45 > v46)
              v46 = v45;
            v42 -= v46;
            v43 = a3;
          }
        }
        while ((unint64_t)v42 >= a1 && v43 < v41);
      }
      if (v43 == v41)
        v48 = &v42[-a4];
      else
        v48 = 0;
      goto LABEL_62;
    }
  }
  else
  {
    do
    {
      *(int64x2_t *)&v52[v20] = v19;
      v20 += 16;
    }
    while (v20 != 2048);
    if (a4)
    {
      v26 = a4 - 1;
      v27 = a3;
      do
      {
        v28 = *v27++;
        *(_QWORD *)&v52[8 * v28] = v26--;
      }
      while (v26 != -1);
    }
    _computeGoodSubstringShift((uint64_t)a3, a4, v15, v16);
  }
  v29 = (unsigned __int8 *)(a1 + a4 - 1);
  if ((unint64_t)v29 >= a1 + a2 || &a3[a4 - 1] < a3)
  {
    v30 = &a3[a4 - 1];
  }
  else
  {
    v30 = &a3[a4 - 1];
    do
    {
      v31 = *v29;
      if ((_DWORD)v31 == *v30)
      {
        --v29;
        --v30;
      }
      else
      {
        v32 = *(_QWORD *)&v52[8 * v31];
        v33 = v15[v30 - a3];
        if (v32 > v33)
          v33 = v32;
        v29 += v33;
        v30 = &a3[a4 - 1];
      }
    }
    while ((unint64_t)v29 < a1 + a2 && v30 >= a3);
  }
  if (v30 < a3)
    v48 = v29 + 1;
  else
    v48 = 0;
LABEL_62:
  if (a4 >= 0x101)
  {
    free(v15);
    free(v16);
  }
  return v48;
}

CFRange CFDataFind(CFDataRef theData, CFDataRef dataToFind, CFRange searchRange, CFDataSearchFlags compareOptions)
{
  CFIndex length;
  CFIndex location;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  CFIndex Bytes;
  CFIndex v27;
  CFRange result;

  length = searchRange.length;
  location = searchRange.location;
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    v9 = -[__CFData length](theData, "length");
    if ((location & 0x8000000000000000) == 0)
      goto LABEL_3;
  }
  else
  {
    v9 = *((_QWORD *)theData + 2);
    if ((location & 0x8000000000000000) == 0)
    {
LABEL_3:
      if (location <= v9)
      {
        if (length < 0)
        {
          v19 = dyld_program_sdk_at_least();
          if ((_DWORD)v19)
            CFDataFind_cold_5(v19, v20, v21);
          v24 = _CFOSLog();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
            CFDataFind_cold_6();
        }
        else if (location + length > v9)
        {
          v16 = dyld_program_sdk_at_least();
          if ((_DWORD)v16)
            CFDataFind_cold_3(v16, v17, v18);
          v25 = _CFOSLog();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
            CFDataFind_cold_4();
        }
      }
      else
      {
        v10 = dyld_program_sdk_at_least();
        if ((_DWORD)v10)
          CFDataFind_cold_1(v10, v11, v12);
        v23 = _CFOSLog();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
          CFDataFind_cold_2();
      }
      goto LABEL_23;
    }
  }
  v13 = dyld_program_sdk_at_least();
  if ((_DWORD)v13)
    CFDataFind_cold_7(v13, v14, v15);
  v22 = _CFOSLog();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
    CFDataFind_cold_8();
LABEL_23:
  Bytes = _CFDataFindBytes(theData, dataToFind, location, length, compareOptions);
  result.length = v27;
  result.location = Bytes;
  return result;
}

uint64_t _computeGoodSubstringShift(uint64_t result, int a2, _QWORD *a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v4 = (a2 - 1);
  a4[(int)v4] = a2;
  if (a2 > 1)
  {
    v5 = (a2 - 2);
    LODWORD(v6) = a2 - 1;
    v7 = a2 - 1;
    do
    {
      if (v5 <= (int)v6 || (v8 = a4[~v7 + a2 + (int)v5], v8 >= (int)v5 - (int)v6))
      {
        if ((int)v5 >= (int)v6)
          v9 = v6;
        else
          v9 = v5;
        if (v9 < 0)
        {
          LODWORD(v6) = v9;
        }
        else
        {
          v6 = (int)v6;
          if (v5 < (int)v6)
            v6 = v5;
          while (*(unsigned __int8 *)(result + v6) == *(unsigned __int8 *)(result + a2 - 1 - (int)v5 + (int)v6))
          {
            v10 = v6-- <= 0;
            if (v10)
            {
              LODWORD(v6) = -1;
              break;
            }
          }
        }
        v8 = (int)v5 - (int)v6;
        v7 = v5;
      }
      a4[v5] = v8;
      v10 = v5-- <= 0;
    }
    while (!v10);
  }
  if (a2 >= 1)
  {
    v11 = (int)v4;
    v12 = a2;
    v13 = a3;
    do
    {
      *v13++ = a2;
      --v12;
    }
    while (v12);
    LODWORD(v14) = 0;
    v15 = a2;
    do
    {
      v16 = v15--;
      if (a4[v15] == v16 && (int)v4 - v15 > (int)v14)
      {
        v14 = (int)v14;
        do
        {
          if (a3[v14] == a2)
            a3[v14] = (int)v4 - v15;
          ++v14;
        }
        while (v12 != v14);
        LODWORD(v14) = v12;
      }
      ++v12;
    }
    while (v12 != a2);
    if (a2 >= 2)
    {
      v17 = (a2 - 1);
      v18 = (int)v4;
      do
      {
        v19 = *a4++;
        a3[(int)v4 - v19] = v18--;
        --v17;
      }
      while (v17);
      do
      {
        *a3++ += v11--;
        --v4;
      }
      while (v4);
    }
  }
  return result;
}

void OUTLINED_FUNCTION_0_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 2u);
}

void OUTLINED_FUNCTION_3_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 219, a4);
}

void OUTLINED_FUNCTION_4(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 218, a4);
}

void OUTLINED_FUNCTION_6(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 221, a4);
}

void sub_182BB8308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182BB8694(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t _compare_clumpiness(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

CFURLRef _CFBundleCopyExecutableURLInDirectory(CFURLRef url)
{
  return _CFBundleCopyExecutableURLInDirectory2(0, url, 0, 1);
}

CFURLRef _CFBundleCopyOtherExecutableURLInDirectory(CFURLRef url)
{
  return _CFBundleCopyExecutableURLInDirectory2(0, url, 0, 1);
}

CFURLRef CFBundleCopyAuxiliaryExecutableURL(CFBundleRef bundle, CFStringRef executableName)
{
  return _CFBundleCopyExecutableURLInDirectory2(bundle, *((CFURLRef *)bundle + 2), executableName, 1);
}

__CFBundle *_CFBundleCreateWithExecutableURLIfMightBeBundle(const __CFAllocator *a1, const __CFURL *a2)
{
  CFURLRef *v2;
  __CFBundle *v3;
  const __CFDictionary *InfoDictionary;

  v2 = _CFBundleCreateWithExecutableURLIfLooksLikeBundle(a1, a2);
  v3 = (__CFBundle *)v2;
  if (v2)
  {
    if (_CFBundleEffectiveLayoutVersion((uint64_t)v2) - 3 <= 1)
    {
      InfoDictionary = CFBundleGetInfoDictionary(v3);
      if (!InfoDictionary || !CFDictionaryGetCount(InfoDictionary))
      {
        CFRelease(v3);
        return 0;
      }
    }
  }
  return v3;
}

CFGregorianUnits *__cdecl CFAbsoluteTimeGetDifferenceAsGregorianUnits(CFGregorianUnits *__return_ptr retstr, CFAbsoluteTime at1, CFAbsoluteTime at2, CFGregorianUnits *tz, CFOptionFlags unitFlags)
{
  int v5;
  CFGregorianUnits *v6;
  uint64_t v10;
  int v11;
  double v12;
  int v13;
  double v14;
  __int128 v15;
  BOOL v16;
  double v17;
  CFGregorianUnits v18;
  uint64_t v19;

  v5 = unitFlags;
  v6 = tz;
  v10 = 0;
  v19 = *MEMORY[0x1E0C80C00];
  if (at2 < at1)
    v11 = 1;
  else
    v11 = -1;
  *(_OWORD *)&retstr->years = 0uLL;
  *(_OWORD *)&retstr->minutes = 0uLL;
  v12 = at2;
  do
  {
    if (((1 << v10) & v5) != 0)
    {
      v13 = (int)((at1 - v12) / (double)dword_182C87E40[v10]);
      *(&retstr->years + v10) = -3 * v11 + v13;
      do
      {
        v14 = v12;
        *(&retstr->years + v10) = -2 * v11 + v13;
        v15 = *(_OWORD *)&retstr->minutes;
        *(_OWORD *)&v18.years = *(_OWORD *)&retstr->years;
        *(_OWORD *)&v18.minutes = v15;
        v12 = CFAbsoluteTimeAddGregorianUnits(at2, (CFTimeZoneRef)v6, &v18);
        v16 = v12 <= at1;
        if (at2 >= at1)
          v16 = v12 >= at1;
        v13 += v11;
      }
      while (v16);
      *(&retstr->years + v10) = -4 * v11 + v13;
      v12 = v14;
    }
    ++v10;
  }
  while (v10 != 5);
  if ((v5 & 0x20) == 0 || (v17 = at1 - v12, retstr->seconds = v17, v17 == 0.0))
    retstr->seconds = 0.0;
  return tz;
}

SInt32 CFAbsoluteTimeGetDayOfYear(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  double SecondsFromGMT;
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  int v9;
  __int16 v11;
  uint64_t v12;
  uint8_t buf[4];
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (tz)
    SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  else
    SecondsFromGMT = 0.0;
  v12 = 0;
  v11 = 0;
  __CFYMDFromAbsolute(vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0), &v12, (unint64_t)&v11 + 1, (unint64_t)&v11);
  v4 = SHIBYTE(v11);
  v5 = HIBYTE(v11);
  if ((SHIBYTE(v11) - 1) >= 0xC && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    v14 = v4;
    _os_log_error_impl(&dword_182A8C000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Month %d is out of bounds", buf, 8u);
    v5 = HIBYTE(v11);
  }
  v6 = (v12 + 1) % 400;
  if (v6 >= 0)
    v7 = (v12 + 1) % 400;
  else
    v7 = -v6;
  if ((v7 & 3) != 0)
  {
    v8 = 0;
  }
  else
  {
    v8 = 0;
    if (v7 != 100 && v7 != 200)
      v8 = v7 != 300;
  }
  if (v5 > 0xF)
  {
    v9 = 0xFFFF;
  }
  else
  {
    if (v5 <= 2)
      v8 = 0;
    v9 = (unsigned __int16)(daysBeforeMonth[v5] + v8);
  }
  return v9 + (char)v11;
}

SInt32 CFAbsoluteTimeGetWeekOfYear(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  double SecondsFromGMT;
  uint64_t v4;
  double v5;
  float v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  SInt32 v11;
  double v12;
  float v13;
  uint64_t v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  int v18;
  __int16 v20;
  uint64_t v21;
  uint8_t buf[4];
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (tz)
    SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  else
    SecondsFromGMT = 0.0;
  v21 = 0;
  v20 = 0;
  __CFYMDFromAbsolute(vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0), &v21, (unint64_t)&v20 + 1, (unint64_t)&v20);
  v4 = v21;
  v5 = __CFAbsoluteFromYMD(v21, 1u, 1);
  v6 = floor(v5 - floor(v5 / 7.0) * 7.0);
  if ((int)v6 >= 0)
    v7 = (int)v6;
  else
    v7 = (int)v6 + 7;
  v8 = SHIBYTE(v20);
  v9 = v20;
  if (SHIBYTE(v20) == 1 && (char)v20 <= 3)
  {
    if (v7 == 4 || (char)v20 <= 2 && v7 == 5)
      return 53;
    v10 = 1;
    if ((char)v20 < 2 && v7 == 6)
      return 53;
  }
  else
  {
    v10 = HIBYTE(v20);
    if (HIBYTE(v20) == 12 && (char)v20 >= 29)
    {
      v11 = 1;
      v12 = __CFAbsoluteFromYMD(v4 + 1, 1u, 1);
      v13 = floor(v12 - floor(v12 / 7.0) * 7.0);
      if ((int)v13 + ((int)v13 < 0 ? 7 : 0) == 3 || v9 >= 0x1E && (int)v13 + ((int)v13 < 0 ? 7 : 0) == 2)
        return v11;
      v10 = 12;
      if (v9 >= 0x1F && (int)v13 + ((int)v13 < 0 ? 7 : 0) == 1)
        return 1;
    }
    else if (HIBYTE(v20) - 1 >= 0xC && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      v23 = v8;
      _os_log_error_impl(&dword_182A8C000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Month %d is out of bounds", buf, 8u);
      v10 = HIBYTE(v20);
      v4 = v21;
    }
  }
  v14 = (v4 + 1) % 400;
  if (v14 >= 0)
    v15 = (v4 + 1) % 400;
  else
    v15 = -v14;
  if ((v15 & 3) != 0)
  {
    v16 = 0;
  }
  else
  {
    v16 = 0;
    if (v15 != 100 && v15 != 200)
      v16 = v15 != 300;
  }
  if (v10 > 0xF)
  {
    v17 = 0xFFFF;
  }
  else
  {
    if (v10 <= 2)
      v16 = 0;
    v17 = (unsigned __int16)(daysBeforeMonth[v10] + v16);
  }
  v18 = (unint64_t)(2454267027 * (v17 + v7 - 10 + (char)v20 - 7 * ((v7 - 10) / 7) + 2)) >> 32;
  return (v18 >> 2) + (v18 >> 31) + 1;
}

CFStringRef __CFDateFormatterCopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  CFAllocatorRef v3;

  v2 = CFGetAllocator(a1);
  v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFDateFormatter %p [%p]>"), a1, v3);
}

CFTypeID CFDateFormatterGetTypeID(void)
{
  return 56;
}

CFDateFormatterStyle CFDateFormatterGetDateStyle(CFDateFormatterRef formatter)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  return *((_QWORD *)formatter + 5);
}

CFDateFormatterStyle CFDateFormatterGetTimeStyle(CFDateFormatterRef formatter)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v2);
  return *((_QWORD *)formatter + 4);
}

__CFAttributedString *_CFDateFormatterCreateAttributedStringAndFieldsWithAbsoluteTime(const __CFAllocator *a1, uint64_t a2, double a3)
{
  const __CFAllocator *v5;
  uint64_t v6;
  unint64_t v7;
  double v8;
  uint64_t v9;
  int v10;
  CFIndex v11;
  int v12;
  UniChar *Typed;
  uint64_t v14;
  const __CFString *v15;
  CFIndex Length;
  __CFAttributedString *Mutable;
  unsigned int i;
  CFStringRef v19;
  UniChar *v21;
  const __CFString *Identifier;
  int v23;
  char v24;
  UniChar v25[768];
  uint64_t v26;
  CFRange v27;
  CFRange v28;

  v5 = a1;
  v26 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v6 = _CFGetTSD(1u);
    if (v6)
      v5 = (const __CFAllocator *)v6;
    else
      v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  v7 = _CFGetNonObjCTypeID((unint64_t *)a2);
  if (v7 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v7);
  v23 = 0;
  v8 = (a3 + 978307200.0) * 1000.0 + 0.5;
  v9 = ufieldpositer_open();
  v10 = __cficu_udat_formatForFields(*(_QWORD *)(a2 + 16), v25, 768, v9, &v23, v8);
  v11 = v10;
  v12 = v23;
  if (v23 == 15 || v10 >= 769)
  {
    v14 = v10 + 2;
    Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * v14, 0x1000040BDFB0063, 0);
    v23 = 0;
    ufieldpositer_close();
    v9 = ufieldpositer_open();
    v11 = (int)__cficu_udat_formatForFields(*(_QWORD *)(a2 + 16), Typed + 1, v14, v9, &v23, v8);
    v12 = v23;
  }
  else
  {
    Typed = 0;
  }
  if (v12 > 0)
  {
    v15 = 0;
    if (!Typed)
      goto LABEL_13;
    goto LABEL_12;
  }
  if (Typed)
    v21 = Typed;
  else
    v21 = (UniChar *)&v24;
  if (*(__objc2_class ***)(a2 + 304) == &__kCFBooleanTrue
    && (Identifier = CFLocaleGetIdentifier(*(CFLocaleRef *)(a2 + 24)),
        CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
  {
    *v21 = 8207;
    ++v11;
  }
  else if (Typed)
  {
    v21 = Typed + 1;
  }
  else
  {
    v21 = v25;
  }
  v15 = CFStringCreateWithCharacters(v5, v21, v11);
  if (Typed)
LABEL_12:
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
LABEL_13:
  if (!v15)
  {
    Mutable = 0;
    if (!v9)
      return Mutable;
    goto LABEL_19;
  }
  Length = CFStringGetLength(v15);
  Mutable = CFAttributedStringCreateMutable(v5, Length);
  v27.location = 0;
  v27.length = 0;
  CFAttributedStringReplaceString(Mutable, v27, v15);
  CFRelease(v15);
  for (i = ufieldpositer_next(); (i & 0x80000000) == 0; i = ufieldpositer_next())
  {
    if (i <= 0x23)
    {
      v19 = CFStringCreateWithBytes(v5, (const UInt8 *)&aGymdkhmssedfww[i], 1, 0x600u, 0);
      v28.location = 0;
      v28.length = 0;
      CFAttributedStringSetAttribute(Mutable, v28, CFSTR("kCFDateFormatterPatternCharacterKey"), v19);
      CFRelease(v19);
    }
  }
  if (v9)
LABEL_19:
    ufieldpositer_close();
  return Mutable;
}

uint64_t _CFDateFormatterCreateSkeletonFromTemplate(const __CFString *a1, const __CFLocale *a2, _DWORD *a3)
{
  CFIndex Length;
  int v7;
  uint64_t v8;
  _QWORD v10[8];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  if (Length)
  {
    v11 = 0;
    v12 = &v11;
    v13 = 0x2020000000;
    v14 = 0;
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3221225472;
    v10[2] = ___CFDateFormatterCreateSkeletonFromTemplate_block_invoke;
    v10[3] = &unk_1E12E13F0;
    v10[4] = &v11;
    v10[5] = Length;
    v10[6] = a1;
    v10[7] = a3;
    v7 = useTemplatePatternGenerator(a2, (uint64_t)v10);
    v8 = v12[3];
    if (!v7 && v8)
    {
      CFRelease((CFTypeRef)v12[3]);
      v8 = 0;
      v12[3] = 0;
    }
    _Block_object_dispose(&v11, 8);
  }
  else
  {
    v8 = 0;
    if (a3)
      *a3 = 1;
  }
  return v8;
}

void sub_182BB92E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __useTemplatePatternGenerator_block_invoke()
{
  __cficu_udatpg_close((const void *)useTemplatePatternGenerator_ptg);
  useTemplatePatternGenerator_ptg = 0;
  free((void *)useTemplatePatternGenerator_ptgLocaleName);
  useTemplatePatternGenerator_ptgLocaleName = 0;
}

void __useTemplatePatternGenerator_block_invoke_2(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&useTemplatePatternGenerator_ptgLock);
  dispatch_source_cancel((dispatch_source_t)useTemplatePatternGenerator_pressureSrc);
  dispatch_release((dispatch_object_t)useTemplatePatternGenerator_pressureSrc);
  useTemplatePatternGenerator_pressureSrc = 0;
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  os_unfair_lock_unlock((os_unfair_lock_t)&useTemplatePatternGenerator_ptgLock);
}

uint64_t __CFDateFormatterStoreSymbolPrefs(const __CFString *a1, const void *a2, _QWORD *a3)
{
  CFTypeID v6;
  uint64_t result;
  CFTypeID v8;
  SInt32 IntValue;
  uint64_t *v10;
  const void *v11;
  uint64_t v12;
  CFIndex v13;
  const void **v14;
  const void **v15;
  const void *ValueAtIndex;
  CFTypeID v17;
  const void *v18;
  _QWORD *v19;

  v6 = CFGetTypeID(a1);
  result = CFStringGetTypeID();
  if (v6 == result)
  {
    v8 = CFGetTypeID(a2);
    result = CFArrayGetTypeID();
    if (v8 == result)
    {
      IntValue = CFStringGetIntValue(a1);
      result = CFArrayGetCount((CFArrayRef)a2);
      switch(IntValue)
      {
        case 0:
          v10 = a3 + 40;
          v11 = (const void *)a3[40];
          if (v11)
            goto LABEL_51;
          goto LABEL_52;
        case 1:
          v10 = a3 + 42;
          v11 = (const void *)a3[42];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 2:
          v10 = a3 + 43;
          v11 = (const void *)a3[43];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 3:
          v10 = a3 + 48;
          v11 = (const void *)a3[48];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 4:
          v10 = a3 + 49;
          v11 = (const void *)a3[49];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 5:
          v12 = result;
          if (result < 1)
            return result;
          v13 = 0;
          v14 = (const void **)(a3 + 63);
          v15 = (const void **)(a3 + 62);
          break;
        case 7:
          v10 = a3 + 41;
          v11 = (const void *)a3[41];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 8:
          v10 = a3 + 44;
          v11 = (const void *)a3[44];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 9:
          v10 = a3 + 50;
          v11 = (const void *)a3[50];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 10:
          v10 = a3 + 45;
          v11 = (const void *)a3[45];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 11:
          v10 = a3 + 46;
          v11 = (const void *)a3[46];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 12:
          v10 = a3 + 47;
          v11 = (const void *)a3[47];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 13:
          v10 = a3 + 51;
          v11 = (const void *)a3[51];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 14:
          v10 = a3 + 52;
          v11 = (const void *)a3[52];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 15:
          v10 = a3 + 53;
          v11 = (const void *)a3[53];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 16:
          v10 = a3 + 54;
          v11 = (const void *)a3[54];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 17:
          v10 = a3 + 55;
          v11 = (const void *)a3[55];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 18:
          v10 = a3 + 56;
          v11 = (const void *)a3[56];
          if (!v11)
            goto LABEL_52;
          goto LABEL_51;
        case 19:
          v10 = a3 + 57;
          v11 = (const void *)a3[57];
          if (v11)
LABEL_51:
            CFRelease(v11);
LABEL_52:
          result = (uint64_t)CFRetain(a2);
          *v10 = result;
          return result;
        default:
          return result;
      }
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v13);
        v17 = CFGetTypeID(ValueAtIndex);
        result = CFStringGetTypeID();
        if (v17 == result)
        {
          if (v13 == 1)
          {
            v18 = *v14;
            v19 = v14;
            if (*v14)
              goto LABEL_22;
            goto LABEL_23;
          }
          if (!v13)
          {
            v18 = *v15;
            v19 = v15;
            if (!*v15)
              goto LABEL_23;
LABEL_22:
            CFRelease(v18);
LABEL_23:
            result = (uint64_t)CFRetain(ValueAtIndex);
            *v19 = result;
          }
        }
        ++v13;
      }
      while (v12 != v13);
    }
  }
  return result;
}

void __CFDateFormatterSetSymbolsArray(uint64_t a1, unsigned int a2, int a3, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  int v10;
  const __CFString *ValueAtIndex;
  CFIndex Length;
  uint64_t v13;
  uint64_t v14;
  CFIndex v15;
  uint64_t v16;
  UniChar *v17;
  const UniChar *CharactersPtr;
  UChar *v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  CFRange v23;

  v20 = a2;
  v22 = *MEMORY[0x1E0C80C00];
  v21 = 0;
  Count = CFArrayGetCount(theArray);
  if (Count >= 1)
  {
    v8 = Count;
    v9 = 0;
    v10 = a3;
    do
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v9);
      Length = CFStringGetLength(ValueAtIndex);
      v14 = Length;
      if (Length >= 768)
        v15 = 768;
      else
        v15 = Length;
      MEMORY[0x1E0C80A78](Length, v13);
      v17 = (UniChar *)((char *)&v20 - v16);
      CharactersPtr = CFStringGetCharactersPtr(ValueAtIndex);
      if (CharactersPtr)
      {
        v19 = (UChar *)CharactersPtr;
      }
      else
      {
        v23.location = 0;
        v23.length = v15;
        CFStringGetCharacters(ValueAtIndex, v23, v17);
        v14 = v15;
        v19 = v17;
      }
      v21 = 0;
      __cficu_udat_setSymbols(a1, v20, (v10 + v9++), v19, v14, &v21);
    }
    while (v8 != v9);
  }
}

double __CFDateFormatterCorrectTimeWithTarget(uint64_t a1, int a2, int a3, int *a4, double a5)
{
  __cficu_ucal_setMillis(a1, a4, a5);
  __cficu_ucal_set(a1, a3 == 0, a2);
  return __cficu_ucal_getMillis(a1, a4);
}

double __CFDateFormatterCorrectTimeToARangeAroundCurrentDate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int *a6, double a7)
{
  double Now;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;

  Now = __cficu_ucal_getNow();
  __cficu_ucal_setMillis(a1, a6, Now);
  v15 = __cficu_ucal_get(a1, 1u, a6);
  v16 = __cficu_ucal_get(a1, a5 == 0, a6);
  v17 = v16;
  if (a5)
  {
    v18 = a4 + v15;
    v19 = v15 - a3;
    v20 = v18 <= a2;
    v21 = v18 - a2;
    if (v20)
      v22 = -1;
    else
      v22 = 1;
    if (v20)
      v23 = 0;
    else
      v23 = v21;
    if (v19 >= 1)
      v24 = -1;
    else
      v24 = v19 + a2;
    if (v19 >= 1)
      v25 = 0;
    else
      v25 = 1 - v19;
  }
  else
  {
    v17 = 100 * (v16 / 100);
    v26 = a4 + v15 % 100;
    v27 = v15 % 100 - a3;
    v28 = v26 < a2;
    v29 = v26 - a2;
    if (v28)
      v22 = -1;
    else
      v22 = 0;
    if (v28)
      v23 = 0;
    else
      v23 = v29 + 1;
    if (v27 >= 0)
      v24 = -1;
    else
      v24 = v27 + a2;
    v25 = -v27 & (v27 >> 63);
  }
  __cficu_ucal_setMillis(a1, a6, a7);
  v30 = __cficu_ucal_get(a1, 1u, a6);
  v31 = v30 % 100;
  v32 = v30 % 100 + v17;
  if (a5)
  {
    v32 = v17;
    v31 = v30;
  }
  if (v24 == -1 || v31 < v24 || v31 - v24 >= v25)
  {
    if (v22 == -1)
    {
      v33 = 0;
    }
    else
    {
      v20 = v31 < v22;
      v34 = v31 - v22;
      v33 = !v20 && v34 < v23;
    }
  }
  else
  {
    v33 = -1;
  }
  if (!a5)
    v33 *= 100;
  return __CFDateFormatterCorrectTimeWithTarget(a1, v33 + v32, a5, a6, a7);
}

uint64_t __CFDateFormatterGetMaxYearGivenJapaneseEra(uint64_t a1, int a2, int *a3)
{
  double Millis;

  __cficu_ucal_clear(a1);
  __cficu_ucal_set(a1, 0, a2 + 1);
  Millis = __cficu_ucal_getMillis(a1, a3);
  __cficu_ucal_set(a1, 0, a2);
  return __cficu_ucal_getFieldDifference(a1, 1u, a3, Millis) + 1;
}

uint64_t _CFDictionaryGetKVOBit(uint64_t a1)
{
  char v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

uint64_t _CFDictionarySetKVOBit(uint64_t result, char a2)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  int v5;

  v2 = (unint64_t *)(result + 8);
  v3 = atomic_load((unint64_t *)(result + 8));
  do
  {
    v4 = __ldaxr(v2);
    if (v4 == v3)
    {
      if (!__stlxr(v3 & 0xFFFFFFFFFFFFFFFELL | a2 & 1, v2))
      {
        v5 = 1;
        goto LABEL_7;
      }
    }
    else
    {
      __clrex();
    }
    v5 = 0;
LABEL_7:
    v3 = v4;
  }
  while (!v5);
  return result;
}

CFMutableStringRef _CFDoubledStringCreate(const __CFString *a1)
{
  CFMutableStringRef Mutable;
  CFRange v4;

  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFStringAppend(Mutable, a1);
  v4.length = CFStringGetLength(Mutable);
  v4.location = 0;
  CFStringFindAndReplace(Mutable, CFSTR("%"), &stru_1E1337B18, v4, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR(" %@"), a1);
  return Mutable;
}

CFStringRef _CFAffixedStringCreate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@"), a2, a1, a3);
}

CFStringRef _CFRLORightToLeftStringCreate(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("%C%@%C"), 8238, a1, 8236);
}

CFStringRef _CFAccentuatedStringCreate(const __CFString *a1)
{
  if (_CFAccentuatedStringCreate_onceToken != -1)
    dispatch_once(&_CFAccentuatedStringCreate_onceToken, &__block_literal_global_2);
  return __CFPseudoLanguageStringCreateWithTransform(a1, 2, (const __CFCharacterSet *)_CFAccentuatedStringCreate_charsToSkip, (uint64_t)&__block_literal_global_12);
}

CFStringRef __CFPseudoLanguageStringCreateWithTransform(const __CFString *a1, uint64_t a2, const __CFCharacterSet *a3, uint64_t a4)
{
  CFIndex Length;
  const __CFString *MutableCopy;
  CFIndex v10;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  UniChar *v13;
  CFIndex v14;
  CFRange RangeOfComposedCharactersAtIndex;
  CFIndex v16;
  CFIndex v17;
  UniChar v18;
  CFIndex v19;
  CFIndex v20;
  CFIndex v21;
  uint64_t v22;
  CFIndex v23;
  const __CFString *MutableWithExternalCharactersNoCopy;
  CFStringRef Copy;
  CFIndex capacity;
  UniChar buffer[8];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  CFStringRef theString;
  const UniChar *v37;
  const char *v38;
  uint64_t v39;
  CFIndex v40;
  CFIndex v41;
  CFIndex v42;
  uint64_t v43;
  CFRange v44;

  v43 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  MutableCopy = CFStringCreateMutableCopy(0, Length, a1);
  v10 = CFStringGetLength(MutableCopy);
  theString = MutableCopy;
  v39 = 0;
  v40 = v10;
  CharactersPtr = CFStringGetCharactersPtr(MutableCopy);
  CStringPtr = 0;
  v37 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(MutableCopy, 0x600u);
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  *(_OWORD *)buffer = 0u;
  v29 = 0u;
  v41 = 0;
  v42 = 0;
  v38 = CStringPtr;
  v13 = (UniChar *)malloc_type_malloc(2 * a2 * v10 + 2, 0x1000040BDFB0063uLL);
  capacity = 0;
  if (v10 < 1)
  {
    v23 = 0;
  }
  else
  {
    v14 = 0;
    do
    {
      RangeOfComposedCharactersAtIndex = CFStringGetRangeOfComposedCharactersAtIndex(MutableCopy, v14);
      if (RangeOfComposedCharactersAtIndex.length < 1)
      {
        v16 = v14;
      }
      else
      {
        v16 = RangeOfComposedCharactersAtIndex.length + v14;
        do
        {
          if (v14 < 0 || (v17 = v40, v40 <= v14))
          {
            v18 = 0;
          }
          else if (v37)
          {
            v18 = v37[v39 + v14];
          }
          else if (v38)
          {
            v18 = v38[v39 + v14];
          }
          else
          {
            if (v42 <= v14 || (v20 = v41, v41 > v14))
            {
              v21 = v14 - 4;
              if ((unint64_t)v14 < 4)
                v21 = 0;
              if (v21 + 64 < v40)
                v17 = v21 + 64;
              v41 = v21;
              v42 = v17;
              v44.location = v39 + v21;
              v44.length = v17 - v21;
              CFStringGetCharacters(theString, v44, buffer);
              v20 = v41;
            }
            v18 = buffer[v14 - v20];
          }
          ++v14;
          v19 = capacity++;
          v13[v19] = v18;
        }
        while (v14 != v16);
        if (RangeOfComposedCharactersAtIndex.length == 1)
        {
          v22 = v18;
          if (!CFCharacterSetIsCharacterMember(a3, v18))
            (*(void (**)(uint64_t, UniChar *, CFIndex *, uint64_t))(a4 + 16))(a4, v13, &capacity, v22);
        }
      }
      v14 = v16;
    }
    while (v16 < v10);
    v23 = capacity;
  }
  v13[v23] = 0;
  MutableWithExternalCharactersNoCopy = CFStringCreateMutableWithExternalCharactersNoCopy(0, v13, v23, v23, (CFAllocatorRef)&__kCFAllocatorNull);
  Copy = CFStringCreateCopy(0, MutableWithExternalCharactersNoCopy);
  CFRelease(MutableCopy);
  CFRelease(MutableWithExternalCharactersNoCopy);
  free(v13);
  return Copy;
}

CFStringRef _CFTallStringCreate(uint64_t a1)
{
  CFStringRef v2;
  const __CFString *v3;
  const __CFCharacterSet *Predefined;
  CFStringRef v5;

  v2 = CFStringCreateWithCharacters(0, _CFTallStringCreate_tallCharacters, 7);
  v3 = CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@"), v2, a1, v2);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetNonBase);
  v5 = __CFPseudoLanguageStringCreateWithTransform(v3, 7, Predefined, (uint64_t)&__block_literal_global_14);
  CFRelease(v2);
  CFRelease(v3);
  return v5;
}

BOOL __CFErrorEqual(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  CFDictionaryRef v10;
  _BOOL8 v11;

  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
    v4 = objc_msgSend(a1, "code");
  else
    v4 = a1[2];
  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a2))
    v5 = objc_msgSend(a2, "code");
  else
    v5 = a2[2];
  if (v4 != v5)
    return 0;
  v6 = (const void *)(CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1) ? objc_msgSend(a1, "domain") : a1[3]);
  v7 = (const void *)(CF_IS_OBJC(0x1BuLL, (__objc2_class **)a2) ? objc_msgSend(a2, "domain") : a2[3]);
  if (!CFEqual(v6, v7))
    return 0;
  v8 = CFErrorCopyUserInfo((CFErrorRef)a1);
  v9 = CFErrorCopyUserInfo((CFErrorRef)a2);
  v10 = v9;
  if (v8 == v9)
  {
    v11 = 1;
    goto LABEL_21;
  }
  v11 = 0;
  if (!v8 || !v9)
  {
LABEL_21:
    if (!v8)
      goto LABEL_23;
    goto LABEL_22;
  }
  v11 = CFEqual(v8, v9) != 0;
LABEL_22:
  CFRelease(v8);
LABEL_23:
  if (v10)
    CFRelease(v10);
  return v11;
}

CFHashCode __CFErrorHash(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16) + CFHash(*(CFTypeRef *)(a1 + 24));
}

CFStringRef __CFErrorCopyFormattingDescription(__CFError *a1)
{
  if (dyld_program_sdk_at_least())
    return (CFStringRef)_CFErrorCreateDebugDescription(a1);
  else
    return CFErrorCopyDescription(a1);
}

const void *_CFErrorCreateLocalizedRecoverySuggestion(_QWORD *a1)
{
  return _CFErrorCopyUserInfoKey(a1, CFSTR("NSLocalizedRecoverySuggestion"));
}

uint64_t _CFErrorCreateUnlocalizedDebugDescription(_QWORD *a1)
{
  _QWORD v3[4];

  v3[3] = *MEMORY[0x1E0C80C00];
  v3[1] = 0;
  v3[0] = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  v3[2] = 0;
  _CFErrorFormatDebugDescriptionAux(a1, (uint64_t)v3);
  return v3[0];
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  CFStringRef result;

  if (!CF_IS_OBJC(0x1BuLL, (__objc2_class **)err))
    return _CFErrorCreateLocalizedDescription(err);
  result = (CFStringRef)-[__CFError localizedDescription](err, "localizedDescription");
  if (result)
    return (CFStringRef)CFRetain(result);
  return result;
}

CFStringRef CFErrorCopyFailureReason(CFErrorRef err)
{
  CFStringRef result;

  if (!CF_IS_OBJC(0x1BuLL, (__objc2_class **)err))
    return (CFStringRef)_CFErrorCopyUserInfoKey(err, CFSTR("NSLocalizedFailureReason"));
  result = (CFStringRef)-[__CFError localizedFailureReason](err, "localizedFailureReason");
  if (result)
    return (CFStringRef)CFRetain(result);
  return result;
}

CFStringRef CFErrorCopyRecoverySuggestion(CFErrorRef err)
{
  CFStringRef result;

  if (!CF_IS_OBJC(0x1BuLL, (__objc2_class **)err))
    return (CFStringRef)_CFErrorCopyUserInfoKey(err, CFSTR("NSLocalizedRecoverySuggestion"));
  result = (CFStringRef)-[__CFError localizedRecoverySuggestion](err, "localizedRecoverySuggestion");
  if (result)
    return (CFStringRef)CFRetain(result);
  return result;
}

const void *CFErrorGetCallBackBlockForDomain(const void *a1)
{
  const void *Value;

  if (!_CFErrorCallBackTable)
    _CFErrorInitializeCallBackTable();
  os_unfair_lock_lock_with_options();
  if (_CFErrorCallBackTable)
    Value = CFDictionaryGetValue((CFDictionaryRef)_CFErrorCallBackTable, a1);
  else
    Value = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
  return Value;
}

void CFErrorSetCallBackForDomain(const void *a1, _QWORD *a2)
{
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 3221225472;
    v2[2] = __CFErrorSetCallBackForDomain_block_invoke;
    v2[3] = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    v2[4] = a2;
    a2 = v2;
  }
  CFErrorSetCallBackBlockForDomain(a1, a2);
}

uint64_t CFErrorGetCallBackForDomain()
{
  return 0;
}

void blockReleaseValueCallBack(int a1, void *aBlock)
{
  _Block_release(aBlock);
}

CFStringRef _CFErrorMachCallBack(uint64_t a1, CFTypeRef cf1)
{
  uint64_t v3;
  char *v4;

  if (CFEqual(cf1, CFSTR("NSDescription"))
    && (!CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1)
      ? (v3 = *(_QWORD *)(a1 + 16))
      : (LODWORD(v3) = objc_msgSend((id)a1, "code")),
        (v4 = mach_error_string(v3)) != 0 && *v4))
  {
    return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4, 0x8000100u);
  }
  else
  {
    return 0;
  }
}

void __CFFileDescriptorDeallocate(uint64_t a1)
{
  NSObject *v2;
  __CFRunLoopSource *v3;
  uint64_t v4;
  void (*v5)(uint64_t);
  _QWORD v6[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    v11 = 0;
    v12 = &v11;
    v13 = 0x2000000000;
    v14 = 0;
    v7 = 0;
    v8 = &v7;
    v9 = 0x2000000000;
    v10 = 0;
    v2 = __fdQueue();
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = ____CFFileDescriptorDeallocate_block_invoke;
    v6[3] = &unk_1E12E1838;
    v6[5] = &v11;
    v6[6] = a1;
    v6[4] = &v7;
    dispatch_sync(v2, v6);
    if (*((_BYTE *)v8 + 24))
    {
      v3 = (__CFRunLoopSource *)v12[3];
      if (v3)
      {
        CFRunLoopSourceInvalidate(v3);
        CFRelease((CFTypeRef)v12[3]);
      }
      v4 = *(_QWORD *)(a1 + 80);
      *(_QWORD *)(a1 + 80) = 0;
      v5 = *(void (**)(uint64_t))(a1 + 96);
      if (v5)
        v5(v4);
      *(_DWORD *)(a1 + 16) = 2;
      __dmb(0xBu);
    }
    *(_DWORD *)(a1 + 16) = 3;
    _Block_object_dispose(&v7, 8);
    _Block_object_dispose(&v11, 8);
  }
}

void sub_182BBB460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 72), 8);
  _Unwind_Resume(a1);
}

CFStringRef __CFFileDescriptorCopyDescription(uint64_t a1)
{
  uint64_t v2;
  uint64_t (*v3)(void);
  CFStringRef v4;
  void *v5;
  const char *dli_sname;
  CFAllocatorRef v8;
  const char *v9;
  CFStringRef v10;
  Dl_info v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 80);
  if (!v2)
    goto LABEL_5;
  v3 = *(uint64_t (**)(void))(a1 + 104);
  if (!v3)
    goto LABEL_5;
  v4 = (CFStringRef)v3();
  if (!v4)
  {
    v2 = *(_QWORD *)(a1 + 80);
LABEL_5:
    v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFFileDescriptor context %p>"), v2);
  }
  memset(&v12, 0, sizeof(v12));
  v5 = *(void **)(a1 + 64);
  dli_sname = "???";
  if (dladdr(v5, &v12))
  {
    if (v12.dli_sname && v12.dli_saddr == v5)
      dli_sname = v12.dli_sname;
  }
  v8 = CFGetAllocator((CFTypeRef)a1);
  v9 = "No";
  if (!*(_DWORD *)(a1 + 16))
    v9 = "Yes";
  v10 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFFileDescriptor %p [%p]>{valid = %s, fd = %x, source = %p, callout = %s (%p), context = %@}"), a1, v8, v9, *(unsigned int *)(a1 + 20), *(_QWORD *)(a1 + 56), dli_sname, v5, v4);
  if (v4)
    CFRelease(v4);
  return v10;
}

CFTypeID CFFileDescriptorGetTypeID(void)
{
  if (CFFileDescriptorGetTypeID_initOnce != -1)
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  return 60;
}

CFFileDescriptorRef CFFileDescriptorCreate(CFAllocatorRef allocator, CFFileDescriptorNativeDescriptor fd, Boolean closeOnInvalidate, CFFileDescriptorCallBack callout, const CFFileDescriptorContext *context)
{
  unsigned int st_mode;
  int v11;
  int v12;
  int v13;
  BOOL v14;
  NSObject *v15;
  __CFFileDescriptor *v16;
  _QWORD block[8];
  CFFileDescriptorNativeDescriptor v19;
  int v20;
  int v21;
  Boolean v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  stat v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) != 0)
    return 0;
  memset(&v27, 0, sizeof(v27));
  if (fstat(fd, &v27) < 0)
    return 0;
  st_mode = v27.st_mode;
  v11 = v27.st_mode & 0x180;
  if (v11 == 128)
  {
    v12 = -1;
    if ((v27.st_mode & 0x80) == 0)
      goto LABEL_9;
  }
  else
  {
    v12 = fcntl(fd, 67, 3);
    if ((st_mode & 0x80) == 0)
    {
LABEL_9:
      v13 = -1;
      goto LABEL_12;
    }
  }
  v13 = fcntl(fd, 67, 3);
LABEL_12:
  v14 = v12 >= 0 || v11 == 128;
  if (!v14 || ((v13 < 0) & (st_mode >> 7)) != 0)
  {
    if ((v12 & 0x80000000) == 0)
      close(v12);
    if ((v13 & 0x80000000) == 0)
      close(v13);
    return 0;
  }
  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 0;
  v15 = __fdQueue();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __CFFileDescriptorCreate_block_invoke;
  block[3] = &unk_1E12E1760;
  v22 = closeOnInvalidate;
  v19 = fd;
  v20 = v12;
  v21 = v13;
  block[6] = callout;
  block[7] = context;
  block[4] = &v23;
  block[5] = allocator;
  dispatch_sync(v15, block);
  v16 = (__CFFileDescriptor *)v24[3];
  if (!v16)
  {
    close(v12);
    close(v13);
    v16 = (__CFFileDescriptor *)v24[3];
  }
  _Block_object_dispose(&v23, 8);
  return v16;
}

void sub_182BBB8F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CFFileDescriptorGetContext(CFFileDescriptorRef f, CFFileDescriptorContext *context)
{
  unint64_t v4;
  __int128 v5;
  __int128 v6;

  if (CFFileDescriptorGetTypeID_initOnce != -1)
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  v4 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v4 != 60)
    _CFAssertMismatchedTypeID(0x3CuLL, v4);
  v5 = *(_OWORD *)((char *)f + 72);
  v6 = *(_OWORD *)((char *)f + 88);
  context->copyDescription = (CFStringRef (__cdecl *)(void *))*((_QWORD *)f + 13);
  *(_OWORD *)&context->version = v5;
  *(_OWORD *)&context->retain = v6;
}

void _CFFileDescriptorInduceFakeReadCallBack(uint64_t a1)
{
  NSObject *v2;
  _QWORD v3[6];

  v3[5] = *MEMORY[0x1E0C80C00];
  v2 = __fdQueue();
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ___CFFileDescriptorInduceFakeReadCallBack_block_invoke;
  v3[3] = &__block_descriptor_tmp_7;
  v3[4] = a1;
  dispatch_async(v2, v3);
}

BOOL cffd_is_writeable(unsigned int a1)
{
  size_t v2;
  void *v3;
  int v4;
  uint64_t v5;
  int v6;
  _BOOL8 v7;

  if (a1 >= 0x100000)
    __break(1u);
  v2 = ((a1 + 8) >> 3) + 7;
  v3 = malloc_type_malloc(v2, 0xEF2DA67DuLL);
  v4 = 1 << a1;
  v5 = a1 >> 5;
  while (1)
  {
    bzero(v3, v2);
    if (__darwin_check_fd_set_overflow(a1, v3, 1))
      *((_DWORD *)v3 + v5) |= v4;
    v6 = pselect_DARWIN_EXTSN();
    if ((v6 & 0x80000000) == 0)
      break;
    if (*__error() != 4 && *__error() != 35)
      goto LABEL_12;
  }
  if (v6 && __darwin_check_fd_set_overflow(a1, v3, 1))
  {
    v7 = (*((_DWORD *)v3 + v5) & v4) != 0;
    goto LABEL_13;
  }
LABEL_12:
  v7 = 0;
LABEL_13:
  free(v3);
  return v7;
}

void CFFileDescriptorDisableCallBacks(CFFileDescriptorRef f, CFOptionFlags callBackTypes)
{
  unint64_t v4;
  NSObject *v5;
  _QWORD block[7];

  block[6] = *MEMORY[0x1E0C80C00];
  if (CFFileDescriptorGetTypeID_initOnce != -1)
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  v4 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v4 != 60)
    _CFAssertMismatchedTypeID(0x3CuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    v5 = __fdQueue();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __CFFileDescriptorDisableCallBacks_block_invoke;
    block[3] = &__block_descriptor_tmp_9;
    block[4] = f;
    block[5] = callBackTypes;
    dispatch_sync(v5, block);
  }
}

void CFFileDescriptorInvalidate(CFFileDescriptorRef f)
{
  unint64_t v2;
  NSObject *v3;
  __CFRunLoopSource *v4;
  uint64_t v5;
  void (*v6)(uint64_t);
  _QWORD v7[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (CFFileDescriptorGetTypeID_initOnce != -1)
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  v2 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v2 != 60)
    _CFAssertMismatchedTypeID(0x3CuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    CFRetain(f);
    v12 = 0;
    v13 = &v12;
    v14 = 0x2000000000;
    v15 = 0;
    v8 = 0;
    v9 = &v8;
    v10 = 0x2000000000;
    v11 = 0;
    v3 = __fdQueue();
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = __CFFileDescriptorInvalidate_block_invoke;
    v7[3] = &unk_1E12E17E8;
    v7[5] = &v12;
    v7[6] = f;
    v7[4] = &v8;
    dispatch_sync(v3, v7);
    if (*((_BYTE *)v9 + 24))
    {
      v4 = (__CFRunLoopSource *)v13[3];
      if (v4)
      {
        CFRunLoopSourceInvalidate(v4);
        CFRelease((CFTypeRef)v13[3]);
      }
      v5 = *((_QWORD *)f + 10);
      *((_QWORD *)f + 10) = 0;
      v6 = (void (*)(uint64_t))*((_QWORD *)f + 12);
      if (v6)
        v6(v5);
      *((_DWORD *)f + 4) = 2;
      __dmb(0xBu);
    }
    CFRelease(f);
    _Block_object_dispose(&v8, 8);
    _Block_object_dispose(&v12, 8);
  }
}

void sub_182BBC218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 72), 8);
  _Unwind_Resume(a1);
}

Boolean CFFileDescriptorIsValid(CFFileDescriptorRef f)
{
  unint64_t v2;
  stat v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (CFFileDescriptorGetTypeID_initOnce != -1)
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  v2 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v2 != 60)
    _CFAssertMismatchedTypeID(0x3CuLL, v2);
  if (*((_DWORD *)f + 4))
    return 0;
  memset(&v4, 0, sizeof(v4));
  if (fstat(*((_DWORD *)f + 5), &v4) < 0)
  {
    CFFileDescriptorInvalidate(f);
    return 0;
  }
  return 1;
}

CFRunLoopSourceRef CFFileDescriptorCreateRunLoopSource(CFAllocatorRef allocator, CFFileDescriptorRef f, CFIndex order)
{
  unint64_t v6;
  NSObject *v7;
  __CFRunLoopSource *v8;
  _QWORD block[8];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (CFFileDescriptorGetTypeID_initOnce != -1)
    dispatch_once(&CFFileDescriptorGetTypeID_initOnce, &__block_literal_global_3);
  v6 = _CFGetNonObjCTypeID((unint64_t *)f);
  if (v6 != 60)
    _CFAssertMismatchedTypeID(0x3CuLL, v6);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) != 0 || !CFFileDescriptorIsValid(f))
    return 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v7 = __fdQueue();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __CFFileDescriptorCreateRunLoopSource_block_invoke;
  block[3] = &unk_1E12E1810;
  block[6] = allocator;
  block[7] = order;
  block[4] = &v11;
  block[5] = f;
  dispatch_sync(v7, block);
  v8 = (__CFRunLoopSource *)v12[3];
  _Block_object_dispose(&v11, 8);
  return v8;
}

void __CFFileDescriptorSchedule(int a1, CFRunLoopRef rl)
{
  CFRunLoopWakeUp(rl);
}

CFTypeRef _CFCopyExtensionForAbstractType(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

BOOL _CFCreateDirectory(char *a1)
{
  int v2;
  int v3;

  if (__CFProphylacticAutofsAccess)
  {
    v2 = open("/dev/autofs_nowait", 0);
    v3 = mkdir(a1, 0x1FFu);
    if (v2 != -1)
      close(v2);
  }
  else
  {
    v3 = mkdir(a1, 0x1FFu);
  }
  return v3 == 0;
}

BOOL _CFRemoveDirectory(char *a1)
{
  int v2;
  int v3;

  if (__CFProphylacticAutofsAccess)
  {
    v2 = open("/dev/autofs_nowait", 0);
    v3 = rmdir(a1);
    if (v2 != -1)
      close(v2);
  }
  else
  {
    v3 = rmdir(a1);
  }
  return v3 == 0;
}

BOOL _CFDeleteFile(char *a1)
{
  int v2;
  int v3;

  if (__CFProphylacticAutofsAccess)
  {
    v2 = open("/dev/autofs_nowait", 0);
    v3 = unlink(a1);
    if (v2 != -1)
      close(v2);
  }
  else
  {
    v3 = unlink(a1);
  }
  return v3 == 0;
}

uint64_t _CFWriteBytesToFile(const __CFURL *a1, const void *a2, size_t a3)
{
  uint64_t result;
  int v6;
  int v7;
  int v8;
  int v9;
  int *v10;
  UInt8 buffer[1026];
  stat v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  memset(&v12, 0, sizeof(v12));
  result = CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026);
  if ((_DWORD)result)
  {
    if (__CFProphylacticAutofsAccess)
      v6 = open("/dev/autofs_nowait", 0);
    else
      v6 = -1;
    if (stat((const char *)buffer, &v12) && *__error() != 2 || (v7 = open((const char *)buffer, 1537, 438), v7 < 0))
    {
      if (v6 != -1)
        close(v6);
      return 0;
    }
    else
    {
      v8 = v7;
      if (a3 && write(v7, a2, a3) != a3)
      {
        v9 = *__error();
        close(v8);
        if (v6 != -1)
          close(v6);
        v10 = __error();
        result = 0;
        *v10 = v9;
      }
      else
      {
        fsync(v8);
        close(v8);
        if (v6 != -1)
          close(v6);
        return 1;
      }
    }
  }
  return result;
}

BOOL _CFIsAbsolutePath(unsigned __int16 *a1, uint64_t a2)
{
  int v2;

  if (a2 < 1)
    return 0;
  v2 = *a1;
  return v2 == 126 || v2 == 47;
}

BOOL _CFStripTrailingPathSlashes(unsigned __int16 *a1, uint64_t *a2)
{
  uint64_t v2;
  int v3;
  unsigned int v4;
  _BOOL4 v5;
  uint64_t i;
  uint64_t v7;

  v2 = *a2;
  if (*a2 >= 2 && a1[1] == 58)
  {
    v3 = *a1;
    v4 = v3 - 65;
    v5 = (v3 - 97) < 0x1A;
    if (v4 < 0x1A)
      v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  for (i = 0; ; --i)
  {
    v7 = v2 + i;
    if (v5)
    {
      if (v7 <= 3)
        return i != 0;
    }
    else if (v7 < 2)
    {
      return i != 0;
    }
    if (a1[v2 - 1 + i] != 47)
      break;
    *a2 = v2 + i - 1;
  }
  return i != 0;
}

void _CFAppendConditionalTrailingPathSlash2(__CFString *a1)
{
  CFIndex Length;

  Length = CFStringGetLength(a1);
  if (CFStringGetCharacterAtIndex(a1, Length - 1) != 47)
    CFStringAppendCharacters(a1, &_CFAppendConditionalTrailingPathSlash2_slash, 1);
}

uint64_t _CFAppendPathComponent(unsigned __int16 *a1, uint64_t *a2, uint64_t a3, void *__src, uint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  int v11;
  int v12;

  if (!a5)
    return 1;
  v7 = *a2;
  v8 = *a2 + 1;
  if (v8 + a5 > a3)
    return 0;
  if (v7 < a3 && v7 != 0)
  {
    if (v7 != 2)
    {
      if (v7 == 1 && *a1 == 47)
      {
        v7 = 1;
        goto LABEL_20;
      }
LABEL_19:
      *a2 = v8;
      a1[v7] = 47;
      v7 = v8;
      goto LABEL_20;
    }
    v11 = a1[1];
    v12 = *a1;
    if (v11 == 58)
    {
      if ((v12 & 0xFFFFFFDF) - 65 >= 0x1A)
        goto LABEL_19;
    }
    else if (v11 != 92 || v12 != 92)
    {
      goto LABEL_19;
    }
    v7 = 2;
  }
LABEL_20:
  memmove(&a1[v7], __src, 2 * a5);
  *a2 += a5;
  return 1;
}

uint64_t _CFAppendPathExtension(unsigned __int16 *a1, uint64_t *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5)
{
  int v9;
  uint64_t result;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  unsigned __int16 *v16;
  int v17;

  if (a5 + *a2 + 1 > a3)
    return 0;
  if (a5 >= 1)
  {
    v9 = *a4;
    if (v9 == 47 || (unint64_t)a5 >= 2 && a4[1] == 58 && (v9 & 0xFFFFFFDF) - 65 < 0x1A)
      return 0;
  }
  _CFStripTrailingPathSlashes(a1, a2);
  v11 = *a2;
  result = 0;
  switch(*a2)
  {
    case 0:
      return result;
    case 1:
      result = 0;
      v12 = *a1;
      if (v12 != 47 && v12 != 126)
        goto LABEL_29;
      return result;
    case 2:
      v13 = a1[1];
      v14 = *a1;
      if (v13 == 58)
      {
        if ((v14 & 0xFFFFFFDF) - 65 < 0x1A)
          return 0;
        goto LABEL_22;
      }
      if (v14 != 92)
        goto LABEL_22;
      if (v13 == 92)
        return 0;
      goto LABEL_29;
    case 3:
      if (a1[2] == 47 && a1[1] == 58 && (*a1 & 0xFFDFu) - 65 < 0x1A)
        return 0;
      goto LABEL_21;
    default:
      if (v11 < 1)
        goto LABEL_29;
LABEL_21:
      v14 = *a1;
LABEL_22:
      if (v14 != 126)
        goto LABEL_29;
      v15 = v11 - 1;
      v16 = a1 + 1;
      break;
  }
  while (1)
  {
    v17 = *v16++;
    if (v17 == 47)
      break;
    if (!--v15)
      return 0;
  }
LABEL_29:
  *a2 = v11 + 1;
  a1[v11] = 46;
  memmove(&a1[v11 + 1], a4, 2 * a5);
  *a2 += a5;
  return 1;
}

BOOL _CFTransmutePathSlashes(_WORD *a1, uint64_t *a2, __int16 a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v3 = *a2;
  if (*a2 >= 2 && *a1 == 92)
    v4 = 2 * (a1[1] == 92);
  else
    v4 = 0;
  if (v4 >= v3)
  {
    v5 = v4;
  }
  else
  {
    v5 = v4;
    while (1)
    {
      v6 = (unsigned __int16)a1[v4];
      if (v6 == 47)
        break;
      v9 = v4 + 1;
      a1[v5] = v6;
LABEL_16:
      ++v5;
      v4 = v9;
      if (v9 >= v3)
        goto LABEL_20;
    }
    a1[v5] = a3;
    if (v3 <= v4 + 1)
      v7 = v4 + 1;
    else
      v7 = v3;
    v8 = v7 - 1;
    while (v8 != v4)
    {
      v9 = v4 + 1;
      v10 = (unsigned __int16)a1[++v4];
      if (v10 != 47)
        goto LABEL_16;
    }
    ++v5;
  }
LABEL_20:
  *a2 = v5;
  return v3 != v5;
}

uint64_t _cfmp_log_failure(uint64_t a1, int *a2, int a3, int a4)
{
  _BOOL4 v8;
  unsigned int v9;
  int v10;
  int v11;
  int v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  unsigned int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v8 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR);
  if (a2)
  {
    if (v8)
    {
      v9 = *((unsigned __int8 *)a2 + 5);
      v10 = *((unsigned __int8 *)a2 + 4);
      v11 = *a2;
      v13 = 136449283;
      v14 = a1;
      v15 = 1025;
      v16 = v11;
      v17 = 1024;
      v18 = v10;
      v19 = 1024;
      v20 = v9 & 1;
      v21 = 1024;
      v22 = (v9 >> 2) & 1;
      v23 = 1024;
      v24 = (v9 >> 1) & 1;
      v25 = 1024;
      v26 = (v9 >> 3) & 1;
      v27 = 1024;
      v28 = (v9 >> 4) & 1;
      v29 = 1024;
      v30 = (v9 >> 5) & 1;
      v31 = 1024;
      v32 = (v9 >> 6) & 1;
      v33 = 1024;
      v34 = v9 >> 7;
      v35 = 1024;
      v36 = a3;
      v37 = 1024;
      v38 = a4;
      _os_log_error_impl(&dword_182A8C000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "*** %{public}s, break on '_CFMachPortDeallocationFailure' to debug: {p:%{private}d c:%d is:%d <i:%d,d:%d> s:%d,r:%d nsi:%d,nss:%d,nsr:%d - ic:%d,ip:%d}", (uint8_t *)&v13, 0x54u);
    }
  }
  else if (v8)
  {
    _cfmp_log_failure_cold_1(a1, a3, a4);
  }
  return _CFMachPortDeallocationFailure();
}

void _cfmp_source_record_deadness(int a1, int a2)
{
  const __CFSet *v4;
  _BYTE *Value;
  _DWORD v6[2];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (_cfmp_records_oGuard != -1)
    dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
  v4 = (const __CFSet *)_cfmp_records_oRecords;
  os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
  v6[0] = a2;
  v6[1] = a1;
  Value = CFSetGetValue(v4, v6);
  if (Value)
    Value[5] &= ~0x10u;
  else
    _cfmp_log_failure((uint64_t)"received deadname notification for untracked port", 0, a1, a2);
  os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
}

void _cfmp_record_nsmachport_deallocation(int a1, unsigned int a2, int a3, int a4)
{
  char v4;
  char v5;
  unsigned int v6;
  const __CFSet *v8;
  int *Value;
  char v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD v16[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = a4;
    v5 = a3;
    if (a4 | a3)
    {
      v6 = a2;
      if (_cfmp_records_oGuard != -1)
        dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
      v8 = (const __CFSet *)_cfmp_records_oRecords;
      os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
      v16[0] = v6;
      v16[1] = a1;
      Value = (int *)CFSetGetValue(v8, v16);
      if (Value)
      {
        v10 = *((_BYTE *)Value + 5);
        if ((v10 & 0x20) == 0)
        {
          _cfmp_log_failure((uint64_t)"setting nsport state - when its not interested", Value, a1, v6);
LABEL_11:
          os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
          return;
        }
        if ((*((_BYTE *)Value + 5) & 4) == 0)
        {
          *((_BYTE *)Value + 5) = ((v5 & 1) << 6) | v10 & 0x3F | (v4 << 7) | 2;
          goto LABEL_11;
        }
        v6 = *Value;
        v14 = *((unsigned __int8 *)Value + 4);
        v13 = v10 & 0x3F | ((v5 & 1) << 6) | (v4 << 7);
        v15 = *((unsigned __int16 *)Value + 3);
        CFSetRemoveValue(v8, Value);
        v12 = v15 << 48;
        v11 = v14 << 32;
      }
      else
      {
        v11 = 0;
        v12 = 0;
        v13 = (v4 << 7) | ((v5 & 1) << 6) | 0x20;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
      _cfmp_cleanup(v11 | v6 | v12 | ((unint64_t)v13 << 40));
    }
  }
}

CFStringRef _cfmp_copy_description(unsigned int *a1)
{
  unsigned int v1;

  if (!a1)
    return CFSTR("{null}");
  v1 = *((unsigned __int8 *)a1 + 5);
  return CFStringCreateWithFormat(0, 0, CFSTR("{p:%d c:%d is:%d <i:%d,d:%d> s:%d,r:%d nsi:%d,nss:%d,nsr:%d}"), *a1, *((unsigned __int8 *)a1 + 4), v1 & 1, (v1 >> 2) & 1, (v1 >> 1) & 1, (v1 >> 3) & 1, (v1 >> 4) & 1, (v1 >> 5) & 1, (v1 >> 6) & 1, v1 >> 7);
}

uint64_t (**__CFStringEncodingGetLatinSuppConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  uint64_t (**result)();

  if (!__CFStringEncodingPrecomposeLatinCharacter_1)
  {
    __CFStringEncodingPrecomposeLatinCharacter_1 = (_UNKNOWN *)a2(4);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_0 = (_UNKNOWN *)a2(3);
  }
  if (a1 > 1029)
  {
    if (a1 > 1286)
    {
      switch(a1)
      {
        case 1287:
          return __CFConverterWindowsBalticRim;
        case 2564:
          return __CFConverterMacRomanLatin1;
        case 2817:
          return __CFConverterNextStepLatin_0;
      }
    }
    else
    {
      switch(a1)
      {
        case 1030:
          return __CFConverterDOSBalticRim;
        case 1040:
          return __CFConverterDOSLatin1;
        case 1046:
          return __CFConverterDOSIcelandic;
      }
    }
    return 0;
  }
  result = __CFConverterISOLatin6;
  switch(a1)
  {
    case 522:
      return result;
    case 523:
    case 524:
      return 0;
    case 525:
      return __CFConverterISOLatin7;
    case 526:
      return __CFConverterISOLatin8;
    case 527:
      return __CFConverterISOLatin9;
    default:
      if (a1 == 37)
      {
        result = __CFConverterMacIcelandic;
      }
      else
      {
        if (a1 != 1024)
          return 0;
        result = __CFConverterDOSLatinUS;
      }
      break;
  }
  return result;
}

uint64_t __CFToISOLatin6(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0xA0)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8214 < 0xFFFFE091)
    return 0;
  v5 = (unsigned __int16 *)&ISOLatin6_from_uni;
  v6 = (unsigned __int16 *)&unk_182C8815E;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromISOLatin6(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0)
    LOWORD(a2) = ISOLatin6_to_uni[a2 - 161];
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin6Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0xA0)
  {
    if ((unsigned __int16)(v9 - 8214) >= 0xE091u)
    {
      v11 = (unsigned __int16 *)&ISOLatin6_from_uni;
      v12 = (unsigned __int16 *)&unk_182C8815E;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

uint64_t __CFIsValidCombiningCharacterForLatinSupp(int a1)
{
  if ((a1 - 768) > 0x5F)
    return 0;
  else
    return (__CFLatinSuppCombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
}

uint64_t __CFToISOLatin7(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  uint64_t result;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0xA0)
  {
    v3 = a2;
    goto LABEL_3;
  }
  result = 0;
  if (a2 != 161 && a2 <= 0x201E)
  {
    v5 = (unsigned __int16 *)&ISOLatin7_from_uni;
    v6 = (unsigned __int16 *)&unk_182C883A4;
    while (1)
    {
      v7 = ((char *)v6 - (char *)v5) >> 3;
      v8 = &v5[2 * v7];
      v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1;
        }
        v5 = v8 + 2;
      }
      else
      {
        v6 = v8 - 2;
      }
      if (v5 > v6)
        return 0;
    }
  }
  return result;
}

uint64_t __CFFromISOLatin7(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0)
    LOWORD(a2) = ISOLatin7_to_uni[a2 - 161];
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin7Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned int v16;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0xA0)
  {
    if (v9 != 161 && v9 <= 0x201E)
    {
      v12 = (unsigned __int16 *)&ISOLatin7_from_uni;
      v13 = (unsigned __int16 *)&unk_182C883A4;
      while (1)
      {
        v14 = ((char *)v13 - (char *)v12) >> 3;
        v15 = &v12[2 * v14];
        v16 = *v15;
        if (v16 <= v9)
        {
          if (v16 >= v9)
          {
            LOBYTE(v9) = v12[2 * v14 + 1];
            goto LABEL_2;
          }
          v12 = v15 + 2;
        }
        else
        {
          v13 = v15 - 2;
        }
        if (v12 > v13)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

uint64_t __CFToISOLatin8(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0xA0)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 7924 < 0xFFFFE1AF)
    return 0;
  v5 = (unsigned __int16 *)&ISOLatin8_from_uni;
  v6 = (unsigned __int16 *)&unk_182C885DE;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromISOLatin8(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0)
    LOWORD(a2) = ISOLatin8_to_uni[a2 - 161];
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin8Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0xA0)
  {
    if ((unsigned __int16)(v9 - 7924) >= 0xE1AFu)
    {
      v11 = (unsigned __int16 *)&ISOLatin8_from_uni;
      v12 = (unsigned __int16 *)&unk_182C885DE;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

uint64_t __CFToISOLatin9(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  uint64_t result;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0xA3)
  {
    v3 = a2;
    goto LABEL_3;
  }
  result = 0;
  if (a2 != 164 && a2 <= 0x20AC)
  {
    v5 = (unsigned __int16 *)&ISOLatin9_from_uni;
    v6 = (unsigned __int16 *)&unk_182C8880C;
    while (1)
    {
      v7 = ((char *)v6 - (char *)v5) >> 3;
      v8 = &v5[2 * v7];
      v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1;
        }
        v5 = v8 + 2;
      }
      else
      {
        v6 = v8 - 2;
      }
      if (v5 > v6)
        return 0;
    }
  }
  return result;
}

uint64_t __CFFromISOLatin9(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA3)
    LOWORD(a2) = ISOLatin9_to_uni[a2 - 164];
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin9Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned int v16;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0xA3)
  {
    if (v9 != 164 && v9 <= 0x20AC)
    {
      v12 = (unsigned __int16 *)&ISOLatin9_from_uni;
      v13 = (unsigned __int16 *)&unk_182C8880C;
      while (1)
      {
        v14 = ((char *)v13 - (char *)v12) >> 3;
        v15 = &v12[2 * v14];
        v16 = *v15;
        if (v16 <= v9)
        {
          if (v16 >= v9)
          {
            LOBYTE(v9) = v12[2 * v14 + 1];
            goto LABEL_2;
          }
          v12 = v15 + 2;
        }
        else
        {
          v13 = v15 - 2;
        }
        if (v12 > v13)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

uint64_t __CFToMacIcelandic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;

  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1792) >= 0x7A0u)
    {
      v4 = (unsigned __int16 *)&MacIcelandic_from_uni;
      v5 = (unsigned __int16 *)&unk_182C88AC4;
      do
      {
        v6 = ((char *)v5 - (char *)v4) >> 3;
        v7 = &v4[2 * v6];
        v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          v4 = v7 + 2;
        }
        else
        {
          v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

uint64_t __CFFromMacIcelandic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    LOWORD(a2) = MacIcelandic_to_uni[a2 - 128];
  *a3 = a2;
  return 1;
}

uint64_t __CFToMacIcelandicPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  int v10;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned int v16;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 <= 0x7F)
  {
    LOBYTE(v10) = v9;
    if (!(_BYTE)v9)
      return 0;
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 1792) < 0x7A0u)
    return 0;
  v12 = (unsigned __int16 *)&MacIcelandic_from_uni;
  v13 = (unsigned __int16 *)&unk_182C88AC4;
  while (1)
  {
    v14 = ((char *)v13 - (char *)v12) >> 3;
    v15 = &v12[2 * v14];
    v16 = *v15;
    if (v16 <= v9)
      break;
    v13 = v15 - 2;
LABEL_12:
    if (v12 > v13)
      return 0;
  }
  if (v16 < v9)
  {
    v12 = v15 + 2;
    goto LABEL_12;
  }
  v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10)
    return 0;
LABEL_3:
  if (a5)
    *a4 = v10;
  *a6 = 1;
  return 2;
}

uint64_t __CFToWindowsBalticRim(uint64_t a1, unsigned int a2, char *a3)
{
  char v3;
  uint64_t result;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;
  unsigned __int16 *v10;
  unsigned __int16 *v11;
  unsigned int v12;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 < 0xA8)
  {
LABEL_12:
    if (a2 < 0xA0)
      return 0;
  }
  else if (a2 <= 0x2122)
  {
    v5 = (unsigned __int16 *)&WindowsBalticRim_from_uni;
    v6 = (unsigned __int16 *)&unk_182C88C24;
    while (1)
    {
      v7 = ((char *)v6 - (char *)v5) >> 3;
      v8 = &v5[2 * v7];
      v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
LABEL_29:
          v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1;
        }
        v5 = v8 + 2;
      }
      else
      {
        v6 = v8 - 2;
      }
      if (v5 > v6)
        goto LABEL_12;
    }
  }
  result = 0;
  if ((a2 - 161 > 0x13 || ((1 << (a2 + 95)) & 0x80011) == 0) && a2 != 255)
  {
    if (a2 < 0xA1)
    {
      v3 = -96;
      goto LABEL_3;
    }
    result = 0;
    if (a2 != 161 && a2 <= 0x201E)
    {
      v5 = (unsigned __int16 *)&ISOLatin7_from_uni;
      v10 = (unsigned __int16 *)&unk_182C883A4;
      do
      {
        v7 = ((char *)v10 - (char *)v5) >> 3;
        v11 = &v5[2 * v7];
        v12 = *v11;
        if (v12 <= a2)
        {
          if (v12 >= a2)
            goto LABEL_29;
          v5 = v11 + 2;
        }
        else
        {
          v10 = v11 - 2;
        }
        result = 0;
      }
      while (v5 <= v10);
    }
  }
  return result;
}

uint64_t __CFFromWindowsBalticRim(uint64_t a1, int a2, _WORD *a3)
{
  uint64_t result;

  if ((a2 & 0x80) == 0)
    goto LABEL_2;
  if (a2 >= 0xA0)
  {
    *a3 = -3;
  }
  else
  {
    *a3 = WindowsBalticRim_to_uni[a2 - 128];
    if (((0x9501150AuLL >> a2) & 1) == 0)
      return 1;
  }
  if (a2 > 179)
  {
    if (a2 != 180)
    {
      if (a2 != 255)
      {
LABEL_16:
        if (a2 > 0xA0)
          LOWORD(a2) = ISOLatin7_to_uni[a2 - 161];
        goto LABEL_2;
      }
      LOWORD(a2) = 729;
    }
LABEL_2:
    *a3 = a2;
    return 1;
  }
  result = 0;
  if (a2 != 161 && a2 != 165)
    goto LABEL_16;
  return result;
}

uint64_t __CFToWindowsBalticRimPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  int v10;
  uint64_t result;
  BOOL v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  v10 = __CFToWindowsBalticRim(v9, v9, &v13);
  result = 0;
  if (v10)
    v12 = v13 == 0;
  else
    v12 = 1;
  if (!v12)
  {
    if (a5)
      *a4 = v13;
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFToNextStepLatin_0(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;

  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 2) >= 0xA2u)
    {
      v4 = (unsigned __int16 *)&nextstep_from_tab_0;
      v5 = (unsigned __int16 *)&unk_182C88E64;
      do
      {
        v6 = ((char *)v5 - (char *)v4) >> 3;
        v7 = &v4[2 * v6];
        v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          v4 = v7 + 2;
        }
        else
        {
          v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

BOOL __CFFromNextStepLatin_0(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = NSToPrecompUnicodeTable_0[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToNextStepLatinPrecompose_0(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  int v10;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned int v16;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 <= 0x7F)
  {
    LOBYTE(v10) = v9;
    if (!(_BYTE)v9)
      return 0;
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 2) < 0xA2u)
    return 0;
  v12 = (unsigned __int16 *)&nextstep_from_tab_0;
  v13 = (unsigned __int16 *)&unk_182C88E64;
  while (1)
  {
    v14 = ((char *)v13 - (char *)v12) >> 3;
    v15 = &v12[2 * v14];
    v16 = *v15;
    if (v16 <= v9)
      break;
    v13 = v15 - 2;
LABEL_12:
    if (v12 > v13)
      return 0;
  }
  if (v16 < v9)
  {
    v12 = v15 + 2;
    goto LABEL_12;
  }
  v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10)
    return 0;
LABEL_3:
  if (a5)
    *a4 = v10;
  *a6 = 1;
  return 2;
}

uint64_t __CFStringEncodingIsValidCombiningCharacterForLatin1Wrapper()
{
  return __CFStringEncodingIsValidCombiningCharacterForLatin1_0();
}

uint64_t __CFToMacRomanLatin1(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;

  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1277) >= 0x59Du)
    {
      v4 = (unsigned __int16 *)&MacRomanLatin1_from_uni;
      v5 = (unsigned __int16 *)&unk_182C8916C;
      do
      {
        v6 = ((char *)v5 - (char *)v4) >> 3;
        v7 = &v4[2 * v6];
        v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          v4 = v7 + 2;
        }
        else
        {
          v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

BOOL __CFFromMacRomanLatin1(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = MacRomanLatin1_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacRomanLatin1Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  int v10;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned int v16;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 <= 0x7F)
  {
    LOBYTE(v10) = v9;
    if (!(_BYTE)v9)
      return 0;
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 1277) < 0x59Du)
    return 0;
  v12 = (unsigned __int16 *)&MacRomanLatin1_from_uni;
  v13 = (unsigned __int16 *)&unk_182C8916C;
  while (1)
  {
    v14 = ((char *)v13 - (char *)v12) >> 3;
    v15 = &v12[2 * v14];
    v16 = *v15;
    if (v16 <= v9)
      break;
    v13 = v15 - 2;
LABEL_12:
    if (v12 > v13)
      return 0;
  }
  if (v16 < v9)
  {
    v12 = v15 + 2;
    goto LABEL_12;
  }
  v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10)
    return 0;
LABEL_3:
  if (a5)
    *a4 = v10;
  *a6 = 1;
  return 2;
}

uint64_t __CFToDOSLatinUS(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF)
    return 0;
  v5 = (unsigned __int16 *)&DOSLatinUS_from_uni;
  v6 = (unsigned __int16 *)&unk_182C8946C;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSLatinUS(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = DOSLatinUS_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSLatinUSPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      v11 = (unsigned __int16 *)&DOSLatinUS_from_uni;
      v12 = (unsigned __int16 *)&unk_182C8946C;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

uint64_t __CFToDOSLatin1(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF)
    return 0;
  v5 = (unsigned __int16 *)&DOSLatin1_from_uni;
  v6 = (unsigned __int16 *)&unk_182C8976C;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSLatin1(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = DOSLatin1_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSLatin1Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      v11 = (unsigned __int16 *)&DOSLatin1_from_uni;
      v12 = (unsigned __int16 *)&unk_182C8976C;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

uint64_t __CFToDOSBalticRim(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF)
    return 0;
  v5 = (unsigned __int16 *)&DOSBalticRim_from_uni;
  v6 = (unsigned __int16 *)&unk_182C89A6C;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSBalticRim(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = DOSIcelandic_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSBalticRimPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      v11 = (unsigned __int16 *)&DOSBalticRim_from_uni;
      v12 = (unsigned __int16 *)&unk_182C89A6C;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

uint64_t __CFToDOSIcelandic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF)
    return 0;
  v5 = (unsigned __int16 *)&DOSIcelandic_from_uni;
  v6 = (unsigned __int16 *)&unk_182C89C6C;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSIcelandic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = DOSIcelandic_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSIcelandicPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_1(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      v11 = (unsigned __int16 *)&DOSIcelandic_from_uni;
      v12 = (unsigned __int16 *)&unk_182C89C6C;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromScriptManagerCodes(CFAllocatorRef allocator, LangCode lcode, RegionCode rcode)
{
  unsigned int v3;
  char *v5;
  CFLocaleIdentifier result;
  const char *v7;

  v3 = lcode;
  if (rcode > 0x6C
    || (v5 = regionCodeToLocaleString[(unsigned __int16)rcode]) == 0
    || !*v5
    || (result = CFStringCreateWithCStringNoCopy(allocator, v5, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull)) == 0)
  {
    if (v3 <= 0x97
      && (unint64_t)(unsigned __int16)v3 - 95 >= 0x21
      && (v7 = langCodeToLocaleString[(unsigned __int16)v3], *v7))
    {
      return CFStringCreateWithCStringNoCopy(allocator, v7, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

const NXArchInfo *_CFBundleCurrentArchitecture()
{
  const NXArchInfo *result;

  result = NXGetLocalArchInfo();
  if (result)
    return (const NXArchInfo *)result->cputype;
  return result;
}

uint64_t _CFBundleDlfcnPreflight(unsigned __int8 *a1, CFErrorRef *a2)
{
  os_unfair_lock_s *v4;
  int v5;
  uint64_t result;
  const __CFURL *v7;
  const __CFURL *v8;
  _BOOL8 v9;
  _BOOL8 v10;
  CFErrorRef Error;
  const __CFArray *v12;
  char *v13;
  __CFString *v14;
  const __CFAllocator *v15;
  const __CFAllocator *v16;
  CFIndex Count;
  const NXArchInfo *v18;
  cpu_type_t cputype;
  CFIndex v20;
  const __CFNumber *ValueAtIndex;
  BOOL v22;
  int v23;
  CFIndex v25;
  const __CFAllocator *v26;
  int v27;
  int v28;
  int valuePtr;
  UInt8 buffer[1026];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock_with_options();
  v5 = a1[52];
  os_unfair_lock_unlock(v4);
  if (v5)
    return 1;
  v7 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  v8 = v7;
  if (!v7 || !CFURLGetFileSystemRepresentation(v7, 1u, buffer, 1026))
  {
    if (a2)
    {
      v16 = CFGetAllocator(a1);
      Error = _CFBundleCreateError(v16, (__CFBundle *)a1, 4);
    }
    else
    {
      Error = 0;
    }
    goto LABEL_41;
  }
  v9 = dlopen_preflight((const char *)buffer);
  v10 = v9;
  Error = 0;
  if (a2 && !v9)
  {
    v12 = CFBundleCopyExecutableArchitectures((CFBundleRef)a1);
    v13 = dlerror();
    if (v13 && *v13)
    {
      v14 = (__CFString *)CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
      if (!v12)
      {
LABEL_10:
        v15 = CFGetAllocator(a1);
        Error = _CFBundleCreateErrorDebug(v15, (CFBundleRef)a1, 3587, v14);
LABEL_39:
        if (v14)
          CFRelease(v14);
LABEL_41:
        v10 = 0;
        result = 0;
        if (!v8)
          goto LABEL_43;
        goto LABEL_42;
      }
    }
    else
    {
      v14 = 0;
      if (!v12)
        goto LABEL_10;
    }
    Count = CFArrayGetCount(v12);
    valuePtr = 0;
    v18 = NXGetLocalArchInfo();
    if (v18)
      cputype = v18->cputype;
    else
      cputype = 0;
    if (Count < 1)
      goto LABEL_31;
    v20 = 0;
    do
    {
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v12, v20);
      if (CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr))
        v22 = valuePtr == cputype;
      else
        v22 = 0;
      v23 = !v22;
      ++v20;
    }
    while (v23 == 1 && v20 < Count);
    if ((v23 & 1) != 0)
    {
LABEL_31:
      v25 = 3585;
    }
    else
    {
      v28 = 0;
      if (_CFBundleGrokObjCImageInfoFromMainExecutable(0, &v28)
        && (v28 & 2) != 0
        && (v27 = 0, _CFBundleGetObjCImageInfo((__CFBundle *)a1, 0, &v27))
        && (v27 & 2) == 0)
      {
        v25 = 3586;
      }
      else
      {
        v25 = 3587;
      }
    }
    v26 = CFGetAllocator(a1);
    Error = _CFBundleCreateErrorDebug(v26, (CFBundleRef)a1, v25, v14);
    CFRelease(v12);
    goto LABEL_39;
  }
LABEL_42:
  CFRelease(v8);
  result = v10;
LABEL_43:
  if (a2)
  {
    if (!(_DWORD)result)
      *a2 = Error;
  }
  return result;
}

uint64_t _CFBundleDlfcnLoadFramework(uint64_t a1, CFTypeRef *a2)
{
  os_unfair_lock_s *v4;
  int v5;
  uint64_t v6;
  const __CFURL *v7;
  const __CFURL *v8;
  void *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  const __CFAllocator *v13;
  void *v14;
  NSObject *v15;
  const __CFAllocator *v16;
  CFTypeRef cf;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  UInt8 *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  void *v26;
  UInt8 buffer[1026];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock_with_options();
  v5 = *(unsigned __int8 *)(a1 + 52);
  os_unfair_lock_unlock(v4);
  if (v5)
    return 1;
  cf = 0;
  v7 = CFBundleCopyExecutableURL((CFBundleRef)a1);
  v8 = v7;
  if (!v7 || !CFURLGetFileSystemRepresentation(v7, 1u, buffer, 1026))
  {
    v12 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadFramework_cold_1();
      if (!a2)
      {
LABEL_16:
        v6 = 0;
        if (!v8)
          goto LABEL_28;
        goto LABEL_27;
      }
    }
    else if (!a2)
    {
      goto LABEL_16;
    }
    v13 = CFGetAllocator((CFTypeRef)a1);
    cf = _CFBundleCreateError(v13, (__CFBundle *)a1, 4);
    goto LABEL_16;
  }
  v9 = dlopen((const char *)buffer, 265);
  v10 = _CFBundleLoadingLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138544130;
    v20 = a1;
    v21 = 2082;
    v22 = buffer;
    v23 = 1024;
    v24 = 265;
    v25 = 2048;
    v26 = v9;
    _os_log_debug_impl(&dword_182A8C000, v10, OS_LOG_TYPE_DEBUG, "dlfcn load framework %{public}@, dlopen of %{public}s mode 0x%x returns handle %p", buf, 0x26u);
  }
  os_unfair_lock_lock_with_options();
  if (!v9)
  {
    *(_QWORD *)(a1 + 56) = 0;
    os_unfair_lock_unlock(v4);
    v14 = dlerror();
    v15 = _CFOSLog();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      _CFBundleDlfcnLoadFramework_cold_2();
      if (!v14)
      {
LABEL_21:
        if (a2)
        {
          _CFBundleDlfcnPreflight((unsigned __int8 *)a1, (CFErrorRef *)&cf);
          if (!cf)
          {
            v16 = CFGetAllocator((CFTypeRef)a1);
            cf = _CFBundleCreateErrorDebug(v16, (CFBundleRef)a1, 3588, v14);
          }
        }
        if (v14)
          CFRelease(v14);
        v6 = 0;
        goto LABEL_27;
      }
    }
    else if (!v14)
    {
      goto LABEL_21;
    }
    v14 = (void *)CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const char *)v14);
    goto LABEL_21;
  }
  if (v9 == *(void **)(a1 + 56))
  {
    v11 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      _CFBundleDlfcnLoadFramework_cold_3();
    os_unfair_lock_unlock(v4);
    dlclose(v9);
    os_unfair_lock_lock_with_options();
  }
  *(_QWORD *)(a1 + 56) = v9;
  v6 = 1;
  *(_BYTE *)(a1 + 52) = 1;
  os_unfair_lock_unlock(v4);
LABEL_27:
  CFRelease(v8);
LABEL_28:
  if (!a2 || (_DWORD)v6)
  {
    if (cf)
      CFRelease(cf);
  }
  else
  {
    *a2 = cf;
  }
  return v6;
}

void _CFBundleDlfcnUnload(uint64_t a1)
{
  os_unfair_lock_s *v2;
  void *v3;
  BOOL v4;
  NSObject *v5;
  int v6;
  NSObject *v7;

  v2 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_assert_owner((const os_unfair_lock *)(a1 + 96));
  v3 = *(void **)(a1 + 56);
  if (*(_BYTE *)(a1 + 52))
    v4 = v3 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v5 = _CFBundleLoadingLogger();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      _CFBundleDlfcnUnload_cold_2();
    *(_QWORD *)(a1 + 56) = 0;
    *(_BYTE *)(a1 + 52) = 0;
    os_unfair_lock_unlock(v2);
    v6 = dlclose(v3);
    os_unfair_lock_lock(v2);
    if (v6)
    {
      v7 = _CFBundleLoadingLogger();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        _CFBundleDlfcnUnload_cold_1(a1, v7);
      *(_QWORD *)(a1 + 56) = v3;
      *(_BYTE *)(a1 + 52) = 1;
    }
  }
}

void *_CFBundleDlfcnGetSymbolByName(uint64_t a1, const __CFString *a2)
{
  return _CFBundleDlfcnGetSymbolByNameWithSearch(a1, a2, 0);
}

void *_CFBundleGetCFMFunctionPointerForName(__CFBundle *a1, const __CFString *a2)
{
  if (CFBundleLoadExecutable(a1))
    return _CFBundleDlfcnGetSymbolByNameWithSearch((uint64_t)a1, a2, 1);
  else
    return 0;
}

void CFBundleGetFunctionPointersForNames(CFBundleRef bundle, CFArrayRef functionNames, void *ftbl[])
{
  int Count;
  CFIndex v7;
  uint64_t v8;
  const __CFString *ValueAtIndex;

  if (ftbl)
  {
    Count = CFArrayGetCount(functionNames);
    if (Count >= 1)
    {
      v7 = 0;
      v8 = Count;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(functionNames, v7);
        ftbl[v7++] = CFBundleGetFunctionPointerForName(bundle, ValueAtIndex);
      }
      while (v8 != v7);
    }
  }
}

__CFBundle *_CFBundleGetCFMFunctionPointersForNames(__CFBundle *result, CFArrayRef theArray, uint64_t a3)
{
  __CFBundle *v5;
  CFIndex v6;
  uint64_t v7;
  const __CFString *ValueAtIndex;

  if (a3)
  {
    v5 = result;
    result = (__CFBundle *)CFArrayGetCount(theArray);
    if ((int)result >= 1)
    {
      v6 = 0;
      v7 = result;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v6);
        result = (__CFBundle *)_CFBundleGetCFMFunctionPointerForName(v5, ValueAtIndex);
        *(_QWORD *)(a3 + 8 * v6++) = result;
      }
      while (v7 != v6);
    }
  }
  return result;
}

void CFBundleGetDataPointersForNames(CFBundleRef bundle, CFArrayRef symbolNames, void *stbl[])
{
  int Count;
  CFIndex v7;
  uint64_t v8;
  const __CFString *ValueAtIndex;

  if (stbl)
  {
    Count = CFArrayGetCount(symbolNames);
    if (Count >= 1)
    {
      v7 = 0;
      v8 = Count;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(symbolNames, v7);
        stbl[v7++] = CFBundleGetDataPointerForName(bundle, ValueAtIndex);
      }
      while (v8 != v7);
    }
  }
}

void OUTLINED_FUNCTION_0_4(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_1_3(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x20u);
}

void OUTLINED_FUNCTION_7(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_0_5(uint64_t a1, const __CFString *a2)
{
  uint64_t v2;

  _CFThrowFormattedException(v2, a2);
}

__CFArray *_CFBundleDYLDCreateLoadedImagePathVariants(const char *a1, const __CFString *a2)
{
  __CFArray *Mutable;
  const __CFString *v5;
  const __CFString *v6;
  const __CFArray *ArrayBySeparatingStrings;
  CFIndex Length;
  CFIndex Count;
  CFIndex v10;
  CFIndex i;
  const __CFString *ValueAtIndex;
  CFIndex v13;
  CFIndex v14;
  int v15;
  CFIndex location;
  CFIndex v17;
  __CFString *MutableCopy;
  __CFString *v19;
  CFRange result;
  uint64_t v22;
  CFRange v23;
  CFRange v24;
  CFRange v25;

  v22 = *MEMORY[0x1E0C80C00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  if (a1)
  {
    if (*a1)
    {
      v5 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, 0x8000100u, (CFAllocatorRef)&__kCFAllocatorNull);
      if (v5)
      {
        v6 = v5;
        ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, CFSTR(":"));
        CFRelease(v6);
        if (ArrayBySeparatingStrings)
        {
          Length = CFStringGetLength(a2);
          Count = CFArrayGetCount(ArrayBySeparatingStrings);
          if (Count >= 1)
          {
            v10 = Count;
            for (i = 0; i != v10; ++i)
            {
              ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, i);
              v13 = CFStringGetLength(ValueAtIndex);
              if (v13)
              {
                v14 = v13;
                result.location = 0;
                result.length = 0;
                v24.location = 0;
                v24.length = Length;
                v15 = CFStringFindWithOptions(a2, CFSTR("."), v24, 4uLL, &result);
                location = result.location;
                if (!v15)
                  location = Length;
                v17 = location - v14;
                if (location - v14 >= 1)
                {
                  v25.location = location - v14;
                  v25.length = v14;
                  if (CFStringCompareWithOptions(a2, ValueAtIndex, v25, 8uLL) == kCFCompareEqualTo)
                  {
                    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, a2);
                    if (MutableCopy)
                    {
                      v19 = MutableCopy;
                      v23.location = v17;
                      v23.length = v14;
                      CFStringReplace(MutableCopy, v23, &stru_1E1337B18);
                      CFArrayAppendValue(Mutable, v19);
                      CFRelease(v19);
                    }
                  }
                }
              }
            }
          }
          CFRelease(ArrayBySeparatingStrings);
        }
      }
    }
  }
  CFArrayAppendValue(Mutable, a2);
  return Mutable;
}

CFStringRef __CFMachPortCopyDescription(uint64_t a1)
{
  uint64_t v2;
  uint64_t (*v3)(void);
  CFStringRef v4;
  void *v5;
  const char *dli_sname;
  CFAllocatorRef v8;
  const char *v9;
  CFStringRef v10;
  Dl_info v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 64);
  if (!v2)
    goto LABEL_5;
  v3 = *(uint64_t (**)(void))(a1 + 88);
  if (!v3)
    goto LABEL_5;
  v4 = (CFStringRef)v3();
  if (!v4)
  {
    v2 = *(_QWORD *)(a1 + 64);
LABEL_5:
    v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFMachPort context %p>"), v2);
  }
  memset(&v12, 0, sizeof(v12));
  v5 = *(void **)(a1 + 48);
  dli_sname = "???";
  if (dladdr(v5, &v12))
  {
    if (v12.dli_sname && v12.dli_saddr == v5)
      dli_sname = v12.dli_sname;
  }
  v8 = CFGetAllocator((CFTypeRef)a1);
  v9 = "No";
  if (!*(_DWORD *)(a1 + 16))
    v9 = "Yes";
  v10 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFMachPort %p [%p]>{valid = %s, port = %x, source = %p, callout = %s (%p), context = %@}"), a1, v8, v9, *(unsigned int *)(a1 + 20), *(_QWORD *)(a1 + 40), dli_sname, v5, v4);
  if (v4)
    CFRelease(v4);
  return v10;
}

uint64_t _CFMachPortCreateWithPort2(__objc2_class **a1, mach_port_name_t a2, uint64_t a3, __int128 *a4, _BYTE *a5)
{
  return _CFMachPortCreateWithPort4(a1, a2, a3, a4, a5, 1);
}

uint64_t _CFMachPortCreateWithPort3(__objc2_class **a1, mach_port_name_t a2, uint64_t a3, __int128 *a4, _BYTE *a5)
{
  return _CFMachPortCreateWithPort4(a1, a2, a3, a4, a5, 0);
}

uint64_t _CFMachPortCreate3(__objc2_class **a1, uint64_t a2, __int128 *a3, _BYTE *a4)
{
  return _CFMachPortCreate4(a1, a2, a3, a4, 0);
}

CFMachPortInvalidationCallBack CFMachPortGetInvalidationCallBack(CFMachPortRef port)
{
  unint64_t v2;
  os_unfair_lock_s *v3;
  void (__cdecl *v4)(CFMachPortRef, void *);

  v2 = _CFGetNonObjCTypeID((unint64_t *)port);
  if (v2 != 36)
    _CFAssertMismatchedTypeID(0x24uLL, v2);
  v3 = (os_unfair_lock_s *)((char *)port + 96);
  os_unfair_lock_lock((os_unfair_lock_t)port + 24);
  v4 = (void (__cdecl *)(CFMachPortRef, void *))*((_QWORD *)port + 4);
  os_unfair_lock_unlock(v3);
  return v4;
}

uint64_t CFMachPortGetQueuedMessageCount(uint64_t a1)
{
  unint64_t v2;
  mach_msg_type_number_t port_info_outCnt;
  integer_t port_info_out[4];
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 36)
    _CFAssertMismatchedTypeID(0x24uLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) != 0)
    return 0;
  v7 = 0;
  *(_OWORD *)port_info_out = 0u;
  v6 = 0u;
  port_info_outCnt = 10;
  if (mach_port_get_attributes(*MEMORY[0x1E0C83DA0], *(_DWORD *)(a1 + 20), 2, port_info_out, &port_info_outCnt))
    return 0;
  else
    return v6;
}

uint64_t __CFDescribeCFMachPortPerformCallout(uint64_t a1, char *a2, size_t a3, char *a4, size_t a5)
{
  const void *v10;
  BOOL v11;
  uint64_t result;
  Dl_info v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (__CFDescribeCFMachPortPerformCallout_onceToken != -1)
    dispatch_once(&__CFDescribeCFMachPortPerformCallout_onceToken, &__block_literal_global_5);
  v10 = *(const void **)(a1 + 48);
  if (__CFDescribeCFMachPortPerformCallout_foundationFireMachPort)
    v11 = __CFDescribeCFMachPortPerformCallout_foundationDescribeNSMachPortCallout == 0;
  else
    v11 = 1;
  if (!v11 && v10 == (const void *)__CFDescribeCFMachPortPerformCallout_foundationFireMachPort)
    return __CFDescribeCFMachPortPerformCallout_foundationDescribeNSMachPortCallout(a1, a1 + 56, a2, a3, a4, a5);
  memset(&v14, 0, sizeof(v14));
  result = dladdr(v10, &v14);
  if ((_DWORD)result)
  {
    snprintf(a4, a5, "(CFMachPort) %s", v14.dli_sname);
    return snprintf(a2, a3, "%s", v14.dli_fname);
  }
  return result;
}

BOOL __CFMachPortCheck(mach_port_name_t name)
{
  kern_return_t v1;
  mach_port_type_t ptype;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  ptype = 0;
  v1 = mach_port_type(*MEMORY[0x1E0C83DA0], name, &ptype);
  return (ptype & 0x70000) != 0 && v1 == 0;
}

void OUTLINED_FUNCTION_0_6(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x12u);
}

void OUTLINED_FUNCTION_1_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

void __CFMessagePortDeallocate(char *ms)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  int v5;
  const void *v6;
  const void *v7;
  __CFMachPort *v8;
  mach_port_t Port;
  char v10;
  CFIndex Count;
  const void **Typed;
  const void **v13;
  CFIndex v14;
  const void *v15;
  CFMessagePortRef *v16;
  CFMessagePortRef v17;

  v2 = (unint64_t *)(ms + 8);
  v3 = atomic_load((unint64_t *)ms + 1);
  do
  {
    v4 = __ldaxr(v2);
    if (v4 == v3)
    {
      if (!__stlxr(v3 | 8, v2))
      {
        v5 = 1;
        goto LABEL_7;
      }
    }
    else
    {
      __clrex();
    }
    v5 = 0;
LABEL_7:
    v3 = v4;
  }
  while (!v5);
  CFMessagePortInvalidate((CFMessagePortRef)ms);
  v6 = (const void *)*((_QWORD *)ms + 4);
  if (v6)
    CFRelease(v6);
  v7 = (const void *)*((_QWORD *)ms + 2);
  if (v7)
    CFRelease(v7);
  v8 = (__CFMachPort *)*((_QWORD *)ms + 3);
  if (v8)
  {
    Port = CFMachPortGetPort(v8);
    v10 = atomic_load((unint64_t *)ms + 1);
    _cfmp_record_deallocation(1u, Port, (v10 & 2) != 0, (v10 & 2) != 0);
    CFMachPortInvalidate(*((CFMachPortRef *)ms + 3));
    CFRelease(*((CFTypeRef *)ms + 3));
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (__CFAllRemoteMessagePorts)
  {
    Count = CFDictionaryGetCount((CFDictionaryRef)__CFAllRemoteMessagePorts);
    Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0x2004093837F09, 0);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)__CFAllRemoteMessagePorts, 0, Typed);
    if (Count < 1)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      if (Typed)
        goto LABEL_23;
    }
    else
    {
      v13 = Typed;
      v14 = Count;
      do
      {
        v15 = *v13++;
        CFRetain(v15);
        --v14;
      }
      while (v14);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
      v16 = (CFMessagePortRef *)Typed;
      do
      {
        CFMessagePortIsValid(*v16);
        v17 = *v16++;
        CFRelease(v17);
        --Count;
      }
      while (Count);
LABEL_23:
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  }
}

CFStringRef __CFMessagePortCopyDescription(unint64_t *cf)
{
  unint64_t *v2;
  char v3;
  unint64_t v4;
  uint64_t (*v5)(void);
  CFStringRef v6;
  void *v7;
  const char *dli_sname;
  CFAllocatorRef v10;
  char v11;
  const char *v12;
  char v13;
  const char *v14;
  const __CFString *v15;
  CFStringRef v16;
  CFAllocatorRef v18;
  char v19;
  const char *v20;
  const char *v21;
  char v22;
  Dl_info v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v2 = cf + 1;
  v3 = atomic_load(cf + 1);
  if ((v3 & 4) == 0)
  {
    v4 = cf[16];
    if (v4)
    {
      v5 = (uint64_t (*)(void))cf[19];
      if (v5)
      {
        v6 = (CFStringRef)v5();
        if (v6)
        {
LABEL_7:
          v7 = (void *)cf[12];
          if (!v7)
            v7 = (void *)cf[13];
          memset(&v23, 0, sizeof(v23));
          dli_sname = "???";
          if (dladdr(v7, &v23))
          {
            if (v23.dli_sname && v23.dli_saddr == v7)
              dli_sname = v23.dli_sname;
          }
          v10 = CFGetAllocator(cf);
          v11 = atomic_load(cf + 1);
          if ((v11 & 1) != 0)
            v12 = "Yes";
          else
            v12 = "No";
          v13 = atomic_load(cf + 1);
          if ((v13 & 4) != 0)
            v14 = "Yes";
          else
            v14 = "No";
          v15 = CFSTR("<no description>");
          if (v6)
            v15 = v6;
          v16 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFMessagePort %p [%p]>{locked = %s, valid = %s, remote = %s, name = %@, source = %p, callout = %s (%p), context = %@}"), cf, v10, "Maybe", v12, v14, cf[2], cf[7], dli_sname, v7, v15);
          if (v6)
            CFRelease(v6);
          return v16;
        }
        v4 = cf[16];
      }
    }
    v6 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFMessagePort context %p>"), v4);
    goto LABEL_7;
  }
  v18 = CFGetAllocator(cf);
  v19 = atomic_load(v2);
  v20 = "Yes";
  if ((v19 & 1) != 0)
    v21 = "Yes";
  else
    v21 = "No";
  v22 = atomic_load(v2);
  if ((v22 & 4) == 0)
    v20 = "No";
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFMessagePort %p [%p]>{locked = %s, valid = %s, remote = %s, name = %@}"), cf, v18, "Maybe", v21, v20, cf[2]);
}

CFTypeID CFMessagePortGetTypeID(void)
{
  return 35;
}

CFMessagePortRef CFMessagePortCreateLocal(CFAllocatorRef allocator, CFStringRef name, CFMessagePortCallBack callout, CFMessagePortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMessagePortRef)__CFMessagePortCreateLocal((__objc2_class **)allocator, name, (uint64_t)callout, (__int128 *)&context->version, shouldFreeInfo, 0, 0);
}

CFTypeRef __CFMessagePortCreateLocal(__objc2_class **a1, const __CFString *a2, uint64_t a3, __int128 *a4, _BYTE *a5, int a6, uint64_t a7)
{
  CFStringRef SanitizedStringName;
  BOOL v14;
  int v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFTypeRef v24;
  uint64_t Instance;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  unint64_t v34;
  unint64_t v35;
  int v36;
  ipc_space_t *v37;
  __CFMachPort *v38;
  __CFMachPort *v39;
  kern_return_t v40;
  kern_return_t v41;
  NSObject *v42;
  NSObject *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  NSObject *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  kern_return_t inserted;
  int v60;
  NSObject *v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  int v65;
  unint64_t v66;
  unint64_t v67;
  int v68;
  __int128 v69;
  __int128 v70;
  uint64_t v71;
  uint64_t (*v72)(uint64_t);
  __CFDictionary *Mutable;
  NSObject *v75;
  const char *v76;
  CFTypeRef cf[2];
  __int128 v78;
  uint64_t v79;
  mach_port_t special_port[2];
  void *ptr;
  uint8_t buf[4];
  kern_return_t v83;
  __int16 v84;
  kern_return_t v85;
  __int16 v86;
  const char *v87;
  __int16 v88;
  mach_port_t v89;
  __int16 v90;
  void *v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  ptr = 0;
  if (a5)
    *a5 = 1;
  if (a2)
    SanitizedStringName = __CFMessagePortCreateSanitizedStringName(a2, (UInt8 **)&ptr);
  else
    SanitizedStringName = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (a6)
    v14 = 1;
  else
    v14 = SanitizedStringName == 0;
  v15 = !v14;
  if (!v14)
  {
    cf[0] = 0;
    if (__CFAllLocalMessagePorts)
    {
      if (CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllLocalMessagePorts, SanitizedStringName, cf))
      {
        CFRetain(cf[0]);
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
        CFRelease(SanitizedStringName);
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
        if (CFMessagePortIsValid((CFMessagePortRef)cf[0]))
          return cf[0];
        v16 = _CFOSLog();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          __CFMessagePortCreateLocal_cold_5(v16, v17, v18, v19, v20, v21, v22, v23);
        v24 = cf[0];
        goto LABEL_62;
      }
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  Instance = _CFRuntimeCreateInstance(a1, 0x23uLL, 144, 0);
  if (!Instance)
  {
    if (SanitizedStringName)
      CFRelease(SanitizedStringName);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    v43 = _CFOSLog();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      __CFMessagePortCreateLocal_cold_1(v43, v44, v45, v46, v47, v48, v49, v50);
    return 0;
  }
  v26 = Instance;
  v27 = (unint64_t *)(Instance + 8);
  v28 = atomic_load((unint64_t *)(Instance + 8));
  do
  {
    v29 = __ldaxr(v27);
    if (v29 == v28)
    {
      if (!__stlxr(v28 & 0xFFFFFFFFFFFFFFFELL, v27))
      {
        v30 = 1;
        goto LABEL_26;
      }
    }
    else
    {
      __clrex();
    }
    v30 = 0;
LABEL_26:
    v28 = v29;
  }
  while (!v30);
  v31 = atomic_load(v27);
  do
  {
    v32 = __ldaxr(v27);
    if (v32 == v31)
    {
      if (!__stlxr(v31 & 0xFFFFFFFFFFFFFFFDLL, v27))
      {
        v33 = 1;
        goto LABEL_33;
      }
    }
    else
    {
      __clrex();
    }
    v33 = 0;
LABEL_33:
    v31 = v32;
  }
  while (!v33);
  v34 = atomic_load(v27);
  do
  {
    v35 = __ldaxr(v27);
    if (v35 == v34)
    {
      if (!__stlxr(v34 & 0xFFFFFFFFFFFFFFFBLL, v27))
      {
        v36 = 1;
        goto LABEL_40;
      }
    }
    else
    {
      __clrex();
    }
    v36 = 0;
LABEL_40:
    v34 = v35;
  }
  while (!v36);
  *(_DWORD *)(Instance + 112) = 0;
  *(_QWORD *)(Instance + 16) = SanitizedStringName;
  if (a6)
    *(_DWORD *)(Instance + 44) = getpid();
  *(_QWORD *)(v26 + 96) = a3;
  *(_QWORD *)(v26 + 104) = a7;
  if (!SanitizedStringName)
    goto LABEL_73;
  *(_QWORD *)special_port = 0;
  v37 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  task_get_special_port(*MEMORY[0x1E0C83DA0], 4, &special_port[1]);
  if (!a6 && !bootstrap_check_in(special_port[1], (const char *)ptr, special_port))
  {
    inserted = mach_port_insert_right(*v37, special_port[0], special_port[0], 0x14u);
    if (inserted)
    {
      v60 = inserted;
      v61 = _CFOSLog();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
        __CFMessagePortCreateLocal_cold_3((int *)special_port, v60, v61);
      mach_port_mod_refs(*v37, special_port[0], 1u, -1);
      goto LABEL_61;
    }
    cf[0] = 0;
    v78 = 0u;
    v79 = 0;
    cf[1] = (CFTypeRef)v26;
    v62 = _CFMachPortCreateWithPort3(a1, special_port[0], (uint64_t)__CFMessagePortDummyCallback, (__int128 *)cf, 0);
    if (!v62)
    {
      v75 = _CFOSLog();
      if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
        __CFMessagePortCreateLocal_cold_2((int *)special_port, v75);
      mach_port_mod_refs(*v37, special_port[0], 1u, -1);
      mach_port_deallocate(*v37, special_port[0]);
      goto LABEL_61;
    }
    v39 = (__CFMachPort *)v62;
    v63 = atomic_load(v27);
    while (1)
    {
      v64 = __ldaxr(v27);
      if (v64 != v63)
        break;
      if (__stlxr(v63 | 2, v27))
        goto LABEL_70;
      v65 = 1;
LABEL_71:
      v63 = v64;
      if (v65)
        goto LABEL_72;
    }
    __clrex();
LABEL_70:
    v65 = 0;
    goto LABEL_71;
  }
  cf[0] = 0;
  v78 = 0u;
  v79 = 0;
  cf[1] = (CFTypeRef)v26;
  v38 = (__CFMachPort *)_CFMachPortCreate3(a1, (uint64_t)__CFMessagePortDummyCallback, (__int128 *)cf, 0);
  if (!v38)
  {
    v51 = _CFOSLog();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      __CFMessagePortCreateLocal_cold_4(v51, v52, v53, v54, v55, v56, v57, v58);
LABEL_61:
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
    v24 = (CFTypeRef)v26;
LABEL_62:
    CFRelease(v24);
    return 0;
  }
  v39 = v38;
  special_port[0] = CFMachPortGetPort(v38);
  v40 = bootstrap_register2();
  if (v40)
  {
    v41 = v40;
    v42 = _CFOSLog();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      v76 = bootstrap_strerror(v41);
      *(_DWORD *)buf = 67110146;
      v83 = v41;
      v84 = 1024;
      v85 = v41;
      v86 = 2080;
      v87 = v76;
      v88 = 1024;
      v89 = special_port[0];
      v90 = 2080;
      v91 = ptr;
      _os_log_error_impl(&dword_182A8C000, v42, OS_LOG_TYPE_ERROR, "*** CFMessagePort: bootstrap_register(): failed %d (0x%x) '%s', port = 0x%x, name = '%s'\nSee /usr/include/servers/bootstrap_defs.h for the error codes.", buf, 0x28u);
    }
    CFMachPortInvalidate(v39);
    CFRelease(v39);
    goto LABEL_61;
  }
LABEL_72:
  CFMachPortSetInvalidationCallBack(v39, (CFMachPortInvalidationCallBack)__CFMessagePortInvalidationCallBack);
  *(_QWORD *)(v26 + 24) = v39;
LABEL_73:
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
  v66 = atomic_load(v27);
  while (2)
  {
    v67 = __ldaxr(v27);
    if (v67 == v66)
    {
      if (!__stlxr(v66 | 1, v27))
      {
        v68 = 1;
        goto LABEL_79;
      }
    }
    else
    {
      __clrex();
    }
    v68 = 0;
LABEL_79:
    v66 = v67;
    if (!v68)
      continue;
    break;
  }
  if (a4)
  {
    v69 = *a4;
    v70 = a4[1];
    *(_QWORD *)(v26 + 152) = *((_QWORD *)a4 + 4);
    *(_OWORD *)(v26 + 136) = v70;
    *(_OWORD *)(v26 + 120) = v69;
    v71 = *((_QWORD *)a4 + 1);
    v72 = (uint64_t (*)(uint64_t))*((_QWORD *)a4 + 2);
    if (v72)
      v71 = v72(v71);
    *(_QWORD *)(v26 + 128) = v71;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (!v15)
  {
LABEL_92:
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
    if (a5)
      *a5 = 0;
    return (CFTypeRef)v26;
  }
  cf[0] = 0;
  if (!__CFAllLocalMessagePorts)
    goto LABEL_90;
  if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllLocalMessagePorts, SanitizedStringName, cf))
  {
    Mutable = (__CFDictionary *)__CFAllLocalMessagePorts;
    if (__CFAllLocalMessagePorts)
    {
LABEL_91:
      CFDictionaryAddValue(Mutable, SanitizedStringName, (const void *)v26);
      goto LABEL_92;
    }
LABEL_90:
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
    __CFAllLocalMessagePorts = (uint64_t)Mutable;
    goto LABEL_91;
  }
  CFRetain(cf[0]);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  CFRelease((CFTypeRef)v26);
  return cf[0];
}

CFTypeRef CFMessagePortCreatePerProcessLocal(__objc2_class **a1, const __CFString *a2, uint64_t a3, __int128 *a4, _BYTE *a5)
{
  return __CFMessagePortCreateLocal(a1, a2, a3, a4, a5, 1, 0);
}

CFTypeRef _CFMessagePortCreateLocalEx(__objc2_class **a1, const __CFString *a2, int a3, uint64_t a4, uint64_t a5, __int128 *a6, _BYTE *a7)
{
  return __CFMessagePortCreateLocal(a1, a2, 0, a6, a7, a3, a5);
}

unint64_t *CFMessagePortCreatePerProcessRemote(__objc2_class **a1, const __CFString *a2, int a3)
{
  return __CFMessagePortCreateRemote(a1, a2, 1, a3);
}

Boolean CFMessagePortIsRemote(CFMessagePortRef ms)
{
  unint64_t v2;
  unsigned int v3;

  v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35)
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  v3 = atomic_load((unint64_t *)ms + 1);
  return (v3 >> 2) & 1;
}

CFStringRef CFMessagePortGetName(CFMessagePortRef ms)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35)
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  return (CFStringRef)*((_QWORD *)ms + 2);
}

Boolean CFMessagePortSetName(CFMessagePortRef ms, CFStringRef newName)
{
  unint64_t v4;
  CFAllocatorRef v5;
  unint64_t *v6;
  char v7;
  __objc2_class **v8;
  CFStringRef SanitizedStringName;
  CFStringRef v10;
  os_unfair_lock_s *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  const void *v19;
  __CFMachPort *v20;
  __CFMachPort **v21;
  ipc_space_t *v22;
  __CFMachPort *v23;
  __CFMachPort *v24;
  kern_return_t v25;
  kern_return_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  char v36;
  mach_port_t Port;
  __CFDictionary *Mutable;
  const void *v39;
  unint64_t v40;
  uint64_t v42;
  void *value[2];
  __int128 v44;
  uint64_t v45;
  mach_port_t special_port[2];
  void *ptr[2];

  ptr[1] = *(void **)MEMORY[0x1E0C80C00];
  v4 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v4 != 35)
    _CFAssertMismatchedTypeID(0x23uLL, v4);
  v5 = CFGetAllocator(ms);
  ptr[0] = 0;
  if (*((_DWORD *)ms + 11))
    goto LABEL_14;
  v6 = (unint64_t *)((char *)ms + 8);
  v7 = atomic_load((unint64_t *)ms + 1);
  if ((v7 & 4) != 0)
    goto LABEL_14;
  v8 = (__objc2_class **)v5;
  SanitizedStringName = __CFMessagePortCreateSanitizedStringName(newName, (UInt8 **)ptr);
  if (!SanitizedStringName)
    return SanitizedStringName;
  v10 = SanitizedStringName;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  value[0] = 0;
  if (__CFAllLocalMessagePorts
    && CFDictionaryGetValueIfPresent((CFDictionaryRef)__CFAllLocalMessagePorts, v10, (const void **)value))
  {
    v11 = (os_unfair_lock_s *)&__CFAllMessagePortsLock;
LABEL_13:
    os_unfair_lock_unlock(v11);
    CFRelease(v10);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr[0]);
LABEL_14:
    LOBYTE(SanitizedStringName) = 0;
    return SanitizedStringName;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  os_unfair_lock_lock((os_unfair_lock_t)ms + 28);
  if (*((_QWORD *)ms + 8))
  {
    CFLog(7, (uint64_t)CFSTR("*** CFMessagePort: Unable to SetName on CFMessagePort %p as it already has a dispatch queue associated with itself."), v12, v13, v14, v15, v16, v17, (__int16)ms);
LABEL_12:
    v11 = (os_unfair_lock_s *)((char *)ms + 112);
    goto LABEL_13;
  }
  v18 = dyld_program_sdk_at_least();
  v19 = (const void *)*((_QWORD *)ms + 2);
  if (v18)
  {
    if (v19)
      goto LABEL_12;
  }
  else if (v19)
  {
    if (CFEqual(v19, v10))
    {
      CFRelease(v10);
      goto LABEL_48;
    }
    v21 = (__CFMachPort **)((char *)ms + 24);
    v20 = (__CFMachPort *)*((_QWORD *)ms + 3);
    if (*((_QWORD *)ms + 2))
    {
      v40 = atomic_load(v6);
      v42 = (v40 >> 1) & 1;
    }
    else
    {
      LODWORD(v42) = 0;
    }
    goto LABEL_21;
  }
  LODWORD(v42) = 0;
  v21 = (__CFMachPort **)((char *)ms + 24);
  v20 = (__CFMachPort *)*((_QWORD *)ms + 3);
LABEL_21:
  *(_QWORD *)special_port = 0;
  v22 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  task_get_special_port(*MEMORY[0x1E0C83DA0], 4, &special_port[1]);
  if (bootstrap_check_in(special_port[1], (const char *__attribute__((__org_typedef(name_t))))ptr[0], special_port))
    goto LABEL_22;
  if (mach_port_insert_right(*v22, special_port[0], special_port[0], 0x14u))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    mach_port_mod_refs(*v22, special_port[0], 1u, -1);
LABEL_28:
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr[0]);
    CFRelease(v10);
    goto LABEL_14;
  }
  value[0] = 0;
  v44 = 0u;
  v45 = 0;
  value[1] = ms;
  v33 = _CFMachPortCreateWithPort3(v8, special_port[0], (uint64_t)__CFMessagePortDummyCallback, (__int128 *)value, 0);
  v24 = (__CFMachPort *)v33;
  v34 = atomic_load((unint64_t *)ms + 1);
  do
  {
    v35 = __ldaxr(v6);
    if (v35 == v34)
    {
      if (!__stlxr(v34 | 2, v6))
      {
        v36 = 1;
        goto LABEL_35;
      }
    }
    else
    {
      __clrex();
    }
    v36 = 0;
LABEL_35:
    v34 = v35;
  }
  while ((v36 & 1) == 0);
  if (v33)
    goto LABEL_37;
LABEL_22:
  value[0] = 0;
  v44 = 0u;
  v45 = 0;
  value[1] = ms;
  v23 = (__CFMachPort *)_CFMachPortCreate3(v8, (uint64_t)__CFMessagePortDummyCallback, (__int128 *)value, 0);
  if (!v23)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    goto LABEL_28;
  }
  v24 = v23;
  special_port[0] = CFMachPortGetPort(v23);
  v25 = bootstrap_register2();
  if (v25)
  {
    v26 = v25;
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    bootstrap_strerror(v26);
    CFLog(7, (uint64_t)CFSTR("*** CFMessagePort: bootstrap_register(): failed %d (0x%x) '%s', port = 0x%x, name = '%s'\nSee /usr/include/servers/bootstrap_defs.h for the error codes."), v27, v28, v29, v30, v31, v32, v26);
    CFMachPortInvalidate(v24);
    CFRelease(v24);
    goto LABEL_28;
  }
LABEL_37:
  CFMachPortSetInvalidationCallBack(v24, (CFMachPortInvalidationCallBack)__CFMessagePortInvalidationCallBack);
  *v21 = v24;
  if (v20 && v20 != v24)
  {
    if ((_DWORD)v42)
    {
      if (*((_QWORD *)ms + 8))
        CFMessagePortSetName_cold_1();
      Port = CFMachPortGetPort(v20);
      mach_port_mod_refs(*v22, Port, 1u, -1);
      mach_port_deallocate(*v22, Port);
    }
    CFMachPortInvalidate(v20);
    CFRelease(v20);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  Mutable = (__CFDictionary *)__CFAllLocalMessagePorts;
  if (!__CFAllLocalMessagePorts)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
    __CFAllLocalMessagePorts = (uint64_t)Mutable;
  }
  v39 = (const void *)*((_QWORD *)ms + 2);
  if (v39)
  {
    CFDictionaryRemoveValue(Mutable, v39);
    CFRelease(*((CFTypeRef *)ms + 2));
    Mutable = (__CFDictionary *)__CFAllLocalMessagePorts;
  }
  *((_QWORD *)ms + 2) = v10;
  CFDictionaryAddValue(Mutable, v10, ms);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
LABEL_48:
  os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr[0]);
  LOBYTE(SanitizedStringName) = 1;
  return SanitizedStringName;
}

void __CFMessagePortInvalidationCallBack(int a1, CFMessagePortRef ms)
{
  if (ms)
    CFMessagePortInvalidate(ms);
}

void CFMessagePortGetContext(CFMessagePortRef ms, CFMessagePortContext *context)
{
  unint64_t v4;
  __int128 v5;
  __int128 v6;

  v4 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v4 != 35)
    _CFAssertMismatchedTypeID(0x23uLL, v4);
  v5 = *(_OWORD *)((char *)ms + 120);
  v6 = *(_OWORD *)((char *)ms + 136);
  context->copyDescription = (CFStringRef (__cdecl *)(const void *))*((_QWORD *)ms + 19);
  *(_OWORD *)&context->version = v5;
  *(_OWORD *)&context->retain = v6;
}

void CFMessagePortInvalidate(CFMessagePortRef ms)
{
  unint64_t v2;
  unint64_t *v3;
  char v4;
  char v5;
  uint64_t v6;
  __CFMachPort *v7;
  __CFRunLoopSource *v8;
  NSObject *v9;
  void (*v10)(CFMessagePortRef, uint64_t);
  __CFMachPort *v11;
  const void *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  char v16;
  uint64_t v17;
  uint64_t *v18;
  char v19;
  uint64_t *v20;
  char v21;
  char v22;
  void (*v23)(uint64_t);
  mach_port_t Port;
  char v25;
  char v26;
  char v27;
  uint64_t v28;

  if (!ms)
    return;
  v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35)
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  v3 = (unint64_t *)((char *)ms + 8);
  v4 = atomic_load((unint64_t *)ms + 1);
  if ((v4 & 8) == 0)
    CFRetain(ms);
  os_unfair_lock_lock((os_unfair_lock_t)ms + 28);
  v5 = atomic_load(v3);
  if ((v5 & 1) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    goto LABEL_45;
  }
  v6 = *((_QWORD *)ms + 8);
  if (v6)
  {
    dispatch_source_cancel(*((dispatch_source_t *)ms + 8));
    *((_QWORD *)ms + 8) = 0;
    *((_QWORD *)ms + 9) = 0;
  }
  v28 = v6;
  v7 = (__CFMachPort *)*((_QWORD *)ms + 6);
  v8 = (__CFRunLoopSource *)*((_QWORD *)ms + 7);
  v9 = *((_QWORD *)ms + 10);
  v10 = (void (*)(CFMessagePortRef, uint64_t))*((_QWORD *)ms + 11);
  v12 = (const void *)*((_QWORD *)ms + 2);
  v11 = (__CFMachPort *)*((_QWORD *)ms + 3);
  v13 = atomic_load((unint64_t *)ms + 1);
  do
  {
    v14 = __ldaxr(v3);
    if (v14 == v13)
    {
      if (!__stlxr(v13 & 0xFFFFFFFFFFFFFFFELL, v3))
      {
        v15 = 1;
        goto LABEL_15;
      }
    }
    else
    {
      __clrex();
    }
    v15 = 0;
LABEL_15:
    v13 = v14;
  }
  while (!v15);
  v16 = atomic_load(v3);
  if ((v16 & 4) != 0)
  {
    v17 = 0;
  }
  else
  {
    v17 = *((_QWORD *)ms + 16);
    *((_QWORD *)ms + 16) = 0;
  }
  *((_QWORD *)ms + 3) = 0;
  *((_QWORD *)ms + 10) = 0;
  *((_QWORD *)ms + 6) = 0;
  *((_QWORD *)ms + 7) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (!*((_DWORD *)ms + 11) && v12)
  {
    v18 = &__CFAllRemoteMessagePorts;
    v19 = atomic_load(v3);
    v20 = (v19 & 4) != 0 ? &__CFAllRemoteMessagePorts : &__CFAllLocalMessagePorts;
    if (*v20)
    {
      v21 = atomic_load(v3);
      if ((v21 & 4) == 0)
        v18 = &__CFAllLocalMessagePorts;
      CFDictionaryRemoveValue((CFMutableDictionaryRef)*v18, v12);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFAllMessagePortsLock);
  if (v10)
    v10(ms, v17);
  v22 = atomic_load(v3);
  if ((v22 & 4) == 0)
  {
    v23 = (void (*)(uint64_t))*((_QWORD *)ms + 18);
    if (v23)
      v23(v17);
  }
  if (v8)
  {
    CFRunLoopSourceInvalidate(v8);
    CFRelease(v8);
  }
  if (v7)
  {
    CFMachPortInvalidate(v7);
    CFRelease(v7);
  }
  if (v11)
  {
    Port = CFMachPortGetPort(v11);
    v25 = atomic_load(v3);
    if ((v25 & 4) != 0)
      _cfmp_record_deallocation(1u, Port, 1, 0);
    CFMachPortSetInvalidationCallBack(v11, 0);
    v26 = atomic_load(v3);
    _cfmp_record_deallocation(1u, Port, (v26 & 2) != 0, (v26 & 2) != 0);
    CFMachPortInvalidate(v11);
    CFRelease(v11);
  }
  if (v9)
  {
    if (v28)
      dispatch_semaphore_wait(v9, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v9);
  }
LABEL_45:
  v27 = atomic_load(v3);
  if ((v27 & 8) == 0)
    CFRelease(ms);
}

CFMessagePortInvalidationCallBack CFMessagePortGetInvalidationCallBack(CFMessagePortRef ms)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v2 != 35)
    _CFAssertMismatchedTypeID(0x23uLL, v2);
  return (CFMessagePortInvalidationCallBack)*((_QWORD *)ms + 11);
}

void CFMessagePortSetInvalidationCallBack(CFMessagePortRef ms, CFMessagePortInvalidationCallBack callout)
{
  unint64_t v3;
  char v4;

  v3 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v3 != 35)
    _CFAssertMismatchedTypeID(0x23uLL, v3);
  v4 = atomic_load((unint64_t *)ms + 1);
  if (!callout || (v4 & 1) != 0)
    *((_QWORD *)ms + 11) = callout;
  else
    ((void (*)(CFMessagePortRef, _QWORD))callout)(ms, *((_QWORD *)ms + 16));
}

void __CFMessagePortReplyCallBack(uint64_t a1, int *a2, unint64_t a3, uint64_t a4)
{
  os_unfair_lock_s *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  _BOOL4 v15;
  uint64_t v16;
  int v17;
  unint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  const UInt8 *v22;
  const __CFData *v23;
  unint64_t v24;
  int v25;
  _BOOL4 v27;
  CFDataRef v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  BOOL v32;
  int v33;
  int v34;
  BOOL v35;
  BOOL v36;
  BOOL v37;
  uint64_t v38;
  _BOOL4 v39;

  v7 = (os_unfair_lock_s *)(a4 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a4 + 112));
  v14 = atomic_load((unint64_t *)(a4 + 8));
  if ((v14 & 1) == 0)
    goto LABEL_79;
  if (a3 < 0x18)
  {
LABEL_3:
    LOWORD(v15) = 0;
LABEL_78:
    CFLog(4, (uint64_t)CFSTR("*** CFMessagePort: dropping corrupt reply Mach message (0b%d%d%d%d%d%d)"), v8, v9, v10, v11, v12, v13, v15);
    mach_msg_destroy((mach_msg_header_t *)a2);
    goto LABEL_79;
  }
  v17 = *a2;
  if (*a2 < 0)
  {
    if (a3 < 0x3C)
      goto LABEL_3;
    LODWORD(v24) = a2[1];
    if (v24 < 0x3C)
      goto LABEL_3;
    v25 = a2[11];
    v15 = v25 != -252513032 && v25 != -118164752;
    v27 = a2[6] != 1 || *((unsigned __int8 *)a2 + 39) != 1;
    goto LABEL_56;
  }
  if (a2[5] == 1128680784)
  {
    if (a3 < 0x38)
      goto LABEL_3;
    v18 = 56;
  }
  else
  {
    if (a3 < 0x3C)
      goto LABEL_3;
    v18 = 60;
  }
  v24 = a2[1];
  if (v18 > v24)
    goto LABEL_3;
  if (a2[5] != 1128680784)
  {
    if (a2[11] == -252513032)
    {
      v15 = 0;
      goto LABEL_54;
    }
    v30 = 11;
LABEL_53:
    v15 = a2[v30] != -118164752;
LABEL_54:
    v27 = 0;
    if (a2[5] == 1128680784)
      goto LABEL_55;
LABEL_56:
    v31 = 4060;
    goto LABEL_57;
  }
  if (a2[10] != -252513032)
  {
    v30 = 10;
    goto LABEL_53;
  }
  v27 = 0;
  v15 = 0;
LABEL_55:
  v31 = 4056;
LABEL_57:
  v32 = v31 < v24;
  if (v27 || v31 < v24)
  {
    v35 = 0;
    v33 = 0;
    if (v17 < 0)
      goto LABEL_76;
    goto LABEL_74;
  }
  if (v17 < 0)
  {
    v33 = a2[14];
    v36 = (v33 - 1610612737) < 0x9FFFFFFE || a2[10] != v33;
    v35 = v36;
    goto LABEL_76;
  }
  if (a2[5] == 1128680784)
  {
    v33 = a2[13];
    if ((v33 - 1610612737) >= 0x9FFFFFFE)
    {
      v34 = -56;
LABEL_72:
      v37 = v34 + (int)v24 < v33;
      goto LABEL_73;
    }
  }
  else
  {
    v33 = a2[14];
    if ((v33 - 1610612737) >= 0x9FFFFFFE)
    {
      v34 = -60;
      goto LABEL_72;
    }
  }
  v37 = 1;
LABEL_73:
  v35 = v37;
LABEL_74:
  if (a2[5] == 1128680784)
  {
    v38 = 10;
    goto LABEL_77;
  }
LABEL_76:
  v38 = 11;
LABEL_77:
  v39 = a2[v38 + 2] >= 0;
  if (v27 || v15 || v32 || v35 || v39)
    goto LABEL_78;
  if (*a2 < 0 || a2[5] != 1128680784)
    v16 = 11;
  else
    v16 = 10;
  v19 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a4 + 32), (const void *)a2[v16 + 2]);
  v20 = *a2;
  if (v19)
  {
    if (v20 < 0)
    {
      v28 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(const UInt8 **)(a2 + 7), a2[10]);
      mach_vm_deallocate(*MEMORY[0x1E0C83DA0], *(_QWORD *)(a2 + 7), a2[10]);
    }
    else
    {
      v21 = 11;
      if (a2[5] == 1128680784)
        v21 = 10;
      v22 = (const UInt8 *)&a2[v21 + 4];
      if (&v22[v33] <= (const UInt8 *)a2 + a2[1])
        v23 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v22, v33 & ~(v33 >> 31));
      else
        v23 = (const __CFData *)CFRetain(&__kCFBooleanFalse);
      v28 = v23;
    }
    if (*a2 < 0 || a2[5] != 1128680784)
      v29 = 11;
    else
      v29 = 10;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a4 + 32), (const void *)a2[v29 + 2], v28);
    CFRelease(v28);
  }
  else if (v20 < 0)
  {
    mach_vm_deallocate(*MEMORY[0x1E0C83DA0], *(_QWORD *)(a2 + 7), a2[10]);
  }
LABEL_79:
  os_unfair_lock_unlock(v7);
}

CFRunLoopSourceRef CFMessagePortCreateRunLoopSource(CFAllocatorRef allocator, CFMessagePortRef local, CFIndex order)
{
  unint64_t v6;
  char v7;
  os_unfair_lock_s *v8;
  __CFRunLoopSource *v9;
  int IsValid;
  CFRunLoopSourceRef v11;
  __CFRunLoopSource *v12;
  char v13;
  CFRunLoopSourceContext v15;

  v15.perform = (void (__cdecl *)(void *))*MEMORY[0x1E0C80C00];
  if (local)
  {
    v6 = _CFGetNonObjCTypeID((unint64_t *)local);
    if (v6 != 35)
      _CFAssertMismatchedTypeID(0x23uLL, v6);
  }
  if (CFMessagePortIsValid(local))
  {
    v7 = atomic_load((unint64_t *)local + 1);
    if ((v7 & 4) == 0)
    {
      v8 = (os_unfair_lock_s *)((char *)local + 112);
      os_unfair_lock_lock((os_unfair_lock_t)local + 28);
      v9 = (__CFRunLoopSource *)*((_QWORD *)local + 7);
      if (v9)
      {
        IsValid = CFRunLoopSourceIsValid(v9);
        v11 = (CFRunLoopSourceRef)*((_QWORD *)local + 7);
        if (IsValid)
        {
          if (v11)
            goto LABEL_17;
        }
        else
        {
          CFRelease(v11);
          *((_QWORD *)local + 7) = 0;
        }
      }
      if (*((_QWORD *)local + 8))
        goto LABEL_12;
      v13 = atomic_load((unint64_t *)local + 1);
      if ((v13 & 1) != 0)
      {
        v15.version = 1;
        v15.info = local;
        v15.retain = CFRetain;
        v15.release = CFRelease;
        v15.copyDescription = (CFStringRef (__cdecl *)(const void *))__CFMessagePortCopyDescription;
        v15.equal = 0;
        v15.hash = 0;
        v15.schedule = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMessagePortGetPort;
        v15.cancel = (void (__cdecl *)(void *, CFRunLoopRef, CFRunLoopMode))__CFMessagePortPerform;
        v11 = CFRunLoopSourceCreate(allocator, order, &v15);
        *((_QWORD *)local + 7) = v11;
      }
      else
      {
        v11 = (CFRunLoopSourceRef)*((_QWORD *)local + 7);
      }
      if (!v11)
      {
LABEL_12:
        v12 = 0;
LABEL_18:
        os_unfair_lock_unlock(v8);
        return v12;
      }
LABEL_17:
      v12 = (__CFRunLoopSource *)CFRetain(v11);
      goto LABEL_18;
    }
  }
  return 0;
}

__CFMachPort *__CFMessagePortGetPort(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFMachPort *result;
  char v10;

  result = *(__CFMachPort **)(a1 + 24);
  if (result)
    return (__CFMachPort *)CFMachPortGetPort(result);
  v10 = atomic_load((unint64_t *)(a1 + 8));
  if ((v10 & 1) != 0)
    CFLog(4, (uint64_t)CFSTR("*** Warning: A local CFMessagePort (%p) is being put in a run loop or dispatch queue, but it has not been named yet, so this will be a no-op and no messages are going to be received, even if named later."), a3, a4, a5, a6, a7, a8, a1);
  result = *(__CFMachPort **)(a1 + 24);
  if (result)
    return (__CFMachPort *)CFMachPortGetPort(result);
  return result;
}

void CFMessagePortSetDispatchQueue(CFMessagePortRef ms, dispatch_queue_t queue)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const __CFString *v19;
  char v20;
  NSObject *v21;
  _QWORD *v22;
  unsigned int Port;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  NSObject *v31;
  NSObject *v32;
  uint64_t v33;
  _QWORD v34[6];
  unsigned int v35;
  _QWORD handler[7];
  unsigned int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = _CFGetNonObjCTypeID((unint64_t *)ms);
  if (v4 != 35)
    _CFAssertMismatchedTypeID(0x23uLL, v4);
  os_unfair_lock_lock((os_unfair_lock_t)ms + 28);
  v12 = atomic_load((unint64_t *)ms + 1);
  if ((v12 & 1) == 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    v19 = CFSTR("*** CFMessagePortSetDispatchQueue(): CFMessagePort is invalid");
LABEL_8:
    CFLog(4, (uint64_t)v19, v13, v14, v15, v16, v17, v18, v34[0]);
    return;
  }
  v20 = atomic_load((unint64_t *)ms + 1);
  if ((v20 & 4) != 0)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    v19 = CFSTR("*** CFMessagePortSetDispatchQueue(): CFMessagePort is not a local port, queue cannot be set");
    goto LABEL_8;
  }
  if (*((_QWORD *)ms + 7))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
    v19 = CFSTR("*** CFMessagePortSetDispatchQueue(): CFMessagePort already has a CFRunLoopSourceRef, queue cannot be set");
    goto LABEL_8;
  }
  v22 = (_QWORD *)((char *)ms + 64);
  v21 = *((_QWORD *)ms + 8);
  if (v21)
  {
    dispatch_source_cancel(v21);
    *v22 = 0;
    *((_QWORD *)ms + 9) = 0;
  }
  if (queue)
  {
    Port = __CFMessagePortGetPort((uint64_t)ms, v5, v6, v7, v8, v9, v10, v11);
    if (Port)
    {
      v30 = Port;
      if (CFMessagePortSetDispatchQueue_once != -1)
        dispatch_once(&CFMessagePortSetDispatchQueue_once, &__block_literal_global_6);
      v31 = dispatch_semaphore_create(0);
      dispatch_retain(v31);
      *((_QWORD *)ms + 10) = v31;
      _cfmp_record_intent_to_invalidate(1, v30);
      v32 = dispatch_source_create(MEMORY[0x1E0C80D98], v30, 0, (dispatch_queue_t)CFMessagePortSetDispatchQueue_mportQueue);
      v33 = MEMORY[0x1E0C809B0];
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 0x40000000;
      handler[2] = __CFMessagePortSetDispatchQueue_block_invoke_2;
      handler[3] = &__block_descriptor_tmp_16;
      handler[4] = queue;
      handler[5] = v32;
      v37 = v30;
      handler[6] = v31;
      dispatch_source_set_cancel_handler(v32, handler);
      v34[0] = v33;
      v34[1] = 0x40000000;
      v34[2] = __CFMessagePortSetDispatchQueue_block_invoke_3;
      v34[3] = &__block_descriptor_tmp_18;
      v35 = v30;
      v34[4] = ms;
      v34[5] = queue;
      dispatch_source_set_event_handler(v32, v34);
      *((_QWORD *)ms + 8) = v32;
      if (v32)
        goto LABEL_16;
    }
    else if (*v22)
    {
LABEL_16:
      dispatch_retain(queue);
      *((_QWORD *)ms + 9) = queue;
      dispatch_resume(*((dispatch_object_t *)ms + 8));
      goto LABEL_19;
    }
    CFLog(4, (uint64_t)CFSTR("*** CFMessagePortSetDispatchQueue(): dispatch source could not be created"), v24, v25, v26, v27, v28, v29, v34[0]);
  }
LABEL_19:
  os_unfair_lock_unlock((os_unfair_lock_t)ms + 28);
}

void OUTLINED_FUNCTION_0_7(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

CFTypeID CFNotificationCenterGetTypeID(void)
{
  return 52;
}

CFMutableStringRef _CFXNotificationCenterCopyDebugInfo(uint64_t a1)
{
  CFMutableStringRef Mutable;
  os_unfair_lock_s *v3;
  _QWORD v5[7];

  v5[6] = *MEMORY[0x1E0C80C00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  v3 = *(os_unfair_lock_s **)(a1 + 16);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = ___CFXNotificationCenterCopyDebugInfo_block_invoke;
  v5[3] = &__block_descriptor_48_e80_v16__0___CFXNotificationRegistration_____CFString__v_vQ_________v_____Q___i_Q__8l;
  v5[4] = Mutable;
  v5[5] = a1;
  CFXNotificationRegistrarEnumerate(v3, (uint64_t)v5);
  return Mutable;
}

BOOL _CFXNotificationCenterIsEmpty(uint64_t a1)
{
  return CFXNotificationRegistrarIsEmpty(*(os_unfair_lock_s **)(a1 + 16));
}

void _CFXNotificationGetSuspended(uint64_t a1)
{
  char v2;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    v2 = atomic_load((unint64_t *)(a1 + 8));
    if ((v2 & 2) != 0)
      atomic_load((unint64_t *)(a1 + 8));
    else
      __break(1u);
  }
}

void CFNotificationCenterSetSuspended(unint64_t *a1, int a2)
{
  unint64_t v4;

  v4 = _CFGetNonObjCTypeID(a1);
  if (v4 != 52)
    _CFAssertMismatchedTypeID(0x34uLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
    _CFXNotificationSetSuspended((uint64_t)a1, a2 != 0);
}

void CFNotificationCenterIsSuspended(unint64_t *a1)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID(a1);
  if (v2 != 52)
    _CFAssertMismatchedTypeID(0x34uLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
    _CFXNotificationGetSuspended((uint64_t)a1);
}

uint64_t ___registerSubNotifications_block_invoke(uint64_t a1)
{
  CFNotificationCenterRef DarwinNotifyCenter;
  uint64_t (*v4)(CFNotificationCenterRef, _QWORD, _QWORD, _QWORD, _QWORD);

  v4 = *(uint64_t (**)(CFNotificationCenterRef, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 24);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  return v4(DarwinNotifyCenter, 0, *(_QWORD *)(a1 + 40), 0, 0);
}

CFStringRef __CFBooleanCopyDescription(__objc2_class **a1)
{
  CFAllocatorRef v2;
  const char *v3;

  v2 = CFGetAllocator(a1);
  if (&__kCFBooleanTrue == a1)
    v3 = "true";
  else
    v3 = "false";
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFBoolean %p [%p]>{value = %s}"), a1, v2, v3);
}

CFStringRef __CFNumberCreateFormattingDescription(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10[2];
  char v11[128];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if ((a2 & 0x8000000000000000) == 0)
    goto LABEL_12;
  v3 = 0;
  v4 = *MEMORY[0x1E0DE7C58];
  if ((~a2 & 0xC000000000000007) == 0)
    v4 = 0;
  v5 = v4 ^ a2;
  v6 = v5 & 7;
  while (v6 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v3))
  {
    if (++v3 == 7)
      goto LABEL_12;
  }
  if (v3 == 3)
  {
    v7 = 0xFFFFFFFFFFFFFFFLL;
    if (v6 == 7)
      v7 = 0xFFFFFFFFFFFFFLL;
    v8 = v7 & (v5 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v8) = atomic_load((unint64_t *)(a2 + 8));
  }
  if ((__CFNumberTypeTable[__CFNumberCanonicalTypes[v8 & 7]] & 0x20) != 0)
    return __CFNumberCreateFormattingDescriptionAsFloat64(a1, (CFNumberRef)a2);
  v10[0] = 0;
  v10[1] = 0;
  __CFNumberGetValue(a2, 17, (uint64_t)v10);
  emit128(v11, v10, 0);
  return CFStringCreateWithFormat(a1, 0, CFSTR("%s"), v11);
}

__CFString *__CFNumberCopyDescription(unint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFString *Mutable;
  CFAllocatorRef v11;
  __int16 v12;
  const char *v13;
  const __CFString *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v18;
  uint64_t v19[2];
  double v20[17];

  v20[16] = *(double *)MEMORY[0x1E0C80C00];
  if (((unint64_t)a1 & 0x8000000000000000) == 0)
    goto LABEL_12;
  v2 = 0;
  v3 = *MEMORY[0x1E0DE7C58];
  if ((~(unint64_t)a1 & 0xC000000000000007) == 0)
    v3 = 0;
  v4 = v3 ^ (unint64_t)a1;
  v5 = v4 & 7;
  while (v5 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v2))
  {
    if (++v2 == 7)
      goto LABEL_12;
  }
  if (v2 == 3)
  {
    v6 = 0xFFFFFFFFFFFFFFFLL;
    if (v5 == 7)
      v6 = 0xFFFFFFFFFFFFFLL;
    v7 = v6 & (v4 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v7) = atomic_load(a1 + 1);
  }
  v8 = v7 & 7;
  v9 = __CFNumberCanonicalTypes[v8];
  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  v11 = CFGetAllocator(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFNumber %p [%p]>{value = "), a1, v11);
  v12 = __CFNumberTypeTable[v9];
  if ((v12 & 0x20) == 0)
  {
    v19[0] = 0;
    v19[1] = 0;
    __CFNumberGetValue((uint64_t)a1, 17, (uint64_t)v19);
    emit128((char *)v20, v19, 1);
    switch(v9)
    {
      case 1:
        v13 = "kCFNumberSInt8Type";
        break;
      case 2:
        v13 = "kCFNumberSInt16Type";
        break;
      case 3:
        v13 = "kCFNumberSInt32Type";
        break;
      case 4:
        v13 = "kCFNumberSInt64Type";
        break;
      default:
        v13 = "unknown integer";
        if (v9 == 17)
          v13 = "kCFNumberSInt128Type";
        break;
    }
    CFStringAppendFormat(Mutable, 0, CFSTR("%s, type = %s}"), v20, v13);
    return Mutable;
  }
  v20[0] = 0.0;
  __CFNumberGetValue((uint64_t)a1, 6, (uint64_t)v20);
  if (fabs(v20[0]) == INFINITY)
  {
    if (v20[0] <= 0.0)
      v14 = CFSTR("-infinity");
    else
      v14 = CFSTR("+infinity");
  }
  else
  {
    if (v20[0] != 0.0)
    {
      v15 = 20;
      if ((v12 & 0x40) == 0)
        v15 = 10;
      CFStringAppendFormat(Mutable, 0, CFSTR("%+.*f"), v20[0], v15, *(_QWORD *)&v20[0]);
      goto LABEL_31;
    }
    if (v20[0] >= 0.0)
      v14 = CFSTR("+0.0");
    else
      v14 = CFSTR("-0.0");
  }
  CFStringAppend(Mutable, v14);
LABEL_31:
  v16 = "unknown float";
  if (v8 == 5)
    v16 = "kCFNumberFloat64Type";
  if (v8 == 4)
    v16 = "kCFNumberFloat32Type";
  CFStringAppendFormat(Mutable, 0, CFSTR(", type = %s}"), v16, v18);
  return Mutable;
}

double _CFNumberInitBool(uint64_t a1, char a2)
{
  double result;
  char v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 7, &v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt8(uint64_t a1, char a2)
{
  double result;
  char v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 7, &v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt8(uint64_t a1, char a2)
{
  double result;
  char v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 7, &v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt16(uint64_t a1, __int16 a2)
{
  double result;
  __int16 v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 8, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt16(uint64_t a1, __int16 a2)
{
  double result;
  __int16 v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 8, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt32(uint64_t a1, int a2)
{
  double result;
  int v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 9, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt32(uint64_t a1, int a2)
{
  double result;
  int v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 9, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt(uint64_t a1, uint64_t a2)
{
  double result;
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v3[0] = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 10, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt(uint64_t a1, uint64_t a2)
{
  double result;
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v3[0] = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 10, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitInt64(uint64_t a1, uint64_t a2)
{
  double result;
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v3[0] = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 11, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitUInt64(uint64_t a1, uint64_t a2)
{
  double result;
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v3[0] = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 11, (char *)v3).n128_u64[0];
  return result;
}

double _CFNumberInitFloat(uint64_t a1, float a2)
{
  double result;
  float v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 12, (char *)&v3).n128_u64[0];
  return result;
}

double _CFNumberInitDouble(uint64_t a1, double a2)
{
  double result;
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  *(double *)v3 = a2;
  *(_QWORD *)&result = __CFNumberInit(a1, 13, (char *)v3).n128_u64[0];
  return result;
}

CFStringRef __CFNumberFormatterCopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  CFAllocatorRef v3;

  v2 = CFGetAllocator(a1);
  v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFNumberFormatter %p [%p]>"), a1, v3);
}

CFTypeID CFNumberFormatterGetTypeID(void)
{
  return 57;
}

CFNumberFormatterStyle CFNumberFormatterGetStyle(CFNumberFormatterRef formatter)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 57)
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  return *((_QWORD *)formatter + 4);
}

Boolean CFNumberFormatterGetDecimalInfoForCurrencyCode(CFStringRef currencyCode, int32_t *defaultFractionDigits, double *roundingIncrement)
{
  Boolean result;
  int v6;
  UniChar buffer[4];
  uint64_t v8;
  CFRange v9;

  v8 = *MEMORY[0x1E0C80C00];
  v9.location = 0;
  v9.length = 3;
  CFStringGetCharacters(currencyCode, v9, buffer);
  buffer[3] = 0;
  v6 = 0;
  if (defaultFractionDigits)
    *defaultFractionDigits = __cficu_ucurr_getDefaultFractionDigits(buffer, &v6);
  if (roundingIncrement)
    *roundingIncrement = __cficu_ucurr_getRoundingIncrement(buffer, &v6);
  if (v6 > 0)
    return 0;
  if (!defaultFractionDigits)
  {
    if (!roundingIncrement)
      return 1;
    return *roundingIncrement >= 0.0;
  }
  result = *defaultFractionDigits >= 0;
  if (roundingIncrement && (*defaultFractionDigits & 0x80000000) == 0)
    return *roundingIncrement >= 0.0;
  return result;
}

void __CFNumberFormatterApplySymbolPrefs(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  CFTypeID v6;
  CFTypeID v7;
  SInt32 IntValue;
  CFIndex Length;
  uint64_t v10;
  uint64_t v11;
  CFIndex v12;
  uint64_t v13;
  UniChar *v14;
  const UniChar *CharactersPtr;
  UChar *v16;
  uint64_t v17;
  uint64_t v18;
  CFRange v19;

  v18 = *MEMORY[0x1E0C80C00];
  v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    v7 = CFGetTypeID(a2);
    if (v7 == CFStringGetTypeID())
    {
      IntValue = CFStringGetIntValue(a1);
      HIDWORD(v17) = 0;
      Length = CFStringGetLength(a2);
      if (Length < 1)
      {
        __cficu_unum_setSymbol(*(_QWORD *)(a3 + 16), IntValue, &word_182F202E0, 0, (int *)&v17 + 1);
      }
      else
      {
        v11 = Length;
        if (Length >= 768)
          v12 = 768;
        else
          v12 = Length;
        MEMORY[0x1E0C80A78](Length, v10);
        v14 = (UniChar *)((char *)&v17 - v13);
        CharactersPtr = CFStringGetCharactersPtr(a2);
        if (CharactersPtr)
        {
          v16 = (UChar *)CharactersPtr;
        }
        else
        {
          v19.location = 0;
          v19.length = v12;
          CFStringGetCharacters(a2, v19, v14);
          v11 = v12;
          v16 = v14;
        }
        __cficu_unum_setSymbol(*(_QWORD *)(a3 + 16), IntValue, v16, v11, (int *)&v17 + 1);
      }
    }
  }
}

void sub_182BC2BF8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void mutateError(SEL sel, uint64_t a2, void *a3)
{
  const char *Name;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  Class Class;

  if (a2 != 3)
  {
    if (a2 != 2)
    {
      if (a2 == 1)
      {
        Name = sel_getName(sel);
        _CFThrowFormattedException((uint64_t)CFSTR("NSInvalidArgumentException"), CFSTR("Attempt to mutate immutable object with %s"), Name);
      }
      v5 = sel_getName(sel);
      Class = object_getClass(a3);
      _CFThrowFormattedException((uint64_t)CFSTR("NSInvalidArgumentException"), CFSTR("Can't call %s in %@"), v5, Class);
    }
    v7 = __CFExceptionProem((objc_class *)a3, sel);
    _CFThrowFormattedException((uint64_t)CFSTR("NSInvalidArgumentException"), CFSTR("%@: nil argument"), v7);
  }
  v6 = __CFExceptionProem((objc_class *)a3, sel);
  _CFThrowFormattedException((uint64_t)CFSTR("NSInvalidArgumentException"), CFSTR("%@: Range or index out of bounds"), v6);
}

void mutateError2(SEL sel, uint64_t a2, void *a3)
{
  const char *Name;
  const char *v5;
  uint64_t v6;
  uint64_t v7;
  Class Class;

  if (a2 != 3)
  {
    if (a2 != 2)
    {
      if (a2 == 1)
      {
        Name = sel_getName(sel);
        _CFThrowFormattedException((uint64_t)CFSTR("NSInvalidArgumentException"), CFSTR("Attempt to mutate immutable object with %s"), Name);
      }
      v5 = sel_getName(sel);
      Class = object_getClass(a3);
      _CFThrowFormattedException((uint64_t)CFSTR("NSInvalidArgumentException"), CFSTR("Can't call %s in %@"), v5, Class);
    }
    v7 = __CFExceptionProem((objc_class *)a3, sel);
    _CFThrowFormattedException((uint64_t)CFSTR("NSInvalidArgumentException"), CFSTR("%@: nil argument"), v7);
  }
  v6 = __CFExceptionProem((objc_class *)a3, sel);
  _CFThrowFormattedException((uint64_t)CFSTR("NSInvalidArgumentException"), CFSTR("%@: Range or index out of bounds"), v6);
}

uint64_t __CFDescribeTimer(uint64_t a1, uint64_t a2, char *a3, size_t a4, char *a5, size_t a6, uint64_t *a7)
{
  void *v12;
  const char *v13;
  const char *ClassName;
  const char *Name;
  const char *v16;
  const char *v17;
  Class Class;
  uint64_t result;
  const char *dli_fname;
  Dl_info v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v12 = *(void **)(a2 + 8);
  v13 = *(const char **)(a2 + 16);
  ClassName = object_getClassName(v12);
  Name = sel_getName(v13);
  if (a7)
    *a7 = object_getMethodImplementation();
  v16 = "<unknown name>";
  if (ClassName)
    v16 = ClassName;
  v17 = "<unknown selector>";
  if (Name)
    v17 = Name;
  snprintf(a5, a6, "(CFTimer) %s %s", v16, v17);
  Class = object_getClass(v12);
  memset(&v21, 0, sizeof(v21));
  result = dladdr(Class, &v21);
  if ((_DWORD)result)
  {
    dli_fname = v21.dli_fname;
    if (!v21.dli_fname)
      dli_fname = "<unknown library>";
    return snprintf(a3, a4, "%s", dli_fname);
  }
  return result;
}

unsigned int *_timerRetain(unsigned int *result)
{
  unsigned int v1;

  do
    v1 = __ldaxr(result);
  while (__stlxr(v1 + 1, result));
  return result;
}

unsigned int *_timerRelease(unsigned int *result)
{
  id *v1;
  unsigned int v2;
  BOOL v3;
  signed int v4;
  void *v5;

  v1 = (id *)result;
  do
  {
    v2 = __ldaxr(result);
    v3 = __OFSUB__(v2, 1);
    v4 = v2 - 1;
  }
  while (__stlxr(v4, result));
  if ((v4 < 0) ^ v3 | (v4 == 0))
  {
    v5 = (void *)_CFAutoreleasePoolPush();

    free(v1);
    return (unsigned int *)_CFAutoreleasePoolPop(v5);
  }
  return result;
}

void OUTLINED_FUNCTION_0_8(uint64_t a1, const __CFString *a2)
{
  uint64_t v2;

  _CFThrowFormattedException(v2, a2);
}

void mergeFunc(uint64_t a1, const __CFDictionary *cf, os_unfair_lock_s *a3)
{
  const void *Value;

  if (CFGetTypeID(cf) == 18)
  {
    Value = CFDictionaryGetValue(cf, CFSTR("NSUserDefaultsDefaultValue"));
    if (Value)
      -[CFPrefsSource setValue:forKey:from:](a3, (uint64_t)Value, a1, 0);
  }
}

uint64_t remoteStoreChanged(void *a1)
{
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 3221225472;
  v2[2] = __remoteStoreChanged_block_invoke;
  v2[3] = &unk_1E12E5C68;
  v2[4] = a1;
  return objc_msgSend(a1, "lockedAsync:", v2);
}

void sub_182BC4A98(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int buf, __int128 a16, id a17)
{
  uint64_t v17;
  id v18;
  NSObject *v19;
  uint64_t v20;

  if (!a2)
    _Unwind_Resume(a1);
  if (a2 == 2)
  {
    v18 = objc_begin_catch(a1);
    v19 = _CFPrefsDaemonLog();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v20 = *(_QWORD *)(v17 + 48);
      buf = 138543874;
      WORD2(a16) = 2114;
      *(_QWORD *)((char *)&a16 + 6) = v20;
      HIWORD(a16) = 2114;
      a17 = v18;
      _os_log_error_impl(&dword_182A8C000, v19, OS_LOG_TYPE_ERROR, "writing key %{public}@ in cloud domain %{public}@ failed with exception %{public}@", (uint8_t *)&buf, 0x20u);
    }
    objc_end_catch();
  }
  else
  {
    objc_begin_catch(a1);
  }
  JUMPOUT(0x182BC4A44);
}

uint64_t __remoteStoreChanged_block_invoke(uint64_t a1)
{
  id *v1;
  NSObject *v2;

  v1 = (id *)(a1 + 32);
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 152), "synchronizeForced:", 1);
  v2 = _CFPrefsDaemonLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    __remoteStoreChanged_block_invoke_cold_1(v1, v2);
  objc_msgSend(*v1, "updateShmemEntry");
  return objc_msgSend(*v1, "asyncNotifyObserversOfWriteFromConnection:message:", 0, 0);
}

void *initSYDRemotePreferencesSource()
{
  void *result;

  if (SyncedDefaultsLibrary_frameworkLibrary
    || (result = dlopen("/System/Library/PrivateFrameworks/SyncedDefaults.framework/SyncedDefaults", 2),
        (SyncedDefaultsLibrary_frameworkLibrary = (uint64_t)result) != 0))
  {
    result = objc_getClass("SYDRemotePreferencesSource");
    classSYDRemotePreferencesSource = (uint64_t)result;
    getSYDRemotePreferencesSourceClass = SYDRemotePreferencesSourceFunction;
  }
  return result;
}

uint64_t SYDRemotePreferencesSourceFunction()
{
  return classSYDRemotePreferencesSource;
}

void sub_182BC5260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const char *PROEM_CLS()
{
  objc_class *v0;

  v0 = (objc_class *)objc_opt_class();
  if (v0)
    return class_getName(v0);
  else
    return "(null class)";
}

const char *PROEM_SEL(const char *a1)
{
  if (a1)
    return sel_getName(a1);
  else
    return "(null selector)";
}

double __os_log_helper_1_2_5_8_32_8_32_8_0_8_32_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  double result;

  *(_QWORD *)&result = 136316162;
  *(_DWORD *)a1 = 136316162;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2080;
  *(_QWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(_QWORD *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 32) = 2080;
  *(_QWORD *)(a1 + 34) = a5;
  *(_WORD *)(a1 + 42) = 2048;
  *(_QWORD *)(a1 + 44) = a6;
  return result;
}

uint64_t OUTLINED_FUNCTION_0_9(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;

  return objc_msgSend(a1, "exceptionWithName:reason:userInfo:osLogPack:size:", a3, a4, 0, v5, v4);
}

uint64_t OUTLINED_FUNCTION_1_6()
{
  return _os_log_pack_fill();
}

uint64_t OUTLINED_FUNCTION_2_5()
{
  return _CFAutoreleasePoolAddObject();
}

void OUTLINED_FUNCTION_3_3(uint64_t a1, const __CFString *a2)
{
  uint64_t v2;

  _CFThrowFormattedException(v2, a2);
}

uint64_t (**(*CFStringEncodingConverterFindBootstrap(int a1))(int a1, uint64_t (*a2)(uint64_t)))()
{
  uint64_t (**(*result)(int, uint64_t (*)(uint64_t)))();

  result = __CFStringEncodingGetArabicConverterDefinition;
  if (a1 > 1039)
  {
    if (a1 <= 2111)
    {
      switch(a1)
      {
        case 1040:
        case 1046:
          return __CFStringEncodingGetLatinSuppConverterDefinition;
        case 1041:
        case 1043:
        case 1045:
        case 1047:
        case 1048:
        case 1049:
        case 1050:
        case 1052:
        case 1054:
        case 1055:
        case 1057:
          return 0;
        case 1042:
          goto LABEL_18;
        case 1044:
          goto LABEL_25;
        case 1051:
          goto LABEL_39;
        case 1053:
          goto LABEL_31;
        case 1056:
          return __CFStringEncodingGetJapaneseConverterDefinition;
        case 1058:
          return __CFStringEncodingGetKoreanConverterDefinition;
        default:
          switch(a1)
          {
            case 1281:
              goto LABEL_18;
            case 1282:
              goto LABEL_39;
            case 1283:
              return __CFStringEncodingGetGreekConverterDefinition;
            case 1284:
              goto LABEL_25;
            case 1285:
              goto LABEL_9;
            case 1286:
              return result;
            case 1287:
              return __CFStringEncodingGetLatinSuppConverterDefinition;
            case 1288:
              result = __CFStringEncodingGetVietnameseConverterDefinition;
              break;
            default:
              if (a1 == 2080)
                return __CFStringEncodingGetJapaneseConverterDefinition;
              return 0;
          }
          break;
      }
      return result;
    }
    if (a1 > 2367)
    {
      switch(a1)
      {
        case 2561:
          return __CFStringEncodingGetJapaneseConverterDefinition;
        case 2562:
          goto LABEL_39;
        case 2563:
          goto LABEL_33;
        case 2564:
          return __CFStringEncodingGetLatinSuppConverterDefinition;
        case 2565:
          return __CFStringEncodingGetSimplifiedChineseConverterDefinition;
        default:
          if ((a1 - 3056) <= 4 && a1 != 3059)
            return __CFStringEncodingGetJapaneseConverterDefinition;
          if (a1 == 2368)
            return __CFStringEncodingGetKoreanConverterDefinition;
          return 0;
      }
    }
    switch(a1)
    {
      case 2112:
        return __CFStringEncodingGetKoreanConverterDefinition;
      case 2336:
        return __CFStringEncodingGetJapaneseConverterDefinition;
      case 2352:
        return __CFStringEncodingGetSimplifiedChineseConverterDefinition;
    }
    return 0;
  }
  if (a1 <= 151)
  {
    switch(a1)
    {
      case 21:
LABEL_31:
        result = (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetThaiConverterDefinition;
        break;
      case 22:
      case 23:
      case 24:
      case 26:
      case 27:
      case 28:
      case 30:
      case 31:
      case 32:
        return 0;
      case 25:
        return __CFStringEncodingGetSimplifiedChineseConverterDefinition;
      case 29:
      case 36:
      case 38:
LABEL_18:
        result = __CFStringEncodingGetLatin2ConverterDefinition;
        break;
      case 33:
      case 34:
        result = (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetSymbolConverterDefinition;
        break;
      case 35:
LABEL_25:
        result = __CFStringEncodingGetLatin5ConverterDefinition;
        break;
      case 37:
        return __CFStringEncodingGetLatinSuppConverterDefinition;
      default:
        switch(a1)
        {
          case 1:
            return __CFStringEncodingGetJapaneseConverterDefinition;
          case 2:
LABEL_33:
            result = __CFStringEncodingGetTraditionalChineseConverterDefinition;
            break;
          case 3:
            return __CFStringEncodingGetKoreanConverterDefinition;
          case 6:
            return __CFStringEncodingGetGreekConverterDefinition;
          case 7:
LABEL_39:
            result = (uint64_t (**(*)(int, uint64_t (*)(uint64_t)))())__CFStringEncodingGetCyrillicConverterDefinition;
            break;
          default:
            return 0;
        }
        break;
    }
  }
  else
  {
    if (a1 > 1023)
    {
      switch(a1)
      {
        case 1024:
          return __CFStringEncodingGetLatinSuppConverterDefinition;
        case 1029:
          return __CFStringEncodingGetGreekConverterDefinition;
        case 1030:
          return __CFStringEncodingGetLatinSuppConverterDefinition;
      }
      return 0;
    }
    switch(a1)
    {
      case 514:
        goto LABEL_18;
      case 515:
      case 516:
      case 524:
        return 0;
      case 517:
        goto LABEL_39;
      case 518:
        return result;
      case 519:
        return __CFStringEncodingGetGreekConverterDefinition;
      case 520:
LABEL_9:
        result = __CFStringEncodingGetHebrewConverterDefinition;
        break;
      case 521:
        goto LABEL_25;
      case 522:
      case 525:
      case 526:
      case 527:
        return __CFStringEncodingGetLatinSuppConverterDefinition;
      case 523:
        goto LABEL_31;
      default:
        if (a1 == 152)
          goto LABEL_39;
        return 0;
    }
  }
  return result;
}

char **_CFArgv()
{
  return *_NSGetArgv();
}

uint64_t _CFArgc()
{
  return *_NSGetArgc();
}

BOOL _CFIsMainThread()
{
  return pthread_main_np() == 1;
}

CFStringRef _CFStringCreateHostName()
{
  char cStr[257];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  if (gethostname(cStr, 0x101uLL))
    cStr[0] = 0;
  return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, cStr, 0x8000100u);
}

CFStringRef CFCopyFullUserName()
{
  uid_t v0;
  passwd *v1;
  const char *pw_gecos;
  CFStringRef result;
  uid_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v4 = 0;
  __CFGetUGIDs(&v4, 0);
  v0 = v4;
  if (!v4)
    v0 = getuid();
  v1 = getpwuid(v0);
  if (!v1)
    return (CFStringRef)CFRetain(&stru_1E1337B18);
  pw_gecos = v1->pw_gecos;
  if (!pw_gecos)
    return (CFStringRef)CFRetain(&stru_1E1337B18);
  result = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, pw_gecos, 0x8000100u);
  if (!result)
    return (CFStringRef)CFRetain(&stru_1E1337B18);
  return result;
}

CFURLRef CFCopyHomeDirectoryURL(void)
{
  return (CFURLRef)_CFCopyHomeDirURLForUser(0, 1);
}

BOOL _CFRSCompatible()
{
  return dyld_get_active_platform() == 2;
}

void __CFTSDInitialize()
{
  if (__CFTSDInitialize_once != -1)
    dispatch_once(&__CFTSDInitialize_once, &__block_literal_global_11);
}

uint64_t (*CFStringEncodingGetAddressForSelector(unsigned int a1))()
{
  if (a1 > 4)
    return 0;
  else
    return off_1E12E5DD0[a1];
}

uint64_t CFStringEncodingIsDecomposableCharacter(unsigned int a1)
{
  if (a1 >= 0x80)
    return CFUniCharIsMemberOf(a1, 0x65u);
  else
    return 0;
}

uint64_t CFStringEncodingDecomposeCharacter(char a1, unsigned __int16 a2, unsigned int *a3)
{
  uint64_t v4;
  unsigned __int16 v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v4 = 0;
  CFUniCharDecompose(&v5, 1, 0, a3, 10, &v4, 0, 0, a1 < 0);
  return v4;
}

uint64_t (**__CFStringEncodingGetExternalConverter(uint64_t a1))()
{
  uint64_t (**(*Bootstrap)(int, uint64_t (*)(uint64_t)))();

  if (!WORD1(a1))
  {
    Bootstrap = CFStringEncodingConverterFindBootstrap(a1);
    if (Bootstrap)
      return Bootstrap(a1, (uint64_t (*)(uint64_t))CFStringEncodingGetAddressForSelector);
  }
  if (__CFStringEncodingGetICUName(a1))
    return (uint64_t (**)())&__CFICUBootstrap;
  return 0;
}

uint64_t __CFStringEncodingCreateListOfAvailablePlatformConverters(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t i;

  result = CFAllocatorAllocateTyped(a1, 220, 0x100004052888210, 0);
  for (i = 0; i != 55; ++i)
    *(_DWORD *)(result + 4 * i) = __CFStringEncodingDylibConveters[i];
  *a2 = 55;
  return result;
}

uint64_t __CFStringEncodingPlatformUnicodeToBytes()
{
  return 3;
}

uint64_t __CFStringEncodingPlatformBytesToUnicode()
{
  return 3;
}

uint64_t __CFStringEncodingPlatformCharLengthForBytes()
{
  return 0;
}

uint64_t __CFStringEncodingPlatformByteLengthForCharacters()
{
  return 0;
}

uint64_t __CFCalendarEqual(void *a1, uint64_t a2)
{
  return objc_msgSend(a1, "isEqual:", a2);
}

id __CFCalendarCopyDescription(void *a1)
{
  return (id)objc_msgSend(a1, "debugDescription");
}

CFTypeID CFCalendarGetTypeID(void)
{
  return 49;
}

CFLocaleRef CFCalendarCopyLocale(CFCalendarRef calendar)
{
  return (CFLocaleRef)objc_msgSend((id)-[__CFCalendar locale](calendar, "locale"), "copy");
}

CFTimeZoneRef CFCalendarCopyTimeZone(CFCalendarRef calendar)
{
  return (CFTimeZoneRef)objc_msgSend((id)-[__CFCalendar timeZone](calendar, "timeZone"), "copy");
}

id CFCalendarCopyGregorianStartDate(void *a1)
{
  return (id)objc_msgSend(a1, "gregorianStartDate");
}

uint64_t CFCalendarSetGregorianStartDate(void *a1, const char *a2)
{
  return objc_msgSend(a1, "setGregorianStartDate:", a2);
}

CFRange CFCalendarGetMinimumRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit unit)
{
  CFIndex v2;
  CFIndex v3;
  CFRange result;

  v2 = -[__CFCalendar minimumRangeOfUnit:](calendar, "minimumRangeOfUnit:", unit);
  if (v2 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v2 = -1;
    v3 = -1;
  }
  result.length = v3;
  result.location = v2;
  return result;
}

CFRange CFCalendarGetMaximumRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit unit)
{
  CFIndex v2;
  CFIndex v3;
  CFRange result;

  v2 = -[__CFCalendar maximumRangeOfUnit:](calendar, "maximumRangeOfUnit:", unit);
  if (v2 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v2 = -1;
    v3 = -1;
  }
  result.length = v3;
  result.location = v2;
  return result;
}

Boolean CFCalendarAddComponents(CFCalendarRef calendar, CFAbsoluteTime *at, CFOptionFlags options, const char *componentDesc, ...)
{
  void *v8;
  int v9;
  const char *v10;
  int v11;
  int v12;
  void *v13;
  uint64_t v14;
  va_list v16;
  va_list va;

  va_start(va, componentDesc);
  va_copy(v16, va);
  v8 = (void *)objc_msgSend(objc_allocWithZone((Class)NSDateComponents), "init");
  v9 = *(unsigned __int8 *)componentDesc;
  if (*componentDesc)
  {
    v10 = componentDesc + 1;
    do
    {
      v11 = va_arg(v16, _QWORD);
      switch(v9)
      {
        case 'D':
          objc_msgSend(v8, "setDayOfYear:", v11);
          break;
        case 'E':
        case 'c':
          objc_msgSend(v8, "setWeekday:", v11);
          break;
        case 'F':
          objc_msgSend(v8, "setWeekdayOrdinal:", v11);
          break;
        case 'G':
          objc_msgSend(v8, "setEra:", v11);
          break;
        case 'H':
          objc_msgSend(v8, "setHour:", v11);
          break;
        case 'I':
        case 'J':
        case 'K':
        case 'N':
        case 'O':
        case 'P':
        case 'R':
        case 'S':
        case 'T':
        case 'V':
        case 'X':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '_':
        case 'a':
        case 'b':
          break;
        case 'L':
        case 'M':
          objc_msgSend(v8, "setMonth:", v11);
          break;
        case 'Q':
          objc_msgSend(v8, "setQuarter:", v11);
          break;
        case 'U':
LABEL_6:
          objc_msgSend(v8, "setYear:", v11, v16);
          break;
        case 'W':
          objc_msgSend(v8, "setWeekOfMonth:", v11);
          break;
        case 'Y':
          objc_msgSend(v8, "setYearForWeekOfYear:", v11);
          break;
        case '^':
LABEL_8:
          objc_msgSend(v8, "setWeekOfYear:", v11, v16);
          objc_msgSend(v8, "setWeek:", v11);
          break;
        case 'd':
          objc_msgSend(v8, "setDay:", v11);
          break;
        default:
          switch(v9)
          {
            case 'l':
              objc_msgSend(v8, "setLeapMonth:", v11 != 0);
              break;
            case 'm':
              objc_msgSend(v8, "setMinute:", v11);
              break;
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 't':
            case 'u':
            case 'v':
            case 'x':
              goto LABEL_22;
            case 'r':
            case 'y':
              goto LABEL_6;
            case 's':
              objc_msgSend(v8, "setSecond:", v11);
              break;
            case 'w':
              goto LABEL_8;
            default:
              if (v9 == 35)
                objc_msgSend(v8, "setNanosecond:", v11);
              break;
          }
          break;
      }
LABEL_22:
      v12 = *(unsigned __int8 *)v10++;
      v9 = v12;
    }
    while (v12);
  }
  v13 = (void *)-[__CFCalendar dateByAddingComponents:toDate:options:](calendar, "dateByAddingComponents:toDate:options:", v8, +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", *at, v16), options);

  if (!v13)
    return 0;
  objc_msgSend(v13, "timeIntervalSinceReferenceDate");
  *(_QWORD *)at = v14;
  return 1;
}

Boolean CFCalendarGetTimeRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit unit, CFAbsoluteTime at, CFAbsoluteTime *startp, CFTimeInterval *tip)
{
  int v7;
  uint64_t v8;
  uint64_t v10;
  id v11[2];

  v11[1] = *(id *)MEMORY[0x1E0C80C00];
  v10 = 0;
  v11[0] = 0;
  v7 = -[__CFCalendar rangeOfUnit:startDate:interval:forDate:](calendar, "rangeOfUnit:startDate:interval:forDate:", unit, v11, &v10, +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", at));
  if (v7)
  {
    if (startp)
    {
      objc_msgSend(v11[0], "timeIntervalSinceReferenceDate");
      *(_QWORD *)startp = v8;
    }
    if (tip)
      *(_QWORD *)tip = v10;
    LOBYTE(v7) = 1;
  }
  return v7;
}

uint64_t CFCalendarGetComponentFromDate(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = objc_msgSend(a1, "component:fromDate:", a2, a3);
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    return -1;
  return result;
}

CFRange CFCalendarGetRangeOfUnit(CFCalendarRef calendar, CFCalendarUnit smallerUnit, CFCalendarUnit biggerUnit, CFAbsoluteTime at)
{
  CFIndex v4;
  CFIndex v5;
  CFRange result;

  v4 = -[__CFCalendar rangeOfUnit:inUnit:forDate:](calendar, "rangeOfUnit:inUnit:forDate:", smallerUnit, biggerUnit, +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", at));
  if (v4 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v4 = -1;
    v5 = -1;
  }
  result.length = v5;
  result.location = v4;
  return result;
}

CFIndex CFCalendarGetOrdinalityOfUnit(CFCalendarRef calendar, CFCalendarUnit smallerUnit, CFCalendarUnit biggerUnit, CFAbsoluteTime at)
{
  CFIndex result;

  result = -[__CFCalendar ordinalityOfUnit:inUnit:forDate:](calendar, "ordinalityOfUnit:inUnit:forDate:", smallerUnit, biggerUnit, +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", at));
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    return -1;
  return result;
}

void _CFLocaleSetPreferredMeasurementSystem(const __CFString *cf1)
{
  const __CFString *v1;
  const CFBooleanRef *v2;
  CFBooleanRef v3;

  v1 = cf1;
  if (cf1)
  {
    if (CFEqual(cf1, CFSTR("Metric")))
    {
      v2 = &kCFBooleanTrue;
      v1 = CFSTR("Centimeters");
    }
    else
    {
      if (CFEqual(v1, CFSTR("U.S.")))
      {
        v2 = &kCFBooleanFalse;
      }
      else
      {
        if (!CFEqual(v1, CFSTR("U.K.")))
          return;
        v2 = &kCFBooleanTrue;
      }
      v1 = CFSTR("Inches");
    }
    v3 = *v2;
  }
  else
  {
    v3 = 0;
  }
  CFPreferencesSetValue(CFSTR("AppleMetricUnits"), v3, CFSTR("kCFPreferencesAnyApplication"), CFSTR("kCFPreferencesCurrentUser"), CFSTR("kCFPreferencesAnyHost"));
  CFPreferencesSetValue(CFSTR("AppleMeasurementUnits"), v1, CFSTR("kCFPreferencesAnyApplication"), CFSTR("kCFPreferencesCurrentUser"), CFSTR("kCFPreferencesAnyHost"));
  CFPreferencesSynchronize(CFSTR("kCFPreferencesAnyApplication"), CFSTR("kCFPreferencesCurrentUser"), CFSTR("kCFPreferencesAnyHost"));
  __CFLocaleResetCurrent(1);
  _CFLocalePostChangeNotification(CFSTR("AppleMeasurementSystemPreferencesChangedNotification"));
}

void _CFLocalePostChangeNotification(const __CFString *a1)
{
  __CFNotificationCenter *DarwinNotifyCenter;

  __CFLocaleResetCurrent(1);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterPostNotification(DarwinNotifyCenter, a1, 0, 0, 1u);
}

CFTypeRef _CFLocaleCopyPreferredMeasurementSystem()
{
  __objc2_class **v0;
  unint64_t v1;
  const void *v2;
  BOOL v3;
  CFTypeRef *v4;
  CFTypeRef v5;
  BOOL v6;

  v0 = (__objc2_class **)CFPreferencesCopyValue(CFSTR("AppleMetricUnits"), CFSTR("kCFPreferencesAnyApplication"), CFSTR("kCFPreferencesCurrentUser"), CFSTR("kCFPreferencesAnyHost"));
  v1 = (unint64_t)CFPreferencesCopyValue(CFSTR("AppleMeasurementUnits"), CFSTR("kCFPreferencesAnyApplication"), CFSTR("kCFPreferencesCurrentUser"), CFSTR("kCFPreferencesAnyHost"));
  if (!((unint64_t)v0 | v1))
    return 0;
  v2 = (const void *)v1;
  if (v1)
    v3 = &__kCFBooleanTrue == v0;
  else
    v3 = 0;
  if (v3 && CFEqual((CFTypeRef)v1, CFSTR("Inches")))
  {
    if ((dyld_program_sdk_at_least() & 1) != 0)
    {
      v4 = (CFTypeRef *)&kCFLocaleMeasurementSystemUK;
      goto LABEL_19;
    }
    goto LABEL_17;
  }
  if (v0)
    v6 = &__kCFBooleanFalse == v0;
  else
    v6 = 0;
  if (v6)
  {
    v4 = (CFTypeRef *)&kCFLocaleMeasurementSystemUS;
LABEL_19:
    v5 = CFRetain(*v4);
    if (!v0)
      goto LABEL_21;
    goto LABEL_20;
  }
  if (v2 && CFEqual(v2, CFSTR("Centimeters")))
  {
LABEL_17:
    v4 = (CFTypeRef *)&kCFLocaleMeasurementSystemMetric;
    goto LABEL_19;
  }
  v5 = 0;
  if (v0)
LABEL_20:
    CFRelease(v0);
LABEL_21:
  if (v2)
    CFRelease(v2);
  return v5;
}

void _CFLocaleSetPreferredTemperatureUnit(CFPropertyListRef value)
{
  char v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if (!value || _CFLocaleGetTemperatureUnitForPreferences((uint64_t)value, &v2))
  {
    CFPreferencesSetValue(CFSTR("AppleTemperatureUnit"), value, CFSTR("kCFPreferencesAnyApplication"), CFSTR("kCFPreferencesCurrentUser"), CFSTR("kCFPreferencesAnyHost"));
    CFPreferencesSynchronize(CFSTR("kCFPreferencesAnyApplication"), CFSTR("kCFPreferencesCurrentUser"), CFSTR("kCFPreferencesAnyHost"));
    __CFLocaleResetCurrent(1);
    _CFLocalePostChangeNotification(CFSTR("AppleTemperatureUnitPreferencesChangedNotification"));
  }
}

Boolean CFPlugInRegisterFactoryFunction(CFUUIDRef factoryUUID, CFPlugInFactoryFunction func)
{
  _QWORD *Locked;

  os_unfair_recursive_lock_lock_with_options();
  Locked = (_QWORD *)_CFPFactoryCommonCreateLocked(&__kCFAllocatorSystemDefault, factoryUUID);
  Locked[5] = 0;
  Locked[6] = 0;
  Locked[4] = func;
  os_unfair_recursive_lock_unlock();
  return 1;
}

Boolean CFPlugInRegisterFactoryFunctionByName(CFUUIDRef factoryUUID, CFPlugInRef plugIn, CFStringRef functionName)
{
  os_unfair_recursive_lock_lock_with_options();
  _CFPlugInRegisterFactoryFunctionByNameLocked(factoryUUID, plugIn, functionName);
  os_unfair_recursive_lock_unlock();
  return 1;
}

Boolean CFPlugInUnregisterFactory(CFUUIDRef factoryUUID)
{
  _BYTE *Value;

  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByFactoryID
    && (Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryUUID)) != 0
    && Value[24])
  {
    _CFPFactoryDisableLocked(Value);
  }
  else
  {
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR))
      CFPlugInUnregisterFactory_cold_1();
  }
  os_unfair_recursive_lock_unlock();
  return 1;
}

void _CFPFactoryDisableLocked(_BYTE *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  a1[24] = 0;
  if (_CFBundlePluginLogger_onceToken != -1)
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  v2 = _CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
    _CFPFactoryDisableLocked_cold_1((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
  CFRelease(a1);
}

Boolean CFPlugInRegisterPlugInType(CFUUIDRef factoryUUID, CFUUIDRef typeUUID)
{
  os_unfair_recursive_lock_lock_with_options();
  _CFPlugInRegisterPlugInTypeLocked(factoryUUID, typeUUID);
  os_unfair_recursive_lock_unlock();
  return 1;
}

Boolean CFPlugInUnregisterPlugInType(CFUUIDRef factoryUUID, CFUUIDRef typeUUID)
{
  CFMutableArrayRef *Value;

  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByFactoryID
    && (Value = (CFMutableArrayRef *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryUUID)) != 0
    && *((_BYTE *)Value + 24))
  {
    _CFPFactoryRemoveTypeLocked(Value, typeUUID);
  }
  else
  {
    if (_CFBundlePluginLogger_onceToken != -1)
      dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
    if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_ERROR))
      CFPlugInUnregisterPlugInType_cold_1();
  }
  os_unfair_recursive_lock_unlock();
  return 1;
}

void _CFPFactoryRemoveTypeLocked(CFMutableArrayRef *a1, const void *a2)
{
  const __CFArray *v4;
  unsigned int FirstIndexOfValue;
  const __CFArray *Value;
  const __CFArray *v7;
  unsigned int v8;
  CFRange v9;
  CFRange v10;

  v4 = a1[7];
  v9.length = CFArrayGetCount(v4);
  v9.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v9, a2);
  if ((FirstIndexOfValue & 0x80000000) == 0)
    CFArrayRemoveValueAtIndex(a1[7], FirstIndexOfValue);
  if (_factoriesByTypeID)
  {
    Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByTypeID, a2);
    if (Value)
    {
      v7 = Value;
      v10.length = CFArrayGetCount(Value);
      v10.location = 0;
      v8 = CFArrayGetFirstIndexOfValue(v7, v10, a1);
      if ((v8 & 0x80000000) == 0)
      {
        CFArrayRemoveValueAtIndex(v7, v8);
        if (!CFArrayGetCount(v7))
          CFDictionaryRemoveValue((CFMutableDictionaryRef)_factoriesByTypeID, a2);
      }
    }
  }
  if (_CFBundlePluginLogger_onceToken != -1)
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
    _CFPFactoryRemoveTypeLocked_cold_1();
}

uint64_t __CFPLUGIN_IS_CALLING_OUT_TO_A_DYNAMIC_REGISTRATION_FUNCTION__(uint64_t (*a1)(uint64_t), uint64_t a2)
{
  return a1(a2);
}

void CFPlugInSetLoadOnDemand(CFPlugInRef plugIn, Boolean flag)
{
  int v2;
  _BYTE *PlugInData;
  _BYTE *v5;

  v2 = flag;
  PlugInData = (_BYTE *)__CFBundleGetPlugInData((uint64_t)plugIn);
  if (*PlugInData)
  {
    v5 = PlugInData;
    os_unfair_recursive_lock_lock_with_options();
    v5[1] = v2;
    if (v2)
    {
      if (v5[2] || *((_DWORD *)v5 + 2))
      {
        os_unfair_recursive_lock_unlock();
      }
      else
      {
        os_unfair_recursive_lock_unlock();
        CFBundleUnloadExecutable(plugIn);
      }
    }
    else
    {
      os_unfair_recursive_lock_unlock();
      CFBundleLoadExecutable(plugIn);
    }
  }
}

Boolean CFPlugInIsLoadOnDemand(CFPlugInRef plugIn)
{
  if (*(_BYTE *)__CFBundleGetPlugInData((uint64_t)plugIn))
    return *(_BYTE *)(__CFBundleGetPlugInData((uint64_t)plugIn) + 1);
  else
    return 0;
}

_BYTE *_CFPlugInWillUnload(uint64_t a1)
{
  _BYTE *result;
  uint64_t PlugInData;
  int Count;
  unint64_t v5;
  uint64_t v6;

  result = (_BYTE *)__CFBundleGetPlugInData(a1);
  if (*result)
  {
    os_unfair_recursive_lock_lock_with_options();
    PlugInData = __CFBundleGetPlugInData(a1);
    Count = CFArrayGetCount(*(CFArrayRef *)(PlugInData + 16));
    if (Count >= 1)
    {
      v5 = Count + 1;
      do
      {
        v6 = __CFBundleGetPlugInData(a1);
        *((_QWORD *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v6 + 16), (v5-- - 2)) + 4) = 0;
      }
      while (v5 > 1);
    }
    return (_BYTE *)os_unfair_recursive_lock_unlock();
  }
  return result;
}

void _CFPFactoryDeallocate(uint64_t a1)
{
  BOOL v2;
  uint64_t v3;
  const __CFArray *v4;
  uint64_t PlugInData;
  unsigned int FirstIndexOfValue;
  uint64_t v7;
  int Count;
  unint64_t v9;
  const void *ValueAtIndex;
  const void *v11;
  const void *v12;
  CFRange v13;

  os_unfair_recursive_lock_lock_with_options();
  if (*(_QWORD *)(a1 + 16))
    v2 = _factoriesByTypeID == 0;
  else
    v2 = 1;
  if (!v2)
    CFDictionaryRemoveValue((CFMutableDictionaryRef)_factoriesByFactoryID, *(const void **)(a1 + 16));
  if (_CFBundlePluginLogger_onceToken != -1)
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
    _CFPFactoryDeallocate_cold_1();
  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
  {
    if (*(_BYTE *)__CFBundleGetPlugInData(*(_QWORD *)(a1 + 40)))
    {
      v4 = *(const __CFArray **)(__CFBundleGetPlugInData(v3) + 16);
      PlugInData = __CFBundleGetPlugInData(v3);
      v13.length = CFArrayGetCount(*(CFArrayRef *)(PlugInData + 16));
      v13.location = 0;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v4, v13, (const void *)a1);
      if ((FirstIndexOfValue & 0x80000000) == 0)
      {
        v7 = __CFBundleGetPlugInData(v3);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v7 + 16), FirstIndexOfValue);
      }
    }
    CFRelease(*(CFTypeRef *)(a1 + 40));
  }
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
  if (Count >= 1)
  {
    v9 = Count + 1;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), (v9 - 2));
      _CFPFactoryRemoveTypeLocked((CFMutableArrayRef *)a1, ValueAtIndex);
      --v9;
    }
    while (v9 > 1);
  }
  CFRelease(*(CFTypeRef *)(a1 + 56));
  os_unfair_recursive_lock_unlock();
  v11 = *(const void **)(a1 + 48);
  if (v11)
    CFRelease(v11);
  v12 = *(const void **)(a1 + 16);
  if (v12)
    CFRelease(v12);
}

CFArrayRef CFPlugInFindFactoriesForPlugInType(CFUUIDRef typeUUID)
{
  const __CFArray *Value;
  const __CFArray *v3;
  __CFArray *Mutable;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v9;
  NSObject *v10;

  os_unfair_recursive_lock_lock_with_options();
  if (_factoriesByTypeID
    && (Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByTypeID, typeUUID)) != 0)
  {
    v3 = Value;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      v6 = Count;
      for (i = 0; i != v6; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v3, i);
        v9 = (const void *)*((_QWORD *)ValueAtIndex + 2);
        if (v9)
        {
          CFRetain(*((CFTypeRef *)ValueAtIndex + 2));
          CFArrayAppendValue(Mutable, v9);
          CFRelease(v9);
        }
      }
    }
  }
  else
  {
    Mutable = 0;
  }
  os_unfair_recursive_lock_unlock();
  if (_CFBundlePluginLogger_onceToken != -1)
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  v10 = _CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
    CFPlugInFindFactoriesForPlugInType_cold_1(Mutable, (uint64_t)typeUUID, v10);
  return Mutable;
}

uint64_t __CFPlugInInstanceDeallocate(uint64_t a1)
{
  void (*v2)(uint64_t);
  uint64_t v3;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *(void (**)(uint64_t))(a1 + 32);
  if (v2)
    v2(a1 + 40);
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
    _CFPFactoryRemoveInstanceLocked(v3);
  return os_unfair_recursive_lock_unlock();
}

const __CFString *__CFPlugInInstanceCopyDescription()
{
  return CFSTR("Some CFPlugInInstance");
}

CFTypeID CFPlugInInstanceGetTypeID(void)
{
  return 33;
}

CFPlugInInstanceRef CFPlugInInstanceCreateWithInstanceDataSize(CFAllocatorRef allocator, CFIndex instanceDataSize, CFPlugInInstanceDeallocateInstanceDataFunction deallocateInstanceFunction, CFStringRef factoryName, CFPlugInInstanceGetInterfaceFunction getInterfaceFunction)
{
  __CFPlugInInstance *Instance;
  _BYTE *Value;

  Instance = (__CFPlugInInstance *)_CFRuntimeCreateInstance((__objc2_class **)allocator, 0x21uLL, (instanceDataSize + 24), 0);
  if (Instance)
  {
    os_unfair_recursive_lock_lock_with_options();
    if (_factoriesByFactoryID
      && (Value = CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, factoryName)) != 0
      && Value[24])
    {
      *((_QWORD *)Instance + 2) = Value;
      _CFPFactoryAddInstanceLocked(Value);
    }
    else
    {
      *((_QWORD *)Instance + 2) = 0;
    }
    *((_QWORD *)Instance + 3) = getInterfaceFunction;
    *((_QWORD *)Instance + 4) = deallocateInstanceFunction;
    os_unfair_recursive_lock_unlock();
  }
  return Instance;
}

Boolean CFPlugInInstanceGetInterfaceFunctionTable(CFPlugInInstanceRef instance, CFStringRef interfaceName, void **ftbl)
{
  uint64_t (*v4)(void);
  _BOOL4 v5;
  void *v6;
  void *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  v4 = (uint64_t (*)(void))*((_QWORD *)instance + 3);
  if (v4)
  {
    v5 = v4() != 0;
    if (!ftbl)
      return v5;
  }
  else
  {
    v5 = 0;
    if (!ftbl)
      return v5;
  }
  v6 = v8;
  if (!v5)
    v6 = 0;
  *ftbl = v6;
  return v5;
}

CFStringRef CFPlugInInstanceGetFactoryName(CFPlugInInstanceRef instance)
{
  uint64_t v2;
  const __CFString *v3;

  os_unfair_recursive_lock_lock_with_options();
  v2 = *((_QWORD *)instance + 2);
  v3 = *(const __CFString **)(v2 + 16);
  if (v3)
    CFRetain(*(CFTypeRef *)(v2 + 16));
  os_unfair_recursive_lock_unlock();
  return v3;
}

void *__cdecl CFPlugInInstanceGetInstanceData(CFPlugInInstanceRef instance)
{
  return (char *)instance + 40;
}

void OUTLINED_FUNCTION_0_10(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_3_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 0x16u);
}

void OUTLINED_FUNCTION_4_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_5_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_7_0(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

CFDataRef CFPropertyListCreateXMLData(CFAllocatorRef allocator, CFPropertyListRef propertyList)
{
  return _CFPropertyListCreateXMLData(allocator, (const __CFString *)propertyList, 1);
}

__CFData *_CFPropertyListCreateXMLDataWithExtras(const __CFAllocator *a1, const __CFString *a2)
{
  return _CFPropertyListCreateXMLData(a1, a2, 0);
}

BOOL _CFPropertyListCreateSingleValue(__objc2_class **a1, const __CFData *a2, uint64_t a3, CFStringRef theString, _QWORD *a5, CFErrorRef *a6)
{
  char *BytePtr;
  unint64_t Length;
  uint64_t v14;
  const __CFArray *v15;
  __objc2_class **Mutable;
  CFIndex Count;
  CFIndex v18;
  CFIndex v19;
  char v20;
  const __CFString *v21;
  char OffsetForValueFromDictionary3;
  unsigned int v23;
  int v25;
  const void *v26;
  CFArrayRef ArrayBySeparatingStrings;
  const void *v28;
  CFIndex v29;
  const __CFString *ValueAtIndex;
  SInt32 IntValue;
  SInt32 v32;
  const void *Value;
  _BOOL4 v34;
  int v35;
  uint64_t v36;
  _QWORD *v38;
  CFTypeRef v39;
  int v40[2];
  unint64_t v41;
  char v42;
  const void *v43;
  _OWORD v44[2];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (!theString || !CFStringGetLength(theString))
    return 0;
  v42 = 0;
  memset(v44, 0, sizeof(v44));
  v41 = 0;
  BytePtr = (char *)CFDataGetBytePtr(a2);
  Length = CFDataGetLength(a2);
  if (Length < 8 || (v14 = Length, !__CFDataGetBinaryPlistTopLevelInfo(a2, &v42, &v41, (uint64_t)v44)))
  {
    v43 = 0;
    _CFPropertyListCreateWithData(a1, a2, a3, a6, 1, 0, 0, &v43);
    v26 = v43;
    if (v43)
    {
      ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString, CFSTR(":"));
      v28 = v26;
      if (CFArrayGetCount(ArrayBySeparatingStrings) < 1)
      {
LABEL_36:
        v34 = v28 != 0;
        v35 = 1;
        if (a5 && v28)
        {
          *a5 = v28;
          CFRetain(v28);
          v36 = 1;
        }
        else
        {
LABEL_45:
          v36 = v35 & v34;
        }
        CFRelease(ArrayBySeparatingStrings);
        CFRelease(v26);
        return v36;
      }
      v29 = 0;
      v28 = v26;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v29);
        IntValue = CFStringGetIntValue(ValueAtIndex);
        v32 = IntValue;
        if (IntValue == 0x7FFFFFFF)
          goto LABEL_26;
        if (!IntValue)
          break;
        if (IntValue != 0x80000000 || !v28)
        {
LABEL_32:
          if (!v28)
          {
LABEL_43:
            v35 = 0;
            v34 = 0;
            goto LABEL_45;
          }
          goto LABEL_33;
        }
LABEL_30:
        if (CFGetTypeID(v28) == 18)
        {
          Value = CFDictionaryGetValue((CFDictionaryRef)v28, ValueAtIndex);
          goto LABEL_35;
        }
LABEL_33:
        if (CFGetTypeID(v28) != 19)
        {
          v35 = 0;
          v34 = 1;
          goto LABEL_45;
        }
        Value = CFArrayGetValueAtIndex((CFArrayRef)v28, v32);
LABEL_35:
        v28 = Value;
        if (++v29 >= CFArrayGetCount(ArrayBySeparatingStrings))
          goto LABEL_36;
      }
      if (CFStringCompare(CFSTR("0"), ValueAtIndex, 0) == kCFCompareEqualTo)
        goto LABEL_32;
LABEL_26:
      if (!v28)
        goto LABEL_43;
      goto LABEL_30;
    }
    return 0;
  }
  v15 = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString, CFSTR(":"));
  v43 = 0;
  *(_QWORD *)v40 = v41;
  Mutable = (__objc2_class **)CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
  Count = CFArrayGetCount(v15);
  _CFDictionarySetCapacity(Mutable, Count + 1);
  v18 = Count - 1;
  if (Count < 1)
  {
    v25 = 0;
    goto LABEL_42;
  }
  v38 = a5;
  v19 = 0;
  v20 = 0;
  do
  {
    v21 = (const __CFString *)CFArrayGetValueAtIndex(v15, v19);
    if (__CFBinaryPlistIsDictionary((uint64_t)BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44))
    {
      OffsetForValueFromDictionary3 = __CFBinaryPlistGetOffsetForValueFromDictionary3(BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44, v21, (unint64_t *)&v43, (unint64_t *)v40);
LABEL_9:
      v20 = OffsetForValueFromDictionary3;
      goto LABEL_13;
    }
    if (__CFBinaryPlistIsArray((uint64_t)BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44))
    {
      v23 = CFStringGetIntValue(v21);
      if (v23 <= 0x7FFFFFFE)
      {
        OffsetForValueFromDictionary3 = __CFBinaryPlistGetOffsetForValueFromArray2((uint64_t)BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44, v23, (unint64_t *)v40);
        goto LABEL_9;
      }
    }
LABEL_13:
    if ((v20 & 1) == 0)
      break;
  }
  while (v18 != v19++);
  v25 = v20 & 1;
  if (v38)
  {
    if ((v20 & 1) != 0)
    {
      v39 = 0;
      v25 = __CFBinaryPlistCreateObjectFiltered(BytePtr, v14, *(unint64_t *)v40, (uint64_t)v44, a1, a3, 0, (const __CFDictionary *)Mutable, 0, 0, 0, &v39, 0);
      if (v25)
        *v38 = v39;
    }
  }
LABEL_42:
  CFRelease(v15);
  CFRelease(Mutable);
  return v25 != 0;
}

uint64_t _CFPropertyListCreateFromXMLData(__objc2_class **a1, const __CFData *a2, unsigned int a3, CFStringRef *a4, char a5, _QWORD *a6)
{
  int v7;
  CFTypeRef v8;
  CFTypeRef cf;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v11[0] = 0;
  if (a4)
    *a4 = 0;
  cf = 0;
  v7 = _CFPropertyListCreateWithData(a1, a2, a3, (CFErrorRef *)&cf, a5, a6, 0, v11);
  v8 = cf;
  if (a4 && !v7 && cf)
  {
    *a4 = __copyErrorDebugDescription((__CFError *)cf);
    v8 = cf;
  }
  if (v8)
    CFRelease(v8);
  return v11[0];
}

CFStringRef __copyErrorDebugDescription(__CFError *a1)
{
  const __CFDictionary *v1;
  const __CFDictionary *v2;
  const __CFString *Value;
  CFStringRef Copy;

  v1 = CFErrorCopyUserInfo(a1);
  if (!v1)
    return 0;
  v2 = v1;
  Value = (const __CFString *)CFDictionaryGetValue(v1, CFSTR("NSDebugDescription"));
  if (Value)
    Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Value);
  else
    Copy = 0;
  CFRelease(v2);
  return Copy;
}

uint64_t __CFRunArrayEqual()
{
  return 0;
}

uint64_t __CFRunArrayHash(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
}

__CFString *__CFRunArrayCopyDescription(uint64_t a1)
{
  _QWORD *v1;
  __CFString *Mutable;
  uint64_t v3;
  _QWORD *v4;

  v1 = *(_QWORD **)(a1 + 16);
  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("%ld blocks used, total length %ld (%ld blocks, block %ld is at %ld)\n"), v1[2], v1[1], v1[3], v1[4], v1[5]);
  if ((uint64_t)v1[2] >= 1)
  {
    v3 = 0;
    v4 = v1 + 7;
    do
    {
      CFStringAppendFormat(Mutable, 0, CFSTR(" %ld %p %@\n"), *(v4 - 1), *v4, *v4);
      ++v3;
      v4 += 2;
    }
    while (v3 < v1[2]);
  }
  return Mutable;
}

uint64_t CFRunArrayGetTypeID()
{
  return 63;
}

_QWORD *__CFRunArrayMakeNewList(CFTypeRef cf, uint64_t *a2)
{
  uint64_t v4;
  CFAllocatorRef v5;
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void **v10;
  _QWORD *v11;
  const void *v12;
  uint64_t v13;

  if (a2)
    v4 = a2[2];
  else
    v4 = 2;
  v5 = CFGetAllocator(cf);
  result = (_QWORD *)CFAllocatorAllocateTyped(v5, 16 * v4 + 48, 1930815021, 0);
  v7 = (uint64_t)result;
  result[3] = v4;
  if (a2)
  {
    v8 = a2[2];
    if (v8 >= 1)
    {
      v9 = 0;
      v10 = (const void **)(a2 + 7);
      v11 = result + 7;
      do
      {
        *(v11 - 1) = *(v10 - 1);
        v12 = *v10;
        v10 += 2;
        result = CFRetain(v12);
        *v11 = result;
        v11 += 2;
        ++v9;
        v8 = a2[2];
      }
      while (v9 < v8);
    }
    *(_QWORD *)(v7 + 16) = v8;
    *(_OWORD *)(v7 + 32) = *((_OWORD *)a2 + 2);
    v13 = *a2;
    *(_QWORD *)(v7 + 8) = a2[1];
    *a2 = v13 - 1;
  }
  else
  {
    result[1] = 0;
    result[2] = 0;
    result[4] = 0;
    result[5] = 0;
  }
  *(_QWORD *)v7 = 1;
  *((_QWORD *)cf + 2) = v7;
  return result;
}

uint64_t CFRunArrayGetCount(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
}

uint64_t CFRunArrayGetValueAtRunArrayIndex(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v3 + 16) <= a2)
    return 0;
  if (a3)
    *a3 = *(_QWORD *)(v3 + 16 * a2 + 48);
  return *(_QWORD *)(v3 + 16 * a2 + 56);
}

void CFRunArrayDelete(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  CFRunArrayReplace(a1, a2, a3, 0, 0);
}

uint64_t __CFLocaleEqual(void *a1, uint64_t a2)
{
  return objc_msgSend(a1, "isEqual:", a2);
}

uint64_t __CFLocaleCopyDescription(void *a1)
{
  return objc_msgSend((id)objc_msgSend(a1, "description"), "copy");
}

id _CFLocaleCopyValidNumberingSystemsForLocaleIdentifier(uint64_t a1)
{
  return (id)+[NSLocale _validNumberingSystemsForLocaleIdentifier:](NSLocale, "_validNumberingSystemsForLocaleIdentifier:", a1);
}

id _CFLocaleCreateLocaleIdentiferByReplacingLanguageCodeAndScriptCode(uint64_t a1, uint64_t a2)
{
  return (id)+[NSLocale _localeIdentifierByReplacingLanguageCodeAndScriptCodeForLangCode:desiredComponents:](NSLocale, "_localeIdentifierByReplacingLanguageCodeAndScriptCodeForLangCode:desiredComponents:", a1, a2);
}

id _CFLocaleCreateLikeCurrentWithBundleLocalizations(uint64_t a1, int a2)
{
  return (id)+[NSLocale _currentLocaleWithBundleLocalizations:disableBundleMatching:](NSLocale, "_currentLocaleWithBundleLocalizations:disableBundleMatching:", a1, a2 != 0);
}

uint64_t _CFLocaleCopyAsIfCurrent(uint64_t a1)
{
  return +[NSLocale _newLocaleAsIfCurrent:overrides:disableBundleMatching:](NSLocale, "_newLocaleAsIfCurrent:overrides:disableBundleMatching:", a1, 0, 0);
}

uint64_t _CFLocaleCopyAsIfCurrentWithOverrides(uint64_t a1, uint64_t a2)
{
  return +[NSLocale _newLocaleAsIfCurrent:overrides:disableBundleMatching:](NSLocale, "_newLocaleAsIfCurrent:overrides:disableBundleMatching:", a1, a2, 0);
}

CFStringRef CFLocaleCopyDisplayNameForPropertyValue(CFLocaleRef displayLocale, CFLocaleKey key, CFStringRef value)
{
  return (CFStringRef)(id)-[__CFLocale displayNameForKey:value:](displayLocale, "displayNameForKey:value:", key, value);
}

CFArrayRef CFLocaleCopyAvailableLocaleIdentifiers(void)
{
  return (CFArrayRef)+[NSLocale availableLocaleIdentifiers](NSLocale, "availableLocaleIdentifiers");
}

CFArrayRef CFLocaleCopyISOLanguageCodes(void)
{
  return (CFArrayRef)+[NSLocale ISOLanguageCodes](NSLocale, "ISOLanguageCodes");
}

CFArrayRef CFLocaleCopyISOCountryCodes(void)
{
  return (CFArrayRef)+[NSLocale ISOCountryCodes](NSLocale, "ISOCountryCodes");
}

CFArrayRef CFLocaleCopyISOCurrencyCodes(void)
{
  return (CFArrayRef)+[NSLocale ISOCurrencyCodes](NSLocale, "ISOCurrencyCodes");
}

CFArrayRef CFLocaleCopyCommonISOCurrencyCodes(void)
{
  return (CFArrayRef)+[NSLocale commonISOCurrencyCodes](NSLocale, "commonISOCurrencyCodes");
}

uint32_t CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier(CFLocaleIdentifier localeIdentifier)
{
  return +[NSLocale windowsLocaleCodeFromLocaleIdentifier:](NSLocale, "windowsLocaleCodeFromLocaleIdentifier:", localeIdentifier);
}

CFLocaleLanguageDirection CFLocaleGetLanguageLineDirection(CFStringRef isoLangCode)
{
  return +[NSLocale lineDirectionForLanguage:](NSLocale, "lineDirectionForLanguage:", isoLangCode);
}

id _CFLocaleCopyPreferredLanguagesForCurrentUser()
{
  return (id)+[NSLocale _preferredLanguagesForCurrentUser:](NSLocale, "_preferredLanguagesForCurrentUser:", 1);
}

void __CFLocaleResetCurrent(int a1)
{
  CFPreferencesAppSynchronize(CFSTR("kCFPreferencesCurrentApplication"));
  if (a1)
    +[NSLocale _resetCurrent](NSLocale, "_resetCurrent");
  dispatch_async(MEMORY[0x1E0C80D38], &__block_literal_global_13);
}

void _CFLocaleResetCurrent()
{
  CFPreferencesAppSynchronize(CFSTR("kCFPreferencesCurrentApplication"));
  +[NSLocale _resetCurrent](NSLocale, "_resetCurrent");
  dispatch_async(MEMORY[0x1E0C80D38], &__block_literal_global_13);
}

void __CFLocalePrefsChanged()
{
  CFAbsoluteTime Current;
  dispatch_time_t v1;
  qos_class_t v2;
  NSObject *global_queue;
  _QWORD v4[6];

  v4[5] = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  __lastNote = *(_QWORD *)&Current;
  v1 = dispatch_time(0, 10000000);
  v2 = qos_class_main();
  global_queue = dispatch_get_global_queue(v2, 2uLL);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ____CFLocalePrefsChanged_block_invoke;
  v4[3] = &__block_descriptor_40_e5_v8__0l;
  *(CFAbsoluteTime *)&v4[4] = Current;
  dispatch_after(v1, global_queue, v4);
}

uint64_t (**__CFStringEncodingGetLatin5ConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_2)
    __CFStringEncodingPrecomposeLatinCharacter_2 = (_UNKNOWN *)a2(4);
  if (a1 > 1043)
  {
    if (a1 != 1044)
    {
      if (a1 == 1284)
        return __CFConverterWindowsLatin5;
      return 0;
    }
    return __CFConverterDOSTurkish;
  }
  else
  {
    if (a1 != 35)
    {
      if (a1 == 521)
        return __CFConverterISOLatin5;
      return 0;
    }
    return __CFConverterMacTurkish;
  }
}

uint64_t __CFToISOLatin5(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;

  if (a2 <= 0xCF)
    goto LABEL_2;
  if (a2 < 0x11E)
  {
LABEL_11:
    if (a2 <= 0xFF && (a2 - 208 >= 0x2F || ((0x600100006001uLL >> (a2 + 48)) & 1) == 0))
    {
LABEL_2:
      *a3 = a2;
      return 1;
    }
  }
  else if (a2 <= 0x15F)
  {
    v4 = (unsigned __int16 *)&ISOLatin5_from_uni;
    v5 = (unsigned __int16 *)&unk_182C8A9C4;
    while (1)
    {
      v6 = ((char *)v5 - (char *)v4) >> 3;
      v7 = &v4[2 * v6];
      v8 = *v7;
      if (v8 <= a2)
      {
        if (v8 >= a2)
        {
          LOBYTE(a2) = v4[2 * v6 + 1];
          goto LABEL_2;
        }
        v4 = v7 + 2;
      }
      else
      {
        v5 = v7 - 2;
      }
      if (v4 > v5)
        goto LABEL_11;
    }
  }
  return 0;
}

uint64_t __CFFromISOLatin5(uint64_t a1, int a2, _WORD *a3)
{
  if (a2 > 239)
  {
    switch(a2)
    {
      case 240:
        LOWORD(a2) = 287;
        break;
      case 253:
        LOWORD(a2) = 305;
        break;
      case 254:
        LOWORD(a2) = 351;
        break;
    }
  }
  else
  {
    switch(a2)
    {
      case 208:
        LOWORD(a2) = 286;
        break;
      case 221:
        LOWORD(a2) = 304;
        break;
      case 222:
        LOWORD(a2) = 350;
        break;
    }
  }
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin5Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  int v10;
  uint64_t result;
  BOOL v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0);
  v10 = __CFToISOLatin5(v9, v9, &v13);
  result = 0;
  if (v10)
    v12 = v13 == 0;
  else
    v12 = 1;
  if (!v12)
  {
    if (a5)
      *a4 = v13;
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFIsValidCombiningCharacterForLatin5(int a1)
{
  if ((a1 - 768) > 0x5F)
    return 0;
  else
    return (__CFLatin5CombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
}

uint64_t __CFToMacTurkish(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;

  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1792) >= 0x7A0u)
    {
      v4 = (unsigned __int16 *)&MacTurkish_from_uni;
      v5 = (unsigned __int16 *)&unk_182C8ABD0;
      do
      {
        v6 = ((char *)v5 - (char *)v4) >> 3;
        v7 = &v4[2 * v6];
        v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          v4 = v7 + 2;
        }
        else
        {
          v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

BOOL __CFFromMacTurkish(__int16 a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
  {
    if (a2 == 245 && (a1 & 0x200) != 0)
      a2 = 65533;
    else
      a2 = MacTurkish_to_uni[a2 - 128];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacTurkishPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  int v10;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned int v16;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0);
  if (v9 <= 0x7F)
  {
    LOBYTE(v10) = v9;
    if (!(_BYTE)v9)
      return 0;
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 1792) < 0x7A0u)
    return 0;
  v12 = (unsigned __int16 *)&MacTurkish_from_uni;
  v13 = (unsigned __int16 *)&unk_182C8ABD0;
  while (1)
  {
    v14 = ((char *)v13 - (char *)v12) >> 3;
    v15 = &v12[2 * v14];
    v16 = *v15;
    if (v16 <= v9)
      break;
    v13 = v15 - 2;
LABEL_12:
    if (v12 > v13)
      return 0;
  }
  if (v16 < v9)
  {
    v12 = v15 + 2;
    goto LABEL_12;
  }
  v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10)
    return 0;
LABEL_3:
  if (a5)
    *a4 = v10;
  *a6 = 1;
  return 2;
}

uint64_t __CFToDOSTurkish(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF)
    return 0;
  v5 = (unsigned __int16 *)&DOSTurkish_from_uni;
  v6 = (unsigned __int16 *)&unk_182C8AEC4;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSTurkish(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = DOSTurkish_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSTurkishPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      v11 = (unsigned __int16 *)&DOSTurkish_from_uni;
      v12 = (unsigned __int16 *)&unk_182C8AEC4;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

uint64_t __CFToWindowsLatin5(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8483 < 0xFFFFDF7D)
    return 0;
  v5 = (unsigned __int16 *)&WindowsLatin5_from_uni;
  v6 = (unsigned __int16 *)&unk_182C8B1A8;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromWindowsLatin5(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = WindowsLatin5_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWindowsLatin5Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_2(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8483) >= 0xDF7Du)
    {
      v11 = (unsigned __int16 *)&WindowsLatin5_from_uni;
      v12 = (unsigned __int16 *)&unk_182C8B1A8;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

void __CFRunLoopDump()
{
  CFRunLoopRef Current;
  CFStringRef v1;

  Current = CFRunLoopGetCurrent();
  v1 = CFCopyDescription(Current);
  CFShow(v1);
  CFRelease(v1);
}

__CFString *__CFRunLoopModeCopyDescription(uint64_t a1)
{
  __CFString *Mutable;
  CFAllocatorRef v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  CFAbsoluteTime Current;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  __int128 v17;

  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  v3 = CFGetAllocator((CFTypeRef)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFRunLoopMode %p [%p]>{name = %@, "), a1, v3, *(_QWORD *)(a1 + 80));
  CFStringAppendFormat(Mutable, 0, CFSTR("port set = 0x%x, "), *(unsigned int *)(a1 + 136));
  CFStringAppendFormat(Mutable, 0, CFSTR("queue = %p, "), *(_QWORD *)(a1 + 160));
  if (*(_BYTE *)(a1 + 168))
    v4 = "fired";
  else
    v4 = "not fired";
  CFStringAppendFormat(Mutable, 0, CFSTR("source = %p (%s), "), *(_QWORD *)(a1 + 152), v4);
  CFStringAppendFormat(Mutable, 0, CFSTR("timer port = 0x%x, "), *(unsigned int *)(a1 + 172));
  v17 = *(_OWORD *)(a1 + 96);
  v5 = *(_QWORD *)(a1 + 112);
  v6 = *(_QWORD *)(a1 + 120);
  Current = CFAbsoluteTimeGetCurrent();
  v8 = mach_absolute_time();
  v9 = *(_QWORD *)(a1 + 184);
  v10 = mach_absolute_time();
  v11 = __CFTSRToTimeInterval(v9 - v10);
  v12 = *(_QWORD *)(a1 + 184);
  v13 = *(_QWORD *)(a1 + 192);
  v14 = mach_absolute_time();
  v15 = __CFTSRToTimeInterval(v13 - v14);
  CFStringAppendFormat(Mutable, 0, CFSTR("\n\tsources0 = %@,\n\tsources1 = %@,\n\tobservers = %@,\n\ttimers = %@,\n\tcurrently %0.09g (%lld) / soft deadline in: %0.09g sec (@ %lld) / hard deadline in: %0.09g sec (@ %lld)\n},\n"), v17, v5, v6, *(_QWORD *)&Current, v8, *(_QWORD *)&v11, v12, *(_QWORD *)&v15, *(_QWORD *)(a1 + 192));
  return Mutable;
}

__CFString *__CFRunLoopCopyDescription(uint64_t a1)
{
  __CFString *Mutable;
  CFAllocatorRef v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  const __CFString *v8;
  const char *v9;
  const char *v10;

  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  v3 = CFGetAllocator((CFTypeRef)a1);
  v4 = a1 + *(unsigned __int8 *)(a1 + 84);
  v5 = *(unsigned __int8 *)(v4 + 85);
  v6 = *(unsigned __int8 *)(v4 + 339);
  v7 = *(_QWORD *)(a1 + 624);
  if (v7)
    v8 = *(const __CFString **)(v7 + 80);
  else
    v8 = CFSTR("(none)");
  if (v6)
    v9 = "true";
  else
    v9 = "false";
  if (v5)
    v10 = "true";
  else
    v10 = "false";
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFRunLoop %p [%p]>{wakeup port = 0x%x, stopped = %s, ignoreWakeUps = %s, \ncurrent mode = %@,\n"), a1, v3, *(unsigned int *)(a1 + 80), v10, v9, v8);
  CFStringAppendFormat(Mutable, 0, CFSTR("common modes = %@,\ncommon mode items = %@,\nmodes = %@}\n"), *(_QWORD *)(a1 + 608), *(_QWORD *)(a1 + 616), *(_QWORD *)(a1 + 632));
  return Mutable;
}

CFTypeID CFRunLoopGetTypeID(void)
{
  return 43;
}

uint64_t _CFRunLoopGet1(uint64_t a1)
{
  return *(_QWORD *)(a1 + 600);
}

uint64_t _CFRunLoopGet2b(uint64_t a1)
{
  return *(_QWORD *)(a1 + 672);
}

CFAbsoluteTime CFRunLoopGetNextTimerFireDate(CFRunLoopRef rl, CFRunLoopMode mode)
{
  unint64_t v4;
  pthread_mutex_t *v5;
  uint64_t v6;
  CFArrayRef *v7;
  pthread_mutex_t *v8;
  const __CFArray *v9;
  double NextFireDate;
  __CFRunLoopTimer *ValueAtIndex;

  v4 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v4 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v5 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  v6 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
  if (v6)
  {
    v7 = (CFArrayRef *)v6;
    v8 = (pthread_mutex_t *)(v6 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(v6 + 16));
    v9 = v7[15];
    NextFireDate = 0.0;
    if (v9)
    {
      if (CFArrayGetCount(v9) >= 1)
      {
        ValueAtIndex = (__CFRunLoopTimer *)CFArrayGetValueAtIndex(v7[15], 0);
        if (ValueAtIndex)
          NextFireDate = CFRunLoopTimerGetNextFireDate(ValueAtIndex);
      }
    }
    pthread_mutex_unlock(v8);
    CFRelease(v7);
  }
  else
  {
    NextFireDate = 0.0;
  }
  pthread_mutex_unlock(v5);
  return NextFireDate;
}

void _CFRunLoopStopMode(uint64_t a1, const __CFString *a2)
{
  uint64_t v4;
  _BYTE *v5;
  pthread_mutex_t *v6;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v4 = __CFRunLoopCopyMode(a1, a2, 1);
  if (v4)
  {
    v5 = (_BYTE *)v4;
    v6 = (pthread_mutex_t *)(v4 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 16));
    v5[88] = 1;
    pthread_mutex_unlock(v6);
    CFRelease(v5);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  CFRunLoopWakeUp((CFRunLoopRef)a1);
}

uint64_t _CFRunLoopModeContainsMode()
{
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  return 0;
}

uint64_t _CFRunLoopPerCalloutAutoreleasepoolEnabled()
{
  return *((unsigned __int8 *)CFRunLoopGetCurrent() + 681);
}

Boolean CFRunLoopContainsTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
  unint64_t v6;
  const __CFArray *v7;
  __CFRunLoop *v8;
  pthread_mutex_t *v9;
  uint64_t v10;
  CFArrayRef *v11;
  pthread_mutex_t *v12;
  const __CFSet *v13;
  CFRange v15;

  v6 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v6 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v6);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  LOBYTE(v7) = 0;
  v8 = (__CFRunLoop *)*((_QWORD *)timer + 11);
  if (v8 && v8 == rl)
  {
    v9 = (pthread_mutex_t *)((char *)rl + 16);
    pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
    if (mode == CFSTR("kCFRunLoopCommonModes"))
    {
      v13 = (const __CFSet *)*((_QWORD *)rl + 77);
      if (v13)
      {
        LOBYTE(v7) = CFSetContainsValue(v13, timer);
LABEL_16:
        pthread_mutex_unlock(v9);
        return v7;
      }
    }
    else
    {
      v10 = __CFRunLoopCopyMode((uint64_t)rl, mode, 0);
      if (v10)
      {
        v11 = (CFArrayRef *)v10;
        v12 = (pthread_mutex_t *)(v10 + 16);
        pthread_mutex_lock((pthread_mutex_t *)(v10 + 16));
        v7 = v11[15];
        if (v7)
        {
          v15.length = CFArrayGetCount(v11[15]);
          v15.location = 0;
          LOBYTE(v7) = CFArrayGetFirstIndexOfValue(v7, v15, timer) != -1;
        }
        pthread_mutex_unlock(v12);
        CFRelease(v11);
        goto LABEL_16;
      }
    }
    LOBYTE(v7) = 0;
    goto LABEL_16;
  }
  return v7;
}

CFStringRef __CFRunLoopSourceCopyDescription(unint64_t *a1)
{
  uint64_t (*v2)(unint64_t);
  uint64_t v3;
  CFStringRef v4;
  unint64_t v5;
  const void **v6;
  void *v7;
  int v8;
  const char *dli_sname;
  CFAllocatorRef v11;
  unint64_t v12;
  const char *v13;
  const char *v14;
  char v15;
  CFStringRef v16;
  Dl_info v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t (*)(unint64_t))a1[17];
  if (v2)
  {
    v3 = v2(a1[14]);
    if (v3)
    {
      v4 = (CFStringRef)v3;
      goto LABEL_17;
    }
  }
  v5 = a1[13];
  if (v5 == 1)
  {
    v6 = (const void **)(a1 + 21);
    goto LABEL_8;
  }
  if (!v5)
  {
    v6 = (const void **)(a1 + 22);
LABEL_8:
    v7 = (void *)*v6;
    goto LABEL_10;
  }
  v7 = 0;
LABEL_10:
  memset(&v18, 0, sizeof(v18));
  v8 = dladdr(v7, &v18);
  dli_sname = "???";
  if (v8)
  {
    if (v18.dli_sname && v18.dli_saddr == v7)
      dli_sname = v18.dli_sname;
  }
  v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFRunLoopSource context>{version = %ld, info = %p, callout = %s (%p)}"), a1[13], a1[14], dli_sname, v7);
LABEL_17:
  v11 = CFGetAllocator(a1);
  v12 = atomic_load(a1 + 11);
  v13 = "Yes";
  if (v12)
    v14 = "Yes";
  else
    v14 = "No";
  v15 = atomic_load(a1 + 1);
  if ((v15 & 8) == 0)
    v13 = "No";
  v16 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFRunLoopSource %p [%p]>{signalled = %s, valid = %s, order = %ld, context = %@}"), a1, v11, v14, v13, a1[10], v4);
  CFRelease(v4);
  return v16;
}

CFIndex CFRunLoopSourceGetOrder(CFRunLoopSourceRef source)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46)
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  return *((_QWORD *)source + 10);
}

BOOL CFRunLoopSourceIsSignalled(uint64_t a1)
{
  unint64_t v2;
  pthread_mutex_t *v3;
  unint64_t v4;
  _BOOL8 v5;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 46)
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v3 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v4 = atomic_load((unint64_t *)(a1 + 88));
  v5 = v4 != 0;
  pthread_mutex_unlock(v3);
  return v5;
}

CFStringRef __CFRunLoopObserverCopyDescription(unint64_t *a1)
{
  uint64_t (*v2)(unint64_t);
  CFStringRef v3;
  void *v4;
  const char *dli_sname;
  CFAllocatorRef v7;
  char v8;
  const char *v9;
  char v10;
  const char *v11;
  CFStringRef v12;
  Dl_info v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t (*)(unint64_t))a1[19];
  if (!v2 || (v3 = (CFStringRef)v2(a1[16])) == 0)
    v3 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFRunLoopObserver context %p>"), a1[16]);
  v4 = (void *)a1[14];
  memset(&v14, 0, sizeof(v14));
  dli_sname = "???";
  if (dladdr(v4, &v14))
  {
    if (v14.dli_sname && v14.dli_saddr == v4)
      dli_sname = v14.dli_sname;
  }
  v7 = CFGetAllocator(a1);
  v8 = atomic_load(a1 + 1);
  if ((v8 & 8) != 0)
    v9 = "Yes";
  else
    v9 = "No";
  v10 = atomic_load(a1 + 1);
  if ((v10 & 2) != 0)
    v11 = "Yes";
  else
    v11 = "No";
  v12 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFRunLoopObserver %p [%p]>{valid = %s, activities = 0x%lx, repeats = %s, order = %ld, callout = %s (%p), context = %@}"), a1, v7, v9, a1[12], v11, a1[13], dli_sname, v4, v3);
  CFRelease(v3);
  return v12;
}

CFTypeID CFRunLoopObserverGetTypeID(void)
{
  return 45;
}

CFOptionFlags CFRunLoopObserverGetActivities(CFRunLoopObserverRef observer)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45)
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  return *((_QWORD *)observer + 12);
}

CFIndex CFRunLoopObserverGetOrder(CFRunLoopObserverRef observer)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45)
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  return *((_QWORD *)observer + 13);
}

Boolean CFRunLoopObserverDoesRepeat(CFRunLoopObserverRef observer)
{
  unint64_t v2;
  unsigned int v3;

  v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45)
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v3 = atomic_load((unint64_t *)observer + 1);
  return (v3 >> 1) & 1;
}

Boolean CFRunLoopObserverIsValid(CFRunLoopObserverRef observer)
{
  unint64_t v2;
  unsigned int v3;

  v2 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v2 != 45)
    _CFAssertMismatchedTypeID(0x2DuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v3 = atomic_load((unint64_t *)observer + 1);
  return (v3 >> 3) & 1;
}

void CFRunLoopObserverGetContext(CFRunLoopObserverRef observer, CFRunLoopObserverContext *context)
{
  unint64_t v4;
  __int128 v5;
  __int128 v6;

  v4 = _CFGetNonObjCTypeID((unint64_t *)observer);
  if (v4 != 45)
    _CFAssertMismatchedTypeID(0x2DuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v5 = *(_OWORD *)((char *)observer + 120);
  v6 = *(_OWORD *)((char *)observer + 136);
  context->copyDescription = (CFStringRef (__cdecl *)(const void *))*((_QWORD *)observer + 19);
  *(_OWORD *)&context->version = v5;
  *(_OWORD *)&context->retain = v6;
}

CFStringRef __CFRunLoopTimerCopyDescription(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t (*v4)(_QWORD);
  CFStringRef v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t);
  void (*v9)(uint64_t, uint64_t, char *, uint64_t, char *, uint64_t, uint64_t (**)(uint64_t, uint64_t));
  const char *dli_fname;
  const char *dli_sname;
  CFAllocatorRef v12;
  char v13;
  const char *v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  CFAbsoluteTime Current;
  CFStringRef v20;
  uint64_t (*v22)(uint64_t, uint64_t);
  Dl_info v23;
  char v24[2048];
  char __str[2056];
  uint64_t v26;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v3 = v2;
  v26 = *MEMORY[0x1E0C80C00];
  v4 = *(uint64_t (**)(_QWORD))(v2 + 184);
  if (!v4 || (v5 = (CFStringRef)v4(*(_QWORD *)(v2 + 160))) == 0)
    v5 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFRunLoopTimer context %p>"), *(_QWORD *)(v3 + 160));
  v6 = *(_QWORD *)(v3 + 144);
  v7 = *(_QWORD *)(v3 + 160);
  strcpy(__str, "<unknown>");
  strcpy(v24, "<unknown>");
  v22 = 0;
  if (__CFRunLoopDebugInfoForRunLoopTimer_onceToken != -1)
    dispatch_once(&__CFRunLoopDebugInfoForRunLoopTimer_onceToken, &__block_literal_global_99_0);
  v8 = *(uint64_t (**)(uint64_t, uint64_t))(v3 + 144);
  if (v8 == _runLoopTimerWithBlockContext)
    v8 = *(uint64_t (**)(uint64_t, uint64_t))(v7 + 16);
  if ((char *)v8 == (char *)__CFFireTimer)
  {
    __CFDescribeTimer(v3, v7, __str, 0x800uLL, v24, 0x800uLL, (uint64_t *)&v22);
  }
  else if (v8 == (uint64_t (*)(uint64_t, uint64_t))__CFRunLoopDebugInfoForRunLoopTimer_foundationTimerFunc
         && __CFRunLoopDebugInfoForRunLoopTimer_foundationTimerFunc
         && (v9 = (void (*)(uint64_t, uint64_t, char *, uint64_t, char *, uint64_t, uint64_t (**)(uint64_t, uint64_t)))__CFRunLoopDebugInfoForRunLoopTimer_foundationDescribeTimerCalloutFunc) != 0
         || v8 == (uint64_t (*)(uint64_t, uint64_t))__CFRunLoopDebugInfoForRunLoopTimer_foundationDelayedPerformFunc
         && __CFRunLoopDebugInfoForRunLoopTimer_foundationDelayedPerformFunc
         && (v9 = (void (*)(uint64_t, uint64_t, char *, uint64_t, char *, uint64_t, uint64_t (**)(uint64_t, uint64_t)))__CFRunLoopDebugInfoForRunLoopTimer_foundationDescribeDelayedPerformFunc) != 0)
  {
    v9(v3, v7, __str, 2048, v24, 2048, &v22);
  }
  else
  {
    memset(&v23, 0, sizeof(v23));
    if (dladdr(v8, &v23))
    {
      dli_fname = v23.dli_fname;
      if (!v23.dli_fname)
        dli_fname = "<unknown library>";
      snprintf(__str, 0x800uLL, "%s", dli_fname);
      dli_sname = v23.dli_sname;
      if (!v23.dli_sname)
        dli_sname = "<unknown function>";
      snprintf(v24, 0x800uLL, "%s", dli_sname);
    }
    else
    {
      strcpy(__str, "<unknown library>");
      strcpy(v24, "<unknown function>");
    }
    v22 = v8;
  }
  v12 = CFGetAllocator((CFTypeRef)v3);
  v13 = atomic_load((unint64_t *)(v3 + 8));
  if ((v13 & 8) != 0)
    v14 = "Yes";
  else
    v14 = "No";
  if ((*(_WORD *)(v3 + 16) & 1) != 0)
    v15 = "Yes";
  else
    v15 = "No";
  v17 = *(_QWORD *)(v3 + 112);
  v16 = *(_QWORD *)(v3 + 120);
  v18 = *(double *)(v3 + 104);
  Current = CFAbsoluteTimeGetCurrent();
  v20 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFRunLoopTimer %p [%p]>{valid = %s, firing = %s, interval = %0.09g, tolerance = %0.09g, next fire date = %0.09g (%0.09g @ %lld), callout = %s (%p / %p) (%s), context = %@}"), v3, v12, v14, v15, v17, v16, *(_QWORD *)&v18, v18 - Current, *(_QWORD *)(v3 + 128), v24, v6, v22, __str, v5);
  CFRelease(v5);
  return v20;
}

CFIndex CFRunLoopTimerGetOrder(CFRunLoopTimerRef timer)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)timer);
  if (v2 != 47)
    _CFAssertMismatchedTypeID(0x2FuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  return *((_QWORD *)timer + 17);
}

CFTimeInterval CFRunLoopTimerGetTolerance(CFRunLoopTimerRef timer)
{
  CFTimeInterval result;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (!CF_IS_OBJC(0x2FuLL, (__objc2_class **)timer))
    return *((double *)timer + 15);
  -[__CFRunLoopTimer tolerance](timer, "tolerance");
  return result;
}

uint64_t __CFRunLoopKillOneTimer(uint64_t a1)
{
  pthread_mutex_t *v2;

  v2 = (pthread_mutex_t *)(a1 + 24);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 96));
  *(_QWORD *)(a1 + 88) = 0;
  return pthread_mutex_unlock(v2);
}

void __THE_SYSTEM_HAS_NO_PORT_SETS_AVAILABLE__(int a1)
{
  if (a1 == 6)
    __RESOURCE_SHORTAGE__();
  if (a1 == 3)
    __NO_SPACE__();
  __break(1u);
}

void OUTLINED_FUNCTION_0_11(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

uint64_t __CFRecordAllocationEvent()
{
  BOOL v0;
  uint64_t result;

  if (__CFOASafe)
    v0 = __CFObjectAllocRecordAllocationFunction == 0;
  else
    v0 = 1;
  if (!v0)
    return __CFObjectAllocRecordAllocationFunction();
  return result;
}

void *__CFRuntimeEnumerateClassTable(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, void *, uint64_t, void **), uint64_t a4)
{
  uint64_t v8;
  uint64_t i;
  void *result;
  int v11;
  unsigned int v12;
  int v13;
  signed int v14;
  uint64_t v15;
  void *__src;
  _QWORD __dst[34];

  __dst[33] = *MEMORY[0x1E0C80C00];
  v8 = (*(uint64_t (**)(uint64_t, const char *))(a2 + 16))(a2, "__CFRuntimeBuiltinClassTable");
  if (v8)
  {
    __dst[0] = 0;
    if (!a3(a1, (void *)v8, 576, (void **)__dst))
    {
      for (i = 0; i != 576; i += 8)
        (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a4, *(_QWORD *)(__dst[0] + i));
    }
  }
  result = (void *)(*(uint64_t (**)(uint64_t, const char *))(a2 + 16))(a2, "__CFRuntimeClassTables");
  if (result)
  {
    __src = 0;
    result = (void *)a3(a1, result, 264, &__src);
    if (!(_DWORD)result)
    {
      result = memcpy(__dst, __src, 0x108uLL);
      v15 = 0;
      v11 = atomic_load((unsigned int *)&__dst[32]);
      if (v11 >= 1)
      {
        v12 = 0;
        v13 = -1;
        do
        {
          if (v12 >> 6 != v13)
          {
            result = (void *)a3(a1, (void *)__dst[v12 >> 6], 512, (void **)&v15);
            v13 = v12 >> 6;
            if ((_DWORD)result)
              break;
          }
          result = (void *)(*(uint64_t (**)(uint64_t, _QWORD))(a4 + 16))(a4, *(_QWORD *)(v15 + 8 * (v12++ & 0x3F)));
          v14 = atomic_load((unsigned int *)&__dst[32]);
        }
        while ((int)v12 < v14);
      }
    }
  }
  return result;
}

void _CFRuntimeUnregisterClassWithTypeID(unint64_t a1)
{
  int v1;

  if (a1 <= 0x47)
    _CFRuntimeUnregisterClassWithTypeID_cold_1();
  v1 = a1;
  os_unfair_lock_lock_with_options();
  *(_QWORD *)(__CFRuntimeClassTables[(v1 - 72) >> 6] + 8 * ((v1 - 72) & 0x3F)) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
}

void _CFEnableZombies()
{
  if (!__CFZombieEnabled)
  {
    __CFZombieEnabled = -1;
    __CFZombifyNSObject();
  }
}

uint64_t __CFRuntimeIsFreedObject(uint64_t result)
{
  void *v1;
  Class Class;
  objc_class *v3;
  const char *Name;

  if (result)
  {
    v1 = (void *)result;
    if (!__CFRuntimeIsFreedObject_freedClass)
      __CFRuntimeIsFreedObject_freedClass = _objc_getFreedObjectClass();
    Class = object_getClass(v1);
    if (Class == (Class)__CFRuntimeIsFreedObject_freedClass)
      return 1;
    v3 = Class;
    result = (uint64_t)object_getClass(Class);
    if (!result)
      return result;
    Name = class_getName(v3);
    return Name && !strncmp(Name, "_NSZombie_", 0xAuLL);
  }
  return result;
}

uint64_t __CFGenericTypeID(unint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t result;

  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    v1 = 0;
    v2 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0)
      v2 = 0;
    v3 = v2 ^ (unint64_t)a1;
    do
    {
      if ((v3 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v1))
        break;
      ++v1;
    }
    while (v1 != 7);
    v4 = v1 | v3;
    v5 = v1 & 7;
    v6 = (v4 >> 55) + 8;
    if (v5 != 7)
      v6 = v5;
    v7 = 22;
    switch(v6)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          __CFGenericTypeID_cold_1();
        return 1;
      case 1:
        goto LABEL_17;
      case 2:
        return 7;
      case 3:
        return v7;
      case 4:
      case 5:
        return 1;
      case 6:
        return 42;
      default:
        if (v6 == 20)
          return 1;
        if (v6 == 22)
          return 7;
LABEL_17:
        result = objc_msgSend(a1, "_cfTypeID");
        break;
    }
  }
  else
  {
    v8 = atomic_load(a1 + 1);
    return (v8 >> 8) & 0x3FF;
  }
  return result;
}

uint64_t _CFGetTypeIDDescription(unint64_t a1)
{
  uint64_t *v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (a1 > 0x47)
  {
    v2 = a1 - 72;
    if ((int)a1 - 72 >= dword_1ECCFAFE8)
      return 0;
    v3 = __CFRuntimeClassTables[v2 >> 6];
    if (!v3)
      return 0;
    v1 = (uint64_t *)(v3 + 8 * (v2 & 0x3F));
  }
  else
  {
    v1 = (uint64_t *)(&__CFRuntimeBuiltinClassTable + a1);
  }
  v4 = 0;
  if (a1 != 1)
  {
    v5 = *v1;
    if (v5)
      return *(_QWORD *)(v5 + 8);
  }
  return v4;
}

CFStringRef CFCopyTypeIDDescription(CFTypeID type_id)
{
  _UNKNOWN **v1;

  if (type_id > 0x47)
    v1 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)type_id - 72) >> 6] + 8 * (((_DWORD)type_id - 72) & 0x3F));
  else
    v1 = &__CFRuntimeBuiltinClassTable + type_id;
  return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, *((const char **)*v1 + 1), 0x600u);
}

uint64_t _objc_getTaggedPointerTag(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int v6;

  v1 = 0;
  v2 = *MEMORY[0x1E0DE7C58];
  if ((~a1 & 0xC000000000000007) == 0)
    v2 = 0;
  v3 = v2 ^ a1;
  do
  {
    if ((v3 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v1))
      break;
    ++v1;
  }
  while (v1 != 7);
  v4 = v1 | v3;
  v5 = v1 & 7;
  v6 = (v4 >> 55) + 8;
  if (v5 == 7)
    return v6;
  else
    return v5;
}

ssize_t __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__()
{
  write(2, "The process has forked and you cannot use this CoreFoundation functionality safely. You MUST exec().\n", 0x65uLL);
  return write(2, "Break on __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__() to debug.\n", 0x75uLL);
}

uint64_t os_log_callback()
{
  return 0;
}

void __cf_atfork_child()
{
  unsigned __int8 v0;

  if ((__CF_FORK_STATE & 2) != 0)
  {
    do
      v0 = __ldaxr((unsigned __int8 *)&__CF_FORK_STATE);
    while (__stlxr(v0 | 1, (unsigned __int8 *)&__CF_FORK_STATE));
  }
}

uint64_t _CFRegisterThreadSanitizerTag(uint64_t a1)
{
  BOOL v1;

  if (__cf_tsanRegisterTagFunction)
    v1 = a1 == 0;
  else
    v1 = 1;
  if (v1)
    return 0;
  else
    return __cf_tsanRegisterTagFunction();
}

uint64_t _CFAssignThreadSanitizerTag(uint64_t result, uint64_t a2)
{
  BOOL v2;

  if (__cf_tsanAssignTagFunction)
    v2 = result == 0;
  else
    v2 = 1;
  if (!v2 && a2 != 0)
    return __cf_tsanAssignTagFunction();
  return result;
}

const char *PROEM_SEL_0(const char *a1)
{
  if (a1)
    return sel_getName(a1);
  else
    return "(null selector)";
}

double __os_log_helper_1_2_4_8_32_8_32_8_0_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  double result;

  *(_QWORD *)&result = 136315906;
  *(_DWORD *)a1 = 136315906;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2080;
  *(_QWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(_QWORD *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 32) = 2048;
  *(_QWORD *)(a1 + 34) = a5;
  return result;
}

double __os_log_helper_1_2_3_8_32_8_32_8_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double result;

  *(_QWORD *)&result = 136315650;
  *(_DWORD *)a1 = 136315650;
  *(_QWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2080;
  *(_QWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 2048;
  *(_QWORD *)(a1 + 24) = a4;
  return result;
}

void __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_182BC9C74(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t _compare_clumpiness_0(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

void sub_182BCA938(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void OUTLINED_FUNCTION_0_12(objc_class *a1, uint64_t a2)
{
  __CFRequireConcreteImplementation(a1, a2);
}

double __CFSetGetCallbacks@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double result;
  __int128 v7;
  __int128 v8;
  _OWORD v9[2];
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = 0u;
  v8 = 0u;
  memset(v9, 0, sizeof(v9));
  v7 = 0u;
  __CFBasicHashGetCallbacks(a1, &v7);
  v3 = *((_QWORD *)&v7 + 1);
  v4 = *((_QWORD *)&v8 + 1);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = v3;
  v5 = *((_QWORD *)&v10 + 1);
  *(_QWORD *)(a2 + 16) = v4;
  *(_QWORD *)(a2 + 24) = v5;
  result = *((double *)v9 + 1);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)((char *)v9 + 8);
  return result;
}

uint64_t __CFSetCreateTransfer(__objc2_class **a1, unint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v12[11];

  v12[10] = *MEMORY[0x1E0C80C00];
  v12[6] = (uint64_t)CFHash;
  v12[7] = 0;
  v12[0] = (uint64_t)__CFTypeCollectionRetain;
  v12[1] = (uint64_t)__CFTypeCollectionRetain;
  v12[2] = (uint64_t)__CFTypeCollectionRelease;
  v12[3] = (uint64_t)__CFTypeCollectionRelease;
  v12[4] = (uint64_t)CFEqual;
  v12[5] = (uint64_t)CFEqual;
  v12[8] = (uint64_t)CFCopyDescription;
  v12[9] = (uint64_t)CFCopyDescription;
  v5 = CFBasicHashCreate(a1, 0x2000u, v12);
  CFBasicHashSuppressRC(v5);
  if (a3 >= 1)
  {
    CFBasicHashSetCapacity(v5, a3);
    do
    {
      v6 = *a2++;
      CFBasicHashAddValue(v5, v6, v6);
      --a3;
    }
    while (a3);
  }
  CFBasicHashUnsuppressRC(v5);
  v7 = (unint64_t *)(v5 + 8);
  v8 = atomic_load((unint64_t *)(v5 + 8));
  do
  {
    v9 = __ldaxr(v7);
    if (v9 == v8)
    {
      if (!__stlxr(v8 | 0x40, v7))
      {
        v10 = 1;
        goto LABEL_10;
      }
    }
    else
    {
      __clrex();
    }
    v10 = 0;
LABEL_10:
    v8 = v9;
  }
  while (!v10);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)v5, 0x11uLL);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  return v5;
}

CFIndex CFSetGetCountOfValue(CFSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
    return -[__CFSet countForObject:](theSet, "countForObject:", value);
  else
    return CFBasicHashGetCountOfKey((uint64_t)theSet, (unint64_t)value);
}

void CFSetReplaceValue(CFMutableSetRef theSet, const void *value)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet replaceObject:](theSet, "replaceObject:", value);
  }
  else
  {
    v10 = atomic_load((unint64_t *)theSet + 1);
    if ((v10 & 0x40) != 0)
      CFLog(3, (uint64_t)CFSTR("%s(): immutable collection %p given to mutating function"), v4, v5, v6, v7, v8, v9, (__int16)"void CFSetReplaceValue(CFMutableSetRef, const void *)");
    CFBasicHashReplaceValue((unint64_t)theSet, (unint64_t)value, (uint64_t)value);
  }
}

uint64_t __CFSocketSetSocketReadBufferAttrs(uint64_t a1, CFIndex a2, double a3)
{
  int v5;
  uint64_t v6;
  BOOL v7;
  double v8;
  float v9;
  CFIndex v10;
  uint64_t v11;
  uint64_t v12;
  CFIndex v13;
  __CFData *Mutable;
  const __CFAllocator *v15;
  const UInt8 *BytePtr;
  CFIndex *v17;
  _QWORD *v18;
  const void *v19;
  const void *v20;
  __CFData *v21;

  if (a3 == 0.0)
  {
    v5 = 0;
    v6 = 0;
  }
  else
  {
    v7 = a3 < 2147483650.0 && a3 > 0.0;
    v8 = floor(a3);
    if (v7)
    {
      v9 = v8;
      v6 = (int)v9;
    }
    else
    {
      v6 = 0x7FFFFFFFLL;
    }
    v5 = (int)((a3 - v8) * 1000000.0);
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
  v10 = *(_QWORD *)(a1 + 296);
  if (v10 != a2)
  {
    v11 = *(_QWORD *)(a1 + 304);
    v12 = *(_QWORD *)(a1 + 312);
    v13 = v11 - v12;
    if (v11 != v12)
    {
      Mutable = *(__CFData **)(a1 + 328);
      if (!Mutable)
      {
        v15 = CFGetAllocator((CFTypeRef)a1);
        Mutable = CFDataCreateMutable(v15, 0);
        *(_QWORD *)(a1 + 328) = Mutable;
      }
      BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 288));
      CFDataAppendBytes(Mutable, &BytePtr[*(_QWORD *)(a1 + 312)], v13);
      CFRelease(*(CFTypeRef *)(a1 + 288));
      v10 = 0;
      *(_OWORD *)(a1 + 288) = 0u;
      *(_OWORD *)(a1 + 304) = 0u;
    }
    v17 = (CFIndex *)(a1 + 296);
    if (a2)
    {
      v18 = (_QWORD *)(a1 + 304);
      v19 = *(const void **)(a1 + 288);
      if (v10 < a2)
      {
        if (v19)
        {
          CFRelease(v19);
          *(_QWORD *)(a1 + 288) = 0;
        }
        *v17 = a2;
        *v18 = 0;
        *(_QWORD *)(a1 + 312) = 0;
        goto LABEL_23;
      }
      *v17 = a2;
      *v18 = 0;
      *(_QWORD *)(a1 + 312) = 0;
      if (!v19)
      {
LABEL_23:
        v21 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
        *(_QWORD *)(a1 + 288) = v21;
        CFDataSetLength(v21, a2);
      }
    }
    else
    {
      *v17 = 0;
      *(_QWORD *)(a1 + 304) = 0;
      *(_QWORD *)(a1 + 312) = 0;
      v20 = *(const void **)(a1 + 288);
      if (v20)
      {
        CFRelease(v20);
        v5 = 0;
        v6 = 0;
        *(_QWORD *)(a1 + 288) = 0;
      }
      else
      {
        v5 = 0;
        v6 = 0;
      }
    }
  }
  if (*(_QWORD *)(a1 + 272) != v6 || *(_DWORD *)(a1 + 280) != v5)
  {
    *(_QWORD *)(a1 + 272) = v6;
    *(_DWORD *)(a1 + 280) = v5;
    *(_DWORD *)(a1 + 284) = 0;
    __CFReadSocketsTimeoutInvalid = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
}

uint64_t __CFSocketGetBytesAvailable(__CFSocket *a1, _QWORD *a2)
{
  uint64_t v3;
  CFSocketNativeHandle Native;
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  v3 = *((_QWORD *)a1 + 38) - *((_QWORD *)a1 + 39);
  if (!v3)
  {
    v6[0] = 0;
    Native = CFSocketGetNative(a1);
    if (ioctl(Native, 0x4004667FuLL, v6) < 0)
      return 0;
    v3 = v6[0];
  }
  *a2 = v3;
  return 1;
}

__CFString *__CFSocketCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  void *v4;
  const char *dli_sname;
  CFAllocatorRef v7;
  const char *v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t (*v15)(uint64_t);
  const __CFString *v16;
  const __CFAllocator *v17;
  Dl_info v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 24));
  v4 = *(void **)(a1 + 208);
  memset(&v19, 0, sizeof(v19));
  dli_sname = "???";
  if (dladdr(v4, &v19))
  {
    if (v19.dli_sname && v19.dli_saddr == v4)
      dli_sname = v19.dli_sname;
  }
  v7 = CFGetAllocator((CFTypeRef)a1);
  v8 = "Yes";
  v9 = atomic_load((unint64_t *)(a1 + 8));
  if ((v9 & 0x10) == 0)
    v8 = "No";
  v10 = *(int *)(a1 + 184);
  v12 = *(unsigned int *)(a1 + 152);
  v11 = *(unsigned int *)(a1 + 156);
  v13 = atomic_load((unint64_t *)(a1 + 8));
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFSocket %p [%p]>{valid = %s, type = %d, socket = %d, socket set count = %ld,\n    callback types = 0x%x, callout = %s (%p), source = %p,\n    run loops = %@,\n    context = "), a1, v7, v8, v11, v12, v10, v13 & 0xF, dli_sname, v4, *(_QWORD *)(a1 + 192), *(_QWORD *)(a1 + 200));
  v14 = *(_QWORD *)(a1 + 224);
  v15 = *(uint64_t (**)(uint64_t))(a1 + 248);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 24));
  if (!v14 || !v15 || (v16 = (const __CFString *)v15(v14)) == 0)
  {
    v17 = CFGetAllocator((CFTypeRef)a1);
    v16 = CFStringCreateWithFormat(v17, 0, CFSTR("<CFSocket context %p>"), v14);
  }
  CFStringAppend(Mutable, v16);
  CFStringAppend(Mutable, CFSTR("}"));
  CFRelease(v16);
  return Mutable;
}

CFDataRef CFSocketCopyAddress(CFSocketRef s)
{
  unint64_t v2;
  pthread_mutex_t *v3;
  char v4;
  const void *v5;
  const __CFData *v6;
  int v8;
  const __CFAllocator *v9;
  socklen_t v10;
  sockaddr v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v3 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  v10 = 256;
  v4 = atomic_load((unint64_t *)s + 1);
  if ((v4 & 0x10) != 0 && !*((_QWORD *)s + 21))
  {
    v8 = *((_DWORD *)s + 38);
    if (v8 != -1 && !getsockname(v8, &v11, &v10) && (int)v10 >= 1)
    {
      v9 = CFGetAllocator(s);
      *((_QWORD *)s + 21) = CFDataCreate(v9, &v11.sa_len, (int)v10);
    }
  }
  v5 = (const void *)*((_QWORD *)s + 21);
  if (v5)
    v6 = (const __CFData *)CFRetain(v5);
  else
    v6 = 0;
  pthread_mutex_unlock(v3);
  return v6;
}

CFDataRef CFSocketCopyPeerAddress(CFSocketRef s)
{
  unint64_t v2;
  pthread_mutex_t *v3;
  char v4;
  const void *v5;
  const __CFData *v6;
  int v8;
  const __CFAllocator *v9;
  socklen_t v10;
  sockaddr v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v2 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v2 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v3 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  v10 = 256;
  v4 = atomic_load((unint64_t *)s + 1);
  if ((v4 & 0x10) != 0 && !*((_QWORD *)s + 22))
  {
    v8 = *((_DWORD *)s + 38);
    if (v8 != -1 && !getpeername(v8, &v11, &v10) && (int)v10 >= 1)
    {
      v9 = CFGetAllocator(s);
      *((_QWORD *)s + 22) = CFDataCreate(v9, &v11.sa_len, (int)v10);
    }
  }
  v5 = (const void *)*((_QWORD *)s + 22);
  if (v5)
    v6 = (const __CFData *)CFRetain(v5);
  else
    v6 = 0;
  pthread_mutex_unlock(v3);
  return v6;
}

void CFSocketGetContext(CFSocketRef s, CFSocketContext *context)
{
  unint64_t v4;
  __int128 v5;
  __int128 v6;

  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v5 = *(_OWORD *)((char *)s + 216);
  v6 = *(_OWORD *)((char *)s + 232);
  context->copyDescription = (CFStringRef (__cdecl *)(const void *))*((_QWORD *)s + 31);
  *(_OWORD *)&context->version = v5;
  *(_OWORD *)&context->retain = v6;
}

void CFSocketDisableCallBacks(CFSocketRef s, CFOptionFlags callBackTypes)
{
  unsigned __int8 v2;
  unint64_t v4;
  pthread_mutex_t *v5;
  char v6;
  unsigned __int8 v7;
  unint64_t v8;
  unsigned __int8 v9;
  CFIndex v10;
  __CFData *v11;
  UInt8 *MutableBytePtr;
  CFIndex v13;
  __CFData *v14;
  UInt8 *v15;
  char v16;
  char v17;
  uint64_t v18;

  v2 = callBackTypes;
  v18 = *MEMORY[0x1E0C80C00];
  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v5 = (pthread_mutex_t *)((char *)s + 24);
  pthread_mutex_lock((pthread_mutex_t *)((char *)s + 24));
  v6 = atomic_load((unint64_t *)s + 1);
  if ((v6 & 0x10) != 0 && *((int *)s + 46) >= 1)
  {
    v7 = atomic_load((unint64_t *)s + 1);
    v8 = v2 & v7 & 0xF;
    v9 = atomic_load((unint64_t *)s + 1);
    *((_DWORD *)s + 4) |= (_DWORD)v8 << 8;
    os_unfair_lock_lock((os_unfair_lock_t)&__CFActiveSocketsLock);
    if ((v9 & 3) == 2 || *((_DWORD *)s + 39) != 1)
      *((_DWORD *)s + 4) |= 0x10000u;
    if (v8 > 7 || (v8 & 4) != 0 && (*((_BYTE *)s + 18) & 1) == 0)
    {
      v10 = *((unsigned int *)s + 38);
      if ((v10 & 0x80000000) == 0)
      {
        v11 = (__CFData *)__CFWriteSocketsFds;
        if (v10 < 8 * CFDataGetLength((CFDataRef)__CFWriteSocketsFds))
        {
          MutableBytePtr = CFDataGetMutableBytePtr(v11);
          if (__darwin_check_fd_set_overflow(v10, MutableBytePtr, 1))
          {
            if ((*(_DWORD *)&MutableBytePtr[4 * (v10 >> 5)] & (1 << v10)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v10, MutableBytePtr, 1))
                *(_DWORD *)&MutableBytePtr[4 * (v10 >> 5)] &= ~(1 << v10);
              if ((_DWORD)__CFWakeupSocketPair != -1)
              {
                v16 = 120;
                send(__CFWakeupSocketPair, &v16, 1uLL, 0);
              }
              atomic_load((unint64_t *)s + 1);
            }
          }
        }
      }
    }
    if ((v9 & 3) != 0 && (v9 & v8 & 3) != 0)
    {
      __CFReadSocketsTimeoutInvalid = 0;
      v13 = *((unsigned int *)s + 38);
      if ((v13 & 0x80000000) == 0)
      {
        v14 = (__CFData *)__CFReadSocketsFds;
        if (v13 < 8 * CFDataGetLength((CFDataRef)__CFReadSocketsFds))
        {
          v15 = CFDataGetMutableBytePtr(v14);
          if (__darwin_check_fd_set_overflow(v13, v15, 1))
          {
            if ((*(_DWORD *)&v15[4 * (v13 >> 5)] & (1 << v13)) != 0)
            {
              if (__darwin_check_fd_set_overflow(v13, v15, 1))
                *(_DWORD *)&v15[4 * (v13 >> 5)] &= ~(1 << v13);
              if ((_DWORD)__CFWakeupSocketPair != -1)
              {
                v17 = 115;
                send(__CFWakeupSocketPair, &v17, 1uLL, 0);
              }
            }
          }
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFActiveSocketsLock);
  }
  pthread_mutex_unlock(v5);
}

CFSocketError CFSocketSendData(CFSocketRef s, CFDataRef address, CFDataRef data, CFTimeInterval timeout)
{
  unint64_t v8;
  const sockaddr *BytePtr;
  const UInt8 *v10;
  int Length;
  CFSocketNativeHandle Native;
  int v13;
  BOOL v14;
  double v15;
  uint64_t v16;
  int v17;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v8 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v8 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v8);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v21 = 0;
  if (address)
  {
    BytePtr = (const sockaddr *)CFDataGetBytePtr(address);
    LODWORD(address) = CFDataGetLength(address);
  }
  else
  {
    BytePtr = 0;
  }
  v10 = CFDataGetBytePtr(data);
  Length = CFDataGetLength(data);
  if (!CFSocketIsValid(s))
    return -1;
  Native = CFSocketGetNative(s);
  if (Native == -1)
    return -1;
  v13 = Native;
  CFRetain(s);
  os_unfair_lock_lock((os_unfair_lock_t)&__CFSocketWriteLock_);
  v14 = timeout < 2147483650.0 && timeout > 0.0;
  v15 = floor(timeout);
  v16 = (int)vcvtmd_s64_f64(timeout);
  if (!v14)
    v16 = 0x7FFFFFFFLL;
  v20 = v16;
  LODWORD(v21) = vcvtmd_s64_f64((timeout - v15) * 1000000.0);
  setsockopt(v13, 0xFFFF, 4101, &v20, 0x10u);
  if (BytePtr && (int)address >= 1)
    v17 = sendto(v13, v10, Length, 0, BytePtr, (socklen_t)address);
  else
    v17 = send(v13, v10, Length, 0);
  v19 = v17;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFSocketWriteLock_);
  CFRelease(s);
  if (v19 >= 1)
    return 0;
  else
    return -1;
}

CFSocketError CFSocketSetAddress(CFSocketRef s, CFDataRef address)
{
  unint64_t v4;
  const sockaddr *BytePtr;
  socklen_t Length;
  CFSocketError result;
  CFSocketNativeHandle Native;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  const __CFString *v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int16 v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v4 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v4 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v4);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (!address || !CFSocketIsValid(s))
    return -1;
  BytePtr = (const sockaddr *)CFDataGetBytePtr(address);
  Length = CFDataGetLength(address);
  result = kCFSocketError;
  if (BytePtr && Length)
  {
    Native = CFSocketGetNative(s);
    if (Length < 3 || BytePtr->sa_family != 1)
    {
LABEL_18:
      v15 = bind(Native, BytePtr, Length);
      if (v15)
      {
        v16 = CFSTR("CFSocketSetAddress bind failure: %d");
      }
      else
      {
        if (!listen(Native, 256))
          return (uint64_t)v15;
        v16 = CFSTR("CFSocketSetAddress listen failure: %d");
      }
      v17 = __error();
      CFLog(7, (uint64_t)v16, v18, v19, v20, v21, v22, v23, *v17);
      return (uint64_t)v15;
    }
    Length = strnlen(BytePtr->sa_data, Length - 2) + 2;
    if (Length <= 0xFF)
    {
      if (Length != BytePtr->sa_len)
      {
        CFLog(4, (uint64_t)CFSTR("WARNING: The sun_len field of a sockaddr_un structure passed to CFSocketSetAddress was not set correctly using the SUN_LEN macro."), v9, v10, v11, v12, v13, v14, v24);
        __memcpy_chk();
        v25 = Length;
        BytePtr = (const sockaddr *)&v25;
      }
      goto LABEL_18;
    }
    return -1;
  }
  return result;
}

CFSocketError CFSocketConnectToAddress(CFSocketRef s, CFDataRef address, CFTimeInterval timeout)
{
  unint64_t v6;
  const sockaddr *BytePtr;
  signed int Length;
  CFSocketError result;
  unsigned int Native;
  BOOL v11;
  int v12;
  int v13;
  BOOL v14;
  const __CFData *Mutable;
  __CFData *v16;
  unint64_t v17;
  UInt8 *MutableBytePtr;
  unint64_t v19;
  unint64_t v20;
  unsigned int v21;
  BOOL v22;
  double v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (CFSocketGetTypeID_initOnce != -1)
    dispatch_once(&CFSocketGetTypeID_initOnce, &__block_literal_global_15);
  v6 = _CFGetNonObjCTypeID((unint64_t *)s);
  if (v6 != 61)
    _CFAssertMismatchedTypeID(0x3DuLL, v6);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v29 = 1;
  v30 = 0;
  HIDWORD(v28) = 0;
  if (!CFSocketIsValid(s))
    return -1;
  BytePtr = (const sockaddr *)CFDataGetBytePtr(address);
  Length = CFDataGetLength(address);
  result = kCFSocketError;
  if (BytePtr && Length >= 1)
  {
    Native = CFSocketGetNative(s);
    v11 = (fcntl(Native, 3, 0) & 0x80000004) == 4 || timeout == 0.0;
    if (!v11)
      ioctl(Native, 0x8004667EuLL, &v29);
    v12 = connect(Native, BytePtr, Length);
    if (v12)
    {
      v13 = *__error();
      v14 = v13 == 36;
      if (timeout >= 0.0 && v13 == 36)
      {
        LODWORD(v28) = 4;
        HIDWORD(v27) = 0;
        Mutable = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
        v16 = Mutable;
        if ((Native & 0x80000000) == 0)
        {
          v17 = 8 * CFDataGetLength(Mutable);
          if ((uint64_t)v17 <= Native)
          {
            v19 = v17 >> 5;
            v20 = 4 * ((((unint64_t)Native + 32) >> 5) - (v17 >> 5));
            CFDataIncreaseLength(v16, v20);
            MutableBytePtr = CFDataGetMutableBytePtr(v16);
            bzero(&MutableBytePtr[4 * v19], v20);
          }
          else
          {
            MutableBytePtr = CFDataGetMutableBytePtr(v16);
          }
          v21 = Native >> 5;
          if (!__darwin_check_fd_set_overflow(Native, MutableBytePtr, 1)
            || ((*(_DWORD *)&MutableBytePtr[4 * v21] >> Native) & 1) == 0)
          {
            if (__darwin_check_fd_set_overflow(Native, MutableBytePtr, 1))
              *(_DWORD *)&MutableBytePtr[4 * v21] |= 1 << Native;
          }
        }
        v22 = timeout < 2147483650.0 && timeout > 0.0;
        v23 = floor(timeout);
        v24 = (int)vcvtmd_s64_f64(timeout);
        if (!v22)
          v24 = 0x7FFFFFFFLL;
        v26 = v24;
        LODWORD(v27) = vcvtmd_s64_f64((timeout - v23) * 1000000.0);
        CFDataGetLength(v16);
        CFDataGetMutableBytePtr(v16);
        v25 = select_DARWIN_EXTSN();
        if (v25 < 0)
        {
          v30 = *__error();
          v12 = -1;
        }
        else if (v25)
        {
          if (getsockopt(Native, 0xFFFF, 4103, &v30, (socklen_t *)&v28))
          {
            v12 = 0;
            v30 = 0;
          }
          else if (v30)
          {
            v12 = -1;
          }
          else
          {
            v12 = 0;
          }
        }
        else
        {
          v12 = -2;
        }
        CFRelease(v16);
        v14 = 1;
        if (v11)
          goto LABEL_26;
LABEL_25:
        ioctl(Native, 0x8004667EuLL, (char *)&v28 + 4, v26, v27, v28);
LABEL_26:
        if (timeout < 0.0 && v14)
          return 0;
        else
          return (uint64_t)v12;
      }
    }
    else
    {
      v14 = 0;
    }
    if (v11)
      goto LABEL_26;
    goto LABEL_25;
  }
  return result;
}

CFSocketRef CFSocketCreate(CFAllocatorRef allocator, SInt32 protocolFamily, SInt32 socketType, SInt32 protocol, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  SInt32 v14;
  SInt32 v15;
  SInt32 v17;
  SInt32 v19;
  int v21;
  CFSocketNativeHandle v22;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (protocolFamily >= 1)
    v14 = protocolFamily;
  else
    v14 = 2;
  if (socketType <= 1)
    v15 = 1;
  else
    v15 = socketType;
  if (protocol < 1 && socketType < 2)
    v17 = 6;
  else
    v17 = protocol;
  if (v17 < 1 && v15 == 2)
    v17 = 17;
  if (v14 == 2)
    v19 = v17;
  else
    v19 = protocol;
  if (v14 != 2)
    v15 = socketType;
  if (v15 < 1 && v14 == 1)
    v21 = 1;
  else
    v21 = v15;
  v22 = socket(v14, v21, v19);
  if (v22 == -1)
    return 0;
  else
    return CFSocketCreateWithNative(allocator, v22, callBackTypes, callout, context);
}

CFSocketRef CFSocketCreateWithSocketSignature(CFAllocatorRef allocator, const CFSocketSignature *signature, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context)
{
  __CFSocket *v10;
  __CFSocket *v11;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v10 = CFSocketCreate(allocator, signature->protocolFamily, signature->socketType, signature->protocol, callBackTypes, callout, context);
  v11 = v10;
  if (v10 && (!CFSocketIsValid(v10) || CFSocketSetAddress(v11, signature->address)))
  {
    CFSocketInvalidate(v11);
    CFRelease(v11);
    return 0;
  }
  return v11;
}

CFSocketRef CFSocketCreateConnectedToSocketSignature(CFAllocatorRef allocator, const CFSocketSignature *signature, CFOptionFlags callBackTypes, CFSocketCallBack callout, const CFSocketContext *context, CFTimeInterval timeout)
{
  __CFSocket *v12;
  __CFSocket *v13;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v12 = CFSocketCreate(allocator, signature->protocolFamily, signature->socketType, signature->protocol, callBackTypes, callout, context);
  v13 = v12;
  if (v12 && (!CFSocketIsValid(v12) || CFSocketConnectToAddress(v13, signature->address, timeout)))
  {
    CFSocketInvalidate(v13);
    CFRelease(v13);
    return 0;
  }
  return v13;
}

CFSocketError CFSocketRegisterValue(const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, CFPropertyListRef value)
{
  __CFDictionary *Mutable;
  _QWORD *v10[3];
  CFSocketError v11;
  CFSocketSignature v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v10[2] = 0;
  v11 = kCFSocketError;
  v10[0] = &v11;
  v10[1] = 0;
  CFDictionaryAddValue(Mutable, CFSTR("Command"), CFSTR("Register"));
  CFDictionaryAddValue(Mutable, CFSTR("Name"), name);
  if (value)
    CFDictionaryAddValue(Mutable, CFSTR("Value"), value);
  memset(&v12, 0, sizeof(v12));
  __CFSocketValidateSignature((uint64_t)nameServerSignature, (uint64_t)&v12, (unsigned __int16)__CFSocketDefaultNameRegistryPortNumber);
  __CFSocketSendNameRegistryRequest(&v12, Mutable, v10, timeout);
  CFRelease(Mutable);
  CFRelease(v12.address);
  return v11;
}

void *__CFSocketValidateSignature(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6;
  int v7;
  int v8;
  int v9;
  const __CFData *v10;
  const UInt8 *BytePtr;
  __int16 v12;
  __int16 v13;
  int v14;
  void *result;
  UInt8 bytes[2];
  __int16 v17;
  int v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v19 = 0;
  *(_WORD *)bytes = 528;
  v17 = bswap32((unsigned __int16)__CFSocketDefaultNameRegistryPortNumber) >> 16;
  v18 = 16777343;
  if (!a1)
  {
    *(_QWORD *)a2 = 0x100000002;
    *(_DWORD *)(a2 + 8) = 6;
    goto LABEL_23;
  }
  v6 = *(_DWORD *)a1;
  *(_DWORD *)a2 = *(_DWORD *)a1;
  v7 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 4) = v7;
  v8 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 8) = v8;
  if (v6 <= 0)
  {
    *(_DWORD *)a2 = 2;
LABEL_7:
    if (v7 < 1)
    {
      *(_DWORD *)(a2 + 4) = 1;
      if (v8 >= 1)
        goto LABEL_15;
    }
    else
    {
      if (v8 >= 1)
        goto LABEL_15;
      if (v7 != 1)
      {
        if (v7 != 2)
          goto LABEL_15;
        v9 = 17;
        goto LABEL_14;
      }
    }
    v9 = 6;
LABEL_14:
    *(_DWORD *)(a2 + 8) = v9;
    goto LABEL_15;
  }
  if (v6 == 2)
    goto LABEL_7;
LABEL_15:
  v10 = *(const __CFData **)(a1 + 16);
  if (v10)
  {
    BytePtr = CFDataGetBytePtr(v10);
    if (CFDataGetLength(*(CFDataRef *)(a1 + 16)) < 16 || (BytePtr[1] | 2) != 2)
    {
      result = (void *)CFRetain(*(CFTypeRef *)(a1 + 16));
      goto LABEL_25;
    }
    *(_WORD *)bytes = 528;
    v12 = *((_WORD *)BytePtr + 1);
    v13 = __rev16(a3);
    if (!v12)
      v12 = v13;
    v17 = v12;
    v14 = *((_DWORD *)BytePtr + 1);
    if (!v14)
      v14 = 16777343;
    v18 = v14;
  }
LABEL_23:
  result = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes, 16);
LABEL_25:
  *(_QWORD *)(a2 + 16) = result;
  return result;
}

void __CFSocketSendNameRegistryRequest(const CFSocketSignature *a1, const void *a2, _QWORD **a3, CFTimeInterval a4)
{
  CFDataRef Data;
  const __CFData *v8;
  __CFSocket *v9;
  __CFSocket *v10;
  __CFRunLoopSource *RunLoopSource;
  __CFRunLoop *Current;
  CFSocketContext v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13.version = 0;
  memset(&v13.retain, 0, 24);
  v13.info = a3;
  if (*a3)
    **a3 = -1;
  Data = CFPropertyListCreateData((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, kCFPropertyListXMLFormat_v1_0, 0, 0);
  if (Data)
  {
    v8 = Data;
    if (*a3)
      **a3 = -2;
    v9 = CFSocketCreateConnectedToSocketSignature((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, 3uLL, (CFSocketCallBack)__CFSocketHandleNameRegistryReply, &v13, a4);
    if (v9)
    {
      v10 = v9;
      if (CFSocketSendData(v9, 0, v8, a4) == kCFSocketSuccess)
      {
        RunLoopSource = CFSocketCreateRunLoopSource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10, 0);
        Current = CFRunLoopGetCurrent();
        CFRunLoopAddSource(Current, RunLoopSource, CFSTR("CFSocketRegistryRequest"));
        CFRunLoopRunInMode(CFSTR("CFSocketRegistryRequest"), a4, 0);
        CFRelease(RunLoopSource);
      }
      CFSocketInvalidate(v10);
      CFRelease(v10);
    }
    CFRelease(v8);
  }
}

CFSocketError CFSocketCopyRegisteredValue(const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, CFPropertyListRef *value, CFDataRef *nameServerAddress)
{
  __CFDictionary *Mutable;
  _QWORD *v12[3];
  CFSocketError v13;
  CFSocketSignature v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  memset(&v14, 0, sizeof(v14));
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v12[2] = nameServerAddress;
  v13 = kCFSocketError;
  v12[0] = &v13;
  v12[1] = value;
  CFDictionaryAddValue(Mutable, CFSTR("Command"), CFSTR("Retrieve"));
  CFDictionaryAddValue(Mutable, CFSTR("Name"), name);
  __CFSocketValidateSignature((uint64_t)nameServerSignature, (uint64_t)&v14, (unsigned __int16)__CFSocketDefaultNameRegistryPortNumber);
  __CFSocketSendNameRegistryRequest(&v14, Mutable, v12, timeout);
  CFRelease(Mutable);
  CFRelease(v14.address);
  return v13;
}

CFSocketError CFSocketRegisterSocketSignature(const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, const CFSocketSignature *signature)
{
  const __CFData *v7;
  UInt8 v8;
  UInt8 v9;
  UInt8 v10;
  int32x4_t v11;
  __int16 v12;
  CFIndex Length;
  CFSocketError v14;
  CFIndex v16;
  __CFData *Mutable;
  const UInt8 *BytePtr;
  __int128 v19;
  CFDataRef theData;
  UInt8 bytes[4];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!signature)
    return CFSocketRegisterValue(nameServerSignature, timeout, name, 0);
  v19 = 0uLL;
  theData = 0;
  __CFSocketValidateSignature((uint64_t)signature, (uint64_t)&v19, 0);
  v7 = theData;
  v8 = v19;
  v9 = BYTE4(v19);
  v10 = BYTE8(v19);
  v11.i64[0] = __PAIR64__(v19, DWORD2(v19));
  v11.i64[1] = *(_QWORD *)((char *)&v19 + 4);
  v12 = vmovn_s32(vcgtq_s32(v11, (int32x4_t)xmmword_182C8B630)).u16[0];
  *(int16x4_t *)v11.i8 = vmovn_s32(vcgtq_s32((int32x4_t)xmmword_182C8B630, v11));
  v11.i16[0] = v12;
  if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(*(int16x4_t *)v11.i8, 0xFuLL))) & 1) != 0
    || (int)v19 > 255
    || !theData
    || SDWORD1(v19) > 255)
  {
    v14 = kCFSocketError;
    if (!theData)
      return v14;
  }
  else
  {
    Length = CFDataGetLength(theData);
    if ((unint64_t)(Length - 256) >= 0xFFFFFFFFFFFFFF01)
    {
      v16 = Length;
      Mutable = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Length + 4);
      bytes[0] = v8;
      bytes[1] = v9;
      bytes[2] = v10;
      bytes[3] = v16;
      CFDataAppendBytes(Mutable, bytes, 4);
      BytePtr = CFDataGetBytePtr(v7);
      CFDataAppendBytes(Mutable, BytePtr, v16);
      v14 = CFSocketRegisterValue(nameServerSignature, timeout, name, Mutable);
      CFRelease(Mutable);
    }
    else
    {
      v14 = kCFSocketError;
    }
  }
  CFRelease(v7);
  return v14;
}

CFSocketError CFSocketUnregister(const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name)
{
  return CFSocketRegisterValue(nameServerSignature, timeout, name, 0);
}

CFSocketError CFSocketCopyRegisteredSocketSignature(const CFSocketSignature *nameServerSignature, CFTimeInterval timeout, CFStringRef name, CFSocketSignature *signature, CFDataRef *nameServerAddress)
{
  CFSocketError v7;
  CFTypeID v8;
  const UInt8 *v9;
  const UInt8 *v10;
  CFIndex v11;
  const UInt8 *BytePtr;
  const UInt8 *v14;
  const UInt8 *v15;
  CFIndex Length;
  __CFData *MutableCopy;
  const __CFData *v18;
  CFTypeRef cf;
  uint64_t v20;
  uint64_t v21;
  CFTypeRef v22;
  CFPropertyListRef value[2];

  value[1] = *(CFPropertyListRef *)MEMORY[0x1E0C80C00];
  v22 = 0;
  value[0] = 0;
  v20 = 0;
  v21 = 0;
  cf = 0;
  v7 = CFSocketCopyRegisteredValue(nameServerSignature, timeout, name, value, (CFDataRef *)&cf);
  if (value[0])
  {
    v8 = CFGetTypeID(value[0]);
    if (v8 == CFDataGetTypeID()
      && (v9 = CFDataGetBytePtr((CFDataRef)value[0])) != 0
      && (v10 = v9, v11 = CFDataGetLength((CFDataRef)value[0]), v11 >= 4))
    {
      if (signature && v7 == kCFSocketSuccess)
      {
        LODWORD(v20) = *v10;
        HIDWORD(v20) = v10[1];
        LODWORD(v21) = v10[2];
        v22 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10 + 4, v11 - 4);
        __CFSocketValidateSignature((uint64_t)&v20, (uint64_t)signature, 0);
        CFRelease(v22);
        BytePtr = CFDataGetBytePtr(signature->address);
        if (CFDataGetLength(signature->address) >= 16 && BytePtr[1] == 2)
        {
          if (cf)
          {
            if (CFDataGetLength((CFDataRef)cf) >= 16)
            {
              v14 = CFDataGetBytePtr((CFDataRef)cf);
              if (v14)
              {
                v15 = v14;
                if (v14[1] == 2)
                {
                  Length = CFDataGetLength(signature->address);
                  MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Length, signature->address);
                  *((_DWORD *)CFDataGetMutableBytePtr(MutableCopy) + 1) = *((_DWORD *)v15 + 1);
                  CFRelease(signature->address);
                  signature->address = MutableCopy;
                }
              }
            }
          }
        }
        if (nameServerAddress)
        {
          v18 = (const __CFData *)cf;
          if (cf)
            v18 = (const __CFData *)CFRetain(cf);
          v7 = kCFSocketSuccess;
          *nameServerAddress = v18;
        }
        else
        {
          v7 = kCFSocketSuccess;
        }
      }
    }
    else
    {
      v7 = kCFSocketError;
    }
    if (value[0])
      CFRelease(value[0]);
  }
  else
  {
    v7 = kCFSocketError;
  }
  if (cf)
    CFRelease(cf);
  return v7;
}

void CFSocketSetDefaultNameRegistryPortNumber(UInt16 port)
{
  __CFSocketDefaultNameRegistryPortNumber = port;
}

UInt16 CFSocketGetDefaultNameRegistryPortNumber(void)
{
  return __CFSocketDefaultNameRegistryPortNumber;
}

uint64_t _CFSocketGetThread()
{
  return __CFSocketManagerThread;
}

void __CFSocketHandleNameRegistryReply(__CFSocket *a1, int a2, const __CFData *a3, CFDataRef data, uint64_t a5)
{
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  CFTypeID v10;
  const void *Value;
  CFDataRef *v12;
  CFDataRef Copy;

  v8 = (const __CFDictionary *)CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, data, 0, 0, 0);
  v9 = v8;
  if (*(_QWORD *)a5)
    **(_QWORD **)a5 = -1;
  if (v8)
  {
    v10 = CFGetTypeID(v8);
    if (v10 == CFDictionaryGetTypeID())
    {
      Value = CFDictionaryGetValue(v9, CFSTR("Result"));
      if (Value)
      {
        if (*(_QWORD *)a5)
          **(_QWORD **)a5 = 0;
        if (*(_QWORD *)(a5 + 8))
          **(_QWORD **)(a5 + 8) = CFRetain(Value);
        v12 = *(CFDataRef **)(a5 + 16);
        if (v12)
        {
          if (a3)
          {
            Copy = CFDataCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a3);
            v12 = *(CFDataRef **)(a5 + 16);
          }
          else
          {
            Copy = 0;
          }
          *v12 = Copy;
        }
      }
    }
    CFRelease(v9);
  }
  CFSocketInvalidate(a1);
}

uint64_t __CFDateIntervalFormatterDeallocate(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  uint64_t result;

  v2 = (const void *)a1[2];
  if (v2)
    CFRelease(v2);
  v3 = (const void *)a1[3];
  if (v3)
    CFRelease(v3);
  v4 = (const void *)a1[4];
  if (v4)
    CFRelease(v4);
  v5 = (const void *)a1[5];
  if (v5)
    CFRelease(v5);
  v6 = (const void *)a1[6];
  if (v6)
    CFRelease(v6);
  result = a1[7];
  if (result)
    return udtitvfmt_close();
  return result;
}

uint64_t CFDateIntervalFormatterCreate(__objc2_class **a1, const void *a2, unint64_t a3, unint64_t a4)
{
  uint64_t Instance;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef v11;

  if (!a1)
  {
    a1 = (__objc2_class **)_CFGetTSD(1u);
    if (!a1)
      a1 = &__kCFAllocatorSystemDefault;
  }
  Instance = _CFRuntimeCreateInstance(a1, 0x45uLL, 80, 0);
  v8 = Instance;
  if (Instance)
  {
    v9 = 2;
    if (a3 >= 5)
      v10 = 2;
    else
      v10 = a3;
    if (a4 < 5)
      v9 = a4;
    *(_QWORD *)(Instance + 64) = v10;
    *(_QWORD *)(Instance + 72) = v9;
    if (a2)
      v11 = CFRetain(a2);
    else
      v11 = 0;
    *(_QWORD *)(v8 + 16) = v11;
    *(_QWORD *)(v8 + 24) = 0;
    *(_QWORD *)(v8 + 32) = 0;
    *(_QWORD *)(v8 + 40) = 0;
    *(_QWORD *)(v8 + 48) = CFRetain(&stru_1E1337B18);
    *(_QWORD *)(v8 + 56) = 0;
    *(_QWORD *)(v8 + 80) = 0;
    *(_DWORD *)(v8 + 88) = 0;
    *(_BYTE *)(v8 + 92) &= 0xFCu;
  }
  return v8;
}

void _CFDateIntervalFormatterInitializeFromCoderValues(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, const void *a5, int a6, int a7, const void *a8, const void *a9, const void *a10)
{
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  os_unfair_lock_s *lock;

  lock = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(_QWORD *)(a1 + 64) = a2;
  *(_QWORD *)(a1 + 72) = a3;
  v18 = *(const void **)(a1 + 48);
  if (v18 != a4)
  {
    if (v18)
      CFRelease(v18);
    if (a4)
      CFRetain(a4);
    *(_QWORD *)(a1 + 48) = a4;
  }
  v19 = *(const void **)(a1 + 40);
  if (v19 != a5)
  {
    if (v19)
      CFRelease(v19);
    if (a5)
      CFRetain(a5);
    *(_QWORD *)(a1 + 40) = a5;
  }
  *(_BYTE *)(a1 + 92) = (a6 != 0) | (2 * (a7 != 0)) | *(_BYTE *)(a1 + 92) & 0xFC;
  v20 = *(const void **)(a1 + 16);
  if (v20 != a8)
  {
    if (v20)
      CFRelease(v20);
    if (a8)
      CFRetain(a8);
    *(_QWORD *)(a1 + 16) = a8;
  }
  v21 = *(const void **)(a1 + 24);
  if (v21 != a9)
  {
    if (v21)
      CFRelease(v21);
    if (a9)
      CFRetain(a9);
    *(_QWORD *)(a1 + 24) = a9;
  }
  v22 = *(const void **)(a1 + 32);
  if (v22 != a10)
  {
    if (v22)
      CFRelease(v22);
    if (a10)
      CFRetain(a10);
    *(_QWORD *)(a1 + 32) = a10;
  }
  os_unfair_lock_unlock(lock);
}

void _CFDateIntervalFormatterCopyCoderValues(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, _BYTE *a6, BOOL *a7, _QWORD *a8, _QWORD *a9, _QWORD *a10)
{
  os_unfair_lock_s *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const void *v24;

  v18 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v19 = *(_QWORD *)(a1 + 72);
  *a2 = *(_QWORD *)(a1 + 64);
  *a3 = v19;
  v20 = *(_QWORD *)(a1 + 48);
  if (v20)
    CFRetain(*(CFTypeRef *)(a1 + 48));
  *a4 = v20;
  v21 = *(_QWORD *)(a1 + 40);
  if (v21)
    CFRetain(*(CFTypeRef *)(a1 + 40));
  *a5 = v21;
  *a6 = *(_BYTE *)(a1 + 92) & 1;
  *a7 = (*(_BYTE *)(a1 + 92) & 2) != 0;
  v22 = *(_QWORD *)(a1 + 16);
  if (v22)
    CFRetain(*(CFTypeRef *)(a1 + 16));
  *a8 = v22;
  v23 = *(_QWORD *)(a1 + 24);
  if (v23)
    CFRetain(*(CFTypeRef *)(a1 + 24));
  *a9 = v23;
  v24 = *(const void **)(a1 + 32);
  if (v24)
    CFRetain(v24);
  *a10 = v24;
  os_unfair_lock_unlock(v18);
}

uint64_t CFDateIntervalFormatterCreateCopy(__objc2_class **a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  void *v6;
  const void *v7;
  const __CFString *v8;
  const __CFString *v9;
  char v10;

  v4 = _CFGetNonObjCTypeID((unint64_t *)a2);
  if (v4 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 88));
  v5 = CFDateIntervalFormatterCreate(a1, *(const void **)(a2 + 16), *(_QWORD *)(a2 + 64), *(_QWORD *)(a2 + 72));
  v6 = *(void **)(a2 + 24);
  if (v6)
    *(_QWORD *)(v5 + 24) = _CFCalendarCreateCopy((uint64_t)a1, v6);
  v7 = *(const void **)(a2 + 32);
  if (v7)
    *(_QWORD *)(v5 + 32) = CFRetain(v7);
  v8 = *(const __CFString **)(a2 + 40);
  if (v8)
    *(_QWORD *)(v5 + 40) = CFStringCreateCopy((CFAllocatorRef)a1, v8);
  v9 = *(const __CFString **)(a2 + 48);
  if (v9)
    *(_QWORD *)(v5 + 48) = CFStringCreateCopy((CFAllocatorRef)a1, v9);
  *(_OWORD *)(v5 + 64) = *(_OWORD *)(a2 + 64);
  v10 = *(_BYTE *)(v5 + 92) & 0xFE | *(_BYTE *)(a2 + 92) & 1;
  *(_BYTE *)(v5 + 92) = v10;
  *(_BYTE *)(v5 + 92) = v10 & 0xFD | *(_BYTE *)(a2 + 92) & 2;
  os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 88));
  return v5;
}

CFLocaleRef CFDateIntervalFormatterCopyLocale(uint64_t a1)
{
  unint64_t v2;
  os_unfair_lock_s *v3;
  const void *v4;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v4 = *(const void **)(a1 + 16);
  if (v4)
  {
    CFRetain(v4);
    os_unfair_lock_unlock(v3);
    return (CFLocaleRef)v4;
  }
  else
  {
    os_unfair_lock_unlock(v3);
    return CFLocaleCopyCurrent();
  }
}

void CFDateIntervalFormatterSetLocale(uint64_t a1, const __CFLocale *a2)
{
  unint64_t v4;
  const __CFLocale *v5;
  CFLocaleRef Copy;

  v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v5 = *(const __CFLocale **)(a1 + 16);
  if (v5 != a2)
  {
    if (v5)
      CFRelease(v5);
    if (a2)
      Copy = CFLocaleCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
    else
      Copy = 0;
    *(_QWORD *)(a1 + 16) = Copy;
    *(_BYTE *)(a1 + 92) |= 1u;
    updateDateTemplateFromCurrentSettings((_QWORD *)a1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

void updateDateTemplateFromCurrentSettings(_QWORD *a1)
{
  CFDateFormatterStyle v2;
  CFDateFormatterStyle v3;
  const void *v4;
  const __CFLocale *v5;
  const __CFLocale *v6;
  CFTypeRef Value;
  __CFDateFormatter *v8;
  const __CFString *Format;
  const void *v10;

  v2 = a1[8];
  v3 = a1[9];
  v4 = (const void *)a1[2];
  if (v4)
    v5 = (const __CFLocale *)CFRetain(v4);
  else
    v5 = CFLocaleCopyCurrent();
  v6 = v5;
  Value = (CFTypeRef)a1[3];
  if (!Value)
    Value = CFLocaleGetValue(v5, CFSTR("kCFLocaleCalendarKey"));
  v8 = CFDateFormatterCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6, v2, v3);
  CFDateFormatterSetProperty(v8, CFSTR("kCFDateFormatterCalendarKey"), Value);
  CFRelease(v6);
  Format = CFDateFormatterGetFormat(v8);
  v10 = (const void *)a1[5];
  if (v10)
    CFRelease(v10);
  a1[5] = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Format);
  CFRelease(v8);
}

CFCalendarRef CFDateIntervalFormatterCopyCalendar(uint64_t a1)
{
  unint64_t v2;
  CFCalendarRef v3;
  __CFCalendar *Value;
  const __CFLocale *v5;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v3 = *(CFCalendarRef *)(a1 + 24);
  if (v3)
  {
    Value = *(__CFCalendar **)(a1 + 24);
  }
  else
  {
    v5 = *(const __CFLocale **)(a1 + 16);
    if (!v5)
    {
      v3 = CFCalendarCopyCurrent();
      goto LABEL_7;
    }
    Value = (__CFCalendar *)CFLocaleGetValue(v5, CFSTR("kCFLocaleCalendarKey"));
    v3 = Value;
  }
  CFRetain(Value);
LABEL_7:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
  return v3;
}

void CFDateIntervalFormatterSetCalendar(uint64_t a1, void *a2)
{
  unint64_t v4;
  const void *v5;
  uint64_t Copy;

  v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v5 = *(const void **)(a1 + 24);
  if (v5 != a2)
  {
    if (v5)
      CFRelease(v5);
    if (a2)
      Copy = _CFCalendarCreateCopy((uint64_t)&__kCFAllocatorSystemDefault, a2);
    else
      Copy = 0;
    *(_QWORD *)(a1 + 24) = Copy;
    *(_BYTE *)(a1 + 92) |= 1u;
    updateDateTemplateFromCurrentSettings((_QWORD *)a1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

CFTimeZoneRef CFDateIntervalFormatterCopyTimeZone(uint64_t a1)
{
  unint64_t v2;
  os_unfair_lock_s *v3;
  const void *v4;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v4 = *(const void **)(a1 + 32);
  if (v4)
  {
    CFRetain(v4);
    os_unfair_lock_unlock(v3);
    return (CFTimeZoneRef)v4;
  }
  else
  {
    os_unfair_lock_unlock(v3);
    return CFTimeZoneCopyDefault();
  }
}

void CFDateIntervalFormatterSetTimeZone(uint64_t a1, const void *a2)
{
  unint64_t v4;
  const void *v5;
  CFTypeRef v6;

  v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v5 = *(const void **)(a1 + 32);
  if (v5 != a2)
  {
    if (v5)
      CFRelease(v5);
    if (a2)
      v6 = CFRetain(a2);
    else
      v6 = 0;
    *(_QWORD *)(a1 + 32) = v6;
    *(_BYTE *)(a1 + 92) |= 1u;
    updateDateTemplateFromCurrentSettings((_QWORD *)a1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

const void *CFDateIntervalFormatterCopyDateTemplate(uint64_t a1)
{
  unint64_t v2;
  const void *v3;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v3 = *(const void **)(a1 + 48);
  if (v3 || (v3 = *(const void **)(a1 + 40)) != 0)
    CFRetain(v3);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
  return v3;
}

void CFDateIntervalFormatterSetDateTemplate(uint64_t a1, const __CFString *a2)
{
  unint64_t v4;
  const __CFString *v5;
  const void *v6;

  v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  if (a2)
    v5 = a2;
  else
    v5 = &stru_1E1337B18;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  if (!CFEqual(v5, *(CFTypeRef *)(a1 + 48)))
  {
    v6 = *(const void **)(a1 + 48);
    if (v6)
      CFRelease(v6);
    *(_QWORD *)(a1 + 48) = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5);
    *(_BYTE *)(a1 + 92) |= 3u;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

uint64_t CFDateIntervalFormatterGetDateStyle(uint64_t a1)
{
  unint64_t v2;
  os_unfair_lock_s *v3;
  uint64_t v4;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v4 = *(_QWORD *)(a1 + 64);
  os_unfair_lock_unlock(v3);
  return v4;
}

void CFDateIntervalFormatterSetDateStyle(uint64_t a1, uint64_t a2)
{
  unint64_t v4;

  v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(_QWORD *)(a1 + 64) = a2;
  *(_BYTE *)(a1 + 92) = *(_BYTE *)(a1 + 92) & 0xFC | 1;
  updateDateTemplateFromCurrentSettings((_QWORD *)a1);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

uint64_t CFDateIntervalFormatterGetTimeStyle(uint64_t a1)
{
  unint64_t v2;
  os_unfair_lock_s *v3;
  uint64_t v4;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v4 = *(_QWORD *)(a1 + 72);
  os_unfair_lock_unlock(v3);
  return v4;
}

void CFDateIntervalFormatterSetTimeStyle(uint64_t a1, uint64_t a2)
{
  unint64_t v4;

  v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(_QWORD *)(a1 + 72) = a2;
  *(_BYTE *)(a1 + 92) = *(_BYTE *)(a1 + 92) & 0xFC | 1;
  updateDateTemplateFromCurrentSettings((_QWORD *)a1);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

uint64_t _CFDateIntervalFormatterGetBoundaryStyle(uint64_t a1)
{
  unint64_t v2;
  os_unfair_lock_s *v3;
  uint64_t v4;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v2);
  v3 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v4 = *(_QWORD *)(a1 + 80);
  os_unfair_lock_unlock(v3);
  return v4;
}

void _CFDateIntervalFormatterSetBoundaryStyle(uint64_t a1, uint64_t a2)
{
  unint64_t v4;

  v4 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v4 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v4);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  *(_QWORD *)(a1 + 80) = a2;
  *(_BYTE *)(a1 + 92) |= 1u;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 88));
}

CFStringRef CFDateIntervalFormatterCreateStringFromDateToDate(uint64_t a1, const __CFDate *a2, const __CFDate *a3)
{
  unint64_t v6;
  os_unfair_lock_s *v7;
  uint64_t v8;
  const __CFLocale *v9;
  CFTypeRef Value;
  const __CFString *Identifier;
  const __CFDictionary *ComponentsFromLocaleIdentifier;
  __CFDictionary *MutableCopy;
  const __CFString *LocaleIdentifierFromComponents;
  const __CFTimeZone *v15;
  const __CFString *Name;
  CFRange v17;
  uint64_t v18;
  const __CFString *v19;
  CFRange v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  UniChar *v29;
  int v30;
  CFStringRef v31;
  UniChar chars[8];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  _OWORD v46[12];
  uint64_t v47;
  _OWORD buffer[6];
  int v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v6 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v6 != 69)
    _CFAssertMismatchedTypeID(0x45uLL, v6);
  v7 = (os_unfair_lock_s *)(a1 + 88);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 88));
  v8 = *(_QWORD *)(a1 + 56);
  if ((*(_BYTE *)(a1 + 92) & 1) != 0)
  {
    if (v8)
    {
      udtitvfmt_close();
      *(_QWORD *)(a1 + 56) = 0;
      *(_BYTE *)(a1 + 92) &= ~1u;
    }
  }
  else if (v8)
  {
    goto LABEL_29;
  }
  v9 = *(const __CFLocale **)(a1 + 16);
  if (v9)
    CFRetain(*(CFTypeRef *)(a1 + 16));
  else
    v9 = CFLocaleCopyCurrent();
  Value = *(CFTypeRef *)(a1 + 24);
  if (!Value)
    Value = CFLocaleGetValue(v9, CFSTR("kCFLocaleCalendarKey"));
  Identifier = CFLocaleGetIdentifier(v9);
  ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier((CFAllocatorRef)&__kCFAllocatorSystemDefault, Identifier);
  MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, ComponentsFromLocaleIdentifier);
  CFRelease(ComponentsFromLocaleIdentifier);
  if (Value)
    CFDictionarySetValue(MutableCopy, CFSTR("kCFLocaleCalendarKey"), Value);
  LocaleIdentifierFromComponents = CFLocaleCreateLocaleIdentifierFromComponents((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy);
  CFRelease(MutableCopy);
  v49 = 0;
  memset(buffer, 0, sizeof(buffer));
  CFStringGetCString(LocaleIdentifierFromComponents, (char *)buffer, 100, 0x8000100u);
  CFRelease(LocaleIdentifierFromComponents);
  v45 = 0;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  *(_OWORD *)chars = 0u;
  v34 = 0u;
  v15 = *(const __CFTimeZone **)(a1 + 32);
  if (v15)
    CFRetain(*(CFTypeRef *)(a1 + 32));
  else
    v15 = CFTimeZoneCopyDefault();
  Name = CFTimeZoneGetName(v15);
  if (CFStringGetLength(Name) > 99)
    v17.length = 100;
  else
    v17.length = CFStringGetLength(Name);
  v17.location = 0;
  CFStringGetCharacters(Name, v17, chars);
  v18 = 48;
  if ((*(_BYTE *)(a1 + 92) & 2) == 0)
    v18 = 40;
  v19 = *(const __CFString **)(a1 + v18);
  v47 = 0;
  memset(v46, 0, sizeof(v46));
  if (CFStringGetLength(v19) > 99)
    v20.length = 100;
  else
    v20.length = CFStringGetLength(v19);
  v20.location = 0;
  CFStringGetCharacters(v19, v20, (UniChar *)v46);
  CFStringGetLength(v19);
  CFStringGetLength(Name);
  v21 = udtitvfmt_open();
  *(_QWORD *)(a1 + 56) = v21;
  if (v21
    || (u_errorName(U_ZERO_ERROR),
        CFLog(3, (uint64_t)CFSTR("udtitvfmt_open failed!  Formatter is NULL! -- locale: %s, template: %@, timezone: %@, status: %s"), v22, v23, v24, v25, v26, v27, (__int16)buffer), *(_QWORD *)(a1 + 56)))
  {
    udtitvfmt_setAttribute();
  }
  CFRelease(v9);
  CFRelease(v15);
  if (!*(_QWORD *)(a1 + 56))
  {
    v31 = &stru_1E1337B18;
    goto LABEL_33;
  }
LABEL_29:
  CFDateGetAbsoluteTime(a2);
  CFDateGetAbsoluteTime(a3);
  bzero(chars, 0x7D0uLL);
  LODWORD(v46[0]) = 0;
  v28 = udtitvfmt_format();
  if (v28 < 1001)
  {
    v31 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, chars, v28);
  }
  else
  {
    v29 = (UniChar *)malloc_type_calloc(v28, 2uLL, 0x1000040BDFB0063uLL);
    LODWORD(v46[0]) = 0;
    v30 = udtitvfmt_format();
    v31 = CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v29, v30);
    free(v29);
  }
LABEL_33:
  os_unfair_lock_unlock(v7);
  return v31;
}

CFStringRef CFDateIntervalFormatterCreateStringFromDateInterval(uint64_t a1, uint64_t a2)
{
  const __CFDate *started;
  const __CFDate *v5;
  CFStringRef StringFromDateToDate;

  started = (const __CFDate *)CFDateIntervalCopyStartDate(a2);
  v5 = CFDateIntervalCopyEndDate(a2);
  StringFromDateToDate = CFDateIntervalFormatterCreateStringFromDateToDate(a1, started, v5);
  CFRelease(started);
  CFRelease(v5);
  return StringFromDateToDate;
}

uint64_t _CFBundleGetLanguageCodeForLocalization(const __CFString *a1)
{
  CFIndex Length;
  CFIndex v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  BOOL v7;
  BOOL v8;
  uint64_t result;
  unint64_t v11;
  BOOL v12;
  char buffer[8];
  char v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  if ((unint64_t)(Length - 2) > 0xFD)
    return 0xFFFFFFFFLL;
  v3 = Length;
  if (!CFStringGetCString(a1, buffer, 255, 0x600u))
    return 0xFFFFFFFFLL;
  v4 = 0;
  v14 = 0;
  do
  {
    v5 = v4;
    v6 = strcmp(buffer, __CFBundleLanguageNamesArray[v4]);
    if (!v6)
      break;
    v4 = v5 + 1;
  }
  while (v5 < 0x97);
  v7 = *(_DWORD *)buffer == 1415538810 && *(unsigned __int16 *)&buffer[4] == 87;
  if (v7 || *(_QWORD *)buffer == 0x746E61482D687ALL)
    return 19;
  v8 = *(_DWORD *)buffer == 1130326138 && *(unsigned __int16 *)&buffer[4] == 78;
  result = 33;
  if (!v8)
  {
    result = *(_QWORD *)buffer == 0x736E61482D687ALL ? 33 : v5;
    if (*(_QWORD *)buffer != 0x736E61482D687ALL && v6)
    {
      if (v3 != 2)
      {
        if (buffer[2] < 0
           ? __maskrune(buffer[2], 0x100uLL)
           : *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * buffer[2] + 60) & 0x100)
        {
          return 0xFFFFFFFFLL;
        }
      }
      if (buffer[0] == 110 && buffer[1] == 111)
      {
        return 9;
      }
      else
      {
        v11 = 0;
        result = 0xFFFFFFFFLL;
        while (buffer[0] != byte_182C8B8E7[v11] || buffer[1] != byte_182C8B8E7[v11 + 1])
        {
          v12 = v11 >= 0x1C5;
          v11 += 3;
          if (v12)
            return result;
        }
        return (unsigned __int16)v11 / 3u;
      }
    }
  }
  return result;
}

uint64_t _CFBundleGetRegionCodeForLocalization(const __CFString *a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t result;
  BOOL v5;
  unsigned int LanguageCodeForLocalization;
  char buffer[6];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(CFStringGetLength(a1) - 2) > 3 || !CFStringGetCString(a1, buffer, 6, 0x600u))
    goto LABEL_14;
  v2 = 0;
  buffer[5] = 0;
  v3 = __CFBundleLocaleAbbreviationsArray;
  do
  {
    if (!strcmp(buffer, (const char *)(v3 + v2)))
      result = (unsigned __int16)v2 / 6u;
    else
      result = 0xFFFFFFFFLL;
    if ((_DWORD)result != -1)
      break;
    v5 = v2 >= 0x288;
    v2 += 6;
  }
  while (!v5);
  if ((int)result <= 27)
  {
    if ((_DWORD)result != -1)
    {
      if ((_DWORD)result == 25)
        return 68;
      return result;
    }
LABEL_14:
    LanguageCodeForLocalization = _CFBundleGetLanguageCodeForLocalization(a1);
    return _CFBundleGetRegionCodeForLanguageCode(LanguageCodeForLocalization);
  }
  if ((_DWORD)result == 28)
    return 82;
  if ((_DWORD)result == 37)
    return 0;
  return result;
}

uint64_t _CFBundleGetLanguageCodeForRegionCode(unsigned int a1)
{
  unsigned __int8 *v2;
  unint64_t i;

  if (a1 == 52)
    return 33;
  if (a1 > 0x6C)
    return 0xFFFFFFFFLL;
  if (!__CFBundleLocaleAbbreviationsArray)
    return 0xFFFFFFFFLL;
  v2 = (unsigned __int8 *)(__CFBundleLocaleAbbreviationsArray + 6 * a1);
  if (!*v2)
    return 0xFFFFFFFFLL;
  for (i = 0; *v2 != byte_182C8B8E7[i] || v2[1] != byte_182C8B8E7[i + 1]; i += 3)
  {
    if (i >= 0x1C5)
      return 0xFFFFFFFFLL;
  }
  return (unsigned __int16)i / 3u;
}

uint64_t _CFBundleGetRegionCodeForLanguageCode(unsigned int a1)
{
  char *v2;
  unint64_t v3;
  BOOL v4;
  unsigned int v5;

  if (a1 == 19)
    return 53;
  if (a1 > 0x97)
    return 0xFFFFFFFFLL;
  v2 = &byte_182C8B8E7[3 * a1];
  if (!*v2)
    return 0xFFFFFFFFLL;
  v3 = 0;
  while (*(unsigned __int8 *)(__CFBundleLocaleAbbreviationsArray + v3) != *v2
       || *(unsigned __int8 *)(__CFBundleLocaleAbbreviationsArray + v3 + 1) != v2[1])
  {
    v4 = v3 >= 0x288;
    v3 += 6;
    if (v4)
    {
      v5 = -1;
      goto LABEL_11;
    }
  }
  if ((unsigned __int16)v3 - 150 < 6)
    return 68;
  v5 = (unsigned __int16)v3 / 6;
LABEL_11:
  if (v5 == 28)
    return 82;
  else
    return v5;
}

CFStringRef _CFBundleCopyLanguageAbbreviationForLanguageCode(unsigned int a1)
{
  const char *v1;

  if (a1 <= 0x97 && (v1 = &byte_182C8B8E7[3 * a1], *v1))
    return CFStringCreateWithCStringNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull);
  else
    return 0;
}

CFArrayRef CFBundleCopyLocalizationsForURL(CFURLRef url)
{
  CFBundleRef v2;
  int32x4_t v3;
  CFBundleRef v4;
  const __CFArray *v5;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const void *Value;
  const void *v10;
  CFTypeID v11;
  const __CFString *v12;
  const __CFString *v13;
  CFTypeID v14;
  const void *v15[2];

  v15[1] = *(const void **)MEMORY[0x1E0C80C00];
  v2 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, url);
  v15[0] = 0;
  if (v2)
  {
    v4 = v2;
    v5 = (const __CFArray *)_CFBundleCopyBundleLocalizations((uint64_t)v2, 0);
    CFRelease(v4);
    return v5;
  }
  else
  {
    v7 = _CFBundleCopyInfoDictionaryInExecutable(url, v3);
    if (!v7)
      return 0;
    v8 = v7;
    Value = CFDictionaryGetValue(v7, CFSTR("CFBundleLocalizations"));
    if (!Value
      || (v10 = Value, v11 = CFGetTypeID(Value), v11 != CFArrayGetTypeID())
      || (v12 = (const __CFString *)CFRetain(v10)) == 0)
    {
      v12 = (const __CFString *)_copyAppleLocalizations(v8);
      if (!v12)
      {
        v13 = (const __CFString *)CFDictionaryGetValue(v8, CFSTR("CFBundleDevelopmentRegion"));
        v12 = v13;
        v15[0] = v13;
        if (v13)
        {
          v14 = CFGetTypeID(v13);
          if (v14 == CFStringGetTypeID() && CFStringGetLength(v12) >= 1)
            v12 = (const __CFString *)CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, 1, &kCFTypeArrayCallBacks);
          else
            v12 = 0;
        }
      }
    }
    CFRelease(v8);
    return (CFArrayRef)v12;
  }
}

void _CFBundleFlushLanguageCachesAfterEUIDChange()
{
  CFBundleRef MainBundle;

  MainBundle = CFBundleGetMainBundle();
  _CFBundleFlushBundleCaches((uint64_t)MainBundle);
  _CFLocaleResetCurrent();
  os_unfair_lock_lock((os_unfair_lock_t)&_CFBundleUserLanguagesLock);
  if (_CFBundleUserLanguages)
  {
    CFRelease((CFTypeRef)_CFBundleUserLanguages);
    _CFBundleUserLanguages = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleUserLanguagesLock);
}

void _CFBundleSetDefaultLocalization(CFStringRef theString)
{
  CFStringRef Copy;

  if (theString)
    Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
  else
    Copy = 0;
  if (_defaultLocalization)
    CFRelease((CFTypeRef)_defaultLocalization);
  _defaultLocalization = (uint64_t)Copy;
}

const char *PROEM_SEL_1(const char *a1)
{
  if (a1)
    return sel_getName(a1);
  else
    return "(null selector)";
}

uint64_t comparisonUsingOrderingForNumericKeys(void **a1, void **a2)
{
  void *v2;

  v2 = *a1;
  if (v2 == *a2)
    return 0;
  else
    return objc_msgSend(v2, "compare:");
}

uint64_t __CFURLComponentsEqual(void *a1, uint64_t a2)
{
  return objc_msgSend(a1, "isEqual:", a2);
}

id __CFURLComponentsCopyDescription(void *a1)
{
  return (id)objc_msgSend(a1, "debugDescription");
}

uint64_t _CFURLComponentsGetTypeID()
{
  return 30;
}

id _CFURLComponentsCreateWithString(uint64_t a1, uint64_t a2)
{
  return (id)+[NSURLComponents _componentsWithString:encodingInvalidCharacters:](&off_1EDCDC9E8, "_componentsWithString:encodingInvalidCharacters:", a2, 1);
}

id _CFURLComponentsCopyUser(void *a1)
{
  return (id)objc_msgSend(a1, "user");
}

id _CFURLComponentsCopyPassword(void *a1)
{
  return (id)objc_msgSend(a1, "password");
}

uint64_t _CFURLComponentsSetUser(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setUser:", a2);
  return 1;
}

uint64_t _CFURLComponentsSetPassword(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setPassword:", a2);
  return 1;
}

id _CFURLComponentsCopyEncodedHost(void *a1)
{
  return (id)objc_msgSend(a1, "encodedHost");
}

uint64_t _CFURLComponentsSetPercentEncodedUser(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setPercentEncodedUser:", a2);
  return 1;
}

void sub_182BD03C0(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
  JUMPOUT(0x182BD03B8);
}

uint64_t _CFURLComponentsSetPercentEncodedPassword(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setPercentEncodedPassword:", a2);
  return 1;
}

