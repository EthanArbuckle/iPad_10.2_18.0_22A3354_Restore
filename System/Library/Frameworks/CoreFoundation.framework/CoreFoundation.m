void *_CFPredicatePolicyData()
{
  return &_CFPredicatePolicyData__cfpredicateelements;
}

__objc2_class **_CFPredicatePolicyRestrictedClasses()
{
  return &off_1E1488A08;
}

uint64_t _CFLocaleGetNoteCount()
{
  return __noteCount;
}

uint64_t _CFTimeZoneGetNoteCount()
{
  return __noteCount_0;
}

__objc2_class **_CFPredicatePolicyRestrictedSelectors()
{
  return &off_1E1488A30;
}

uint64_t _CFCalendarGetMidnightNoteCount()
{
  __dmb(0xBu);
  return __CFMidnightNoteCount;
}

_BYTE *__NSDictionaryI_new(uint64_t *a1, uint64_t *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  unint64_t v6;
  uint64_t v10;
  uint64_t v11;
  objc_class *v12;
  _BYTE *v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  _QWORD v21[2];
  void (*v22)(_QWORD *, uint64_t, uint64_t);
  void *v23;
  _BYTE *v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;

  v6 = a4;
  v10 = 0;
  v29 = *MEMORY[0x1E0C80C00];
  v28 = a3;
  while (__NSDictionaryCapacities[v10] < a4)
  {
    if (++v10 == 64)
    {
      __break(1u);
      break;
    }
  }
  v11 = __NSDictionarySizes[v10];
  v12 = (objc_class *)objc_opt_self();
  v13 = __CFAllocateObject(v12, 16 * v11);
  v14 = v13;
  v13[15] = v13[15] & 3 | (4 * v10);
  *((_QWORD *)v13 + 1) = *((_QWORD *)v13 + 1) & 0xFE00000000000000 | v6 & 0x1FFFFFFFFFFFFFFLL;
  v13[15] = v13[15] & 0xFD | a5 & 2;
  if (v6)
  {
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 3221225472;
    v22 = ____NSDictionaryI_new_block_invoke;
    v23 = &unk_1E12E13A0;
    v26 = v11;
    v27 = a5;
    v24 = v13;
    v25 = v13 + 16;
    if (a3)
    {
      v15 = *a1;
      v16 = v28++;
      ____NSDictionaryI_new_block_invoke(v21, *v16, v15);
      if (v6 >= 2)
      {
        v17 = v6 - 1;
        do
        {
          v18 = v28++;
          v19 = *v18;
          v28 = v18 + 2;
          v22(v21, v18[1], v19);
          --v17;
        }
        while (v17);
      }
    }
    else
    {
      do
      {
        v22(v21, *a1++, *a2++);
        --v6;
      }
      while (v6);
    }
  }
  return v14;
}

void sub_182A8E730(_Unwind_Exception *exception_object, int a2)
{
  void *v2;

  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    if (v2)

    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

unint64_t *_CFNonObjCRetain(unint64_t *a1)
{
  return _CFRetain(a1, 0);
}

void mdict_rehashd(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;

  if (a2 >= 0x28)
  {
    __break(1u);
  }
  else
  {
    v3 = LODWORD(__NSDictionarySizes_0[a2]);
    v4 = malloc_type_calloc(1uLL, 16 * v3, 0x6B90FCE3uLL);
    v18 = a1;
    v5 = *(_QWORD **)(a1 + 8);
    v6 = *(_QWORD *)(a1 + 16) >> 58;
    if (v6)
    {
      v7 = 0;
      v8 = LODWORD(__NSDictionarySizes_0[v6]);
      if (v3 <= 1)
        v9 = 1;
      else
        v9 = v3;
      do
      {
        v10 = (void *)v5[v7];
        if (v10)
          v11 = v10 == &___NSDictionaryM_DeletedMarker;
        else
          v11 = 1;
        if (!v11)
        {
          v12 = objc_msgSend((id)v5[v7], "hash");
          if (!a2)
            goto LABEL_22;
          v13 = v12 % v3;
          v14 = v9;
          while (v4[v13])
          {
            v15 = v13 + 1;
            if (v15 >= v3)
              v16 = v3;
            else
              v16 = 0;
            v13 = v15 - v16;
            if (!--v14)
              goto LABEL_22;
          }
          if (v13 == 0x7FFFFFFFFFFFFFFFLL)
LABEL_22:
            __NSMUTABLEDICTIONARY_CONCURRENT_MODIFICATION_DETECTED__();
          v4[v13] = v10;
          v4[v3 + v13] = v5[v8 + v7];
        }
        ++v7;
      }
      while (v7 != v8);
    }
    free(v5);
    v17 = *(_QWORD *)(v18 + 16) & 0x3FFFFFFFFFFFFFFLL | ((unint64_t)a2 << 58);
    *(_QWORD *)(v18 + 8) = v4;
    *(_QWORD *)(v18 + 16) = v17;
  }
}

uint64_t __CFStringHash(uint64_t a1)
{
  char v1;
  unsigned __int16 **v2;
  unsigned __int16 *v3;
  char v4;
  char v5;
  uint64_t v6;
  char v7;
  char v8;
  unint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  unint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  unint64_t v24;
  unsigned __int16 *v25;
  uint64_t i;
  unsigned __int16 *v27;
  unsigned __int16 *v28;
  unsigned int v29;
  unsigned int v30;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  v2 = (unsigned __int16 **)(a1 + 16);
  if ((v1 & 0x60) != 0)
  {
    v3 = *v2;
  }
  else
  {
    v4 = atomic_load((unint64_t *)(a1 + 8));
    v3 = (unsigned __int16 *)&v2[(v4 & 5) != 4];
  }
  v5 = atomic_load((unint64_t *)(a1 + 8));
  if ((v5 & 5) == 4)
  {
    v6 = *(unsigned __int8 *)v3;
  }
  else
  {
    v7 = atomic_load((unint64_t *)(a1 + 8));
    if ((v7 & 0x60) != 0)
      v6 = *(_QWORD *)(a1 + 24);
    else
      v6 = (uint64_t)*v2;
  }
  v8 = atomic_load((unint64_t *)(a1 + 8));
  if ((v8 & 0x10) != 0)
  {
    if (v6 >= 97)
    {
      v24 = 0;
      v14 = v6;
      do
      {
        v14 = v3[v24 + 3] + 67503105 * v14 + 257 * (257 * (257 * v3[v24] + v3[v24 + 1]) + v3[v24 + 2]);
        v18 = v24 >= 0x1C;
        v24 += 4;
      }
      while (!v18);
      v25 = (unsigned __int16 *)((char *)v3 + (v6 & 0xFFFFFFFFFFFFFFFELL) - 32);
      for (i = -20; i < 12; i += 4)
      {
        v14 = v25[3] + 67503105 * v14 + 257 * (257 * (257 * *v25 + v25[1]) + v25[2]);
        v25 += 4;
      }
      v27 = &v3[v6];
      v28 = v27 - 32;
      do
      {
        v14 = v28[3] + 67503105 * v14 + 257 * (257 * (257 * *v28 + v28[1]) + v28[2]);
        v28 += 4;
      }
      while (v28 < v27);
    }
    else
    {
      v15 = &v3[v6];
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFCLL) < 1)
      {
        v14 = v6;
      }
      else
      {
        v16 = &v3[v6 & 0xFFFFFFFFFFFFFFFCLL];
        v14 = v6;
        do
        {
          v14 = v3[3] + 67503105 * v14 + 257 * (257 * (257 * *v3 + v3[1]) + v3[2]);
          v3 += 4;
        }
        while (v3 < v16);
      }
      while (v3 < v15)
      {
        v30 = *v3++;
        v14 = 257 * v14 + v30;
      }
    }
  }
  else
  {
    v9 = atomic_load((unint64_t *)(a1 + 8));
    v10 = (v9 >> 2) & 1;
    v11 = (unsigned __int8 *)v3 + v10;
    if (v6 >= 97)
    {
      v17 = 0;
      v14 = v6;
      do
      {
        v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *((unsigned __int8 *)v3 + v10 + v17 + 3))
            + 67503105 * v14
            + 257
            * (257
             * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *((unsigned __int8 *)v3 + v10 + v17))
              + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *((unsigned __int8 *)v3 + v10 + v17 + 1)))
             + *(unsigned __int16 *)(__CFCharToUniCharTable
                                                 + 2 * *((unsigned __int8 *)v3 + v10 + v17 + 2)));
        v18 = v17 >= 0x1C;
        v17 += 4;
      }
      while (!v18);
      v19 = 0;
      v20 = (uint64_t)v3 + v10 + ((unint64_t)v6 >> 1) - 16;
      do
      {
        v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v20 + v19 + 3))
            + 67503105 * v14
            + 257
            * (257
             * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v20 + v19))
              + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v20 + v19 + 1)))
             + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v20 + v19 + 2)));
        v21 = v19 - 16;
        v19 += 4;
      }
      while (v21 < 12);
      v22 = &v11[v6];
      v23 = &v11[v6 - 32];
      do
      {
        v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v23[3])
            + 67503105 * v14
            + 257
            * (257
             * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v23)
              + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v23[1]))
             + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v23[2]));
        v23 += 4;
      }
      while (v23 < v22);
    }
    else
    {
      v12 = &v11[v6];
      if ((uint64_t)(v6 & 0xFFFFFFFFFFFFFFFCLL) < 1)
      {
        v14 = v6;
      }
      else
      {
        v13 = &v11[v6 & 0xFFFFFFFFFFFFFFFCLL];
        v14 = v6;
        do
        {
          v14 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v11[3])
              + 67503105 * v14
              + 257
              * (257
               * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v11)
                + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v11[1]))
               + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v11[2]));
          v11 += 4;
        }
        while (v11 < v13);
      }
      for (; v11 < v12; v14 = 257 * v14 + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v29))
        v29 = *v11++;
    }
  }
  return (v14 << (v6 & 0x1F)) + v14;
}

BOOL __CFStringEqual(CFStringRef theString, CFStringRef a2)
{
  char v4;
  char **p_data;
  char *v6;
  char v7;
  char v8;
  char **v9;
  char *v10;
  char v11;
  char v12;
  int64_t length;
  char v14;
  char v15;
  uint64_t v16;
  char v17;
  unint64_t v18;
  unsigned __int8 *v19;
  unint64_t v20;
  unsigned __int8 *v21;
  char v22;
  char v23;
  _BOOL8 result;
  char v25;
  const __CFString *v26;
  char *v27;
  int v28;
  uint64_t *v29;
  char v30;
  char v31;
  char v32;
  const __CFString *CharactersPtr;
  char *v34;
  int v35;
  uint64_t *p_info;
  char v37;
  char v38;
  int v39;
  int v40;
  int v41;
  char v42;
  char *v43;
  char v44;
  char *v45;
  char v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t j;
  uint64_t v52;
  unsigned __int16 v53;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  CFRange v60;
  uint64_t v61;
  char v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t i;
  uint64_t v68;
  unsigned __int16 v69;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  CFRange v76;
  uint64_t v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  CFStringRef theStringa[2];
  __int128 v87;
  __int128 v88;
  uint64_t v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  v4 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v4 & 0x60) != 0)
  {
    v6 = *p_data;
  }
  else
  {
    v7 = atomic_load((unint64_t *)&theString->info);
    v6 = (char *)&p_data[(v7 & 5) != 4];
  }
  v8 = atomic_load((unint64_t *)&a2->info);
  v9 = &a2->data;
  if ((v8 & 0x60) != 0)
  {
    v10 = *v9;
  }
  else
  {
    v11 = atomic_load((unint64_t *)&a2->info);
    v10 = (char *)&v9[(v11 & 5) != 4];
  }
  v12 = atomic_load((unint64_t *)&theString->info);
  if ((v12 & 5) == 4)
  {
    length = *v6;
  }
  else
  {
    v14 = atomic_load((unint64_t *)&theString->info);
    if ((v14 & 0x60) != 0)
      length = theString->length;
    else
      length = (int64_t)*p_data;
  }
  v15 = atomic_load((unint64_t *)&a2->info);
  if ((v15 & 5) == 4)
  {
    v16 = *v10;
  }
  else
  {
    v17 = atomic_load((unint64_t *)&a2->info);
    if ((v17 & 0x60) != 0)
      v16 = a2->length;
    else
      v16 = (uint64_t)*v9;
  }
  if (length == v16)
  {
    v18 = atomic_load((unint64_t *)&theString->info);
    v19 = (unsigned __int8 *)&v6[(v18 >> 2) & 1];
    v20 = atomic_load((unint64_t *)&a2->info);
    v21 = (unsigned __int8 *)&v10[(v20 >> 2) & 1];
    v22 = atomic_load((unint64_t *)&theString->info);
    if ((v22 & 0x10) == 0)
    {
      v23 = atomic_load((unint64_t *)&a2->info);
      if ((v23 & 0x10) == 0)
        return memcmp(v19, v21, length) == 0;
    }
    v25 = atomic_load((unint64_t *)&theString->info);
    if ((v25 & 0x10) != 0)
    {
      v32 = atomic_load((unint64_t *)&a2->info);
      if ((v32 & 0x10) != 0)
      {
        if (length >= 1)
        {
          result = 1;
          while (1)
          {
            v40 = *(unsigned __int16 *)v19;
            v19 += 2;
            v39 = v40;
            v41 = *(unsigned __int16 *)v21;
            v21 += 2;
            if (v39 != v41)
              break;
            if (!--length)
              return result;
          }
          return 0;
        }
      }
      else
      {
        v87 = 0u;
        v85 = 0u;
        v83 = 0u;
        v84 = 0u;
        v81 = 0u;
        v82 = 0u;
        v79 = 0u;
        v80 = 0u;
        v78 = 0u;
        theStringa[0] = a2;
        v89 = 0;
        v88 = (unint64_t)length;
        CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(a2);
        v34 = 0;
        theStringa[1] = CharactersPtr;
        if (!CharactersPtr)
        {
          v35 = __CFDefaultEightBitStringEncoding;
          if (__CFDefaultEightBitStringEncoding == -1)
          {
            CharactersPtr = (const __CFString *)__CFStringComputeEightBitStringEncoding(0);
            v35 = __CFDefaultEightBitStringEncoding;
          }
          if (v35 != 1536)
          {
            if (v35 == -1)
            {
              __CFStringComputeEightBitStringEncoding(CharactersPtr);
              v35 = __CFDefaultEightBitStringEncoding;
            }
            if (v35 != 1536)
              goto LABEL_42;
          }
          p_info = &a2->info;
          v37 = atomic_load((unint64_t *)&a2->info);
          if ((v37 & 0x10) == 0 || (v38 = atomic_load((unint64_t *)p_info), (v38 & 8) != 0))
          {
            v44 = atomic_load((unint64_t *)p_info);
            if ((v44 & 0x60) != 0)
            {
              v45 = *v9;
            }
            else
            {
              v62 = atomic_load((unint64_t *)&a2->info);
              v45 = (char *)&v9[(v62 & 5) != 4];
            }
            v63 = atomic_load((unint64_t *)&a2->info);
            v34 = &v45[(v63 >> 2) & 1];
          }
          else
          {
LABEL_42:
            v34 = 0;
          }
        }
        *((_QWORD *)&v88 + 1) = 0;
        v89 = 0;
        *(_QWORD *)&v87 = v34;
        if (length >= 1)
        {
          v64 = 0;
          v65 = 0;
          v66 = 0;
          for (i = 64; ; ++i)
          {
            v68 = (unint64_t)v66 >= 4 ? 4 : v66;
            if (theStringa[1])
            {
              v69 = *((_WORD *)&theStringa[1]->isa + v66 + *((_QWORD *)&v87 + 1));
            }
            else if ((_QWORD)v87)
            {
              v69 = *(char *)(v87 + *((_QWORD *)&v87 + 1) + v66);
            }
            else
            {
              if (v89 <= v66 || v65 > v66)
              {
                v71 = -v68;
                v72 = v68 + v64;
                v73 = i - v68;
                v74 = v66 + v71;
                v75 = v74 + 64;
                if (v74 + 64 >= (uint64_t)v88)
                  v75 = v88;
                *((_QWORD *)&v88 + 1) = v74;
                v89 = v75;
                v76.location = v74 + *((_QWORD *)&v87 + 1);
                if ((uint64_t)v88 >= v73)
                  v77 = v73;
                else
                  v77 = v88;
                v76.length = v77 + v72;
                CFStringGetCharacters(theStringa[0], v76, (UniChar *)&v78);
                v65 = *((_QWORD *)&v88 + 1);
              }
              v69 = *((_WORD *)&v78 + v66 - v65);
            }
            if (*(unsigned __int16 *)&v19[2 * v66] != v69)
              break;
            ++v66;
            --v64;
            if (length == v66)
              return 1;
          }
          return 0;
        }
      }
    }
    else
    {
      v87 = 0u;
      v85 = 0u;
      v83 = 0u;
      v84 = 0u;
      v81 = 0u;
      v82 = 0u;
      v79 = 0u;
      v80 = 0u;
      v78 = 0u;
      theStringa[0] = theString;
      v89 = 0;
      v88 = (unint64_t)length;
      v26 = (const __CFString *)CFStringGetCharactersPtr(theString);
      v27 = 0;
      theStringa[1] = v26;
      if (!v26)
      {
        v28 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          v26 = (const __CFString *)__CFStringComputeEightBitStringEncoding(0);
          v28 = __CFDefaultEightBitStringEncoding;
        }
        if (v28 != 1536)
        {
          if (v28 == -1)
          {
            __CFStringComputeEightBitStringEncoding(v26);
            v28 = __CFDefaultEightBitStringEncoding;
          }
          if (v28 != 1536)
            goto LABEL_31;
        }
        v29 = &theString->info;
        v30 = atomic_load((unint64_t *)&theString->info);
        if ((v30 & 0x10) == 0 || (v31 = atomic_load((unint64_t *)v29), (v31 & 8) != 0))
        {
          v42 = atomic_load((unint64_t *)v29);
          if ((v42 & 0x60) != 0)
          {
            v43 = *p_data;
          }
          else
          {
            v46 = atomic_load((unint64_t *)&theString->info);
            v43 = (char *)&p_data[(v46 & 5) != 4];
          }
          v47 = atomic_load((unint64_t *)&theString->info);
          v27 = &v43[(v47 >> 2) & 1];
        }
        else
        {
LABEL_31:
          v27 = 0;
        }
      }
      *((_QWORD *)&v88 + 1) = 0;
      v89 = 0;
      *(_QWORD *)&v87 = v27;
      if (length >= 1)
      {
        v48 = 0;
        v49 = 0;
        v50 = 0;
        for (j = 64; ; ++j)
        {
          v52 = (unint64_t)v50 >= 4 ? 4 : v50;
          if (theStringa[1])
          {
            v53 = *((_WORD *)&theStringa[1]->isa + v50 + *((_QWORD *)&v87 + 1));
          }
          else if ((_QWORD)v87)
          {
            v53 = *(char *)(v87 + *((_QWORD *)&v87 + 1) + v50);
          }
          else
          {
            if (v89 <= v50 || v49 > v50)
            {
              v55 = -v52;
              v56 = v52 + v48;
              v57 = j - v52;
              v58 = v50 + v55;
              v59 = v58 + 64;
              if (v58 + 64 >= (uint64_t)v88)
                v59 = v88;
              *((_QWORD *)&v88 + 1) = v58;
              v89 = v59;
              v60.location = v58 + *((_QWORD *)&v87 + 1);
              if ((uint64_t)v88 >= v57)
                v61 = v57;
              else
                v61 = v88;
              v60.length = v61 + v56;
              CFStringGetCharacters(theStringa[0], v60, (UniChar *)&v78);
              v49 = *((_QWORD *)&v88 + 1);
            }
            v53 = *((_WORD *)&v78 + v50 - v49);
          }
          if (*(unsigned __int16 *)&v21[2 * v50] != v53)
            break;
          ++v50;
          --v48;
          if (length == v50)
            return 1;
        }
        return 0;
      }
    }
    return 1;
  }
  return 0;
}

uint64_t CFStringHashISOLatin1CString(unsigned __int8 *a1, uint64_t a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  unsigned __int8 *v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned int v12;

  if (a2 >= 97)
  {
    v5 = 0;
    v3 = a2;
    do
    {
      v3 = a1[v5 + 3] + 67503105 * v3 + 257 * (257 * ((a1[v5] | (a1[v5] << 8)) + a1[v5 + 1]) + a1[v5 + 2]);
      v6 = v5 >= 0x1C;
      v5 += 4;
    }
    while (!v6);
    v7 = 0;
    do
    {
      v8 = (uint64_t)&a1[((unint64_t)a2 >> 1) - 16];
      v3 = *(unsigned __int8 *)(v8 + v7 + 3)
         + 67503105 * v3
         + 257
         * (257
          * ((*(unsigned __int8 *)(v8 + v7) | (*(unsigned __int8 *)(v8 + v7) << 8)) + *(unsigned __int8 *)(v8 + v7 + 1))
          + *(unsigned __int8 *)(v8 + v7 + 2));
      v9 = v7 - 16;
      v7 += 4;
    }
    while (v9 < 12);
    v10 = &a1[a2 - 32];
    do
    {
      v3 = v10[3] + 67503105 * v3 + 257 * (257 * ((*v10 | (*v10 << 8)) + v10[1]) + v10[2]);
      v10 += 4;
    }
    while (v10 < &a1[a2]);
  }
  else
  {
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      v2 = a1;
      v4 = a1;
      v3 = a2;
    }
    else
    {
      v2 = a1;
      v3 = a2;
      v4 = a1;
      do
      {
        v3 = v4[3] + 67503105 * v3 + 257 * (257 * ((*v4 | (*v4 << 8)) + v4[1]) + v4[2]);
        v4 += 4;
        v2 += 4;
      }
      while (v4 < &a1[a2 & 0xFFFFFFFFFFFFFFFCLL]);
    }
    if (v4 < &a1[a2])
    {
      v11 = (unsigned __int8 *)(&a1[a2] - v2);
      do
      {
        v12 = *v4++;
        v3 = 257 * v3 + v12;
        --v11;
      }
      while (v11);
    }
  }
  return (v3 << (a2 & 0x1F)) + v3;
}

BOOL isEqualToString(uint64_t a1, void *a2)
{
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  BOOL v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  int v18;
  _WORD v20[16];
  _QWORD v21[3];

  v21[2] = *MEMORY[0x1E0C80C00];
  v4 = (uint64_t *)MEMORY[0x1E0DE7C58];
  v5 = *MEMORY[0x1E0DE7C58];
  v6 = a1 & 0xC000000000000007;
  if ((a1 & 0xC000000000000007) == 0xC000000000000007)
    v5 = 7;
  v7 = ((unint64_t)(v5 ^ a1) >> 3) & 0xF;
  if (v7 != objc_msgSend(a2, "length"))
    return 0;
  v21[0] = 0;
  v21[1] = 0;
  v8 = *v4;
  if (v6 == 0xC000000000000007)
    v8 = 0;
  v9 = v8 ^ a1;
  v10 = (~(v8 ^ a1) & 7) == 0;
  v11 = 0xFFFFFFFFFFFFFFFLL;
  if (v10)
    v11 = 0xFFFFFFFFFFFFFLL;
  v12 = (v9 >> 3) & 0xF;
  v13 = (v11 & (v9 >> 3)) >> 4;
  if (v12 < 8)
  {
    v21[0] = v13;
  }
  else
  {
    v14 = (v9 >> 3) & 0xF;
    if (v12 >= 0xA)
    {
      do
      {
        *((_BYTE *)&v20[15] + v14 + 1) = sixBitToCharLookup[v13 & 0x1F];
        v13 >>= 5;
        --v14;
      }
      while (v14);
    }
    else
    {
      do
      {
        *((_BYTE *)&v20[15] + v14 + 1) = sixBitToCharLookup[v13 & 0x3F];
        v13 >>= 6;
        --v14;
      }
      while (v14);
    }
  }
  objc_msgSend(a2, "getCharacters:range:", v20, 0, v7);
  if (!v12)
    return 1;
  if (v20[0] != LOBYTE(v21[0]))
    return 0;
  v15 = 1;
  do
  {
    v16 = v15;
    if (v12 == v15)
      break;
    v17 = *((unsigned __int8 *)v21 + v15);
    v18 = (unsigned __int16)v20[v15++];
  }
  while (v18 == v17);
  return v16 >= v12;
}

unint64_t _CFStringGetLength2(unint64_t *a1)
{
  char v1;
  uint64_t v2;
  char v3;
  uint64_t v4;
  unsigned __int8 ***v5;
  unsigned __int8 **v6;
  uint64_t v8;

  v1 = atomic_load(a1 + 1);
  v2 = v1 & 5;
  v3 = atomic_load(a1 + 1);
  v4 = v3 & 0x60;
  if (v2 == 4)
  {
    v5 = (unsigned __int8 ***)(a1 + 2);
    if (v4)
    {
      v6 = *v5;
    }
    else
    {
      v8 = atomic_load(a1 + 1);
      v6 = (unsigned __int8 **)&v5[(v8 & 5) != 4];
    }
    return *(unsigned __int8 *)v6;
  }
  else if ((v3 & 0x60) != 0)
  {
    return a1[3];
  }
  else
  {
    return a1[2];
  }
}

uint64_t comparisonUsingOrderingForStringKeys(id *a1, _QWORD *a2)
{
  if (*a1 == (id)*a2)
    return 0;
  else
    return objc_msgSend(*a1, "compare:options:range:locale:", *a2, 2, 0, objc_msgSend(*a1, "length"), 0);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)_CFStringGetCStringPtrInternal((uint64_t)theString, encoding, 1, 1);
}

uint64_t _NSIsNSString(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  Class Class;
  uint64_t (*MethodImplementation)(uint64_t, char *);

  if (a1 < 0)
  {
    v2 = 0;
    v3 = *MEMORY[0x1E0DE7C58];
    if ((~a1 & 0xC000000000000007) == 0)
      v3 = 0;
    v4 = v3 ^ a1;
    do
    {
      if ((v4 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v2))
        break;
      ++v2;
    }
    while (v2 != 7);
    v5 = v2 | v4;
    v6 = v2 & 7;
    v7 = (v5 >> 55) + 8;
    if (v6 == 7)
      LODWORD(v6) = v7;
    LOBYTE(Class) = (_DWORD)v6 == 2 || (_DWORD)v6 == 22;
    return Class & 1;
  }
  if (_NSStringClass)
  {
    if (a1)
      goto LABEL_17;
LABEL_21:
    LOBYTE(Class) = 0;
    return Class & 1;
  }
  Class = objc_getClass("NSString");
  _NSStringClass = (uint64_t)Class;
  if (!Class)
    return Class & 1;
  if (!a1)
    goto LABEL_21;
LABEL_17:
  MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
    return MethodImplementation(a1, sel_isNSString__);
  LOBYTE(Class) = objc_opt_isKindOfClass();
  return Class & 1;
}

uint64_t _CFStringCheckAndGetCharacters(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *__dst)
{
  char v4;
  unsigned __int8 ***v5;
  unsigned __int8 **v6;
  char v7;
  char v8;
  unsigned __int8 **v9;
  char v10;
  char v12;
  unint64_t v13;

  v4 = atomic_load((unint64_t *)(a1 + 8));
  v5 = (unsigned __int8 ***)(a1 + 16);
  if ((v4 & 0x60) != 0)
  {
    v6 = *v5;
  }
  else
  {
    v7 = atomic_load((unint64_t *)(a1 + 8));
    v6 = (unsigned __int8 **)&v5[(v7 & 5) != 4];
  }
  v8 = atomic_load((unint64_t *)(a1 + 8));
  if ((v8 & 5) == 4)
  {
    v9 = (unsigned __int8 **)*(unsigned __int8 *)v6;
  }
  else
  {
    v10 = atomic_load((unint64_t *)(a1 + 8));
    if ((v10 & 0x60) != 0)
      v9 = *(unsigned __int8 ***)(a1 + 24);
    else
      v9 = *v5;
  }
  if (a2 + a3 > (uint64_t)v9)
    return 3;
  v12 = atomic_load((unint64_t *)(a1 + 8));
  if ((v12 & 0x10) != 0)
  {
    memmove(__dst, (char *)v6 + 2 * a2, 2 * a3);
  }
  else
  {
    v13 = atomic_load((unint64_t *)(a1 + 8));
    __CFStrConvertBytesToUnicode((unsigned __int8 *)v6 + a2 + ((v13 >> 2) & 1), __dst, a3);
  }
  return 0;
}

unsigned __int8 *__CFStrConvertBytesToUnicode(unsigned __int8 *result, _WORD *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;

  if (a3 >= 1)
  {
    v3 = __CFCharToUniCharTable;
    do
    {
      v4 = *result++;
      *a2++ = *(_WORD *)(v3 + 2 * v4);
      --a3;
    }
    while (a3);
  }
  return result;
}

uint64_t _CFNonObjCHash(unint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  _UNKNOWN **v10;
  uint64_t (*v11)(unint64_t *);

  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    v2 = 0;
    v3 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0)
      v3 = 0;
    v4 = v3 ^ (unint64_t)a1;
    do
    {
      if ((v4 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v2))
        break;
      ++v2;
    }
    while (v2 != 7);
    v5 = v2 | v4;
    v6 = v2 & 7;
    v7 = (v5 >> 55) + 8;
    if (v6 == 7)
      LODWORD(v6) = v7;
    v8 = 22;
    switch((int)v6)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          _CFNonObjCHash_cold_1();
        goto LABEL_18;
      case 1:
        goto LABEL_19;
      case 2:
        goto LABEL_17;
      case 3:
        goto LABEL_21;
      case 4:
      case 5:
        goto LABEL_18;
      case 6:
        v8 = 42;
        goto LABEL_21;
      default:
        if ((_DWORD)v6 == 20)
        {
LABEL_18:
          v8 = 1;
          goto LABEL_21;
        }
        if ((_DWORD)v6 == 22)
        {
LABEL_17:
          v8 = 7;
          goto LABEL_21;
        }
LABEL_19:
        v8 = objc_msgSend(a1, "_cfTypeID");
        break;
    }
  }
  else
  {
    v9 = atomic_load(a1 + 1);
    v8 = (v9 >> 8) & 0x3FF;
  }
  if (v8 <= 0x47)
LABEL_21:
    v10 = &__CFRuntimeBuiltinClassTable + v8;
  else
    v10 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v8 - 72) >> 6] + 8 * (((_DWORD)v8 - 72) & 0x3F));
  v11 = (uint64_t (*)(unint64_t *))*((_QWORD *)*v10 + 6);
  if (v11)
    return v11(a1);
  else
    return (uint64_t)a1;
}

uint64_t CFStringHashCString(unsigned __int8 *a1, uint64_t a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  unsigned __int8 *v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned int v12;

  if (a2 >= 97)
  {
    v5 = 0;
    v3 = a2;
    do
    {
      v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 3])
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5])
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 1]))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 2]));
      v6 = v5 >= 0x1C;
      v5 += 4;
    }
    while (!v6);
    v7 = 0;
    do
    {
      v8 = (uint64_t)&a1[((unint64_t)a2 >> 1) - 16];
      v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 3))
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7))
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 1)))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 2)));
      v9 = v7 - 16;
      v7 += 4;
    }
    while (v9 < 12);
    v10 = &a1[a2 - 32];
    do
    {
      v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[3])
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v10)
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[1]))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[2]));
      v10 += 4;
    }
    while (v10 < &a1[a2]);
  }
  else
  {
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      v2 = a1;
      v4 = a1;
      v3 = a2;
    }
    else
    {
      v2 = a1;
      v3 = a2;
      v4 = a1;
      do
      {
        v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[3])
           + 67503105 * v3
           + 257
           * (257
            * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v4)
             + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[1]))
            + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[2]));
        v4 += 4;
        v2 += 4;
      }
      while (v4 < &a1[a2 & 0xFFFFFFFFFFFFFFFCLL]);
    }
    if (v4 < &a1[a2])
    {
      v11 = (unsigned __int8 *)(&a1[a2] - v2);
      do
      {
        v12 = *v4++;
        v3 = 257 * v3 + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v12);
        --v11;
      }
      while (v11);
    }
  }
  return (v3 << (a2 & 0x1F)) + v3;
}

uint64_t _cow_mutate_slow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (((*(uint64_t (**)(void))(a3 + 8))() & 1) == 0)
    _cow_mutate_slow_cold_1();
  return (*(uint64_t (**)(uint64_t, _QWORD))(a3 + 16))(a1, 0);
}

uint64_t cow_copy_storage(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t result;
  char *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  id *v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  id v17;

  v2 = *(char **)(a1 + 16);
  if (!v2)
  {
    v5 = 0;
LABEL_21:
    result = 1;
    goto LABEL_22;
  }
  v3 = *(unsigned int *)(a1 + 28);
  result = (uint64_t)malloc_type_malloc(8 * v3, 0x80040B8603338uLL);
  v5 = (char *)result;
  if (result)
  {
    v6 = *(_DWORD *)(a1 + 36);
    v7 = *(unsigned int *)(a1 + 24);
    v8 = v3 - v7;
    if ((int)v3 - (int)v7 >= v6)
      v9 = v6;
    else
      v9 = v8;
    if ((_DWORD)v9)
    {
      v10 = (id *)(result + 8 * v7);
      memcpy(v10, &v2[8 * v7], 8 * v9);
      v11 = v9;
      do
      {
        if (((unint64_t)*v10 & 0x8000000000000000) == 0)
          v12 = *v10;
        ++v10;
        --v11;
      }
      while (v11);
    }
    if (v6 > v8)
    {
      memcpy(v5, v2, 8 * (v6 - v9));
      v13 = 0;
      if (v6 - v9 <= 1uLL)
        v14 = 1;
      else
        v14 = v6 - v9;
      v15 = 8 * v14;
      do
      {
        v16 = *(_QWORD *)&v5[v13];
        if ((v16 & 0x8000000000000000) == 0)
          v17 = (id)v16;
        v13 += 8;
      }
      while (v15 != v13);
    }
    goto LABEL_21;
  }
LABEL_22:
  *(_QWORD *)(a1 + 16) = v5;
  return result;
}

uint64_t cow_set_cow(uint64_t result, unint64_t a2)
{
  atomic_store(a2, (unint64_t *)(result + 8));
  return result;
}

void sub_182A91FD0(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t __CFBooleanHash(__objc2_class **a1)
{
  if (&__kCFBooleanTrue == a1)
    return 2654435761;
  else
    return 0;
}

uint64_t _CFStringCompareASCIICaseInsensitive(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3;

  if (!a3)
    return 0;
  while (1)
  {
    v3 = __ASCII_LOWERCASE_TABLE[*a1] - __ASCII_LOWERCASE_TABLE[*a2];
    if ((_DWORD)v3)
      break;
    ++a2;
    ++a1;
    if (!--a3)
      return 0;
  }
  return v3;
}

void __NSMUTABLEDICTIONARY_CONCURRENT_MODIFICATION_DETECTED__()
{
  objc_class *v0;
  __int16 Name;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v0 = (objc_class *)objc_opt_class();
  Name = (unsigned __int16)class_getName(v0);
  CFLog(3, (uint64_t)CFSTR("*** Collection <%s: %p> was mutated while rehashing."), v2, v3, v4, v5, v6, v7, Name);
  __break(1u);
}

uint64_t __CFStringCheckAndReplace(__CFString *theString, unint64_t a2, uint64_t a3, __CFString *a4)
{
  char v4;
  uint64_t result;
  __CFString *v6;
  unint64_t v10;
  char v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  char **p_data;
  char *v16;
  unint64_t length;
  uint64_t v18;
  CFStringRef Copy;
  CFIndex v20;
  int v21;
  _BOOL4 v22;
  unsigned int v23;
  char v24;
  char v25;
  uint64_t v26;
  char **v27;
  char *v28;
  char *v29;
  uint64_t v30;
  CFStringEncoding v31;
  unint64_t v32;
  uint64_t v33;
  _QWORD v34[3];
  CFRange v35;
  CFRange v36;

  v34[2] = *MEMORY[0x1E0C80C00];
  v4 = atomic_load((unint64_t *)&theString->info);
  if ((v4 & 1) == 0)
    return 1;
  v6 = a4;
  if (!a4)
    return 2;
  v10 = a2 + a3;
  v11 = atomic_load((unint64_t *)&theString->info);
  v12 = v11 & 5;
  v13 = atomic_load((unint64_t *)&theString->info);
  v14 = v13 & 0x60;
  if (v12 == 4)
  {
    p_data = &theString->data;
    if (v14)
    {
      v16 = *p_data;
    }
    else
    {
      v18 = atomic_load((unint64_t *)&theString->info);
      v16 = (char *)&p_data[(v18 & 5) != 4];
    }
    length = *v16;
  }
  else if ((v13 & 0x60) != 0)
  {
    length = theString->length;
  }
  else
  {
    length = (unint64_t)theString->data;
  }
  result = 3;
  if (v10 >= a2 && v10 <= length)
  {
    if (a4 == theString)
    {
      Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
      v6 = (__CFString *)Copy;
    }
    else
    {
      Copy = 0;
    }
    v20 = CFStringGetLength(v6);
    if (v20 < 1)
    {
      v22 = 0;
    }
    else
    {
      if (CF_IS_OBJC(7uLL, (__objc2_class **)v6))
      {
        v21 = -[__CFString _encodingCantBeStoredInEightBitCFString](v6, "_encodingCantBeStoredInEightBitCFString");
      }
      else
      {
        v23 = atomic_load((unint64_t *)&v6->info);
        v21 = (v23 >> 4) & 1;
      }
      v22 = v21 != 0;
    }
    v34[0] = a2;
    v34[1] = a3;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)v34, 1, v20, v22);
    v24 = atomic_load((unint64_t *)&theString->info);
    v25 = atomic_load((unint64_t *)&theString->info);
    v26 = v25 & 0x60;
    v27 = &theString->data;
    if ((v24 & 0x10) == 0)
    {
      if (v26)
      {
        v28 = *v27;
      }
      else
      {
        v30 = atomic_load((unint64_t *)&theString->info);
        v28 = (char *)&v27[(v30 & 5) != 4];
      }
      v31 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        v31 = __CFDefaultEightBitStringEncoding;
      }
      v32 = atomic_load((unint64_t *)&theString->info);
      v35.location = 0;
      v35.length = v20;
      CFStringGetBytes(v6, v35, v31, 0, 0, (UInt8 *)&v28[a2 + ((v32 >> 2) & 1)], v20, 0);
      goto LABEL_36;
    }
    if (v26)
    {
      v29 = *v27;
      if (!v29)
        goto LABEL_36;
    }
    else
    {
      v33 = atomic_load((unint64_t *)&theString->info);
      v29 = (char *)&v27[(v33 & 5) != 4];
      if (!v29)
      {
LABEL_36:
        if (Copy)
          CFRelease(Copy);
        return 0;
      }
    }
    v36.location = 0;
    v36.length = v20;
    CFStringGetCharacters(v6, v36, (UniChar *)&v29[2 * a2]);
    goto LABEL_36;
  }
  return result;
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
  uint64_t *p_info;
  char v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char **p_data;
  char *v19;
  uint64_t length;
  uint64_t v21;
  const __CFString *Copy;
  CFIndex v23;
  int v24;
  _BOOL4 v25;
  unsigned int v26;
  uint64_t v27;
  char v28;
  char v29;
  uint64_t v30;
  char **v31;
  char *v32;
  char *v33;
  uint64_t v34;
  CFStringEncoding v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD v38[3];
  CFRange v39;
  CFRange v40;

  v38[2] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString appendString:](theString, "appendString:", appendedString);
    return;
  }
  p_info = &theString->info;
  v5 = atomic_load((unint64_t *)&theString->info);
  if ((v5 & 1) == 0)
  {
    v6 = _CFOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      CFStringAppend_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    return;
  }
  v14 = atomic_load((unint64_t *)p_info);
  v15 = v14 & 5;
  v16 = atomic_load((unint64_t *)p_info);
  v17 = v16 & 0x60;
  if (v15 == 4)
  {
    p_data = &theString->data;
    if (v17)
    {
      v19 = *p_data;
    }
    else
    {
      v21 = atomic_load((unint64_t *)&theString->info);
      v19 = (char *)&p_data[(v21 & 5) != 4];
    }
    length = *v19;
  }
  else if ((v16 & 0x60) != 0)
  {
    length = theString->length;
  }
  else
  {
    length = (uint64_t)theString->data;
  }
  if (appendedString == theString)
  {
    Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
    appendedString = Copy;
  }
  else
  {
    Copy = 0;
  }
  v23 = CFStringGetLength(appendedString);
  if (v23 < 1)
  {
    v25 = 0;
  }
  else
  {
    if (CF_IS_OBJC(7uLL, (__objc2_class **)appendedString))
    {
      v24 = -[__CFString _encodingCantBeStoredInEightBitCFString]((id)appendedString, "_encodingCantBeStoredInEightBitCFString");
    }
    else
    {
      v26 = atomic_load((unint64_t *)&appendedString->info);
      v24 = (v26 >> 4) & 1;
    }
    v25 = v24 != 0;
  }
  v38[0] = length;
  v38[1] = 0;
  v27 = __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)v38, 1, v23, v25);
  v28 = atomic_load((unint64_t *)&theString->info);
  v29 = atomic_load((unint64_t *)&theString->info);
  v30 = v29 & 0x60;
  v31 = &theString->data;
  if ((v28 & 0x10) == 0)
  {
    if (v30)
    {
      v32 = *v31;
    }
    else
    {
      v34 = atomic_load((unint64_t *)&theString->info);
      v32 = (char *)&v31[(v34 & 5) != 4];
    }
    v35 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(v27);
      v35 = __CFDefaultEightBitStringEncoding;
    }
    v36 = atomic_load((unint64_t *)&theString->info);
    v39.location = 0;
    v39.length = v23;
    CFStringGetBytes(appendedString, v39, v35, 0, 0, (UInt8 *)&v32[length + ((v36 >> 2) & 1)], v23, 0);
    goto LABEL_35;
  }
  if (!v30)
  {
    v37 = atomic_load((unint64_t *)&theString->info);
    v33 = (char *)&v31[(v37 & 5) != 4];
    if (!v33)
      goto LABEL_35;
    goto LABEL_34;
  }
  v33 = *v31;
  if (v33)
  {
LABEL_34:
    v40.location = 0;
    v40.length = v23;
    CFStringGetCharacters(appendedString, v40, (UniChar *)&v33[2 * length]);
  }
LABEL_35:
  if (Copy)
    CFRelease(Copy);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  int v10;
  unsigned int v11;
  uint64_t v12;
  CFIndex length;
  CFIndex location;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  char v22;
  int v23;
  char v24;
  char **p_data;
  char *v26;
  int64_t Bytes;
  char *v28;
  char v29;
  unint64_t v30;
  int v32;
  int v33;
  _QWORD v34[2];
  unint64_t v35[3];
  CFRange v36;

  v10 = isExternalRepresentation;
  v11 = lossByte;
  v12 = *(_QWORD *)&encoding;
  length = range.length;
  location = range.location;
  v35[2] = *MEMORY[0x1E0C80C00];
  v16 = CF_IS_OBJC(7uLL, (__objc2_class **)theString);
  if ((_DWORD)v16)
  {
    if (!v11)
    {
      v17 = CFStringConvertEncodingToNSStringEncoding(v12);
      v18 = v17;
      v34[0] = location;
      v34[1] = length;
      if (((unint64_t)theString & 0x8000000000000000) == 0)
        goto LABEL_35;
      v19 = 0;
      v20 = *MEMORY[0x1E0DE7C58];
      if ((~(unint64_t)theString & 0xC000000000000007) == 0)
        LOBYTE(v20) = 0;
      v21 = (v20 ^ theString) & 7;
      while (v21 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v19))
      {
        if (++v19 == 7)
          goto LABEL_35;
      }
      if (v10
        || !buffer
        || v19 != 2
        || v17 > 5
        || ((1 << v17) & 0x32) == 0
        || (Bytes = _NSTaggedPointerStringGetBytes((uint64_t)theString, v35), Bytes < length)
        || location > Bytes - length)
      {
LABEL_35:
        if (-[__CFString getBytes:maxLength:usedLength:encoding:options:range:remainingRange:]((id)theString, "getBytes:maxLength:usedLength:encoding:options:range:remainingRange:", buffer, maxBufLen, usedBufLen, v18, 2 * (v10 != 0), location, length, v34))return v34[0] - location;
        else
          return 0;
      }
      if (length >= maxBufLen)
        length = maxBufLen;
      v28 = (char *)v35 + location;
      goto LABEL_42;
    }
  }
  else
  {
    v22 = atomic_load((unint64_t *)&theString->info);
    if ((v22 & 0x10) == 0)
    {
      v23 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        v16 = __CFStringComputeEightBitStringEncoding(v16);
        v23 = __CFDefaultEightBitStringEncoding;
      }
      if (v23 == (_DWORD)v12)
        goto LABEL_14;
      if (v23 == -1)
      {
        __CFStringComputeEightBitStringEncoding(v16);
        v23 = __CFDefaultEightBitStringEncoding;
      }
      if (v23 == 1536)
      {
        switch(BYTE1(v12))
        {
          case 0:
            if (v12 <= 0x22 && ((1 << v12) & 0x600000032) != 0 || (_DWORD)v12 == 152)
              goto LABEL_59;
            goto LABEL_14;
          case 1:
            if ((_DWORD)v12 != 134217984)
              goto LABEL_59;
            goto LABEL_14;
          case 2:
            if ((_DWORD)v12 == 518)
              goto LABEL_59;
            goto LABEL_14;
          case 6:
            if ((_DWORD)v12 != 1536)
              goto LABEL_59;
            goto LABEL_14;
          case 8:
          case 0xC:
            goto LABEL_59;
          case 0xA:
            if ((v12 - 2561) > 0xF)
              goto LABEL_14;
            v32 = 1 << (v12 - 1);
            v33 = 32785;
            break;
          case 0xB:
            if ((v12 - 3059) > 0xC)
              goto LABEL_14;
            v32 = 1 << (v12 + 13);
            v33 = 4099;
            break;
          default:
            if (((unsigned __int16)v12 & 0xFF00u) > 0xC00)
              goto LABEL_59;
            goto LABEL_14;
        }
        if ((v32 & v33) == 0)
        {
LABEL_14:
          v24 = atomic_load((unint64_t *)&theString->info);
          p_data = &theString->data;
          if ((v24 & 0x60) != 0)
          {
            v26 = *p_data;
            if (!buffer)
            {
LABEL_43:
              if (usedBufLen)
                *usedBufLen = length;
              return length;
            }
          }
          else
          {
            v29 = atomic_load((unint64_t *)&theString->info);
            v26 = (char *)&p_data[(v29 & 5) != 4];
            if (!buffer)
              goto LABEL_43;
          }
          if (length >= maxBufLen)
            length = maxBufLen;
          v30 = atomic_load((unint64_t *)&theString->info);
          v28 = &v26[location + ((v30 >> 2) & 1)];
LABEL_42:
          memmove(buffer, v28, length);
          goto LABEL_43;
        }
      }
    }
  }
LABEL_59:
  v36.location = location;
  v36.length = length;
  return __CFStringEncodeByteStream(theString, v36, v10, v12, v11, (UniChar *)buffer, maxBufLen, usedBufLen);
}

void __CFStringAppendBytes(unint64_t *a1, unsigned __int8 *a2, unint64_t a3, uint64_t a4)
{
  int v8;
  int v9;
  _BOOL4 v10;
  int v11;
  char v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  unsigned __int8 ***v16;
  unsigned __int8 **v17;
  unint64_t v18;
  uint64_t v19;
  __objc2_class **v20;
  unsigned int v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  char v27;
  char v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  char v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  char v36;
  size_t v37;
  char *v38;
  unsigned __int8 *v39;
  unint64_t v40;
  unsigned int v41;
  uint64_t v43;
  unint64_t v44;
  unsigned __int8 *v45;
  unsigned __int8 *v46;
  unsigned __int8 v47;
  uint64_t v48;
  unint64_t v49;
  const __CFAllocator *v50;
  _QWORD v51[2];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v82 = 0u;
  v83 = 0u;
  v80 = 0u;
  v81 = 0u;
  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  if ((_DWORD)a4 == 1536)
    goto LABEL_5;
  v8 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding(a1);
    v8 = __CFDefaultEightBitStringEncoding;
  }
  if (v8 == (_DWORD)a4)
  {
LABEL_5:
    v9 = 0;
    v10 = 0;
    v11 = 0;
    goto LABEL_6;
  }
  if ((_DWORD)a4 == 256)
  {
    if (a3 >= 2)
    {
      v40 = 0;
      do
      {
        v41 = *(unsigned __int16 *)&a2[2 * v40];
        v10 = v41 < 0x80;
        ++v40;
      }
      while (v41 <= 0x7F && v40 < a3 >> 1);
    }
    else
    {
      v10 = 1;
    }
    v9 = 0;
    v11 = !v10;
    a3 >>= 1;
LABEL_6:
    if (CF_IS_OBJC(7uLL, (__objc2_class **)a1))
    {
      if (v10 | v11)
        objc_msgSend(a1, "appendCharacters:length:", a2, a3);
      else
        objc_msgSend(a1, "_cfAppendCString:length:", a2, a3);
      return;
    }
    v12 = atomic_load(a1 + 1);
    v13 = v12 & 5;
    v14 = atomic_load(a1 + 1);
    v15 = v14 & 0x60;
    if (v13 == 4)
    {
      v16 = (unsigned __int8 ***)(a1 + 2);
      if (v15)
      {
        v17 = *v16;
      }
      else
      {
        v23 = atomic_load(a1 + 1);
        v17 = (unsigned __int8 **)&v16[(v23 & 5) != 4];
      }
      v18 = *(unsigned __int8 *)v17;
      if ((v11 & 1) != 0)
        goto LABEL_30;
LABEL_32:
      v25 = atomic_load(a1 + 1);
      v24 = (v25 >> 4) & 1;
LABEL_33:
      v51[0] = v18;
      v51[1] = 0;
      __CFStringChangeSizeMultiple((uint64_t)a1, (uint64_t)v51, 1, a3, v24);
      v26 = a1 + 1;
      v27 = atomic_load(a1 + 1);
      if ((v27 & 0x10) != 0)
      {
        v32 = atomic_load(v26);
        v33 = a1 + 2;
        if ((v32 & 0x60) != 0)
        {
          v34 = (_QWORD *)*v33;
        }
        else
        {
          v36 = atomic_load(a1 + 1);
          v34 = &v33[(v36 & 5) != 4];
        }
        if (!v11)
        {
          __CFStrConvertBytesToUnicode(a2, (_WORD *)v34 + v18, a3);
          goto LABEL_60;
        }
        v37 = 2 * a3;
        v38 = (char *)v34 + 2 * v18;
        v39 = a2;
      }
      else
      {
        v28 = atomic_load(v26);
        v29 = v28 & 0x60;
        v30 = a1 + 2;
        if (v10)
        {
          if (v29)
          {
            v31 = (_QWORD *)*v30;
          }
          else
          {
            v43 = atomic_load(a1 + 1);
            v31 = &v30[(v43 & 5) != 4];
          }
          v44 = atomic_load(a1 + 1);
          if ((uint64_t)a3 >= 1)
          {
            v45 = (unsigned __int8 *)v31 + v18 + ((v44 >> 2) & 1);
            v46 = a2;
            do
            {
              v47 = *v46;
              v46 += 2;
              *v45++ = v47;
              --a3;
            }
            while (a3);
          }
          goto LABEL_60;
        }
        if (v29)
        {
          v35 = (_QWORD *)*v30;
        }
        else
        {
          v48 = atomic_load(a1 + 1);
          v35 = &v30[(v48 & 5) != 4];
        }
        v49 = atomic_load(a1 + 1);
        v38 = (char *)v35 + v18 + ((v49 >> 2) & 1);
        v39 = a2;
        v37 = a3;
      }
      memmove(v38, v39, v37);
LABEL_60:
      if (v9)
      {
        v50 = (const __CFAllocator *)_CFGetTSD(1u);
        if (!v50)
          v50 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
        CFAllocatorDeallocate(v50, a2);
      }
      return;
    }
    if ((v14 & 0x60) != 0)
    {
      v18 = a1[3];
      if ((v11 & 1) == 0)
        goto LABEL_32;
    }
    else
    {
      v18 = a1[2];
      if ((v11 & 1) == 0)
        goto LABEL_32;
    }
LABEL_30:
    LODWORD(v24) = 1;
    goto LABEL_33;
  }
  LOBYTE(v51[0]) = 0;
  v19 = _CFGetTSD(1u);
  v20 = &__kCFAllocatorSystemDefault;
  if (v19)
    v20 = (__objc2_class **)v19;
  *(_QWORD *)&v53 = v20;
  *(_QWORD *)&v52 = 0;
  v21 = atomic_load(a1 + 1);
  if (__CFStringDecodeByteStream3((char *)a2, a3, a4, (v21 >> 4) & 1, (uint64_t)&v52, v51, 0))
  {
    v10 = 0;
    a3 = *((_QWORD *)&v53 + 1);
    v11 = BYTE8(v52) == 0;
    a2 = (unsigned __int8 *)v52;
    if (LOBYTE(v51[0]))
      v22 = 1;
    else
      v22 = BYTE9(v52) == 0;
    v9 = !v22;
    goto LABEL_6;
  }
}

uint64_t __CFStringChangeSizeMultiple(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unint64_t *v5;
  char v6;
  uint64_t *v7;
  uint64_t *v8;
  char v9;
  uint64_t v10;
  char v11;
  char v12;
  int64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  size_t v26;
  char v27;
  uint64_t PreferredSizeForSize;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  size_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  size_t v44;
  char v45;
  uint64_t v46;
  int v47;
  unsigned int v48;
  unsigned int v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  unint64_t v55;
  unint64_t v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  int v60;
  unint64_t v61;
  unint64_t v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  int v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  char v79;
  char v80;
  uint64_t v81;
  unsigned int v82;
  uint64_t v83;
  unsigned __int8 *v84;
  uint64_t v85;
  uint64_t v86;
  char v87;
  unint64_t *v88;
  unint64_t v89;
  unint64_t v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  int v97;
  char v98;
  unint64_t v99;
  unint64_t v100;
  int v101;
  unint64_t v102;
  unint64_t v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  char v107;
  char v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  char *p_ptr;
  uint64_t v115;
  _QWORD *v116;
  uint64_t v117;
  uint64_t v118;
  size_t v119;
  uint64_t v120;
  char *v121;
  uint64_t v122;
  BOOL v123;
  void *v124;
  const void *v125;
  char *v126;
  uint64_t v127;
  unint64_t v128;
  char *v129;
  char *v130;
  size_t v131;
  BOOL v132;
  uint64_t *v133;
  char *v134;
  unint64_t v135;
  char *v136;
  size_t v137;
  BOOL v138;
  void *Typed;
  unsigned int v140;
  int v141;
  int v142;
  uint64_t v143;
  uint64_t v144;
  int v145;
  uint64_t v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t v149;
  uint64_t v151;
  char *v152;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  char ptr;
  uint64_t v158;

  v158 = *MEMORY[0x1E0C80C00];
  v5 = (unint64_t *)(result + 8);
  v6 = atomic_load((unint64_t *)(result + 8));
  v7 = (uint64_t *)(result + 16);
  if ((v6 & 0x60) != 0)
  {
    v8 = (uint64_t *)*v7;
    if (*v7)
      goto LABEL_3;
LABEL_6:
    v10 = 0;
    goto LABEL_10;
  }
  v11 = atomic_load(v5);
  v8 = &v7[(v11 & 5) != 4];
  if (!v8)
    goto LABEL_6;
LABEL_3:
  v9 = atomic_load(v5);
  if ((v9 & 5) == 4)
  {
    v10 = *(unsigned __int8 *)v8;
  }
  else
  {
    v12 = atomic_load(v5);
    if ((v12 & 0x60) != 0)
      v10 = *(_QWORD *)(result + 24);
    else
      v10 = *v7;
  }
LABEL_10:
  if (a3 == 1)
  {
    v13 = v10 + a4 - *(_QWORD *)(a2 + 8);
  }
  else
  {
    v13 = v10 + a4 * a3;
    if (a3 >= 1)
    {
      v14 = (uint64_t *)(a2 + 8);
      v15 = a3;
      do
      {
        v16 = *v14;
        v14 += 2;
        v13 -= v16;
        --v15;
      }
      while (v15);
    }
  }
  v155 = result;
  if (!v13)
  {
    v24 = *(_QWORD *)(result + 32);
    if (!v24
      || ((unint64_t)(v24 - 2) <= 0xFFFFFFFFFFFFFFFCLL
        ? (v25 = (*(_QWORD *)(result + 40) & 8) == 0)
        : (v25 = 0),
          !v25
       || ((v26 = *(_QWORD *)(result + 40) >> 4, v27 = atomic_load(v5), (~v27 & 0x60) != 0)
         ? (PreferredSizeForSize = malloc_good_size(v26))
         : (PreferredSizeForSize = CFAllocatorGetPreferredSizeForSize(*(CFAllocatorRef *)(result + 48), v26, 0)),
           PreferredSizeForSize < 0 ? (v54 = -1) : (v54 = PreferredSizeForSize),
           result = v155,
           v54 == v24)))
    {
      if ((*(_BYTE *)(result + 40) & 4) != 0)
      {
LABEL_140:
        v80 = atomic_load(v5);
        if ((v80 & 0x60) != 0)
          *(_QWORD *)(result + 24) = 0;
        else
          *v7 = 0;
        return result;
      }
      v55 = atomic_load(v5);
      while (1)
      {
        v56 = __ldaxr(v5);
        if (v56 != v55)
          break;
        if (__stlxr(v55 & 0xFFFFFFFFFFFFFFEFLL, v5))
          goto LABEL_82;
        v57 = 1;
LABEL_83:
        v55 = v56;
        if (v57)
        {
          if (v24 >= 2)
          {
            if (!v8)
              __CFStringChangeSizeMultiple_cold_1();
            v58 = atomic_load(v5);
            while (2)
            {
              v59 = __ldaxr(v5);
              if (v59 == v58)
              {
                if (!__stlxr(v58 | 4, v5))
                {
                  v60 = 1;
                  goto LABEL_92;
                }
              }
              else
              {
                __clrex();
              }
              v60 = 0;
LABEL_92:
              v58 = v59;
              if (!v60)
                continue;
              break;
            }
            v61 = atomic_load(v5);
            while (2)
            {
              v62 = __ldaxr(v5);
              if (v62 == v61)
              {
                if (!__stlxr(v61 | 8, v5))
                {
                  v63 = 1;
                  goto LABEL_99;
                }
              }
              else
              {
                __clrex();
              }
              v63 = 0;
LABEL_99:
              v61 = v62;
              if (v63)
              {
                *(_WORD *)v8 = 0;
                goto LABEL_140;
              }
              continue;
            }
          }
          v64 = atomic_load(v5);
          while (2)
          {
            v65 = __ldaxr(v5);
            if (v65 == v64)
            {
              if (!__stlxr(v64 & 0xFFFFFFFFFFFFFFFBLL, v5))
              {
                v66 = 1;
                goto LABEL_107;
              }
            }
            else
            {
              __clrex();
            }
            v66 = 0;
LABEL_107:
            v64 = v65;
            if (!v66)
              continue;
            break;
          }
          v67 = atomic_load(v5);
          while (2)
          {
            v68 = __ldaxr(v5);
            if (v68 == v67)
            {
              if (!__stlxr(v67 & 0xFFFFFFFFFFFFFFF7, v5))
              {
                v69 = 1;
                goto LABEL_114;
              }
            }
            else
            {
              __clrex();
            }
            v69 = 0;
LABEL_114:
            v67 = v68;
            if (v69)
              goto LABEL_140;
            continue;
          }
        }
      }
      __clrex();
LABEL_82:
      v57 = 0;
      goto LABEL_83;
    }
    if (v8)
    {
      __CFStrDeallocateMutableContents(v155, v8);
      result = v155;
    }
    *(_QWORD *)(result + 16) = 0;
    v70 = *(_QWORD *)(result + 40) & 0xFFFFFFFFFFFFFFF7;
    *(_QWORD *)(result + 32) = 0;
    *(_QWORD *)(result + 40) = v70;
    v71 = atomic_load((unint64_t *)(result + 8));
    while (1)
    {
      v72 = __ldaxr(v5);
      if (v72 != v71)
        break;
      if (__stlxr(v71 & 0xFFFFFFFFFFFFFFFBLL, v5))
        goto LABEL_123;
      v73 = 1;
LABEL_124:
      v71 = v72;
      if (v73)
      {
        v74 = atomic_load(v5);
        while (1)
        {
          v75 = __ldaxr(v5);
          if (v75 != v74)
            break;
          if (__stlxr(v74 & 0xFFFFFFFFFFFFFFF7, v5))
            goto LABEL_130;
          v76 = 1;
LABEL_131:
          v74 = v75;
          if (v76)
          {
            if ((*(_BYTE *)(result + 40) & 4) != 0)
              goto LABEL_140;
            v77 = atomic_load(v5);
            while (2)
            {
              v78 = __ldaxr(v5);
              if (v78 == v77)
              {
                if (!__stlxr(v77 & 0xFFFFFFFFFFFFFFEFLL, v5))
                {
                  v79 = 1;
                  goto LABEL_139;
                }
              }
              else
              {
                __clrex();
              }
              v79 = 0;
LABEL_139:
              v77 = v78;
              if ((v79 & 1) != 0)
                goto LABEL_140;
              continue;
            }
          }
        }
        __clrex();
LABEL_130:
        v76 = 0;
        goto LABEL_131;
      }
    }
    __clrex();
LABEL_123:
    v73 = 0;
    goto LABEL_124;
  }
  v17 = 0;
  v18 = atomic_load(v5);
  v19 = 1;
  v156 = 2;
  LODWORD(v20) = 1;
  v21 = 0;
  if (!a5 && (v18 & 0x10) == 0)
  {
    v22 = *(_QWORD *)(result + 40);
    v20 = (v22 >> 2) & 1;
    if ((v22 & 4) != 0)
    {
      v17 = 0;
      v21 = 0;
      v19 = 1;
      v23 = 2;
    }
    else
    {
      v19 = 0;
      v21 = 2;
      v17 = 1;
      v23 = 1;
    }
    v156 = v23;
  }
  v145 = v20;
  v149 = v10;
  v154 = a3;
  v152 = (char *)v8;
  v29 = *(_QWORD *)(result + 32);
  v30 = v29;
  if (v13 > (v21 ^ 0x7FFFFFFFFFFFFFFFuLL) >> v19)
    __CFStringHandleOutOfMemory();
  v151 = v19;
  v31 = (v13 << v19) + v21;
  v32 = *(_QWORD *)(result + 32);
  v33 = v29 | v31;
  v34 = v156;
  if (v29 | v31)
  {
    if (v29 < v31
      || (v29 >= 0 ? (v35 = *(_QWORD *)(result + 32)) : (v35 = v29 + 1),
          (v32 = *(_QWORD *)(result + 32), (*(_BYTE *)(result + 40) & 8) == 0)
       && (v32 = *(_QWORD *)(result + 32), v35 >> 1 > v31)))
    {
      if ((v31 & 0x8000000000000000) != 0)
        goto LABEL_150;
      v36 = *(_QWORD *)(result + 40);
      v37 = (v36 >> 4) * v156;
      if (v37 <= v31)
        v38 = v31;
      else
        v38 = (v36 >> 4) * v156;
      if ((v36 & 2) != 0)
        v39 = v38;
      else
        v39 = (3 * v31 + 1) >> 1;
      if ((3 * v31 + 1) >> 1 >= v37)
        v40 = v39;
      else
        v40 = v37;
      v41 = atomic_load(v5);
      if ((~v41 & 0x60) != 0)
        v42 = malloc_good_size(v40);
      else
        v42 = CFAllocatorGetPreferredSizeForSize(*(CFAllocatorRef *)(result + 48), v40, 0);
      if (v42 < 0)
        v32 = -1;
      else
        v32 = v42;
      result = v155;
      v34 = v156;
      v29 = v30;
    }
  }
  if (v32 == -1)
LABEL_150:
    __CFStringHandleOutOfMemory();
  v148 = (v18 & 0x10) >> 4;
  if (!v152 || v32 != v29 || v151 && v149 >= 1 && (v18 & 0x10) == 0)
  {
    result = __CFStrAllocateMutableContents(result, v32);
    if (result)
      goto LABEL_159;
    if (v33)
    {
      v43 = v155;
      if (v30 >= v31)
      {
        if ((*(_BYTE *)(v155 + 40) & 8) != 0
          || (v30 >= 0 ? (v81 = v30) : (v81 = v30 + 1), v31 >= v30 && v81 >> 1 <= v31))
        {
LABEL_157:
          v32 = v30;
          if (v30 != -1)
          {
            result = __CFStrAllocateMutableContents(v43, v30);
            if (!result)
              __CFStringHandleOutOfMemory();
LABEL_159:
            v82 = atomic_load(v5);
            v49 = (v82 >> 2) & 1;
            v52 = result + v17;
            v47 = 1;
            v29 = v32;
            v50 = v151;
            v51 = v152;
            v53 = (v18 & 0x10) >> 4;
            v34 = v156;
            if (!v152)
              goto LABEL_171;
            goto LABEL_160;
          }
LABEL_267:
          __CFStringHandleOutOfMemory();
        }
      }
      if ((v31 & 0x8000000000000000) != 0)
        goto LABEL_267;
      if (v31 <= (*(_QWORD *)(v155 + 40) >> 4) * v156)
        v44 = (*(_QWORD *)(v155 + 40) >> 4) * v156;
      else
        v44 = v31;
      v45 = atomic_load((unint64_t *)(v155 + 8));
      if ((~v45 & 0x60) != 0)
        v46 = malloc_good_size(v44);
      else
        v46 = CFAllocatorGetPreferredSizeForSize(*(CFAllocatorRef *)(v155 + 48), v44, 0);
      if (v46 < 0)
        v30 = -1;
      else
        v30 = v46;
    }
    v43 = v155;
    goto LABEL_157;
  }
  v47 = 0;
  v48 = atomic_load(v5);
  v49 = (v48 >> 2) & 1;
  v50 = v151;
  v51 = v152;
  v52 = (uint64_t)&v152[v17];
  result = (uint64_t)v152;
  v53 = (v18 & 0x10) >> 4;
LABEL_160:
  v143 = result;
  v144 = v29;
  v83 = (v18 >> 4) & 1;
  v84 = (unsigned __int8 *)&v51[v49];
  if (v145 == v53)
  {
    v140 = v49;
    v141 = v47;
    v85 = a4;
    v86 = v154;
    if ((unsigned __int8 *)v52 != v84)
    {
      copyBlocks(v84, v52, v149, v83, (v18 >> 4) & 1, a2, v154, a4);
      goto LABEL_163;
    }
    if (v154 >= 1)
    {
      v111 = 0;
      v112 = 0;
      v142 = 0;
      v113 = 0;
      p_ptr = &ptr;
      v115 = 10;
      while (1)
      {
        v116 = (_QWORD *)(a2 + 16 * v112);
        v117 = v116[1];
        v118 = v117 + *v116;
        if (v86 - v112 == 1)
        {
          v119 = (v149 - v118) * v34;
          if (!v119)
            goto LABEL_257;
        }
        else
        {
          v119 = (v116[2] - v118) * v34;
        }
        v120 = v118 * v34;
        v111 += (v85 - v117) * v34;
        if (v111 <= 0)
        {
          if (v111)
            v123 = v119 == 0;
          else
            v123 = 1;
          if (!v123)
          {
            v124 = (void *)(v52 + v111 + v120);
            v125 = (const void *)(v52 + v120);
            v126 = p_ptr;
            v127 = v115;
            memmove(v124, v125, v119);
            v115 = v127;
            p_ptr = v126;
            v34 = v156;
          }
          if (v113 >= 1)
          {
            v146 = v115;
            v128 = v113 + 1;
            v129 = p_ptr;
            v130 = &p_ptr[24 * v113 - 8];
            v86 = v154;
            do
            {
              v131 = *((_QWORD *)v130 - 1);
              if (*(_QWORD *)v130)
                v132 = v131 == 0;
              else
                v132 = 1;
              if (!v132)
                memmove((void *)(v52 + *((_QWORD *)v130 - 2) + *(_QWORD *)v130), (const void *)(v52 + *((_QWORD *)v130 - 2)), v131);
              --v128;
              v130 -= 24;
            }
            while (v128 > 1);
            v113 = 0;
            v34 = v156;
            p_ptr = v129;
            v115 = v146;
            goto LABEL_256;
          }
        }
        else
        {
          if (v113 == v115)
          {
            v121 = p_ptr;
            v122 = 2 * v115 + 8;
            if (v142)
            {
              p_ptr = (char *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, p_ptr, 24 * v122, 0x1000040504FFAC1, 0, 0);
            }
            else
            {
              v147 = v115;
              Typed = (void *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 24 * v122, 0x1000040504FFAC1, 0);
              memmove(Typed, v121, 24 * v147);
              v142 = 1;
              p_ptr = (char *)Typed;
            }
            v34 = v156;
          }
          else
          {
            v122 = v115;
          }
          v133 = (uint64_t *)&p_ptr[24 * v113];
          *v133 = v120;
          v133[1] = v119;
          v133[2] = v111;
          ++v113;
          v115 = v122;
          v85 = a4;
        }
        v86 = v154;
LABEL_256:
        if (++v112 == v86)
        {
LABEL_257:
          v134 = p_ptr;
          v51 = v152;
          v53 = v148;
          if (v113 >= 1)
          {
            v135 = v113 + 1;
            v136 = &p_ptr[24 * v113 - 8];
            do
            {
              v137 = *((_QWORD *)v136 - 1);
              if (*(_QWORD *)v136)
                v138 = v137 == 0;
              else
                v138 = 1;
              if (!v138)
                memmove((void *)(v52 + *((_QWORD *)v136 - 2) + *(_QWORD *)v136), (const void *)(v52 + *((_QWORD *)v136 - 2)), v137);
              --v135;
              v136 -= 24;
            }
            while (v135 > 1);
          }
          if (v142)
            CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v134);
          break;
        }
      }
    }
LABEL_163:
    LOBYTE(v50) = v151;
    v49 = v140;
    v47 = v141;
  }
  else if (v50)
  {
    copyBlocks(v84, v52, v149, v83, 1, a2, v154, a4);
  }
  if (v47)
  {
    v87 = atomic_load(v5);
    if ((v87 & 0x20) != 0)
      __CFStrDeallocateMutableContents(v155, v51);
    v47 = 1;
  }
  result = v143;
  v29 = v144;
LABEL_171:
  if ((v50 & 1) != 0)
  {
    v88 = (unint64_t *)v155;
    if (!v53)
    {
      v89 = atomic_load(v5);
      while (1)
      {
        v90 = __ldaxr(v5);
        if (v90 != v89)
          break;
        if (__stlxr(v89 | 0x10, v5))
          goto LABEL_178;
        v91 = 1;
LABEL_179:
        v89 = v90;
        if (v91)
          goto LABEL_180;
      }
      __clrex();
LABEL_178:
      v91 = 0;
      goto LABEL_179;
    }
LABEL_180:
    if (v49)
    {
      v92 = atomic_load(v5);
      while (1)
      {
        v93 = __ldaxr(v5);
        if (v93 != v92)
          break;
        if (__stlxr(v92 & 0xFFFFFFFFFFFFFFFBLL, v5))
          goto LABEL_186;
        v94 = 1;
LABEL_187:
        v92 = v93;
        if (v94)
        {
          v95 = atomic_load(v5);
          while (1)
          {
            v96 = __ldaxr(v5);
            if (v96 != v95)
              break;
            if (__stlxr(v95 & 0xFFFFFFFFFFFFFFF7, v5))
              goto LABEL_193;
            v97 = 1;
LABEL_194:
            v95 = v96;
            if (v97)
              goto LABEL_222;
          }
          __clrex();
LABEL_193:
          v97 = 0;
          goto LABEL_194;
        }
      }
      __clrex();
LABEL_186:
      v94 = 0;
      goto LABEL_187;
    }
    goto LABEL_222;
  }
  *(_BYTE *)(v52 + v13) = 0;
  if (v13 <= 255)
    v98 = v13;
  else
    v98 = 0;
  *(_BYTE *)result = v98;
  v88 = (unint64_t *)v155;
  if (!v49)
  {
    v99 = atomic_load(v5);
    while (1)
    {
      v100 = __ldaxr(v5);
      if (v100 != v99)
        break;
      if (__stlxr(v99 | 4, v5))
        goto LABEL_205;
      v101 = 1;
LABEL_206:
      v99 = v100;
      if (v101)
      {
        v102 = atomic_load(v5);
        while (1)
        {
          v103 = __ldaxr(v5);
          if (v103 != v102)
            break;
          if (__stlxr(v102 | 8, v5))
            goto LABEL_212;
          v104 = 1;
LABEL_213:
          v102 = v103;
          if (v104)
            goto LABEL_214;
        }
        __clrex();
LABEL_212:
        v104 = 0;
        goto LABEL_213;
      }
    }
    __clrex();
LABEL_205:
    v101 = 0;
    goto LABEL_206;
  }
LABEL_214:
  if (v53)
  {
    v105 = atomic_load(v5);
    while (1)
    {
      v106 = __ldaxr(v5);
      if (v106 != v105)
        break;
      if (__stlxr(v105 & 0xFFFFFFFFFFFFFFEFLL, v5))
        goto LABEL_220;
      v107 = 1;
LABEL_221:
      v105 = v106;
      if ((v107 & 1) != 0)
        goto LABEL_222;
    }
    __clrex();
LABEL_220:
    v107 = 0;
    goto LABEL_221;
  }
LABEL_222:
  v108 = atomic_load(v88 + 1);
  v25 = (v108 & 0x60) == 0;
  v109 = 3;
  if (v25)
    v109 = 2;
  v88[v109] = v13;
  if (v47)
  {
    v110 = v88[5] & 0xFFFFFFFFFFFFFFF7;
    v88[4] = v29;
    v88[5] = v110;
    v88[2] = result;
  }
  return result;
}

uint64_t __CFStrAllocateMutableContents(uint64_t a1, uint64_t a2)
{
  char v2;
  const CFAllocatorRef *v3;
  char v4;
  uint64_t Typed;

  v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((~v2 & 0x60) != 0)
  {
    if (a1 < 0)
    {
      v3 = &kCFAllocatorSystemDefault;
    }
    else
    {
      v4 = atomic_load((unint64_t *)(a1 + 8));
      if (v4 < 0)
        v3 = &kCFAllocatorSystemDefault;
      else
        v3 = (const CFAllocatorRef *)(a1 - 16);
    }
  }
  else
  {
    v3 = (const CFAllocatorRef *)(a1 + 48);
  }
  Typed = CFAllocatorAllocateTyped(*v3, a2, 1802897708, 0);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  return Typed;
}

unint64_t CFStringConvertEncodingToNSStringEncoding(CFStringEncoding encoding)
{
  CFStringEncoding v1;
  unint64_t result;

  if (encoding == 134217984)
  {
    *(_QWORD *)&encoding = 4;
    goto LABEL_36;
  }
  if (encoding == 1536)
  {
    *(_QWORD *)&encoding = 1;
    goto LABEL_36;
  }
  v1 = encoding & 0xFFF;
  if (v1 <= 0x4FF)
  {
    if ((encoding & 0xFFF) > 0x200)
    {
      switch(v1)
      {
        case 0x201u:
          *(_QWORD *)&encoding = 5;
          goto LABEL_36;
        case 0x202u:
          *(_QWORD *)&encoding = 9;
          goto LABEL_36;
        case 0x420u:
          *(_QWORD *)&encoding = 8;
          goto LABEL_36;
      }
    }
    else
    {
      if ((encoding & 0xFFF) == 0)
      {
        *(_QWORD *)&encoding = 30;
        goto LABEL_36;
      }
      if (v1 == 33)
      {
        *(_QWORD *)&encoding = 6;
        goto LABEL_36;
      }
      if (v1 == 256 && encoding == 256)
      {
        *(_QWORD *)&encoding = 10;
        goto LABEL_36;
      }
    }
LABEL_26:
    *(_QWORD *)&encoding = encoding | 0x80000000;
    goto LABEL_36;
  }
  if ((encoding & 0xFFF) > 0x81F)
  {
    if ((encoding & 0xFFF) > 0xB00)
    {
      if (v1 == 2817)
      {
        *(_QWORD *)&encoding = 2;
        goto LABEL_36;
      }
      if (v1 == 3071)
      {
        *(_QWORD *)&encoding = 7;
        goto LABEL_36;
      }
    }
    else
    {
      if (v1 == 2080)
      {
        *(_QWORD *)&encoding = 21;
        goto LABEL_36;
      }
      if (v1 == 2336)
      {
        *(_QWORD *)&encoding = 3;
        goto LABEL_36;
      }
    }
    goto LABEL_26;
  }
  *(_QWORD *)&encoding = 12;
  switch(v1)
  {
    case 0x500u:
      break;
    case 0x501u:
      *(_QWORD *)&encoding = 15;
      break;
    case 0x502u:
      *(_QWORD *)&encoding = 11;
      break;
    case 0x503u:
      *(_QWORD *)&encoding = 13;
      break;
    case 0x504u:
      *(_QWORD *)&encoding = 14;
      break;
    default:
      goto LABEL_26;
  }
LABEL_36:
  LODWORD(result) = encoding;
  return result;
}

unint64_t _NSTaggedPointerStringGetBytes(uint64_t a1, unint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  BOOL v4;
  uint64_t v5;
  unint64_t result;
  unint64_t v7;
  char *v8;
  unint64_t v9;

  v2 = *MEMORY[0x1E0DE7C58];
  if ((~a1 & 0xC000000000000007) == 0)
    v2 = 0;
  v3 = v2 ^ a1;
  v4 = (~(v2 ^ a1) & 7) == 0;
  v5 = 0xFFFFFFFFFFFFFFFLL;
  if (v4)
    v5 = 0xFFFFFFFFFFFFFLL;
  result = (v3 >> 3) & 0xF;
  v7 = (v5 & (v3 >> 3)) >> 4;
  if (result < 8)
  {
    *a2 = v7;
  }
  else
  {
    v8 = (char *)a2 - 1;
    v9 = result;
    if (result >= 0xA)
    {
      do
      {
        v8[v9] = sixBitToCharLookup[v7 & 0x1F];
        v7 >>= 5;
        --v9;
      }
      while (v9);
    }
    else
    {
      do
      {
        v8[v9] = sixBitToCharLookup[v7 & 0x3F];
        v7 >>= 6;
        --v9;
      }
      while (v9);
    }
  }
  return result;
}

void cow_cleanup(uint64_t a1, int a2)
{
  int *v2;
  uint64_t v3;
  unint64_t v4;
  void **v5;
  uint64_t v6;
  id *v7;
  void **v8;
  uint64_t v9;
  void *v10;

  v2 = &OBJC_IVAR_____NSFrozenDictionaryM_storage;
  if (a2 == 1)
    v2 = &OBJC_IVAR_____NSDictionaryM_storage;
  v3 = a1 + *v2;
  v5 = *(void ***)v3;
  v4 = *(_QWORD *)(v3 + 8);
  v6 = LODWORD(__NSDictionarySizes_0[v4 >> 58]);
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = v4 & 0x2000000FFFFFFFFLL;
  if (v4 >> 58)
  {
    v7 = &v5[v6];
    v8 = v5;
    v9 = v6;
    do
    {
      v10 = *v8;
      if ((uint64_t)*v8 >= 1 && v10 != &___NSDictionaryM_DeletedMarker)

      ++v8;
      --v9;
    }
    while (v9);
    do
    {
      if ((uint64_t)*v7 >= 1)

      ++v7;
      --v6;
    }
    while (v6);
  }
  free(v5);
}

void _CFRelease(void *ptr)
{
  unint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  CFIndex v9;
  unint64_t v10;
  int v11;
  void (*v12)(void *);
  unint64_t v13;
  int v14;
  void (*v15)(void *);
  unint64_t v16;
  BOOL v17;
  char v18;
  unint64_t v19;
  char v20;
  unint64_t v21;
  char v22;
  __objc2_class **v23;
  const __CFAllocator *v24;
  _BOOL4 v25;
  CFAllocatorRef v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  Class Class;
  objc_class *v31;
  unint64_t v32;
  uint64_t *v33;
  int v34;
  uint64_t *v35;
  objc_class *v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  const char *v40;
  objc_class *v41;
  objc_class *v42;
  int v43;
  uint64_t v44;
  char v45;
  const CFAllocatorRef *v46;
  void (*v47)(uint64_t, void *);
  char *name[33];

  name[32] = *(char **)MEMORY[0x1E0C80C00];
  v2 = (unint64_t *)((char *)ptr + 8);
  v3 = atomic_load((unint64_t *)ptr + 1);
  v4 = (v3 >> 8) & 0x3FF;
  if (v4 > 0x47)
  {
    v6 = v4 - 72;
    if ((int)v4 - 72 >= dword_1ECCFAFE8 || (v7 = __CFRuntimeClassTables[v6 >> 6]) == 0)
    {
      v8 = 0;
      if ((v3 & 0x200000) == 0)
        goto LABEL_7;
LABEL_49:
      _CFRelease_cold_3((char *)name, v8);
    }
    v5 = (uint64_t *)(v7 + 8 * (v6 & 0x3F));
  }
  else
  {
    v5 = (uint64_t *)(&__CFRuntimeBuiltinClassTable + v4);
  }
  v8 = *v5;
  if ((v3 & 0x200000) != 0)
    goto LABEL_49;
LABEL_7:
  if (!__CFOASafe)
  {
    v9 = 0;
    if ((v3 & 0x800000) == 0)
      goto LABEL_9;
    goto LABEL_104;
  }
  v9 = CFGetRetainCount(ptr);
  if ((v3 & 0x800000) != 0)
  {
LABEL_104:
    v47 = *(void (**)(uint64_t, void *))(v8 + 80);
    if (!v47 || (*(_BYTE *)v8 & 8) == 0)
      _CFRelease_cold_1();
    if (v3 <= 0xFFFEFFFFFFFFFFFFLL)
      _CFRelease_cold_2();
    v47(-1, ptr);
LABEL_108:
    if (__CFOASafe)
    {
      if (__CFObjectAllocRecordAllocationFunction)
        __CFObjectAllocRecordAllocationFunction(29, ptr, 0, v9 - 1, 0);
    }
    return;
  }
  while (1)
  {
LABEL_9:
    while (HIWORD(v3) != 1)
    {
      if (!HIWORD(v3))
        return;
      while (1)
      {
        v10 = __ldaxr(v2);
        if (v10 != v3)
          break;
        if (!__stlxr(v3 - 0x1000000000000, v2))
        {
          v11 = 1;
          goto LABEL_21;
        }
      }
      v11 = 0;
      __clrex();
LABEL_21:
      v3 = v10;
      if (v11)
        goto LABEL_108;
    }
    if ((*(_BYTE *)v8 & 4) != 0)
    {
      v12 = *(void (**)(void *))(v8 + 72);
      if (v12)
        v12(ptr);
    }
    while (1)
    {
      v13 = __ldaxr(v2);
      if (v13 != v3)
        break;
      if (!__stlxr(v3 | 0x400000, v2))
      {
        v14 = 1;
        goto LABEL_24;
      }
    }
    v14 = 0;
    __clrex();
LABEL_24:
    v3 = v13;
    if (v14)
    {
      v15 = *(void (**)(void *))(v8 + 32);
      if (v15)
        v15(ptr);
      v16 = atomic_load(v2);
      v17 = v4 == 2 || HIWORD(v16) == 1;
      v18 = v17;
      if (!v17)
      {
        while (1)
        {
          v3 = atomic_load(v2);
          while (1)
          {
            v21 = __ldaxr(v2);
            if (v21 != v3)
              break;
            if (!__stlxr(v3 & 0xFFFFFFFFFFBFFFFFLL, v2))
              goto LABEL_41;
          }
          __clrex();
        }
      }
      do
      {
        v3 = v16;
        v19 = (v16 | 0x200000) - 0x1000000000000;
        while (1)
        {
          v16 = __ldaxr(v2);
          if (v16 != v3)
            break;
          if (!__stlxr(v19, v2))
          {
            v20 = 1;
            goto LABEL_40;
          }
        }
        v20 = 0;
        __clrex();
LABEL_40:
        ;
      }
      while ((v20 & 1) == 0);
LABEL_41:
      if ((v18 & 1) != 0)
        break;
    }
  }
  if (__CFOASafe && __CFObjectAllocRecordAllocationFunction)
    __CFObjectAllocRecordAllocationFunction(29, ptr, 0, 0, 0);
  if (v4 == 2)
  {
    __CFAllocatorDeallocate(ptr);
    return;
  }
  v22 = atomic_load(v2);
  if (v22 < 0)
  {
    v26 = 0;
    v25 = 1;
    v24 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  else
  {
    v23 = (__objc2_class **)CFGetAllocator(ptr);
    v24 = (const __CFAllocator *)v23;
    if (&__kCFAllocatorSystemDefault == v23)
    {
      v25 = 1;
    }
    else if (v23)
    {
      v25 = 0;
    }
    else
    {
      v25 = &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault();
    }
    if (((unint64_t)ptr & 0x8000000000000000) != 0
      || (v27 = atomic_load((unint64_t *)ptr + 1),
          CF_IS_OBJC((v27 >> 8) & 0x3FF, (__objc2_class **)ptr))
      || (v28 = atomic_load(v2), (v28 & 0x3FF00) == 0x200))
    {
      v26 = 0;
    }
    else
    {
      v45 = atomic_load(v2);
      if (v45 < 0)
        v46 = &kCFAllocatorSystemDefault;
      else
        v46 = (const CFAllocatorRef *)((char *)ptr - 16);
      v26 = *v46;
    }
  }
  v29 = __CFZombieEnabled;
  Class = object_getClass(ptr);
  v31 = Class;
  if (!v29)
  {
    if (object_getClass(Class))
      objc_destructInstance(ptr);
    goto LABEL_95;
  }
  os_unfair_lock_lock_with_options();
  v32 = 0;
  v33 = (uint64_t *)&__CFRuntimeBuiltinClassTable;
  while (v32 < dword_1ECCFAFE8 + 72)
  {
    v34 = v32 - 72;
    if (v32 >= 0x48)
    {
      if (v34 >= dword_1ECCFAFE8)
      {
        v36 = 0;
      }
      else
      {
        v36 = (objc_class *)__CFRuntimeClassTables[(v34 >> 6) + 16];
        if (v36)
          v36 = (objc_class *)*((_QWORD *)v36 + (v34 & 0x3F));
      }
      if (v36 != v31 || v34 >= dword_1ECCFAFE8 || (v37 = __CFRuntimeClassTables[v34 >> 6]) == 0)
      {
LABEL_80:
        v39 = 0;
        goto LABEL_81;
      }
      v35 = (uint64_t *)(v37 + 8 * (v34 & 0x3F));
    }
    else
    {
      v35 = v33;
      if ((objc_class *)__CFRuntimeBuiltinObjCClassTable[v32] != v31)
        goto LABEL_80;
    }
    v38 = *v35;
    if (!v38)
      goto LABEL_80;
    v39 = *(const char **)(v38 + 8);
LABEL_81:
    ++v32;
    ++v33;
    if (v39)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
      goto LABEL_88;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
  if (object_getClass(v31))
    v39 = class_getName(v31);
  else
    v39 = 0;
LABEL_88:
  v40 = "$class-unknown$";
  if (v39)
    v40 = v39;
  name[0] = 0;
  asprintf(name, "_NSZombie_%s", v40);
  v41 = objc_lookUpClass(name[0]);
  if (!v41)
  {
    v42 = objc_lookUpClass("_NSZombie_");
    v41 = objc_duplicateClass(v42, name[0], 0);
  }
  free(name[0]);
  if (object_getClass(v31))
    objc_destructInstance(ptr);
  v43 = __CFDeallocateZombies;
  object_setClass(ptr, v41);
  if (v43)
  {
LABEL_95:
    v44 = -16;
    if (v25)
      v44 = 0;
    CFAllocatorDeallocate(v24, (char *)ptr + v44);
  }
  if (v26)
    CFRelease(v26);
}

void CFAllocatorDeallocate(CFAllocatorRef allocator, void *ptr)
{
  malloc_zone_t *v3;
  uint64_t v4;
  void *(__cdecl *valloc)(_malloc_zone_t *, size_t);

  v3 = (malloc_zone_t *)allocator;
  if (!allocator)
  {
    v4 = _CFGetTSD(1u);
    if (v4)
      v3 = (malloc_zone_t *)v4;
    else
      v3 = (malloc_zone_t *)&__kCFAllocatorSystemDefault;
  }
  if (v3->reserved1 != (void *)qword_1ECCFACA8)
    malloc_zone_free(v3, ptr);
  if (ptr)
  {
    valloc = v3[1].valloc;
    if (valloc)
      ((void (*)(void *, void (__cdecl *)(_malloc_zone_t *, void *)))valloc)(ptr, v3->try_free_default);
  }
}

void __CFAllocatorSystemDeallocate(void *ptr, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder)
    zone = malloc_default_zone();
  malloc_zone_free(zone, ptr);
}

uint64_t _CFRuntimeCreateInstance(__objc2_class **a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t result;
  int v10;
  uint64_t v11;
  uint64_t v12;
  __objc2_class **v13;
  __objc2_class **v14;
  uint64_t v15;
  unint64_t *v16;
  _BOOL4 v17;
  size_t v18;
  size_t v19;
  malloc_type_id_t v20;
  unint64_t *v21;
  malloc_zone_t *v22;
  uint64_t (*v23)(void);
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  CFTypeRef v27;
  uint64_t v28;
  uint64_t v29;
  objc_class **v30;
  int v31;
  uint64_t v32;
  objc_class *v33;
  void (*v34)(unint64_t *);
  unint64_t *Typed;

  if (a2 <= 0x47)
  {
    v8 = (uint64_t *)*(&__CFRuntimeBuiltinClassTable + a2);
    if (!v8)
      return 0;
LABEL_10:
    v12 = *v8;
    if ((*v8 & 0x10) != 0)
      v13 = &__kCFAllocatorSystemDefault;
    else
      v13 = a1;
    if ((v12 & 8) != 0 && !v8[10])
    {
      CFLog(4, CFSTR("*** _CFRuntimeCreateInstance() found inconsistent class '%s'."));
      return 0;
    }
    v14 = v13;
    if (!v13)
    {
      v15 = _CFGetTSD(1u);
      if (v15)
        v14 = (__objc2_class **)v15;
      else
        v14 = &__kCFAllocatorSystemDefault;
    }
    if (&__kCFAllocatorNull == v14)
      return 0;
    if (&__kCFAllocatorSystemDefault == v14)
    {
      v17 = 1;
    }
    else if (v14)
    {
      v17 = 0;
    }
    else
    {
      v17 = &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault();
    }
    if ((*v8 & 0x10) != 0)
      v18 = v8[11];
    else
      v18 = 16;
    v19 = (a3 + 16 * !v17 + 31) & 0xFFFFFFFFFFFFFFF0;
    v20 = (403 * (a2 ^ 0xC9DC5)) & 0xFFFFFLL | 0xCF000000;
    if ((*v8 & 0x10) != 0)
    {
      v22 = malloc_default_zone();
      v21 = (unint64_t *)malloc_type_zone_memalign(v22, v18, v19, v20);
    }
    else
    {
      if (!__CFAllocatorRespectsHintZeroWhenAllocating(v13))
      {
        Typed = (unint64_t *)CFAllocatorAllocateTyped(v13, v19, v20, 0);
        v16 = Typed;
        if (!Typed)
          return (uint64_t)v16;
        bzero(Typed, v19);
        goto LABEL_36;
      }
      v21 = (unint64_t *)CFAllocatorAllocateTyped(v13, v19, v20, 1);
    }
    v16 = v21;
    if (!v21)
      return (uint64_t)v16;
LABEL_36:
    if (a4 && __CFOASafe)
    {
      v23 = __CFObjectAllocSetLastAllocEventNameFunction;
      if (!__CFObjectAllocSetLastAllocEventNameFunction)
        goto LABEL_44;
      v24 = v16;
      v25 = a4;
    }
    else
    {
      if (!__CFOASafe)
        goto LABEL_44;
      v23 = __CFObjectAllocSetLastAllocEventNameFunction;
      if (!__CFObjectAllocSetLastAllocEventNameFunction)
        goto LABEL_44;
      v25 = v8[1];
      v24 = v16;
    }
    ((void (*)(unint64_t *, uint64_t))v23)(v24, v25);
LABEL_44:
    if (v17)
    {
      v26 = 128;
    }
    else
    {
      v27 = CFRetain(v14);
      v26 = 0;
      *v16 = (unint64_t)v27;
      v16 += 2;
    }
    v28 = v26 | ((_DWORD)a2 << 8);
    v29 = -8388608;
    if ((v12 & 8) == 0)
      v29 = 0x1000000000000;
    atomic_store(v28 | v29, v16 + 1);
    *v16 = 0;
    if (a2 > 0x47)
    {
      v31 = a2 - 72;
      if ((int)a2 - 72 >= dword_1ECCFAFE8 || (v32 = __CFRuntimeClassTables[(v31 >> 6) + 16]) == 0)
      {
        v33 = 0;
LABEL_56:
        object_setClass(v16, v33);
        v34 = (void (*)(unint64_t *))v8[2];
        if (v34)
          v34(v16);
        return (uint64_t)v16;
      }
      v30 = (objc_class **)(v32 + 8 * (v31 & 0x3F));
    }
    else
    {
      v30 = (objc_class **)&__CFRuntimeBuiltinObjCClassTable[a2];
    }
    v33 = *v30;
    goto LABEL_56;
  }
  result = os_unfair_lock_lock_with_options();
  if (dword_1ECCFAFE8 + 72 > a2)
  {
    v10 = a2 - 72;
    if ((int)a2 - 72 < dword_1ECCFAFE8 && (v11 = __CFRuntimeClassTables[v10 >> 6]) != 0)
      v8 = *(uint64_t **)(v11 + 8 * (v10 & 0x3F));
    else
      v8 = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFBigRuntimeFunnel);
    if (!v8)
      return 0;
    goto LABEL_10;
  }
  __break(1u);
  return result;
}

void *__cdecl CFAllocatorAllocate(CFAllocatorRef allocator, CFIndex size, CFOptionFlags hint)
{
  unint64_t v3;

  return _CFAllocatorAllocateImpl((malloc_zone_t *)allocator, size, (v3 >> 2), hint);
}

void *__CFAllocatorSystemAllocate(size_t size, uint64_t a2, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder)
    zone = malloc_default_zone();
  if (a2 == 1)
    return malloc_type_zone_calloc(zone, 1uLL, size, 0x53AEF0D3uLL);
  else
    return malloc_type_zone_malloc(zone, size, 0xD90F5EB9uLL);
}

BOOL __CFAllocatorRespectsHintZeroWhenAllocating(__objc2_class **a1)
{
  return a1 == &__kCFAllocatorSystemDefault || a1 == &__kCFAllocatorMallocZone;
}

void __CFStringDeallocate(uint64_t a1)
{
  unint64_t *v1;
  char v2;
  char v4;
  char v5;
  char v6;
  void **v7;
  void **v8;
  char v9;
  char v10;
  BOOL v11;
  uint64_t v12;
  const __CFAllocator *v13;
  const __CFAllocator *v14;
  char v15;
  char v16;
  CFAllocatorRef *v17;
  char v18;

  v1 = (unint64_t *)(a1 + 8);
  v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x60) == 0)
    return;
  v4 = atomic_load(v1);
  v5 = atomic_load(v1);
  if ((v5 & 0x20) == 0)
    goto LABEL_11;
  v6 = atomic_load((unint64_t *)(a1 + 8));
  v7 = (void **)(a1 + 16);
  if ((v6 & 0x60) == 0)
  {
    v15 = atomic_load((unint64_t *)(a1 + 8));
    v8 = &v7[(v15 & 5) != 4];
    if (v8)
      goto LABEL_5;
LABEL_11:
    if ((v4 & 1) == 0)
      return;
    goto LABEL_14;
  }
  v8 = (void **)*v7;
  if (!*v7)
    goto LABEL_11;
LABEL_5:
  if ((v4 & 1) == 0)
  {
    v9 = atomic_load((unint64_t *)(a1 + 8));
    if ((~v9 & 0x60) == 0)
    {
      v10 = atomic_load((unint64_t *)(a1 + 8));
      v11 = (v10 & 5) == 4;
      v12 = 32;
      if (v11)
        v12 = 24;
      v13 = *(const __CFAllocator **)(a1 + v12);
      CFAllocatorDeallocate(v13, v8);
      v14 = v13;
      goto LABEL_16;
    }
    if (a1 < 0)
    {
      v17 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    }
    else
    {
      v18 = atomic_load((unint64_t *)(a1 + 8));
      if (v18 < 0)
        v17 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
      else
        v17 = (CFAllocatorRef *)(a1 - 16);
    }
    CFAllocatorDeallocate(*v17, v8);
    return;
  }
  __CFStrDeallocateMutableContents(a1, v8);
LABEL_14:
  v16 = atomic_load((unint64_t *)(a1 + 8));
  if ((~v16 & 0x60) == 0)
  {
    v14 = *(const __CFAllocator **)(a1 + 48);
LABEL_16:
    CFRelease(v14);
  }
}

void __CFBasicHashAddValue(uint64_t cf, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7;
  int v8;
  unint64_t Bucket_Exponential_Indirect_NoCollision;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(const CFAllocatorRef, uint64_t);
  const CFAllocatorRef *v13;
  char v14;
  uint64_t (*v15)(const CFAllocatorRef, unint64_t);
  char v16;
  const CFAllocatorRef *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(const CFAllocatorRef, uint64_t);
  char v23;
  const CFAllocatorRef *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(const CFAllocatorRef, uint64_t);
  char v31;
  const CFAllocatorRef *v32;

  ++*(_WORD *)(cf + 16);
  v7 = *(_QWORD *)(cf + 24);
  if (__CFBasicHashTableCapacities[BYTE2(v7)] >= (uint64_t)(*(_DWORD *)(cf + 20) + 1))
  {
    v10 = a2;
    if (*(_QWORD *)(*(_QWORD *)(cf + 40) + 8 * a2) == -1)
    {
      v11 = *(_QWORD *)(cf + 32);
      *(_QWORD *)(cf + 24) = v7 & 0xFFFFFFFFFFFF0000 | (unsigned __int16)(v7 - 1);
      *(_QWORD *)(cf + 32) = v11;
    }
    goto LABEL_20;
  }
  __CFBasicHashRehash(cf, 1);
  if (!*(_BYTE *)(cf + 26))
  {
    v10 = -1;
    goto LABEL_20;
  }
  v8 = *(_WORD *)(cf + 18) & 3;
  if ((*(_WORD *)(cf + 18) & 0x8000) != 0)
  {
    switch(v8)
    {
      case 3:
        Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision(cf, a3);
        goto LABEL_19;
      case 2:
        Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_Indirect_NoCollision(cf, a3);
        goto LABEL_19;
      case 1:
        Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(cf, a3);
        goto LABEL_19;
    }
LABEL_76:
    __break(1u);
    return;
  }
  if (v8 == 3)
  {
    Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_NoCollision(cf, a3);
    goto LABEL_19;
  }
  if (v8 == 2)
  {
    Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_NoCollision(cf, a3);
    goto LABEL_19;
  }
  if (v8 != 1)
    goto LABEL_76;
  Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_NoCollision(cf, a3);
LABEL_19:
  v10 = Bucket_Exponential_Indirect_NoCollision;
LABEL_20:
  if ((*(_QWORD *)(cf + 32) & 2) == 0)
  {
    v12 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(cf + 24) >> 39) & 0x1FLL]
                                                                  + 8 * ((*(_QWORD *)(cf + 24) >> 34) & 0x1FLL));
    if (v12)
    {
      if (cf < 0)
      {
        v13 = &kCFAllocatorSystemDefault;
      }
      else
      {
        v14 = atomic_load((unint64_t *)(cf + 8));
        if (v14 < 0)
          v13 = &kCFAllocatorSystemDefault;
        else
          v13 = (const CFAllocatorRef *)(cf - 16);
      }
      a4 = v12(*v13, a4);
    }
  }
  if ((*(_WORD *)(cf + 18) & 4) != 0 && (*(_QWORD *)(cf + 32) & 2) == 0)
  {
    v15 = *(uint64_t (**)(const CFAllocatorRef, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(cf + 27) >> 5) & 0x1F]
                                                                           + 8 * (*(_DWORD *)(cf + 27) & 0x1FLL));
    if (v15)
    {
      if (cf < 0 || (v16 = atomic_load((unint64_t *)(cf + 8)), v16 < 0))
        v17 = &kCFAllocatorSystemDefault;
      else
        v17 = (const CFAllocatorRef *)(cf - 16);
      a3 = v15(*v17, a3);
    }
  }
  v18 = *(_QWORD *)(cf + 40);
  v19 = *(_QWORD *)(v18 + 8 * v10);
  if (a4)
    v20 = a4;
  else
    v20 = 2814029233;
  if (v20 == -1)
    v20 = 2780474809;
  *(_QWORD *)(v18 + 8 * v10) = v20;
  if ((unint64_t)(v19 + 1) >= 2)
  {
    if (v19 == 2814029233)
      v19 = 0;
    if (v19 == 2780474809)
      v21 = -1;
    else
      v21 = v19;
    if ((*(_QWORD *)(cf + 32) & 2) == 0)
    {
      v22 = *(void (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                              + (HIBYTE(*(_QWORD *)(cf + 24)) & 0xF8))
                                                                 + 8 * ((*(_QWORD *)(cf + 24) >> 54) & 0x1FLL));
      if (v22)
      {
        if (cf < 0 || (v23 = atomic_load((unint64_t *)(cf + 8)), v23 < 0))
          v24 = &kCFAllocatorSystemDefault;
        else
          v24 = (const CFAllocatorRef *)(cf - 16);
        v22(*v24, v21);
      }
    }
  }
  v25 = *(unsigned __int16 *)(cf + 18);
  if ((v25 & 4) != 0)
  {
    v26 = *(_QWORD *)(cf + 8 * ((v25 >> 2) & 1) + 40);
    v27 = *(_QWORD *)(v26 + 8 * v10);
    if (a3)
      v28 = a3;
    else
      v28 = 2814029233;
    if (v28 == -1)
      v28 = 2780474809;
    *(_QWORD *)(v26 + 8 * v10) = v28;
    if ((unint64_t)(v27 + 1) >= 2)
    {
      if (v27 == 2814029233)
        v27 = 0;
      if (v27 == 2780474809)
        v29 = -1;
      else
        v29 = v27;
      if ((*(_QWORD *)(cf + 32) & 2) == 0)
      {
        v30 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(cf + 24) >> 49) & 0x1FLL]
                                                                   + 8 * ((*(_QWORD *)(cf + 24) >> 44) & 0x1FLL));
        if (v30)
        {
          if (cf < 0 || (v31 = atomic_load((unint64_t *)(cf + 8)), v31 < 0))
            v32 = &kCFAllocatorSystemDefault;
          else
            v32 = (const CFAllocatorRef *)(cf - 16);
          v30(*v32, v29);
        }
      }
    }
  }
  if ((*(_WORD *)(cf + 18) & 0x18) != 0)
    __CFBasicHashIncSlotCount(cf);
  ++*(_DWORD *)(cf + 20);
}

CFTypeRef __CFStringCreateImmutableFunnel3(__objc2_class **allocator, int8x16_t *ptr, int64_t a3, uint64_t a4, unsigned int a5, const __CFAllocator *a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  size_t v13;
  __objc2_class **v15;
  uint64_t v16;
  const __CFAllocator *v17;
  uint64_t v18;
  int v19;
  int v20;
  unint64_t Instance;
  int v22;
  int v23;
  unint64_t v24;
  int8x16_t *v25;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;
  BOOL v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  size_t v33;
  unint64_t v34;
  uint64_t Typed;
  int8x16_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int32 v40;
  uint64_t v41;
  int v42;
  int8x16_t *v43;
  uint64_t v44;
  uint64_t v45;
  int8x16_t *v46;
  unsigned __int8 *v47;
  int8x16_t *v48;
  unint64_t v49;
  unsigned __int8 *v50;
  uint64_t v51;
  unint64_t v52;
  unsigned __int8 *v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unsigned __int8 *v58;
  unint64_t v59;
  unint64_t v60;
  _BOOL4 v61;
  unsigned int v62;
  size_t v63;
  BOOL v64;
  uint64_t v65;
  uint64_t v66;
  int8x16_t *v67;
  __CFString *v68;
  __CFString *v69;
  BOOL v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  int v79;
  unint64_t v80;
  unint64_t v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  int v85;
  char v86;
  char v87;
  uint64_t v88;
  char v89;
  uint64_t v90;
  char v91;
  _BYTE **v92;
  _BYTE *v93;
  char v94;
  char v95;
  unint64_t v97;
  unsigned __int8 *v98;
  int8x16_t *v99;
  int8x16_t *v100;
  int v101;
  BOOL v102;
  int v103;
  _BOOL4 v104;
  uint64_t v105;
  __int128 v106;
  CFAllocatorRef allocatora[2];
  _OWORD v108[63];
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  v7 = (a5 >> 2) & 1;
  v104 = (a5 & 0x30) != 0;
  v8 = a3 - v7;
  if (a3 < v7)
  {
    if (dyld_program_sdk_at_least())
      __CFStringCreateImmutableFunnel3_cold_1();
    return 0;
  }
  v13 = a3;
  v15 = allocator;
  v101 = a5 & 0x30;
  memset(v108, 0, 480);
  v106 = 0u;
  *(_OWORD *)allocatora = 0u;
  if (!allocator)
  {
    v16 = _CFGetTSD(1u);
    if (v16)
      v15 = (__objc2_class **)v16;
    else
      v15 = &__kCFAllocatorSystemDefault;
  }
  v17 = (const __CFAllocator *)v15;
  if (a6 != (const __CFAllocator *)-1)
  {
    if (a6)
    {
      v17 = a6;
      if (v13)
        goto LABEL_19;
      goto LABEL_16;
    }
    v18 = _CFGetTSD(1u);
    if (v18)
      v17 = (const __CFAllocator *)v18;
    else
      v17 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  if (v13)
    goto LABEL_19;
LABEL_16:
  if (&__kCFAllocatorSystemDefault == v15
    || !v15 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault())
  {
    if (v101 && v17 != (const __CFAllocator *)&__kCFAllocatorNull)
      CFAllocatorDeallocate(v17, ptr);
    return CFRetain(&stru_1E1337B18);
  }
LABEL_19:
  v19 = 0;
  v103 = (a5 >> 3) & 1;
  BYTE9(v106) = 0;
  if ((_DWORD)a4 != 256)
  {
    v20 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      v20 = __CFDefaultEightBitStringEncoding;
    }
    if ((_DWORD)a4 == 1536 || v20 != (_DWORD)a4)
    {
      v19 = 0;
      switch(BYTE1(a4))
      {
        case 0:
          v19 = 0;
          if ((a4 > 0x22 || ((1 << a4) & 0x600000032) == 0) && (_DWORD)a4 != 152)
            goto LABEL_47;
          goto LABEL_51;
        case 1:
          if ((_DWORD)a4 == 134217984)
            goto LABEL_47;
          goto LABEL_50;
        case 2:
          if ((_DWORD)a4 == 518)
            goto LABEL_50;
          goto LABEL_47;
        case 6:
          if ((_DWORD)a4 != 1536)
            goto LABEL_50;
          goto LABEL_47;
        case 8:
        case 0xC:
          goto LABEL_51;
        case 0xA:
          if ((a4 - 2561) > 0xF)
            goto LABEL_47;
          v22 = 1 << (a4 - 1);
          v23 = 32785;
          break;
        case 0xB:
          if ((a4 - 3059) > 0xC)
            goto LABEL_47;
          v22 = 1 << (a4 + 13);
          v23 = 4099;
          break;
        default:
          if (((unsigned __int16)a4 & 0xFF00u) > 0xC00)
            goto LABEL_50;
          goto LABEL_47;
      }
      if ((v22 & v23) != 0)
      {
LABEL_50:
        v19 = 0;
      }
      else
      {
LABEL_47:
        v24 = v13;
        v25 = ptr;
        while (v24 > 0x1F)
        {
          v27 = *v25;
          v26 = v25[1];
          v25 += 2;
          v28 = vorrq_s8(v27, v26);
          v24 -= 32;
          if ((*(_QWORD *)&vorr_s8(*(int8x8_t *)v28.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v28, v28, 8uLL)) & 0x8080808080808080) != 0)
            goto LABEL_50;
        }
        while (v24 > 0xF)
        {
          v19 = 0;
          v37 = v25->i64[0];
          v38 = v25->i64[1];
          ++v25;
          v24 -= 16;
          if (((v38 | v37) & 0x8080808080808080) != 0)
            goto LABEL_51;
        }
        while (v24 > 7)
        {
          v19 = 0;
          v39 = v25->i64[0];
          v25 = (int8x16_t *)((char *)v25 + 8);
          v24 -= 8;
          if ((v39 & 0x8080808080808080) != 0)
            goto LABEL_51;
        }
        while (v24 > 3)
        {
          v19 = 0;
          v40 = v25->i32[0];
          v25 = (int8x16_t *)((char *)v25 + 4);
          v24 -= 4;
          if ((v40 & 0x80808080) != 0)
            goto LABEL_51;
        }
        v41 = 0;
        do
        {
          v19 = v24 == v41;
          if (v24 == v41)
            break;
          v42 = v25->i8[v41++];
        }
        while ((v42 & 0x80000000) == 0);
      }
    }
    else
    {
      v19 = 1;
    }
  }
LABEL_51:
  v29 = (a5 & 1) == 0;
  if ((_DWORD)a4 != 256)
    v29 = v19;
  if (!v29)
  {
    LOBYTE(v105) = 0;
    allocatora[0] = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    *(_QWORD *)&v106 = 0;
    if (!__CFStringDecodeByteStream3(&ptr->i8[v7], v8, a4, 0, (uint64_t)&v106, &v105, a7))
      return 0;
    v19 = BYTE8(v106);
    if (BYTE8(v106))
      LODWORD(a4) = 1536;
    else
      LODWORD(a4) = 256;
    if (!(_BYTE)v105)
    {
      v13 = (uint64_t)allocatora[1] << (BYTE8(v106) == 0);
      if (v101 && v17 != (const __CFAllocator *)&__kCFAllocatorNull)
        CFAllocatorDeallocate(v17, ptr);
      if (BYTE9(v106) && v15 == (__objc2_class **)allocatora[0] && !v19)
      {
        BYTE9(v106) = 0;
        ptr = (int8x16_t *)__CFSafelyReallocateWithAllocatorTyped(v15, v106, v13, 1283844863, 0, 0);
        LODWORD(v7) = 0;
        v103 = 0;
        v104 = 1;
      }
      else
      {
        LODWORD(v7) = 0;
        v103 = 0;
        v104 = 0;
        ptr = (int8x16_t *)v106;
      }
      v17 = (const __CFAllocator *)v15;
    }
    goto LABEL_109;
  }
  if ((_DWORD)a4 == 256 && (a5 & 2) != 0)
  {
    v30 = v13 >> 1;
    if (v13 >= 2)
    {
      v31 = 0;
      if (v30 <= 1)
        v32 = 1;
      else
        v32 = v13 >> 1;
      while (ptr->u16[v31] <= 0x7Fu)
      {
        if (v32 == ++v31)
          goto LABEL_62;
      }
      LODWORD(a4) = 256;
      goto LABEL_109;
    }
LABEL_62:
    a4 = v13 < 0x200;
    if (v13 >= 0x200)
      v33 = v13 >> 1;
    else
      v33 = v30 + 1;
    v34 = v33 + 1;
    if (v33 + 1 < 0x3F0)
    {
      v36 = (int8x16_t *)v108;
    }
    else
    {
      Typed = CFAllocatorAllocateTyped(v15, v33 + 1, 1908973194, 0);
      v36 = (int8x16_t *)Typed;
      if (__CFOASafe)
      {
        v100 = (int8x16_t *)Typed;
        __CFSetLastAllocationEventName();
        v36 = v100;
      }
      if (!v36)
      {
        LODWORD(a4) = 256;
        v13 = v34;
        goto LABEL_109;
      }
    }
    v43 = v36;
    if (v13 > 0x1FF || (v36->i8[0] = v30, v43 = (int8x16_t *)&v36->i8[1], v13 >= 2))
    {
      v44 = 0;
      if (v30 <= 1)
        v45 = 1;
      else
        v45 = v13 >> 1;
      do
      {
        v43->i8[v44] = ptr->i16[v44];
        ++v44;
      }
      while (v45 != v44);
    }
    v43->i8[v30] = 0;
    if (v101 && v17 != (const __CFAllocator *)&__kCFAllocatorNull)
    {
      v46 = v36;
      CFAllocatorDeallocate(v17, ptr);
      v36 = v46;
    }
    v104 = v34 > 0x3EF;
    v13 = v30 + a4;
    v47 = &v36->u8[a4];
    LODWORD(v7) = a4;
    LODWORD(a4) = 1536;
    v17 = (const __CFAllocator *)v15;
    v102 = v7;
    v103 = 1;
    goto LABEL_111;
  }
LABEL_109:
  v102 = (_DWORD)v7 != 0;
  v30 = v13 - v7;
  if (!v19)
    goto LABEL_141;
  v47 = &ptr->u8[v7];
  v36 = ptr;
LABEL_111:
  if (!__CFTaggedStringClass)
    goto LABEL_133;
  if ((uint64_t)v30 <= 7)
  {
    v48 = v36;
    v105 = 0;
    v49 = v30;
    v50 = v47;
    __memmove_chk();
    if ((v105 & 0x8080808080808080) != 0)
    {
      v36 = v48;
      v47 = v50;
      v30 = v49;
      goto LABEL_133;
    }
    v55 = v49;
    Instance = (8 * v49) | (v105 << 7) | 0x8000000000000002;
    v56 = *MEMORY[0x1E0DE7C58] ^ Instance;
    v36 = v48;
    if ((~v56 & 0xC000000000000007) != 0)
      Instance = v56 & 0xFFFFFFFFFFFFFFF8 | *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + (v56 & 7));
    v47 = v50;
    v30 = v55;
    if (!Instance)
      goto LABEL_133;
LABEL_130:
    ptr = 0;
    if (!v104 || v17 == (const __CFAllocator *)&__kCFAllocatorNull)
      goto LABEL_227;
    CFAllocatorDeallocate(v17, v36);
    goto LABEL_158;
  }
  if (v30 > 0xB)
    goto LABEL_133;
  if (v30 < 0xA)
  {
    v51 = 0;
    v52 = v30;
    v53 = v47;
    while (1)
    {
      v54 = charToSixBitLookup_0[*v53];
      if (v54 > 0x3F)
        goto LABEL_133;
      v51 = v54 | (v51 << 6);
      ++v53;
      if (!--v52)
        goto LABEL_128;
    }
  }
  v51 = 0;
  v57 = v30;
  v58 = v47;
  do
  {
    v59 = charToSixBitLookup_0[*v58];
    if (v59 > 0x1F)
      goto LABEL_133;
    v51 = v59 | (32 * v51);
    ++v58;
    --v57;
  }
  while (v57);
LABEL_128:
  Instance = (8 * v30) | (v51 << 7) | 0x8000000000000002;
  v60 = Instance ^ *MEMORY[0x1E0DE7C58];
  if ((~v60 & 0xC000000000000007) == 0)
    goto LABEL_130;
  Instance = v60 & 0xFFFFFFFFFFFFFFF8 | *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + (v60 & 7));
  if (Instance)
    goto LABEL_130;
LABEL_133:
  if ((a5 & 0x20) != 0)
  {
    ptr = v36;
LABEL_141:
    v61 = v104;
    v62 = v103;
    if (!v104)
      goto LABEL_138;
    goto LABEL_142;
  }
  v61 = v104;
  if (__CFStringCreateImmutableFunnel3_onceToken != -1)
  {
    v97 = v30;
    v98 = v47;
    v99 = v36;
    dispatch_once(&__CFStringCreateImmutableFunnel3_onceToken, &__block_literal_global_18);
    v47 = v98;
    v30 = v97;
    v36 = v99;
  }
  v62 = v103;
  if (!__CFStringCreateImmutableFunnel3_sDisableStringROM)
  {
    v67 = v36;
    v68 = __CFSearchStringROM(v47, v30);
    if (v68)
    {
      v69 = v68;
      if (v104 && v17 != (const __CFAllocator *)&__kCFAllocatorNull)
        CFAllocatorDeallocate(v17, v67);
      Instance = (unint64_t)CFRetain(v69);
LABEL_158:
      ptr = 0;
      goto LABEL_227;
    }
    ptr = v67;
    if (!v104)
      goto LABEL_138;
LABEL_142:
    v64 = v17 == (const __CFAllocator *)&__kCFAllocatorNull || v17 == (const __CFAllocator *)v15;
    v65 = 16;
    if (v64)
      v65 = 8;
    if ((_DWORD)v7)
      v66 = v65;
    else
      v66 = v65 + 8;
    goto LABEL_169;
  }
  ptr = v36;
  if (v104)
    goto LABEL_142;
LABEL_138:
  if ((_DWORD)v7)
  {
    LODWORD(v7) = 1;
    v63 = v13;
  }
  else if ((_DWORD)a4 == 256 || (uint64_t)v13 > 255)
  {
    LODWORD(v7) = 0;
    v63 = v13 + 8;
  }
  else
  {
    v63 = v13 + 1;
    LODWORD(v7) = 1;
  }
  if (v62)
    v70 = 0;
  else
    v70 = (_DWORD)a4 == 256;
  v62 = !v70;
  if (v70)
    v66 = v63;
  else
    v66 = v63 + 1;
LABEL_169:
  Instance = _CFRuntimeCreateInstance(v15, 7uLL, v66, 0);
  if (!Instance)
  {
    if (v61 && v17 != (const __CFAllocator *)&__kCFAllocatorNull)
    {
      CFAllocatorDeallocate(v17, ptr);
      Instance = 0;
    }
    goto LABEL_227;
  }
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  v71 = 96;
  if (v17 == (const __CFAllocator *)&__kCFAllocatorNull)
    v71 = 64;
  v72 = 32;
  if (v17 != (const __CFAllocator *)v15)
    v72 = v71;
  v73 = (unint64_t *)(Instance + 8);
  v74 = atomic_load((unint64_t *)(Instance + 8));
  if (!v61)
    v72 = 0;
  do
  {
    v75 = __ldaxr(v73);
    if (v75 == v74)
    {
      if (!__stlxr(v74 & 0xFFFFFFFFFFFFFF9FLL | v72, v73))
      {
        v76 = 1;
        goto LABEL_183;
      }
    }
    else
    {
      __clrex();
    }
    v76 = 0;
LABEL_183:
    v74 = v75;
  }
  while (!v76);
  v77 = atomic_load(v73);
  do
  {
    v78 = __ldaxr(v73);
    if (v78 == v77)
    {
      if (!__stlxr(v77 & 0xFFFFFFFFFFFFFFEFLL | (16 * ((_DWORD)a4 == 256)), v73))
      {
        v79 = 1;
        goto LABEL_190;
      }
    }
    else
    {
      __clrex();
    }
    v79 = 0;
LABEL_190:
    v77 = v78;
  }
  while (!v79);
  v80 = atomic_load(v73);
  do
  {
    v81 = __ldaxr(v73);
    if (v81 == v80)
    {
      if (!__stlxr(v80 & 0xFFFFFFFFFFFFFFF7 | (8 * v62), v73))
      {
        v82 = 1;
        goto LABEL_197;
      }
    }
    else
    {
      __clrex();
    }
    v82 = 0;
LABEL_197:
    v80 = v81;
  }
  while (!v82);
  v83 = atomic_load(v73);
  do
  {
    v84 = __ldaxr(v73);
    if (v84 == v83)
    {
      if (!__stlxr(v83 & 0xFFFFFFFFFFFFFFFBLL | (4 * v7), v73))
      {
        v85 = 1;
        goto LABEL_204;
      }
    }
    else
    {
      __clrex();
    }
    v85 = 0;
LABEL_204:
    v83 = v84;
  }
  while (!v85);
  if ((_DWORD)v7)
  {
    if (v61)
      goto LABEL_207;
LABEL_217:
    v91 = atomic_load((unint64_t *)(Instance + 8));
    v92 = (_BYTE **)(Instance + 16);
    if ((v91 & 0x60) != 0)
    {
      v93 = *v92;
    }
    else
    {
      v94 = atomic_load(v73);
      v93 = &v92[(v94 & 5) != 4];
    }
    if ((_DWORD)v7)
      v95 = v102;
    else
      v95 = 1;
    if ((v95 & 1) == 0)
      *v93++ = v13;
    memmove(v93, ptr, v13);
    if (v62)
      v93[v13] = 0;
  }
  else
  {
    v89 = atomic_load((unint64_t *)(Instance + 8));
    v64 = (v89 & 0x60) == 0;
    v90 = 24;
    if (v64)
      v90 = 16;
    *(_QWORD *)(Instance + v90) = v30 >> ((_DWORD)a4 == 256);
    if (!v61)
      goto LABEL_217;
LABEL_207:
    *(_QWORD *)(Instance + 16) = ptr;
    v86 = atomic_load((unint64_t *)(Instance + 8));
    if ((~v86 & 0x60) == 0)
    {
      CFRetain(v17);
      v87 = atomic_load((unint64_t *)(Instance + 8));
      v64 = (v87 & 5) == 4;
      v88 = 32;
      if (v64)
        v88 = 24;
      *(_QWORD *)(Instance + v88) = v17;
    }
  }
LABEL_227:
  if (BYTE9(v106))
    CFAllocatorDeallocate(allocatora[0], ptr);
  return (CFTypeRef)Instance;
}

unint64_t *_CFRetain(unint64_t *cf, int a2)
{
  unint64_t *v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unint64_t v8;
  _UNKNOWN **v9;
  _BYTE *v10;
  void (*v11)(uint64_t, unint64_t *);
  CFIndex v13;

  v2 = cf;
  v3 = cf + 1;
  v4 = atomic_load(cf + 1);
  if ((v4 & 0x800000) == 0)
  {
    v5 = v4;
    while (!a2 || (v5 & 0x600000) == 0)
    {
      if (!HIWORD(v5))
        return v2;
      v4 &= 0xFFFFFFFFFFFFuLL;
      if (HIWORD(v5) != 0xFFFF)
        v4 = v5 + 0x1000000000000;
      while (1)
      {
        v6 = __ldaxr(v3);
        if (v6 != v5)
          break;
        if (!__stlxr(v4, v3))
        {
          v7 = 1;
          goto LABEL_12;
        }
      }
      v7 = 0;
      __clrex();
LABEL_12:
      v5 = v6;
      if (v7)
        goto LABEL_23;
    }
    return 0;
  }
  if (a2)
    return 0;
  v8 = (v4 >> 8) & 0x3FF;
  if (v8 > 0x47)
    v9 = (_UNKNOWN **)(__CFRuntimeClassTables[(v8 - 72) >> 6] + 8 * (((_DWORD)v8 - 72) & 0x3F));
  else
    v9 = &__CFRuntimeBuiltinClassTable + v8;
  v10 = *v9;
  v11 = (void (*)(uint64_t, unint64_t *))*((_QWORD *)*v9 + 10);
  if (!v11 || (*v10 & 8) == 0)
    _CFRetain_cold_1();
  if (v4 <= 0xFFFEFFFFFFFFFFFFLL)
    _CFRetain_cold_2();
  v11(1, cf);
LABEL_23:
  if (__CFOASafe)
  {
    v13 = CFGetRetainCount(v2);
    if (__CFOASafe)
    {
      if (__CFObjectAllocRecordAllocationFunction)
        __CFObjectAllocRecordAllocationFunction(28, v2, 0, v13, 0);
    }
  }
  return v2;
}

uint64_t _CFGetTSDCreateIfNeeded(unsigned int a1, int a2)
{
  _QWORD *v4;

  if (a1 >= 0x46)
    _CFGetTSDCreateIfNeeded_cold_1(a1);
  v4 = __CFTSDGetTable(a2);
  if (v4)
    return v4[a1 + 1];
  if (a2)
    _CFLogSimple(4, "Warning: TSD slot %d retrieved but the thread data has already been torn down.", a1);
  return 0;
}

void *__CFTSDGetTable(int a1)
{
  unint64_t StatusReg;
  void *v2;

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  v2 = *(void **)(StatusReg + 440);
  if (v2 == (void *)4096)
    return 0;
  if (a1 && !v2)
  {
    v2 = malloc_type_calloc(1uLL, 0x468uLL, 0x1080040FF2AA448uLL);
    pthread_key_init_np();
    *(_QWORD *)(StatusReg + 440) = v2;
  }
  return v2;
}

uint64_t _CFGetTSD(unsigned int a1)
{
  return _CFGetTSDCreateIfNeeded(a1, 1);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  void *v1;
  unint64_t v2;

  if (!cf)
    CFRetain_cold_1();
  v1 = (void *)cf;
  if (((unint64_t)cf & 0x8000000000000000) == 0)
  {
    v2 = atomic_load((unint64_t *)cf + 1);
    if (CF_IS_OBJC((v2 >> 8) & 0x3FF, (__objc2_class **)cf))
      return v1;
    else
      return _CFRetain((unint64_t *)v1, 0);
  }
  return cf;
}

__CFString *__CFSearchStringROM(unsigned __int8 *a1, uint64_t a2)
{
  unsigned __int16 v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __CFString *v8;

  if (a2 > 80)
    return 0;
  v4 = __CFStrHashEightBit2(a1, a2);
  v5 = CFStringROMTableHashData[v4];
  if ((v5 & 7) == 0)
    return 0;
  v6 = v5 >> 3;
  v7 = (CFStringROMTableHashData[v4] >> 3) + (CFStringROMTableHashData[v4] & 7);
  while (1)
  {
    v8 = CFStringROMTable[v6];
    if (v8->length == a2 && !memcmp(a1, v8->data, a2))
      break;
    if (++v6 >= v7)
      return 0;
  }
  return v8;
}

uint64_t __CFStrHashEightBit2(unsigned __int8 *a1, uint64_t a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  unsigned __int8 *v4;
  unint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned int v12;

  if (a2 >= 97)
  {
    v5 = 0;
    v3 = a2;
    do
    {
      v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 3])
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5])
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 1]))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * a1[v5 + 2]));
      v6 = v5 >= 0x1C;
      v5 += 4;
    }
    while (!v6);
    v7 = 0;
    do
    {
      v8 = (uint64_t)&a1[((unint64_t)a2 >> 1) - 16];
      v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 3))
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7))
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 1)))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(v8 + v7 + 2)));
      v9 = v7 - 16;
      v7 += 4;
    }
    while (v9 < 12);
    v10 = &a1[a2 - 32];
    do
    {
      v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[3])
         + 67503105 * v3
         + 257
         * (257
          * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v10)
           + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[1]))
          + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v10[2]));
      v10 += 4;
    }
    while (v10 < &a1[a2]);
  }
  else
  {
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      v2 = a1;
      v4 = a1;
      v3 = a2;
    }
    else
    {
      v2 = a1;
      v3 = a2;
      v4 = a1;
      do
      {
        v3 = *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[3])
           + 67503105 * v3
           + 257
           * (257
            * (257 * *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *v4)
             + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[1]))
            + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v4[2]));
        v4 += 4;
        v2 += 4;
      }
      while (v4 < &a1[a2 & 0xFFFFFFFFFFFFFFFCLL]);
    }
    if (v4 < &a1[a2])
    {
      v11 = (unsigned __int8 *)(&a1[a2] - v2);
      do
      {
        v12 = *v4++;
        v3 = 257 * v3 + *(unsigned __int16 *)(__CFCharToUniCharTable + 2 * v12);
        --v11;
      }
      while (v11);
    }
  }
  return (v3 << (a2 & 0x1F)) + v3;
}

CFTypeRef __CFTypeCollectionRetain(int a1, CFTypeRef cf)
{
  if (!cf)
    __CFTypeCollectionRetain_cold_1();
  return CFRetain(cf);
}

void __CFStrDeallocateMutableContents(uint64_t a1, void *a2)
{
  char v2;
  const CFAllocatorRef *v3;
  char v4;
  const __CFAllocator *v5;
  char v6;

  v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((~v2 & 0x60) != 0)
  {
    if (a1 < 0)
    {
      v3 = &kCFAllocatorSystemDefault;
    }
    else
    {
      v4 = atomic_load((unint64_t *)(a1 + 8));
      if (v4 < 0)
        v3 = &kCFAllocatorSystemDefault;
      else
        v3 = (const CFAllocatorRef *)(a1 - 16);
    }
  }
  else
  {
    v3 = (const CFAllocatorRef *)(a1 + 48);
  }
  v5 = *v3;
  v6 = atomic_load((unint64_t *)(a1 + 8));
  if ((v6 & 1) != 0)
    atomic_load((unint64_t *)(a1 + 8));
  CFAllocatorDeallocate(v5, a2);
}

void __RELEASE_OBJECTS_IN_THE_ARRAY__(uint64_t a1, int a2)
{
  int *v2;
  uint64_t v3;
  id *v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  id *v9;
  uint64_t v10;
  uint64_t v11;
  id *v12;

  v2 = &OBJC_IVAR_____NSFrozenArrayM_storage;
  if (a2 == 1)
    v2 = &OBJC_IVAR_____NSArrayM_storage;
  v3 = a1 + *v2;
  v4 = *(id **)v3;
  v5 = *(unsigned int *)(v3 + 8);
  v6 = *(_DWORD *)(v3 + 12) - v5;
  v7 = *(_DWORD *)(v3 + 20);
  *(_DWORD *)(v3 + 20) = 0;
  if (v6 >= v7)
    v8 = v7;
  else
    v8 = v6;
  *(_QWORD *)v3 = 0;
  *(_QWORD *)(v3 + 8) = 0;
  if (v4)
  {
    if ((_DWORD)v8)
    {
      v9 = &v4[v5];
      v10 = v8;
      do
      {
        if (((unint64_t)*v9 & 0x8000000000000000) == 0)

        ++v9;
        --v10;
      }
      while (v10);
    }
    if (v7 > v6)
    {
      if (v7 - v8 <= 1)
        v11 = 1;
      else
        v11 = v7 - v8;
      v12 = v4;
      do
      {
        if (((unint64_t)*v12 & 0x8000000000000000) == 0)

        ++v12;
        --v11;
      }
      while (v11);
    }
    free(v4);
  }
}

uint64_t __CFStringDecodeByteStream3(char *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, _BYTE *a6, uint64_t a7)
{
  uint64_t v12;
  _QWORD *v14;
  BOOL v15;
  __objc2_class **v16;
  char *v17;
  _WORD *v18;
  BOOL v20;
  uint64_t Typed;
  unsigned __int16 *v22;
  int v23;
  _BOOL4 v24;
  int v25;
  unsigned int *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  int v30;
  void *v31;
  BOOL v33;
  uint64_t result;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  int v38;
  unsigned __int16 *v39;
  int v40;
  _WORD *v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  int v45;
  int v46;
  _BYTE *v47;
  uint64_t v48;
  void *v49;
  BOOL v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  _WORD *v59;
  BOOL v60;
  unint64_t v62;
  unsigned int *v63;
  unsigned int v64;
  unsigned int v65;
  _BYTE *v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  size_t v70;
  void *v71;
  char *v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  char *v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  char v81;
  int v82;
  char v83;
  char *v84;
  uint64_t v85;
  int v86;
  int v87;
  char *v88;
  uint64_t v89;
  int v90;
  void *v91;
  BOOL v93;
  uint64_t v94;
  unint64_t v95;
  unint64_t v96;
  void *v97;
  BOOL v98;
  char v99;
  BOOL v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  int v105;
  uint64_t v106;
  _WORD *v107;
  uint64_t v108;
  _QWORD v109[2];

  v12 = a2;
  v109[1] = *MEMORY[0x1E0C80C00];
  if (a6)
    *a6 = 0;
  *(_QWORD *)(a5 + 24) = 0;
  v14 = (_QWORD *)(a5 + 24);
  v15 = a4 == 0;
  *(_BYTE *)(a5 + 8) = a4 == 0;
  *(_BYTE *)(a5 + 9) = 0;
  if (!a2)
    return 1;
  v16 = *(__objc2_class ***)(a5 + 16);
  if (!v16)
  {
    v16 = (__objc2_class **)_CFGetTSD(1u);
    if (!v16)
      v16 = &__kCFAllocatorSystemDefault;
  }
  *(_QWORD *)(a5 + 16) = v16;
  if ((int)a3 <= 268435711)
  {
    v17 = &a1[v12];
    if ((int)a3 <= 134217983)
    {
      if ((_DWORD)a3 != 256)
      {
        if ((_DWORD)a3 == 3071)
        {
          *(_BYTE *)(a5 + 8) = 0;
          v18 = *(_WORD **)a5;
          v20 = (unint64_t)v12 > 0x1F8 || v18 != 0;
          *(_BYTE *)(a5 + 9) = v20;
          if (!v18)
          {
            if ((unint64_t)v12 > 0x1F8)
            {
              Typed = CFAllocatorAllocateTyped(v16, 2 * v12, 0x1000040BDFB0063, 0);
              *(_QWORD *)a5 = Typed;
              if (!Typed)
                goto LABEL_204;
              goto LABEL_105;
            }
            v18 = (_WORD *)(a5 + 32);
          }
          *(_QWORD *)a5 = v18;
LABEL_105:
          *v14 = 0;
          if (v12 < 1)
          {
            LOBYTE(v54) = 0;
            goto LABEL_138;
          }
          v53 = 0;
          v54 = 0;
          v55 = 0;
          while (1)
          {
            v57 = *a1++;
            v56 = v57;
            if (v54 == 1)
            {
              if ((v56 & 0xFFFFFFDF) == 0x55)
              {
                v55 = 0;
                v54 = 2;
              }
              else
              {
                v55 = v56 - 48;
                if (v56 - 48 > 9)
                {
                  if (v56 != 92)
                    goto LABEL_137;
                  v55 = 92;
LABEL_133:
                  v54 = 0;
                  v59 = *(_WORD **)a5;
                  *(_QWORD *)(a5 + 24) = v53 + 1;
                  v59[v53++] = v55;
                  goto LABEL_134;
                }
                v54 = 7;
              }
            }
            else
            {
              if ((_BYTE)v54)
              {
                v58 = v56 - 48;
                if ((char)v54 > 5)
                {
                  if ((v56 - 48) > 9u)
                    goto LABEL_137;
                  v55 = v58 | (8 * v55);
                  if (++v54 == 9)
                    goto LABEL_133;
                }
                else
                {
                  if ((v56 - 48) > 9u)
                  {
                    if (v56 > 0x60)
                      LOBYTE(v56) = v56 - 32;
                    if ((v56 - 65) > 5u)
                    {
LABEL_137:
                      LOBYTE(v54) = 1;
LABEL_138:
                      v60 = v54 == 0;
LABEL_139:
                      if (!v60)
                      {
LABEL_204:
                        if (*(_BYTE *)(a5 + 9))
                        {
                          if (*(_QWORD *)a5)
                            CFAllocatorDeallocate(*(CFAllocatorRef *)(a5 + 16), *(void **)a5);
                        }
                        result = 0;
                        *(_BYTE *)(a5 + 8) = v15;
                        *(_BYTE *)(a5 + 9) = 0;
                        *(_QWORD *)a5 = 0;
                        *(_QWORD *)(a5 + 24) = 0;
                        return result;
                      }
                      return 1;
                    }
                    v55 = (v56 - 55) | (16 * v55);
                  }
                  else
                  {
                    v55 = v58 | (16 * v55);
                  }
                  if (++v54 == 6)
                    goto LABEL_133;
                }
              }
              else
              {
                if (v56 == 92)
                {
                  v54 = 1;
                  goto LABEL_134;
                }
                v55 = v56;
                if ((v56 & 0x80) != 0)
                  goto LABEL_137;
              }
              if (!(_BYTE)v54)
                goto LABEL_133;
              if (v54 == 255)
                goto LABEL_137;
            }
LABEL_134:
            if (a1 >= v17)
              goto LABEL_138;
          }
        }
        goto LABEL_60;
      }
      goto LABEL_24;
    }
    if ((_DWORD)a3 != 134217984)
    {
      v25 = 201326848;
      goto LABEL_34;
    }
    if (v12 >= 3 && *a1 == 239 && a1[1] == 187 && a1[2] == 191)
    {
      v12 -= 3;
      if (!v12)
        return 1;
      a1 += 3;
    }
    if (!*(_BYTE *)(a5 + 8))
    {
LABEL_91:
      if (__CFStringDecodeByteStream3_onceToken != -1)
        dispatch_once(&__CFStringDecodeByteStream3_onceToken, &__block_literal_global_19);
      v49 = *(void **)a5;
      v51 = (unint64_t)v12 > 0x1F8 || v49 != 0;
      *(_BYTE *)(a5 + 9) = v51;
      if (!v49)
      {
        if ((unint64_t)v12 > 0x1F8)
        {
          v52 = CFAllocatorAllocateTyped(*(_QWORD *)(a5 + 16), 2 * v12, 0x1000040BDFB0063, 0);
          *(_QWORD *)a5 = v52;
          if (!v52)
            goto LABEL_204;
LABEL_186:
          *v14 = 0;
          if (a1 < v17)
          {
            v74 = 0;
            while (1)
            {
              v109[0] = 0;
              v75 = __CFStringDecodeByteStream3___CFFromUTF8(a7, a1, v17 - a1, *(_QWORD *)a5 + 2 * v74, v12 - v74, v109);
              v76 = v109[0];
              if (!v109[0])
                break;
              a1 += v75;
              v74 = *v14 + v109[0];
              *v14 = v74;
              if (a1 >= v17)
                goto LABEL_202;
            }
LABEL_203:
            if (!v76)
              goto LABEL_204;
            return 1;
          }
LABEL_202:
          v76 = 1;
          goto LABEL_203;
        }
        v49 = (void *)(a5 + 32);
      }
      *(_QWORD *)a5 = v49;
      goto LABEL_186;
    }
    if (v12 >= 1)
    {
      v28 = a1;
      v29 = v12;
      while (1)
      {
        v30 = *v28++;
        if (v30 < 0)
          break;
        if (!--v29)
          goto LABEL_50;
      }
      *(_BYTE *)(a5 + 8) = 0;
      goto LABEL_91;
    }
LABEL_50:
    *(_QWORD *)(a5 + 24) = v12;
    v31 = *(void **)a5;
    v33 = (unint64_t)v12 > 0x3F0 || v31 != 0;
    *(_BYTE *)(a5 + 9) = v33;
    if (!v31)
    {
      if ((unint64_t)v12 > 0x3F0)
      {
        v31 = (void *)CFAllocatorAllocateTyped(v16, v12, 0x100004077774924, 0);
        *(_QWORD *)a5 = v31;
        if (!v31)
          goto LABEL_204;
        goto LABEL_211;
      }
      v31 = (void *)(a5 + 32);
    }
    *(_QWORD *)a5 = v31;
LABEL_211:
    v71 = v31;
    goto LABEL_284;
  }
  if ((int)a3 <= 402653439)
  {
    if ((_DWORD)a3 == 268435712 || (_DWORD)a3 == 335544576)
    {
LABEL_24:
      if ((unint64_t)v12 < 2)
        goto LABEL_204;
      v22 = (unsigned __int16 *)&a1[v12 & 0xFFFFFFFFFFFFFFFELL];
      if ((_DWORD)a3 == 268435712)
        goto LABEL_66;
      if ((_DWORD)a3 != 256)
      {
        v36 = v12 & 0xFFFFFFFFFFFFFFFELL;
        v37 = (uint64_t)(v12 & 0xFFFFFFFFFFFFFFFELL) >> 1;
        *v14 = v37;
        if (a6)
        {
          result = 1;
          *a6 = 1;
          *(_QWORD *)a5 = a1;
          *(_BYTE *)(a5 + 8) = 0;
          return result;
        }
        v24 = 0;
        goto LABEL_68;
      }
      v23 = *(unsigned __int16 *)a1;
      if (v23 == 65534 || v23 == 65279)
      {
        a1 += 2;
        v24 = v23 != 65279;
      }
      else
      {
LABEL_66:
        v24 = 1;
      }
      v36 = (char *)v22 - a1;
      v37 = ((char *)v22 - a1) >> 1;
      *v14 = v37;
LABEL_68:
      if (*(_BYTE *)(a5 + 8))
      {
        if (v24)
          v38 = 33023;
        else
          v38 = 65408;
        v39 = (unsigned __int16 *)a1;
        do
        {
          if (v39 >= v22)
          {
            v47 = *(_BYTE **)a5;
            if (!*(_QWORD *)a5)
            {
              if (v37 < 0x3F1)
              {
                v47 = (_BYTE *)(a5 + 32);
                *(_QWORD *)a5 = a5 + 32;
              }
              else
              {
                v48 = CFAllocatorAllocateTyped(v16, v37, 0x100004077774924, 0);
                *(_QWORD *)a5 = v48;
                if (!v48)
                  goto LABEL_204;
                v47 = (_BYTE *)v48;
                *(_BYTE *)(a5 + 9) = 1;
              }
            }
            if (v24)
            {
              if (a1 < (char *)v22)
              {
                result = 1;
                do
                {
                  *v47++ = a1[1];
                  a1 += 2;
                }
                while (a1 < (char *)v22);
                return result;
              }
            }
            else if (a1 < (char *)v22)
            {
              result = 1;
              do
              {
                v81 = *a1;
                a1 += 2;
                *v47++ = v81;
              }
              while (a1 < (char *)v22);
              return result;
            }
            return 1;
          }
          v40 = *v39++;
        }
        while ((v38 & v40) == 0);
        *(_BYTE *)(a5 + 8) = 0;
      }
      v41 = *(_WORD **)a5;
      if (!*(_QWORD *)a5)
      {
        if (v37 < 0x1F9)
        {
          v41 = (_WORD *)(a5 + 32);
          *(_QWORD *)a5 = a5 + 32;
        }
        else
        {
          v42 = CFAllocatorAllocateTyped(v16, v36, 0x1000040BDFB0063, 0);
          *(_QWORD *)a5 = v42;
          if (!v42)
            goto LABEL_204;
          v41 = (_WORD *)v42;
          *(_BYTE *)(a5 + 9) = 1;
        }
      }
      if (v24)
      {
        if (a1 < (char *)v22)
        {
          result = 1;
          do
          {
            v69 = *(unsigned __int16 *)a1;
            a1 += 2;
            *v41++ = bswap32(v69) >> 16;
          }
          while (a1 < (char *)v22);
          return result;
        }
        return 1;
      }
      v70 = 2 * *v14;
      v71 = v41;
      v72 = a1;
LABEL_285:
      memmove(v71, v72, v70);
      return 1;
    }
    goto LABEL_60;
  }
  if ((_DWORD)a3 == 402653440)
    goto LABEL_35;
  v25 = 469762304;
LABEL_34:
  if ((_DWORD)a3 == v25)
  {
LABEL_35:
    if ((unint64_t)v12 < 4)
      goto LABEL_204;
    v26 = (unsigned int *)&a1[v12 & 0xFFFFFFFFFFFFFFFCLL];
    if ((_DWORD)a3 == 201326848)
    {
      v43 = *(_DWORD *)a1;
      if (*(_DWORD *)a1 == -131072 || v43 == 65279)
      {
        a1 += 4;
        v27 = (uint64_t)((v12 & 0xFFFFFFFFFFFFFFFCLL) - 4) >> 2;
        *v14 = v27;
        if (v43 == 65279)
          goto LABEL_85;
LABEL_147:
        v45 = 0xFFFF;
        v44 = 1;
        v46 = -2130706433;
        goto LABEL_148;
      }
      v27 = v12 >> 2;
    }
    else
    {
      v27 = v12 >> 2;
      if ((_DWORD)a3 != 402653440)
      {
        *v14 = v27;
LABEL_85:
        v44 = 0;
        v45 = -65536;
        v46 = -128;
LABEL_148:
        v62 = v27;
        if (a1 < (char *)v26)
        {
          v62 = v27;
          v63 = (unsigned int *)a1;
          do
          {
            v64 = *v63;
            if ((*v63 & v46) != 0)
            {
              *(_BYTE *)(a5 + 8) = 0;
              if ((v64 & v45) != 0)
              {
                v65 = bswap32(v64);
                if (v44)
                  v64 = v65;
                if (HIWORD(v64) > 0x10u)
                  return 0;
                *v14 = ++v62;
              }
            }
            ++v63;
          }
          while (v63 < v26);
        }
        v66 = *(_BYTE **)a5;
        if (*(_BYTE *)(a5 + 8))
        {
          if (!v66)
          {
            if (v62 < 0x3F1)
            {
              v66 = (_BYTE *)(a5 + 32);
              *(_QWORD *)a5 = a5 + 32;
            }
            else
            {
              v67 = CFAllocatorAllocateTyped(v16, v62, 0x100004077774924, 0);
              *(_QWORD *)a5 = v67;
              if (!v67)
                goto LABEL_204;
              v66 = (_BYTE *)v67;
              *(_BYTE *)(a5 + 9) = 1;
            }
          }
          if ((v44 & 1) != 0)
          {
            if (a1 < (char *)v26)
            {
              result = 1;
              do
              {
                *v66++ = a1[3];
                a1 += 4;
              }
              while (a1 < (char *)v26);
              return result;
            }
          }
          else if (a1 < (char *)v26)
          {
            result = 1;
            do
            {
              v73 = *(_DWORD *)a1;
              a1 += 4;
              *v66++ = v73;
            }
            while (a1 < (char *)v26);
            return result;
          }
          return 1;
        }
        if (!v66)
        {
          if (v62 < 0x1F9)
          {
            v66 = (_BYTE *)(a5 + 32);
            *(_QWORD *)a5 = a5 + 32;
          }
          else
          {
            v68 = CFAllocatorAllocateTyped(v16, 2 * v62, 0x1000040BDFB0063, 0);
            *(_QWORD *)a5 = v68;
            if (!v68)
              goto LABEL_204;
            v66 = (_BYTE *)v68;
            *(_BYTE *)(a5 + 9) = 1;
          }
        }
        if (v27 >= 1)
        {
          v77 = &a1[4 * v27];
          do
          {
            v79 = *(_DWORD *)a1;
            a1 += 4;
            v78 = v79;
            v80 = bswap32(v79);
            if (v44)
              v78 = v80;
            if (HIWORD(v78))
            {
              if (HIWORD(v78) > 0x10u)
                goto LABEL_204;
              *(_WORD *)v66 = ((v78 + 67043328) >> 10) - 10240;
              v66 += 2;
              LOWORD(v78) = v78 & 0x3FF | 0xDC00;
            }
            else if ((v78 & 0xF800 | 0x400) == 0xDC00)
            {
              goto LABEL_204;
            }
            *(_WORD *)v66 = v78;
            v66 += 2;
          }
          while (a1 < v77);
        }
        goto LABEL_202;
      }
    }
    *v14 = v27;
    goto LABEL_147;
  }
LABEL_60:
  result = CFStringEncodingGetConverter(a3);
  if (!result)
    return result;
  v35 = result;
  switch(BYTE1(a3))
  {
    case 0:
      if (a3 <= 0x22 && ((1 << a3) & 0x600000032) != 0 || (_DWORD)a3 == 152)
        goto LABEL_230;
      goto LABEL_240;
    case 1:
    case 8:
    case 0xC:
      goto LABEL_230;
    case 2:
      if ((_DWORD)a3 != 518)
        goto LABEL_240;
      goto LABEL_230;
    case 6:
      if ((_DWORD)a3 == 1536)
        goto LABEL_240;
      goto LABEL_230;
    case 0xA:
      if ((a3 - 2561) <= 0xF && ((1 << (a3 - 1)) & 0x8011) != 0)
        goto LABEL_230;
      goto LABEL_240;
    case 0xB:
      if ((a3 - 3059) >= 2)
        goto LABEL_240;
      goto LABEL_230;
    default:
      if (((unsigned __int16)a3 & 0xFF00u) >= 0xC01)
      {
LABEL_230:
        v82 = 0;
        *(_BYTE *)(a5 + 8) = 0;
      }
      else
      {
LABEL_240:
        if (*(_BYTE *)(a5 + 8))
        {
          if (v12 < 1)
          {
LABEL_245:
            v83 = 0;
            v82 = 1;
            goto LABEL_249;
          }
          v88 = a1;
          v89 = v12;
          while (1)
          {
            v90 = *v88++;
            if (v90 < 0)
              break;
            if (!--v89)
              goto LABEL_245;
          }
          v82 = 1;
          goto LABEL_248;
        }
        v82 = 1;
      }
      v83 = 1;
      if ((_DWORD)a3 == 1 && !a4)
      {
        *(_BYTE *)(a5 + 8) = 1;
        if (v12 < 1)
        {
LABEL_238:
          v83 = 0;
          goto LABEL_249;
        }
        v84 = a1;
        v85 = v12;
        while (1)
        {
          v87 = *v84++;
          v86 = v87;
          if (v87 < 0 || v86 == 92)
            break;
          if (!--v85)
            goto LABEL_238;
        }
LABEL_248:
        *(_BYTE *)(a5 + 8) = 0;
        v83 = 1;
      }
LABEL_249:
      if (*(_BYTE *)(result + 20) != 1)
      {
        if ((v83 & 1) == 0)
          goto LABEL_272;
        v95 = CFStringEncodingCharLengthForBytes(a3, 0, (unint64_t)a1, v12);
        v96 = v95;
        v97 = *(void **)a5;
        if (*(_QWORD *)a5)
          v98 = 1;
        else
          v98 = v95 > 0x1F8;
        v99 = v98;
        *(_BYTE *)(a5 + 9) = v99;
        if (!v97)
        {
          if (v95 > 0x1F8)
          {
            v97 = (void *)CFAllocatorAllocateTyped(*(_QWORD *)(a5 + 16), 2 * v95, 0x1000040BDFB0063, 0);
            *(_QWORD *)a5 = v97;
            if (!v97)
              goto LABEL_204;
LABEL_306:
            if ((__CFStringDecodeByteStream3_lossyFlag & 1) == 0)
              __CFStringDecodeByteStream3_lossyFlag = 1;
            if (v96 <= 0x1F8)
              v108 = 504;
            else
              v108 = v96;
            v60 = CFStringEncodingBytesToUnicode(a3, __CFWantsToUseASCIICompatibleConversion, (unint64_t)a1, v12, 0, (uint64_t)v97, v108, (uint64_t *)(a5 + 24)) == 0;
            goto LABEL_139;
          }
          v97 = (void *)(a5 + 32);
        }
        *(_QWORD *)a5 = v97;
        goto LABEL_306;
      }
      if ((v83 & 1) == 0)
      {
LABEL_272:
        *(_QWORD *)(a5 + 24) = v12;
        v71 = *(void **)a5;
        v101 = (unint64_t)v12 > 0x3F0 || v71 != 0;
        *(_BYTE *)(a5 + 9) = v101;
        if (!v71)
        {
          if ((unint64_t)v12 > 0x3F0)
          {
            v71 = (void *)CFAllocatorAllocateTyped(*(_QWORD *)(a5 + 16), v12, 0x100004077774924, 0);
            *(_QWORD *)a5 = v71;
            if (!v71)
              goto LABEL_204;
            goto LABEL_284;
          }
          v71 = (void *)(a5 + 32);
        }
        *(_QWORD *)a5 = v71;
LABEL_284:
        v72 = a1;
        v70 = v12;
        goto LABEL_285;
      }
      v91 = *(void **)a5;
      v93 = (unint64_t)v12 > 0x1F8 || v91 != 0;
      *(_BYTE *)(a5 + 9) = v93;
      if (v91)
        goto LABEL_289;
      if ((unint64_t)v12 <= 0x1F8)
      {
        v91 = (void *)(a5 + 32);
LABEL_289:
        *(_QWORD *)a5 = v91;
        goto LABEL_290;
      }
      v94 = CFAllocatorAllocateTyped(*(_QWORD *)(a5 + 16), 2 * v12, 0x1000040BDFB0063, 0);
      *(_QWORD *)a5 = v94;
      if (!v94)
        goto LABEL_204;
LABEL_290:
      *v14 = v12;
      if ((_DWORD)a3 == 513 || (_DWORD)a3 == 1536)
      {
        if (v12 >= 1)
        {
          v102 = 0;
          result = 1;
          do
          {
            *(_WORD *)(*(_QWORD *)a5 + 2 * v102) = a1[v102];
            ++v102;
          }
          while (v12 != v102);
          return result;
        }
        return 1;
      }
      if (v12 < 1)
        return 1;
      v103 = 0;
      do
      {
        v105 = *a1++;
        v104 = v105;
        v106 = v105;
        v107 = (_WORD *)(*(_QWORD *)a5 + v103);
        if (!v82 || v104 < 0)
        {
          if (!(*(unsigned int (**)(_QWORD, uint64_t, _WORD *))(v35 + 8))(0, v106, v107))
            goto LABEL_204;
        }
        else
        {
          *v107 = v106;
        }
        v103 += 2;
        result = 1;
        --v12;
      }
      while (v12);
      return result;
  }
}

void __CFBasicHashDeallocate(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if ((v1 & 8) != 0)
  {
    __break(1u);
  }
  else
  {
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 32) = v1 | 8;
    __CFBasicHashDrain(a1);
  }
}

unsigned __int8 *copyBlocks(unsigned __int8 *result, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  unsigned __int8 *v22;

  v22 = result;
  v10 = a4 != 0;
  if (a7 < 1)
  {
    v13 = 0;
    v12 = 0;
  }
  else
  {
    v11 = a7;
    v12 = 0;
    v13 = 0;
    v14 = a8 << (a5 != 0);
    v15 = a4 != a5;
    v16 = (uint64_t *)(a6 + 8);
    do
    {
      v17 = *(v16 - 1);
      v18 = (v17 << v10) - v13;
      if (v18 >= 1)
      {
        if (a4 == a5)
          result = (unsigned __int8 *)memmove((void *)(a2 + v12), &v22[v13], (v17 << v10) - v13);
        else
          result = __CFStrConvertBytesToUnicode(&v22[v13], (_WORD *)(a2 + v12), v18);
      }
      v19 = *v16;
      v16 += 2;
      v13 = (v19 + v17) << v10;
      v12 += v14 + (v18 << v15);
      --v11;
    }
    while (v11);
  }
  v20 = (a3 << v10) - v13;
  if (a3 << v10 > v13)
  {
    if (a4 == a5)
      return (unsigned __int8 *)memmove((void *)(a2 + v12), &v22[v13], v20);
    else
      return __CFStrConvertBytesToUnicode(&v22[v13], (_WORD *)(a2 + v12), v20);
  }
  return result;
}

void __CFURLDeallocate(unint64_t *a1)
{
  const __CFAllocator *v2;
  unint64_t *v3;
  const void *v5;
  const void *v6;
  _QWORD *v7;
  const void *v8;
  unint64_t *v9;
  const void *v10;

  v2 = CFGetAllocator(a1);
  v3 = a1 + 3;
  if (atomic_load(a1 + 3))
  {
    v5 = (const void *)atomic_load(v3);
    CFRelease(v5);
  }
  atomic_store(0xDEADBEEFuLL, v3);
  v6 = (const void *)a1[4];
  if (v6)
    CFRelease(v6);
  v7 = (_QWORD *)a1[5];
  if (v7)
  {
    v8 = (const void *)v7[1];
    if (!v8 || (CFRelease(v8), (v7 = (_QWORD *)a1[5]) != 0))
      CFAllocatorDeallocate(v2, v7);
  }
  v9 = a1 + 6;
  v10 = (const void *)atomic_load(v9);
  if (v10)
    CFRelease(v10);
  atomic_store(0xDEADBEEFuLL, v9);
}

void __CFArrayDeallocate(unint64_t a1)
{
  __CFArrayReleaseValues(a1, 0, *(_QWORD *)(a1 + 16), 1);
}

unsigned __int8 *__CFFromUTF8(__int16 a1, unsigned __int8 *a2, uint64_t a3, _WORD *a4, uint64_t a5, _QWORD *a6)
{
  unsigned __int8 *v8;
  uint64_t v10;
  int v12;
  _DWORD *v13;
  uint64_t v14;
  unsigned int v15;
  _WORD *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 *v19;
  char v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  _DWORD *v27;
  int IsMemberOf;
  uint64_t v29;
  unint64_t v30;
  _WORD *v31;
  _WORD *v32;
  uint64_t v33;
  char v34;
  _WORD *v35;
  uint64_t v36;
  uint64_t v39;
  _WORD *v40;
  unsigned int v41[10];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  v40 = a4;
  v8 = a2;
  if (a3)
  {
    v10 = a3;
    v12 = a1 & 0xC0;
    v13 = &offsetsFromUTF8;
    v8 = a2;
    while (1)
    {
      v14 = v39;
      if (a5 && v39 >= a5)
        goto LABEL_73;
      v15 = *v8;
      if (v10 <= (unsigned __int16)trailingBytesForUTF8[*v8])
        goto LABEL_73;
      --v10;
      if ((~(_BYTE)v15 & 0xF8) == 0)
        break;
      v18 = (unsigned __int16)trailingBytesForUTF8[*v8];
      if ((a1 & 0x800) == 0)
      {
        v19 = &v8[v18];
        while (v19 > v8)
        {
          v20 = *v19--;
          if ((v20 & 0xC0) != 0x80)
            goto LABEL_7;
        }
        if ((char)v15 < -62 || v15 > 0xF4)
          break;
        if (*v8 > 0xEFu)
        {
          if (v15 == 240)
          {
            if (v8[1] < 0x90u)
              break;
          }
          else if (v15 == 244 && v8[1] >= 0x90u)
          {
            break;
          }
        }
        else if (v15 == 224)
        {
          if (v8[1] < 0xA0u)
            break;
        }
        else if (v15 == 237 && v8[1] > 0x9Fu)
        {
          break;
        }
      }
      v21 = 0;
      v22 = (unsigned __int16)trailingBytesForUTF8[*v8];
      switch(*v8)
      {
        case 0u:
        case 1u:
        case 2u:
        case 3u:
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 8u:
        case 9u:
        case 0xAu:
        case 0xBu:
        case 0xCu:
        case 0xDu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x15u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
        case 0x19u:
        case 0x1Au:
        case 0x1Bu:
        case 0x1Cu:
        case 0x1Du:
        case 0x1Eu:
        case 0x1Fu:
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x23u:
        case 0x24u:
        case 0x25u:
        case 0x26u:
        case 0x27u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x2Bu:
        case 0x2Cu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x3Fu:
        case 0x40u:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Bu:
        case 0x5Cu:
        case 0x5Du:
        case 0x5Eu:
        case 0x5Fu:
        case 0x60u:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
        case 0x7Bu:
        case 0x7Cu:
        case 0x7Du:
        case 0x7Eu:
        case 0x7Fu:
        case 0x80u:
        case 0x81u:
        case 0x82u:
        case 0x83u:
        case 0x84u:
        case 0x85u:
        case 0x86u:
        case 0x87u:
        case 0x88u:
        case 0x89u:
        case 0x8Au:
        case 0x8Bu:
        case 0x8Cu:
        case 0x8Du:
        case 0x8Eu:
        case 0x8Fu:
        case 0x90u:
        case 0x91u:
        case 0x92u:
        case 0x93u:
        case 0x94u:
        case 0x95u:
        case 0x96u:
        case 0x97u:
        case 0x98u:
        case 0x99u:
        case 0x9Au:
        case 0x9Bu:
        case 0x9Cu:
        case 0x9Du:
        case 0x9Eu:
        case 0x9Fu:
        case 0xA0u:
        case 0xA1u:
        case 0xA2u:
        case 0xA3u:
        case 0xA4u:
        case 0xA5u:
        case 0xA6u:
        case 0xA7u:
        case 0xA8u:
        case 0xA9u:
        case 0xAAu:
        case 0xABu:
        case 0xACu:
        case 0xADu:
        case 0xAEu:
        case 0xAFu:
        case 0xB0u:
        case 0xB1u:
        case 0xB2u:
        case 0xB3u:
        case 0xB4u:
        case 0xB5u:
        case 0xB6u:
        case 0xB7u:
        case 0xB8u:
        case 0xB9u:
        case 0xBAu:
        case 0xBBu:
        case 0xBCu:
        case 0xBDu:
        case 0xBEu:
        case 0xBFu:
          goto LABEL_39;
        case 0xC0u:
        case 0xC1u:
        case 0xC2u:
        case 0xC3u:
        case 0xC4u:
        case 0xC5u:
        case 0xC6u:
        case 0xC7u:
        case 0xC8u:
        case 0xC9u:
        case 0xCAu:
        case 0xCBu:
        case 0xCCu:
        case 0xCDu:
        case 0xCEu:
        case 0xCFu:
        case 0xD0u:
        case 0xD1u:
        case 0xD2u:
        case 0xD3u:
        case 0xD4u:
        case 0xD5u:
        case 0xD6u:
        case 0xD7u:
        case 0xD8u:
        case 0xD9u:
        case 0xDAu:
        case 0xDBu:
        case 0xDCu:
        case 0xDDu:
        case 0xDEu:
        case 0xDFu:
          goto LABEL_38;
        case 0xE0u:
        case 0xE1u:
        case 0xE2u:
        case 0xE3u:
        case 0xE4u:
        case 0xE5u:
        case 0xE6u:
        case 0xE7u:
        case 0xE8u:
        case 0xE9u:
        case 0xEAu:
        case 0xEBu:
        case 0xECu:
        case 0xEDu:
        case 0xEEu:
        case 0xEFu:
          goto LABEL_37;
        case 0xF0u:
        case 0xF1u:
        case 0xF2u:
        case 0xF3u:
        case 0xF4u:
        case 0xF5u:
        case 0xF6u:
        case 0xF7u:
          v21 = v15 << 6;
          v23 = *++v8;
          v15 = v23;
LABEL_37:
          v24 = *++v8;
          v21 = (v21 + v15) << 6;
          v15 = v24;
LABEL_38:
          v25 = *++v8;
          v22 = (v21 + v15) << 6;
          v15 = v25;
LABEL_39:
          ++v8;
          v21 = v22 + v15;
          break;
        default:
          break;
      }
      v10 -= v18;
      v26 = v21 - v13[v18];
      if (HIWORD(v26))
      {
        if (v26 >= 0x110000)
        {
          if ((a1 & 0x80) == 0)
            goto LABEL_72;
          if (a5)
          {
            v31 = v40;
            *v40 = -3;
            v40 = v31 + 1;
          }
          goto LABEL_12;
        }
        if (!v12)
          goto LABEL_62;
        v27 = v13;
        if ((CFUniCharIsMemberOf(v21 - v13[v18], 0x65u) & 1) == 0)
        {
          v14 = v39;
          v13 = v27;
LABEL_62:
          v17 = v14 + 2;
          if (a5)
          {
            if (v17 > a5)
              goto LABEL_73;
            v35 = v40;
            *v40 = ((v26 + 67043328) >> 10) - 10240;
            v40 = v35 + 2;
            v35[1] = v26 & 0x3FF | 0xDC00;
          }
LABEL_13:
          v39 = v17;
          goto LABEL_14;
        }
        v33 = CFUniCharDecomposeCharacter(v26, v41, 10);
        v30 = v33;
        if (!a5)
        {
          if (v33 < 1)
            goto LABEL_48;
          v17 = v39;
          v13 = v27;
          do
          {
            if (v41[v30 - 1] < 0x10000)
              v36 = 1;
            else
              v36 = 2;
            v17 += v36;
          }
          while (v30-- > 1);
          goto LABEL_13;
        }
      }
      else
      {
        if ((a1 & 0x80) == 0 && (v26 & 0xFFFFF800) == 0xD800)
        {
LABEL_72:
          v8 -= (v18 + 1);
          goto LABEL_73;
        }
        if (!v12
          || v26 < 0x80
          || (v27 = v13, IsMemberOf = CFUniCharIsMemberOf(v21 - v13[v18], 0x65u), v13 = v27, !IsMemberOf))
        {
          if (a5)
          {
            v32 = v40;
            *v40 = v26;
            v40 = v32 + 1;
          }
          ++v39;
          goto LABEL_14;
        }
        v29 = CFUniCharDecomposeCharacter(v26, v41, 10);
        v30 = v29;
        if (!a5)
        {
          v39 += v29;
LABEL_48:
          v13 = v27;
          goto LABEL_14;
        }
      }
      v34 = CFUniCharFillDestinationBuffer(v41, v30, (uint64_t *)&v40, a5, &v39, 0);
      v13 = v27;
      if ((v34 & 1) == 0)
        goto LABEL_73;
LABEL_14:
      if (!v10)
        goto LABEL_73;
    }
LABEL_7:
    if ((a1 & 1) == 0 && v15 != 169)
      goto LABEL_73;
    if (a5)
    {
      v16 = v40;
      *v40 = -3;
      v40 = v16 + 1;
    }
    ++v8;
LABEL_12:
    v17 = v14 + 1;
    goto LABEL_13;
  }
LABEL_73:
  if (a6)
    *a6 = v39;
  return (unsigned __int8 *)(v8 - a2);
}

void __CFDateComponentsDeallocate(uint64_t a1)
{
  const void *v2;
  const void *v3;

  if (!a1)
    __CFDateComponentsDeallocate_cold_1();
  v2 = *(const void **)(a1 + 16);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 24);
  if (v3)
    CFRelease(v3);
}

void __CFCharacterSetDeallocate(uint64_t a1)
{
  const __CFAllocator *v2;
  unint64_t *v3;
  char v4;
  char v5;
  char v6;
  char v7;
  void *v8;
  char v9;
  char v10;
  uint64_t i;
  uint64_t v12;
  const __CFAllocator *v13;
  const __CFAllocator *v14;

  v2 = CFGetAllocator((CFTypeRef)a1);
  v3 = (unint64_t *)(a1 + 8);
  v4 = atomic_load((unint64_t *)(a1 + 8));
  if ((v4 & 0x70) != 0
    || (v5 = atomic_load(v3), (v5 & 1) != 0)
    || (v6 = atomic_load((unint64_t *)(a1 + 8)), (v6 & 8) != 0)
    || CFCharacterSetGetPredefined(*(CFCharacterSetPredefinedSet *)(a1 + 24)) != (CFCharacterSetRef)a1)
  {
    v7 = atomic_load(v3);
    if ((v7 & 0x70) == 0x20 && (v8 = *(void **)(a1 + 24)) != 0
      || (v9 = atomic_load((unint64_t *)(a1 + 8)), (v9 & 0x70) == 0x30) && (v8 = *(void **)(a1 + 24)) != 0
      || (v10 = atomic_load((unint64_t *)(a1 + 8)), (v10 & 0x70) == 0x40) && (v8 = *(void **)(a1 + 24)) != 0)
    {
      CFAllocatorDeallocate(v2, v8);
    }
    if (*(_QWORD *)(a1 + 40))
    {
      for (i = 0; i != 16; ++i)
      {
        v12 = *(_QWORD *)(a1 + 40);
        if (((*(_DWORD *)(v12 + 8) >> i) & 2) != 0)
          CFRelease(*(CFTypeRef *)(*(_QWORD *)v12 + 8 * i));
      }
      v13 = CFGetAllocator((CFTypeRef)a1);
      CFAllocatorDeallocate(v13, **(void ***)(a1 + 40));
      v14 = CFGetAllocator((CFTypeRef)a1);
      CFAllocatorDeallocate(v14, *(void **)(a1 + 40));
      *(_QWORD *)(a1 + 40) = 0;
    }
  }
}

void __CFStreamDeallocate(uint64_t a1)
{
  uint64_t *v2;
  const __CFAllocator *v3;
  _QWORD *v4;
  void (*v5)(void);
  const void *v6;
  void (*v7)(_QWORD);
  void *v8;
  const void *v9;
  NSObject *v10;

  v2 = *(uint64_t **)(a1 + 48);
  v3 = CFGetAllocator((CFTypeRef)a1);
  _CFStreamClose(a1);
  v4 = *(_QWORD **)(a1 + 32);
  if (v4)
  {
    if (v4[1])
    {
      v5 = (void (*)(void))v4[3];
      if (v5)
      {
        v5();
        v4 = *(_QWORD **)(a1 + 32);
      }
    }
    v6 = (const void *)v4[8];
    if (v6)
    {
      CFRelease(v6);
      v4 = *(_QWORD **)(a1 + 32);
    }
    CFAllocatorDeallocate(v3, v4);
    *(_QWORD *)(a1 + 32) = 0;
  }
  if (v2)
  {
    v7 = (void (*)(_QWORD))v2[2];
    if (v7)
    {
      if (*v2)
        ((void (*)(uint64_t, _QWORD))v7)(a1, *(_QWORD *)(a1 + 40));
      else
        v7(*(_QWORD *)(a1 + 40));
    }
    v8 = *(void **)(a1 + 24);
    if (v8)
    {
      if (*v2 <= 1)
      {
        CFAllocatorDeallocate(v3, v8);
        goto LABEL_19;
      }
      goto LABEL_18;
    }
  }
  else
  {
    v8 = *(void **)(a1 + 24);
    if (v8)
LABEL_18:
      CFRelease(v8);
  }
LABEL_19:
  if ((*(_BYTE *)(a1 + 16) & 0x20) == 0)
    CFAllocatorDeallocate(v3, *(void **)(a1 + 48));
  v9 = *(const void **)(a1 + 120);
  if (v9)
  {
    CFRelease(v9);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v10 = *(NSObject **)(a1 + 128);
  if (v10)
  {
    dispatch_release(v10);
    *(_QWORD *)(a1 + 128) = 0;
  }
}

void writeDataFinalize(CFTypeRef cf, CFAllocatorRef *a2)
{
  __objc2_class **v4;
  _QWORD *v5;
  _QWORD *v6;
  const __CFAllocator *v7;

  v4 = (__objc2_class **)a2[2];
  if (v4 != &__kCFAllocatorNull)
  {
    v5 = (_QWORD *)*((_QWORD *)*a2 + 3);
    if (v5)
    {
      do
      {
        v6 = (_QWORD *)v5[3];
        CFAllocatorDeallocate(a2[2], v5);
        v5 = v6;
      }
      while (v6);
      v4 = (__objc2_class **)a2[2];
    }
    CFRelease(v4);
  }
  v7 = CFGetAllocator(cf);
  CFAllocatorDeallocate(v7, a2);
}

void readDataFinalize(const void *a1, CFTypeRef *a2)
{
  const __CFAllocator *v4;

  CFRelease(*a2);
  v4 = CFGetAllocator(a1);
  CFAllocatorDeallocate(v4, a2);
}

char *typeStringRetain(int a1, char *__s)
{
  char *v2;
  size_t v3;
  void *v4;

  v2 = __s;
  v3 = strlen(__s) + 1;
  if ((_dyld_is_memory_immutable() & 1) == 0)
  {
    v4 = malloc_type_malloc(v3, 0xE9BF9616uLL);
    memcpy(v4, v2, v3);
    return (char *)v4;
  }
  return v2;
}

void __CFErrorDeallocate(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 24));
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

void __CFBitVectorDeallocate(_QWORD *a1)
{
  const __CFAllocator *v2;
  void *v3;

  v2 = CFGetAllocator(a1);
  v3 = (void *)a1[4];
  if (v3)
    CFAllocatorDeallocate(v2, v3);
}

void __CFRunArrayDeallocate(_QWORD *a1)
{
  const void **v2;
  uint64_t v3;
  const void **v4;
  const void *v5;
  const __CFAllocator *v6;

  v2 = (const void **)a1[2];
  os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
  if ((uint64_t)*v2 > 1)
  {
    *v2 = (char *)*v2 - 1;
    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    if ((uint64_t)v2[2] >= 1)
    {
      v3 = 0;
      v4 = v2 + 7;
      do
      {
        v5 = *v4;
        v4 += 2;
        CFRelease(v5);
        ++v3;
      }
      while (v3 < (uint64_t)v2[2]);
    }
    v6 = CFGetAllocator(a1);
    CFAllocatorDeallocate(v6, v2);
  }
}

void __CFAttributedStringDeallocate(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 16));
  CFRelease(*(CFTypeRef *)(a1 + 24));
}

uint64_t _cfmp_deallocation_record_retain(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 5) & 1) != 0)
    _cfmp_deallocation_record_retain_cold_1();
  *(_BYTE *)(a2 + 5) |= 1u;
  return a2;
}

uint64_t CFStringEncodingCharLengthForBytes(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  uint64_t (*v12)(uint64_t, unint64_t, uint64_t);
  uint64_t v13;
  uint64_t (*v14)(uint64_t *, uint64_t, unint64_t, uint64_t, _QWORD, _QWORD, _QWORD *);
  uint64_t v15;
  uint64_t v16;
  unint64_t v18;
  uint64_t v19;
  BOOL v20;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  v7 = (uint64_t *)__CFGetConverter();
  if (!v7)
    return 0;
  v8 = v7;
  v9 = *v7;
  v10 = *(unsigned __int8 *)(*v7 + 20);
  if (v10 == 4)
    return __CFStringEncodingPlatformCharLengthForBytes();
  if (v10 == 5)
    return __CFStringEncodingICUCharLength(v7[1], a2, a3, a4);
  if (*(_WORD *)(v9 + 16) != 1)
  {
    v12 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v9 + 32);
    if (v12)
      return v12(a2, a3, a4);
    v21[0] = 0;
    if (a4 < 1)
      return 0;
    v13 = 0;
    while (1)
    {
      v14 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, _QWORD, _QWORD, _QWORD *))v8[2];
      if (v14)
      {
        if ((a2 & 0xC0) != 0)
          v14 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, _QWORD, _QWORD, _QWORD *))v8[3];
        v15 = v14(v8, a2, a3, a4, 0, 0, v21);
      }
      else
      {
        v15 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, _QWORD, _QWORD, _QWORD *))(*v8 + 8))(a2, a3, a4, 0, 0, v21);
      }
      v16 = a4 - v15;
      v13 += v21[0];
      if (v16 < 1 || (a2 & 1) == 0)
        break;
      v18 = a3 + v15;
      v19 = ((uint64_t (*)(unint64_t, uint64_t, _QWORD, _QWORD, _QWORD *))v8[5])(v18, v16, 0, 0, v21);
      a3 = v18 + v19;
      v13 += v21[0];
      v20 = v16 <= v19;
      a4 = v16 - v19;
      if (v20)
        return v13;
    }
    if (v16 >= 1)
      return 0;
    return v13;
  }
  return a4;
}

void fileFinalize(const void *a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  const __CFAllocator *v6;

  v4 = *(_DWORD *)(a2 + 8);
  v5 = *(_QWORD *)(a2 + 16);
  if (v4 < 1)
  {
    if (v5)
      CFRelease(*(CFTypeRef *)(a2 + 16));
  }
  else
  {
    if (v5)
    {
      CFFileDescriptorInvalidate(*(CFFileDescriptorRef *)(a2 + 16));
      CFRelease(*(CFTypeRef *)(a2 + 16));
      *(_QWORD *)(a2 + 16) = 0;
      v4 = *(_DWORD *)(a2 + 8);
    }
    close(v4);
  }
  if (*(_QWORD *)a2)
    CFRelease(*(CFTypeRef *)a2);
  v6 = CFGetAllocator(a1);
  CFAllocatorDeallocate(v6, (void *)a2);
}

void _cfmp_record_deallocation(unsigned __int8 a1, unsigned int a2, char a3, char a4)
{
  unsigned int v6;
  const __CFSet *v8;
  _BYTE *Value;
  char v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t v14;
  uint64_t v15;
  _DWORD v16[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v6 = a2;
    if (_cfmp_records_oGuard != -1)
      dispatch_once(&_cfmp_records_oGuard, &__block_literal_global_4);
    v8 = (const __CFSet *)_cfmp_records_oRecords;
    os_unfair_lock_lock((os_unfair_lock_t)&_cfmp_records_lock);
    v16[0] = v6;
    v16[1] = a1;
    Value = CFSetGetValue(v8, v16);
    if (Value)
    {
      v10 = Value[5];
      if ((v10 & 4) == 0)
      {
        Value[5] = (16 * (a4 & 1)) | (8 * (a3 & 1)) | v10 & 0xE7 | 2;
        os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
        return;
      }
      v6 = *(_DWORD *)Value;
      v14 = Value[4];
      v13 = (8 * (a3 & 1)) & 0xEF | (16 * (a4 & 1)) | v10 & 0xE7;
      v15 = *((unsigned __int16 *)Value + 3);
      CFSetRemoveValue(v8, Value);
      v12 = v15 << 48;
      v11 = v14 << 32;
    }
    else
    {
      v11 = 0;
      v12 = 0;
      v13 = (8 * (a3 & 1)) & 0xEF | (16 * (a4 & 1));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_cfmp_records_lock);
    _cfmp_cleanup(v11 | v6 | v12 | ((unint64_t)v13 << 40));
  }
}

void __CFMachPortDeallocate(uint64_t a1)
{
  os_unfair_lock_s *v2;
  NSObject *v3;
  __CFRunLoopSource *v4;
  void (*v5)(uint64_t, uint64_t);
  uint64_t v6;
  void (*v7)(uint64_t);
  unsigned int v8;
  unint64_t *v9;
  unsigned int v10;
  int v11;
  unsigned int v12;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    v2 = (os_unfair_lock_s *)(a1 + 96);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    if (!*(_DWORD *)(a1 + 16))
    {
      *(_DWORD *)(a1 + 16) = 1;
      __dmb(0xBu);
      v3 = *(NSObject **)(a1 + 24);
      if (v3)
      {
        dispatch_source_cancel(v3);
        *(_QWORD *)(a1 + 24) = 0;
      }
      v5 = *(void (**)(uint64_t, uint64_t))(a1 + 32);
      v4 = *(__CFRunLoopSource **)(a1 + 40);
      *(_QWORD *)(a1 + 40) = 0;
      v6 = *(_QWORD *)(a1 + 64);
      v7 = *(void (**)(uint64_t))(a1 + 112);
      *(_QWORD *)(a1 + 64) = 0;
      if (v5)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
        v5(a1, v6);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
      }
      if (v4)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
        CFRunLoopSourceInvalidate(v4);
        CFRelease(v4);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
      }
      if (v7)
      {
        if (v6)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
          v7(v6);
          os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
        }
      }
      *(_DWORD *)(a1 + 16) = 2;
      __dmb(0xBu);
    }
    *(_DWORD *)(a1 + 16) = 3;
    v8 = *(_DWORD *)(a1 + 20);
    v9 = (unint64_t *)(a1 + 8);
    v10 = atomic_load((unint64_t *)(a1 + 8));
    v11 = (v10 >> 2) & 1;
    LODWORD(v9) = atomic_load(v9);
    v12 = (v9 >> 1) & 1;
    os_unfair_lock_unlock(v2);
    _cfmp_record_deallocation(0, v8, v11, v12);
  }
}

void *blockCopyValueCallBack(int a1, void *aBlock)
{
  return _Block_copy(aBlock);
}

void __CFStorageClearRootNode(uint64_t a1)
{
  const __CFAllocator *v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;

  v2 = CFGetAllocator((CFTypeRef)a1);
  if (*(_BYTE *)(a1 + 157))
  {
    CFAllocatorDeallocate(v2, *(void **)(a1 + 168));
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 160);
    if (v3)
    {
      v4 = (unsigned int *)(v3 + 8);
      if (*(_DWORD *)(v3 + 8))
      {
        do
        {
          v5 = __ldxr(v4);
          v6 = v5 - 1;
        }
        while (__stxr(v6, v4));
        if (!v6)
          __CFStorageDeallocateNode((const void *)a1, v3);
      }
    }
    v7 = *(_QWORD *)(a1 + 168);
    if (v7)
    {
      v8 = (unsigned int *)(v7 + 8);
      if (*(_DWORD *)(v7 + 8))
      {
        do
        {
          v9 = __ldxr(v8);
          v10 = v9 - 1;
        }
        while (__stxr(v10, v8));
        if (!v10)
          __CFStorageDeallocateNode((const void *)a1, v7);
      }
    }
    v11 = *(_QWORD *)(a1 + 176);
    if (v11)
    {
      v12 = (unsigned int *)(v11 + 8);
      if (*(_DWORD *)(v11 + 8))
      {
        do
        {
          v13 = __ldxr(v12);
          v14 = v13 - 1;
        }
        while (__stxr(v14, v12));
        if (!v14)
          __CFStorageDeallocateNode((const void *)a1, v11);
      }
    }
  }
  *(_BYTE *)(a1 + 157) = 1;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
}

uint64_t __CFStringComputeEightBitStringEncoding()
{
  uint64_t result;
  int v1;

  if ((__CFStringComputeEightBitStringEncoding___CFStringIsBeingInitialized2 & 1) != 0)
    return 1536;
  __CFStringComputeEightBitStringEncoding___CFStringIsBeingInitialized2 = 1;
  v1 = _CFExecutableLinkedOnOrAfter(9uLL);
  __CFStringComputeEightBitStringEncoding___CFStringIsBeingInitialized2 = 0;
  if (v1)
  {
    result = 1536;
LABEL_5:
    __CFDefaultEightBitStringEncoding = result;
    return result;
  }
  if (__CFStringIsBeingInitialized == 1 || __CFIsReadyToInitializeSystemEncoding == 0)
    return 0;
  result = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    if (CFStringGetSystemEncoding() == -1)
      return 1536;
    result = 0;
    goto LABEL_5;
  }
  return result;
}

void __CFStringTokenizerDeallocate(uint64_t a1)
{
  const void *v1;

  if (a1)
  {
    v1 = *(const void **)(a1 + 16);
    if (v1)
      CFRelease(v1);
  }
}

uint64_t __CFStringEncodingICUCharLength(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  uint64_t v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  v5[0] = 0;
  if (__CFStringEncodingICUToUnicode(a1, a2, a3, a4, 0, 0, 0, v5))
    return 0;
  else
    return v5[0];
}

__n128 __CFRunLoopModeDeallocate(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  mach_error_t v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  __n128 result;

  v2 = *(const void **)(a1 + 96);
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 104);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 112);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 120);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 128);
  if (v6)
    CFRelease(v6);
  CFRelease(*(CFTypeRef *)(a1 + 80));
  v7 = mach_port_mod_refs(*MEMORY[0x1E0C83DA0], *(_DWORD *)(a1 + 136), 3u, -1);
  if (v7)
  {
    v8 = v7;
    mach_error_string(v7);
    CFLog(3, (uint64_t)CFSTR("error (%d - %s) while trying to free port set: %d"), v9, v10, v11, v12, v13, v14, v8);
  }
  v15 = *(NSObject **)(a1 + 152);
  if (v15)
  {
    dispatch_source_cancel(v15);
    dispatch_release(*(dispatch_object_t *)(a1 + 152));
  }
  v16 = *(NSObject **)(a1 + 160);
  if (v16)
    dispatch_release(v16);
  if (*(_DWORD *)(a1 + 172))
    mk_timer_destroy();
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  result.n128_u64[0] = 0x7C7C7C7C7C7C7C7CLL;
  result.n128_u64[1] = 0x7C7C7C7C7C7C7C7CLL;
  *(__n128 *)(a1 + 16) = result;
  *(__n128 *)(a1 + 32) = result;
  *(__n128 *)(a1 + 48) = result;
  *(__n128 *)(a1 + 64) = result;
  *(__n128 *)(a1 + 80) = result;
  *(__n128 *)(a1 + 96) = result;
  *(__n128 *)(a1 + 112) = result;
  *(__n128 *)(a1 + 128) = result;
  *(__n128 *)(a1 + 144) = result;
  *(__n128 *)(a1 + 160) = result;
  *(__n128 *)(a1 + 176) = result;
  *(_QWORD *)(a1 + 192) = 0x7C7C7C7C7C7C7C7CLL;
  return result;
}

uint64_t _CFBurstTrieRetainWrapper(uint64_t a1, uint64_t a2)
{
  return CFBurstTrieRetain(a2);
}

void CFRetain_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** CFRetain() called with NULL ***";
  __break(1u);
}

void __CFXNotificationRegistrarDeallocate(uint64_t a1)
{
  unint64_t v2;
  unint64_t i;
  int v4;
  void *v5;
  void *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const void **v10;
  void *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  const void **v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  void *v21;
  void *v22;
  void *v23;
  const void *v24;
  _OWORD v25[3];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v2)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 4 * i);
      if (v4 != -1)
      {
        v5 = *(void **)(*(_QWORD *)(a1 + 96) + 40 * v4 + 24);
        if (v5)
        {
          free(v5);
          v2 = *(unsigned int *)(a1 + 40);
        }
      }
    }
  }
  v6 = *(void **)(a1 + 96);
  if (v6)
  {
    v7 = *(unsigned int *)(a1 + 108);
    if ((_DWORD)v7)
    {
      v8 = 0;
      v9 = 8;
      do
      {
        v10 = (const void **)(*(_QWORD *)(a1 + 96) + v9);
        if (*v10)
        {
          _CFXNotificationRegistrarRemoveCachedName(v10);
          v7 = *(unsigned int *)(a1 + 108);
        }
        ++v8;
        v9 += 40;
      }
      while (v8 < v7);
      v6 = *(void **)(a1 + 96);
    }
    free(v6);
  }
  v11 = *(void **)(a1 + 120);
  if (v11)
  {
    if ((*(_BYTE *)(a1 + 24) & 2) != 0)
    {
      v12 = *(unsigned int *)(a1 + 132);
      if ((_DWORD)v12)
      {
        v13 = 0;
        v14 = 8;
        do
        {
          v15 = (const void **)(*(_QWORD *)(a1 + 120) + v14);
          if (*v15)
          {
            _CFXNotificationRegistrarRemoveCachedName(v15);
            v12 = *(unsigned int *)(a1 + 132);
          }
          ++v13;
          v14 += 32;
        }
        while (v13 < v12);
        v11 = *(void **)(a1 + 120);
      }
    }
    free(v11);
  }
  v16 = *(unsigned int *)(a1 + 156);
  if ((_DWORD)v16)
  {
    v17 = 0;
    v18 = 44;
    do
    {
      v19 = *(_QWORD *)(a1 + 144);
      v20 = *(_DWORD *)(v19 + v18);
      if ((v20 & 0x8000) == 0)
      {
        if ((v20 & 0x400) != 0)
        {
          objc_destroyWeak((id *)(v19 + v18 - 36));
          v20 = *(_DWORD *)(v19 + v18);
        }
        memset(v25, 0, sizeof(v25));
        _CFXNotificationHandlerRelease((uint64_t *)(v19 + v18 - 28), v20, (unsigned int *)v25);
        _CFXNotificationDisposalListRelease((unsigned int *)v25);
        v16 = *(unsigned int *)(a1 + 156);
      }
      ++v17;
      v18 += 56;
    }
    while (v17 < v16);
  }
  free(*(void **)(a1 + 144));
  v21 = *(void **)(a1 + 32);
  if (v21)
    free(v21);
  v22 = *(void **)(a1 + 48);
  if (v22)
    free(v22);
  v23 = *(void **)(a1 + 64);
  if (v23)
    free(v23);
  v24 = *(const void **)(a1 + 88);
  if (v24)
    CFRelease(v24);
}

void __CFNotificationCenterDeallocate(uint64_t a1)
{
  _xpc_connection_s *v2;

  CFRelease(*(CFTypeRef *)(a1 + 16));
  *(_QWORD *)(a1 + 16) = 0;
  v2 = *(_xpc_connection_s **)(a1 + 24);
  if (v2)
  {
    xpc_connection_cancel(v2);
    xpc_release(*(xpc_object_t *)(a1 + 24));
  }
}

void boundPairWriteFinalize(uint64_t a1, unsigned __int8 *a2)
{
  pthread_mutex_t *v3;
  int v4;
  const void *v5;

  if (a2)
  {
    v3 = (pthread_mutex_t *)(a2 + 104);
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    v4 = *a2;
    a2[48] = 1;
    *((_WORD *)a2 + 26) = 0;
    v5 = (const void *)*((_QWORD *)a2 + 8);
    if (v5)
    {
      CFRelease(v5);
      *((_QWORD *)a2 + 8) = 0;
    }
    pthread_mutex_unlock(v3);
    if (v4)
      boundPairCommonFinalize((uint64_t)a2);
  }
}

void __CFBasicHashDrain(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void (*v13)(const CFAllocatorRef, uint64_t);
  const CFAllocatorRef *v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(const CFAllocatorRef, uint64_t);
  const CFAllocatorRef *v19;
  char v20;
  void *ptr;
  const __CFAllocator *v22;
  uint64_t *v23;

  v2 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  v3 = 0;
  v22 = CFGetAllocator((CFTypeRef)a1);
  v23 = *(uint64_t **)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  v4 = *(unsigned __int16 *)(a1 + 18);
  if ((v4 & 4) != 0)
  {
    v5 = a1 + 8 * ((v4 >> 2) & 1);
    v3 = *(uint64_t **)(v5 + 40);
    *(_QWORD *)(v5 + 40) = 0;
  }
  if ((v4 & 0x18) != 0)
  {
    v6 = a1 + (v4 & 0x18);
    ptr = *(void **)(v6 + 40);
    *(_QWORD *)(v6 + 40) = 0;
  }
  else
  {
    ptr = 0;
  }
  ++*(_WORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 20) = 0;
  *(_QWORD *)(a1 + 24) = v7 & 0xFFFFFFFFFF000000;
  if (v2 >= 1)
  {
    v8 = v23;
    v9 = v3;
    do
    {
      v11 = *v8++;
      v10 = v11;
      if ((unint64_t)(v11 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v10 == 2814029233)
          v10 = 0;
        if (v10 == 2780474809)
          v12 = -1;
        else
          v12 = v10;
        if ((*(_QWORD *)(a1 + 32) & 2) == 0)
        {
          v13 = *(void (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                                  + (HIBYTE(*(_QWORD *)(a1 + 24)) & 0xF8))
                                                                     + 8 * ((*(_QWORD *)(a1 + 24) >> 54) & 0x1FLL));
          if (v13)
          {
            v14 = &kCFAllocatorSystemDefault;
            if ((a1 & 0x8000000000000000) == 0)
            {
              v15 = atomic_load((unint64_t *)(a1 + 8));
              if (v15 < 0)
                v14 = &kCFAllocatorSystemDefault;
              else
                v14 = (const CFAllocatorRef *)(a1 - 16);
            }
            v13(*v14, v12);
          }
        }
        if (v3)
        {
          v16 = *v9;
          if (*v9 == 2814029233)
            v16 = 0;
          if (v16 == 2780474809)
            v17 = -1;
          else
            v17 = v16;
          if ((*(_QWORD *)(a1 + 32) & 2) == 0)
          {
            v18 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(a1 + 24) >> 49) & 0x1FLL]
                                                                       + 8 * ((*(_QWORD *)(a1 + 24) >> 44) & 0x1FLL));
            if (v18)
            {
              v19 = &kCFAllocatorSystemDefault;
              if ((a1 & 0x8000000000000000) == 0)
              {
                v20 = atomic_load((unint64_t *)(a1 + 8));
                if (v20 < 0)
                  v19 = &kCFAllocatorSystemDefault;
                else
                  v19 = (const CFAllocatorRef *)(a1 - 16);
              }
              v18(*v19, v17);
            }
          }
        }
      }
      ++v9;
      --v2;
    }
    while (v2);
  }
  CFAllocatorDeallocate(v22, v23);
  CFAllocatorDeallocate(v22, v3);
  CFAllocatorDeallocate(v22, ptr);
  CFAllocatorDeallocate(v22, 0);
}

void CFRelease(CFTypeRef cf)
{
  unint64_t v2;

  if (!cf)
    CFRelease_cold_1();
  if (((unint64_t)cf & 0x8000000000000000) == 0)
  {
    v2 = atomic_load((unint64_t *)cf + 1);
    if (CF_IS_OBJC((v2 >> 8) & 0x3FF, (__objc2_class **)cf))

    else
      _CFRelease((void *)cf);
  }
}

void __CFTypeCollectionRelease(int a1, CFTypeRef cf)
{
  if (!cf)
    __CFTypeCollectionRelease_cold_1();
  CFRelease(cf);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
    return -[__CFDictionary __getValue:forKey:](theDict, "__getValue:forKey:", value, key);
  v7 = 0u;
  v8 = 0u;
  CFBasicHashFindBucket((uint64_t)theDict, (unint64_t)key, (uint64_t *)&v7);
  if (!*((_QWORD *)&v8 + 1))
    return 0;
  if (value)
    *value = (const void *)v8;
  return 1;
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
    return (const void *)-[__CFDictionary objectForKey:](theDict, "objectForKey:", key);
  v5 = 0u;
  v6 = 0u;
  CFBasicHashFindBucket((uint64_t)theDict, (unint64_t)key, (uint64_t *)&v5);
  if (*((_QWORD *)&v6 + 1))
    return (const void *)v6;
  else
    return 0;
}

unint64_t ___CFBasicHashFindBucket_Linear@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6;
  uint64_t (*v7)(unint64_t);
  unint64_t result;
  unint64_t v9;
  _QWORD *v10;
  uint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, unint64_t);
  unint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t *v26;

  v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  result = a2;
  if (v7)
    result = v7(a2);
  v9 = *(unsigned __int16 *)(a1 + 18);
  v10 = (_QWORD *)(a1 + 40);
  if ((v9 & 4) != 0)
    v11 = (uint64_t *)(a1 + 40 + 8 * ((v9 >> 2) & 1));
  else
    v11 = (uint64_t *)(a1 + 40);
  v26 = a3;
  if (!v6)
  {
    v14 = -1;
LABEL_27:
    v16 = 0;
    v20 = v26;
    v26[1] = 0;
    v26[2] = 0;
    *v26 = v14;
    goto LABEL_28;
  }
  v12 = result % v6;
  v13 = *v11;
  v14 = -1;
  v15 = v6;
  while (1)
  {
    v16 = *(_QWORD *)(v13 + 8 * v12);
    switch(v16)
    {
      case -1:
        if (v14 == -1)
          v14 = v12;
        goto LABEL_21;
      case 0:
        v20 = v26;
        v26[1] = 0;
        v26[2] = 0;
        if (v14 == -1)
          v21 = v12;
        else
          v21 = v14;
        *v26 = v21;
        goto LABEL_28;
      case 2814029233:
        v16 = 0;
        break;
    }
    v17 = v16 == 2780474809 ? -1 : v16;
    if (v17 == a2)
      break;
    v18 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8 * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v18)
    {
      result = v18(v17, a2);
      if ((_DWORD)result)
        goto LABEL_34;
    }
LABEL_21:
    if (v6 <= v12 + 1)
      v19 = v6;
    else
      v19 = 0;
    v12 = v12 + 1 - v19;
    if (!--v15)
      goto LABEL_27;
  }
  v17 = a2;
LABEL_34:
  v22 = *(_QWORD *)(*v10 + 8 * v12);
  v23 = -1;
  if (v22 != 2780474809)
    v23 = *(_QWORD *)(*v10 + 8 * v12);
  if (v22 == 2814029233)
    v24 = 0;
  else
    v24 = v23;
  v20 = v26;
  v26[1] = v17;
  v26[2] = v24;
  *v26 = v12;
  v25 = *(unsigned __int16 *)(a1 + 18);
  if ((v25 & 0x18) != 0)
    __asm { BR              X11 }
  v16 = 1;
LABEL_28:
  v20[3] = v16;
  return result;
}

void sub_182A98B04()
{
  JUMPOUT(0x182A98A48);
}

void sub_182A98B0C()
{
  JUMPOUT(0x182A98A48);
}

void sub_182A98B14()
{
  JUMPOUT(0x182A98A48);
}

uint64_t CFBasicHashFindBucket@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  BOOL v3;
  int v4;

  v3 = a2 == 2814029233 || a2 == 2780474809;
  if (v3 || !*(_BYTE *)(a1 + 26))
  {
    *(_OWORD *)a3 = xmmword_182DC7A10;
    *((_OWORD *)a3 + 1) = unk_182DC7A20;
    return a1;
  }
  v4 = *(_WORD *)(a1 + 18) & 3;
  if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
  {
    switch(v4)
    {
      case 3:
        return ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, a3);
      case 2:
        return ___CFBasicHashFindBucket_Double_Indirect(a1, a2, a3);
      case 1:
        return ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, a3);
    }
  }
  else
  {
    switch(v4)
    {
      case 3:
        return ___CFBasicHashFindBucket_Exponential(a1, a2, a3);
      case 2:
        return ___CFBasicHashFindBucket_Double(a1, a2, a3);
      case 1:
        return ___CFBasicHashFindBucket_Linear(a1, a2, a3);
    }
  }
  __break(1u);
  return a1;
}

CFHashCode CFHash(CFTypeRef cf)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t (*v12)(uint64_t);
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _UNKNOWN **v16;
  uint64_t v18;
  uint64_t i;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  int v27;

  if (!cf)
    CFHash_cold_1();
  if (((unint64_t)cf & 0x8000000000000000) != 0)
  {
    v2 = 0;
    v3 = (uint64_t *)MEMORY[0x1E0DE7C58];
    v4 = *MEMORY[0x1E0DE7C58];
    v5 = (unint64_t)cf & 0xC000000000000007;
    if (((unint64_t)cf & 0xC000000000000007) == 0xC000000000000007)
      v4 = 0;
    v6 = v4 ^ (unint64_t)cf;
    v7 = v6 & 7;
    v8 = MEMORY[0x1E0DE7C48];
    do
    {
      if (v7 == *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v2))
        break;
      ++v2;
    }
    while (v2 != 7);
    v9 = v2 | v6;
    v10 = v2 & 7;
    v11 = (v9 >> 55) + 8;
    if (v10 == 7)
      LODWORD(v10) = v11;
    if ((_DWORD)v10)
    {
      if ((_DWORD)v10 == 3)
      {
        v12 = __CFNumberHash;
        return v12((uint64_t)cf);
      }
    }
    else
    {
      if ((dyld_program_sdk_at_least() & 1) != 0)
        CFHash_cold_4();
      v18 = *v3;
      if (v5 == 0xC000000000000007)
        v18 = 0;
      v6 = v18 ^ (unint64_t)cf;
      v7 = v6 & 7;
    }
    for (i = 0; i != 7; ++i)
    {
      if (v7 == *(unsigned __int8 *)(v8 + i))
        break;
    }
    v20 = ((i | v6) >> 55) + 8;
    if ((i & 7) != 7)
      v20 = i & 7;
    v21 = 22;
    switch(v20)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          CFHash_cold_3();
        goto LABEL_37;
      case 1:
        goto LABEL_38;
      case 2:
        goto LABEL_36;
      case 3:
        goto LABEL_40;
      case 4:
      case 5:
        goto LABEL_37;
      case 6:
        v21 = 42;
        goto LABEL_40;
      default:
        if (v20 == 20)
        {
LABEL_37:
          v21 = 1;
        }
        else if (v20 == 22)
        {
LABEL_36:
          v21 = 7;
        }
        else
        {
LABEL_38:
          v21 = objc_msgSend((id)cf, "_cfTypeID");
        }
LABEL_40:
        if (CF_IS_OBJC(v21, (__objc2_class **)cf))
          return objc_msgSend((id)cf, "hash");
        v22 = 0;
        v23 = *v3;
        if (v5 == 0xC000000000000007)
          v23 = 0;
        v24 = v23 ^ (unint64_t)cf;
        do
        {
          if ((v24 & 7) == *(_BYTE *)(v8 + v22))
            break;
          ++v22;
        }
        while (v22 != 7);
        v25 = v22 | v24;
        v26 = v22 & 7;
        v27 = (v25 >> 55) + 8;
        if (v26 == 7)
          LODWORD(v26) = v27;
        v15 = 22;
        switch((int)v26)
        {
          case 0:
            if (dyld_program_sdk_at_least())
              CFHash_cold_2();
            goto LABEL_55;
          case 1:
            goto LABEL_56;
          case 2:
            goto LABEL_54;
          case 3:
            goto LABEL_16;
          case 4:
          case 5:
            goto LABEL_55;
          case 6:
            v15 = 42;
            goto LABEL_16;
          default:
            if ((_DWORD)v26 == 20)
            {
LABEL_55:
              v15 = 1;
              goto LABEL_16;
            }
            if ((_DWORD)v26 == 22)
            {
LABEL_54:
              v15 = 7;
              goto LABEL_16;
            }
LABEL_56:
            v15 = objc_msgSend((id)cf, "_cfTypeID");
            break;
        }
        break;
    }
  }
  else
  {
    v13 = atomic_load((unint64_t *)cf + 1);
    if (CF_IS_OBJC((v13 >> 8) & 0x3FF, (__objc2_class **)cf))
      return objc_msgSend((id)cf, "hash");
    v14 = atomic_load((unint64_t *)cf + 1);
    v15 = (v14 >> 8) & 0x3FF;
  }
  if (v15 > 0x47)
    v16 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v15 - 72) >> 6] + 8 * (((_DWORD)v15 - 72) & 0x3F));
  else
LABEL_16:
    v16 = &__CFRuntimeBuiltinClassTable + v15;
  v12 = (uint64_t (*)(uint64_t))*((_QWORD *)*v16 + 6);
  if (v12)
    return v12((uint64_t)cf);
  return (CFHashCode)cf;
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  unint64_t v22;
  void *v23;
  CFTypeRef v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  unint64_t v48;
  int TaggedPointerTag;
  unint64_t v50;
  unint64_t v51;
  _UNKNOWN **v52;
  uint64_t (*v53)(CFTypeRef, CFTypeRef);

  if (!cf1)
    CFEqual_cold_1();
  if (cf1 == cf2)
    return 1;
  if (!cf2)
    CFEqual_cold_2();
  if (((unint64_t)cf1 & 0x8000000000000000) != 0)
  {
    v4 = *MEMORY[0x1E0DE7C58];
    v5 = (unint64_t)cf1 & 0xC000000000000007;
    if (((unint64_t)cf2 & 0x8000000000000000) != 0)
    {
      v6 = 0;
      if (v5 == 0xC000000000000007)
        v7 = 0;
      else
        v7 = *MEMORY[0x1E0DE7C58];
      do
      {
        if (((v7 ^ (unint64_t)cf1) & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v6))
          break;
        ++v6;
      }
      while (v6 != 7);
      v8 = 0;
      v9 = v6 | v7 ^ (unint64_t)cf1;
      v10 = v6 & 7;
      v11 = (v9 >> 55) + 8;
      if (v10 == 7)
        LODWORD(v10) = v11;
      if ((~(unint64_t)cf2 & 0xC000000000000007) != 0)
        v12 = *MEMORY[0x1E0DE7C58];
      else
        v12 = 0;
      v13 = v12 ^ (unint64_t)cf2;
      do
      {
        if ((v13 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v8))
          break;
        ++v8;
      }
      while (v8 != 7);
      v14 = v8 | v13;
      v15 = v8 & 7;
      v16 = (v14 >> 55) + 8;
      if (v15 != 7)
        v16 = v15;
      if ((_DWORD)v10 != v16 || v10 <= 6 && ((1 << v10) & 0x54) != 0)
        return 0;
    }
    v17 = 0;
    if (v5 == 0xC000000000000007)
      v4 = 0;
    v18 = v4 ^ (unint64_t)cf1;
    do
    {
      if ((v18 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v17))
        break;
      ++v17;
    }
    while (v17 != 7);
    v19 = ((v17 | v18) >> 55) + 8;
    if ((v17 & 7) != 7)
      v19 = v17 & 7;
    v20 = 22;
    switch(v19)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          CFEqual_cold_7();
        goto LABEL_53;
      case 1:
        goto LABEL_58;
      case 2:
        goto LABEL_52;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_53;
      case 6:
        v20 = 42;
        break;
      default:
        if (v19 == 20)
        {
LABEL_53:
          v20 = 1;
        }
        else if (v19 == 22)
        {
LABEL_52:
          v20 = 7;
        }
        else
        {
LABEL_58:
          v20 = objc_msgSend((id)cf1, "_cfTypeID");
        }
        break;
    }
  }
  else
  {
    v22 = atomic_load((unint64_t *)cf1 + 1);
    v20 = (v22 >> 8) & 0x3FF;
  }
  if (CF_IS_OBJC(v20, (__objc2_class **)cf1))
  {
    v23 = (void *)cf1;
    v24 = cf2;
    return objc_msgSend(v23, "isEqual:", v24);
  }
  if (((unint64_t)cf2 & 0x8000000000000000) != 0)
  {
    v25 = 0;
    v26 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)cf2 & 0xC000000000000007) == 0)
      v26 = 0;
    v27 = v26 ^ (unint64_t)cf2;
    do
    {
      if ((v27 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v25))
        break;
      ++v25;
    }
    while (v25 != 7);
    v28 = v25 | v27;
    v29 = v25 & 7;
    v30 = (v28 >> 55) + 8;
    if (v29 == 7)
      LODWORD(v29) = v30;
    v31 = 22;
    switch((int)v29)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          CFEqual_cold_6();
        goto LABEL_57;
      case 1:
        goto LABEL_60;
      case 2:
        goto LABEL_56;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_57;
      case 6:
        v31 = 42;
        break;
      default:
        if ((_DWORD)v29 == 20)
        {
LABEL_57:
          v31 = 1;
        }
        else if ((_DWORD)v29 == 22)
        {
LABEL_56:
          v31 = 7;
        }
        else
        {
LABEL_60:
          v31 = objc_msgSend((id)cf2, "_cfTypeID");
        }
        break;
    }
  }
  else
  {
    v32 = atomic_load((unint64_t *)cf2 + 1);
    v31 = (v32 >> 8) & 0x3FF;
  }
  if (CF_IS_OBJC(v31, (__objc2_class **)cf2))
  {
    v23 = (void *)cf2;
    v24 = cf1;
    return objc_msgSend(v23, "isEqual:", v24);
  }
  if (((unint64_t)cf1 & 0x8000000000000000) != 0)
  {
    v33 = 0;
    v34 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)cf1 & 0xC000000000000007) == 0)
      v34 = 0;
    v35 = v34 ^ (unint64_t)cf1;
    do
    {
      if ((v35 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v33))
        break;
      ++v33;
    }
    while (v33 != 7);
    v36 = v33 | v35;
    v37 = v33 & 7;
    v38 = (v36 >> 55) + 8;
    if (v37 == 7)
      LODWORD(v37) = v38;
    v39 = 22;
    switch((int)v37)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          CFEqual_cold_5();
        goto LABEL_80;
      case 1:
        goto LABEL_81;
      case 2:
        goto LABEL_79;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_80;
      case 6:
        v39 = 42;
        break;
      default:
        if ((_DWORD)v37 == 20)
        {
LABEL_80:
          v39 = 1;
        }
        else if ((_DWORD)v37 == 22)
        {
LABEL_79:
          v39 = 7;
        }
        else
        {
LABEL_81:
          v39 = objc_msgSend((id)cf1, "_cfTypeID");
        }
        break;
    }
  }
  else
  {
    v40 = atomic_load((unint64_t *)cf1 + 1);
    v39 = (v40 >> 8) & 0x3FF;
  }
  if (((unint64_t)cf2 & 0x8000000000000000) != 0)
  {
    v41 = 0;
    v42 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)cf2 & 0xC000000000000007) == 0)
      v42 = 0;
    v43 = v42 ^ (unint64_t)cf2;
    do
    {
      if ((v43 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v41))
        break;
      ++v41;
    }
    while (v41 != 7);
    v44 = v41 | v43;
    v45 = v41 & 7;
    v46 = (v44 >> 55) + 8;
    if (v45 == 7)
      LODWORD(v45) = v46;
    v47 = 22;
    switch((int)v45)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          CFEqual_cold_4();
        goto LABEL_98;
      case 1:
        goto LABEL_99;
      case 2:
        goto LABEL_97;
      case 3:
        break;
      case 4:
      case 5:
        goto LABEL_98;
      case 6:
        v47 = 42;
        break;
      default:
        if ((_DWORD)v45 == 20)
        {
LABEL_98:
          v47 = 1;
        }
        else if ((_DWORD)v45 == 22)
        {
LABEL_97:
          v47 = 7;
        }
        else
        {
LABEL_99:
          v47 = objc_msgSend((id)cf2, "_cfTypeID");
        }
        break;
    }
  }
  else
  {
    v48 = atomic_load((unint64_t *)cf2 + 1);
    v47 = (v48 >> 8) & 0x3FF;
  }
  if (v39 == v47)
  {
    if (((unint64_t)cf1 & 0x8000000000000000) != 0)
    {
      TaggedPointerTag = _objc_getTaggedPointerTag((uint64_t)cf1);
      v50 = 22;
      switch(TaggedPointerTag)
      {
        case 0:
          if (dyld_program_sdk_at_least())
            CFEqual_cold_3();
          goto LABEL_112;
        case 1:
          goto LABEL_113;
        case 2:
          goto LABEL_111;
        case 3:
          goto LABEL_115;
        case 4:
        case 5:
          goto LABEL_112;
        case 6:
          v50 = 42;
          goto LABEL_115;
        default:
          if (TaggedPointerTag == 20)
          {
LABEL_112:
            v50 = 1;
            goto LABEL_115;
          }
          if (TaggedPointerTag == 22)
          {
LABEL_111:
            v50 = 7;
            goto LABEL_115;
          }
LABEL_113:
          v50 = objc_msgSend((id)cf1, "_cfTypeID");
          break;
      }
    }
    else
    {
      v51 = atomic_load((unint64_t *)cf1 + 1);
      v50 = (v51 >> 8) & 0x3FF;
    }
    if (v50 <= 0x47)
LABEL_115:
      v52 = &__CFRuntimeBuiltinClassTable + v50;
    else
      v52 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v50 - 72) >> 6] + 8 * (((_DWORD)v50 - 72) & 0x3F));
    v53 = (uint64_t (*)(CFTypeRef, CFTypeRef))*((_QWORD *)*v52 + 5);
    if (v53)
      return v53(cf1, cf2);
  }
  return 0;
}

CFComparisonResult CFStringCompareWithOptionsAndLocale(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions, CFLocaleRef locale)
{
  CFIndex length;
  CFIndex location;
  const __CFString *v9;
  CFIndex v11;
  CFStringCompareFlags v12;
  uint64_t v13;
  const __CFLocale *v14;
  CFStringCompareFlags v15;
  uint64_t SpecialCaseHandlingLanguageIdentifierForLocale;
  uint64_t v17;
  unint64_t v18;
  CFComparisonResult v19;
  char v20;
  int64_t v21;
  const __CFString *v22;
  unsigned int v23;
  uint64_t CStringPtrInternal;
  uint64_t v25;
  unsigned __int16 *v26;
  CFIndex v27;
  unsigned __int8 *v28;
  int v29;
  CFComparisonResult v30;
  uint64_t v31;
  uint64_t v32;
  const UniChar *CharactersPtr;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  CFComparisonResult v42;
  BOOL v43;
  const UniChar *v44;
  uint64_t v45;
  unsigned int v46;
  int64_t v47;
  uint64_t v48;
  int v49;
  char v50;
  int64_t v51;
  uint64_t v52;
  uint64_t v53;
  int64_t v54;
  int64_t v55;
  uint64_t v56;
  uint64_t v57;
  int64_t v58;
  int64_t v59;
  uint64_t v60;
  uint64_t v61;
  int64_t v62;
  uint64_t v63;
  int64_t v64;
  uint64_t v65;
  int64_t v66;
  UTF32Char v67;
  uint64_t v68;
  int64_t v69;
  UniChar *v70;
  int64_t v71;
  UniChar v72;
  uint64_t v73;
  UniChar *v74;
  int64_t v75;
  UniChar v76;
  CFComparisonResult v77;
  BOOL v78;
  int v79;
  uint64_t v80;
  int64_t v81;
  UniChar *v82;
  uint64_t v83;
  UniChar v84;
  uint64_t v85;
  UniChar *v86;
  uint64_t v87;
  UniChar v88;
  uint64_t v89;
  char v90;
  UTF32Char v91;
  unsigned int v92;
  BOOL v93;
  uint64_t v94;
  int64_t v95;
  int64_t v96;
  uint64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  uint64_t v101;
  int IsLongCharacterMember;
  BOOL v103;
  uint64_t v104;
  unsigned int v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  BOOL v109;
  BOOL v110;
  uint64_t v112;
  uint64_t v113;
  int64_t v114;
  uint64_t v115;
  uint64_t v116;
  int64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  int64_t v121;
  uint64_t v122;
  int64_t v123;
  int v124;
  unsigned int v125;
  BOOL v126;
  char v127;
  uint64_t v128;
  int64_t v129;
  uint64_t v130;
  int v131;
  BOOL v132;
  char v133;
  uint64_t v134;
  _BOOL4 v135;
  uint64_t v137;
  char v138;
  unint64_t v139;
  uint64_t v140;
  _BOOL4 v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  int64_t v145;
  int64_t v146;
  int64_t v147;
  uint64_t v148;
  int64_t v149;
  int v150;
  uint64_t v151;
  uint64_t v152;
  int64_t v153;
  int64_t v154;
  int64_t v155;
  uint64_t v156;
  int v157;
  UTF32Char v158;
  uint64_t v159;
  _BOOL4 v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  int64_t v164;
  uint64_t v165;
  uint64_t v166;
  int64_t v167;
  uint64_t v168;
  uint64_t RangeOfCharacterClusterAtIndex;
  uint64_t v170;
  uint64_t v173;
  uint64_t v174;
  int64_t v175;
  uint64_t v176;
  int64_t v177;
  uint64_t v178;
  unsigned int v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  unint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  UniChar v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  int64_t v192;
  unsigned int v193;
  uint64_t v194;
  unint64_t v195;
  UniChar *v196;
  uint64_t v197;
  uint64_t v198;
  UniChar v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  unsigned int v203;
  uint64_t v204;
  int v205;
  int64_t v206;
  uint64_t v207;
  unsigned int v208;
  unsigned int v209;
  uint64_t v210;
  BOOL v211;
  CFLocaleRef v212;
  uint64_t v213;
  int64_t v214;
  int64_t v215;
  UniChar *v216;
  int64_t v217;
  UniChar v218;
  UTF32Char v219;
  uint64_t v220;
  uint64_t v221;
  int64_t v222;
  UniChar *v223;
  uint64_t v224;
  UniChar v225;
  uint64_t v226;
  unsigned int v227;
  BOOL v228;
  char v229;
  int v230;
  BOOL v231;
  char v232;
  unsigned int v233;
  uint64_t v234;
  uint64_t v235;
  int64_t v236;
  _BOOL4 v237;
  uint64_t v238;
  uint64_t v239;
  int64_t v240;
  int64_t v241;
  UniChar *v242;
  int64_t v243;
  UniChar v244;
  UTF32Char v245;
  uint64_t v246;
  uint64_t v247;
  int64_t v248;
  UniChar *v249;
  uint64_t v250;
  UniChar v251;
  uint64_t v252;
  unsigned int v253;
  BOOL v254;
  char v255;
  int v256;
  BOOL v257;
  char v258;
  unsigned int v259;
  uint64_t v260;
  uint64_t v261;
  int64_t v262;
  _BOOL4 v263;
  uint64_t v264;
  uint64_t v265;
  int64_t v266;
  char v267;
  char v268;
  uint64_t v269;
  CFComparisonResult v270;
  CFIndex v271;
  int v272;
  int v273;
  BOOL v274;
  CFComparisonResult v276;
  int64_t v277;
  int64_t v278;
  int64_t v279;
  unint64_t v280;
  unsigned int v281;
  uint64_t v282;
  __CFString *v283;
  int64_t v284;
  int64_t v285;
  int64_t v286;
  int64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  int64_t v297;
  uint64_t v298;
  uint64_t v299;
  int64_t v300;
  int64_t v301;
  unint64_t v302;
  int v303;
  uint64_t v304;
  char *__s1;
  unsigned int v306;
  int64_t v307;
  int64_t v308;
  uint64_t BitmapPtrForPlane;
  int64_t v310;
  int64_t v311;
  int64_t v312;
  int64_t v313;
  __CFString *theString;
  int v315[2];
  int v316[2];
  CFLocaleRef cf;
  char v318;
  uint64_t v319;
  uint64_t v320;
  int64_t v321;
  UTF32Char theChar;
  UTF32Char theChara[2];
  UTF32Char theCharb[2];
  UTF32Char theCharc[2];
  UTF32Char theChard[2];
  int64_t v327;
  int v328;
  uint64_t v329;
  UniChar *v330;
  CFStringCompareFlags v331;
  uint64_t v332;
  uint64_t v333;
  char v334;
  CFCharacterSetRef theSet[2];
  __int128 v336;
  uint64_t v337;
  uint64_t v338;
  UniChar buffer[8];
  __int128 v340;
  __int128 v341;
  __int128 v342;
  __int128 v343;
  __int128 v344;
  __int128 v345;
  __int128 v346;
  __int128 v347;
  __int128 v348;
  __int128 v349;
  int64_t v350;
  UniChar v351[8];
  __int128 v352;
  __int128 v353;
  __int128 v354;
  __int128 v355;
  __int128 v356;
  __int128 v357;
  __int128 v358;
  __int128 v359;
  __int128 v360;
  __int128 v361;
  int64_t v362;
  unsigned int v363[64];
  unsigned int v364[64];
  uint64_t v365;
  CFRange v366;
  CFRange v367;
  CFRange v368;
  CFRange v369;
  CFRange v370;
  CFRange v371;
  CFRange v372;
  CFRange v373;
  CFRange v374;
  CFRange v375;

  length = rangeToCompare.length;
  location = rangeToCompare.location;
  v9 = theString2;
  v365 = *MEMORY[0x1E0C80C00];
  v11 = CFStringGetLength(theString2);
  v12 = compareOptions;
  v13 = v11;
  v306 = (locale == 0) & (compareOptions >> 5);
  v331 = compareOptions;
  if (v306 == 1)
  {
    v14 = CFLocaleCopyCurrent();
    v12 = compareOptions;
    locale = v14;
  }
  v15 = v12 & 0x191;
  if (locale)
  {
    SpecialCaseHandlingLanguageIdentifierForLocale = _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 1);
    v12 = v331;
    __s1 = (char *)SpecialCaseHandlingLanguageIdentifierForLocale;
  }
  else
  {
    __s1 = 0;
  }
  v362 = 0;
  v360 = 0u;
  v361 = 0u;
  v358 = 0u;
  v359 = 0u;
  v356 = 0u;
  v357 = 0u;
  v354 = 0u;
  v355 = 0u;
  v352 = 0u;
  v353 = 0u;
  *(_OWORD *)v351 = 0u;
  *(_OWORD *)buffer = 0u;
  v340 = 0u;
  v341 = 0u;
  v342 = 0u;
  v343 = 0u;
  v344 = 0u;
  v345 = 0u;
  v346 = 0u;
  v347 = 0u;
  v348 = 0u;
  v349 = 0u;
  v350 = 0;
  v337 = 0;
  v338 = 0;
  *(_OWORD *)theSet = 0u;
  v336 = 0u;
  v17 = __CFStringFillCharacterSetInlineBuffer((uint64_t)theSet, v12);
  v18 = v331;
  v19 = kCFCompareEqualTo;
  if (v15)
    v20 = 1;
  else
    v20 = v17;
  v318 = v20;
  v328 = v17;
  theString = (__CFString *)theString1;
  if ((v331 & 0x40) != 0 || locale)
  {
    v21 = 0;
    goto LABEL_28;
  }
  v21 = 0;
  if ((v17 & 1) != 0)
    goto LABEL_28;
  v22 = v9;
  v23 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding(v17);
    v23 = __CFDefaultEightBitStringEncoding;
  }
  CStringPtrInternal = _CFStringGetCStringPtrInternal((uint64_t)theString, v23, 0, 1);
  v25 = _CFStringGetCStringPtrInternal((uint64_t)v22, v23, 0, 1);
  v26 = (unsigned __int16 *)v25;
  if (!CStringPtrInternal || !v25)
  {
    v19 = kCFCompareEqualTo;
    v32 = 1;
    v18 = v331;
    if ((v318 & 1) == 0)
    {
      v9 = v22;
      if (CStringPtrInternal)
        goto LABEL_611;
      v21 = 0;
      if (v25)
        goto LABEL_621;
      CStringPtrInternal = (uint64_t)CFStringGetCharactersPtr(theString);
      CharactersPtr = CFStringGetCharactersPtr(v22);
      v26 = (unsigned __int16 *)CharactersPtr;
      v19 = kCFCompareEqualTo;
      v32 = 2;
      if (!CStringPtrInternal)
      {
        v21 = 0;
        v18 = v331;
        goto LABEL_621;
      }
      v18 = v331;
      if (!CharactersPtr)
      {
LABEL_611:
        v21 = 0;
        goto LABEL_621;
      }
      if (length >= v13)
        v34 = v13;
      else
        v34 = length;
      if (v34 < 1)
        goto LABEL_46;
      v35 = CStringPtrInternal + 2 * location;
      v36 = v35 + 2 * v34;
      v37 = v35 + 2;
      do
      {
        v38 = *v26++;
        v39 = *(unsigned __int16 *)(v37 - 2);
        v40 = v39 - v38;
        v41 = v39 != v38 || v37 >= v36;
        v37 += 2;
      }
      while (!v41);
      if (!v40)
LABEL_46:
        v40 = length - v13;
      v42 = (v40 >> 63) | 1;
      v43 = v40 == 0;
      goto LABEL_636;
    }
    v21 = 0;
LABEL_620:
    v9 = v22;
    goto LABEL_621;
  }
  v18 = v331 & 0xFFFFFFFFFFFFFFEFLL;
  if ((v331 & 0x200) == 0 && v23 == 1536)
  {
    if ((v331 & 1) != 0)
    {
      if (length >= v13)
        v27 = v13;
      else
        v27 = length;
      if (v27)
      {
        v28 = (unsigned __int8 *)(CStringPtrInternal + location);
        while (1)
        {
          v29 = __ASCII_LOWERCASE_TABLE[*v28] - __ASCII_LOWERCASE_TABLE[*(unsigned __int8 *)v26];
          if (v29)
            break;
          v26 = (unsigned __int16 *)((char *)v26 + 1);
          ++v28;
          if (!--v27)
            goto LABEL_632;
        }
      }
      else
      {
LABEL_632:
        v29 = length - v13;
      }
      v43 = v29 == 0;
      v274 = v29 < 0;
LABEL_634:
      v42 = kCFCompareLessThan;
      if (!v274)
        v42 = kCFCompareGreaterThan;
LABEL_636:
      if (v43)
        return 0;
      else
        return v42;
    }
    goto LABEL_434;
  }
  if ((v331 & 0x81) == 0)
  {
LABEL_434:
    v19 = kCFCompareEqualTo;
    v21 = 0;
    v32 = 1;
    goto LABEL_620;
  }
  if (length >= v13)
    v207 = v13;
  else
    v207 = length;
  CStringPtrInternal += location;
  v9 = v22;
  if (v207 < 1)
  {
    v19 = kCFCompareEqualTo;
    v21 = 0;
    goto LABEL_642;
  }
  v21 = 0;
  v19 = kCFCompareEqualTo;
  while (1)
  {
    v208 = *(unsigned __int8 *)(CStringPtrInternal + v21);
    v209 = *(unsigned __int8 *)(v25 + v21);
    if (v208 != v209)
      break;
LABEL_432:
    if (v207 == ++v21)
      goto LABEL_643;
  }
  if (((v209 | v208) & 0x80) == 0)
  {
    if (v208 < v209)
      v210 = -1;
    else
      v210 = 1;
    if (((v19 == kCFCompareEqualTo) & (v331 >> 9)) != 0)
      v19 = v210;
    if ((v331 & 1) != 0)
    {
      if (v208 - 65 < 0x1A)
        v208 += 32;
      if (v209 - 65 < 0x1A)
        v209 += 32;
    }
    v211 = v208 >= v209;
    if (v208 != v209)
      goto LABEL_616;
    goto LABEL_432;
  }
  CStringPtrInternal = 0;
LABEL_642:
  if (v21 == v207)
  {
LABEL_643:
    v276 = kCFCompareLessThan;
    if ((int)length - (int)v13 >= 0)
      v276 = kCFCompareGreaterThan;
    if ((_DWORD)length == (_DWORD)v13)
      return v19;
    else
      return v276;
  }
  v32 = 1;
LABEL_621:
  if (CStringPtrInternal && v26)
  {
    if (length >= v13)
      v271 = v13;
    else
      v271 = length;
    v272 = memcmp((const void *)(CStringPtrInternal + v32 * location), v26, v32 * v271);
    v273 = length - v13;
    if (v272)
      v273 = v272;
    v43 = v273 == 0;
    v274 = v273 < 0;
    goto LABEL_634;
  }
LABEL_28:
  v30 = v19;
  BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x6Eu, 0);
  *(_QWORD *)&v359 = theString;
  *((_QWORD *)&v360 + 1) = location;
  *(_QWORD *)&v361 = length;
  *((_QWORD *)&v359 + 1) = CFStringGetCharactersPtr(theString);
  if (*((_QWORD *)&v359 + 1))
    v31 = 0;
  else
    v31 = _CFStringGetCStringPtrInternal((uint64_t)theString, 0x600u, 0, 1);
  *(_QWORD *)&v360 = v31;
  *((_QWORD *)&v361 + 1) = 0;
  v362 = 0;
  *(_QWORD *)&v347 = v9;
  *((_QWORD *)&v348 + 1) = 0;
  *(_QWORD *)&v349 = v13;
  v44 = CFStringGetCharactersPtr(v9);
  v45 = 0;
  *((_QWORD *)&v347 + 1) = v44;
  if (!v44)
    v45 = _CFStringGetCStringPtrInternal((uint64_t)v9, 0x600u, 0, 1);
  *(_QWORD *)&v348 = v45;
  *((_QWORD *)&v349 + 1) = 0;
  v350 = 0;
  if (locale)
  {
    v46 = v331;
    LODWORD(v319) = ((v331 & 0x200) == 0) & (v331 >> 7);
    if ((v331 & 0x200) != 0)
      v18 &= ~0x80uLL;
    v47 = v21;
  }
  else
  {
    v47 = 0;
    v46 = v331;
    v319 = (v331 >> 7) & 1;
  }
  v48 = v30;
  v49 = v328;
  v50 = v318;
  v51 = 0;
  v302 = v18;
  if (v21 >= length || v21 >= v13)
  {
    LOBYTE(v303) = 0;
    v54 = v21;
    v66 = 0;
LABEL_411:
    v58 = v21;
    v59 = v54;
    if ((v49 | v319) == 1)
      goto LABEL_439;
    goto LABEL_595;
  }
  v283 = (__CFString *)v9;
  v301 = v13;
  v327 = length;
  v52 = 0;
  v53 = 0;
  *(_QWORD *)v315 = 0;
  cf = locale;
  v51 = 0;
  v303 = 0;
  v289 = 0;
  v288 = 0;
  v54 = v21;
  v55 = v47;
  while (2)
  {
    v56 = 0;
    v57 = 0;
LABEL_60:
    v58 = v21;
    v59 = v54;
    v60 = v56;
    v298 = v57;
    v61 = v57;
    v307 = v55;
    v308 = v47;
    v310 = v54;
    v304 = v56;
LABEL_61:
    v62 = v59 - 4;
    if ((unint64_t)v59 < 4)
      v62 = 0;
    v297 = v62;
    v296 = v62 + 64;
    v63 = v59 + 1;
    v64 = v59 - 3;
    if ((unint64_t)(v59 + 1) < 4)
      v64 = 0;
    v300 = v64;
    v299 = v64 + 64;
    if (v61 <= 0)
      v65 = 0;
    else
      v65 = -1;
    v320 = v65;
    v66 = *(_QWORD *)v315;
    v329 = v61;
LABEL_69:
    if (!v60)
    {
      if (v58 < 0 || (v69 = v361, (uint64_t)v361 <= v58))
      {
        v67 = 0;
LABEL_78:
        v338 = 1;
        if (!v61)
          goto LABEL_79;
LABEL_71:
        LODWORD(v68) = v363[v53++];
        break;
      }
      v70 = (UniChar *)*((_QWORD *)&v359 + 1);
      if (*((_QWORD *)&v359 + 1))
      {
        v71 = *((_QWORD *)&v360 + 1) + v58;
      }
      else
      {
        if ((_QWORD)v360)
        {
          v72 = *(char *)(v360 + *((_QWORD *)&v360 + 1) + v58);
          goto LABEL_115;
        }
        if (v362 <= v58 || (v113 = *((_QWORD *)&v361 + 1), *((uint64_t *)&v361 + 1) > v58))
        {
          v114 = v58 - 4;
          if ((unint64_t)v58 < 4)
            v114 = 0;
          if (v114 + 64 < (uint64_t)v361)
            v69 = v114 + 64;
          *((_QWORD *)&v361 + 1) = v114;
          v362 = v69;
          v367.location = *((_QWORD *)&v360 + 1) + v114;
          v367.length = v69 - v114;
          v291 = v52;
          v115 = v63;
          v116 = v48;
          v117 = v51;
          CFStringGetCharacters((CFStringRef)v359, v367, v351);
          v60 = 0;
          v46 = v331;
          v61 = v329;
          v54 = v310;
          v52 = v291;
          v55 = v307;
          v47 = v308;
          v50 = v318;
          v51 = v117;
          v49 = v328;
          v48 = v116;
          v63 = v115;
          v113 = *((_QWORD *)&v361 + 1);
        }
        v71 = v58 - v113;
        v70 = v351;
      }
      v72 = v70[v71];
LABEL_115:
      v67 = v72;
      if ((v46 & 1) != 0 && v72 >= 0x41u && v72 <= 0x5Au)
      {
        if (__s1 && v72 == 73)
        {
          v67 = 73;
        }
        else
        {
          if (v48)
            v109 = 1;
          else
            v109 = (v46 & 0x200) == 0;
          if (v109)
            v67 = v72 + 32;
        }
      }
      goto LABEL_78;
    }
    v67 = v364[v52++];
    if (v61)
      goto LABEL_71;
LABEL_79:
    if (v59 < 0 || (v73 = v349, (uint64_t)v349 <= v59))
    {
      v68 = 0;
    }
    else
    {
      v74 = (UniChar *)*((_QWORD *)&v347 + 1);
      if (*((_QWORD *)&v347 + 1))
      {
        v75 = *((_QWORD *)&v348 + 1) + v59;
        goto LABEL_83;
      }
      if ((_QWORD)v348)
      {
        v76 = *(char *)(v348 + *((_QWORD *)&v348 + 1) + v59);
      }
      else
      {
        if (v350 <= v59 || (v118 = *((_QWORD *)&v349 + 1), *((uint64_t *)&v349 + 1) > v59))
        {
          if (v296 < (uint64_t)v349)
            v73 = v296;
          *((_QWORD *)&v349 + 1) = v297;
          v350 = v73;
          v333 = v53;
          v119 = v60;
          v368.location = *((_QWORD *)&v348 + 1) + v297;
          v368.length = v73 - v297;
          v292 = v52;
          *(_QWORD *)theCharb = v63;
          v120 = v48;
          v121 = v51;
          CFStringGetCharacters((CFStringRef)v347, v368, buffer);
          v60 = v119;
          v46 = v331;
          v53 = v333;
          v61 = v329;
          v54 = v310;
          v52 = v292;
          v55 = v307;
          v47 = v308;
          v50 = v318;
          v51 = v121;
          v49 = v328;
          v48 = v120;
          v63 = *(_QWORD *)theCharb;
          v118 = *((_QWORD *)&v349 + 1);
        }
        v75 = v59 - v118;
        v74 = buffer;
LABEL_83:
        v76 = v74[v75];
      }
      v68 = v76;
      if ((v46 & 1) != 0 && v76 >= 0x41u && v76 <= 0x5Au)
      {
        if (__s1 && v76 == 73)
        {
          v68 = 73;
        }
        else
        {
          if (v48)
            v110 = 1;
          else
            v110 = (v46 & 0x200) == 0;
          if (v110)
            v68 = v76 + 32;
          else
            v68 = v76;
        }
      }
    }
    v337 = 1;
    if (!v61
      && (v46 & 0x40) != 0
      && !v60
      && v67 <= 0x39
      && v67 >= 0x30
      && v68 <= 0x39
      && v68 >= 0x30)
    {
      *(_QWORD *)v315 = v66;
      v183 = 0;
      v184 = 0;
      v295 = v52;
      do
      {
        v185 = v183;
        v186 = v58 + v183;
        v184 = v67 - 48 + 10 * v184;
        v21 = v186 + 1;
        if (v186 < -1)
          break;
        v187 = v361;
        if ((uint64_t)v361 <= v21)
          break;
        if (*((_QWORD *)&v359 + 1))
        {
          v188 = *(_WORD *)(*((_QWORD *)&v359 + 1) + 2 * (v58 + v185 + *((_QWORD *)&v360 + 1)) + 2);
        }
        else if ((_QWORD)v360)
        {
          v188 = *(char *)(v360 + *((_QWORD *)&v360 + 1) + v58 + v185 + 1);
        }
        else
        {
          if (v362 <= v21 || (v189 = *((_QWORD *)&v361 + 1), *((uint64_t *)&v361 + 1) > v21))
          {
            v190 = v58 + v185 - 3;
            if ((unint64_t)v21 < 4)
              v190 = 0;
            if (v190 + 64 < (uint64_t)v361)
              v187 = v190 + 64;
            *((_QWORD *)&v361 + 1) = v190;
            v362 = v187;
            v370.location = *((_QWORD *)&v360 + 1) + v190;
            v370.length = v187 - v190;
            v191 = v48;
            v192 = v51;
            *(_QWORD *)theChard = v68;
            CFStringGetCharacters((CFStringRef)v359, v370, v351);
            v68 = *(_QWORD *)theChard;
            v52 = v295;
            v55 = v307;
            v47 = v308;
            v50 = v318;
            v46 = v331;
            v51 = v192;
            v49 = v328;
            v48 = v191;
            v189 = *((_QWORD *)&v361 + 1);
          }
          v188 = v351[v58 + 1 - v189 + v185];
        }
        v67 = v188;
        v193 = (unsigned __int16)(v188 - 48);
        v183 = v185 + 1;
      }
      while (v193 < 0xA);
      v194 = 0;
      v195 = 0;
      v196 = &buffer[v59 + 1];
      do
      {
        v197 = v194;
        v195 = (v68 - 48) + 10 * v195;
        v54 = v59 + v194 + 1;
        if (v59 < -1)
          break;
        v198 = v349;
        if ((uint64_t)v349 <= v54)
          break;
        if (*((_QWORD *)&v347 + 1))
        {
          v199 = *(_WORD *)(*((_QWORD *)&v347 + 1) + 2 * (v59 + v197 + *((_QWORD *)&v348 + 1)) + 2);
        }
        else if ((_QWORD)v348)
        {
          v199 = *(char *)(v348 + *((_QWORD *)&v348 + 1) + v59 + v197 + 1);
        }
        else
        {
          if (v350 <= v54 || (v200 = *((_QWORD *)&v349 + 1), *((uint64_t *)&v349 + 1) > v54))
          {
            v201 = v59 + v197 - 3;
            if ((unint64_t)v54 < 4)
              v201 = 0;
            if (v201 + 64 < (uint64_t)v349)
              v198 = v201 + 64;
            *((_QWORD *)&v349 + 1) = v201;
            v350 = v198;
            v371.location = *((_QWORD *)&v348 + 1) + v201;
            v371.length = v198 - v201;
            v202 = v48;
            v287 = v51;
            v313 = v54;
            v330 = v196;
            CFStringGetCharacters((CFStringRef)v347, v371, buffer);
            v196 = v330;
            v46 = v331;
            v54 = v313;
            v52 = v295;
            v55 = v307;
            v47 = v308;
            v50 = v318;
            v51 = v287;
            v49 = v328;
            v48 = v202;
            v200 = *((_QWORD *)&v349 + 1);
          }
          v199 = v196[v197 - v200];
        }
        LODWORD(v68) = v199;
        v203 = (unsigned __int16)(v199 - 48);
        v194 = v197 + 1;
      }
      while (v203 < 0xA);
      if (v184 != v195)
      {
        v281 = v306;
        if (!cf)
          v281 = 0;
        if (v184 >= v195)
        {
          if (v281)
            CFRelease(cf);
          return 1;
        }
        else
        {
          if (v281)
            CFRelease(cf);
          return -1;
        }
      }
      if ((v46 & 0x200) != 0)
      {
        locale = cf;
        if (!v48)
        {
          if (v185 + 1 < v197 + 1)
            v204 = -1;
          else
            v204 = 1;
          v205 = v303;
          if (v185 != v197)
            v205 = 1;
          v303 = v205;
          if (v185 == v197)
            v48 = 0;
          else
            v48 = v204;
          if (v185 != v197)
            v51 = v59;
          v206 = *(_QWORD *)v315;
          if (v185 != v197)
            v206 = v58;
          *(_QWORD *)v315 = v206;
        }
      }
      else
      {
        locale = cf;
      }
      if (v21 >= v327 || v54 >= v301)
      {
        v21 = v58 + v185 + 1;
        v54 = v59 + v197 + 1;
        length = v327;
        goto LABEL_409;
      }
      continue;
    }
    break;
  }
  if (v67 == (_DWORD)v68)
  {
    *(_QWORD *)v315 = v66;
    v57 = v61;
    v56 = v60;
    v54 = v59;
    v21 = v58;
    locale = cf;
    length = v327;
LABEL_329:
    if (v52 == v56 && v56 > 0)
      v56 = 0;
    if (v53 == v57 && v57 > 0)
      v57 = 0;
    v173 = v338;
    if (v56)
      v173 = 0;
    v21 += v173;
    v174 = v337;
    if (v57)
      v174 = 0;
    v54 += v174;
    if (!(v56 | v57))
    {
      v55 = v54;
      v47 = v21;
    }
    if (v21 >= length || v54 >= v301)
    {
LABEL_409:
      v13 = v301;
      v66 = *(_QWORD *)v315;
      goto LABEL_411;
    }
    goto LABEL_60;
  }
  if ((v50 & 1) == 0)
  {
    if (!cf)
    {
      v211 = v67 >= v68;
      goto LABEL_616;
    }
    v77 = _CFCompareStringsWithLocale(v351, v21, v327 - v21, buffer, v54, v301 - v54, v302, cf);
    if (!v306)
      return v77;
    v212 = cf;
    goto LABEL_614;
  }
  if (v67 < v68)
    v77 = kCFCompareLessThan;
  else
    v77 = kCFCompareGreaterThan;
  if (((v48 == 0) & (v46 >> 9)) != 0)
  {
    v48 = v77;
    v51 = v55;
    v66 = v47;
  }
  v78 = v67 >= 0x80 || v68 >= 0x80;
  v79 = v328 ^ 1;
  if (v78)
    v79 = 0;
  if (v79 == 1)
  {
    if (cf)
    {
      v77 = _CFCompareStringsWithLocale(v351, v58, v327 - v58, buffer, v59, v301 - v59, v302, cf);
      if (!v306)
        return v77;
      v212 = cf;
      goto LABEL_614;
    }
    if ((v46 & 1) == 0)
      return v77;
  }
  v332 = v53;
  if ((v67 & 0xFC00) == 0xD800 && v58 >= -1)
  {
    v80 = v58 + 1;
    v81 = v361;
    if ((uint64_t)v361 > v58 + 1)
    {
      v82 = (UniChar *)*((_QWORD *)&v359 + 1);
      if (*((_QWORD *)&v359 + 1))
      {
        v83 = *((_QWORD *)&v360 + 1) + v80;
        goto LABEL_112;
      }
      if ((_QWORD)v360)
      {
        v84 = *(char *)(v360 + *((_QWORD *)&v360 + 1) + v80);
      }
      else
      {
        if (v362 <= v80 || (v122 = *((_QWORD *)&v361 + 1), *((uint64_t *)&v361 + 1) > v80))
        {
          v123 = v58 - 3;
          if ((unint64_t)v80 < 4)
            v123 = 0;
          if (v123 + 64 < (uint64_t)v361)
            v81 = v123 + 64;
          *((_QWORD *)&v361 + 1) = v123;
          v362 = v81;
          *(_QWORD *)theCharc = v60;
          v369.location = *((_QWORD *)&v360 + 1) + v123;
          v369.length = v81 - v123;
          v293 = v52;
          v282 = v48;
          v285 = v51;
          v124 = v68;
          CFStringGetCharacters((CFStringRef)v359, v369, v351);
          LODWORD(v68) = v124;
          v60 = *(_QWORD *)theCharc;
          v46 = v331;
          v53 = v332;
          v61 = v329;
          v54 = v310;
          v52 = v293;
          v55 = v307;
          v47 = v308;
          v50 = v318;
          v51 = v285;
          v49 = v328;
          v48 = v282;
          v122 = *((_QWORD *)&v361 + 1);
        }
        v83 = v80 - v122;
        v82 = v351;
LABEL_112:
        v84 = v82[v83];
      }
      if (v84 >> 10 == 55)
      {
        v67 = ((unsigned __int16)v67 << 10) - 56613888 + v84;
        v338 = 2;
      }
    }
  }
  if ((v68 & 0xFC00) == 0xD800 && v59 >= -1)
  {
    v85 = v349;
    if ((uint64_t)v349 > v63)
    {
      v86 = (UniChar *)*((_QWORD *)&v347 + 1);
      if (*((_QWORD *)&v347 + 1))
      {
        v87 = *((_QWORD *)&v348 + 1) + v63;
        goto LABEL_138;
      }
      if ((_QWORD)v348)
      {
        v88 = *(char *)(v348 + *((_QWORD *)&v348 + 1) + v63);
      }
      else
      {
        if (v350 <= v63 || (v106 = *((_QWORD *)&v349 + 1), *((uint64_t *)&v349 + 1) > v63))
        {
          if (v299 < (uint64_t)v349)
            v85 = v299;
          *((_QWORD *)&v349 + 1) = v300;
          v350 = v85;
          *(_QWORD *)theChara = v60;
          v366.location = *((_QWORD *)&v348 + 1) + v300;
          v366.length = v85 - v300;
          v290 = v52;
          v107 = v48;
          v284 = v51;
          v108 = v68;
          CFStringGetCharacters((CFStringRef)v347, v366, buffer);
          LODWORD(v68) = v108;
          v60 = *(_QWORD *)theChara;
          v46 = v331;
          v53 = v332;
          v61 = v329;
          v54 = v310;
          v52 = v290;
          v55 = v307;
          v47 = v308;
          v50 = v318;
          v51 = v284;
          v49 = v328;
          v48 = v107;
          v106 = *((_QWORD *)&v349 + 1);
        }
        v87 = v63 - v106;
        v86 = buffer;
LABEL_138:
        v88 = v86[v87];
      }
      if (v88 >> 10 == 55)
      {
        LODWORD(v68) = ((unsigned __int16)v68 << 10) - 56613888 + v88;
        v337 = 2;
      }
    }
  }
  theChar = v68;
  if (!v49)
    goto LABEL_263;
  v89 = v60;
  v90 = (char)theSet[1];
  v91 = HIDWORD(theSet[1]);
  v92 = (uint64_t)theSet[1] & 4;
  if (HIDWORD(theSet[1]) > v67 || v336 <= v67)
  {
    if (((uint64_t)theSet[1] & 4) == 0)
      goto LABEL_220;
    goto LABEL_188;
  }
  if (!HIWORD(v67) && ((uint64_t)theSet[1] & 2) == 0)
  {
    if (*((_QWORD *)&v336 + 1))
    {
      if (((uint64_t)theSet[1] & 1) != 0)
      {
        v125 = v92 >> 2;
        v104 = *(unsigned __int8 *)(*((_QWORD *)&v336 + 1) + ((unint64_t)v67 >> 8));
        if (*(_BYTE *)(*((_QWORD *)&v336 + 1) + ((unint64_t)v67 >> 8)))
        {
          if ((_DWORD)v104 == 255)
          {
            v105 = v92 == 0;
          }
          else if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v336 + 1)
                                                           + 32 * v104
                                                           + (v67 >> 3)
                                                           + 224) >> (v67 & 7)) & 1) != 0)
          {
            v105 = v92 == 0;
          }
          else
          {
            v105 = v92 >> 2;
          }
        }
        else
        {
          v105 = v92 >> 2;
        }
        v54 = v310;
        if (!v105)
          goto LABEL_221;
      }
      else
      {
        v93 = v92 != 0;
        if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v336 + 1) + ((unint64_t)v67 >> 3)) >> (v67 & 7)) & 1) != 0)
          v93 = v92 == 0;
        v54 = v310;
        if (!v93)
          goto LABEL_220;
      }
    }
    else
    {
      v103 = v92 != 0;
      if (((uint64_t)theSet[1] & 1) == 0)
        v103 = v92 == 0;
      if (!v103)
      {
LABEL_220:
        v125 = v92 >> 2;
        goto LABEL_221;
      }
    }
LABEL_188:
    if (v52 != v89 || v89 <= 0)
      v60 = v89;
    else
      v60 = 0;
    v112 = v338;
    if (v60)
      v112 = 0;
    v58 += v112;
    v53 = v332 + v320;
    length = v327;
    v61 = v329;
    if (v58 >= v327)
    {
      locale = cf;
      goto LABEL_438;
    }
    goto LABEL_69;
  }
  v94 = v48;
  v95 = v66;
  v96 = v51;
  v97 = v63;
  v98 = v58;
  v99 = v59;
  v100 = v21;
  v101 = v52;
  IsLongCharacterMember = CFCharacterSetIsLongCharacterMember(theSet[0], v67);
  v54 = v310;
  v52 = v101;
  v21 = v100;
  v59 = v99;
  v58 = v98;
  v63 = v97;
  v55 = v307;
  v47 = v308;
  v50 = v318;
  v46 = v331;
  v51 = v96;
  v66 = v95;
  v49 = v328;
  v48 = v94;
  if (IsLongCharacterMember)
    goto LABEL_188;
  v90 = (char)theSet[1];
  v91 = HIDWORD(theSet[1]);
  v92 = (uint64_t)theSet[1] & 4;
  v125 = (LODWORD(theSet[1]) >> 2) & 1;
LABEL_221:
  v61 = v329;
  *(_QWORD *)v315 = v66;
  if (v91 > theChar || v336 <= theChar)
  {
    if (!v92)
      goto LABEL_262;
    goto LABEL_251;
  }
  if (HIWORD(theChar) || (v90 & 2) != 0)
  {
    v128 = v48;
    v129 = v51;
    v321 = v21;
    v130 = v52;
    v131 = CFCharacterSetIsLongCharacterMember(theSet[0], theChar);
    v61 = v329;
    v46 = v331;
    v54 = v310;
    v52 = v130;
    v21 = v321;
    v55 = v307;
    v47 = v308;
    v50 = v318;
    v51 = v129;
    v49 = v328;
    v48 = v128;
    if (!v131)
      goto LABEL_262;
    goto LABEL_251;
  }
  if (*((_QWORD *)&v336 + 1))
  {
    if ((v90 & 1) != 0)
    {
      v134 = *(unsigned __int8 *)(*((_QWORD *)&v336 + 1) + ((unint64_t)theChar >> 8));
      if (*(_BYTE *)(*((_QWORD *)&v336 + 1) + ((unint64_t)theChar >> 8)))
      {
        if ((_DWORD)v134 == 255)
        {
          v125 = v92 == 0;
        }
        else
        {
          v135 = v92 == 0;
          if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v336 + 1)
                                                      + 32 * v134
                                                      + (theChar >> 3)
                                                      + 224) >> (theChar & 7)) & 1) != 0)
            v125 = v135;
        }
      }
      if (!v125)
        goto LABEL_262;
    }
    else
    {
      v43 = v92 == 0;
      v126 = v92 != 0;
      v127 = v43;
      if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v336 + 1) + ((unint64_t)theChar >> 3)) >> (theChar & 7)) & 1) != 0)
        v126 = v127;
      if (!v126)
        goto LABEL_262;
    }
LABEL_251:
    if (v332 == v61 && v61 > 0)
      v61 = 0;
    v137 = v337;
    if (v61)
      v137 = 0;
    v59 += v137;
    length = v327;
    if (v327 <= v58 || (v60 = v89, v52 -= v89 > 0, v53 = v332, v59 >= v301))
    {
      v66 = *(_QWORD *)v315;
      locale = cf;
LABEL_438:
      v13 = v301;
LABEL_439:
      v213 = v48;
      v214 = v51;
      *(_QWORD *)v316 = v66;
      if (v58 < length)
      {
        while (2)
        {
          if (v58 < 0 || (v215 = v361, (uint64_t)v361 <= v58))
          {
            v218 = 0;
          }
          else
          {
            v216 = (UniChar *)*((_QWORD *)&v359 + 1);
            if (*((_QWORD *)&v359 + 1))
            {
              v217 = *((_QWORD *)&v360 + 1) + v58;
              goto LABEL_444;
            }
            if ((_QWORD)v360)
            {
              v218 = *(char *)(v360 + *((_QWORD *)&v360 + 1) + v58);
            }
            else
            {
              if (v362 <= v58 || (v235 = *((_QWORD *)&v361 + 1), *((uint64_t *)&v361 + 1) > v58))
              {
                v236 = v58 - 4;
                if ((unint64_t)v58 < 4)
                  v236 = 0;
                if (v236 + 64 < (uint64_t)v361)
                  v215 = v236 + 64;
                *((_QWORD *)&v361 + 1) = v236;
                v362 = v215;
                v372.location = *((_QWORD *)&v360 + 1) + v236;
                v372.length = v215 - v236;
                CFStringGetCharacters((CFStringRef)v359, v372, v351);
                v51 = v214;
                v49 = v328;
                v48 = v213;
                v235 = *((_QWORD *)&v361 + 1);
              }
              v217 = v58 - v235;
              v216 = v351;
LABEL_444:
              v218 = v216[v217];
            }
          }
          v219 = v218;
          if (((v218 < 0x80u) & ~v49) != 0)
            break;
          if (v218 >> 10 == 54 && v58 >= -1)
          {
            v220 = v13;
            v221 = v58 + 1;
            v222 = v361;
            if ((uint64_t)v361 <= v58 + 1)
            {
              v13 = v220;
              v66 = *(_QWORD *)v316;
            }
            else
            {
              v223 = (UniChar *)*((_QWORD *)&v359 + 1);
              if (*((_QWORD *)&v359 + 1))
              {
                v224 = *((_QWORD *)&v360 + 1) + v221;
                goto LABEL_452;
              }
              if ((_QWORD)v360)
              {
                v225 = *(char *)(v360 + *((_QWORD *)&v360 + 1) + v221);
              }
              else
              {
                if (v362 <= v221 || (v239 = *((_QWORD *)&v361 + 1), *((uint64_t *)&v361 + 1) > v221))
                {
                  v240 = v58 - 3;
                  if ((unint64_t)v221 < 4)
                    v240 = 0;
                  if (v240 + 64 < (uint64_t)v361)
                    v222 = v240 + 64;
                  *((_QWORD *)&v361 + 1) = v240;
                  v362 = v222;
                  v373.location = *((_QWORD *)&v360 + 1) + v240;
                  v373.length = v222 - v240;
                  CFStringGetCharacters((CFStringRef)v359, v373, v351);
                  v51 = v214;
                  v49 = v328;
                  v48 = v213;
                  v239 = *((_QWORD *)&v361 + 1);
                }
                v224 = v221 - v239;
                v223 = v351;
LABEL_452:
                v225 = v223[v224];
              }
              v13 = v220;
              v66 = *(_QWORD *)v316;
              if (v225 >> 10 == 55)
                v219 = (v219 << 10) + v225 - 56613888;
            }
          }
          if (!(_DWORD)v319)
            goto LABEL_465;
          v226 = BitmapPtrForPlane;
          if (v219 >= 0x10000)
          {
            v226 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v219));
            v51 = v214;
            v49 = v328;
            v48 = v213;
          }
          if (!v226 || ((*(unsigned __int8 *)(v226 + ((unsigned __int16)v219 >> 3)) >> (v219 & 7)) & 1) == 0)
          {
LABEL_465:
            if (!v49)
              break;
            v227 = (uint64_t)theSet[1] & 4;
            if (HIDWORD(theSet[1]) > v219 || v336 <= v219)
            {
              if (((uint64_t)theSet[1] & 4) == 0)
                break;
            }
            else if (HIWORD(v219) || ((uint64_t)theSet[1] & 2) != 0)
            {
              v230 = CFCharacterSetIsLongCharacterMember(theSet[0], v219);
              v51 = v214;
              v49 = v328;
              v48 = v213;
              if (!v230)
                break;
            }
            else if (*((_QWORD *)&v336 + 1))
            {
              if (((uint64_t)theSet[1] & 1) != 0)
              {
                v233 = v227 >> 2;
                v234 = *(unsigned __int8 *)(*((_QWORD *)&v336 + 1) + ((unint64_t)v219 >> 8));
                if (*(_BYTE *)(*((_QWORD *)&v336 + 1) + ((unint64_t)v219 >> 8)))
                {
                  if ((_DWORD)v234 == 255)
                  {
                    v233 = v227 == 0;
                  }
                  else
                  {
                    v237 = v227 == 0;
                    if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v336 + 1)
                                                                + 32 * v234
                                                                + (v219 >> 3)
                                                                + 224) >> (v219 & 7)) & 1) != 0)
                      v233 = v237;
                  }
                }
                if (!v233)
                  break;
              }
              else
              {
                v43 = v227 == 0;
                v228 = v227 != 0;
                v229 = v43;
                if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v336 + 1) + ((unint64_t)v219 >> 3)) >> (v219 & 7)) & 1) != 0)
                  v228 = v229;
                if (!v228)
                  break;
              }
            }
            else
            {
              v43 = v227 == 0;
              v231 = v227 != 0;
              v232 = v43;
              if (((uint64_t)theSet[1] & 1) == 0)
                v231 = v232;
              if (!v231)
                break;
            }
          }
          if (v219 < 0x10000)
            v238 = 1;
          else
            v238 = 2;
          v58 += v238;
          if (v58 >= length)
            break;
          continue;
        }
      }
      if (v59 < v13)
      {
        while (2)
        {
          if (v59 < 0 || (v241 = v349, (uint64_t)v349 <= v59))
          {
            v244 = 0;
          }
          else
          {
            v242 = (UniChar *)*((_QWORD *)&v347 + 1);
            if (*((_QWORD *)&v347 + 1))
            {
              v243 = *((_QWORD *)&v348 + 1) + v59;
              goto LABEL_522;
            }
            if ((_QWORD)v348)
            {
              v244 = *(char *)(v348 + *((_QWORD *)&v348 + 1) + v59);
            }
            else
            {
              if (v350 <= v59 || (v261 = *((_QWORD *)&v349 + 1), *((uint64_t *)&v349 + 1) > v59))
              {
                v262 = v59 - 4;
                if ((unint64_t)v59 < 4)
                  v262 = 0;
                if (v262 + 64 < (uint64_t)v349)
                  v241 = v262 + 64;
                *((_QWORD *)&v349 + 1) = v262;
                v350 = v241;
                v374.location = *((_QWORD *)&v348 + 1) + v262;
                v374.length = v241 - v262;
                CFStringGetCharacters((CFStringRef)v347, v374, buffer);
                v51 = v214;
                v49 = v328;
                v48 = v213;
                v261 = *((_QWORD *)&v349 + 1);
              }
              v243 = v59 - v261;
              v242 = buffer;
LABEL_522:
              v244 = v242[v243];
            }
          }
          v245 = v244;
          if (((v244 < 0x80u) & ~v49) != 0)
            break;
          if (v244 >> 10 == 54 && v59 >= -1)
          {
            v246 = v13;
            v247 = v59 + 1;
            v248 = v349;
            if ((uint64_t)v349 <= v59 + 1)
            {
              v13 = v246;
              v66 = *(_QWORD *)v316;
            }
            else
            {
              v249 = (UniChar *)*((_QWORD *)&v347 + 1);
              if (*((_QWORD *)&v347 + 1))
              {
                v250 = *((_QWORD *)&v348 + 1) + v247;
                goto LABEL_530;
              }
              if ((_QWORD)v348)
              {
                v251 = *(char *)(v348 + *((_QWORD *)&v348 + 1) + v247);
              }
              else
              {
                if (v350 <= v247 || (v265 = *((_QWORD *)&v349 + 1), *((uint64_t *)&v349 + 1) > v247))
                {
                  v266 = v59 - 3;
                  if ((unint64_t)v247 < 4)
                    v266 = 0;
                  if (v266 + 64 < (uint64_t)v349)
                    v248 = v266 + 64;
                  *((_QWORD *)&v349 + 1) = v266;
                  v350 = v248;
                  v375.location = *((_QWORD *)&v348 + 1) + v266;
                  v375.length = v248 - v266;
                  CFStringGetCharacters((CFStringRef)v347, v375, buffer);
                  v51 = v214;
                  v49 = v328;
                  v48 = v213;
                  v265 = *((_QWORD *)&v349 + 1);
                }
                v250 = v247 - v265;
                v249 = buffer;
LABEL_530:
                v251 = v249[v250];
              }
              v13 = v246;
              v66 = *(_QWORD *)v316;
              if (v251 >> 10 == 55)
                v245 = (v245 << 10) + v251 - 56613888;
            }
          }
          if (!(_DWORD)v319)
            goto LABEL_543;
          v252 = BitmapPtrForPlane;
          if (v245 >= 0x10000)
          {
            v252 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v245));
            v51 = v214;
            v49 = v328;
            v48 = v213;
          }
          if (!v252 || ((*(unsigned __int8 *)(v252 + ((unsigned __int16)v245 >> 3)) >> (v245 & 7)) & 1) == 0)
          {
LABEL_543:
            if (!v49)
              break;
            v253 = (uint64_t)theSet[1] & 4;
            if (HIDWORD(theSet[1]) > v245 || v336 <= v245)
            {
              if (((uint64_t)theSet[1] & 4) == 0)
                break;
            }
            else if (HIWORD(v245) || ((uint64_t)theSet[1] & 2) != 0)
            {
              v256 = CFCharacterSetIsLongCharacterMember(theSet[0], v245);
              v51 = v214;
              v49 = v328;
              v48 = v213;
              if (!v256)
                break;
            }
            else if (*((_QWORD *)&v336 + 1))
            {
              if (((uint64_t)theSet[1] & 1) != 0)
              {
                v259 = v253 >> 2;
                v260 = *(unsigned __int8 *)(*((_QWORD *)&v336 + 1) + ((unint64_t)v245 >> 8));
                if (*(_BYTE *)(*((_QWORD *)&v336 + 1) + ((unint64_t)v245 >> 8)))
                {
                  if ((_DWORD)v260 == 255)
                  {
                    v259 = v253 == 0;
                  }
                  else
                  {
                    v263 = v253 == 0;
                    if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v336 + 1)
                                                                + 32 * v260
                                                                + (v245 >> 3)
                                                                + 224) >> (v245 & 7)) & 1) != 0)
                      v259 = v263;
                  }
                }
                if (!v259)
                  break;
              }
              else
              {
                v43 = v253 == 0;
                v254 = v253 != 0;
                v255 = v43;
                if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v336 + 1) + ((unint64_t)v245 >> 3)) >> (v245 & 7)) & 1) != 0)
                  v254 = v255;
                if (!v254)
                  break;
              }
            }
            else
            {
              v43 = v253 == 0;
              v257 = v253 != 0;
              v258 = v43;
              if (((uint64_t)theSet[1] & 1) == 0)
                v257 = v258;
              if (!v257)
                break;
            }
          }
          if (v245 < 0x10000)
            v264 = 1;
          else
            v264 = 2;
          v59 += v264;
          if (v59 >= v13)
            break;
          continue;
        }
      }
LABEL_595:
      if (locale)
      {
        v267 = v306;
        if ((v303 & 1) == 0 && v48 && v58 == length && v59 == v13)
          v48 = _CFCompareStringsWithLocale(v351, v66, length - v66, buffer, v51, v13 - v51, v302, locale);
      }
      else
      {
        v267 = v306;
      }
      v268 = v267 ^ 1;
      if (!locale)
        v268 = 1;
      if ((v268 & 1) == 0)
      {
        v269 = v48;
        CFRelease(locale);
        v48 = v269;
      }
      if (v59 < v13)
        v270 = kCFCompareLessThan;
      else
        v270 = v48;
      if (v58 < length)
        return 1;
      else
        return v270;
    }
    goto LABEL_61;
  }
  v43 = v92 == 0;
  v132 = v92 != 0;
  v133 = v43;
  if ((v90 & 1) == 0)
    v132 = v133;
  if (v132)
    goto LABEL_251;
LABEL_262:
  v54 = v59;
  v298 = v61;
  v21 = v58;
  v60 = v89;
  v304 = v89;
  v66 = *(_QWORD *)v315;
  v53 = v332;
LABEL_263:
  v138 = v319 ^ 1;
  if (v21 < 1)
    v138 = 1;
  v139 = v302;
  if ((v138 & 1) != 0)
  {
    v142 = v289;
    v57 = v298;
    goto LABEL_293;
  }
  v57 = v298;
  v140 = v60;
  if (v60)
    goto LABEL_267;
  v143 = BitmapPtrForPlane;
  if (v67 >= 0x10000)
  {
    v144 = v48;
    v145 = v66;
    v146 = v51;
    v147 = v21;
    v148 = v52;
    v149 = v54;
    v143 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v67));
    v61 = v329;
    v46 = v331;
    v54 = v149;
    v52 = v148;
    v21 = v147;
    v57 = v298;
    v55 = v307;
    v47 = v308;
    v50 = v318;
    v51 = v146;
    v66 = v145;
    v49 = v328;
    v48 = v144;
  }
  if (!v143)
  {
LABEL_267:
    v141 = 0;
    if (!v61)
      goto LABEL_276;
LABEL_288:
    if (v141)
      v54 -= v337;
LABEL_291:
    v142 = v289;
    v60 = v140;
    goto LABEL_292;
  }
  v150 = (1 << (v67 & 7)) & *(unsigned __int8 *)(v143 + ((unsigned __int16)v67 >> 3));
  v141 = v150 != 0;
  if (v150)
    v67 = theChar;
  if (v61)
    goto LABEL_288;
LABEL_276:
  v151 = BitmapPtrForPlane;
  if (theChar >= 0x10000)
  {
    v152 = v48;
    v153 = v66;
    v154 = v51;
    v155 = v21;
    v156 = v52;
    v311 = v54;
    v151 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(theChar));
    v61 = v329;
    v46 = v331;
    v54 = v311;
    v52 = v156;
    v21 = v155;
    v57 = v298;
    v55 = v307;
    v47 = v308;
    v50 = v318;
    v51 = v154;
    v66 = v153;
    v49 = v328;
    v48 = v152;
  }
  if (!v151)
    goto LABEL_288;
  v157 = (1 << (theChar & 7)) & *(unsigned __int8 *)(v151 + ((unsigned __int16)theChar >> 3));
  if (v157)
    v158 = v67;
  else
    v158 = theChar;
  if (((v141 ^ (v157 != 0)) & 1) == 0)
  {
    theChar = v158;
    goto LABEL_291;
  }
  v159 = v337;
  if (!v141)
    v159 = 0;
  v54 -= v159;
  v60 = v140;
  if (v157)
  {
    v21 -= v338;
    theChar = v67;
  }
  v142 = v289;
LABEL_292:
  v53 = v332;
LABEL_293:
  *(_QWORD *)v315 = v66;
  if (v67 == theChar)
  {
    locale = cf;
    length = v327;
    goto LABEL_313;
  }
  if (v60)
  {
    v160 = 0;
    locale = cf;
    goto LABEL_311;
  }
  if (!v288 || v288 == v21)
  {
    v312 = v54;
    v286 = v51;
    v162 = v48;
    v334 = 0;
    v163 = v21;
    v164 = v21;
    v165 = v52;
    v166 = __CFStringFoldCharacterClusterAtIndex(v67, v351, v163, v302, __s1, v364, &v338, &v334);
    v161 = v166;
    if (v166 > 0)
      v52 = 1;
    else
      v52 = v165;
    if (v166 > 0)
      v67 = v364[0];
    v167 = v164;
    if (v334)
    {
      v168 = v52;
      RangeOfCharacterClusterAtIndex = CFStringGetRangeOfCharacterClusterAtIndex(theString, v164, 1);
      v52 = v168;
      v288 = RangeOfCharacterClusterAtIndex + v170;
    }
    else
    {
      v288 = 0;
    }
    locale = cf;
    v55 = v307;
    v47 = v308;
    v48 = v162;
    v49 = v328;
    v51 = v286;
    v61 = v329;
    v46 = v331;
    v50 = v318;
    v21 = v167;
    v54 = v312;
    v57 = v298;
  }
  else
  {
    v161 = 0;
    locale = cf;
  }
  v160 = v161 == 0;
  v304 = v161;
  if (!v161 && v57 >= 1)
  {
    if (!locale)
    {
      v211 = v67 >= theChar;
      goto LABEL_616;
    }
    v277 = v327 - v47;
LABEL_651:
    v278 = v301 - v55;
    v279 = v55;
    v280 = v139;
LABEL_652:
    v77 = _CFCompareStringsWithLocale(v351, v47, v277, buffer, v279, v278, v280, locale);
    if (!v306)
      return v77;
    v212 = locale;
LABEL_614:
    CFRelease(v212);
    return v77;
  }
LABEL_311:
  if (!v61)
  {
    if (v67 != theChar)
      v160 = 1;
    if (v160 && (!v289 || v289 == v54))
    {
      v294 = v52;
      v175 = v51;
      v176 = v48;
      v334 = 0;
      v177 = v54;
      v178 = __CFStringFoldCharacterClusterAtIndex(theChar, buffer, v54, v302, __s1, v363, &v337, &v334);
      v179 = v363[0];
      if (v178 <= 0)
        v179 = theChar;
      else
        v53 = 1;
      if (v178 && v67 == v179)
      {
        v180 = v178;
        if (v334)
        {
          v181 = CFStringGetRangeOfCharacterClusterAtIndex(v283, v177, 1);
          v142 = v181 + v182;
        }
        else
        {
          v142 = 0;
        }
        length = v327;
        v48 = v176;
        v49 = v328;
        v51 = v175;
        v46 = v331;
        v50 = v318;
        v55 = v307;
        v47 = v308;
        v52 = v294;
        v139 = v302;
        v54 = v177;
        v57 = v180;
        goto LABEL_313;
      }
      if (!locale)
      {
        v211 = v67 >= v179;
        goto LABEL_616;
      }
      v279 = v307;
      v47 = v308;
      v277 = v327 - v308;
      v280 = v302;
      v278 = v301 - v307;
      goto LABEL_652;
    }
    v57 = 0;
    length = v327;
LABEL_328:
    v56 = v304;
    goto LABEL_329;
  }
  length = v327;
  v142 = v289;
LABEL_313:
  v289 = v142;
  if (v304 < 1 || v57 < 1)
    goto LABEL_328;
  while (v52 < v304 && v53 < v57)
  {
    if (v364[v52] != v363[v53])
      goto LABEL_649;
    ++v52;
    ++v53;
  }
  if (v52 >= v304)
    goto LABEL_328;
  v56 = v304;
  if (v53 >= v57)
    goto LABEL_329;
LABEL_649:
  if (locale)
  {
    v277 = length - v47;
    goto LABEL_651;
  }
  v211 = v364[v52] >= v363[v53];
LABEL_616:
  if (v211)
    return 1;
  else
    return -1;
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  char v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  char **p_data;
  char *v11;
  uint64_t v12;

  if (((unint64_t)theString & 0x8000000000000000) != 0)
  {
    v2 = 0;
    v3 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)theString & 0xC000000000000007) == 0)
      LOBYTE(v3) = 0;
    v4 = (v3 ^ theString) & 7;
    while (v4 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v2))
    {
      if (++v2 == 7)
        goto LABEL_10;
    }
    if (v2 == 2)
      return _NSTaggedPointerStringGetLength((uint64_t)theString);
  }
LABEL_10:
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    return -[__CFString length]((id)theString, "length");
  v6 = atomic_load((unint64_t *)&theString->info);
  v7 = v6 & 5;
  v8 = atomic_load((unint64_t *)&theString->info);
  v9 = v8 & 0x60;
  if (v7 == 4)
  {
    p_data = &theString->data;
    if (v9)
    {
      v11 = *p_data;
    }
    else
    {
      v12 = atomic_load((unint64_t *)&theString->info);
      v11 = (char *)&p_data[(v12 & 5) != 4];
    }
    return *v11;
  }
  else if ((v8 & 0x60) != 0)
  {
    return theString->length;
  }
  else
  {
    return (CFIndex)theString->data;
  }
}

uint64_t _CFStringGetCStringPtrInternal(uint64_t a1, unsigned int a2, int a3, int a4)
{
  unint64_t *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t result;
  BOOL v13;
  char v14;
  char v15;
  char v16;
  _QWORD *v17;
  _QWORD *v18;
  char v19;
  unint64_t v20;
  BOOL v21;
  BOOL v22;

  v7 = (unint64_t *)a1;
  if (a1 < 0 && a4)
  {
    v8 = 0;
    v9 = *MEMORY[0x1E0DE7C58];
    if ((~a1 & 0xC000000000000007) == 0)
      LOBYTE(v9) = 0;
    v10 = (v9 ^ a1) & 7;
    while (v10 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v8))
    {
      if (++v8 == 7)
        goto LABEL_10;
    }
    if (v8 == 2)
      return 0;
  }
LABEL_10:
  v11 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    a1 = ((uint64_t (*)(void))__CFStringComputeEightBitStringEncoding)();
    v11 = __CFDefaultEightBitStringEncoding;
  }
  if (v11 != a2)
  {
    if (v11 == -1)
    {
      __CFStringComputeEightBitStringEncoding(a1);
      v11 = __CFDefaultEightBitStringEncoding;
    }
    if (v11 == 1536)
    {
      result = 0;
      switch(BYTE1(a2))
      {
        case 0:
          result = 0;
          if ((a2 > 0x22 || ((1 << a2) & 0x600000032) == 0) && a2 != 152)
          {
            v13 = 1;
            goto LABEL_49;
          }
          return result;
        case 1:
          v21 = a2 == 134217984;
          goto LABEL_38;
        case 2:
          v13 = a2 != 518;
          goto LABEL_49;
        case 6:
          v21 = a2 == 1536;
LABEL_38:
          v13 = v21;
          goto LABEL_49;
        case 8:
        case 0xC:
          return result;
        case 0xA:
          v13 = 1;
          if (a2 - 2561 <= 0xF && ((1 << (a2 - 1)) & 0x8011) != 0)
            return 0;
          goto LABEL_49;
        case 0xB:
          if (a2 == 3071)
            return 0;
          v22 = __CFADD__(a2 - 3061, 2);
          goto LABEL_46;
        default:
          v22 = (a2 & 0xFF00) >= 0xC01;
LABEL_46:
          v13 = !v22;
LABEL_49:
          result = 0;
          if (!v7 || !v13)
            return result;
          goto LABEL_14;
      }
    }
    return 0;
  }
  if (!v7)
    return 0;
LABEL_14:
  if (a4 && CF_IS_OBJC(7uLL, (__objc2_class **)v7))
    return objc_msgSend(v7, "_fastCStringContents:", a3 != 0);
  if (a3 || (v14 = atomic_load(v7 + 1), (v14 & 0x10) != 0))
  {
    v15 = atomic_load(v7 + 1);
    if ((v15 & 8) == 0)
      return 0;
  }
  v16 = atomic_load(v7 + 1);
  v17 = v7 + 2;
  if ((v16 & 0x60) != 0)
  {
    v18 = (_QWORD *)*v17;
  }
  else
  {
    v19 = atomic_load(v7 + 1);
    v18 = &v17[(v19 & 5) != 4];
  }
  v20 = atomic_load(v7 + 1);
  return (uint64_t)v18 + ((v20 >> 2) & 1);
}

unint64_t CF_IS_OBJC(unint64_t result, __objc2_class **a2)
{
  __objc2_class *v2;
  uint64_t *v3;
  int v4;
  uint64_t v5;
  __objc2_class *v6;

  if (((unint64_t)a2 & 0x8000000000000000) != 0)
    return 1;
  v2 = *a2;
  if (!*a2)
  {
    if (result)
      CF_IS_OBJC_cold_1();
    return result;
  }
  if (result == 7 && v2 == __CFConstantStringClassReferencePtr)
    return 0;
  if (result <= 0x47)
  {
    v3 = &__CFRuntimeBuiltinObjCClassTable[result];
    goto LABEL_13;
  }
  v4 = result - 72;
  if ((int)result - 72 < dword_1ECCFAFE8)
  {
    v5 = __CFRuntimeClassTables[(v4 >> 6) + 16];
    if (v5)
    {
      v3 = (uint64_t *)(v5 + 8 * (v4 & 0x3F));
LABEL_13:
      v6 = (__objc2_class *)*v3;
      if (v2 == v6)
        return 0;
      goto LABEL_16;
    }
  }
  v6 = 0;
LABEL_16:
  if ((v2 & 1) == 0)
    return 1;
  return (*MEMORY[0x1E0DE7C40] & (unint64_t)v2) != (_QWORD)v6;
}

uint64_t __CFStringFillCharacterSetInlineBuffer(uint64_t a1, unint64_t a2)
{
  const __CFCharacterSet *Predefined;
  __CFCharacterSet *MutableCopy;

  if ((a2 & 0x10000) != 0)
  {
    if (!__CFStringFillCharacterSetInlineBuffer_nonAlnumChars)
    {
      Predefined = CFCharacterSetGetPredefined(kCFCharacterSetAlphaNumeric);
      MutableCopy = CFCharacterSetCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Predefined);
      CFCharacterSetInvert(MutableCopy);
      while (!__ldaxr((unint64_t *)&__CFStringFillCharacterSetInlineBuffer_nonAlnumChars))
      {
        if (!__stlxr((unint64_t)MutableCopy, (unint64_t *)&__CFStringFillCharacterSetInlineBuffer_nonAlnumChars))goto LABEL_8;
      }
      __clrex();
      CFRelease(MutableCopy);
    }
LABEL_8:
    CFCharacterSetInitInlineBuffer((__objc2_class **)__CFStringFillCharacterSetInlineBuffer_nonAlnumChars, a1);
  }
  return (a2 >> 16) & 1;
}

uint64_t _NSIsNSNumber(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  Class Class;
  uint64_t (*MethodImplementation)(uint64_t, char *);

  if (a1 < 0)
  {
    v2 = 0;
    v3 = *MEMORY[0x1E0DE7C58];
    if ((~a1 & 0xC000000000000007) == 0)
      LOBYTE(v3) = 0;
    v4 = (v3 ^ a1) & 7;
    do
    {
      if (v4 == *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v2))
        break;
      ++v2;
    }
    while (v2 != 7);
    LOBYTE(Class) = (v2 & 7) == 3;
    return Class & 1;
  }
  if (_NSNumberClass)
  {
    if (a1)
      goto LABEL_10;
LABEL_14:
    LOBYTE(Class) = 0;
    return Class & 1;
  }
  Class = objc_getClass("NSNumber");
  _NSNumberClass = (uint64_t)Class;
  if (!Class)
    return Class & 1;
  if (!a1)
    goto LABEL_14;
LABEL_10:
  MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
    return MethodImplementation(a1, sel_isNSNumber__);
  LOBYTE(Class) = objc_opt_isKindOfClass();
  return Class & 1;
}

uint64_t _CFNumberGetType2(unint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;

  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    v2 = 0;
    v3 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0)
      v3 = 0;
    v4 = v3 ^ (unint64_t)a1;
    v5 = (v3 ^ (unint64_t)a1) & 7;
    v6 = MEMORY[0x1E0DE7C48];
    while (v5 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v2))
    {
      if (++v2 == 7)
        goto LABEL_15;
    }
    if (v2 == 3)
    {
      v7 = 0;
      while (v5 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v7))
      {
        if (++v7 == 7)
          goto LABEL_25;
      }
      goto LABEL_21;
    }
LABEL_15:
    if (CF_IS_OBJC(0x16uLL, (__objc2_class **)a1))
      return objc_msgSend(a1, "_cfNumberType");
    v7 = 0;
    while (v5 != *(unsigned __int8 *)(v6 + v7))
    {
      if (++v7 == 7)
        goto LABEL_25;
    }
LABEL_21:
    if (v7 == 3)
    {
      v9 = 0xFFFFFFFFFFFFFFFLL;
      if (v5 == 7)
        v9 = 0xFFFFFFFFFFFFFLL;
      v10 = v9 & (v4 >> 3);
      return __CFNumberCanonicalTypes[v10 & 7];
    }
  }
  else if (CF_IS_OBJC(0x16uLL, (__objc2_class **)a1))
  {
    return objc_msgSend(a1, "_cfNumberType");
  }
LABEL_25:
  LOBYTE(v10) = atomic_load(a1 + 1);
  return __CFNumberCanonicalTypes[v10 & 7];
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  void *v3;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  char v12;
  uint64_t v13;
  _BYTE v15[128];
  uint64_t v16;

  v3 = valuePtr;
  v16 = *MEMORY[0x1E0C80C00];
  if (((unint64_t)number & 0x8000000000000000) == 0)
    goto LABEL_18;
  v6 = 0;
  v7 = *MEMORY[0x1E0DE7C58];
  if ((~(unint64_t)number & 0xC000000000000007) == 0)
    v7 = 0;
  v8 = v7 ^ (unint64_t)number;
  v9 = v8 & 7;
  while (v9 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v6))
  {
    if (++v6 == 7)
      goto LABEL_18;
  }
  if (v6 == 3)
  {
    if (!valuePtr)
      valuePtr = v15;
    if (v9 == 7)
      v10 = (uint64_t)(v8 << 9) >> 12;
    else
      v10 = (uint64_t)(2 * v8) >> 4;
    v11 = (v8 & 0x40) == 0;
    v12 = 6;
    if (v11)
      v12 = 4;
    v13 = v10 >> v12;
    switch(__CFNumberTypeTable[theType] & 0x1F)
    {
      case 1:
        *(_BYTE *)valuePtr = v13;
        break;
      case 2:
        *(_WORD *)valuePtr = v13;
        break;
      case 3:
        *(_DWORD *)valuePtr = v13;
        break;
      case 4:
        *(_QWORD *)valuePtr = v13;
        break;
      case 5:
        *(float *)valuePtr = (float)v13;
        break;
      case 6:
        *(double *)valuePtr = (double)v13;
        break;
      default:
        return __CFNumberGetValueCompat((uint64_t)number, theType, (uint64_t)valuePtr);
    }
    return 1;
  }
  else
  {
LABEL_18:
    if (CF_IS_OBJC(0x16uLL, (__objc2_class **)number))
    {
      return -[__CFNumber _getValue:forType:](number, "_getValue:forType:", v3, __CFNumberTypeTable[theType] & 0x1FLL);
    }
    else
    {
      if (v3)
        valuePtr = v3;
      else
        valuePtr = v15;
      return __CFNumberGetValueCompat((uint64_t)number, theType, (uint64_t)valuePtr);
    }
  }
}

uint64_t __CFNumberGetValueCompat(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t result;
  __int16 v19;
  double v20;
  int v21;
  _BOOL4 v22;
  BOOL v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;
  __int16 v29;
  unint64_t v30;
  __int16 v31;
  unint64_t v32;
  __int16 v33;
  __int16 v35;
  uint64_t v36;
  float v37;
  int v38;
  float v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  double v47;
  double v48;
  int v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  double v53;
  float v54;
  unint64_t v55;
  int64_t v56;
  double v57;
  float v58;
  double v59;
  unint64_t v60;
  uint64_t v61;
  double v62;
  _BOOL4 v63;
  BOOL v64;
  _BOOL4 v65;
  uint64_t v66;
  double v67;
  uint64_t v68;
  double v69;
  _QWORD v70[2];

  v70[1] = *MEMORY[0x1E0C80C00];
  if ((a1 & 0x8000000000000000) == 0)
    goto LABEL_12;
  v3 = 0;
  v4 = *MEMORY[0x1E0DE7C58];
  if ((~a1 & 0xC000000000000007) == 0)
    v4 = 0;
  v5 = v4 ^ a1;
  v6 = v5 & 7;
  while (v6 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v3))
  {
    if (++v3 == 7)
      goto LABEL_12;
  }
  if (v3 == 3)
  {
    v7 = 0xFFFFFFFFFFFFFFFLL;
    if (v6 == 7)
      v7 = 0xFFFFFFFFFFFFFLL;
    v8 = v7 & (v5 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v8) = atomic_load((unint64_t *)(a1 + 8));
  }
  v9 = __CFNumberTypeTable[a2] & 0x1FLL;
  v10 = __CFNumberCanonicalTypes[v8 & 7];
  v11 = (unint64_t *)(a1 + 16);
  v70[0] = 0;
  if (a1 < 0)
  {
    v12 = 0;
    v13 = *MEMORY[0x1E0DE7C58];
    if ((~a1 & 0xC000000000000007) == 0)
      v13 = 0;
    v14 = v13 ^ a1;
    v15 = v14 & 7;
    while (v15 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v12))
    {
      if (++v12 == 7)
        goto LABEL_28;
    }
    if (v12 == 3)
    {
      v16 = v14 << 9 >> 12;
      if (v15 != 7)
        v16 = (2 * v14) >> 4;
      v17 = 6;
      if ((v14 & 0x40) == 0)
        v17 = 4;
      v70[0] = v16 >> v17;
      if ((unint64_t)(v10 - 5) < 2)
        v10 = 4;
      v11 = v70;
    }
  }
LABEL_28:
  result = 0;
  switch(v9)
  {
    case 1:
      v19 = __CFNumberTypeTable[v10];
      if ((v19 & 0x20) == 0)
      {
        if ((v19 & 0x40) == 0)
        {
          v20 = *(double *)v11;
          *(_BYTE *)a3 = *v11;
          v21 = _CFExecutableLinkedOnOrAfter(6uLL);
          v22 = *(_QWORD *)&v20 == SLOBYTE(v20);
          v23 = *(_QWORD *)&v20 >= 0x100uLL;
          goto LABEL_35;
        }
        v50 = v11[1];
        *(_BYTE *)a3 = v50;
        return v50 == (char)v50;
      }
      if ((v19 & 0x40) == 0)
      {
        v37 = *(float *)v11;
        v38 = (int)*(float *)v11;
        *(_BYTE *)a3 = v38;
        goto LABEL_64;
      }
      v48 = *(double *)v11;
      v49 = (int)*(double *)v11;
      *(_BYTE *)a3 = v49;
      goto LABEL_102;
    case 2:
      v24 = __CFNumberTypeTable[v10];
      if ((v24 & 0x20) == 0)
      {
        if ((v24 & 0x40) != 0)
        {
          v43 = v11[1];
          *(_WORD *)a3 = v43;
          return v43 == (__int16)v43;
        }
        v25 = *v11;
        *(_WORD *)a3 = *v11;
        v21 = _CFExecutableLinkedOnOrAfter(6uLL);
        v22 = v25 == (__int16)v25;
        v23 = v25 >= 0x10000;
LABEL_35:
        if (!v23)
          v22 = 1;
        return !v21 || v22;
      }
      if ((v24 & 0x40) != 0)
      {
        v48 = *(double *)v11;
        v49 = (int)*(double *)v11;
        *(_WORD *)a3 = v49;
        goto LABEL_102;
      }
      v37 = *(float *)v11;
      v38 = (int)*(float *)v11;
      *(_WORD *)a3 = v38;
LABEL_64:
      v39 = (float)v38;
      return v37 == v39;
    case 3:
      v29 = __CFNumberTypeTable[v10];
      if ((v29 & 0x20) == 0)
      {
        if ((v29 & 0x40) != 0)
          v30 = v11[1];
        else
          v30 = *v11;
        *(_DWORD *)a3 = v30;
        return v30 == (int)v30;
      }
      if ((v29 & 0x40) == 0)
      {
        v37 = *(float *)v11;
        *(_DWORD *)a3 = (int)*(float *)v11;
        v39 = (float)(int)v37;
        return v37 == v39;
      }
      v48 = *(double *)v11;
      v49 = (int)*(double *)v11;
      *(_DWORD *)a3 = v49;
LABEL_102:
      v57 = (double)v49;
      return v48 == v57;
    case 4:
      v31 = __CFNumberTypeTable[v10];
      if ((v31 & 0x20) == 0)
      {
        if ((v31 & 0x40) == 0)
          goto LABEL_60;
        v32 = v11[1];
        goto LABEL_61;
      }
      if ((v31 & 0x40) == 0)
      {
        v37 = *(float *)v11;
        v40 = (uint64_t)*(float *)v11;
        *(_QWORD *)a3 = v40;
        v39 = (float)v40;
        return v37 == v39;
      }
      v48 = *(double *)v11;
      *(_QWORD *)a3 = (uint64_t)*(double *)v11;
      v57 = (double)(uint64_t)v48;
      return v48 == v57;
    case 5:
      v33 = __CFNumberTypeTable[v10];
      if ((v33 & 0x20) != 0)
      {
        if ((v33 & 0x40) == 0)
        {
          *(_DWORD *)a3 = *(_DWORD *)v11;
          return 1;
        }
        v48 = *(double *)v11;
        v58 = *(double *)v11;
        *(float *)a3 = v58;
        v57 = v58;
        return v48 == v57;
      }
      v27 = *v11;
      if ((v33 & 0x40) == 0)
      {
        *(float *)a3 = (float)v27;
        v28 = (uint64_t)(float)v27;
        return v27 == v28;
      }
      v44 = v11[1];
      v51 = -v27;
      if (v44)
        v51 = ~v27;
      if (v27 < 0)
      {
        v52 = -(uint64_t)v44;
      }
      else
      {
        v51 = v27;
        v52 = v44;
      }
      v53 = -((double)v52 + (double)v51 * 1.84467441e19);
      if (v27 >= 0)
        v53 = (double)v52 + (double)v51 * 1.84467441e19;
      v54 = v53;
      *(float *)a3 = v54;
      if (v54 < -1.7014e38)
        goto LABEL_97;
      if (v54 >= 1.7014e38)
        goto LABEL_117;
      v47 = v54;
      goto LABEL_112;
    case 6:
      v26 = __CFNumberTypeTable[v10];
      if ((v26 & 0x20) != 0)
      {
        if ((v26 & 0x40) == 0)
        {
          *(double *)a3 = *(float *)v11;
          return 1;
        }
LABEL_60:
        v32 = *v11;
LABEL_61:
        *(_QWORD *)a3 = v32;
        return 1;
      }
      v27 = *v11;
      if ((v26 & 0x40) != 0)
      {
        v44 = v11[1];
        v45 = -v27;
        if (v44)
          v45 = ~v27;
        if (v27 < 0)
        {
          v46 = -(uint64_t)v44;
        }
        else
        {
          v45 = v27;
          v46 = v44;
        }
        v47 = -((double)v46 + (double)v45 * 1.84467441e19);
        if (v27 >= 0)
          v47 = (double)v46 + (double)v45 * 1.84467441e19;
        *(double *)a3 = v47;
        if (v47 < -1.70141183e38)
        {
LABEL_97:
          v55 = 0;
          v56 = 0x8000000000000000;
        }
        else
        {
          if (v47 >= 1.70141183e38)
          {
LABEL_117:
            v56 = 0x7FFFFFFFFFFFFFFFLL;
            v55 = -1;
LABEL_118:
            v63 = v56 <= v27;
            v64 = v55 > v44;
            v65 = v55 >= v44 && v63;
            return !v64 && v65;
          }
LABEL_112:
          v56 = vcvtmd_s64_f64(v47 * 5.42101086e-20);
          v55 = (unint64_t)(v47 + floor(v47 * 5.42101086e-20) * -1.84467441e19);
        }
        if (v56 < v27)
          return 0;
        goto LABEL_118;
      }
      *(double *)a3 = (double)v27;
      v28 = (uint64_t)(double)v27;
      return v27 == v28;
    case 17:
      v35 = __CFNumberTypeTable[v10];
      if ((v35 & 0x20) == 0)
      {
        if ((v35 & 0x40) != 0)
        {
          *(_OWORD *)a3 = *(_OWORD *)v11;
        }
        else
        {
          v36 = *v11;
          *(_QWORD *)a3 = v36 >> 63;
          *(_QWORD *)(a3 + 8) = v36;
        }
        return 1;
      }
      if ((v35 & 0x40) != 0)
      {
        v59 = *(double *)v11;
        if (*(double *)v11 >= -1.70141183e38)
        {
          if (v59 >= 1.70141183e38)
          {
            v60 = -1;
            v61 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else
          {
            v61 = vcvtmd_s64_f64(v59 * 5.42101086e-20);
            v60 = (unint64_t)(v59 + floor(v59 * 5.42101086e-20) * -1.84467441e19);
          }
        }
        else
        {
          v60 = 0;
          v61 = 0x8000000000000000;
        }
        *(_QWORD *)a3 = v61;
        *(_QWORD *)(a3 + 8) = v60;
        v68 = -v61;
        if (v60)
          v68 = ~v61;
        if (v61 < 0)
          v60 = -(uint64_t)v60;
        else
          v68 = v61;
        v69 = -((double)v60 + (double)v68 * 1.84467441e19);
        if (v61 >= 0)
          v69 = (double)v60 + (double)v68 * 1.84467441e19;
        return v69 == v59;
      }
      else
      {
        v37 = *(float *)v11;
        if (*(float *)v11 >= -1.7014e38)
        {
          if (v37 >= 1.7014e38)
          {
            v41 = -1;
            v42 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else
          {
            v62 = v37 * 5.42101086e-20;
            v42 = vcvtmd_s64_f64(v62);
            v41 = (unint64_t)(v37 + floor(v62) * -1.84467441e19);
          }
        }
        else
        {
          v41 = 0;
          v42 = 0x8000000000000000;
        }
        *(_QWORD *)a3 = v42;
        *(_QWORD *)(a3 + 8) = v41;
        v66 = -v42;
        if (v41)
          v66 = ~v42;
        if (v42 < 0)
          v41 = -(uint64_t)v41;
        else
          v66 = v42;
        v67 = -((double)v41 + (double)v66 * 1.84467441e19);
        if (v42 >= 0)
          v67 = (double)v41 + (double)v66 * 1.84467441e19;
        v39 = v67;
        return v37 == v39;
      }
    default:
      return result;
  }
}

uint64_t __CFRunLoopModeEqual(uint64_t a1, uint64_t a2)
{
  return CFEqual(*(CFTypeRef *)(a1 + 80), *(CFTypeRef *)(a2 + 80));
}

BOOL typeStringEqual(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

uint64_t _dependentNotificationsEqual(CFTypeRef **a1, CFTypeRef **a2)
{
  return CFEqual(**a1, **a2);
}

uint64_t _CFCompareStringsWithLocale(UniChar *buffer, int64_t a2, int64_t a3, UniChar *a4, int64_t a5, int64_t a6, unint64_t a7, const __CFLocale *a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFLocaleRef v18;
  const __CFLocale *v19;
  BOOL v20;
  const __CFLocale *v21;
  const void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  UniChar *Typed;
  uint64_t v27;
  uint64_t v28;
  CFRange v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  UniChar *v33;
  uint64_t v34;
  UniChar *v35;
  int64_t v36;
  int64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  CFRange v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  UniChar *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  BOOL v53;
  int64_t v54;
  int64_t v55;
  UniChar *v56;
  uint64_t v57;
  CFIndex v58;
  uint64_t v59;
  CFRange v60;
  char *v61;
  UniChar v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  CFRange v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  UniChar *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int64_t v79;
  UniChar *v80;
  int64_t v81;
  UniChar *v82;
  uint64_t v83;
  CFIndex v84;
  uint64_t v85;
  CFRange v86;
  char *v87;
  UniChar v88;
  int64_t v89;
  int v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  BOOL v94;
  BOOL v95;
  uint64_t v96;
  uint64_t v97;
  const __CFLocale *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  CFTypeRef v102;
  uint64_t v104;
  uint64_t v105;
  CFRange v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  UniChar *v110;
  int64_t v111;
  int64_t v112;
  int64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  const __CFLocale *cf;
  UniChar *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  UniChar *ptr;
  UniChar *v124;
  UniChar *__src;
  int v126;
  int64_t v128;
  uint64_t Collator;
  const __CFLocale *v130;
  CFTypeRef v131;
  BOOL v132;
  int v133;
  char v134;
  char __dst;
  uint64_t v136;

  v136 = *MEMORY[0x1E0C80C00];
  v133 = 0;
  v132 = 0;
  if (!_CFCompareStringsWithLocale_alnumBMP)
  {
    _CFCompareStringsWithLocale_alnumBMP = CFUniCharGetBitmapPtrForPlane(0xAu, 0);
    _CFCompareStringsWithLocale_nonBaseBMP = CFUniCharGetBitmapPtrForPlane(8u, 0);
    _CFCompareStringsWithLocale_punctBMP = CFUniCharGetBitmapPtrForPlane(0xBu, 0);
    _CFCompareStringsWithLocale_controlBMP = CFUniCharGetBitmapPtrForPlane(0x6Cu, 0);
  }
  v15 = a2;
  if (a2 >= 1)
    v15 = __extendLocationBackward(a2 - 1, buffer, _CFCompareStringsWithLocale_nonBaseBMP, _CFCompareStringsWithLocale_punctBMP);
  v16 = a5;
  if (a5 >= 1)
    v16 = __extendLocationBackward(a5 - 1, a4, _CFCompareStringsWithLocale_nonBaseBMP, _CFCompareStringsWithLocale_punctBMP);
  v17 = _CFGetTSD(9u);
  v116 = _CFGetTSD(8u);
  v117 = v17;
  cf = a8;
  v119 = buffer;
  if ((const __CFLocale *)v116 == a8)
  {
    v126 = 1;
    Collator = v17;
    if (v15 < 0)
      goto LABEL_32;
    goto LABEL_31;
  }
  os_unfair_lock_lock_with_options();
  if ((const __CFLocale *)__CFDefaultCollatorLocale == a8)
  {
    v19 = 0;
    v20 = 1;
    goto LABEL_23;
  }
  v18 = CFLocaleCopyCurrent();
  if (v18 == a8)
  {
    v21 = a8;
    v20 = a8 == 0;
    if (v21)
    {
      v22 = (const void *)__CFDefaultCollatorLocale;
      v19 = v21;
      if ((const __CFLocale *)__CFDefaultCollatorLocale != v21)
      {
        v23 = __CFDefaultCollatorsCount;
        if (__CFDefaultCollatorsCount >= 1)
        {
          do
          {
            __CFDefaultCollatorsCount = v23 - 1;
            ucol_close();
            v23 = __CFDefaultCollatorsCount;
          }
          while (__CFDefaultCollatorsCount > 0);
          v22 = (const void *)__CFDefaultCollatorLocale;
        }
        v19 = cf;
        if (v22)
          CFRelease(v22);
        v20 = 0;
        __CFDefaultCollatorLocale = (uint64_t)CFRetain(cf);
      }
    }
    else
    {
      v19 = 0;
    }
LABEL_23:
    v130 = v19;
    if (__CFDefaultCollatorsCount <= 0)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
    }
    else
    {
      v24 = __CFDefaultCollators[--__CFDefaultCollatorsCount];
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
      Collator = v24;
      if (v24)
      {
        if (v20)
          goto LABEL_27;
        goto LABEL_26;
      }
    }
    Collator = __CFStringCreateCollator(cf);
    if (v20)
    {
LABEL_27:
      a8 = cf;
      if (Collator)
      {
        v126 = 0;
        if (v15 < 0)
          goto LABEL_32;
        goto LABEL_31;
      }
      goto LABEL_30;
    }
LABEL_26:
    CFRelease(v130);
    goto LABEL_27;
  }
  CFRelease(v18);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFDefaultCollatorLock);
LABEL_30:
  Collator = __CFStringCreateCollator(a8);
  _CFSetTSD(0x11u, 0, 0);
  v126 = 1;
  if (v15 < 0)
    goto LABEL_32;
LABEL_31:
  v25 = *((_QWORD *)buffer + 20);
  if (v15 + a3 <= v25)
  {
    v27 = *((_QWORD *)buffer + 17);
    if (v27)
    {
      Typed = (UniChar *)(v27 + 2 * *((_QWORD *)buffer + 19) + 2 * v15);
      if (v16 < 0)
        goto LABEL_53;
      goto LABEL_52;
    }
    if (a3 <= 64)
    {
      if (v15 + a3 > *((_QWORD *)buffer + 22) || (v28 = *((_QWORD *)buffer + 21), v15 < v28))
      {
        if (v15 + 64 < v25)
          v25 = v15 + 64;
        *((_QWORD *)buffer + 21) = v15;
        *((_QWORD *)buffer + 22) = v25;
        v29.length = v25 - v15;
        v31 = *((_QWORD *)buffer + 18);
        v30 = *((_QWORD *)buffer + 19);
        if (v31)
        {
          v28 = v15;
          if (v29.length)
          {
            v32 = v31 + v30;
            v33 = buffer;
            do
            {
              *v33++ = *(char *)(v32 + v15);
              ++v32;
              --v25;
            }
            while (v15 != v25);
            v28 = v15;
          }
        }
        else
        {
          v29.location = v30 + v15;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v29, buffer);
          v28 = *((_QWORD *)buffer + 21);
        }
      }
      Typed = &buffer[v15 - v28];
      if (v16 < 0)
        goto LABEL_53;
      goto LABEL_52;
    }
  }
LABEL_32:
  Typed = 0;
  if (v16 < 0)
    goto LABEL_53;
LABEL_52:
  v34 = *((_QWORD *)a4 + 20);
  if (v16 + a6 <= v34)
  {
    v104 = *((_QWORD *)a4 + 17);
    if (v104)
    {
      v35 = (UniChar *)(v104 + 2 * *((_QWORD *)a4 + 19) + 2 * v16);
      if (!Typed)
        goto LABEL_54;
    }
    else
    {
      if (a6 > 64)
        goto LABEL_53;
      if (v16 + a6 > *((_QWORD *)a4 + 22) || (v105 = *((_QWORD *)a4 + 21), v16 < v105))
      {
        if (v16 + 64 < v34)
          v34 = v16 + 64;
        *((_QWORD *)a4 + 21) = v16;
        *((_QWORD *)a4 + 22) = v34;
        v106.length = v34 - v16;
        v108 = *((_QWORD *)a4 + 18);
        v107 = *((_QWORD *)a4 + 19);
        if (v108)
        {
          v105 = v16;
          if (v106.length)
          {
            v109 = v108 + v107;
            v110 = a4;
            do
            {
              *v110++ = *(char *)(v109 + v16);
              ++v109;
              --v34;
            }
            while (v16 != v34);
            v105 = v16;
          }
        }
        else
        {
          v106.location = v107 + v16;
          CFStringGetCharacters(*((CFStringRef *)a4 + 16), v106, a4);
          v105 = *((_QWORD *)a4 + 21);
        }
      }
      v35 = &a4[v16 - v105];
      if (!Typed)
        goto LABEL_54;
    }
    if (v35)
    {
      v111 = a2 + a3 - v15;
      v112 = a5 + a6 - v16;
      v100 = Collator;
      if (Collator && !__CompareTextDefault(Collator, v126, a7, Typed, v111, v35, v112, &v132, &v133))
      {
        v114 = (a7 >> 9) & 1;
        if (!v132)
          LODWORD(v114) = 1;
        v115 = 1;
        if (v133 < 0)
          v115 = -1;
        if ((_DWORD)v114)
          v97 = v115;
        else
          v97 = 0;
      }
      else
      {
        if (v111 >= v112)
          v113 = v112;
        else
          v113 = v111;
        if (memcmp(Typed, v35, 2 * v113) >= 0)
          v97 = 1;
        else
          v97 = -1;
      }
      v99 = v117;
      v98 = cf;
      goto LABEL_189;
    }
    goto LABEL_54;
  }
LABEL_53:
  v35 = 0;
LABEL_54:
  v120 = 0;
  v121 = 0;
  ptr = 0;
  v124 = 0;
  v122 = 0;
  v36 = a2 + a3;
  v37 = a5 + a6;
  __src = a4;
  v128 = a2 + a3;
  v131 = (CFTypeRef)(a5 + a6);
  do
  {
    if (a2 >= v36)
      goto LABEL_101;
    v38 = __extendLocationForward(a2, buffer, _CFCompareStringsWithLocale_alnumBMP, _CFCompareStringsWithLocale_punctBMP, _CFCompareStringsWithLocale_controlBMP, v36);
    a2 = v38;
    a3 = v38 - v15;
    if (v15 < 0)
      goto LABEL_58;
    v39 = *((_QWORD *)buffer + 20);
    if (v38 > v39)
      goto LABEL_58;
    v43 = *((_QWORD *)buffer + 17);
    if (!v43)
    {
      if (a3 <= 64)
      {
        if (v38 > *((_QWORD *)buffer + 22) || (v44 = *((_QWORD *)buffer + 21), v15 < v44))
        {
          if (v15 + 64 < v39)
            v39 = v15 + 64;
          *((_QWORD *)buffer + 21) = v15;
          *((_QWORD *)buffer + 22) = v39;
          v45.length = v39 - v15;
          v47 = *((_QWORD *)buffer + 18);
          v46 = *((_QWORD *)buffer + 19);
          if (v47)
          {
            v44 = v15;
            if (v45.length)
            {
              v48 = v47 + v46;
              v49 = buffer;
              do
              {
                *v49++ = *(char *)(v48 + v15);
                ++v48;
                --v39;
              }
              while (v15 != v39);
              v44 = v15;
            }
          }
          else
          {
            v45.location = v46 + v15;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v45, buffer);
            v44 = *((_QWORD *)buffer + 21);
          }
        }
        Typed = &buffer[v15 - v44];
        goto LABEL_100;
      }
LABEL_58:
      if (v121 < 0 || a3 >= 129)
      {
        if (v121 >= a3)
        {
          Typed = ptr;
        }
        else
        {
          if (a3 <= 0)
            v40 = -((v15 - v38) & 0x7F);
          else
            v40 = a3 & 0x7F;
          v41 = a3 - v40;
          v42 = v41 + 128;
          if (v121)
          {
            Typed = (UniChar *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, ptr, 2 * (v41 + 128), 0x1000040BDFB0063, 0, 0);
          }
          else
          {
            Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * (v41 + 128), 0x1000040BDFB0063, 0);
            if (!Typed)
              __CFStringHandleOutOfMemory();
          }
          v121 = v42;
          a4 = __src;
        }
      }
      else
      {
        Typed = (UniChar *)&__dst;
      }
      v50 = *((_QWORD *)buffer + 17);
      if (v50)
      {
        memmove(Typed, (const void *)(v50 + 2 * *((_QWORD *)buffer + 19) + 2 * v15), 2 * a3);
        ptr = Typed;
      }
      else
      {
        v51 = *((_QWORD *)buffer + 21);
        if (v15 < v51 || (v52 = *((_QWORD *)buffer + 22), v53 = v52 <= v15, v54 = v52 - v15, v53))
        {
          v56 = Typed;
          v57 = v15;
          v58 = a3;
          if (a2 > v51)
          {
            v56 = Typed;
            v57 = v15;
            v58 = a3;
            if (a2 < *((_QWORD *)buffer + 22))
            {
              v58 = v51 - v15;
              memmove(&Typed[v51 - v15], buffer, 2 * (a2 - v51));
              v56 = Typed;
              v57 = v15;
            }
          }
        }
        else
        {
          if (a3 >= v54)
            v55 = v54;
          else
            v55 = a3;
          memmove(Typed, &buffer[v15 - v51], 2 * v55);
          v56 = &Typed[v55];
          v57 = v55 + v15;
          v58 = a3 - v55;
        }
        if (v58 >= 1)
        {
          v59 = *((_QWORD *)buffer + 18);
          v60.location = *((_QWORD *)buffer + 19) + v57;
          if (v59)
          {
            v61 = (char *)(v59 + v60.location);
            do
            {
              v62 = *v61++;
              *v56++ = v62;
              --v58;
            }
            while (v58);
          }
          else
          {
            v60.length = v58;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v60, v56);
          }
        }
        ptr = Typed;
        a4 = __src;
      }
      goto LABEL_100;
    }
    Typed = (UniChar *)(v43 + 2 * *((_QWORD *)buffer + 19) + 2 * v15);
LABEL_100:
    v37 = (int64_t)v131;
LABEL_101:
    if (a5 < v37)
    {
      v63 = __extendLocationForward(a5, a4, _CFCompareStringsWithLocale_alnumBMP, _CFCompareStringsWithLocale_punctBMP, _CFCompareStringsWithLocale_controlBMP, v37);
      a5 = v63;
      a6 = v63 - v16;
      if (v16 < 0 || (v64 = *((_QWORD *)a4 + 20), v63 > v64))
      {
LABEL_104:
        if (v122 < 0 || a6 >= 129)
        {
          if (v122 >= a6)
          {
            v35 = v124;
          }
          else
          {
            if (a6 <= 0)
              v65 = -((v16 - v63) & 0x7F);
            else
              v65 = a6 & 0x7F;
            v66 = a6 - v65;
            v67 = v66 + 128;
            if (v122)
            {
              v35 = (UniChar *)__CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, v124, 2 * (v66 + 128), 0x1000040BDFB0063, 0, 0);
            }
            else
            {
              v35 = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * (v66 + 128), 0x1000040BDFB0063, 0);
              if (!v35)
                __CFStringHandleOutOfMemory();
            }
            v122 = v67;
            a4 = __src;
          }
        }
        else
        {
          v35 = (UniChar *)&v134;
        }
        v75 = *((_QWORD *)a4 + 17);
        if (v75)
        {
          memmove(v35, (const void *)(v75 + 2 * *((_QWORD *)a4 + 19) + 2 * v16), 2 * a6);
          v124 = v35;
          goto LABEL_146;
        }
        v76 = *((_QWORD *)a4 + 21);
        v77 = v16 - v76;
        if (v16 < v76 || (v78 = *((_QWORD *)a4 + 22), v53 = v78 <= v16, v79 = v78 - v16, v53))
        {
          v82 = v35;
          v83 = v16;
          v84 = a6;
          if (a5 > v76)
          {
            v82 = v35;
            v83 = v16;
            v84 = a6;
            if (a5 < *((_QWORD *)__src + 22))
            {
              v84 = v76 - v16;
              memmove(&v35[v76 - v16], __src, 2 * (a5 - v76));
              v82 = v35;
              v83 = v16;
            }
          }
        }
        else
        {
          v80 = a4;
          if (a6 >= v79)
            v81 = v79;
          else
            v81 = a6;
          memmove(v35, &v80[v77], 2 * v81);
          v82 = &v35[v81];
          v83 = v81 + v16;
          v84 = a6 - v81;
        }
        if (v84 >= 1)
        {
          v85 = *((_QWORD *)__src + 18);
          v86.location = *((_QWORD *)__src + 19) + v83;
          if (!v85)
          {
            v86.length = v84;
            CFStringGetCharacters(*((CFStringRef *)__src + 16), v86, v82);
            v124 = v35;
            a4 = __src;
            goto LABEL_145;
          }
          v87 = (char *)(v85 + v86.location);
          do
          {
            v88 = *v87++;
            *v82++ = v88;
            --v84;
          }
          while (v84);
        }
        v124 = v35;
        a4 = __src;
LABEL_145:
        buffer = v119;
        goto LABEL_146;
      }
      v68 = *((_QWORD *)a4 + 17);
      if (v68)
      {
        v35 = (UniChar *)(v68 + 2 * *((_QWORD *)a4 + 19) + 2 * v16);
      }
      else
      {
        if (a6 > 64)
          goto LABEL_104;
        if (v63 > *((_QWORD *)a4 + 22) || (v69 = *((_QWORD *)a4 + 21), v16 < v69))
        {
          if (v16 + 64 < v64)
            v64 = v16 + 64;
          *((_QWORD *)a4 + 21) = v16;
          *((_QWORD *)a4 + 22) = v64;
          v70.length = v64 - v16;
          v72 = *((_QWORD *)a4 + 18);
          v71 = *((_QWORD *)a4 + 19);
          if (v72)
          {
            v69 = v16;
            if (v70.length)
            {
              v73 = v72 + v71;
              v74 = a4;
              do
              {
                *v74++ = *(char *)(v73 + v16);
                ++v73;
                --v64;
              }
              while (v16 != v64);
              v69 = v16;
            }
          }
          else
          {
            v70.location = v71 + v16;
            CFStringGetCharacters(*((CFStringRef *)a4 + 16), v70, a4);
            v69 = *((_QWORD *)a4 + 21);
          }
        }
        v35 = &a4[v16 - v69];
      }
    }
LABEL_146:
    if (Collator && !__CompareTextDefault(Collator, v126, a7, Typed, a3, v35, a6, &v132, &v133))
    {
      v91 = v133;
      if (v132)
      {
        v92 = v120;
        v36 = v128;
        v93 = 1;
        if (v133 < 0)
          v93 = -1;
        if (((v120 == 0) & (a7 >> 9) & (v133 != 0)) != 0)
          v92 = v93;
        v120 = v92;
        v133 = 0;
        v91 = 0;
        v37 = (int64_t)v131;
        goto LABEL_169;
      }
    }
    else
    {
      if (!Typed || !v35)
        _CFCompareStringsWithLocale_cold_1();
      if (a3 >= a6)
        v89 = a6;
      else
        v89 = a3;
      v90 = memcmp(Typed, v35, 2 * v89);
      v133 = v90;
      if (!v90)
      {
        v36 = v128;
        v37 = (int64_t)v131;
        if (a3 < a6)
        {
          v133 = -2;
          v97 = -1;
          goto LABEL_185;
        }
        if (a6 < a3)
        {
          v133 = 2;
          v97 = 1;
          goto LABEL_185;
        }
        v91 = 0;
        goto LABEL_169;
      }
      if (v90 < 0)
        v91 = v90 - 1;
      else
        v91 = v90 + 1;
      v133 = v91;
    }
    v36 = v128;
    v37 = (int64_t)v131;
    if ((v91 - 2) < 0xFFFFFFFD)
      break;
LABEL_169:
    if (!v91)
    {
      v15 = a2;
      v16 = a5;
    }
  }
  while (a2 < v36 || a5 < v37);
  v94 = v91 == 0;
  v95 = v91 < 0;
  v96 = 1;
  if (v95)
    v96 = -1;
  if (v94)
    v97 = v120;
  else
    v97 = v96;
LABEL_185:
  v99 = v117;
  v98 = cf;
  v100 = Collator;
  if (v121 >= 1)
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, ptr);
  if (v122 >= 1)
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v124);
LABEL_189:
  if (v100 != v99)
  {
    if (v116)
    {
      v101 = _CFGetTSD(9u);
      __collatorFinalize(v101);
    }
    _CFSetTSD(9u, v100, (uint64_t)__collatorFinalize);
    v102 = CFRetain(v98);
    _CFSetTSD(8u, (uint64_t)v102, 0);
  }
  _CFSetTSD(0x11u, a7, 0);
  return v97;
}

uint64_t __CompareTextDefault(uint64_t a1, int a2, unsigned int a3, unsigned __int16 *a4, unint64_t a5, unsigned __int16 *a6, unint64_t a7, BOOL *a8, int *a9)
{
  char v14;
  int v15;
  int v16;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  BOOL v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;

  v14 = a3;
  *a8 = 1;
  *a9 = 0;
  if (!a2 || ((_CFGetTSD(0x11u) >> 6) & 1) != ((a3 >> 6) & 1))
    ucol_setAttribute();
  v15 = ucol_strcoll();
  if (v15)
  {
    if (v15 == -1)
      v16 = -2;
    else
      v16 = 2;
LABEL_8:
    *a9 = v16;
    goto LABEL_10;
  }
  v16 = *a9;
  if (!*a9)
  {
    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
    v20 = ucol_strcoll();
    if (v20)
    {
      if (v20 == -1)
        v21 = -1;
      else
        v21 = 1;
      *a9 = v21;
    }
    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
    v16 = *a9;
    if ((v14 & 0x10) == 0 && !v16)
    {
      ucol_openElements();
      v25 = ucol_openElements();
      v40 = a7;
      v26 = ucol_next();
      v27 = ucol_next();
      v42 = v25;
      v41 = 0;
      if (v26 == -1)
      {
        v16 = 0;
        goto LABEL_71;
      }
      v28 = v27;
      v16 = 0;
      if (v27 != -1)
      {
        v39 = a5;
        v29 = 0;
        v30 = 0;
        v41 = 0;
        v31 = v42;
        while (1)
        {
          v44 = MEMORY[0x186DB0E58]();
          v32 = MEMORY[0x186DB0E58](v31);
          v43 = v32;
          if ((v28 ^ v26) <= 0xFF)
          {
            if (v26 >= 0x10000)
            {
              v35 = v26;
              v36 = v28;
              if (v26 - 143 < 9)
                v35 = v26 - 138;
              if (v28 - 143 < 9)
                v36 = v28 - 138;
              if (v35 != v36)
              {
                if (v35 < v36)
                  v16 = -1;
                else
                  v16 = 1;
LABEL_70:
                a5 = v39;
                break;
              }
            }
            else
            {
              if (v44 - v30 > v32 - v29)
                v33 = -1;
              else
                v33 = 1;
              if (v44 - v30 == v32 - v29)
                v33 = 0;
              v34 = v41;
              if (v41)
                v33 = v41;
              if ((v26 & 0xFF00) != 0)
                v34 = v33;
              v41 = v34;
            }
          }
          v26 = ucol_next();
          v31 = v42;
          v37 = ucol_next();
          v28 = v37;
          v38 = v26 == -1 || v37 == -1;
          v29 = v43;
          v30 = v44;
          if (v38)
          {
            v16 = 0;
            goto LABEL_70;
          }
        }
      }
LABEL_71:
      ucol_closeElements();
      ucol_closeElements();
      a7 = v40;
      if (!v16)
        v16 = v41;
      goto LABEL_8;
    }
  }
LABEL_10:
  *a8 = v16 == 0;
  if (!*a9)
  {
    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
    v18 = ucol_strcoll();
    if (v18)
    {
      if (v18 == -1)
        v19 = -1;
      else
        v19 = 1;
    }
    else
    {
      if (a5 >= a7)
        v22 = a7;
      else
        v22 = a5;
      if (v22)
      {
        while (1)
        {
          v23 = *a4;
          v24 = *a6;
          if (v23 != v24)
            break;
          ++a4;
          ++a6;
          if (!--v22)
            goto LABEL_30;
        }
        if (v23 < v24)
          v19 = -1;
        else
          v19 = 1;
      }
      else
      {
LABEL_30:
        if (a5 < a7)
          v19 = -1;
        else
          v19 = 1;
        if (a5 == a7)
          v19 = 0;
      }
    }
    *a9 = v19;
    ucol_setAttribute();
    ucol_setAttribute();
    ucol_setAttribute();
  }
  return 0;
}

uint64_t __extendLocationBackward(uint64_t a1, UniChar *buffer, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v8;
  uint64_t i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  UniChar v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  UniChar *v24;
  unsigned __int16 v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  CFRange v32;
  CFRange v33;

  v4 = a1;
  if (a1 >= 1)
  {
    v8 = -a1;
    for (i = a1 + 64; ; --i)
    {
      if ((unint64_t)v4 >= 5)
        v10 = 5;
      else
        v10 = v4;
      if ((unint64_t)v4 >= 4)
        v11 = 4;
      else
        v11 = v4;
      v12 = *((_QWORD *)buffer + 20);
      if (v12 <= v4)
      {
        v14 = 0;
      }
      else
      {
        v13 = *((_QWORD *)buffer + 17);
        if (v13)
        {
          v14 = *(_WORD *)(v13 + 2 * (v4 + *((_QWORD *)buffer + 19)));
        }
        else
        {
          v15 = *((_QWORD *)buffer + 18);
          if (v15)
          {
            v14 = *(char *)(v15 + *((_QWORD *)buffer + 19) + v4);
          }
          else
          {
            if (*((_QWORD *)buffer + 22) <= v4 || (v16 = *((_QWORD *)buffer + 21), v16 > v4))
            {
              v17 = -v11;
              v18 = v11 + v8;
              v19 = i - v11;
              v20 = v4 + v17;
              v21 = v20 + 64;
              if (v20 + 64 >= v12)
                v21 = *((_QWORD *)buffer + 20);
              *((_QWORD *)buffer + 21) = v20;
              *((_QWORD *)buffer + 22) = v21;
              if (v12 >= v19)
                v12 = v19;
              v32.length = v12 + v18;
              v32.location = v20 + *((_QWORD *)buffer + 19);
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v32, buffer);
              v16 = *((_QWORD *)buffer + 21);
            }
            v14 = buffer[v4 - v16];
          }
        }
        if (v14 >> 10 == 55)
        {
          v22 = *((_QWORD *)buffer + 20);
          if (v22 >= v4)
          {
            v23 = *((_QWORD *)buffer + 17);
            if (v23)
            {
              v24 = (UniChar *)(v23 + 2 * (v4 + *((_QWORD *)buffer + 19)));
              goto LABEL_27;
            }
            v26 = *((_QWORD *)buffer + 18);
            if (v26)
            {
              v25 = *(char *)(v26 + *((_QWORD *)buffer + 19) + v4 - 1);
            }
            else
            {
              if (*((_QWORD *)buffer + 22) < v4 || (v28 = *((_QWORD *)buffer + 21), v28 >= v4))
              {
                v29 = v4 - v10;
                v30 = v4 - v10 + 64;
                if (v30 >= v22)
                  v30 = *((_QWORD *)buffer + 20);
                *((_QWORD *)buffer + 21) = v29;
                *((_QWORD *)buffer + 22) = v30;
                if (v22 >= i - v10)
                  v22 = i - v10;
                v33.length = v22 + v10 + v8;
                v33.location = v29 + *((_QWORD *)buffer + 19);
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v33, buffer);
                v28 = *((_QWORD *)buffer + 21);
              }
              v24 = &buffer[v4 - v28];
LABEL_27:
              v25 = *(v24 - 1);
            }
            if (v25 >> 10 == 54)
              return v4;
          }
        }
      }
      if (a3 && ((*(unsigned __int8 *)(a3 + (v14 >> 3)) >> (v14 & 7)) & 1) != 0)
      {
        if ((unsigned __int16)((unsigned __int16)(v14 - 11904) >> 7) < 0xFBu)
          return v4;
      }
      else if (!a4
             || (unsigned __int16)((unsigned __int16)(v14 - 11904) >> 7) < 0xFBu
             || ((1 << (v14 & 7)) & *(unsigned __int8 *)(a4 + (v14 >> 3))) == 0)
      {
        return v4;
      }
      ++v8;
      if (v4-- <= 1)
        return 0;
    }
  }
  return v4;
}

void CFRelease_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** CFRelease() called with NULL ***";
  __break(1u);
}

uint64_t __CFRunLoopSourceEqual(unint64_t *a1, unint64_t *a2)
{
  int v2;
  int v3;
  unint64_t v4;
  uint64_t (*v5)(unint64_t, unint64_t);
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  if (a1 == a2)
    return 1;
  v2 = atomic_load(a1 + 1);
  v3 = atomic_load(a2 + 1);
  if (((v3 ^ v2) & 8) != 0)
    return 0;
  if (a1[10] != a2[10])
    return 0;
  v4 = a1[13];
  if (v4 != a2[13])
    return 0;
  if (a1[19] != a2[19])
    return 0;
  v5 = (uint64_t (*)(unint64_t, unint64_t))a1[18];
  if (v5 != (uint64_t (*)(unint64_t, unint64_t))a2[18])
    return 0;
  if (v4 == 1)
  {
    v7 = a1[21];
    v8 = a2[21];
LABEL_13:
    if (v7 != v8)
      return 0;
    goto LABEL_14;
  }
  if (!v4)
  {
    v7 = a1[22];
    v8 = a2[22];
    goto LABEL_13;
  }
LABEL_14:
  v9 = a1[14];
  v10 = a2[14];
  if (v5)
    return v5(v9, v10);
  else
    return v9 == v10;
}

BOOL __CFisEqualUUIDBytes(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL _cfmp_equal(int *a1, uint64_t a2)
{
  _BOOL8 result;
  int v4;
  int v5;

  if (a1 == (int *)a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    v4 = *a1;
    v5 = *((unsigned __int8 *)a1 + 4);
    return v4 == *(_DWORD *)a2 && v5 == *(unsigned __int8 *)(a2 + 4);
  }
  return result;
}

void CF_IS_OBJC_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"CF objects must have a non-zero isa";
  __break(1u);
}

BOOL __CFCanonicalNameCompare(const char *a1, const char *a2)
{
  return strncasecmp_l(a1, a2, 0x100uLL, 0) == 0;
}

uint64_t __extendLocationForward(int64_t a1, UniChar *buffer, uint64_t a3, uint64_t a4, uint64_t a5, int64_t a6)
{
  int64_t v12;
  uint64_t v13;
  UniChar v14;
  uint64_t v15;
  int64_t v16;
  int64_t v17;
  int64_t v18;
  int64_t v19;
  uint64_t v20;
  UniChar v21;
  uint64_t v22;
  int64_t v23;
  int64_t v24;
  char v25;
  unsigned int v26;
  uint64_t BitmapPtrForPlane;
  uint64_t v28;
  uint64_t v29;
  CFRange v31;
  CFRange v32;

  while (1)
  {
    if (a1 < 0 || (v12 = *((_QWORD *)buffer + 20), v12 <= a1))
    {
      v14 = 0;
      goto LABEL_6;
    }
    v13 = *((_QWORD *)buffer + 17);
    if (v13)
    {
      v14 = *(_WORD *)(v13 + 2 * (*((_QWORD *)buffer + 19) + a1));
    }
    else
    {
      v15 = *((_QWORD *)buffer + 18);
      if (v15)
      {
        v14 = *(char *)(v15 + *((_QWORD *)buffer + 19) + a1);
      }
      else
      {
        if (*((_QWORD *)buffer + 22) <= a1 || (v16 = *((_QWORD *)buffer + 21), v16 > a1))
        {
          v17 = a1 - 4;
          if ((unint64_t)a1 < 4)
            v17 = 0;
          if (v17 + 64 < v12)
            v12 = v17 + 64;
          *((_QWORD *)buffer + 21) = v17;
          *((_QWORD *)buffer + 22) = v12;
          v31.location = *((_QWORD *)buffer + 19) + v17;
          v31.length = v12 - v17;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v31, buffer);
          v16 = *((_QWORD *)buffer + 21);
        }
        v14 = buffer[a1 - v16];
      }
    }
    if (v14 >> 10 == 54)
    {
      v18 = a1 + 1;
      v19 = *((_QWORD *)buffer + 20);
      if (v19 > a1 + 1)
      {
        v20 = *((_QWORD *)buffer + 17);
        if (v20)
        {
          v21 = *(_WORD *)(v20 + 2 * (*((_QWORD *)buffer + 19) + v18));
        }
        else
        {
          v22 = *((_QWORD *)buffer + 18);
          if (v22)
          {
            v21 = *(char *)(v22 + *((_QWORD *)buffer + 19) + v18);
          }
          else
          {
            if (*((_QWORD *)buffer + 22) <= v18 || (v23 = *((_QWORD *)buffer + 21), v23 > v18))
            {
              v24 = a1 - 3;
              if ((unint64_t)a1 < 3)
                v24 = 0;
              if (v24 + 64 < v19)
                v19 = v24 + 64;
              *((_QWORD *)buffer + 21) = v24;
              *((_QWORD *)buffer + 22) = v19;
              v32.location = *((_QWORD *)buffer + 19) + v24;
              v32.length = v19 - v24;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v32, buffer);
              v23 = *((_QWORD *)buffer + 21);
            }
            v21 = buffer[v18 - v23];
          }
        }
        if (v21 >> 10 == 55)
          break;
      }
    }
LABEL_6:
    ++a1;
    if (a3 && ((*(unsigned __int8 *)(a3 + (v14 >> 3)) >> (v14 & 7)) & 1) != 0
      || a4 && ((*(unsigned __int8 *)(a4 + (v14 >> 3)) >> (v14 & 7)) & 1) != 0)
    {
      if ((unsigned __int16)((unsigned __int16)(v14 - 11904) >> 7) < 0xFBu)
        return a1;
    }
    else if (!a5
           || (unsigned __int16)((unsigned __int16)(v14 - 11904) >> 7) < 0xFBu
           || ((1 << (v14 & 7)) & *(unsigned __int8 *)(a5 + (v14 >> 3))) == 0)
    {
      return a1;
    }
LABEL_15:
    if (a1 >= a6)
      return a1;
  }
  v25 = v21;
  v26 = (v14 << 10) + v21 - 56613888;
  a1 += 2;
  BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0xAu, HIWORD(v26));
  if (BitmapPtrForPlane
    && ((*(unsigned __int8 *)(BitmapPtrForPlane + ((unsigned __int16)v26 >> 3)) >> (v25 & 7)) & 1) != 0)
  {
    goto LABEL_15;
  }
  v28 = CFUniCharGetBitmapPtrForPlane(0xBu, HIWORD(v26));
  if (v28)
  {
    if (((*(unsigned __int8 *)(v28 + ((unsigned __int16)v26 >> 3)) >> (v25 & 7)) & 1) != 0)
      goto LABEL_15;
  }
  v29 = CFUniCharGetBitmapPtrForPlane(0x6Cu, HIWORD(v26));
  if (v29)
  {
    if (((*(unsigned __int8 *)(v29 + ((unsigned __int16)v26 >> 3)) >> (v25 & 7)) & 1) != 0)
      goto LABEL_15;
  }
  return a1;
}

BOOL __CFMachPortEqual(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20);
}

void _releaseStringsSource(uint64_t a1, _OWORD *a2)
{
  __int128 v3;
  __int128 v4;
  _OWORD v5[4];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v3 = a2[3];
  v5[2] = a2[2];
  v5[3] = v3;
  v6 = *((_QWORD *)a2 + 8);
  v4 = a2[1];
  v5[0] = *a2;
  v5[1] = v4;
  _CFBundleReleaseStringsSources((uint64_t)v5);
  free(a2);
}

uint64_t _CompareTestEntryToTableEntryKey(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

CFTypeID CFBagGetTypeID(void)
{
  return 4;
}

uint64_t chcompar(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 - *a2;
}

uint64_t _CFStringCheckAndGetCharacterAtIndex(uint64_t a1, uint64_t a2, _WORD *a3)
{
  char v6;
  unsigned __int8 ***v7;
  unsigned __int8 **v8;
  char v9;
  char v10;
  unsigned __int8 **v11;
  char v12;
  char v13;
  unint64_t v14;
  unsigned __int8 *v15;
  uint64_t result;
  __int16 v17;

  if (a2 < 0 && !dyld_program_sdk_at_least())
  {
    v17 = 0;
  }
  else
  {
    v6 = atomic_load((unint64_t *)(a1 + 8));
    v7 = (unsigned __int8 ***)(a1 + 16);
    if ((v6 & 0x60) != 0)
    {
      v8 = *v7;
      if (a2 < 0)
        return 3;
    }
    else
    {
      v9 = atomic_load((unint64_t *)(a1 + 8));
      v8 = (unsigned __int8 **)&v7[(v9 & 5) != 4];
      if (a2 < 0)
        return 3;
    }
    v10 = atomic_load((unint64_t *)(a1 + 8));
    if ((v10 & 5) == 4)
    {
      v11 = (unsigned __int8 **)*(unsigned __int8 *)v8;
    }
    else
    {
      v12 = atomic_load((unint64_t *)(a1 + 8));
      if ((v12 & 0x60) != 0)
        v11 = *(unsigned __int8 ***)(a1 + 24);
      else
        v11 = *v7;
    }
    if ((uint64_t)v11 <= a2)
      return 3;
    v13 = atomic_load((unint64_t *)(a1 + 8));
    if ((v13 & 0x10) != 0)
    {
      v15 = (unsigned __int8 *)v8 + 2 * a2;
    }
    else
    {
      v14 = atomic_load((unint64_t *)(a1 + 8));
      v15 = (unsigned __int8 *)(__CFCharToUniCharTable + 2 * *((unsigned __int8 *)v8 + ((v14 >> 2) & 1) + a2));
    }
    v17 = *(_WORD *)v15;
  }
  result = 0;
  *a3 = v17;
  return result;
}

void sub_182A9E254(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void *_CFCreateArrayStorage(unint64_t a1, int a2, size_t *a3)
{
  size_t v5;
  size_t v6;
  void *result;

  if (a1 >> 61)
    goto LABEL_7;
  v5 = malloc_good_size(8 * a1);
  if (HIDWORD(v5))
    _CFCreateArrayStorage_cold_2();
  v6 = v5;
  result = a2 ? malloc_type_calloc(1uLL, v5, 0xBA4241FuLL) : malloc_type_malloc(v5, 0xB9DF98CuLL);
  *a3 = v6 >> 3;
  if (!result)
LABEL_7:
    _CFCreateArrayStorage_cold_1();
  return result;
}

_QWORD *__NSArrayI_transferNew(void *a1, uint64_t a2)
{
  objc_class *v4;
  _QWORD *v5;
  _QWORD *v6;

  v4 = (objc_class *)objc_opt_self();
  v5 = __CFAllocateObject(v4, 0);
  v6 = v5;
  if (v5)
  {
    v5[1] = a2;
    v5[2] = a1;
  }
  else
  {
    free(a1);
  }
  return v6;
}

void sub_182A9E840(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182A9ED18(_Unwind_Exception *a1)
{
  free(0);
  _Unwind_Resume(a1);
}

uint64_t _NSIsNSArray(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*MethodImplementation)(uint64_t, char *);

  if (a1)
  {
    v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
      return MethodImplementation(v1, sel_isNSArray__);
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }
  return a1 & 1;
}

char *__NSArrayI_new(id *a1, _QWORD *a2, unint64_t a3, char a4)
{
  objc_class *v8;
  char *v9;
  char *v10;
  id *v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  id v16;
  _QWORD *v18;

  v18 = a2;
  v8 = (objc_class *)objc_opt_self();
  v9 = (char *)__CFAllocateObject(v8, 8 * a3);
  v10 = v9;
  if (a3)
  {
    v11 = (id *)(v9 + 16);
    if (a2)
    {
      *v11 = *a1;
      if (a3 >= 2)
      {
        v12 = a3 - 1;
        v13 = v9 + 24;
        do
        {
          v14 = v18++;
          *v13++ = *v14;
          --v12;
        }
        while (v12);
      }
    }
    else if (a1)
    {
      memmove(v9 + 16, a1, 8 * a3);
    }
    if ((a4 & 1) == 0)
    {
      if (a3 <= 1)
        v15 = 1;
      else
        v15 = a3;
      do
      {
        if (((unint64_t)*v11 & 0x8000000000000000) == 0)
          v16 = *v11;
        ++v11;
        --v15;
      }
      while (v15);
    }
    *((_QWORD *)v10 + 1) = a3;
  }
  return v10;
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  int v4;

  v4 = capacity;
  if (callBacks != &kCFTypeArrayCallBacks
    || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
    && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    return (CFMutableArrayRef)__CFArrayCreateMutable0((__objc2_class **)allocator, v4, callBacks);
  }
  if (__FoundationPresent_static_init != -1)
    dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
  if (__FoundationPresent_present)
    return (CFMutableArrayRef)-[NSMutableArray initWithCapacity:]([NSMutableArray alloc], "initWithCapacity:", 0);
  else
    return (CFMutableArrayRef)__CFArrayCreateMutable0((__objc2_class **)allocator, v4, callBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  objc_class **Mutable;
  uint64_t Generic;
  CFIndex v10;

  Mutable = (objc_class **)__NSCFDictionaryCreateMutable((__objc2_class **)allocator, capacity, keyCallBacks, valueCallBacks);
  if (!Mutable)
  {
    Generic = __CFDictionaryCreateGeneric((__objc2_class **)allocator, (uint64_t)keyCallBacks, valueCallBacks);
    Mutable = (objc_class **)Generic;
    if (Generic)
    {
      if (capacity >= 1)
      {
        if (capacity >= 1000)
          v10 = 1000;
        else
          v10 = capacity;
        CFBasicHashSetCapacity(Generic, v10);
      }
      _CFRuntimeSetInstanceTypeIDAndIsa(Mutable, 0x12uLL);
      if (__CFOASafe)
        __CFSetLastAllocationEventName();
    }
  }
  return (CFMutableDictionaryRef)Mutable;
}

_DWORD *__NSCFDictionaryCreateMutable(__objc2_class **a1, unint64_t a2, const CFDictionaryKeyCallBacks *a3, const CFDictionaryValueCallBacks *a4)
{
  unint64_t v8;

  if (__FoundationPresent_static_init_0 != -1)
    dispatch_once(&__FoundationPresent_static_init_0, &__block_literal_global_45);
  if (__FoundationPresent_present_0
    && (&__kCFAllocatorSystemDefault == a1
     || !a1 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault()))
  {
    if (a3 == &kCFTypeDictionaryKeyCallBacks && a4 == &kCFTypeDictionaryValueCallBacks)
    {
      v8 = 0;
      return __NSDictionaryM_new(0, 0, a2, v8);
    }
    if (a3 == &kCFCopyStringDictionaryKeyCallBacks && a4 == &kCFTypeDictionaryValueCallBacks)
    {
      v8 = 3;
      return __NSDictionaryM_new(0, 0, a2, v8);
    }
  }
  return 0;
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  CFAllocatorRef result;

  result = (CFAllocatorRef)_CFGetTSD(1u);
  if (!result)
    return (CFAllocatorRef)&__kCFAllocatorSystemDefault;
  return result;
}

Class _CFRuntimeSetInstanceTypeIDAndIsa(objc_class **a1, unint64_t a2)
{
  Class result;
  objc_class *v5;
  objc_class **v6;
  int v7;
  objc_class *v8;
  uint64_t v9;
  objc_class *v10;

  result = (Class)_CFRuntimeSetInstanceTypeID((uint64_t)a1, a2);
  v5 = *a1;
  if (a2 >= 0x48)
  {
    v7 = a2 - 72;
    if ((int)a2 - 72 >= dword_1ECCFAFE8)
    {
      v8 = 0;
    }
    else
    {
      v8 = (objc_class *)__CFRuntimeClassTables[(v7 >> 6) + 16];
      if (v8)
        v8 = (objc_class *)*((_QWORD *)v8 + (v7 & 0x3F));
    }
    if (v5 != v8)
    {
      if (v7 >= dword_1ECCFAFE8 || (v9 = __CFRuntimeClassTables[(v7 >> 6) + 16]) == 0)
      {
        v10 = 0;
        return object_setClass(a1, v10);
      }
      v6 = (objc_class **)(v9 + 8 * (v7 & 0x3F));
LABEL_13:
      v10 = *v6;
      return object_setClass(a1, v10);
    }
  }
  else
  {
    v6 = (objc_class **)&__CFRuntimeBuiltinObjCClassTable[a2];
    if (v5 != *v6)
      goto LABEL_13;
  }
  return result;
}

uint64_t _CFRuntimeSetInstanceTypeID(uint64_t result, unint64_t a2)
{
  _QWORD **v2;
  int v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  _BYTE **v9;
  unsigned int v10;
  uint64_t v11;
  _BYTE *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;

  if (a2 > 0x47)
  {
    v3 = a2 - 72;
    if ((int)a2 - 72 >= dword_1ECCFAFE8)
      goto LABEL_26;
    v4 = __CFRuntimeClassTables[v3 >> 6];
    if (!v4)
      goto LABEL_26;
    v2 = (_QWORD **)(v4 + 8 * (v3 & 0x3F));
  }
  else
  {
    v2 = (_QWORD **)(&__CFRuntimeBuiltinClassTable + a2);
  }
  v5 = *v2;
  if (*v2)
  {
    v6 = (unint64_t *)(result + 8);
    v7 = atomic_load((unint64_t *)(result + 8));
    v8 = (v7 >> 8) & 0x3FF;
    if (v8 > 0x47)
    {
      v10 = v8 - 72;
      if ((int)v8 - 72 >= dword_1ECCFAFE8 || (v11 = __CFRuntimeClassTables[v10 >> 6]) == 0)
      {
        v12 = 0;
LABEL_14:
        if ((*v12 & 8) != 0 || v8 && (*v5 & 8) != 0)
          return CFLog(3, CFSTR("*** Cannot change the CFTypeID of a %s to a %s due to custom ref counting"));
        v13 = atomic_load(v6);
        while (1)
        {
          v14 = __ldaxr(v6);
          if (v14 != v13)
            break;
          if (__stlxr(v13 & 0xFFFFFFFFFFFC00FFLL | ((unint64_t)a2 << 8), v6))
            goto LABEL_23;
          v15 = 1;
LABEL_24:
          v13 = v14;
          if (v15)
            return result;
        }
        __clrex();
LABEL_23:
        v15 = 0;
        goto LABEL_24;
      }
      v9 = (_BYTE **)(v11 + 8 * (v10 & 0x3F));
    }
    else
    {
      v9 = (_BYTE **)(&__CFRuntimeBuiltinClassTable + v8);
    }
    v12 = *v9;
    goto LABEL_14;
  }
LABEL_26:
  __break(1u);
  return result;
}

__objc2_class **__NSArrayMutablePlaceholder()
{
  return &___mutablePlaceholderArray;
}

__objc2_class **__NSArrayImmutablePlaceholder()
{
  return &___immutablePlaceholderArray;
}

uint64_t __createArray(void *a1, uint64_t a2)
{
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v3[0] = a2;
  return objc_msgSend(a1, "initWithObjects:count:", v3, 1);
}

_QWORD *__NSSingleObjectArrayI_new(uint64_t a1, char a2)
{
  objc_class *v4;
  _QWORD *v5;
  _QWORD *v6;
  id v7;

  v4 = (objc_class *)objc_opt_self();
  v5 = __CFAllocateObject(v4, 0);
  v6 = v5;
  if (v5)
  {
    v5[1] = a1;
    if (a1 >= 1 && (a2 & 1) == 0)
      v7 = (id)a1;
  }
  return v6;
}

_DWORD *__NSDictionaryM_new(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  objc_class *v8;
  _DWORD *v9;
  _DWORD *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  id v24;
  uint64_t v25;
  uint64_t v26;
  id v27;
  _DWORD *result;
  NSException *v29;
  _DWORD *v30;
  uint64_t v31;
  char v33;
  char *v35;

  v33 = a4;
  v5 = 0;
  v6 = 0xFFFFFFFF80000000 * ((a4 >> 1) & 1);
  while (__NSDictionaryCapacities_0[v5] < a3)
  {
    ++v5;
    v6 -= 0x400000000000000;
    if (v5 == 40)
    {
      __break(1u);
      break;
    }
  }
  v7 = __NSDictionarySizes_0[v5];
  v8 = (objc_class *)objc_opt_self();
  v9 = __CFAllocateObject(v8, 0);
  v9[4] = 1;
  *((_QWORD *)v9 + 2) = (*((_QWORD *)v9 + 2) & 0x3FFFFFF7FFFFFFFLL) - v6;
  v30 = v9;
  if (a3)
  {
    v10 = v9;
    v11 = (char *)malloc_type_calloc(1uLL, 16 * v7, 0x8448092BuLL);
    *((_QWORD *)v10 + 1) = v11;
    if (a1 && a2)
    {
      v12 = v11;
      v13 = 0;
      v35 = &v11[8 * v7];
      if ((v7 & 0xFFFFFFFE) != 0)
        v14 = v7;
      else
        v14 = 1;
      v31 = v14;
      do
      {
        v15 = *(void **)(a1 + 8 * v13);
        v16 = objc_msgSend(v15, "hash");
        v17 = v7;
        if (v5 * 8)
        {
          v18 = v16 % v7;
          v19 = v31;
          v17 = v7;
          while (1)
          {
            v20 = *(void **)&v12[8 * v18];
            if (!v20)
              break;
            if (v20 == &___NSDictionaryM_DeletedMarker)
            {
              if (v17 == v7)
                v17 = v18;
            }
            else if (v20 == v15 || (objc_msgSend(v20, "isEqual:", v15) & 1) != 0)
            {
              v17 = v18;
              goto LABEL_29;
            }
            if (v18 + 1 >= v7)
              v21 = v7;
            else
              v21 = 0;
            v18 = v18 + 1 - v21;
            if (!--v19)
              goto LABEL_29;
          }
          if (v17 == v7)
            v17 = v18;
        }
LABEL_29:
        if (*(_QWORD *)&v12[8 * v17])
        {
          v22 = *(_QWORD *)&v35[8 * v17];
          if (v22 >= 1)

        }
        else
        {
          v23 = *(_QWORD *)(a1 + 8 * v13);
          if ((v33 & 1) != 0)
          {
            v25 = objc_msgSend(*(id *)(a1 + 8 * v13), "copyWithZone:", 0);
            *(_QWORD *)&v12[8 * v17] = v25;
            if (!v25)
            {
              CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSDictionary: -copyWithZone: for key %@ returned nil"), v23);
              v29 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
              objc_exception_throw(v29);
            }
          }
          else
          {
            *(_QWORD *)&v12[8 * v17] = v23;
            if (v23 >= 1)
              v24 = (id)v23;
          }
          *((_QWORD *)v30 + 2) = *((_QWORD *)v30 + 2) & 0xFE000000FFFFFFFFLL | ((((unint64_t)(*((_QWORD *)v30 + 2) + 0x100000000) >> 32) & 0x1FFFFFF) << 32);
        }
        v26 = *(_QWORD *)(a2 + 8 * v13);
        *(_QWORD *)&v35[8 * v17] = v26;
        if ((v33 & 4) == 0 && v26 >= 1)
          v27 = (id)v26;
        ++v13;
      }
      while (v13 != a3);
    }
  }
  else
  {
    *((_QWORD *)v9 + 1) = 0;
  }
  result = v30;
  atomic_store(0, (unint64_t *)v30 + 3);
  return result;
}

id __NSArrayM_new(const void *a1, unint64_t a2, char a3)
{
  objc_class *v6;
  id v7;
  unsigned int v8;
  _QWORD *v9;
  uint64_t v10;
  size_t v11;
  size_t v12;
  _QWORD *v13;
  char *v14;
  size_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  id v19;

  v6 = (objc_class *)objc_opt_self();
  v7 = __CFAllocateObject(v6, 0);
  if (v7)
  {
    if (a2)
    {
      if (a2 >> 61)
      {
LABEL_4:

        return 0;
      }
      v10 = 8 * a2;
      v11 = malloc_good_size(8 * a2);
      if (HIDWORD(v11))
        __NSArrayM_new_cold_1();
      v12 = v11;
      if (a1)
      {
        v13 = malloc_type_malloc(v11, 0xB9DF98CuLL);
        if (!v13)
          goto LABEL_4;
        v9 = v13;
        memmove(v13, a1, 8 * a2);
        if ((a3 & 1) != 0)
        {
          v14 = (char *)&v9[a2];
          v15 = v12 - v10;
        }
        else
        {
          v17 = 0;
          do
          {
            v18 = v9[v17];
            if ((v18 & 0x8000000000000000) == 0)
              v19 = (id)v18;
            ++v17;
          }
          while (a2 != v17);
          v14 = (char *)&v9[a2];
          v15 = v12 - v10;
        }
        bzero(v14, v15);
        v8 = v12 >> 3;
      }
      else
      {
        v16 = malloc_type_calloc(1uLL, v11, 0xBA4241FuLL);
        if (!v16)
          goto LABEL_4;
        v9 = v16;
        LODWORD(a2) = 0;
        v8 = v12 >> 3;
      }
    }
    else
    {
      v8 = 0;
      v9 = 0;
    }
    *((_QWORD *)v7 + 2) = v9;
    *((_DWORD *)v7 + 6) = 0;
    *((_DWORD *)v7 + 7) = v8;
    *((_DWORD *)v7 + 8) = 1;
    *((_DWORD *)v7 + 9) = a2;
  }
  return v7;
}

id __CFAllocateObject(objc_class *a1, size_t a2)
{
  id Instance;
  id v3;

  Instance = class_createInstance(a1, a2);
  if (!Instance)
    objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSMallocException"), CFSTR("*** NSAllocateObject(): attempt to allocate object failed"), 0));
  v3 = Instance;
  if (__CFOASafe)
  {
    object_getClassName(Instance);
    __CFSetLastAllocationEventName();
  }
  return v3;
}

uint64_t _CFPredicatePolicyData_getFlags()
{
  return _cfprediacateelements_flags;
}

uint64_t __CFDictionaryCreateGeneric(__objc2_class **a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12[5];
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 8);
    v4 = *(_QWORD *)(a2 + 16);
    v5 = *(_OWORD *)(a2 + 32);
    v6 = *(_QWORD *)(a2 + 24);
  }
  else
  {
    v3 = 0;
    v4 = 0;
    v6 = 0;
    v5 = 0uLL;
  }
  v12[1] = v3;
  v12[3] = v4;
  v13 = v5;
  v14 = 0;
  v16 = v6;
  if (a3)
  {
    v7 = a3[1];
    v8 = a3[2];
    v10 = a3[3];
    v9 = a3[4];
  }
  else
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
  }
  v12[0] = v7;
  v12[2] = v8;
  v12[4] = v9;
  v15 = v10;
  return CFBasicHashCreate(a1, 0x2001u, v12);
}

uint64_t CFBasicHashCreate(__objc2_class **a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  int v9;
  int v10;
  char v11;

  v5 = 40;
  if ((a2 & 1) == 0)
    v5 = 32;
  if ((a2 & 2) != 0)
    v5 += 8;
  if ((a2 & 4) != 0)
    v6 = v5 + 8;
  else
    v6 = v5;
  result = _CFRuntimeCreateInstance(a1, 3uLL, v6, 0);
  v8 = result;
  if (!result)
    return v8;
  v9 = *(_WORD *)(result + 18) & 0xFFFC | (a2 >> 13) & 3;
  *(_WORD *)(result + 18) = *(_WORD *)(result + 18) & 0xFFFC | (a2 >> 13) & 3;
  if ((a2 & 0x8000) != 0)
    *(_QWORD *)(result + 32) |= 4uLL;
  v10 = ((_WORD)a2 << 7) & 0x6000 | (((a2 >> 8) & 0xF) << 9) & 0x7FFF | (a2 >> 12 << 15) | v9;
  if ((a2 & 0x1FC0) != 0)
    *(_WORD *)(result + 18) = v10;
  *(_WORD *)(result + 16) = 1;
  if ((~v10 & 0xA00) != 0
    && (~v10 & 0x2200) != 0
    && (~v10 & 0x1400) != 0
    && (~v10 & 0x4400) != 0
    && (~v10 & 0x2800) != 0
    && (~v10 & 0x5000) != 0
    && (~v10 & 0x8400) != 0
    && (~v10 & 0x9000) != 0
    && (unsigned __int16)v10 < 0xC000u)
  {
    if ((a2 & 1) != 0)
    {
      LOWORD(v10) = v10 | 4;
      *(_WORD *)(result + 18) = v10;
      v11 = 2;
      if ((a2 & 2) == 0)
      {
LABEL_27:
        if ((a2 & 4) != 0)
          *(_WORD *)(result + 18) = v10 & 0xFE7F | ((v11 & 3) << 7);
        *(_QWORD *)(result + 24) = *(_QWORD *)(result + 24) & 0xFFFFFFFC00FFFFFFLL | ((CFBasicHashGetPtrIndex(a3[1]) & 0x3FF) << 24);
        *(_QWORD *)(v8 + 24) = *(_QWORD *)(v8 + 24) & 0xFFFFF003FFFFFFFFLL | ((CFBasicHashGetPtrIndex(*a3) & 0x3FF) << 34);
        *(_QWORD *)(v8 + 24) = *(_QWORD *)(v8 + 24) & 0xFFC00FFFFFFFFFFFLL | ((CFBasicHashGetPtrIndex(a3[3]) & 0x3FF) << 44);
        *(_QWORD *)(v8 + 24) = *(_QWORD *)(v8 + 24) & 0x3FFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)CFBasicHashGetPtrIndex(a3[2]) << 54);
        *(_QWORD *)(v8 + 32) = *(_QWORD *)(v8 + 32) & 0xFFFFFFFFFFFFC00FLL | (16
                                                                            * (CFBasicHashGetPtrIndex(a3[9]) & 0x3FF));
        *(_QWORD *)(v8 + 32) = *(_QWORD *)(v8 + 32) & 0xFFFFFFFFFF003FFFLL | ((CFBasicHashGetPtrIndex(a3[8]) & 0x3FF) << 14);
        *(_QWORD *)(v8 + 32) = *(_QWORD *)(v8 + 32) & 0xFFFFFFFC00FFFFFFLL | ((CFBasicHashGetPtrIndex(a3[5]) & 0x3FF) << 24);
        *(_QWORD *)(v8 + 32) = *(_QWORD *)(v8 + 32) & 0xFFFFF003FFFFFFFFLL | ((CFBasicHashGetPtrIndex(a3[4]) & 0x3FF) << 34);
        *(_QWORD *)(v8 + 32) = *(_QWORD *)(v8 + 32) & 0xFFC00FFFFFFFFFFFLL | ((CFBasicHashGetPtrIndex(a3[6]) & 0x3FF) << 44);
        *(_QWORD *)(v8 + 32) = *(_QWORD *)(v8 + 32) & 0x3FFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)CFBasicHashGetPtrIndex(a3[7]) << 54);
        return v8;
      }
    }
    else
    {
      v11 = 1;
      if ((a2 & 2) == 0)
        goto LABEL_27;
    }
    LOWORD(v10) = v10 & 0xFFE7 | (8 * (v11++ & 3));
    *(_WORD *)(result + 18) = v10;
    goto LABEL_27;
  }
  __break(1u);
  return result;
}

uint64_t CFBasicHashGetPtrIndex(uint64_t a1)
{
  uint64_t result;
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  void *v9;
  signed int v10;

  if (CFBasicHashGetPtrIndex_once != -1)
    dispatch_once(&CFBasicHashGetPtrIndex_once, &__block_literal_global_35);
  result = os_unfair_lock_lock_with_options();
  v3 = atomic_load(&CFBasicHashCallBackPtrsCount);
  if (v3 >= 1)
  {
    v4 = 0;
    while (*(_QWORD *)(CFBasicHashCallBackPtrs[v4 >> 5] + 8 * (v4 & 0x1F)) != a1)
    {
      v4 = (v4 + 1);
      v5 = atomic_load(&CFBasicHashCallBackPtrsCount);
      if ((int)v4 >= v5)
        goto LABEL_7;
    }
    goto LABEL_13;
  }
LABEL_7:
  v6 = atomic_load(&CFBasicHashCallBackPtrsCount);
  if (v6 < 1024)
  {
    v7 = atomic_load(&CFBasicHashCallBackPtrsCount);
    v8 = atomic_load(&CFBasicHashCallBackPtrsCapacity);
    if (v7 == v8)
    {
      v9 = malloc_type_malloc(0x100uLL, 0x80040B8603338uLL);
      v10 = atomic_load(&CFBasicHashCallBackPtrsCount);
      CFBasicHashCallBackPtrs[v10 / 32] = (uint64_t)v9;
      do
        v7 = __ldaxr(&CFBasicHashCallBackPtrsCapacity);
      while (__stlxr(v7 + 32, &CFBasicHashCallBackPtrsCapacity));
    }
    do
      v4 = __ldaxr(&CFBasicHashCallBackPtrsCount);
    while (__stlxr(v4 + 1, &CFBasicHashCallBackPtrsCount));
    *(_QWORD *)(CFBasicHashCallBackPtrs[(int)v4 / 32] + 8 * (int)(v4 - (v7 & 0xFFFFFFE0))) = a1;
LABEL_13:
    os_unfair_lock_unlock((os_unfair_lock_t)&CFBasicHashCallBackPtrsLock);
    return v4;
  }
  __break(1u);
  return result;
}

__objc2_class **__NSDictionaryMutablePlaceholder()
{
  return &___mutablePlaceholderDictionary;
}

__objc2_class **__NSDictionaryImmutablePlaceholder()
{
  return &___immutablePlaceholderDictionary;
}

_QWORD *__NSSingleEntryDictionaryI_new(unint64_t a1, unint64_t a2, char a3)
{
  objc_class *v6;
  _QWORD *v7;
  id v8;
  uint64_t v9;
  id v10;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  NSException *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  NSException *v21;
  NSException *v22;
  _QWORD v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v12 = _os_log_pack_size();
    v14 = (char *)v23 - ((MEMORY[0x1E0C80A78](v12, v13) + 15) & 0xFFFFFFFFFFFFFFF0);
    v15 = _os_log_pack_fill();
    *(_DWORD *)v15 = 136315138;
    *(_QWORD *)(v15 + 4) = "__NSSingleEntryDictionaryI_new";
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** %s: key cannot be nil"), "__NSSingleEntryDictionaryI_new");
    v16 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:](NSException, "exceptionWithName:reason:userInfo:osLogPack:size:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0, v14, v12);
    objc_exception_throw(v16);
  }
  if (!a2)
  {
    v17 = _os_log_pack_size();
    v19 = (char *)v23 - ((MEMORY[0x1E0C80A78](v17, v18) + 15) & 0xFFFFFFFFFFFFFFF0);
    v20 = _os_log_pack_fill();
    *(_DWORD *)v20 = 136315138;
    *(_QWORD *)(v20 + 4) = "__NSSingleEntryDictionaryI_new";
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** %s: object cannot be nil"), "__NSSingleEntryDictionaryI_new");
    v21 = +[NSException exceptionWithName:reason:userInfo:osLogPack:size:](NSException, "exceptionWithName:reason:userInfo:osLogPack:size:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0, v19, v17);
    objc_exception_throw(v21);
  }
  v6 = (objc_class *)objc_opt_self();
  v7 = __CFAllocateObject(v6, 0);
  if (v7)
  {
    if ((a3 & 1) != 0)
    {
      v9 = objc_msgSend((id)a1, "copyWithZone:", 0);
      v7[2] = v9;
      if (!v9)
      {
        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSDictionary: -copyWithZone: for key %@ returned nil"), a1);
        v22 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
        objc_exception_throw(v22);
      }
    }
    else
    {
      if ((a3 & 8) == 0 && (a1 & 0x8000000000000000) == 0)
        v8 = (id)a1;
      v7[2] = a1;
    }
    v7[1] = a2;
    if ((a2 & 0x8000000000000000) == 0 && (a3 & 4) == 0)
      v10 = (id)a2;
  }
  return v7;
}

void sub_182AA1C00(_Unwind_Exception *exception_object, int a2)
{
  uint64_t v2;

  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    if (v2 >= 1)

    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_182AA1C40()
{
  objc_end_catch();
  JUMPOUT(0x182AA1C48);
}

void sub_182AA2318(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

unint64_t CFLog(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  return _CFLogvEx3(0, 0, 0, 0, a1, a2, &a9);
}

CFLocaleRef CFLocaleGetSystem(void)
{
  return (CFLocaleRef)+[NSLocale _system](NSLocale, "_system");
}

uint64_t __CFBinaryPlistWriteOrPresize(const void *a1, const void *a2, uint64_t a3, uint64_t a4, int a5, _QWORD *a6)
{
  objc_class **v9;
  const __CFArray *v10;
  const __CFSet *v11;
  CFIndex Count;
  unint64_t *Typed;
  int *v14;
  CFTypeID v15;
  BOOL v16;
  unsigned __int8 v17;
  uint64_t v18;
  unsigned int v19;
  BOOL v20;
  CFIndex v21;
  const void *ValueAtIndex;
  unint64_t v23;
  unsigned __int8 v24;
  uint64_t v25;
  unsigned int v26;
  unint64_t *v28;
  CFIndex v29;
  unint64_t v30;
  const void *v31;
  uint64_t v32;
  const void *v33;
  unint64_t v36;
  CFSetCallBacks v37;
  CFArrayCallBacks callBacks;
  _OWORD v39[5];
  __int128 __src;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  __src = 0u;
  v41 = 0u;
  memset(v39, 0, sizeof(v39));
  v9 = (objc_class **)CFBasicHashCreate(&__kCFAllocatorSystemDefault, 0xA001u, (uint64_t *)v39);
  _CFRuntimeSetInstanceTypeIDAndIsa(v9, 0x12uLL);
  *(_OWORD *)&callBacks.version = xmmword_1E12E0F00;
  *(_OWORD *)&callBacks.release = *(_OWORD *)&off_1E12E0F10;
  callBacks.equal = 0;
  v10 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &callBacks);
  v37 = *(CFSetCallBacks *)byte_1E12E0F28;
  v11 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &v37);
  _flattenPlist(a1, v10, (__CFDictionary *)v9, v11);
  CFRelease(v11);
  Count = CFArrayGetCount(v10);
  Typed = (unint64_t *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 557344345, 0);
  v14 = (int *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8208, 0x10E0040DB85EAC6, 0);
  *(_QWORD *)v14 = a2;
  *((_QWORD *)v14 + 1) = 0;
  *((_QWORD *)v14 + 2) = 0;
  *((_QWORD *)v14 + 3) = 0;
  if (a2)
  {
    v15 = CFGetTypeID(a2);
    v16 = v15 == CFDataGetTypeID();
  }
  else
  {
    v16 = 1;
  }
  *((_BYTE *)v14 + 44) = v16;
  *((_QWORD *)v14 + 4) = 0;
  v14[10] = 0;
  bufferWrite((uint64_t)v14, "bplist00", 8, a5);
  *(_QWORD *)&__src = 0;
  *((_QWORD *)&__src + 1) = bswap64(Count);
  *(_QWORD *)&v41 = 0;
  v17 = 0;
  if (!Count)
    goto LABEL_12;
  v18 = -1;
  do
  {
    ++v17;
    v20 = (Count & (v18 << 8)) == 0;
    v18 <<= 8;
  }
  while (!v20);
  if (v17 <= 7u)
  {
LABEL_12:
    while (1)
    {
      v19 = v17;
      v20 = v17 > 4u || ((1 << v17) & 0x16) == 0;
      if (!v20)
        break;
      ++v17;
      if (v19 >= 7)
      {
        v17 = 8;
        break;
      }
    }
  }
  BYTE7(__src) = v17;
  if (Count < 1)
  {
LABEL_20:
    CFRelease(v9);
    CFRelease(v10);
    v23 = *((_QWORD *)v14 + 4) + v14[10];
    *((_QWORD *)&v41 + 1) = bswap64(v23);
    v24 = 0;
    if (!v23)
      goto LABEL_28;
    v25 = -1;
    do
    {
      ++v24;
      v20 = (v23 & (v25 << 8)) == 0;
      v25 <<= 8;
    }
    while (!v20);
    if (v24 <= 7u)
    {
LABEL_28:
      while (1)
      {
        v26 = v24;
        if (v24 <= 4u && ((1 << v24) & 0x16) != 0)
          break;
        ++v24;
        if (v26 >= 7)
        {
          v24 = 8;
          break;
        }
      }
    }
    BYTE6(__src) = v24;
    if (Count >= 1)
    {
      v28 = Typed;
      v29 = Count;
      do
      {
        v30 = *v28++;
        v36 = bswap64(v30);
        bufferWrite((uint64_t)v14, (_BYTE *)&v36 - v24 + 8, v24, a5);
        --v29;
      }
      while (v29);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    bufferWrite((uint64_t)v14, &__src, 32, a5);
    writeBytes((uint64_t)v14, (const UInt8 *)v14 + 45, v14[10], a5);
    v14[10] = 0;
    v31 = (const void *)*((_QWORD *)v14 + 3);
    if (v31)
    {
      if (a6)
      {
        v32 = 0;
        *a6 = v31;
      }
      else
      {
        CFRelease(v31);
        v32 = 0;
      }
    }
    else
    {
      v32 = v23 + Count * v24 + 32;
    }
    Typed = (unint64_t *)v14;
  }
  else
  {
    v21 = 0;
    while (1)
    {
      Typed[v21] = *((_QWORD *)v14 + 4) + v14[10];
      ValueAtIndex = CFArrayGetValueAtIndex(v10, v21);
      if (!_appendObject((uint64_t)v14, (uint64_t)ValueAtIndex))
        break;
      if (Count == ++v21)
        goto LABEL_20;
    }
    CFRelease(v9);
    CFRelease(v10);
    v33 = (const void *)*((_QWORD *)v14 + 3);
    if (a6)
    {
      if (v33)
        *a6 = v33;
    }
    else if (v33)
    {
      CFRelease(v33);
    }
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14);
    v32 = 0;
  }
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  return v32;
}

uint64_t _CFArrayCheckAndGetValueAtIndex(unint64_t *a1, int64_t a2, _BYTE *a3)
{
  char v3;
  uint64_t v4;
  char v6;
  BOOL v7;
  uint64_t v8;

  if (a2 < 0 || (uint64_t)a1[2] <= a2)
  {
    if (a3)
      *a3 = 1;
    return -1;
  }
  else
  {
    atomic_load(a1 + 1);
    v3 = atomic_load(a1 + 1);
    if ((v3 & 3) != 0)
    {
      v4 = a1[5] + 8 * *(_QWORD *)a1[5] + 16;
    }
    else
    {
      v6 = atomic_load(a1 + 1);
      v7 = (~v6 & 0xC) == 0;
      v8 = 6;
      if (v7)
        v8 = 11;
      v4 = (uint64_t)&a1[v8];
    }
    return *(_QWORD *)(v4 + 8 * a2);
  }
}

uint64_t _appendObject(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFDate *v9;
  const __CFDate *v10;
  uint64_t v11;
  int64_t v12;
  uint64_t v13;
  CFIndex Count;
  int64_t v15;
  char v16;
  void **Typed;
  void **v18;
  uint64_t v19;
  int64_t v20;
  CFIndex v21;
  uint64_t v22;
  char v23;
  CFIndex Length;
  int64_t v25;
  char v26;
  int8x16_t *BytePtr;
  uint64_t v28;
  int64_t v29;
  char v30;
  void **p_src;
  char v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const void *v39;
  uint64_t v40;
  const void *v41;
  int8x16_t v43;
  unsigned int __src;
  unint64_t valuePtr;
  void *keys[2];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;
  CFRange v79;
  CFRange v80;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v11 = v2;
  v78 = *MEMORY[0x1E0C80C00];
  v12 = CFGetTypeID(v9);
  v13 = 0;
  if (v12 > 40)
  {
    if (v12 == 41)
    {
      v34 = _CFKeyedArchiverUIDGetValue((uint64_t)v10);
      v35 = 4;
      if (v34 < 0x10000)
        v35 = 2;
      if (v34 < 0x100)
        v36 = 1;
      else
        v36 = v35;
      v43.i8[0] = (v36 - 1) | 0x80;
      keys[0] = (void *)bswap64(v34);
      v13 = 1;
      bufferWrite(v11, &v43, 1, v4);
      v19 = v11;
      v18 = (void **)((char *)&keys[1] - v36);
      v20 = v36;
    }
    else
    {
      if (v12 != 42)
        return v13;
      v43.i8[0] = 51;
      v13 = 1;
      bufferWrite(v11, &v43, 1, v4);
      keys[0] = (void *)bswap64(COERCE_UNSIGNED_INT64(CFDateGetAbsoluteTime(v10)));
      v18 = keys;
      v19 = v11;
      v20 = 8;
    }
    bufferWrite(v19, v18, v20, v4);
    return v13;
  }
  switch(v12)
  {
    case 18:
      Count = CFDictionaryGetCount(v10);
      v15 = Count;
      v16 = 15;
      if (Count < 15)
        v16 = Count;
      LOBYTE(valuePtr) = v16 | 0xD0;
      bufferWrite(v11, &valuePtr, 1, v4);
      if (v15 < 15)
      {
        v76 = 0u;
        v77 = 0u;
        v74 = 0u;
        v75 = 0u;
        v72 = 0u;
        v73 = 0u;
        v70 = 0u;
        v71 = 0u;
        v68 = 0u;
        v69 = 0u;
        v66 = 0u;
        v67 = 0u;
        v64 = 0u;
        v65 = 0u;
        v62 = 0u;
        v63 = 0u;
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v52 = 0u;
        v53 = 0u;
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        Typed = keys;
        *(_OWORD *)keys = 0u;
        v47 = 0u;
        CFDictionaryGetKeysAndValues(v10, (const void **)keys, (const void **)&keys[v15]);
        if (v15 < 1)
          goto LABEL_69;
      }
      else
      {
        _appendInt(v11, v15, v4);
        v76 = 0u;
        v77 = 0u;
        v74 = 0u;
        v75 = 0u;
        v72 = 0u;
        v73 = 0u;
        v70 = 0u;
        v71 = 0u;
        v68 = 0u;
        v69 = 0u;
        v66 = 0u;
        v67 = 0u;
        v64 = 0u;
        v65 = 0u;
        v62 = 0u;
        v63 = 0u;
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v52 = 0u;
        v53 = 0u;
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        *(_OWORD *)keys = 0u;
        v47 = 0u;
        if ((unint64_t)v15 >= 0x101)
          Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 16 * v15, 0xC0040B8AA526DLL, 0);
        else
          Typed = keys;
        CFDictionaryGetKeysAndValues(v10, (const void **)Typed, (const void **)&Typed[v15]);
      }
      v37 = 0;
      if (2 * v15 <= 1)
        v38 = 1;
      else
        v38 = 2 * v15;
      do
      {
        v39 = Typed[v37];
        if (v8)
        {
          v43.i32[0] = 0;
          v43.i32[0] = bswap32(CFDictionaryGetValue(v8, v39));
          bufferWrite(v11, &v43.i8[-v6 + 4], v6, v4);
        }
        else if (!_appendObject(v11, v39, 0, v6, v4))
        {
          goto LABEL_65;
        }
        ++v37;
      }
      while (v38 != v37);
      goto LABEL_63;
    case 19:
      v21 = CFArrayGetCount(v10);
      v22 = v21;
      v76 = 0u;
      v77 = 0u;
      v74 = 0u;
      v75 = 0u;
      v72 = 0u;
      v73 = 0u;
      v70 = 0u;
      v71 = 0u;
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      v64 = 0u;
      v65 = 0u;
      v62 = 0u;
      v63 = 0u;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v54 = 0u;
      v55 = 0u;
      v52 = 0u;
      v53 = 0u;
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      v23 = 15;
      *(_OWORD *)keys = 0u;
      v47 = 0u;
      if (v21 < 15)
        v23 = v21;
      LOBYTE(valuePtr) = v23 | 0xA0;
      bufferWrite(v11, &valuePtr, 1, v4);
      if (v22 < 15)
      {
        Typed = keys;
        v79.location = 0;
        v79.length = v22;
        CFArrayGetValues(v10, v79, (const void **)keys);
        if (v22 < 1)
          goto LABEL_69;
      }
      else
      {
        _appendInt(v11, v22, v4);
        if ((unint64_t)v22 >= 0x101)
          Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v22, 0xC0040B8AA526DLL, 0);
        else
          Typed = keys;
        v80.location = 0;
        v80.length = v22;
        CFArrayGetValues(v10, v80, (const void **)Typed);
      }
      v40 = 0;
      while (2)
      {
        v41 = Typed[v40];
        if (v8)
        {
          v43.i32[0] = 0;
          v43.i32[0] = bswap32(CFDictionaryGetValue(v8, v41));
          bufferWrite(v11, &v43.i8[-v6 + 4], v6, v4);
          goto LABEL_62;
        }
        if (_appendObject(v11, v41, 0, v6, v4))
        {
LABEL_62:
          if (v22 == ++v40)
          {
LABEL_63:
            if (Typed != keys)
              CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
            goto LABEL_69;
          }
          continue;
        }
        break;
      }
LABEL_65:
      if (Typed != keys)
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
      return 0;
    case 20:
      Length = CFDataGetLength(v10);
      v25 = Length;
      v26 = 15;
      if (Length < 15)
        v26 = Length;
      LOBYTE(keys[0]) = v26 | 0x40;
      bufferWrite(v11, keys, 1, v4);
      if (v25 >= 15)
        _appendInt(v11, v25, v4);
      BytePtr = (int8x16_t *)CFDataGetBytePtr(v10);
      v28 = v11;
      v29 = v25;
      goto LABEL_45;
    case 21:
      if (CFBooleanGetValue(v10))
        v30 = 9;
      else
        v30 = 8;
      LOBYTE(keys[0]) = v30;
      v13 = 1;
      bufferWrite(v11, keys, 1, v4);
      return v13;
    case 22:
      valuePtr = 0;
      if (CFNumberIsFloatType(v10))
      {
        keys[0] = 0;
        __src = 0;
        if (CFNumberGetByteSize(v10) > 4)
        {
          v43.i64[0] = 0;
          CFNumberGetValue(v10, kCFNumberFloat64Type, &v43);
          keys[0] = (void *)bswap64(v43.u64[0]);
          p_src = keys;
          v32 = 35;
          v33 = 8;
        }
        else
        {
          v43.i32[0] = 0;
          CFNumberGetValue(v10, kCFNumberFloat32Type, &v43);
          __src = bswap32(v43.u32[0]);
          p_src = (void **)&__src;
          v32 = 34;
          v33 = 4;
        }
        v43.i8[0] = v32;
        bufferWrite(v11, &v43, 1, v4);
        v28 = v11;
        BytePtr = (int8x16_t *)p_src;
        v29 = v33;
        goto LABEL_45;
      }
      if (_CFNumberGetType2((unint64_t *)v10) == 17)
      {
        keys[0] = 0;
        keys[1] = 0;
        CFNumberGetValue(v10, kCFNumberMaxType|kCFNumberSInt8Type, keys);
        v43 = vrev64q_s8(*(int8x16_t *)keys);
        LOBYTE(__src) = 20;
        bufferWrite(v11, &__src, 1, v4);
        BytePtr = &v43;
        v28 = v11;
        v29 = 16;
LABEL_45:
        bufferWrite(v28, BytePtr, v29, v4);
        goto LABEL_69;
      }
      CFNumberGetValue(v10, kCFNumberSInt64Type, &valuePtr);
      _appendInt(v11, valuePtr, v4);
LABEL_69:
      v13 = 1;
      break;
    default:
      if (v12 != 7)
        return v13;
      _appendString(v11, (CFStringRef)v10, v4);
      goto LABEL_69;
  }
  return v13;
}

void bufferWrite(uint64_t a1, _BYTE *__src, int64_t a3, int a4)
{
  int v8;
  size_t v9;
  uint64_t v10;
  int v11;

  if (a3)
  {
    if (a3 < 8160)
    {
      v8 = *(_DWORD *)(a1 + 40);
      if (8160 - v8 >= a3)
        v9 = a3;
      else
        v9 = 8160 - v8;
      if (!a4 && (*(_QWORD *)a1 || *(_QWORD *)(a1 + 8)))
      {
        v10 = v8;
        switch(v9)
        {
          case 1uLL:
            goto LABEL_14;
          case 2uLL:
            goto LABEL_13;
          case 3uLL:
            goto LABEL_12;
          case 4uLL:
            *(_BYTE *)(v8 + a1 + 48) = __src[3];
            v8 = *(_DWORD *)(a1 + 40);
LABEL_12:
            *(_BYTE *)(a1 + v8 + 47) = __src[2];
            v8 = *(_DWORD *)(a1 + 40);
LABEL_13:
            *(_BYTE *)(a1 + v8 + 46) = __src[1];
            v10 = *(int *)(a1 + 40);
LABEL_14:
            *(_BYTE *)(a1 + v10 + 45) = *__src;
            break;
          default:
            memmove((void *)(a1 + v8 + 45), __src, v9);
            break;
        }
      }
      v11 = *(_DWORD *)(a1 + 40) + v9;
      *(_DWORD *)(a1 + 40) = v11;
      if (v11 == 8160)
      {
        writeBytes(a1, (const UInt8 *)(a1 + 45), 8160, a4);
        if (!a4 && (*(_QWORD *)a1 || *(_QWORD *)(a1 + 8)))
          memmove((void *)(a1 + 45), &__src[v9], a3 - v9);
        *(_DWORD *)(a1 + 40) = a3 - v9;
      }
    }
    else
    {
      writeBytes(a1, (const UInt8 *)(a1 + 45), *(int *)(a1 + 40), a4);
      *(_DWORD *)(a1 + 40) = 0;
      writeBytes(a1, __src, a3, a4);
    }
  }
}

void _flattenPlist(const void *a1, const __CFArray *a2, __CFDictionary *a3, const __CFSet *a4)
{
  CFTypeID v8;
  CFTypeID v9;
  CFIndex v10;
  const void *Value;
  unsigned int v12;
  unsigned int Count;
  CFIndex v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  const void **v18;
  size_t v19;
  const void **Typed;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  const void **v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t i;
  _QWORD v30[2];
  CFRange v31;
  CFRange v32;

  v30[1] = *MEMORY[0x1E0C80C00];
  v8 = CFGetTypeID(a1);
  v9 = v8;
  if (v8 > 0x2A
    || ((1 << v8) & 0x40000500080) == 0
    || (v10 = CFSetGetCount(a4), CFSetAddValue(a4, a1), CFSetGetCount(a4) != v10))
  {
    Count = CFArrayGetCount(a2);
    CFArrayAppendValue(a2, a1);
    CFDictionaryAddValue(a3, a1, (const void *)Count);
    if (v9 != 19)
    {
      if (v9 != 18)
        return;
      v14 = CFDictionaryGetCount((CFDictionaryRef)a1);
      MEMORY[0x1E0C80A78](v14, v15);
      v18 = (const void **)((char *)v30 - v17);
      if (v16 >= 0x200)
        v19 = 512;
      else
        v19 = v16;
      bzero((char *)v30 - v17, v19);
      if (v14 >= 129)
      {
        Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 16 * v14, 0xC0040B8AA526DLL, 0);
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, Typed, &Typed[v14]);
      }
      else
      {
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v18, &v18[v14]);
        Typed = v18;
        if (v14 < 1)
          goto LABEL_25;
      }
      v27 = 0;
      if (2 * v14 <= 1)
        v28 = 1;
      else
        v28 = 2 * v14;
      do
        _flattenPlist(Typed[v27++], a2, a3, a4);
      while (v28 != v27);
LABEL_25:
      if (Typed == v18)
        return;
LABEL_31:
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
      return;
    }
    v21 = CFArrayGetCount((CFArrayRef)a1);
    MEMORY[0x1E0C80A78](v21, v22);
    v25 = (const void **)((char *)v30 - v24);
    if (v23 >= 0x200)
      v26 = 512;
    else
      v26 = v23;
    bzero((char *)v30 - v24, v26);
    if (v21 >= 257)
    {
      Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v21, 0xC0040B8AA526DLL, 0);
      v32.location = 0;
      v32.length = v21;
      CFArrayGetValues((CFArrayRef)a1, v32, Typed);
    }
    else
    {
      v31.location = 0;
      v31.length = v21;
      CFArrayGetValues((CFArrayRef)a1, v31, v25);
      Typed = v25;
      if (v21 < 1)
        goto LABEL_30;
    }
    for (i = 0; i != v21; ++i)
      _flattenPlist(Typed[i], a2, a3, a4);
LABEL_30:
    if (Typed == v25)
      return;
    goto LABEL_31;
  }
  Value = CFSetGetValue(a4, a1);
  if (Value != a1)
  {
    v12 = CFDictionaryGetValue(a3, Value);
    CFDictionaryAddValue(a3, a1, (const void *)v12);
  }
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  CFTypeID result;
  unint64_t v9;
  unint64_t v10;

  if (((unint64_t)cf & 0x8000000000000000) != 0)
  {
    v2 = 0;
    v3 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)cf & 0xC000000000000007) == 0)
      v3 = 0;
    v4 = v3 ^ (unint64_t)cf;
    do
    {
      if ((v4 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v2))
        break;
      ++v2;
    }
    while (v2 != 7);
    v5 = v2 | v4;
    v6 = v2 & 7;
    v7 = (v5 >> 55) + 8;
    if (v6 == 7)
      LODWORD(v6) = v7;
    result = 22;
    switch((int)v6)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          CFGetTypeID_cold_1();
        goto LABEL_18;
      case 1:
        return objc_msgSend((id)cf, "_cfTypeID");
      case 2:
        goto LABEL_17;
      case 3:
        return result;
      case 4:
      case 5:
        goto LABEL_18;
      case 6:
        return 42;
      default:
        if ((_DWORD)v6 == 20)
        {
LABEL_18:
          result = 1;
        }
        else
        {
          if ((_DWORD)v6 != 22)
            return objc_msgSend((id)cf, "_cfTypeID");
LABEL_17:
          result = 7;
        }
        break;
    }
  }
  else
  {
    v9 = atomic_load((unint64_t *)cf + 1);
    if (CF_IS_OBJC((v9 >> 8) & 0x3FF, (__objc2_class **)cf))
    {
      return objc_msgSend((id)cf, "_cfTypeID");
    }
    else
    {
      v10 = atomic_load((unint64_t *)cf + 1);
      return (v10 >> 8) & 0x3FF;
    }
  }
  return result;
}

uint64_t CFBasicHashGetCount(uint64_t a1)
{
  unsigned int v1;

  v1 = *(unsigned __int16 *)(a1 + 18);
  if ((v1 & 0x18) == 0)
    return *(unsigned int *)(a1 + 20);
  if ((uint64_t)__CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)] < 1)
    return 0;
  return ((uint64_t (*)(_QWORD))((char *)&loc_182AA3708 + 4 * byte_182DC75BC[(v1 >> 5) & 3]))(0);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
    return -[__CFArray count](theArray, "count");
  else
    return *((_QWORD *)theArray + 2);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  char v6;
  char v7;
  const char *v8;
  char v9;
  const char *v10;
  const char *v11;
  CFMutableDictionaryRef v12;

  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary __addObject:forKey:](theDict, "__addObject:forKey:", value, key);
  }
  else
  {
    v6 = atomic_load((unint64_t *)theDict + 1);
    if ((v6 & 0x40) != 0)
    {
      v11 = "void CFDictionaryAddValue(CFMutableDictionaryRef, const void *, const void *)";
      v12 = theDict;
      CFLog(3, CFSTR("%s(): immutable collection %p given to mutating function"));
    }
    v7 = atomic_load((unint64_t *)theDict + 1);
    if ((v7 & 1) != 0)
    {
      v8 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        v8 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v8;
      }
      objc_msgSend(theDict, v8, key, v11, v12);
    }
    CFBasicHashAddValue((uint64_t)theDict, (unint64_t)key, (uint64_t)value);
    v9 = atomic_load((unint64_t *)theDict + 1);
    if ((v9 & 1) != 0)
    {
      v10 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        v10 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v10;
      }
      objc_msgSend(theDict, v10, key);
    }
  }
}

uint64_t CFBasicHashAddValue(uint64_t a1, unint64_t a2, uint64_t a3)
{
  char v3;
  int v7;
  unint64_t v8;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = atomic_load((unint64_t *)(a1 + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809 || a3 == 2814029233)
    goto LABEL_28;
  v10 = 0u;
  v11 = 0u;
  if (*(_BYTE *)(a1 + 26))
  {
    v7 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, (uint64_t *)&v10);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double_Indirect(a1, a2, (uint64_t *)&v10);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, (uint64_t *)&v10);
          break;
        default:
          goto LABEL_28;
      }
    }
    else if (v7 == 3)
    {
      ___CFBasicHashFindBucket_Exponential(a1, a2, (uint64_t *)&v10);
    }
    else
    {
      if (v7 != 2)
      {
        if (v7 == 1)
        {
          ___CFBasicHashFindBucket_Linear(a1, a2, (uint64_t *)&v10);
          goto LABEL_21;
        }
LABEL_28:
        __break(1u);
      }
      ___CFBasicHashFindBucket_Double(a1, a2, (uint64_t *)&v10);
    }
  }
  else
  {
    v10 = xmmword_182DC7A10;
    v11 = unk_182DC7A20;
  }
LABEL_21:
  v8 = *((_QWORD *)&v11 + 1);
  if (!*((_QWORD *)&v11 + 1))
  {
    __CFBasicHashAddValue(a1, v10, a2, a3);
    return 1;
  }
  result = 0;
  ++*(_WORD *)(a1 + 16);
  if (v8 <= 0x7FFFFFFFFFFFFFFELL && (*(_WORD *)(a1 + 18) & 0x18) != 0)
  {
    __CFBasicHashIncSlotCount(a1);
    return 1;
  }
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  _QWORD v4[2];

  v4[1] = *MEMORY[0x1E0C80C00];
  v4[0] = value;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
    -[__CFArray addObject:](theArray, "addObject:", value);
  else
    _CFArrayReplaceValues((unint64_t)theArray, *((_QWORD *)theArray + 2), 0, v4, 1);
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
    return -[__CFSet count](theSet, "count");
  else
    return CFBasicHashGetCount((uint64_t)theSet);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
    return -[__CFDictionary count](theDict, "count");
  else
    return CFBasicHashGetCount((uint64_t)theDict);
}

const void *__cdecl CFSetGetValue(CFSetRef theSet, const void *value)
{
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
    return (const void *)-[__CFSet member:](theSet, "member:", value);
  v5 = 0u;
  v6 = 0u;
  CFBasicHashFindBucket((uint64_t)theSet, (unint64_t)value, (uint64_t *)&v5);
  if (*((_QWORD *)&v6 + 1))
    return (const void *)v6;
  else
    return 0;
}

unint64_t ___CFBasicHashFindBucket_Exponential_Indirect@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t (*v8)(unint64_t);
  unint64_t result;
  unint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(uint64_t);
  uint64_t (*v23)(uint64_t);
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t *v28;
  unint64_t v29;
  uint64_t v30;

  v6 = *(unsigned __int8 *)(a1 + 26);
  v7 = __CFBasicHashTableSizes[v6];
  v8 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  result = a2;
  if (v8)
    result = v8(a2);
  v30 = a2;
  if (result / v7 % v7)
    v10 = result / v7 % v7;
  else
    v10 = v7 - 1;
  v11 = *(unsigned __int16 *)(a1 + 18);
  if ((v11 & 4) != 0)
    v12 = (uint64_t *)(a1 + 40 + 8 * ((v11 >> 2) & 1));
  else
    v12 = (uint64_t *)(a1 + 40);
  v28 = a3;
  if (!v7)
  {
    v16 = -1;
LABEL_35:
    v20 = 0;
    v24 = v28;
    v28[1] = 0;
    v28[2] = 0;
    *v28 = v16;
    goto LABEL_36;
  }
  v13 = result % v7;
  v14 = __CFBasicHashPrimitiveRoots[v6];
  v15 = *v12;
  v16 = -1;
  v17 = v7;
  v18 = v14;
  v19 = result % v7;
  v29 = v10;
  while (1)
  {
    v20 = *(_QWORD *)(v15 + 8 * v19);
    switch(v20)
    {
      case -1:
        if (v16 == -1)
          v16 = v19;
        goto LABEL_28;
      case 0:
        v24 = v28;
        v28[1] = 0;
        v28[2] = 0;
        if (v16 == -1)
          v25 = v19;
        else
          v25 = v16;
        *v28 = v25;
        goto LABEL_36;
      case 2814029233:
        v20 = 0;
        break;
    }
    if (v20 == 2780474809)
      v21 = -1;
    else
      v21 = v20;
    v22 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(a1 + 32) >> 54) >> 5]
                                            + 8 * ((*(_QWORD *)(a1 + 32) >> 54) & 0x1FLL));
    if (v22)
    {
      result = v22(v21);
      v21 = result;
    }
    if (v21 == v30)
      break;
    v23 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                            + 8 * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v23)
    {
      result = v23(v21);
      v10 = v29;
      if ((_DWORD)result)
        goto LABEL_42;
    }
    else
    {
      v10 = v29;
    }
LABEL_28:
    v19 = v13 + v18 * v10;
    if (v7 <= v19)
      v19 %= v7;
    v18 *= v14;
    if (v7 <= v18)
      v18 %= v7;
    if (!--v17)
      goto LABEL_35;
  }
  v21 = v30;
LABEL_42:
  v24 = v28;
  *v28 = v19;
  v26 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v19);
  if (v26 == 2814029233)
  {
    v26 = 0;
  }
  else if (v26 == 2780474809)
  {
    v26 = -1;
  }
  v28[1] = v21;
  v28[2] = v26;
  v27 = *(unsigned __int16 *)(a1 + 18);
  if ((v27 & 0x18) != 0)
    __asm { BR              X11 }
  v20 = 1;
LABEL_36:
  v24[3] = v20;
  return result;
}

void sub_182AA3EF0()
{
  JUMPOUT(0x182AA3E2CLL);
}

void sub_182AA3EF8()
{
  JUMPOUT(0x182AA3E2CLL);
}

void sub_182AA3F00()
{
  JUMPOUT(0x182AA3E2CLL);
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
  char v4;

  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet addObject:](theSet, "addObject:", value);
  }
  else
  {
    v4 = atomic_load((unint64_t *)theSet + 1);
    if ((v4 & 0x40) != 0)
      CFLog(3, CFSTR("%s(): immutable collection %p given to mutating function"));
    CFBasicHashAddValue((uint64_t)theSet, (unint64_t)value, (uint64_t)value);
  }
}

void _CFArrayReplaceValues(unint64_t a1, uint64_t a2, uint64_t a3, _QWORD *__src, uint64_t a5)
{
  unsigned int v10;
  int v11;
  const CFArrayCallBacks *v12;
  char v13;
  int v14;
  const CFAllocatorRef *v15;
  char v16;
  unint64_t v17;
  CFAllocatorRef v18;
  _OWORD *Typed;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  int64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t v34;
  uint64_t v36;
  BOOL v38;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  const CFAllocatorRef *v50;
  char v51;
  uint64_t *v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  size_t v60;
  const __CFAllocator *allocator;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _OWORD v67[128];
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  memset(v67, 0, 512);
  v10 = atomic_load((unint64_t *)(a1 + 8));
  v11 = (v10 >> 2) & 3;
  if (v11)
  {
    if (v11 == 1)
    {
      v12 = &kCFTypeArrayCallBacks;
    }
    else
    {
      v13 = atomic_load((unint64_t *)(a1 + 8));
      v14 = v13 & 3;
      if (v14 != 2 && v14)
        v12 = 0;
      else
        v12 = (const CFArrayCallBacks *)(a1 + 48);
    }
  }
  else
  {
    v12 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  v15 = &kCFAllocatorSystemDefault;
  if ((a1 & 0x8000000000000000) == 0)
  {
    v16 = atomic_load((unint64_t *)(a1 + 8));
    if (v16 < 0)
      v15 = &kCFAllocatorSystemDefault;
    else
      v15 = (const CFAllocatorRef *)(a1 - 16);
  }
  v17 = *(_QWORD *)(a1 + 16) - a3;
  v18 = *v15;
  Typed = __src;
  if (v12->retain)
  {
    if (a5 >= 257)
    {
      Typed = (_OWORD *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * a5, 0x80040B8603338, 0);
      if (Typed != v67 && __CFOASafe)
        __CFSetLastAllocationEventName();
    }
    else
    {
      Typed = v67;
      if (a5 < 1)
        goto LABEL_21;
    }
    v20 = 0;
    do
    {
      *((_QWORD *)Typed + v20) = ((uint64_t (*)(CFAllocatorRef, _QWORD))v12->retain)(v18, __src[v20]);
      ++v20;
    }
    while (a5 != v20);
  }
LABEL_21:
  v21 = v17 + a5;
  ++*(_QWORD *)(a1 + 24);
  if (a3 >= 1)
    __CFArrayReleaseValues(a1, a2, a3, 0);
  v22 = *(uint64_t **)(a1 + 40);
  v66 = v21;
  if (v22)
  {
    v23 = a5 - a3;
    if (a5 == a3)
      goto LABEL_88;
    v24 = *(_QWORD *)(a1 + 16);
    v25 = v24 - a3 + a5;
    v63 = v22 + 2;
    v64 = v24 - a3 - a2;
    v27 = *v22;
    v26 = v22[1];
    v28 = v26 >> 17;
    if (v26 >> 17 <= 4)
      v28 = 4;
    if (v26 < v25 || (v29 = v26 - v24, v24 < v25) && v29 < v28)
    {
      v30 = v28 + v25;
      v62 = *v22;
      if (v28 + v25 >= 4)
      {
        if (flsl(v28 + v25) == 31)
          v31 = 0x7FFFFFFFFFFFFFFFLL;
        else
          v31 = 1 << flsl(v30);
      }
      else
      {
        v31 = 4;
      }
      v65 = a2;
      if ((a1 & 0x8000000000000000) != 0)
      {
        v50 = &kCFAllocatorSystemDefault;
      }
      else
      {
        v51 = atomic_load((unint64_t *)(a1 + 8));
        if (v51 < 0)
          v50 = &kCFAllocatorSystemDefault;
        else
          v50 = (const CFAllocatorRef *)(a1 - 16);
      }
      allocator = *v50;
      v52 = (uint64_t *)CFAllocatorAllocateTyped(*v50, 8 * v31 + 16, 1166748410, 0);
      if (__CFOASafe)
        __CFSetLastAllocationEventName();
      v53 = v52 + 2;
      if (v31 >= v25)
        v54 = v31 - v25;
      else
        v54 = v31 - v25 + 1;
      *v52 = v54 >> 1;
      v52[1] = v31;
      if (v65 >= 1)
        memmove(&v53[v54 >> 1], &v63[v62], 8 * v65);
      if (v64 >= 1)
        memmove(&v53[v65 + a5 + (v54 >> 1)], &v63[a3 + v65 + v62], 8 * v64);
      *(_QWORD *)(a1 + 40) = v52;
      CFAllocatorDeallocate(allocator, v22);
      a2 = v65;
      goto LABEL_88;
    }
    v33 = v23 <= v29 - v27 || v23 < 0;
    v34 = v24 - a3 - a2;
    if (v33 && v64 < a2)
    {
      v58 = v27 + a2 + a3;
      v59 = v27 + a2 + a5;
      if (v64 >= 1)
      {
        memmove(&v63[v59], &v63[v58], 8 * v64);
        v34 = v64;
      }
      if (a5 < a3)
      {
        v49 = &v63[v59 + v34];
        v48 = v58 - v59;
        goto LABEL_99;
      }
    }
    else
    {
      v36 = v27 - v23;
      v38 = v27 < v23 || v64 < a2;
      if (v23 < 0 || !v38)
      {
        *v22 = v36;
        if (a2 >= 1)
          memmove(&v22[v36 + 2], &v22[v27 + 2], 8 * a2);
        if (v23 < 0)
        {
          v49 = &v63[v27];
          v60 = -8 * v23;
          goto LABEL_110;
        }
      }
      else
      {
        v39 = v29 < v23;
        v40 = v29 - v23;
        if (v39)
          v41 = v40 + 1;
        else
          v41 = v40;
        v42 = v41 >> 1;
        if (v39)
          v40 += 3;
        v43 = *v22;
        v44 = v42 - (v40 >> 2);
        v45 = a3 + a2 + *v22;
        v46 = a2 + a5 + v44;
        *v22 = v44;
        v47 = v43;
        if (v44 >= v43)
        {
          if (v64 >= 1)
            memmove(&v63[v46], &v63[v45], 8 * v64);
          if (a2 >= 1)
            memmove(&v63[v44], &v63[v47], 8 * a2);
          if (v44 > v47)
          {
            v60 = 8 * (v44 - v47);
            v49 = &v63[v47];
            goto LABEL_110;
          }
        }
        else
        {
          if (a2 >= 1)
          {
            memmove(&v63[v44], &v63[v43], 8 * a2);
            v34 = v64;
          }
          if (v34 >= 1)
          {
            memmove(&v63[v46], &v63[v45], 8 * v34);
            v34 = v64;
          }
          v48 = v45 - v46;
          if (v45 > v46)
          {
            v49 = &v63[v46 + v34];
LABEL_99:
            v60 = 8 * v48;
LABEL_110:
            bzero(v49, v60);
          }
        }
      }
    }
  }
  else if ((v21 & 0x8000000000000000) == 0)
  {
    if (v21 >= 4)
    {
      if (flsl(v21) == 31)
        v32 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v32 = 1 << flsl(v21);
    }
    else
    {
      v32 = 4;
    }
    v55 = (uint64_t *)CFAllocatorAllocateTyped(v18, 8 * v32 + 16, 1424118679, 0);
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
    v56 = v32 - a5;
    if (v32 < a5)
      ++v56;
    *v55 = v56 >> 1;
    v55[1] = v32;
    *(_QWORD *)(a1 + 40) = v55;
  }
LABEL_88:
  if (a5 >= 1)
  {
    v57 = *(_QWORD **)(a1 + 40);
    if (!v57)
      _CFArrayReplaceValues_cold_1();
    memmove(&v57[*v57 + 2 + a2], Typed, 8 * a5);
  }
  *(_QWORD *)(a1 + 16) = v66;
  if (Typed != v67 && Typed != (_OWORD *)__src)
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
}

uint64_t __NSOrderedSetEquateKeys(void *a1, uint64_t a2)
{
  return objc_msgSend(a1, "isEqual:", a2);
}

void __CFBasicHashRehash(uint64_t cf, uint64_t a2)
{
  unint64_t v2;
  uint64_t *v3;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __objc2_class **v10;
  uint64_t Typed;
  uint64_t v12;
  void *v13;
  __objc2_class **v14;
  void *v15;
  unint64_t v16;
  size_t v17;
  __objc2_class **v18;
  uint64_t v19;
  void *v20;
  _QWORD *v21;
  unint64_t v22;
  _QWORD *v23;
  char *v24;
  char *v25;
  uint64_t v26;
  BOOL v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t (*v35)(uint64_t);
  unint64_t Bucket_Exponential_Indirect_NoCollision;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  void (*v42)(const CFAllocatorRef, uint64_t);
  const CFAllocatorRef *v43;
  char v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void (*v48)(const CFAllocatorRef, uint64_t);
  const CFAllocatorRef *v49;
  char v50;
  const __CFAllocator *v51;
  void *ptr;
  int v53;

  v5 = BYTE2(*(_QWORD *)(cf + 24));
  v6 = v5;
  if (!a2)
    goto LABEL_9;
  v7 = 0;
  v2 = *(_QWORD *)(cf + 32);
  v3 = (uint64_t *)(a2 & ~(a2 >> 63));
  do
  {
    if (__CFBasicHashTableCapacities[v7] >= (uint64_t)v3 + *(unsigned int *)(cf + 20))
      goto LABEL_6;
    ++v7;
  }
  while (v7 != 64);
  do
  {
    while (1)
    {
      do
      {
        while (1)
        {
          do
          {
            while (1)
            {
LABEL_5:
              __break(1u);
LABEL_6:
              v2 = ((v2 >> 2) & 1) + v7;
              if (v3 == (uint64_t *)1)
                v6 = v2;
              else
                v6 = v7;
LABEL_9:
              v8 = __CFBasicHashTableSizes[v6];
              v9 = __CFBasicHashTableSizes[v5];
              if (v8 < 1)
              {
                Typed = 0;
                v12 = 0;
LABEL_32:
                v19 = 0;
                goto LABEL_37;
              }
              if ((unint64_t)(v8 - 0x1000000000000000) >> 61 != 7)
                __CFBasicHashRehash_cold_1();
              v10 = (__objc2_class **)CFGetAllocator((CFTypeRef)cf);
              if (!__CFAllocatorRespectsHintZeroWhenAllocating(v10))
                break;
              Typed = CFAllocatorAllocateTyped(v10, 8 * v8, 3506094911, 1);
              if (Typed)
                goto LABEL_17;
            }
            v13 = (void *)CFAllocatorAllocateTyped(v10, 8 * v8, 3112355480, 0);
          }
          while (!v13);
          Typed = (uint64_t)v13;
          bzero(v13, 8 * v8);
LABEL_17:
          if (__CFOASafe)
            __CFSetLastAllocationEventName();
          if ((*(_WORD *)(cf + 18) & 4) == 0)
          {
            v12 = 0;
            goto LABEL_28;
          }
          v14 = (__objc2_class **)CFGetAllocator((CFTypeRef)cf);
          if (!__CFAllocatorRespectsHintZeroWhenAllocating(v14))
            break;
          v12 = CFAllocatorAllocateTyped(v14, 8 * v8, 3506094911, 1);
          if (v12)
            goto LABEL_26;
        }
        v15 = (void *)CFAllocatorAllocateTyped(v14, 8 * v8, 3112355480, 0);
      }
      while (!v15);
      v12 = (uint64_t)v15;
      bzero(v15, 8 * v8);
LABEL_26:
      if (__CFOASafe)
        __CFSetLastAllocationEventName();
LABEL_28:
      v16 = *(unsigned __int16 *)(cf + 18);
      if ((v16 & 0x18) == 0)
        goto LABEL_32;
      v17 = v8 << ((v16 >> 5) & 3);
      v18 = (__objc2_class **)CFGetAllocator((CFTypeRef)cf);
      if (!__CFAllocatorRespectsHintZeroWhenAllocating(v18))
        break;
      v19 = CFAllocatorAllocateTyped(v18, v17, 3506094911, 1);
      if (v19)
        goto LABEL_35;
    }
    v20 = (void *)CFAllocatorAllocateTyped(v18, v17, 3112355480, 0);
  }
  while (!v20);
  v19 = (uint64_t)v20;
  bzero(v20, v17);
LABEL_35:
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
LABEL_37:
  *(_QWORD *)(cf + 24) = *(_QWORD *)(cf + 24) & 0xFFFFFFFFFF000000 | ((unint64_t)v6 << 16);
  v21 = *(_QWORD **)(cf + 40);
  *(_QWORD *)(cf + 40) = Typed;
  v22 = *(unsigned __int16 *)(cf + 18);
  if ((v22 & 4) != 0)
  {
    v24 = (char *)(cf + 8 * ((v22 >> 2) & 1));
    v23 = (_QWORD *)*((_QWORD *)v24 + 5);
    *((_QWORD *)v24 + 5) = v12;
  }
  else
  {
    v23 = 0;
  }
  if ((v22 & 0x18) != 0)
  {
    v25 = (char *)(cf + (v22 & 0x18));
    ptr = (void *)*((_QWORD *)v25 + 5);
    *((_QWORD *)v25 + 5) = v19;
  }
  else
  {
    ptr = 0;
  }
  if (v9 >= 1)
  {
    v26 = 0;
    if (v19)
      v27 = ptr == 0;
    else
      v27 = 1;
    v28 = !v27;
    v53 = v28;
    do
    {
      v29 = v21[v26];
      if ((unint64_t)(v29 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v29 == 2814029233)
          v29 = 0;
        if (v29 == 2780474809)
          v30 = -1;
        else
          v30 = v29;
        v31 = v30;
        if (v23)
        {
          v32 = v23[v26];
          if (v32 == 2814029233)
            v32 = 0;
          if (v32 == 2780474809)
            v31 = -1;
          else
            v31 = v32;
        }
        v33 = *(_QWORD *)(cf + 24);
        if (*(__int16 *)(cf + 18) < 0)
        {
          v34 = *(_QWORD *)(cf + 32);
          v3 = CFBasicHashCallBackPtrs;
          v2 = CFBasicHashCallBackPtrs[(v34 >> 54) >> 5];
          v35 = *(uint64_t (**)(uint64_t))(v2 + 8 * ((v34 >> 54) & 0x1F));
          if (v35)
          {
            v31 = v35(v30);
            v33 = *(_QWORD *)(cf + 24);
          }
          else
          {
            v31 = v30;
          }
        }
        if ((v33 & 0xFF0000) != 0)
        {
          v7 = *(unsigned __int16 *)(cf + 18);
          v5 = v7 & 3;
          if ((v7 & 0x8000) != 0)
          {
            switch((_DWORD)v5)
            {
              case 3:
                Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision(cf, v31);
                break;
              case 2:
                Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_Indirect_NoCollision(cf, v31);
                break;
              case 1:
                Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(cf, v31);
                break;
              default:
                goto LABEL_5;
            }
          }
          else
          {
            switch((_DWORD)v5)
            {
              case 3:
                Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_NoCollision(cf, v31);
                break;
              case 2:
                Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_NoCollision(cf, v31);
                break;
              case 1:
                Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_NoCollision(cf, v31);
                break;
              default:
                goto LABEL_5;
            }
          }
          v37 = Bucket_Exponential_Indirect_NoCollision;
        }
        else
        {
          v37 = -1;
        }
        v38 = *(_QWORD *)(cf + 40);
        v39 = *(_QWORD *)(v38 + 8 * v37);
        if (v30)
          v2 = v30;
        else
          v2 = 2814029233;
        if (v2 == -1)
          v2 = 2780474809;
        *(_QWORD *)(v38 + 8 * v37) = v2;
        v7 = v39 + 1;
        if ((unint64_t)(v39 + 1) >= 2)
        {
          if (v39 == 2814029233)
            v39 = 0;
          if (v39 == 2780474809)
            v40 = -1;
          else
            v40 = v39;
          if ((*(_QWORD *)(cf + 32) & 2) == 0)
          {
            v41 = *(_QWORD *)(cf + 24);
            v2 = (unint64_t)CFBasicHashCallBackPtrs;
            v7 = *(uint64_t *)((char *)CFBasicHashCallBackPtrs + (HIBYTE(v41) & 0xF8));
            v42 = *(void (**)(const CFAllocatorRef, uint64_t))(v7 + 8 * ((v41 >> 54) & 0x1F));
            if (v42)
            {
              v43 = &kCFAllocatorSystemDefault;
              if ((cf & 0x8000000000000000) == 0)
              {
                v44 = atomic_load((unint64_t *)(cf + 8));
                v27 = (v44 & 0x80) == 0;
                v43 = (const CFAllocatorRef *)(cf - 16);
                if (!v27)
                  v43 = &kCFAllocatorSystemDefault;
              }
              v42(*v43, v40);
            }
          }
        }
        if (v23)
        {
          v5 = *(unsigned __int16 *)(cf + 18);
          if ((v5 & 4) == 0)
            goto LABEL_5;
          v45 = *(_QWORD *)(cf + 8 * ((v5 >> 2) & 1) + 40);
          v46 = *(_QWORD *)(v45 + 8 * v37);
          if (v31)
            v2 = v31;
          else
            v2 = 2814029233;
          if (v2 == -1)
            v2 = 2780474809;
          *(_QWORD *)(v45 + 8 * v37) = v2;
          if ((unint64_t)(v46 + 1) >= 2)
          {
            if (v46 == 2814029233)
              v46 = 0;
            if (v46 == 2780474809)
              v47 = -1;
            else
              v47 = v46;
            if ((*(_QWORD *)(cf + 32) & 2) == 0)
            {
              v2 = (unint64_t)CFBasicHashCallBackPtrs;
              v48 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(cf + 24) >> 49) & 0x1FLL]
                                                                         + 8 * ((*(_QWORD *)(cf + 24) >> 44) & 0x1FLL));
              if (v48)
              {
                v49 = &kCFAllocatorSystemDefault;
                if ((cf & 0x8000000000000000) == 0)
                {
                  v50 = atomic_load((unint64_t *)(cf + 8));
                  v27 = (v50 & 0x80) == 0;
                  v49 = (const CFAllocatorRef *)(cf - 16);
                  if (!v27)
                    v49 = &kCFAllocatorSystemDefault;
                }
                v48(*v49, v47);
              }
            }
          }
        }
        if (v53)
          __asm { BR              X9 }
      }
      ++v26;
    }
    while (v9 != v26);
  }
  v51 = CFGetAllocator((CFTypeRef)cf);
  CFAllocatorDeallocate(v51, v21);
  CFAllocatorDeallocate(v51, v23);
  CFAllocatorDeallocate(v51, ptr);
  CFAllocatorDeallocate(v51, 0);
}

uint64_t ___CFBasicHashFindBucket_Linear_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t (*v4)(unint64_t);
  unint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t result;
  unint64_t v9;
  unint64_t v10;

  v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4)
    a2 = v4(a2);
  v5 = *(unsigned __int16 *)(a1 + 18);
  if ((v5 & 4) != 0)
    v6 = (uint64_t *)(a1 + 40 + 8 * ((v5 >> 2) & 1));
  else
    v6 = (uint64_t *)(a1 + 40);
  if (!v3)
    return -1;
  v7 = *v6;
  result = a2 % v3;
  v9 = v3;
  while (*(_QWORD *)(v7 + 8 * result))
  {
    if (v3 <= result + 1)
      v10 = v3;
    else
      v10 = 0;
    result = result + 1 - v10;
    if (!--v9)
      return -1;
  }
  return result;
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  unint64_t v2;
  CFAllocatorRef *v3;
  unint64_t v5;
  char v6;

  if (!cf
    || ((unint64_t)cf & 0x8000000000000000) != 0
    || (v2 = atomic_load((unint64_t *)cf + 1), CF_IS_OBJC((v2 >> 8) & 0x3FF, (__objc2_class **)cf)))
  {
    v3 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    return *v3;
  }
  v5 = atomic_load((unint64_t *)cf + 1);
  if ((v5 & 0x3FF00) != 0x200)
  {
    v6 = atomic_load((unint64_t *)cf + 1);
    if (v6 < 0)
      v3 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    else
      v3 = (CFAllocatorRef *)((char *)cf - 16);
    return *v3;
  }
  return (CFAllocatorRef)__CFAllocatorGetAllocator((uint64_t)cf);
}

unint64_t ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t (*v5)(unint64_t);
  unint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t result;

  v3 = *(unsigned __int8 *)(a1 + 26);
  v4 = __CFBasicHashTableSizes[v3];
  v5 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  if (v5)
    a2 = v5(a2);
  v6 = a2 / v4 % v4;
  if (!v6)
    v6 = v4 - 1;
  v7 = *(unsigned __int16 *)(a1 + 18);
  v8 = (uint64_t *)(a1 + 40 + 8 * ((v7 >> 2) & 1));
  if ((v7 & 4) == 0)
    v8 = (uint64_t *)(a1 + 40);
  v9 = *v8;
  v10 = v4;
  v11 = __CFBasicHashPrimitiveRoots[v3];
  result = a2 % v4;
  while (*(_QWORD *)(v9 + 8 * result))
  {
    result = a2 % v4 + v11 * v6;
    if (v4 <= result)
      result %= v4;
    v11 *= __CFBasicHashPrimitiveRoots[v3];
    if (v4 <= v11)
      v11 %= v4;
    if (!--v10)
      return -1;
  }
  return result;
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  if (CF_IS_OBJC(0x15uLL, (__objc2_class **)BOOLean))
    return -[__CFBoolean BOOLValue](BOOLean, "BOOLValue");
  else
    return &__kCFBooleanTrue == (__objc2_class **)BOOLean;
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
  CFIndex Count;

  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary getObjects:andKeys:](theDict, "getObjects:andKeys:", values, keys);
  }
  else
  {
    Count = CFDictionaryGetCount(theDict);
    CFBasicHashGetElements((uint64_t)theDict, Count, (uint64_t)values, (uint64_t)keys);
  }
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
  CFIndex length;
  CFIndex location;
  char v7;
  int v8;
  char v9;
  BOOL v10;
  uint64_t v11;
  char *v12;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    -[__CFArray getObjects:range:](theArray, "getObjects:range:", values, location, length);
    return;
  }
  if (length >= 1)
  {
    v7 = atomic_load((unint64_t *)theArray + 1);
    v8 = v7 & 3;
    if (v8 == 2)
    {
      v12 = (char *)(*((_QWORD *)theArray + 5) + 8 * **((_QWORD **)theArray + 5) + 16);
LABEL_11:
      memmove(values, &v12[8 * location], 8 * length);
      return;
    }
    if (!v8)
    {
      v9 = atomic_load((unint64_t *)theArray + 1);
      v10 = (~v9 & 0xC) == 0;
      v11 = 48;
      if (v10)
        v11 = 88;
      v12 = (char *)theArray + v11;
      goto LABEL_11;
    }
  }
}

uint64_t CFHashBytes(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned __int8 *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  BOOL v10;
  int v11;
  int v12;
  int v13;

  if ((int)a2 < 4)
  {
    v2 = 0;
    v9 = a2;
  }
  else
  {
    v2 = 0;
    v3 = (unsigned __int8 *)((a2 & 0xFFFFFFFF00000000) + a1 + 1);
    v4 = a2;
    do
    {
      v5 = *(v3 - 1) + 16 * v2;
      v6 = *v3 + 16 * (v5 ^ (16 * (v5 >> 28)));
      v7 = v3[1] + 16 * (v6 ^ (16 * (v6 >> 28)));
      v8 = v3[2] + 16 * (v7 ^ (16 * (v7 >> 28)));
      v2 = (v8 ^ ((v8 & 0xF0000000) >> 24)) & ~(v8 & 0xF0000000);
      v9 = v4 - 4;
      v3 += 4;
      v10 = v4 > 7;
      v4 -= 4;
    }
    while (v10);
  }
  switch(v9)
  {
    case 1u:
      goto LABEL_11;
    case 2u:
LABEL_10:
      v12 = *(unsigned __int8 *)(a2 + a1 - 2) + 16 * v2;
      v2 = (v12 ^ ((v12 & 0xF0000000) >> 24)) & ~(v12 & 0xF0000000);
LABEL_11:
      v13 = *(unsigned __int8 *)(a2 + a1 - 1) + 16 * v2;
      return (v13 ^ ((v13 & 0xF0000000) >> 24)) & ~(v13 & 0xF0000000);
    case 3u:
      v11 = *(unsigned __int8 *)(a2 + a1 - 3) + 16 * v2;
      v2 = (v11 ^ ((v11 & 0xF0000000) >> 24)) & ~(v11 & 0xF0000000);
      goto LABEL_10;
  }
  return v2;
}

void _appendString(uint64_t a1, CFStringRef theString, int a3)
{
  CFIndex Length;
  UInt8 *Typed;
  char v8;
  CFIndex v9;
  char v10;
  int64_t v11;
  UniChar *v12;
  UniChar *v13;
  char __src;
  CFIndex usedBufLen;
  UInt8 buffer[1024];
  uint64_t v17;
  CFRange v18;
  CFRange v19;

  v17 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(theString);
  if (Length >= 1025)
    Typed = (UInt8 *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, Length, 3515625951, 0);
  else
    Typed = buffer;
  usedBufLen = 0;
  v18.location = 0;
  v18.length = Length;
  if (CFStringGetBytes(theString, v18, 0x600u, 0, 0, Typed, Length, &usedBufLen) == Length)
  {
    v8 = usedBufLen;
    if (usedBufLen >= 15)
      v8 = 15;
    __src = v8 | 0x50;
    bufferWrite(a1, &__src, 1, a3);
    v9 = usedBufLen;
    if (usedBufLen >= 15)
    {
      _appendInt(a1, usedBufLen, a3);
      v9 = usedBufLen;
    }
    bufferWrite(a1, Typed, v9, a3);
  }
  else
  {
    v10 = 15;
    if (Length < 15)
      v10 = Length;
    __src = v10 | 0x60;
    bufferWrite(a1, &__src, 1, a3);
    if (Length >= 15)
      _appendInt(a1, Length, a3);
    v11 = 2 * Length;
    v12 = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * Length, 0x1000040BDFB0063, 0);
    v19.location = 0;
    v19.length = Length;
    CFStringGetCharacters(theString, v19, v12);
    if (Length >= 1)
    {
      v13 = v12;
      do
      {
        *v13 = bswap32(*v13) >> 16;
        ++v13;
        --Length;
      }
      while (Length);
    }
    bufferWrite(a1, v12, v11, a3);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12);
  }
  if (Typed != buffer)
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
}

uint64_t _NSIsNSDictionary(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*MethodImplementation)(uint64_t, char *);

  if (a1)
  {
    v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
      return MethodImplementation(v1, sel_isNSDictionary__);
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }
  return a1 & 1;
}

void _appendInt(uint64_t a1, unint64_t a2, int a3)
{
  int64_t v5;
  char __src;
  _QWORD v7[2];

  v7[1] = *MEMORY[0x1E0C80C00];
  if (a2 > 0xFF)
  {
    if (a2 >> 16)
    {
      if (HIDWORD(a2))
      {
        __src = 19;
        v5 = 8;
      }
      else
      {
        __src = 18;
        v5 = 4;
      }
    }
    else
    {
      __src = 17;
      v5 = 2;
    }
  }
  else
  {
    __src = 16;
    v5 = 1;
  }
  v7[0] = bswap64(a2);
  bufferWrite(a1, &__src, 1, a3);
  bufferWrite(a1, (_BYTE *)&v7[1] - v5, v5, a3);
}

uint64_t __CFDataHash(unint64_t *a1)
{
  char v1;
  unint64_t v2;
  uint64_t v3;

  v1 = atomic_load(a1 + 1);
  if ((v1 & 4) != 0)
    v2 = ((unint64_t)a1 + 63) & 0xFFFFFFFFFFFFFFF0;
  else
    v2 = a1[5];
  if ((uint64_t)a1[2] >= 80)
    v3 = 80;
  else
    v3 = a1[2];
  return CFHashBytes(v2, v3);
}

uint64_t __CFArrayCreateMutable0(__objc2_class **a1, int a2, const CFArrayCallBacks *a3)
{
  return __CFArrayCreateInit(a1, 2, a2, a3);
}

uint64_t typeStringHash(char *a1)
{
  size_t v2;

  v2 = strlen(a1);
  return CFStringHashCString((unsigned __int8 *)a1, v2);
}

CFHashCode _dependentNotificationHash(CFTypeRef **a1)
{
  return CFHash(**a1);
}

CFHashCode __CFRunLoopModeHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 80));
}

uint64_t __rangeRetain(uint64_t a1, uint64_t a2)
{
  CFRetain(*(CFTypeRef *)(a2 + 16));
  return a2;
}

void _CFArrayReplaceValues_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"CFArray expectation failed";
  __break(1u);
}

uint64_t __CFArrayEqual(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  const CFArrayCallBacks *v7;
  uint64_t result;
  char v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  const CFArrayCallBacks *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t (*equal)(void);

  if (a1 == a2)
    return 1;
  v4 = a1[2];
  if (v4 != a2[2])
    return 0;
  v5 = atomic_load(a1 + 1);
  v6 = (v5 >> 2) & 3;
  if (v6)
  {
    if (v6 == 1)
    {
      v7 = &kCFTypeArrayCallBacks;
    }
    else
    {
      v9 = atomic_load(a1 + 1);
      v10 = v9 & 3;
      v11 = v10 ? 0 : (uint64_t)(a1 + 6);
      v7 = v10 == 2 ? (const CFArrayCallBacks *)(a1 + 6) : (const CFArrayCallBacks *)v11;
    }
  }
  else
  {
    v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  v12 = atomic_load(a2 + 1);
  v13 = (v12 >> 2) & 3;
  if (v13)
  {
    if (v13 == 1)
    {
      v14 = &kCFTypeArrayCallBacks;
    }
    else
    {
      atomic_load(a2 + 1);
      v14 = (const CFArrayCallBacks *)(a2 + 6);
    }
  }
  else
  {
    v14 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  if (v7->equal != v14->equal)
    return 0;
  if (v4 < 1)
    return 1;
  v15 = 0;
  while (1)
  {
    atomic_load(a1 + 1);
    v16 = atomic_load(a1 + 1);
    if ((v16 & 3) != 0)
    {
      v17 = a1[5] + 8 * *(_QWORD *)a1[5] + 16;
    }
    else
    {
      v18 = atomic_load(a1 + 1);
      v19 = (~v18 & 0xC) != 0 ? 48 : 88;
      v17 = (uint64_t)a1 + v19;
    }
    v20 = *(_QWORD *)(v17 + 8 * v15);
    atomic_load(a2 + 1);
    v21 = atomic_load(a2 + 1);
    if ((v21 & 3) != 0)
    {
      v22 = a2[5] + 8 * *(_QWORD *)a2[5] + 16;
    }
    else
    {
      v23 = atomic_load(a2 + 1);
      v24 = (~v23 & 0xC) != 0 ? 48 : 88;
      v22 = (uint64_t)a2 + v24;
    }
    if (v20 != *(_QWORD *)(v22 + 8 * v15))
    {
      equal = (uint64_t (*)(void))v7->equal;
      if (!equal)
        return 0;
      result = equal();
      if (!(_DWORD)result)
        break;
    }
    if (v4 == ++v15)
      return 1;
  }
  return result;
}

void sub_182AA68EC(_Unwind_Exception *a1)
{
  free(0);
  _Unwind_Resume(a1);
}

uint64_t __CFStringIsCF(uint64_t a1, _BYTE *a2, _QWORD *a3, BOOL *a4)
{
  uint64_t result;
  char v9;
  char v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  unsigned __int8 ***v14;
  unsigned __int8 **v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;

  if (CF_IS_OBJC(7uLL, (__objc2_class **)a1))
    return 0;
  v9 = atomic_load((unint64_t *)(a1 + 8));
  *a2 = v9 & 1;
  v10 = atomic_load((unint64_t *)(a1 + 8));
  v11 = v10 & 5;
  v12 = atomic_load((unint64_t *)(a1 + 8));
  v13 = v12 & 0x60;
  if (v11 == 4)
  {
    v14 = (unsigned __int8 ***)(a1 + 16);
    if (v13)
    {
      v15 = *v14;
    }
    else
    {
      v17 = atomic_load((unint64_t *)(a1 + 8));
      v15 = (unsigned __int8 **)&v14[(v17 & 5) != 4];
    }
    v16 = *(unsigned __int8 *)v15;
  }
  else if ((v12 & 0x60) != 0)
  {
    v16 = *(_QWORD *)(a1 + 24);
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 16);
  }
  *a3 = v16;
  v18 = atomic_load((unint64_t *)(a1 + 8));
  result = 1;
  *a4 = ((v18 >> 4) & 1) == 0;
  return result;
}

CFIndex __CFStringEncodeByteStream(CFStringRef theString, CFRange range, int a3, uint64_t a4, unsigned int a5, UniChar *buffer, uint64_t a7, int64_t *a8)
{
  uint64_t v8;
  UniChar *v9;
  uint64_t length;
  CFIndex location;
  int64_t *v13;
  const UniChar *v17;
  uint64_t v18;
  const char *CStringPtr;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  unsigned int v23;
  _QWORD *v24;
  CFStringEncoding v25;
  const char *v26;
  const unsigned __int8 *v27;
  int v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const unsigned __int8 *v33;
  int v34;
  uint64_t v35;
  CFIndex v36;
  CFIndex v37;
  uint64_t v38;
  uint64_t v39;
  CFIndex v40;
  UniChar v41;
  unsigned int v42;
  int v43;
  size_t v44;
  BOOL v45;
  uint64_t v46;
  uint64_t v47;
  CFIndex v48;
  CFIndex v49;
  CFIndex v50;
  BOOL v51;
  BOOL v52;
  uint64_t v53;
  char v54;
  UniChar *v55;
  CFStringEncoding v56;
  ConstStringPtr PascalStringPtr;
  int v58;
  uint64_t v59;
  int64_t v61;
  const unsigned __int8 *v62;
  const char *v63;
  CFIndex i;
  CFIndex v65;
  UniChar v66;
  unsigned int v67;
  CFIndex v68;
  CFIndex v70;
  CFIndex v71;
  CFIndex v72;
  UniChar v73;
  CFIndex v74;
  CFIndex v75;
  uint64_t v76;
  uint64_t v77;
  unsigned int v78;
  uint64_t v79;
  int v80;
  BOOL v81;
  BOOL v82;
  int v83;
  int v84;
  unsigned int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  int v90;
  unsigned int v91;
  uint64_t v92;
  CFRange RangeOfComposedCharactersAtIndex;
  int v94;
  CFRange v95;
  unsigned int *v96;
  uint64_t v97;
  unsigned int v98;
  const UniChar *v99;
  BOOL v101;
  unsigned int v102;
  const unsigned __int8 *v103;
  unsigned int v104;
  unsigned int v105;
  CFIndex v106;
  unsigned int v107;
  unsigned int v108;
  int64_t *v109;
  uint64_t v110;
  CFIndex v111;
  uint64_t v112;
  uint64_t __src;
  UniChar buffera[8];
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  CFStringRef theStringa;
  const UniChar *CharactersPtr;
  const char *v124;
  CFRange v125;
  CFIndex v126;
  CFIndex v127;
  __int16 v128;
  uint64_t v129;
  CFRange v130;
  CFRange v131;
  CFRange v132;
  CFRange v133;
  CFRange v134;

  v8 = a7;
  v9 = buffer;
  length = range.length;
  location = range.location;
  v13 = a8;
  v129 = *MEMORY[0x1E0C80C00];
  v111 = 0;
  v112 = 0;
  if ((_DWORD)a4 == 3071)
  {
    v120 = 0u;
    v121 = 0u;
    v118 = 0u;
    v119 = 0u;
    v116 = 0u;
    v117 = 0u;
    *(_OWORD *)buffera = 0u;
    v115 = 0u;
    theStringa = theString;
    v125 = range;
    CharactersPtr = CFStringGetCharactersPtr(theString);
    v109 = a8;
    if (CharactersPtr)
      CStringPtr = 0;
    else
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    v126 = 0;
    v127 = 0;
    v124 = CStringPtr;
    if (length < 1)
      goto LABEL_249;
    v35 = 0;
    v36 = 0;
    v106 = 0;
    v37 = 0;
    v38 = 64;
    while (1)
    {
      if ((unint64_t)v37 >= 4)
        v39 = 4;
      else
        v39 = v37;
      v40 = v125.length;
      if (v125.length <= v37)
      {
        v42 = 0;
        LOBYTE(v43) = 0;
      }
      else
      {
        if (CharactersPtr)
        {
          v41 = CharactersPtr[v37 + v125.location];
        }
        else if (v124)
        {
          v41 = v124[v125.location + v37];
        }
        else
        {
          v45 = v127 > v37 && v106 <= v37;
          if (!v45)
          {
            v46 = -v39;
            v47 = v39 + v35;
            v48 = v38 - v39;
            v49 = v37 + v46;
            v50 = v49 + 64;
            if (v49 + 64 >= v125.length)
              v50 = v125.length;
            v126 = v49;
            v127 = v50;
            if (v125.length >= v48)
              v40 = v48;
            v130.length = v40 + v47;
            v130.location = v49 + v125.location;
            CFStringGetCharacters(theStringa, v130, buffera);
            v36 = v126;
          }
          v41 = buffera[v37 - v36];
          v106 = v36;
        }
        v42 = v41;
        v51 = (unsigned __int16)(v41 - 32) >= 0x5Fu || v41 == 92;
        if (!v51 || (v41 <= 0xDu ? (v52 = ((1 << v41) & 0x2600) == 0) : (v52 = 1), !v52))
        {
          v44 = 1;
          goto LABEL_81;
        }
        if (v41 == 92)
        {
          LOBYTE(v42) = 92;
          BYTE1(__src) = 92;
          v44 = 2;
          goto LABEL_81;
        }
        if (v41 > 0xFFu)
        {
          BYTE2(__src) = a0123456789abcd[(unint64_t)v41 >> 12];
          v54 = a0123456789abcd[((unint64_t)v41 >> 8) & 0xF];
          BYTE1(__src) = 117;
          BYTE3(__src) = v54;
          BYTE4(__src) = a0123456789abcd[v42 >> 4];
          BYTE5(__src) = a0123456789abcd[v42 & 0xF];
          LOBYTE(v42) = 92;
          v44 = 6;
          goto LABEL_81;
        }
        v43 = v41 >> 6;
      }
      BYTE1(__src) = v43 + 48;
      BYTE2(__src) = (v42 >> 3) & 7 | 0x30;
      BYTE3(__src) = v42 & 7 | 0x30;
      LOBYTE(v42) = 92;
      v44 = 4;
LABEL_81:
      LOBYTE(__src) = v42;
      v53 = v112 + v44;
      if (v9)
      {
        if (v53 > v8)
          goto LABEL_249;
        memcpy((char *)v9 + v112, &__src, v44);
      }
      v111 = ++v37;
      v112 = v53;
      --v35;
      ++v38;
      if (v37 >= length)
        goto LABEL_249;
    }
  }
  if ((_DWORD)a4 != 134217984)
  {
    if ((_DWORD)a4 == 256 || (_DWORD)a4 == 335544576 || (_DWORD)a4 == 268435712)
    {
      v20 = 2;
      if (a3 == 0 || (_DWORD)a4 != 256)
        v20 = 0;
      v111 = range.length;
      v21 = v20 + 2 * range.length;
      if (buffer)
      {
        if (v21 > a7)
        {
          if (a7 <= v20)
            length = 0;
          else
            length = (unint64_t)(a7 - v20) >> 1;
          v111 = length;
          v21 = v20 + 2 * length;
        }
        v112 = v21;
        if (a3 != 0 && (_DWORD)a4 == 256)
        {
          *buffer = -257;
          range.length = length;
          CFStringGetCharacters(theString, range, buffer + 1);
        }
        else
        {
          range.length = length;
          CFStringGetCharacters(theString, range, buffer);
          if ((_DWORD)a4 == 268435712 && length >= 1)
          {
            v55 = &v9[length];
            do
            {
              *v9 = bswap32(*v9) >> 16;
              ++v9;
            }
            while (v9 < v55);
          }
        }
      }
      else
      {
        v112 = v20 + 2 * range.length;
      }
      goto LABEL_250;
    }
    v109 = a8;
    if ((_DWORD)a4 != 201326848 && (_DWORD)a4 != 469762304 && (_DWORD)a4 != 402653440)
    {
      __src = 0;
      v23 = 0;
      switch(BYTE1(a4))
      {
        case 0:
          v23 = 0;
          if ((a4 > 0x22 || ((1 << a4) & 0x600000032) == 0) && (_DWORD)a4 != 152)
            goto LABEL_263;
          goto LABEL_28;
        case 1:
          goto LABEL_24;
        case 2:
          v23 = a4 != 518;
          goto LABEL_28;
        case 6:
          v22 = (_DWORD)a4 == 1536;
          goto LABEL_25;
        case 8:
        case 0xC:
          goto LABEL_28;
        case 0xA:
          if ((a4 - 2561) >= 0x10)
LABEL_263:
            v23 = 1;
          else
            v23 = (0x7FEEu >> (a4 - 1)) & 1;
          goto LABEL_28;
        case 0xB:
          v101 = __CFADD__(a4 - 3061, 2);
          goto LABEL_260;
        default:
          v101 = ((unsigned __int16)a4 & 0xFF00u) >= 0xC01;
LABEL_260:
          v23 = !v101;
          break;
      }
      goto LABEL_28;
    }
    v120 = 0u;
    v121 = 0u;
    v118 = 0u;
    v119 = 0u;
    v116 = 0u;
    v117 = 0u;
    *(_OWORD *)buffera = 0u;
    v115 = 0u;
    if (a3)
    {
      if ((_DWORD)a4 == 201326848)
      {
        v112 = 4;
        if (buffer)
        {
          if (a7 > 3)
          {
            *(_DWORD *)buffer = 65279;
            v9 = buffer + 2;
          }
          else
          {
            v112 = 0;
          }
        }
      }
    }
    theStringa = theString;
    v125 = range;
    CharactersPtr = CFStringGetCharactersPtr(theString);
    if (CharactersPtr)
      v63 = 0;
    else
      v63 = CFStringGetCStringPtr(theString, 0x600u);
    v126 = 0;
    v127 = 0;
    v124 = v63;
    if (length >= 1)
    {
      for (i = 0; i < length; v111 = i)
      {
        v65 = v125.length;
        if (v125.length <= i)
        {
          v67 = 0;
        }
        else
        {
          if (CharactersPtr)
          {
            v66 = CharactersPtr[v125.location + i];
          }
          else if (v124)
          {
            v66 = v124[v125.location + i];
          }
          else
          {
            v68 = v126;
            if (v127 <= i || v126 > i)
            {
              v70 = i - 4;
              if ((unint64_t)i < 4)
                v70 = 0;
              if (v70 + 64 < v125.length)
                v65 = v70 + 64;
              v126 = v70;
              v127 = v65;
              v131.location = v125.location + v70;
              v131.length = v65 - v70;
              CFStringGetCharacters(theStringa, v131, buffera);
              v68 = v126;
            }
            v66 = buffera[i - v68];
          }
          if ((v66 & 0xFC00) == 0xDC00)
          {
LABEL_169:
            v67 = a5;
            if (!a5)
              break;
            goto LABEL_170;
          }
          v67 = v66;
          if ((v66 & 0xFC00) == 0xD800)
          {
            v71 = i + 1;
            if (i + 1 >= length)
              goto LABEL_169;
            v72 = v125.length;
            if (v125.length <= v71)
              goto LABEL_169;
            if (CharactersPtr)
            {
              v73 = CharactersPtr[v125.location + v71];
            }
            else if (v124)
            {
              v73 = v124[v125.location + v71];
            }
            else
            {
              if (v127 <= v71 || (v74 = v126, v126 > v71))
              {
                v75 = i - 3;
                if ((unint64_t)i < 3)
                  v75 = 0;
                if (v75 + 64 < v125.length)
                  v72 = v75 + 64;
                v126 = v75;
                v127 = v72;
                v132.location = v125.location + v75;
                v132.length = v72 - v75;
                CFStringGetCharacters(theStringa, v132, buffera);
                v74 = v126;
              }
              v73 = buffera[v71 - v74];
            }
            if (v73 >> 10 != 55)
              goto LABEL_169;
            v67 = (v67 << 10) + v73 - 56613888;
          }
        }
LABEL_170:
        v76 = v112;
        v77 = v112 + 4;
        v112 += 4;
        if (v9)
        {
          if (v77 > v8)
          {
            v112 = v76;
            break;
          }
          v78 = bswap32(v67);
          if ((_DWORD)a4 != 402653440)
            v78 = v67;
          *(_DWORD *)v9 = v78;
          v9 += 2;
        }
        if (HIWORD(v67))
          v79 = 2;
        else
          v79 = 1;
        i += v79;
      }
    }
LABEL_249:
    v13 = v109;
    goto LABEL_250;
  }
  v17 = CFStringGetCharactersPtr(theString);
  if (v17)
  {
    if (v9)
      v18 = v8;
    else
      v18 = 0;
    v111 = __CFToUTF8(0, (unsigned __int16 *)&v17[location], length, v9, v18, &v112);
LABEL_250:
    if (v13)
      *v13 = v112;
    return v111;
  }
  v109 = a8;
  __src = 0;
LABEL_24:
  v22 = (_DWORD)a4 == 134217984;
LABEL_25:
  v23 = v22;
LABEL_28:
  v24 = CFStringEncodingIsValidEncoding(a4);
  if ((v24 & 1) != 0)
  {
    if (v23)
    {
      v25 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding(v24);
        v25 = __CFDefaultEightBitStringEncoding;
      }
      v26 = CFStringGetCStringPtr(theString, v25);
      if (v26)
      {
        v27 = (const unsigned __int8 *)&v26[location];
        v28 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          v105 = v23;
          v29 = &v26[location];
          __CFStringComputeEightBitStringEncoding(v26);
          v27 = (const unsigned __int8 *)v29;
          v23 = v105;
          v28 = __CFDefaultEightBitStringEncoding;
        }
        if (v28 != (_DWORD)a4)
        {
          if (v8 >= length)
            v30 = length;
          else
            v30 = v8;
          v31 = length - v30;
          if (v9)
            v32 = v31;
          else
            v32 = 0;
          if ((*(char *)v27 & 0x80000000) == 0 && v32 < length)
          {
            v33 = v27;
            do
            {
              v34 = *(char *)++v33;
              --length;
            }
            while ((v34 & 0x80000000) == 0 && length > v32);
            goto LABEL_188;
          }
LABEL_187:
          v33 = v27;
LABEL_188:
          v61 = v33 - v27;
          v111 = v33 - v27;
          v103 = v27;
          if (v9)
          {
            if (v61 >= v8)
              v61 = v8;
            v111 = v61;
            memmove(v9, v27, v61);
            v9 = (UniChar *)((char *)v9 + v61);
            v8 -= v61;
          }
          if (!length || v9 && !v8)
            goto LABEL_127;
          location += v61;
          v112 = v61;
          v62 = v103;
          if (!v9)
            goto LABEL_196;
LABEL_125:
          if (!v8)
            goto LABEL_126;
LABEL_196:
          if (!v9)
            v8 = 0;
          if (a5)
          {
            v82 = a5 == 255 && (_DWORD)a4 == 1536;
            v83 = (a5 << 24) | 1;
            if (v82)
              v83 = 1;
          }
          else
          {
            v83 = 0;
          }
          v84 = v83 | ((a3 != 0) << 8);
          v85 = __CFWantsToUseASCIICompatibleConversion;
          if (v23)
            v85 = 0;
          v86 = v84 | v85;
          if (!v62)
          {
            v99 = CFStringGetCharactersPtr(theString);
            if (v99)
            {
              CFStringEncodingUnicodeToBytes(a4, v86, (unsigned __int16 *)&v99[location], length, &v111, (unsigned int *)v9, v8, &v112);
              goto LABEL_249;
            }
          }
          v110 = 0;
          if (length < 1)
            goto LABEL_249;
          LOBYTE(v108) = 0;
          v87 = 0;
          v88 = 0;
          v102 = v86 & 0xFFFFFEFF;
          while (1)
          {
            if (length >= 512)
              v89 = 512;
            else
              v89 = length;
            v133.location = location;
            v133.length = v89;
            CFStringGetCharacters(theString, v133, buffera);
            if ((unint64_t)length >= 0x201)
              v89 -= (v128 & 0xFC00) == 55296;
            v104 = ((length > v89) << 12) | (v108 << 16) | v86;
            v90 = CFStringEncodingUnicodeToBytes(a4, v104, buffera, v89, &__src, (unsigned int *)v9, v8, &v110);
            LOBYTE(v108) = BYTE2(v90);
            v91 = v90 & 0xFF00FFFF;
            if ((v90 & 0xFF00FFFF) != 0)
            {
              if (v91 != 1)
                goto LABEL_248;
              v92 = __src;
              if ((unint64_t)length >= 0x201 && (uint64_t)(v89 - __src) <= 5)
              {
                RangeOfComposedCharactersAtIndex = CFStringGetRangeOfComposedCharactersAtIndex(theString, v89 + location);
                v92 = __src;
                v91 = 1;
                if (RangeOfComposedCharactersAtIndex.length <= 6
                  && RangeOfComposedCharactersAtIndex.location < __src + location)
                {
                  v94 = CFStringEncodingUnicodeToBytes(a4, v104, buffera, RangeOfComposedCharactersAtIndex.location - location, &__src, (unsigned int *)v9, v8, &v110);
                  LOBYTE(v108) = BYTE2(v94);
                  v91 = v94 & 0xFF00FFFF;
                  v92 = __src;
                }
              }
              if (v91 && v87 >= 1 && v92 <= 5)
              {
                v95 = CFStringGetRangeOfComposedCharactersAtIndex(theString, location);
                if (v95.length > 6)
                  goto LABEL_248;
                if (v95.location >= location)
                  goto LABEL_248;
                CFStringGetCharacters(theString, v95, buffera);
                if (CFStringEncodingUnicodeToBytes(a4, v86, buffera, v95.length, &__src, 0, 0, &v110))
                  goto LABEL_248;
                location -= v87;
                v134.location = location;
                v134.length = v95.location - location;
                CFStringGetCharacters(theString, v134, buffera);
                v96 = v8 ? (unsigned int *)((char *)v9 - v88) : 0;
                v97 = v8 ? v8 + v88 : 0;
                v98 = CFStringEncodingUnicodeToBytes(a4, v104, buffera, v95.location - location, &__src, v96, v97, &v110);
                if ((v98 & 0xFF00FFFF) != 0)
                {
LABEL_248:
                  v112 += v110;
                  v111 += __src;
                  goto LABEL_249;
                }
                v108 = HIWORD(v98);
                v112 -= v88;
                v111 -= v87;
                length += v87;
                if (v8)
                  v9 = (UniChar *)((char *)v9 - v88);
                v8 = v97;
              }
              else if (v91)
              {
                goto LABEL_248;
              }
            }
            v88 = v110;
            v87 = __src;
            v112 += v110;
            v111 += __src;
            if (v8)
            {
              v8 -= v110;
              if (v8 < 1)
                goto LABEL_249;
              v9 = (UniChar *)((char *)v9 + v110);
            }
            location += __src;
            v86 = v102;
            v45 = length <= __src;
            length -= __src;
            if (v45)
              goto LABEL_249;
          }
        }
        goto LABEL_116;
      }
      v56 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding(0);
        v56 = __CFDefaultEightBitStringEncoding;
      }
      PascalStringPtr = CFStringGetPascalStringPtr(theString, v56);
      if (PascalStringPtr)
      {
        v27 = &PascalStringPtr[location + 1];
        v58 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          v107 = v23;
          v59 = (uint64_t)&PascalStringPtr[location + 1];
          __CFStringComputeEightBitStringEncoding(PascalStringPtr);
          v27 = (const unsigned __int8 *)v59;
          v23 = v107;
          v58 = __CFDefaultEightBitStringEncoding;
        }
        if (v58 != (_DWORD)a4)
        {
          if ((*(char *)v27 & 0x80000000) == 0 && length >= 1)
          {
            v33 = v27;
            do
            {
              v80 = *(char *)++v33;
              v81 = length-- != 0;
            }
            while ((v80 & 0x80000000) == 0 && length != 0 && v81);
            goto LABEL_188;
          }
          goto LABEL_187;
        }
LABEL_116:
        if (length < v8 || v9 == 0)
          v61 = length;
        else
          v61 = v8;
        if (v9)
          memmove(v9, v27, v61);
        goto LABEL_127;
      }
    }
    v62 = 0;
    if (!v9)
      goto LABEL_196;
    goto LABEL_125;
  }
LABEL_126:
  v61 = 0;
LABEL_127:
  if (v109)
    *v109 = v61;
  return v61;
}

Boolean CFStringFindWithOptionsAndLocale(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFLocaleRef locale, CFRange *result)
{
  CFIndex length;
  CFIndex location;
  CFIndex v12;
  uint64_t v13;
  _BOOL4 v14;
  CFCharacterSetRef *v15;
  int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  const __CFLocale *v20;
  const __CFString *CharactersPtr;
  uint64_t v22;
  const __CFString *v23;
  CFIndex v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  char v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  BOOL v49;
  _BOOL4 v50;
  unint64_t v52;
  UniChar v53;
  uint64_t v54;
  BOOL v55;
  char v56;
  unint64_t v57;
  int v58;
  unsigned int v59;
  uint64_t v60;
  BOOL v61;
  char v62;
  int v63;
  BOOL v64;
  char v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _BOOL4 v74;
  unsigned __int8 v75;
  BOOL v76;
  int v77;
  unint64_t v79;
  __int16 v80;
  CFIndex v81;
  UniChar *v82;
  CFIndex v83;
  UniChar v84;
  uint64_t v85;
  unint64_t v86;
  unsigned int v87;
  BOOL v88;
  char v89;
  unint64_t v90;
  unsigned int *v91;
  uint64_t v92;
  uint64_t v93;
  UniChar v94;
  uint64_t v95;
  uint64_t v96;
  unsigned int *v97;
  unsigned int *v98;
  uint64_t v99;
  uint64_t v100;
  CFIndex v101;
  UniChar v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  BOOL v106;
  char v107;
  unsigned int v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  _BOOL4 v112;
  int v113;
  BOOL v114;
  CFIndex v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  UniChar v120;
  int v121;
  unsigned int v122;
  uint64_t v123;
  BOOL v124;
  char v125;
  int v126;
  BOOL v127;
  char v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  CFIndex v134;
  unsigned int v135;
  uint64_t v136;
  _BOOL4 v137;
  uint64_t UnicodePropertyDataForPlane;
  int v139;
  unsigned __int8 v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  UniChar v146;
  unsigned int Script;
  uint64_t v148;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  CFIndex v153;
  int v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  UniChar v160;
  unsigned int v161;
  BOOL v163;
  BOOL v164;
  BOOL v165;
  char v166;
  char v167;
  unsigned int v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  _BOOL4 v176;
  uint64_t i;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  UniChar v181;
  CFIndex v182;
  UniChar v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  UniChar *v191;
  uint64_t v192;
  uint64_t v193;
  CFRange v194;
  char *v195;
  uint64_t v196;
  UniChar *v197;
  UniChar v198;
  BOOL v199;
  CFRange v200;
  char *v201;
  uint64_t v202;
  UniChar *v203;
  UniChar v204;
  uint64_t v205;
  CFRange v206;
  char *v207;
  UniChar *v208;
  UniChar v209;
  unsigned int v210;
  unsigned int v211;
  uint64_t v212;
  uint64_t v213;
  _BOOL4 v214;
  BOOL v215;
  int v216;
  uint64_t v217;
  unint64_t v218;
  uint64_t v219;
  uint64_t v220;
  CFIndex v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  UTF32Char v231;
  UTF32Char v232;
  uint64_t v233;
  UniChar *v234;
  uint64_t v235;
  UniChar v236;
  CFIndex v237;
  UniChar *v238;
  CFIndex v239;
  UniChar v240;
  int v241;
  uint64_t v242;
  uint64_t v243;
  UniChar *v244;
  uint64_t v245;
  UniChar v246;
  CFIndex v247;
  UniChar *v248;
  CFIndex v249;
  UniChar v250;
  int v251;
  char v252;
  unsigned int v253;
  BOOL v254;
  char v255;
  int IsLongCharacterMember;
  BOOL v257;
  char v258;
  unsigned int v259;
  uint64_t v260;
  uint64_t v263;
  _BOOL4 v264;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  unsigned int v272;
  BOOL v273;
  BOOL v274;
  int v275;
  BOOL v276;
  char v277;
  char v278;
  unsigned int v279;
  uint64_t v280;
  _BOOL4 v281;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  _BOOL4 v286;
  uint64_t v287;
  int v288;
  uint64_t v289;
  int v290;
  UTF32Char v291;
  uint64_t v292;
  uint64_t v293;
  _BOOL4 v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v299;
  uint64_t v300;
  uint64_t RangeOfCharacterClusterAtIndex;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  char v310;
  unsigned int v311;
  uint64_t v312;
  uint64_t v313;
  UniChar *v314;
  uint64_t v315;
  UniChar v316;
  unsigned int v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  UniChar v321;
  UniChar *v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  UniChar *v326;
  uint64_t v327;
  UniChar v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  int v337;
  uint64_t v338;
  int *v339;
  CFIndex v340;
  UniChar *v341;
  CFIndex v342;
  UniChar v343;
  UTF32Char v344;
  int v345;
  unsigned int v346;
  uint64_t v347;
  BOOL v348;
  char v349;
  uint64_t v350;
  int v351;
  uint64_t v352;
  CFIndex v353;
  UniChar *v354;
  CFIndex v355;
  UniChar v356;
  BOOL v357;
  char v358;
  uint64_t v359;
  uint64_t v360;
  unsigned int v361;
  uint64_t v362;
  _BOOL4 v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  UniChar v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  UniChar v380;
  uint64_t v381;
  uint64_t v382;
  unsigned int v383;
  char v384;
  uint64_t v385;
  uint64_t v386;
  char v387;
  uint64_t v388;
  UniChar v389;
  UTF32Char v390;
  int v391;
  unsigned int v392;
  uint64_t v393;
  BOOL v394;
  char v395;
  uint64_t v396;
  int v397;
  BOOL v398;
  char v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  UniChar v404;
  unsigned int v405;
  uint64_t v406;
  _BOOL4 v407;
  uint64_t v408;
  uint64_t v409;
  int MatchedLength;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  __CFString *v415;
  char v416;
  uint64_t *v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  CFRange *v421;
  int v422[2];
  int *v423;
  uint64_t v424;
  UTF32Char *v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t BitmapPtrForPlane;
  uint64_t v431;
  CFCharacterSetRef *v432;
  UTF32Char *v433;
  uint64_t v434;
  uint64_t v435;
  CFStringCompareFlags v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  __int16 v441;
  unsigned int v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t *v446;
  uint64_t v447;
  uint64_t v448;
  unint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  CFStringCompareFlags v453;
  char *SpecialCaseHandlingLanguageIdentifierForLocale;
  _DWORD *v455;
  int v456;
  int v457;
  uint64_t v458;
  CFIndex v459;
  uint64_t v460;
  uint64_t CStringPtrInternal;
  uint64_t v462;
  int v463;
  CFIndex v464;
  uint64_t v465;
  uint64_t v466;
  CFCharacterSetRef theSet[2];
  __int128 v468;
  int v469;
  UniChar v470[8];
  __int128 v471;
  __int128 v472;
  __int128 v473;
  __int128 v474;
  __int128 v475;
  __int128 v476;
  __int128 v477;
  CFStringRef v478[2];
  CFRange v479;
  __int128 v480;
  CFIndex v481;
  UniChar v482[8];
  __int128 v483;
  __int128 v484;
  __int128 v485;
  __int128 v486;
  __int128 v487;
  __int128 v488;
  __int128 v489;
  CFStringRef v490[2];
  CFRange range;
  __int128 v492;
  CFIndex v493;
  UniChar buffer[8];
  __int128 v496;
  __int128 v497;
  __int128 v498;
  __int128 v499;
  __int128 v500;
  __int128 v501;
  __int128 v502;
  CFStringRef v503[2];
  __int128 v504;
  __int128 v505;
  uint64_t v506;
  unsigned int __s2[64];
  unsigned int __s1[64];
  uint64_t v509;
  CFRange v510;
  CFRange v511;
  CFRange v512;
  CFRange v513;
  CFRange v514;
  CFRange v515;
  CFRange v516;
  CFRange v517;
  CFRange v518;
  CFRange v519;
  CFRange v520;
  CFRange v521;
  CFRange v522;
  CFRange v523;
  CFRange v524;
  CFRange v525;
  CFRange v526;
  CFRange v527;
  CFRange v528;
  CFRange v529;
  CFRange v530;
  CFRange v531;

  length = rangeToSearch.length;
  location = rangeToSearch.location;
  v509 = *MEMORY[0x1E0C80C00];
  v12 = CFStringGetLength(stringToFind);
  *(_OWORD *)theSet = 0u;
  v468 = 0u;
  v13 = __CFStringFillCharacterSetInlineBuffer((uint64_t)theSet, searchOptions);
  LOBYTE(v14) = 0;
  if ((_DWORD)v13)
    v15 = theSet;
  else
    v15 = 0;
  v432 = v15;
  if ((searchOptions & 0x91) != 0)
    v16 = 1;
  else
    v16 = v13;
  if (v12 <= (unint64_t)length)
    v17 = 1;
  else
    v17 = v16;
  v464 = v12;
  if (v12 < 1 || length < 1 || !v17)
    return v14;
  v463 = v13;
  v506 = 0;
  v504 = 0u;
  v505 = 0u;
  v502 = 0u;
  *(_OWORD *)v503 = 0u;
  v500 = 0u;
  v501 = 0u;
  v498 = 0u;
  v499 = 0u;
  v496 = 0u;
  v497 = 0u;
  *(_OWORD *)buffer = 0u;
  v493 = 0;
  range = (CFRange)0;
  v492 = 0u;
  v489 = 0u;
  *(_OWORD *)v490 = 0u;
  v487 = 0u;
  v488 = 0u;
  v485 = 0u;
  v486 = 0u;
  v483 = 0u;
  v484 = 0u;
  *(_OWORD *)v482 = 0u;
  v18 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding(v13);
    v18 = __CFDefaultEightBitStringEncoding;
  }
  CStringPtrInternal = _CFStringGetCStringPtrInternal((uint64_t)theString, v18, 0, 1);
  v458 = _CFStringGetCStringPtrInternal((uint64_t)stringToFind, v18, 0, 1);
  *(_QWORD *)v422 = location;
  v19 = location + length;
  if (locale)
  {
    SpecialCaseHandlingLanguageIdentifierForLocale = (char *)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 1);
  }
  else if ((searchOptions & 0x20) != 0)
  {
    v20 = CFLocaleCopyCurrent();
    SpecialCaseHandlingLanguageIdentifierForLocale = (char *)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(v20, 1);
    CFRelease(v20);
  }
  else
  {
    SpecialCaseHandlingLanguageIdentifierForLocale = 0;
  }
  v503[0] = theString;
  *((_QWORD *)&v504 + 1) = 0;
  *(_QWORD *)&v505 = v19;
  CharactersPtr = (const __CFString *)CFStringGetCharactersPtr(theString);
  v22 = 0;
  v503[1] = CharactersPtr;
  if (!CharactersPtr)
    v22 = _CFStringGetCStringPtrInternal((uint64_t)theString, 0x600u, 0, 1);
  v506 = 0;
  *(_QWORD *)&v504 = v22;
  *((_QWORD *)&v505 + 1) = 0;
  v490[0] = stringToFind;
  range.length = 0;
  *(_QWORD *)&v492 = v464;
  v23 = (const __CFString *)CFStringGetCharactersPtr(stringToFind);
  v24 = 0;
  v490[1] = v23;
  if (!v23)
    v24 = _CFStringGetCStringPtrInternal((uint64_t)stringToFind, 0x600u, 0, 1);
  v415 = (__CFString *)stringToFind;
  v453 = searchOptions & 1;
  v493 = 0;
  range.location = v24;
  *((_QWORD *)&v492 + 1) = 0;
  v421 = result;
  if ((searchOptions & 4) != 0)
  {
    v29 = v464;
    if (v16)
      v29 = 1;
    v27 = v19 - v29;
    if ((searchOptions & 8) != 0)
      v30 = v16;
    else
      v30 = 1;
    if (v30)
      v28 = *(_QWORD *)v422;
    else
      v28 = v27;
  }
  else
  {
    v25 = v464;
    if (v16)
      v25 = 1;
    v26 = v19 - v25;
    v27 = *(_QWORD *)v422;
    if ((searchOptions & 8) != 0)
      v28 = *(_QWORD *)v422;
    else
      v28 = v26;
  }
  v31 = v463;
  v457 = (searchOptions >> 8) & 1 | v16;
  v436 = searchOptions & 0xC;
  v431 = v28;
  if (v27 > v28)
    v32 = -1;
  else
    v32 = 1;
  v460 = v19;
  v441 = searchOptions;
  if (!CStringPtrInternal || !v458)
  {
    if (!((searchOptions >> 8) & 1 | v16 & 1))
    {
      for (i = v32; ; v27 += i)
      {
        v178 = 0;
        v179 = v27;
        while (1)
        {
          if (v179 < 0 || (v180 = v505, (uint64_t)v505 <= v179))
          {
            v181 = 0;
          }
          else if (v503[1])
          {
            v181 = *((_WORD *)&v503[1]->isa + *((_QWORD *)&v504 + 1) + v179);
          }
          else if ((_QWORD)v504)
          {
            v181 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v179);
          }
          else
          {
            if (v506 <= v179 || (v186 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) > v179))
            {
              v187 = v179 - 4;
              if ((unint64_t)v179 < 4)
                v187 = 0;
              if (v187 + 64 < (uint64_t)v505)
                v180 = v187 + 64;
              *((_QWORD *)&v505 + 1) = v187;
              v506 = v180;
              v518.location = *((_QWORD *)&v504 + 1) + v187;
              v518.length = v180 - v187;
              CFStringGetCharacters(v503[0], v518, buffer);
              v186 = *((_QWORD *)&v505 + 1);
            }
            v181 = buffer[v179 - v186];
          }
          v182 = v492;
          if ((uint64_t)v492 <= v178)
          {
            v183 = 0;
          }
          else if (v490[1])
          {
            v183 = *((_WORD *)&v490[1]->isa + range.length + v178);
          }
          else if (range.location)
          {
            v183 = *(char *)(range.location + range.length + v178);
          }
          else
          {
            if (v493 <= v178 || (v184 = *((_QWORD *)&v492 + 1), *((uint64_t *)&v492 + 1) > v178))
            {
              v185 = v178 - 4;
              if ((unint64_t)v178 < 4)
                v185 = 0;
              if (v185 + 64 < (uint64_t)v492)
                v182 = v185 + 64;
              *((_QWORD *)&v492 + 1) = v185;
              v493 = v182;
              v517.location = range.length + v185;
              v517.length = v182 - v185;
              CFStringGetCharacters(v490[0], v517, v482);
              v184 = *((_QWORD *)&v492 + 1);
            }
            v183 = v482[v178 - v184];
          }
          if (v181 != v183)
            break;
          ++v179;
          if (++v178 == v464)
            goto LABEL_446;
        }
        if (v178 == v464)
        {
LABEL_446:
          if (v421)
          {
            v421->location = v27;
            v421->length = v464;
          }
          goto LABEL_453;
        }
        if (v27 == v431)
          goto LABEL_1100;
      }
    }
    v465 = 0;
    v466 = 0;
    BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x6Eu, 0);
    UnicodePropertyDataForPlane = CFUniCharGetUnicodePropertyDataForPlane(0, 0);
    v139 = v463;
    v140 = searchOptions;
    v414 = UnicodePropertyDataForPlane;
    if ((searchOptions & 0x10000) != 0)
      goto LABEL_521;
    v141 = 0;
    v142 = 0;
    *(_OWORD *)v478 = *(_OWORD *)v490;
    v479 = range;
    v480 = v492;
    v481 = v493;
    v474 = v486;
    v475 = v487;
    v476 = v488;
    v477 = v489;
    *(_OWORD *)v470 = *(_OWORD *)v482;
    v471 = v483;
    v472 = v484;
    v473 = v485;
    v143 = 64;
    v469 = 0;
    while (1)
    {
      if ((unint64_t)v142 >= 4)
        v144 = 4;
      else
        v144 = v142;
      v145 = v480;
      if ((uint64_t)v480 <= v142)
      {
        v146 = 0;
      }
      else if (v478[1])
      {
        v146 = *((_WORD *)&v478[1]->isa + v142 + v479.length);
      }
      else if (v479.location)
      {
        v146 = *(char *)(v479.location + v479.length + v142);
      }
      else
      {
        v148 = *((_QWORD *)&v480 + 1);
        if (v481 <= v142 || *((_QWORD *)&v480 + 1) > v142)
        {
          v150 = v144 + v141;
          v151 = v143 - v144;
          v152 = v142 - v144;
          v153 = v152 + 64;
          if (v152 + 64 >= (uint64_t)v480)
            v153 = v480;
          *((_QWORD *)&v480 + 1) = v152;
          v481 = v153;
          if ((uint64_t)v480 >= v151)
            v145 = v151;
          v515.length = v145 + v150;
          v515.location = v152 + v479.length;
          CFStringGetCharacters(v478[0], v515, v470);
          v148 = *((_QWORD *)&v480 + 1);
        }
        v146 = v470[v142 - v148];
      }
      if (u_isdigit(v146))
        goto LABEL_456;
      Script = uscript_getScript();
      v139 = v463;
      if (v469 > 0)
        goto LABEL_519;
      if (Script)
        break;
      ++v142;
      --v141;
      ++v143;
      if (v464 == v142)
        goto LABEL_519;
    }
    if (Script > 0xF || ((1 << Script) & 0x8410) == 0)
    {
      v140 = searchOptions;
      v139 = v463;
LABEL_520:
      UnicodePropertyDataForPlane = v414;
LABEL_521:
      v418 = 0;
      v419 = 0;
      v413 = 0;
      v212 = 0;
      v213 = 0;
      v214 = v436 == 8;
      if (v453)
        v215 = SpecialCaseHandlingLanguageIdentifierForLocale == 0;
      else
        v215 = 1;
      v216 = !v215;
      v217 = (uint64_t)&theSet[1];
      if (!v139)
        v217 = 8;
      v423 = (int *)v217;
      v424 = 0;
      v218 = (unint64_t)theSet | 0xC;
      if (!v139)
        v218 = 12;
      v433 = (UTF32Char *)v218;
      v219 = (uint64_t)&v468;
      if (!v139)
        v219 = 16;
      v425 = (UTF32Char *)v219;
      v220 = (uint64_t)&v468 + 8;
      if (!v139)
        v220 = 24;
      v417 = (uint64_t *)v220;
      v416 = v139 ^ 1;
      v420 = v140 & 0x90;
      v412 = UnicodePropertyDataForPlane + 256;
      v426 = v32;
      v445 = v27;
      v221 = v27;
      v456 = v216;
      while (1)
      {
        v222 = 0;
        v223 = 0;
        v224 = 0;
        v434 = 0;
        v435 = 0;
        v427 = 0;
        v428 = 0;
        v225 = v221;
        v459 = v221;
        while (1)
        {
          v438 = v225;
          v440 = v222;
          v443 = v223;
          v226 = v224;
          v437 = v224;
LABEL_538:
          v227 = v222 - 4;
          if ((unint64_t)v222 < 4)
            v227 = 0;
          v448 = v227;
          v447 = v227 + 64;
          v228 = v222 + 1;
          v229 = v222 - 3;
          if ((unint64_t)(v222 + 1) < 4)
            v229 = 0;
          v452 = v229;
          v450 = v229 + 64;
          if (v226 <= 0)
            v230 = 0;
          else
            v230 = -1;
          v462 = v226;
          if (v223)
          {
LABEL_546:
            v231 = __s1[v212++];
            if (!v226)
              goto LABEL_555;
LABEL_547:
            v232 = __s2[v213++];
            goto LABEL_562;
          }
          while (1)
          {
            if (v225 < 0 || (v233 = v505, (uint64_t)v505 <= v225))
            {
              v231 = 0;
              goto LABEL_554;
            }
            v234 = (UniChar *)v503[1];
            if (v503[1])
            {
              v235 = *((_QWORD *)&v504 + 1) + v225;
            }
            else
            {
              if ((_QWORD)v504)
              {
                v236 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v225);
                goto LABEL_625;
              }
              if (v506 <= v225 || (v269 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) > v225))
              {
                v270 = v225 - 4;
                if ((unint64_t)v225 < 4)
                  v270 = 0;
                if (v270 + 64 < (uint64_t)v505)
                  v233 = v270 + 64;
                *((_QWORD *)&v505 + 1) = v270;
                v506 = v233;
                v521.location = *((_QWORD *)&v504 + 1) + v270;
                v521.length = v233 - v270;
                CFStringGetCharacters(v503[0], v521, buffer);
                v226 = v462;
                v216 = v456;
                v214 = v436 == 8;
                v221 = v459;
                v139 = v463;
                v269 = *((_QWORD *)&v505 + 1);
              }
              v235 = v225 - v269;
              v234 = buffer;
            }
            v236 = v234[v235];
LABEL_625:
            v231 = v236;
            if (v453 && v236 >= 0x41u && v236 <= 0x5Au)
            {
              if (v236 != 73 || SpecialCaseHandlingLanguageIdentifierForLocale == 0)
                v231 = v236 + 32;
              else
                v231 = 73;
            }
LABEL_554:
            v466 = 1;
            if (v226)
              goto LABEL_547;
LABEL_555:
            if ((v222 & 0x8000000000000000) == 0)
            {
              v237 = v492;
              if ((uint64_t)v492 > v222)
              {
                v238 = (UniChar *)v490[1];
                if (v490[1])
                {
                  v239 = range.length + v222;
                  goto LABEL_559;
                }
                if (range.location)
                {
                  v240 = *(char *)(range.location + range.length + v222);
                }
                else
                {
                  if (v493 <= v222 || (v271 = *((_QWORD *)&v492 + 1), *((uint64_t *)&v492 + 1) > v222))
                  {
                    if (v447 < (uint64_t)v492)
                      v237 = v447;
                    *((_QWORD *)&v492 + 1) = v448;
                    v493 = v237;
                    v522.location = range.length + v448;
                    v522.length = v237 - v448;
                    CFStringGetCharacters(v490[0], v522, v482);
                    v226 = v462;
                    v216 = v456;
                    v214 = v436 == 8;
                    v221 = v459;
                    v139 = v463;
                    v271 = *((_QWORD *)&v492 + 1);
                  }
                  v239 = v222 - v271;
                  v238 = v482;
LABEL_559:
                  v240 = v238[v239];
                }
                v232 = v240;
                if (v453 && v240 >= 0x41u && v240 <= 0x5Au)
                {
                  if (v240 != 73 || SpecialCaseHandlingLanguageIdentifierForLocale == 0)
                    v232 = v240 + 32;
                  else
                    v232 = 73;
                }
                goto LABEL_561;
              }
            }
            v232 = 0;
LABEL_561:
            v465 = 1;
LABEL_562:
            if (v231 == v232)
            {
              v224 = v226;
              goto LABEL_777;
            }
            if ((v232 | v231) > 0x7F)
              v241 = 1;
            else
              v241 = v139;
            if ((v241 | v216) != 1)
            {
              v310 = 1;
              goto LABEL_825;
            }
            if ((v231 & 0xFC00) == 0xD800 && v225 >= -1)
            {
              v242 = v225 + 1;
              v243 = v505;
              if ((uint64_t)v505 <= v225 + 1)
              {
                v19 = v460;
                goto LABEL_578;
              }
              v244 = (UniChar *)v503[1];
              if (v503[1])
              {
                v245 = *((_QWORD *)&v504 + 1) + v242;
                goto LABEL_572;
              }
              if ((_QWORD)v504)
              {
                v246 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v242);
              }
              else
              {
                if (v506 <= v242 || (v267 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) > v242))
                {
                  v268 = v225 - 3;
                  if ((unint64_t)v242 < 4)
                    v268 = 0;
                  if (v268 + 64 < (uint64_t)v505)
                    v243 = v268 + 64;
                  *((_QWORD *)&v505 + 1) = v268;
                  v506 = v243;
                  v520.location = *((_QWORD *)&v504 + 1) + v268;
                  v520.length = v243 - v268;
                  CFStringGetCharacters(v503[0], v520, buffer);
                  v226 = v462;
                  v216 = v456;
                  v214 = v436 == 8;
                  v221 = v459;
                  v139 = v463;
                  v267 = *((_QWORD *)&v505 + 1);
                }
                v245 = v242 - v267;
                v244 = buffer;
LABEL_572:
                v246 = v244[v245];
              }
              v19 = v460;
              if (v246 >> 10 == 55)
              {
                v231 = ((unsigned __int16)v231 << 10) - 56613888 + v246;
                v466 = 2;
              }
            }
LABEL_578:
            if ((v232 & 0xFC00) != 0xD800)
              goto LABEL_588;
            if (v222 < -1)
              goto LABEL_588;
            v247 = v492;
            if ((uint64_t)v492 <= v228)
              goto LABEL_588;
            v248 = (UniChar *)v490[1];
            if (v490[1])
            {
              v249 = range.length + v228;
LABEL_583:
              v250 = v248[v249];
              goto LABEL_586;
            }
            if (!range.location)
            {
              if (v493 <= v228 || (v263 = *((_QWORD *)&v492 + 1), *((uint64_t *)&v492 + 1) > v228))
              {
                if (v450 < (uint64_t)v492)
                  v247 = v450;
                *((_QWORD *)&v492 + 1) = v452;
                v493 = v247;
                v519.location = range.length + v452;
                v519.length = v247 - v452;
                CFStringGetCharacters(v490[0], v519, v482);
                v226 = v462;
                v216 = v456;
                v214 = v436 == 8;
                v221 = v459;
                v139 = v463;
                v263 = *((_QWORD *)&v492 + 1);
              }
              v249 = v228 - v263;
              v248 = v482;
              goto LABEL_583;
            }
            v250 = *(char *)(range.location + range.length + v228);
LABEL_586:
            if (v250 >> 10 == 55)
            {
              v232 = ((unsigned __int16)v232 << 10) - 56613888 + v250;
              v465 = 2;
            }
LABEL_588:
            if (!v139)
            {
              v225 = v438;
              v222 = v440;
              v224 = v437;
              goto LABEL_724;
            }
            v251 = v225 != v221 || v214;
            v252 = (char)theSet[1];
            if (v251 != 1 || v225 >= v19)
              goto LABEL_685;
            v253 = (uint64_t)theSet[1] & 4;
            if (HIDWORD(theSet[1]) > v231 || v468 <= v231)
            {
              if (((uint64_t)theSet[1] & 4) == 0)
                goto LABEL_685;
              goto LABEL_654;
            }
            if (HIWORD(v231) || ((uint64_t)theSet[1] & 2) != 0)
              break;
            if (*((_QWORD *)&v468 + 1))
            {
              if (((uint64_t)theSet[1] & 1) != 0)
              {
                v259 = v253 >> 2;
                v260 = *(unsigned __int8 *)(*((_QWORD *)&v468 + 1) + ((unint64_t)v231 >> 8));
                if (!*(_BYTE *)(*((_QWORD *)&v468 + 1) + ((unint64_t)v231 >> 8)))
                  goto LABEL_621;
                if ((_DWORD)v260 == 255)
                {
                  v259 = v253 == 0;
LABEL_621:
                  if (!v259)
                    goto LABEL_685;
                  goto LABEL_654;
                }
                v264 = v253 == 0;
                if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v468 + 1)
                                                            + 32 * v260
                                                            + (v231 >> 3)
                                                            + 224) >> (v231 & 7)) & 1) != 0)
                  v259 = v264;
                if (!v259)
                  goto LABEL_685;
              }
              else
              {
                v49 = v253 == 0;
                v254 = v253 != 0;
                v255 = v49;
                if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v468 + 1) + ((unint64_t)v231 >> 3)) >> (v231 & 7)) & 1) != 0)
                  v254 = v255;
                if (!v254)
                  goto LABEL_685;
              }
            }
            else
            {
              v49 = v253 == 0;
              v257 = v253 != 0;
              v258 = v49;
              if (((uint64_t)theSet[1] & 1) == 0)
                v257 = v258;
              if (!v257)
                goto LABEL_685;
            }
LABEL_654:
            if (v212 == v223 && v223 > 0)
              v223 = 0;
            v266 = v466;
            if (v223)
              v266 = 0;
            v225 += v266;
            v213 += v230;
            if (v223)
              goto LABEL_546;
          }
          IsLongCharacterMember = CFCharacterSetIsLongCharacterMember(theSet[0], v231);
          v226 = v462;
          v216 = v456;
          v214 = v436 == 8;
          v221 = v459;
          v139 = v463;
          if (IsLongCharacterMember)
            goto LABEL_654;
          v252 = (char)theSet[1];
LABEL_685:
          v272 = v252 & 4;
          if (HIDWORD(theSet[1]) > v232 || v468 <= v232)
          {
            if ((v252 & 4) == 0)
              goto LABEL_798;
            goto LABEL_713;
          }
          if (HIWORD(v232) || (v252 & 2) != 0)
          {
            v275 = CFCharacterSetIsLongCharacterMember(theSet[0], v232);
            v226 = v462;
            v216 = v456;
            v214 = v436 == 8;
            v221 = v459;
            v139 = v463;
            if (!v275)
              goto LABEL_798;
            goto LABEL_713;
          }
          if (!*((_QWORD *)&v468 + 1))
          {
            v49 = v272 == 0;
            v276 = v272 != 0;
            v277 = v49;
            if ((v252 & 1) != 0)
              v278 = v276;
            else
              v278 = v277;
            if ((v278 & 1) == 0)
              goto LABEL_798;
            goto LABEL_713;
          }
          if ((v252 & 1) == 0)
            break;
          v279 = v272 >> 2;
          v280 = *(unsigned __int8 *)(*((_QWORD *)&v468 + 1) + ((unint64_t)v232 >> 8));
          if (*(_BYTE *)(*((_QWORD *)&v468 + 1) + ((unint64_t)v232 >> 8)))
          {
            if ((_DWORD)v280 == 255)
            {
              v279 = v272 == 0;
            }
            else
            {
              v281 = v272 == 0;
              if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v468 + 1)
                                                          + 32 * v280
                                                          + (v232 >> 3)
                                                          + 224) >> (v232 & 7)) & 1) != 0)
                v279 = v281;
            }
          }
          if (v279)
            goto LABEL_713;
LABEL_798:
          v224 = v226;
          v443 = v223;
LABEL_724:
          v284 = v434;
          if ((v441 & 0x80) == 0 || v225 <= v221)
            goto LABEL_751;
          if (v223)
          {
            v285 = v225;
            goto LABEL_728;
          }
          v287 = BitmapPtrForPlane;
          if (v231 >= 0x10000)
          {
            v287 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v231));
            v284 = v434;
            v226 = v462;
            v216 = v456;
            v214 = v436 == 8;
            v221 = v459;
            v139 = v463;
          }
          v285 = v225;
          if (!v287)
          {
LABEL_728:
            v286 = 0;
            if (!v226)
              goto LABEL_736;
LABEL_747:
            if (v286)
              v222 -= v465;
            goto LABEL_750;
          }
          v288 = (1 << (v231 & 7)) & *(unsigned __int8 *)(v287 + ((unsigned __int16)v231 >> 3));
          v286 = v288 != 0;
          if (v288)
            v231 = v232;
          if (v226)
            goto LABEL_747;
LABEL_736:
          v289 = BitmapPtrForPlane;
          if (v232 >= 0x10000)
          {
            v434 = v284;
            v289 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v232));
            v284 = v434;
            v226 = v462;
            v216 = v456;
            v214 = v436 == 8;
            v221 = v459;
            v139 = v463;
          }
          if (!v289)
            goto LABEL_747;
          v290 = (1 << (v232 & 7)) & *(unsigned __int8 *)(v289 + ((unsigned __int16)v232 >> 3));
          if (v290)
            v291 = v231;
          else
            v291 = v232;
          if (((v286 ^ (v290 != 0)) & 1) != 0)
          {
            v292 = v465;
            if (!v286)
              v292 = 0;
            v222 -= v292;
            if (v290)
            {
              v225 = v285 - v466;
              v232 = v231;
              goto LABEL_751;
            }
          }
          else
          {
            v232 = v291;
          }
LABEL_750:
          v225 = v285;
LABEL_751:
          v293 = v435;
          if (v231 == v232)
          {
LABEL_752:
            v223 = v443;
            goto LABEL_757;
          }
          if (v223)
          {
            v294 = 0;
            v295 = v424;
            goto LABEL_755;
          }
          if (!v418 || v418 == v225)
          {
            v295 = v424;
            v212 = v225 - v424 + 1;
            if (v419 < 1 || v225 < v424 || v225 >= v413 + v424 || v212 >= v419)
            {
              v434 = v284;
              LOBYTE(v470[0]) = 0;
              v419 = __CFStringFoldCharacterClusterAtIndex(v231, buffer, v225, v441, SpecialCaseHandlingLanguageIdentifierForLocale, __s1, &v466, v470);
              if (v419 > 0)
              {
                v212 = 1;
                v231 = __s1[0];
              }
              v413 = v466;
              if (LOBYTE(v470[0]))
              {
                RangeOfCharacterClusterAtIndex = CFStringGetRangeOfCharacterClusterAtIndex((__CFString *)theString, v225, 1);
                v303 = RangeOfCharacterClusterAtIndex + v302;
                v304 = 2;
                if (RangeOfCharacterClusterAtIndex > 2)
                  v304 = RangeOfCharacterClusterAtIndex;
                v305 = v304 - 1;
                if (v445 > v431)
                  v303 = v305;
                v418 = v303;
              }
              else
              {
                v418 = 0;
              }
              v295 = v225;
              v296 = v419;
              v139 = v463;
              v221 = v459;
              v214 = v436 == 8;
              v216 = v456;
              v226 = v462;
              v284 = v434;
              goto LABEL_817;
            }
            v294 = 0;
            v418 = 0;
            v231 = __s1[v225 - v424];
            v443 = v419;
          }
          else
          {
            v296 = 0;
            v295 = v424;
LABEL_817:
            v294 = v296 == 0;
            v443 = v296;
            if (!v296 && v224 > 0)
            {
              v424 = v295;
              v223 = 0;
              goto LABEL_906;
            }
          }
LABEL_755:
          v424 = v295;
          if (!v226)
          {
            if (v231 != v232)
              v294 = 1;
            if (!v294)
              goto LABEL_776;
            if (!v435 || v435 == v222)
            {
              v213 = v222 - v284 + 1;
              if (v428 < 1 || v222 < v284 || v222 >= v427 + v284 || v213 >= v428)
              {
                LOBYTE(v470[0]) = 0;
                v306 = __CFStringFoldCharacterClusterAtIndex(v232, v482, v222, v441, SpecialCaseHandlingLanguageIdentifierForLocale, __s2, &v465, v470);
                v427 = v465;
                v428 = v306;
                if (LOBYTE(v470[0]))
                {
                  v307 = CFStringGetRangeOfCharacterClusterAtIndex(v415, v222, 1);
                  v309 = v307 + v308;
                }
                else
                {
                  v309 = 0;
                }
                v139 = v463;
                v221 = v459;
                v214 = v436 == 8;
                v216 = v456;
                v223 = v443;
                if (!v428 || v231 != __s2[0])
                  goto LABEL_906;
                v284 = v222;
                v224 = v428;
                v213 = 1;
                v293 = v309;
                goto LABEL_757;
              }
              if (v231 == __s2[v222 - v284])
              {
                v293 = 0;
                v224 = v428;
                goto LABEL_752;
              }
            }
            else if (v231 == v232)
            {
LABEL_776:
              v224 = 0;
              v223 = v443;
              goto LABEL_777;
            }
            v223 = v443;
            goto LABEL_906;
          }
          v223 = v443;
          v293 = v435;
LABEL_757:
          v435 = v293;
          if (v223 < 1 || v224 < 1)
          {
            v434 = v284;
          }
          else
          {
            while (v212 < v223 && v213 < v224)
            {
              if (__s1[v212] != __s2[v213])
                goto LABEL_906;
              ++v212;
              ++v213;
            }
            v434 = v284;
            if (v212 < v223 && v213 < v224)
              goto LABEL_906;
          }
LABEL_777:
          if (v212 == v223 && v223 > 0)
            v223 = 0;
          if (v213 == v224 && v224 > 0)
            v224 = 0;
          v299 = v466;
          if (v223)
            v299 = 0;
          v225 += v299;
          v300 = v465;
          if (v224)
            v300 = 0;
          v222 += v300;
          if (v222 >= v464)
            goto LABEL_906;
        }
        v273 = v272 != 0;
        v274 = v272 == 0;
        if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v468 + 1) + ((unint64_t)v232 >> 3)) >> (v232 & 7)) & 1) != 0)
          v273 = v274;
        if (!v273)
          goto LABEL_798;
LABEL_713:
        if (v213 == v226 && v226 > 0)
          v226 = 0;
        v283 = v465;
        if (v226)
          v283 = 0;
        v222 += v283;
        v212 -= v223 > 0;
        if (v222 < v464)
          goto LABEL_538;
LABEL_906:
        if (v225 == v19)
          v337 = v139;
        else
          v337 = 0;
        if (v337 != 1 || v222 >= v464)
        {
          v310 = v416;
          goto LABEL_825;
        }
        v338 = v223;
        v339 = v423;
        while (2)
        {
          if (v222 < 0 || (v340 = v492, (uint64_t)v492 <= v222))
          {
            v344 = 0;
          }
          else
          {
            v341 = (UniChar *)v490[1];
            if (v490[1])
            {
              v342 = range.length + v222;
              goto LABEL_916;
            }
            if (range.location)
            {
              v343 = *(char *)(range.location + range.length + v222);
            }
            else
            {
              if (v493 <= v222 || (v359 = *((_QWORD *)&v492 + 1), *((uint64_t *)&v492 + 1) > v222))
              {
                v360 = v222 - 4;
                if ((unint64_t)v222 < 4)
                  v360 = 0;
                if (v360 + 64 < (uint64_t)v492)
                  v340 = v360 + 64;
                *((_QWORD *)&v492 + 1) = v360;
                v493 = v340;
                v526.location = range.length + v360;
                v526.length = v340 - v360;
                CFStringGetCharacters(v490[0], v526, v482);
                v216 = v456;
                v214 = v436 == 8;
                v221 = v459;
                v139 = v463;
                v359 = *((_QWORD *)&v492 + 1);
              }
              v342 = v222 - v359;
              v341 = v482;
LABEL_916:
              v343 = v341[v342];
            }
            v344 = v343;
            if (v343 >> 10 == 54)
            {
              v352 = v222 + 1;
              v353 = v492;
              if ((uint64_t)v492 <= v222 + 1)
              {
                v339 = v423;
              }
              else
              {
                v354 = (UniChar *)v490[1];
                if (v490[1])
                {
                  v355 = range.length + v352;
                  goto LABEL_945;
                }
                if (range.location)
                {
                  v356 = *(char *)(range.location + range.length + v352);
                }
                else
                {
                  if (v493 <= v352 || (v364 = *((_QWORD *)&v492 + 1), *((uint64_t *)&v492 + 1) > v352))
                  {
                    v365 = v222 - 3;
                    if ((unint64_t)v222 < 3)
                      v365 = 0;
                    if (v365 + 64 < (uint64_t)v492)
                      v353 = v365 + 64;
                    *((_QWORD *)&v492 + 1) = v365;
                    v493 = v353;
                    v527.location = range.length + v365;
                    v527.length = v353 - v365;
                    CFStringGetCharacters(v490[0], v527, v482);
                    v216 = v456;
                    v214 = v436 == 8;
                    v221 = v459;
                    v139 = v463;
                    v364 = *((_QWORD *)&v492 + 1);
                  }
                  v355 = v352 - v364;
                  v354 = v482;
LABEL_945:
                  v356 = v354[v355];
                }
                v339 = v423;
                if (v356 >> 10 == 55)
                  v344 = (v344 << 10) - 56613888 + v356;
              }
            }
          }
          v345 = *v339;
          v346 = *v339 & 4;
          if (*v433 > v344 || *v425 <= v344)
          {
            if (!v346)
              goto LABEL_982;
            goto LABEL_932;
          }
          if (HIWORD(v344) || (v345 & 2) != 0)
          {
            v351 = CFCharacterSetIsLongCharacterMember(*v432, v344);
            v216 = v456;
            v214 = v436 == 8;
            v221 = v459;
            v139 = v463;
            if (!v351)
              goto LABEL_982;
LABEL_932:
            if (v344 < 0x10000)
              v350 = 1;
            else
              v350 = 2;
            v222 += v350;
            if (v222 >= v464)
              goto LABEL_982;
            continue;
          }
          break;
        }
        v347 = *v417;
        if (*v417)
        {
          if ((v345 & 1) != 0)
          {
            v361 = v346 >> 2;
            v362 = *(unsigned __int8 *)(v347 + ((unint64_t)v344 >> 8));
            if (*(_BYTE *)(v347 + ((unint64_t)v344 >> 8)))
            {
              if ((_DWORD)v362 == 255)
              {
                v361 = v346 == 0;
              }
              else
              {
                v363 = v346 == 0;
                if ((((unint64_t)*(unsigned __int8 *)(v347 + 32 * v362 + (v344 >> 3) + 224) >> (v344 & 7)) & 1) != 0)
                  v361 = v363;
              }
            }
            if (!v361)
              goto LABEL_982;
          }
          else
          {
            v49 = v346 == 0;
            v348 = v346 != 0;
            v349 = v49;
            if ((((unint64_t)*(unsigned __int8 *)(v347 + ((unint64_t)v344 >> 3)) >> (v344 & 7)) & 1) != 0)
              v348 = v349;
            if (!v348)
              goto LABEL_982;
          }
          goto LABEL_932;
        }
        v49 = v346 == 0;
        v357 = v346 != 0;
        v358 = v49;
        if ((v345 & 1) == 0)
          v357 = v358;
        if (v357)
          goto LABEL_932;
LABEL_982:
        v310 = v416;
        v225 = v19;
        v223 = v338;
LABEL_825:
        if (v222 != v464)
          goto LABEL_875;
        if (v223 < 1)
        {
LABEL_838:
          if (!v420 || v225 >= v19)
            goto LABEL_1027;
          if (v225 < 0 || (v313 = v505, (uint64_t)v505 <= v225))
          {
            v317 = 0;
          }
          else
          {
            v314 = (UniChar *)v503[1];
            if (v503[1])
            {
              v315 = *((_QWORD *)&v504 + 1) + v225;
              goto LABEL_844;
            }
            if ((_QWORD)v504)
            {
              v316 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v225);
            }
            else
            {
              if (v506 <= v225 || (v331 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) > v225))
              {
                v332 = v225 - 4;
                if ((unint64_t)v225 < 4)
                  v332 = 0;
                if (v332 + 64 < (uint64_t)v505)
                  v313 = v332 + 64;
                *((_QWORD *)&v505 + 1) = v332;
                v506 = v313;
                v523.location = *((_QWORD *)&v504 + 1) + v332;
                v523.length = v313 - v332;
                CFStringGetCharacters(v503[0], v523, buffer);
                v216 = v456;
                v214 = v436 == 8;
                v221 = v459;
                v139 = v463;
                v331 = *((_QWORD *)&v505 + 1);
              }
              v315 = v225 - v331;
              v314 = buffer;
LABEL_844:
              v316 = v314[v315];
            }
            v317 = v316;
            if (v316 >> 10 == 54)
            {
              v324 = v225 + 1;
              v325 = v505;
              if ((uint64_t)v505 > v225 + 1)
              {
                v326 = (UniChar *)v503[1];
                if (v503[1])
                {
                  v327 = *((_QWORD *)&v504 + 1) + v324;
                  goto LABEL_864;
                }
                if ((_QWORD)v504)
                {
                  v328 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v324);
                }
                else
                {
                  if (v506 <= v324 || (v335 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) > v324))
                  {
                    v336 = v225 - 3;
                    if ((unint64_t)v225 < 3)
                      v336 = 0;
                    if (v336 + 64 < (uint64_t)v505)
                      v325 = v336 + 64;
                    *((_QWORD *)&v505 + 1) = v336;
                    v506 = v325;
                    v525.location = *((_QWORD *)&v504 + 1) + v336;
                    v525.length = v325 - v336;
                    CFStringGetCharacters(v503[0], v525, buffer);
                    v216 = v456;
                    v214 = v436 == 8;
                    v221 = v459;
                    v139 = v463;
                    v335 = *((_QWORD *)&v505 + 1);
                  }
                  v327 = v324 - v335;
                  v326 = buffer;
LABEL_864:
                  v328 = v326[v327];
                }
                v318 = BitmapPtrForPlane;
                if (v328 >> 10 == 55)
                {
                  v317 = (v317 << 10) - 56613888 + v328;
                  v318 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v317));
                  v216 = v456;
                  v214 = v436 == 8;
                  v221 = v459;
                  v139 = v463;
                }
LABEL_847:
                if (v318 && ((*(unsigned __int8 *)(v318 + ((unsigned __int16)v317 >> 3)) >> (v317 & 7)) & 1) != 0)
                {
                  if ((v441 & 0x80) == 0)
                    goto LABEL_875;
                  if (!HIWORD(v317))
                  {
                    v366 = -v225;
                    v367 = v225 + 64;
                    v368 = v225;
                    do
                    {
                      if ((unint64_t)v368 >= 5)
                        v369 = 5;
                      else
                        v369 = v368;
                      v370 = v368 - 1;
                      if (v368 >= 1 && (v371 = v505, (uint64_t)v505 >= v368))
                      {
                        if (v503[1])
                        {
                          v372 = *((_WORD *)v503[1] + v368 + *((_QWORD *)&v504 + 1) - 1);
                        }
                        else if ((_QWORD)v504)
                        {
                          v372 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v368 - 1);
                        }
                        else
                        {
                          if (v506 < v368 || (v373 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) >= v368))
                          {
                            v374 = -v369;
                            v375 = v367 - v369;
                            v376 = v369 + v366;
                            v377 = v368 + v374;
                            v378 = v377 + 64;
                            if (v377 + 64 >= (uint64_t)v505)
                              v378 = v505;
                            *((_QWORD *)&v505 + 1) = v377;
                            v506 = v378;
                            if ((uint64_t)v505 >= v375)
                              v371 = v375;
                            v528.length = v371 + v376;
                            v528.location = v377 + *((_QWORD *)&v504 + 1);
                            CFStringGetCharacters(v503[0], v528, buffer);
                            v221 = v459;
                            v373 = *((_QWORD *)&v505 + 1);
                          }
                          v372 = buffer[v368 - 1 - v373];
                        }
                      }
                      else
                      {
                        v372 = 0;
                      }
                      ++v366;
                      --v367;
                      --v368;
                    }
                    while (*(uint64_t *)v422 < v370);
                    if (v372 > 0x50Fu)
                    {
                      v19 = v460;
                    }
                    else
                    {
                      v379 = v225 + 1;
                      v19 = v460;
                      do
                      {
                        v225 = v379;
                        if (v379 >= v460)
                          break;
                        if (v379 - 1 >= -1)
                        {
                          v382 = v505;
                          v381 = BitmapPtrForPlane;
                          if ((uint64_t)v505 <= v225)
                          {
                            v380 = 0;
                          }
                          else if (v503[1])
                          {
                            v380 = *((_WORD *)&v503[1]->isa + v225 + *((_QWORD *)&v504 + 1));
                          }
                          else if ((_QWORD)v504)
                          {
                            v380 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v225);
                          }
                          else
                          {
                            if (v506 <= v225 || (v385 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) > v225))
                            {
                              v386 = v225 - 4;
                              if ((unint64_t)v225 < 4)
                                v386 = 0;
                              if (v386 + 64 < (uint64_t)v505)
                                v382 = v386 + 64;
                              *((_QWORD *)&v505 + 1) = v386;
                              v506 = v382;
                              v529.location = *((_QWORD *)&v504 + 1) + v386;
                              v529.length = v382 - v386;
                              CFStringGetCharacters(v503[0], v529, buffer);
                              v221 = v459;
                              v385 = *((_QWORD *)&v505 + 1);
                            }
                            v380 = buffer[v225 - v385];
                          }
                        }
                        else
                        {
                          v380 = 0;
                          v381 = BitmapPtrForPlane;
                        }
                        if (!v381)
                          break;
                        v383 = *(unsigned __int8 *)(v381 + (v380 >> 3));
                        v384 = v380 & 7;
                        v379 = v225 + 1;
                      }
                      while (((v383 >> v384) & 1) != 0);
                    }
                  }
                  goto LABEL_1027;
                }
                if ((v441 & 0x80) != 0)
                  goto LABEL_1027;
                v319 = v225 - 1;
                if (v225 < 1 || (v320 = v505, (uint64_t)v505 < v225))
                {
                  v321 = 0;
                  goto LABEL_867;
                }
                v322 = (UniChar *)v503[1];
                if (v503[1])
                {
                  v323 = *((_QWORD *)&v504 + 1) + v319;
                  goto LABEL_857;
                }
                if ((_QWORD)v504)
                {
                  v321 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v319);
                }
                else
                {
                  if (v506 < v225 || (v333 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) >= v225))
                  {
                    v334 = v225 - 5;
                    if ((unint64_t)v225 < 5)
                      v334 = 0;
                    if (v334 + 64 < (uint64_t)v505)
                      v320 = v334 + 64;
                    *((_QWORD *)&v505 + 1) = v334;
                    v506 = v320;
                    v524.location = *((_QWORD *)&v504 + 1) + v334;
                    v524.length = v320 - v334;
                    CFStringGetCharacters(v503[0], v524, buffer);
                    v221 = v459;
                    v333 = *((_QWORD *)&v505 + 1);
                  }
                  v323 = v319 - v333;
                  v322 = buffer;
LABEL_857:
                  v321 = v322[v323];
                }
LABEL_867:
                if (v317 == 847
                  || v321 == 847
                  || v321 == 8205
                  || (unsigned __int16)(v321 - 4352) < 0xFAu
                  || v414
                  && *(_BYTE *)(v414 + HIBYTE(v321))
                  && *(_BYTE *)(v412 + (*(unsigned __int8 *)(v414 + HIBYTE(v321)) << 8) - 256 + v321) == 9)
                {
                  v329 = CFStringGetRangeOfCharacterClusterAtIndex((__CFString *)theString, v225 - 1, 1);
                  v216 = v456;
                  v214 = v436 == 8;
                  v221 = v459;
                  v139 = v463;
                  if (v225 < v329 + v330)
                    goto LABEL_875;
                }
LABEL_1027:
                if (v436 == 12)
                  v387 = v310;
                else
                  v387 = 1;
                if ((v387 & 1) == 0 && v225 < v19)
                {
                  do
                  {
                    if (v225 < 0 || (v388 = v505, (uint64_t)v505 <= v225))
                    {
                      v390 = 0;
                    }
                    else
                    {
                      if (v503[1])
                      {
                        v389 = *((_WORD *)&v503[1]->isa + *((_QWORD *)&v504 + 1) + v225);
                      }
                      else if ((_QWORD)v504)
                      {
                        v389 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v225);
                      }
                      else
                      {
                        if (v506 <= v225 || (v400 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) > v225))
                        {
                          v401 = v225 - 4;
                          if ((unint64_t)v225 < 4)
                            v401 = 0;
                          if (v401 + 64 < (uint64_t)v505)
                            v388 = v401 + 64;
                          *((_QWORD *)&v505 + 1) = v401;
                          v506 = v388;
                          v530.location = *((_QWORD *)&v504 + 1) + v401;
                          v530.length = v388 - v401;
                          CFStringGetCharacters(v503[0], v530, buffer);
                          v221 = v459;
                          v400 = *((_QWORD *)&v505 + 1);
                        }
                        v389 = buffer[v225 - v400];
                      }
                      v390 = v389;
                      if (v389 >> 10 == 54)
                      {
                        v402 = v225 + 1;
                        v403 = v505;
                        if ((uint64_t)v505 > v225 + 1)
                        {
                          if (v503[1])
                          {
                            v404 = *((_WORD *)&v503[1]->isa + *((_QWORD *)&v504 + 1) + v402);
                          }
                          else if ((_QWORD)v504)
                          {
                            v404 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v402);
                          }
                          else
                          {
                            if (v506 <= v402 || (v408 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) > v402))
                            {
                              v409 = v225 - 3;
                              if ((unint64_t)v225 < 3)
                                v409 = 0;
                              if (v409 + 64 < (uint64_t)v505)
                                v403 = v409 + 64;
                              *((_QWORD *)&v505 + 1) = v409;
                              v506 = v403;
                              v531.location = *((_QWORD *)&v504 + 1) + v409;
                              v531.length = v403 - v409;
                              CFStringGetCharacters(v503[0], v531, buffer);
                              v221 = v459;
                              v408 = *((_QWORD *)&v505 + 1);
                            }
                            v404 = buffer[v402 - v408];
                          }
                          if (v404 >> 10 == 55)
                            v390 = (v390 << 10) - 56613888 + v404;
                        }
                      }
                    }
                    v391 = *v423;
                    v392 = *v423 & 4;
                    if (*v433 > v390 || *v425 <= v390)
                    {
                      if (!v392)
                        break;
                    }
                    else if (HIWORD(v390) || (v391 & 2) != 0)
                    {
                      v397 = CFCharacterSetIsLongCharacterMember(*v432, v390);
                      v221 = v459;
                      if (!v397)
                        break;
                    }
                    else
                    {
                      v393 = *v417;
                      if (*v417)
                      {
                        if ((v391 & 1) != 0)
                        {
                          v405 = v392 >> 2;
                          v406 = *(unsigned __int8 *)(v393 + ((unint64_t)v390 >> 8));
                          if (*(_BYTE *)(v393 + ((unint64_t)v390 >> 8)))
                          {
                            if ((_DWORD)v406 == 255)
                            {
                              v405 = v392 == 0;
                            }
                            else
                            {
                              v407 = v392 == 0;
                              if ((((unint64_t)*(unsigned __int8 *)(v393
                                                                          + 32 * v406
                                                                          + (v390 >> 3)
                                                                          + 224) >> (v390 & 7)) & 1) != 0)
                                v405 = v407;
                            }
                          }
                          if (!v405)
                            break;
                        }
                        else
                        {
                          v49 = v392 == 0;
                          v394 = v392 != 0;
                          v395 = v49;
                          if ((((unint64_t)*(unsigned __int8 *)(v393 + ((unint64_t)v390 >> 3)) >> (v390 & 7)) & 1) != 0)
                            v394 = v395;
                          if (!v394)
                            break;
                        }
                      }
                      else
                      {
                        v49 = v392 == 0;
                        v398 = v392 != 0;
                        v399 = v49;
                        if ((v391 & 1) == 0)
                          v398 = v399;
                        if (!v398)
                          break;
                      }
                    }
                    if (v390 < 0x10000)
                      v396 = 1;
                    else
                      v396 = 2;
                    v225 += v396;
                  }
                  while (v225 < v19);
                }
                if (v436 == 12 && v225 != v19)
                  goto LABEL_1100;
                if (v421)
                {
                  v421->location = v221;
                  v421->length = v225 - v221;
                }
LABEL_453:
                LOBYTE(v14) = 1;
                return v14;
              }
            }
          }
          v318 = BitmapPtrForPlane;
          goto LABEL_847;
        }
        if ((v441 & 0x80) != 0 && __s1[0] <= 0x50F)
        {
          if (v212 < v223)
          {
            while (1)
            {
              v311 = __s1[v212];
              v312 = BitmapPtrForPlane;
              if (v311 >= 0x10000)
              {
                v312 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v311));
                v216 = v456;
                v214 = v436 == 8;
                v221 = v459;
                v139 = v463;
              }
              if (!v312 || ((*(unsigned __int8 *)(v312 + ((unsigned __int16)v311 >> 3)) >> (v311 & 7)) & 1) == 0)
                break;
              if (v223 == ++v212)
                goto LABEL_837;
            }
          }
          if (v212 == v223)
          {
LABEL_837:
            v225 += v466;
            v212 = v223;
            goto LABEL_838;
          }
        }
LABEL_875:
        if (v221 == v431)
          goto LABEL_1100;
        v221 += v426;
      }
    }
LABEL_456:
    *(_DWORD *)v470 = 0;
    v188 = length << 32;
    if ((searchOptions & 4) != 0)
    {
      if ((v431 & 0x8000000000000000) == 0)
      {
        v192 = v431 + (int)length;
        v193 = v505;
        v139 = v463;
        if (v192 <= (uint64_t)v505)
        {
          if (v503[1])
          {
            v191 = (UniChar *)v503[1] + *((_QWORD *)&v504 + 1) + v431;
            goto LABEL_496;
          }
          if (v188 <= 0x4000000000)
          {
            if (v192 > v506 || v431 < *((uint64_t *)&v505 + 1))
            {
              if (v431 + 64 < (uint64_t)v505)
                v193 = v431 + 64;
              *((_QWORD *)&v505 + 1) = v431;
              v506 = v193;
              v200.location = *((_QWORD *)&v504 + 1) + v431;
              v200.length = v193 - v431;
              if ((_QWORD)v504)
              {
                if (v200.length)
                {
                  v201 = (char *)(v504 + v200.location);
                  v202 = v431 - v193;
                  v203 = buffer;
                  do
                  {
                    v204 = *v201++;
                    *v203++ = v204;
                    v199 = __CFADD__(v202++, 1);
                  }
                  while (!v199);
                }
              }
              else
              {
                CFStringGetCharacters(v503[0], v200, buffer);
                v139 = v463;
              }
            }
            v205 = v431 - *((_QWORD *)&v505 + 1);
            goto LABEL_495;
          }
        }
LABEL_464:
        v191 = 0;
        goto LABEL_496;
      }
    }
    else if ((v27 & 0x8000000000000000) == 0)
    {
      v189 = v27 + (int)length;
      v190 = v505;
      v139 = v463;
      if (v189 <= (uint64_t)v505)
      {
        if (v503[1])
        {
          v191 = (UniChar *)v503[1] + *((_QWORD *)&v504 + 1) + v27;
          goto LABEL_496;
        }
        if (v188 <= 0x4000000000)
        {
          if (v189 > v506 || v27 < *((uint64_t *)&v505 + 1))
          {
            if (v27 + 64 < (uint64_t)v505)
              v190 = v27 + 64;
            *((_QWORD *)&v505 + 1) = v27;
            v506 = v190;
            v194.location = *((_QWORD *)&v504 + 1) + v27;
            v194.length = v190 - v27;
            if ((_QWORD)v504)
            {
              if (v194.length)
              {
                v195 = (char *)(v504 + v194.location);
                v196 = v27 - v190;
                v197 = buffer;
                do
                {
                  v198 = *v195++;
                  *v197++ = v198;
                  v199 = __CFADD__(v196++, 1);
                }
                while (!v199);
              }
            }
            else
            {
              CFStringGetCharacters(v503[0], v194, buffer);
              v139 = v463;
            }
          }
          v205 = v27 - *((_QWORD *)&v505 + 1);
LABEL_495:
          v191 = &buffer[v205];
LABEL_496:
          if ((int)v464 <= (uint64_t)v492)
          {
            if (v490[1])
              goto LABEL_510;
            if (v464 << 32 <= 0x4000000000)
            {
              if ((int)v464 > v493 || *((uint64_t *)&v492 + 1) >= 1)
              {
                if ((uint64_t)v492 >= 64)
                  v206.length = 64;
                else
                  v206.length = v492;
                *((_QWORD *)&v492 + 1) = 0;
                v493 = v206.length;
                v206.location = range.length;
                if (range.location)
                {
                  if (v206.length)
                  {
                    v207 = (char *)(range.location + range.length);
                    v208 = v482;
                    do
                    {
                      v209 = *v207++;
                      *v208++ = v209;
                      --v206.length;
                    }
                    while (v206.length);
                  }
                }
                else
                {
                  CFStringGetCharacters(v490[0], v206, v482);
                  v139 = v463;
                }
              }
LABEL_510:
              if (v191)
              {
                ucol_open();
                v139 = v463;
                if (*(int *)v470 <= 0)
                {
                  ucol_setStrength();
                  usearch_openFromCollator();
                  if (*(int *)v470 <= 0)
                  {
                    if ((searchOptions & 4) != 0)
                      v210 = usearch_last();
                    else
                      v210 = usearch_first();
                    v211 = v210;
                    if (*(int *)v470 < 1)
                    {
                      if ((v210 & 0x80000000) != 0)
                      {
                        LOBYTE(v14) = 0;
                      }
                      else
                      {
                        MatchedLength = usearch_getMatchedLength();
                        if ((searchOptions & 8) != 0)
                        {
                          if ((searchOptions & 4) != 0)
                            v14 = MatchedLength + v211 == length;
                          else
                            v14 = v211 == 0;
                        }
                        else
                        {
                          v14 = 1;
                        }
                        if (v421 && v14)
                        {
                          v421->location = *(_QWORD *)v422 + v211;
                          v421->length = MatchedLength;
                          LOBYTE(v14) = 1;
                        }
                      }
                      usearch_close();
                      ucol_close();
                      return v14;
                    }
                    usearch_close();
                  }
                  ucol_close();
                  v139 = v463;
                }
              }
            }
          }
LABEL_519:
          v140 = searchOptions;
          goto LABEL_520;
        }
      }
      goto LABEL_464;
    }
    v191 = 0;
    v139 = v463;
    goto LABEL_496;
  }
  LODWORD(v33) = 0;
  v34 = 0;
  if (v463)
    v35 = (uint64_t)&theSet[1];
  else
    v35 = 8;
  if (v463)
    v36 = (unint64_t)theSet | 0xC;
  else
    v36 = 12;
  v37 = (uint64_t)&v468;
  if (!v463)
    v37 = 16;
  v455 = (_DWORD *)v37;
  v38 = (uint64_t)&v468 + 8;
  if (!v463)
    v38 = 24;
  v446 = (uint64_t *)v38;
  v439 = v32;
  v449 = v36;
  v451 = v35;
  while (2)
  {
    v114 = v27 < v19;
    v444 = v27;
    v39 = 0;
    v40 = v27;
    if (!v114)
      goto LABEL_265;
    do
    {
      v41 = -v40;
      v42 = v40 + 64;
      v442 = v34;
      v43 = v34;
      v44 = v40;
      while (1)
      {
        if ((unint64_t)v44 >= 4)
          v45 = 4;
        else
          v45 = v44;
        v46 = *(unsigned __int8 *)(CStringPtrInternal + v44);
        v47 = *(unsigned __int8 *)(v458 + v39);
        if (v46 == v47)
          goto LABEL_181;
        if (!v457)
        {
          v34 = v442;
          goto LABEL_265;
        }
        v48 = (char)v46;
        v49 = SpecialCaseHandlingLanguageIdentifierForLocale && (char)v46 == 73;
        v50 = !v49;
        if (v48 < 0 || !v50)
        {
          if (v44 < 0 || (uint64_t)v505 <= v44)
          {
            v53 = 0;
          }
          else if (v503[1])
          {
            v53 = *((_WORD *)&v503[1]->isa + v44 + *((_QWORD *)&v504 + 1));
          }
          else if ((_QWORD)v504)
          {
            v53 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v44);
          }
          else
          {
            if (v506 <= v44 || (v68 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) > v44))
            {
              v69 = -v45;
              v70 = v45 + v41;
              v71 = v42 - v45;
              v72 = v44 + v69;
              v73 = v72 + 64;
              if (v72 + 64 >= (uint64_t)v505)
                v73 = v505;
              *((_QWORD *)&v505 + 1) = v72;
              v506 = v73;
              if ((uint64_t)v505 < v71)
                v71 = v505;
              v510.length = v71 + v70;
              v510.location = v72 + *((_QWORD *)&v504 + 1);
              CFStringGetCharacters(v503[0], v510, buffer);
              v68 = *((_QWORD *)&v505 + 1);
            }
            v53 = buffer[v44 - v68];
          }
          v43 = v53;
          v54 = __CFStringFoldCharacterClusterAtIndex(v53, buffer, v44, v441, SpecialCaseHandlingLanguageIdentifierForLocale, __s1, 0, 0);
          if (v54 <= 0)
          {
            __s1[0] = v43;
            v52 = 1;
          }
          else
          {
            v52 = v54;
          }
          v31 = v463;
          v36 = v449;
          v35 = v451;
        }
        else
        {
          if ((v48 - 65) < 0x1Au && v453 != 0)
            LOBYTE(v48) = v48 + 32;
          __s1[0] = v48;
          v52 = 1;
        }
        v55 = v436 != 8 && v444 == v44;
        v56 = v463 ^ 1;
        if (v55)
          v56 = 1;
        if ((v56 & 1) != 0)
          break;
        if ((v48 & 0x80u) == 0)
          v57 = v48;
        else
          v57 = v43;
        v58 = *(_DWORD *)v35;
        v59 = *(_DWORD *)v35 & 4;
        if (*(_DWORD *)v36 > v57 || *v455 <= v57)
        {
          if (!v59)
            break;
          goto LABEL_108;
        }
        if ((v58 & 2) != 0)
        {
          v63 = CFCharacterSetIsLongCharacterMember(*v432, v57);
          v36 = v449;
          v35 = v451;
          v31 = v463;
          if (!v63)
            break;
          goto LABEL_108;
        }
        v60 = *v446;
        if (*v446)
        {
          if ((v58 & 1) != 0)
          {
            v66 = v59 >> 2;
            v67 = *(unsigned __int8 *)(v60 + (v57 >> 8));
            if (!*(_BYTE *)(v60 + (v57 >> 8)))
              goto LABEL_124;
            if ((_DWORD)v67 == 255)
            {
              v66 = v59 == 0;
LABEL_124:
              if (!v66)
                break;
              goto LABEL_108;
            }
            v74 = v59 == 0;
            if (((*(unsigned __int8 *)(v60 + 32 * v67 + (v57 >> 3) + 224) >> (v57 & 7)) & 1) != 0)
              v66 = v74;
            if (!v66)
              break;
          }
          else
          {
            v49 = v59 == 0;
            v61 = v59 != 0;
            v62 = v49;
            if (((*(unsigned __int8 *)(v60 + (v57 >> 3)) >> (v57 & 7)) & 1) != 0)
              v61 = v62;
            if (!v61)
              break;
          }
        }
        else
        {
          v49 = v59 == 0;
          v64 = v59 != 0;
          v65 = v49;
          if ((v58 & 1) == 0)
            v64 = v65;
          if (!v64)
            break;
        }
LABEL_108:
        ++v44;
        --v41;
        ++v42;
        if (v44 >= v460)
          goto LABEL_262;
      }
      v75 = v47;
      if (SpecialCaseHandlingLanguageIdentifierForLocale)
        v76 = (char)v47 == 73;
      else
        v76 = 0;
      v77 = !v76;
      if ((char)v47 < 0 || !v77)
      {
        v80 = v441;
        if (v39 < 0 || (v81 = v492, (uint64_t)v492 <= v39))
        {
          v84 = 0;
        }
        else
        {
          v82 = (UniChar *)v490[1];
          if (v490[1])
          {
            v83 = range.length + v39;
LABEL_156:
            v84 = v82[v83];
            goto LABEL_158;
          }
          if (!range.location)
          {
            if (v493 <= v39 || (v110 = *((_QWORD *)&v492 + 1), *((uint64_t *)&v492 + 1) > v39))
            {
              v111 = v39 - 4;
              if ((unint64_t)v39 < 4)
                v111 = 0;
              if (v111 + 64 < (uint64_t)v492)
                v81 = v111 + 64;
              *((_QWORD *)&v492 + 1) = v111;
              v493 = v81;
              v513.location = range.length + v111;
              v513.length = v81 - v111;
              CFStringGetCharacters(v490[0], v513, v482);
              v110 = *((_QWORD *)&v492 + 1);
            }
            v83 = v39 - v110;
            v82 = v482;
            goto LABEL_156;
          }
          v84 = *(char *)(range.location + range.length + v39);
        }
LABEL_158:
        LODWORD(v33) = v84;
        v85 = __CFStringFoldCharacterClusterAtIndex(v84, v482, v39, v441, SpecialCaseHandlingLanguageIdentifierForLocale, __s2, 0, 0);
        if (v85 <= 0)
        {
          __s2[0] = v33;
          v79 = 1;
        }
        else
        {
          v79 = v85;
        }
        v31 = v463;
        v36 = v449;
        v35 = v451;
        if (!v463)
          goto LABEL_178;
LABEL_162:
        if ((v75 & 0x80u) == 0)
          v86 = v75;
        else
          v86 = v33;
        v87 = (uint64_t)theSet[1] & 4;
        if (HIDWORD(theSet[1]) > v86 || v468 <= v86)
        {
          if (((uint64_t)theSet[1] & 4) == 0)
            goto LABEL_178;
        }
        else if (((uint64_t)theSet[1] & 2) != 0)
        {
          v105 = CFCharacterSetIsLongCharacterMember(theSet[0], v86);
          v36 = v449;
          v35 = v451;
          v31 = v463;
          if (!v105)
            goto LABEL_178;
        }
        else if (*((_QWORD *)&v468 + 1))
        {
          if (((uint64_t)theSet[1] & 1) != 0)
          {
            v108 = v87 >> 2;
            v109 = *(unsigned __int8 *)(*((_QWORD *)&v468 + 1) + (v86 >> 8));
            if (*(_BYTE *)(*((_QWORD *)&v468 + 1) + (v86 >> 8)))
            {
              if ((_DWORD)v109 == 255)
              {
                v108 = v87 == 0;
              }
              else
              {
                v112 = v87 == 0;
                if (((*(unsigned __int8 *)(*((_QWORD *)&v468 + 1) + 32 * v109 + (v86 >> 3) + 224) >> (v86 & 7)) & 1) != 0)
                  v108 = v112;
              }
            }
            if (!v108)
              goto LABEL_178;
          }
          else
          {
            v49 = v87 == 0;
            v88 = v87 != 0;
            v89 = v49;
            if (((*(unsigned __int8 *)(*((_QWORD *)&v468 + 1) + (v86 >> 3)) >> (v86 & 7)) & 1) != 0)
              v88 = v89;
            if (!v88)
              goto LABEL_178;
          }
        }
        else
        {
          v49 = v87 == 0;
          v106 = v87 != 0;
          v107 = v49;
          if (((uint64_t)theSet[1] & 1) == 0)
            v106 = v107;
          if (!v106)
            goto LABEL_178;
        }
        v40 = v44;
        v34 = v43;
        goto LABEL_234;
      }
      if ((v47 - 65) < 0x1Au && v453 != 0)
        v75 = v47 + 32;
      __s2[0] = v75;
      v79 = 1;
      v80 = v441;
      if (v31)
        goto LABEL_162;
LABEL_178:
      if (v52 != 1 || v79 != 1)
      {
        if (v453 || v52 == v79)
        {
          if ((uint64_t)v52 >= (uint64_t)v79)
            v90 = v79;
          else
            v90 = v52;
          if (memcmp(__s1, __s2, 4 * v90))
          {
            v40 = v44;
            v34 = v43;
            v31 = v463;
            v36 = v449;
            v35 = v451;
            break;
          }
          if (v52 >= v79)
          {
            v31 = v463;
            v36 = v449;
            v35 = v451;
            if (v79 >= v52)
              goto LABEL_181;
            if ((uint64_t)(v52 + v39) <= v464)
            {
              v97 = &__s1[v52];
              v98 = &__s1[v79];
              v99 = v44 + 1;
              if ((unint64_t)(v44 + 1) >= 4)
                v100 = v44 - 3;
              else
                v100 = 0;
              while (1)
              {
                if (v44 < -1 || (v101 = v492, (uint64_t)v492 <= v99))
                {
                  v102 = 0;
                }
                else if (v490[1])
                {
                  v102 = *((_WORD *)&v490[1]->isa + v44 + range.length + 1);
                }
                else if (range.location)
                {
                  v102 = *(char *)(range.location + range.length + v44 + 1);
                }
                else
                {
                  if (v493 <= v99 || (v104 = *((_QWORD *)&v492 + 1), *((uint64_t *)&v492 + 1) > v99))
                  {
                    if (v100 + 64 < (uint64_t)v492)
                      v101 = v100 + 64;
                    *((_QWORD *)&v492 + 1) = v100;
                    v493 = v101;
                    v512.location = range.length + v100;
                    v512.length = v101 - v100;
                    CFStringGetCharacters(v490[0], v512, v482);
                    v104 = *((_QWORD *)&v492 + 1);
                  }
                  v102 = v482[v44 + 1 - v104];
                }
                v103 = v39 + 1;
                if (__CFStringFoldCharacterClusterAtIndex(v102, v482, v39 + 1, v441, SpecialCaseHandlingLanguageIdentifierForLocale, __s2, 0, 0) > 0)goto LABEL_263;
                v31 = v463;
                v36 = v449;
                v35 = v451;
                if (*v98 != __s2[0])
                {
LABEL_264:
                  v40 = v44;
                  v34 = v43;
                  goto LABEL_265;
                }
                ++v98;
                ++v39;
                if (v98 >= v97)
                {
                  v39 = v103;
                  goto LABEL_181;
                }
              }
            }
          }
          else
          {
            v31 = v463;
            v36 = v449;
            v35 = v451;
            if ((uint64_t)(v79 + v44) <= v460)
            {
              v91 = &__s2[v52];
              while (1)
              {
                v92 = v44 + 1;
                if (v44 < -1 || (v93 = v505, (uint64_t)v505 <= v92))
                {
                  v94 = 0;
                }
                else if (v503[1])
                {
                  v94 = *((_WORD *)&v503[1]->isa + v44 + *((_QWORD *)&v504 + 1) + 1);
                }
                else if ((_QWORD)v504)
                {
                  v94 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v44 + 1);
                }
                else
                {
                  if (v506 <= v92 || (v95 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) > v92))
                  {
                    v96 = v44 - 3;
                    if ((unint64_t)v92 < 4)
                      v96 = 0;
                    if (v96 + 64 < (uint64_t)v505)
                      v93 = v96 + 64;
                    *((_QWORD *)&v505 + 1) = v96;
                    v506 = v93;
                    v511.location = *((_QWORD *)&v504 + 1) + v96;
                    v511.length = v93 - v96;
                    CFStringGetCharacters(v503[0], v511, buffer);
                    v95 = *((_QWORD *)&v505 + 1);
                  }
                  v94 = buffer[v44 + 1 - v95];
                }
                if (__CFStringFoldCharacterClusterAtIndex(v94, buffer, v44 + 1, v80, SpecialCaseHandlingLanguageIdentifierForLocale, __s1, 0, 0) > 0)break;
                v31 = v463;
                v36 = v449;
                v35 = v451;
                if (*v91 != __s1[0])
                  goto LABEL_264;
                ++v91;
                ++v44;
                if (v91 >= &__s2[v79])
                {
                  v44 = v92;
                  goto LABEL_181;
                }
              }
LABEL_263:
              v40 = v44;
              v34 = v43;
              v31 = v463;
              v36 = v449;
              v35 = v451;
              break;
            }
          }
        }
LABEL_262:
        v40 = v44;
        v34 = v43;
        break;
      }
      v40 = v44;
      v34 = v43;
      if (__s1[0] != __s2[0])
        break;
LABEL_181:
      v40 = v44 + 1;
      v34 = v43;
LABEL_234:
      ++v39;
    }
    while (v40 < v460 && v39 < v464);
LABEL_265:
    if (v40 == v460)
      v113 = v31;
    else
      v113 = 0;
    v114 = v113 == 1 && v39 < v464;
    if (v114)
    {
      v116 = -v39;
      v117 = v39 + 64;
      v115 = v444;
      while (1)
      {
        if ((unint64_t)v39 >= 4)
          v118 = 4;
        else
          v118 = v39;
        if (v39 < 0 || (v119 = v492, (uint64_t)v492 <= v39))
        {
          v120 = 0;
        }
        else if (v490[1])
        {
          v120 = *((_WORD *)&v490[1]->isa + v39 + range.length);
        }
        else if (range.location)
        {
          v120 = *(char *)(range.location + range.length + v39);
        }
        else
        {
          if (v493 <= v39 || (v129 = *((_QWORD *)&v492 + 1), *((uint64_t *)&v492 + 1) > v39))
          {
            v130 = -v118;
            v131 = v118 + v116;
            v132 = v117 - v118;
            v133 = v39 + v130;
            v134 = v133 + 64;
            if (v133 + 64 >= (uint64_t)v492)
              v134 = v492;
            *((_QWORD *)&v492 + 1) = v133;
            v493 = v134;
            if ((uint64_t)v492 >= v132)
              v119 = v132;
            v514.length = v119 + v131;
            v514.location = v133 + range.length;
            CFStringGetCharacters(v490[0], v514, v482);
            v36 = v449;
            v35 = v451;
            v31 = v463;
            v129 = *((_QWORD *)&v492 + 1);
          }
          v120 = v482[v39 - v129];
        }
        v33 = v120;
        v121 = *(_DWORD *)v35;
        v122 = *(_DWORD *)v35 & 4;
        if (*(_DWORD *)v36 > v120 || *v455 <= v120)
        {
          if (!v122)
            goto LABEL_273;
        }
        else if ((v121 & 2) != 0)
        {
          v126 = CFCharacterSetIsLongCharacterMember(*v432, v120);
          v36 = v449;
          v35 = v451;
          v31 = v463;
          if (!v126)
            goto LABEL_273;
        }
        else
        {
          v123 = *v446;
          if (*v446)
          {
            if ((v121 & 1) != 0)
            {
              v135 = v122 >> 2;
              v136 = *(unsigned __int8 *)(v123 + (v33 >> 8));
              if (*(_BYTE *)(v123 + (v33 >> 8)))
              {
                if ((_DWORD)v136 == 255)
                {
                  v135 = v122 == 0;
                }
                else
                {
                  v137 = v122 == 0;
                  if (((*(unsigned __int8 *)(v123 + 32 * v136 + (v33 >> 3) + 224) >> (v33 & 7)) & 1) != 0)
                    v135 = v137;
                }
              }
              if (!v135)
                goto LABEL_273;
            }
            else
            {
              v49 = v122 == 0;
              v124 = v122 != 0;
              v125 = v49;
              if (((*(unsigned __int8 *)(v123 + (v33 >> 3)) >> (v33 & 7)) & 1) != 0)
                v124 = v125;
              if (!v124)
                goto LABEL_273;
            }
          }
          else
          {
            v49 = v122 == 0;
            v127 = v122 != 0;
            v128 = v49;
            if ((v121 & 1) == 0)
              v127 = v128;
            if (!v127)
              goto LABEL_273;
          }
        }
        ++v39;
        --v116;
        ++v117;
        if (v464 == v39)
          goto LABEL_354;
      }
    }
    v115 = v444;
LABEL_273:
    if (v39 == v464)
    {
LABEL_354:
      if (v436 == 12)
        v154 = v31;
      else
        v154 = 0;
      if (v154 == 1)
      {
        v155 = v460;
        if (v40 < v460)
        {
          v156 = -v40;
          v157 = v40 + 64;
          do
          {
            if ((unint64_t)v40 >= 4)
              v158 = 4;
            else
              v158 = v40;
            if (v40 < 0 || (v159 = v505, (uint64_t)v505 <= v40))
            {
              v160 = 0;
            }
            else if (v503[1])
            {
              v160 = *((_WORD *)&v503[1]->isa + v40 + *((_QWORD *)&v504 + 1));
            }
            else if ((_QWORD)v504)
            {
              v160 = *(char *)(v504 + *((_QWORD *)&v504 + 1) + v40);
            }
            else
            {
              if (v506 <= v40 || (v170 = *((_QWORD *)&v505 + 1), *((uint64_t *)&v505 + 1) > v40))
              {
                v171 = -v158;
                v172 = v158 + v156;
                v173 = v157 - v158;
                v174 = v40 + v171;
                v175 = v174 + 64;
                if (v174 + 64 >= (uint64_t)v505)
                  v175 = v505;
                *((_QWORD *)&v505 + 1) = v174;
                v506 = v175;
                if ((uint64_t)v505 >= v173)
                  v159 = v173;
                v516.length = v159 + v172;
                v516.location = v174 + *((_QWORD *)&v504 + 1);
                CFStringGetCharacters(v503[0], v516, buffer);
                v170 = *((_QWORD *)&v505 + 1);
              }
              v160 = buffer[v40 - v170];
            }
            v161 = (uint64_t)theSet[1] & 4;
            if (HIDWORD(theSet[1]) <= v160 && v468 > v160)
            {
              if (((uint64_t)theSet[1] & 2) != 0)
              {
                if (!CFCharacterSetIsLongCharacterMember(*v432, v160))
                  goto LABEL_449;
              }
              else if (*((_QWORD *)&v468 + 1))
              {
                if (((uint64_t)theSet[1] & 1) != 0)
                {
                  v168 = v161 >> 2;
                  v169 = *(unsigned __int8 *)(*((_QWORD *)&v468 + 1) + ((unint64_t)v160 >> 8));
                  if (*(_BYTE *)(*((_QWORD *)&v468 + 1) + ((unint64_t)v160 >> 8)))
                  {
                    if ((_DWORD)v169 == 255)
                    {
                      v168 = v161 == 0;
                    }
                    else
                    {
                      v176 = v161 == 0;
                      if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v468 + 1)
                                                                  + 32 * v169
                                                                  + (v160 >> 3)
                                                                  + 224) >> (v160 & 7)) & 1) != 0)
                        v168 = v176;
                    }
                  }
                  if (!v168)
                    goto LABEL_449;
                }
                else
                {
                  v163 = v161 != 0;
                  v164 = v161 == 0;
                  if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v468 + 1) + ((unint64_t)v160 >> 3)) >> (v160 & 7)) & 1) != 0)
                    v163 = v164;
                  if (!v163)
                    goto LABEL_449;
                }
              }
              else
              {
                v49 = v161 == 0;
                v165 = v161 != 0;
                v166 = v49;
                if (((uint64_t)theSet[1] & 1) != 0)
                  v167 = v165;
                else
                  v167 = v166;
                if ((v167 & 1) == 0)
                  goto LABEL_449;
              }
            }
            else if (((uint64_t)theSet[1] & 4) == 0)
            {
              goto LABEL_449;
            }
            ++v40;
            --v156;
            ++v157;
          }
          while (v460 != v40);
          v40 = v460;
LABEL_451:
          if (v421)
          {
            v421->location = v115;
            v421->length = v40 - v115;
          }
          goto LABEL_453;
        }
      }
      else
      {
        v155 = v460;
      }
LABEL_449:
      if (v436 == 12 && v40 != v155)
        break;
      goto LABEL_451;
    }
    if (v115 != v431)
    {
      v27 = v115 + v439;
      v19 = v460;
      continue;
    }
    break;
  }
LABEL_1100:
  LOBYTE(v14) = 0;
  return v14;
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  char v6;
  char v7;
  char **p_data;
  char v9;

  if (((unint64_t)theString & 0x8000000000000000) != 0)
  {
    v2 = 0;
    v3 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)theString & 0xC000000000000007) == 0)
      LOBYTE(v3) = 0;
    v4 = (v3 ^ theString) & 7;
    while (v4 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v2))
    {
      if (++v2 == 7)
        goto LABEL_9;
    }
    if (v2 == 2)
      return 0;
  }
LABEL_9:
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    return (const UniChar *)-[__CFString _fastCharacterContents]((id)theString, "_fastCharacterContents");
  v6 = atomic_load((unint64_t *)&theString->info);
  if ((v6 & 0x10) == 0)
    return 0;
  v7 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v7 & 0x60) != 0)
    return (const UniChar *)*p_data;
  v9 = atomic_load((unint64_t *)&theString->info);
  return (const UniChar *)&p_data[(v9 & 5) != 4];
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
  CFIndex length;
  CFIndex location;
  char v7;
  char **p_data;
  char *v9;
  char v10;
  char v11;
  unint64_t v12;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString getCharacters:range:]((id)theString, "getCharacters:range:", buffer, location, length);
  }
  else
  {
    v7 = atomic_load((unint64_t *)&theString->info);
    p_data = &theString->data;
    if ((v7 & 0x60) != 0)
    {
      v9 = *p_data;
    }
    else
    {
      v10 = atomic_load((unint64_t *)&theString->info);
      v9 = (char *)&p_data[(v10 & 5) != 4];
    }
    v11 = atomic_load((unint64_t *)&theString->info);
    if ((v11 & 0x10) != 0)
    {
      memmove(buffer, &v9[2 * location], 2 * length);
    }
    else
    {
      v12 = atomic_load((unint64_t *)&theString->info);
      __CFStrConvertBytesToUnicode((unsigned __int8 *)&v9[location + ((v12 >> 2) & 1)], buffer, length);
    }
  }
}

uint64_t CFUniCharGetBitmapPtrForPlane(unsigned int a1, unsigned int a2)
{
  unsigned int v2;
  uint64_t v5;

  if (a1 - 16 >= 0x54)
    v2 = a1;
  else
    v2 = a1 + 85;
  if (a1 == 1)
    v2 = 108;
  if (v2 <= 0xF && ((1 << v2) & 0x900F) != 0)
    return 0;
  if (v2 > 0x63)
    v2 -= 85;
  v5 = v2 - 4;
  if (v5 <= 0x15 && *((_DWORD *)&__CFUniCharBitmapDataArray + 4 * v5) > a2)
    return *(_QWORD *)(*((_QWORD *)&__CFUniCharBitmapDataArray + 2 * v5 + 1) + 8 * a2);
  else
    return 0;
}

uint64_t CFUniCharGetUnicodePropertyDataForPlane(unsigned int a1, unsigned int a2)
{
  if (*((_DWORD *)&__CFUniCharUnicodePropertyTable + 4 * a1) <= a2)
    return 0;
  else
    return *(_QWORD *)(*((_QWORD *)&__CFUniCharUnicodePropertyTable + 2 * a1 + 1) + 8 * a2);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  CFRange v5;

  v5.length = CFStringGetLength(theString);
  v5.location = 0;
  return CFStringFindWithOptionsAndLocale(theString, suffix, v5, 0xCuLL, 0, 0);
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  CFRange v5;

  v5.length = CFStringGetLength(theString);
  v5.location = 0;
  return CFStringFindWithOptionsAndLocale(theString, prefix, v5, 8uLL, 0, 0);
}

ConstStringPtr CFStringGetPascalStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  unint64_t v7;
  char v8;
  char v9;
  int v10;
  char v11;
  char **p_data;
  ConstStringPtr result;
  char v14;
  char v15;
  char v16;
  uint64_t v17;
  char v18;
  int v19;
  int v20;

  if (((unint64_t)theString & 0x8000000000000000) != 0)
  {
    v4 = 0;
    v5 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)theString & 0xC000000000000007) == 0)
      LOBYTE(v5) = 0;
    v6 = (v5 ^ theString) & 7;
    while (v6 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v4))
    {
      if (++v4 == 7)
        goto LABEL_9;
    }
    if (v4 == 2)
      return 0;
  }
LABEL_9:
  v7 = CF_IS_OBJC(7uLL, (__objc2_class **)theString);
  if ((_DWORD)v7)
    return 0;
  v8 = atomic_load((unint64_t *)&theString->info);
  if ((v8 & 4) == 0)
    return 0;
  v9 = atomic_load((unint64_t *)&theString->info);
  if ((v9 & 0x10) != 0)
    return 0;
  v10 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    v7 = __CFStringComputeEightBitStringEncoding(v7);
    v10 = __CFDefaultEightBitStringEncoding;
  }
  if (v10 != encoding)
  {
    if (v10 == -1)
    {
      __CFStringComputeEightBitStringEncoding(v7);
      v10 = __CFDefaultEightBitStringEncoding;
    }
    if (v10 == 1536)
    {
      result = 0;
      switch(BYTE1(encoding))
      {
        case 0:
          result = 0;
          if ((encoding > 0x22 || ((1 << encoding) & 0x600000032) == 0) && encoding != 152)
            goto LABEL_15;
          return result;
        case 1:
          if (encoding != 134217984)
            return 0;
          goto LABEL_15;
        case 2:
          if (encoding == 518)
            return 0;
          goto LABEL_15;
        case 6:
          if (encoding != 1536)
            return 0;
          goto LABEL_15;
        case 8:
        case 0xC:
          return result;
        case 0xA:
          if (encoding - 2561 > 0xF)
            goto LABEL_15;
          v19 = 1 << (encoding - 1);
          v20 = 32785;
          goto LABEL_46;
        case 0xB:
          if (encoding - 3059 > 0xC)
            goto LABEL_15;
          v19 = 1 << (encoding + 13);
          v20 = 4099;
LABEL_46:
          if ((v19 & v20) != 0)
            return 0;
          goto LABEL_15;
        default:
          if ((encoding & 0xFF00) > 0xC00)
            return 0;
          goto LABEL_15;
      }
    }
    return 0;
  }
LABEL_15:
  v11 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v11 & 0x60) != 0)
  {
    result = (ConstStringPtr)*p_data;
  }
  else
  {
    v14 = atomic_load((unint64_t *)&theString->info);
    result = (ConstStringPtr)&p_data[(v14 & 5) != 4];
  }
  v15 = atomic_load((unint64_t *)&theString->info);
  if ((v15 & 5) != 4)
  {
    v16 = atomic_load((unint64_t *)&theString->info);
    if ((v16 & 5) == 4)
    {
      v17 = *result;
    }
    else
    {
      v18 = atomic_load((unint64_t *)&theString->info);
      v17 = (v18 & 0x60) != 0 ? theString->length : (uint64_t)*p_data;
    }
    if (v17 != *result)
      return 0;
  }
  return result;
}

CFIndex __CFStringLength(uint64_t a1)
{
  return CFStringGetLength(*(CFStringRef *)(a1 + 72));
}

CFIndex CFBitVectorGetCount(CFBitVectorRef bv)
{
  return *((_QWORD *)bv + 2);
}

uint64_t _CFPreferencesCopyAppValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return _CFPreferencesCopyAppValueWithContainerAndConfiguration(a1, a2, a3, 0);
}

uint64_t __CFStringAccess(uint64_t a1, uint64_t a2, int a3)
{
  return doAccess(a1, a2, a3, *(CFStringRef *)(a1 + 72));
}

CFTypeID CFDateGetTypeID(void)
{
  if (CFDateGetTypeID_initOnce != -1)
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
  return 42;
}

uint64_t _getFrameDescriptor(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  _UNKNOWN **v7;

  if ((a1 & 0x8000000000000000) == 0)
    goto LABEL_12;
  v1 = 0;
  v2 = *MEMORY[0x1E0DE7C58];
  if ((~a1 & 0xC000000000000007) == 0)
    v2 = 0;
  v3 = v2 ^ a1;
  v4 = v3 & 7;
  do
  {
    if (v4 == *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v1))
      break;
    ++v1;
  }
  while (v1 != 7);
  if ((~(_BYTE)v1 & 7) == 0 && ((v1 | v3) & 0x7F80000000000000) == 0x600000000000000)
  {
    v5 = v4 == 7;
    v6 = 0xFFFFFFFFFFFFFFFLL;
    if (v5)
      v6 = 0xFFFFFFFFFFFFFLL;
    v7 = __CFGetSignatureROMEntryAtIndex(v6 & (v3 >> 3));
  }
  else
  {
LABEL_12:
    v7 = (_UNKNOWN **)(a1 + 8);
  }
  return (uint64_t)*v7;
}

_UNKNOWN **__CFGetSignatureROMEntryAtIndex(unint64_t a1)
{
  if (a1 >= 0x28FB)
    __CFGetSignatureROMEntryAtIndex_cold_1();
  return &MethodSignatureROMTable + 3 * a1;
}

void __NSICreateBackingForArgumentIfNeeded(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8;
  __CFData *Mutable;
  __CFData *v10;
  void *v11;
  uint64_t v12;
  __CFData *v13;
  __CFData *v14;
  const UInt8 *v15;
  CFIndex v16;
  void *v17;

  if ((*(_WORD *)(a2 + 34) & 0x80) != 0)
  {
    v8 = *(_QWORD *)(a1 + 40);
    if (!v8)
    {
      Mutable = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, objc_msgSend(*(id *)(a1 + 24), "numberOfArguments") + 1);
      if (!Mutable)
        __NSICreateBackingForArgumentIfNeeded_cold_1();
      v10 = Mutable;
      *(_QWORD *)(a1 + 40) = CFDataGetMutableBytePtr(Mutable);
      v11 = *(void **)(a1 + 32);
      if (!v11)
      {
        v11 = (void *)objc_opt_new();
        *(_QWORD *)(a1 + 32) = v11;
        if (!v11)
          __NSICreateBackingForArgumentIfNeeded_cold_2();
      }
      objc_msgSend(v11, "addObject:", v10);
      CFRelease(v10);
      v8 = *(_QWORD *)(a1 + 40);
    }
    v12 = a3 + 1;
    if (!*(_BYTE *)(v8 + a3 + 1))
    {
      v13 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
      v14 = v13;
      if (a4)
      {
        v15 = *(const UInt8 **)(*(_QWORD *)(a1 + 8) + *(_DWORD *)(a2 + 28) + *(unsigned __int8 *)(a2 + 32));
        if (v15)
        {
          CFDataAppendBytes(v13, v15, *(unsigned int *)(*(_QWORD *)a2 + 16));
LABEL_14:
          v17 = *(void **)(a1 + 32);
          if (!v17)
          {
            v17 = (void *)objc_opt_new();
            *(_QWORD *)(a1 + 32) = v17;
          }
          objc_msgSend(v17, "addObject:", v14);
          *(_QWORD *)(*(_QWORD *)(a1 + 8) + *(unsigned int *)(a2 + 28)) = CFDataGetMutableBytePtr(v14);
          *(_BYTE *)(v8 + v12) = 1;
          return;
        }
        v16 = *(unsigned int *)(*(_QWORD *)a2 + 16);
      }
      else
      {
        v16 = *(unsigned int *)(*(_QWORD *)a2 + 16);
      }
      CFDataSetLength(v13, v16);
      goto LABEL_14;
    }
  }
}

uint64_t __NSI1(uint64_t result, uint64_t a2, char *a3, char a4)
{
  char *v5;
  uint64_t v7;
  unsigned int v8;
  __int16 v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  double *v13;
  int v14;
  const char *v15;
  NSException *v16;

  if (result)
  {
    v5 = a3;
    v7 = result;
    while (1)
    {
      v8 = (a4 & 1) != 0 ? *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32) : *(_DWORD *)(v7 + 20);
      v9 = *(_WORD *)(v7 + 34);
      if ((v9 & 0x80) == 0)
        break;
      a4 = 0;
      v7 = *(_QWORD *)v7;
      a2 = *(_QWORD *)(a2 + v8);
      if (!v7)
        return result;
    }
    if ((*(_WORD *)(v7 + 34) & 0x400) != 0 || (v9 & 0x1800) == 0x800)
    {
      v12 = *(_QWORD *)v7;
      if (!v12)
      {
        v15 = "array";
        if ((v9 & 0x400) != 0)
          v15 = "struct";
        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%s with unknown contents found while getting argument"), v15);
        v16 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
        objc_exception_throw(v16);
      }
      do
      {
        result = __NSI1(v12, a2, v5, a4 & 1);
        v12 = *(_QWORD *)(v12 + 8);
      }
      while (v12);
    }
    else if ((*(_WORD *)(v7 + 34) & 0x2000) != 0)
    {
      *(_QWORD *)&a3[*(unsigned int *)(v7 + 20)] = *(_QWORD *)(a2 + v8);
    }
    else
    {
      if ((a4 & 1) != 0)
      {
        v10 = *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32);
        v11 = *(_DWORD *)(v7 + 24) + *(char *)(v7 + 33);
      }
      else
      {
        v11 = *(_DWORD *)(v7 + 16);
        v10 = *(_DWORD *)(v7 + 20);
      }
      v13 = (double *)(a2 + v10);
      if ((v9 & 0x1800) == 0x1800)
      {
        LOWORD(v14) = 8;
      }
      else
      {
        v14 = *(_DWORD *)(v7 + 16);
        v5 = &a3[*(unsigned int *)(v7 + 20)];
      }
      bzero(v5, (unsigned __int16)v14);
      return __NSI0(v7, v13, (unsigned __int16)v11, (double *)v5, (unsigned __int16)v14);
    }
  }
  return result;
}

uint64_t __NSI2(uint64_t result, uint64_t a2, double *a3, char a4)
{
  double *v5;
  uint64_t v7;
  unsigned int v8;
  __int16 v9;
  int v10;
  unsigned int v11;
  int v12;
  uint64_t v13;
  void *v14;
  int v15;
  const char *v16;
  NSException *v17;

  if (result)
  {
    v5 = a3;
    v7 = result;
    while (1)
    {
      v8 = (a4 & 1) != 0 ? *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32) : *(_DWORD *)(v7 + 20);
      v9 = *(_WORD *)(v7 + 34);
      if ((v9 & 0x80) == 0)
        break;
      a4 = 0;
      v7 = *(_QWORD *)v7;
      a2 = *(_QWORD *)(a2 + v8);
      if (!v7)
        return result;
    }
    if ((*(_WORD *)(v7 + 34) & 0x400) != 0 || (v9 & 0x1800) == 0x800)
    {
      v13 = *(_QWORD *)v7;
      if (!v13)
      {
        v16 = "array";
        if ((v9 & 0x400) != 0)
          v16 = "struct";
        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%s with unknown contents found while setting argument"), v16);
        v17 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
        objc_exception_throw(v17);
      }
      do
      {
        result = __NSI2(v13, a2, v5, a4 & 1);
        v13 = *(_QWORD *)(v13 + 8);
      }
      while (v13);
    }
    else
    {
      if ((*(_WORD *)(v7 + 34) & 0x2000) == 0)
      {
        if ((v9 & 0x1800) == 0x1800)
        {
          LOWORD(v10) = 8;
          if ((a4 & 1) == 0)
          {
LABEL_14:
            v11 = *(_DWORD *)(v7 + 20);
            LOWORD(v12) = *(_WORD *)(v7 + 16);
LABEL_22:
            v14 = (void *)(a2 + v11);
            v15 = (unsigned __int16)v12;
            bzero(v14, (unsigned __int16)v12);
            return __NSI0(v7, v5, (unsigned __int16)v10, (double *)v14, v15);
          }
        }
        else
        {
          v10 = *(_DWORD *)(v7 + 16);
          v5 = (double *)((char *)a3 + *(unsigned int *)(v7 + 20));
          if ((a4 & 1) == 0)
            goto LABEL_14;
        }
        v11 = *(_DWORD *)(v7 + 28) + *(unsigned __int8 *)(v7 + 32);
        v12 = *(_DWORD *)(v7 + 24) + *(char *)(v7 + 33);
        goto LABEL_22;
      }
      *(double *)(a2 + v8) = *(double *)((char *)a3 + *(unsigned int *)(v7 + 20));
    }
  }
  return result;
}

uint64_t __NSI0(uint64_t result, double *a2, int a3, double *a4, int a5)
{
  int v5;
  float v6;
  int v7;
  float v8;
  double v9;
  float v10;
  float v11;
  double v12;

  if ((*(_WORD *)(result + 34) & 0x200) != 0)
  {
    v7 = a5 + (a3 << 8);
    if (v7 > 2055)
    {
      if (v7 <= 4099)
      {
        if (v7 != 2056 && v7 != 2064)
          goto LABEL_60;
LABEL_26:
        v9 = *a2;
LABEL_31:
        *a4 = v9;
        return result;
      }
      if (v7 != 4100)
      {
        if (v7 != 4104 && v7 != 4112)
          goto LABEL_60;
        goto LABEL_26;
      }
      goto LABEL_29;
    }
    if (v7 > 1039)
    {
      if (v7 != 1040)
      {
        if (v7 == 2052)
        {
LABEL_29:
          v10 = *a2;
LABEL_42:
          *(float *)a4 = v10;
          return result;
        }
LABEL_60:
        __break(1u);
        return result;
      }
    }
    else
    {
      if (v7 == 1028)
      {
        v10 = *(float *)a2;
        goto LABEL_42;
      }
      if (v7 != 1032)
        goto LABEL_60;
    }
    v9 = *(float *)a2;
    goto LABEL_31;
  }
  v5 = a5 + (a3 << 8);
  if ((*(_WORD *)(result + 34) & 0x100) == 0)
  {
    if (v5 <= 1024)
    {
      switch(v5)
      {
        case 257:
          goto LABEL_35;
        case 258:
          LOWORD(v8) = *(unsigned __int8 *)a2;
          goto LABEL_54;
        case 259:
        case 261:
        case 262:
        case 263:
          goto LABEL_60;
        case 260:
          LODWORD(v6) = *(unsigned __int8 *)a2;
          goto LABEL_56;
        case 264:
          *(_QWORD *)&v12 = *(unsigned __int8 *)a2;
          goto LABEL_59;
        default:
          switch(v5)
          {
            case 513:
              goto LABEL_35;
            case 514:
              goto LABEL_16;
            case 516:
              LODWORD(v6) = *(unsigned __int16 *)a2;
              goto LABEL_56;
            case 520:
              *(_QWORD *)&v12 = *(unsigned __int16 *)a2;
              goto LABEL_59;
            default:
              goto LABEL_60;
          }
      }
    }
    switch(v5)
    {
      case 1025:
        goto LABEL_39;
      case 1026:
        goto LABEL_46;
      case 1027:
      case 1029:
      case 1030:
      case 1031:
        goto LABEL_60;
      case 1028:
        goto LABEL_47;
      case 1032:
        *(_QWORD *)&v12 = *(unsigned int *)a2;
        goto LABEL_59;
      default:
        switch(v5)
        {
          case 2049:
            goto LABEL_23;
          case 2050:
            goto LABEL_43;
          case 2052:
            goto LABEL_44;
          case 2056:
            goto LABEL_45;
          default:
            goto LABEL_60;
        }
    }
  }
  if (v5 <= 1024)
  {
    switch(v5)
    {
      case 257:
LABEL_35:
        LOBYTE(v11) = *(_BYTE *)a2;
        goto LABEL_40;
      case 258:
        LOWORD(v8) = *(char *)a2;
        goto LABEL_54;
      case 259:
      case 261:
      case 262:
      case 263:
        goto LABEL_60;
      case 260:
        LODWORD(v6) = *(char *)a2;
        goto LABEL_56;
      case 264:
        *(_QWORD *)&v12 = *(char *)a2;
        goto LABEL_59;
      default:
        switch(v5)
        {
          case 513:
            goto LABEL_35;
          case 514:
LABEL_16:
            LOWORD(v8) = *(_WORD *)a2;
            goto LABEL_54;
          case 516:
            LODWORD(v6) = *(__int16 *)a2;
            goto LABEL_56;
          case 520:
            *(_QWORD *)&v12 = *(__int16 *)a2;
            goto LABEL_59;
          default:
            goto LABEL_60;
        }
    }
  }
  switch(v5)
  {
    case 1025:
LABEL_39:
      v11 = *(float *)a2;
LABEL_40:
      *(_BYTE *)a4 = LOBYTE(v11);
      break;
    case 1026:
LABEL_46:
      v8 = *(float *)a2;
LABEL_54:
      *(_WORD *)a4 = LOWORD(v8);
      break;
    case 1027:
    case 1029:
    case 1030:
    case 1031:
      goto LABEL_60;
    case 1028:
LABEL_47:
      v6 = *(float *)a2;
LABEL_56:
      *(float *)a4 = v6;
      break;
    case 1032:
      *(_QWORD *)&v12 = *(int *)a2;
LABEL_59:
      *a4 = v12;
      break;
    default:
      switch(v5)
      {
        case 2049:
LABEL_23:
          *(_BYTE *)a4 = *(_QWORD *)a2;
          break;
        case 2050:
LABEL_43:
          *(_WORD *)a4 = *(_QWORD *)a2;
          break;
        case 2052:
LABEL_44:
          *(_DWORD *)a4 = *(_QWORD *)a2;
          break;
        case 2056:
LABEL_45:
          v12 = *a2;
          goto LABEL_59;
        default:
          goto LABEL_60;
      }
      break;
  }
  return result;
}

uint64_t __invoking___(uint64_t (*a1)(unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128), uint64_t a2, __n128 *a3, uint64_t a4)
{
  uint64_t v4;
  __n128 *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v26 = a2;
  v4 = a4 - 224;
  v5 = a3 + 14;
  v6 = (unint64_t *)(((unint64_t)&v26 - a4 + 224) & 0xFFFFFFFFFFFFFFF0);
  while (v4)
  {
    v7 = v5->n128_u64[0];
    v5 = (__n128 *)((char *)v5 + 8);
    v4 -= 8;
    *v6++ = v7;
  }
  result = a1(a3->n128_u64[0], a3->n128_u64[1], a3[1].n128_u64[0], a3[1].n128_u64[1], a3[2].n128_u64[0], a3[2].n128_u64[1], a3[3].n128_u64[0], a3[3].n128_u64[1], a3[5], a3[6], a3[7], a3[8], a3[9], a3[10], a3[11], a3[12]);
  v9 = v26;
  *(_OWORD *)(v26 + 192) = v10;
  *(_OWORD *)(v9 + 176) = v11;
  *(_OWORD *)(v9 + 160) = v12;
  *(_OWORD *)(v9 + 144) = v13;
  *(_OWORD *)(v9 + 128) = v14;
  *(_OWORD *)(v9 + 112) = v15;
  *(_OWORD *)(v9 + 96) = v16;
  *(_OWORD *)(v9 + 80) = v17;
  *(_QWORD *)(v9 + 64) = v18;
  *(_QWORD *)(v9 + 56) = v19;
  *(_QWORD *)(v9 + 48) = v20;
  *(_QWORD *)(v9 + 40) = v21;
  *(_QWORD *)(v9 + 32) = v22;
  *(_QWORD *)(v9 + 24) = v23;
  *(_QWORD *)(v9 + 16) = v24;
  *(_QWORD *)(v9 + 8) = v25;
  *(_QWORD *)v9 = result;
  return result;
}

id _CF_forwarding_prep_0@<X0>(void *a1@<X0>, const char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>, __n128 a10@<Q0>, __n128 a11@<Q1>, __n128 a12@<Q2>, __n128 a13@<Q3>, __n128 a14@<Q4>, __n128 a15@<Q5>, __n128 a16@<Q6>, __n128 a17@<Q7>)
{
  __n128 *v17;
  id v19;
  SEL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  __n128 v31;
  __n128 v32;
  __n128 v33;
  __n128 v34;
  __n128 v35;

  v35 = a17;
  v34 = a16;
  v33 = a15;
  v32 = a14;
  v31 = a13;
  v30 = a12;
  v29 = a11;
  v28 = a10;
  v27 = a9;
  v26 = a8;
  v25 = a7;
  v24 = a6;
  v23 = a5;
  v22 = a4;
  v21 = a3;
  v20 = a2;
  v19 = a1;
  v17 = ___forwarding___((uint64_t)&v19, 0);
  if (v17)
    return (id)v17->n128_u64[0];
  else
    return objc_msgSend(v19, v20, v21, v22, v23, v24, v25, v26, v28.n128_f64[0], v29.n128_f64[0], v30.n128_f64[0], v31.n128_f64[0], v32.n128_f64[0], v33.n128_f64[0], v34.n128_f64[0], v35.n128_f64[0]);
}

__n128 *___forwarding___(uint64_t a1, uint64_t a2)
{
  __n128 *v3;
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  objc_class *Class;
  const char *Name;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  objc_class *v25;
  _BOOL4 v26;
  size_t v27;
  size_t InstanceSize;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  objc_class *v35;
  uint64_t v36;
  unsigned __int8 *v37;
  int v38;
  uint64_t AtomTarget;
  Class Superclass;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  objc_class *v61;
  char v62[256];
  uint64_t v63;

  v3 = (__n128 *)a1;
  v63 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)a1;
  v5 = *(const char **)(a1 + 8);
  if ((*(_QWORD *)a1 & 0x8000000000000000) != 0)
  {
    v6 = 0;
    v7 = *MEMORY[0x1E0DE7C58];
    if ((~v4 & 0xC000000000000007) == 0)
      LOBYTE(v7) = 0;
    v8 = (v7 ^ v4) & 7;
    while (v8 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v6))
    {
      if (++v6 == 7)
        goto LABEL_9;
    }
    if (!v6)
    {
LABEL_43:
      if (dyld_program_sdk_at_least())
        ___forwarding____cold_1();
      AtomTarget = getAtomTarget(v4);
      v3->n128_u64[0] = AtomTarget;
      __invoking___((uint64_t (*)(unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, unint64_t, __n128, __n128, __n128, __n128, __n128, __n128, __n128, __n128))MEMORY[0x1E0DE7D20], (uint64_t)v3, v3, 1024);
      if (v3->n128_u64[0] == AtomTarget)
        v3->n128_u64[0] = v4;
      return v3;
    }
  }
LABEL_9:
  Class = object_getClass(*(id *)a1);
  Name = class_getName(Class);
  if (class_respondsToSelector(Class, sel_forwardingTargetForSelector_))
  {
    v11 = objc_msgSend((id)v4, "forwardingTargetForSelector:", v5);
    if (v11)
    {
      if (v11 != v4)
      {
        if ((v11 & 0x8000000000000000) == 0)
          goto LABEL_40;
        v12 = 0;
        v13 = *MEMORY[0x1E0DE7C58];
        if ((~v11 & 0xC000000000000007) == 0)
          LOBYTE(v13) = 0;
        v14 = (v13 ^ v11) & 7;
        while (v14 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v12))
        {
          if (++v12 == 7)
            goto LABEL_40;
        }
        if (v12)
        {
LABEL_40:
          v3->n128_u64[0] = v11;
          return 0;
        }
        v4 = v11;
        goto LABEL_43;
      }
    }
  }
  if (!strncmp(Name, "_NSZombie_", 0xAuLL))
    ___forwarding____cold_2(v4, (__int16)Name, v5);
  if (!class_respondsToSelector(Class, sel_methodSignatureForSelector_))
  {
    Superclass = class_getSuperclass(Class);
    object_getClassName((id)v4);
    if (Superclass)
    {
      CFLog(4, (uint64_t)CFSTR("*** NSForwarding: warning: object %p of class '%s' does not implement methodSignatureForSelector: -- trouble ahead"), v42, v43, v44, v45, v46, v47, v4);
    }
    else
    {
      object_getClassName((id)v4);
      CFLog(4, (uint64_t)CFSTR("*** NSForwarding: warning: object %p of class '%s' does not implement methodSignatureForSelector: -- did you forget to declare the superclass of '%s'?"), v48, v49, v50, v51, v52, v53, v4);
    }
LABEL_52:
    v54 = sel_getName(v5);
    if (sel_getUid(v54) != v5)
      CFLog(4, (uint64_t)CFSTR("*** NSForwarding: warning: selector (%p) for message '%s' does not match selector known to Objective C runtime (%p)-- abort"), v55, v56, v57, v58, v59, v60, (__int16)v5);
    v61 = object_getClass((id)v4);
    if (class_respondsToSelector(v61, sel_doesNotRecognizeSelector_))
    {
      objc_msgSend((id)v4, "doesNotRecognizeSelector:", v5);
      __break(1u);
    }
    ___forwarding____cold_3((void *)v4);
  }
  v15 = (void *)objc_msgSend((id)v4, "methodSignatureForSelector:", v5);
  if (!v15)
    goto LABEL_52;
  v16 = v15;
  v17 = objc_msgSend(v15, "_frameDescriptor");
  if ((((unint64_t)*(unsigned __int16 *)(*(_QWORD *)v17 + 34) >> 6) & 1) != a2)
  {
    v18 = (unsigned __int16)sel_getName(v5);
    CFLog(4, (uint64_t)CFSTR("*** NSForwarding: warning: method signature and compiler disagree on struct-return-edness of '%s'.  Signature thinks it does%s return a struct, and compiler thinks it does%s."), v19, v20, v21, v22, v23, v24, v18);
  }
  v25 = object_getClass((id)v4);
  v26 = class_respondsToSelector(v25, sel__forwardStackInvocation_);
  if (v26)
  {
    objc_opt_self();
    v27 = objc_msgSend(v16, "frameLength") + 320;
    InstanceSize = class_getInstanceSize((Class)NSInvocation);
    v30 = &v62[-((MEMORY[0x1E0C80A78](InstanceSize, v29) + 15) & 0xFFFFFFFFFFFFFFF0)];
    bzero(v30, InstanceSize);
    bzero(v30, InstanceSize);
    MEMORY[0x1E0C80A78](v31, v32);
    v34 = &v62[-v33];
    bzero(&v62[-v33], v27);
    objc_constructInstance((Class)NSInvocation, v30);
    -[NSInvocation _initWithMethodSignature:frame:buffer:size:]((uint64_t)v30, v16, v3, v34, v27);
    objc_msgSend((id)v4, "_forwardStackInvocation:", v30);
  }
  else
  {
    v35 = object_getClass((id)v4);
    if (!class_respondsToSelector(v35, sel_forwardInvocation_))
      ___forwarding____cold_4(v62, (id)v4);
    v30 = +[NSInvocation _invocationWithMethodSignature:frame:](NSInvocation, "_invocationWithMethodSignature:frame:", v16, v3);
    objc_msgSend((id)v4, "forwardInvocation:", v30);
    v27 = 0;
  }
  if (v30[52] && (*(_WORD *)(*(_QWORD *)v17 + 34) & 0x80) != 0)
  {
    v36 = *(_QWORD *)v17;
    memmove(*(void **)((char *)v3->n128_u64 + *(unsigned int *)(v36 + 28) + *(unsigned __int8 *)(v36 + 32)), *(const void **)(*((_QWORD *)v30 + 1) + *(unsigned int *)(v36 + 28) + *(unsigned __int8 *)(v36 + 32)), *(unsigned int *)(*(_QWORD *)v36 + 16));
  }
  v37 = (unsigned __int8 *)objc_msgSend(v16, "methodReturnType");
  v38 = *v37;
  if (v38 == 118 || v38 == 86 && v37[1] == 118)
  {
    if (v26)

    return (__n128 *)&___forwarding____placeholder;
  }
  else
  {
    v3 = (__n128 *)*((_QWORD *)v30 + 2);
    if (v26)
    {
      v3 = -[NSData bytes](+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", *((_QWORD *)v30 + 2), v27), "bytes");

    }
  }
  return v3;
}

const UInt8 *__NSI3(const UInt8 *result, uint64_t a2, id *a3, char a4)
{
  const UInt8 *v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  const UInt8 *v11;
  int v12;
  __CFData *v13;
  void *v14;
  const UInt8 *v15;
  const UInt8 *i;
  const char *v17;
  __CFData *v18;
  size_t v19;
  const UInt8 *v20;
  id v21;

  if (result)
  {
    v7 = result;
    while (1)
    {
      v8 = (a4 & 1) != 0 ? *((_DWORD *)v7 + 7) + v7[32] : *((_DWORD *)v7 + 5);
      v9 = v8;
      v10 = *((unsigned __int16 *)v7 + 17);
      if ((v10 & 0x80) == 0)
        break;
      a4 = 0;
      v7 = *(const UInt8 **)v7;
      a2 = *(_QWORD *)(a2 + v9);
      if (!v7)
        return result;
    }
    if ((~v10 & 0x1800) != 0)
    {
      if ((v10 & 0xC00) != 0)
      {
        for (i = *(const UInt8 **)v7; i; i = (const UInt8 *)*((_QWORD *)i + 1))
          result = (const UInt8 *)__NSI3(i, a2, a3, a4 & 1);
      }
      else if ((v10 & 0x2000) != 0)
      {
        v20 = *(const UInt8 **)(a2 + v9);
        if ((v10 & 0x8000) != 0)
        {
          result = (const UInt8 *)(id)objc_msgSend(*(id *)(a2 + v9), "copy");
          v20 = result;
          *(_QWORD *)(a2 + v9) = result;
        }
        if (v20)
        {
          v21 = *a3;
          if (!*a3)
          {
            v21 = (id)objc_opt_new();
            *a3 = v21;
          }
          return (const UInt8 *)objc_msgSend(v21, "addObject:", v20);
        }
      }
      else if ((v10 & 0x4000) != 0)
      {
        v17 = *(const char **)(a2 + v9);
        if (v17)
        {
          if (!*a3)
            *a3 = (id)objc_opt_new();
          v18 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
          v19 = strlen(v17);
          CFDataAppendBytes(v18, (const UInt8 *)v17, v19 + 1);
          objc_msgSend(*a3, "addObject:", v18);
          result = CFDataGetMutableBytePtr(v18);
          *(_QWORD *)(a2 + v9) = result;
        }
      }
    }
    else
    {
      v11 = *(const UInt8 **)(a2 + v9);
      if (v11)
      {
        v12 = v10 & 3;
        result = (const UInt8 *)_CFExecutableLinkedOnOrAfter(6uLL);
        if (v12 == 1 || !(_DWORD)result)
        {
          v13 = CFDataCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
          CFDataAppendBytes(v13, v11, *((unsigned int *)v7 + 4));
          v14 = *a3;
          if (!*a3)
          {
            v14 = (void *)objc_opt_new();
            *a3 = v14;
          }
          objc_msgSend(v14, "addObject:", v13);
          result = CFDataGetMutableBytePtr(v13);
          v11 = result;
          *(_QWORD *)(a2 + v9) = result;
        }
        v15 = *(const UInt8 **)v7;
        if (*(_QWORD *)v7)
        {
          do
          {
            result = (const UInt8 *)__NSI3(v15, v11, a3, 0);
            v15 = (const UInt8 *)*((_QWORD *)v15 + 1);
          }
          while (v15);
        }
      }
    }
  }
  return result;
}

DIR *_CFIterateDirectory(const __CFString *a1, int a2, const __CFArray *a3, uint64_t a4)
{
  DIR *result;
  DIR *v8;
  dirent *v9;
  dirent *v10;
  int d_namlen;
  int v12;
  CFIndex v13;
  uint64_t v14;
  const __CFString *ValueAtIndex;
  CFIndex Length;
  CFStringEncoding v17;
  uint64_t v18;
  CFStringRef v19;
  CFStringRef v20;
  CFStringRef v21;
  const __CFString *v22;
  uint64_t d_type;
  CFStringRef v24;
  int v25;
  int v26;
  DIR *v27;
  int v28;
  uint64_t v29;
  CFStringRef cf;
  char __dst[8];
  stat v32;
  char v33[1025];
  char buffer[1026];
  uint64_t v35;
  CFRange v36;

  v35 = *MEMORY[0x1E0C80C00];
  result = (DIR *)CFStringGetFileSystemRepresentation(a1, buffer, 1026);
  if ((_DWORD)result)
  {
    result = opendir(buffer);
    if (result)
    {
      v8 = result;
      v29 = a4;
      v28 = a2;
      v27 = result;
      while (1)
      {
        v9 = readdir(v8);
        if (!v9)
          return (DIR *)closedir(v8);
        v10 = v9;
        d_namlen = v9->d_namlen;
        if (!v9->d_namlen || !v9->d_ino)
          goto LABEL_44;
        if (v9->d_name[0] != 46)
          goto LABEL_14;
        if (d_namlen != 1)
        {
          if (d_namlen == 2)
          {
            v12 = v9->d_name[1];
            if (v12 == 46)
              goto LABEL_44;
          }
          else
          {
            v12 = v9->d_name[1];
          }
          if (v12 != 95)
          {
LABEL_14:
            cf = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9->d_name);
            v33[0] = 0;
            if (a3)
            {
              if (CFArrayGetCount(a3) < 1)
              {
                v14 = 0;
              }
              else
              {
                v13 = 0;
                v14 = 0;
                do
                {
                  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a3, v13);
                  *(_QWORD *)__dst = 0;
                  Length = CFStringGetLength(ValueAtIndex);
                  v17 = CFStringFileSystemEncoding();
                  v36.location = 0;
                  v36.length = Length;
                  v14 += CFStringGetBytes(ValueAtIndex, v36, v17, 0, 0, (UInt8 *)&v33[v14], 1025 - v14, (CFIndex *)__dst);
                  if (v14 >= 1)
                  {
                    v18 = *(_QWORD *)__dst;
                    if (v14 >= *(uint64_t *)__dst)
                    {
                      if (v33[v14 - 1] != 47)
                        v33[v14++] = 47;
                    }
                    else if (v33[*(_QWORD *)__dst - 1] != 47)
                    {
                      v33[*(_QWORD *)__dst] = 47;
                      v14 = v18 + 1;
                    }
                  }
                  ++v13;
                }
                while (v13 < CFArrayGetCount(a3));
              }
              v33[v14] = 0;
              a4 = v29;
              a2 = v28;
              v8 = v27;
            }
            if (a2
              && (v10->d_type == 4
               || !v10->d_type
               && (memset(&v32, 0, sizeof(v32)),
                   strncpy(__dst, buffer, 0x400uLL),
                   __strlcat_chk(),
                   __strlcat_chk(),
                   !stat(__dst, &v32))
               && (v32.st_mode & 0xF000) == 0x4000))
            {
              __strlcat_chk();
            }
            else if (!a3)
            {
              v21 = cf;
              if (cf)
                goto LABEL_40;
              goto LABEL_44;
            }
            __strlcat_chk();
            v19 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v33);
            v20 = v19;
            v21 = cf;
            if (cf)
            {
              if (!v19)
              {
LABEL_40:
                v22 = (const __CFString *)CFRetain(v21);
                v21 = cf;
                v20 = v22;
              }
              d_type = v10->d_type;
              v24 = v21;
              v25 = (*(uint64_t (**)(uint64_t, CFStringRef, CFStringRef, uint64_t))(a4 + 16))(a4, v21, v20, d_type);
              CFRelease(v24);
              CFRelease(v20);
              if (v25)
                v26 = 0;
              else
                v26 = 3;
              goto LABEL_45;
            }
            if (v19)
              CFRelease(v19);
          }
        }
LABEL_44:
        v26 = 2;
LABEL_45:
        if (v26 == 3)
          return (DIR *)closedir(v8);
      }
    }
  }
  return result;
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  uint64_t v3;
  size_t v6;

  v3 = *(_QWORD *)&encoding;
  v6 = strlen(cStr);
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)cStr, v6, v3, 8u, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
}

CFStringRef CFStringCreateWithFileSystemRepresentation(CFAllocatorRef alloc, const char *buffer)
{
  CFStringEncoding v4;

  v4 = CFStringFileSystemEncoding();
  return CFStringCreateWithCString(alloc, buffer, v4);
}

uint64_t CFStringFileSystemEncoding()
{
  if ((__CFDefaultFileSystemEncoding & 1) == 0)
    __CFDefaultFileSystemEncoding = 1;
  return 134217984;
}

CFComparisonResult CFStringCompareWithOptions(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions)
{
  return CFStringCompareWithOptionsAndLocale(theString1, theString2, rangeToCompare, compareOptions, 0);
}

uint64_t parseArrayTag(uint64_t a1, CFArrayRef *a2, unint64_t a3)
{
  uint64_t result;
  const __CFArray *Mutable;
  const __CFSet *v8;
  const __CFSet *v9;
  CFStringRef v10;
  __CFSet *v11;
  int v12;
  uint64_t v13;
  int ContentObject;
  CFStringRef v15;
  int v16;
  int v17;
  CFArrayRef *v18;
  CFArrayRef Copy;
  CFArrayRef *v20;
  __CFSet *v21;
  __CFSet *v22;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[0] = 0;
  if (!*(_BYTE *)(a1 + 80))
  {
    Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0, &kCFTypeArrayCallBacks);
    v8 = *(const __CFSet **)(a1 + 72);
    v21 = 0;
    v22 = 0;
    __CFPropertyListCreateSplitKeypaths(*(const __CFAllocator **)(a1 + 32), v8, &v21, &v22);
    v9 = v21;
    v20 = a2;
    if (!v21)
    {
      ContentObject = getContentObject((unint64_t *)a1, 0, (uint64_t)cf, a3);
      v13 = 0;
      v11 = v22;
      if (ContentObject)
        goto LABEL_17;
      goto LABEL_31;
    }
    v10 = CFStringCreateWithFormat(*(CFAllocatorRef *)(a1 + 32), 0, CFSTR("%ld"), 0);
    if (!CFSetContainsValue(v9, v10) && !CFSetContainsValue(v9, CFSTR("*")))
      *(_BYTE *)(a1 + 80) = 1;
    if (v10)
      CFRelease(v10);
    v11 = v22;
    *(_QWORD *)(a1 + 72) = v22;
    v12 = getContentObject((unint64_t *)a1, 0, (uint64_t)cf, a3);
    *(_QWORD *)(a1 + 72) = v8;
    *(_BYTE *)(a1 + 80) = 0;
    v13 = 1;
    if (!v12)
    {
LABEL_31:
      if (v11)
        CFRelease(v11);
      if (v9)
        CFRelease(v9);
      if (!*(_QWORD *)(a1 + 24) && checkForCloseTag((unint64_t *)a1, (const UInt8 *)"array", 5uLL))
      {
        v17 = allowImmutableCollections;
        if (allowImmutableCollections == -1)
        {
          v17 = getenv("CFPropertyListAllowImmutableCollections") != 0;
          allowImmutableCollections = v17;
        }
        if (v17 == 1)
        {
          v18 = v20;
          if (*(_DWORD *)(a1 + 40))
          {
            Copy = Mutable;
          }
          else
          {
            Copy = CFArrayCreateCopy(*(CFAllocatorRef *)(a1 + 32), Mutable);
            if (Mutable)
              CFRelease(Mutable);
          }
        }
        else
        {
          Copy = Mutable;
          v18 = v20;
        }
        *v18 = Copy;
        return 1;
      }
      if (Mutable)
        CFRelease(Mutable);
      return 0;
    }
    while (1)
    {
      while (1)
      {
LABEL_17:
        if (cf[0])
        {
          CFArrayAppendValue(Mutable, cf[0]);
          if (cf[0])
            CFRelease(cf[0]);
        }
        if (v9)
          break;
        if (!getContentObject((unint64_t *)a1, 0, (uint64_t)cf, a3))
          goto LABEL_31;
      }
      v15 = CFStringCreateWithFormat(*(CFAllocatorRef *)(a1 + 32), 0, CFSTR("%ld"), v13);
      if (!CFSetContainsValue(v9, v15) && !CFSetContainsValue(v9, CFSTR("*")))
        break;
      if (v15)
        goto LABEL_24;
LABEL_25:
      ++v13;
      *(_QWORD *)(a1 + 72) = v11;
      v16 = getContentObject((unint64_t *)a1, 0, (uint64_t)cf, a3);
      *(_QWORD *)(a1 + 72) = v8;
      *(_BYTE *)(a1 + 80) = 0;
      if (!v16)
        goto LABEL_31;
    }
    *(_BYTE *)(a1 + 80) = 1;
    if (!v15)
      goto LABEL_25;
LABEL_24:
    CFRelease(v15);
    goto LABEL_25;
  }
  while (getContentObject((unint64_t *)a1, 0, (uint64_t)cf, a3))
  {
    if (cf[0])
      CFRelease(cf[0]);
  }
  if (*(_QWORD *)(a1 + 24))
    return 0;
  result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"array", 5uLL);
  if (!(_DWORD)result)
    return result;
  *a2 = 0;
  return 1;
}

CFTypeRef _createUniqueStringWithUTF8Bytes(uint64_t a1, const UInt8 *a2, uint64_t a3)
{
  BOOL v6;
  const void *ValueAtIndex;
  unsigned int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!a3)
    return CFRetain(&stru_1E1337B18);
  v9 = 0;
  if (CFBurstTrieContainsUTF8String(*(_QWORD *)(a1 + 48), (uint64_t)a2, a3, &v9))
    v6 = v9 == 0;
  else
    v6 = 1;
  if (v6)
  {
    ValueAtIndex = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), a2, a3, 0x8000100u, 0);
    if (ValueAtIndex)
    {
      v9 = CFArrayGetCount(*(CFArrayRef *)(a1 + 56)) + 1;
      if (CFBurstTrieAddUTF8String(*(_QWORD *)(a1 + 48), (uint64_t)a2, a3, v9))
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 56), ValueAtIndex);
    }
  }
  else
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v9 - 1);
    CFRetain(ValueAtIndex);
  }
  return ValueAtIndex;
}

uint64_t CFBurstTrieContainsUTF8String(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  _DWORD *v7;
  uint64_t result;
  int v9;
  int v10;
  __int128 v11;
  __int128 v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (a3 > 1023)
    return 0;
  v7 = *(_DWORD **)(a1 + 2056);
  if (!v7)
    goto LABEL_13;
  if (*v7 == -1161889074)
    return burstTrieMappedFind((uint64_t)v7 + v7[1], (uint64_t)v7, a2, a3, a4, (*(_DWORD *)(a1 + 2072) & 8) != 0);
  if ((*(_DWORD *)(a1 + 2072) & 0x18) == 0)
  {
LABEL_13:
    traverseCFBurstTrieWithCursor(a1, a2);
    return 0;
  }
  v13 = 0;
  v11 = 0u;
  v12 = 0u;
  CFBurstTrieSetCursorForBytes(a1, (uint64_t)&v11, a2, a3);
  v10 = v9;
  result = 0;
  if (v10 && *(_QWORD *)((char *)&v12 + 1) == 1)
  {
    if (HIDWORD(v11))
    {
      if (a4)
        *a4 = HIDWORD(v11);
      return 1;
    }
    return 0;
  }
  return result;
}

size_t traverseCFBurstTrieWithCursor(uint64_t a1, uint64_t a2)
{
  size_t result;
  unint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t (*v7)(uint64_t, uint64_t);
  uint64_t (*v8)(uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  _BYTE v20[32];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;

  result = MEMORY[0x1E0C80A78](a1, a2);
  v8 = v7;
  v9 = v6;
  v10 = v5;
  v50 = *MEMORY[0x1E0C80C00];
  v11 = *(_QWORD *)(result + 2056);
  if (v11)
  {
    if ((*(_BYTE *)(result + 2072) & 8) != 0)
    {
      return fwrite("Please use CFBurstTrieCursorRef API for file based trie.\n", 0x39uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
    }
    else
    {
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      v36 = 0u;
      v37 = 0u;
      v34 = 0u;
      v35 = 0u;
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      v28 = 0u;
      v29 = 0u;
      v26 = 0u;
      v27 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      *(_OWORD *)&v20[16] = 0u;
      v21 = 0u;
      v19 = 0u;
      *(_OWORD *)v20 = 0u;
      v12 = *(_DWORD *)(v11 + 4);
      *(_QWORD *)&v20[12] = v3;
      *(_DWORD *)v20 = v12;
      *(_QWORD *)&v20[4] = v4;
      return findCFBurstTrieMappedLevel(result, (uint64_t)&v19, v5, v6, v7);
    }
  }
  else
  {
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v44 = 0u;
    v45 = 0u;
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v21 = 0u;
    v19 = 0u;
    *(_DWORD *)&v20[8] = 0;
    v13 = result | 1;
    *(_QWORD *)v20 = result | 1;
    *(_OWORD *)&v20[16] = v3;
    *(_DWORD *)&v20[12] = v4;
    if (v4)
    {
      v14 = 0;
      while (1)
      {
        v15 = *(unsigned __int8 *)(v3 + v14);
        v13 = *(_QWORD *)((v13 & 0xFFFFFFFFFFFFFFFCLL) + 8 * v15);
        *(_QWORD *)v20 = v13;
        v20[v14 + 24] = v15;
        if ((v13 & 3) != 1)
          break;
        if (v4 == ++v14)
          goto LABEL_8;
      }
      if ((v13 & 3) == 2)
      {
        *(_DWORD *)&v20[8] = v14 + 1;
        return findCFBurstTrieList((uint64_t)&v19, v6, v7);
      }
    }
    else
    {
LABEL_8:
      *(_DWORD *)&v20[8] = v4;
      v16 = v13 & 0xFFFFFFFFFFFFFFFCLL;
      v17 = *(unsigned int *)((v13 & 0xFFFFFFFFFFFFFFFCLL) + 2052);
      v18 = v4;
      if ((_DWORD)v17)
      {
        result = ((uint64_t (*)(uint64_t, _BYTE *, uint64_t, uint64_t))v7)(v6, &v20[24], v17, 1);
        if ((result & 1) != 0)
          return result;
        v18 = *(_DWORD *)&v20[8];
        v4 = *(_DWORD *)&v20[12];
      }
      if (v18 != v4 || (v10 & 1) == 0)
        return traverseCFBurstTrieLevel(v16, (uint64_t)&v19, v10, v9, v8);
    }
  }
  return result;
}

uint64_t findCFBurstTrieList(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  uint64_t v3;
  size_t v4;
  int v5;
  unint64_t v6;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;

  v3 = *(_QWORD *)(result + 16);
  v4 = (*(_DWORD *)(result + 28) - *(_DWORD *)(result + 24));
  if ((int)v4 >= 1)
    v5 = *(_DWORD *)(result + 28) - *(_DWORD *)(result + 24);
  else
    v5 = 0;
  v6 = v3 & 0xFFFFFFFFFFFFFFFCLL;
  if ((v3 & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    v9 = result;
    v10 = result + 40;
    do
    {
      v11 = *(unsigned __int16 *)(v6 + 16);
      if (v5 <= (int)v11)
      {
        v12 = *(unsigned int *)(v9 + 24);
        if ((int)v4 <= 0
          || (result = memcmp((const void *)(v6 + 18), (const void *)(*(_QWORD *)(v9 + 32) + v12), v4), !(_DWORD)result))
        {
          result = (uint64_t)memcpy((void *)(v10 + v12), (const void *)(v6 + 18), v11);
          *(_BYTE *)(v9 + *(_DWORD *)(v9 + 24) + *(unsigned __int16 *)(v6 + 16) + 40) = 0;
          *(_QWORD *)(v9 + 16) = v6;
          if (*(_DWORD *)(v6 + 12))
          {
            result = a3(a2, v10);
            if ((result & 1) != 0)
              break;
          }
        }
      }
      v6 = *(_QWORD *)v6;
    }
    while (v6);
  }
  return result;
}

uint64_t containsKey(_DWORD *a1, uint64_t a2, int a3, uint64_t a4)
{
  if ((_DWORD)a4)
    *a1 = a3;
  return a4;
}

uint64_t CFBurstTrieAddUTF8StringWithWeight(unint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  BOOL v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v11;
  uint64_t v12;
  int v13;
  _DWORD *v14;
  uint64_t v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  char *CFBurstTrieListNode;
  _DWORD *v25;
  unsigned int v29;

  v6 = a3 >= 4096 || *(_QWORD *)(a1 + 2056) != 0 || a5 == 0;
  v7 = !v6;
  if (v6)
    return v7;
  v8 = a1;
  v9 = a1;
  if (!(_DWORD)a3)
  {
LABEL_15:
    v13 = *(_DWORD *)(v9 + 2048);
    *(_DWORD *)(v9 + 2048) = v13 + a4;
    *(_DWORD *)(v9 + 2052) = a5;
    if (v13)
      return v7;
LABEL_34:
    ++*(_DWORD *)(v8 + 2076);
    return v7;
  }
  v11 = 0;
  v9 = a1;
  while (1)
  {
    v12 = *(_QWORD *)(v9 + 8 * *(unsigned __int8 *)(a2 + v11));
    if ((v12 & 3) != 1)
      break;
    v9 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    if ((_DWORD)a3 == (_DWORD)++v11)
      goto LABEL_15;
  }
  if ((v12 & 3) != 2)
  {
    *(_QWORD *)(v9 + 8 * *(unsigned __int8 *)(a2 + v11)) = (unint64_t)makeCFBurstTrieListNode((const void *)(a2 + v11 + 1), ~(_DWORD)v11 + (int)a3, a4, a5) | 2;
    goto LABEL_34;
  }
  v29 = v7;
  v14 = (_DWORD *)(v12 & 0xFFFFFFFFFFFFFFFCLL);
  if ((v12 & 0xFFFFFFFFFFFFFFFCLL) == 0)
    CFBurstTrieAddUTF8StringWithWeight_cold_1();
  v15 = (a3 - 1);
  v16 = 1;
  v17 = v12 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    v18 = v17;
    if ((_DWORD)v15 - *(unsigned __int16 *)(v17 + 16) == (_DWORD)v11
      && !memcmp((const void *)(a2 + v11 + 1), (const void *)(v17 + 18), v15 - v11))
    {
      break;
    }
    ++v16;
    v17 = *(_QWORD *)v18;
    if (!*(_QWORD *)v18)
    {
      *(_QWORD *)v18 = makeCFBurstTrieListNode((const void *)(a2 + v11 + 1), (int)v15 - (int)v11, a4, a5);
      v19 = 1;
      goto LABEL_26;
    }
  }
  v19 = 0;
  *(_DWORD *)(v18 + 8) += a4;
  *(_DWORD *)(v18 + 12) = a5;
LABEL_26:
  v8 = a1;
  if (v16 > *(_DWORD *)(a1 + 2080))
  {
    v20 = (unint64_t)malloc_type_calloc(1uLL, 0x808uLL, 0x100004078B9B834uLL);
    do
    {
      v22 = v14[2];
      v21 = v14[3];
      if (*((_WORD *)v14 + 8))
      {
        v23 = *(_QWORD *)(v20 + 8 * *((unsigned __int8 *)v14 + 18));
        CFBurstTrieListNode = makeCFBurstTrieListNode((char *)v14 + 19, *((unsigned __int16 *)v14 + 8) - 1, v14[2], v21);
        *((_DWORD *)CFBurstTrieListNode + 2) = v22;
        *(_QWORD *)CFBurstTrieListNode = v23 & 0xFFFFFFFFFFFFFFFCLL;
        *(_QWORD *)(v20 + 8 * *((unsigned __int8 *)v14 + 18)) = (unint64_t)CFBurstTrieListNode | 2;
      }
      else
      {
        *(_DWORD *)(v20 + 2048) = v22;
        *(_DWORD *)(v20 + 2052) = v21;
      }
      v25 = *(_DWORD **)v14;
      free(v14);
      v14 = v25;
    }
    while (v25);
    v12 = v20 | 1;
  }
  *(_QWORD *)(v9 + 8 * *(unsigned __int8 *)(a2 + v11)) = v12;
  v7 = v29;
  if (v19)
    goto LABEL_34;
  return v7;
}

char *makeCFBurstTrieListNode(const void *a1, unsigned int a2, int a3, int a4)
{
  size_t v8;
  char *v9;

  v8 = a2;
  v9 = (char *)malloc_type_calloc(1uLL, a2 + 19, 0x91998343uLL);
  memcpy(v9 + 18, a1, v8);
  v9[a2 + 18] = 0;
  *(_QWORD *)v9 = 0;
  *((_WORD *)v9 + 8) = a2;
  *((_DWORD *)v9 + 2) = a3;
  *((_DWORD *)v9 + 3) = a4;
  return v9;
}

uint64_t CFBurstTrieAddUTF8String(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddUTF8StringWithWeight(a1, a2, a3, 1, a4);
}

void _CFBundleAddValueForType(void *key, __CFDictionary *a2, CFDictionaryRef theDict, const void *a4, __CFDictionary *a5, int a6)
{
  void *Value;
  CFStringRef v13;

  Value = (void *)CFDictionaryGetValue(theDict, key);
  if (Value)
  {
    if (!a5)
      goto LABEL_7;
  }
  else
  {
    v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@.%@"), CFSTR("_CFBT_"), key);
    Value = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    CFDictionarySetValue(a2, v13, Value);
    CFDictionarySetValue(theDict, key, Value);
    CFRelease(Value);
    CFRelease(v13);
    if (!a5)
    {
LABEL_7:
      CFArrayAppendValue((CFMutableArrayRef)Value, a4);
      return;
    }
  }
  if (a6)
  {
    CFDictionarySetValue(a5, key, key);
    goto LABEL_7;
  }
  if (!CFDictionaryGetValue(a5, key))
    goto LABEL_7;
}

uint64_t findCFBurstTrieMappedLevel(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;

  v9 = result;
  v10 = *(_DWORD *)(a2 + 20);
  v11 = *(_DWORD *)(a2 + 24);
  v12 = (*(_DWORD *)(a2 + 16) & 0xFFFFFFFC) + *(_QWORD *)(result + 2056);
  if (v11 <= v10)
    v13 = v10;
  else
    v13 = v11;
  if (v11 >= v10)
  {
    LODWORD(v15) = *(_DWORD *)(a2 + 24);
LABEL_10:
    if (*(_DWORD *)(v12 + 1024))
    {
      result = a5(a4, a2 + 36);
      if ((result & 1) != 0)
        return result;
      v10 = *(_DWORD *)(a2 + 20);
      LODWORD(v15) = *(_DWORD *)(a2 + 24);
    }
    if ((_DWORD)v15 != v10 || (a3 & 1) == 0)
      return traverseCFBurstTrieMappedLevel(v9, v12, (_DWORD *)a2, a3, a4, a5);
  }
  else
  {
    v14 = *(_QWORD *)(a2 + 28);
    v15 = *(unsigned int *)(a2 + 24);
    while (1)
    {
      v16 = *(unsigned __int8 *)(v14 + v15);
      v17 = *(_DWORD *)(v12 + 4 * v16);
      *(_DWORD *)(a2 + 16) = v17;
      *(_DWORD *)(a2 + 24) = v15 + 1;
      *(_BYTE *)(a2 + 36 + v15) = v16;
      v18 = v17 & 3;
      if (v18 != 1)
        break;
      ++v15;
      v12 = (v17 & 0xFFFFFFFC) + *(_QWORD *)(result + 2056);
      if (v13 == v15)
        goto LABEL_10;
    }
    if (v18 == 2)
    {
      return findCFBurstTrieMappedPage(result, a2, a4, a5);
    }
    else if (v18 == 3)
    {
      return findCFBurstTrieCompactMappedLevel(result, a2, a3, a4, a5);
    }
  }
  return result;
}

uint64_t findCFBurstTrieCompactMappedLevel(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  unsigned int v7;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  int8x8_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int8x8_t v19;
  uint64_t v20;
  int v21;
  int8x8_t v22;
  uint8x8_t v23;
  uint8x8_t v24;
  __int32 v25;
  int v26;

  v7 = a3;
  v9 = result;
  v10 = *(_DWORD *)(a2 + 20);
  v11 = *(_DWORD *)(a2 + 24);
  v12 = (int8x8_t *)((*(_DWORD *)(a2 + 16) & 0xFFFFFFFC) + *(_QWORD *)(result + 2056));
  if (v11 <= v10)
    v13 = v10;
  else
    v13 = v11;
  if (v11 >= v10)
  {
    LODWORD(v17) = *(_DWORD *)(a2 + 24);
LABEL_18:
    if (v12[4].i32[0])
    {
      result = a5(a4, a2 + 36);
      if ((result & 1) != 0)
        return result;
      v10 = *(_DWORD *)(a2 + 20);
      LODWORD(v17) = *(_DWORD *)(a2 + 24);
    }
    if ((_DWORD)v17 != v10 || (v7 & 1) == 0)
      return traverseCFBurstTrieCompactMappedLevel(v9, v12, (_DWORD *)a2, v7, a4, a5);
  }
  else
  {
    v14 = *(_QWORD *)(a2 + 28);
    v15 = *(unsigned int *)(a2 + 24);
    while (1)
    {
      v16 = *(unsigned __int8 *)(v14 + v15);
      v17 = v15 + 1;
      *(_DWORD *)(a2 + 24) = v15 + 1;
      *(_BYTE *)(a2 + v15 + 36) = v16;
      LODWORD(v18) = v16 >> 6;
      v19 = v12[v16 >> 6];
      v20 = 1 << v16;
      if ((*(_QWORD *)&v19 & (1 << v16)) == 0)
        break;
      if (v16 >= 0x40)
      {
        v21 = 0;
        if (v18 <= 1)
          v18 = 1;
        else
          v18 = v18;
        result = (uint64_t)v12;
        do
        {
          v22 = *(int8x8_t *)result;
          result += 8;
          v23 = (uint8x8_t)vcnt_s8(v22);
          v23.i16[0] = vaddlv_u8(v23);
          v21 += v23.i32[0];
          --v18;
        }
        while (v18);
      }
      else
      {
        v21 = 0;
      }
      v24 = (uint8x8_t)vcnt_s8((int8x8_t)((v20 - 1) & *(_QWORD *)&v19));
      v24.i16[0] = vaddlv_u8(v24);
      v25 = v12[4].i32[v21 + v24.i32[0] + 1];
      *(_DWORD *)(a2 + 16) = v25;
      v26 = v25 & 3;
      if (v26 != 3)
      {
        if (v26 == 1)
          return findCFBurstTrieMappedLevel(v9, a2, a3, a4, a5);
        if (v26 == 2)
          return findCFBurstTrieMappedPage(v9, a2, a4, a5);
        return result;
      }
      v12 = (int8x8_t *)((v25 & 0xFFFFFFFC) + *(_QWORD *)(v9 + 2056));
      v15 = v17;
      if (v17 == v13)
        goto LABEL_18;
    }
  }
  return result;
}

uint64_t findCFBurstTrieMappedPage(uint64_t result, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t))
{
  unsigned int *v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  char *v9;
  unsigned __int16 *v10;
  size_t v11;
  int v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unsigned int v15;
  unsigned __int8 *v16;
  char *v17;
  uint64_t v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  size_t v22;
  char *v23;
  uint64_t v26;
  int v27;
  uint64_t v28;
  _BYTE __s1[256];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v5 = (unsigned int *)((*(_DWORD *)(a2 + 16) & 0xFFFFFFFC) + *(_QWORD *)(result + 2056));
  v6 = *v5;
  v27 = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24);
  if (v27 >= 1)
    v7 = *(_DWORD *)(a2 + 20) - *(_DWORD *)(a2 + 24);
  else
    v7 = 0;
  if ((*(_BYTE *)(result + 2072) & 8) != 0)
  {
    if (v6)
    {
      v14 = 0;
      v15 = 0;
      v26 = a2 + 36;
      do
      {
        v16 = v14;
        v17 = (char *)v5 + v15;
        v19 = v17[4];
        v14 = (unsigned __int8 *)(v17 + 4);
        v18 = v19;
        v20 = *(unsigned __int16 *)(v14 + 1);
        if (v16 && v18 > *v16)
          result = (uint64_t)memcpy(&__s1[*v16], v16 + 7, v18 - *v16);
        if ((int)v18 + v20 >= v7)
        {
          v21 = *(unsigned int *)(a2 + 24);
          v22 = *v14;
          if (v27 <= 0
            || (v23 = (char *)(*(_QWORD *)(a2 + 28) + v21), result = memcmp(__s1, v23, *v14), !(_DWORD)result)
            && (result = memcmp(v14 + 7, &v23[v22], (*(_DWORD *)(a2 + 20) - v21 - v22)), !(_DWORD)result))
          {
            memcpy((void *)(v26 + v21), __s1, v22);
            result = (uint64_t)memcpy((void *)(v26 + *(unsigned int *)(a2 + 24) + *v14), v14 + 7, *(unsigned __int16 *)(v14 + 1));
            *(_BYTE *)(a2 + *(_DWORD *)(a2 + 24) + *v14 + *(unsigned __int16 *)(v14 + 1) + 36) = 0;
            if (*(_DWORD *)(v14 + 3))
            {
              result = a4(a3, v26);
              if ((result & 1) != 0)
                break;
            }
          }
        }
        v15 += *(unsigned __int16 *)(v14 + 1) + 7;
      }
      while (v15 < v6);
    }
  }
  else if (v6)
  {
    v8 = 0;
    v28 = a2 + 36;
    do
    {
      v9 = (char *)v5 + v8;
      v12 = *((unsigned __int16 *)v9 + 2);
      v10 = (unsigned __int16 *)(v9 + 4);
      v11 = v12;
      if (v7 <= v12)
      {
        v13 = *(unsigned int *)(a2 + 24);
        result = memcmp(v10 + 3, (const void *)(*(_QWORD *)(a2 + 28) + v13), v7);
        if (!(_DWORD)result)
        {
          result = (uint64_t)memcpy((void *)(v28 + v13), v10 + 3, v11);
          *(_BYTE *)(a2 + *(_DWORD *)(a2 + 24) + *v10 + 36) = 0;
          if (*(_DWORD *)(v10 + 1))
          {
            result = a4(a3, v28);
            if ((result & 1) != 0)
              break;
          }
        }
      }
      v8 += *v10 + 6;
    }
    while (v8 < v6);
  }
  return result;
}

CFIndex CFArrayGetCountOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length;
  CFIndex location;
  const CFArrayCallBacks *v7;
  CFIndex v8;
  const void *v9;
  unsigned int (*equal)(const void *, const void *);
  unsigned int v11;
  int v12;
  char v13;
  int v14;
  const CFArrayCallBacks *v15;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
    goto LABEL_2;
  v11 = atomic_load((unint64_t *)theArray + 1);
  v12 = (v11 >> 2) & 3;
  if (v12)
  {
    if (v12 == 1)
    {
LABEL_2:
      v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }
    v13 = atomic_load((unint64_t *)theArray + 1);
    v14 = v13 & 3;
    if (v14)
      v15 = 0;
    else
      v15 = (const CFArrayCallBacks *)((char *)theArray + 48);
    if (v14 == 2)
      v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    else
      v7 = v15;
  }
  else
  {
    v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_3:
  if (length < 1)
    return 0;
  v8 = 0;
  do
  {
    v9 = (const void *)-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location);
    if (v9 == value
      || (equal = (unsigned int (*)(const void *, const void *))v7->equal) != 0 && equal(value, v9))
    {
      ++v8;
    }
    ++location;
    --length;
  }
  while (length);
  return v8;
}

CFTypeID CFStringGetTypeID(void)
{
  return 7;
}

uint64_t __CFRunLoopDoObservers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  size_t v12;
  uint64_t v13;
  CFIndex i;
  unint64_t *ValueAtIndex;
  char v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t *v21;
  char v22;
  char *v23;
  char v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  uint64_t (*v28)(uint64_t, uint64_t, uint64_t);
  uint64_t v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  char v33;
  uint64_t v34;
  pthread_mutex_t *v35;
  pthread_mutex_t *v36;
  uint64_t v37;
  char *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  v40 = a1;
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  result = *(_QWORD *)(a2 + 112);
  if (result)
  {
    result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      v8 = result;
      v39 = &v34;
      MEMORY[0x1E0C80A78](result, v7);
      v11 = (char *)&v34 - v10;
      if (v9 >= 0x200)
        v12 = 512;
      else
        v12 = v9;
      bzero((char *)&v34 - v10, v12);
      v38 = v11;
      if (v8 >= 0x401)
        v11 = (char *)malloc_type_malloc(8 * v8, 0x2004093837F09uLL);
      v13 = 0;
      for (i = 0; i != v8; ++i)
      {
        ValueAtIndex = (unint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 112), i);
        if ((ValueAtIndex[12] & a3) != 0)
        {
          v16 = atomic_load(ValueAtIndex + 1);
          if ((v16 & 8) != 0)
          {
            v17 = atomic_load(ValueAtIndex + 1);
            if ((v17 & 1) == 0)
              *(_QWORD *)&v11[8 * v13++] = CFRetain(ValueAtIndex);
          }
        }
      }
      v36 = (pthread_mutex_t *)(a2 + 16);
      v37 = a2;
      pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
      v18 = v40;
      v35 = (pthread_mutex_t *)(v40 + 16);
      pthread_mutex_unlock((pthread_mutex_t *)(v40 + 16));
      if (v13 >= 1)
      {
        v19 = 0;
        while (1)
        {
          v20 = *(_QWORD *)&v11[8 * v19];
          pthread_mutex_lock((pthread_mutex_t *)(v20 + 16));
          v21 = (unint64_t *)(v20 + 8);
          v22 = atomic_load((unint64_t *)(v20 + 8));
          if ((v22 & 8) != 0)
            break;
          pthread_mutex_unlock((pthread_mutex_t *)(v20 + 16));
LABEL_42:
          CFRelease((CFTypeRef)v20);
          if (++v19 == v13)
            goto LABEL_43;
        }
        v23 = v11;
        v24 = atomic_load(v21);
        v25 = atomic_load(v21);
        while (1)
        {
          v26 = __ldaxr(v21);
          if (v26 != v25)
            break;
          if (__stlxr(v25 | 1, v21))
            goto LABEL_27;
          v27 = 1;
LABEL_28:
          v25 = v26;
          if (v27)
          {
            pthread_mutex_unlock((pthread_mutex_t *)(v20 + 16));
            v28 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v20 + 112);
            v29 = *(_QWORD *)(v20 + 128);
            if (v18 && !*(_BYTE *)(v18 + 681))
              v30 = 0;
            else
              v30 = (void *)_CFAutoreleasePoolPush();
            kdebug_trace();
            __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(v28, v20, a3, v29);
            kdebug_trace();
            __CFRunLoopPerCalloutARPEnd(v30);
            if ((v24 & 2) == 0)
              CFRunLoopObserverInvalidate((CFRunLoopObserverRef)v20);
            v31 = atomic_load(v21);
            v18 = v40;
            v11 = v23;
            while (1)
            {
              v32 = __ldaxr(v21);
              if (v32 != v31)
                break;
              if (__stlxr(v31 & 0xFFFFFFFFFFFFFFFELL, v21))
                goto LABEL_40;
              v33 = 1;
LABEL_41:
              v31 = v32;
              if ((v33 & 1) != 0)
                goto LABEL_42;
            }
            __clrex();
LABEL_40:
            v33 = 0;
            goto LABEL_41;
          }
        }
        __clrex();
LABEL_27:
        v27 = 0;
        goto LABEL_28;
      }
LABEL_43:
      pthread_mutex_lock(v35);
      pthread_mutex_lock(v36);
      if (v11 != v38)
        free(v11);
      return kdebug_trace();
    }
  }
  return result;
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", idx);
}

void *__CFRunLoopPerCalloutARPEnd(void *result)
{
  if (result)
    return _CFAutoreleasePoolPop(result);
  return result;
}

void sub_182AAF784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, int a10, __int16 a11, __int16 a12, uint64_t a13)
{
  id v14;
  void *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a2)
  {
    v14 = objc_begin_catch(exception_object);
    if (a2 == 2)
    {
      v15 = v14;
      v16 = _CFOSLog();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v17 = objc_msgSend(v15, "name");
        v18 = objc_msgSend(v15, "reason");
        v19 = objc_msgSend(v15, "userInfo");
        LODWORD(a9) = 138543875;
        *(_QWORD *)((char *)&a9 + 4) = v17;
        WORD6(a9) = 2113;
        *(_QWORD *)((char *)&a9 + 14) = v18;
        a12 = 2113;
        a13 = v19;
        _os_log_error_impl(&dword_182A8C000, v16, OS_LOG_TYPE_ERROR, "Caught exception during runloop's autorelease pool drain of client objects %{public}@: %{private}@ userInfo: %{private}@", (uint8_t *)&a9, 0x20u);
      }
      objc_terminate();
    }
    objc_terminate();
  }
  _Unwind_Resume(exception_object);
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(uint64_t (*result)(uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4))(uint64_t, uint64_t, uint64_t)
{
  if (result)
    return (uint64_t (*)(uint64_t, uint64_t, uint64_t))result(a2, a3, a4);
  return result;
}

uint64_t __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

void *_CFAutoreleasePoolPop(void *context)
{
  objc_autoreleasePoolPop(context);
  return context;
}

uint64_t _CFAutoreleasePoolPush()
{
  return MEMORY[0x186DB02F4]();
}

uint64_t __NSDICTIONARY_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

uint64_t __NSCollectionHandleConcurrentEnumerationIfSpecified(char a1, char a2, size_t a3, uint64_t a4)
{
  _QWORD v8[6];
  char v9;
  _QWORD v10[3];
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if ((a1 & 1) == 0 || __CFActiveProcessorCount() < 2)
    return 0;
  v10[0] = 0;
  v10[1] = v10;
  v10[2] = 0x2020000000;
  v11 = 0;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ____NSCollectionHandleConcurrentEnumerationIfSpecified_block_invoke;
  v8[3] = &unk_1E1334700;
  v9 = a2;
  v8[4] = a4;
  v8[5] = v10;
  dispatch_apply(a3, 0, v8);
  _Block_object_dispose(v10, 8);
  return 1;
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  CFIndex length;
  CFIndex location;
  const CFArrayCallBacks *v7;
  const void *v8;
  unsigned int (*equal)(const void *, const void *);
  unsigned int v11;
  int v12;
  char v13;
  int v14;
  const CFArrayCallBacks *v15;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
    goto LABEL_2;
  v11 = atomic_load((unint64_t *)theArray + 1);
  v12 = (v11 >> 2) & 3;
  if (v12)
  {
    if (v12 == 1)
    {
LABEL_2:
      v7 = &kCFTypeArrayCallBacks;
      goto LABEL_3;
    }
    v13 = atomic_load((unint64_t *)theArray + 1);
    v14 = v13 & 3;
    if (v14)
      v15 = 0;
    else
      v15 = (const CFArrayCallBacks *)((char *)theArray + 48);
    if (v14 == 2)
      v7 = (const CFArrayCallBacks *)((char *)theArray + 48);
    else
      v7 = v15;
  }
  else
  {
    v7 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_3:
  if (length < 1)
    return 0;
  while (1)
  {
    v8 = (const void *)-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location);
    if (v8 == value)
      break;
    equal = (unsigned int (*)(const void *, const void *))v7->equal;
    if (equal)
    {
      if (equal(value, v8))
        break;
    }
    ++location;
    if (!--length)
      return 0;
  }
  return 1;
}

uint64_t parseRealTag(uint64_t a1, _QWORD *a2)
{
  const __CFString *v4;
  const void *v5;
  CFErrorRef Error;
  CFTypeRef *v7;
  uint64_t result;
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  CFErrorRef v12;
  uint64_t v13;
  uint64_t v14;
  double valuePtr;
  int v16;
  CFStringRef theString1;
  UniChar buffer[8];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  const __CFString *v26;
  const UniChar *v27;
  const char *v28;
  uint64_t v29;
  CFIndex v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  theString1 = 0;
  if (!parseStringTag(a1, (CFMutableStringRef *)&theString1))
  {
    if (*(_QWORD *)(a1 + 24))
      return 0;
    v13 = lineNumber((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840, CFSTR("Encountered empty <real> on line %u"), v13);
    goto LABEL_34;
  }
  v4 = theString1;
  if (*(_BYTE *)(a1 + 80))
  {
    v5 = 0;
    if (!theString1)
      goto LABEL_20;
    goto LABEL_19;
  }
  if (CFStringCompare(theString1, CFSTR("nan"), 1uLL) == kCFCompareEqualTo)
  {
    v7 = (CFTypeRef *)&kCFNumberNaN;
    goto LABEL_17;
  }
  if (CFStringCompare(v4, CFSTR("+infinity"), 1uLL) == kCFCompareEqualTo)
    goto LABEL_14;
  if (CFStringCompare(v4, CFSTR("-infinity"), 1uLL) == kCFCompareEqualTo)
  {
LABEL_16:
    v7 = (CFTypeRef *)&kCFNumberNegativeInfinity;
LABEL_17:
    v5 = *v7;
    if (*v7)
    {
      CFRetain(*v7);
      if (!v4)
      {
LABEL_20:
        if (checkForCloseTag((unint64_t *)a1, (const UInt8 *)"real", 4uLL))
        {
          *a2 = v5;
          return 1;
        }
        if (v5)
          CFRelease(v5);
        return 0;
      }
LABEL_19:
      CFRelease(v4);
      goto LABEL_20;
    }
    goto LABEL_25;
  }
  if (CFStringCompare(v4, CFSTR("infinity"), 1uLL) == kCFCompareEqualTo)
  {
LABEL_14:
    v7 = (CFTypeRef *)&kCFNumberPositiveInfinity;
    goto LABEL_17;
  }
  if (CFStringCompare(v4, CFSTR("-inf"), 1uLL) == kCFCompareEqualTo)
    goto LABEL_16;
  if (CFStringCompare(v4, CFSTR("inf"), 1uLL) == kCFCompareEqualTo
    || CFStringCompare(v4, CFSTR("+inf"), 1uLL) == kCFCompareEqualTo)
  {
    goto LABEL_14;
  }
LABEL_25:
  Length = CFStringGetLength(v4);
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  *(_OWORD *)buffer = 0u;
  v19 = 0u;
  v26 = v4;
  v29 = 0;
  v30 = Length;
  CharactersPtr = CFStringGetCharactersPtr(v4);
  CStringPtr = 0;
  v27 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(v4, 0x600u);
  v31 = 0;
  v32 = 0;
  v28 = CStringPtr;
  v16 = 0;
  valuePtr = 0.0;
  if (__CFStringScanDouble(buffer, 0, &v16, &valuePtr) && Length == v16)
  {
    v5 = CFNumberCreate(*(CFAllocatorRef *)(a1 + 32), kCFNumberDoubleType, &valuePtr);
    if (!v4)
      goto LABEL_20;
    goto LABEL_19;
  }
  if (v4)
    CFRelease(v4);
  v14 = lineNumber((unint64_t *)a1);
  Error = __CFPropertyListCreateError(3840, CFSTR("Encountered misformatted real on line %u"), v14);
LABEL_34:
  v12 = Error;
  result = 0;
  *(_QWORD *)(a1 + 24) = v12;
  return result;
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  CFRange v7;

  v7.length = CFStringGetLength(theString1);
  v7.location = 0;
  return CFStringCompareWithOptionsAndLocale(theString1, theString2, v7, compareOptions, 0);
}

unint64_t _NSTaggedPointerStringGetLength(uint64_t a1)
{
  int v1;

  v1 = *MEMORY[0x1E0DE7C58];
  if ((~a1 & 0xC000000000000007) == 0)
    v1 = 7;
  return ((unint64_t)(v1 ^ a1) >> 3) & 0xF;
}

CFDataRef _CFXPCCreateCFObjectFromXPCObject(const __CFArray *a1)
{
  CFArrayRef v1;
  Class Class;
  objc_class *v3;
  objc_class *v4;
  objc_class *v5;
  size_t v6;
  CFIndex v7;
  xpc_object_t v8;
  void *v9;
  double v10;
  CFTypeRef *v12;
  _BOOL4 value;
  const char *string_ptr;
  size_t length;
  CFIndex v17;
  const UInt8 *bytes_ptr;
  int64_t v19;
  size_t count;
  CFIndex v21;
  const void **p_uu1;
  uint64_t v23;
  uint64_t v24;
  const void **v25;
  xpc_object_t v26;
  void *v27;
  const void **v28;
  uint64_t v29;
  uint64_t v30;
  const void **v31;
  xpc_object_t v32;
  const __CFArray *v33;
  __objc2_class **v34;
  CFTypeID v35;
  CFTypeID TypeID;
  const __CFString *v37;
  const __CFString *v38;
  const __CFURL *v39;
  _QWORD v40[7];
  _QWORD applier[6];
  uuid_t uu;
  uint64_t v43;
  uint64_t v44;
  __int128 uu1;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;
  CFUUIDBytes v78;

  v1 = a1;
  v77 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return v1;
  Class = object_getClass(a1);
  v3 = (objc_class *)MEMORY[0x1E0C81350];
  if (Class == (Class)MEMORY[0x1E0C81350])
  {
    v12 = (CFTypeRef *)&kCFNull;
    return (CFDataRef)CFRetain(*v12);
  }
  if (Class == (Class)MEMORY[0x1E0C812D0])
  {
    value = xpc_BOOL_get_value(v1);
    v12 = (CFTypeRef *)&kCFBooleanTrue;
    if (!value)
      v12 = (CFTypeRef *)&kCFBooleanFalse;
    return (CFDataRef)CFRetain(*v12);
  }
  if (Class == (Class)MEMORY[0x1E0C81390])
  {
    string_ptr = xpc_string_get_string_ptr(v1);
    return (CFDataRef)CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, string_ptr, 0x8000100u);
  }
  if (Class == (Class)MEMORY[0x1E0C812E8])
  {
    length = xpc_data_get_length(v1);
    if ((length & 0x8000000000000000) == 0)
    {
      v17 = length;
      bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(v1);
      return CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes_ptr, v17);
    }
    return 0;
  }
  if (Class == (Class)MEMORY[0x1E0C81328])
  {
    *(_QWORD *)&uu1 = xpc_int64_get_value(v1);
    return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt64Type, &uu1);
  }
  if (Class == (Class)MEMORY[0x1E0C81300])
  {
    *(_QWORD *)&uu1 = xpc_double_get_value(v1);
    return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberDoubleType, &uu1);
  }
  if (Class == (Class)MEMORY[0x1E0C812F0])
  {
    v19 = xpc_date_get_value(v1);
    return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (double)v19 / 1000000000.0 - 978307200.0);
  }
  v4 = (objc_class *)MEMORY[0x1E0C813A0];
  if (Class == (Class)MEMORY[0x1E0C813A0])
  {
    v78 = *(CFUUIDBytes *)xpc_uuid_get_bytes(v1);
    return CFUUIDCreateFromUUIDBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v78);
  }
  if (Class == (Class)MEMORY[0x1E0C812C8])
  {
    count = xpc_array_get_count(v1);
    if (!(count >> 59))
    {
      v21 = count;
      v75 = 0u;
      v76 = 0u;
      v73 = 0u;
      v74 = 0u;
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v55 = 0u;
      v56 = 0u;
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      v49 = 0u;
      v50 = 0u;
      v47 = 0u;
      v48 = 0u;
      uu1 = 0u;
      v46 = 0u;
      if (count >= 0x101)
      {
        p_uu1 = (const void **)malloc_type_malloc(8 * count, 0xC0040B8AA526DuLL);
        if (!p_uu1)
          return 0;
      }
      else
      {
        p_uu1 = (const void **)&uu1;
      }
      *(_QWORD *)uu = 0;
      *(_QWORD *)&uu[8] = uu;
      v43 = 0x2000000000;
      v44 = 0;
      applier[0] = MEMORY[0x1E0C809B0];
      applier[1] = 0x40000000;
      applier[2] = ___CFXPCCreateCFObjectFromXPCObject_block_invoke;
      applier[3] = &unk_1E1335F58;
      applier[4] = uu;
      applier[5] = p_uu1;
      xpc_array_apply(v1, applier);
      v23 = *(_QWORD *)(*(_QWORD *)&uu[8] + 24);
      if (v21 == v23)
      {
        v1 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, p_uu1, v21, &kCFTypeArrayCallBacks);
        v23 = *(_QWORD *)(*(_QWORD *)&uu[8] + 24);
      }
      else
      {
        v1 = 0;
      }
      if (v23 >= 1)
      {
        v24 = 0;
        do
          CFRelease(p_uu1[v24++]);
        while (v24 < *(_QWORD *)(*(_QWORD *)&uu[8] + 24));
      }
      if (p_uu1 == (const void **)&uu1)
        goto LABEL_62;
      v25 = p_uu1;
      goto LABEL_61;
    }
    return 0;
  }
  v5 = (objc_class *)MEMORY[0x1E0C812F8];
  if (Class != (Class)MEMORY[0x1E0C812F8])
    return 0;
  v6 = xpc_dictionary_get_count(v1);
  if (v6 >> 58)
    return 0;
  v7 = v6;
  if (v6 == 3)
  {
    v26 = xpc_dictionary_get_value(v1, "com.apple.CFURL.magic");
    if (!v26)
      goto LABEL_50;
    v27 = v26;
    if (object_getClass(v26) == v4)
    {
      uu1 = 0uLL;
      memset(uu, 0, sizeof(uu));
      uu1 = *(_OWORD *)xpc_uuid_get_bytes(v27);
      if (uuid_parse("C3853DCC-9776-4114-B6C1-FD9F51944A6D", uu) || uuid_compare((const unsigned __int8 *)&uu1, uu))
        goto LABEL_50;
      v32 = xpc_dictionary_get_value(v1, "com.apple.CFURL.string");
      if (v32)
      {
        v33 = (const __CFArray *)xpc_dictionary_get_value(v1, "com.apple.CFURL.base");
        v1 = v33;
        if (!v33)
          return v1;
        if (object_getClass(v33) == v5 || object_getClass(v1) == v3)
        {
          v34 = (__objc2_class **)_CFXPCCreateCFObjectFromXPCObject(v1);
          if (v34)
          {
            v35 = CFURLGetTypeID();
            if (v35 == CFGetTypeID(v34) || (TypeID = CFNullGetTypeID(), TypeID == CFGetTypeID(v34)))
            {
              v37 = (const __CFString *)_CFXPCCreateCFObjectFromXPCObject(v32);
              v38 = v37;
              if (v37)
              {
                if (CFGetTypeID(v37) == 7)
                {
                  if (&__kCFNull == v34)
                    v39 = 0;
                  else
                    v39 = (const __CFURL *)v34;
                  v1 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v38, v39);
                  CFRelease(v34);
                  CFRelease(v38);
                  return v1;
                }
                CFRelease(v38);
              }
            }
            CFRelease(v34);
          }
        }
      }
    }
    return 0;
  }
  if (v6 != 2)
  {
    v75 = 0u;
    v76 = 0u;
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    v65 = 0u;
    v66 = 0u;
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    v59 = 0u;
    v60 = 0u;
    v57 = 0u;
    v58 = 0u;
    v55 = 0u;
    v56 = 0u;
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    uu1 = 0u;
    v46 = 0u;
    if (v6 < 0x81)
      goto LABEL_52;
    v28 = (const void **)malloc_type_malloc(16 * v6, 0xC0040B8AA526DuLL);
    if (v28)
      goto LABEL_53;
    return 0;
  }
  v8 = xpc_dictionary_get_value(v1, "com.apple.CFDate.magic");
  if (!v8)
  {
LABEL_50:
    v75 = 0u;
    v76 = 0u;
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    v65 = 0u;
    v66 = 0u;
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    v59 = 0u;
    v60 = 0u;
    v57 = 0u;
    v58 = 0u;
    v55 = 0u;
    v56 = 0u;
    v53 = 0u;
    v54 = 0u;
    v51 = 0u;
    v52 = 0u;
    v49 = 0u;
    v50 = 0u;
    v47 = 0u;
    v48 = 0u;
    uu1 = 0u;
    v46 = 0u;
LABEL_52:
    v28 = (const void **)&uu1;
LABEL_53:
    *(_QWORD *)uu = 0;
    *(_QWORD *)&uu[8] = uu;
    v43 = 0x2000000000;
    v44 = 0;
    v40[0] = MEMORY[0x1E0C809B0];
    v40[1] = 0x40000000;
    v40[2] = ___CFXPCCreateCFObjectFromXPCObject_block_invoke_2;
    v40[3] = &unk_1E1335F80;
    v40[4] = uu;
    v40[5] = v28;
    v40[6] = v7;
    xpc_dictionary_apply(v1, v40);
    v29 = *(_QWORD *)(*(_QWORD *)&uu[8] + 24);
    if (v7 == v29)
    {
      v1 = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v28, &v28[v7], v7, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v29 = *(_QWORD *)(*(_QWORD *)&uu[8] + 24);
    }
    else
    {
      v1 = 0;
    }
    if (v29 >= 1)
    {
      v30 = 0;
      v31 = &v28[v7];
      do
      {
        CFRelease(v28[v30]);
        CFRelease(v31[v30++]);
      }
      while (v30 < *(_QWORD *)(*(_QWORD *)&uu[8] + 24));
    }
    if (v28 == (const void **)&uu1)
      goto LABEL_62;
    v25 = v28;
LABEL_61:
    free(v25);
LABEL_62:
    _Block_object_dispose(uu, 8);
    return v1;
  }
  v9 = v8;
  if (object_getClass(v8) != v4)
    return 0;
  memset(uu, 0, sizeof(uu));
  uu1 = *(_OWORD *)xpc_uuid_get_bytes(v9);
  if (uuid_parse("C119A421-DF31-48EF-843D-21B4030D1621", uu) || uuid_compare((const unsigned __int8 *)&uu1, uu))
    goto LABEL_50;
  v10 = xpc_dictionary_get_double(v1, "com.apple.CFDate.ti");
  return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10 - 978307200.0);
}

void sub_182AB1098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  __objc2_class **v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  double v16;
  uint64_t v17;
  BOOL v18;
  unsigned int v20;
  _BOOL4 v21;
  float v22;
  __objc2_class **v23;
  double v24;
  uint64_t v25;
  unsigned int v26;
  BOOL v27;
  uint64_t v29;
  uint64_t Instance;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  int v45;
  unint64_t *v46;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int v51;

  v5 = (__objc2_class **)allocator;
  if (!allocator)
  {
    v6 = _CFGetTSD(1u);
    if (v6)
      v5 = (__objc2_class **)v6;
    else
      v5 = &__kCFAllocatorSystemDefault;
  }
  if ((__CFNumberTaggedPointersDisabled & 1) == 0
    && (&__kCFAllocatorSystemDefault == v5
     || !v5 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault())
    && __CFNumberCaching != 2)
  {
    switch(__CFNumberTypeTable[theType] & 0x1F)
    {
      case 1:
        v7 = *MEMORY[0x1E0DE7C58];
        v8 = ((uint64_t)*(char *)valuePtr << 7) | 0x8000000000000003;
        goto LABEL_15;
      case 2:
        v9 = *(__int16 *)valuePtr;
        v7 = *MEMORY[0x1E0DE7C58];
        v10 = 0x800000000000000BLL;
        goto LABEL_14;
      case 3:
        v9 = *(int *)valuePtr;
        v7 = *MEMORY[0x1E0DE7C58];
        v10 = 0x8000000000000013;
LABEL_14:
        v8 = v10 | (v9 << 7);
LABEL_15:
        v11 = v8 ^ v7;
        goto LABEL_115;
      case 4:
        if ((unint64_t)(*(_QWORD *)valuePtr - 0x80000000000000) < 0xFF00000000000001)
          goto LABEL_36;
        v12 = *MEMORY[0x1E0DE7C58];
        v8 = (*(_QWORD *)valuePtr << 7) | 0x800000000000001BLL;
        goto LABEL_114;
      case 5:
        v13 = (uint64_t)*(float *)valuePtr;
        if (*(float *)valuePtr != (float)v13)
          goto LABEL_36;
        v14 = *(int *)valuePtr < 0 && v13 == 0;
        if (v14 || (unint64_t)(v13 - 0x80000000000000) < 0xFF00000000000001)
          goto LABEL_36;
        v12 = *MEMORY[0x1E0DE7C58];
        v8 = (v13 << 7) | 0x8000000000000023;
        goto LABEL_114;
      case 6:
        v16 = *(double *)valuePtr;
        if (*(double *)valuePtr != (double)(uint64_t)*(double *)valuePtr)
          goto LABEL_36;
        v17 = (uint64_t)v16;
        v18 = v16 < 0.0 && v17 == 0;
        if (v18 || (unint64_t)(v17 - 0x80000000000000) < 0xFF00000000000001)
          goto LABEL_36;
        v12 = *MEMORY[0x1E0DE7C58];
        v8 = (v17 << 7) | 0x800000000000002BLL;
LABEL_114:
        v11 = v12 ^ v8;
LABEL_115:
        if ((~v11 & 0xC000000000000007) != 0)
          v8 = v11 & 0xFFFFFFFFFFFFFFF8 | *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + (v11 & 7));
        break;
      default:
        goto LABEL_36;
    }
    return (CFNumberRef)v8;
  }
LABEL_36:
  v20 = (unsigned __int16)__CFNumberTypeTable[theType];
  if ((v20 & 0x20) != 0)
  {
    if ((v20 & 0x40) != 0)
    {
      v24 = *(double *)valuePtr;
      if (!*(_QWORD *)valuePtr)
      {
        v23 = &__kCFNumberFloat64Zero;
        return (CFNumberRef)CFRetain(v23);
      }
      if (*(_QWORD *)valuePtr == 0x3FF0000000000000)
      {
        v23 = &__kCFNumberFloat64One;
        return (CFNumberRef)CFRetain(v23);
      }
      if (fabs(v24) != INFINITY)
        goto LABEL_67;
      v27 = v24 < 0.0;
    }
    else
    {
      v22 = *(float *)valuePtr;
      if (!*(_DWORD *)valuePtr)
      {
        v23 = &__kCFNumberFloat32Zero;
        return (CFNumberRef)CFRetain(v23);
      }
      if (*(_DWORD *)valuePtr == 1065353216)
      {
        v23 = &__kCFNumberFloat32One;
        return (CFNumberRef)CFRetain(v23);
      }
      if (fabsf(v22) != INFINITY)
        goto LABEL_67;
      v27 = v22 < 0.0;
    }
    if (v27)
      v23 = &__kCFNumberNegativeInfinity;
    else
      v23 = &__kCFNumberPositiveInfinity;
    return (CFNumberRef)CFRetain(v23);
  }
  if (&__kCFAllocatorSystemDefault == v5)
  {
    v21 = 1;
    goto LABEL_48;
  }
  if (v5)
  {
LABEL_67:
    v25 = -2;
    goto LABEL_68;
  }
  v21 = &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault();
LABEL_48:
  v25 = -2;
  if (v21 && !__CFNumberCaching)
  {
    switch(v20 & 0x1F)
    {
      case 1u:
        v25 = *(char *)valuePtr;
        v26 = (v25 + 1);
        goto LABEL_63;
      case 2u:
        v25 = *(__int16 *)valuePtr;
        v26 = (unsigned __int16)(v25 + 1);
        goto LABEL_63;
      case 3u:
        v25 = *(int *)valuePtr;
        v26 = v25 + 1;
LABEL_63:
        if (v26 <= 0xD)
          goto LABEL_64;
        goto LABEL_67;
      case 4u:
        v25 = *(_QWORD *)valuePtr;
        if ((unint64_t)(*(_QWORD *)valuePtr + 1) > 0xD)
          goto LABEL_67;
LABEL_64:
        v23 = (__objc2_class **)__CFNumberCache[v25 + 1];
        if (v23)
          return (CFNumberRef)CFRetain(v23);
        break;
      default:
        break;
    }
  }
LABEL_68:
  if ((v20 & 0x20) != 0)
    v29 = 8;
  else
    v29 = ((v20 >> 3) & 8) + 8;
  if (CFNumberGetTypeID_initOnce != -1)
    dispatch_once(&CFNumberGetTypeID_initOnce, &__block_literal_global_8);
  Instance = _CFRuntimeCreateInstance(v5, 0x16uLL, v29, 0);
  v8 = Instance;
  if (Instance)
  {
    v31 = __CFNumberCanonicalTypeIndex[v20 & 0x1F] & 7;
    v32 = (unint64_t *)(Instance + 8);
    v33 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      v34 = __ldaxr(v32);
      if (v34 != v33)
        break;
      if (__stlxr(v33 & 0xFFFFFFFFFFFFFFC0 | v31, v32))
        goto LABEL_79;
      v35 = 1;
LABEL_80:
      v33 = v34;
      if (v35)
      {
        __CFNumberInit(Instance, theType, (char *)valuePtr);
        if (v25 == -2)
          return (CFNumberRef)v8;
        *(_QWORD *)(v8 + 16) = v25;
        if ((v8 & 0x8000000000000000) == 0)
          goto LABEL_93;
        v36 = 0;
        v37 = *MEMORY[0x1E0DE7C58];
        if ((~v8 & 0xC000000000000007) == 0)
          v37 = 0;
        v38 = v37 ^ v8;
        v39 = v38 & 7;
        while (v39 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v36))
        {
          if (++v36 == 7)
            goto LABEL_93;
        }
        if (v36 == 3)
        {
          v40 = 0xFFFFFFFFFFFFFFFLL;
          if (v39 == 7)
            v40 = 0xFFFFFFFFFFFFFLL;
          v41 = v40 & (v38 >> 3);
        }
        else
        {
LABEL_93:
          LOBYTE(v41) = atomic_load(v32);
        }
        v42 = __CFNumberCanonicalTypes[v41 & 7];
        v43 = atomic_load(v32);
        while (2)
        {
          v44 = __ldaxr(v32);
          if (v44 == v43)
          {
            if (!__stlxr(v43 & 0xFFFFFFFFFFFFFFC0 | 2, v32))
            {
              v45 = 1;
              goto LABEL_100;
            }
          }
          else
          {
            __clrex();
          }
          v45 = 0;
LABEL_100:
          v43 = v44;
          if (v45)
          {
            v46 = &__CFNumberCache[v25 + 1];
            while (!__ldaxr(v46))
            {
              if (!__stlxr(v8, v46))
              {
                CFRetain((CFTypeRef)v8);
                return (CFNumberRef)v8;
              }
            }
            __clrex();
            v48 = __CFNumberCanonicalTypeIndex[v42] & 7;
            v49 = atomic_load(v32);
            while (2)
            {
              v50 = __ldaxr(v32);
              if (v50 == v49)
              {
                if (!__stlxr(v49 & 0xFFFFFFFFFFFFFFC0 | v48, v32))
                {
                  v51 = 1;
                  goto LABEL_111;
                }
              }
              else
              {
                __clrex();
              }
              v51 = 0;
LABEL_111:
              v49 = v50;
              if (v51)
                return (CFNumberRef)v8;
              continue;
            }
          }
          continue;
        }
      }
    }
    __clrex();
LABEL_79:
    v35 = 0;
    goto LABEL_80;
  }
  return (CFNumberRef)v8;
}

__n128 __CFNumberInit(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v3;
  __n128 result;

  switch(__CFNumberTypeTable[a2] & 0x1F)
  {
    case 1:
      v3 = *a3;
      goto LABEL_6;
    case 2:
      v3 = *(__int16 *)a3;
      goto LABEL_6;
    case 3:
      v3 = *(int *)a3;
      goto LABEL_6;
    case 4:
    case 6:
      v3 = *(_QWORD *)a3;
LABEL_6:
      *(_QWORD *)(a1 + 16) = v3;
      break;
    case 5:
      *(_DWORD *)(a1 + 16) = *(_DWORD *)a3;
      break;
    case 0x11:
      result = *(__n128 *)a3;
      *(_OWORD *)(a1 + 16) = *(_OWORD *)a3;
      break;
    default:
      return result;
  }
  return result;
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  CFIndex v8;
  const void **v9;
  const void **v10;
  unint64_t *v12;
  uint64_t Generic;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  int v20;

  v8 = numValues;
  v9 = values;
  v10 = keys;
  v12 = (unint64_t *)__NSCFDictionaryCreate((__objc2_class **)allocator, (unint64_t *)keys, (unint64_t *)values, numValues, keyCallBacks, valueCallBacks);
  if (v12)
    return (CFDictionaryRef)v12;
  Generic = __CFDictionaryCreateGeneric((__objc2_class **)allocator, (uint64_t)keyCallBacks, valueCallBacks);
  v12 = (unint64_t *)Generic;
  if (!Generic)
    return (CFDictionaryRef)v12;
  if (v8 >= 1)
  {
    CFBasicHashSetCapacity(Generic, v8);
    do
    {
      v15 = (unint64_t)*v10++;
      v14 = v15;
      v16 = (uint64_t)*v9++;
      CFBasicHashAddValue((uint64_t)v12, v14, v16);
      --v8;
    }
    while (v8);
  }
  v17 = v12 + 1;
  v18 = atomic_load(v12 + 1);
  do
  {
    v19 = __ldaxr(v17);
    if (v19 == v18)
    {
      if (!__stlxr(v18 | 0x40, v17))
      {
        v20 = 1;
        goto LABEL_12;
      }
    }
    else
    {
      __clrex();
    }
    v20 = 0;
LABEL_12:
    v18 = v19;
  }
  while (!v20);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)v12, 0x12uLL);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  return (CFDictionaryRef)v12;
}

__objc2_class **__NSCFDictionaryCreate(__objc2_class **a1, unint64_t *a2, unint64_t *a3, unint64_t a4, const CFDictionaryKeyCallBacks *a5, const CFDictionaryValueCallBacks *a6)
{
  BOOL v12;
  uint64_t *v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t v18;

  if (__FoundationPresent_static_init_0 != -1)
    dispatch_once(&__FoundationPresent_static_init_0, &__block_literal_global_45);
  if (!__FoundationPresent_present_0
    || &__kCFAllocatorSystemDefault != a1
    && (a1 || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    return 0;
  }
  v12 = a5 == &kCFCopyStringDictionaryKeyCallBacks || a5 == &kCFTypeDictionaryKeyCallBacks;
  if (!v12 || a6 != &kCFTypeDictionaryValueCallBacks)
    return 0;
  if (a5 != &kCFCopyStringDictionaryKeyCallBacks)
  {
    v15 = (uint64_t *)a2;
    v16 = (uint64_t *)a3;
    v17 = a4;
    v18 = 0;
    return (__objc2_class **)__NSDictionaryI_new(v15, v16, 0, v17, v18);
  }
  if (!a4)
    return &__NSDictionary0__struct;
  if (a4 != 1)
  {
    v15 = (uint64_t *)a2;
    v16 = (uint64_t *)a3;
    v17 = a4;
    v18 = 1;
    return (__objc2_class **)__NSDictionaryI_new(v15, v16, 0, v17, v18);
  }
  return (__objc2_class **)__NSSingleEntryDictionaryI_new(*a2, *a3, 1);
}

uint64_t __CFStringScanDouble(UniChar *buffer, uint64_t a2, int *a3, double *a4)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  UniChar v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int64_t v15;
  const __CFAllocator *v16;
  int v17;
  char *Typed;
  size_t v19;
  uint64_t v20;
  signed int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  double *v30;
  char *v31;
  char __src[256];
  uint64_t v33;
  CFRange v34;
  CFRange v35;

  v33 = *MEMORY[0x1E0C80C00];
  v31 = 0;
  v7 = *a3;
  if (*a3 < 0)
    goto LABEL_5;
LABEL_2:
  v8 = v7;
  v9 = *((_QWORD *)buffer + 20);
  if (v9 > v8)
  {
    v10 = *((_QWORD *)buffer + 17);
    if (v10)
    {
      v11 = *(_WORD *)(v10 + 2 * (*((_QWORD *)buffer + 19) + v8));
    }
    else
    {
      v12 = *((_QWORD *)buffer + 18);
      if (v12)
      {
        v11 = *(char *)(v12 + *((_QWORD *)buffer + 19) + v8);
      }
      else
      {
        if (*((_QWORD *)buffer + 22) <= v8 || (v13 = *((_QWORD *)buffer + 21), v13 > v8))
        {
          v14 = v8 - 4;
          if (v8 < 4)
            v14 = 0;
          if (v14 + 64 < v9)
            v9 = v14 + 64;
          *((_QWORD *)buffer + 21) = v14;
          *((_QWORD *)buffer + 22) = v9;
          v34.location = *((_QWORD *)buffer + 19) + v14;
          v34.length = v9 - v14;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v34, buffer);
          v13 = *((_QWORD *)buffer + 21);
        }
        v11 = buffer[v8 - v13];
      }
    }
    goto LABEL_6;
  }
LABEL_5:
  while (1)
  {
    v11 = -1;
LABEL_6:
    if (v11 != 12288
      && (unsigned __int16)(v11 - 0x2000) >= 0xCu
      && v11 >= 0x21u
      && (unsigned __int16)(v11 - 127) >= 0x22u)
    {
      break;
    }
    v7 = *a3 + 1;
    *a3 = v7;
    if ((v7 & 0x80000000) == 0)
      goto LABEL_2;
  }
  if (v11 >= 0x80u)
  {
    __src[0] = 0;
    Typed = __src;
    v28 = strtod_l(__src, &v31, 0);
  }
  else
  {
    v30 = a4;
    v15 = 0;
    v16 = 0;
    v17 = 256;
    Typed = __src;
    while (1)
    {
      v19 = v15;
      if (((__CFNumberSet[v11 >> 3] >> (v11 & 7)) & 1) == 0)
        break;
      if (v15 >= v17 - 1)
      {
        if (!v16)
        {
          v20 = _CFGetTSD(1u);
          if (v20)
            v16 = (const __CFAllocator *)v20;
          else
            v16 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
        }
        v17 += 256;
        if (Typed == __src)
        {
          Typed = (char *)CFAllocatorAllocateTyped(v16, v17, 0x100004077774924, 0);
          memmove(Typed, __src, v19);
        }
        else
        {
          Typed = (char *)__CFSafelyReallocateWithAllocatorTyped(v16, Typed, v17, 0x100004077774924, 0, 0);
        }
      }
      Typed[v19] = v11;
      v21 = v19 + *a3 + 1;
      if ((v21 & 0x80000000) == 0)
      {
        v22 = v21;
        v23 = *((_QWORD *)buffer + 20);
        if (v23 > v21)
        {
          v24 = *((_QWORD *)buffer + 17);
          if (v24)
          {
            v11 = *(_WORD *)(v24 + 2 * (*((_QWORD *)buffer + 19) + v21));
          }
          else
          {
            v25 = *((_QWORD *)buffer + 18);
            if (v25)
            {
              v11 = *(char *)(v25 + *((_QWORD *)buffer + 19) + v21);
            }
            else
            {
              if (*((_QWORD *)buffer + 22) <= v21 || (v26 = *((_QWORD *)buffer + 21), v26 > v21))
              {
                if (v21 >= 4)
                  v27 = v21 - 4;
                else
                  v27 = 0;
                if (v27 + 64 < v23)
                  v23 = v27 + 64;
                *((_QWORD *)buffer + 21) = v27;
                *((_QWORD *)buffer + 22) = v23;
                v35.location = *((_QWORD *)buffer + 19) + v27;
                v35.length = v23 - v27;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v35, buffer);
                v26 = *((_QWORD *)buffer + 21);
              }
              v11 = buffer[v22 - v26];
            }
          }
          v15 = v19 + 1;
          if (v11 < 0x80u)
            continue;
        }
      }
      LODWORD(v19) = v19 + 1;
      break;
    }
    Typed[v19] = 0;
    v28 = strtod_l(Typed, &v31, 0);
    if (v16)
      CFAllocatorDeallocate(v16, Typed);
    a4 = v30;
  }
  if (Typed == v31)
    return 0;
  *a3 += (_DWORD)v31 - (_DWORD)Typed;
  if (a4)
    *a4 = v28;
  return 1;
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  CFIndex Length;
  const __CFArray *Results;
  const __CFArray *v8;
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex v11;
  CFIndex i;
  _QWORD *ValueAtIndex;
  CFStringRef v14;
  CFStringRef v15;
  const void *v17[2];
  CFRange v18;
  CFRange v19;
  CFRange v20;

  v17[1] = *(const void **)MEMORY[0x1E0C80C00];
  v17[0] = theString;
  Length = CFStringGetLength(theString);
  v20.location = 0;
  v20.length = Length;
  Results = CFStringCreateArrayWithFindResults(alloc, theString, separatorString, v20, 0);
  if (!Results)
    return CFArrayCreate(alloc, v17, 1, &kCFTypeArrayCallBacks);
  v8 = Results;
  Count = CFArrayGetCount(Results);
  Mutable = CFArrayCreateMutable(alloc, Count + 2, &kCFTypeArrayCallBacks);
  if (Count < 1)
  {
    v11 = 0;
  }
  else
  {
    v11 = 0;
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v8, i);
      v18.length = *ValueAtIndex - v11;
      v18.location = v11;
      v14 = CFStringCreateWithSubstring(alloc, theString, v18);
      CFArrayAppendValue(Mutable, v14);
      CFRelease(v14);
      v11 = ValueAtIndex[1] + *ValueAtIndex;
    }
  }
  v19.length = Length - v11;
  v19.location = v11;
  v15 = CFStringCreateWithSubstring(alloc, theString, v19);
  CFArrayAppendValue(Mutable, v15);
  CFRelease(v15);
  CFRelease(v8);
  return Mutable;
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  if (callBacks != &kCFTypeArrayCallBacks
    || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
    && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    return (CFArrayRef)__CFArrayCreate0((__objc2_class **)allocator, (uint64_t *)values, numValues, callBacks);
  }
  if (__FoundationPresent_static_init != -1)
    dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
  if (__FoundationPresent_present)
    return (CFArrayRef)-[NSArray initWithObjects:count:]([NSArray alloc], "initWithObjects:count:", values, numValues);
  else
    return (CFArrayRef)__CFArrayCreate0((__objc2_class **)allocator, (uint64_t *)values, numValues, callBacks);
}

CFArrayRef CFStringCreateArrayWithFindResults(CFAllocatorRef alloc, CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  uint64_t length;
  CFIndex location;
  uint64_t v9;
  __objc2_class **v10;
  uint64_t v11;
  __CFData *Mutable;
  uint64_t v13;
  uint64_t v14;
  CFRange *v15;
  uint64_t v16;
  UInt8 *MutableBytePtr;
  __CFArray *v18;
  const __CFAllocator *allocator;
  CFArrayCallBacks callBacks;
  CFRange result;
  uint64_t v24;
  CFRange v25;

  length = rangeToSearch.length;
  location = rangeToSearch.location;
  v24 = *MEMORY[0x1E0C80C00];
  allocator = alloc;
  if (!alloc)
  {
    v9 = _CFGetTSD(1u);
    v10 = &__kCFAllocatorSystemDefault;
    if (v9)
      v10 = (__objc2_class **)v9;
    allocator = (const __CFAllocator *)v10;
  }
  if (length < 1)
    return 0;
  v11 = 0;
  Mutable = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  result.location = 0;
  result.length = 0;
  v16 = (location + length);
  while (1)
  {
    v25.location = location;
    v25.length = length;
    if (!CFStringFindWithOptionsAndLocale(theString, stringToFind, v25, compareOptions, 0, &result))
      break;
    if ((compareOptions & 4) != 0)
    {
      length = result.location - location;
    }
    else
    {
      location = result.length + result.location;
      length = v16 - (result.length + result.location);
    }
    if (v14 >= v13)
    {
      if (!Mutable)
        Mutable = CFDataCreateMutable(allocator, 0);
      v13 = 2 * v13 + 8;
      CFDataSetLength(Mutable, 24 * v13);
      v15 = (CFRange *)&CFDataGetMutableBytePtr(Mutable)[v11];
    }
    *v15 = result;
    v15[1].location = (CFIndex)Mutable;
    v15 = (CFRange *)((char *)v15 + 24);
    ++v14;
    v11 += 24;
    if (length <= 0)
      goto LABEL_18;
  }
  if (!v14)
    return 0;
LABEL_18:
  *(_OWORD *)&callBacks.version = xmmword_1E12E6DC8;
  *(_OWORD *)&callBacks.release = *(_OWORD *)off_1E12E6DD8;
  callBacks.equal = (CFArrayEqualCallBack)__rangeEqual;
  CFDataSetLength(Mutable, 24 * v14);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  v18 = CFArrayCreateMutable(allocator, 8 * v14, &callBacks);
  do
  {
    CFArrayAppendValue(v18, MutableBytePtr);
    MutableBytePtr += 24;
    --v14;
  }
  while (v14);
  CFRelease(Mutable);
  return v18;
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
  uint64_t v4;
  unint64_t *v5;
  char v6;
  char v7;
  char v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  char v12;
  unint64_t v13;

  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    -[__CFData setLength:](theData, "setLength:", length);
    return;
  }
  v4 = *((_QWORD *)theData + 2);
  v5 = (unint64_t *)((char *)theData + 8);
  v6 = atomic_load((unint64_t *)theData + 1);
  v7 = atomic_load((unint64_t *)theData + 1);
  if ((v7 & 1) != 0)
  {
    if (length < 0)
    {
      if ((v6 & 2) != 0)
        __CFDataHandleOutOfMemory(length);
      __break(1u);
      goto LABEL_26;
    }
    if (*((_QWORD *)theData + 3) < length)
    {
      if ((v6 & 2) != 0)
      {
        __CFDataGrow((unint64_t *)theData, length - v4, 1);
        goto LABEL_23;
      }
LABEL_26:
      CFDataSetLength_cold_1();
    }
    if (length > v4)
    {
      v8 = atomic_load(v5);
      if ((v8 & 0x40) != 0)
      {
        v12 = atomic_load(v5);
        if ((v12 & 4) != 0)
          v13 = ((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0;
        else
          v13 = *((_QWORD *)theData + 5);
        bzero((void *)(v13 + v4), length - v4);
        goto LABEL_23;
      }
    }
    if (length < v4)
    {
      v9 = atomic_load(v5);
      while (1)
      {
        v10 = __ldaxr(v5);
        if (v10 != v9)
          break;
        if (__stlxr(v9 | 0x40, v5))
          goto LABEL_16;
        v11 = 1;
LABEL_17:
        v9 = v10;
        if (v11)
          goto LABEL_23;
      }
      __clrex();
LABEL_16:
      v11 = 0;
      goto LABEL_17;
    }
  }
LABEL_23:
  *((_QWORD *)theData + 2) = length;
}

uint64_t __CFArrayCreateInit(__objc2_class **a1, char a2, int a3, const CFArrayCallBacks *a4)
{
  int v5;
  unsigned int v6;
  CFTypeRef (*retain)(int, CFTypeRef);
  int v8;
  int v9;
  int v10;
  uint64_t Instance;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  CFArrayCallBacks *v19;
  __int128 v20;
  __int128 v21;

  v5 = a2 & 3;
  v6 = v5;
  if (a4)
  {
    retain = (CFTypeRef (*)(int, CFTypeRef))a4->retain;
    if (retain || a4->release || a4->copyDescription || (v6 = a2 & 3, a4->equal))
    {
      if (a4 == &kCFTypeArrayCallBacks
        || retain == __CFTypeCollectionRetain
        && (void (*)(int, CFTypeRef))a4->release == __CFTypeCollectionRelease
        && a4->copyDescription == CFCopyDescription
        && a4->equal == CFEqual)
      {
        v6 = v5 | 4;
      }
      else
      {
        v6 = v5 | 0xC;
      }
    }
  }
  v8 = v6 & 0xC;
  v9 = 8 * a3;
  if ((a2 & 3) != 0)
    v9 = 0;
  if (v8 == 12)
    v10 = 72;
  else
    v10 = 32;
  Instance = _CFRuntimeCreateInstance(a1, 0x13uLL, (v10 + v9), 0);
  v12 = Instance;
  if (Instance)
  {
    v13 = (unint64_t *)(Instance + 8);
    v14 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      v15 = __ldaxr(v13);
      if (v15 != v14)
        break;
      if (__stlxr(v14 & 0xFFFFFFFFFFFFFF80 | v6, v13))
        goto LABEL_24;
      v16 = 1;
LABEL_25:
      v14 = v15;
      if (v16)
      {
        *(_QWORD *)(Instance + 16) = 0;
        if (v5 == 2)
        {
          if (__CFOASafe)
            __CFSetLastAllocationEventName();
          *(_QWORD *)(v12 + 24) = 1;
          *(_DWORD *)(v12 + 32) = 0;
          *(_QWORD *)(v12 + 40) = 0;
        }
        else if (!v5 && __CFOASafe)
        {
          __CFSetLastAllocationEventName();
        }
        if (v8 == 12)
        {
          v17 = atomic_load(v13);
          v18 = (v17 >> 2) & 3;
          if (v18)
          {
            if (v18 == 1)
            {
              v19 = (CFArrayCallBacks *)&kCFTypeArrayCallBacks;
            }
            else
            {
              atomic_load((unint64_t *)(v12 + 8));
              v19 = (CFArrayCallBacks *)(v12 + 48);
            }
          }
          else
          {
            v19 = (CFArrayCallBacks *)&__kCFNullArrayCallBacks;
          }
          v20 = *(_OWORD *)&a4->version;
          v21 = *(_OWORD *)&a4->release;
          v19->equal = a4->equal;
          *(_OWORD *)&v19->version = v20;
          *(_OWORD *)&v19->release = v21;
        }
        return v12;
      }
    }
    __clrex();
LABEL_24:
    v16 = 0;
    goto LABEL_25;
  }
  return v12;
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  char v3;

  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
    return (UInt8 *)-[__CFData mutableBytes](theData, "mutableBytes");
  v3 = atomic_load((unint64_t *)theData + 1);
  if ((v3 & 4) != 0)
    return (UInt8 *)(((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0);
  else
    return (UInt8 *)*((_QWORD *)theData + 5);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  char v3;

  if (capacity)
    v3 = 1;
  else
    v3 = 3;
  return (CFMutableDataRef)__CFDataInit((__objc2_class **)allocator, v3, capacity, 0, 0, 0);
}

void ___copyIngestedCacheResult_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 40), a2);
}

uint64_t _runLoopObserverWithBlockContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t parseDateTag(uint64_t a1, CFDateRef *a2)
{
  _BYTE *v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  char *v9;
  _BYTE *v10;
  int v11;
  int v12;
  char *v13;
  _BYTE *v14;
  int v15;
  int v16;
  char *v17;
  _BYTE *v18;
  int v19;
  int v20;
  char *v21;
  _BYTE *v22;
  int v23;
  int v24;
  char *v25;
  _BYTE *v26;
  int v27;
  int v28;
  uint64_t v29;
  double AbsoluteTime;
  CFDateRef v31;
  uint64_t result;
  uint64_t v33;
  CFErrorRef Error;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  unsigned int v42;
  int v43;
  CFGregorianDate v44;

  v3 = *(_BYTE **)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v3 < v4 && *v3 == 45)
  {
    v5 = 0;
    *(_QWORD *)(a1 + 8) = ++v3;
  }
  else
  {
    v5 = 1;
  }
  if ((unint64_t)v3 >= v4)
    goto LABEL_38;
  v6 = 0;
  v7 = 0;
  while (1)
  {
    v8 = (char)v3[v6];
    if ((v8 - 48) > 9)
      break;
    v7 = v8 + 10 * v7 - 48;
    *(_QWORD *)(a1 + 8) = &v3[++v6];
    if (v4 - (_QWORD)v3 == v6)
      goto LABEL_38;
  }
  if (v8 != 45)
    goto LABEL_38;
  v9 = &v3[v6 + 1];
  *(_QWORD *)(a1 + 8) = v9;
  v10 = &v3[v6 + 3];
  if ((unint64_t)v10 >= v4)
    goto LABEL_38;
  v11 = *v9;
  v12 = (char)v3[v6 + 2];
  *(_QWORD *)(a1 + 8) = v10;
  if ((v11 - 48) > 9)
    goto LABEL_38;
  if ((v12 - 48) > 9)
    goto LABEL_38;
  if (*v10 != 45)
    goto LABEL_38;
  v13 = &v3[v6 + 4];
  *(_QWORD *)(a1 + 8) = v13;
  v14 = &v3[v6 + 6];
  if ((unint64_t)v14 >= v4)
    goto LABEL_38;
  v15 = *v13;
  v16 = (char)v3[v6 + 5];
  *(_QWORD *)(a1 + 8) = v14;
  if ((v15 - 48) > 9)
    goto LABEL_38;
  if ((v16 - 48) > 9)
    goto LABEL_38;
  if (*v14 != 84)
    goto LABEL_38;
  v17 = &v3[v6 + 7];
  *(_QWORD *)(a1 + 8) = v17;
  v18 = &v3[v6 + 9];
  if ((unint64_t)v18 >= v4)
    goto LABEL_38;
  v19 = *v17;
  v20 = (char)v3[v6 + 8];
  *(_QWORD *)(a1 + 8) = v18;
  if ((v19 - 48) > 9)
    goto LABEL_38;
  if ((v20 - 48) > 9)
    goto LABEL_38;
  if (*v18 != 58)
    goto LABEL_38;
  v21 = &v3[v6 + 10];
  *(_QWORD *)(a1 + 8) = v21;
  v22 = &v3[v6 + 12];
  if ((unint64_t)v22 >= v4)
    goto LABEL_38;
  v23 = *v21;
  v24 = (char)v3[v6 + 11];
  *(_QWORD *)(a1 + 8) = v22;
  if ((v23 - 48) > 9)
    goto LABEL_38;
  if ((v24 - 48) > 9)
    goto LABEL_38;
  if (*v22 != 58)
    goto LABEL_38;
  v25 = &v3[v6 + 13];
  *(_QWORD *)(a1 + 8) = v25;
  v26 = &v3[v6 + 15];
  if ((unint64_t)v26 >= v4)
    goto LABEL_38;
  v27 = *v25;
  v28 = (char)v3[v6 + 14];
  *(_QWORD *)(a1 + 8) = v26;
  if ((v27 - 48) > 9)
    goto LABEL_38;
  if ((v28 - 48) > 9)
    goto LABEL_38;
  if (*v26 != 90)
    goto LABEL_38;
  *(_QWORD *)(a1 + 8) = &v3[v6 + 16];
  v42 = v7;
  v43 = v5;
  v37 = v15;
  v38 = v11;
  v40 = v16;
  v41 = v12;
  v36 = v19;
  v39 = v20;
  if (checkForCloseTag((unint64_t *)a1, (const UInt8 *)"date", 4uLL))
  {
    if (v43)
      v29 = v42;
    else
      v29 = -v42;
    *(_QWORD *)&v44.year = v29 | ((unint64_t)(v41 + 10 * v38 - 528) << 32) | ((unint64_t)(v40 + 10 * v37 - 528) << 40) | ((unint64_t)(v39 + 10 * v36 - 528) << 48) | ((unint64_t)(v24 + 10 * v23 - 528) << 56);
    v44.second = (double)(v28 + 10 * v27 - 528);
    AbsoluteTime = CFGregorianDateGetAbsoluteTime(v44, 0);
    v31 = 0;
    if (!*(_BYTE *)(a1 + 80))
      v31 = CFDateCreate(*(CFAllocatorRef *)(a1 + 32), AbsoluteTime);
    *a2 = v31;
    return 1;
  }
  else
  {
LABEL_38:
    v33 = lineNumber((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840, CFSTR("Could not interpret <date> at line %u"), v33);
    result = 0;
    *(_QWORD *)(a1 + 24) = Error;
  }
  return result;
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)-[NSDate initWithTimeIntervalSinceReferenceDate:]([NSDate alloc], "initWithTimeIntervalSinceReferenceDate:", at);
}

CFAbsoluteTime CFGregorianDateGetAbsoluteTime(CFGregorianDate gdate, CFTimeZoneRef tz)
{
  unint64_t v3;
  double second;
  double v5;
  double v6;
  double v7;
  CFTimeInterval SecondsFromGMT;

  v3 = *(_QWORD *)&gdate.year;
  second = gdate.second;
  v5 = __CFAbsoluteFromYMD(gdate.year - 2001, (int)(v3 >> 8) >> 24, (int)(v3 >> 16) >> 24) * 86400.0;
  v6 = (double)((uint64_t)v3 >> 56) * 60.0 + (double)((int)(v3 >> 24) >> 24) * 3600.0 + second;
  v7 = v6 + v5;
  if (tz)
  {
    SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, v6 + v5);
    return v7 - CFTimeZoneGetSecondsFromGMT(tz, v7 - SecondsFromGMT);
  }
  return v7;
}

double __CFAbsoluteFromYMD(uint64_t a1, unsigned int a2, int a3)
{
  double v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  double v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  __int16 v15;
  unsigned int v16;

  v3 = (double)(a1 / 400) * 146097.0 + 0.0;
  v4 = a1 % 400;
  if (a1 % 400 < 0)
  {
    v9 = ~a1 + 400 * (a1 / 400);
    v10 = a1 % 400;
    do
    {
      v11 = v9 % 0x190;
      if (((v9 % 0x190) & 3) != 0 || v11 == 100 || v11 == 300 || (v12 = 366.0, v11 == 200))
        v12 = 365.0;
      v3 = v3 - v12;
      --v9;
      ++v10;
    }
    while (v10);
  }
  else if (v4)
  {
    v5 = 1;
    v6 = a1 % 400;
    do
    {
      v7 = v5 % 0x190;
      if (((v5 % 0x190) & 3) != 0 || v7 == 100 || v7 == 300 || (v8 = 366.0, v7 == 200))
        v8 = 365.0;
      v3 = v3 + v8;
      ++v5;
      --v6;
    }
    while (v6);
  }
  v13 = (v4 + 1) % 400;
  if (v13 >= 0)
    v14 = v13;
  else
    v14 = -v13;
  if ((v14 & 3) != 0)
  {
    v15 = 0;
  }
  else
  {
    v15 = 0;
    if (v14 != 100 && v14 != 200)
      v15 = v14 != 300;
  }
  if (a2 <= 0xF)
  {
    if (a2 <= 2)
      v15 = 0;
    v16 = (unsigned __int16)(daysBeforeMonth[a2] + v15);
    if (v16 != 0xFFFF)
      v3 = v3 + (double)v16;
  }
  return v3 + (double)(a3 - 1);
}

void ___parseBundleStrings_block_invoke(uint64_t a1, const void *a2, __CFString *cf)
{
  CFTypeID v6;
  _QWORD *v7;
  __CFBundle *v8;
  const void *v9;
  __CFDictionary *v10;
  NSObject *v11;

  v6 = CFGetTypeID(cf);
  if (v6 == CFStringGetTypeID())
  {
    v8 = *(__CFBundle **)(a1 + 32);
    v7 = (_QWORD *)(a1 + 32);
    v9 = (const void *)_CFStringCreateByParsingMarkdownAndInflectingIfNeeded(cf, v8, 0);
    v10 = (__CFDictionary *)v7[1];
    if (v9)
    {
      CFDictionaryAddValue(v10, a2, v9);
      CFRelease(v9);
    }
    else
    {
      CFDictionaryAddValue(v10, a2, cf);
      v11 = _CFBundleResourceLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        ___parseBundleStrings_block_invoke_cold_1((uint64_t)a2, v7, v11);
    }
  }
  else
  {
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 40), a2, cf);
  }
}

UText *CFStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 0, a2);
}

uint64_t __CFSetLastAllocationEventName()
{
  BOOL v0;
  uint64_t result;

  if (__CFOASafe)
    v0 = __CFObjectAllocSetLastAllocEventNameFunction == 0;
  else
    v0 = 1;
  if (!v0)
    return __CFObjectAllocSetLastAllocEventNameFunction();
  return result;
}

id _CFURLComponentsCopyURL(void *a1)
{
  return (id)objc_msgSend(a1, "URL");
}

uint64_t __CFBinaryPlistGetOffsetForValueFromArray2(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  char v10;
  unsigned __int8 *v11;
  unint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  unsigned int v19;
  unint64_t v20;
  unsigned int *v21;
  uint64_t v22;
  unint64_t v23;
  unsigned int v24;
  unint64_t v25;
  unsigned int *v26;
  uint64_t v28;
  unsigned int v29;

  v6 = 0;
  if (a3 < 8)
    return v6;
  v7 = *(_QWORD *)(a4 + 24);
  v8 = v7 - 1;
  if (v7 - 1 < a3)
    return v6;
  v6 = 0;
  v9 = (_BYTE *)(a1 + a3);
  if (a1 + a3 == -1)
    return v6;
  v10 = *v9;
  if ((*v9 & 0xF0) != 0xA0)
    return v6;
  v11 = v9 + 1;
  v12 = v10 & 0xF;
  if ((v10 & 0xF) == 0xF)
  {
    if (a1 + v8 < (unint64_t)v11)
      return 0;
    v13 = v9 + 2;
    v14 = *v11;
    if ((*v11 & 0xF0) != 0x10)
      return 0;
    v6 = 0;
    v15 = v14 & 0xF;
    v16 = 1 << (v14 & 0xF);
    if (__CFADD__(v16, v13) || (unint64_t)&v11[v16] > a1 + v8)
      return v6;
    switch((char)v16)
    {
      case 1:
        v12 = *v13;
        goto LABEL_23;
      case 2:
        v12 = __rev16(*(unsigned __int16 *)(v11 + 1));
        goto LABEL_23;
      case 4:
        v12 = bswap32(*(_DWORD *)(v11 + 1));
        goto LABEL_23;
      case 8:
        v12 = bswap64(*(_QWORD *)(v11 + 1));
        goto LABEL_22;
      default:
        if (v15 > 7)
          return 0;
        v12 = 0;
        if ((v16 & 0xFE) != 0)
          v17 = v16;
        else
          v17 = 1;
        v18 = v11 + 1;
        do
        {
          v19 = *v18++;
          v12 = v19 | (v12 << 8);
          --v17;
        }
        while (v17);
LABEL_22:
        if ((v12 & 0x8000000000000000) != 0)
          return 0;
LABEL_23:
        v11 = &v13[v16];
        break;
    }
  }
  if (v12 <= a5)
    return 0;
  v20 = *(unsigned __int8 *)(a4 + 7);
  if (!is_mul_ok(v12, v20))
    return 0;
  v6 = 0;
  if (__CFADD__(v12 * v20, v11) || a1 + v8 < (unint64_t)&v11[v12 * v20 - 1])
    return v6;
  v21 = (unsigned int *)&v11[v20 * a5];
  if (a1 + 8 > (unint64_t)v21)
    return 0;
  v22 = a1 + v7;
  if (a1 + v7 - v20 < (unint64_t)v21)
    return 0;
  v23 = *(unsigned __int8 *)(a4 + 7);
  switch(*(_BYTE *)(a4 + 7))
  {
    case 0:
      break;
    case 1:
      v23 = *(unsigned __int8 *)v21;
      break;
    case 2:
      v23 = __rev16(*(unsigned __int16 *)v21);
      break;
    case 4:
      v23 = bswap32(*v21);
      break;
    case 8:
      v23 = bswap64(*(_QWORD *)v21);
      break;
    default:
      v23 = 0;
      do
      {
        v24 = *(unsigned __int8 *)v21;
        v21 = (unsigned int *)((char *)v21 + 1);
        v23 = v24 | (v23 << 8);
        --v20;
      }
      while (v20);
      break;
  }
  if (*(_QWORD *)(a4 + 8) <= v23)
    return 0;
  if (a6)
  {
    v25 = *(unsigned __int8 *)(a4 + 6);
    v26 = (unsigned int *)(v22 + v23 * v25);
    switch(*(_BYTE *)(a4 + 6))
    {
      case 0:
        break;
      case 1:
        v25 = *(unsigned __int8 *)v26;
        break;
      case 2:
        v25 = __rev16(*(unsigned __int16 *)v26);
        break;
      case 4:
        v25 = bswap32(*v26);
        break;
      case 8:
        v25 = bswap64(*(_QWORD *)v26);
        break;
      default:
        v28 = *(unsigned __int8 *)(a4 + 6);
        v25 = 0;
        do
        {
          v29 = *(unsigned __int8 *)v26;
          v26 = (unsigned int *)((char *)v26 + 1);
          v25 = v29 | (v25 << 8);
          --v28;
        }
        while (v28);
        break;
    }
    *a6 = v25;
  }
  return 1;
}

uint64_t _CFKeyedArchiverUIDCreate(__objc2_class **a1, int a2)
{
  uint64_t result;

  result = _CFRuntimeCreateInstance(a1, 0x29uLL, 8, 0);
  if (result)
    *(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t _CompareTestEntryPrefixToTableEntryKey(_QWORD *a1, _BYTE **a2)
{
  int v2;
  int v3;
  _BOOL4 v4;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  unsigned int v11;

  v2 = *(unsigned __int8 *)*a1;
  v3 = **a2;
  v4 = **a2 == 0;
  if (v2 == v3 && v3 != 0)
  {
    v6 = *a2 + 1;
    v7 = (unsigned __int8 *)(*a1 + 1);
    do
    {
      v8 = *v7++;
      v2 = v8;
      v9 = *v6++;
      v3 = v9;
      v4 = v9 == 0;
    }
    while (v2 == v9 && v3 != 0);
  }
  if ((char)v2 < (char)v3)
    v11 = -1;
  else
    v11 = 1;
  if (v4)
    return 0;
  else
    return v11;
}

uint64_t parseDictTag(uint64_t a1, _QWORD *a2, unint64_t a3)
{
  const __CFSet *v6;
  const __CFDictionary *v7;
  CFTypeRef v8;
  CFTypeRef v9;
  int ContentObject;
  CFTypeRef v11;
  CFTypeRef v12;
  const __CFNumber *Value;
  const __CFNumber *v14;
  uint64_t v15;
  uint64_t result;
  CFErrorRef Error;
  CFErrorRef v18;
  uint64_t v19;
  CFTypeRef v20;
  uint64_t v21;
  int v22;
  CFDictionaryRef Copy;
  const __CFAllocator *v24;
  CFMutableDictionaryRef Mutable;
  uint64_t v26;
  uint64_t v27;
  int valuePtr;
  CFTypeRef v29;
  CFTypeRef v30;
  CFTypeRef v31;
  CFTypeRef cf;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v33 = 0;
  v31 = 0;
  cf = 0;
  if (*(_BYTE *)(a1 + 80))
  {
    while (getContentObject((unint64_t *)a1, &v33, (uint64_t)&cf, a3))
    {
      if (!v33)
      {
        if (*(_QWORD *)(a1 + 24))
          return 0;
        v26 = lineNumber((unint64_t *)a1);
        Error = __CFPropertyListCreateError(3840, CFSTR("Found non-key inside <dict> at line %u"), v26);
LABEL_49:
        v18 = Error;
        result = 0;
        *(_QWORD *)(a1 + 24) = v18;
        return result;
      }
      if (!getContentObject((unint64_t *)a1, 0, (uint64_t)&v31, a3))
      {
        if (*(_QWORD *)(a1 + 24))
          return 0;
        v27 = lineNumber((unint64_t *)a1);
        Error = __CFPropertyListCreateError(3840, CFSTR("Value missing for key inside <dict> at line %u"), v27);
        goto LABEL_49;
      }
      if (cf)
        CFRelease(cf);
      cf = 0;
      if (v31)
        CFRelease(v31);
      v31 = 0;
    }
    result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"dict", 4uLL);
    if (!(_DWORD)result)
      return result;
    *a2 = 0;
    return 1;
  }
  v6 = *(const __CFSet **)(a1 + 72);
  v29 = 0;
  v30 = 0;
  __CFPropertyListCreateSplitKeypaths(*(const __CFAllocator **)(a1 + 32), v6, (__CFSet **)&v29, (__CFSet **)&v30);
  v7 = 0;
  if (!getContentObject((unint64_t *)a1, &v33, (uint64_t)&cf, a3) || (v8 = cf) == 0)
  {
LABEL_31:
    if (v30)
      CFRelease(v30);
    if (v29)
      CFRelease(v29);
    if (*(_QWORD *)(a1 + 24) || !checkForCloseTag((unint64_t *)a1, (const UInt8 *)"dict", 4uLL))
      goto LABEL_66;
    if (v7)
    {
      if (CFDictionaryGetCount(v7) == 1)
      {
        Value = (const __CFNumber *)CFDictionaryGetValue(v7, CFSTR("CF$UID"));
        if (Value)
        {
          v14 = Value;
          if (CFGetTypeID(Value) == 22)
          {
            valuePtr = 0;
            CFNumberGetValue(v14, kCFNumberSInt32Type, &valuePtr);
            v15 = _CFKeyedArchiverUIDCreate(*(__objc2_class ***)(a1 + 32), valuePtr);
            CFRelease(v7);
            *a2 = v15;
            return 1;
          }
        }
      }
      v22 = allowImmutableCollections;
      if (allowImmutableCollections == -1)
      {
        v22 = getenv("CFPropertyListAllowImmutableCollections") != 0;
        allowImmutableCollections = v22;
      }
      if (v22 == 1 && !*(_DWORD *)(a1 + 40))
      {
        Copy = CFDictionaryCreateCopy(*(CFAllocatorRef *)(a1 + 32), v7);
        CFRelease(v7);
        v7 = Copy;
      }
    }
    else
    {
      v24 = *(const __CFAllocator **)(a1 + 32);
      if (*(_DWORD *)(a1 + 40))
        Mutable = CFDictionaryCreateMutable(v24, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      else
        Mutable = CFDictionaryCreate(v24, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v7 = Mutable;
    }
    *a2 = v7;
    return 1;
  }
  v7 = 0;
  while (1)
  {
    if (!v33)
    {
      if (*(_QWORD *)(a1 + 24)
        || (v19 = lineNumber((unint64_t *)a1),
            *(_QWORD *)(a1 + 24) = __CFPropertyListCreateError(3840, CFSTR("Found non-key inside <dict> at line %u"), v19), (v8 = cf) != 0))
      {
        CFRelease(v8);
      }
      if (v30)
        CFRelease(v30);
      v20 = v29;
      if (v29)
        goto LABEL_65;
      goto LABEL_66;
    }
    v9 = v29;
    if (v29)
      break;
    if (!getContentObject((unint64_t *)a1, 0, (uint64_t)&v31, a3))
      goto LABEL_57;
LABEL_20:
    v11 = cf;
    if (cf)
    {
      v12 = v31;
      if (v31)
      {
        if (!v7)
        {
          v7 = CFDictionaryCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          _CFDictionarySetCapacity((__objc2_class **)v7, 10);
          v12 = v31;
          v11 = cf;
        }
        CFDictionarySetValue(v7, v11, v12);
        v11 = cf;
      }
    }
    if (v11)
      CFRelease(v11);
    cf = 0;
    if (v31)
      CFRelease(v31);
    v31 = 0;
    if (getContentObject((unint64_t *)a1, &v33, (uint64_t)&cf, a3))
    {
      v8 = cf;
      if (cf)
        continue;
    }
    goto LABEL_31;
  }
  if (!__CFPropertyListKeyPassesFilterSet((uint64_t)v8, (void *)v29))
    *(_BYTE *)(a1 + 80) = 1;
  *(_QWORD *)(a1 + 72) = v30;
  ContentObject = getContentObject((unint64_t *)a1, 0, (uint64_t)&v31, a3);
  *(_QWORD *)(a1 + 72) = v6;
  *(_BYTE *)(a1 + 80) = 0;
  if (ContentObject)
    goto LABEL_20;
LABEL_57:
  if (!*(_QWORD *)(a1 + 24))
  {
    v21 = lineNumber((unint64_t *)a1);
    *(_QWORD *)(a1 + 24) = __CFPropertyListCreateError(3840, CFSTR("Value missing for key inside <dict> at line %u"), v21);
  }
  if (cf)
    CFRelease(cf);
  if (v30)
    CFRelease(v30);
  if (v9)
  {
    v20 = v9;
LABEL_65:
    CFRelease(v20);
  }
LABEL_66:
  if (v7)
    CFRelease(v7);
  return 0;
}

uint64_t __CFBinaryPlistCreateObject(const void *a1, int a2, unint64_t a3, uint64_t a4, __objc2_class **a5, uint64_t a6, const __CFDictionary *a7, CFTypeRef *a8)
{
  return __CFBinaryPlistCreateObjectFiltered(a1, a2, a3, a4, a5, a6, 0, a7, 0, 0, 0, a8, 0);
}

uint64_t __CFBinaryPlistCreateObjectFiltered(const void *Value, int a2, unint64_t a3, uint64_t a4, __objc2_class **a5, uint64_t a6, uint64_t a7, const __CFDictionary *a8, CFSetRef theSet, uint64_t a10, CFIndex a11, CFTypeRef *a12, CFTypeID *a13)
{
  NSObject *v13;
  uint64_t v20;
  uint64_t Typed;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  unsigned __int8 *v26;
  unint64_t v27;
  unint64_t v28;
  unsigned __int8 *v29;
  unsigned __int8 v30;
  unsigned int v31;
  uint64_t v32;
  const __CFArray *v33;
  unint64_t v34;
  unsigned __int8 *v35;
  char v36;
  unsigned int v37;
  uint64_t v38;
  const UInt8 *v39;
  CFIndex v40;
  unsigned __int8 *v41;
  UInt8 v42;
  unsigned int v43;
  uint64_t v44;
  unint64_t v46;
  CFDateRef v47;
  CFNumberRef v48;
  uint64_t *v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  unsigned int *v53;
  unint64_t v54;
  _BOOL4 v55;
  unsigned int *v56;
  uint64_t v57;
  unint64_t v59;
  _BOOL4 v60;
  CFTypeID *v61;
  unsigned int v62;
  uint64_t Instance;
  CFTypeID *v64;
  CFNumberRef v65;
  uint64_t v66;
  unsigned int v67;
  unint64_t v68;
  uint64_t v69;
  unsigned __int8 *v70;
  unsigned int v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  size_t v76;
  const __CFSet *v77;
  CFIndex v78;
  BOOL v79;
  int v80;
  int v81;
  const __CFAllocator *v82;
  _BOOL4 v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t *v86;
  uint64_t v87;
  unsigned int *v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unsigned int *v92;
  unsigned int v93;
  uint64_t v94;
  unsigned int *v95;
  uint64_t v96;
  int v97;
  __CFSet *v98;
  CFMutableSetRef v99;
  const void **v100;
  const __CFArray *v101;
  uint64_t v102;
  CFTypeRef *v103;
  uint64_t *v104;
  int v105;
  CFIndex Count;
  CFIndex v107;
  const void **v108;
  const void **v109;
  CFStringRef *v110;
  const __CFString *v111;
  SInt32 IntValue;
  uint64_t v113;
  unsigned int v114;
  _QWORD *v115;
  _QWORD *v116;
  const void *v117;
  __CFArray *v118;
  CFTypeRef *v119;
  const __CFArray *Transfer;
  const __CFArray *v121;
  CFArrayRef Copy;
  unsigned __int8 *v123;
  const void *v124;
  uint64_t v125;
  unsigned __int8 *v126;
  unsigned int v127;
  unint64_t v128;
  unint64_t v129;
  unsigned __int8 *v130;
  char v131;
  unint64_t v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  __CFSet **v137;
  size_t v138;
  __objc2_class **v139;
  const __CFSet *v140;
  const __CFSet *v141;
  const __CFAllocator *v142;
  uint64_t v143;
  const __CFDictionary *FilteredDictionary;
  const __CFDictionary *v145;
  uint64_t v146;
  const __CFArray *v147;
  uint64_t v148;
  const __CFAllocator *v149;
  uint64_t v150;
  unsigned int *v151;
  uint64_t v152;
  uint64_t v153;
  unint64_t v154;
  unsigned int *v155;
  unsigned int v156;
  uint64_t v157;
  unsigned int *v158;
  uint64_t v159;
  int v160;
  __CFDictionary *v161;
  uint64_t v162;
  uint64_t v163;
  const void **v164;
  CFTypeRef *v165;
  CFDictionaryRef v166;
  __CFSet *v167;
  __CFSet **v168;
  __CFSet *v169;
  __CFSet **v170;
  __CFSet *v171;
  uint64_t v172;
  unsigned __int8 *v173;
  unsigned int v174;
  __CFData *Mutable;
  __CFSet *v176;
  CFDataRef v177;
  int v178;
  _BYTE v179[4];
  int v180;
  CFAllocatorRef v181;
  unsigned __int8 *v182;
  uint64_t v183;
  unint64_t v184;
  uint64_t v185;
  __CFSet **v186;
  const void **v187;
  unsigned __int8 *v188;
  __CFSet **v189;
  const __CFArray *v190;
  CFIndex v191;
  uint64_t v192;
  const __CFSet *v193;
  CFMutableDictionaryRef v194;
  CFMutableSetRef *v195;
  __objc2_class **v196;
  CFTypeID *v197;
  unint64_t v198;
  const void *v199;
  unint64_t v200;
  _QWORD v201[13];
  _QWORD v202[13];
  __CFSet *valuePtr[2];
  __CFSet *v204[3];
  CFRange v205;

  v204[1] = *(__CFSet **)MEMORY[0x1E0C80C00];
  if ((unint64_t)a10 >= 0x81)
  {
    v13 = _CFOSLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
      __CFBinaryPlistCreateObjectFiltered_cold_1(v13);
    return 0;
  }
  v20 = (uint64_t)Value;
  v196 = a5;
  v197 = a13;
  v198 = ~a3;
  if (a8)
  {
    if (a12)
    {
      Value = CFDictionaryGetValue(a8, (const void *)v198);
      *a12 = Value;
      if (Value)
      {
        CFRetain(Value);
        if (v197)
          *v197 = CFGetTypeID(*a12);
        return 1;
      }
    }
  }
  v195 = (CFMutableSetRef *)a12;
  if (theSet)
  {
    Value = (const void *)CFSetContainsValue(theSet, (const void *)v198);
    if ((_DWORD)Value)
      return 0;
  }
  v194 = a8;
  Typed = 0;
  if (a3 >= 8)
  {
    v193 = theSet;
    v23 = *(_QWORD *)(a4 + 24) - 1;
    if (v23 >= a3)
    {
      Typed = 0;
      v24 = v20 + a3;
      v25 = *(unsigned __int8 *)(v20 + a3);
      switch(v25 >> 4)
      {
        case 0u:
          if (v25 == 9)
          {
            if (v195)
              *v195 = (CFMutableSetRef)&__kCFBooleanTrue;
            if (v197)
              *v197 = 21;
            return 1;
          }
          if (v25 == 8)
          {
            v49 = (uint64_t *)v197;
            if (v195)
              *v195 = (CFMutableSetRef)&__kCFBooleanFalse;
            if (!v49)
              return 1;
            v50 = 21;
          }
          else
          {
            v49 = (uint64_t *)v197;
            if (*(_BYTE *)(v20 + a3))
              return 0;
            if (v195)
              *v195 = (CFMutableSetRef)&__kCFNull;
            if (!v49)
              return 1;
            v50 = 16;
          }
          *v49 = v50;
          return 1;
        case 1u:
          if (v24 == -1)
            return 0;
          v51 = v25 & 0xF;
          v52 = 1 << (v25 & 0xF);
          if (v24 >= ~v52)
            return 0;
          Typed = 0;
          if (v51 > 4)
            return Typed;
          v53 = (unsigned int *)(v24 + 1);
          if (v20 + v23 < v24 + v52)
            return Typed;
          switch((1 << (v25 & 0xF)))
          {
            case 1u:
              v54 = *(unsigned __int8 *)v53;
              goto LABEL_124;
            case 2u:
              v54 = __rev16(*(unsigned __int16 *)v53);
              goto LABEL_124;
            case 4u:
              v54 = bswap32(*v53);
              goto LABEL_124;
            case 8u:
              v54 = bswap64(*(_QWORD *)v53);
LABEL_124:
              v64 = v197;
              break;
            default:
              v54 = 0;
              if ((v52 & 0xFE) != 0)
                v66 = (1 << (v25 & 0xF));
              else
                v66 = 1;
              v64 = v197;
              do
              {
                v67 = *(unsigned __int8 *)v53;
                v53 = (unsigned int *)((char *)v53 + 1);
                v54 = v67 | (v54 << 8);
                --v66;
              }
              while (v66);
              break;
          }
          v204[0] = (__CFSet *)v54;
          if (v64)
            *v64 = 22;
          if (!v195)
            return 1;
          if (v51 < 4)
          {
            v65 = CFNumberCreate((CFAllocatorRef)v196, kCFNumberSInt64Type, v204);
          }
          else
          {
            valuePtr[0] = 0;
            valuePtr[1] = (__CFSet *)v54;
            v65 = CFNumberCreate((CFAllocatorRef)v196, kCFNumberMaxType|kCFNumberSInt8Type, valuePtr);
          }
          v48 = v65;
          Typed = v65 != 0;
          if (v194 && v65)
            goto LABEL_133;
          goto LABEL_134;
        case 2u:
          if ((v25 & 0xF) == 3)
          {
            if (v24 == -1)
              return 0;
            Typed = 0;
            if (v24 <= 0xFFFFFFFFFFFFFFF6 && v20 + v23 >= v24 + 8)
            {
              valuePtr[0] = (__CFSet *)bswap64(*(_QWORD *)(v24 + 1));
              if (v197)
                *v197 = 22;
              if (!v195)
                return 1;
              v48 = CFNumberCreate((CFAllocatorRef)v196, kCFNumberFloat64Type, valuePtr);
              Typed = v48 != 0;
              if (v48)
                v60 = v194 != 0;
              else
                v60 = 0;
              if (v60)
LABEL_133:
                CFDictionarySetValue(v194, (const void *)v198, v48);
LABEL_134:
              *v195 = v48;
              return Typed;
            }
          }
          else
          {
            if ((v25 & 0xF) != 2 || v24 == -1)
              return 0;
            Typed = 0;
            if (v24 <= 0xFFFFFFFFFFFFFFFALL && v20 + v23 >= v24 + 4)
            {
              LODWORD(valuePtr[0]) = bswap32(*(_DWORD *)(v24 + 1));
              if (v197)
                *v197 = 22;
              if (!v195)
                return 1;
              v48 = CFNumberCreate((CFAllocatorRef)v196, kCFNumberFloat32Type, valuePtr);
              Typed = v48 != 0;
              if (v48)
                v55 = v194 != 0;
              else
                v55 = 0;
              if (v55)
                goto LABEL_133;
              goto LABEL_134;
            }
          }
          return Typed;
        case 3u:
          Typed = 0;
          if (v24 == -1)
            return Typed;
          if (v25 != 51)
            return Typed;
          Typed = 0;
          if (v24 > 0xFFFFFFFFFFFFFFF6 || v20 + v23 < v24 + 8)
            return Typed;
          v46 = *(_QWORD *)(v24 + 1);
          if (v197)
            *v197 = 42;
          if (!v195)
            return 1;
          v47 = CFDateCreate((CFAllocatorRef)v196, COERCE_CFABSOLUTETIME(bswap64(v46)));
          v48 = v47;
          Typed = v47 != 0;
          if (v194 && v47)
LABEL_120:
            CFDictionarySetValue(v194, (const void *)v198, v48);
          goto LABEL_134;
        case 4u:
          if (v24 == -1)
            return 0;
          v39 = (const UInt8 *)(v24 + 1);
          v40 = v25 & 0xF;
          if ((v25 & 0xF) == 0xF)
          {
            if (v20 + v23 < (unint64_t)v39)
              return 0;
            v41 = (unsigned __int8 *)(v24 + 2);
            v42 = *v39;
            if ((*v39 & 0xF0) != 0x10)
              return 0;
            Typed = 0;
            v43 = v42 & 0xF;
            v44 = 1 << (v42 & 0xF);
            if (!__CFADD__(v44, v41) && (unint64_t)&v39[v44] <= v20 + v23)
            {
              switch((char)v44)
              {
                case 1:
                  v40 = *v41;
                  goto LABEL_408;
                case 2:
                  v40 = __rev16(*(unsigned __int16 *)(v24 + 2));
                  goto LABEL_408;
                case 4:
                  v40 = bswap32(*(_DWORD *)(v24 + 2));
                  goto LABEL_408;
                case 8:
                  v40 = bswap64(*(_QWORD *)(v24 + 2));
                  goto LABEL_407;
                default:
                  if (v43 <= 7)
                  {
                    v40 = 0;
                    if ((v44 & 0xFE) != 0)
                      v172 = v44;
                    else
                      v172 = 1;
                    v173 = (unsigned __int8 *)(v24 + 2);
                    do
                    {
                      v174 = *v173++;
                      v40 = v174 | (unint64_t)(v40 << 8);
                      --v172;
                    }
                    while (v172);
LABEL_407:
                    if (v40 < 0)
                      return 0;
                  }
                  else
                  {
                    v40 = 0;
                  }
LABEL_408:
                  v39 = &v41[v44];
                  goto LABEL_409;
              }
            }
          }
          else
          {
LABEL_409:
            Typed = 0;
            if (!__CFADD__(v40, v39) && v20 + v23 >= (unint64_t)&v39[v40 - 1])
            {
              if (v197)
                *v197 = 20;
              if (!v195)
                return 1;
              if (a6 == 2)
              {
                Mutable = CFDataCreateMutable((CFAllocatorRef)v196, 0);
                v176 = Mutable;
                if (Mutable)
                  CFDataAppendBytes(Mutable, v39, v40);
                Typed = v176 != 0;
              }
              else
              {
                v177 = CFDataCreate((CFAllocatorRef)v196, v39, v40);
                v176 = v177;
                Typed = v177 != 0;
                if (v194 && v177)
                {
                  CFDictionarySetValue(v194, (const void *)v198, v177);
                  Typed = 1;
                }
              }
              *v195 = v176;
            }
          }
          return Typed;
        case 5u:
          v202[0] = MEMORY[0x1E0C809B0];
          v202[1] = 3221225472;
          v202[2] = ____CFBinaryPlistCreateObjectFiltered_block_invoke;
          v202[3] = &__block_descriptor_104_e12_B24__0r_8q16l;
          v202[4] = v197;
          v202[5] = v195;
          v202[6] = a6;
          v202[7] = a6;
          v202[8] = v196;
          v202[9] = a7;
          v202[10] = a3;
          v202[11] = v194;
          v202[12] = v198;
          return __CFBinaryPlistParseASCIIString(v20, v23, (_BYTE *)v24, (uint64_t)v202);
        case 6u:
          v201[0] = MEMORY[0x1E0C809B0];
          v201[1] = 3221225472;
          v201[2] = ____CFBinaryPlistCreateObjectFiltered_block_invoke_2;
          v201[3] = &__block_descriptor_104_e13_B24__0r_S8q16l;
          v201[4] = v197;
          v201[5] = v195;
          v201[6] = a6;
          v201[7] = a6;
          v201[8] = v196;
          v201[9] = a7;
          v201[10] = a3;
          v201[11] = v194;
          v201[12] = v198;
          return __CFBinaryPlistParseUnicode16String(v20, v23, (_BYTE *)v24, (uint64_t)v201);
        case 8u:
          if (v24 != -1)
          {
            v56 = (unsigned int *)(v24 + 1);
            v57 = (v25 & 0xF) + 1;
            if (v24 < ~v57 && v20 + v23 >= v24 + v57)
            {
              switch(v25 & 0xF)
              {
                case 0u:
                  LODWORD(v59) = *(unsigned __int8 *)v56;
                  goto LABEL_110;
                case 1u:
                  LODWORD(v59) = __rev16(*(unsigned __int16 *)v56);
                  goto LABEL_110;
                case 3u:
                  LODWORD(v59) = bswap32(*v56);
LABEL_110:
                  v61 = v197;
                  goto LABEL_115;
                case 7u:
                  v59 = bswap64(*(_QWORD *)v56);
                  v61 = v197;
                  goto LABEL_114;
                default:
                  v59 = 0;
                  v61 = v197;
                  do
                  {
                    v62 = *(unsigned __int8 *)v56;
                    v56 = (unsigned int *)((char *)v56 + 1);
                    v59 = v62 | (v59 << 8);
                    --v57;
                  }
                  while (v57);
LABEL_114:
                  if (HIDWORD(v59))
                    return 0;
LABEL_115:
                  if (v61)
                    *v61 = 41;
                  if (!v195)
                    return 1;
                  Instance = _CFRuntimeCreateInstance(v196, 0x29uLL, 8, 0);
                  v48 = (CFNumberRef)Instance;
                  Typed = Instance != 0;
                  if (Instance)
                  {
                    *(_DWORD *)(Instance + 16) = v59;
                    if (v194)
                      goto LABEL_120;
                  }
                  goto LABEL_134;
              }
            }
          }
          return 0;
        case 0xAu:
        case 0xCu:
          v191 = a11;
          v192 = a6;
          if (v24 == -1)
            return 0;
          v26 = (unsigned __int8 *)(v24 + 1);
          v27 = v25 & 0xF;
          if ((v25 & 0xF) == 0xF)
          {
            v28 = v20 + v23;
            if (v20 + v23 >= (unint64_t)v26)
            {
              v29 = (unsigned __int8 *)(v24 + 2);
              v30 = *v26;
              if ((*v26 & 0xF0) == 0x10)
              {
                Typed = 0;
                v31 = v30 & 0xF;
                v32 = 1 << (v30 & 0xF);
                if (__CFADD__(v32, v29) || (unint64_t)&v26[v32] > v28)
                  return Typed;
                switch((char)v32)
                {
                  case 1:
                    v27 = *v29;
                    goto LABEL_164;
                  case 2:
                    v27 = __rev16(*(unsigned __int16 *)(v24 + 2));
                    goto LABEL_164;
                  case 4:
                    v27 = bswap32(*(_DWORD *)(v24 + 2));
                    goto LABEL_164;
                  case 8:
                    v68 = bswap64(*(_QWORD *)(v24 + 2));
                    goto LABEL_162;
                  default:
                    if (v31 > 7)
                    {
                      v187 = (const void **)&v29[v32];
                      if (v28 < (unint64_t)&v29[v32 - 1])
                        return 0;
                      v27 = 0;
                      v188 = 0;
                      v189 = (__CFSet **)(a4 + 7);
                      goto LABEL_175;
                    }
                    v68 = 0;
                    if ((v32 & 0xFE) != 0)
                      v69 = v32;
                    else
                      v69 = 1;
                    v70 = (unsigned __int8 *)(v24 + 2);
                    do
                    {
                      v71 = *v70++;
                      v68 = v71 | (v68 << 8);
                      --v69;
                    }
                    while (v69);
LABEL_162:
                    if ((v68 & 0x8000000000000000) == 0)
                    {
                      v27 = v68;
LABEL_164:
                      v26 = &v29[v32];
                      goto LABEL_165;
                    }
                    break;
                }
              }
            }
            return 0;
          }
LABEL_165:
          v72 = *(unsigned __int8 *)(a4 + 7);
          v189 = (__CFSet **)(a4 + 7);
          if (v27)
          {
            if (!is_mul_ok(v27, v72))
              return 0;
            v73 = v27 * v72;
          }
          else
          {
            v73 = 0;
          }
          Typed = 0;
          if (__CFADD__(v73, v26))
            return Typed;
          v187 = (const void **)v26;
          if (v20 + v23 < (unint64_t)&v26[v73 - 1])
            return Typed;
          if (v27)
          {
            if (v27 >> 61)
              return 0;
            v188 = (unsigned __int8 *)(8 * v27);
          }
          else
          {
            v188 = 0;
          }
LABEL_175:
          v186 = (__CFSet **)v179;
          v190 = (const __CFArray *)v27;
          MEMORY[0x1E0C80A78](Value, v23);
          Typed = (uint64_t)&v179[-v75];
          if (v74 >= 0x200)
            v76 = 512;
          else
            v76 = v74;
          bzero(&v179[-v75], v76);
          v182 = (unsigned __int8 *)Typed;
          if (v195)
          {
            if ((unint64_t)v190 >= 0x101)
            {
              Typed = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v188, 1181297625, 0);
              if (!Typed)
                return Typed;
            }
          }
          else
          {
            Typed = 0;
          }
          v188 = (unsigned __int8 *)Typed;
          v77 = 0;
          if (!v193 && a10 >= 16)
          {
            v77 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0);
            v193 = v77;
          }
          v183 = (uint64_t)v77;
          if (v193)
            CFSetAddValue(v193, (const void *)v198);
          valuePtr[0] = 0;
          v204[0] = 0;
          v181 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
          v78 = v191;
          __CFPropertyListCreateSplitKeypaths((const __CFAllocator *)&__kCFAllocatorSystemDefault, (CFSetRef)v191, valuePtr, v204);
          v180 = v25 & 0xF0;
          if (v78)
            v79 = (v25 & 0xF0) == 160;
          else
            v79 = 0;
          v80 = !v79;
          if (valuePtr[0])
          {
            v81 = CFSetContainsValue(valuePtr[0], CFSTR("*"));
            v82 = (const __CFAllocator *)v196;
            v83 = v81 != 0;
          }
          else
          {
            v83 = 0;
            v82 = (const __CFAllocator *)v196;
          }
          if ((v80 | v83) == 1)
          {
            v84 = (unint64_t)v187;
            if (v190)
            {
              v85 = 0;
              v191 = v20 + 8;
              v86 = &v200;
              if (!v195)
                v86 = 0;
              v184 = (unint64_t)v86;
              v185 = a10 + 1;
              v87 = -1;
              while (v191 <= v84)
              {
                v88 = (unsigned int *)v84;
                v89 = v20 + *(_QWORD *)(a4 + 24);
                v90 = *(unsigned __int8 *)(a4 + 7);
                if (v89 - v90 < v84)
                  break;
                v91 = *(unsigned __int8 *)(a4 + 7);
                switch(*(_BYTE *)(a4 + 7))
                {
                  case 0:
                    break;
                  case 1:
                    v91 = *(unsigned __int8 *)v88;
                    break;
                  case 2:
                    v91 = __rev16(*(unsigned __int16 *)v88);
                    break;
                  case 4:
                    v91 = bswap32(*v88);
                    break;
                  case 8:
                    v91 = bswap64(*(_QWORD *)v88);
                    break;
                  default:
                    v91 = 0;
                    v92 = v88;
                    do
                    {
                      v93 = *(unsigned __int8 *)v92;
                      v92 = (unsigned int *)((char *)v92 + 1);
                      v91 = v93 | (v91 << 8);
                      --v90;
                    }
                    while (v90);
                    break;
                }
                if (*(_QWORD *)(a4 + 8) <= v91)
                  break;
                v94 = *(unsigned __int8 *)(a4 + 6);
                v95 = (unsigned int *)(v89 + v91 * v94);
                switch(*(_BYTE *)(a4 + 6))
                {
                  case 0:
                    break;
                  case 1:
                    LODWORD(v94) = *(unsigned __int8 *)v95;
                    break;
                  case 2:
                    LODWORD(v94) = __rev16(*(unsigned __int16 *)v95);
                    break;
                  case 4:
                    LODWORD(v94) = bswap32(*v95);
                    break;
                  case 8:
                    LODWORD(v94) = bswap64(*(_QWORD *)v95);
                    break;
                  default:
                    v96 = *(unsigned __int8 *)(a4 + 6);
                    LODWORD(v94) = 0;
                    do
                    {
                      v97 = *(unsigned __int8 *)v95;
                      v95 = (unsigned int *)((char *)v95 + 1);
                      LODWORD(v94) = v97 | ((_DWORD)v94 << 8);
                      --v96;
                    }
                    while (v96);
                    break;
                }
                v200 = 0;
                v98 = v204[0];
                if (v80)
                  v98 = 0;
                if ((__CFBinaryPlistCreateObjectFiltered(v20, a2, v94, a4, (int)v196, a6, a7, (int)v194, v193, v185, (uint64_t)v98, v184, 0) & 1) == 0)
                {
                  v123 = v188;
                  if (v188)
                  {
                    while (v87 != -1)
                    {
                      v124 = *(const void **)&v123[8 * v87--];
                      CFRelease(v124);
                    }
                    if (v123 != v182)
                      CFAllocatorDeallocate(v181, v188);
                  }
                  goto LABEL_285;
                }
                if (v188)
                  *(_QWORD *)&v188[8 * v85] = v200;
                v84 = (unint64_t)v88 + *(unsigned __int8 *)v189;
                ++v85;
                ++v87;
                if (v85 >= (uint64_t)v190)
                  goto LABEL_227;
              }
              v115 = v188;
              if (v188)
              {
                v116 = v182;
                while (v87 != -1)
                {
                  v117 = (const void *)v115[v87--];
                  CFRelease(v117);
                }
                if (v115 != v116)
                  CFAllocatorDeallocate(v181, v115);
              }
LABEL_285:
              Typed = 0;
              goto LABEL_306;
            }
LABEL_227:
            if (v180 != 160)
            {
              if (!v195)
              {
LABEL_277:
                v105 = 1;
                v102 = 17;
LABEL_279:
                v104 = (uint64_t *)v197;
                goto LABEL_290;
              }
              if (v192)
              {
                v99 = CFSetCreateMutable((CFAllocatorRef)v196, 0, &kCFTypeSetCallBacks);
                *v195 = v99;
                if (v190)
                {
                  v100 = (const void **)v188;
                  v101 = v190;
                  do
                  {
                    CFSetAddValue(*v195, *v100++);
                    v101 = (const __CFArray *)((char *)v101 - 1);
                  }
                  while (v101);
                  if (v190)
                  {
                    v102 = 17;
                    v103 = (CFTypeRef *)v188;
                    v104 = (uint64_t *)v197;
                    v105 = 1;
                    do
                    {
                      CFRelease(*v103++);
                      v190 = (const __CFArray *)((char *)v190 - 1);
                    }
                    while (v190);
                    goto LABEL_290;
                  }
                }
                goto LABEL_277;
              }
              Transfer = (const __CFArray *)__CFSetCreateTransfer(v196, (unint64_t *)v188, (uint64_t)v190);
              v102 = 17;
LABEL_288:
              v104 = (uint64_t *)v197;
LABEL_289:
              *v195 = Transfer;
              v105 = 1;
              goto LABEL_290;
            }
            if (v195)
            {
              if (!v192)
              {
                Transfer = (const __CFArray *)__CFArrayCreateTransfer(v196, v188, (unint64_t)v190);
                v102 = 19;
                goto LABEL_288;
              }
              v118 = CFArrayCreateMutable((CFAllocatorRef)v196, 0, &kCFTypeArrayCallBacks);
              *v195 = v118;
              v205.location = 0;
              v205.length = 0;
              CFArrayReplaceValues(v118, v205, (const void **)v188, (CFIndex)v190);
              if (v190)
              {
                v102 = 19;
                v119 = (CFTypeRef *)v188;
                do
                {
                  CFRelease(*v119++);
                  v190 = (const __CFArray *)((char *)v190 - 1);
                }
                while (v190);
                v105 = 1;
                goto LABEL_279;
              }
            }
            v105 = 1;
            v102 = 19;
            goto LABEL_279;
          }
          Count = CFSetGetCount(valuePtr[0]);
          v104 = (uint64_t *)v197;
          v190 = CFArrayCreateMutable(v82, Count, &kCFTypeArrayCallBacks);
          if (!valuePtr[0])
          {
            v105 = 1;
            goto LABEL_269;
          }
          v107 = CFSetGetCount(valuePtr[0]);
          v108 = (const void **)malloc_type_malloc(8 * v107, 0xC0040B8AA526DuLL);
          CFSetGetValues(valuePtr[0], v108);
          v185 = (uint64_t)v108;
          v191 = CFSetGetCount(valuePtr[0]);
          v104 = (uint64_t *)v197;
          if (v191 < 1)
          {
            v105 = 1;
            goto LABEL_268;
          }
          v189 = (__CFSet **)(a10 + 1);
          v109 = &v199;
          if (!v195)
            v109 = 0;
          v187 = v109;
          v110 = (CFStringRef *)v185;
          while (1)
          {
            v111 = *v110;
            IntValue = CFStringGetIntValue(*v110);
            v114 = IntValue;
            if (IntValue != 0x7FFFFFFF)
            {
              if (IntValue)
              {
                if (IntValue < 0)
                  goto LABEL_251;
              }
              else if (CFStringCompare(CFSTR("0"), v111, 0))
              {
                goto LABEL_251;
              }
              v200 = 0;
              if (__CFBinaryPlistGetOffsetForValueFromArray2(v20, v113, a3, a4, v114, &v200))
              {
                v199 = 0;
                if (!__CFBinaryPlistCreateObjectFiltered(v20, a2, v200, a4, (int)v196, a6, a7, (int)v194, v193, (uint64_t)v189, (uint64_t)v204[0], (uint64_t)v187, 0))
                {
                  v105 = 0;
LABEL_253:
                  v104 = (uint64_t *)v197;
LABEL_268:
                  free((void *)v185);
LABEL_269:
                  if (v195 && v105)
                  {
                    if ((unint64_t)(v192 - 1) < 2)
                    {
                      v102 = 19;
                      Transfer = v190;
                      goto LABEL_289;
                    }
                    v121 = v190;
                    Copy = CFArrayCreateCopy((CFAllocatorRef)v196, v190);
                    *v195 = Copy;
                    CFRelease(v121);
                    v105 = 1;
                  }
                  else if (v190)
                  {
                    CFRelease(v190);
                  }
                  v102 = 19;
LABEL_290:
                  if (v104)
                    *v104 = v102;
                  if (v193)
                    CFSetRemoveValue(v193, (const void *)v198);
                  Typed = v105 != 0;
                  if (v195 && v194 && !v192 && v105)
                    CFDictionarySetValue(v194, (const void *)v198, *v195);
                  if (v188 && v188 != v182)
                    CFAllocatorDeallocate(v181, v188);
                  if (valuePtr[0])
                    CFRelease(valuePtr[0]);
                  if (v204[0])
                    CFRelease(v204[0]);
LABEL_306:
                  if (v183)
                    CFRelease((CFTypeRef)v183);
                  return Typed;
                }
                if (v199)
                {
                  CFArrayAppendValue(v190, v199);
                  CFRelease(v199);
                }
              }
            }
LABEL_251:
            ++v110;
            if (!--v191)
            {
              v105 = 1;
              goto LABEL_253;
            }
          }
        case 0xDu:
          v191 = a11;
          v192 = a6;
          if (v24 == -1)
            return 0;
          v33 = (const __CFArray *)(v24 + 1);
          v34 = v25 & 0xF;
          if ((v25 & 0xF) != 0xF)
            goto LABEL_317;
          if (v20 + v23 < (unint64_t)v33)
            return 0;
          v35 = (unsigned __int8 *)(v24 + 2);
          v36 = *(_BYTE *)v33;
          if ((*(_BYTE *)v33 & 0xF0) != 0x10)
            return 0;
          Typed = 0;
          v37 = v36 & 0xF;
          v38 = 1 << (v36 & 0xF);
          if (__CFADD__(v38, v35) || (unint64_t)v33 + v38 > v20 + v23)
            return Typed;
          switch((char)v38)
          {
            case 1:
              v34 = *v35;
              goto LABEL_316;
            case 2:
              v34 = __rev16(*(unsigned __int16 *)(v24 + 2));
              goto LABEL_316;
            case 4:
              v34 = bswap32(*(_DWORD *)(v24 + 2));
              goto LABEL_316;
            case 8:
              v34 = bswap64(*(_QWORD *)(v24 + 2));
              goto LABEL_315;
            default:
              if (v37 >= 8)
              {
                v33 = (const __CFArray *)&v35[v38];
                goto LABEL_320;
              }
              v34 = 0;
              if ((v38 & 0xFE) != 0)
                v125 = v38;
              else
                v125 = 1;
              v126 = (unsigned __int8 *)(v24 + 2);
              do
              {
                v127 = *v126++;
                v34 = v127 | (v34 << 8);
                --v125;
              }
              while (v125);
LABEL_315:
              if ((v34 & 0x8000000000000000) != 0)
                return 0;
LABEL_316:
              v33 = (const __CFArray *)&v35[v38];
              break;
          }
LABEL_317:
          if (v34)
          {
            v128 = 2 * v34;
            v130 = (unsigned __int8 *)(a4 + 7);
            v129 = *(unsigned __int8 *)(a4 + 7);
            if (!is_mul_ok(2 * v34, v129))
              return 0;
            v190 = v33;
            v131 = 0;
            v132 = v128 * v129;
          }
          else
          {
LABEL_320:
            v190 = v33;
            v132 = 0;
            v128 = 0;
            v130 = (unsigned __int8 *)(a4 + 7);
            v131 = 1;
          }
          Typed = 0;
          if (__CFADD__(v132, v190) || v20 + v23 < (unint64_t)v190 + v132 - 1)
            return Typed;
          if ((v131 & 1) != 0)
          {
            v188 = v130;
            v185 = 0;
          }
          else
          {
            if (v128 >> 61)
              return 0;
            v188 = v130;
            v185 = 8 * v128;
          }
          v187 = (const void **)v179;
          MEMORY[0x1E0C80A78](Value, v23);
          v136 = v135;
          v137 = (__CFSet **)&v179[-v134];
          if (v133 >= 0x200)
            v138 = 512;
          else
            v138 = v133;
          bzero(&v179[-v134], v138);
          v186 = v137;
          v183 = v136;
          if (v195)
          {
            v189 = v137;
            v139 = v196;
            if (v136 >= 257)
            {
              v189 = (__CFSet **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v185, 303780961, 0);
              if (!v189)
                return 0;
            }
          }
          else
          {
            v189 = 0;
            v139 = v196;
          }
          v140 = 0;
          if (v193)
          {
            v141 = (const __CFSet *)v191;
          }
          else
          {
            v141 = (const __CFSet *)v191;
            if (a10 >= 16)
            {
              v140 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0);
              v193 = v140;
            }
          }
          v191 = (CFIndex)v140;
          if (v193)
            CFSetAddValue(v193, (const void *)v198);
          if (v141)
          {
            v142 = (const __CFAllocator *)v139;
            v143 = v192;
            FilteredDictionary = __CFPropertyListCreateFilteredDictionary(v142, v141, v20, a2, a3, a4, v195 == 0, v192, a7, SHIDWORD(a7), (int)v194, v193, a10);
            v145 = FilteredDictionary;
            if (v195 && FilteredDictionary)
            {
              if ((unint64_t)(v143 - 1) < 2)
              {
                *v195 = FilteredDictionary;
LABEL_390:
                Typed = 1;
                goto LABEL_391;
              }
              v166 = CFDictionaryCreateCopy((CFAllocatorRef)v196, FilteredDictionary);
              *v195 = v166;
            }
            else if (!FilteredDictionary)
            {
              Typed = 0;
LABEL_391:
              v167 = v193;
              goto LABEL_430;
            }
            CFRelease(v145);
            goto LABEL_390;
          }
          v185 = v183 >> 1;
          v146 = v183;
          v147 = v190;
          if (v183 >= 1)
          {
            v148 = 0;
            v184 = v20 + 8;
            v149 = (const __CFAllocator *)valuePtr;
            if (!v195)
              v149 = 0;
            v181 = v149;
            v182 = (unsigned __int8 *)(a10 + 1);
            v150 = -1;
            while (v184 <= (unint64_t)v147)
            {
              v151 = (unsigned int *)v147;
              v152 = v20 + *(_QWORD *)(a4 + 24);
              v153 = *(unsigned __int8 *)(a4 + 7);
              if (v152 - v153 < (unint64_t)v147)
                break;
              v154 = *(unsigned __int8 *)(a4 + 7);
              switch(*(_BYTE *)(a4 + 7))
              {
                case 0:
                  break;
                case 1:
                  v154 = *(unsigned __int8 *)v151;
                  break;
                case 2:
                  v154 = __rev16(*(unsigned __int16 *)v151);
                  break;
                case 4:
                  v154 = bswap32(*v151);
                  break;
                case 8:
                  v154 = bswap64(*(_QWORD *)v151);
                  break;
                default:
                  v154 = 0;
                  v155 = v151;
                  do
                  {
                    v156 = *(unsigned __int8 *)v155;
                    v155 = (unsigned int *)((char *)v155 + 1);
                    v154 = v156 | (v154 << 8);
                    --v153;
                  }
                  while (v153);
                  break;
              }
              if (*(_QWORD *)(a4 + 8) <= v154)
                break;
              v157 = *(unsigned __int8 *)(a4 + 6);
              v158 = (unsigned int *)(v152 + v154 * v157);
              switch(*(_BYTE *)(a4 + 6))
              {
                case 0:
                  break;
                case 1:
                  LODWORD(v157) = *(unsigned __int8 *)v158;
                  break;
                case 2:
                  LODWORD(v157) = __rev16(*(unsigned __int16 *)v158);
                  break;
                case 4:
                  LODWORD(v157) = bswap32(*v158);
                  break;
                case 8:
                  LODWORD(v157) = bswap64(*(_QWORD *)v158);
                  break;
                default:
                  v159 = *(unsigned __int8 *)(a4 + 6);
                  LODWORD(v157) = 0;
                  do
                  {
                    v160 = *(unsigned __int8 *)v158;
                    v158 = (unsigned int *)((char *)v158 + 1);
                    LODWORD(v157) = v160 | ((_DWORD)v157 << 8);
                    --v159;
                  }
                  while (v159);
                  break;
              }
              valuePtr[0] = 0;
              v204[0] = 0;
              if (!__CFBinaryPlistCreateObjectFiltered(v20, a2, v157, a4, (int)v196, a6, a7, (int)v194, v193, (uint64_t)v182, 0, (uint64_t)v181, (uint64_t)v204)|| v148 < v185 && v204[0] != (__CFSet *)7)
              {
                v170 = v189;
                if (valuePtr[0])
                  CFRelease(valuePtr[0]);
                if (v170)
                {
                  while (v150 != -1)
                  {
                    v171 = v170[v150--];
                    CFRelease(v171);
                  }
                  if (v170 != v186)
                    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v170);
                }
LABEL_424:
                Typed = 0;
                goto LABEL_442;
              }
              if (v189)
                v189[v148] = valuePtr[0];
              v147 = (const __CFArray *)((char *)v151 + *v188);
              ++v148;
              ++v150;
              if (v148 == v146)
                goto LABEL_375;
            }
            v168 = v189;
            if (v189)
            {
              while (v150 != -1)
              {
                v169 = v168[v150--];
                CFRelease(v169);
              }
              if (v168 != v186)
                CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v189);
            }
            goto LABEL_424;
          }
LABEL_375:
          if (v195)
          {
            if (v192)
            {
              v161 = CFDictionaryCreateMutable((CFAllocatorRef)v196, v185, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (v146 >= 1)
              {
                v162 = v185;
                if (v185 <= 1)
                  v163 = 1;
                else
                  v163 = v185;
                v164 = (const void **)v189;
                do
                {
                  CFDictionaryAddValue(v161, *v164, v164[v162]);
                  ++v164;
                  --v163;
                }
                while (v163);
                v165 = (CFTypeRef *)v189;
                do
                {
                  CFRelease(*v165++);
                  --v146;
                }
                while (v146);
              }
            }
            else
            {
              v161 = (__CFDictionary *)__CFDictionaryCreateTransfer(v196, (unint64_t *)v189, (unint64_t *)&v189[v185], v185);
            }
            *v195 = v161;
          }
          v167 = v193;
          if (v197)
            *v197 = 18;
          Typed = 1;
LABEL_430:
          if (v167)
            CFSetRemoveValue(v167, (const void *)v198);
          if (v192)
            v178 = 0;
          else
            v178 = Typed;
          if (v195 && v194 && v178)
            CFDictionarySetValue(v194, (const void *)v198, *v195);
          if (v189 && v189 != v186)
            CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v189);
LABEL_442:
          if (v191)
            CFRelease((CFTypeRef)v191);
          break;
        default:
          return Typed;
      }
    }
  }
  return Typed;
}

void sub_182AB5090(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_QWORD *)(v1 + 88))
    CFRelease(*(CFTypeRef *)(v1 + 88));
  _Unwind_Resume(exception_object);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)bytes, numBytes, *(uint64_t *)&encoding, (isExternalRepresentation != 0) | 2u, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  char v6;
  char v7;
  const char *v8;
  char v9;
  const char *v10;
  const char *v11;
  CFMutableDictionaryRef v12;

  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary __setObject:forKey:](theDict, "__setObject:forKey:", value, key);
  }
  else
  {
    v6 = atomic_load((unint64_t *)theDict + 1);
    if ((v6 & 0x40) != 0)
    {
      v11 = "void CFDictionarySetValue(CFMutableDictionaryRef, const void *, const void *)";
      v12 = theDict;
      CFLog(3, CFSTR("%s(): immutable collection %p given to mutating function"));
    }
    v7 = atomic_load((unint64_t *)theDict + 1);
    if ((v7 & 1) != 0)
    {
      v8 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        v8 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v8;
      }
      objc_msgSend(theDict, v8, key, v11, v12);
    }
    CFBasicHashSetValue((uint64_t)theDict, (unint64_t)key, (uint64_t)value);
    v9 = atomic_load((unint64_t *)theDict + 1);
    if ((v9 & 1) != 0)
    {
      v10 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        v10 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v10;
      }
      objc_msgSend(theDict, v10, key);
    }
  }
}

void CFBasicHashSetValue(uint64_t a1, unint64_t a2, uint64_t a3)
{
  char v3;
  int v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v3 = atomic_load((unint64_t *)(a1 + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809 || a3 == 2814029233)
    goto LABEL_24;
  v8 = 0u;
  v9 = 0u;
  if (*(_BYTE *)(a1 + 26))
  {
    v7 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, (uint64_t *)&v8);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double_Indirect(a1, a2, (uint64_t *)&v8);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, (uint64_t *)&v8);
          break;
        default:
          goto LABEL_24;
      }
    }
    else if (v7 == 3)
    {
      ___CFBasicHashFindBucket_Exponential(a1, a2, (uint64_t *)&v8);
    }
    else
    {
      if (v7 != 2)
      {
        if (v7 == 1)
        {
          ___CFBasicHashFindBucket_Linear(a1, a2, (uint64_t *)&v8);
          goto LABEL_21;
        }
LABEL_24:
        __break(1u);
      }
      ___CFBasicHashFindBucket_Double(a1, a2, (uint64_t *)&v8);
    }
  }
  else
  {
    v8 = xmmword_182DC7A10;
    v9 = unk_182DC7A20;
  }
LABEL_21:
  if (*((_QWORD *)&v9 + 1))
    __CFBasicHashReplaceValue(a1, v8, a2, a3);
  else
    __CFBasicHashAddValue(a1, v8, a2, a3);
}

uint64_t getContentObject(unint64_t *a1, _BYTE *a2, uint64_t a3, unint64_t a4)
{
  CFErrorRef Error;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v14;
  uint64_t v16;
  uint64_t v17;

  if (a4 >= 0x81)
  {
    v16 = lineNumber(a1);
    Error = __CFPropertyListCreateError(3840, CFSTR("Too many nested arrays or dictionaries, failing on line %u"), v16);
LABEL_26:
    a1[3] = (unint64_t)Error;
    return 0;
  }
  if (a2)
    *a2 = 0;
  if (a1[3])
    return 0;
  while (2)
  {
    v9 = (char *)a1[1];
    v10 = a1[2];
    if ((unint64_t)v9 >= v10)
      return 0;
    v11 = v10 - (_QWORD)v9;
    while (1)
    {
      v12 = *v9;
      if (v12 > 0x20 || ((1 << *v9) & 0x100002600) == 0)
        break;
      a1[1] = (unint64_t)++v9;
      if (!--v11)
        goto LABEL_25;
    }
    if ((_DWORD)v12 != 60)
    {
      v17 = lineNumber(a1);
      Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unexpected character %c on line %u while looking for open tag"), v12, v17);
      goto LABEL_26;
    }
    a1[1] = (unint64_t)(v9 + 1);
    if ((unint64_t)(v9 + 1) >= v10)
      goto LABEL_25;
    v14 = v9[1];
    switch(v14)
    {
      case '!':
        if ((unint64_t)(v9 + 3) < v10 && v9[2] == 45 && v9[3] == 45)
        {
          a1[1] = (unint64_t)(v9 + 4);
          skipXMLComment(a1);
LABEL_23:
          if (!a1[3])
            continue;
          return 0;
        }
LABEL_25:
        Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unexpected EOF"));
        goto LABEL_26;
      case '?':
        skipXMLProcessingInstruction(a1);
        goto LABEL_23;
      case '/':
        a1[1] = (unint64_t)v9;
        return 0;
    }
  }
  return parseXMLElement(a1, a2, a3, a4);
}

uint64_t parseXMLElement(uint64_t a1, _BYTE *a2, CFTypeRef *a3, uint64_t a4)
{
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  _BOOL4 v15;
  size_t v16;
  _BOOL4 v17;
  int v18;
  _BOOL4 v19;
  int v20;
  int v21;
  int v22;
  CFErrorRef Error;
  BOOL v24;
  int v25;
  int v27;
  BOOL v28;
  int v29;
  int v30;
  CFErrorRef v31;
  uint64_t result;
  int v33;
  const __CFAllocator *v34;
  void *Mutable;
  CFStringRef v36;
  CFStringRef v37;
  const __CFString *v38;
  uint64_t v39;
  int v40;
  const __CFAllocator *v41;
  CFTypeRef *v42;
  int v43;
  const __CFAllocator *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  v6 = *(unsigned __int8 **)(a1 + 8);
  v7 = v6;
  if (a2)
  {
    *a2 = 0;
    v7 = *(unsigned __int8 **)(a1 + 8);
  }
  v8 = *(unsigned __int8 **)(a1 + 16);
  if (v7 >= v8)
  {
    v11 = -1;
  }
  else
  {
    v9 = v8 - v7;
    v10 = (_DWORD)v7 - (_DWORD)v6;
    v11 = -1;
    do
    {
      v12 = *v7;
      if (v12 <= 0x3E)
      {
        if (((1 << v12) & 0x100002600) != 0)
        {
          if (v11 == -1)
            v11 = v10;
        }
        else if (v12 == 62)
        {
          goto LABEL_14;
        }
      }
      *(_QWORD *)(a1 + 8) = ++v7;
      ++v10;
      --v9;
    }
    while (v9);
    v7 = v8;
  }
LABEL_14:
  if (v7 >= v8)
    return 0;
  v13 = *(v7 - 1);
  if (v11 == -1)
    v11 = (_DWORD)v7 - (v13 == 47) - (_DWORD)v6;
  *(_QWORD *)(a1 + 8) = v7 + 1;
  if (v11)
  {
    v14 = -1;
    v15 = 1;
    v16 = 6;
    v17 = 1;
    v18 = 1;
    v19 = 1;
    v20 = 1;
    v21 = 1;
    switch(*v6)
    {
      case 'a':
        if (v11 != 5)
          goto LABEL_65;
        v22 = *(_DWORD *)v6 ^ 0x61727261 | v6[4] ^ 0x79;
        v17 = v22 != 0;
        if (v22)
          v14 = -1;
        else
          v14 = 1;
        v15 = 1;
        goto LABEL_49;
      case 'b':
      case 'c':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'q':
        goto LABEL_71;
      case 'd':
        if (v11 != 4)
          goto LABEL_65;
        if (*(_DWORD *)v6 == 1952672100)
        {
          v18 = 0;
          v14 = 2;
          goto LABEL_64;
        }
        v16 = 6;
        if (*(_DWORD *)v6 == 1635017060)
        {
          v21 = 0;
          v14 = 5;
        }
        else if (*(_DWORD *)v6 == 1702125924)
        {
          v14 = 6;
        }
        else
        {
          v14 = -1;
        }
        v15 = 1;
        goto LABEL_70;
      case 'f':
        if (v11 != 5)
          goto LABEL_65;
        v24 = (*(_DWORD *)v6 ^ 0x736C6166 | v6[4] ^ 0x65) == 0;
        v25 = 10;
        goto LABEL_54;
      case 'i':
        if (v11 != 7)
          goto LABEL_65;
        v24 = (*(_DWORD *)v6 ^ 0x65746E69 | *(_DWORD *)(v6 + 3) ^ 0x72656765) == 0;
        v25 = 8;
        goto LABEL_54;
      case 'k':
        if (v11 != 3)
          goto LABEL_65;
        if (*(_WORD *)v6 != 25963 || v6[2] != 121)
          goto LABEL_57;
        v15 = 1;
        v20 = 0;
        v16 = 3;
        if (a2)
          *a2 = 1;
        v17 = 1;
        v18 = 1;
        v14 = 3;
        goto LABEL_71;
      case 'p':
        if (v11 != 5)
          goto LABEL_65;
        v27 = *(_DWORD *)v6 ^ 0x73696C70 | v6[4] ^ 0x74;
        v24 = v27 == 0;
        v15 = v27 != 0;
        if (v24)
          v14 = 0;
        else
          v14 = -1;
        v17 = 1;
LABEL_49:
        v16 = 6;
        goto LABEL_58;
      case 'r':
        if (v11 != 4)
          goto LABEL_65;
        v28 = *(_DWORD *)v6 == 1818322290;
        v29 = 7;
        goto LABEL_61;
      case 's':
        if (v11 != 6)
          goto LABEL_65;
        v30 = *(_DWORD *)v6 ^ 0x69727473 | *((unsigned __int16 *)v6 + 2) ^ 0x676E;
        v24 = v30 == 0;
        v19 = v30 != 0;
        v25 = 4;
LABEL_54:
        if (v24)
          v14 = v25;
        else
          v14 = -1;
LABEL_57:
        v15 = 1;
        v16 = 6;
        v17 = 1;
LABEL_58:
        v18 = 1;
        goto LABEL_71;
      case 't':
        if (v11 == 4)
        {
          v28 = *(_DWORD *)v6 == 1702195828;
          v29 = 9;
LABEL_61:
          if (v28)
            v14 = v29;
          else
            v14 = -1;
LABEL_64:
          v15 = 1;
          v16 = 6;
LABEL_70:
          v17 = 1;
        }
        else
        {
LABEL_65:
          v16 = 6;
        }
LABEL_71:
        if (v21 && v20 && v19 && v18 && v17 && v15 && !*(_BYTE *)(a1 + 64))
        {
          Error = __CFPropertyListCreateError(3840, CFSTR("Encountered new tag when expecting only old-style property list objects"));
          goto LABEL_79;
        }
        switch(v14)
        {
          case 0:
            if (v13 == 47)
            {
              Error = __CFPropertyListCreateError(3840, CFSTR("Encountered empty plist tag"));
              goto LABEL_79;
            }
            return parsePListTag((unint64_t *)a1, a3, a4 + 1);
          case 1:
            if (v13 == 47)
            {
              if (*(_BYTE *)(a1 + 80))
                goto LABEL_101;
              v40 = *(_DWORD *)(a1 + 40);
              v41 = *(const __CFAllocator **)(a1 + 32);
              if (v40)
                Mutable = CFArrayCreateMutable(v41, 0, &kCFTypeArrayCallBacks);
              else
                Mutable = CFArrayCreate(v41, 0, 0, &kCFTypeArrayCallBacks);
              goto LABEL_138;
            }
            return parseArrayTag(a1, (CFArrayRef *)a3, a4 + 1);
          case 2:
            if (v13 == 47)
            {
              if (*(_BYTE *)(a1 + 80))
                goto LABEL_101;
              v43 = *(_DWORD *)(a1 + 40);
              v44 = *(const __CFAllocator **)(a1 + 32);
              if (v43)
                Mutable = CFDictionaryCreateMutable(v44, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              else
                Mutable = CFDictionaryCreate(v44, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              goto LABEL_138;
            }
            return parseDictTag(a1, a3, a4 + 1);
          case 3:
          case 4:
            if (v13 == 47)
            {
              if (*(_BYTE *)(a1 + 80))
              {
LABEL_101:
                *a3 = 0;
                goto LABEL_139;
              }
              v33 = *(_DWORD *)(a1 + 40);
              v34 = *(const __CFAllocator **)(a1 + 32);
              if (v33 == 2)
                Mutable = CFStringCreateMutable(v34, 0);
              else
                Mutable = (void *)CFStringCreateWithCharacters(v34, 0, 0);
              goto LABEL_138;
            }
            result = parseStringTag(a1, (CFMutableStringRef *)a3);
            if ((_DWORD)result)
            {
              if (checkForCloseTag((unint64_t *)a1, &CFXMLPlistTags[10 * v14], v16))
                goto LABEL_139;
              result = (uint64_t)*a3;
              if (*a3)
                goto LABEL_90;
            }
            return result;
          case 5:
            if (v13 == 47)
            {
              v46 = lineNumber((unint64_t *)a1);
              Error = __CFPropertyListCreateError(3840, CFSTR("Encountered empty <data> on line %u"), v46);
              goto LABEL_79;
            }
            return parseDataTag(a1, (__CFData **)a3);
          case 6:
            if (v13 == 47)
            {
              v47 = lineNumber((unint64_t *)a1);
              Error = __CFPropertyListCreateError(3840, CFSTR("Encountered empty <date> on line %u"), v47);
              goto LABEL_79;
            }
            return parseDateTag(a1, (CFDateRef *)a3);
          case 7:
            if (v13 == 47)
            {
              v48 = lineNumber((unint64_t *)a1);
              Error = __CFPropertyListCreateError(3840, CFSTR("Encountered empty <real> on line %u"), v48);
              goto LABEL_79;
            }
            return parseRealTag(a1, a3);
          case 8:
            if (v13 == 47)
            {
              v49 = lineNumber((unint64_t *)a1);
              Error = __CFPropertyListCreateError(3840, CFSTR("Encountered empty <integer> on line %u"), v49);
              goto LABEL_79;
            }
            return parseIntegerTag(a1, (CFNumberRef *)a3);
          case 9:
            if (v13 != 47 && !checkForCloseTag((unint64_t *)a1, (const UInt8 *)"true", 4uLL))
            {
              v50 = lineNumber((unint64_t *)a1);
              Error = __CFPropertyListCreateError(3840, CFSTR("Encountered non-empty <true> on line %u"), v50);
              goto LABEL_79;
            }
            if (*(_BYTE *)(a1 + 80))
              goto LABEL_117;
            v42 = (CFTypeRef *)&kCFBooleanTrue;
            goto LABEL_130;
          case 10:
            if (v13 != 47 && !checkForCloseTag((unint64_t *)a1, (const UInt8 *)"false", 5uLL))
            {
              v51 = lineNumber((unint64_t *)a1);
              Error = __CFPropertyListCreateError(3840, CFSTR("Encountered non-empty <false> on line %u"), v51);
              goto LABEL_79;
            }
            if (*(_BYTE *)(a1 + 80))
            {
LABEL_117:
              Mutable = 0;
            }
            else
            {
              v42 = (CFTypeRef *)&kCFBooleanFalse;
LABEL_130:
              Mutable = (void *)CFRetain(*v42);
            }
LABEL_138:
            *a3 = Mutable;
LABEL_139:
            result = 1;
            break;
          default:
            v36 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6, v14, 0x8000100u, 0);
            v37 = v36;
            *(_QWORD *)(a1 + 8) = v6;
            if (v36)
              v38 = v36;
            else
              v38 = CFSTR("<unknown>");
            v39 = lineNumber((unint64_t *)a1);
            *(_QWORD *)(a1 + 24) = __CFPropertyListCreateError(3840, CFSTR("Encountered unknown tag %@ on line %u"), v38, v39);
            if (!v37)
              return 0;
            result = (uint64_t)v37;
LABEL_90:
            CFRelease((CFTypeRef)result);
            return 0;
        }
        break;
      default:
        v17 = 1;
        v18 = 1;
        v19 = 1;
        v20 = 1;
        v21 = 1;
        goto LABEL_71;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 8) = v6;
    v45 = lineNumber((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840, CFSTR("Malformed tag on line %u"), v45);
LABEL_79:
    v31 = Error;
    result = 0;
    *(_QWORD *)(a1 + 24) = v31;
  }
  return result;
}

uint64_t checkForCloseTag(unint64_t *a1, const UInt8 *a2, size_t a3)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  CFErrorRef Error;
  int v7;
  unsigned __int8 *v10;
  CFStringRef v11;
  uint64_t v12;
  uint64_t result;
  CFErrorRef v14;
  unsigned __int8 *v15;
  unsigned int v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v4 = (unsigned __int8 *)a1[1];
  v5 = (unsigned __int8 *)a1[2];
  if (v5 - v4 < (uint64_t)(a3 + 3))
    goto LABEL_27;
  v7 = *v4;
  if (v7 != 60 || (a1[1] = (unint64_t)(v4 + 1), v7 = v4[1], v7 != 47))
  {
    if (!a1[3])
    {
      v21 = lineNumber(a1);
      Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unexpected character %c on line %u while looking for close tag"), (char)v7, v21);
      goto LABEL_13;
    }
    return 0;
  }
  v10 = v4 + 2;
  a1[1] = (unint64_t)(v4 + 2);
  if (memcmp(v4 + 2, a2, a3))
  {
    v11 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, a3, 0x8000100u, 0);
    if (!a1[3])
    {
      v12 = lineNumber(a1);
      a1[3] = (unint64_t)__CFPropertyListCreateError(3840, CFSTR("Close tag on line %u does not match open tag %@"), v12, v11);
    }
    CFRelease(v11);
    return 0;
  }
  v15 = &v10[a3];
  for (a1[1] = (unint64_t)&v10[a3]; v15 < v5; a1[1] = (unint64_t)v15)
  {
    v16 = (char)*v15;
    v17 = v16 > 0x20;
    v18 = (1 << v16) & 0x100002600;
    if (v17 || v18 == 0)
      break;
    ++v15;
  }
  if (v15 == v5)
  {
LABEL_27:
    if (!a1[3])
    {
      Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unexpected EOF"));
LABEL_13:
      v14 = Error;
      result = 0;
      a1[3] = (unint64_t)v14;
      return result;
    }
    return 0;
  }
  if (*v15 != 62)
  {
    if (!a1[3])
    {
      v20 = (char)*v15;
      v22 = lineNumber(a1);
      Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unexpected character %c on line %u while looking for close tag"), v20, v22);
      goto LABEL_13;
    }
    return 0;
  }
  a1[1] = (unint64_t)(v15 + 1);
  return 1;
}

uint64_t parseStringTag(uint64_t a1, CFMutableStringRef *a2)
{
  uint64_t result;
  __CFData *Mutable;
  const UInt8 *v6;
  const UInt8 *v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  CFErrorRef Error;
  _BYTE *v14;
  unint64_t v15;
  unsigned int v16;
  int v17;
  UInt8 v18;
  int v19;
  uint64_t v20;
  const UInt8 *v21;
  CFIndex v22;
  uint64_t v23;
  CFIndex v24;
  UInt8 v25;
  _BYTE *v26;
  int v27;
  uint64_t v28;
  unsigned int v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  const __CFString *v34;
  const __CFString *v35;
  const __CFAllocator *v36;
  const UInt8 *v37;
  CFIndex v38;
  const __CFString *v39;
  const __CFString *v40;
  const __CFString *v41;
  __CFString *MutableCopy;
  const UInt8 *BytePtr;
  CFIndex Length;
  __CFString *UniqueStringWithUTF8Bytes;
  CFErrorRef v46;
  CFIndex *usedBufLen;
  CFIndex *usedBufLena;
  CFIndex *usedBufLenb;
  CFIndex *usedBufLenc;
  CFIndex *usedBufLend;
  CFIndex *usedBufLene;
  uint64_t v53;
  uint64_t v54;
  UInt8 bytes[8];
  UInt8 v56[6];
  UInt8 buffer[6];
  uint64_t v58;
  CFRange v59;

  v58 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 24))
    return 0;
  Mutable = 0;
  v6 = *(const UInt8 **)(a1 + 8);
  v7 = v6;
  while (1)
  {
    v8 = *(_QWORD *)(a1 + 16);
    if ((unint64_t)v6 >= v8)
      break;
    v9 = *v6;
    if (v9 == 38)
    {
      if (!Mutable)
      {
        Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
        v6 = *(const UInt8 **)(a1 + 8);
      }
      CFDataAppendBytes(Mutable, v7, v6 - v7);
      v14 = *(_BYTE **)(a1 + 8);
      v15 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 8) = v14 + 1;
      v16 = v15 - ((_DWORD)v14 + 1);
      if ((int)v16 <= 0)
        goto LABEL_72;
      v17 = (char)v14[1];
      if (v17 <= 102)
      {
        if (v17 == 35)
        {
          if (v16 > 3)
          {
            v26 = v14 + 2;
            *(_QWORD *)(a1 + 8) = v14 + 2;
            v27 = v14[2];
            if (v27 == 120)
            {
              v26 = v14 + 3;
              *(_QWORD *)(a1 + 8) = v14 + 3;
            }
            if ((unint64_t)v26 < v15)
            {
              v28 = 0;
              v29 = 0;
              v30 = v15 - (_QWORD)v26;
              while (1)
              {
                v31 = (char)v26[v28];
                *(_QWORD *)(a1 + 8) = &v26[v28 + 1];
                if ((_DWORD)v31 == 59)
                  break;
                if ((_DWORD)v28 == 8)
                {
                  usedBufLend = (CFIndex *)lineNumber((unint64_t *)a1);
                  Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unparseable unicode sequence at line %u while parsing data (too large of a value for a Unicode sequence)"), usedBufLend, v53, *(_QWORD *)bytes);
                  goto LABEL_81;
                }
                v32 = 16 * v29;
                if ((v31 - 48) > 9)
                {
                  if (v27 != 120)
                    goto LABEL_89;
                  if ((v31 - 97) > 5)
                  {
                    if ((v31 - 65) > 5)
                    {
LABEL_89:
                      v54 = lineNumber((unint64_t *)a1);
                      Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unexpected character %c at line %u while parsing data"), v31, v54, *(_QWORD *)bytes);
                      goto LABEL_81;
                    }
                    v29 = v32 + v31 - 55;
                  }
                  else
                  {
                    v29 = v32 + v31 - 87;
                  }
                }
                else
                {
                  v33 = 10 * v29;
                  if (v27 == 120)
                    v33 = v32;
                  v29 = v31 + v33 - 48;
                }
                *(_DWORD *)v56 = v29;
                if (v30 == ++v28)
                  goto LABEL_72;
              }
              *(_DWORD *)v56 = bswap32(v29);
              v34 = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), v56, 4, 0x18000100u, 0);
              if (v34)
              {
                v35 = v34;
                *(_QWORD *)bytes = 0;
                v59.length = CFStringGetLength(v34);
                v59.location = 0;
                CFStringGetBytes(v35, v59, 0x8000100u, 0, 0, buffer, 6, (CFIndex *)bytes);
                CFDataAppendBytes(Mutable, buffer, *(CFIndex *)bytes);
                CFRelease(v35);
                goto LABEL_82;
              }
              usedBufLene = (CFIndex *)lineNumber((unint64_t *)a1);
              Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unparseable Unicode sequence at line %u while parsing data (input did not result in a real string)"), usedBufLene, v53, *(_QWORD *)bytes);
              goto LABEL_81;
            }
          }
          goto LABEL_72;
        }
        if (v17 != 97)
          goto LABEL_80;
        if (v16 <= 3)
          goto LABEL_72;
        v19 = v14[2];
        if (v19 != 109)
        {
          if (v16 < 5 || v19 != 112 || v14[3] != 111 || v14[4] != 115 || v14[5] != 59)
            goto LABEL_80;
          v25 = 39;
          goto LABEL_79;
        }
        if (v14[3] != 112 || v14[4] != 59)
          goto LABEL_80;
        bytes[0] = 38;
        v20 = 5;
      }
      else if (v17 == 103)
      {
        if (v16 < 3 || v14[2] != 116 || v14[3] != 59)
          goto LABEL_80;
        v18 = 62;
LABEL_47:
        bytes[0] = v18;
        v20 = 4;
      }
      else
      {
        if (v17 != 113)
        {
          if (v17 == 108 && v16 >= 3 && v14[2] == 116 && v14[3] == 59)
          {
            v18 = 60;
            goto LABEL_47;
          }
LABEL_80:
          usedBufLenc = (CFIndex *)lineNumber((unint64_t *)a1);
          Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unknown ampersand-escape sequence at line %u"), usedBufLenc, v53, *(_QWORD *)bytes);
          goto LABEL_81;
        }
        if (v16 < 5 || v14[2] != 117 || v14[3] != 111 || v14[4] != 116 || v14[5] != 59)
          goto LABEL_80;
        v25 = 34;
LABEL_79:
        bytes[0] = v25;
        v20 = 6;
      }
      *(_QWORD *)(a1 + 8) = &v14[v20];
      CFDataAppendBytes(Mutable, bytes, 1);
      goto LABEL_82;
    }
    if (v9 == 60)
    {
      if ((unint64_t)(v6 + 1) >= v8 || v6[1] != 33)
        break;
      if (!Mutable)
      {
        Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
        v6 = *(const UInt8 **)(a1 + 8);
      }
      CFDataAppendBytes(Mutable, v7, v6 - v7);
      v10 = *(_QWORD *)(a1 + 8);
      v11 = *(_QWORD *)(a1 + 16);
      if (v11 - v10 > 8)
      {
        if (*(_QWORD *)v10 != 0x41544144435B213CLL || *(_BYTE *)(v10 + 8) != 91)
        {
          usedBufLena = (CFIndex *)lineNumber((unint64_t *)a1);
          Error = __CFPropertyListCreateError(3840, CFSTR("Encountered improper CDATA opening at line %u"), usedBufLena, v53, *(_QWORD *)bytes);
          goto LABEL_81;
        }
        v21 = (const UInt8 *)(v10 + 9);
        *(_QWORD *)(a1 + 8) = v10 + 9;
        if (v10 + 9 < (unint64_t)(v11 - 2))
        {
          v22 = 0;
          v23 = v11 - v10 - 11;
          while (1)
          {
            v24 = v10 + v22;
            if (*(_BYTE *)(v10 + v22 + 9) == 93 && *(_BYTE *)(v24 + 10) == 93 && *(_BYTE *)(v10 + v22 + 11) == 62)
              break;
            *(_QWORD *)(a1 + 8) = v24 + 10;
            if (v23 == ++v22)
              goto LABEL_42;
          }
          CFDataAppendBytes(Mutable, v21, v22);
          *(_QWORD *)(a1 + 8) += 3;
          goto LABEL_82;
        }
LABEL_42:
        *(_QWORD *)(a1 + 8) = v21;
        usedBufLenb = (CFIndex *)lineNumber((unint64_t *)a1);
        Error = __CFPropertyListCreateError(3840, CFSTR("Could not find end of CDATA started on line %u"), usedBufLenb, v53, *(_QWORD *)bytes);
LABEL_81:
        *(_QWORD *)(a1 + 24) = Error;
LABEL_82:
        v6 = *(const UInt8 **)(a1 + 8);
        v7 = v6;
        goto LABEL_83;
      }
LABEL_72:
      Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unexpected EOF"), usedBufLen, v53, *(_QWORD *)bytes);
      goto LABEL_81;
    }
    *(_QWORD *)(a1 + 8) = ++v6;
LABEL_83:
    if (*(_QWORD *)(a1 + 24))
    {
      if (Mutable)
        CFRelease(Mutable);
      return 0;
    }
  }
  if (!Mutable)
  {
    if (*(_BYTE *)(a1 + 80))
    {
      *a2 = 0;
      return 1;
    }
    if (*(_DWORD *)(a1 + 40) != 2)
    {
      UniqueStringWithUTF8Bytes = (__CFString *)_createUniqueStringWithUTF8Bytes(a1, v7, v6 - v7);
      if (!UniqueStringWithUTF8Bytes)
        goto LABEL_112;
      *a2 = UniqueStringWithUTF8Bytes;
      return 1;
    }
    v41 = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), v7, v6 - v7, 0x8000100u, 0);
    if (!v41)
      goto LABEL_112;
    Mutable = (__CFData *)v41;
    MutableCopy = CFStringCreateMutableCopy(*(CFAllocatorRef *)(a1 + 32), 0, v41);
LABEL_105:
    *a2 = MutableCopy;
LABEL_106:
    CFRelease(Mutable);
    return 1;
  }
  if (*(_BYTE *)(a1 + 80))
  {
    *a2 = 0;
    goto LABEL_106;
  }
  CFDataAppendBytes(Mutable, v7, v6 - v7);
  if (*(_DWORD *)(a1 + 40) != 2)
  {
    BytePtr = CFDataGetBytePtr(Mutable);
    Length = CFDataGetLength(Mutable);
    MutableCopy = (__CFString *)_createUniqueStringWithUTF8Bytes(a1, BytePtr, Length);
    if (!MutableCopy)
      goto LABEL_109;
    goto LABEL_105;
  }
  v36 = *(const __CFAllocator **)(a1 + 32);
  v37 = CFDataGetBytePtr(Mutable);
  v38 = CFDataGetLength(Mutable);
  v39 = CFStringCreateWithBytes(v36, v37, v38, 0x8000100u, 0);
  if (v39)
  {
    v40 = v39;
    *a2 = CFStringCreateMutableCopy(*(CFAllocatorRef *)(a1 + 32), 0, v39);
    CFRelease(v40);
    goto LABEL_106;
  }
LABEL_109:
  CFRelease(Mutable);
LABEL_112:
  v46 = __CFPropertyListCreateError(3840, CFSTR("Unable to convert string to correct encoding"));
  result = 0;
  *(_QWORD *)(a1 + 24) = v46;
  return result;
}

uint64_t __CFBasicHashReplaceValue(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t (*v8)(const CFAllocatorRef, uint64_t);
  const CFAllocatorRef *v9;
  char v10;
  uint64_t (*v11)(const CFAllocatorRef, uint64_t);
  const CFAllocatorRef *v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(const CFAllocatorRef, uint64_t);
  const CFAllocatorRef *v19;
  char v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t (*v26)(const CFAllocatorRef, uint64_t);
  char v27;
  const CFAllocatorRef *v28;

  v4 = a4;
  v7 = result;
  ++*(_WORD *)(result + 16);
  if ((*(_QWORD *)(result + 32) & 2) == 0)
  {
    v8 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(result + 24) >> 39) & 0x1FLL]
                                                                 + 8 * ((*(_QWORD *)(result + 24) >> 34) & 0x1FLL));
    if (v8)
    {
      if (result < 0)
      {
        v9 = &kCFAllocatorSystemDefault;
      }
      else
      {
        v10 = atomic_load((unint64_t *)(result + 8));
        if (v10 < 0)
          v9 = &kCFAllocatorSystemDefault;
        else
          v9 = (const CFAllocatorRef *)(result - 16);
      }
      result = v8(*v9, a4);
      v4 = result;
    }
  }
  if ((*(_WORD *)(v7 + 18) & 4) != 0 && (*(_QWORD *)(v7 + 32) & 2) == 0)
  {
    v11 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(v7 + 27) >> 5) & 0x1F]
                                                                  + 8 * (*(_DWORD *)(v7 + 27) & 0x1FLL));
    if (v11)
    {
      if (v7 < 0)
      {
        v12 = &kCFAllocatorSystemDefault;
      }
      else
      {
        v13 = atomic_load((unint64_t *)(v7 + 8));
        if (v13 < 0)
          v12 = &kCFAllocatorSystemDefault;
        else
          v12 = (const CFAllocatorRef *)(v7 - 16);
      }
      result = v11(*v12, a3);
      a3 = result;
    }
  }
  v14 = *(_QWORD *)(v7 + 40);
  v15 = *(_QWORD *)(v14 + 8 * a2);
  if (v4)
    v16 = v4;
  else
    v16 = 2814029233;
  if (v16 == -1)
    v16 = 2780474809;
  *(_QWORD *)(v14 + 8 * a2) = v16;
  if ((unint64_t)(v15 + 1) >= 2)
  {
    if (v15 == 2814029233)
      v15 = 0;
    if (v15 == 2780474809)
      v17 = -1;
    else
      v17 = v15;
    if ((*(_QWORD *)(v7 + 32) & 2) == 0)
    {
      v18 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                                 + (HIBYTE(*(_QWORD *)(v7 + 24)) & 0xF8))
                                                                    + 8 * ((*(_QWORD *)(v7 + 24) >> 54) & 0x1FLL));
      if (v18)
      {
        if (v7 < 0)
        {
          v19 = &kCFAllocatorSystemDefault;
        }
        else
        {
          v20 = atomic_load((unint64_t *)(v7 + 8));
          if (v20 < 0)
            v19 = &kCFAllocatorSystemDefault;
          else
            v19 = (const CFAllocatorRef *)(v7 - 16);
        }
        result = v18(*v19, v17);
      }
    }
  }
  v21 = *(unsigned __int16 *)(v7 + 18);
  if ((v21 & 4) != 0)
  {
    v22 = *(_QWORD *)(v7 + 8 * ((v21 >> 2) & 1) + 40);
    v23 = *(_QWORD *)(v22 + 8 * a2);
    if (a3)
      v24 = a3;
    else
      v24 = 2814029233;
    if (v24 == -1)
      v24 = 2780474809;
    *(_QWORD *)(v22 + 8 * a2) = v24;
    if ((unint64_t)(v23 + 1) >= 2)
    {
      if (v23 == 2814029233)
        v23 = 0;
      if (v23 == 2780474809)
        v25 = -1;
      else
        v25 = v23;
      if ((*(_QWORD *)(v7 + 32) & 2) == 0)
      {
        v26 = *(uint64_t (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(v7 + 24) >> 49) & 0x1FLL]
                                                                      + 8 * ((*(_QWORD *)(v7 + 24) >> 44) & 0x1FLL));
        if (v26)
        {
          if (v7 < 0 || (v27 = atomic_load((unint64_t *)(v7 + 8)), v27 < 0))
            v28 = &kCFAllocatorSystemDefault;
          else
            v28 = (const CFAllocatorRef *)(v7 - 16);
          return v26(*v28, v25);
        }
      }
    }
  }
  return result;
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  __CFString *v3;
  CFMutableStringRef Mutable;
  CFStringRef Copy;
  CFIndex Length;
  int v10;
  _BOOL4 v11;
  unsigned int v12;
  uint64_t v13;
  char v14;
  char v15;
  uint64_t v16;
  UniChar **p_data;
  UniChar *v18;
  UniChar *v19;
  uint64_t v20;
  CFStringEncoding v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD v24[3];
  CFRange v25;
  CFRange v26;

  v3 = (__CFString *)theString;
  v24[2] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    return (CFMutableStringRef)-[__CFString mutableCopy](v3, "mutableCopy");
  Mutable = CFStringCreateMutable(alloc, maxLength);
  if (Mutable == v3)
  {
    Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3);
    v3 = (__CFString *)Copy;
  }
  else
  {
    Copy = 0;
  }
  Length = CFStringGetLength(v3);
  if (Length < 1)
  {
    v11 = 0;
  }
  else
  {
    if (CF_IS_OBJC(7uLL, (__objc2_class **)v3))
    {
      v10 = -[__CFString _encodingCantBeStoredInEightBitCFString](v3, "_encodingCantBeStoredInEightBitCFString");
    }
    else
    {
      v12 = atomic_load((unint64_t *)&v3->info);
      v10 = (v12 >> 4) & 1;
    }
    v11 = v10 != 0;
  }
  v24[0] = 0;
  v24[1] = 0;
  v13 = __CFStringChangeSizeMultiple((uint64_t)Mutable, (uint64_t)v24, 1, Length, v11);
  v14 = atomic_load((unint64_t *)&Mutable->info);
  v15 = atomic_load((unint64_t *)&Mutable->info);
  v16 = v15 & 0x60;
  p_data = (UniChar **)&Mutable->data;
  if ((v14 & 0x10) == 0)
  {
    if (v16)
    {
      v18 = *p_data;
    }
    else
    {
      v20 = atomic_load((unint64_t *)&Mutable->info);
      v18 = (UniChar *)&p_data[(v20 & 5) != 4];
    }
    v21 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(v13);
      v21 = __CFDefaultEightBitStringEncoding;
    }
    v22 = atomic_load((unint64_t *)&Mutable->info);
    v25.location = 0;
    v25.length = Length;
    CFStringGetBytes(v3, v25, v21, 0, 0, (UInt8 *)v18 + ((v22 >> 2) & 1), Length, 0);
    goto LABEL_24;
  }
  if (v16)
  {
    v19 = *p_data;
    if (!*p_data)
      goto LABEL_24;
    goto LABEL_23;
  }
  v23 = atomic_load((unint64_t *)&Mutable->info);
  v19 = (UniChar *)&p_data[(v23 & 5) != 4];
  if (v19)
  {
LABEL_23:
    v26.location = 0;
    v26.length = Length;
    CFStringGetCharacters(v3, v26, v19);
  }
LABEL_24:
  if (Copy)
    CFRelease(Copy);
  return Mutable;
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)__CFDataInit((__objc2_class **)allocator, 0, length, bytes, length, 0);
}

void _CFDictionarySetCapacity(__objc2_class **a1, uint64_t a2)
{
  if (!CF_IS_OBJC(0x12uLL, a1))
    CFBasicHashSetCapacity((uint64_t)a1, a2);
}

CFTypeRef _CFStringCreateWithBytesNoCopyDisallowROM(__objc2_class **a1, int8x16_t *a2, int64_t a3, uint64_t a4, int a5, const __CFAllocator *a6)
{
  return __CFStringCreateImmutableFunnel3(a1, a2, a3, a4, (a5 != 0) | 0x22u, a6, 0);
}

void __CFPropertyListCreateSplitKeypaths(const __CFAllocator *a1, CFSetRef theSet, __CFSet **a3, __CFSet **a4)
{
  __CFSet **v4;
  __CFSet **v5;
  unint64_t Count;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  const void **v13;
  size_t v14;
  __CFSet *Mutable;
  __CFSet *v16;
  const void **Typed;
  uint64_t v18;
  const __CFArray *v19;
  CFIndex v20;
  unint64_t v21;
  unint64_t v22;
  const void *ValueAtIndex;
  CFMutableSetRef v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  char *v28;
  size_t v29;
  size_t v30;
  CFIndex v31;
  CFArrayRef v32;
  __CFSet **v33;
  __CFSet **v34;
  __CFSet ***v35;
  CFAllocatorRef v36;
  CFAllocatorRef v37;
  uint64_t v38;
  CFRange v39;

  v4 = a4;
  v5 = a3;
  v37 = a1;
  v38 = *MEMORY[0x1E0C80C00];
  if (!theSet)
  {
    *a3 = 0;
    *a4 = 0;
    return;
  }
  Count = CFSetGetCount(theSet);
  if (Count >> 60)
    __CFPropertyListCreateSplitKeypaths_cold_1();
  v9 = Count;
  if (Count <= 1)
    v10 = 1;
  else
    v10 = Count;
  MEMORY[0x1E0C80A78](Count, v8);
  v13 = (const void **)((char *)&v33 - v12);
  if (v11 >= 0x200)
    v14 = 512;
  else
    v14 = v11;
  bzero((char *)&v33 - v12, v14);
  v35 = &v33;
  if (v9 >= 0x101)
  {
    Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v10, 0xC0040B8AA526DLL, 0);
    if (!Typed)
      __CFPropertyListCreateSplitKeypaths_cold_4();
    v13 = Typed;
    CFSetGetValues(theSet, Typed);
    goto LABEL_15;
  }
  bzero(v13, 8 * v10);
  CFSetGetValues(theSet, v13);
  if (v9)
  {
LABEL_15:
    v33 = v5;
    v34 = v4;
    Mutable = 0;
    v16 = 0;
    v18 = 0;
    v36 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    do
    {
      v19 = (const __CFArray *)v13[v18];
      v20 = CFArrayGetCount(v19);
      v21 = v20 - 1;
      if (v20 >= 1)
      {
        v22 = v20;
        if (!Mutable)
          Mutable = CFSetCreateMutable(v37, 0, &kCFTypeSetCallBacks);
        ValueAtIndex = CFArrayGetValueAtIndex(v19, 0);
        CFSetAddValue(Mutable, ValueAtIndex);
        if (v22 >= 2)
        {
          if (!v16)
          {
            v24 = CFSetCreateMutable(v37, 0, &kCFTypeSetCallBacks);
            v16 = v24;
          }
          if (v21 >> 60)
            __CFPropertyListCreateSplitKeypaths_cold_2();
          MEMORY[0x1E0C80A78](v24, v25);
          v28 = (char *)&v33 - v27;
          if (v26 >= 0x200)
            v29 = 512;
          else
            v29 = v26;
          bzero((char *)&v33 - v27, v29);
          v30 = 8 * v21;
          if (v22 > 0x101)
          {
            v28 = (char *)CFAllocatorAllocateTyped(v36, v30, 0xC0040B8AA526DLL, 0);
            if (!v28)
              __CFPropertyListCreateSplitKeypaths_cold_3();
          }
          else
          {
            bzero(v28, v30);
          }
          v39.length = CFArrayGetCount(v19) - 1;
          v39.location = 1;
          CFArrayGetValues(v19, v39, (const void **)v28);
          v31 = CFArrayGetCount(v19);
          v32 = CFArrayCreate(v37, (const void **)v28, v31 - 1, &kCFTypeArrayCallBacks);
          CFSetAddValue(v16, v32);
          if (v32)
            CFRelease(v32);
          if (v22 >= 0x102)
            CFAllocatorDeallocate(v36, v28);
        }
      }
      ++v18;
    }
    while (v9 != v18);
    v5 = v33;
    v4 = v34;
    if (v9 >= 0x101)
      CFAllocatorDeallocate(v36, v13);
    goto LABEL_36;
  }
  Mutable = 0;
  v16 = 0;
LABEL_36:
  *v5 = Mutable;
  *v4 = v16;
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  objc_class **Generic;
  __CFSet *v4;

  Generic = (objc_class **)__CFSetCreateGeneric((__objc2_class **)allocator, (uint64_t)callBacks);
  v4 = (__CFSet *)Generic;
  if (Generic)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Generic, 0x11uLL);
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
  }
  return v4;
}

uint64_t __CFSetCreateGeneric(__objc2_class **a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  __int128 v4;
  uint64_t v5;
  uint64_t v7[5];
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v2 = *(_QWORD *)(a2 + 8);
    v3 = *(_QWORD *)(a2 + 16);
    v4 = *(_OWORD *)(a2 + 32);
    v5 = *(_QWORD *)(a2 + 24);
  }
  else
  {
    v2 = 0;
    v3 = 0;
    v5 = 0;
    v4 = 0uLL;
  }
  v8 = v4;
  v10 = v5;
  v11 = v5;
  v7[0] = v2;
  v7[1] = v2;
  v7[2] = v3;
  v7[3] = v3;
  v7[4] = v4;
  v9 = 0;
  return CFBasicHashCreate(a1, 0x2000u, v7);
}

uint64_t __CFDictionaryCreateTransfer(__objc2_class **a1, unint64_t *a2, unint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t *v5;
  unint64_t *v6;
  uint64_t Transfer;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v17[11];

  v4 = a4;
  v5 = (uint64_t *)a3;
  v6 = a2;
  v17[10] = *MEMORY[0x1E0C80C00];
  Transfer = (uint64_t)__NSCFDictionaryCreateTransfer(a1, a2, a3, a4);
  if (Transfer)
    return Transfer;
  v17[6] = (uint64_t)CFHash;
  v17[7] = 0;
  v17[0] = (uint64_t)__CFTypeCollectionRetain;
  v17[1] = (uint64_t)__CFTypeCollectionRetain;
  v17[2] = (uint64_t)__CFTypeCollectionRelease;
  v17[3] = (uint64_t)__CFTypeCollectionRelease;
  v17[4] = (uint64_t)CFEqual;
  v17[5] = (uint64_t)CFEqual;
  v17[8] = (uint64_t)CFCopyDescription;
  v17[9] = (uint64_t)CFCopyDescription;
  Transfer = CFBasicHashCreate(a1, 0x2001u, v17);
  CFBasicHashSuppressRC(Transfer);
  if (v4 >= 1)
  {
    CFBasicHashSetCapacity(Transfer, v4);
    do
    {
      v10 = *v6++;
      v9 = v10;
      v11 = *v5++;
      CFBasicHashAddValue(Transfer, v9, v11);
      --v4;
    }
    while (v4);
  }
  CFBasicHashUnsuppressRC(Transfer);
  v12 = (unint64_t *)(Transfer + 8);
  v13 = atomic_load((unint64_t *)(Transfer + 8));
  do
  {
    v14 = __ldaxr(v12);
    if (v14 == v13)
    {
      if (!__stlxr(v13 | 0x40, v12))
      {
        v15 = 1;
        goto LABEL_11;
      }
    }
    else
    {
      __clrex();
    }
    v15 = 0;
LABEL_11:
    v13 = v14;
  }
  while (!v15);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)Transfer, 0x12uLL);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  return Transfer;
}

__objc2_class **__NSCFDictionaryCreateTransfer(__objc2_class **a1, unint64_t *a2, unint64_t *a3, unint64_t a4)
{
  if (__FoundationPresent_static_init_0 != -1)
    dispatch_once(&__FoundationPresent_static_init_0, &__block_literal_global_45);
  if (!__FoundationPresent_present_0
    || &__kCFAllocatorSystemDefault != a1
    && (a1 || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    return 0;
  }
  if (a4 == 1)
    return (__objc2_class **)__NSSingleEntryDictionaryI_new(*a2, *a3, 12);
  if (a4)
    return (__objc2_class **)__NSDictionaryI_new((uint64_t *)a2, (uint64_t *)a3, 0, a4, 12);
  return &__NSDictionary0__struct;
}

uint64_t __CFBinaryPlistParseUnicode16String(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  unsigned __int8 *v4;
  char v5;
  unint64_t v6;
  unsigned __int8 *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;

  if (a3 == (_BYTE *)-1)
    return 0;
  v5 = *a3;
  v4 = a3 + 1;
  v6 = v5 & 0xF;
  if ((_DWORD)v6 == 15)
  {
    if (a1 + a2 >= (unint64_t)v4)
    {
      v7 = v4 + 1;
      if ((*v4 & 0xF0) == 0x10)
      {
        v8 = *v4 & 0xF;
        v9 = 1 << v8;
        if (!__CFADD__(1 << v8, v7) && (unint64_t)&v4[v9] <= a1 + a2)
        {
          switch((1 << v8))
          {
            case 1u:
              v6 = *v7;
              goto LABEL_20;
            case 2u:
              v6 = __rev16(*(unsigned __int16 *)(v4 + 1));
              goto LABEL_20;
            case 4u:
              v6 = bswap32(*(_DWORD *)(v4 + 1));
              goto LABEL_20;
            case 8u:
              v6 = bswap64(*(_QWORD *)(v4 + 1));
              goto LABEL_19;
            default:
              if (v8 > 7)
              {
                v6 = 0;
LABEL_20:
                v4 = &v7[v9];
                goto LABEL_21;
              }
              v6 = 0;
              if ((v9 & 0xFE) != 0)
                v10 = v9;
              else
                v10 = 1;
              v11 = v4 + 1;
              do
              {
                v12 = *v11++;
                v6 = v12 | (v6 << 8);
                --v10;
              }
              while (v10);
LABEL_19:
              if ((v6 & 0x8000000000000000) == 0)
                goto LABEL_20;
              break;
          }
        }
      }
    }
    return 0;
  }
LABEL_21:
  v13 = (unint64_t)&v4[v6 - 1];
  v15 = ~v6 >= v13;
  v14 = v6 + v13;
  v15 = v15 && ~v6 >= (unint64_t)v4;
  if (!v15 || a1 + a2 < v14)
    return 0;
  return (*(uint64_t (**)(uint64_t, unsigned __int8 *, unint64_t))(a4 + 16))(a4, v4, v6);
}

unint64_t *__CFArrayCreateTransfer(__objc2_class **a1, const void *a2, unint64_t a3)
{
  size_t v5;
  unint64_t *Instance;
  unint64_t *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  char v12;
  int v13;
  char v14;
  BOOL v15;
  uint64_t v16;
  unint64_t *v17;

  v5 = 8 * a3;
  Instance = (unint64_t *)_CFRuntimeCreateInstance(a1, 0x13uLL, (8 * a3 + 32), 0);
  v7 = Instance;
  if (!Instance)
    return v7;
  v8 = Instance + 1;
  v9 = atomic_load(Instance + 1);
  do
  {
    v10 = __ldaxr(v8);
    if (v10 == v9)
    {
      if (!__stlxr(v9 & 0xFFFFFFFFFFFFFF80 | 4, v8))
      {
        v11 = 1;
        goto LABEL_8;
      }
    }
    else
    {
      __clrex();
    }
    v11 = 0;
LABEL_8:
    v9 = v10;
  }
  while (!v11);
  Instance[2] = a3;
  v12 = atomic_load(Instance + 1);
  v13 = v12 & 3;
  if (v13 == 2)
  {
    v17 = (unint64_t *)(Instance[5] + 8 * *(_QWORD *)Instance[5] + 16);
  }
  else if (v13)
  {
    v17 = 0;
  }
  else
  {
    v14 = atomic_load(Instance + 1);
    v15 = (~v14 & 0xC) == 0;
    v16 = 6;
    if (v15)
      v16 = 11;
    v17 = &Instance[v16];
  }
  memmove(v17, a2, v5);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  return v7;
}

uint64_t CFBasicHashUnsuppressRC(uint64_t result)
{
  *(_QWORD *)(result + 32) &= ~2uLL;
  return result;
}

uint64_t CFBasicHashSuppressRC(uint64_t result)
{
  *(_QWORD *)(result + 32) |= 2uLL;
  return result;
}

unint64_t *skipXMLComment(unint64_t *result)
{
  unint64_t *v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v1 = result;
  v3 = result[1];
  v2 = result[2];
  if (v3 >= v2 - 3)
  {
LABEL_7:
    v6 = lineNumber(result);
    result = (unint64_t *)__CFPropertyListCreateError(3840, CFSTR("Unterminated comment started on line %u"), v6);
    v1[3] = (unint64_t)result;
  }
  else
  {
    v4 = v2 - v3 - 3;
    v5 = v3 + 3;
    while (*(_BYTE *)(v5 - 3) != 45 || *(_BYTE *)(v5 - 2) != 45 || *(_BYTE *)(v5 - 1) != 62)
    {
      ++v5;
      if (!--v4)
        goto LABEL_7;
    }
    result[1] = v5;
  }
  return result;
}

void sub_182AB7DD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  free(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_182AB8884(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

uint64_t _NSIsNSSet(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*MethodImplementation)(uint64_t, char *);

  if (a1)
  {
    v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
      return MethodImplementation(v1, sel_isNSSet__);
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }
  return a1 & 1;
}

void __rehashs(uint64_t a1, int a2)
{
  unsigned __int8 v2;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  void *v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;

  v2 = a2;
  v4 = __NSSetSizes_0[2 * a2];
  v5 = malloc_type_calloc(1uLL, 8 * v4, 0x69585060uLL);
  v6 = *(unsigned int *)(a1 + 28);
  v7 = *(_QWORD **)(a1 + 16);
  if (v6 >> 26)
  {
    v8 = 0;
    v9 = *(unsigned int *)((char *)__NSSetSizes_0 + ((v6 >> 23) & 0x1F8));
    if (v9 <= 1)
      v10 = 1;
    else
      v10 = v9;
    do
    {
      v11 = (void *)v7[v8];
      if (v11)
        v12 = v11 == &___NSSetM_DeletedMarker;
      else
        v12 = 1;
      if (!v12)
      {
        v13 = objc_msgSend((id)v7[v8], "hash") % v4;
        do
        {
          v14 = v13;
          v15 = v5[v13];
          v16 = v13 + 1;
          if (v16 >= v4)
            v17 = v4;
          else
            v17 = 0;
          v13 = v16 - v17;
        }
        while (v15);
        v5[v14] = v11;
      }
      ++v8;
    }
    while (v8 != v10);
  }
  free(v7);
  *(_QWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 28) & 0x3FFFFFF | (v2 << 26);
}

void sub_182ABAF44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void CFBagRemoveValue(CFMutableBagRef theBag, const void *value)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v10;

  v10 = atomic_load((unint64_t *)theBag + 1);
  if ((v10 & 0x40) != 0)
    CFLog(3, (uint64_t)CFSTR("%s(): immutable collection %p given to mutating function"), v2, v3, v4, v5, v6, v7, (__int16)"void CFBagRemoveValue(CFMutableBagRef, const void *)");
  CFBasicHashRemoveValue((uint64_t)theBag, (unint64_t)value);
}

unint64_t *_NSSetI_mutableCopyWithZone(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  unint64_t *v10;
  size_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = a1[1];
  v4 = v3 & 0x3FFFFFFFFFFFFFFLL;
  if ((v3 & 0x3FFFFFFFFFFFFFELL) != 0)
    v5 = v3 & 0x3FFFFFFFFFFFFFFLL;
  else
    v5 = 1;
  v6 = MEMORY[0x1E0C80A78](v5, a2);
  v8 = (char *)&v12 - v7;
  v12 = 0;
  if (v4 >= 0x101)
  {
    v8 = (char *)_CFCreateArrayStorage(v6, 0, &v12);
    v9 = v8;
  }
  else
  {
    v9 = 0;
  }
  objc_msgSend(a1, "getObjects:count:", v8, v4, v12, v13);
  v10 = __NSSetM_new((uint64_t)v8, v4, 0);
  free(v9);
  return v10;
}

void sub_182ABB468(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void _CFBundleSetupXPCBootstrap(void *a1)
{
  CFBundleRef MainBundle;
  const __CFArray *v3;
  const __CFArray *v4;

  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    v3 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle((uint64_t)MainBundle);
    if (v3)
    {
      v4 = v3;
      _CFBundleSetupXPCBootstrapWithLanguages(a1, v3);
      CFRelease(v4);
    }
  }
}

void _CFBundleSetupXPCBootstrapWithLanguages(void *a1, const __CFArray *a2)
{
  xpc_object_t v4;
  CFIndex v5;
  const __CFString *ValueAtIndex;
  xpc_object_t v7;
  void *v8;
  xpc_object_t v9;
  char buffer[128];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v4 = xpc_array_create(0, 0);
  if (CFArrayGetCount(a2) >= 1)
  {
    v5 = 0;
    do
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v5);
      if (CFStringGetCString(ValueAtIndex, buffer, 128, 0x8000100u))
      {
        v7 = xpc_string_create(buffer);
        if (v7)
        {
          v8 = v7;
          xpc_array_append_value(v4, v7);
          xpc_release(v8);
        }
      }
      ++v5;
    }
    while (v5 < CFArrayGetCount(a2));
  }
  if (xpc_array_get_count(v4))
  {
    v9 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_value(v9, "MainBundleLanguages", v4);
    xpc_dictionary_set_value(a1, "_NSBundleEntry", v9);
    xpc_release(v9);
  }
  xpc_release(v4);
}

uint64_t CFBundleGetLocalizationInfoForLocalization(CFStringRef localeIdentifier, unsigned int *a2, unsigned int *a3, _DWORD *a4, _DWORD *a5)
{
  const __CFString *ValueAtIndex;
  uint64_t result;
  unsigned int LanguageCodeForLocalization;
  unsigned int RegionCodeForLocalization;
  int v13;
  int v14;
  CFBundleRef MainBundle;
  CFTypeRef v16;
  _BOOL4 v17;
  int v18;
  __int16 v19;
  __int16 v20;
  __int16 v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;

  ValueAtIndex = localeIdentifier;
  v24 = *MEMORY[0x1E0C80C00];
  v22 = -1;
  v23 = -1;
  if (localeIdentifier)
    goto LABEL_2;
  MainBundle = CFBundleGetMainBundle();
  if (!MainBundle || (v16 = _CFBundleCopyLanguageSearchListInBundle((uint64_t)MainBundle)) == 0)
  {
    v16 = _CFBundleCopyUserLanguages();
    if (!v16)
    {
LABEL_13:
      _CFBundleGetLanguageAndRegionCodes(&v23, &v22);
      RegionCodeForLocalization = v22;
      LanguageCodeForLocalization = v23;
      goto LABEL_14;
    }
  }
  if (CFArrayGetCount((CFArrayRef)v16) <= 0)
  {
    CFRelease(v16);
    goto LABEL_13;
  }
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v16, 0);
  CFRelease(v16);
  if (!ValueAtIndex)
    goto LABEL_13;
LABEL_2:
  v21 = -1;
  v20 = -1;
  v19 = 0;
  v18 = 0;
  result = CFLocaleGetLanguageRegionEncodingForLocaleIdentifier(ValueAtIndex, &v21, &v20, &v19, &v18);
  if ((_DWORD)result)
  {
    LanguageCodeForLocalization = v21;
    RegionCodeForLocalization = v20;
    v13 = v19;
    v14 = v18;
    if (!a2)
      goto LABEL_28;
LABEL_27:
    *a2 = LanguageCodeForLocalization;
    goto LABEL_28;
  }
  LanguageCodeForLocalization = _CFBundleGetLanguageCodeForLocalization(ValueAtIndex);
  v23 = LanguageCodeForLocalization;
  RegionCodeForLocalization = _CFBundleGetRegionCodeForLocalization(ValueAtIndex);
  v22 = RegionCodeForLocalization;
LABEL_14:
  if (LanguageCodeForLocalization < 0x99 || RegionCodeForLocalization == -1)
  {
    v17 = LanguageCodeForLocalization != -1;
    if (RegionCodeForLocalization == -1 && LanguageCodeForLocalization != -1)
    {
      RegionCodeForLocalization = _CFBundleGetRegionCodeForLanguageCode(LanguageCodeForLocalization);
      v17 = 1;
    }
  }
  else
  {
    LanguageCodeForLocalization = _CFBundleGetLanguageCodeForRegionCode(RegionCodeForLocalization);
    v17 = LanguageCodeForLocalization != -1;
  }
  if (LanguageCodeForLocalization > 0x97)
  {
    v13 = 0;
    v14 = 0;
  }
  else
  {
    v13 = __CFBundleScriptCodesArray[LanguageCodeForLocalization];
    v14 = __CFBundleStringEncodingsArray[LanguageCodeForLocalization];
  }
  result = RegionCodeForLocalization != -1 || v17;
  if (a2)
    goto LABEL_27;
LABEL_28:
  if (a3)
    *a3 = RegionCodeForLocalization;
  if (a4)
    *a4 = v13;
  if (a5)
    *a5 = v14;
  return result;
}

void _CFBundleGetLanguageAndRegionCodes(unsigned int *a1, unsigned int *a2)
{
  CFBundleRef MainBundle;
  const __CFArray *v5;
  const __CFString *ValueAtIndex;
  unsigned int LanguageCodeForLocalization;
  unsigned int RegionCodeForLocalization;
  __int16 v9;
  __int16 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle && (v5 = (const __CFArray *)_CFBundleCopyLanguageSearchListInBundle((uint64_t)MainBundle)) != 0
    || (v5 = (const __CFArray *)_CFBundleCopyUserLanguages()) != 0)
  {
    if (CFArrayGetCount(v5) < 1)
    {
      RegionCodeForLocalization = 0;
      LanguageCodeForLocalization = 0;
    }
    else
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, 0);
      v10 = -1;
      v9 = -1;
      if (CFLocaleGetLanguageRegionEncodingForLocaleIdentifier(ValueAtIndex, &v10, &v9, 0, 0))
      {
        LanguageCodeForLocalization = v10;
        RegionCodeForLocalization = v9;
      }
      else
      {
        LanguageCodeForLocalization = _CFBundleGetLanguageCodeForLocalization(ValueAtIndex);
        RegionCodeForLocalization = _CFBundleGetRegionCodeForLocalization(ValueAtIndex);
      }
      if (LanguageCodeForLocalization != -1 || RegionCodeForLocalization == -1)
      {
        if (LanguageCodeForLocalization != -1 && RegionCodeForLocalization == -1)
          RegionCodeForLocalization = _CFBundleGetRegionCodeForLanguageCode(LanguageCodeForLocalization);
      }
      else
      {
        LanguageCodeForLocalization = _CFBundleGetLanguageCodeForRegionCode(RegionCodeForLocalization);
      }
    }
    CFRelease(v5);
    if (a1)
      goto LABEL_18;
  }
  else
  {
    RegionCodeForLocalization = 0;
    LanguageCodeForLocalization = 0;
    if (a1)
LABEL_18:
      *a1 = LanguageCodeForLocalization;
  }
  if (a2)
    *a2 = RegionCodeForLocalization;
}

uint64_t CFLocaleGetLanguageRegionEncodingForLocaleIdentifier(CFStringRef localeIdentifier, _WORD *a2, _WORD *a3, _WORD *a4, _DWORD *a5)
{
  const __CFString *CanonicalLocaleIdentifierFromString;
  const __CFString *v10;
  int Language;
  uint64_t v12;
  int v13;
  int Script;
  BOOL v15;
  void *v16;
  int v17;
  BOOL v18;
  int v19;
  _QWORD __key[2];
  int v22;
  char v23[158];
  char __s[170];
  char buffer[257];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  CanonicalLocaleIdentifierFromString = CFLocaleCreateCanonicalLocaleIdentifierFromString(0, localeIdentifier);
  if (CanonicalLocaleIdentifierFromString)
  {
    v10 = CanonicalLocaleIdentifierFromString;
    if (!CFStringGetCString(CanonicalLocaleIdentifierFromString, buffer, 257, 0x600u))
    {
LABEL_27:
      v12 = 0;
      goto LABEL_28;
    }
    v22 = 0;
    Language = uloc_getLanguage();
    v12 = 0;
    v13 = Language;
    if (Language < 1)
    {
LABEL_28:
      CFRelease(v10);
      return v12;
    }
    __s[Language] = 0;
    __key[0] = __s;
    __key[1] = 0;
    v22 = 0;
    Script = uloc_getScript();
    v15 = Script != 0;
    if (!Script)
    {
      v22 = 0;
      Script = uloc_getCountry();
      if (!Script)
      {
        v22 = 0;
        Script = uloc_getVariant();
      }
    }
    if (Script >= 1)
    {
      v23[Script] = 0;
      __strlcat_chk();
      __strlcat_chk();
    }
    v16 = bsearch(__key, &localeToLegacyCodes, 0xA3uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))CompareLocaleToLegacyCodesEntries);
    if (!v16)
    {
      if (a5)
        v18 = v15;
      else
        v18 = 0;
      v19 = strlen(__s);
      v12 = 0;
      if (v18 || v13 >= v19)
        goto LABEL_28;
      __s[v13] = 0;
      v16 = bsearch(__key, &localeToLegacyCodes, 0xA3uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))CompareLocaleToLegacyCodesEntries);
      if (!v16)
        goto LABEL_27;
    }
    if (a2)
      *a2 = *((_WORD *)v16 + 5);
    if (a3)
      *a3 = *((_WORD *)v16 + 4);
    if (a5)
      *a5 = *((_DWORD *)v16 + 3);
    if (!a4)
    {
LABEL_19:
      v12 = 1;
      goto LABEL_28;
    }
    v17 = *((_DWORD *)v16 + 3);
    if (v17 <= 0x20)
    {
LABEL_18:
      *a4 = v17;
      goto LABEL_19;
    }
    if (v17 > 235)
    {
      if (v17 == 236)
      {
        LOWORD(v17) = 28;
        goto LABEL_18;
      }
      if (v17 == 252)
      {
        LOWORD(v17) = 32;
        goto LABEL_18;
      }
    }
    else
    {
      if (v17 == 140)
      {
        LOWORD(v17) = 4;
        goto LABEL_18;
      }
      if (v17 == 152)
      {
        LOWORD(v17) = 7;
        goto LABEL_18;
      }
    }
    LOWORD(v17) = 0;
    goto LABEL_18;
  }
  return 0;
}

CFURLRef CFURLCreateFileReferenceURL(CFAllocatorRef allocator, CFURLRef url, CFErrorRef *error)
{
  __objc2_class **v5;
  CFStringEncoding *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFString *v13;
  CFStringRef v14;
  CFStringRef v15;
  CFIndex location;
  CFIndex Length;
  _BOOL4 v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFURL *v22;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  __int16 v27;
  char v28;
  CFRange result;
  uint64_t v30;
  CFRange v31;

  v30 = *MEMORY[0x1E0C80C00];
  if (url)
  {
    v5 = (__objc2_class **)CFURLCopyAbsoluteURL(url);
    if (v5)
    {
      v6 = (CFStringEncoding *)v5;
      v28 = 0;
      if (_CFURLHasFileURLScheme(v5, &v28))
      {
        v13 = CFURLCopyPath((CFURLRef)v6);
        v14 = CFURLCopyNetLocation((CFURLRef)v6);
        v15 = CFURLCopyResourceSpecifier((CFURLRef)v6);
        if (v13)
        {
          if (CFStringHasPrefix(v13, CFSTR("/.file/id=")))
          {
            result.location = 0;
            result.length = 0;
            v31.length = CFStringGetLength(v13) - 10;
            v31.location = 10;
            if (!CFStringFindWithOptions(v13, CFSTR("/"), v31, 0, &result))
              goto LABEL_10;
            location = result.location;
            if (location == CFStringGetLength(v13) - 1)
              goto LABEL_10;
          }
          CFRelease(v13);
        }
        v13 = _CFURLCopyFileReferenceURLPath(v6, error);
        if (!v13)
        {
          v22 = 0;
          if (!v14)
          {
LABEL_32:
            if (v15)
              CFRelease(v15);
            goto LABEL_34;
          }
LABEL_31:
          CFRelease(v14);
          goto LABEL_32;
        }
LABEL_10:
        Length = CFStringGetLength(v13);
        v18 = CFStringGetCharacterAtIndex(v13, Length - 1) == 47;
        v19 = v15;
        if (!v15)
        {
          if (!v14 || CFEqual(v14, CFSTR("localhost")))
          {
            v23 = URLPathToPOSIXPath(v13, allocator, v6[5], 1);
            if (!v23)
            {
              v22 = 0;
LABEL_30:
              CFRelease(v13);
              if (!v14)
                goto LABEL_32;
              goto LABEL_31;
            }
            v24 = v23;
            v22 = (const __CFURL *)_CFURLCreateWithFileSystemPath((__objc2_class **)allocator, v23, 0, v18, 0);
            v25 = v24;
LABEL_29:
            CFRelease(v25);
            goto LABEL_30;
          }
          v19 = &stru_1E1337B18;
        }
        v20 = &stru_1E1337B18;
        if (v14)
          v20 = v14;
        v21 = CFStringCreateWithFormat(allocator, 0, CFSTR("file://%@%@%@"), v20, v13, v19);
        if (v21)
          v22 = (const __CFURL *)_CFURLCreateWithURLString((__objc2_class **)allocator, v21, 1, 0);
        else
          v22 = 0;
        v25 = v21;
        goto LABEL_29;
      }
      if (v28)
      {
        if (error)
        {
LABEL_18:
          v22 = 0;
          *error = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 262, 0);
LABEL_34:
          CFRelease(v6);
          return v22;
        }
      }
      else
      {
        CFLog(4, (uint64_t)CFSTR("CFURLCreateFileReferenceURL failed because it was passed a URL which has no scheme"), v7, v8, v9, v10, v11, v12, v27);
        if (error)
          goto LABEL_18;
      }
      v22 = 0;
      goto LABEL_34;
    }
  }
  return 0;
}

CFURLRef CFURLCreateFilePathURL(CFAllocatorRef allocator, CFURLRef url, CFErrorRef *error)
{
  CFURLRef v6;
  const __CFAllocator *v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  unint64_t Length;
  CFIndex MaximumSizeForEncoding;
  CFIndex v13;
  char *v14;
  const __CFURL *v15;
  const __CFAllocator *v16;
  size_t v17;
  const __CFString *StringFromFileSystemRepresentationByAddingPercentEscapes;
  CFIndex v19;
  CFIndex v20;
  CFIndex v21;
  UniChar *v22;
  CFIndex v23;
  CFIndex v24;
  CFIndex v25;
  UniChar *v26;
  CFIndex v27;
  CFIndex v28;
  CFIndex v29;
  UniChar *v30;
  CFIndex v31;
  CFIndex v32;
  CFIndex v33;
  CFIndex v34;
  const __CFString *v35;
  CFIndex v37;
  UniChar *v38;
  char v39;
  char buffer[16];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  CFIndex v72;
  CFMutableStringRef Mutable;
  uint64_t v74;
  CFRange v75;
  CFRange v76;
  CFRange v77;
  CFRange v78;

  v74 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!_CFURLHasFileURLScheme((__objc2_class **)url, &v39))
  {
    if (v39)
    {
      if (error)
      {
LABEL_11:
        v15 = 0;
        *error = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 262, 0);
        return v15;
      }
    }
    else
    {
      CFLog(4, CFSTR("CFURLCreateFilePathURL failed because it was passed a URL which has no scheme"));
      if (error)
        goto LABEL_11;
    }
    return 0;
  }
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
  {
    if (-[__CFURL baseURL](url, "baseURL"))
      goto LABEL_4;
  }
  else if (*((_QWORD *)url + 4))
  {
LABEL_4:
    v6 = CFURLCopyAbsoluteURL(url);
    v7 = CFGetAllocator(v6);
    v8 = CFURLCreateStringWithFileSystemPath(v7, (__objc2_class **)v6, 0, 0);
    v9 = CFURLCopyNetLocation(v6);
    v10 = CFURLCopyResourceSpecifier(v6);
    CFRelease(v6);
    if (v8)
      goto LABEL_5;
    goto LABEL_14;
  }
  v16 = CFGetAllocator(url);
  v8 = CFURLCreateStringWithFileSystemPath(v16, (__objc2_class **)url, 0, 0);
  v9 = CFURLCopyNetLocation(url);
  v10 = CFURLCopyResourceSpecifier(url);
  if (v8)
  {
LABEL_5:
    Length = CFStringGetLength(v8);
    if (Length <= 1)
      Length = 1;
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    v13 = MaximumSizeForEncoding + 1;
    if (MaximumSizeForEncoding >= 1024)
      v14 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xBB047E6uLL);
    else
      v14 = buffer;
    if (CFStringGetCString(v8, v14, v13, 0x8000100u))
    {
      v17 = strlen(v14);
      StringFromFileSystemRepresentationByAddingPercentEscapes = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(0, v14, v17, 0, 0, 0, 0);
    }
    else
    {
      StringFromFileSystemRepresentationByAddingPercentEscapes = 0;
    }
    if (v14 != buffer)
      free(v14);
    v70 = 0u;
    v71 = 0u;
    v68 = 0u;
    v69 = 0u;
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    v54 = 0u;
    v55 = 0u;
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v44 = 0u;
    v45 = 0u;
    v42 = 0u;
    v43 = 0u;
    *(_OWORD *)buffer = 0u;
    v41 = 0u;
    v72 = 0;
    Mutable = CFStringCreateMutable(allocator, 0);
    v19 = CFStringGetLength(CFSTR("file://"));
    v20 = v72;
    if (v19 < 1025)
    {
      v21 = v19;
      if (v72 + v19 >= 1025)
      {
        CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
        v20 = 0;
        v72 = 0;
      }
      v22 = (UniChar *)&buffer[2 * v20];
      v75.location = 0;
      v75.length = v21;
      CFStringGetCharacters(CFSTR("file://"), v75, v22);
      v72 += v21;
      if (!v9)
      {
LABEL_40:
        v27 = CFStringGetLength(StringFromFileSystemRepresentationByAddingPercentEscapes);
        v28 = v72;
        if (v27 < 1025)
        {
          v29 = v27;
          if (v72 + v27 >= 1025)
          {
            CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
            v28 = 0;
            v72 = 0;
          }
          v30 = (UniChar *)&buffer[2 * v28];
          v77.location = 0;
          v77.length = v29;
          CFStringGetCharacters(StringFromFileSystemRepresentationByAddingPercentEscapes, v77, v30);
          v72 += v29;
        }
        else
        {
          if (v72)
          {
            CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
            v72 = 0;
          }
          CFStringAppend(Mutable, StringFromFileSystemRepresentationByAddingPercentEscapes);
        }
        if (CFURLHasDirectoryPath(url)
          && CFStringCompare(StringFromFileSystemRepresentationByAddingPercentEscapes, CFSTR("/"), 0))
        {
          v31 = v72;
          if (v72 >= 1024)
          {
            CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
            v31 = 0;
            v72 = 0;
          }
          *(_WORD *)&buffer[2 * v31] = 47;
          ++v72;
        }
        if (v10)
        {
          v32 = CFStringGetLength(v10);
          v33 = v72;
          if (v32 < 1025)
          {
            v37 = v32;
            if (v72 + v32 >= 1025)
            {
              CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
              v33 = 0;
              v72 = 0;
            }
            v38 = (UniChar *)&buffer[2 * v33];
            v78.location = 0;
            v78.length = v37;
            CFStringGetCharacters(v10, v78, v38);
            v34 = v72 + v37;
            v72 = v34;
            if (!v34)
            {
LABEL_59:
              v35 = Mutable;
              Mutable = 0;
              if (v35)
              {
                v15 = (const __CFURL *)_CFURLCreateWithURLString((int)allocator, v35);
                CFRelease(v35);
              }
              else
              {
                v15 = 0;
              }
              CFRelease(StringFromFileSystemRepresentationByAddingPercentEscapes);
              CFRelease(v8);
              if (!v9)
                goto LABEL_64;
              goto LABEL_63;
            }
LABEL_58:
            CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v34);
            v72 = 0;
            goto LABEL_59;
          }
          if (v72)
          {
            CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
            v72 = 0;
          }
          CFStringAppend(Mutable, v10);
        }
        v34 = v72;
        if (!v72)
          goto LABEL_59;
        goto LABEL_58;
      }
    }
    else
    {
      if (v72)
      {
        CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
        v72 = 0;
      }
      CFStringAppend(Mutable, CFSTR("file://"));
      if (!v9)
        goto LABEL_40;
    }
    v23 = CFStringGetLength(v9);
    v24 = v72;
    if (v23 < 1025)
    {
      v25 = v23;
      if (v72 + v23 >= 1025)
      {
        CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
        v24 = 0;
        v72 = 0;
      }
      v26 = (UniChar *)&buffer[2 * v24];
      v76.location = 0;
      v76.length = v25;
      CFStringGetCharacters(v9, v76, v26);
      v72 += v25;
    }
    else
    {
      if (v72)
      {
        CFStringAppendCharacters(Mutable, (const UniChar *)buffer, v72);
        v72 = 0;
      }
      CFStringAppend(Mutable, v9);
    }
    goto LABEL_40;
  }
LABEL_14:
  if (error)
  {
    v15 = 0;
    *error = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 4, 0);
    if (!v9)
      goto LABEL_64;
LABEL_63:
    CFRelease(v9);
    goto LABEL_64;
  }
  v15 = 0;
  if (v9)
    goto LABEL_63;
LABEL_64:
  if (v10)
    CFRelease(v10);
  return v15;
}

CFStringRef CFURLCopyResourceSpecifier(CFURLRef anURL)
{
  CFURLRef v1;
  int v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int i;
  CFAllocatorRef v6;
  uint64_t v7;
  int v8;
  const __CFString *v9;
  uint64_t v10;
  CFAllocatorRef v11;
  CFRange v12;
  const __CFAllocator *v13;
  const __CFString *v14;
  CFAllocatorRef v15;
  unint64_t *v16;
  unint64_t v17;
  const __CFString *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  char v22;
  CFIndex v24;
  unsigned int v25;
  BOOL v26;
  unsigned int v27;
  uint64_t v28;
  char v29;
  unint64_t *v30;
  const __CFString *v31;
  CFIndex Length;
  uint64_t v33;
  char v34;
  uint64_t v35;
  CFIndex v36;
  char v37;
  unsigned int v38;
  _QWORD v39[18];
  uint64_t v40;

  v1 = anURL;
  v40 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
    v1 = (CFURLRef)-[__CFURL _cfurl](v1, "_cfurl");
  v2 = *((_DWORD *)v1 + 4);
  if ((v2 & 0x4000) != 0)
  {
    v4 = 0;
    for (i = 256; i != 32; i >>= 1)
    {
      if ((i & v2) != 0)
        v4 = i;
    }
    if (!v4)
      return 0;
    v6 = CFGetAllocator(v1);
    if (v1 && (v7 = *((_QWORD *)v1 + 5)) != 0)
    {
      v8 = *(_DWORD *)(v7 + 16);
      v9 = *(const __CFString **)(v7 + 8);
    }
    else
    {
      v8 = 0;
      v9 = 0;
    }
    v19 = *((_DWORD *)v1 + 4);
    if ((v19 & 0x10000) != 0 || v4 == 512)
    {
LABEL_27:
      if ((v19 & v4) != 0)
      {
        if ((v4 & 1) != 0)
        {
          v21 = 0;
        }
        else
        {
          LODWORD(v21) = 0;
          do
          {
            v22 = v4;
            v4 >>= 1;
            v21 = (v19 & 1) + v21;
            v19 >>= 1;
          }
          while ((v22 & 2) == 0);
        }
        v24 = *((_QWORD *)v1 + 2 * v21 + 7) - 1;
      }
      else
      {
        v24 = -2;
      }
      v30 = (unint64_t *)((char *)v1 + 24);
      v31 = (const __CFString *)atomic_load(v30);
      Length = CFStringGetLength(v31);
      v14 = (const __CFString *)atomic_load(v30);
      v12.length = Length - v24;
      v13 = v6;
      v12.location = v24;
    }
    else
    {
      v20 = v4;
      while ((v20 & v8) == 0)
      {
        v20 *= 2;
        if (v20 == 512)
          goto LABEL_27;
      }
      v25 = v4;
      while (v25 >= 2)
      {
        v26 = (v8 & (v25 >> 1)) == 0;
        v25 >>= 1;
        if (!v26)
        {
          v38 = 0;
          _parseComponents(v9, *((const __CFURL **)v1 + 4), &v38, v39, &v37);
          v27 = v38;
          if ((v38 & v4) != 0)
          {
            if ((v4 & 1) != 0)
            {
              v28 = 0;
            }
            else
            {
              LODWORD(v28) = 0;
              do
              {
                v29 = v4;
                v4 >>= 1;
                v28 = (v27 & 1) + v28;
                v27 >>= 1;
              }
              while ((v29 & 2) == 0);
            }
            v3 = v39[2 * v28] - 1;
          }
          else
          {
            v3 = -2;
          }
          v36 = CFStringGetLength(v9);
          v13 = CFGetAllocator(v1);
          v12.length = v36 - v3;
          goto LABEL_18;
        }
      }
      if ((v19 & v4) != 0)
      {
        if ((v4 & 1) != 0)
        {
          v33 = 0;
        }
        else
        {
          LODWORD(v33) = 0;
          do
          {
            v34 = v4;
            v4 >>= 1;
            v33 = (v19 & 1) + v33;
            v19 >>= 1;
          }
          while ((v34 & 2) == 0);
        }
        v35 = *((_QWORD *)v1 + 2 * v33 + 7) - 1;
      }
      else
      {
        v35 = -2;
      }
      v12.length = CFStringGetLength(v9) - v35;
      v13 = v6;
      v14 = v9;
      v12.location = v35;
    }
  }
  else
  {
    if ((v2 & 1) != 0)
      v3 = *((_QWORD *)v1 + 7) + *((_QWORD *)v1 + 8) + 1;
    else
      v3 = 0;
    v10 = *((_QWORD *)v1 + 5);
    if (v10 && (v9 = *(const __CFString **)(v10 + 8)) != 0)
    {
      v11 = CFGetAllocator(v1);
      v12.length = CFStringGetLength(v9) - v3;
      v13 = v11;
LABEL_18:
      v14 = v9;
    }
    else
    {
      v15 = CFGetAllocator(v1);
      v16 = (unint64_t *)((char *)v1 + 24);
      v17 = atomic_load((unint64_t *)v1 + 3);
      v18 = (const __CFString *)atomic_load(v16);
      v12.length = CFStringGetLength(v18) - v3;
      v13 = v15;
      v14 = (const __CFString *)v17;
    }
    v12.location = v3;
  }
  return CFStringCreateWithSubstring(v13, v14, v12);
}

CFStringRef CFURLCopyNetLocation(CFURLRef anURL)
{
  int v2;
  uint64_t v4;
  CFIndex v5;
  CFIndex v6;
  uint64_t v7;
  const __CFString *v8;
  CFIndex v9;
  const __CFAllocator *v10;
  const __CFAllocator *v11;
  const __CFString *v12;
  CFRange result;
  uint64_t v14;
  CFRange v15;
  CFRange v16;
  CFRange v17;

  v14 = *MEMORY[0x1E0C80C00];
  while (1)
  {
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
      anURL = (CFURLRef)-[__CFURL _cfurl](anURL, "_cfurl");
    v2 = *((_DWORD *)anURL + 4);
    if ((v2 & 0x1E) != 0)
      break;
    anURL = (CFURLRef)*((_QWORD *)anURL + 4);
    if (!anURL)
      return 0;
  }
  v4 = _netLocationRange(*((_DWORD *)anURL + 4), (uint64_t)anURL + 56);
  v6 = v5;
  if ((v2 & 0x10000) == 0 && (v7 = *((_QWORD *)anURL + 5)) != 0 && (*(_BYTE *)(v7 + 16) & 0x1E) != 0)
  {
    result.location = 0;
    result.length = 0;
    v8 = *(const __CFString **)(v7 + 8);
    v9 = CFStringGetLength(v8) - v4;
    v15.location = v4;
    v15.length = v9;
    if (CFStringFindWithOptions(v8, CFSTR("/"), v15, 0, &result))
      v9 = result.location - v4;
    v10 = CFGetAllocator(anURL);
    v16.location = v4;
    v16.length = v9;
    return CFStringCreateWithSubstring(v10, v8, v16);
  }
  else
  {
    v11 = CFGetAllocator(anURL);
    v12 = (const __CFString *)atomic_load((unint64_t *)anURL + 3);
    v17.location = v4;
    v17.length = v6;
    return CFStringCreateWithSubstring(v11, v12, v17);
  }
}

CFStringRef _CFURLCopyFileReferenceURLPath(const void *a1, CFErrorRef *a2)
{
  const __CFAllocator *v4;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  __objc2_class **Value;
  __objc2_class **v8;
  const __CFNumber *v9;
  int v10;
  CFStringRef v11;
  const __CFNumber *v12;
  char v13;
  const void *v14;
  int v15;
  uint64_t v16;
  const __CFAllocator *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  const __CFString *v21;
  const __CFString *v22;
  CFIndex Length;
  CFIndex v24;
  int CharacterAtIndex;
  const __CFString *v26;
  const __CFString *v27;
  CFStringRef v28;
  CFStringRef FileReferencePath;
  const __CFAllocator *v31;
  CFTypeRef cf;
  CFTypeRef propertyValueTypeRefPtr;
  _QWORD block[5];
  uint64_t v35;
  uint64_t valuePtr[2];

  valuePtr[1] = *MEMORY[0x1E0C80C00];
  v35 = 0;
  valuePtr[0] = 0;
  v4 = CFGetAllocator(a1);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = ___CFURLCopyFileReferenceURLPath_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = v4;
  if (_CFURLCopyFileReferenceURLPath_onceToken != -1)
    dispatch_once(&_CFURLCopyFileReferenceURLPath_onceToken, block);
  v5 = CFURLCopyResourcePropertiesForKeys((CFURLRef)a1, (CFArrayRef)_CFURLCopyFileReferenceURLPath_sPropertyKeys, a2);
  if (v5)
  {
    v6 = v5;
    v31 = v4;
    Value = (__objc2_class **)CFDictionaryGetValue(v5, CFSTR("NSURLIsDirectoryKey"));
    if (Value == &__kCFBooleanTrue)
    {
      v9 = (const __CFNumber *)CFDictionaryGetValue(v6, CFSTR("_NSURLVolumeIDKey"));
      v10 = 1;
    }
    else
    {
      v8 = (__objc2_class **)CFDictionaryGetValue(v6, CFSTR("_NSURLVolumeIsHFSStandardKey"));
      v9 = (const __CFNumber *)CFDictionaryGetValue(v6, CFSTR("_NSURLVolumeIDKey"));
      if (v8 == &__kCFBooleanTrue)
      {
        v12 = (const __CFNumber *)CFDictionaryGetValue(v6, CFSTR("_NSURLParentDirectoryIDKey"));
        v14 = CFDictionaryGetValue(v6, CFSTR("NSURLNameKey"));
        v15 = 0;
        v10 = 0;
        v13 = 1;
LABEL_12:
        if (v14)
          v15 = 1;
        if (v9 && v12 && v15)
        {
          if (CFNumberGetValue(v9, kCFNumberLongLongType, valuePtr)
            && CFNumberGetValue(v12, kCFNumberLongLongType, &v35))
          {
            v16 = v35;
            if ((v13 & 1) != 0)
            {
              v4 = v31;
              v17 = v31;
              v18 = v35;
              v16 = 0;
              v19 = (uint64_t)v14;
              v20 = 0;
            }
            else
            {
              v4 = v31;
              v17 = v31;
              v18 = 0;
              v19 = 0;
              v20 = v10;
            }
            FileReferencePath = createFileReferencePath(v17, valuePtr[0], v18, v16, v19, v20);
            v11 = FileReferencePath;
            if (a2 && !FileReferencePath)
              goto LABEL_47;
            goto LABEL_54;
          }
          v11 = 0;
          if (a2)
            *a2 = 0;
LABEL_41:
          v4 = v31;
          goto LABEL_54;
        }
        propertyValueTypeRefPtr = 0;
        if (!CFURLCopyResourcePropertyForKey((CFURLRef)a1, CFSTR("NSURLParentDirectoryURLKey"), &propertyValueTypeRefPtr, a2))
        {
          v11 = 0;
          goto LABEL_41;
        }
        v4 = v31;
        if (!propertyValueTypeRefPtr)
        {
          v11 = 0;
          if (a2)
LABEL_47:
            *a2 = 0;
LABEL_54:
          CFRelease(v6);
          if (!a2)
            return v11;
          goto LABEL_55;
        }
        v21 = (const __CFString *)_CFURLCopyFileReferenceURLPath(propertyValueTypeRefPtr, a2);
        if (!v21)
        {
          v11 = 0;
LABEL_53:
          CFRelease(propertyValueTypeRefPtr);
          goto LABEL_54;
        }
        v22 = v21;
        cf = 0;
        Length = CFStringGetLength(v21);
        v24 = Length - 1;
        if (Length < 1)
        {
          if (a2)
          {
            v11 = 0;
            *a2 = 0;
LABEL_52:
            CFRelease(v22);
            goto LABEL_53;
          }
        }
        else if (CFURLCopyResourcePropertyForKey((CFURLRef)a1, CFSTR("NSURLNameKey"), &cf, a2))
        {
          CharacterAtIndex = CFStringGetCharacterAtIndex(v22, v24);
          v26 = CFSTR("%@/%@");
          if (Value == &__kCFBooleanTrue)
            v26 = CFSTR("%@/%@/");
          v27 = CFSTR("%@%@");
          if (Value == &__kCFBooleanTrue)
            v27 = CFSTR("%@%@/");
          if (CharacterAtIndex == 47)
            v28 = CFStringCreateWithFormat(v31, 0, v27, v22, cf);
          else
            v28 = CFStringCreateWithFormat(v31, 0, v26, v22, cf);
          v11 = v28;
          if (a2 && !v28)
            *a2 = 0;
          if (cf)
            CFRelease(cf);
          goto LABEL_52;
        }
        v11 = 0;
        goto LABEL_52;
      }
      v10 = 0;
    }
    v12 = (const __CFNumber *)CFDictionaryGetValue(v6, CFSTR("_NSURLFileIDKey"));
    v13 = 0;
    v14 = 0;
    v15 = 1;
    goto LABEL_12;
  }
  v11 = 0;
  if (!a2)
    return v11;
LABEL_55:
  if (!v11 && !*a2)
    *a2 = CFErrorCreate(v4, CFSTR("NSCocoaErrorDomain"), 256, 0);
  return v11;
}

CFStringRef createFileReferencePath(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  CFStringRef v10;
  const char *v11;
  const char *v13;
  char v14[992];
  char v15[1024];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0;
  if (!a5)
  {
    v13 = "/";
    if (!a6)
      v13 = "";
    if (snprintf(v15, 0x400uLL, "/.file/id=%lld.%lld%s", a2, a4, v13) <= 0x3FF)
      return CFStringCreateWithCString(a1, v15, 0x8000100u);
    return 0;
  }
  MEMORY[0x1E0C80A78](a1, a2);
  if (!CFStringGetCString(v10, v14, 1024, 0x8000100u))
    return 0;
  v11 = "/";
  if (!a6)
    v11 = "";
  if (snprintf(v15, 0x400uLL, "/.file/id=%lld.%lld/%s%s", a2, a3, v14, v11) <= 0x3FF)
    return CFStringCreateWithCString(a1, v15, 0x8000100u);
  else
    return 0;
}

CFStringRef CFDateFormatterCreateDateFormatFromTemplate(CFAllocatorRef allocator, CFStringRef tmplate, CFOptionFlags options, CFLocaleRef locale)
{
  CFTypeID TypeID;
  CFTypeID v9;
  CFMutableArrayRef Mutable;
  BOOL v11;
  int v12;
  uint64_t *v13;
  const __CFString *v14;
  _QWORD v16[9];
  BOOL v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  CFMutableArrayRef v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  TypeID = CFStringGetTypeID();
  v9 = CFGetTypeID(tmplate);
  Mutable = 0;
  v18 = 0;
  v19 = &v18;
  v20 = 0x2020000000;
  v21 = 0;
  v11 = TypeID == v9;
  if (!v11)
    Mutable = CFArrayCreateMutable(allocator, 0, &kCFTypeArrayCallBacks);
  v21 = Mutable;
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3221225472;
  v16[2] = __CFDateFormatterCreateDateFormatFromTemplate_block_invoke;
  v16[3] = &unk_1E12E13C8;
  v17 = v11;
  v16[6] = locale;
  v16[7] = options;
  v16[8] = allocator;
  v16[4] = &v18;
  v16[5] = tmplate;
  v12 = useTemplatePatternGenerator(locale, (uint64_t)v16);
  v13 = v19;
  v14 = (const __CFString *)v19[3];
  if (!v12)
  {
    if (v14)
    {
      CFRelease((CFTypeRef)v19[3]);
      v13 = v19;
    }
    v14 = 0;
    v13[3] = 0;
  }
  _Block_object_dispose(&v18, 8);
  return v14;
}

void sub_182ABD2FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  _Unwind_Resume(exception_object);
}

uint64_t useTemplatePatternGenerator(const __CFLocale *a1, uint64_t a2)
{
  const __CFString *Identifier;
  const char *CStringPtr;
  uint64_t v5;
  int v6;
  qos_class_t v7;
  NSObject *global_queue;
  BOOL v9;
  uint64_t v10;
  _QWORD handler[5];
  int v13;
  char buffer[768];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (a1)
    Identifier = CFLocaleGetIdentifier(a1);
  else
    Identifier = &stru_1E1337B18;
  CStringPtr = CFStringGetCStringPtr(Identifier, 0x600u);
  if (!CStringPtr)
  {
    CStringPtr = buffer;
    if (!CFStringGetCString(Identifier, buffer, 768, 0x600u))
      CStringPtr = 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&useTemplatePatternGenerator_ptgLock);
  if (!useTemplatePatternGenerator_ptgLocaleName
    || !strcmp((const char *)useTemplatePatternGenerator_ptgLocaleName, CStringPtr))
  {
    v5 = useTemplatePatternGenerator_ptg;
    v13 = 0;
    if (useTemplatePatternGenerator_ptg)
    {
      v6 = 0;
      goto LABEL_16;
    }
  }
  else
  {
    __cficu_udatpg_close((const void *)useTemplatePatternGenerator_ptg);
    useTemplatePatternGenerator_ptg = 0;
    free((void *)useTemplatePatternGenerator_ptgLocaleName);
    useTemplatePatternGenerator_ptgLocaleName = 0;
    v13 = 0;
  }
  v5 = __cficu_udatpg_open((uint64_t)CStringPtr, &v13);
  useTemplatePatternGenerator_ptg = v5;
  v6 = v13;
  if (v5)
  {
    if (v13 <= 0)
    {
      useTemplatePatternGenerator_ptgLocaleName = (uint64_t)strdup(CStringPtr);
      if (!useTemplatePatternGenerator_pressureSrc)
      {
        v7 = qos_class_main();
        global_queue = dispatch_get_global_queue(v7, 2uLL);
        useTemplatePatternGenerator_pressureSrc = (uint64_t)dispatch_source_create(MEMORY[0x1E0C80DA8], 0, 6uLL, global_queue);
        handler[0] = MEMORY[0x1E0C809B0];
        handler[1] = 3221225472;
        handler[2] = __useTemplatePatternGenerator_block_invoke_2;
        handler[3] = &unk_1E12E1438;
        handler[4] = &__block_literal_global_1;
        dispatch_source_set_event_handler((dispatch_source_t)useTemplatePatternGenerator_pressureSrc, handler);
        dispatch_resume((dispatch_object_t)useTemplatePatternGenerator_pressureSrc);
        v5 = useTemplatePatternGenerator_ptg;
        v6 = v13;
      }
    }
  }
LABEL_16:
  if (v5)
    v9 = v6 < 1;
  else
    v9 = 0;
  v10 = v9;
  if (a2 && (_DWORD)v10)
    (*(void (**)(uint64_t, uint64_t))(a2 + 16))(a2, v5);
  os_unfair_lock_unlock((os_unfair_lock_t)&useTemplatePatternGenerator_ptgLock);
  return v10;
}

uint64_t __cficu_udatpg_getSkeleton(uint64_t a1, UChar *a2, uint64_t a3, const UniChar *a4, uint64_t a5, int *a6)
{
  uint64_t Skeleton;
  CFStringRef v13;
  const void *v14;
  CFTypeRef v15;
  CFStringRef v16;
  CFStringRef v17;
  CFStringRef v18;

  Skeleton = udatpg_getSkeleton();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dtpg", a1);
    v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    v15 = ___CFICUCreateVariableNameForUCharOutput("skeleton", (uint64_t)a4, a5);
    v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    v17 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
    if (*a6 <= 0)
      v18 = CFStringCreateWithCharacters(0, a4, (int)Skeleton);
    else
      v18 = 0;
    ___CFICULogWithArguments(1, CFSTR("udatpg_getSkeleton(%@, %@, %d, %@, %d, &%@); // %d %@ %@"),
      v13,
      v17,
      a3,
      v15,
      a5,
      v14,
      Skeleton,
      v18,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v17);
    if (v18)
      CFRelease(v18);
    CFRelease(v16);
  }
  return Skeleton;
}

uint64_t __cficu_udatpg_getBestPattern(uint64_t a1, UChar *a2, uint64_t a3, const UniChar *a4, uint64_t a5, int *a6)
{
  uint64_t BestPattern;
  CFStringRef v13;
  const void *v14;
  CFTypeRef v15;
  CFStringRef v16;
  CFStringRef v17;
  CFStringRef v18;

  BestPattern = udatpg_getBestPattern();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dtpg", a1);
    v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    v15 = ___CFICUCreateVariableNameForUCharOutput("pattern", (uint64_t)a4, a5);
    v16 = ___CFICUCreateErrorStringWithComment(a6, 0);
    v17 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
    if (*a6 <= 0)
      v18 = CFStringCreateWithCharacters(0, a4, (int)BestPattern);
    else
      v18 = 0;
    ___CFICULogWithArguments(1, CFSTR("udatpg_getBestPattern(%@, %@, %d, %@, %d, &%@); // %d %@ %@"),
      v13,
      v17,
      a3,
      v15,
      a5,
      v14,
      BestPattern,
      v18,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    if (v18)
      CFRelease(v18);
    CFRelease(v17);
    CFRelease(v16);
  }
  return BestPattern;
}

uint64_t __cficu_udatpg_open(uint64_t a1, int *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  CFStringRef v7;

  v4 = udatpg_open();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"dtpg", v4);
    v6 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    v7 = ___CFICUCreateErrorStringWithComment(a2, 1);
    ___CFICULogWithArguments(1, CFSTR("UDateTimePatternGenerator *%@ = udatpg_open(\"%s\", &%@); %@"), v5, a1, v6, v7);
    CFRelease(v5);
    CFRelease(v6);
    CFRelease(v7);
  }
  return v4;
}

uint64_t __CFBinaryPlistGetOffsetForValueFromDictionary3(char *a1, int a2, unint64_t a3, uint64_t a4, const __CFString *cf, unint64_t *a6, unint64_t *a7)
{
  CFTypeID v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  char v18;
  unsigned int *v19;
  unint64_t v20;
  unsigned __int8 *v21;
  char v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int8 *v27;
  unsigned int v28;
  CFIndex Length;
  unsigned int v31;
  uint64_t v32;
  const char *CStringPtr;
  int64_t v34;
  char *v35;
  size_t v36;
  uint64_t v37;
  _BOOL4 v38;
  char *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unsigned int *v43;
  unsigned int v44;
  unint64_t v45;
  unsigned int *v46;
  uint64_t v47;
  unsigned int v48;
  char v49;
  unint64_t v50;
  unsigned __int8 *v51;
  char *v52;
  unsigned int v53;
  uint64_t v54;
  unsigned int *v55;
  uint64_t v56;
  _BOOL4 v57;
  int v58;
  uint64_t v59;
  char *v60;
  unsigned int v61;
  unsigned int *v62;
  uint64_t v63;
  int v64;
  unsigned int *v65;
  char *v66;
  uint64_t v67;
  unint64_t v68;
  int v69;
  unsigned int v70;
  unint64_t v71;
  unsigned int *v72;
  uint64_t v73;
  unsigned int v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t *v77;
  unint64_t v78;
  unsigned __int8 *v79;
  unint64_t v80;
  size_t __n;
  char *__s2;
  char *v83;
  CFTypeID v84;
  CFTypeRef v85;
  char buffer[16];
  uint64_t v87;

  v87 = *MEMORY[0x1E0C80C00];
  if (!cf)
    return 0;
  v14 = CFGetTypeID(cf);
  if (v14 < 0x14 && ((0xE0001u >> v14) & 1) != 0)
    return 0;
  v15 = 0;
  if (a3 < 8)
    return v15;
  v16 = *(_QWORD *)(a4 + 24) - 1;
  if (v16 < a3)
    return v15;
  v15 = 0;
  v17 = &a1[a3];
  if (&a1[a3] == (char *)-1)
    return v15;
  v18 = *v17;
  if ((*v17 & 0xF0) != 0xD0)
    return v15;
  v19 = (unsigned int *)(v17 + 1);
  v20 = v18 & 0xF;
  if ((v18 & 0xF) == 0xF)
  {
    if (&a1[v16] < (char *)v19)
      return 0;
    v21 = (unsigned __int8 *)(v17 + 2);
    v22 = *(_BYTE *)v19;
    if ((*(_BYTE *)v19 & 0xF0) != 0x10)
      return 0;
    v15 = 0;
    v23 = v22 & 0xF;
    v24 = 1 << (v22 & 0xF);
    if (__CFADD__(v24, v21) || (char *)v19 + v24 > &a1[v16])
      return v15;
    switch((char)v24)
    {
      case 1:
        v20 = *v21;
        goto LABEL_26;
      case 2:
        v20 = __rev16(*(unsigned __int16 *)((char *)v19 + 1));
        goto LABEL_26;
      case 4:
        v20 = bswap32(*(unsigned int *)((char *)v19 + 1));
        goto LABEL_26;
      case 8:
        v20 = bswap64(*(_QWORD *)((char *)v19 + 1));
        goto LABEL_25;
      default:
        if (v23 >= 8)
        {
          v20 = 0;
          v25 = 0;
          v19 = (unsigned int *)&v21[v24];
          goto LABEL_33;
        }
        v20 = 0;
        if ((v24 & 0xFE) != 0)
          v26 = v24;
        else
          v26 = 1;
        v27 = (unsigned __int8 *)v19 + 1;
        do
        {
          v28 = *v27++;
          v20 = v28 | (v20 << 8);
          --v26;
        }
        while (v26);
LABEL_25:
        if ((v20 & 0x8000000000000000) != 0)
          return 0;
LABEL_26:
        v19 = (unsigned int *)&v21[v24];
        break;
    }
  }
  if (v20)
  {
    if (!is_mul_ok(2 * v20, *(unsigned __int8 *)(a4 + 7)))
      return 0;
    v25 = 2 * v20 * *(unsigned __int8 *)(a4 + 7);
  }
  else
  {
    v25 = 0;
  }
LABEL_33:
  v15 = 0;
  if (__CFADD__(v25, v19) || &a1[v16] < (char *)v19 + v25 - 1)
    return v15;
  v77 = a6;
  if (v14 != 7)
  {
    v35 = 0;
    v31 = *(unsigned __int8 *)(a4 + 7);
    v79 = (unsigned __int8 *)(a4 + 7);
LABEL_47:
    v34 = -1;
    goto LABEL_48;
  }
  Length = CFStringGetLength(cf);
  v31 = *(unsigned __int8 *)(a4 + 7);
  v79 = (unsigned __int8 *)(a4 + 7);
  if (Length == -1)
  {
    v35 = 0;
    goto LABEL_47;
  }
  v32 = Length;
  CStringPtr = CFStringGetCStringPtr(cf, 0);
  v34 = v32;
  v35 = (char *)CStringPtr;
  if (v32 > 15 || CStringPtr)
  {
LABEL_48:
    if (!v20)
      goto LABEL_112;
    goto LABEL_49;
  }
  if (CFStringGetCString(cf, buffer, 16, 0))
  {
    v36 = strnlen(buffer, 0x10uLL);
    v34 = v32;
    if (v36 == v32)
      v35 = buffer;
    else
      v35 = 0;
    if (!v20)
      goto LABEL_112;
    goto LABEL_49;
  }
  v35 = 0;
  v34 = v32;
  if (!v20)
  {
LABEL_112:
    v38 = 0;
LABEL_113:
    v69 = 0;
    return v38 & v69;
  }
LABEL_49:
  v37 = 0;
  v75 = v20 * v31;
  v83 = a1 + 8;
  v78 = (unint64_t)&a1[*(_QWORD *)(a4 + 24) - 1];
  v76 = ~v34;
  v38 = 1;
  v80 = v20;
  __n = v34;
  __s2 = v35;
  while (1)
  {
    if (v83 > (char *)v19)
      goto LABEL_113;
    v39 = &a1[*(_QWORD *)(a4 + 24)];
    v40 = *(unsigned __int8 *)(a4 + 7);
    if (&v39[-v40] < (char *)v19)
      goto LABEL_113;
    v41 = *(unsigned __int8 *)(a4 + 7);
    switch(*(_BYTE *)(a4 + 7))
    {
      case 0:
        break;
      case 1:
        v41 = *(unsigned __int8 *)v19;
        break;
      case 2:
        v41 = __rev16(*(unsigned __int16 *)v19);
        break;
      case 4:
        v41 = bswap32(*v19);
        break;
      case 8:
        v41 = bswap64(*(_QWORD *)v19);
        break;
      default:
        v41 = 0;
        v42 = *(unsigned __int8 *)(a4 + 7);
        v43 = v19;
        do
        {
          v44 = *(unsigned __int8 *)v43;
          v43 = (unsigned int *)((char *)v43 + 1);
          v41 = v44 | (v41 << 8);
          --v42;
        }
        while (v42);
        break;
    }
    if (*(_QWORD *)(a4 + 8) <= v41)
      goto LABEL_113;
    v45 = *(unsigned __int8 *)(a4 + 6);
    v46 = (unsigned int *)&v39[v41 * v45];
    switch(*(_BYTE *)(a4 + 6))
    {
      case 0:
        break;
      case 1:
        v45 = *(unsigned __int8 *)v46;
        break;
      case 2:
        v45 = __rev16(*(unsigned __int16 *)v46);
        break;
      case 4:
        v45 = bswap32(*v46);
        break;
      case 8:
        v45 = bswap64(*(_QWORD *)v46);
        break;
      default:
        v47 = *(unsigned __int8 *)(a4 + 6);
        v45 = 0;
        do
        {
          v48 = *(unsigned __int8 *)v46;
          v46 = (unsigned int *)((char *)v46 + 1);
          v45 = v48 | (v45 << 8);
          --v47;
        }
        while (v47);
        break;
    }
    if (v35)
    {
      v49 = a1[v45];
      if ((v49 & 0xF0) == 0x50)
        break;
    }
    v55 = v19;
    v56 = v37;
    v57 = v38;
    v85 = 0;
    v84 = 0;
    if (!__CFBinaryPlistCreateObjectFiltered(a1, a2, v45, a4, &__kCFAllocatorSystemDefault, 0xFFFFFFFF80000000, 0, 0, 0, 0, 0, &v85, &v84)|| v84 <= 0x13 && ((1 << v84) & 0xE0001) != 0)
    {
      if (v85)
        CFRelease(v85);
      goto LABEL_110;
    }
    v58 = CFEqual(cf, v85);
    CFRelease(v85);
    v34 = __n;
    v35 = __s2;
    v37 = v56;
    v19 = v55;
    if (v58)
      goto LABEL_104;
    v40 = *v79;
LABEL_86:
    v19 = (unsigned int *)((char *)v19 + v40);
    v38 = ++v37 < v80;
    if (v37 == v80)
      goto LABEL_113;
  }
  if (__CFADD__(v45, a1) || &a1[v45] == (char *)-1)
    goto LABEL_113;
  v50 = v49 & 0xF;
  v51 = (unsigned __int8 *)&a1[v45 + 1];
  if (v34 >= 15 && (_DWORD)v50 == 15)
  {
    if (v78 < (unint64_t)v51)
      goto LABEL_113;
    v52 = &a1[v45 + 2];
    if ((*v51 & 0xF0) != 0x10)
      goto LABEL_113;
    v53 = *v51 & 0xF;
    v54 = 1 << v53;
    if (__CFADD__(1 << v53, v52) || (unint64_t)&v51[v54] > v78)
      goto LABEL_113;
    switch((1 << v53))
    {
      case 1u:
        v50 = *v52;
        goto LABEL_99;
      case 2u:
        v50 = __rev16(*(unsigned __int16 *)&a1[v45 + 2]);
        goto LABEL_99;
      case 4u:
        v50 = bswap32(*(_DWORD *)&a1[v45 + 2]);
        goto LABEL_99;
      case 8u:
        v50 = bswap64(*(_QWORD *)&a1[v45 + 2]);
        goto LABEL_98;
      default:
        if (v53 < 8)
        {
          v50 = 0;
          if ((v54 & 0xFE) != 0)
            v59 = v54;
          else
            v59 = 1;
          v60 = &a1[v45 + 2];
          do
          {
            v61 = *v60++;
            v50 = v61 | (v50 << 8);
            --v59;
          }
          while (v59);
LABEL_98:
          if ((v50 & 0x8000000000000000) != 0)
            goto LABEL_113;
        }
        else
        {
          v50 = 0;
        }
LABEL_99:
        v51 = (unsigned __int8 *)&v52[v54];
        v34 = __n;
        break;
    }
  }
  if (v50 != v34)
    goto LABEL_86;
  if (v76 < (unint64_t)v51 || v78 < (unint64_t)&v51[v34 - 1])
    goto LABEL_113;
  v62 = v19;
  v63 = v37;
  v57 = v38;
  v64 = memcmp(v51, __s2, v34);
  v34 = __n;
  v35 = __s2;
  v37 = v63;
  v19 = v62;
  if (v64)
    goto LABEL_86;
LABEL_104:
  v65 = (unsigned int *)((char *)v19 + v75);
  if (v83 > (char *)v19 + v75)
  {
LABEL_110:
    v69 = 0;
    v38 = v57;
    return v38 & v69;
  }
  v66 = &a1[*(_QWORD *)(a4 + 24)];
  v67 = *(unsigned __int8 *)(a4 + 7);
  v38 = v57;
  if (&v66[-v67] < (char *)v65)
    goto LABEL_113;
  v68 = *(unsigned __int8 *)(a4 + 7);
  switch(*(_BYTE *)(a4 + 7))
  {
    case 0:
      break;
    case 1:
      v68 = *(unsigned __int8 *)v65;
      break;
    case 2:
      v68 = __rev16(*(unsigned __int16 *)v65);
      break;
    case 4:
      v68 = bswap32(*v65);
      break;
    case 8:
      v68 = bswap64(*(_QWORD *)v65);
      break;
    default:
      v68 = 0;
      do
      {
        v70 = *(unsigned __int8 *)v65;
        v65 = (unsigned int *)((char *)v65 + 1);
        v68 = v70 | (v68 << 8);
        --v67;
      }
      while (v67);
      break;
  }
  if (*(_QWORD *)(a4 + 8) <= v68)
    goto LABEL_113;
  if (a7)
  {
    v71 = *(unsigned __int8 *)(a4 + 6);
    v72 = (unsigned int *)&v66[v68 * v71];
    switch(*(_BYTE *)(a4 + 6))
    {
      case 0:
        break;
      case 1:
        v71 = *(unsigned __int8 *)v72;
        break;
      case 2:
        v71 = __rev16(*(unsigned __int16 *)v72);
        break;
      case 4:
        v71 = bswap32(*v72);
        break;
      case 8:
        v71 = bswap64(*(_QWORD *)v72);
        break;
      default:
        v73 = *(unsigned __int8 *)(a4 + 6);
        v71 = 0;
        do
        {
          v74 = *(unsigned __int8 *)v72;
          v72 = (unsigned int *)((char *)v72 + 1);
          v71 = v74 | (v71 << 8);
          --v73;
        }
        while (v73);
        break;
    }
    *a7 = v71;
  }
  if (v77)
    *v77 = v45;
  v69 = 1;
  return v38 & v69;
}

void _CFStringAppendFormatAndArgumentsAux2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 *a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  CFErrorRef v14[2];

  v14[1] = *(CFErrorRef *)MEMORY[0x1E0C80C00];
  v14[0] = 0;
  __CFStringAppendFormatCore(a1, a2, a3, a4, 0, a5, 0, a6, 0, 0, 0, 0, a7, 0, v14);
  if (!v13)
  {
    CFLog(3, (uint64_t)CFSTR("ERROR: Failed to format string: %@"), v7, v8, v9, v10, v11, v12, (__int16)v14[0]);
    if (v14[0])
      CFRelease(v14[0]);
  }
}

uint64_t _CFNonObjCStringGetCStringPtr(uint64_t a1, unsigned int a2, int a3)
{
  return _CFStringGetCStringPtrInternal(a1, a2, a3, 0);
}

uint64_t __CFStringMtbl(uint64_t a1)
{
  char v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

CFStringEncoding CFStringConvertNSStringEncodingToEncoding(unint64_t encoding)
{
  CFStringEncoding v2;

  if (encoding == 4)
    return 134217984;
  if (encoding - 1 <= 0xE)
    return word_182CF929A[encoding - 1];
  v2 = encoding & 0x7FFFFFFF;
  if ((encoding & 0x80000000) == 0)
    v2 = -1;
  if (encoding == 21)
    v2 = 2080;
  if (encoding == 30)
    return 0;
  else
    return v2;
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  uint64_t v4;
  uint64_t v5;
  Boolean result;
  char v10;
  char **p_data;
  char *v12;
  char v13;
  char v14;
  CFIndex length;
  char v16;
  char v17;
  int v18;
  unint64_t v19;
  int v20;
  int v21;
  int64_t v22;
  int64_t v23[2];
  CFRange v24;

  v23[1] = *MEMORY[0x1E0C80C00];
  v4 = bufferSize - 1;
  if (bufferSize < 1)
    return 0;
  v5 = *(_QWORD *)&encoding;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    return -[__CFString _getCString:maxLength:encoding:]((id)theString, "_getCString:maxLength:encoding:", buffer, v4, v5);
  v10 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v10 & 0x60) != 0)
  {
    v12 = *p_data;
  }
  else
  {
    v13 = atomic_load((unint64_t *)&theString->info);
    v12 = (char *)&p_data[(v13 & 5) != 4];
  }
  v14 = atomic_load((unint64_t *)&theString->info);
  if ((v14 & 5) == 4)
  {
    length = *v12;
  }
  else
  {
    v16 = atomic_load((unint64_t *)&theString->info);
    if ((v16 & 0x60) != 0)
      length = theString->length;
    else
      length = (CFIndex)*p_data;
  }
  v17 = atomic_load((unint64_t *)&theString->info);
  if ((v17 & 0x10) != 0)
    goto LABEL_41;
  v18 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    v18 = __CFDefaultEightBitStringEncoding;
  }
  if (v18 == (_DWORD)v5)
    goto LABEL_17;
  if (v18 == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    v18 = __CFDefaultEightBitStringEncoding;
  }
  if (v18 != 1536)
    goto LABEL_41;
  switch(BYTE1(v5))
  {
    case 0:
      if (v5 <= 0x22 && ((1 << v5) & 0x600000032) != 0 || (_DWORD)v5 == 152)
        goto LABEL_41;
      goto LABEL_17;
    case 1:
      if ((_DWORD)v5 != 134217984)
        goto LABEL_41;
      goto LABEL_17;
    case 2:
      if ((_DWORD)v5 == 518)
        goto LABEL_41;
      goto LABEL_17;
    case 6:
      if ((_DWORD)v5 != 1536)
        goto LABEL_41;
      goto LABEL_17;
    case 8:
    case 0xC:
      goto LABEL_41;
    case 0xA:
      if ((v5 - 2561) > 0xF)
        goto LABEL_17;
      v20 = 1 << (v5 - 1);
      v21 = 32785;
      break;
    case 0xB:
      if ((v5 - 3059) > 0xC)
        goto LABEL_17;
      v20 = 1 << (v5 + 13);
      v21 = 4099;
      break;
    default:
      if (((unsigned __int16)v5 & 0xFF00u) > 0xC00)
        goto LABEL_41;
      goto LABEL_17;
  }
  if ((v20 & v21) == 0)
  {
LABEL_17:
    if (length >= bufferSize)
    {
      result = 0;
      *buffer = 0;
    }
    else
    {
      v19 = atomic_load((unint64_t *)&theString->info);
      memmove(buffer, &v12[(v19 >> 2) & 1], length);
      buffer[length] = 0;
      return 1;
    }
  }
  else
  {
LABEL_41:
    v23[0] = 0;
    v24.location = 0;
    v24.length = length;
    result = __CFStringEncodeByteStream(theString, v24, 0, v5, 0, (UniChar *)buffer, v4, v23) == length;
    v22 = v23[0];
    if (!result)
      v22 = 0;
    buffer[v22] = 0;
  }
  return result;
}

uint64_t _NSIsNSObject(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*MethodImplementation)(uint64_t, char *);

  if (a1)
  {
    v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
      return MethodImplementation(v1, sel_isNSObject__);
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }
  return a1 & 1;
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
  CFNotificationCenterPostNotificationWithOptions(center, name, object, userInfo, deliverImmediately != 0);
}

CFStringRef _CFStringCreateWithFormatAndArgumentsAux2(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 *a7)
{
  return _CFStringCreateWithFormatAndArgumentsReturningMetadata(a1, a2, a3, a4, 0, a5, a6, 0, a7);
}

CFStringRef _CFStringCreateWithFormatAndArgumentsReturningMetadata(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, CFArrayRef *a8, __int16 *a9)
{
  CFMutableStringRef Mutable;
  int v18;
  CFStringRef Copy;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  Mutable[1].info = Mutable[1].info & 0xF | 0x780;
  cf[0] = 0;
  __CFStringAppendFormatCore((uint64_t)Mutable, a2, a3, a4, a5, a6, 0, a7, 0, 0, 0, 0, a9, a8, (CFErrorRef *)cf);
  if (v18)
  {
    Copy = CFStringCreateCopy(a1, Mutable);
  }
  else
  {
    CFLog(3, CFSTR("ERROR: Failed to format string: %@"));
    if (cf[0])
      CFRelease(cf[0]);
    Copy = 0;
  }
  CFRelease(Mutable);
  return Copy;
}

unint64_t *_CFNonObjCStringCreateCopy(__objc2_class **allocator, uint64_t a2)
{
  unint64_t *v4;
  char v5;
  __objc2_class **v6;
  const CFAllocatorRef *v7;
  uint64_t v8;
  char v9;
  char v10;
  char v11;
  uint64_t v12;
  int8x16_t **v13;
  int8x16_t *v14;
  int8x16_t *v15;
  char v16;
  char v17;
  char v19;
  unint64_t v20;
  int8x16_t *v21;
  int64_t v22;
  char v23;
  uint64_t v24;
  char v25;
  int8x16_t *v26;
  char v27;
  uint64_t v28;
  __objc2_class **v29;
  int64_t v30;
  unsigned int v31;

  v4 = (unint64_t *)(a2 + 8);
  v5 = atomic_load((unint64_t *)(a2 + 8));
  if ((v5 & 1) != 0)
    goto LABEL_12;
  v6 = allocator;
  if (allocator)
  {
    if (a2 < 0)
    {
LABEL_4:
      v7 = &kCFAllocatorSystemDefault;
      goto LABEL_11;
    }
  }
  else
  {
    v8 = _CFGetTSD(1u);
    v6 = &__kCFAllocatorSystemDefault;
    if (v8)
      v6 = (__objc2_class **)v8;
    if (a2 < 0)
      goto LABEL_4;
  }
  v9 = atomic_load((unint64_t *)(a2 + 8));
  if (v9 < 0)
    v7 = &kCFAllocatorSystemDefault;
  else
    v7 = (const CFAllocatorRef *)(a2 - 16);
LABEL_11:
  if (v6 == *(__objc2_class ***)v7)
  {
    v16 = atomic_load((unint64_t *)(a2 + 8));
    if ((v16 & 0x60) == 0)
      return _CFNonObjCRetain((unint64_t *)a2);
    v17 = atomic_load((unint64_t *)(a2 + 8));
    if ((v17 & 0x20) != 0 || __CFRuntimeIsConstant(a2))
      return _CFNonObjCRetain((unint64_t *)a2);
  }
LABEL_12:
  v10 = atomic_load(v4);
  v11 = atomic_load(v4);
  v12 = v11 & 0x60;
  v13 = (int8x16_t **)(a2 + 16);
  if ((v10 & 0x10) != 0)
  {
    if (v12)
    {
      v15 = *v13;
    }
    else
    {
      v24 = atomic_load((unint64_t *)(a2 + 8));
      v15 = (int8x16_t *)&v13[(v24 & 5) != 4];
    }
    v25 = atomic_load((unint64_t *)(a2 + 8));
    if ((v25 & 5) == 4)
    {
      v26 = (int8x16_t *)v15->u8[0];
    }
    else
    {
      v27 = atomic_load((unint64_t *)(a2 + 8));
      if ((v27 & 0x60) != 0)
        v26 = *(int8x16_t **)(a2 + 24);
      else
        v26 = *v13;
    }
    v30 = 2 * (_QWORD)v26;
    v29 = allocator;
    v28 = 256;
    v31 = 2;
  }
  else
  {
    if (v12)
    {
      v14 = *v13;
    }
    else
    {
      v19 = atomic_load((unint64_t *)(a2 + 8));
      v14 = (int8x16_t *)&v13[(v19 & 5) != 4];
    }
    v20 = atomic_load((unint64_t *)(a2 + 8));
    v21 = (int8x16_t *)((char *)v14 + ((v20 >> 2) & 1));
    LOBYTE(v20) = atomic_load((unint64_t *)(a2 + 8));
    if ((v20 & 5) == 4)
    {
      v22 = v14->u8[0];
    }
    else
    {
      v23 = atomic_load((unint64_t *)(a2 + 8));
      if ((v23 & 0x60) != 0)
        v22 = *(_QWORD *)(a2 + 24);
      else
        v22 = (int64_t)*v13;
    }
    v28 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      v28 = __CFDefaultEightBitStringEncoding;
    }
    v29 = allocator;
    v15 = v21;
    v30 = v22;
    v31 = 0;
  }
  return (unint64_t *)__CFStringCreateImmutableFunnel3(v29, v15, v30, v28, v31, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  if (((unint64_t)theString & 0x8000000000000000) != 0)
    return theString;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    return (CFStringRef)-[__CFString copy]((id)theString, "copy");
  return (CFStringRef)_CFNonObjCStringCreateCopy((__objc2_class **)alloc, (uint64_t)theString);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  __objc2_class **v3;
  uint64_t v4;
  __CFString *Instance;
  unint64_t *p_info;
  unint64_t v7;
  unint64_t v8;
  int v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  char v16;
  BOOL v17;
  uint64_t v18;
  CFIndex v19;
  char v20;

  v3 = (__objc2_class **)alloc;
  if (!alloc)
  {
    v4 = _CFGetTSD(1u);
    if (v4)
      v3 = (__objc2_class **)v4;
    else
      v3 = &__kCFAllocatorSystemDefault;
  }
  Instance = (__CFString *)_CFRuntimeCreateInstance(v3, 7uLL, 32, 0);
  if (Instance)
  {
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
    p_info = (unint64_t *)&Instance->info;
    v7 = atomic_load((unint64_t *)&Instance->info);
    while (1)
    {
      v8 = __ldaxr(p_info);
      if (v8 != v7)
        break;
      if (__stlxr(v7 & 0xFFFFFFFFFFFFFF9FLL | 0x20, p_info))
        goto LABEL_13;
      v9 = 1;
LABEL_14:
      v7 = v8;
      if (v9)
      {
        v10 = atomic_load(p_info);
        while (1)
        {
          v11 = __ldaxr(p_info);
          if (v11 != v10)
            break;
          if (__stlxr(v10 & 0xFFFFFFFFFFFFFFEFLL, p_info))
            goto LABEL_20;
          v12 = 1;
LABEL_21:
          v10 = v11;
          if (v12)
          {
            v13 = atomic_load(p_info);
            while (1)
            {
              v14 = __ldaxr(p_info);
              if (v14 != v13)
                break;
              if (__stlxr(v13 | 1, p_info))
                goto LABEL_27;
              v15 = 1;
LABEL_28:
              v13 = v14;
              if (v15)
              {
                Instance->data = 0;
                v16 = atomic_load((unint64_t *)&Instance->info);
                v17 = (v16 & 0x60) == 0;
                v18 = 24;
                if (v17)
                  v18 = 16;
                *(void **)((char *)&Instance->isa + v18) = 0;
                v19 = (16 * maxLength) | 2;
                if (!maxLength)
                  v19 = 512;
                Instance[1].isa = 0;
                Instance[1].info = v19;
                v20 = atomic_load((unint64_t *)&Instance->info);
                if ((~v20 & 0x60) == 0)
                {
                  CFRetain(v3);
                  Instance[1].data = (char *)v3;
                }
                return Instance;
              }
            }
            __clrex();
LABEL_27:
            v15 = 0;
            goto LABEL_28;
          }
        }
        __clrex();
LABEL_20:
        v12 = 0;
        goto LABEL_21;
      }
    }
    __clrex();
LABEL_13:
    v9 = 0;
    goto LABEL_14;
  }
  return Instance;
}

void __CFStringAppendFormatCore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __CFString *a9, uint64_t a10, _OWORD *a11, uint64_t a12, __int16 *a13, CFArrayRef *a14, CFErrorRef *a15)
{
  uint64_t v15;
  __CFString *v16;
  __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  const void *v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  const void *v23;
  const void *v24;
  uint64_t (*v25)(uint64_t, uint64_t, const __CFString *);
  uint64_t (*v26)(uint64_t, uint64_t, const __CFString *);
  uint64_t (*v27)(uint64_t, uint64_t);
  CFErrorRef *v28;
  CFArrayRef *v29;
  CFTypeID v30;
  CFArrayRef *p_theArray;
  uint64_t FormatSpecifierConfiguration;
  const __CFDictionary *v33;
  __CFDictionary *Mutable;
  uint64_t v35;
  CFIndex Length;
  _BYTE *v37;
  int FormatSpecifiersInString;
  CFIndex v39;
  uint64_t v40;
  const __CFAllocator *v41;
  __CFDictionary *v42;
  CFErrorRef v43;
  const __CFAllocator *v44;
  UniChar *v45;
  unint64_t v46;
  unint64_t v47;
  CFRange v48;
  int v49;
  CFIndex v50;
  unsigned __int8 *v51;
  int v52;
  BOOL v53;
  CFStringRef v54;
  CFIndex v55;
  uint64_t v56;
  UniChar *Typed;
  UniChar *v58;
  UniChar *v59;
  char v60;
  char v61;
  uint64_t v62;
  char **p_data;
  char **v64;
  UniChar *v65;
  uint64_t v66;
  uint64_t v67;
  const __CFAllocator *v68;
  _OWORD *v69;
  _DWORD *v70;
  _BYTE *v71;
  uint64_t v72;
  __objc2_class **v73;
  _BYTE *v74;
  BOOL v75;
  _BYTE *v76;
  char *v77;
  CFIndex v78;
  unint64_t v79;
  unint64_t v80;
  void **p_vtable;
  size_t v82;
  uint64_t v83;
  __int128 v84;
  _BYTE *v85;
  _DWORD *v86;
  _DWORD *v87;
  _BYTE *v88;
  __int16 *v89;
  int v90;
  _DWORD *v91;
  unsigned int v92;
  uint64_t v93;
  int v94;
  int v95;
  int v96;
  unsigned __int8 *v97;
  uint64_t v98;
  unsigned __int8 v99;
  unsigned __int8 v100;
  uint64_t v101;
  unsigned int v102;
  BOOL v104;
  _BOOL4 v105;
  uint64_t v107;
  int v108;
  uint64_t v109;
  unsigned __int16 *v110;
  unsigned __int8 *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  _DWORD *v115;
  uint64_t v116;
  BOOL v117;
  unsigned __int8 v118;
  __int16 v119;
  int v120;
  int v121;
  const __CFString *ImmutableFunnel3;
  __int16 v123;
  int v124;
  __int16 v125;
  int v126;
  uint64_t v127;
  __int16 *v128;
  uint64_t v129;
  int8x16_t *v130;
  int64_t v131;
  unsigned int v132;
  uint64_t v133;
  int v134;
  char v135;
  __int16 v136;
  __int16 v137;
  __int16 v138;
  __CFDictionary *MutableCopy;
  const __CFString *v140;
  __CFDictionary **v141;
  const __CFDictionary *v142;
  const void *v143;
  const void *InputIdentifierFormatterMappingFromDescriptor;
  const __CFDictionary *v145;
  const __CFDictionary *v146;
  CFIndex v147;
  const void *Value;
  const void *v149;
  const void *v150;
  uint64_t v151;
  const __CFAllocator *v152;
  __CFDictionary *v153;
  CFErrorRef v154;
  int v155;
  int v156;
  _BYTE *v157;
  uint64_t location;
  uint64_t v159;
  BOOL v160;
  int v161;
  uint64_t v162;
  _BYTE *v163;
  unsigned int v164;
  uint64_t v165;
  int v167;
  char *v168;
  int v169;
  _BYTE *v170;
  _BYTE *v171;
  int v172;
  int v173;
  char *v174;
  int v176;
  char *v177;
  int v178;
  uint64_t v179;
  _BYTE *v180;
  const __CFString *v181;
  const UniChar *CharactersPtr;
  unint64_t v183;
  unsigned int v184;
  uint64_t CStringPtrInternal;
  CFIndex v186;
  void *v187;
  int v188;
  _BYTE *v189;
  _BYTE *v190;
  uint64_t v191;
  int64_t v192;
  unint64_t v193;
  uint64_t v194;
  int8x16_t *v195;
  __objc2_class **v196;
  int64_t v197;
  unsigned int v198;
  int v199;
  int v200;
  BOOL v201;
  int v202;
  unsigned __int8 v203;
  uint64_t v204;
  unsigned __int8 v205;
  unsigned int v206;
  BOOL v207;
  BOOL v208;
  int v209;
  BOOL v210;
  uint64_t v211;
  int v212;
  UniChar *v213;
  int v214;
  uint64_t v215;
  UniChar *v216;
  UniChar v217;
  UniChar v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  __int16 v222;
  uint64_t v223;
  int v224;
  int v225;
  int v226;
  __int16 v227;
  __int16 v228;
  CFTypeRef v229;
  uint64_t v230;
  CFRange v231;
  UniChar *v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  int v236;
  _OWORD *v237;
  __int16 *v238;
  unsigned int v239;
  uint64_t v240;
  uint64_t v241;
  _QWORD *v242;
  __int16 *v243;
  uint64_t v244;
  char *v245;
  int v246;
  __int16 *v247;
  __int16 *v248;
  __int16 *v249;
  uint64_t v250;
  char *v251;
  CFIndex v252;
  uint64_t v253;
  _BYTE *v254;
  char *v255;
  uint64_t v256;
  _BYTE *v257;
  uint64_t v258;
  unsigned __int8 *v259;
  unsigned int v260;
  int v261;
  uint64_t v262;
  unsigned __int8 *v263;
  uint64_t v264;
  unsigned int v265;
  int v266;
  _BYTE *v267;
  int v268;
  _BYTE *v269;
  int v270;
  unsigned int v271;
  unint64_t v272;
  int v273;
  unsigned int v274;
  uint64_t v275;
  int v276;
  _BYTE *v277;
  int *v278;
  uint64_t v279;
  uint64_t v280;
  unint64_t v281;
  uint64_t v282;
  const char *v283;
  int v284;
  CFIndex v285;
  int v286;
  unint64_t *v287;
  CFIndex v288;
  uint64_t v289;
  uint64_t v290;
  UniChar *v291;
  _BYTE *v292;
  uint64_t v293;
  int v294;
  uint64_t v295;
  int v296;
  int v297;
  const char *v298;
  int v299;
  uint64_t v300;
  int v301;
  const char *v302;
  int v303;
  void *v304;
  int v305;
  char *v306;
  unint64_t *v307;
  CFIndex v308;
  __CFString *v309;
  CFIndex v310;
  __CFString *v311;
  CFIndex v312;
  CFIndex v313;
  _BYTE *v314;
  char *v315;
  const void *v316;
  __CFString *v317;
  unsigned __int8 *v318;
  int v319;
  int v320;
  int v322;
  char *v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  const __CFString *v328;
  _OWORD *v329;
  __int128 v330;
  char *v331;
  unint64_t v332;
  __CFString *v333;
  _BYTE *v334;
  uint64_t v335;
  char *v336;
  uint64_t v337;
  unsigned __int8 *v338;
  int v339;
  int v340;
  int v342;
  void *v343;
  int v344;
  void *v345;
  double v346;
  int v347;
  unint64_t v348;
  int v349;
  const __CFString *v350;
  _BYTE *v351;
  unint64_t v352;
  uint64_t v353;
  unint64_t v354;
  uint64_t v355;
  CFIndex v356;
  const UniChar *v357;
  uint64_t i;
  CFIndex v359;
  CFMutableArrayRef *v360;
  uint64_t v361;
  uint64_t v362;
  int v363;
  int v364;
  int v365;
  int v366;
  int v367;
  int v368;
  _OWORD *v369;
  const UniChar *v370;
  int v371;
  unint64_t v372;
  int v373;
  char *v374;
  int v375;
  int v376;
  int v377;
  int v378;
  int v379;
  CFTypeID v380;
  const __CFString *v381;
  const char *v382;
  CFStringEncoding v383;
  const __CFString *v384;
  CFArrayRef *v385;
  _OWORD *v386;
  CFIndex v387;
  __int128 v388;
  int v389;
  uint64_t v390;
  int v391;
  _BOOL4 v392;
  CFIndex v393;
  CFStringEncoding v394;
  uint64_t v395;
  CFStringEncoding v396;
  UniChar *v397;
  const __CFAllocator *v398;
  CFNumberType v399;
  char *v400;
  const UniChar *v401;
  uint64_t v402;
  int v404;
  int v406;
  int v407;
  __CFString *v408;
  int v409;
  int v410;
  CFIndex v411;
  void *v412;
  uint64_t v413;
  const __CFString *v414;
  const __CFDictionary *v415;
  uint64_t (*v416)(uint64_t, uint64_t, const __CFString *);
  char *v417;
  uint64_t v418;
  int v419;
  int appended;
  int v421;
  int v422;
  uint64_t v423;
  int v424;
  int v425;
  int v426;
  int v427;
  int v428;
  int v429;
  int v430;
  uint64_t v431;
  CFRange v432;
  const __CFString *v433;
  const __CFString *v434;
  void *v435;
  uint64_t v436;
  unint64_t v437;
  uint64_t v438;
  uint64_t v439;
  const __CFAllocator *v440;
  __CFDictionary *v441;
  CFErrorRef v442;
  __CFDictionary *v443;
  __CFDictionary *v444;
  CFStringRef v445;
  __CFDictionary *v446;
  uint64_t v447;
  const __CFAllocator *v448;
  __CFDictionary *v449;
  CFErrorRef v450;
  uint64_t v451;
  char *v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  CFErrorRef *v456;
  CFIndex v457;
  char key;
  uint64_t v459;
  char *v460;
  UniChar cf2;
  unint64_t cf2a;
  UniChar *v463;
  const __CFDictionary *theDict;
  const __CFString *theString;
  const __CFString *v466;
  _BYTE *v467;
  int v468;
  uint64_t v469;
  const __CFString *v470;
  __CFString *v471;
  CFMutableStringRef v472;
  CFMutableStringRef v473;
  __CFString *v474;
  _DWORD *v475;
  void *v476;
  int v477;
  char *v478;
  const __CFAllocator *alloc;
  uint64_t v480;
  char *v481;
  char *cStr;
  char *cStra;
  char *cStrb;
  char *cStrc;
  int v486;
  char *v487;
  char *v488;
  unint64_t v489;
  uint64_t (*v490)(uint64_t, uint64_t, const __CFString *);
  unint64_t v491;
  CFIndex range;
  uint64_t v493;
  uint64_t v494;
  uint64_t (*v495)(uint64_t, uint64_t);
  CFDictionaryRef v496;
  CFTypeRef cf;
  _BOOL4 v498;
  const void *v499;
  CFMutableArrayRef *v500;
  _DWORD *v501;
  int v502;
  CFIndex v503;
  size_t count;
  unsigned int counta;
  _OWORD *countb;
  CFArrayRef *v507;
  __CFString *v508;
  _BYTE *v509;
  __int16 *__src;
  __int16 *__srca;
  char *__srcb;
  _OWORD v513[2];
  __int16 *v514;
  void *v515;
  _BYTE *v516;
  int8x16_t ptr;
  CFArrayRef theArray;
  UniChar chars[16];
  __int128 v520;
  __int128 v521;
  __int128 v522;
  __int128 v523;
  __int128 v524;
  __int128 v525;
  __int128 v526;
  __int128 v527;
  __int128 v528;
  __int128 v529;
  __int128 v530;
  __int128 v531;
  __int128 v532;
  __int128 v533;
  __int128 v534;
  __int128 v535;
  __int128 v536;
  __int128 v537;
  __int128 v538;
  __int128 v539;
  __int128 v540;
  __int128 v541;
  __int128 v542;
  __int128 v543;
  __int128 v544;
  __int128 v545;
  __int128 v546;
  __int128 v547;
  uint64_t v548;
  unsigned __int8 *v549[16];
  _OWORD v550[30];
  uint64_t v551;
  _BYTE v552[976];
  _BYTE v553[1952];
  UniChar v554[400];
  uint64_t v555;
  CFRange v556;
  CFRange v557;
  CFRange v558;

  v15 = MEMORY[0x1E0C80A78](a1, a2);
  v17 = v16;
  v19 = v18;
  cf = v20;
  v22 = v21;
  v24 = v23;
  v26 = v25;
  v495 = v27;
  v508 = (__CFString *)v15;
  v29 = a14;
  v28 = a15;
  v555 = *MEMORY[0x1E0C80C00];
  bzero(v552, 0x3D0uLL);
  v499 = v24;
  if (v24)
  {
    v30 = CFGetTypeID(v24);
    v498 = v30 == CFLocaleGetTypeID();
  }
  else
  {
    v498 = 0;
  }
  v551 = 0;
  memset(v550, 0, sizeof(v550));
  p_theArray = &theArray;
  if (!a14)
    p_theArray = 0;
  v500 = p_theArray;
  theArray = 0;
  FormatSpecifierConfiguration = _CFStringGetFormatSpecifierConfiguration(v17);
  ptr.i64[1] = 0;
  if (FormatSpecifierConfiguration)
    v33 = (const __CFDictionary *)FormatSpecifierConfiguration;
  else
    v33 = v22;
  if (v19)
  {
    if (a10 >= 11)
    {
      if (!a15)
        return;
      Mutable = CFDictionaryCreateMutable(0, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(Mutable, CFSTR("NSDebugDescription"), CFSTR("Exceeded maximum number of allowed nested stringsdict entry references"));
      *a15 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 2048, Mutable);
LABEL_43:
      CFRelease(Mutable);
      return;
    }
    v35 = (uint64_t)v17;
    v549[0] = 0;
    *(_QWORD *)&v513[0] = 0;
    v516 = 0;
    ptr.i64[0] = 0;
    v515 = 0;
    v548 = 0;
    v546 = 0u;
    v547 = 0u;
    v544 = 0u;
    v545 = 0u;
    v542 = 0u;
    v543 = 0u;
    v540 = 0u;
    v541 = 0u;
    v538 = 0u;
    v539 = 0u;
    v536 = 0u;
    v537 = 0u;
    v534 = 0u;
    v535 = 0u;
    v532 = 0u;
    v533 = 0u;
    v530 = 0u;
    v531 = 0u;
    v528 = 0u;
    v529 = 0u;
    v526 = 0u;
    v527 = 0u;
    v524 = 0u;
    v525 = 0u;
    v522 = 0u;
    v523 = 0u;
    v520 = 0u;
    v521 = 0u;
    memset(chars, 0, sizeof(chars));
    Length = CFStringGetLength(v19);
    __CFStringSetUpFormatAndSpecBuffers((uint64_t)v19, Length, v549, (UniChar **)v513, (UniChar **)&ptr, v554, (uint64_t *)&v516, (uint64_t)v553, (uint64_t *)&v515, (uint64_t)chars);
    v37 = v516;
    FormatSpecifiersInString = __CFStringFindFormatSpecifiersInString((uint64_t)v549[0], *(uint64_t *)&v513[0], Length, (uint64_t)v516, 0, 0);
    if ((UniChar *)ptr.i64[0] != v554)
      CFAllocatorDeallocate(0, (void *)ptr.i64[0]);
    if (v37 != v553)
      CFAllocatorDeallocate(0, v37);
    if (v515 != chars)
      CFAllocatorDeallocate(0, v515);
    if (!Length || !FormatSpecifiersInString)
    {
      if (!a15)
        return;
      Mutable = CFDictionaryCreateMutable(0, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v54 = CFStringCreateWithFormat(0, 0, CFSTR("Expected format '%@' is invalid"), v19);
      CFDictionarySetValue(Mutable, CFSTR("NSDebugDescription"), v54);
      *a15 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 2048, Mutable);
      CFRelease(v54);
      goto LABEL_43;
    }
    v17 = (__CFString *)v35;
    if (!v33 && __CFStringValidateFormat((uint64_t)v19, v35) < 0)
      return;
    v29 = a14;
  }
  v39 = CFStringGetLength(v17);
  if (v39 >= 0x80000000)
  {
    if (a15)
    {
LABEL_26:
      v40 = _CFGetTSD(1u);
      if (v40)
        v41 = (const __CFAllocator *)v40;
      else
        v41 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
      v42 = CFDictionaryCreateMutable(v41, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(v42, CFSTR("NSDebugDescription"), CFSTR("Overflow occurred"));
      v43 = CFErrorCreate(v41, CFSTR("NSCocoaErrorDomain"), 2048, v42);
      v44 = 0;
      v45 = 0;
      goto LABEL_70;
    }
LABEL_888:
    v44 = 0;
    v496 = 0;
    v69 = 0;
    v70 = 0;
    v71 = 0;
    v45 = 0;
    goto LABEL_889;
  }
  range = v39;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)v17))
  {
    v46 = 0;
    v47 = 0;
LABEL_32:
    v48.length = range;
    goto LABEL_33;
  }
  v60 = atomic_load((unint64_t *)&v17->info);
  v61 = atomic_load((unint64_t *)&v17->info);
  v62 = v61 & 0x60;
  p_data = &v17->data;
  if ((v60 & 0x10) != 0)
  {
    v47 = 0;
    if (v62)
    {
      v46 = (unint64_t)*p_data;
    }
    else
    {
      v438 = atomic_load((unint64_t *)&v17->info);
      v46 = (unint64_t)&p_data[(v438 & 5) != 4];
    }
    goto LABEL_32;
  }
  if (v62)
  {
    v64 = (char **)*p_data;
  }
  else
  {
    v436 = atomic_load((unint64_t *)&v17->info);
    v64 = &p_data[(v436 & 5) != 4];
  }
  v48.length = range;
  v46 = 0;
  if (v64)
  {
    v437 = atomic_load((unint64_t *)&v17->info);
    v47 = (unint64_t)v64 + ((v437 >> 2) & 1);
  }
  else
  {
    v47 = 0;
  }
LABEL_33:
  theString = v17;
  v466 = v19;
  v491 = v47;
  if (v47 | v46)
  {
    if (v47)
    {
      if (v48.length >= 1)
      {
        v49 = 0;
        v50 = v48.length;
        v51 = (unsigned __int8 *)v47;
        while (1)
        {
          v52 = *v51++;
          if (v52 == 37)
          {
            v53 = __OFADD__(v49++, 1);
            if (v53)
              break;
          }
          if (!--v50)
          {
            v45 = 0;
            v44 = 0;
            goto LABEL_64;
          }
        }
        v28 = a15;
        if (a15)
          goto LABEL_26;
        goto LABEL_888;
      }
      v489 = v46;
      theDict = v33;
      v49 = 0;
      v45 = 0;
      goto LABEL_77;
    }
    v45 = 0;
    v44 = 0;
  }
  else
  {
    if (v48.length < 401)
    {
      v44 = 0;
      v58 = v554;
    }
    else
    {
      v55 = v48.length;
      v56 = _CFGetTSD(1u);
      if (v56)
        v44 = (const __CFAllocator *)v56;
      else
        v44 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
      Typed = (UniChar *)CFAllocatorAllocateTyped(v44, 2 * v55, 0x1000040BDFB0063, 0);
      v58 = Typed;
      if (Typed != v554 && __CFOASafe)
      {
        v59 = Typed;
        __CFSetLastAllocationEventName();
        v58 = v59;
      }
      v48.length = range;
    }
    v48.location = 0;
    v65 = v58;
    CFStringGetCharacters(theString, v48, v58);
    v46 = (unint64_t)v65;
    v48.length = range;
    v45 = v65;
  }
  if (v48.length < 1)
  {
    v489 = v46;
    theDict = v33;
    v49 = 0;
  }
  else
  {
    v66 = 0;
    v49 = 0;
    do
    {
      if (*(_WORD *)(v46 + 2 * v66) == 37)
      {
        v53 = __OFADD__(v49++, 1);
        if (v53)
          goto LABEL_65;
      }
      ++v66;
    }
    while (v48.length != v66);
LABEL_64:
    if (v49 >= 0x100000)
    {
LABEL_65:
      v28 = a15;
      if (!a15)
      {
        v496 = 0;
        v69 = 0;
        v70 = 0;
        v71 = 0;
        goto LABEL_889;
      }
      v67 = _CFGetTSD(1u);
      if (v67)
        v68 = (const __CFAllocator *)v67;
      else
        v68 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
      v42 = CFDictionaryCreateMutable(v68, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(v42, CFSTR("NSDebugDescription"), CFSTR("Overflow occurred"));
      v43 = CFErrorCreate(v68, CFSTR("NSCocoaErrorDomain"), 2048, v42);
LABEL_70:
      CFRelease(v42);
      v496 = 0;
      v69 = 0;
      v70 = 0;
      v71 = 0;
      *v28 = v43;
LABEL_889:
      CFAllocatorDeallocate(v44, v71);
      goto LABEL_890;
    }
    v489 = v46;
    theDict = v33;
  }
LABEL_77:
  v72 = _CFGetTSD(1u);
  if (v72)
    v73 = (__objc2_class **)v72;
  else
    v73 = &__kCFAllocatorSystemDefault;
  v71 = v553;
  if (((2 * v49) | 1) > 61)
  {
    v74 = (_BYTE *)CFAllocatorAllocateTyped(v73, 32 * ((2 * v49) | 1u), 0x10000408E5DAE1CLL, 0);
    v71 = v74;
    v75 = v74 == v553 || __CFOASafe == 0;
    if (!v75)
    {
      v76 = v74;
      __CFSetLastAllocationEventName();
      v71 = v76;
    }
  }
  v509 = v71;
  if (v49 >= 61)
  {
    v77 = (char *)CFAllocatorAllocateTyped(v73, 8 * v49, 0x6004044C4A2DFLL, 0);
    v71 = v509;
  }
  else
  {
    v77 = (char *)v550;
  }
  v79 = v491;
  v78 = range;
  v80 = v489;
  v481 = v77;
  p_vtable = (void **)(NSTimer + 24);
  v507 = v29;
  alloc = (const __CFAllocator *)v73;
  v490 = v26;
  v463 = v45;
  if (range < 1)
  {
    v480 = 0;
    v496 = 0;
    LODWORD(v82) = 0;
    goto LABEL_288;
  }
  v82 = 0;
  LODWORD(v83) = 0;
  v496 = 0;
  v480 = 0;
  v84 = xmmword_182C98E20;
  do
  {
    v85 = &v71[32 * v82];
    *((_DWORD *)v85 + 1) = v83;
    v86 = v85 + 4;
    *(_OWORD *)(v85 + 8) = v84;
    v87 = v85 + 8;
    *(_DWORD *)v85 = 0;
    v88 = v85 + 27;
    v89 = (__int16 *)(v85 + 2);
    *((_DWORD *)v85 + 6) = -1;
    v90 = v83;
    if (v79)
    {
      if (v78 > (int)v83)
      {
        v83 = (int)v83;
        while (*(_BYTE *)(v79 + v83) != 37)
        {
          if (v78 == ++v83)
            goto LABEL_100;
        }
        goto LABEL_101;
      }
    }
    else
    {
      v83 = (int)v83;
      if (v78 > (int)v83)
      {
        while (*(_WORD *)(v80 + 2 * v83) != 37)
        {
          if (v78 == ++v83)
          {
LABEL_100:
            LODWORD(v83) = v78;
            break;
          }
        }
LABEL_101:
        if ((_DWORD)v83 != v90)
        {
          v123 = 32;
          goto LABEL_272;
        }
      }
    }
    count = v82;
    v91 = v85 + 20;
    if (v90 + 1 >= (int)v78)
    {
      LODWORD(v83) = v90 + 1;
LABEL_201:
      ImmutableFunnel3 = 0;
      *v89 = 43;
      goto LABEL_248;
    }
    v92 = 0;
    v93 = 0;
    v94 = 0;
    v95 = 0;
    v96 = 0;
    v486 = 0;
    v475 = v85 + 16;
    v467 = v85 + 25;
    v97 = v85 + 26;
    v98 = -1;
    v99 = -1;
    v100 = -1;
    LODWORD(v83) = v90 + 1;
    v501 = v85 + 20;
    while (1)
    {
      v101 = (int)v83;
      if (v79)
        v102 = *(unsigned __int8 *)(v79 + (int)v83);
      else
        v102 = *(unsigned __int16 *)(v80 + 2 * (int)v83);
      LODWORD(v83) = v83 + 1;
      if (v98 < 0)
      {
        __src = v89;
        while (1)
        {
          while (v102 - 49 < 9)
          {
            v107 = 0;
            if ((int)v83 <= (int)v78)
              v108 = v78;
            else
              v108 = v83;
            v109 = v108 - (uint64_t)(int)v83;
            v110 = (unsigned __int16 *)(v80 + 2 * (int)v83);
            v111 = (unsigned __int8 *)(v79 + (int)v83);
            do
            {
              v112 = (unsigned __int128)(v107 * (__int128)10) >> 64;
              v113 = 10 * v107;
              if (v112 != v113 >> 63)
                goto LABEL_282;
              v114 = v102 - 48;
              v53 = __OFADD__(v113, v114);
              v107 = v113 + v114;
              if (v53)
                goto LABEL_282;
              if (!v109)
              {
                ImmutableFunnel3 = 0;
                v89 = __src;
                *__src = 43;
                LODWORD(v83) = v108;
                v80 = v489;
                v91 = v85 + 20;
                goto LABEL_248;
              }
              if (v79)
                v102 = *v111;
              else
                v102 = *v110;
              --v109;
              ++v110;
              ++v111;
              LODWORD(v83) = v83 + 1;
            }
            while (v102 - 48 < 0xA);
            if (v102 == 36)
            {
              v89 = __src;
              v91 = v85 + 20;
              if (v107 < 128)
              {
                v80 = v489;
                if (v100 == 254)
                {
                  v100 = v107 - 1;
                  *v467 = v107 - 1;
                }
                else
                {
                  v118 = v107 - 1;
                  if (v99 == 254)
                  {
                    *v97 = v118;
                    v99 = v118;
                  }
                  else
                  {
                    v85[24] = v118;
                  }
                }
                goto LABEL_157;
              }
              if (a15)
              {
                v447 = _CFGetTSD(1u);
                if (v447)
                  v448 = (const __CFAllocator *)v447;
                else
                  v448 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
                v449 = CFDictionaryCreateMutable(v448, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                CFDictionarySetValue(v449, CFSTR("NSDebugDescription"), CFSTR("Overflow occurred"));
                v450 = CFErrorCreate(v448, CFSTR("NSCocoaErrorDomain"), 2048, v449);
                CFRelease(v449);
                v70 = 0;
                *a15 = v450;
              }
              else
              {
                v70 = 0;
              }
              v29 = v507;
LABEL_915:
              v44 = alloc;
              v45 = v463;
              goto LABEL_879;
            }
            if (v486)
              v115 = v85 + 16;
            else
              v115 = v85 + 12;
            v91 = v85 + 20;
            if (v107 >= 0x80000000)
            {
LABEL_282:
              if (a15)
              {
                v151 = _CFGetTSD(1u);
                if (v151)
                  v152 = (const __CFAllocator *)v151;
                else
                  v152 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
                v153 = CFDictionaryCreateMutable(v152, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                CFDictionarySetValue(v153, CFSTR("NSDebugDescription"), CFSTR("Overflow occurred"));
                v154 = CFErrorCreate(v152, CFSTR("NSCocoaErrorDomain"), 2048, v153);
                CFRelease(v153);
                v71 = v509;
                v70 = 0;
                *a15 = v154;
              }
              else
              {
                v70 = 0;
              }
              v29 = v507;
              v44 = alloc;
              v45 = v463;
              v69 = v481;
              goto LABEL_880;
            }
            *v115 = v107;
            v80 = v489;
          }
          switch(v102)
          {
            case ' ':
              if ((v92 & 4) != 0)
                goto LABEL_198;
              v92 |= 8u;
              goto LABEL_170;
            case '#':
              v96 = 1;
              goto LABEL_198;
            case '*':
              v99 = -2;
              *v97 = -2;
              goto LABEL_198;
            case '+':
              v92 = v92 & 0xFFFFFFF3 | 4;
              goto LABEL_170;
            case '-':
              v92 = v92 & 0xFFFFFFFC | 2;
              goto LABEL_170;
            case '.':
              if ((int)v83 >= (int)v78)
              {
                ImmutableFunnel3 = 0;
                v136 = 43;
LABEL_232:
                v89 = __src;
                *__src = v136;
                goto LABEL_248;
              }
              if (v79)
                v102 = *(unsigned __int8 *)(v79 + (int)v83);
              else
                v102 = *(unsigned __int16 *)(v80 + 2 * (int)v83);
              LODWORD(v83) = v83 + 1;
              v486 = 1;
              if (v102 == 42)
              {
                v100 = -2;
                *v467 = -2;
LABEL_173:
                v486 = 1;
                goto LABEL_198;
              }
              break;
            case '0':
              if (v486)
              {
                *v475 = 0;
                goto LABEL_173;
              }
              if ((v92 & 2) != 0)
              {
                v486 = 0;
              }
              else
              {
                v486 = 0;
                v92 |= 1u;
LABEL_170:
                *v91 = v92;
              }
              goto LABEL_198;
            case '@':
              if (v96)
              {
                v96 = 0;
                v98 = (int)v83;
LABEL_198:
                v89 = __src;
                goto LABEL_157;
              }
              ImmutableFunnel3 = 0;
              v138 = 37;
LABEL_245:
              v89 = __src;
              *__src = v138;
LABEL_246:
              v137 = 4;
LABEL_247:
              *(_WORD *)v85 = v137;
              goto LABEL_248;
            case 'A':
            case 'a':
              goto LABEL_213;
            case 'C':
              ImmutableFunnel3 = 0;
              v89 = __src;
              *__src = 41;
              v137 = 2;
              goto LABEL_247;
            case 'D':
            case 'U':
            case 'd':
            case 'i':
            case 'u':
              v134 = _CFExecutableLinkedOnOrAfter(8uLL);
              v91 = v85 + 20;
              if (v134)
                *v501 |= 0x20u;
              v71 = v509;
              if ((v102 & 0xFFDF) == 0x55)
                v135 = 4;
              else
                v135 = 1;
              v509[32 * count + 28] = v135;
              v79 = v491;
              v78 = range;
              v80 = v489;
              v84 = xmmword_182C98E20;
              goto LABEL_231;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              v124 = _CFExecutableLinkedOnOrAfter(8uLL);
              v91 = v85 + 20;
              if (v124)
                *v501 |= 0x20u;
              if (v102 - 65 >= 0x1A)
                v125 = v102;
              else
                v125 = v102 + 32;
              v71 = v509;
              v509[32 * count + 28] = ((v125 & 0xFFFE) == 102) | (2 * ((v125 & 0xFFFD) == 101));
              v79 = v491;
              v78 = range;
              v80 = v489;
              v84 = xmmword_182C98E20;
              if (v486 && *v475 == -1 && *v467 == 255)
                *v475 = 0;
LABEL_213:
              v89 = __src;
              *__src = 34;
              if (*(_WORD *)v85 == 5)
              {
                ImmutableFunnel3 = 0;
                goto LABEL_248;
              }
              ImmutableFunnel3 = 0;
              goto LABEL_246;
            case 'L':
              v119 = 5;
              goto LABEL_197;
            case 'O':
            case 'X':
            case 'o':
            case 'x':
LABEL_231:
              ImmutableFunnel3 = 0;
              v136 = 33;
              goto LABEL_232;
            case 'P':
              ImmutableFunnel3 = 0;
              v138 = 40;
              goto LABEL_245;
            case 'S':
              ImmutableFunnel3 = 0;
              v138 = 38;
              goto LABEL_245;
            case '[':
              if (!v95)
                v98 = (int)v83;
              v95 = 1;
              goto LABEL_198;
            case 'c':
              ImmutableFunnel3 = 0;
              v89 = __src;
              *__src = 33;
              v137 = 1;
              goto LABEL_247;
            case 'h':
              if ((int)v83 < (int)v78
                && (!v79
                  ? (v120 = *(unsigned __int16 *)(v80 + 2 * (int)v83))
                  : (v120 = *(unsigned __int8 *)(v79 + (int)v83)),
                    v120 == 104))
              {
                LODWORD(v83) = v83 + 1;
                v119 = 1;
              }
              else
              {
                v119 = 2;
              }
              goto LABEL_197;
            case 'j':
            case 'q':
            case 't':
            case 'z':
              goto LABEL_196;
            case 'l':
              if ((int)v83 < (int)v78)
              {
                v121 = v79 ? *(unsigned __int8 *)(v79 + (int)v83) : *(unsigned __int16 *)(v80 + 2 * (int)v83);
                if (v121 == 108)
                  LODWORD(v83) = v83 + 1;
              }
LABEL_196:
              v119 = 4;
LABEL_197:
              *(_WORD *)v85 = v119;
              goto LABEL_198;
            case 'n':
              ImmutableFunnel3 = 0;
              v138 = 42;
              goto LABEL_245;
            case 'p':
              ImmutableFunnel3 = 0;
              v138 = 35;
              goto LABEL_245;
            case 's':
              ImmutableFunnel3 = 0;
              v138 = 39;
              goto LABEL_245;
            default:
              *__src = 32;
              goto LABEL_279;
          }
        }
      }
      if (v102 >= 0x30 && v102 - 58 >= 7)
      {
        v104 = v102 == 95 || v102 - 91 >= 6;
        v105 = !v104;
        if (v102 <= 0x7A && !v105)
          goto LABEL_157;
      }
      if (v102 != 93)
        break;
      v116 = v101 - v98;
      v117 = v95 == 0;
      if (v95)
        v94 = 1;
      else
        v95 = 0;
      if (!v117)
        v93 = v116;
LABEL_157:
      if ((int)v83 >= (int)v78)
        goto LABEL_201;
    }
    if (v102 != 64)
    {
      v98 = -1;
      goto LABEL_157;
    }
    v126 = v92 | 0x40;
    if (!v94)
      v126 = v92;
    *v91 = v126 | 0x10;
    if (v94)
      v127 = v93;
    else
      v127 = v101 - v98;
    *v89 = 37;
    *(_WORD *)v85 = 4;
    if (v127 < 1)
    {
      ImmutableFunnel3 = 0;
      goto LABEL_248;
    }
    v128 = v89;
    if (v79)
    {
      v129 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding(v101);
        v79 = v491;
        v129 = __CFDefaultEightBitStringEncoding;
      }
      v130 = (int8x16_t *)(v79 + v98);
      v131 = v127;
      v132 = 2;
      v133 = -1;
    }
    else
    {
      v131 = 2 * v127;
      v130 = (int8x16_t *)(v80 + 2 * v98);
      v129 = 256;
      v132 = 16;
      v133 = (uint64_t)&__kCFAllocatorNull;
    }
    ImmutableFunnel3 = (const __CFString *)__CFStringCreateImmutableFunnel3(0, v130, v131, v129, v132, (const __CFAllocator *)v133, 0);
    v89 = v128;
    v71 = v509;
    v79 = v491;
    v78 = range;
    v80 = v489;
    v84 = xmmword_182C98E20;
    v91 = v501;
    if (*v128 != 32)
    {
LABEL_248:
      if ((*v91 & 0x10) == 0)
      {
        v82 = count;
LABEL_273:
        *v87 = v83 - v90;
        goto LABEL_274;
      }
      __srca = v89;
      if ((*v91 & 0x40) != 0)
      {
        if (!ImmutableFunnel3)
        {
          v142 = v496;
          *(_QWORD *)&v481[8 * v480] = v496;
LABEL_265:
          if (v142)
          {
            *v88 = v480;
            Value = CFDictionaryGetValue(v142, CFSTR("NSStringFormatSpecTypeKey"));
            v149 = CFDictionaryGetValue(v142, CFSTR("NSStringFormatValueTypeKey"));
            if (!Value || (v150 = v149, !CFEqual(Value, CFSTR("NSStringPluralRuleType"))))
            {
              ++v480;
              v71 = v509;
              v79 = v491;
              v78 = range;
              v80 = v489;
              v82 = count;
              v84 = xmmword_182C98E20;
              goto LABEL_273;
            }
            v71 = v509;
            v79 = v491;
            v78 = range;
            v80 = v489;
            v82 = count;
            v84 = xmmword_182C98E20;
            if (v150)
            {
              ++v480;
              goto LABEL_273;
            }
            v123 = 44;
            ++v480;
          }
          else
          {
            v123 = 32;
            v78 = range;
            v80 = v489;
            v82 = count;
            v84 = xmmword_182C98E20;
          }
          v89 = __srca;
          goto LABEL_272;
        }
        v557.length = CFStringGetLength(ImmutableFunnel3);
        v557.location = 0;
        if (CFStringCompareWithOptionsAndLocale(ImmutableFunnel3, CFSTR("tt"), v557, 0, 0))
        {
          v558.length = CFStringGetLength(ImmutableFunnel3);
          v140 = CFSTR("VocativeName");
          v558.location = 0;
          if (!CFStringFindWithOptionsAndLocale(ImmutableFunnel3, CFSTR("VocativeName"), v558, 8uLL, 0, 0))
          {
            MutableCopy = 0;
            v496 = 0;
            goto LABEL_263;
          }
        }
        else
        {
          v140 = CFSTR("TechnicalTerm");
        }
        v143 = CFDictionaryGetValue((CFDictionaryRef)&unk_1E14889E0, CFSTR("NSStringFormatFamilyInfoKey"));
        InputIdentifierFormatterMappingFromDescriptor = (const void *)_CFStringGetInputIdentifierFormatterMappingFromDescriptor((uint64_t)v143);
        v145 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)&unk_1E14889E0, CFSTR("NSStringFormatRuleInfoKey"));
        v146 = (const __CFDictionary *)CFDictionaryGetValue(v145, v140);
        v147 = CFDictionaryGetCount(v146);
        MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v147, v146);
        CFDictionaryAddValue(MutableCopy, CFSTR("NSStringFormatFamilyInfoKey"), InputIdentifierFormatterMappingFromDescriptor);
        v496 = MutableCopy;
        goto LABEL_263;
      }
      if (theDict && ImmutableFunnel3)
      {
        MutableCopy = (__CFDictionary *)CFDictionaryGetValue(theDict, ImmutableFunnel3);
LABEL_263:
        v141 = (__CFDictionary **)&v481[8 * v480];
        *v141 = MutableCopy;
        goto LABEL_264;
      }
      v141 = (__CFDictionary **)&v481[8 * v480];
      *v141 = 0;
      if (ImmutableFunnel3)
      {
LABEL_264:
        CFRelease(ImmutableFunnel3);
        v142 = *v141;
        v71 = v509;
        v79 = v491;
        goto LABEL_265;
      }
      v123 = 32;
      v82 = count;
LABEL_272:
      *v89 = v123;
      goto LABEL_273;
    }
LABEL_279:
    *v86 = v90 + 1;
    *v87 = v83 + ~v90;
    *v91 |= 0x80u;
    v82 = count;
LABEL_274:
    ++v82;
  }
  while (v78 > (int)v83);
  v29 = v507;
  v73 = (__objc2_class **)alloc;
  p_vtable = (void **)(NSTimer + 24);
LABEL_288:
  v155 = (int)a9;
  v156 = 3 * (v49 + (_DWORD)a9) + 1;
  v157 = v552;
  if (v156 >= 62)
  {
    v157 = (_BYTE *)CFAllocatorAllocateTyped(v73, 16 * (3 * (v49 + (_DWORD)a9) + 1), 0x1082040F23858EBLL, 0);
    if (v157 != v552)
    {
      if (__CFOASafe)
        __CFSetLastAllocationEventName();
    }
  }
  bzero(v157, 16 * v156);
  v514 = 0;
  if (v480 >= 1)
    v514 = a13;
  __srcb = v157;
  v71 = v509;
  counta = v82;
  if ((_DWORD)v82)
  {
    v159 = 0;
    if (v466)
      v160 = theDict == 0;
    else
      v160 = 1;
    v161 = !v160;
    v468 = v161;
    v162 = v82;
    v502 = v156;
    v472 = a9;
    v493 = v82;
    while (2)
    {
      v163 = &v71[32 * v159];
      v164 = *((unsigned __int16 *)v163 + 1);
      v165 = (1 << v164) & 0x180100000001;
      if (v164 <= 0x2C && v165 != 0)
        goto LABEL_306;
      v167 = v502 - 1;
      v168 = v163 + 24;
      if (v502 <= (char)v163[24])
        v167 = (char)v163[24];
      v170 = v163 + 25;
      v169 = (char)v163[25];
      if (v167 > v169)
        v169 = v167;
      v171 = v163 + 26;
      if (v169 <= (char)v163[26])
        v169 = (char)v163[26];
      if (v502 > v169)
      {
        v172 = v163[26];
        goto LABEL_330;
      }
      v173 = 3 * v169 + 1;
      if (v169 < 21)
      {
        v174 = __srcb;
      }
      else
      {
        location = CFAllocatorAllocateTyped(alloc, 16 * (3 * v169 + 1), 0x1082040F23858EBLL, 0);
        v174 = (char *)location;
        if ((_BYTE *)location != v552 && __CFOASafe != 0)
        {
          __CFSetLastAllocationEventName();
          goto LABEL_325;
        }
        if ((_BYTE *)location == v552)
        {
          v71 = v509;
          v174 = __srcb;
        }
        else
        {
LABEL_325:
          memcpy(v174, __srcb, 16 * v502);
          bzero(&v174[16 * v502], 16 * (v173 - (uint64_t)v502));
          if (__srcb != v552)
            CFAllocatorDeallocate(alloc, __srcb);
          v29 = v507;
          v71 = v509;
          p_vtable = NSTimer.vtable;
        }
        v170 = v163 + 25;
        v171 = v163 + 26;
        v168 = v163 + 24;
      }
      v172 = *v171;
      __srcb = v174;
      v502 = v173;
LABEL_330:
      if (v172 == 254)
      {
        *v171 = v155;
        if (((char)v155 - 127) <= 0xFFFFFEFF)
          goto LABEL_903;
        ++v155;
      }
      if (*v170 == 254)
      {
        *v170 = v155;
        if (((char)v155 - 127) <= 0xFFFFFEFF)
          goto LABEL_903;
        ++v155;
      }
      v176 = *v168;
      if (v176 == 255)
      {
        *v168 = v155;
        if (((char)v155 - 127) <= 0xFFFFFEFF)
        {
LABEL_903:
          if (a15)
          {
            v439 = _CFGetTSD(1u);
            if (v439)
              v440 = (const __CFAllocator *)v439;
            else
              v440 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
            v441 = CFDictionaryCreateMutable(v440, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue(v441, CFSTR("NSDebugDescription"), CFSTR("Overflow occurred"));
            v442 = CFErrorCreate(v440, CFSTR("NSCocoaErrorDomain"), 2048, v441);
            CFRelease(v441);
            v71 = v509;
            *a15 = v442;
          }
          v44 = alloc;
          goto LABEL_909;
        }
        LOBYTE(v176) = v155++;
      }
      v177 = &__srcb[16 * (char)v176];
      *((_WORD *)v177 + 1) = *(_WORD *)v163;
      v178 = *((unsigned __int16 *)v163 + 1);
      *(_WORD *)v177 = v178;
      v179 = (char)v71[32 * v159 + 27];
      if (v179 == -1)
      {
        v75 = v178 == 32;
        v188 = v468;
        if (v75)
          v188 = 0;
        if (v188 == 1)
        {
          v189 = v170;
          v190 = &v71[32 * v159];
          v191 = *((int *)v190 + 1);
          v192 = *((int *)v190 + 2);
          v44 = alloc;
          v193 = v491;
          if (v491)
          {
            v194 = *((unsigned int *)p_vtable + 908);
            if ((_DWORD)v194 == -1)
            {
              __CFStringComputeEightBitStringEncoding(location);
              v193 = v491;
              v194 = *((unsigned int *)p_vtable + 908);
            }
            v195 = (int8x16_t *)(v193 + v191);
            v196 = (__objc2_class **)alloc;
            v197 = v192;
            v198 = 18;
          }
          else
          {
            v197 = 2 * v192;
            v195 = (int8x16_t *)(v489 + 2 * v191);
            v196 = (__objc2_class **)alloc;
            v194 = 256;
            v198 = 16;
          }
          v229 = __CFStringCreateImmutableFunnel3(v196, v195, v197, v194, v198, (const __CFAllocator *)&__kCFAllocatorNull, 0);
          v69 = v481;
          if (!v229)
          {
            v444 = CFDictionaryCreateMutable(alloc, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue(v444, CFSTR("NSDebugDescription"), CFSTR("Unable to allocate CFString to validate format specifiers"));
            *a15 = CFErrorCreate(alloc, CFSTR("NSCocoaErrorDomain"), 2048, v444);
            CFRelease(v444);
            v45 = v463;
LABEL_912:
            v71 = v509;
LABEL_913:
            v70 = __srcb;
            goto LABEL_880;
          }
          v230 = __CFStringValidateFormat((uint64_t)v466, (uint64_t)v229);
          CFRelease(v229);
          v71 = v509;
          v472 = (CFMutableStringRef)v230;
          v170 = v189;
          if (v230 < 0)
          {
            v44 = alloc;
            v45 = v463;
            goto LABEL_913;
          }
        }
      }
      else
      {
        v487 = v168;
        v180 = v170;
        location = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)&v481[8 * v179], CFSTR("NSStringFormatValueTypeKey"));
        if (location)
        {
          v181 = (const __CFString *)location;
          CharactersPtr = CFStringGetCharactersPtr((CFStringRef)location);
          v183 = (unint64_t)CharactersPtr;
          v184 = *((_DWORD *)p_vtable + 908);
          if (v184 == -1)
          {
            __CFStringComputeEightBitStringEncoding(CharactersPtr);
            v184 = *((_DWORD *)p_vtable + 908);
          }
          CStringPtrInternal = _CFStringGetCStringPtrInternal((uint64_t)v181, v184, 1, 1);
          location = CFStringGetLength(v181);
          v186 = location;
          if (v183 | CStringPtrInternal)
          {
            v187 = 0;
          }
          else
          {
            v183 = CFAllocatorAllocateTyped(alloc, 2 * location, 0x1000040BDFB0063, 0);
            v556.location = 0;
            v556.length = v186;
            CFStringGetCharacters(v181, v556, (UniChar *)v183);
            v187 = (void *)v183;
          }
          v470 = v181;
          if ((int)v186 >= 1)
          {
            v199 = 0;
            v200 = 0;
            v201 = 0;
            cf2 = 0;
            v202 = 0;
            v203 = -1;
            v204 = -1;
            v205 = -1;
            while (1)
            {
              if (CStringPtrInternal)
                v206 = *(unsigned __int8 *)(CStringPtrInternal + v202);
              else
                v206 = *(unsigned __int16 *)(v183 + 2 * v202);
              ++v202;
              if (v204 < 0)
              {
                while (2)
                {
                  v211 = 0;
                  location = v202;
                  if (v202 <= (int)v186)
                    v212 = v186;
                  else
                    v212 = v202;
                  v213 = (UniChar *)(v183 + 2 * v202);
                  v214 = v202;
                  v215 = v202 - (uint64_t)v212;
                  while (2)
                  {
                    v216 = (UniChar *)v183;
                    v217 = 1;
                    v218 = 33;
                    switch(v206)
                    {
                      case ' ':
                      case '+':
                      case '-':
                        v202 += v211;
                        goto LABEL_421;
                      case '#':
                        v202 += v211;
                        v200 = 1;
                        goto LABEL_421;
                      case '*':
                        v202 += v211;
                        v203 = -2;
                        goto LABEL_421;
                      case '.':
                        if (!(v215 + v211))
                          goto LABEL_455;
                        if (CStringPtrInternal)
                          v206 = *(unsigned __int8 *)(CStringPtrInternal + v202 + v211);
                        else
                          v206 = v213[v211];
                        v183 = (unint64_t)v216;
                        ++v211;
                        ++v214;
                        v201 = 1;
                        if (v206 != 42)
                          continue;
                        v202 += v211;
                        v205 = -2;
                        goto LABEL_422;
                      case '0':
                        v202 += v211;
                        v201 = v201;
                        goto LABEL_421;
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                        v219 = 0;
                        v220 = v202 + v211;
                        v202 = v214;
                        v183 = (unint64_t)v216;
                        break;
                      case '@':
                        if (!v200)
                          goto LABEL_473;
                        v200 = 0;
                        v204 = v211 + v202;
                        v202 += v211;
                        goto LABEL_421;
                      case 'A':
                      case 'a':
                        goto LABEL_448;
                      case 'C':
                        v217 = 2;
                        v218 = 41;
                        goto LABEL_457;
                      case 'D':
                      case 'U':
                      case 'd':
                      case 'i':
                      case 'u':
                        location = _CFExecutableLinkedOnOrAfter(8uLL);
                        goto LABEL_453;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        location = _CFExecutableLinkedOnOrAfter(8uLL);
LABEL_448:
                        if (cf2 == 5)
                          v217 = 5;
                        else
                          v217 = 4;
                        v218 = 34;
                        goto LABEL_457;
                      case 'L':
                        v202 += v211;
                        v222 = 5;
                        goto LABEL_408;
                      case 'O':
                      case 'X':
                      case 'o':
                      case 'x':
LABEL_453:
                        v218 = 33;
                        goto LABEL_456;
                      case 'P':
                        v217 = 4;
                        v218 = 40;
                        goto LABEL_457;
                      case 'S':
                        v217 = 4;
                        v218 = 38;
                        goto LABEL_457;
                      case '[':
                        v223 = v211 + v202;
                        v202 += v211;
                        if (!v199)
                          v204 = v223;
                        v199 = 1;
                        goto LABEL_421;
                      case 'c':
                        goto LABEL_457;
                      case 'h':
                        v224 = v211 + v202;
                        if ((int)v211 + v202 >= (int)v186)
                        {
                          v227 = 2;
                          goto LABEL_420;
                        }
                        if (CStringPtrInternal)
                          v225 = *(unsigned __int8 *)(CStringPtrInternal + v202 + v211);
                        else
                          v225 = v213[v211];
                        v183 = (unint64_t)v216;
                        if (v225 == 104)
                          ++v202;
                        v202 += v211;
                        if (v225 == 104)
                          v228 = 1;
                        else
                          v228 = 2;
                        goto LABEL_434;
                      case 'j':
                      case 'q':
                      case 't':
                      case 'z':
                        v202 += v211;
                        v222 = 4;
LABEL_408:
                        cf2 = v222;
                        goto LABEL_421;
                      case 'l':
                        v224 = v211 + v202;
                        if ((int)v211 + v202 >= (int)v186)
                        {
                          v227 = 4;
LABEL_420:
                          cf2 = v227;
                          v202 = v224;
                          goto LABEL_421;
                        }
                        if (CStringPtrInternal)
                          v226 = *(unsigned __int8 *)(CStringPtrInternal + v202 + v211);
                        else
                          v226 = v213[v211];
                        v183 = (unint64_t)v216;
                        if (v226 == 108)
                          ++v202;
                        v202 += v211;
                        v228 = 4;
LABEL_434:
                        cf2 = v228;
                        goto LABEL_422;
                      case 'n':
                        v217 = 4;
                        v218 = 42;
                        goto LABEL_457;
                      case 'p':
                        v217 = 4;
                        v218 = 35;
                        goto LABEL_457;
                      case 's':
                        v217 = 4;
                        v218 = 39;
                        goto LABEL_457;
                      default:
                        v217 = cf2;
                        v218 = 32;
                        goto LABEL_457;
                    }
                    break;
                  }
                  do
                  {
                    location = 10 * v219;
                    if ((unsigned __int128)(v219 * (__int128)10) >> 64 != (10 * v219) >> 63)
                      goto LABEL_454;
                    v221 = v206 - 48;
                    v219 = location + v221;
                    if (__OFADD__(location, v221))
                      goto LABEL_454;
                    if (v220 >= (int)v186)
                    {
LABEL_455:
                      v218 = 43;
                      goto LABEL_456;
                    }
                    if (CStringPtrInternal)
                      v206 = *(unsigned __int8 *)(CStringPtrInternal + v220);
                    else
                      v206 = v216[v220];
                    ++v220;
                    location = v206 - 48;
                    ++v202;
                  }
                  while (location < 0xA);
                  if (v206 != 36)
                  {
                    if (v219 <= 0x7FFFFFFF)
                      continue;
LABEL_454:
                    v218 = 0;
LABEL_456:
                    v217 = cf2;
                    goto LABEL_457;
                  }
                  break;
                }
                if (v219 > 127)
                  goto LABEL_454;
                if (v205 == 254)
                {
                  v205 = v219 - 1;
                }
                else if (v203 == 254)
                {
                  v203 = v219 - 1;
                }
LABEL_421:
                v183 = (unint64_t)v216;
              }
              else
              {
                v207 = v206 >= 0x30 && v206 - 58 >= 7;
                if (!v207
                  || (v206 != 95 ? (v208 = v206 - 91 >= 6) : (v208 = 1),
                      v208 ? (v209 = 0) : (v209 = 1),
                      v206 <= 0x7A ? (v210 = v209 == 0) : (v210 = 0),
                      !v210))
                {
                  if (v206 != 93)
                  {
                    if (v206 == 64)
                    {
LABEL_473:
                      v217 = 4;
                      v218 = 37;
                      goto LABEL_457;
                    }
                    v204 = -1;
                  }
                }
              }
LABEL_422:
              if (v202 >= (int)v186)
              {
                v217 = cf2;
                goto LABEL_442;
              }
            }
          }
          v217 = 0;
LABEL_442:
          v218 = 43;
LABEL_457:
          if (v187)
            CFAllocatorDeallocate(alloc, v187);
          v29 = v507;
          p_vtable = (void **)(NSTimer + 24);
          if (!v466)
            goto LABEL_465;
          v231 = CFStringFind(v470, CFSTR("%"), 0);
          location = v231.location;
          if (v231.location != -1 || v231.length)
          {
            v44 = alloc;
            v443 = CFDictionaryCreateMutable(alloc, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue(v443, CFSTR("NSDebugDescription"), CFSTR("Invalid format for NSStringFormatValueTypeKey"));
            *a15 = CFErrorCreate(alloc, CFSTR("NSCocoaErrorDomain"), 2048, v443);
            CFRelease(v443);
            v45 = v463;
            v69 = v481;
            goto LABEL_912;
          }
          if (((0xC0100000000uLL >> v218) & 1) != 0)
          {
LABEL_465:
            v71 = v509;
          }
          else
          {
            chars[0] = v217;
            chars[1] = v218;
            *(_OWORD *)&chars[2] = *(_OWORD *)(v163 + 4);
            *(_OWORD *)&chars[8] = *((_OWORD *)v163 + 1);
            location = __CFStringValidateFormatSpec(v466, chars, (uint64_t)v472);
            v71 = v509;
            v472 = (CFMutableStringRef)location;
            if (location < 0)
            {
              v44 = alloc;
              v445 = CFStringCreateWithFormat(alloc, 0, CFSTR("NSStringFormatValueTypeKey '%@' does not match expected specifiers '%@'"), v470, v466);
              v446 = CFDictionaryCreateMutable(alloc, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              CFDictionarySetValue(v446, CFSTR("NSDebugDescription"), v445);
              *a15 = CFErrorCreate(alloc, CFSTR("NSCocoaErrorDomain"), 2048, v446);
              CFRelease(v446);
              CFRelease(v445);
              v71 = v509;
LABEL_909:
              v45 = v463;
              v69 = v481;
              goto LABEL_913;
            }
          }
          v232 = (UniChar *)&__srcb[16 * *v487];
          v232[1] = v217;
          *v232 = v218;
        }
        else
        {
          v71 = v509;
        }
        v170 = v180;
      }
      v233 = (char)*v171;
      if (v233 != -1)
        *(_DWORD *)&__srcb[16 * v233] = 33;
      v234 = (char)*v170;
      if (v234 != -1)
        *(_DWORD *)&__srcb[16 * v234] = 33;
      v162 = v493;
LABEL_306:
      if (++v159 == v162)
        goto LABEL_484;
      continue;
    }
  }
  v502 = 3 * (v49 + (_DWORD)a9) + 1;
LABEL_484:
  if (v502 >= 1)
  {
    v235 = 0;
    v236 = 0;
    v237 = a11;
    v238 = (__int16 *)__srcb;
    do
    {
      if (a11 && v235 < a12 && !*v238)
        *(_OWORD *)v238 = *v237;
      v239 = *v238;
      if (v239 > 0x2C)
      {
LABEL_923:
        __break(1u);
        return;
      }
      if (((1 << v239) & 0x7EE00000000) != 0)
      {
        v236 = v235;
      }
      else if (((1 << v239) & 0x180100000001) == 0)
      {
        goto LABEL_923;
      }
      ++v235;
      v238 += 8;
      ++v237;
    }
    while (v502 != v235);
    v240 = 0;
    v241 = v236;
    v242 = __srcb + 8;
    do
    {
      switch(*((_WORD *)v242 - 4))
      {
        case '!':
        case ')':
          switch(*((_WORD *)v242 - 3))
          {
            case 1:
              v245 = (char *)a13;
              a13 += 4;
              v244 = *v245;
              break;
            case 2:
              v249 = a13;
              a13 += 4;
              v244 = *v249;
              break;
            case 4:
              goto LABEL_497;
            default:
              v248 = a13;
              a13 += 4;
              v244 = *(int *)v248;
              break;
          }
          goto LABEL_498;
        case '"':
          v247 = a13;
          a13 += 4;
          *v242 = *(_QWORD *)v247;
          break;
        case '#':
        case '%':
        case '&':
        case '\'':
        case '(':
LABEL_497:
          v243 = a13;
          a13 += 4;
          v244 = *(_QWORD *)v243;
LABEL_498:
          *v242 = v244;
          break;
        case '$':
          break;
        case '*':
          a13 += 4;
          *v242 = &ptr.i64[1];
          break;
        default:
          if (!*((_WORD *)v242 - 4))
          {
            v246 = dyld_program_sdk_at_least();
            if (v240 < v241)
            {
              if (v246)
                a13 += 4;
            }
          }
          break;
      }
      v242 += 2;
      ++v240;
    }
    while (v502 != v240);
  }
  v250 = v502;
  v70 = __srcb;
  if (a11)
    v251 = (char *)a11;
  else
    v251 = __srcb;
  v494 = v502;
  if (a11)
    v250 = a12;
  v459 = v250;
  v460 = v251;
  if (!counta)
  {
    v435 = 0;
    v45 = v463;
    goto LABEL_878;
  }
  v503 = counta;
  v252 = (CFIndex)malloc_type_calloc(counta, 0x20uLL, 0x10000408E5DAE1CuLL);
  v488 = (char *)v252;
  v253 = 0;
  cf2a = 0;
  key = 0;
  v457 = 0;
  v254 = v509;
  v255 = v509 - 8;
  v256 = 1;
  while (2)
  {
    ptr.i16[0] = 0;
    v257 = &v254[32 * v253];
    v259 = v257 + 26;
    v258 = (char)v257[26];
    if (v258 == -1)
    {
      v260 = 0;
      v261 = 0;
    }
    else
    {
      v260 = v70[4 * v258 + 2];
      v261 = 1;
    }
    countb = &v254[32 * v253];
    v264 = (char)v257[25];
    v263 = v257 + 25;
    v262 = v264;
    if (v264 == -1)
    {
      v265 = 0;
      v266 = 0;
    }
    else
    {
      v265 = v70[4 * v262 + 2];
      v266 = 1;
    }
    v267 = &v254[32 * v253];
    v270 = *((__int16 *)v267 + 1);
    v269 = v267 + 2;
    v268 = v270;
    v271 = *(_DWORD *)(v269 + 10);
    if (v271 == -1)
      v272 = v260;
    else
      v272 = v271;
    if (v271 == -1)
      v273 = v261;
    else
      v273 = 1;
    v274 = *(_DWORD *)(v269 + 14);
    if (v274 == -1)
      v275 = v265;
    else
      v275 = v274;
    if (v274 == -1)
      v276 = v266;
    else
      v276 = 1;
    switch(v268)
    {
      case ' ':
        if (v507)
        {
          v307 = (unint64_t *)v508;
          v252 = CFStringGetLength(v508);
          v254 = v509;
          v308 = v252;
        }
        else
        {
          v308 = 0;
          v307 = (unint64_t *)v508;
        }
        v351 = &v254[32 * v253];
        v353 = *((int *)v351 + 1);
        v352 = *((int *)v351 + 2);
        v354 = v491;
        if (v491)
        {
          v355 = __CFDefaultEightBitStringEncoding;
          if (__CFDefaultEightBitStringEncoding == -1)
          {
            __CFStringComputeEightBitStringEncoding(v252);
            v354 = v491;
            v355 = __CFDefaultEightBitStringEncoding;
          }
          __CFStringAppendBytes(v307, (unsigned __int8 *)(v354 + v353), v352, v355);
          if (v507)
          {
LABEL_636:
            v356 = CFStringGetLength((CFStringRef)v307);
            goto LABEL_652;
          }
        }
        else
        {
          CFStringAppendCharacters((CFMutableStringRef)v307, (const UniChar *)(v489 + 2 * v353), v352);
          if (v507)
            goto LABEL_636;
        }
        v356 = 0;
LABEL_652:
        *(_OWORD *)chars = *countb;
        *(_OWORD *)&chars[8] = countb[1];
        v360 = v500;
        v359 = v503;
        v70 = __srcb;
LABEL_656:
        v361 = (uint64_t)v70;
        v362 = v494;
        v313 = v308;
LABEL_723:
        v379 = 0;
        goto LABEL_828;
      case '!':
      case '"':
        if (!v498 || (v254[32 * v253 + 20] & 0x20) == 0)
          goto LABEL_539;
        if (v507)
        {
          v348 = v272;
          cStra = (char *)CFStringGetLength(v508);
          v70 = __srcb;
          v349 = __CFStringFormatLocalizedNumber(v508, v499, (uint64_t)__srcb, (uint64_t)countb, v348, v275, v276);
          v272 = v348;
          v254 = v509;
          if (v349)
          {
            v350 = v508;
LABEL_689:
            v356 = CFStringGetLength(v350);
LABEL_691:
            v313 = (CFIndex)cStra;
            goto LABEL_692;
          }
        }
        else
        {
          v372 = v272;
          v373 = __CFStringFormatLocalizedNumber(v508, v499, (uint64_t)v70, (uint64_t)countb, v272, v275, v276);
          v272 = v372;
          v254 = v509;
          if (v373)
          {
            v313 = 0;
            v356 = 0;
LABEL_692:
            v369 = countb;
LABEL_722:
            *(_OWORD *)chars = *v369;
            *(_OWORD *)&chars[8] = v369[1];
            v360 = v500;
            v359 = v503;
            v361 = (uint64_t)v70;
            v362 = v494;
            goto LABEL_723;
          }
        }
LABEL_539:
        v277 = &v254[32 * v253];
        v279 = *((int *)v277 + 2);
        v278 = (int *)(v277 + 8);
        v280 = v279 + 1;
        if ((v279 + 1) < 0x81)
        {
          v282 = 0;
          v283 = (const char *)v549;
        }
        else
        {
          v281 = v272;
          v282 = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v280, 581079708, 0);
          v272 = v281;
          v283 = (const char *)v282;
        }
        v476 = (void *)v272;
        v473 = (CFMutableStringRef)v282;
        if ((int)v275 + (int)v272 < 17)
        {
          v290 = 0;
          v291 = chars;
          v289 = 528;
        }
        else
        {
          v289 = (int)v275 + (int)v272 + 512;
          v290 = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v289, 1565541268, 0);
          v291 = (UniChar *)v290;
        }
        v292 = v509;
        v293 = *(int *)&v509[32 * v253 + 4];
        v294 = *v278;
        if (v491)
        {
          if (v294 >= 1)
          {
            v295 = 0;
            v296 = 0;
            do
            {
              v297 = *(unsigned __int8 *)(v491 + v295 + v293);
              if (v297 == 36)
              {
                if ((v296 & 0x80000000) == 0)
                {
                  v298 = &v283[v296 - 1];
                  do
                  {
                    v299 = *(unsigned __int8 *)v298--;
                    --v296;
                  }
                  while ((v299 - 48) < 0xA);
                }
              }
              else
              {
                v283[v296] = v297;
                v294 = *v278;
              }
              ++v296;
              ++v295;
            }
            while (v295 < v294);
            goto LABEL_571;
          }
        }
        else if (v294 >= 1)
        {
          v300 = 0;
          v296 = 0;
          do
          {
            v301 = *(unsigned __int16 *)(v489 + 2 * (v300 + v293));
            if (v301 == 36)
            {
              if ((v296 & 0x80000000) == 0)
              {
                v302 = &v283[v296 - 1];
                do
                {
                  v303 = *(unsigned __int8 *)v302--;
                  --v296;
                }
                while ((v303 - 48) < 0xA);
              }
            }
            else
            {
              v283[v296] = v301;
              v294 = *v278;
            }
            ++v296;
            ++v300;
          }
          while (v300 < v294);
LABEL_571:
          v471 = (__CFString *)v290;
          v283[v296] = 0;
          cStrb = (char *)v291;
          *((_BYTE *)v291 + v289 - 1) = 0;
          if (v507)
          {
            v290 = CFStringGetLength(v508);
            v292 = v509;
            v469 = v290;
          }
          else
          {
            v469 = 0;
          }
          switch(*(_WORD *)v269)
          {
            case '!':
              v304 = *(void **)&__srcb[16 * (char)v292[32 * v253 + 24] + 8];
              if (*(_WORD *)countb == 4)
              {
                v344 = *v263;
                v345 = v476;
                v306 = cStrb;
                if (*v259 != 255)
                  goto LABEL_658;
              }
              else
              {
                v344 = *v263;
                v345 = v476;
                v306 = cStrb;
                if (*v259 != 255)
                {
LABEL_658:
                  if (v344 == 255)
                    v290 = snprintf_l(v306, 0x1FFuLL, 0, v283, v345, *(_QWORD *)&__srcb[16 * (char)v292[32 * v253 + 24] + 8], v452, v453, v454, v455, v456);
                  else
                    v290 = snprintf_l(v306, 0x1FFuLL, 0, v283, v345, v275, *(_QWORD *)&__srcb[16 * (char)v292[32 * v253 + 24] + 8], v453, v454, v455, v456);
                  goto LABEL_736;
                }
              }
              if (v344 != 255)
                goto LABEL_630;
LABEL_662:
              v290 = snprintf_l(v306, 0x1FFuLL, 0, v283, v304, v451, v452, v453, v454, v455, v456);
LABEL_736:
              v383 = __CFDefaultEightBitStringEncoding;
              if (__CFDefaultEightBitStringEncoding == -1)
              {
                __CFStringComputeEightBitStringEncoding(v290);
                v383 = __CFDefaultEightBitStringEncoding;
              }
              v384 = v508;
              CFStringAppendCString(v508, cStrb, v383);
              v386 = countb;
              v385 = v507;
LABEL_739:
              v70 = __srcb;
              if (v385)
                v387 = CFStringGetLength(v384);
              else
                v387 = 0;
              v388 = v386[1];
              v513[0] = *v386;
              v513[1] = v388;
              _CFStringFormatAppendMetadata(v500, v503, (uint64_t)__srcb, v494, (uint64_t)v513, v469, v387, 0);
              if (v471)
                CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v471);
              if (v473)
                CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v473);
              break;
            case '"':
              v346 = *(double *)&__srcb[16 * (char)v292[32 * v253 + 24] + 8];
              v347 = *v263;
              if (*v259 == 255)
              {
                if (v347 == 255)
                {
                  v290 = snprintf_l(cStrb, 0x1FFuLL, 0, v283, v346, *(_QWORD *)&__srcb[16 * (char)v292[32 * v253 + 24] + 8]);
                }
                else
                {
                  v451 = *(_QWORD *)&__srcb[16 * (char)v292[32 * v253 + 24] + 8];
                  v290 = snprintf_l(cStrb, 0x1FFuLL, 0, v283, v346, v275);
                }
              }
              else
              {
                if (v347 == 255)
                {
                  v451 = *(_QWORD *)&__srcb[16 * (char)v292[32 * v253 + 24] + 8];
                }
                else
                {
                  v452 = *(char **)&__srcb[16 * (char)v292[32 * v253 + 24] + 8];
                  v451 = v275;
                }
                v290 = snprintf_l(cStrb, 0x1FFuLL, 0, v283, v346, v476);
              }
              if (!v499)
                goto LABEL_736;
              v380 = CFGetTypeID(v499);
              v290 = (uint64_t)(v380 == CFLocaleGetTypeID()
                             ? CFLocaleGetValue((CFLocaleRef)v499, CFSTR("kCFLocaleDecimalSeparatorKey"))
                             : CFDictionaryGetValue((CFDictionaryRef)v499, CFSTR("NSDecimalSeparator")));
              v381 = (const __CFString *)v290;
              if (!v290)
                goto LABEL_736;
              v382 = cStrb + 1;
              while (2)
              {
                if (!*(v382 - 1))
                  goto LABEL_736;
                if (*(v382 - 1) != 46)
                {
                  ++v382;
                  continue;
                }
                break;
              }
              *((_BYTE *)v382 - 1) = 0;
              v394 = __CFDefaultEightBitStringEncoding;
              v385 = v507;
              v384 = v508;
              v386 = countb;
              if (__CFDefaultEightBitStringEncoding == -1)
              {
                __CFStringComputeEightBitStringEncoding(v290);
                v394 = __CFDefaultEightBitStringEncoding;
              }
              CFStringAppendCString(v508, cStrb, v394);
              CFStringAppend(v508, v381);
              v396 = __CFDefaultEightBitStringEncoding;
              if (__CFDefaultEightBitStringEncoding == -1)
              {
                __CFStringComputeEightBitStringEncoding(v395);
                v396 = __CFDefaultEightBitStringEncoding;
              }
              CFStringAppendCString(v508, v382, v396);
              goto LABEL_739;
            case '#':
            case '*':
              v304 = *(void **)&__srcb[16 * (char)v292[32 * v253 + 24] + 8];
              v305 = *v263;
              if (*v259 != 255)
              {
                v306 = cStrb;
                if (v305 == 255)
                {
                  v451 = *(_QWORD *)&__srcb[16 * (char)v292[32 * v253 + 24] + 8];
                }
                else
                {
                  v451 = v275;
                  v452 = *(char **)&__srcb[16 * (char)v292[32 * v253 + 24] + 8];
                }
                v304 = v476;
                goto LABEL_662;
              }
              v306 = cStrb;
              if (v305 == 255)
                goto LABEL_662;
LABEL_630:
              v290 = snprintf_l(v306, 0x1FFuLL, 0, v283, v275, v304, v452, v453, v454, v455, v456);
              goto LABEL_736;
            default:
              goto LABEL_736;
          }
          goto LABEL_829;
        }
        v296 = 0;
        goto LABEL_571;
      case '#':
        goto LABEL_539;
      case '%':
      case ',':
        v284 = v272;
        if (v507)
        {
          v285 = CFStringGetLength(v508);
          v254 = v509;
          cStr = (char *)v285;
        }
        else
        {
          cStr = 0;
        }
        v314 = &v254[32 * v253];
        v315 = v314 + 27;
        if (v314[27] == 255)
        {
          v324 = (char)v314[24];
          v323 = v314 + 24;
          v325 = *(_QWORD *)&__srcb[16 * v324 + 8];
          if (!v325)
            goto LABEL_819;
          if (v490)
          {
            LOBYTE(chars[0]) = 0;
            v326 = __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_CONTEXT__(v490, v325, (uint64_t)theString);
            v327 = (uint64_t)v499;
            if (LOBYTE(chars[0]))
            {
              v328 = (const __CFString *)CFRetain(CFSTR("%@NSCONTEXT"));
              v329 = countb;
              v330 = countb[1];
              v331 = &v488[32 * (int)cf2a];
              *(_OWORD *)v331 = *countb;
              *((_OWORD *)v331 + 1) = v330;
              v332 = (cf2a + 1);
              v333 = v508;
            }
            else
            {
              v328 = (const __CFString *)v326;
              v333 = v508;
              v332 = cf2a;
              v329 = countb;
            }
            v374 = cStr;
            cf2a = v332;
            if (v328)
              goto LABEL_755;
            v325 = *(_QWORD *)&__srcb[16 * *v323 + 8];
          }
          else
          {
            v333 = v508;
            v327 = (uint64_t)v499;
            v329 = countb;
            v374 = cStr;
          }
          if (v495)
          {
            v328 = (const __CFString *)__CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_LOCALE__(v495, v325, v327);
            v70 = __srcb;
            if (!v328)
              goto LABEL_751;
            goto LABEL_756;
          }
          v390 = __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_LOCALE__((uint64_t (*)(uint64_t, uint64_t))__CFCopyFormattingDescription, v325, v327);
          if (!v390)
          {
            v413 = *v323;
            v70 = __srcb;
            v328 = __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT__(*(const void **)&__srcb[16 * v413 + 8]);
            if (!v328)
            {
LABEL_751:
              CFStringAppendCString(v333, "(null description)", 0x600u);
              v389 = 0;
              if (!v507)
                goto LABEL_769;
              goto LABEL_826;
            }
LABEL_756:
            v391 = __CFStringAppendFormatCore_disableIsolates;
            if (__CFStringAppendFormatCore_disableIsolates == 255)
            {
              if (dyld_program_sdk_at_least())
                v391 = __CFgetenv("CFStringDisableIsolates") != 0;
              else
                v391 = 1;
              __CFStringAppendFormatCore_disableIsolates = v391;
            }
            v75 = v391 == 0;
            v392 = v498;
            if (!v75)
              v392 = 0;
            if (!v392)
            {
              CFStringAppend(v333, v328);
LABEL_767:
              v389 = 0;
LABEL_768:
              CFRelease(v328);
              if (!v507)
                goto LABEL_769;
              goto LABEL_826;
            }
            if ((key & 1) != 0)
              goto LABEL_765;
            v393 = CFStringGetLength(v328);
            if ((_CFStringHasStrongRTL(v328, 0, v393) & 1) != 0)
              goto LABEL_765;
            v411 = CFStringGetLength(v333);
            if (v411)
            {
              if (v411 <= v457 || (_CFStringHasStrongRTL(v333, v457, v411 - v457) & 1) == 0)
              {
LABEL_843:
                CFStringAppend(v333, v328);
                v457 = CFStringGetLength(v333);
                key = 0;
                goto LABEL_767;
              }
            }
            else
            {
              v423 = *(int *)&v509[32 * v253 + 8] + (uint64_t)*(int *)&v509[32 * v253 + 4];
              if (range <= v423 || !_CFStringHasStrongRTL(theString, v423, range - v423))
                goto LABEL_843;
            }
LABEL_765:
            chars[0] = 8296;
            key = 1;
            CFStringAppendCharacters(v333, chars, 1);
            CFStringAppend(v333, v328);
            chars[0] = 8297;
            CFStringAppendCharacters(v333, chars, 1);
            v389 = 1;
            goto LABEL_768;
          }
          v328 = (const __CFString *)v390;
LABEL_755:
          v70 = __srcb;
          goto LABEL_756;
        }
        if (*(_WORD *)v269 == 44)
        {
          if (!cf)
            goto LABEL_819;
          v478 = v314 + 27;
          v316 = cf;
LABEL_591:
          v317 = (__CFString *)CFRetain(v316);
LABEL_814:
          v408 = v317;
        }
        else
        {
          v334 = &v254[32 * v253];
          v337 = (char)v334[24];
          v336 = v334 + 24;
          v335 = v337;
          switch(*(_WORD *)&__srcb[16 * v337])
          {
            case '!':
              v478 = v315;
              v397 = (UniChar *)&__srcb[16 * v335 + 8];
              v398 = alloc;
              v399 = kCFNumberSInt64Type;
              goto LABEL_813;
            case '"':
              v478 = v315;
              v400 = &__srcb[16 * v335];
              if (*((_WORD *)v400 + 1) == 5)
              {
                *(_QWORD *)chars = 0;
                *(_QWORD *)chars = *(_QWORD *)&__srcb[16 * *v336 + 8];
                v397 = chars;
              }
              else
              {
                v397 = (UniChar *)(v400 + 8);
              }
              v398 = alloc;
              v399 = kCFNumberDoubleType;
              goto LABEL_813;
            case '#':
              v478 = v315;
              v397 = (UniChar *)&__srcb[16 * v335 + 8];
              v398 = alloc;
              v399 = kCFNumberCFIndexType;
LABEL_813:
              v317 = (__CFString *)CFNumberCreate(v398, v399, v397);
              goto LABEL_814;
            case '%':
              v316 = *(const void **)&__srcb[16 * v335 + 8];
              if (!v316)
                goto LABEL_819;
              v478 = v315;
              goto LABEL_591;
            case '&':
              v401 = *(const UniChar **)&__srcb[16 * v335 + 8];
              if (!v401)
                goto LABEL_819;
              v478 = v315;
              v474 = CFStringCreateMutable(alloc, 0);
              v402 = 0;
              while (v401[v402++])
                ;
              v404 = v402 - 1;
              if ((int)v275 >= v404 || v276 == 0)
                v406 = v404;
              else
                v406 = v275;
              if ((v509[32 * v253 + 20] & 2) != 0)
              {
                CFStringAppendCharacters(v474, v401, v406);
                if (!v273)
                  goto LABEL_869;
                v421 = v284 - v406;
                if (v284 <= v406)
                  goto LABEL_869;
                v408 = v474;
                do
                {
                  if (v421 >= 10)
                    v422 = 10;
                  else
                    v422 = v421;
                  __CFStringAppendBytes((unint64_t *)v474, "          ", v422, 1536);
                  v53 = __OFSUB__(v421, 10);
                  v421 -= 10;
                }
                while (!((v421 < 0) ^ v53 | (v421 == 0)));
              }
              else
              {
                v407 = v284;
                v408 = v474;
                if (v273)
                {
                  v409 = v407 - v406;
                  if (v407 > v406)
                  {
                    do
                    {
                      if (v409 >= 10)
                        v410 = 10;
                      else
                        v410 = v409;
                      __CFStringAppendBytes((unint64_t *)v474, "          ", v410, 1536);
                      v53 = __OFSUB__(v409, 10);
                      v409 -= 10;
                    }
                    while (!((v409 < 0) ^ v53 | (v409 == 0)));
                  }
                }
                CFStringAppendCharacters(v474, v401, v406);
              }
              break;
            case '\'':
            case '(':
              if (!*(_QWORD *)&__srcb[16 * v335 + 8])
                goto LABEL_819;
              v478 = v315;
              v474 = CFStringCreateMutable(alloc, 0);
              v338 = *(unsigned __int8 **)&__srcb[16 * *v336 + 8];
              if (*(_WORD *)v269 == 40)
              {
                v340 = *v338++;
                v339 = v340;
                if ((int)v275 >= v340 || v276 == 0)
                  v342 = v339;
                else
                  v342 = v275;
              }
              else if (v276)
              {
                v412 = memchr(v338, 0, (int)v275);
                if (v412)
                  v342 = (_DWORD)v412 - (_DWORD)v338;
                else
                  v342 = v275;
              }
              else
              {
                v342 = strlen((const char *)v338);
              }
              if ((v509[32 * v253 + 20] & 2) != 0)
              {
                if ((__CFDefaultSystemEncoding & 1) != 0)
                {
                  v428 = 1;
                }
                else
                {
                  CFStringGetSystemEncoding();
                  v428 = __CFDefaultSystemEncoding;
                }
                __CFStringAppendBytes((unint64_t *)v474, v338, v342, (v428 - 1));
                if (v273 && (v429 = v284 - v342, v284 > v342))
                {
                  v408 = v474;
                  do
                  {
                    if (v429 >= 10)
                      v430 = 10;
                    else
                      v430 = v429;
                    __CFStringAppendBytes((unint64_t *)v474, "          ", v430, 1536);
                    v53 = __OFSUB__(v429, 10);
                    v429 -= 10;
                  }
                  while (!((v429 < 0) ^ v53 | (v429 == 0)));
                }
                else
                {
LABEL_869:
                  v408 = v474;
                }
              }
              else
              {
                v424 = v284;
                v408 = v474;
                if (v273)
                {
                  v425 = v424 - v342;
                  if (v424 > v342)
                  {
                    do
                    {
                      if (v425 >= 10)
                        v426 = 10;
                      else
                        v426 = v425;
                      __CFStringAppendBytes((unint64_t *)v474, "          ", v426, 1536);
                      v53 = __OFSUB__(v425, 10);
                      v425 -= 10;
                    }
                    while (!((v425 < 0) ^ v53 | (v425 == 0)));
                  }
                }
                if ((__CFDefaultSystemEncoding & 1) != 0)
                {
                  v427 = 1;
                }
                else
                {
                  CFStringGetSystemEncoding();
                  v427 = __CFDefaultSystemEncoding;
                }
                __CFStringAppendBytes((unint64_t *)v474, v338, v342, (v427 - 1));
              }
              break;
            case ')':
              v478 = v315;
              ptr.i16[0] = *(_QWORD *)&__srcb[16 * v335 + 8];
              v317 = (__CFString *)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, &ptr, 2, 256, 0x10u, (const __CFAllocator *)&__kCFAllocatorNull, 0);
              goto LABEL_814;
            default:
              goto LABEL_819;
          }
        }
        if (v408)
        {
          v414 = _CFCopyResolvedFormatStringWithConfiguration(v408, *(CFDictionaryRef *)&v481[8 * *v478], v499);
          CFRelease(v408);
          if (v414)
          {
            *(_QWORD *)chars = v514;
            if ((char)v509[32 * v253 + 24] < 0)
            {
              v417 = v255;
              v418 = v256;
              v415 = theDict;
              v70 = __srcb;
              v29 = v507;
              v416 = v490;
              if (v253)
              {
                do
                {
                  v419 = *v417;
                  v417 -= 32;
                  if ((v419 & 0x80000000) == 0)
                    break;
                  --v418;
                }
                while (v418 >= 2);
              }
            }
            else
            {
              v415 = theDict;
              v70 = __srcb;
              v29 = v507;
              v416 = v490;
            }
            v455 = 0;
            v456 = a15;
            v453 = v459;
            v454 = *(_QWORD *)chars;
            v451 = a10 + 1;
            v452 = v460;
            theDict = v415;
            appended = __CFStringAppendFormatCore(v508, v495, v416, v499, v415, 0, v466);
            CFRelease(v414);
            if (!appended)
            {
              free(v488);
              goto LABEL_915;
            }
            v389 = 0;
            v333 = v508;
            goto LABEL_825;
          }
        }
LABEL_819:
        v333 = v508;
        CFStringAppendCString(v508, "(null)", 0x600u);
        v389 = 0;
        v70 = __srcb;
        v29 = v507;
LABEL_825:
        v329 = countb;
        v374 = cStr;
        if (!v29)
        {
LABEL_769:
          v356 = 0;
          goto LABEL_827;
        }
LABEL_826:
        v356 = CFStringGetLength(v333);
LABEL_827:
        *(_OWORD *)chars = *v329;
        *(_OWORD *)&chars[8] = v329[1];
        v360 = v500;
        v359 = v503;
        v361 = (uint64_t)v70;
        v362 = v494;
        v313 = (CFIndex)v374;
        v379 = v389;
LABEL_828:
        _CFStringFormatAppendMetadata(v360, v359, v361, v362, (uint64_t)chars, v313, v356, v379);
LABEL_829:
        v254 = v509;
LABEL_830:
        ++v253;
        ++v256;
        v255 += 32;
        if (v253 != v503)
          continue;
        v45 = v463;
        if ((int)cf2a >= 1)
        {
          v431 = 0;
          do
          {
            v432 = CFStringFind(v508, CFSTR("%@NSCONTEXT"), 0);
            v433 = (const __CFString *)__CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_CONTEXT__(v490, *(_QWORD *)&v70[4 * v488[v431 + 24] + 2], (uint64_t)v508);
            if (v433)
            {
              v434 = v433;
              CFStringReplace(v508, v432, v433);
              CFRelease(v434);
            }
            v431 += 32;
            v70 = __srcb;
          }
          while (32 * cf2a != v431);
        }
        v435 = v488;
LABEL_878:
        free(v435);
        v29 = v507;
        v44 = alloc;
LABEL_879:
        v69 = v481;
        v71 = v509;
LABEL_880:
        if (v71 != v553)
          goto LABEL_889;
LABEL_890:
        if (v70 != (_DWORD *)v552)
          CFAllocatorDeallocate(v44, v70);
        if (v45 && v45 != v554)
          CFAllocatorDeallocate(v44, v45);
        if (v69 != v550)
          CFAllocatorDeallocate(v44, v69);
        if (v496)
          CFRelease(v496);
        if (v29)
        {
          if (theArray)
          {
            *v29 = CFArrayCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theArray);
            CFRelease(theArray);
          }
        }
        return;
      case '&':
        v477 = v272;
        if (v507)
        {
          v309 = v508;
          v310 = CFStringGetLength(v508);
          v254 = v509;
        }
        else
        {
          v310 = 0;
          v309 = v508;
        }
        v357 = *(const UniChar **)&v70[4 * (char)v254[32 * v253 + 24] + 2];
        cStrc = (char *)v310;
        if (!v357)
        {
          CFStringAppendCString(v309, "(null)", 0x600u);
          goto LABEL_718;
        }
        if (v276)
        {
          if ((int)v275 < 1)
          {
            LODWORD(i) = 0;
          }
          else
          {
            for (i = 0; i != v275; ++i)
            {
              if (!v357[i])
                goto LABEL_702;
            }
            LODWORD(i) = v275;
          }
        }
        else
        {
          LODWORD(i) = -1;
          v370 = v357;
          do
          {
            v371 = *v370++;
            LODWORD(i) = i + 1;
          }
          while (v371);
        }
LABEL_702:
        if ((v254[32 * v253 + 20] & 2) != 0)
        {
          CFStringAppendCharacters(v309, v357, i);
          if (v273)
          {
            v377 = v477 - i;
            if (v477 > (int)i)
            {
              do
              {
                if (v377 >= 10)
                  v378 = 10;
                else
                  v378 = v377;
                __CFStringAppendBytes((unint64_t *)v309, "          ", v378, 1536);
                v53 = __OFSUB__(v377, 10);
                v377 -= 10;
              }
              while (!((v377 < 0) ^ v53 | (v377 == 0)));
            }
          }
        }
        else
        {
          if (v273)
          {
            v375 = v477 - i;
            if (v477 > (int)i)
            {
              do
              {
                if (v375 >= 10)
                  v376 = 10;
                else
                  v376 = v375;
                __CFStringAppendBytes((unint64_t *)v309, "          ", v376, 1536);
                v53 = __OFSUB__(v375, 10);
                v375 -= 10;
              }
              while (!((v375 < 0) ^ v53 | (v375 == 0)));
            }
          }
          CFStringAppendCharacters(v309, v357, i);
        }
LABEL_718:
        v70 = __srcb;
        if (v507)
          v356 = CFStringGetLength(v309);
        else
          v356 = 0;
        v369 = countb;
        v313 = (CFIndex)cStrc;
        goto LABEL_722;
      case '\'':
      case '(':
        v286 = v272;
        if (v507)
        {
          v287 = (unint64_t *)v508;
          v288 = CFStringGetLength(v508);
          v254 = v509;
          cStra = (char *)v288;
        }
        else
        {
          cStra = 0;
          v287 = (unint64_t *)v508;
        }
        v318 = *(unsigned __int8 **)&v70[4 * (char)v254[32 * v253 + 24] + 2];
        if (v318)
        {
          if (*(_WORD *)v269 == 40)
          {
            v320 = *v318++;
            v319 = v320;
            if ((int)v275 >= v320 || v276 == 0)
              v322 = v319;
            else
              v322 = v275;
          }
          else
          {
            if (v276)
            {
              v343 = memchr(v318, 0, (int)v275);
              if (v343)
                v322 = (_DWORD)v343 - (_DWORD)v318;
              else
                v322 = v275;
            }
            else
            {
              v322 = strlen((const char *)v318);
            }
            v254 = v509;
          }
          if ((v254[32 * v253 + 20] & 2) != 0)
          {
            if ((__CFDefaultSystemEncoding & 1) != 0)
            {
              v366 = 1;
            }
            else
            {
              CFStringGetSystemEncoding();
              v366 = __CFDefaultSystemEncoding;
            }
            __CFStringAppendBytes(v287, v318, v322, (v366 - 1));
            if (v273)
            {
              v367 = v286 - v322;
              if (v286 > v322)
              {
                do
                {
                  if (v367 >= 10)
                    v368 = 10;
                  else
                    v368 = v367;
                  __CFStringAppendBytes(v287, "          ", v368, 1536);
                  v53 = __OFSUB__(v367, 10);
                  v367 -= 10;
                }
                while (!((v367 < 0) ^ v53 | (v367 == 0)));
              }
            }
          }
          else
          {
            if (v273)
            {
              v363 = v286 - v322;
              if (v286 > v322)
              {
                do
                {
                  if (v363 >= 10)
                    v364 = 10;
                  else
                    v364 = v363;
                  __CFStringAppendBytes(v287, "          ", v364, 1536);
                  v53 = __OFSUB__(v363, 10);
                  v363 -= 10;
                }
                while (!((v363 < 0) ^ v53 | (v363 == 0)));
              }
            }
            if ((__CFDefaultSystemEncoding & 1) != 0)
            {
              v365 = 1;
            }
            else
            {
              CFStringGetSystemEncoding();
              v365 = __CFDefaultSystemEncoding;
            }
            __CFStringAppendBytes(v287, v318, v322, (v365 - 1));
          }
        }
        else
        {
          CFStringAppendCString((CFMutableStringRef)v287, "(null)", 0x600u);
        }
        v70 = __srcb;
        if (v507)
        {
          v350 = (const __CFString *)v287;
          goto LABEL_689;
        }
        v356 = 0;
        goto LABEL_691;
      case ')':
        if (v507)
        {
          v311 = v508;
          v312 = CFStringGetLength(v508);
          v254 = v509;
          v308 = v312;
        }
        else
        {
          v308 = 0;
          v311 = v508;
        }
        ptr.i16[0] = *(_QWORD *)&v70[4 * (char)v254[32 * v253 + 24] + 2];
        CFStringAppendCharacters(v311, (const UniChar *)&ptr, 1);
        if (v507)
          v356 = CFStringGetLength(v311);
        else
          v356 = 0;
        *(_OWORD *)chars = *countb;
        *(_OWORD *)&chars[8] = countb[1];
        v360 = v500;
        v359 = v503;
        goto LABEL_656;
      case '+':
        if (v507)
          v313 = CFStringGetLength(v508);
        else
          v313 = 0;
        v359 = v503;
        *(_OWORD *)chars = *countb;
        *(_OWORD *)&chars[8] = countb[1];
        v360 = v500;
        v361 = (uint64_t)v70;
        v362 = v494;
        v356 = v313;
        goto LABEL_723;
      default:
        goto LABEL_830;
    }
  }
}

void _CFStringFormatAppendMetadata(CFMutableArrayRef *a1, CFIndex a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  int v15;
  __CFDictionary *Mutable;
  BOOL v17;
  _BOOL8 v18;
  int v19;
  void *v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  CFNumberRef v24;
  uint64_t v25;
  CFNumberRef v26;
  CFNumberType v27;
  CFNumberRef v28;
  CFNumberRef v29;
  unint64_t v30;
  int v31;
  int valuePtr;
  void *value[2];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v15 = *(unsigned __int16 *)(a5 + 2);
    if ((v15 - 43) >= 2)
    {
      if (v15 == 32)
      {
        if ((*(_BYTE *)(a5 + 20) & 0x80) == 0)
          return;
      }
      else
      {
        if (*(char *)(a5 + 24) < 0)
          return;
        if (*(unsigned __int8 *)(a5 + 24) >= a4)
          _CFStringFormatAppendMetadata_cold_1();
      }
    }
    if (!*a1)
      *a1 = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, &kCFTypeArrayCallBacks);
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v17 = a8 == 0;
    v18 = a8 != 0;
    v19 = *(_DWORD *)(a5 + 4);
    if (v17)
      v20 = (void *)a6;
    else
      v20 = (void *)(a6 + 1);
    v31 = *(_DWORD *)(a5 + 8);
    valuePtr = v19;
    value[0] = v20;
    v21 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &valuePtr);
    CFDictionarySetValue(Mutable, CFSTR("SpecLocation"), v21);
    CFRelease(v21);
    v22 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, &v31);
    CFDictionarySetValue(Mutable, CFSTR("SpecLength"), v22);
    CFRelease(v22);
    v23 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, value);
    CFDictionarySetValue(Mutable, CFSTR("ReplacementLocation"), v23);
    CFRelease(v23);
    v30 = (a7 - v18 - (unint64_t)value[0]) & ~((int64_t)(a7 - v18 - (unint64_t)value[0]) >> 63);
    v24 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, &v30);
    CFDictionarySetValue(Mutable, CFSTR("ReplacementLength"), v24);
    CFRelease(v24);
    v25 = *(char *)(a5 + 24);
    if (v25 < 0)
      goto LABEL_26;
    if (v25 < a4 && *(_WORD *)(a5 + 2) != 32)
    {
      value[0] = (void *)(v25 + 1);
      v26 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, value);
      CFDictionarySetValue(Mutable, CFSTR("Index"), v26);
      CFRelease(v26);
      LODWORD(v25) = *(char *)(a5 + 24);
      if ((v25 & 0x80000000) != 0)
        goto LABEL_26;
    }
    if (v25 >= a4)
      goto LABEL_26;
    *(_OWORD *)value = *(_OWORD *)(a3 + 16 * v25);
    if (SLOWORD(value[0]) == 33)
    {
      v27 = kCFNumberSInt64Type;
    }
    else
    {
      if (SLOWORD(value[0]) != 34)
      {
        if (SLOWORD(value[0]) == 37)
        {
          if (value[1])
            CFDictionarySetValue(Mutable, CFSTR("Object"), value[1]);
        }
        goto LABEL_26;
      }
      v27 = kCFNumberDoubleType;
    }
    v28 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v27, &value[1]);
    CFDictionarySetValue(Mutable, CFSTR("Number"), v28);
    CFRelease(v28);
LABEL_26:
    value[0] = (void *)v18;
    v29 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberCFIndexType, value);
    CFDictionarySetValue(Mutable, CFSTR("AddedIsolates"), v29);
    CFRelease(v29);
    CFArrayAppendValue(*a1, Mutable);
    CFRelease(Mutable);
  }
}

uint64_t _CFExecutableLinkedOnOrAfter(unint64_t a1)
{
  unsigned int active_platform;

  active_platform = dyld_get_active_platform();
  _CFBuildVersionForCFSystemVersion(a1, active_platform);
  return dyld_program_sdk_at_least();
}

unint64_t _CFBuildVersionForCFSystemVersion(unint64_t a1, unsigned int a2)
{
  uint64_t v2;
  unint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;

  if (a1 <= 0x13)
  {
    if (a1 > 4)
    {
      if (a1 >= 0xA)
        v2 = 4294901760;
      else
        v2 = 0;
      if (a2 == 6 || a2 == 1)
      {
        v3 = a1 - 5;
        a1 = _CFBuildVersionForCFSystemVersion_macos_map[a1 - 5];
        if (a2 == 6)
        {
          if (v3 >= 0xB)
          {
            if ((_DWORD)a1 == 659456)
              v7 = 917504;
            else
              v7 = -65536;
            if ((_DWORD)a1 == 720896)
              v8 = 917504;
            else
              v8 = v7;
            if ((_DWORD)a1 == 659201)
              a1 = 852480;
            else
              a1 = v8;
            a2 = 2;
          }
          else
          {
            a2 = 2;
            a1 = 851968;
          }
        }
      }
      else
      {
        a1 = v2;
      }
      return a2 | (a1 << 32);
    }
    goto LABEL_16;
  }
  if (a1 - 1000 <= 0xF)
  {
    if (a1 > 0x3EC && a2 == 1)
    {
      if (a1 - 1005 >= 0xB)
      {
        a2 = 1;
        a1 = 4294901760;
      }
      else
      {
        a1 = dword_182DB1504[a1 - 1005];
        a2 = 1;
      }
      return a2 | (a1 << 32);
    }
LABEL_16:
    a1 = 0;
    if (a2 == 6)
      a2 = 2;
    return a2 | (a1 << 32);
  }
  if (a2 == 6)
  {
    if ((_DWORD)a1 == 659456)
      v4 = 917504;
    else
      v4 = -65536;
    if ((_DWORD)a1 == 720896)
      v5 = 917504;
    else
      v5 = v4;
    if ((_DWORD)a1 == 659201)
      v6 = 852480;
    else
      v6 = v5;
    if (a1 >= 0xA0F01)
      a1 = v6;
    else
      a1 = 851968;
    a2 = 2;
  }
  return a2 | (a1 << 32);
}

uint64_t _CFStringGetFormatSpecifierConfiguration(void *a1)
{
  if ((objc_opt_respondsToSelector() & 1) != 0)
    return objc_msgSend(a1, "formatConfiguration");
  else
    return 0;
}

BOOL __CFRuntimeIsConstant(uint64_t a1)
{
  unint64_t v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return HIWORD(v1) == 0;
}

uint64_t __CFCopyFormattingDescription(unint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  CFStringRef (*v14)(uint64_t);
  unint64_t v15;
  unint64_t v17;
  unint64_t v18;
  _UNKNOWN **v19;
  uint64_t v20;
  uint64_t i;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  int v29;

  if (!a1)
    return 0;
  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    v4 = 0;
    v5 = (uint64_t *)MEMORY[0x1E0DE7C58];
    v6 = *MEMORY[0x1E0DE7C58];
    v7 = (unint64_t)a1 & 0xC000000000000007;
    if (((unint64_t)a1 & 0xC000000000000007) == 0xC000000000000007)
      v6 = 0;
    v8 = v6 ^ (unint64_t)a1;
    v9 = v8 & 7;
    v10 = MEMORY[0x1E0DE7C48];
    do
    {
      if (v9 == *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v4))
        break;
      ++v4;
    }
    while (v4 != 7);
    v11 = v4 | v8;
    v12 = v4 & 7;
    v13 = (v11 >> 55) + 8;
    if (v12 == 7)
      LODWORD(v12) = v13;
    if ((_DWORD)v12)
    {
      if ((_DWORD)v12 == 6)
        return 0;
      if ((_DWORD)v12 == 3)
      {
        v14 = __CFNumberCopyFormattingDescription;
        return ((uint64_t (*)(unint64_t *, uint64_t))v14)(a1, a2);
      }
    }
    else
    {
      if ((dyld_program_sdk_at_least() & 1) != 0)
        __CFCopyFormattingDescription_cold_3();
      v20 = *v5;
      if (v7 == 0xC000000000000007)
        v20 = 0;
      v8 = v20 ^ (unint64_t)a1;
      v9 = v8 & 7;
    }
    for (i = 0; i != 7; ++i)
    {
      if (v9 == *(unsigned __int8 *)(v10 + i))
        break;
    }
    v22 = ((i | v8) >> 55) + 8;
    if ((i & 7) != 7)
      v22 = i & 7;
    v23 = 22;
    switch(v22)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          __CFCopyFormattingDescription_cold_2();
        goto LABEL_40;
      case 1:
        goto LABEL_41;
      case 2:
        goto LABEL_39;
      case 3:
        goto LABEL_43;
      case 4:
      case 5:
        goto LABEL_40;
      case 6:
        v23 = 42;
        goto LABEL_43;
      default:
        if (v22 == 20)
        {
LABEL_40:
          v23 = 1;
        }
        else if (v22 == 22)
        {
LABEL_39:
          v23 = 7;
        }
        else
        {
LABEL_41:
          v23 = objc_msgSend(a1, "_cfTypeID");
        }
LABEL_43:
        if (CF_IS_OBJC(v23, (__objc2_class **)a1))
          goto LABEL_15;
        v24 = 0;
        v25 = *v5;
        if (v7 == 0xC000000000000007)
          v25 = 0;
        v26 = v25 ^ (unint64_t)a1;
        do
        {
          if ((v26 & 7) == *(_BYTE *)(v10 + v24))
            break;
          ++v24;
        }
        while (v24 != 7);
        v27 = v24 | v26;
        v28 = v24 & 7;
        v29 = (v27 >> 55) + 8;
        if (v28 == 7)
          LODWORD(v28) = v29;
        v18 = 22;
        switch((int)v28)
        {
          case 0:
            if (dyld_program_sdk_at_least())
              __CFCopyFormattingDescription_cold_1();
            goto LABEL_57;
          case 1:
            goto LABEL_58;
          case 2:
            goto LABEL_56;
          case 3:
            goto LABEL_19;
          case 4:
          case 5:
            goto LABEL_57;
          case 6:
            v18 = 42;
            goto LABEL_19;
          default:
            if ((_DWORD)v28 == 20)
            {
LABEL_57:
              v18 = 1;
              goto LABEL_19;
            }
            if ((_DWORD)v28 == 22)
            {
LABEL_56:
              v18 = 7;
              goto LABEL_19;
            }
LABEL_58:
            v18 = objc_msgSend(a1, "_cfTypeID");
            break;
        }
        break;
    }
  }
  else
  {
    v15 = atomic_load(a1 + 1);
    if (CF_IS_OBJC((v15 >> 8) & 0x3FF, (__objc2_class **)a1))
    {
LABEL_15:
      if ((objc_opt_respondsToSelector() & 1) != 0)
        return objc_msgSend(a1, "_copyFormattingDescription:", a2);
      return 0;
    }
    v17 = atomic_load(a1 + 1);
    v18 = (v17 >> 8) & 0x3FF;
  }
  if (v18 > 0x47)
    v19 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v18 - 72) >> 6] + 8 * (((_DWORD)v18 - 72) & 0x3F));
  else
LABEL_19:
    v19 = &__CFRuntimeBuiltinClassTable + v18;
  v14 = (CFStringRef (*)(uint64_t))*((_QWORD *)*v19 + 7);
  if (v14)
    return ((uint64_t (*)(unint64_t *, uint64_t))v14)(a1, a2);
  return 0;
}

CFStringRef __CFStringCopyFormattingDescription(CFStringRef theString)
{
  CFAllocatorRef *p_data;
  char v2;

  if (((unint64_t)theString & 0x8000000000000000) != 0)
  {
    p_data = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
  }
  else
  {
    v2 = atomic_load((unint64_t *)&theString->info);
    if (v2 < 0)
      p_data = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
    else
      p_data = (CFAllocatorRef *)&theString[-1].data;
  }
  return CFStringCreateCopy(*p_data, theString);
}

CFTypeRef _DescriptionWithStringProxyFunc(void *a1, uint64_t a2, uint64_t a3, int a4, _BYTE *a5)
{
  const void *v10;

  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    if (a5)
      *a5 = 1;
    if (a4)
    {
      v10 = (const void *)objc_msgSend(a1, "_dynamicContextEvaluation:patternString:", a2, a3);
      if (v10)
        return CFRetain(v10);
    }
  }
  else if (a5)
  {
    *a5 = 0;
  }
  return 0;
}

CFTypeRef _DescriptionWithLocaleFunc(void *a1, uint64_t a2)
{
  const __CFString *v4;

  if (a1)
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      v4 = (const __CFString *)objc_msgSend(a1, "descriptionWithLocale:", a2);
    else
      v4 = (const __CFString *)objc_msgSend(a1, "description");
  }
  else
  {
    v4 = CFSTR("*nil*");
  }
  if (!v4)
    v4 = CFSTR("*nil description*");
  return CFRetain(v4);
}

uint64_t _CFStringHasStrongRTL(const __CFString *a1, uint64_t a2, uint64_t a3)
{
  uint64_t BitmapPtrForPlane;
  uint64_t CStringPtrInternal;
  int64_t v8;
  int64_t v9;
  UniChar v10;
  unsigned int v11;
  uint64_t v12;
  int64_t v13;
  int64_t v14;
  int64_t v15;
  int64_t v16;
  UniChar v17;
  int64_t v18;
  int64_t v19;
  unsigned int v20;
  _OWORD v22[8];
  CFStringRef theString;
  const UniChar *CharactersPtr;
  uint64_t v25;
  uint64_t v26;
  int64_t v27;
  int64_t v28;
  int64_t v29;
  uint64_t v30;
  CFRange v31;
  CFRange v32;

  v30 = *MEMORY[0x1E0C80C00];
  BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x66u, 0);
  theString = a1;
  v26 = a2;
  v27 = a3;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  if (CharactersPtr)
    CStringPtrInternal = 0;
  else
    CStringPtrInternal = _CFStringGetCStringPtrInternal((uint64_t)a1, 0x600u, 1, 1);
  v28 = 0;
  v29 = 0;
  v25 = CStringPtrInternal;
  if (a3 < 1)
    return 0;
  v8 = 0;
  memset(v22, 0, sizeof(v22));
  while (1)
  {
    if (v8 < 0 || (v9 = v27, v27 <= v8))
    {
      LOWORD(v11) = 0;
      goto LABEL_11;
    }
    if (CharactersPtr)
    {
      v10 = CharactersPtr[v26 + v8];
    }
    else if (v25)
    {
      v10 = *(char *)(v25 + v26 + v8);
    }
    else
    {
      if (v29 <= v8 || (v14 = v28, v28 > v8))
      {
        v15 = v8 - 4;
        if ((unint64_t)v8 < 4)
          v15 = 0;
        if (v15 + 64 < v27)
          v9 = v15 + 64;
        v28 = v15;
        v29 = v9;
        v31.location = v26 + v15;
        v31.length = v9 - v15;
        CFStringGetCharacters(theString, v31, (UniChar *)v22);
        v14 = v28;
      }
      v10 = *((_WORD *)v22 + v8 - v14);
    }
    v11 = v10;
    if (v10 >> 10 == 54)
      break;
LABEL_11:
    v12 = BitmapPtrForPlane;
    if (BitmapPtrForPlane)
      goto LABEL_12;
LABEL_13:
    v13 = v8 + 1;
LABEL_14:
    v8 = v13;
    if (v13 >= a3)
      return 0;
  }
  v13 = v8 + 1;
  v16 = v27;
  if (v27 <= v8 + 1)
    goto LABEL_14;
  if (CharactersPtr)
  {
    v17 = CharactersPtr[v26 + v13];
  }
  else if (v25)
  {
    v17 = *(char *)(v25 + v26 + v13);
  }
  else
  {
    if (v29 <= v13 || (v18 = v28, v28 > v13))
    {
      v19 = v8 - 3;
      if ((unint64_t)v8 < 3)
        v19 = 0;
      if (v19 + 64 < v27)
        v16 = v19 + 64;
      v28 = v19;
      v29 = v16;
      v32.location = v26 + v19;
      v32.length = v16 - v19;
      CFStringGetCharacters(theString, v32, (UniChar *)v22);
      v18 = v28;
    }
    v17 = *((_WORD *)v22 + v13 - v18);
  }
  if (v17 >> 10 != 55)
    goto LABEL_14;
  v11 = (v11 << 10) + v17 - 56613888;
  v20 = HIWORD(v11) & 0x1F;
  if (!v20)
  {
    ++v8;
    goto LABEL_11;
  }
  v12 = CFUniCharGetBitmapPtrForPlane(0x66u, v20);
  ++v8;
  if (!v12)
    goto LABEL_13;
LABEL_12:
  if (((*(unsigned __int8 *)(v12 + ((unsigned __int16)v11 >> 3)) >> (v11 & 7)) & 1) == 0)
    goto LABEL_13;
  return 1;
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  unint64_t v4;
  CFMutableStringRef Mutable;
  unint64_t v6;
  int8x8_t v7;
  unint64_t v8;
  int8x8_t v9;
  unint64_t v10;
  int8x8_t v11;
  unint64_t v12;
  int8x8_t v13;
  unint64_t v14;
  int8x8_t v15;
  unint64_t v16;
  int8x8_t v17;
  unint64_t v18;
  int8x8_t v19;
  unint64_t v20;
  int8x8_t v21;
  unint64_t v22;
  int8x8_t v23;
  unint64_t v24;
  int8x8_t v25;
  unint64_t v26;
  int8x8_t v27;
  UniChar v28;
  unint64_t v29;
  int8x8_t v30;
  __int16 v31;
  uint32x2_t v32;
  unint64_t v33;
  int8x8_t v34;
  unint64_t v35;
  int8x8_t v36;
  __int16 v37;
  unint64_t v38;
  int8x8_t v39;
  __int16 v40;
  uint32x2_t v41;
  unint64_t v42;
  int8x8_t v43;
  UniChar v45;
  __int16 v46;
  __int16 v47;
  __int16 v48;
  __int16 v49;
  __int16 v50;
  __int16 v51;
  __int16 v52;
  __int16 v53;
  __int16 v54;
  __int16 v55;
  __int16 v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v4 = _CFGetNonObjCTypeID((unint64_t *)uuid);
  if (v4 != 34)
    _CFAssertMismatchedTypeID(0x22uLL, v4);
  Mutable = CFStringCreateMutable(alloc, 0);
  v6 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 16)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v7 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v6), (int8x8_t)(v6 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v6, (int32x2_t)0x3700000037));
  v8 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 17)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v9 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v8), (int8x8_t)(v8 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v8, (int32x2_t)0x3700000037));
  v10 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 18)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v11 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v10), (int8x8_t)(v10 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v10, (int32x2_t)0x3700000037));
  v12 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 19)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v13 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v12), (int8x8_t)(v12 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v12, (int32x2_t)0x3700000037));
  v46 = v7.i16[2];
  v45 = v7.i16[0];
  v48 = v9.i16[2];
  v47 = v9.i16[0];
  v50 = v11.i16[2];
  v49 = v11.i16[0];
  v52 = v13.i16[2];
  v51 = v13.i16[0];
  v53 = 45;
  CFStringAppendCharacters(Mutable, &v45, 9);
  v14 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 20)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v15 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v14), (int8x8_t)(v14 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v14, (int32x2_t)0x3700000037));
  v46 = v15.i16[2];
  v45 = v15.i16[0];
  v16 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 21)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v17 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v16), (int8x8_t)(v16 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v16, (int32x2_t)0x3700000037));
  v48 = v17.i16[2];
  v47 = v17.i16[0];
  v49 = 45;
  CFStringAppendCharacters(Mutable, &v45, 5);
  v18 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 22)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v19 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v18), (int8x8_t)(v18 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v18, (int32x2_t)0x3700000037));
  v46 = v19.i16[2];
  v45 = v19.i16[0];
  v20 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 23)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v21 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v20), (int8x8_t)(v20 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v20, (int32x2_t)0x3700000037));
  v48 = v21.i16[2];
  v47 = v21.i16[0];
  v49 = 45;
  CFStringAppendCharacters(Mutable, &v45, 5);
  v22 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 24)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v23 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v22), (int8x8_t)(v22 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v22, (int32x2_t)0x3700000037));
  v46 = v23.i16[2];
  v45 = v23.i16[0];
  v24 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 25)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v25 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v24), (int8x8_t)(v24 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v24, (int32x2_t)0x3700000037));
  v48 = v25.i16[2];
  v47 = v25.i16[0];
  v49 = 45;
  CFStringAppendCharacters(Mutable, &v45, 5);
  v26 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 26)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v27 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v26), (int8x8_t)(v26 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v26, (int32x2_t)0x3700000037));
  v46 = v27.i16[2];
  v28 = v27.i16[0];
  v29 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 27)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v30 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v29), (int8x8_t)(v29 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v29, (int32x2_t)0x3700000037));
  v45 = v28;
  v48 = v30.i16[2];
  v31 = v30.i16[0];
  v32 = (uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 28));
  v47 = v31;
  v33 = *(_QWORD *)&vshl_u32(v32, (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v34 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v33), (int8x8_t)(v33 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v33, (int32x2_t)0x3700000037));
  v50 = v34.i16[2];
  v49 = v34.i16[0];
  v35 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 29)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v36 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v35), (int8x8_t)(v35 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v35, (int32x2_t)0x3700000037));
  v52 = v36.i16[2];
  v37 = v36.i16[0];
  v38 = *(_QWORD *)&vshl_u32((uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 30)), (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v39 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v38), (int8x8_t)(v38 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v38, (int32x2_t)0x3700000037));
  v51 = v37;
  v54 = v39.i16[2];
  v40 = v39.i16[0];
  v41 = (uint32x2_t)vdup_n_s32(*((unsigned __int8 *)uuid + 31));
  v53 = v40;
  v42 = *(_QWORD *)&vshl_u32(v41, (uint32x2_t)4294967292) & 0xFFFFFF0FFFFFFF0FLL;
  v43 = vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0xA0000000ALL, (uint32x2_t)v42), (int8x8_t)(v42 | 0x3000000030), (int8x8_t)vadd_s32((int32x2_t)v42, (int32x2_t)0x3700000037));
  v56 = v43.i16[2];
  v55 = v43.i16[0];
  CFStringAppendCharacters(Mutable, &v45, 12);
  return Mutable;
}

const __CFString *_CFCopyResolvedFormatStringWithConfiguration(__CFString *a1, CFDictionaryRef theDict, const void *a3)
{
  const __CFString *v6;
  const void *v7;
  __CFBundle *MainBundle;
  const __CFArray *v9;
  const __CFArray *v10;
  CFArrayRef v11;
  const __CFString *ValueAtIndex;
  CFTypeID v14;
  size_t v15;
  CFTypeID v16;
  CFTypeID TypeID;
  const void *v18;
  CFTypeID v20;
  CFStringRef v21;
  const __CFString *Identifier;
  int v24;
  CFStringRef v25;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  void *RelevantLocaleInfoFromLocaleSummary;
  const __CFDictionary *v29;
  CFTypeID v30;
  const __CFDictionary *v31;
  uint64_t CharacterAtIndex;
  const __CFDictionary *v33;
  const __CFDictionary *v34;
  CFTypeID v35;
  CFIndex Length;
  uint64_t v37;
  const __CFDictionary *v38;
  CFTypeID v39;
  CFTypeID v40;
  const __CFDictionary *v41;
  CFTypeID v42;
  const __CFDictionary *v43;
  const __CFDictionary *v44;
  CFTypeID v45;
  const __CFDictionary *v46;
  const __CFString *v47;
  CFTypeID v48;
  const __CFString *v49;
  const __CFString *AffixRuleFormat;
  CFTypeID v51;
  const __CFDictionary *v52;
  const void *v53;
  unint64_t Count;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  const void **v59;
  const void **v60;
  const __CFString *v61;
  const __CFCharacterSet *v62;
  const __CFString *v63;
  CFTypeID v64;
  const __CFString *v65;
  void *v66;
  uint64_t v67;
  CFStringRef v68;
  NSException *v69;
  _QWORD v70[2];
  const void *(*v71)(uint64_t, CFDictionaryRef, UniChar);
  void *v72;
  const __CFDictionary *v73;
  uint64_t v74;
  int v75;
  size_t v76;
  const void *v77[2];
  int v78;
  void *value[22];

  value[20] = *(void **)MEMORY[0x1E0C80C00];
  v6 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("NSStringFormatSpecTypeKey"));
  if (!v6)
    return v6;
  v7 = CFDictionaryGetValue(theDict, CFSTR("NSStringFormatLocaleKey"));
  if (!v7)
  {
    v7 = a3;
    if (!a3)
    {
      v7 = (const void *)_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale;
      if (!_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale)
      {
        MainBundle = CFBundleGetMainBundle();
        v9 = CFBundleCopyBundleLocalizations(MainBundle);
        if (v9)
        {
          v10 = v9;
          v11 = CFBundleCopyPreferredLocalizationsFromArray(v9);
          CFRelease(v10);
          if (v11)
          {
            if (CFArrayGetCount(v11) <= 0)
            {
              CFRelease(v11);
            }
            else
            {
              ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v11, 0);
              v7 = CFLocaleCreate(0, ValueAtIndex);
              CFRelease(v11);
              if (v7)
                goto LABEL_12;
            }
          }
        }
        v7 = CFLocaleCreate(0, CFSTR("en"));
LABEL_12:
        while (!__ldaxr((unint64_t *)&_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale))
        {
          if (!__stlxr((unint64_t)v7, (unint64_t *)&_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale))goto LABEL_16;
        }
        __clrex();
        CFRelease(v7);
        v7 = (const void *)_CFCopyResolvedFormatStringWithConfiguration_mainBundleLocale;
      }
    }
  }
LABEL_16:
  if (v6 == CFSTR("NSStringPluralRuleType") || CFEqual(v6, CFSTR("NSStringPluralRuleType")))
  {
    v14 = CFGetTypeID(a1);
    if (v14 == CFNumberGetTypeID())
    {
      v76 = 0;
      if (CFNumberGetValue((CFNumberRef)a1, kCFNumberCFIndexType, &v76))
      {
        v15 = v76;
        if (v76)
        {
          v6 = 0;
        }
        else
        {
          if (CFNumberIsFloatType((CFNumberRef)a1))
            v6 = 0;
          else
            v6 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("zero"));
          v15 = v76;
        }
        if (v15 == 0x7FFFFFFFFFFFFFFFLL)
          v6 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("other"));
        if (v6)
          return (const __CFString *)CFRetain(v6);
      }
      else
      {
        v76 = -1;
      }
      v75 = 0;
      Identifier = CFLocaleGetIdentifier((CFLocaleRef)v7);
      if (!Identifier)
        Identifier = CFSTR("en");
      if (!CFStringGetCString(Identifier, (char *)value, 157, 0x8000100u))
        strcpy((char *)value, "en");
      uplrules_open();
      v75 = 0;
      v74 = 0;
      if (CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, &v74))
        v24 = uplrules_select();
      else
        v24 = 0;
      uplrules_close();
      v6 = 0;
      if (v75 <= 0 && v24 >= 1)
      {
        v25 = CFStringCreateWithCharactersNoCopy(0, (const UniChar *)v77, v24, (CFAllocatorRef)&__kCFAllocatorNull);
        v6 = (const __CFString *)CFDictionaryGetValue(theDict, v25);
        CFRelease(v25);
      }
      if (!v6 && v76 == 1)
      {
        if (CFNumberIsFloatType((CFNumberRef)a1))
        {
LABEL_63:
          v6 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("other"));
          if (v6)
            return (const __CFString *)CFRetain(v6);
          return v6;
        }
        v6 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("one"));
      }
      if (v6)
        return (const __CFString *)CFRetain(v6);
      goto LABEL_63;
    }
    return 0;
  }
  if (v6 == CFSTR("NSStringDirectRuleType") || CFEqual(v6, CFSTR("NSStringDirectRuleType")))
  {
    v16 = CFGetTypeID(a1);
    TypeID = CFStringGetTypeID();
    v6 = 0;
    if (!a1 || v16 != TypeID)
      return v6;
    v18 = a1;
    return (const __CFString *)CFRetain(v18);
  }
  if (v6 == CFSTR("NSStringGenderRuleType") || CFEqual(v6, CFSTR("NSStringGenderRuleType")))
  {
    value[0] = 0;
    v20 = CFGetTypeID(a1);
    v6 = 0;
    if (v20 != CFNumberGetTypeID())
      return v6;
    LODWORD(v76) = 0;
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &v76))
    {
      v77[0] = 0;
      v77[1] = 0;
      v78 = 0;
      if ((v76 & 0x80000000) == 0 && snprintf((char *)v77, 0x14uLL, "%d", v76) >= 1)
      {
        if (LOBYTE(v77[0]))
        {
          v21 = CFStringCreateWithCStringNoCopy(0, (const char *)v77, 0x600u, (CFAllocatorRef)&__kCFAllocatorNull);
          if (v21)
          {
            if (!CFDictionaryGetValueIfPresent(theDict, v21, (const void **)value))
              value[0] = (void *)CFDictionaryGetValue(theDict, CFSTR("0"));
            CFRelease(v21);
            if (value[0])
              return (const __CFString *)CFRetain(value[0]);
          }
        }
      }
    }
    return 0;
  }
  if (v6 == CFSTR("NSStringEntityFormattingRuleType") || CFEqual(v6, CFSTR("NSStringEntityFormattingRuleType")))
  {
    v26 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("NSStringFormatFamilyInfoKey"));
    v27 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("NSStringFormatLocaleInfoKey"));
    RelevantLocaleInfoFromLocaleSummary = _CFStringGetRelevantLocaleInfoFromLocaleSummary(v27, (const __CFLocale *)v7);
    v29 = (const __CFDictionary *)CFRetain(RelevantLocaleInfoFromLocaleSummary);
    v77[0] = 0;
    if (CFDictionaryGetValueIfPresent(v29, CFSTR("NSStringFormatRuleStartEndInfoKey"), v77))
    {
      v30 = CFGetTypeID(a1);
      if (v30 == CFStringGetTypeID())
      {
        v70[0] = MEMORY[0x1E0C809B0];
        v70[1] = 3221225472;
        v71 = ___CFCopyResolvedFormatStringWithConfiguration_block_invoke;
        v72 = &__block_descriptor_40_e29__v20__0____CFDictionary__8S16l;
        v73 = v26;
        v31 = (const __CFDictionary *)v77[0];
        CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0);
        v33 = (const __CFDictionary *)___CFCopyResolvedFormatStringWithConfiguration_block_invoke((uint64_t)v70, v31, CharacterAtIndex);
        v34 = v33;
        if (!v33)
          goto LABEL_97;
        v35 = CFGetTypeID(v33);
        if (v35 == CFDictionaryGetTypeID())
        {
          Length = CFStringGetLength(a1);
          v37 = CFStringGetCharacterAtIndex(a1, Length - 1);
          v38 = (const __CFDictionary *)v71((uint64_t)v70, v34, v37);
          v34 = v38;
          if (!v38)
            goto LABEL_97;
          v39 = CFGetTypeID(v38);
          v40 = CFStringGetTypeID();
          goto LABEL_82;
        }
      }
      else
      {
        v44 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v77[0], CFSTR("default"));
        v34 = v44;
        if (!v44)
          goto LABEL_97;
        v45 = CFGetTypeID(v44);
        if (v45 == CFDictionaryGetTypeID())
        {
          v46 = (const __CFDictionary *)CFDictionaryGetValue(v34, CFSTR("default"));
          v34 = v46;
          if (!v46)
            goto LABEL_97;
          v39 = CFGetTypeID(v46);
          v40 = CFStringGetTypeID();
LABEL_82:
          if (v39 != v40)
            v34 = 0;
LABEL_97:
          v51 = CFGetTypeID(a1);
          if (v51 == CFStringGetTypeID() && !v34)
          {
            v52 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("NSStringFormatClassInfoKey"));
            value[0] = 0;
            if (CFDictionaryGetValueIfPresent(v29, CFSTR("NSStringFormatClassTypeKey"), (const void **)value))
              v53 = CFDictionaryGetValue(v52, value[0]);
            else
              v53 = CFDictionaryGetValue(v29, CFSTR("NSStringFormatRuleInfoKey"));
            v77[0] = v53;
            Count = CFDictionaryGetCount((CFDictionaryRef)v53);
            v56 = Count;
            if (Count >> 60)
            {
              v68 = CFStringCreateWithFormat(0, 0, CFSTR("*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt"), Count);
              v69 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSGenericException"), v68, 0);
              CFRelease(v68);
              objc_exception_throw(v69);
            }
            if (Count <= 1)
              Count = 1;
            v57 = MEMORY[0x1E0C80A78](Count, v55);
            v59 = (const void **)((char *)v70 - v58);
            v76 = 0;
            if (v56 >= 0x101)
            {
              v59 = (const void **)_CFCreateArrayStorage(v57, 0, &v76);
              v60 = v59;
            }
            else
            {
              v60 = 0;
            }
            CFDictionaryGetKeysAndValues((CFDictionaryRef)v77[0], v59, 0);
            if (v56)
            {
              while (1)
              {
                v61 = (const __CFString *)*v59;
                if (CFStringCompare((CFStringRef)*v59, CFSTR("default"), 0))
                {
                  v62 = (const __CFCharacterSet *)CFDictionaryGetValue(v26, v61);
                  if ((_CFStringContentsInCharacterSet(a1, v62) & 1) != 0)
                    break;
                }
                ++v59;
                if (!--v56)
                  goto LABEL_112;
              }
            }
            else
            {
LABEL_112:
              v61 = 0;
            }
            if (v61)
              v63 = v61;
            else
              v63 = CFSTR("default");
            v34 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v77[0], v63);
            free(v60);
          }
          if (v29)
            CFRelease(v29);
          if (v34)
            return (const __CFString *)CFRetain(v34);
          return 0;
        }
      }
    }
    else if (CFDictionaryGetValueIfPresent(v29, CFSTR("NSStringConditionalFormatRuleInfoKey"), v77))
    {
      v41 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v77[0], CFSTR("default"));
      v42 = CFGetTypeID(a1);
      if (v42 == CFStringGetTypeID() && _CFStringConditionalFormattingMeetsCondition(a1, (CFLocaleRef)v7))
        v43 = (const __CFDictionary *)CFDictionaryGetValue(v41, CFSTR("NSStringConditionalFormatKey"));
      else
        v43 = (const __CFDictionary *)CFDictionaryGetValue(v41, CFSTR("default"));
      v34 = v43;
      goto LABEL_97;
    }
    v34 = 0;
    goto LABEL_97;
  }
  if (v6 == CFSTR("NSStringAffixRuleType") || CFEqual(v6, CFSTR("NSStringAffixRuleType")))
  {
    v47 = (const __CFString *)CFLocaleGetValue((CFLocaleRef)v7, CFSTR("kCFLocaleLanguageCodeKey"));
    v48 = CFGetTypeID(a1);
    if (v48 != CFStringGetTypeID()
      || (v47 ? (v49 = v47) : (v49 = CFSTR("en")),
          AffixRuleFormat = _CFStringFindAffixRuleFormat(v49, a1),
          (v18 = CFDictionaryGetValue(theDict, AffixRuleFormat)) == 0))
    {
      v18 = CFDictionaryGetValue(theDict, CFSTR("other"));
      if (!v18)
        return 0;
    }
    return (const __CFString *)CFRetain(v18);
  }
  if (v6 != CFSTR("NSStringVocativeNameFormattingRuleType")
    && !CFEqual(v6, CFSTR("NSStringVocativeNameFormattingRuleType")))
  {
    return 0;
  }
  v64 = CFGetTypeID(a1);
  v6 = a1;
  if (v64 != 7)
  {
    if (_CFCopyResolvedFormatStringWithConfiguration_onceToken != -1)
      dispatch_once(&_CFCopyResolvedFormatStringWithConfiguration_onceToken, &__block_literal_global_39);
    if (!__NSPersonNameComponentsClass)
      return 0;
    if ((objc_opt_isKindOfClass() & 1) == 0)
      return 0;
    v6 = (const __CFString *)-[__CFString givenName](a1, "givenName");
    if (CFGetTypeID(v6) != 7)
      return 0;
  }
  if (!v6)
    return v6;
  v65 = (const __CFString *)_CFStringCopyVocativeCaseOfGivenName(v6, (CFLocaleRef)v7);
  v6 = v65;
  if (v64 == 7 || !v65)
    return v6;
  v66 = (void *)-[__CFString copy](a1, "copy");
  objc_msgSend(v66, "setGivenName:", v6);
  if (_CFCopyResolvedFormatStringWithConfiguration_onceToken_44 != -1)
    dispatch_once(&_CFCopyResolvedFormatStringWithConfiguration_onceToken_44, &__block_literal_global_45);
  CFRelease(v6);
  v67 = objc_msgSend((id)objc_msgSend((id)_CFCopyResolvedFormatStringWithConfiguration_formatter, "stringFromPersonNameComponents:", v66), "copy");
  CFRelease(v66);
  return (const __CFString *)v67;
}

void sub_182AC4900(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

CFStringRef __CFUUIDCopyFormattingDescription(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFUUIDCreateString(v2, (CFUUIDRef)a1);
}

CFTypeRef __CFBooleanCopyFormattingDescription(__objc2_class **a1)
{
  if (&__kCFBooleanTrue == a1)
    return CFRetain(CFSTR("true"));
  else
    return CFRetain(CFSTR("false"));
}

CFStringRef __CFURLCopyFormattingDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  const __CFString *v3;
  const __CFString *v4;
  CFComparisonResult v5;
  uint64_t v6;
  const __CFString *v7;
  uint64_t v9;
  const __CFString *v10;
  CFStringRef TruncatedURLString;
  CFStringRef v12;
  const __CFString *v13;
  CFStringRef v14;
  CFStringRef v15;

  v2 = CFGetAllocator((CFTypeRef)a1);
  v3 = CFURLCopyScheme((CFURLRef)a1);
  if (v3 && (v4 = v3, v5 = CFStringCompare(v3, CFSTR("data"), 1uLL), CFRelease(v4), v5 == kCFCompareEqualTo))
  {
    v9 = *(_QWORD *)(a1 + 32);
    v10 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    TruncatedURLString = CreateTruncatedURLString(v2, v10);
    v12 = TruncatedURLString;
    if (!v9)
      return TruncatedURLString;
    v13 = CFURLGetString(*(CFURLRef *)(a1 + 32));
    v14 = CreateTruncatedURLString(v2, v13);
    v15 = CFStringCreateWithFormat(v2, 0, CFSTR("%@ -- %@"), v12, v14);
    if (v12)
      CFRelease(v12);
    if (v14)
      CFRelease(v14);
    return v15;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 32);
    v7 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    if (v6)
      return CFStringCreateWithFormat(v2, 0, CFSTR("%@ -- %@"), v7, *(_QWORD *)(a1 + 32));
    else
      return CFStringCreateCopy(v2, v7);
  }
}

uint64_t _registrar_compare(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_QWORD *)(a2 + 48);
  v4 = v2 >= v3;
  v5 = v2 > v3;
  if (v4)
    return v5;
  else
    return 0xFFFFFFFFLL;
}

unint64_t _CFDataGetBytePtrNonObjC(uint64_t a1)
{
  char v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((v1 & 4) != 0)
    return (a1 + 63) & 0xFFFFFFFFFFFFFFF0;
  else
    return *(_QWORD *)(a1 + 40);
}

unint64_t _CFStringCreateTaggedPointerString(unsigned __int8 *a1, uint64_t a2)
{
  unint64_t result;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;

  if (!a2)
    return (unint64_t)&stru_1E1337B18;
  if (!__CFTaggedStringClass)
    return 0;
  if (a2 > 7)
  {
    if ((unint64_t)a2 <= 0xB)
    {
      if ((unint64_t)a2 >= 0xA)
      {
        v6 = 0;
        v9 = a2;
        while (1)
        {
          v10 = charToSixBitLookup_0[*a1];
          if (v10 > 0x1F)
            break;
          v6 = v10 | (32 * v6);
          ++a1;
          if (!--v9)
          {
LABEL_15:
            result = (8 * a2) | (v6 << 7) | 0x8000000000000002;
            v5 = result ^ *MEMORY[0x1E0DE7C58];
            goto LABEL_16;
          }
        }
      }
      else
      {
        v6 = 0;
        v7 = a2;
        while (1)
        {
          v8 = charToSixBitLookup_0[*a1];
          if (v8 > 0x3F)
            break;
          v6 = v8 | (v6 << 6);
          ++a1;
          if (!--v7)
            goto LABEL_15;
        }
      }
    }
    return 0;
  }
  __memmove_chk();
  result = (8 * a2) | 0x8000000000000002;
  v5 = *MEMORY[0x1E0DE7C58] ^ result;
LABEL_16:
  if ((~v5 & 0xC000000000000007) != 0)
    return v5 & 0xFFFFFFFFFFFFFFF8 | *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + (v5 & 7));
  return result;
}

void _CFBundleInfoPlistProcessInfoDictionary(void *a1)
{
  const __CFArray *Mutable;
  CFMutableDictionaryRef v3;
  uint64_t v4;
  CFIndex v5;
  const void *ValueAtIndex;
  _QWORD v7[5];
  _QWORD v8[8];

  v8[7] = *MEMORY[0x1E0C80C00];
  if (a1 && CFDictionaryGetCount((CFDictionaryRef)a1))
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    v3 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v4 = MEMORY[0x1E0C809B0];
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = ___CFBundleInfoPlistProcessInfoDictionary_block_invoke;
    v8[3] = &__block_descriptor_tmp_19_0;
    v8[4] = Mutable;
    v8[5] = v3;
    v8[6] = a1;
    CFDictionaryApply(a1, (uint64_t)v8);
    if (CFArrayGetCount(Mutable) >= 1)
    {
      v5 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v5);
        CFDictionaryRemoveValue((CFMutableDictionaryRef)a1, ValueAtIndex);
        ++v5;
      }
      while (v5 < CFArrayGetCount(Mutable));
    }
    v7[0] = v4;
    v7[1] = 0x40000000;
    v7[2] = ___CFBundleInfoPlistProcessInfoDictionary_block_invoke_2;
    v7[3] = &__block_descriptor_tmp_20;
    v7[4] = a1;
    CFDictionaryApply(v3, (uint64_t)v7);
    CFRelease(Mutable);
    CFRelease(v3);
  }
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
  char v4;
  char v5;
  const char *v6;
  char v7;
  const char *v8;
  const char *v9;
  CFMutableDictionaryRef v10;

  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary removeObjectForKey:](theDict, "removeObjectForKey:", key);
  }
  else
  {
    v4 = atomic_load((unint64_t *)theDict + 1);
    if ((v4 & 0x40) != 0)
    {
      v9 = "void CFDictionaryRemoveValue(CFMutableDictionaryRef, const void *)";
      v10 = theDict;
      CFLog(3, CFSTR("%s(): immutable collection %p given to mutating function"));
    }
    v5 = atomic_load((unint64_t *)theDict + 1);
    if ((v5 & 1) != 0)
    {
      v6 = (const char *)__CF_KVO_WillChangeSelector_hc;
      if (!__CF_KVO_WillChangeSelector_hc)
      {
        v6 = sel_registerName("willChangeValueForKey:");
        __CF_KVO_WillChangeSelector_hc = (uint64_t)v6;
      }
      objc_msgSend(theDict, v6, key, v9, v10);
    }
    CFBasicHashRemoveValue((uint64_t)theDict, (unint64_t)key);
    v7 = atomic_load((unint64_t *)theDict + 1);
    if ((v7 & 1) != 0)
    {
      v8 = (const char *)__CF_KVO_DidChangeSelector_hc;
      if (!__CF_KVO_DidChangeSelector_hc)
      {
        v8 = sel_registerName("didChangeValueForKey:");
        __CF_KVO_DidChangeSelector_hc = (uint64_t)v8;
      }
      objc_msgSend(theDict, v8, key);
    }
  }
}

uint64_t CFDictionaryApply(void *a1, uint64_t a2)
{
  _QWORD v5[6];

  v5[5] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)a1))
    return objc_msgSend(a1, "enumerateKeysAndObjectsWithOptions:usingBlock:", 0, a2);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __CFDictionaryApply_block_invoke;
  v5[3] = &unk_1E12E14A8;
  v5[4] = a2;
  return CFBasicHashApply((uint64_t)a1, (uint64_t)v5);
}

void sub_182AC5AD8(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

uint64_t CFBasicHashRemoveValue(uint64_t result, unint64_t a2)
{
  char v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v2 = atomic_load((unint64_t *)(result + 8));
  if ((v2 & 0x40) != 0)
    goto LABEL_26;
  v3 = 0;
  if (a2 == 2780474809 || a2 == 2814029233)
    return v3;
  v4 = result;
  v7 = 0u;
  v8 = 0u;
  if (!*(_BYTE *)(result + 26))
  {
    v7 = xmmword_182DC7A10;
    v8 = unk_182DC7A20;
    goto LABEL_20;
  }
  v5 = *(_WORD *)(result + 18) & 3;
  if ((*(_WORD *)(result + 18) & 0x8000) != 0)
  {
    switch(v5)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v7);
        break;
      case 2:
        ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v7);
        break;
      case 1:
        ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v7);
        break;
      default:
        goto LABEL_26;
    }
LABEL_20:
    v3 = *((_QWORD *)&v8 + 1);
    if (*((_QWORD *)&v8 + 1) < 2uLL)
    {
      if (*((_QWORD *)&v8 + 1) == 1)
        __CFBasicHashRemoveValue(v4, v7);
    }
    else
    {
      ++*(_WORD *)(v4 + 16);
      if (v3 <= 0x7FFFFFFFFFFFFFFELL)
      {
        v6 = *(unsigned __int16 *)(v4 + 18);
        if ((v6 & 0x18) != 0)
          __asm { BR              X12 }
      }
    }
    return v3;
  }
  switch(v5)
  {
    case 3:
      ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v7);
      goto LABEL_20;
    case 2:
      ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v7);
      goto LABEL_20;
    case 1:
      ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v7);
      goto LABEL_20;
  }
LABEL_26:
  __break(1u);
  return result;
}

void __CFBasicHashRemoveValue(uint64_t cf, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(const CFAllocatorRef, uint64_t);
  const CFAllocatorRef *v8;
  char v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void (*v14)(const CFAllocatorRef, uint64_t);
  char v15;
  const CFAllocatorRef *v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unint64_t v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  BOOL v27;

  ++*(_WORD *)(cf + 16);
  v4 = *(_QWORD *)(cf + 40);
  v5 = *(_QWORD *)(v4 + 8 * a2);
  *(_QWORD *)(v4 + 8 * a2) = -1;
  if ((unint64_t)(v5 + 1) >= 2)
  {
    if (v5 == 2814029233)
      v5 = 0;
    if (v5 == 2780474809)
      v6 = -1;
    else
      v6 = v5;
    if ((*(_QWORD *)(cf + 32) & 2) == 0)
    {
      v7 = *(void (**)(const CFAllocatorRef, uint64_t))(*(uint64_t *)((char *)CFBasicHashCallBackPtrs
                                                                             + (HIBYTE(*(_QWORD *)(cf + 24)) & 0xF8))
                                                                + 8 * ((*(_QWORD *)(cf + 24) >> 54) & 0x1FLL));
      if (v7)
      {
        if (cf < 0)
        {
          v8 = &kCFAllocatorSystemDefault;
        }
        else
        {
          v9 = atomic_load((unint64_t *)(cf + 8));
          if (v9 < 0)
            v8 = &kCFAllocatorSystemDefault;
          else
            v8 = (const CFAllocatorRef *)(cf - 16);
        }
        v7(*v8, v6);
      }
    }
  }
  v10 = *(unsigned __int16 *)(cf + 18);
  if ((v10 & 4) != 0)
  {
    v11 = *(_QWORD *)(cf + 8 * ((v10 >> 2) & 1) + 40);
    v12 = *(_QWORD *)(v11 + 8 * a2);
    *(_QWORD *)(v11 + 8 * a2) = -1;
    if ((unint64_t)(v12 + 1) >= 2)
    {
      if (v12 == 2814029233)
        v12 = 0;
      if (v12 == 2780474809)
        v13 = -1;
      else
        v13 = v12;
      if ((*(_QWORD *)(cf + 32) & 2) == 0)
      {
        v14 = *(void (**)(const CFAllocatorRef, uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(cf + 24) >> 49) & 0x1FLL]
                                                                   + 8 * ((*(_QWORD *)(cf + 24) >> 44) & 0x1FLL));
        if (v14)
        {
          if (cf < 0 || (v15 = atomic_load((unint64_t *)(cf + 8)), v15 < 0))
            v16 = &kCFAllocatorSystemDefault;
          else
            v16 = (const CFAllocatorRef *)(cf - 16);
          v14(*v16, v13);
        }
      }
    }
  }
  v17 = *(unsigned __int16 *)(cf + 18);
  if ((v17 & 0x18) != 0)
    __asm { BR              X11 }
  v18 = *(_DWORD *)(cf + 20) - 1;
  *(_DWORD *)(cf + 20) = v18;
  v19 = *(_QWORD *)(cf + 24);
  v20 = *(_QWORD *)(cf + 32);
  v21 = BYTE2(v19);
  v22 = v19 & 0xFFFFFFFFFFFF0000 | (unsigned __int16)(v19 + 1);
  *(_QWORD *)(cf + 24) = v22;
  if ((v20 & 4) != 0)
  {
    if (v21 < 6)
      goto LABEL_37;
    v23 = v21 - 5;
  }
  else
  {
    if (v21 < 3)
      goto LABEL_37;
    v23 = v21 - 2;
  }
  if (__CFBasicHashTableCapacities[v23] > (uint64_t)v18)
  {
    v24 = -1;
LABEL_45:
    __CFBasicHashRehash(cf, v24);
    return;
  }
LABEL_37:
  v25 = (unsigned __int16)v22;
  if (!(_WORD)v22
    || ((v26 = __CFBasicHashTableSizes[BYTE2(v22)], v26 >= 20) ? (v27 = (unint64_t)v26 >> 2 > v25) : (v27 = 1),
        !v27))
  {
    v24 = 0;
    goto LABEL_45;
  }
}

void sub_182AC7430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFTypeID CFSetGetTypeID(void)
{
  return 17;
}

uint64_t CFTypeGetTypeID()
{
  return 1;
}

void CFSetRemoveAllValues(CFMutableSetRef theSet)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet removeAllObjects](theSet, "removeAllObjects");
  }
  else
  {
    v8 = atomic_load((unint64_t *)theSet + 1);
    if ((v8 & 0x40) != 0)
      CFLog(3, (uint64_t)CFSTR("%s(): immutable collection %p given to mutating function"), v2, v3, v4, v5, v6, v7, (__int16)"void CFSetRemoveAllValues(CFMutableSetRef)");
    CFBasicHashRemoveAllValues((uint64_t)theSet);
  }
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;
  CFSetRef v10;
  CFIndex Count;
  const void **v12;
  char v13;
  const char *v14;

  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary removeAllObjects](theDict, "removeAllObjects");
  }
  else
  {
    v8 = atomic_load((unint64_t *)theDict + 1);
    if ((v8 & 0x40) != 0)
      CFLog(3, (uint64_t)CFSTR("%s(): immutable collection %p given to mutating function"), v2, v3, v4, v5, v6, v7, (__int16)"void CFDictionaryRemoveAllValues(CFMutableDictionaryRef)");
    v9 = atomic_load((unint64_t *)theDict + 1);
    if ((v9 & 1) != 0)
    {
      if (!__CF_KVO_WillChangeKeysSelector_hc)
        __CF_KVO_WillChangeKeysSelector_hc = (uint64_t)sel_registerName("_willChangeValuesForKeys:");
      Count = CFDictionaryGetCount(theDict);
      v12 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
      CFDictionaryGetKeysAndValues(theDict, v12, 0);
      v10 = CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, Count, &kCFTypeSetCallBacks);
      free(v12);
      objc_msgSend(theDict, (SEL)__CF_KVO_WillChangeKeysSelector_hc, v10);
    }
    else
    {
      v10 = 0;
    }
    CFBasicHashRemoveAllValues((uint64_t)theDict);
    v13 = atomic_load((unint64_t *)theDict + 1);
    if ((v13 & 1) != 0)
    {
      v14 = (const char *)__CF_KVO_DidChangeKeysSelector_hc;
      if (!__CF_KVO_DidChangeKeysSelector_hc)
      {
        v14 = sel_registerName("_didChangeValuesForKeys:");
        __CF_KVO_DidChangeKeysSelector_hc = (uint64_t)v14;
      }
      objc_msgSend(theDict, v14, v10);
      if (v10)
        CFRelease(v10);
    }
  }
}

void CFBasicHashRemoveAllValues(uint64_t a1)
{
  char v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((v1 & 0x40) != 0)
  {
    __break(1u);
  }
  else if (*(_BYTE *)(a1 + 26))
  {
    __CFBasicHashDrain(a1);
  }
}

void mdict_removeObjectForKey(uint64_t *a1, void *a2)
{
  uint64_t *v2;
  unint64_t v3;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  void *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v2 = a1 + 1;
  v3 = (unint64_t)a1[2] >> 58;
  if (v3)
  {
    v6 = LODWORD(__NSDictionarySizes_0[v3]);
    v7 = *v2;
    v20 = *v2 + 8 * v6;
    v8 = 0;
    v9 = objc_msgSend(a2, "hash") % v6;
    if (v6 <= 1)
      v10 = 1;
    else
      v10 = v6;
    v11 = v6;
    while (1)
    {
      v12 = *(void **)(v7 + 8 * v9);
      if (!v12)
        break;
      if (v12 == &___NSDictionaryM_DeletedMarker)
      {
        ++v8;
        if (v11 == v6)
          v11 = v9;
      }
      else if (v12 == a2 || (objc_msgSend(v12, "isEqual:", a2) & 1) != 0)
      {
        v11 = v9;
        goto LABEL_21;
      }
      if (v9 + 1 >= v6)
        v13 = v6;
      else
        v13 = 0;
      v9 = v9 + 1 - v13;
      if (!--v10)
        goto LABEL_21;
    }
    if (v11 == v6)
      v11 = v9;
LABEL_21:
    if (v11 < v6)
    {
      v14 = *(_QWORD *)(v7 + 8 * v11);
      if (v14 && v14 != (_QWORD)&___NSDictionaryM_DeletedMarker)
      {
        v16 = a1[2];
        if ((v16 & 0x200000000000000) != 0)
          objc_msgSend(a1, "willChangeValueForKey:", a2);
        v19 = *(_QWORD *)(v20 + 8 * v11);
        *(_QWORD *)(v7 + 8 * v11) = &___NSDictionaryM_DeletedMarker;
        *(_QWORD *)(v20 + 8 * v11) = 0;
        a1[2] = a1[2] & 0xFE000000FFFFFFFFLL | ((((unint64_t)(a1[2] + 0x1FFFFFF00000000) >> 32) & 0x1FFFFFF) << 32);
        if (v8 > 0xF)
        {
          mdict_rehashd((uint64_t)a1, v3);
        }
        else
        {
          if (v11 + 1 < v6)
            v17 = v11 + 1;
          else
            v17 = 0;
          if (!*(_QWORD *)(v7 + 8 * v17))
          {
            do
            {
              *(_QWORD *)(v7 + 8 * v11) = 0;
              if (v11)
                v18 = v11;
              else
                v18 = v6;
              v11 = v18 - 1;
            }
            while (*(_UNKNOWN **)(v7 + 8 * (v18 - 1)) == &___NSDictionaryM_DeletedMarker);
          }
        }
        if ((v16 & 0x200000000000000) != 0)
          objc_msgSend(a1, "didChangeValueForKey:", a2);
        if ((v14 & 0x8000000000000000) == 0)

        if (v19 >= 1)
      }
    }
  }
}

void _cfmp_deallocation_record_release(int a1, int *a2)
{
  if ((*((_BYTE *)a2 + 5) & 1) == 0)
    _cfmp_log_failure((uint64_t)"Freeing a record not in the set", a2, *((unsigned __int8 *)a2 + 4), *a2);
  free(a2);
}

void __NSOrderedSetEnumerate(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _BOOL4 v27;
  int v28;
  unint64_t v29;
  unint64_t v30;
  _QWORD block[13];
  _QWORD v34[3];
  char v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE v40[128];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend(a1, "count"))
  {
    if ((a3 & 0x1000000000000000) != 0)
    {
      v6 = objc_msgSend(a4, "firstIndex");
      v30 = objc_msgSend(a4, "lastIndex");
    }
    else
    {
      v6 = 0;
      v30 = objc_msgSend(a1, "count") - 1;
    }
    if (v6 != 0x7FFFFFFFFFFFFFFFLL && v30 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if ((a3 & 1) != 0)
      {
        v7 = __CFActiveProcessorCount();
        if (v7 < 2)
          a3 &= ~1uLL;
      }
      else
      {
        v7 = 1;
      }
      if ((a3 & 3) != 0)
      {
        v8 = (v30 - v6 + 1) / v7 / v7;
        if (v8 >= 0x10)
        {
          if (v8 <= 0x1000)
            v9 = (v8 + 15) & 0xFFFFFFFFFFFFFFF0;
          else
            v9 = 4096;
        }
        else
        {
          v9 = 16;
        }
        v17 = v9 + v30 - v6;
        v36 = 0;
        v37 = &v36;
        v38 = 0x2020000000;
        v39 = 0x7FFFFFFFFFFFFFFFLL;
        v18 = v17 / v9;
        if ((a3 & 1) != 0)
        {
          v34[0] = 0;
          v34[1] = v34;
          v34[2] = 0x2020000000;
          v35 = 0;
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3221225472;
          block[2] = ____NSOrderedSetEnumerate_block_invoke;
          block[3] = &unk_1E12E6278;
          block[10] = v9;
          block[11] = v30;
          block[12] = a3;
          block[4] = a1;
          block[5] = a4;
          block[7] = v34;
          block[8] = &v36;
          block[6] = a2;
          block[9] = v6;
          dispatch_apply(v18, 0, block);
          _Block_object_dispose(v34, 8);
        }
        else if (v9 <= v17)
        {
          v19 = 0;
          v20 = v9 - 1;
          if (v18 <= 1)
            v21 = 1;
          else
            v21 = v17 / v9;
          v22 = v21 - 1;
          v23 = v6;
          v24 = v30;
          do
          {
            if ((a3 & 2) != 0)
            {
              if (v20 >= v24 - v6)
                v26 = v6;
              else
                v26 = 1 - v9 + v24;
              v25 = v24;
            }
            else
            {
              if (v20 >= v24 - v6)
                v25 = v30;
              else
                v25 = v20 + v19 * v9 + v6;
              v26 = v23;
            }
            v27 = __NSOrderedSetChunkIterate(a1, a3, v26, v25, a4, a2, (unint64_t *)v37 + 3, 0, 0);
            ++v19;
            if (v22)
              v28 = v27;
            else
              v28 = 1;
            --v22;
            v24 -= v9;
            v23 += v9;
          }
          while (v28 != 1);
        }
        _Block_object_dispose(&v36, 8);
      }
      else
      {
        v29 = v6;
        LOBYTE(v34[0]) = 0;
        v10 = (void *)_CFAutoreleasePoolPush();
        v41 = 0u;
        v42 = 0u;
        v43 = 0u;
        v44 = 0u;
        v11 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v41, v40, 16);
        if (v11)
        {
          v12 = 0;
          v13 = 0;
          v14 = *(_QWORD *)v42;
          do
          {
            for (i = 0; i != v11; ++i)
            {
              if (*(_QWORD *)v42 != v14)
                objc_enumerationMutation(a1);
              v16 = v13 + i;
              if ((a3 & 0x1000000000000000) == 0
                || v29 <= v16 && v16 <= v30 && objc_msgSend(a4, "containsIndex:", v13 + i))
              {
                __NSORDEREDSET_IS_CALLING_OUT_TO_A_BLOCK__(a2);
                if (v12 < 0x3FF)
                {
                  ++v12;
                }
                else
                {
                  _CFAutoreleasePoolPop(v10);
                  v10 = (void *)_CFAutoreleasePoolPush();
                  v12 = 0;
                }
              }
            }
            v11 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v41, v40, 16);
            v13 += i;
          }
          while (v11);
        }
        _CFAutoreleasePoolPop(v10);
      }
    }
  }
}

void sub_182AC88A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t __NSORDEREDSET_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

uint64_t _CFLengthAfterDeletingPathExtension2(const __CFString *a1)
{
  uint64_t result;

  result = _CFStartOfPathExtension2(a1);
  if (result <= 0)
    return CFStringGetLength(a1);
  return result;
}

CFIndex _CFStartOfPathExtension2(const __CFString *a1)
{
  _BOOL4 hasDrive;
  CFIndex v4;
  int CharacterAtIndex;

  if (CFStringGetLength(a1) >= 2)
  {
    hasDrive = _hasDrive(a1);
    v4 = CFStringGetLength(a1) - 1;
    while (v4)
    {
      CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v4);
      if (CharacterAtIndex == 47)
        break;
      --v4;
      if (CharacterAtIndex == 46)
      {
        if (hasDrive && v4 == 1)
          return 0;
        else
          return v4 + 1;
      }
    }
  }
  return 0;
}

Boolean CFStringIsEncodingAvailable(CFStringEncoding encoding)
{
  uint64_t v1;
  Boolean result;
  int v3;

  v1 = *(_QWORD *)&encoding;
  result = 1;
  if ((int)v1 > 134217983)
  {
    if ((int)v1 > 335544575)
    {
      if ((_DWORD)v1 == 335544576 || (_DWORD)v1 == 402653440)
        return result;
      v3 = 469762304;
    }
    else
    {
      if ((_DWORD)v1 == 134217984 || (_DWORD)v1 == 201326848)
        return result;
      v3 = 268435712;
    }
    if ((_DWORD)v1 == v3)
      return result;
    return CFStringEncodingIsValidEncoding(v1);
  }
  if ((int)v1 <= 1535)
  {
    if (!(_DWORD)v1 || (_DWORD)v1 == 256 || (_DWORD)v1 == 1280)
      return result;
    return CFStringEncodingIsValidEncoding(v1);
  }
  if ((_DWORD)v1 != 1536 && (_DWORD)v1 != 2817 && (_DWORD)v1 != 3071)
    return CFStringEncodingIsValidEncoding(v1);
  return result;
}

CFStringRef CFURLCreateStringByAddingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveUnescaped, CFStringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding)
{
  CFIndex Length;
  uint64_t v10;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  CFMutableStringRef MutableCopy;
  CFIndex v14;
  CFIndex v15;
  UniChar v16;
  CFIndex v17;
  CFIndex v19;
  CFIndex v20;
  const __CFAllocator *v21;
  CFIndex v22;
  UniChar v23;
  unsigned int *v24;
  UniChar *v25;
  unsigned int *v26;
  unsigned int v27;
  CFIndex v28;
  CFIndex v29;
  CFIndex v30;
  unsigned __int16 v31;
  CFIndex v32;
  CFIndex v33;
  CFIndex v34;
  unsigned int *v35;
  UniChar *v36;
  unsigned int *v37;
  unsigned int v38;
  const __CFAllocator *v40;
  uint64_t v42;
  UniChar v43;
  unsigned __int16 v44[2];
  unsigned int v45[2];
  UniChar chars[1024];
  UniChar buffer[8];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  CFStringRef theString;
  const UniChar *v56;
  const char *v57;
  uint64_t v58;
  CFIndex v59;
  CFIndex v60;
  CFIndex v61;
  uint64_t v62;
  CFRange v63;
  CFRange v64;
  CFRange v65;
  CFRange v66;

  v62 = *MEMORY[0x1E0C80C00];
  if (!originalString)
    return 0;
  Length = CFStringGetLength(originalString);
  if (!Length)
    return CFStringCreateCopy(allocator, originalString);
  v10 = Length;
  theString = originalString;
  v58 = 0;
  v59 = Length;
  CharactersPtr = CFStringGetCharactersPtr(originalString);
  CStringPtr = 0;
  v56 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(originalString, 0x600u);
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  *(_OWORD *)buffer = 0u;
  v48 = 0u;
  v61 = 0;
  v57 = CStringPtr;
  v60 = 0;
  if (v10 < 1)
  {
LABEL_83:
    v40 = CFGetAllocator(originalString);
    return CFStringCreateCopy(v40, originalString);
  }
  MutableCopy = 0;
  v14 = 0;
  v15 = 0;
  do
  {
    v43 = 0;
    if (v56)
    {
      v16 = v56[v58 + v14];
    }
    else if (v57)
    {
      v16 = v57[v58 + v14];
    }
    else
    {
      v17 = v60;
      if (v61 <= v14 || v60 > v14)
      {
        v19 = v14 - 4;
        if (v14 < 4)
          v19 = 0;
        v20 = v19 + 64;
        if (v19 + 64 >= v59)
          v20 = v59;
        v60 = v19;
        v61 = v20;
        v63.location = v58 + v19;
        v63.length = v20 - v19;
        CFStringGetCharacters(theString, v63, buffer);
        v17 = v60;
      }
      v16 = buffer[v14 - v17];
    }
    v43 = v16;
    if (v16 <= 0x7Fu && (sURLValidCharacters[v16] & 1) != 0)
    {
      if (!legalURLCharactersToBeEscaped || !_stringContainsCharacter(legalURLCharactersToBeEscaped, v16))
      {
LABEL_38:
        if (MutableCopy)
        {
          chars[v15] = v43;
          if (v15 == 1023)
          {
            CFStringAppendCharacters(MutableCopy, chars, 1024);
            v15 = 0;
          }
          else
          {
            ++v15;
          }
        }
        goto LABEL_74;
      }
    }
    else if (charactersToLeaveUnescaped && _stringContainsCharacter(charactersToLeaveUnescaped, v16))
    {
      goto LABEL_38;
    }
    v42 = 0;
    if (!MutableCopy)
    {
      v21 = CFGetAllocator(originalString);
      MutableCopy = CFStringCreateMutableCopy(v21, 0, originalString);
      v64.length = v10 - v14;
      v64.location = v14;
      CFStringDelete(MutableCopy, v64);
    }
    if (v15 >= 1000)
    {
      CFStringAppendCharacters(MutableCopy, chars, v15);
      v15 = 0;
    }
    if (!CFStringEncodingUnicodeToBytes(encoding, 0, &v43, 1, 0, v45, 8, &v42))
    {
      if (v42 >= 1)
      {
        v24 = (unsigned int *)((char *)v45 + v42);
        v25 = &chars[v15 + 2];
        v26 = v45;
        do
        {
          v27 = *(unsigned __int8 *)v26;
          v26 = (unsigned int *)((char *)v26 + 1);
          *(v25 - 2) = 37;
          *(v25 - 1) = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)v27 >> 4];
          v15 += 3;
          *v25 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[v27 & 0xF];
          v25 += 3;
        }
        while (v26 < v24);
      }
      goto LABEL_74;
    }
    if (encoding != 134217984)
      break;
    if ((v43 & 0xFC00) != 0xD800)
      break;
    v22 = v14 + 1;
    if (v14 + 1 >= v10)
      break;
    if (v56)
    {
      v23 = v56[v58 + v22];
    }
    else if (v57)
    {
      v23 = v57[v58 + v22];
    }
    else
    {
      if (v61 <= v22 || (v28 = v60, v60 > v22))
      {
        v29 = v14 - 3;
        if (v14 < 3)
          v29 = 0;
        v30 = v29 + 64;
        if (v29 + 64 >= v59)
          v30 = v59;
        v60 = v29;
        v61 = v30;
        v65.location = v58 + v29;
        v65.length = v30 - v29;
        CFStringGetCharacters(theString, v65, buffer);
        v28 = v60;
      }
      v23 = buffer[v22 - v28];
    }
    if (v23 >> 10 != 55)
      break;
    v44[0] = v43;
    if (v56)
    {
      v31 = v56[v58 + v22];
    }
    else if (v57)
    {
      v31 = v57[v58 + v22];
    }
    else
    {
      if (v61 <= v22 || (v32 = v60, v60 > v22))
      {
        v33 = v14 - 3;
        if (v14 < 3)
          v33 = 0;
        v34 = v33 + 64;
        if (v33 + 64 >= v59)
          v34 = v59;
        v60 = v33;
        v61 = v34;
        v66.location = v58 + v33;
        v66.length = v34 - v33;
        CFStringGetCharacters(theString, v66, buffer);
        v32 = v60;
      }
      v31 = buffer[v22 - v32];
    }
    v44[1] = v31;
    if (CFStringEncodingUnicodeToBytes(134217984, 0, v44, 2, 0, v45, 6, &v42))
      break;
    if (v42 >= 1)
    {
      v35 = (unsigned int *)((char *)v45 + v42);
      v36 = &chars[v15 + 2];
      v37 = v45;
      do
      {
        v38 = *(unsigned __int8 *)v37;
        v37 = (unsigned int *)((char *)v37 + 1);
        *(v36 - 2) = 37;
        *(v36 - 1) = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)v38 >> 4];
        v15 += 3;
        *v36 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[v38 & 0xF];
        v36 += 3;
      }
      while (v37 < v35);
    }
    ++v14;
LABEL_74:
    ++v14;
  }
  while (v14 < v10);
  if (v14 >= v10)
  {
    if (MutableCopy)
    {
      if (v15)
        CFStringAppendCharacters(MutableCopy, chars, v15);
      return MutableCopy;
    }
    goto LABEL_83;
  }
  if (MutableCopy)
  {
    CFRelease(MutableCopy);
    return 0;
  }
  return MutableCopy;
}

uint64_t CFStringEncodingUnicodeToBytes(int a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, uint64_t *a5, unsigned int *a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v10;
  unint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t (*v19)(_QWORD, uint64_t, uint64_t);
  int v20;
  void *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  void (*v40)(void);
  uint64_t (*v41)(uint64_t *, _QWORD, unint64_t, uint64_t, _QWORD, _QWORD, uint64_t *);
  uint64_t v42;
  uint64_t (*v43)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *);
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t (*v47)(uint64_t *, _QWORD, unsigned __int16 *, uint64_t, _QWORD, _QWORD, uint64_t *);
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  uint64_t v52;
  char v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v57;
  uint64_t v58;
  uint64_t v60;
  _BYTE *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t *v65;
  unint64_t v66;
  unsigned __int16 *v67;
  void (**v68)(void);
  uint64_t (*v69)(_QWORD, uint64_t, uint64_t);
  uint64_t v70;
  unsigned int v71;
  uint64_t v72;
  unsigned int v73;
  uint64_t (*v74)(_QWORD);
  uint64_t v75;
  _QWORD v76[2];

  v10 = (uint64_t)a6;
  v13 = (unint64_t)a3;
  v14 = a2;
  v76[1] = *MEMORY[0x1E0C80C00];
  if (a1 == 134217984)
  {
    v75 = 0;
    v76[0] = 0;
    if ((a2 & 0xC0) != 0)
    {
      CFUniCharDecompose(a3, a4, v76, a6, a7, &v75, 1, 2, (a2 & 0x80) != 0);
      if (!a5)
      {
LABEL_5:
        if (a8)
          *a8 = v75;
        if (a4 == v76[0])
          return 0;
        if (a7 < 1)
          return 1;
        if (a7 - v75 > 9)
          return 1;
        v20 = *(_WORD *)(v13 + 2 * v76[0]) & 0xFC00;
        if (v20 == 56320
          || v20 == 55296
          && (a4 - v76[0] == 1
           || (unsigned __int16)((unsigned __int16)(*(_WORD *)(v13 + 2 * v76[0] + 2) + 0x2000) >> 10) < 0x3Fu))
        {
          return 1;
        }
        return 2;
      }
    }
    else
    {
      v21 = CFStringEncodingUnicodeToBytes___CFToUTF8;
      if (!CFStringEncodingUnicodeToBytes___CFToUTF8)
      {
        v21 = **(void ***)__CFGetConverter(134217984);
        CFStringEncodingUnicodeToBytes___CFToUTF8 = v21;
      }
      v76[0] = ((uint64_t (*)(_QWORD, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))v21)(0, v13, a4, v10, a7, &v75);
      if (!a5)
        goto LABEL_5;
    }
    *a5 = v76[0];
    goto LABEL_5;
  }
  v16 = (uint64_t *)((uint64_t (*)(void))__CFGetConverter)();
  v76[0] = 0;
  if (!v16)
    return 3;
  v17 = v16;
  if ((v14 & 8) != 0)
  {
    v18 = *v16;
    v19 = 0;
    if ((v14 & 1) != 0)
      v74 = 0;
    else
      v74 = *(uint64_t (**)(_QWORD))(v18 + 64);
  }
  else
  {
    v18 = *v16;
    v74 = *(uint64_t (**)(_QWORD))(*v16 + 64);
    if ((v14 & 0x20) != 0)
    {
      v19 = 0;
    }
    else
    {
      v19 = *(uint64_t (**)(_QWORD, uint64_t, uint64_t))(v18 + 56);
      v14 = v14 | 0x10;
    }
  }
  v22 = *(unsigned __int8 *)(v18 + 20);
  if (v22 == 4)
    return __CFStringEncodingPlatformUnicodeToBytes();
  if (v22 == 5)
    return __CFStringEncodingICUToBytes(v16[1], v14, v13, a4, a5, v10, a7, a8);
  if (a4 >= 1)
  {
    v69 = v19;
    v23 = 0;
    v24 = 0;
    v71 = BYTE3(v14);
    v73 = v14;
    v72 = v10;
    while (1)
    {
      if (a7 && a7 <= v23)
        goto LABEL_112;
      v25 = (uint64_t (*)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))v17[1];
      if (v25)
      {
        v26 = a7 ? a7 - v23 : 0;
        v27 = v25(v17, v14, v13 + 2 * v24, a4 - v24, v10 + v23, v26, v76);
      }
      else
      {
        v28 = a7 ? a7 - v23 : 0;
        v27 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))*v17)(v14, v13 + 2 * v24, a4 - v24, v10 + v23, v28, v76);
      }
      v29 = v27 + v24;
      v30 = a4 - (v27 + v24);
      if (a4 > v27 + v24)
        break;
      v24 += v27;
      v14 = v73;
LABEL_74:
      v23 += v76[0];
      v10 = v72;
      if (v24 >= a4)
        goto LABEL_112;
    }
    v70 = v27;
    v75 = 0;
    if (v74 && v29 >= 1 && (v67 = (unsigned __int16 *)(v13 + 2 * v29), v74(*v67)))
    {
      if (v69)
      {
        v66 = v13;
        v68 = (void (**)(void))v17;
        v64 = a5;
        v65 = a8;
        v31 = 0;
        v32 = 0;
        v33 = v29;
        v34 = v13 + 2 * v29;
        do
        {
          v35 = v33;
          v36 = v29 + v31;
          v37 = v74(*(unsigned __int16 *)(v34 + 2 * v31 - 2));
          v32 += 2;
          --v31;
          if (v36 < 2)
            break;
          v33 = v35 - 1;
        }
        while ((v37 & 1) != 0);
        v13 = v66;
        v38 = v66 + 2 * v29 - v32;
        v39 = v76[0] + v23;
        if (*((unsigned __int16 *)*v68 + 8) < 2u)
        {
          v23 = v39 - 1;
          v48 = v70;
        }
        else
        {
          v40 = v68[1];
          if (v40)
            v40();
          else
            (*(void (**)(_QWORD, unint64_t, uint64_t, _QWORD, _QWORD, _QWORD *))*v68)(v73, v66 + 2 * v29 - v32, -v31, 0, 0, v76);
          v23 = v39 - v76[0];
          v48 = v70;
          v38 = v66 + 2 * v29 - v32;
        }
        v62 = a4 - v48 - v24;
        if (a7)
          v49 = a7 - v23;
        else
          v49 = 0;
        v60 = v49;
        v61 = (_BYTE *)(v72 + v23);
        v50 = v69(v73, v38, v62 - v31);
        if (v50 < 1)
        {
          if ((v73 & 1) == 0)
          {
            v29 = v70 + v24 + v31;
            result = 1;
            a5 = v64;
            a8 = v65;
            v17 = (uint64_t *)v68;
            goto LABEL_146;
          }
          if (v71)
          {
            do
            {
              v42 = v35;
              if (v35 >= a4)
                break;
              v51 = v74(*(unsigned __int16 *)(v66 + 2 * v35++));
            }
            while ((v51 & 1) != 0);
            v76[0] = 1;
            a8 = v65;
            v14 = v73;
            if (a7)
              *v61 = v71;
            a5 = v64;
            v17 = (uint64_t *)v68;
            goto LABEL_73;
          }
          v17 = (uint64_t *)v68;
          v42 = ((uint64_t (*)(unint64_t, uint64_t, _BYTE *, uint64_t, _QWORD *))v68[4])(v66 + 2 * v29 - v32 + 2, ~v31 + v62, v61, v60, v76)+ v29+ v31+ 1;
          a5 = v64;
          a8 = v65;
        }
        else
        {
          v42 = v50 + v29 + v31;
          if (v42 >= a4)
          {
            a5 = v64;
            a8 = v65;
            v17 = (uint64_t *)v68;
          }
          else
          {
            v63 = v50;
            a5 = v64;
            a8 = v65;
            v17 = (uint64_t *)v68;
            if (v74(*(unsigned __int16 *)(v66 + 2 * v42)))
            {
              v23 += v76[0];
              v29 = v70 + v24 + v63 + v31;
LABEL_145:
              result = 1;
LABEL_146:
              LODWORD(v14) = v73;
LABEL_147:
              v24 = v29;
              if (a7)
                goto LABEL_113;
              goto LABEL_126;
            }
          }
        }
        goto LABEL_72;
      }
      if (a7)
      {
        if (v76[0] + v23 == a7)
          goto LABEL_143;
        v47 = (uint64_t (*)(uint64_t *, _QWORD, unsigned __int16 *, uint64_t, _QWORD, _QWORD, uint64_t *))v17[1];
        if (v47)
        {
          if (v47(v17, v73, v67, v30, 0, 0, &v75))
            goto LABEL_143;
        }
        else if ((*(uint64_t (**)(_QWORD, unsigned __int16 *, uint64_t, _QWORD, _QWORD, uint64_t *))*v17)(v73, v67, v30, 0, 0, &v75))
        {
LABEL_143:
          v23 += v76[0];
          result = 2;
          goto LABEL_146;
        }
      }
      if ((v73 & 0x20) != 0)
      {
        v52 = v70 + v24 + 1;
        v14 = v73;
        do
        {
          v42 = v52;
          if (v52 >= a4)
            break;
          v53 = v74(*(unsigned __int16 *)(v13 + 2 * v52));
          v52 = v42 + 1;
        }
        while ((v53 & 1) != 0);
        goto LABEL_73;
      }
      v23 += v76[0];
      if (!v71)
      {
        v43 = (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))v17[4];
        v45 = v72 + v23;
        if (a7)
          v46 = a7 - v23;
        else
          v46 = 0;
        v44 = v13 + 2 * v29;
        goto LABEL_71;
      }
    }
    else
    {
      if (a7)
      {
        if (v76[0] + v23 == a7)
          goto LABEL_132;
        v41 = (uint64_t (*)(uint64_t *, _QWORD, unint64_t, uint64_t, _QWORD, _QWORD, uint64_t *))v17[1];
        if (v41)
        {
          if (v41(v17, v73, v13 + 2 * v29, v30, 0, 0, &v75))
            goto LABEL_132;
        }
        else if ((*(uint64_t (**)(_QWORD, unint64_t, uint64_t, _QWORD, _QWORD, uint64_t *))*v17)(v73, v13 + 2 * v29, v30, 0, 0, &v75))
        {
LABEL_132:
          v23 += v76[0];
          LODWORD(v14) = v73;
          if ((v73 & 0xFF000001) == 1)
          {
            v76[0] = 0;
            do
            {
              v57 = ((uint64_t (*)(unint64_t, uint64_t, _QWORD, _QWORD, _QWORD *))v17[4])(v13 + 2 * v29, a4 - v29, 0, 0, v76);
              if (!v57)
                break;
              v58 = v76[0] ? 0 : v57;
              v29 += v58;
            }
            while (v29 < a4 && v76[0] == 0);
          }
          result = 2 * (v29 < a4);
          goto LABEL_147;
        }
      }
      v23 += v76[0];
      if ((v73 & 1) == 0)
        goto LABEL_145;
      if (!v71)
      {
        v43 = (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))v17[4];
        v44 = v13 + 2 * v29;
        v45 = v72 + v23;
        if (a7)
          v46 = a7 - v23;
        else
          v46 = 0;
LABEL_71:
        v42 = v43(v44, v30, v45, v46, v76) + v29;
LABEL_72:
        v14 = v73;
LABEL_73:
        v24 = v42;
        goto LABEL_74;
      }
    }
    v42 = v29 + 1;
    v76[0] = 1;
    if (a7)
      *(_BYTE *)(v72 + v23) = v71;
    goto LABEL_72;
  }
  v24 = 0;
  v23 = 0;
LABEL_112:
  result = 0;
  if (a7)
  {
LABEL_113:
    if (v24 < a4 && !(_DWORD)result)
    {
      if ((v14 & 0xFF000001) == 1)
      {
        v76[0] = 0;
        do
        {
          v54 = ((uint64_t (*)(unint64_t, uint64_t, _QWORD, _QWORD, _QWORD *))v17[4])(v13 + 2 * v24, a4 - v24, 0, 0, v76);
          if (!v54)
            break;
          v55 = v76[0] ? 0 : v54;
          v24 += v55;
        }
        while (v24 < a4 && v76[0] == 0);
      }
      result = 2 * (v24 < a4);
    }
  }
LABEL_126:
  if (a8)
    *a8 = v23;
  if (a5)
    *a5 = v24;
  return result;
}

uint64_t __CFToUTF8(char a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  _BYTE *v6;
  unsigned __int16 *v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int16 *v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  unsigned __int16 v14;
  uint64_t v16;

  v6 = a4;
  v7 = a2;
  if (a3 < 1)
  {
LABEL_43:
    if (!a6)
      return v7 - a2;
    goto LABEL_44;
  }
  v8 = (unint64_t)&a2[a3];
  v9 = (unint64_t)&a4[a5];
  v10 = a2;
  v6 = a4;
  while (1)
  {
    if (a5 && (unint64_t)v6 >= v9)
    {
LABEL_42:
      v7 = v10;
      goto LABEL_43;
    }
    v7 = v10 + 1;
    v11 = *v10;
    if (v11 <= 0x7F)
    {
      if (a5)
        *v6 = v11;
      v12 = 1;
      goto LABEL_40;
    }
    if (v11 >> 11 >= 0x1B)
    {
      if (v11 >> 10 > 0x36)
      {
        if ((a1 & 0x80) == 0 && v11 < 0xE000)
          goto LABEL_42;
      }
      else if ((unint64_t)v7 < v8 && (v13 = *v7, (v13 & 0xFC00) == 0xDC00))
      {
        v7 = v10 + 2;
        v11 = v13 + (v11 << 10) - 56613888;
      }
      else if ((a1 & 0x80) == 0)
      {
        goto LABEL_42;
      }
    }
    if (!a5)
    {
      if (v11 < 0x10000)
        v14 = 3;
      else
        v14 = 4;
      if (v11 < 0x800)
        v14 = 2;
      if (v11 < 0x80)
        v14 = 1;
      goto LABEL_39;
    }
    if (v11 < 0x10000)
      v14 = 3;
    else
      v14 = 4;
    if (v11 < 0x800)
      v14 = 2;
    if (v11 < 0x80)
      v14 = 1;
    if (v14 > (v9 - (_DWORD)v6))
      break;
    switch(v14)
    {
      case 1u:
        goto LABEL_31;
      case 2u:
        goto LABEL_30;
      case 3u:
        goto LABEL_29;
      case 4u:
        v6[3] = v11 & 0x3F | 0x80;
        v11 >>= 6;
LABEL_29:
        v6[2] = v11 & 0x3F | 0x80;
        v11 >>= 6;
LABEL_30:
        v6[1] = v11 & 0x3F | 0x80;
        v11 >>= 6;
LABEL_31:
        *v6 = firstByteMark[v14] | v11;
        break;
      default:
        break;
    }
LABEL_39:
    v12 = v14;
LABEL_40:
    v6 += v12;
    v10 = v7;
    if ((unint64_t)v7 >= v8)
      goto LABEL_43;
  }
  v16 = -4;
  if (v11 < 0x10000)
    v16 = -2;
  v7 = (unsigned __int16 *)((char *)v7 + v16);
  if (a6)
LABEL_44:
    *a6 = v6 - a4;
  return v7 - a2;
}

_OWORD *CFStringEncodingGetConverter(uint64_t a1)
{
  _OWORD *result;

  result = __CFGetConverter(a1);
  if (result)
    return *(_OWORD **)result;
  return result;
}

_QWORD *CFStringEncodingIsValidEncoding(uint64_t a1)
{
  _QWORD *result;

  result = (_QWORD *)__CFGetConverter(a1);
  if (result)
    return (_QWORD *)(*result != 0);
  return result;
}

_OWORD *__CFGetConverter(uint64_t a1)
{
  uint64_t *v2;
  CFStringEncoding SystemEncoding;
  int v4;
  _OWORD *Value;
  uint64_t (**ExternalConverter)();
  uint64_t Typed;
  unsigned int v8;
  unsigned int v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t (*v12)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned __int16 *, uint64_t, _QWORD *);
  int8x16_t v13;
  __CFDictionary *Mutable;

  switch((_DWORD)a1)
  {
    case 0xFFFFFFFF:
      return 0;
    case 0x8000100:
      v2 = &__CFGetConverter_commonConverters;
      goto LABEL_6;
    case 0:
      v2 = &qword_1ECCFAC50;
LABEL_6:
      os_unfair_lock_lock((os_unfair_lock_t)&__CFGetConverter_lock);
LABEL_9:
      v4 = 0;
      Value = (_OWORD *)*v2;
      goto LABEL_10;
  }
  SystemEncoding = CFStringGetSystemEncoding();
  os_unfair_lock_lock((os_unfair_lock_t)&__CFGetConverter_lock);
  if (SystemEncoding == (_DWORD)a1)
  {
    v2 = &qword_1ECCFAC58;
    goto LABEL_9;
  }
  if (!__CFGetConverter_mappingTable)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__CFGetConverter_lock);
    v2 = 0;
    v4 = 1;
    goto LABEL_11;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)__CFGetConverter_mappingTable, (const void *)a1);
  v2 = 0;
  v4 = 1;
LABEL_10:
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFGetConverter_lock);
  if (!Value)
  {
LABEL_11:
    if ((int)a1 > 1535)
    {
      switch((_DWORD)a1)
      {
        case 0x600:
          ExternalConverter = __CFConverterASCII;
          goto LABEL_28;
        case 0xB01:
          ExternalConverter = __CFConverterNextStepLatin;
          goto LABEL_28;
        case 0x8000100:
          ExternalConverter = __CFConverterUTF8;
          goto LABEL_28;
      }
    }
    else
    {
      switch((_DWORD)a1)
      {
        case 0:
          ExternalConverter = __CFConverterMacRoman;
          goto LABEL_28;
        case 0x201:
          ExternalConverter = __CFConverterISOLatin1;
          goto LABEL_28;
        case 0x500:
          ExternalConverter = __CFConverterWinLatin1;
          goto LABEL_28;
      }
    }
    ExternalConverter = __CFStringEncodingGetExternalConverter(a1);
    if (ExternalConverter)
    {
LABEL_28:
      os_unfair_lock_lock((os_unfair_lock_t)&__CFGetConverter_lock);
      if (v4)
      {
        if (!__CFGetConverter_mappingTable
          || (Value = CFDictionaryGetValue((CFDictionaryRef)__CFGetConverter_mappingTable, (const void *)a1)) == 0)
        {
LABEL_34:
          if ((__CFEncodingConverterFromDefinition__currentIndex - 9) > 0xFFFFFFF5)
          {
            Typed = __CFEncodingConverterFromDefinition__allocatedEntries;
            if (__CFEncodingConverterFromDefinition__allocatedEntries)
            {
              v8 = ++__CFEncodingConverterFromDefinition__currentIndex;
              goto LABEL_39;
            }
          }
          else
          {
            __CFEncodingConverterFromDefinition__currentIndex = 0;
            __CFEncodingConverterFromDefinition__allocatedEntries = 0;
          }
          Typed = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 480, 0xE004030B2989CLL, 0);
          __CFEncodingConverterFromDefinition__allocatedEntries = Typed;
          v8 = __CFEncodingConverterFromDefinition__currentIndex;
LABEL_39:
          Value = (_OWORD *)(Typed + 48 * v8);
          Value[1] = 0u;
          Value[2] = 0u;
          *Value = 0u;
          *(_QWORD *)Value = ExternalConverter;
          v9 = v8;
          switch(*((_BYTE *)ExternalConverter + 20))
          {
            case 0:
              v10 = (_QWORD *)(Typed + 48 * v8);
              v10[1] = 0;
              v10[2] = 0;
              v10[3] = 0;
              goto LABEL_48;
            case 1:
              v11 = (_QWORD *)(Typed + 48 * v8);
              v11[1] = __CFToBytesCheapEightBitWrapper;
              v11[2] = __CFToUnicodeCheapEightBitWrapper;
              v12 = __CFToCanonicalUnicodeCheapEightBitWrapper;
              goto LABEL_46;
            case 2:
              v11 = (_QWORD *)(Typed + 48 * v8);
              v11[1] = __CFToBytesStandardEightBitWrapper;
              v11[2] = __CFToUnicodeStandardEightBitWrapper;
              v12 = __CFToCanonicalUnicodeStandardEightBitWrapper;
              goto LABEL_46;
            case 3:
              v11 = (_QWORD *)(Typed + 48 * v8);
              v11[1] = __CFToBytesCheapMultiByteWrapper;
              v11[2] = __CFToUnicodeCheapMultiByteWrapper;
              v12 = __CFToCanonicalUnicodeCheapMultiByteWrapper;
LABEL_46:
              v11[3] = v12;
              goto LABEL_48;
            case 4:
              goto LABEL_48;
            case 5:
              *(_QWORD *)(Typed + 48 * v8 + 8) = __CFStringEncodingGetICUName(a1);
LABEL_48:
              v13.i64[0] = (uint64_t)__CFDefaultToBytesFallbackProc;
              v13.i64[1] = (uint64_t)__CFDefaultToUnicodeFallbackProc;
              *(int8x16_t *)(Typed + 48 * v9 + 32) = vbslq_s8((int8x16_t)vceqzq_s64(*(int64x2_t *)(ExternalConverter + 5)), v13, *(int8x16_t *)(ExternalConverter + 5));
              if (v4)
                goto LABEL_49;
              goto LABEL_42;
            default:
              Value = 0;
              if (v4)
              {
LABEL_49:
                Mutable = (__CFDictionary *)__CFGetConverter_mappingTable;
                if (!__CFGetConverter_mappingTable)
                {
                  Mutable = CFDictionaryCreateMutable(0, 0, 0, 0);
                  __CFGetConverter_mappingTable = (uint64_t)Mutable;
                }
                CFDictionarySetValue(Mutable, (const void *)a1, Value);
              }
              else
              {
LABEL_42:
                *v2 = (uint64_t)Value;
              }
              break;
          }
        }
      }
      else
      {
        Value = (_OWORD *)*v2;
        if (!*v2)
          goto LABEL_34;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFGetConverter_lock);
      return Value;
    }
    return 0;
  }
  return Value;
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  _OWORD *Converter;
  _OWORD *v1;
  _OWORD *v2;

  if ((__CFDefaultSystemEncoding & 1) == 0)
  {
    if ((__CFIsReadyToInitializeSystemEncoding & 1) != 0)
    {
      if ((__CFStringIsBeingInitialized & 1) == 0)
      {
        __CFStringIsBeingInitialized = 1;
        Converter = CFStringEncodingGetConverter(0);
        __CFDefaultSystemEncoding = 1;
        if (!Converter)
          Converter = CFStringEncodingGetConverter(0);
        if (*((_BYTE *)Converter + 20) == 1)
          v1 = (_OWORD *)*((_QWORD *)Converter + 1);
        else
          v1 = 0;
        __CFSetCharToUniCharFunc(v1);
        __CFStringIsBeingInitialized = 0;
      }
    }
    else if (!__CFCharToUniCharFunc)
    {
      v2 = CFStringEncodingGetConverter(0);
      __CFSetCharToUniCharFunc(*((_OWORD **)v2 + 1));
    }
  }
  return 0;
}

uint64_t __CFToBytesCheapEightBitWrapper(unsigned int (***a1)(uint64_t, _QWORD, char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v9;
  uint64_t v15;
  char v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a6 >= a4 || a6 == 0)
    v9 = a4;
  else
    v9 = a6;
  if (v9 < 1)
  {
    v15 = 0;
  }
  else
  {
    v15 = 0;
    v17 = 0;
    while ((**a1)(a2, *(unsigned __int16 *)(a3 + 2 * v15), &v17))
    {
      if (a6)
        *(_BYTE *)(a5 + v15) = v17;
      if (v9 == ++v15)
      {
        v15 = v9;
        break;
      }
    }
  }
  *a7 = v15;
  return v15;
}

BOOL __CFToISOLatin1(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0xFF)
    *a3 = a2;
  return a2 < 0x100;
}

BOOL __CFToASCII(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  if (a2 <= 0x7F)
    *a3 = a2;
  return a2 < 0x80;
}

uint64_t __CFToMacRoman(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;

  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1277) >= 0x59Du)
    {
      v4 = (unsigned __int16 *)&macRoman_from_uni;
      v5 = (unsigned __int16 *)&unk_182C87510;
      do
      {
        v6 = ((char *)v5 - (char *)v4) >> 3;
        v7 = &v4[2 * v6];
        v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          v4 = v7 + 2;
        }
        else
        {
          v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

uint64_t _stringContainsCharacter(const __CFString *a1, int a2)
{
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  UniChar v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFIndex v18;
  CFRange v19;
  uint64_t v20;
  _OWORD v22[8];
  CFStringRef theString;
  const UniChar *v24;
  const char *v25;
  uint64_t v26;
  CFIndex v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  theString = a1;
  v26 = 0;
  v27 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v24 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v28 = 0;
  v29 = 0;
  v25 = CStringPtr;
  if (Length < 1)
    return 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 64;
  memset(v22, 0, sizeof(v22));
  while (1)
  {
    v11 = (unint64_t)v9 >= 4 ? 4 : v9;
    if (v24)
    {
      v12 = v24[v9 + v26];
    }
    else if (v25)
    {
      v12 = v25[v26 + v9];
    }
    else
    {
      if (v29 <= v9 || v8 > v9)
      {
        v14 = -v11;
        v15 = v11 + v7;
        v16 = v10 - v11;
        v17 = v9 + v14;
        v18 = v17 + 64;
        if (v17 + 64 >= v27)
          v18 = v27;
        v28 = v17;
        v29 = v18;
        v19.location = v17 + v26;
        if (v27 >= v16)
          v20 = v16;
        else
          v20 = v27;
        v19.length = v20 + v15;
        CFStringGetCharacters(theString, v19, (UniChar *)v22);
        v8 = v28;
      }
      v12 = *((_WORD *)v22 + v9 - v8);
    }
    if (a2 == v12)
      break;
    ++v9;
    --v7;
    ++v10;
    if (Length == v9)
      return 0;
  }
  return 1;
}

uint64_t CFStringEncodingIsValidCombiningCharacterForLatin1(int a1)
{
  if ((a1 - 768) > 0x5F)
    return 0;
  else
    return (__CFLatin1CombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
}

CFURLRef CFURLCreateCopyDeletingPathExtension(CFAllocatorRef allocator, CFURLRef url)
{
  CFURLRef v2;
  int v4;
  CFIndex PathComponent;
  CFIndex v6;
  CFIndex v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  CFMutableStringRef MutableCopy;
  const __CFURL *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFRange v18;
  CFRange v19;

  v2 = url;
  v17 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
    v2 = (CFURLRef)-[__CFURL _cfurl](v2, "_cfurl");
  v4 = CFURLIsFileReferenceURL(v2);
  if (v4)
  {
    v2 = CFURLCreateFilePathURL(allocator, v2, 0);
    if (!v2)
      return 0;
  }
  PathComponent = _rangeOfLastPathComponent((uint64_t)v2);
  if (PathComponent == -1
    || (v7 = PathComponent,
        v19.length = v6,
        v8 = (const __CFString *)atomic_load((unint64_t *)v2 + 3),
        v19.location = PathComponent,
        (v9 = CFStringCreateWithSubstring(allocator, v8, v19)) == 0))
  {
    v13 = 0;
    if (!v4)
      return v13;
    goto LABEL_17;
  }
  v10 = v9;
  v15 = 0;
  v16 = 0;
  _CFGetPathExtensionRangesFromPathComponent(v9, &v15, 0);
  if (v15 == -1)
  {
    v13 = (const __CFURL *)CFRetain(v2);
  }
  else
  {
    v11 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
    MutableCopy = CFStringCreateMutableCopy(allocator, 0, v11);
    v18.location = v7 + v15 - 1;
    v18.length = v16 + 1;
    CFStringDelete(MutableCopy, v18);
    if (MutableCopy)
      v13 = (const __CFURL *)_CFURLCreateWithURLString((__objc2_class **)allocator, MutableCopy, 0, *((const __CFURL **)v2 + 4));
    else
      v13 = 0;
    CFRelease(MutableCopy);
  }
  CFRelease(v10);
  if (v4)
LABEL_17:
    CFRelease(v2);
  return v13;
}

CFStringRef CFURLCopyPathExtension(CFURLRef url)
{
  const __CFString *PathComponent;
  const __CFString *v3;
  const __CFAllocator *v4;
  const __CFString *v5;
  CFRange v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  PathComponent = CFURLCopyLastPathComponent(url);
  if (!PathComponent)
    return 0;
  v3 = PathComponent;
  v7.location = 0;
  v7.length = 0;
  _CFGetPathExtensionRangesFromPathComponent(PathComponent, &v7.location, 0);
  if (v7.location == -1)
  {
    v5 = 0;
  }
  else
  {
    v4 = CFGetAllocator(url);
    v5 = CFStringCreateWithSubstring(v4, v3, v7);
  }
  CFRelease(v3);
  return v5;
}

void _CFGetPathExtensionRangesFromPathComponent(const __CFString *a1, uint64_t *a2, uint64_t *a3)
{
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  CFIndex v13;
  CFIndex v14;
  UniChar *v15;
  uint64_t v16;
  CFIndex v17;
  uint64_t v18;
  UniChar v19;
  CFIndex v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  CFIndex v24;
  uint64_t v25;
  uint64_t v26;
  CFIndex v27;
  CFRange v28;
  CFIndex v29;
  CFIndex v30;
  UniChar *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  unint64_t v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  CFIndex v40;
  unint64_t v41;
  UniChar *v42;
  CFRange v43;
  const char *v44;
  UniChar *v45;
  UniChar v46;
  CFIndex v47;
  CFIndex v48;
  CFIndex v49;
  uint64_t v50;
  CFIndex v51;
  UniChar *v52;
  __int16 v53;
  uint64_t v54;
  uint64_t v55;
  CFIndex v56;
  CFIndex v57;
  CFIndex v58;
  CFRange v59;
  CFIndex v60;
  uint64_t v61;
  CFIndex v62;
  char *v63;
  CFIndex v64;
  int64_t v65;
  uint64_t v66;
  UniChar v67;
  uint64_t v69;
  uint64_t v70;
  CFIndex v71;
  uint64_t v72;
  CFIndex v73;
  CFRange v74;
  CFIndex v75;
  int64_t v76;
  int64_t v77;
  uint64_t v78;
  UniChar v79;
  uint64_t v81;
  uint64_t v82;
  CFIndex v83;
  uint64_t v84;
  CFIndex v85;
  CFRange v86;
  CFIndex v87;
  UniChar v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  CFIndex v92;
  _BOOL4 v93;
  _BOOL4 v94;
  int64_t v95;
  UniChar buffer[8];
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  CFStringRef theString;
  const UniChar *v105;
  const char *v106;
  CFIndex v107;
  CFIndex v108;
  uint64_t v109;
  CFIndex v110;
  uint64_t v111;
  CFRange v112;

  v111 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  theString = a1;
  v107 = 0;
  v108 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v105 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v109 = 0;
  v110 = 0;
  v106 = CStringPtr;
  if (!((unint64_t)a2 | (unint64_t)a3))
    return;
  if (Length < 2)
    goto LABEL_60;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = Length - 1;
  v102 = 0u;
  v103 = 0u;
  v100 = 0u;
  v101 = 0u;
  v98 = 0u;
  v99 = 0u;
  v13 = 1 - Length;
  v14 = Length + 63;
  *(_OWORD *)buffer = 0u;
  v97 = 0u;
  v15 = &buffer[Length - 1];
  v16 = 2 - 2 * Length;
  while (1)
  {
    v17 = Length + v10;
    if (v12 >= 0x3F)
      v18 = 63;
    else
      v18 = v12;
    if (v105)
    {
      v19 = v105[v17 - 1 + v107];
    }
    else if (v106)
    {
      v19 = v106[v107 - 1 + Length + v10];
    }
    else
    {
      v20 = v17 - 1;
      v21 = v110 > v20 && v11 <= v20;
      if (!v21)
      {
        v22 = ~v18;
        v23 = v18 ^ 0x3F;
        v24 = v14 - v18;
        v25 = v18 + v9;
        v26 = Length + v10 + v22;
        v27 = Length + v10 + v23;
        if (v27 >= v108)
          v27 = v108;
        v109 = v26;
        v110 = v27;
        v28.location = v26 + v107;
        if (v108 >= v24)
          v29 = v24;
        else
          v29 = v108;
        v28.length = v13 + v25 + v29;
        v30 = v13;
        v31 = v15;
        CFStringGetCharacters(theString, v28, buffer);
        v15 = v31;
        v13 = v30;
        v11 = v109;
      }
      v19 = v15[v10 - v11];
    }
    v32 = 0;
    v33 = v19;
    v34 = -1;
    if (v33 > 8233)
    {
      v35 = v33 - 8234;
      v21 = v35 > 0x3F;
      v36 = (1 << v35) & 0xF00000000000001FLL;
      v37 = v21 || v36 == 0;
      v38 = 0;
      v39 = -1;
      if (!v37)
        goto LABEL_63;
      goto LABEL_37;
    }
    if (v33 > 1563)
    {
      if ((v33 - 8206) < 2)
      {
LABEL_39:
        v38 = 0;
        goto LABEL_62;
      }
      v38 = 0;
      v39 = -1;
      if (v33 == 1564)
        goto LABEL_63;
      goto LABEL_37;
    }
    if (v33 == 32)
      goto LABEL_39;
    if (v33 == 46)
      break;
    v38 = 0;
    v39 = -1;
    if (v33 == 47)
      goto LABEL_63;
LABEL_37:
    --v12;
    v16 += 2;
    --v14;
    --v10;
    ++v9;
    if (Length + v10 <= 1)
    {
      v32 = 0;
      v38 = 0;
LABEL_91:
      v34 = -1;
      goto LABEL_63;
    }
  }
  if (!v10)
  {
    v32 = 0;
    v38 = 0;
    goto LABEL_62;
  }
  v40 = Length + v10;
  v41 = Length + v10 - 1;
  if (v41 > 2)
    goto LABEL_68;
  if (v105)
  {
    v42 = (UniChar *)&v105[v107];
  }
  else
  {
    if ((uint64_t)v41 > v110 || v11 >= 1)
    {
      if (v108 >= 64)
        v43.length = 64;
      else
        v43.length = v108;
      v109 = 0;
      v110 = v43.length;
      v43.location = v107;
      if (v106)
      {
        if (v43.length)
        {
          v44 = &v106[v107];
          v45 = buffer;
          do
          {
            v46 = *v44++;
            *v45++ = v46;
            --v43.length;
          }
          while (v43.length);
        }
      }
      else
      {
        v47 = v13;
        CFStringGetCharacters(theString, v43, buffer);
        v13 = v47;
      }
    }
    v11 = v109;
    v42 = &buffer[-v109];
  }
  if (*v42 != 46)
    goto LABEL_68;
  v32 = v40 - 2;
  if (v40 == 2)
    goto LABEL_61;
  if (v42[1] != 46)
  {
LABEL_68:
    v39 = Length + v10;
    v38 = -v10;
    if (!a3)
    {
LABEL_90:
      v32 = 0;
      goto LABEL_91;
    }
    v48 = v40 + 63;
    v49 = v13 - v10;
    while (1)
    {
      if (v41 >= 0x40)
        v50 = 64;
      else
        v50 = v41;
      v51 = v40 - 1;
      if (v40 - 1 < 2)
        goto LABEL_90;
      if (v105)
      {
        v52 = (UniChar *)&v105[v40 + v107];
      }
      else
      {
        if (v106)
        {
          v53 = v106[v107 - 2 + v40];
          goto LABEL_79;
        }
        if (v110 < v51 || v11 >= v51)
        {
          v54 = -v50;
          v55 = v50 + v49;
          v56 = v48 - v50;
          v57 = v40 + v54;
          v58 = v57 + 63;
          if (v57 + 63 >= v108)
            v58 = v108;
          v109 = v57 - 1;
          v110 = v58;
          v59.location = v57 + v107 - 1;
          if (v108 >= v56)
            v60 = v56;
          else
            v60 = v108;
          v59.length = v60 + v55;
          CFStringGetCharacters(theString, v59, buffer);
          v11 = v109;
        }
        v52 = &buffer[v40 - v11];
      }
      v53 = *(v52 - 2);
LABEL_79:
      v16 += 2;
      ++v49;
      --v48;
      --v41;
      --v40;
      if (v53 != 32)
      {
        v61 = 0;
        v62 = 1 - v51;
        v63 = (char *)buffer - v16;
        v64 = v51 + 63;
        v65 = v51 - 1;
        while (1)
        {
          v66 = (unint64_t)v65 >= 0x3F ? 63 : v65;
          if (v105)
          {
            v67 = v105[v65 + v107];
          }
          else if (v106)
          {
            v67 = v106[v107 + v65];
          }
          else
          {
            if (v110 <= v65 || v11 > v65)
            {
              v69 = -v66;
              v70 = v66 + v62;
              v71 = v64 - v66;
              v72 = v65 + v69;
              v73 = v72 + 64;
              if (v72 + 64 >= v108)
                v73 = v108;
              v109 = v72;
              v110 = v73;
              v74.location = v72 + v107;
              if (v108 >= v71)
                v75 = v71;
              else
                v75 = v108;
              v74.length = v75 + v70;
              CFStringGetCharacters(theString, v74, buffer);
              v11 = v109;
            }
            v67 = *(_WORD *)&v63[-2 * v11];
          }
          if (v67 == 32 || v67 == 46)
            break;
          ++v61;
          --v64;
          v63 -= 2;
          ++v62;
          v34 = -1;
          v21 = v65-- <= 1;
          if (v21)
          {
LABEL_137:
            v32 = 0;
            goto LABEL_63;
          }
        }
        v95 = v65 + 1;
        v76 = -v65;
        v77 = v65 + 64;
        while (1)
        {
          v78 = (unint64_t)v65 >= 0x3F ? 63 : v65;
          if (v105)
          {
            v79 = v105[v65 + v107];
          }
          else if (v106)
          {
            v79 = v106[v107 + v65];
          }
          else
          {
            if (v110 <= v65 || v11 > v65)
            {
              v81 = -v78;
              v82 = v78 + v76;
              v83 = v77 - v78;
              v84 = v65 + v81;
              v85 = v84 + 64;
              if (v84 + 64 >= v108)
                v85 = v108;
              v109 = v84;
              v110 = v85;
              v86.location = v84 + v107;
              if (v108 >= v83)
                v87 = v83;
              else
                v87 = v108;
              v86.length = v87 + v82;
              CFStringGetCharacters(theString, v86, buffer);
              v11 = v109;
            }
            v79 = *(_WORD *)&v63[-2 * v11];
          }
          if (v79 != 32)
            break;
          --v77;
          v63 -= 2;
          ++v76;
          v34 = -1;
          v21 = v65-- <= 1;
          if (v21)
            goto LABEL_137;
        }
        if (v105)
        {
          v88 = v105[v107 + v65];
          v89 = v95;
        }
        else
        {
          v89 = v95;
          if (v106)
          {
            v88 = v106[v107 + v65];
          }
          else
          {
            if (v110 <= v65 || v11 > v65)
            {
              v90 = 63;
              if ((unint64_t)v65 < 0x3F)
                v90 = v65;
              v91 = v65 - v90 + 64;
              if (v91 >= v108)
                v91 = v108;
              v109 = v65 - v90;
              v110 = v91;
              v92 = v77 - v90;
              if (v108 < v77 - v90)
                v92 = v108;
              v112.length = v90 + v92 - v65;
              v112.location = v65 - v90 + v107;
              CFStringGetCharacters(theString, v112, buffer);
              v11 = v109;
            }
            v88 = *(_WORD *)&v63[-2 * v11];
          }
        }
        v93 = v88 == 46;
        v94 = v61 != 0;
        if (v93 && v94)
          v32 = v61;
        else
          v32 = 0;
        if (v93 && v94)
          v34 = v89;
        else
          v34 = -1;
        goto LABEL_63;
      }
    }
  }
LABEL_60:
  v32 = 0;
LABEL_61:
  v38 = 0;
  v34 = -1;
LABEL_62:
  v39 = -1;
LABEL_63:
  if (a2)
  {
    *a2 = v39;
    a2[1] = v38;
  }
  if (a3)
  {
    *a3 = v34;
    a3[1] = v32;
  }
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  CFURLRef v1;
  const __CFAllocator *v2;
  const __CFString *v3;
  const __CFString *v4;
  CFIndex Length;
  CFIndex v6;
  CFIndex v7;
  CFIndex v8;
  CFIndex v9;
  BOOL v10;
  const __CFAllocator *v11;
  const __CFString *v12;
  int v13;
  const __CFAllocator *v14;
  CFIndex PathComponent;
  CFIndex v16;
  CFIndex v17;
  CFIndex v18;
  const __CFString *v19;
  const __CFAllocator *v21;
  const __CFString *v22;
  int v23;
  const __CFString *v24;
  const __CFAllocator *v25;
  CFStringRef v26;
  const __CFString *v27;
  CFRange result;
  uint64_t v29;
  CFRange v30;
  CFRange v31;
  CFRange v32;

  v1 = url;
  v29 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
  {
    v2 = CFGetAllocator(v1);
    v3 = CFURLCreateStringWithFileSystemPath(v2, (__objc2_class **)v1, 0, 0);
    v4 = v3;
    result.location = 0;
    result.length = 0;
    if (v3)
    {
      Length = CFStringGetLength(v3);
      if (Length)
      {
        v6 = Length;
        v7 = Length - 1;
        if (CFStringGetCharacterAtIndex(v4, Length - 1) != 47)
          v7 = v6;
        if (v7)
        {
          v30.location = 0;
          v30.length = v7;
          if (CFStringFindWithOptions(v4, CFSTR("/"), v30, 4uLL, &result))
            v8 = result.location + 1;
          else
            v8 = 0;
          v9 = v7 - v8;
          if (v8)
            v10 = 0;
          else
            v10 = v9 == v6;
          if (!v10)
          {
            v11 = CFGetAllocator(v1);
            v31.location = v8;
            v31.length = v9;
            v12 = CFStringCreateWithSubstring(v11, v4, v31);
            CFRelease(v4);
            return v12;
          }
        }
      }
    }
    return v4;
  }
  v13 = CFURLIsFileReferenceURL(v1);
  if (v13)
  {
    v14 = CFGetAllocator(v1);
    v1 = CFURLCreateFilePathURL(v14, v1, 0);
    if (!v1)
      return 0;
  }
  PathComponent = _rangeOfLastPathComponent((uint64_t)v1);
  if (PathComponent == -1 || (v17 = v16) == 0)
  {
    if (v13)
      CFRelease(v1);
    return (CFStringRef)CFRetain(&stru_1E1337B18);
  }
  else
  {
    v18 = PathComponent;
    if (v16 != 1
      || (v19 = (const __CFString *)atomic_load((unint64_t *)v1 + 3), CFStringGetCharacterAtIndex(v19, v18) != 47))
    {
      v21 = CFGetAllocator(v1);
      v22 = (const __CFString *)atomic_load((unint64_t *)v1 + 3);
      v32.location = v18;
      v32.length = v17;
      v4 = CFStringCreateWithSubstring(v21, v22, v32);
      if ((*((_BYTE *)v1 + 17) & 0x80) == 0)
      {
        v23 = *((_DWORD *)v1 + 5);
        if (_CFURLHasFileURLScheme((__objc2_class **)v1, 0))
          v24 = CFSTR("/");
        else
          v24 = &stru_1E1337B18;
        v25 = CFGetAllocator(v1);
        if (v23 == 134217984)
          v26 = CFURLCreateStringByReplacingPercentEscapes(v25, v4, v24);
        else
          v26 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v25, v4, v24, *((_DWORD *)v1 + 5));
        v27 = v26;
        CFRelease(v4);
        v4 = v27;
      }
      if (v13)
        CFRelease(v1);
      return v4;
    }
    if (v13)
      CFRelease(v1);
    return (CFStringRef)CFRetain(CFSTR("/"));
  }
}

CFURLRef CFURLCreateCopyAppendingPathExtension(CFAllocatorRef allocator, CFURLRef url, CFStringRef extension)
{
  int v6;
  const __CFURL *v7;
  CFIndex PathComponent;
  uint64_t v9;
  CFIndex v11;
  uint64_t v12;
  const __CFString *v13;
  __CFString *MutableCopy;
  __CFString *v15;
  CFIndex v16;
  const __CFString *v17;
  unint64_t *v18;
  const __CFString *v19;

  if (!CFStringGetLength(extension))
    return (CFURLRef)CFRetain(url);
  if (!_CFExtensionIsValidToAppend(extension))
    return 0;
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
    url = (CFURLRef)-[__CFURL _cfurl](url, "_cfurl");
  v6 = CFURLIsFileReferenceURL(url);
  if (v6)
  {
    v7 = CFURLCreateFilePathURL(allocator, url, 0);
    if (!v7)
      return 0;
    url = v7;
    PathComponent = _rangeOfLastPathComponent((uint64_t)v7);
    if (PathComponent == -1)
    {
      CFRelease(url);
      return 0;
    }
  }
  else
  {
    PathComponent = _rangeOfLastPathComponent((uint64_t)url);
    if (PathComponent == -1)
      return 0;
  }
  v11 = PathComponent;
  v12 = v9;
  v13 = (const __CFString *)atomic_load((unint64_t *)url + 3);
  MutableCopy = CFStringCreateMutableCopy(allocator, 0, v13);
  if (MutableCopy)
  {
    v15 = MutableCopy;
    v16 = v11 + v12;
    CFStringInsert(MutableCopy, v16, CFSTR("."));
    if (_CFURLHasFileURLScheme((__objc2_class **)url, 0))
      v17 = POSIXPathToURLPath(extension, 0, 0, 0);
    else
      v17 = CFURLCreateStringByAddingPercentEscapes(allocator, extension, 0, CFSTR(";?/"), *((_DWORD *)url + 5));
    v19 = v17;
    if (v17)
    {
      CFStringInsert(v15, v16 + 1, v17);
      CFRelease(v19);
      v18 = _CFURLCreateWithURLString((__objc2_class **)allocator, v15, 0, *((const __CFURL **)url + 4));
    }
    else
    {
      v18 = 0;
    }
    CFRelease(v15);
    if (!v6)
      return (CFURLRef)v18;
  }
  else
  {
    v18 = 0;
    if (!v6)
      return (CFURLRef)v18;
  }
  CFRelease(url);
  return (CFURLRef)v18;
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  CFURLRef v2;
  int v4;
  CFURLRef v5;
  unsigned int v6;
  unint64_t *v7;
  unsigned int v8;
  unsigned int v9;
  char v10;
  char *v11;
  CFIndex v12;
  CFIndex v13;
  CFIndex PathComponent;
  uint64_t v15;
  CFIndex v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  CFMutableStringRef v21;
  const __CFString *v22;
  CFIndex v23;
  uint64_t v24;
  const __CFString *v25;
  __CFString *MutableCopy;
  CFRange v27;
  uint64_t v28;
  uint64_t v29;
  CFIndex v30;
  CFRange v32;

  v2 = url;
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
    v2 = (CFURLRef)-[__CFURL _cfurl](v2, "_cfurl");
  v4 = CFURLIsFileReferenceURL(v2);
  if (!v4)
  {
    v6 = *((_DWORD *)v2 + 4);
    if ((v6 & 0x20) != 0)
      goto LABEL_9;
    return 0;
  }
  v5 = CFURLCreateFilePathURL(allocator, v2, 0);
  if (!v5)
    return 0;
  v2 = v5;
  v6 = *((_DWORD *)v5 + 4);
  if ((v6 & 0x20) == 0)
  {
    v7 = 0;
LABEL_37:
    CFRelease(v2);
    return (CFURLRef)v7;
  }
LABEL_9:
  v8 = 0;
  v9 = 32;
  do
  {
    v10 = v9;
    v9 >>= 1;
    v8 += v6 & 1;
    v6 >>= 1;
  }
  while ((v10 & 2) == 0);
  v11 = (char *)v2 + 16 * v8;
  v13 = *((_QWORD *)v11 + 7);
  v12 = *((_QWORD *)v11 + 8);
  PathComponent = _rangeOfLastPathComponent((uint64_t)v2);
  if (v15)
  {
    v16 = PathComponent;
    if (v15 == 2)
    {
      v18 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
      if (CFStringGetCharacterAtIndex(v18, v16) != 46)
        goto LABEL_21;
      v19 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
      if (CFStringGetCharacterAtIndex(v19, v16 + 1) != 46)
        goto LABEL_21;
    }
    else if (v15 != 1
           || (v17 = (const __CFString *)atomic_load((unint64_t *)v2 + 3),
               (CFStringGetCharacterAtIndex(v17, v16) & 0xFFFE) != 0x2E))
    {
LABEL_21:
      v25 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
      MutableCopy = CFStringCreateMutableCopy(allocator, 0, v25);
      v21 = MutableCopy;
      if (v16 == v13)
      {
        v32.location = v13;
        v32.length = v12;
        CFStringReplace(MutableCopy, v32, CFSTR("."));
        CFStringInsert(v21, 1, CFSTR("/"));
        goto LABEL_33;
      }
      v27.length = v12 + v13 - v16;
      v27.location = v16;
      goto LABEL_24;
    }
  }
  v20 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
  v21 = CFStringCreateMutableCopy(allocator, 0, v20);
  if (v12 <= 0)
  {
    v24 = 0;
    v23 = v12 + v13;
  }
  else
  {
    v22 = (const __CFString *)atomic_load((unint64_t *)v2 + 3);
    v23 = v12 + v13;
    if (CFStringGetCharacterAtIndex(v22, v23 - 1) == 47)
    {
      v24 = 0;
    }
    else
    {
      CFStringInsert(v21, v23, CFSTR("/"));
      v24 = 1;
    }
  }
  CFStringInsert(v21, v24 + v23, CFSTR(".."));
  CFStringInsert(v21, v24 + v23 + 2, CFSTR("/"));
  v28 = v24 + 3 + v12;
  if (v28 >= 5)
  {
    v29 = v24 + 3 + v23;
    v30 = v29 - 5;
    if (CFStringGetCharacterAtIndex(v21, v29 - 5) == 46)
    {
      if ((unint64_t)v28 < 8)
      {
        if (v28 == 5)
          goto LABEL_31;
      }
      else
      {
        v30 = v29 - 6;
        if (CFStringGetCharacterAtIndex(v21, v29 - 6) == 47)
        {
LABEL_31:
          MutableCopy = v21;
          v27.location = v30;
          v27.length = 2;
LABEL_24:
          CFStringDelete(MutableCopy, v27);
        }
      }
    }
  }
LABEL_33:
  if (v21)
    v7 = _CFURLCreateWithURLString((__objc2_class **)allocator, v21, 0, *((const __CFURL **)v2 + 4));
  else
    v7 = 0;
  CFRelease(v21);
  if (v4)
    goto LABEL_37;
  return (CFURLRef)v7;
}

CFIndex _rangeOfLastPathComponent(uint64_t a1)
{
  unsigned int v1;
  CFIndex v2;
  unsigned int v3;
  unsigned int v4;
  char v5;
  CFIndex *v6;
  CFIndex v7;
  unint64_t *v9;
  const __CFString *v10;
  CFIndex v11;
  const __CFString *v12;
  CFRange result;
  uint64_t v15;
  CFRange v16;

  v15 = *MEMORY[0x1E0C80C00];
  v1 = *(_DWORD *)(a1 + 16);
  if ((v1 & 0x20) == 0)
    return -1;
  v3 = 0;
  v4 = 32;
  do
  {
    v5 = v4;
    v4 >>= 1;
    v3 += v1 & 1;
    v1 >>= 1;
  }
  while ((v5 & 2) == 0);
  v6 = (CFIndex *)(a1 + 56 + 16 * v3);
  v2 = *v6;
  v7 = v6[1];
  if (*v6 != -1 && v7 != 0)
  {
    result.location = 0;
    result.length = 0;
    v9 = (unint64_t *)(a1 + 24);
    v10 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    v11 = v7 - 1;
    if (CFStringGetCharacterAtIndex(v10, v7 - 1 + v2) != 47 || (--v7, v11))
    {
      v12 = (const __CFString *)atomic_load(v9);
      v16.location = v2;
      v16.length = v7;
      if (CFStringFindWithOptions(v12, CFSTR("/"), v16, 4uLL, &result))
        return result.location + 1;
    }
  }
  return v2;
}

uint64_t _CFExtensionIsValidToAppend(const __CFString *a1)
{
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v5;
  uint64_t v6;
  CFIndex v7;
  CFIndex v8;
  uint64_t v9;
  uint64_t v10;
  UniChar v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  CFIndex v15;
  uint64_t v16;
  CFIndex v17;
  CFRange v18;
  CFIndex v19;
  uint64_t result;
  unsigned int v21;
  unint64_t v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t i;
  uint64_t v27;
  uint64_t v28;
  UniChar v29;
  uint64_t v30;
  uint64_t v31;
  CFIndex v32;
  uint64_t v33;
  CFIndex v34;
  CFRange v35;
  CFIndex v36;
  _OWORD v37[8];
  CFStringRef theString;
  const UniChar *v39;
  const char *v40;
  uint64_t v41;
  CFIndex v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  theString = a1;
  v41 = 0;
  v42 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v39 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v43 = 0;
  v44 = 0;
  v40 = CStringPtr;
  if (!Length)
    return 0;
  v5 = Length - 1;
  if (Length < 1)
    return 1;
  v6 = 0;
  v7 = 1 - Length;
  v8 = Length + 63;
  v9 = Length - 1;
  memset(v37, 0, sizeof(v37));
  while (1)
  {
    v10 = (unint64_t)v9 >= 0x3F ? 63 : v9;
    if (v39)
    {
      v11 = v39[v9 + v41];
    }
    else if (v40)
    {
      v11 = v40[v41 + v9];
    }
    else
    {
      v12 = v44 > v9 && v6 <= v9;
      if (!v12)
      {
        v13 = -v10;
        v14 = v10 + v7;
        v15 = v8 - v10;
        v16 = v9 + v13;
        v17 = v16 + 64;
        if (v16 + 64 >= v42)
          v17 = v42;
        v43 = v16;
        v44 = v17;
        v18.location = v16 + v41;
        if (v42 >= v15)
          v19 = v15;
        else
          v19 = v42;
        v18.length = v19 + v14;
        CFStringGetCharacters(theString, v18, (UniChar *)v37);
        v6 = v43;
      }
      v11 = *((_WORD *)v37 + v9 - v6);
    }
    result = 0;
    if (v11 <= 0x2029u)
      break;
    v21 = v11 - 8234;
    v12 = v21 > 0x3F;
    v22 = (1 << v21) & 0xF00000000000001FLL;
    if (!v12 && v22 != 0)
      return result;
LABEL_37:
    ++v7;
    --v8;
    v12 = v9-- <= 0;
    if (v12)
      return 1;
  }
  if (v11 > 0x61Bu)
  {
    if (v11 - 8206 < 2 || v11 == 1564)
      return result;
    goto LABEL_37;
  }
  if (v11 == 32)
    return result;
  if (v11 != 46)
  {
    if (v11 == 47)
      return result;
    goto LABEL_37;
  }
  if (v9 >= v5)
    return 0;
  v24 = v9 + 64;
  v25 = -v9;
  for (i = v9 + 1; ; --i)
  {
    v27 = (unint64_t)v9 >= 0x40 ? 64 : v9;
    v28 = i - 1;
    if (i - 1 < 1)
      break;
    if (v39)
    {
      v29 = v39[i - 2 + v41];
    }
    else if (v40)
    {
      v29 = v40[v41 - 2 + i];
    }
    else
    {
      if (v44 < v28 || v6 >= v28)
      {
        v30 = -v27;
        v31 = v27 + v25;
        v32 = v24 - v27;
        v33 = i + v30;
        v34 = v33 + 63;
        if (v33 + 63 >= v42)
          v34 = v42;
        v43 = v33 - 1;
        v44 = v34;
        v35.location = v33 + v41 - 1;
        if (v42 >= v32)
          v36 = v32;
        else
          v36 = v42;
        v35.length = v36 + v31;
        CFStringGetCharacters(theString, v35, (UniChar *)v37);
        v6 = v43;
      }
      v29 = *((_WORD *)&v37[-1] + i - v6 + 6);
    }
    result = 0;
    ++v25;
    --v24;
    --v9;
    if (v29 == 47)
      return result;
  }
  return 1;
}

__CFDictionary *_createQueryTableAtPath(const __CFString *a1, const __CFArray *a2, const __CFString *a3, const __CFString *a4, char a5)
{
  CFMutableDictionaryRef Mutable;
  const __CFAllocator *v10;
  __CFString *MutableCopy;
  __CFString *v12;
  CFIndex Length;
  CFIndex v14;
  const __CFString *ValueAtIndex;
  CFIndex v16;
  __CFString *v17;
  _BOOL4 v18;
  __CFDictionary *v19;
  char v20;
  CFIndex v21;
  const __CFString *v22;
  CFIndex v23;
  const __CFAllocator *v24;
  __CFString *v25;
  CFIndex Count;
  CFMutableDictionaryRef cf;
  CFMutableDictionaryRef v30;
  const __CFArray *theArray;
  CFRange v32;
  CFRange v33;
  CFRange v34;
  CFRange v35;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  theArray = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  v10 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  v30 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, a1);
  v12 = MutableCopy;
  if (a3)
    _CFAppendPathComponent2(MutableCopy, a3);
  Length = CFStringGetLength(v12);
  if (a4)
    _CFAppendPathComponent2(v12, a4);
  _CFBundleReadDirectory(v12, (const __CFArray *)a4, a5, (uint64_t)theArray, 0, (uint64_t)Mutable, (uint64_t)v30, 0, 0, 0);
  v32.length = CFStringGetLength(v12) - Length;
  v32.location = Length;
  CFStringDelete(v12, v32);
  Count = CFArrayGetCount(theArray);
  if (!a2)
  {
    cf = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v14 = 0;
    goto LABEL_11;
  }
  v14 = CFArrayGetCount(a2);
  cf = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v14 < 1)
  {
LABEL_11:
    v18 = 0;
    goto LABEL_12;
  }
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, 0);
  v16 = CFStringGetLength(ValueAtIndex);
  v17 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16 + 5, ValueAtIndex);
  CFStringAppend(v17, CFSTR(".lproj"));
  _CFAppendPathComponent2(v12, ValueAtIndex);
  _CFAppendPathExtension2(v12, CFSTR("lproj"));
  if (a4)
    _CFAppendPathComponent2(v12, a4);
  _CFBundleReadDirectory(v12, (const __CFArray *)a4, a5, (uint64_t)theArray, 0, (uint64_t)Mutable, (uint64_t)v30, (uint64_t)cf, 1, v17);
  CFRelease(v17);
  v33.length = CFStringGetLength(v12) - Length;
  v33.location = Length;
  CFStringDelete(v12, v33);
  v18 = Count < CFArrayGetCount(theArray);
LABEL_12:
  v19 = Mutable;
  _CFAppendPathComponent2(v12, CFSTR("Base"));
  _CFAppendPathExtension2(v12, CFSTR("lproj"));
  if (a4)
    _CFAppendPathComponent2(v12, a4);
  v20 = 1;
  _CFBundleReadDirectory(v12, (const __CFArray *)a4, a5, (uint64_t)theArray, v18, (uint64_t)v19, (uint64_t)v30, (uint64_t)cf, 1, CFSTR("Base.lproj"));
  v34.length = CFStringGetLength(v12) - Length;
  v34.location = Length;
  CFStringDelete(v12, v34);
  if (!v18)
    v20 = Count < CFArrayGetCount(theArray);
  if (v14 > 1 && CFArrayGetCount(a2) > 1)
  {
    v21 = 1;
    do
    {
      v22 = (const __CFString *)CFArrayGetValueAtIndex(a2, v21);
      v23 = CFStringGetLength(v22);
      v24 = v10;
      v25 = CFStringCreateMutableCopy(v10, v23 + 5, v22);
      CFStringAppend(v25, CFSTR(".lproj"));
      _CFAppendPathComponent2(v12, v22);
      _CFAppendPathExtension2(v12, CFSTR("lproj"));
      if (a4)
        _CFAppendPathComponent2(v12, a4);
      _CFBundleReadDirectory(v12, (const __CFArray *)a4, a5, (uint64_t)theArray, v20, (uint64_t)v19, (uint64_t)v30, (uint64_t)cf, 0, v25);
      CFRelease(v25);
      v35.length = CFStringGetLength(v12) - Length;
      v35.location = Length;
      CFStringDelete(v12, v35);
      if (v20)
        v20 = 1;
      else
        v20 = Count < CFArrayGetCount(theArray);
      v10 = v24;
      ++v21;
    }
    while (v21 < CFArrayGetCount(a2));
  }
  CFRelease(cf);
  CFRelease(v12);
  if (CFArrayGetCount(theArray) >= 1)
    CFDictionarySetValue(v19, CFSTR("_CFBAF_"), theArray);
  CFRelease(theArray);
  CFRelease(v30);
  return v19;
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
  CFIndex length;
  CFIndex location;
  char v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[3];

  length = range.length;
  location = range.location;
  v14[2] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString deleteCharactersInRange:](theString, "deleteCharactersInRange:", location, length);
  }
  else
  {
    v5 = atomic_load((unint64_t *)&theString->info);
    if ((v5 & 1) != 0)
    {
      v14[0] = location;
      v14[1] = length;
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)v14, 1, 0, 0);
    }
    else
    {
      v6 = _CFOSLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
        CFStringDelete_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
}

void _CFAppendPathComponent2(__CFString *a1, const __CFString *a2)
{
  _CFAppendTrailingPathSlash2(a1);
  CFStringAppend(a1, a2);
}

void _CFAppendTrailingPathSlash2(__CFString *a1)
{
  CFIndex Length;

  Length = CFStringGetLength(a1);
  if (Length)
  {
    if (Length == 2)
    {
      if (!_hasDrive(a1) && !_hasNet(a1))
        goto LABEL_9;
    }
    else if (Length != 1 || CFStringGetCharacterAtIndex(a1, 0) != 47)
    {
LABEL_9:
      CFStringAppendCharacters(a1, &_CFAppendTrailingPathSlash2_slash, 1);
    }
  }
}

void _CFBundleReadDirectory(const __CFString *a1, const __CFArray *a2, char a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, void *a10)
{
  CFArrayRef v15;
  void *v16;
  uint64_t ProductNameSuffix;
  const __CFString *PlatformNameSuffix;
  BOOL v19;
  _QWORD v22[11];
  char v23;
  char v24;
  char v25;
  void *v26;
  void *values[3];

  v15 = a2;
  v16 = a10;
  values[2] = *(void **)MEMORY[0x1E0C80C00];
  v26 = a2;
  ProductNameSuffix = _CFBundleGetProductNameSuffix();
  PlatformNameSuffix = _CFBundleGetPlatformNameSuffix();
  if (v16)
    v19 = v15 == 0;
  else
    v19 = 1;
  if (v19)
  {
    if (v16)
    {
      v15 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&a10, 1, &kCFTypeArrayCallBacks);
      v16 = a10;
    }
    else
    {
      if (v15)
        v15 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&v26, 1, &kCFTypeArrayCallBacks);
      v16 = 0;
    }
  }
  else
  {
    values[0] = v16;
    values[1] = v15;
    v15 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 2, &kCFTypeArrayCallBacks);
  }
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 0x40000000;
  v22[2] = ___CFBundleReadDirectory_block_invoke;
  v22[3] = &__block_descriptor_tmp_51;
  v23 = a3;
  v22[4] = ProductNameSuffix;
  v22[5] = PlatformNameSuffix;
  v24 = a5;
  v22[6] = a4;
  v22[7] = a6;
  v22[8] = a7;
  v22[9] = a8;
  v25 = a9;
  v22[10] = v16;
  _CFIterateDirectory(a1, 1, v15, (uint64_t)v22);
  if (v15)
    CFRelease(v15);
}

uint64_t _CFBundleGetProductNameSuffix()
{
  if (_CFBundleGetProductNameSuffix_onceToken != -1)
    dispatch_once(&_CFBundleGetProductNameSuffix_onceToken, &__block_literal_global_3_0);
  return _CFBundleGetProductNameSuffix__cfBundlePlatformSuffix;
}

const __CFString *_CFBundleGetPlatformNameSuffix()
{
  return CFSTR("-iphoneos");
}

uint64_t _CFAppendPathExtension2(__CFString *a1, CFStringRef theString)
{
  _BOOL4 v4;
  CFIndex Length;
  CFIndex v6;
  int CharacterAtIndex;
  CFIndex v8;
  uint64_t v9;
  CFRange v11;
  CFRange v12;

  if (!a1
    || CFStringGetLength(theString) >= 1 && CFStringGetCharacterAtIndex(theString, 0) == 47
    || CFStringGetLength(theString) > 1 && _hasDrive(theString))
  {
    return 0;
  }
  v4 = CFStringGetLength(a1) >= 2 && _hasDrive(a1);
  while (1)
  {
    Length = CFStringGetLength(a1);
    if (v4)
    {
      if (Length <= 3)
        break;
    }
    else if (Length < 2)
    {
      break;
    }
    v6 = CFStringGetLength(a1);
    if (CFStringGetCharacterAtIndex(a1, v6 - 1) != 47)
      break;
    v11.location = CFStringGetLength(a1) - 1;
    v11.length = 1;
    CFStringDelete(a1, v11);
  }
  if (!CFStringGetLength(a1))
    return 0;
  CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0);
  v8 = CFStringGetLength(a1);
  v9 = 0;
  switch(v8)
  {
    case 0:
      return v9;
    case 1:
      v9 = 0;
      if (CharacterAtIndex != 47 && CharacterAtIndex != 126)
        goto LABEL_25;
      return v9;
    case 2:
      if (_hasDrive(a1) || _hasNet(a1))
        return 0;
      goto LABEL_25;
    case 3:
      if (CFStringGetCharacterAtIndex(a1, 2) == 47 && _hasDrive(a1))
        return 0;
      goto LABEL_25;
    default:
LABEL_25:
      if (v8 >= 1 && CharacterAtIndex == 126)
      {
        v12.location = 1;
        v12.length = v8 - 1;
        if (!CFStringFindWithOptions(a1, CFSTR("/"), v12, 0, 0))
          return 0;
      }
      v9 = 1;
      CFStringAppendCharacters(a1, _CFAppendPathExtension2_dotChar, 1);
      CFStringAppend(a1, theString);
      break;
  }
  return v9;
}

BOOL _hasDrive(const __CFString *a1)
{
  int CharacterAtIndex;
  _BOOL8 result;

  result = 0;
  if (CFStringGetLength(a1) >= 2)
  {
    CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0);
    if (CFStringGetCharacterAtIndex(a1, 1) == 58 && (CharacterAtIndex & 0xFFFFFFDF) - 65 < 0x1A)
      return 1;
  }
  return result;
}

uint64_t _hasNet(const __CFString *a1)
{
  int CharacterAtIndex;
  uint64_t v3;
  int v4;

  if (CFStringGetLength(a1) < 2)
    return 0;
  CharacterAtIndex = CFStringGetCharacterAtIndex(a1, 0);
  v3 = 1;
  v4 = CFStringGetCharacterAtIndex(a1, 1);
  if (CharacterAtIndex != 92 || v4 != 92)
    return 0;
  return v3;
}

_OWORD *__CFSetCharToUniCharFunc(_OWORD *result)
{
  uint64_t (*v1)(_QWORD, _QWORD, __int16 *);
  uint64_t i;
  __int16 v3;
  __int16 v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if ((_OWORD *)__CFCharToUniCharFunc != result)
  {
    v1 = (uint64_t (*)(_QWORD, _QWORD, __int16 *))result;
    if (result)
    {
      result = CFStringEncodingGetConverter(0);
      if (result && *((uint64_t (**)(_QWORD, _QWORD, __int16 *))result + 1) == v1)
      {
        __CFCharToUniCharTable = (uint64_t)__CFMacRomanCharToUnicharTable;
      }
      else
      {
        __CFCharToUniCharTable = (uint64_t)__CFMutableCharToUniCharTable;
        for (i = 128; i != 256; ++i)
        {
          v4 = 0;
          result = (_OWORD *)v1(0, i, &v4);
          if ((_DWORD)result)
            v3 = v4;
          else
            v3 = -3;
          __CFMutableCharToUniCharTable[i] = v3;
        }
      }
      __CFCharToUniCharFunc = (uint64_t)v1;
    }
    else
    {
      __CFCharToUniCharTable = (uint64_t)&__CFIdempotentCharToUniCharTable;
    }
  }
  return result;
}

uint64_t _CompareLowerTestEntryPrefixToTableEntryKey(char **a1, _BYTE **a2)
{
  uint64_t v2;
  _BYTE *v3;
  __darwin_ct_rune_t v4;
  __darwin_ct_rune_t v5;
  __darwin_ct_rune_t v6;
  int v7;
  BOOL v8;
  char *v9;
  char *v10;
  __darwin_ct_rune_t v11;
  __darwin_ct_rune_t v12;
  BOOL v13;
  uint64_t v14;
  int v15;

  v2 = (uint64_t)*a1;
  v3 = *a2;
  v5 = __tolower(**a1);
  v4 = v5 << 24;
  v5 = (char)v5;
  v6 = (char)*v3;
  v7 = *v3;
  if ((char)v5 == v6)
  {
    v8 = !*v3 || v4 == 1593835520;
    v6 = (char)v5;
    if (!v8)
    {
      v9 = (char *)(v2 + 1);
      v10 = v3 + 1;
      do
      {
        v11 = *v9++;
        v5 = __tolower(v11);
        v4 = v5 << 24;
        v5 = (char)v5;
        v12 = *v10++;
        v6 = v12;
        v7 = v12;
        if ((char)v5 != v12)
          break;
        v13 = !v7 || v4 == 1593835520;
        v6 = (char)v5;
      }
      while (!v13);
    }
  }
  if (v7)
  {
    v14 = 0xFFFFFFFFLL;
    if (v4 != 1593835520)
    {
      if (v5 < v6)
        return 0xFFFFFFFFLL;
      else
        return 1;
    }
  }
  else
  {
    if (v4 < 0)
      v15 = __maskrune(v5, 0x500uLL);
    else
      v15 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v5 + 60) & 0x500;
    return v15 != 0;
  }
  return v14;
}

__CFString *__CFNumberFormatterCreateCompressedString(CFStringRef theString, int a2, CFIndex *a3)
{
  CFIndex Length;
  CFIndex v5;
  __CFString *Mutable;
  const __CFCharacterSet *Predefined;
  CFCharacterSetRef v8;
  BOOL v9;
  UniChar v10;
  CFIndex v11;
  int CharacterAtIndex;
  const __CFCharacterSet *v13;
  int v14;
  UniChar v15;
  const __CFCharacterSet *theSet;
  UniChar chars;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!theString)
    return 0;
  if (a3)
  {
    v5 = *a3;
    Length = a3[1];
  }
  else
  {
    Length = CFStringGetLength(theString);
    v5 = 0;
  }
  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
  v8 = CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  if (Length >= 1)
  {
    theSet = v8;
    v9 = 0;
    v10 = 0;
    v11 = Length + v5;
    do
    {
      chars = 0;
      CharacterAtIndex = CFStringGetCharacterAtIndex(theString, v5);
      v13 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
      if (CFCharacterSetIsCharacterMember(v13, CharacterAtIndex))
        v14 = 32;
      else
        v14 = CharacterAtIndex;
      chars = v14;
      if (++v5 >= Length)
      {
        v15 = 0;
      }
      else
      {
        v15 = CFStringGetCharacterAtIndex(theString, v5);
        v14 = chars;
      }
      if (v14 == 39 && a2 != 0)
        v9 = !v9;
      if (v9
        || v14 != 32
        || CFCharacterSetIsCharacterMember(Predefined, v10) && CFCharacterSetIsCharacterMember(Predefined, v15)
        || CFCharacterSetIsCharacterMember(theSet, v10) && CFCharacterSetIsCharacterMember(theSet, v15))
      {
        CFStringAppendCharacters(Mutable, &chars, 1);
        v10 = chars;
      }
    }
    while (v5 < v11);
  }
  return Mutable;
}

CFCharacterSetRef CFCharacterSetGetPredefined(CFCharacterSetPredefinedSet theSetIdentifier)
{
  if ((unint64_t)(theSetIdentifier - 16) <= 0xFFFFFFFFFFFFFFF0)
    CFCharacterSetGetPredefined_cold_1();
  return (CFCharacterSetRef)(&__CFBuiltinSets + 6 * theSetIdentifier - 6);
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
  uint64_t *p_info;
  char v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  char **p_data;
  char *v21;
  uint64_t length;
  uint64_t v23;
  char v24;
  CFIndex v25;
  unsigned int v26;
  uint64_t *v28;
  char v29;
  char **v30;
  char v31;
  char *v32;
  char v33;
  char **v34;
  char *v35;
  char v36;
  char v37;
  unint64_t v38;
  char *v39;
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString appendCharacters:length:](theString, "appendCharacters:length:", chars, numChars);
    return;
  }
  p_info = &theString->info;
  v7 = atomic_load((unint64_t *)&theString->info);
  if ((v7 & 1) == 0)
  {
    v8 = _CFOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      CFStringAppendCharacters_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    return;
  }
  v16 = atomic_load((unint64_t *)p_info);
  v17 = v16 & 5;
  v18 = atomic_load((unint64_t *)p_info);
  v19 = v18 & 0x60;
  if (v17 == 4)
  {
    p_data = &theString->data;
    if (v19)
    {
      v21 = *p_data;
    }
    else
    {
      v23 = atomic_load((unint64_t *)&theString->info);
      v21 = (char *)&p_data[(v23 & 5) != 4];
    }
    length = *v21;
  }
  else if ((v18 & 0x60) != 0)
  {
    length = theString->length;
  }
  else
  {
    length = (uint64_t)theString->data;
  }
  v24 = atomic_load((unint64_t *)&theString->info);
  if ((v24 & 0x10) != 0)
  {
    v41 = length;
    v42 = 0;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v41, 1, numChars, 1);
    v31 = atomic_load((unint64_t *)&theString->info);
    v30 = &theString->data;
    if ((v31 & 0x60) == 0)
    {
      v28 = &theString->info;
LABEL_31:
      v36 = atomic_load((unint64_t *)v28);
      v32 = (char *)&v30[(v36 & 5) != 4];
      goto LABEL_32;
    }
LABEL_26:
    v32 = *v30;
LABEL_32:
    memmove(&v32[2 * length], chars, 2 * numChars);
    return;
  }
  if (numChars < 1)
  {
    v41 = length;
    v42 = 0;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v41, 1, numChars, 0);
  }
  else
  {
    v25 = 0;
    do
      v26 = chars[v25++];
    while (v26 <= 0x7F && v25 < numChars);
    v41 = length;
    v42 = 0;
    __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v41, 1, numChars, v26 > 0x7F);
    if (v26 >= 0x80)
    {
      v28 = &theString->info;
      v29 = atomic_load((unint64_t *)&theString->info);
      v30 = &theString->data;
      if ((v29 & 0x60) == 0)
        goto LABEL_31;
      goto LABEL_26;
    }
  }
  v33 = atomic_load((unint64_t *)&theString->info);
  v34 = &theString->data;
  if ((v33 & 0x60) != 0)
  {
    v35 = *v34;
  }
  else
  {
    v37 = atomic_load((unint64_t *)&theString->info);
    v35 = (char *)&v34[(v37 & 5) != 4];
  }
  v38 = atomic_load((unint64_t *)&theString->info);
  if (numChars >= 1)
  {
    v39 = &v35[length + ((v38 >> 2) & 1)];
    do
    {
      v40 = *(_BYTE *)chars++;
      *v39++ = v40;
      --numChars;
    }
    while (numChars);
  }
}

CFStringRef _CFStringCreateByAddingPercentEncodingWithAllowedCharacters(const __CFAllocator *a1, CFStringRef theString, const __CFCharacterSet *a3)
{
  CFIndex Length;
  CFIndex v7;
  CFIndex MaximumSizeForEncoding;
  uint64_t v9;
  CFIndex v10;
  CFStringRef v11;
  size_t v12;
  __int128 v13;
  _BYTE *v14;
  UInt8 *v16;
  uint64_t v17;
  UInt8 *v18;
  CFIndex v19;
  int v20;
  __int16 v21;
  CFIndex v22;
  char v23;
  _BYTE *v24;
  char v25;
  char v26;
  uint64_t v27;
  char *v28;
  char *v29;
  const char *v30;
  unint64_t v31;
  int v32;
  int v33;
  char v34;
  char v35;
  const char *v36;
  CFIndex v37;
  int v38;
  unint64_t v39;
  CFIndex v40;
  int v41;
  unint64_t v42;
  char v43;
  uint64_t v44;
  unint64_t v45;
  CFIndex v46[2];
  CFRange v47;

  v46[1] = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(theString);
  if (!Length)
    return CFStringCreateCopy(a1, theString);
  v7 = Length;
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding != -1)
  {
    v10 = MaximumSizeForEncoding;
    v11 = 0;
    v12 = 4 * MaximumSizeForEncoding;
    if (!(4 * MaximumSizeForEncoding))
      return v11;
    *((_QWORD *)&v13 + 1) = ((MaximumSizeForEncoding + __PAIR128__(1, 0xC000000000000000)) >> 64) & 1;
    *(_QWORD *)&v13 = MaximumSizeForEncoding - 0x4000000000000000;
    if ((unint64_t)(v13 >> 63) < 3 || MaximumSizeForEncoding >> 62 << 63 >> 63 < 0)
      return v11;
    if (v12 < 0x401)
    {
      MEMORY[0x1E0C80A78](MaximumSizeForEncoding, v9);
      v14 = (char *)&v44 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v14, v12);
    }
    else
    {
      v14 = malloc_type_malloc(4 * MaximumSizeForEncoding, 0x100004077774924uLL);
    }
    v46[0] = 0;
    v47.location = 0;
    v47.length = v7;
    v11 = 0;
    if (CFStringGetBytes(theString, v47, 0x8000100u, 0, 0, v14, v10, v46) != v7)
      goto LABEL_74;
    v16 = &v14[v10];
    if (InitializeURLAllowedCharacterSets_static_init == -1)
    {
      if (a3)
      {
LABEL_14:
        v17 = 0;
        while (*(const __CFCharacterSet **)(sURLAllowedCharacterSets + 8 * v17) != a3)
        {
          if (++v17 == 7)
            goto LABEL_17;
        }
        v21 = 2;
        switch(v17)
        {
          case 0:
            goto LABEL_66;
          case 1:
            v21 = 4;
            goto LABEL_66;
          case 2:
            v22 = v46[0];
            if (v46[0] <= 1)
              goto LABEL_77;
            if (*v14 == 91)
            {
              if (v14[v46[0] - 1] == 93)
              {
                v23 = 0;
                v24 = v14 + 1;
                *v16 = 91;
                v18 = v16 + 1;
                v22 = v46[0] - 2;
                v46[0] -= 2;
                v25 = 1;
              }
              else
              {
LABEL_77:
                v25 = 0;
                v23 = 1;
                v18 = &v14[v10];
                v24 = v14;
              }
              if (v22 < 1)
              {
LABEL_91:
                if ((v23 & 1) == 0)
                  *v18++ = 93;
                goto LABEL_73;
              }
            }
            else
            {
              v25 = 0;
              v23 = 1;
              v24 = v14;
              v18 = &v14[v10];
            }
            v40 = 0;
            do
            {
              v41 = (char)v24[v40];
              v42 = v24[v40];
              if ((v41 & 0x80000000) == 0
                && (v41 == 58 ? (v43 = v25) : (v43 = 0), (v43 & 1) != 0 || (sURLAllowedCharacters[v42] & 8) != 0))
              {
                *v18++ = v41;
              }
              else
              {
                *v18 = 37;
                v18[1] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v42 >> 4];
                v18[2] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v42 & 0xF];
                v18 += 3;
              }
              ++v40;
            }
            while (v40 < v46[0]);
            goto LABEL_91;
          case 3:
            v18 = &v14[v10];
            if (v46[0] < 1)
              goto LABEL_73;
            v26 = 0;
            v27 = 0;
            v28 = (char *)&_CFXNotificationPost_samples + 8;
            v29 = (char *)&_CFXNotificationPost_samples + 8;
            v30 = "0123456789ABCDEF";
            v18 = v16;
            break;
          case 4:
            v21 = 64;
            goto LABEL_66;
          case 5:
            v21 = 128;
            goto LABEL_66;
          case 7:
            goto LABEL_17;
          default:
            v21 = 0;
LABEL_66:
            v18 = &v14[v10];
            if (v46[0] >= 1)
            {
              v37 = 0;
              v18 = v16;
              do
              {
                v38 = (char)v14[v37];
                v39 = v14[v37];
                if (v38 < 0 || ((unsigned __int16)v21 & sURLAllowedCharacters[v39]) == 0)
                {
                  *v18 = 37;
                  v18[1] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v39 >> 4];
                  v18[2] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v39 & 0xF];
                  v18 += 3;
                }
                else
                {
                  *v18++ = v38;
                }
                ++v37;
              }
              while (v37 < v46[0]);
            }
            goto LABEL_73;
        }
        while (1)
        {
          v31 = v14[v27];
          if (v26)
            break;
          v33 = 0;
          v26 = (_DWORD)v31 == 47;
          if ((v31 & 0x80) == 0 && (_DWORD)v31 != 58)
            v33 = (sURLAllowedCharacters[v31] >> 5) & 1;
          if (*((_QWORD *)v28 + 211) != -1)
          {
            HIDWORD(v44) = v31 == 47;
            v45 = v31;
            dispatch_once(&_CFURIParserSemicolonAllowedInPath_onceToken, &__block_literal_global_13);
            v31 = v45;
            v26 = BYTE4(v44);
            v30 = "0123456789ABCDEF";
            v29 = (_BYTE *)(&_CFXNotificationPost_samples + 8);
            v28 = (_BYTE *)(&_CFXNotificationPost_samples + 8);
          }
          if (v29[1664])
          {
            if (!v33)
              goto LABEL_60;
          }
          else
          {
            if ((_DWORD)v31 == 59)
              v35 = 0;
            else
              v35 = v33;
            if ((v35 & 1) == 0)
            {
LABEL_60:
              *v18 = 37;
              v18[1] = v30[v31 >> 4];
              v18[2] = v30[v31 & 0xF];
              v18 += 3;
              goto LABEL_61;
            }
          }
          *v18++ = v31;
LABEL_61:
          if (++v27 >= v46[0])
            goto LABEL_73;
        }
        if ((v31 & 0x80) != 0)
          v32 = 0;
        else
          v32 = (sURLAllowedCharacters[v31] >> 5) & 1;
        if (*((_QWORD *)v28 + 211) != -1)
        {
          v36 = v30;
          v45 = v14[v27];
          dispatch_once(&_CFURIParserSemicolonAllowedInPath_onceToken, &__block_literal_global_13);
          v31 = v45;
          v30 = v36;
          v29 = (_BYTE *)(&_CFXNotificationPost_samples + 8);
          v28 = (_BYTE *)(&_CFXNotificationPost_samples + 8);
        }
        if (v29[1664])
        {
          if (v32)
          {
LABEL_49:
            *v18++ = v31;
LABEL_55:
            v26 = 1;
            goto LABEL_61;
          }
        }
        else
        {
          if ((_DWORD)v31 == 59)
            v34 = 0;
          else
            v34 = v32;
          if ((v34 & 1) != 0)
            goto LABEL_49;
        }
        *v18 = 37;
        v18[1] = v30[v31 >> 4];
        v18[2] = v30[v31 & 0xF];
        v18 += 3;
        goto LABEL_55;
      }
    }
    else
    {
      dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
      if (a3)
        goto LABEL_14;
    }
LABEL_17:
    v18 = &v14[v10];
    if (v46[0] >= 1)
    {
      v19 = 0;
      v18 = v16;
      do
      {
        v20 = (char)v14[v19];
        if (v20 < 0 || !CFCharacterSetIsCharacterMember(a3, v14[v19]))
        {
          *v18 = 37;
          v18[1] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[(unint64_t)v20 >> 4];
          v18[2] = _CFStringCreateByAddingPercentEncodingWithAllowedCharacters_hexchars[v20 & 0xF];
          v18 += 3;
        }
        else
        {
          *v18++ = v20;
        }
        ++v19;
      }
      while (v19 < v46[0]);
    }
LABEL_73:
    v11 = CFStringCreateWithBytes(0, v16, v18 - v16, 0x8000100u, 0);
LABEL_74:
    if (v12 >= 0x401)
      free(v14);
    return v11;
  }
  return 0;
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  uint64_t v2;
  int v4;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  unsigned __int16 *v11;
  unsigned int v12;
  unsigned __int16 *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  unsigned int v22;

  v2 = theChar;
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
  {
    LOBYTE(v4) = -[__CFCharacterSet longCharacterIsMember:](theSet, "longCharacterIsMember:", v2);
  }
  else
  {
    v6 = atomic_load((unint64_t *)theSet + 1);
    v7 = atomic_load((unint64_t *)theSet + 1);
    v4 = (v6 >> 3) & 1;
    switch((v7 >> 4) & 7)
    {
      case 0u:
        v4 ^= CFUniCharIsMemberOf(v2, *((_DWORD *)theSet + 6));
        break;
      case 1u:
        v18 = *((_QWORD *)theSet + 4);
        if (v18)
        {
          v19 = *((unsigned int *)theSet + 6);
          v20 = v4 ^ (v18 + v19 > v2);
          if (v19 <= v2)
            LOBYTE(v4) = v20;
        }
        break;
      case 2u:
        v8 = *((_QWORD *)theSet + 4);
        if (v8)
        {
          v9 = (unsigned __int16 *)*((_QWORD *)theSet + 3);
          if (*v9 <= v2)
          {
            v10 = &v9[v8];
            v12 = *(v10 - 1);
            v11 = v10 - 1;
            if (v12 >= v2 && v8 >= 1)
            {
              while (1)
              {
                v14 = &v9[((char *)v11 - (char *)v9) >> 2];
                v15 = *v14;
                if (v15 <= v2)
                {
                  if (v15 >= v2)
                  {
                    LOBYTE(v4) = v4 ^ 1;
                    return v4;
                  }
                  v9 = v14 + 1;
                }
                else
                {
                  v11 = v14 - 1;
                }
                if (v9 > v11)
                  return v4;
              }
            }
          }
        }
        break;
      case 3u:
        v21 = *((_QWORD *)theSet + 3);
        if (v21)
        {
          v22 = *(unsigned __int8 *)(v21 + ((unint64_t)v2 >> 3));
          goto LABEL_29;
        }
        break;
      case 4u:
        v16 = *((_QWORD *)theSet + 3);
        if (v16)
        {
          v17 = *(unsigned __int8 *)(v16 + ((unint64_t)v2 >> 8));
          if (!*(_BYTE *)(v16 + ((unint64_t)v2 >> 8)))
            goto LABEL_22;
          if ((_DWORD)v17 == 255)
          {
            LOBYTE(v4) = 1;
          }
          else
          {
            v22 = *(unsigned __int8 *)(v16 + 32 * v17 + ((unint64_t)(v2 & 0xF8) >> 3) + 224);
LABEL_29:
            v4 = (v22 >> (v2 & 7)) & 1;
          }
        }
        break;
      default:
LABEL_22:
        LOBYTE(v4) = 0;
        break;
    }
  }
  return v4;
}

Boolean CFStringFindCharacterFromSet(CFStringRef theString, CFCharacterSetRef theSet, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  char v6;
  CFIndex length;
  CFIndex location;
  CFIndex v11;
  Boolean v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t CStringPtrInternal;
  CFIndex i;
  int64_t v19;
  CFIndex v20;
  UniChar *v21;
  CFIndex v22;
  UniChar v23;
  unsigned int v24;
  BOOL v26;
  BOOL v27;
  CFIndex v28;
  BOOL v29;
  BOOL v30;
  char v31;
  char v32;
  int64_t v33;
  CFIndex v34;
  UniChar *v35;
  CFIndex v36;
  UniChar v37;
  UniChar v38;
  UTF32Char v39;
  unsigned int v41;
  uint64_t v42;
  int64_t v43;
  int64_t v44;
  _BOOL4 v45;
  int64_t v46;
  int64_t v47;
  CFRange v48;
  CFIndex v49;
  CFCharacterSetRef theSeta[2];
  __int128 v51;
  UniChar buffer[8];
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  CFStringRef theStringa;
  const UniChar *CharactersPtr;
  uint64_t v62;
  CFIndex v63;
  CFIndex v64;
  int64_t v65;
  int64_t v66;
  uint64_t v67;
  CFRange v68;
  CFRange v69;

  v6 = searchOptions;
  length = rangeToSearch.length;
  location = rangeToSearch.location;
  v67 = *MEMORY[0x1E0C80C00];
  v11 = CFStringGetLength(theString);
  v12 = 0;
  if (!length || location + length > v11)
    return v12;
  if ((v6 & 4) != 0)
    v13 = location;
  else
    v13 = location + length - 1;
  if ((v6 & 4) != 0)
    v14 = location + length - 1;
  else
    v14 = location;
  if ((v6 & 8) != 0)
    v15 = v14;
  else
    v15 = v13;
  if (v14 > v15)
    v16 = -1;
  else
    v16 = 1;
  theStringa = theString;
  v63 = location;
  v64 = length;
  CharactersPtr = CFStringGetCharactersPtr(theString);
  if (CharactersPtr)
    CStringPtrInternal = 0;
  else
    CStringPtrInternal = _CFStringGetCStringPtrInternal((uint64_t)theString, 0x600u, 0, 1);
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  *(_OWORD *)buffer = 0u;
  v53 = 0u;
  *(_OWORD *)theSeta = 0u;
  v51 = 0u;
  v65 = 0;
  v66 = 0;
  v62 = CStringPtrInternal;
  CFCharacterSetInitInlineBuffer((__objc2_class **)theSet, (uint64_t)theSeta);
  for (i = v14; ; i += v16)
  {
    v19 = i - location;
    if (i - location >= 0)
    {
      v20 = v64;
      if (v64 > v19)
        break;
    }
    v23 = 0;
LABEL_25:
    v24 = (uint64_t)theSeta[1] & 4;
    if (HIDWORD(theSeta[1]) <= v23 && v51 > v23)
    {
      if (((uint64_t)theSeta[1] & 2) != 0)
      {
        if (CFCharacterSetIsLongCharacterMember(theSeta[0], v23))
          goto LABEL_104;
      }
      else if (*((_QWORD *)&v51 + 1))
      {
        if (((uint64_t)theSeta[1] & 1) != 0)
        {
          v41 = v24 >> 2;
          v42 = *(unsigned __int8 *)(*((_QWORD *)&v51 + 1) + ((unint64_t)v23 >> 8));
          if (*(_BYTE *)(*((_QWORD *)&v51 + 1) + ((unint64_t)v23 >> 8)))
          {
            if ((_DWORD)v42 == 255)
            {
              v41 = v24 == 0;
            }
            else
            {
              v45 = v24 == 0;
              if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v51 + 1)
                                                          + 32 * v42
                                                          + (v23 >> 3)
                                                          + 224) >> (v23 & 7)) & 1) != 0)
                v41 = v45;
            }
          }
          if (v41)
          {
LABEL_104:
            v12 = 1;
            if (!result)
              return v12;
            v48 = (CFRange)vdupq_n_s64(1uLL);
            v48.location = i;
            goto LABEL_106;
          }
        }
        else
        {
          v26 = v24 != 0;
          v27 = v24 == 0;
          if ((((unint64_t)*(unsigned __int8 *)(*((_QWORD *)&v51 + 1) + ((unint64_t)v23 >> 3)) >> (v23 & 7)) & 1) != 0)
            v26 = v27;
          if (v26)
            goto LABEL_104;
        }
      }
      else
      {
        v29 = v24 == 0;
        v30 = v24 != 0;
        v31 = v29;
        if (((uint64_t)theSeta[1] & 1) != 0)
          v32 = v30;
        else
          v32 = v31;
        if ((v32 & 1) != 0)
          goto LABEL_104;
      }
    }
    else if (((uint64_t)theSeta[1] & 4) != 0)
    {
      goto LABEL_104;
    }
    if (i == v15)
      return 0;
LABEL_92:
    ;
  }
  v21 = (UniChar *)CharactersPtr;
  if (CharactersPtr)
  {
    v22 = v63 + v19;
LABEL_23:
    v23 = v21[v22];
    goto LABEL_42;
  }
  if (!v62)
  {
    if (v66 <= v19 || (v43 = v65, v65 > v19))
    {
      v44 = v19 - 4;
      if ((unint64_t)v19 < 4)
        v44 = 0;
      if (v44 + 64 < v64)
        v20 = v44 + 64;
      v65 = v44;
      v66 = v20;
      v68.location = v63 + v44;
      v68.length = v20 - v44;
      CFStringGetCharacters(theStringa, v68, buffer);
      v43 = v65;
    }
    v22 = v19 - v43;
    v21 = buffer;
    goto LABEL_23;
  }
  v23 = *(char *)(v62 + v63 + v19);
LABEL_42:
  if (v23 >> 11 != 27)
    goto LABEL_25;
  v28 = (int)i + (int)v16;
  if (v14 <= v15)
  {
    if (v28 > v15)
      return 0;
  }
  else if (v28 < v15)
  {
    return 0;
  }
  v33 = v28 - location;
  if (v28 - location < 0 || (v34 = v64, v64 <= v33))
  {
    v37 = 0;
  }
  else
  {
    v35 = (UniChar *)CharactersPtr;
    if (CharactersPtr)
    {
      v36 = v63 + v33;
      goto LABEL_59;
    }
    if (v62)
    {
      v37 = *(char *)(v62 + v63 + v33);
    }
    else
    {
      if (v66 <= v33 || (v46 = v65, v65 > v33))
      {
        v47 = v33 - 4;
        if ((unint64_t)v33 < 4)
          v47 = 0;
        if (v47 + 64 < v64)
          v34 = v47 + 64;
        v65 = v47;
        v66 = v34;
        v69.location = v63 + v47;
        v69.length = v34 - v47;
        CFStringGetCharacters(theStringa, v69, buffer);
        v46 = v65;
      }
      v36 = v33 - v46;
      v35 = buffer;
LABEL_59:
      v37 = v35[v36];
    }
  }
  if (i >= v28)
    v38 = v37;
  else
    v38 = v23;
  if (i >= v28)
    v37 = v23;
  if (v38 >> 10 != 54 || (v37 & 0xFC00) != 0xDC00)
  {
LABEL_86:
    i = (int)i + (int)v16;
    if (v28 == v15)
      return 0;
    goto LABEL_92;
  }
  v39 = (v38 << 10) + v37 - 56613888;
  if (HIDWORD(theSeta[1]) > v39 || v51 <= v39)
  {
    if (((uint64_t)theSeta[1] & 4) != 0)
      goto LABEL_109;
    goto LABEL_86;
  }
  if (!CFCharacterSetIsLongCharacterMember(theSeta[0], v39))
    goto LABEL_86;
LABEL_109:
  if (result)
  {
    if (i >= v28)
      v49 = (int)i + (int)v16;
    else
      v49 = i;
    v48 = (CFRange)vdupq_n_s64(2uLL);
    v48.location = v49;
LABEL_106:
    *result = v48;
  }
  return 1;
}

uint64_t _CFCharacterSetIsLongCharacterMember(uint64_t a1, unsigned int a2)
{
  char v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  char v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned __int16 *v17;
  unsigned __int16 *v18;
  unsigned int v19;
  unsigned __int16 *v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;

  if (BYTE2(a2))
  {
    v2 = atomic_load((unint64_t *)(a1 + 8));
    if ((v2 & 0x70) == 0)
    {
      v10 = atomic_load((unint64_t *)(a1 + 8));
      return (v10 >> 3) & 1 ^ CFUniCharIsMemberOf(a2, *(_DWORD *)(a1 + 24));
    }
    v3 = *(_QWORD *)(a1 + 40);
    if (v3)
    {
      v4 = *(_BYTE *)(v3 + 13) != 0;
      v5 = *(_DWORD *)(v3 + 8);
      if (BYTE2(a2) <= 0x10u
        && ((v5 >> SBYTE2(a2)) & 1) != 0
        && *(unsigned __int8 *)(v3 + 12) >= BYTE2(a2))
      {
        v6 = *(_QWORD *)(*(_QWORD *)v3 + 8 * (BYTE2(a2) - 1));
        if (v6)
        {
          a2 = (unsigned __int16)a2;
          a1 = v6;
          goto LABEL_10;
        }
      }
      if (v5)
        return v4;
    }
    else
    {
      v4 = 0;
    }
    v11 = atomic_load((unint64_t *)(a1 + 8));
    if ((v11 & 0x70) == 0x10)
    {
      v12 = atomic_load((unint64_t *)(a1 + 8));
      v4 = (v12 >> 3) & 1;
      v13 = *(_QWORD *)(a1 + 32);
      if (v13)
      {
        v14 = *(unsigned int *)(a1 + 24);
        if (v14 <= a2)
          return v4 ^ (v13 + v14 > a2);
      }
    }
    return v4;
  }
  LODWORD(v4) = 0;
LABEL_10:
  v7 = atomic_load((unint64_t *)(a1 + 8));
  v8 = atomic_load((unint64_t *)(a1 + 8));
  v9 = (v7 >> 3) & 1;
  switch((v8 >> 4) & 7)
  {
    case 0u:
      v9 ^= CFUniCharIsMemberOf(a2, *(_DWORD *)(a1 + 24));
      return v4 ^ v9;
    case 1u:
      v25 = *(_QWORD *)(a1 + 32);
      if (v25)
      {
        v26 = *(unsigned int *)(a1 + 24);
        if (v26 <= a2)
          v9 ^= v25 + v26 > a2;
      }
      return v4 ^ v9;
    case 2u:
      v15 = *(_QWORD *)(a1 + 32);
      if (!v15)
        return v4 ^ v9;
      v16 = *(unsigned __int16 **)(a1 + 24);
      if (*v16 > (unsigned __int16)a2)
        return v4 ^ v9;
      v17 = &v16[v15];
      v19 = *(v17 - 1);
      v18 = v17 - 1;
      if (v19 < (unsigned __int16)a2 || v15 < 1)
        return v4 ^ v9;
      break;
    case 3u:
      v27 = *(_QWORD *)(a1 + 24);
      if (!v27)
        return v4 ^ v9;
      v28 = *(unsigned __int8 *)(v27 + ((unsigned __int16)a2 >> 3));
      goto LABEL_44;
    case 4u:
      v23 = *(_QWORD *)(a1 + 24);
      if (!v23)
        return v4 ^ v9;
      v24 = *(unsigned __int8 *)(v23 + BYTE1(a2));
      if (*(_BYTE *)(v23 + BYTE1(a2)))
      {
        if ((_DWORD)v24 == 255)
        {
          v9 = 1;
        }
        else
        {
          v28 = *(unsigned __int8 *)(v23 + 32 * v24 + (a2 >> 3) + 224);
LABEL_44:
          v9 = (v28 >> (a2 & 7)) & 1;
        }
      }
      else
      {
        v9 = 0;
      }
      return v4 ^ v9;
    default:
      return 0;
  }
  while (1)
  {
    v21 = &v16[((char *)v18 - (char *)v16) >> 2];
    v22 = *v21;
    if (v22 <= (unsigned __int16)a2)
      break;
    v18 = v21 - 1;
LABEL_30:
    if (v16 > v18)
      return v4 ^ v9;
  }
  if (v22 < (unsigned __int16)a2)
  {
    v16 = v21 + 1;
    goto LABEL_30;
  }
  v9 = (v7 & 8) == 0;
  return v4 ^ v9;
}

uint64_t CFUniCharIsMemberOf(int a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  _BOOL4 v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int *v8;
  BOOL v9;
  unsigned int v10;
  uint64_t v12;

  if (a2 - 16 >= 0x54)
    v2 = a2;
  else
    v2 = a2 + 85;
  if (a2 == 1)
    v3 = 108;
  else
    v3 = v2;
  if (v3 == 15)
  {
    v5 = (a1 - 8232) < 2 || a1 == 133;
    return (a1 - 10) < 4 || v5;
  }
  if (v3 != 3)
  {
    if (v3 == 2)
    {
      v4 = 1;
      if (a1 > 159)
      {
        if (a1 == 160 || a1 == 5760)
          return v4;
      }
      else if (a1 == 9 || a1 == 32)
      {
        return v4;
      }
      if ((a1 - 0x2000) >= 0xC)
      {
        v4 = 1;
        if (a1 == 8239 || a1 == 8287)
          return v4;
        goto LABEL_38;
      }
      return 1;
    }
    v6 = v3 - 85;
    if (v3 <= 0x63)
      v6 = v3;
    v7 = v6 - 4;
    if (v7 > 0x15)
      return 0;
    v8 = (unsigned int *)&__CFUniCharBitmapDataArray[2 * v7];
    if (v3 == 108)
    {
      v10 = BYTE2(a1);
      if (BYTE2(a1) == 14)
      {
        v9 = a1 != 1 && a1 - 32 >= 0x60;
        return !v9;
      }
    }
    else
    {
      if (v3 == 12)
      {
        if (BYTE2(a1) == 14)
        {
          v9 = a1 == 1 || a1 - 128 >= 0xFFFFFFA0;
          return !v9;
        }
        if (BYTE2(a1) - 15 >= 2)
        {
          if (BYTE2(a1) < *v8)
          {
            v12 = *(_QWORD *)(__CFUniCharBitmapDataArray[2 * v7 + 1] + 8 * BYTE2(a1));
            if (v12)
              return ((*(unsigned __int8 *)(v12 + ((unsigned __int16)a1 >> 3)) >> (a1 & 7)) & 1) == 0;
          }
          return 1;
        }
        return 0;
      }
      v10 = BYTE2(a1);
    }
    if (v10 < *v8)
    {
      v4 = *(_QWORD *)(__CFUniCharBitmapDataArray[2 * v7 + 1] + 8 * v10);
      if (v4)
        return (*(unsigned __int8 *)(v4 + ((unsigned __int16)a1 >> 3)) >> (a1 & 7)) & 1;
      return v4;
    }
    return 0;
  }
  v4 = 1;
  if (a1 > 159)
  {
    if (a1 == 160 || a1 == 5760)
      return v4;
  }
  else if (a1 == 9 || a1 == 32)
  {
    return v4;
  }
  if ((a1 - 0x2000) < 0xC)
    return 1;
  v4 = 1;
  if (a1 <= 8231)
  {
    if ((a1 - 10) >= 4 && a1 != 133)
      return 0;
    return v4;
  }
  if ((a1 - 8232) <= 0x37 && ((1 << (a1 - 40)) & 0x80000000000083) != 0)
    return v4;
LABEL_38:
  if (a1 != 12288)
    return 0;
  return v4;
}

Boolean CFCharacterSetIsLongCharacterMember(CFCharacterSetRef theSet, UTF32Char theChar)
{
  uint64_t v2;

  v2 = *(_QWORD *)&theChar;
  if (CF_IS_OBJC(0x19uLL, (__objc2_class **)theSet))
    return -[__CFCharacterSet longCharacterIsMember:](theSet, "longCharacterIsMember:", v2);
  else
    return _CFCharacterSetIsLongCharacterMember((uint64_t)theSet, v2);
}

uint64_t CFCharacterSetInitInlineBuffer(__objc2_class **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  unsigned int v5;
  uint64_t v6;
  char v7;
  int v8;
  char v9;
  char v10;
  char v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  unsigned int v20;

  v3 = (uint64_t)a1;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)a2 = a1;
  *(_DWORD *)(a2 + 16) = 0x10000;
  result = CF_IS_OBJC(0x19uLL, a1);
  if ((_DWORD)result && (result = objc_msgSend((id)v3, "_expandedCFCharacterSet"), (v3 = result) == 0))
  {
    *(_DWORD *)(a2 + 8) = 2;
LABEL_24:
    *(_DWORD *)(a2 + 16) = 1114112;
  }
  else
  {
    v5 = atomic_load((unint64_t *)(v3 + 8));
    switch((v5 >> 4) & 7)
    {
      case 0u:
        result = CFUniCharGetBitmapPtrForPlane(*(_DWORD *)(v3 + 24), 0);
        *(_QWORD *)(a2 + 24) = result;
        *(_DWORD *)(a2 + 16) = 1114112;
        if (result)
        {
          v9 = atomic_load((unint64_t *)(v3 + 8));
          if ((v9 & 8) == 0)
            goto LABEL_22;
          v8 = 4;
        }
        else
        {
          v8 = 2;
        }
        goto LABEL_21;
      case 1u:
        *(_DWORD *)(a2 + 12) = *(_DWORD *)(v3 + 24);
        *(_DWORD *)(a2 + 16) = *(_DWORD *)(v3 + 24) + *(_DWORD *)(v3 + 32);
        v10 = atomic_load((unint64_t *)(v3 + 8));
        if ((v10 & 8) != 0)
          *(_DWORD *)(a2 + 8) = 4;
        return result;
      case 2u:
        *(_DWORD *)(a2 + 8) = 2;
        if (*(uint64_t *)(v3 + 32) >= 1)
        {
          *(_DWORD *)(a2 + 12) = **(unsigned __int16 **)(v3 + 24);
          *(_DWORD *)(a2 + 16) = *(unsigned __int16 *)(*(_QWORD *)(v3 + 24) + 2 * *(_QWORD *)(v3 + 32) - 2) + 1;
          v11 = atomic_load((unint64_t *)(v3 + 8));
          if ((v11 & 8) != 0)
          {
            v12 = *(_DWORD *)(a2 + 12);
            v13 = *(_DWORD *)(a2 + 16);
            if (v12)
            {
              if (v13 == 0x10000)
              {
                *(_DWORD *)(a2 + 12) = 0;
                *(_DWORD *)(a2 + 16) = v12;
              }
              else
              {
                *(_QWORD *)(a2 + 12) = 0x1000000000000;
              }
            }
            else
            {
              *(_DWORD *)(a2 + 12) = v13;
              *(_DWORD *)(a2 + 16) = 0x10000;
            }
          }
        }
        goto LABEL_22;
      case 3u:
      case 4u:
        v6 = *(_QWORD *)(v3 + 24);
        *(_QWORD *)(a2 + 24) = v6;
        if (v6)
        {
          v7 = atomic_load((unint64_t *)(v3 + 8));
          if ((v7 & 0x70) != 0x40)
            goto LABEL_22;
          v8 = 1;
        }
        else
        {
          *(_DWORD *)(a2 + 8) = 1;
          v14 = atomic_load((unint64_t *)(v3 + 8));
          if ((v14 & 8) == 0)
            goto LABEL_22;
          v8 = *(_DWORD *)(a2 + 8) | 4;
        }
LABEL_21:
        *(_DWORD *)(a2 + 8) = v8;
LABEL_22:
        v15 = *(_QWORD *)(v3 + 40);
        if (!v15)
          return result;
        if (*(_BYTE *)(v15 + 13))
          goto LABEL_24;
        v16 = *(_DWORD *)(v15 + 8);
        if (!v16)
          return result;
        v17 = 1114112;
        v18 = 15;
        break;
      default:
        return result;
    }
    while (1)
    {
      v19 = v18 + 1;
      v20 = (v18 + 1);
      if (v20 <= 0x10
        && ((v16 >> v19) & 1) != 0
        && *(unsigned __int8 *)(v15 + 12) >= v20
        && *(_QWORD *)(*(_QWORD *)v15 + 8 * v18))
      {
        break;
      }
      --v18;
      v17 -= 0x10000;
      if (v19 <= 1)
        return result;
    }
    *(_DWORD *)(a2 + 16) = v17;
  }
  return result;
}

CFStringRef _CFCreateLastPathComponent(const __CFAllocator *a1, CFStringRef theString, _QWORD *a3)
{
  CFIndex Length;
  CFIndex v7;
  uint64_t v9;
  uint64_t v10;
  CFRange v11;
  const __CFAllocator *v12;
  const __CFString *v13;

  Length = CFStringGetLength(theString);
  v7 = Length - 2;
  if (Length >= 2)
  {
    v9 = Length;
    v10 = 0;
    while (v9 + v10 >= 1)
    {
      if (CFStringGetCharacterAtIndex(theString, --v10 + v9) == 47)
      {
        v11.location = v9 + v10 + 1;
        if (a3)
          *a3 = v9 + v10;
        v11.length = ~v10;
        v12 = a1;
        v13 = theString;
        return CFStringCreateWithSubstring(v12, v13, v11);
      }
    }
    if (v9 >= 3 && _hasDrive(theString))
    {
      if (a3)
        *a3 = -1;
      v12 = a1;
      v13 = theString;
      v11.location = 2;
      v11.length = v7;
      return CFStringCreateWithSubstring(v12, v13, v11);
    }
  }
  if (a3)
    *a3 = -1;
  return (CFStringRef)CFRetain(theString);
}

void _CFBundleSplitFileName(const __CFString *a1, __CFString **a2, CFStringRef *a3, CFStringRef *a4, const __CFString *a5, const __CFString *a6, uint64_t a7, int *a8)
{
  CFIndex Length;
  uint64_t v15;
  CFIndex v16;
  uint64_t v18;
  CFIndex v19;
  CFIndex v20;
  CFIndex v21;
  CFIndex v22;
  CFIndex v23;
  CFIndex v24;
  BOOL v25;
  CFIndex v26;
  CFIndex v27;
  int CharacterAtIndex;
  CFComparisonResult v29;
  unint64_t v30;
  CFIndex v31;
  CFIndex v32;
  int v33;
  int v34;
  CFIndex v35;
  CFComparisonResult v36;
  int v37;
  int v38;
  unsigned int v39;
  __CFString *MutableCopy;
  __CFString *v41;
  CFIndex v43;
  CFRange v44;
  CFIndex v45;
  const __CFString *theString2;
  int *v47;
  CFRange v49;
  CFRange v50;
  CFRange v51;
  CFRange v52;

  Length = CFStringGetLength(a1);
  if ((unint64_t)a3 | (unint64_t)a4)
  {
    v15 = Length;
    v16 = Length;
    do
    {
      if (v16-- < 1)
      {
        v18 = 0;
        goto LABEL_9;
      }
    }
    while (CFStringGetCharacterAtIndex(a1, v16) != 46);
    v18 = (unsigned __int16)v16;
    if (a3 && v15 - 1 != (unsigned __int16)v16)
    {
      v49.length = CFStringGetLength(a1) + ~(unint64_t)(unsigned __int16)v16;
      v49.location = (unsigned __int16)v16 + 1;
      *a3 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, v49);
    }
LABEL_9:
    if (a4 && v15 >= 1)
    {
      v19 = 0;
      while (CFStringGetCharacterAtIndex(a1, v19) != 46)
      {
        if (v15 == ++v19)
          goto LABEL_17;
      }
      if (v18 != v19)
      {
        v50.length = ~v19 + CFStringGetLength(a1);
        v50.location = v19 + 1;
        *a4 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, v50);
      }
    }
  }
LABEL_17:
  v20 = CFStringGetLength(a1);
  v21 = v20 - 1;
  if (v20 <= 1)
  {
    v23 = 0;
    v24 = 0;
    v31 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 3;
    goto LABEL_44;
  }
  v22 = v20;
  theString2 = a6;
  v47 = a8;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 1 - v20;
  while (1)
  {
    CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v21);
    if (CharacterAtIndex == 46)
      v22 = v21;
    if (CharacterAtIndex == 126 && !v25)
    {
      v51.location = v21;
      v51.length = v22 + v27;
      v29 = CFStringCompareWithOptions(a1, a5, v51, 8uLL);
      if (v29 == kCFCompareEqualTo)
      {
        v23 = v21;
        v24 = v22 + v27;
      }
      v25 = v29 == kCFCompareEqualTo;
      v26 = v21;
      goto LABEL_27;
    }
    if (CharacterAtIndex == 45)
      break;
LABEL_27:
    v30 = v21-- + 1;
    ++v27;
    if (v30 <= 2)
    {
      v31 = 0;
      v32 = 0;
      v33 = 0;
      goto LABEL_39;
    }
  }
  if (v25)
    v35 = v26;
  else
    v35 = v22;
  v32 = v35 - v21;
  v52.location = v21;
  v52.length = v35 - v21;
  v36 = CFStringCompareWithOptions(a1, theString2, v52, 8uLL);
  if (v36)
    v31 = 0;
  else
    v31 = v21;
  if (v36)
  {
    v32 = 0;
    v33 = 0;
  }
  else
  {
    v33 = 1;
  }
LABEL_39:
  a8 = v47;
  if ((v33 & v25) != 0)
    v34 = 4;
  else
    v34 = 3;
  if (v25)
  {
    v37 = 2;
    goto LABEL_45;
  }
LABEL_44:
  v37 = 1;
LABEL_45:
  if (v33)
    v38 = v34;
  else
    v38 = v37;
  *a8 = v38;
  if ((v38 - 2) <= 2)
  {
    v39 = v38 - 3;
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, a1);
    v41 = MutableCopy;
    if (v38 == 4 || v38 == 2)
      v43 = v24;
    else
      v43 = 0;
    if (v39 >= 2)
      v44.location = v23;
    else
      v44.location = v31;
    if (v39 >= 2)
      v45 = 0;
    else
      v45 = v32;
    v44.length = v43 + v45;
    CFStringDelete(MutableCopy, v44);
    *a2 = v41;
  }
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  char v5;
  char **p_data;
  char *v7;
  char v8;
  char v9;
  unint64_t v10;
  UniChar *v11;

  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    return -[__CFString characterAtIndex:]((id)theString, "characterAtIndex:", idx);
  v5 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v5 & 0x60) != 0)
  {
    v7 = *p_data;
  }
  else
  {
    v8 = atomic_load((unint64_t *)&theString->info);
    v7 = (char *)&p_data[(v8 & 5) != 4];
  }
  v9 = atomic_load((unint64_t *)&theString->info);
  if ((v9 & 0x10) != 0)
  {
    v11 = (UniChar *)&v7[2 * idx];
  }
  else
  {
    v10 = atomic_load((unint64_t *)&theString->info);
    v11 = (UniChar *)(__CFCharToUniCharTable + 2 * v7[((v10 >> 2) & 1) + idx]);
  }
  return *v11;
}

const __CFString *CFURLCreateStringWithFileSystemPath(const __CFAllocator *a1, __objc2_class **a2, uint64_t a3, int a4)
{
  uint64_t v5;
  const __CFURL *v7;
  const __CFString *v8;
  int v9;
  int v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  CFStringEncoding v14;
  CFStringRef v15;
  _BOOL4 v16;
  const __CFArray *ArrayBySeparatingStrings;
  int Count;
  const __CFArray *MutableCopy;
  const __CFString *ValueAtIndex;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  const __CFString *v24;
  int CharacterAtIndex;
  int v26;
  unsigned int v27;
  CFStringRef v28;
  const __CFString *v29;
  CFIndex v30;
  CFStringRef v31;
  CFIndex Length;
  _BOOL4 v33;
  int v34;
  uint64_t v35;
  CFIndex v36;
  int v37;
  UniChar *Typed;
  uint64_t v39;
  uint64_t v40;
  UniChar *v41;
  int v42;
  UniChar *v43;
  UniChar *v44;
  CFStringRef v45;
  CFRange v47;
  CFRange v48;
  CFRange v49;

  v5 = (uint64_t)a2;
  if (a4)
  {
    if (CF_IS_OBJC(0x1DuLL, a2))
    {
      v7 = (const __CFURL *)objc_msgSend((id)v5, "baseURL");
      if (!v7)
        goto LABEL_6;
LABEL_8:
      v8 = (const __CFString *)CFURLCreateStringWithFileSystemPath(a1, v7, a3, 0);
      v9 = 0;
      goto LABEL_9;
    }
    v7 = *(const __CFURL **)(v5 + 32);
    if (v7)
      goto LABEL_8;
  }
  else
  {
    v7 = 0;
  }
LABEL_6:
  v8 = 0;
  v9 = 1;
LABEL_9:
  v10 = CF_IS_OBJC(0x1DuLL, (__objc2_class **)v5);
  if (a3 || v10 || (*(_BYTE *)(v5 + 17) & 0x80) == 0 || (v11 = _retainedComponentString(v5, 32, 1, 1)) == 0)
  {
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)v5))
      v5 = objc_msgSend((id)v5, "_cfurl");
    v13 = CFURLCopyPath((CFURLRef)v5);
    v14 = *(_DWORD *)(v5 + 20);
    if (v9 && CFURLIsFileReferenceURL((CFURLRef)v5))
    {
      v15 = FileReferenceURLPathToFullURLPath(v13, a1);
      CFRelease(v13);
      v13 = v15;
    }
    if (!v13)
      return v8;
    if (a3 == 2)
    {
      ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, v13, CFSTR("/"));
      Count = CFArrayGetCount(ArrayBySeparatingStrings);
      MutableCopy = CFArrayCreateMutableCopy(a1, Count, ArrayBySeparatingStrings);
      CFRelease(ArrayBySeparatingStrings);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, Count - 1);
      if (!CFStringGetLength(ValueAtIndex))
        CFArrayRemoveValueAtIndex(MutableCopy, --Count);
      if (Count >= 2)
      {
        v21 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, 0);
        if (!CFStringGetLength(v21))
        {
          v22 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, 1);
          v23 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(a1, v22, CFSTR("\\"), v14);
          if (v23)
          {
            v24 = v23;
            if (CFStringGetLength(v23) == 2)
            {
              CharacterAtIndex = CFStringGetCharacterAtIndex(v24, 1);
              v26 = CharacterAtIndex;
              if (CharacterAtIndex == 124 || CharacterAtIndex == 58)
              {
                CFArrayRemoveValueAtIndex(MutableCopy, 0);
                if (v26 == 124)
                {
                  v27 = CFStringGetCharacterAtIndex(v24, 0);
                  v28 = CFStringCreateWithFormat(a1, 0, CFSTR("%c:"), v27);
                  CFArraySetValueAtIndex(MutableCopy, 0, v28);
                  CFRelease(v28);
                }
              }
            }
            CFRelease(v24);
          }
        }
      }
      v29 = CFStringCreateByCombiningStrings(a1, MutableCopy, CFSTR("\\"));
      CFRelease(MutableCopy);
      v12 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(a1, v29, CFSTR("\\"), v14);
      CFRelease(v29);
    }
    else
    {
      if (a3)
      {
        v12 = v8;
LABEL_65:
        CFRelease(v13);
        return v12;
      }
      v16 = _CFURLHasFileURLScheme((__objc2_class **)v5, 0);
      v12 = URLPathToPOSIXPath(v13, a1, v14, v16);
    }
    CFRelease(v13);
    if (!v12)
      return v8;
  }
  else
  {
    v12 = v11;
  }
  if (!CFURLHasDirectoryPath((CFURLRef)v5)
    || CFStringGetLength(v12) < 2
    || (v30 = CFStringGetLength(v12), CFStringGetCharacterAtIndex(v12, v30 - 1) != 47)
    || (v49.length = CFStringGetLength(v12) - 1,
        v49.location = 0,
        v31 = CFStringCreateWithSubstring(a1, v12, v49),
        CFRelease(v12),
        (v12 = v31) != 0))
  {
    Length = CFStringGetLength(v12);
    if (a3 != 2)
    {
      if (Length >= 1)
      {
        v33 = CFStringGetCharacterAtIndex(v12, 0) != 47;
LABEL_53:
        if (v8 && v33)
        {
          v34 = CFURLHasDirectoryPath(v7);
          v35 = CFStringGetLength(v8);
          v36 = CFStringGetLength(v12);
          v37 = _CFGetSlash();
          Typed = (UniChar *)CFAllocatorAllocateTyped(a1, 2 * (v36 + v35) + 4, 0x1000040BDFB0063, 0);
          v47.location = 0;
          v47.length = v35;
          CFStringGetCharacters(v8, v47, Typed);
          if (v34)
          {
            if (Typed[v35 - 1] != v37)
              Typed[v35++] = v37;
          }
          else
          {
            v39 = 2 * v35 - 2;
            do
            {
              v40 = v39;
              v41 = (UniChar *)((char *)Typed + v39);
              if (v41 <= Typed)
                break;
              v42 = *v41;
              v39 = v40 - 2;
            }
            while (v42 != v37);
            v35 = (v40 >> 1) + 1;
          }
          v43 = &Typed[v35 - (a3 == 1)];
          v48.location = 0;
          v48.length = v36;
          CFStringGetCharacters(v12, v48, v43);
          v44 = &v43[v36];
          *v44 = 0;
          v45 = _resolvedPath((char *)Typed, (unint64_t)v44, v37, 0, 1, a1);
          CFRelease(v8);
          v13 = v12;
          v12 = v45;
          goto LABEL_65;
        }
LABEL_58:
        v13 = v8;
        if (!v8)
          return v12;
        goto LABEL_65;
      }
LABEL_52:
      v33 = 1;
      goto LABEL_53;
    }
    if (Length < 3)
    {
      if (Length != 2)
        goto LABEL_52;
    }
    else if (CFStringGetCharacterAtIndex(v12, 0) == 92 && CFStringGetCharacterAtIndex(v12, 1) == 92)
    {
      goto LABEL_58;
    }
    v33 = 1;
    if (CFStringGetCharacterAtIndex(v12, 1) == 58)
      goto LABEL_58;
    goto LABEL_53;
  }
  return v8;
}

CFStringRef CFStringCreateWithCharactersNoCopy(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)chars, 2 * numChars, 256, 0x10u, contentsDeallocator, 0);
}

BOOL _CFURLHasFileURLScheme(__objc2_class **a1, _BYTE *a2)
{
  __objc2_class **v3;
  unsigned int v4;
  CFStringRef v5;
  CFStringRef v6;
  _BOOL8 v7;

  do
  {
    while (1)
    {
      v3 = a1;
      if (!CF_IS_OBJC(0x1DuLL, a1))
        break;
      a1 = (__objc2_class **)objc_msgSend(v3, "baseURL");
      if (!a1)
        goto LABEL_5;
    }
    a1 = (__objc2_class **)v3[4];
  }
  while (a1);
LABEL_5:
  if (!CF_IS_OBJC(0x1DuLL, v3) && (v4 = *((_DWORD *)v3 + 4), v4 >> 29))
  {
    if (a2)
    {
      *a2 = v4 & 1;
      v4 = *((_DWORD *)v3 + 4);
    }
    return v4 >> 29 == 3;
  }
  else
  {
    v5 = CFURLCopyScheme((CFURLRef)v3);
    if (v5)
    {
      v6 = v5;
      if (v5 == CFSTR("file"))
      {
        v7 = 1;
        if (!a2)
          goto LABEL_11;
      }
      else
      {
        v7 = CFStringCompare(v5, CFSTR("file"), 1uLL) == kCFCompareEqualTo;
        if (!a2)
        {
LABEL_11:
          CFRelease(v6);
          return v7;
        }
      }
      *a2 = 1;
      goto LABEL_11;
    }
    v7 = 0;
    if (a2)
      *a2 = 0;
  }
  return v7;
}

Boolean CFURLHasDirectoryPath(CFURLRef anURL)
{
  unsigned int v2;
  BOOL v3;

  do
  {
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
      anURL = (CFURLRef)-[__CFURL _cfurl](anURL, "_cfurl");
    v2 = *((_DWORD *)anURL + 4);
    anURL = (CFURLRef)*((_QWORD *)anURL + 4);
    if (anURL)
      v3 = (v2 & 0x3E) == 0;
    else
      v3 = 0;
  }
  while (v3);
  return (v2 >> 11) & 1;
}

const __CFString *_retainedComponentString(uint64_t a1, int a2, int a3, int a4)
{
  const __CFAllocator *v8;
  unsigned int v9;
  const __CFAllocator *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  char v14;
  CFIndex *v15;
  CFRange v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFString *v21;
  uint64_t v22;
  int v23;
  CFAllocatorRef v24;
  CFIndex Length;
  uint64_t v26;
  int v27;
  const __CFAllocator *v28;
  uint64_t v29;
  unint64_t v30;
  CFStringEncoding v31;
  CFStringRef v32;
  CFStringRef v33;
  void *v35;
  CFMutableStringRef v36[3];
  CFMutableStringRef theString;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __int16 v41;
  UInt8 v42[1024];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v8 = CFGetAllocator((CFTypeRef)a1);
  v9 = *(_DWORD *)(a1 + 16);
  if ((v9 & a2) == 0)
    return 0;
  v10 = v8;
  if ((a2 & 1) != 0)
  {
    v16.location = *(_QWORD *)(a1 + 56);
    if (v16.location != -1)
    {
      v16.length = *(_QWORD *)(a1 + 64);
      goto LABEL_10;
    }
    return 0;
  }
  v11 = 0;
  v12 = a2;
  v13 = *(_DWORD *)(a1 + 16);
  do
  {
    v14 = v12;
    v12 >>= 1;
    v11 += v13 & 1;
    v13 >>= 1;
  }
  while ((v14 & 2) == 0);
  v15 = (CFIndex *)(a1 + 56 + 16 * v11);
  v16.location = *v15;
  if (*v15 == -1)
    return 0;
  v16.length = v15[1];
  if ((a2 & 1) == 0)
  {
LABEL_13:
    v19 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    v20 = CFStringCreateWithSubstring(v8, v19, v16);
    goto LABEL_19;
  }
LABEL_10:
  switch(v9 >> 29)
  {
    case 1u:
      v17 = CFSTR("http");
      break;
    case 2u:
      v17 = CFSTR("https");
      break;
    case 3u:
      v17 = CFSTR("file");
      break;
    case 4u:
      v17 = CFSTR("data");
      break;
    case 5u:
      v17 = CFSTR("ftp");
      break;
    default:
      goto LABEL_13;
  }
  v20 = (const __CFString *)CFRetain(v17);
LABEL_19:
  v21 = v20;
  if (a4 | a3 || !v20 || (*(_BYTE *)(a1 + 18) & 1) != 0)
    goto LABEL_29;
  v22 = *(_QWORD *)(a1 + 40);
  if (v22)
    LODWORD(v22) = *(_DWORD *)(v22 + 16);
  if ((v22 & a2) == 0)
  {
LABEL_29:
    v18 = v20;
    if (!a4)
      return v18;
    goto LABEL_30;
  }
  v23 = *(_DWORD *)(a1 + 20);
  v24 = CFGetAllocator(v20);
  Length = CFStringGetLength(v21);
  v36[2] = (CFMutableStringRef)v36;
  theString = 0;
  v41 = 0;
  v39 = 0;
  v40 = 0;
  v38 = 0;
  constructBuffers(v21, v42, &v40, &v39, (char *)&v41 + 1, (char *)&v41);
  v26 = v40;
  v27 = HIBYTE(v41);
  v28 = v24;
  v29 = v39;
  scanCharacters(v28, &theString, 0, v40, v39, HIBYTE(v41), 0, Length, &v38, a2, v23);
  v18 = theString;
  if (theString)
  {
    v30 = Length - v38;
    if (Length > v38)
    {
      if (v27)
        __CFStringAppendBytes((unint64_t *)theString, (unsigned __int8 *)(v26 + v38), v30, 513);
      else
        CFStringAppendCharacters(theString, (const UniChar *)(v29 + 2 * v38), v30);
    }
  }
  else
  {
    CFRetain(v21);
    v18 = v21;
  }
  if ((_BYTE)v41)
  {
    if (v27)
      v35 = (void *)v26;
    else
      v35 = (void *)v29;
    free(v35);
  }
  CFRelease(v21);
  if (a4)
  {
LABEL_30:
    if (v18)
    {
      v31 = *(_DWORD *)(a1 + 20);
      if (v31 == 134217984)
        v32 = CFURLCreateStringByReplacingPercentEscapes(v10, v18, &stru_1E1337B18);
      else
        v32 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(v10, v18, &stru_1E1337B18, v31);
      v33 = v32;
      CFRelease(v18);
      return v33;
    }
  }
  return v18;
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  CFIndex length;
  CFIndex location;
  unint64_t v7;
  char v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  char **p_data;
  char *v14;
  char *v15;
  uint64_t v16;
  char v17;
  char v18;
  uint64_t v19;
  char **v20;
  char *v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __objc2_class **v27;
  int8x16_t *v28;
  int64_t v29;
  unsigned int v30;
  uint64_t v31;

  length = range.length;
  location = range.location;
  v7 = CF_IS_OBJC(7uLL, (__objc2_class **)str);
  if ((_DWORD)v7)
    return (CFStringRef)-[__CFString _createSubstringWithRange:]((id)str, "_createSubstringWithRange:", location, length);
  if (!location)
  {
    v9 = atomic_load((unint64_t *)&str->info);
    v10 = v9 & 5;
    v11 = atomic_load((unint64_t *)&str->info);
    v12 = v11 & 0x60;
    if (v10 == 4)
    {
      p_data = &str->data;
      if (v12)
      {
        v14 = *p_data;
      }
      else
      {
        v16 = atomic_load((unint64_t *)&str->info);
        v14 = (char *)&p_data[(v16 & 5) != 4];
      }
      v15 = (char *)*v14;
    }
    else
    {
      v15 = (v11 & 0x60) != 0 ? (char *)str->length : str->data;
    }
    if ((char *)length == v15)
      return (CFStringRef)_CFNonObjCStringCreateCopy((__objc2_class **)alloc, (uint64_t)str);
  }
  v17 = atomic_load((unint64_t *)&str->info);
  v18 = atomic_load((unint64_t *)&str->info);
  v19 = v18 & 0x60;
  v20 = &str->data;
  if ((v17 & 0x10) != 0)
  {
    if (v19)
    {
      v22 = *v20;
    }
    else
    {
      v31 = atomic_load((unint64_t *)&str->info);
      v22 = (char *)&v20[(v31 & 5) != 4];
    }
    v28 = (int8x16_t *)&v22[2 * location];
    v29 = 2 * length;
    v27 = (__objc2_class **)alloc;
    v26 = 256;
    v30 = 2;
  }
  else
  {
    if (v19)
    {
      v21 = *v20;
    }
    else
    {
      v23 = atomic_load((unint64_t *)&str->info);
      v21 = (char *)&v20[(v23 & 5) != 4];
    }
    v24 = atomic_load((unint64_t *)&str->info);
    v25 = (uint64_t)&v21[location + ((v24 >> 2) & 1)];
    v26 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(v7);
      v26 = __CFDefaultEightBitStringEncoding;
    }
    v27 = (__objc2_class **)alloc;
    v28 = (int8x16_t *)v25;
    v29 = length;
    v30 = 0;
  }
  return (CFStringRef)__CFStringCreateImmutableFunnel3(v27, v28, v29, v26, v30, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
}

CFStringRef CFURLCreateStringByReplacingPercentEscapes(CFAllocatorRef allocator, CFStringRef originalString, CFStringRef charactersToLeaveEscaped)
{
  uint64_t v3;
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;
  const __CFAllocator *v8;
  BOOL v9;
  CFIndex Length;
  CFIndex v11;
  const __CFAllocator *v12;
  unint64_t v13;
  CFIndex v14;
  CFIndex MaximumSizeForEncoding;
  CFIndex v16;
  UInt8 *v17;
  int v19;
  _BOOL4 v20;
  CFMutableStringRef v21;
  __CFString *v22;
  int CharacterAtIndex;
  int v24;
  char v25;
  char v26;
  UInt8 v27;
  const __CFString *v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  int v36;
  int v37;
  char v38;
  char v39;
  char v40;
  int v41;
  const __CFString *v42;
  CFIndex v43;
  CFIndex v44;
  CFIndex location;
  __CFString *v46;
  CFIndex v47;
  uint64_t v48;
  const __CFAllocator *v49;
  __CFString *v50;
  UniChar *v51;
  const UniChar *v52;
  int v53;
  CFRange v54;
  const __CFString *v55;
  CFIndex v56;
  UInt8 *v57;
  CFIndex v58;
  UInt8 *v59;
  int v60;
  int v61;
  uint64_t v62;
  CFAllocatorRef v63;
  CFAllocatorRef v64;
  uint64_t v65;
  __CFString *v66;
  CFIndex v67;
  __CFString *v68;
  CFStringRef v69;
  uint64_t *v70;
  CFIndex v71;
  UniChar v72;
  CFRange v73;
  CFIndex v74;
  UInt8 v75;
  _BYTE v76[4191];
  uint64_t v77;
  CFRange v78;
  CFRange v79;
  CFRange v80;
  CFRange v81;

  v3 = MEMORY[0x1E0C80A78](allocator, originalString);
  v6 = v5;
  v7 = v4;
  v8 = (const __CFAllocator *)v3;
  v77 = *MEMORY[0x1E0C80C00];
  if (v5)
  {
    v9 = CFStringGetLength(v5) == 0;
    if (!v7)
      return 0;
  }
  else
  {
    v9 = 0;
    if (!v4)
      return 0;
  }
  Length = CFStringGetLength(v7);
  if (!v6)
    return CFStringCreateCopy(v8, v7);
  v11 = Length;
  if (!Length)
    return CFStringCreateCopy(v8, v7);
  v73.location = 0;
  v73.length = 0;
  v72 = 0;
  if (v9)
  {
    v12 = v8;
    v13 = CFStringGetLength(v7);
    v14 = v13;
    if (v13 <= 1)
      v13 = 1;
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v13, 0x8000100u);
    v16 = MaximumSizeForEncoding;
    if (MaximumSizeForEncoding < 2097)
    {
      v17 = &v75;
LABEL_89:
      v74 = 0;
      v79.location = 0;
      v79.length = v14;
      if (CFStringGetBytes(v7, v79, 0x8000100u, 0, 0, v17, v16, &v74))
      {
        v56 = v74;
        v57 = &v17[v16];
        if (v74 >= 1)
        {
          v58 = 0;
          v59 = v17;
          v57 = &v17[v16];
          do
          {
            v60 = *v59;
            if (v60 == 37)
            {
              v58 += 2;
              if (v58 >= v56)
                goto LABEL_103;
              v61 = UnescapeAllWithUTF8_hexvalues[v59[1]];
              v60 = UnescapeAllWithUTF8_hexvalues[v59[2]];
              if (((v60 | v61) & 0x80) != 0)
                goto LABEL_103;
              v59 += 3;
              LOBYTE(v60) = v60 + 16 * v61;
            }
            else
            {
              ++v59;
            }
            *v57++ = v60;
            ++v58;
            v56 = v74;
          }
          while (v58 < v74);
        }
        v22 = (__CFString *)CFStringCreateWithBytes(v12, &v17[v16], v57 - &v17[v16], 0x8000100u, 0);
      }
      else
      {
LABEL_103:
        v22 = 0;
      }
      if (v17 != &v75)
        free(v17);
      return v22;
    }
    v17 = (UInt8 *)malloc_type_malloc(2 * MaximumSizeForEncoding, 0xD59F743FuLL);
    if (v17)
      goto LABEL_89;
    return 0;
  }
  v80.location = 0;
  v80.length = Length;
  v19 = CFStringFindWithOptions(v7, CFSTR("%"), v80, 0, &v73);
  v20 = v19 == 0;
  if (v19)
  {
    v69 = v6;
    v21 = 0;
    v67 = 0;
    v22 = 0;
    v63 = (CFAllocatorRef)&__kCFAllocatorNull;
    v64 = v8;
    v71 = v11;
    while (1)
    {
      LODWORD(v70) = v20;
      if (v11 - v73.location < 3)
        break;
      CharacterAtIndex = CFStringGetCharacterAtIndex(v7, v73.location + 1);
      v24 = CFStringGetCharacterAtIndex(v7, v73.location + 2);
      if ((CharacterAtIndex - 48) >= 0xA)
      {
        if ((CharacterAtIndex - 97) >= 6)
        {
          if ((CharacterAtIndex - 65) > 5)
            break;
          v25 = -55;
        }
        else
        {
          v25 = -87;
        }
      }
      else
      {
        v25 = -48;
      }
      v26 = 16 * (v25 + CharacterAtIndex);
      if ((v24 - 48) > 9)
      {
        if ((v24 - 97) > 5)
        {
          if ((v24 - 65) > 5)
            break;
          v27 = v24 + v26 - 55;
        }
        else
        {
          v27 = v24 + v26 - 87;
        }
      }
      else
      {
        v27 = v24 + v26 - 48;
      }
      v75 = v27;
      v11 = v71;
      if ((v27 & 0x80) != 0)
      {
        if ((v27 & 0x10) != 0)
          v30 = 4;
        else
          v30 = 3;
        if ((v27 & 0x20) != 0)
          v31 = v30;
        else
          v31 = 2;
        if (v71 < v73.location + (3 * v31))
          break;
        v68 = v21;
        v65 = v31;
        v66 = v22;
        v32 = v31;
        if (CFStringGetCharacterAtIndex(v7, v73.location + 3) == 37)
        {
          v33 = 0;
          v34 = 1;
          v35 = 4;
          do
          {
            v36 = CFStringGetCharacterAtIndex(v7, v35 + v73.location);
            v37 = CFStringGetCharacterAtIndex(v7, v35 + v73.location + 1);
            v76[v33] = 0;
            if ((v36 - 48) >= 0xA)
            {
              if ((v36 - 97) >= 6)
              {
                if ((v36 - 65) > 5)
                  break;
                v38 = -55;
              }
              else
              {
                v38 = -87;
              }
            }
            else
            {
              v38 = -48;
            }
            v39 = 16 * (v38 + v36);
            v76[v33] = v39;
            if ((v37 - 48) >= 0xA)
            {
              if ((v37 - 97) >= 6)
              {
                if ((v37 - 65) > 5)
                  break;
                v40 = -55;
              }
              else
              {
                v40 = -87;
              }
            }
            else
            {
              v40 = -48;
            }
            v76[v33] = v40 + v37 + v39;
            v34 = v33 + 2 < v32;
            if (v32 - 2 == v33)
              break;
            v41 = CFStringGetCharacterAtIndex(v7, v35 + v73.location + 2);
            v35 += 3;
            ++v33;
          }
          while (v41 == 37);
        }
        else
        {
          v34 = 1;
        }
        v8 = v64;
        v42 = CFStringCreateWithBytes(v64, &v75, v32, 0x8000100u, 0);
        v29 = v65;
        v22 = v66;
        v21 = v68;
        if (!v42)
          break;
        v28 = v42;
        v43 = CFStringGetLength(v42);
        if ((v27 & 0x30) == 0x20)
        {
          v21 = v68;
          if (!v43 && v75 == 239 && v76[0] == 187 && v76[1] == 191)
          {
            v72 = -257;
            if (!v68)
              v21 = CFStringCreateMutableWithExternalCharactersNoCopy(v8, &v72, 1, 1, v63);
            CFRelease(v28);
            v28 = (const __CFString *)CFRetain(v21);
          }
          if (v34)
          {
LABEL_79:
            if (v28)
              CFRelease(v28);
            break;
          }
        }
        else
        {
          v21 = v68;
          if (v34)
            goto LABEL_79;
        }
        v11 = v71;
      }
      else
      {
        v72 = v27;
        if (!v21)
          v21 = CFStringCreateMutableWithExternalCharactersNoCopy(v8, &v72, 1, 1, v63);
        v28 = (const __CFString *)CFRetain(v21);
        v29 = 1;
      }
      v44 = v73.location + (3 * v29);
      location = CFStringFind(v69, v28, 0).location;
      if (location == -1)
      {
        if (!v22)
        {
          location = (CFIndex)CFStringCreateMutable(v8, v11);
          v22 = (__CFString *)location;
        }
        v46 = v22;
        v47 = v73.location - v67;
        if (v73.location - v67 >= 1)
        {
          v70 = &v62;
          MEMORY[0x1E0C80A78](location, v67);
          v49 = v8;
          v50 = v21;
          v51 = (UniChar *)((char *)&v62 - ((v48 + 15) & 0xFFFFFFFFFFFFFFF0));
          v78.length = v47;
          CFStringGetCharacters(v7, v78, v51);
          v52 = v51;
          v21 = v50;
          v8 = v49;
          CFStringAppendCharacters(v46, v52, v47);
          v11 = v71;
        }
        CFStringAppend(v46, v28);
        v67 = v44;
        v22 = v46;
      }
      if (v28)
        CFRelease(v28);
      v81.length = v11 - v44;
      v81.location = v44;
      v53 = CFStringFindWithOptions(v7, CFSTR("%"), v81, 0, &v73);
      v20 = v53 == 0;
      if (!v53)
        goto LABEL_82;
    }
    v11 = v71;
    LOBYTE(v20) = (_BYTE)v70;
LABEL_82:
    if (v21)
      CFRelease(v21);
  }
  else
  {
    v22 = 0;
    v67 = 0;
  }
  if (v20)
  {
    if (!v22)
      return CFStringCreateCopy(v8, v7);
    v54.location = v67;
    if (v11 > v67)
    {
      v54.length = v11 - v67;
      v55 = CFStringCreateWithSubstring(v8, v7, v54);
      CFStringAppend(v22, v55);
      CFRelease(v55);
    }
    return v22;
  }
  if (v22)
  {
    CFRelease(v22);
    return 0;
  }
  return v22;
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return CFStringFindWithOptionsAndLocale(theString, stringToFind, rangeToSearch, searchOptions, 0, result);
}

CFStringRef _resolvedPath(char *__dst, unint64_t a2, int a3, int a4, int a5, CFAllocatorRef alloc)
{
  char *v8;
  unsigned __int16 *v11;
  char *v12;
  char *v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  char *i;
  char *v18;
  CFIndex v19;

  v8 = (char *)a2;
  if ((unint64_t)__dst >= a2)
    goto LABEL_40;
  v11 = (unsigned __int16 *)__dst;
  while (2)
  {
    v12 = (char *)(v11 + 1);
    v13 = (char *)(v11 + 2);
    v14 = (unint64_t)(v11 + 3);
    while (1)
    {
      if (*v11 != 46)
        goto LABEL_32;
      if (v12 == v8)
      {
        v8 = (char *)(v11 + 1);
        if (v11 != (unsigned __int16 *)__dst)
        {
          *v11 = 0;
          v8 = (char *)v11;
        }
        goto LABEL_40;
      }
      v15 = *(unsigned __int16 *)v12;
      if (v15 == a3)
      {
        if (v11 == (unsigned __int16 *)__dst && v13 == v8)
        {
          v8 = (char *)(v11 + 2);
          goto LABEL_40;
        }
        memmove(v11, v11 + 2, v8 - v13 + 2);
        v16 = -2;
        goto LABEL_19;
      }
      if (v8 - (char *)v11 < 3
        || v15 != 46
        || v13 != v8 && ((unint64_t)(v8 - (char *)v11) < 5 || *(unsigned __int16 *)v13 != a3))
      {
        goto LABEL_32;
      }
      if ((char *)v11 - __dst >= 3)
        break;
      if (!a4)
        goto LABEL_32;
      if (v14 >= (unint64_t)v8)
        goto LABEL_40;
      memmove(v11, v11 + 3, (unint64_t)&v8[-v14 + 2] & 0x1FFFFFFFELL);
      v16 = -3;
LABEL_19:
      v8 += 2 * v16;
      if (v11 >= (unsigned __int16 *)v8)
        goto LABEL_40;
    }
    for (i = (char *)(v11 - 2); i >= __dst && *(unsigned __int16 *)i != a3; i -= 2)
      ;
    v18 = i + 2;
    if (i + 2 == (char *)v11 || (char *)v11 - v18 == 6 && *(_WORD *)v18 == 46 && *((_WORD *)i + 2) == 46)
    {
LABEL_32:
      while (v11 < (unsigned __int16 *)v8 && *v11 != a3)
        ++v11;
      v18 = (char *)(v11 + 1);
      goto LABEL_35;
    }
    if (v13 == v8)
    {
      if (v18 == __dst)
      {
        *(_DWORD *)__dst = 3080238;
        *((_WORD *)__dst + 2) = 0;
        v8 = __dst + 6;
      }
      else
      {
        *(_WORD *)v18 = 0;
        v8 = i + 2;
      }
      break;
    }
    memmove(v18, v11 + 3, (unint64_t)&v8[-v14 + 2] & 0x1FFFFFFFELL);
    v8 = &v18[(_QWORD)v8 - v14];
LABEL_35:
    v11 = (unsigned __int16 *)v18;
    if (v18 < v8)
      continue;
    break;
  }
LABEL_40:
  if (a5 && v8 > __dst && v8 - 2 != __dst && *((unsigned __int16 *)v8 - 1) == a3)
    v8 -= 2;
  if (v8 >= __dst)
    v19 = (v8 - __dst) >> 1;
  else
    v19 = 0;
  return CFStringCreateWithCharactersNoCopy(alloc, (const UniChar *)__dst, v19, alloc);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  CFURLRef v1;

  v1 = anURL;
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
    v1 = (CFURLRef)-[__CFURL _cfurl](v1, "_cfurl");
  return _retainedComponentString((uint64_t)v1, 32, 0, 0);
}

CFStringRef URLPathToPOSIXPath(CFStringRef origString, CFAllocatorRef allocator, CFStringEncoding encoding, int a4)
{
  const __CFString *v6;
  const __CFString *v7;
  const __CFString *v8;
  CFIndex Length;
  CFIndex v10;
  CFStringRef v11;
  CFRange v13;

  if (a4)
    v6 = CFSTR("/");
  else
    v6 = &stru_1E1337B18;
  v7 = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(allocator, origString, v6, encoding);
  v8 = v7;
  if (!v7)
    return v8;
  Length = CFStringGetLength(v7);
  if (Length < 2)
    return v8;
  v10 = Length - 1;
  if (CFStringGetCharacterAtIndex(v8, Length - 1) != 47)
    return v8;
  v13.location = 0;
  v13.length = v10;
  v11 = CFStringCreateWithSubstring(allocator, v8, v13);
  CFRelease(v8);
  return v11;
}

CFStringRef CFURLCreateStringByReplacingPercentEscapesUsingEncoding(CFAllocatorRef allocator, CFStringRef origString, CFStringRef charsToLeaveEscaped, CFStringEncoding encoding)
{
  const __CFAllocator *v6;
  CFIndex Length;
  CFIndex v9;
  CFIndex v10;
  CFMutableStringRef Mutable;
  CFIndex v12;
  int v13;
  char *v14;
  uint64_t v15;
  CFIndex v16;
  CFIndex v17;
  uint64_t v18;
  void *v19;
  int CharacterAtIndex;
  int v21;
  char v22;
  char v23;
  char v24;
  int v25;
  CFStringRef v26;
  const __CFString *v27;
  CFRange v28;
  const __CFString *v29;
  CFIndex v30;
  CFMutableStringRef v31;
  CFIndex i;
  char v33;
  const __CFString *v34;
  CFRange v35;
  const __CFString *v36;
  CFIndex v37;
  const __CFAllocator *alloc;
  CFIndex range;
  const __CFString *range_8;
  const __CFString *cf;
  UniChar chars;
  CFRange result;
  char v45;
  uint64_t v46;
  CFRange v47;
  CFRange v48;

  v6 = allocator;
  v46 = *MEMORY[0x1E0C80C00];
  if (encoding == 134217984)
    return CFURLCreateStringByReplacingPercentEscapes(allocator, origString, charsToLeaveEscaped);
  result.location = 0;
  result.length = 0;
  if (!charsToLeaveEscaped)
  {
    if (origString)
      return CFStringCreateCopy(allocator, origString);
    return 0;
  }
  Length = CFStringGetLength(charsToLeaveEscaped);
  if (!origString)
    return 0;
  v9 = Length;
  v10 = CFStringGetLength(origString);
  v47.location = 0;
  v47.length = v10;
  if (CFStringFindWithOptions(origString, CFSTR("%"), v47, 0, &result))
  {
    v37 = v9;
    alloc = v6;
    range_8 = charsToLeaveEscaped;
    cf = 0;
    Mutable = 0;
    v12 = 0;
    v13 = 8;
    v14 = &v45;
LABEL_7:
    v15 = 0;
    range = v12;
    chars = 0;
    v16 = result.location + 3;
    v17 = -result.location;
    while (1)
    {
      v18 = v15;
      if (v10 + v17 < 3)
        break;
      v12 = v16;
      if (v15 == v13)
      {
        if (v14 == &v45)
        {
          v14 = (char *)malloc_type_malloc(0x10uLL, 0x100004077774924uLL);
          __memmove_chk();
          v13 = 16;
        }
        else
        {
          v19 = malloc_type_malloc(2 * v13, 0x100004077774924uLL);
          memmove(v19, v14, v13);
          free(v14);
          v13 *= 2;
          v14 = (char *)v19;
        }
      }
      chars = CFStringGetCharacterAtIndex(origString, v12 - 2);
      CharacterAtIndex = CFStringGetCharacterAtIndex(origString, v12 - 1);
      v21 = chars;
      v14[v18] = 0;
      if ((v21 - 48) >= 0xA)
      {
        if ((v21 - 97) >= 6)
        {
          if ((v21 - 65) > 5)
            break;
          v22 = -55;
        }
        else
        {
          v22 = -87;
        }
      }
      else
      {
        v22 = -48;
      }
      v23 = 16 * (v22 + v21);
      v14[v18] = v23;
      if ((CharacterAtIndex - 48) >= 0xA)
      {
        if ((CharacterAtIndex - 97) >= 6)
        {
          if ((CharacterAtIndex - 65) > 5)
            break;
          v24 = -55;
        }
        else
        {
          v24 = -87;
        }
      }
      else
      {
        v24 = -48;
      }
      v14[v18] = v24 + CharacterAtIndex + v23;
      if (v10 > v12)
      {
        v25 = CFStringGetCharacterAtIndex(origString, v12);
        v16 = v12 + 3;
        v17 -= 3;
        v15 = v18 + 1;
        if (v25 == 37)
          continue;
      }
      v6 = alloc;
      v26 = CFStringCreateWithBytes(alloc, (const UInt8 *)v14, (v18 + 1), encoding, 0);
      if (!v26)
        goto LABEL_48;
      v27 = v26;
      if (!Mutable)
        Mutable = CFStringCreateMutable(alloc, v10);
      v28.location = range;
      if (result.location - range >= 1)
      {
        v28.length = result.location - range;
        v29 = CFStringCreateWithSubstring(alloc, origString, v28);
        CFStringAppend(Mutable, v29);
        CFRelease(v29);
      }
      if (v37)
      {
        v30 = CFStringGetLength(v27);
        v31 = (CFMutableStringRef)cf;
        if (!cf)
          v31 = CFStringCreateMutableWithExternalCharactersNoCopy(alloc, &chars, 1, 1, (CFAllocatorRef)&__kCFAllocatorNull);
        cf = v31;
        if (v30 >= 1)
        {
          for (i = 0; i != v30; ++i)
          {
            chars = CFStringGetCharacterAtIndex(v27, i);
            if (CFStringFind(range_8, cf, 0).location == -1)
              CFStringAppendCharacters(Mutable, &chars, 1);
            else
              _appendPercentEscapesForCharacter(&chars, 0, encoding, Mutable);
          }
        }
      }
      else
      {
        CFStringAppend(Mutable, v27);
      }
      CFRelease(v27);
      v48.location = v12;
      v48.length = v10 - v12;
      if (!CFStringFindWithOptions(origString, CFSTR("%"), v48, 0, &result))
      {
        v33 = 1;
        range = v12;
        v6 = alloc;
        v34 = cf;
        goto LABEL_49;
      }
      goto LABEL_7;
    }
    v6 = alloc;
LABEL_48:
    v34 = cf;
    v33 = 0;
LABEL_49:
    if (v34)
      CFRelease(v34);
    if (v14 != &v45)
      free(v14);
    if ((v33 & 1) != 0)
    {
      if (Mutable)
      {
        v35.location = range;
        if (v10 > range)
        {
          v35.length = v10 - range;
          v36 = CFStringCreateWithSubstring(v6, origString, v35);
          CFStringAppend(Mutable, v36);
          CFRelease(v36);
        }
        return Mutable;
      }
      return CFStringCreateCopy(v6, origString);
    }
    if (!Mutable)
      return Mutable;
    CFRelease(Mutable);
    return 0;
  }
  return CFStringCreateCopy(v6, origString);
}

uint64_t _CFGetSlash()
{
  return 47;
}

CFMutableStringRef CFStringCreateMutableWithExternalCharactersNoCopy(CFAllocatorRef alloc, UniChar *chars, CFIndex numChars, CFIndex capacity, CFAllocatorRef externalCharactersAllocator)
{
  __objc2_class **v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t Instance;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  unint64_t *v25;
  char v26;
  BOOL v27;
  uint64_t v28;
  char v29;
  char v30;

  v9 = (__objc2_class **)alloc;
  if (&__kCFAllocatorNull == (__objc2_class **)externalCharactersAllocator)
    v10 = 2;
  else
    v10 = 3;
  if (externalCharactersAllocator)
    v11 = v10;
  else
    v11 = 1;
  if (!alloc)
  {
    v12 = _CFGetTSD(1u);
    if (v12)
      v9 = (__objc2_class **)v12;
    else
      v9 = &__kCFAllocatorSystemDefault;
  }
  if (v11 == 3)
    v13 = 40;
  else
    v13 = 32;
  Instance = _CFRuntimeCreateInstance(v9, 7uLL, v13, 0);
  if (Instance)
  {
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
    v15 = (unint64_t *)(Instance + 8);
    v16 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      v17 = __ldaxr(v15);
      if (v17 != v16)
        break;
      if (__stlxr(v16 & 0xFFFFFFFFFFFFFF9FLL | (32 * v11), v15))
        goto LABEL_22;
      v18 = 1;
LABEL_23:
      v16 = v17;
      if (v18)
      {
        v19 = atomic_load(v15);
        while (1)
        {
          v20 = __ldaxr(v15);
          if (v20 != v19)
            break;
          if (__stlxr(v19 | 0x10, v15))
            goto LABEL_29;
          v21 = 1;
LABEL_30:
          v19 = v20;
          if (v21)
          {
            v22 = atomic_load(v15);
            while (1)
            {
              v23 = __ldaxr(v15);
              if (v23 != v22)
                break;
              if (__stlxr(v22 | 1, v15))
                goto LABEL_36;
              v24 = 1;
LABEL_37:
              v22 = v23;
              if (v24)
              {
                *(_QWORD *)(Instance + 16) = 0;
                v25 = (unint64_t *)(Instance + 8);
                v26 = atomic_load((unint64_t *)(Instance + 8));
                v27 = (v26 & 0x60) == 0;
                v28 = 24;
                if (v27)
                  v28 = 16;
                *(_QWORD *)(Instance + v28) = 0;
                *(_OWORD *)(Instance + 32) = xmmword_182C98E30;
                v29 = atomic_load(v25);
                if ((~v29 & 0x60) == 0)
                {
                  CFRetain(v9);
                  *(_QWORD *)(Instance + 48) = v9;
                }
                *(_QWORD *)(Instance + 40) |= 4uLL;
                v30 = atomic_load(v25);
                if ((~v30 & 0x60) == 0)
                {
                  CFRelease(*(CFTypeRef *)(Instance + 48));
                  CFRetain(externalCharactersAllocator);
                  *(_QWORD *)(Instance + 48) = externalCharactersAllocator;
                }
                CFStringSetExternalCharactersNoCopy((CFMutableStringRef)Instance, chars, numChars, capacity);
                return (CFMutableStringRef)Instance;
              }
            }
            __clrex();
LABEL_36:
            v24 = 0;
            goto LABEL_37;
          }
        }
        __clrex();
LABEL_29:
        v21 = 0;
        goto LABEL_30;
      }
    }
    __clrex();
LABEL_22:
    v18 = 0;
    goto LABEL_23;
  }
  return (CFMutableStringRef)Instance;
}

void CFStringSetExternalCharactersNoCopy(CFMutableStringRef theString, UniChar *chars, CFIndex length, CFIndex capacity)
{
  char v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;

  v4 = atomic_load((unint64_t *)&theString->info);
  if ((v4 & 1) != 0)
  {
    theString->data = (char *)chars;
    v13 = atomic_load((unint64_t *)&theString->info);
    v14 = (v13 & 0x60) == 0;
    v15 = 24;
    if (v14)
      v15 = 16;
    *(void **)((char *)&theString->isa + v15) = (void *)length;
    v16 = theString[1].info | 8;
    theString[1].isa = (void *)(2 * capacity);
    theString[1].info = v16;
  }
  else
  {
    v5 = _CFOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      CFStringSetExternalCharactersNoCopy_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
  }
}

CFStringRef FileReferenceURLPathToFullURLPath(const __CFString *a1, const __CFAllocator *a2)
{
  CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes;
  const char *v6;
  const __CFString *v7;
  const __CFString *v8;
  unint64_t Length;
  CFIndex MaximumSizeForEncoding;
  CFIndex v11;
  char *v12;
  size_t v13;
  CFStringRef v14;
  CFStringRef v15;
  CFStringRef v16;
  char *__endptr;
  char buffer[8];
  __int16 v19;
  char v20[2038];
  char v21[1024];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!CFStringGetCString(a1, buffer, 2048, 0x8000100u))
    return 0;
  if (*(_QWORD *)buffer != 0x692F656C69662E2FLL || v19 != 15716)
    return 0;
  __endptr = 0;
  strtoll(v20, &__endptr, 10);
  StringFromFileSystemRepresentationByAddingPercentEscapes = 0;
  if (*__endptr != 46)
    return StringFromFileSystemRepresentationByAddingPercentEscapes;
  strtoll(__endptr + 1, &__endptr, 10);
  v6 = *__endptr == 47 ? __endptr + 1 : __endptr;
  v7 = (const __CFString *)_FSCreatePathForFileID();
  if (!v7)
    return 0;
  v8 = v7;
  Length = CFStringGetLength(v7);
  if (Length <= 1)
    Length = 1;
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  v11 = MaximumSizeForEncoding + 1;
  if (MaximumSizeForEncoding >= 1024)
    v12 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xBB047E6uLL);
  else
    v12 = v21;
  if (CFStringGetCString(v8, v12, v11, 0x8000100u))
  {
    v13 = strlen(v12);
    StringFromFileSystemRepresentationByAddingPercentEscapes = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(0, v12, v13, 0, 0, 0, 0);
  }
  else
  {
    StringFromFileSystemRepresentationByAddingPercentEscapes = 0;
  }
  if (v12 != v21)
    free(v12);
  CFRelease(v8);
  if (*v6)
  {
    v14 = CFStringCreateWithCString(a2, v6, 0x8000100u);
    if (v14)
    {
      v15 = v14;
      v16 = CFStringCreateWithFormat(a2, 0, CFSTR("%@/%@"), StringFromFileSystemRepresentationByAddingPercentEscapes, v14);
      CFRelease(v15);
    }
    else
    {
      v16 = 0;
    }
    CFRelease(StringFromFileSystemRepresentationByAddingPercentEscapes);
    return v16;
  }
  return StringFromFileSystemRepresentationByAddingPercentEscapes;
}

uint64_t __CFNumberHash(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  double v9;
  long double v10;
  double v11;
  double v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  double v16[2];

  v16[1] = *(double *)MEMORY[0x1E0C80C00];
  if ((a1 & 0x8000000000000000) == 0)
    goto LABEL_12;
  v1 = 0;
  v2 = *MEMORY[0x1E0DE7C58];
  if ((~a1 & 0xC000000000000007) == 0)
    v2 = 0;
  v3 = v2 ^ a1;
  v4 = v3 & 7;
  while (v4 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v1))
  {
    if (++v1 == 7)
      goto LABEL_12;
  }
  if (v1 == 3)
  {
    v5 = 0xFFFFFFFFFFFFFFFLL;
    if (v4 == 7)
      v5 = 0xFFFFFFFFFFFFFLL;
    v6 = v5 & (v3 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v6) = atomic_load((unint64_t *)(a1 + 8));
  }
  if ((unint64_t)(__CFNumberCanonicalTypes[v6 & 7] - 1) > 2)
  {
    v16[0] = 0.0;
    __CFNumberGetValue(a1, 6, (uint64_t)v16);
    v9 = -v16[0];
    if (v16[0] >= 0.0)
      v9 = v16[0];
    v10 = floor(v9 + 0.5);
    v11 = (v9 - v10) * 1.84467441e19;
    v12 = fmod(v10, 1.84467441e19);
    v13 = 2654435761u * (unint64_t)v12;
    v14 = v13 + (unint64_t)v11;
    if (v11 <= 0.0)
      v14 = 2654435761u * (unint64_t)v12;
    v15 = v13 - (unint64_t)fabs(v11);
    if (v11 < 0.0)
      return v15;
    else
      return v14;
  }
  else
  {
    LODWORD(v16[0]) = 0;
    __CFNumberGetValue(a1, 3, (uint64_t)v16);
    v7 = LODWORD(v16[0]);
    if (SLODWORD(v16[0]) < 0)
      v7 = -LODWORD(v16[0]);
    return 2654435761 * v7;
  }
}

uint64_t __CFNumberGetValue(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  double v20;
  double v21;
  unint64_t v22;
  BOOL v23;
  double v24;
  double v25;
  unint64_t v26;
  BOOL v27;
  double v28;
  double v29;
  BOOL v30;
  double v31;
  double v32;
  uint64_t v33;
  BOOL v34;
  double v35;
  double v36;
  float v37;
  float v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  unint64_t v45;
  uint64_t v46;
  double v47;
  double v48;
  unint64_t v49;
  uint64_t v50;
  double v51;
  float v52;
  float v53;
  float v54;
  float v55;
  float v56;
  float v57;
  unsigned int v58;
  float v59;
  float v60;
  unint64_t v61;
  float v62;
  double v63;
  double v64;
  float v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  int64_t v70;
  _QWORD v75[2];

  v75[1] = *MEMORY[0x1E0C80C00];
  if ((result & 0x8000000000000000) == 0)
    goto LABEL_12;
  v3 = 0;
  v4 = *MEMORY[0x1E0DE7C58];
  if ((~result & 0xC000000000000007) == 0)
    v4 = 0;
  v5 = v4 ^ result;
  v6 = v5 & 7;
  while (v6 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v3))
  {
    if (++v3 == 7)
      goto LABEL_12;
  }
  if (v3 == 3)
  {
    v7 = 0xFFFFFFFFFFFFFFFLL;
    if (v6 == 7)
      v7 = 0xFFFFFFFFFFFFFLL;
    v8 = v7 & (v5 >> 3);
  }
  else
  {
LABEL_12:
    LOBYTE(v8) = atomic_load((unint64_t *)(result + 8));
  }
  v9 = (unsigned __int16)__CFNumberTypeTable[__CFNumberCanonicalTypes[v8 & 7]];
  v10 = __CFNumberTypeTable[a2] & 0x1FLL;
  v11 = result + 16;
  v12 = (v9 >> 5) & 1;
  v13 = (v9 >> 6) & 1;
  v75[0] = 0;
  if (result < 0)
  {
    v14 = 0;
    v15 = *MEMORY[0x1E0DE7C58];
    if ((~result & 0xC000000000000007) == 0)
      v15 = 0;
    v16 = v15 ^ result;
    v17 = v16 & 7;
    while (v17 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v14))
    {
      if (++v14 == 7)
        goto LABEL_26;
    }
    if (v14 == 3)
    {
      v13 = 0;
      v12 = 0;
      v18 = v16 << 9 >> 12;
      if (v17 != 7)
        v18 = (2 * v16) >> 4;
      v19 = 6;
      if ((v16 & 0x40) == 0)
        v19 = 4;
      v75[0] = v18 >> v19;
      v11 = (unint64_t)v75;
    }
  }
LABEL_26:
  switch(v10)
  {
    case 1:
      if (v12)
      {
        if (v13)
        {
          v20 = *(double *)v11;
          v21 = 127.0;
          if (*(double *)v11 <= 127.0)
            v21 = *(double *)v11;
          LODWORD(v22) = (int)v21;
          v23 = v20 < -128.0;
        }
        else
        {
          v52 = *(float *)v11;
          v53 = 127.0;
          if (*(float *)v11 <= 127.0)
            v53 = *(float *)v11;
          LODWORD(v22) = (int)v53;
          v23 = v52 < -128.0;
        }
        if (v23)
          LOBYTE(v22) = 0x80;
LABEL_108:
        *(_BYTE *)a3 = v22;
        return result;
      }
      v40 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v40 > 0 || (v22 = *(_QWORD *)(v11 + 8), v40 == 0.0) && v22 > 0x7F)
        {
          LOBYTE(v22) = 127;
        }
        else
        {
          if (v22 < 0xFFFFFFFFFFFFFF80 && *(_QWORD *)&v40 == -1)
            LOBYTE(v22) = 0x80;
          if (*(uint64_t *)&v40 < -1)
            LOBYTE(v22) = 0x80;
        }
        goto LABEL_108;
      }
      v68 = 127;
      if (*(uint64_t *)&v40 < 127)
        v68 = *(_QWORD *)&v40;
      if (v68 <= -128)
        LOBYTE(v68) = 0x80;
      *(_BYTE *)a3 = v68;
      return result;
    case 2:
      if (v12)
      {
        if (v13)
        {
          v24 = *(double *)v11;
          v25 = 32767.0;
          if (*(double *)v11 <= 32767.0)
            v25 = *(double *)v11;
          LODWORD(v26) = (int)v25;
          v27 = v24 < -32768.0;
        }
        else
        {
          v54 = *(float *)v11;
          v55 = 32767.0;
          if (*(float *)v11 <= 32767.0)
            v55 = *(float *)v11;
          LODWORD(v26) = (int)v55;
          v27 = v54 < -32768.0;
        }
        if (v27)
          LOWORD(v26) = 0x8000;
LABEL_114:
        *(_WORD *)a3 = v26;
        return result;
      }
      v41 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v41 > 0 || (v26 = *(_QWORD *)(v11 + 8), v41 == 0.0) && v26 >> 15)
        {
          LOWORD(v26) = 0x7FFF;
        }
        else
        {
          if (v26 < 0xFFFFFFFFFFFF8000 && *(_QWORD *)&v41 == -1)
            LOWORD(v26) = 0x8000;
          if (*(uint64_t *)&v41 < -1)
            LOWORD(v26) = 0x8000;
        }
        goto LABEL_114;
      }
      v69 = 0x7FFFLL;
      if (*(uint64_t *)&v41 < 0x7FFF)
        v69 = *(_QWORD *)&v41;
      if (v69 <= -32768)
        LOWORD(v69) = 0x8000;
      *(_WORD *)a3 = v69;
      return result;
    case 3:
      if (v12)
      {
        if (v13)
        {
          v28 = *(double *)v11;
          v29 = 2147483650.0;
          if (*(double *)v11 <= 2147483650.0)
            v29 = *(double *)v11;
          LODWORD(v11) = (int)v29;
          v30 = v28 < -2147483650.0;
        }
        else
        {
          v56 = *(float *)v11;
          v57 = 2147500000.0;
          if (*(float *)v11 <= 2147500000.0)
            v57 = *(float *)v11;
          LODWORD(v11) = (int)v57;
          v30 = v56 < -2147500000.0;
        }
        v58 = 0x80000000;
        goto LABEL_119;
      }
      v42 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v42 > 0 || (v11 = *(_QWORD *)(v11 + 8), v42 == 0.0) && v11 >> 31)
        {
          LODWORD(v11) = 0x7FFFFFFF;
        }
        else
        {
          if (v11 < 0xFFFFFFFF80000000 && *(_QWORD *)&v42 == -1)
            LODWORD(v11) = 0x80000000;
          if (*(uint64_t *)&v42 < -1)
            LODWORD(v11) = 0x80000000;
        }
        goto LABEL_130;
      }
      v70 = 0x7FFFFFFFLL;
      if (*(uint64_t *)&v42 < 0x7FFFFFFF)
        v70 = *(_QWORD *)&v42;
      if (v70 <= (uint64_t)0xFFFFFFFF80000000)
        LODWORD(v70) = 0x80000000;
      *(_DWORD *)a3 = v70;
      return result;
    case 4:
      if (v12)
      {
        if (v13)
        {
          v31 = *(double *)v11;
          v32 = 9.22337204e18;
          if (*(double *)v11 <= 9.22337204e18)
            v32 = *(double *)v11;
          v33 = (uint64_t)v32;
          v34 = v31 < -9.22337204e18;
        }
        else
        {
          v59 = *(float *)v11;
          v60 = 9.2234e18;
          if (*(float *)v11 <= 9.2234e18)
            v60 = *(float *)v11;
          v33 = (uint64_t)v60;
          v34 = v59 < -9.2234e18;
        }
        v61 = 0x8000000000000000;
        goto LABEL_126;
      }
      v43 = *(double *)v11;
      if (v13)
      {
        if (*(uint64_t *)&v43 > 0 || (v33 = *(_QWORD *)(v11 + 8), v43 == 0.0) && v33 < 0)
        {
          v33 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else
        {
          if (v33 > -1 && *(_QWORD *)&v43 == -1)
            v33 = 0x8000000000000000;
          if (*(uint64_t *)&v43 < -1)
            v33 = 0x8000000000000000;
        }
        goto LABEL_128;
      }
      *(double *)a3 = v43;
      return result;
    case 5:
      if (v12)
      {
        if (v13)
        {
          v35 = *(double *)v11;
          if (fabs(*(double *)v11) != INFINITY)
          {
            v36 = 3.40282347e38;
            if (v35 <= 3.40282347e38)
              v36 = *(double *)v11;
            v37 = v36;
            v23 = v35 < -3.40282347e38;
            v38 = -3.4028e38;
            if (!v23)
              v38 = v37;
LABEL_158:
            *(float *)a3 = v38;
            return result;
          }
          v30 = v35 < 0.0;
          LODWORD(v11) = 2139095040;
          v58 = -8388608;
LABEL_119:
          if (v30)
            LODWORD(v11) = v58;
        }
        else
        {
          LODWORD(v11) = *(_DWORD *)v11;
        }
LABEL_130:
        *(_DWORD *)a3 = v11;
        return result;
      }
      v44 = *(double *)v11;
      if (v13)
      {
        v45 = *(_QWORD *)(v11 + 8);
        v46 = -*(_QWORD *)&v44;
        if (v45)
          v46 = ~*(_QWORD *)&v44;
        if (v44 < 0.0)
          v45 = -(uint64_t)v45;
        else
          v46 = *(_QWORD *)&v44;
        v47 = -((double)v45 + (double)v46 * 1.84467441e19);
        if (v44 >= 0.0)
          v47 = (double)v45 + (double)v46 * 1.84467441e19;
        v38 = v47;
      }
      else
      {
        v38 = (float)*(uint64_t *)&v44;
        if ((float)*(uint64_t *)&v44 > 3.4028e38)
          v38 = 3.4028e38;
      }
      goto LABEL_158;
    case 6:
      if (v12)
      {
        if (v13)
        {
          v33 = *(_QWORD *)v11;
LABEL_128:
          *(_QWORD *)a3 = v33;
          return result;
        }
        v62 = *(float *)v11;
        if (fabsf(*(float *)v11) == INFINITY)
        {
          v34 = v62 < 0.0;
          v33 = 0x7FF0000000000000;
          v61 = 0xFFF0000000000000;
LABEL_126:
          if (v34)
            v33 = v61;
          goto LABEL_128;
        }
        v63 = v62;
        v64 = 1.79769313e308;
        if (v63 <= 1.79769313e308)
          v64 = v63;
        if (v63 >= -1.79769313e308)
          v51 = v64;
        else
          v51 = -1.79769313e308;
      }
      else
      {
        v48 = *(double *)v11;
        if (v13)
        {
          v49 = *(_QWORD *)(v11 + 8);
          v50 = -*(_QWORD *)&v48;
          if (v49)
            v50 = ~*(_QWORD *)&v48;
          if (v48 < 0.0)
            v49 = -(uint64_t)v49;
          else
            v50 = *(_QWORD *)&v48;
          v51 = -((double)v49 + (double)v50 * 1.84467441e19);
          if (v48 >= 0.0)
            v51 = (double)v49 + (double)v50 * 1.84467441e19;
        }
        else
        {
          v51 = (double)*(uint64_t *)&v48;
          if ((double)*(uint64_t *)&v48 > 1.79769313e308)
            v51 = 1.79769313e308;
        }
      }
      *(double *)a3 = v51;
      return result;
    case 17:
      if (!v12)
      {
        if (v13)
        {
          *(_OWORD *)a3 = *(_OWORD *)v11;
          return result;
        }
        v66 = *(_QWORD *)v11;
        v67 = v66 >> 63;
        goto LABEL_167;
      }
      if (v13)
      {
        v39 = *(double *)v11;
        if (*(double *)v11 >= -1.70141183e38)
        {
          if (v39 >= 1.70141183e38)
            goto LABEL_166;
          goto LABEL_165;
        }
LABEL_138:
        v66 = 0;
        v67 = 0x8000000000000000;
        goto LABEL_167;
      }
      v65 = *(float *)v11;
      if (*(float *)v11 < -1.7014e38)
        goto LABEL_138;
      if (v65 >= 1.7014e38)
      {
LABEL_166:
        v66 = -1;
        v67 = 0x7FFFFFFFFFFFFFFFLL;
        goto LABEL_167;
      }
      v39 = v65;
LABEL_165:
      v67 = vcvtmd_s64_f64(v39 * 5.42101086e-20);
      v66 = (unint64_t)(v39 + floor(v39 * 5.42101086e-20) * -1.84467441e19);
LABEL_167:
      *(_QWORD *)a3 = v67;
      *(_QWORD *)(a3 + 8) = v66;
      return result;
    default:
      return result;
  }
}

CFStringRef CFCopyDescription(CFStringRef cf)
{
  __CFString *v1;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  __CFString *(*v12)(unint64_t *);
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _UNKNOWN **v16;
  _QWORD *v17;
  uint64_t (*v18)(__CFString *);
  uint64_t v19;
  CFAllocatorRef v20;
  uint64_t v21;
  uint64_t i;
  int v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  int v30;

  if (cf)
  {
    v1 = (__CFString *)cf;
    if (((unint64_t)cf & 0x8000000000000000) != 0)
    {
      v2 = 0;
      v3 = (uint64_t *)MEMORY[0x1E0DE7C58];
      v4 = *MEMORY[0x1E0DE7C58];
      v5 = (unint64_t)cf & 0xC000000000000007;
      if (((unint64_t)cf & 0xC000000000000007) == 0xC000000000000007)
        v4 = 0;
      v6 = v4 ^ (unint64_t)cf;
      v7 = v6 & 7;
      v8 = MEMORY[0x1E0DE7C48];
      do
      {
        if (v7 == *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v2))
          break;
        ++v2;
      }
      while (v2 != 7);
      v9 = v2 | v6;
      v10 = v2 & 7;
      v11 = (v9 >> 55) + 8;
      if (v10 == 7)
        LODWORD(v10) = v11;
      if ((_DWORD)v10)
      {
        if ((_DWORD)v10 == 6)
        {
          v12 = (__CFString *(*)(unint64_t *))__CFDateCopyDescription;
          return v12((unint64_t *)cf);
        }
        if ((_DWORD)v10 == 3)
        {
          v12 = __CFNumberCopyDescription;
          return v12((unint64_t *)cf);
        }
      }
      else
      {
        if ((dyld_program_sdk_at_least() & 1) != 0)
          CFCopyDescription_cold_3();
        v21 = *v3;
        if (v5 == 0xC000000000000007)
          v21 = 0;
        v6 = v21 ^ (unint64_t)v1;
        v7 = v6 & 7;
      }
      for (i = 0; i != 7; ++i)
      {
        if (v7 == *(unsigned __int8 *)(v8 + i))
          break;
      }
      v23 = ((i | v6) >> 55) + 8;
      if ((i & 7) != 7)
        v23 = i & 7;
      v24 = 22;
      switch(v23)
      {
        case 0:
          if (dyld_program_sdk_at_least())
            CFCopyDescription_cold_2();
          goto LABEL_42;
        case 1:
          goto LABEL_43;
        case 2:
          goto LABEL_41;
        case 3:
          goto LABEL_45;
        case 4:
        case 5:
          goto LABEL_42;
        case 6:
          v24 = 42;
          goto LABEL_45;
        default:
          if (v23 == 20)
          {
LABEL_42:
            v24 = 1;
          }
          else if (v23 == 22)
          {
LABEL_41:
            v24 = 7;
          }
          else
          {
LABEL_43:
            v24 = -[__CFString _cfTypeID](v1, "_cfTypeID");
          }
LABEL_45:
          if (CF_IS_OBJC(v24, (__objc2_class **)v1))
            return (CFStringRef)-[__CFString _copyDescription](v1, "_copyDescription");
          v25 = 0;
          v26 = *v3;
          if (v5 == 0xC000000000000007)
            v26 = 0;
          v27 = v26 ^ (unint64_t)v1;
          do
          {
            if ((v27 & 7) == *(_BYTE *)(v8 + v25))
              break;
            ++v25;
          }
          while (v25 != 7);
          v28 = v25 | v27;
          v29 = v25 & 7;
          v30 = (v28 >> 55) + 8;
          if (v29 == 7)
            LODWORD(v29) = v30;
          v15 = 22;
          switch((int)v29)
          {
            case 0:
              if (dyld_program_sdk_at_least())
                CFCopyDescription_cold_1();
              goto LABEL_59;
            case 1:
              goto LABEL_60;
            case 2:
              goto LABEL_58;
            case 3:
              goto LABEL_18;
            case 4:
            case 5:
              goto LABEL_59;
            case 6:
              v15 = 42;
              goto LABEL_18;
            default:
              if ((_DWORD)v29 == 20)
              {
LABEL_59:
                v15 = 1;
                goto LABEL_18;
              }
              if ((_DWORD)v29 == 22)
              {
LABEL_58:
                v15 = 7;
                goto LABEL_18;
              }
LABEL_60:
              v15 = -[__CFString _cfTypeID](v1, "_cfTypeID");
              break;
          }
          break;
      }
    }
    else
    {
      v13 = atomic_load((unint64_t *)&cf->info);
      if (CF_IS_OBJC((v13 >> 8) & 0x3FF, (__objc2_class **)cf))
        return (CFStringRef)-[__CFString _copyDescription](v1, "_copyDescription");
      v14 = atomic_load((unint64_t *)&v1->info);
      v15 = (v14 >> 8) & 0x3FF;
    }
    if (v15 > 0x47)
      v16 = (_UNKNOWN **)(__CFRuntimeClassTables[((int)v15 - 72) >> 6] + 8 * (((_DWORD)v15 - 72) & 0x3F));
    else
LABEL_18:
      v16 = &__CFRuntimeBuiltinClassTable + v15;
    v17 = *v16;
    v18 = (uint64_t (*)(__CFString *))*((_QWORD *)*v16 + 8);
    if (!v18 || (cf = (CFStringRef)v18(v1)) == 0)
    {
      v19 = v17[1];
      v20 = CFGetAllocator(v1);
      return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<%s %p [%p]>"), v19, v1, v20);
    }
  }
  return cf;
}

void sub_182AD2920(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182AD3054(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)(v3 - 272) = v2;
  *(_QWORD *)(v3 - 264) = v1;
  free(*(void **)(v3 - 272));
  free(*(void **)(v3 - 264));
  _Unwind_Resume(a1);
}

uint64_t _NSIsNSData(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*MethodImplementation)(uint64_t, char *);

  if (a1)
  {
    v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
      return MethodImplementation(v1, sel_isNSData__);
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }
  return a1 & 1;
}

void sub_182AD3C68(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

CFStringRef __CFStringCopyDescription(uint64_t a1)
{
  const CFAllocatorRef *v1;
  char v2;

  v1 = &kCFAllocatorSystemDefault;
  if ((a1 & 0x8000000000000000) == 0)
  {
    v2 = atomic_load((unint64_t *)(a1 + 8));
    if (v2 < 0)
      v1 = &kCFAllocatorSystemDefault;
    else
      v1 = (const CFAllocatorRef *)(a1 - 16);
  }
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFString %p [%p]>{contents = \"%@\"}"), a1, *v1, a1);
}

uint64_t _NSIsNSDate(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  char isKindOfClass;
  uint64_t (*MethodImplementation)(uint64_t, char *);

  if (a1 < 0)
  {
    v2 = 0;
    v3 = *MEMORY[0x1E0DE7C58];
    if ((~a1 & 0xC000000000000007) == 0)
      LOBYTE(v3) = 0;
    v4 = (v3 ^ a1) & 7;
    do
    {
      if (v4 == *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v2))
        break;
      ++v2;
    }
    while (v2 != 7);
    isKindOfClass = (v2 & 7) == 6;
  }
  else if (a1)
  {
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
      return MethodImplementation(a1, sel_isNSDate__);
    objc_opt_class();
    isKindOfClass = objc_opt_isKindOfClass();
  }
  else
  {
    isKindOfClass = 0;
  }
  return isKindOfClass & 1;
}

CFStringRef __CFBundleCopyDescription(uint64_t a1)
{
  const __CFURL *v2;
  CFStringRef v3;
  unsigned int v4;
  const __CFString *v5;
  const __CFString *v6;
  CFStringRef v7;
  CFStringRef v8;
  UInt8 buffer[1026];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = *(const __CFURL **)(a1 + 16);
  if (v2 && CFURLGetFileSystemRepresentation(v2, 1u, buffer, 1026))
    v3 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const char *)buffer);
  else
    v3 = 0;
  v4 = *(_DWORD *)(a1 + 48) - 2;
  v5 = &stru_1E1337B18;
  v6 = &stru_1E1337B18;
  if (v4 <= 3)
    v6 = off_1E12E11A0[v4];
  if (!*(_BYTE *)(a1 + 52))
    v5 = CFSTR("not ");
  if (*(_BYTE *)(a1 + 72))
    v7 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("CFBundle/CFPlugIn %p <%@> (%@%@loaded)"), a1, v3, v6, v5);
  else
    v7 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("CFBundle %p <%@> (%@%@loaded)"), a1, v3, v6, v5);
  v8 = v7;
  if (v3)
    CFRelease(v3);
  return v8;
}

CFStringRef __CFBasicHashCopyDescription(const void *a1)
{
  __CFString *v2;
  CFAllocatorRef v3;
  CFStringRef v4;

  v2 = CFBasicHashCopyDescription((uint64_t)a1, 0, (uint64_t)&stru_1E1337B18, (uint64_t)CFSTR("\t"), 1);
  v3 = CFGetAllocator(a1);
  v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFBasicHash %p [%p]>%@"), a1, v3, v2);
  CFRelease(v2);
  return v4;
}

__CFString *CFBasicHashCopyDescription(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5)
{
  __CFString *Mutable;
  char v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  const char *v15;
  uint64_t Count;
  unsigned int v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t Size;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  _QWORD v30[7];
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  v11 = atomic_load((unint64_t *)(a1 + 8));
  if ((v11 & 0x40) != 0)
    v12 = "immutable";
  else
    v12 = "mutable";
  v13 = *(_WORD *)(a1 + 18);
  if ((v13 & 0x18) != 0)
    v14 = "multi";
  else
    v14 = "";
  if ((v13 & 4) != 0)
    v15 = "dict";
  else
    v15 = "set";
  Count = CFBasicHashGetCount(a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("%@{type = %s %s%s, count = %ld,\n"), a3, v12, v14, v15, Count);
  if (a2)
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("%@hash cache = %s, strong values = %s, strong keys = %s, cb = %s,\n"), a3, "no", "no", "no", "custom");
    CFStringAppendFormat(Mutable, 0, CFSTR("%@num bucket index = %d, num buckets = %ld, capacity = %ld, num buckets used = %u,\n"), a3, BYTE2(*(_QWORD *)(a1 + 24)), __CFBasicHashTableSizes[BYTE2(*(_QWORD *)(a1 + 24))], __CFBasicHashTableCapacities[BYTE2(*(_QWORD *)(a1 + 24))], *(unsigned int *)(a1 + 20));
    v17 = *(unsigned __int16 *)(a1 + 18);
    if ((v17 & 0x18) != 0)
      v18 = (1 << ((v17 >> 5) & 3));
    else
      v18 = 0;
    if ((*(_QWORD *)(a1 + 32) & 8) != 0)
      v19 = "yes";
    else
      v19 = "no";
    CFStringAppendFormat(Mutable, 0, CFSTR("%@counts width = %d, finalized = %s,\n"), a3, v18, v19);
    v20 = *(unsigned __int16 *)(a1 + 16);
    v21 = *(unsigned __int16 *)(a1 + 24);
    v22 = *(_WORD *)(a1 + 18);
    v23 = 56;
    if ((v22 & 4) == 0)
      v23 = 48;
    if ((v22 & 0x18) != 0)
      v24 = v23 + 8;
    else
      v24 = v23;
    Size = CFBasicHashGetSize(a1, 1);
    CFStringAppendFormat(Mutable, 0, CFSTR("%@num mutations = %ld, num deleted = %ld, size = %ld, total size = %ld,\n"), a3, v20, v21, v24, Size);
    v26 = 0;
    v27 = *(unsigned __int16 *)(a1 + 18);
    if ((v27 & 4) != 0)
      v26 = *(_QWORD *)(a1 + 8 * ((v27 >> 2) & 1) + 40);
    if ((v27 & 0x18) != 0)
      v28 = *(_QWORD *)(a1 + (v27 & 0x18) + 40);
    else
      v28 = 0;
    CFStringAppendFormat(Mutable, 0, CFSTR("%@values ptr = %p, keys ptr = %p, counts ptr = %p, hashes ptr = %p,\n"), a3, *(_QWORD *)(a1 + 40), v26, v28, 0);
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("%@entries =>\n"), a3);
  v30[0] = MEMORY[0x1E0C809B0];
  v30[1] = 3221225472;
  v30[2] = __CFBasicHashCopyDescription_block_invoke;
  v30[3] = &__block_descriptor_57_e15_C40__0___qQQQ_8l;
  v31 = a5;
  v30[4] = a1;
  v30[5] = Mutable;
  v30[6] = a4;
  CFBasicHashApply(a1, (uint64_t)v30);
  CFStringAppendFormat(Mutable, 0, CFSTR("%@}\n"), a3);
  return Mutable;
}

__CFString *__CFDataCopyDescription(unint64_t *cf)
{
  uint64_t v2;
  char v3;
  unsigned __int8 *v4;
  const __CFAllocator *v5;
  __CFString *Mutable;
  CFAllocatorRef v7;
  unint64_t v8;
  BOOL v9;
  uint64_t v10;
  unsigned int v11;

  v2 = cf[2];
  v3 = atomic_load(cf + 1);
  if ((v3 & 4) != 0)
    v4 = (unsigned __int8 *)(((unint64_t)cf + 63) & 0xFFFFFFFFFFFFFFF0);
  else
    v4 = (unsigned __int8 *)cf[5];
  v5 = CFGetAllocator(cf);
  Mutable = CFStringCreateMutable(v5, 0);
  v7 = CFGetAllocator(cf);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFData %p [%p]>{length = %lu, capacity = %lu, bytes = 0x"), cf, v7, v2, cf[3]);
  if (v2 < 25)
  {
    if (v2 >= 1)
    {
      do
      {
        v11 = *v4++;
        CFStringAppendFormat(Mutable, 0, CFSTR("%02x"), v11);
        --v2;
      }
      while (v2);
    }
  }
  else
  {
    v8 = 0;
    do
    {
      CFStringAppendFormat(Mutable, 0, CFSTR("%02x%02x%02x%02x"), v4[v8], v4[v8 + 1], v4[v8 + 2], v4[v8 + 3]);
      v9 = v8 >= 0xC;
      v8 += 4;
    }
    while (!v9);
    CFStringAppend(Mutable, CFSTR(" ... "));
    v10 = v2 - 8;
    do
    {
      CFStringAppendFormat(Mutable, 0, CFSTR("%02x%02x%02x%02x"), v4[v10], v4[v10 + 1], v4[v10 + 2], v4[v10 + 3]);
      v10 += 4;
    }
    while (v10 < v2);
  }
  CFStringAppend(Mutable, CFSTR("}"));
  return Mutable;
}

uint64_t __CFhashUUIDBytes(uint64_t a1)
{
  return CFHashBytes(a1, 16);
}

void __CFStringClose(uint64_t a1)
{
  const void *v2;
  void *v3;

  v2 = *(const void **)(a1 + 80);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v3 = *(void **)(a1 + 88);
  if (v3)
  {
    free(v3);
    *(_QWORD *)(a1 + 88) = 0;
  }
  if ((*(_BYTE *)(a1 + 8) & 0x20) != 0)
  {
    CFRelease(*(CFTypeRef *)(a1 + 72));
    *(_QWORD *)(a1 + 72) = 0;
  }
}

CFStringRef CFURLCopyHostName(CFURLRef anURL)
{
  return _CFURLCopyHostName((uint64_t)anURL, 1);
}

CFMutableStringRef _CFBundleCopyLocalizedStringForLocalizationAndTableURL(unint64_t *a1, void *a2, void *a3, __CFString *a4, const void *a5, CFTypeRef *a6)
{
  const __CFArray *v11;
  CFMutableStringRef v12;
  const void *v14[2];

  v14[1] = *(const void **)MEMORY[0x1E0C80C00];
  v14[0] = a5;
  if (!a5)
    return _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption(a1, a2, a3, a4, 0, 0, a6);
  v11 = CFArrayCreate(0, v14, 1, &kCFTypeArrayCallBacks);
  v12 = _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption(a1, a2, a3, a4, v11, 0, a6);
  if (v11)
    CFRelease(v11);
  return v12;
}

CFMutableStringRef _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption(unint64_t *a1, void *a2, void *a3, __CFString *a4, const __CFArray *a5, int a6, CFTypeRef *a7)
{
  unint64_t v14;
  NSSet *v15;
  const __CFDictionary *v16;
  const __CFDictionary *v17;
  __CFString *Value;
  CFMutableStringRef MutableCopy;
  void *v21;
  const __CFString *v22;
  NSObject *v23;
  CFMutableStringRef v24;
  CFStringRef v25;
  CFStringRef v26;
  CFStringRef v27;
  CFStringRef v28;
  uint64_t v29;
  NSObject *v30;
  __CFString *Mutable;
  CFIndex v32;
  const __CFString *ValueAtIndex;
  NSObject *v34;
  CFTypeRef cf;
  void *key;
  uint8_t buf[4];
  void *v38;
  __int16 v39;
  void *v40;
  __int16 v41;
  unint64_t *v42;
  __int16 v43;
  __CFString *v44;
  __int16 v45;
  __CFString *v46;
  __int16 v47;
  CFMutableStringRef v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  key = a2;
  v14 = _CFGetNonObjCTypeID(a1);
  if (v14 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v14);
  if (a2)
  {
    CFBundleAllowMixedLocalizations();
    if (!a4 || CFEqual(a4, &stru_1E1337B18))
      a4 = CFSTR("Localizable");
    v15 = -[NSSet initWithObjects:count:]([NSSet alloc], "initWithObjects:count:", &key, 1);
    cf = 0;
    v16 = _copyStringTable((uint64_t)a1, a4, v15, a5, a6, &cf);
    if (v16)
    {
      v17 = v16;
      Value = (__CFString *)CFDictionaryGetValue(v16, key);
      if (Value)
      {
        MutableCopy = Value;
        CFRetain(Value);
        CFRelease(v17);

        goto LABEL_24;
      }
      CFRelease(v17);
    }

    if (a3 && !CFEqual(a3, &stru_1E1337B18))
      v21 = a3;
    else
      v21 = key;
    v22 = (const __CFString *)CFRetain(v21);
    if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once != -1)
      dispatch_once(&_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once, &__block_literal_global_38);
    if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_capitalize)
    {
      MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v22);
      v23 = _CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412802;
        v38 = key;
        v39 = 2112;
        v40 = a4;
        v41 = 2112;
        v42 = a1;
        _os_log_error_impl(&dword_182A8C000, v23, OS_LOG_TYPE_ERROR, "ERROR: %@ not found in table %@ of bundle %@", buf, 0x20u);
      }
      CFStringUppercase(MutableCopy, 0);
      CFRelease(v22);
    }
    else
    {
      MutableCopy = (CFMutableStringRef)v22;
    }
LABEL_24:
    if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once_8 != -1)
      dispatch_once(&_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_once_8, &__block_literal_global_10_0);
    if (CFStringGetLength(MutableCopy) >= 1)
    {
      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_doubleStrings == 1)
      {
        v24 = _CFDoubledStringCreate(MutableCopy);
        CFRelease(MutableCopy);
        MutableCopy = v24;
      }
      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_accentuateStrings == 1)
      {
        v25 = _CFAccentuatedStringCreate(MutableCopy);
        CFRelease(MutableCopy);
        MutableCopy = (CFMutableStringRef)v25;
      }
      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_forceRightToLeftStrings == 1)
      {
        v26 = _CFRLORightToLeftStringCreate((uint64_t)MutableCopy);
        CFRelease(MutableCopy);
        MutableCopy = (CFMutableStringRef)v26;
      }
      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_surroundStrings == 1)
      {
        v27 = _CFAffixedStringCreate((uint64_t)MutableCopy, (uint64_t)CFSTR("[# "), (uint64_t)CFSTR(" #]"));
        CFRelease(MutableCopy);
        MutableCopy = (CFMutableStringRef)v27;
      }
      if (_CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption_tallStrings == 1)
      {
        v28 = _CFTallStringCreate((uint64_t)MutableCopy);
        CFRelease(MutableCopy);
        MutableCopy = (CFMutableStringRef)v28;
      }
    }
    if (!a6 && MutableCopy)
    {
      v29 = _CFStringCreateByParsingMarkdownAndInflectingIfNeeded(MutableCopy, (__CFBundle *)a1, (uint64_t)cf);
      CFRelease(MutableCopy);
      MutableCopy = (CFMutableStringRef)v29;
    }
    if (a7)
    {
      *a7 = cf;
    }
    else if (cf)
    {
      CFRelease(cf);
    }
    if (a5 && (v30 = _CFBundleLocalizedStringLogger(), os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)))
    {
      Mutable = CFStringCreateMutable(0, 0);
      CFStringAppend(Mutable, CFSTR("["));
      if (CFArrayGetCount(a5) >= 1)
      {
        v32 = 0;
        do
        {
          if (v32)
            CFStringAppend(Mutable, CFSTR(", "));
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a5, v32);
          CFStringAppend(Mutable, ValueAtIndex);
          ++v32;
        }
        while (v32 < CFArrayGetCount(a5));
      }
      CFStringAppend(Mutable, CFSTR("]"));
    }
    else
    {
      Mutable = 0;
    }
    v34 = _CFBundleLocalizedStringLogger();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138479107;
      v38 = a1;
      v39 = 2114;
      v40 = key;
      v41 = 2114;
      v42 = (unint64_t *)a3;
      v43 = 2114;
      v44 = a4;
      v45 = 2114;
      v46 = Mutable;
      v47 = 2114;
      v48 = MutableCopy;
      _os_log_debug_impl(&dword_182A8C000, v34, OS_LOG_TYPE_DEBUG, "Bundle: %{private}@, key: %{public}@, value: %{public}@, table: %{public}@, localizationNames: %{public}@, result: %{public}@", buf, 0x3Eu);
      if (!Mutable)
        return MutableCopy;
    }
    else if (!Mutable)
    {
      return MutableCopy;
    }
    CFRelease(Mutable);
    return MutableCopy;
  }
  if (a3)
    return (CFMutableStringRef)CFRetain(a3);
  else
    return (CFMutableStringRef)CFRetain(&stru_1E1337B18);
}

void sub_182AD5048(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182AD55A8(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182AD5C48(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

_BYTE *__NSSetI_new(uint64_t *a1, uint64_t *a2, unint64_t a3, char a4)
{
  unint64_t v5;
  uint64_t v8;
  uint64_t v9;
  objc_class *v10;
  _BYTE *v11;
  _BYTE *v12;
  unint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  _QWORD v17[2];
  unint64_t (*v18)(uint64_t, uint64_t);
  void *v19;
  _BYTE *v20;
  char *v21;
  uint64_t v22;
  char v23;
  uint64_t *v24;
  uint64_t v25;

  v5 = a3;
  v8 = 0;
  v25 = *MEMORY[0x1E0C80C00];
  v24 = a2;
  while (__NSSetCapacities[v8] < a3)
  {
    if (++v8 == 64)
    {
      __break(1u);
      break;
    }
  }
  v9 = __NSSetSizes[v8];
  v10 = (objc_class *)objc_opt_self();
  v11 = __CFAllocateObject(v10, 8 * v9);
  v12 = v11;
  v11[15] = v11[15] & 3 | (4 * v8);
  if (v5)
  {
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 3221225472;
    v18 = ____NSSetI_new_block_invoke;
    v19 = &unk_1E12E62F8;
    v21 = v11 + 16;
    v22 = v9;
    v23 = a4;
    v20 = v11;
    if (a2)
    {
      ____NSSetI_new_block_invoke((uint64_t)v17, *a1);
      if (v5 >= 2)
      {
        v13 = v5 - 1;
        do
        {
          v14 = v24++;
          v18((uint64_t)v17, *v14);
          --v13;
        }
        while (v13);
      }
    }
    else
    {
      do
      {
        v15 = *a1++;
        v18((uint64_t)v17, v15);
        --v5;
      }
      while (v5);
    }
  }
  return v12;
}

uint64_t __NSSetM_copy(uint64_t Function, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v6;
  _WORD *v8;
  uint64_t v10;
  char *v11;
  id v12;
  objc_class *v13;
  os_unfair_lock_s *v14;
  _QWORD v16[2];

  v3 = Function;
  v16[1] = *MEMORY[0x1E0C80C00];
  if (__cf_tsanReadFunction)
    Function = __cf_tsanReadFunction(Function, v2, __CFTSANTagMutableSet);
  v4 = *(_DWORD *)(v3 + 28) & 0x3FFFFFF;
  if (!atomic_load((unint64_t *)(v3 + 8)))
  {
    if (v4 > 3)
      goto LABEL_5;
LABEL_11:
    MEMORY[0x1E0C80A78](Function, a2);
    v11 = (char *)v16 - v10;
    objc_msgSend((id)v3, "getObjects:count:", (char *)v16 - v10, v4);
    return objc_msgSend(objc_allocWithZone((Class)NSSet), "initWithObjects:count:", v11, v4);
  }
  if (v4 < 2)
    goto LABEL_11;
LABEL_5:
  v6 = (unint64_t *)(v3 + 8);
  if (!atomic_load((unint64_t *)(v3 + 8)))
  {
    v8 = _cow_create(v3, 1);
    while (!__ldaxr(v6))
    {
      if (!__stlxr((unint64_t)v8, v6))
        goto LABEL_13;
    }
    __clrex();
    free(v8);
  }
LABEL_13:
  v13 = (objc_class *)objc_opt_self();
  v12 = __CFAllocateObject(v13, 0);
  v14 = (os_unfair_lock_s *)atomic_load((unint64_t *)(v3 + 8));
  _cow_copy(v3, 1, v14, (uint64_t)__NSSet_cowCallbacks, (uint64_t)v12, 0);
  return (uint64_t)v12;
}

unint64_t *__NSSetM_new(uint64_t a1, unint64_t a2, char a3)
{
  int v4;
  unint64_t v5;
  unint64_t v6;
  objc_class *v7;
  unint64_t *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  void *v18;
  unint64_t v19;
  uint64_t v20;
  id v21;
  unint64_t *v23;
  uint64_t v25;

  v4 = 0;
  v5 = 0;
  while (__NSSetCapacities_0[v5 / 2] < a2)
  {
    v5 += 2;
    v4 -= 0x4000000;
    if (v5 == 128)
    {
      __break(1u);
      break;
    }
  }
  v6 = __NSSetSizes_0[v5];
  v7 = (objc_class *)objc_opt_self();
  v8 = (unint64_t *)__CFAllocateObject(v7, 0);
  atomic_store(0, v8 + 1);
  v8[2] = 0;
  *((_DWORD *)v8 + 6) = 1;
  v23 = v8;
  *((_DWORD *)v8 + 7) = (*((_DWORD *)v8 + 7) & 0x3FFFFFF) - v4;
  if (a2)
  {
    v9 = malloc_type_calloc(1uLL, 8 * v6, 0x55ECBBD0uLL);
    v23[2] = (unint64_t)v9;
    if (a1)
    {
      v10 = v9;
      v11 = 0;
      if (v6 <= 1)
        v12 = 1;
      else
        v12 = v6;
      v25 = v12;
      do
      {
        v13 = *(void **)(a1 + 8 * v11);
        v14 = objc_msgSend(v13, "hash");
        v15 = v6;
        if ((_DWORD)(v5 * 4))
        {
          v16 = v14 % v6;
          v17 = v25;
          v15 = v6;
          while (1)
          {
            v18 = (void *)v10[v16];
            if (!v18)
              break;
            if (v18 == &___NSSetM_DeletedMarker)
            {
              if (v15 == v6)
                v15 = v16;
            }
            else if (v18 == v13 || (objc_msgSend(v18, "isEqual:", v13) & 1) != 0)
            {
              v15 = v16;
              goto LABEL_28;
            }
            if (v16 + 1 >= v6)
              v19 = v6;
            else
              v19 = 0;
            v16 = v16 + 1 - v19;
            if (!--v17)
              goto LABEL_28;
          }
          if (v15 == v6)
            v15 = v16;
        }
LABEL_28:
        if (!v10[v15])
        {
          v20 = *(_QWORD *)(a1 + 8 * v11);
          v10[v15] = v20;
          if ((a3 & 1) == 0 && v20 >= 1)
            v21 = (id)v20;
          *((_DWORD *)v23 + 7) = *((_DWORD *)v23 + 7) & 0xFC000000 | (*((_DWORD *)v23 + 7) + 1) & 0x3FFFFFF;
        }
        ++v11;
      }
      while (v11 != a2);
    }
  }
  return v23;
}

__objc2_class **__NSSetMutablePlaceholder()
{
  return &___mutablePlaceholderSet;
}

__objc2_class **__NSSetImmutablePlaceholder()
{
  return &___immutablePlaceholderSet;
}

uint64_t __createSet(void *a1, uint64_t a2)
{
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v3[0] = a2;
  return objc_msgSend(a1, "initWithObjects:count:", v3, 1);
}

_QWORD *__NSSingleObjectSetI_new(uint64_t a1, char a2)
{
  objc_class *v4;
  _QWORD *v5;
  _QWORD *v6;
  id v7;

  v4 = (objc_class *)objc_opt_self();
  v5 = __CFAllocateObject(v4, 0);
  v6 = v5;
  if (v5)
  {
    v5[1] = a1;
    if (a1 >= 1 && (a2 & 1) == 0)
      v7 = (id)a1;
  }
  return v6;
}

uint64_t _CFBundleLocalizedStringLogger()
{
  if (_CFBundleLocalizedStringLogger_onceToken != -1)
    dispatch_once(&_CFBundleLocalizedStringLogger_onceToken, &__block_literal_global_96);
  return _CFBundleLocalizedStringLogger__log;
}

uint64_t _CFStringCreateByParsingMarkdownAndInflectingIfNeeded(__CFString *a1, __CFBundle *a2, uint64_t a3)
{
  uint64_t FormatSpecifierConfiguration;

  if (_CFStringNeedsMarkdownParsing(a1, a2))
  {
    FormatSpecifierConfiguration = _CFStringGetFormatSpecifierConfiguration(a1);
    return _CFStringCreateWithMarkdownAndConfiguration((uint64_t)a1, FormatSpecifierConfiguration, (uint64_t)a2, a3);
  }
  else
  {
    CFRetain(a1);
    return (uint64_t)a1;
  }
}

const __CFString *_CFStringNeedsMarkdownParsing(const __CFString *a1, CFBundleRef bundle)
{
  const __CFString *result;
  const __CFString *v4;
  CFRange v5;

  if (!bundle)
    return 0;
  result = CFBundleGetIdentifier(bundle);
  if (result)
  {
    v4 = result;
    v5.length = CFStringGetLength(result);
    v5.location = 0;
    result = (const __CFString *)CFStringFindWithOptionsAndLocale(v4, CFSTR("com.apple."), v5, 8uLL, 0, 0);
    if ((_DWORD)result)
      return (const __CFString *)(CFStringFind(a1, CFSTR("^["), 0).location != -1);
  }
  return result;
}

CFStringRef CFBundleGetIdentifier(CFBundleRef bundle)
{
  CFStringRef result;

  result = (CFStringRef)CFBundleGetInfoDictionary(bundle);
  if (result)
    return (CFStringRef)CFDictionaryGetValue((CFDictionaryRef)result, CFSTR("CFBundleIdentifier"));
  return result;
}

CFDictionaryRef CFBundleGetInfoDictionary(CFBundleRef bundle)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  os_unfair_lock_lock((os_unfair_lock_t)bundle + 28);
  _CFBundleRefreshInfoDictionaryAlreadyLocked((uint64_t)bundle);
  os_unfair_lock_unlock((os_unfair_lock_t)bundle + 28);
  return (CFDictionaryRef)*((_QWORD *)bundle + 3);
}

void _CFBundleRefreshInfoDictionaryAlreadyLocked(uint64_t a1)
{
  const __CFDictionary *v2;
  const void *v3;
  const __CFString *Value;
  CFTypeID v5;
  CFIndex Length;
  int v7;
  CFTypeID v8;
  unint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  UniChar *v16;
  int v17;
  int v18;
  unsigned int v19;
  BOOL v20;
  int v21;
  __int16 v22;
  int v23;
  const __CFAllocator *v24;
  CFNumberRef v25;
  int v26;
  int v27;
  int v28;
  CFTypeRef v29;
  UniChar buffer[2];
  unsigned __int16 v31;
  uint64_t v32;
  CFRange v33;

  v32 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 24))
  {
    v29 = 0;
    v2 = _CFBundleCopyInfoDictionaryInDirectoryWithVersion((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFURLRef *)(a1 + 16), &v29, 0, *(unsigned __int8 *)(a1 + 55), *(unsigned __int8 *)(a1 + 53));
    *(_QWORD *)(a1 + 24) = v2;
    v3 = *(const void **)(a1 + 216);
    if (v3)
    {
      CFRelease(v3);
      v2 = *(const __CFDictionary **)(a1 + 24);
    }
    *(_QWORD *)(a1 + 216) = v29;
    if (v2)
    {
      Value = (const __CFString *)CFDictionaryGetValue(v2, CFSTR("CFBundleNumericVersion"));
      if (Value || (Value = (const __CFString *)CFDictionaryGetValue(v2, CFSTR("CFBundleVersion"))) != 0)
      {
        v5 = CFGetTypeID(Value);
        if (v5 == CFStringGetTypeID())
        {
          Length = CFStringGetLength(Value);
          if ((unint64_t)(Length - 11) < 0xFFFFFFFFFFFFFFF6)
          {
LABEL_10:
            v7 = 0;
LABEL_54:
            *(_DWORD *)buffer = v7;
            v24 = CFGetAllocator((CFTypeRef)a1);
            v25 = CFNumberCreate(v24, kCFNumberSInt32Type, buffer);
            CFDictionarySetValue(v2, CFSTR("CFBundleNumericVersion"), v25);
            CFRelease(v25);
            return;
          }
          v9 = Length;
          v33.location = 0;
          v33.length = Length;
          CFStringGetCharacters(Value, v33, buffer);
          v10 = buffer[0];
          if ((unsigned __int16)(buffer[0] - 58) >= 0xFFF6u)
          {
            v15 = buffer[0] - 48;
            if (v9 < 2)
            {
              v17 = 0;
              v11 = 0;
              v19 = 0;
              v20 = 0;
              v21 = 0x8000;
              v14 = buffer[0] - 48;
              v15 = 0;
LABEL_50:
              v7 = v21 + (v17 << 20) + (v14 << 24) + (v15 << 28) + v11 + v19;
              if (v20)
                v7 = 0;
              if (v19 > 0xFF)
                v7 = 0;
              goto LABEL_54;
            }
            v10 = buffer[1];
            if ((unsigned __int16)(buffer[1] - 58) >= 0xFFF6u)
            {
              v14 = buffer[1] - 48;
              if (v9 < 3)
                goto LABEL_30;
              v10 = v31;
              if (v31 != 46)
              {
                v11 = 0;
                v17 = 0;
                v16 = &v31;
                v9 -= 2;
                goto LABEL_41;
              }
              v12 = -3;
              v13 = 3;
LABEL_17:
              v9 += v12;
              if (v9)
              {
                v16 = &buffer[v13];
                v10 = *v16;
                if ((unsigned __int16)(v10 - 58) < 0xFFF6u)
                {
                  v11 = 0;
                  v17 = 0;
LABEL_41:
                  v18 = v15;
                  goto LABEL_42;
                }
                v17 = v10 - 48;
                if (v9 >= 2)
                {
                  v10 = v16[1];
                  if (v10 != 46)
                  {
                    v11 = 0;
                    --v9;
                    ++v16;
                    goto LABEL_41;
                  }
                  if (v9 != 2)
                  {
                    v10 = v16[2];
                    if ((unsigned __int16)(v10 - 58) < 0xFFF6u)
                    {
                      v11 = 0;
                      v9 -= 2;
                      v16 += 2;
                      goto LABEL_41;
                    }
                    v11 = (v10 << 16) - 3145728;
                    v9 -= 3;
                    if (v9)
                    {
                      v28 = v16[3];
                      v16 += 3;
                      v10 = v28;
                      goto LABEL_41;
                    }
                    goto LABEL_37;
                  }
                }
LABEL_36:
                v11 = 0;
LABEL_37:
                v19 = 0;
                v20 = 0;
                v21 = 0x8000;
                goto LABEL_50;
              }
LABEL_30:
              v17 = 0;
              goto LABEL_36;
            }
            v11 = 0;
            if (buffer[1] == 46)
            {
              v12 = -2;
              v13 = 2;
              v14 = buffer[0] - 48;
              goto LABEL_16;
            }
            v16 = &buffer[1];
            --v9;
            v18 = 0;
            v14 = buffer[0] - 48;
          }
          else
          {
            v11 = 0;
            if (buffer[0] == 46)
            {
              v12 = -1;
              v13 = 1;
              v14 = 0;
LABEL_16:
              v15 = 0;
              goto LABEL_17;
            }
            v16 = buffer;
            v18 = 0;
            v14 = 0;
          }
          v17 = 0;
LABEL_42:
          v22 = v10 - 97;
          if ((v10 - 97) > 5 || ((0x2Bu >> v22) & 1) == 0)
            goto LABEL_10;
          v21 = dword_182DCA914[v22];
          if (v9 == 1)
          {
            v19 = 0;
          }
          else
          {
            v23 = v16[1];
            if ((v23 - 58) < 0xFFFFFFF6)
              goto LABEL_10;
            v19 = v23 - 48;
            if (v9 != 2)
            {
              v26 = v16[2];
              if ((v26 - 58) < 0xFFFFFFF6)
                goto LABEL_10;
              v19 = v26 + 10 * v19 - 48;
              if (v9 != 3)
              {
                v27 = v16[3];
                if ((v27 - 58) < 0xFFFFFFF6)
                  goto LABEL_10;
                v19 = v27 + 10 * v19 - 48;
                v20 = v9 - 3 > 1;
                goto LABEL_49;
              }
            }
          }
          v20 = 0;
LABEL_49:
          v15 = v18;
          goto LABEL_50;
        }
        v8 = CFGetTypeID(Value);
        if (v8 != CFNumberGetTypeID())
          CFDictionaryRemoveValue(v2, CFSTR("CFBundleNumericVersion"));
      }
    }
  }
}

CFDictionaryRef _copyStringTable(uint64_t a1, __CFString *a2, CFTypeRef cf, const __CFArray *a4, unsigned __int8 a5, CFTypeRef *a6)
{
  void *v12;
  int v13;
  int v14;
  const __CFDictionary *v15;
  const __CFDictionary *Value;
  const __CFDictionary *v17;
  const __CFSet *v18;
  CFDictionaryRef Copy;
  const __CFSet *v20;
  CFDictionaryRef v21;
  CFTypeRef v22;
  const __CFDictionary *Mutable;
  CFMutableDictionaryRef v24;
  const __CFDictionary *v25;
  const __CFAllocator *v26;
  void *v27;
  const __CFAllocator *v28;
  CFMutableSetRef MutableCopy;
  const void *v30;
  const __CFDictionary *v31;
  const void *v32;
  __CFSet *v33;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  CFTypeRef cfa[2];
  CFTypeRef context;
  uint64_t v42;
  void (*v43)(uint64_t, const void *);
  void *v44;
  const void *v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 *v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  if (cf)
    v12 = (void *)CFRetain(cf);
  else
    v12 = 0;
  if (CFStringHasSuffix(a2, CFSTR(".nocache")))
  {
    v13 = _CFExecutableLinkedOnOrAfter(5uLL);
    v14 = 0;
    if (a4 || v13)
      goto LABEL_36;
LABEL_10:
    os_unfair_lock_lock_with_options();
    v15 = *(const __CFDictionary **)(a1 + 144);
    if (v15 && (Value = (const __CFDictionary *)CFDictionaryGetValue(v15, a2)) != 0)
    {
      v17 = Value;
      v18 = *(const __CFSet **)(a1 + 152);
      if (v18 && CFSetContainsValue(v18, a2))
      {
        Copy = CFDictionaryCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17);
LABEL_18:
        v21 = Copy;
        v22 = 0;
        goto LABEL_28;
      }
      if (v12)
      {
        *(_QWORD *)&v47 = 0;
        *((_QWORD *)&v47 + 1) = &v47;
        v48 = 0x2020000000uLL;
        *(_QWORD *)&v35 = MEMORY[0x1E0C809B0];
        *((_QWORD *)&v35 + 1) = 3221225472;
        *(_QWORD *)&v36 = ___stringTableFromCacheSatisfyingRequest_block_invoke;
        *((_QWORD *)&v36 + 1) = &unk_1E1335D58;
        *(_QWORD *)&v38 = a1;
        *((_QWORD *)&v38 + 1) = a2;
        *(_QWORD *)&v37 = &v47;
        *((_QWORD *)&v37 + 1) = v17;
        CFSetApply(v12, (uint64_t)&v35);
        v22 = *(CFTypeRef *)(*((_QWORD *)&v47 + 1) + 24);
        if (v22)
          v21 = 0;
        else
          v21 = CFDictionaryCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17);
        _Block_object_dispose(&v47, 8);
LABEL_28:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
        if (v21)
        {
          if (a6)
            *a6 = 0;
          if (v12)
            goto LABEL_80;
          return v21;
        }
        goto LABEL_33;
      }
    }
    else
    {
      v20 = *(const __CFSet **)(a1 + 152);
      if (v20 && CFSetContainsValue(v20, a2))
      {
        Copy = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        goto LABEL_18;
      }
      if (v12)
      {
        v22 = CFRetain(v12);
LABEL_25:
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
LABEL_33:
        if (v12)
          CFRelease(v12);
        v14 = 1;
        v12 = (void *)v22;
        goto LABEL_36;
      }
    }
    v22 = 0;
    goto LABEL_25;
  }
  if (!a4)
    goto LABEL_10;
  v14 = 0;
LABEL_36:
  v39 = 0u;
  *(_OWORD *)cfa = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  _CFBundleGetStringsSources(a1, 1, a2, a4, (uint64_t)&v35);
  BYTE8(v39) = v14;
  cfa[0] = 0;
  *(_DWORD *)((char *)&v39 + 9) = 0;
  *(_WORD *)((char *)&v39 + 13) = 0;
  cfa[1] = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if ((_QWORD)v36)
  {
    if (!(_BYTE)v39)
      BYTE9(v39) = 1;
    BYTE12(v39) = 1;
  }
  if (*((_QWORD *)&v37 + 1))
  {
    if (!BYTE1(v39))
      BYTE9(v39) = 1;
    BYTE13(v39) = 1;
  }
  if (*((_QWORD *)&v38 + 1))
  {
    if (!BYTE2(v39))
      BYTE9(v39) = 1;
    BYTE14(v39) = 1;
  }
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  _loadStringsInOrder((const void *)a1, a2, v12, Mutable, (uint64_t)&v35, a6);
  if (BYTE11(v39))
  {
    v24 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    *(_QWORD *)&v47 = MEMORY[0x1E0C809B0];
    *((_QWORD *)&v47 + 1) = 3221225472;
    *(_QWORD *)&v48 = ___postProcessStringsDict_block_invoke;
    *((_QWORD *)&v48 + 1) = &__block_descriptor_73_e34_____CFString__16__0____CFString__8l;
    *(_QWORD *)&v49 = Mutable;
    *((_QWORD *)&v49 + 1) = v24;
    *(_QWORD *)&v50 = a1;
    *((_QWORD *)&v50 + 1) = a2;
    v51 = &v35;
    v52 = a5;
    context = cfa[1];
    v42 = (uint64_t)Mutable;
    v43 = (void (*)(uint64_t, const void *))&v47;
    v44 = (void *)a1;
    v45 = (const void *)*((_QWORD *)&v36 + 1);
    v46 = a5;
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFPlatformSpecificStringDictionaryApplyFunction, &context);
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFLocalizedFormatStringApplyFunction, &context);
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFVariableWidthStringDictionaryApplyFunction, &context);
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFAttributedLocalizedStringDictionaryApplyFunction, &context);
    CFRelease(v24);
  }
  if (!v14)
  {
    v21 = Mutable;
    goto LABEL_77;
  }
  os_unfair_lock_lock_with_options();
  v25 = *(const __CFDictionary **)(a1 + 144);
  if (!v25)
  {
    v26 = CFGetAllocator((CFTypeRef)a1);
    v25 = CFDictionaryCreateMutable(v26, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    *(_QWORD *)(a1 + 144) = v25;
  }
  v27 = (void *)CFDictionaryGetValue(v25, a2);
  if (!v27)
  {
    v28 = CFGetAllocator((CFTypeRef)a1);
    v27 = CFDictionaryCreateMutable(v28, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 144), a2, v27);
    CFRelease(v27);
  }
  if (!WORD6(v39) && !BYTE14(v39))
    goto LABEL_57;
  if (cf)
  {
    MutableCopy = CFSetCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (CFSetRef)cf);
    v30 = (const void *)MEMORY[0x1E0C809B0];
    *(_QWORD *)&v47 = MEMORY[0x1E0C809B0];
    *((_QWORD *)&v47 + 1) = 3221225472;
    *(_QWORD *)&v48 = ___copyIngestedCacheResult_block_invoke;
    *((_QWORD *)&v48 + 1) = &__block_descriptor_48_e18_v32__0r_v8r_v16_24l;
    *(_QWORD *)&v49 = v27;
    *((_QWORD *)&v49 + 1) = MutableCopy;
    CFDictionaryApply(Mutable, (uint64_t)&v47);
    if (CFSetGetCount(MutableCopy) >= 1)
    {
      v31 = *(const __CFDictionary **)(a1 + 160);
      if (!v31)
      {
        v31 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(_QWORD *)(a1 + 160) = v31;
      }
      v32 = CFDictionaryGetValue(v31, a2);
      if (!v32)
      {
        v32 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringSetCallBacks);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 160), a2, v32);
        CFRelease(v32);
      }
      context = v30;
      v42 = 3221225472;
      v43 = ___copyIngestedCacheResult_block_invoke_2;
      v44 = &__block_descriptor_40_e13_v24__0r_v8_16l;
      v45 = v32;
      CFSetApply(MutableCopy, (uint64_t)&context);
    }
    CFRelease(MutableCopy);
    goto LABEL_69;
  }
  if (CFDictionaryGetCount(Mutable) >= 1)
  {
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)__CFStringsDictAddFunction, v27);
  }
  else
  {
LABEL_57:
    BYTE10(v39) = 1;
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 144), a2);
    v27 = 0;
  }
LABEL_69:
  if (BYTE10(v39))
  {
    v33 = *(__CFSet **)(a1 + 152);
    if (!v33)
    {
      v33 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringSetCallBacks);
      *(_QWORD *)(a1 + 152) = v33;
    }
    CFSetAddValue(v33, a2);
  }
  if (v27)
    v21 = CFDictionaryCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFDictionaryRef)v27);
  else
    v21 = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  CFRelease(Mutable);
LABEL_77:
  v49 = v37;
  v50 = v38;
  v51 = (__int128 *)v39;
  v47 = v35;
  v48 = v36;
  _CFBundleReleaseStringsSources((uint64_t)&v47);
  CFRelease(cfa[1]);
  if (cfa[0])
    CFRelease(cfa[0]);
  if (v12)
LABEL_80:
    CFRelease(v12);
  return v21;
}

void sub_182AD7C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  uint64_t Copy;
  const __CFDictionary *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  int v10;

  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
    return (CFDictionaryRef)-[__CFDictionary copyWithZone:](theDict, "copyWithZone:", 0);
  Copy = CFBasicHashCreateCopy((__objc2_class **)allocator, (uint64_t)theDict);
  v6 = (const __CFDictionary *)Copy;
  if (!Copy)
    return v6;
  v7 = (unint64_t *)(Copy + 8);
  v8 = atomic_load((unint64_t *)(Copy + 8));
  do
  {
    v9 = __ldaxr(v7);
    if (v9 == v8)
    {
      if (!__stlxr(v8 | 0x40, v7))
      {
        v10 = 1;
        goto LABEL_10;
      }
    }
    else
    {
      __clrex();
    }
    v10 = 0;
LABEL_10:
    v8 = v9;
  }
  while (!v10);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)Copy, 0x12uLL);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  return v6;
}

uint64_t CFBundleAllowMixedLocalizations()
{
  if (CFBundleAllowMixedLocalizations_once != -1)
    dispatch_once(&CFBundleAllowMixedLocalizations_once, &__block_literal_global_16);
  return CFBundleAllowMixedLocalizations_allowMixed;
}

CFMutableSetRef CFSetCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFSetRef theSet)
{
  CFIndex Count;
  const void **Typed;
  objc_class **Copy;
  uint64_t Generic;
  CFIndex i;
  _OWORD v11[128];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    Count = CFSetGetCount(theSet);
    memset(v11, 0, 512);
    if (Count >= 257)
      Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
    else
      Typed = (const void **)v11;
    CFSetGetValues(theSet, Typed);
    Generic = __CFSetCreateGeneric((__objc2_class **)allocator, (uint64_t)&kCFTypeSetCallBacks);
    Copy = (objc_class **)Generic;
    if (Count >= 1 && Generic)
    {
      CFBasicHashSetCapacity(Generic, Count);
      for (i = 0; i < Count; ++i)
        CFBasicHashAddValue((uint64_t)Copy, (unint64_t)Typed[i], (uint64_t)Typed[i]);
    }
    if (Typed != (const void **)v11)
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
  else
  {
    Copy = (objc_class **)CFBasicHashCreateCopy((__objc2_class **)allocator, (uint64_t)theSet);
  }
  if (Copy)
  {
    _CFRuntimeSetInstanceTypeIDAndIsa(Copy, 0x11uLL);
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
  }
  return (CFMutableSetRef)Copy;
}

uint64_t CFBasicHashGetUsedBucketCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

void _CFBundleReleaseStringsSources(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;

  v2 = *(const void **)a1;
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 8);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 16);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 24);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 32);
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(a1 + 40);
  if (v7)
    CFRelease(v7);
  v8 = *(const void **)(a1 + 48);
  if (v8)
    CFRelease(v8);
  v9 = *(const void **)(a1 + 56);
  if (v9)
    CFRelease(v9);
}

id __NSFrozenSetM_mutableCopy(uint64_t a1)
{
  uint64_t v1;
  unint64_t *v3;
  _WORD *v5;
  objc_class *v7;
  id v8;
  os_unfair_lock_s *v9;

  if (__cf_tsanReadFunction)
    __cf_tsanReadFunction(a1, v1, __CFTSANTagMutableSet);
  v3 = (unint64_t *)(a1 + 24);
  if (!atomic_load((unint64_t *)(a1 + 24)))
  {
    v5 = _cow_create(a1, 0);
    while (!__ldaxr(v3))
    {
      if (!__stlxr((unint64_t)v5, v3))
        goto LABEL_9;
    }
    __clrex();
    free(v5);
  }
LABEL_9:
  v7 = (objc_class *)objc_opt_self();
  v8 = __CFAllocateObject(v7, 0);
  v9 = (os_unfair_lock_s *)atomic_load((unint64_t *)(a1 + 24));
  _cow_copy(a1, 0, v9, (uint64_t)__NSSet_cowCallbacks, (uint64_t)v8, 1);
  return v8;
}

uint64_t __CFRunLoopSourceHash(uint64_t a1)
{
  uint64_t (*v1)(uint64_t);
  uint64_t result;

  v1 = *(uint64_t (**)(uint64_t))(a1 + 152);
  result = *(_QWORD *)(a1 + 112);
  if (v1)
    return v1(result);
  return result;
}

void __CFXNotificationPostToken(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  __CFNotification *v9;
  void *v10;
  _QWORD v11[2];
  void **v12;
  _OWORD v13[4];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v11[1] = 0;
  memset(v13, 0, sizeof(v13));
  v11[0] = 0x100000000;
  v12 = (void **)v13;
  if (CFXNotificationRegistrarFindToken(a1[2], a2, (uint64_t)v11))
  {
    if (!a3)
      a3 = *v12;
    v9 = -[__CFNotification initWithName:object:userInfo:foundation:]([__CFNotification alloc], "initWithName:object:userInfo:foundation:", a3, a4, a5, 1);
    v10 = _CFXRegistrationPost(a1, (uint64_t)v12, 1, (uint64_t)v9, v12[2]);

  }
  _CFXNotificationRegistrationBufferDestroy((unsigned int *)v11);
}

void CFNotificationCenterPostNotificationWithOptions(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, CFOptionFlags options)
{
  unint64_t v10;
  __CFNotification *v11;
  char v12;
  const void *v13;
  char v14;
  CFDictionaryRef v15;
  __CFNotification *v16;

  v10 = _CFGetNonObjCTypeID((unint64_t *)center);
  if (v10 != 52)
    _CFAssertMismatchedTypeID(0x34uLL, v10);
  v11 = [__CFNotification alloc];
  v12 = atomic_load((unint64_t *)center + 1);
  if ((v12 & 1) != 0)
    v13 = 0;
  else
    v13 = object;
  v14 = atomic_load((unint64_t *)center + 1);
  if ((v14 & 1) != 0)
    v15 = 0;
  else
    v15 = userInfo;
  v16 = -[__CFNotification initWithName:object:userInfo:foundation:](v11, "initWithName:object:userInfo:foundation:", name, v13, v15, 0);
  _CFXNotificationPost((unint64_t *)center, v16, options);

}

void _CFXNotificationRegistrarRemoveNames(uint64_t a1, uint64_t a2, int a3, __CFString *a4, unint64_t a5, const __CFString *cf1, unint64_t a7, int a8, uint64_t a9)
{
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int *v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int *v24;
  int v25;
  int v26;
  unint64_t v27;

  v27 = *(unsigned int *)(a2 + 8);
  if (!(_DWORD)v27)
    return;
  if (CFSTR("kCFNotificationAnyName") == a4)
  {
    v20 = 0;
    while (1)
    {
      v21 = *(_DWORD *)(*(_QWORD *)a2 + 4 * v20);
      if (v21 != -1)
        break;
LABEL_20:
      if (++v20 == v27)
        return;
    }
    while (1)
    {
      v22 = *(_QWORD *)(a1 + 96) + 40 * v21;
      v23 = *(_DWORD *)(v22 + 4);
      v24 = (unsigned int *)(v22 + 24);
      if (a3 == 1)
      {
        if (_CFXNotificationRegistrarRemoveObservers(a1, v24, a9))
        {
          v25 = 1;
LABEL_18:
          _CFXNotificationRegistrarRecycleNameRegistration(a1, (uint64_t *)a2, v21, v25);
        }
      }
      else if (_CFXNotificationRegistrarRemoveObjects(a1, (uint64_t)v24, cf1, a7, a8, a9))
      {
        v25 = 0;
        goto LABEL_18;
      }
      v21 = v23;
      if (v23 == -1)
        goto LABEL_20;
    }
  }
  v15 = *(_DWORD *)(*(_QWORD *)a2 + 4 * (a5 % v27));
  if (v15 == -1)
    return;
  while (1)
  {
    v16 = *(_QWORD *)(a1 + 96);
    v17 = v16 + 40 * v15;
    v18 = *(_DWORD *)(v17 + 4);
    if (!CFCachedStringEqual((CFTypeRef *)(v17 + 8), a4))
      goto LABEL_9;
    v19 = (unsigned int *)(v16 + 40 * v15 + 24);
    if (a3 != 1)
      break;
    if (_CFXNotificationRegistrarRemoveObservers(a1, v19, a9))
    {
      v26 = 1;
      goto LABEL_23;
    }
LABEL_9:
    v15 = v18;
    if (v18 == -1)
      return;
  }
  if (!_CFXNotificationRegistrarRemoveObjects(a1, (uint64_t)v19, cf1, a7, a8, a9))
    goto LABEL_9;
  v26 = 0;
LABEL_23:
  _CFXNotificationRegistrarRecycleNameRegistration(a1, (uint64_t *)a2, v15, v26);
}

uint64_t _CFXNotificationRegistrarFindName(uint64_t a1, uint64_t a2, const void *a3, unint64_t a4, _DWORD *a5)
{
  unint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;

  v5 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v5)
  {
    v9 = *(unsigned int *)(*(_QWORD *)a2 + 4 * (a4 % v5));
    while (v9 != 0xFFFFFFFFLL)
    {
      v10 = v9;
      v11 = *(_QWORD *)(a1 + 96);
      v12 = v11 + 40 * v9;
      v9 = *(unsigned int *)(v12 + 4);
      if (CFCachedStringEqual((CFTypeRef *)(v12 + 8), a3))
      {
        result = v11 + 40 * v10;
        if (a5)
          *a5 = v10;
        return result;
      }
    }
  }
  return 0;
}

BOOL CFCachedStringEqual(CFTypeRef *a1, const void *a2)
{
  _BOOL8 v4;

  os_unfair_lock_lock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  if (*a1)
    v4 = CFEqual(*a1, a2) != 0;
  else
    v4 = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  return v4;
}

uint64_t _CFXNotificationRegisterObserver(CFIndex a1, const __CFString *a2, __CFString *a3, unint64_t a4, __CFString *a5, void *a6, const void *a7)
{
  unint64_t v10;
  char v14;
  __int16 v15;
  char v16;
  uint64_t v17;
  objc_class *Class;
  void *v19;
  char v20;
  char v21;
  UInt8 *v22;
  UInt8 *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  const char *v32;
  int v33;
  UInt8 *v34;
  uint32_t v35;
  xpc_object_t v36;
  uint64_t *v37;
  _xpc_connection_s *v38;
  CFIndex maxBufLen[6];
  int out_token;
  uint64_t v42;
  CFRange v43;
  CFRange v44;
  CFRange v45;
  CFRange v46;
  CFRange v47;
  CFRange v48;

  v10 = a4;
  v42 = *MEMORY[0x1E0C80C00];
  v14 = atomic_load((unint64_t *)(a1 + 8));
  if ((v14 & 1) == 0)
  {
    v15 = atomic_load((unint64_t *)(a1 + 8));
    v10 = ~(v15 << 11) & 0x1000 | a4;
  }
  if (!a2 || !a3 || !a5 || a5 == CFSTR("kCFNotificationAnyObserver"))
    __break(1u);
  v16 = atomic_load((unint64_t *)(a1 + 8));
  if ((v16 & 2) != 0 && (__CFIsDistNoteDaemon & 1) != 0)
    return 0;
  if ((v10 & 0x400) != 0)
  {
    Class = object_getClass(a5);
    if (class_isMetaClass(Class))
      v10 &= ~0x400uLL;
    if ((v10 & 0x400) != 0)
      objc_opt_self();
  }
  _CFNotificationCenterInitializeDependentNotificationIfNecessary((uint64_t)a2);
  v17 = CFXNotificationRegistrarAdd(*(_QWORD *)(a1 + 16), a2, a3, a5, v10, a6, a7);
  out_token = 0;
  v19 = (void *)_CFAutoreleasePoolPush();
  v20 = atomic_load((unint64_t *)(a1 + 8));
  if ((v20 & 1) != 0)
  {
    maxBufLen[0] = 0;
    v47.length = CFStringGetLength(a2);
    v47.location = 0;
    CFStringGetBytes(a2, v47, 0x8000100u, 0, 0, 0, 0, maxBufLen);
    v34 = (UInt8 *)malloc_type_malloc(maxBufLen[0] + 1, 0x603CF76EuLL);
    v48.length = CFStringGetLength(a2);
    v48.location = 0;
    CFStringGetBytes(a2, v48, 0x8000100u, 0, 0, v34, maxBufLen[0], 0);
    v34[maxBufLen[0]] = 0;
    if (__CFXNotificationCenterDarwinQueue_initOnce != -1)
      dispatch_once(&__CFXNotificationCenterDarwinQueue_initOnce, &__block_literal_global_97);
    maxBufLen[0] = MEMORY[0x1E0C809B0];
    maxBufLen[1] = 3221225472;
    maxBufLen[2] = (CFIndex)____CFXNotificationRegisterObserver_block_invoke;
    maxBufLen[3] = (CFIndex)&__block_descriptor_48_e8_v12__0i8l;
    maxBufLen[4] = a1;
    maxBufLen[5] = v17;
    v35 = notify_register_dispatch((const char *)v34, &out_token, (dispatch_queue_t)__CFXNotificationCenterDarwinQueue_queue, maxBufLen);
    CFXNotificationRegisteredObserverSetNotifyToken(*(_QWORD *)(a1 + 16), v17, out_token);
    free(v34);
    if (v35)
      v17 = 0;
  }
  else
  {
    v21 = atomic_load((unint64_t *)(a1 + 8));
    if ((v21 & 2) != 0)
    {
      maxBufLen[0] = 0;
      v43.length = CFStringGetLength(a2);
      v43.location = 0;
      CFStringGetBytes(a2, v43, 0x8000100u, 0, 0, 0, 0, maxBufLen);
      v22 = (UInt8 *)malloc_type_malloc(maxBufLen[0] + 1, 0x603CF76EuLL);
      v44.length = CFStringGetLength(a2);
      v44.location = 0;
      CFStringGetBytes(a2, v44, 0x8000100u, 0, 0, v22, maxBufLen[0], 0);
      v22[maxBufLen[0]] = 0;
      maxBufLen[0] = 0;
      v45.length = CFStringGetLength(a3);
      v45.location = 0;
      CFStringGetBytes(a3, v45, 0x8000100u, 0, 0, 0, 0, maxBufLen);
      v23 = (UInt8 *)malloc_type_malloc(maxBufLen[0] + 1, 0x603CF76EuLL);
      v46.length = CFStringGetLength(a3);
      v46.location = 0;
      CFStringGetBytes(a3, v46, 0x8000100u, 0, 0, v23, maxBufLen[0], 0);
      v23[maxBufLen[0]] = 0;
      v24 = strcmp("kCFNotificationAnyName", (const char *)v22);
      if (v24 | strcmp("kCFNotificationAnyObject", (const char *)v23) || (getpid(), !sandbox_check()))
      {
        v33 = 1;
      }
      else
      {
        v31 = __CFGenerateReport();
        v32 = "\n\n";
        if (!v31)
          v32 = "";
        CFLog(4, (uint64_t)CFSTR("*** attempt to register for all distributed notifications thwarted by sandboxing.%s%s"), v25, v26, v27, v28, v29, v30, (__int16)v32);
        free(v31);
        v33 = 0;
      }
      v36 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_string(v36, "method", "register");
      xpc_dictionary_set_uint64(v36, "version", 1uLL);
      xpc_dictionary_set_string(v36, "name", (const char *)v22);
      xpc_dictionary_set_string(v36, "object", (const char *)v23);
      xpc_dictionary_set_uint64(v36, "options", v10 & 0xFFFFFFFFFFFFDBFFLL);
      xpc_dictionary_set_uint64(v36, "token", v17);
      v37 = _CFGetProcessPath();
      xpc_dictionary_set_string(v36, "pn", (const char *)*v37);
      CFXNotificationRegisteredObserverSetDistributedConnection(*(_QWORD *)(a1 + 16), v17, *(_QWORD **)(a1 + 24));
      if (v33)
      {
        v38 = *(_xpc_connection_s **)(a1 + 24);
        _CFSuddenTerminationDisable();
        xpc_connection_send_message(v38, v36);
        xpc_connection_send_barrier(v38, &__block_literal_global_99);
      }
      xpc_release(v36);
      free(v23);
      free(v22);
    }
  }
  _CFAutoreleasePoolPop(v19);
  return v17;
}

void _CFNotificationCenterInitializeDependentNotificationIfNecessary(uint64_t a1)
{
  uint64_t i;
  const void **v2;
  const void *v3;
  const void **v4;
  __CFSet *v5;
  const void *v6;
  const void *Value;
  dispatch_once_t *v8;
  _QWORD block[5];
  CFSetCallBacks callBacks;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v11[0] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&_dependentNotificationLock);
  for (i = 0; i != 8; ++i)
  {
    v2 = (const void **)(&_unprocessedDependentNotificationLists)[i];
    if (!v2)
      break;
    v3 = *v2;
    if (*v2)
    {
      v4 = v2 + 1;
      do
      {
        v5 = (__CFSet *)_dependentNotifications;
        if (!_dependentNotifications)
        {
          memset(&callBacks, 0, 32);
          *(_OWORD *)&callBacks.equal = xmmword_1E12E5A08;
          v5 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &callBacks);
          _dependentNotifications = (uint64_t)v5;
        }
        CFSetAddValue(v5, v3);
        v6 = *v4++;
        v3 = v6;
      }
      while (v6);
    }
    (&_unprocessedDependentNotificationLists)[i] = 0;
  }
  memset(&callBacks.retain, 0, sizeof(CFSetCallBacks));
  callBacks.version = (CFIndex)v11;
  Value = CFSetGetValue((CFSetRef)_dependentNotifications, &callBacks);
  os_unfair_lock_unlock((os_unfair_lock_t)&_dependentNotificationLock);
  if (Value)
  {
    v8 = (dispatch_once_t *)*((_QWORD *)Value + 1);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = ___CFNotificationCenterInitializeDependentNotificationIfNecessary_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = Value;
    if (*v8 != -1)
      dispatch_once(v8, block);
  }
}

uint64_t CFXNotificationRegistrarAdd(uint64_t a1, const __CFString *cf, __CFString *cf1, const __CFString *a4, int a5, void *a6, const void *a7)
{
  unsigned int v10;
  const __CFString *v11;
  int v12;
  const __CFString *v13;
  CFHashCode v14;
  CFHashCode v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  int v21;
  uint64_t v22;
  void *v23;
  const void *v24;
  void *v25;
  int v26;
  uint64_t v27;
  uint64_t v29;
  unint64_t v30;
  int v31[2];
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  _OWORD v38[3];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v10 = *(unsigned __int8 *)(a1 + 24);
  if (cf)
  {
    v11 = cf;
    if (CFSTR("kCFNotificationAnyName") != cf && CFEqual(cf, CFSTR("kCFNotificationAnyName")))
      v11 = CFSTR("kCFNotificationAnyName");
  }
  else
  {
    v11 = CFSTR("kCFNotificationAnyName");
  }
  v12 = (v10 >> 1) & 1;
  if (cf1)
  {
    if (v12 && CFSTR("kCFNotificationAnyObject") != cf1 && CFEqual(cf1, CFSTR("kCFNotificationAnyObject")))
      cf1 = CFSTR("kCFNotificationAnyObject");
  }
  else
  {
    cf1 = CFSTR("kCFNotificationAnyObject");
  }
  v13 = CFSTR("kCFNotificationAnyObserver");
  if (a4)
    v13 = a4;
  *(_QWORD *)v31 = v13;
  v14 = CFHash(v11);
  if (v12)
    v15 = CFHash(cf1);
  else
    v15 = ((unint64_t)cf1 >> 5) & 0x7F;
  v16 = (unsigned int *)(a1 + 168);
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 + 1, v16));
  v18 = v17 << 32;
  v36 = -1;
  v37 = -1;
  v35 = -1;
  memset(v38, 0, sizeof(v38));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (v11 == CFSTR("kCFNotificationAnyName"))
  {
    if (cf1 == CFSTR("kCFNotificationAnyObject"))
    {
      v20 = (unsigned int *)(a1 + 80);
      v29 = v18;
      v30 = -1;
      v22 = a1;
      v23 = a6;
      v24 = a7;
      v21 = -1;
      goto LABEL_27;
    }
    v20 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, a1 + 48, cf1, v15, &v36, -1, v12) + 16);
    v21 = v36;
    LODWORD(v30) = -1;
    HIDWORD(v30) = v36;
  }
  else
  {
    if (cf1 == CFSTR("kCFNotificationAnyObject"))
    {
      v20 = (unsigned int *)(_CFXNotificationRegistrarAddName(a1, a1 + 64, v11, v14, &v37, 1) + 24);
      v23 = a6;
      v26 = a5 | 0x800;
      v21 = v37;
      v30 = __PAIR64__(v36, v37);
      v29 = v18;
      v22 = a1;
      v24 = a7;
      v25 = *(void **)v31;
      goto LABEL_29;
    }
    v19 = _CFXNotificationRegistrarAddName(a1, a1 + 32, v11, v14, &v37, 0);
    v20 = (unsigned int *)(_CFXNotificationRegistrarAddObject(a1, v19 + 24, cf1, v15, &v36, v37, v12) + 16);
    v21 = v36;
    v30 = __PAIR64__(v36, v37);
  }
  v29 = v18;
  v22 = a1;
  v23 = a6;
  v24 = a7;
LABEL_27:
  v25 = *(void **)v31;
  v26 = a5;
LABEL_29:
  _CFXNotificationRegistrarAddObserver(v22, v20, v23, v24, v21, v25, &v35, v26, v29, v30, SHIDWORD(v30), (unsigned int *)v38);
  v27 = v35;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationDisposalListRelease((unsigned int *)v38);
  return v18 | v27;
}

void _CFXNotificationPost(unint64_t *a1, void *a2, uint64_t a3)
{
  char v6;
  const __CFString *v7;
  uint64_t v8;
  const __CFString *v9;
  void *v10;
  void *v11;
  char v12;
  UInt8 *v13;
  char v14;
  const void *v15;
  CFDataRef Data;
  void *v17;
  uint64_t v18;
  CFIndex *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  void *v23;
  void **v24;
  void *v25;
  NSObject *DispatchData;
  xpc_object_t v27;
  UInt8 *v28;
  UInt8 *v29;
  xpc_object_t v30;
  double Current;
  double v32;
  uint64_t v33;
  unint64_t v34;
  int64x2_t v35;
  double v36;
  int8x16_t v37;
  float64x2_t v38;
  int8x16_t v39;
  int8x16_t v40;
  uint64_t v41;
  double v42;
  _xpc_connection_s *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  CFIndex v48[34];
  CFRange v49;
  CFRange v50;
  CFRange v51;
  CFRange v52;
  CFRange v53;
  CFRange v54;

  v48[32] = *MEMORY[0x1E0C80C00];
  v6 = atomic_load(a1 + 1);
  if ((v6 & 2) != 0 && (__CFIsDistNoteDaemon & 1) != 0)
    return;
  v7 = (const __CFString *)objc_msgSend(a2, "name");
  v8 = objc_msgSend(a2, "object");
  if (v8)
    v9 = (const __CFString *)v8;
  else
    v9 = CFSTR("kCFNotificationAnyObject");
  if (!a2 || !v7)
  {
    __break(1u);
    return;
  }
  v10 = (void *)_CFAutoreleasePoolPush();
  v11 = v10;
  v12 = atomic_load(a1 + 1);
  if ((a3 & 0x100000) == 0 && (v12 & 1) != 0)
  {
    v48[0] = 0;
    v49.length = CFStringGetLength(v7);
    v49.location = 0;
    CFStringGetBytes(v7, v49, 0x8000100u, 0, 0, 0, 0, v48);
    v13 = (UInt8 *)malloc_type_malloc(v48[0] + 1, 0x603CF76EuLL);
    v50.length = CFStringGetLength(v7);
    v50.location = 0;
    CFStringGetBytes(v7, v50, 0x8000100u, 0, 0, v13, v48[0], 0);
    v13[v48[0]] = 0;
    notify_post((const char *)v13);
    free(v13);
LABEL_11:
    _CFAutoreleasePoolPop(v11);
    return;
  }
  v14 = atomic_load(a1 + 1);
  if ((a3 & 0x100000) != 0 || (v14 & 2) == 0)
  {
    v17 = _CFAutoreleasePoolPop(v10);
    memset(v48, 0, 256);
    MEMORY[0x1E0C80A78](v17, v18);
    bzero(&v45, 0x810uLL);
    v44 = 0x2000000000;
    v46 = &v47;
    CFXNotificationRegistrarFind(a1[2], v7, v9, (unsigned int *)&v44);
    if (v44 < 0x21)
    {
      v19 = v48;
      if ((_DWORD)v44)
      {
LABEL_19:
        v20 = 0;
        v21 = 0;
        v22 = 0;
        do
        {
          if (CFXNotificationRegistrarValidateToken(a1[2], v46[v20 + 6]))
          {
            v23 = _CFXRegistrationPost(a1, (uint64_t)&v46[v20], 0, (uint64_t)a2, (void *)v46[v20 + 2]);
            if (v23)
              v19[v22++] = (CFIndex)v23;
          }
          ++v21;
          v20 += 8;
        }
        while (v21 < v44);
        _CFXNotificationRegistrationBufferDestroy((unsigned int *)&v44);
        if (v22 >= 1)
        {
          v24 = (void **)v19;
          do
          {
            v25 = *v24++;
            objc_msgSend(v25, "waitUntilFinished");

            --v22;
          }
          while (v22);
        }
        goto LABEL_30;
      }
    }
    else
    {
      v19 = (CFIndex *)malloc_type_malloc(8 * v44, 0x80040B8603338uLL);
      if ((_DWORD)v44)
        goto LABEL_19;
    }
    _CFXNotificationRegistrationBufferDestroy((unsigned int *)&v44);
LABEL_30:
    if (v19 != v48)
      free(v19);
    return;
  }
  v15 = (const void *)objc_msgSend(a2, "userInfo");
  if (v15)
  {
    Data = CFPropertyListCreateData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (!Data)
    {
      _CFAutoreleasePoolPop(v11);
      return;
    }
  }
  else
  {
    Data = 0;
  }
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if (Data)
    {
      DispatchData = _CFDataCreateDispatchData(Data);
      v27 = xpc_data_create_with_dispatch_data(DispatchData);
      dispatch_release(DispatchData);
    }
    else
    {
      v27 = 0;
    }
    v48[0] = 0;
    v51.length = CFStringGetLength(v7);
    v51.location = 0;
    CFStringGetBytes(v7, v51, 0x8000100u, 0, 0, 0, 0, v48);
    v28 = (UInt8 *)malloc_type_malloc(v48[0] + 1, 0x603CF76EuLL);
    v52.length = CFStringGetLength(v7);
    v52.location = 0;
    CFStringGetBytes(v7, v52, 0x8000100u, 0, 0, v28, v48[0], 0);
    v28[v48[0]] = 0;
    v48[0] = 0;
    v53.length = CFStringGetLength(v9);
    v53.location = 0;
    CFStringGetBytes(v9, v53, 0x8000100u, 0, 0, 0, 0, v48);
    v29 = (UInt8 *)malloc_type_malloc(v48[0] + 1, 0x603CF76EuLL);
    v54.length = CFStringGetLength(v9);
    v54.location = 0;
    CFStringGetBytes(v9, v54, 0x8000100u, 0, 0, v29, v48[0], 0);
    v29[v48[0]] = 0;
    v30 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v30, "method", "post");
    xpc_dictionary_set_uint64(v30, "version", 1uLL);
    xpc_dictionary_set_string(v30, "name", (const char *)v28);
    xpc_dictionary_set_string(v30, "object", (const char *)v29);
    xpc_dictionary_set_value(v30, "userinfo", v27);
    xpc_dictionary_set_uint64(v30, "options", a3);
    Current = CFAbsoluteTimeGetCurrent();
    os_unfair_lock_lock_with_options();
    v32 = *(double *)&_CFXNotificationPost_lastPost;
    if (*(double *)&_CFXNotificationPost_lastPost == 0.0)
    {
      _CFXNotificationPost_lastPost = *(_QWORD *)&Current;
    }
    else
    {
      v33 = 0;
      v34 = (_CFXNotificationPost_sampleIndex + 1) % 0x64uLL;
      _CFXNotificationPost_lastPost = *(_QWORD *)&Current;
      _CFXNotificationPost_samples[v34] = Current - v32;
      _CFXNotificationPost_sampleIndex = v34;
      v35 = 0uLL;
      v36 = 0.0;
      v37 = (int8x16_t)vdupq_n_s64(0x8000000000000000);
      do
      {
        v38 = *(float64x2_t *)&_CFXNotificationPost_samples[v33];
        v39 = (int8x16_t)vceqzq_f64(v38);
        v35 = vsubq_s64(v35, (int64x2_t)vmvnq_s8(v39));
        v40 = vbslq_s8(v39, v37, (int8x16_t)v38);
        v36 = v36 + *(double *)v40.i64 + *(double *)&v40.i64[1];
        v33 += 2;
      }
      while (v33 != 100);
      v41 = vaddvq_s64(v35);
      if ((unint64_t)v41 >= 0xB && Current - *(double *)&_CFXNotificationPost_lastWarning > 10.0)
      {
        v42 = (double)v41 / v36;
        if (v42 > 60.0)
        {
          _CFXNotificationPost_lastWarning = *(_QWORD *)&Current;
          os_unfair_lock_unlock((os_unfair_lock_t)&_CFXNotificationPost_sampleLock);
          if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
            _CFXNotificationPost_cold_1(v42);
          goto LABEL_54;
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFXNotificationPost_sampleLock);
LABEL_54:
    v43 = (_xpc_connection_s *)a1[3];
    _CFSuddenTerminationDisable();
    xpc_connection_send_message(v43, v30);
    xpc_connection_send_barrier(v43, &__block_literal_global_99);
    xpc_release(v30);
    free(v29);
    free(v28);
    if (v27)
      xpc_release(v27);
    if (Data)
      CFRelease(Data);
    goto LABEL_11;
  }
  if (Data)
    CFRelease(Data);
}

void _CFXNotificationRegistrationBufferDestroy(unsigned int *a1)
{
  uint64_t v2;
  unint64_t v3;
  unsigned int *v4;

  if (*a1)
  {
    v2 = 0;
    v3 = 0;
    do
    {
      _CFXNotificationRegistrationDispose(*((_QWORD *)a1 + 2) + v2, *((unsigned __int8 *)a1 + 8));
      ++v3;
      v2 += 64;
    }
    while (v3 < *a1);
  }
  v4 = (unsigned int *)*((_QWORD *)a1 + 2);
  if (v4 != a1 + 6)
    free(v4);
}

void CFXNotificationRegistrarFind(uint64_t a1, const __CFString *cf1, const __CFString *a3, unsigned int *a4)
{
  int v7;
  const __CFString *v8;
  const __CFString *v9;
  CFHashCode v10;
  unint64_t v11;
  uint64_t Name;
  uint64_t v13;
  uint64_t Object;
  uint64_t v15;
  const __CFString *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFString *v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int v23;
  char v24;
  size_t v25;
  unsigned int v26;
  void *v27;
  _OWORD v28[3];
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v27 = &v29;
  v26 = 0;
  v25 = 32;
  v24 = 0;
  v7 = (*(unsigned __int8 *)(a1 + 24) >> 1) & 1;
  *((_BYTE *)a4 + 8) = (*(_BYTE *)(a1 + 24) & 2) != 0;
  v8 = CFSTR("kCFNotificationAnyName");
  if (cf1)
  {
    v9 = cf1;
    if (CFSTR("kCFNotificationAnyName") == cf1)
    {
      v8 = cf1;
    }
    else if (CFEqual(cf1, CFSTR("kCFNotificationAnyName")))
    {
      v9 = CFSTR("kCFNotificationAnyName");
    }
  }
  else
  {
    v9 = CFSTR("kCFNotificationAnyName");
  }
  if (!a3)
  {
    a3 = CFSTR("kCFNotificationAnyObject");
    v10 = CFHash(v9);
    if (!v7)
      goto LABEL_12;
LABEL_17:
    v11 = CFHash(a3);
    goto LABEL_18;
  }
  if (v7)
  {
    if (CFSTR("kCFNotificationAnyObject") != a3 && CFEqual(a3, CFSTR("kCFNotificationAnyObject")))
      a3 = CFSTR("kCFNotificationAnyObject");
    v10 = CFHash(v9);
    goto LABEL_17;
  }
  v10 = CFHash(v9);
LABEL_12:
  v11 = ((unint64_t)a3 >> 5) & 0x7F;
LABEL_18:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (v9 != v8)
  {
    Name = _CFXNotificationRegistrarFindName(a1, a1 + 32, v9, v10, 0);
    if (Name)
    {
      v13 = Name;
      Object = _CFXNotificationRegistrarFindObject(a1, Name + 24, a3, v11, v7, 0);
      if (Object)
      {
        v15 = Object;
        v16 = (const __CFString *)CFCachedStringCopyString((CFTypeRef *)(v13 + 8));
        _CFXNotificationRegistrarFindObservers((_QWORD *)a1, (unsigned int *)(v15 + 16), v16, *(const __CFString **)(v15 + 8), a4, &v27, &v26, &v25, &v24);
        CFRelease(v16);
      }
    }
  }
  if (a3 != CFSTR("kCFNotificationAnyObject"))
  {
    v17 = _CFXNotificationRegistrarFindObject(a1, a1 + 48, a3, v11, v7, 0);
    if (v17)
      _CFXNotificationRegistrarFindObservers((_QWORD *)a1, (unsigned int *)(v17 + 16), v8, *(const __CFString **)(v17 + 8), a4, &v27, &v26, &v25, &v24);
  }
  v18 = _CFXNotificationRegistrarFindName(a1, a1 + 64, v9, v10, 0);
  if (v18)
  {
    v19 = v18;
    v20 = (const __CFString *)CFCachedStringCopyString((CFTypeRef *)(v18 + 8));
    _CFXNotificationRegistrarFindObservers((_QWORD *)a1, (unsigned int *)(v19 + 24), v20, CFSTR("kCFNotificationAnyObject"), a4, &v27, &v26, &v25, &v24);
    CFRelease(v20);
  }
  _CFXNotificationRegistrarFindObservers((_QWORD *)a1, (unsigned int *)(a1 + 80), v8, CFSTR("kCFNotificationAnyObject"), a4, &v27, &v26, &v25, &v24);
  memset(v28, 0, sizeof(v28));
  v21 = v26;
  if (v26)
  {
    v22 = (unsigned int *)v27;
    do
    {
      v23 = *v22++;
      _CFXNotificationRegistrarInvalidateObserver(a1, v23, -1, -1, (unsigned int *)v28);
      --v21;
    }
    while (v21);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
  _CFXNotificationDisposalListRelease((unsigned int *)v28);
  if ((*(_BYTE *)(a1 + 24) & 1) != 0)
    qsort(*((void **)a4 + 2), *a4, 0x40uLL, (int (__cdecl *)(const void *, const void *))_registrar_compare);
  if (v24)
    free(v27);
}

uint64_t _CFXNotificationRegistrarFindObject(uint64_t a1, uint64_t a2, CFTypeRef cf1, unint64_t a4, int a5, _DWORD *a6)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v12;
  uint64_t v13;
  CFTypeRef v14;

  v6 = *(unsigned int *)(a2 + 8);
  if (!(_DWORD)v6)
    return 0;
  v7 = *(unsigned int *)(*(_QWORD *)a2 + 4 * (a4 % v6));
  if ((_DWORD)v7 == -1)
    return 0;
  while (1)
  {
    v12 = *(_QWORD *)(a1 + 120);
    v13 = v12 + 32 * v7;
    v14 = *(CFTypeRef *)(v13 + 8);
    if (v14 == cf1 || a5 && CFEqual(cf1, v14))
      break;
    v7 = *(unsigned int *)(v12 + 32 * v7 + 4);
    if ((_DWORD)v7 == -1)
      return 0;
  }
  if (a6)
    *a6 = v7;
  return v13;
}

_QWORD *_CFXNotificationRegistrarFindObservers(_QWORD *result, unsigned int *a2, const __CFString *a3, const __CFString *a4, unsigned int *a5, void **a6, unsigned int *a7, size_t *a8, _BYTE *a9)
{
  uint64_t v9;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  size_t v15;
  unsigned int *v16;
  char *v17;
  uint64_t v18;
  CFStringRef *v19;
  uint64_t v20;
  id *v21;
  char *v22;
  unsigned int *v23;
  int v24;
  uint64_t v25;
  size_t v26;
  size_t v27;
  size_t v28;
  void *v29;
  int v33;
  size_t v34;
  void *ptr;
  unsigned int *v36;
  unsigned int v37;
  _QWORD *v39;

  v39 = result;
  v37 = *a7;
  v34 = *a8;
  ptr = *a6;
  v33 = *a9;
  v9 = *a2;
  if ((_DWORD)v9 != -1)
  {
    v36 = a5 + 6;
    do
    {
      v12 = v39[18];
      v13 = *(unsigned int *)(v12 + 56 * v9 + 4);
      v14 = *a5;
      if (a5[1] >= *a5 + 1)
      {
        v17 = (char *)*((_QWORD *)a5 + 2);
      }
      else
      {
        v15 = malloc_good_size((unint64_t)(*a5 + 1) << 6);
        v16 = (unsigned int *)*((_QWORD *)a5 + 2);
        if (v16 == v36)
        {
          v17 = (char *)malloc_type_malloc(v15 & 0x3FFFFFFFC0, 0xBFFB94A8uLL);
          memcpy(v17, *((const void **)a5 + 2), (unint64_t)*a5 << 6);
        }
        else
        {
          v17 = (char *)malloc_type_realloc(v16, v15 & 0x3FFFFFFFC0, 0x2C35A74FuLL);
        }
        a5[1] = v15 >> 6;
        *((_QWORD *)a5 + 2) = v17;
        v14 = *a5;
      }
      v18 = v14;
      v19 = (CFStringRef *)&v17[64 * (unint64_t)v14];
      v20 = v12 + 56 * v9;
      v21 = (id *)(v20 + 8);
      if ((*(_BYTE *)(v20 + 45) & 4) != 0)
      {
        result = objc_loadWeakRetained(v21);
        if (!result)
        {
          v26 = v37 + 1;
          if (v34 < v26)
          {
            v27 = malloc_good_size(4 * v26);
            v28 = v27;
            if (v33)
            {
              result = malloc_type_realloc(ptr, v27 & 0x3FFFFFFFCLL, 0x2C35A74FuLL);
              ptr = result;
            }
            else
            {
              v29 = malloc_type_malloc(v27 & 0x3FFFFFFFCLL, 0xBFFB94A8uLL);
              result = memcpy(v29, ptr, 4 * v37);
              v33 = 1;
              ptr = v29;
            }
            v34 = v28 >> 2;
          }
          *((_DWORD *)ptr + v37++) = v9;
          goto LABEL_17;
        }
        *(_QWORD *)&v17[64 * v18 + 16] = result;
        v14 = *a5;
      }
      else
      {
        v19[2] = (CFStringRef)*v21;
      }
      *a5 = v14 + 1;
      v22 = &v17[64 * v18];
      v24 = *(_DWORD *)(v20 + 44);
      v23 = (unsigned int *)(v20 + 44);
      CFXNotificationHandlerCopy((_QWORD *)v22 + 4, *(void **)(v12 + 56 * v9 + 16), *(CFTypeRef *)(v12 + 56 * v9 + 24), v24);
      *v19 = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a3);
      result = &a4->isa;
      if (*((_BYTE *)a5 + 8))
        result = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a4);
      *((_QWORD *)v22 + 1) = result;
      *((_QWORD *)v22 + 3) = *v23;
      v25 = v12 + 56 * v9;
      *((_QWORD *)v22 + 6) = v9 | ((unint64_t)*(unsigned int *)(v25 + 40) << 32);
      *((_QWORD *)v22 + 7) = *(_QWORD *)(v25 + 32);
LABEL_17:
      v9 = v13;
    }
    while (v13 != 0xFFFFFFFFLL);
  }
  *a6 = ptr;
  *a7 = v37;
  *a8 = v34;
  *a9 = v33;
  return result;
}

BOOL _CFXNotificationRegistrarRemoveObservers(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v4;
  uint64_t v7;
  unsigned int v8;
  _OWORD v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v4 = *a2;
  memset(v10, 0, sizeof(v10));
  if (v4 == -1)
  {
LABEL_6:
    _CFXNotificationDisposalListRelease((unsigned int *)v10);
    return a2[1] == 0;
  }
  else
  {
    while (1)
    {
      v7 = *(_QWORD *)(a1 + 144);
      v8 = v4;
      v4 = *(_DWORD *)(v7 + 56 * v4 + 4);
      if ((!a3 || *(_QWORD *)(v7 + 56 * v8 + 8) == a3)
        && _CFXNotificationRegistrarRecycleObserverRegistration(a1, a2, v8, (unsigned int *)v10))
      {
        return 1;
      }
      if (v4 == -1)
        goto LABEL_6;
    }
  }
}

void _CFXNotificationDisposalListRelease(unsigned int *a1)
{
  unsigned int v2;
  int v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;

  v2 = *a1;
  if (*a1 >= 4)
    v3 = 4;
  else
    v3 = *a1;
  if (v3)
  {
    v4 = 1;
    do
    {
      CFRelease(*(CFTypeRef *)&a1[2 * v4]);
      v2 = *a1;
      if (*a1 >= 4)
        v5 = 4;
      else
        v5 = v2;
    }
    while (v4++ < v5);
  }
  if (v2 >= 5)
  {
    v7 = 0;
    do
    {
      CFRelease(*(CFTypeRef *)(*((_QWORD *)a1 + 5) + 8 * v7));
      v8 = v7 + 5;
      ++v7;
    }
    while (v8 < *a1);
  }
}

_DWORD *_CFXNotificationRegistrarAddObserver(uint64_t a1, unsigned int *a2, void *aBlock, CFTypeRef cf, int a5, void *a6, unsigned int *a7, int a8, uint64_t a9, int a10, int a11, unsigned int *a12)
{
  int v12;
  void *v14;
  int v15;
  unsigned int v18;
  uint64_t v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  size_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  uint64_t v28;
  char *v29;
  char *v30;
  int v31;
  uint64_t v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  _DWORD *v38;
  char *v39;
  unsigned int v40;
  uint64_t v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int v44;
  void *v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  unsigned int v49;
  _DWORD *v50;
  int v51;
  unsigned int v52;
  uint64_t v53;
  id *v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  _DWORD *result;
  int v59;
  uint64_t v60;
  int v61;
  unsigned int *v62;
  unsigned int *v63;
  void *v65;
  CFTypeRef v66;
  uint64_t v68;
  _OWORD *ptr;
  _OWORD __src[8];
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  if ((*(_QWORD *)&a8 & 0xE0000) == 0)
    _CFXNotificationRegistrarAddObserver_cold_1();
  v12 = a8;
  v14 = a6;
  v15 = a5;
  v18 = *(_DWORD *)(a1 + 160);
  if (v18 != -1)
    goto LABEL_3;
  v23 = *(_DWORD *)(a1 + 156);
  if (v23 == -1)
    goto LABEL_40;
  v65 = aBlock;
  v66 = cf;
  v24 = malloc_good_size(56 * v23 + 56);
  v25 = *(unsigned int *)(a1 + 156);
  v26 = v24 / 0x38;
  v27 = *(char **)(a1 + 144);
  v28 = (v24 / 0x38);
  v29 = (char *)malloc_type_malloc(56 * v28, 0xBFFB94A8uLL);
  v30 = v29;
  memset(__src, 0, sizeof(__src));
  if (!(_DWORD)v25)
  {
    *(_QWORD *)(a1 + 144) = v29;
    v45 = v27;
    v14 = a6;
LABEL_30:
    free(v45);
    goto LABEL_31;
  }
  v60 = v28;
  v61 = v26;
  v62 = a7;
  v63 = a2;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v68 = 32;
  v34 = a11;
  ptr = __src;
  do
  {
    v35 = *(_QWORD *)&v27[v32 + 8];
    if ((v27[v32 + 45] & 4) == 0)
    {
      *(_QWORD *)&v30[v32 + 8] = v35;
      goto LABEL_21;
    }
    if (v35)
    {
      objc_moveWeak((id *)&v30[v32 + 8], (id *)&v27[v32 + 8]);
      goto LABEL_21;
    }
    v36 = v33++;
    if (v33 <= v68)
    {
      v37 = v68;
LABEL_19:
      v38 = ptr;
      goto LABEL_20;
    }
    v37 = (v68 + 1);
    if (ptr == __src)
    {
      ptr = malloc_type_malloc(4 * (v68 + 1), 0xBFFB94A8uLL);
      memcpy(ptr, __src, 4 * v68);
      goto LABEL_19;
    }
    v38 = malloc_type_realloc(ptr, 4 * (v68 + 1), 0x2C35A74FuLL);
LABEL_20:
    v38[v36] = v31;
    *(_QWORD *)&v30[v32 + 8] = 0;
    v68 = v37;
    ptr = v38;
    v34 = a11;
LABEL_21:
    v39 = &v30[v32];
    *(_QWORD *)v39 = *(_QWORD *)&v27[v32];
    *((_OWORD *)v39 + 1) = *(_OWORD *)&v27[v32 + 16];
    *((_QWORD *)v39 + 4) = *(_QWORD *)&v27[v32 + 32];
    *((_QWORD *)v39 + 5) = *(_QWORD *)&v27[v32 + 40];
    *((_DWORD *)v39 + 12) = *(_DWORD *)&v27[v32 + 48];
    v32 += 56;
    ++v31;
  }
  while (56 * v25 != v32);
  *(_QWORD *)(a1 + 144) = v30;
  free(v27);
  v40 = v33;
  a7 = v62;
  a2 = v63;
  v14 = a6;
  if (v40)
  {
    v41 = v40;
    v42 = (unsigned int *)ptr;
    do
    {
      v44 = *v42++;
      v43 = v44;
      if (v44 != v34)
        _CFXNotificationRegistrarInvalidateObserver(a1, v43, a10, v34, a12);
      --v41;
    }
    while (v41);
  }
  v45 = ptr;
  v28 = v60;
  LODWORD(v26) = v61;
  if (ptr != __src)
    goto LABEL_30;
LABEL_31:
  if (v25 >= v26)
  {
    v51 = *(_DWORD *)(a1 + 156);
    aBlock = v65;
    cf = v66;
  }
  else
  {
    v46 = 56 * v25;
    aBlock = v65;
    cf = v66;
    do
    {
      v47 = &v30[v46];
      *((_QWORD *)v47 + 1) = 0;
      *((_QWORD *)v47 + 2) = 0;
      *((_QWORD *)v47 + 3) = 0;
      *(_QWORD *)(v47 + 44) = 0xFFFFFFFF00008000;
      v48 = *(_QWORD *)(a1 + 144);
      v49 = *(_DWORD *)(a1 + 160);
      if (v49 != -1)
        *(_DWORD *)(v48 + 56 * v49) = v25;
      v50 = (_DWORD *)(v48 + v46);
      *v50 = -1;
      v50[1] = v49;
      v51 = *(_DWORD *)(a1 + 156) + 1;
      *(_DWORD *)(a1 + 156) = v51;
      *(_DWORD *)(a1 + 160) = v25++;
      v46 += 56;
    }
    while (v28 != v25);
  }
  v15 = a5;
  if (v51 != (_DWORD)v26)
    _CFXNotificationRegistrarAddObserver_cold_2();
  v18 = *(_DWORD *)(a1 + 160);
  if (v18 == -1)
  {
LABEL_40:
    v19 = *(_QWORD *)(a1 + 144);
    v18 = -1;
    goto LABEL_41;
  }
LABEL_3:
  v19 = *(_QWORD *)(a1 + 144);
  v20 = (unsigned int *)(v19 + 56 * v18);
  v21 = *v20;
  v22 = v20[1];
  *(_DWORD *)(a1 + 160) = v22;
  if (v21 != -1)
    *(_DWORD *)(v19 + 56 * v21 + 4) = v22;
  if (v22 != -1)
    *(_DWORD *)(v19 + 56 * v22) = v21;
LABEL_41:
  ++*(_DWORD *)(a1 + 152);
  v52 = v18;
  *a7 = v18;
  v53 = v19 + 56 * v18;
  CFXNotificationHandlerCopy((_QWORD *)(v53 + 16), aBlock, cf, v12);
  *(_DWORD *)(v53 + 40) = HIDWORD(a9);
  *(_DWORD *)(v53 + 48) = v15;
  v54 = (id *)(v53 + 8);
  if ((v12 & 0x400) != 0)
  {
    if (!objc_storeWeakOrNil(v54, v14))
    {
      *v54 = v14;
      v12 &= ~0x400u;
    }
  }
  else
  {
    *v54 = v14;
  }
  v55 = v19 + 56 * v52;
  *(_DWORD *)(v55 + 44) = v12;
  *(_QWORD *)(v55 + 32) = 0;
  v56 = *a7;
  v57 = *a2;
  if (*a2 != -1)
    *(_DWORD *)(*(_QWORD *)(a1 + 144) + 56 * v57) = v56;
  result = (_DWORD *)(v19 + 56 * v52);
  *result = -1;
  result[1] = v57;
  v59 = a2[1] + 1;
  *a2 = v56;
  a2[1] = v59;
  return result;
}

_QWORD *CFXNotificationHandlerCopy(_QWORD *result, void *aBlock, CFTypeRef cf, int a4)
{
  _QWORD *v4;

  v4 = result;
  *result = 0;
  result[1] = 0;
  if ((a4 & 0x20000) != 0)
  {
    if (aBlock)
    {
      result = _Block_copy(aBlock);
      *v4 = result;
    }
    if (cf)
    {
      result = CFRetain(cf);
      v4[1] = result;
    }
  }
  else if ((a4 & 0x40000) != 0 || (a4 & 0x80000) != 0)
  {
    *result = aBlock;
  }
  return result;
}

uint64_t _CFXNotificationRegistrarAddName(uint64_t a1, uint64_t a2, const void *a3, unint64_t a4, unsigned int *a5, int a6)
{
  unint64_t v8;
  uint64_t Name;
  unsigned int v13;
  _DWORD *v14;
  size_t v15;
  uint64_t v16;
  void *v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  int *v23;
  int v24;
  int v25;
  _QWORD *v26;
  unsigned int v27;
  unsigned int v28;
  size_t v29;
  size_t v30;
  unsigned int v31;
  _DWORD *v32;
  size_t v33;
  unsigned int v34;
  size_t v35;
  _DWORD *v36;
  _DWORD *v37;
  _DWORD *v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unint64_t v48;
  unsigned int v49;
  unint64_t v50;
  unsigned int v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  unsigned int v55;
  _DWORD *v56;
  unsigned int v58;
  unint64_t v59;

  v8 = a4;
  Name = _CFXNotificationRegistrarFindName(a1, a2, a3, a4, a5);
  if (Name)
    return Name;
  v13 = *(_DWORD *)(a1 + 112);
  if (v13 == -1)
  {
    v15 = malloc_good_size(40 * (*(_DWORD *)(a1 + 108) + 1)) / 0x28;
    v16 = *(unsigned int *)(a1 + 108);
    v17 = *(void **)(a1 + 96);
    if (v17)
      v18 = malloc_type_realloc(v17, 40 * v15, 0x2C35A74FuLL);
    else
      v18 = malloc_type_malloc(40 * v15, 0xBFFB94A8uLL);
    v14 = v18;
    *(_DWORD *)(a1 + 108) = v15;
    *(_QWORD *)(a1 + 96) = v18;
    if (v16 < v15)
    {
      v19 = 40 * v16 + 36;
      do
      {
        v20 = *(_QWORD *)(a1 + 96);
        v21 = *(_DWORD *)(a1 + 112);
        if (v21 != -1)
          *(_DWORD *)(v20 + 40 * v21) = v16;
        v22 = v20 + v19;
        *(_DWORD *)(v22 - 36) = -1;
        *(_DWORD *)(v22 - 32) = v21;
        *(_DWORD *)(a1 + 112) = v16;
        *(_QWORD *)(v22 - 28) = 0;
        *(_DWORD *)(v22 - 4) = 0;
        *(_QWORD *)(*(_QWORD *)(a1 + 96) + v19 - 12) = 0;
        *(_DWORD *)(*(_QWORD *)(a1 + 96) + v19) = 0;
        ++v16;
        v19 += 40;
      }
      while (v15 != v16);
      v14 = *(_DWORD **)(a1 + 96);
    }
    v13 = *(_DWORD *)(a1 + 112);
    if (v13 == -1)
      goto LABEL_18;
  }
  else
  {
    v14 = *(_DWORD **)(a1 + 96);
  }
  v23 = &v14[10 * v13];
  v24 = *v23;
  v25 = v23[1];
  *(_DWORD *)(a1 + 112) = v25;
  if (v24 != -1)
    v14[10 * v24 + 1] = v25;
  if (v25 != -1)
    v14[10 * v25] = v24;
LABEL_18:
  ++*(_DWORD *)(a1 + 104);
  *a5 = v13;
  Name = (uint64_t)&v14[10 * v13];
  _CFXNotificationRegistrarAddCachedName(a3, (void **)(Name + 8));
  v26 = (_QWORD *)(Name + 24);
  if (a6 == 1)
  {
    *v26 = 0xFFFFFFFFLL;
  }
  else
  {
    *v26 = 0;
    *(_QWORD *)(Name + 32) = 0;
  }
  v27 = *a5;
  v28 = 31 - __clz(*(_DWORD *)(a2 + 12) + 1);
  if (v28 <= 1)
    v28 = 1;
  v29 = malloc_good_size(4 * v28);
  v30 = v29 >> 2;
  if (!(v29 >> 2))
    _CFXNotificationRegistrarAddName_cold_1();
  v31 = v13;
  v32 = *(_DWORD **)a2;
  if (*(_DWORD *)(a2 + 8) >= v30)
  {
    v37 = *(_DWORD **)a2;
  }
  else
  {
    v33 = v29;
    v58 = v31;
    v59 = v8;
    v34 = v27;
    v35 = v29 & 0x3FFFFFFFCLL;
    v36 = malloc_type_malloc(v29 & 0x3FFFFFFFCLL, 0xBFFB94A8uLL);
    v37 = v36;
    if (v32)
    {
      memset(v36, 255, v35);
      v38 = *(_DWORD **)a2;
      v39 = *(unsigned int *)(a2 + 8);
      v27 = v34;
      v8 = v59;
      if ((_DWORD)v39)
      {
        v40 = 0;
        v41 = *(unsigned int *)(a2 + 8);
        do
        {
          v42 = v38[v40];
          if ((_DWORD)v42 != -1)
          {
            v43 = *(_QWORD *)(a1 + 96);
            do
            {
              v44 = v43 + 40 * v42;
              v47 = *(_DWORD *)(v44 + 4);
              v46 = v44 + 4;
              v45 = v47;
              v48 = *(_QWORD *)(v46 + 12);
              if (v38)
              {
                v49 = *(_DWORD *)(v43 + 40 * v42);
                if (v38[v48 % v39] == v42)
                  v38[v48 % v39] = v45;
                if (v49 != -1)
                  *(_DWORD *)(v43 + 40 * v49 + 4) = v45;
                if (v45 != 0xFFFFFFFFLL)
                  *(_DWORD *)(v43 + 40 * v45) = v49;
              }
              if (v37)
              {
                v50 = v48 % (v33 >> 2);
                v51 = v37[v50];
                if (v51 != -1)
                  *(_DWORD *)(v43 + 40 * v51) = v42;
                *(_DWORD *)(v43 + 40 * v42) = -1;
                *(_DWORD *)v46 = v51;
                v37[v50] = v42;
              }
              v42 = v45;
            }
            while (v45 != 0xFFFFFFFFLL);
            v41 = *(unsigned int *)(a2 + 8);
          }
          ++v40;
        }
        while (v40 < v41);
      }
      *(_QWORD *)a2 = v37;
      *(_DWORD *)(a2 + 8) = v30;
      free(v38);
      v37 = *(_DWORD **)a2;
    }
    else
    {
      *(_QWORD *)a2 = v36;
      *(_DWORD *)(a2 + 8) = v30;
      memset(v36, 255, v35);
      v27 = v34;
      v8 = v59;
    }
    v31 = v58;
  }
  v52 = *(unsigned int *)(a2 + 8);
  *(_QWORD *)&v14[10 * v31 + 4] = v8;
  if (v27 != -1 && v37)
  {
    v53 = v8 % v52;
    v54 = *(_QWORD *)(a1 + 96);
    v55 = v37[v53];
    if (v55 != -1)
      *(_DWORD *)(v54 + 40 * v55) = v27;
    v56 = (_DWORD *)(v54 + 40 * v27);
    *v56 = -1;
    v56[1] = v55;
    v37[v53] = v27;
  }
  ++*(_DWORD *)(a2 + 12);
  return Name;
}

BOOL _CFXNotificationRegistrarRemoveObjects(uint64_t a1, uint64_t a2, const __CFString *cf1, unint64_t a4, int a5, uint64_t a6)
{
  unint64_t v7;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  const __CFString *v15;
  uint64_t i;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v7 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v7)
  {
    if (CFSTR("kCFNotificationAnyObject") == cf1)
    {
      for (i = 0; i != v7; ++i)
      {
        v18 = *(unsigned int *)(*(_QWORD *)a2 + 4 * i);
        if ((_DWORD)v18 != -1)
        {
          do
          {
            v19 = *(_QWORD *)(a1 + 120) + 32 * v18;
            v20 = *(unsigned int *)(v19 + 4);
            if (_CFXNotificationRegistrarRemoveObservers(a1, (unsigned int *)(v19 + 16), a6))
              _CFXNotificationRegistrarRecycleObjectRegistration(a1, (uint64_t *)a2, v18, a5);
            v18 = v20;
          }
          while (v20 != 0xFFFFFFFFLL);
        }
      }
    }
    else
    {
      v12 = *(_DWORD *)(*(_QWORD *)a2 + 4 * (a4 % v7));
      while (v12 != -1)
      {
        v13 = v12;
        v14 = *(_QWORD *)(a1 + 120) + 32 * v12;
        v12 = *(_DWORD *)(v14 + 4);
        v15 = *(const __CFString **)(v14 + 8);
        if ((v15 == cf1 || a5 && CFEqual(cf1, v15))
          && _CFXNotificationRegistrarRemoveObservers(a1, (unsigned int *)(v14 + 16), a6)
          && _CFXNotificationRegistrarRecycleObjectRegistration(a1, (uint64_t *)a2, v13, a5))
        {
          return 1;
        }
      }
    }
  }
  return *(_DWORD *)(a2 + 12) == 0;
}

void _CFXNotificationRegistrationDispose(uint64_t a1, int a2)
{
  uint64_t v4;
  const void *v5;
  _OWORD v6[3];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 24);
  memset(v6, 0, sizeof(v6));
  _CFXNotificationHandlerRelease((uint64_t *)(a1 + 32), v4, (unsigned int *)v6);
  _CFXNotificationDisposalListRelease((unsigned int *)v6);
  if (a2)
  {
    v5 = *(const void **)(a1 + 8);
    if (v5)
      CFRelease(v5);
  }
  if ((*(_BYTE *)(a1 + 25) & 4) != 0)

  if (*(_QWORD *)a1)
    CFRelease(*(CFTypeRef *)a1);
}

BOOL CFXNotificationRegistrarValidateToken(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  _BOOL8 v6;

  v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  v6 = *(_DWORD *)(a1 + 156) > a2
    && (v5 = *(_QWORD *)(a1 + 144), *(_DWORD *)(v5 + 56 * a2 + 40) == HIDWORD(a2))
    && (*(_BYTE *)(v5 + 56 * a2 + 45) & 0x80) == 0;
  os_unfair_lock_unlock(v4);
  return v6;
}

void *_CFXRegistrationPost(const void *a1, uint64_t a2, int a3, uint64_t a4, void *a5)
{
  void *v5;
  uint64_t v11;
  uint64_t v12;
  id v13;
  uint64_t v14;
  char v15;
  NSObject *global_queue;
  qos_class_t v17;
  _QWORD block[2];
  void (*v20)(uint64_t);
  void *v21;
  uint64_t v22;
  __int128 v23;
  const void *v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  char v28;
  __int128 v29;
  uint64_t v30;

  v5 = 0;
  v30 = *MEMORY[0x1E0C80C00];
  if (a2 && a4)
  {
    if (!_CFXRegistrationPost_operationQueueClass)
      _CFXRegistrationPost_operationQueueClass = (uint64_t)objc_lookUpClass("NSOperationQueue");
    if (!_CFXRegistrationPost_blockOperationClass)
      _CFXRegistrationPost_blockOperationClass = (uint64_t)objc_lookUpClass("NSBlockOperation");
    v29 = 0uLL;
    v11 = *(_QWORD *)(a2 + 24);
    CFXNotificationHandlerCopy(&v29, *(void **)(a2 + 32), *(CFTypeRef *)(a2 + 40), v11);
    v12 = *((_QWORD *)&v29 + 1) & (v11 << 46 >> 63);
    if ((v11 & 0x400) != 0)
      v13 = a5;
    v14 = *(_QWORD *)(a2 + 48);
    if (v11 & 0x10000 | v12)
      v15 = 1;
    else
      v15 = a3;
    CFRetain(a1);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    v20 = ___CFXRegistrationPost_block_invoke;
    v21 = &unk_1E12E5AA0;
    v23 = v29;
    v28 = v15;
    v24 = a1;
    v25 = v14;
    v22 = a4;
    v26 = a5;
    v27 = v11;
    if (v12)
    {
      if (objc_msgSend((id)_CFXRegistrationPost_operationQueueClass, "currentQueue") != v12
        && (pthread_main_np() != 1 || objc_msgSend((id)_CFXRegistrationPost_operationQueueClass, "mainQueue") != v12))
      {
        v5 = (void *)objc_opt_new();
        objc_msgSend(v5, "addExecutionBlock:", block);
        objc_msgSend((id)v12, "addOperation:", v5);
        return v5;
      }
      goto LABEL_20;
    }
    if ((*(_BYTE *)(a2 + 26) & 1) != 0)
    {
      v17 = qos_class_main();
      global_queue = dispatch_get_global_queue(v17, 2uLL);
    }
    else
    {
      if (!a3)
      {
LABEL_20:
        v20((uint64_t)block);
        return 0;
      }
      global_queue = MEMORY[0x1E0C80D38];
    }
    dispatch_async(global_queue, block);
    return 0;
  }
  return v5;
}

id __CFNOTIFICATIONCENTER_IS_CALLING_OUT_TO_AN_OBSERVER__(id result, const char *a2, uint64_t a3, void *a4, void *a5, int a6)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  const __CFString *v12;
  char v13;
  uint64_t v14;

  if ((void *)kCFXNotificationPlaceholderObserver == a4)
    v8 = 0;
  else
    v8 = a4;
  if ((a6 & 0x20000) != 0)
    return (id)(*((uint64_t (**)(const char *, void *))a2 + 2))(a2, a5);
  if ((a6 & 0x40000) != 0)
    return objc_msgSend(v8, a2, a5);
  if ((a6 & 0x80000) != 0)
  {
    v9 = (uint64_t)result;
    v10 = objc_msgSend(a5, "name");
    v11 = atomic_load((unint64_t *)(v9 + 8));
    if ((v11 & 1) != 0)
      v12 = CFSTR("kCFNotificationAnyObject");
    else
      v12 = (const __CFString *)objc_msgSend(a5, "object");
    v13 = atomic_load((unint64_t *)(v9 + 8));
    if ((v13 & 1) != 0)
      v14 = 0;
    else
      v14 = objc_msgSend(a5, "userInfo");
    return (id)((uint64_t (*)(uint64_t, void *, uint64_t, const __CFString *, uint64_t))a2)(v9, v8, v10, v12, v14);
  }
  return result;
}

void CFXNotificationHandlerRelease(uint64_t *a1, int a2)
{
  _OWORD v2[3];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  memset(v2, 0, sizeof(v2));
  _CFXNotificationHandlerRelease(a1, a2, (unsigned int *)v2);
  _CFXNotificationDisposalListRelease((unsigned int *)v2);
}

uint64_t *_CFXNotificationHandlerRelease(uint64_t *result, int a2, unsigned int *a3)
{
  uint64_t *v3;
  uint64_t v5;

  v3 = result;
  if ((a2 & 0x20000) != 0)
  {
    if (*result)
      result = (uint64_t *)__CFXNotificationDisposalListAddItem(a3, *result);
    v5 = v3[1];
    if (v5)
      result = (uint64_t *)__CFXNotificationDisposalListAddItem(a3, v5);
  }
  *v3 = 0;
  v3[1] = 0;
  return result;
}

void _CFXNotificationRegistrarAddCachedName(const void *a1, void **a2)
{
  const __CFDictionary *NamePool;
  char *Value;
  void *key[2];

  key[1] = *(void **)MEMORY[0x1E0C80C00];
  key[0] = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  NamePool = _CFXNotificationRegistrarGetNamePool();
  if ((CFDictionaryGetKeyIfPresent((uint64_t)NamePool, (unint64_t)a1, key) & 1) != 0)
  {
    Value = (char *)CFDictionaryGetValue(NamePool, key[0]);
    CFDictionarySetValue(NamePool, key[0], Value + 1);
  }
  else
  {
    CFDictionarySetValue(NamePool, a1, (const void *)1);
    CFDictionaryGetKeyIfPresent((uint64_t)NamePool, (unint64_t)a1, key);
  }
  *a2 = key[0];
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
}

uint64_t CFDictionaryGetKeyIfPresent(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5 = 0u;
  v6 = 0u;
  CFBasicHashFindBucket(a1, a2, (uint64_t *)&v5);
  if (!*((_QWORD *)&v6 + 1))
    return 0;
  if (a3)
    *a3 = *((_QWORD *)&v5 + 1);
  return 1;
}

CFMutableDictionaryRef _CFXNotificationRegistrarGetNamePool()
{
  CFMutableDictionaryRef result;

  os_unfair_lock_assert_owner((const os_unfair_lock *)&__CFXNotificationRegistrarNamePoolLock);
  result = (CFMutableDictionaryRef)__CFXNotificationRegistrarNamePool;
  if (!__CFXNotificationRegistrarNamePool)
  {
    result = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, 0);
    __CFXNotificationRegistrarNamePool = (uint64_t)result;
  }
  return result;
}

uint64_t _CFXNotificationRegistrarAddObject(uint64_t a1, uint64_t a2, void *a3, unint64_t a4, unsigned int *a5, int a6, int a7)
{
  unint64_t v10;
  uint64_t v12;
  uint64_t Object;
  unsigned int v15;
  _DWORD *v16;
  unint64_t v17;
  size_t v18;
  size_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void **v28;
  unsigned int v29;
  unsigned int v30;
  size_t v31;
  unsigned int *v32;
  size_t v33;
  size_t v34;
  unsigned int *v35;
  unsigned int *v36;
  unsigned int *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  CFHashCode v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v52;
  unint64_t v53;
  size_t v54;
  unsigned int v55;
  _DWORD *v56;
  uint64_t v57;

  v10 = a4;
  v12 = a2;
  Object = _CFXNotificationRegistrarFindObject(a1, a2, a3, a4, a7, a5);
  if (Object)
    return Object;
  v15 = *(_DWORD *)(a1 + 136);
  if (v15 == -1)
  {
    v17 = v10;
    v18 = malloc_good_size(32 * (*(_DWORD *)(a1 + 132) + 1));
    v19 = v18 >> 5;
    v20 = *(unsigned int *)(a1 + 132);
    v21 = *(void **)(a1 + 120);
    if (v21)
      v16 = malloc_type_realloc(v21, v18 & 0x1FFFFFFFE0, 0x2C35A74FuLL);
    else
      v16 = malloc_type_malloc(v18 & 0x1FFFFFFFE0, 0xBFFB94A8uLL);
    *(_DWORD *)(a1 + 132) = v19;
    *(_QWORD *)(a1 + 120) = v16;
    if (v20 < v19)
    {
      v22 = (uint64_t)&v16[8 * v20 + 4];
      do
      {
        v23 = *(unsigned int *)(a1 + 136);
        if ((_DWORD)v23 != -1)
          v16[8 * v23] = v20;
        *(_DWORD *)(v22 - 16) = -1;
        *(_DWORD *)(v22 - 12) = v23;
        *(_DWORD *)(a1 + 136) = v20;
        *(_DWORD *)(v22 + 8) = -1;
        ++v20;
        *(_QWORD *)(v22 - 8) = 0;
        *(_QWORD *)v22 = 0xFFFFFFFFLL;
        v22 += 32;
      }
      while ((v18 >> 5) != v20);
    }
    v15 = *(_DWORD *)(a1 + 136);
    v10 = v17;
    if (v15 == -1)
      goto LABEL_17;
  }
  else
  {
    v16 = *(_DWORD **)(a1 + 120);
  }
  v24 = &v16[8 * v15];
  v25 = *v24;
  v26 = v24[1];
  *(_DWORD *)(a1 + 136) = v26;
  if ((_DWORD)v25 != -1)
    v16[8 * v25 + 1] = v26;
  if ((_DWORD)v26 != -1)
    v16[8 * v26] = v25;
LABEL_17:
  ++*(_DWORD *)(a1 + 128);
  *a5 = v15;
  v27 = v15;
  v56 = v16;
  Object = (uint64_t)&v16[8 * v15];
  *(_DWORD *)(Object + 24) = -1;
  *(_QWORD *)(Object + 16) = 0xFFFFFFFFLL;
  v28 = (void **)(Object + 8);
  if (a7)
    _CFXNotificationRegistrarAddCachedName(a3, v28);
  else
    *v28 = a3;
  *(_DWORD *)(Object + 24) = a6;
  v29 = *a5;
  v30 = 31 - __clz(*(_DWORD *)(v12 + 12) + 1);
  if (v30 <= 1)
    v30 = 1;
  v31 = malloc_good_size(4 * v30);
  if (!(v31 >> 2))
    _CFXNotificationRegistrarAddObject_cold_1();
  v32 = *(unsigned int **)v12;
  if (*(_DWORD *)(v12 + 8) >= (v31 >> 2))
  {
    v36 = *(unsigned int **)v12;
  }
  else
  {
    v33 = v31;
    v54 = v31 >> 2;
    v55 = v29;
    v34 = v31 & 0x3FFFFFFFCLL;
    v35 = (unsigned int *)malloc_type_malloc(v31 & 0x3FFFFFFFCLL, 0xBFFB94A8uLL);
    v36 = v35;
    if (v32)
    {
      v52 = Object;
      v53 = v10;
      memset(v35, 255, v34);
      v37 = *(unsigned int **)v12;
      v57 = v12;
      v38 = *(unsigned int *)(v12 + 8);
      if ((_DWORD)v38)
      {
        v39 = 0;
        v40 = (v33 >> 2);
        do
        {
          v41 = v37[v39];
          if ((_DWORD)v41 != -1)
          {
            do
            {
              v42 = *(_QWORD *)(a1 + 120);
              v43 = v42 + 32 * v41;
              v44 = *(_QWORD *)(v43 + 8);
              if (a7)
                v45 = CFHash((CFTypeRef)v44);
              else
                v45 = (v44 >> 5) & 0x7F;
              v46 = v42 + 32 * v41;
              v47 = *(unsigned int *)(v46 + 4);
              v48 = v36[v45 % v40];
              *(_DWORD *)(v46 + 4) = v48;
              *(_DWORD *)v43 = -1;
              if ((_DWORD)v48 != -1)
                *(_DWORD *)(*(_QWORD *)(a1 + 120) + 32 * v48) = v41;
              v36[v45 % v40] = v41;
              v41 = v47;
            }
            while (v47 != 0xFFFFFFFFLL);
            v38 = *(unsigned int *)(v57 + 8);
          }
          ++v39;
        }
        while (v39 < v38);
      }
      v12 = v57;
      *(_QWORD *)v57 = v36;
      *(_DWORD *)(v57 + 8) = v54;
      free(v37);
      v36 = *(unsigned int **)v57;
      Object = v52;
      v10 = v53;
    }
    else
    {
      *(_QWORD *)v12 = v35;
      *(_DWORD *)(v12 + 8) = v54;
      memset(v35, 255, v34);
    }
    v29 = v55;
  }
  v49 = v10 % *(unsigned int *)(v12 + 8);
  v50 = v36[v49];
  if ((_DWORD)v50 != -1)
    *(_DWORD *)(*(_QWORD *)(a1 + 120) + 32 * v50) = v29;
  *(_DWORD *)Object = -1;
  v56[8 * v27 + 1] = v50;
  v36[v49] = v29;
  ++*(_DWORD *)(v12 + 12);
  return Object;
}

CFTypeRef CFCachedStringCopyString(CFTypeRef *a1)
{
  CFTypeRef v2;

  os_unfair_lock_lock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  v2 = CFRetain(*a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFXNotificationRegistrarNamePoolLock);
  return v2;
}

unsigned int *__CFXNotificationDisposalListAddItem(unsigned int *result, uint64_t a2)
{
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;

  v3 = result;
  v4 = *result;
  v5 = (v4 - 3);
  if (v4 > 3)
  {
    v7 = result[1];
    result = (unsigned int *)*((_QWORD *)result + 5);
    if (v7 < v5)
    {
      if (result)
        result = (unsigned int *)malloc_type_realloc(result, (v4 - 3), 0x560EF604uLL);
      else
        result = (unsigned int *)malloc_type_malloc(8 * v5, 0x80040B8603338uLL);
      *((_QWORD *)v3 + 5) = result;
      v3[1] = v5;
      LODWORD(v4) = *v3;
    }
    v6 = &result[2 * (v4 - 4)];
  }
  else
  {
    v6 = &result[2 * v4 + 2];
  }
  *(_QWORD *)v6 = a2;
  *v3 = v4 + 1;
  return result;
}

BOOL _CFXNotificationRegistrarRecycleObserverRegistration(uint64_t a1, unsigned int *a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  int v15;
  _DWORD *v16;
  int v17;
  uint64_t v18;
  xpc_connection_t *v19;
  uint64_t v20;
  xpc_object_t v21;
  xpc_object_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;

  v8 = *(_QWORD *)(a1 + 144);
  v9 = a3;
  if (a2 && a3 != -1)
  {
    v10 = (unsigned int *)(v8 + 56 * a3);
    v11 = *v10;
    v12 = v10[1];
    if (*a2 == a3)
      *a2 = v12;
    if (v11 != -1)
      *(_DWORD *)(v8 + 56 * v11 + 4) = v12;
    if (v12 != -1)
      *(_DWORD *)(v8 + 56 * v12) = v11;
  }
  if ((*(_BYTE *)(a1 + 24) & 2) != 0)
  {
    v13 = *(_DWORD *)(v8 + 56 * a3 + 44);
    if ((v13 & 0x2000) != 0)
    {
      v18 = v8 + 56 * a3;
      v20 = *(_QWORD *)(v18 + 32);
      v19 = (xpc_connection_t *)(v18 + 32);
      if (v20)
      {
        v21 = xpc_array_create(0, 0);
        xpc_array_set_uint64(v21, 0xFFFFFFFFFFFFFFFFLL, v9 | ((unint64_t)*(unsigned int *)(v8 + 56 * v9 + 40) << 32));
        v22 = xpc_dictionary_create(0, 0, 0);
        xpc_dictionary_set_string(v22, "method", "unregister");
        xpc_dictionary_set_uint64(v22, "version", 1uLL);
        xpc_dictionary_set_value(v22, "tokens", v21);
        _CFSuddenTerminationDisable();
        xpc_connection_send_message(*v19, v22);
        xpc_connection_send_barrier(*v19, &__block_literal_global_36);
        xpc_release(v22);
        xpc_release(v21);
        xpc_release(*v19);
      }
      *v19 = 0;
    }
    else if ((v13 & 0x4000) != 0)
    {
      v14 = v8 + 56 * a3;
      v17 = *(_DWORD *)(v14 + 32);
      v16 = (_DWORD *)(v14 + 32);
      v15 = v17;
      if (v17)
        notify_cancel(v15);
      *v16 = 0;
    }
  }
  v23 = v8 + 56 * v9;
  v25 = *(_DWORD *)(v23 + 44);
  v24 = v23 + 44;
  _CFXNotificationHandlerRelease((uint64_t *)(v24 - 28), v25, a4);
  if ((*(_BYTE *)(v24 + 1) & 4) != 0)
    objc_destroyWeak((id *)(v8 + 56 * v9 + 8));
  *(_QWORD *)(v8 + 56 * v9 + 8) = 0;
  *(_DWORD *)v24 = 0x8000;
  v26 = a2[1] - 1;
  a2[1] = v26;
  if (a3 != -1)
  {
    v27 = *(_QWORD *)(a1 + 144);
    v28 = *(_DWORD *)(a1 + 160);
    if (v28 != -1)
      *(_DWORD *)(v27 + 56 * v28) = a3;
    *(_DWORD *)(v27 + 56 * v9) = -1;
    *(_DWORD *)(v27 + 56 * v9 + 4) = v28;
    *(_DWORD *)(a1 + 160) = a3;
    v26 = a2[1];
  }
  --*(_DWORD *)(a1 + 152);
  return v26 == 0;
}

void CFXNotificationRegisteredObserverSetNotifyToken(uint64_t a1, uint64_t a2, int a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  uint64_t v8;

  v6 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(_DWORD *)(a1 + 156) > a2)
  {
    v7 = *(_QWORD *)(a1 + 144);
    if (*(_DWORD *)(v7 + 56 * a2 + 40) == HIDWORD(a2))
    {
      v8 = v7 + 56 * a2;
      *(_DWORD *)(v8 + 44) |= 0x4000u;
      *(_DWORD *)(v8 + 32) = a3;
    }
  }
  os_unfair_lock_unlock(v6);
}

BOOL _CFXNotificationRegistrarRecycleObjectRegistration(uint64_t a1, uint64_t *a2, unsigned int a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const void **v12;
  unint64_t v13;
  CFHashCode v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;

  v8 = *(_QWORD *)(a1 + 120);
  v9 = a3;
  v10 = v8 + 32 * a3;
  v13 = *(_QWORD *)(v10 + 8);
  v12 = (const void **)(v10 + 8);
  v11 = v13;
  if (a4)
  {
    v14 = CFHash((CFTypeRef)v11);
    v8 = *(_QWORD *)(a1 + 120);
  }
  else
  {
    v14 = (v11 >> 5) & 0x7F;
  }
  if (a3 != -1)
  {
    v15 = *a2;
    if (*a2)
    {
      v16 = v14 % *((unsigned int *)a2 + 2);
      v17 = (unsigned int *)(v8 + 32 * v9);
      v18 = *v17;
      v19 = v17[1];
      if (*(_DWORD *)(v15 + 4 * v16) == a3)
        *(_DWORD *)(v15 + 4 * v16) = v19;
      if ((_DWORD)v18 != -1)
        *(_DWORD *)(v8 + 32 * v18 + 4) = v19;
      if ((_DWORD)v19 != -1)
        *(_DWORD *)(v8 + 32 * v19) = v18;
    }
  }
  if (a4)
    _CFXNotificationRegistrarRemoveCachedName(v12);
  *v12 = 0;
  v20 = *((_DWORD *)a2 + 3);
  if (v20)
    *((_DWORD *)a2 + 3) = --v20;
  if (a3 != -1)
  {
    v21 = *(_QWORD *)(a1 + 120);
    v22 = *(unsigned int *)(a1 + 136);
    if ((_DWORD)v22 != -1)
      *(_DWORD *)(v21 + 32 * v22) = a3;
    v23 = (_DWORD *)(v21 + 32 * v9);
    *v23 = -1;
    v23[1] = v22;
    *(_DWORD *)(a1 + 136) = a3;
    v20 = *((_DWORD *)a2 + 3);
  }
  --*(_DWORD *)(a1 + 128);
  return v20 == 0;
}

void CFXNotificationRegistrarRemoveToken(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  _OWORD v5[3];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  memset(v5, 0, sizeof(v5));
  v4 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(_DWORD *)(a1 + 156) > a2
    && *(_DWORD *)(*(_QWORD *)(a1 + 144) + 56 * a2 + 40) == HIDWORD(a2))
  {
    _CFXNotificationRegistrarInvalidateObserver(a1, a2, -1, -1, (unsigned int *)v5);
  }
  os_unfair_lock_unlock(v4);
  _CFXNotificationDisposalListRelease((unsigned int *)v5);
}

void _CFXNotificationRegistrarInvalidateObserver(uint64_t a1, unsigned int a2, int a3, int a4, unsigned int *a5)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  _BOOL4 v15;
  _BOOL4 v17;
  uint64_t *v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  _BOOL4 v24;
  _BOOL4 v26;

  if (*(_DWORD *)(a1 + 156) > a2)
  {
    v7 = *(_QWORD *)(a1 + 144);
    v8 = *(_DWORD *)(v7 + 56 * a2 + 44);
    if ((v8 & 0x800) != 0)
    {
      v23 = *(_DWORD *)(v7 + 56 * a2 + 48);
      v24 = _CFXNotificationRegistrarRecycleObserverRegistration(a1, (unsigned int *)(*(_QWORD *)(a1 + 96) + 40 * v23 + 24), a2, a5);
      if (v23 != a3 && v24)
      {
        v19 = (uint64_t *)(a1 + 64);
        v20 = a1;
        v21 = v23;
        v22 = 1;
        goto LABEL_22;
      }
    }
    else if ((v8 & 0x8000) == 0)
    {
      v9 = *(unsigned int *)(v7 + 56 * a2 + 48);
      if ((_DWORD)v9 == -1)
      {
        _CFXNotificationRegistrarRecycleObserverRegistration(a1, (unsigned int *)(a1 + 80), a2, a5);
      }
      else if (v9 < *(_DWORD *)(a1 + 132))
      {
        v11 = (*(unsigned __int8 *)(a1 + 24) >> 1) & 1;
        v12 = *(_QWORD *)(a1 + 120) + 32 * v9;
        v13 = *(_DWORD *)(v12 + 24);
        if (v13 == -1)
        {
          v26 = _CFXNotificationRegistrarRecycleObserverRegistration(a1, (unsigned int *)(v12 + 16), a2, a5);
          if ((_DWORD)v9 != a4 && v26)
            _CFXNotificationRegistrarRecycleObjectRegistration(a1, (uint64_t *)(a1 + 48), v9, v11);
        }
        else
        {
          v14 = *(_QWORD *)(a1 + 96);
          v15 = _CFXNotificationRegistrarRecycleObserverRegistration(a1, (unsigned int *)(v12 + 16), a2, a5);
          if ((_DWORD)v9 != a4 && v15)
          {
            v17 = _CFXNotificationRegistrarRecycleObjectRegistration(a1, (uint64_t *)(v14 + 40 * v13 + 24), v9, v11);
            if (v13 != a3 && v17)
            {
              v19 = (uint64_t *)(a1 + 32);
              v20 = a1;
              v21 = v13;
              v22 = 0;
LABEL_22:
              _CFXNotificationRegistrarRecycleNameRegistration(v20, v19, v21, v22);
            }
          }
        }
      }
    }
  }
}

uint64_t CFXNotificationRegistrarFindToken(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6;
  int v7;
  os_unfair_lock_s *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  int v13;
  uint64_t v14;
  int v15;
  int *v16;
  int v17;
  id *v18;
  uint64_t v19;
  _OWORD *v20;
  __int128 v21;
  int v22;
  id WeakRetained;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  CFTypeRef v28;
  const __CFString *v29;
  const __CFString *Copy;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned __int8 *)(a1 + 24);
  v7 = (v6 >> 1) & 1;
  *(_BYTE *)(a3 + 8) = (v6 & 2) != 0;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v8 = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  if (*(_DWORD *)(a1 + 156) <= a2)
    goto LABEL_6;
  v9 = *(_QWORD *)(a1 + 144);
  v10 = a2;
  v11 = v9 + 56 * a2;
  v13 = *(_DWORD *)(v11 + 40);
  v12 = (unsigned int *)(v11 + 40);
  if (v13 != HIDWORD(a2)
    || (v14 = v9 + 56 * a2,
        v17 = *(_DWORD *)(v14 + 44),
        v16 = (int *)(v14 + 44),
        LOWORD(v15) = v17,
        (v17 & 0x8000) != 0))
  {
LABEL_6:
    v19 = 0;
LABEL_7:
    v36 = 0u;
    v37 = 0u;
    v35 = 0u;
    goto LABEL_8;
  }
  v18 = (id *)(v9 + 56 * a2 + 8);
  if ((v15 & 0x400) == 0)
  {
    *(_QWORD *)&v32 = *v18;
LABEL_14:
    v25 = *(unsigned int *)(v9 + 56 * a2 + 48);
    if ((v15 & 0x800) != 0)
    {
      v29 = CFSTR("kCFNotificationAnyObject");
      if (v7)
        v29 = (const __CFString *)CFRetain(CFSTR("kCFNotificationAnyObject"));
      *((_QWORD *)&v31 + 1) = v29;
      *(_QWORD *)&v31 = CFCachedStringCopyString((CFTypeRef *)(*(_QWORD *)(a1 + 96) + 40 * v25 + 8));
    }
    else
    {
      if ((_DWORD)v25 == -1)
      {
        Copy = CFSTR("kCFNotificationAnyObject");
        if (v7)
          Copy = (const __CFString *)CFRetain(CFSTR("kCFNotificationAnyObject"));
      }
      else
      {
        v26 = *(_QWORD *)(a1 + 120);
        v27 = *(_DWORD *)(v26 + 32 * v25 + 24);
        if (v27 == -1)
          v28 = CFRetain(CFSTR("kCFNotificationAnyName"));
        else
          v28 = CFCachedStringCopyString((CFTypeRef *)(*(_QWORD *)(a1 + 96) + 40 * v27 + 8));
        *(_QWORD *)&v31 = v28;
        if (v7)
          Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)(v26 + 32 * v25 + 8));
        else
          Copy = *(const __CFString **)(v26 + 32 * v25 + 8);
      }
      *((_QWORD *)&v31 + 1) = Copy;
    }
    CFXNotificationHandlerCopy(&v33, *(void **)(v9 + 56 * v10 + 16), *(CFTypeRef *)(v9 + 56 * v10 + 24), *v16);
    *((_QWORD *)&v32 + 1) = *v16;
    *(_QWORD *)&v34 = v10 | ((unint64_t)*v12 << 32);
    v19 = 1;
    goto LABEL_7;
  }
  WeakRetained = objc_loadWeakRetained(v18);
  if (WeakRetained)
  {
    *(_QWORD *)&v32 = WeakRetained;
    v15 = *v16;
    goto LABEL_14;
  }
  v36 = 0u;
  v37 = 0u;
  v35 = 0u;
  _CFXNotificationRegistrarInvalidateObserver(a1, a2, -1, -1, (unsigned int *)&v35);
  v19 = 0;
LABEL_8:
  os_unfair_lock_unlock(v8);
  _CFXNotificationDisposalListRelease((unsigned int *)&v35);
  if ((_DWORD)v19)
  {
    v20 = *(_OWORD **)(a3 + 16);
    *v20 = v31;
    v20[1] = v32;
    v21 = v34;
    v20[2] = v33;
    v20[3] = v21;
    v22 = 1;
  }
  else
  {
    v22 = 0;
  }
  *(_DWORD *)a3 = v22;
  return v19;
}

uint64_t *_CFGetProcessPath()
{
  if (!__CFProcessPath)
    _CFProcessPath();
  return &__CFProcessPath;
}

CFStringRef CFDateFormatterCreateStringWithDate(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  const __CFAllocator *v5;
  uint64_t v6;
  unint64_t v7;
  CFAbsoluteTime AbsoluteTime;

  v5 = allocator;
  if (!allocator)
  {
    v6 = _CFGetTSD(1u);
    if (v6)
      v5 = (const __CFAllocator *)v6;
    else
      v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  v7 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v7 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v7);
  AbsoluteTime = CFDateGetAbsoluteTime(date);
  return CFDateFormatterCreateStringWithAbsoluteTime(v5, formatter, AbsoluteTime);
}

uint64_t CFRunLoopRunSpecific(uint64_t a1, const __CFString *a2, int a3, double a4)
{
  unint64_t v8;
  uint64_t v9;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  _QWORD v20[6];

  v20[5] = *MEMORY[0x1E0C80C00];
  v8 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v8 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v8);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (!a2 || a2 == CFSTR("kCFRunLoopCommonModes") || CFEqual(a2, CFSTR("kCFRunLoopCommonModes")))
  {
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __CFRunLoopRunSpecific_block_invoke;
    v20[3] = &__block_descriptor_40_e5_v8__0l;
    v20[4] = a2;
    if (CFRunLoopRunSpecific_onceToken != -1)
      dispatch_once(&CFRunLoopRunSpecific_onceToken, v20);
    return 1;
  }
  v11 = atomic_load((unint64_t *)(a1 + 8));
  if ((v11 & 4) != 0)
    return 1;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v12 = __CFRunLoopCopyMode(a1, a2, 0);
  if (!v12)
  {
LABEL_17:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    return 1;
  }
  v13 = v12;
  if (__CFRunLoopModeIsEmpty(a1, v12))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v13 + 16));
    CFRelease((CFTypeRef)v13);
    goto LABEL_17;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v13 + 16));
  v14 = *(unsigned __int8 *)(a1 + 84);
  if (v14 >= 0xFE)
    CFRunLoopRunSpecific_cold_1();
  v15 = v14 + 1;
  *(_BYTE *)(a1 + 84) = v15;
  v16 = a1 + v15;
  *(_BYTE *)(v16 + 85) = 0;
  *(_BYTE *)(v16 + 339) = 0;
  v17 = *(_QWORD *)(a1 + 624);
  *(_QWORD *)(a1 + 624) = v13;
  if ((*(_BYTE *)(v13 + 144) & 1) != 0)
    __CFRunLoopDoObservers(a1, v13, 1);
  v18 = (_DWORD *)CFRunLoopRunSpecific_runloopNestingLevel();
  ++*v18;
  kdebug_trace();
  v19 = __CFRunLoopRun(a1, v13, a3, *v18, a4);
  kdebug_trace();
  --*v18;
  if ((*(_BYTE *)(v13 + 144) & 0x80) != 0)
    __CFRunLoopDoObservers(a1, v13, 128);
  v9 = v19;
  if (!*(_BYTE *)(a1 + 84))
    CFRunLoopRunSpecific_cold_2();
  --*(_BYTE *)(a1 + 84);
  pthread_mutex_unlock((pthread_mutex_t *)(v13 + 16));
  CFRelease((CFTypeRef)v13);
  *(_QWORD *)(a1 + 624) = v17;
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  return v9;
}

void sub_182ADC6F8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t __CFRunLoopCopyMode(uint64_t a1, const __CFString *a2, int a3)
{
  const void *v6;
  uint64_t Instance;
  ipc_space_t *v9;
  kern_return_t v10;
  int sig;
  mach_port_name_t port_4CF;
  mach_port_name_t v13;
  NSObject *v14;
  mach_port_name_t v15;
  mach_port_name_t v16;
  _QWORD handler[5];
  pthread_mutexattr_t v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD value[5];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v29 = 0;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v22 = 0u;
  memset(value, 0, sizeof(value));
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)value, 0x2CuLL);
  *(_QWORD *)&v22 = a2;
  v6 = CFSetGetValue(*(CFSetRef *)(a1 + 632), value);
  Instance = (uint64_t)v6;
  if (v6)
  {
    CFRetain(v6);
  }
  else if (a3)
  {
    Instance = _CFRuntimeCreateInstance(&__kCFAllocatorSystemDefault, 0x2CuLL, 184, 0);
    if (Instance)
    {
      v18.__sig = 0;
      *(_QWORD *)v18.__opaque = 0;
      pthread_mutexattr_init(&v18);
      pthread_mutexattr_settype(&v18, 2);
      pthread_mutex_init((pthread_mutex_t *)(Instance + 16), &v18);
      pthread_mutexattr_destroy(&v18);
      *(_QWORD *)(Instance + 80) = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
      LODWORD(v18.__sig) = 0;
      v9 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
      v10 = mach_port_allocate(*MEMORY[0x1E0C83DA0], 3u, (mach_port_name_t *)&v18);
      if (v10)
        __THE_SYSTEM_HAS_NO_PORT_SETS_AVAILABLE__(v10);
      sig = v18.__sig;
      *(_BYTE *)(Instance + 168) = 0;
      *(_DWORD *)(Instance + 136) = sig;
      *(_QWORD *)(Instance + 184) = -1;
      *(_QWORD *)(Instance + 192) = -1;
      *(_QWORD *)(Instance + 160) = _dispatch_runloop_root_queue_create_4CF();
      port_4CF = _dispatch_runloop_root_queue_get_port_4CF();
      if (!port_4CF)
        __CFRunLoopCopyMode_cold_1();
      v13 = port_4CF;
      v14 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, *(dispatch_queue_t *)(Instance + 160));
      *(_QWORD *)(Instance + 152) = v14;
      v18.__sig = 0;
      *(_QWORD *)v18.__opaque = &v18;
      v19 = 0x2020000000;
      v20 = Instance + 168;
      handler[0] = MEMORY[0x1E0C809B0];
      handler[1] = 3221225472;
      handler[2] = ____CFRunLoopCopyMode_block_invoke;
      handler[3] = &unk_1E12E5FF0;
      handler[4] = &v18;
      dispatch_source_set_event_handler(v14, handler);
      dispatch_source_set_timer(*(dispatch_source_t *)(Instance + 152), 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x141uLL);
      dispatch_resume(*(dispatch_object_t *)(Instance + 152));
      if (mach_port_insert_member(*v9, v13, *(_DWORD *)(Instance + 136)))
        __CFRunLoopCopyMode_cold_5();
      v15 = mk_timer_create();
      *(_DWORD *)(Instance + 172) = v15;
      if (!v15)
        __CFRunLoopCopyMode_cold_2();
      if (mach_port_insert_member(*v9, v15, *(_DWORD *)(Instance + 136)))
        __CFRunLoopCopyMode_cold_4();
      v16 = *(_DWORD *)(a1 + 80);
      if (!v16 || mach_port_insert_member(*v9, v16, *(_DWORD *)(Instance + 136)))
        __CFRunLoopCopyMode_cold_3();
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 632), (const void *)Instance);
      _Block_object_dispose(&v18, 8);
    }
  }
  else
  {
    return 0;
  }
  return Instance;
}

void sub_182ADC9F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CFRunLoopRun(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5)
{
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  int v13;
  uint64_t v14;
  uint64_t v16;
  mach_port_name_t main_queue_port_4CF;
  int port_4CF;
  uint64_t v19;
  intptr_t v20;
  NSObject *global_queue;
  NSObject *v22;
  uint64_t v23;
  double v24;
  dispatch_time_t v25;
  unint64_t *v26;
  int v27;
  mach_port_name_t v28;
  uint64_t v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  double Current;
  unint64_t v35;
  unint64_t v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  int v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  const void *v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  const __CFDictionary *v49;
  int v50;
  void *v51;
  NSObject *v52;
  BOOL v53;
  uint64_t v54;
  _BYTE *v55;
  int v56;
  int IsEmpty;
  uint64_t v58;
  NSObject *source;
  uint64_t v60;
  uint64_t v61;
  _BOOL4 v62;
  pthread_mutex_t *v63;
  pthread_mutex_t *v64;
  int v65;
  void *v66;
  int v67;
  mach_port_name_t name;
  mach_port_t v69;
  void *v70;
  id v71;
  voucher_mach_msg_state_t state;
  _QWORD v73[5];
  _QWORD handler[5];
  _BYTE msg[12];
  __int16 v76;
  int v77;
  _BYTE v78[3072];
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  v10 = mach_absolute_time();
  v11 = a1 + *(unsigned __int8 *)(a1 + 84);
  v13 = *(unsigned __int8 *)(v11 + 85);
  v12 = (_BYTE *)(v11 + 85);
  if (v13)
  {
    *v12 = 0;
    return 2;
  }
  if (*(_BYTE *)(a2 + 88))
  {
    *(_BYTE *)(a2 + 88) = 0;
    return 2;
  }
  v16 = v10;
  if (pthread_main_np() == 1
    && !_CFGetTSD(4u)
    && CFRunLoopGetMain() == (CFRunLoopRef)a1
    && CFSetContainsValue(*(CFSetRef *)(a1 + 608), *(const void **)(a2 + 80)))
  {
    main_queue_port_4CF = _dispatch_get_main_queue_port_4CF();
  }
  else
  {
    main_queue_port_4CF = 0;
  }
  if (!*(_QWORD *)(a2 + 160))
    goto LABEL_14;
  port_4CF = _dispatch_runloop_root_queue_get_port_4CF();
  if (!port_4CF)
  {
    qword_1EDCD1038 = (uint64_t)"Unable to get port for run loop mode queue";
    __break(1u);
LABEL_14:
    port_4CF = 0;
  }
  v67 = a3;
  if (a5 <= 0.0)
  {
    v19 = 0;
    source = 0;
  }
  else if (a5 <= 504911232.0)
  {
    v19 = __CFTimeIntervalToTSR(a5) + v16;
    if (pthread_main_np() == 1)
      v20 = qos_class_main();
    else
      v20 = 17;
    global_queue = dispatch_get_global_queue(v20, 2uLL);
    v22 = dispatch_source_create(MEMORY[0x1E0C80DD0], 0, 0, global_queue);
    CFRetain((CFTypeRef)a1);
    v23 = MEMORY[0x1E0C809B0];
    handler[0] = MEMORY[0x1E0C809B0];
    handler[1] = 3221225472;
    handler[2] = ____CFRunLoopRun_block_invoke;
    handler[3] = &__block_descriptor_40_e5_v8__0l;
    handler[4] = a1;
    dispatch_source_set_event_handler(v22, handler);
    v73[0] = v23;
    v73[1] = 3221225472;
    v73[2] = ____CFRunLoopRun_block_invoke_2;
    v73[3] = &__block_descriptor_40_e5_v8__0l;
    v73[4] = a1;
    dispatch_source_set_cancel_handler(v22, v73);
    v24 = __CFTSRToTimeInterval(v16);
    v25 = dispatch_time(1uLL, (unint64_t)((v24 + a5) * 1000000000.0));
    dispatch_source_set_timer(v22, v25, 0xFFFFFFFFFFFFFFFFLL, 0x3E8uLL);
    source = v22;
    dispatch_resume(v22);
  }
  else
  {
    source = 0;
    v19 = -1;
  }
  v60 = v19;
  v62 = v19 != 0;
  v26 = (unint64_t *)(a1 + 8);
  v63 = (pthread_mutex_t *)(a1 + 16);
  v64 = (pthread_mutex_t *)(a2 + 16);
  name = main_queue_port_4CF;
  v27 = 1;
  v61 = a4;
  do
  {
    __cftrace_runloop_trace_iteration_start(a4, (__CFRunLoop *)a1);
    v71 = 0;
    state = (voucher_mach_msg_state_t)-1;
    v70 = 0;
    v69 = 0;
    v28 = *(_DWORD *)(a2 + 136);
    *(_BYTE *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 0;
    v29 = *(_QWORD *)(a2 + 144);
    if ((v29 & 2) != 0)
    {
      __CFRunLoopDoObservers(a1, a2, 2);
      v29 = *(_QWORD *)(a2 + 144);
    }
    if ((v29 & 4) != 0)
      __CFRunLoopDoObservers(a1, a2, 4);
    __CFRunLoopDoBlocks(a1, a2);
    v30 = v62;
    v65 = __CFRunLoopDoSources0(a1, a2, v67);
    if (v65)
    {
      __CFRunLoopDoBlocks(a1, a2);
      v30 = 0;
    }
    if (!name
      || v27
      || (v70 = v78, !__CFRunLoopServiceMachPort(name, (mach_msg_header_t **)&v70, &v69, 0, &state, 0)))
    {
      if (v30)
      {
        if ((*(_BYTE *)(a2 + 144) & 0x20) != 0)
          __CFRunLoopDoObservers(a1, a2, 32);
        v31 = atomic_load(v26);
        while (1)
        {
          v32 = __ldaxr(v26);
          if (v32 != v31)
            break;
          if (__stlxr(v31 | 2, v26))
            goto LABEL_41;
          v33 = 1;
LABEL_42:
          v31 = v32;
          if (v33)
          {
            if (name)
              mach_port_insert_member(*MEMORY[0x1E0C83DA0], name, v28);
            pthread_mutex_unlock(v64);
            pthread_mutex_unlock(v63);
            Current = CFAbsoluteTimeGetCurrent();
            goto LABEL_56;
          }
        }
        __clrex();
LABEL_41:
        v33 = 0;
        goto LABEL_42;
      }
      v35 = atomic_load(v26);
      while (1)
      {
        v36 = __ldaxr(v26);
        if (v36 != v35)
          break;
        if (__stlxr(v35 | 2, v26))
          goto LABEL_51;
        v37 = 1;
LABEL_52:
        v35 = v36;
        if (v37)
        {
          if (name)
            mach_port_insert_member(*MEMORY[0x1E0C83DA0], name, v28);
          pthread_mutex_unlock(v64);
          pthread_mutex_unlock(v63);
          Current = 0.0;
LABEL_56:
          kdebug_trace();
          kdebug_trace();
          v70 = v78;
          __CFRunLoopServiceMachPort(v28, (mach_msg_header_t **)&v70, &v69, v30 << 31 >> 31, &state, &v71);
          if (port_4CF && v69 == port_4CF)
          {
            while (1)
            {
              while ((_dispatch_runloop_root_queue_perform_4CF() & 1) != 0)
                ;
              if (*(_BYTE *)(a2 + 168))
                break;
              if (v70 && v70 != v78)
                free(v70);
              v70 = v78;
              __CFRunLoopServiceMachPort(v28, (mach_msg_header_t **)&v70, &v69, v30 << 31 >> 31, &state, &v71);
              if (v69 != port_4CF)
                goto LABEL_66;
            }
            *(_BYTE *)(a2 + 168) = 0;
          }
LABEL_66:
          kdebug_trace();
          kdebug_trace();
          pthread_mutex_lock(v63);
          pthread_mutex_lock(v64);
          if (v30)
          {
            *(double *)(a1 + 664) = *(double *)(a1 + 664) + CFAbsoluteTimeGetCurrent() - Current;
            a4 = v61;
            if (name)
              mach_port_extract_member(*MEMORY[0x1E0C83DA0], name, v28);
            *(_BYTE *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 1;
            v38 = atomic_load((unint64_t *)(a1 + 8));
            while (1)
            {
              v39 = __ldaxr(v26);
              if (v39 != v38)
                break;
              if (__stlxr(v38 & 0xFFFFFFFFFFFFFFFDLL, v26))
                goto LABEL_74;
              v40 = 1;
LABEL_75:
              v38 = v39;
              if (v40)
              {
                if ((*(_BYTE *)(a2 + 144) & 0x40) != 0)
                  __CFRunLoopDoObservers(a1, a2, 64);
                goto LABEL_87;
              }
            }
            __clrex();
LABEL_74:
            v40 = 0;
            goto LABEL_75;
          }
          *(double *)(a1 + 664) = *(double *)(a1 + 664) + 0.0;
          a4 = v61;
          if (name)
            mach_port_extract_member(*MEMORY[0x1E0C83DA0], name, v28);
          *(_BYTE *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 1;
          v41 = atomic_load((unint64_t *)(a1 + 8));
          while (2)
          {
            v42 = __ldaxr(v26);
            if (v42 == v41)
            {
              if (!__stlxr(v41 & 0xFFFFFFFFFFFFFFFDLL, v26))
              {
                v43 = 1;
                goto LABEL_86;
              }
            }
            else
            {
              __clrex();
            }
            v43 = 0;
LABEL_86:
            v41 = v42;
            if (v43)
              goto LABEL_87;
            continue;
          }
        }
      }
      __clrex();
LABEL_51:
      v37 = 0;
      goto LABEL_52;
    }
LABEL_87:
    *(_BYTE *)(a1 + *(unsigned __int8 *)(a1 + 84) + 339) = 1;
    v44 = (const void *)v69;
    if (!v69)
    {
      v27 = 0;
      goto LABEL_115;
    }
    if (v69 != *(_DWORD *)(a1 + 80))
    {
      if (port_4CF && v69 == port_4CF)
      {
        v45 = mach_absolute_time();
        if (!__CFRunLoopDoTimers(a1, a2, v45))
          goto LABEL_99;
      }
      else
      {
        v46 = *(_DWORD *)(a2 + 172);
        if (v46 && v69 == v46)
        {
          v47 = mach_absolute_time();
          if (!__CFRunLoopDoTimers(a1, a2, v47))
          {
            *(_QWORD *)(a2 + 184) = -1;
            *(_QWORD *)(a2 + 192) = -1;
LABEL_99:
            __CFArmNextTimerInMode(a2);
          }
        }
        else
        {
          if (v69 == name)
          {
            pthread_mutex_unlock(v64);
            pthread_mutex_unlock(v63);
            _CFSetTSD(4u, 6, 0);
            v66 = (void *)_CFAutoreleasePoolPush();
            kdebug_trace();
            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();
            kdebug_trace();
            __CFRunLoopPerCalloutARPEnd(v66);
            _CFSetTSD(4u, 0, 0);
            pthread_mutex_lock(v63);
            pthread_mutex_lock(v64);
            v27 = 1;
            v65 = 1;
            goto LABEL_115;
          }
          kdebug_trace();
          v48 = _CFSetTSD(0xDu, (uint64_t)v71, MEMORY[0x1E0C84910]);
          if ((__CF_FORK_STATE & 2) == 0)
            __CF_USED();
          if ((__CF_FORK_STATE & 1) != 0)
            __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
          v49 = *(const __CFDictionary **)(a2 + 128);
          if (v49 && CFDictionaryGetValue(v49, v44))
          {
            *(_QWORD *)msg = 0;
            v50 = __CFRunLoopDoSource1(a1, a2);
            v51 = *(void **)msg;
            if (*(_QWORD *)msg)
            {
              mach_msg(*(mach_msg_header_t **)msg, 1, *(_DWORD *)(*(_QWORD *)msg + 4), 0, 0, 0, 0);
              CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v51);
            }
            v65 |= v50;
          }
          else
          {
            v52 = _CFOSLog();
            if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
            {
              v58 = *(_QWORD *)(a2 + 80);
              *(_DWORD *)msg = 138412546;
              *(_QWORD *)&msg[4] = v58;
              v76 = 1024;
              v77 = (int)v44;
              _os_log_error_impl(&dword_182A8C000, v52, OS_LOG_TYPE_ERROR, "__CFRunLoopModeFindSourceForMachPort returned NULL for mode '%@' livePort: %u", msg, 0x12u);
            }
          }
          _CFSetTSD(0xDu, v48, MEMORY[0x1E0C84910]);
          kdebug_trace();
        }
      }
      v27 = 0;
      goto LABEL_115;
    }
    v27 = 0;
LABEL_115:
    if (v70 && v70 != v78)
      free(v70);
    __CFRunLoopDoBlocks(a1, a2);
    if (v67 && v65)
    {
      v53 = 0;
      v14 = 4;
      goto LABEL_128;
    }
    if (v60 < mach_absolute_time())
    {
      v53 = 0;
      v14 = 3;
      goto LABEL_128;
    }
    v54 = a1 + *(unsigned __int8 *)(a1 + 84);
    v56 = *(unsigned __int8 *)(v54 + 85);
    v55 = (_BYTE *)(v54 + 85);
    if (v56)
    {
      v53 = 0;
      *v55 = 0;
LABEL_127:
      v14 = 2;
      goto LABEL_128;
    }
    if (*(_BYTE *)(a2 + 88))
    {
      v53 = 0;
      *(_BYTE *)(a2 + 88) = 0;
      goto LABEL_127;
    }
    IsEmpty = __CFRunLoopModeIsEmpty(a1, a2);
    v53 = IsEmpty == 0;
    v14 = IsEmpty != 0;
LABEL_128:
    voucher_mach_msg_revert(state);

    kdebug_trace();
  }
  while (v53);
  if (source)
  {
    dispatch_source_cancel(source);
    dispatch_release(source);
  }
  return v14;
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  timespec __tp;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  __tp.tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_REALTIME, &__tp);
  return (double)__tp.tv_sec + -978307200.0 + (double)__tp.tv_nsec * 0.000000001;
}

uint64_t __CFRunLoopDoBlocks(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD *v5;
  const void *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  CFTypeID v11;
  const void *v12;
  const void *v13;
  void *v14;
  const __CFSet *theSet;

  result = kdebug_trace();
  v5 = *(_QWORD **)(a1 + 640);
  if (!v5)
    return result;
  v6 = *(const void **)(a2 + 80);
  if (!v6)
    return result;
  v7 = *(_QWORD **)(a1 + 648);
  *(_QWORD *)(a1 + 640) = 0;
  *(_QWORD *)(a1 + 648) = 0;
  theSet = *(const __CFSet **)(a1 + 608);
  pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  v8 = 0;
  v9 = v5;
  do
  {
    while (1)
    {
      v10 = v5;
      v5 = (_QWORD *)*v5;
      v11 = CFGetTypeID((CFTypeRef)v10[1]);
      v12 = (const void *)v10[1];
      if (v11 == 7)
      {
        if (CFEqual(v12, v6))
          goto LABEL_11;
        if (!CFEqual((CFTypeRef)v10[1], CFSTR("kCFRunLoopCommonModes")))
          goto LABEL_22;
        break;
      }
      if (CFSetContainsValue((CFSetRef)v12, v6))
        goto LABEL_11;
      if (CFSetContainsValue((CFSetRef)v10[1], CFSTR("kCFRunLoopCommonModes")))
        break;
LABEL_22:
      v8 = v10;
      if (!v5)
        goto LABEL_23;
    }
    if (!CFSetContainsValue(theSet, v6))
      goto LABEL_22;
LABEL_11:
    if (v8)
      *v8 = v5;
    if (v10 == v9)
      v9 = v5;
    if (v10 == v7)
      v7 = v8;
    v13 = (const void *)v10[2];
    CFRelease((CFTypeRef)v10[1]);
    free(v10);
    if (*(_BYTE *)(a1 + 681))
      v14 = (void *)_CFAutoreleasePoolPush();
    else
      v14 = 0;
    kdebug_trace();
    __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__((uint64_t)v13);
    kdebug_trace();
    __CFRunLoopPerCalloutARPEnd(v14);
    _Block_release(v13);
  }
  while (v5);
LABEL_23:
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  if (v9 && v7)
  {
    *v7 = *(_QWORD *)(a1 + 640);
    *(_QWORD *)(a1 + 640) = v9;
    if (!*(_QWORD *)(a1 + 648))
      *(_QWORD *)(a1 + 648) = v7;
  }
  return kdebug_trace();
}

uint64_t __CFRunLoopServiceMachPort(mach_port_name_t rcv_name, mach_msg_header_t **a2, mach_port_t *a3, mach_msg_timeout_t timeout, voucher_mach_msg_state_t *a5, id *a6)
{
  char v11;
  unsigned int v12;
  mach_msg_header_t *v13;
  mach_msg_option_t v14;
  char *v15;
  voucher_mach_msg_state_t v16;
  uint64_t v17;
  mach_msg_size_t msgh_size;
  mach_msg_header_t *v19;
  mach_port_t msgh_local_port;
  uint64_t result;

  v11 = 0;
  v12 = 3072;
  while (1)
  {
    v13 = *a2;
    v13->msgh_remote_port = 0;
    v13->msgh_local_port = rcv_name;
    v13->msgh_bits = 0;
    v13->msgh_size = v12;
    v13->msgh_id = 0;
    if (timeout == -1)
      v14 = 117442566;
    else
      v14 = 117442822;
    v15 = (char *)mach_msg(v13, v14, 0, v13->msgh_size, rcv_name, timeout, 0);
    voucher_mach_msg_revert(*a5);
    v16 = voucher_mach_msg_adopt(v13);
    *a5 = v16;
    if (a6)
    {
      if (v16 == (voucher_mach_msg_state_t)-1)
        v17 = 0;
      else
        v17 = voucher_copy();
      *a6 = (id)v17;
    }
    if ((_DWORD)v15 != 268451844)
      break;
    msgh_size = v13->msgh_size;
    if ((v11 & 1) != 0)
    {
      v19 = *a2;
    }
    else
    {
      v19 = 0;
      *a2 = 0;
    }
    v12 = (msgh_size + 71) & 0xFFFFFFFC;
    *a2 = (mach_msg_header_t *)__CFSafelyReallocateTyped(v19, (msgh_size + 68 + 3) & 0x1FFFFFFFCLL, 1216056538, 0);
    v11 = 1;
    if (a6)
    {
      if (*a6)

    }
  }
  if ((_DWORD)v15 == 268451843)
  {
    if ((v11 & 1) != 0)
      free(v13);
    msgh_local_port = 0;
    result = 0;
    *a2 = 0;
  }
  else
  {
    if ((_DWORD)v15)
      __CFRunLoopServiceMachPort_cold_1(v15);
    msgh_local_port = v13->msgh_local_port;
    result = 1;
  }
  *a3 = msgh_local_port;
  return result;
}

uint64_t __CFRunLoopModeIsEmpty(uint64_t a1, uint64_t a2)
{
  const __CFSet *v4;
  const __CFSet *v5;
  const __CFArray *v6;
  _QWORD *v8;
  _QWORD *v9;
  CFTypeID v10;
  const void *v11;
  const void *v12;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (pthread_main_np() == 1
    && !_CFGetTSD(4u)
    && CFRunLoopGetMain() == (CFRunLoopRef)a1
    && CFSetContainsValue(*(CFSetRef *)(a1 + 608), *(const void **)(a2 + 80)))
  {
    return 0;
  }
  v4 = *(const __CFSet **)(a2 + 96);
  if (v4)
  {
    if (CFSetGetCount(v4) > 0)
      return 0;
  }
  v5 = *(const __CFSet **)(a2 + 104);
  if (v5)
  {
    if (CFSetGetCount(v5) > 0)
      return 0;
  }
  v6 = *(const __CFArray **)(a2 + 120);
  if (v6)
  {
    if (CFArrayGetCount(v6) > 0)
      return 0;
  }
  v8 = *(_QWORD **)(a1 + 640);
  while (v8)
  {
    v9 = v8;
    v8 = (_QWORD *)*v8;
    v10 = CFGetTypeID((CFTypeRef)v9[1]);
    v11 = (const void *)v9[1];
    v12 = *(const void **)(a2 + 80);
    if (v10 == 7)
    {
      if (CFEqual(v11, v12))
        return 0;
      if (CFEqual((CFTypeRef)v9[1], CFSTR("kCFRunLoopCommonModes")))
        goto LABEL_23;
    }
    else
    {
      if (CFSetContainsValue((CFSetRef)v11, v12))
        return 0;
      if (CFSetContainsValue((CFSetRef)v9[1], CFSTR("kCFRunLoopCommonModes")))
      {
LABEL_23:
        if (CFSetContainsValue(*(CFSetRef *)(a1 + 608), *(const void **)(a2 + 80)))
          return 0;
      }
    }
  }
  return 1;
}

uint64_t __CFRunLoopDoSources0(uint64_t a1, uint64_t a2, int a3)
{
  const __CFSet *v6;
  uint64_t v7;
  uint64_t Count;
  CFIndex v9;
  const void *ValueAtIndex;
  uint64_t v11;
  CFTypeRef cf[2];
  CFRange v14;

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  kdebug_trace();
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  cf[0] = 0;
  v6 = *(const __CFSet **)(a2 + 96);
  if (v6
    && CFSetGetCount(v6) >= 1
    && (CFSetApplyFunction(*(CFSetRef *)(a2 + 96), (CFSetApplierFunction)__CFRunLoopCollectSources0, cf), cf[0]))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 16));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    if (CFGetTypeID(cf[0]) == 46)
    {
      v7 = __CFRunLoopDoSource0(a1, (uint64_t)cf[0]);
    }
    else
    {
      Count = CFArrayGetCount((CFArrayRef)cf[0]);
      v14.location = 0;
      v14.length = Count;
      CFArraySortValues((CFMutableArrayRef)cf[0], v14, (CFComparatorFunction)__CFRunLoopSourceComparator, 0);
      if (Count < 1)
      {
        v7 = 0;
      }
      else
      {
        v9 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf[0], v9);
          v11 = __CFRunLoopDoSource0(a1, (uint64_t)ValueAtIndex);
          v7 = v11;
          if (a3)
          {
            if ((_DWORD)v11)
              break;
          }
          if (Count == ++v9)
            goto LABEL_19;
        }
        v7 = 1;
      }
    }
LABEL_19:
    CFRelease(cf[0]);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  }
  else
  {
    v7 = 0;
  }
  kdebug_trace();
  return v7;
}

uint64_t __cftrace_runloop_trace_iteration_start(uint64_t a1, __CFRunLoop *a2)
{
  uint64_t result;
  const __CFString *v4;
  _BOOL4 v5;
  unint64_t v6;
  CFIndex Length;
  CFIndex v8;
  CFStringRef v9;
  CFIndex MaximumSizeForEncoding;
  uint64_t v11;
  uint64_t v12;
  CFIndex v13;
  int CString;
  _QWORD v15[2];
  CFRange v16;

  v15[1] = *MEMORY[0x1E0C80C00];
  result = kdebug_is_enabled();
  if ((_DWORD)result)
  {
    v4 = CFRunLoopCopyCurrentMode(a2);
    if (CFEqual(v4, CFSTR("kCFRunLoopDefaultMode")))
    {
      v5 = 0;
    }
    else if (CFEqual(v4, CFSTR("kCFRunLoopCommonModes")))
    {
      v5 = 0;
    }
    else if (CFEqual(v4, CFSTR("NSModalPanelRunLoopMode")))
    {
      v5 = 0;
    }
    else if (CFEqual(v4, CFSTR("NSEventTrackingRunLoopMode")))
    {
      v5 = 0;
    }
    else if (CFEqual(v4, CFSTR("UITrackingRunLoopMode")))
    {
      v5 = 0;
    }
    else if (CFEqual(v4, CFSTR("com.apple.run-loop-mode.view-bridge.blocks")))
    {
      v5 = 0;
    }
    else
    {
      if (CFStringGetCStringPtr(v4, 0x8000100u))
      {
        v6 = kdebug_trace_string();
        v5 = 1;
      }
      else
      {
        Length = CFStringGetLength(v4);
        if (Length < 177)
        {
          v8 = Length;
        }
        else
        {
          v8 = 176;
          v16.location = 0;
          v16.length = 176;
          v9 = CFStringCreateWithSubstring(0, v4, v16);
          CFRelease(v4);
          v4 = v9;
        }
        MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v8, 0x8000100u);
        MEMORY[0x1E0C80A78](MaximumSizeForEncoding, v11);
        CString = CFStringGetCString(v4, (char *)v15 - v12, v13, 0x8000100u);
        v5 = CString != 0;
        if (CString)
          v6 = kdebug_trace_string();
        else
          v6 = -1;
      }
      if (v6 >= 0xFFFFFFFFFFFFFFF9)
      {
        kdebug_trace_string();
        v5 = 0;
      }
    }
    CFRelease(v4);
    _CFRunLoopCurrentIsMain();
    result = kdebug_trace();
    if (v5)
      return kdebug_trace_string();
  }
  return result;
}

BOOL _CFRunLoopCurrentIsMain()
{
  pthread_t v0;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v0 = (pthread_t)pthread_main_thread_np();
  return v0 == pthread_self();
}

CFRunLoopMode CFRunLoopCopyCurrentMode(CFRunLoopRef rl)
{
  unint64_t v2;
  pthread_mutex_t *v3;
  uint64_t v4;
  const __CFString *v5;

  v2 = _CFGetNonObjCTypeID((unint64_t *)rl);
  if (v2 != 43)
    _CFAssertMismatchedTypeID(0x2BuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v3 = (pthread_mutex_t *)((char *)rl + 16);
  pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
  v4 = *((_QWORD *)rl + 78);
  if (v4)
    v5 = (const __CFString *)CFRetain(*(CFTypeRef *)(v4 + 80));
  else
    v5 = 0;
  pthread_mutex_unlock(v3);
  return v5;
}

uint64_t _CFKeyedArchiverUIDGetValue(uint64_t a1)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)a1);
  if (v2 != 41)
    _CFAssertMismatchedTypeID(0x29uLL, v2);
  return *(unsigned int *)(a1 + 16);
}

uint64_t _CFGetNonObjCTypeID(unint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t result;

  if (((unint64_t)a1 & 0x8000000000000000) != 0)
  {
    v1 = 0;
    v2 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)a1 & 0xC000000000000007) == 0)
      v2 = 0;
    v3 = v2 ^ (unint64_t)a1;
    do
    {
      if ((v3 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v1))
        break;
      ++v1;
    }
    while (v1 != 7);
    v4 = v1 | v3;
    v5 = v1 & 7;
    v6 = (v4 >> 55) + 8;
    if (v5 != 7)
      v6 = v5;
    v7 = 22;
    switch(v6)
    {
      case 0:
        if (dyld_program_sdk_at_least())
          _CFGetNonObjCTypeID_cold_1();
        return 1;
      case 1:
        goto LABEL_17;
      case 2:
        return 7;
      case 3:
        return v7;
      case 4:
      case 5:
        return 1;
      case 6:
        return 42;
      default:
        if (v6 == 20)
          return 1;
        if (v6 == 22)
          return 7;
LABEL_17:
        result = objc_msgSend(a1, "_cfTypeID");
        break;
    }
  }
  else
  {
    v8 = atomic_load(a1 + 1);
    return (v8 >> 8) & 0x3FF;
  }
  return result;
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  CFRunLoopRef result;
  _opaque_pthread_t *v1;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  result = (CFRunLoopRef)CFRunLoopGetMain___main;
  if (!CFRunLoopGetMain___main)
  {
    v1 = (_opaque_pthread_t *)pthread_main_thread_np();
    result = (CFRunLoopRef)_CFRunLoopGet0(v1);
    CFRunLoopGetMain___main = (uint64_t)result;
  }
  return result;
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
  _QWORD v6[7];

  v6[6] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet __applyValues:context:](theSet, "__applyValues:context:", applier, context);
  }
  else
  {
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = __CFSetApplyFunction_block_invoke;
    v6[3] = &__block_descriptor_48_e15_C40__0___qQQQ_8l;
    v6[4] = applier;
    v6[5] = context;
    CFBasicHashApply((uint64_t)theSet, (uint64_t)v6);
  }
}

uint64_t __CFRunLoopDoSource1(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t (**v3)(uint64_t, uint64_t, __objc2_class **, uint64_t);
  uint64_t (**v4)(uint64_t, uint64_t, __objc2_class **, uint64_t);
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  pthread_mutex_t *v14;
  pthread_mutex_t *v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(uint64_t, uint64_t, __objc2_class **, uint64_t);
  uint64_t v21;
  void *v22;
  uint64_t v24;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v13 = v2;
  v24 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  CFRetain((CFTypeRef)v10);
  v14 = (pthread_mutex_t *)(v12 + 16);
  pthread_mutex_unlock((pthread_mutex_t *)(v12 + 16));
  v15 = (pthread_mutex_t *)(v13 + 16);
  pthread_mutex_unlock((pthread_mutex_t *)(v13 + 16));
  pthread_mutex_lock((pthread_mutex_t *)(v10 + 16));
  v16 = atomic_load((unint64_t *)(v10 + 8));
  if ((v16 & 8) != 0)
  {
    atomic_store(0, (unint64_t *)(v10 + 88));
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 16));
    v18 = v8;
    v19 = v6;
    v20 = *(uint64_t (**)(uint64_t, uint64_t, __objc2_class **, uint64_t))(v10 + 168);
    v21 = *(_QWORD *)(v10 + 112);
    if (v13 && !*(_BYTE *)(v13 + 681))
      v22 = 0;
    else
      v22 = (void *)_CFAutoreleasePoolPush();
    kdebug_trace();
    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(v20, v18, v19, v4, v21);
    kdebug_trace();
    __CFRunLoopPerCalloutARPEnd(v22);
    if ((__CF_FORK_STATE & 2) == 0)
      __CF_USED();
    v15 = (pthread_mutex_t *)(v13 + 16);
    v14 = (pthread_mutex_t *)(v12 + 16);
    if ((__CF_FORK_STATE & 1) != 0)
      __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
    v17 = 1;
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v10 + 16));
    v17 = 0;
  }
  CFRelease((CFTypeRef)v10);
  pthread_mutex_lock(v15);
  pthread_mutex_lock(v14);
  return v17;
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(uint64_t (*result)(uint64_t, uint64_t, __objc2_class **, uint64_t), uint64_t a2, uint64_t a3, uint64_t (**a4)(uint64_t, uint64_t, __objc2_class **, uint64_t), uint64_t a5))(uint64_t, uint64_t, __objc2_class **, uint64_t)
{
  if (result)
  {
    result = (uint64_t (*)(uint64_t, uint64_t, __objc2_class **, uint64_t))result(a2, a3, &__kCFAllocatorSystemDefault, a5);
    *a4 = result;
  }
  return result;
}

uint64_t __CFMachPortPerform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v7)(_QWORD);
  uint64_t v8;
  void (*v9)(uint64_t);

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a4 + 96));
    if (*(_DWORD *)(a4 + 16))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a4 + 96));
    }
    else
    {
      v7 = *(uint64_t (**)(_QWORD))(a4 + 104);
      v8 = *(_QWORD *)(a4 + 64);
      if (v7)
      {
        v8 = v7(*(_QWORD *)(a4 + 64));
        v9 = *(void (**)(uint64_t))(a4 + 112);
      }
      else
      {
        v9 = 0;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(a4 + 96));
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 48))(a4, a1, a2, v8);
      if (v9)
        v9(v8);
      if ((__CF_FORK_STATE & 2) == 0)
        __CF_USED();
      if ((__CF_FORK_STATE & 1) != 0)
        __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
    }
  }
  return 0;
}

uint64_t __CFBasicHashFastEnumeration(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v7 = *a2;
  if (!*a2)
    a2[2] = a1 + 16;
  a2[1] = a3;
  v8 = *(unsigned int *)(a1 + 20);
  v9 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  if ((_DWORD)v8)
    v10 = v7 < v9;
  else
    v10 = 0;
  v11 = 0;
  if (v10 && a4 >= 1)
  {
    do
    {
      v14 = 0u;
      v15 = 0u;
      CFBasicHashGetBucket(a1, v7, &v14);
      if (*((_QWORD *)&v15 + 1))
      {
        *(_QWORD *)(a2[1] + 8 * v11++) = *((_QWORD *)&v14 + 1);
        --v8;
      }
      ++*a2;
      if (v8 < 1)
        break;
      if (++v7 >= v9)
        break;
    }
    while (v11 < a4);
  }
  return v11;
}

CFMutableDictionaryRef __CFPropertyListCreateFilteredDictionary(const __CFAllocator *a1, const __CFSet *a2, uint64_t a3, int a4, unint64_t a5, uint64_t a6, int a7, int a8, int a9, int a10, int a11, const __CFSet *a12, uint64_t a13)
{
  unint64_t v20;
  _BYTE *v21;
  char v22;
  unsigned int *v23;
  unint64_t v24;
  unsigned __int8 *v25;
  char v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  unsigned int v32;
  uint64_t v33;
  const char *CStringPtr;
  CFMutableDictionaryRef Mutable;
  BOOL v37;
  char v38;
  void **v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unsigned int *v43;
  unsigned int v44;
  unint64_t v45;
  unsigned int *v46;
  uint64_t v47;
  unsigned int v48;
  CFSetRef v49;
  int v50;
  CFStringRef v52;
  unsigned int *v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  unsigned int v57;
  uint64_t v58;
  unsigned int *v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  void *v67;
  const char *v68;
  char v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  _QWORD v73[5];
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  CFIndex Count;
  CFTypeRef cf;
  CFSetRef theSet;
  uint64_t v80;
  CFStringRef Copy;
  void *values[8];
  char buffer[8];
  uint64_t v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  cf = 0;
  theSet = 0;
  __CFPropertyListCreateSplitKeypaths((const __CFAllocator *)&__kCFAllocatorSystemDefault, a2, &theSet, (__CFSet **)&cf);
  if (!theSet)
    return 0;
  if (a5 < 8)
    goto LABEL_36;
  v20 = *(_QWORD *)(a6 + 24) - 1;
  if (v20 < a5)
    goto LABEL_36;
  v21 = (_BYTE *)(a3 + a5);
  if (a3 + a5 == -1)
    goto LABEL_36;
  v22 = *v21;
  if ((*v21 & 0xF0) != 0xD0)
    goto LABEL_36;
  v23 = (unsigned int *)(v21 + 1);
  v24 = v22 & 0xF;
  if ((v22 & 0xF) == 0xF)
  {
    if (a3 + v20 < (unint64_t)v23)
      goto LABEL_36;
    v25 = v21 + 2;
    v26 = *(_BYTE *)v23;
    if ((*(_BYTE *)v23 & 0xF0) != 0x10)
      goto LABEL_36;
    v27 = v26 & 0xF;
    v28 = 1 << (v26 & 0xF);
    if (__CFADD__(v28, v25) || (unint64_t)v23 + v28 > a3 + v20)
      goto LABEL_36;
    switch((char)v28)
    {
      case 1:
        v24 = *v25;
        goto LABEL_24;
      case 2:
        v24 = __rev16(*(unsigned __int16 *)((char *)v23 + 1));
        goto LABEL_24;
      case 4:
        v24 = bswap32(*(unsigned int *)((char *)v23 + 1));
        goto LABEL_24;
      case 8:
        v24 = bswap64(*(_QWORD *)((char *)v23 + 1));
        goto LABEL_23;
      default:
        if (v27 >= 8)
        {
          v24 = 0;
          v29 = 0;
          v23 = (unsigned int *)&v25[v28];
          goto LABEL_29;
        }
        v24 = 0;
        if ((v28 & 0xFE) != 0)
          v30 = v28;
        else
          v30 = 1;
        v31 = (unsigned __int8 *)v23 + 1;
        do
        {
          v32 = *v31++;
          v24 = v32 | (v24 << 8);
          --v30;
        }
        while (v30);
LABEL_23:
        if ((v24 & 0x8000000000000000) != 0)
          goto LABEL_36;
LABEL_24:
        v23 = (unsigned int *)&v25[v28];
        break;
    }
  }
  if (v24)
  {
    if (!is_mul_ok(2 * v24, *(unsigned __int8 *)(a6 + 7)))
      goto LABEL_36;
    v29 = 2 * v24 * *(unsigned __int8 *)(a6 + 7);
  }
  else
  {
    v29 = 0;
  }
LABEL_29:
  if (__CFADD__(v29, v23) || a3 + v20 < (unint64_t)v23 + v29 - 1)
  {
LABEL_36:
    CFRelease(theSet);
    if (cf)
      CFRelease(cf);
    return 0;
  }
  v70 = v24;
  v33 = *(unsigned __int8 *)(a6 + 7);
  v74 = 0;
  v75 = &v74;
  v76 = 0x2020000000;
  Count = 0;
  Count = CFSetGetCount(theSet);
  v73[0] = MEMORY[0x1E0C809B0];
  v73[1] = 3221225472;
  v73[2] = ____CFPropertyListCreateFilteredDictionary_block_invoke;
  v73[3] = &unk_1E12E0FA0;
  v73[4] = &v74;
  CFSetApply(theSet, (uint64_t)v73);
  *(_QWORD *)buffer = 0;
  v84 = 0;
  if (CFSetGetCount(theSet) != 1)
    goto LABEL_40;
  values[0] = 0;
  CFSetGetValues(theSet, (const void **)values);
  CStringPtr = CFStringGetCStringPtr((CFStringRef)values[0], 0);
  if (!CStringPtr)
  {
    if (CFStringGetCString((CFStringRef)values[0], buffer, 16, 0))
    {
      CStringPtr = buffer;
      goto LABEL_35;
    }
LABEL_40:
    v67 = 0;
    v68 = 0;
    goto LABEL_41;
  }
LABEL_35:
  v68 = CStringPtr;
  v67 = (void *)strlen(CStringPtr);
LABEL_41:
  Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v70)
  {
    v66 = v70 * v33;
    v71 = a3 + 8;
    v72 = 0;
    if (v67)
      v37 = v68 == 0;
    else
      v37 = 1;
    v38 = v37;
    v69 = v38;
    v39 = values;
    if (a7)
      v39 = 0;
    v65 = (uint64_t)v39;
    while (1)
    {
      if (!v75[3])
        goto LABEL_122;
      if (v71 > (unint64_t)v23)
        goto LABEL_119;
      v40 = *(_QWORD *)(a6 + 24);
      v41 = *(unsigned __int8 *)(a6 + 7);
      if (a3 + v40 - v41 < (unint64_t)v23)
        goto LABEL_119;
      v42 = *(unsigned __int8 *)(a6 + 7);
      switch(*(_BYTE *)(a6 + 7))
      {
        case 0:
          break;
        case 1:
          v42 = *(unsigned __int8 *)v23;
          break;
        case 2:
          v42 = __rev16(*(unsigned __int16 *)v23);
          break;
        case 4:
          v42 = bswap32(*v23);
          break;
        case 8:
          v42 = bswap64(*(_QWORD *)v23);
          break;
        default:
          v42 = 0;
          v43 = v23;
          do
          {
            v44 = *(unsigned __int8 *)v43;
            v43 = (unsigned int *)((char *)v43 + 1);
            v42 = v44 | (v42 << 8);
            --v41;
          }
          while (v41);
          break;
      }
      if (*(_QWORD *)(a6 + 8) <= v42)
      {
LABEL_119:
        CFRelease(Mutable);
LABEL_121:
        Mutable = 0;
        goto LABEL_122;
      }
      v45 = *(unsigned __int8 *)(a6 + 6);
      v46 = (unsigned int *)(a3 + v40 + v42 * v45);
      switch(*(_BYTE *)(a6 + 6))
      {
        case 0:
          break;
        case 1:
          v45 = *(unsigned __int8 *)v46;
          break;
        case 2:
          v45 = __rev16(*(unsigned __int16 *)v46);
          break;
        case 4:
          v45 = bswap32(*v46);
          break;
        case 8:
          v45 = bswap64(*(_QWORD *)v46);
          break;
        default:
          v47 = *(unsigned __int8 *)(a6 + 6);
          v45 = 0;
          do
          {
            v48 = *(unsigned __int8 *)v46;
            v46 = (unsigned int *)((char *)v46 + 1);
            v45 = v48 | (v45 << 8);
            --v47;
          }
          while (v47);
          break;
      }
      v49 = theSet;
      Copy = 0;
      if ((v69 & 1) == 0 && (*(_BYTE *)(a3 + v45) & 0xF0) == 0x50)
        break;
      values[0] = 0;
      v80 = 0;
      if (__CFBinaryPlistCreateObjectFiltered(a3, a4, v45, a6, (int)&__kCFAllocatorSystemDefault, 0x80000000, a9, a11, a12, 0, 0, (uint64_t)values, (uint64_t)&v80))
      {
        if ((unint64_t)(v80 - 17) >= 3 && v80 != 0)
        {
          if (v80 == 7 && __CFPropertyListKeyPassesFilterSet((uint64_t)values[0], v49))
            Copy = CFStringCreateCopy(a1, (CFStringRef)values[0]);
          if (values[0])
            CFRelease(values[0]);
          v50 = 0;
LABEL_87:
          v52 = Copy;
          if (Copy)
            goto LABEL_89;
          goto LABEL_88;
        }
      }
      v52 = 0;
      v50 = 1;
LABEL_88:
      if (v50)
        goto LABEL_119;
LABEL_89:
      if (v52)
      {
        v53 = (unsigned int *)((char *)v23 + v66);
        if (v71 > (unint64_t)v23 + v66)
          goto LABEL_120;
        v54 = a3 + *(_QWORD *)(a6 + 24);
        v55 = *(unsigned __int8 *)(a6 + 7);
        if (v54 - v55 < (unint64_t)v53)
          goto LABEL_120;
        v56 = *(unsigned __int8 *)(a6 + 7);
        switch(*(_BYTE *)(a6 + 7))
        {
          case 0:
            break;
          case 1:
            v56 = *(unsigned __int8 *)v53;
            break;
          case 2:
            v56 = __rev16(*(unsigned __int16 *)v53);
            break;
          case 4:
            v56 = bswap32(*v53);
            break;
          case 8:
            v56 = bswap64(*(_QWORD *)v53);
            break;
          default:
            v56 = 0;
            do
            {
              v57 = *(unsigned __int8 *)v53;
              v53 = (unsigned int *)((char *)v53 + 1);
              v56 = v57 | (v56 << 8);
              --v55;
            }
            while (v55);
            break;
        }
        if (*(_QWORD *)(a6 + 8) <= v56)
          goto LABEL_120;
        v58 = *(unsigned __int8 *)(a6 + 6);
        v59 = (unsigned int *)(v54 + v56 * v58);
        switch(*(_BYTE *)(a6 + 6))
        {
          case 0:
            break;
          case 1:
            LODWORD(v58) = *(unsigned __int8 *)v59;
            break;
          case 2:
            LODWORD(v58) = __rev16(*(unsigned __int16 *)v59);
            break;
          case 4:
            LODWORD(v58) = bswap32(*v59);
            break;
          case 8:
            LODWORD(v58) = bswap64(*(_QWORD *)v59);
            break;
          default:
            v60 = *(unsigned __int8 *)(a6 + 6);
            LODWORD(v58) = 0;
            do
            {
              v61 = *(unsigned __int8 *)v59;
              v59 = (unsigned int *)((char *)v59 + 1);
              LODWORD(v58) = v61 | ((_DWORD)v58 << 8);
              --v60;
            }
            while (v60);
            break;
        }
        values[0] = 0;
        if (!__CFBinaryPlistCreateObjectFiltered(a3, a4, v58, a6, (int)a1, a8, a9, a11, a12, a13 + 1, (uint64_t)cf, v65, 0))
        {
LABEL_120:
          CFRelease(v52);
          CFRelease(Mutable);
          goto LABEL_121;
        }
        v62 = v75[3];
        v63 = v62 < 1;
        v64 = v62 - 1;
        if (!v63)
          v75[3] = v64;
        if (values[0])
        {
          CFDictionarySetValue(Mutable, v52, values[0]);
          CFRelease(values[0]);
        }
        CFRelease(v52);
      }
      v23 = (unsigned int *)((char *)v23 + *(unsigned __int8 *)(a6 + 7));
      if (++v72 == v70)
        goto LABEL_122;
    }
    Copy = 0;
    values[0] = (void *)MEMORY[0x1E0C809B0];
    values[1] = (void *)3221225472;
    values[2] = ____CFPropertyListTryFilteredDictionaryASCIIFastPath_block_invoke;
    values[3] = &__block_descriptor_64_e12_B24__0r_8q16l;
    values[4] = (void *)v68;
    values[5] = v67;
    values[6] = &Copy;
    values[7] = a1;
    v50 = __CFBinaryPlistParseASCIIString(a3, v40 - 1, (_BYTE *)(a3 + v45), (uint64_t)values) ^ 1;
    goto LABEL_87;
  }
LABEL_122:
  if (theSet)
    CFRelease(theSet);
  if (cf)
    CFRelease(cf);
  _Block_object_dispose(&v74, 8);
  return Mutable;
}

void sub_182ADF0F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t __CFBinaryPlistParseASCIIString(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  unsigned __int8 *v4;
  char v5;
  unint64_t v6;
  unsigned __int8 *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned int v12;

  if (a3 != (_BYTE *)-1)
  {
    v5 = *a3;
    v4 = a3 + 1;
    v6 = v5 & 0xF;
    if ((_DWORD)v6 == 15)
    {
      if (a1 + a2 >= (unint64_t)v4)
      {
        v7 = v4 + 1;
        if ((*v4 & 0xF0) == 0x10)
        {
          v8 = *v4 & 0xF;
          v9 = 1 << v8;
          if (!__CFADD__(1 << v8, v7) && (unint64_t)&v4[v9] <= a1 + a2)
          {
            switch((1 << v8))
            {
              case 1u:
                v6 = *v7;
                goto LABEL_20;
              case 2u:
                v6 = __rev16(*(unsigned __int16 *)(v4 + 1));
                goto LABEL_20;
              case 4u:
                v6 = bswap32(*(_DWORD *)(v4 + 1));
                goto LABEL_20;
              case 8u:
                v6 = bswap64(*(_QWORD *)(v4 + 1));
                goto LABEL_19;
              default:
                if (v8 > 7)
                {
                  v6 = 0;
LABEL_20:
                  v4 = &v7[v9];
                  goto LABEL_21;
                }
                v6 = 0;
                if ((v9 & 0xFE) != 0)
                  v10 = v9;
                else
                  v10 = 1;
                v11 = v4 + 1;
                do
                {
                  v12 = *v11++;
                  v6 = v12 | (v6 << 8);
                  --v10;
                }
                while (v10);
LABEL_19:
                if ((v6 & 0x8000000000000000) == 0)
                  goto LABEL_20;
                break;
            }
          }
        }
      }
    }
    else
    {
LABEL_21:
      if (!__CFADD__(v6, v4) && a1 + a2 >= (unint64_t)&v4[v6 - 1])
        return (*(uint64_t (**)(uint64_t, unsigned __int8 *, unint64_t))(a4 + 16))(a4, v4, v6);
    }
  }
  return 0;
}

BOOL __CFPropertyListKeyBufferMatchesFilterBuffer(unsigned __int8 *a1, uint64_t a2, _BYTE *__s2, uint64_t __n)
{
  uint64_t v4;
  int v5;
  _BYTE *v7;
  size_t v8;

  v4 = __n - 1;
  if (__n != 1)
  {
    if (__n >= 2 && __s2[v4] == 42)
    {
      if (v4 <= a2)
      {
        v7 = __s2;
        v8 = __n - 1;
        return memcmp(a1, v7, v8) == 0;
      }
    }
    else if (a2 == __n)
    {
      v7 = __s2;
      v8 = __n;
      return memcmp(a1, v7, v8) == 0;
    }
    return 0;
  }
  v5 = *__s2;
  if (v5 == 42)
    return 1;
  if (a2 != 1)
    return 0;
  return v5 == *a1;
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
  CFIndex Count;

  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet getObjects:](theSet, "getObjects:", values);
  }
  else
  {
    Count = CFSetGetCount(theSet);
    CFBasicHashGetElements((uint64_t)theSet, Count, 0, (uint64_t)values);
  }
}

uint64_t __CFPropertyListKeyPassesFilterSet(uint64_t a1, void *a2)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ____CFPropertyListKeyPassesFilterSet_block_invoke;
  v4[3] = &unk_1E12E5E68;
  v4[4] = &v5;
  v4[5] = a1;
  CFSetApply(a2, (uint64_t)v4);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_182ADF468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t CFSetApply(void *a1, uint64_t a2)
{
  _QWORD v5[6];

  v5[5] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)a1))
    return objc_msgSend(a1, "enumerateObjectsWithOptions:usingBlock:", 0, a2);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __CFSetApply_block_invoke;
  v5[3] = &unk_1E12E14A8;
  v5[4] = a2;
  return CFBasicHashApply((uint64_t)a1, (uint64_t)v5);
}

uint64_t CFBasicHashGetElements(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned int *)(result + 20);
  v5 = __CFBasicHashTableSizes[*(unsigned __int8 *)(result + 26)];
  if ((_DWORD)v4)
    v6 = v5 < 1;
  else
    v6 = 1;
  if (!v6 && a2 >= 1)
  {
    v11 = result;
    v12 = 0;
    v13 = 0;
    do
    {
      v18 = 0u;
      v19 = 0u;
      result = CFBasicHashGetBucket(v11, v12, &v18);
      if (*((_QWORD *)&v19 + 1))
      {
        --v4;
        if (v13 < a2)
        {
          v15 = *((_QWORD *)&v18 + 1);
          v14 = v19;
          v16 = *((_QWORD *)&v19 + 1) - 1;
          do
          {
            if (a3)
              *(_QWORD *)(a3 + 8 * v13) = v14;
            if (a4)
              *(_QWORD *)(a4 + 8 * v13) = v15;
            ++v13;
            v17 = v16-- != 0;
          }
          while (v17 && v13 < a2);
        }
      }
      if (v4 < 1)
        break;
      if (++v12 >= v5)
        break;
    }
    while (v13 < a2);
  }
  return result;
}

uint64_t CFBasicHashApply(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, _OWORD *);
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(result + 20);
  v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(result + 26)];
  if ((_DWORD)v2)
    v4 = v3 < 1;
  else
    v4 = 1;
  if (!v4)
  {
    v6 = result;
    v7 = 1;
    do
    {
      v11 = 0u;
      v12 = 0u;
      result = CFBasicHashGetBucket(v6, v7 - 1, &v11);
      if (*((_QWORD *)&v12 + 1))
      {
        v8 = *(uint64_t (**)(uint64_t, _OWORD *))(a2 + 16);
        v10[0] = v11;
        v10[1] = v12;
        result = v8(a2, v10);
        if (!(_DWORD)result)
          return result;
        v2 -= (_DWORD)result != 0;
      }
    }
    while (v2 >= 1 && v7++ < v3);
  }
  return result;
}

uint64_t CFBasicHashGetBucket@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t result;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t);

  a3[2] = 0;
  a3[3] = 0;
  *a3 = a2;
  a3[1] = 0;
  result = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * a2);
  if ((unint64_t)(result - 1) >= 0xFFFFFFFFFFFFFFFELL)
  {
    a3[1] = 0;
    a3[2] = 0;
    a3[3] = 0;
    return result;
  }
  v6 = *(unsigned __int16 *)(a1 + 18);
  if ((v6 & 0x18) != 0)
    __asm { BR              X13 }
  v7 = -1;
  if (result != 2780474809)
    v7 = result;
  if (result == 2814029233)
    v8 = 0;
  else
    v8 = v7;
  a3[2] = v8;
  a3[3] = 1;
  if ((v6 & 4) != 0)
  {
    result = *(_QWORD *)(*(_QWORD *)(a1 + 8 * ((v6 >> 2) & 1) + 40) + 8 * a2);
LABEL_16:
    if (result == 2814029233)
    {
      result = 0;
    }
    else if (result == 2780474809)
    {
      result = -1;
    }
    goto LABEL_23;
  }
  if ((v6 & 0x8000) == 0)
    goto LABEL_16;
  if (result == 2814029233)
  {
    result = 0;
  }
  else if (result == 2780474809)
  {
    result = -1;
  }
  v9 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(a1 + 32) >> 54) >> 5]
                                         + 8 * ((*(_QWORD *)(a1 + 32) >> 54) & 0x1FLL));
  if (v9)
    result = v9(result);
LABEL_23:
  a3[1] = result;
  return result;
}

void __CFRunLoopCollectSources0(unint64_t *cf, CFTypeRef *a2)
{
  char v3;
  CFTypeID v6;
  CFTypeRef v7;
  __CFArray *Mutable;

  if (!cf[13])
  {
    v3 = atomic_load(cf + 1);
    if ((v3 & 8) != 0)
    {
      if (atomic_load(cf + 11))
      {
        if (*a2)
        {
          v6 = CFGetTypeID(*a2);
          v7 = *a2;
          if (v6 == 46)
          {
            Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
            *a2 = Mutable;
            CFArrayAppendValue(Mutable, v7);
            CFArrayAppendValue((CFMutableArrayRef)*a2, cf);
            CFRelease(v7);
          }
          else
          {
            CFArrayAppendValue((CFMutableArrayRef)*a2, cf);
          }
        }
        else
        {
          *a2 = CFRetain(cf);
        }
      }
    }
  }
}

BOOL __CFPropertyListFilterKeyHasWildcard(const __CFString *a1)
{
  CFIndex Length;

  Length = CFStringGetLength(a1);
  return Length >= 1 && CFStringGetCharacterAtIndex(a1, Length - 1) == 42;
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
  unsigned __int8 v2;
  unint64_t v3;
  mach_port_t v4;
  mach_msg_return_t v5;
  mach_msg_header_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v2 = atomic_load(__CFMainThreadHasExited);
  if ((v2 & 1) != 0 && CFRunLoopGetMain() == rl)
  {
    if (CFRunLoopWakeUp_onceToken != -1)
      dispatch_once(&CFRunLoopWakeUp_onceToken, &__block_literal_global_14);
    _CFRunLoopError_MainThreadHasExited();
  }
  else
  {
    v3 = _CFGetNonObjCTypeID((unint64_t *)rl);
    if (v3 != 43)
      _CFAssertMismatchedTypeID(0x2BuLL, v3);
    pthread_mutex_lock((pthread_mutex_t *)((char *)rl + 16));
    if (*((_BYTE *)rl + *((unsigned __int8 *)rl + 84) + 339))
    {
      pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
    }
    else
    {
      kdebug_trace();
      v4 = *((_DWORD *)rl + 20);
      *(_QWORD *)&v6.msgh_bits = 0x1800000013;
      v6.msgh_remote_port = v4;
      v6.msgh_local_port = 0;
      *(_QWORD *)&v6.msgh_voucher_port = 0;
      v5 = mach_msg(&v6, 17, 0x18u, 0, 0, 0, 0);
      __CFMachMessageCheckForAndDestroyUnsentMessage(v5, &v6);
      if (v5)
      {
        if (v5 != 268435460)
          CFRunLoopWakeUp_cold_1();
      }
      kdebug_trace();
      pthread_mutex_unlock((pthread_mutex_t *)((char *)rl + 16));
    }
  }
}

uint64_t __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()
{
  return _dispatch_main_queue_callback_4CF();
}

uint64_t __CFRunLoopDoSource0(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v4;
  char v6;
  uint64_t (*v7)(uint64_t);
  uint64_t v8;
  void *v9;

  v4 = (pthread_mutex_t *)(a2 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 16));
  if (!atomic_load((unint64_t *)(a2 + 88)))
  {
    pthread_mutex_unlock(v4);
    return 0;
  }
  atomic_store(0, (unint64_t *)(a2 + 88));
  v6 = atomic_load((unint64_t *)(a2 + 8));
  pthread_mutex_unlock(v4);
  if ((v6 & 8) == 0)
    return 0;
  v7 = *(uint64_t (**)(uint64_t))(a2 + 176);
  v8 = *(_QWORD *)(a2 + 112);
  if (a1 && !*(_BYTE *)(a1 + 681))
    v9 = 0;
  else
    v9 = (void *)_CFAutoreleasePoolPush();
  kdebug_trace();
  __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(v7, v8);
  kdebug_trace();
  __CFRunLoopPerCalloutARPEnd(v9);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  return 1;
}

uint64_t (*__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(uint64_t (*result)(uint64_t), uint64_t a2))(uint64_t)
{
  if (result)
    return (uint64_t (*)(uint64_t))result(a2);
  return result;
}

void CFRunLoopSourceSignal(CFRunLoopSourceRef source)
{
  unint64_t v2;
  char v3;
  unint64_t *v4;
  uint64_t v5;

  v2 = _CFGetNonObjCTypeID((unint64_t *)source);
  if (v2 != 46)
    _CFAssertMismatchedTypeID(0x2EuLL, v2);
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  pthread_mutex_lock((pthread_mutex_t *)((char *)source + 16));
  v3 = atomic_load((unint64_t *)source + 1);
  if ((v3 & 8) != 0)
  {
    kdebug_trace();
    v4 = (unint64_t *)((char *)source + 88);
    v5 = mach_absolute_time();
    while (!__ldaxr(v4))
    {
      if (!__stlxr(v5, v4))
        goto LABEL_12;
    }
    __clrex();
LABEL_12:
    kdebug_trace();
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)source + 16));
}

void __CFMachMessageCheckForAndDestroyUnsentMessage(int a1, mach_msg_header_t *a2)
{
  mach_port_t msgh_local_port;
  mach_msg_bits_t msgh_bits;

  if (a1 != 268435463)
  {
    if (a1 == 268435459)
    {
LABEL_10:
      mach_msg_destroy(a2);
      return;
    }
    if (a1 != 16)
      return;
  }
  msgh_local_port = a2->msgh_local_port;
  if (msgh_local_port - 1 <= 0xFFFFFFFD)
  {
    msgh_bits = a2->msgh_bits;
    if (((a2->msgh_bits >> 8) & 0x1F) - 17 <= 1)
    {
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], msgh_local_port);
      msgh_bits = a2->msgh_bits;
    }
    a2->msgh_bits = msgh_bits & 0xFFFFE0FF;
  }
  if (a1 == 268435459 || a1 == 16)
    goto LABEL_10;
}

void __CFRunLoopAddItemToCommonModes(const __CFString *a1, uint64_t a2)
{
  void *v3;
  __CFRunLoop *v4;
  CFTypeID v5;

  v4 = *(__CFRunLoop **)a2;
  v3 = *(void **)(a2 + 8);
  v5 = CFGetTypeID(v3);
  switch(v5)
  {
    case '-':
      CFRunLoopAddObserver(v4, (CFRunLoopObserverRef)v3, a1);
      break;
    case '/':
      CFRunLoopAddTimer(v4, (CFRunLoopTimerRef)v3, a1);
      break;
    case '.':
      CFRunLoopAddSource(v4, (CFRunLoopSourceRef)v3, a1);
      break;
  }
}

void __CFRunLoopRemoveItemFromCommonModes(const __CFString *a1, uint64_t a2)
{
  void *v3;
  __CFRunLoop *v4;
  CFTypeID v5;

  v4 = *(__CFRunLoop **)a2;
  v3 = *(void **)(a2 + 8);
  v5 = CFGetTypeID(v3);
  switch(v5)
  {
    case '-':
      CFRunLoopRemoveObserver(v4, (CFRunLoopObserverRef)v3, a1);
      break;
    case '/':
      CFRunLoopRemoveTimer(v4, (CFRunLoopTimerRef)v3, a1);
      break;
    case '.':
      CFRunLoopRemoveSource(v4, (CFRunLoopSourceRef)v3, a1);
      break;
  }
}

void __CFRunLoopGetModeName(uint64_t a1, CFMutableArrayRef theArray)
{
  CFArrayAppendValue(theArray, *(const void **)(a1 + 80));
}

double __CFTSRToTimeInterval(unint64_t a1)
{
  if (CFDateGetTypeID_initOnce != -1)
    dispatch_once(&CFDateGetTypeID_initOnce, &__block_literal_global_100);
  return *(double *)&__CF1_TSRRate * (double)a1;
}

void ___copyIngestedCacheResult_block_invoke_2(uint64_t a1, const void *a2)
{
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), a2);
}

void sub_182AE0650(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t CFBasicHashesAreEqual(uint64_t a1, uint64_t a2)
{
  uint64_t Count;
  uint64_t v5;
  _QWORD v7[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  Count = CFBasicHashGetCount(a1);
  if (Count != CFBasicHashGetCount(a2))
    return 0;
  v5 = 1;
  if (Count)
  {
    v8 = 0;
    v9 = &v8;
    v10 = 0x2020000000;
    v11 = 1;
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = __CFBasicHashesAreEqual_block_invoke;
    v7[3] = &unk_1E1335AE8;
    v7[4] = &v8;
    v7[5] = a2;
    v7[6] = a1;
    CFBasicHashApply(a1, (uint64_t)v7);
    v5 = *((unsigned __int8 *)v9 + 24);
    _Block_object_dispose(&v8, 8);
  }
  return v5;
}

void sub_182AE0850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __CFRunLoopAddItemsToCommonMode(void *a1, uint64_t a2)
{
  const __CFString *v3;
  __CFRunLoop *v4;
  CFTypeID v5;

  v4 = *(__CFRunLoop **)a2;
  v3 = *(const __CFString **)(a2 + 8);
  v5 = CFGetTypeID(a1);
  switch(v5)
  {
    case '-':
      CFRunLoopAddObserver(v4, (CFRunLoopObserverRef)a1, v3);
      break;
    case '/':
      CFRunLoopAddTimer(v4, (CFRunLoopTimerRef)a1, v3);
      break;
    case '.':
      CFRunLoopAddSource(v4, (CFRunLoopSourceRef)a1, v3);
      break;
  }
}

void _CFPrefsSynchronizeDirtySourceForTimer(void *a1)
{
  uint64_t v2;
  const void *v3;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t);
  void (*v9)(uint64_t);
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6 = &v5;
  v7 = 0x3052000000;
  v8 = __Block_byref_object_copy__321;
  v9 = __Block_byref_object_dispose__322;
  v10 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___CFPrefsSynchronizeDirtySourceForTimer_block_invoke;
  v4[3] = &unk_1E13366E0;
  v4[4] = a1;
  v4[5] = &v5;
  objc_msgSend(a1, "lockedSync:", v4);
  v2 = v6[5];
  if (v2)
  {
    v3 = (const void *)(*(uint64_t (**)(void))(v2 + 16))();
    objc_msgSend(a1, "finishedNonRequestWriteWithResult:", v3);
    if (v3)
      CFRelease(v3);
  }

  _Block_object_dispose(&v5, 8);
}

void sub_182AE0AF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __CFRunLoopDeallocateTimers(uint64_t a1, void *a2)
{
  const __CFArray *v3;
  CFIndex Count;
  CFRange v6;

  v3 = *(const __CFArray **)(a1 + 120);
  if (v3)
  {
    Count = CFArrayGetCount(v3);
    if (Count)
    {
      v6.length = Count;
      v6.location = 0;
      CFArrayApplyFunction(*(CFArrayRef *)(a1 + 120), v6, (CFArrayApplierFunction)__CFRunLoopKillOneTimer, a2);
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 120));
    }
  }
}

void __CFRunLoopDeallocateSources(uint64_t a1, const void *a2)
{
  const __CFSet *v4;
  CFIndex Count;
  const __CFSet *v6;
  CFMutableSetRef *v7;
  uint64_t v8;
  const void **Typed;
  const __CFSet *v10;
  const __CFSet *v11;
  CFIndex v12;
  const void **v13;
  uint64_t v14;
  const void *v15;
  __CFSet *v16;
  ipc_space_t *v17;
  const void **v18;
  const void *v19;
  pthread_mutex_t *v20;
  __CFBag *v21;
  uint64_t v22;
  void (*v23)(_QWORD, const void *, _QWORD);
  mach_port_name_t v24;
  _OWORD v25[128];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v4 = *(const __CFSet **)(a1 + 96);
  if (v4)
  {
    Count = CFSetGetCount(v4);
    v7 = (CFMutableSetRef *)(a1 + 104);
    v6 = *(const __CFSet **)(a1 + 104);
    if (!v6)
      goto LABEL_7;
  }
  else
  {
    v7 = (CFMutableSetRef *)(a1 + 104);
    v6 = *(const __CFSet **)(a1 + 104);
    if (!v6)
      return;
    Count = 0;
  }
  v6 = (const __CFSet *)CFSetGetCount(v6);
LABEL_7:
  v8 = (uint64_t)v6 + Count;
  if ((uint64_t)v6 + Count >= 257)
    Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v8, 0x80040B8603338, 0);
  else
    Typed = (const void **)v25;
  memset(v25, 0, 512);
  v10 = *(const __CFSet **)(a1 + 96);
  if (v10)
    CFSetGetValues(v10, Typed);
  v11 = *v7;
  if (*v7)
  {
    v12 = *(_QWORD *)(a1 + 96);
    if (v12)
      v12 = CFSetGetCount((CFSetRef)v12);
    CFSetGetValues(v11, &Typed[v12]);
  }
  if (v8 >= 1)
  {
    v13 = Typed;
    v14 = v8;
    do
    {
      v15 = *v13++;
      CFRetain(v15);
      --v14;
    }
    while (v14);
  }
  v16 = *(__CFSet **)(a1 + 96);
  if (v16)
    CFSetRemoveAllValues(v16);
  if (*v7)
    CFSetRemoveAllValues(*v7);
  if (v8 >= 1)
  {
    v17 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    v18 = Typed;
    do
    {
      v19 = *v18;
      v20 = (pthread_mutex_t *)((char *)*v18 + 16);
      pthread_mutex_lock(v20);
      v21 = (__CFBag *)*((_QWORD *)v19 + 12);
      if (v21)
        CFBagRemoveValue(v21, a2);
      pthread_mutex_unlock(v20);
      v22 = *((_QWORD *)v19 + 13);
      if (v22 == 1)
      {
        v24 = (*((uint64_t (**)(_QWORD))v19 + 20))(*((_QWORD *)v19 + 14));
        if (v24)
          mach_port_extract_member(*v17, v24, *(_DWORD *)(a1 + 136));
      }
      else if (!v22)
      {
        v23 = (void (*)(_QWORD, const void *, _QWORD))*((_QWORD *)v19 + 21);
        if (v23)
          v23(*((_QWORD *)v19 + 14), a2, *(_QWORD *)(a1 + 80));
      }
      CFRelease(v19);
      ++v18;
      --v8;
    }
    while (v8);
  }
  if (Typed != (const void **)v25)
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
}

void __CFRunLoopDeallocateObservers(uint64_t a1)
{
  const __CFArray *v2;
  uint64_t Count;
  const void **Typed;
  const void **v5;
  uint64_t v6;
  const void *v7;
  uint64_t *v8;
  const void *v9;
  _OWORD v10[128];
  uint64_t v11;
  CFRange v12;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = *(const __CFArray **)(a1 + 112);
  if (v2)
  {
    Count = CFArrayGetCount(v2);
    if (Count >= 257)
      Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0x80040B8603338, 0);
    else
      Typed = (const void **)v10;
    memset(v10, 0, 512);
    v12.location = 0;
    v12.length = Count;
    CFArrayGetValues(*(CFArrayRef *)(a1 + 112), v12, Typed);
    if (Count < 1)
    {
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 112));
    }
    else
    {
      v5 = Typed;
      v6 = Count;
      do
      {
        v7 = *v5++;
        CFRetain(v7);
        --v6;
      }
      while (v6);
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 112));
      v8 = (uint64_t *)Typed;
      do
      {
        __CFRunLoopObserverCancel(*v8);
        v9 = (const void *)*v8++;
        CFRelease(v9);
        --Count;
      }
      while (Count);
    }
    if (Typed != (const void **)v10)
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
}

void __CFRunLoopCleanseSources(uint64_t a1, const void *a2)
{
  const __CFSet *v4;
  CFIndex Count;
  const __CFSet *v6;
  const __CFSet **v7;
  uint64_t v8;
  const void **Typed;
  const __CFSet *v10;
  const __CFSet *v11;
  CFIndex v12;
  const void **v13;
  const void *v14;
  pthread_mutex_t *v15;
  __CFBag *v16;
  _OWORD v17[128];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v4 = *(const __CFSet **)(a1 + 96);
  if (v4)
  {
    Count = CFSetGetCount(v4);
    v7 = (const __CFSet **)(a1 + 104);
    v6 = *(const __CFSet **)(a1 + 104);
    if (!v6)
      goto LABEL_7;
  }
  else
  {
    v7 = (const __CFSet **)(a1 + 104);
    v6 = *(const __CFSet **)(a1 + 104);
    if (!v6)
      return;
    Count = 0;
  }
  v6 = (const __CFSet *)CFSetGetCount(v6);
LABEL_7:
  v8 = (uint64_t)v6 + Count;
  if ((uint64_t)v6 + Count >= 257)
    Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v8, 0x80040B8603338, 0);
  else
    Typed = (const void **)v17;
  memset(v17, 0, 512);
  v10 = *(const __CFSet **)(a1 + 96);
  if (v10)
    CFSetGetValues(v10, Typed);
  v11 = *v7;
  if (v11)
  {
    v12 = *(_QWORD *)(a1 + 96);
    if (v12)
      v12 = CFSetGetCount((CFSetRef)v12);
    CFSetGetValues(v11, &Typed[v12]);
  }
  if (v8 >= 1)
  {
    v13 = Typed;
    do
    {
      v14 = *v13;
      v15 = (pthread_mutex_t *)((char *)*v13 + 16);
      pthread_mutex_lock(v15);
      v16 = (__CFBag *)*((_QWORD *)v14 + 12);
      if (v16)
        CFBagRemoveValue(v16, a2);
      pthread_mutex_unlock(v15);
      ++v13;
      --v8;
    }
    while (v8);
  }
  if (Typed != (const void **)v17)
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
}

void __CFFileDescriptorPerform(uint64_t a1)
{
  NSObject *v2;
  void (*v3)(uint64_t, uint64_t, uint64_t);
  void (*v4)(uint64_t);
  _QWORD block[10];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    v22 = 0;
    v23 = &v22;
    v24 = 0x2000000000;
    v25 = 0;
    v18 = 0;
    v19 = &v18;
    v20 = 0x2000000000;
    v21 = 0;
    v14 = 0;
    v15 = &v14;
    v16 = 0x2000000000;
    v17 = 0;
    v10 = 0;
    v11 = &v10;
    v12 = 0x2000000000;
    v13 = 0;
    v6 = 0;
    v7 = &v6;
    v8 = 0x2000000000;
    v9 = 0;
    v2 = __fdQueue();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ____CFFileDescriptorPerform_block_invoke;
    block[3] = &unk_1E12E1860;
    block[4] = &v14;
    block[5] = &v22;
    block[6] = &v18;
    block[7] = &v10;
    block[8] = &v6;
    block[9] = a1;
    dispatch_sync(v2, block);
    if (*((_BYTE *)v15 + 24) && (*((_BYTE *)v23 + 24) || *((_BYTE *)v19 + 24)))
    {
      v3 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
      if (v3)
        v3(a1, (*((_BYTE *)v23 + 24) != 0) | (2 * (*((_BYTE *)v19 + 24) != 0)), v11[3]);
      v4 = (void (*)(uint64_t))v7[3];
      if (v4)
        v4(v11[3]);
      if ((__CF_FORK_STATE & 2) == 0)
        __CF_USED();
      if ((__CF_FORK_STATE & 1) != 0)
        __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
    }
    _Block_object_dispose(&v6, 8);
    _Block_object_dispose(&v10, 8);
    _Block_object_dispose(&v14, 8);
    _Block_object_dispose(&v18, 8);
    _Block_object_dispose(&v22, 8);
  }
}

void sub_182AE1310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  uint64_t v28;

  _Block_object_dispose(&a20, 8);
  _Block_object_dispose(&a24, 8);
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose((const void *)(v28 - 136), 8);
  _Block_object_dispose((const void *)(v28 - 104), 8);
  _Unwind_Resume(a1);
}

unint64_t *_CFTryRetain(unint64_t *result)
{
  if (result)
  {
    if (((unint64_t)result & 0x8000000000000000) == 0)
      return _CFRetain(result, 1);
  }
  return result;
}

uint64_t __CFBinaryPlistWrite15(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  CFTypeRef *v3;
  CFTypeRef *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFData *v9;
  __CFData *v10;
  __CFString *v11;
  _BOOL4 v12;
  uint64_t result;
  _BYTE newBytes[9];
  _QWORD v15[3];
  CFTypeRef cf;
  uint64_t v17;
  int __len;
  _BYTE __len_4[8156];
  CFRange v20;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v11 = (__CFString *)v2;
  *(_QWORD *)&__len_4[8148] = *MEMORY[0x1E0C80C00];
  bzero(&__len, 0x1FD8uLL);
  v15[0] = v10;
  v15[1] = v8;
  cf = 0;
  v17 = 0;
  v15[2] = v6;
  __len = 0;
  bufferWrite_0((uint64_t)v15, "bplist15", 8);
  bufferWrite_0((uint64_t)v15, byte_182DCA8E0, 9);
  bufferWrite_0((uint64_t)v15, byte_182DCA8EA, 5);
  v12 = __writeObject15(v15, v11);
  writeBytes_0((uint64_t)v15, __len_4, __len);
  __len = 0;
  if ((unint64_t)v10 | v8)
  {
    newBytes[0] = 19;
    *(_QWORD *)&newBytes[1] = v17 ^ 0x8000000000000000;
    if (v8)
    {
      *(_QWORD *)(v8 + 8) = *(_QWORD *)newBytes;
      *(_BYTE *)(v8 + 16) = newBytes[8];
    }
    if (v10)
    {
      v20.location = 8;
      v20.length = 9;
      CFDataReplaceBytes(v10, v20, newBytes, 9);
    }
  }
  if (v12)
    return v17;
  if (v4 && cf)
  {
    result = 0;
    *v4 = cf;
  }
  else
  {
    if (cf)
      CFRelease(cf);
    return 0;
  }
  return result;
}

BOOL __writeObject15(_QWORD *a1, __CFString *a2)
{
  int64_t v4;
  int64_t v5;
  CFIndex Length;
  unint64_t v7;
  char v8;
  CFIndex *p_usedBufLen;
  uint64_t v10;
  uint64_t Count;
  const void **Typed;
  char v13;
  char *p_src;
  uint64_t v15;
  uint64_t v16;
  CFStringRef v17;
  CFStringRef v18;
  CFURLRef v19;
  char v20;
  CFIndex v21;
  CFIndex MaximumSizeForEncoding;
  CFIndex v23;
  UInt8 *v24;
  CFTypeID v25;
  CFIndex Bytes;
  char v27;
  int v28;
  char *v29;
  CFUUIDBytes *BytePtr;
  uint64_t v31;
  uint64_t v32;
  char v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  CFIndex *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char v46;
  CFIndex usedBufLen;
  unint64_t v48;
  CFUUIDBytes v49;
  char __src;
  char v51;
  char v52;
  char v53;
  char v54;
  _OWORD valuePtr[64];
  __int128 v56;
  _BYTE v57[2056];
  uint64_t v58;
  CFRange v59;
  CFRange v60;

  v58 = *MEMORY[0x1E0C80C00];
  v4 = CFGetTypeID(a2);
  v5 = v4;
  __src = 0;
  memset(v57, 0, 512);
  if (v4 > 19)
  {
    switch(v4)
    {
      case 20:
        Length = CFDataGetLength((CFDataRef)a2);
        v7 = Length;
        v8 = 15;
        if (Length < 15)
          v8 = Length;
        __src = v8 | 0x40;
        bufferWrite_0((uint64_t)a1, &__src, 1);
        if ((uint64_t)v7 < 15)
          goto LABEL_69;
        if (v7 <= 0x7F)
        {
          LOBYTE(valuePtr[0]) = v7 ^ 0x80;
          LOBYTE(v56) = 16;
          bufferWrite_0((uint64_t)a1, &v56, 1);
          p_usedBufLen = (CFIndex *)valuePtr;
LABEL_67:
          v35 = (uint64_t)a1;
          v36 = 1;
          goto LABEL_68;
        }
        if (!(v7 >> 15))
        {
          LOBYTE(valuePtr[0]) = 17;
          bufferWrite_0((uint64_t)a1, valuePtr, 1);
          LOBYTE(v56) = v7;
          LOBYTE(usedBufLen) = BYTE1(v7) ^ 0x80;
          bufferWrite_0((uint64_t)a1, &v56, 1);
          p_usedBufLen = &usedBufLen;
          goto LABEL_67;
        }
        if (!(v7 >> 31))
        {
          LOBYTE(valuePtr[0]) = 18;
          bufferWrite_0((uint64_t)a1, valuePtr, 1);
          LOBYTE(usedBufLen) = BYTE1(v7);
          LOBYTE(v56) = v7;
          v54 = BYTE2(v7);
          v53 = BYTE3(v7) ^ 0x80;
          bufferWrite_0((uint64_t)a1, &v56, 1);
          bufferWrite_0((uint64_t)a1, &usedBufLen, 1);
          bufferWrite_0((uint64_t)a1, &v54, 1);
          p_usedBufLen = (CFIndex *)&v53;
          goto LABEL_67;
        }
        LOBYTE(valuePtr[0]) = 19;
        *(_WORD *)((char *)valuePtr + 1) = v7;
        BYTE3(valuePtr[0]) = BYTE2(v7);
        BYTE4(valuePtr[0]) = BYTE3(v7);
        BYTE5(valuePtr[0]) = BYTE4(v7);
        BYTE6(valuePtr[0]) = BYTE5(v7);
        BYTE7(valuePtr[0]) = BYTE6(v7);
        BYTE8(valuePtr[0]) = HIBYTE(v7) ^ 0x80;
        p_usedBufLen = (CFIndex *)valuePtr;
        v35 = (uint64_t)a1;
        v36 = 9;
LABEL_68:
        bufferWrite_0(v35, p_usedBufLen, v36);
LABEL_69:
        BytePtr = (CFUUIDBytes *)CFDataGetBytePtr((CFDataRef)a2);
        v31 = (uint64_t)a1;
        v32 = v7;
        goto LABEL_70;
      case 21:
        if (CFBooleanGetValue((CFBooleanRef)a2))
          v13 = 9;
        else
          v13 = 8;
        __src = v13;
        v10 = 1;
        p_src = &__src;
        v15 = (uint64_t)a1;
        v16 = 1;
        goto LABEL_54;
      case 22:
        if (CFNumberIsFloatType((CFNumberRef)a2))
        {
          if (CFNumberGetByteSize((CFNumberRef)a2) > 4)
          {
            *(_QWORD *)&valuePtr[0] = 0;
            CFNumberGetValue((CFNumberRef)a2, kCFNumberFloat64Type, valuePtr);
            *(_QWORD *)&v56 = bswap64(*(unint64_t *)&valuePtr[0]);
            __src = 35;
            v10 = 1;
            bufferWrite_0((uint64_t)a1, &__src, 1);
            p_src = (char *)&v56;
            v15 = (uint64_t)a1;
            v16 = 8;
          }
          else
          {
            LODWORD(valuePtr[0]) = 0;
            CFNumberGetValue((CFNumberRef)a2, kCFNumberFloat32Type, valuePtr);
            LODWORD(v56) = bswap32(valuePtr[0]);
            __src = 34;
            v10 = 1;
            bufferWrite_0((uint64_t)a1, &__src, 1);
            p_src = (char *)&v56;
            v15 = (uint64_t)a1;
            v16 = 4;
          }
LABEL_54:
          bufferWrite_0(v15, p_src, v16);
          return v10;
        }
        if (_CFNumberGetType2((unint64_t *)a2) == 17)
        {
          v56 = 0uLL;
          CFNumberGetValue((CFNumberRef)a2, kCFNumberMaxType|kCFNumberSInt8Type, &v56);
          LOBYTE(valuePtr[0]) = 20;
          *(_QWORD *)((char *)valuePtr + 1) = *((_QWORD *)&v56 + 1);
          *(_QWORD *)((char *)valuePtr + 9) = v56 ^ 0x8000000000000000;
          BytePtr = (CFUUIDBytes *)valuePtr;
          v31 = (uint64_t)a1;
          v32 = 17;
          goto LABEL_70;
        }
        *(_QWORD *)&v56 = 0;
        CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt64Type, &v56);
        v34 = v56;
        if ((_QWORD)v56 == (char)v56)
        {
          LOBYTE(valuePtr[0]) = v56 ^ 0x80;
          LOBYTE(usedBufLen) = 16;
          bufferWrite_0((uint64_t)a1, &usedBufLen, 1);
          BytePtr = (CFUUIDBytes *)valuePtr;
LABEL_115:
          v31 = (uint64_t)a1;
          v32 = 1;
          goto LABEL_70;
        }
        if ((_QWORD)v56 == (int)v56)
        {
          LOBYTE(valuePtr[0]) = 18;
          bufferWrite_0((uint64_t)a1, valuePtr, 1);
          v54 = BYTE1(v34);
          LOBYTE(usedBufLen) = v34;
          v53 = BYTE2(v34);
          v52 = HIBYTE(v34) ^ 0x80;
          bufferWrite_0((uint64_t)a1, &usedBufLen, 1);
          bufferWrite_0((uint64_t)a1, &v54, 1);
          bufferWrite_0((uint64_t)a1, &v53, 1);
          BytePtr = (CFUUIDBytes *)&v52;
          goto LABEL_115;
        }
        LOBYTE(valuePtr[0]) = 19;
        *(_QWORD *)((char *)valuePtr + 1) = v56 ^ 0x8000000000000000;
        BytePtr = (CFUUIDBytes *)valuePtr;
        v31 = (uint64_t)a1;
        v32 = 9;
        break;
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
        goto LABEL_14;
      case 29:
        v17 = CFURLGetString((CFURLRef)a2);
        if (!v17)
          return 0;
        v18 = v17;
        v19 = CFURLGetBaseURL((CFURLRef)a2);
        if (v19)
          v20 = 13;
        else
          v20 = 12;
        __src = v20;
        bufferWrite_0((uint64_t)a1, &__src, 1);
        if (v19)
          __writeObject15(a1, v19);
        __writeObject15(a1, v18);
        return 1;
      default:
        if (v4 == 34)
        {
          __src = 14;
          bufferWrite_0((uint64_t)a1, &__src, 1);
          v25 = CFUUIDGetTypeID();
          if (CF_IS_OBJC(v25, (__objc2_class **)a2))
          {
            valuePtr[0] = 0uLL;
            -[__CFString getUUIDBytes:](a2, "getUUIDBytes:", valuePtr);
            v49 = (CFUUIDBytes)valuePtr[0];
          }
          else
          {
            v49 = CFUUIDGetUUIDBytes((CFUUIDRef)a2);
          }
          BytePtr = &v49;
          v31 = (uint64_t)a1;
          v32 = 16;
          goto LABEL_70;
        }
        if (v4 != 42)
          goto LABEL_14;
        __src = 51;
        bufferWrite_0((uint64_t)a1, &__src, 1);
        v48 = bswap64(COERCE_UNSIGNED_INT64(CFDateGetAbsoluteTime((CFDateRef)a2)));
        bufferWrite_0((uint64_t)a1, &v48, 8);
        return 1;
    }
    goto LABEL_70;
  }
  if (v4 != 7)
  {
    if (v4 == 16)
    {
      __src = 0;
      v10 = 1;
      bufferWrite_0((uint64_t)a1, &__src, 1);
      return v10;
    }
LABEL_14:
    switch(v4)
    {
      case 18:
        Count = CFDictionaryGetCount((CFDictionaryRef)a2);
        if ((unint64_t)(2 * Count) < 0x101)
          Typed = (const void **)v57;
        else
          Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 16 * Count, 0xC0040B8AA526DLL, 0);
        CFDictionaryGetKeysAndValues((CFDictionaryRef)a2, Typed, &Typed[Count]);
        v33 = -48;
        break;
      case 17:
        Count = CFSetGetCount((CFSetRef)a2);
        if ((unint64_t)Count < 0x101)
          Typed = (const void **)v57;
        else
          Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
        CFSetGetValues((CFSetRef)a2, Typed);
        v33 = -64;
        break;
      case 19:
        Count = CFArrayGetCount((CFArrayRef)a2);
        if ((unint64_t)Count < 0x101)
          Typed = (const void **)v57;
        else
          Typed = (const void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
        v60.location = 0;
        v60.length = Count;
        CFArrayGetValues((CFArrayRef)a2, v60, Typed);
        v33 = -96;
        break;
      default:
        return 0;
    }
    v37 = 15;
    if (Count < 15)
      v37 = Count;
    __src = v33 | v37;
    bufferWrite_0((uint64_t)a1, &__src, 1);
    if (Count < 15)
    {
      if (Count < 1)
      {
LABEL_97:
        if (Typed != (const void **)v57)
          CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
        return 1;
      }
      goto LABEL_92;
    }
    if ((unint64_t)Count > 0x7F)
    {
      if ((unint64_t)Count >> 15)
      {
        if ((unint64_t)Count >> 31)
        {
          LOBYTE(valuePtr[0]) = 19;
          *(_WORD *)((char *)valuePtr + 1) = Count;
          BYTE3(valuePtr[0]) = BYTE2(Count);
          BYTE4(valuePtr[0]) = BYTE3(Count);
          BYTE5(valuePtr[0]) = BYTE4(Count);
          BYTE6(valuePtr[0]) = BYTE5(Count);
          BYTE7(valuePtr[0]) = BYTE6(Count);
          BYTE8(valuePtr[0]) = HIBYTE(Count) ^ 0x80;
          v38 = (CFIndex *)valuePtr;
          v39 = (uint64_t)a1;
          v40 = 9;
          goto LABEL_91;
        }
        LOBYTE(valuePtr[0]) = 18;
        bufferWrite_0((uint64_t)a1, valuePtr, 1);
        LOBYTE(usedBufLen) = BYTE1(Count);
        LOBYTE(v56) = Count;
        v54 = BYTE2(Count);
        v53 = BYTE3(Count) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &v56, 1);
        bufferWrite_0((uint64_t)a1, &usedBufLen, 1);
        bufferWrite_0((uint64_t)a1, &v54, 1);
        v38 = (CFIndex *)&v53;
      }
      else
      {
        LOBYTE(valuePtr[0]) = 17;
        bufferWrite_0((uint64_t)a1, valuePtr, 1);
        LOBYTE(v56) = Count;
        LOBYTE(usedBufLen) = BYTE1(Count) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &v56, 1);
        v38 = &usedBufLen;
      }
    }
    else
    {
      LOBYTE(valuePtr[0]) = Count ^ 0x80;
      LOBYTE(v56) = 16;
      bufferWrite_0((uint64_t)a1, &v56, 1);
      v38 = (CFIndex *)valuePtr;
    }
    v39 = (uint64_t)a1;
    v40 = 1;
LABEL_91:
    bufferWrite_0(v39, v38, v40);
LABEL_92:
    v41 = 0;
    if (Count << (v5 == 18) <= 1)
      v42 = 1;
    else
      v42 = Count << (v5 == 18);
    while (__writeObject15(a1, Typed[v41]))
    {
      if (v42 == ++v41)
        goto LABEL_97;
    }
    if (Typed != (const void **)v57)
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    return 0;
  }
  v21 = CFStringGetLength(a2);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(v21, 0x8000100u);
  v23 = MaximumSizeForEncoding;
  if (!*a1 && !a1[1])
  {
    v32 = MaximumSizeForEncoding + 10;
    v31 = (uint64_t)a1;
    BytePtr = 0;
LABEL_70:
    bufferWrite_0(v31, BytePtr, v32);
    return 1;
  }
  if (MaximumSizeForEncoding <= 1024)
  {
    usedBufLen = 0;
    v24 = (UInt8 *)valuePtr;
LABEL_42:
    v59.location = 0;
    v59.length = v21;
    Bytes = CFStringGetBytes(a2, v59, 0x8000100u, 0, 0, v24, v23, &usedBufLen);
    goto LABEL_43;
  }
  v24 = (UInt8 *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, MaximumSizeForEncoding, 3027758341, 0);
  usedBufLen = 0;
  if (v24)
    goto LABEL_42;
  Bytes = 0;
LABEL_43:
  if (Bytes == v21)
  {
    v27 = usedBufLen;
    if (usedBufLen >= 15)
      v27 = 15;
    v46 = v27 | 0x70;
    bufferWrite_0((uint64_t)a1, &v46, 1);
    v28 = usedBufLen;
    if (usedBufLen < 15)
      goto LABEL_108;
    if ((unint64_t)usedBufLen > 0x7F)
    {
      if ((unint64_t)usedBufLen >> 15)
      {
        if ((unint64_t)usedBufLen >> 31)
        {
          LOBYTE(v56) = 19;
          *(_QWORD *)((char *)&v56 + 1) = usedBufLen ^ 0x8000000000000000;
          v29 = (char *)&v56;
          v43 = (uint64_t)a1;
          v44 = 9;
          goto LABEL_107;
        }
        LOBYTE(v56) = 18;
        bufferWrite_0((uint64_t)a1, &v56, 1);
        v53 = BYTE1(v28);
        v54 = v28;
        v52 = BYTE2(v28);
        v51 = HIBYTE(v28) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &v54, 1);
        bufferWrite_0((uint64_t)a1, &v53, 1);
        bufferWrite_0((uint64_t)a1, &v52, 1);
        v29 = &v51;
      }
      else
      {
        LOBYTE(v56) = 17;
        bufferWrite_0((uint64_t)a1, &v56, 1);
        v54 = v28;
        v53 = BYTE1(v28) ^ 0x80;
        bufferWrite_0((uint64_t)a1, &v54, 1);
        v29 = &v53;
      }
    }
    else
    {
      LOBYTE(v56) = usedBufLen ^ 0x80;
      v54 = 16;
      bufferWrite_0((uint64_t)a1, &v54, 1);
      v29 = (char *)&v56;
    }
    v43 = (uint64_t)a1;
    v44 = 1;
LABEL_107:
    bufferWrite_0(v43, v29, v44);
LABEL_108:
    bufferWrite_0((uint64_t)a1, v24, usedBufLen);
  }
  if (v24 != (UInt8 *)valuePtr)
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v24);
  return Bytes == v21;
}

void writeBytes(uint64_t a1, const UInt8 *__src, int64_t __len, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFIndex v12;
  const UInt8 *v13;
  uint64_t v14;
  uint64_t v15;
  CFErrorRef Error;
  CFIndex v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  if (__len >= 1)
  {
    v19 = v7;
    v20 = v6;
    v21 = v5;
    v22 = v4;
    if (!*(_QWORD *)(a1 + 24))
    {
      v12 = __len;
      v13 = __src;
      v14 = *(_QWORD *)(a1 + 8);
      if (v14)
      {
        v15 = *(_QWORD *)(a1 + 32);
        if (__CFADD__(__len, v15) || *(_QWORD *)(a1 + 16) < (unint64_t)(v15 + __len))
        {
          Error = __CFPropertyListCreateError(3851, CFSTR("Binary property list writing could not be completed because databytes is full."), v19, v20, v21, v22, v8, v9);
LABEL_7:
          *(_QWORD *)(a1 + 24) = Error;
          return;
        }
        if (!a4)
          memmove((void *)(v14 + v15), __src, __len);
      }
      if (!*(_BYTE *)(a1 + 44))
      {
        while (1)
        {
          v17 = v12;
          if (!a4)
          {
            v17 = v12;
            if (*(_QWORD *)a1)
            {
              v17 = CFWriteStreamWrite(*(CFWriteStreamRef *)a1, v13, v12);
              if (!v17)
              {
                Error = __CFPropertyListCreateError(3851, CFSTR("Binary property list writing could not be completed because stream is full."), v19, v20, v21, v22, v8, v9);
                goto LABEL_7;
              }
              if (v17 < 0)
                break;
            }
          }
          *(_QWORD *)(a1 + 32) += v17;
          v13 += v17;
          v18 = v12 <= v17;
          v12 -= v17;
          if (v18)
            return;
        }
        if (!*(_QWORD *)a1 || (Error = CFWriteStreamCopyError(*(CFWriteStreamRef *)a1)) == 0)
          Error = __CFPropertyListCreateError(3851, CFSTR("Binary property list writing could not be completed because the stream had an unknown error."), v19, v20, v21, v22, v8, v9);
        goto LABEL_7;
      }
      if (!a4)
      {
        if (*(_QWORD *)a1)
          CFDataAppendBytes(*(CFMutableDataRef *)a1, v13, v12);
      }
      *(_QWORD *)(a1 + 32) += v12;
    }
  }
}

const void *__CFPropertyListIsDictPlistAux(const void *cf, uint64_t a2, uint64_t a3)
{
  const void *v5;
  _QWORD *v6;
  CFTypeID v7;
  CFStringRef v8;
  _QWORD *v9;
  _QWORD *v10;

  if (*(_BYTE *)a3)
  {
    v5 = cf;
    if (!cf)
    {
      v9 = *(_QWORD **)(a3 + 24);
      if (v9)
      {
        if (!*v9)
          **(_QWORD **)(a3 + 24) = CFRetain(CFSTR("property list dictionaries cannot contain NULL keys"));
      }
    }
    if (!a2)
    {
      v10 = *(_QWORD **)(a3 + 24);
      if (v10)
      {
        if (!*v10)
          **(_QWORD **)(a3 + 24) = CFRetain(CFSTR("property list dictionaries cannot contain NULL values"));
      }
    }
    if (CFGetTypeID(v5) != 7)
    {
      v6 = *(_QWORD **)(a3 + 24);
      if (v6)
      {
        if (!*v6)
        {
          v7 = CFGetTypeID(v5);
          v8 = CFCopyTypeIDDescription(v7);
          **(_QWORD **)(a3 + 24) = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("property list dictionaries may only have keys which are CFStrings, not '%@'"), v8);
          CFRelease(v8);
        }
      }
    }
    cf = 0;
    if (v5 && a2)
    {
      if (CFGetTypeID(v5) == 7)
        cf = (const void *)__CFPropertyListIsValidAux(a2, a3);
      else
        cf = 0;
    }
    *(_BYTE *)a3 = (_BYTE)cf;
  }
  return cf;
}

BOOL __CFPropertyListIsValidAux(const void *a1, _BYTE *a2)
{
  CFTypeID v4;
  _BOOL8 v5;
  CFTypeID v6;
  uint64_t v7;
  const __CFString *v8;
  uint64_t v9;
  const __CFBag *v10;
  int v12;
  CFIndex v13;
  CFIndex v14;
  CFIndex Count;
  CFStringRef v16;
  CFBagCallBacks callBacks;
  uint64_t v18;
  CFRange v19;

  v18 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    if (*((_QWORD *)a2 + 3))
    {
      v8 = CFSTR("property lists cannot contain NULL");
      goto LABEL_11;
    }
    return 0;
  }
  v4 = CFGetTypeID(a1);
  v5 = 1;
  if (v4 != 7)
  {
    v6 = v4;
    if (v4 != 20
      && (*((_QWORD *)a2 + 1) == 1
       || (v4 > 0x2A || ((1 << v4) & 0x40000600000) == 0) && _CFKeyedArchiverUIDGetTypeID() != v4))
    {
      v7 = *((_QWORD *)a2 + 2);
      if (v7)
      {
        if (CFSetContainsValue(*((CFSetRef *)a2 + 2), a1))
        {
          if (*((_QWORD *)a2 + 3))
          {
            v8 = CFSTR("property lists cannot contain recursive container references");
LABEL_11:
            v5 = 0;
            **((_QWORD **)a2 + 3) = CFRetain(v8);
            return v5;
          }
          return 0;
        }
      }
      else
      {
        *((_QWORD *)a2 + 2) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0);
      }
      v9 = *((_QWORD *)a2 + 1);
      if (v9 != 200)
      {
        v10 = (const __CFBag *)*((_QWORD *)a2 + 4);
        if (!v10)
        {
          *(_OWORD *)&callBacks.version = *(_OWORD *)&kCFTypeBagCallBacks.version;
          *(_OWORD *)&callBacks.release = *(_OWORD *)&kCFTypeBagCallBacks.release;
          callBacks.equal = 0;
          callBacks.hash = 0;
          *((_QWORD *)a2 + 4) = CFBagCreateMutable(0, 0, &callBacks);
          v12 = 1;
LABEL_26:
          if (v6 == 18)
          {
            Count = CFDictionaryGetCount((CFDictionaryRef)a1);
            if (v9 != 200 && Count >= 1)
              CFBagAddValue(*((CFMutableBagRef *)a2 + 4), a1);
            CFSetAddValue(*((CFMutableSetRef *)a2 + 2), a1);
            CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)__CFPropertyListIsDictPlistAux, a2);
          }
          else
          {
            if (v6 != 19)
            {
              if (*((_QWORD *)a2 + 3))
              {
                v16 = CFCopyTypeIDDescription(v6);
                **((_QWORD **)a2 + 3) = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("property lists cannot contain objects of type '%@'"), v16);
                CFRelease(v16);
              }
              v5 = 0;
              if (v7)
                goto LABEL_38;
LABEL_37:
              CFRelease(*((CFTypeRef *)a2 + 2));
              *((_QWORD *)a2 + 2) = 0;
LABEL_38:
              if (v12)
              {
                CFRelease(*((CFTypeRef *)a2 + 4));
                *((_QWORD *)a2 + 4) = 0;
              }
              return v5;
            }
            v13 = CFArrayGetCount((CFArrayRef)a1);
            v14 = v13;
            if (v9 != 200 && v13 >= 1)
              CFBagAddValue(*((CFMutableBagRef *)a2 + 4), a1);
            CFSetAddValue(*((CFMutableSetRef *)a2 + 2), a1);
            v19.location = 0;
            v19.length = v14;
            CFArrayApplyFunction((CFArrayRef)a1, v19, (CFArrayApplierFunction)__CFPropertyListIsArrayPlistAux, a2);
          }
          CFSetRemoveValue(*((CFMutableSetRef *)a2 + 2), a1);
          v5 = *a2 != 0;
          if (v7)
            goto LABEL_38;
          goto LABEL_37;
        }
        if ((unint64_t)CFBagGetCountOfValue(v10, a1) >= 0x181)
        {
          if (*((_QWORD *)a2 + 3))
          {
            v8 = CFSTR("Too many nested arrays or dictionaries please use kCFPropertyListBinaryFormat_v1_0 instead which supports references");
            goto LABEL_11;
          }
          return 0;
        }
      }
      v12 = 0;
      goto LABEL_26;
    }
  }
  return v5;
}

CFTypeID CFNumberGetTypeID(void)
{
  if (CFNumberGetTypeID_initOnce != -1)
    dispatch_once(&CFNumberGetTypeID_initOnce, &__block_literal_global_8);
  return 22;
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
    return -[__CFDictionary containsKey:](theDict, "containsKey:", key);
  else
    return CFBasicHashGetCountOfKey((uint64_t)theDict, (unint64_t)key) > 0;
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
    return -[__CFSet containsObject:](theSet, "containsObject:", value);
  else
    return CFBasicHashGetCountOfKey((uint64_t)theSet, (unint64_t)value) > 0;
}

uint64_t CFBasicHashGetCountOfKey(uint64_t result, unint64_t a2)
{
  BOOL v2;
  int v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v2 = a2 == 2780474809 || a2 == 2814029233;
  if (v2 || !*(_DWORD *)(result + 20))
    return 0;
  if (!*(_BYTE *)(result + 26))
  {
    v4 = xmmword_182DC7A10;
    v5 = unk_182DC7A20;
    return *((_QWORD *)&v5 + 1);
  }
  v3 = *(_WORD *)(result + 18) & 3;
  if ((*(_WORD *)(result + 18) & 0x8000) != 0)
  {
    switch(v3)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v4);
        return *((_QWORD *)&v5 + 1);
      case 2:
        ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v4);
        return *((_QWORD *)&v5 + 1);
      case 1:
        ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v4);
        return *((_QWORD *)&v5 + 1);
    }
LABEL_25:
    __break(1u);
    return result;
  }
  if (v3 == 3)
  {
    ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v4);
    return *((_QWORD *)&v5 + 1);
  }
  if (v3 == 2)
  {
    ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v4);
    return *((_QWORD *)&v5 + 1);
  }
  if (v3 != 1)
    goto LABEL_25;
  ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v4);
  return *((_QWORD *)&v5 + 1);
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
  _QWORD v6[7];

  v6[6] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
  {
    -[__CFDictionary __apply:context:](theDict, "__apply:context:", applier, context);
  }
  else
  {
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = __CFDictionaryApplyFunction_block_invoke;
    v6[3] = &__block_descriptor_48_e15_C40__0___qQQQ_8l;
    v6[4] = applier;
    v6[5] = context;
    CFBasicHashApply((uint64_t)theDict, (uint64_t)v6);
  }
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
  char v4;

  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
  {
    -[__CFSet removeObject:](theSet, "removeObject:", value);
  }
  else
  {
    v4 = atomic_load((unint64_t *)theSet + 1);
    if ((v4 & 0x40) != 0)
      CFLog(3, CFSTR("%s(): immutable collection %p given to mutating function"));
    CFBasicHashRemoveValue((uint64_t)theSet, (unint64_t)value);
  }
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFIndex length;
  CFIndex location;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if (range.length >= 1)
  {
    v17 = v9;
    v18 = v8;
    v19 = v7;
    v20 = v6;
    v21 = v5;
    v22 = v4;
    v23 = v10;
    v24 = v11;
    length = range.length;
    location = range.location;
    do
    {
      ((void (*)(uint64_t, void *))applier)(-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location++, v17, v18, v19, v20, v21, v22, v23, v24), context);
      --length;
    }
    while (length);
  }
}

uint64_t __CFPropertyListIsArrayPlistAux(uint64_t result, uint64_t a2)
{
  _QWORD *v3;
  CFTypeRef v4;

  if (*(_BYTE *)a2)
  {
    if (result)
    {
      result = __CFPropertyListIsValidAux(result, a2);
    }
    else
    {
      v3 = *(_QWORD **)(a2 + 24);
      if (v3 && !*v3)
      {
        v4 = CFRetain(CFSTR("property list arrays cannot contain NULL"));
        result = 0;
        **(_QWORD **)(a2 + 24) = v4;
      }
      else
      {
        result = 0;
      }
    }
    *(_BYTE *)a2 = result;
  }
  return result;
}

void __CFXPCDictionaryApplier(const __CFString *a1, uint64_t a2, xpc_object_t *a3)
{
  CFIndex Length;
  size_t MaximumSizeForEncoding;
  CFIndex v8;
  char *v9;
  char *v10;
  void *v11;
  void *v12;

  if (CFGetTypeID(a1) == 7)
  {
    Length = CFStringGetLength(a1);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length + 1, 0x8000100u);
    if (MaximumSizeForEncoding != -1)
    {
      v8 = MaximumSizeForEncoding;
      v9 = (char *)malloc_type_malloc(MaximumSizeForEncoding, 0xCB2E0E6uLL);
      if (v9)
      {
        v10 = v9;
        if (CFStringGetCString(a1, v9, v8, 0x8000100u))
        {
          v11 = (void *)_CFXPCCreateXPCObjectFromCFObject(a2);
          if (v11)
          {
            v12 = v11;
            xpc_dictionary_set_value(*a3, v10, v11);
            xpc_release(v12);
          }
        }
        free(v10);
      }
    }
  }
}

xpc_object_t _CFXPCCreateXPCObjectFromCFObject(__CFString *a1)
{
  CFTypeID v2;
  CFIndex Length;
  size_t MaximumSizeForEncoding;
  CFIndex v6;
  char *v7;
  char *v8;
  void *v9;
  NSObject *DispatchData;
  xpc_object_t v11;
  double v13;
  CFIndex Count;
  CFIndex i;
  const void *ValueAtIndex;
  void *v17;
  void *v18;
  size_t v19;
  void *v20;
  CFURLRef v21;
  uint64_t v22;
  void *v23;
  xpc_object_t v24;
  void *v25;
  xpc_object_t v26;
  void *v27;
  xpc_object_t values[3];
  CFUUIDBytes valuePtr;
  const char *v30;
  uuid_t uu;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  if (CFNullGetTypeID() == v2)
    return xpc_null_create();
  if (CFBooleanGetTypeID() == v2)
    return xpc_BOOL_create(&__kCFBooleanTrue == (__objc2_class **)a1);
  if (v2 == 7)
  {
    Length = CFStringGetLength(a1);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length + 1, 0x8000100u);
    if (MaximumSizeForEncoding != -1)
    {
      v6 = MaximumSizeForEncoding;
      v7 = (char *)malloc_type_malloc(MaximumSizeForEncoding, 0x9B28DDC6uLL);
      if (v7)
      {
        v8 = v7;
        if (CFStringGetCString(a1, v7, v6, 0x8000100u))
          v9 = xpc_string_create(v8);
        else
          v9 = 0;
        free(v8);
        return v9;
      }
    }
    return 0;
  }
  if (CFDataGetTypeID() == v2)
  {
    DispatchData = _CFDataCreateDispatchData(a1);
    v11 = xpc_data_create_with_dispatch_data(DispatchData);
    dispatch_release(DispatchData);
    return v11;
  }
  if (v2 != 42)
  {
    if (v2 == 22)
    {
      if (CFNumberIsFloatType((CFNumberRef)a1))
      {
        *(_QWORD *)&valuePtr.byte0 = 0;
        if (CFNumberGetValue((CFNumberRef)a1, kCFNumberDoubleType, &valuePtr))
          return xpc_double_create(*(double *)&valuePtr.byte0);
      }
      else
      {
        *(_QWORD *)&valuePtr.byte0 = 0;
        if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, &valuePtr))
          return xpc_int64_create(*(int64_t *)&valuePtr.byte0);
      }
      return 0;
    }
    if (CFUUIDGetTypeID() == v2)
    {
      valuePtr = CFUUIDGetUUIDBytes((CFUUIDRef)a1);
      return xpc_uuid_create(&valuePtr.byte0);
    }
    if (v2 == 18)
    {
      *(_QWORD *)&valuePtr.byte0 = xpc_dictionary_create(0, 0, 0);
      if (!*(_QWORD *)&valuePtr.byte0)
        return 0;
      Count = CFDictionaryGetCount((CFDictionaryRef)a1);
      CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)__CFXPCDictionaryApplier, &valuePtr);
      v19 = xpc_dictionary_get_count(*(xpc_object_t *)&valuePtr.byte0);
      v9 = *(void **)&valuePtr.byte0;
    }
    else
    {
      if (v2 != 19)
      {
        if (CFURLGetTypeID() != v2)
          return 0;
        v9 = (void *)CFURLGetString((CFURLRef)a1);
        if (!v9)
          return v9;
        v21 = CFURLGetBaseURL((CFURLRef)a1);
        if (!v21)
          v21 = (CFURLRef)&__kCFNull;
        v22 = _CFXPCCreateXPCObjectFromCFObject(v21);
        if (!v22)
          return 0;
        v23 = (void *)v22;
        v9 = (void *)_CFXPCCreateXPCObjectFromCFObject(v9);
        if (!v9)
        {
          xpc_release(v23);
          return v9;
        }
        memset(uu, 0, sizeof(uu));
        if (uuid_parse("C3853DCC-9776-4114-B6C1-FD9F51944A6D", uu) || (v24 = xpc_uuid_create(uu)) == 0)
        {
          xpc_release(v9);
          v20 = v23;
          goto LABEL_42;
        }
        v25 = v24;
        *(_QWORD *)&valuePtr.byte0 = "com.apple.CFURL.magic";
        *(_QWORD *)&valuePtr.byte8 = "com.apple.CFURL.string";
        v30 = "com.apple.CFURL.base";
        values[0] = v24;
        values[1] = v9;
        values[2] = v23;
        v26 = xpc_dictionary_create((const char *const *)&valuePtr, values, 3uLL);
        v27 = v9;
        v9 = v26;
        xpc_release(v27);
        xpc_release(v23);
        xpc_release(v25);
        if (!v9 || xpc_dictionary_get_count(v9) == 3)
          return v9;
LABEL_41:
        v20 = v9;
LABEL_42:
        xpc_release(v20);
        return 0;
      }
      v9 = xpc_array_create(0, 0);
      if (!v9)
        return v9;
      Count = CFArrayGetCount((CFArrayRef)a1);
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, i);
          v17 = (void *)_CFXPCCreateXPCObjectFromCFObject(ValueAtIndex);
          if (v17)
          {
            v18 = v17;
            xpc_array_append_value(v9, v17);
            xpc_release(v18);
          }
        }
      }
      v19 = xpc_array_get_count(v9);
    }
    if (v19 == Count)
      return v9;
    goto LABEL_41;
  }
  v13 = CFDateGetAbsoluteTime((CFDateRef)a1) + 978307200.0;
  if (v13 < -9223372040.0 || v13 > 9223372040.0)
    return _CFXPCCreateXPCObjectFromOutOfRangeCFTimeInterval(v13);
  else
    return xpc_date_create((uint64_t)(v13 * 1000000000.0));
}

CFTypeID CFBooleanGetTypeID(void)
{
  return 21;
}

CFTypeID CFDataGetTypeID(void)
{
  return 20;
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return ((unsigned __int16)__CFNumberTypeTable[CFNumberGetType(number)] >> 5) & 1;
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  CFNumberType result;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;

  if (((unint64_t)number & 0x8000000000000000) != 0)
  {
    v2 = 0;
    v3 = *MEMORY[0x1E0DE7C58];
    if ((~(unint64_t)number & 0xC000000000000007) == 0)
      v3 = 0;
    v4 = v3 ^ (unint64_t)number;
    v5 = (v3 ^ (unint64_t)number) & 7;
    v6 = MEMORY[0x1E0DE7C48];
    while (v5 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v2))
    {
      if (++v2 == 7)
        goto LABEL_15;
    }
    if (v2 == 3)
    {
      v7 = 0;
      while (v5 != *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v7))
      {
        if (++v7 == 7)
          goto LABEL_34;
      }
      if (v7 != 3)
      {
LABEL_34:
        LOBYTE(v13) = atomic_load((unint64_t *)number + 1);
        return __CFNumberCanonicalTypes[v13 & 7];
      }
      v12 = 0xFFFFFFFFFFFFFFFLL;
      if (v5 == 7)
        v12 = 0xFFFFFFFFFFFFFLL;
      v13 = v12 & (v4 >> 3);
      return __CFNumberCanonicalTypes[v13 & 7];
    }
LABEL_15:
    if (CF_IS_OBJC(0x16uLL, (__objc2_class **)number))
      goto LABEL_16;
    v9 = 0;
    while (v5 != *(unsigned __int8 *)(v6 + v9))
    {
      if (++v9 == 7)
        goto LABEL_25;
    }
    if (v9 == 3)
    {
      v10 = 0xFFFFFFFFFFFFFFFLL;
      if (v5 == 7)
        v10 = 0xFFFFFFFFFFFFFLL;
      v11 = v10 & (v4 >> 3);
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  if (!CF_IS_OBJC(0x16uLL, (__objc2_class **)number))
  {
LABEL_25:
    LOBYTE(v11) = atomic_load((unint64_t *)number + 1);
LABEL_26:
    result = __CFNumberCanonicalTypes[v11 & 7];
    goto LABEL_27;
  }
LABEL_16:
  result = -[__CFNumber _cfNumberType](number, "_cfNumberType");
LABEL_27:
  if (result == (kCFNumberMaxType|kCFNumberSInt8Type))
    return 4;
  return result;
}

CFTypeID CFNullGetTypeID(void)
{
  return 16;
}

uint64_t _CFKeyedArchiverUIDGetTypeID()
{
  return 41;
}

const __CFString *_CFPrefsCreateCacheKeyForQuintuplet(__CFString *a1, const __CFString *a2, int a3, const __CFString *a4, char a5)
{
  const __CFString *CacheStringForBundleID;
  const void *v10;
  const __CFString *v11;
  CFStringRef Copy;
  const __CFString *v13;
  const char *v14;
  const __CFString *v15;
  const __CFString *v16;
  CFStringRef v17;
  int v18;
  BOOL v19;
  const __CFString *v20;
  const __CFString *v21;
  const char *v22;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  CFIndex v25;
  CFIndex v26;
  CFIndex v27;
  CFIndex v28;
  CFIndex v29;
  uint64_t v30;
  size_t v31;
  uint64_t v32;
  uint64_t v33;
  UInt8 *v34;
  size_t v35;
  UInt8 *v36;
  size_t v37;
  CFIndex v38;
  UInt8 *v39;
  char *v40;
  size_t v41;
  CFStringRef v42;
  const __CFString *v43;
  const __CFString *v44;
  const char *v46[2];
  CFIndex v47[2];
  CFRange v48;
  CFRange v49;
  CFRange v50;

  v47[1] = *MEMORY[0x1E0C80C00];
  CacheStringForBundleID = (const __CFString *)_CFPrefsGetCacheStringForBundleID(a1);
  v10 = (const void *)_CFPrefsGetCacheStringForBundleID(CFSTR("kCFPreferencesCurrentApplication"));
  if (CFEqual(CacheStringForBundleID, v10))
  {
    v11 = CFSTR("C");
  }
  else if (CFEqual(CacheStringForBundleID, CFSTR("kCFPreferencesAnyApplication")))
  {
    v11 = CFSTR("A");
  }
  else
  {
    v11 = CacheStringForBundleID;
  }
  if (CFEqual(a2, CFSTR("kCFPreferencesCurrentUser")))
  {
LABEL_7:
    Copy = CFSTR("C");
    v13 = CFSTR("kCFPreferencesCurrentUser");
    if (!CFSTR("kCFPreferencesCurrentUser"))
      goto LABEL_9;
    goto LABEL_8;
  }
  v13 = CFSTR("kCFPreferencesAnyUser");
  Copy = CFSTR("kCFPreferencesAnyUser");
  if (!CFEqual(a2, CFSTR("kCFPreferencesAnyUser")))
  {
    v17 = CFCopyUserName();
    v18 = CFEqual(a2, v17);
    CFRelease(v17);
    if (CFSTR("kCFPreferencesCurrentUser"))
      v19 = v18 == 0;
    else
      v19 = 1;
    if (!v19)
    {
      Copy = CFSTR("C");
      v13 = CFSTR("kCFPreferencesCurrentUser");
LABEL_8:
      CFRelease(v13);
      goto LABEL_9;
    }
    Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2);
  }
  if (Copy == CFSTR("kCFPreferencesCurrentUser"))
    goto LABEL_7;
  if (Copy == CFSTR("kCFPreferencesAnyUser"))
  {
    Copy = CFSTR("A");
    if (CFSTR("kCFPreferencesAnyUser"))
      goto LABEL_8;
  }
  else if (!Copy)
  {
    return 0;
  }
LABEL_9:
  if ((a5 & 1) == 0)
  {
    if (!a4 || CFEqual(a4, CFSTR("kCFPreferencesNoContainer")))
    {
      if (CFEqual(v11, CFSTR("C")))
      {
        if (Copy != CFSTR("kCFPreferencesCurrentUser"))
        {
          v15 = CFSTR("C/A//*/L");
          v16 = CFSTR("C/A//B/L");
          goto LABEL_30;
        }
        v43 = CFSTR("C/C//*/L");
        v44 = CFSTR("C/C//B/L");
        goto LABEL_52;
      }
      if (CFEqual(v11, CFSTR("kCFPreferencesAnyApplication")))
      {
        if (Copy != CFSTR("kCFPreferencesCurrentUser"))
        {
          v15 = CFSTR("A/A//*/L");
          v16 = CFSTR("A/A//B/L");
LABEL_30:
          if (a3)
            v20 = v16;
          else
            v20 = v15;
          if (Copy != CFSTR("kCFPreferencesAnyUser"))
            goto LABEL_34;
LABEL_55:
          CFRelease(Copy);
          return v20;
        }
        v43 = CFSTR("A/C//*/L");
        v44 = CFSTR("A/C//B/L");
LABEL_52:
        if (a3)
          v20 = v44;
        else
          v20 = v43;
        goto LABEL_55;
      }
    }
LABEL_34:
    v14 = "L";
    goto LABEL_35;
  }
  v14 = "C";
LABEL_35:
  v46[0] = v14;
  if (a4)
    v21 = a4;
  else
    v21 = &stru_1E1337B18;
  if (a3)
    v22 = "B";
  else
    v22 = "*";
  Length = CFStringGetLength(v11);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  v25 = CFStringGetLength(Copy);
  v26 = CFStringGetMaximumSizeForEncoding(v25, 0x8000100u);
  v27 = CFStringGetLength(v21);
  v28 = CFStringGetMaximumSizeForEncoding(v27, 0x8000100u);
  v46[1] = (const char *)v46;
  v29 = MaximumSizeForEncoding + v26 + v28;
  v30 = v29 + 2;
  v31 = v29 + 7;
  MEMORY[0x1E0C80A78](v28, v32);
  v34 = (UInt8 *)v46 - v33;
  if (v30 < 1019)
    bzero((char *)v46 - v33, v31);
  else
    v34 = (UInt8 *)malloc_type_calloc(v31, 1uLL, 0x100004077774924uLL);
  v47[0] = 0;
  v48.length = CFStringGetLength(v11);
  v48.location = 0;
  CFStringGetBytes(v11, v48, 0x8000100u, 0, 0, v34, v31, v47);
  v35 = v31 + ~v47[0];
  v36 = (UInt8 *)(strncat((char *)&v34[v47[0]], "/", v35) + 1);
  v49.length = CFStringGetLength(Copy);
  v49.location = 0;
  CFStringGetBytes(Copy, v49, 0x8000100u, 0, 0, v36, v35, v47);
  v37 = v35 - v47[0];
  v38 = v35 - v47[0] - 1;
  v39 = (UInt8 *)(strncat((char *)&v36[v47[0]], "/", v38) + 1);
  v50.length = CFStringGetLength(v21);
  v50.location = 0;
  CFStringGetBytes(v21, v50, 0x8000100u, 0, 0, v39, v38, v47);
  v40 = (char *)&v39[v47[0]];
  strncat((char *)&v39[v47[0]], "/", v37 - 2);
  strncat(v40 + 1, v22, v37 - 3);
  strncat(v40 + 2, "/", v37 - 4);
  strncat(v40 + 3, v46[0], v37 - 5);
  v41 = strlen((const char *)v34);
  if (v30 < 1019)
    v42 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, v41, 0x8000100u, 0);
  else
    v42 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, v41, 0x8000100u, 0, (CFAllocatorRef)&__kCFAllocatorMalloc);
  v20 = v42;
  CFRelease(Copy);
  return v20;
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  CFIndex v2;
  int v3;
  unint64_t v4;
  CFIndex v6;
  unint64_t v7;
  CFIndex v8;
  CFIndex v9;
  CFStringEncoding v11;
  uint64_t Converter;
  unint64_t v13;
  int64_t v14;
  CFIndex v15;

  v2 = length;
  HIDWORD(v4) = encoding - 134217984;
  LODWORD(v4) = encoding - 134217984;
  v3 = v4 >> 26;
  if ((v3 - 4) < 2 || v3 == 1)
  {
    v6 = 4 * length;
    v7 = (unint64_t)length >> 61;
    goto LABEL_7;
  }
  if (!v3)
  {
    v8 = 3 * length;
    v9 = 0x2AAAAAAAAAAAAAAALL;
    goto LABEL_12;
  }
  v11 = encoding & 0xFFF;
  if (v11 > 0x4FF)
  {
    if ((encoding & 0xFFF) > 0xB00)
    {
      if (v11 == 2817)
        return v2;
      if (v11 == 3071)
      {
        v8 = 6 * length;
        v9 = 0x1555555555555555;
LABEL_12:
        if (length > v9)
          return -1;
        else
          return v8;
      }
    }
    else if (v11 == 1280 || v11 == 1536)
    {
      return v2;
    }
    goto LABEL_29;
  }
  if ((encoding & 0xFFF) == 0)
    return v2;
  if (v11 == 256)
  {
    v6 = 2 * length;
    v7 = (unint64_t)length >> 62;
LABEL_7:
    if (v7)
      return -1;
    else
      return v6;
  }
  if (v11 == 513)
    return v2;
LABEL_29:
  Converter = CFStringEncodingGetConverter(*(_QWORD *)&encoding);
  if (Converter)
  {
    v13 = *(unsigned __int16 *)(Converter + 16);
    v14 = 0x7FFFFFFFFFFFFFFFLL / v13;
    v15 = v13 * v2;
    if (v14 < v2)
      return -1;
    else
      return v15;
  }
  return v2;
}

uint64_t _CFPrefsGetCacheStringForBundleID(__CFString *a1)
{
  const __CFString *v1;
  BOOL v2;
  __CFBundle *MainBundle;
  const __CFString *Identifier;
  const __CFString *v7;

  v1 = (const __CFString *)_CFPrefsCurrentAppIdentifierCache;
  v2 = a1 == CFSTR("kCFPreferencesCurrentApplication") || _CFPrefsCurrentAppIdentifierCache == (_QWORD)a1;
  if (v2 || CFEqual(a1, CFSTR("kCFPreferencesCurrentApplication")))
  {
    if (!v1)
    {
      if ((MainBundle = CFBundleGetMainBundle()) != 0
        && (Identifier = CFBundleGetIdentifier(MainBundle)) != 0
        && (v1 = Identifier, CFStringGetLength(Identifier))
        || (v1 = (const __CFString *)_CFProcessNameString()) != 0)
      {
        v7 = _CFStringCopyBundleUnloadingProtectedString((uint64_t)v1);
        v1 = v7;
        while (!__ldaxr((unint64_t *)&_CFPrefsCurrentAppIdentifierCache))
        {
          if (!__stlxr((unint64_t)v7, (unint64_t *)&_CFPrefsCurrentAppIdentifierCache))
            return (uint64_t)v1;
        }
        __clrex();
        CFRelease(v7);
        return _CFPrefsCurrentAppIdentifierCache;
      }
    }
  }
  else if (!v1 || !CFEqual(v1, a1))
  {
    v1 = CFSTR("kCFPreferencesAnyApplication");
    if (!CFEqual(a1, CFSTR("kCFPreferencesAnyApplication"))
      && !CFEqual(a1, CFSTR("Apple Global Domain"))
      && !CFEqual(a1, CFSTR(".GlobalPreferences")))
    {
      return (uint64_t)a1;
    }
  }
  return (uint64_t)v1;
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  CFIndex Count;
  BOOL v7;
  char v8;
  __objc2_class **v9;
  int8x16_t *v10;
  size_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  const __CFString *ValueAtIndex;
  const __CFAllocator *v17;
  CFIndex v18;
  CFIndex i;
  __CFString *v20;
  CFIndex Length;
  char v22;
  uint64_t v23;
  char *Typed;
  CFIndex v25;
  char *v26;
  CFIndex v27;
  size_t v28;
  char v29;
  char v30;
  unsigned __int8 *v31;
  char v32;
  uint64_t *v33;
  char v34;
  unint64_t v35;
  __CFString *v36;
  CFIndex v37;
  size_t v38;
  char v39;
  uint64_t *v40;
  unsigned __int8 **v41;
  char v42;
  char v43;
  uint64_t v44;
  char v45;
  unint64_t *p_info;
  char v47;
  unint64_t v48;
  char v49;
  uint64_t v50;
  unint64_t v51;
  char v52;
  char v53;
  unint64_t v54;
  char v55;
  char v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  CFAllocatorRef v63;
  uint64_t *p_data;
  char *__s;
  CFStringRef theString;
  int v67;
  char v68;
  CFRange v69;
  CFRange v70;

  Count = CFArrayGetCount(theArray);
  v67 = CF_IS_OBJC(7uLL, (__objc2_class **)separatorString);
  if (v67)
  {
    v7 = 0;
  }
  else
  {
    v8 = atomic_load((unint64_t *)&separatorString->info);
    v7 = (v8 & 0x10) == 0;
  }
  if (Count == 1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0);
    return CFStringCreateCopy(alloc, ValueAtIndex);
  }
  else
  {
    if (Count)
    {
      if (!alloc)
      {
        v17 = (const __CFAllocator *)_CFGetTSD(1u);
        if (v17)
          alloc = v17;
        else
          alloc = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
      }
      theString = separatorString;
      v18 = CFStringGetLength(separatorString) * (Count - 1);
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          v20 = (__CFString *)CFArrayGetValueAtIndex(theArray, i);
          Length = CFStringGetLength(v20);
          if (CF_IS_OBJC(7uLL, (__objc2_class **)v20)
            || (v22 = atomic_load((unint64_t *)&v20->info), (v22 & 0x10) != 0))
          {
            v7 = 0;
          }
          v18 += Length;
        }
      }
      v62 = 2 * v18;
      if (v7)
        v23 = v18 + 1;
      else
        v23 = 2 * v18;
      Typed = (char *)CFAllocatorAllocateTyped(alloc, v23, 4140641899, 0);
      if (!Typed)
        __CFStringHandleOutOfMemory();
      v63 = alloc;
      if (__CFOASafe)
        __CFSetLastAllocationEventName();
      v68 = !v7;
      v25 = CFStringGetLength(theString);
      __s = Typed;
      if (Count >= 1)
      {
        v26 = 0;
        v27 = 0;
        v28 = v25 << v68;
        p_data = (uint64_t *)&theString->data;
        do
        {
          if (v27)
          {
            if (v26)
            {
              memmove(Typed, v26, v28);
            }
            else
            {
              if (v67)
              {
                v69.length = CFStringGetLength(theString);
                v69.location = 0;
                CFStringGetCharacters(theString, v69, (UniChar *)Typed);
              }
              else if (v7 || (v29 = atomic_load((unint64_t *)&theString->info), (v29 & 0x10) != 0))
              {
                v32 = atomic_load((unint64_t *)&theString->info);
                if ((v32 & 0x60) != 0)
                {
                  v33 = (uint64_t *)*p_data;
                }
                else
                {
                  v34 = atomic_load((unint64_t *)&theString->info);
                  v33 = &p_data[(v34 & 5) != 4];
                }
                v35 = atomic_load((unint64_t *)&theString->info);
                memmove(Typed, (char *)v33 + ((v35 >> 2) & 1), v28);
              }
              else
              {
                v30 = atomic_load((unint64_t *)&theString->info);
                if ((v30 & 0x60) != 0)
                {
                  v31 = (unsigned __int8 *)*p_data;
                }
                else
                {
                  v53 = atomic_load((unint64_t *)&theString->info);
                  v31 = (unsigned __int8 *)&p_data[(v53 & 5) != 4];
                }
                v54 = atomic_load((unint64_t *)&theString->info);
                v55 = atomic_load((unint64_t *)&theString->info);
                v56 = atomic_load((unint64_t *)&theString->info);
                v57 = v56 & 0x60;
                if ((v55 & 5) == 4)
                {
                  if (v57)
                  {
                    v58 = (uint64_t *)*p_data;
                  }
                  else
                  {
                    v60 = atomic_load((unint64_t *)&theString->info);
                    v58 = &p_data[(v60 & 5) != 4];
                  }
                  v59 = *(unsigned __int8 *)v58;
                }
                else if (v57)
                {
                  v59 = theString->length;
                }
                else
                {
                  v59 = *p_data;
                }
                __CFStrConvertBytesToUnicode(&v31[(v54 >> 2) & 1], Typed, v59);
              }
              v26 = Typed;
            }
            Typed += v28;
          }
          v36 = (__CFString *)CFArrayGetValueAtIndex(theArray, v27);
          if (CF_IS_OBJC(7uLL, (__objc2_class **)v36))
          {
            v37 = CFStringGetLength(v36);
            v70.location = 0;
            v70.length = v37;
            CFStringGetCharacters(v36, v70, (UniChar *)Typed);
            v38 = 2 * v37;
          }
          else
          {
            v39 = atomic_load((unint64_t *)&v36->info);
            v40 = (uint64_t *)&v36->data;
            if ((v39 & 0x60) != 0)
            {
              v41 = (unsigned __int8 **)*v40;
            }
            else
            {
              v42 = atomic_load((unint64_t *)&v36->info);
              v41 = (unsigned __int8 **)&v40[(v42 & 5) != 4];
            }
            v43 = atomic_load((unint64_t *)&v36->info);
            if ((v43 & 5) == 4)
            {
              v44 = *(unsigned __int8 *)v41;
            }
            else
            {
              v45 = atomic_load((unint64_t *)&v36->info);
              if ((v45 & 0x60) != 0)
                v44 = v36->length;
              else
                v44 = *v40;
            }
            v38 = v44 << v68;
            if (v7
              || (p_info = (unint64_t *)&v36->info,
                  v47 = atomic_load((unint64_t *)&v36->info),
                  (v47 & 0x10) != 0))
            {
              v51 = atomic_load((unint64_t *)&v36->info);
              v25 = (CFIndex)memmove(Typed, (char *)v41 + ((v51 >> 2) & 1), v38);
            }
            else
            {
              v48 = atomic_load(p_info);
              v49 = atomic_load(p_info);
              if ((v49 & 5) == 4)
              {
                v50 = *(unsigned __int8 *)v41;
              }
              else
              {
                v52 = atomic_load((unint64_t *)&v36->info);
                if ((v52 & 0x60) != 0)
                  v50 = v36->length;
                else
                  v50 = *v40;
              }
              v25 = (CFIndex)__CFStrConvertBytesToUnicode((unsigned __int8 *)v41 + ((v48 >> 2) & 1), Typed, v50);
            }
          }
          Typed += v38;
          ++v27;
        }
        while (Count != v27);
      }
      if (v7)
      {
        *Typed = 0;
        v61 = __CFDefaultEightBitStringEncoding;
        if (__CFDefaultEightBitStringEncoding == -1)
        {
          __CFStringComputeEightBitStringEncoding(v25);
          v61 = __CFDefaultEightBitStringEncoding;
        }
        v11 = strlen(__s);
        v9 = (__objc2_class **)v63;
        v10 = (int8x16_t *)__s;
        v12 = v61;
        v13 = 24;
        v14 = (uint64_t)v63;
      }
      else
      {
        v11 = v62;
        v9 = (__objc2_class **)v63;
        v10 = (int8x16_t *)__s;
        v12 = 256;
        v13 = 16;
        v14 = (uint64_t)v63;
      }
    }
    else
    {
      v9 = (__objc2_class **)alloc;
      v10 = 0;
      v11 = 0;
      v12 = 256;
      v13 = 2;
      v14 = -1;
    }
    return (CFStringRef)__CFStringCreateImmutableFunnel3(v9, v10, v11, v12, v13, (const __CFAllocator *)v14, 0);
  }
}

void __CFStringsDictAddFunction(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionaryAddValue(theDict, key, value);
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t Status;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFIndex v11;
  _OWORD *Typed;
  CFAllocatorRef v13;
  uint64_t v14;
  uint64_t v15;
  pthread_mutex_t *v16;
  uint64_t v17;
  __CFRunLoopSource *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
    return -[__CFWriteStream write:maxLength:](stream, "write:maxLength:", buffer, bufferLength);
  Status = _CFStreamGetStatus((uint64_t)stream);
  v8 = *((_QWORD *)stream + 6);
  if (Status == 1)
  {
    *((_QWORD *)stream + 2) |= 0x40uLL;
    waitForOpen((uint64_t)stream);
    *((_QWORD *)stream + 2) &= ~0x40uLL;
    Status = _CFStreamGetStatus((uint64_t)stream);
  }
  if (Status == 4 || Status == 2)
  {
    if ((*((_QWORD *)stream + 2) & 0x1ELL) == 6)
      v9 = *((_QWORD *)stream + 2) | 0x40;
    else
      v9 = *((_QWORD *)stream + 2) & 0xFFFFFFA0 | 0x44;
    *((_QWORD *)stream + 2) = v9;
    v10 = *((_QWORD *)stream + 4);
    if (v10)
      *(_QWORD *)(v10 + 72) &= ~4uLL;
    if (*(uint64_t *)v8 > 1)
    {
      v11 = (*(uint64_t (**)(CFWriteStreamRef, const UInt8 *, CFIndex, char *, _QWORD))(v8 + 72))(stream, buffer, bufferLength, (char *)stream + 24, *((_QWORD *)stream + 5));
    }
    else
    {
      v23 = 0uLL;
      v11 = (*(uint64_t (**)(CFWriteStreamRef, const UInt8 *, CFIndex, __int128 *, _QWORD))(v8 + 72))(stream, buffer, bufferLength, &v23, *((_QWORD *)stream + 5));
      if (DWORD2(v23))
      {
        Typed = (_OWORD *)*((_QWORD *)stream + 3);
        if (!Typed)
        {
          v13 = CFGetAllocator(stream);
          Typed = (_OWORD *)CFAllocatorAllocateTyped(v13, 16, 0x1000040D9A13B51, 0);
          *((_QWORD *)stream + 3) = Typed;
        }
        *Typed = v23;
      }
    }
    if (*((_QWORD *)stream + 3))
    {
      v14 = *((_QWORD *)stream + 2);
      if ((v14 & 0x1F) != 7)
        *((_QWORD *)stream + 2) = v14 & 0xFFFFFFE0 | 7;
      v15 = *((_QWORD *)stream + 4);
      if (!v15 || (*(_BYTE *)(v15 + 48) & 8) == 0)
        goto LABEL_39;
      v16 = (pthread_mutex_t *)((char *)stream + 56);
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      v17 = *((_QWORD *)stream + 4);
      if (v17)
      {
        v18 = *(__CFRunLoopSource **)(v17 + 56);
        if (v18)
        {
          CFRetain(*(CFTypeRef *)(v17 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          v19 = *((_QWORD *)stream + 4);
          v20 = *(_QWORD *)(v19 + 72) | 8;
LABEL_26:
          *(_QWORD *)(v19 + 72) = v20;
          CFRunLoopSourceSignal(v18);
          CFRelease(v18);
          _wakeUpRunLoop((uint64_t)stream);
LABEL_39:
          *((_QWORD *)stream + 2) &= ~0x40uLL;
          return v11;
        }
      }
    }
    else
    {
      if (v11)
      {
        if ((*((_QWORD *)stream + 2) & 0x1ELL) != 6)
          *((_QWORD *)stream + 2) = *((_QWORD *)stream + 2) & 0xFFFFFFE0 | 2;
        goto LABEL_39;
      }
      if ((*((_QWORD *)stream + 2) & 0x1ELL) != 6)
        *((_QWORD *)stream + 2) = *((_QWORD *)stream + 2) & 0xFFFFFFE0 | 5;
      v21 = *((_QWORD *)stream + 4);
      if (!v21 || (*(_BYTE *)(v21 + 48) & 0x10) == 0)
        goto LABEL_39;
      v16 = (pthread_mutex_t *)((char *)stream + 56);
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      v22 = *((_QWORD *)stream + 4);
      if (v22)
      {
        v18 = *(__CFRunLoopSource **)(v22 + 56);
        if (v18)
        {
          CFRetain(*(CFTypeRef *)(v22 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          v19 = *((_QWORD *)stream + 4);
          v20 = *(_QWORD *)(v19 + 72) | 0x10;
          goto LABEL_26;
        }
      }
    }
    pthread_mutex_unlock(v16);
    goto LABEL_39;
  }
  return -1;
}

uint64_t _CFStreamOpen(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t, char *, _QWORD);
  _OWORD *Typed;
  CFAllocatorRef v7;
  uint64_t v8;
  uint64_t v9;
  __CFRunLoopSource *v10;
  uint64_t v11;
  uint64_t v12;
  __CFRunLoopSource *v13;
  __int128 v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *(uint64_t **)(a1 + 48);
  if (!_CFStreamGetStatus(a1))
  {
    v16 = 0;
    if ((*(_QWORD *)(a1 + 16) & 0x1ELL) == 6)
      v4 = *(_QWORD *)(a1 + 16) | 0x40;
    else
      v4 = *(_QWORD *)(a1 + 16) & 0xFFFFFFA0 | 0x41;
    *(_QWORD *)(a1 + 16) = v4;
    v5 = (uint64_t (*)(uint64_t, uint64_t, char *, _QWORD))v2[4];
    if (v5)
    {
      if (*v2 > 1)
      {
        v3 = v5(a1, a1 + 24, &v16, *(_QWORD *)(a1 + 40));
      }
      else
      {
        v15 = 0uLL;
        v3 = v5(a1, (uint64_t)&v15, &v16, *(_QWORD *)(a1 + 40));
        if (DWORD2(v15))
        {
          Typed = *(_OWORD **)(a1 + 24);
          if (!Typed)
          {
            v7 = CFGetAllocator((CFTypeRef)a1);
            Typed = (_OWORD *)CFAllocatorAllocateTyped(v7, 16, 0x1000040D9A13B51, 0);
            *(_QWORD *)(a1 + 24) = Typed;
          }
          *Typed = v15;
        }
      }
      if (!v16)
        goto LABEL_33;
      v4 = *(_QWORD *)(a1 + 16);
      if (!(_DWORD)v3)
      {
        if ((*(_QWORD *)(a1 + 16) & 0x1FLL) != 7)
          *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 16) & 0xFFFFFFE0 | 7;
        v11 = *(_QWORD *)(a1 + 32);
        if (v11 && (*(_BYTE *)(v11 + 48) & 8) != 0)
        {
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
          v12 = *(_QWORD *)(a1 + 32);
          if (v12 && (v13 = *(__CFRunLoopSource **)(v12 + 56)) != 0)
          {
            CFRetain(*(CFTypeRef *)(v12 + 56));
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
            *(_QWORD *)(*(_QWORD *)(a1 + 32) + 72) |= 8uLL;
            CFRunLoopSourceSignal(v13);
            CFRelease(v13);
            _wakeUpRunLoop(a1);
          }
          else
          {
            pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
          }
        }
        v3 = 0;
        goto LABEL_33;
      }
    }
    else
    {
      v3 = 1;
      v16 = 1;
    }
    if ((v4 & 0x1F) == 1)
      *(_QWORD *)(a1 + 16) = v4 & 0xFFFFFFE0 | 2;
    v8 = *(_QWORD *)(a1 + 32);
    if (v8 && (*(_BYTE *)(v8 + 48) & 1) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      v9 = *(_QWORD *)(a1 + 32);
      if (v9 && (v10 = *(__CFRunLoopSource **)(v9 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v9 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 72) |= 1uLL;
        CFRunLoopSourceSignal(v10);
        CFRelease(v10);
        _wakeUpRunLoop(a1);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }
    }
LABEL_33:
    *(_QWORD *)(a1 + 16) &= ~0x40uLL;
    return v3;
  }
  return 0;
}

void _CFStreamClose(uint64_t a1)
{
  uint64_t Status;
  uint64_t v3;
  uint64_t v4;
  void (*v5)(uint64_t, _QWORD);
  uint64_t v6;
  uint64_t v7;
  void *v8;
  const void *Value;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex FirstIndexOfValue;
  uint64_t v13;
  __CFRunLoopSource *v14;
  __CFRunLoop *ValueAtIndex;
  const __CFString *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  CFRange v20;

  Status = _CFStreamGetStatus(a1);
  if (!Status || Status == 6)
    return;
  v3 = *(_QWORD *)(a1 + 48);
  if (Status == 7)
  {
    v4 = *(_QWORD *)(a1 + 16);
    if ((v4 & 0x80) != 0)
      return;
  }
  else
  {
    v4 = *(_QWORD *)(a1 + 16);
    if ((v4 & 0x80) != 0)
      return;
  }
  *(_QWORD *)(a1 + 16) = v4 | 0xC0;
  v5 = *(void (**)(uint64_t, _QWORD))(v3 + 88);
  if (v5)
    v5(a1, *(_QWORD *)(a1 + 40));
  v6 = *(_QWORD *)(a1 + 32);
  if (v6 && *(_QWORD *)(v6 + 56))
  {
    if ((*(_BYTE *)(a1 + 17) & 1) == 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      v7 = *(_QWORD *)(a1 + 32);
      if (v7)
      {
        v8 = *(void **)(v7 + 56);
        if (v8)
        {
          CFRetain(*(CFTypeRef *)(v7 + 56));
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56) = 0;
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
          CFRelease(v8);
          CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v8);
          CFRelease(v8);
          goto LABEL_33;
        }
        *(_QWORD *)(v7 + 56) = 0;
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      goto LABEL_33;
    }
    os_unfair_lock_lock((os_unfair_lock_t)&sSourceLock);
    Value = CFDictionaryGetValue((CFDictionaryRef)sSharedSources, (const void *)a1);
    v10 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)sSharedSources, Value);
    Count = CFArrayGetCount(v10);
    v20.location = 0;
    v20.length = Count;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v10, v20, (const void *)a1);
    if (FirstIndexOfValue != -1)
    {
      CFArrayRemoveValueAtIndex(v10, FirstIndexOfValue);
      --Count;
    }
    if (!Count)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      v13 = *(_QWORD *)(a1 + 32);
      if (v13 && (v14 = *(__CFRunLoopSource **)(v13 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v13 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        ValueAtIndex = (__CFRunLoop *)CFArrayGetValueAtIndex((CFArrayRef)Value, 0);
        v16 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)Value, 1);
        CFRunLoopRemoveSource(ValueAtIndex, v14, v16);
        CFRelease(v14);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }
      CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, Value);
    }
    CFDictionaryRemoveValue((CFMutableDictionaryRef)sSharedSources, (const void *)a1);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
    v17 = *(_QWORD *)(a1 + 32);
    if (v17)
    {
      v18 = *(void **)(v17 + 56);
      if (v18)
      {
        CFRetain(*(CFTypeRef *)(v17 + 56));
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56) = 0;
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        CFRelease(v18);
        if (!Count)
          CFRunLoopSourceInvalidate((CFRunLoopSourceRef)v18);
        CFRelease(v18);
        goto LABEL_32;
      }
      *(_QWORD *)(v17 + 56) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
LABEL_32:
    *(_QWORD *)(a1 + 16) &= ~0x100uLL;
    os_unfair_lock_unlock((os_unfair_lock_t)&sSourceLock);
  }
LABEL_33:
  v19 = *(_QWORD *)(a1 + 16);
  if ((v19 & 0x1E) != 6)
    v19 = v19 & 0xFFFFFFA0 | 6;
  *(_QWORD *)(a1 + 16) = v19 & 0xFFFFFFFFFFFFFFBFLL;
}

uint64_t _CFStreamGetStatus(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t *v4;
  uint64_t (*v5)(uint64_t, __int128 *, _QWORD);
  int v6;
  _OWORD *Typed;
  CFAllocatorRef v8;
  uint64_t v9;
  BOOL v10;
  int v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __CFRunLoopSource *v16;
  uint64_t v17;
  __CFRunLoopSource *v18;
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 16);
  result = v2 & 0x1F;
  *(_QWORD *)(a1 + 16) = v2 | 0x40;
  if (result != 1)
    goto LABEL_39;
  v4 = *(uint64_t **)(a1 + 48);
  v5 = (uint64_t (*)(uint64_t, __int128 *, _QWORD))v4[5];
  if (!v5)
    goto LABEL_29;
  if (*v4 <= 1)
  {
    v19 = 0uLL;
    v6 = v5(a1, &v19, *(_QWORD *)(a1 + 40));
    if (DWORD2(v19))
    {
      Typed = *(_OWORD **)(a1 + 24);
      if (!Typed)
      {
        v8 = CFGetAllocator((CFTypeRef)a1);
        Typed = (_OWORD *)CFAllocatorAllocateTyped(v8, 16, 0x1000040D9A13B51, 0);
        *(_QWORD *)(a1 + 24) = Typed;
      }
      *Typed = v19;
    }
    if (v6)
      goto LABEL_9;
LABEL_29:
    result = 1;
    goto LABEL_39;
  }
  if (!v5(a1, (__int128 *)(a1 + 24), *(_QWORD *)(a1 + 40)))
    goto LABEL_29;
LABEL_9:
  v9 = *(_QWORD *)(a1 + 24);
  if (v9)
    v10 = (*(_QWORD *)(a1 + 16) & 0x1FLL) == 6;
  else
    v10 = 0;
  v11 = v10;
  if ((*(_QWORD *)(a1 + 16) & 0x1FuLL) - 8 < 0xFFFFFFFFFFFFFFFELL || v11 != 0)
  {
    v13 = 2;
    if (v9)
      v13 = 7;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 16) & 0xFFFFFFE0 | v13;
  }
  v14 = *(_QWORD *)(a1 + 32);
  if (v9)
  {
    if (v14 && (*(_BYTE *)(v14 + 48) & 8) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      v15 = *(_QWORD *)(a1 + 32);
      if (v15 && (v16 = *(__CFRunLoopSource **)(v15 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v15 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 72) |= 8uLL;
        CFRunLoopSourceSignal(v16);
        CFRelease(v16);
        _wakeUpRunLoop(a1);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }
    }
    result = 7;
  }
  else
  {
    if (v14 && (*(_BYTE *)(v14 + 48) & 1) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
      v17 = *(_QWORD *)(a1 + 32);
      if (v17 && (v18 = *(__CFRunLoopSource **)(v17 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v17 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 72) |= 1uLL;
        CFRunLoopSourceSignal(v18);
        CFRelease(v18);
        _wakeUpRunLoop(a1);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
      }
    }
    result = 2;
  }
LABEL_39:
  *(_QWORD *)(a1 + 16) &= ~0x40uLL;
  return result;
}

uint64_t dataWrite(char *a1, char *__src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *Typed;
  int64_t v11;
  uint64_t v14;
  uint64_t v16;

  Typed = *(_QWORD **)(a5 + 8);
  v11 = Typed[1] - Typed[2];
  if (*(__objc2_class ***)(a5 + 16) == &__kCFAllocatorNull && v11 < a3)
  {
LABEL_17:
    *(_DWORD *)(a4 + 8) = 12;
    *(_QWORD *)a4 = 1;
    return -1;
  }
  else
  {
    v14 = a3;
    if (a3 >= 1)
    {
      v16 = a3;
      while (1)
      {
        if (v11 >= 1)
        {
          if (v16 < v11)
            v11 = v16;
          memmove((void *)(*Typed + Typed[2]), __src, v11);
          v16 -= v11;
          Typed = *(_QWORD **)(a5 + 8);
          Typed[2] += v11;
          if (v16 < 1)
            break;
          __src += v11;
        }
        if (v16 <= 1024)
          v11 = 1024;
        else
          v11 = v16;
        Typed = (_QWORD *)CFAllocatorAllocateTyped(*(_QWORD *)(a5 + 16), v11 + 32, 2750053540, 0);
        if (!Typed)
          goto LABEL_17;
        *Typed = Typed + 4;
        Typed[1] = v11;
        Typed[2] = 0;
        Typed[3] = 0;
        *(_QWORD *)(*(_QWORD *)(a5 + 8) + 24) = Typed;
        *(_QWORD *)(a5 + 8) = Typed;
      }
    }
    *(_DWORD *)(a4 + 8) = 0;
    if (*(_BYTE *)(a5 + 24) && (*(__objc2_class ***)(a5 + 16) != &__kCFAllocatorNull || Typed[1] > Typed[2]))
      CFWriteStreamSignalEvent(a1, 4uLL, 0, a4, a5, a6, a7, a8);
  }
  return v14;
}

uint64_t writeDataOpen(char *a1, uint64_t a2, _BYTE *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;

  if (*(_BYTE *)(a4 + 24))
  {
    if (*(__objc2_class ***)(a4 + 16) == &__kCFAllocatorNull)
    {
      if (*(_QWORD *)(*(_QWORD *)(a4 + 8) + 8) <= *(_QWORD *)(*(_QWORD *)(a4 + 8) + 16))
        v10 = 16;
      else
        v10 = 4;
    }
    else
    {
      v10 = 4;
    }
    CFWriteStreamSignalEvent(a1, v10, 0, a4, a5, a6, a7, a8);
  }
  *(_DWORD *)(a2 + 8) = 0;
  *a3 = 1;
  return 1;
}

CFIndex CFNumberGetByteSize(CFNumberRef number)
{
  return 1 << (((unint64_t)(unsigned __int16)__CFNumberTypeTable[CFNumberGetType(number)] >> 7) & 7);
}

CFTypeID CFUUIDGetTypeID(void)
{
  return 34;
}

CFTypeID CFURLGetTypeID(void)
{
  return 29;
}

uint64_t readDataOpen(char *a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;

  if (*(_BYTE *)(a4 + 16))
  {
    if (CFDataGetLength(*(CFDataRef *)a4))
      v12 = 2;
    else
      v12 = 16;
    CFReadStreamSignalEvent(a1, v12, 0, v7, v8, v9, v10, v11);
  }
  *(_DWORD *)(a2 + 8) = 0;
  *a3 = 1;
  return 1;
}

void CFBitVectorSetBitAtIndex(CFMutableBitVectorRef bv, CFIndex idx, CFBit value)
{
  uint64_t v3;
  CFIndex v4;
  int v5;
  char v6;

  v3 = *((_QWORD *)bv + 4);
  v4 = idx / 8;
  v5 = 1 << (~(_BYTE)idx & 7);
  if (value)
    v6 = *(_BYTE *)(v3 + v4) | v5;
  else
    v6 = *(_BYTE *)(v3 + v4) & ~(_BYTE)v5;
  *(_BYTE *)(v3 + v4) = v6;
}

CFURLRef CFURLGetBaseURL(CFURLRef anURL)
{
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
    return (CFURLRef)-[__CFURL baseURL](anURL, "baseURL");
  else
    return (CFURLRef)*((_QWORD *)anURL + 4);
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFIndex location;
  CFIndex v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (otherRange.length >= 1)
  {
    v13 = v6;
    v14 = v5;
    v15 = v4;
    v16 = v3;
    v17 = v7;
    v18 = v8;
    location = otherRange.location;
    v12 = otherRange.location + otherRange.length;
    do
      CFArrayAppendValue(theArray, (const void *)-[__CFArray objectAtIndex:](otherArray, "objectAtIndex:", location++, v13, v14, v15, v16, v17, v18));
    while (location < v12);
  }
}

ssize_t fileWrite(uint64_t a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  ssize_t v6;
  uint64_t v7;
  __CFFileDescriptor *v8;

  v6 = fdWrite(*(_DWORD *)(a5 + 8), a2, a3, a4);
  v7 = *(_QWORD *)(a5 + 24);
  if ((v7 & 1) != 0)
  {
    *(_QWORD *)(a5 + 24) = v7 & 0xFFFFFFFFFFFFFFFELL;
    v8 = *(__CFFileDescriptor **)(a5 + 16);
    if (v8)
      CFFileDescriptorEnableCallBacks(v8, 2uLL);
  }
  return v6;
}

ssize_t fdWrite(int a1, const void *a2, size_t a3, uint64_t a4)
{
  ssize_t result;
  int v6;

  result = write(a1, a2, a3);
  if (result < 0)
  {
    v6 = *__error();
    *(_QWORD *)a4 = 1;
    result = -1;
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(a4 + 8) = v6;
  return result;
}

void fileClose(uint64_t a1, uint64_t a2)
{
  int v3;
  __CFFileDescriptor *v4;
  const void **v5;
  __CFFileDescriptor *v6;
  const void *v7;

  v3 = *(_DWORD *)(a2 + 8);
  if (v3 < 0)
  {
    v5 = (const void **)(a2 + 16);
    v7 = *(const void **)(a2 + 16);
    if (!v7)
      return;
  }
  else
  {
    close(v3);
    v6 = *(__CFFileDescriptor **)(a2 + 16);
    v5 = (const void **)(a2 + 16);
    v4 = v6;
    *((_DWORD *)v5 - 2) = -1;
    if (!v6)
      return;
    CFFileDescriptorInvalidate(v4);
    v7 = *v5;
  }
  CFRelease(v7);
  *v5 = 0;
}

void _onelineFormatArrayApply(uint64_t a1, CFMutableStringRef theString)
{
  CFStringAppendFormat(theString, 0, CFSTR("%@, "), a1);
}

void __CFVariableWidthStringDictionaryApplyFunction(const void *a1, const __CFDictionary *a2, uint64_t a3)
{
  CFTypeID TypeID;
  const __CFDictionary *Value;
  const __CFDictionary *v8;
  objc_class *v9;
  const void *v10;
  uint64_t context;
  CFTypeRef cf;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("NSStringVariableWidthRuleType"));
    if (Value)
    {
      v8 = Value;
      if (CFDictionaryGetCount(Value))
      {
        context = *(_QWORD *)(a3 + 16);
        cf = CFDictionaryCreateMutableCopy(0, 0, v8);
        CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)__CFVariableWidthStringApplyFunction, &context);
        v9 = _CFStringCreateWithWidthContexts((uint64_t)cf);
        CFRelease(cf);
        if (v9)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v9);
          CFRelease(v9);
        }
      }
      else if (*(_QWORD *)a3 && (v10 = CFDictionaryGetValue(*(CFDictionaryRef *)a3, a1)) != 0)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v10);
      }
      else
      {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 8), a1);
      }
    }
  }
}

void __CFPlatformSpecificStringDictionaryApplyFunction(const void *a1, const __CFDictionary *a2, CFDictionaryRef *a3)
{
  CFTypeID TypeID;
  const __CFDictionary *Value;
  const __CFDictionary *v8;
  const void *v9;
  const void *v10;
  CFTypeID v11;
  CFTypeID v12;
  CFTypeID v13;
  CFTypeID v14;
  const void *v15;
  __CFDictionary *v16;

  TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("NSStringDeviceSpecificRuleType"));
    if (Value)
    {
      v8 = Value;
      v9 = (const void *)_CFGetProductName();
      if (!CFDictionaryGetCount(v8))
        goto LABEL_16;
      if (!v9
        || (v10 = CFDictionaryGetValue(v8, v9)) == 0
        && (!CFEqual(v9, CFSTR("ipod")) && !CFEqual(v9, CFSTR("ipad"))
         || (v10 = CFDictionaryGetValue(v8, CFSTR("iphone"))) == 0))
      {
        v10 = CFDictionaryGetValue(v8, CFSTR("other"));
        if (!v10)
          goto LABEL_16;
      }
      v11 = CFGetTypeID(v10);
      if (v11 == CFStringGetTypeID() || (v12 = CFGetTypeID(v10), v12 == CFDictionaryGetTypeID()))
        CFDictionarySetValue(a3[1], a1, v10);
      v13 = CFGetTypeID(v10);
      if (v13 != CFStringGetTypeID())
      {
        v14 = CFGetTypeID(v10);
        if (v14 != CFDictionaryGetTypeID())
        {
LABEL_16:
          v15 = CFDictionaryGetValue(*a3, a1);
          v16 = a3[1];
          if (v15)
            CFDictionarySetValue(v16, a1, v15);
          else
            CFDictionaryRemoveValue(v16, a1);
        }
      }
    }
  }
}

void __CFLocalizedFormatStringApplyFunction(const void *a1, const __CFDictionary *a2, uint64_t a3)
{
  CFTypeID TypeID;
  void *Value;
  const void *v8;
  const void *v9;

  TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    Value = (void *)CFDictionaryGetValue(a2, CFSTR("NSStringLocalizedFormatKey"));
    if (Value)
    {
      v8 = (const void *)_CFStringCopyWithFomatStringConfiguration(Value, (uint64_t)a2);
      if (v8)
      {
        v9 = v8;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v8);
        CFRelease(v9);
      }
    }
  }
}

void __CFAttributedLocalizedStringDictionaryApplyFunction(const void *a1, const __CFDictionary *a2, uint64_t a3)
{
  CFTypeID TypeID;
  const void *Value;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;

  TypeID = CFDictionaryGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    Value = CFDictionaryGetValue(a2, CFSTR("NSStringFormatSpecTypeKey"));
    if (Value)
    {
      if (CFEqual(Value, CFSTR("NSStringDirectRuleType")))
      {
        v8 = CFDictionaryGetValue(a2, CFSTR("NSStringLocalizationKey"));
        if (v8
          && (v9 = v8, CFGetTypeID(v8) == 7)
          && ((v10 = CFDictionaryGetValue(a2, CFSTR("NSStringFormatIsMarkdownKey"))) != 0
           && CFEqual(v10, &__kCFBooleanTrue)
           && !*(_BYTE *)(a3 + 40)
            ? (v11 = (const void *)_CFStringCreateWithMarkdownAndConfiguration((uint64_t)v9, (uint64_t)a2, *(_QWORD *)(a3 + 24), *(_QWORD *)(a3 + 32))): (v11 = CFRetain(v9)), (v12 = v11) != 0))
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v11);
          CFRelease(v12);
        }
        else if (*(_QWORD *)a3 && (v13 = CFDictionaryGetValue(*(CFDictionaryRef *)a3, a1)) != 0)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), a1, v13);
        }
        else
        {
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 8), a1);
        }
      }
    }
  }
}

uint64_t _CFStringCopyWithFomatStringConfiguration(void *a1, uint64_t a2)
{
  if ((objc_opt_respondsToSelector() & 1) != 0)
    return objc_msgSend(a1, "_copyFormatStringWithConfiguration:", a2);
  CFRetain(a1);
  return (uint64_t)a1;
}

uint64_t _calcMinTimeout_locked(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  BOOL v5;

  v2 = *(_QWORD *)(result + 272);
  if (!v2 && !*(_DWORD *)(result + 280))
    goto LABEL_7;
  v3 = (void *)(result + 272);
  v4 = *a2;
  if (*a2)
  {
    v5 = v2 < *(_QWORD *)v4;
    if (v2 == *(_QWORD *)v4)
      v5 = *(_DWORD *)(result + 280) < *(_DWORD *)(v4 + 8);
    if (!v5)
    {
LABEL_7:
      if (!*(_QWORD *)(result + 328))
        return result;
      v3 = &_calcMinTimeout_locked_sKickerTime;
    }
  }
  *a2 = (uint64_t)v3;
  return result;
}

uint64_t _CFGetProductName()
{
  if (_CFGetProductName_onceToken != -1)
    dispatch_once(&_CFGetProductName_onceToken, &__block_literal_global_46);
  return _CFGetProductName__cfBundlePlatform;
}

void _searchForExistingFactoryLocked(const __CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeID v5;
  const void *v6;
  CFTypeRef *Value;

  if (!*a3)
  {
    v5 = CFGetTypeID(a1);
    if (v5 != CFStringGetTypeID()
      || (v6 = CFUUIDCreateFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1)) == 0)
    {
      v6 = CFRetain(a1);
    }
    if (_factoriesByFactoryID)
    {
      Value = (CFTypeRef *)CFDictionaryGetValue((CFDictionaryRef)_factoriesByFactoryID, v6);
      if (Value)
        *a3 = CFRetain(Value[5]);
    }
    if (v6)
      CFRelease(v6);
  }
}

const __CFString *_searchForDummyUUID(const __CFString *result, const __CFString *a2, _BYTE *a3)
{
  const __CFString *v5;
  CFTypeID v6;
  CFTypeID v7;

  if (!*a3)
  {
    v5 = result;
    v6 = CFGetTypeID(result);
    result = (const __CFString *)CFStringGetTypeID();
    if ((const __CFString *)v6 == result)
    {
      result = (const __CFString *)CFStringCompare(v5, CFSTR("00000000-0000-0000-0000-000000000000"), 0);
      if (a2)
      {
        if (!result)
        {
          v7 = CFGetTypeID(a2);
          result = (const __CFString *)CFStringGetTypeID();
          if ((const __CFString *)v7 == result)
          {
            result = (const __CFString *)CFStringCompare(a2, CFSTR("MyFactoryFunction"), 0);
            if (!result)
              *a3 = 1;
          }
        }
      }
    }
  }
  return result;
}

void _registerFactoryLocked(const __CFString *a1, const __CFString *a2, const void *a3)
{
  CFTypeID v6;
  const void *v7;
  CFTypeID v8;
  NSObject *v9;
  const __CFString *v10;
  int v11;
  const void *v12;
  __int16 v13;
  const __CFString *v14;
  __int16 v15;
  const void *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID()
    || (v7 = CFUUIDCreateFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1)) == 0)
  {
    v7 = CFRetain(a1);
  }
  v8 = CFGetTypeID(a2);
  if (v8 != CFStringGetTypeID() || CFStringGetLength(a2) <= 0)
    a2 = 0;
  if (_CFBundlePluginLogger_onceToken != -1)
    dispatch_once(&_CFBundlePluginLogger_onceToken, &__block_literal_global_12);
  v9 = _CFBundlePluginLogger__log;
  if (os_log_type_enabled((os_log_t)_CFBundlePluginLogger__log, OS_LOG_TYPE_DEBUG))
  {
    v10 = CFSTR("<no func>");
    v11 = 138543874;
    if (a2)
      v10 = a2;
    v12 = v7;
    v13 = 2114;
    v14 = v10;
    v15 = 2050;
    v16 = a3;
    _os_log_debug_impl(&dword_182A8C000, v9, OS_LOG_TYPE_DEBUG, "Registering static factory %{public}@ %{public}@ bundle %{public}p", (uint8_t *)&v11, 0x20u);
  }
  _CFPlugInRegisterFactoryFunctionByNameLocked(v7, a3, a2);
  if (v7)
    CFRelease(v7);
}

void boundPairWriteClose(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v3;
  const void *v4;
  const void *v5;
  uint64_t v6;
  const void *v7;
  const void *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v6 = 0;
    v7 = 0;
    v3 = (pthread_mutex_t *)(a2 + 104);
    v8 = 0;
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    *(_BYTE *)(a2 + 50) = 1;
    *(_BYTE *)(a2 + 3) = 1;
    if (!*(_BYTE *)(a2 + 2))
    {
      if (*(_WORD *)(a2 + 4))
      {
        setupScheduledStreamCloseBlock(&v6, *(CFTypeRef *)(a2 + 32), *(CFTypeRef *)(a2 + 8), *(CFTypeRef *)(a2 + 16));
      }
      else
      {
        v5 = *(const void **)(a2 + 8);
        v4 = *(const void **)(a2 + 16);
        v6 = 0;
        if (v5)
          CFRetain(v5);
        v7 = v5;
        if (v4)
          CFRetain(v4);
        v8 = v4;
      }
    }
    pthread_mutex_unlock(v3);
    performUnlockParamsAndDealloc((uint64_t)&v6);
  }
}

void locallySetValueOverlayMergeFunc(void *key, const __CFString *value, CFMutableDictionaryRef theDict)
{
  if (value == CFSTR("MagicRemovedValue"))
    CFDictionaryRemoveValue(theDict, key);
  else
    CFDictionarySetValue(theDict, key, value);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
  uint64_t v2;

  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    -[__CFArray removeAllObjects](theArray, "removeAllObjects");
  }
  else
  {
    __CFArrayReleaseValues((unint64_t)theArray, 0, *((_QWORD *)theArray + 2), 1);
    v2 = *((_QWORD *)theArray + 3) + 1;
    *((_QWORD *)theArray + 2) = 0;
    *((_QWORD *)theArray + 3) = v2;
  }
}

void sub_182AE612C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __CFArrayReleaseValues(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v8;
  int v9;
  const CFArrayCallBacks *v10;
  char v11;
  int v12;
  const CFArrayCallBacks *v13;
  char v14;
  int v15;
  char v17;
  int v18;
  char v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  char v24;
  int v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  const CFAllocatorRef *v30;
  CFAllocatorRef v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  const CFAllocatorRef *v35;
  char v36;
  CFAllocatorRef v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  CFAllocatorRef *v41;
  char v42;

  v8 = atomic_load((unint64_t *)(a1 + 8));
  v9 = (v8 >> 2) & 3;
  if (v9)
  {
    if (v9 == 1)
    {
      v10 = &kCFTypeArrayCallBacks;
    }
    else
    {
      v11 = atomic_load((unint64_t *)(a1 + 8));
      v12 = v11 & 3;
      if (v12)
        v13 = 0;
      else
        v13 = (const CFArrayCallBacks *)(a1 + 48);
      if (v12 == 2)
        v10 = (const CFArrayCallBacks *)(a1 + 48);
      else
        v10 = v13;
    }
  }
  else
  {
    v10 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
  v14 = atomic_load((unint64_t *)(a1 + 8));
  v15 = v14 & 3;
  if (v15 == 2)
  {
    v23 = *(void **)(a1 + 40);
    if (a3 >= 1 && v23)
    {
      v24 = atomic_load((unint64_t *)(a1 + 8));
      v25 = v24 & 3;
      if (v25 == 2)
      {
        v28 = *(_QWORD *)(a1 + 40) + 8 * **(_QWORD **)(a1 + 40) + 16;
      }
      else if (v25)
      {
        v28 = 0;
      }
      else
      {
        v26 = atomic_load((unint64_t *)(a1 + 8));
        v20 = (~v26 & 0xC) == 0;
        v27 = 48;
        if (v20)
          v27 = 88;
        v28 = a1 + v27;
      }
      if (v10->release)
      {
        if ((a1 & 0x8000000000000000) != 0)
        {
          v35 = &kCFAllocatorSystemDefault;
        }
        else
        {
          v36 = atomic_load((unint64_t *)(a1 + 8));
          if (v36 < 0)
            v35 = &kCFAllocatorSystemDefault;
          else
            v35 = (const CFAllocatorRef *)(a1 - 16);
        }
        v37 = *v35;
        v38 = (uint64_t *)(v28 + 8 * a2);
        v39 = a3;
        do
        {
          v40 = *v38++;
          ((void (*)(CFAllocatorRef, uint64_t))v10->release)(v37, v40);
          --v39;
        }
        while (v39);
      }
      bzero((void *)(v28 + 8 * a2), 8 * a3);
    }
    if (a4 && !a2 && *(_QWORD *)(a1 + 16) == a3)
    {
      if ((a1 & 0x8000000000000000) != 0)
      {
        v41 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
      }
      else
      {
        v42 = atomic_load((unint64_t *)(a1 + 8));
        if (v42 < 0)
          v41 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
        else
          v41 = (CFAllocatorRef *)(a1 - 16);
      }
      if (v23)
        CFAllocatorDeallocate(*v41, v23);
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 40) = 0;
    }
  }
  else if (!v15 && v10->release && a3 >= 1)
  {
    v17 = atomic_load((unint64_t *)(a1 + 8));
    v18 = v17 & 3;
    if (v18 == 2)
    {
      v22 = *(_QWORD *)(a1 + 40) + 8 * **(_QWORD **)(a1 + 40) + 16;
      if ((a1 & 0x8000000000000000) == 0)
        goto LABEL_31;
    }
    else
    {
      if (!v18)
      {
        v19 = atomic_load((unint64_t *)(a1 + 8));
        v20 = (~v19 & 0xC) == 0;
        v21 = 48;
        if (v20)
          v21 = 88;
        v22 = a1 + v21;
        if ((a1 & 0x8000000000000000) != 0)
          goto LABEL_35;
LABEL_31:
        v29 = atomic_load((unint64_t *)(a1 + 8));
        if (v29 < 0)
          v30 = &kCFAllocatorSystemDefault;
        else
          v30 = (const CFAllocatorRef *)(a1 - 16);
        goto LABEL_36;
      }
      v22 = 0;
      if ((a1 & 0x8000000000000000) == 0)
        goto LABEL_31;
    }
LABEL_35:
    v30 = &kCFAllocatorSystemDefault;
LABEL_36:
    v31 = *v30;
    v32 = (uint64_t *)(v22 + 8 * a2);
    v33 = a3;
    do
    {
      v34 = *v32++;
      ((void (*)(CFAllocatorRef, uint64_t))v10->release)(v31, v34);
      --v33;
    }
    while (v33);
    bzero((void *)(v22 + 8 * a2), 8 * a3);
  }
}

void __rangeRelease(uint64_t a1, uint64_t a2)
{
  CFRelease(*(CFTypeRef *)(a2 + 16));
}

void sub_182AE6F40(_Unwind_Exception *a1)
{
  uint64_t v1;

  free(*(void **)(v1 - 160));
  _Unwind_Resume(a1);
}

void sub_182AE8180(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void CFSortIndexes(uint64_t a1, unint64_t a2, char a3, uint64_t a4)
{
  char v6;
  char *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  NSObject *v12;
  char *v13;
  _QWORD block[8];

  block[7] = *MEMORY[0x1E0C80C00];
  if ((uint64_t)a2 >= 1)
  {
    if (a2 >> 60)
      CFSortIndexes_cold_1();
    v6 = a3;
    v7 = (char *)a1;
    if ((a3 & 1) != 0)
    {
      a1 = __CFActiveProcessorCount();
      if (a2 < 0xA0 || (int)a1 < 2)
      {
        v6 = 0;
      }
      else if (a2 > 0x27F || a1 <= 2)
      {
        if (a2 > 0xC7F || a1 <= 4)
        {
          if (a1 <= 8 || a2 >> 7 >= 0x7D)
            a1 = a1;
          else
            a1 = 8;
        }
        else
        {
          a1 = 4;
        }
      }
      else
      {
        a1 = 2;
      }
      if ((int)a1 >= 16)
        v8 = 16;
      else
        v8 = a1;
    }
    else
    {
      v8 = 0;
    }
    if (a2 > 0x10000)
    {
      v12 = dispatch_queue_create("com.apple.NSSortIndexes", MEMORY[0x1E0C80D50]);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __CFSortIndexes_block_invoke;
      block[3] = &__block_descriptor_tmp_9;
      block[4] = ((a2 + 15) >> 3) & 0x1FFFFFFFFFFFFFFELL;
      block[5] = a2;
      block[6] = v7;
      dispatch_apply(8uLL, 0, block);
      dispatch_release(v12);
      if ((v6 & 1) == 0)
      {
LABEL_18:
        MEMORY[0x1E0C80A78](a1, a2);
        v11 = (char *)block - v10;
        if ((uint64_t)a2 > 4096)
        {
          v13 = (char *)malloc_type_malloc(8 * a2, 0x100004000313F17uLL);
          __CFSimpleMergeSort((uint64_t)v7, a2, (uint64_t)v13, a4);
          if (v11 != v13)
            free(v13);
        }
        else
        {
          __CFSimpleMergeSort((uint64_t)v7, a2, (uint64_t)block - v10, a4);
        }
        return;
      }
    }
    else
    {
      v9 = 0;
      do
      {
        *(_QWORD *)&v7[8 * v9] = v9;
        ++v9;
      }
      while (a2 != v9);
      if ((v6 & 1) == 0)
        goto LABEL_18;
    }
    __CFSortIndexesN(v7, a2, v8, a4);
  }
}

uint64_t __CFSimpleMergeSort(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v16;
  unint64_t v17;
  int64_t v18;
  int64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  if (a2 >= 2)
  {
    v5 = a2;
    v6 = (_QWORD *)result;
    if (a2 == 3)
    {
      v9 = *(_QWORD *)result;
      v10 = *(_QWORD *)(result + 8);
      v11 = *(_QWORD *)(result + 16);
      v12 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a4 + 16))(a4, *(_QWORD *)result, v10);
      if (v12 <= 0)
        v13 = v9;
      else
        v13 = v10;
      if (v12 <= 0)
        v9 = v10;
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, v9, v11);
      if (result < 1)
      {
        v14 = v9;
        v9 = v11;
      }
      else
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, v13, v11);
        if (result <= 0)
          v14 = v11;
        else
          v14 = v13;
        if (result > 0)
          v13 = v11;
      }
      *v6 = v13;
      v6[1] = v14;
      v6[2] = v9;
    }
    else if (a2 == 2)
    {
      v7 = *(_QWORD *)result;
      v8 = *(_QWORD *)(result + 8);
      result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a4 + 16))(a4, *(_QWORD *)result, v8);
      if (result >= 1)
      {
        *v6 = v8;
        v6[1] = v7;
      }
    }
    else
    {
      v16 = (unint64_t)a2 >> 1;
      __CFSimpleMergeSort(result, (unint64_t)a2 >> 1, a3, a4);
      result = __CFSimpleMergeSort(&v6[v16], v5 - (v5 >> 1), a3, a4);
      if ((uint64_t)(v5 - (v5 >> 1)) >= 1)
      {
        if (v5 < 0x11
          || (result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a4 + 16))(a4, v6[v16 - 1], v6[v16]),
              result >= 1))
        {
          v17 = 0;
          v18 = 0;
          v19 = v5 >> 1;
          while (v19 < (uint64_t)v5)
          {
            v20 = v6[v17];
            v21 = v6[v19];
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16))(a4, v20, v21);
            if (result >= 1)
              v22 = v21;
            else
              v22 = v20;
            if (result < 1)
              ++v17;
            if (result > 0)
              ++v19;
            *(_QWORD *)(a3 + 8 * v18++) = v22;
            if (v17 >= v16)
            {
              do
              {
                v6[v18 - 1] = *(_QWORD *)(a3 - 8 + 8 * v18);
                --v18;
              }
              while (v18);
              return result;
            }
          }
          if (v18 < (uint64_t)v5)
          {
            v23 = v16;
            do
              v6[--v5] = v6[--v23];
            while (v18 < (uint64_t)v5);
          }
          for (; v18; --v18)
            v6[v18 - 1] = *(_QWORD *)(a3 - 8 + 8 * v18);
        }
      }
    }
  }
  return result;
}

uint64_t __CFArrayCompareValues(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))a3)(*a1, *a2, *(_QWORD *)(a3 + 8));
}

uint64_t __CFRunLoopSourceComparator(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v5;
  double v6;
  unint64_t v7;
  BOOL v8;
  _BOOL8 v9;

  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(_QWORD *)(a2 + 80);
  if (v2 < v3)
    return -1;
  if (v3 < v2)
    return 1;
  v5 = atomic_load((unint64_t *)(a1 + 88));
  v6 = (double)v5;
  v7 = atomic_load((unint64_t *)(a2 + 88));
  v8 = v6 < (double)v7;
  v9 = v6 > (double)v7;
  if (v8)
    return -1;
  else
    return v9;
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return -[__CFDate compare:](theDate, "compare:", otherDate);
}

uint64_t compareHashesAscending(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  v4 = v2 >= v3;
  v5 = v2 != v3;
  if (v4)
    return v5;
  else
    return 0xFFFFFFFFLL;
}

CFDateFormatterRef CFDateFormatterCreateISO8601Formatter(CFAllocatorRef allocator, CFISO8601DateFormatOptions formatOptions)
{
  const __CFString *v4;
  const __CFLocale *v5;
  __CFDateFormatter *CFDateFormatter;
  __CFString *Mutable;
  __CFString *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  int v13;
  int v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const char *v18;
  const char *v19;
  CFIndex Length;
  const char *v21;
  char *cStr;
  char *v24;
  const char *v25;

  v4 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, "en_US_POSIX", 0x8000100u);
  v5 = CFLocaleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4);
  CFDateFormatter = (__CFDateFormatter *)__CreateCFDateFormatter((__objc2_class **)allocator, v5, 0, 0, &__kCFBooleanTrue);
  if (!formatOptions)
    goto LABEL_64;
  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 33);
  v8 = Mutable;
  if ((~(_WORD)formatOptions & 0x773) == 0)
  {
    if ((formatOptions & 0x100) != 0)
      v9 = "yyyy-MM-dd";
    else
      v9 = "yyyyMMdd";
    CFStringAppendCString(Mutable, v9, 0x8000100u);
    if ((formatOptions & 0x80) != 0)
      v10 = " ";
    else
      v10 = "'T'";
    CFStringAppendCString(v8, v10, 0x8000100u);
    if ((formatOptions & 0x200) != 0)
      v11 = "HH:mm:ss";
    else
      v11 = "HHmmss";
    CFStringAppendCString(v8, v11, 0x8000100u);
    if ((formatOptions & 0x800) != 0)
      CFStringAppendCString(v8, ".SSS", 0x8000100u);
    if ((formatOptions & 0x400) != 0)
      v12 = "XXXXX";
    else
      v12 = "XXXX";
    CFStringAppendCString(v8, v12, 0x8000100u);
    goto LABEL_62;
  }
  if ((_DWORD)formatOptions)
  {
    v13 = 0;
    v14 = 0;
    if ((formatOptions & 0x400) != 0)
      v15 = "XXXXX";
    else
      v15 = "XXXX";
    if ((formatOptions & 0x80) != 0)
      v16 = " ";
    else
      v16 = "'T'";
    v17 = "HH:mm:ss";
    if ((formatOptions & 0x200) == 0)
      v17 = "HHmmss";
    cStr = (char *)v16;
    v24 = (char *)v17;
    v18 = "dd";
    if ((formatOptions & 2) == 0)
      v18 = "DDD";
    if ((formatOptions & 4) != 0)
      v18 = "ee";
    v25 = v18;
    if ((formatOptions & 4) != 0)
      v19 = "YYYY";
    else
      v19 = "yyyy";
    do
    {
      Length = CFStringGetLength(v8);
      if (v14 > 15)
      {
        if (v14 != 16)
        {
          if (v14 == 32)
          {
            if ((formatOptions & 0x20) == 0)
              goto LABEL_61;
            if (Length >= 1)
              CFStringAppendCString(v8, cStr, 0x8000100u);
            CFStringAppendCString(v8, v24, 0x8000100u);
            v21 = ".SSS";
            if ((formatOptions & 0x800) == 0)
              goto LABEL_61;
          }
          else
          {
            if (v14 != 64)
              goto LABEL_61;
            v21 = v15;
            if ((formatOptions & 0x40) == 0)
              goto LABEL_61;
          }
          goto LABEL_60;
        }
        if ((formatOptions & 0x10) != 0)
        {
          v21 = v25;
          if ((formatOptions & 0x100) != 0)
          {
            v21 = v25;
            goto LABEL_54;
          }
          goto LABEL_60;
        }
      }
      else
      {
        if (v14 == 1)
        {
          v21 = v19;
          if ((formatOptions & 1) == 0)
            goto LABEL_61;
          goto LABEL_60;
        }
        if (v14 != 2)
        {
          if (v14 != 4 || (formatOptions & 4) == 0)
            goto LABEL_61;
          v21 = "'W'ww";
          if ((formatOptions & 0x100) == 0)
            goto LABEL_60;
LABEL_54:
          if (Length >= 1)
            CFStringAppendCString(v8, "-", 0x8000100u);
LABEL_60:
          CFStringAppendCString(v8, v21, 0x8000100u);
          goto LABEL_61;
        }
        if ((formatOptions & 2) != 0)
        {
          v21 = "MM";
          if ((formatOptions & 0x100) != 0)
            goto LABEL_54;
          goto LABEL_60;
        }
      }
LABEL_61:
      v14 = 1 << v13++;
    }
    while (v14 < formatOptions);
  }
LABEL_62:
  if (v8)
  {
    CFDateFormatterSetFormat(CFDateFormatter, v8);
    CFRelease(v8);
  }
LABEL_64:
  CFRelease(v4);
  CFRelease(v5);
  return CFDateFormatter;
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
  char v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  size_t v15;

  v3 = atomic_load((unint64_t *)&theString->info);
  if ((v3 & 1) != 0)
  {
    v12 = *(_QWORD *)&encoding;
    v15 = strlen(cStr);
    __CFStringAppendBytes((unint64_t *)theString, (unsigned __int8 *)cStr, v15, v12);
  }
  else
  {
    v4 = _CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      CFStringAppendCString_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  if (localeIdentifier)
    return (CFLocaleRef)+[NSLocale _newLocaleWithIdentifier:](NSLocale, "_newLocaleWithIdentifier:", localeIdentifier);
  else
    return 0;
}

uint64_t __CreateCFDateFormatter(__objc2_class **a1, const __CFLocale *a2, unint64_t a3, unint64_t a4, __objc2_class **a5)
{
  uint64_t Instance;
  uint64_t v10;
  CFLocaleRef System;
  __CFCalendar *v12;
  CFTypeRef Value;

  if (!a1)
  {
    a1 = (__objc2_class **)_CFGetTSD(1u);
    if (!a1)
      a1 = &__kCFAllocatorSystemDefault;
  }
  Instance = _CFRuntimeCreateInstance(a1, 0x38uLL, 512, 0);
  v10 = Instance;
  if (Instance)
  {
    *(_QWORD *)(Instance + 32) = a4;
    *(_QWORD *)(Instance + 40) = a3;
    if (a3 >= 5)
      *(_QWORD *)(Instance + 40) = 2;
    if (a4 >= 5)
      *(_QWORD *)(Instance + 32) = 2;
    if (a2)
      System = a2;
    else
      System = CFLocaleGetSystem();
    *(_QWORD *)(v10 + 24) = CFRetain(System);
    if (&__kCFBooleanTrue == a5)
    {
      v12 = CFCalendarCreateWithIdentifier((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("gregorian"));
      CFCalendarSetFirstWeekday(v12, 2);
      CFCalendarSetMinimumDaysInFirstWeek(v12, 4);
      *(_QWORD *)(v10 + 96) = v12;
    }
    *(_QWORD *)(v10 + 88) = CFTimeZoneCopyDefault();
    Value = CFLocaleGetValue(*(CFLocaleRef *)(v10 + 24), CFSTR("calendar"));
    if (Value && CFEqual(Value, CFSTR("gregorian")))
      *(_QWORD *)(v10 + 112) = CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, -1609459200.0);
    __ResetUDateFormat(v10, 0);
    if (!*(_QWORD *)(v10 + 16))
    {
      CFRelease((CFTypeRef)v10);
      return 0;
    }
  }
  return v10;
}

CFTimeZoneRef CFTimeZoneCopyDefault(void)
{
  void *v0;
  NSTimeZone *v1;
  const __CFTimeZone *v2;

  v0 = (void *)_CFAutoreleasePoolPush();
  v1 = +[NSTimeZone defaultTimeZone](NSTimeZone, "defaultTimeZone");
  if (v1)
    v2 = (const __CFTimeZone *)CFRetain(v1);
  else
    v2 = 0;
  _CFAutoreleasePoolPop(v0);
  return v2;
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
  unint64_t v4;
  const __CFString *ForcedString;
  CFIndex Length;
  uint64_t v7;
  CFIndex v8;
  unint64_t v9;
  char *v10;
  UChar *CharactersPtr;
  const void *v12;
  const __CFAllocator *v13;
  _QWORD v14[2];
  CFRange v15;

  v14[1] = *MEMORY[0x1E0C80C00];
  v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v4);
  ForcedString = (const __CFString *)__CFDateFormatterCreateForcedString(formatter, formatString);
  Length = CFStringGetLength(ForcedString);
  if (*((const __CFString **)formatter + 6) != ForcedString)
  {
    v8 = Length;
    if (Length <= 1024)
    {
      if (*((__objc2_class ***)formatter + 10) != &__kCFBooleanTrue
        && *((__objc2_class ***)formatter + 9) == &__kCFBooleanTrue)
      {
        __ResetUDateFormat((uint64_t)formatter, 1);
      }
      v9 = 2 * v8;
      if ((unint64_t)(2 * v8) < 0x101)
      {
        if (v8 < 1)
        {
          v10 = 0;
        }
        else
        {
          MEMORY[0x1E0C80A78](Length, v7);
          v10 = (char *)v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
          bzero(v10, 2 * v8);
        }
      }
      else
      {
        v10 = (char *)malloc_type_malloc(2 * v8, 0x1000040BDFB0063uLL);
      }
      CharactersPtr = (UChar *)CFStringGetCharactersPtr(ForcedString);
      if (!CharactersPtr)
      {
        v15.location = 0;
        v15.length = v8;
        CFStringGetCharacters(ForcedString, v15, (UniChar *)v10);
        CharactersPtr = (UChar *)v10;
      }
      __cficu_udat_applyPattern(*((_QWORD *)formatter + 2), 0, CharactersPtr, v8);
      v12 = (const void *)*((_QWORD *)formatter + 6);
      if (v12)
        CFRelease(v12);
      v13 = CFGetAllocator(formatter);
      *((_QWORD *)formatter + 6) = CFStringCreateCopy(v13, ForcedString);
      *((_QWORD *)formatter + 10) = &__kCFBooleanTrue;
      if (v9 >= 0x101)
        free(v10);
    }
  }
  if (ForcedString)
    CFRelease(ForcedString);
}

uint64_t _CFOSLog()
{
  if (_CFOSLog_onceToken != -1)
    dispatch_once(&_CFOSLog_onceToken, &__block_literal_global_24);
  return _CFOSLog_logger;
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return (CFCalendarRef)+[NSCalendar _newCalendarWithIdentifier:](NSCalendar, "_newCalendarWithIdentifier:", identifier);
}

void CFCalendarSetMinimumDaysInFirstWeek(CFCalendarRef calendar, CFIndex mwd)
{
  -[__CFCalendar setMinimumDaysInFirstWeek:](calendar, "setMinimumDaysInFirstWeek:", mwd);
}

void CFCalendarSetFirstWeekday(CFCalendarRef calendar, CFIndex wkdy)
{
  -[__CFCalendar setFirstWeekday:](calendar, "setFirstWeekday:", wkdy);
}

Boolean CFCalendarGetComponentDifference(CFCalendarRef calendar, CFAbsoluteTime startingAT, CFAbsoluteTime resultAT, CFOptionFlags options, const char *componentDesc, ...)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE *i;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  void *v17;
  unsigned __int8 *v18;
  _DWORD *v19;
  int v20;
  int v21;
  va_list v23;
  uint64_t vars0;
  _BYTE *vars8;
  va_list va;

  va_start(va, componentDesc);
  vars0 = va_arg(va, _QWORD);
  v5 = vars0;
  vars8 = va_arg(va, _BYTE *);
  v6 = 0;
  va_copy(v23, va);
  for (i = vars8; ; ++i)
  {
    v8 = *i;
    if (v8 <= 0x63)
      break;
    v9 = v6 | 0x80;
    v10 = v6 | 0x2100;
    v11 = v6 | 4;
    if (v8 != 121)
      v11 = v6;
    if (v8 != 119)
      v10 = v11;
    if (v8 != 115)
      v9 = v10;
    v12 = v6 | 0x10;
    v13 = v6 | 8;
    v14 = v6 | 0x40;
    if (v8 != 109)
      v14 = v6;
    if (v8 != 108)
      v13 = v14;
    if (v8 != 100)
      v12 = v13;
    if (*i <= 0x72u)
      v6 = v12;
    else
      v6 = v9;
LABEL_20:
    ;
  }
  switch(*i)
  {
    case 'D':
      v6 |= 0x10000uLL;
      goto LABEL_20;
    case 'E':
      v6 |= 0x200uLL;
      goto LABEL_20;
    case 'F':
      v6 |= 0x400uLL;
      goto LABEL_20;
    case 'G':
      v6 |= 2uLL;
      goto LABEL_20;
    case 'H':
      v6 |= 0x20uLL;
      goto LABEL_20;
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'N':
    case 'O':
    case 'P':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'X':
      goto LABEL_20;
    case 'M':
      v6 |= 8uLL;
      goto LABEL_20;
    case 'Q':
      v6 |= 0x800uLL;
      goto LABEL_20;
    case 'W':
      v6 |= 0x1000uLL;
      goto LABEL_20;
    case 'Y':
      v6 |= 0x4000uLL;
      goto LABEL_20;
    default:
      if (v8 == 35)
      {
        v6 |= 0x8000uLL;
        goto LABEL_20;
      }
      if (*i)
        goto LABEL_20;
      v15 = -[__CFCalendar components:fromDate:toDate:options:](calendar, "components:fromDate:toDate:options:", v6, +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", startingAT), +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", resultAT), v5);
      if (!v15)
        return v15;
      v16 = *vars8;
      if (*vars8)
      {
        v17 = (void *)v15;
        v18 = vars8 + 1;
        do
        {
          v19 = va_arg(v23, _DWORD *);
          if (v16 <= 99)
          {
            switch(v16)
            {
              case 'D':
                v20 = objc_msgSend(v17, "dayOfYear");
                goto LABEL_62;
              case 'E':
                v20 = objc_msgSend(v17, "weekday");
                goto LABEL_62;
              case 'F':
                v20 = objc_msgSend(v17, "weekdayOrdinal");
                goto LABEL_62;
              case 'G':
                v20 = objc_msgSend(v17, "era");
                goto LABEL_62;
              case 'H':
                v20 = objc_msgSend(v17, "hour");
                goto LABEL_62;
              case 'I':
              case 'J':
              case 'K':
              case 'L':
              case 'N':
              case 'O':
              case 'P':
              case 'R':
              case 'S':
              case 'T':
              case 'U':
              case 'V':
              case 'X':
                goto LABEL_63;
              case 'M':
                v20 = objc_msgSend(v17, "month");
                goto LABEL_62;
              case 'Q':
                v20 = objc_msgSend(v17, "quarter");
                goto LABEL_62;
              case 'W':
                v20 = objc_msgSend(v17, "weekOfMonth");
                goto LABEL_62;
              case 'Y':
                v20 = objc_msgSend(v17, "yearForWeekOfYear");
                goto LABEL_62;
              default:
                if (v16 != 35)
                  goto LABEL_63;
                v20 = objc_msgSend(v17, "nanosecond");
                break;
            }
            goto LABEL_62;
          }
          if (v16 > 114)
          {
            switch(v16)
            {
              case 's':
                v20 = objc_msgSend(v17, "second");
                goto LABEL_62;
              case 'w':
                *v19 = objc_msgSend(v17, "weekOfYear");
                if (objc_msgSend(v17, "weekOfYear") == 0x7FFFFFFFFFFFFFFFLL)
                {
                  v20 = objc_msgSend(v17, "week");
                  goto LABEL_62;
                }
                break;
              case 'y':
                v20 = objc_msgSend(v17, "year");
                goto LABEL_62;
            }
          }
          else
          {
            switch(v16)
            {
              case 'd':
                v20 = objc_msgSend(v17, "day");
                goto LABEL_62;
              case 'l':
                v20 = objc_msgSend(v17, "isLeapMonth");
                goto LABEL_62;
              case 'm':
                v20 = objc_msgSend(v17, "minute");
LABEL_62:
                *v19 = v20;
                break;
            }
          }
LABEL_63:
          v21 = *v18++;
          v16 = v21;
        }
        while (v21);
      }
      LOBYTE(v15) = 1;
      return v15;
  }
}

CFAbsoluteTime CFAbsoluteTimeAddGregorianUnits(CFAbsoluteTime at, CFTimeZoneRef tz, CFGregorianUnits *units)
{
  CFGregorianDate GregorianDate;
  CFAbsoluteTime result;
  unsigned int v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  BOOL v16;
  char v17;
  unsigned __int8 v18;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  BOOL v23;
  char v24;
  BOOL v25;
  uint64_t v26;
  int v27;
  int v28;
  BOOL v29;
  BOOL v30;

  GregorianDate = CFAbsoluteTimeGetGregorianDate(at, tz);
  v7 = units->years + GregorianDate.year;
  v8 = units->months + ((int)(*(_QWORD *)&GregorianDate.year >> 8) >> 24);
  if (v8 >= 13)
  {
    if (v8 >= 24)
      v9 = 24;
    else
      v9 = units->months + ((int)(*(_QWORD *)&GregorianDate.year >> 8) >> 24);
    v10 = (v8 - v9 + 11) / 0xCu;
    v8 = v8 - 12 * v10 - 12;
    v7 += v10 + 1;
  }
  v11 = (int)(*(_QWORD *)&GregorianDate.year >> 16) >> 24;
  if (v8 <= 0)
  {
    if (v8 <= -11)
      v12 = -11;
    else
      v12 = v8;
    if (v8 >= -11)
      v13 = v8;
    else
      v13 = v8 + 1;
    v14 = (v12 - v13) / 0xCu;
    if (v8 < -11)
      ++v14;
    v8 += 12 * v14 + 12;
    v7 += ~v14;
  }
  v15 = (int)(v7 - 2000) % 400;
  if (v15 < 0)
    v15 = -v15;
  v16 = v15 != 300;
  if (v15 == 200)
    v16 = 0;
  if (v15 == 100)
    v16 = 0;
  if ((v15 & 3) != 0)
    v16 = 0;
  v17 = daysInMonth[v8];
  if (v8 != 2)
    v16 = 0;
  v18 = v17 + v16;
  v19 = (v17 + v16);
  if (v11 >= v18)
    v11 = v19;
  v20 = v11 + units->days;
  while (v20 > v18)
  {
    if (v8 <= 11)
    {
      ++v8;
    }
    else
    {
      ++v7;
      v8 = 1;
    }
    v21 = (int)(v7 - 2000) % 400;
    if (v21 < 0)
      v21 = -v21;
    v22 = v21 != 300;
    if (v21 == 200)
      v22 = 0;
    if (v21 == 100)
      v22 = 0;
    v23 = (v21 & 3) == 0 && v22;
    if (v8 >= 0x10u)
      goto LABEL_66;
    v24 = daysInMonth[v8];
    v20 -= v19;
    v25 = v8 == 2 && v23;
    v18 = v24 + v25;
    v19 = (v24 + v25);
  }
  if (v20 <= 0)
  {
    while (1)
    {
      v27 = v8 < 2;
      if (v8 >= 2)
        --v8;
      else
        v8 = 12;
      v7 -= v27;
      v28 = (int)(v7 - 2000) % 400;
      if (v28 < 0)
        v28 = -v28;
      v29 = v28 != 300;
      if (v28 == 200)
        v29 = 0;
      if (v28 == 100)
        v29 = 0;
      if ((v28 & 3) != 0)
        v29 = 0;
      if (v8 >= 0x10u)
        break;
      v26 = v8;
      v30 = v8 == 2 && v29;
      v20 += (daysInMonth[v8] + v30);
      if (v20 >= 1)
        goto LABEL_65;
    }
LABEL_66:
    __break(1u);
    return result;
  }
  v26 = v8;
LABEL_65:
  *(_QWORD *)&GregorianDate.year = *(_QWORD *)&GregorianDate.year & 0xFFFF000000000000 | ((unint64_t)v20 << 40) | (v26 << 32) | v7;
  return units->seconds
       + CFGregorianDateGetAbsoluteTime(GregorianDate, tz)
       + (double)units->hours * 3600.0
       + (double)units->minutes * 60.0;
}

CFGregorianDate CFAbsoluteTimeGetGregorianDate(CFAbsoluteTime at, CFTimeZoneRef tz)
{
  double SecondsFromGMT;
  int v4;
  double v12;
  int32x2_t v13;
  int8x8_t v14;
  uint64x2_t v15;
  int64x2_t v16;
  unint64_t v17;
  double v18;
  double v19;
  __int16 v20;
  uint64_t v21[2];
  CFGregorianDate result;

  v21[1] = *MEMORY[0x1E0C80C00];
  SecondsFromGMT = 0.0;
  if (tz)
    SecondsFromGMT = CFTimeZoneGetSecondsFromGMT(tz, at);
  v21[0] = 0;
  v20 = 0;
  v19 = SecondsFromGMT + at;
  __CFYMDFromAbsolute(vcvtmd_s64_f64((SecondsFromGMT + at) / 86400.0), v21, (unint64_t)&v20 + 1, (unint64_t)&v20);
  if (v21[0] >= 2147481646)
    v4 = 2147481646;
  else
    v4 = v21[0];
  _Q1 = vrndmq_f64(vdivq_f64((float64x2_t)vdupq_lane_s64(*(uint64_t *)&v19, 0), (float64x2_t)xmmword_182C87E10));
  _D0 = 0x404E000000000000;
  __asm { FMLS            D2, D0, V1.D[0] }
  v12 = _D2 + 60.0;
  if (_D2 >= 0.0)
    v12 = _D2;
  if (v12 == 0.0)
    v12 = 0.0;
  v13 = vcvt_s32_f32(vcvt_f32_f64(vrndmq_f64(vmlsq_f64(_Q1, (float64x2_t)xmmword_182C87E20, vrndmq_f64(vdivq_f64(_Q1, (float64x2_t)xmmword_182C87E20))))));
  v14 = vand_s8(vbsl_s8((int8x8_t)vcltz_s32(v13), (int8x8_t)vadd_s32(v13, (int32x2_t)0x180000003CLL), (int8x8_t)v13), (int8x8_t)0xFF000000FFLL);
  v15.i64[0] = v14.u32[0];
  v15.i64[1] = v14.u32[1];
  v16 = (int64x2_t)vshlq_u64(v15, (uint64x2_t)xmmword_182C87E30);
  v17 = vorrq_s8((int8x16_t)v16, (int8x16_t)vdupq_laneq_s64(v16, 1)).u64[0] | ((unint64_t)v20 << 40) | ((unint64_t)HIBYTE(v20) << 32) | (v4 + 2001);
  v18 = v12;
  result.second = v18;
  result.year = v17;
  result.month = BYTE4(v17);
  result.day = BYTE5(v17);
  result.hour = BYTE6(v17);
  result.minute = HIBYTE(v17);
  return result;
}

CFTimeInterval CFTimeZoneGetSecondsFromGMT(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  void *v4;
  CFTimeInterval v5;

  v4 = (void *)_CFAutoreleasePoolPush();
  v5 = (double)-[__CFTimeZone secondsFromGMTForDate:](tz, "secondsFromGMTForDate:", +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", at));
  _CFAutoreleasePoolPop(v4);
  return v5;
}

BOOL CFDateComponentsIsValidDateInCalendar(_QWORD *a1, void *a2)
{
  unint64_t v3;
  void *Copy;
  id DateFromComponents;
  _QWORD *DateComponentsFromDate;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _BOOL8 v24;

  if (!a1)
    CFDateComponentsIsValidDateInCalendar_cold_1();
  if (!a2)
    CFDateComponentsIsValidDateInCalendar_cold_2();
  v3 = a1[19];
  if (v3 == 0x7FFFFFFFFFFFFFFFLL || v3 <= 0x3B9AC9FF)
  {
    Copy = (void *)_CFCalendarCreateCopy((uint64_t)&__kCFAllocatorSystemDefault, a2);
    if (v3 - 1 >= 0x7FFFFFFFFFFFFFFELL)
    {
      DateFromComponents = CFCalendarCreateDateFromComponents((uint64_t)&__kCFAllocatorSystemDefault, Copy, (uint64_t)a1);
      if (DateFromComponents)
        goto LABEL_9;
    }
    else
    {
      a1[19] = 0;
      DateFromComponents = CFCalendarCreateDateFromComponents((uint64_t)&__kCFAllocatorSystemDefault, Copy, (uint64_t)a1);
      a1[19] = v3;
      if (DateFromComponents)
      {
LABEL_9:
        DateComponentsFromDate = CFCalendarCreateDateComponentsFromDate((uint64_t)&__kCFAllocatorSystemDefault, Copy);
        v8 = DateComponentsFromDate;
        v9 = a1[4];
        if (v9 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[4] != v9)
          goto LABEL_40;
        v10 = a1[5];
        if (v10 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[5] != v10)
          goto LABEL_40;
        v11 = a1[6];
        if (v11 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[6] != v11)
          goto LABEL_40;
        v12 = a1[7];
        if (v12 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[7] != v12)
          goto LABEL_40;
        v13 = a1[8];
        if (v13 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[8] != v13)
          goto LABEL_40;
        v14 = a1[9];
        if (v14 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[9] != v14)
          goto LABEL_40;
        v15 = a1[10];
        if (v15 != 0x7FFFFFFFFFFFFFFFLL && DateComponentsFromDate[10] != v15)
          goto LABEL_40;
        if (((v16 = a1[11], v16 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[11] == v16)
          && ((v17 = a1[13], v17 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[13] == v17)
          && ((v18 = a1[14], v18 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[14] == v18)
          && ((v19 = a1[15], v19 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[15] == v19)
          && ((v20 = a1[16], v20 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[16] == v20)
          && ((v21 = a1[17], v21 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[17] == v21)
          && ((v22 = a1[20], v22 == 0x7FFFFFFFFFFFFFFFLL) || DateComponentsFromDate[20] == v22))
        {
          v23 = a1[18];
          v24 = v23 == 0x7FFFFFFFFFFFFFFFLL || DateComponentsFromDate[18] == v23;
        }
        else
        {
LABEL_40:
          v24 = 0;
        }
        CFRelease(DateFromComponents);
        CFRelease(v8);
        goto LABEL_44;
      }
    }
    v24 = 1;
LABEL_44:
    CFRelease(Copy);
    return v24;
  }
  return 0;
}

CFTypeRef CFCalendarCreateDateComponentsFromDate(uint64_t a1, void *a2)
{
  return CFRetain((CFTypeRef)objc_msgSend((id)objc_msgSend(a2, "components:fromDate:"), "_dateComponents"));
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  uint64_t v3;
  _BYTE *i;
  uint64_t v5;
  int v6;
  void *v7;
  unsigned __int8 *v8;
  _DWORD *v9;
  int v10;
  int v11;
  va_list v13;
  _BYTE *vars8;
  va_list va;

  va_start(va, componentDesc);
  vars8 = va_arg(va, _BYTE *);
  v3 = 0;
  va_copy(v13, va);
  for (i = vars8; *i > 0x6Bu; ++i)
  {
    switch(*i)
    {
      case 'l':
LABEL_7:
        v3 |= 8uLL;
        break;
      case 'm':
        v3 |= 0x40uLL;
        break;
      case 'r':
      case 'y':
LABEL_6:
        v3 |= 4uLL;
        break;
      case 's':
        v3 |= 0x80uLL;
        break;
      case 'w':
LABEL_8:
        v3 |= 0x2100uLL;
        break;
      default:
        continue;
    }
LABEL_22:
    ;
  }
  switch(*i)
  {
    case 'D':
      v3 |= 0x10000uLL;
      goto LABEL_22;
    case 'E':
    case 'c':
      v3 |= 0x200uLL;
      goto LABEL_22;
    case 'F':
      v3 |= 0x400uLL;
      goto LABEL_22;
    case 'G':
      v3 |= 2uLL;
      goto LABEL_22;
    case 'H':
      v3 |= 0x20uLL;
      goto LABEL_22;
    case 'I':
    case 'J':
    case 'K':
    case 'N':
    case 'O':
    case 'P':
    case 'R':
    case 'S':
    case 'T':
    case 'V':
    case 'X':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '_':
    case 'a':
    case 'b':
      goto LABEL_22;
    case 'L':
    case 'M':
      goto LABEL_7;
    case 'Q':
      v3 |= 0x800uLL;
      goto LABEL_22;
    case 'U':
      goto LABEL_6;
    case 'W':
      v3 |= 0x1000uLL;
      goto LABEL_22;
    case 'Y':
      v3 |= 0x4000uLL;
      goto LABEL_22;
    case '^':
      goto LABEL_8;
    case 'd':
      v3 |= 0x10uLL;
      goto LABEL_22;
    default:
      if (*i == 35)
      {
        v3 |= 0x8000uLL;
        goto LABEL_22;
      }
      if (*i)
        goto LABEL_22;
      v5 = -[__CFCalendar components:fromDate:](calendar, "components:fromDate:", v3, +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", at));
      if (v5)
      {
        v6 = *vars8;
        if (*vars8)
        {
          v7 = (void *)v5;
          v8 = vars8 + 1;
          while (2)
          {
            v9 = va_arg(v13, _DWORD *);
            switch(v6)
            {
              case 'D':
                v10 = objc_msgSend(v7, "dayOfYear");
                goto LABEL_46;
              case 'E':
              case 'c':
                v10 = objc_msgSend(v7, "weekday");
                goto LABEL_46;
              case 'F':
                v10 = objc_msgSend(v7, "weekdayOrdinal");
                goto LABEL_46;
              case 'G':
                v10 = objc_msgSend(v7, "era");
                goto LABEL_46;
              case 'H':
                v10 = objc_msgSend(v7, "hour");
                goto LABEL_46;
              case 'I':
              case 'J':
              case 'K':
              case 'N':
              case 'O':
              case 'P':
              case 'R':
              case 'S':
              case 'T':
              case 'V':
              case 'X':
              case 'Z':
              case '[':
              case '\\':
              case ']':
              case '_':
              case 'a':
              case 'b':
                goto LABEL_47;
              case 'L':
              case 'M':
                v10 = objc_msgSend(v7, "month");
                goto LABEL_46;
              case 'Q':
                v10 = objc_msgSend(v7, "quarter");
                goto LABEL_46;
              case 'U':
LABEL_29:
                v10 = objc_msgSend(v7, "year", v13);
                goto LABEL_46;
              case 'W':
                v10 = objc_msgSend(v7, "weekOfMonth");
                goto LABEL_46;
              case 'Y':
                v10 = objc_msgSend(v7, "yearForWeekOfYear");
                goto LABEL_46;
              case '^':
LABEL_31:
                *v9 = objc_msgSend(v7, "weekOfYear", v13);
                if (objc_msgSend(v7, "weekOfYear") != 0x7FFFFFFFFFFFFFFFLL)
                  goto LABEL_47;
                v10 = objc_msgSend(v7, "week");
LABEL_46:
                *v9 = v10;
LABEL_47:
                v11 = *v8++;
                v6 = v11;
                if (!v11)
                  break;
                continue;
              case 'd':
                v10 = objc_msgSend(v7, "day");
                goto LABEL_46;
              default:
                switch(v6)
                {
                  case 'l':
                    v10 = objc_msgSend(v7, "isLeapMonth");
                    goto LABEL_46;
                  case 'm':
                    v10 = objc_msgSend(v7, "minute");
                    goto LABEL_46;
                  case 'n':
                  case 'o':
                  case 'p':
                  case 'q':
                  case 't':
                  case 'u':
                  case 'v':
                  case 'x':
                    goto LABEL_47;
                  case 'r':
                  case 'y':
                    goto LABEL_29;
                  case 's':
                    v10 = objc_msgSend(v7, "second");
                    goto LABEL_46;
                  case 'w':
                    goto LABEL_31;
                  default:
                    if (v6 != 35)
                      goto LABEL_47;
                    v10 = objc_msgSend(v7, "nanosecond");
                    break;
                }
                goto LABEL_46;
            }
            break;
          }
        }
        LOBYTE(v5) = 1;
      }
      return v5;
  }
}

uint64_t CFDateComponentsGetValue(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  if (!a1)
    CFDateComponentsGetValue_cold_1();
  v2 = 0x7FFFFFFFFFFFFFFFLL;
  if (a2 <= 511)
  {
    if (a2 > 31)
    {
      if (a2 > 127)
      {
        if (a2 == 128)
        {
          v3 = a1 + 88;
          return *(_QWORD *)v3;
        }
        if (a2 == 256)
        {
          v3 = a1 + 96;
          return *(_QWORD *)v3;
        }
      }
      else
      {
        if (a2 == 32)
        {
          v3 = a1 + 72;
          return *(_QWORD *)v3;
        }
        if (a2 == 64)
        {
          v3 = a1 + 80;
          return *(_QWORD *)v3;
        }
      }
    }
    else if (a2 > 7)
    {
      if (a2 == 8)
      {
        v3 = a1 + 48;
        return *(_QWORD *)v3;
      }
      if (a2 == 16)
      {
        v3 = a1 + 64;
        return *(_QWORD *)v3;
      }
    }
    else
    {
      if (a2 == 2)
      {
        v3 = a1 + 32;
        return *(_QWORD *)v3;
      }
      if (a2 == 4)
      {
        v3 = a1 + 40;
        return *(_QWORD *)v3;
      }
    }
  }
  else if (a2 < 0x2000)
  {
    if (a2 > 2047)
    {
      if (a2 == 2048)
      {
        v3 = a1 + 120;
        return *(_QWORD *)v3;
      }
      if (a2 == 4096)
      {
        v3 = a1 + 128;
        return *(_QWORD *)v3;
      }
    }
    else
    {
      if (a2 == 512)
      {
        v3 = a1 + 104;
        return *(_QWORD *)v3;
      }
      if (a2 == 1024)
      {
        v3 = a1 + 112;
        return *(_QWORD *)v3;
      }
    }
  }
  else if (a2 < 0x8000)
  {
    if (a2 == 0x2000)
    {
      v3 = a1 + 136;
      return *(_QWORD *)v3;
    }
    if (a2 == 0x4000)
    {
      v3 = a1 + 144;
      return *(_QWORD *)v3;
    }
  }
  else
  {
    switch(a2)
    {
      case 0x8000:
        v3 = a1 + 152;
        return *(_QWORD *)v3;
      case 0x10000:
        v3 = a1 + 160;
        return *(_QWORD *)v3;
      case 0x40000000:
        v3 = a1 + 56;
        return *(_QWORD *)v3;
    }
  }
  return v2;
}

uint64_t __CFYMDFromAbsolute(uint64_t result, uint64_t *a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int16 v10;
  int v11;
  char v12;
  int v13;
  unsigned __int8 v14;
  __int16 v15;
  __int16 v16;
  BOOL v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v4 = 400 * (result / 146097);
  for (i = result % 146097; i < 0; --v4)
  {
    v21 = v4 % 400;
    if (v4 % 400 < 0)
      v21 = -v21;
    if ((v21 & 3) != 0 || v21 == 100 || v21 == 300 || v21 == 200)
      v22 = 365;
    else
      v22 = 366;
    i += v22;
  }
  v6 = (v4 + 1) % 400;
  if (v6 < 0)
    v6 = -v6;
  if ((v6 & 3) != 0 || v6 == 100 || v6 == 300 || v6 == 200)
    v7 = 365;
  else
    v7 = 366;
  if (i >= v7)
  {
    do
    {
      v19 = (v4 + 2) % 400;
      if (v19 < 0)
        v19 = 400 * ((v4 + 2) / 400) - (v4 + 2);
      if ((v19 & 3) != 0 || v19 == 100 || v19 == 300 || v19 == 200)
        v20 = 365;
      else
        v20 = 366;
      i -= v7;
      ++v4;
      v7 = v20;
    }
    while (i >= v20);
  }
  if (a2)
    *a2 = v4;
  if (a3 | a4)
  {
    v8 = (v4 + 1) % 400;
    if (v8 >= 0)
      v9 = v8;
    else
      v9 = -v8;
    if ((v9 & 3) != 0)
    {
      v10 = 0;
    }
    else
    {
      v10 = 0;
      if (v9 != 100 && v9 != 200)
        v10 = v9 != 300;
    }
    v11 = (int)i / 33;
    if (((int)i / 33 + 1) <= 0xCu)
      v12 = 12;
    else
      v12 = (int)i / 33 + 1;
    while (1)
    {
      v13 = v11 + 1;
      if ((v11 + 1) > 0xBu)
        break;
      v14 = v11 + 2;
      v15 = daysBeforeMonth[v14];
      if (v14 > 2u)
        v16 = v10;
      else
        v16 = 0;
      v17 = i < (unsigned __int16)(v15 + v16);
      v11 = v13;
      if (v17)
      {
        if (!a3)
          goto LABEL_26;
        goto LABEL_25;
      }
    }
    LOBYTE(v13) = v12;
    if (a3)
LABEL_25:
      *(_BYTE *)a3 = v13;
LABEL_26:
    if (a4)
    {
      if (v13 > 0xFu)
      {
        v18 = -1;
      }
      else
      {
        if (v13 <= 2u)
          LOBYTE(v10) = 0;
        v18 = daysBeforeMonth[v13] + v10;
      }
      *(_BYTE *)a4 = i - v18 + 1;
    }
  }
  return result;
}

id CFCalendarCreateDateFromComponents(uint64_t a1, void *a2, uint64_t a3)
{
  id v4;
  id v5;

  v4 = -[NSDateComponents _initWithCFDateComponents:]([NSDateComponents alloc], "_initWithCFDateComponents:", a3);
  v5 = (id)objc_msgSend(a2, "dateFromComponents:", v4);

  return v5;
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  void *v6;
  int v7;
  const char *v8;
  int v9;
  int v10;
  void *v11;
  uint64_t v12;
  va_list v14;
  va_list va;

  va_start(va, componentDesc);
  va_copy(v14, va);
  v6 = (void *)objc_msgSend(objc_allocWithZone((Class)NSDateComponents), "init");
  v7 = *(unsigned __int8 *)componentDesc;
  if (*componentDesc)
  {
    v8 = componentDesc + 1;
    do
    {
      v9 = va_arg(v14, _QWORD);
      if (v7 > 99)
      {
        if (v7 > 114)
        {
          switch(v7)
          {
            case 's':
              objc_msgSend(v6, "setSecond:", v9);
              break;
            case 'w':
              objc_msgSend(v6, "setWeekOfYear:", v9);
              objc_msgSend(v6, "setWeek:", v9);
              break;
            case 'y':
              objc_msgSend(v6, "setYear:", v9);
              break;
          }
        }
        else
        {
          switch(v7)
          {
            case 'd':
              objc_msgSend(v6, "setDay:", v9);
              break;
            case 'l':
              objc_msgSend(v6, "setLeapMonth:", v9 != 0);
              break;
            case 'm':
              objc_msgSend(v6, "setMinute:", v9);
              break;
          }
        }
      }
      else
      {
        switch(v7)
        {
          case 'D':
            objc_msgSend(v6, "setDayOfYear:", v9);
            break;
          case 'E':
            objc_msgSend(v6, "setWeekday:", v9);
            break;
          case 'F':
            objc_msgSend(v6, "setWeekdayOrdinal:", v9);
            break;
          case 'G':
            objc_msgSend(v6, "setEra:", v9);
            break;
          case 'H':
            objc_msgSend(v6, "setHour:", v9);
            break;
          case 'I':
          case 'J':
          case 'K':
          case 'L':
          case 'N':
          case 'O':
          case 'P':
          case 'R':
          case 'S':
          case 'T':
          case 'U':
          case 'V':
          case 'X':
            break;
          case 'M':
            objc_msgSend(v6, "setMonth:", v9);
            break;
          case 'Q':
            objc_msgSend(v6, "setQuarter:", v9);
            break;
          case 'W':
            objc_msgSend(v6, "setWeekOfMonth:", v9);
            break;
          case 'Y':
            objc_msgSend(v6, "setYearForWeekOfYear:", v9);
            break;
          default:
            if (v7 == 35)
              objc_msgSend(v6, "setNanosecond:", v9);
            break;
        }
      }
      v10 = *(unsigned __int8 *)v8++;
      v7 = v10;
    }
    while (v10);
  }
  v11 = (void *)-[__CFCalendar dateFromComponents:](calendar, "dateFromComponents:", v6, v14);

  if (!v11)
    return 0;
  objc_msgSend(v11, "timeIntervalSinceReferenceDate");
  *(_QWORD *)at = v12;
  return 1;
}

_QWORD *CFDateComponentsSetValue(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;

  if (!result)
    CFDateComponentsSetValue_cold_1();
  if (a2 <= 511)
  {
    if (a2 > 31)
    {
      if (a2 > 127)
      {
        if (a2 == 128)
        {
          v3 = result + 11;
        }
        else
        {
          if (a2 != 256)
            return result;
          v3 = result + 12;
        }
      }
      else if (a2 == 32)
      {
        v3 = result + 9;
      }
      else
      {
        if (a2 != 64)
          return result;
        v3 = result + 10;
      }
    }
    else if (a2 > 7)
    {
      if (a2 == 8)
      {
        v3 = result + 6;
      }
      else
      {
        if (a2 != 16)
          return result;
        v3 = result + 8;
      }
    }
    else if (a2 == 2)
    {
      v3 = result + 4;
    }
    else
    {
      if (a2 != 4)
        return result;
      v3 = result + 5;
    }
  }
  else if (a2 < 0x2000)
  {
    if (a2 > 2047)
    {
      if (a2 == 2048)
      {
        v3 = result + 15;
      }
      else
      {
        if (a2 != 4096)
          return result;
        v3 = result + 16;
      }
    }
    else if (a2 == 512)
    {
      v3 = result + 13;
    }
    else
    {
      if (a2 != 1024)
        return result;
      v3 = result + 14;
    }
  }
  else if (a2 < 0x8000)
  {
    if (a2 == 0x2000)
    {
      v3 = result + 17;
    }
    else
    {
      if (a2 != 0x4000)
        return result;
      v3 = result + 18;
    }
  }
  else
  {
    switch(a2)
    {
      case 0x8000:
        v3 = result + 19;
        break;
      case 0x10000:
        v3 = result + 20;
        break;
      case 0x40000000:
        v3 = result + 7;
        break;
      default:
        return result;
    }
  }
  *v3 = a3;
  return result;
}

int64x2_t CFDateComponentsCreate(__objc2_class **Default)
{
  int64x2_t *Instance;
  int64x2_t result;

  if (!Default)
    Default = (__objc2_class **)CFAllocatorGetDefault();
  Instance = (int64x2_t *)_CFRuntimeCreateInstance(Default, 0x42uLL, 152, 0);
  if (Instance)
  {
    Instance[1].i64[0] = 0;
    Instance[1].i64[1] = 0;
    result = vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL);
    Instance[2] = result;
    Instance[3] = result;
    Instance[4] = result;
    Instance[5] = result;
    Instance[6] = result;
    Instance[7] = result;
    Instance[10].i64[0] = 0x7FFFFFFFFFFFFFFFLL;
    Instance[8] = result;
    Instance[9] = result;
  }
  return result;
}

uint64_t CFDateComponentsCreateCopy(__objc2_class **a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  const void *v6;
  CFTypeRef v7;
  const void *v8;

  CFDateComponentsCreate(a1);
  if (!v3)
    CFDateComponentsCreateCopy_cold_1();
  v4 = v3;
  v5 = (void *)CFDateComponentsCopyCalendar(a2);
  if (v5)
  {
    v6 = v5;
    CFDateComponentsSetCalendar(v4, v5);
    CFRelease(v6);
  }
  v7 = CFDateComponentsCopyTimeZone(a2);
  if (v7)
  {
    v8 = v7;
    CFDateComponentsSetTimeZone(v4, v7);
    CFRelease(v8);
  }
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v4 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v4 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v4 + 80) = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v4 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(v4 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v4 + 128) = *(_OWORD *)(a2 + 128);
  *(_QWORD *)(v4 + 160) = *(_QWORD *)(a2 + 160);
  *(_OWORD *)(v4 + 144) = *(_OWORD *)(a2 + 144);
  return v4;
}

CFTypeRef CFDateComponentsCopyCalendar(uint64_t a1)
{
  CFTypeRef result;

  if (!a1)
    CFDateComponentsCopyCalendar_cold_1();
  result = *(CFTypeRef *)(a1 + 16);
  if (result)
    return CFRetain(result);
  return result;
}

CFTypeRef CFDateComponentsCopyTimeZone(uint64_t a1)
{
  CFTypeRef result;

  if (!a1)
    CFDateComponentsCopyTimeZone_cold_1();
  result = *(CFTypeRef *)(a1 + 24);
  if (result)
    return CFRetain(result);
  return result;
}

void CFDateComponentsSetTimeZone(uint64_t a1, CFTypeRef cf)
{
  const void *v4;
  __CFCalendar *v5;

  if (!a1)
    CFDateComponentsSetTimeZone_cold_1();
  v4 = *(const void **)(a1 + 24);
  if (cf && v4)
  {
    if (CFEqual(v4, cf))
      return;
    v4 = *(const void **)(a1 + 24);
  }
  else if (!v4)
  {
    goto LABEL_8;
  }
  CFRelease(v4);
  *(_QWORD *)(a1 + 24) = 0;
LABEL_8:
  if (cf)
  {
    *(_QWORD *)(a1 + 24) = CFRetain(cf);
    v5 = *(__CFCalendar **)(a1 + 16);
    if (v5)
      CFCalendarSetTimeZone(v5, (CFTimeZoneRef)cf);
  }
}

double decodeTaggedTimeInterval(unint64_t a1)
{
  uint64_t v1;

  if (!a1)
    return 0.0;
  if (a1 == -1)
  {
    v1 = 0x8000000000000000;
  }
  else
  {
    if (a1 >> 60)
      decodeTaggedTimeInterval_cold_1();
    v1 = a1 & 0xFFFFFFFFFFFFFLL | (a1 >> 59 << 63) | (((uint64_t)(32 * a1) >> 57 << 52) + 0x3EF0000000000000);
  }
  return *(double *)&v1;
}

CFBit CFBitVectorGetBitAtIndex(CFBitVectorRef bv, CFIndex idx)
{
  return (*(unsigned __int8 *)(*((_QWORD *)bv + 4) + idx / 8) >> (~(_BYTE)idx & 7)) & 1;
}

NSSet *mdict_keysOfEntriesWithOptionsPassingTest(uint64_t *a1, char a2, uint64_t a3)
{
  unint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  NSSet *v9;
  size_t v10;
  void *v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  char v16;
  _QWORD v17[9];
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  v5 = a1[1];
  v7 = *(unsigned int *)((char *)__NSDictionarySizes_0 + ((v5 >> 55) & 0x1F8));
  v8 = *a1 + 8 * v7;
  v9 = +[NSSet set](NSMutableSet, "set");
  v18 = 0;
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3221225472;
  v17[2] = __mdict_keysOfEntriesWithOptionsPassingTest_block_invoke;
  v17[3] = &unk_1E1337558;
  v17[6] = v6;
  v17[7] = v8;
  v17[8] = &v18;
  v17[4] = v9;
  v17[5] = a3;
  if ((__NSCollectionHandleConcurrentEnumerationIfSpecified(a2, 0, v7, (uint64_t)v17) & 1) == 0)
  {
    v16 = 0;
    if (v5 >> 58)
    {
      v10 = 0;
      do
      {
        v11 = *(void **)(v6 + 8 * v10);
        if (v11)
          v12 = v11 == &___NSDictionaryM_DeletedMarker;
        else
          v12 = 1;
        if (!v12)
        {
          v13 = *(_QWORD *)(v8 + 8 * v10);
          v14 = (void *)_CFAutoreleasePoolPush();
          if ((*(unsigned int (**)(uint64_t, void *, uint64_t, char *))(a3 + 16))(a3, v11, v13, &v16))
            -[NSSet addObject:](v9, "addObject:", v11);
          _CFAutoreleasePoolPop(v14);
          if (v16)
            break;
        }
        ++v10;
      }
      while (v10 < v7);
    }
    return (NSSet *)(id)-[NSSet copy](v9, "copy");
  }
  return v9;
}

void __NSSetEnumerate(void *a1, char a2, uint64_t a3)
{
  uint64_t v6;
  void *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  size_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD v20[6];
  _QWORD block[9];
  _QWORD v22[3];
  char v23;
  _BYTE v24[128];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend(a1, "count"))
  {
    if ((a2 & 1) != 0)
    {
      v6 = __CFActiveProcessorCount();
      if (v6 < 2)
        a2 = 0;
    }
    else
    {
      v6 = 1;
    }
    if ((a2 & 1) != 0)
    {
      v8 = objc_msgSend(a1, "count");
      v9 = 32;
      v10 = 16;
      v11 = 4;
      if (v8 < 4 * v6)
        v11 = 1;
      if (v8 < 16 * v6)
        v10 = v11;
      if (v8 < 32 * v6)
        v9 = v10;
      if (48 * v6 > v8)
        v12 = v9;
      else
        v12 = 48;
      if (v8 < v6 << 6)
        v13 = v12;
      else
        v13 = 64;
      v14 = (v8 + v13 - 1) / v13;
      v15 = (void *)_CFAutoreleasePoolPush();
      v16 = objc_msgSend(a1, "objectEnumerator");
      v31 = 0u;
      v32 = 0u;
      v30 = 0u;
      v33 = 0;
      v29 = 850045857;
      v22[0] = 0;
      v22[1] = v22;
      v22[2] = 0x2020000000;
      v23 = 0;
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ____NSSetEnumerate_block_invoke;
      block[3] = &unk_1E12E14D0;
      block[6] = v22;
      block[7] = v13;
      block[8] = &v29;
      block[4] = v16;
      block[5] = a3;
      dispatch_apply(v14, 0, block);
      _CFAutoreleasePoolPop(v15);
      _Block_object_dispose(v22, 8);
    }
    else
    {
      v7 = (void *)_CFAutoreleasePoolPush();
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v29 = 0;
        *(_QWORD *)&v30 = &v29;
        *((_QWORD *)&v30 + 1) = 0x2020000000;
        LOBYTE(v31) = 0;
        v20[0] = MEMORY[0x1E0C809B0];
        v20[1] = 3221225472;
        v20[2] = ____NSSetEnumerate_block_invoke_2;
        v20[3] = &unk_1E12E14F8;
        v20[4] = a3;
        v20[5] = &v29;
        CFBasicHashApply((uint64_t)a1, (uint64_t)v20);
        _Block_object_dispose(&v29, 8);
      }
      else
      {
        LOBYTE(v29) = 0;
        v25 = 0u;
        v26 = 0u;
        v27 = 0u;
        v28 = 0u;
        v17 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v25, v24, 16);
        if (v17)
        {
          v18 = *(_QWORD *)v26;
LABEL_24:
          v19 = 0;
          while (1)
          {
            if (*(_QWORD *)v26 != v18)
              objc_enumerationMutation(a1);
            __NSSET_IS_CALLING_OUT_TO_A_BLOCK__(a3);
            if ((_BYTE)v29)
              break;
            if (v17 == ++v19)
            {
              v17 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v25, v24, 16);
              if (v17)
                goto LABEL_24;
              break;
            }
          }
        }
      }
      _CFAutoreleasePoolPop(v7);
    }
  }
}

void sub_182AEE1C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t __NSSET_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

void ___stringTableFromCacheSatisfyingRequest_block_invoke(uint64_t a1, const void *a2)
{
  const __CFDictionary *v4;
  const __CFSet *Value;
  __CFSet *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  const void *v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 40), a2))
  {
    v4 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 48) + 160);
    if (!v4
      || (Value = (const __CFSet *)CFDictionaryGetValue(v4, *(const void **)(a1 + 56))) == 0
      || !CFSetContainsValue(Value, a2))
    {
      v6 = *(__CFSet **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (!v6)
      {
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
        v6 = *(__CFSet **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      }
      CFSetAddValue(v6, a2);
      v7 = _CFBundleLocalizedStringLogger();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v8 = *(_QWORD *)(a1 + 48);
        v9 = *(_QWORD *)(a1 + 56);
        v10 = 138412802;
        v11 = v8;
        v12 = 2112;
        v13 = a2;
        v14 = 2112;
        v15 = v9;
        _os_log_debug_impl(&dword_182A8C000, v7, OS_LOG_TYPE_DEBUG, "Lazy cache miss for bundle: %@ key: %@ table: %@", (uint8_t *)&v10, 0x20u);
      }
    }
  }
}

const void *___dictionaryContainsAllKeysInSet_block_invoke(uint64_t a1, const void *a2, _BYTE *a3)
{
  const void *result;

  result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  if (!result)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    *a3 = 1;
  }
  return result;
}

void ___loadLocTable_block_invoke(uint64_t a1, void *a2)
{
  CFArrayRef v3;
  void *values[3];

  values[2] = *(void **)MEMORY[0x1E0C80C00];
  values[0] = *(void **)(a1 + 32);
  values[1] = a2;
  v3 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 2, &kCFTypeArrayCallBacks);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), v3);
  CFRelease(v3);
}

uint64_t __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(void))(result + 16))();
  return result;
}

void __RELEASE_OBJECTS_IN_THE_SET__(uint64_t a1, int a2)
{
  int *v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  _QWORD *v7;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;

  v2 = &OBJC_IVAR_____NSFrozenSetM_storage;
  if (a2 == 1)
    v2 = &OBJC_IVAR_____NSSetM_storage;
  v3 = a1 + *v2;
  v4 = *(unsigned int *)(v3 + 12);
  v5 = *(unsigned int *)((char *)__NSSetSizes_0 + ((v4 >> 23) & 0x1F8));
  v6 = v4 & 0x3FFFFFF;
  v7 = *(_QWORD **)v3;
  *(_DWORD *)(v3 + 12) = 0;
  *(_QWORD *)v3 = 0;
  if ((v4 & 0x3FFFFFF) != 0 && v4 >> 26 != 0)
  {
    v9 = 0;
    do
    {
      v10 = v7[v9];
      if (v10)
        v11 = v10 == (_QWORD)&___NSSetM_DeletedMarker;
      else
        v11 = 1;
      if (!v11)
      {
        if ((v10 & 0x8000000000000000) == 0)

        --v6;
      }
      if (!v6)
        break;
      ++v9;
    }
    while (v9 < v5);
  }
  free(v7);
}

void ___loadStringsFromData_block_invoke_2(uint64_t a1, const void *a2)
{
  const void *Value;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  if (Value)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 48), a2, Value);
  }
}

void ___loadStringsFromData_block_invoke(uint64_t a1, const void *a2)
{
  CFArrayRef v3;
  const void *v4[2];

  v4[1] = *(const void **)MEMORY[0x1E0C80C00];
  v4[0] = a2;
  v3 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4, 1, &kCFTypeArrayCallBacks);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), v3);
  CFRelease(v3);
}

void _CFPrefsDeliverPendingKVONotificationsGuts(const __CFArray *a1)
{
  const __CFDictionary *Mutable;
  CFIndex Count;
  CFIndex v4;
  CFIndex i;
  void *ValueAtIndex;
  const char *v7;
  void *v8;
  id Property;
  void *Value;
  const char *v11;
  id v12;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v4 = Count;
    for (i = 0; i != v4; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      v8 = ValueAtIndex;
      if (ValueAtIndex)
        Property = objc_getProperty(ValueAtIndex, v7, 8, 1);
      else
        Property = 0;
      Value = (void *)CFDictionaryGetValue(Mutable, Property);
      if (!Value)
      {
        Value = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
        if (v8)
          v12 = objc_getProperty(v8, v11, 8, 1);
        else
          v12 = 0;
        CFDictionarySetValue(Mutable, v12, Value);
        CFRelease(Value);
      }
      CFArrayAppendValue((CFMutableArrayRef)Value, v8);
    }
  }
  CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)applyBlockApplier, &__block_literal_global_190);
  CFRelease(Mutable);
}

void sub_182AEEB54(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182AEEB74(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x182AEEB28);
}

void sub_182AEEDF4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182AEF4E8(_Unwind_Exception *a1)
{
  free(0);
  _Unwind_Resume(a1);
}

void sub_182AEF9BC(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182AEFD3C(_Unwind_Exception *a1)
{
  free(0);
  _Unwind_Resume(a1);
}

void sub_182AF002C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182AF02E8(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

Boolean CFDictionaryContainsValue(CFDictionaryRef theDict, const void *value)
{
  if (CF_IS_OBJC(0x12uLL, (__objc2_class **)theDict))
    return -[__CFDictionary containsObject:](theDict, "containsObject:", value);
  else
    return CFBasicHashGetCountOfValue((uint64_t)theDict, (unint64_t)value) > 0;
}

void sub_182AF0948(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t CFStringHashCharacters(unsigned __int16 *a1, uint64_t a2)
{
  unsigned __int16 *v2;
  unsigned __int16 *v3;
  uint64_t v4;
  unint64_t v5;
  BOOL v6;
  unsigned __int16 *v7;
  uint64_t i;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  unsigned int v11;

  if (a2 >= 97)
  {
    v5 = 0;
    v4 = a2;
    do
    {
      v4 = a1[v5 + 3] + 67503105 * v4 + 257 * (257 * (257 * a1[v5] + a1[v5 + 1]) + a1[v5 + 2]);
      v6 = v5 >= 0x1C;
      v5 += 4;
    }
    while (!v6);
    v7 = (unsigned __int16 *)((char *)a1 + (a2 & 0xFFFFFFFFFFFFFFFELL) - 32);
    for (i = -20; i < 12; i += 4)
    {
      v4 = v7[3] + 67503105 * v4 + 257 * (257 * (257 * *v7 + v7[1]) + v7[2]);
      v7 += 4;
    }
    v9 = &a1[a2];
    v10 = v9 - 32;
    do
    {
      v4 = v10[3] + 67503105 * v4 + 257 * (257 * (257 * *v10 + v10[1]) + v10[2]);
      v10 += 4;
    }
    while (v10 < v9);
  }
  else
  {
    v2 = &a1[a2];
    if ((uint64_t)(a2 & 0xFFFFFFFFFFFFFFFCLL) < 1)
    {
      v4 = a2;
    }
    else
    {
      v3 = &a1[a2 & 0xFFFFFFFFFFFFFFFCLL];
      v4 = a2;
      do
      {
        v4 = a1[3] + 67503105 * v4 + 257 * (257 * (257 * *a1 + a1[1]) + a1[2]);
        a1 += 4;
      }
      while (a1 < v3);
    }
    while (a1 < v2)
    {
      v11 = *a1++;
      v4 = 257 * v4 + v11;
    }
  }
  return (v4 << (a2 & 0x1F)) + v4;
}

void sub_182AF1054(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

uint64_t CFBasicHashGetCountOfValue(uint64_t result, unint64_t a2)
{
  __int16 v2;
  int v3;
  uint64_t v4;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a2 == 2814029233 || !*(_DWORD *)(result + 20))
    return 0;
  v2 = *(_WORD *)(result + 18);
  if ((v2 & 4) != 0)
  {
    v6 = 0;
    v7 = &v6;
    v8 = 0x2020000000;
    v9 = 0;
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = __CFBasicHashGetCountOfValue_block_invoke;
    v5[3] = &unk_1E1335AE8;
    v5[5] = a2;
    v5[6] = result;
    v5[4] = &v6;
    CFBasicHashApply(result, (uint64_t)v5);
    v4 = v7[3];
    _Block_object_dispose(&v6, 8);
    return v4;
  }
  if (!*(_BYTE *)(result + 26))
  {
    v10 = xmmword_182DC7A10;
    v11 = unk_182DC7A20;
    return *((_QWORD *)&v11 + 1);
  }
  v3 = v2 & 3;
  if ((*(_WORD *)(result + 18) & 0x8000) != 0)
  {
    switch(v3)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential_Indirect(result, a2, (uint64_t *)&v10);
        return *((_QWORD *)&v11 + 1);
      case 2:
        ___CFBasicHashFindBucket_Double_Indirect(result, a2, (uint64_t *)&v10);
        return *((_QWORD *)&v11 + 1);
      case 1:
        ___CFBasicHashFindBucket_Linear_Indirect(result, a2, (uint64_t *)&v10);
        return *((_QWORD *)&v11 + 1);
    }
  }
  else
  {
    switch(v3)
    {
      case 3:
        ___CFBasicHashFindBucket_Exponential(result, a2, (uint64_t *)&v10);
        return *((_QWORD *)&v11 + 1);
      case 2:
        ___CFBasicHashFindBucket_Double(result, a2, (uint64_t *)&v10);
        return *((_QWORD *)&v11 + 1);
      case 1:
        ___CFBasicHashFindBucket_Linear(result, a2, (uint64_t *)&v10);
        return *((_QWORD *)&v11 + 1);
    }
  }
  __break(1u);
  return result;
}

void sub_182AF1470(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(exception_object);
}

uint64_t __CFMachPortHash(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

void sub_182AF1618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFTypeRef __NSCacheKeyRetain(const void *a1, _QWORD *a2)
{
  CFTypeRef result;

  result = CFRetain(a1);
  *a2 = result;
  return result;
}

CFURLRef _CFBundleCreateRelativeURLFromBaseAndPath(const __CFString *a1, const __CFURL *a2, int a3, const __CFString *a4)
{
  const __CFString *v7;
  int v8;
  const __CFString *v9;
  CFIndex v10;
  CFIndex Length;
  CFIndex v12;
  Boolean v13;
  CFURLRef v14;
  CFRange result;
  uint64_t v17;
  CFRange v18;
  CFRange v19;
  CFRange v20;

  v7 = a1;
  v17 = *MEMORY[0x1E0C80C00];
  result.location = 0;
  result.length = 0;
  v18.length = CFStringGetLength(a1) - 1;
  v18.location = 0;
  v8 = CFStringFindWithOptions(v7, a4, v18, 4uLL, &result);
  if (v8)
  {
    v19.length = result.location;
    v19.location = 0;
    v9 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7, v19);
    a2 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, v9, 1u);
    v10 = result.location + 1;
    Length = CFStringGetLength(v7);
    v20.length = Length + ~result.location;
    v20.location = v10;
    v7 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7, v20);
    CFRelease(v9);
  }
  v12 = CFStringGetLength(v7);
  v13 = CFStringGetCharacterAtIndex(v7, v12 - 1) == a3;
  v14 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7, kCFURLPOSIXPathStyle, v13, a2);
  if (v8)
  {
    CFRelease(a2);
    CFRelease(v7);
  }
  return v14;
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)__CFURLCreateCopyAppendingPathComponent(allocator, (__objc2_class **)url, pathComponent, isDirectory, CFSTR(";?"));
}

CFURLRef _CFBundleCreateNormalizedURL(const __CFAllocator *a1, CFURLRef url)
{
  const char *v3;
  size_t v4;
  UInt8 buffer[1026];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026))
    return 0;
  v3 = _CFBundleNormalizedPath((const char *)buffer);
  v4 = strlen(v3);
  return CFURLCreateFromFileSystemRepresentation(a1, (const UInt8 *)v3, v4, 1u);
}

BOOL _CFPrefsGetPathForManagedBundleID(__CFString *a1, const __CFString *a2, int a3, UInt8 *a4)
{
  const __CFString *CacheStringForBundleID;
  const __CFString *v9;
  const __CFString *v10;
  const __CFURL *v11;
  const __CFURL *v12;
  const __CFString *v13;
  const __CFString *v14;
  CFStringRef v15;
  const __CFString *v16;
  _BOOL8 v17;
  const __CFURL *v18;
  const __CFString *v20;
  const __CFString *v21;

  if (_CFPrefsGetPathForManagedBundleID_onceToken == -1)
  {
    if (!a3)
      goto LABEL_5;
  }
  else
  {
    dispatch_once(&_CFPrefsGetPathForManagedBundleID_onceToken, &__block_literal_global_6);
    if (!a3)
      goto LABEL_5;
  }
  if (_CFPrefsGetPathForManagedBundleID_containerizedOnceToken != -1)
    dispatch_once(&_CFPrefsGetPathForManagedBundleID_containerizedOnceToken, &__block_literal_global_9);
LABEL_5:
  if (a1 && (CacheStringForBundleID = (const __CFString *)_CFPrefsGetCacheStringForBundleID(a1)) != 0)
  {
    v9 = CacheStringForBundleID;
    if (CFEqual(CacheStringForBundleID, CFSTR("kCFPreferencesAnyApplication")))
      v10 = CFSTR(".GlobalPreferences");
    else
      v10 = v9;
    if (!a3)
      goto LABEL_11;
  }
  else
  {
    v10 = 0;
    if (!a3)
    {
LABEL_11:
      v11 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFStringRef)_CFPrefsGetPathForManagedBundleID_containingDirectoryPath, kCFURLPOSIXPathStyle, 1u);
      goto LABEL_14;
    }
  }
  v11 = (const __CFURL *)CFRetain((CFTypeRef)_CFPrefsGetPathForManagedBundleID_containerizedContainingDirectoryURL);
LABEL_14:
  v12 = v11;
  if (!v11)
    return 0;
  if (CFEqual(a2, CFSTR("kCFPreferencesAnyUser")))
  {
    if (!v10)
    {
      v14 = &stru_1E1337B18;
      goto LABEL_29;
    }
    v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@.plist"), v10);
    goto LABEL_18;
  }
  if (!CFEqual(a2, CFSTR("kCFPreferencesCurrentUser")))
  {
    v20 = _CFPrefsCopyUsernameForMobileUser();
    if (v20)
    {
      v21 = v20;
      if (CFEqual(a2, v20))
        a2 = CFSTR("mobile");
      CFRelease(v21);
    }
    if (v10)
      v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@/%@.plist"), a2, v10);
    else
      v13 = (const __CFString *)CFRetain(a2);
LABEL_18:
    v14 = v13;
    goto LABEL_19;
  }
  if (_CFPrefsGetPathForManagedBundleID_onceToken_16 != -1)
    dispatch_once(&_CFPrefsGetPathForManagedBundleID_onceToken_16, &__block_literal_global_17_0);
  v15 = (CFStringRef)_CFPrefsGetPathForManagedBundleID_ourUserName;
  if (!_CFPrefsGetPathForManagedBundleID_ourUserName)
  {
    v15 = CFCopyUserName();
    if (v10)
      goto LABEL_26;
LABEL_41:
    v16 = (const __CFString *)CFRetain(v15);
    goto LABEL_42;
  }
  if (!v10)
    goto LABEL_41;
LABEL_26:
  v16 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@/%@.plist"), v15, v10);
LABEL_42:
  v14 = v16;
  if (!_CFPrefsGetPathForManagedBundleID_ourUserName && v15)
    CFRelease(v15);
LABEL_19:
  if (v14)
  {
LABEL_29:
    v18 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14, kCFURLPOSIXPathStyle, 0, v12);
    CFRelease(v14);
    CFRelease(v12);
    if (v18)
    {
      v17 = CFURLGetFileSystemRepresentation(v18, 1u, a4, 1024) != 0;
      v12 = v18;
      goto LABEL_31;
    }
    return 0;
  }
  v17 = 0;
LABEL_31:
  CFRelease(v12);
  return v17;
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)_CFURLCreateWithFileSystemPath((__objc2_class **)allocator, filePath, pathStyle, isDirectory, 0);
}

BOOL _CFPrefsGetPathForTriplet(__CFString *a1, const __CFString *a2, int a3, CFStringRef filePath, UInt8 *a5)
{
  CFURLRef v9;
  const __CFURL *PreferencesDirectoryURLForTriplet;
  const __CFString *CacheStringForBundleID;
  CFIndex location;
  CFStringRef v13;
  const __CFString *v14;
  const __CFURL *v15;
  _BOOL8 v16;
  const __CFString *v18;
  CFRange v19;

  if (filePath)
  {
    v9 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, filePath, kCFURLPOSIXPathStyle, 1u);
    PreferencesDirectoryURLForTriplet = _CFPrefsCreatePreferencesDirectoryURLForTriplet(a2, a3, v9);
    if (v9)
      CFRelease(v9);
    if (!PreferencesDirectoryURLForTriplet)
      return 0;
  }
  else
  {
    PreferencesDirectoryURLForTriplet = _CFPrefsCreatePreferencesDirectoryURLForTriplet(a2, a3, 0);
    if (!PreferencesDirectoryURLForTriplet)
      return 0;
  }
  CacheStringForBundleID = (const __CFString *)_CFPrefsGetCacheStringForBundleID(a1);
  if (CFEqual(CacheStringForBundleID, CFSTR("kCFPreferencesAnyApplication")))
    CacheStringForBundleID = CFSTR(".GlobalPreferences");
  location = CFStringFind(CacheStringForBundleID, CFSTR(".plist"), 0xDuLL).location;
  if (location == -1)
  {
    CFRetain(CacheStringForBundleID);
    if (!a3)
      goto LABEL_14;
  }
  else
  {
    v19.length = location;
    v19.location = 0;
    CacheStringForBundleID = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, CacheStringForBundleID, v19);
    if (!a3)
      goto LABEL_14;
  }
  if (!CFEqual(a2, CFSTR("kCFPreferencesAnyUser")))
  {
    v18 = _CFXPreferencesGetByHostIdentifierString();
    v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@.%@.plist"), CacheStringForBundleID, v18);
    goto LABEL_16;
  }
LABEL_14:
  v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@.plist"), CacheStringForBundleID);
LABEL_16:
  v14 = v13;
  CFRelease(CacheStringForBundleID);
  if (!v14)
  {
    v16 = 0;
    goto LABEL_21;
  }
  v15 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v14, kCFURLPOSIXPathStyle, 0, PreferencesDirectoryURLForTriplet);
  CFRelease(v14);
  CFRelease(PreferencesDirectoryURLForTriplet);
  if (v15)
  {
    v16 = CFURLGetFileSystemRepresentation(v15, 1u, a5, 1024) != 0;
    PreferencesDirectoryURLForTriplet = v15;
LABEL_21:
    CFRelease(PreferencesDirectoryURLForTriplet);
    return v16;
  }
  return 0;
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  int v6;
  CFAllocatorRef v8;
  const __CFAllocator *v9;
  const __CFString *v10;
  const __CFString *v11;
  char *v13;
  const __CFString *v14;
  const __CFString *v15;
  Boolean FileSystemRepresentation;
  const __CFString *v18;
  int v19;
  char *v20;
  char buffera[8];
  __int16 v22;
  char v23[2038];
  uint64_t v24;

  v6 = resolveAgainstBase;
  v24 = *MEMORY[0x1E0C80C00];
  v8 = CFGetAllocator(url);
  if (!url)
    return 0;
  v9 = v8;
  if (v6)
  {
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
    {
      if (-[__CFURL baseURL](url, "baseURL"))
        goto LABEL_9;
    }
    else if (*((_QWORD *)url + 4))
    {
      goto LABEL_9;
    }
  }
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url) || (*((_BYTE *)url + 17) & 0x10) == 0)
  {
LABEL_9:
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
    {
      if (-[__CFURL baseURL](url, "baseURL"))
        goto LABEL_26;
    }
    else if (*((_QWORD *)url + 4))
    {
      goto LABEL_26;
    }
    if (CFURLIsFileReferenceURL(url))
    {
      v10 = CFURLCopyPath(url);
      if (v10)
      {
        v11 = v10;
        if (!CFStringGetCString(v10, buffera, 2048, 0x8000100u))
          goto LABEL_25;
        if (*(_QWORD *)buffera != 0x692F656C69662E2FLL || v22 != 15716)
          goto LABEL_25;
        v20 = 0;
        strtoll(v23, &v20, 10);
        if (*v20 != 46)
          goto LABEL_25;
        strtoll(v20 + 1, &v20, 10);
        v13 = v20;
        if (*v20 == 47)
          v13 = v20 + 1;
        if (!*v13)
        {
          v19 = _FSGetFileSystemRepresentationForFileID();
          CFRelease(v11);
          if (v19)
            return 1;
        }
        else
        {
LABEL_25:
          CFRelease(v11);
        }
      }
    }
LABEL_26:
    v14 = CFURLCreateStringWithFileSystemPath(v9, (__objc2_class **)url, 0, v6);
    if (v14)
    {
      v15 = v14;
      FileSystemRepresentation = CFStringGetFileSystemRepresentation(v14, (char *)buffer, maxBufLen);
      CFRelease(v15);
      return FileSystemRepresentation;
    }
    return 0;
  }
  v18 = (const __CFString *)atomic_load((unint64_t *)url + 3);
  return CanonicalFileURLStringToFileSystemRepresentation(v18, buffer, maxBufLen);
}

CFTypeRef _CFURLCreateWithFileSystemRepresentation(const __CFAllocator *a1, char *__s1, uint64_t a3, int a4, const __CFURL *cf)
{
  const __CFURL *v5;
  int v10;
  _BOOL4 v11;
  _BOOL4 v13;
  CFStringRef v14;
  const __CFString *v15;
  uint64_t v16;
  CFStringRef v17;
  uint64_t Instance;
  uint64_t v19;
  CFURLRef v20;
  int v21;
  int v22;
  CFIndex Length;
  int v24;
  const __CFString *v25;
  CFIndex v26;
  char v27;
  uint64_t v28;

  v5 = cf;
  v28 = *MEMORY[0x1E0C80C00];
  if (a3 < 1)
  {
    if (cf)
      return CFRetain(cf);
    return 0;
  }
  v10 = *__s1;
  v27 = 0;
  if (v10 == 47)
  {
    v11 = (unint64_t)a3 >= 0xA && strncmp(__s1, "/.file/id=", 0xAuLL) == 0;
    v17 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(a1, __s1, a3, a4, 1, 0, &v27);
    if (v17)
    {
      v15 = v17;
      v13 = 0;
      v5 = 0;
      v16 = 72;
LABEL_15:
      Instance = _CFRuntimeCreateInstance((__objc2_class **)a1, 0x1DuLL, v16, 0);
      v19 = Instance;
      if (Instance)
      {
        *(_DWORD *)(Instance + 20) = 134217984;
        atomic_store((unint64_t)CFStringCreateCopy(a1, v15), (unint64_t *)(Instance + 24));
        if (v5)
          v20 = CFURLCopyAbsoluteURL(v5);
        else
          v20 = 0;
        *(_QWORD *)(v19 + 32) = v20;
        if (v10 == 47)
        {
          if (v27)
            v21 = 4096;
          else
            v21 = 36864;
          if (v11)
            v21 = 0x2000;
          if (a4)
            v22 = 1610696737;
          else
            v22 = 1610694689;
          *(_DWORD *)(v19 + 16) = v22 | v21;
          *(_OWORD *)(v19 + 56) = xmmword_182CF96F0;
          Length = CFStringGetLength(v15);
          *(_QWORD *)(v19 + 72) = 7;
          *(_QWORD *)(v19 + 80) = Length - 7;
        }
        else
        {
          if (a4)
            v24 = 84000;
          else
            v24 = 81952;
          *(_DWORD *)(v19 + 16) = v24 | ((v27 == 0) << 15);
          v25 = (const __CFString *)atomic_load((unint64_t *)(v19 + 24));
          v26 = CFStringGetLength(v25);
          *(_QWORD *)(v19 + 56) = 0;
          *(_QWORD *)(v19 + 64) = v26;
        }
      }
      CFRelease(v15);
      if (!v13)
        return (CFTypeRef)v19;
      goto LABEL_37;
    }
    return 0;
  }
  v13 = cf == 0;
  if (!cf)
    v5 = (const __CFURL *)_CFURLCreateCurrentDirectoryURL((int)a1);
  v14 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(a1, __s1, a3, a4, v10 == 47, 0, &v27);
  if (v14)
  {
    v15 = v14;
    v11 = 0;
    v16 = 56;
    goto LABEL_15;
  }
  v19 = 0;
  if (v13)
  {
LABEL_37:
    if (v5)
      CFRelease(v5);
  }
  return (CFTypeRef)v19;
}

CFTypeRef _CFURLCreateWithFileSystemPath(__objc2_class **a1, CFStringRef theString, uint64_t a3, _BOOL4 a4, const void *a5)
{
  const __CFString *v8;
  CFIndex Length;
  CFIndex v11;
  _BOOL4 v12;
  _BOOL4 v13;
  UniChar *v15;
  CFIndex v16;
  CFIndex v17;
  uint64_t v18;
  int v19;
  CFIndex v20;
  CFIndex v21;
  CFIndex v22;
  int v23;
  unsigned int v24;
  int v25;
  const __CFArray *ArrayBySeparatingStrings;
  __CFArray *MutableCopy;
  int v28;
  const __CFString *ValueAtIndex;
  unsigned int Count;
  uint64_t v31;
  CFIndex v32;
  const __CFString *v33;
  CFIndex v34;
  CFIndex v35;
  __CFString *v36;
  CFIndex v37;
  const __CFString *v38;
  _BOOL4 v39;
  const __CFAllocator *v40;
  CFIndex v41;
  CFIndex v42;
  CFIndex v43;
  __CFArray *v44;
  const __CFString *v45;
  CFStringRef v46;
  CFStringRef v47;
  const __CFString *v48;
  uint64_t v49;
  CFStringRef v50;
  const __CFArray *v51;
  const __CFString *v52;
  __CFArray *v53;
  CFStringRef v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t Instance;
  CFURLRef v60;
  int v61;
  const __CFString *v62;
  CFIndex v63;
  int v64;
  int v65;
  CFIndex v66;
  int v67;
  unsigned int v68;
  _BOOL4 v69;
  int CharacterAtIndex;
  const __CFString *cf;
  const void *v72;
  int v73;
  CFIndex v74;
  BOOL v75;
  CFRange result;
  uint64_t v77;
  CFRange v78;
  CFRange v79;
  CFRange v80;
  CFRange v81;

  v8 = theString;
  v77 = *MEMORY[0x1E0C80C00];
  v75 = 0;
  Length = CFStringGetLength(theString);
  if (Length < 1)
  {
    if (a5)
      return CFRetain(a5);
    return 0;
  }
  v11 = Length;
  if (a3 != 2)
  {
    if (a3 != 1)
    {
      if (!a3)
      {
        v12 = CFStringGetCharacterAtIndex(v8, 0) == 47;
        if (v8)
          v13 = CFStringHasPrefix(v8, CFSTR("/.file/id=")) != 0;
        else
          v13 = 0;
        v48 = POSIXPathToURLPath(v8, a4, v12, &v75);
LABEL_76:
        v49 = 0;
        if (!v48)
          return 0;
LABEL_98:
        if (v12)
        {
          v55 = 0;
          v56 = 0;
          a5 = 0;
          if (a4)
            goto LABEL_108;
          goto LABEL_106;
        }
LABEL_102:
        if (a5)
        {
          v56 = 0;
          v55 = 1;
          if (a4)
            goto LABEL_108;
        }
        else
        {
          a5 = (const void *)_CFURLCreateCurrentDirectoryURL((int)a1);
          v55 = 1;
          v56 = 1;
          if (a4)
          {
LABEL_108:
            if (v55)
              v58 = 56;
            else
              v58 = 72;
            Instance = _CFRuntimeCreateInstance(a1, 0x1DuLL, v58, 0);
            v57 = Instance;
            if (Instance)
            {
              *(_DWORD *)(Instance + 20) = 134217984;
              atomic_store((unint64_t)CFStringCreateCopy((CFAllocatorRef)a1, v48), (unint64_t *)(Instance + 24));
              if (a5)
                v60 = CFURLCopyAbsoluteURL((CFURLRef)a5);
              else
                v60 = 0;
              *(_QWORD *)(v57 + 32) = v60;
              if ((v55 & 1) != 0)
              {
                if (a4)
                  v61 = 84000;
                else
                  v61 = 81952;
                *(_DWORD *)(v57 + 16) = v61;
                v62 = (const __CFString *)atomic_load((unint64_t *)(v57 + 24));
                v63 = CFStringGetLength(v62);
                *(_QWORD *)(v57 + 56) = 0;
                *(_QWORD *)(v57 + 64) = v63;
              }
              else
              {
                v64 = 84001;
                if (!a4)
                  v64 = 81953;
                if (v13)
                  v65 = v64 | 0x2000;
                else
                  v65 = (v75 << 15) | ((v49 == 0) << 12) | v64;
                *(_DWORD *)(v57 + 16) = v65 | 0x60000000;
                *(_OWORD *)(v57 + 56) = xmmword_182CF96F0;
                v66 = CFStringGetLength(v48);
                *(_QWORD *)(v57 + 72) = 7;
                *(_QWORD *)(v57 + 80) = v66 - 7;
              }
            }
            if (a5)
              v67 = v56;
            else
              v67 = 0;
            if (v67 == 1)
              CFRelease(a5);
            CFRelease(v48);
            return (CFTypeRef)v57;
          }
        }
LABEL_106:
        if (v11 == 1)
          a4 = CFStringGetCharacterAtIndex(v48, 0) == 47;
        goto LABEL_108;
      }
      return 0;
    }
    CharacterAtIndex = CFStringGetCharacterAtIndex(v8, 0);
    v12 = CharacterAtIndex != 58;
    v79.location = 0;
    v79.length = v11;
    v73 = CFStringFindWithOptions(v8, CFSTR("::"), v79, 0, 0);
    if (v73)
    {
      v15 = (UniChar *)malloc_type_malloc(2 * v11, 0x1000040BDFB0063uLL);
      v78.location = 0;
      v78.length = v11;
      CFStringGetCharacters(v8, v78, v15);
      v16 = 0;
      v17 = 0;
      v18 = -1;
      do
      {
        v19 = v15[v17];
        if (v19 == 58)
        {
          v20 = v17 + 1;
          if (v17 + 1 < v11 && v15[v20] == 58)
          {
            if (v16 >= 1 && (v18 & 0x8000000000000000) == 0)
            {
              if (v18 >= v16)
                v21 = v16;
              else
                v21 = v18;
              v22 = v21 - 1;
              while (1)
              {
                if (v16 < 2)
                {
                  v16 = 0;
                  goto LABEL_25;
                }
                if (v16 <= v18)
                  break;
                v23 = v15[--v16];
                if (v23 == 58)
                  goto LABEL_25;
              }
              v16 = v22;
            }
          }
          else
          {
            v20 = v17;
          }
LABEL_25:
          if (v18 == -1)
            v18 = v16;
          LOWORD(v19) = v15[v20];
          v17 = v20;
        }
        v15[v16++] = v19;
        ++v17;
      }
      while (v17 < v11);
      v8 = CFStringCreateWithCharacters((CFAllocatorRef)a1, v15, v16);
      v11 = CFStringGetLength(v8);
      free(v15);
    }
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)a1, v8, CFSTR(":"));
    MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)a1, 0, ArrayBySeparatingStrings);
    v28 = CFStringGetCharacterAtIndex(v8, 0);
    CFRelease(ArrayBySeparatingStrings);
    v74 = v11;
    if (v28 == 58)
    {
      CFArrayRemoveValueAtIndex(MutableCopy, 0);
    }
    else
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, 0);
      if (CFStringGetLength(ValueAtIndex) == 1 && CFStringGetCharacterAtIndex(ValueAtIndex, 0) == 47)
        CFArrayRemoveValueAtIndex(MutableCopy, 0);
      CFArrayInsertValueAtIndex(MutableCopy, 0, &stru_1E1337B18);
    }
    v72 = a5;
    Count = CFArrayGetCount(MutableCopy);
    v31 = Count;
    cf = v8;
    if (Count)
    {
      v68 = Count;
      v69 = a4;
      v32 = 0;
      do
      {
        v33 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v32);
        result.location = 0;
        result.length = 0;
        v34 = CFStringGetLength(v33);
        v80.location = 0;
        v80.length = v34;
        if (CFStringFindWithOptions(v33, CFSTR("/"), v80, 0, &result))
        {
          v35 = 0;
          v36 = 0;
          do
          {
            v37 = v35 + v34;
            if (!v36)
              v36 = CFStringCreateMutableCopy((CFAllocatorRef)a1, v37, v33);
            CFStringReplace(v36, result, CFSTR(":"));
            v34 = v37 + ~result.location;
            v35 = result.location + 1;
            v81.location = result.location + 1;
            v81.length = v34;
          }
          while (CFStringFindWithOptions(v33, CFSTR("/"), v81, 0, &result));
          if (v36)
          {
            CFArraySetValueAtIndex(MutableCopy, v32, v36);
            CFRelease(v36);
          }
        }
        ++v32;
      }
      while (v32 != v31);
      a4 = v69;
      if (v69)
      {
        v38 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v68 - 1);
        if (CFStringGetLength(v38))
          CFArrayAppendValue(MutableCopy, &stru_1E1337B18);
      }
    }
    if (!MutableCopy)
    {
      v48 = 0;
      goto LABEL_95;
    }
    v39 = a4;
    v40 = CFGetAllocator(MutableCopy);
    v41 = CFArrayGetCount(MutableCopy);
    v42 = v41;
    if (v41 >= 1)
    {
      v43 = 0;
      v44 = 0;
      while (1)
      {
        v45 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, v43);
        v46 = CFURLCreateStringByAddingPercentEscapes(v40, v45, 0, CFSTR(";?/"), 0x8000100u);
        if (!v46)
          break;
        v47 = v46;
        if (v46 != v45)
        {
          if (!v44)
            v44 = CFArrayCreateMutableCopy(v40, v42, MutableCopy);
          CFArraySetValueAtIndex(v44, v43, v47);
        }
        CFRelease(v47);
        if (v42 == ++v43)
          goto LABEL_83;
      }
      if (v42 == v43)
      {
LABEL_83:
        v51 = v44;
        if (v44)
          goto LABEL_85;
        goto LABEL_84;
      }
      v54 = 0;
      v48 = 0;
      a5 = v72;
      v12 = CharacterAtIndex != 58;
      if (!v44)
        goto LABEL_94;
      goto LABEL_93;
    }
    if (v41)
    {
      v48 = 0;
      a5 = v72;
      v12 = CharacterAtIndex != 58;
    }
    else
    {
LABEL_84:
      CFRetain(MutableCopy);
      v51 = MutableCopy;
LABEL_85:
      CFRelease(MutableCopy);
      v12 = CharacterAtIndex != 58;
      if (CFArrayGetCount(v51) == 1
        && (v52 = (const __CFString *)CFArrayGetValueAtIndex(v51, 0), !CFStringGetLength(v52)))
      {
        v53 = (__CFArray *)CFRetain(CFSTR("/"));
      }
      else
      {
        v53 = (__CFArray *)CFStringCreateByCombiningStrings((CFAllocatorRef)a1, v51, CFSTR("/"));
      }
      v44 = v53;
      a5 = v72;
      if (CharacterAtIndex != 58 && v53)
      {
        v54 = CFStringCreateWithFormat((CFAllocatorRef)a1, 0, CFSTR("file://%@"), v53);
        MutableCopy = v51;
LABEL_93:
        CFRelease(v44);
        v48 = v54;
        goto LABEL_94;
      }
      MutableCopy = v51;
      v48 = (const __CFString *)v53;
    }
LABEL_94:
    CFRelease(MutableCopy);
    a4 = v39;
LABEL_95:
    v11 = v74;
    if (v73)
      CFRelease(cf);
    v13 = 0;
    v49 = 1;
    if (!v48)
      return 0;
    goto LABEL_98;
  }
  v24 = CFStringGetCharacterAtIndex(v8, 0);
  if ((unint64_t)v11 < 2)
    v25 = 0;
  else
    v25 = CFStringGetCharacterAtIndex(v8, 1);
  if (v24 <= 0x7F && (sURLValidCharacters[v24] & 2) != 0 && (v25 == 124 || v25 == 58))
    goto LABEL_70;
  if (v24 == 47)
  {
    v12 = 1;
    v48 = POSIXPathToURLPath(v8, a4, 1, &v75);
    v13 = 0;
    goto LABEL_76;
  }
  if (v24 == 92)
  {
LABEL_70:
    v12 = 1;
    v48 = WindowsPathToURLPath(v8, (const __CFAllocator *)a1, a4, 1);
    v13 = 0;
    v49 = 2;
    if (v48)
      goto LABEL_98;
  }
  else
  {
    v50 = WindowsPathToURLPath(v8, (const __CFAllocator *)a1, a4, 0);
    if (v50)
    {
      v48 = v50;
      v13 = 0;
      v49 = 2;
      goto LABEL_102;
    }
  }
  return 0;
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  const __CFAllocator *v2;
  const __CFURL *v3;
  const __CFURL *v4;
  CFURLRef v5;
  char v6;
  const __CFString *v7;
  CFIndex *v8;
  const __CFString *v10;
  UniChar *v11;
  UniChar *v12;
  CFURLRef v13;
  char v14;
  unsigned int v15;
  _QWORD v16[19];

  v16[18] = *MEMORY[0x1E0C80C00];
  v2 = CFGetAllocator(relativeURL);
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)relativeURL))
  {
    v3 = (const __CFURL *)-[__CFURL absoluteURL](relativeURL, "absoluteURL");
    v4 = v3;
    if (v3)
      CFRetain(v3);
    return v4;
  }
  v5 = (CFURLRef)*((_QWORD *)relativeURL + 4);
  if (!v5)
    return (CFURLRef)CFRetain(relativeURL);
  if (CFURLIsFileReferenceURL(*((CFURLRef *)relativeURL + 4)) && !CFURLHasDirectoryPath(v5))
  {
    v13 = CFURLCreateFilePathURL(v2, v5, 0);
    if (!v13)
      return 0;
    v5 = v13;
    v6 = 0;
  }
  else
  {
    v6 = 1;
  }
  v15 = 0;
  v14 = 0;
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)v5))
  {
    v7 = CFURLGetString(v5);
    v15 = 0;
    v8 = v16;
    _parseComponents(v7, 0, &v15, v16, &v14);
  }
  else
  {
    v7 = (const __CFString *)atomic_load((unint64_t *)v5 + 3);
    v15 = *((_DWORD *)v5 + 4);
    v8 = (CFIndex *)((char *)v5 + 56);
  }
  v10 = (const __CFString *)atomic_load((unint64_t *)relativeURL + 3);
  v11 = resolveAbsoluteURLString(v2, v10, *((_DWORD *)relativeURL + 4), (uint64_t)relativeURL + 56, v7, v15, v8);
  if (v11)
  {
    v12 = v11;
    v4 = (const __CFURL *)_CFURLCreateWithURLString((int)v2, (CFStringRef)v11);
    CFRelease(v12);
    *((_DWORD *)v4 + 5) = *((_DWORD *)relativeURL + 5);
    if ((v6 & 1) != 0)
      return v4;
    goto LABEL_16;
  }
  v4 = 0;
  if ((v6 & 1) == 0)
LABEL_16:
    CFRelease(v5);
  return v4;
}

CFStringRef POSIXPathToURLPath(const __CFString *a1, int a2, int a3, BOOL *a4)
{
  int64_t MaximumSizeOfFileSystemRepresentation;
  CFIndex v9;
  char *v10;
  size_t v11;
  CFStringRef v12;
  char v14;
  char buffer[1024];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  if (CFStringGetLength(a1))
  {
    MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(a1);
    v9 = MaximumSizeOfFileSystemRepresentation;
    if (MaximumSizeOfFileSystemRepresentation >= 1025)
      v10 = (char *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0xC529D2D2uLL);
    else
      v10 = buffer;
  }
  else
  {
    v10 = buffer;
    v9 = 1;
  }
  if (CFStringGetFileSystemRepresentation(a1, v10, v9))
  {
    v11 = strlen(v10);
    v12 = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(0, v10, v11, a2, a3, 0, &v14);
  }
  else
  {
    v12 = 0;
  }
  if (v10 != buffer)
    free(v10);
  if (a4)
    *a4 = v14 == 0;
  return v12;
}

Boolean CFStringGetFileSystemRepresentation(CFStringRef string, char *buffer, CFIndex maxBufLen)
{
  if (CFStringGetLength(string))
    return -[__CFString getFileSystemRepresentation:maxLength:]((id)string, "getFileSystemRepresentation:maxLength:", buffer, maxBufLen);
  if (!maxBufLen)
    return 0;
  *buffer = 0;
  return 1;
}

CFStringRef CreateStringFromFileSystemRepresentationByAddingPercentEscapes(const __CFAllocator *a1, _BYTE *a2, uint64_t a3, int a4, int a5, int a6, char *a7)
{
  size_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  CFStringRef v32;
  _QWORD v34[2];

  v34[1] = *MEMORY[0x1E0C80C00];
  v14 = (a4 != 0) | (8 * (a5 != 0)) | 0xC00;
  MEMORY[0x1E0C80A78](a1, a2);
  v18 = (char *)v34 - v17;
  if (v19 >= 1025)
  {
    v14 = 3 * a3 + 8 * v15 + v16;
    v21 = (char *)malloc_type_malloc(v14, 0x42281852uLL);
    if (!v21)
    {
      v32 = 0;
      v23 = 0;
      goto LABEL_62;
    }
    v20 = v21;
    v34[0] = a7;
  }
  else
  {
    v34[0] = a7;
    v20 = (char *)v34 - v17;
  }
  v22 = v20;
  if (a5)
  {
    strlcpy(v20, "file://", v14);
    v22 = v20 + 7;
  }
  if (!a6)
  {
    if (a3 >= 1)
    {
      v23 = 0;
      v24 = 0;
      while (1)
      {
        v27 = a2[v24];
        if (!a2[v24])
          goto LABEL_28;
        if ((sURLValidBytes[v27] & 1) != 0)
        {
          *v22++ = v27;
        }
        else
        {
          *v22 = 37;
          v22[1] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)a2[v24] >> 4];
          v22[2] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[a2[v24] & 0xF];
          v22 += 3;
          v23 = 1;
        }
        if (a3 == ++v24)
          goto LABEL_34;
      }
    }
LABEL_27:
    v24 = 0;
    v23 = 0;
    v28 = a2;
    goto LABEL_29;
  }
  if (a3 < 1)
    goto LABEL_27;
  v23 = 0;
  v24 = 0;
  while (1)
  {
    v25 = a2[v24];
    if (!a2[v24])
      break;
    if ((_DWORD)v25 == 47 || (sURLValidBytes[v25] & 1) == 0)
    {
      *v22 = 37;
      v22[1] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)a2[v24] >> 4];
      v22[2] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[a2[v24] & 0xF];
      v22 += 3;
      v23 = 1;
    }
    else
    {
      *v22++ = v25;
    }
    if (a3 == ++v24)
      goto LABEL_34;
  }
LABEL_28:
  v28 = &a2[v24];
LABEL_29:
  if (v24 < a3)
  {
    while (!*v28)
    {
      ++v24;
      ++v28;
      if (a3 == v24)
        goto LABEL_34;
    }
  }
  if (v24 != a3)
  {
    v32 = 0;
    goto LABEL_60;
  }
LABEL_34:
  if (!a4)
  {
    if (a6)
    {
      if (a3 >= 2 && v22 - v20 >= 4)
      {
        v30 = v22 - v20 - 3;
        do
        {
          v29 = (uint64_t)v22;
          v22 -= 3;
          if (strncmp(v22, "%2F", 3uLL))
            break;
          if (a3 < 3)
            goto LABEL_58;
          --a3;
          v29 = (uint64_t)v22;
          v31 = v30 < 4;
          v30 -= 3;
        }
        while (!v31);
        goto LABEL_59;
      }
    }
    else if (a3 >= 2)
    {
      v29 = (uint64_t)&v22[-a3 + 1];
      while (a2[a3 - 1] == 47)
      {
        --a3;
        --v22;
        if ((unint64_t)(a3 + 1) <= 2)
          goto LABEL_59;
      }
    }
    goto LABEL_58;
  }
  if (!a6)
  {
    if (a3 >= 1 && a2[a3 - 1] != 47)
      *v22++ = 47;
    goto LABEL_58;
  }
  if (v22 - v20 < 4 || !strncmp(v22 - 3, "%2F", 3uLL))
  {
LABEL_58:
    v29 = (uint64_t)v22;
    goto LABEL_59;
  }
  *(_WORD *)v22 = 12837;
  v29 = (uint64_t)(v22 + 3);
  v22[2] = 70;
LABEL_59:
  v32 = CFStringCreateWithBytes(a1, (const UInt8 *)v20, v29 - (_QWORD)v20, 0x8000100u, 0);
LABEL_60:
  a7 = (char *)v34[0];
  if (v20 != v18)
    free(v20);
LABEL_62:
  if (a7)
    *a7 = v23;
  return v32;
}

CFIndex CFStringGetMaximumSizeOfFileSystemRepresentation(CFStringRef string)
{
  CFIndex Length;
  CFStringEncoding FastestEncoding;
  BOOL v4;
  uint64_t v5;

  Length = CFStringGetLength(string);
  FastestEncoding = CFStringGetFastestEncoding(string);
  if (FastestEncoding != 1536 && FastestEncoding)
  {
    v4 = Length <= 0xE38E38E38E38E38;
    v5 = 9 * Length;
  }
  else
  {
    v4 = Length <= 0x2AAAAAAAAAAAAAAALL;
    v5 = 3 * Length;
  }
  if (v4)
    return v5 + 1;
  else
    return -1;
}

CFStringEncoding CFStringGetFastestEncoding(CFStringRef theString)
{
  CFStringEncoding result;
  char v3;

  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    return -[__CFString _fastestEncodingInCFStringEncoding]((id)theString, "_fastestEncodingInCFStringEncoding");
  v3 = atomic_load((unint64_t *)&theString->info);
  if ((v3 & 0x10) != 0)
    return 256;
  result = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding(0xFFFFFFFFLL);
    return __CFDefaultEightBitStringEncoding;
  }
  return result;
}

BOOL CFUniCharDecomposeWithErrorLocation(unsigned __int16 *a1, uint64_t a2, _QWORD *a3, unsigned int *a4, uint64_t a5, _QWORD *a6, int a7, int a8, char a9, uint64_t *a10)
{
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v20;
  unsigned int *v21;
  unsigned __int16 *v22;
  unsigned __int16 *v23;
  unsigned int v24;
  unsigned int v25;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int *Typed;
  size_t v35;
  uint64_t BitmapPtrForPlane;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v43;
  unsigned int *v44;
  uint64_t v49;
  uint64_t v51;
  unsigned int *v52;
  _BYTE v53[128];
  uint64_t v54;

  v12 = a6;
  v13 = a5;
  v14 = a3;
  v15 = a2;
  v54 = *MEMORY[0x1E0C80C00];
  v51 = 0;
  v52 = a4;
  if (a10)
    *a10 = -1;
  v16 = a2;
  if (a2 < 1)
    goto LABEL_90;
  v17 = 0;
  v18 = 0;
  if (a9)
    v19 = &__CFUniCharHfsPlusDecomposableCharacterSetBitmapPlane0_0;
  else
    v19 = &__CFUniCharCanonicalDecomposableCharacterSetBitmapPlane0_0;
  v49 = (uint64_t)v19;
  v43 = 32;
  v20 = a2;
  v21 = (unsigned int *)v53;
  v22 = a1;
  v16 = a2;
LABEL_8:
  v23 = v22;
  while (1)
  {
    v25 = *v22++;
    v24 = v25;
    if (v25 <= 0x7F)
    {
      if (v18 < 1)
      {
        v20 = v16;
      }
      else
      {
        if (v18 != 1)
          __CFUniCharPrioritySort(v21, v18);
        if (!CFUniCharFillDestinationBuffer(v21, v18, (uint64_t *)&v52, v13, &v51, a8))
        {
LABEL_74:
          v14 = a3;
          v12 = a6;
          v15 = a2;
          goto LABEL_80;
        }
        v18 = 0;
        v17 = 0;
      }
      v33 = v51;
      if (v13 < 1)
        goto LABEL_65;
      if (v51 >= v13)
      {
        v16 = v20;
LABEL_87:
        v14 = a3;
        v12 = a6;
        v15 = a2;
        goto LABEL_88;
      }
      if (a8)
      {
        if (a8 != 3)
        {
          if (a8 == 2)
          {
            *(_BYTE *)v52 = v24;
            v52 = (unsigned int *)((char *)v52 + 1);
            v33 = v51;
          }
          goto LABEL_65;
        }
        v39 = v52;
        *v52 = v24;
        v38 = v39 + 1;
      }
      else
      {
        v37 = v52;
        *(_WORD *)v52 = v24;
        v38 = (unsigned int *)((char *)v37 + 2);
      }
      v52 = v38;
LABEL_65:
      v16 = v20 - 1;
      v51 = v33 + 1;
      goto LABEL_71;
    }
    if ((v24 & 0xFC00) == 0xD800)
      break;
    if ((v24 & 0xFC00) == 0xDC00 && a8 != 0)
      goto LABEL_76;
LABEL_20:
    if (a7)
    {
      if (!(v24 >> 17))
      {
        v28 = (uint64_t)*(&__CFUniCharCombiningPriorityTable_0 + HIWORD(v24));
        if (*(_BYTE *)(v28 + BYTE1(v24)))
        {
          if (*(_BYTE *)(v28 + (*(unsigned __int8 *)(v28 + BYTE1(v24)) << 8) - 256 + v24 + 256))
          {
            v32 = v43;
            if (v18 + 1 >= v43)
            {
              v32 = v43 + 32;
              Typed = (unsigned int *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 4 * (v43 + 32), 0x100004052888210, 0);
              v35 = 4 * v43;
              v44 = Typed;
              memmove(Typed, v21, v35);
              if (v21 != (unsigned int *)v53)
                CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v21);
              v21 = v44;
            }
            BitmapPtrForPlane = v49;
            if ((v24 < 0x10000 || (BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v24))) != 0)
              && ((*(unsigned __int8 *)(BitmapPtrForPlane + ((unsigned __int16)v24 >> 3)) >> (v24 & 7)) & 1) != 0)
            {
              v18 += CFUniCharDecomposeCharacter(v24, &v21[v18], v32 - v18);
            }
            else
            {
              v21[v18++] = v24;
            }
            v13 = a5;
LABEL_68:
            v40 = 1;
            if (HIWORD(v24))
              v40 = 2;
            v17 += v40;
            v43 = v32;
LABEL_71:
            v20 = v16 - v17;
            if (v16 > v17)
              goto LABEL_8;
            goto LABEL_79;
          }
        }
      }
    }
    if (v18 < 1)
    {
      v20 = v16;
      v13 = a5;
    }
    else
    {
      v13 = a5;
      if (v18 != 1)
        __CFUniCharPrioritySort(v21, v18);
      if (!CFUniCharFillDestinationBuffer(v21, v18, (uint64_t *)&v52, a5, &v51, a8))
        goto LABEL_74;
      v17 = 0;
    }
    v29 = v49;
    if ((v24 < 0x10000 || (v29 = CFUniCharGetBitmapPtrForPlane(9u, BYTE2(v24))) != 0)
      && ((*(unsigned __int8 *)(v29 + ((unsigned __int16)v24 >> 3)) >> (v24 & 7)) & 1) != 0)
    {
      v30 = CFUniCharDecomposeCharacter(v24, v21, 32);
      v18 = v30;
      if (a7 && v30 != 1)
      {
        v16 = v20;
        v32 = v43;
        goto LABEL_68;
      }
    }
    else
    {
      *v21 = v24;
      v18 = 1;
    }
    if (!CFUniCharFillDestinationBuffer(v21, v18, (uint64_t *)&v52, v13, &v51, a8))
    {
      v16 = v20;
      goto LABEL_79;
    }
    v18 = 0;
    v31 = -2;
    if (!HIWORD(v24))
      v31 = -1;
    v16 = v20 + v31;
    v23 = v22;
    v20 = v16 - v17;
    if (v16 <= v17)
      goto LABEL_87;
  }
  if (v20 >= 2)
  {
    v27 = *v22;
    if ((v27 & 0xFC00) == 0xDC00)
    {
      v22 = v23 + 2;
      v24 = v27 + (v24 << 10) - 56613888;
      goto LABEL_20;
    }
  }
  if (!a8)
    goto LABEL_20;
  v23 = v22;
LABEL_76:
  if (a10)
    *a10 = v23 - a1;
  v13 = a5;
LABEL_79:
  v14 = a3;
  v12 = a6;
  v15 = a2;
  if (v18 < 1)
    goto LABEL_88;
LABEL_80:
  if ((unint64_t)v18 >= 2)
    __CFUniCharPrioritySort(v21, v18);
  if (CFUniCharFillDestinationBuffer(v21, v18, (uint64_t *)&v52, v13, &v51, a8))
    v41 = v17;
  else
    v41 = 0;
  v16 -= v41;
LABEL_88:
  if (v21 != (unsigned int *)v53)
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v21);
LABEL_90:
  if (v14)
    *v14 = v15 - v16;
  if (v12)
    *v12 = v51;
  return v16 < 1;
}

Boolean CFURLIsFileReferenceURL(CFURLRef url)
{
  CFURLRef v1;

  do
  {
    while (1)
    {
      v1 = url;
      if (!CF_IS_OBJC(0x1DuLL, (__objc2_class **)url))
        break;
      url = (CFURLRef)-[__CFURL baseURL](v1, "baseURL");
      if (!url)
        goto LABEL_5;
    }
    url = (CFURLRef)*((_QWORD *)v1 + 4);
  }
  while (url);
LABEL_5:
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)v1))
    return -[__CFURL isFileReferenceURL](v1, "isFileReferenceURL");
  else
    return (*((_DWORD *)v1 + 4) & 0xE0002000) == 1610620928;
}

UniChar *resolveAbsoluteURLString(const __CFAllocator *a1, const __CFString *a2, unsigned int a3, uint64_t a4, CFStringRef theString, unsigned int a6, CFIndex *a7)
{
  CFIndex Length;
  CFIndex v15;
  uint64_t v16;
  uint64_t v17;
  UniChar *result;
  UniChar *v19;
  CFMutableStringRef v20;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(theString);
  v15 = CFStringGetLength(a2);
  if (v15 + Length > 1024)
  {
    result = (UniChar *)malloc_type_malloc(2 * (v15 + Length), 0x1000040BDFB0063uLL);
    if (result)
    {
      v19 = result;
      v20 = resolveAbsoluteURLStringBuffer(a1, a2, a3, a4, theString, a6, a7, result);
      free(v19);
      return (UniChar *)v20;
    }
  }
  else
  {
    MEMORY[0x1E0C80A78](v15, v16);
    return (UniChar *)resolveAbsoluteURLStringBuffer(a1, a2, a3, a4, theString, a6, a7, (UniChar *)((char *)v21 - v17));
  }
  return result;
}

CFMutableStringRef resolveAbsoluteURLStringBuffer(const __CFAllocator *a1, const __CFString *a2, unsigned int a3, uint64_t a4, const __CFString *a5, unsigned int a6, CFIndex *a7, UniChar *a8)
{
  __CFString *Mutable;
  CFIndex v17;
  __CFString *v18;
  CFIndex v19;
  uint64_t v20;
  CFIndex Length;
  CFIndex v22;
  CFIndex v23;
  CFIndex v24;
  CFIndex v25;
  CFIndex v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  char v30;
  CFIndex *v31;
  CFIndex v32;
  CFIndex v33;
  CFIndex v34;
  UniChar *v35;
  CFIndex v36;
  unsigned int v37;
  unsigned int v38;
  char v39;
  CFIndex *v40;
  CFIndex v41;
  CFIndex v42;
  CFIndex v43;
  unsigned int v44;
  unsigned int v45;
  char v46;
  CFRange *v47;
  CFIndex location;
  char v49;
  UniChar *Typed;
  char *v51;
  uint64_t v52;
  UniChar *v53;
  UniChar *v54;
  const __CFString *v55;
  CFIndex v56;
  CFIndex v57;
  CFIndex v58;
  CFIndex v59;
  UniChar *v60;
  uint64_t v61;
  CFIndex v62;
  CFIndex v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  char v67;
  CFIndex *v68;
  CFIndex v69;
  CFIndex v70;
  CFIndex v71;
  CFIndex v72;
  unsigned int v73;
  unsigned int i;
  uint64_t v75;
  char v76;
  unsigned int v77;
  unsigned int v78;
  char v79;
  CFIndex v80;
  __CFString *v81;
  const UniChar *v82;
  CFIndex v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  CFIndex v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  char v91;
  CFIndex *v92;
  CFIndex v93;
  CFIndex v94;
  CFIndex v95;
  CFIndex v96;
  __CFString *v97;
  const UniChar *v98;
  CFIndex v99;
  unsigned int v100;
  unsigned int v101;
  char v102;
  CFIndex *v103;
  CFIndex v104;
  CFIndex v105;
  CFIndex v106;
  CFIndex v107;
  CFIndex v108;
  CFMutableStringRef result;
  unsigned int v110;
  unsigned int v111;
  char v112;
  CFIndex *v113;
  CFIndex v114;
  CFIndex v115;
  UniChar *v116;
  _OWORD v117[128];
  CFIndex numChars;
  CFMutableStringRef theString;
  uint64_t v120;
  CFRange v121;
  CFRange v122;
  CFRange v123;
  CFRange v124;
  CFRange v125;
  CFRange v126;
  CFRange v127;
  CFRange v128;
  CFRange v129;
  CFRange v130;
  CFRange v131;
  CFRange v132;
  CFRange v133;
  CFRange v134;

  v120 = *MEMORY[0x1E0C80C00];
  memset(v117, 0, 512);
  numChars = 0;
  Mutable = CFStringCreateMutable(a1, 0);
  v17 = 0;
  theString = Mutable;
  if ((a6 & 1) != 0)
  {
    if (*a7 == -1)
    {
      v17 = 0;
    }
    else
    {
      v18 = Mutable;
      v19 = a7[1];
      v121.length = v19;
      v121.location = *a7;
      CFStringGetCharacters(a5, v121, a8);
      if (v19 < 1025)
      {
        __memcpy_chk();
        v20 = numChars + v19;
        numChars += v19;
      }
      else
      {
        CFStringAppendCharacters(v18, a8, v19);
        v20 = numChars;
      }
      if (v20 >= 1024)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, v20);
        v20 = 0;
        numChars = 0;
      }
      *((_WORD *)v117 + v20) = 58;
      v17 = ++numChars;
    }
  }
  if ((a3 & 0x1E) != 0)
  {
    Length = CFStringGetLength(a2);
    v22 = numChars;
    if (Length >= 1025)
    {
      if (numChars)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        numChars = 0;
      }
      CFStringAppend(theString, a2);
      goto LABEL_158;
    }
    v34 = Length;
    if (numChars + Length >= 1025)
    {
      CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
      v22 = 0;
      numChars = 0;
    }
    v35 = (UniChar *)v117 + v22;
    v124.location = 0;
    v124.length = v34;
    CFStringGetCharacters(a2, v124, v35);
    v36 = numChars + v34;
LABEL_156:
    numChars = v36;
    if (!v36)
      return theString;
    goto LABEL_159;
  }
  if (v17 >= 1023)
  {
    CFStringAppendCharacters(theString, (const UniChar *)v117, v17);
    v17 = 0;
    numChars = 0;
  }
  *(_DWORD *)((char *)v117 + 2 * v17) = 3080239;
  numChars += 2;
  v23 = _netLocationRange(a6, (uint64_t)a7);
  if (v23 != -1)
  {
    v25 = v24;
    v122.location = v23;
    v122.length = v25;
    CFStringGetCharacters(a5, v122, a8);
    v26 = numChars;
    if (v25 < 1025)
    {
      if (numChars + v25 >= 1025)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        v26 = 0;
        numChars = 0;
      }
      memcpy((char *)v117 + 2 * v26, a8, 2 * v25);
      numChars += v25;
      if ((a3 & 0x20) == 0)
        goto LABEL_23;
      goto LABEL_37;
    }
    if (numChars)
    {
      CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
      numChars = 0;
    }
    CFStringAppendCharacters(theString, a8, v25);
  }
  if ((a3 & 0x20) == 0)
  {
LABEL_23:
    if ((a6 & 0x20) != 0)
    {
      v27 = 0;
      v28 = 32;
      v29 = a6;
      do
      {
        v30 = v28;
        v28 >>= 1;
        v27 += v29 & 1;
        v29 >>= 1;
      }
      while ((v30 & 2) == 0);
      v31 = &a7[2 * v27];
      if (*v31 != -1)
      {
        v32 = v31[1];
        v123.length = v32;
        v123.location = *v31;
        CFStringGetCharacters(a5, v123, a8);
        v33 = numChars;
        if (v32 < 1025)
        {
          if (numChars + v32 >= 1025)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            v33 = 0;
            numChars = 0;
          }
          memcpy((char *)v117 + 2 * v33, a8, 2 * v32);
          numChars += v32;
        }
        else
        {
          if (numChars)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            numChars = 0;
          }
          CFStringAppendCharacters(theString, a8, v32);
        }
      }
    }
    if ((a3 & 0x1C0) != 0)
    {
      if ((a3 & 0x40) == 0)
      {
        if ((a6 & 0x40) != 0)
        {
          v64 = 0;
          v65 = 64;
          v66 = a6;
          do
          {
            v67 = v65;
            v65 >>= 1;
            v64 += v66 & 1;
            v66 >>= 1;
          }
          while ((v67 & 2) == 0);
          v68 = &a7[2 * v64];
          v69 = *v68;
          if (*v68 != -1)
          {
            v70 = v68[1];
            v71 = numChars;
            if (numChars >= 1024)
            {
              CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
              v71 = 0;
              numChars = 0;
            }
            *((_WORD *)v117 + v71) = 59;
            ++numChars;
            v127.location = v69;
            v127.length = v70;
            CFStringGetCharacters(a5, v127, a8);
            v72 = numChars;
            if (v70 <= 1024)
            {
              if (numChars + v70 >= 1025)
              {
                CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
                v72 = 0;
                numChars = 0;
              }
              memcpy((char *)v117 + 2 * v72, a8, 2 * v70);
              numChars += v70;
            }
            else
            {
              if (numChars)
              {
                CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
                numChars = 0;
              }
              CFStringAppendCharacters(theString, a8, v70);
            }
          }
        }
        if ((a3 & 0x80) == 0)
          goto LABEL_168;
        v88 = 0;
        v89 = 128;
        v90 = a3;
        do
        {
          v91 = v89;
          v89 >>= 1;
          v88 += v90 & 1;
          v90 >>= 1;
        }
        while ((v91 & 2) == 0);
        v92 = (CFIndex *)(a4 + 16 * v88);
        v93 = *v92;
        if (*v92 == -1)
        {
LABEL_168:
          if ((a6 & 0x80) == 0)
            goto LABEL_146;
          v100 = 0;
          v101 = 128;
          do
          {
            v102 = v101;
            v101 >>= 1;
            v100 += a6 & 1;
            a6 >>= 1;
          }
          while ((v102 & 2) == 0);
          v103 = &a7[2 * v100];
          v104 = *v103;
          if (*v103 == -1)
          {
LABEL_146:
            if ((a3 & 0x100) == 0)
              goto LABEL_158;
            v110 = 0;
            v111 = 256;
            do
            {
              v112 = v111;
              v111 >>= 1;
              v110 += a3 & 1;
              a3 >>= 1;
            }
            while ((v112 & 2) == 0);
            v113 = (CFIndex *)(a4 + 16 * v110);
            v114 = *v113;
            if (*v113 == -1)
              goto LABEL_158;
            v63 = v113[1];
            v115 = numChars;
            if (numChars >= 1024)
            {
              CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
              v115 = 0;
              numChars = 0;
            }
            *((_WORD *)v117 + v115) = 35;
            ++numChars;
            v132.location = v114;
            v132.length = v63;
            CFStringGetCharacters(a2, v132, a8);
            v80 = numChars;
            if (v63 <= 1024)
              goto LABEL_153;
LABEL_98:
            if (v80)
            {
              CFStringAppendCharacters(theString, (const UniChar *)v117, v80);
              numChars = 0;
            }
            v81 = theString;
            v82 = a8;
            v83 = v63;
            goto LABEL_109;
          }
          v105 = v103[1];
          v106 = numChars;
          if (numChars >= 1024)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            v106 = 0;
            numChars = 0;
          }
          *((_WORD *)v117 + v106) = 63;
          ++numChars;
          v131.location = v104;
          v131.length = v105;
          CFStringGetCharacters(a5, v131, a8);
          v107 = numChars;
          if (v105 > 1024)
          {
            if (numChars)
            {
              CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
              numChars = 0;
            }
            v97 = theString;
            v98 = a8;
            v99 = v105;
            goto LABEL_136;
          }
          if (numChars + v105 >= 1025)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            v107 = 0;
            numChars = 0;
          }
          memcpy((char *)v117 + 2 * v107, a8, 2 * v105);
          v108 = numChars + v105;
        }
        else
        {
          v94 = v92[1];
          v95 = numChars;
          if (numChars >= 1024)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            v95 = 0;
            numChars = 0;
          }
          *((_WORD *)v117 + v95) = 63;
          ++numChars;
          v130.location = v93;
          v130.length = v94;
          CFStringGetCharacters(a2, v130, a8);
          v96 = numChars;
          if (v94 > 1024)
          {
            if (numChars)
            {
              CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
              numChars = 0;
            }
            v97 = theString;
            v98 = a8;
            v99 = v94;
LABEL_136:
            CFStringAppendCharacters(v97, v98, v99);
            goto LABEL_146;
          }
          if (numChars + v94 >= 1025)
          {
            CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
            v96 = 0;
            numChars = 0;
          }
          memcpy((char *)v117 + 2 * v96, a8, 2 * v94);
          v108 = numChars + v94;
        }
        numChars = v108;
        goto LABEL_146;
      }
      v77 = 0;
      v78 = 64;
      do
      {
        v79 = v78;
        v78 >>= 1;
        v77 += a3 & 1;
        a3 >>= 1;
      }
      while ((v79 & 2) == 0);
      v61 = *(_QWORD *)(a4 + 16 * v77) - 1;
      v63 = CFStringGetLength(a2) - v61;
LABEL_97:
      v128.location = v61;
      v128.length = v63;
      CFStringGetCharacters(a2, v128, a8);
      v80 = numChars;
      if (v63 < 1025)
      {
LABEL_153:
        if (v80 + v63 >= 1025)
        {
          CFStringAppendCharacters(theString, (const UniChar *)v117, v80);
          v80 = 0;
          numChars = 0;
        }
        memcpy((char *)v117 + 2 * v80, a8, 2 * v63);
        v36 = numChars + v63;
        goto LABEL_156;
      }
      goto LABEL_98;
    }
    v73 = 0;
    for (i = 256; i != 32; i >>= 1)
    {
      if ((i & a6) != 0)
        v73 = i;
    }
    if (v73)
    {
      if ((v73 & a6) != 0)
      {
        if ((v73 & 1) != 0)
        {
          v75 = 0;
        }
        else
        {
          LODWORD(v75) = 0;
          do
          {
            v76 = v73;
            v73 >>= 1;
            v75 = (a6 & 1) + v75;
            a6 >>= 1;
          }
          while ((v76 & 2) == 0);
        }
        v84 = a7[2 * v75];
      }
      else
      {
        v84 = -1;
      }
      v85 = CFStringGetLength(a5) - v84;
      v129.location = v84 - 1;
      v86 = v85 + 1;
      v129.length = v85 + 1;
      CFStringGetCharacters(a5, v129, a8);
      v87 = numChars;
      if (v85 < 1024)
      {
        if (numChars + v86 > 1024)
        {
          CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
          v87 = 0;
          numChars = 0;
        }
        memcpy((char *)v117 + 2 * v87, a8, 2 * v86);
        v36 = numChars + v86;
        goto LABEL_156;
      }
      if (numChars)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        numChars = 0;
      }
      v81 = theString;
      v82 = a8;
      v83 = v85 + 1;
LABEL_109:
      CFStringAppendCharacters(v81, v82, v83);
    }
LABEL_158:
    v36 = numChars;
    if (!numChars)
      return theString;
LABEL_159:
    CFStringAppendCharacters(theString, (const UniChar *)v117, v36);
    return theString;
  }
LABEL_37:
  v37 = 0;
  v38 = 32;
  do
  {
    v39 = v38;
    v38 >>= 1;
    v37 += a3 & 1;
    a3 >>= 1;
  }
  while ((v39 & 2) == 0);
  v40 = (CFIndex *)(a4 + 16 * v37);
  v41 = *v40;
  v42 = v40[1];
  if ((a6 & 0x20) == 0)
  {
    v43 = 0;
LABEL_52:
    v49 = 1;
LABEL_53:
    v134.location = v41;
    v134.length = v42;
    v55 = CFStringCreateWithSubstring(a1, a2, v134);
    goto LABEL_54;
  }
  v44 = 0;
  v45 = 32;
  do
  {
    v46 = v45;
    v45 >>= 1;
    v44 += a6 & 1;
    a6 >>= 1;
  }
  while ((v46 & 2) == 0);
  v47 = (CFRange *)&a7[2 * v44];
  location = v47->location;
  v43 = v47->length;
  if (v47->location == -1)
    goto LABEL_52;
  if (!v42)
  {
    v55 = CFStringCreateWithSubstring(a1, a5, *v47);
    v49 = 0;
    goto LABEL_54;
  }
  v49 = 0;
  if (CFStringGetCharacterAtIndex(a2, v41) == 47 || !v43)
    goto LABEL_53;
  Typed = (UniChar *)CFAllocatorAllocateTyped(a1, 2 * (v43 + v42) + 2, 0x1000040BDFB0063, 0);
  if (Typed)
  {
    v51 = (char *)Typed;
    v125.location = location;
    v125.length = v43;
    CFStringGetCharacters(a5, v125, Typed);
    v52 = 2 * v43;
    while (1)
    {
      v53 = (UniChar *)&v51[v52];
      v52 -= 2;
      if (!v52)
        break;
      if (*(v53 - 1) == 47)
      {
        v54 = (UniChar *)&v51[v52 + 2];
        goto LABEL_165;
      }
    }
    if (*(_WORD *)v51 == 47)
      v54 = v53;
    else
      v54 = (UniChar *)v51;
LABEL_165:
    v133.location = v41;
    v133.length = v42;
    CFStringGetCharacters(a2, v133, v54);
    v116 = &v54[v42];
    *v116 = 0;
    v55 = _resolvedPath(v51, (unint64_t)v116, 47, 0, 0, a1);
    v49 = 0;
    v43 = 1;
LABEL_54:
    if (((v49 & 1) != 0 || !v43) && CFStringGetCharacterAtIndex(v55, 0) != 47)
    {
      v56 = numChars;
      if (numChars >= 1024)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        v56 = 0;
        numChars = 0;
      }
      *((_WORD *)v117 + v56) = 47;
      ++numChars;
    }
    v57 = CFStringGetLength(v55);
    v58 = numChars;
    if (v57 < 1025)
    {
      v59 = v57;
      if (numChars + v57 >= 1025)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        v58 = 0;
        numChars = 0;
      }
      v60 = (UniChar *)v117 + v58;
      v126.location = 0;
      v126.length = v59;
      CFStringGetCharacters(v55, v126, v60);
      numChars += v59;
    }
    else
    {
      if (numChars)
      {
        CFStringAppendCharacters(theString, (const UniChar *)v117, numChars);
        numChars = 0;
      }
      CFStringAppend(theString, v55);
    }
    CFRelease(v55);
    v61 = v42 + v41;
    v62 = CFStringGetLength(a2);
    v63 = v62 - v61;
    if (v62 > v61)
      goto LABEL_97;
    goto LABEL_158;
  }
  result = theString;
  if (theString)
  {
    CFRelease(theString);
    return 0;
  }
  return result;
}

uint64_t _netLocationRange(unsigned int a1, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  int v4;
  __int128 v5;
  __int128 v6;
  unsigned int v7;
  unsigned int v8;
  char v9;
  uint64_t v10;
  uint64_t result;
  _OWORD v12[4];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if ((a1 & 0x1E) == 0)
    return -1;
  v2 = xmmword_182C87F40;
  v3 = xmmword_182C87F40;
  if ((a1 & 2) != 0)
    v3 = *(_OWORD *)(a2 + 16 * (a1 & 1));
  v12[0] = v3;
  v4 = (a1 >> 1) & 1;
  v5 = xmmword_182C87F40;
  if ((a1 & 4) != 0)
    v5 = *(_OWORD *)(a2 + 16 * (v4 + (a1 & 1)));
  v12[1] = v5;
  v6 = xmmword_182C87F40;
  if ((a1 & 8) != 0)
    v6 = *(_OWORD *)(a2 + 16 * (((a1 >> 2) & 1) + v4 + (a1 & 1)));
  v12[2] = v6;
  if ((a1 & 0x10) != 0)
  {
    v7 = 0;
    v8 = 16;
    do
    {
      v9 = v8;
      v8 >>= 1;
      v7 += a1 & 1;
      a1 >>= 1;
    }
    while ((v9 & 2) == 0);
    v2 = *(_OWORD *)(a2 + 16 * v7);
  }
  v10 = 0;
  v12[3] = v2;
  result = -1;
  do
  {
    if (*(_QWORD *)&v12[v10] != -1 && result == -1)
      result = *(_QWORD *)&v12[v10];
    ++v10;
  }
  while (v10 != 4);
  return result;
}

CFURLRef _CFPrefsCreatePreferencesDirectoryURLForTriplet(const __CFString *a1, int a2, const void *a3)
{
  const __CFURL *v7;
  uid_t v8;
  passwd *v9;
  CFIndex Length;
  unint64_t MaximumSizeForEncoding;
  CFIndex v12;
  char *v13;
  const char *pw_dir;
  size_t v15;
  const __CFURL *v16;
  const __CFString *v17;
  CFURLRef v18;
  char buffer[128];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!CFEqual(a1, CFSTR("kCFPreferencesAnyUser")))
  {
    if (a3)
    {
      v7 = (const __CFURL *)CFRetain(a3);
    }
    else
    {
      if (CFEqual(a1, CFSTR("kCFPreferencesCurrentUser")))
      {
        v8 = geteuid();
        v9 = getpwuid(v8);
      }
      else
      {
        Length = CFStringGetLength(a1);
        MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        v12 = MaximumSizeForEncoding;
        if (MaximumSizeForEncoding >= 0x7F)
          v13 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0x4525BEE4uLL);
        else
          v13 = buffer;
        if (CFStringGetCString(a1, v13, v12, 0x8000100u))
          v9 = getpwnam(v13);
        else
          v9 = 0;
        if (buffer != v13)
          free(v13);
      }
      if (v9 && (pw_dir = v9->pw_dir) != 0)
      {
        v15 = strlen(pw_dir);
        v7 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)pw_dir, v15, 1u);
      }
      else
      {
        v7 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("/var/empty"), kCFURLPOSIXPathStyle, 1u);
      }
    }
    v16 = v7;
    if (v7)
    {
      if (a2)
        v17 = CFSTR("Library/Preferences/ByHost/");
      else
        v17 = CFSTR("Library/Preferences/");
      v18 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, v17, kCFURLPOSIXPathStyle, 1u, v7);
      CFRelease(v16);
      return v18;
    }
    return 0;
  }
  if (_CFPrefsCurrentProcessIsCFPrefsD() && geteuid())
    return 0;
  if (a3)
    return CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("Library/Preferences/"), kCFURLPOSIXPathStyle, 1u, (CFURLRef)a3);
  else
    return CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("/private/var/preferences"), kCFURLPOSIXPathStyle, 1u);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)_CFURLCreateWithFileSystemRepresentation(allocator, (char *)buffer, bufLen, isDirectory, 0);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  va_list va;

  va_start(va, format);
  return CFStringCreateWithFormatAndArguments(alloc, formatOptions, format, va);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  if (CF_IS_OBJC(7uLL, (__objc2_class **)format) && _CFStringObjCFormatRequiresInflection((void *)format))
    return (CFStringRef)_CFStringCreateFormatWithInflectionAndArguments((uint64_t)alloc, (uint64_t)formatOptions, (uint64_t)format, (uint64_t)arguments);
  else
    return _CFStringCreateWithFormatAndArgumentsReturningMetadata(alloc, 0, 0, (uint64_t)formatOptions, 0, 0, (uint64_t)format, 0, (__int16 *)arguments);
}

uint64_t _CFAutoreleasePoolAddObject()
{
  if (__CFOASafe)
    __CFRecordAllocationEvent();
  return _objc_rootAutorelease();
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return (CFLocaleRef)(id)+[NSLocale _current](NSLocale, "_current");
}

void CFDateFormatterSetProperty(CFDateFormatterRef formatter, CFStringRef key, CFTypeRef value)
{
  unint64_t v6;

  v6 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v6 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v6);
  __CFDateFormatterSetProperty((uint64_t)formatter, key, (__CFString *)value, 0);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return (CFDateFormatterRef)__CreateCFDateFormatter((__objc2_class **)allocator, locale, dateStyle, timeStyle, &__kCFBooleanFalse);
}

BOOL _CFStringObjCFormatRequiresInflection(void *a1)
{
  Class Class;

  Class = object_getClass(a1);
  if (__NSGetCFLocalizedAttributedStringClass_onceToken != -1)
    dispatch_once(&__NSGetCFLocalizedAttributedStringClass_onceToken, &__block_literal_global_96_0);
  return Class == (Class)__NSCFLocalizedAttributedStringClass;
}

uint64_t _CFURLCreateCurrentDirectoryURL(int a1)
{
  int v2;
  char __s[1026];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (!_CFGetCurrentDirectory(__s, 1026))
    return 0;
  v2 = strlen(__s);
  return _CFURLCreateWithFileSystemRepresentation(a1, __s, v2, 1, 0);
}

BOOL _CFGetCurrentDirectory(char *a1, int a2)
{
  return getcwd(a1, a2) != 0;
}

BOOL _CFPreferencesGetAppBooleanValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, Boolean *a4)
{
  __objc2_class **v5;
  _BOOL8 BooleanValueWithValue;

  v5 = (__objc2_class **)_CFPreferencesCopyAppValueWithContainerAndConfiguration(a1, a2, a3, 0);
  BooleanValueWithValue = _CFPreferencesGetBooleanValueWithValue(v5, a4);
  if (v5)
    CFRelease(v5);
  return BooleanValueWithValue;
}

CFStringRef CFCopyUserName()
{
  uid_t v0;
  passwd *v1;
  char *pw_name;
  CFStringRef result;
  uid_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v4 = 0;
  __CFGetUGIDs(&v4, 0);
  v0 = v4;
  if (!v4)
    v0 = getuid();
  v1 = getpwuid(v0);
  if (!v1 || (pw_name = v1->pw_name) == 0)
  {
    pw_name = __CFgetenv("USER");
    if (!pw_name)
      return (CFStringRef)CFRetain(&stru_1E1337B18);
  }
  result = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, pw_name, 0x8000100u);
  if (!result)
    return (CFStringRef)CFRetain(&stru_1E1337B18);
  return result;
}

uint64_t _CFPreferencesCopyValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v10;
  uint64_t v11;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v10 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v11 = objc_msgSend(v10, "copyValueForKey:identifier:user:host:container:", a1, a2, a3, a4, a5);

  return v11;
}

uint64_t _CFPreferencesCopyAppValueWithContainerAndConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  uint64_t v9;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v8 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v9 = objc_msgSend(v8, "copyAppValueForKey:identifier:container:configurationURL:", a1, a2, a3, a4);

  return v9;
}

uint64_t _CFPrefsCurrentProcessIsCFPrefsD()
{
  return isCFPrefsD;
}

uint64_t _CFGetEUID()
{
  unsigned int v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  __CFGetUGIDs(&v1, 0);
  return v1;
}

unint64_t __CFGetUGIDs(_DWORD *a1, _DWORD *a2)
{
  unint64_t result;
  unint64_t v5;
  _QWORD v6[6];

  v6[5] = *MEMORY[0x1E0C80C00];
  if (_CFCanChangeEUIDs_onceToken != -1)
    dispatch_once(&_CFCanChangeEUIDs_onceToken, &__block_literal_global_87);
  if (_CFCanChangeEUIDs_canChangeEUIDs)
  {
    result = ____CFGetUGIDs_block_invoke();
    v5 = HIDWORD(result);
    if (!a1)
      goto LABEL_6;
    goto LABEL_5;
  }
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = ____CFGetUGIDs_block_invoke_2;
  v6[3] = &unk_1E1333B58;
  v6[4] = &__block_literal_global_59;
  if (__CFGetUGIDs_onceToken != -1)
    dispatch_once(&__CFGetUGIDs_onceToken, v6);
  result = __CFGetUGIDs_cachedUGIDs;
  LODWORD(v5) = HIDWORD(__CFGetUGIDs_cachedUGIDs);
  if (a1)
LABEL_5:
    *a1 = result;
LABEL_6:
  if (a2)
    *a2 = v5;
  return result;
}

void sub_182AF5B10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void normalizeQuintuplet(__CFString *theString, const __CFString *a2, unsigned __int8 a3, CFStringRef a4, uint64_t a5, uint64_t a6)
{
  const __CFString *v8;
  __CFString *v10;
  __CFString *v11;
  const __CFString *v12;
  CFStringRef v13;
  BOOL v14;
  uint64_t CacheStringForBundleID;
  __int16 v16;
  CFTypeRef v17;
  CFTypeRef v18;
  CFTypeRef cf;
  unsigned __int8 v20;
  uint64_t v21;
  CFRange v22;

  v8 = a4;
  v10 = theString;
  v21 = *MEMORY[0x1E0C80C00];
  v20 = a3;
  v18 = 0;
  cf = 0;
  v17 = 0;
  if (a4)
  {
    if (CFStringHasPrefix(a4, CFSTR("/private/var/containers/Shared/SystemGroup"))
      || CFStringHasPrefix(v8, CFSTR("/var/containers/Shared/SystemGroup")))
    {
      a2 = CFSTR("kCFPreferencesAnyUser");
      v20 = 1;
    }
LABEL_8:
    if (CFStringHasSuffix(v10, CFSTR(".plist")))
    {
      v22.length = CFStringGetLength(v10) - 6;
      v22.location = 0;
      v11 = (__CFString *)CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v10, v22);
      cf = v11;
    }
    else
    {
      v11 = (__CFString *)cf;
    }
    goto LABEL_11;
  }
  if (CFStringGetCharacterAtIndex(theString, 0) != 47)
    goto LABEL_8;
  if ((_DWORD)a5)
    normalizeQuintuplet_cold_1();
  v16 = 0;
  _CFPrefsExtractQuadrupleFromPathIfPossible(v10, (CFStringRef *)&cf, (CFStringRef *)&v18, &v17, &v20, (_BYTE *)&v16 + 1, &v16);
  v11 = (__CFString *)cf;
  if (!cf)
    goto LABEL_8;
LABEL_11:
  if (v17)
    v8 = (const __CFString *)v17;
  if (v11)
    v10 = v11;
  if (v18)
    v12 = (const __CFString *)v18;
  else
    v12 = a2;
  v13 = _CFPrefsCopyUserForContainer(v12, v8);
  if (CFEqual(CFSTR("kCFPreferencesAnyUser"), v13))
    v14 = v20 == 0;
  else
    v14 = 0;
  if (v14)
    v20 = 1;
  CacheStringForBundleID = _CFPrefsGetCacheStringForBundleID(v10);
  (*(void (**)(uint64_t, uint64_t, CFStringRef, _QWORD, const __CFString *, uint64_t))(a6 + 16))(a6, CacheStringForBundleID, v13, v20, v8, a5);
  if (cf)
    CFRelease(cf);
  if (v17)
    CFRelease(v17);
  if (v18)
    CFRelease(v18);
  if (v13)
    CFRelease(v13);
}

CFStringRef _CFPrefsCopyUserForContainer(const __CFString *cf1, CFStringRef theString)
{
  const __CFString *v3;
  CFStringRef v4;
  int v5;
  BOOL v6;

  if (theString && CFStringHasPrefix(theString, CFSTR("/private/var/containers/Shared/SystemGroup/")))
    return CFSTR("kCFPreferencesAnyUser");
  if (CFEqual(cf1, CFSTR("kCFPreferencesCurrentUser")))
    return CFSTR("kCFPreferencesCurrentUser");
  v3 = CFSTR("kCFPreferencesAnyUser");
  if (!CFEqual(cf1, CFSTR("kCFPreferencesAnyUser")))
  {
    v4 = CFCopyUserName();
    v5 = CFEqual(cf1, v4);
    CFRelease(v4);
    v6 = !CFSTR("kCFPreferencesCurrentUser") || v5 == 0;
    v3 = CFSTR("kCFPreferencesCurrentUser");
    if (v6)
      return CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, cf1);
  }
  return v3;
}

void sub_182AF6238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_list va;

  va_start(va, a14);
  objc_end_catch();
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182AF6468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  uint64_t v14;
  va_list va;

  va_start(va, a14);
  objc_end_catch();
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v14 - 120), 8);
  _Unwind_Resume(a1);
}

BOOL _CFPrefsArmPendingKVOSlot()
{
  uint64_t v0;

  v0 = _CFGetTSD(0x10u);
  if (!v0)
    _CFSetTSD(0x10u, 16, (uint64_t)dummyKVODestructor);
  return v0 == 0;
}

uint64_t _CFSetTSD(unsigned int a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  char *v7;
  uint64_t result;

  if (a1 >= 0x46)
    _CFSetTSD_cold_1(a1);
  v6 = (char *)__CFTSDGetTable(1);
  if (v6)
  {
    v7 = &v6[8 * a1];
    result = *((_QWORD *)v7 + 1);
    *((_QWORD *)v7 + 1) = a2;
    *((_QWORD *)v7 + 71) = a3;
  }
  else
  {
    _CFLogSimple(4, "Warning: TSD slot %d set but the thread data has already been torn down.", a1);
    return 0;
  }
  return result;
}

void sub_182AF6D2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(exception_object);
}

uint64_t generationCountFromListOfSources(id *a1, uint64_t a2, _BYTE *a3, __n128 a4)
{
  uint64_t v5;
  uint64_t v7;
  unsigned __int16 *v8;
  const __CFArray *v9;
  CFIndex Count;
  uint64_t v11;
  CFIndex v12;
  uint64_t v13;
  const void **v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unint64_t v19;
  const void *v20;
  NSObject *v21;
  double Current;
  double v23;
  double v24;
  _BOOL4 v25;
  unsigned int v26;
  uint64_t v28;
  unint64_t v29;
  int v30;
  uint64_t v32;
  os_log_t v33;
  __n128 v34;
  __n128 v35;
  __objc2_class **v36;
  uint8_t buf[4];
  _BYTE v38[10];
  __int16 v39;
  unsigned int v40;
  __int16 v41;
  unsigned int v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  CFRange v46;

  v45 = *MEMORY[0x1E0C80C00];
  if (a2 >= 1)
  {
    v5 = a2;
    v7 = 0;
    v36 = &__kCFBooleanTrue;
    a4.n128_u64[0] = 138543362;
    v35 = a4;
    a4.n128_u64[0] = 67110146;
    v34 = a4;
    while (1)
    {
      v8 = (unsigned __int16 *)*a1;
      if (*((_BYTE *)*a1 + 56))
      {
        v9 = (const __CFArray *)*((_QWORD *)v8 + 12);
        if (v9)
        {
          Count = CFArrayGetCount(v9);
          v12 = Count;
          if (Count >= 1)
          {
            MEMORY[0x1E0C80A78](Count, v11);
            v14 = (const void **)((char *)&v32 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
            v46.location = 0;
            v46.length = v12;
            CFArrayGetValues(*((CFArrayRef *)v8 + 12), v46, v14);
            v7 += generationCountFromListOfSources(v14, v12, a3);
          }
        }
        goto LABEL_33;
      }
      v15 = (unsigned int *)atomic_load((unint64_t *)v8 + 5);
      if (!v15)
        break;
      v16 = atomic_load(v15);
      v17 = atomic_load((unsigned int *)&sentinelGeneration);
      if (v16 != v17)
      {
        v18 = atomic_load((unsigned int *)v8 + 12);
        if (v16 != v18)
        {
          Current = CFAbsoluteTimeGetCurrent();
          v23 = *((double *)v8 + 8);
          if (v23 == 0.0)
          {
            *((double *)v8 + 8) = Current;
            v8[36] = 1;
            goto LABEL_32;
          }
          v24 = Current - v23;
          if (Current - v23 >= 0.5)
          {
            *((_QWORD *)v8 + 8) = 0;
            v26 = v8[36];
            v25 = v26 > 0xFA;
            if (v26 > 0xFA)
              v24 = 0.5;
          }
          else
          {
            v25 = 0;
            v26 = ++v8[36];
          }
          if (v26 - 251 >= 9 && !v25)
            goto LABEL_32;
          v28 = objc_msgSend(v8, "copyOSLogDescription");
          _CFSetTSD(0xFu, (uint64_t)v36, 0);
          if (makeLogHandles_logToken != -1)
            dispatch_once(&makeLogHandles_logToken, &__block_literal_global_143);
          v33 = (os_log_t)clientHandle;
          if (os_log_type_enabled((os_log_t)clientHandle, OS_LOG_TYPE_ERROR))
          {
            v30 = v8[36];
            *(_DWORD *)buf = v34.n128_u32[0];
            *(_DWORD *)v38 = v30;
            *(_WORD *)&v38[4] = 1024;
            *(_DWORD *)&v38[6] = (int)(v24 * 1000.0);
            v39 = 1024;
            v40 = v16;
            v41 = 1024;
            v42 = v18;
            v43 = 2114;
            v20 = (const void *)v28;
            v44 = v28;
            _os_log_error_impl(&dword_182A8C000, v33, OS_LOG_TYPE_ERROR, "Source was stale %i times within the last %i ms (%i (latestGeneration) != %i (lastKnownShmemState)): %{public}@", buf, 0x24u);
          }
          else
          {
            v20 = (const void *)v28;
          }
          goto LABEL_31;
        }
      }
      v19 = atomic_load((unint64_t *)v8 + 4);
      v7 += v19;
LABEL_33:
      ++a1;
      if (!--v5)
        return v7;
    }
    if (!*((_QWORD *)v8 + 2))
    {
LABEL_32:
      v29 = atomic_load((unint64_t *)v8 + 4);
      v7 += v29;
      *a3 = 1;
      goto LABEL_33;
    }
    v20 = (const void *)objc_msgSend(*a1, "copyOSLogDescription");
    _CFSetTSD(0xFu, (uint64_t)v36, 0);
    if (makeLogHandles_logToken != -1)
      dispatch_once(&makeLogHandles_logToken, &__block_literal_global_143);
    v21 = clientHandle;
    if (os_log_type_enabled((os_log_t)clientHandle, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = v35.n128_u32[0];
      *(_QWORD *)v38 = v20;
      _os_log_error_impl(&dword_182A8C000, v21, OS_LOG_TYPE_ERROR, "Source was stale because shmem was null: %{public}@", buf, 0xCu);
    }
LABEL_31:
    _CFSetTSD(0xFu, 0, 0);
    CFRelease(v20);
    goto LABEL_32;
  }
  return 0;
}

void sub_182AF7744(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182AF775C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182AF7774(uint64_t a1, int a2)
{
  if (a2)
    objc_terminate();
  JUMPOUT(0x182AF7780);
}

void _CFPrefsExtractQuadrupleFromPathIfPossible(const __CFString *a1, CFStringRef *a2, CFStringRef *a3, CFTypeRef *a4, _BYTE *a5, _BYTE *a6, _BYTE *a7)
{
  const __CFString *v13;
  CFRange v14;
  const __CFString *v15;
  CFStringRef v16;
  CFStringRef v17;
  CFIndex location;
  CFIndex v19;
  CFRange v20;
  CFIndex v21;
  int v22;
  CFMutableStringRef MutableCopy;
  CFRange v24;
  CFIndex v25;
  CFRange v26;
  const __CFString *v27;
  CFRange v28;
  CFIndex v29;
  CFIndex length;
  CFRange v31;
  CFRange v32;
  uint64_t v33;
  CFIndex v34;
  CFIndex v35;
  CFStringRef v36;
  CFIndex v37;
  CFRange v38;
  CFRange v39;
  CFIndex v40;
  const __CFString *v41;
  CFIndex v42;
  CFIndex v43;
  CFIndex v44;
  CFStringRef v45;
  const __CFString *v46;
  int v47;
  int v48;
  CFStringEncoding SystemEncoding;
  CFStringRef v50;
  CFStringRef v51;
  const __CFString *v52;
  CFStringRef Copy;
  CFStringRef v54;
  int v55;
  const char *v56;
  const __CFString *v57;
  CFRange v58;
  const CFStringRef *v59;
  const __CFString *v60;
  CFRange v61;
  CFStringRef *v62;
  _BYTE *v63;
  _BYTE *v64;
  CFStringRef *v65;
  CFTypeRef *v66;
  char buffer[16];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  CFRange result;
  uint64_t v72;
  CFRange v73;
  CFRange v74;
  CFRange v75;
  CFRange v76;
  CFRange v77;
  CFRange v78;
  CFRange v79;
  CFRange v80;
  CFRange v81;
  CFRange v82;
  CFRange v83;
  CFRange v84;
  CFRange v85;
  CFRange v86;

  v72 = *MEMORY[0x1E0C80C00];
  *a7 = 0;
  if (!a1)
    return;
  v13 = a1;
  if (CFStringGetCharacterAtIndex(a1, 0) != 47 && CFStringFind(v13, CFSTR(".."), 0).location == -1)
    return;
  if (CFStringHasSuffix(v13, CFSTR(".plist")))
    CFRetain(v13);
  else
    v13 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@.plist"), v13);
  v65 = a2;
  v66 = a4;
  v63 = a7;
  v64 = a6;
  if (CFStringFind(v13, CFSTR("/containers/Shared/SystemGroup/"), 0).location == -1
    || (v14 = CFStringFind(v13, CFSTR("/Library/Preferences/"), 4uLL), v14.location == -1))
  {
    v17 = 0;
    v16 = 0;
    v15 = 0;
  }
  else
  {
    v73.length = CFStringGetLength(v13) - (v14.location + v14.length);
    v73.location = v14.location + v14.length;
    v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v73);
    v74.length = v14.location + 1;
    v74.location = 0;
    v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v74);
    v17 = CFSTR("kCFPreferencesAnyUser");
  }
  location = CFStringFind(v13, CFSTR("/Containers/Shared/AppGroup/"), 0).location;
  if (location >= 1)
  {
    v19 = location;
    v20 = CFStringFind(v13, CFSTR("/Library/Preferences/"), 4uLL);
    if (v20.location != -1)
    {
      v21 = CFStringGetLength(v13) - (v20.location + v20.length);
      if (v15)
        CFRelease(v15);
      v75.location = v20.location + v20.length;
      v75.length = v21;
      v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v75);
      if (v16)
        CFRelease(v16);
      v76.length = v20.location + 1;
      v76.location = 0;
      v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v76);
      result.length = 0;
      result.location = 0;
      v77.location = 0;
      v77.length = v19;
      if (!CFStringFindWithOptions(v13, CFSTR("/"), v77, 4uLL, &result))
        _CFPrefsExtractQuadrupleFromPathIfPossible_cold_1();
      v78.location = result.location + 1;
      v78.length = v19 - (result.location + 1);
      v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, v78);
    }
  }
  if (v15)
  {
    CFRelease(v13);
    v22 = 0;
    goto LABEL_43;
  }
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v13);
  CFRelease(v13);
  v24 = CFStringFind(MutableCopy, CFSTR("/private/var/preferences/"), 8uLL);
  if (v24.location == -1)
  {
    v28 = CFStringFind(MutableCopy, CFSTR("/private/var/"), 8uLL);
    if (v28.location == -1)
      goto LABEL_26;
    v25 = v28.location;
    v26.length = v28.length;
    v27 = CFSTR("/var/");
  }
  else
  {
    v25 = v24.location;
    v26.length = v24.length;
    v27 = CFSTR("/Library/Preferences/");
  }
  v26.location = v25;
  CFStringReplace(MutableCopy, v26, v27);
LABEL_26:
  v31 = CFStringFind(MutableCopy, CFSTR("/Containers/Data/Application/"), 0);
  length = v31.length;
  v29 = v31.location;
  if (v31.location == -1)
  {
    v32 = CFStringFind(MutableCopy, CFSTR("/Applications/"), 0);
    length = v32.length;
    v29 = v32.location;
    result.length = 0;
    result.location = 0;
    if (v32.location == -1)
      goto LABEL_33;
  }
  else
  {
    result.length = 0;
    result.location = 0;
  }
  v33 = v29 + length + 1;
  v79.length = CFStringGetLength(MutableCopy) - v33;
  v79.location = v33;
  if (CFStringFindWithOptions(MutableCopy, CFSTR("/"), v79, 0, &result))
  {
    if (v16)
      CFRelease(v16);
    v80.length = result.location;
    v80.location = 0;
    v16 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v80);
    v34 = result.location;
    v35 = CFStringGetLength(MutableCopy);
    v81.length = v35 - result.location;
    v81.location = v34;
    v36 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v81);
    CFRelease(MutableCopy);
    MutableCopy = (CFMutableStringRef)v36;
  }
LABEL_33:
  v38 = CFStringFind(MutableCopy, CFSTR("/var/Managed Preferences/"), 8uLL);
  v37 = v38.length;
  if (v38.location != -1
    || (v39 = CFStringFind(MutableCopy, CFSTR("/Library/Managed Preferences/"), 8uLL),
        v37 = v39.length,
        v39.location != -1))
  {
    v40 = v37;
    *v64 = 1;
    v82.length = CFStringGetLength(MutableCopy) - v37;
    v82.location = v40;
    v41 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v82);
    CFRelease(MutableCopy);
    v42 = CFStringFind(v41, CFSTR("/"), 0).location;
    if (v42 == -1)
    {
      v15 = (const __CFString *)CFRetain(v41);
      if (v17)
        CFRelease(v17);
      v22 = 0;
      v17 = CFSTR("kCFPreferencesAnyUser");
    }
    else
    {
      v43 = v42;
      if (v17)
        CFRelease(v17);
      v83.location = 0;
      v83.length = v43;
      v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v41, v83);
      v44 = v43 + 1;
      v84.length = CFStringGetLength(v41) - v44;
      v84.location = v44;
      v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v41, v84);
      v22 = 1;
    }
LABEL_42:
    CFRelease(v41);
    if (v15)
    {
LABEL_43:
      if (CFStringHasSuffix(v15, CFSTR(".plist")))
      {
        v85.length = CFStringGetLength(v15) - 6;
        v85.location = 0;
        v45 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v85);
        CFRelease(v15);
        v15 = v45;
      }
      *v65 = v15;
      v46 = CFSTR("kCFPreferencesNoContainer");
      if (v16)
        v46 = v16;
      *v66 = v46;
      bzero(&result, 0x400uLL);
      v70 = 0u;
      v69 = 0u;
      if (!_CFPrefsGetImpersonatedApplicationAuditToken(&v69))
      {
        if (_CFAuditTokenForSelf_onceToken != -1)
          dispatch_once(&_CFAuditTokenForSelf_onceToken, &__block_literal_global_21);
        v69 = _CFAuditTokenForSelf_auditToken;
        v70 = unk_1ECCFA5A0;
      }
      *(_OWORD *)buffer = v69;
      v68 = v70;
      v47 = sandbox_container_path_for_audit_token();
      v48 = CFEqual(*v66, CFSTR("kCFPreferencesNoContainer"));
      if (v47)
      {
        if (v48)
        {
          *v66 = 0;
          goto LABEL_64;
        }
      }
      else if (v48)
      {
        bzero(buffer, 0x400uLL);
        if (CFStringGetCString(*v65, buffer, 1024, 0x8000100u)
          && (!sandbox_check_by_audit_token() || !sandbox_check_by_audit_token()))
        {
          *v66 = 0;
        }
      }
      else
      {
        SystemEncoding = CFStringGetSystemEncoding();
        v50 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const char *)&result, SystemEncoding, (CFAllocatorRef)&__kCFAllocatorNull);
        if (CFEqual(*v66, v50))
        {
          CFRelease(*v66);
          *v66 = 0;
        }
        CFRelease(v50);
      }
      if (*v66)
      {
        v51 = _CFPrefsCopyUserForContainer(v17, (CFStringRef)*v66);
        CFRelease(v17);
        v17 = v51;
      }
LABEL_64:
      if (CFEqual(v17, CFSTR("wireless")))
      {
        CFRelease(v17);
        v17 = CFSTR("_wireless");
      }
      if (!eduModeEnabled())
        goto LABEL_82;
      v52 = _CFPrefsCopyUsernameForMobileUser();
      if (CFEqual(v17, v52))
      {
        CFRelease(v17);
        if (CFEqual(CFSTR("mobile"), CFSTR("kCFPreferencesCurrentUser")))
        {
          v17 = CFSTR("kCFPreferencesCurrentUser");
LABEL_81:
          CFRelease(v52);
LABEL_82:
          *a3 = v17;
          if (CFEqual(v17, CFSTR("kCFPreferencesAnyUser")))
            *a5 = 1;
          return;
        }
        v17 = CFSTR("kCFPreferencesAnyUser");
        if (CFEqual(CFSTR("mobile"), CFSTR("kCFPreferencesAnyUser")))
          goto LABEL_81;
        v54 = CFCopyUserName();
        v55 = CFEqual(CFSTR("mobile"), v54);
        CFRelease(v54);
        if (CFSTR("kCFPreferencesCurrentUser"))
        {
          v17 = CFSTR("kCFPreferencesCurrentUser");
          if (v55)
            goto LABEL_81;
        }
        Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("mobile"));
      }
      else
      {
        if (!v22)
          goto LABEL_81;
        if (_CFPrefsExtractQuadrupleFromPathIfPossible_onceToken != -1)
          dispatch_once(&_CFPrefsExtractQuadrupleFromPathIfPossible_onceToken, &__block_literal_global_43);
        if (!_CFPrefsExtractQuadrupleFromPathIfPossible_mobileHome
          || CFStringFind((CFStringRef)_CFPrefsExtractQuadrupleFromPathIfPossible_mobileHome, v17, 0).location == -1)
        {
          goto LABEL_81;
        }
        CFRelease(v17);
        Copy = _CFPrefsCopyUserConstantForUserName(CFSTR("mobile"));
      }
      v17 = Copy;
      goto LABEL_81;
    }
    goto LABEL_108;
  }
  v62 = a3;
  *v64 = 0;
  v56 = (const char *)_CFGetCachedUnsandboxedHomeDirectoryForCurrentUser();
  v57 = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v56);
  v58 = CFStringFind(MutableCopy, CFSTR("/Library/Preferences/"), 0);
  if (v58.location == -1)
  {
    v22 = 0;
  }
  else if (v58.location)
  {
    if (CFStringHasPrefix(MutableCopy, CFSTR("/var/db/")))
    {
      if (v17)
        CFRelease(v17);
      v61.length = v58.location - 8;
      v60 = MutableCopy;
      v61.location = 8;
    }
    else
    {
      if (!CFStringHasPrefix(MutableCopy, CFSTR("/var/")))
      {
        if (!v57)
        {
          v22 = 0;
          goto LABEL_104;
        }
        if (CFStringHasPrefix(MutableCopy, v57))
        {
          if (v17)
            CFRelease(v17);
          v22 = 0;
          v17 = CFSTR("kCFPreferencesCurrentUser");
        }
        else
        {
          v22 = 0;
        }
        goto LABEL_103;
      }
      if (v17)
        CFRelease(v17);
      v61.length = v58.location - 5;
      v60 = MutableCopy;
      v61.location = 5;
    }
    v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v60, v61);
    v22 = 1;
  }
  else
  {
    if (v17)
      CFRelease(v17);
    v22 = 0;
    v59 = &kCFPreferencesCurrentUser;
    if (!v16)
      v59 = &kCFPreferencesAnyUser;
    v17 = *v59;
  }
  if (v57)
LABEL_103:
    CFRelease(v57);
LABEL_104:
  if (v58.location != -1 && v17)
  {
    v86.length = CFStringGetLength(MutableCopy) - (v58.location + v58.length);
    v86.location = v58.location + v58.length;
    v15 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, MutableCopy, v86);
    v41 = MutableCopy;
    a3 = v62;
    goto LABEL_42;
  }
  CFRelease(MutableCopy);
LABEL_108:
  *v63 = 1;
  if (v16)
    CFRelease(v16);
  if (v17)
    CFRelease(v17);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  int v6;
  BOOL v7;
  CFIndex location;
  CFIndex length;
  CFRange result;
  uint64_t v11;
  CFRange v12;
  CFRange v13;

  v11 = *MEMORY[0x1E0C80C00];
  result.location = 0;
  result.length = 0;
  v13.length = CFStringGetLength(theString);
  v13.location = 0;
  v6 = CFStringFindWithOptionsAndLocale(theString, stringToFind, v13, compareOptions, 0, &result);
  v7 = v6 == 0;
  if (v6)
    location = result.location;
  else
    location = -1;
  if (v7)
    length = 0;
  else
    length = result.length;
  v12.length = length;
  v12.location = location;
  return v12;
}

CFTypeRef _copyValueForKey(uint64_t a1, void *key)
{
  unsigned __int8 v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  double Current;
  double v10;
  const void *v11;
  NSObject *v12;
  const __CFDictionary *v14;
  __CFString *Value;
  const __CFDictionary *v16;
  NSObject *v17;
  void *v18;
  NSObject *v19;
  NSObject *v20;
  double v22;
  _BOOL4 v23;
  unsigned int v24;
  const void *v26;
  NSObject *v27;
  int v28;
  _BYTE v29[24];
  void *v30;
  uint64_t v31;
  uint8_t buf[4];
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  unsigned int v37;
  __int16 v38;
  unsigned int v39;
  __int16 v40;
  const void *v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (byte_1EDCCE379)
    objc_msgSend((id)a1, "alreadylocked_clearCache");
  *(_QWORD *)v29 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v29[8] = 3221225472;
  *(_QWORD *)&v29[16] = __alreadylocked_requestNewDataIfStale_block_invoke;
  v30 = &unk_1E12E5C68;
  v31 = a1;
  v4 = atomic_load((unsigned __int8 *)(a1 + 121));
  if ((v4 & 1) == 0)
  {
    v5 = (unsigned int *)atomic_load((unint64_t *)(a1 + 40));
    if (!v5)
    {
      if (*(_QWORD *)(a1 + 16))
      {
        v11 = (const void *)objc_msgSend((id)a1, "copyOSLogDescription", *(_QWORD *)v29, *(_QWORD *)&v29[8]);
        _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
        v12 = _CFPrefsClientLog();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          _copyValueForKey_cold_2();
        _CFSetTSD(0xFu, 0, 0);
        CFRelease(v11);
      }
      goto LABEL_13;
    }
    v6 = atomic_load(v5);
    v7 = atomic_load((unsigned int *)&sentinelGeneration);
    if (v6 != v7)
    {
      v8 = atomic_load((unsigned int *)(a1 + 48));
      if (v6 != v8)
      {
        Current = CFAbsoluteTimeGetCurrent();
        v10 = *(double *)(a1 + 64);
        if (v10 == 0.0)
        {
          *(double *)(a1 + 64) = Current;
          *(_WORD *)(a1 + 72) = 1;
        }
        else
        {
          v22 = Current - v10;
          if (Current - v10 >= 0.5)
          {
            *(_QWORD *)(a1 + 64) = 0;
            v24 = *(unsigned __int16 *)(a1 + 72);
            v23 = v24 > 0xFA;
            if (v24 > 0xFA)
              v22 = 0.5;
          }
          else
          {
            v23 = 0;
            v24 = (unsigned __int16)++*(_WORD *)(a1 + 72);
          }
          if (v24 - 251 < 9 || v23)
          {
            v26 = (const void *)objc_msgSend((id)a1, "copyOSLogDescription", *(_QWORD *)v29, *(_QWORD *)&v29[8]);
            _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
            v27 = _CFPrefsClientLog();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              v28 = *(unsigned __int16 *)(a1 + 72);
              *(_DWORD *)buf = 67110146;
              v33 = v28;
              v34 = 1024;
              v35 = (int)(v22 * 1000.0);
              v36 = 1024;
              v37 = v6;
              v38 = 1024;
              v39 = v8;
              v40 = 2114;
              v41 = v26;
              _os_log_error_impl(&dword_182A8C000, v27, OS_LOG_TYPE_ERROR, "Source was stale %i times within the last %i ms (%i (latestGeneration) != %i (lastKnownShmemState)): %{public}@", buf, 0x24u);
            }
            _CFSetTSD(0xFu, 0, 0);
            CFRelease(v26);
          }
        }
LABEL_13:
        os_unfair_lock_assert_owner((const os_unfair_lock *)(a1 + 52));
        (*(void (**)(_BYTE *))&v29[16])(v29);
      }
    }
  }
  if (atomic_load((unint64_t *)(a1 + 104)))
  {
    os_unfair_lock_lock(&locallySetDictLock);
    v14 = (const __CFDictionary *)atomic_load((unint64_t *)(a1 + 104));
    Value = (__CFString *)CFDictionaryGetValue(v14, key);
    os_unfair_lock_unlock(&locallySetDictLock);
    if (Value == CFSTR("MagicRemovedValue"))
      goto LABEL_19;
    if (Value)
      goto LABEL_20;
  }
  v16 = *(const __CFDictionary **)(a1 + 16);
  if (v16)
  {
    Value = (__CFString *)CFDictionaryGetValue(v16, key);
    goto LABEL_20;
  }
LABEL_19:
  Value = 0;
LABEL_20:
  v17 = _CFPrefsClientLog();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    v18 = (void *)objc_msgSend((id)a1, "copyOSLogDescription");
    if (Value)
    {
      _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
      v19 = _CFPrefsClientLog();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v29 = 138478339;
        *(_QWORD *)&v29[4] = Value;
        *(_WORD *)&v29[12] = 2114;
        *(_QWORD *)&v29[14] = key;
        *(_WORD *)&v29[22] = 2114;
        v30 = v18;
        _os_log_debug_impl(&dword_182A8C000, v19, OS_LOG_TYPE_DEBUG, "looked up value %{private}@ for key %{public}@ in %{public}@", v29, 0x20u);
      }
    }
    else
    {
      _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
      v20 = _CFPrefsClientLog();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        _copyValueForKey_cold_1();
    }
    _CFSetTSD(0xFu, 0, 0);
    CFRelease(v18);
  }
  if (Value)
    return CFRetain(Value);
  else
    return 0;
}

void sub_182AF8F38(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t _CFPrefsClientLog()
{
  if (makeLogHandles_logToken != -1)
    dispatch_once(&makeLogHandles_logToken, &__block_literal_global_143);
  return clientHandle;
}

BOOL _CFPreferencesGetBooleanValueWithValue(__objc2_class **cf, Boolean *a2)
{
  CFTypeID v4;
  _BOOL8 result;
  Boolean Value;
  BOOL v7;
  Boolean v8;
  double v9[2];

  v9[1] = *(double *)MEMORY[0x1E0C80C00];
  if (!cf)
    goto LABEL_26;
  if (&__kCFBooleanTrue == cf)
    goto LABEL_11;
  if (&__kCFBooleanFalse == cf)
  {
LABEL_24:
    if (a2)
    {
      result = 0;
      *a2 = 1;
      return result;
    }
    return 0;
  }
  v4 = CFGetTypeID(cf);
  if (v4 != 22)
  {
    if (v4 == 7)
    {
      if (CFStringCompare((CFStringRef)cf, CFSTR("YES"), 1uLL) == kCFCompareEqualTo
        || CFStringCompare((CFStringRef)cf, CFSTR("true"), 1uLL) == kCFCompareEqualTo)
      {
        goto LABEL_11;
      }
      if (CFStringCompare((CFStringRef)cf, CFSTR("NO"), 1uLL) == kCFCompareEqualTo
        || CFStringCompare((CFStringRef)cf, CFSTR("false"), 1uLL) == kCFCompareEqualTo)
      {
        goto LABEL_24;
      }
      if (CFEqual(cf, CFSTR("1")))
      {
LABEL_11:
        result = 1;
        if (a2)
          *a2 = 1;
        return result;
      }
      if (CFEqual(cf, CFSTR("0")))
        goto LABEL_24;
    }
LABEL_26:
    if (a2)
    {
      result = 0;
      *a2 = 0;
      return result;
    }
    return 0;
  }
  if (CFNumberIsFloatType((CFNumberRef)cf))
  {
    v9[0] = 0.0;
    Value = CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, v9);
    if (a2)
      *a2 = Value;
    v7 = v9[0] == 0.0;
  }
  else
  {
    v9[0] = 0.0;
    v8 = CFNumberGetValue((CFNumberRef)cf, kCFNumberCFIndexType, v9);
    if (a2)
      *a2 = v8;
    v7 = *(_QWORD *)&v9[0] == 0;
  }
  return !v7;
}

BOOL _CFPrefsGetImpersonatedApplicationAuditToken(_OWORD *a1)
{
  uint64_t v1;
  __int128 v2;

  v1 = _CFPrefsAuditTokenToImpersonate | *((_QWORD *)&_CFPrefsAuditTokenToImpersonate + 1) | qword_1EDCD15CC | unk_1EDCD15D4;
  if (a1 && v1)
  {
    v2 = *(_OWORD *)&qword_1EDCD15CC;
    *a1 = _CFPrefsAuditTokenToImpersonate;
    a1[1] = v2;
  }
  return v1 != 0;
}

uint64_t _CFGetCachedUnsandboxedHomeDirectoryForCurrentUser()
{
  if (_CFGetCachedUnsandboxedHomeDirectoryForCurrentUser_onceToken != -1)
    dispatch_once(&_CFGetCachedUnsandboxedHomeDirectoryForCurrentUser_onceToken, &__block_literal_global_154);
  return _CFGetCachedUnsandboxedHomeDirectoryForCurrentUser_unsandboxedHomePath;
}

void sub_182AF9B1C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

BOOL _CFBundleSupportedProductName(const __CFString *a1, CFRange rangeToSearch)
{
  CFIndex length;
  CFIndex location;
  unint64_t v6;
  unint64_t v7;
  int v8;
  CFRange v9;
  CFRange v10;

  length = rangeToSearch.length;
  location = rangeToSearch.location;
  v9.location = rangeToSearch.location;
  v9.length = length;
  if (CFStringFindWithOptions(a1, CFSTR("iphone"), v9, 8uLL, 0))
    return 1;
  v6 = 0;
  do
  {
    v7 = v6;
    if (v6 == 2)
      break;
    v10.location = location;
    v10.length = length;
    v8 = CFStringFindWithOptions(a1, _CFBundleSupportedProductName_platforms[v6 + 1], v10, 8uLL, 0);
    v6 = v7 + 1;
  }
  while (!v8);
  return v7 < 2;
}

void sub_182AFA110(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

const void *_CFBundleGetMappedStringsFile(CFIndex a1)
{
  const void *ValueAtIndex;

  os_unfair_lock_lock_with_options();
  ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)_mappedStringsFiles, a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&_mappedStringsFilesLock);
  return ValueAtIndex;
}

const char *__cdecl NSGetSizeAndAlignment(const char *typePtr, NSUInteger *sizep, NSUInteger *alignp)
{
  return __NSGetSizeAndAlignment(typePtr, (uint64_t *)sizep, (uint64_t *)alignp, (uint64_t)typePtr, 1, 0, 1uLL);
}

uint64_t __CFHyphenationGetHyphensForString(const __CFString *a1, CFIndex a2, uint64_t a3, uint64_t a4, uint64_t a5, CFIndex a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t result;
  CFIndex v13;
  uint64_t v16;
  uint64_t v17;
  const __CFLocale *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  char *v22;
  CFIndex v23;
  uint64_t v24;
  unsigned int v25;
  BOOL v26;
  CFIndex v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  _WORD v34[208];
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  CFRange v43;

  v40 = a4;
  v42 = *MEMORY[0x1E0C80C00];
  if (a3 > 200)
    return -1;
  v13 = a3;
  v16 = MEMORY[0x1E0C80A78](a1, a2);
  MEMORY[0x1E0C80A78](v16, v17);
  v19 = __CFHyphenationCopyTrieInstance(v18);
  if (!v19)
    return -1;
  v20 = v19;
  v37 = &v35;
  v38 = a8;
  v35 = a5;
  v36 = a9;
  memset(v34, 0, 406);
  v43.location = a2;
  v43.length = v13;
  CFStringGetCharacters(a1, v43, &v34[1]);
  v34[0] = 46;
  v34[v13 + 1] = 46;
  v21 = v13 + 2;
  v34[v13 + 2] = 0;
  v39 = &v33;
  __memset_chk();
  if ((v13 & 0x8000000000000000) == 0)
  {
    v22 = (char *)v39 + 2;
    v23 = v13;
    do
    {
      if ((unint64_t)v21 >= 8)
        v24 = v21 - 8;
      else
        v24 = 0;
      if (v24 <= a6)
      {
        if (v40 && v21 <= v13 && *(_BYTE *)(v21 + v40 - 1))
          *((_BYTE *)v39 + v21) = 9;
        v34[v21] = 0;
        if (v24 < (unint64_t)v21)
        {
          do
          {
            v41 = 0;
            if (v24 > a6)
              break;
            CFBurstTrieContainsCharacters((uint64_t)v20, (uint64_t)&v34[v24], v21 - v24, &v41);
            v25 = v41;
            v26 = v41 + 0x10000000 < 0x10000001 || v21 < v24;
            if (!v26)
            {
              v27 = v23;
              do
              {
                if ((v25 & 7) > v22[v27])
                  v22[v27] = v25 & 7;
                v25 >>= 3;
                v28 = v27 + 2;
                --v27;
              }
              while (v28 > v24);
            }
            ++v24;
          }
          while (v24 != v21);
        }
      }
      --v23;
      v26 = v21-- <= 2;
    }
    while (!v26);
  }
  CFBurstTrieRelease(v20);
  result = 0;
  v29 = v36;
  v30 = v35 - 2;
  v31 = v38;
  v32 = (char *)v39 - 1;
  while (v13 >= 4)
  {
    if ((v32[v13] & 1) != 0 && v13 - 1 <= a6)
      *(_QWORD *)(v31 + 8 * result++) = v30 + v13;
    --v13;
    if (result == v29)
      return v29;
  }
  return result;
}

uint64_t CFBurstTrieContainsCharacters(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE v12[343];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a3 > 1023)
    return 0;
  v8 = v12;
  if (a3 >= 86)
    v8 = malloc_type_malloc((4 * a3) | 1, 0x1774C9FuLL);
  v9 = burstTrieConvertCharactersToUTF8(a2, a3, (uint64_t)v8);
  v8[v9] = 0;
  v10 = CFBurstTrieContainsUTF8String(a1, (uint64_t)v8, v9, a4);
  if (v12 != v8)
    free(v8);
  return v10;
}

uint64_t burstTrieConvertCharactersToUTF8(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  char v11;
  int v12;

  if (a2 >= 1)
  {
    v3 = result;
    v4 = 0;
    v5 = 0;
    LODWORD(result) = 0;
    while (1)
    {
      v6 = *(unsigned __int16 *)(v3 + 2 * v4);
      if ((v6 & 0xFC00) == 0xD800)
      {
        v7 = v5 + 1;
        if (v7 >= a2 || (v8 = *(unsigned __int16 *)(v3 + 2 * v7), (v8 & 0xFC00) != 0xDC00))
        {
LABEL_11:
          *(_BYTE *)(a3 + result) = (v6 >> 12) | 0xE0;
          v10 = result + 2;
          *(_BYTE *)(a3 + (result + 1)) = (v6 >> 6) & 0x3F | 0x80;
          v11 = v6 & 0x3F | 0x80;
          v12 = 3;
          goto LABEL_12;
        }
        v9 = v8 + (v6 << 10) - 56613888;
        *(_BYTE *)(a3 + result) = (v9 >> 18) - 16;
        *(_BYTE *)(a3 + (result + 1)) = (v9 >> 12) & 0x3F | 0x80;
        v10 = result + 3;
        *(_BYTE *)(a3 + (result + 2)) = (v9 >> 6) & 0x3F | 0x80;
        v11 = v8 & 0x3F | 0x80;
        v12 = 4;
        v5 = v7;
      }
      else if (v6 > 0x7F)
      {
        if (v6 > 0x7FF)
          goto LABEL_11;
        v10 = result + 1;
        *(_BYTE *)(a3 + result) = (v6 >> 6) - 64;
        v11 = v6 & 0x3F | 0x80;
        v12 = 2;
      }
      else
      {
        v11 = *(_WORD *)(v3 + 2 * v4);
        v12 = 1;
        v10 = result;
      }
LABEL_12:
      result = (result + v12);
      *(_BYTE *)(a3 + v10) = v11;
      v4 = ++v5;
      if (v5 >= a2)
        goto LABEL_15;
    }
  }
  result = 0;
LABEL_15:
  *(_BYTE *)(a3 + result) = 0;
  return result;
}

CFIndex CFStringGetHyphenationLocationBeforeIndex(CFStringRef string, CFIndex location, CFRange limitRange, CFOptionFlags options, CFLocaleRef locale, UTF32Char *character)
{
  CFIndex result;
  CFIndex v9;
  int length;
  uint64_t HyphenationLocations;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  result = -1;
  if (string)
  {
    if (locale)
    {
      v9 = limitRange.location;
      if ((limitRange.location & 0x8000000000000000) == 0)
      {
        length = limitRange.length;
        if (limitRange.length >= 1
          && limitRange.location <= location
          && limitRange.location + limitRange.length >= location)
        {
          if (limitRange.length <= CFStringGetLength(string))
          {
            if (character)
              *character = 45;
            v16[0] = 0;
            HyphenationLocations = _CFHyphenationGetHyphenationLocations(string, location, v9, length, options, locale, (uint64_t)v16, 1);
            if (v16[0] >= location || HyphenationLocations <= 0)
              return -1;
            else
              return v16[0];
          }
          else
          {
            return -1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t _CFHyphenationGetHyphenationLocations(const __CFString *a1, CFIndex a2, CFIndex a3, int a4, uint64_t a5, CFLocaleRef locale, uint64_t a7, uint64_t a8)
{
  const __CFLocale *v9;
  uint64_t v15;
  __CFString *Identifier;
  const __CFArray *TokenizersForLocale;
  const __CFArray *v18;
  CFIndex Count;
  uint64_t v20;
  int v21;
  CFIndex v22;
  const __CFLocale *v23;
  CFIndex v24;
  CFIndex v25;
  const void *ValueAtIndex;
  CFIndex v27;
  CFIndex Length;
  uint64_t v29;
  uint64_t *v30;
  int v31;
  int v32;
  CFIndex v33;
  uint64_t v34;
  char *v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  char v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  int v49;
  int v50;
  BOOL v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  CFIndex v58;
  UniChar *v59;
  uint64_t v60;
  char *v61;
  unint64_t v62;
  BOOL v63;
  CFIndex v64;
  __CFString *MutableWithExternalCharactersNoCopy;
  __CFString *v66;
  _QWORD *v67;
  const __CFString *v68;
  _QWORD *v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int v72;
  CFIndex v73;
  unsigned __int16 *v74;
  unsigned __int16 *v75;
  int v76;
  int v77;
  unsigned int v78;
  CFIndex v79;
  uint64_t v80;
  const __CFString *v81;
  uint64_t HyphensForString;
  int v83;
  unint64_t v84;
  BOOL v85;
  __int16 *v86;
  __CFString *v87;
  const __CFArray *v88;
  __CFArray *v89;
  uint64_t v90;
  uint64_t v92;
  uint64_t v93;
  const __CFString *v94;
  CFIndex v95;
  uint64_t v96;
  uint64_t *v97;
  uint64_t *v98;
  CFIndex v99;
  CFIndex v100;
  CFAllocatorRef v101;
  CFAllocatorRef v102;
  char *v103;
  const __CFString *v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  _DWORD v108[64];
  uint64_t v109;
  CFRange v110;

  v9 = locale;
  v109 = *MEMORY[0x1E0C80C00];
  v15 = 100;
  if (a8 < 100)
    v15 = a8;
  v106 = v15;
  if (!CFStringIsHyphenationAvailableForLocale(locale))
    return -1;
  v105 = a5;
  Identifier = (__CFString *)CFLocaleGetIdentifier(v9);
  os_unfair_lock_lock_with_options();
  TokenizersForLocale = (const __CFArray *)getTokenizersForLocale(Identifier);
  if (!TokenizersForLocale || (v18 = TokenizersForLocale, (Count = CFArrayGetCount(TokenizersForLocale)) == 0))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
    goto LABEL_9;
  }
  v104 = a1;
  v20 = a7;
  v21 = a4;
  v22 = a3;
  v23 = v9;
  v24 = a2;
  v25 = Count - 1;
  ValueAtIndex = CFArrayGetValueAtIndex(v18, Count - 1);
  v27 = v25;
  a2 = v24;
  v9 = v23;
  a3 = v22;
  a4 = v21;
  a7 = v20;
  a1 = v104;
  CFArrayRemoveValueAtIndex(v18, v27);
  os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
  if (!ValueAtIndex)
  {
LABEL_9:
    v107 = 0;
    CFStringGetCString(Identifier, (char *)v108, 256, 0x8000100u);
    ValueAtIndex = (const void *)ubrk_open();
    if (!ValueAtIndex)
      return 0;
  }
  v104 = (const __CFString *)a7;
  Length = CFStringGetLength(a1);
  v30 = &v92;
  v31 = a2 + 20 - a3;
  if (a2 <= a3)
    v31 = a4;
  if (a2 + 20 <= Length)
    v32 = v31;
  else
    v32 = Length - a3;
  v33 = v32;
  v107 = 0;
  MEMORY[0x1E0C80A78](Length, v29);
  v35 = (char *)&v92 - v34;
  v110.location = a3;
  v110.length = v33;
  CFStringGetCharacters(a1, v110, (UniChar *)((char *)&v92 - v34));
  ubrk_setText();
  v36 = ubrk_last();
  if (v36 != -1)
  {
    v37 = v36;
    v103 = v35;
    v38 = 0;
    v100 = a2;
    v39 = a2 - a3;
    v102 = 0;
    v99 = a3 + 1;
    v101 = (CFAllocatorRef)&__kCFAllocatorNull;
    v40 = v105;
    while (1)
    {
      do
      {
        v41 = v37;
        v42 = ubrk_preceding();
        if ((_DWORD)v42 == -1)
          goto LABEL_103;
        v37 = v42;
      }
      while ((int)v42 >= v39);
      v43 = (v41 - v42);
      if ((int)v43 < 5)
        goto LABEL_98;
      v44 = &v103[2 * (int)v42];
      v45 = *(unsigned __int16 *)v44;
      if (v45 == 39)
      {
        v46 = 1;
        goto LABEL_39;
      }
      if (v45 == 99)
      {
LABEL_27:
        v49 = *((unsigned __int16 *)v44 + 1);
        v46 = 2;
        if (v49 == 39 || v49 == 8217)
          goto LABEL_39;
      }
      else
      {
        v46 = 1;
        if (v45 == 8217)
          goto LABEL_39;
        v47 = 0;
        while (v47 != 7)
        {
          v48 = __CFHyphenationRangeOfCharactersExcludingContraction_singleCharacterPrefixes[v47++ + 3];
          if (v48 == v45)
          {
            if ((unint64_t)(v47 - 1) > 6)
              break;
            goto LABEL_27;
          }
        }
      }
      if (v45 == 113 && *((_WORD *)v44 + 1) == 117)
      {
        v50 = *((unsigned __int16 *)v44 + 2);
        v51 = v50 == 8217 || v50 == 39;
        v46 = 3;
        if (!v51)
          v46 = 0;
      }
      else
      {
        v46 = 0;
      }
LABEL_39:
      v52 = v43 - v46;
      if (v43 - v46 >= 1)
      {
        v53 = (v43 - 1);
        v54 = *(unsigned __int16 *)&v44[2 * v53];
        if (v54 == 8217 || v54 == 39)
        {
          LODWORD(v53) = v43 - 2;
          goto LABEL_43;
        }
        if (v52 >= 2)
        {
          v74 = (unsigned __int16 *)&v44[2 * (int)v43];
          v77 = *(v74 - 2);
          v75 = v74 - 2;
          v76 = v77;
          if ((v77 == 8217 || v76 == 39) && (v78 = v54 - 100, v78 <= 0x10) && ((1 << v78) & 0x18001) != 0)
          {
            LODWORD(v53) = v43 - 3;
LABEL_43:
            v53 = (int)v53;
          }
          else if (v52 >= 3)
          {
            v83 = *(unsigned __int16 *)&v44[2 * (int)v43 - 6];
            if (v83 == 8217 || v83 == 39)
            {
              v84 = 0;
              v85 = 1;
              v86 = &word_182DC88AA;
              do
              {
                if (v76 == (unsigned __int16)*(v86 - 1))
                {
                  v42 = (unsigned __int16)*v86;
                  if (v75[1] == (_DWORD)v42)
                    break;
                }
                v85 = v84 < 4;
                v86 += 2;
                ++v84;
              }
              while (v84 != 5);
              if (v85)
                v53 = (int)v43 - 4;
            }
          }
        }
        v55 = v53 <= v46;
        v56 = v53 - v46;
        if (v55)
          v57 = 0;
        else
          v57 = v46;
        if (v55)
          v58 = (v41 - v37);
        else
          v58 = v56 + 1;
        if (v58 < 5)
          goto LABEL_98;
        v98 = v30;
        v93 = v37;
        v95 = a3 + v37;
        MEMORY[0x1E0C80A78](v42, &v44[2 * v57]);
        v61 = (char *)&v92 - ((v58 + 15) & 0xFFFFFFFFFFFFFFF0);
        v62 = 0;
        do
        {
          v63 = 0;
          v64 = v62 + 2;
          if (v62 >= 3 && v64 < v58)
            v63 = v59[v62 - 1] - 97 <= 0x19 && v59[v62] - 65 < 0x1A;
          v61[v62++] = v63;
        }
        while (v64 - 1 != v58);
        v96 = v60;
        MutableWithExternalCharactersNoCopy = CFStringCreateMutableWithExternalCharactersNoCopy(v102, v59, v58, v58, v101);
        if (!MutableWithExternalCharactersNoCopy)
          goto LABEL_103;
        v97 = &v92;
        v66 = MutableWithExternalCharactersNoCopy;
        CFStringLowercase(MutableWithExternalCharactersNoCopy, v9);
        v67 = __CFHyphenationCopyTrieInstance(v9);
        v68 = v66;
        if (v67)
        {
          v69 = v67;
          v108[0] = 0;
          v94 = v68;
          CFBurstTrieContains((uint64_t)v67, v68, 0, v58, v108);
          CFBurstTrieRelease(v69);
          if (v108[0] >> 28 != 15)
          {
            v68 = v94;
            goto LABEL_77;
          }
          v70 = v106;
          if (v106 < 1 || v108[0] == -1)
          {
            CFRelease(v94);
          }
          else
          {
            v71 = 0;
            v72 = ~v108[0];
            v73 = v99 + v96 + v93;
            do
            {
              if ((v72 & 1) != 0)
                *((_QWORD *)&v104->isa + v71++) = v73;
              if (v72 < 2)
                break;
              v72 >>= 1;
              ++v73;
            }
            while (v71 < v70);
            v68 = v94;
            if (v71 == -1)
              goto LABEL_77;
LABEL_83:
            CFRelease(v68);
            if (v71 >= 1)
            {
              v38 += v71;
              if (v106 - v71 < 1)
                goto LABEL_103;
              v106 -= v71;
              v104 = (const __CFString *)((char *)v104 + 8 * v71);
            }
          }
          v40 = v105;
          v30 = v98;
          goto LABEL_98;
        }
LABEL_77:
        v79 = v58 - 200;
        if (v58 >= 200)
          v80 = 200;
        else
          v80 = v58;
        if (v58 <= 200)
          v79 = 0;
        v81 = v68;
        HyphensForString = __CFHyphenationGetHyphensForString(v68, 0, v80, (uint64_t)v61, v95 + v96 + v79, v100 - (v95 + v96 + v79), (uint64_t)v9, (uint64_t)v104, v106);
        v68 = v81;
        v71 = HyphensForString;
        goto LABEL_83;
      }
LABEL_98:
      if ((v40 & 1) == 0)
        goto LABEL_103;
    }
  }
  v38 = 0;
LABEL_103:
  v87 = (__CFString *)CFLocaleGetIdentifier(v9);
  os_unfair_lock_lock_with_options();
  v88 = (const __CFArray *)getTokenizersForLocale(v87);
  if (v88 && (v89 = v88, v90 = CFArrayGetCount(v88), v90 <= 2))
  {
    CFArraySetValueAtIndex(v89, v90, ValueAtIndex);
    os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&tokenizerMutex);
    ubrk_close();
  }
  return v38;
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
  unsigned int v6;
  int v7;
  const CFArrayCallBacks *v8;
  char v9;
  int v10;
  const CFAllocatorRef *v11;
  char v12;
  CFAllocatorRef v13;
  char v14;
  char v15;
  int v16;
  char v17;
  BOOL v18;
  uint64_t v19;
  char *v20;
  uint64_t *v21;
  uint64_t (*retain)(_QWORD, _QWORD);
  uint64_t v23;
  uint64_t v24;
  void (*release)(CFAllocatorRef, uint64_t);
  _QWORD v26[2];

  v26[1] = *MEMORY[0x1E0C80C00];
  v26[0] = value;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    -[__CFArray setObject:atIndex:](theArray, "setObject:atIndex:", value, idx);
    return;
  }
  if (*((_QWORD *)theArray + 2) == idx)
  {
    _CFArrayReplaceValues((unint64_t)theArray, idx, 0, v26, 1);
    return;
  }
  v6 = atomic_load((unint64_t *)theArray + 1);
  v7 = (v6 >> 2) & 3;
  if (v7)
  {
    if (v7 == 1)
    {
      v8 = &kCFTypeArrayCallBacks;
      if (((unint64_t)theArray & 0x8000000000000000) == 0)
        goto LABEL_18;
    }
    else
    {
      v9 = atomic_load((unint64_t *)theArray + 1);
      v10 = v9 & 3;
      if (v10 == 2)
      {
        v8 = (const CFArrayCallBacks *)((char *)theArray + 48);
        if (((unint64_t)theArray & 0x8000000000000000) == 0)
          goto LABEL_18;
      }
      else
      {
        if (v10)
          v8 = 0;
        else
          v8 = (const CFArrayCallBacks *)((char *)theArray + 48);
        if (((unint64_t)theArray & 0x8000000000000000) == 0)
          goto LABEL_18;
      }
    }
  }
  else
  {
    v8 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
    if (((unint64_t)theArray & 0x8000000000000000) == 0)
    {
LABEL_18:
      v12 = atomic_load((unint64_t *)theArray + 1);
      if (v12 < 0)
        v11 = &kCFAllocatorSystemDefault;
      else
        v11 = (const CFAllocatorRef *)((char *)theArray - 16);
      goto LABEL_21;
    }
  }
  v11 = &kCFAllocatorSystemDefault;
LABEL_21:
  v13 = *v11;
  v14 = atomic_load((unint64_t *)theArray + 1);
  if ((v14 & 1 | 2) == 2)
  {
    v15 = atomic_load((unint64_t *)theArray + 1);
    v16 = v15 & 3;
    if (v16 == 2)
    {
      v20 = (char *)(*((_QWORD *)theArray + 5) + 8 * **((_QWORD **)theArray + 5) + 16);
    }
    else if (v16)
    {
      v20 = 0;
    }
    else
    {
      v17 = atomic_load((unint64_t *)theArray + 1);
      v18 = (~v17 & 0xC) == 0;
      v19 = 48;
      if (v18)
        v19 = 88;
      v20 = (char *)theArray + v19;
    }
    v21 = (uint64_t *)&v20[8 * idx];
  }
  else
  {
    v21 = 0;
  }
  retain = (uint64_t (*)(_QWORD, _QWORD))v8->retain;
  v23 = v26[0];
  if (retain)
    v23 = retain(v13, v26[0]);
  v24 = *v21;
  *v21 = v23;
  release = (void (*)(CFAllocatorRef, uint64_t))v8->release;
  if (release)
    release(v13, v24);
  ++*((_QWORD *)theArray + 3);
}

void CFStringFold(CFMutableStringRef theString, CFStringCompareFlags theFlags, CFLocaleRef theLocale)
{
  char v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int16 v13;
  uint64_t Length;
  int v16;
  const __CFLocale *v17;
  unsigned int v18;
  uint64_t CStringPtrInternal;
  const UniChar *CharactersPtr;
  uint64_t v21;
  uint64_t v22;
  CFIndex v23;
  char *v24;
  char v25;
  char **p_data;
  char *v27;
  char v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  UniChar *Typed;
  UniChar *v34;
  __CFString *MutableWithExternalCharactersNoCopy;
  const __CFString *v36;
  char v37;
  uint64_t v38;
  char v39;
  uint64_t v40;
  char **v41;
  char *v42;
  uint64_t v43;
  const UniChar *v44;
  uint64_t v45;
  char v46;
  char **v47;
  char *v48;
  char v49;
  unsigned int *v50;
  char *v51;
  int v52;
  UniChar v53;
  uint64_t v54;
  CFIndex v56;
  CFIndex v57;
  unsigned int v58;
  unsigned int *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  UniChar v64;
  uint64_t v65;
  CFIndex v66;
  CFIndex v67;
  BOOL v68;
  int v69;
  uint64_t v70;
  unsigned int *v71;
  unsigned int *v72;
  int v73;
  char v74;
  uint64_t v75;
  uint64_t v76;
  char v77;
  char v78;
  uint64_t v79;
  char *v80;
  char v81;
  const UniChar *v82;
  uint64_t v83;
  char v84;
  char *v85;
  char *v86;
  unsigned int *v87;
  unsigned int *v88;
  unsigned int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  char v93;
  const __CFLocale *v94;
  char **v95;
  const __CFLocale *v96;
  _BOOL4 v97;
  CFStringCompareFlags theFlagsa;
  char *SpecialCaseHandlingLanguageIdentifierForLocale;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unsigned int v103[64];
  unsigned int v104[64];
  UniChar buffer[8];
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 theStringa;
  __int128 v114;
  __int128 v115;
  CFIndex v116;
  uint64_t v117;
  CFRange v118;
  CFRange v119;
  CFRange v120;
  CFRange v121;

  v117 = *MEMORY[0x1E0C80C00];
  v3 = atomic_load((unint64_t *)&theString->info);
  if ((v3 & 1) == 0)
  {
    v4 = _CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      CFStringFold_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
    return;
  }
  v13 = theFlags;
  v116 = 0;
  v114 = 0u;
  v115 = 0u;
  v112 = 0u;
  theStringa = 0u;
  v110 = 0u;
  v111 = 0u;
  v108 = 0u;
  v109 = 0u;
  v106 = 0u;
  v107 = 0u;
  *(_OWORD *)buffer = 0u;
  Length = CFStringGetLength(theString);
  v16 = CF_IS_OBJC(7uLL, (__objc2_class **)theString);
  v97 = v16 != 0;
  v17 = theLocale;
  if ((v13 & 0x20) != 0)
  {
    v17 = theLocale;
    if (!theLocale)
      v17 = CFLocaleCopyCurrent();
  }
  theFlagsa = v13 & 0x181;
  if ((v13 & 0x181) != 0 && Length)
  {
    if (v17)
      SpecialCaseHandlingLanguageIdentifierForLocale = (char *)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(v17, 1);
    else
      SpecialCaseHandlingLanguageIdentifierForLocale = 0;
    v18 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      v18 = __CFDefaultEightBitStringEncoding;
    }
    CStringPtrInternal = _CFStringGetCStringPtrInternal((uint64_t)theString, v18, 0, v97);
    if (!CStringPtrInternal || (v13 & 1) != 0 || v18 != 1536)
    {
      *(_QWORD *)&theStringa = theString;
      *((_QWORD *)&v114 + 1) = 0;
      *(_QWORD *)&v115 = Length;
      CharactersPtr = CFStringGetCharactersPtr(theString);
      v21 = 0;
      *((_QWORD *)&theStringa + 1) = CharactersPtr;
      if (!CharactersPtr)
        v21 = _CFStringGetCStringPtrInternal((uint64_t)theString, 0x600u, 0, v97);
      v22 = 0;
      v116 = 0;
      *(_QWORD *)&v114 = v21;
      *((_QWORD *)&v115 + 1) = 0;
      v96 = v17;
      v23 = 0;
      if ((v13 & 0x81) == 0 || !CStringPtrInternal)
        goto LABEL_45;
      v94 = theLocale;
      if (v16)
      {
        v24 = 0;
      }
      else
      {
        v25 = atomic_load((unint64_t *)&theString->info);
        p_data = &theString->data;
        if ((v25 & 0x60) != 0)
        {
          v27 = *p_data;
        }
        else
        {
          v28 = atomic_load((unint64_t *)&theString->info);
          v27 = (char *)&p_data[(v28 & 5) != 4];
        }
        v29 = atomic_load((unint64_t *)&theString->info);
        v24 = &v27[(v29 >> 2) & 1];
      }
      if (Length <= 0)
      {
        v22 = 0;
        v31 = CStringPtrInternal;
        goto LABEL_44;
      }
      v30 = 0;
      v22 = 0;
      v31 = CStringPtrInternal;
      while (1)
      {
        if (*(char *)(CStringPtrInternal + v30) < 0 || SpecialCaseHandlingLanguageIdentifierForLocale)
        {
          v32 = __CFStringFoldCharacterClusterAtIndex(*(unsigned __int16 *)(__CFCharToUniCharTable + 2 * *(unsigned __int8 *)(CStringPtrInternal + v30)), buffer, v30, theFlagsa, SpecialCaseHandlingLanguageIdentifierForLocale, v103, 0, 0);
          v22 = v32;
          if (v32 >= 1)
          {
            if (v32 != 1 || v103[0] > 0x7F || !v24)
              goto LABEL_44;
            v24[v30] = v103[0];
            v22 = 1;
          }
          goto LABEL_40;
        }
        if ((v13 & 1) != 0 && *(unsigned __int8 *)(CStringPtrInternal + v30) - 65 <= 0x19)
          break;
LABEL_40:
        ++v31;
        ++v30;
        if (CStringPtrInternal + v30 >= (unint64_t)(CStringPtrInternal + Length))
        {
          v31 = CStringPtrInternal + v30;
          goto LABEL_44;
        }
      }
      if (v24)
      {
        v24[v30] += 32;
        goto LABEL_40;
      }
      v31 = CStringPtrInternal + v30;
LABEL_44:
      theLocale = v94;
      v23 = v31 - CStringPtrInternal;
      v17 = v96;
LABEL_45:
      if (Length > v23)
      {
        if (v16)
        {
          Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * (Length - v23), 0x1000040BDFB0063, 0);
          v118.location = v23;
          v118.length = Length - v23;
          CFStringGetCharacters(theString, v118, Typed);
          v34 = Typed;
          v17 = v96;
          MutableWithExternalCharactersNoCopy = CFStringCreateMutableWithExternalCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, Length - v23, Length - v23, 0);
          if (MutableWithExternalCharactersNoCopy)
          {
            v36 = MutableWithExternalCharactersNoCopy;
            CFStringFold(MutableWithExternalCharactersNoCopy, theFlagsa, v96);
            v119.location = v23;
            v119.length = Length - v23;
            CFStringReplace(theString, v119, v36);
            CFRelease(v36);
            goto LABEL_155;
          }
        }
        v100 = 0;
        if (v22 >= 1)
        {
          v101 = v23 + 1;
          v102 = 0;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v101, 1, v22 - 1, 1);
          v37 = atomic_load((unint64_t *)&theString->info);
          v38 = v37 & 5;
          v39 = atomic_load((unint64_t *)&theString->info);
          v40 = v39 & 0x60;
          if (v38 == 4)
          {
            v41 = &theString->data;
            if (v40)
            {
              v42 = *v41;
            }
            else
            {
              v43 = atomic_load((unint64_t *)&theString->info);
              v42 = (char *)&v41[(v43 & 5) != 4];
            }
            Length = *v42;
          }
          else if ((v39 & 0x60) != 0)
          {
            Length = theString->length;
          }
          else
          {
            Length = (uint64_t)theString->data;
          }
          *(_QWORD *)&theStringa = theString;
          *((_QWORD *)&v114 + 1) = 0;
          *(_QWORD *)&v115 = Length;
          v44 = CFStringGetCharactersPtr(theString);
          v45 = 0;
          *((_QWORD *)&theStringa + 1) = v44;
          if (!v44)
            v45 = _CFStringGetCStringPtrInternal((uint64_t)theString, 0x600u, 0, v97);
          *(_QWORD *)&v114 = v45;
          *((_QWORD *)&v115 + 1) = 0;
          v116 = 0;
          v46 = atomic_load((unint64_t *)&theString->info);
          v47 = &theString->data;
          if ((v46 & 0x60) != 0)
          {
            v48 = *v47;
          }
          else
          {
            v49 = atomic_load((unint64_t *)&theString->info);
            v48 = (char *)&v47[(v49 & 5) != 4];
          }
          v50 = v103;
          v51 = &v48[2 * v23];
          do
          {
            v52 = *v50++;
            *(_WORD *)v51 = v52;
            v51 += 2;
          }
          while (v50 < &v103[v22]);
          ++v23;
        }
        if (v23 < Length)
        {
          v95 = &theString->data;
          do
          {
            if (*((_QWORD *)&theStringa + 1))
            {
              v53 = *(_WORD *)(*((_QWORD *)&theStringa + 1) + 2 * (*((_QWORD *)&v114 + 1) + v23));
            }
            else if ((_QWORD)v114)
            {
              v53 = *(char *)(v114 + *((_QWORD *)&v114 + 1) + v23);
            }
            else
            {
              v54 = *((_QWORD *)&v115 + 1);
              if (v116 <= v23 || *((_QWORD *)&v115 + 1) > v23)
              {
                v56 = v23 - 4;
                if (v23 < 4)
                  v56 = 0;
                v57 = v56 + 64;
                if (v56 + 64 >= (uint64_t)v115)
                  v57 = v115;
                *((_QWORD *)&v115 + 1) = v56;
                v116 = v57;
                v120.location = *((_QWORD *)&v114 + 1) + v56;
                v120.length = v57 - v56;
                CFStringGetCharacters((CFStringRef)theStringa, v120, buffer);
                v54 = *((_QWORD *)&v115 + 1);
              }
              v53 = buffer[v23 - v54];
            }
            v58 = v53;
            v100 = 0;
            if ((v13 & 0x80) != 0 || SpecialCaseHandlingLanguageIdentifierForLocale || v53 > 0x7Fu)
            {
              v62 = v23 + 1;
              if (v53 >> 10 == 54 && v62 < Length)
              {
                if (*((_QWORD *)&theStringa + 1))
                {
                  v64 = *(_WORD *)(*((_QWORD *)&theStringa + 1) + 2 * (*((_QWORD *)&v114 + 1) + v62));
                }
                else if ((_QWORD)v114)
                {
                  v64 = *(char *)(v114 + *((_QWORD *)&v114 + 1) + v62);
                }
                else
                {
                  if (v116 <= v62 || (v65 = *((_QWORD *)&v115 + 1), *((uint64_t *)&v115 + 1) > v62))
                  {
                    v66 = v23 - 3;
                    if (v23 < 3)
                      v66 = 0;
                    v67 = v66 + 64;
                    if (v66 + 64 >= (uint64_t)v115)
                      v67 = v115;
                    *((_QWORD *)&v115 + 1) = v66;
                    v116 = v67;
                    v121.location = *((_QWORD *)&v114 + 1) + v66;
                    v121.length = v67 - v66;
                    CFStringGetCharacters((CFStringRef)theStringa, v121, buffer);
                    v65 = *((_QWORD *)&v115 + 1);
                  }
                  v64 = buffer[v62 - v65];
                }
                v68 = v64 >> 10 == 55;
                v69 = (v58 << 10) + v64 - 56613888;
                if (v68)
                  v58 = v69;
              }
              v70 = __CFStringFoldCharacterClusterAtIndex(v58, buffer, v23, theFlagsa, SpecialCaseHandlingLanguageIdentifierForLocale, v103, &v100, 0);
              v60 = v100;
              if (v100 >= 1)
              {
                v61 = v70;
                v59 = &v103[v70];
                if (v70 >= 1)
                  goto LABEL_112;
                v73 = 0;
LABEL_119:
                if (v61 == v60)
                {
                  v74 = atomic_load((unint64_t *)&theString->info);
                  if ((v74 & 0x10) == 0)
                  {
                    v60 = v100;
                    goto LABEL_122;
                  }
                }
                else
                {
LABEL_122:
                  v75 = v60 - v61;
                  if (v60 < v61)
                  {
                    v75 = 0;
                    v76 = v61 - v60;
                  }
                  else
                  {
                    v60 = v61;
                    v76 = 0;
                  }
                  v101 = v60 + v23;
                  v102 = v75;
                  __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v101, 1, v76, 1);
                  v77 = atomic_load((unint64_t *)&theString->info);
                  v78 = atomic_load((unint64_t *)&theString->info);
                  v79 = v78 & 0x60;
                  if ((v77 & 5) == 4)
                  {
                    if (v79)
                    {
                      v80 = *v95;
                    }
                    else
                    {
                      v81 = atomic_load((unint64_t *)&theString->info);
                      v80 = (char *)&v95[(v81 & 5) != 4];
                    }
                    Length = *v80;
                  }
                  else if (v79)
                  {
                    Length = theString->length;
                  }
                  else
                  {
                    Length = (uint64_t)*v95;
                  }
                  *(_QWORD *)&theStringa = theString;
                  *((_QWORD *)&v114 + 1) = 0;
                  *(_QWORD *)&v115 = Length;
                  v82 = CFStringGetCharactersPtr(theString);
                  v83 = 0;
                  *((_QWORD *)&theStringa + 1) = v82;
                  if (!v82)
                    v83 = _CFStringGetCStringPtrInternal((uint64_t)theString, 0x600u, 0, v97);
                  *(_QWORD *)&v114 = v83;
                  *((_QWORD *)&v115 + 1) = 0;
                  v116 = 0;
                }
                v84 = atomic_load((unint64_t *)&theString->info);
                if ((v84 & 0x60) != 0)
                {
                  v85 = *v95;
                  if (v73)
                    goto LABEL_138;
                  goto LABEL_153;
                }
                v93 = atomic_load((unint64_t *)&theString->info);
                v85 = (char *)&v95[(v93 & 5) != 4];
                if (!v73)
                {
LABEL_153:
                  v17 = v96;
                  goto LABEL_154;
                }
LABEL_138:
                v86 = &v85[2 * v23];
                v87 = v103;
                v88 = v103;
                v17 = v96;
                while (2)
                {
                  v90 = *v88++;
                  v89 = v90;
                  v91 = HIWORD(v90);
                  if (HIWORD(v90))
                  {
                    if (v91 > 0x10)
                      goto LABEL_146;
                    *(_WORD *)v86 = ((v89 + 67043328) >> 10) - 10240;
                    v86 += 2;
                    LOWORD(v92) = v89 & 0x3FF | 0xDC00;
                  }
                  else if ((v89 & 0xFC00) == 0xD800)
                  {
                    if (v88 < v59)
                    {
                      v92 = *v88;
                      if (*v88 >> 10 == 55)
                      {
                        *(_WORD *)v86 = v89;
                        v86 += 2;
                        v88 = v87 + 2;
                        goto LABEL_150;
                      }
                    }
LABEL_146:
                    LOWORD(v92) = -3;
                  }
                  else if ((v89 & 0xFC00) == 0xDC00)
                  {
                    LOWORD(v92) = -3;
                  }
                  else
                  {
                    LOWORD(v92) = v89;
                  }
LABEL_150:
                  *(_WORD *)v86 = v92;
                  v86 += 2;
                  v87 = v88;
                  if (v88 >= v59)
                    goto LABEL_154;
                  continue;
                }
              }
              v61 = 1;
            }
            else
            {
              if ((v13 & 1) != 0 && v53 >= 0x41u && v53 <= 0x5Au)
              {
                v100 = 1;
                v103[0] = v53 + 32;
                v59 = v104;
                v60 = 1;
                v61 = 1;
LABEL_112:
                v71 = v103;
                do
                {
                  v72 = v71 + 1;
                  if (*((_WORD *)v71 + 1))
                    ++v61;
                  ++v71;
                }
                while (v72 < v59);
                v73 = 1;
                goto LABEL_119;
              }
              v61 = 1;
            }
LABEL_154:
            v23 += v61;
          }
          while (v23 < Length);
        }
      }
    }
  }
LABEL_155:
  if (!theLocale && v17)
    CFRelease(v17);
}

uint64_t __CFStringFoldCharacterClusterAtIndex(unsigned int a1, UniChar *buffer, uint64_t a3, __int16 a4, char *__s1, unsigned int *a6, _QWORD *a7, _BYTE *a8)
{
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  int64_t v17;
  uint64_t v18;
  char v19;
  int64_t v20;
  uint64_t v21;
  UniChar v22;
  uint64_t v23;
  int64_t v24;
  int64_t v25;
  unsigned __int16 v26;
  uint64_t BitmapPtrForPlane;
  unsigned int v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;
  BOOL v33;
  int64_t v34;
  uint64_t v35;
  UniChar *v36;
  uint64_t v37;
  unsigned __int16 v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  __int16 *v42;
  uint64_t v43;
  __int16 *v44;
  __int16 *v45;
  __int16 v46;
  int v48;
  __int16 *v49;
  __int16 *v50;
  unsigned int *v51;
  unsigned int v52;
  unsigned __int16 *v53;
  BOOL v54;
  int v55;
  uint64_t v56;
  char v57;
  uint64_t v59;
  _QWORD *v60;
  unsigned int *v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int *v64;
  unsigned int v65;
  uint64_t v66;
  int64_t v68;
  uint64_t v69;
  UniChar v70;
  unsigned int v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  BOOL v76;
  uint64_t v77;
  uint64_t v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  uint64_t v83;
  UniChar v84;
  uint64_t v85;
  int64_t v86;
  int64_t v87;
  int64_t v88;
  int64_t v89;
  int64_t v90;
  uint64_t v91;
  UniChar v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  uint64_t v104;
  UniChar v105;
  uint64_t v106;
  int64_t v107;
  int64_t v108;
  char v109;
  uint64_t v110;
  _BYTE *v111;
  unsigned int v113;
  __int16 v114[8];
  uint64_t v115;
  CFRange v116;
  CFRange v117;
  CFRange v118;
  CFRange v119;
  CFRange v120;
  CFRange v121;

  v115 = *MEMORY[0x1E0C80C00];
  v113 = a1;
  if (!a1)
    return 0;
  v14 = a1;
  v15 = HIWORD(a1);
  if (!__CFStringFoldCharacterClusterAtIndex_decompBMP)
  {
    __CFStringFoldCharacterClusterAtIndex_decompBMP = CFUniCharGetBitmapPtrForPlane(9u, 0);
    __CFStringFoldCharacterClusterAtIndex_graphemeBMP = CFUniCharGetBitmapPtrForPlane(0x6Eu, 0);
  }
  v16 = 1;
  if (v15)
    v16 = 2;
  v110 = a3;
  v111 = a8;
  v17 = v16 + a3;
  if (v14 <= 0x7F)
  {
    if (!__s1 || v14 != 73)
    {
      v18 = 0;
      v19 = 0;
      if ((a4 & 1) == 0 || v14 - 65 > 0x19)
        goto LABEL_118;
      v19 = 0;
      v113 = v14 + 32;
      *a6 = v14 + 32;
      goto LABEL_17;
    }
    v18 = 0;
LABEL_36:
    v15 = 0;
    goto LABEL_37;
  }
  if ((a4 & 0x100) != 0 && v14 - 65280 <= 0xEF)
  {
    v18 = 1;
    CFUniCharCompatibilityDecompose((int *)&v113, 1, 1);
    LOWORD(v14) = v113;
    *a6 = v113;
  }
  else
  {
    v18 = 0;
    if (v15)
      goto LABEL_37;
  }
  v15 = 0;
  if ((v14 & 0xFC00) == 0xD800 && (v17 & 0x8000000000000000) == 0)
  {
    v20 = *((_QWORD *)buffer + 20);
    if (v20 > v17)
    {
      v21 = *((_QWORD *)buffer + 17);
      if (v21)
      {
        v22 = *(_WORD *)(v21 + 2 * (*((_QWORD *)buffer + 19) + v17));
      }
      else
      {
        v23 = *((_QWORD *)buffer + 18);
        if (v23)
        {
          v22 = *(char *)(v23 + *((_QWORD *)buffer + 19) + v17);
        }
        else
        {
          if (*((_QWORD *)buffer + 22) <= v17 || (v24 = *((_QWORD *)buffer + 21), v24 > v17))
          {
            v25 = v17 - 4;
            if ((unint64_t)v17 < 4)
              v25 = 0;
            if (v25 + 64 < v20)
              v20 = v25 + 64;
            *((_QWORD *)buffer + 21) = v25;
            *((_QWORD *)buffer + 22) = v20;
            v116.location = *((_QWORD *)buffer + 19) + v25;
            v116.length = v20 - v25;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v116, buffer);
            v24 = *((_QWORD *)buffer + 21);
          }
          v22 = buffer[v17 - v24];
        }
      }
      if (v22 >> 10 == 55)
      {
        v113 = ((unsigned __int16)v113 << 10) + v22 - 56613888;
        ++v17;
        v15 = HIWORD(v113);
        goto LABEL_37;
      }
    }
    goto LABEL_36;
  }
LABEL_37:
  if ((a4 & 0x90) == 0)
    goto LABEL_51;
  v26 = v113;
  if (v15)
  {
    BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(9u, v15);
    if (!BitmapPtrForPlane)
      goto LABEL_51;
  }
  else
  {
    BitmapPtrForPlane = __CFStringFoldCharacterClusterAtIndex_decompBMP;
    if (!__CFStringFoldCharacterClusterAtIndex_decompBMP)
      goto LABEL_51;
  }
  if (((*(unsigned __int8 *)(BitmapPtrForPlane + (v26 >> 3)) >> (v26 & 7)) & 1) != 0)
  {
    v28 = v113;
    v29 = CFUniCharDecomposeCharacter(v113, a6, 64);
    v18 = v29;
    v30 = *a6;
    v113 = *a6;
    if ((a4 & 0x80) != 0 && v30 < 0x510)
    {
      v18 = 1;
    }
    else if ((a4 & 0x10) != 0)
    {
      if (v111 && !v29)
        *v111 = 1;
    }
    else
    {
      v18 = 0;
      v113 = v28;
    }
  }
LABEL_51:
  if ((a4 & 1) == 0)
  {
LABEL_52:
    v19 = 0;
    goto LABEL_118;
  }
  v31 = v113;
  v33 = (a4 & 0x80) == 0 || v113 > 0x50F;
  if (!__CFStringFoldCharacterClusterAtIndex_lowerBMP)
  {
    __CFStringFoldCharacterClusterAtIndex_lowerBMP = CFUniCharGetBitmapPtrForPlane(0x67u, 0);
    __CFStringFoldCharacterClusterAtIndex_caseFoldBMP = CFUniCharGetBitmapPtrForPlane(0x6Au, 0);
    v31 = v113;
  }
  if (__s1 && v31 == 73)
  {
    if (!strcmp(__s1, "tr") || !strcmp(__s1, "az"))
    {
      if (v18 >= 2)
      {
        if (a6[1] == 775)
        {
          if ((unint64_t)v18 >= 3)
            memmove(a6 + 1, a6 + 2, 4 * v18 - 8);
          *a6 = 105;
          v113 = 105;
          v19 = 1;
          --v18;
          goto LABEL_118;
        }
        goto LABEL_78;
      }
      if ((v17 & 0x8000000000000000) == 0)
      {
        v34 = *((_QWORD *)buffer + 20);
        if (v34 > v17)
        {
          v35 = *((_QWORD *)buffer + 17);
          if (v35)
          {
            v36 = (UniChar *)(v35 + 2 * (*((_QWORD *)buffer + 19) + v17));
LABEL_74:
            if (*v36 != 775)
            {
              LOWORD(v31) = v113;
              goto LABEL_79;
            }
            *a6 = 105;
            v113 = 105;
            ++v17;
            v19 = 1;
LABEL_17:
            v18 = 1;
            goto LABEL_118;
          }
          if (!*((_QWORD *)buffer + 18))
          {
            if (*((_QWORD *)buffer + 22) <= v17 || (v86 = *((_QWORD *)buffer + 21), v86 > v17))
            {
              v87 = v17 - 4;
              if ((unint64_t)v17 < 4)
                v87 = 0;
              if (v87 + 64 < v34)
                v34 = v87 + 64;
              *((_QWORD *)buffer + 21) = v87;
              *((_QWORD *)buffer + 22) = v34;
              v118.location = *((_QWORD *)buffer + 19) + v87;
              v118.length = v34 - v87;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v118, buffer);
              v86 = *((_QWORD *)buffer + 21);
            }
            v36 = &buffer[v17 - v86];
            goto LABEL_74;
          }
        }
      }
    }
LABEL_78:
    LOWORD(v31) = 73;
  }
LABEL_79:
  if (v15)
  {
    v37 = CFUniCharGetBitmapPtrForPlane(0x67u, v15);
    if (!v37)
      goto LABEL_84;
  }
  else
  {
    v37 = __CFStringFoldCharacterClusterAtIndex_lowerBMP;
    if (!__CFStringFoldCharacterClusterAtIndex_lowerBMP)
    {
LABEL_84:
      v38 = v113;
      if (v15)
      {
        v39 = CFUniCharGetBitmapPtrForPlane(0x6Au, v15);
        if (!v39)
          goto LABEL_52;
      }
      else
      {
        v39 = __CFStringFoldCharacterClusterAtIndex_caseFoldBMP;
        if (!__CFStringFoldCharacterClusterAtIndex_caseFoldBMP)
          goto LABEL_52;
      }
      if (((*(unsigned __int8 *)(v39 + (v38 >> 3)) >> (v38 & 7)) & 1) == 0)
        goto LABEL_52;
      goto LABEL_89;
    }
  }
  if (((*(unsigned __int8 *)(v37 + ((unsigned __int16)v31 >> 3)) >> (v31 & 7)) & 1) == 0)
    goto LABEL_84;
LABEL_89:
  v40 = CFUniCharMapCaseTo(v113, v114, 8, 3, 0, (unsigned __int16 *)__s1);
  v41 = v40;
  v42 = &v114[v40];
  v18 -= v18 > 0;
  if (v18 >= 1 && (v40 & 0xFFFFFFFE) != 0)
  {
    v43 = 0;
    if (v40)
    {
      v44 = v114;
      v45 = v114;
      do
      {
        v46 = *v45++;
        if ((v46 & 0xFC00) == 0xD800 && v45 < v42)
        {
          v48 = v44[1] & 0xFC00;
          v49 = v44 + 2;
          if (v48 == 56320)
            v45 = v49;
        }
        ++v43;
        v44 = v45;
      }
      while (v45 < v42);
    }
    memmove(&a6[v43], a6 + 1, 4 * v18);
  }
  v109 = a4;
  if (v41)
  {
    v50 = v114;
    v51 = a6;
    do
    {
      v53 = (unsigned __int16 *)(v50 + 1);
      v52 = (unsigned __int16)*v50;
      v113 = v52;
      v54 = (v52 & 0xFC00) != 0xD800 || v53 >= (unsigned __int16 *)v42;
      if (v54 || (v55 = *v53, (v55 & 0xFC00) != 0xDC00))
      {
        v56 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
        ++v50;
      }
      else
      {
        v50 += 2;
        v113 = (v52 << 10) - 56613888 + v55;
        v56 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v113));
        v52 = v113;
      }
      if (v56)
        v57 = v33;
      else
        v57 = 1;
      if ((v57 & 1) != 0 || ((*(unsigned __int8 *)(v56 + ((unsigned __int16)v52 >> 3)) >> (v52 & 7)) & 1) == 0)
      {
        *v51++ = v52;
        ++v18;
      }
    }
    while (v50 < v42);
  }
  v19 = 0;
  LOBYTE(a4) = v109;
LABEL_118:
  if ((a4 & 0x90) != 0)
  {
    LODWORD(v59) = (a4 & 0x80) == 0 || v113 > 0x50F;
    if (v18)
      goto LABEL_126;
    *a6 = v113;
    if ((_DWORD)v59)
    {
      if (v17 < 0 || (v68 = *((_QWORD *)buffer + 20), v68 <= v17))
      {
        v71 = 0;
      }
      else
      {
        v69 = *((_QWORD *)buffer + 17);
        if (v69)
        {
          v70 = *(_WORD *)(v69 + 2 * (*((_QWORD *)buffer + 19) + v17));
        }
        else
        {
          v78 = *((_QWORD *)buffer + 18);
          if (v78)
          {
            v70 = *(char *)(v78 + *((_QWORD *)buffer + 19) + v17);
          }
          else
          {
            if (*((_QWORD *)buffer + 22) <= v17 || (v79 = *((_QWORD *)buffer + 21), v79 > v17))
            {
              v80 = v17 - 4;
              if ((unint64_t)v17 < 4)
                v80 = 0;
              if (v80 + 64 < v68)
                v68 = v80 + 64;
              *((_QWORD *)buffer + 21) = v80;
              *((_QWORD *)buffer + 22) = v68;
              v117.location = *((_QWORD *)buffer + 19) + v80;
              v117.length = v68 - v80;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v117, buffer);
              v79 = *((_QWORD *)buffer + 21);
            }
            v70 = buffer[v17 - v79];
          }
        }
        v71 = v70;
        if (v70 >> 10 == 54)
        {
          v81 = v17 + 1;
          v82 = *((_QWORD *)buffer + 20);
          if (v82 > v17 + 1)
          {
            v83 = *((_QWORD *)buffer + 17);
            if (v83)
            {
              v84 = *(_WORD *)(v83 + 2 * (*((_QWORD *)buffer + 19) + v81));
            }
            else
            {
              v85 = *((_QWORD *)buffer + 18);
              if (v85)
              {
                v84 = *(char *)(v85 + *((_QWORD *)buffer + 19) + v81);
              }
              else
              {
                if (*((_QWORD *)buffer + 22) <= v81 || (v88 = *((_QWORD *)buffer + 21), v88 > v81))
                {
                  v89 = v17 - 3;
                  if ((unint64_t)v17 < 3)
                    v89 = 0;
                  if (v89 + 64 < v82)
                    v82 = v89 + 64;
                  *((_QWORD *)buffer + 21) = v89;
                  *((_QWORD *)buffer + 22) = v82;
                  v119.location = *((_QWORD *)buffer + 19) + v89;
                  v119.length = v82 - v89;
                  CFStringGetCharacters(*((CFStringRef *)buffer + 16), v119, buffer);
                  v88 = *((_QWORD *)buffer + 21);
                }
                v84 = buffer[v81 - v88];
              }
            }
            if (v84 >> 10 == 55)
            {
              v71 = (v71 << 10) + v84 - 56613888;
              v59 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v71));
              v72 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v71));
              if (!v59)
                goto LABEL_200;
LABEL_151:
              v73 = (unsigned __int16)v71 >> 3;
              v74 = 1 << (v71 & 7);
              if ((v74 & *(_BYTE *)(v59 + v73)) == 0)
              {
                v18 = 0;
                LODWORD(v59) = 0;
                goto LABEL_201;
              }
              if ((a4 & 0x80) != 0 && v71 < 0x510)
              {
                v18 = 1;
              }
              else if (v72 && (v74 & *(_BYTE *)(v72 + v73)) != 0)
              {
                v75 = CFUniCharDecomposeCharacter(v71, a6 + 1, 63);
                v18 = v75 + 1;
                if (v111 && !v75)
                {
                  v18 = 1;
                  *v111 = 1;
                }
              }
              else
              {
                a6[1] = v71;
                v18 = 2;
              }
              v76 = v59 == __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
              LODWORD(v59) = 1;
              if (v76)
                v77 = 1;
              else
                v77 = 2;
              v17 += v77;
LABEL_126:
              if (v18 > 63)
              {
LABEL_127:
                if (v111)
                  *v111 = 1;
LABEL_129:
                if (v18 >= 2)
                {
                  v60 = a7;
                  v61 = &a6[v18];
                  v62 = -4;
                  do
                  {
                    v63 = v62;
                    v64 = (unsigned int *)((char *)v61 + v62);
                    if ((unsigned int *)((char *)v61 + v62) <= a6)
                      break;
                    v65 = *v64;
                    if (HIWORD(*v64))
                    {
                      v66 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(*v64));
                      if (!v66)
                        break;
                    }
                    else
                    {
                      v66 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
                      if (!__CFStringFoldCharacterClusterAtIndex_graphemeBMP)
                        break;
                    }
                    v62 = v63 - 4;
                  }
                  while (((*(unsigned __int8 *)(v66 + ((unsigned __int16)v65 >> 3)) >> (v65 & 7)) & 1) != 0);
                  if (-v63 >= 5)
                    CFUniCharPrioritySort(v64, (unint64_t)-v63 >> 2);
                  a7 = v60;
                }
                goto LABEL_140;
              }
LABEL_201:
              while ((v17 & 0x8000000000000000) == 0)
              {
                v90 = *((_QWORD *)buffer + 20);
                if (v90 <= v17)
                  break;
                v91 = *((_QWORD *)buffer + 17);
                if (v91)
                {
                  v92 = *(_WORD *)(v91 + 2 * (*((_QWORD *)buffer + 19) + v17));
                }
                else
                {
                  v99 = *((_QWORD *)buffer + 18);
                  if (v99)
                  {
                    v92 = *(char *)(v99 + *((_QWORD *)buffer + 19) + v17);
                  }
                  else
                  {
                    if (*((_QWORD *)buffer + 22) <= v17 || (v100 = *((_QWORD *)buffer + 21), v100 > v17))
                    {
                      v101 = v17 - 4;
                      if ((unint64_t)v17 < 4)
                        v101 = 0;
                      if (v101 + 64 < v90)
                        v90 = v101 + 64;
                      *((_QWORD *)buffer + 21) = v101;
                      *((_QWORD *)buffer + 22) = v90;
                      v120.location = *((_QWORD *)buffer + 19) + v101;
                      v120.length = v90 - v101;
                      CFStringGetCharacters(*((CFStringRef *)buffer + 16), v120, buffer);
                      v100 = *((_QWORD *)buffer + 21);
                    }
                    v92 = buffer[v17 - v100];
                  }
                }
                v113 = v92;
                if (v92 >> 10 != 54)
                  goto LABEL_206;
                v102 = v17 + 1;
                v103 = *((_QWORD *)buffer + 20);
                if (v103 <= v17 + 1)
                  goto LABEL_206;
                v104 = *((_QWORD *)buffer + 17);
                if (v104)
                {
                  v105 = *(_WORD *)(v104 + 2 * (*((_QWORD *)buffer + 19) + v102));
                }
                else
                {
                  v106 = *((_QWORD *)buffer + 18);
                  if (v106)
                  {
                    v105 = *(char *)(v106 + *((_QWORD *)buffer + 19) + v102);
                  }
                  else
                  {
                    if (*((_QWORD *)buffer + 22) <= v102 || (v107 = *((_QWORD *)buffer + 21), v107 > v102))
                    {
                      v108 = v17 - 3;
                      if ((unint64_t)v17 < 3)
                        v108 = 0;
                      if (v108 + 64 < v103)
                        v103 = v108 + 64;
                      *((_QWORD *)buffer + 21) = v108;
                      *((_QWORD *)buffer + 22) = v103;
                      v121.location = *((_QWORD *)buffer + 19) + v108;
                      v121.length = v103 - v108;
                      CFStringGetCharacters(*((CFStringRef *)buffer + 16), v121, buffer);
                      v107 = *((_QWORD *)buffer + 21);
                    }
                    v105 = buffer[v102 - v107];
                  }
                }
                if (v105 >> 10 != 55)
                  goto LABEL_206;
                v113 = ((unsigned __int16)v113 << 10) + v105 - 56613888;
                v93 = CFUniCharGetBitmapPtrForPlane(0x6Eu, HIWORD(v113));
                v94 = CFUniCharGetBitmapPtrForPlane(9u, HIWORD(v113));
                if ((v19 & 1) != 0)
                  goto LABEL_222;
LABEL_207:
                if (!v93)
                  goto LABEL_129;
                v95 = (unsigned __int16)v113 >> 3;
                v96 = 1 << (v113 & 7);
                if ((v96 & *(_BYTE *)(v93 + v95)) == 0)
                  goto LABEL_129;
                if ((_DWORD)v59)
                {
                  if (v94 && (v96 & *(_BYTE *)(v94 + v95)) != 0)
                  {
                    v97 = CFUniCharDecomposeCharacter(v113, &a6[v18], 64 - v18);
                    v18 += v97;
                    if (!v97)
                      goto LABEL_127;
                  }
                  else
                  {
                    a6[v18++] = v113;
                  }
                }
                else if ((unint64_t)v18 <= 1)
                {
                  v18 = 1;
                }
                if (v93 == __CFStringFoldCharacterClusterAtIndex_graphemeBMP)
                  v98 = 1;
                else
                  v98 = 2;
                v17 += v98;
LABEL_222:
                v19 = 0;
                if (v18 >= 64)
                  goto LABEL_127;
              }
              v113 = 0;
LABEL_206:
              v93 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
              v94 = __CFStringFoldCharacterClusterAtIndex_decompBMP;
              if ((v19 & 1) != 0)
                goto LABEL_222;
              goto LABEL_207;
            }
          }
        }
      }
      v59 = __CFStringFoldCharacterClusterAtIndex_graphemeBMP;
      v72 = __CFStringFoldCharacterClusterAtIndex_decompBMP;
      if (__CFStringFoldCharacterClusterAtIndex_graphemeBMP)
        goto LABEL_151;
    }
LABEL_200:
    v18 = 0;
    goto LABEL_201;
  }
LABEL_140:
  if (a7 && v18 >= 1)
    *a7 = v17 - v110;
  return v18;
}

void CFStringUppercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  uint64_t *p_info;
  unsigned int v5;
  char v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  char **p_data;
  char *v20;
  uint64_t length;
  uint64_t v22;
  uint64_t v23;
  char v24;
  char **v25;
  char *v26;
  char v27;
  unint64_t v28;
  char *v29;
  int v30;
  char v31;
  char **v32;
  unint64_t v33;
  char v34;
  unsigned int ConditionalCaseMappingFlags;
  unsigned int v36;
  uint64_t v37;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  char v43;
  int v44;
  char v45;
  char v46;
  char v47;
  char v48;
  char v49;
  char v50;
  uint64_t v51;
  uint64_t v52;
  __int16 v53;
  _WORD v54[7];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  p_info = &theString->info;
  v5 = atomic_load((unint64_t *)&theString->info);
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfUppercase:](theString, "_cfUppercase:", locale);
    return;
  }
  v6 = atomic_load((unint64_t *)p_info);
  if ((v6 & 1) == 0)
  {
    v7 = _CFOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      CFStringUppercase_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    return;
  }
  v15 = atomic_load((unint64_t *)&theString->info);
  v16 = v15 & 5;
  v17 = atomic_load((unint64_t *)&theString->info);
  v18 = v17 & 0x60;
  if (v16 == 4)
  {
    p_data = &theString->data;
    if (v18)
    {
      v20 = *p_data;
    }
    else
    {
      v22 = atomic_load((unint64_t *)&theString->info);
      v20 = (char *)&p_data[(v22 & 5) != 4];
    }
    length = *v20;
  }
  else if ((v17 & 0x60) != 0)
  {
    length = theString->length;
  }
  else
  {
    length = (uint64_t)theString->data;
  }
  if (locale)
    locale = (CFLocaleRef)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 0);
  v23 = 0;
  if (locale || ((v5 >> 4) & 1) != 0)
  {
LABEL_28:
    if (v23 >= length)
      return;
    if (((v5 >> 4) & 1) == 0)
    {
      v51 = 0;
      v52 = 0;
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
    }
    v31 = atomic_load((unint64_t *)&theString->info);
    v32 = &theString->data;
    if ((v31 & 0x60) != 0)
    {
      v33 = (unint64_t)*v32;
    }
    else
    {
      v34 = atomic_load((unint64_t *)&theString->info);
      v33 = (unint64_t)&v32[(v34 & 5) != 4];
    }
    ConditionalCaseMappingFlags = 0;
    while (1)
    {
      v36 = *(unsigned __int16 *)(v33 + 2 * v23);
      v37 = v23 + 1;
      if ((v36 & 0xFC00) == 0xD800 && v37 < length)
      {
        v44 = *(unsigned __int16 *)(v33 + 2 * v37);
        if ((v44 & 0xFC00) == 0xDC00)
          v36 = v44 + (v36 << 10) - 56613888;
      }
      if (locale)
        ConditionalCaseMappingFlags = CFUniCharGetConditionalCaseMappingFlags(v36, v33, v23, length, 1, (unsigned __int16 *)locale, ConditionalCaseMappingFlags);
      else
        ConditionalCaseMappingFlags = 0;
      v39 = CFUniCharMapCaseTo(v36, &v53, 8, 1, ConditionalCaseMappingFlags, (unsigned __int16 *)locale);
      v40 = v39 - 1;
      if (v39 >= 1)
        *(_WORD *)(v33 + 2 * v23) = v53;
      if (v36 < 0x10000)
      {
        if (!v39)
        {
          v51 = v23;
LABEL_59:
          v52 = 1;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
          v45 = atomic_load((unint64_t *)&theString->info);
          if ((v45 & 0x60) != 0)
          {
            v33 = (unint64_t)*v32;
          }
          else
          {
            v47 = atomic_load((unint64_t *)&theString->info);
            v33 = (unint64_t)&v32[(v47 & 5) != 4];
          }
          --length;
          goto LABEL_72;
        }
        if (v39 >= 2)
        {
          v51 = v23 + 1;
          v52 = 0;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, v40, 1);
          v43 = atomic_load((unint64_t *)&theString->info);
          if ((v43 & 0x60) != 0)
          {
            v33 = (unint64_t)*v32;
          }
          else
          {
            v48 = atomic_load((unint64_t *)&theString->info);
            v33 = (unint64_t)&v32[(v48 & 5) != 4];
          }
          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v40;
LABEL_71:
          v23 += v40;
        }
      }
      else
      {
        v41 = v39 - 2;
        if (v39 != 2)
        {
          v40 = v39 - 1;
          if (v39 == 1)
          {
            v51 = v23 + 1;
            goto LABEL_59;
          }
          if (!v39)
          {
            v51 = v23;
            v52 = 2;
            __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
            v42 = atomic_load((unint64_t *)&theString->info);
            if ((v42 & 0x60) != 0)
            {
              v33 = (unint64_t)*v32;
            }
            else
            {
              v49 = atomic_load((unint64_t *)&theString->info);
              v33 = (unint64_t)&v32[(v49 & 5) != 4];
            }
            length -= 2;
            goto LABEL_72;
          }
          v51 = v23 + 1;
          v52 = 0;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, v41, 1);
          v46 = atomic_load((unint64_t *)&theString->info);
          if ((v46 & 0x60) != 0)
          {
            v33 = (unint64_t)*v32;
          }
          else
          {
            v50 = atomic_load((unint64_t *)&theString->info);
            v33 = (unint64_t)&v32[(v50 & 5) != 4];
          }
          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v41;
          goto LABEL_71;
        }
        ++v23;
        *(_WORD *)(v33 + 2 * v23) = v54[0];
      }
LABEL_72:
      if (++v23 >= length)
        return;
    }
  }
  v24 = atomic_load((unint64_t *)&theString->info);
  v25 = &theString->data;
  if ((v24 & 0x60) != 0)
  {
    v26 = *v25;
  }
  else
  {
    v27 = atomic_load((unint64_t *)&theString->info);
    v26 = (char *)&v25[(v27 & 5) != 4];
  }
  v28 = atomic_load((unint64_t *)&theString->info);
  if (length >= 1)
  {
    v23 = 0;
    v29 = &v26[(v28 >> 2) & 1];
    do
    {
      v30 = v29[v23];
      if ((v30 - 97) > 0x19)
      {
        if (v30 < 0)
          goto LABEL_28;
      }
      else
      {
        v29[v23] = v30 - 32;
      }
      ++v23;
    }
    while (length != v23);
  }
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
  uint64_t *p_info;
  unsigned int v5;
  char v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  char **p_data;
  char *v20;
  uint64_t length;
  uint64_t v22;
  uint64_t v23;
  char v24;
  char **v25;
  char *v26;
  char v27;
  unint64_t v28;
  char *v29;
  int v30;
  char v31;
  char **v32;
  unint64_t v33;
  char v34;
  unsigned int ConditionalCaseMappingFlags;
  unsigned int v36;
  uint64_t v37;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  char v43;
  int v44;
  char v45;
  char v46;
  char v47;
  char v48;
  char v49;
  char v50;
  uint64_t v51;
  uint64_t v52;
  __int16 v53;
  _WORD v54[7];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  p_info = &theString->info;
  v5 = atomic_load((unint64_t *)&theString->info);
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString _cfLowercase:](theString, "_cfLowercase:", locale);
    return;
  }
  v6 = atomic_load((unint64_t *)p_info);
  if ((v6 & 1) == 0)
  {
    v7 = _CFOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      CFStringLowercase_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    return;
  }
  v15 = atomic_load((unint64_t *)&theString->info);
  v16 = v15 & 5;
  v17 = atomic_load((unint64_t *)&theString->info);
  v18 = v17 & 0x60;
  if (v16 == 4)
  {
    p_data = &theString->data;
    if (v18)
    {
      v20 = *p_data;
    }
    else
    {
      v22 = atomic_load((unint64_t *)&theString->info);
      v20 = (char *)&p_data[(v22 & 5) != 4];
    }
    length = *v20;
  }
  else if ((v17 & 0x60) != 0)
  {
    length = theString->length;
  }
  else
  {
    length = (uint64_t)theString->data;
  }
  if (locale)
    locale = (CFLocaleRef)_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(locale, 0);
  v23 = 0;
  if (locale || ((v5 >> 4) & 1) != 0)
  {
LABEL_28:
    if (v23 >= length)
      return;
    if (((v5 >> 4) & 1) == 0)
    {
      v51 = 0;
      v52 = 0;
      __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
    }
    v31 = atomic_load((unint64_t *)&theString->info);
    v32 = &theString->data;
    if ((v31 & 0x60) != 0)
    {
      v33 = (unint64_t)*v32;
    }
    else
    {
      v34 = atomic_load((unint64_t *)&theString->info);
      v33 = (unint64_t)&v32[(v34 & 5) != 4];
    }
    ConditionalCaseMappingFlags = 0;
    while (1)
    {
      v36 = *(unsigned __int16 *)(v33 + 2 * v23);
      v37 = v23 + 1;
      if ((v36 & 0xFC00) == 0xD800 && v37 < length)
      {
        v44 = *(unsigned __int16 *)(v33 + 2 * v37);
        if ((v44 & 0xFC00) == 0xDC00)
          v36 = v44 + (v36 << 10) - 56613888;
      }
      if (locale || v36 == 931)
        ConditionalCaseMappingFlags = CFUniCharGetConditionalCaseMappingFlags(v36, v33, v23, length, 0, (unsigned __int16 *)locale, ConditionalCaseMappingFlags);
      else
        ConditionalCaseMappingFlags = 0;
      v39 = CFUniCharMapCaseTo(v36, &v53, 8, 0, ConditionalCaseMappingFlags, (unsigned __int16 *)locale);
      v40 = v39 - 1;
      if (v39 >= 1)
        *(_WORD *)(v33 + 2 * v23) = v53;
      if (v36 < 0x10000)
      {
        if (!v39)
        {
          v51 = v23;
LABEL_60:
          v52 = 1;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
          v45 = atomic_load((unint64_t *)&theString->info);
          if ((v45 & 0x60) != 0)
          {
            v33 = (unint64_t)*v32;
          }
          else
          {
            v47 = atomic_load((unint64_t *)&theString->info);
            v33 = (unint64_t)&v32[(v47 & 5) != 4];
          }
          --length;
          goto LABEL_73;
        }
        if (v39 >= 2)
        {
          v51 = v23 + 1;
          v52 = 0;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, v40, 1);
          v43 = atomic_load((unint64_t *)&theString->info);
          if ((v43 & 0x60) != 0)
          {
            v33 = (unint64_t)*v32;
          }
          else
          {
            v48 = atomic_load((unint64_t *)&theString->info);
            v33 = (unint64_t)&v32[(v48 & 5) != 4];
          }
          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v40;
LABEL_72:
          v23 += v40;
        }
      }
      else
      {
        v41 = v39 - 2;
        if (v39 != 2)
        {
          v40 = v39 - 1;
          if (v39 == 1)
          {
            v51 = v23 + 1;
            goto LABEL_60;
          }
          if (!v39)
          {
            v51 = v23;
            v52 = 2;
            __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, 0, 1);
            v42 = atomic_load((unint64_t *)&theString->info);
            if ((v42 & 0x60) != 0)
            {
              v33 = (unint64_t)*v32;
            }
            else
            {
              v49 = atomic_load((unint64_t *)&theString->info);
              v33 = (unint64_t)&v32[(v49 & 5) != 4];
            }
            length -= 2;
            goto LABEL_73;
          }
          v51 = v23 + 1;
          v52 = 0;
          __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)&v51, 1, v41, 1);
          v46 = atomic_load((unint64_t *)&theString->info);
          if ((v46 & 0x60) != 0)
          {
            v33 = (unint64_t)*v32;
          }
          else
          {
            v50 = atomic_load((unint64_t *)&theString->info);
            v33 = (unint64_t)&v32[(v50 & 5) != 4];
          }
          memmove((void *)(v33 + 2 * v23 + 2), v54, 2 * v40);
          length += v41;
          goto LABEL_72;
        }
        ++v23;
        *(_WORD *)(v33 + 2 * v23) = v54[0];
      }
LABEL_73:
      if (++v23 >= length)
        return;
    }
  }
  v24 = atomic_load((unint64_t *)&theString->info);
  v25 = &theString->data;
  if ((v24 & 0x60) != 0)
  {
    v26 = *v25;
  }
  else
  {
    v27 = atomic_load((unint64_t *)&theString->info);
    v26 = (char *)&v25[(v27 & 5) != 4];
  }
  v28 = atomic_load((unint64_t *)&theString->info);
  if (length >= 1)
  {
    v23 = 0;
    v29 = &v26[(v28 >> 2) & 1];
    do
    {
      v30 = v29[v23];
      if ((v30 - 65) > 0x19)
      {
        if ((v30 & 0x80) != 0)
          goto LABEL_28;
      }
      else
      {
        v29[v23] = v30 + 32;
      }
      ++v23;
    }
    while (length != v23);
  }
}

uint64_t _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale(const __CFLocale *a1, int a2)
{
  const char *v4;
  uint64_t v5;
  BOOL v6;
  const __CFString *Value;
  const __CFString *v8;
  const char *CStringPtrInternal;
  UInt8 buffer[2];
  uint64_t v12;
  CFRange v13;

  v12 = *MEMORY[0x1E0C80C00];
  if (!__CFLocaleGetDoesNotRequireSpecialCaseHandling(a1))
  {
    os_unfair_lock_lock_with_options();
    v5 = _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLocale;
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lock);
    if (v5)
      v6 = v5 == (_QWORD)a1;
    else
      v6 = 0;
    if (v6)
      return _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLangID;
    if (a2)
      Value = (const __CFString *)CFLocaleGetValue(a1, CFSTR("locale:collator id"));
    else
      Value = CFLocaleGetIdentifier(a1);
    v8 = Value;
    if (CFStringGetLength(Value) >= 2)
    {
      CStringPtrInternal = (const char *)_CFStringGetCStringPtrInternal((uint64_t)v8, 0x8000100u, 1, 1);
      if (CStringPtrInternal
        || (CStringPtrInternal = (const char *)buffer,
            v13.location = 0,
            v13.length = 2,
            CFStringGetBytes(v8, v13, 0x8000100u, 0, 0, buffer, 2, 0) == 2))
      {
        v4 = "az";
        if (!strncmp(CStringPtrInternal, "az", 2uLL)
          || (v4 = "lt", !strncmp(CStringPtrInternal, "lt", 2uLL))
          || (v4 = "tr", !strncmp(CStringPtrInternal, "tr", 2uLL))
          || (v4 = "nl", !strncmp(CStringPtrInternal, "nl", 2uLL))
          || (v4 = "el", !strncmp(CStringPtrInternal, "el", 2uLL)))
        {
          os_unfair_lock_lock_with_options();
          _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLocale = (uint64_t)a1;
          _CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lastLangID = (uint64_t)v4;
          os_unfair_lock_unlock((os_unfair_lock_t)&_CFStrGetSpecialCaseHandlingLanguageIdentifierForLocale_lock);
          return (uint64_t)v4;
        }
      }
    }
  }
  return 0;
}

uint64_t __CFLocaleGetDoesNotRequireSpecialCaseHandling(void *a1)
{
  return objc_msgSend(a1, "_doesNotRequireSpecialCaseHandling");
}

uint64_t CFUniCharMapCaseTo(unsigned int a1, __int16 *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, unsigned __int16 *a6)
{
  uint64_t v8;
  uint64_t v10;
  unsigned int *v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  int IsMemberOf;
  uint64_t v20;
  unsigned int *v21;
  _DWORD *v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t result;
  unsigned int v29;
  __int16 *v30;
  BOOL v31;
  __int16 v32;
  __int16 v33;
  int *v34;
  int *v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int *v38;
  unsigned int *v39;
  unsigned int *v40;
  __int16 v41;
  unsigned int *v42;
  uint64_t v43;
  __int16 *v44;
  int v45;
  __int16 *v46;
  __int16 v47;
  unsigned __int16 v48;
  unint64_t v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  __int16 *v53;
  __int16 v54;
  int v55;
  int v57;
  unsigned int v58;
  uint64_t v60;
  unsigned int v61;
  _BYTE v62[44];

  v8 = a4;
  *(_QWORD *)&v62[36] = *MEMORY[0x1E0C80C00];
  v10 = (a1 == 931) & a5;
  v11 = (unsigned int *)v62;
  v58 = a1 & 0xFFFFFFDF;
  v12 = (a5 & 2) != 0 && a1 == 775;
  v13 = !v12;
  v14 = BYTE2(a1);
  v15 = 1 << (a1 & 7);
  v60 = (unsigned __int16)a1 >> 3;
  v55 = a4;
  v16 = __CFUniCharBitmapDataArray;
  while (1)
  {
    if ((_DWORD)v10)
    {
      v31 = v55 == 0;
      v32 = 931;
      v33 = 962;
      goto LABEL_75;
    }
    if (!a6)
      goto LABEL_51;
    if ((a5 & 0x10) != 0)
    {
      if (a1 == 769)
        return 0;
      if (a1 == 836)
      {
        v32 = 776;
        goto LABEL_77;
      }
      v17 = v16;
      v18 = v10;
      IsMemberOf = CFUniCharIsMemberOf(a1, 9u);
      v10 = v18;
      v16 = v17;
      if (IsMemberOf)
        break;
    }
LABEL_19:
    v23 = *a6;
    if (v23 <= 0x746B)
    {
      if (v23 == 27758)
      {
        if (v58 == 74)
        {
          if ((a5 & 8) != 0)
            v41 = 74;
          else
            v41 = 106;
          if ((v8 - 1) >= 2)
            v32 = v41;
          else
            v32 = 74;
          goto LABEL_77;
        }
        goto LABEL_51;
      }
      if (v23 != 29300)
        goto LABEL_51;
LABEL_31:
      if ((int)a1 <= 304)
      {
        if (a1 == 73)
          goto LABEL_103;
        if (a1 == 105 || a1 == 304)
        {
          v31 = (_DWORD)v8 == 3 || (_DWORD)v8 == 0;
          v32 = 304;
          v33 = 105;
          goto LABEL_75;
        }
      }
      else if (a1 == 775)
      {
        if ((a5 & 2) != 0)
        {
          if (!(_DWORD)v8)
            return 0;
          v32 = 775;
LABEL_77:
          *a2 = v32;
          return 1;
        }
      }
      else if (a1 == 305)
      {
LABEL_103:
        if ((_DWORD)v8 != 3 && (_DWORD)v8)
        {
          v32 = 73;
          goto LABEL_77;
        }
        v31 = (a5 & 4) == 0;
        v32 = 105;
        v33 = 305;
LABEL_75:
        if (v31)
          v32 = v33;
        goto LABEL_77;
      }
      goto LABEL_51;
    }
    if (v23 == 31329)
      goto LABEL_31;
    if (v23 != 29804)
      goto LABEL_51;
    if (!v13)
      return 0;
    if ((_DWORD)v8)
      goto LABEL_51;
    if ((a5 & 4) != 0)
    {
      if ((int)a1 > 204)
      {
        switch(a1)
        {
          case 0xCDu:
            goto LABEL_126;
          case 0x128u:
LABEL_127:
            v46 = a2;
            *(_DWORD *)a2 = 50790505;
            v47 = 771;
            goto LABEL_128;
          case 0x12Eu:
            v48 = 303;
            goto LABEL_137;
        }
        goto LABEL_51;
      }
      if (a1 == 73)
      {
        v48 = 105;
LABEL_137:
        *(_DWORD *)a2 = v48 | 0x3070000;
        return 2;
      }
      if (a1 == 74)
      {
        v48 = 106;
        goto LABEL_137;
      }
    }
    else
    {
      if (a1 == 296)
        goto LABEL_127;
      if (a1 == 205)
      {
LABEL_126:
        v46 = a2;
        *(_DWORD *)a2 = 50790505;
        v47 = 769;
        goto LABEL_128;
      }
    }
    if (a1 == 204)
    {
      v46 = a2;
      *(_DWORD *)a2 = 50790505;
      v47 = 768;
LABEL_128:
      v46[2] = v47;
      return 3;
    }
LABEL_51:
    if ((v8 + 87) >= 0x54)
      v24 = v8 + 103;
    else
      v24 = v8 + 188;
    if ((_DWORD)v8 == -102)
      v25 = 108;
    else
      v25 = v24;
    if (v25 > 0x63)
      v25 -= 85;
    v26 = v25 - 4;
    if (v14 < LODWORD(v16[2 * v26]))
    {
      v27 = *(_QWORD *)(v16[2 * v26 + 1] + 8 * v14);
      if (v27)
      {
        if ((v15 & *(_BYTE *)(v27 + v60)) != 0)
        {
          v34 = (&__CFUniCharCaseMappingTable)[v8];
          if (*v34 <= a1)
          {
            v35 = &v34[2 * (__CFUniCharCaseMappingTableCounts[v8] - 1)];
            if (*v35 >= a1)
            {
              do
              {
                v36 = (unsigned int *)&v34[2 * (((char *)v35 - (char *)v34) >> 4)];
                if (*v36 <= a1)
                {
                  if (*v36 >= a1)
                  {
                    v37 = v36[1];
LABEL_89:
                    if ((_DWORD)v8 != 2 || v37)
                    {
                      if (!v37)
                        goto LABEL_63;
                      goto LABEL_107;
                    }
                    if (a1 - 125252 < 0xFFFE171D)
                      goto LABEL_63;
                    v38 = (unsigned int *)&__CFUniCharToUppercaseMappingTable;
                    v39 = (unsigned int *)((char *)&__CFUniCharToUppercaseMappingTable + 12192);
                    while (1)
                    {
                      v40 = &v38[2 * (((char *)v39 - (char *)v38) >> 4)];
                      if (*v40 <= a1)
                      {
                        if (*v40 >= a1)
                        {
                          v37 = v40[1];
                          if (!v37)
                            goto LABEL_63;
                          LODWORD(v8) = 1;
LABEL_107:
                          result = HIBYTE(v37) & 0x1F;
                          if ((_DWORD)result == 1)
                          {
                            if ((v37 & 0x80000000) != 0)
                            {
                              if (a3 < 2)
                                goto LABEL_63;
                              *a2 = (((v37 & 0xFFFC00) + 67043328) >> 10) - 10240;
                              a2[1] = v37 & 0x3FF | 0xDC00;
                              return 2;
                            }
                            *a2 = v37;
                            return 1;
                          }
                          if (result >= a3)
                            goto LABEL_63;
                          v42 = (unsigned int *)((char *)*(&__CFUniCharCaseMappingExtraTable + v8)
                                               + 4 * (v37 & 0xFFFFFF));
                          if ((v37 & 0x80000000) != 0)
                          {
                            if (!(_DWORD)result)
                              goto LABEL_63;
                            v49 = result + 1;
                            result = 0;
                            while (1)
                            {
                              v51 = *v42++;
                              v50 = v51;
                              if (v51 < 0x10000)
                              {
                                v52 = result + 1;
                                v53 = a2;
                                if (result + 1 >= a3)
                                {
LABEL_147:
                                  if (v49 == 2)
                                    return result;
LABEL_63:
                                  if (a1 >= 0x10000)
                                  {
                                    *a2 = (((a1 & 0xFFFC00) + 67043328) >> 10) - 10240;
                                    a2[1] = a1 & 0x3FF | 0xDC00;
                                    return 2;
                                  }
                                  *a2 = a1;
                                  return 1;
                                }
                                v54 = v50;
                              }
                              else
                              {
                                v52 = result + 2;
                                v53 = a2;
                                if (result + 2 >= a3)
                                  goto LABEL_147;
                                a2[result++] = (((v50 & 0xFFFC00) + 67043328) >> 10) - 10240;
                                v54 = v50 & 0x3FF | 0xDC00;
                              }
                              v53[result] = v54;
                              --v49;
                              result = v52;
                              if (v49 <= 1)
                                goto LABEL_63;
                            }
                          }
                          if ((_DWORD)result)
                          {
                            v43 = HIBYTE(v37) & 0x1F;
                            v44 = a2;
                            do
                            {
                              v45 = *v42++;
                              *v44++ = v45;
                              --v43;
                            }
                            while (v43);
                            return result;
                          }
                          return 0;
                        }
                        v38 = v40 + 2;
                      }
                      else
                      {
                        v39 = v40 - 2;
                      }
                      if (v38 > v39)
                        goto LABEL_63;
                    }
                  }
                  v34 = (int *)(v36 + 2);
                }
                else
                {
                  v35 = (int *)(v36 - 2);
                }
              }
              while (v34 <= v35);
            }
          }
          v37 = 0;
          goto LABEL_89;
        }
      }
    }
    v12 = (_DWORD)v8 == 3;
    v8 = 0;
    if (!v12)
      goto LABEL_63;
  }
  v57 = v15;
  v20 = CFUniCharDecomposeCharacter(a1, &v61, 10);
  if (v20 < 2)
  {
LABEL_18:
    v15 = v57;
    v16 = v17;
    v10 = v18;
    goto LABEL_19;
  }
  v21 = (unsigned int *)&v62[4 * v20 - 4];
  v22 = v62;
  while (*v22 != 769)
  {
    if (++v22 >= v21)
      goto LABEL_18;
  }
  result = CFUniCharMapCaseTo(v61, a2, a3, v8, 0, a6);
  if (!result)
  {
    *a2 = v61;
    result = 1;
  }
  do
  {
    v29 = *v11;
    if (*v11 != 769)
    {
      if (HIWORD(v29))
      {
        v30 = &a2[result];
        *v30 = ((v29 + 67043328) >> 10) - 10240;
        result += 2;
        v30[1] = v29 & 0x3FF | 0xDC00;
      }
      else
      {
        a2[result++] = v29;
      }
    }
    ++v11;
  }
  while (v11 < v21);
  return result;
}

CFTypeRef getTokenizersForLocale(void *key)
{
  const __CFDictionary *Mutable;
  CFMutableArrayRef v3;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[0] = 0;
  Mutable = (const __CFDictionary *)gTokenizers;
  if (!gTokenizers)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    gTokenizers = (uint64_t)Mutable;
  }
  if (!CFDictionaryGetValueIfPresent(Mutable, key, cf))
  {
    v3 = CFArrayCreateMutable(0, 3, 0);
    cf[0] = v3;
    if (v3)
    {
      CFDictionarySetValue((CFMutableDictionaryRef)gTokenizers, key, v3);
      CFRelease(cf[0]);
    }
  }
  return cf[0];
}

Boolean CFStringIsHyphenationAvailableForLocale(CFLocaleRef locale)
{
  if (locale)
  {
    locale = (CFLocaleRef)__CFHyphenationCopyTrieInstance(locale);
    if (locale)
    {
      CFBurstTrieRelease(locale);
      LOBYTE(locale) = 1;
    }
  }
  return locale;
}

_QWORD *__CFHyphenationCopyTrieInstance(const __CFLocale *a1)
{
  CFLocaleIdentifier Identifier;
  const __CFDictionary *v3;
  _QWORD *Value;
  _QWORD *v5;
  const __CFString *v6;
  CFTypeRef v7;
  const __CFString *DictionaryPathForLanguageAndRegion;
  const __CFString *v9;
  BOOL v10;
  const __CFString *v11;
  const __CFString *v12;
  CFDictionaryValueCallBacks v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  Identifier = CFLocaleGetIdentifier(a1);
  os_unfair_lock_lock_with_options();
  v3 = (const __CFDictionary *)__CFHyphenationCopyTrieInstance_gTries;
  if (!__CFHyphenationCopyTrieInstance_gTries)
  {
    *(_OWORD *)&v14.version = xmmword_1E13360F0;
    *(_OWORD *)&v14.release = *(_OWORD *)&off_1E1336100;
    v14.equal = 0;
    v3 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &v14);
    __CFHyphenationCopyTrieInstance_gTries = (uint64_t)v3;
  }
  Value = CFDictionaryGetValue(v3, Identifier);
  if (Value)
  {
    v5 = Value;
    CFBurstTrieRetain((uint64_t)Value);
    goto LABEL_16;
  }
  v6 = (const __CFString *)CFLocaleGetValue(a1, CFSTR("kCFLocaleLanguageCodeKey"));
  v7 = CFLocaleGetValue(a1, CFSTR("kCFLocaleCountryCodeKey"));
  DictionaryPathForLanguageAndRegion = __CFHyphenationCreateDictionaryPathForLanguageAndRegion(v6, (unint64_t)v7);
  if (!DictionaryPathForLanguageAndRegion)
    goto LABEL_15;
  v9 = DictionaryPathForLanguageAndRegion;
  v5 = CFBurstTrieCreateFromFile(DictionaryPathForLanguageAndRegion);
  CFRelease(v9);
  if (v7)
    v10 = v5 == 0;
  else
    v10 = 0;
  if (!v10)
    goto LABEL_13;
  v11 = __CFHyphenationCreateDictionaryPathForLanguageAndRegion(v6, 0);
  if (!v11)
  {
LABEL_15:
    v5 = 0;
    goto LABEL_16;
  }
  v12 = v11;
  v5 = CFBurstTrieCreateFromFile(v11);
  CFRelease(v12);
LABEL_13:
  if (v5)
    CFDictionaryAddValue((CFMutableDictionaryRef)__CFHyphenationCopyTrieInstance_gTries, Identifier, v5);
LABEL_16:
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFHyphenationCopyTrieInstance_trieMutex);
  return v5;
}

uint64_t CFBurstTrieRetain(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 2084);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return result;
}

uint64_t CFBurstTrieContains(uint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, _DWORD *a5)
{
  CFIndex v10;
  UInt8 *v11;
  uint64_t v12;
  CFIndex v13;
  CFIndex usedBufLen;
  _BYTE v16[343];
  uint64_t v17;
  CFRange v18;

  v17 = *MEMORY[0x1E0C80C00];
  if (a4 > 1023)
    return 0;
  usedBufLen = 0;
  if (a4 < 86)
  {
    v10 = 342;
    v11 = v16;
  }
  else
  {
    v10 = 4 * a4;
    v11 = (UInt8 *)malloc_type_malloc((4 * a4) | 1, 0x4E9C7E14uLL);
  }
  v18.location = a3;
  v18.length = a4;
  CFStringGetBytes(a2, v18, 0x8000100u, 0x2Du, 0, v11, v10, &usedBufLen);
  v13 = usedBufLen;
  v11[usedBufLen] = 0;
  v12 = CFBurstTrieContainsUTF8String(a1, (uint64_t)v11, v13, a5);
  if (v16 != v11)
    free(v11);
  return v12;
}

uint64_t CFUniCharDecomposeCharacter(unsigned int a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3;

  if (a1 - 44032 > 0x2BA4)
    return __CFUniCharRecursivelyDecomposeCharacter(a1, a2, a3);
  v3 = 2;
  if ((unsigned __int16)(a1 + 21504) % 0x1Cu)
    v3 = 3;
  if (v3 > a3)
    return 0;
  *a2 = ((28533 * (unsigned __int16)(a1 + 21504)) >> 24) | 0x1100;
  a2[1] = (unsigned __int16)(a1 + 21504) % 0x24Cu / 0x1C + 4449;
  if (!((unsigned __int16)(a1 + 21504) % 0x1Cu))
    return 2;
  a2[2] = (unsigned __int16)((unsigned __int16)(a1 + 21504) % 0x1Cu + 4519);
  return 3;
}

unsigned int *__CFUniCharPrioritySort(unsigned int *result, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  char v8;
  _DWORD *v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;

  v2 = (unint64_t)&result[a2];
  if (a2 >= 1)
  {
    do
    {
      v3 = *result;
      if (!(v3 >> 17))
      {
        v4 = *(uint64_t *)((char *)&__CFUniCharCombiningPriorityTable_0 + ((v3 >> 13) & 0x7FFF8));
        if (*(_BYTE *)(v4 + BYTE1(v3)))
        {
          if (*(_BYTE *)(v4 + (*(unsigned __int8 *)(v4 + BYTE1(v3)) << 8) - 256 + v3 + 256))
            break;
        }
      }
      ++result;
    }
    while ((unint64_t)result < v2);
  }
  if ((uint64_t)(v2 - (_QWORD)result) >= 5)
  {
    do
    {
      v5 = *result;
      if (v5 >> 17)
      {
        v7 = 0;
      }
      else
      {
        v6 = *(uint64_t *)((char *)&__CFUniCharCombiningPriorityTable_0 + ((v5 >> 13) & 0x7FFF8));
        v7 = *(unsigned __int8 *)(v6 + BYTE1(v5));
        if (*(_BYTE *)(v6 + BYTE1(v5)))
          v7 = *(unsigned __int8 *)(v6 + (v7 << 8) - 256 + v5 + 256);
      }
      if ((unint64_t)(result + 1) >= v2)
        break;
      v8 = 0;
      v9 = result + 1;
      do
      {
        v10 = *v9;
        if (v10 >> 17
          || (v11 = *(uint64_t *)((char *)&__CFUniCharCombiningPriorityTable_0 + ((v10 >> 13) & 0x7FFF8)),
              !*(_BYTE *)(v11 + BYTE1(v10))))
        {
          v12 = 0;
        }
        else
        {
          v12 = *(unsigned __int8 *)(v11
                                   + (*(unsigned __int8 *)(v11 + BYTE1(v10)) << 8)
                                   - 256
                                   + v10
                                   + 256);
        }
        if (v7 > v12)
        {
          v13 = *(v9 - 1);
          *(v9 - 1) = v10;
          *v9 = v13;
          v8 = 1;
        }
        ++v9;
        v7 = v12;
      }
      while ((unint64_t)v9 < v2);
    }
    while ((v8 & 1) != 0);
  }
  return result;
}

CFStringRef __CFHyphenationCreateDictionaryPathForLanguageAndRegion(const __CFString *a1, unint64_t a2)
{
  __CFString *v4;
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  const void *LinguisticDataPath;
  CFStringRef v8;

  if (!a1)
    return 0;
  v4 = a2 | CFStringCompare(a1, CFSTR("en"), 0) ? (__CFString *)a2 : CFSTR("US");
  Mutable = CFArrayCreateMutable(0, 10, &kCFTypeArrayCallBacks);
  if (!Mutable)
    return 0;
  v6 = Mutable;
  LinguisticDataPath = (const void *)_CFHyphenationGetLinguisticDataPath();
  CFArrayAppendValue(v6, LinguisticDataPath);
  CFArrayAppendValue(v6, a1);
  if (v4)
    CFArrayAppendValue(v6, v4);
  CFArrayAppendValue(v6, CFSTR("hyphenation.dat"));
  v8 = CFStringCreateByCombiningStrings(0, v6, CFSTR("/"));
  CFRelease(v6);
  return v8;
}

void sub_182AFE0C8(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFHyphenationGetLinguisticDataPath()
{
  uint64_t result;

  result = _CFCustomHyphenationLinguisticDataPath;
  if (!_CFCustomHyphenationLinguisticDataPath)
  {
    if (_CFHyphenationGetLinguisticDataPath_once_token != -1)
      dispatch_once(&_CFHyphenationGetLinguisticDataPath_once_token, &__block_literal_global_41);
    return _CFDefaultHyphenationLinguisticDataPath;
  }
  return result;
}

_QWORD *CFBurstTrieCreateFromFile(const __CFString *a1)
{
  _QWORD *v1;
  int v3;
  int v4;
  int *v5;
  int v6;
  _QWORD *v8;
  char buffer[1024];
  stat v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  memset(&v10, 0, sizeof(v10));
  if (CFStringGetCString(a1, buffer, 1024, 0x8000100u))
  {
    if (!stat(buffer, &v10))
    {
      v3 = open(buffer, 0, 0);
      if ((v3 & 0x80000000) == 0)
      {
        v4 = v3;
        v5 = (int *)mmap(0, v10.st_size, 1, 1, v3, 0);
        v6 = *v5;
        if (*v5 == 14531089 || v6 == -889275714)
        {
          v8 = malloc_type_calloc(1uLL, 0x830uLL, 0x1010040873DE71CuLL);
          v1 = v8;
          v8[257] = v5;
          *((_DWORD *)v8 + 516) = v10.st_size;
        }
        else
        {
          v1 = 0;
          if (v6 != -1161889074)
          {
LABEL_15:
            close(v4);
            return v1;
          }
          v8 = malloc_type_calloc(1uLL, 0x830uLL, 0x1010040873DE71CuLL);
          v1 = v8;
          v8[257] = v5;
          *((_DWORD *)v8 + 516) = v10.st_size;
          *((_DWORD *)v8 + 517) = v5[1];
        }
        *((_DWORD *)v8 + 518) = v5[4];
        *((_DWORD *)v1 + 519) = v5[2];
        atomic_store(1u, (unsigned int *)v1 + 521);
        *((_BYTE *)v1 + 2088) = 1;
        goto LABEL_15;
      }
    }
  }
  return 0;
}

uint64_t __CFUniCharRecursivelyDecomposeCharacter(unsigned int a1, _DWORD *a2, uint64_t a3)
{
  _DWORD *v4;
  char *v5;
  char *v6;
  char *v7;
  unsigned int v8;
  uint64_t v9;
  int *v10;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  int *v16;
  int v17;
  int v18;
  uint64_t v19;

  v4 = a2;
  v19 = *MEMORY[0x1E0C80C00];
  if (a1 - 195102 < 0xFFFD06A2)
  {
LABEL_8:
    v8 = 0;
    goto LABEL_9;
  }
  v5 = (char *)&__CFUniCharDecompositionTable;
  v6 = (char *)&__CFUniCharDecompositionTable + 16480;
  while (1)
  {
    v7 = &v5[8 * ((v6 - v5) >> 4)];
    if (*(_DWORD *)v7 <= a1)
      break;
    v6 = v7 - 8;
LABEL_7:
    if (v5 > v6)
      goto LABEL_8;
  }
  if (*(_DWORD *)v7 < a1)
  {
    v5 = v7 + 8;
    goto LABEL_7;
  }
  v8 = *((_DWORD *)v7 + 1);
LABEL_9:
  v9 = HIBYTE(v8) & 0x1F;
  v18 = v8 & 0xFFFFFF;
  v10 = (int *)((char *)&__CFUniCharMultipleDecompositionTable + 4 * (v8 & 0xFFFFFF));
  v11 = &v18;
  if ((v8 & 0x1E000000) != 0)
    v11 = (int *)((char *)&__CFUniCharMultipleDecompositionTable + 4 * (v8 & 0xFFFFFF));
  v12 = a3 - v9;
  if (a3 < v9)
    return 0;
  if ((v8 & 0x40000000) == 0)
  {
    v13 = 0;
    goto LABEL_23;
  }
  v13 = __CFUniCharRecursivelyDecomposeCharacter(*v11, a2, v12);
  if (!v13 || v13 + v9 - 1 > a3)
    return 0;
  v16 = &v18;
  if (v9 > 1)
    v16 = v10;
  v11 = v16 + 1;
  v4 += v13;
  --v9;
LABEL_23:
  for (result = v13 + v9; v9; --v9)
  {
    v17 = *v11++;
    *v4++ = v17;
  }
  return result;
}

void _CFPrefsRegisterUserDefaultsInstanceWithCloudConfigurationURL(uint64_t a1, uint64_t a2)
{
  void *v4;
  id v5;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v4 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v5 = v4;
  objc_msgSend(v4, "registerUserDefaultsInstance:configurationURL:", a1, a2);

}

void sub_182AFE710(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFStringRef _CFStreamCreateWithFile(__objc2_class **a1, CFURLRef anURL, int a3)
{
  CFStringRef result;
  CFStringRef v7;
  CFURLRef v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (anURL)
  {
    result = CFURLCopyScheme(anURL);
    if (!result)
      return result;
    v7 = result;
    if (CFEqual(result, CFSTR("file")))
    {
      v9 = 0u;
      v10 = 0u;
      CFRelease(v7);
      v8 = anURL;
      LODWORD(v9) = -1;
      return (CFStringRef)_CFStreamCreateWithConstantCallbacks(a1, (uint64_t)&v8, fileCallBacks, a3);
    }
    CFRelease(v7);
  }
  return 0;
}

BOOL __NSCacheKeyEqual(const void *a1, const void *a2)
{
  return CFEqual(a1, a2) != 0;
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  const UInt8 *BytePtr;
  CFIndex v7;
  char v8;

  BytePtr = CFDataGetBytePtr(theData);
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
    v7 = -[__CFData length](theData, "length");
  else
    v7 = *((_QWORD *)theData + 2);
  if (capacity)
    v8 = 1;
  else
    v8 = 3;
  return (CFMutableDataRef)__CFDataInit((__objc2_class **)allocator, v8, capacity, BytePtr, v7, 0);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  uint64_t v3;
  int8x16_t *BytePtr;
  CFIndex Length;

  v3 = *(_QWORD *)&encoding;
  BytePtr = (int8x16_t *)CFDataGetBytePtr(data);
  Length = CFDataGetLength(data);
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, BytePtr, Length, v3, 3u, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryInDirectoryWithVersion(CFAllocatorRef allocator, CFURLRef baseURL, CFTypeRef *a3, const __CFSet *a4, uint64_t a5, int a6)
{
  const __CFURL *v10;
  const __CFString *v11;
  const __CFString *v12;
  void *Mutable;
  const __CFString *v14;
  const __CFString *v15;
  const __CFURL *v16;
  const __CFString *v17;
  CFIndex Length;
  CFIndex v19;
  const __CFURL *v20;
  const __CFURL *v21;
  const __CFData *MappedOrLoadedPlistData;
  const __CFSet *v23;
  const __CFSet *v24;
  CFIndex Count;
  __CFError *v26;
  const __CFSet *TopLevelKeyPaths;
  CFIndex v28;
  const __CFData *v29;
  CFIndex v30;
  const __CFData *v31;
  CFTypeRef v32;
  CFIndex v33;
  const __CFURL *v34;
  const __CFData *v35;
  uint64_t *v36;
  const __CFURL *v37;
  CFTypeID TypeID;
  CFErrorDomain Domain;
  CFIndex Code;
  NSObject *v41;
  const void *v42;
  const void *v43;
  CFTypeRef v45;
  _QWORD v46[11];
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  CFTypeRef cf;
  CFDataRef resourceData[7];
  CFErrorRef error[5];
  CFErrorRef v58;
  const __CFURL *v59;
  const __CFURL *v60;
  _BYTE buf[24];
  void *v62;
  __CFError *v63;
  CFTypeRef v64;
  void *v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  if (!baseURL)
    return 0;
  switch(a6)
  {
    case 0:
      v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("Resources/"), baseURL);
      v11 = CFSTR("Resources/Info.plist");
      v12 = CFSTR("Resources/Info-iphoneos.plist");
      if (v10)
        goto LABEL_20;
      return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    case 1:
      v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("Support%20Files/"), baseURL);
      v11 = CFSTR("Support%20Files/Info.plist");
      v12 = CFSTR("Support%20Files/Info-iphoneos.plist");
      if (!v10)
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      goto LABEL_20;
    case 2:
      v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("Contents/"), baseURL);
      v11 = CFSTR("Contents/Info.plist");
      v12 = CFSTR("Contents/Info-iphoneos.plist");
      if (!v10)
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      goto LABEL_20;
    case 3:
      v14 = CFURLCopyFileSystemPath(baseURL, kCFURLPOSIXPathStyle);
      if (!v14)
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v15 = v14;
      if (CFStringHasSuffix(v14, CFSTR("Support Files"))
        || CFStringHasSuffix(v15, CFSTR("Contents"))
        || CFStringHasSuffix(v15, CFSTR("Resources")))
      {
        v10 = 0;
        v11 = CFSTR("Resources/Info.plist");
        v12 = CFSTR("Resources/Info-iphoneos.plist");
      }
      else
      {
        v10 = (const __CFURL *)CFRetain(baseURL);
        v11 = CFSTR("Info.plist");
        v12 = CFSTR("Info-iphoneos.plist");
      }
      CFRelease(v15);
      if (!v10)
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      goto LABEL_20;
    case 12:
      v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("WrappedBundle/Contents/"), baseURL);
      v11 = CFSTR("WrappedBundle/Contents/Info.plist");
      v12 = CFSTR("WrappedBundle/Contents/Info-iphoneos.plist");
      if (!v10)
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      goto LABEL_20;
    case 13:
      v10 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("WrappedBundle/"), baseURL);
      v11 = CFSTR("WrappedBundle/Info.plist");
      v12 = CFSTR("WrappedBundle/Info-iphoneos.plist");
      if (!v10)
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
LABEL_20:
      v16 = CFURLCopyAbsoluteURL(v10);
      v17 = CFURLCopyFileSystemPath(v16, kCFURLPOSIXPathStyle);
      CFRelease(v16);
      v51 = 0;
      v52 = &v51;
      v53 = 0x2000000000;
      v54 = 0;
      v47 = 0;
      v48 = &v47;
      v49 = 0x2000000000;
      v50 = 0;
      if (v17)
      {
        Length = CFStringGetLength(CFSTR("Info.plist"));
        v19 = CFStringGetLength(CFSTR("Info-iphoneos.plist"));
        v46[0] = MEMORY[0x1E0C809B0];
        v46[1] = 0x40000000;
        v46[2] = ___CFBundleCopyInfoDictionaryInDirectoryWithVersion_block_invoke;
        v46[3] = &unk_1E1337730;
        v46[6] = v19;
        v46[7] = v12;
        v46[4] = &v47;
        v46[5] = &v51;
        v46[8] = baseURL;
        v46[9] = Length;
        v46[10] = v11;
        _CFIterateDirectory(v17, 0, 0, (uint64_t)v46);
        CFRelease(v17);
      }
      CFRelease(v10);
      v45 = 0;
      if (!a4)
        goto LABEL_47;
      v20 = (const __CFURL *)v52[3];
      v21 = (const __CFURL *)v48[3];
      v59 = v21;
      v60 = v20;
      if (v21)
      {
        LOBYTE(resourceData[0]) = 0;
        *(_QWORD *)buf = 0;
        MappedOrLoadedPlistData = _CFBundleCreateMappedOrLoadedPlistData(v21, 1, 0, (BOOL *)resourceData, (CFErrorRef *)buf);
        if (MappedOrLoadedPlistData)
        {
          v45 = v21;
        }
        else if (*(_QWORD *)buf)
        {
          _CFBundleLogLoadingInfoPlistError((uint64_t)&v59, *(CFErrorRef *)buf);
          CFRelease(*(CFTypeRef *)buf);
        }
      }
      else
      {
        MappedOrLoadedPlistData = 0;
      }
      if (v20 && !MappedOrLoadedPlistData)
      {
        LOBYTE(resourceData[0]) = 0;
        *(_QWORD *)buf = 0;
        MappedOrLoadedPlistData = _CFBundleCreateMappedOrLoadedPlistData(v20, 1, 0, (BOOL *)resourceData, (CFErrorRef *)buf);
        if (MappedOrLoadedPlistData)
        {
          v45 = v20;
        }
        else if (*(_QWORD *)buf)
        {
          _CFBundleLogLoadingInfoPlistError((uint64_t)&v60, *(CFErrorRef *)buf);
          CFRelease(*(CFTypeRef *)buf);
        }
      }
      if (!MappedOrLoadedPlistData)
      {
LABEL_47:
        resourceData[0] = 0;
        v34 = (const __CFURL *)v48[3];
        if (v34
          && (CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, resourceData, 0, 0, 0), (v35 = resourceData[0]) != 0))
        {
          v36 = v48;
        }
        else
        {
          v37 = (const __CFURL *)v52[3];
          if (!v37
            || (CFURLCreateDataAndPropertiesFromResource((CFAllocatorRef)&__kCFAllocatorSystemDefault, v37, resourceData, 0, 0, 0), (v35 = resourceData[0]) == 0))
          {
            Mutable = 0;
            goto LABEL_64;
          }
          v36 = v52;
        }
        v45 = (CFTypeRef)v36[3];
        error[0] = 0;
        Mutable = (void *)CFPropertyListCreateWithData(allocator, v35, 1uLL, 0, error);
        if (Mutable)
        {
          TypeID = CFDictionaryGetTypeID();
          if (TypeID == CFGetTypeID(Mutable))
          {
            _CFBundleInfoPlistProcessInfoDictionary(Mutable);
LABEL_63:
            CFRelease(resourceData[0]);
            goto LABEL_64;
          }
          CFRelease(Mutable);
        }
        else if (error[0])
        {
          Domain = CFErrorGetDomain(error[0]);
          Code = CFErrorGetCode(error[0]);
          v41 = _CFBundleResourceLogger();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134349570;
            *(_QWORD *)&buf[4] = v45;
            *(_WORD *)&buf[12] = 2114;
            *(_QWORD *)&buf[14] = Domain;
            *(_WORD *)&buf[22] = 2050;
            v62 = (void *)Code;
            _os_log_error_impl(&dword_182A8C000, v41, OS_LOG_TYPE_ERROR, "There was an error parsing the Info.plist for the bundle at URL <%{public}p>: %{public}@ - %{public}ld", buf, 0x20u);
          }
          CFRelease(error[0]);
        }
        Mutable = CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        goto LABEL_63;
      }
      v58 = 0;
      v23 = _CFPropertyListCopyTopLevelKeys(&__kCFAllocatorSystemDefault, MappedOrLoadedPlistData, 0, &v58);
      v24 = v23;
      if (v23)
      {
        Count = CFSetGetCount(v23);
        v26 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, 0, 0);
        error[0] = (CFErrorRef)MEMORY[0x1E0C809B0];
        error[1] = (CFErrorRef)0x40000000;
        error[2] = (CFErrorRef)___CFBundleCopyLimitedInfoPlistKeys_block_invoke;
        error[3] = (CFErrorRef)&__block_descriptor_tmp_108;
        error[4] = v26;
        CFSetApply(v24, (uint64_t)error);
        _CFBundleInfoPlistProcessInfoDictionary(v26);
        TopLevelKeyPaths = __CFPropertyListCreateTopLevelKeyPaths((const __CFAllocator *)&__kCFAllocatorSystemDefault, a4);
        v28 = CFSetGetCount(a4);
        v29 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, v28, &kCFTypeSetCallBacks);
        v30 = CFSetGetCount(a4);
        v31 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, v30, &kCFTypeSetCallBacks);
        resourceData[0] = (CFDataRef)MEMORY[0x1E0C809B0];
        resourceData[1] = (CFDataRef)0x40000000;
        resourceData[2] = (CFDataRef)___CFBundleCopyLimitedInfoPlistKeys_block_invoke_2;
        resourceData[3] = (CFDataRef)&__block_descriptor_tmp_109;
        resourceData[4] = v26;
        resourceData[5] = v29;
        resourceData[6] = v31;
        CFSetApply(TopLevelKeyPaths, (uint64_t)resourceData);
        CFRelease(TopLevelKeyPaths);
        cf = 0;
        if (_CFPropertyListCreateFiltered((const __CFAllocator *)&__kCFAllocatorSystemDefault, MappedOrLoadedPlistData, 0, v29, &cf, &v58))
        {
          v32 = cf;
          v33 = CFSetGetCount(v31);
          Mutable = CFDictionaryCreateMutable(allocator, v33, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          *(_QWORD *)buf = MEMORY[0x1E0C809B0];
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___CFCopyLogicalKeysMappedToProcessedValues_block_invoke;
          v62 = &__block_descriptor_tmp_110;
          v63 = v26;
          v64 = v32;
          v65 = Mutable;
          CFSetApply(v31, (uint64_t)buf);
          CFRelease(cf);
        }
        else
        {
          Mutable = 0;
        }
        CFRelease(v29);
        CFRelease(v24);
        CFRelease(v26);
        CFRelease(v31);
      }
      else
      {
        Mutable = 0;
      }
      if (!Mutable && v58)
      {
        _CFBundleLogLoadingInfoPlistError((uint64_t)&v45, v58);
        CFRelease(v58);
      }
      CFRelease(MappedOrLoadedPlistData);
LABEL_64:
      if (a3 && v45)
      {
        CFRetain(v45);
        *a3 = v45;
      }
      v42 = (const void *)v48[3];
      if (v42)
        CFRelease(v42);
      v43 = (const void *)v52[3];
      if (v43)
        CFRelease(v43);
      _Block_object_dispose(&v47, 8);
      _Block_object_dispose(&v51, 8);
      if (!Mutable)
        return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      return (CFMutableDictionaryRef)Mutable;
    default:
      return CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
}

void sub_182AFF2A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v14;
  va_list va;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a13);
  va_start(va, a13);
  v14 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return 18;
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  const __CFAllocator *v4;
  const __CFString *v5;
  unint64_t Length;
  int64_t MaximumSizeForEncoding;
  uint64_t v8;
  char *v9;
  const __CFString *v10;
  size_t v11;
  const __CFString *v12;
  _BYTE v14[1024];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = CFGetAllocator(anURL);
  if (pathStyle)
    return CFURLCreateStringWithFileSystemPath(v4, (__objc2_class **)anURL, pathStyle, 0);
  if (!CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
  {
    if (!*((_QWORD *)anURL + 4))
      goto LABEL_6;
    return CFURLCreateStringWithFileSystemPath(v4, (__objc2_class **)anURL, pathStyle, 0);
  }
  if (-[__CFURL baseURL](anURL, "baseURL"))
    return CFURLCreateStringWithFileSystemPath(v4, (__objc2_class **)anURL, pathStyle, 0);
LABEL_6:
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL) || (*((_BYTE *)anURL + 17) & 0x10) == 0)
    return CFURLCreateStringWithFileSystemPath(v4, (__objc2_class **)anURL, pathStyle, 0);
  v5 = CFURLGetString(anURL);
  Length = CFStringGetLength(v5);
  if (Length <= 1)
    Length = 1;
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  v8 = MaximumSizeForEncoding;
  v9 = MaximumSizeForEncoding >= 1025 ? (char *)malloc_type_malloc(MaximumSizeForEncoding, 0xA2D6A293uLL) : v14;
  v10 = (const __CFString *)atomic_load((unint64_t *)anURL + 3);
  if (CanonicalFileURLStringToFileSystemRepresentation(v10, v9, v8))
  {
    v11 = strlen(v9);
    v12 = CFStringCreateWithBytes(v4, (const UInt8 *)v9, v11, 0x8000100u, 0);
  }
  else
  {
    v12 = 0;
  }
  if (v9 != v14)
    free(v9);
  if (!v12)
    return CFURLCreateStringWithFileSystemPath(v4, (__objc2_class **)anURL, pathStyle, 0);
  return v12;
}

uint64_t CanonicalFileURLStringToFileSystemRepresentation(const __CFString *a1, _BYTE *a2, uint64_t a3)
{
  uint64_t v3;
  _BYTE *v5;
  CFIndex Length;
  CFIndex v8;
  UInt8 *v9;
  CFIndex v10;
  BOOL v11;
  CFIndex v12;
  uint64_t v13;
  UInt8 *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  _BYTE *v18;
  _BYTE *v19;
  CFIndex usedBufLen;
  UInt8 buffer[3072];
  uint64_t v23;
  CFRange v24;

  v3 = 0;
  v23 = *MEMORY[0x1E0C80C00];
  if (a2 && a3)
  {
    v5 = a2;
    Length = CFStringGetLength(a1);
    v8 = Length - 7;
    if (Length == 7)
    {
      *v5 = 0;
      return 1;
    }
    else
    {
      usedBufLen = 0;
      if (v8 >= 1025)
      {
        v9 = (UInt8 *)malloc_type_malloc(3 * v8, 0xF61F24DDuLL);
        if (!v9)
          return 0;
      }
      else
      {
        v9 = buffer;
      }
      v24.location = 7;
      v24.length = v8;
      if (CFStringGetBytes(a1, v24, 0x8000100u, 0, 0, v9, 3 * v8, &usedBufLen))
      {
        v10 = usedBufLen;
        if (usedBufLen >= 1)
        {
          v11 = 0;
          v12 = 0;
          v13 = 0;
          v14 = v9;
          while (1)
          {
            if (a3 == v13)
            {
              v3 = 0;
              goto LABEL_28;
            }
            LODWORD(v15) = *v14;
            if ((_DWORD)v15 != 37)
              break;
            v12 += 2;
            if (v12 < v10)
            {
              v16 = CanonicalFileURLStringToFileSystemRepresentation_hexvalues[v14[1]];
              v5[v13] = 16 * v16;
              v15 = v14[2];
              v14 += 3;
              LOBYTE(v15) = CanonicalFileURLStringToFileSystemRepresentation_hexvalues[v15] + 16 * v16;
LABEL_16:
              v5[v13] = v15;
              v11 = v15 == 47;
            }
            ++v13;
            if (++v12 >= v10)
            {
              LODWORD(v17) = v13 != 1;
              v18 = &v5[v13];
              goto LABEL_21;
            }
          }
          ++v14;
          goto LABEL_16;
        }
        LODWORD(v17) = 0;
        v11 = 0;
        v18 = v5;
LABEL_21:
        v19 = &v5[a3];
        if (v11)
          v17 = v17;
        else
          v17 = 0;
        v5 = &v18[-v17];
        v3 = 1;
        if (&v18[-v17] < v19)
LABEL_28:
          *v5 = 0;
      }
      else
      {
        v3 = 0;
      }
      if (v9 != buffer)
        free(v9);
    }
  }
  return v3;
}

const __CFURL *__CFURLHash(const __CFURL *result)
{
  CFStringRef v1;

  if (result)
  {
    v1 = CFURLGetString(result);
    return (const __CFURL *)CFHash(v1);
  }
  return result;
}

uint64_t __CFURLEqual(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const void *v5;
  const void *v6;
  CFStringRef v7;
  CFStringRef v8;

  if (a1 == a2)
    return 1;
  if (((*(_DWORD *)(a2 + 16) ^ *(_DWORD *)(a1 + 16)) & 0xE0006DFF) != 0)
    return 0;
  v5 = *(const void **)(a1 + 32);
  v6 = *(const void **)(a2 + 32);
  if (!v5)
  {
    if (v6)
      return 0;
LABEL_10:
    v7 = CFURLGetString((CFURLRef)a1);
    v8 = CFURLGetString((CFURLRef)a2);
    return CFEqual(v7, v8);
  }
  if (!v6)
    return 0;
  result = CFEqual(v5, v6);
  if ((_DWORD)result)
    goto LABEL_10;
  return result;
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  uint64_t v3;

  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
    return (CFStringRef)-[__CFURL relativeString](anURL, "relativeString");
  if ((*((_BYTE *)anURL + 18) & 1) != 0)
    return (CFStringRef)atomic_load((unint64_t *)anURL + 3);
  v3 = *((_QWORD *)anURL + 5);
  if (v3)
    return *(CFStringRef *)(v3 + 8);
  else
    return 0;
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  v6[0] = 0;
  _CFPropertyListCreateWithData((__objc2_class **)allocator, data, options, error, 1, format, 0, v6);
  return (CFPropertyListRef)v6[0];
}

CFSetRef _CFPropertyListCopyTopLevelKeys(__objc2_class **a1, CFDataRef theData, unsigned int a3, CFErrorRef *a4)
{
  char *BytePtr;
  unint64_t Length;
  int v10;
  CFSetRef v11;
  const __CFDictionary *v12;
  CFIndex Count;
  const void **v14;
  const void **v15;
  CFErrorRef Error;
  unint64_t v18;
  char v19;
  CFTypeRef cf[2];
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (theData)
  {
    BytePtr = (char *)CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    if (Length >= 8)
    {
      v10 = Length;
      v19 = 0;
      *(_OWORD *)cf = 0u;
      v21 = 0u;
      v18 = 0;
      if (__CFDataGetBinaryPlistTopLevelInfo(theData, &v19, &v18, (uint64_t)cf))
      {
        v11 = __CFBinaryPlistCopyTopLevelKeys(a1, BytePtr, v10, v18, (uint64_t)cf);
        if (!a4)
          return v11;
        goto LABEL_19;
      }
    }
    cf[0] = 0;
    _CFPropertyListCreateWithData(a1, theData, a3, a4, 1, 0, 0, cf);
    v12 = (const __CFDictionary *)cf[0];
    if (cf[0])
    {
      if (CFGetTypeID(cf[0]) == 18)
      {
        Count = CFDictionaryGetCount(v12);
        v14 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
        if (v14)
        {
          v15 = v14;
          CFDictionaryGetKeysAndValues(v12, v14, 0);
          v11 = CFSetCreate((CFAllocatorRef)a1, v15, Count, &kCFTypeSetCallBacks);
          free(v15);
          goto LABEL_18;
        }
        if (a4)
        {
          Error = __CFPropertyListCreateError(3840, CFSTR("Unable to convert string to correct encoding"));
          goto LABEL_16;
        }
      }
      else if (a4)
      {
        Error = __CFPropertyListCreateError(3840, CFSTR("Cannot copy top-level keys for plist with non-dictionary root object"));
LABEL_16:
        v11 = 0;
        *a4 = Error;
        goto LABEL_18;
      }
      v11 = 0;
LABEL_18:
      CFRelease(v12);
      if (!a4)
        return v11;
      goto LABEL_19;
    }
  }
  v11 = 0;
  if (!a4)
    return v11;
LABEL_19:
  if (!v11)
    *a4 = __CFPropertyListCreateError(3840, CFSTR("Unable to extract top-level keys"));
  return v11;
}

uint64_t _CFPropertyListCreateFiltered(const __CFAllocator *a1, CFDataRef theData, uint64_t a3, const __CFSet *a4, CFTypeRef *a5, CFErrorRef *a6)
{
  uint64_t v6;
  const UInt8 *BytePtr;
  unint64_t Length;
  int v15;
  unint64_t v16;
  const __CFSet *TopLevelKeyPaths;
  const __CFDictionary *Mutable;
  CFTypeRef cf;
  unint64_t v21;
  char v22;
  _OWORD v23[2];
  uint64_t v24;

  v6 = 0;
  v24 = *MEMORY[0x1E0C80C00];
  if (theData && a4)
  {
    v22 = 0;
    memset(v23, 0, sizeof(v23));
    v21 = 0;
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    cf = 0;
    if (Length >= 8
      && (v15 = Length, __CFDataGetBinaryPlistTopLevelInfo(theData, &v22, &v21, (uint64_t)v23)))
    {
      v16 = v21;
      TopLevelKeyPaths = __CFPropertyListCreateTopLevelKeyPaths(a1, a4);
      Mutable = CFDictionaryCreateMutable(a1, 0, 0, &kCFTypeDictionaryValueCallBacks);
      v6 = __CFBinaryPlistCreateObjectFiltered(BytePtr, v15, v16, (uint64_t)v23, (__objc2_class **)a1, a3, (unint64_t)theData & (a3 << 47 >> 63), Mutable, 0, 0, (CFIndex)TopLevelKeyPaths, &cf, 0);
      CFRelease(TopLevelKeyPaths);
      CFRelease(Mutable);
    }
    else
    {
      v6 = _CFPropertyListCreateWithData((__objc2_class **)a1, theData, a3, a6, 1, 0, a4, &cf) != 0;
    }
    if (a5 && (_DWORD)v6)
    {
      *a5 = cf;
    }
    else if (cf)
    {
      CFRelease(cf);
    }
  }
  return v6;
}

uint64_t __CFTryParseBinaryPlist(__objc2_class **a1, CFDataRef theData, uint64_t a3, _QWORD *a4, CFTypeRef *a5)
{
  const UInt8 *BytePtr;
  unint64_t Length;
  int v12;
  __objc2_class **Mutable;
  uint64_t v14;
  CFTypeRef v16;
  int v17[2];
  char v18;
  _OWORD v19[2];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (Length < 8)
    return 0;
  v12 = Length;
  v18 = 0;
  memset(v19, 0, sizeof(v19));
  *(_QWORD *)v17 = 0;
  if (!__CFDataGetBinaryPlistTopLevelInfo(theData, &v18, (unint64_t *)v17, (uint64_t)v19))
    return 0;
  Mutable = (__objc2_class **)CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
  _CFDictionarySetCapacity(Mutable, *((uint64_t *)&v19[0] + 1));
  v16 = 0;
  v14 = __CFBinaryPlistCreateObjectFiltered(BytePtr, v12, *(unint64_t *)v17, (uint64_t)v19, a1, a3, 0, (const __CFDictionary *)Mutable, 0, 0, 0, &v16, 0);
  if ((_DWORD)v14)
  {
    if (a4)
      *a4 = v16;
  }
  else
  {
    if (a4)
      *a4 = 0;
    if (a5)
      *a5 = CFRetain(CFSTR("binary data is corrupt"));
  }
  CFRelease(Mutable);
  return v14;
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  char v3;

  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
    return (const UInt8 *)-[__CFData bytes](theData, "bytes");
  v3 = atomic_load((unint64_t *)theData + 1);
  if ((v3 & 4) != 0)
    return (const UInt8 *)(((unint64_t)theData + 63) & 0xFFFFFFFFFFFFFFF0);
  else
    return (const UInt8 *)*((_QWORD *)theData + 5);
}

void CFBasicHashSetCapacity(uint64_t a1, uint64_t a2)
{
  char v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;

  v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x40) != 0)
  {
    __break(1u);
  }
  else
  {
    v3 = *(unsigned int *)(a1 + 20);
    v4 = a2 <= v3;
    v5 = a2 - v3;
    if (!v4)
    {
      ++*(_WORD *)(a1 + 16);
      __CFBasicHashRehash(a1, v5);
    }
  }
}

uint64_t __CFDataGetBinaryPlistTopLevelInfo(_QWORD *a1, _BYTE *a2, unint64_t *a3, uint64_t a4)
{
  UInt8 *BytePtr;
  unint64_t v10;

  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)a1))
    return objc_msgSend(a1, "_getBPlistMarker:offset:trailer:", a2, a3, a4);
  BytePtr = (UInt8 *)CFDataGetBytePtr((CFDataRef)a1);
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)a1))
    v10 = objc_msgSend(a1, "length");
  else
    v10 = a1[2];
  return __CFBinaryPlistGetTopLevelInfo(BytePtr, v10, a2, a3, a4);
}

uint64_t __CFBinaryPlistGetTopLevelInfo(_DWORD *a1, unint64_t a2, _BYTE *a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v5;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;
  unint64_t v14;
  BOOL v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  unsigned int *v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int *v22;
  unint64_t v23;
  unsigned int v24;
  int v26;

  v5 = 0;
  if (a1 && a2 >= 0x29)
  {
    if (*a1 != 1768714338 || *(_DWORD *)((char *)a1 + 3) != 812938089)
      return 0;
    v5 = 0;
    v8 = (char *)a1 + a2;
    v9 = bswap64(*(_QWORD *)((char *)a1 + a2 - 24));
    if ((uint64_t)v9 >= 1)
    {
      v10 = bswap64(*((_QWORD *)v8 - 1));
      if ((v10 & 0x8000000000000000) == 0)
      {
        v11 = bswap64(*((_QWORD *)v8 - 2));
        if (v9 > v11 && v10 >= 9 && a2 - 32 > v10)
        {
          v12 = *(v8 - 26);
          if (!*(v8 - 26))
            return 0;
          v13 = *(v8 - 25);
          if (!*(v8 - 25))
            return 0;
          if (!is_mul_ok(v9, v12))
            return 0;
          v14 = v9 * v12;
          if (!(v9 * v12) || v10 + v14 > 0xFFFFFFFFFFFFFFDFLL)
            return 0;
          v5 = 0;
          if (v10 > ~v14 || v10 + v14 + 32 != a2)
            return v5;
          if (v13 <= 7 && v9 >> (8 * v13)
            || v12 <= 7 && v10 >> (8 * v12))
          {
            return 0;
          }
          v5 = 0;
          v15 = __CFADD__(v10, a1);
          if ((unint64_t)a1 <= 0xFFFFFFFFFFFFFFF7 && !v15)
          {
            if ((unint64_t)a1 + v10 <= -(uint64_t)v14)
            {
              v16 = 0;
              v17 = v8 - 32;
              if (v12 <= 1)
                v18 = 1;
              else
                v18 = *(v8 - 26);
              v19 = (_DWORD *)((char *)a1 + v10);
              while (1)
              {
                switch((int)v12)
                {
                  case 1:
                    v20 = *(unsigned __int8 *)v19;
                    break;
                  case 2:
                    v20 = __rev16(*(unsigned __int16 *)v19);
                    break;
                  case 4:
                    v20 = bswap32(*v19);
                    break;
                  case 8:
                    v20 = bswap64(*(_QWORD *)v19);
                    break;
                  default:
                    v21 = 0;
                    v20 = 0;
                    do
                      v20 = *((unsigned __int8 *)v19 + v21++) | (v20 << 8);
                    while (v18 != v21);
                    break;
                }
                if (v10 - 1 < v20)
                  break;
                v19 = (unsigned int *)((char *)v19 + v12);
                if (++v16 == v9)
                {
                  v22 = (_DWORD *)((char *)a1 + v10 + v11 * v12);
                  switch((int)v12)
                  {
                    case 1:
                      v23 = *(unsigned __int8 *)v22;
                      break;
                    case 2:
                      v23 = __rev16(*(unsigned __int16 *)v22);
                      break;
                    case 4:
                      v23 = bswap32(*v22);
                      break;
                    case 8:
                      v23 = bswap64(*(_QWORD *)v22);
                      break;
                    default:
                      v23 = 0;
                      do
                      {
                        v24 = *(unsigned __int8 *)v22;
                        v22 = (unsigned int *)((char *)v22 + 1);
                        v23 = v24 | (v23 << 8);
                        --v18;
                      }
                      while (v18);
                      break;
                  }
                  if (v23 >= 8 && v10 > v23)
                  {
                    if (a5)
                    {
                      v26 = *(_DWORD *)v17;
                      *(_WORD *)(a5 + 4) = *((_WORD *)v17 + 2);
                      *(_DWORD *)a5 = v26;
                      *(_BYTE *)(a5 + 6) = v12;
                      *(_BYTE *)(a5 + 7) = v13;
                      *(_QWORD *)(a5 + 8) = v9;
                      *(_QWORD *)(a5 + 16) = v11;
                      *(_QWORD *)(a5 + 24) = v10;
                    }
                    if (a4)
                      *a4 = v23;
                    if (a3)
                      *a3 = *((_BYTE *)a1 + v23);
                    return 1;
                  }
                  return 0;
                }
              }
            }
            return 0;
          }
        }
      }
    }
  }
  return v5;
}

uint64_t _CFPropertyListCreateWithData(__objc2_class **a1, CFDataRef theData, unsigned int a3, CFErrorRef *a4, char a5, _QWORD *a6, const __CFSet *a7, _QWORD *a8)
{
  char v10;
  int v11;
  int v12;
  uint64_t v18;
  CFErrorRef Error;
  const UInt8 *BytePtr;
  unsigned int Length;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  CFStringEncoding v29;
  const UInt8 *v30;
  CFIndex v31;
  const __CFString *v32;
  const __CFString *v33;
  const __CFData *UTF8DataFromString;
  unsigned __int8 *i;
  const UInt8 *v36;
  int v37;
  int v38;
  int v39;
  int v40;
  const UInt8 *v41;
  uint64_t v42;
  int v43;
  CFErrorRef v44;
  const __CFString *v45;
  CFStringEncoding v46;
  CFStringEncoding v47;
  _QWORD *v49;
  char v50;

  v10 = BYTE1(a3) | (a3 >> 9) | (a3 >> 10);
  if (BYTE1(a3) & 1 | ((a3 & 0x200) != 0) | ((a3 & 0x400) != 0))
    v11 = (a3 >> 8) & 1;
  else
    v11 = 1;
  if (BYTE1(a3) & 1 | ((a3 & 0x200) != 0) | ((a3 & 0x400) != 0))
    v12 = (a3 >> 10) & 1;
  else
    v12 = 1;
  if (!theData || !CFDataGetLength(theData))
  {
    if (!a4)
      return 0;
    Error = __CFPropertyListCreateError(3840, CFSTR("Cannot parse a NULL or zero-length data"));
LABEL_17:
    v18 = 0;
    *a4 = Error;
    return v18;
  }
  if (((a3 & 0x200) != 0 || (v10 & 1) == 0)
    && __CFTryParseBinaryPlist(a1, theData, a3, a8, 0))
  {
    if (a6)
      *a6 = 200;
    return 1;
  }
  if (!(v12 | v11))
  {
    if (!a4)
      return 0;
    Error = __CFPropertyListCreateError(3840, CFSTR("Unsupported property list"));
    goto LABEL_17;
  }
  v50 = a5;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v22 = Length;
  if (Length < 5)
  {
    if (Length != 4)
    {
      if (Length < 3)
      {
LABEL_51:
        v26 = 0;
        goto LABEL_52;
      }
      v23 = *BytePtr;
LABEL_36:
      switch(v23)
      {
        case 0:
          goto LABEL_54;
        case 254:
          v25 = BytePtr[1];
          if (v25 == 255)
          {
            v49 = a6;
            v24 = 268435712;
            goto LABEL_55;
          }
          break;
        case 255:
          v25 = BytePtr[1];
          if (v25 == 254)
          {
            v49 = a6;
LABEL_44:
            v24 = 335544576;
LABEL_55:
            v28 = 2;
            goto LABEL_56;
          }
          break;
        default:
          v25 = BytePtr[1];
          break;
      }
      goto LABEL_48;
    }
    v23 = *BytePtr;
  }
  else
  {
    v23 = *BytePtr;
    if (v23 == 255)
    {
      v25 = BytePtr[1];
      if (v25 == 254)
      {
        v49 = a6;
        if (!BytePtr[2] && !BytePtr[3])
        {
          v24 = 469762304;
          goto LABEL_90;
        }
        goto LABEL_44;
      }
LABEL_48:
      if (v25)
        goto LABEL_49;
LABEL_54:
      v49 = a6;
      v24 = 256;
      goto LABEL_55;
    }
    if (!*BytePtr)
    {
      if (!BytePtr[1] && BytePtr[2] == 254 && BytePtr[3] == 255)
      {
        v49 = a6;
        v24 = 402653440;
LABEL_90:
        v28 = 4;
LABEL_56:
        v29 = v24;
        v30 = &CFDataGetBytePtr(theData)[v28];
        v31 = CFDataGetLength(theData);
        v32 = CFStringCreateWithBytes((CFAllocatorRef)a1, v30, v31 - v28, v29, 0);
        if (v32)
        {
          v33 = v32;
          UTF8DataFromString = _createUTF8DataFromString((const __CFAllocator *)a1, v32);
          v18 = _CFPropertyListCreateFromUTF8Data((const __CFAllocator *)a1, UTF8DataFromString, 0, v33, 0, a3, a4, v50, v49, a7, a8, v12, v11);
          CFRelease(v33);
          if (UTF8DataFromString)
            CFRelease(UTF8DataFromString);
          return v18;
        }
        if (a4)
        {
          Error = __CFPropertyListCreateError(3840, CFSTR("Could not determine the encoding of the XML data (string creation failed)"));
          goto LABEL_17;
        }
        return 0;
      }
      goto LABEL_54;
    }
  }
  if (v23 != 239)
    goto LABEL_36;
  v25 = BytePtr[1];
  if (v25 != 187)
    goto LABEL_48;
  if (BytePtr[2] == 191)
  {
    v26 = 3;
LABEL_52:
    v27 = v50;
    return _CFPropertyListCreateFromUTF8Data((const __CFAllocator *)a1, theData, v26, 0, 0x8000100u, a3, a4, v27, a6, a7, a8, v12, v11);
  }
LABEL_49:
  if (Length < 5 || strncmp((const char *)BytePtr, "<?xml", 5uLL))
    goto LABEL_51;
  i = (unsigned __int8 *)(BytePtr + 5);
  v36 = &BytePtr[v22];
  if (v22 < 6uLL)
  {
LABEL_76:
    v27 = v50;
    if (i < v36)
    {
      v39 = *i;
      if (v39 == 39 || v39 == 34)
      {
        v40 = (char)v39;
        v41 = i + 1;
        v42 = 1;
        while (&i[v42] < v36)
        {
          v43 = i[v42++];
          if (v43 == v40)
          {
            if ((_DWORD)v42 == 7
              && (*v41 | 0x20) == 0x75
              && (i[2] | 0x20) == 0x74
              && (i[3] | 0x20) == 0x66
              && i[4] == 45
              && i[5] == 56)
            {
              goto LABEL_88;
            }
            v45 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v41, (v42 - 2), 0x201u, 0);
            v46 = CFStringConvertIANACharSetNameToEncoding(v45);
            if (v46 == -1)
            {
              v44 = __CFPropertyListCreateError(3840, CFSTR("Encountered unknown encoding (%@)"), v45);
              if (v45)
                CFRelease(v45);
              goto LABEL_92;
            }
            v24 = v46;
            v49 = a6;
            if (v45)
            {
              v47 = v46;
              CFRelease(v45);
              v24 = v47;
            }
            if (v24 == 134217984)
            {
              v26 = 0;
              v27 = v50;
              a6 = v49;
              return _CFPropertyListCreateFromUTF8Data((const __CFAllocator *)a1, theData, v26, 0, 0x8000100u, a3, a4, v27, a6, a7, a8, v12, v11);
            }
            v44 = 0;
            v28 = 0;
            if (!v24)
              goto LABEL_92;
            goto LABEL_56;
          }
        }
      }
    }
    goto LABEL_88;
  }
  v37 = *i;
  v27 = v50;
  if ((v37 & 0xFE) == 0x3E)
  {
LABEL_88:
    v26 = 0;
    return _CFPropertyListCreateFromUTF8Data((const __CFAllocator *)a1, theData, v26, 0, 0x8000100u, a3, a4, v27, a6, a7, a8, v12, v11);
  }
  for (i = (unsigned __int8 *)(BytePtr + 14); i < v36; ++i)
  {
    v38 = *(i - 8);
    if (v37 == 101
      && v38 == 110
      && *(i - 7) == 99
      && *(i - 6) == 111
      && *(i - 5) == 100
      && *(i - 4) == 105
      && *(i - 3) == 110
      && *(i - 2) == 103
      && *(i - 1) == 61)
    {
      goto LABEL_76;
    }
    v26 = 0;
    v37 = v38;
    if ((v38 & 0xFE) == 0x3E)
      return _CFPropertyListCreateFromUTF8Data((const __CFAllocator *)a1, theData, v26, 0, 0x8000100u, a3, a4, v27, a6, a7, a8, v12, v11);
  }
  v44 = __CFPropertyListCreateError(3840, CFSTR("End of buffer while looking for encoding name"), v26);
LABEL_92:
  if (a4 && !v44)
  {
    Error = __CFPropertyListCreateError(3840, CFSTR("Could not determine the encoding of the XML data"));
    goto LABEL_17;
  }
  if (a4 && v44)
  {
    v18 = 0;
    *a4 = v44;
    return v18;
  }
  v18 = 0;
  if (!a4 && v44)
  {
    CFRelease(v44);
    return 0;
  }
  return v18;
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
    return -[__CFData length](theData, "length");
  else
    return *((_QWORD *)theData + 2);
}

const __CFSet *__CFPropertyListCreateTopLevelKeyPaths(const __CFAllocator *a1, CFSetRef theSet)
{
  const __CFSet *Mutable;
  unint64_t Count;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *Typed;
  size_t v11;
  uint64_t i;
  CFTypeID v13;
  const __CFString *v14;
  CFArrayRef ArrayBySeparatingStrings;
  _QWORD v17[2];

  Mutable = theSet;
  v17[1] = *MEMORY[0x1E0C80C00];
  if (theSet)
  {
    Count = CFSetGetCount(theSet);
    if (Count >> 60)
      __CFPropertyListCreateTopLevelKeyPaths_cold_1();
    v6 = Count;
    if (Count <= 1)
      v7 = 1;
    else
      v7 = Count;
    MEMORY[0x1E0C80A78](Count, v5);
    Typed = (char *)v17 - v9;
    if (v8 >= 0x200)
      v11 = 512;
    else
      v11 = v8;
    bzero((char *)v17 - v9, v11);
    if (v6 > 0x100)
    {
      Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v7, 0xC0040B8AA526DLL, 0);
      if (!Typed)
        __CFPropertyListCreateTopLevelKeyPaths_cold_2();
    }
    else
    {
      bzero(Typed, 8 * v7);
    }
    CFSetGetValues(Mutable, (const void **)Typed);
    Mutable = CFSetCreateMutable(a1, v6, &kCFTypeSetCallBacks);
    if (v6)
    {
      for (i = 0; i != v6; ++i)
      {
        v13 = CFGetTypeID(*(CFTypeRef *)&Typed[8 * i]);
        v14 = *(const __CFString **)&Typed[8 * i];
        if (v13 == 19)
        {
          CFSetAddValue(Mutable, v14);
        }
        else
        {
          ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a1, v14, CFSTR(":"));
          CFSetAddValue(Mutable, ArrayBySeparatingStrings);
          if (ArrayBySeparatingStrings)
            CFRelease(ArrayBySeparatingStrings);
        }
      }
      if (v6 >= 0x101)
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
  }
  return Mutable;
}

CFSetRef __CFBinaryPlistCopyTopLevelKeys(__objc2_class **a1, char *a2, int a3, unint64_t a4, uint64_t a5)
{
  CFSetRef v5;
  unint64_t v7;
  char *v9;
  char v10;
  unsigned int *v13;
  unint64_t v14;
  unsigned __int8 *v15;
  char v16;
  unsigned int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;
  unsigned int v22;
  unint64_t v23;
  void *v24;
  void *v25;
  unint64_t v26;
  void *v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int *v31;
  unsigned int v32;
  unint64_t v33;
  unsigned int *v34;
  uint64_t v35;
  unsigned int v36;
  BOOL v37;
  CFTypeRef *v38;
  CFTypeID v40;
  CFTypeRef v41[2];

  v5 = 0;
  v41[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  if (a4 < 8)
    return v5;
  v7 = *(_QWORD *)(a5 + 24) - 1;
  if (v7 < a4)
    return v5;
  v5 = 0;
  v9 = &a2[a4];
  if (&a2[a4] == (char *)-1)
    return v5;
  v10 = *v9;
  if ((*v9 & 0xF0) != 0xD0)
    return v5;
  v13 = (unsigned int *)(v9 + 1);
  v14 = v10 & 0xF;
  if ((v10 & 0xF) == 0xF)
  {
    if (&a2[v7] < (char *)v13)
      return 0;
    v15 = (unsigned __int8 *)(v9 + 2);
    v16 = *(_BYTE *)v13;
    if ((*(_BYTE *)v13 & 0xF0) != 0x10)
      return 0;
    v5 = 0;
    v17 = v16 & 0xF;
    v18 = 1 << (v16 & 0xF);
    if (__CFADD__(v18, v15) || (char *)v13 + v18 > &a2[v7])
      return v5;
    switch((char)v18)
    {
      case 1:
        v14 = *v15;
        goto LABEL_23;
      case 2:
        v14 = __rev16(*(unsigned __int16 *)((char *)v13 + 1));
        goto LABEL_23;
      case 4:
        v14 = bswap32(*(unsigned int *)((char *)v13 + 1));
        goto LABEL_23;
      case 8:
        v14 = bswap64(*(_QWORD *)((char *)v13 + 1));
        goto LABEL_22;
      default:
        if (v17 >= 8)
        {
          v14 = 0;
          v19 = 0;
          v13 = (unsigned int *)&v15[v18];
          goto LABEL_28;
        }
        v14 = 0;
        if ((v18 & 0xFE) != 0)
          v20 = v18;
        else
          v20 = 1;
        v21 = (unsigned __int8 *)v13 + 1;
        do
        {
          v22 = *v21++;
          v14 = v22 | (v14 << 8);
          --v20;
        }
        while (v20);
LABEL_22:
        if ((v14 & 0x8000000000000000) != 0)
          return 0;
LABEL_23:
        v13 = (unsigned int *)&v15[v18];
        break;
    }
  }
  if (v14)
  {
    v5 = 0;
    v19 = 2 * v14;
    if (!is_mul_ok(2 * v14, *(unsigned __int8 *)(a5 + 7)))
      return v5;
    v14 = v19 * *(unsigned __int8 *)(a5 + 7);
  }
  else
  {
    v19 = 0;
  }
LABEL_28:
  v5 = 0;
  if (!__CFADD__(v14, v13) && &a2[v7] >= (char *)v13 + v14 - 1)
  {
    if (v19 >= 0x402)
      v23 = 512;
    else
      v23 = v19 >> 1;
    v24 = malloc_type_malloc(8 * v23, 0x6004044C4A2DFuLL);
    if (v24)
    {
      v25 = v24;
      if (v19)
      {
        v26 = 0;
        if (v19 >> 1 <= 1)
          v19 = 1;
        else
          v19 >>= 1;
        while (1)
        {
          if (v26 >= v23)
          {
            v23 = (3 * v23) >> 1;
            v27 = malloc_type_realloc(v25, 8 * v23, 0x6004044C4A2DFuLL);
            if (!v27)
              break;
            v25 = v27;
          }
          if (a2 + 8 > (char *)v13)
            break;
          v28 = &a2[*(_QWORD *)(a5 + 24)];
          v29 = *(unsigned __int8 *)(a5 + 7);
          if (&v28[-v29] < (char *)v13)
            break;
          v30 = *(unsigned __int8 *)(a5 + 7);
          switch(*(_BYTE *)(a5 + 7))
          {
            case 0:
              break;
            case 1:
              v30 = *(unsigned __int8 *)v13;
              break;
            case 2:
              v30 = __rev16(*(unsigned __int16 *)v13);
              break;
            case 4:
              v30 = bswap32(*v13);
              break;
            case 8:
              v30 = bswap64(*(_QWORD *)v13);
              break;
            default:
              v30 = 0;
              v31 = v13;
              do
              {
                v32 = *(unsigned __int8 *)v31;
                v31 = (unsigned int *)((char *)v31 + 1);
                v30 = v32 | (v30 << 8);
                --v29;
              }
              while (v29);
              break;
          }
          if (*(_QWORD *)(a5 + 8) <= v30)
            break;
          v33 = *(unsigned __int8 *)(a5 + 6);
          v34 = (unsigned int *)&v28[v30 * v33];
          switch(*(_BYTE *)(a5 + 6))
          {
            case 0:
              break;
            case 1:
              v33 = *(unsigned __int8 *)v34;
              break;
            case 2:
              v33 = __rev16(*(unsigned __int16 *)v34);
              break;
            case 4:
              v33 = bswap32(*v34);
              break;
            case 8:
              v33 = bswap64(*(_QWORD *)v34);
              break;
            default:
              v35 = *(unsigned __int8 *)(a5 + 6);
              v33 = 0;
              do
              {
                v36 = *(unsigned __int8 *)v34;
                v34 = (unsigned int *)((char *)v34 + 1);
                v33 = v36 | (v33 << 8);
                --v35;
              }
              while (v35);
              break;
          }
          v40 = 0;
          v41[0] = 0;
          if (__CFBinaryPlistCreateObjectFiltered(a2, a3, v33, a5, a1, 0, 0, 0, 0, 0, 0, v41, &v40))v37 = v40 == 7;
          else
            v37 = 0;
          if (!v37)
          {
            if (v41[0])
              CFRelease(v41[0]);
            break;
          }
          *((CFTypeRef *)v25 + v26++) = v41[0];
          v13 = (unsigned int *)((char *)v13 + *(unsigned __int8 *)(a5 + 7));
          if (v26 == v19)
            goto LABEL_66;
        }
        v5 = 0;
      }
      else
      {
LABEL_66:
        v5 = CFSetCreate((CFAllocatorRef)a1, (const void **)v25, v19, &kCFTypeSetCallBacks);
        v26 = v19;
      }
      if (v26)
      {
        v38 = (CFTypeRef *)v25;
        do
        {
          if (*v38)
            CFRelease(*v38);
          ++v38;
          --v26;
        }
        while (v26);
      }
      free(v25);
      return v5;
    }
    return 0;
  }
  return v5;
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  uint64_t Generic;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  int v12;

  Generic = __CFSetCreateGeneric((__objc2_class **)allocator, (uint64_t)callBacks);
  v7 = (unint64_t *)Generic;
  if (!Generic)
    return (CFSetRef)v7;
  if (numValues >= 1)
  {
    CFBasicHashSetCapacity(Generic, numValues);
    do
    {
      v8 = (unint64_t)*values++;
      CFBasicHashAddValue((uint64_t)v7, v8, v8);
      --numValues;
    }
    while (numValues);
  }
  v9 = v7 + 1;
  v10 = atomic_load(v7 + 1);
  do
  {
    v11 = __ldaxr(v9);
    if (v11 == v10)
    {
      if (!__stlxr(v10 | 0x40, v9))
      {
        v12 = 1;
        goto LABEL_11;
      }
    }
    else
    {
      __clrex();
    }
    v12 = 0;
LABEL_11:
    v10 = v11;
  }
  while (!v12);
  _CFRuntimeSetInstanceTypeIDAndIsa((objc_class **)v7, 0x11uLL);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  return (CFSetRef)v7;
}

uint64_t _CFPropertyListCreateFromUTF8Data(const __CFAllocator *a1, CFDataRef theData, uint64_t a3, const void *a4, CFStringEncoding a5, int a6, _QWORD *a7, char a8, _QWORD *a9, const __CFSet *a10, _QWORD *a11, char a12, char a13)
{
  CFIndex Length;
  CFIndex v22;
  const UInt8 *BytePtr;
  CFErrorRef Error;
  void *v25;
  uint64_t result;
  _QWORD *v27;
  char *v28;
  unint64_t v29;
  unsigned int v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v34;
  int v35;
  _DWORD *v36;
  BOOL v37;
  CFErrorRef v38;
  unsigned __int8 *v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  unint64_t v44;
  int v45;
  unint64_t v46;
  char *v47;
  uint64_t v48;
  CFErrorRef v50;
  CFTypeRef v51;
  int v52;
  int v53;
  void **p_value;
  const void *v55;
  __CFError *v56;
  const void *v57;
  const __CFDictionary *v58;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  const __CFString *Domain;
  CFIndex Code;
  CFErrorRef v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void *value;
  const UInt8 *v70;
  char *v71;
  unint64_t v72;
  CFTypeRef v73;
  const __CFAllocator *v74;
  void *v75[2];
  CFTypeRef cf[2];
  CFTypeRef v77[2];
  CFTypeRef v78[3];

  v78[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  Length = CFDataGetLength(theData);
  if (!Length)
  {
    if (!a7)
      return 0;
    Error = __CFPropertyListCreateError(3840, CFSTR("Conversion of string failed. The string is empty."));
    goto LABEL_8;
  }
  v22 = Length;
  v78[0] = 0;
  *(_OWORD *)v77 = 0u;
  *(_OWORD *)cf = 0u;
  *(_OWORD *)v75 = 0u;
  BytePtr = CFDataGetBytePtr(theData);
  v70 = &BytePtr[a3];
  if (__OFADD__(&BytePtr[a3], v22))
  {
    if (!a7)
      return 0;
    Error = __CFPropertyListCreateError(3840, CFSTR("Unable to address entirety of CFPropertyList"));
LABEL_8:
    v25 = Error;
    goto LABEL_9;
  }
  v27 = a9;
  v71 = (char *)&BytePtr[a3];
  v72 = (unint64_t)&BytePtr[v22];
  v73 = 0;
  v74 = a1;
  LODWORD(v75[0]) = a6;
  LOBYTE(cf[1]) = a8;
  LOBYTE(v77[1]) = 0;
  if (!a12)
    goto LABEL_79;
  CFRetain(theData);
  v75[1] = CFBurstTrieCreate();
  cf[0] = CFArrayCreateMutable(a1, 0, &kCFTypeArrayCallBacks);
  v77[0] = __CFPropertyListCreateTopLevelKeyPaths(a1, a10);
  while (1)
  {
    v28 = v71;
    if ((unint64_t)v71 >= v72)
    {
      v50 = __CFPropertyListCreateError(3840, CFSTR("Encountered unexpected EOF"), v64, v66);
LABEL_69:
      v51 = 0;
      v52 = 0;
      v73 = v50;
      goto LABEL_75;
    }
    v29 = v72 - (_QWORD)v71;
    while (1)
    {
      v30 = *v28;
      v31 = v30 > 0x20;
      v32 = (1 << v30) & 0x100002600;
      if (v31 || v32 == 0)
        break;
      ++v28;
      if (!--v29)
      {
        v28 = (char *)v72;
        break;
      }
    }
    v71 = v28;
    if ((unint64_t)(v28 + 1) >= v72)
    {
      v50 = __CFPropertyListCreateError(3840, CFSTR("No XML content found"), v64, v66);
      goto LABEL_69;
    }
    v34 = *v28;
    if ((_DWORD)v34 != 60)
    {
      v68 = lineNumber((unint64_t *)&v70);
      v50 = __CFPropertyListCreateError(3840, CFSTR("Unexpected character %c at line %u"), v34, v68);
      goto LABEL_69;
    }
    v71 = v28 + 1;
    v35 = v28[1];
    if (v35 == 63)
    {
      v71 = v28 + 2;
      skipXMLProcessingInstruction((unint64_t *)&v70);
      goto LABEL_29;
    }
    if ((unsigned __int16)v35 != 33)
      break;
    v36 = v28 + 2;
    v71 = v28 + 2;
    if ((unint64_t)(v28 + 3) < v72 && *(_BYTE *)v36 == 45 && v28[3] == 45)
    {
      v71 = v28 + 5;
      skipXMLComment((unint64_t *)&v70);
LABEL_29:
      if (v73)
        goto LABEL_70;
    }
    else
    {
      if ((uint64_t)(v72 - (_QWORD)v36) >= 7
        && (*v36 == 1413697348 ? (v37 = *(_DWORD *)(v28 + 5) == 1162893652) : (v37 = 0), v37))
      {
        v39 = (unsigned __int8 *)(v28 + 9);
        v71 = v28 + 9;
        if ((unint64_t)(v28 + 9) < v72)
        {
          v40 = v72 - (_QWORD)v28 - 9;
          while (1)
          {
            v41 = (char)*v39;
            v31 = v41 > 0x20;
            v42 = (1 << v41) & 0x100002600;
            if (v31 || v42 == 0)
              break;
            v71 = (char *)++v39;
            if (!--v40)
            {
              v39 = (unsigned __int8 *)v72;
              break;
            }
          }
        }
        if ((unint64_t)v39 < v72)
        {
          v44 = v72 - (_QWORD)v39;
          while (1)
          {
            v45 = *v39;
            if (v45 == 91)
              break;
            if (v45 == 62)
            {
              v47 = (char *)(v39 + 1);
              goto LABEL_63;
            }
            v71 = (char *)++v39;
            if (!--v44)
            {
              v39 = (unsigned __int8 *)v72;
              break;
            }
          }
        }
        if (v39 == (unsigned __int8 *)v72 || (unint64_t)v39 >= v72)
        {
LABEL_61:
          v38 = __CFPropertyListCreateError(3840, CFSTR("Encountered unexpected EOF while parsing DTD"), v64, v66);
        }
        else
        {
          v46 = v72 - (_QWORD)v39;
          v47 = (char *)(v39 + 1);
          while (1)
          {
            v48 = *(v47 - 1);
            if (v48 > 0x20 || ((1 << *(v47 - 1)) & 0x100002600) == 0)
              break;
            v71 = v47++;
            if (!--v46)
              goto LABEL_61;
          }
          if ((_DWORD)v48 == 62)
          {
LABEL_63:
            v71 = v47;
            goto LABEL_29;
          }
          v67 = lineNumber((unint64_t *)&v70);
          v38 = __CFPropertyListCreateError(3840, CFSTR("Encountered unexpected character %c on line %u while parsing DTD"), v48, v67);
        }
      }
      else
      {
        v65 = lineNumber((unint64_t *)&v70);
        v38 = __CFPropertyListCreateError(3840, CFSTR("Malformed DTD on line %u"), v65, v66);
      }
      v73 = v38;
      if (v38)
      {
LABEL_70:
        v51 = 0;
        v52 = 0;
        goto LABEL_75;
      }
    }
  }
  v53 = parseXMLElement((uint64_t)&v70, 0, v78, 0);
  v52 = v53;
  v51 = v78[0];
  if (a9 && v53 && v78[0])
  {
    *a9 = 100;
    v52 = 1;
  }
LABEL_75:
  CFBurstTrieRelease((_QWORD *)v75[1]);
  CFRelease(cf[0]);
  if (v77[0])
    CFRelease(v77[0]);
  CFRelease(theData);
  v27 = a9;
  if (v52)
  {
    *a11 = v51;
    return 1;
  }
LABEL_79:
  if (!a13)
  {
    if (a7)
    {
      if (a12)
      {
        v25 = (void *)v73;
        if (v73)
          goto LABEL_9;
      }
      Error = __CFPropertyListCreateError(3840, CFSTR("Unsupported property list"));
      goto LABEL_8;
    }
    result = (uint64_t)v73;
    if (!v73)
      return result;
    goto LABEL_100;
  }
  value = 0;
  if (a7)
    p_value = &value;
  else
    p_value = 0;
  v55 = __CFCreateOldStylePropertyListOrStringsFile(a1, theData, a4, a5, a6, (CFErrorRef *)p_value, v27);
  v56 = (__CFError *)v73;
  if (!v55)
  {
    if (a7)
    {
      v25 = value;
      if (v73 && value)
      {
        v58 = CFErrorCopyUserInfo((CFErrorRef)v73);
        Count = CFDictionaryGetCount(v58);
        MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count + 1, v58);
        CFDictionaryAddValue(MutableCopy, CFSTR("kCFPropertyListOldStyleParsingError"), value);
        Domain = CFErrorGetDomain(v56);
        Code = CFErrorGetCode(v56);
        v63 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Domain, Code, MutableCopy);
        CFRelease(v58);
        CFRelease(MutableCopy);
        CFRelease(value);
        CFRelease(v56);
        result = 0;
        *a7 = v63;
        return result;
      }
      if (v73 && !value)
      {
        result = 0;
        *a7 = v73;
        return result;
      }
      if (!v73 && value)
      {
LABEL_9:
        result = 0;
        *a7 = v25;
        return result;
      }
      if (!((unint64_t)v73 | (unint64_t)value))
      {
        Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unknown error during parse"));
        goto LABEL_8;
      }
      return 0;
    }
    if (!v73)
      return 0;
    result = (uint64_t)v73;
LABEL_100:
    CFRelease((CFTypeRef)result);
    return 0;
  }
  v57 = v55;
  if (v73)
    CFRelease(v73);
  *a11 = v57;
  return 1;
}

void CFBurstTrieRelease(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  void *v5;

  v2 = (unsigned int *)a1 + 521;
  do
  {
    v3 = __ldaxr(v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, v2));
  if (!v4)
  {
    v5 = (void *)a1[257];
    if (v5)
    {
      if (*((_BYTE *)a1 + 2088))
        munmap(v5, *((unsigned int *)a1 + 516));
    }
    else
    {
      finalizeCFBurstTrie((uint64_t)a1);
    }
    free(a1);
  }
}

void finalizeCFBurstTrie(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;

  for (i = 0; i != 256; ++i)
  {
    v3 = *(_QWORD *)(a1 + 8 * i);
    if ((v3 & 3) == 2)
    {
      v4 = (_QWORD *)(v3 & 0xFFFFFFFFFFFFFFFCLL);
      do
      {
        v5 = (_QWORD *)*v4;
        free(v4);
        v4 = v5;
      }
      while (v5);
    }
    else if ((v3 & 3) == 1)
    {
      finalizeCFBurstTrie(v3 & 0xFFFFFFFFFFFFFFFCLL);
      free((void *)(*(_QWORD *)(a1 + 8 * i) & 0xFFFFFFFFFFFFFFFCLL));
    }
  }
}

_DWORD *CFBurstTrieCreate()
{
  CFNumberRef v0;
  __CFDictionary *Mutable;
  _DWORD *v2;
  int valuePtr;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  valuePtr = 256;
  v0 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  Mutable = CFDictionaryCreateMutable(0, 1, 0, 0);
  CFDictionarySetValue(Mutable, CFSTR("ContainerSize"), v0);
  v2 = CFBurstTrieCreateWithOptions(Mutable);
  CFRelease(v0);
  CFRelease(Mutable);
  return v2;
}

_DWORD *CFBurstTrieCreateWithOptions(const __CFDictionary *a1)
{
  _DWORD *v2;
  int v3;
  int valuePtr;
  void *value[2];

  value[1] = *(void **)MEMORY[0x1E0C80C00];
  v2 = malloc_type_calloc(1uLL, 0x830uLL, 0x1010040873DE71CuLL);
  v2[520] = 256;
  value[0] = 0;
  if (CFDictionaryGetValueIfPresent(a1, CFSTR("ContainerSize"), (const void **)value))
  {
    valuePtr = 0;
    CFNumberGetValue((CFNumberRef)value[0], kCFNumberIntType, &valuePtr);
    v3 = valuePtr;
    if ((valuePtr - 3) >= 0xFFD)
      v3 = 256;
    v2[520] = v3;
  }
  atomic_store(1u, v2 + 521);
  return v2;
}

Boolean CFURLCreateDataAndPropertiesFromResource(CFAllocatorRef alloc, CFURLRef url, CFDataRef *resourceData, CFDictionaryRef *properties, CFArrayRef desiredProperties, SInt32 *errorCode)
{
  const __CFString *v12;
  const __CFString *v13;
  char v14;
  int v15;
  const __CFAllocator *v16;
  __objc2_class **v17;
  const __CFData *v18;
  uint64_t Count;
  void **p_value;
  CFDateRef *p_cf;
  CFIndex v22;
  const __CFString *v23;
  __CFString *v24;
  __CFString *ValueAtIndex;
  CFNumberRef v26;
  __CFDictionary *v27;
  const __CFString *v28;
  const __CFString *v29;
  int v30;
  __objc2_class **v31;
  __CFDictionary *v32;
  int v33;
  int v34;
  SInt32 v35;
  int v36;
  const __CFAllocator *allocator;
  const __CFDictionary *theDict;
  uid_t v40;
  void *value;
  CFTypeRef cf;
  CFIndex length;
  int valuePtr;
  char v45;
  UInt8 *bytes[11];
  CFRange v47;
  CFRange v48;
  CFRange v49;

  bytes[9] = *(UInt8 **)MEMORY[0x1E0C80C00];
  v12 = CFURLCopyScheme(url);
  if (v12)
  {
    v13 = v12;
    if (CFStringCompare(v12, CFSTR("file"), 1uLL))
    {
      if (CFStringCompare(v13, CFSTR("data"), 1uLL) == kCFCompareEqualTo)
      {
        v14 = _CFDataURLCreateDataAndPropertiesFromResource(alloc, url, (__CFString *)resourceData, desiredProperties, properties, (__CFString *)errorCode);
        goto LABEL_24;
      }
      if (__CFNetwork__CFURLCreateDataAndPropertiesFromResource_onceToken != -1)
        dispatch_once(&__CFNetwork__CFURLCreateDataAndPropertiesFromResource_onceToken, &__block_literal_global_23);
      if (__CFNetwork__CFURLCreateDataAndPropertiesFromResource_dyfunc)
      {
        v14 = __CFNetwork__CFURLCreateDataAndPropertiesFromResource_dyfunc(alloc, url, resourceData, properties, desiredProperties, errorCode);
LABEL_24:
        LOBYTE(v15) = v14;
LABEL_106:
        CFRelease(v13);
        return v15;
      }
      if (resourceData)
        *resourceData = 0;
      if (properties)
        *properties = 0;
      if (errorCode)
      {
        LOBYTE(v15) = 0;
        *errorCode = -15;
        goto LABEL_106;
      }
LABEL_105:
      LOBYTE(v15) = 0;
      goto LABEL_106;
    }
    if (errorCode)
      *errorCode = 0;
    if (resourceData)
    {
      bytes[0] = 0;
      length = 0;
      v16 = alloc;
      if (!alloc)
      {
        v17 = (__objc2_class **)_CFGetTSD(1u);
        if (!v17)
          v17 = &__kCFAllocatorSystemDefault;
        v16 = (const __CFAllocator *)CFRetain(v17);
      }
      if (_CFReadBytesFromFile(v16, url, (void **)bytes, &length, 0, 0))
      {
        v18 = CFDataCreateWithBytesNoCopy(v16, bytes[0], length, v16);
        v15 = 1;
      }
      else
      {
        v18 = 0;
        v15 = 0;
        if (errorCode)
          *errorCode = -10;
      }
      *resourceData = v18;
      if (!alloc)
        CFRelease(v16);
    }
    else
    {
      v15 = 1;
      v16 = alloc;
    }
    if (!properties)
    {
LABEL_101:
      if (!resourceData || v15)
        goto LABEL_106;
      if (*resourceData)
      {
        CFRelease(*resourceData);
        LOBYTE(v15) = 0;
        *resourceData = 0;
        goto LABEL_106;
      }
      goto LABEL_105;
    }
    allocator = v16;
    value = 0;
    cf = 0;
    if (errorCode)
      *errorCode = 0;
    v45 = 0;
    valuePtr = 0;
    length = 0;
    v40 = 0;
    if (!desiredProperties)
    {
      desiredProperties = (CFArrayRef)_CFFileURLCreatePropertiesFromResource__allProps;
      if (!_CFFileURLCreatePropertiesFromResource__allProps)
      {
        memset(&bytes[6], 0, 24);
        bytes[0] = (UInt8 *)CFSTR("kCFURLFileExists");
        bytes[1] = (UInt8 *)CFSTR("kCFURLFilePOSIXMode");
        bytes[2] = (UInt8 *)CFSTR("kCFURLFileDirectoryContents");
        bytes[3] = (UInt8 *)CFSTR("kCFURLFileLength");
        bytes[4] = (UInt8 *)CFSTR("kCFURLFileLastModificationTime");
        bytes[5] = (UInt8 *)CFSTR("kCFURLFileOwnerID");
        desiredProperties = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)bytes, 6, &kCFTypeArrayCallBacks);
        _CFFileURLCreatePropertiesFromResource__allProps = (uint64_t)desiredProperties;
      }
    }
    Count = CFArrayGetCount(desiredProperties);
    theDict = CFDictionaryCreateMutable(v16, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!Count)
    {
LABEL_99:
      *properties = theDict;
      if (!theDict)
        v15 = 0;
      goto LABEL_101;
    }
    v47.location = 0;
    v47.length = Count;
    if (CFArrayContainsValue(desiredProperties, v47, CFSTR("kCFURLFileDirectoryContents")))
      p_value = &value;
    else
      p_value = 0;
    v48.location = 0;
    v48.length = Count;
    if (CFArrayContainsValue(desiredProperties, v48, CFSTR("kCFURLFileLastModificationTime")))
      p_cf = (CFDateRef *)&cf;
    else
      p_cf = 0;
    if (_CFGetFileProperties(allocator, url, &v45, &valuePtr, &length, p_cf, &v40, (__CFArray **)p_value))
    {
      if (Count == 1
        && (v49.location = 0, v49.length = 1,
                                CFArrayContainsValue(desiredProperties, v49, CFSTR("kCFURLFileExists"))))
      {
        CFDictionarySetValue(theDict, CFSTR("kCFURLFileExists"), &__kCFBooleanFalse);
      }
      else if (errorCode)
      {
        *errorCode = -10;
      }
      goto LABEL_99;
    }
    if (Count < 1)
    {
LABEL_95:
      if (cf)
        CFRelease(cf);
      if (value)
        CFRelease(value);
      goto LABEL_99;
    }
    v22 = 0;
    v23 = CFSTR("kCFURLFileLength");
    while (1)
    {
      v24 = (__CFString *)v23;
      ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex(desiredProperties, v22);
      if (ValueAtIndex == CFSTR("kCFURLFilePOSIXMode") || CFEqual(CFSTR("kCFURLFilePOSIXMode"), ValueAtIndex))
        break;
      v29 = CFSTR("kCFURLFileDirectoryContents");
      if (ValueAtIndex == CFSTR("kCFURLFileDirectoryContents")
        || (v30 = CFEqual(CFSTR("kCFURLFileDirectoryContents"), ValueAtIndex),
            v29 = CFSTR("kCFURLFileDirectoryContents"),
            v30))
      {
        if (v45)
        {
          if ((valuePtr & 0xF000) == 0x4000)
          {
            v31 = (__objc2_class **)value;
            if (value)
              goto LABEL_68;
          }
        }
LABEL_78:
        v23 = v24;
        goto LABEL_79;
      }
      v23 = v24;
      if (ValueAtIndex != v24)
      {
        v33 = CFEqual(v24, ValueAtIndex);
        v23 = v24;
        if (!v33)
        {
          v29 = CFSTR("kCFURLFileLastModificationTime");
          if (ValueAtIndex == CFSTR("kCFURLFileLastModificationTime")
            || (v34 = CFEqual(CFSTR("kCFURLFileLastModificationTime"), ValueAtIndex),
                v29 = CFSTR("kCFURLFileLastModificationTime"),
                v34))
          {
            if (v45)
            {
              v31 = (__objc2_class **)cf;
              if (cf)
              {
LABEL_68:
                v32 = theDict;
LABEL_69:
                CFDictionarySetValue(v32, v29, v31);
                goto LABEL_62;
              }
            }
          }
          else
          {
            v29 = CFSTR("kCFURLFileExists");
            if (ValueAtIndex == CFSTR("kCFURLFileExists")
              || (v36 = CFEqual(CFSTR("kCFURLFileExists"), ValueAtIndex), v29 = CFSTR("kCFURLFileExists"), v36))
            {
              v32 = theDict;
              if (v45)
                v31 = &__kCFBooleanTrue;
              else
                v31 = &__kCFBooleanFalse;
              goto LABEL_69;
            }
            if (ValueAtIndex != CFSTR("kCFURLFileOwnerID") && !CFEqual(CFSTR("kCFURLFileOwnerID"), ValueAtIndex))
            {
              v23 = v24;
              if (!errorCode)
                goto LABEL_82;
              v35 = -16;
              goto LABEL_81;
            }
            if (v45)
            {
              v26 = CFNumberCreate(allocator, kCFNumberSInt32Type, &v40);
              v27 = theDict;
              v28 = CFSTR("kCFURLFileOwnerID");
LABEL_61:
              CFDictionarySetValue(v27, v28, v26);
              CFRelease(v26);
LABEL_62:
              v23 = v24;
              goto LABEL_82;
            }
          }
          goto LABEL_78;
        }
      }
      if (v45)
      {
        v26 = CFNumberCreate(allocator, kCFNumberSInt64Type, &length);
        v27 = theDict;
        v28 = v24;
        goto LABEL_61;
      }
LABEL_79:
      if (errorCode)
      {
        v35 = -10;
LABEL_81:
        *errorCode = v35;
      }
LABEL_82:
      if (Count == ++v22)
        goto LABEL_95;
    }
    if (v45)
    {
      v26 = CFNumberCreate(allocator, kCFNumberSInt32Type, &valuePtr);
      v27 = theDict;
      v28 = CFSTR("kCFURLFilePOSIXMode");
      goto LABEL_61;
    }
    goto LABEL_78;
  }
  if (errorCode)
    *errorCode = -15;
  if (resourceData)
    *resourceData = 0;
  LOBYTE(v15) = 0;
  if (properties)
    *properties = 0;
  return v15;
}

CFStringRef CFURLCopyScheme(CFURLRef anURL)
{
  const __CFString *v2;
  const __CFString *v3;
  const __CFString *v4;
  const __CFString *v5;

  while (2)
  {
    if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)anURL))
    {
      v5 = (const __CFString *)-[__CFURL scheme](anURL, "scheme");
      v3 = v5;
      if (v5)
        CFRetain(v5);
    }
    else
    {
      switch(*((_DWORD *)anURL + 4) >> 29)
      {
        case 1:
          v4 = CFSTR("http");
          return (CFStringRef)CFRetain(v4);
        case 2:
          v4 = CFSTR("https");
          return (CFStringRef)CFRetain(v4);
        case 3:
          v4 = CFSTR("file");
          return (CFStringRef)CFRetain(v4);
        case 4:
          v4 = CFSTR("data");
          return (CFStringRef)CFRetain(v4);
        case 5:
          v4 = CFSTR("ftp");
          return (CFStringRef)CFRetain(v4);
        default:
          v2 = _retainedComponentString((uint64_t)anURL, 1, 1, 0);
          if (v2)
            return v2;
          anURL = (CFURLRef)*((_QWORD *)anURL + 4);
          if (anURL)
            continue;
          v3 = 0;
          break;
      }
    }
    break;
  }
  return v3;
}

uint64_t _CFReadBytesFromFile(const __CFAllocator *a1, CFURLRef url, void **a3, int64_t *a4, int64_t st_size, int a6)
{
  uint64_t result;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t Typed;
  void *v18;
  int v19;
  UInt8 buffer[1026];
  stat v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  result = CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026);
  if ((_DWORD)result)
  {
    *a3 = 0;
    if (__CFProphylacticAutofsAccess)
    {
      v12 = open("/dev/autofs_nowait", 0);
      v13 = open((const char *)buffer, a6, 438);
      if (v13 < 0)
        goto LABEL_21;
      v14 = v13;
    }
    else
    {
      v15 = open((const char *)buffer, a6, 438);
      if (v15 < 0)
        return 0;
      v14 = v15;
      v12 = -1;
    }
    memset(&v21, 0, sizeof(v21));
    if (fstat(v14, &v21) < 0)
    {
      v19 = *__error();
      close(v14);
      if (v12 != -1)
        close(v12);
      *__error() = v19;
      return 0;
    }
    if ((v21.st_mode & 0xF000) != 0x8000)
    {
      close(v14);
      if (v12 != -1)
        close(v12);
      *__error() = 13;
      return 0;
    }
    if (v21.st_size)
    {
      if (v21.st_size <= st_size || st_size == 0)
        st_size = v21.st_size;
      Typed = CFAllocatorAllocateTyped(a1, st_size, 920877487, 0);
      *a3 = (void *)Typed;
      if (!Typed)
        goto LABEL_20;
      v18 = (void *)Typed;
      if (__CFOASafe)
      {
        __CFSetLastAllocationEventName();
        v18 = *a3;
      }
      if (read(v14, v18, st_size) < 0)
      {
        CFAllocatorDeallocate(a1, *a3);
LABEL_20:
        close(v14);
LABEL_21:
        if (v12 != -1)
          close(v12);
        return 0;
      }
    }
    else
    {
      *a3 = (void *)CFAllocatorAllocateTyped(a1, 4, 1113882534, 0);
      if (__CFOASafe)
        __CFSetLastAllocationEventName();
      st_size = 0;
    }
    *a4 = st_size;
    if (v12 != -1)
      close(v12);
    close(v14);
    return 1;
  }
  return result;
}

uint64_t parsePListTag(unint64_t *a1, CFTypeRef *a2, unint64_t a3)
{
  unint64_t v6;
  CFErrorRef Error;
  CFErrorRef v8;
  uint64_t result;
  int v10;
  uint64_t v11;
  CFTypeRef cf;
  CFTypeRef v13[2];

  v13[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  v13[0] = 0;
  if (!getContentObject(a1, 0, (uint64_t)v13, a3))
  {
    if (!a1[3])
    {
      Error = __CFPropertyListCreateError(3840, CFSTR("Encountered empty plist tag"));
LABEL_10:
      v8 = Error;
      result = 0;
      a1[3] = (unint64_t)v8;
      return result;
    }
    return 0;
  }
  v6 = a1[1];
  cf = 0;
  if (getContentObject(a1, 0, (uint64_t)&cf, a3))
  {
    if (cf)
      CFRelease(cf);
    if (v13[0])
      CFRelease(v13[0]);
    a1[1] = v6;
    v11 = lineNumber(a1);
    Error = __CFPropertyListCreateError(3840, CFSTR("Encountered unexpected element at line %u (plist can only include one object)"), v11);
    goto LABEL_10;
  }
  if (a1[3])
  {
    result = (uint64_t)v13[0];
  }
  else
  {
    v10 = checkForCloseTag(a1, (const UInt8 *)"plist", 5uLL);
    result = (uint64_t)v13[0];
    if (v10)
    {
      *a2 = v13[0];
      return 1;
    }
  }
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 0;
  }
  return result;
}

unint64_t *skipXMLProcessingInstruction(unint64_t *result)
{
  unint64_t *v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;

  v1 = result;
  v2 = result[1];
  v3 = result[2];
  if (v2 >= v3 - 2)
  {
LABEL_6:
    result[1] = v2;
    v6 = lineNumber(result);
    result = (unint64_t *)__CFPropertyListCreateError(3840, CFSTR("Encountered unexpected EOF while parsing the processing instruction begun on line %u"), v6);
    v1[3] = (unint64_t)result;
  }
  else
  {
    v4 = v3 - v2 - 2;
    v5 = (_BYTE *)(v2 + 1);
    while (*(v5 - 1) != 63 || *v5 != 62)
    {
      result[1] = (unint64_t)v5++;
      if (!--v4)
        goto LABEL_6;
    }
    result[1] = (unint64_t)(v5 + 1);
  }
  return result;
}

uint64_t lineNumber(unint64_t *a1)
{
  unsigned __int8 *v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t result;
  int v5;

  v1 = (unsigned __int8 *)*a1;
  v2 = a1[2];
  if (*a1 >= v2)
    return 1;
  v3 = a1[1];
  result = 1;
  do
  {
    if ((unint64_t)v1 >= v3)
      break;
    v5 = *v1;
    if (v5 == 10)
    {
      result = (result + 1);
    }
    else if (v5 == 13)
    {
      result = (result + 1);
      if ((unint64_t)(v1 + 1) < v2 && (unint64_t)(v1 + 1) < v3 && v1[1] == 10)
        ++v1;
    }
    ++v1;
  }
  while ((unint64_t)v1 < v2);
  return result;
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)err))
    return -[__CFError code](err, "code");
  else
    return *((_QWORD *)err + 2);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)err))
    return (CFErrorDomain)-[__CFError domain](err, "domain");
  else
    return (CFErrorDomain)*((_QWORD *)err + 3);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  const void *v2;
  const __CFAllocator *v4;

  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)err))
  {
    v2 = (const void *)-[__CFError userInfo](err, "userInfo");
    if (v2)
      return (CFDictionaryRef)CFRetain(v2);
  }
  else
  {
    v2 = (const void *)*((_QWORD *)err + 4);
    if (v2)
      return (CFDictionaryRef)CFRetain(v2);
  }
  v4 = CFGetAllocator(err);
  return _CFErrorCreateEmptyDictionary(v4);
}

CFTypeRef _CFLocaleCopyPreferredTemperatureUnit()
{
  CFPropertyListRef v0;
  CFTypeRef *v1;
  CFTypeRef v2;
  char v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v0 = CFPreferencesCopyValue(CFSTR("AppleTemperatureUnit"), CFSTR("kCFPreferencesAnyApplication"), CFSTR("kCFPreferencesCurrentUser"), CFSTR("kCFPreferencesAnyHost"));
  v4 = 0;
  if (!_CFLocaleGetTemperatureUnitForPreferences((uint64_t)v0, &v4))
  {
    v2 = 0;
    if (!v0)
      return v2;
LABEL_7:
    CFRelease(v0);
    return v2;
  }
  v1 = (CFTypeRef *)&kCFLocaleTemperatureUnitCelsius;
  if (!v4)
    v1 = (CFTypeRef *)&kCFLocaleTemperatureUnitFahrenheit;
  v2 = CFRetain(*v1);
  if (v0)
    goto LABEL_7;
  return v2;
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)_CFPreferencesCopyValueWithContainer((uint64_t)key, (uint64_t)applicationID, (uint64_t)userName, (uint64_t)hostName, 0);
}

uint64_t _CFLocaleGetTemperatureUnitForPreferences(uint64_t result, char *a2)
{
  const void *v3;
  char v4;

  if (result)
  {
    v3 = (const void *)result;
    if (CFEqual((CFTypeRef)result, CFSTR("Celsius")))
    {
      v4 = 1;
    }
    else
    {
      result = CFEqual(v3, CFSTR("Fahrenheit"));
      v4 = 0;
      if (!(_DWORD)result)
        return result;
    }
    *a2 = v4;
    return 1;
  }
  return result;
}

uint64_t __NSMS6(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  BOOL v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v2 = a1 != 0;
  v3 = a2 != 0;
  if (!(a1 | a2))
    return 1;
  v4 = a2;
  v5 = a1;
  while (1)
  {
    result = 0;
    if (!v2 || !v3)
      break;
    if (*(_BYTE *)(v5 + 36) != 64 || *(_BYTE *)(v4 + 36) != 64)
    {
      result = __NSMS6(*(_QWORD *)v5, *(_QWORD *)v4);
      if ((_DWORD)result)
      {
        result = __NSMS6(*(_QWORD *)(v5 + 8), *(_QWORD *)(v4 + 8));
        if ((_DWORD)result)
          return strcmp((const char *)(v5 + 37), (const char *)(v4 + 37)) == 0;
      }
      return result;
    }
    v7 = *(unsigned __int16 *)(v5 + 34);
    v8 = *(unsigned __int16 *)(v4 + 34);
    if (((v8 ^ v7) & 0x8000) != 0)
      return 0;
    v9 = *(_QWORD *)v5;
    if (*(_QWORD *)v5)
    {
      v10 = *(_QWORD *)v4;
      if (*(_QWORD *)v4)
      {
        if ((v8 & v7 & 0x8000) != 0)
        {
          if ((__NSMS6(v9, v10) & 1) == 0)
            return 0;
        }
        else if (strcmp((const char *)(v9 + 37), (const char *)(v10 + 37)))
        {
          return 0;
        }
      }
    }
    v5 = *(_QWORD *)(v5 + 8);
    v4 = *(_QWORD *)(v4 + 8);
    v2 = v5 != 0;
    v3 = v4 != 0;
    if (!(v5 | v4))
      return 1;
  }
  return result;
}

__CFData *_CFPropertyListCreateXMLData(CFAllocatorRef allocator, const __CFString *a2, int a3)
{
  __CFData *Mutable;
  _QWORD v7[2];
  __int128 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!a3 || (v7[0] = 1, v8 = 0u, v9 = 0, v7[1] = 100, Mutable = 0, __CFPropertyListIsValidAux(a2, v7)))
  {
    Mutable = CFDataCreateMutable(allocator, 0);
    CFDataAppendBytes(Mutable, (const UInt8 *)"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE ", 49);
    _plistAppendCharacters(Mutable, L"plist", 5);
    CFDataAppendBytes(Mutable, (const UInt8 *)" PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<", 89);
    _plistAppendCharacters(Mutable, L"plist", 5);
    CFDataAppendBytes(Mutable, (const UInt8 *)" version=\"1.0\">\n", 16);
    _CFAppendXML0(a2, 0, Mutable);
    CFDataAppendBytes(Mutable, (const UInt8 *)"</", 2);
    _plistAppendCharacters(Mutable, L"plist", 5);
    CFDataAppendBytes(Mutable, (const UInt8 *)">\n", 2);
  }
  return Mutable;
}

uint64_t parseDataTag(uint64_t a1, __CFData **a2)
{
  UInt8 *Typed;
  unsigned __int8 *v4;
  char v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t result;
  __CFData *Mutable;
  const __CFAllocator *v16;
  uint64_t v17;
  uint64_t v18;
  CFErrorRef Error;
  uint64_t v20;

  v20 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(a1 + 80))
  {
    Typed = 0;
    v4 = *(unsigned __int8 **)(a1 + 8);
  }
  else
  {
    Typed = (UInt8 *)CFAllocatorAllocateTyped(*(_QWORD *)(a1 + 32), 256, 3027262758, 0);
    v4 = *(unsigned __int8 **)(a1 + 8);
  }
  if ((unint64_t)v4 >= *(_QWORD *)(a1 + 16))
  {
    v8 = 0;
LABEL_29:
    if (*(_BYTE *)(a1 + 80))
    {
      result = checkForCloseTag((unint64_t *)a1, (const UInt8 *)"data", 4uLL);
      if (!(_DWORD)result)
        return result;
      Mutable = 0;
    }
    else
    {
      v16 = *(const __CFAllocator **)(a1 + 32);
      if (*(_DWORD *)(a1 + 40) == 2)
      {
        Mutable = CFDataCreateMutable(v16, 0);
        CFDataAppendBytes(Mutable, Typed, v8);
        CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 32), Typed);
      }
      else
      {
        Mutable = CFDataCreateWithBytesNoCopy(v16, Typed, v8, *(CFAllocatorRef *)(a1 + 32));
      }
      if (!Mutable)
      {
        *(_QWORD *)(a1 + 8) = v20;
        v18 = lineNumber((unint64_t *)a1);
        Error = __CFPropertyListCreateError(3840, CFSTR("Could not interpret <data> at line %u (should be base64-encoded)"), v18);
        result = 0;
        *(_QWORD *)(a1 + 24) = Error;
        return result;
      }
      if (!checkForCloseTag((unint64_t *)a1, (const UInt8 *)"data", 4uLL))
      {
        CFRelease(Mutable);
        return 0;
      }
    }
    *a2 = Mutable;
    return 1;
  }
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 256;
  v10 = MEMORY[0x1E0C80978];
  while (1)
  {
    v11 = *v4;
    if ((_DWORD)v11 != 61)
      break;
    ++v7;
LABEL_11:
    if ((parseDataTag_dataDecodeTable[v11] & 0x80000000) == 0)
    {
      ++v5;
      v6 = parseDataTag_dataDecodeTable[v11] + (v6 << 6);
      if (!*(_BYTE *)(a1 + 80) && (v5 & 3) == 0)
      {
        v12 = v8 + 2;
        if (v9 <= (int)v12)
        {
          if (v9 >= 0x40000)
          {
            if (HIBYTE(v9))
              v9 += 0x40000;
            else
              v9 *= 2;
          }
          else
          {
            v9 *= 4;
          }
          Typed = (UInt8 *)__CFSafelyReallocateWithAllocatorTyped(*(_QWORD *)(a1 + 32), Typed, v9, 3151119965, 0, 0);
          v10 = MEMORY[0x1E0C80978];
        }
        Typed[v8] = BYTE2(v6);
        if (v7 > 1)
        {
          ++v8;
        }
        else
        {
          Typed[v8 + 1] = BYTE1(v6);
          if (v7 == 1)
          {
            v8 += 2;
          }
          else
          {
            v8 += 3;
            Typed[v12] = v6;
          }
        }
      }
    }
    v13 = *(_QWORD *)(a1 + 16);
    v4 = (unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 1);
    *(_QWORD *)(a1 + 8) = v4;
    if ((unint64_t)v4 >= v13)
      goto LABEL_29;
  }
  if ((_DWORD)v11 == 60)
    goto LABEL_29;
  if ((v11 & 0x80) == 0)
  {
    v7 &= (int)(*(_DWORD *)(v10 + 4 * v11 + 60) << 17) >> 31;
    goto LABEL_11;
  }
  __maskrune(*v4, 0x4000uLL);
  v17 = lineNumber((unint64_t *)a1);
  *(_QWORD *)(a1 + 24) = __CFPropertyListCreateError(3840, CFSTR("Could not interpret <data> on line %u (invalid character 0x%hhX)"), v17, v11);
  if (Typed)
    CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 32), Typed);
  return 0;
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const __CFString *v11;
  __CFWriteStream *v13;
  const __CFData *v14;
  __int16 v16;
  CFTypeRef cf;
  __int128 v18;
  uint64_t v19;
  CFTypeRef *p_cf;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (format == kCFPropertyListBinaryFormat_v1_0)
  {
    v13 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)&__kCFAllocatorSystemDefault, allocator);
    CFWriteStreamOpen(v13);
    if (CFPropertyListWrite(propertyList, v13, kCFPropertyListBinaryFormat_v1_0, options, error) < 1)
      v14 = 0;
    else
      v14 = (const __CFData *)CFWriteStreamCopyProperty(v13, CFSTR("kCFStreamPropertyDataWritten"));
    CFWriteStreamClose(v13);
    CFRelease(v13);
  }
  else
  {
    if (format != kCFPropertyListXMLFormat_v1_0)
    {
      if (format == kCFPropertyListOpenStepFormat)
        v11 = CFSTR("Property list format kCFPropertyListOpenStepFormat not supported for writing");
      else
        v11 = CFSTR("Unknown format option");
      CFLog(3, (uint64_t)v11, format, options, (uint64_t)error, v5, v6, v7, v16);
      return 0;
    }
    cf = 0;
    v18 = xmmword_182C8A760;
    v19 = 0;
    p_cf = &cf;
    v21 = 0;
    if (!__CFPropertyListIsValidAux(propertyList, &v18))
    {
      if (error)
        *error = __CFPropertyListCreateError(3851, CFSTR("Property list invalid for format: %ld (%@)"), 100, cf);
      if (cf)
        CFRelease(cf);
      return 0;
    }
    return _CFPropertyListCreateXMLData(allocator, (const __CFString *)propertyList, 0);
  }
  return v14;
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  if (!CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
    return _CFStreamOpen((uint64_t)stream);
  -[__CFWriteStream open](stream, "open");
  return 1;
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
    -[__CFWriteStream close](stream, "close");
  else
    _CFStreamClose((uint64_t)stream);
}

CFIndex CFPropertyListWriteToStream(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFStringRef *errorString)
{
  const __CFString *v5;
  CFIndex v6;
  CFTypeRef v7;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  if (errorString)
    *errorString = 0;
  cf[0] = 0;
  if (format != kCFPropertyListBinaryFormat_v1_0 && format != kCFPropertyListXMLFormat_v1_0)
  {
    if (format == kCFPropertyListOpenStepFormat)
    {
      if (errorString)
      {
        v5 = CFSTR("Property list format kCFPropertyListOpenStepFormat not supported for writing");
LABEL_15:
        v6 = 0;
        *errorString = (CFStringRef)CFRetain(v5);
        return v6;
      }
    }
    else if (errorString)
    {
      v5 = CFSTR("Unknown format option");
      goto LABEL_15;
    }
    return 0;
  }
  v6 = CFPropertyListWrite(propertyList, stream, format, 0, (CFErrorRef *)cf);
  v7 = cf[0];
  if (errorString && cf[0])
  {
    *errorString = __copyErrorDebugDescription((__CFError *)cf[0]);
    v7 = cf[0];
  }
  if (v7)
    CFRelease(v7);
  return v6;
}

CFIndex CFPropertyListWrite(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  CFTypeRef v17;
  CFIndex v18;
  __CFData *XMLData;
  const __CFData *v20;
  uint64_t Length;
  const UInt8 *BytePtr;
  const UInt8 *v23;
  CFIndex v24;
  BOOL v25;
  CFErrorRef v27;
  CFErrorRef v28;
  __CFDictionary *Mutable;
  __int16 v30;
  CFTypeRef cf;
  _QWORD v32[6];

  v32[5] = *MEMORY[0x1E0C80C00];
  cf = 0;
  v32[0] = 1;
  v32[1] = format;
  v32[2] = 0;
  v32[3] = &cf;
  v32[4] = 0;
  if (!__CFPropertyListIsValidAux(propertyList, v32))
  {
    if (error)
      *error = __CFPropertyListCreateError(3851, CFSTR("Property list invalid for format: %ld (%@)"), format, cf);
    v17 = cf;
    if (!cf)
      return 0;
    goto LABEL_9;
  }
  if (format == kCFPropertyListBinaryFormat_v1_0)
    return __CFBinaryPlistWrite(propertyList, stream, 0, options, error);
  if (format != kCFPropertyListXMLFormat_v1_0)
  {
    if (format == kCFPropertyListOpenStepFormat)
      v16 = CFSTR("Property list format kCFPropertyListOpenStepFormat not supported for writing");
    else
      v16 = CFSTR("Unknown format option");
    goto LABEL_21;
  }
  XMLData = _CFPropertyListCreateXMLData((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const __CFString *)propertyList, 1);
  if (!XMLData)
  {
    v16 = CFSTR("Property list format kCFPropertyListXMLFormat_v1_0 specified but was not a valid property list type");
LABEL_21:
    CFLog(3, (uint64_t)v16, v10, v11, v12, v13, v14, v15, v30);
    return 0;
  }
  v20 = XMLData;
  Length = CFDataGetLength(XMLData);
  BytePtr = CFDataGetBytePtr(v20);
  if (Length >= 1)
  {
    v23 = BytePtr;
    while (1)
    {
      v24 = CFWriteStreamWrite(stream, v23, Length);
      if (!v24)
        break;
      if (v24 < 0)
      {
        v27 = CFWriteStreamCopyError(stream);
        if (v27)
        {
          v28 = v27;
          if (error)
          {
            Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue(Mutable, CFSTR("NSDebugDescription"), CFSTR("Property list writing could not be completed because the stream had an unknown error."));
            CFDictionarySetValue(Mutable, CFSTR("NSUnderlyingError"), v28);
            *error = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("NSCocoaErrorDomain"), 3851, Mutable);
            CFRelease(Mutable);
          }
          CFRelease(v28);
        }
        goto LABEL_30;
      }
      v23 += v24;
      v25 = Length <= v24;
      Length -= v24;
      if (v25)
        goto LABEL_18;
    }
    if (error)
      *error = __CFPropertyListCreateError(3851, CFSTR("Property list writing could not be completed because stream is full."));
LABEL_30:
    v17 = v20;
LABEL_9:
    CFRelease(v17);
    return 0;
  }
LABEL_18:
  v18 = CFDataGetLength(v20);
  CFRelease(v20);
  return v18;
}

uint64_t __CFBinaryPlistWrite(const void *a1, const void *a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, a5);
}

CFPropertyListRef CFPropertyListCreateFromStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags mutabilityOption, CFPropertyListFormat *format, CFStringRef *errorString)
{
  CFPropertyListRef v7;
  CFTypeRef v8;
  CFTypeRef cf[2];

  cf[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  if (errorString)
    *errorString = 0;
  cf[0] = 0;
  v7 = CFPropertyListCreateWithStream(allocator, stream, streamLength, mutabilityOption, format, (CFErrorRef *)cf);
  v8 = cf[0];
  if (errorString && cf[0])
  {
    *errorString = __copyErrorDebugDescription((__CFError *)cf[0]);
    v8 = cf[0];
  }
  if (v8)
    CFRelease(v8);
  return v7;
}

CFReadStreamRef CFReadStreamCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  __CFReadStream *v5;
  CFTypeRef cf[4];

  cf[3] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  cf[1] = 0;
  cf[2] = 0;
  cf[0] = CFDataCreateWithBytesNoCopy(alloc, bytes, length, bytesDeallocator);
  v5 = (__CFReadStream *)_CFStreamCreateWithConstantCallbacks((__objc2_class **)alloc, (uint64_t)cf, readDataCallBacks, 1);
  CFRelease(cf[0]);
  return v5;
}

CFWriteStreamRef CFWriteStreamCreateWithAllocatedBuffers(CFAllocatorRef alloc, CFAllocatorRef bufferAllocator)
{
  _OWORD v3[2];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v3[0] = 0u;
  v3[1] = (unint64_t)bufferAllocator;
  return (CFWriteStreamRef)_CFStreamCreateWithConstantCallbacks((__objc2_class **)alloc, (uint64_t)v3, writeDataCallBacks, 0);
}

uint64_t _CFStreamCreateWithConstantCallbacks(__objc2_class **a1, uint64_t a2, _QWORD *a3, int a4)
{
  uint64_t v6;
  double v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t, uint64_t, double);

  if (*a3 != 1)
    return 0;
  v7 = _CFStreamCreate(a1, a4);
  v8 = v6;
  if (v6)
  {
    *(_QWORD *)(v6 + 16) |= 0x20uLL;
    *(_QWORD *)(v6 + 48) = a3;
    v9 = (uint64_t (*)(uint64_t, uint64_t, double))a3[1];
    if (v9)
      a2 = v9(v6, a2, v7);
    *(_QWORD *)(v8 + 40) = a2;
  }
  return v8;
}

double _CFStreamCreate(__objc2_class **a1, int a2)
{
  unint64_t v2;
  uint64_t Instance;
  double result;
  uint64_t v5;

  if (a2)
    v2 = 38;
  else
    v2 = 39;
  Instance = _CFRuntimeCreateInstance(a1, v2, 128, 0);
  if (Instance)
  {
    v5 = *(_QWORD *)(Instance + 16);
    if ((v5 & 0x1E) != 6)
      *(_QWORD *)(Instance + 16) = v5 & 0xFFFFFFE0;
    *(_QWORD *)(Instance + 56) = 850045857;
    result = 0.0;
    *(_OWORD *)(Instance + 64) = 0u;
    *(_OWORD *)(Instance + 80) = 0u;
    *(_OWORD *)(Instance + 96) = 0u;
    *(_QWORD *)(Instance + 112) = 0;
  }
  return result;
}

uint64_t writeDataCreate(CFTypeRef cf, _QWORD *a2)
{
  CFAllocatorRef Default;
  CFAllocatorRef v5;
  uint64_t result;
  CFAllocatorRef v7;
  uint64_t v8;

  Default = (CFAllocatorRef)a2[2];
  if (Default == (CFAllocatorRef)&__kCFAllocatorNull)
  {
    v7 = CFGetAllocator(cf);
    result = CFAllocatorAllocateTyped(v7, 64, 2152488875, 0);
    *(_QWORD *)result = result + 32;
    v8 = *(_QWORD *)(*a2 + 8);
    *(_QWORD *)(result + 32) = *(_QWORD *)*a2;
    *(_QWORD *)(result + 40) = v8;
    *(_QWORD *)(result + 48) = 0;
    *(_QWORD *)(result + 56) = 0;
    *(_QWORD *)(result + 8) = result + 32;
  }
  else
  {
    if (!Default)
    {
      Default = CFAllocatorGetDefault();
      a2[2] = Default;
    }
    CFRetain(Default);
    v5 = CFGetAllocator(cf);
    result = CFAllocatorAllocateTyped(v5, 1088, 1466909623, 0);
    *(_QWORD *)(result + 32) = result + 64;
    *(_QWORD *)(result + 48) = 0;
    *(_QWORD *)(result + 56) = 0;
    *(_QWORD *)(result + 40) = 1024;
    *(_QWORD *)result = result + 32;
    *(_QWORD *)(result + 8) = result + 32;
    Default = (CFAllocatorRef)a2[2];
  }
  *(_QWORD *)(result + 16) = Default;
  *(_BYTE *)(result + 24) = 0;
  return result;
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  uint64_t v6;
  uint64_t v7;
  CFErrorRef *v8;
  CFErrorRef *v9;
  unsigned int v10;
  _QWORD *v11;
  __CFReadStream *v12;
  __CFReadStream *v13;
  int v14;
  int v15;
  char *v16;
  uint64_t v17;
  CFIndex v18;
  int v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v23;
  CFErrorRef v24;
  __CFDictionary *Mutable;
  CFPropertyListRef result;
  const __CFData *v27;
  CFErrorRef v28;
  __objc2_class **v29;
  unsigned int v30;
  _QWORD *v31;
  UInt8 buffer[8192];
  uint64_t v33;

  v6 = MEMORY[0x1E0C80A78](allocator, stream);
  v9 = v8;
  v30 = v10;
  v31 = v11;
  v13 = v12;
  v29 = (__objc2_class **)v6;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v33 = *MEMORY[0x1E0C80C00];
  if (v7)
    v17 = v7;
  else
    v17 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    if (v17 >= 0x2000)
      v18 = 0x2000;
    else
      v18 = v17;
    v19 = CFReadStreamRead(v13, buffer, v18);
    v20 = v19;
    if (v19 <= 0)
    {
      if (!v19)
      {
        v21 = v14;
        if (!v16)
          goto LABEL_38;
        goto LABEL_36;
      }
      v24 = CFReadStreamCopyError(v13);
      if (!v9)
        goto LABEL_32;
      goto LABEL_27;
    }
    v21 = v14 + v19;
    if (__OFADD__(v14, v19))
      goto LABEL_23;
    if (v15 < v21)
    {
      if (v15 < 0x40000)
      {
        v22 = 4 * v15;
LABEL_15:
        if (v22 <= v21)
          v15 = v14 + v19;
        else
          v15 = v22;
        v23 = __CFSafelyReallocateWithAllocatorTyped(&__kCFAllocatorSystemDefault, v16, v15, 3267573040, 0, 0);
        if (!v23)
          __break(1u);
        v16 = (char *)v23;
        goto LABEL_20;
      }
      if (!HIBYTE(v15))
      {
        v22 = 2 * v15;
        goto LABEL_15;
      }
      v22 = v15 + 0x40000;
      if (!__OFADD__(v15, 0x40000))
        goto LABEL_15;
LABEL_23:
      v24 = __CFPropertyListCreateError(3840, CFSTR("Stream too large"));
      v16 = 0;
      if (!v9)
      {
LABEL_32:
        if (v24)
          CFRelease(v24);
        return 0;
      }
LABEL_27:
      if (v16)
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16);
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      CFDictionarySetValue(Mutable, CFSTR("NSDebugDescription"), CFSTR("Property list reading could not be completed because the stream had an unknown error. Did you forget to open the stream?"));
      if (v24)
        CFDictionarySetValue(Mutable, CFSTR("NSUnderlyingError"), v24);
      *v9 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("NSCocoaErrorDomain"), 3842, Mutable);
      CFRelease(Mutable);
      goto LABEL_32;
    }
LABEL_20:
    memmove(&v16[v14], buffer, v20);
    v17 -= v20;
    v14 += v20;
  }
  while (v17 >= 1);
  if (!v16)
  {
LABEL_38:
    if (v16)
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16);
    if (v9)
    {
      v28 = __CFPropertyListCreateError(3840, CFSTR("stream had too few bytes"));
      result = 0;
      *v9 = v28;
      return result;
    }
    return 0;
  }
LABEL_36:
  if (v21 <= 5)
    goto LABEL_38;
  v27 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v16, v21, (CFAllocatorRef)&__kCFAllocatorSystemDefault);
  *(_QWORD *)buffer = 0;
  _CFPropertyListCreateWithData(v29, v27, v30, v9, 1, v31, 0, buffer);
  CFRelease(v27);
  return *(CFPropertyListRef *)buffer;
}

void *__CFSafelyReallocateWithAllocator(malloc_zone_t *a1, malloc_zone_t *a2, uint64_t a3, malloc_type_id_t type_id, uint64_t a5)
{
  unint64_t v5;

  return __CFSafelyReallocateWithAllocatorImpl(a1, a2, a3, (v5 >> 2), type_id, a5);
}

void *__cdecl CFAllocatorReallocate(CFAllocatorRef allocator, void *ptr, CFIndex newsize, CFOptionFlags hint)
{
  unint64_t v4;

  return CFAllocatorReallocateImpl((malloc_zone_t *)allocator, (malloc_zone_t *)ptr, newsize, (v4 >> 2), hint);
}

void *__CFAllocatorSystemReallocate(void *ptr, size_t size, int a3, malloc_zone_t *zone)
{
  if (zone == (malloc_zone_t *)&__MallocDefaultZoneInfoPlaceholder)
    zone = malloc_default_zone();
  return malloc_type_zone_realloc(zone, ptr, size, 0x82F82C52uLL);
}

CFTypeRef CFWriteStreamCopyProperty(CFWriteStreamRef stream, CFStreamPropertyKey propertyName)
{
  CFTypeRef result;
  uint64_t (*v5)(CFWriteStreamRef, CFStreamPropertyKey, _QWORD);

  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
    return (id)-[__CFWriteStream propertyForKey:](stream, "propertyForKey:", propertyName);
  v5 = *(uint64_t (**)(CFWriteStreamRef, CFStreamPropertyKey, _QWORD))(*((_QWORD *)stream + 6) + 96);
  if (!v5)
    return 0;
  *((_QWORD *)stream + 2) |= 0x40uLL;
  result = (CFTypeRef)v5(stream, propertyName, *((_QWORD *)stream + 5));
  *((_QWORD *)stream + 2) &= ~0x40uLL;
  return result;
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  CFAllocatorRef v4;
  uint64_t v8;

  v4 = bytesDeallocator;
  if (!bytesDeallocator)
  {
    v8 = _CFGetTSD(1u);
    if (v8)
      v4 = (CFAllocatorRef)v8;
    else
      v4 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
  }
  return (CFDataRef)__CFDataInit((__objc2_class **)allocator, 0, length, bytes, length, v4);
}

CFDataRef dataCopyProperty(int a1, CFTypeRef cf1, uint64_t *a3)
{
  __objc2_class **v4;
  uint64_t v5;
  CFIndex v6;
  uint64_t v7;
  uint64_t Typed;
  const UInt8 *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;

  if (!CFEqual(cf1, CFSTR("kCFStreamPropertyDataWritten")))
    return 0;
  v4 = (__objc2_class **)a3[2];
  if (v4 == &__kCFAllocatorNull)
    return 0;
  v5 = *a3;
  if (*a3)
  {
    v6 = 0;
    do
    {
      v7 = *(_QWORD *)(v5 + 16);
      v5 = *(_QWORD *)(v5 + 24);
      v6 += v7;
    }
    while (v5);
    if (v6 >= 1)
    {
      Typed = CFAllocatorAllocateTyped(a3[2], v6, 2558180666, 0);
      if (Typed)
      {
        v9 = (const UInt8 *)Typed;
        v10 = *a3;
        if (*a3)
        {
          v11 = (char *)Typed;
          do
          {
            memmove(v11, *(const void **)v10, *(_QWORD *)(v10 + 16));
            v12 = *(_QWORD *)(v10 + 16);
            v10 = *(_QWORD *)(v10 + 24);
            v11 += v12;
          }
          while (v10);
        }
        return CFDataCreateWithBytesNoCopy((CFAllocatorRef)v4, v9, v6, (CFAllocatorRef)v4);
      }
      return 0;
    }
  }
  else
  {
    v6 = 0;
  }
  v9 = 0;
  return CFDataCreateWithBytesNoCopy((CFAllocatorRef)v4, v9, v6, (CFAllocatorRef)v4);
}

void _CFAppendXML0(const __CFString *a1, unsigned int a2, __CFData *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  __CFData *v11;
  __int16 *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t Count;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CFNumberRef v25;
  uint64_t v26;
  __int16 *v27;
  CFAbsoluteTime AbsoluteTime;
  CFGregorianDate GregorianDate;
  uint64_t v30;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v33;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  const UInt8 *v41;
  unint64_t v42;
  unint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  size_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  __int16 *v56;
  __CFData *v57;
  uint64_t v58;
  int IsFloatType;
  const __CFString *v60;
  uint64_t Typed;
  __CFArray *Mutable;
  uint64_t v63;
  const __CFString *v64;
  uint64_t v65;
  uint64_t v66;
  const void *Value;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  size_t v71;
  uint64_t v72;
  CFAllocatorRef v73[2];
  unsigned int v74;
  _QWORD *v75;
  _QWORD valuePtr[12];
  CFRange v77;
  CFRange v78;
  CFRange v79;

  valuePtr[11] = *MEMORY[0x1E0C80C00];
  v6 = CFGetTypeID(a1);
  v7 = a2;
  if (a2)
  {
    v8 = a2;
    do
    {
      if (v8 >= 4)
        v9 = 4;
      else
        v9 = v8;
      _plistAppendCharacters(a3, _appendIndents_tabs, v9);
      v10 = (unint64_t)v8 > 4;
      v8 -= 4;
    }
    while (v10);
  }
  if (v6 == 7)
  {
    CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
    _plistAppendCharacters(a3, L"string", 6);
    CFDataAppendBytes(a3, (const UInt8 *)">", 1);
    _appendEscapedString(a1, a3);
    CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
    v11 = a3;
    v12 = L"string";
    v13 = 6;
LABEL_9:
    _plistAppendCharacters(v11, v12, v13);
    CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
    return;
  }
  if (_CFKeyedArchiverUIDGetTypeID() == v6)
  {
    CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
    _plistAppendCharacters(a3, L"dict", 4);
    CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
    v14 = a2 + 1;
    if (a2 == -1)
    {
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"key", 3);
      CFDataAppendBytes(a3, (const UInt8 *)">", 1);
      _appendEscapedString(CFSTR("CF$UID"), a3);
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
      _plistAppendCharacters(a3, L"key", 3);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
    }
    else
    {
      v22 = a2 + 1;
      do
      {
        if (v22 >= 4)
          v23 = 4;
        else
          v23 = v22;
        _plistAppendCharacters(a3, _appendIndents_tabs, v23);
        v10 = (unint64_t)v22 > 4;
        v22 -= 4;
      }
      while (v10);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"key", 3);
      CFDataAppendBytes(a3, (const UInt8 *)">", 1);
      _appendEscapedString(CFSTR("CF$UID"), a3);
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
      _plistAppendCharacters(a3, L"key", 3);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
      do
      {
        if (v14 >= 4)
          v24 = 4;
        else
          v24 = v14;
        _plistAppendCharacters(a3, _appendIndents_tabs, v24);
        v10 = (unint64_t)v14 > 4;
        v14 -= 4;
      }
      while (v10);
    }
    CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
    _plistAppendCharacters(a3, L"integer", 7);
    CFDataAppendBytes(a3, (const UInt8 *)">", 1);
    valuePtr[0] = _CFKeyedArchiverUIDGetValue((uint64_t)a1);
    v25 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt64Type, valuePtr);
    _plistAppendFormat(a3, CFSTR("%@"), v25);
    CFRelease(v25);
    CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
    _plistAppendCharacters(a3, L"integer", 7);
    CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
    if (a2)
    {
      do
      {
        if (v7 >= 4)
          v26 = 4;
        else
          v26 = v7;
        _plistAppendCharacters(a3, _appendIndents_tabs, v26);
        v10 = (unint64_t)v7 > 4;
        v7 -= 4;
      }
      while (v10);
    }
    CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
    v27 = L"dict";
    goto LABEL_37;
  }
  switch(v6)
  {
    case 18:
      Count = CFDictionaryGetCount((CFDictionaryRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"dict", 4);
      if (!Count)
        goto LABEL_82;
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
      MEMORY[0x1E0C80A78](v16, v17);
      v20 = (char *)v73 - v19;
      if (v18 >= 0x200)
        v21 = 512;
      else
        v21 = v18;
      bzero((char *)v73 - v19, v21);
      v73[1] = (CFAllocatorRef)v73;
      if (Count > 0x100)
      {
        Typed = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * Count, 0xC0040B8AA526DLL, 0);
        if (!Typed)
          _CFAppendXML0_cold_1();
        v20 = (char *)Typed;
      }
      else
      {
        bzero(v20, 8 * Count);
      }
      CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, (const void **)v20, 0);
      v73[0] = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
      Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeArrayCallBacks);
      v77.location = 0;
      v77.length = 0;
      CFArrayReplaceValues(Mutable, v77, (const void **)v20, Count);
      v78.location = 0;
      v78.length = Count;
      CFArraySortValues(Mutable, v78, (CFComparatorFunction)CFStringCompare, 0);
      v79.location = 0;
      v79.length = Count;
      v75 = v20;
      CFArrayGetValues(Mutable, v79, (const void **)v20);
      CFRelease(Mutable);
      v63 = 0;
      v74 = a2;
      do
      {
        v64 = (const __CFString *)v75[v63];
        if (a2 != -1)
        {
          v65 = a2 + 1;
          do
          {
            if (v65 >= 4)
              v66 = 4;
            else
              v66 = v65;
            _plistAppendCharacters(a3, _appendIndents_tabs, v66);
            v10 = (unint64_t)v65 > 4;
            v65 -= 4;
          }
          while (v10);
        }
        CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
        _plistAppendCharacters(a3, L"key", 3);
        CFDataAppendBytes(a3, (const UInt8 *)">", 1);
        _appendEscapedString(v64, a3);
        CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
        _plistAppendCharacters(a3, L"key", 3);
        CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
        Value = CFDictionaryGetValue((CFDictionaryRef)a1, v64);
        _CFAppendXML0(Value, a2 + 1, a3);
        ++v63;
      }
      while (v63 != Count);
      if (Count >= 0x101)
        CFAllocatorDeallocate(v73[0], v75);
      if (v74)
      {
        do
        {
          if (v7 >= 4)
            v68 = 4;
          else
            v68 = v7;
          _plistAppendCharacters(a3, _appendIndents_tabs, v68);
          v10 = (unint64_t)v7 > 4;
          v7 -= 4;
        }
        while (v10);
      }
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
      _plistAppendCharacters(a3, L"dict", 4);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
      return;
    case 19:
      v30 = CFArrayGetCount((CFArrayRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"array", 5);
      if (!v30)
        goto LABEL_82;
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
      for (i = 0; i != v30; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, i);
        _CFAppendXML0(ValueAtIndex, a2 + 1, a3);
      }
      if (a2)
      {
        do
        {
          if (v7 >= 4)
            v33 = 4;
          else
            v33 = v7;
          _plistAppendCharacters(a3, _appendIndents_tabs, v33);
          v10 = (unint64_t)v7 > 4;
          v7 -= 4;
        }
        while (v10);
      }
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
      v12 = L"array";
      v11 = a3;
      v13 = 5;
      goto LABEL_9;
    case 20:
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"data", 4);
      CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
      BytePtr = CFDataGetBytePtr((CFDataRef)a1);
      Length = CFDataGetLength((CFDataRef)a1);
      if (a2 >= 8uLL)
        v36 = 8;
      else
        v36 = a2;
      if (Length < 1)
        goto LABEL_111;
      v37 = Length;
      v74 = a2;
      v38 = 0;
      v39 = 0;
      v75 = (_QWORD *)v36;
      v40 = 76 - 8 * v36;
      break;
    case 21:
      v55 = CFBooleanGetValue((CFBooleanRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      if (v55)
      {
        v56 = L"true";
        v57 = a3;
        v58 = 4;
      }
      else
      {
        v56 = L"false";
        v57 = a3;
        v58 = 5;
      }
      _plistAppendCharacters(v57, v56, v58);
LABEL_82:
      CFDataAppendBytes(a3, (const UInt8 *)"/>\n", 3);
      return;
    case 22:
      IsFloatType = CFNumberIsFloatType((CFNumberRef)a1);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      if (IsFloatType)
      {
        _plistAppendCharacters(a3, L"real", 4);
        CFDataAppendBytes(a3, (const UInt8 *)">", 1);
        v60 = __CFNumberCopyFormattingDescriptionAsFloat64((CFNumberRef)a1);
        _plistAppendString(a3, v60);
        CFRelease(v60);
        CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
        v11 = a3;
        v12 = L"real";
LABEL_79:
        v13 = 4;
      }
      else
      {
        _plistAppendCharacters(a3, L"integer", 7);
        CFDataAppendBytes(a3, (const UInt8 *)">", 1);
        _plistAppendFormat(a3, CFSTR("%@"), a1);
        CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
        v11 = a3;
        v12 = L"integer";
        v13 = 7;
      }
      goto LABEL_9;
    default:
      if (v6 != 42)
        return;
      AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)a1);
      GregorianDate = CFAbsoluteTimeGetGregorianDate(AbsoluteTime, 0);
      CFDataAppendBytes(a3, (const UInt8 *)"<", 1);
      _plistAppendCharacters(a3, L"date", 4);
      CFDataAppendBytes(a3, (const UInt8 *)">", 1);
      _plistAppendFormat(a3, CFSTR("%04d-%02d-%02dT%02d:%02d:%02dZ"), *(_QWORD *)&GregorianDate.year, ((int)(*(_QWORD *)&GregorianDate.year >> 8) >> 24), ((int)(*(_QWORD *)&GregorianDate.year >> 16) >> 24), ((int)(*(_QWORD *)&GregorianDate.year >> 24) >> 24), (*(int *)&GregorianDate.month >> 24), (int)GregorianDate.second);
      CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
      v11 = a3;
      v12 = L"date";
      goto LABEL_79;
  }
  do
  {
    v41 = BytePtr;
    v42 = v39 % 3;
    if (v39 % 3 == 2)
    {
      v44 = *BytePtr;
      v45 = v38 + 1;
      *((_BYTE *)valuePtr + v38) = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[((unint64_t)(v44 | (*(BytePtr - 1) << 8)) >> 6) & 0x3F];
      v43 = v44 & 0x3F;
      v46 = 2;
    }
    else
    {
      if (v42 == 1)
      {
        v43 = ((unint64_t)(*BytePtr | (*(BytePtr - 1) << 8)) >> 4) & 0x3F;
      }
      else
      {
        if (v42)
          goto LABEL_63;
        v43 = (unint64_t)*BytePtr >> 2;
      }
      v46 = 1;
      v45 = v38;
    }
    v38 += v46;
    *((_BYTE *)valuePtr + v45) = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[v43];
LABEL_63:
    if (v38 >= v40)
    {
      *(_WORD *)((char *)valuePtr + v38) = 10;
      if (v74)
      {
        v47 = (uint64_t)v75;
        do
        {
          if (v47 >= 4)
            v48 = 4;
          else
            v48 = v47;
          _plistAppendCharacters(a3, _appendIndents_tabs, v48);
          v10 = (unint64_t)v47 > 4;
          v47 -= 4;
        }
        while (v10);
      }
      v49 = strlen((const char *)valuePtr);
      CFDataAppendBytes(a3, (const UInt8 *)valuePtr, v49);
      v38 = 0;
    }
    ++v39;
    BytePtr = v41 + 1;
  }
  while (v39 != v37);
  if (v37 % 3 == 2)
  {
    v52 = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[4 * (*v41 & 0xF)];
    v53 = 2;
    v54 = 1;
    v51 = v38;
    a2 = v74;
    v50 = (uint64_t)v75;
LABEL_103:
    v69 = v54 + v38;
    *((_BYTE *)valuePtr + v51) = v52;
    v38 += v53;
    *((_BYTE *)valuePtr + v69) = 61;
  }
  else
  {
    a2 = v74;
    v50 = (uint64_t)v75;
    if (v37 % 3 == 1)
    {
      v51 = v38 + 1;
      *((_BYTE *)valuePtr + v38) = _XMLPlistAppendDataUsingBase64___CFPLDataEncodeTable[16 * (*v41 & 3)];
      v52 = 61;
      v53 = 3;
      v54 = 2;
      goto LABEL_103;
    }
  }
  if (v38 >= 1)
  {
    *(_WORD *)((char *)valuePtr + v38) = 10;
    if (a2)
    {
      do
      {
        if (v50 >= 4)
          v70 = 4;
        else
          v70 = v50;
        _plistAppendCharacters(a3, _appendIndents_tabs, v70);
        v10 = (unint64_t)v50 > 4;
        v50 -= 4;
      }
      while (v10);
    }
    v71 = strlen((const char *)valuePtr);
    CFDataAppendBytes(a3, (const UInt8 *)valuePtr, v71);
  }
LABEL_111:
  if (a2)
  {
    do
    {
      if (v7 >= 4)
        v72 = 4;
      else
        v72 = v7;
      _plistAppendCharacters(a3, _appendIndents_tabs, v72);
      v10 = (unint64_t)v7 > 4;
      v7 -= 4;
    }
    while (v10);
  }
  CFDataAppendBytes(a3, (const UInt8 *)"</", 2);
  v27 = L"data";
LABEL_37:
  _plistAppendCharacters(a3, v27, 4);
  CFDataAppendBytes(a3, (const UInt8 *)">\n", 2);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
  CFRange v6;

  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    -[__CFData appendBytes:length:](theData, "appendBytes:length:", bytes, length);
  }
  else
  {
    v6.location = *((_QWORD *)theData + 2);
    v6.length = 0;
    CFDataReplaceBytes(theData, v6, bytes, length);
  }
}

unint64_t *__CFDataInit(__objc2_class **a1, char a2, unint64_t a3, const UInt8 *a4, CFIndex a5, const void *a6)
{
  const void *v6;
  __objc2_class **v11;
  _BOOL4 v12;
  uint64_t v13;
  BOOL ShouldUseAllocator;
  uint64_t v15;
  unint64_t *Instance;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  char v28;
  unint64_t v29;
  unint64_t v30;
  int v31;
  unint64_t v32;
  unint64_t v33;
  int v34;
  char *v35;
  char *v36;
  void *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  int v42;
  unint64_t v43;
  int v44;
  unint64_t v45;
  unint64_t v46;
  int v47;
  CFRange v49;

  v6 = a6;
  v11 = a1;
  v12 = 0;
  if ((a2 & 2) == 0 && !a6)
    v12 = 4 * *MEMORY[0x1E0C85AD8] - 63 > a3;
  if (!a1)
  {
    v13 = _CFGetTSD(1u);
    if (v13)
      v11 = (__objc2_class **)v13;
    else
      v11 = &__kCFAllocatorSystemDefault;
  }
  ShouldUseAllocator = __CFDataShouldUseAllocator(v11);
  if (v12)
    v15 = a3 + 47;
  else
    v15 = 32;
  Instance = (unint64_t *)_CFRuntimeCreateInstance(v11, 0x14uLL, v15, 0);
  v17 = Instance;
  if (!Instance)
    return v17;
  Instance[2] = 0;
  v18 = Instance + 1;
  v19 = atomic_load(Instance + 1);
  v20 = 4;
  if (!v12)
    v20 = 0;
  do
  {
    v21 = __ldaxr(v18);
    if (v21 == v19)
    {
      if (!__stlxr(v19 & 0xFFFFFFFFFFFFFFFBLL | v20, v18))
      {
        v22 = 1;
        goto LABEL_19;
      }
    }
    else
    {
      __clrex();
    }
    v22 = 0;
LABEL_19:
    v19 = v21;
  }
  while (!v22);
  v23 = atomic_load(v18);
  do
  {
    v24 = __ldaxr(v18);
    if (v24 == v23)
    {
      if (!__stlxr(v23 & 0xFFFFFFFFFFFFFFF7 | (8 * (ShouldUseAllocator & 0x1F)), v18))
      {
        v25 = 1;
        goto LABEL_26;
      }
    }
    else
    {
      __clrex();
    }
    v25 = 0;
LABEL_26:
    v23 = v24;
  }
  while (!v25);
  if ((a2 & 1) != 0 && (a2 & 2) != 0)
  {
    Instance[3] = 16;
    v26 = atomic_load(Instance + 1);
    while (1)
    {
      v27 = __ldaxr(v18);
      if (v27 != v26)
        break;
      if (__stlxr(v26 | 3, v18))
        goto LABEL_34;
      v28 = 1;
LABEL_35:
      v26 = v27;
      if ((v28 & 1) != 0)
        goto LABEL_44;
    }
    __clrex();
LABEL_34:
    v28 = 0;
    goto LABEL_35;
  }
  Instance[3] = a3;
  v29 = atomic_load(Instance + 1);
  while (2)
  {
    v30 = __ldaxr(v18);
    if (v30 == v29)
    {
      if (!__stlxr(v29 & 0xFFFFFFFFFFFFFFFCLL | 1, v18))
      {
        v31 = 1;
        goto LABEL_43;
      }
    }
    else
    {
      __clrex();
    }
    v31 = 0;
LABEL_43:
    v29 = v30;
    if (!v31)
      continue;
    break;
  }
LABEL_44:
  if (!v6)
  {
    if ((a2 & 1) != 0 && (a2 & 2) == 0)
      LODWORD(v6) = _CFExecutableLinkedOnOrAfter(6uLL) == 0;
    if (v12)
    {
      if ((a2 & 1) != 0 || a5)
        goto LABEL_84;
      v17[5] = 0;
      v32 = atomic_load(v17 + 1);
      while (1)
      {
        v33 = __ldaxr(v18);
        if (v33 != v32)
          break;
        if (__stlxr(v32 & 0xFFFFFFFFFFFFFFFBLL, v18))
          goto LABEL_58;
        v34 = 1;
LABEL_59:
        v32 = v33;
        if (v34)
        {
          if ((__CFDataInit_didCheck & 1) == 0)
          {
            v35 = (char *)_CFProcessPath();
            if (v35)
            {
              v36 = strrchr(v35, 47);
              if (!v36)
                goto LABEL_75;
            }
            else
            {
              v36 = "";
            }
            if (!strcmp(v36, "/Remote") && _CFAppVersionCheckLessThan(CFSTR("com.apple.Remote"), -1, 2.1))
              __CFDataInit_setToNull = 1;
LABEL_75:
            __CFDataInit_didCheck = 1;
          }
          if (__CFDataInit_setToNull == 1)
          {
            v17[5] = ((unint64_t)v17 + 63) & 0xFFFFFFFFFFFFFFF0;
            v40 = atomic_load(v17 + 1);
            while (1)
            {
              v41 = __ldaxr(v18);
              if (v41 != v40)
                break;
              if (__stlxr(v40 | 4, v18))
                goto LABEL_82;
              v42 = 1;
LABEL_83:
              v40 = v41;
              if (v42)
                goto LABEL_84;
            }
            __clrex();
LABEL_82:
            v42 = 0;
            goto LABEL_83;
          }
LABEL_84:
          v39 = 0;
          v38 = atomic_load(v18);
          goto LABEL_85;
        }
      }
      __clrex();
LABEL_58:
      v34 = 0;
      goto LABEL_59;
    }
    v37 = __CFDataAllocate((uint64_t)v17, v17[3], (int)v6);
    v17[5] = (unint64_t)v37;
    if (__CFOASafe)
    {
      __CFSetLastAllocationEventName();
      v37 = (void *)v17[5];
    }
    if (!v37)
    {
      CFRelease(v17);
      return 0;
    }
    v38 = atomic_load(v18);
    v39 = 64;
    if ((_DWORD)v6)
      v39 = 0;
LABEL_85:
    while (1)
    {
      v43 = __ldaxr(v18);
      if (v43 != v38)
        break;
      if (__stlxr(v38 & 0xFFFFFFFFFFFFFFBFLL | v39, v18))
        goto LABEL_89;
      v44 = 1;
LABEL_90:
      v38 = v43;
      if (v44)
      {
        v17[4] = 0;
        v49.location = 0;
        v49.length = 0;
        CFDataReplaceBytes((CFMutableDataRef)v17, v49, a4, a5);
        if ((a2 & 1) != 0)
          return v17;
LABEL_92:
        v45 = atomic_load(v18);
        while (2)
        {
          v46 = __ldaxr(v18);
          if (v46 == v45)
          {
            if (!__stlxr(v45 & 0xFFFFFFFFFFFFFFFCLL, v18))
            {
              v47 = 1;
              goto LABEL_98;
            }
          }
          else
          {
            __clrex();
          }
          v47 = 0;
LABEL_98:
          v45 = v46;
          if (v47)
            return v17;
          continue;
        }
      }
    }
    __clrex();
LABEL_89:
    v44 = 0;
    goto LABEL_90;
  }
  Instance[5] = (unint64_t)a4;
  Instance[4] = (unint64_t)CFRetain(v6);
  v17[2] = a5;
  if ((a2 & 1) == 0)
    goto LABEL_92;
  return v17;
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
  CFIndex length;
  CFIndex location;
  uint64_t v8;
  CFIndex v9;
  CFIndex v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  CFIndex v25;
  char v26;
  unint64_t v27;
  char v28;
  int v29;
  UInt8 *v30;
  UInt8 *v31;
  char v32;
  BOOL v33;
  int v34;
  int64_t v35;
  NSObject *v36;

  length = range.length;
  location = range.location;
  v8 = (uint64_t)theData;
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    objc_msgSend((id)v8, "replaceBytesInRange:withBytes:length:", location, length, newBytes, newLength);
    return;
  }
  v9 = *(_QWORD *)(v8 + 16);
  v10 = *(_QWORD *)(v8 + 24);
  if (location < 0)
  {
    v14 = dyld_program_sdk_at_least();
    if ((_DWORD)v14)
      CFDataReplaceBytes_cold_11(v14, v15, v16);
    v23 = _CFOSLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
      CFDataReplaceBytes_cold_12();
  }
  else
  {
    if (location <= v9)
    {
      if (length < 0)
      {
        v20 = dyld_program_sdk_at_least();
        if ((_DWORD)v20)
          CFDataReplaceBytes_cold_9(v20, v21, v22);
        v8 = _CFOSLog();
        if (os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_FAULT))
          CFDataReplaceBytes_cold_10();
        goto LABEL_59;
      }
      if (location + length > v9)
      {
        v17 = dyld_program_sdk_at_least();
        if ((_DWORD)v17)
          CFDataReplaceBytes_cold_7(v17, v18, v19);
        v36 = _CFOSLog();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
          CFDataReplaceBytes_cold_8();
      }
      goto LABEL_19;
    }
    v11 = dyld_program_sdk_at_least();
    if ((_DWORD)v11)
      CFDataReplaceBytes_cold_1(v11, v12, v13);
    v24 = _CFOSLog();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
      goto LABEL_60;
  }
  while (length < 0)
  {
LABEL_59:
    qword_1EDCD1038 = (uint64_t)"Negative range.length passed to CFDataReplaceBytes";
    __break(1u);
LABEL_60:
    CFDataReplaceBytes_cold_6();
  }
LABEL_19:
  if (newLength < 0)
    CFDataReplaceBytes_cold_2();
  v25 = v9 - length + newLength;
  if (v25 < 0)
    CFDataReplaceBytes_cold_3();
  if (!newBytes && newLength)
    CFDataReplaceBytes_cold_4();
  v26 = atomic_load((unint64_t *)(v8 + 8));
  if ((v26 & 4) != 0)
    v27 = (v8 + 63) & 0xFFFFFFFFFFFFFFF0;
  else
    v27 = *(_QWORD *)(v8 + 40);
  v28 = atomic_load((unint64_t *)(v8 + 8));
  v29 = v28 & 3;
  if (v29 == 1)
  {
    v30 = (UInt8 *)newBytes;
    if (v25 > v10)
      CFDataReplaceBytes_cold_5();
  }
  else if (v29 == 3 && v10 < v25)
  {
    v30 = (UInt8 *)newBytes;
    if (newLength)
    {
      v30 = (UInt8 *)newBytes;
      if (newBytes)
      {
        v30 = (UInt8 *)newBytes;
        if (v27)
        {
          v30 = (UInt8 *)newBytes;
          if (v27 + v10 > (unint64_t)newBytes)
          {
            v31 = (UInt8 *)malloc_type_malloc(newLength, 0x65CD2194uLL);
            if (!v31)
              __CFDataHandleOutOfMemory(newLength);
            v30 = v31;
            memmove(v31, newBytes, newLength);
          }
        }
      }
    }
    __CFDataGrow((unint64_t *)v8, newLength - length, 0);
    v32 = atomic_load((unint64_t *)(v8 + 8));
    if ((v32 & 4) != 0)
      v27 = (v8 + 63) & 0xFFFFFFFFFFFFFFF0;
    else
      v27 = *(_QWORD *)(v8 + 40);
  }
  else
  {
    v30 = (UInt8 *)newBytes;
  }
  if (newLength)
    v33 = v30 == 0;
  else
    v33 = 1;
  v34 = !v33;
  if (length != newLength)
  {
    v35 = v9 - (location + length);
    if (v35 >= 1)
      memmove((void *)(v27 + location + newLength), (const void *)(v27 + location + length), v35);
  }
  if (v34)
    memmove((void *)(v27 + location), v30, newLength);
  if (v30 != newBytes)
    free(v30);
  *(_QWORD *)(v8 + 16) = v25;
}

BOOL __CFDataShouldUseAllocator(__objc2_class **a1)
{
  if (!a1)
  {
    a1 = (__objc2_class **)_CFGetTSD(1u);
    if (!a1)
      a1 = &__kCFAllocatorSystemDefault;
  }
  return a1 != &__kCFAllocatorSystemDefault && a1 != &__kCFAllocatorMalloc && a1 != &__kCFAllocatorMallocZone;
}

void _plistAppendCharacters(CFMutableDataRef theData, _WORD *a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  _WORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  UInt8 v12;
  uint64_t v13;
  unsigned int v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFData *ExternalRepresentation;
  const __CFData *v18;
  const UInt8 *BytePtr;
  CFIndex Length;
  UInt8 bytes[400];
  uint64_t v22;

  v6 = 0;
  v22 = *MEMORY[0x1E0C80C00];
  v7 = a3 - 1;
  v8 = a2 + 1;
  while (1)
  {
    v9 = 0;
    v10 = 0;
    if (a3 >= 1 && v6 >= -399)
    {
      v11 = v6 + 399;
      if (v7 < v6 + 399)
        v11 = v7;
      if ((unsigned __int16)*a2 > 0x7Fu)
      {
        v9 = 0;
        v10 = 0;
      }
      else
      {
        v9 = 0;
        v12 = *a2;
        while (1)
        {
          v13 = v9;
          bytes[v9] = v12;
          if (v11 == v9)
            break;
          v14 = (unsigned __int16)v8[v9];
          v12 = v8[v9++];
          if (v14 > 0x7F)
            goto LABEL_13;
        }
        v9 = v11 + 1;
LABEL_13:
        v10 = v13 + 1;
      }
    }
    if (v9 > v6)
    {
      CFDataAppendBytes(theData, bytes, v10 - v6);
      v6 = v9;
    }
    if (a3 <= v6)
      break;
    if ((unsigned __int16)a2[v6] >= 0x80u)
    {
      v15 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, &a2[v6], a3 - v6, (CFAllocatorRef)&__kCFAllocatorNull);
      if (v15)
      {
        v16 = v15;
        ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, 0x8000100u, 0);
        if (ExternalRepresentation)
        {
          v18 = ExternalRepresentation;
          BytePtr = CFDataGetBytePtr(ExternalRepresentation);
          Length = CFDataGetLength(v18);
          CFDataAppendBytes(theData, BytePtr, Length);
          CFRelease(v18);
        }
        CFRelease(v16);
      }
      return;
    }
  }
}

void __CFDataGrow(unint64_t *cf, int64_t a2, int a3)
{
  int64_t v3;
  unint64_t v4;
  uint64_t v8;
  char v9;
  char v10;
  CFAllocatorRef v11;
  const void *v12;
  char v13;
  char v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  int v23;

  v3 = cf[2];
  v4 = v3 + a2;
  if ((unint64_t)(v3 + a2) >> 42)
    __CFDataHandleOutOfMemory(v3 + a2);
  if (v4 >= 0x10)
  {
    if (v4 >> 20)
    {
      if (HIDWORD(v4))
      {
        v10 = flsl(0x20000000);
        if ((v4 >> (v10 - 1) << 29) + 0x20000000 >= 0x3FFFFFFFFFFLL)
          v8 = 0x3FFFFFFFFFFLL;
        else
          v8 = (v4 >> (v10 - 1) << 29) + 0x20000000;
      }
      else
      {
        v8 = 1 << flsl(v3 + a2);
      }
    }
    else
    {
      v9 = flsl(v3 + a2);
      v8 = 1 << ((v9 & 1u) + v9);
    }
  }
  else
  {
    v8 = 16;
  }
  v11 = CFGetAllocator(cf);
  v12 = (const void *)cf[5];
  if (!a3
    || (v13 = atomic_load(cf + 1), v8 <= 0x20000)
    || (v13 & 8) != 0
    || (v14 = atomic_load(cf + 1), (v14 & 8) != 0)
    || v3 && (uint64_t)v4 / v3 < 5
    || (v15 = __CFDataAllocate((uint64_t)cf, v8, 1)) == 0)
  {
    v18 = atomic_load(cf + 1);
    if ((v18 & 8) != 0)
      v19 = __CFSafelyReallocateWithAllocatorTyped(v11, v12, v8, 0x100004077774924, 0, 0);
    else
      v19 = __CFSafelyReallocateTyped(v12, v8, 0x100004077774924, 0);
    v16 = v19;
    if (!v19)
      __CFDataHandleOutOfMemory(v8);
    v17 = 64;
    if (a3 && a2 >= 1)
    {
      bzero((void *)(v19 + v3), a2);
      v17 = 64;
    }
  }
  else
  {
    v16 = (uint64_t)v15;
    memmove(v15, v12, v3);
    __CFDataDeallocate((uint64_t)cf);
    v17 = 0;
  }
  cf[3] = v8;
  v20 = cf + 1;
  v21 = atomic_load(cf + 1);
  do
  {
    v22 = __ldaxr(v20);
    if (v22 == v21)
    {
      if (!__stlxr(v21 & 0xFFFFFFFFFFFFFFBFLL | v17, v20))
      {
        v23 = 1;
        goto LABEL_32;
      }
    }
    else
    {
      __clrex();
    }
    v23 = 0;
LABEL_32:
    v21 = v22;
  }
  while (!v23);
  cf[5] = v16;
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
}

void __CFDataDeallocate(uint64_t a1)
{
  char v1;
  char v2;
  const void *v4;
  _QWORD *v5;
  char v6;
  void *v7;
  CFAllocatorRef *v8;
  char v9;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((v1 & 4) == 0)
  {
    v2 = atomic_load((unint64_t *)(a1 + 8));
    if ((v2 & 0x10) == 0)
    {
      v4 = *(const void **)(a1 + 32);
      if (v4)
      {
        v5 = (_QWORD *)(a1 + 40);
        CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 32), *(void **)(a1 + 40));
        CFRelease(v4);
      }
      else
      {
        v6 = atomic_load((unint64_t *)(a1 + 8));
        if ((v6 & 8) != 0)
        {
          if (a1 < 0)
          {
            v8 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
          }
          else
          {
            v9 = atomic_load((unint64_t *)(a1 + 8));
            if (v9 < 0)
              v8 = (CFAllocatorRef *)&kCFAllocatorSystemDefault;
            else
              v8 = (CFAllocatorRef *)(a1 - 16);
          }
          CFAllocatorDeallocate(*v8, *(void **)(a1 + 40));
        }
        else
        {
          v7 = *(void **)(a1 + 40);
          if (v7)
            free(v7);
        }
        v5 = (_QWORD *)(a1 + 40);
      }
      *v5 = 0;
    }
  }
}

void *__CFSafelyReallocate(void *a1, size_t a2, uint64_t a3)
{
  unint64_t v3;

  return __CFSafelyReallocateImpl(a1, a2, (v3 >> 2), a3);
}

void *__CFDataAllocate(uint64_t a1, size_t size, int a3)
{
  char v5;
  const CFAllocatorRef *v7;
  char v8;
  void *Typed;
  void *v10;

  v5 = atomic_load((unint64_t *)(a1 + 8));
  if ((v5 & 8) != 0)
  {
    if (a1 < 0)
    {
      v7 = &kCFAllocatorSystemDefault;
    }
    else
    {
      v8 = atomic_load((unint64_t *)(a1 + 8));
      if (v8 < 0)
        v7 = &kCFAllocatorSystemDefault;
      else
        v7 = (const CFAllocatorRef *)(a1 - 16);
    }
    Typed = (void *)CFAllocatorAllocateTyped(*v7, size, 2869208503, 0);
    v10 = Typed;
    if (a3)
      bzero(Typed, size);
    return v10;
  }
  else if (a3)
  {
    return malloc_type_calloc(1uLL, size, 0xB552CF23uLL);
  }
  else
  {
    return malloc_type_malloc(size, 0x4400A1E1uLL);
  }
}

void _appendEscapedString(const __CFString *a1, __CFData *a2)
{
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  UniChar v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFIndex v19;
  __CFData *v20;
  const char *v21;
  CFIndex v22;
  _OWORD v23[8];
  CFStringRef theString;
  const UniChar *v25;
  const char *v26;
  uint64_t v27;
  CFIndex v28;
  uint64_t v29;
  uint64_t v30;
  _WORD v31[64];
  uint64_t v32;
  CFRange v33;

  v32 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  theString = a1;
  v27 = 0;
  v28 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v25 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v29 = 0;
  v30 = 0;
  v26 = CStringPtr;
  if (Length >= 1)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 64;
    memset(v23, 0, sizeof(v23));
    while (1)
    {
      v11 = (unint64_t)v8 >= 4 ? 4 : v8;
      if (v25)
      {
        v12 = v25[v8 + v27];
      }
      else if (v26)
      {
        v12 = v26[v27 + v8];
      }
      else
      {
        v13 = v29;
        if (v30 <= v8 || v29 > v8)
        {
          v15 = -v11;
          v16 = v11 + v7;
          v17 = v10 - v11;
          v18 = v8 + v15;
          v19 = v18 + 64;
          if (v18 + 64 >= v28)
            v19 = v28;
          v29 = v18;
          v30 = v19;
          if (v28 < v17)
            v17 = v28;
          v33.length = v17 + v16;
          v33.location = v18 + v27;
          CFStringGetCharacters(theString, v33, (UniChar *)v23);
          v13 = v29;
        }
        v12 = *((_WORD *)v23 + v8 - v13);
      }
      if (v9 >= 62 && (v12 & 0xFC00) == 0xD800)
      {
        _plistAppendCharacters(a2, v31, v9);
        v9 = 0;
      }
      if (v12 == 38)
        break;
      if (v12 == 62)
      {
        if (v9)
          _plistAppendCharacters(a2, v31, v9);
        v20 = a2;
        v21 = "&gt;";
LABEL_34:
        v22 = 4;
LABEL_38:
        CFDataAppendBytes(v20, (const UInt8 *)v21, v22);
        goto LABEL_39;
      }
      if (v12 == 60)
      {
        if (v9)
          _plistAppendCharacters(a2, v31, v9);
        v20 = a2;
        v21 = "&lt;";
        goto LABEL_34;
      }
      v31[v9++] = v12;
      if (v9 != 64)
        goto LABEL_40;
      _plistAppendCharacters(a2, v31, 64);
LABEL_39:
      v9 = 0;
LABEL_40:
      ++v8;
      --v7;
      ++v10;
      if (Length == v8)
      {
        if (v9)
          _plistAppendCharacters(a2, v31, v9);
        return;
      }
    }
    if (v9)
      _plistAppendCharacters(a2, v31, v9);
    v20 = a2;
    v21 = "&amp;";
    v22 = 5;
    goto LABEL_38;
  }
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t Status;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFIndex v11;
  _OWORD *Typed;
  CFAllocatorRef v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFRunLoopSource *v17;
  uint64_t v18;
  uint64_t v19;
  __CFRunLoopSource *v20;
  __int128 v21;
  char v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
    return -[__CFReadStream read:maxLength:](stream, "read:maxLength:", buffer, bufferLength);
  Status = _CFStreamGetStatus((uint64_t)stream);
  v8 = *((_QWORD *)stream + 6);
  if (Status == 1)
  {
    *((_QWORD *)stream + 2) |= 0x40uLL;
    waitForOpen((uint64_t)stream);
    *((_QWORD *)stream + 2) &= ~0x40uLL;
    Status = _CFStreamGetStatus((uint64_t)stream);
  }
  if ((unint64_t)(Status - 2) >= 2)
  {
    if (Status == 5)
      return 0;
    else
      return -1;
  }
  else
  {
    v22 = 0;
    v9 = *((_QWORD *)stream + 2);
    *((_QWORD *)stream + 2) = v9 | 0x40;
    v10 = *((_QWORD *)stream + 4);
    if (v10)
      *(_QWORD *)(v10 + 72) &= ~2uLL;
    if ((v9 & 0x1E) != 6)
      *((_QWORD *)stream + 2) = v9 & 0xFFFFFFA0 | 0x43;
    if (*(uint64_t *)v8 > 1)
    {
      v11 = (*(uint64_t (**)(CFReadStreamRef, UInt8 *, CFIndex, char *, char *, _QWORD))(v8 + 48))(stream, buffer, bufferLength, (char *)stream + 24, &v22, *((_QWORD *)stream + 5));
    }
    else
    {
      v21 = 0uLL;
      v11 = (*(uint64_t (**)(CFReadStreamRef, UInt8 *, CFIndex, __int128 *, char *, _QWORD))(v8 + 48))(stream, buffer, bufferLength, &v21, &v22, *((_QWORD *)stream + 5));
      if (DWORD2(v21))
      {
        Typed = (_OWORD *)*((_QWORD *)stream + 3);
        if (!Typed)
        {
          v13 = CFGetAllocator(stream);
          Typed = (_OWORD *)CFAllocatorAllocateTyped(v13, 16, 0x1000040D9A13B51, 0);
          *((_QWORD *)stream + 3) = Typed;
        }
        *Typed = v21;
      }
    }
    if (*((_QWORD *)stream + 3))
    {
      v14 = *((_QWORD *)stream + 2);
      if ((v14 & 0x1F) != 7)
        *((_QWORD *)stream + 2) = v14 & 0xFFFFFFE0 | 7;
      v15 = *((_QWORD *)stream + 4);
      if (v15 && (*(_BYTE *)(v15 + 48) & 8) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
        v16 = *((_QWORD *)stream + 4);
        if (v16 && (v17 = *(__CFRunLoopSource **)(v16 + 56)) != 0)
        {
          CFRetain(*(CFTypeRef *)(v16 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          *(_QWORD *)(*((_QWORD *)stream + 4) + 72) |= 8uLL;
          CFRunLoopSourceSignal(v17);
          CFRelease(v17);
          _wakeUpRunLoop((uint64_t)stream);
        }
        else
        {
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        }
      }
      v11 = -1;
    }
    else if (v22)
    {
      if ((*((_QWORD *)stream + 2) & 0x1ELL) != 6)
        *((_QWORD *)stream + 2) = *((_QWORD *)stream + 2) & 0xFFFFFFE0 | 5;
      v18 = *((_QWORD *)stream + 4);
      if (v18 && (*(_BYTE *)(v18 + 48) & 0x10) != 0)
      {
        pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
        v19 = *((_QWORD *)stream + 4);
        if (v19 && (v20 = *(__CFRunLoopSource **)(v19 + 56)) != 0)
        {
          CFRetain(*(CFTypeRef *)(v19 + 56));
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
          *(_QWORD *)(*((_QWORD *)stream + 4) + 72) |= 0x10uLL;
          CFRunLoopSourceSignal(v20);
          CFRelease(v20);
          _wakeUpRunLoop((uint64_t)stream);
        }
        else
        {
          pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        }
      }
    }
    else if ((*((_QWORD *)stream + 2) & 0x1ELL) != 6)
    {
      *((_QWORD *)stream + 2) = *((_QWORD *)stream + 2) & 0xFFFFFFE0 | 2;
    }
    *((_QWORD *)stream + 2) &= ~0x40uLL;
  }
  return v11;
}

uint64_t dataRead(char *a1, void *a2, uint64_t a3, uint64_t a4, BOOL *a5, uint64_t a6)
{
  const UInt8 *BytePtr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const UInt8 *v18;
  const UInt8 *v19;
  uint64_t v20;
  uint64_t v21;

  BytePtr = CFDataGetBytePtr(*(CFDataRef *)a6);
  v18 = &BytePtr[CFDataGetLength(*(CFDataRef *)a6)];
  v19 = *(const UInt8 **)(a6 + 8);
  v20 = v18 - v19;
  if (v18 - v19 >= a3)
    v20 = a3;
  v21 = v20 & ~(v20 >> 63);
  if (v20 >= 1)
  {
    memmove(a2, v19, v20 & ~(v20 >> 63));
    v19 = (const UInt8 *)(*(_QWORD *)(a6 + 8) + v21);
    *(_QWORD *)(a6 + 8) = v19;
  }
  *(_DWORD *)(a4 + 8) = 0;
  *a5 = v19 >= v18;
  if (*(_BYTE *)(a6 + 16) && v19 < v18)
    CFReadStreamSignalEvent(a1, 2uLL, 0, v13, v14, v15, v16, v17);
  return v21;
}

uint64_t readDataCreate(const void *a1, CFTypeRef *a2)
{
  CFAllocatorRef v3;
  uint64_t Typed;
  const __CFData *v5;

  v3 = CFGetAllocator(a1);
  Typed = CFAllocatorAllocateTyped(v3, 24, 0x107004054E2031FLL, 0);
  if (Typed)
  {
    v5 = (const __CFData *)CFRetain(*a2);
    *(_QWORD *)Typed = v5;
    *(_QWORD *)(Typed + 8) = CFDataGetBytePtr(v5);
    *(_BYTE *)(Typed + 16) = 0;
  }
  return Typed;
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
  uint64_t length;
  CFIndex location;
  char isKindOfClass;
  char v10;
  const CFArrayCallBacks *v11;
  CFArrayReleaseCallBack release;
  CFArrayRetainCallBack retain;
  void **Typed;
  unsigned int v15;
  int v16;
  char v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v24[2];
  void *values[2];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  CFRange v58;
  CFRange v59;

  length = range.length;
  location = range.location;
  v57 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    objc_opt_class();
    isKindOfClass = objc_opt_isKindOfClass();
  }
  else
  {
    v10 = atomic_load((unint64_t *)theArray + 1);
    isKindOfClass = (v10 & 3) != 0;
  }
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
    goto LABEL_5;
  v15 = atomic_load((unint64_t *)theArray + 1);
  v16 = (v15 >> 2) & 3;
  if (v16)
  {
    if (v16 == 1)
    {
LABEL_5:
      v11 = &kCFTypeArrayCallBacks;
      goto LABEL_6;
    }
    v17 = atomic_load((unint64_t *)theArray + 1);
    v18 = v17 & 3;
    if (v18 != 2 && v18)
      v11 = 0;
    else
      v11 = (const CFArrayCallBacks *)((char *)theArray + 48);
  }
  else
  {
    v11 = (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  }
LABEL_6:
  if ((isKindOfClass & 1) == 0)
    goto LABEL_9;
  retain = v11->retain;
  release = v11->release;
  if (retain)
  {
    if (release)
      goto LABEL_9;
  }
  else if (!release)
  {
LABEL_9:
    if (length >= 2)
    {
      v55 = 0u;
      v56 = 0u;
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      v49 = 0u;
      v50 = 0u;
      v47 = 0u;
      v48 = 0u;
      v45 = 0u;
      v46 = 0u;
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      v39 = 0u;
      v40 = 0u;
      v37 = 0u;
      v38 = 0u;
      v35 = 0u;
      v36 = 0u;
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      v29 = 0u;
      v30 = 0u;
      v27 = 0u;
      v28 = 0u;
      *(_OWORD *)values = 0u;
      v26 = 0u;
      if ((unint64_t)length >= 0x101)
        Typed = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * length, 0x80040B8603338, 0);
      else
        Typed = values;
      v58.location = location;
      v58.length = length;
      CFArrayGetValues(theArray, v58, (const void **)Typed);
      v24[0] = comparator;
      v24[1] = context;
      CFQSortArray(Typed, length, 8, (uint64_t)__CFArrayCompareValues, (uint64_t)v24, v19, v20, v21);
      if ((isKindOfClass & 1) != 0)
      {
        v59.location = location;
        v59.length = length;
        CFArrayReplaceValues(theArray, v59, (const void **)Typed, length);
      }
      if (Typed != values)
        CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    }
    return;
  }
  if (length >= 2)
  {
    do
    {
      if (location < location - 1 + length)
      {
        v22 = 0;
        do
        {
          if (((uint64_t (*)(uint64_t, uint64_t, void *))comparator)(-[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location + v22 + 1), -[__CFArray objectAtIndex:](theArray, "objectAtIndex:", location + v22), context) < 0)CFArrayExchangeValuesAtIndices(theArray, location + v22, location + v22 + 1);
          ++v22;
        }
        while (length - 1 != v22);
      }
    }
    while (length-- > 2);
  }
}

void CFArrayReplaceValues(CFMutableArrayRef theArray, CFRange range, const void **newValues, CFIndex newCount)
{
  CFIndex length;
  CFIndex location;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
    -[__CFArray replaceObjectsInRange:withObjects:count:](theArray, "replaceObjectsInRange:withObjects:count:", location, length, newValues, newCount);
  else
    _CFArrayReplaceValues((unint64_t)theArray, location, length, newValues, newCount);
}

void CFQSortArray(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  unint64_t v36;
  uint64_t v37;
  char *v38;
  _QWORD *v39;
  const char *v40;
  uint64_t v41;
  _QWORD v42[9];

  v42[8] = *MEMORY[0x1E0C80C00];
  if (a2 < 2 || a3 < 1)
    return;
  if ((unsigned __int128)(a2 * (__int128)a3) >> 64 != (a2 * a3) >> 63)
  {
    v17 = CFLog(3, (uint64_t)CFSTR("Unable to qsort array - count: %ld elementSize: %ld product overflows"), a3, a4, a5, a6, a7, a8, a2);
    v39 = (_QWORD *)&unk_1EDCD1000;
    v40 = "qsort - count/elementSize overflow";
LABEL_23:
    v39[7] = v40;
    __break(1u);
    goto LABEL_24;
  }
  v11 = a3 * a2;
  if (__CFADD__(a1, a3 * a2))
  {
    v17 = CFLog(3, (uint64_t)CFSTR("Unable to qsort array - list: %lu count: %ld elementSize: %ld - array access overflows"), a3, a4, a5, a6, a7, a8, (__int16)a1);
    v39 = (_QWORD *)&unk_1EDCD1000;
    v40 = "qsort - array access overflow";
    goto LABEL_23;
  }
  MEMORY[0x1E0C80A78](a1, a2);
  v15 = (char *)&v42[-1] - v14;
  v16 = (char *)&v42[-1] - v14;
  if ((unint64_t)a2 > 0x1000)
  {
    v17 = (uint64_t)malloc_type_malloc(8 * a2, 0x100004000313F17uLL);
    v16 = (char *)v17;
    if (!v17)
LABEL_24:
      CFQSortArray_cold_1(v17, v18, v19, v20, v21, v22, v23, v24);
  }
  v42[0] = MEMORY[0x1E0C809B0];
  v42[1] = 0x40000000;
  v42[2] = __CFQSortArray_block_invoke;
  v42[3] = &__block_descriptor_tmp_12_1;
  v42[4] = a4;
  v42[5] = a1;
  v42[6] = a3;
  v42[7] = a5;
  CFSortIndexes((uint64_t)v16, a2, 0, (uint64_t)v42);
  MEMORY[0x1E0C80A78](v25, v26);
  v34 = (char *)&v42[-1] - v33;
  v35 = (char *)&v42[-1] - v33;
  if (v36 < a2)
    v35 = (char *)malloc_type_malloc(a3 * a2, 0x146070BuLL);
  v41 = (uint64_t)&v41;
  if (__CFADD__(v35, v11))
  {
    v17 = CFLog(3, (uint64_t)CFSTR("Unable to qsort array - list: %lu count: %ld elementSize: %ld array - store overflows"), v27, v28, v29, v30, v31, v32, (__int16)a1);
    v39 = &unk_1EDCD1000;
    v40 = "qsort - array storage overflow";
    goto LABEL_23;
  }
  v37 = 0;
  v38 = v35;
  do
  {
    if (a3 == 8)
      *(_QWORD *)&v35[8 * v37] = a1[*(_QWORD *)&v16[8 * v37]];
    else
      memmove(v38, (char *)a1 + *(_QWORD *)&v16[8 * v37] * a3, a3);
    ++v37;
    v38 += a3;
  }
  while (a2 != v37);
  memmove(a1, v35, a3 * a2);
  if (v34 != v35)
    free(v35);
  if (v15 != v16)
    free(v16);
}

void _plistAppendString(__CFData *a1, CFStringRef theString)
{
  const UniChar *CharactersPtr;
  UniChar *v5;
  CFIndex Length;
  const char *CStringPtr;
  size_t v8;
  const __CFData *ExternalRepresentation;
  const __CFData *v10;
  const UInt8 *BytePtr;
  CFIndex v12;

  CharactersPtr = CFStringGetCharactersPtr(theString);
  if (CharactersPtr)
  {
    v5 = (UniChar *)CharactersPtr;
    Length = CFStringGetLength(theString);
    _plistAppendCharacters(a1, v5, Length);
  }
  else
  {
    CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    if (CStringPtr || (CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u)) != 0)
    {
      v8 = strlen(CStringPtr);
      CFDataAppendBytes(a1, (const UInt8 *)CStringPtr, v8);
    }
    else
    {
      ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString, 0x8000100u, 0);
      if (ExternalRepresentation)
      {
        v10 = ExternalRepresentation;
        BytePtr = CFDataGetBytePtr(ExternalRepresentation);
        v12 = CFDataGetLength(v10);
        CFDataAppendBytes(a1, BytePtr, v12);
        CFRelease(v10);
      }
    }
  }
}

CFStringRef __CFNumberCreateFormattingDescriptionAsFloat64(const __CFAllocator *a1, CFNumberRef number)
{
  const __CFString *v3;
  double valuePtr[2];

  valuePtr[1] = *(double *)MEMORY[0x1E0C80C00];
  valuePtr[0] = 0.0;
  CFNumberGetValue(number, kCFNumberFloat64Type, valuePtr);
  if (fabs(valuePtr[0]) == INFINITY)
  {
    if (valuePtr[0] <= 0.0)
      v3 = CFSTR("-infinity");
    else
      v3 = CFSTR("+infinity");
    return (CFStringRef)CFRetain(v3);
  }
  if (valuePtr[0] == 0.0)
  {
    v3 = CFSTR("0.0");
    return (CFStringRef)CFRetain(v3);
  }
  return CFStringCreateWithFormat(a1, 0, CFSTR("%.*g"), 17, *(_QWORD *)&valuePtr[0]);
}

CFStringRef __CFNumberCopyFormattingDescriptionAsFloat64(CFNumberRef number)
{
  return __CFNumberCreateFormattingDescriptionAsFloat64((const __CFAllocator *)&__kCFAllocatorSystemDefault, number);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t data;
  char v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  char **p_data;
  char *v14;
  uint64_t v15;
  char v16;
  int v17;
  char v18;
  char **v19;
  char *v20;
  char v21;
  unint64_t v22;
  char v23;
  char v24;
  uint64_t v25;
  char *v26;
  CFIndex v27;
  uint64_t v28;
  CFDataRef result;
  int v30;
  int v31;
  const __CFAllocator *v32;
  char v33;
  int v34;
  char v35;
  char v36;
  UniChar *Typed;
  int v38;
  char v39;
  char **v40;
  unsigned __int16 *v41;
  char v42;
  char v43;
  char v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  char v52;
  char **v53;
  char *v54;
  char v55;
  unint64_t v56;
  const UInt8 *v57;
  char v58;
  uint64_t v59;
  char v60;
  uint64_t v61;
  char *v62;
  CFIndex v63;
  uint64_t v64;
  CFIndex length;
  int v66[2];
  uint64_t v67;
  CFRange v68;
  CFRange v69;

  v4 = lossByte;
  v5 = *(_QWORD *)&encoding;
  v67 = *MEMORY[0x1E0C80C00];
  length = 0;
  *(_QWORD *)v66 = 0;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    data = CFStringGetLength(theString);
  }
  else
  {
    v9 = atomic_load((unint64_t *)&theString->info);
    v10 = v9 & 5;
    v11 = atomic_load((unint64_t *)&theString->info);
    v12 = v11 & 0x60;
    if (v10 == 4)
    {
      p_data = &theString->data;
      if (v12)
      {
        v14 = *p_data;
      }
      else
      {
        v15 = atomic_load((unint64_t *)&theString->info);
        v14 = (char *)&p_data[(v15 & 5) != 4];
      }
      data = *v14;
    }
    else if ((v11 & 0x60) != 0)
    {
      data = theString->length;
    }
    else
    {
      data = (uint64_t)theString->data;
    }
    v16 = atomic_load((unint64_t *)&theString->info);
    if ((v16 & 0x10) == 0)
    {
      v17 = __CFDefaultEightBitStringEncoding;
      if (__CFDefaultEightBitStringEncoding == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        v17 = __CFDefaultEightBitStringEncoding;
      }
      if (v17 == (_DWORD)v5)
        goto LABEL_15;
      if (v17 == -1)
      {
        __CFStringComputeEightBitStringEncoding();
        v17 = __CFDefaultEightBitStringEncoding;
      }
      if (v17 == 1536)
      {
        switch(BYTE1(v5))
        {
          case 0:
            if (v5 <= 0x22 && ((1 << v5) & 0x600000032) != 0 || (_DWORD)v5 == 152)
              goto LABEL_48;
            goto LABEL_15;
          case 1:
            if ((_DWORD)v5 != 134217984)
              goto LABEL_48;
            goto LABEL_15;
          case 2:
            if ((_DWORD)v5 == 518)
              goto LABEL_48;
            goto LABEL_15;
          case 6:
            if ((_DWORD)v5 != 1536)
              goto LABEL_48;
            goto LABEL_15;
          case 8:
          case 0xC:
            goto LABEL_48;
          case 0xA:
            if ((v5 - 2561) > 0xF)
              goto LABEL_15;
            v30 = 1 << (v5 - 1);
            v31 = 32785;
            break;
          case 0xB:
            if ((v5 - 3059) > 0xC)
              goto LABEL_15;
            v30 = 1 << (v5 + 13);
            v31 = 4099;
            break;
          default:
            if (((unsigned __int16)v5 & 0xFF00u) > 0xC00)
              goto LABEL_48;
            goto LABEL_15;
        }
        if ((v30 & v31) == 0)
        {
LABEL_15:
          v18 = atomic_load((unint64_t *)&theString->info);
          v19 = &theString->data;
          if ((v18 & 0x60) != 0)
          {
            v20 = *v19;
          }
          else
          {
            v21 = atomic_load((unint64_t *)&theString->info);
            v20 = (char *)&v19[(v21 & 5) != 4];
          }
          v22 = atomic_load((unint64_t *)&theString->info);
          v23 = atomic_load((unint64_t *)&theString->info);
          v24 = atomic_load((unint64_t *)&theString->info);
          v25 = v24 & 0x60;
          if ((v23 & 5) == 4)
          {
            if (v25)
            {
              v26 = *v19;
            }
            else
            {
              v28 = atomic_load((unint64_t *)&theString->info);
              v26 = (char *)&v19[(v28 & 5) != 4];
            }
            v27 = *v26;
          }
          else if (v25)
          {
            v27 = theString->length;
          }
          else
          {
            v27 = (CFIndex)*v19;
          }
          return CFDataCreate(alloc, (const UInt8 *)&v20[(v22 >> 2) & 1], v27);
        }
      }
    }
  }
LABEL_48:
  if (!alloc)
  {
    v32 = (const __CFAllocator *)_CFGetTSD(1u);
    if (v32)
      alloc = v32;
    else
      alloc = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
  }
  if ((v5 & 0xFFF) == 0x100 && ((_DWORD)v5 == 256 || (v5 - 134217985) >> 26 <= 4))
  {
    v36 = 1;
    if ((v5 & 0x8000000) != 0)
      v36 = 2;
    *(_QWORD *)v66 = (data + 1) << v36;
  }
  else
  {
    *(_QWORD *)v66 = CFStringGetMaximumSizeForEncoding(data, v5);
    if (*(uint64_t *)v66 > data && !CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    {
      v33 = atomic_load((unint64_t *)&theString->info);
      if ((v33 & 0x10) != 0)
      {
        v39 = atomic_load((unint64_t *)&theString->info);
        v40 = &theString->data;
        if ((v39 & 0x60) != 0)
        {
          v41 = (unsigned __int16 *)*v40;
        }
        else
        {
          v42 = atomic_load((unint64_t *)&theString->info);
          v41 = (unsigned __int16 *)&v40[(v42 & 5) != 4];
        }
        v43 = atomic_load((unint64_t *)&theString->info);
        v44 = atomic_load((unint64_t *)&theString->info);
        v45 = v44 & 0x60;
        if ((v43 & 5) == 4)
        {
          if (v45)
          {
            v46 = *v40;
          }
          else
          {
            v48 = atomic_load((unint64_t *)&theString->info);
            v46 = (char *)&v40[(v48 & 5) != 4];
          }
          v47 = *v46;
        }
        else if (v45)
        {
          v47 = theString->length;
        }
        else
        {
          v47 = (uint64_t)*v40;
        }
        v49 = CFStringEncodingByteLengthForCharacters(v5, 256, v41, v47);
        if (v49 >= 1)
          *(_QWORD *)v66 = v49;
      }
      else
      {
        v68.location = 0;
        v68.length = data;
        v34 = __CFStringEncodeByteStream(theString, v68, 1, v5, v4, 0, 0x7FFFFFFFFFFFFFFFLL, (int64_t *)v66);
        if (data != v34)
        {
          result = 0;
          if (!v4 || !v34)
            return result;
        }
        if (*(_QWORD *)v66 == data)
        {
          v35 = atomic_load((unint64_t *)&theString->info);
          if ((v35 & 0x10) == 0)
          {
            switch(BYTE1(v5))
            {
              case 0:
                if (v5 <= 0x22 && ((1 << v5) & 0x600000032) != 0 || (_DWORD)v5 == 152)
                  goto LABEL_71;
                goto LABEL_105;
              case 1:
                if ((_DWORD)v5 != 134217984)
                  goto LABEL_71;
                goto LABEL_105;
              case 2:
                if ((_DWORD)v5 == 518)
                  goto LABEL_71;
                goto LABEL_105;
              case 6:
                if ((_DWORD)v5 != 1536)
                  goto LABEL_71;
                goto LABEL_105;
              case 8:
              case 0xC:
                goto LABEL_71;
              case 0xA:
                if ((v5 - 2561) > 0xF)
                  goto LABEL_105;
                v50 = 1 << (v5 - 1);
                v51 = 32785;
                break;
              case 0xB:
                if ((v5 - 3059) > 0xC)
                  goto LABEL_105;
                v50 = 1 << (v5 + 13);
                v51 = 4099;
                break;
              default:
                if (((unsigned __int16)v5 & 0xFF00u) > 0xC00)
                  goto LABEL_71;
                goto LABEL_105;
            }
            if ((v50 & v51) == 0)
            {
LABEL_105:
              v52 = atomic_load((unint64_t *)&theString->info);
              v53 = &theString->data;
              if ((v52 & 0x60) != 0)
              {
                v54 = *v53;
              }
              else
              {
                v55 = atomic_load((unint64_t *)&theString->info);
                v54 = (char *)&v53[(v55 & 5) != 4];
              }
              v56 = atomic_load((unint64_t *)&theString->info);
              v57 = (const UInt8 *)&v54[(v56 >> 2) & 1];
              v58 = atomic_load((unint64_t *)&theString->info);
              v59 = v58 & 5;
              v60 = atomic_load((unint64_t *)&theString->info);
              v61 = v60 & 0x60;
              if (v59 == 4)
              {
                if (v61)
                {
                  v62 = *v53;
                }
                else
                {
                  v64 = atomic_load((unint64_t *)&theString->info);
                  v62 = (char *)&v53[(v64 & 5) != 4];
                }
                v63 = *v62;
              }
              else if (v61)
              {
                v63 = theString->length;
              }
              else
              {
                v63 = (CFIndex)*v53;
              }
              return CFDataCreate(alloc, v57, v63);
            }
          }
        }
      }
    }
  }
LABEL_71:
  Typed = (UniChar *)CFAllocatorAllocateTyped(alloc, *(_QWORD *)v66, 3056615131, 0);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  v69.location = 0;
  v69.length = data;
  v38 = __CFStringEncodeByteStream(theString, v69, 1, v5, v4, Typed, *(uint64_t *)v66, &length);
  if (data == v38 || v4 && v38)
    return CFDataCreateWithBytesNoCopy(alloc, (const UInt8 *)Typed, length, alloc);
  CFAllocatorDeallocate(alloc, Typed);
  return 0;
}

ssize_t fileRead(uint64_t a1, void *a2, size_t a3, uint64_t a4, BOOL *a5, uint64_t a6)
{
  ssize_t v8;
  uint64_t v9;
  __CFFileDescriptor *v10;
  off_t v12;
  stat v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v8 = fdRead(*(_DWORD *)(a6 + 8), a2, a3, a4, a5);
  v9 = *(_QWORD *)(a6 + 24);
  if ((v9 & 2) != 0)
  {
    *(_QWORD *)(a6 + 24) = v9 & 0xFFFFFFFFFFFFFFFDLL;
    if (!*a5)
    {
      if (*(_QWORD *)(a6 + 16))
      {
        memset(&v13, 0, sizeof(v13));
        if ((fstat(*(_DWORD *)(a6 + 8), &v13) & 0x80000000) == 0 && (v13.st_mode & 0xF000) == 0x8000)
        {
          v12 = lseek(*(_DWORD *)(a6 + 8), 0, 1);
          if (v13.st_size == v12)
            _CFFileDescriptorInduceFakeReadCallBack(*(_QWORD *)(a6 + 16));
        }
      }
    }
    v10 = *(__CFFileDescriptor **)(a6 + 16);
    if (v10)
      CFFileDescriptorEnableCallBacks(v10, 1uLL);
  }
  return v8;
}

ssize_t fdRead(int a1, void *a2, size_t a3, uint64_t a4, BOOL *a5)
{
  ssize_t result;
  int v8;

  result = read(a1, a2, a3);
  if (result < 0)
  {
    v8 = *__error();
    *(_QWORD *)a4 = 1;
    result = -1;
  }
  else
  {
    v8 = 0;
    *a5 = result == 0;
  }
  *(_DWORD *)(a4 + 8) = v8;
  return result;
}

uint64_t fileCreate(const void *a1, uint64_t a2)
{
  CFAllocatorRef v3;
  uint64_t Typed;
  const void *v5;

  v3 = CFGetAllocator(a1);
  Typed = CFAllocatorAllocateTyped(v3, 40, 0x10600401BE82CDFLL, 0);
  if (Typed)
  {
    v5 = *(const void **)a2;
    *(_QWORD *)Typed = *(_QWORD *)a2;
    if (v5)
      CFRetain(v5);
    *(_DWORD *)(Typed + 8) = *(_DWORD *)(a2 + 8);
    *(_QWORD *)(Typed + 16) = 0;
    *(_QWORD *)(Typed + 24) = 0;
    *(_QWORD *)(Typed + 32) = -1;
  }
  return Typed;
}

void _plistAppendFormat(__CFData *a1, CFStringRef format, ...)
{
  const __CFString *v3;
  va_list va;

  va_start(va, format);
  v3 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, format, va);
  _plistAppendString(a1, v3);
  CFRelease(v3);
}

void deallocatePurgeable(void *a1, uint64_t a2)
{
  vm_map_t v3;
  const UInt8 *BytePtr;
  kern_return_t v5;
  int v6;
  NSObject *v7;

  if (*(_BYTE *)(a2 + 25))
  {
    free(a1);
  }
  else
  {
    v3 = *MEMORY[0x1E0C83DA0];
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a2 + 8));
    v5 = mach_vm_deallocate(v3, (mach_vm_address_t)BytePtr, *(_QWORD *)(a2 + 16));
    if (v5)
    {
      v6 = v5;
      v7 = _CFPrefsDaemonLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
        deallocatePurgeable_cold_1(v6, v7);
    }
  }
}

uint64_t _CFRuntimeGetClassWithTypeID(unint64_t a1)
{
  _UNKNOWN **v1;
  int v2;
  uint64_t v3;

  if (a1 <= 0x47)
  {
    v1 = &__CFRuntimeBuiltinClassTable + a1;
    return (uint64_t)*v1;
  }
  v2 = a1 - 72;
  if ((int)a1 - 72 < dword_1ECCFAFE8)
  {
    v3 = __CFRuntimeClassTables[v2 >> 6];
    if (v3)
    {
      v1 = (_UNKNOWN **)(v3 + 8 * (v2 & 0x3F));
      return (uint64_t)*v1;
    }
  }
  return 0;
}

uint64_t _getFlags(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  _UNKNOWN **v7;

  if ((a1 & 0x8000000000000000) == 0)
    goto LABEL_12;
  v1 = 0;
  v2 = *MEMORY[0x1E0DE7C58];
  if ((~a1 & 0xC000000000000007) == 0)
    v2 = 0;
  v3 = v2 ^ a1;
  v4 = v3 & 7;
  do
  {
    if (v4 == *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + v1))
      break;
    ++v1;
  }
  while (v1 != 7);
  if ((~(_BYTE)v1 & 7) == 0 && ((v1 | v3) & 0x7F80000000000000) == 0x600000000000000)
  {
    v5 = v4 == 7;
    v6 = 0xFFFFFFFFFFFFFFFLL;
    if (v5)
      v6 = 0xFFFFFFFFFFFFFLL;
    v7 = __CFGetSignatureROMEntryAtIndex(v6 & (v3 >> 3)) + 2;
  }
  else
  {
LABEL_12:
    v7 = (_UNKNOWN **)(a1 + 24);
  }
  return (uint64_t)*v7;
}

void CFErrorSetCallBackBlockForDomain(const void *a1, const void *a2)
{
  if (!_CFErrorCallBackTable)
    _CFErrorInitializeCallBackTable();
  os_unfair_lock_lock_with_options();
  if (a2)
    CFDictionarySetValue((CFMutableDictionaryRef)_CFErrorCallBackTable, a1, a2);
  else
    CFDictionaryRemoveValue((CFMutableDictionaryRef)_CFErrorCallBackTable, a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
}

uint64_t _CFErrorCreateRedactedDescription(_QWORD *a1)
{
  _QWORD v3[4];

  v3[3] = *MEMORY[0x1E0C80C00];
  v3[1] = 0;
  v3[0] = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  v3[2] = 257;
  _CFErrorFormatDebugDescriptionAux(a1, (uint64_t)v3);
  return v3[0];
}

uint64_t _CFErrorCreateDebugDescription(_QWORD *a1)
{
  _QWORD v3[4];

  v3[3] = *MEMORY[0x1E0C80C00];
  v3[1] = 0;
  v3[0] = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  v3[2] = 1;
  _CFErrorFormatDebugDescriptionAux(a1, (uint64_t)v3);
  return v3[0];
}

void sub_182B076B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_182B079D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  _Unwind_Resume(exception_object);
}

uint64_t CFPREFERENCES_IS_WAITING_FOR_SYSTEM_AND_USER_CFPREFSDS(const os_unfair_lock *a1, uint64_t a2)
{
  os_unfair_lock_assert_not_owner(a1 + 17);
  os_unfair_lock_assert_not_owner(a1 + 18);
  os_unfair_lock_assert_not_owner(a1 + 19);
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

void sub_182B08210(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void _CFPrefsDictionaryApplyBlock(const __CFDictionary *a1, void *context)
{
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)applyBlockApplier, context);
}

uint64_t applyBlockApplier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t notifySearchListOfRemoteChangesCallback(uint64_t a1, void *a2, uint64_t a3)
{
  return objc_msgSend(a2, "handleChangeNotificationForDomainIdentifier:isRemote:", a3, 1);
}

void sub_182B087E4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t synchronizeApplier(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "synchronize");
}

void sub_182B08A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

unint64_t visit(uint64_t a1, int a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t WeakRetained;
  void *v12;
  int v13;
  _QWORD *v15;
  void *v16;
  unsigned __int8 v18;
  uint64_t v19;

  v6 = 0;
  v7 = 0;
  v19 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 24);
  v18 = 0;
  v9 = a1 + 8;
  while (1)
  {
    v10 = v9;
    WeakRetained = (unint64_t)objc_loadWeakRetained((id *)v9);
    v12 = (void *)WeakRetained;
    if (!(WeakRetained | v7))
      v7 = v9;
    if (WeakRetained)
      ++v6;
    (*(void (**)(uint64_t, unint64_t, unint64_t, unsigned __int8 *))(a3 + 16))(a3, v9, WeakRetained, &v18);
    v9 = *(_QWORD *)(v9 + 8);
    if (v12)

    v13 = v18;
    if (v18 || v6 > v8)
      break;
    if (!v9)
    {
      v15 = (_QWORD *)(v10 + 8);
      goto LABEL_15;
    }
  }
  v15 = (_QWORD *)(v10 + 8);
  if (v9)
    goto LABEL_16;
LABEL_15:
  *(_QWORD *)(a1 + 24) = v6;
LABEL_16:
  if (!a2 && !v13 && !v7)
  {
    v16 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040BD48D6D6uLL);
    if (!v16)
      visit_cold_1();
    v7 = (unint64_t)v16;
    *v15 = v16;
  }
  return v7;
}

void userInfoKeyValueShow(const void *a1, void *a2, uint64_t a3)
{
  int v6;
  char v7;
  __CFString *v8;
  const __CFString *v9;
  const void *v10;
  uint64_t v11;

  if (!a3)
    userInfoKeyValueShow_cold_1();
  v6 = CFEqual(a1, CFSTR("NSUnderlyingError"));
  if (a2 && v6 && CFGetTypeID(a2) == 27)
  {
    CFStringAppendFormat(*(CFMutableStringRef *)a3, 0, CFSTR("%@=%p {"), a1, a2);
    _CFErrorFormatDebugDescriptionAux(a2, a3);
    CFStringAppend(*(CFMutableStringRef *)a3, CFSTR("}, "));
  }
  else if (*(_BYTE *)(a3 + 17))
  {
    v7 = objc_opt_respondsToSelector();
    v8 = *(__CFString **)a3;
    if ((v7 & 1) != 0)
    {
      v10 = a1;
      v11 = objc_msgSend(a2, "redactedDescription");
      v9 = CFSTR("%@=%@, ");
    }
    else
    {
      v10 = a1;
      v9 = CFSTR("%@=<private>, ");
    }
    CFStringAppendFormat(v8, 0, v9, v10, v11);
  }
  else
  {
    CFStringAppendFormat(*(CFMutableStringRef *)a3, 0, CFSTR("%@=%@, "), a1, a2);
  }
}

void _CFErrorFormatDebugDescriptionAux(_QWORD *a1, uint64_t a2)
{
  __CFString *v4;
  __CFString *v5;
  __CFString *v6;
  __CFString *v7;
  const __CFDictionary *v8;
  __CFString *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  __CFString *v14;
  CFRange v15;

  v4 = (__CFString *)_CFErrorCopyUserInfoKey(a1, CFSTR("NSDebugDescription"));
  v5 = (__CFString *)_CFErrorCopyUserInfoKey(a1, CFSTR("NSDescription"));
  if (v5)
  {
    v6 = v5;
  }
  else
  {
    if (v4)
    {
      v6 = v4;
    }
    else if (*(_BYTE *)(a2 + 16))
    {
      v7 = (__CFString *)_CFErrorCopyUserInfoKey(a1, CFSTR("NSLocalizedDescription"));
      if (!v7)
        v7 = (__CFString *)_CFErrorCopyUserInfoKey(a1, CFSTR("NSLocalizedFailureReason"));
      v6 = v7;
    }
    else
    {
      v6 = 0;
    }
    v4 = 0;
  }
  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
    v8 = (const __CFDictionary *)objc_msgSend(a1, "userInfo");
  else
    v8 = (const __CFDictionary *)a1[4];
  v9 = *(__CFString **)a2;
  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
    v10 = objc_msgSend(a1, "domain");
  else
    v10 = a1[3];
  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
    v11 = objc_msgSend(a1, "code");
  else
    v11 = a1[2];
  CFStringAppendFormat(v9, 0, CFSTR("Error Domain=%@ Code=%ld"), v10, v11);
  if (*(_BYTE *)(a2 + 17))
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      CFStringAppendFormat(*(CFMutableStringRef *)a2, 0, CFSTR(" \"%@\""), -[__CFString redactedDescription](v6, "redactedDescription"));
  }
  else
  {
    CFStringAppendFormat(*(CFMutableStringRef *)a2, 0, CFSTR(" \"%@\""), v6);
  }
  if (v6 && v4 && CFStringGetLength(v4) >= 1 && !CFEqual(v6, v4))
  {
    if (*(_BYTE *)(a2 + 17))
    {
      if ((objc_opt_respondsToSelector() & 1) != 0)
        CFStringAppendFormat(*(CFMutableStringRef *)a2, 0, CFSTR(" (%@)"), -[__CFString redactedDescription](v4, "redactedDescription"));
    }
    else
    {
      CFStringAppendFormat(*(CFMutableStringRef *)a2, 0, CFSTR(" (%@)"), v4);
    }
  }
  if (!v8 || !CFDictionaryGetCount(v8))
  {
LABEL_36:
    if (!v4)
      goto LABEL_38;
    goto LABEL_37;
  }
  v12 = *(_QWORD *)(a2 + 8);
  if (v12 <= 2)
  {
    *(_QWORD *)(a2 + 8) = v12 + 1;
    CFStringAppend(*(CFMutableStringRef *)a2, CFSTR(" UserInfo={"));
    CFDictionaryApplyFunction(v8, (CFDictionaryApplierFunction)userInfoKeyValueShow, (void *)a2);
    v13 = CFStringHasSuffix(*(CFStringRef *)a2, CFSTR(", ")) != 0;
    v14 = *(__CFString **)a2;
    v15.location = CFStringGetLength(*(CFStringRef *)a2) - 2 * v13;
    v15.length = 2 * v13;
    CFStringReplace(v14, v15, CFSTR("}"));
    --*(_QWORD *)(a2 + 8);
    goto LABEL_36;
  }
  CFStringAppendFormat(*(CFMutableStringRef *)a2, 0, CFSTR(" UserInfo=%p (not displayed)"), v8);
  if (v4)
LABEL_37:
    CFRelease(v4);
LABEL_38:
  if (v6)
    CFRelease(v6);
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  char v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va;

  va_start(va, format);
  v3 = atomic_load((unint64_t *)&theString->info);
  if ((v3 & 1) != 0)
  {
    CFStringAppendFormatAndArguments(theString, formatOptions, format, va);
  }
  else
  {
    v4 = _CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      CFStringAppendFormat_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
}

void CFStringAppendFormatAndArguments(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  char v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = atomic_load((unint64_t *)&theString->info);
  if ((v4 & 1) != 0)
  {
    if (!__CFStringAppendFormatCore(theString, 0, 0, formatOptions, 0, 0, 0))
      CFLog(3, CFSTR("ERROR: Failed to format string: %@"));
  }
  else
  {
    v5 = _CFOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      CFStringAppendFormatAndArguments_cold_1(v5, v6, v7, v8, v9, v10, v11, v12);
  }
}

const void *_CFErrorCopyUserInfoKey(_QWORD *a1, const void *a2)
{
  const void *result;

  result = _CFErrorCopyUserInfoKeyFromUserInfo(a1, a2);
  if (!result)
    return _CFErrorCopyUserInfoKeyFromCallBack(a1, (uint64_t)a2);
  return result;
}

const void *_CFErrorCopyUserInfoKeyFromUserInfo(_QWORD *a1, const void *a2)
{
  const __CFDictionary *v4;
  const void *Value;
  const void *v6;

  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
  {
    v4 = (const __CFDictionary *)objc_msgSend(a1, "userInfo");
    if (v4)
      goto LABEL_3;
    return 0;
  }
  v4 = (const __CFDictionary *)a1[4];
  if (!v4)
    return 0;
LABEL_3:
  Value = CFDictionaryGetValue(v4, a2);
  v6 = Value;
  if (Value)
    CFRetain(Value);
  return v6;
}

const void *_CFErrorCopyUserInfoKeyFromCallBack(_QWORD *a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
    v4 = (const void *)objc_msgSend(a1, "domain");
  else
    v4 = (const void *)a1[3];
  v5 = CFErrorCopyCallBackBlockForDomain(v4);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = (const void *)(*((uint64_t (**)(const void *, _QWORD *, uint64_t))v5 + 2))(v5, a1, a2);
  v8 = v7;
  if (v7)
    CFRetain(v7);
  CFRelease(v6);
  return v8;
}

const void *CFErrorCopyCallBackBlockForDomain(const void *a1)
{
  const void *Value;
  const void *v3;

  if (!_CFErrorCallBackTable)
    _CFErrorInitializeCallBackTable();
  os_unfair_lock_lock_with_options();
  if (_CFErrorCallBackTable)
  {
    Value = CFDictionaryGetValue((CFDictionaryRef)_CFErrorCallBackTable, a1);
    v3 = Value;
    if (Value)
      CFRetain(Value);
  }
  else
  {
    v3 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
  return v3;
}

CFTypeRef CFAutorelease(CFTypeRef arg)
{
  CFTypeRef v2;

  if (!arg)
    CFAutorelease_cold_1();
  v2 = (id)arg;
  return arg;
}

const __CFString *_CFErrorPOSIXCallBack(_QWORD *a1, CFTypeRef cf1)
{
  uint64_t v4;
  char *v5;
  const __CFString *v6;
  __CFArray *v7;
  const __CFArray *v8;
  const __CFURL *ValueAtIndex;
  CFStringRef v10;
  CFStringRef v11;
  const __CFString *v12;
  const __CFURL *v13;
  __CFBundle *v14;
  __CFBundle *v15;
  __CFString *v16;

  if (!CFEqual(cf1, CFSTR("NSDescription")) && !CFEqual(cf1, CFSTR("NSLocalizedFailureReason")))
    return 0;
  if (CF_IS_OBJC(0x1BuLL, (__objc2_class **)a1))
    LODWORD(v4) = objc_msgSend(a1, "code");
  else
    v4 = a1[2];
  v5 = strerror(v4);
  if (!v5 || !*v5)
    return 0;
  v6 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, 0x8000100u);
  if (v6)
  {
    if (!CFEqual(cf1, CFSTR("NSDescription")))
    {
      v7 = CFCopySearchPathForDirectoriesInDomains(5, 8, 0);
      if (v7)
      {
        v8 = v7;
        if (CFArrayGetCount(v7) >= 1)
        {
          ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v8, 0);
          v10 = CFURLCopyFileSystemPath(ValueAtIndex, kCFURLPOSIXPathStyle);
          if (v10)
          {
            v11 = v10;
            v12 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@/CoreServices/CoreTypes.bundle"), v10);
            v13 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, kCFURLPOSIXPathStyle, 0);
            CFRelease(v11);
            if (v13)
            {
              v14 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13);
              if (v14)
              {
                v15 = v14;
                v16 = (__CFString *)CFBundleCopyLocalizedString(v14, v6, CFSTR("%%NOTFOUND%%"), CFSTR("ErrnoErrors"));
                if (v16 == CFSTR("%%NOTFOUND%%"))
                {
                  CFRelease(CFSTR("%%NOTFOUND%%"));
                  v16 = 0;
                }
                CFRelease(v6);
                CFRelease(v15);
                v6 = v16;
              }
              CFRelease(v13);
            }
            CFRelease(v12);
          }
        }
        CFRelease(v8);
      }
    }
  }
  return v6;
}

IMP _CFErrorCocoaCallBack(uint64_t a1, uint64_t a2)
{
  IMP result;
  Class v5;
  objc_class *v6;
  const char *v7;
  SEL v8;
  uint64_t (*v9)(uint64_t, SEL, uint64_t);

  result = (IMP)_CFErrorCocoaCallBack_cocoaCallBack;
  if (_CFErrorCocoaCallBack_cocoaCallBack)
    goto LABEL_4;
  v5 = objc_lookUpClass("NSError");
  if (v5)
  {
    v6 = v5;
    v7 = sel_registerName("_retainedUserInfoCallBackForKey:");
    result = class_getMethodImplementation(v6, v7);
    _CFErrorCocoaCallBack_cocoaCallBack = result;
    if (!result)
      return result;
    goto LABEL_4;
  }
  result = (IMP)_CFErrorCocoaCallBack_cocoaCallBack;
  if (_CFErrorCocoaCallBack_cocoaCallBack)
  {
LABEL_4:
    v9 = (uint64_t (*)(uint64_t, SEL, uint64_t))result;
    v8 = sel_registerName("_retainedUserInfoCallBackForKey:");
    return (IMP)v9(a1, v8, a2);
  }
  return result;
}

CFTypeID CFErrorGetTypeID(void)
{
  return 27;
}

uint64_t __alreadylocked_requestNewDataIfStale_block_invoke(uint64_t a1)
{
  return -[CFPrefsPlistSource alreadylocked_requestNewData](*(_QWORD *)(a1 + 32));
}

void _CFErrorInitializeCallBackTable()
{
  CFMutableDictionaryRef v0;
  uint64_t v1;
  CFDictionaryValueCallBacks v2;
  uint64_t value;
  uint64_t v4;
  const void *(*v5)(uint64_t, uint64_t, uint64_t);
  void *v6;
  void *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v2.equal = CFEqual;
  v2.version = kCFTypeDictionaryValueCallBacks.version;
  v2.copyDescription = kCFTypeDictionaryValueCallBacks.copyDescription;
  v2.retain = (CFDictionaryRetainCallBack)blockCopyValueCallBack;
  v2.release = (CFDictionaryReleaseCallBack)blockReleaseValueCallBack;
  v0 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &v2);
  os_unfair_lock_lock_with_options();
  if (_CFErrorCallBackTable)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
    CFRelease(v0);
  }
  else
  {
    _CFErrorCallBackTable = (uint64_t)v0;
    v1 = MEMORY[0x1E0C809B0];
    value = MEMORY[0x1E0C809B0];
    v4 = 3221225472;
    v5 = ____CFErrorSetCallBackForDomainNoLock_block_invoke;
    v6 = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    v7 = _CFErrorPOSIXCallBack;
    CFDictionarySetValue(v0, CFSTR("NSPOSIXErrorDomain"), &value);
    value = v1;
    v4 = 3221225472;
    v5 = ____CFErrorSetCallBackForDomainNoLock_block_invoke;
    v6 = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    v7 = _CFErrorMachCallBack;
    CFDictionarySetValue((CFMutableDictionaryRef)_CFErrorCallBackTable, CFSTR("NSMachErrorDomain"), &value);
    value = v1;
    v4 = 3221225472;
    v5 = ____CFErrorSetCallBackForDomainNoLock_block_invoke;
    v6 = &__block_descriptor_40_e89__v24__0____CFError____CFRuntimeBase_QAQ_q____CFString_____CFDictionary__8____CFString__16l;
    v7 = _CFErrorCocoaCallBack;
    CFDictionarySetValue((CFMutableDictionaryRef)_CFErrorCallBackTable, CFSTR("NSCocoaErrorDomain"), &value);
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFErrorLock);
  }
}

objc_class *__NSDictionaryParameterCheckIterate(objc_class *result, const char *a2, uint64_t a3)
{
  uint64_t v3;
  NSException *v4;

  if (!a3)
  {
    v3 = __CFExceptionProem(result, a2);
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@: block is nil"), v3);
    v4 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
    objc_exception_throw(v4);
  }
  return result;
}

uint64_t __NSArrayM_copy(uint64_t a1)
{
  uint64_t v1;
  unint64_t v3;
  unsigned int v4;
  unint64_t *v5;
  _WORD *v7;
  objc_class *v10;
  id v11;
  os_unfair_lock_s *v12;

  if (__cf_tsanReadFunction)
    __cf_tsanReadFunction(a1, v1, __CFTSANTagMutableArray);
  v3 = atomic_load((unint64_t *)(a1 + 8));
  v4 = *(_DWORD *)(a1 + 36);
  if (!v3)
  {
    if (v4 > 5)
      goto LABEL_5;
    return objc_msgSend(__NSArrayImmutablePlaceholder(), "initWithArray:range:copyItems:", a1, 0, *(unsigned int *)(a1 + 36), 0);
  }
  if (v4 < 4)
    return objc_msgSend(__NSArrayImmutablePlaceholder(), "initWithArray:range:copyItems:", a1, 0, *(unsigned int *)(a1 + 36), 0);
LABEL_5:
  v5 = (unint64_t *)(a1 + 8);
  if (!atomic_load((unint64_t *)(a1 + 8)))
  {
    v7 = _cow_create(a1, 1);
    while (!__ldaxr(v5))
    {
      if (!__stlxr((unint64_t)v7, v5))
        goto LABEL_13;
    }
    __clrex();
    free(v7);
  }
LABEL_13:
  v10 = (objc_class *)objc_opt_self();
  v11 = __CFAllocateObject(v10, 0);
  v12 = (os_unfair_lock_s *)atomic_load((unint64_t *)(a1 + 8));
  _cow_copy(a1, 1, v12, (uint64_t)__NSArray_cowCallbacks, (uint64_t)v11, 0);
  return (uint64_t)v11;
}

uint64_t __initWithArrayDontCopyItems(__objc2_class **a1, void *a2)
{
  __objc2_class *v4;

  v4 = (__objc2_class *)objc_opt_class();
  if (v4 != __NSArrayI && v4 != __NSArrayM && v4 != __NSFrozenArrayM)
    return 0;
  if (a1 == &___mutablePlaceholderArray)
    return objc_msgSend(a2, "mutableCopyWithZone:", 0);
  if (a1 != &___immutablePlaceholderArray)
    return 0;
  return objc_msgSend(a2, "copyWithZone:", 0);
}

void _cow_copy(uint64_t a1, uint64_t a2, os_unfair_lock_t lock, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int os_unfair_lock_opaque_low;
  int os_unfair_lock_opaque_high;

  os_unfair_lock_lock(lock);
  os_unfair_lock_opaque_low = LOWORD(lock[1]._os_unfair_lock_opaque);
  os_unfair_lock_opaque_high = HIWORD(lock[1]._os_unfair_lock_opaque);
  if ((_DWORD)a6 == 1)
  {
    if (os_unfair_lock_opaque_high != 0xFFFF)
    {
      LOWORD(os_unfair_lock_opaque_high) = os_unfair_lock_opaque_high + 1;
LABEL_8:
      LOWORD(lock[1]._os_unfair_lock_opaque) = os_unfair_lock_opaque_low;
      HIWORD(lock[1]._os_unfair_lock_opaque) = os_unfair_lock_opaque_high;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))a4)(a1, a2, a5, a6);
      goto LABEL_9;
    }
  }
  else if (os_unfair_lock_opaque_low != 0xFFFF)
  {
    LOWORD(os_unfair_lock_opaque_low) = os_unfair_lock_opaque_low + 1;
    goto LABEL_8;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))a4)(a1, a2, a5, a6);
  if (((*(uint64_t (**)(uint64_t))(a4 + 8))(a5) & 1) == 0)
    _cow_copy_cold_1();
  (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a5, 0);
LABEL_9:
  os_unfair_lock_unlock(lock);
}

__n128 cow_copy_instance(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int *v4;
  int *v5;
  int *v6;
  unint64_t v7;
  __n128 *v8;
  int *v9;
  uint64_t v10;
  unint64_t v11;
  __n128 result;
  __n128 *v13;

  v4 = &OBJC_IVAR_____NSFrozenArrayM_cow;
  if (a2 == 1)
    v5 = &OBJC_IVAR_____NSArrayM_cow;
  else
    v5 = &OBJC_IVAR_____NSFrozenArrayM_cow;
  if (a2 == 1)
    v6 = &OBJC_IVAR_____NSArrayM_storage;
  else
    v6 = &OBJC_IVAR_____NSFrozenArrayM_storage;
  v7 = atomic_load((unint64_t *)(a1 + *v5));
  v8 = (__n128 *)(a1 + *v6);
  if (a4 == 1)
  {
    v4 = &OBJC_IVAR_____NSArrayM_cow;
    v9 = &OBJC_IVAR_____NSArrayM_storage;
  }
  else
  {
    v9 = &OBJC_IVAR_____NSFrozenArrayM_storage;
  }
  atomic_store(v7, (unint64_t *)(a3 + *v4));
  v10 = *v9;
  v11 = v8[1].n128_u64[0];
  result = *v8;
  v13 = (__n128 *)(a3 + v10);
  *v13 = *v8;
  v13[1].n128_u64[0] = v11;
  return result;
}

_WORD *_cow_create(uint64_t a1, int a2)
{
  _WORD *result;

  result = malloc_type_calloc(8uLL, 1uLL, 0x56E69C1FuLL);
  if (!result)
    _cow_create_cold_1();
  *(_DWORD *)result = 0;
  result[2] = a2 != 1;
  result[3] = a2 == 1;
  return result;
}

uint64_t __CFStringIsMutable(uint64_t a1)
{
  char v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

CFCharacterSetRef CFCharacterSetCreateCopy(CFAllocatorRef alloc, CFCharacterSetRef theSet)
{
  return (CFCharacterSetRef)__CFCharacterSetCreateCopy(alloc, (unint64_t *)theSet, 0, 1);
}

UText *__CFStringUTextInit(UText *a1, int32_t a2, const void *a3)
{
  UText *result;
  const UTextFuncs *v6;
  UErrorCode status;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  status = U_ZERO_ERROR;
  if (!a3)
    return 0;
  result = utext_setup(a1, 0, &status);
  if (status > U_ZERO_ERROR)
    return 0;
  result->providerProperties = a2;
  v6 = (const UTextFuncs *)&__CFAttributedStringFuncs;
  result->context = a3;
  if ((a2 & 0x10) == 0)
    v6 = (const UTextFuncs *)&__CFStringFuncs;
  result->pFuncs = v6;
  return result;
}

CFMutableStringRef _CFBundleCopyLocalizedStringForLocalizations(unint64_t *a1, void *a2, void *a3, __CFString *a4, const __CFArray *a5)
{
  return _CFBundleCopyLocalizedStringForLocalizationTableURLAndMarkdownOption(a1, a2, a3, a4, a5, 0, 0);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  if (!CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
    return _CFStreamOpen((uint64_t)stream);
  -[__CFReadStream open](stream, "open");
  return 1;
}

uint64_t __exceptionMatch(objc_class *a1, void *a2)
{
  return objectIsKindOfClass(a2, a1);
}

id *__exceptionPreprocess(id *a1)
{
  id v2;
  Class v3;
  uint64_t v4;
  uint64_t v5;

  if (objectIsKindOfClass(a1, (objc_class *)NSException))
  {
    v2 = a1[4];
    if (v2)
    {
      if (objc_msgSend(a1[4], "objectForKey:", CFSTR("callStackReturnAddresses"))
        || objc_msgSend(v2, "objectForKey:", CFSTR("callStackSymbols")))
      {
        return a1;
      }
    }
    else
    {
      __CFLookUpClass("NSMutableDictionary");
      v2 = (id)objc_opt_new();
      a1[4] = v2;
    }
    if ((objc_msgSend((id)objc_msgSend((id)objc_msgSend(a1, "userInfo"), "objectForKey:", CFSTR("NSExceptionOmitCallstacks")), "BOOLValue") & 1) == 0)
    {
      v3 = __CFLookUpClass("NSThread");
      v4 = -[objc_class callStackReturnAddresses](v3, "callStackReturnAddresses");
      v5 = -[objc_class callStackSymbols](v3, "callStackSymbols");
      if (v4)
        objc_msgSend(v2, "setObject:forKey:", v4, CFSTR("callStackReturnAddresses"));
      if (v5)
        objc_msgSend(v2, "setObject:forKey:", v5, CFSTR("callStackSymbols"));
    }
  }
  return a1;
}

uint64_t objectIsKindOfClass(void *a1, objc_class *a2)
{
  void *v3;
  objc_class *Class;
  objc_class *Superclass;

  if (a1)
  {
    v3 = a1;
    Class = object_getClass(a1);
    if (class_respondsToSelector(Class, sel_isKindOfClass_))
    {
      LOBYTE(a1) = objc_opt_isKindOfClass();
    }
    else
    {
      Superclass = object_getClass(v3);
      for (LOBYTE(a1) = Superclass != 0; Superclass != a2 && Superclass; LOBYTE(a1) = Superclass != 0)
        Superclass = class_getSuperclass(Superclass);
    }
  }
  return a1 & 1;
}

uint64_t _NSIsNSCFConstantString(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*MethodImplementation)(uint64_t, char *);

  if (a1)
  {
    v1 = a1;
    MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
    if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
      return MethodImplementation(v1, sel_isNSCFConstantString__);
    objc_opt_class();
    LOBYTE(a1) = objc_opt_isKindOfClass();
  }
  return a1 & 1;
}

_QWORD *_NSMessageBuilder(uint64_t a1, uint64_t a2)
{
  objc_class *v4;
  _QWORD *result;

  v4 = __CFLookUpClass("__NSMessageBuilder");
  result = class_createInstance(v4, 0);
  result[1] = a1;
  result[2] = a2;
  return result;
}

CFDateRef _CFXPCCreateCFObjectFromXPCMessage(void *a1)
{
  CFDateRef result;
  size_t v2[2];

  v2[1] = *MEMORY[0x1E0C80C00];
  v2[0] = 0;
  result = (CFDateRef)xpc_dictionary_get_data(a1, "ECF19A18-7AA6-4141-B4DC-A2E5123B2B5C", v2);
  if (result)
    return __CFBinaryPlistCreate15((uint64_t)result, v2[0]);
  return result;
}

CFDateRef __CFBinaryPlistCreate15(uint64_t a1, unint64_t a2)
{
  char v2;
  CFDateRef Object15;
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  const void *v11[2];

  v11[1] = *(const void **)MEMORY[0x1E0C80C00];
  if (a2 < 0x10)
    return 0;
  if (__CFADD__(a2, a1))
    return 0;
  if (*(_QWORD *)a1 != 0x35317473696C7062)
    return 0;
  if (a1 + a2 - 1 < a1 + 8)
    return 0;
  v2 = *(_BYTE *)(a1 + 8);
  if ((v2 & 0xF0) != 0x10)
    return 0;
  Object15 = 0;
  v4 = (unsigned __int8 *)(a1 + 9);
  v5 = 1 << (v2 & 0xF);
  if (!__CFADD__(v5, a1 + 9) && (unint64_t)&v4[v5] <= a1 + a2)
  {
    Object15 = 0;
    switch((int)v5)
    {
      case 1:
        v6 = (char)*v4;
        if ((int)v6 >= 0)
          v7 = v6 - 128;
        else
          v7 = *v4 ^ 0x80;
        goto LABEL_17;
      case 2:
        v8 = (__int16)(*(unsigned __int8 *)(a1 + 10) << 8) | (unint64_t)*(unsigned __int8 *)(a1 + 9);
        if ((v8 & 0x80000000) == 0)
          v7 = v8 - 0x8000;
        else
          v7 = (unsigned __int16)v8 ^ 0x8000u;
        goto LABEL_17;
      case 4:
        v7 = *(int *)v4 ^ 0xFFFFFFFF80000000;
        goto LABEL_17;
      case 8:
        v7 = *(_QWORD *)(a1 + 9) ^ 0x8000000000000000;
LABEL_17:
        Object15 = 0;
        if (v7 < 16 || v7 > a2)
          return Object15;
        v9 = (char *)&v4[v5];
        if ((unint64_t)v9 >= a1 + a2)
          return 0;
        if (*v9 != 18)
          return 0;
        v11[0] = v9 + 5;
        if ((unint64_t)(v9 + 5) >= a1 + a2)
          return 0;
        Object15 = __readObject15(a1, v7, v11);
        break;
      default:
        return Object15;
    }
  }
  return Object15;
}

CFDateRef __readObject15(uint64_t a1, uint64_t a2, const void **a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  char *v9;
  unsigned int v10;
  const __CFURL *v11;
  CFIndex v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t v16;
  const CFNullRef *v17;
  void *v18;
  uint64_t v19;
  CFNumberType v20;
  unsigned int v21;
  unint64_t v22;
  CFDateRef result;
  CFIndex v24;
  unsigned __int8 *v25;
  uint64_t v26;
  uint64_t v27;
  CFIndex v28;
  unsigned __int8 *v29;
  uint64_t v30;
  uint64_t v31;
  CFIndex v32;
  unsigned __int8 *v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v42;
  unint64_t v43;
  const __CFString *Object15;
  const __CFString *v45;
  const void *v46;
  CFTypeID v47;
  const __CFString *v48;
  CFURLRef v49;
  uint64_t v50;
  const void *v51;
  unint64_t v52;
  int v53;
  void **v54;
  __CFArray *Mutable;
  const char *v56;
  const char *v57;
  unint64_t v58;
  const __CFURL *v59;
  Class v60;
  Class v61;
  const char *v62;
  uint64_t v63;
  uint64_t v64;
  const void **v65;
  const void *v66;
  unint64_t v67;
  char *v68;
  unint64_t v69;
  CFStringEncoding v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  size_t v75;
  UniChar *Typed;
  UniChar *v77;
  UniChar *v78;
  CFIndex v79;
  unint64_t v80;
  unint64_t v81;
  void *values[2];
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  uint64_t v114;
  CFUUIDBytes v115;
  CFRange v116;

  v114 = *MEMORY[0x1E0C80C00];
  v3 = a1 + a2;
  v4 = a1 + a2 - 1;
  v5 = (unint64_t)*a3;
  if ((unint64_t)*a3 < a1 + 22 || v4 < v5)
    return 0;
  v9 = (char *)(v5 + 1);
  v10 = *(unsigned __int8 *)v5;
  *a3 = (const void *)(v5 + 1);
  if (v5 == -1)
    return 0;
  v11 = 0;
  switch(v10 >> 4)
  {
    case 0u:
      v11 = 0;
      switch(v10)
      {
        case 0u:
          v17 = &kCFNull;
          return *v17;
        case 8u:
          v17 = &kCFBooleanFalse;
          return *v17;
        case 9u:
          v17 = &kCFBooleanTrue;
          return *v17;
        case 0xCu:
          Object15 = (const __CFString *)__readObject15(a1, a2, a3);
          if (!Object15)
            return 0;
          v45 = Object15;
          if (CFGetTypeID(Object15) != 7)
            goto LABEL_141;
          v11 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v45, 0);
          v46 = v45;
          goto LABEL_138;
        case 0xDu:
          v11 = (const __CFURL *)__readObject15(a1, a2, a3);
          if (!v11)
            return v11;
          v47 = CFURLGetTypeID();
          if (v47 == CFGetTypeID(v11) && (v48 = (const __CFString *)__readObject15(a1, a2, a3)) != 0)
          {
            v45 = v48;
            if (CFGetTypeID(v48) == 7)
            {
              v49 = CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v45, v11);
              CFRelease(v11);
              CFRelease(v45);
              return v49;
            }
            CFRelease(v11);
LABEL_141:
            v51 = v45;
          }
          else
          {
            v51 = v11;
          }
          break;
        case 0xEu:
          if (v5 > 0xFFFFFFFFFFFFFFEELL || v3 < v5 + 17)
            return 0;
          v50 = *(_QWORD *)v9;
          *(_QWORD *)&v115.byte8 = *(_QWORD *)(v5 + 9);
          *a3 = (const void *)(v5 + 17);
          *(_QWORD *)&v115.byte0 = v50;
          return CFUUIDCreateFromUUIDBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, v115);
        default:
          return v11;
      }
      goto LABEL_142;
    case 1u:
      if ((v10 & 0xF) > 4)
        return 0;
      if ((v10 & 0xF) != 4)
      {
        if (v3 >= (unint64_t)v9 && (*(_BYTE *)v5 & 0xF0) == 0x10)
        {
          v40 = 1 << (*(_BYTE *)v5 & 0xF);
          if (v5 < ~v40 && v3 >= (unint64_t)&v9[v40])
          {
            v11 = 0;
            switch((int)v40)
            {
              case 1:
                v42 = *v9;
                if ((int)v42 >= 0)
                  v43 = v42 - 128;
                else
                  v43 = *v9 ^ 0x80;
                goto LABEL_200;
              case 2:
                v81 = (__int16)(*(unsigned __int8 *)(v5 + 2) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 1);
                if ((v81 & 0x80000000) == 0)
                  v43 = v81 - 0x8000;
                else
                  v43 = (unsigned __int16)v81 ^ 0x8000u;
                goto LABEL_200;
              case 4:
                v43 = *(int *)v9 ^ 0xFFFFFFFF80000000;
                goto LABEL_200;
              case 8:
                v43 = *(_QWORD *)v9 ^ 0x8000000000000000;
LABEL_200:
                values[0] = (void *)v43;
                *a3 = &v9[v40];
                v20 = kCFNumberSInt64Type;
                return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v20, values);
              default:
                return v11;
            }
          }
        }
        return 0;
      }
      v11 = 0;
      if (v5 <= 0xFFFFFFFFFFFFFFEELL && v3 >= v5 + 17)
      {
        v18 = *(void **)v9;
        *a3 = (const void *)(v5 + 9);
        v19 = *(_QWORD *)(v5 + 9);
        *a3 = (const void *)(v5 + 17);
        values[0] = (void *)(v19 ^ 0x8000000000000000);
        values[1] = v18;
        v20 = kCFNumberMaxType|kCFNumberSInt8Type;
        return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v20, values);
      }
      return v11;
    case 2u:
      if ((v10 & 0xF) == 3)
      {
        if (v5 <= 0xFFFFFFFFFFFFFFF6 && v3 >= v5 + 9)
        {
          v39 = *(_QWORD *)v9;
          *a3 = (const void *)(v5 + 9);
          values[0] = (void *)bswap64(v39);
          v20 = kCFNumberFloat64Type;
          return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v20, values);
        }
      }
      else if ((v10 & 0xF) == 2 && v5 <= 0xFFFFFFFFFFFFFFFALL && v3 >= v5 + 5)
      {
        v21 = *(_DWORD *)v9;
        *a3 = (const void *)(v5 + 5);
        LODWORD(values[0]) = bswap32(v21);
        v20 = kCFNumberFloat32Type;
        return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v20, values);
      }
      return 0;
    case 3u:
      v11 = 0;
      if (v5 > 0xFFFFFFFFFFFFFFF6 || v10 != 51)
        return v11;
      if (v3 < v5 + 9)
        return 0;
      v22 = *(_QWORD *)v9;
      *a3 = (const void *)(v5 + 9);
      return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, COERCE_CFABSOLUTETIME(bswap64(v22)));
    case 4u:
      v24 = v10 & 0xF;
      if ((_DWORD)v24 != 15)
        goto LABEL_149;
      if (v4 < (unint64_t)v9)
        return 0;
      v25 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10)
        return 0;
      v11 = 0;
      v26 = 1 << (*v9 & 0xF);
      if (__CFADD__(v26, v25) || v3 < (unint64_t)&v25[v26])
        return v11;
      v11 = 0;
      switch((int)v26)
      {
        case 1:
          v27 = (char)*v25;
          if ((int)v27 >= 0)
            v24 = v27 - 128;
          else
            v24 = *v25 ^ 0x80;
          break;
        case 2:
          v67 = (__int16)(*(unsigned __int8 *)(v5 + 3) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 2);
          if ((v67 & 0x80000000) == 0)
            v24 = v67 - 0x8000;
          else
            v24 = (unsigned __int16)v67 ^ 0x8000u;
          break;
        case 4:
          v24 = *(int *)v25 ^ 0xFFFFFFFF80000000;
          break;
        case 8:
          v24 = *(_QWORD *)(v5 + 2) ^ 0x8000000000000000;
          break;
        default:
          return v11;
      }
      v9 = (char *)&v25[v26];
      *a3 = &v25[v26];
LABEL_149:
      if (__CFADD__(v24, v9))
        return 0;
      v68 = &v9[v24];
      if (v3 < (unint64_t)&v9[v24])
        return 0;
      result = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v9, v24);
      goto LABEL_194;
    case 5u:
      v28 = v10 & 0xF;
      if ((_DWORD)v28 != 15)
        goto LABEL_158;
      if (v4 < (unint64_t)v9)
        return 0;
      v29 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10)
        return 0;
      v11 = 0;
      v30 = 1 << (*v9 & 0xF);
      if (__CFADD__(v30, v29) || v3 < (unint64_t)&v29[v30])
        return v11;
      v11 = 0;
      switch((int)v30)
      {
        case 1:
          v31 = (char)*v29;
          if ((int)v31 >= 0)
            v28 = v31 - 128;
          else
            v28 = *v29 ^ 0x80;
          break;
        case 2:
          v69 = (__int16)(*(unsigned __int8 *)(v5 + 3) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 2);
          if ((v69 & 0x80000000) == 0)
            v28 = v69 - 0x8000;
          else
            v28 = (unsigned __int16)v69 ^ 0x8000u;
          break;
        case 4:
          v28 = *(int *)v29 ^ 0xFFFFFFFF80000000;
          break;
        case 8:
          v28 = *(_QWORD *)(v5 + 2) ^ 0x8000000000000000;
          break;
        default:
          return v11;
      }
      v9 = (char *)&v29[v30];
      *a3 = &v29[v30];
LABEL_158:
      if (__CFADD__(v28, v9))
        return 0;
      v68 = &v9[v28];
      if (v3 < (unint64_t)&v9[v28])
        return 0;
      v70 = 1536;
      goto LABEL_193;
    case 6u:
      v32 = v10 & 0xF;
      if ((_DWORD)v32 == 15)
      {
        if (v4 < (unint64_t)v9)
          return 0;
        v33 = (unsigned __int8 *)(v5 + 2);
        if ((*v9 & 0xF0) != 0x10)
          return 0;
        v11 = 0;
        v34 = 1 << (*v9 & 0xF);
        if (!__CFADD__(v34, v33) && v3 >= (unint64_t)&v33[v34])
        {
          v11 = 0;
          switch((int)v34)
          {
            case 1:
              v35 = (char)*v33;
              if ((int)v35 >= 0)
                v32 = v35 - 128;
              else
                v32 = *v33 ^ 0x80;
              goto LABEL_166;
            case 2:
              v71 = (__int16)(v9[2] << 8) | (unint64_t)v9[1];
              if ((v71 & 0x80000000) == 0)
                v32 = v71 - 0x8000;
              else
                v32 = (unsigned __int16)v71 ^ 0x8000u;
              goto LABEL_166;
            case 4:
              v32 = *(int *)v33 ^ 0xFFFFFFFF80000000;
              goto LABEL_166;
            case 8:
              v32 = *(_QWORD *)(v9 + 1) ^ 0x8000000000000000;
LABEL_166:
              v9 = (char *)&v33[v34];
              *a3 = &v33[v34];
              goto LABEL_167;
            default:
              return v11;
          }
        }
        return v11;
      }
LABEL_167:
      v72 = (unint64_t)&v9[v32 - 1];
      if (~v32 >= v72)
      {
        v73 = v32 + v72;
        if ((unint64_t)v9 <= ~v32 && v4 >= v73)
        {
          if (v32)
          {
            if (v32 < 0)
              return 0;
            v75 = 2 * v32;
          }
          else
          {
            v75 = 0;
          }
          Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v75, 724697696, 0);
          if (Typed)
          {
            v77 = Typed;
            memmove(Typed, *a3, v75);
            if (v32)
            {
              v78 = v77;
              v79 = v32;
              do
              {
                *v78 = bswap32(*v78) >> 16;
                ++v78;
                --v79;
              }
              while (v79);
            }
            v11 = (const __CFURL *)CFStringCreateWithCharacters((CFAllocatorRef)&__kCFAllocatorSystemDefault, v77, v32);
            CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v77);
            *a3 = (const void *)(v73 + 1);
            return v11;
          }
        }
      }
      return 0;
    case 7u:
      v28 = v10 & 0xF;
      if ((_DWORD)v28 != 15)
        goto LABEL_188;
      if (v4 < (unint64_t)v9)
        return 0;
      v36 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10)
        return 0;
      v11 = 0;
      v37 = 1 << (*v9 & 0xF);
      if (__CFADD__(v37, v36) || v3 < (unint64_t)&v36[v37])
        return v11;
      v11 = 0;
      switch((int)v37)
      {
        case 1:
          v38 = (char)*v36;
          if ((int)v38 >= 0)
            v28 = v38 - 128;
          else
            v28 = *v36 ^ 0x80;
          break;
        case 2:
          v80 = (__int16)(*(unsigned __int8 *)(v5 + 3) << 8) | (unint64_t)*(unsigned __int8 *)(v5 + 2);
          if ((v80 & 0x80000000) == 0)
            v28 = v80 - 0x8000;
          else
            v28 = (unsigned __int16)v80 ^ 0x8000u;
          break;
        case 4:
          v28 = *(int *)v36 ^ 0xFFFFFFFF80000000;
          break;
        case 8:
          v28 = *(_QWORD *)(v5 + 2) ^ 0x8000000000000000;
          break;
        default:
          return v11;
      }
      v9 = (char *)&v36[v37];
      *a3 = &v36[v37];
LABEL_188:
      if (__CFADD__(v28, v9))
        return 0;
      v68 = &v9[v28];
      if (v3 < (unint64_t)&v9[v28])
        return 0;
      v70 = 134217984;
LABEL_193:
      result = (CFDateRef)CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v9, v28, v70, 0);
LABEL_194:
      *a3 = v68;
      return result;
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0xDu:
      v13 = v10 & 0xF;
      if ((_DWORD)v13 != 15)
      {
LABEL_104:
        v53 = v10 & 0xF0;
        if (v53 == 208)
        {
          if (v13)
          {
            if (v13 < 0)
              return 0;
            v13 *= 2;
LABEL_109:
            if ((unint64_t)v13 >> 61)
              return 0;
            v112 = 0u;
            v113 = 0u;
            v110 = 0u;
            v111 = 0u;
            v108 = 0u;
            v109 = 0u;
            v106 = 0u;
            v107 = 0u;
            v104 = 0u;
            v105 = 0u;
            v102 = 0u;
            v103 = 0u;
            v100 = 0u;
            v101 = 0u;
            v98 = 0u;
            v99 = 0u;
            v96 = 0u;
            v97 = 0u;
            v94 = 0u;
            v95 = 0u;
            v92 = 0u;
            v93 = 0u;
            v90 = 0u;
            v91 = 0u;
            v88 = 0u;
            v89 = 0u;
            v86 = 0u;
            v87 = 0u;
            v84 = 0u;
            v85 = 0u;
            *(_OWORD *)values = 0u;
            v83 = 0u;
            if ((unint64_t)v13 >= 0x101)
            {
              v54 = (void **)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * v13, 2666184794, 0);
              if (!v54)
                return 0;
            }
            else
            {
              v54 = values;
            }
            Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
            v58 = 0;
            while (1)
            {
              v59 = (const __CFURL *)__readObject15(a1, a2, a3);
              v11 = v59;
              if (!v59)
              {
                v46 = Mutable;
LABEL_138:
                CFRelease(v46);
                return v11;
              }
              if (v53 == 208 && v58 < (unint64_t)v13 >> 1 && CFGetTypeID(v59) - 17 <= 2)
                break;
              CFArrayAppendValue(Mutable, v11);
              if (v13 == ++v58)
                goto LABEL_113;
            }
            CFRelease(v11);
            v51 = Mutable;
LABEL_142:
            CFRelease(v51);
            return 0;
          }
        }
        else if (v13)
        {
          goto LABEL_109;
        }
        v112 = 0u;
        v113 = 0u;
        v110 = 0u;
        v111 = 0u;
        v108 = 0u;
        v109 = 0u;
        v106 = 0u;
        v107 = 0u;
        v104 = 0u;
        v105 = 0u;
        v102 = 0u;
        v103 = 0u;
        v100 = 0u;
        v101 = 0u;
        v98 = 0u;
        v99 = 0u;
        v96 = 0u;
        v97 = 0u;
        v94 = 0u;
        v95 = 0u;
        v92 = 0u;
        v93 = 0u;
        v90 = 0u;
        v91 = 0u;
        v88 = 0u;
        v89 = 0u;
        v86 = 0u;
        v87 = 0u;
        v84 = 0u;
        v85 = 0u;
        *(_OWORD *)values = 0u;
        v83 = 0u;
        Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
        v13 = 0;
        v54 = values;
LABEL_113:
        v116.location = 0;
        v116.length = v13;
        CFArrayGetValues(Mutable, v116, (const void **)v54);
        switch(v53)
        {
          case 160:
            v56 = "newArrayWithObjects:count:";
            v57 = "NSArray";
            break;
          case 192:
            v56 = "newSetWithObjects:count:";
            v57 = "NSSet";
            break;
          case 176:
            v56 = "newOrderedSetWithObjects:count:";
            v57 = "NSOrderedSet";
            break;
          default:
            v61 = __CFLookUpClass("NSDictionary");
            v62 = sel_registerName("newDictionaryWithObjects:forKeys:count:");
            if (v13 >= 0)
              v63 = v13;
            else
              v63 = v13 + 1;
            v64 = v63 >> 1;
            v11 = (const __CFURL *)objc_msgSend(v61, v62, &v54[v63 >> 1], v54, v63 >> 1);
            if (v13 >= 2)
            {
              v65 = (const void **)v54;
              do
              {
                v66 = *v65++;
                CFRelease(v66);
                --v64;
              }
              while (v64);
            }
            goto LABEL_128;
        }
        v60 = __CFLookUpClass(v57);
        v11 = (const __CFURL *)objc_msgSend(v60, sel_registerName(v56), v54, v13);
LABEL_128:
        CFRelease(Mutable);
        if (v54 != values)
          CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v54);
        return v11;
      }
      if (v4 < (unint64_t)v9)
        return 0;
      v14 = (unsigned __int8 *)(v5 + 2);
      if ((*v9 & 0xF0) != 0x10)
        return 0;
      v11 = 0;
      v15 = 1 << (*v9 & 0xF);
      if (!__CFADD__(v15, v14) && v3 >= (unint64_t)&v14[v15])
      {
        v11 = 0;
        switch((int)v15)
        {
          case 1:
            v16 = (char)*v14;
            if ((int)v16 >= 0)
              v13 = v16 - 128;
            else
              v13 = *v14 ^ 0x80;
            goto LABEL_103;
          case 2:
            v52 = (__int16)(v9[2] << 8) | (unint64_t)v9[1];
            if ((v52 & 0x80000000) == 0)
              v13 = v52 - 0x8000;
            else
              v13 = (unsigned __int16)v52 ^ 0x8000u;
            goto LABEL_103;
          case 4:
            v13 = *(int *)v14 ^ 0xFFFFFFFF80000000;
            goto LABEL_103;
          case 8:
            v13 = *(_QWORD *)(v9 + 1) ^ 0x8000000000000000;
LABEL_103:
            *a3 = &v14[v15];
            goto LABEL_104;
          default:
            return v11;
        }
      }
      return v11;
    default:
      return v11;
  }
}

Class __CFLookUpClass(const char *a1)
{
  Class result;
  objc_class *v3;
  objc_class *ClassPair;
  objc_class *v5;

  result = objc_lookUpClass(a1);
  if (!result)
  {
    if (!dlopen("/System/Library/Frameworks/Foundation.framework/Foundation", 5))
    {
      dlerror();
      CFLog(3, CFSTR("*** Error: Could not load Foundation for class %s; error is '%s'; if this seems unreasonable, perhaps seatbelt has prevented the load due to file access limitations on the process"));
    }
    result = objc_lookUpClass(a1);
    if (!result)
    {
      if (!strcmp(a1, "NSString") || !strcmp(a1, "NSMutableString"))
      {
        v3 = (objc_class *)objc_opt_self();
        ClassPair = objc_allocateClassPair(v3, "NSString", 0x20uLL);
        objc_registerClassPair(ClassPair);
        v5 = objc_allocateClassPair(ClassPair, "NSMutableString", 0x20uLL);
        objc_registerClassPair(v5);
        return objc_lookUpClass(a1);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void __getDefaultArguments_block_invoke()
{
  NSArray *v0;
  uint64_t v1;
  uint64_t v2;
  id v3;
  uint64_t v4;
  __CFString *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  __CFString *v9;
  id v10;
  const __CFData *v11;
  CFErrorRef error;
  id v13[2];

  v13[1] = *(id *)MEMORY[0x1E0C80C00];
  if (!issetugid())
  {
    getDefaultArguments___NSDefaultArguments = objc_opt_new();
    v0 = -[NSProcessInfo arguments](+[NSProcessInfo processInfo](&off_1EDCDCE48, "processInfo"), "arguments");
    v1 = -[NSArray count](v0, "count") - 1;
    if (v1 >= 2)
    {
      v2 = 1;
      do
      {
        v3 = -[NSArray objectAtIndex:](v0, "objectAtIndex:", v2);
        v4 = v2 + 1;
        if (!objc_msgSend(v3, "hasPrefix:", CFSTR("-")))
          goto LABEL_20;
        v5 = -[NSArray objectAtIndex:](v0, "objectAtIndex:", v2 + 1);
        if ((-[__CFString hasPrefix:](v5, "hasPrefix:", CFSTR("-")) & 1) != 0)
          goto LABEL_20;
        v6 = -[__CFString rangeOfCharacterFromSet:options:range:](v5, "rangeOfCharacterFromSet:options:range:", -[NSCharacterSet invertedSet](+[NSCharacterSet whitespaceAndNewlineCharacterSet](&off_1EDCDD1E0, "whitespaceAndNewlineCharacterSet"), "invertedSet"), 0, 0, -[__CFString length](v5, "length"));
        if (!v7)
        {
          v5 = &stru_1E1337B18;
LABEL_18:
          objc_msgSend((id)getDefaultArguments___NSDefaultArguments, "setObject:forKeyedSubscript:", v5, objc_msgSend(v3, "substringFromIndex:", 1));
          goto LABEL_19;
        }
        v8 = -[__CFString characterAtIndex:](v5, "characterAtIndex:", v6);
        if (((v8 - 34) > 0x39 || ((1 << (v8 - 34)) & 0x200000004000041) == 0)
          && v8 != 123)
        {
          goto LABEL_18;
        }
        v13[0] = 0;
        v9 = (__CFString *)(id)_CFPropertyListCreateFromXMLString((const __CFAllocator *)&__kCFAllocatorSystemDefault, v5, 0, (CFStringRef *)v13, 1, 0);
        if (v13[0])
        {
          v10 = v13[0];
          v11 = (const __CFData *)-[__CFString dataUsingEncoding:allowLossyConversion:](v5, "dataUsingEncoding:allowLossyConversion:", 4, 0);
          error = 0;
          v5 = (id)CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v11, 0, 0, &error);
          if (!v5 && error)
          {
            CFRelease(error);
            goto LABEL_19;
          }
        }
        else
        {
          v5 = v9;
        }
        if (v5)
          goto LABEL_18;
LABEL_19:
        v4 = v2 + 2;
LABEL_20:
        v2 = v4;
      }
      while (v4 < v1);
    }
  }
}

uint64_t _CFPropertyListCreateFromXMLString(const __CFAllocator *a1, const __CFString *a2, int a3, CFStringRef *a4, char a5, _QWORD *a6)
{
  uint64_t v7;
  CFErrorRef v8;
  const __CFDictionary *v9;
  int ValueIfPresent;
  const __CFString *v11;
  CFStringRef v12;
  CFDictionaryRef v13;
  const void *v14;
  void *value;
  CFErrorRef err[2];

  err[1] = *(CFErrorRef *)MEMORY[0x1E0C80C00];
  if (a4)
    *a4 = 0;
  err[0] = 0;
  v7 = _CFPropertyListCreateFromXMLStringError(a1, a2, a3, err, a5, a6);
  v8 = err[0];
  if (a4 && err[0])
  {
    v9 = CFErrorCopyUserInfo(err[0]);
    value = 0;
    ValueIfPresent = CFDictionaryGetValueIfPresent(v9, CFSTR("kCFPropertyListOldStyleParsingError"), (const void **)&value);
    v11 = (const __CFString *)CFDictionaryGetValue(v9, CFSTR("NSDebugDescription"));
    v12 = v11;
    if (ValueIfPresent)
    {
      v13 = CFErrorCopyUserInfo((CFErrorRef)value);
      v14 = CFDictionaryGetValue(v9, CFSTR("NSDebugDescription"));
      v12 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("XML parser error:\n\t%@\nOld-style plist parser error:\n\t%@\n"), v12, v14);
      CFRelease(v13);
    }
    else if (v11)
    {
      CFRetain(v11);
    }
    CFRelease(v9);
    *a4 = v12;
    v8 = err[0];
  }
  if (v8)
    CFRelease(v8);
  return v7;
}

uint64_t _CFPropertyListCreateFromXMLStringError(const __CFAllocator *a1, const __CFString *a2, int a3, _QWORD *a4, char a5, _QWORD *a6)
{
  const __CFData *UTF8DataFromString;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  UTF8DataFromString = _createUTF8DataFromString(a1, a2);
  v14[0] = 0;
  _CFPropertyListCreateFromUTF8Data(a1, UTF8DataFromString, 0, a2, 0, a3, a4, a5, a6, 0, v14, 1, 1);
  if (UTF8DataFromString)
    CFRelease(UTF8DataFromString);
  return v14[0];
}

CFDataRef _createUTF8DataFromString(const __CFAllocator *a1, CFStringRef theString)
{
  UInt8 *Typed;
  CFIndex maxBufLen[2];
  CFRange v7;
  CFRange v8;

  maxBufLen[1] = *MEMORY[0x1E0C80C00];
  maxBufLen[0] = 0;
  v7.length = CFStringGetLength(theString);
  v7.location = 0;
  CFStringGetBytes(theString, v7, 0x8000100u, 0, 0, 0, 0, maxBufLen);
  Typed = (UInt8 *)CFAllocatorAllocateTyped(a1, maxBufLen[0], 143755134, 0);
  v8.length = CFStringGetLength(theString);
  v8.location = 0;
  CFStringGetBytes(theString, v8, 0x8000100u, 0, 0, Typed, maxBufLen[0], 0);
  return CFDataCreateWithBytesNoCopy(a1, Typed, maxBufLen[0], a1);
}

CFAttributedStringRef CFAttributedStringCreateCopy(CFAllocatorRef alloc, CFAttributedStringRef aStr)
{
  unint64_t *MutableWithSubstring;
  char v5;
  CFAllocatorRef v6;
  const CFAllocatorRef *v7;
  uint64_t v8;
  char v9;
  CFIndex Length;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  int v14;

  MutableWithSubstring = (unint64_t *)aStr;
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    return (CFAttributedStringRef)objc_msgSend(MutableWithSubstring, "copy");
  v5 = atomic_load(MutableWithSubstring + 1);
  if ((v5 & 1) == 0)
    goto LABEL_14;
  v6 = alloc;
  if (alloc)
  {
    if (((unint64_t)MutableWithSubstring & 0x8000000000000000) != 0)
    {
LABEL_6:
      v7 = &kCFAllocatorSystemDefault;
      goto LABEL_13;
    }
  }
  else
  {
    v8 = _CFGetTSD(1u);
    v6 = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
    if (v8)
      v6 = (CFAllocatorRef)v8;
    if (((unint64_t)MutableWithSubstring & 0x8000000000000000) != 0)
      goto LABEL_6;
  }
  v9 = atomic_load(MutableWithSubstring + 1);
  if (v9 < 0)
    v7 = &kCFAllocatorSystemDefault;
  else
    v7 = (const CFAllocatorRef *)(MutableWithSubstring - 2);
LABEL_13:
  if (v6 != *v7)
  {
LABEL_14:
    Length = CFAttributedStringGetLength((CFAttributedStringRef)MutableWithSubstring);
    MutableWithSubstring = (unint64_t *)__CFAttributedStringCreateMutableWithSubstring(alloc, (CFStringRef *)MutableWithSubstring, 0, Length);
    v11 = MutableWithSubstring + 1;
    v12 = atomic_load(MutableWithSubstring + 1);
    while (1)
    {
      v13 = __ldaxr(v11);
      if (v13 != v12)
        break;
      if (__stlxr(v12 | 1, v11))
        goto LABEL_19;
      v14 = 1;
LABEL_20:
      v12 = v13;
      if (v14)
        return (CFAttributedStringRef)MutableWithSubstring;
    }
    __clrex();
LABEL_19:
    v14 = 0;
    goto LABEL_20;
  }
  CFRetain(MutableWithSubstring);
  return (CFAttributedStringRef)MutableWithSubstring;
}

CFIndex CFAttributedStringGetLength(CFAttributedStringRef aStr)
{
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    return -[__CFAttributedString length](aStr, "length");
  else
    return CFStringGetLength(*((CFStringRef *)aStr + 2));
}

CFAttributedStringRef CFAttributedStringCreate(CFAllocatorRef alloc, CFStringRef str, CFDictionaryRef attributes)
{
  uint64_t Instance;
  CFIndex Length;
  uint64_t v8;
  CFMutableDictionaryRef AttributesDictionary;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  int v13;

  Instance = _CFRuntimeCreateInstance((__objc2_class **)alloc, 0x3EuLL, 16, 0);
  if (Instance)
  {
    *(_QWORD *)(Instance + 16) = CFStringCreateCopy(alloc, str);
    *(_QWORD *)(Instance + 24) = CFRunArrayCreate((__objc2_class **)alloc);
    Length = CFStringGetLength(*(CFStringRef *)(Instance + 16));
    if (Length)
    {
      v8 = Length;
      AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(alloc, attributes);
      CFRunArrayInsert(*(CFTypeRef *)(Instance + 24), 0, v8, AttributesDictionary);
      CFRelease(AttributesDictionary);
    }
    v10 = (unint64_t *)(Instance + 8);
    v11 = atomic_load((unint64_t *)(Instance + 8));
    while (1)
    {
      v12 = __ldaxr(v10);
      if (v12 != v11)
        break;
      if (__stlxr(v11 | 1, v10))
        goto LABEL_9;
      v13 = 1;
LABEL_10:
      v11 = v12;
      if (v13)
        return (CFAttributedStringRef)Instance;
    }
    __clrex();
LABEL_9:
    v13 = 0;
    goto LABEL_10;
  }
  return (CFAttributedStringRef)Instance;
}

__CFAttributedString *__CFAttributedStringCreateMutableWithSubstring(const __CFAllocator *a1, CFStringRef *a2, CFIndex a3, CFIndex a4)
{
  __CFAttributedString *Mutable;
  const __CFString *v9;
  CFIndex v10;
  CFIndex v11;
  const __CFDictionary *Attributes;
  CFRange v13;
  CFRange effectiveRange;
  uint64_t v17;
  CFRange v18;
  CFRange v19;

  v17 = *MEMORY[0x1E0C80C00];
  Mutable = CFAttributedStringCreateMutable(a1, 0);
  v19.location = a3;
  v19.length = a4;
  v9 = CFStringCreateWithSubstring(a1, a2[2], v19);
  v18.location = 0;
  v18.length = 0;
  CFAttributedStringReplaceString(Mutable, v18, v9);
  CFRelease(v9);
  if (a4 >= 1)
  {
    v10 = a3 + a4;
    v11 = a3;
    do
    {
      effectiveRange.location = 0;
      effectiveRange.length = 0;
      Attributes = CFAttributedStringGetAttributes((CFAttributedStringRef)a2, v11, &effectiveRange);
      if (effectiveRange.location + effectiveRange.length <= v10)
        v13.length = effectiveRange.location - v11 + effectiveRange.length;
      else
        v13.length = v10 - v11;
      if (effectiveRange.location != v11 || effectiveRange.location + effectiveRange.length > v10)
        effectiveRange.length = v13.length;
      v13.location = v11 - a3;
      CFAttributedStringSetAttributes(Mutable, v13, Attributes, 1u);
      v11 += effectiveRange.length;
    }
    while (v11 < v10);
  }
  return Mutable;
}

CFDictionaryRef CFAttributedStringGetAttributesAndLongestEffectiveRange(CFAttributedStringRef aStr, CFIndex loc, CFRange inRange, CFRange *longestEffectiveRange)
{
  CFIndex length;
  CFIndex location;
  CFDictionaryRef Attributes;
  CFIndex v11;
  CFIndex v12;
  CFDictionaryRef v13;
  CFIndex v14;
  CFDictionaryRef v15;
  CFIndex v16;
  CFIndex v17;
  CFRange v18;
  uint64_t v19;

  length = inRange.length;
  location = inRange.location;
  v19 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    return (CFDictionaryRef)-[__CFAttributedString attributesAtIndex:longestEffectiveRange:inRange:](aStr, "attributesAtIndex:longestEffectiveRange:inRange:", loc, longestEffectiveRange, location, length);
  Attributes = CFAttributedStringGetAttributes(aStr, loc, longestEffectiveRange);
  if (longestEffectiveRange)
  {
    v18 = *longestEffectiveRange;
    v11 = location + length;
    do
    {
      v12 = v18.length + v18.location;
      if (v18.length + v18.location >= v11)
        break;
      v13 = CFAttributedStringGetAttributes(aStr, v18.length + v18.location, &v18);
    }
    while (CFEqual(v13, Attributes));
    v18 = *longestEffectiveRange;
    do
    {
      v14 = v18.location;
      if (v18.location <= location)
        break;
      v15 = CFAttributedStringGetAttributes(aStr, v18.location - 1, &v18);
    }
    while (CFEqual(v15, Attributes));
    if (v14 <= location)
      v16 = location;
    else
      v16 = v14;
    if (v11 >= v12)
      v17 = v12;
    else
      v17 = v11;
    longestEffectiveRange->location = v16;
    longestEffectiveRange->length = v17 - v16;
  }
  return Attributes;
}

CFDictionaryRef CFAttributedStringGetAttributes(CFAttributedStringRef aStr, CFIndex loc, CFRange *effectiveRange)
{
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
    return (CFDictionaryRef)-[__CFAttributedString attributesAtIndex:effectiveRange:](aStr, "attributesAtIndex:effectiveRange:", loc, effectiveRange);
  else
    return (CFDictionaryRef)CFRunArrayGetValueAtIndex(*((_QWORD *)aStr + 3), loc, &effectiveRange->location, 0);
}

uint64_t CFRunArrayGetValueAtIndex(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v6;

  v6 = blockForLocation(*(_QWORD *)(a1 + 16), a2, a3);
  if (a4)
    *a4 = v6;
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16 * v6 + 56);
}

uint64_t blockForLocation(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v3 = *(_QWORD *)(a1 + 40);
  if (v3 >= 0)
    v4 = *(_QWORD *)(a1 + 40);
  else
    v4 = v3 + 1;
  if (a2 <= v4 >> 1)
  {
    v3 = 0;
    v5 = 0;
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 32);
  }
  v6 = a1 + 16 * v5;
  if (v3 <= a2)
  {
    --v5;
    v11 = (uint64_t *)(v6 + 48);
    do
    {
      v12 = v3;
      v13 = *v11;
      v11 += 2;
      v9 = v13;
      v3 += v13;
      ++v5;
    }
    while (v3 <= a2);
    v3 = v12;
  }
  else
  {
    v7 = (uint64_t *)(v6 + 32);
    do
    {
      v8 = v5--;
      v10 = *v7;
      v7 -= 2;
      v9 = v10;
      v3 -= v10;
    }
    while (v8 >= 2 && v3 > a2);
  }
  *(_QWORD *)(a1 + 32) = v5;
  *(_QWORD *)(a1 + 40) = v3;
  if (a3)
  {
    *a3 = v3;
    a3[1] = v9;
  }
  return v5;
}

CFMutableAttributedStringRef CFAttributedStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  __CFAttributedString *Instance;

  Instance = (__CFAttributedString *)_CFRuntimeCreateInstance((__objc2_class **)alloc, 0x3EuLL, 16, 0);
  if (Instance)
  {
    *((_QWORD *)Instance + 2) = CFStringCreateMutable(alloc, maxLength);
    *((_QWORD *)Instance + 3) = CFRunArrayCreate((__objc2_class **)alloc);
  }
  return Instance;
}

_QWORD *_CFRunArrayCreateWithGuts(__objc2_class **a1, uint64_t a2)
{
  _QWORD *Instance;
  _QWORD *v4;
  CFAllocatorRef v5;
  _QWORD *Typed;

  Instance = (_QWORD *)_CFRuntimeCreateInstance(a1, 0x3FuLL, 8, 0);
  v4 = Instance;
  if (Instance)
  {
    if (a2)
    {
      Instance[2] = a2;
      os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
      ++*(_QWORD *)v4[2];
      os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    }
    else
    {
      v5 = CFGetAllocator(Instance);
      Typed = (_QWORD *)CFAllocatorAllocateTyped(v5, 80, 1930815021, 0);
      Typed[2] = 0;
      Typed[3] = 2;
      Typed[4] = 0;
      Typed[5] = 0;
      *Typed = 1;
      Typed[1] = 0;
      v4[2] = Typed;
    }
  }
  return v4;
}

_QWORD *CFRunArrayCreate(__objc2_class **a1)
{
  return _CFRunArrayCreateWithGuts(a1, 0);
}

void CFAttributedStringReplaceString(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef replacement)
{
  CFIndex length;
  CFIndex location;
  CFIndex v7;
  uint64_t v8;
  const void *ValueAtIndex;
  uint64_t v10;
  uint64_t v11;
  const __CFAllocator *v12;
  CFRange v13;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
  {
    -[__CFAttributedString replaceCharactersInRange:withString:](aStr, "replaceCharactersInRange:withString:", location, length, replacement);
    return;
  }
  v7 = CFStringGetLength(replacement);
  v8 = v7;
  if (v7 >= 1)
  {
    if (length >= 1)
    {
      ValueAtIndex = (const void *)CFRunArrayGetValueAtIndex(*((_QWORD *)aStr + 3), location, 0, 0);
      CFRetain(ValueAtIndex);
      goto LABEL_8;
    }
    v10 = location - 1;
    if (location < 1)
    {
      if (CFStringGetLength(*((CFStringRef *)aStr + 2)) < 1)
      {
        v12 = CFGetAllocator(aStr);
        ValueAtIndex = CFDictionaryCreateMutable(v12, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
LABEL_17:
        CFRunArrayInsert(*((CFTypeRef *)aStr + 3), location, v8, ValueAtIndex);
        if (ValueAtIndex)
        {
LABEL_18:
          CFRelease(ValueAtIndex);
          goto LABEL_19;
        }
        goto LABEL_19;
      }
      v11 = *((_QWORD *)aStr + 3);
      v10 = 0;
    }
    else
    {
      v11 = *((_QWORD *)aStr + 3);
    }
    ValueAtIndex = (const void *)CFRunArrayGetValueAtIndex(v11, v10, 0, 0);
    CFRetain(ValueAtIndex);
    goto LABEL_17;
  }
  if (length >= 1)
  {
    ValueAtIndex = 0;
LABEL_8:
    CFRunArrayReplace(*((_QWORD **)aStr + 3), location, length, ValueAtIndex, v8);
    if (!ValueAtIndex)
      goto LABEL_19;
    goto LABEL_18;
  }
  if (v7)
  {
    ValueAtIndex = 0;
    goto LABEL_17;
  }
LABEL_19:
  v13.location = location;
  v13.length = length;
  CFStringReplace(*((CFMutableStringRef *)aStr + 2), v13, replacement);
}

CFTypeRef CFRunArrayInsert(CFTypeRef result, uint64_t a2, uint64_t a3, const void *a4)
{
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  CFTypeRef v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v7 = result;
    v8 = (uint64_t *)*((_QWORD *)result + 2);
    os_unfair_lock_lock((os_unfair_lock_t)&runArrayLock);
    if (*v8 >= 2)
    {
      __CFRunArrayMakeNewList(v7, v8);
      v8 = (uint64_t *)v7[2];
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&runArrayLock);
    if (a2 == v8[1])
    {
      if (a2 < 1)
      {
        __CFRunArraySetBlockCapacity(v7, 1);
        v8 = (uint64_t *)v7[2];
        result = CFRetain(a4);
        v8[6] = a3;
        v8[7] = (uint64_t)result;
        v14 = v8[2];
      }
      else
      {
        result = (CFTypeRef)CFEqual(a4, (CFTypeRef)v8[2 * v8[2] + 5]);
        v9 = v8[2];
        if ((_DWORD)result)
        {
          v8[2 * v9 + 4] += a3;
          if (v8[4] >= v9)
            v8[5] += a3;
          goto LABEL_21;
        }
        __CFRunArraySetBlockCapacity(v7, v9 + 1);
        v8 = (uint64_t *)v7[2];
        result = CFRetain(a4);
        v14 = v8[2];
        v17 = &v8[2 * v14];
        v17[6] = a3;
        v17[7] = (uint64_t)result;
      }
      v8[2] = v14 + 1;
LABEL_21:
      v8[1] += a3;
      return result;
    }
    v29 = 0;
    v30 = 0;
    v10 = blockForLocation((uint64_t)v8, a2, &v29);
    v11 = &v8[2 * v10];
    result = (CFTypeRef)CFEqual(a4, (CFTypeRef)v11[7]);
    if ((_DWORD)result)
    {
      v12 = v11 + 6;
LABEL_11:
      v13 = a3;
LABEL_12:
      *v12 += v13;
      goto LABEL_21;
    }
    v15 = v29;
    if (v10 >= 1 && v29 == a2)
    {
      v16 = &v8[2 * v10 - 2];
      result = (CFTypeRef)CFEqual(a4, (CFTypeRef)v16[7]);
      if ((_DWORD)result)
      {
        v16[6] += a3;
        if (v8[4] < v10)
          goto LABEL_21;
        v12 = v8 + 5;
        goto LABEL_11;
      }
      v15 = v29;
    }
    v18 = v8[2];
    if (v15 == a2)
    {
      __CFRunArraySetBlockCapacity(v7, v18 + 1);
      v8 = (uint64_t *)v7[2];
      v12 = v8 + 2;
      v19 = v8[2];
      if (v19 > v10)
      {
        v20 = &v8[2 * v19 + 6];
        do
        {
          --v19;
          *(_OWORD *)v20 = *((_OWORD *)v20 - 1);
          v20 -= 2;
        }
        while (v19 > v10);
      }
      result = CFRetain(a4);
      v21 = &v8[2 * v10];
      v21[6] = a3;
      v21[7] = (uint64_t)result;
      v13 = 1;
    }
    else
    {
      __CFRunArraySetBlockCapacity(v7, v18 + 2);
      v8 = (uint64_t *)v7[2];
      v12 = v8 + 2;
      v22 = v8[2];
      v23 = v10 + 2;
      if (v22 + 1 >= v10 + 2)
      {
        v24 = v22 + 2;
        v25 = &v8[2 * v22 + 8];
        do
        {
          *(_OWORD *)v25 = *((_OWORD *)v25 - 2);
          v25 -= 2;
          --v24;
        }
        while (v24 > v23);
      }
      v26 = CFRetain(a4);
      v27 = (uint64_t)&v8[2 * v10 + 6];
      *(_QWORD *)(v27 + 16) = a3;
      *(_QWORD *)(v27 + 24) = v26;
      *(_QWORD *)v27 = a2 - v29;
      result = CFRetain(*(CFTypeRef *)(v27 + 8));
      v28 = &v8[2 * v23 + 6];
      v28[1] = (uint64_t)result;
      *v28 = v30 - a2 + v29;
      v13 = 2;
    }
    goto LABEL_12;
  }
  return result;
}

_QWORD *__CFRunArraySetBlockCapacity(_QWORD *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v7;
  unint64_t v8;
  CFAllocatorRef v9;

  if (a2 <= 1)
    v2 = 1;
  else
    v2 = a2;
  v3 = *(_QWORD *)(result[2] + 24);
  if (v3 >= 0)
    v4 = *(_QWORD *)(result[2] + 24);
  else
    v4 = v3 + 1;
  v5 = v4 >> 1;
  if (v3 < v2 || v5 > v2)
  {
    v7 = result;
    v8 = v2 + 3;
    v9 = CFGetAllocator(result);
    result = (_QWORD *)__CFSafelyReallocateWithAllocatorTyped(v9, v7[2], ((v8 / 3) << 6) | 0x30, 1344524507, 0, 0);
    v7[2] = result;
    result[3] = 4 * (v8 / 3);
  }
  return result;
}

const void *__CFCreateOldStylePropertyListOrStringsFile(const __CFAllocator *a1, CFDataRef theData, CFTypeRef cf, CFStringEncoding a4, int a5, CFErrorRef *a6, _QWORD *a7)
{
  const __CFString *v11;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFIndex v16;
  CFIndex v17;
  const UniChar *CharactersPtr;
  const UniChar *v19;
  _QWORD *v20;
  const char *v21;
  UniChar *Typed;
  UniChar *v23;
  const void *v24;
  __CFString *v26;
  CFTypeID v27;
  CFTypeID TypeID;
  __CFDictionary *v29;
  uint64_t v30;
  __CFError *Error;
  uint64_t v32;
  const UniChar *v33;
  UniChar *v34;
  char *v35;
  CFTypeRef cfa;
  const __CFAllocator *v37;
  uint64_t v38;
  CFTypeRef Mutable;
  uint64_t v40;
  CFRange v41;

  v40 = *MEMORY[0x1E0C80C00];
  if (cf)
  {
    v11 = (const __CFString *)CFRetain(cf);
  }
  else
  {
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    v11 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, BytePtr, Length, a4, 0, (CFAllocatorRef)&__kCFAllocatorNull);
    if (!v11)
    {
      if (a6)
      {
        v24 = 0;
        *a6 = __CFPropertyListCreateError(3840, CFSTR("Conversion of string failed."));
        return v24;
      }
      return 0;
    }
  }
  v16 = CFStringGetLength(v11);
  if (!v16)
  {
    if (a6)
      *a6 = __CFPropertyListCreateError(3840, CFSTR("Conversion of string failed. The string is empty."));
    goto LABEL_19;
  }
  v17 = v16;
  CharactersPtr = CFStringGetCharactersPtr(v11);
  v19 = CharactersPtr;
  if (CharactersPtr)
  {
    v38 = 0;
    v33 = CharactersPtr;
    if (!__OFADD__(CharactersPtr, v17))
    {
      v23 = (UniChar *)CharactersPtr;
      goto LABEL_22;
    }
    v20 = (_QWORD *)&unk_1EDCD1000;
    v21 = "Unable to address entirety of CFPropertyList";
    goto LABEL_18;
  }
  Typed = (UniChar *)CFAllocatorAllocateTyped(a1, 2 * v17, 0x1000040BDFB0063, 0);
  if (!Typed)
  {
    v20 = &unk_1EDCD1000;
    v21 = "CFPropertyList ran out of memory while attempting to allocate temporary storage.";
LABEL_18:
    v20[7] = v21;
LABEL_19:
    CFRelease(v11);
    return 0;
  }
  v23 = Typed;
  v41.location = 0;
  v41.length = v17;
  CFStringGetCharacters(v11, v41, Typed);
  CFRelease(v11);
  v38 = 0;
  v33 = v23;
  if (__OFADD__(v23, v17))
  {
    qword_1EDCD1038 = (uint64_t)"Unable to address entirety of CFPropertyList";
LABEL_31:
    CFAllocatorDeallocate(a1, v23);
    return 0;
  }
  v11 = 0;
LABEL_22:
  v34 = v23;
  v35 = (char *)&v23[v17];
  v37 = a1;
  LODWORD(v38) = a5;
  Mutable = CFSetCreateMutable(a1, 0, &kCFTypeSetCallBacks);
  if (!Mutable)
  {
    qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
    if (!v19)
      goto LABEL_31;
    goto LABEL_19;
  }
  cfa = 0;
  if (advanceToNonSpace((uint64_t)&v33))
  {
    v26 = parsePlistObject((uint64_t)&v33, 1, 0);
    if (!v26)
    {
LABEL_40:
      Error = (__CFError *)cfa;
      if (!a6)
      {
        if (cfa)
          CFRelease(cfa);
        v24 = 0;
        if (!v19)
          goto LABEL_36;
        goto LABEL_45;
      }
      if (!cfa)
      {
        v32 = lineNumberStrings((unint64_t *)&v33);
        Error = __CFPropertyListCreateError(3840, CFSTR("Unknown error parsing property list around line %d"), v32);
      }
      v24 = 0;
      *a6 = Error;
      goto LABEL_44;
    }
    v24 = v26;
    if (!advanceToNonSpace((uint64_t)&v33))
      goto LABEL_34;
    v27 = CFGetTypeID(v24);
    TypeID = CFStringGetTypeID();
    CFRelease(v24);
    if (v27 != TypeID)
    {
      if (cfa)
        CFRelease(cfa);
      v30 = lineNumberStrings((unint64_t *)&v33);
      cfa = __CFPropertyListCreateError(3840, CFSTR("Junk after plist at line %d"), v30);
      goto LABEL_40;
    }
    if (cfa)
    {
      CFRelease(cfa);
      cfa = 0;
    }
    v34 = v23;
    v29 = parsePlistDictContent((uint64_t)&v33, 0);
  }
  else
  {
    v29 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  v24 = v29;
  if (!v29)
    goto LABEL_40;
LABEL_34:
  if (!a7)
  {
LABEL_44:
    if (!v19)
      goto LABEL_36;
    goto LABEL_45;
  }
  *a7 = 1;
  if (!v19)
  {
LABEL_36:
    CFAllocatorDeallocate(a1, v23);
    goto LABEL_46;
  }
LABEL_45:
  CFRelease(v11);
LABEL_46:
  if (Mutable)
    CFRelease(Mutable);
  return v24;
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)bytes, numBytes, *(uint64_t *)&encoding, (isExternalRepresentation != 0) | 0x12u, contentsDeallocator, 0);
}

__CFDictionary *parsePlistDictContent(uint64_t a1, int a2)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v5;
  __CFString *v6;
  __CFString *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  int v10;
  const void *v11;
  _WORD *v12;
  const void *v13;
  uint64_t v14;
  CFErrorRef Error;
  const void *v16;
  uint64_t v17;
  CFErrorRef v18;
  const void *v19;
  uint64_t v20;
  CFErrorRef v21;
  CFErrorRef v22;
  const void *v23;
  uint64_t v25;

  Mutable = CFDictionaryCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v14 = lineNumberStrings((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840, CFSTR("Unable to allocate dictionary while parsing plist at line %d"), v14);
    v16 = *(const void **)(a1 + 24);
    if (v16)
      CFRelease(v16);
    v5 = 0;
    *(_QWORD *)(a1 + 24) = Error;
    return v5;
  }
  v5 = Mutable;
  v6 = parsePlistString(a1);
  if (!v6)
  {
LABEL_14:
    v13 = *(const void **)(a1 + 24);
    if (v13)
    {
      CFRelease(v13);
      *(_QWORD *)(a1 + 24) = 0;
    }
    return v5;
  }
  v7 = v6;
  v8 = (a2 + 1);
  while (1)
  {
    if (!advanceToNonSpace(a1))
    {
      v20 = lineNumberStrings((unint64_t *)a1);
      _CFPropertyListMissingSemicolonOrValue();
      v21 = __CFPropertyListCreateError(3840, CFSTR("Missing ';' on line %d"), v20);
      goto LABEL_24;
    }
    v9 = *(unsigned __int16 **)(a1 + 8);
    v10 = *v9;
    if (v10 != 61)
    {
      if (v10 == 59)
      {
        v11 = CFRetain(v7);
        goto LABEL_9;
      }
      v25 = lineNumberStrings((unint64_t *)a1);
      v21 = __CFPropertyListCreateError(3840, CFSTR("Expected ';' or '=' after key at line %d"), v25);
LABEL_24:
      v22 = v21;
      v23 = *(const void **)(a1 + 24);
      if (v23)
        CFRelease(v23);
      *(_QWORD *)(a1 + 24) = v22;
LABEL_27:
      CFRelease(v7);
      goto LABEL_28;
    }
    *(_QWORD *)(a1 + 8) = v9 + 1;
    v11 = parsePlistObject(a1, 1, v8);
    if (!v11)
      goto LABEL_27;
LABEL_9:
    CFDictionarySetValue(v5, v7, v11);
    CFRelease(v7);
    if (v11)
      CFRelease(v11);
    if (!advanceToNonSpace(a1))
      break;
    v12 = *(_WORD **)(a1 + 8);
    if (*v12 != 59)
      break;
    *(_QWORD *)(a1 + 8) = v12 + 1;
    v7 = parsePlistString(a1);
    if (!v7)
      goto LABEL_14;
  }
  v17 = lineNumberStrings((unint64_t *)a1);
  _CFPropertyListMissingSemicolon();
  v18 = __CFPropertyListCreateError(3840, CFSTR("Missing ';' on line %d"), v17);
  v19 = *(const void **)(a1 + 24);
  if (v19)
    CFRelease(v19);
  *(_QWORD *)(a1 + 24) = v18;
LABEL_28:
  CFRelease(v5);
  return 0;
}

uint64_t advanceToNonSpace(uint64_t a1)
{
  unint64_t v1;
  unsigned __int16 *v2;
  unsigned __int16 *v3;
  int v4;
  BOOL v5;
  int v6;
  int v7;
  BOOL v8;
  int v10;
  BOOL v11;
  uint64_t v12;

  v2 = *(unsigned __int16 **)(a1 + 8);
  v1 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v2 >= v1)
    return 0;
  while (1)
  {
    v3 = v2 + 1;
    v4 = *v2;
    v5 = (v4 - 9) >= 5 && (v4 - 8232) >= 2;
    if (!v5 || v4 == 32)
      goto LABEL_6;
    if (v4 != 47 || (unint64_t)v3 >= v1)
      break;
    v6 = *v3;
    if (v6 == 42)
    {
      v3 = v2 + 2;
      if ((unint64_t)(v2 + 2) < v1)
      {
        v2 += 2;
        while (1)
        {
          v10 = *v2++;
          v11 = v10 != 42 || (unint64_t)v2 >= v1;
          if (!v11 && *v2 == 47)
            break;
          v3 = v2;
          if ((unint64_t)v2 >= v1)
            goto LABEL_7;
        }
        v2 = v3 + 2;
        goto LABEL_7;
      }
LABEL_6:
      v2 = v3;
      goto LABEL_7;
    }
    if (v6 != 47)
      break;
    for (v2 += 2; (unint64_t)v2 < v1; ++v2)
    {
      v7 = *v2;
      v8 = (v7 - 8232) < 2 || v7 == 10;
      if (v8 || v7 == 13)
        break;
    }
LABEL_7:
    if ((unint64_t)v2 >= v1)
    {
      v12 = 0;
      goto LABEL_36;
    }
  }
  v12 = 1;
LABEL_36:
  *(_QWORD *)(a1 + 8) = v2;
  return v12;
}

__CFString *parseQuotedPlistString(uint64_t a1, int a2)
{
  unint64_t v3;
  unint64_t v4;
  __CFString *v6;
  uint64_t v7;
  UniChar *v8;
  const UniChar *v9;
  CFMutableStringRef Mutable;
  unint64_t v11;
  uint64_t v12;
  int v13;
  _WORD *v14;
  char v15;
  unsigned int v16;
  CFErrorRef v17;
  const void *v18;
  int v19;
  uint64_t v21;
  __int16 v22;
  __CFString *Value;
  CFStringRef v24;
  CFErrorRef Error;
  CFErrorRef v26;
  const void *v27;
  __CFString *v29;
  const UniChar *v30;
  const void *v31;
  CFErrorRef v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  UniChar chars;
  uint64_t v37;
  __int16 v38;
  char v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  if (v4 >= v3)
  {
LABEL_65:
    *(_QWORD *)(a1 + 8) = v4;
    v34 = lineNumberStrings((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840, CFSTR("Unterminated quoted string starting on line %d"), v34);
    goto LABEL_66;
  }
  v6 = 0;
  v7 = MEMORY[0x1E0C80978];
  v8 = *(UniChar **)(a1 + 8);
  v9 = v8;
  do
  {
    chars = 0;
    chars = *v8;
    if (chars == a2)
      break;
    if (chars == 92)
    {
      if (!v6)
      {
        Mutable = CFStringCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
        if (!Mutable)
        {
          Error = __CFPropertyListCreateError(3840, CFSTR("Unable to allocate quoted string while parsing plist"));
          goto LABEL_66;
        }
        v6 = Mutable;
        v8 = *(UniChar **)(a1 + 8);
      }
      CFStringAppendCharacters(v6, v9, v8 - v9);
      v12 = *(_QWORD *)(a1 + 8);
      v11 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 8) = v12 + 2;
      if (v12 + 2 == v11)
      {
        CFRelease(v6);
        v35 = lineNumberStrings((unint64_t *)a1);
        Error = __CFPropertyListCreateError(3840, CFSTR("Unterminated backslash sequence on line %d"), v35);
        goto LABEL_66;
      }
      v13 = *(unsigned __int16 *)(v12 + 2);
      v14 = (_WORD *)(v12 + 4);
      *(_QWORD *)(a1 + 8) = v14;
      if (v13 > 84)
      {
        if (v13 > 101)
        {
          switch(v13)
          {
            case 'n':
              LOWORD(v13) = 10;
              break;
            case 'o':
            case 'p':
            case 'q':
            case 's':
            case 'u':
              break;
            case 'r':
              LOWORD(v13) = 13;
              break;
            case 't':
              LOWORD(v13) = 9;
              break;
            case 'v':
              LOWORD(v13) = 11;
              break;
            default:
              if (v13 == 102)
                LOWORD(v13) = 12;
              break;
          }
        }
        else
        {
          switch(v13)
          {
            case 'U':
              if ((unint64_t)v14 >= v11)
              {
                LOWORD(v13) = 0;
              }
              else
              {
                LOWORD(v13) = 0;
                v19 = -5;
                do
                {
                  if (__CFADD__(v19++, 1))
                    break;
                  v21 = (unsigned __int16)*v14;
                  if (v21 <= 0x7F && (*(_DWORD *)(v7 + 4 * v21 + 60) & 0x10000) != 0)
                  {
                    *(_QWORD *)(a1 + 8) = ++v14;
                    if (v21 >= 0x47)
                      v22 = -87;
                    else
                      v22 = -55;
                    if (v21 < 0x3A)
                      v22 = -48;
                    LOWORD(v13) = v21 + 16 * v13 + v22;
                  }
                }
                while ((unint64_t)v14 < v11);
              }
              break;
            case 'a':
              LOWORD(v13) = 7;
              break;
            case 'b':
              LOWORD(v13) = 8;
              break;
          }
        }
      }
      else
      {
        v15 = v13 - 48;
        if ((v13 - 48) < 8)
        {
          LOBYTE(v16) = 0;
          v38 = 0;
          v37 = 0;
          do
          {
            if ((unint64_t)v14 >= v11)
              break;
            if ((*v14 & 0xFFF8) != 0x30)
              break;
            v15 = *v14++ + 8 * v15 - 48;
            *(_QWORD *)(a1 + 8) = v14;
            v16 = (v16 + 1);
          }
          while (v16 < 2);
          v39 = v15;
          if (CFStringEncodingBytesToUnicode(2817, 0, (unint64_t)&v39, 1, 0, (uint64_t)&v38, 1, &v37))
          {
            v17 = __CFPropertyListCreateError(3840, CFSTR("Unable to convert octet-stream while parsing plist"));
            v18 = *(const void **)(a1 + 24);
            if (v18)
              CFRelease(v18);
            LOWORD(v13) = 0;
            *(_QWORD *)(a1 + 24) = v17;
          }
          else if (v37 == 1)
          {
            LOWORD(v13) = v38;
          }
          else
          {
            LOWORD(v13) = 0;
          }
        }
      }
      chars = v13;
      CFStringAppendCharacters(v6, &chars, 1);
      v8 = *(UniChar **)(a1 + 8);
      v3 = *(_QWORD *)(a1 + 16);
      v9 = v8;
    }
    else
    {
      *(_QWORD *)(a1 + 8) = ++v8;
    }
  }
  while ((unint64_t)v8 < v3);
  if (v3 <= (unint64_t)v8)
  {
    if (v6)
      CFRelease(v6);
    goto LABEL_65;
  }
  if (v6)
  {
    if (v9 != v8)
      CFStringAppendCharacters(v6, v9, v8 - v9);
    if (*(_DWORD *)(a1 + 40) == 2)
      goto LABEL_76;
    Value = (__CFString *)CFSetGetValue(*(CFSetRef *)(a1 + 48), v6);
    if (!Value)
    {
      v24 = __CFStringCollectionCopy(*(const __CFAllocator **)(a1 + 32), v6);
      if (!v24)
      {
        v32 = __CFPropertyListCreateError(3840, CFSTR("Unable to copy string while parsing plist"));
        v33 = *(const void **)(a1 + 24);
        if (v33)
          CFRelease(v33);
        Value = 0;
        *(_QWORD *)(a1 + 24) = v32;
        goto LABEL_62;
      }
      Value = (__CFString *)v24;
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), v24);
      __CFTypeCollectionRelease(*(_QWORD *)(a1 + 32), Value);
    }
    CFRetain(Value);
LABEL_62:
    CFRelease(v6);
    v6 = Value;
    goto LABEL_76;
  }
  if (*(_DWORD *)(a1 + 40) != 2)
  {
    v6 = (__CFString *)_uniqueStringForCharacters(a1, v9, v8 - v9);
LABEL_76:
    *(_QWORD *)(a1 + 8) += 2;
    v31 = *(const void **)(a1 + 24);
    if (v31)
    {
      CFRelease(v31);
      *(_QWORD *)(a1 + 24) = 0;
    }
    return v6;
  }
  v29 = CFStringCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
  if (v29)
  {
    v6 = v29;
    v30 = *(const UniChar **)(a1 + 8);
    if (v9 != v30)
      CFStringAppendCharacters(v29, v9, v30 - v9);
    goto LABEL_76;
  }
  Error = __CFPropertyListCreateError(3840, CFSTR("Unable to allocate mutable string while parsing plist"));
LABEL_66:
  v26 = Error;
  v27 = *(const void **)(a1 + 24);
  if (v27)
    CFRelease(v27);
  v6 = 0;
  *(_QWORD *)(a1 + 24) = v26;
  return v6;
}

CFStringRef __CFStringCollectionCopy(const __CFAllocator *a1, const __CFString *a2)
{
  if (!a2)
    __CFStringCollectionCopy_cold_1();
  return CFStringCreateCopy(a1, a2);
}

CFTypeRef _uniqueStringForCharacters(uint64_t a1, const UniChar *a2, CFIndex a3)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  char *Typed;
  uint64_t v11;
  unsigned int v12;
  CFStringRef v13;
  CFErrorRef Error;
  const void *Value;
  CFErrorRef v16;
  const void *v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  if (!a3)
    return CFRetain(&stru_1E1337B18);
  MEMORY[0x1E0C80A78](a1, a2);
  v7 = (char *)v18 - v6;
  if (v8 >= 2048)
  {
    Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, a3 + 1, 2505277932, 0);
    if (!Typed)
    {
      Error = __CFPropertyListCreateError(3840, CFSTR("Unable to allocate string while parsing plist"));
      goto LABEL_20;
    }
    goto LABEL_7;
  }
  Typed = (char *)v18 - v6;
  if (a3 >= 1)
  {
LABEL_7:
    v11 = 0;
    while (1)
    {
      v12 = a2[v11];
      if (v12 >= 0x80)
        break;
      Typed[v11++] = v12;
      if (a3 == v11)
        goto LABEL_10;
    }
    v13 = CFStringCreateWithCharacters(*(CFAllocatorRef *)(a1 + 32), a2, a3);
    if (!v13)
    {
      Error = __CFPropertyListCreateError(3840, CFSTR("Unable to allocate pre-unique string while parsing plist"));
      goto LABEL_20;
    }
LABEL_13:
    if (Typed != v7)
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
    Value = CFSetGetValue(*(CFSetRef *)(a1 + 48), v13);
    if (!Value)
    {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), v13);
      Value = v13;
    }
    CFRelease(v13);
    CFRetain(Value);
    return Value;
  }
LABEL_10:
  Typed[a3] = 0;
  v13 = CFStringCreateWithBytes(*(CFAllocatorRef *)(a1 + 32), (const UInt8 *)Typed, a3, 0x600u, 0);
  if (v13)
    goto LABEL_13;
  Error = __CFPropertyListCreateError(3840, CFSTR("Unable to allocate ascii string while parsing plist"));
LABEL_20:
  v16 = Error;
  v17 = *(const void **)(a1 + 24);
  if (v17)
    CFRelease(v17);
  Value = 0;
  *(_QWORD *)(a1 + 24) = v16;
  return Value;
}

__CFString *parsePlistObject(uint64_t a1, int a2, uint64_t a3)
{
  CFErrorRef Error;
  CFErrorRef v5;
  const void *v6;
  __CFArray *v7;
  unsigned __int16 *v11;
  uint64_t v12;
  int v13;
  __int16 *v14;
  CFMutableArrayRef Mutable;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  _WORD *v19;
  const void *v20;
  CFMutableDataRef v21;
  unint64_t v22;
  int v23;
  unsigned int v24;
  char v25;
  __int16 v26;
  char v27;
  const void *v28;
  CFErrorRef v31;
  CFErrorRef v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  UInt8 bytes[400];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (a3 >= 0x201)
  {
    v34 = lineNumberStrings((unint64_t *)a1);
    Error = __CFPropertyListCreateError(3840, CFSTR("Too many nested arrays or dictionaries at line %d"), v34);
    goto LABEL_3;
  }
  if (!advanceToNonSpace(a1))
  {
    if (a2)
    {
      Error = __CFPropertyListCreateError(3840, CFSTR("Unexpected EOF while parsing plist"));
      goto LABEL_3;
    }
    return 0;
  }
  v11 = *(unsigned __int16 **)(a1 + 8);
  v13 = *v11;
  v12 = *v11;
  *(_QWORD *)(a1 + 8) = v11 + 1;
  if (v13 > 39)
  {
    if ((_DWORD)v12 == 40)
    {
      Mutable = CFArrayCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0, &kCFTypeArrayCallBacks);
      if (!Mutable)
      {
        Error = __CFPropertyListCreateError(3840, CFSTR("Unable to allocate array string while parsing plist"));
        goto LABEL_3;
      }
      v7 = Mutable;
      v16 = (a3 + 1);
      v17 = parsePlistObject(a1, 0, v16);
      if (v17)
      {
        v18 = (const void *)v17;
        do
        {
          CFArrayAppendValue(v7, v18);
          CFRelease(v18);
          if (!advanceToNonSpace(a1))
          {
            CFRelease(v7);
            v40 = lineNumberStrings((unint64_t *)a1);
            Error = __CFPropertyListCreateError(3840, CFSTR("Expected ',' for array at line %d"), v40);
            goto LABEL_3;
          }
          v19 = *(_WORD **)(a1 + 8);
          if (*v19 != 44)
            break;
          *(_QWORD *)(a1 + 8) = v19 + 1;
          v18 = (const void *)parsePlistObject(a1, 0, v16);
        }
        while (v18);
      }
      if (advanceToNonSpace(a1))
      {
        v14 = *(__int16 **)(a1 + 8);
        if (*v14 == 41)
        {
          v20 = *(const void **)(a1 + 24);
          if (v20)
          {
            CFRelease(v20);
            *(_QWORD *)(a1 + 24) = 0;
            v14 = *(__int16 **)(a1 + 8);
          }
          goto LABEL_65;
        }
      }
      CFRelease(v7);
      v37 = lineNumberStrings((unint64_t *)a1);
      Error = __CFPropertyListCreateError(3840, CFSTR("Expected terminating ')' for array at line %d"), v37);
LABEL_3:
      v5 = Error;
      v6 = *(const void **)(a1 + 24);
      if (v6)
        CFRelease(v6);
      v7 = 0;
      *(_QWORD *)(a1 + 24) = v5;
      return (__CFString *)v7;
    }
    if ((_DWORD)v12 != 60)
    {
      if ((_DWORD)v12 == 123)
      {
        v7 = (__CFArray *)parsePlistDictContent(a1, a3);
        if (!v7)
          return (__CFString *)v7;
        if (advanceToNonSpace(a1))
        {
          v14 = *(__int16 **)(a1 + 8);
          if (*v14 == 125)
            goto LABEL_65;
        }
        CFRelease(v7);
        v35 = lineNumberStrings((unint64_t *)a1);
        Error = __CFPropertyListCreateError(3840, CFSTR("Expected terminating '}' for dictionary at line %d"), v35);
        goto LABEL_3;
      }
      goto LABEL_66;
    }
    v21 = CFDataCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
    if (!v21)
    {
      v36 = lineNumberStrings((unint64_t *)a1);
      Error = __CFPropertyListCreateError(3840, CFSTR("Unable to allocate data while parsing property list at line %d"), v36);
      goto LABEL_3;
    }
    v7 = v21;
    v14 = *(__int16 **)(a1 + 8);
    v22 = *(_QWORD *)(a1 + 16);
    if ((unint64_t)v14 >= v22)
      goto LABEL_61;
LABEL_33:
    v23 = 0;
    while (1)
    {
      v24 = (unsigned __int16)*v14;
      if (v24 == 62)
      {
LABEL_58:
        if (v23 < 0)
        {
          CFRelease(v7);
          if (v23 == -2)
          {
LABEL_80:
            v38 = lineNumberStrings((unint64_t *)a1);
            v31 = __CFPropertyListCreateError(3840, CFSTR("Malformed data byte group at line %d; uneven length"), v38);
          }
          else
          {
LABEL_90:
            v41 = lineNumberStrings((unint64_t *)a1);
            v31 = __CFPropertyListCreateError(3840, CFSTR("Malformed data byte group at line %d; invalid hex"), v41);
          }
          v32 = v31;
          v33 = *(const void **)(a1 + 24);
          if (v33)
            CFRelease(v33);
          *(_QWORD *)(a1 + 24) = v32;
          return 0;
        }
        if (v23)
        {
          CFDataAppendBytes(v7, bytes, v23);
          v14 = *(__int16 **)(a1 + 8);
          v22 = *(_QWORD *)(a1 + 16);
          if ((unint64_t)v14 < v22)
            goto LABEL_33;
        }
LABEL_61:
        v28 = *(const void **)(a1 + 24);
        if (v28)
        {
          CFRelease(v28);
          *(_QWORD *)(a1 + 24) = 0;
          v14 = *(__int16 **)(a1 + 8);
          v22 = *(_QWORD *)(a1 + 16);
        }
        if ((unint64_t)v14 < v22 && *v14 == 62)
        {
LABEL_65:
          *(_QWORD *)(a1 + 8) = v14 + 1;
          return (__CFString *)v7;
        }
        CFRelease(v7);
        v39 = lineNumberStrings((unint64_t *)a1);
        Error = __CFPropertyListCreateError(3840, CFSTR("Expected terminating '>' for data at line %d"), v39);
        goto LABEL_3;
      }
      if ((v24 & 0xFE) - 48 <= 9)
        break;
      if ((v24 - 97) <= 5u)
      {
        v25 = v24 - 87;
LABEL_41:
        *(_QWORD *)(a1 + 8) = ++v14;
        if ((unint64_t)v14 >= v22)
          goto LABEL_79;
        v26 = *v14;
        if ((*v14 & 0xFEu) - 48 > 9)
        {
          if ((v26 - 97) > 5u)
          {
            if ((v26 - 65) > 5u)
              goto LABEL_79;
            v27 = v26 - 55;
            goto LABEL_54;
          }
          v27 = v26 - 87;
        }
        else
        {
          v27 = v26 - 48;
LABEL_54:
          if (v27 == -1)
          {
LABEL_79:
            CFRelease(v7);
            goto LABEL_80;
          }
        }
        bytes[v23++] = v27 + 16 * v25;
        goto LABEL_56;
      }
      if ((v24 - 65) <= 5u)
      {
        v25 = v24 - 55;
LABEL_37:
        if (v25 != -1)
          goto LABEL_41;
      }
      if ((v24 > 0x20 || ((1 << v24) & 0x100002600) == 0) && v24 - 8232 >= 2)
      {
        CFRelease(v7);
        goto LABEL_90;
      }
LABEL_56:
      *(_QWORD *)(a1 + 8) = ++v14;
      if ((unint64_t)v14 >= v22 || v23 >= 400)
        goto LABEL_58;
    }
    v25 = v24 - 48;
    goto LABEL_37;
  }
  if ((_DWORD)v12 == 34 || (_DWORD)v12 == 39)
    return parseQuotedPlistString(a1, v12);
LABEL_66:
  if ((v12 - 48) >= 0xA
    && (unsigned __int16)((v12 & 0xFFDF) - 65) >= 0x1Au
    && ((v12 - 36) > 0x3B || ((1 << (v12 - 36)) & 0x800000000400E01) == 0))
  {
    *(_QWORD *)(a1 + 8) = v11;
    if (a2)
    {
      v42 = lineNumberStrings((unint64_t *)a1);
      Error = __CFPropertyListCreateError(3840, CFSTR("Unexpected character '0x%x' at line %d"), v12, v42);
      goto LABEL_3;
    }
    return 0;
  }
  *(_QWORD *)(a1 + 8) = v11;
  return parseUnquotedPlistString(a1);
}

__CFString *parsePlistString(uint64_t a1)
{
  unsigned __int16 *v2;
  int v3;
  BOOL v5;
  BOOL v6;

  if (!advanceToNonSpace(a1))
    return 0;
  v2 = *(unsigned __int16 **)(a1 + 8);
  v3 = *v2;
  if (v3 == 39 || v3 == 34)
  {
    *(_QWORD *)(a1 + 8) = v2 + 1;
    return parseQuotedPlistString(a1, v3);
  }
  v5 = (v3 - 48) >= 0xA && (unsigned __int16)((v3 & 0xFFDF) - 65) >= 0x1Au;
  if (v5
    && ((v3 - 36) <= 0x3B
      ? (v6 = ((1 << (v3 - 36)) & 0x800000000400E01) == 0)
      : (v6 = 1),
        v6))
  {
    return 0;
  }
  else
  {
    return parseUnquotedPlistString(a1);
  }
}

CFErrorRef __CFPropertyListCreateError(CFIndex code, CFStringRef format, ...)
{
  CFStringRef v3;
  __CFDictionary *Mutable;
  CFErrorRef v5;
  va_list va;

  va_start(va, format);
  if (!format)
    return CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("NSCocoaErrorDomain"), code, 0);
  v3 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, format, va);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(Mutable, CFSTR("NSDebugDescription"), v3);
  v5 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("NSCocoaErrorDomain"), code, Mutable);
  CFRelease(v3);
  CFRelease(Mutable);
  return v5;
}

CFErrorRef CFErrorCreateWithUserInfoKeysAndValues(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, const void *const *userInfoKeys, const void *const *userInfoValues, CFIndex numUserInfoValues)
{
  CFErrorRef result;
  CFErrorRef v10;
  __CFError *v11;

  result = CFDictionaryCreate(allocator, (const void **)userInfoKeys, (const void **)userInfoValues, numUserInfoValues, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (result)
  {
    v10 = result;
    v11 = CFErrorCreate(allocator, domain, code, result);
    CFRelease(v10);
    return v11;
  }
  return result;
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  __CFError *Instance;
  CFStringRef Copy;
  CFArrayRef v10;
  CFArrayRef v11;
  __CFDictionary *MutableCopy;
  const __CFDictionary *v13;
  CFDictionaryRef EmptyDictionary;

  Instance = (__CFError *)_CFRuntimeCreateInstance((__objc2_class **)allocator, 0x1BuLL, 24, 0);
  if (Instance)
  {
    Copy = CFStringCreateCopy(allocator, domain);
    *((_QWORD *)Instance + 2) = code;
    *((_QWORD *)Instance + 3) = Copy;
    v10 = _CFErrorCreateCallStackReturnAddresses(allocator);
    if (v10)
    {
      v11 = v10;
      if (userInfo)
        MutableCopy = CFDictionaryCreateMutableCopy(allocator, 0, userInfo);
      else
        MutableCopy = CFDictionaryCreateMutable(allocator, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      v13 = MutableCopy;
      if (MutableCopy)
      {
        CFDictionarySetValue(MutableCopy, CFSTR("NSCallStackReturnAddresses"), v11);
        userInfo = v13;
      }
      CFRelease(v11);
    }
    else
    {
      v13 = 0;
    }
    if (userInfo)
      EmptyDictionary = CFDictionaryCreateCopy(allocator, userInfo);
    else
      EmptyDictionary = _CFErrorCreateEmptyDictionary(allocator);
    *((_QWORD *)Instance + 4) = EmptyDictionary;
    if (v13)
      CFRelease(v13);
  }
  return Instance;
}

CFArrayRef _CFErrorCreateCallStackReturnAddresses(const __CFAllocator *a1)
{
  unsigned __int8 v1;
  CFArrayRef Copy;
  void *v5;
  NSArray *v6;

  v1 = atomic_load(_CFErrorCallStackCaptureEnabled);
  if ((v1 & 1) == 0)
    return 0;
  v5 = (void *)MEMORY[0x186DB02F4]();
  v6 = +[NSThread callStackReturnAddresses](&off_1EDCDC8E8, "callStackReturnAddresses");
  if (v6)
    Copy = CFArrayCreateCopy(a1, (CFArrayRef)v6);
  else
    Copy = 0;
  objc_autoreleasePoolPop(v5);
  return Copy;
}

CFDictionaryRef _CFErrorCreateEmptyDictionary(CFAllocatorRef allocator)
{
  const __CFAllocator *v1;
  uint64_t v2;

  if (allocator)
  {
    v1 = allocator;
  }
  else
  {
    v2 = _CFGetTSD(1u);
    if (v2)
      v1 = (const __CFAllocator *)v2;
    else
      v1 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  if (&__kCFAllocatorSystemDefault == (__objc2_class **)v1
    || !v1 && &__kCFAllocatorSystemDefault == (__objc2_class **)CFAllocatorGetDefault())
  {
    return (CFDictionaryRef)CFRetain(&__NSDictionary0__struct);
  }
  else
  {
    return CFDictionaryCreate(v1, 0, 0, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
}

__CFString *parseUnquotedPlistString(uint64_t a1)
{
  unint64_t v2;
  const UniChar *v3;
  const UniChar *v4;
  unsigned int v6;
  BOOL v7;
  uint64_t v8;
  __CFString *Mutable;
  __CFString *v11;
  CFErrorRef Error;
  CFErrorRef v13;
  const void *v14;

  v3 = *(const UniChar **)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v3 >= v2)
    goto LABEL_17;
  v4 = *(const UniChar **)(a1 + 8);
  do
  {
    if ((unsigned __int16)(*v4 - 48) >= 0xAu && (unsigned __int16)((*v4 & 0xFFDF) - 65) >= 0x1Au)
    {
      v6 = *v4 - 36;
      v7 = v6 > 0x3B;
      v8 = (1 << v6) & 0x800000000400E01;
      if (v7 || v8 == 0)
        break;
    }
    *(_QWORD *)(a1 + 8) = ++v4;
  }
  while ((unint64_t)v4 < v2);
  if (v4 == v3)
  {
LABEL_17:
    Error = __CFPropertyListCreateError(3840, CFSTR("Unexpected EOF"));
    goto LABEL_18;
  }
  if (*(_DWORD *)(a1 + 40) == 2)
  {
    Mutable = CFStringCreateMutable(*(CFAllocatorRef *)(a1 + 32), 0);
    if (Mutable)
    {
      v11 = Mutable;
      CFStringAppendCharacters(Mutable, v3, (uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v3) >> 1);
      return v11;
    }
    Error = __CFPropertyListCreateError(3840, CFSTR("Unable to allocate unquoted string while parsing plist"));
LABEL_18:
    v13 = Error;
    v14 = *(const void **)(a1 + 24);
    if (v14)
      CFRelease(v14);
    v11 = 0;
    *(_QWORD *)(a1 + 24) = v13;
    return v11;
  }
  return (__CFString *)_uniqueStringForCharacters(a1, v3, v4 - v3);
}

uint64_t lineNumberStrings(unint64_t *a1)
{
  unsigned __int16 *v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t result;
  int v5;

  v1 = (unsigned __int16 *)*a1;
  v2 = a1[2];
  if (*a1 >= v2)
    return 1;
  v3 = a1[1];
  result = 1;
  do
  {
    if ((unint64_t)v1 >= v3)
      break;
    v5 = *v1;
    if (v5 == 10)
    {
      result = (result + 1);
    }
    else if (v5 == 13)
    {
      result = (result + 1);
      if ((unint64_t)(v1 + 1) < v2 && (unint64_t)(v1 + 1) < v3 && v1[1] == 10)
        ++v1;
    }
    ++v1;
  }
  while ((unint64_t)v1 < v2);
  return result;
}

CFTypeRef CFNumberFormatterCopyProperty(CFNumberFormatterRef formatter, CFNumberFormatterKey key)
{
  unint64_t v4;
  int Context;
  const __CFAllocator *v6;
  double *p_valuePtr;
  CFNumberType v8;
  CFTypeRef result;
  uint64_t v10;
  int Attribute;
  int v14;
  int TextAttribute;
  CFIndex v16;
  int v17;
  const __CFString *Identifier;
  void *CStringPtr;
  uint64_t v20;
  const void *v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  int v26;
  CFTypeRef *v27;
  BOOL v28;
  int Symbol;
  int v30;
  const __CFAllocator *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  int v37;
  double DoubleAttribute;
  int valuePtr;
  char buffer[768];
  UniChar chars[768];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  DoubleAttribute = 0.0;
  v37 = 0;
  v4 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v4 != 57)
    _CFAssertMismatchedTypeID(0x39uLL, v4);
  if (CFEqual(CFSTR("kCFNumberFormatterFormattingContextKey"), key))
  {
    Context = __cficu_unum_getContext(*((_QWORD *)formatter + 2), 1, &v37);
LABEL_4:
    valuePtr = Context;
LABEL_5:
    v6 = CFGetAllocator(formatter);
    p_valuePtr = (double *)&valuePtr;
    v8 = kCFNumberSInt32Type;
    return CFNumberCreate(v6, v8, p_valuePtr);
  }
  v10 = *((_QWORD *)formatter + 4);
  if (((unint64_t)(v10 - 8) >= 0xFFFFFFFFFFFFFFFDLL || v10 == 9)
    && CFSTR("kCFNumberFormatterIsLenientKey") != key)
  {
    return 0;
  }
  if (CFSTR("kCFNumberFormatterCurrencyCodeKey") == key)
  {
    TextAttribute = __cficu_unum_getTextAttribute(*((_QWORD *)formatter + 2), 5u, chars, 768, &v37);
    v16 = TextAttribute;
    v17 = v37;
    if (v37 <= 0 && !TextAttribute)
    {
      Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3));
      CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
      if (!CStringPtr)
      {
        CStringPtr = buffer;
        if (!CFStringGetCString(Identifier, buffer, 768, 0x600u))
          return 0;
      }
      v36 = 0;
      v20 = __cficu_unum_open(2u, 0, 0, (uint64_t)CStringPtr, 0, &v36);
      if (v20)
      {
        v21 = (const void *)v20;
        v16 = (int)__cficu_unum_getTextAttribute(v20, 5u, chars, 768, &v36);
        __cficu_unum_close(v21);
      }
      else
      {
        v16 = 0;
      }
      v17 = v37;
    }
    result = 0;
    if (v17 <= 0 && v16 >= 1 && v16 <= 768)
      goto LABEL_95;
    return result;
  }
  if (CFSTR("kCFNumberFormatterDecimalSeparatorKey") == key)
  {
    v22 = *((_QWORD *)formatter + 2);
    v23 = 0;
  }
  else if (CFSTR("kCFNumberFormatterCurrencyDecimalSeparatorKey") == key)
  {
    v22 = *((_QWORD *)formatter + 2);
    v23 = 10;
  }
  else
  {
    if (CFSTR("kCFNumberFormatterAlwaysShowDecimalSeparatorKey") == key)
    {
      v24 = *((_QWORD *)formatter + 2);
      v25 = 2;
      goto LABEL_76;
    }
    if (CFSTR("kCFNumberFormatterGroupingSeparatorKey") == key)
    {
      v22 = *((_QWORD *)formatter + 2);
      v23 = 1;
    }
    else
    {
      if (CFSTR("kCFNumberFormatterUseGroupingSeparatorKey") == key)
      {
        v24 = *((_QWORD *)formatter + 2);
        v25 = 1;
        goto LABEL_76;
      }
      if (CFSTR("kCFNumberFormatterPercentSymbolKey") == key)
      {
        v22 = *((_QWORD *)formatter + 2);
        v23 = 3;
      }
      else
      {
        if (CFSTR("kCFNumberFormatterZeroSymbolKey") == key)
        {
          result = (CFTypeRef)*((_QWORD *)formatter + 9);
          if (!result)
            return result;
          return CFRetain(result);
        }
        if (CFSTR("kCFNumberFormatterNaNSymbolKey") == key)
        {
          v22 = *((_QWORD *)formatter + 2);
          v23 = 15;
        }
        else if (CFSTR("kCFNumberFormatterInfinitySymbolKey") == key)
        {
          v22 = *((_QWORD *)formatter + 2);
          v23 = 14;
        }
        else if (CFSTR("kCFNumberFormatterMinusSignKey") == key)
        {
          v22 = *((_QWORD *)formatter + 2);
          v23 = 6;
        }
        else if (CFSTR("kCFNumberFormatterPlusSignKey") == key)
        {
          v22 = *((_QWORD *)formatter + 2);
          v23 = 7;
        }
        else if (CFSTR("kCFNumberFormatterCurrencySymbolKey") == key)
        {
          v22 = *((_QWORD *)formatter + 2);
          v23 = 8;
        }
        else
        {
          if (CFSTR("kCFNumberFormatterExponentSymbolKey") != key)
          {
            if (CFSTR("kCFNumberFormatterMinIntegerDigitsKey") == key)
            {
              v32 = *((_QWORD *)formatter + 2);
              v33 = 4;
              goto LABEL_107;
            }
            if (CFSTR("kCFNumberFormatterMaxIntegerDigitsKey") == key)
            {
              v32 = *((_QWORD *)formatter + 2);
              v33 = 3;
              goto LABEL_107;
            }
            if (CFSTR("kCFNumberFormatterMinFractionDigitsKey") == key)
            {
              v32 = *((_QWORD *)formatter + 2);
              v33 = 7;
              goto LABEL_107;
            }
            if (CFSTR("kCFNumberFormatterMaxFractionDigitsKey") == key)
            {
              v32 = *((_QWORD *)formatter + 2);
              v33 = 6;
              goto LABEL_107;
            }
            if (CFSTR("kCFNumberFormatterGroupingSizeKey") == key)
            {
              v32 = *((_QWORD *)formatter + 2);
              v33 = 10;
              goto LABEL_107;
            }
            if (CFSTR("kCFNumberFormatterSecondaryGroupingSizeKey") == key)
            {
              v32 = *((_QWORD *)formatter + 2);
              v33 = 15;
              goto LABEL_107;
            }
            if (CFSTR("kCFNumberFormatterRoundingModeKey") == key)
            {
              v32 = *((_QWORD *)formatter + 2);
              v33 = 11;
              goto LABEL_107;
            }
            if (CFSTR("kCFNumberFormatterRoundingIncrementKey") == key)
            {
              DoubleAttribute = __cficu_unum_getDoubleAttribute(*((_QWORD *)formatter + 2), 12);
              v6 = CFGetAllocator(formatter);
              p_valuePtr = &DoubleAttribute;
              v8 = kCFNumberDoubleType;
              return CFNumberCreate(v6, v8, p_valuePtr);
            }
            if (CFSTR("kCFNumberFormatterFormatWidthKey") == key)
            {
              v32 = *((_QWORD *)formatter + 2);
              v33 = 13;
              goto LABEL_107;
            }
            if (CFSTR("kCFNumberFormatterPaddingPositionKey") == key)
            {
              v32 = *((_QWORD *)formatter + 2);
              v33 = 14;
              goto LABEL_107;
            }
            if (CFSTR("kCFNumberFormatterPaddingCharacterKey") == key)
            {
              v34 = *((_QWORD *)formatter + 2);
              v35 = 4;
              goto LABEL_109;
            }
            if (CFSTR("kCFNumberFormatterDefaultFormatKey") == key)
            {
              result = (CFTypeRef)*((_QWORD *)formatter + 6);
              if (!result)
                return result;
            }
            else
            {
              if (CFSTR("kCFNumberFormatterMultiplierKey") != key)
              {
                if (CFSTR("kCFNumberFormatterPositivePrefixKey") == key)
                {
                  v34 = *((_QWORD *)formatter + 2);
                  v35 = 0;
                }
                else if (CFSTR("kCFNumberFormatterPositiveSuffixKey") == key)
                {
                  v34 = *((_QWORD *)formatter + 2);
                  v35 = 1;
                }
                else if (CFSTR("kCFNumberFormatterNegativePrefixKey") == key)
                {
                  v34 = *((_QWORD *)formatter + 2);
                  v35 = 2;
                }
                else
                {
                  if (CFSTR("kCFNumberFormatterNegativeSuffixKey") != key)
                  {
                    if (CFSTR("kCFNumberFormatterPerMillSymbolKey") == key)
                    {
                      v22 = *((_QWORD *)formatter + 2);
                      v23 = 12;
                    }
                    else if (CFSTR("kCFNumberFormatterInternationalCurrencySymbolKey") == key)
                    {
                      v22 = *((_QWORD *)formatter + 2);
                      v23 = 9;
                    }
                    else
                    {
                      if (CFSTR("kCFNumberFormatterCurrencyGroupingSeparatorKey") != key)
                      {
                        if (CFSTR("kCFNumberFormatterIsLenientKey") == key)
                        {
                          v27 = (CFTypeRef *)&kCFBooleanTrue;
                          v28 = *((_BYTE *)formatter + 80) == 0;
                          goto LABEL_77;
                        }
                        if (CFSTR("kCFNumberFormatterUseSignificantDigitsKey") != key)
                        {
                          if (CFSTR("kCFNumberFormatterMinSignificantDigitsKey") == key)
                          {
                            v32 = *((_QWORD *)formatter + 2);
                            v33 = 17;
                          }
                          else
                          {
                            if (CFSTR("kCFNumberFormatterMaxSignificantDigitsKey") != key)
                            {
                              if (CFSTR("kCFNumberFormatterMinGroupingDigitsKey") == key)
                              {
                                Attribute = __cficu_unum_getAttribute(*((_QWORD *)formatter + 2), 22);
                                if (Attribute == -2)
                                  v14 = -1;
                                else
                                  v14 = Attribute;
                                valuePtr = v14;
                                goto LABEL_5;
                              }
                              return 0;
                            }
                            v32 = *((_QWORD *)formatter + 2);
                            v33 = 18;
                          }
LABEL_107:
                          Context = __cficu_unum_getAttribute(v32, v33);
                          goto LABEL_4;
                        }
                        v24 = *((_QWORD *)formatter + 2);
                        v25 = 16;
LABEL_76:
                        v26 = __cficu_unum_getAttribute(v24, v25);
                        v27 = (CFTypeRef *)&kCFBooleanTrue;
                        v28 = v26 == 0;
LABEL_77:
                        if (v28)
                          v27 = (CFTypeRef *)&kCFBooleanFalse;
                        result = *v27;
                        return CFRetain(result);
                      }
                      v22 = *((_QWORD *)formatter + 2);
                      v23 = 17;
                    }
                    goto LABEL_91;
                  }
                  v34 = *((_QWORD *)formatter + 2);
                  v35 = 3;
                }
LABEL_109:
                Symbol = __cficu_unum_getTextAttribute(v34, v35, chars, 768, &v37);
                goto LABEL_92;
              }
              result = (CFTypeRef)*((_QWORD *)formatter + 8);
              if (!result)
                return result;
            }
            return CFRetain(result);
          }
          v22 = *((_QWORD *)formatter + 2);
          v23 = 11;
        }
      }
    }
  }
LABEL_91:
  Symbol = __cficu_unum_getSymbol(v22, v23, chars, 768, &v37);
LABEL_92:
  v30 = Symbol;
  result = 0;
  if (v37 <= 0 && v30 <= 768)
  {
    v16 = v30;
LABEL_95:
    v31 = CFGetAllocator(formatter);
    return CFStringCreateWithCharacters(v31, chars, v16);
  }
  return result;
}

CFStringRef CFNumberFormatterGetFormat(CFNumberFormatterRef formatter)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int v5;
  const __CFAllocator *v6;
  CFStringRef v7;
  const __CFString *v8;
  const void *v9;
  const void *v11;
  int v12;
  UniChar chars[768];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v2 != 57)
    _CFAssertMismatchedTypeID(0x39uLL, v2);
  v3 = *((_QWORD *)formatter + 4) - 5;
  if (v3 < 5 && ((0x17u >> v3) & 1) != 0)
    return 0;
  v12 = 0;
  v4 = __cficu_unum_toPattern(*((_QWORD *)formatter + 2), 0, chars, 768, &v12);
  if (v12 <= 0)
  {
    v5 = v4;
    if (v4 <= 768)
    {
      v6 = CFGetAllocator(formatter);
      v7 = CFStringCreateWithCharacters(v6, chars, v5);
      if (v7)
      {
        v8 = v7;
        v9 = (const void *)*((_QWORD *)formatter + 5);
        if (v9)
        {
          if (CFEqual(v7, v9))
          {
            CFRelease(v8);
            return (CFStringRef)*((_QWORD *)formatter + 5);
          }
          CFRelease(*((CFTypeRef *)formatter + 5));
        }
        *((_QWORD *)formatter + 5) = v8;
        v11 = (const void *)*((_QWORD *)formatter + 7);
        if (v11)
        {
          CFRelease(v11);
          v8 = (const __CFString *)*((_QWORD *)formatter + 5);
        }
        *((_QWORD *)formatter + 7) = __CFNumberFormatterCreateCompressedString(v8, 1, 0);
      }
    }
  }
  return (CFStringRef)*((_QWORD *)formatter + 5);
}

CFStringRef CFDateFormatterCreateStringWithAbsoluteTime(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFAbsoluteTime at)
{
  const __CFAllocator *v5;
  uint64_t v6;
  unint64_t v7;
  double v8;
  int v9;
  CFIndex v10;
  int v11;
  UniChar *Typed;
  uint64_t v13;
  const __CFString *v14;
  UniChar *v16;
  const __CFString *Identifier;
  int v18;
  char v19;
  UniChar v20[768];
  uint64_t v21;

  v5 = allocator;
  v21 = *MEMORY[0x1E0C80C00];
  if (!allocator)
  {
    v6 = _CFGetTSD(1u);
    if (v6)
      v5 = (const __CFAllocator *)v6;
    else
      v5 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  v7 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v7 != 56)
    _CFAssertMismatchedTypeID(0x38uLL, v7);
  v18 = 0;
  v8 = (at + 978307200.0) * 1000.0 + 0.5;
  v9 = __cficu_udat_format(*((_QWORD *)formatter + 2), v20, 768, 0, &v18, v8);
  v10 = v9;
  v11 = v18;
  if (v18 == 15 || v9 >= 769)
  {
    v13 = v9 + 2;
    Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * v13, 0x1000040BDFB0063, 0);
    v18 = 0;
    v10 = (int)__cficu_udat_format(*((_QWORD *)formatter + 2), Typed + 1, v13, 0, &v18, v8);
    v11 = v18;
  }
  else
  {
    Typed = 0;
  }
  if (v11 <= 0)
  {
    if (Typed)
      v16 = Typed;
    else
      v16 = (UniChar *)&v19;
    if (*((__objc2_class ***)formatter + 38) == &__kCFBooleanTrue
      && (Identifier = CFLocaleGetIdentifier(*((CFLocaleRef *)formatter + 3)),
          CFLocaleGetLanguageCharacterDirection(Identifier) == kCFLocaleLanguageDirectionRightToLeft))
    {
      *v16 = 8207;
      ++v10;
    }
    else if (Typed)
    {
      v16 = Typed + 1;
    }
    else
    {
      v16 = v20;
    }
    v14 = CFStringCreateWithCharacters(v5, v16, v10);
    if (Typed)
      goto LABEL_12;
  }
  else
  {
    v14 = 0;
    if (Typed)
LABEL_12:
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
  return v14;
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)chars, 2 * numChars, 256, 2u, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
}

void CFStringReplace(CFMutableStringRef theString, CFRange range, CFStringRef replacement)
{
  CFIndex length;
  CFIndex location;
  char v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *Copy;
  CFIndex v17;
  int v18;
  _BOOL4 v19;
  unsigned int v20;
  uint64_t v21;
  char v22;
  char v23;
  uint64_t v24;
  char **p_data;
  char *v26;
  char *v27;
  uint64_t v28;
  CFStringEncoding v29;
  unint64_t v30;
  uint64_t v31;
  _QWORD v32[3];
  CFRange v33;
  CFRange v34;

  length = range.length;
  location = range.location;
  v32[2] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString replaceCharactersInRange:withString:](theString, "replaceCharactersInRange:withString:", location, length, replacement);
    return;
  }
  v7 = atomic_load((unint64_t *)&theString->info);
  if ((v7 & 1) == 0)
  {
    v8 = _CFOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
      CFStringReplace_cold_1(v8, v9, v10, v11, v12, v13, v14, v15);
    return;
  }
  if (replacement == theString)
  {
    Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
    replacement = Copy;
  }
  else
  {
    Copy = 0;
  }
  v17 = CFStringGetLength(replacement);
  if (v17 < 1)
  {
    v19 = 0;
  }
  else
  {
    if (CF_IS_OBJC(7uLL, (__objc2_class **)replacement))
    {
      v18 = -[__CFString _encodingCantBeStoredInEightBitCFString]((id)replacement, "_encodingCantBeStoredInEightBitCFString");
    }
    else
    {
      v20 = atomic_load((unint64_t *)&replacement->info);
      v18 = (v20 >> 4) & 1;
    }
    v19 = v18 != 0;
  }
  v32[0] = location;
  v32[1] = length;
  v21 = __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)v32, 1, v17, v19);
  v22 = atomic_load((unint64_t *)&theString->info);
  v23 = atomic_load((unint64_t *)&theString->info);
  v24 = v23 & 0x60;
  p_data = &theString->data;
  if ((v22 & 0x10) == 0)
  {
    if (v24)
    {
      v26 = *p_data;
    }
    else
    {
      v28 = atomic_load((unint64_t *)&theString->info);
      v26 = (char *)&p_data[(v28 & 5) != 4];
    }
    v29 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(v21);
      v29 = __CFDefaultEightBitStringEncoding;
    }
    v30 = atomic_load((unint64_t *)&theString->info);
    v33.location = 0;
    v33.length = v17;
    CFStringGetBytes(replacement, v33, v29, 0, 0, (UInt8 *)&v26[location + ((v30 >> 2) & 1)], v17, 0);
    goto LABEL_27;
  }
  if (!v24)
  {
    v31 = atomic_load((unint64_t *)&theString->info);
    v27 = (char *)&p_data[(v31 & 5) != 4];
    if (!v27)
      goto LABEL_27;
    goto LABEL_26;
  }
  v27 = *p_data;
  if (v27)
  {
LABEL_26:
    v34.location = 0;
    v34.length = v17;
    CFStringGetCharacters(replacement, v34, (UniChar *)&v27[2 * location]);
  }
LABEL_27:
  if (Copy)
    CFRelease(Copy);
}

CFStringRef _CFStringCreateByRemovingPercentEncoding(const __CFAllocator *a1, CFStringRef theString)
{
  CFIndex Length;
  CFIndex v5;
  CFIndex MaximumSizeForEncoding;
  uint64_t v7;
  CFIndex v8;
  CFStringRef v9;
  unint64_t v10;
  char *v11;
  CFIndex v13;
  char *v14;
  CFIndex v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  CFIndex v19[2];
  CFRange v20;

  v19[1] = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(theString);
  if (!Length)
    return CFStringCreateCopy(a1, theString);
  v5 = Length;
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding == -1)
    return 0;
  v8 = MaximumSizeForEncoding;
  v9 = 0;
  if ((MaximumSizeForEncoding & 0x8000000000000000) == 0)
  {
    v10 = 2 * MaximumSizeForEncoding;
    if (2 * MaximumSizeForEncoding)
    {
      if (v10 < 0x401)
      {
        MEMORY[0x1E0C80A78](MaximumSizeForEncoding, v7);
        v11 = (char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
        bzero(v11, 2 * v8);
      }
      else
      {
        v11 = (char *)malloc_type_malloc(2 * MaximumSizeForEncoding, 0x100004077774924uLL);
      }
      v19[0] = 0;
      v20.location = 0;
      v20.length = v5;
      if (CFStringGetBytes(theString, v20, 0x8000100u, 0, 0, (UInt8 *)v11, v8, v19))
      {
        v13 = v19[0];
        v14 = &v11[v8];
        if (v19[0] >= 1)
        {
          v15 = 0;
          v16 = (unsigned __int8 *)v11;
          v14 = &v11[v8];
          do
          {
            v17 = *v16;
            if (v17 == 37)
            {
              v15 += 2;
              if (v15 >= v13)
                goto LABEL_20;
              v18 = _CFStringCreateByRemovingPercentEncoding_hexvalues[v16[1]];
              v17 = _CFStringCreateByRemovingPercentEncoding_hexvalues[v16[2]];
              if (((v17 | v18) & 0x80) != 0)
                goto LABEL_20;
              v16 += 3;
              LOBYTE(v17) = v17 + 16 * v18;
            }
            else
            {
              ++v16;
            }
            *v14++ = v17;
            ++v15;
            v13 = v19[0];
          }
          while (v15 < v19[0]);
        }
        v9 = CFStringCreateWithBytes(0, (const UInt8 *)&v11[v8], v14 - &v11[v8], 0x8000100u, 0);
      }
      else
      {
LABEL_20:
        v9 = 0;
      }
      if (v10 >= 0x401)
        free(v11);
    }
  }
  return v9;
}

uint64_t __cficu_udat_format(uint64_t a1, const UniChar *a2, uint64_t a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12;
  CFStringRef v13;
  const void *v14;
  CFTypeRef v15;
  CFStringRef v16;
  CFStringRef v17;
  CFStringRef v18;

  v12 = udat_format();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    v15 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a2, a3);
    v16 = ___CFICUCreateArgumentForDouble(a6);
    v17 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0)
    {
      v18 = CFStringCreateWithCharacters(0, a2, (int)v12);
      if (!a4)
        goto LABEL_7;
    }
    else
    {
      v18 = 0;
      if (!a4)
      {
LABEL_7:
        ___CFICULogWithArguments(1, CFSTR("udat_format(%@, %@, %@, %d, NULL, &%@); // %d %@ %@"),
          v13,
          v16,
          v15,
          a3,
          v14,
          v12,
          v18,
          v17);
        ___CFICULogWithArguments(1, CFSTR("u_printf(\"%@: '%%S'\\n\", %@);"), v15, v15);
        CFRelease(v13);
        CFRelease(v14);
        CFRelease(v15);
        CFRelease(v16);
        if (v18)
          CFRelease(v18);
        CFRelease(v17);
        return v12;
      }
    }
    ___CFICULogWithArguments(1, CFSTR("#warning non-NULL position ignored"));
    goto LABEL_7;
  }
  return v12;
}

uint64_t __cficu_unum_toPattern(uint64_t a1, int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  uint64_t v10;
  CFStringRef v11;
  const void *v12;
  CFTypeRef v13;
  CFStringRef v14;
  CFStringRef v15;

  v10 = unum_toPattern();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v12 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    v13 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a3, a4);
    v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0)
      v15 = CFStringCreateWithCharacters(0, a3, (int)v10);
    else
      v15 = 0;
    ___CFICULogWithArguments(1, CFSTR("unum_toPattern(%@, %d, %@, %d, &%@); // %d %@ %@"),
      v11,
      a2,
      v13,
      a4,
      v12,
      v10,
      v15,
      v14);
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    if (v15)
      CFRelease(v15);
    CFRelease(v14);
  }
  return v10;
}

uint64_t __cficu_unum_getSymbol(uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  uint64_t Symbol;
  CFStringRef v11;
  CFTypeRef v12;
  const void *v13;
  CFStringRef v14;
  CFStringRef v15;
  const char *v16;

  Symbol = unum_getSymbol();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v12 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a3, a4);
    v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0)
      v15 = CFStringCreateWithCharacters(0, a3, (int)Symbol);
    else
      v15 = 0;
    v16 = ___CFICUGetEnumStringForUNumberFormatSymbol(a2);
    ___CFICULogWithArguments(1, CFSTR("unum_getSymbol(%@, %s, %@, %d, &%@); // %d %@ %@"),
      v11,
      v16,
      v12,
      a4,
      v13,
      Symbol,
      v15,
      v14);
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    if (v15)
      CFRelease(v15);
    CFRelease(v14);
  }
  return Symbol;
}

uint64_t __cficu_unum_getContext(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t Context;
  CFStringRef v7;
  CFStringRef v8;

  Context = unum_getContext();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v8 = ___CFICUCreateErrorStringWithComment(a3, 1);
    ___CFICULogWithArguments(1, CFSTR("unum_getContext(%@, %d, &%@);
    CFRelease(v8);
    CFRelease(v7);
  }
  return Context;
}

void sub_182B11360(_Unwind_Exception *a1)
{
  uint64_t v1;

  free(*(void **)(v1 - 168));
  _Unwind_Resume(a1);
}

void sub_182B11DD8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void __NSDictionaryEnumerate(void *a1, char a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  char *v21;
  unint64_t v22;
  char *v23;
  unint64_t v24;
  BOOL v25;
  CFStringRef v26;
  NSException *v27;
  _QWORD v28[5];
  _QWORD block[10];
  _QWORD v30[3];
  char v31;
  size_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v6 = objc_msgSend(a1, "count");
  if (v6)
  {
    v7 = v6;
    if ((a2 & 1) == 0)
      goto LABEL_20;
    v15 = __CFActiveProcessorCount();
    if (v15 < 2)
      a2 = 0;
    if ((a2 & 1) != 0)
    {
      v8 = 32;
      v9 = 16;
      v10 = 4;
      if (v7 < 4 * v15)
        v10 = 1;
      if (v7 < 16 * v15)
        v9 = v10;
      if (v7 < 32 * v15)
        v8 = v9;
      if (48 * v15 > v7)
        v11 = v8;
      else
        v11 = 48;
      if (v7 < v15 << 6)
        v12 = v11;
      else
        v12 = 64;
      v13 = (void *)_CFAutoreleasePoolPush();
      v14 = objc_msgSend(a1, "keyEnumerator");
      v35 = 0u;
      v34 = 0u;
      v33 = 0u;
      v36 = 0;
      v32 = 850045857;
      v30[0] = 0;
      v30[1] = v30;
      v30[2] = 0x2020000000;
      v31 = 0;
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 3221225472;
      block[2] = ____NSDictionaryEnumerate_block_invoke;
      block[3] = &unk_1E12E5C90;
      block[8] = v12;
      block[9] = &v32;
      block[6] = a3;
      block[7] = v30;
      block[4] = v14;
      block[5] = a1;
      dispatch_apply((v7 + v12 - 1) / v12, 0, block);
      _CFAutoreleasePoolPop(v13);
      _Block_object_dispose(v30, 8);
    }
    else
    {
LABEL_20:
      v16 = (void *)_CFAutoreleasePoolPush();
      objc_lookUpClass("__NSCFDictionary");
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v28[0] = MEMORY[0x1E0C809B0];
        v28[1] = 3221225472;
        v28[2] = ____NSDictionaryEnumerate_block_invoke_2;
        v28[3] = &unk_1E12E14A8;
        v28[4] = a3;
        CFBasicHashApply((uint64_t)a1, (uint64_t)v28);
      }
      else
      {
        if (((v7 >> 59) & 0xF) != 0)
        {
          v26 = CFStringCreateWithFormat(0, 0, CFSTR("*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt"), 2 * v7);
          v27 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSGenericException"), v26, 0);
          CFRelease(v26);
          objc_exception_throw(v27);
        }
        if (2 * v7 <= 1)
          v18 = 1;
        else
          v18 = 2 * v7;
        v19 = MEMORY[0x1E0C80A78](v18, v17);
        v21 = (char *)v28 - v20;
        v32 = 0;
        if (v22 >= 0x101)
        {
          v21 = (char *)_CFCreateArrayStorage(v19, 0, &v32);
          v23 = v21;
        }
        else
        {
          v23 = 0;
        }
        objc_msgSend(a1, "getObjects:andKeys:count:", &v21[8 * v7], v21, v7);
        LOBYTE(v30[0]) = 0;
        v24 = v7 - 1;
        do
        {
          __NSDICTIONARY_IS_CALLING_OUT_TO_A_BLOCK__(a3);
          if (LOBYTE(v30[0]))
            v25 = 1;
          else
            v25 = v24 == 0;
          --v24;
          v21 += 8;
        }
        while (!v25);
        free(v23);
      }
      _CFAutoreleasePoolPop(v16);
    }
  }
}

void sub_182B12E70(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182B135FC(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFDictionaryFastEnumeration(__objc2_class **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (CF_IS_OBJC(0x12uLL, a1))
    return 0;
  else
    return __CFBasicHashFastEnumeration((uint64_t)a1, a2, a3, a4);
}

void __RELEASE_OBJECTS_IN_THE_ORDEREDSET__(uint64_t a1, int a2)
{
  int *v2;
  uint64_t v3;
  void *v4;
  void *v5;

  v2 = &OBJC_IVAR_____NSFrozenOrderedSetM_storage;
  if (a2 == 1)
    v2 = &OBJC_IVAR_____NSOrderedSetM_storage;
  v3 = a1 + *v2;
  v4 = *(void **)(v3 + 8);
  if (*(_QWORD *)v3)
  {
    v5 = *(void **)(v3 + 8);
    CFRelease(*(CFTypeRef *)v3);
    v4 = v5;
  }

}

void _CFXNotificationCancelToken(uint64_t a1, uint64_t a2)
{
  CFXNotificationRegistrarRemoveToken(*(_QWORD *)(a1 + 16), a2);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
    -[__CFReadStream close](stream, "close");
  else
    _CFStreamClose((uint64_t)stream);
}

uint64_t _CFBagFastEnumeration(__objc2_class **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (CF_IS_OBJC(4uLL, a1))
    return 0;
  else
    return __CFBasicHashFastEnumeration((uint64_t)a1, a2, a3, a4);
}

void _CFPreferencesSetAppValueWithContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _CFPreferencesSetAppValueWithContainerAndConfiguration(a1, a2, a3, a4, 0);
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
  CFIndex length;
  CFIndex location;
  CFRange v5;

  length = range.length;
  location = range.location;
  if (CF_IS_OBJC(0x14uLL, (__objc2_class **)theData))
  {
    -[__CFData replaceBytesInRange:withBytes:length:](theData, "replaceBytesInRange:withBytes:length:", location, length, 0, 0);
  }
  else
  {
    v5.location = location;
    v5.length = length;
    CFDataReplaceBytes(theData, v5, 0, 0);
  }
}

void __NSArrayEnumerate(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  BOOL v26;
  char v27;
  unint64_t v28;
  void *v29;
  unint64_t v30;
  _QWORD block[13];
  _QWORD v34[3];
  char v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE v40[128];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (objc_msgSend(a1, "count"))
  {
    if ((a3 & 0x1000000000000000) != 0)
    {
      v6 = objc_msgSend(a4, "firstIndex");
      v30 = objc_msgSend(a4, "lastIndex");
    }
    else
    {
      v6 = 0;
      v30 = objc_msgSend(a1, "count") - 1;
    }
    if (v6 != 0x7FFFFFFFFFFFFFFFLL && v30 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if ((a3 & 1) != 0)
      {
        v7 = __CFActiveProcessorCount();
        if (v7 < 2)
          a3 &= ~1uLL;
      }
      else
      {
        v7 = 1;
      }
      if ((a3 & 3) != 0)
      {
        v8 = (v30 - v6 + 1) / v7 / v7;
        if (v8 >= 0x10)
        {
          if (v8 <= 0x1000)
            v9 = (v8 + 15) & 0xFFFFFFFFFFFFFFF0;
          else
            v9 = 4096;
        }
        else
        {
          v9 = 16;
        }
        v17 = v9 + v30 - v6;
        v36 = 0;
        v37 = &v36;
        v38 = 0x2020000000;
        v39 = 0x7FFFFFFFFFFFFFFFLL;
        if ((a3 & 1) != 0)
        {
          v34[0] = 0;
          v34[1] = v34;
          v34[2] = 0x2020000000;
          v35 = 0;
          block[0] = MEMORY[0x1E0C809B0];
          block[1] = 3221225472;
          block[2] = ____NSArrayEnumerate_block_invoke;
          block[3] = &unk_1E12E6278;
          block[10] = v9;
          block[11] = v30;
          block[12] = a3;
          block[4] = a1;
          block[5] = a4;
          block[7] = v34;
          block[8] = &v36;
          block[6] = a2;
          block[9] = v6;
          dispatch_apply(v17 / v9, 0, block);
          _Block_object_dispose(v34, 8);
        }
        else
        {
          v29 = a1;
          if (v9 <= v17)
          {
            v18 = 0;
            v19 = v9 - 1;
            v20 = 1;
            v21 = v6;
            v22 = v30;
            v23 = v17 / v9;
            do
            {
              if ((a3 & 2) != 0)
              {
                if (v19 >= v22 - v6)
                  v25 = v6;
                else
                  v25 = 1 - v9 + v22;
                v24 = v22;
              }
              else
              {
                if (v19 >= v22 - v6)
                  v24 = v30;
                else
                  v24 = v19 + v18 * v9 + v6;
                v25 = v21;
              }
              v26 = __NSArrayChunkIterate(v29, a3, v25, v24, a4, a2, (unint64_t *)v37 + 3, 0, 0);
              ++v18;
              v27 = v20 >= v23 || v26;
              v22 -= v9;
              v21 += v9;
              ++v20;
            }
            while ((v27 & 1) == 0);
          }
        }
        _Block_object_dispose(&v36, 8);
      }
      else
      {
        v28 = v6;
        v10 = (void *)_CFAutoreleasePoolPush();
        LOBYTE(v34[0]) = 0;
        v41 = 0u;
        v42 = 0u;
        v43 = 0u;
        v44 = 0u;
        v11 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v41, v40, 16);
        if (v11)
        {
          v12 = 0;
          v13 = 0;
          v14 = *(_QWORD *)v42;
          do
          {
            for (i = 0; i != v11; ++i)
            {
              if (*(_QWORD *)v42 != v14)
                objc_enumerationMutation(a1);
              v16 = v13 + i;
              if ((a3 & 0x1000000000000000) == 0
                || v28 <= v16 && v16 <= v30 && objc_msgSend(a4, "containsIndex:", v13 + i))
              {
                __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(a2);
                if (v12 < 0x3FF)
                {
                  ++v12;
                }
                else
                {
                  _CFAutoreleasePoolPop(v10);
                  v10 = (void *)_CFAutoreleasePoolPush();
                  v12 = 0;
                }
              }
            }
            v11 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v41, v40, 16);
            v13 += i;
          }
          while (v11);
        }
        _CFAutoreleasePoolPop(v10);
      }
    }
  }
}

void sub_182B15E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a33, 8);
  _Unwind_Resume(a1);
}

uint64_t _CFNonObjCArrayGetCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

unint64_t _CFArrayFastEnumeration(unint64_t *a1, _QWORD *a2)
{
  char v2;
  int v3;
  char v4;
  int v5;
  char v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  char v11;
  int v12;

  if (!a1[2])
    return 0;
  v2 = atomic_load(a1 + 1);
  v3 = v2 & 3;
  if (v3 != 2)
  {
    if (!v3 && !*a2)
    {
      *a2 = 1;
      a2[2] = &_CFArrayFastEnumeration_const_mu;
      v4 = atomic_load(a1 + 1);
      v5 = v4 & 3;
      if (v5 != 2)
      {
        if (!v5)
        {
LABEL_7:
          v6 = atomic_load(a1 + 1);
          v7 = (~v6 & 0xC) == 0;
          v8 = 6;
          if (v7)
            v8 = 11;
          v9 = (uint64_t)&a1[v8];
          goto LABEL_16;
        }
        goto LABEL_14;
      }
LABEL_15:
      v9 = a1[5] + 8 * *(_QWORD *)a1[5] + 16;
      goto LABEL_16;
    }
    return 0;
  }
  if (*a2)
    return 0;
  *a2 = 1;
  a2[2] = a1 + 3;
  v11 = atomic_load(a1 + 1);
  v12 = v11 & 3;
  if (v12 == 2)
    goto LABEL_15;
  if (!v12)
    goto LABEL_7;
LABEL_14:
  v9 = 0;
LABEL_16:
  a2[1] = v9;
  return a1[2];
}

id __NSOrderedSetGetIndexesPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  size_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  id v32;
  void *context;
  unint64_t v34;
  void *v35;
  void *v36;
  unint64_t v37;
  _QWORD block[14];
  _QWORD v40[3];
  char v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  _BYTE v47[128];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (!objc_msgSend(a1, "count")
    || ((a3 & 0x1000000000000000) != 0
      ? (v7 = objc_msgSend(a4, "firstIndex"), v37 = objc_msgSend(a4, "lastIndex"))
      : (v7 = 0, v37 = objc_msgSend(a1, "count") - 1),
        v7 == 0x7FFFFFFFFFFFFFFFLL || v37 == 0x7FFFFFFFFFFFFFFFLL))
  {
    __CFLookUpClass("NSIndexSet");
    return (id)objc_opt_new();
  }
  else
  {
    if ((a3 & 1) != 0)
    {
      v8 = __CFActiveProcessorCount();
      if (v8 < 2)
        a3 &= ~1uLL;
    }
    else
    {
      v8 = 1;
    }
    __CFLookUpClass("NSMutableIndexSet");
    v36 = (void *)objc_opt_new();
    if ((a3 & 3) != 0)
    {
      v10 = (v37 - v7 + 1) / v8 / v8;
      if (v10 >= 0x10)
      {
        if (v10 <= 0x1000)
          v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0;
        else
          v11 = 4096;
      }
      else
      {
        v11 = 16;
      }
      v20 = v11 + v37 - v7;
      v21 = v20 / v11;
      if ((a3 & 1) != 0)
      {
        v40[0] = 0;
        v40[1] = v40;
        v40[2] = 0x2020000000;
        v41 = 0;
        v45 = 0u;
        v44 = 0u;
        v43 = 0u;
        v46 = 0;
        v42 = 850045857;
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ____NSOrderedSetGetIndexesPassingTest_block_invoke;
        block[3] = &unk_1E12E62A0;
        block[8] = v40;
        block[9] = v7;
        block[10] = v11;
        block[11] = v37;
        block[4] = a1;
        block[5] = a4;
        block[6] = v36;
        block[7] = a2;
        block[12] = a3;
        block[13] = &v42;
        dispatch_apply(v21, 0, block);
        _Block_object_dispose(v40, 8);
      }
      else
      {
        v35 = a1;
        if (v11 <= v20)
        {
          v22 = v7;
          v23 = 0;
          v24 = v11 - 1;
          if (v21 <= 1)
            v25 = 1;
          else
            v25 = v20 / v11;
          v26 = v25 - 1;
          v27 = v22;
          v28 = v37;
          do
          {
            v29 = v26;
            if ((a3 & 2) != 0)
            {
              if (v24 >= v28 - v22)
                v31 = v22;
              else
                v31 = 1 - v11 + v28;
              v30 = v28;
            }
            else
            {
              if (v24 >= v28 - v22)
                v30 = v37;
              else
                v30 = v24 + v23 * v11 + v22;
              v31 = v27;
            }
            if (__NSOrderedSetChunkIterate(v35, a3, v31, v30, a4, a2, 0, v36, 0))
              break;
            ++v23;
            v26 = v29 - 1;
            v28 -= v11;
            v27 += v11;
          }
          while (v29);
        }
      }
    }
    else
    {
      context = (void *)_CFAutoreleasePoolPush();
      LOBYTE(v42) = 0;
      v48 = 0u;
      v49 = 0u;
      v50 = 0u;
      v51 = 0u;
      v12 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v48, v47, 16);
      if (v12)
      {
        v13 = v12;
        v34 = v7;
        v14 = 0;
        v15 = 0;
        v16 = *(_QWORD *)v49;
        do
        {
          for (i = 0; i != v13; ++i)
          {
            if (*(_QWORD *)v49 != v16)
              objc_enumerationMutation(a1);
            v18 = v15 + i;
            v19 = *(_QWORD *)(*((_QWORD *)&v48 + 1) + 8 * i);
            if ((a3 & 0x1000000000000000) == 0
              || v34 <= v18 && v18 <= v37 && objc_msgSend(a4, "containsIndex:", v15 + i))
            {
              if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(a2 + 16))(a2, v19, v15 + i, &v42))
              {
                objc_msgSend(v36, "addIndex:", v15 + i);
              }
              if ((_BYTE)v42)
                goto LABEL_33;
              if (v14 >= 0x3FF)
              {
                _CFAutoreleasePoolPop(context);
                context = (void *)_CFAutoreleasePoolPush();
                v14 = 0;
              }
              else
              {
                ++v14;
              }
            }
          }
          v13 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v48, v47, 16);
          v15 += i;
        }
        while (v13);
      }
LABEL_33:
      _CFAutoreleasePoolPop(context);
    }
    v32 = (id)objc_msgSend(v36, "copy");

    return v32;
  }
}

BOOL __NSArrayChunkIterate(void *a1, uint64_t a2, unint64_t a3, unint64_t a4, void *a5, uint64_t a6, unint64_t *a7, void *a8, pthread_mutex_t *a9)
{
  unint64_t *v14;
  unint64_t v15;
  _BOOL4 v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _BOOL4 v29;
  _BOOL4 v30;
  unint64_t *v32;
  unint64_t v33;
  _BOOL4 v34;
  unint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t *v38;
  pthread_mutex_t *v39;
  id v40;
  unint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  uint64_t v45;

  v40 = a8;
  v42 = a6;
  v45 = *MEMORY[0x1E0C80C00];
  v44 = 0;
  v43 = 0x7FFFFFFFFFFFFFFFLL;
  if (a7)
    v14 = a7;
  else
    v14 = (unint64_t *)&v43;
  if ((a2 & 0x2000000000000000) != 0)
  {
    v15 = atomic_load(v14);
    if (v15 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v16 = v15 >= a3;
      v17 = v15 <= a4;
      if ((a2 & 2) != 0)
        v16 = v17;
      if (!v16)
        return 0;
    }
  }
  v41 = v14;
  v37 = (void *)_CFAutoreleasePoolPush();
  v38 = &v36;
  v19 = MEMORY[0x1E0C80A78](v37, v18);
  v21 = (char *)&v36 - v20;
  MEMORY[0x1E0C80A78](v19, v22);
  v24 = (char *)&v36 - v23;
  if ((a2 & 0x1000000000000000) != 0
    && !objc_msgSend(a5, "__getContainmentVector:inRange:", (char *)&v36 - v23, a3, a4 - a3 + 1))
  {
    goto LABEL_46;
  }
  objc_msgSend(a1, "getObjects:range:", v21, a3, a4 - a3 + 1);
  if (a4 - a3 == -1)
    goto LABEL_46;
  v25 = 0;
  v39 = a9;
  while (1)
  {
    v26 = a4 - a3 - v25;
    if ((a2 & 2) == 0)
      v26 = v25;
    if ((a2 & 0x1000000000000000) != 0 && !v24[v26])
      goto LABEL_33;
    if ((a2 & 2) != 0)
      v27 = a4 - v25;
    else
      v27 = v25 + a3;
    if ((a2 & 0x6000000000000000) == 0)
    {
      __NSARRAY_IS_CALLING_OUT_TO_A_BLOCK__(v42);
      goto LABEL_27;
    }
    if ((__NSARRAY_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(v42) & 1) != 0)
      break;
LABEL_27:
    if (v44)
      goto LABEL_46;
    if ((a2 & 0x2000000000000000) != 0)
    {
      v28 = atomic_load(v41);
      if (v28 != 0x7FFFFFFFFFFFFFFFLL)
      {
        v29 = v28 >= a3;
        v30 = v28 <= a4;
        if ((a2 & 2) == 0)
          v30 = v29;
        if (!v30)
          goto LABEL_46;
      }
    }
LABEL_33:
    if (++v25 >= a4 - a3 + 1)
      goto LABEL_46;
  }
  if ((a2 & 0x2000000000000000) == 0)
  {
    if ((a2 & 0x4000000000000000) != 0)
    {
      if (v39)
      {
        pthread_mutex_lock(v39);
        objc_msgSend(v40, "addIndex:", v27);
        pthread_mutex_unlock(v39);
      }
      else
      {
        objc_msgSend(v40, "addIndex:", v27);
      }
    }
    goto LABEL_27;
  }
  v32 = v41;
  while (1)
  {
    v33 = atomic_load(v32);
    if (v33 != 0x7FFFFFFFFFFFFFFFLL)
    {
      v34 = v33 < v27;
      if ((a2 & 2) == 0)
        v34 = v27 < v33;
      if (!v34)
        break;
    }
    while (1)
    {
      v32 = v41;
      v35 = __ldxr(v41);
      if (v35 != v33)
        break;
      if (!__stxr(v27, v41))
        goto LABEL_46;
    }
    __clrex();
  }
LABEL_46:
  _CFAutoreleasePoolPop(v37);
  return v44 != 0;
}

id __NSArrayGetIndexesPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v7;
  uint64_t v8;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _BOOL4 v29;
  id v30;
  void *context;
  void *contexta;
  void *v33;
  void *v34;
  void *v35;
  unint64_t v36;
  _QWORD block[14];
  _QWORD v39[3];
  char v40;
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  _BYTE v46[128];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  if (!objc_msgSend(a1, "count")
    || ((a3 & 0x1000000000000000) != 0
      ? (v7 = objc_msgSend(a4, "firstIndex"), v36 = objc_msgSend(a4, "lastIndex"))
      : (v7 = 0, v36 = objc_msgSend(a1, "count") - 1),
        v7 == 0x7FFFFFFFFFFFFFFFLL || v36 == 0x7FFFFFFFFFFFFFFFLL))
  {
    __CFLookUpClass("NSIndexSet");
    return (id)objc_opt_new();
  }
  else
  {
    if ((a3 & 1) != 0)
    {
      v8 = __CFActiveProcessorCount();
      if (v8 < 2)
        a3 &= ~1uLL;
    }
    else
    {
      v8 = 1;
    }
    __CFLookUpClass("NSMutableIndexSet");
    v35 = (void *)objc_opt_new();
    if ((a3 & 3) != 0)
    {
      v10 = (v36 - v7 + 1) / v8 / v8;
      if (v10 >= 0x10)
      {
        if (v10 <= 0x1000)
          v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0;
        else
          v11 = 4096;
      }
      else
      {
        v11 = 16;
      }
      v19 = v11 + v36 - v7;
      if ((a3 & 1) != 0)
      {
        v44 = 0u;
        v43 = 0u;
        v42 = 0u;
        v45 = 0;
        v41 = 850045857;
        v39[0] = 0;
        v39[1] = v39;
        v39[2] = 0x2020000000;
        v40 = 0;
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ____NSArrayGetIndexesPassingTest_block_invoke;
        block[3] = &unk_1E12E62A0;
        block[8] = v39;
        block[9] = v7;
        block[10] = v11;
        block[11] = v36;
        block[4] = a1;
        block[5] = a4;
        block[6] = v35;
        block[7] = a2;
        block[12] = a3;
        block[13] = &v41;
        dispatch_apply(v19 / v11, 0, block);
        _Block_object_dispose(v39, 8);
      }
      else
      {
        contexta = a1;
        v34 = a4;
        if (v11 <= v19)
        {
          v20 = v7;
          v21 = 0;
          v22 = v11 - 1;
          v23 = 1;
          v24 = -(uint64_t)v7;
          v25 = v36;
          v26 = v19 / v11;
          do
          {
            if ((a3 & 2) != 0)
            {
              if (v22 >= v24 + v25)
                v28 = v20;
              else
                v28 = 1 - v11 + v25;
              v27 = v25;
            }
            else
            {
              if (v22 >= v24 + v25)
                v27 = v36;
              else
                v27 = v22 + v21 * v11 + v20;
              v28 = v7;
            }
            v29 = __NSArrayChunkIterate(contexta, a3, v28, v27, v34, a2, 0, v35, 0);
            if (v23 >= v26)
              break;
            ++v21;
            v25 -= v11;
            v7 += v11;
            ++v23;
          }
          while (!v29);
        }
      }
    }
    else
    {
      context = (void *)_CFAutoreleasePoolPush();
      LOBYTE(v41) = 0;
      v47 = 0u;
      v48 = 0u;
      v49 = 0u;
      v50 = 0u;
      v12 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v47, v46, 16);
      if (v12)
      {
        v13 = v12;
        v33 = a4;
        v14 = 0;
        v15 = 0;
        v16 = *(_QWORD *)v48;
        do
        {
          for (i = 0; i != v13; ++i)
          {
            if (*(_QWORD *)v48 != v16)
              objc_enumerationMutation(a1);
            v18 = v15 + i;
            if ((a3 & 0x1000000000000000) == 0
              || v7 <= v18 && v18 <= v36 && objc_msgSend(v33, "containsIndex:", v15 + i))
            {
              if (__NSARRAY_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(a2))
                objc_msgSend(v35, "addIndex:", v15 + i);
              if (v14 >= 0x3FF)
              {
                _CFAutoreleasePoolPop(context);
                context = (void *)_CFAutoreleasePoolPush();
                v14 = 0;
              }
              else
              {
                ++v14;
              }
            }
          }
          v13 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v47, v46, 16);
          v15 += i;
        }
        while (v13);
      }
      _CFAutoreleasePoolPop(context);
    }
    v30 = (id)objc_msgSend(v35, "copy");

    return v30;
  }
}

unint64_t __NSArrayGetIndexPassingTest(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _BOOL4 v29;
  void *context;
  void *contexta;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  _QWORD block[13];
  _QWORD v38[3];
  char v39;
  unint64_t v40;
  unint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[128];
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (!objc_msgSend(a1, "count"))
    return 0x7FFFFFFFFFFFFFFFLL;
  if ((a3 & 0x1000000000000000) != 0)
  {
    v7 = objc_msgSend(a4, "firstIndex");
    v35 = objc_msgSend(a4, "lastIndex");
  }
  else
  {
    v7 = 0;
    v35 = objc_msgSend(a1, "count") - 1;
  }
  v8 = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 != 0x7FFFFFFFFFFFFFFFLL && v35 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if ((a3 & 1) != 0)
    {
      v9 = __CFActiveProcessorCount();
      if (v9 < 2)
        a3 &= ~1uLL;
    }
    else
    {
      v9 = 1;
    }
    if ((a3 & 3) != 0)
    {
      v10 = (v35 - v7 + 1) / v9 / v9;
      if (v10 >= 0x10)
      {
        if (v10 <= 0x1000)
          v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0;
        else
          v11 = 4096;
      }
      else
      {
        v11 = 16;
      }
      v20 = v11 + v35 - v7;
      if ((a3 & 1) != 0)
      {
        v40 = 0;
        v41 = &v40;
        v42 = 0x2020000000;
        v43 = 0x7FFFFFFFFFFFFFFFLL;
        v38[0] = 0;
        v38[1] = v38;
        v38[2] = 0x2020000000;
        v39 = 0;
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 3221225472;
        block[2] = ____NSArrayGetIndexPassingTest_block_invoke;
        block[3] = &unk_1E12E6278;
        block[10] = v11;
        block[11] = v35;
        block[12] = a3;
        block[4] = a1;
        block[5] = a4;
        block[6] = a2;
        block[7] = v38;
        block[8] = &v40;
        block[9] = v7;
        dispatch_apply(v20 / v11, 0, block);
        v8 = atomic_load(v41 + 3);
        _Block_object_dispose(v38, 8);
        _Block_object_dispose(&v40, 8);
      }
      else
      {
        contexta = a4;
        v34 = a2;
        v40 = 0x7FFFFFFFFFFFFFFFLL;
        if (v11 <= v20)
        {
          v21 = 0;
          v22 = v11 - 1;
          v23 = 1;
          v24 = v7;
          v25 = v35;
          v26 = v20 / v11;
          do
          {
            if ((a3 & 2) != 0)
            {
              if (v22 >= v25 - v7)
                v28 = v7;
              else
                v28 = 1 - v11 + v25;
              v27 = v25;
            }
            else
            {
              if (v22 >= v25 - v7)
                v27 = v35;
              else
                v27 = v22 + v21 * v11 + v7;
              v28 = v24;
            }
            v29 = __NSArrayChunkIterate(a1, a3, v28, v27, contexta, v34, &v40, 0, 0);
            if (v23 >= v26)
              break;
            ++v21;
            v25 -= v11;
            v24 += v11;
            ++v23;
          }
          while (!v29);
        }
        return atomic_load(&v40);
      }
    }
    else
    {
      v12 = (void *)_CFAutoreleasePoolPush();
      LOBYTE(v40) = 0;
      v45 = 0u;
      v46 = 0u;
      v47 = 0u;
      v48 = 0u;
      v13 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v45, v44, 16);
      if (v13)
      {
        v14 = v13;
        context = v12;
        v33 = v7;
        v15 = 0;
        v16 = 0;
        v17 = *(_QWORD *)v46;
        while (2)
        {
          for (i = 0; i != v14; ++i)
          {
            if (*(_QWORD *)v46 != v17)
              objc_enumerationMutation(a1);
            v19 = v16 + i;
            if ((a3 & 0x1000000000000000) == 0
              || v33 <= v19 && v19 <= v35 && objc_msgSend(a4, "containsIndex:", v16 + i))
            {
              if ((__NSARRAY_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(a2) & 1) != 0)
              {
                v8 = v16 + i;
                goto LABEL_51;
              }
              if (v15 >= 0x3FF)
              {
                _CFAutoreleasePoolPop(context);
                context = (void *)_CFAutoreleasePoolPush();
                v15 = 0;
              }
              else
              {
                ++v15;
              }
            }
          }
          v14 = objc_msgSend(a1, "countByEnumeratingWithState:objects:count:", &v45, v44, 16);
          v16 += i;
          if (v14)
            continue;
          break;
        }
        v8 = 0x7FFFFFFFFFFFFFFFLL;
LABEL_51:
        v12 = context;
      }
      _CFAutoreleasePoolPop(v12);
    }
  }
  return v8;
}

uint64_t __NSARRAY_IS_CALLING_OUT_TO_A_BOOL_BLOCK__(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 16))();
}

CFArrayRef _copyBundleLocalizationsFromResources(__CFBundle *a1, uint64_t a2)
{
  const __CFDictionary *InfoDictionary;
  const __CFDictionary *v5;
  const __CFArray *Value;
  const __CFArray *v7;
  CFTypeID v8;
  const __CFAllocator *v9;
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex v12;
  const __CFString *ValueAtIndex;
  CFTypeID v14;
  const __CFAllocator *v15;
  const __CFArray *Copy;
  CFURLRef v17;
  const __CFURL *v18;
  CFAllocatorRef v19;
  uint64_t v20;
  const __CFArray *v21;
  __CFArray *MutableCopy;
  CFStringRef DevelopmentRegion;
  const __CFString *v24;
  CFIndex v25;
  uint64_t v26;
  const __CFString *v27;
  CFTypeRef v28;
  const __CFAllocator *v29;
  __CFString *AlternateNameForLanguage;
  __CFString *v32;
  CFIndex Length;
  CFIndex v34;
  int CharacterAtIndex;
  int v36;
  __CFString *v37;
  const __CFString *v38;
  CFIndex v39;
  const __CFString *v40;
  __CFString *v41;
  __CFString *v42;
  CFLocaleIdentifier CanonicalLanguageIdentifierFromString;
  CFIndex v44;
  const __CFString *v45;
  CFLocaleIdentifier v46;
  CFLocaleIdentifier v47;
  int v48;
  __CFArray *v49;
  const void *v50[2];
  CFRange v51;
  CFRange v52;
  CFRange v53;
  CFRange v54;
  CFRange v55;
  CFRange v56;
  CFRange v57;
  CFRange v58;

  v50[1] = *(const void **)MEMORY[0x1E0C80C00];
  InfoDictionary = CFBundleGetInfoDictionary(a1);
  if (InfoDictionary)
  {
    v5 = InfoDictionary;
    Value = (const __CFArray *)CFDictionaryGetValue(InfoDictionary, CFSTR("CFBundleLocalizations"));
    if (Value && (v7 = Value, v8 = CFGetTypeID(Value), v8 == CFArrayGetTypeID()))
    {
      v9 = CFGetAllocator(a1);
      Count = CFArrayGetCount(v7);
      Mutable = CFArrayCreateMutable(v9, Count, &kCFTypeArrayCallBacks);
      if (CFArrayGetCount(v7) >= 1)
      {
        v12 = 0;
        do
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v12);
          v14 = CFGetTypeID(ValueAtIndex);
          if (v14 == CFStringGetTypeID() && CFStringGetLength(ValueAtIndex) >= 1)
            CFArrayAppendValue(Mutable, ValueAtIndex);
          ++v12;
        }
        while (v12 < CFArrayGetCount(v7));
      }
      v15 = CFGetAllocator(a1);
      Copy = CFArrayCreateCopy(v15, Mutable);
      CFRelease(Mutable);
    }
    else
    {
      Copy = (const __CFArray *)_copyAppleLocalizations(v5);
    }
  }
  else
  {
    Copy = 0;
  }
  v17 = CFBundleCopyResourcesDirectoryURL(a1);
  if (v17)
  {
    v18 = v17;
    v19 = CFGetAllocator(a1);
    v20 = _CFBundleCopyLProjDirectoriesForURL((uint64_t)v19, v18);
    if (v20)
    {
      v21 = (const __CFArray *)v20;
      if (Copy)
      {
        MutableCopy = CFArrayCreateMutableCopy(0, 0, Copy);
        CFRelease(Copy);
        v58.length = CFArrayGetCount(v21);
        v58.location = 0;
        CFArrayAppendArray(MutableCopy, v21, v58);
        CFRelease(v21);
        Copy = MutableCopy;
      }
      else
      {
        Copy = (const __CFArray *)v20;
      }
    }
    CFRelease(v18);
  }
  DevelopmentRegion = CFBundleGetDevelopmentRegion(a1);
  v24 = DevelopmentRegion;
  v50[0] = DevelopmentRegion;
  if (Copy)
  {
    if (DevelopmentRegion)
    {
      v25 = CFArrayGetCount(Copy);
      if (a2 != 1)
      {
        if (a2)
          return Copy;
        if ((dyld_program_sdk_at_least() & 1) != 0)
          goto LABEL_25;
      }
      v51.location = 0;
      v51.length = v25;
      if (CFArrayContainsValue(Copy, v51, CFSTR("Base")))
      {
LABEL_25:
        v26 = CFArrayGetCount(Copy);
        v52.location = 0;
        v52.length = v26;
        if (CFArrayContainsValue(Copy, v52, v24))
        {
          v27 = v24;
        }
        else
        {
          AlternateNameForLanguage = _CFBundleGetAlternateNameForLanguage(v24);
          if (AlternateNameForLanguage
            && (v32 = AlternateNameForLanguage,
                v53.location = 0,
                v53.length = v26,
                CFArrayContainsValue(Copy, v53, AlternateNameForLanguage)))
          {
            v27 = v32;
          }
          else
          {
            Length = CFStringGetLength(v24);
            if (Length >= 4)
            {
              v34 = Length;
              CharacterAtIndex = CFStringGetCharacterAtIndex(v24, 2);
              v36 = CharacterAtIndex;
              if (CharacterAtIndex == 95 || CharacterAtIndex == 45)
              {
                v37 = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, v34, v24);
                v28 = v37;
                v38 = v36 == 45 ? CFSTR("_") : CFSTR("-");
                v54.location = 2;
                v54.length = 1;
                CFStringReplace(v37, v54, v38);
                if (v28)
                {
                  v55.location = 0;
                  v55.length = v26;
                  if (CFArrayContainsValue(Copy, v55, v28))
                    goto LABEL_28;
                  CFRelease(v28);
                }
              }
            }
            if (CFArrayGetCount(Copy) < 1)
              goto LABEL_54;
            v39 = 0;
            while (1)
            {
              v40 = (const __CFString *)CFArrayGetValueAtIndex(Copy, v39);
              v41 = _CFBundleGetAlternateNameForLanguage(v24);
              v42 = _CFBundleGetAlternateNameForLanguage(v40);
              if (_CFBundleIsLanguageDefaultLanguageOfOther(v24, v40)
                || _CFBundleIsLanguageDefaultLanguageOfOther(v41, v40)
                || _CFBundleIsLanguageDefaultLanguageOfOther(v24, v42))
              {
                break;
              }
              if (++v39 >= CFArrayGetCount(Copy))
                goto LABEL_54;
            }
            if (v40 && (v56.location = 0, v56.length = v26, CFArrayContainsValue(Copy, v56, v40)))
            {
              v27 = v40;
            }
            else
            {
LABEL_54:
              CanonicalLanguageIdentifierFromString = CFLocaleCreateCanonicalLanguageIdentifierFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v24);
              if (!CanonicalLanguageIdentifierFromString)
                goto LABEL_62;
              v28 = CanonicalLanguageIdentifierFromString;
              v57.location = 0;
              v57.length = v26;
              if (CFArrayContainsValue(Copy, v57, CanonicalLanguageIdentifierFromString))
                goto LABEL_28;
              if (v26 < 1)
              {
LABEL_61:
                CFRelease(v28);
                goto LABEL_62;
              }
              v44 = 0;
              while (1)
              {
                v45 = (const __CFString *)CFArrayGetValueAtIndex(Copy, v44);
                v46 = CFLocaleCreateCanonicalLanguageIdentifierFromString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v45);
                if (v46)
                {
                  v47 = v46;
                  v48 = CFEqual(v46, v28);
                  CFRelease(v47);
                  if (v48)
                    break;
                }
                if (v26 == ++v44)
                  goto LABEL_61;
              }
              CFRelease(v28);
              v27 = v45;
            }
          }
        }
        v28 = CFRetain(v27);
        if (v28)
        {
LABEL_28:
          CFRelease(v28);
          return Copy;
        }
LABEL_62:
        v49 = CFArrayCreateMutableCopy(0, 0, Copy);
        CFRelease(Copy);
        CFArrayAppendValue(v49, v24);
        return v49;
      }
    }
  }
  else
  {
    v29 = CFGetAllocator(a1);
    if (!v24)
      return CFArrayCreate(v29, 0, 0, &kCFTypeArrayCallBacks);
    return CFArrayCreate(v29, v50, 1, &kCFTypeArrayCallBacks);
  }
  return Copy;
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  char *i;
  _BYTE *v5;
  uint64_t v6;
  int v7;
  char *v8;
  char *v9;
  int v10;
  char **v11;
  char **v12;
  char *v13;
  char *v14;
  _QWORD __key[2];
  _BYTE v16[257];
  _BYTE v17[257];
  char buffer[257];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (!localeIdentifier || !CFStringGetCString(localeIdentifier, buffer, 257, 0x600u))
    return 0;
  for (i = buffer; ; ++i)
  {
    if (!*i)
    {
      v17[0] = 0;
      goto LABEL_14;
    }
    if (*i == 64)
      break;
  }
  v17[0] = 64;
  *i = 0;
  v5 = v17;
  v6 = 1;
  do
  {
    v7 = i[v6];
    if (v7 != 32)
    {
      *++v5 = v7;
      v7 = i[v6];
    }
    ++v6;
  }
  while (v7);
LABEL_14:
  __key[0] = buffer;
  __key[1] = 0;
  if (!bsearch(__key, oldAppleLocaleToCanonical, 0xB8uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey))
  {
    v13 = 0;
    v14 = 0;
    _UpdateFullLocaleString(buffer, &v14, &v13, v16);
    v8 = v13;
    v9 = v14;
    if (v14 && v13)
    {
      if (strncmp(v14 + 1, v13 + 1, 2uLL))
        goto LABEL_22;
      do
      {
        v10 = v9[3];
        *v9++ = v10;
      }
      while (v10);
      v8 = v13;
    }
    if (!v8)
    {
LABEL_24:
      __key[0] = buffer;
      v12 = (char **)bsearch(__key, localeStringPrefixToDefaults, 0xB7uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryPrefixToTableEntryKey);
      if (v12)
        _RemoveSubstringsIfPresent(buffer, v12[1]);
      goto LABEL_26;
    }
LABEL_22:
    __key[0] = v8;
    v11 = (char **)bsearch(__key, localeStringRegionToDefaults, 5uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey);
    if (v11)
      _RemoveSubstringsIfPresent(buffer, v11[1]);
    goto LABEL_24;
  }
  __strlcpy_chk();
  v16[0] = 0;
LABEL_26:
  _AppendKeyValueString((uint64_t)buffer, v16);
  _AppendKeyValueString((uint64_t)buffer, v17);
  return CFStringCreateWithCString(allocator, buffer, 0x600u);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLanguageIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  uint64_t *i;
  _BYTE *v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  BOOL v9;
  char **v10;
  char *p_buffer;
  char *j;
  unsigned int v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  char v21;
  char *v22;
  char *v23;
  _QWORD __key[2];
  _BYTE v25[257];
  _BYTE v26[257];
  uint64_t buffer;
  __int16 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!localeIdentifier || !CFStringGetCString(localeIdentifier, (char *)&buffer, 257, 0x600u))
    return 0;
  for (i = &buffer; ; i = (uint64_t *)((char *)i + 1))
  {
    if (!*(_BYTE *)i)
    {
      v26[0] = 0;
      goto LABEL_14;
    }
    if (*(_BYTE *)i == 64)
      break;
  }
  v26[0] = 64;
  *(_BYTE *)i = 0;
  v5 = v26;
  v6 = 1;
  do
  {
    v7 = *((unsigned __int8 *)i + v6);
    if (v7 != 32)
    {
      *++v5 = v7;
      v7 = *((unsigned __int8 *)i + v6);
    }
    ++v6;
  }
  while (v7);
LABEL_14:
  __key[0] = &buffer;
  __key[1] = 0;
  if (buffer == 0x4F484141535F6161
    || (buffer == 0x414D4B4F425F6F6ELL ? (v8 = v28 == 76) : (v8 = 0),
        v8
     || (buffer == 0x524F4E594E5F6F6ELL ? (v9 = v28 == 19283) : (v9 = 0),
         v9
      || bsearch(__key, oldAppleLocaleToCanonical, 0xB8uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey))))
  {
    __strlcpy_chk();
    v25[0] = 0;
  }
  else
  {
    v22 = 0;
    v23 = 0;
    _UpdateFullLocaleString((char *)&buffer, &v23, &v22, v25);
    if (v23 && v22)
      *v22 = 0;
  }
  __key[0] = &buffer;
  v10 = (char **)bsearch(__key, localeStringPrefixToDefaults, 0xB7uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryPrefixToTableEntryKey);
  if (v10)
    _RemoveSubstringsIfPresent((char *)&buffer, v10[1]);
  __key[0] = &buffer;
  if (bsearch(__key, appleLocaleToLanguageString, 6uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareTestEntryToTableEntryKey))
  {
    __strlcpy_chk();
  }
  else
  {
    p_buffer = (char *)&buffer;
    for (j = (char *)&buffer; *j; ++j)
    {
      if (*j == 95)
      {
        v14 = j + 1;
        v13 = j[1];
        v15 = MEMORY[0x1E0C80978];
        if ((v13 & 0x80000000) != 0)
        {
          if (__maskrune(j[1], 0x100uLL))
            goto LABEL_35;
        }
        else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v13 + 60) & 0x100) != 0)
        {
LABEL_35:
          v16 = 3;
          do
          {
            v18 = *++v14;
            v17 = v18;
            if ((v18 & 0x80000000) != 0)
              v19 = __maskrune(v17, 0x100uLL);
            else
              v19 = *(_DWORD *)(v15 + 4 * v17 + 60) & 0x100;
          }
          while (v19);
          goto LABEL_50;
        }
        if (v13 - 48 > 9)
        {
          v16 = 0;
        }
        else
        {
          v16 = 4;
          do
            v20 = *++v14;
          while ((v20 - 48) < 0xA);
        }
LABEL_50:
        if (&v14[-v16] == p_buffer)
          v21 = 45;
        else
          v21 = 0;
        *j = v21;
        j = v14;
        break;
      }
      ++p_buffer;
    }
    *j = 0;
  }
  _AppendKeyValueString((uint64_t)&buffer, v25);
  _AppendKeyValueString((uint64_t)&buffer, v26);
  return CFStringCreateWithCString(allocator, (const char *)&buffer, 0x600u);
}

void _AppendKeyValueString(uint64_t a1, _BYTE *a2)
{
  if (*a2 && uloc_openKeywords())
  {
    while (uenum_next())
    {
      uloc_getKeywordValue();
      uloc_setKeywordValue();
    }
    uenum_close();
  }
}

unint64_t _UpdateFullLocaleString(char *a1, char **a2, char **a3, _BYTE *a4)
{
  const char **v5;
  const char **v6;
  int v7;
  const char *v8;
  int v9;
  uint64_t v10;
  int v11;
  char *v12;
  char *v13;
  int v14;
  char v15;
  unsigned __int8 *v16;
  char *v17;
  int v18;
  uint64_t v19;
  char *v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  char *v25;
  char *v26;
  unsigned int v27;
  char v28;
  int v29;
  char *v30;
  int v31;
  _BYTE *v32;
  int v33;
  int v34;
  _BYTE *i;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t *v39;
  const char *v40;
  unint64_t result;
  char *v42;
  unsigned int v43;
  char *v44;
  unsigned int v45;
  char *v46;
  unsigned int v47;
  const char *v48;
  unsigned int v49;
  char v50;
  unsigned __int8 *v51;
  _BYTE *v52;
  int v53;
  char v54;
  unsigned __int8 *v55;
  _BYTE *v56;
  int v57;
  char v58;
  unsigned __int8 *v59;
  char *v60;
  int v61;
  _BYTE *v62;
  char v63;
  unsigned __int8 *v64;
  char *v65;
  int v66;
  char *v70;
  char *v71;
  _QWORD __key[3];

  __key[2] = *MEMORY[0x1E0C80C00];
  __key[0] = a1;
  __key[1] = 0;
  v5 = (const char **)bsearch(__key, localeStringPrefixToCanonical, 0x131uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))_CompareLowerTestEntryPrefixToTableEntryKey);
  if (!v5)
    goto LABEL_15;
  v6 = v5;
  v7 = strlen(*v5);
  v8 = v6[1];
  v9 = strlen(v8);
  v10 = (v9 - v7);
  if (v9 - v7 < 0)
  {
    v13 = &a1[v9];
    do
    {
      v14 = v13[v7 - v9];
      *v13++ = v14;
    }
    while (v14);
LABEL_11:
    if (v8)
    {
      v15 = *v8;
      if (*v8)
      {
        v16 = (unsigned __int8 *)(v8 + 1);
        v17 = a1;
        do
        {
          *v17++ = v15;
          v18 = *v16++;
          v15 = v18;
        }
        while (v18);
      }
    }
    goto LABEL_15;
  }
  if (v9 == v7)
    goto LABEL_11;
  v11 = strlen(a1);
  if ((int)v10 + v11 <= 256)
  {
    if (v11 >= (uint64_t)v7)
    {
      v12 = &a1[v11];
      do
      {
        v12[v10] = *v12;
        --v12;
      }
      while (v12 >= &a1[v7]);
    }
    goto LABEL_11;
  }
LABEL_15:
  v19 = 0;
  v70 = 0;
  v71 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = MEMORY[0x1E0C80978];
  v25 = a1;
  while (1)
  {
    v26 = &a1[v19];
    v27 = a1[v19];
    if ((v27 & 0x80000000) != 0)
      break;
    if ((*(_DWORD *)(v24 + 4 * v27 + 60) & 0x100) == 0)
      goto LABEL_21;
LABEL_18:
    if (v23)
      v28 = __toupper(v27);
    else
      v28 = __tolower(v27);
    *v26 = v28;
LABEL_25:
    ++v19;
  }
  if (__maskrune(a1[v19], 0x100uLL))
    goto LABEL_18;
LABEL_21:
  if (v27 - 48 < 0xA)
  {
    v21 = 1;
    goto LABEL_25;
  }
  if (v22)
  {
    if (v23)
    {
      v23 = 1;
      v20 = v25;
      goto LABEL_51;
    }
    v29 = (_DWORD)v25 - (_DWORD)a1;
    if ((_DWORD)v25 - (_DWORD)a1 + 3 != (_DWORD)v19 || v21)
    {
      if (v29 + 4 == (_DWORD)v19 && v21)
      {
        if (*v25 == 95)
          goto LABEL_38;
        v30 = v71;
        if (!v71)
          v30 = v25;
        v71 = v30;
      }
      else if (v29 + 5 != (_DWORD)v19 || v21)
      {
        if (v29 + 1 == (_DWORD)v19 && *v25 == 95)
        {
          v23 = 1;
          goto LABEL_51;
        }
      }
      else
      {
        v25[1] = __toupper(v25[1]);
      }
    }
    else
    {
      if (*v25 == 95)
      {
        v25[1] = __toupper(v25[1]);
        v25[2] = __toupper(v25[2]);
LABEL_38:
        v23 = 1;
        v70 = v25;
        goto LABEL_51;
      }
      if (!v71)
      {
        v25[1] = __toupper(v25[1]);
        v25[2] = __toupper(v25[2]);
        v71 = v25;
      }
    }
    v23 = 0;
    *v25 = 45;
    goto LABEL_51;
  }
  if (v21)
    goto LABEL_53;
LABEL_51:
  v21 = 0;
  v31 = *v26;
  v22 = 1;
  v25 = &a1[v19];
  if (v31 == 95 || v31 == 45)
    goto LABEL_25;
LABEL_53:
  v32 = a4;
  *a4 = 0;
  if (v20)
  {
    v33 = uloc_canonicalize();
    if (v33 >= 256)
      v34 = 256;
    else
      v34 = v33;
    a4[v34] = 0;
    for (i = a4 + 1; *(i - 1); ++i)
    {
      if (*(i - 1) == 64)
      {
        do
        {
          *v20 = 0;
          v36 = *--v20;
        }
        while (v36 == 95);
        LOBYTE(v37) = *(i - 1);
        if ((_BYTE)v37)
        {
          v38 = 0;
          do
          {
            a4[v38] = v37;
            v37 = i[v38++];
          }
          while (v37);
          v32 = &a4[v38];
        }
        break;
      }
    }
    *v32 = 0;
  }
  v39 = &specialCases;
  v40 = "-UK";
  while (2)
  {
    if (*v39)
    {
      result = _CheckForTag((uint64_t)a1, (const char *)*v39);
      if (!(_DWORD)result)
        goto LABEL_107;
    }
    v42 = (char *)v39[2];
    v43 = *v42;
    if ((v43 & 0x80000000) != 0)
    {
      if (!__maskrune(v43, 0x8000uLL))
        goto LABEL_77;
LABEL_72:
      result = (unint64_t)strstr(a1, v40);
      if (!result)
        goto LABEL_92;
      v44 = (char *)result;
      v45 = *(char *)(result + 3);
      if ((v45 & 0x80000000) != 0)
      {
        result = __maskrune(v45, 0x500uLL);
        if (!(_DWORD)result)
          goto LABEL_89;
      }
      else
      {
        result = *(_DWORD *)(v24 + 4 * v45 + 60) & 0x500;
        if (!(_DWORD)result)
        {
LABEL_89:
          v50 = *v42;
          if (*v42)
          {
            v51 = (unsigned __int8 *)(v42 + 1);
            v52 = v44 + 1;
            do
            {
              *v52++ = v50;
              v53 = *v51++;
              v50 = v53;
            }
            while (v53);
          }
        }
      }
LABEL_92:
      if (v70)
      {
        result = _CheckForTag((uint64_t)(v70 + 1), v40 + 1);
        if ((_DWORD)result)
        {
          v54 = *v42;
          if (*v42)
          {
            v55 = (unsigned __int8 *)(v42 + 1);
            v56 = v70 + 1;
            do
            {
              *v56++ = v54;
              v57 = *v55++;
              v54 = v57;
            }
            while (v57);
          }
        }
      }
      goto LABEL_107;
    }
    if ((*(_DWORD *)(v24 + 4 * v43 + 60) & 0x8000) != 0)
      goto LABEL_72;
LABEL_77:
    if (v70)
    {
      result = _CheckForTag((uint64_t)(v70 + 1), v40 + 1);
      if ((_DWORD)result)
        goto LABEL_99;
    }
    v46 = strstr(a1, v40);
    if (v46)
    {
      v47 = v46[3];
      if ((v47 & 0x80000000) != 0)
      {
        result = __maskrune(v47, 0x500uLL);
        if ((_DWORD)result)
          goto LABEL_82;
      }
      else
      {
        result = *(_DWORD *)(v24 + 4 * v47 + 60) & 0x500;
        if ((_DWORD)result)
          goto LABEL_82;
      }
LABEL_99:
      v58 = *v42;
      if (*v42)
      {
        v59 = (unsigned __int8 *)(v42 + 1);
        v60 = a1;
        do
        {
          *v60++ = v58;
          v61 = *v59++;
          v58 = v61;
        }
        while (v61);
      }
    }
    else
    {
LABEL_82:
      v48 = (const char *)v39[3];
      if (!v70 || (result = _CheckForTag((uint64_t)(v70 + 1), v48 + 1), !(_DWORD)result))
      {
        result = (unint64_t)strstr(a1, v48);
        if (!result)
          goto LABEL_107;
        v49 = *(char *)(result + 3);
        if ((v49 & 0x80000000) != 0)
        {
          result = __maskrune(v49, 0x500uLL);
          if ((_DWORD)result)
            goto LABEL_107;
        }
        else
        {
          result = *(_DWORD *)(v24 + 4 * v49 + 60) & 0x500;
          if ((_DWORD)result)
            goto LABEL_107;
        }
      }
      v62 = (_BYTE *)v39[4];
      v63 = *v62;
      if (*v62)
      {
        v64 = v62 + 1;
        v65 = a1;
        do
        {
          *v65++ = v63;
          v66 = *v64++;
          v63 = v66;
        }
        while (v66);
      }
    }
LABEL_107:
    v40 = (const char *)v39[6];
    v39 += 5;
    if (v40)
      continue;
    break;
  }
  if (a2)
    *a2 = v71;
  if (a3)
    *a3 = v70;
  return result;
}

BOOL _CheckForTag(uint64_t a1, const char *a2)
{
  unsigned int v4;
  int v5;

  if (strncmp((const char *)a1, a2, 2uLL))
    return 0;
  v4 = *(char *)(a1 + 2);
  if ((v4 & 0x80000000) != 0)
    v5 = __maskrune(v4, 0x500uLL);
  else
    v5 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v4 + 60) & 0x500;
  return v5 == 0;
}

BOOL _CFBundleIsLanguageDefaultLanguageOfOther(const void *a1, const void *a2)
{
  _BOOL8 v2;
  const __CFString *v4;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;

  v2 = 0;
  if (a1 && a2)
  {
    v4 = (const __CFString *)_CFBundleCopyDefaultLanguageForLanguage(a1);
    if (v4)
    {
      v5 = v4;
      v6 = (const __CFString *)_CFBundleCopyDefaultLanguageForLanguage(a2);
      if (v6)
      {
        v7 = v6;
        v2 = CFStringCompare(v5, v6, 1uLL) == kCFCompareEqualTo;
        CFRelease(v5);
        v5 = v7;
      }
      else
      {
        v2 = 0;
      }
      CFRelease(v5);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

const void *_CFBundleCopyDefaultLanguageForLanguage(const void *a1)
{
  const __CFDictionary *Mutable;
  const __CFString *Value;
  const void *Copy;

  os_unfair_lock_lock_with_options();
  Mutable = (const __CFDictionary *)_CFBundleCopyDefaultLanguageForLanguage_cache;
  if (!_CFBundleCopyDefaultLanguageForLanguage_cache)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    _CFBundleCopyDefaultLanguageForLanguage_cache = (uint64_t)Mutable;
  }
  Value = (const __CFString *)CFDictionaryGetValue(Mutable, a1);
  if (Value)
  {
    Copy = CFStringCreateCopy(0, Value);
LABEL_7:
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleCopyDefaultLanguageForLanguage_defaultLanguageLock);
    return Copy;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFBundleCopyDefaultLanguageForLanguage_defaultLanguageLock);
  Copy = _CFLocaleCopyLocaleIdentifierByAddingLikelySubtags((uint64_t)a1);
  if (Copy)
  {
    os_unfair_lock_lock_with_options();
    CFDictionarySetValue((CFMutableDictionaryRef)_CFBundleCopyDefaultLanguageForLanguage_cache, a1, Copy);
    goto LABEL_7;
  }
  return Copy;
}

void CFDateComponentsSetCalendar(uint64_t a1, void *cf2)
{
  const void *v4;
  __CFCalendar *Copy;
  __CFCalendar *v6;
  const __CFTimeZone *v7;

  if (!a1)
    CFDateComponentsSetCalendar_cold_1();
  v4 = *(const void **)(a1 + 16);
  if (cf2 && v4)
  {
    if (CFEqual(v4, cf2))
      return;
    v4 = *(const void **)(a1 + 16);
  }
  else if (!v4)
  {
    goto LABEL_8;
  }
  CFRelease(v4);
  *(_QWORD *)(a1 + 16) = 0;
LABEL_8:
  if (cf2)
  {
    Copy = (__CFCalendar *)_CFCalendarCreateCopy((uint64_t)&__kCFAllocatorSystemDefault, cf2);
    v6 = Copy;
    v7 = *(const __CFTimeZone **)(a1 + 24);
    if (v7)
      CFCalendarSetTimeZone(Copy, v7);
    *(_QWORD *)(a1 + 16) = v6;
  }
}

uint64_t _CFCalendarCreateCopy(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "copy");
}

void sub_182B18AC8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  free(v2);
  free(v1);
  _Unwind_Resume(a1);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  if (CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
    return (CFMutableArrayRef)-[NSArray initWithArray:copyItems:]([NSMutableArray alloc], "initWithArray:copyItems:", theArray, 0);
  if (__CFArrayGetCallBacks((uint64_t)theArray) != &kCFTypeArrayCallBacks
    || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
    && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
  {
    return __CFArrayCreateMutableCopy0((__objc2_class **)allocator, capacity, (unint64_t *)theArray);
  }
  if (__FoundationPresent_static_init != -1)
    dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
  if (__FoundationPresent_present)
    return (CFMutableArrayRef)-[NSArray initWithArray:copyItems:]([NSMutableArray alloc], "initWithArray:copyItems:", theArray, 0);
  else
    return __CFArrayCreateMutableCopy0((__objc2_class **)allocator, capacity, (unint64_t *)theArray);
}

char *_RemoveSubstringsIfPresent(char *__s1, char *a2)
{
  char v2;
  char *v3;
  char *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  char *v8;
  char *v9;
  unsigned int v10;
  int v11;
  char __s2[257];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = *a2;
  if (!*a2)
    return __s1;
  v3 = a2;
  v4 = __s1;
  v5 = MEMORY[0x1E0C80978];
  do
  {
    v6 = 0;
    v7 = 0;
    v8 = v3 - 1;
    while ((v2 & 0x80) == 0)
    {
      if ((*(_DWORD *)(v5 + 4 * v2 + 60) & 0x800) == 0)
        goto LABEL_9;
LABEL_8:
      __s2[v7] = v2;
      v9 = &v3[v7++];
      v2 = v9[1];
      ++v8;
      ++v6;
    }
    if (__maskrune(v2, 0x800uLL))
      goto LABEL_8;
LABEL_9:
    v3 = v8;
    do
    {
      v10 = v3[1];
      if ((v10 & 0x80000000) != 0)
        __s1 = (char *)__maskrune(v10, 0x4000uLL);
      else
        __s1 = (char *)(*(_DWORD *)(v5 + 4 * v10 + 60) & 0x4000);
      ++v3;
    }
    while ((_DWORD)__s1);
    if ((_DWORD)v7)
    {
      __s2[v7] = 0;
      __s1 = strstr(v4, __s2);
      if (__s1)
      {
        do
        {
          v11 = __s1[v6];
          *__s1++ = v11;
        }
        while (v11);
      }
    }
    v2 = *v3;
  }
  while (*v3);
  return __s1;
}

__CFString *_CFBundleGetAlternateNameForLanguage(CFTypeRef cf1)
{
  uint64_t v2;
  __CFString *v3;
  int v4;
  __CFString *v5;

  v2 = 0;
  while (1)
  {
    v3 = _CFBundleGetAlternateNameForLanguage___CFBundleCommonLanguageAbbreviationsArray[v2];
    v4 = CFEqual(cf1, v3);
    v5 = _CFBundleGetAlternateNameForLanguage___CFBundleCommonLanguageNamesArray[v2];
    if (v4)
      break;
    if (CFEqual(cf1, v5))
      return v3;
    if (++v2 == 7)
      return 0;
  }
  return v5;
}

CFStringRef CFBundleGetDevelopmentRegion(CFBundleRef bundle)
{
  unint64_t v2;
  const __CFDictionary *InfoDictionary;
  const __CFString *Value;
  const __CFString *v5;
  CFTypeID v6;

  v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  InfoDictionary = CFBundleGetInfoDictionary(bundle);
  if (!InfoDictionary)
    return 0;
  Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, CFSTR("CFBundleDevelopmentRegion"));
  v5 = Value;
  if (Value)
  {
    v6 = CFGetTypeID(Value);
    if (v6 != CFStringGetTypeID() || !CFStringGetLength(v5))
      return 0;
  }
  return v5;
}

CFURLRef _CFBundleCopyResourcesDirectoryURLInDirectory(CFURLRef baseURL, int a2)
{
  const __CFString *v2;
  const __CFString *v3;

  if (baseURL)
  {
    if (a2 <= 1)
    {
      if (a2)
      {
        if (a2 != 1)
          return (CFURLRef)CFRetain(baseURL);
        v3 = CFSTR("Support%20Files/Resources/");
      }
      else
      {
        v3 = CFSTR("Resources/");
      }
    }
    else
    {
      if (a2 != 2)
      {
        if (a2 == 12)
        {
          v2 = CFSTR("WrappedBundle/Contents/Resources/");
          return _CFURLCreateResolvedDirectoryWithString((const __CFAllocator *)&__kCFAllocatorSystemDefault, v2, baseURL);
        }
        if (a2 == 13)
        {
          v2 = CFSTR("WrappedBundle/");
          return _CFURLCreateResolvedDirectoryWithString((const __CFAllocator *)&__kCFAllocatorSystemDefault, v2, baseURL);
        }
        return (CFURLRef)CFRetain(baseURL);
      }
      v3 = CFSTR("Contents/Resources/");
    }
    return CFURLCreateWithString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3, baseURL);
  }
  return baseURL;
}

CFURLRef CFBundleCopyResourcesDirectoryURL(CFBundleRef bundle)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)bundle);
  if (v2 != 31)
    _CFAssertMismatchedTypeID(0x1FuLL, v2);
  return _CFBundleCopyResourcesDirectoryURLInDirectory(*((CFURLRef *)bundle + 2), *((unsigned __int8 *)bundle + 53));
}

id _CFLocaleCopyLocaleIdentifierByAddingLikelySubtags(uint64_t a1)
{
  return (id)+[NSLocale _localeIdentifierByAddingLikelySubtags:](NSLocale, "_localeIdentifierByAddingLikelySubtags:", a1);
}

uint64_t _CFBundleCopyLProjDirectoriesForURL(uint64_t a1, CFURLRef relativeURL)
{
  const __CFURL *v3;
  const __CFString *v4;
  CFIndex Length;
  uint64_t v6;
  _QWORD v8[8];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v3 = CFURLCopyAbsoluteURL(relativeURL);
  v4 = CFURLCopyFileSystemPath(v3, kCFURLPOSIXPathStyle);
  CFRelease(v3);
  Length = CFStringGetLength(CFSTR(".lproj"));
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = ___CFBundleCopyLProjDirectoriesForURL_block_invoke;
  v8[3] = &unk_1E12E69E0;
  v8[4] = &v9;
  v8[5] = Length;
  v8[6] = CFSTR(".lproj");
  v8[7] = a1;
  _CFIterateDirectory(v4, 0, 0, (uint64_t)v8);
  CFRelease(v4);
  v6 = v10[3];
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_182B191D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _copyAppleLocalizations(const __CFDictionary *a1)
{
  const __CFURL *v2;
  CFBundleRef v3;
  uint64_t v4;

  if (CFDictionaryGetValue(a1, CFSTR("_CFBundleUseAppleLocalizations")) != &__kCFBooleanTrue)
    return 0;
  v2 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("/System/Library/Frameworks/CoreFoundation.framework"), kCFURLPOSIXPathStyle, 1u);
  v3 = CFBundleCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v2);
  v4 = _copyBundleLocalizationsFromResources(v3, 0);
  CFRelease(v2);
  CFRelease(v3);
  return v4;
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  if (!CF_IS_OBJC(0x13uLL, (__objc2_class **)theArray))
  {
    if (__CFArrayGetCallBacks((uint64_t)theArray) != &kCFTypeArrayCallBacks
      || &__kCFAllocatorSystemDefault != (__objc2_class **)allocator
      && (allocator || &__kCFAllocatorSystemDefault != (__objc2_class **)CFAllocatorGetDefault()))
    {
      return (CFArrayRef)__CFArrayCreateCopy0((__objc2_class **)allocator, (unint64_t *)theArray);
    }
    if (__FoundationPresent_static_init != -1)
      dispatch_once(&__FoundationPresent_static_init, &__block_literal_global_10);
    if (!__FoundationPresent_present)
      return (CFArrayRef)__CFArrayCreateCopy0((__objc2_class **)allocator, (unint64_t *)theArray);
  }
  if (_CFArrayIsMutable((uint64_t)theArray))
    return (CFArrayRef)-[NSArray initWithArray:copyItems:]([NSArray alloc], "initWithArray:copyItems:", theArray, 0);
  return (CFArrayRef)-[__CFArray copyWithZone:](theArray, "copyWithZone:", 0);
}

BOOL _CFArrayIsMutable(uint64_t a1)
{
  char v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return (v1 & 3) != 0;
}

const CFArrayCallBacks *__CFArrayGetCallBacks(uint64_t a1)
{
  unsigned int v1;
  int v2;
  char v4;
  int v5;
  uint64_t v6;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  v2 = (v1 >> 2) & 3;
  if (!v2)
    return (const CFArrayCallBacks *)&__kCFNullArrayCallBacks;
  if (v2 == 1)
    return &kCFTypeArrayCallBacks;
  v4 = atomic_load((unint64_t *)(a1 + 8));
  v5 = v4 & 3;
  if (v5)
    v6 = 0;
  else
    v6 = a1 + 48;
  if (v5 == 2)
    return (const CFArrayCallBacks *)(a1 + 48);
  else
    return (const CFArrayCallBacks *)v6;
}

uint64_t __CFActiveProcessorCount()
{
  return MEMORY[0xFFFFFC034];
}

unint64_t _NSMS3StackAlignedOffset_arm64(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  v5[0] = 0;
  __NSGetSizeAndAlignment((_BYTE *)(a1 + 37), 0, v5, 0, 1, 0, 1uLL);
  v3 = v5[0];
  if (v5[0] <= 1uLL)
    v3 = 1;
  return (a2 + v3 - 1) / v3 * v3;
}

uint64_t __forwarding_prep_b___@<X0>(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, void *a4@<X3>, void *a5@<X4>, void *a6@<X5>, void *a7@<X6>, void *a8@<X7>, void *a9@<X8>, __n128 a10@<Q0>, __n128 a11@<Q1>, __n128 a12@<Q2>, __n128 a13@<Q3>, __n128 a14@<Q4>, __n128 a15@<Q5>, __n128 a16@<Q6>, __n128 a17@<Q7>)
{
  id v18[10];
  __n128 v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;
  __n128 v26;

  v26 = a17;
  v25 = a16;
  v24 = a15;
  v23 = a14;
  v22 = a13;
  v21 = a12;
  v20 = a11;
  v19 = a10;
  v18[8] = a9;
  v18[7] = a8;
  v18[6] = a7;
  v18[5] = a6;
  v18[4] = a5;
  v18[3] = a4;
  v18[2] = a3;
  v18[1] = a2;
  v18[0] = a1;
  return __block_forwarding___(v18);
}

uint64_t __block_forwarding___(id *a1)
{
  _QWORD *v2;
  objc_class *Class;
  const char *Name;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  uint64_t result;

  v2 = *a1;
  Class = object_getClass(*a1);
  Name = class_getName(Class);
  if (!strncmp(Name, "_NSZombie_", 0xAuLL))
    __block_forwarding____cold_1((__int16)v2, v5, v6, v7, v8, v9, v10, v11);
  v12 = _Block_signature(v2);
  if (!v12)
    __block_forwarding____cold_2((__int16)v2, v13, v14, v15, v16, v17, v18, v19);
  v20 = +[NSInvocation _invocationWithMethodSignature:frame:](NSBlockInvocation, "_invocationWithMethodSignature:frame:", +[NSMethodSignature signatureWithObjCTypes:](NSMethodSignature, "signatureWithObjCTypes:", v12), a1);
  objc_msgSend(v20, "setTarget:", 0);
  result = v2[4];
  if (result)
    return (*(uint64_t (**)(uint64_t, id))(result + 16))(result, v20);
  __break(1u);
  return result;
}

void sub_182B19E58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  _QWORD **v14;

  if (a2 == 1)
  {
    objc_begin_catch(exception_object);
    __NSMethodFrameArgInfoDestroy(*v14);
    __NSMethodFrameArgInfoDestroy(v14[1]);
    free(v14);
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_182B19ED8(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t __CFSearchSignatureROM(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2;
  __int16 v4;
  unint64_t v5;
  uint64_t v6;
  const char **v7;
  const char *v8;

  if (a2 <= 1024)
  {
    v4 = __CFStrHashEightBit2(a1, a2);
    v5 = MethodSignatureROMTableHashData[v4 & 0x3FFF];
    v2 = (v5 >> 3) - 1;
    v6 = v5 & 7;
    v7 = (const char **)(&MethodSignatureROMTable + 3 * (MethodSignatureROMTableHashData[v4 & 0x3FFF] >> 3) + 1);
    while (v6)
    {
      v8 = *v7;
      v7 += 3;
      ++v2;
      --v6;
      if (!strcmp((const char *)a1, v8))
        return v2;
    }
  }
  return -1;
}

uint64_t *parseFrameArgumentInfo(uint64_t *a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  uint64_t *v5;
  _BYTE *v6;
  _BYTE *v7;
  char *v8;
  uint64_t *v9;
  _BYTE *v10;
  char *v11;
  unint64_t v12;
  __int16 v13;
  char *v14;
  uint64_t v15;
  char v16;
  _BYTE *v17;
  _BYTE *v18;
  _BYTE *v19;
  int v20;
  _BYTE *v21;
  int v22;
  uint64_t v23;
  unsigned __int8 *v24;
  int v25;
  uint64_t v26;
  int v27;
  _BYTE *v28;
  char v29;
  uint64_t v30;
  unsigned __int8 *v31;
  char v32;
  uint64_t v33;
  int v34;
  _BYTE *v35;
  _BYTE *v36;
  int v37;
  _BYTE *v38;
  unsigned __int8 *v39;
  _BYTE *v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  uint64_t v48;
  unint64_t v49;
  _BYTE *v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char v61;
  unsigned __int8 *v62;
  int v63;
  unint64_t v64;
  unint64_t i;
  int v66;
  char *v67;
  _BYTE *v68;
  _BYTE *v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  char v84;
  unsigned __int8 *v85;
  int v86;
  _BYTE *v87;
  uint64_t v88;
  int v89;
  uint64_t v90;
  unsigned __int8 *v91;
  _BYTE *v92;
  int v93;
  uint64_t v94;
  int v95;
  unint64_t v96;
  char *v97;
  _BYTE *v98;
  unint64_t v99;
  _BYTE *v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  char *v117;
  unsigned __int8 *v118;
  BOOL v119;
  int v120;
  char *v121;
  _BYTE *v122;
  unsigned __int8 *v123;
  unsigned __int8 *v124;
  unsigned __int8 *v125;
  int v126;
  unsigned __int8 *v127;
  int v128;
  char *v129;
  char *v130;
  uint64_t *v131;
  _BYTE *v132;
  char v133;
  NSException *v134;
  NSException *v135;
  NSException *v137;
  NSException *v138;
  NSException *v139;
  const __CFString *v140;
  NSException *v141;
  NSException *v142;
  NSException *v143;
  NSException *v144;
  NSException *v145;
  uint64_t v146;
  uint64_t v147;
  const __CFString *v148;
  const __CFString *format;
  const __CFString *v150;
  unint64_t v151;
  __int16 v152;
  uint64_t *v153;
  unint64_t v154;
  _BYTE *v155;
  unint64_t v157;
  _BYTE *v159;
  _BYTE *v160;
  unsigned __int8 *v161;
  unint64_t v162;
  uint64_t v163;
  char *v164;
  unint64_t v165;
  uint64_t v166[3];

  v166[1] = *MEMORY[0x1E0C80C00];
  if (a4 >= 0x401)
  {
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: exceeded maximum nesting depth %d"), 1024);
    v142 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
    objc_exception_throw(v142);
  }
  v5 = a1;
  v163 = 0;
  v6 = __NSGetSizeAndAlignment((_BYTE *)*a1, &v163, 0, *a1, 0, 0, 1uLL);
  v7 = &v6[-*v5];
  v8 = (char *)malloc_type_calloc(1uLL, (size_t)(v7 + 42), 0xC8F86945uLL);
  v9 = (uint64_t *)v8;
  if (!v8)
  {
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: memory error - offset: %lu"), a2);
    v143 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
    objc_exception_throw(v143);
  }
  v10 = v8 + 37;
  *((_DWORD *)v8 + 4) = v163;
  *((_DWORD *)v8 + 5) = a2;
  v11 = (char *)*v5;
  v159 = v8 + 37;
  if (*v5 < (unint64_t)v6)
  {
    v153 = v5;
    v12 = (unint64_t)&v10[(_QWORD)v7 + 2];
    v151 = a4 + 1;
    if (a3)
      v13 = 2048;
    else
      v13 = 6144;
    v152 = v13;
    v154 = a4;
    v157 = a4 + 2;
    v148 = CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed extended block spec '%s'; exceeded maximum nesting depth %d");
    format = CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed extended block spec '%s'");
    v150 = CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed array spec '%s'");
    v155 = v6;
    while (2)
    {
      v14 = v11 + 1;
      v15 = *v11;
      v162 = (unint64_t)(v11 + 1);
      v16 = v15;
      switch((int)v15)
      {
        case '#':
          *((_WORD *)v9 + 17) |= 0x2000u;
          *((_BYTE *)v9 + 36) = v15;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case '*':
          *((_WORD *)v9 + 17) |= 0x4000u;
          *((_BYTE *)v9 + 36) = v15;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case '+':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          goto LABEL_75;
        case ':':
        case 'B':
        case 'v':
          *((_BYTE *)v9 + 36) = v15;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case '@':
          *((_WORD *)v9 + 17) |= 0x2000u;
          *((_BYTE *)v9 + 36) = v15;
          v35 = v159;
          if ((unint64_t)v159 >= v12)
            goto LABEL_241;
          *v159 = v15;
          v36 = ++v159;
          v37 = *v14;
          if (v37 == 34)
          {
            v91 = (unsigned __int8 *)(v11 + 2);
            v162 = (unint64_t)(v11 + 2);
            if ((unint64_t)v36 >= v12)
              goto LABEL_241;
            v92 = v35 + 2;
            v159 = v35 + 2;
            v35[1] = 34;
            if (v154 >= 0x400)
            {
              v148 = CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed extended object spec '%s'; exceeded maximum nesting depth %d");
              v38 = v11 + 1;
LABEL_268:
              CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v148, v38, 1024, v147);
            }
            else
            {
              v93 = *v91;
              if (*v91)
              {
                v94 = 0;
                v95 = *v91;
                v6 = v155;
                while (v95 != 34)
                {
                  v95 = v11[v94++ + 3];
                  if (!v95)
                    goto LABEL_255;
                }
                if (!v94)
                  goto LABEL_75;
                v96 = (unint64_t)&v11[v94 + 2];
                if (v93 == 60)
                {
                  v97 = 0;
                  goto LABEL_198;
                }
                v117 = v11 + 2;
                if ((unint64_t)(v94 + 2) >= 3)
                {
                  v118 = (unsigned __int8 *)(v11 + 3);
                  do
                  {
                    if ((unint64_t)v92 >= v12)
                      goto LABEL_241;
                    *v92++ = v93;
                    v119 = (unint64_t)v118 >= v96;
                    v120 = *v118++;
                    v93 = v120;
                  }
                  while (!v119 && v93 != 60);
                  v159 = v92;
                  v117 = (char *)(v118 - 1);
                }
                v121 = (char *)malloc_type_calloc(1uLL, v117 - (char *)v91 + 40, 0x21A5C7D9uLL);
                v97 = v121;
                if (v121)
                {
                  *((_WORD *)v121 + 17) |= 0x2000u;
                  strncpy(v121 + 37, v11 + 2, v117 - (char *)v91)[v117 - (char *)v91] = 0;
                  *v9 = (uint64_t)v97;
                  v91 = (unsigned __int8 *)v117;
LABEL_198:
                  if ((unsigned __int8 *)v96 == v91)
                  {
                    v91 = (unsigned __int8 *)&v11[v94 + 2];
                  }
                  else
                  {
                    if (v11 - (char *)v91 + v94 + 2 >= 3 && *v91 == 60)
                    {
                      v122 = v159;
                      while ((unint64_t)v122 < v12)
                      {
                        v123 = v91 + 1;
                        *v122 = 60;
                        v124 = v122 + 1;
                        v161 = v124;
                        v125 = v91 + 1;
                        if ((unint64_t)(v91 + 1) < v96)
                        {
                          v126 = *v123;
                          v125 = v91 + 1;
                          if (v126 != 62)
                          {
                            v127 = v91 + 2;
                            do
                            {
                              if ((unint64_t)v124 >= v12)
                                goto LABEL_241;
                              v161 = v124 + 1;
                              *v124 = v126;
                              v119 = (unint64_t)v127 >= v96;
                              v128 = *v127++;
                              v126 = v128;
                              if (v119)
                                break;
                              ++v124;
                            }
                            while (v126 != 62);
                            v125 = v127 - 1;
                          }
                        }
                        v129 = (char *)malloc_type_calloc(1uLL, v125 - v123 + 40, 0xF8BB8CC4uLL);
                        v130 = v129;
                        if (!v129)
                          goto LABEL_260;
                        *((_WORD *)v129 + 17) &= ~0x2000u;
                        strncpy(v129 + 37, (const char *)v91 + 1, v125 - v123)[v125 - v123] = 0;
                        v131 = (uint64_t *)(v97 + 8);
                        if (!v97)
                          v131 = v9;
                        *v131 = (uint64_t)v130;
                        if ((unint64_t)v161 >= v12)
                          break;
                        *v161 = *v125;
                        v122 = v161 + 1;
                        v159 = v161 + 1;
                        v91 = v125 + 1;
                        if (&v11[v94] - (char *)v125 + 1 >= 3)
                        {
                          v97 = v130;
                          if (v125[1] == 60)
                            continue;
                        }
                        goto LABEL_216;
                      }
LABEL_241:
                      v139 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0);
LABEL_242:
                      objc_exception_throw(v139);
                    }
LABEL_216:
                    if ((unint64_t)v91 > v96)
                    {
LABEL_222:
                      v116 = (uint64_t)&v11[v94 + 3];
                      goto LABEL_223;
                    }
                  }
                  v132 = v159;
                  while ((unint64_t)v132 < v12)
                  {
                    v133 = *v91++;
                    *v132++ = v133;
                    v159 = v132;
                    if ((unint64_t)v91 > v96)
                      goto LABEL_222;
                  }
                  goto LABEL_241;
                }
LABEL_260:
                CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: memory error - offset: %lu"), a2, v146, v147);
              }
              else
              {
LABEL_255:
                format = CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed extended object spec '%s'");
                v38 = v11 + 1;
LABEL_256:
                CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, format, v38, v146, v147);
              }
            }
            v139 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
            goto LABEL_242;
          }
          v6 = v155;
          if (v37 != 63)
            goto LABEL_75;
          *((_WORD *)v9 + 17) |= 0x8000u;
          v38 = v11 + 2;
          v162 = (unint64_t)(v11 + 2);
          if ((unint64_t)v36 >= v12)
            goto LABEL_241;
          v159 = v35 + 2;
          v35[1] = *v14;
          v6 = v155;
          if (*v38 != 60)
            goto LABEL_75;
          v39 = (unsigned __int8 *)(v11 + 3);
          v162 = (unint64_t)(v11 + 3);
          if ((unint64_t)(v35 + 2) >= v12)
            goto LABEL_241;
          v40 = v35 + 3;
          v35[2] = 60;
          if (v154 > 0x3FF)
            goto LABEL_268;
          v41 = *v39;
          if (!*v39)
            goto LABEL_256;
          v42 = 0;
          v43 = 0;
          while (1)
          {
            if (v41 != 62)
            {
              v44 = v41 == 60;
              goto LABEL_69;
            }
            if (!v43)
              break;
            v44 = -1;
LABEL_69:
            v43 += v44;
            v41 = v11[v42++ + 4];
            if (!v41)
              goto LABEL_256;
          }
          v100 = v40;
          if ((unint64_t)(v42 + 3) >= 4)
          {
            v101 = 0;
            v102 = 0;
            v100 = v40;
            do
            {
              v165 = 0;
              v166[0] = 0;
              __NSGetSizeAndAlignment(v39, v166, (uint64_t *)&v165, (uint64_t)v39, 1, 0, 1uLL);
              v103 = v165;
              if (!v165)
              {
                v165 = 1;
                v103 = 1;
              }
              v104 = (v103 + v102 - 1) / v103 * v103;
              v105 = parseFrameArgumentInfo(&v162, v104 + a2, 1, v157);
              v112 = v105;
              if (!v105)
              {
                CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'"), v162);
                v135 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
                objc_exception_throw(v135);
              }
              v113 = v166[0];
              if (v166[0] != *(_DWORD *)(v105 + 16))
              {
                v146 = v105 + 37;
                v147 = *(unsigned int *)(v105 + 16);
                CFLog(4, (uint64_t)CFSTR("*** warning: +[NSMethodSignature signatureWithObjCTypes:]: subInfo size (%lu) for '%s' not same as computed size (%d)"), v106, v107, v108, v109, v110, v111, v166[0]);
                v113 = *(unsigned int *)(v112 + 16);
              }
              LOBYTE(v114) = *(_BYTE *)(v112 + 37);
              if ((_BYTE)v114)
              {
                v115 = 0;
                do
                {
                  if ((unint64_t)&v100[v115] >= v12)
                    objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
                  v100[v115] = v114;
                  v114 = *(unsigned __int8 *)(v112 + v115++ + 38);
                }
                while (v114);
                v100 += v115;
              }
              if (!*v9)
                *v9 = v112;
              if (v101)
                *(_QWORD *)(v101 + 8) = v112;
              v102 = v113 + v104;
              v39 = (unsigned __int8 *)v162;
              v101 = v112;
            }
            while (v162 < (unint64_t)&v11[v42 + 3]);
          }
          if ((unint64_t)v100 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          v159 = v100 + 1;
          *v100 = 62;
          v116 = (uint64_t)&v11[v42 + 4];
LABEL_223:
          v162 = v116;
          v6 = v155;
LABEL_75:
          v11 = (char *)v162;
          if (v162 >= (unint64_t)v6)
          {
            v10 = v159;
            v5 = v153;
            break;
          }
          continue;
        case 'C':
        case 'I':
        case 'L':
        case 'Q':
        case 'S':
        case 'T':
          *((_BYTE *)v9 + 36) = v15;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case 'D':
        case 'd':
        case 'f':
          *((_WORD *)v9 + 17) |= 0x200u;
          *((_BYTE *)v9 + 36) = v15;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case 'N':
          *((_WORD *)v9 + 17) |= 3u;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case 'O':
          *((_WORD *)v9 + 17) |= 4u;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case 'R':
          *((_WORD *)v9 + 17) |= 8u;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case 'V':
          *((_WORD *)v9 + 17) |= 0x20u;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case '[':
          *((_BYTE *)v9 + 36) = v15;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          *v159 = v15;
          v21 = v159 + 1;
          *((_WORD *)v9 + 17) |= v152;
          if (v154 >= 0x400)
          {
            CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed array spec '%s'; exceeded maximum nesting depth %d"),
              v11,
              1024);
          }
          else
          {
            v22 = *v14;
            if (*v14)
            {
              v23 = 0;
              v24 = (unsigned __int8 *)(v11 + 2);
              v25 = *v14;
              while (1)
              {
                if (v25 != 93)
                {
                  v26 = v25 == 91;
                  goto LABEL_30;
                }
                if (!v23)
                  break;
                v26 = -1;
LABEL_30:
                v23 += v26;
                v27 = *v24++;
                v25 = v27;
                if (!v27)
                  goto LABEL_252;
              }
              if ((v22 - 48) > 9)
              {
                v162 = (unint64_t)(v11 + 1);
                goto LABEL_262;
              }
              v45 = 0;
              v46 = 0;
              do
              {
                if (v46 >= 0x19999999)
                {
                  v162 = (unint64_t)&v11[v45 + 1];
                  v140 = CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: array too large in spec '%s'");
                  goto LABEL_251;
                }
                if ((unint64_t)&v21[v45] >= v12)
                {
                  v162 = (unint64_t)&v11[v45 + 1];
                  goto LABEL_234;
                }
                v46 = (v22 - 48) + 10 * v46;
                v21[v45] = v22;
                v22 = v11[v45++ + 2];
              }
              while ((v22 - 48) < 0xA);
              v47 = &v11[v45 + 1];
              v162 = (unint64_t)v47;
              v160 = &v21[v45];
              if (v46 - 65537 >= 0xFFFFFFFFFFFF0000)
              {
                v165 = 0;
                v166[0] = 0;
                __NSGetSizeAndAlignment(v47, v166, (uint64_t *)&v165, (uint64_t)v47, 1, 0, 1uLL);
                if (!v165)
                  v165 = 1;
                v48 = 0;
                v49 = 0;
                v50 = v160;
                while (1)
                {
                  v51 = (v165 + v49 - 1) / v165 * v165;
                  v164 = v47;
                  v52 = parseFrameArgumentInfo(&v164, v51 + a2, a3, v157);
                  v59 = v52;
                  if (!v52)
                  {
                    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'"), v11);
                    v141 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
                    objc_exception_throw(v141);
                  }
                  v60 = v166[0];
                  if (v166[0] != *(_DWORD *)(v52 + 16))
                  {
                    v146 = v52 + 37;
                    v147 = *(unsigned int *)(v52 + 16);
                    CFLog(4, (uint64_t)CFSTR("*** warning: +[NSMethodSignature signatureWithObjCTypes:]: subInfo size (%lu) for '%s' not same as computed size (%d)"), v53, v54, v55, v56, v57, v58, v166[0]);
                    v60 = *(unsigned int *)(v59 + 16);
                  }
                  if (!*v9)
                    break;
                  if (v48)
                    goto LABEL_91;
LABEL_92:
                  v49 = v60 + v51;
                  v48 = v59;
                  if (!--v46)
                  {
                    if ((unint64_t)v50 >= v12)
                      goto LABEL_234;
                    v159 = v50 + 1;
                    *v50 = 93;
                    v162 = (unint64_t)v24;
                    v66 = (v165 + v49 - 1) / v165 * v165;
LABEL_167:
                    *((_DWORD *)v9 + 4) = v66;
                    v6 = v155;
                    if (v66)
                      goto LABEL_75;
LABEL_168:
                    if (*v9)
                    {
                      __NSMethodFrameArgInfoDestroy((_QWORD *)*v9);
                      *v9 = 0;
                    }
                    goto LABEL_75;
                  }
                }
                v61 = *(_BYTE *)(v59 + 37);
                if (v61)
                {
                  v62 = (unsigned __int8 *)(v59 + 38);
                  while ((unint64_t)v50 < v12)
                  {
                    *v50++ = v61;
                    v63 = *v62++;
                    v61 = v63;
                    if (!v63)
                      goto LABEL_98;
                  }
LABEL_234:
                  v137 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0);
LABEL_235:
                  objc_exception_throw(v137);
                }
LABEL_98:
                *v9 = v59;
                if (!v48)
                  goto LABEL_92;
LABEL_91:
                *(_QWORD *)(v48 + 8) = v59;
                goto LABEL_92;
              }
LABEL_262:
              v140 = CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: array too small or too large in spec '%s'");
LABEL_251:
              v150 = v140;
            }
LABEL_252:
            CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v150, v11, v146, v147);
          }
          v137 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
          goto LABEL_235;
        case '^':
          *((_BYTE *)v9 + 36) = v15;
          v18 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          *v159 = v16;
          v19 = v159 + 1;
          v20 = *v14;
          if (v20 == 118 || v20 == 63)
          {
            v162 = (unint64_t)(v11 + 2);
            if ((unint64_t)v19 >= v12)
              objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
            v159 += 2;
            v18[1] = v20;
          }
          else
          {
            v88 = parseFrameArgumentInfo(&v162, 0, a3, v151);
            if (!v88)
            {
              CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'"), *v153);
              v145 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
              objc_exception_throw(v145);
            }
            LOBYTE(v89) = *(_BYTE *)(v88 + 37);
            if ((_BYTE)v89)
            {
              v90 = 0;
              do
              {
                if ((unint64_t)&v19[v90] >= v12)
                  objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
                v19[v90] = v89;
                v89 = *(unsigned __int8 *)(v88 + v90++ + 38);
              }
              while (v89);
              v19 += v90;
            }
            v159 = v19;
            if (*(_DWORD *)(v88 + 16))
            {
              *v9 = v88;
              *((_WORD *)v9 + 17) |= 0x1000u;
            }
            else
            {
              __NSMethodFrameArgInfoDestroy((_QWORD *)v88);
            }
          }
          goto LABEL_75;
        case 'c':
        case 'i':
        case 'l':
        case 'q':
        case 's':
        case 't':
          *((_WORD *)v9 + 17) |= 0x100u;
          *((_BYTE *)v9 + 36) = v15;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case 'n':
          *((_WORD *)v9 + 17) |= 1u;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case 'o':
          *((_WORD *)v9 + 17) |= 2u;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          goto LABEL_74;
        case 'r':
          *((_WORD *)v9 + 17) |= 0x10u;
          v17 = v159;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
LABEL_74:
          *v17 = v15;
          v159 = v17 + 1;
          goto LABEL_75;
        case '{':
          *((_BYTE *)v9 + 36) = v15;
          if ((unint64_t)v159 >= v12)
            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
          *v159 = v15;
          v28 = v159 + 1;
          *((_WORD *)v9 + 17) |= 0x400u;
          if (v154 >= 0x400)
          {
            CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec '%s'; exceeded maximum nesting depth %d"),
              v11,
              1024);
          }
          else
          {
            v29 = *v14;
            if (*v14)
            {
              v30 = 0;
              v31 = (unsigned __int8 *)(v11 + 2);
              v32 = *v14;
              do
              {
                if (v32 == 125)
                {
                  if (!v30)
                  {
                    v64 = (unint64_t)(v31 - 1);
                    for (i = 1; ; v29 = v11[i])
                    {
                      if (v29 > 60)
                      {
                        if (v29 == 61)
                        {
                          v67 = &v11[i];
                          if (i >= 2)
                          {
                            v98 = v11 + 1;
                            while (1)
                            {
                              v14 = v98 + 1;
                              if ((unint64_t)v28 >= v12)
                                break;
                              *v28++ = *v98++;
                              if (v14 >= v67)
                                goto LABEL_113;
                            }
                            v162 = (unint64_t)(v98 + 1);
LABEL_239:
                            v138 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0);
LABEL_240:
                            objc_exception_throw(v138);
                          }
LABEL_113:
                          v162 = (unint64_t)v14;
                          if (*v67 != 61)
                          {
                            if ((unint64_t)v28 < v12)
                            {
                              *v28 = 125;
                              v159 = v28 + 1;
                              v162 = (unint64_t)v31;
                              v87 = malloc_type_calloc(1uLL, 0x29uLL, 0xDD01A950uLL);
                              v87[37] = 0;
                              *((_DWORD *)v87 + 5) = a2;
                              *v9 = (uint64_t)v87;
                              if (*((_DWORD *)v9 + 4))
                                goto LABEL_75;
                              goto LABEL_168;
                            }
                            goto LABEL_239;
                          }
                          if ((unint64_t)v28 >= v12)
                            objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
                          *v28 = 61;
                          v68 = v28 + 1;
                          v69 = v67 + 1;
                          v162 = (unint64_t)(v67 + 1);
                          if ((unint64_t)(v67 + 1) >= v64)
                          {
                            v72 = 0;
                            v71 = 0;
LABEL_162:
                            if ((unint64_t)v68 >= v12)
                              objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
                            v159 = v68 + 1;
                            *v68 = 125;
                            v162 = (unint64_t)v31;
                            if (v72 <= 1)
                              v99 = 1;
                            else
                              v99 = v72;
                            v66 = (v71 + v99 - 1) / v99 * v99;
                            goto LABEL_167;
                          }
                          v70 = 0;
                          v71 = 0;
                          v72 = 0;
                          while (2)
                          {
                            v165 = 0;
                            v166[0] = 0;
                            __NSGetSizeAndAlignment(v69, v166, (uint64_t *)&v165, (uint64_t)v69, 1, 0, 1uLL);
                            v73 = v165;
                            if (v72 <= v165)
                              v72 = v165;
                            if (!v165)
                            {
                              v165 = 1;
                              v73 = 1;
                            }
                            v74 = (v73 + v71 - 1) / v73 * v73;
                            v75 = parseFrameArgumentInfo(&v162, v74 + a2, 1, v157);
                            v82 = v75;
                            if (!v75)
                            {
                              CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%s'"), v162);
                              v134 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
                              objc_exception_throw(v134);
                            }
                            v83 = v166[0];
                            if (v166[0] != *(_DWORD *)(v75 + 16))
                            {
                              v146 = v75 + 37;
                              v147 = *(unsigned int *)(v75 + 16);
                              CFLog(4, (uint64_t)CFSTR("*** warning: +[NSMethodSignature signatureWithObjCTypes:]: subInfo size (%lu) for '%s' not same as computed size (%d)"), v76, v77, v78, v79, v80, v81, v166[0]);
                              v83 = *(unsigned int *)(v82 + 16);
                            }
                            v84 = *(_BYTE *)(v82 + 37);
                            if (v84)
                            {
                              v85 = (unsigned __int8 *)(v82 + 38);
                              do
                              {
                                if ((unint64_t)v68 >= v12)
                                  objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
                                *v68++ = v84;
                                v86 = *v85++;
                                v84 = v86;
                              }
                              while (v86);
                            }
                            if (*v9)
                            {
                              if (v70)
                                goto LABEL_130;
                            }
                            else
                            {
                              *v9 = v82;
                              if (v70)
LABEL_130:
                                *(_QWORD *)(v70 + 8) = v82;
                            }
                            v71 = v83 + v74;
                            v69 = (_BYTE *)v162;
                            v70 = v82;
                            if (v162 >= v64)
                              goto LABEL_162;
                            continue;
                          }
                        }
                        if (v29 == 125)
                          goto LABEL_112;
                      }
                      else if (!v29 || v29 == 41)
                      {
LABEL_112:
                        v67 = v11 + 1;
                        goto LABEL_113;
                      }
                      if (v29)
                        ++i;
                    }
                  }
                  v33 = -1;
                }
                else
                {
                  v33 = v32 == 123;
                }
                v30 += v33;
                v34 = *v31++;
                v32 = v34;
              }
              while (v34);
            }
            CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec '%s'"), v11, v146, v147);
          }
          v138 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
          goto LABEL_240;
        default:
          __NSMethodFrameArgInfoDestroy(v9);
          CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: unsupported type encoding spec '%c' in '%s'"), v15, *v153);
          v144 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
          objc_exception_throw(v144);
      }
      break;
    }
  }
  *v10 = 0;
  *v5 = (uint64_t)v6;
  if (!*((_BYTE *)v9 + 36))
  {
    __NSMethodFrameArgInfoDestroy(v9);
    return 0;
  }
  return v9;
}

void sub_182B1B724(_Unwind_Exception *a1, int a2)
{
  _QWORD *v2;

  objc_end_catch();
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    __NSMethodFrameArgInfoDestroy(v2);
    objc_exception_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_182B1B848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182B1B870(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182B1B87C(_Unwind_Exception *a1, int a2)
{
  if (a2)
    objc_terminate();
  sub_182B1B848(a1);
}

void sub_182B1B884()
{
  JUMPOUT(0x182B1B88CLL);
}

void sub_182B1B8AC()
{
  objc_end_catch();
  JUMPOUT(0x182B1B8B4);
}

_BYTE *__NSGetSizeAndAlignment(_BYTE *result, uint64_t *a2, uint64_t *a3, uint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7)
{
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  const char *v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unsigned __int8 v28;
  _BYTE *v29;
  uint64_t v30;
  int v31;
  char v32;
  _BYTE *v33;
  unint64_t v34;
  uint64_t v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  _BYTE *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  NSException *v57;
  NSException *v58;
  NSException *v59;
  NSException *v60;
  NSException *v61;
  NSException *v62;
  uint64_t v64;
  _QWORD v65[2];

  v9 = result;
  v65[1] = *MEMORY[0x1E0C80C00];
  if (a3)
    *a3 = 0;
  if (a2)
    *a2 = 0;
  while (2)
  {
    v10 = result;
    v12 = (char)*result++;
    v11 = v12;
    switch(v12)
    {
      case '"':
        result = v10 + 2;
LABEL_7:
        if (*(result - 1) == 34)
          continue;
        if (*(result - 1))
        {
          ++result;
          goto LABEL_7;
        }
        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): unterminated ivar name spec at '%s' in '%s'"), v9, a4);
        goto LABEL_159;
      case '#':
      case '*':
      case ':':
      case 'D':
      case 'Q':
      case 'd':
      case 'q':
        goto LABEL_41;
      case '$':
      case '%':
      case '&':
      case '\'':
      case ')':
      case ',':
      case '-':
      case '.':
      case '/':
      case ';':
      case '<':
      case '=':
      case '>':
      case '?':
      case 'A':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'J':
      case 'K':
      case 'M':
      case 'P':
      case 'U':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '\\':
      case ']':
      case '_':
      case 'a':
      case 'b':
      case 'e':
      case 'g':
      case 'h':
      case 'j':
      case 'k':
      case 'm':
      case 'p':
      case 'u':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
        goto LABEL_160;
      case '(':
        v20 = "union";
        v21 = 41;
        goto LABEL_66;
      case '+':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'N':
      case 'O':
      case 'R':
      case 'V':
      case 'n':
      case 'o':
      case 'r':
        continue;
      case '@':
        if (a3)
          *a3 = 8;
        if (a2)
          *a2 = 8;
        v22 = *result;
        if (v22 == 34)
        {
          v43 = v10[2];
          if (v10[2])
          {
            result = v10 + 3;
            while (v43 != 34)
            {
              v44 = *result++;
              v43 = v44;
              if (!v44)
                goto LABEL_128;
            }
            goto LABEL_46;
          }
LABEL_128:
          CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): malformed extended class info spec at '%s' in '%s'"), v9, a4);
        }
        else
        {
          if (v22 != 63)
            goto LABEL_46;
          result = v10 + 2;
          if (v10[2] != 60)
            goto LABEL_46;
          v23 = v10[3];
          if (v10[3])
          {
            v24 = 0;
            result = v10 + 4;
            do
            {
              if (v23 == 62)
              {
                if (!v24)
                  goto LABEL_46;
                v25 = -1;
              }
              else
              {
                v25 = v23 == 60;
              }
              v24 += v25;
              v26 = *result++;
              v23 = v26;
            }
            while (v26);
          }
          CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): malformed extended block spec at '%s' in '%s'"), v9, a4);
        }
        goto LABEL_159;
      case 'B':
      case 'C':
      case 'c':
        if (a3)
          *a3 = 1;
        if (!a2)
          goto LABEL_46;
        v13 = 1;
        goto LABEL_45;
      case 'I':
      case 'L':
      case 'f':
      case 'i':
      case 'l':
        if (a3)
          *a3 = 4;
        if (!a2)
          goto LABEL_46;
        v13 = 4;
        goto LABEL_45;
      case 'S':
      case 's':
        if (a3)
          *a3 = 2;
        if (!a2)
          goto LABEL_46;
        v13 = 2;
        goto LABEL_45;
      case 'T':
      case 't':
        if (a3)
          *a3 = 16;
        if (!a2)
          goto LABEL_46;
        v13 = 16;
        goto LABEL_45;
      case '[':
        if (a6 >= 0x200)
          goto LABEL_162;
        v14 = *result;
        if (!*result)
          goto LABEL_36;
        v15 = 0;
        v16 = 0;
        v17 = *result;
        while (1)
        {
          if (v17 == 93)
          {
            if (!v16)
            {
              if ((v14 - 48) > 9)
              {
                if (v15)
                {
                  v34 = 0;
                  goto LABEL_111;
                }
                goto LABEL_36;
              }
              v34 = 0;
              v35 = v15;
              while (v34 < 0x19999999)
              {
                v34 = (v14 - 48) + 10 * v34;
                v36 = *++result;
                v14 = v36;
                --v35;
                if ((v36 - 48) >= 0xA)
                {
                  if (v35)
                  {
                    if (v34 && !is_mul_ok(v34, a7))
                    {
                      CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): cumulative nesting of arrays has reached ridiculous proportions at '%s' in '%s'"), v9, a4);
                      goto LABEL_159;
                    }
LABEL_111:
                    v37 = (unint64_t)&v10[v15 + 1];
                    v38 = v34 * a7;
                    v64 = 0;
                    v65[0] = 0;
                    v39 = (_BYTE *)__NSGetSizeAndAlignment(result, v65, &v64, a4, a5, a6 + 1, v34 * a7);
                    v40 = v65[0];
                    if (!v65[0])
                    {
                      CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): malformed array spec or array too large at '%s' in '%s'"), v9, a4);
                      v59 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
                      objc_exception_throw(v59);
                    }
                    if (!v39 || (unint64_t)v39 > v37 || *v39 != 93)
                    {
                      CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): malformed array spec at '%s' in '%s'"), v9, a4);
                      v58 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
                      objc_exception_throw(v58);
                    }
                    v41 = v64;
                    if (a3)
                      *a3 = v64;
                    result = v39 + 1;
                    if (!v41)
                    {
                      v41 = 1;
                      v64 = 1;
                    }
                    if (a2)
                    {
                      if (__CFADD__(v41, v40))
                      {
                        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): array too large at '%s' in '%s'"), v9, a4);
                        v60 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
                        objc_exception_throw(v60);
                      }
                      v42 = (v41 + v40 - 1) / v41 * v41;
                      if (v34 > 0xFFFFFFFFFFFFFFFFLL / v42)
                      {
                        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): array too large at '%s' in '%s'"), v9, a4);
                        v61 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
                        objc_exception_throw(v61);
                      }
                      if (v38 > 0xFFFFFFFFFFFFFFFFLL / v42)
                      {
                        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): cumulative nested array has reached ridiculous size at '%s' in '%s'"), v9, a4);
                        v62 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
                        objc_exception_throw(v62);
                      }
                      v13 = v42 * v34;
LABEL_45:
                      *a2 = v13;
                    }
                    goto LABEL_46;
                  }
LABEL_36:
                  CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): malformed array spec at '%s' in '%s'"), v9, a4);
                  goto LABEL_159;
                }
              }
              CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): malformed array spec at '%s' in '%s' -- size is too large"), v9, a4);
LABEL_159:
              v57 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
              objc_exception_throw(v57);
            }
            v18 = -1;
          }
          else
          {
            v18 = v17 == 91;
          }
          v16 += v18;
          v17 = v10[v15++ + 2];
          if (!v17)
            goto LABEL_36;
        }
      case '^':
        if (a6 >= 0x200)
          goto LABEL_162;
        v19 = *result;
        if (v19 == 118 || v19 == 63)
        {
          result = v10 + 2;
LABEL_41:
          if (a3)
            *a3 = 8;
          if (a2)
          {
            v13 = 8;
            goto LABEL_45;
          }
LABEL_46:
          if (*result == 43)
            ++result;
          return result;
        }
        switch((char)v19)
        {
          case '(':
            v53 = v10[2];
            if (v10[2])
            {
              v54 = 0;
              result = v10 + 3;
              do
              {
                if (v53 == 41)
                {
                  if (!v54)
                    goto LABEL_41;
                  v55 = -1;
                }
                else
                {
                  v55 = v53 == 40;
                }
                v54 += v55;
                v56 = *result++;
                v53 = v56;
              }
              while (v56);
            }
            break;
          case '[':
            v49 = v10[2];
            if (v10[2])
            {
              v50 = 0;
              result = v10 + 3;
              do
              {
                if (v49 == 93)
                {
                  if (!v50)
                    goto LABEL_41;
                  v51 = -1;
                }
                else
                {
                  v51 = v49 == 91;
                }
                v50 += v51;
                v52 = *result++;
                v49 = v52;
              }
              while (v52);
            }
            break;
          case '{':
            v45 = v10[2];
            if (v10[2])
            {
              v46 = 0;
              result = v10 + 3;
              do
              {
                if (v45 == 125)
                {
                  if (!v46)
                    goto LABEL_41;
                  v47 = -1;
                }
                else
                {
                  v47 = v45 == 123;
                }
                v46 += v47;
                v48 = *result++;
                v45 = v48;
              }
              while (v48);
            }
            break;
          default:
            result = (_BYTE *)((uint64_t (*)(void))__NSGetSizeAndAlignment)();
            if (result)
              goto LABEL_41;
            break;
        }
        CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): malformed pointed-to-type spec at '%s' in '%s'"), v9, a4);
        goto LABEL_159;
      case 'v':
        goto LABEL_46;
      case '{':
        v20 = "struct";
        v21 = 125;
LABEL_66:
        if (a6 >= 0x200)
        {
LABEL_162:
          CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): type encoding string '%s' contains too many nesting levels"), a4);
          goto LABEL_159;
        }
        if (!*result)
          goto LABEL_74;
        v27 = 0;
        v28 = *result;
        v29 = result;
        while (2)
        {
          if (v21 != (char)v28)
          {
            v30 = v28 == v11;
LABEL_73:
            v27 += v30;
            v31 = *++v29;
            v28 = v31;
            if (!v31)
            {
LABEL_74:
              CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): malformed %s spec at '%s' in '%s'"), v20, v9, a4);
              goto LABEL_159;
            }
            continue;
          }
          break;
        }
        if (v27)
        {
          v30 = -1;
          goto LABEL_73;
        }
        v32 = *result;
        v33 = result;
        break;
      default:
        if ((_DWORD)v11)
        {
LABEL_160:
          CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("NSGetSizeAndAlignment(): unsupported type encoding spec '%c' at '%s' in '%s'"), v11, v9, a4);
          goto LABEL_159;
        }
        return v10;
    }
    break;
  }
  while (v32 <= 60)
  {
    if (!v32 || v32 == 41)
      goto LABEL_85;
LABEL_82:
    if (v32)
      ++v33;
    v32 = *v33;
  }
  if (v32 == 61)
    goto LABEL_86;
  if (v32 != 125)
    goto LABEL_82;
LABEL_85:
  v32 = *result;
  v33 = result;
LABEL_86:
  if (v32 == 61)
    result = v33 + 1;
  else
    result = v33;
  for (; result < v29; result = (_BYTE *)((uint64_t (*)(void))__NSGetSizeAndAlignment)())
    ;
  if (result && *result)
    ++result;
  if (a3)
    *a3 = 0;
  if (a2)
    *a2 = 0;
  if (result < v29)
    goto LABEL_46;
  return result;
}

void sub_182B1C310(_Unwind_Exception *exc_buf, int a2)
{
  int v2;

  if (a2 == 1)
  {
    objc_begin_catch(exc_buf);
    if (!v2)
    {
      objc_end_catch();
      JUMPOUT(0x182B1BD60);
    }
    objc_exception_rethrow();
  }
  _Unwind_Resume(exc_buf);
}

void sub_182B1C348(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

unint64_t computeReturnFrameExtent(uint64_t *a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v32[2];

  v2 = a2;
  v32[1] = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v6 = a2 + 2;
  v5 = a2[2];
  if (!v5)
  {
    *(_OWORD *)a2 = xmmword_182DC6F60;
    v5 = 224;
    a2[2] = 224;
  }
  v7 = *(unsigned __int8 *)(v4 + 36);
  v8 = (v7 - 35);
  if (v8 <= 0x3B)
  {
    if (((1 << (v7 - 35)) & 0x8034241A0800081) != 0)
    {
LABEL_8:
      v10 = *a2;
      v11 = *(unsigned int *)(v4 + 16);
      if ((unint64_t)(*a2 + v11) > 0x40)
      {
        *a2 = 72;
        v32[0] = 0;
        __NSGetSizeAndAlignment((_BYTE *)(v4 + 37), 0, v32, 0, 1, 0, 1uLL);
        v13 = v32[0];
        if (v32[0] <= 1uLL)
          v13 = 1;
        v10 = (v5 + v13 - 225) / v13 * v13 + 224;
        v12 = *(_DWORD *)(v4 + 16);
        v2 = v6;
        LOBYTE(v11) = v12;
      }
      else
      {
        v12 = ((v11 - 1) & 0xFFFFFFF8) + 8;
      }
      *v2 = v10 + v12;
LABEL_14:
      *(_DWORD *)(v4 + 24) = v12;
      *(_DWORD *)(v4 + 28) = v10;
      *(_BYTE *)(v4 + 33) = v11 - v12;
      return (*v6 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (v8 == 33)
    {
LABEL_17:
      v10 = a2[1];
      if (v10 > 0xC0)
      {
        *a2 = 72;
        v32[0] = 0;
        __NSGetSizeAndAlignment((_BYTE *)(v4 + 37), 0, v32, 0, 1, 0, 1uLL);
        v17 = v32[0];
        if (v32[0] <= 1uLL)
          v17 = 1;
        v10 = (v5 + v17 - 225) / v17 * v17 + 224;
        v11 = *(unsigned int *)(v4 + 16);
        v2[2] = v10 + v11;
        v12 = v11;
      }
      else
      {
        a2[1] = v10 + 16;
        LODWORD(v11) = *(_DWORD *)(v4 + 16);
        v12 = 16;
      }
      goto LABEL_14;
    }
  }
  v9 = v7 - 99;
  if (v9 <= 0x18)
  {
    if (((1 << v9) & 0x34241) != 0)
      goto LABEL_8;
    if (((1 << v9) & 0xA) != 0)
      goto LABEL_17;
    if (v9 == 24)
    {
      v32[0] = 0;
      v31 = 0;
      if (__NSMFAIsHFA_arm64(v4, &v31, (unint64_t *)v32))
      {
        v15 = v2[1];
        if (v15 + (unint64_t)*(unsigned int *)(v4 + 16) > 0xC0)
        {
          *(_OWORD *)v2 = xmmword_182DC6F90;
          v24 = _NSMS3StackAlignedOffset_arm64(v4, v5 - 224);
          v25 = *(unsigned int *)(v4 + 16);
          *(_DWORD *)(v4 + 24) = v25;
          *(_DWORD *)(v4 + 28) = v24 + 224;
          v2[2] = v24 + 224 + v25;
          __NSMFASetOffsetsForCompositeElements_arm64(*(_QWORD *)v4, (v24 + 224));
        }
        else
        {
          v16 = v32[0];
          *(_DWORD *)(v4 + 24) = 16 * LODWORD(v32[0]);
          *(_DWORD *)(v4 + 28) = v15;
          v2[1] = v15 + 16 * v16;
          v30 = 0;
          __NSMFASetRegisterOffsetsForHFA_arm64(*(_QWORD *)v4, v15, &v30);
        }
        *(_BYTE *)(v4 + 33) = 0;
      }
      else
      {
        v18 = *(unsigned int *)(v4 + 16);
        if (v18 < 0x11)
        {
          v26 = 8 * (((v18 - 1) >> 3) + 1);
          v27 = *v2;
          if ((unint64_t)(*v2 + v18) > 0x40)
          {
            v29 = _NSMS3StackAlignedOffset_arm64(v4, v5 - 224);
            LODWORD(v27) = v29 + 224;
            *v6 = v29 + 224 + v26;
            v28 = 72;
          }
          else
          {
            v28 = v27 + v26;
          }
          *(_DWORD *)(v4 + 28) = v27;
          *v2 = v28;
          *(_DWORD *)(v4 + 24) = v26;
          *(_BYTE *)(v4 + 33) = *(_BYTE *)(v4 + 16) - v26;
          v22 = *(_QWORD *)v4;
          v23 = *(unsigned int *)(v4 + 28);
        }
        else
        {
          v19 = strlen((const char *)(v4 + 37));
          v20 = malloc_type_calloc(1uLL, v19 + 42, 0x700DC4B9uLL);
          *v20 = v4;
          v20[2] = 8;
          *((_DWORD *)v20 + 6) = 8;
          *((_WORD *)v20 + 17) |= 0x1082u;
          *((_WORD *)v20 + 18) = 24158;
          v21 = strlen((const char *)(v4 + 37));
          memmove((char *)v20 + 38, (const void *)(v4 + 37), v21 + 1);
          *a1 = (uint64_t)v20;
          computeReturnFrameExtent(a1, v2);
          v22 = *(_QWORD *)v4;
          v23 = 0;
        }
        __NSMFASetOffsetsForCompositeElements_arm64(v22, v23);
      }
    }
  }
  return (*v6 + 7) & 0xFFFFFFFFFFFFFFF8;
}

void __NSMethodFrameArgInfoDestroy(_QWORD *a1)
{
  if (a1)
  {
    __NSMethodFrameArgInfoDestroy(*a1);
    __NSMethodFrameArgInfoDestroy(a1[1]);
    free(a1);
  }
}

uint64_t __NSMFAIsHFA_arm64(uint64_t a1, _BYTE *a2, unint64_t *a3)
{
  uint64_t v5;
  uint64_t result;
  int v7;
  char v8;
  unint64_t v9;

  if (!a1)
    return 1;
  v5 = a1;
  while (1)
  {
    result = 0;
    v7 = *(unsigned __int8 *)(v5 + 36);
    v8 = v7 - 68;
    if ((v7 - 68) > 0x37)
      break;
    if (((1 << v8) & 0x500000001) != 0)
    {
      v9 = *a3 + 1;
      *a3 = v9;
      if (v9 > 4)
        return 0;
      if (*a2)
      {
        if ((char)*a2 != v7)
          return 0;
      }
      else
      {
        *a2 = v7;
      }
    }
    else
    {
      if (((1 << v8) & 0x80000000800000) == 0)
        return result;
      if ((__NSMFAIsHFA_arm64(*(_QWORD *)v5, a2, a3) & 1) == 0)
        return 0;
    }
    v5 = *(_QWORD *)(v5 + 8);
    if (!v5)
      return 1;
  }
  return result;
}

uint64_t __NSMFASetOffsetsForCompositeElements_arm64(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  int v4;

  if (result)
  {
    v3 = result;
    do
    {
      v4 = *(_DWORD *)(v3 + 20) + a2;
      *(_DWORD *)(v3 + 24) = *(_DWORD *)(v3 + 16);
      *(_DWORD *)(v3 + 28) = v4;
      if ((*(_BYTE *)(v3 + 35) & 0xC) != 0)
        result = __NSMFASetOffsetsForCompositeElements_arm64(*(_QWORD *)v3, a2);
      v3 = *(_QWORD *)(v3 + 8);
    }
    while (v3);
  }
  return result;
}

uint64_t __NSMFASetRegisterOffsetsForHFA_arm64(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5;
  uint64_t v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;
  char v10;

  if (!a1)
    return 0;
  v5 = a1;
  v6 = 0;
  do
  {
    v7 = *(_WORD *)(v5 + 34);
    v8 = *a3;
    *(_DWORD *)(v5 + 28) = a2 + 16 * *a3;
    if ((v7 & 0xC00) != 0)
    {
      v9 = __NSMFASetRegisterOffsetsForHFA_arm64(*(_QWORD *)v5, a2, a3);
      v10 = 0;
    }
    else
    {
      v10 = *(_BYTE *)(v5 + 16) - 16;
      *a3 = v8 + 1;
      v9 = 16;
    }
    *(_DWORD *)(v5 + 24) = v9;
    *(_BYTE *)(v5 + 33) = v10;
    v6 += v9;
    v5 = *(_QWORD *)(v5 + 8);
  }
  while (v5);
  return v6;
}

UText *__CFStringClone(UText *a1, uint64_t a2, int a3, UErrorCode *status)
{
  UText *v4;
  UText *v8;
  int64_t v9;
  const UTextFuncs *v10;
  int v11;
  const __CFAttributedString *v12;
  void *MutableCopy;

  if (*(int *)status > 0)
    return 0;
  v8 = utext_setup(a1, 0, status);
  v4 = v8;
  if (*(int *)status <= 0)
  {
    v8->providerProperties = *(_DWORD *)(a2 + 8);
    v8->chunkNativeStart = *(_QWORD *)(a2 + 32);
    v9 = *(_QWORD *)(a2 + 32);
    v8->chunkNativeLimit = v9;
    v8->nativeIndexingLimit = v9;
    v8->chunkOffset = 0;
    v10 = (const UTextFuncs *)&__CFAttributedStringFuncs;
    v11 = *(_DWORD *)(a2 + 8);
    if ((v11 & 0x10) == 0)
      v10 = (const UTextFuncs *)&__CFStringFuncs;
    v8->pFuncs = v10;
    if (*(int *)status <= 0)
    {
      if (a3)
      {
        v12 = *(const __CFAttributedString **)(a2 + 72);
        if ((v11 & 0x10) != 0)
          MutableCopy = CFAttributedStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v12);
        else
          MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, (CFStringRef)v12);
        v4->context = MutableCopy;
        v4->providerProperties |= 0x28u;
      }
      else
      {
        v8->context = *(const void **)(a2 + 72);
      }
    }
  }
  return v4;
}

Boolean CFSetGetValueIfPresent(CFSetRef theSet, const void *candidate, const void **value)
{
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)theSet))
    return -[__CFSet __getValue:forObj:](theSet, "__getValue:forObj:", value, candidate);
  v7 = 0u;
  v8 = 0u;
  CFBasicHashFindBucket((uint64_t)theSet, (unint64_t)candidate, (uint64_t *)&v7);
  if (!*((_QWORD *)&v8 + 1))
    return 0;
  if (value)
    *value = (const void *)v8;
  return 1;
}

const void *__cdecl CFBagGetValue(CFBagRef theBag, const void *value)
{
  __int128 v3;
  __int128 v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v3 = 0u;
  v4 = 0u;
  CFBasicHashFindBucket((uint64_t)theBag, (unint64_t)value, (uint64_t *)&v3);
  if (*((_QWORD *)&v4 + 1))
    return (const void *)v4;
  else
    return 0;
}

uint64_t _CFSetFastEnumeration(__objc2_class **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (CF_IS_OBJC(0x11uLL, a1))
    return 0;
  else
    return __CFBasicHashFastEnumeration((uint64_t)a1, a2, a3, a4);
}

BOOL _CFSetIsMutable(uint64_t a1)
{
  unsigned int v3;

  if (CF_IS_OBJC(0x11uLL, (__objc2_class **)a1))
    return 0;
  v3 = atomic_load((unint64_t *)(a1 + 8));
  return ((v3 >> 6) & 1) == 0;
}

uint64_t __CFDataMtbl(uint64_t a1)
{
  char v1;

  v1 = atomic_load((unint64_t *)(a1 + 8));
  return v1 & 1;
}

uint64_t _CFIsDeallocating(uint64_t a1)
{
  unsigned int v1;

  if (a1 < 1)
    return 0;
  v1 = atomic_load((unint64_t *)(a1 + 8));
  if ((*(_QWORD *)&v1 & 0x800000) != 0)
    return 1;
  else
    return (v1 >> 22) & 1;
}

uint64_t _cfmp_hash(uint64_t result)
{
  if (result)
    return 2654435761 * (*(unsigned __int8 *)(result + 4) | (*(_DWORD *)result << 8));
  return result;
}

void sub_182B1E6E0(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

id _CFURLComponentsCopyPort(void *a1)
{
  return (id)objc_msgSend(a1, "port");
}

id _CFURLComponentsCopyPath(void *a1)
{
  return (id)objc_msgSend(a1, "path");
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  const __CFString *v10;
  const __CFString *v11;
  unint64_t *v12;
  const __CFURL *v13;

  if (dyld_program_sdk_at_least())
    v10 = _CFURLCreateURLStringWithBytes(allocator, (UInt8 *)URLBytes, length, encoding);
  else
    v10 = CFStringCreateWithBytes(allocator, URLBytes, length, encoding, 0);
  v11 = v10;
  if (!v10)
    return 0;
  v12 = _CFURLCreateWithURLString((__objc2_class **)allocator, v10, 0, baseURL);
  v13 = (const __CFURL *)v12;
  if (encoding != 134217984 && v12)
    *((_DWORD *)v12 + 5) = encoding;
  CFRelease(v11);
  return v13;
}

unint64_t *__CFURLCreateCopyAppendingPathComponent(const __CFAllocator *a1, __objc2_class **a2, const __CFString *a3, int a4, const __CFString *a5)
{
  uint64_t v8;
  CFURLRef v10;
  _BOOL4 v11;
  const __CFString *v12;
  CFMutableStringRef MutableCopy;
  __CFString *v14;
  CFStringRef v15;
  unint64_t *v16;
  const __CFString *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  char v24;
  uint64_t *v25;
  const __CFString *v26;
  CFIndex v27;
  CFIndex Length;

  v8 = (uint64_t)a2;
  if (CF_IS_OBJC(0x1DuLL, a2))
    v8 = objc_msgSend((id)v8, "_cfurl");
  if (CFURLIsFileReferenceURL((CFURLRef)v8))
  {
    v10 = CFURLCreateFilePathURL(a1, (CFURLRef)v8, 0);
    v11 = v10 != 0;
    if (v10)
      v8 = (uint64_t)v10;
  }
  else
  {
    v11 = 0;
  }
  if ((*(_BYTE *)(v8 + 16) & 0x20) != 0)
  {
    v12 = (const __CFString *)atomic_load((unint64_t *)(v8 + 24));
    MutableCopy = CFStringCreateMutableCopy(a1, 0, v12);
    if (MutableCopy)
    {
      v14 = MutableCopy;
      if (_CFURLHasFileURLScheme((__objc2_class **)v8, 0))
        v15 = POSIXPathToURLPath(a3, 0, 0, 0);
      else
        v15 = CFURLCreateStringByAddingPercentEscapes(a1, a3, 0, a5, *(_DWORD *)(v8 + 20));
      v18 = v15;
      if (!v15)
      {
        v16 = 0;
        goto LABEL_30;
      }
      v19 = *(_DWORD *)(v8 + 16);
      if ((v19 & 0x20) != 0)
      {
        v22 = 0;
        v23 = 32;
        do
        {
          v24 = v23;
          v23 >>= 1;
          v22 += v19 & 1;
          v19 >>= 1;
        }
        while ((v24 & 2) == 0);
        v25 = (uint64_t *)(v8 + 56 + 16 * v22);
        v21 = *v25;
        v20 = v25[1];
        if (v20)
        {
          v26 = (const __CFString *)atomic_load((unint64_t *)(v8 + 24));
          if (CFStringGetCharacterAtIndex(v26, v21 + v20 - 1) == 47)
          {
LABEL_27:
            v27 = v20 + v21;
            CFStringInsert(v14, v27, v18);
            if (a4)
            {
              Length = CFStringGetLength(v18);
              CFStringInsert(v14, Length + v27, CFSTR("/"));
            }
            CFRelease(v18);
            v16 = _CFURLCreateWithURLString((__objc2_class **)a1, v14, 0, *(const __CFURL **)(v8 + 32));
LABEL_30:
            CFRelease(v14);
            if (!v11)
              return v16;
            goto LABEL_13;
          }
        }
      }
      else
      {
        v20 = 0;
        v21 = -1;
      }
      if (!CFStringGetLength(v18) || CFStringGetCharacterAtIndex(v18, 0) != 47)
        CFStringInsert(v14, v21 + v20++, CFSTR("/"));
      goto LABEL_27;
    }
  }
  v16 = 0;
  if (v11)
LABEL_13:
    CFRelease((CFTypeRef)v8);
  return v16;
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
  char v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *Copy;
  CFIndex Length;
  int v17;
  _BOOL4 v18;
  unsigned int v19;
  uint64_t v20;
  char v21;
  char v22;
  uint64_t v23;
  char **p_data;
  char *v25;
  char *v26;
  uint64_t v27;
  CFStringEncoding v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD v31[3];
  CFRange v32;
  CFRange v33;

  v31[2] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)str))
  {
    -[__CFString insertString:atIndex:](str, "insertString:atIndex:", insertedStr, idx);
    return;
  }
  v6 = atomic_load((unint64_t *)&str->info);
  if ((v6 & 1) == 0)
  {
    v7 = _CFOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      CFStringInsert_cold_1(v7, v8, v9, v10, v11, v12, v13, v14);
    return;
  }
  if (insertedStr == str)
  {
    Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, str);
    insertedStr = Copy;
  }
  else
  {
    Copy = 0;
  }
  Length = CFStringGetLength(insertedStr);
  if (Length < 1)
  {
    v18 = 0;
  }
  else
  {
    if (CF_IS_OBJC(7uLL, (__objc2_class **)insertedStr))
    {
      v17 = -[__CFString _encodingCantBeStoredInEightBitCFString]((id)insertedStr, "_encodingCantBeStoredInEightBitCFString");
    }
    else
    {
      v19 = atomic_load((unint64_t *)&insertedStr->info);
      v17 = (v19 >> 4) & 1;
    }
    v18 = v17 != 0;
  }
  v31[0] = idx;
  v31[1] = 0;
  v20 = __CFStringChangeSizeMultiple((uint64_t)str, (uint64_t)v31, 1, Length, v18);
  v21 = atomic_load((unint64_t *)&str->info);
  v22 = atomic_load((unint64_t *)&str->info);
  v23 = v22 & 0x60;
  p_data = &str->data;
  if ((v21 & 0x10) == 0)
  {
    if (v23)
    {
      v25 = *p_data;
    }
    else
    {
      v27 = atomic_load((unint64_t *)&str->info);
      v25 = (char *)&p_data[(v27 & 5) != 4];
    }
    v28 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(v20);
      v28 = __CFDefaultEightBitStringEncoding;
    }
    v29 = atomic_load((unint64_t *)&str->info);
    v32.location = 0;
    v32.length = Length;
    CFStringGetBytes(insertedStr, v32, v28, 0, 0, (UInt8 *)&v25[idx + ((v29 >> 2) & 1)], Length, 0);
    goto LABEL_27;
  }
  if (!v23)
  {
    v30 = atomic_load((unint64_t *)&str->info);
    v26 = (char *)&p_data[(v30 & 5) != 4];
    if (!v26)
      goto LABEL_27;
    goto LABEL_26;
  }
  v26 = *p_data;
  if (v26)
  {
LABEL_26:
    v33.location = 0;
    v33.length = Length;
    CFStringGetCharacters(insertedStr, v33, (UniChar *)&v26[2 * idx]);
  }
LABEL_27:
  if (Copy)
    CFRelease(Copy);
}

void CFStringReplaceAll(CFMutableStringRef theString, CFStringRef replacement)
{
  uint64_t *p_info;
  char v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  char **p_data;
  char *v19;
  uint64_t length;
  uint64_t v21;
  const __CFString *Copy;
  CFIndex v23;
  int v24;
  _BOOL4 v25;
  unsigned int v26;
  uint64_t v27;
  char v28;
  char v29;
  uint64_t v30;
  char **v31;
  char *v32;
  UniChar *v33;
  uint64_t v34;
  CFStringEncoding v35;
  unint64_t v36;
  uint64_t v37;
  _QWORD v38[3];
  CFRange v39;
  CFRange v40;

  v38[2] = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    -[__CFString setString:](theString, "setString:", replacement);
    return;
  }
  p_info = &theString->info;
  v5 = atomic_load((unint64_t *)&theString->info);
  if ((v5 & 1) == 0)
  {
    v6 = _CFOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      CFStringReplaceAll_cold_1(v6, v7, v8, v9, v10, v11, v12, v13);
    return;
  }
  v14 = atomic_load((unint64_t *)p_info);
  v15 = v14 & 5;
  v16 = atomic_load((unint64_t *)p_info);
  v17 = v16 & 0x60;
  if (v15 == 4)
  {
    p_data = &theString->data;
    if (v17)
    {
      v19 = *p_data;
    }
    else
    {
      v21 = atomic_load((unint64_t *)&theString->info);
      v19 = (char *)&p_data[(v21 & 5) != 4];
    }
    length = *v19;
  }
  else if ((v16 & 0x60) != 0)
  {
    length = theString->length;
  }
  else
  {
    length = (uint64_t)theString->data;
  }
  if (replacement == theString)
  {
    Copy = CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, theString);
    replacement = Copy;
  }
  else
  {
    Copy = 0;
  }
  v23 = CFStringGetLength(replacement);
  if (v23 < 1)
  {
    v25 = 0;
  }
  else
  {
    if (CF_IS_OBJC(7uLL, (__objc2_class **)replacement))
    {
      v24 = -[__CFString _encodingCantBeStoredInEightBitCFString]((id)replacement, "_encodingCantBeStoredInEightBitCFString");
    }
    else
    {
      v26 = atomic_load((unint64_t *)&replacement->info);
      v24 = (v26 >> 4) & 1;
    }
    v25 = v24 != 0;
  }
  v38[0] = 0;
  v38[1] = length;
  v27 = __CFStringChangeSizeMultiple((uint64_t)theString, (uint64_t)v38, 1, v23, v25);
  v28 = atomic_load((unint64_t *)&theString->info);
  v29 = atomic_load((unint64_t *)&theString->info);
  v30 = v29 & 0x60;
  v31 = &theString->data;
  if ((v28 & 0x10) == 0)
  {
    if (v30)
    {
      v32 = *v31;
    }
    else
    {
      v34 = atomic_load((unint64_t *)&theString->info);
      v32 = (char *)&v31[(v34 & 5) != 4];
    }
    v35 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding(v27);
      v35 = __CFDefaultEightBitStringEncoding;
    }
    v36 = atomic_load((unint64_t *)&theString->info);
    v39.location = 0;
    v39.length = v23;
    CFStringGetBytes(replacement, v39, v35, 0, 0, (UInt8 *)&v32[(v36 >> 2) & 1], v23, 0);
    goto LABEL_35;
  }
  if (!v30)
  {
    v37 = atomic_load((unint64_t *)&theString->info);
    v33 = (UniChar *)&v31[(v37 & 5) != 4];
    if (!v33)
      goto LABEL_35;
    goto LABEL_34;
  }
  v33 = (UniChar *)*v31;
  if (*v31)
  {
LABEL_34:
    v40.location = 0;
    v40.length = v23;
    CFStringGetCharacters(replacement, v40, v33);
  }
LABEL_35:
  if (Copy)
    CFRelease(Copy);
}

id _CFURLComponentsCopyURLRelativeToURL(void *a1, uint64_t a2)
{
  return (id)objc_msgSend(a1, "URLRelativeToURL:", a2);
}

unint64_t *_CFURLCreateWithURLString(__objc2_class **a1, CFStringRef theString, int a3, const __CFURL *a4)
{
  __objc2_class **v6;
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  CFIndex v10;
  int v11;
  CFIndex v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  UniChar *v17;
  CFRange v18;
  char *v19;
  CFIndex v20;
  UniChar *v21;
  UniChar v22;
  BOOL v23;
  CFIndex v24;
  CFIndex v25;
  uint64_t v26;
  CFIndex v27;
  const UniChar *v28;
  const char *v29;
  CFIndex v30;
  UniChar v31;
  unint64_t *v32;
  CFRange v33;
  CFIndex v34;
  uint64_t v35;
  uint64_t v36;
  UniChar *v37;
  CFRange v38;
  char *v39;
  CFIndex v40;
  UniChar *v41;
  UniChar v42;
  uint64_t v43;
  uint64_t v44;
  size_t v45;
  unint64_t *Instance;
  CFStringRef Copy;
  unint64_t *v48;
  CFURLRef v49;
  const __CFAllocator *v50;
  const __CFString *v51;
  CFIndex v52;
  const __CFString *v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  char v63;
  uint64_t *v64;
  unint64_t *v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  const void *v70;
  const __CFAllocator *v71;
  uint64_t *v72;
  int v75;
  CFMutableStringRef theStringa;
  uint64_t v77;
  uint64_t v78;
  __int16 v79;
  uint64_t __src[18];
  UniChar buffer[8];
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  CFIndex v92;
  uint64_t v93;

  v6 = a1;
  v93 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if (!theString)
      return 0;
    v87 = 0u;
    v88 = 0u;
    v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    *(_OWORD *)buffer = 0u;
    v82 = 0u;
    Length = CFStringGetLength(theString);
    *(_QWORD *)&v89 = theString;
    *((_QWORD *)&v90 + 1) = 0;
    *(_QWORD *)&v91 = Length;
    CharactersPtr = CFStringGetCharactersPtr(theString);
    CStringPtr = 0;
    *((_QWORD *)&v89 + 1) = CharactersPtr;
    if (!CharactersPtr)
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    *(_QWORD *)&v90 = CStringPtr;
    *((_QWORD *)&v91 + 1) = 0;
    v92 = 0;
    if (Length >= 1)
    {
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      do
      {
        v14 = v12 + 64;
        if (v12 + 64 <= Length)
          v15 = 64;
        else
          v15 = Length - v12;
        if (v12 < 0 || (v16 = v91, v15 + v12 > (uint64_t)v91))
        {
          v17 = 0;
        }
        else if (*((_QWORD *)&v89 + 1))
        {
          v17 = (UniChar *)(*((_QWORD *)&v89 + 1) + 2 * *((_QWORD *)&v90 + 1) + 2 * v12);
        }
        else
        {
          if (v15 > 64)
          {
            v17 = 0;
LABEL_30:
            if (Length >= v14)
              v24 = v12 + 64;
            else
              v24 = Length;
            v25 = v12;
            while (2)
            {
              v26 = *v17;
              if (v13)
              {
                if (v26 > 0x7F || (sURLValidCharacters[v26] & 0x10) == 0)
                  return 0;
                --v13;
                goto LABEL_38;
              }
              if (*v17 > 0x5Au)
              {
                v13 = 0;
                if ((_DWORD)v26 == 91 || (_DWORD)v26 == 93)
                {
LABEL_38:
                  ++v17;
                  if (v24 == ++v25)
                    goto LABEL_52;
                  continue;
                }
              }
              else
              {
                if ((_DWORD)v26 == 35)
                {
                  if (v11)
                    return 0;
                  v13 = 0;
                  v11 = 1;
                  goto LABEL_38;
                }
                if ((_DWORD)v26 == 37)
                {
                  if (v25 + 2 >= Length)
                    return 0;
                  v13 = 2;
                  goto LABEL_38;
                }
              }
              break;
            }
            if (v26 > 0x7F || (sURLValidCharacters[v26] & 1) == 0)
              return 0;
            v13 = 0;
            goto LABEL_38;
          }
          if (v15 + v12 > v92 || v12 < v10)
          {
            if (v14 < (uint64_t)v91)
              v16 = v12 + 64;
            *((_QWORD *)&v91 + 1) = v12;
            v92 = v16;
            v18.location = *((_QWORD *)&v90 + 1) + v12;
            v18.length = v16 - v12;
            if ((_QWORD)v90)
            {
              if (v18.length)
              {
                v19 = (char *)(v90 + v18.location);
                v20 = v12 - v16;
                v21 = buffer;
                do
                {
                  v22 = *v19++;
                  *v21++ = v22;
                  v23 = __CFADD__(v20++, 1);
                }
                while (!v23);
              }
            }
            else
            {
              CFStringGetCharacters((CFStringRef)v89, v18, buffer);
            }
          }
          v10 = *((_QWORD *)&v91 + 1);
          v17 = &buffer[v12 - *((_QWORD *)&v91 + 1)];
        }
        if (v15 >= 1)
          goto LABEL_30;
LABEL_52:
        v12 += v15;
      }
      while (v12 < Length);
    }
    v6 = a1;
  }
  v92 = 0;
  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  *(_OWORD *)buffer = 0u;
  v27 = CFStringGetLength(theString);
  *(_QWORD *)&v89 = theString;
  *((_QWORD *)&v90 + 1) = 0;
  *(_QWORD *)&v91 = v27;
  v28 = CFStringGetCharactersPtr(theString);
  v29 = 0;
  *((_QWORD *)&v89 + 1) = v28;
  if (!v28)
    v29 = CFStringGetCStringPtr(theString, 0x600u);
  *(_QWORD *)&v90 = v29;
  *((_QWORD *)&v91 + 1) = 0;
  v92 = 0;
  if (v27 < 1)
    goto LABEL_100;
  if (*((_QWORD *)&v89 + 1))
  {
    v30 = 0;
    v31 = *(_WORD *)(*((_QWORD *)&v89 + 1) + 2 * *((_QWORD *)&v90 + 1));
  }
  else if (v29)
  {
    v30 = 0;
    v31 = v29[*((_QWORD *)&v90 + 1)];
  }
  else
  {
    v33.location = *((_QWORD *)&v90 + 1);
    v33.length = (uint64_t)v91 >= 64 ? 64 : v91;
    v92 = v33.length;
    CFStringGetCharacters((CFStringRef)v89, v33, buffer);
    v30 = *((_QWORD *)&v91 + 1);
    v31 = buffer[-*((_QWORD *)&v91 + 1)];
  }
  if (v31 > 0x7Fu || (sURLValidCharacters[v31] & 2) == 0)
    goto LABEL_100;
  v34 = 0;
  while (1)
  {
    v35 = v34 + 64;
    if (v34 + 64 <= v27)
      v36 = 64;
    else
      v36 = v27 - v34;
    if (v34 < 0 || v36 + v34 > (uint64_t)v91)
    {
      v37 = 0;
      goto LABEL_91;
    }
    if (*((_QWORD *)&v89 + 1))
    {
      v37 = (UniChar *)(*((_QWORD *)&v89 + 1) + 2 * *((_QWORD *)&v90 + 1) + 2 * v34);
      goto LABEL_91;
    }
    if (v36 > 64)
      break;
    if (v36 + v34 > v92 || v34 < v30)
    {
      if (v35 >= (uint64_t)v91)
        v35 = v91;
      *((_QWORD *)&v91 + 1) = v34;
      v92 = v35;
      v38.location = *((_QWORD *)&v90 + 1) + v34;
      v38.length = v35 - v34;
      if ((_QWORD)v90)
      {
        if (v38.length)
        {
          v39 = (char *)(v90 + v38.location);
          v40 = v34 - v35;
          v41 = buffer;
          do
          {
            v42 = *v39++;
            *v41++ = v42;
            v23 = __CFADD__(v40++, 1);
          }
          while (!v23);
        }
      }
      else
      {
        CFStringGetCharacters((CFStringRef)v89, v38, buffer);
      }
    }
    v30 = *((_QWORD *)&v91 + 1);
    v37 = &buffer[v34 - *((_QWORD *)&v91 + 1)];
LABEL_91:
    if (v36 >= 1)
      goto LABEL_92;
LABEL_97:
    v34 += v36;
    if (v34 >= v27)
      goto LABEL_100;
  }
  v37 = 0;
LABEL_92:
  v43 = 0;
  while (1)
  {
    v44 = v37[v43];
    if ((_DWORD)v44 == 58)
      break;
    if (v44 > 0x7F || (sURLValidCharacters[v44] & 8) == 0)
      goto LABEL_100;
    if (++v43 >= v36)
      goto LABEL_97;
  }
  a4 = 0;
LABEL_100:
  LOBYTE(v77) = 0;
  LODWORD(v78) = 0;
  _parseComponents(theString, a4, (unsigned int *)&v78, __src, (char *)&v77);
  v45 = 16 * v77;
  Instance = (unint64_t *)_CFRuntimeCreateInstance(v6, 0x1DuLL, v45 + 40, 0);
  v32 = Instance;
  if (Instance)
  {
    *((_DWORD *)Instance + 4) = v78;
    *((_DWORD *)Instance + 5) = 134217984;
    memcpy(Instance + 7, __src, v45);
    Copy = CFStringCreateCopy((CFAllocatorRef)v6, theString);
    v48 = v32 + 3;
    atomic_store((unint64_t)Copy, v32 + 3);
    if (a4)
      v49 = CFURLCopyAbsoluteURL(a4);
    else
      v49 = 0;
    v32[4] = (unint64_t)v49;
    v50 = CFGetAllocator(v32);
    v51 = (const __CFString *)atomic_load(v48);
    v52 = CFStringGetLength(v51);
    v79 = 0;
    __src[0] = 0;
    v77 = 0;
    v78 = 0;
    theStringa = 0;
    v75 = 0;
    v53 = (const __CFString *)atomic_load(v48);
    constructBuffers(v53, (UInt8 *)buffer, __src, &v78, (char *)&v79 + 1, (char *)&v79);
    v54 = *((_DWORD *)v32 + 4);
    if ((v54 & 0x4000) != 0)
    {
      v77 = 0;
      v56 = __src[0];
      v57 = v78;
      v58 = 2;
      v59 = HIBYTE(v79);
      do
      {
        v60 = *((_DWORD *)v32 + 4);
        if ((v60 & v58) != 0)
        {
          v61 = 0;
          v62 = v58;
          do
          {
            v63 = v62;
            v62 >>= 1;
            v61 += v60 & 1;
            v60 >>= 1;
          }
          while ((v63 & 2) == 0);
          v64 = (uint64_t *)&v32[2 * v61 + 7];
          if (*v64 != -1)
            scanCharacters(v50, &theStringa, &v75, v56, v57, v59, *v64, v64[1] + *v64, &v77, v58, *((_DWORD *)v32 + 5));
        }
        v58 *= 2;
      }
      while (v58 < 512);
      v65 = (unint64_t *)theStringa;
      if (theStringa)
      {
LABEL_120:
        v66 = v75;
        v67 = v32[5];
        if (v75 && !v67)
        {
          _CFURLAllocateExtraDataspace(v32);
          v67 = v32[5];
        }
        if (v67)
          *(_DWORD *)(v67 + 16) = v66;
        v68 = v52 - v77;
        if (v52 > v77)
        {
          if (v59)
            __CFStringAppendBytes(v65, (unsigned __int8 *)(v56 + v77), v68, 513);
          else
            CFStringAppendCharacters((CFMutableStringRef)v65, (const UniChar *)(v57 + 2 * v77), v68);
        }
        v69 = v32[5];
        if (v69 || (_CFURLAllocateExtraDataspace(v32), (v69 = v32[5]) != 0))
        {
          v70 = *(const void **)(v69 + 8);
          if (v70)
            CFRelease(v70);
          v71 = CFGetAllocator(v32);
          *(_QWORD *)(v32[5] + 8) = CFStringCreateCopy(v71, (CFStringRef)v65);
        }
        CFRelease(v65);
      }
      else
      {
        *((_DWORD *)v32 + 4) |= 0x10000u;
      }
    }
    else
    {
      if ((v54 & 1) != 0)
        v55 = v32[8] + 1;
      else
        v55 = 1;
      v77 = 0;
      v56 = __src[0];
      v57 = v78;
      v59 = HIBYTE(v79);
      if (!scanCharacters(v50, &theStringa, &v75, __src[0], v78, HIBYTE(v79), v55, v52, &v77, 0, *((_DWORD *)v32 + 5)))*((_DWORD *)v32 + 4) |= 0x10000u;
      v65 = (unint64_t *)theStringa;
      if (theStringa)
        goto LABEL_120;
    }
    if ((_BYTE)v79)
    {
      v72 = __src;
      if (!HIBYTE(v79))
        v72 = &v78;
      free((void *)*v72);
    }
  }
  return v32;
}

uint64_t scanCharacters(const __CFAllocator *a1, __CFString **a2, _DWORD *a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, _QWORD *a9, int a10, int a11)
{
  unsigned __int8 v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  const __CFString *v26;
  unsigned __int16 v27;
  int v28;
  BOOL v30;
  int v31;
  uint64_t v32;
  uint64_t v34;
  uint64_t v36;
  unsigned int v37;
  int v38;
  CFMutableStringRef Mutable;
  unsigned __int16 v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v45;
  uint64_t v46;
  unsigned __int16 v49;
  unsigned __int16 v50;
  unsigned __int16 v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (!a6)
  {
    if (a7 >= a8)
      return 0;
    v15 = 0;
    v46 = a8 - 1;
    if (a3)
      v30 = a10 == 0;
    else
      v30 = 1;
    v31 = !v30;
    v32 = a7;
    while (1)
    {
      v49 = *(_WORD *)(a5 + 2 * v32);
      if (v49 <= 0x7Fu)
      {
        if ((sURLValidCharacters[v49] & 1) != 0)
        {
          if (a10 == 4 || a10 == 2)
          {
            v37 = v49 - 47;
            v21 = v37 > 0x11;
            v38 = (1 << v37) & 0x30001;
            if (!v21 && v38 != 0)
              goto LABEL_81;
          }
          goto LABEL_94;
        }
        v34 = v32 + 2;
        if (v49 == 37 && v34 < a8)
        {
          v42 = *(unsigned __int16 *)(a5 + 2 * v32 + 2);
          if (v42 <= 0x7F && (sURLValidCharacters[v42] & 0x10) != 0)
          {
            v43 = *(unsigned __int16 *)(a5 + 2 * v34);
            if (v43 <= 0x7F && (sURLValidCharacters[v43] & 0x10) != 0)
              goto LABEL_94;
          }
        }
      }
      if (a10 != 8)
        goto LABEL_81;
      if (v32 != a7 || v49 != 91)
      {
        if (v32 == v46)
        {
          v36 = v46;
          if (v49 == 93)
            goto LABEL_95;
        }
LABEL_81:
        if (v31)
          *a3 |= a10;
        Mutable = *a2;
        if (!*a2)
        {
          Mutable = CFStringCreateMutable(a1, 0);
          *a2 = Mutable;
        }
        CFStringAppendCharacters(Mutable, (const UniChar *)(a5 + 2 * *a9), v32 - *a9);
        if (_appendPercentEscapesForCharacter(&v49, 0, a11, *a2))
        {
          *a9 = v32 + 1;
        }
        else if (a11 == 134217984)
        {
          v36 = v32 + 1;
          if (v32 + 1 < a8 && (v49 & 0xFC00) == 0xD800)
          {
            v41 = *(_WORD *)(a5 + 2 * v36);
            if ((v41 & 0xFC00) == 0xDC00)
            {
              v50 = v49;
              v51 = v41;
              if (_appendPercentEscapesForCharacter(&v50, 1, 134217984, *a2))
                *a9 = v32 + 2;
              else
                v36 = v32;
              v15 = 1;
              goto LABEL_95;
            }
          }
        }
        v15 = 1;
LABEL_94:
        v36 = v32;
        goto LABEL_95;
      }
      v36 = a7;
LABEL_95:
      v32 = v36 + 1;
      if (v36 + 1 >= a8)
        return v15;
    }
  }
  if (a7 < a8)
  {
    v15 = 0;
    v45 = a8 - 1;
    if (a3)
      v16 = a10 == 0;
    else
      v16 = 1;
    v17 = !v16;
    v18 = a7;
    while (1)
    {
      v19 = *(char *)(a4 + v18);
      v49 = *(char *)(a4 + v18);
      if ((v19 & 0x80000000) == 0)
      {
        if ((sURLValidCharacters[(unsigned __int16)v19] & 1) != 0)
        {
          if (a10 == 4 || a10 == 2)
          {
            v23 = (unsigned __int16)v19 - 47;
            v21 = v23 > 0x11;
            v24 = (1 << v23) & 0x30001;
            if (!v21 && v24 != 0)
              goto LABEL_30;
          }
          goto LABEL_43;
        }
        v20 = v18 + 2;
        v21 = v19 == 37 && v20 < a8;
        if (v21
          && (*(char *)(v18 + a4 + 1) & 0x80000000) == 0
          && (sURLValidCharacters[*(unsigned __int8 *)(v18 + a4 + 1)] & 0x10) != 0)
        {
          v28 = *(char *)(a4 + v20);
          if ((v28 & 0x80000000) == 0 && (sURLValidCharacters[v28] & 0x10) != 0)
            goto LABEL_43;
        }
      }
      if (a10 != 8)
        goto LABEL_30;
      if (v18 != a7 || v19 != 91)
      {
        if (v18 == v45)
        {
          v22 = v45;
          if (v19 == 93)
            goto LABEL_44;
        }
LABEL_30:
        if (v17)
          *a3 |= a10;
        if (!*a2)
          *a2 = CFStringCreateMutable(a1, 0);
        v26 = CFStringCreateWithBytes(a1, (const UInt8 *)(a4 + *a9), v18 - *a9, 0x201u, 0);
        CFStringAppend(*a2, v26);
        CFRelease(v26);
        if (_appendPercentEscapesForCharacter(&v49, 0, a11, *a2))
        {
          *a9 = v18 + 1;
        }
        else if (a11 == 134217984)
        {
          v22 = v18 + 1;
          if (v18 + 1 < a8 && (v49 & 0xFC00) == 0xD800)
          {
            v27 = *(char *)(a4 + v22);
            if (v27 >> 10 == 55)
            {
              v50 = v49;
              v51 = v27;
              if (_appendPercentEscapesForCharacter(&v50, 1, 134217984, *a2))
                *a9 = v18 + 2;
              else
                v22 = v18;
              v15 = 1;
              goto LABEL_44;
            }
          }
        }
        v15 = 1;
LABEL_43:
        v22 = v18;
        goto LABEL_44;
      }
      v22 = a7;
LABEL_44:
      v18 = v22 + 1;
      if (v22 + 1 >= a8)
        return v15;
    }
  }
  return 0;
}

void _parseComponents(const __CFString *a1, const __CFURL *a2, unsigned int *a3, _QWORD *a4, char *a5)
{
  CFIndex Length;
  int v11;
  unsigned int v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  char v16;
  int v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  _BOOL4 v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  _BOOL4 v36;
  _BOOL4 v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  int v48;
  _BOOL4 v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  char *v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  int v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  BOOL v62;
  unsigned int v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  unsigned __int16 *v69;
  unsigned __int16 *v70;
  unsigned __int16 *v71;
  int v72;
  int v73;
  int v74;
  uint64_t v75;
  int v76;
  int v77;
  void **v78;
  uint64_t v79;
  uint64_t v80;
  BOOL v81;
  unsigned int v82;
  uint64_t v83;
  int v84;
  int v85;
  uint64_t v86;
  char v87;
  uint64_t v88;
  char v89;
  unsigned int v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t i;
  int v97;
  uint64_t j;
  int v99;
  unsigned __int16 *v100;
  char *v101;
  __int16 v102;
  UInt8 v103[1024];
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  uint64_t v113;

  v113 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(a1);
  v102 = 0;
  v100 = 0;
  v101 = 0;
  constructBuffers(a1, v103, &v101, &v100, (char *)&v102 + 1, (char *)&v102);
  v11 = HIBYTE(v102);
  if (HIBYTE(v102))
  {
    v111 = 0u;
    v112 = 0u;
    v109 = 0u;
    v110 = 0u;
    v107 = 0u;
    v108 = 0u;
    v105 = 0u;
    v106 = 0u;
    v104 = 0u;
    v12 = *a3;
    if (Length < 1)
    {
      v17 = 0;
      v14 = 0;
      v18 = 0;
    }
    else
    {
      v13 = 0;
      while (v101[v13] != 35)
      {
        if (Length == ++v13)
        {
          v14 = 0;
          v13 = Length;
          goto LABEL_14;
        }
      }
      v12 |= 0x100u;
      *(_QWORD *)&v112 = v13 + 1;
      *((_QWORD *)&v112 + 1) = ~v13 + Length;
      v14 = 1;
LABEL_14:
      if (v13 < 1)
      {
        v17 = 0;
        v18 = 0;
      }
      else
      {
        v18 = *v101;
        v17 = 1;
        if ((v18 & 0x80000000) != 0)
        {
          v19 = 0;
          goto LABEL_20;
        }
      }
      Length = v13;
    }
    v19 = (sURLValidCharacters[(unsigned __int16)v18] >> 3) & 1;
    v13 = Length;
LABEL_20:
    v20 = 0;
    v23 = v18 > 0x40 && v19 != 0 || v18 == 58;
    if (v17 && v23)
    {
      v20 = 0;
      while (1)
      {
        v24 = v101[v20];
        if (v24 == 58)
          break;
        if ((v24 & 0x80) == 0 && (sURLValidCharacters[v24] & 8) != 0 && ++v20 < v13)
          continue;
        v20 = 0;
        v25 = 0;
        goto LABEL_38;
      }
      v12 |= 1u;
      *(_QWORD *)&v104 = 0;
      *((_QWORD *)&v104 + 1) = v20;
      ++v14;
      switch(v20)
      {
        case 3:
          if (*v101 != 102 || v101[1] != 116)
          {
            v25 = 4;
            v20 = 3;
            goto LABEL_38;
          }
          v60 = 4;
          v61 = 3;
          v62 = v101[2] == 112;
          v63 = v12 & 0x1FFFFFFF | 0xA0000000;
          v64 = 4;
          v20 = 3;
          break;
        case 4:
          v65 = *v101;
          if (v65 == 100)
          {
            if (v101[1] != 97 || v101[2] != 116)
              goto LABEL_256;
            v60 = 5;
            v61 = 4;
            v62 = v101[3] == 97;
            v90 = 0x80000000;
          }
          else
          {
            if (v65 != 102)
            {
              if (v65 == 104 && v101[1] == 116 && v101[2] == 116 && v101[3] == 112)
              {
                v33 = v12 & 0x1FFFFFFF | 0x20000000;
                v25 = 5;
                v20 = 4;
LABEL_183:
                v12 = v33;
                goto LABEL_38;
              }
LABEL_256:
              v25 = 5;
              v20 = 4;
              goto LABEL_38;
            }
            if (v101[1] != 105 || v101[2] != 108)
              goto LABEL_256;
            v60 = 5;
            v61 = 4;
            v62 = v101[3] == 101;
            v90 = 1610612736;
          }
          v63 = v90 & 0xE0000000 | v12 & 0x1FFFFFFF;
          v64 = 5;
          v20 = 4;
          break;
        case 5:
          if (*v101 != 104 || v101[1] != 116 || v101[2] != 116 || v101[3] != 112 || v101[4] != 115)
          {
            v25 = 6;
            v20 = 5;
            goto LABEL_38;
          }
          v33 = v12 & 0x1FFFFFFF | 0x40000000;
          v25 = 6;
          v20 = 5;
          goto LABEL_183;
        default:
          v25 = v20 + 1;
          goto LABEL_38;
      }
      if (v62)
        v12 = v63;
      else
        v20 = v61;
      if (v62)
        v25 = v64;
      else
        v25 = v60;
    }
    else
    {
      v25 = 0;
    }
LABEL_38:
    if ((v12 & 1) != 0 && (v13 == v25 || v101[v25] != 47))
    {
LABEL_113:
      *a3 = v12 & 0xFFFFFEFF;
      *a4 = 0;
      a4[1] = v20;
      *a5 = 1;
      goto LABEL_215;
    }
    v26 = v12 | 0x4000;
    if (v13 - v25 >= 2 && v101[v25] == 47 && v101[v25 + 1] == 47)
    {
      v27 = v25 + 2;
      if (v25 + 2 >= v13)
        goto LABEL_48;
      v28 = v25 + 2;
      while ((v101[v28] | 0x10) != 0x3F)
      {
        if (v13 == ++v28)
        {
          v28 = v13;
          break;
        }
      }
      if (v28 == v27)
      {
LABEL_48:
        v28 = v25 + 2;
      }
      else
      {
        if (v27 >= v28)
        {
LABEL_236:
          v87 = v14;
        }
        else
        {
          v86 = -1;
          while (v101[v27 + 1 + v86] != 64)
          {
            ++v86;
            if (v25 - v28 + 2 + v86 == -1)
              goto LABEL_236;
          }
          v26 = v12 | 0x4002;
          v87 = v14 + 1;
          *(_QWORD *)&v105 = v25 + 2;
          if (v27 < v25 + v86 + 3)
          {
            v91 = 0;
            v92 = &v101[v27];
            v93 = v86;
            while (v92[v91] != 58)
            {
              ++v91;
              if (--v93 == -1)
                goto LABEL_284;
            }
            v26 = v12 | 0x4006;
            v87 = v14 + 2;
            *(_QWORD *)&v106 = v25 + v91 + 3;
            *((_QWORD *)&v106 + 1) = v93;
            *((_QWORD *)&v105 + 1) = v91;
          }
LABEL_284:
          if ((v26 & 4) == 0)
            *((_QWORD *)&v105 + 1) = v86 + 1;
          v27 = v25 + v86 + 4;
        }
        v26 |= 8u;
        v14 = v87 + 1;
        *(_QWORD *)&v107 = v27;
        if (v28 > v27)
        {
          for (i = v27; i < v28; ++i)
          {
            v97 = v101[i];
            if (v97 == 91)
            {
              if (i < v28)
              {
                while (v101[i] != 93)
                {
                  if (v28 == ++i)
                  {
                    i = v28;
                    goto LABEL_297;
                  }
                }
                v26 |= 0x400u;
              }
            }
            else if (v97 == 58)
            {
              v26 |= 0x10u;
              v14 = v87 + 2;
              *(_QWORD *)&v108 = i + 1;
              *((_QWORD *)&v108 + 1) = v28 - (i + 1);
              *((_QWORD *)&v107 + 1) = i - v27;
              break;
            }
LABEL_297:
            ;
          }
        }
        if ((v26 & 0x10) == 0)
          *((_QWORD *)&v107 + 1) = v28 - v27;
      }
    }
    else
    {
      v28 = v25;
    }
    if (v28 >= v13)
    {
LABEL_54:
      v29 = v13;
    }
    else
    {
      v29 = v28;
      while (v101[v29] != 63)
      {
        if (v13 == ++v29)
          goto LABEL_54;
      }
      v26 |= 0x80u;
      ++v14;
      *(_QWORD *)&v111 = v29 + 1;
      *((_QWORD *)&v111 + 1) = ~v29 + v13;
    }
    v34 = v29 - v28;
    if (v29 == v28 && (v26 & 0x1E) == 0)
      goto LABEL_168;
    v35 = v26 | 0x20;
    ++v14;
    *(_QWORD *)&v109 = v28;
    *((_QWORD *)&v109 + 1) = v29 - v28;
    if (v34 < 1)
    {
      if (a2 && CFURLHasDirectoryPath(a2))
      {
LABEL_166:
        v26 = v35 | 0x800;
        goto LABEL_168;
      }
    }
    else
    {
      if (v29 <= v28)
      {
        v36 = 0;
      }
      else if (v101[v28] == 37)
      {
        v36 = 1;
      }
      else
      {
        v50 = v28 + 1;
        do
        {
          v51 = v50;
          if (v29 == v50)
            break;
          v52 = v101[v50++];
        }
        while (v52 != 37);
        v36 = v51 < v29;
      }
      if (v34 >= 7
        && v101[v28] == 47
        && v101[v28 + 1] == 46
        && v101[v28 + 2] == 102
        && v101[v28 + 3] == 105
        && v101[v28 + 4] == 108
        && (v53 = &v101[v28], v53[5] == 101)
        && v53[6] == 47)
      {
        v35 = v26 | 0x2020;
      }
      else
      {
        v54 = v26 | 0x8020;
        if (!v36)
          v35 = v54;
      }
      v55 = v101[v29 - 1];
      if (v55 == 47)
        goto LABEL_166;
      if ((unsigned __int16)v55 == 46)
      {
        if (v34 == 1)
          goto LABEL_166;
        v56 = v101[v29 - 2];
        if (v56 == 47 || (unsigned __int16)v56 == 46 && (v34 == 2 || v101[v29 - 3] == 47))
          goto LABEL_166;
      }
    }
    v26 = v35;
LABEL_168:
    v57 = 0;
    v58 = 0;
    *a3 = v26;
    *a5 = v14;
    v59 = 1;
    do
    {
      if ((*a3 & v59) != 0)
        *(_OWORD *)&a4[2 * v58++] = *(__int128 *)((char *)&v104 + v57);
      v59 *= 2;
      v57 += 16;
    }
    while (v57 != 144);
    goto LABEL_215;
  }
  v111 = 0u;
  v112 = 0u;
  v109 = 0u;
  v110 = 0u;
  v107 = 0u;
  v108 = 0u;
  v105 = 0u;
  v106 = 0u;
  v104 = 0u;
  v12 = *a3;
  if (Length < 1)
  {
    v30 = 0;
    v16 = 0;
    v31 = 0;
  }
  else
  {
    v15 = 0;
    while (v100[v15] != 35)
    {
      if (Length == ++v15)
      {
        v16 = 0;
        v15 = Length;
        goto LABEL_60;
      }
    }
    v12 |= 0x100u;
    *(_QWORD *)&v112 = v15 + 1;
    *((_QWORD *)&v112 + 1) = ~v15 + Length;
    v16 = 1;
LABEL_60:
    if (v15 < 1)
    {
      v30 = 0;
      v31 = 0u;
    }
    else
    {
      v31 = *v100;
      v30 = 1;
      if (v31 > 0x7F)
      {
        v32 = 0;
        goto LABEL_82;
      }
    }
    Length = v15;
  }
  v32 = (sURLValidCharacters[v31] >> 3) & 1;
  v15 = Length;
LABEL_82:
  v20 = 0;
  v39 = v31 > 0x40 && v32 != 0 || v31 == 58;
  if (!v30 || !v39)
  {
    v41 = 0;
    goto LABEL_100;
  }
  v20 = 0;
  while (1)
  {
    v40 = v100[v20];
    if ((_DWORD)v40 == 58)
      break;
    if (v40 <= 0x7F && (sURLValidCharacters[v40] & 8) != 0 && ++v20 < v15)
      continue;
    v20 = 0;
    v41 = 0;
    goto LABEL_100;
  }
  v12 |= 1u;
  *(_QWORD *)&v104 = 0;
  *((_QWORD *)&v104 + 1) = v20;
  ++v16;
  switch(v20)
  {
    case 3:
      if (*v100 != 102 || v100[1] != 116)
      {
        v41 = 4;
        v20 = 3;
        break;
      }
      v79 = 4;
      v80 = 3;
      v81 = v100[2] == 112;
      v82 = v12 & 0x1FFFFFFF | 0xA0000000;
      v83 = 4;
      v20 = 3;
      goto LABEL_260;
    case 4:
      v84 = *v100;
      if (v84 != 100)
      {
        if (v84 == 102)
        {
          if (v100[1] == 105 && v100[2] == 108 && v100[3] == 101)
          {
            v85 = 1610612736;
            goto LABEL_270;
          }
        }
        else if (v84 == 104 && v100[1] == 116 && v100[2] == 116 && v100[3] == 112)
        {
          v85 = 0x20000000;
LABEL_270:
          v46 = v85 & 0xE0000000 | v12 & 0x1FFFFFFF;
          v41 = 5;
          v20 = 4;
          goto LABEL_271;
        }
LABEL_272:
        v41 = 5;
        v20 = 4;
        break;
      }
      if (v100[1] != 97 || v100[2] != 116)
        goto LABEL_272;
      v79 = 5;
      v80 = 4;
      v81 = v100[3] == 97;
      v82 = v12 & 0x1FFFFFFF | 0x80000000;
      v83 = 5;
      v20 = 4;
LABEL_260:
      if (v81)
        v12 = v82;
      else
        v20 = v80;
      if (v81)
        v41 = v83;
      else
        v41 = v79;
      break;
    case 5:
      if (*v100 == 104 && v100[1] == 116 && v100[2] == 116 && v100[3] == 112 && v100[4] == 115)
      {
        v46 = v12 & 0x1FFFFFFF | 0x40000000;
        v41 = 6;
        v20 = 5;
LABEL_271:
        v12 = v46;
        break;
      }
      v41 = 6;
      v20 = 5;
      break;
    default:
      v41 = v20 + 1;
      break;
  }
LABEL_100:
  if ((v12 & 1) != 0 && (v15 == v41 || v100[v41] != 47))
    goto LABEL_113;
  v42 = v12 | 0x4000;
  if (v15 - v41 >= 2 && v100[v41] == 47 && v100[v41 + 1] == 47)
  {
    v43 = v41 + 2;
    if (v41 + 2 >= v15)
      goto LABEL_112;
    v44 = v41 + 2;
    while ((v100[v44] | 0x10) != 0x3F)
    {
      if (v15 == ++v44)
      {
        v44 = v15;
        break;
      }
    }
    if (v44 == v43)
    {
LABEL_112:
      v44 = v41 + 2;
    }
    else
    {
      if (v43 >= v44)
      {
LABEL_242:
        v89 = v16;
      }
      else
      {
        v88 = 0;
        while (v100[v41 + 2 + v88] != 64)
        {
          ++v88;
          if (!(v41 - v44 + 2 + v88))
            goto LABEL_242;
        }
        v42 = v12 | 0x4002;
        v89 = v16 + 1;
        *(_QWORD *)&v105 = v41 + 2;
        if (v43 < v41 + v88 + 2)
        {
          v94 = 0;
          v95 = v88 - 1;
          while (v100[v41 + 2 + v94] != 58)
          {
            ++v94;
            if (--v95 == -1)
              goto LABEL_301;
          }
          v42 = v12 | 0x4006;
          v89 = v16 + 2;
          *(_QWORD *)&v106 = v41 + v94 + 3;
          *((_QWORD *)&v106 + 1) = v95;
          *((_QWORD *)&v105 + 1) = v94;
        }
LABEL_301:
        if ((v42 & 4) == 0)
          *((_QWORD *)&v105 + 1) = v88;
        v43 = v41 + v88 + 3;
      }
      v42 |= 8u;
      v16 = v89 + 1;
      *(_QWORD *)&v107 = v43;
      if (v44 > v43)
      {
        for (j = v43; j < v44; ++j)
        {
          v99 = v100[j];
          if (v99 == 91)
          {
            if (j < v44)
            {
              while (v100[j] != 93)
              {
                if (v44 == ++j)
                {
                  j = v44;
                  goto LABEL_314;
                }
              }
              v42 |= 0x400u;
            }
          }
          else if (v99 == 58)
          {
            v42 |= 0x10u;
            v16 = v89 + 2;
            *(_QWORD *)&v108 = j + 1;
            *((_QWORD *)&v108 + 1) = v44 - (j + 1);
            *((_QWORD *)&v107 + 1) = j - v43;
            break;
          }
LABEL_314:
          ;
        }
      }
      if ((v42 & 0x10) == 0)
        *((_QWORD *)&v107 + 1) = v44 - v43;
    }
  }
  else
  {
    v44 = v41;
  }
  if (v44 >= v15)
  {
LABEL_119:
    v45 = v15;
  }
  else
  {
    v45 = v44;
    while (v100[v45] != 63)
    {
      if (v15 == ++v45)
        goto LABEL_119;
    }
    v42 |= 0x80u;
    ++v16;
    *(_QWORD *)&v111 = v45 + 1;
    *((_QWORD *)&v111 + 1) = ~v45 + v15;
  }
  v47 = v45 - v44;
  if (v45 == v44 && (v42 & 0x1E) == 0)
    goto LABEL_211;
  v48 = v42 | 0x20;
  ++v16;
  *(_QWORD *)&v109 = v44;
  *((_QWORD *)&v109 + 1) = v45 - v44;
  if (v47 < 1)
  {
    if (a2 && CFURLHasDirectoryPath(a2))
    {
LABEL_209:
      v42 = v48 | 0x800;
      goto LABEL_211;
    }
  }
  else
  {
    if (v45 <= v44)
    {
      v49 = 0;
    }
    else if (v100[v44] == 37)
    {
      v49 = 1;
    }
    else
    {
      v66 = v44 + 1;
      do
      {
        v67 = v66;
        if (v45 == v66)
          break;
        v68 = v100[v66++];
      }
      while (v68 != 37);
      v49 = v67 < v45;
    }
    if (v47 >= 7
      && v100[v44] == 47
      && (v69 = &v100[v44], v69[1] == 46)
      && v69[2] == 102
      && (v70 = &v100[v44], v70[3] == 105)
      && v70[4] == 108
      && (v71 = &v100[v44], v71[5] == 101)
      && v71[6] == 47)
    {
      v48 = v42 | 0x2020;
    }
    else
    {
      v72 = v42 | 0x8020;
      if (!v49)
        v48 = v72;
    }
    v73 = v100[v45 - 1];
    if (v73 == 47)
      goto LABEL_209;
    if (v73 == 46)
    {
      if (v47 == 1)
        goto LABEL_209;
      v74 = v100[v45 - 2];
      if (v74 == 47 || v74 == 46 && (v47 == 2 || v100[v45 - 3] == 47))
        goto LABEL_209;
    }
  }
  v42 = v48;
LABEL_211:
  v75 = 0;
  v76 = 0;
  *a3 = v42;
  *a5 = v16;
  v77 = 1;
  do
  {
    if ((*a3 & v77) != 0)
      *(_OWORD *)&a4[2 * v76++] = *(__int128 *)((char *)&v104 + v75);
    v77 *= 2;
    v75 += 16;
  }
  while (v75 != 144);
LABEL_215:
  if ((_BYTE)v102)
  {
    v78 = (void **)&v101;
    if (!v11)
      v78 = (void **)&v100;
    free(*v78);
  }
}

void constructBuffers(const __CFString *a1, UInt8 *a2, _QWORD *a3, _QWORD *a4, char *a5, char *a6)
{
  const char *CStringPtr;
  const UniChar *CharactersPtr;
  CFIndex Length;
  char v15;
  size_t v16;
  char v17;
  char v18;
  CFIndex usedBufLen[2];
  CFRange v20;
  CFRange v21;
  CFRange v22;

  usedBufLen[1] = *MEMORY[0x1E0C80C00];
  CStringPtr = CFStringGetCStringPtr(a1, 0x201u);
  *a3 = CStringPtr;
  if (CStringPtr)
  {
    *a4 = 0;
    *a5 = 1;
LABEL_5:
    *a6 = 0;
    return;
  }
  CharactersPtr = CFStringGetCharactersPtr(a1);
  *a4 = CharactersPtr;
  if (CharactersPtr)
  {
    *a5 = 0;
    goto LABEL_5;
  }
  usedBufLen[0] = 0;
  Length = CFStringGetLength(a1);
  v20.location = 0;
  v20.length = Length;
  CFStringGetBytes(a1, v20, 0x201u, 0, 0, 0, 0x7FFFFFFFLL, usedBufLen);
  if (usedBufLen[0] == Length)
  {
    if (a2 && Length < 1025)
    {
      v15 = 0;
    }
    else
    {
      a2 = (UInt8 *)malloc_type_malloc(Length, 0x2AEB48FuLL);
      v15 = 1;
    }
    *a6 = v15;
    v21.location = 0;
    v21.length = Length;
    CFStringGetBytes(a1, v21, 0x201u, 0, 0, a2, Length, 0);
    *a3 = a2;
    v18 = 1;
  }
  else
  {
    v16 = 2 * Length;
    if (a2 && v16 < 0x401)
    {
      v17 = 0;
    }
    else
    {
      a2 = (UInt8 *)malloc_type_malloc(v16, 0x1000040BDFB0063uLL);
      v17 = 1;
    }
    *a6 = v17;
    v22.location = 0;
    v22.length = Length;
    CFStringGetCharacters(a1, v22, (UniChar *)a2);
    v18 = 0;
    *a4 = a2;
  }
  *a5 = v18;
}

CFURLRef CFURLCreateWithString(CFAllocatorRef allocator, CFStringRef URLString, CFURLRef baseURL)
{
  if (URLString)
    return (CFURLRef)_CFURLCreateWithURLString((__objc2_class **)allocator, URLString, 1, baseURL);
  else
    return 0;
}

id _CFURLComponentsCopyString(void *a1)
{
  return (id)objc_msgSend(a1, "string");
}

id _CFURLComponentsCopyScheme(void *a1)
{
  return (id)objc_msgSend(a1, "scheme");
}

id _CFURLComponentsCopyPercentEncodedQuery(void *a1)
{
  return (id)objc_msgSend(a1, "percentEncodedQuery");
}

id _CFURLComponentsCopyPercentEncodedHost(void *a1)
{
  return (id)objc_msgSend(a1, "percentEncodedHost");
}

id _CFURLComponentsCopyHost(void *a1)
{
  return (id)objc_msgSend(a1, "host");
}

id _CFURLComponentsCopyPercentEncodedFragment(void *a1)
{
  return (id)objc_msgSend(a1, "percentEncodedFragment");
}

id _CFURLComponentsCopyPercentEncodedUser(void *a1)
{
  return (id)objc_msgSend(a1, "percentEncodedUser");
}

id _CFURLComponentsCopyPercentEncodedPath(void *a1)
{
  return (id)objc_msgSend(a1, "percentEncodedPath");
}

uint64_t _CFURLComponentsGetURLHostAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1)
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  return *(_QWORD *)(sURLAllowedCharacterSets + 16);
}

uint64_t _appendPercentEscapesForCharacter(unsigned __int16 *a1, int a2, int a3, __CFString *a4)
{
  uint64_t v5;
  int v6;
  uint64_t result;
  CFIndex v8;
  unsigned int *v9;
  unsigned int *v10;
  UniChar *v11;
  unsigned int v12;
  uint64_t v13;
  UniChar chars[24];
  unsigned int v15[2];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  if (a2)
    v5 = 2;
  else
    v5 = 1;
  v6 = CFStringEncodingUnicodeToBytes(a3, 0, a1, v5, 0, v15, 8, &v13);
  result = 0;
  if (!v6)
  {
    if (v13 < 1)
    {
      v8 = 0;
    }
    else
    {
      v8 = 0;
      v9 = (unsigned int *)((char *)v15 + v13);
      v10 = v15;
      do
      {
        v11 = &chars[v8];
        *v11 = 37;
        v12 = *(unsigned __int8 *)v10;
        v10 = (unsigned int *)((char *)v10 + 1);
        v11[1] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[(unint64_t)v12 >> 4];
        v8 += 3;
        v11[2] = CreateStringFromFileSystemRepresentationByAddingPercentEscapes_hexchars[v12 & 0xF];
      }
      while (v10 < v9);
    }
    CFStringAppendCharacters(a4, chars, v8);
    return 1;
  }
  return result;
}

_QWORD *_CFURLAllocateExtraDataspace(_QWORD *result)
{
  _QWORD *v1;
  CFAllocatorRef v2;
  uint64_t v3;
  uint64_t v4;

  if (!result[5])
  {
    v1 = result;
    v2 = CFGetAllocator(result);
    result = (_QWORD *)CFAllocatorAllocateTyped(v2, 24, 0x10E0040191BE475, 0);
    v3 = v1[5];
    if (v3)
    {
      v4 = *(_QWORD *)(v3 + 8);
      *result = *(_QWORD *)v3;
      *((_DWORD *)result + 4) = *(_DWORD *)(v3 + 16);
    }
    else
    {
      v4 = 0;
      *result = 0;
      *((_DWORD *)result + 4) = 0;
    }
    result[1] = v4;
    v1[5] = result;
  }
  return result;
}

id _CFURLComponentsCopyPercentEncodedPassword(void *a1)
{
  return (id)objc_msgSend(a1, "percentEncodedPassword");
}

__objc2_class **__CFURLSetResourceInfoPtr(__objc2_class **result, const void *a2)
{
  unint64_t *v3;
  unint64_t *v4;

  if (result)
  {
    v3 = (unint64_t *)result;
    result = (__objc2_class **)CF_IS_OBJC(0x1DuLL, result);
    if (!(_DWORD)result
      || (result = (__objc2_class **)objc_msgSend(v3, "_cfurl"), (v3 = (unint64_t *)result) != 0))
    {
      v4 = v3 + 6;
      while (!__ldaxr(v4))
      {
        if (!__stlxr((unint64_t)a2, v4))
          return (__objc2_class **)CFRetain(a2);
      }
      __clrex();
    }
  }
  return result;
}

void sub_182B21270(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return _CFPreferencesGetAppIntegerValueWithContainer((uint64_t)key, (uint64_t)applicationID, 0, (BOOL *)keyExistsAndHasValidFormat);
}

BOOL _CFRunLoopFinished(uint64_t a1, const __CFString *a2)
{
  pthread_mutex_t *v4;
  uint64_t v5;
  const void *v6;
  pthread_mutex_t *v7;
  _BOOL8 v8;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v4 = (pthread_mutex_t *)(a1 + 16);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  v5 = __CFRunLoopCopyMode(a1, a2, 0);
  if (v5)
  {
    v6 = (const void *)v5;
    v7 = (pthread_mutex_t *)(v5 + 16);
    pthread_mutex_lock((pthread_mutex_t *)(v5 + 16));
    v8 = __CFRunLoopModeIsEmpty(a1, (uint64_t)v6) != 0;
    pthread_mutex_unlock(v7);
    CFRelease(v6);
  }
  else
  {
    v8 = 1;
  }
  pthread_mutex_unlock(v4);
  return v8;
}

const __CFString *_calculateUserNameForUID(uid_t a1)
{
  int v2;
  passwd *v3;
  NSObject *v4;
  const __CFString *v5;
  const __CFString *v6;

  v2 = 0;
  while (1)
  {
    *__error() = 0;
    v3 = getpwuid(a1);
    if (*__error() != 4)
      break;
LABEL_6:
    if (v3)
      goto LABEL_10;
  }
  if (!*__error())
    goto LABEL_9;
  if (v2 < 3)
  {
    ++v2;
    goto LABEL_6;
  }
  v4 = _CFPrefsDaemonLog();
  if (!os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
  {
LABEL_9:
    if (!v3)
      return 0;
    goto LABEL_10;
  }
  _calculateUserNameForUID_cold_1(a1, v4);
  if (!v3)
    return 0;
LABEL_10:
  if (v3->pw_name)
  {
    v5 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, v3->pw_name, 0x8000100u);
    v6 = _internString(v5);
    CFRelease(v5);
    return v6;
  }
  return 0;
}

void CFAttributedStringSetAttribute(CFMutableAttributedStringRef aStr, CFRange range, CFStringRef attrName, CFTypeRef value)
{
  CFIndex length;
  CFIndex location;
  __CFDictionary *ValueAtIndex;
  __CFDictionary *v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  const void *v15;
  const __CFAllocator *v16;
  __CFDictionary *AttributesDictionary;
  CFIndex v18;
  CFIndex v19;
  uint64_t v20;

  length = range.length;
  location = range.location;
  v20 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x3EuLL, (__objc2_class **)aStr))
  {
    -[__CFAttributedString addAttribute:value:range:](aStr, "addAttribute:value:range:", attrName, value, location, length);
    return;
  }
  if (length)
  {
    while (1)
    {
      v18 = 0;
      v19 = 0;
      ValueAtIndex = (__CFDictionary *)CFRunArrayGetValueAtIndex(*((_QWORD *)aStr + 3), location, &v18, 0);
      v10 = ValueAtIndex;
      v12 = v18;
      v11 = v19;
      v13 = v18 == location && v19 <= length;
      if (!v13)
        goto LABEL_12;
      if (CFGetRetainCount(ValueAtIndex) != 1)
        break;
      CFDictionarySetValue(v10, attrName, value);
LABEL_20:
      location += v19;
      length -= v19;
      if (!length)
        return;
    }
    v12 = v18;
    v11 = v19;
LABEL_12:
    v13 = v12 < location;
    v14 = v12 - location;
    if (v13)
    {
      v11 += v14;
      v18 = location;
      v19 = v11;
    }
    if (v11 > length)
      v19 = length;
    v15 = CFDictionaryGetValue(v10, attrName);
    if (!v15 || !CFEqual(v15, value))
    {
      v16 = CFGetAllocator(aStr);
      AttributesDictionary = __CFAttributedStringCreateAttributesDictionary(v16, v10);
      CFDictionarySetValue(AttributesDictionary, attrName, value);
      CFRunArrayReplace(*((_QWORD **)aStr + 3), v18, v19, AttributesDictionary, v19);
      CFRelease(AttributesDictionary);
    }
    goto LABEL_20;
  }
}

const __CFString *_internString(const __CFString *a1)
{
  const __CFString *Value;
  const __CFSet *Mutable;

  if (!a1)
    return 0;
  Value = CFSTR("kCFPreferencesAnyApplication");
  if (!CFEqual(a1, CFSTR("kCFPreferencesAnyApplication")))
  {
    if (((unint64_t)a1 & 0x8000000000000000) != 0 || CFGetRetainCount(a1) == 0xFFFFFFFFFFFFFFFLL)
    {
      return a1;
    }
    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)&_internString_lock);
      Mutable = (const __CFSet *)_internString_table;
      if (!_internString_table)
      {
        Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeSetCallBacks);
        _internString_table = (uint64_t)Mutable;
      }
      Value = (const __CFString *)CFSetGetValue(Mutable, a1);
      if (!Value)
      {
        CFSetAddValue((CFMutableSetRef)_internString_table, a1);
        Value = a1;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&_internString_lock);
      CFRetain(Value);
    }
  }
  return Value;
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  CFIndex v6;
  unint64_t v7;
  _UNKNOWN **v8;
  _BYTE *v9;
  unsigned int (*v10)(_QWORD, CFTypeRef);

  if (!cf)
    CFGetRetainCount_cold_1();
  if (((unint64_t)cf & 0x8000000000000000) != 0)
    return 0x7FFFFFFFFFFFFFFFLL;
  v3 = atomic_load((unint64_t *)cf + 1);
  if (CF_IS_OBJC((v3 >> 8) & 0x3FF, (__objc2_class **)cf))
    return objc_msgSend((id)cf, "retainCount");
  v4 = atomic_load((unint64_t *)cf + 1);
  if ((v4 & 0x800000) != 0)
  {
    v7 = (v4 >> 8) & 0x3FF;
    if (v7 > 0x47)
      v8 = (_UNKNOWN **)(__CFRuntimeClassTables[(v7 - 72) >> 6] + 8 * (((_DWORD)v7 - 72) & 0x3F));
    else
      v8 = &__CFRuntimeBuiltinClassTable + v7;
    v9 = *v8;
    v10 = (unsigned int (*)(_QWORD, CFTypeRef))*((_QWORD *)*v8 + 10);
    if (v10 && (*v9 & 8) != 0)
    {
      if (v4 > 0xFFFEFFFFFFFFFFFFLL)
        return v10(0, cf);
    }
    else
    {
      __break(1u);
    }
    CFGetRetainCount_cold_2();
  }
  v5 = atomic_load((unint64_t *)cf + 1);
  v6 = HIWORD(v5);
  if (v6)
    return v6;
  else
    return 0xFFFFFFFFFFFFFFFLL;
}

uint64_t __CFBinaryPlistWriteToStreamWithOptions(const void *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  return __CFBinaryPlistWriteOrPresize(a1, a2, a3, a4, 0, 0);
}

CFNumberRef CFNumberFormatterCreateNumberFromString(CFAllocatorRef allocator, CFNumberFormatterRef formatter, CFStringRef string, CFRange *rangep, CFOptionFlags options)
{
  char v5;
  const __CFAllocator *v9;
  uint64_t v10;
  unint64_t v11;
  const __CFNumber *v12;
  int ValueFromString;
  uint64_t v14;
  double v15;
  uint64_t v16;
  double v17;
  uint64_t v19;
  CFIndex length;
  CFIndex v21;
  CFNumberType v22;
  int v24;
  long double v25;
  uint64_t i;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  double v32;
  long double __y;
  double v34;
  CFRange rangepa;
  _QWORD valuePtr[3];

  v5 = options;
  v9 = allocator;
  valuePtr[2] = *MEMORY[0x1E0C80C00];
  if (!allocator)
  {
    v10 = _CFGetTSD(1u);
    if (v10)
      v9 = (const __CFAllocator *)v10;
    else
      v9 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  }
  v11 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v11 != 57)
    _CFAssertMismatchedTypeID(0x39uLL, v11);
  if (rangep)
  {
    rangepa = *rangep;
  }
  else
  {
    rangepa.location = 0;
    rangepa.length = CFStringGetLength(string);
  }
  v12 = (const __CFNumber *)*((_QWORD *)formatter + 8);
  *((_QWORD *)formatter + 8) = 0;
  ValueFromString = CFNumberFormatterGetValueFromString(formatter, string, &rangepa, kCFNumberSInt64Type, valuePtr);
  *((_QWORD *)formatter + 8) = v12;
  if (!ValueFromString)
    goto LABEL_29;
  if (v12)
  {
    v14 = valuePtr[0];
    v34 = 1.0;
    if (CFNumberGetValue(v12, kCFNumberFloat64Type, &v34))
      v15 = v34;
    else
      v15 = 1.0;
    if (v14 >= 0)
      v16 = v14;
    else
      v16 = -v14;
    v17 = fabs(v15);
    if (v17 > (double)v16 || v17 < 1.0)
      goto LABEL_29;
    if (modf(v15, &__y) == 0.0)
    {
      v19 = v14 / (uint64_t)v15;
      if (v14 % (uint64_t)v15)
        goto LABEL_29;
    }
    else if (v15 == -1.0)
    {
      v19 = -v14;
    }
    else
    {
      if (v15 == 1.0)
        goto LABEL_27;
      v32 = 0.0;
      v24 = -1;
      do
        v25 = scalbn(v15, ++v24);
      while (modf(v25, &v32) != 0.0);
      for (i = (uint64_t)v32; ; i *= 2)
      {
        v27 = i >= 0 ? i : -i;
        if (v27 >> 50)
          break;
        LOBYTE(v24) = v24 + 1;
      }
      if ((unint64_t)v16 >> 53)
      {
        v28 = 0;
        v29 = v14;
        do
        {
          v14 = v29 - i;
          v30 = v29 - i;
          v28 += 1 << v24;
          if (v30 < 0)
            v30 = -v30;
          v31 = (unint64_t)v30 >> 53;
          v29 = v14;
        }
        while (v31);
      }
      else
      {
        v28 = 0;
      }
      if (fmod((double)v14, v15) != 0.0)
        goto LABEL_29;
      v19 = v28 + (uint64_t)((double)v14 / v15);
    }
    valuePtr[0] = v19;
  }
LABEL_27:
  length = rangepa.length;
  v21 = CFStringGetLength(string);
  if ((v5 & 1) != 0 || length == v21)
  {
    if (rangep)
      *rangep = rangepa;
    v22 = kCFNumberSInt64Type;
    return CFNumberCreate(v9, v22, valuePtr);
  }
LABEL_29:
  if ((v5 & 1) != 0)
    return 0;
  v22 = kCFNumberFloat64Type;
  if (!CFNumberFormatterGetValueFromString(formatter, string, rangep, kCFNumberFloat64Type, valuePtr))
    return 0;
  return CFNumberCreate(v9, v22, valuePtr);
}

Boolean CFNumberFormatterGetValueFromString(CFNumberFormatterRef formatter, CFStringRef string, CFRange *rangep, CFNumberType numberType, void *valuePtr)
{
  unint64_t v8;
  const __CFString *CompressedString;
  const __CFString *v10;
  CFIndex Length;
  CFIndex location;
  const __CFString *v13;
  const __CFString *v14;
  _BOOL4 v15;
  const __CFString *v16;
  CFIndex v17;
  const UniChar *CharactersPtr;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  UChar *v22;
  const __CFNumber **v23;
  int v24;
  const void *v25;
  _BOOL8 v26;
  uint64_t v27;
  double v28;
  CFRange *v29;
  int v30;
  int v31;
  int v32;
  BOOL v33;
  CFCharacterSetRef Predefined;
  const __CFCharacterSet *v36;
  UniChar CharacterAtIndex;
  CFIndex v38;
  uint64_t v39;
  CFIndex v40;
  CFIndex v41;
  int v42;
  int v43;
  const __CFCharacterSet *v44;
  int v45;
  const void *v46;
  Boolean result;
  const __CFNumber *v48;
  int Value;
  double v50;
  float v51;
  uint64_t v52;
  uint64_t v53;
  CFNumberType v54;
  const __CFNumber **v55;
  _BYTE *v56;
  const __CFNumber *v57;
  CFRange *v58;
  CFStringRef theString;
  char *v60;
  uint64_t v61;
  _QWORD v62[130];
  CFRange v63;

  v56 = valuePtr;
  theString = string;
  v62[128] = *MEMORY[0x1E0C80C00];
  v8 = _CFGetNonObjCTypeID((unint64_t *)formatter);
  if (v8 != 57)
    _CFAssertMismatchedTypeID(0x39uLL, v8);
  if (*((_BYTE *)formatter + 80))
    CompressedString = __CFNumberFormatterCreateCompressedString(theString, 0, &rangep->location);
  else
    CompressedString = (const __CFString *)CFRetain(theString);
  v10 = CompressedString;
  if (*((_BYTE *)formatter + 80))
  {
    Length = CFStringGetLength(CompressedString);
    location = 0;
  }
  else
  {
    if (rangep)
    {
      location = rangep->location;
      Length = rangep->length;
    }
    else
    {
      Length = CFStringGetLength(CompressedString);
      location = 0;
    }
    Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
    if (Length >= 1)
    {
      v36 = Predefined;
      while (1)
      {
        CharacterAtIndex = CFStringGetCharacterAtIndex(v10, location);
        if (!CFCharacterSetIsCharacterMember(v36, CharacterAtIndex))
          break;
        ++location;
        v33 = Length-- <= 1;
        if (v33)
        {
          Length = 0;
          break;
        }
      }
    }
  }
  v13 = (const __CFString *)*((_QWORD *)formatter + 9);
  v58 = rangep;
  if (v13)
  {
    if (*((_BYTE *)formatter + 80))
      v14 = __CFNumberFormatterCreateCompressedString(v13, 0, 0);
    else
      v14 = (const __CFString *)CFRetain(v13);
    v16 = v14;
    v15 = CFStringCompare(v10, v14, 0) == kCFCompareEqualTo;
    CFRelease(v16);
  }
  else
  {
    v15 = 0;
  }
  if ((Length & ~(Length >> 63)) >= 1024)
    v17 = 1024;
  else
    v17 = Length & ~(Length >> 63);
  CharactersPtr = CFStringGetCharactersPtr(v10);
  v20 = MEMORY[0x1E0C80A78](CharactersPtr, v19);
  v22 = (UChar *)((char *)&v52 - v21);
  if (v20)
  {
    if (!*((_BYTE *)formatter + 80))
    {
      v22 = (UChar *)(v20 + 2 * location);
      v23 = (const __CFNumber **)((char *)formatter + 64);
      v57 = (const __CFNumber *)*((_QWORD *)formatter + 8);
LABEL_26:
      *v23 = 0;
      goto LABEL_27;
    }
    v23 = (const __CFNumber **)((char *)formatter + 64);
    v57 = (const __CFNumber *)*((_QWORD *)formatter + 8);
    *((_QWORD *)formatter + 8) = 0;
    v22 = (UChar *)v20;
LABEL_23:
    __CFNumberFormatterApplyPattern((uint64_t)formatter, *((CFStringRef *)formatter + 7));
    v25 = (const void *)*((_QWORD *)formatter + 8);
    if (v25)
      CFRelease(v25);
    goto LABEL_26;
  }
  if (!v17)
  {
    if (v10)
      CFRelease(v10);
    return 0;
  }
  v63.location = location;
  v63.length = v17;
  CFStringGetCharacters(v10, v63, (UniChar *)((char *)&v52 - v21));
  v23 = (const __CFNumber **)((char *)formatter + 64);
  v57 = (const __CFNumber *)*((_QWORD *)formatter + 8);
  v24 = *((unsigned __int8 *)formatter + 80);
  *((_QWORD *)formatter + 8) = 0;
  if (v24)
    goto LABEL_23;
LABEL_27:
  v26 = (unint64_t)numberType <= kCFNumberCFIndexType && ((1 << numberType) & 0x4F9E) != 0;
  __cficu_unum_setAttribute(*((_QWORD *)formatter + 2), 0, v26);
  v61 = 0;
  if (v15)
  {
    v27 = 0;
    HIDWORD(v61) = CFStringGetLength(v10);
    v28 = 0.0;
    v29 = v58;
  }
  else
  {
    v55 = v23;
    bzero(v62, 0x400uLL);
    v30 = __cficu_unum_parseDecimal(*((_QWORD *)formatter + 2), v22, v17, (unsigned int *)&v61 + 1, (const UInt8 *)v62, 1024, (int *)&v61);
    v31 = v30;
    v32 = v61;
    v33 = (int)v61 >= 1 || v30 <= 0;
    if (!v33 && v26)
    {
      v60 = 0;
      *__error() = 0;
      v27 = strtoll_l((const char *)v62, &v60, 10, 0);
      if (*__error() || *v60)
      {
        v32 = 3;
        LODWORD(v61) = 3;
      }
      else
      {
        v32 = v61;
      }
    }
    else
    {
      v27 = 0;
    }
    v29 = v58;
    v28 = 0.0;
    if (v32 > 0)
    {
      v23 = v55;
    }
    else
    {
      v33 = v31 < 1;
      v23 = v55;
      if (!v33)
      {
        v60 = 0;
        *__error() = 0;
        v28 = strtod_l((const char *)v62, &v60, 0);
        if (*__error() || *v60)
          LODWORD(v61) = 3;
      }
    }
  }
  if (*((_BYTE *)formatter + 80))
  {
    if (v29)
    {
      v38 = v29->location;
      if (SHIDWORD(v61) >= 1)
      {
        v53 = v27;
        v54 = numberType;
        v55 = v23;
        v39 = 0;
        v40 = v29->length + v38;
        while (v38 < v40)
        {
          v41 = v38;
          while (1)
          {
            v42 = v22[v39];
            v43 = CFStringGetCharacterAtIndex(theString, v41);
            v44 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
            v45 = CFCharacterSetIsCharacterMember(v44, v43) ? 32 : v43;
            v38 = v41 + 1;
            if (v42 == v45)
              break;
            ++v41;
            if (v40 == v38)
            {
              v38 = v40;
              numberType = v54;
              goto LABEL_74;
            }
          }
          ++v39;
          numberType = v54;
          if (v39 >= SHIDWORD(v61))
          {
            v38 = v41 + 1;
            break;
          }
        }
LABEL_74:
        v29 = v58;
        v23 = v55;
        v27 = v53;
      }
      v29->length = v38 - v29->location;
    }
    __CFNumberFormatterApplyPattern((uint64_t)formatter, *((CFStringRef *)formatter + 5));
    v46 = (const void *)*((_QWORD *)formatter + 8);
    if (v46)
      CFRelease(v46);
  }
  else if (v29)
  {
    v29->length = location - v29->location + SHIDWORD(v61);
  }
  *v23 = v57;
  CFRelease(v10);
  if ((int)v61 > 0)
    return 0;
  v48 = *v23;
  if (*v23)
  {
    v62[0] = 0x3FF0000000000000;
    Value = CFNumberGetValue(v48, kCFNumberFloat64Type, v62);
    v50 = *(double *)v62;
    if (!Value)
      v50 = 1.0;
    v27 = (uint64_t)((double)v27 / v50);
    v28 = v28 / v50;
  }
  switch(numberType)
  {
    case kCFNumberSInt8Type:
    case kCFNumberCharType:
      if (v27 != (char)v27)
        return 0;
      *v56 = v27;
      return 1;
    case kCFNumberSInt16Type:
    case kCFNumberShortType:
      if (v27 != (__int16)v27)
        return 0;
      *(_WORD *)v56 = v27;
      return 1;
    case kCFNumberSInt32Type:
    case kCFNumberIntType:
      if (v27 != (int)v27)
        return 0;
      *(_DWORD *)v56 = v27;
      return 1;
    case kCFNumberSInt64Type:
    case kCFNumberLongType:
    case kCFNumberLongLongType:
    case kCFNumberCFIndexType:
      *(_QWORD *)v56 = v27;
      return 1;
    case kCFNumberFloat32Type:
    case kCFNumberFloatType:
      result = 0;
      if (v28 < -3.40282347e38 || v28 > 3.40282347e38)
        return result;
      v51 = v28;
      *(float *)v56 = v51;
      break;
    case kCFNumberFloat64Type:
    case kCFNumberDoubleType:
      result = 0;
      if (v28 < -1.79769313e308 || v28 > 1.79769313e308)
        return result;
      *(double *)v56 = v28;
      break;
    default:
      return 0;
  }
  return 1;
}

uint64_t __cficu_unum_parseDecimal(uint64_t a1, UChar *a2, uint64_t a3, unsigned int *a4, const UInt8 *a5, uint64_t a6, int *a7)
{
  CFStringRef v14;
  uint64_t v15;
  CFStringRef v16;
  const void *v17;
  CFStringRef v18;
  CFStringRef v19;
  CFStringRef v21;
  const void *v22;

  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if ((___CFICULoggingEnabled_loggingEnabled & 1) == 0)
    return unum_parseDecimal();
  v14 = ___CFICUCreateArgumentForParsePosition(a4);
  v15 = unum_parseDecimal();
  v16 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
  v17 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a7);
  v18 = ___CFICUCreateErrorStringWithComment(a7, 0);
  if (*a7 <= 0)
    v19 = CFStringCreateWithBytes(0, a5, (int)v15, 0x8000100u, 0);
  else
    v19 = 0;
  v21 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
  v22 = (const void *)___CFICUCreateVariableName("result");
  ___CFICULogWithArguments(1, CFSTR("char %@[%d];"), v22, a6);
  ___CFICULogWithArguments(1, CFSTR("unum_parseDecimal(%@, %@, %d, %@, %@, %d, &%@); // %d %@ %@"),
    v16,
    v21,
    a3,
    v14,
    v22,
    a6,
    v17,
    v15,
    v19,
    v18);
  CFRelease(v16);
  CFRelease(v17);
  CFRelease(v22);
  CFRelease(v14);
  if (v19)
    CFRelease(v19);
  CFRelease(v21);
  CFRelease(v18);
  return v15;
}

uint64_t __CFStringFormatLocalizedNumber(__CFString *a1, const void *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  CFLocaleRef Locale;
  uint64_t *v14;
  CFLocaleRef v15;
  CFLocaleRef v16;
  __CFNumberFormatter *v17;
  __CFNumberFormatter *v18;
  __CFNumberFormatter *v19;
  const __CFNumber *v20;
  const __CFNumber *v21;
  const __CFString *Format;
  const __CFString *Copy;
  CFMutableStringRef Mutable;
  double v25;
  double v26;
  CFNumberRef v27;
  CFNumberRef v28;
  CFNumberRef v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  const __CFString *v33;
  int v34;
  int CharacterAtIndex;
  __CFString *MutableCopy;
  int v37;
  CFNumberRef v38;
  int v39;
  int *v40;
  CFNumberRef v41;
  int v42;
  const __CFString *v43;
  CFNumberRef v44;
  int v45;
  _QWORD *v46;
  __CFNumberFormatter *v47;
  CFNumberType v48;
  uint64_t v49;
  const __CFString *StringWithValue;
  uint64_t v51;
  CFIndex v52;
  __CFString *v53;
  uint64_t v55;
  CFIndex v56;
  _QWORD v57[2];
  int v58;
  int v59;
  int valuePtr;
  int v61;
  _DWORD length[3];
  CFRange v63;

  *(_QWORD *)&length[1] = *MEMORY[0x1E0C80C00];
  length[0] = a5;
  if (__CFStringFormatLocalizedNumber_disableLocalizedFormatting != -1)
  {
    if (!__CFStringFormatLocalizedNumber_disableLocalizedFormatting)
      goto LABEL_5;
    return 0;
  }
  __CFStringFormatLocalizedNumber_disableLocalizedFormatting = getenv("CFStringDisableLocalizedNumberFormatting") != 0;
  if (__CFStringFormatLocalizedNumber_disableLocalizedFormatting)
    return 0;
LABEL_5:
  os_unfair_lock_lock((os_unfair_lock_t)&__CFStringFormatLocalizedNumber_formatterLock);
  switch(*(_BYTE *)(a4 + 28))
  {
    case 1:
    case 4:
      if (!__CFStringFormatLocalizedNumber_decimalFormatter)
        goto LABEL_17;
      Locale = CFNumberFormatterGetLocale((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_decimalFormatter);
      if (CFEqual(Locale, a2))
      {
        v14 = &__CFStringFormatLocalizedNumber_decimalFormatter;
        goto LABEL_27;
      }
      if (__CFStringFormatLocalizedNumber_decimalFormatter)
        CFRelease((CFTypeRef)__CFStringFormatLocalizedNumber_decimalFormatter);
LABEL_17:
      v17 = CFNumberFormatterCreate(0, (CFLocaleRef)a2, kCFNumberFormatterDecimalStyle);
      __CFStringFormatLocalizedNumber_decimalFormatter = (uint64_t)v17;
      if (!v17)
        goto LABEL_46;
      goto LABEL_28;
    case 2:
      if (!__CFStringFormatLocalizedNumber_scientificFormatter)
        goto LABEL_21;
      v15 = CFNumberFormatterGetLocale((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_scientificFormatter);
      if (CFEqual(v15, a2))
      {
        v14 = &__CFStringFormatLocalizedNumber_scientificFormatter;
        goto LABEL_27;
      }
      if (__CFStringFormatLocalizedNumber_scientificFormatter)
        CFRelease((CFTypeRef)__CFStringFormatLocalizedNumber_scientificFormatter);
LABEL_21:
      v18 = CFNumberFormatterCreate(0, (CFLocaleRef)a2, kCFNumberFormatterScientificStyle);
      __CFStringFormatLocalizedNumber_scientificFormatter = (uint64_t)v18;
      if (!v18)
        goto LABEL_46;
      v14 = &__CFStringFormatLocalizedNumber_scientificFormatter;
      CFNumberFormatterSetFormat(v18, CFSTR("#E+00"));
      CFNumberFormatterSetProperty((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_scientificFormatter, CFSTR("kCFNumberFormatterUseSignificantDigitsKey"), &__kCFBooleanTrue);
      goto LABEL_27;
    case 3:
      if (!__CFStringFormatLocalizedNumber_gFormatter)
        goto LABEL_25;
      v16 = CFNumberFormatterGetLocale((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_gFormatter);
      if (CFEqual(v16, a2))
      {
        v14 = &__CFStringFormatLocalizedNumber_gFormatter;
      }
      else
      {
        if (__CFStringFormatLocalizedNumber_gFormatter)
          CFRelease((CFTypeRef)__CFStringFormatLocalizedNumber_gFormatter);
LABEL_25:
        v19 = CFNumberFormatterCreate(0, (CFLocaleRef)a2, kCFNumberFormatterDecimalStyle);
        __CFStringFormatLocalizedNumber_gFormatter = (uint64_t)v19;
        if (!v19)
          goto LABEL_46;
        v14 = &__CFStringFormatLocalizedNumber_gFormatter;
        v20 = (const __CFNumber *)CFNumberFormatterCopyProperty(v19, CFSTR("kCFNumberFormatterGroupingSizeKey"));
        CFNumberGetValue(v20, kCFNumberSInt32Type, &__CFStringFormatLocalizedNumber_groupingSize);
        CFRelease(v20);
        v21 = (const __CFNumber *)CFNumberFormatterCopyProperty((CFNumberFormatterRef)__CFStringFormatLocalizedNumber_gFormatter, CFSTR("kCFNumberFormatterSecondaryGroupingSizeKey"));
        CFNumberGetValue(v21, kCFNumberSInt32Type, &__CFStringFormatLocalizedNumber_secondaryGroupingSize);
        CFRelease(v21);
      }
LABEL_27:
      v17 = (__CFNumberFormatter *)*v14;
      if (!*v14)
      {
LABEL_46:
        os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringFormatLocalizedNumber_formatterLock);
        return 0;
      }
LABEL_28:
      Format = CFNumberFormatterGetFormat(v17);
      Copy = CFStringCreateCopy(0, Format);
      if (!a7)
      {
        if (*(_WORD *)(a4 + 2) == 33)
          a6 = 0;
        else
          a6 = 6;
      }
      v61 = a6;
      if (*(_BYTE *)(a4 + 28) == 3)
      {
        if (!a6)
        {
          a6 = 1;
          v61 = 1;
        }
        Mutable = CFStringCreateMutable(0, 0);
        CFStringAppendCString(Mutable, "@", 0x600u);
        CFStringPad(Mutable, CFSTR("#"), a6, 0);
        v25 = *(double *)(a3 + 16 * *(char *)(a4 + 24) + 8);
        v26 = __exp10((double)a6);
        if (v25 > 0.0 && (v25 < 0.0001 || v25 > v26) || v25 < 0.0 && (v25 > -0.0001 || v25 < -v26))
        {
          CFStringAppendCString(Mutable, "E+00", 0x600u);
        }
        else if (a6 > __CFStringFormatLocalizedNumber_groupingSize)
        {
          if (__CFStringFormatLocalizedNumber_groupingSize)
          {
            CFStringInsert(Mutable, a6 - __CFStringFormatLocalizedNumber_groupingSize, CFSTR(","));
            if (__CFStringFormatLocalizedNumber_secondaryGroupingSize)
            {
              if (a6 > __CFStringFormatLocalizedNumber_groupingSize
                      + __CFStringFormatLocalizedNumber_secondaryGroupingSize)
                CFStringInsert(Mutable, a6- (__CFStringFormatLocalizedNumber_groupingSize+ __CFStringFormatLocalizedNumber_secondaryGroupingSize), CFSTR(","));
            }
          }
        }
        CFNumberFormatterSetFormat(v17, Mutable);
        CFRelease(Mutable);
      }
      valuePtr = 0;
      v27 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
      CFNumberFormatterSetProperty(v17, CFSTR("kCFNumberFormatterFormatWidthKey"), v27);
      v28 = CFNumberCreate(0, kCFNumberSInt32Type, &v61);
      CFNumberFormatterSetProperty(v17, CFSTR("kCFNumberFormatterMaxFractionDigitsKey"), v28);
      if (*(_WORD *)(a4 + 2) == 34)
        v29 = v28;
      else
        v29 = v27;
      CFNumberFormatterSetProperty(v17, CFSTR("kCFNumberFormatterMinFractionDigitsKey"), v29);
      CFRelease(v28);
      CFRelease(v27);
      v30 = *(char *)(a4 + 24);
      v31 = *(__int16 *)(a3 + 16 * v30);
      if (v31 == 34)
      {
        LOBYTE(v32) = *(double *)(a3 + 16 * v30 + 8) < 0.0;
      }
      else
      {
        LOBYTE(v32) = 0;
        if (v31 == 33)
          v32 = *(_QWORD *)(a3 + 16 * v30 + 8) >> 63;
      }
      v33 = CFNumberFormatterGetFormat(v17);
      v34 = *(_DWORD *)(a4 + 20);
      CharacterAtIndex = CFStringGetCharacterAtIndex(v33, 0);
      if ((v32 & 1) != 0 || (v34 & 4) == 0)
      {
        if (CharacterAtIndex == 43)
        {
          v63.length = CFStringGetLength(v33) - 1;
          v63.location = 1;
          MutableCopy = (__CFString *)CFStringCreateWithSubstring(0, v33, v63);
          goto LABEL_62;
        }
      }
      else if (CharacterAtIndex != 43)
      {
        MutableCopy = CFStringCreateMutableCopy(0, 0, CFSTR("+"));
        CFStringAppend(MutableCopy, v33);
LABEL_62:
        CFNumberFormatterSetFormat(v17, MutableCopy);
        CFRelease(MutableCopy);
      }
      v37 = *(_BYTE *)(a4 + 20) & 1;
      if (a7 && *(_WORD *)(a4 + 2) == 33)
      {
        v38 = CFNumberCreate(0, kCFNumberSInt32Type, &v61);
        CFNumberFormatterSetProperty(v17, CFSTR("kCFNumberFormatterFormatWidthKey"), v38);
      }
      else
      {
        v38 = CFNumberCreate(0, kCFNumberSInt32Type, length);
        CFNumberFormatterSetProperty(v17, CFSTR("kCFNumberFormatterFormatWidthKey"), v38);
        if (!a7)
          goto LABEL_69;
      }
      if (*(_WORD *)(a4 + 2) == 33)
        v37 = 1;
LABEL_69:
      if ((*(_DWORD *)(a4 + 20) & 2) != 0)
        v39 = 3;
      else
        v39 = v37;
      v58 = 0;
      v59 = v39;
      CFNumberGetValue(v38, kCFNumberSInt32Type, &v58);
      if (v37 && v58 >= 1 && v59 && *(_WORD *)(a4 + 2) != 34)
        CFNumberFormatterSetProperty(v17, CFSTR("kCFNumberFormatterMinIntegerDigitsKey"), v38);
      CFRelease(v38);
      if (a7 && *(_WORD *)(a4 + 2) == 33)
      {
        LODWORD(v57[0]) = 1;
        v40 = (int *)v57;
      }
      else
      {
        v40 = &v59;
      }
      v41 = CFNumberCreate(0, kCFNumberSInt32Type, v40);
      CFNumberFormatterSetProperty(v17, CFSTR("kCFNumberFormatterPaddingPositionKey"), v41);
      CFRelease(v41);
      if (v37)
      {
        v42 = *(unsigned __int8 *)(a4 + 28);
        if (v42 != 3)
          goto LABEL_86;
        v43 = CFSTR("0");
      }
      else
      {
        v43 = CFSTR(" ");
      }
      CFNumberFormatterSetProperty(v17, CFSTR("kCFNumberFormatterPaddingCharacterKey"), v43);
      v42 = *(unsigned __int8 *)(a4 + 28);
LABEL_86:
      if (v42 == 2)
      {
        ++v61;
        v44 = CFNumberCreate(0, kCFNumberSInt32Type, &v61);
        CFNumberFormatterSetProperty(v17, CFSTR("kCFNumberFormatterMinSignificantDigitsKey"), v44);
        CFNumberFormatterSetProperty(v17, CFSTR("kCFNumberFormatterMaxSignificantDigitsKey"), v44);
        CFRelease(v44);
      }
      v45 = *(__int16 *)(a4 + 2);
      if (v45 == 34)
      {
        v49 = a3 + 16 * *(char *)(a4 + 24);
        if (*(_WORD *)(v49 + 2) == 5)
        {
          v57[0] = *(_QWORD *)(v49 + 8);
          v46 = v57;
        }
        else
        {
          v46 = (_QWORD *)(v49 + 8);
        }
        v47 = v17;
        v48 = kCFNumberDoubleType;
      }
      else
      {
        if (v45 != 33)
        {
          StringWithValue = 0;
          goto LABEL_99;
        }
        if ((*(_BYTE *)(a4 + 28) & 4) != 0)
        {
          v51 = *(_QWORD *)(a3 + 16 * *(char *)(a4 + 24) + 8);
          v57[0] = 0;
          v57[1] = v51;
          v46 = v57;
          v47 = v17;
          v48 = kCFNumberMaxType|kCFNumberSInt8Type;
        }
        else
        {
          v46 = (_QWORD *)(a3 + 16 * *(char *)(a4 + 24) + 8);
          v47 = v17;
          v48 = kCFNumberSInt64Type;
        }
      }
      StringWithValue = CFNumberFormatterCreateStringWithValue(0, v47, v48, v46);
LABEL_99:
      CFNumberFormatterSetFormat(v17, Copy);
      CFRelease(Copy);
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringFormatLocalizedNumber_formatterLock);
      if (!StringWithValue)
        return 0;
      if (a7)
      {
        if (*(_WORD *)(a4 + 2) == 33)
        {
          v52 = CFStringGetLength(StringWithValue);
          if (v52 < length[0])
          {
            if (v59 == 3)
            {
              v53 = CFStringCreateMutableCopy(0, 0, StringWithValue);
              CFStringPad(v53, CFSTR(" "), length[0], 0);
            }
            else
            {
              v53 = CFStringCreateMutable(0, 0);
              v55 = length[0];
              v56 = CFStringGetLength(StringWithValue);
              CFStringPad(v53, CFSTR(" "), v55 - v56, 0);
              CFStringAppend(v53, StringWithValue);
            }
            CFRelease(StringWithValue);
            StringWithValue = v53;
          }
        }
      }
      CFStringAppend(a1, StringWithValue);
      CFRelease(StringWithValue);
      return 1;
    default:
      __CFStringFormatLocalizedNumber_cold_1();
  }
}

