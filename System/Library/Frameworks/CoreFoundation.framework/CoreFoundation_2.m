void sub_182BD03EC(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
  JUMPOUT(0x182BD03E4);
}

uint64_t _CFURLComponentsSetPercentEncodedHost(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setPercentEncodedHost:", a2);
  return 1;
}

void sub_182BD0418(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
  JUMPOUT(0x182BD0410);
}

uint64_t _CFURLComponentsSetPercentEncodedPath(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setPercentEncodedPath:", a2);
  return 1;
}

void sub_182BD0444(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
  JUMPOUT(0x182BD043CLL);
}

uint64_t _CFURLComponentsSetPercentEncodedFragment(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setPercentEncodedFragment:", a2);
  return 1;
}

void sub_182BD0470(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
  JUMPOUT(0x182BD0468);
}

uint64_t _CFURLComponentsSetEncodedHost(void *a1, uint64_t a2)
{
  objc_msgSend(a1, "setEncodedHost:", a2);
  return 1;
}

void sub_182BD049C(void *a1)
{
  objc_begin_catch(a1);
  objc_end_catch();
  JUMPOUT(0x182BD0494);
}

uint64_t _CFURLComponentsGetRangeOfScheme(void *a1)
{
  uint64_t result;

  result = objc_msgSend(a1, "rangeOfScheme");
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    return -1;
  return result;
}

uint64_t _CFURLComponentsGetRangeOfUser(void *a1)
{
  uint64_t result;

  result = objc_msgSend(a1, "rangeOfUser");
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    return -1;
  return result;
}

uint64_t _CFURLComponentsGetRangeOfPassword(void *a1)
{
  uint64_t result;

  result = objc_msgSend(a1, "rangeOfPassword");
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    return -1;
  return result;
}

uint64_t _CFURLComponentsGetRangeOfHost(void *a1)
{
  uint64_t result;

  result = objc_msgSend(a1, "rangeOfHost");
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    return -1;
  return result;
}

uint64_t _CFURLComponentsGetRangeOfPort(void *a1)
{
  uint64_t result;

  result = objc_msgSend(a1, "rangeOfPort");
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    return -1;
  return result;
}

uint64_t _CFURLComponentsGetRangeOfFragment(void *a1)
{
  uint64_t result;

  result = objc_msgSend(a1, "rangeOfFragment");
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    return -1;
  return result;
}

CFArrayRef __CFURLComponentsCopyQueryItems(void *a1, int a2)
{
  void *v2;
  void *v3;
  __CFArray *Mutable;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;
  void *v10;
  CFIndex v11;
  CFDictionaryRef v12;
  __int128 v13;
  void *values[2];
  void *keys[2];
  _BYTE v16[128];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a2)
    v2 = (void *)objc_msgSend(a1, "percentEncodedQueryItems");
  else
    v2 = (void *)objc_msgSend(a1, "queryItems");
  v3 = v2;
  if (!v2)
    return 0;
  if (objc_msgSend(v2, "count") == 1)
    return CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeArrayCallBacks);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v6 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v17, v16, 16);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)v18;
    v13 = xmmword_1E12E6A10;
    do
    {
      for (i = 0; i != v7; ++i)
      {
        if (*(_QWORD *)v18 != v8)
          objc_enumerationMutation(v3);
        v10 = *(void **)(*((_QWORD *)&v17 + 1) + 8 * i);
        values[0] = (void *)objc_msgSend(v10, "name", v13, 0, 0, v13);
        values[1] = (void *)objc_msgSend(v10, "value");
        if (objc_msgSend(v10, "value"))
          v11 = 2;
        else
          v11 = 1;
        v12 = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)keys, (const void **)values, v11, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFArrayAppendValue(Mutable, v12);
      }
      v7 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v17, v16, 16);
    }
    while (v7);
  }
  return Mutable;
}

CFIndex __CFURLComponentsSetQueryItems(void *a1, CFArrayRef theArray, const __CFArray *a3)
{
  void *v3;
  CFIndex Count;
  CFIndex result;
  NSArray *v8;
  CFIndex v9;
  const __CFString *ValueAtIndex;
  __objc2_class **v11;
  CFTypeID v12;
  CFTypeID v13;
  __objc2_class **v14;
  const __CFString *v15;

  v3 = a1;
  if (!theArray)
  {
    v15 = 0;
    return objc_msgSend(a1, "setQuery:", v15);
  }
  if (!CFArrayGetCount(theArray))
  {
    v15 = &stru_1E1337B18;
    a1 = v3;
    return objc_msgSend(a1, "setQuery:", v15);
  }
  Count = CFArrayGetCount(theArray);
  result = CFArrayGetCount(a3);
  if (Count == result)
  {
    v8 = +[NSArray array](NSMutableArray, "array");
    if (CFArrayGetCount(theArray) >= 1)
    {
      v9 = 0;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v9);
        v11 = (__objc2_class **)CFArrayGetValueAtIndex(a3, v9);
        if (ValueAtIndex == (const __CFString *)&__kCFNull)
        {
          ValueAtIndex = &stru_1E1337B18;
        }
        else
        {
          v12 = CFGetTypeID(ValueAtIndex);
          if (v12 != CFStringGetTypeID())
            ValueAtIndex = &stru_1E1337B18;
        }
        if (v11 == &__kCFNull)
        {
          v14 = 0;
        }
        else
        {
          v13 = CFGetTypeID(v11);
          if (v13 == CFStringGetTypeID())
            v14 = v11;
          else
            v14 = 0;
        }
        -[NSArray addObject:](v8, "addObject:", +[NSURLQueryItem queryItemWithName:value:](&off_1EDCDCC08, "queryItemWithName:value:", ValueAtIndex, v14));
        ++v9;
      }
      while (CFArrayGetCount(theArray) > v9);
    }
    return objc_msgSend(v3, "setQueryItems:", v8);
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t _CFURLComponentsMatchURLInString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  result = +[NSURLComponents _matchWithString:requiredComponents:defaultValues:urlPtr:](&off_1EDCDC9E8, "_matchWithString:requiredComponents:defaultValues:urlPtr:", a1, a2, a3, a4);
  if (result == 0x7FFFFFFFFFFFFFFFLL)
    return -1;
  return result;
}

unint64_t _CFSocketStreamSetAuthenticatesServerCertificateDefault(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 vars0;

  return CFLog(3, (uint64_t)CFSTR("_CFSocketStreamSetAuthenticatesServerCertificateDefault(): This call has been deprecated.  Use SetProperty(_kCFStreamPropertySocketSecurityAuthenticatesServerCertificate, kCFBooleanTrue/False)\n"), a3, a4, a5, a6, a7, a8, vars0);
}

uint64_t _CFSocketStreamGetAuthenticatesServerCertificateDefault(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 vars0;

  CFLog(3, (uint64_t)CFSTR("_CFSocketStreamGetAuthenticatesServerCertificateDefault(): This call has been removed as a security risk.  Use security properties on individual streams instead.\n"), a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t _CFSocketStreamPairSetAuthenticatesServerCertificate(__CFReadStream *a1, CFWriteStreamRef stream, int a3)
{
  const CFBooleanRef *v3;
  CFBooleanRef v4;

  v3 = &kCFBooleanFalse;
  if (a3)
    v3 = &kCFBooleanTrue;
  v4 = *v3;
  if (a1)
    return CFReadStreamSetProperty(a1, CFSTR("_kCFStreamPropertySocketSecurityAuthenticatesServerCertificate"), v4);
  else
    return CFWriteStreamSetProperty(stream, CFSTR("_kCFStreamPropertySocketSecurityAuthenticatesServerCertificate"), v4);
}

void CFStreamCreatePairWithSocket(CFAllocatorRef alloc, CFSocketNativeHandle sock, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
  createPair((uint64_t)alloc, 0, 0, *(uint64_t *)&sock, 0, readStream, writeStream);
}

void CFStreamCreatePairWithPeerSocketSignature(CFAllocatorRef alloc, const CFSocketSignature *signature, CFReadStreamRef *readStream, CFWriteStreamRef *writeStream)
{
  createPair((uint64_t)alloc, 0, 0, 0, (uint64_t)signature, readStream, writeStream);
}

uint64_t _CFStreamErrorFromError(__CFError *a1)
{
  uint64_t (*v2)(_QWORD);
  uint64_t v3;
  CFErrorDomain Domain;

  pthread_mutex_lock(&CFNetworkSupport);
  if ((dword_1EDCCE510 & 1) == 0)
    initializeCFNetworkSupport();
  v2 = off_1EDCCE528;
  pthread_mutex_unlock(&CFNetworkSupport);
  if (v2)
    return off_1EDCCE528(a1);
  Domain = CFErrorGetDomain(a1);
  if (CFEqual(Domain, CFSTR("NSPOSIXErrorDomain")))
  {
    v3 = 1;
  }
  else if (CFEqual(Domain, CFSTR("NSOSStatusErrorDomain")))
  {
    v3 = 2;
  }
  else if (CFEqual(Domain, CFSTR("NSMachErrorDomain")))
  {
    v3 = 11;
  }
  else
  {
    v3 = -1;
  }
  CFErrorGetCode(a1);
  return v3;
}

CFErrorRef _CFStreamCreateErrorFromStreamError(const __CFAllocator *a1, int *a2)
{
  uint64_t (*v4)(_QWORD, _QWORD);
  CFIndex v6;
  CFErrorDomain *v7;
  const __CFDictionary *v8;
  CFErrorRef v9;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  pthread_mutex_lock(&CFNetworkSupport);
  if ((dword_1EDCCE510 & 1) == 0)
    initializeCFNetworkSupport();
  v4 = off_1EDCCE520;
  pthread_mutex_unlock(&CFNetworkSupport);
  if (v4)
    return (CFErrorRef)off_1EDCCE520(a1, a2);
  if (*(_QWORD *)a2 == 2)
  {
    v6 = a2[2];
    v7 = (CFErrorDomain *)&kCFErrorDomainOSStatus;
    return CFErrorCreate(a1, *v7, v6, 0);
  }
  if (*(_QWORD *)a2 == 1)
  {
    v6 = a2[2];
    v7 = (CFErrorDomain *)&kCFErrorDomainPOSIX;
    return CFErrorCreate(a1, *v7, v6, 0);
  }
  keys[0] = CFSTR("CFStreamErrorDomainKey");
  values = CFNumberCreate(a1, kCFNumberCFIndexType, a2);
  v8 = CFDictionaryCreate(a1, (const void **)keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v9 = CFErrorCreate(a1, CFSTR("BogusCFStreamErrorCompatibilityDomain"), a2[2], v8);
  CFRelease(values);
  CFRelease(v8);
  return v9;
}

void __CFSortIndexesN(char *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int64_t v11;
  uint64_t v12;
  int64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  const void **v17;
  size_t v18;
  size_t v19;
  void **v20;
  int64_t v21;
  int64_t v22;
  int64_t v23;
  unint64_t v24;
  char *v25;
  void *v26;
  uint64_t v27;
  size_t v28;
  size_t v29;
  int64_t v30;
  _QWORD v31[10];
  _QWORD v32[10];
  _QWORD block[11];

  block[10] = *MEMORY[0x1E0C80C00];
  v6 = (a2 + a3 - 1) / a3;
  v8 = v6 + 15;
  v7 = v6 < -15;
  v9 = v6 + 30;
  if (!v7)
    v9 = v8;
  v10 = v9 >> 4;
  v11 = v9 & 0xFFFFFFFFFFFFFFF0;
  v12 = (v9 & 0xFFFFFFFFFFFFFFF0) + a2;
  v13 = (v12 - 1) / v11;
  v14 = v12 - v11 * v13;
  MEMORY[0x1E0C80A78](a1, a2);
  v17 = (const void **)((char *)&v27 - v16);
  if (v15 >= 0x200)
    v18 = 512;
  else
    v18 = v15;
  bzero((char *)&v27 - v16, v18);
  v19 = v10 << 7;
  if (v13 >= 1)
  {
    v20 = (void **)v17;
    v21 = v13;
    do
    {
      *v20++ = malloc_type_malloc(v19, 0x100004000313F17uLL);
      --v21;
    }
    while (v21);
  }
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ____CFSortIndexesN_block_invoke;
  block[3] = &unk_1E12E6B18;
  block[6] = v11;
  block[7] = v14;
  block[8] = a1;
  block[9] = v17;
  block[4] = a4;
  block[5] = v13;
  dispatch_apply(v13, 0, block);
  if (v13 >= 0)
    v22 = v13;
  else
    v22 = v13 + 1;
  if (v13 - 1 >= 0)
    v23 = v13 - 1;
  else
    v23 = v13;
  if (v13 >= 1)
  {
    v29 = v22 & 0xFFFFFFFFFFFFFFFELL;
    v28 = v23 & 0xFFFFFFFFFFFFFFFELL;
    v24 = (unint64_t)(v13 + 1) >> 1;
    v30 = v13 - 1;
    v25 = &a1[8 * v11 * (v13 - 1)];
    do
    {
      v32[0] = MEMORY[0x1E0C809B0];
      v32[1] = 0x40000000;
      v32[2] = ____CFSortIndexesN_block_invoke_2;
      v32[3] = &unk_1E12E6B40;
      v32[6] = v11;
      v32[7] = v13;
      v32[8] = v14;
      v32[9] = v17;
      v32[4] = a4;
      v32[5] = a1;
      dispatch_apply(v29, 0, v32);
      if ((v13 & 1) != 0)
        memmove((void *)v17[v30], v25, 8 * v14);
      v31[0] = MEMORY[0x1E0C809B0];
      v31[1] = 0x40000000;
      v31[2] = ____CFSortIndexesN_block_invoke_3;
      v31[3] = &unk_1E12E6B68;
      v31[6] = v13;
      v31[7] = v14;
      v31[8] = v11;
      v31[9] = a1;
      v31[5] = v17;
      v31[4] = a4;
      dispatch_apply(v28, 0, v31);
      memmove(a1, *v17, v19);
      if ((v13 & 1) == 0)
        memmove(v25, v17[v30], 8 * v14);
      --v24;
    }
    while (v24);
    do
    {
      v26 = (void *)*v17++;
      free(v26);
      --v13;
    }
    while (v13);
  }
}

uint64_t *__CFSortIndexesNMerge(uint64_t *result, uint64_t a2, uint64_t *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t *v11;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;

  v11 = a3;
  v13 = result;
  if (a4 + a2 >= 17)
  {
    result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a7 + 16))(a7, result[a2 - 1], *a3);
    if ((uint64_t)result <= 0)
    {
      if (a6)
        v30 = v11;
      else
        v30 = v13;
      if (a6)
        v31 = a4;
      else
        v31 = a2;
      return (uint64_t *)memmove(a5, v30, 8 * v31);
    }
  }
  if (!a6)
  {
    if (a2 < 1)
      return result;
    v22 = &v13[a2];
    v23 = &v11[a4];
    v24 = &a5[a2];
    while (1)
    {
      if (v23 <= v11)
      {
        v28 = *v13++;
        v27 = v28;
      }
      else
      {
        if (v22 > v13)
        {
          v25 = *v13;
          v26 = *v11;
          result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a7 + 16))(a7, *v13, *v11);
          if ((uint64_t)result <= 0)
          {
            *a5 = v25;
            ++v13;
          }
          else
          {
            *a5 = v26;
            ++v11;
          }
          goto LABEL_25;
        }
        v29 = *v11++;
        v27 = v29;
      }
      *a5 = v27;
LABEL_25:
      if (++a5 >= v24)
        return result;
    }
  }
  if (a4 >= 1)
  {
    v14 = &a5[a4];
    v15 = &v11[a4 - 1];
    v16 = &v13[a2 - 1];
    do
    {
      if (v15 >= v11)
      {
        if (v16 >= v13)
        {
          v20 = *v16;
          v21 = *v15;
          result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a7 + 16))(a7, *v16, *v15);
          if ((uint64_t)result <= 0)
          {
            *(v14 - 1) = v21;
            --v15;
          }
          else
          {
            *(v14 - 1) = v20;
            --v16;
          }
          goto LABEL_11;
        }
        v19 = *--v15;
        v17 = v19;
      }
      else
      {
        v18 = *--v16;
        v17 = v18;
      }
      *(v14 - 1) = v17;
LABEL_11:
      --v14;
    }
    while (v14 > a5);
  }
  return result;
}

uint64_t __CFStorageGetCapacity(uint64_t a1)
{
  uint64_t NodeCapacity;
  int v3;

  NodeCapacity = __CFStorageGetNodeCapacity(a1 + 144);
  v3 = *(_DWORD *)(a1 + 24);
  if (v3 == -1)
    return NodeCapacity / *(_QWORD *)(a1 + 16);
  else
    return NodeCapacity >> v3;
}

uint64_t __CFStorageGetNodeCapacity(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t NodeCapacity;
  uint64_t v4;
  uint64_t v5;

  if (a1)
  {
    v1 = a1;
    v2 = 0;
    while (!*(_BYTE *)(v1 + 13))
    {
      NodeCapacity = __CFStorageGetNodeCapacity(*(_QWORD *)(v1 + 16));
      v4 = __CFStorageGetNodeCapacity(*(_QWORD *)(v1 + 24));
      v1 = *(_QWORD *)(v1 + 32);
      v2 += NodeCapacity + v4;
      if (!v1)
        goto LABEL_7;
    }
    v5 = *(_QWORD *)(v1 + 16);
  }
  else
  {
    v2 = 0;
LABEL_7:
    v5 = 0;
  }
  return v5 + v2;
}

uint64_t __CFStorageGetValueSize(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t __CFStorageEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *ValueAtIndex;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  int v19;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 144);
  v3 = *(_DWORD *)(a1 + 24);
  if (v3 == -1)
    v4 = v2 / *(_QWORD *)(a1 + 16);
  else
    v4 = v2 >> v3;
  v5 = *(_QWORD *)(a2 + 144);
  v6 = *(_DWORD *)(a2 + 24);
  if (v6 == -1)
    v7 = v5 / *(_QWORD *)(a2 + 16);
  else
    v7 = v5 >> v6;
  if (v4 != v7)
    return 0;
  v8 = *(_QWORD *)(a1 + 16);
  if (v8 != *(_QWORD *)(a2 + 16))
    return 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  ValueAtIndex = 0;
  v15 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  while (v13 < v4)
  {
    if (v13 >= v11 + v12)
    {
      ValueAtIndex = (char *)CFStorageGetValueAtIndex(a1, v13, &v25);
      v10 = v23;
      v9 = v24;
    }
    v16 = v9 + v10;
    if (v13 >= v9 + v10)
    {
      v15 = (char *)CFStorageGetValueAtIndex(a2, v13, &v23);
      v10 = v23;
      v9 = v24;
      v16 = v24 + v23;
    }
    v12 = v25;
    v11 = v26;
    if (v16 >= v26 + v25)
      v17 = v26 + v25;
    else
      v17 = v16;
    v18 = (v17 - v13) * v8;
    v19 = memcmp(ValueAtIndex, v15, v18);
    ValueAtIndex += v18;
    v15 += v18;
    v13 = v17;
    if (v19)
      return 0;
  }
  return 1;
}

uint64_t __CFStorageHash(uint64_t a1)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(a1 + 144);
  v2 = *(_DWORD *)(a1 + 24);
  if (v2 == -1)
    return v1 / *(_QWORD *)(a1 + 16);
  else
    return v1 >> v2;
}

__CFString *__CFStorageCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = *(_QWORD *)(a1 + 144);
  v5 = *(_DWORD *)(a1 + 24);
  if (v5 == -1)
  {
    v8 = *(_QWORD *)(a1 + 16);
    v6 = v4 / v8;
    v7 = __CFStorageGetNodeCapacity(a1 + 144) / v8;
  }
  else
  {
    v6 = v4 >> v5;
    v7 = __CFStorageGetNodeCapacity(a1 + 144) >> v5;
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFStorage %p [%p]>[count = %lu, capacity = %lu]\n"), a1, v2, v6, v7);
  __CFStorageDescribeNode((uint64_t *)(a1 + 144), Mutable, 0);
  return Mutable;
}

uint64_t CFStorageGetTypeID()
{
  return 26;
}

uint64_t CFStorageCreateWithSubrange(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __objc2_class **v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  BOOL v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int *v41;
  int v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD v51[3];
  _QWORD v52[4];

  v52[3] = *MEMORY[0x1E0C80C00];
  v6 = (__objc2_class **)CFGetAllocator((CFTypeRef)a1);
  v7 = CFStorageCreate(v6, *(_QWORD *)(a1 + 16));
  if (a3 >= 1)
  {
    v8 = *(_DWORD *)(a1 + 24);
    if (v8 == -1)
    {
      v11 = *(_QWORD *)(a1 + 16);
      v9 = v11 * a2;
      v10 = v11 * a3;
    }
    else
    {
      v9 = a2 << v8;
      v10 = a3 << v8;
    }
    v12 = a1 + 144;
    if (*(_BYTE *)(a1 + 157))
    {
      v13 = 0;
    }
    else
    {
      v13 = 0;
      v14 = v9;
      do
      {
        v15 = *(uint64_t **)(v12 + 16);
        v16 = *(_QWORD **)(v12 + 24);
        v52[0] = v15;
        v52[1] = v16;
        v17 = *(_QWORD **)(v12 + 32);
        v52[2] = v17;
        if (v16)
          v16 = (_QWORD *)*v16;
        if (v17)
          v17 = (_QWORD *)*v17;
        v18 = *v15;
        v51[0] = 0;
        v51[1] = v18;
        v19 = (char *)v16 + v18;
        v51[2] = (char *)v16 + v18;
        v20 = v14 & ~(v14 >> 63);
        v21 = v14 + v10;
        if (v18 >= v14 + v10)
          v22 = v14 + v10;
        else
          v22 = v18;
        v23 = __OFSUB__(v22, v20);
        v24 = v22 - v20;
        if ((v24 < 0) ^ v23 | (v24 == 0))
          v24 = 0;
        if (v18 <= v14)
          v25 = v14;
        else
          v25 = v18;
        if ((uint64_t)v19 >= v21)
          v26 = (char *)(v14 + v10);
        else
          v26 = v19;
        v23 = __OFSUB__(v26, v25);
        v27 = (uint64_t)&v26[-v25];
        if ((v27 < 0) ^ v23 | (v27 == 0))
          v27 = 0;
        if ((uint64_t)v19 <= v14)
          v28 = v14;
        else
          v28 = (uint64_t)v19;
        v29 = &v19[(_QWORD)v17];
        if ((uint64_t)v29 >= v21)
          v29 = (char *)(v14 + v10);
        v30 = (uint64_t)v29 <= v28;
        v31 = &v29[-v28];
        if (v30)
          v31 = 0;
        v32 = v27 != 0;
        if (v24)
          ++v32;
        if (v31)
          v33 = v32 + 1;
        else
          v33 = v32;
        if (v33 != 1)
          break;
        v34 = v27 ? 1 : 2;
        v35 = v24 ? 0 : v34;
        v12 = v52[v35];
        v36 = v51[v35];
        v14 -= v36;
        v13 += v36;
      }
      while (!*(_BYTE *)(v12 + 13));
    }
    if (*(_BYTE *)(v12 + 13))
    {
      CFStorageInsertValues(v7, 0, a3);
      v37 = *(_QWORD *)(v12 + 24);
      if (v37)
        CFStorageReplaceValues((char *)v7, 0, a3, (char *)(v37 + v9 - v13));
    }
    else
    {
      v38 = 0;
      v39 = *(_QWORD *)v12;
      *(_QWORD *)(v7 + 160) = 0;
      *(_BYTE *)(v7 + 157) = 0;
      *(_QWORD *)(v7 + 144) = v39;
      *(_QWORD *)(v7 + 168) = 0;
      *(_QWORD *)(v7 + 176) = 0;
      do
      {
        v40 = *(_QWORD *)(v12 + 16 + 8 * v38);
        if (!v40)
          break;
        v41 = (unsigned int *)(v40 + 8);
        v42 = *(_DWORD *)(v40 + 8);
        *(_BYTE *)(v40 + 12) = 1;
        if (v42)
        {
          do
            v43 = __ldxr(v41);
          while (__stxr(v43 + 1, v41));
        }
        *(_QWORD *)(v7 + 160 + 8 * v38++) = v40;
      }
      while (v38 != 3);
      v44 = *(_DWORD *)(v7 + 24);
      if (v44 == -1)
      {
        v47 = *(_QWORD *)(v7 + 16);
        v45 = v13 / v47;
        v46 = v39 / v47;
      }
      else
      {
        v45 = v13 >> v44;
        v46 = v39 >> v44;
      }
      v48 = a2 - v45;
      v49 = v45 - a2 - a3;
      if (v49 + v46 >= 1)
        CFStorageDeleteValues(v7, -v49, v49 + v46);
      if (v48 >= 1)
        CFStorageDeleteValues(v7, 0, v48);
    }
  }
  return v7;
}

uint64_t __CFStorageCreateNode(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t Typed;

  Typed = CFAllocatorAllocateTyped(a1, 40, 0x1032040801AFE6DLL, 0);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  *(_DWORD *)(Typed + 8) = 1;
  *(_BYTE *)(Typed + 12) = *(_BYTE *)(a2 + 96);
  *(_BYTE *)(Typed + 13) = a3;
  *(_QWORD *)Typed = a4;
  if ((a3 & 1) == 0)
    *(_QWORD *)(Typed + 32) = 0;
  *(_QWORD *)(Typed + 16) = 0;
  *(_QWORD *)(Typed + 24) = 0;
  return Typed;
}

uint64_t _CFStorageFastEnumeration(uint64_t a1, unint64_t *a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t ValueAtIndex;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *a2;
  if (v3)
  {
    v4 = a2[3];
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 144);
    v6 = *(_DWORD *)(a1 + 24);
    if (v6 == -1)
      v4 = v5 / *(_QWORD *)(a1 + 16);
    else
      v4 = v5 >> v6;
    a2[3] = v4;
  }
  if (v3 >= v4)
    return 0;
  v9 = 0;
  v10 = 0;
  ValueAtIndex = CFStorageGetValueAtIndex(a1, v3, &v9);
  result = v10;
  *a2 += v10;
  a2[1] = ValueAtIndex;
  return result;
}

uint64_t CFStorageApplyFunction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  _QWORD v7[8];

  v7[7] = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)(a1 + 16);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[2] = __CFStorageApplyFunction_block_invoke;
  v7[3] = &__block_descriptor_tmp_10;
  v7[4] = a4;
  v7[5] = a5;
  v7[6] = v5;
  return CFStorageApplyBlock(a1, a2, a3, 0, (uint64_t)v7);
}

uint64_t CFStorageApplyBlock(uint64_t result, uint64_t a2, uint64_t a3, unsigned __int8 a4, uint64_t a5)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a3)
  {
    v6 = *(_DWORD *)(result + 24);
    if (v6 == -1)
    {
      v9 = *(_QWORD *)(result + 16);
      v7 = v9 * a2;
      v8 = v9 * a3;
    }
    else
    {
      v7 = a2 << v6;
      v8 = a3 << v6;
    }
    if (((a3 >= 0x100000) & a4) != 0)
      v10 = 3;
    else
      v10 = 0;
    return __CFStorageEnumerateNodesInByteRangeWithBlock(result, result + 144, 0, v7, v8, v10, a5);
  }
  return result;
}

BOOL __CFStorageEnumerateNodesInByteRangeWithBlock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12;
  CFAllocatorRef v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  BOOL v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  size_t v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v59;
  _QWORD block[12];
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  char v65;
  unsigned __int8 v66;
  _QWORD v67[6];
  _QWORD v68[3];
  _QWORD v69[5];

  v69[3] = *MEMORY[0x1E0C80C00];
  v66 = 0;
  if (*(_BYTE *)(a2 + 13))
  {
    if (a5 >= *(_QWORD *)a2 - a4)
      v12 = *(_QWORD *)a2 - a4;
    else
      v12 = a5;
    if (!*(_QWORD *)(a2 + 24))
    {
      v13 = CFGetAllocator((CFTypeRef)a1);
      v14 = *(_QWORD *)a2;
      v15 = *MEMORY[0x1E0C85AD8];
      if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
        v16 = *MEMORY[0x1E0C85AD8];
      else
        v16 = v15 + 1;
      if (v14 <= v16 >> 1)
      {
        v51 = v14 + 63;
        v29 = v14 < -63;
        v52 = v14 + 126;
        if (!v29)
          v52 = v51;
        v18 = v52 & 0xFFFFFFFFFFFFFFC0;
      }
      else
      {
        v17 = (v14 + v15 - 1) & -(int)v15;
        if (*(_QWORD *)(a1 + 136) >= v17)
          v18 = v17;
        else
          v18 = *(_QWORD *)(a1 + 136);
      }
      if (v18 > *(_QWORD *)(a2 + 16))
      {
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
        if (v18 > *(_QWORD *)(a2 + 16))
        {
          *(_QWORD *)(a2 + 24) = __CFSafelyReallocateWithAllocatorTyped(v13, *(_QWORD *)(a2 + 24), v18, 1893177561, 0, 0);
          if (__CFOASafe)
            __CFSetLastAllocationEventName();
          *(_QWORD *)(a2 + 16) = v18;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
      }
    }
    v53 = a4 + a3;
    v54 = *(_DWORD *)(a1 + 24);
    if (v54 == -1)
    {
      v57 = *(_QWORD *)(a1 + 16);
      v55 = v53 / v57;
      v56 = v12 / v57;
    }
    else
    {
      v55 = v53 >> v54;
      v56 = v12 >> v54;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned __int8 *))(a7 + 16))(a7, *(_QWORD *)(a2 + 24) + a4, v55, v56, &v66);
    v49 = v66;
    return v49 != 0;
  }
  v19 = *(uint64_t **)(a2 + 16);
  v20 = *(uint64_t **)(a2 + 24);
  v69[0] = v19;
  v69[1] = v20;
  v21 = *(uint64_t **)(a2 + 32);
  v69[2] = v21;
  v22 = *v19;
  if (v20)
    v23 = *v20;
  else
    v23 = 0;
  if (v21)
    v24 = *v21;
  else
    v24 = 0;
  v68[0] = 0;
  v68[1] = v22;
  v25 = v23 + v22;
  v68[2] = v23 + v22;
  v26 = a4 & ~(a4 >> 63);
  v27 = a4 + a5;
  if (v22 >= a4 + a5)
    v28 = a4 + a5;
  else
    v28 = v22;
  v29 = v28 <= v26;
  v30 = v28 - v26;
  if (v29)
    v31 = 0;
  else
    v31 = v30;
  if (v29)
    v32 = 0;
  else
    v32 = a4 & ~(a4 >> 63);
  v67[0] = v32;
  v67[1] = v31;
  if (v22 <= a4)
    v33 = a4;
  else
    v33 = v22;
  if (v25 >= v27)
    v34 = v27;
  else
    v34 = v25;
  v35 = v34 <= v33;
  v36 = v34 - v33;
  if (v35)
    v37 = 0;
  else
    v37 = v36;
  if (v35)
    v38 = 0;
  else
    v38 = v33;
  v67[2] = v38;
  v67[3] = v37;
  if (v25 <= a4)
    v39 = a4;
  else
    v39 = v25;
  v40 = v25 + v24;
  if (v40 >= v27)
    v40 = v27;
  v41 = v40 <= v39;
  v42 = v40 - v39;
  if (v41)
    v43 = 0;
  else
    v43 = v42;
  if (v41)
    v44 = 0;
  else
    v44 = v39;
  v67[4] = v44;
  v67[5] = v43;
  v45 = v37 != 0;
  if (v31)
    ++v45;
  if (v43)
    ++v45;
  v46 = a6 - (v45 > 1);
  if (v45 < 2 || v46 < 0)
  {
    v59 = v44;
    if (v31 < 1)
    {
      if (v37 < 1)
      {
        if (v43 <= 0)
        {
          v49 = 0;
          return v49 != 0;
        }
        goto LABEL_90;
      }
    }
    else
    {
      v50 = __CFStorageEnumerateNodesInByteRangeWithBlock(a1, v19, a3, v32);
      if (v37 > 0)
        v49 = 1;
      else
        v49 = v50;
      if (v37 < 1 || (v50 & 1) != 0)
        goto LABEL_86;
    }
    v49 = __CFStorageEnumerateNodesInByteRangeWithBlock(a1, v20, v22 + a3, v38 - v22);
LABEL_86:
    if (v43 <= 0)
      return v49 != 0;
    if ((v49 & 1) != 0)
    {
      v49 = 1;
      return v49 != 0;
    }
LABEL_90:
    v49 = __CFStorageEnumerateNodesInByteRangeWithBlock(a1, v21, v25 + a3, v59 - v25);
    return v49 != 0;
  }
  v47 = 1;
  v62 = 0;
  v63 = &v62;
  if (v20)
    v47 = 2;
  if (v21)
    v48 = v47 + 1;
  else
    v48 = v47;
  v64 = 0x2000000000;
  v65 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ____CFStorageEnumerateNodesInByteRangeWithBlock_block_invoke;
  block[3] = &unk_1E12E6BB0;
  block[6] = v67;
  block[7] = a1;
  block[8] = v69;
  block[9] = a3;
  block[10] = v68;
  block[11] = v46;
  block[4] = a7;
  block[5] = &v62;
  dispatch_apply(v48, 0, block);
  v49 = *((unsigned __int8 *)v63 + 24);
  _Block_object_dispose(&v62, 8);
  return v49 != 0;
}

uint64_t __CFStorageSetAlwaysFrozen(uint64_t result, char a2)
{
  *(_BYTE *)(result + 96) = a2;
  return result;
}

void __CFStorageDescribeNode(uint64_t *a1, __CFString *a2, uint64_t a3)
{
  uint64_t v6;
  CFStringEncoding SystemEncoding;
  uint64_t v8;
  const char *v9;
  const char *v10;
  uint64_t i;
  uint64_t v12;

  if (a3 >= 1)
  {
    v6 = a3;
    do
    {
      SystemEncoding = CFStringGetSystemEncoding();
      CFStringAppendCString(a2, "  ", SystemEncoding);
      --v6;
    }
    while (v6);
  }
  v8 = *a1;
  if (*((_BYTE *)a1 + 13))
  {
    v9 = "yes";
    if (!*((_BYTE *)a1 + 12))
      v9 = "no";
    CFStringAppendFormat(a2, 0, CFSTR("Leaf %ld/%ld (%p) refcount: %u frozen: %s\n"), v8, a1[2], a1, *((unsigned int *)a1 + 2), v9);
  }
  else
  {
    v10 = "yes";
    if (!*((_BYTE *)a1 + 12))
      v10 = "no";
    CFStringAppendFormat(a2, 0, CFSTR("Node %ld (%p) refcount: %u frozen: %s\n"), v8, a1, *((unsigned int *)a1 + 2), v10);
    for (i = 0; i != 3; ++i)
    {
      v12 = a1[i + 2];
      if (v12)
        __CFStorageDescribeNode(v12, a2, a3 + 1);
    }
  }
}

void __CFStorageDeallocateNode(const void *a1, uint64_t a2)
{
  const __CFAllocator *v4;
  const __CFAllocator *v5;
  void *v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;

  v4 = CFGetAllocator(a1);
  v5 = v4;
  if (*(_BYTE *)(a2 + 13))
  {
    v6 = *(void **)(a2 + 24);
    if (v6)
      CFAllocatorDeallocate(v4, v6);
  }
  else
  {
    v7 = *(_QWORD *)(a2 + 16);
    if (v7)
    {
      v8 = (unsigned int *)(v7 + 8);
      if (*(_DWORD *)(v7 + 8))
      {
        do
        {
          v9 = __ldxr(v8);
          v10 = v9 - 1;
        }
        while (__stxr(v10, v8));
        if (!v10)
          __CFStorageDeallocateNode(a1);
      }
    }
    v11 = *(_QWORD *)(a2 + 24);
    if (v11)
    {
      v12 = (unsigned int *)(v11 + 8);
      if (*(_DWORD *)(v11 + 8))
      {
        do
        {
          v13 = __ldxr(v12);
          v14 = v13 - 1;
        }
        while (__stxr(v14, v12));
        if (!v14)
          __CFStorageDeallocateNode(a1);
      }
    }
    v15 = *(_QWORD *)(a2 + 32);
    if (v15)
    {
      v16 = (unsigned int *)(v15 + 8);
      if (*(_DWORD *)(v15 + 8))
      {
        do
        {
          v17 = __ldxr(v16);
          v18 = v17 - 1;
        }
        while (__stxr(v18, v16));
        if (!v18)
          __CFStorageDeallocateNode(a1);
      }
    }
  }
  CFAllocatorDeallocate(v5, (void *)a2);
}

uint64_t __CFStorageInsertFrozen(uint64_t a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t *v9;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *Node;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int64_t v22;
  int64_t *v23;
  int64_t v24;
  int64_t v25;
  uint64_t v26;
  uint64_t v27;
  const void *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t inserted;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int *v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int *v52;
  unsigned int v53;
  unsigned int v54;
  __int128 v55;
  uint64_t *v56;
  _QWORD *v57;
  uint64_t *v58;
  uint64_t v59;
  unsigned int *v60;
  unsigned int v61;
  uint64_t *v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  int64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  BOOL v74;
  int64_t v75;
  int64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  BOOL v80;
  int64_t v81;
  int64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v86;
  pthread_mutex_t *v90;
  __int128 v91;
  __int128 v92;
  uint64_t v93;

  v9 = (uint64_t *)a3;
  v93 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a3 + 13))
  {
    v12 = *(_QWORD *)a3 + a5;
    v13 = *(_QWORD *)(a2 + 136);
    v14 = v12 - v13;
    if (v12 > v13)
    {
      if (*(_QWORD *)a3 == a4)
      {
        Node = (uint64_t *)__CFStorageCreateNode(a1, a2, 1, a5);
        v16 = (uint64_t)Node;
        if (!Node)
        {
          v19 = 0;
          v20 = 0;
          goto LABEL_128;
        }
        v17 = *Node;
        v18 = *(_DWORD *)(a2 + 24);
        if (v18 != -1)
        {
          v19 = a6 >> v18;
          v20 = v17 >> v18;
LABEL_128:
          os_unfair_lock_lock_with_options();
          *(_QWORD *)(a2 + 104) = v16;
          *(_QWORD *)(a2 + 112) = v19;
          *(_QWORD *)(a2 + 120) = v20;
          os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 128));
          return (uint64_t)v9;
        }
        v84 = *(_QWORD *)(a2 + 16);
        v19 = a6 / v84;
LABEL_127:
        v20 = v17 / v84;
        goto LABEL_128;
      }
      if (a4)
      {
        v16 = __CFStorageCreateNode(a1, a2, 1, v13);
        v90 = (pthread_mutex_t *)a1;
        v33 = __CFStorageCreateNode(a1, a2, 1, v12 - v13);
        v34 = *MEMORY[0x1E0C85AD8];
        if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
          v35 = *MEMORY[0x1E0C85AD8];
        else
          v35 = v34 + 1;
        v36 = v35 >> 1;
        if (v36 >= v13)
        {
          v64 = v13 + 63;
          if (v13 < -63)
            v64 = v13 + 126;
          v38 = v64 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          v37 = (v13 + v34 - 1) & -(int)v34;
          if (*(_QWORD *)(a2 + 136) >= v37)
            v38 = v37;
          else
            v38 = *(_QWORD *)(a2 + 136);
        }
        if (v38 > *(_QWORD *)(v16 + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v38 > *(_QWORD *)(v16 + 16))
          {
            *(_QWORD *)(v16 + 24) = __CFSafelyReallocateWithAllocatorTyped(v90, *(_QWORD *)(v16 + 24), v38, 1893177561, 0, 0);
            if (__CFOASafe)
              __CFSetLastAllocationEventName();
            *(_QWORD *)(v16 + 16) = v38;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
          v34 = *MEMORY[0x1E0C85AD8];
          if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
            v65 = *MEMORY[0x1E0C85AD8];
          else
            v65 = v34 + 1;
          v36 = v65 >> 1;
        }
        if (v36 >= v14)
        {
          v68 = v14 + 63;
          if (v14 < -63)
            v68 = v14 + 126;
          v67 = v68 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          v66 = (v14 + v34 - 1) & -(int)v34;
          if (*(_QWORD *)(a2 + 136) >= v66)
            v67 = v66;
          else
            v67 = *(_QWORD *)(a2 + 136);
        }
        if (v67 > *(_QWORD *)(v33 + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v67 > *(_QWORD *)(v33 + 16))
          {
            *(_QWORD *)(v33 + 24) = __CFSafelyReallocateWithAllocatorTyped(v90, *(_QWORD *)(v33 + 24), v67, 1893177561, 0, 0);
            if (__CFOASafe)
              __CFSetLastAllocationEventName();
            *(_QWORD *)(v33 + 16) = v67;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        }
        memmove(*(void **)(v16 + 24), (const void *)v9[3], a4);
        v69 = a5 + a4;
        v70 = (a5 + a4) & ~((a5 + a4) >> 63);
        v71 = a5;
        v72 = *v9 + a5;
        if (v13 >= v72)
          v73 = v72;
        else
          v73 = v13;
        v74 = v73 <= v70;
        v75 = v73 - v70;
        if (v74)
          v76 = 0;
        else
          v76 = v75;
        if (v74)
          v77 = 0;
        else
          v77 = v70;
        if (v76 >= 1)
          memmove((void *)(*(_QWORD *)(v16 + 24) + v77), (const void *)(v9[3] + v77 - v71), v76);
        if (v13 <= v69)
          v78 = v69;
        else
          v78 = v13;
        if (v12 >= v72)
          v79 = v72;
        else
          v79 = v12;
        v80 = v79 <= v78;
        v81 = v79 - v78;
        if (v80)
          v82 = 0;
        else
          v82 = v81;
        if (v80)
          v78 = 0;
        if (v82 >= 1)
          memmove((void *)(*(_QWORD *)(v33 + 24) + v78 - v13), (const void *)(v9[3] + v78 - v71), v82);
        v40 = a6 - a4;
        v41 = *(_QWORD *)v16;
        v42 = *(_DWORD *)(a2 + 24);
        if (v42 != -1)
          goto LABEL_120;
        goto LABEL_122;
      }
      v60 = (unsigned int *)(a3 + 8);
      if (*(_DWORD *)(a3 + 8))
      {
        do
          v61 = __ldxr(v60);
        while (__stxr(v61 + 1, v60));
      }
      v62 = (uint64_t *)__CFStorageCreateNode(a1, a2, 1, a5);
      v16 = (uint64_t)v62;
      if (v62)
      {
        v17 = *v62;
        v63 = *(_DWORD *)(a2 + 24);
        if (v63 == -1)
        {
          v84 = *(_QWORD *)(a2 + 16);
          v19 = a6 / v84;
          v9 = v62;
          goto LABEL_127;
        }
        v19 = a6 >> v63;
        v20 = v17 >> v63;
LABEL_121:
        v9 = (uint64_t *)v16;
        goto LABEL_128;
      }
      v19 = 0;
      v20 = 0;
LABEL_125:
      v9 = 0;
      goto LABEL_128;
    }
    v27 = __CFStorageCreateNode(a1, a2, 1, *(_QWORD *)a3 + a5);
    v16 = v27;
    v28 = (const void *)v9[3];
    if (v28)
    {
      v29 = *MEMORY[0x1E0C85AD8];
      if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
        v30 = *MEMORY[0x1E0C85AD8];
      else
        v30 = v29 + 1;
      if (v12 <= v30 >> 1)
      {
        v39 = v12 + 63;
        if (v12 < -63)
          v39 = v12 + 126;
        v32 = v39 & 0xFFFFFFFFFFFFFFC0;
      }
      else
      {
        v31 = (v12 + v29 - 1) & -(int)v29;
        if (*(_QWORD *)(a2 + 136) >= v31)
          v32 = v31;
        else
          v32 = *(_QWORD *)(a2 + 136);
      }
      if (v32 > *(_QWORD *)(v27 + 16))
      {
        pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
        if (v32 > *(_QWORD *)(v16 + 16))
        {
          *(_QWORD *)(v16 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(_QWORD *)(v16 + 24), v32, 1893177561, 0, 0);
          if (__CFOASafe)
            __CFSetLastAllocationEventName();
          *(_QWORD *)(v16 + 16) = v32;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        v28 = (const void *)v9[3];
      }
      memmove(*(void **)(v16 + 24), v28, a4);
      memmove((void *)(*(_QWORD *)(v16 + 24) + a4 + a5), (const void *)(v9[3] + a4), *v9 - a4);
    }
    else if (!v27)
    {
      v19 = 0;
      v20 = 0;
      goto LABEL_125;
    }
    v40 = a6 - a4;
    v41 = *(_QWORD *)v16;
    v42 = *(_DWORD *)(a2 + 24);
    if (v42 != -1)
    {
LABEL_120:
      v19 = v40 >> v42;
      v20 = v41 >> v42;
      goto LABEL_121;
    }
LABEL_122:
    v83 = *(_QWORD *)(a2 + 16);
    v19 = v40 / v83;
    v9 = (uint64_t *)v16;
    v20 = v41 / v83;
    goto LABEL_128;
  }
  v21 = __CFStorageCreateNode(a1, a2, 0, 0);
  v22 = a4 - 1;
  v23 = (int64_t *)v9[2];
  v24 = *v23;
  if (*v23 >= a4)
  {
    v26 = 0;
    v86 = 1;
  }
  else
  {
    v22 -= v24;
    v23 = (int64_t *)v9[3];
    v25 = v22 - *v23;
    if (v22 >= *v23)
    {
      v86 = 0;
      v23 = (int64_t *)v9[4];
      v26 = 2;
      v22 = v25;
    }
    else
    {
      v86 = 1;
      v26 = 1;
    }
  }
  inserted = __CFStorageInsertFrozen(a1, a2, v23, v22 + 1, a5, a6);
  v44 = inserted;
  v46 = v45;
  v47 = 0;
  v91 = 0u;
  v92 = 0u;
  do
  {
    v48 = v9[v47 + 2];
    if (v48)
    {
      v49 = (unsigned int *)(v48 + 8);
      if (*(_DWORD *)(v48 + 8))
      {
        do
          v50 = __ldxr(v49);
        while (__stxr(v50 + 1, v49));
      }
      *(_BYTE *)(v48 + 12) = 1;
    }
    *((_QWORD *)&v91 + v47++) = v48;
  }
  while (v47 != 3);
  v51 = *((_QWORD *)&v91 + v26);
  if (v51 != inserted)
  {
    v52 = (unsigned int *)(v51 + 8);
    if (*(_DWORD *)(v51 + 8))
    {
      do
      {
        v53 = __ldxr(v52);
        v54 = v53 - 1;
      }
      while (__stxr(v54, v52));
      if (!v54)
        __CFStorageDeallocateNode((const void *)a2, v51);
    }
    *((_QWORD *)&v91 + v26) = v44;
  }
  if (v46)
  {
    if (v86)
    {
      *((_QWORD *)&v92 + 1) = v92;
      if (v24 >= a4)
        *(_QWORD *)&v92 = *((_QWORD *)&v91 + 1);
    }
    *((_QWORD *)&v91 + v26 + 1) = v46;
  }
  v55 = v91;
  *(_OWORD *)(v21 + 16) = v91;
  v56 = (uint64_t *)*((_QWORD *)&v92 + 1);
  if (*((_QWORD *)&v92 + 1))
  {
    v57 = (_QWORD *)__CFStorageCreateNode(a1, a2, 0, 0);
    v58 = (uint64_t *)v92;
    v57[2] = v92;
    v57[3] = v56;
    *(_QWORD *)v21 = **((_QWORD **)&v55 + 1) + *(_QWORD *)v55;
    v59 = *v58;
    v9 = v56;
  }
  else
  {
    *(_QWORD *)(v21 + 32) = v92;
    v57 = (_QWORD *)v21;
    v59 = a5;
  }
  *v57 = *v9 + v59;
  return v21;
}

uint64_t __CFStorageDeleteFrozen(uint64_t a1, uint64_t a2, uint64_t *a3, int64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t Node;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int64_t v16;
  uint64_t v18;
  int64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  int64_t v24;
  int64_t v25;
  int64_t v26;
  BOOL v27;
  int64_t v28;
  uint64_t v30;
  unsigned int *v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD __src[4];

  __src[3] = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)a3 + 13))
  {
    v10 = *a3 - a5;
    if (*a3 != a5)
    {
      Node = __CFStorageCreateNode(a1, a2, 1, *a3 - a5);
      v12 = Node;
      if (a3[3])
      {
        v13 = *MEMORY[0x1E0C85AD8];
        if ((uint64_t)*MEMORY[0x1E0C85AD8] >= 0)
          v14 = *MEMORY[0x1E0C85AD8];
        else
          v14 = v13 + 1;
        if (v10 <= v14 >> 1)
        {
          v33 = v10 + 63;
          if (v10 < -63)
            v33 = v10 + 126;
          v16 = v33 & 0xFFFFFFFFFFFFFFC0;
        }
        else
        {
          v15 = (v10 + v13 - 1) & -(int)v13;
          if (*(_QWORD *)(a2 + 136) >= v15)
            v16 = v15;
          else
            v16 = *(_QWORD *)(a2 + 136);
        }
        v34 = a4 + a5;
        v35 = *a3;
        if (v16 > *(_QWORD *)(Node + 16))
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 32));
          if (v16 > *(_QWORD *)(v12 + 16))
          {
            *(_QWORD *)(v12 + 24) = __CFSafelyReallocateWithAllocatorTyped(a1, *(_QWORD *)(v12 + 24), v16, 1893177561, 0, 0);
            if (__CFOASafe)
              __CFSetLastAllocationEventName();
            *(_QWORD *)(v12 + 16) = v16;
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 32));
        }
        if (a4 >= 1)
          memmove(*(void **)(v12 + 24), (const void *)a3[3], a4);
        if (v35 - v34 >= 1)
          memmove((void *)(*(_QWORD *)(v12 + 24) + a4), (const void *)(a3[3] + v34), v35 - v34);
      }
      return v12;
    }
    return 0;
  }
  if (a5 == *a3)
    return 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  memset(__src, 0, 24);
  v21 = a4 + a5;
  do
  {
    v22 = (uint64_t *)a3[v20 + 2];
    if (!v22)
      break;
    v23 = *v22;
    v24 = a4 <= v19 ? v19 : a4;
    v25 = v23 + v19;
    v26 = v21 >= v23 + v19 ? v23 + v19 : v21;
    v27 = v26 <= v24;
    v28 = v26 - v24;
    if (v27 ? 0 : v28)
    {
      v30 = __CFStorageDeleteFrozen(a1, a2);
      if (v30)
        __src[v18++] = v30;
    }
    else
    {
      v31 = (unsigned int *)(v22 + 1);
      if (*((_DWORD *)v22 + 2))
      {
        do
          v32 = __ldxr(v31);
        while (__stxr(v32 + 1, v31));
      }
      __src[v18++] = v22;
      *((_BYTE *)v22 + 12) = 1;
    }
    ++v20;
    v19 = v25;
  }
  while (v20 != 3);
  if (v18 == 1)
    return __src[0];
  v36 = __CFStorageCreateNode(a1, a2, 0, 0);
  v12 = v36;
  if (v18)
    memcpy((void *)(v36 + 16), __src, 8 * v18);
  *(_QWORD *)v12 = *a3 - a5;
  return v12;
}

uint64_t _CFStreamGetInfoPointer(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 40);
  return result;
}

CFStringRef __CFStreamCopyDescription(_QWORD *cf)
{
  _QWORD *v2;
  uint64_t (*v3)(_QWORD);
  CFStringRef v4;
  const __CFAllocator *v5;
  CFStringRef v6;
  CFTypeID v7;
  const __CFAllocator *v8;
  CFStringRef v9;
  CFStringRef v10;

  v2 = (_QWORD *)cf[6];
  v3 = (uint64_t (*)(_QWORD))v2[3];
  if (v3)
  {
    if (*v2)
      v4 = (CFStringRef)((uint64_t (*)(_QWORD *, _QWORD))v3)(cf, cf[5]);
    else
      v4 = (CFStringRef)v3(cf[5]);
  }
  else
  {
    v5 = CFGetAllocator(cf);
    v4 = CFStringCreateWithFormat(v5, 0, CFSTR("info = %p"), cf[5]);
  }
  v6 = v4;
  v7 = CFGetTypeID(cf);
  v8 = CFGetAllocator(cf);
  if (v7 == 38)
    v9 = CFStringCreateWithFormat(v8, 0, CFSTR("<CFReadStream %p>{%@}"), cf, v6);
  else
    v9 = CFStringCreateWithFormat(v8, 0, CFSTR("<CFWriteStream %p>{%@}"), cf, v6);
  v10 = v9;
  CFRelease(v6);
  return v10;
}

CFStreamError CFReadStreamGetError(CFReadStreamRef stream)
{
  __CFError *StreamError;
  uint64_t v3;
  CFStreamError result;

  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
    StreamError = (__CFError *)-[__CFReadStream _cfStreamError](stream, "_cfStreamError");
  else
    StreamError = _CFStreamGetStreamError((uint64_t)stream);
  result.error = v3;
  result.domain = (CFIndex)StreamError;
  return result;
}

__CFError *_CFStreamGetStreamError(uint64_t a1)
{
  __CFError *result;

  result = *(__CFError **)(a1 + 24);
  if (result)
  {
    if (**(uint64_t **)(a1 + 48) > 1)
      return (__CFError *)_CFStreamErrorFromError(result);
    else
      return *(__CFError **)result;
  }
  return result;
}

CFStreamError CFWriteStreamGetError(CFWriteStreamRef stream)
{
  __CFError *StreamError;
  uint64_t v3;
  CFStreamError result;

  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
    StreamError = (__CFError *)-[__CFWriteStream _cfStreamError](stream, "_cfStreamError");
  else
    StreamError = _CFStreamGetStreamError((uint64_t)stream);
  result.error = v3;
  result.domain = (CFIndex)StreamError;
  return result;
}

CFErrorRef CFReadStreamCopyError(CFReadStreamRef stream)
{
  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
    return (CFErrorRef)(id)-[__CFReadStream streamError](stream, "streamError");
  else
    return _CFStreamCopyError(stream);
}

CFErrorRef _CFStreamCopyError(CFTypeRef cf)
{
  CFErrorRef result;
  const __CFAllocator *v3;

  result = (CFErrorRef)*((_QWORD *)cf + 3);
  if (result)
  {
    if (**((uint64_t **)cf + 6) > 1)
    {
      CFRetain(result);
      return (CFErrorRef)*((_QWORD *)cf + 3);
    }
    else
    {
      v3 = CFGetAllocator(cf);
      return _CFStreamCreateErrorFromStreamError(v3, *((int **)cf + 3));
    }
  }
  return result;
}

CFErrorRef CFWriteStreamCopyError(CFWriteStreamRef stream)
{
  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
    return (CFErrorRef)(id)-[__CFWriteStream streamError](stream, "streamError");
  else
    return _CFStreamCopyError(stream);
}

uint64_t waitForOpen(uint64_t a1)
{
  CFRunLoopRef Current;

  Current = CFRunLoopGetCurrent();
  _CFStreamScheduleWithRunLoop((char *)a1, Current, CFSTR("_kCFStreamBlockingOpenMode"));
  while ((*(_QWORD *)(a1 + 16) & 0x1FLL) == 1)
    CFRunLoopRunInMode(CFSTR("_kCFStreamBlockingOpenMode"), 1.0e20, 1u);
  return _CFStreamUnscheduleFromRunLoop(a1, Current, CFSTR("_kCFStreamBlockingOpenMode"));
}

const UInt8 *__cdecl CFReadStreamGetBuffer(CFReadStreamRef stream, CFIndex maxBytesToRead, CFIndex *numBytesRead)
{
  const UInt8 *v6;
  uint64_t Status;
  uint64_t *v8;
  uint64_t (*v9)(CFReadStreamRef, CFIndex, CFIndex *, char *, char *, _QWORD);
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  _OWORD *Typed;
  CFAllocatorRef v16;
  uint64_t v17;
  uint64_t v18;
  __CFRunLoopSource *v19;
  uint64_t v20;
  uint64_t v21;
  __CFRunLoopSource *v22;
  char v23;
  __int128 v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
  {
    *(_QWORD *)&v25 = 0;
    if (-[__CFReadStream getBuffer:length:](stream, "getBuffer:length:", &v25, numBytesRead))
      return (const UInt8 *)v25;
    else
      return 0;
  }
  Status = _CFStreamGetStatus((uint64_t)stream);
  v8 = (uint64_t *)*((_QWORD *)stream + 6);
  if (Status == 1)
  {
    *((_QWORD *)stream + 2) |= 0x40uLL;
    waitForOpen((uint64_t)stream);
    *((_QWORD *)stream + 2) &= ~0x40uLL;
    Status = _CFStreamGetStatus((uint64_t)stream);
  }
  if ((unint64_t)(Status - 2) >= 2)
  {
    if (Status != 5)
    {
      v6 = 0;
      *numBytesRead = -1;
      return v6;
    }
    goto LABEL_13;
  }
  v9 = (uint64_t (*)(CFReadStreamRef, CFIndex, CFIndex *, char *, char *, _QWORD))v8[7];
  if (!v9)
  {
LABEL_13:
    v6 = 0;
    *numBytesRead = 0;
    return v6;
  }
  v26 = 0;
  v10 = *((_QWORD *)stream + 4);
  if (v10)
  {
    v11 = *(_QWORD *)(v10 + 72);
    v12 = (uint64_t *)((char *)stream + 16);
    v13 = *((_QWORD *)stream + 2) | 0x40;
    *((_QWORD *)stream + 2) = v13;
    if ((v11 & 2) != 0)
    {
      *(_QWORD *)(v10 + 72) = v11 & 0xFFFFFFFFFFFFFFFDLL;
      v14 = 1;
    }
    else
    {
      v14 = 0;
    }
  }
  else
  {
    v14 = 0;
    v12 = (uint64_t *)((char *)stream + 16);
    v13 = *((_QWORD *)stream + 2) | 0x40;
    *((_QWORD *)stream + 2) = v13;
  }
  if ((v13 & 0x1E) != 6)
    *v12 = v13 & 0xFFFFFFE0 | 3;
  if (*v8 > 1)
  {
    v6 = (const UInt8 *)v9(stream, maxBytesToRead, numBytesRead, (char *)stream + 24, &v26, *((_QWORD *)stream + 5));
  }
  else
  {
    v25 = 0uLL;
    v6 = (const UInt8 *)v9(stream, maxBytesToRead, numBytesRead, (char *)&v25, &v26, *((_QWORD *)stream + 5));
    if (DWORD2(v25))
    {
      Typed = (_OWORD *)*((_QWORD *)stream + 3);
      if (!Typed)
      {
        v16 = CFGetAllocator(stream);
        Typed = (_OWORD *)CFAllocatorAllocateTyped(v16, 16, 0x1000040D9A13B51, 0);
        *((_QWORD *)stream + 3) = Typed;
      }
      *Typed = v25;
    }
  }
  if (*((_QWORD *)stream + 3))
  {
    *numBytesRead = -1;
    if ((*v12 & 0x1F) != 7)
      *v12 = *v12 & 0xFFFFFFE0 | 7;
    v17 = *((_QWORD *)stream + 4);
    if (v17 && (*(_BYTE *)(v17 + 48) & 8) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      v18 = *((_QWORD *)stream + 4);
      if (v18 && (v19 = *(__CFRunLoopSource **)(v18 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v18 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        *(_QWORD *)(*((_QWORD *)stream + 4) + 72) |= 8uLL;
        CFRunLoopSourceSignal(v19);
        CFRelease(v19);
        _wakeUpRunLoop((uint64_t)stream);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
      }
    }
    v6 = 0;
  }
  else if (v26)
  {
    if ((*v12 & 0x1E) != 6)
      *v12 = *v12 & 0xFFFFFFE0 | 5;
    v20 = *((_QWORD *)stream + 4);
    if (v20 && (*(_BYTE *)(v20 + 48) & 0x10) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)stream + 56));
      v21 = *((_QWORD *)stream + 4);
      if (v21 && (v22 = *(__CFRunLoopSource **)(v21 + 56)) != 0)
      {
        CFRetain(*(CFTypeRef *)(v21 + 56));
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
        *(_QWORD *)(*((_QWORD *)stream + 4) + 72) |= 0x10uLL;
        CFRunLoopSourceSignal(v22);
        CFRelease(v22);
        _wakeUpRunLoop((uint64_t)stream);
      }
      else
      {
        pthread_mutex_unlock((pthread_mutex_t *)((char *)stream + 56));
      }
    }
  }
  else
  {
    v23 = v14 ^ 1;
    if (v6)
      v23 = 1;
    if ((v23 & 1) == 0)
      *(_QWORD *)(*((_QWORD *)stream + 4) + 72) |= 2uLL;
    if ((*v12 & 0x1E) != 6)
      *v12 = *v12 & 0xFFFFFFE0 | 2;
  }
  *v12 &= ~0x40uLL;
  return v6;
}

uint64_t _CFStreamCopyProperty(_QWORD *a1, uint64_t a2)
{
  uint64_t (*v2)(_QWORD *, uint64_t, _QWORD);
  uint64_t result;

  v2 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(a1[6] + 96);
  if (!v2)
    return 0;
  a1[2] |= 0x40uLL;
  result = v2(a1, a2, a1[5]);
  a1[2] &= ~0x40uLL;
  return result;
}

uint64_t _CFStreamSetProperty(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v3)(_QWORD *, uint64_t, uint64_t, _QWORD);
  uint64_t result;

  v3 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, _QWORD))(a1[6] + 104);
  if (!v3)
    return 0;
  a1[2] |= 0x40uLL;
  result = v3(a1, a2, a3, a1[5]);
  a1[2] &= ~0x40uLL;
  return result;
}

double _CFReadStreamInitialize(uint64_t a1)
{
  double result;

  if (a1)
  {
    *(_QWORD *)(a1 + 56) = 850045857;
    result = 0.0;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_QWORD *)(a1 + 112) = 0;
  }
  return result;
}

double _CFWriteStreamInitialize(uint64_t a1)
{
  double result;

  if (a1)
  {
    *(_QWORD *)(a1 + 56) = 850045857;
    result = 0.0;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_QWORD *)(a1 + 112) = 0;
  }
  return result;
}

uint64_t _CFReadStreamGetClient(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    return *(_QWORD *)(v1 + 8);
  else
    return 0;
}

uint64_t _CFWriteStreamGetClient(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (v1)
    return *(_QWORD *)(v1 + 8);
  else
    return 0;
}

void CFReadStreamUnscheduleFromRunLoop(CFReadStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x26uLL, (__objc2_class **)stream))
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      -[__CFReadStream _unscheduleFromCFRunLoop:forMode:](stream, "_unscheduleFromCFRunLoop:forMode:", runLoop, runLoopMode);
    else
      -[__CFReadStream removeFromRunLoop:forMode:](stream, "removeFromRunLoop:forMode:", _CFRunLoopGet2((uint64_t)runLoop), runLoopMode);
  }
  else
  {
    _CFStreamUnscheduleFromRunLoop((uint64_t)stream, runLoop, runLoopMode);
  }
}

void CFWriteStreamUnscheduleFromRunLoop(CFWriteStreamRef stream, CFRunLoopRef runLoop, CFRunLoopMode runLoopMode)
{
  if (CF_IS_OBJC(0x27uLL, (__objc2_class **)stream))
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
      -[__CFWriteStream _unscheduleFromCFRunLoop:forMode:](stream, "_unscheduleFromCFRunLoop:forMode:", runLoop, runLoopMode);
    else
      -[__CFWriteStream removeFromRunLoop:forMode:](stream, "removeFromRunLoop:forMode:", _CFRunLoopGet2((uint64_t)runLoop), runLoopMode);
  }
  else
  {
    _CFStreamUnscheduleFromRunLoop((uint64_t)stream, runLoop, runLoopMode);
  }
}

NSObject *_CFStreamCopyDispatchQueue(uint64_t a1)
{
  pthread_mutex_t *v2;
  NSObject *v3;

  v2 = (pthread_mutex_t *)(a1 + 56);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  if (*(_QWORD *)(a1 + 32))
  {
    v3 = *(NSObject **)(a1 + 128);
    if (v3)
      dispatch_retain(v3);
  }
  else
  {
    v3 = 0;
  }
  pthread_mutex_unlock(v2);
  return v3;
}

void _CFReadStreamSignalEventDelayed(char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CFStreamSignalEvent(a1, a2, a3, 0, a5, a6, a7, a8);
}

uint64_t _CFReadStreamClearEvent(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 32);
  if (v2)
    *(_QWORD *)(v2 + 72) &= ~a2;
  return result;
}

void _CFWriteStreamSignalEventDelayed(char *a1, unint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _CFStreamSignalEvent(a1, a2, a3, 0, a5, a6, a7, a8);
}

uint64_t CFReadStreamGetInfoPointer(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 40);
  return result;
}

uint64_t CFWriteStreamGetInfoPointer(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 40);
  return result;
}

uint64_t _CFStreamInstanceSize()
{
  return 128;
}

void ___legacyStreamRunLoop_block_invoke()
{
  qos_class_t v0;
  pthread_t v1;
  dispatch_semaphore_t dsema;
  pthread_attr_t __attr;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  sLegacyRL = 0;
  dsema = dispatch_semaphore_create(0);
  memset(&__attr, 0, sizeof(__attr));
  pthread_attr_init(&__attr);
  pthread_attr_setdetachstate(&__attr, 2);
  v0 = qos_class_main();
  pthread_attr_set_qos_class_np(&__attr, v0, 0);
  v1 = 0;
  pthread_create(&v1, &__attr, (void *(__cdecl *)(void *))_legacyStreamRunLoop_workThread, &dsema);
  pthread_attr_destroy(&__attr);
  dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(dsema);
}

void _perform()
{
  unint64_t v0;

  do
    v0 = __ldxr(&sPerformCount);
  while (__stxr(v0 + 1, &sPerformCount));
}

uint64_t _CFStringGetInputIdentifierFormatterMappingFromDescriptor(uint64_t a1)
{
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 3221225472;
  v2[2] = ___CFStringGetInputIdentifierFormatterMappingFromDescriptor_block_invoke;
  v2[3] = &__block_descriptor_40_e5_v8__0l;
  v2[4] = a1;
  if (_CFStringGetInputIdentifierFormatterMappingFromDescriptor_loc_formatting_family_info_init != -1)
    dispatch_once(&_CFStringGetInputIdentifierFormatterMappingFromDescriptor_loc_formatting_family_info_init, v2);
  return _CFStringGetInputIdentifierFormatterMappingFromDescriptor_localizedStringFormattingFamilyInfo;
}

void sub_182BD39A8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

BOOL __CFStringCopyCharSetWithPattern(const __CFString *a1, unint64_t **a2)
{
  CFIndex Length;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  CFRange v12;

  v11 = *MEMORY[0x1E0C80C00];
  HIDWORD(v10) = 0;
  Length = CFStringGetLength(a1);
  if (CFStringGetCharactersPtr(a1))
  {
    v7 = uset_openPattern();
  }
  else
  {
    MEMORY[0x1E0C80A78](0, v5);
    v12.location = 0;
    v12.length = Length;
    CFStringGetCharacters(a1, v12, (UniChar *)((char *)&v10 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0)));
    v7 = uset_openPattern();
  }
  if (SHIDWORD(v10) > 0)
    return 0;
  *a2 = _CFCreateCharacterSetFromUSet(v7, v6);
  uset_close();
  return *a2 != 0;
}

void *_CFStringGetRelevantLocaleInfoFromLocaleSummary(const __CFDictionary *a1, const __CFLocale *a2)
{
  unint64_t Count;
  CFMutableArrayRef Mutable;
  uint64_t v6;
  __CFArray *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  const void **v11;
  const void **v12;
  const __CFArray *v13;
  const __CFArray *v14;
  const __CFArray *v15;
  const void *ValueAtIndex;
  CFStringRef v18;
  NSException *v19;
  size_t v20;
  void *value;
  void *values[2];

  values[1] = *(void **)MEMORY[0x1E0C80C00];
  value = 0;
  Count = CFDictionaryGetCount(a1);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeArrayCallBacks);
  if (!Mutable)
    return value;
  if (Count >> 60)
  {
    v18 = CFStringCreateWithFormat(0, 0, CFSTR("*** attempt to create a temporary id buffer which is too large or with a negative count (%lu) -- possibly data is corrupt"), Count);
    v19 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSGenericException"), v18, 0);
    CFRelease(v18);
    objc_exception_throw(v19);
  }
  v7 = Mutable;
  if (Count <= 1)
    v8 = 1;
  else
    v8 = Count;
  v9 = MEMORY[0x1E0C80A78](v8, v6);
  v11 = (const void **)((char *)&v20 - v10);
  v20 = 0;
  if (Count >= 0x101)
  {
    v11 = (const void **)_CFCreateArrayStorage(v9, 0, &v20);
    v12 = v11;
  }
  else
  {
    v12 = 0;
  }
  CFDictionaryGetKeysAndValues(a1, v11, 0);
  for (; Count; --Count)
    CFArrayAppendValue(v7, *v11++);
  values[0] = (void *)CFLocaleGetIdentifier(a2);
  v13 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)values, 1, &kCFTypeArrayCallBacks);
  v14 = CFBundleCopyLocalizationsForPreferences(v7, v13);
  v15 = CFBundleCopyPreferredLocalizationsFromArray(v14);
  if (CFArrayGetCount(v15) > 0)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v15, 0);
    free(v12);
    if (!CFDictionaryGetValueIfPresent(a1, ValueAtIndex, (const void **)&value))
      value = (void *)CFDictionaryGetValue(a1, CFSTR("default"));
    if (!v15)
      goto LABEL_18;
    goto LABEL_17;
  }
  free(v12);
  if (v15)
LABEL_17:
    CFRelease(v15);
LABEL_18:
  if (v14)
    CFRelease(v14);
  CFRelease(v7);
  if (v13)
    CFRelease(v13);
  return value;
}

void sub_182BD3D44(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

uint64_t _CFStringContentsInCharacterSet(const __CFString *a1, const __CFCharacterSet *a2)
{
  uint64_t v2;
  __CFCharacterSet *MutableCopy;
  __CFCharacterSet *v5;
  BOOL v6;
  CFRange v8;
  uint64_t v9;
  CFRange v10;

  v9 = *MEMORY[0x1E0C80C00];
  v2 = 1;
  if (a1)
  {
    if (a2)
    {
      MutableCopy = CFCharacterSetCreateMutableCopy(0, a2);
      if (MutableCopy)
      {
        v5 = MutableCopy;
        CFCharacterSetInvert(MutableCopy);
        CFCharacterSetRemoveCharactersInString(v5, CFSTR(" "));
        v8 = (CFRange)xmmword_182C87F40;
        v10.length = CFStringGetLength(a1);
        v10.location = 0;
        if (CFStringFindCharacterFromSet(a1, v5, v10, 0, &v8))
          v6 = 0;
        else
          v6 = v8.location == -1;
        v2 = v6;
        CFRelease(v5);
      }
    }
  }
  return v2;
}

uint64_t _CFStringConditionalFormattingMeetsCondition(const __CFString *a1, CFLocaleRef locale)
{
  uint64_t result;
  const __CFCharacterSet *Predefined;
  CFRange v5;
  uint64_t v6;
  CFRange v7;

  v6 = *MEMORY[0x1E0C80C00];
  result = (uint64_t)CFLocaleGetValue(locale, CFSTR("kCFLocaleLanguageCodeKey"));
  if (result)
  {
    result = CFEqual((CFTypeRef)result, CFSTR("fi"));
    if ((_DWORD)result)
    {
      Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
      v5 = (CFRange)xmmword_182C87F40;
      v7.length = CFStringGetLength(a1);
      v7.location = 0;
      return CFStringFindCharacterFromSet(a1, Predefined, v7, 0, &v5) != 0;
    }
  }
  return result;
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName(const __CFString *a1, CFLocaleRef locale)
{
  CFTypeRef Value;
  const void *v5;

  Value = CFLocaleGetValue(locale, CFSTR("kCFLocaleLanguageCodeKey"));
  if (!Value)
    return CFRetain(a1);
  v5 = Value;
  if (CFEqual(Value, CFSTR("cs")))
    return _CFStringCopyVocativeCaseOfGivenName_cs(a1, locale);
  if (CFEqual(v5, CFSTR("el")))
    return _CFStringCopyVocativeCaseOfGivenName_el(a1, locale);
  if (CFEqual(v5, CFSTR("uk")))
    return _CFStringCopyVocativeCaseOfGivenName_uk(a1, locale);
  if (CFEqual(v5, CFSTR("lt")))
    return _CFStringCopyVocativeCaseOfGivenName_lt(a1, locale);
  else
    return CFRetain(a1);
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_cs(CFStringRef theString, const __CFLocale *a2)
{
  __CFString *MutableCopy;
  uint64_t v5;
  __CFString *v6;
  CFIndex Count;
  CFIndex v8;
  const __CFString *ValueAtIndex;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFIndex v17;
  CFRange v18;
  CFRange v19;
  const __CFString *v20;
  __CFString *v21;
  CFIndex Length;
  CFIndex v23;
  UniChar *p_chars;
  CFStringRef v25;
  CFTypeRef v26;
  CFTypeRef result;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const __CFString **v49;
  const __CFString *v50;
  const __CFString *v51;
  const __CFString *v52;
  const __CFString *v53;
  const __CFString *v54;
  const __CFString *v55;
  const __CFString *v56;
  const __CFString *v57;
  const __CFString *v58;
  uint64_t v59;
  __int16 v60;
  __int16 v61;
  UniChar chars;
  uint64_t v63;
  CFRange v64;
  CFRange v65;

  v63 = *MEMORY[0x1E0C80C00];
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, theString);
  if (MutableCopy)
  {
    v6 = MutableCopy;
    CFStringLowercase(MutableCopy, a2);
    Count = CFArrayGetCount((CFArrayRef)&off_1E1488D50);
    v64.location = 0;
    v64.length = Count;
    v8 = CFArrayBSearchValues((CFArrayRef)&off_1E1488D50, v64, v6, (CFComparatorFunction)CFStringCompare, 0);
    if (v8 < Count)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)&off_1E1488D50, v8);
      if (CFStringCompare(v6, ValueAtIndex, 0) == kCFCompareEqualTo)
      {
        v25 = theString;
        goto LABEL_24;
      }
    }
    if (CFStringCompare(v6, CFSTR("seth"), 0) == kCFCompareEqualTo)
    {
      Length = CFStringGetLength(v6);
      CFStringReplaceAll(v6, theString);
      v23 = Length - 1;
      v17 = CFStringGetLength(v6);
      v18.location = v17 - v23;
      if (v17 >= v23)
      {
        v18.length = v23;
        CFStringReplace(v6, v18, CFSTR("ethe"));
LABEL_23:
        v25 = v6;
LABEL_24:
        v26 = CFRetain(v25);
        CFRelease(v6);
        if (v26)
          return v26;
        return CFRetain(theString);
      }
      goto LABEL_57;
    }
    if (CFStringHasSuffix(v6, CFSTR("a")))
    {
      CFStringReplaceAll(v6, theString);
      v17 = CFStringGetLength(v6);
      if (v17 > 0)
      {
        v19.location = v17 - 1;
        v20 = CFSTR("o");
LABEL_8:
        v21 = v6;
        v19.length = 1;
LABEL_22:
        CFStringReplace(v21, v19, v20);
        goto LABEL_23;
      }
      goto LABEL_57;
    }
    v57 = CFSTR("uk");
    v58 = 0;
    v55 = CFSTR("k");
    v56 = CFSTR("ck");
    v53 = CFSTR("g");
    v54 = CFSTR("ik");
    if (__CFStringHasOneOfSuffixes(v6, v10, v11, v12, v13, v14, v15, v16, (uint64_t)CFSTR("h")))
    {
      CFStringReplaceAll(v6, theString);
      chars = 117;
      p_chars = &chars;
LABEL_13:
      CFStringAppendCharacters(v6, p_chars, 1);
      goto LABEL_23;
    }
    if (CFStringHasSuffix(v6, CFSTR("nec")))
    {
      CFStringReplaceAll(v6, theString);
      v17 = CFStringGetLength(v6);
      if (v17 > 1)
      {
        v19.location = v17 - 2;
        v20 = CFSTR("e");
LABEL_21:
        v21 = v6;
        v19.length = 2;
        goto LABEL_22;
      }
    }
    else if (CFStringHasSuffix(v6, CFSTR("ius")))
    {
      CFStringReplaceAll(v6, theString);
      v17 = CFStringGetLength(v6);
      if (v17 > 1)
      {
        v19.location = v17 - 2;
        v20 = CFSTR("e");
        goto LABEL_21;
      }
    }
    else
    {
      if (CFStringHasSuffix(v6, CFSTR("uce")))
      {
        CFStringReplaceAll(v6, theString);
        v17 = CFStringGetLength(v6);
        if (v17 > 0)
        {
          v19.location = v17 - 1;
          v20 = CFSTR("i");
          goto LABEL_8;
        }
        goto LABEL_57;
      }
      v57 = CFSTR("xel");
      v58 = 0;
      v55 = CFSTR("rel");
      v56 = CFSTR("bel");
      if (!__CFStringHasOneOfSuffixes(v6, v28, v29, v30, v31, v32, v33, v34, (uint64_t)CFSTR("vel")))
      {
        if (CFStringHasSuffix(v6, CFSTR("les")))
        {
          CFStringReplaceAll(v6, theString);
          v65.location = CFStringGetLength(v6) - 1;
          v65.length = 1;
          CFStringDelete(v6, v65);
          goto LABEL_23;
        }
        v57 = CFSTR("o");
        v58 = 0;
        v55 = CFSTR("c");
        v56 = CFSTR("lix");
        v53 = CFSTR("j");
        v54 = CFSTR("ex");
        v51 = CFSTR("");
        v52 = CFSTR("el");
        v50 = CFSTR("z");
        if (__CFStringHasOneOfSuffixes(v6, v35, v36, v37, v38, v39, v40, v41, (uint64_t)CFSTR("s")))
        {
          CFStringReplaceAll(v6, theString);
          v61 = 105;
          p_chars = (UniChar *)&v61;
          goto LABEL_13;
        }
        if (CFStringHasSuffix(v6, CFSTR("dk")))
        {
          CFStringReplaceAll(v6, theString);
          v17 = CFStringGetLength(v6);
          if (v17 <= 2)
            goto LABEL_57;
          v19.location = v17 - 3;
          v20 = CFSTR("ku");
        }
        else
        {
          if (!CFStringHasSuffix(v6, CFSTR("nk")))
          {
            if (CFStringHasSuffix(v6, CFSTR("ek")))
            {
              CFStringReplaceAll(v6, theString);
              v17 = CFStringGetLength(v6);
              if (v17 > 1)
              {
                v19.location = v17 - 2;
                v20 = CFSTR("ku");
                goto LABEL_21;
              }
            }
            else if (CFStringHasSuffix(v6, CFSTR("ter")))
            {
              CFStringReplaceAll(v6, theString);
              v17 = CFStringGetLength(v6);
              if (v17 > 1)
              {
                v19.location = v17 - 2;
                v20 = CFSTR("e");
                goto LABEL_21;
              }
            }
            else
            {
              if (!CFStringHasSuffix(v6, CFSTR("tr")))
              {
                v58 = CFSTR("b");
                v59 = 0;
                v56 = CFSTR("p");
                v57 = CFSTR("f");
                v54 = CFSTR("m");
                v55 = CFSTR("l");
                v52 = CFSTR("n");
                v53 = CFSTR("v");
                v50 = CFSTR("d");
                v51 = CFSTR("t");
                if (!__CFStringHasOneOfSuffixes(v6, v42, v43, v44, v45, v46, v47, v48, (uint64_t)CFSTR("h")))
                {
                  CFRelease(v6);
                  return CFRetain(theString);
                }
                CFStringReplaceAll(v6, theString);
                v60 = 101;
                p_chars = (UniChar *)&v60;
                goto LABEL_13;
              }
              CFStringReplaceAll(v6, theString);
              v17 = CFStringGetLength(v6);
              if (v17 > 0)
              {
                v19.location = v17 - 1;
                v20 = CFSTR("e");
                goto LABEL_8;
              }
            }
            goto LABEL_57;
          }
          CFStringReplaceAll(v6, theString);
          v17 = CFStringGetLength(v6);
          if (v17 <= 2)
            goto LABEL_57;
          v19.location = v17 - 3;
          v20 = CFSTR("ku");
        }
        v21 = v6;
        v19.length = 3;
        goto LABEL_22;
      }
      CFStringReplaceAll(v6, theString);
      v17 = CFStringGetLength(v6);
      if (v17 > 1)
      {
        v19.location = v17 - 2;
        v20 = CFSTR("le");
        goto LABEL_21;
      }
    }
LABEL_57:
    MEMORY[0x1E0C80A78](v17, v18.location);
    v49 = &v50;
    __strlcpy_chk();
    __strlcat_chk();
    goto LABEL_58;
  }
  MEMORY[0x1E0C80A78](0, v5);
  v49 = &v52;
  __strlcpy_chk();
  __strlcat_chk();
LABEL_58:
  result = (CFTypeRef)__strlcat_chk();
  qword_1EDCD1038 = (uint64_t)v49;
  __break(1u);
  return result;
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_el(CFStringRef theString1, const __CFLocale *a2)
{
  uint64_t v4;
  __CFString *MutableCopy;
  uint64_t v6;
  __CFString *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFIndex Length;
  uint64_t v16;
  CFTypeRef result;
  CFRange v18;
  const __CFString *v19;
  CFTypeRef v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  _QWORD v32[5];
  const __CFString *v33;
  uint64_t v34;
  uint64_t v35;
  CFRange v36;

  v4 = 0;
  v35 = *MEMORY[0x1E0C80C00];
  do
  {
    if (CFStringCompare(theString1, _CFStringCopyVocativeCaseOfGivenName_el_keys[v4], 0) == kCFCompareEqualTo)
      return CFRetain(_CFStringCopyVocativeCaseOfGivenName_el_values[v4]);
    ++v4;
  }
  while (v4 != 12);
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, theString1);
  if (MutableCopy)
  {
    v7 = MutableCopy;
    CFStringLowercase(MutableCopy, a2);
    v33 = CFSTR("");
    v34 = 0;
    v32[3] = CFSTR("");
    v32[4] = CFSTR("");
    if (__CFStringHasOneOfSuffixes(v7, v8, v9, v10, v11, v12, v13, v14, (uint64_t)CFSTR("")))
      goto LABEL_6;
    if (CFStringHasSuffix(v7, CFSTR("")))
      goto LABEL_10;
    if (CFStringHasSuffix(v7, CFSTR("")))
    {
      CFStringReplaceAll(v7, theString1);
      Length = CFStringGetLength(v7);
      if (Length > 1)
      {
        v18.location = Length - 2;
        v19 = CFSTR("");
        goto LABEL_15;
      }
LABEL_32:
      MEMORY[0x1E0C80A78](Length, v16);
      v30 = &v31;
      __strlcpy_chk();
      __strlcat_chk();
      goto LABEL_33;
    }
    if (CFStringHasSuffix(v7, CFSTR("")))
    {
      v28 = __CFStringApproximateSyllableCount_el_GR(v7);
      if (v28 == 2)
      {
LABEL_6:
        CFStringReplaceAll(v7, theString1);
        Length = CFStringGetLength(v7);
        if (Length > 0)
        {
          v36.location = Length - 1;
          v36.length = 1;
          CFStringDelete(v7, v36);
          goto LABEL_16;
        }
        goto LABEL_32;
      }
      if (v28 >= 3)
      {
LABEL_10:
        CFStringReplaceAll(v7, theString1);
        Length = CFStringGetLength(v7);
        if (Length > 1)
        {
          v18.location = Length - 2;
          v19 = CFSTR("");
LABEL_15:
          v18.length = 2;
          CFStringReplace(v7, v18, v19);
          goto LABEL_16;
        }
        goto LABEL_32;
      }
    }
    else
    {
      v33 = CFSTR("");
      v34 = 0;
      if (__CFStringHasOneOfSuffixes(v7, v21, v22, v23, v24, v25, v26, v27, (uint64_t)CFSTR("")))
      {
        v29 = __CFStringApproximateSyllableCount_el_GR(v7);
        switch(v29)
        {
          case 4:
            goto LABEL_26;
          case 3:
            CFStringReplaceAll(v7, theString1);
            CFStringAppend(v7, CFSTR(""));
LABEL_16:
            v20 = CFRetain(v7);
            CFRelease(v7);
            if (v20)
              return v20;
            return CFRetain(theString1);
          case 2:
LABEL_26:
            CFStringReplaceAll(v7, theString1);
            Length = CFStringGetLength(v7);
            if (Length > 1)
            {
              v18.location = Length - 2;
              v19 = CFSTR("");
              goto LABEL_15;
            }
            goto LABEL_32;
        }
      }
    }
    CFRelease(v7);
    return CFRetain(theString1);
  }
  MEMORY[0x1E0C80A78](0, v6);
  v30 = v32;
  __strlcpy_chk();
  __strlcat_chk();
LABEL_33:
  result = (CFTypeRef)__strlcat_chk();
  qword_1EDCD1038 = (uint64_t)v30;
  __break(1u);
  return result;
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_uk(CFStringRef theString, const __CFLocale *a2)
{
  __CFString *MutableCopy;
  uint64_t v5;
  __CFString *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFIndex Length;
  CFRange v22;
  CFRange v23;
  const __CFString *v24;
  CFIndex v25;
  CFIndex v26;
  const __CFString *v27;
  CFIndex v28;
  CFIndex v29;
  CFIndex v30;
  CFTypeRef v31;
  CFTypeRef result;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  __CFString *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  UniChar *p_chars;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  const __CFString **v63;
  const __CFString *v64;
  const __CFString *v65;
  const __CFString *v66;
  const __CFString *v67;
  const __CFString *v68;
  const __CFString *v69;
  const __CFString *v70;
  const __CFString *v71;
  const __CFString *v72;
  uint64_t v73;
  __int16 v74;
  __int16 v75;
  UniChar chars;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, theString);
  if (MutableCopy)
  {
    v6 = MutableCopy;
    CFStringLowercase(MutableCopy, a2);
    if (CFStringCompare(v6, CFSTR(""), 0))
    {
      if (CFStringCompare(v6, CFSTR(""), 0))
      {
        if (CFStringCompare(v6, CFSTR(""), 0))
        {
          if (CFStringCompare(v6, CFSTR(""), 0))
          {
            v72 = CFSTR("");
            v73 = 0;
            v71 = CFSTR("");
            if (__CFStringHasOneOfSuffixes(v6, v7, v8, v9, v10, v11, v12, v13, (uint64_t)CFSTR("")))
              goto LABEL_7;
            v72 = CFSTR("");
            v73 = 0;
            v71 = CFSTR("");
            if (__CFStringHasOneOfSuffixes(v6, v14, v15, v16, v17, v18, v19, v20, (uint64_t)CFSTR("")))
            {
LABEL_22:
              CFStringReplaceAll(v6, theString);
              Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.location = Length - 1;
                v24 = CFSTR("");
                goto LABEL_30;
              }
              goto LABEL_53;
            }
            v72 = CFSTR("");
            v73 = 0;
            v70 = CFSTR("");
            v71 = CFSTR("");
            v69 = CFSTR("");
            if (__CFStringHasOneOfSuffixes(v6, v33, v34, v35, v36, v37, v38, v39, (uint64_t)CFSTR("")))
            {
              CFStringReplaceAll(v6, theString);
              Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.location = Length - 1;
                v24 = CFSTR("");
                goto LABEL_30;
              }
              goto LABEL_53;
            }
            v71 = CFSTR("");
            v72 = 0;
            v69 = CFSTR("");
            v70 = CFSTR("");
            v67 = CFSTR("");
            v68 = CFSTR("");
            v65 = CFSTR("");
            v66 = CFSTR("");
            if (__CFStringHasOneOfSuffixes(v6, v40, v41, v42, v43, v44, v45, v46, (uint64_t)CFSTR("")))
            {
              CFStringReplaceAll(v6, theString);
              Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.location = Length - 1;
                v24 = CFSTR("");
                goto LABEL_30;
              }
              goto LABEL_53;
            }
            if (CFStringHasSuffix(v6, CFSTR("")))
              goto LABEL_22;
            v71 = CFSTR("");
            v72 = 0;
            if (__CFStringHasOneOfSuffixes(v6, v48, v49, v50, v51, v52, v53, v54, (uint64_t)CFSTR("")))
            {
              CFStringReplaceAll(v6, theString);
              chars = 1091;
              p_chars = &chars;
              goto LABEL_35;
            }
            if (CFStringHasSuffix(v6, CFSTR("")))
            {
              CFStringReplaceAll(v6, theString);
              Length = CFStringGetLength(v6);
              if (Length > 0)
              {
                v23.location = Length - 1;
                v24 = CFSTR("");
                goto LABEL_30;
              }
              goto LABEL_53;
            }
            if (CFStringHasSuffix(v6, CFSTR("")))
            {
              CFStringReplaceAll(v6, theString);
              Length = CFStringGetLength(v6);
              if (Length > 1)
              {
                v23.location = Length - 2;
                v24 = CFSTR("");
LABEL_45:
                v47 = v6;
                v23.length = 2;
                goto LABEL_31;
              }
            }
            else
            {
              if (!CFStringHasSuffix(v6, CFSTR("")))
              {
                if (CFStringHasSuffix(v6, CFSTR("")))
                {
LABEL_7:
                  CFStringReplaceAll(v6, theString);
                  Length = CFStringGetLength(v6);
                  if (Length > 0)
                  {
                    v23.location = Length - 1;
                    v24 = CFSTR("");
LABEL_30:
                    v47 = v6;
                    v23.length = 1;
LABEL_31:
                    CFStringReplace(v47, v23, v24);
                    goto LABEL_18;
                  }
                  goto LABEL_53;
                }
                if (CFStringHasSuffix(v6, CFSTR("")))
                {
                  CFStringReplaceAll(v6, theString);
                  v75 = 1086;
                  p_chars = (UniChar *)&v75;
                }
                else
                {
                  v71 = CFSTR("");
                  v72 = 0;
                  v69 = CFSTR("");
                  v70 = CFSTR("");
                  v67 = CFSTR("");
                  v68 = CFSTR("");
                  v65 = CFSTR("");
                  v66 = CFSTR("");
                  v64 = CFSTR("");
                  if (!__CFStringHasOneOfSuffixes(v6, v56, v57, v58, v59, v60, v61, v62, (uint64_t)CFSTR("")))
                  {
                    CFRelease(v6);
                    return CFRetain(theString);
                  }
                  CFStringReplaceAll(v6, theString);
                  v74 = 1077;
                  p_chars = (UniChar *)&v74;
                }
LABEL_35:
                CFStringAppendCharacters(v6, p_chars, 1);
LABEL_18:
                v31 = CFRetain(v6);
                CFRelease(v6);
                if (v31)
                  return v31;
                return CFRetain(theString);
              }
              CFStringReplaceAll(v6, theString);
              Length = CFStringGetLength(v6);
              if (Length > 1)
              {
                v23.location = Length - 2;
                v24 = CFSTR("");
                goto LABEL_45;
              }
            }
LABEL_53:
            MEMORY[0x1E0C80A78](Length, v22.location);
            v63 = &v64;
            __strlcpy_chk();
            __strlcat_chk();
            goto LABEL_54;
          }
          v30 = CFStringGetLength(v6);
          CFStringReplaceAll(v6, theString);
          v26 = v30 - 1;
          Length = CFStringGetLength(v6);
          v22.location = Length - v26;
          if (Length < v26)
            goto LABEL_53;
          v27 = CFSTR("");
        }
        else
        {
          v29 = CFStringGetLength(v6);
          CFStringReplaceAll(v6, theString);
          v26 = v29 - 1;
          Length = CFStringGetLength(v6);
          v22.location = Length - v26;
          if (Length < v26)
            goto LABEL_53;
          v27 = CFSTR("");
        }
      }
      else
      {
        v28 = CFStringGetLength(v6);
        CFStringReplaceAll(v6, theString);
        v26 = v28 - 1;
        Length = CFStringGetLength(v6);
        v22.location = Length - v26;
        if (Length < v26)
          goto LABEL_53;
        v27 = CFSTR("");
      }
    }
    else
    {
      v25 = CFStringGetLength(v6);
      CFStringReplaceAll(v6, theString);
      v26 = v25 - 1;
      Length = CFStringGetLength(v6);
      v22.location = Length - v26;
      if (Length < v26)
        goto LABEL_53;
      v27 = CFSTR("");
    }
    v22.length = v26;
    CFStringReplace(v6, v22, v27);
    goto LABEL_18;
  }
  MEMORY[0x1E0C80A78](0, v5);
  v63 = &v66;
  __strlcpy_chk();
  __strlcat_chk();
LABEL_54:
  result = (CFTypeRef)__strlcat_chk();
  qword_1EDCD1038 = (uint64_t)v63;
  __break(1u);
  return result;
}

CFTypeRef _CFStringCopyVocativeCaseOfGivenName_lt(CFStringRef theString, const __CFLocale *a2)
{
  __CFString *MutableCopy;
  uint64_t v5;
  __CFString *v6;
  CFIndex Length;
  uint64_t v8;
  CFRange v9;
  const __CFString *v10;
  __CFString *v11;
  CFTypeRef v12;
  uint64_t *v14;
  uint64_t v15;
  _QWORD v16[10];
  CFRange v17;

  v16[9] = *MEMORY[0x1E0C80C00];
  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, theString);
  if (!MutableCopy)
  {
    MEMORY[0x1E0C80A78](0, v5);
    v14 = v16;
    __strlcpy_chk();
    __strlcat_chk();
    goto LABEL_25;
  }
  v6 = MutableCopy;
  CFStringLowercase(MutableCopy, a2);
  if (CFStringHasSuffix(v6, CFSTR("jas")))
  {
    CFStringReplaceAll(v6, theString);
    Length = CFStringGetLength(v6);
    if (Length > 0)
    {
      v9.location = Length - 1;
      v10 = CFSTR("u");
LABEL_8:
      v11 = v6;
      v9.length = 1;
LABEL_9:
      CFStringReplace(v11, v9, v10);
      goto LABEL_10;
    }
    goto LABEL_24;
  }
  if (CFStringHasSuffix(v6, CFSTR("as")))
  {
    CFStringReplaceAll(v6, theString);
    Length = CFStringGetLength(v6);
    if (Length > 0)
    {
      v9.location = Length - 1;
      v10 = CFSTR("i");
      goto LABEL_8;
    }
    goto LABEL_24;
  }
  if (CFStringHasSuffix(v6, CFSTR("us")))
  {
    CFStringReplaceAll(v6, theString);
    Length = CFStringGetLength(v6);
    if (Length > 1)
    {
      v9.location = Length - 2;
      v10 = CFSTR("au");
      v11 = v6;
      v9.length = 2;
      goto LABEL_9;
    }
LABEL_24:
    MEMORY[0x1E0C80A78](Length, v8);
    v14 = &v15;
    __strlcpy_chk();
    __strlcat_chk();
LABEL_25:
    __strlcat_chk();
    qword_1EDCD1038 = (uint64_t)v14;
    __break(1u);
  }
  if (!CFStringHasSuffix(v6, CFSTR("is")) && !CFStringHasSuffix(v6, CFSTR("ys")))
  {
    if (!CFStringHasSuffix(v6, CFSTR("")))
    {
      CFRelease(v6);
      return CFRetain(theString);
    }
    CFStringReplaceAll(v6, theString);
    Length = CFStringGetLength(v6);
    if (Length > 0)
    {
      v9.location = Length - 1;
      v10 = CFSTR("e");
      goto LABEL_8;
    }
    goto LABEL_24;
  }
  CFStringReplaceAll(v6, theString);
  v17.location = CFStringGetLength(v6) - 1;
  v17.length = 1;
  CFStringDelete(v6, v17);
LABEL_10:
  v12 = CFRetain(v6);
  CFRelease(v6);
  if (v12)
    return v12;
  return CFRetain(theString);
}

BOOL __CFStringHasOneOfSuffixes(CFStringRef theString, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFStringRef *v10;
  CFStringRef v11;
  CFStringRef *v13;

  v13 = (CFStringRef *)&a9;
  do
  {
    v10 = v13++;
    v11 = *v10;
  }
  while (*v10 && !CFStringHasSuffix(theString, *v10));
  return v11 != 0;
}

uint64_t __CFStringApproximateSyllableCount_el_GR(const __CFString *a1)
{
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  CFIndex v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  UniChar v8;
  BOOL v9;
  unint64_t v10;
  int64_t v11;
  CFIndex v12;
  UniChar v13;
  CFIndex v14;
  UniChar v15;
  CFIndex v16;
  UniChar v17;
  unint64_t v18;
  unint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unint64_t v23;
  unsigned int v24;
  int v25;
  _OWORD v28[8];
  CFStringRef theString;
  const UniChar *v30;
  const char *v31;
  uint64_t v32;
  CFIndex Length;
  unint64_t v34;
  int64_t v35;
  uint64_t v36;
  CFRange v37;
  CFRange v38;
  CFRange v39;
  CFRange v40;

  v36 = *MEMORY[0x1E0C80C00];
  theString = a1;
  v32 = 0;
  Length = CFStringGetLength(a1);
  CharactersPtr = CFStringGetCharactersPtr(theString);
  CStringPtr = 0;
  v30 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  memset(v28, 0, sizeof(v28));
  v34 = 0;
  v35 = 0;
  v31 = CStringPtr;
  v4 = Length;
  if (Length >= 1)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    while (2)
    {
      if (v30)
      {
        v8 = v30[v32 + v5];
      }
      else if (v31)
      {
        v8 = v31[v32 + v5];
      }
      else
      {
        v9 = v35 > (uint64_t)v5 && v7 <= (uint64_t)v5;
        if (!v9)
        {
          v10 = v5 - 4;
          if (v5 < 4)
            v10 = 0;
          if ((uint64_t)(v10 + 64) < v4)
            v4 = v10 + 64;
          v34 = v10;
          v35 = v4;
          v37.location = v32 + v10;
          v37.length = v4 - v10;
          CFStringGetCharacters(theString, v37, (UniChar *)v28);
          v7 = v34;
        }
        v8 = *((_WORD *)v28 + v5 - v7);
      }
      switch(v8)
      {
        case 0x3ACu:
        case 0x3ADu:
        case 0x3AEu:
        case 0x3AFu:
        case 0x3B7u:
        case 0x3C9u:
        case 0x3CCu:
        case 0x3CDu:
        case 0x3CEu:
          goto LABEL_20;
        case 0x3B0u:
        case 0x3B2u:
        case 0x3B3u:
        case 0x3B4u:
        case 0x3B6u:
        case 0x3B8u:
        case 0x3BAu:
        case 0x3BBu:
        case 0x3BCu:
        case 0x3BDu:
        case 0x3BEu:
        case 0x3C0u:
        case 0x3C1u:
        case 0x3C2u:
        case 0x3C3u:
        case 0x3C4u:
        case 0x3C6u:
        case 0x3C7u:
        case 0x3C8u:
        case 0x3CAu:
        case 0x3CBu:
          goto LABEL_21;
        case 0x3B1u:
        case 0x3B5u:
        case 0x3C5u:
          v11 = v5 + 1;
          v12 = Length;
          if (Length <= (uint64_t)(v5 + 1))
            goto LABEL_20;
          if (v30)
          {
            v13 = v30[v32 + v11];
          }
          else if (v31)
          {
            v13 = v31[v32 + v11];
          }
          else
          {
            if (v35 <= v11 || v7 > v11)
            {
              v18 = v5 - 3;
              if (v5 < 3)
                v18 = 0;
              if ((uint64_t)(v18 + 64) < Length)
                v12 = v18 + 64;
              v34 = v18;
              v35 = v12;
              v38.location = v32 + v18;
              v38.length = v12 - v18;
              CFStringGetCharacters(theString, v38, (UniChar *)v28);
              v7 = v34;
            }
            v13 = *((_WORD *)v28 + v11 - v7);
          }
          if (v13 != 953 && v13 != 943)
            goto LABEL_20;
          goto LABEL_77;
        case 0x3B9u:
          v11 = v5 + 1;
          v14 = Length;
          if (Length > (uint64_t)(v5 + 1))
          {
            if (v30)
            {
              v15 = v30[v32 + v11];
            }
            else if (v31)
            {
              v15 = v31[v32 + v11];
            }
            else
            {
              if (v35 <= v11 || v7 > v11)
              {
                v19 = v5 - 3;
                if (v5 < 3)
                  v19 = 0;
                if ((uint64_t)(v19 + 64) < Length)
                  v14 = v19 + 64;
                v34 = v19;
                v35 = v14;
                v39.location = v32 + v19;
                v39.length = v14 - v19;
                CFStringGetCharacters(theString, v39, (UniChar *)v28);
                v7 = v34;
              }
              v15 = *((_WORD *)v28 + v11 - v7);
            }
            v20 = v15 - 940;
            v9 = v20 > 0x22;
            v21 = (1 << v20) & 0x420000021;
            if (!v9 && v21 != 0)
              goto LABEL_77;
          }
          goto LABEL_20;
        case 0x3BFu:
          v11 = v5 + 1;
          v16 = Length;
          if (Length > (uint64_t)(v5 + 1))
          {
            if (v30)
            {
              v17 = v30[v32 + v11];
            }
            else if (v31)
            {
              v17 = v31[v32 + v11];
            }
            else
            {
              if (v35 <= v11 || v7 > v11)
              {
                v23 = v5 - 3;
                if (v5 < 3)
                  v23 = 0;
                if ((uint64_t)(v23 + 64) < Length)
                  v16 = v23 + 64;
                v34 = v23;
                v35 = v16;
                v40.location = v32 + v23;
                v40.length = v16 - v23;
                CFStringGetCharacters(theString, v40, (UniChar *)v28);
                v7 = v34;
              }
              v17 = *((_WORD *)v28 + v11 - v7);
            }
            v24 = v17 - 943;
            v9 = v24 > 0x1E;
            v25 = (1 << v24) & 0x40400401;
            if (!v9 && v25 != 0)
LABEL_77:
              v5 = v11;
          }
LABEL_20:
          ++v6;
          goto LABEL_21;
        default:
          if (!v8)
            return v6;
LABEL_21:
          ++v5;
          v4 = Length;
          if (Length <= (uint64_t)v5)
            return v6;
          continue;
      }
    }
  }
  return 0;
}

void boundPairCommonFinalize(uint64_t a1)
{
  __CFRunLoopSource *v2;

  cbDestroy(*(void ***)(a1 + 96));
  if (*(_QWORD *)(a1 + 8))
  {
    CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(a1 + 56));
    CFRelease(*(CFTypeRef *)(a1 + 8));
    *(_QWORD *)(a1 + 8) = 0;
  }
  v2 = *(__CFRunLoopSource **)(a1 + 56);
  if (v2)
  {
    CFRunLoopSourceInvalidate(v2);
    CFRelease(*(CFTypeRef *)(a1 + 56));
    *(_QWORD *)(a1 + 56) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 104));
  CFAllocatorDeallocate(*(CFAllocatorRef *)(a1 + 88), (void *)a1);
}

void boundPairReadFinalize(uint64_t a1, uint64_t a2)
{
  pthread_mutex_t *v3;
  int v4;
  const void *v5;
  const void *v6;

  if (a2)
  {
    v3 = (pthread_mutex_t *)(a2 + 104);
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 104));
    v4 = *(unsigned __int8 *)(a2 + 48);
    *(_BYTE *)a2 = 1;
    *(_WORD *)(a2 + 4) = 0;
    v5 = *(const void **)(a2 + 16);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(a2 + 16) = 0;
    }
    v6 = *(const void **)(a2 + 40);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a2 + 40) = 0;
    }
    pthread_mutex_unlock(v3);
    if (v4)
      boundPairCommonFinalize(a2);
  }
}

uint64_t boundPairReadOpenComplete(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*(_WORD *)(a3 + 4))
  {
    CFReadStreamSignalEvent(a1, 1uLL, 0, a4, a5, a6, a7, a8);
    if (boundPairReadCanRead(v10, a3))
      CFReadStreamSignalEvent(a1, 2uLL, 0, v11, v12, v13, v14, v15);
    _wakeReadStreamScheduledRunLoops();
  }
  return 1;
}

const void *boundPairReadCopyProperty(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  const void *v3;
  const void *Value;

  v3 = 0;
  if (a2 && a3)
  {
    if (*(_QWORD *)(a3 + 40) && CFStringCompare(CFSTR("_kCFStreamPropertyHTTPTrailer"), a2, 1uLL) == kCFCompareEqualTo)
    {
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 40), a2);
      v3 = Value;
      if (Value)
        CFRetain(Value);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

__CFDictionary *boundPairReadSetProperty(uint64_t a1, const __CFString *a2, const void *a3, uint64_t a4)
{
  CFComparisonResult v7;
  __CFDictionary *result;

  if (!a2)
    return 0;
  v7 = CFStringCompare(CFSTR("_kCFStreamPropertyHTTPTrailer"), a2, 1uLL);
  result = 0;
  if (a4)
  {
    if (v7 == kCFCompareEqualTo)
    {
      result = *(__CFDictionary **)(a4 + 40);
      if (result
        || (result = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks), (*(_QWORD *)(a4 + 40) = result) != 0))
      {
        if (a3)
          CFDictionarySetValue(result, a2, a3);
        else
          CFDictionaryRemoveValue(result, a2);
        return (__CFDictionary *)1;
      }
    }
  }
  return result;
}

void boundPairReadUnschedule(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  BOOL v5;
  int v6;

  if (a4)
  {
    v4 = *(__int16 *)(a4 + 4);
    v5 = __OFSUB__(v4, 1);
    v6 = v4 - 1;
    if (v6 < 0 == v5)
      *(_WORD *)(a4 + 4) = v6;
  }
}

uint64_t boundPairWriteOpenComplete(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (*(_WORD *)(a3 + 52))
  {
    CFWriteStreamSignalEvent(a1, 1uLL, 0, a4, a5, a6, a7, a8);
    CFWriteStreamSignalEvent(a1, 4uLL, 0, v9, v10, v11, v12, v13);
    _wakeWriteStreamScheduledRunLoops();
  }
  return 1;
}

BOOL boundPairCanWrite(uint64_t a1, uint64_t a2)
{
  if (!a2)
    return 0;
  if (*(_BYTE *)(a2 + 48))
    return 0;
  return _cbCanWrite(*(_QWORD *)(a2 + 96));
}

uint64_t (**__CFStringEncodingGetSimplifiedChineseConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  uint64_t (**v4)();
  uint64_t (**v5)();

  if (!__CFStringEncodingIsDecomposableCharacter)
  {
    __CFStringEncodingIsDecomposableCharacter = (_UNKNOWN *)a2(1);
    __CFStringEncodingDecomposeCharacter = (_UNKNOWN *)a2(2);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_1 = (_UNKNOWN *)a2(3);
    __CFStringEncodingPrecomposeLatinCharacter_3 = (_UNKNOWN *)a2(4);
  }
  v4 = __CFConverterEUC_CN;
  v5 = __CFConverterMacSimplifiedChinese;
  if (a1 != 25)
    v5 = 0;
  if (a1 != 2352)
    v4 = v5;
  if (a1 == 2565)
    return __CFConverterGB_HZ;
  else
    return v4;
}

uint64_t __CFToEUC_CN(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  uint64_t result;
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;
  unsigned __int16 v9;

  if (a2 < 0x80)
  {
    result = 1;
    goto LABEL_3;
  }
  if ((unsigned __int16)(a2 + 15) < 0xB3u)
    return 0;
  v4 = (unsigned __int16 *)&__CFToGB2312CharMap;
  v5 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + 36516);
  while (1)
  {
    v6 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v5 - v4)) >> 1;
    v7 = &v4[17 * v6];
    v8 = *v7;
    if (v8 <= a2)
      break;
    v5 = v7 - 17;
LABEL_10:
    if (v4 > v5)
      return 0;
  }
  if (v8 + 16 <= a2)
  {
    v4 = v7 + 17;
    goto LABEL_10;
  }
  v9 = v4[17 * v6 + 1 + (int)(a2 - v8)];
  if (!v9 || v9 == 65533)
    return 0;
  LOBYTE(a2) = v9 | 0x80;
  *a3++ = (unsigned __int16)(v9 | 0x8080) >> 8;
  result = 2;
LABEL_3:
  *a3 = a2;
  return result;
}

uint64_t __CFFromEUC_CN(uint64_t a1, char *a2, uint64_t a3, unsigned __int16 *a4)
{
  unsigned __int16 v4;
  uint64_t result;
  unsigned int v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  uint64_t v9;
  unsigned __int16 *v10;
  unsigned int v11;
  unsigned __int16 v12;

  v4 = *a2;
  if ((*a2 & 0x80000000) == 0)
  {
    *a4 = v4;
    return 1;
  }
  result = 0;
  if (a3 >= 2 && (v4 + 1) >= 0xA2u)
  {
    v6 = a2[1] & 0x7F | ((v4 & 0x7F) << 8);
    if ((unsigned __int16)(v6 - 30594) < 0xA99Fu)
      goto LABEL_12;
    v7 = (unsigned __int16 *)&__CFFromGB2312CharMap;
    v8 = (unsigned __int16 *)((char *)&__CFFromGB2312CharMap + 15906);
    while (1)
    {
      v9 = (0xF83E0F83E0F83E1 * (v8 - v7)) >> 1;
      v10 = &v7[33 * v9];
      v11 = *v10;
      if (v11 <= v6)
      {
        if (v11 + 32 > v6)
        {
          v12 = v7[33 * v9 + 1 + (int)(v6 - v11)];
          if (v12)
          {
            *a4 = v12;
            if (v12 != 65533)
              return 2;
            return 0;
          }
LABEL_12:
          *a4 = -3;
          return 0;
        }
        v7 = v10 + 33;
      }
      else
      {
        v8 = v10 - 33;
      }
      if (v7 > v8)
        goto LABEL_12;
    }
  }
  return result;
}

uint64_t __CFToEUC_CNLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t result;
  unsigned int v4;
  uint64_t v5;

  for (result = 0; a3; --a3)
  {
    v4 = *a2++;
    if (v4 < 0x80)
      v5 = 1;
    else
      v5 = 2;
    result += v5;
  }
  return result;
}

uint64_t __CFFromEUC_CNLen(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t result;
  _BOOL4 v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;

  if (a3 < 1)
    return 0;
  result = 0;
  do
  {
    v5 = a3 == 1 || *a2 >= 0;
    v6 = !v5;
    if (v5)
      v7 = 1;
    else
      v7 = 2;
    a2 += v7;
    if (v6)
      v8 = -2;
    else
      v8 = -1;
    ++result;
    v9 = __OFADD__(v8, a3);
    a3 += v8;
  }
  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

uint64_t __CFToEUC_CNPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  char v19;
  BOOL v20;
  uint64_t result;
  _BYTE v22[2];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v9 = *a2;
  if (v9 > 0x7F)
  {
    v11 = a2[1];
    if (v9 == 12454)
      v12 = 12532;
    else
      v12 = v9 + 1;
    v13 = v9 + 2;
    if (v11 != 12442)
      v13 = 65533;
    if (v11 == 12441)
      v14 = v12;
    else
      v14 = v13;
    if ((v9 & 0xFFFFFFDF) == 0x418)
      v15 = v9 + 1;
    else
      v15 = -3;
    if (v9 == 1077)
      v16 = 1105;
    else
      v16 = -3;
    if (v9 == 1045)
      v17 = 1025;
    else
      v17 = v16;
    if (v11 != 776)
      v17 = 65533;
    if (v11 == 774)
      v17 = v15;
    if (a2[1] <= 0x3098u)
      v10 = v17;
    else
      v10 = v14;
  }
  else
  {
    v10 = __CFStringEncodingPrecomposeLatinCharacter_3(a2, a3, 0);
  }
  v18 = __CFToEUC_CN(v10, (unsigned __int16)v10, v22);
  v19 = v22[0];
  if (v18)
    v20 = v22[0] == 0;
  else
    v20 = 1;
  if (!v20)
  {
    result = 2;
    *a6 = 2;
    if (!a5)
      return result;
    if (a5 >= 2)
    {
      *a4 = v19;
      a4[1] = v22[1];
      return 2;
    }
  }
  return 0;
}

uint64_t __CFIsValidCombiningCharSimplifiedChinese(int a1)
{
  if ((a1 - 774) <= 0x32 && ((1 << (a1 - 6)) & 0x4000000000005) != 0
    || (a1 - 12441) < 2)
  {
    return 1;
  }
  else
  {
    return __CFStringEncodingIsValidCombiningCharacterForLatin1_1();
  }
}

uint64_t __CFToMacSimplifiedChinese(char a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  uint64_t v14;
  char *v17;
  char IsValidCombiningCharacterForLatin1_1;
  uint64_t v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  uint64_t v22;
  unsigned __int16 *v23;
  unsigned int v24;
  unsigned __int16 *v25;
  uint64_t v26;
  unsigned __int16 *v27;
  unsigned int v28;
  BOOL v29;
  char *v30;
  int v31;
  unsigned int v32;
  unsigned __int16 *v33;
  char *v34;
  unsigned __int16 v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  __int16 v39;
  unsigned __int16 *v40;
  unsigned __int16 *v41;
  uint64_t v42;
  unsigned __int16 *v43;
  unsigned int v44;
  unsigned __int16 *v45;
  unsigned __int16 *v46;
  uint64_t v47;
  unsigned __int16 *v48;
  unsigned int v49;
  unsigned __int16 v50;
  unsigned int v52;
  char v53;
  uint64_t v55;
  _BYTE *v56;
  _QWORD v58[2];

  v58[1] = *MEMORY[0x1E0C80C00];
  if (a3 < 1)
  {
    v19 = 0;
    v12 = 0;
    goto LABEL_171;
  }
  v11 = 0;
  v12 = 0;
  v55 = a3 + 1;
  v13 = (unsigned __int16 *)&__CFToMacSimplifiedChineseMap;
  while (1)
  {
    if (!a5 || v11 < a5)
      goto LABEL_15;
    if ((a1 & 0x10) == 0)
      goto LABEL_170;
    v14 = *a2;
    if ((v14 - 774) <= 0x32 && ((1 << (v14 - 6)) & 0x4000000000005) != 0
      || (v14 - 12441) < 2)
    {
      goto LABEL_16;
    }
    v17 = (char *)v13;
    IsValidCombiningCharacterForLatin1_1 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1(*a2, 1, 0x4000000000005);
    v13 = (unsigned __int16 *)v17;
    if ((IsValidCombiningCharacterForLatin1_1 & 1) == 0)
    {
      v14 = *a2;
      if ((v14 & 0xFFF0) != 0xF870)
        goto LABEL_170;
    }
    else
    {
LABEL_15:
      v14 = *a2;
      if (v14 < 0x80)
        goto LABEL_18;
    }
LABEL_16:
    if (a1 < 0 && (unsigned __int16)(v14 - 131) <= 0x1Cu)
    {
LABEL_18:
      v19 = v11 + 1;
      if (a5)
        *a4++ = v14;
      goto LABEL_55;
    }
    if (v12 + 1 < a3 && (_DWORD)v14 == 252)
    {
      if ((__int16)a2[1] == -1921)
      {
        v19 = v11 + 1;
        if (a5)
          *a4++ = 0x80;
        ++a2;
        ++v12;
        goto LABEL_55;
      }
      goto LABEL_27;
    }
    if ((unsigned __int16)(v14 + 443) < 0x25Bu)
      break;
LABEL_27:
    v20 = v13 + 78;
    v21 = v13;
    while (1)
    {
      v22 = ((char *)v20 - (char *)v21) >> 3;
      v23 = &v21[2 * v22];
      v24 = *v23;
      if (v24 <= v14)
        break;
      v20 = v23 - 2;
LABEL_32:
      if (v21 > v20)
        goto LABEL_33;
    }
    if (v24 < v14)
    {
      v21 = v23 + 2;
      goto LABEL_32;
    }
    LODWORD(v21) = v21[2 * v22 + 1];
    if (v21 > 0xFF)
    {
      v19 = v11 + 2;
      if (a5)
      {
        if (v19 > a5)
          goto LABEL_170;
        *a4 = BYTE1(v21);
        goto LABEL_127;
      }
    }
    else
    {
      v19 = v11 + 1;
      if (a5)
        *a4++ = (_BYTE)v21;
    }
LABEL_55:
    ++a2;
    ++v12;
    v11 = v19;
    if (v12 >= a3)
      goto LABEL_171;
  }
LABEL_33:
  if ((unsigned __int16)(v14 + 15) < 0xB3u)
    goto LABEL_51;
  v21 = (unsigned __int16 *)&__CFToGB2312CharMap;
  v25 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + 36516);
  while (2)
  {
    v26 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v25 - v21)) >> 1;
    v27 = &v21[17 * v26];
    v28 = *v27;
    if (v28 > v14)
    {
      v25 = v27 - 17;
      goto LABEL_39;
    }
    if (v28 + 16 <= v14)
    {
      v21 = v27 + 17;
LABEL_39:
      if (v21 > v25)
        goto LABEL_51;
      continue;
    }
    break;
  }
  LOWORD(v21) = v21[17 * v26 + 1 + (int)(v14 - v28)];
  if ((_WORD)v21)
    v29 = (unsigned __int16)v21 == 65533;
  else
    v29 = 1;
  if (!v29)
  {
    v19 = v11 + 2;
    if (a5)
    {
      if (v19 > a5)
        goto LABEL_170;
      *a4 = BYTE1(v21) | 0x80;
      LOBYTE(v21) = v21 | 0x80;
LABEL_127:
      a4[1] = (_BYTE)v21;
      a4 += 2;
    }
    goto LABEL_55;
  }
LABEL_51:
  if ((a1 & 8) != 0 || v12 < 1)
    goto LABEL_170;
  if ((a1 & 0x10) == 0)
  {
LABEL_54:
    v19 = v11;
    goto LABEL_55;
  }
  v56 = a4;
  if ((int)v14 > 823)
  {
    if ((v14 - 12441) >= 2 && (_DWORD)v14 != 824)
      goto LABEL_71;
  }
  else
  {
    if ((_DWORD)v14 == 768)
    {
      if (*(a2 - 1) == 110)
      {
        v19 = v11 + 1;
        if (a5)
          *(_WORD *)(a4++ - 1) = -16472;
        goto LABEL_55;
      }
      goto LABEL_71;
    }
    if ((_DWORD)v14 != 774 && (_DWORD)v14 != 776)
    {
LABEL_71:
      v30 = (char *)v13;
      v31 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1(v14, 1, 0x4000000000005);
      v13 = (unsigned __int16 *)v30;
      a4 = v56;
      if (!v31)
      {
        if ((_DWORD)v14 == 63615)
        {
          if (*(a2 - 1) != 252)
            goto LABEL_170;
          v19 = v11 - 1;
          if (a5)
            *(v56 - 2) = 0x80;
          a4 = v56 - 1;
          goto LABEL_55;
        }
        if ((_DWORD)v14 != 63614)
          goto LABEL_170;
        v52 = *(a2 - 1);
        if (v52 > 0xFF00)
        {
          if (*(a2 - 1) <= 0xFF19u)
          {
            if (v52 == 65281)
            {
              v53 = -34;
            }
            else
            {
              if (v52 != 65292)
                goto LABEL_170;
              v53 = -39;
            }
          }
          else
          {
            switch(v52)
            {
              case 0xFF1Au:
                v53 = -36;
                break;
              case 0xFF1Bu:
                v53 = -35;
                break;
              case 0xFF1Fu:
                v53 = -33;
                break;
              default:
                goto LABEL_170;
            }
          }
        }
        else if (*(a2 - 1) <= 0x3001u)
        {
          if (v52 == 8943)
          {
            v53 = -13;
          }
          else
          {
            if (v52 != 12289)
              goto LABEL_170;
            v53 = -37;
          }
        }
        else
        {
          switch(v52)
          {
            case 0x3002u:
              v53 = -38;
              break;
            case 0x3016u:
              v53 = -20;
              break;
            case 0x3017u:
              v53 = -19;
              break;
            default:
              goto LABEL_170;
          }
        }
        if (a5)
        {
          *(v56 - 2) = -90;
          *(v56 - 1) = v53;
        }
        goto LABEL_54;
      }
    }
  }
  v58[0] = 2;
  v33 = a2 - 1;
  v32 = *(a2 - 1);
  if (v32 < 0x80)
  {
    v34 = (char *)v13;
    v35 = __CFStringEncodingPrecomposeLatinCharacter_3(a2 - 1, v55 - v12, v58);
    v13 = (unsigned __int16 *)v34;
    v36 = v58[0] - 2;
    if (v58[0] <= 2)
      v37 = 0;
    else
      v37 = v58[0] - 2;
    goto LABEL_76;
  }
  v38 = *a2;
  if (v38 > 0x3098)
  {
    if (v38 != 12441)
    {
      if (v38 == 12442)
      {
        v36 = 0;
        v37 = 0;
        v35 = v32 + 2;
        goto LABEL_76;
      }
      goto LABEL_172;
    }
    v36 = 0;
    v37 = 0;
    if (v32 == 12454)
      v35 = 12532;
    else
      v35 = v32 + 1;
LABEL_76:
    v12 += v37;
    if (v35 != 252)
    {
      a4 = v56;
      goto LABEL_95;
    }
    a4 = v56;
    if (v12 >= a3)
      goto LABEL_95;
    if ((__int16)a2[1] == -1921)
    {
      if (a5)
        *(v56 - 1) = 0x80;
      ++v12;
      goto LABEL_54;
    }
    v35 = 252;
LABEL_98:
    v40 = v13 + 78;
    v41 = v13;
    while (1)
    {
      v42 = ((char *)v40 - (char *)v41) >> 3;
      v43 = &v41[2 * v42];
      v44 = *v43;
      if (v44 <= v35)
      {
        if (v44 >= v35)
        {
          if (a5)
          {
            if (v11 >= a5)
              goto LABEL_170;
            *(_WORD *)(a4++ - 1) = __rev16(v41[2 * v42 + 1]);
          }
          v19 = v11 + 1;
          goto LABEL_55;
        }
        v41 = v43 + 2;
      }
      else
      {
        v40 = v43 - 2;
      }
      if (v41 > v40)
        goto LABEL_104;
    }
  }
  if (v38 == 774)
  {
    v36 = 0;
    v37 = 0;
    if ((v32 & 0xFFFFFFDF) == 0x418)
      v35 = v32 + 1;
    else
      v35 = -3;
    goto LABEL_76;
  }
  if (v38 != 776)
  {
LABEL_172:
    v36 = 0;
    goto LABEL_173;
  }
  v36 = 0;
  if (v32 == 1077)
    v39 = 1105;
  else
    v39 = -3;
  if (v32 == 1045)
    v35 = 1025;
  else
    v35 = v39;
LABEL_95:
  if ((unsigned __int16)(v35 + 443) >= 0x25Bu)
    goto LABEL_98;
LABEL_104:
  if ((unsigned __int16)(v35 + 15) < 0xB3u)
    goto LABEL_173;
  v45 = (unsigned __int16 *)&__CFToGB2312CharMap;
  v46 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + 36516);
  while (1)
  {
    v47 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v46 - v45)) >> 1;
    v48 = &v45[17 * v47];
    v49 = *v48;
    if (v49 <= v35)
      break;
    v46 = v48 - 17;
LABEL_110:
    if (v45 > v46)
      goto LABEL_173;
  }
  if (v49 + 16 <= v35)
  {
    v45 = v48 + 17;
    goto LABEL_110;
  }
  v50 = v45[17 * v47 + 1 + (int)(v35 - v49)];
  if (!v50 || v50 == 65533)
  {
LABEL_173:
    v12 -= v36;
    *a6 = v11;
    return v12;
  }
  if (!a5)
  {
LABEL_147:
    if (*v33 >= 0x80u)
      v19 = v11;
    else
      v19 = v11 + 1;
    goto LABEL_55;
  }
  if (*v33 > 0x7Fu)
  {
    *(a4 - 2) = HIBYTE(v50) | 0x80;
    *(a4 - 1) = v50 | 0x80;
    goto LABEL_147;
  }
  if (v11 < a5)
  {
    *(a4 - 1) = HIBYTE(v50) | 0x80;
    *a4 = v50 | 0x80;
    goto LABEL_147;
  }
LABEL_170:
  v19 = v11;
LABEL_171:
  *a6 = v19;
  return v12;
}

uint64_t __CFFromMacSimplifiedChinese(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4, uint64_t a5, uint64_t *a6)
{
  unint64_t v9;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  BOOL v20;
  __int16 *v21;
  uint64_t v22;
  int v23;
  __int16 v24;
  unsigned int v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  unsigned __int16 *v29;
  unsigned int v30;
  unsigned __int16 v31;
  unsigned int v33;
  unint64_t v34;
  int v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  int IsDecomposableCharacter;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  __int16 *v46;
  __int16 v47;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _WORD v53[3];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (a3 < 1)
    return 0;
  v9 = a3;
  v12 = 0;
  v13 = 0;
  v14 = a1 & 0xC0;
  if ((a1 & 0x200) != 0)
    v15 = 2;
  else
    v15 = 3;
  if ((a1 & 0x200) != 0)
    v16 = 1;
  else
    v16 = 2;
  while (2)
  {
    if (a5 && v12 >= a5)
      return v13;
    v17 = (char)*a2;
    v18 = *a2;
    if ((v17 & 0x80000000) == 0 || v17 == -96 || (a1 & 0x80) != 0 && (v18 + 125) <= 0x1Cu)
      goto LABEL_14;
    if (v18 == 128)
    {
      if (v14)
      {
        if (!a5)
        {
          v21 = a4;
          v22 = v15;
          goto LABEL_63;
        }
        if (v12 + v15 > a5)
          return v13;
        *(_DWORD *)a4 = 50856053;
        v21 = a4 + 2;
        if ((a1 & 0x200) != 0)
        {
          v22 = 2;
          goto LABEL_63;
        }
        v22 = 3;
      }
      else
      {
        if (!a5)
        {
          v21 = a4;
          v22 = v16;
          goto LABEL_63;
        }
        if (v12 + v16 > a5)
          return v13;
        *a4 = 252;
        v21 = a4 + 1;
        if ((a1 & 0x200) != 0)
        {
          v22 = 1;
          goto LABEL_63;
        }
        v22 = 2;
      }
      *v21 = -1921;
      v21 = &a4[v22];
LABEL_63:
      v12 += v22;
      a4 = v21;
LABEL_17:
      v19 = 1;
      goto LABEL_18;
    }
    if ((v18 + 3) <= 0x85u)
    {
      if (*a2 > 0xFCu)
      {
        if (v18 == 253)
        {
          LOWORD(v18) = 169;
        }
        else if (v18 == 254)
        {
          LOWORD(v18) = 8482;
        }
        else
        {
          LOWORD(v18) = 8230;
        }
        goto LABEL_14;
      }
      if (v18 == 129)
      {
        if ((a1 & 0x200) == 0)
        {
          LOWORD(v18) = -1920;
          goto LABEL_14;
        }
      }
      else if (v18 == 130 && (a1 & 0x200) == 0)
      {
        LOWORD(v18) = -1919;
LABEL_14:
        if (a5)
          *a4++ = v18;
        ++v12;
        goto LABEL_17;
      }
      v19 = 1;
      goto LABEL_19;
    }
    if (v9 < 2)
      return v13;
    if (v18 == 161)
    {
      v23 = a2[1];
      v24 = 183;
      switch(a2[1])
      {
        case 0xA4u:
          goto LABEL_105;
        case 0xA5u:
        case 0xA6u:
        case 0xA7u:
        case 0xA8u:
        case 0xA9u:
          break;
        case 0xAAu:
          v24 = 8212;
          goto LABEL_105;
        case 0xABu:
          v24 = 12316;
          goto LABEL_105;
        case 0xACu:
          v24 = 8214;
          goto LABEL_105;
        case 0xADu:
          v24 = 8943;
          goto LABEL_105;
        default:
          if (v23 == 233)
          {
            v24 = 162;
            goto LABEL_105;
          }
          if (v23 == 234)
          {
            v24 = 163;
            goto LABEL_105;
          }
          break;
      }
    }
    else
    {
      if (v18 == 163)
      {
        v23 = a2[1];
        if (v23 != 164)
        {
          if (v23 == 254)
          {
            v24 = 8254;
            goto LABEL_105;
          }
          goto LABEL_53;
        }
        v24 = 165;
LABEL_105:
        if (a5)
          *a4++ = v24;
        goto LABEL_107;
      }
      v23 = a2[1];
    }
LABEL_53:
    v25 = v23 & 0x7F | ((v18 & 0x7F) << 8);
    if ((unsigned __int16)((v23 & 0x7F | ((v18 & 0x7F) << 8)) - 30594) < 0xA99Fu)
      break;
    v26 = (unsigned __int16 *)&__CFFromGB2312CharMap;
    v27 = (unsigned __int16 *)((char *)&__CFFromGB2312CharMap + 15906);
    while (1)
    {
      v28 = (0xF83E0F83E0F83E1 * (v27 - v26)) >> 1;
      v29 = &v26[33 * v28];
      v30 = *v29;
      if (v30 <= v25)
        break;
      v27 = v29 - 33;
LABEL_59:
      if (v26 > v27)
        goto LABEL_78;
    }
    if (v30 + 32 <= v25)
    {
      v26 = v29 + 33;
      goto LABEL_59;
    }
    v31 = v26[33 * v28 + 1 + (int)(v25 - v30)];
    if (v31 != 65533 && v31 != 0)
    {
      if (!v14
        || (v50 = v15,
            v52 = v16,
            IsDecomposableCharacter = __CFStringEncodingIsDecomposableCharacter(v31, (a1 >> 7) & 1),
            v15 = v50,
            v16 = v52,
            !IsDecomposableCharacter))
      {
        if (a5)
          *a4++ = v31;
        v12 = *a6 + 1;
        v19 = 2;
        goto LABEL_18;
      }
      v43 = __CFStringEncodingDecomposeCharacter(a1, v31, v53, v52);
      v44 = *a6;
      v12 = *a6 + v43;
      *a6 = v12;
      if (!a5)
      {
        v19 = 2;
        v15 = v50;
        v16 = v52;
        goto LABEL_19;
      }
      if (v12 > a5)
      {
        *a6 = v44;
        return v13;
      }
      v15 = v50;
      v16 = v52;
      if (v43 >= 1)
      {
        v45 = v43 + 1;
        v46 = v53;
        do
        {
          v47 = *v46++;
          *a4++ = v47;
          --v45;
        }
        while (v45 > 1);
      }
      v19 = 2;
LABEL_19:
      v13 += v19;
      a2 += v19;
      v20 = (uint64_t)v9 <= v19;
      v9 -= v19;
      if (v20)
        return v13;
      continue;
    }
    break;
  }
LABEL_78:
  if (v18 == 168)
  {
    if ((v23 + 69) > 5u)
      return v13;
    v39 = __CFFromMacSimplifiedChineseMapA8[v23 - 187];
    if (v14)
    {
      v51 = v16;
      v49 = v14;
      v40 = v15;
      if ((__CFStringEncodingIsDecomposableCharacter((unsigned __int16)__CFFromMacSimplifiedChineseMapA8[v23 - 187], (a1 >> 7) & 1) & 1) != 0)
      {
        __CFStringEncodingDecomposeCharacter(a1, (unsigned __int16)v39, v53, v41);
        v12 = *a6 + 2;
        if (!a5)
        {
          v19 = 2;
          v15 = v40;
          v14 = v49;
          v16 = v51;
          goto LABEL_18;
        }
        v16 = v51;
        if (v12 <= a5)
        {
          v15 = v40;
          *a4 = v53[0];
          a4[1] = v53[1];
          a4 += 2;
          v19 = 2;
          v14 = v49;
          goto LABEL_18;
        }
        return v13;
      }
      v12 = *a6;
      v15 = v40;
      v14 = v49;
      v16 = v51;
    }
    if (a5)
    {
      if (v12 >= a5)
        return v13;
      *a4++ = v39;
    }
LABEL_107:
    ++v12;
    goto LABEL_108;
  }
  if (v18 == 166 && (v23 + 39) <= 0x1Cu)
  {
    v33 = v23 - 217;
    v34 = 0x418007FuLL >> v33;
    v35 = ((a1 & 0x200) == 0) & (0x418007FuLL >> v33);
    if (v35)
      v36 = 2;
    else
      v36 = 1;
    v12 += v36;
    if (!a5)
      goto LABEL_108;
    if (v12 <= a5)
    {
      v37 = __CFFromMacSimplifiedChineseMapA6[v33];
      v38 = HIWORD(v37);
      if ((v34 & 1) == 0)
        LOWORD(v38) = v37;
      *a4 = v38;
      if ((v35 & 1) != 0)
      {
        a4[1] = v37;
        a4 += 2;
      }
      else
      {
        ++a4;
      }
LABEL_108:
      v19 = 2;
LABEL_18:
      *a6 = v12;
      goto LABEL_19;
    }
  }
  return v13;
}

uint64_t __CFFromMacSimplifiedChineseLen(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  uint64_t result;
  BOOL v4;
  BOOL v5;
  int v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;

  if (a3 < 1)
    return 0;
  result = 0;
  do
  {
    if ((*a2 & 0x80) != 0
      && (*a2 - 129 <= 0x1F ? (v4 = ((1 << (*a2 + 127)) & 0x80000003) == 0) : (v4 = 1),
          v4 ? (v5 = (unint64_t)a3 >= 2) : (v5 = 0),
          v5 && *a2 < 0xFDu))
    {
      v6 = *a2;
      v7 = a3 - 1;
      if (v6 == 128)
        v8 = a2 + 1;
      else
        v8 = a2 + 2;
      if (v6 == 128)
      {
        v9 = result + 1;
      }
      else
      {
        v7 = a3 - 2;
        v9 = result;
      }
      if (v6 == 161)
        a2 += 2;
      else
        a2 = v8;
      if (v6 == 161)
        a3 -= 2;
      else
        a3 = v7;
      if (v6 == 161)
        ++result;
      else
        result = v9;
    }
    else
    {
      ++a2;
      --a3;
    }
    ++result;
  }
  while (a3 > 0);
  return result;
}

uint64_t __CFToGB_HZ(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, _QWORD *a6)
{
  unint64_t v7;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 *v15;
  const char *v16;
  uint64_t v17;
  unint64_t v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int IsValidCombiningCharacterForLatin1_1;
  uint64_t v26;
  const char *v27;
  const char *v28;
  uint64_t v29;
  const char *v30;
  char v31;
  unsigned __int8 *v32;
  int v33;
  unsigned __int16 *v34;
  unsigned __int16 *v35;
  uint64_t v36;
  unsigned __int16 *v37;
  unsigned int v38;
  unsigned __int16 v39;
  BOOL v40;
  unint64_t v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned __int16 v53;
  unsigned int v54;
  unsigned __int16 *v55;
  unsigned __int16 *v56;
  uint64_t v57;
  unsigned __int16 *v58;
  unsigned int v59;
  unsigned int v60;
  __int16 v61;
  unsigned __int16 v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char v67;
  uint64_t v68;
  uint64_t v69;
  BOOL v72;
  size_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  _QWORD v83[2];

  v7 = (unint64_t)a2;
  v83[1] = *MEMORY[0x1E0C80C00];
  if (a3 < 1)
  {
    v10 = 0;
    v15 = a2;
    goto LABEL_138;
  }
  v10 = 0;
  v11 = (unint64_t)&a2[a3];
  if (a5)
    v12 = -1;
  else
    v12 = 0;
  v76 = v12;
  v13 = 0x8EA4u;
  v14 = 1;
  v15 = (unsigned __int16 *)v7;
  v16 = "~{";
  while (2)
  {
    if (a5 && v10 >= a5)
    {
      if ((a1 & 0x10) == 0)
        goto LABEL_114;
      v17 = *v15;
      if ((v17 - 774) <= 0x32 && ((1 << (v17 - 6)) & 0x4000000000005) != 0
        || (v17 - 12441) < 2)
      {
        goto LABEL_38;
      }
      v20 = v11;
      v77 = v7;
      v80 = v10;
      v21 = v16;
      v22 = a1;
      v23 = a5;
      v24 = v14;
      IsValidCombiningCharacterForLatin1_1 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1(v17, v11, v13);
      v14 = v24;
      a5 = v23;
      a1 = v22;
      v16 = v21;
      v7 = v77;
      v10 = v80;
      v13 = 36516;
      v11 = v20;
      if (!IsValidCombiningCharacterForLatin1_1)
        goto LABEL_114;
    }
    v17 = *v15;
    if (v17 <= 0x7F)
    {
      v26 = v10 + 2;
      if ((v14 & 1) != 0)
      {
        v26 = v10;
        v27 = 0;
      }
      else
      {
        v27 = "~}";
      }
      v28 = "~";
      if ((v14 & 1) == 0)
        v28 = "~}~";
      if ((_DWORD)v17 == 126)
        v29 = v26 + 1;
      else
        v29 = v26;
      if ((_DWORD)v17 == 126)
        v30 = v28;
      else
        v30 = v27;
      v10 = v29 + 1;
      if (a5)
      {
        if (v29 >= a5)
        {
          if ((((_DWORD)v17 != 126) & v14) != 0)
            v74 = -1;
          else
            v74 = ~strlen(v30);
          v10 += v74;
          goto LABEL_138;
        }
        if ((((_DWORD)v17 != 126) & v14) == 0)
        {
          v31 = *v30;
          if (*v30)
          {
            v32 = (unsigned __int8 *)(v30 + 1);
            do
            {
              *a4++ = v31;
              v33 = *v32++;
              v31 = v33;
            }
            while (v33);
          }
        }
        *a4++ = v17;
      }
      v14 = 1;
      goto LABEL_110;
    }
LABEL_38:
    if ((unsigned __int16)(v17 + 15) < 0xB3u)
      break;
    v34 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + v13);
    v35 = (unsigned __int16 *)&__CFToGB2312CharMap;
    while (1)
    {
      v36 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v34 - v35)) >> 1;
      v37 = &v35[17 * v36];
      v38 = *v37;
      if (v38 <= v17)
        break;
      v34 = v37 - 17;
LABEL_44:
      if (v35 > v34)
        goto LABEL_51;
    }
    if (v38 + 16 <= v17)
    {
      v35 = v37 + 17;
      goto LABEL_44;
    }
    v39 = v35[17 * v36 + 1 + (int)(v17 - v38)];
    if (v39)
      v40 = v39 == 65533;
    else
      v40 = 1;
    if (!v40)
    {
      v65 = v10 + 2;
      if ((v14 & 1) == 0)
        v65 = v10;
      v10 = v65 + 2;
      if (!a5)
      {
        v14 = 0;
        goto LABEL_110;
      }
      if (v10 > a5)
      {
        v75 = -2;
        if ((v14 & 1) != 0)
          v75 = -4;
        v68 = v10 + v75;
        v10 += v75 + 2;
LABEL_116:
        if (v10 <= a5)
        {
          *(_WORD *)a4 = 32126;
        }
        else
        {
          if ((unint64_t)v15 > v7)
          {
            for (--v15; ; --v15)
            {
              v69 = *v15;
              if (((v69 - 774) > 0x32 || ((1 << (v69 - 6)) & 0x4000000000005) == 0)
                && (v69 - 12441) >= 2)
              {
                if (__CFStringEncodingIsValidCombiningCharacterForLatin1_1(v69, v11, v13))
                  v72 = (unint64_t)v15 > v7;
                else
                  v72 = 0;
                if (!v72)
                  break;
              }
              else if ((unint64_t)v15 <= v7)
              {
                break;
              }
            }
          }
          if ((unint64_t)v15 <= v7 || *(v15 - 1) > 0x7Fu)
          {
            *((_WORD *)a4 - 1) = 32126;
            v10 = v68;
          }
          else
          {
            v10 = v68 - 4;
          }
        }
        goto LABEL_138;
      }
      if ((v14 & 1) != 0)
      {
        v66 = 0;
        v67 = 126;
        do
        {
          a4[v66] = v67;
          v67 = v16[++v66];
        }
        while (v66 != 2);
        a4 += 2;
      }
      v14 = 0;
      *a4 = HIBYTE(v39) & 0x7F;
      a4[1] = v39 & 0x7F;
      a4 += 2;
LABEL_110:
      if ((unint64_t)++v15 >= v11)
      {
LABEL_114:
        if ((v14 & 1) != 0)
          goto LABEL_138;
        v68 = v10;
        v10 += 2;
        if (!a5)
          goto LABEL_138;
        goto LABEL_116;
      }
      continue;
    }
    break;
  }
LABEL_51:
  if ((a1 & 8) != 0 || (unint64_t)v15 <= v7)
    goto LABEL_114;
  if ((a1 & 0x10) == 0)
    goto LABEL_110;
  v83[0] = 0;
  if (((v17 - 774) > 0x32 || ((1 << (v17 - 6)) & 0x4000000000005) == 0)
    && (v17 - 12441) >= 2)
  {
    v41 = v11;
    v78 = v7;
    v81 = v10;
    v42 = v16;
    v43 = a1;
    v44 = a5;
    v45 = v14;
    v46 = __CFStringEncodingIsValidCombiningCharacterForLatin1_1(v17, v11, v13);
    v14 = v45;
    a5 = v44;
    a1 = v43;
    v16 = v42;
    v7 = v78;
    v10 = v81;
    v13 = 36516;
    v11 = v41;
    if (!v46)
      goto LABEL_114;
  }
  v47 = *(v15 - 1);
  if (v47 <= 0x7F)
  {
    v79 = v11;
    v82 = v10;
    v48 = v16;
    v49 = v7;
    v50 = a1;
    v51 = a5;
    v52 = v14;
    v53 = __CFStringEncodingPrecomposeLatinCharacter_3(v15 - 1, (uint64_t)(v11 - (_QWORD)(v15 - 1)) >> 1, v83);
    v14 = v52;
    a5 = v51;
    a1 = v50;
    v7 = v49;
    v16 = v48;
    v11 = v79;
    v10 = v82;
    v13 = 0x8EA4u;
    goto LABEL_60;
  }
  v60 = *v15;
  if (v60 <= 0x3098)
  {
    if (v60 == 774)
    {
      if ((v47 & 0xFFFFFFDF) != 0x418)
        goto LABEL_114;
      v53 = v47 + 1;
    }
    else
    {
      if (v60 != 776)
        goto LABEL_114;
      if (v47 == 1077)
        v61 = 1105;
      else
        v61 = -3;
      if (v47 == 1045)
        v53 = 1025;
      else
        v53 = v61;
    }
    goto LABEL_61;
  }
  if (v60 == 12441)
  {
    if (v47 != 12454)
    {
      v53 = v47 + 1;
      goto LABEL_60;
    }
    v54 = 12532;
    v53 = 12532;
  }
  else
  {
    if (v60 != 12442)
      goto LABEL_114;
    v53 = v47 + 2;
LABEL_60:
    if (!v53)
      goto LABEL_114;
LABEL_61:
    if ((unsigned __int16)(v53 + 15) < 0xB3u)
      goto LABEL_114;
    v54 = v53;
  }
  v55 = (unsigned __int16 *)((char *)&__CFToGB2312CharMap + v13);
  v56 = (unsigned __int16 *)&__CFToGB2312CharMap;
  while (2)
  {
    v57 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v55 - v56)) >> 1;
    v58 = &v56[17 * v57];
    v59 = *v58;
    if (v59 > v53)
    {
      v55 = v58 - 17;
      goto LABEL_68;
    }
    if (v59 + 16 <= v54)
    {
      v56 = v58 + 17;
LABEL_68:
      if (v56 > v55)
        goto LABEL_114;
      continue;
    }
    break;
  }
  v62 = v56[17 * v57 + 1 + (int)(v54 - v59)];
  if (v62)
    v63 = v62 == 65533;
  else
    v63 = 1;
  if (v63)
    goto LABEL_114;
  if ((v14 & 1) == 0)
    goto LABEL_87;
  if ((unint64_t)(v15 - 2) >= v7 && *(v15 - 2) >= 0x80u)
  {
    --v10;
    a4 += v76;
LABEL_87:
    v64 = v10;
    if (!a5)
    {
LABEL_109:
      v10 = v64;
      goto LABEL_110;
    }
LABEL_108:
    *(a4 - 2) = HIBYTE(v62) & 0x7F;
    *(a4 - 1) = v62 & 0x7F;
    goto LABEL_109;
  }
  v64 = v10 + 3;
  if (!a5)
    goto LABEL_109;
  if (v64 <= a5)
  {
    *(_WORD *)(a4 - 1) = 31614;
    a4 += 3;
    goto LABEL_108;
  }
LABEL_138:
  *a6 = v10;
  return (uint64_t)((uint64_t)v15 - v7) >> 1;
}

_BYTE *__CFFromGB_HZ(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, _QWORD *a6)
{
  unint64_t v9;
  uint64_t v12;
  int v13;
  char v14;
  uint64_t v15;
  __objc2_class **p_superclass;
  unsigned __int8 *v17;
  char v18;
  BOOL v19;
  int v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  int v23;
  int v24;
  unsigned int v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  unsigned __int16 *v29;
  unsigned int v30;
  unsigned __int16 v31;
  BOOL v32;
  int v33;
  int v34;
  uint64_t v35;
  __int16 *v36;
  unsigned __int16 v37;
  unsigned int v39;
  unsigned __int16 v40;
  _BYTE v41[10];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v9 = (unint64_t)&a2[a3];
  if (a3 < 1)
  {
    v12 = 0;
    v14 = 1;
    v22 = a2;
    if (a5)
      goto LABEL_75;
    goto LABEL_80;
  }
  v12 = 0;
  v13 = a1 & 0xC0;
  v14 = 1;
  v15 = 0x3E22u;
  p_superclass = &OBJC_METACLASS___CFPDMirroredSource.superclass;
  v17 = a2;
LABEL_3:
  v18 = v14;
  if (a5)
    v19 = v12 < a5;
  else
    v19 = 1;
  v20 = v19;
  v21 = v17;
  while (1)
  {
    if (!v20)
    {
      v14 = v18;
      v22 = v17;
      if (a5)
        goto LABEL_75;
      goto LABEL_80;
    }
    v22 = v21 + 1;
    v23 = *v21;
    if ((v14 & 1) == 0)
      break;
    if (v23 != 126)
    {
      ++v12;
      if (a5)
        *a4++ = v23;
LABEL_52:
      v17 = v22;
      if ((unint64_t)v22 >= v9)
        goto LABEL_74;
      goto LABEL_3;
    }
    if ((unint64_t)v22 >= v9)
      goto LABEL_71;
    v22 = v21 + 2;
    v24 = v21[1];
    if (v24 == 10)
    {
      v21 += 2;
LABEL_25:
      v14 = 1;
      goto LABEL_26;
    }
    if (v24 != 123)
    {
      if (v24 != 126)
      {
LABEL_71:
        v14 = 1;
        goto LABEL_73;
      }
      if (a5)
        *a4++ = 126;
      ++v12;
      goto LABEL_52;
    }
    v14 = 0;
    v21 += 2;
LABEL_26:
    if ((unint64_t)v21 >= v9)
      goto LABEL_73;
  }
  if (v23 == 126)
  {
    if ((unint64_t)v22 >= v9)
    {
      if ((a1 & 1) == 0)
        goto LABEL_72;
    }
    else if ((a1 & 1) == 0 && *v22 != 125)
    {
      goto LABEL_72;
    }
    v21 += 2;
    goto LABEL_25;
  }
  if ((unint64_t)v22 >= v9)
    goto LABEL_48;
  v25 = *v22 & 0x7F | ((v23 & 0x7F) << 8);
  if ((unsigned __int16)(v25 - 30594) < 0xA99Fu)
    goto LABEL_48;
  v26 = (unsigned __int16 *)&__CFFromGB2312CharMap;
  v27 = (unsigned __int16 *)((char *)&__CFFromGB2312CharMap + v15);
  while (2)
  {
    v28 = (0xF83E0F83E0F83E1 * (v27 - v26)) >> 1;
    v29 = &v26[33 * v28];
    v30 = *v29;
    if (v30 > v25)
    {
      v27 = v29 - 33;
      goto LABEL_37;
    }
    if (v30 + 32 <= v25)
    {
      v26 = v29 + 33;
LABEL_37:
      if (v26 > v27)
        goto LABEL_48;
      continue;
    }
    break;
  }
  v31 = v26[33 * v28 + 1 + (int)(v25 - v30)];
  if (v31)
    v32 = v31 == 65533;
  else
    v32 = 1;
  if (v32)
  {
LABEL_48:
    if ((a1 & 1) == 0)
    {
      v14 = 0;
      if (a5)
        goto LABEL_75;
      goto LABEL_80;
    }
    if (a5)
      *a4++ = 63;
    ++v12;
    v22 = v21 + 2;
    goto LABEL_52;
  }
  if (!v13
    || (v39 = v31,
        v40 = v31,
        v33 = ((uint64_t (*)(void))p_superclass[80])(),
        v31 = v40,
        p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDMirroredSource + 8),
        v15 = 15906,
        !v33))
  {
    if (a5)
      *a4++ = v31;
    v35 = v12 + 1;
LABEL_65:
    v22 = v21 + 2;
    v12 = v35;
    goto LABEL_52;
  }
  v34 = __CFStringEncodingDecomposeCharacter(a1, v39, v41, 15906);
  v35 = v12 + (unsigned __int16)v34;
  if (!a5)
  {
    v15 = 15906;
    p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDMirroredSource + 8);
    goto LABEL_65;
  }
  if (v35 <= a5)
  {
    v15 = 15906;
    p_superclass = (__objc2_class **)(&OBJC_METACLASS___CFPDMirroredSource + 8);
    if ((_WORD)v34)
    {
      v36 = (__int16 *)v41;
      do
      {
        --v34;
        v37 = *v36++;
        *a4++ = v37;
      }
      while ((_WORD)v34);
    }
    goto LABEL_65;
  }
LABEL_72:
  v14 = 0;
LABEL_73:
  v22 = v21;
LABEL_74:
  if (a5)
  {
LABEL_75:
    if ((v14 & 1) == 0 && v12 == a5 && v9 - (_QWORD)v22 == 2 && *v22 == 126)
      v22 += 2 * (v22[1] == 125);
  }
LABEL_80:
  *a6 = v12;
  return (_BYTE *)(v22 - a2);
}

CFTypeRef __CFStringCreateImmutableFunnel2(__objc2_class **a1, int8x16_t *a2, int64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, char a9, const __CFAllocator *a10)
{
  return __CFStringCreateImmutableFunnel3(a1, a2, a3, a4, (a5 != 0) | (2 * (a6 != 0)) | (a7 != 0) | (8 * (a8 != 0)) | (16 * (a9 != 0)), a10, 0);
}

CFStringRef CFStringCreateWithPascalStringNoCopy(CFAllocatorRef alloc, ConstStr255Param pStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)__CFStringCreateImmutableFunnel3((__objc2_class **)alloc, (int8x16_t *)pStr, *pStr + 1, *(uint64_t *)&encoding, 0x14u, contentsDeallocator, 0);
}

CFTypeRef _CFStringCreateWithBytesNoCopy(__objc2_class **a1, int8x16_t *a2, int64_t a3, uint64_t a4, int a5, const __CFAllocator *a6)
{
  return __CFStringCreateImmutableFunnel3(a1, a2, a3, a4, (a5 != 0) | 0x12u, a6, 0);
}

CFStringRef __CFStringMakeConstantString(const char *cStr)
{
  __objc2_class **v2;
  const __CFString *Value;
  const char *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __CFString *Mutable;
  char v13;
  const char *v14;
  int v15;
  size_t v16;
  __objc2_class **ImmutableFunnel3;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  int v26;
  char v27;
  char v28;
  _QWORD *v29;
  _QWORD *v30;
  char v31;
  unint64_t v32;
  char *Typed;
  size_t v34;
  CFIndex Count;
  CFDictionaryValueCallBacks valueCallBacks;
  CFDictionaryKeyCallBacks keyCallBacks;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (!constantStringTable)
  {
    keyCallBacks = *(CFDictionaryKeyCallBacks *)byte_1E12E6D98;
    *(_OWORD *)&valueCallBacks.version = *(_OWORD *)&kCFTypeDictionaryValueCallBacks.version;
    *(_OWORD *)&valueCallBacks.release = *(_OWORD *)&kCFTypeDictionaryValueCallBacks.release;
    valueCallBacks.equal = 0;
    v2 = (__objc2_class **)CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &keyCallBacks, &valueCallBacks);
    _CFDictionarySetCapacity(v2, 2500);
    os_unfair_lock_lock_with_options();
    if (!constantStringTable)
      constantStringTable = (uint64_t)v2;
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFSTRLock);
    if ((__objc2_class **)constantStringTable != v2)
      CFRelease(v2);
  }
  os_unfair_lock_lock_with_options();
  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)constantStringTable, cStr);
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFSTRLock);
  if (!Value)
  {
    v4 = cStr;
    while (1)
    {
      v5 = *v4;
      if (!*v4)
        break;
      ++v4;
      if (v5 < 0)
      {
        Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
        v13 = *cStr;
        if (*cStr)
        {
          v14 = cStr + 1;
          do
          {
            if (v13 < 0)
              CFStringAppendFormat(Mutable, 0, CFSTR("\\%3o"), v13);
            else
              CFStringAppendFormat(Mutable, 0, CFSTR("%1c"), v13);
            v15 = *(unsigned __int8 *)v14++;
            v13 = v15;
          }
          while (v15);
        }
        CFLog(4, (uint64_t)CFSTR("WARNING: CFSTR(\"%@\") has non-7 bit chars, interpreting using MacOS Roman encoding for now, but this will change. Please eliminate usages of non-7 bit chars (including escaped characters above \\177 octal) in CFSTR()."), v6, v7, v8, v9, v10, v11, (__int16)Mutable);
        CFRelease(Mutable);
        break;
      }
    }
    v16 = strlen(cStr);
    ImmutableFunnel3 = (__objc2_class **)__CFStringCreateImmutableFunnel3(&__kCFAllocatorSystemDefault, (int8x16_t *)cStr, v16, 0, 8u, (const __CFAllocator *)0xFFFFFFFFFFFFFFFFLL, 0);
    if (!ImmutableFunnel3)
      __CFStringMakeConstantString_cold_1(0, v18, v19, v20, v21, v22, v23, v24);
    v25 = (unint64_t *)ImmutableFunnel3;
    v26 = CF_IS_OBJC(7uLL, ImmutableFunnel3);
    if (v26)
      goto LABEL_27;
    if (__CFOASafe)
      __CFSetLastAllocationEventName();
    v27 = atomic_load(v25 + 1);
    if ((v27 & 0x10) != 0
      || ((v28 = atomic_load(v25 + 1), v29 = v25 + 2, (v28 & 0x60) == 0)
        ? (v31 = atomic_load(v25 + 1), v30 = &v29[(v31 & 5) != 4])
        : (v30 = (_QWORD *)*v29),
          v32 = atomic_load(v25 + 1),
          !v30))
    {
LABEL_27:
      v34 = strlen(cStr) + 1;
      Typed = (char *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, v34, 1041838444, 0);
      if (__CFOASafe)
        __CFSetLastAllocationEventName();
      strlcpy(Typed, cStr, v34);
    }
    else
    {
      Typed = (char *)v30 + ((v32 >> 2) & 1);
    }
    os_unfair_lock_lock_with_options();
    Count = CFDictionaryGetCount((CFDictionaryRef)constantStringTable);
    CFDictionaryAddValue((CFMutableDictionaryRef)constantStringTable, Typed, v25);
    if (CFDictionaryGetCount((CFDictionaryRef)constantStringTable) == Count)
    {
      Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)constantStringTable, Typed);
    }
    else
    {
      Value = (const __CFString *)v25;
      if (!v26)
      {
        Value = (const __CFString *)v25;
        if (!__CFRuntimeIsConstant((uint64_t)v25))
        {
          __CFRuntimeSetRC((uint64_t)v25, 0);
          Value = (const __CFString *)v25;
        }
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&_CFSTRLock);
    CFRelease(v25);
  }
  return Value;
}

CFTypeRef __cStrCopyDescription(int8x16_t *__s)
{
  uint64_t v2;
  size_t v3;

  v2 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    v2 = __CFDefaultEightBitStringEncoding;
  }
  v3 = strlen(__s->i8);
  return __CFStringCreateImmutableFunnel3(&__kCFAllocatorSystemDefault, __s, v3, v2, 0x18u, (const __CFAllocator *)&__kCFAllocatorNull, 0);
}

BOOL __cStrEqual(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

uint64_t __cStrHash(const char *a1)
{
  const char *v1;
  int64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v1 = a1;
  v2 = strlen(a1);
  if (v2 > 4)
  {
    v6 = v1[1] + (uint64_t)*v1 + ((uint64_t)*v1 << 8);
    v7 = v6 + v1[v2 - 2] + (v6 << 8);
    v4 = v7 + v1[v2 - 1] + (v7 << 8);
  }
  else if ((_DWORD)v2)
  {
    v3 = v2;
    v4 = 0;
    do
    {
      v5 = *v1++;
      v4 = 257 * v4 + v5;
      --v3;
    }
    while (v3);
  }
  else
  {
    v4 = 0;
  }
  return (v4 << (v2 & 0x1F)) + v4;
}

uint64_t _CFStrSetDesiredCapacity(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(result + 40) & 0xFLL | (16 * a2);
  return result;
}

Boolean CFStringGetPascalString(CFStringRef theString, StringPtr buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  uint64_t v4;
  uint64_t v5;
  CFIndex Length;
  char v10;
  char **p_data;
  char *v12;
  char v13;
  char v14;
  char v15;
  BOOL v16;
  uint64_t v17;
  char v18;
  int v19;
  unint64_t v20;
  Boolean result;
  int v22;
  int v23;
  CFIndex v24;
  int64_t v25[2];
  CFRange v26;

  v25[1] = *MEMORY[0x1E0C80C00];
  v4 = bufferSize - 1;
  if (bufferSize < 1)
    return 0;
  v5 = *(_QWORD *)&encoding;
  v25[0] = 0;
  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
  {
    Length = CFStringGetLength(theString);
    if (Length <= 255)
    {
LABEL_41:
      v26.location = 0;
      v26.length = Length;
      v24 = __CFStringEncodeByteStream(theString, v26, 0, v5, 0, (UniChar *)(buffer + 1), v4, v25);
      result = 0;
      v16 = v24 == Length;
      LOBYTE(Length) = 0;
      if (v16)
      {
        result = 1;
        LOBYTE(Length) = v25[0];
      }
      goto LABEL_44;
    }
    return 0;
  }
  v10 = atomic_load((unint64_t *)&theString->info);
  p_data = &theString->data;
  if ((v10 & 0x60) != 0)
  {
    v12 = *p_data;
  }
  else
  {
    v13 = atomic_load((unint64_t *)&theString->info);
    v12 = (char *)&p_data[(v13 & 5) != 4];
  }
  v14 = atomic_load((unint64_t *)&theString->info);
  if ((v14 & 5) == 4)
  {
    Length = *v12;
  }
  else
  {
    v15 = atomic_load((unint64_t *)&theString->info);
    v16 = (v15 & 0x60) == 0;
    v17 = 24;
    if (v16)
      v17 = 16;
    Length = *(CFIndex *)((char *)&theString->isa + v17);
    if (Length > 255)
      return 0;
  }
  v18 = atomic_load((unint64_t *)&theString->info);
  if ((v18 & 0x10) != 0)
    goto LABEL_41;
  v19 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
    __CFStringComputeEightBitStringEncoding();
    v19 = __CFDefaultEightBitStringEncoding;
  }
  if (v19 != (_DWORD)v5)
  {
    if (v19 == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      v19 = __CFDefaultEightBitStringEncoding;
    }
    if (v19 != 1536)
      goto LABEL_41;
    switch(BYTE1(v5))
    {
      case 0:
        if (v5 <= 0x22 && ((1 << v5) & 0x600000032) != 0 || (_DWORD)v5 == 152)
          goto LABEL_41;
        goto LABEL_17;
      case 1:
        if ((_DWORD)v5 != 134217984)
          goto LABEL_41;
        goto LABEL_17;
      case 2:
        if ((_DWORD)v5 == 518)
          goto LABEL_41;
        goto LABEL_17;
      case 6:
        if ((_DWORD)v5 != 1536)
          goto LABEL_41;
        goto LABEL_17;
      case 8:
      case 0xC:
        goto LABEL_41;
      case 0xA:
        if ((v5 - 2561) > 0xF)
          goto LABEL_17;
        v22 = 1 << (v5 - 1);
        v23 = 32785;
        break;
      case 0xB:
        if ((v5 - 3059) > 0xC)
          goto LABEL_17;
        v22 = 1 << (v5 + 13);
        v23 = 4099;
        break;
      default:
        if (((unsigned __int16)v5 & 0xFF00u) > 0xC00)
          goto LABEL_41;
        goto LABEL_17;
    }
    if ((v22 & v23) != 0)
      goto LABEL_41;
  }
LABEL_17:
  if (Length >= bufferSize)
    return 0;
  v20 = atomic_load((unint64_t *)&theString->info);
  memmove(buffer + 1, &v12[(v20 >> 2) & 1], Length);
  result = 1;
LABEL_44:
  *buffer = Length;
  return result;
}

uint64_t _CFStringCompareForHFS(const __CFString *a1, const __CFString *a2, __int16 a3)
{
  const UniChar *CharactersPtr;
  const UniChar *v6;
  uint64_t CStringPtrInternal;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unint64_t v11;
  CFIndex v12;
  const __CFString *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const __CFString *v17;
  uint64_t v18;
  CFIndex v19;
  BOOL v20;
  _BOOL4 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void **p_vtable;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  UniChar v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  UniChar v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  char v54;
  UniChar v55;
  uint64_t v56;
  UniChar v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v80;
  uint64_t v81;
  CFIndex v82;
  uint64_t v83;
  void **v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  UniChar v89;
  uint64_t v90;
  UniChar v91;
  uint64_t v92;
  BOOL v93;
  uint64_t v94;
  uint64_t v95;
  void **v96;
  uint64_t v97;
  uint64_t v98;
  void **v99;
  unsigned int v100;
  uint64_t v101;
  char v102;
  uint64_t BitmapPtrForPlane;
  CFIndex Length;
  uint64_t v105;
  uint64_t v106;
  uint64_t v108;
  unsigned int v109;
  uint64_t v110;
  uint64_t v111;
  unsigned int __s2[64];
  unsigned int __s1[64];
  UniChar v114[8];
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  CFStringRef v122[2];
  __int128 v123;
  __int128 v124;
  uint64_t v125;
  UniChar buffer[8];
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  CFStringRef theString[2];
  __int128 v135;
  __int128 v136;
  uint64_t v137;
  uint64_t v138;
  CFRange v139;
  CFRange v140;
  CFRange v141;
  CFRange v142;
  CFRange v143;
  CFRange v144;

  v138 = *MEMORY[0x1E0C80C00];
  CharactersPtr = CFStringGetCharactersPtr(a1);
  v6 = CFStringGetCharactersPtr(a2);
  if (CharactersPtr)
  {
    CStringPtrInternal = 0;
  }
  else
  {
    v8 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      v8 = __CFDefaultEightBitStringEncoding;
    }
    CStringPtrInternal = _CFStringGetCStringPtrInternal((uint64_t)a1, v8, 1, 1);
  }
  v105 = CStringPtrInternal;
  if (v6)
  {
    v106 = 0;
  }
  else
  {
    v9 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      v9 = __CFDefaultEightBitStringEncoding;
    }
    v106 = _CFStringGetCStringPtrInternal((uint64_t)a2, v9, 1, 1);
    CStringPtrInternal = v105;
  }
  if ((a3 & 0x10) == 0 || CStringPtrInternal && v106)
  {
    BitmapPtrForPlane = 0;
    v101 = 0;
    v10 = 1;
  }
  else
  {
    BitmapPtrForPlane = CFUniCharGetBitmapPtrForPlane(0x65u, 0);
    if (BitmapPtrForPlane)
    {
      v101 = CFUniCharGetBitmapPtrForPlane(8u, 0);
      v10 = 0;
    }
    else
    {
      BitmapPtrForPlane = 0;
      v101 = 0;
      v10 = 1;
    }
    CStringPtrInternal = v105;
  }
  v11 = (unint64_t)CharactersPtr | CStringPtrInternal;
  Length = CFStringGetLength(a1);
  v12 = CFStringGetLength(a2);
  v137 = 0;
  v135 = 0u;
  v136 = 0u;
  v133 = 0u;
  *(_OWORD *)theString = 0u;
  v131 = 0u;
  v132 = 0u;
  v129 = 0u;
  v130 = 0u;
  v127 = 0u;
  v128 = 0u;
  *(_OWORD *)buffer = 0u;
  v125 = 0;
  v123 = 0u;
  v124 = 0u;
  v121 = 0u;
  *(_OWORD *)v122 = 0u;
  v119 = 0u;
  v120 = 0u;
  v117 = 0u;
  v118 = 0u;
  v115 = 0u;
  v116 = 0u;
  *(_OWORD *)v114 = 0u;
  if (((v10 ^ 1) & 1) != 0 || !v11)
  {
    theString[0] = a1;
    *((_QWORD *)&v135 + 1) = 0;
    *(_QWORD *)&v136 = Length;
    v13 = (const __CFString *)CFStringGetCharactersPtr(a1);
    v14 = 0;
    theString[1] = v13;
    if (!v13)
      v14 = _CFStringGetCStringPtrInternal((uint64_t)a1, 0x600u, 1, 1);
    v137 = 0;
    *(_QWORD *)&v135 = v14;
    *((_QWORD *)&v136 + 1) = 0;
  }
  v15 = v106;
  if ((unint64_t)v6 | v106)
    v16 = v10 ^ 1;
  else
    v16 = 1;
  if (v16 == 1)
  {
    v122[0] = a2;
    *((_QWORD *)&v123 + 1) = 0;
    *(_QWORD *)&v124 = v12;
    v17 = (const __CFString *)CFStringGetCharactersPtr(a2);
    v18 = 0;
    v122[1] = v17;
    if (!v17)
      v18 = _CFStringGetCStringPtrInternal((uint64_t)a2, 0x600u, 1, 1);
    v125 = 0;
    *(_QWORD *)&v123 = v18;
    *((_QWORD *)&v124 + 1) = 0;
    v15 = v106;
  }
  v19 = Length;
  v20 = Length > 0;
  v21 = v12 > 0;
  if (Length < 1)
  {
    v22 = v105;
  }
  else
  {
    v102 = v10;
    v22 = v105;
    if (v12 >= 1)
    {
      v23 = 0;
      v24 = 0;
      p_vtable = NSTimer.vtable;
      do
      {
        v26 = -v24;
        v27 = v24 + 64;
        do
        {
          if ((unint64_t)v24 >= 4)
            v28 = 4;
          else
            v28 = v24;
          if (CharactersPtr)
          {
            v29 = CharactersPtr[v24];
          }
          else if (v22)
          {
            v29 = *((_WORD *)p_vtable[455] + *(unsigned __int8 *)(v22 + v24));
          }
          else if (v24 < 0 || (v30 = v136, (uint64_t)v136 <= v24))
          {
            v29 = 0;
          }
          else if (theString[1])
          {
            v29 = *((_WORD *)&theString[1]->isa + v24 + *((_QWORD *)&v135 + 1));
          }
          else if ((_QWORD)v135)
          {
            v29 = *(char *)(v135 + *((_QWORD *)&v135 + 1) + v24);
          }
          else
          {
            if (v137 <= v24 || (v32 = *((_QWORD *)&v136 + 1), *((uint64_t *)&v136 + 1) > v24))
            {
              v33 = -v28;
              v34 = v28 + v26;
              v35 = v27 - v28;
              v36 = v24 + v33;
              v37 = v36 + 64;
              if (v36 + 64 >= (uint64_t)v136)
                v37 = v136;
              *((_QWORD *)&v136 + 1) = v36;
              v137 = v37;
              if ((uint64_t)v136 >= v35)
                v30 = v35;
              v139.length = v30 + v34;
              v139.location = v36 + *((_QWORD *)&v135 + 1);
              CFStringGetCharacters(theString[0], v139, buffer);
              p_vtable = (void **)(NSTimer + 24);
              v19 = Length;
              v22 = v105;
              v15 = v106;
              v32 = *((_QWORD *)&v136 + 1);
            }
            v29 = buffer[v24 - v32];
          }
          v31 = v29;
          if (__CFHFSLowerTable[HIBYTE(v29)])
            v29 = __CFHFSLowerTable[__CFHFSLowerTable[HIBYTE(v29)] + v29];
          if (++v24 >= v19)
            break;
          --v26;
          ++v27;
        }
        while (!v29);
        v38 = v29;
        v39 = v24 - 1;
        v40 = -v23;
        v41 = v23 + 64;
        do
        {
          if ((unint64_t)v23 >= 4)
            v42 = 4;
          else
            v42 = v23;
          if (v6)
          {
            v43 = v6[v23];
          }
          else if (v15)
          {
            v43 = *((_WORD *)p_vtable[455] + *(unsigned __int8 *)(v15 + v23));
          }
          else if (v23 < 0 || (v44 = v124, (uint64_t)v124 <= v23))
          {
            v43 = 0;
          }
          else if (v122[1])
          {
            v43 = *((_WORD *)&v122[1]->isa + v23 + *((_QWORD *)&v123 + 1));
          }
          else if ((_QWORD)v123)
          {
            v43 = *(char *)(v123 + *((_QWORD *)&v123 + 1) + v23);
          }
          else
          {
            if (v125 <= v23 || (v46 = *((_QWORD *)&v124 + 1), *((uint64_t *)&v124 + 1) > v23))
            {
              v47 = -v42;
              v48 = v42 + v40;
              v49 = v41 - v42;
              v50 = v23 + v47;
              v51 = v50 + 64;
              if (v50 + 64 >= (uint64_t)v124)
                v51 = v124;
              *((_QWORD *)&v124 + 1) = v50;
              v125 = v51;
              v108 = v39;
              if ((uint64_t)v124 >= v49)
                v44 = v49;
              v140.length = v44 + v48;
              v100 = v38;
              v140.location = v50 + *((_QWORD *)&v123 + 1);
              CFStringGetCharacters(v122[0], v140, v114);
              v38 = v100;
              v39 = v108;
              p_vtable = (void **)(NSTimer + 24);
              v19 = Length;
              v22 = v105;
              v15 = v106;
              v46 = *((_QWORD *)&v124 + 1);
            }
            v43 = v114[v23 - v46];
          }
          v45 = v43;
          if (__CFHFSLowerTable[HIBYTE(v43)])
            v43 = __CFHFSLowerTable[__CFHFSLowerTable[HIBYTE(v43)] + v43];
          if (++v23 >= v12)
            break;
          --v40;
          ++v41;
        }
        while (!v43);
        if ((a3 & 1) != 0)
          v52 = v38;
        else
          v52 = v31;
        if ((a3 & 1) != 0)
          v53 = v43;
        else
          v53 = v45;
        if (v52 == v53)
          goto LABEL_154;
        v54 = v102;
        if ((v53 | v52) < 0x80)
          v54 = 1;
        if ((v54 & 1) != 0)
          goto LABEL_240;
        if (v24 < v19 && (v52 & 0xFC00) == 0xD800)
        {
          if (CharactersPtr)
          {
            v55 = CharactersPtr[v24];
          }
          else if (v22)
          {
            v55 = *((_WORD *)p_vtable[455] + *(unsigned __int8 *)(v22 + v24));
          }
          else
          {
            if (v39 < -1)
              goto LABEL_108;
            v71 = v136;
            if ((uint64_t)v136 <= v24)
              goto LABEL_108;
            if (theString[1])
            {
              v55 = *((_WORD *)&theString[1]->isa + *((_QWORD *)&v135 + 1) + v24);
            }
            else if ((_QWORD)v135)
            {
              v55 = *(char *)(v135 + *((_QWORD *)&v135 + 1) + v24);
            }
            else
            {
              if (v137 <= v24 || (v73 = *((_QWORD *)&v136 + 1), *((uint64_t *)&v136 + 1) > v24))
              {
                v74 = v24 - 4;
                if ((unint64_t)v24 < 4)
                  v74 = 0;
                v75 = v52;
                if (v74 + 64 < (uint64_t)v136)
                  v71 = v74 + 64;
                *((_QWORD *)&v136 + 1) = v74;
                v137 = v71;
                v76 = v39;
                v141.location = *((_QWORD *)&v135 + 1) + v74;
                v141.length = v71 - v74;
                CFStringGetCharacters(theString[0], v141, buffer);
                v52 = v75;
                v39 = v76;
                p_vtable = (void **)(NSTimer + 24);
                v15 = v106;
                v73 = *((_QWORD *)&v136 + 1);
              }
              v55 = buffer[v24 - v73];
            }
          }
          if (v55 >> 10 == 55)
            v52 = (v52 << 10) - 56613888 + v55;
        }
LABEL_108:
        v109 = v52;
        if (v23 >= v12 || (v53 & 0xFC00) != 0xD800)
        {
          v56 = v39;
          goto LABEL_117;
        }
        v56 = v39;
        if (v6)
        {
          v57 = v6[v23];
        }
        else if (v15)
        {
          v57 = *((_WORD *)p_vtable[455] + *(unsigned __int8 *)(v15 + v23));
        }
        else
        {
          if (v23 - 1 < -1)
            goto LABEL_117;
          v72 = v124;
          if ((uint64_t)v124 <= v23)
            goto LABEL_117;
          if (v122[1])
          {
            v57 = *((_WORD *)&v122[1]->isa + *((_QWORD *)&v123 + 1) + v23);
          }
          else if ((_QWORD)v123)
          {
            v57 = *(char *)(v123 + *((_QWORD *)&v123 + 1) + v23);
          }
          else
          {
            if (v125 <= v23 || (v77 = *((_QWORD *)&v124 + 1), *((uint64_t *)&v124 + 1) > v23))
            {
              v78 = v23 - 4;
              if ((unint64_t)v23 < 4)
                v78 = 0;
              if (v78 + 64 < (uint64_t)v124)
                v72 = v78 + 64;
              *((_QWORD *)&v124 + 1) = v78;
              v125 = v72;
              v142.location = *((_QWORD *)&v123 + 1) + v78;
              v142.length = v72 - v78;
              CFStringGetCharacters(v122[0], v142, v114);
              v52 = v109;
              v77 = *((_QWORD *)&v124 + 1);
            }
            v57 = v114[v23 - v77];
          }
        }
        if (v57 >> 10 == 55)
          v53 = (v53 << 10) - 56613888 + v57;
LABEL_117:
        v58 = BitmapPtrForPlane;
        if (v52 >= 0x10000)
        {
          v58 = CFUniCharGetBitmapPtrForPlane(0x65u, HIWORD(v52));
          v52 = v109;
        }
        if (!v58 || ((*(unsigned __int8 *)(v58 + ((unsigned __int16)v52 >> 3)) >> (v52 & 7)) & 1) == 0)
        {
          v59 = BitmapPtrForPlane;
          if (v53 >= 0x10000)
          {
            v59 = CFUniCharGetBitmapPtrForPlane(0x65u, HIWORD(v53));
            v52 = v109;
          }
          if (!v59 || ((*(unsigned __int8 *)(v59 + ((unsigned __int16)v53 >> 3)) >> (v53 & 7)) & 1) == 0)
          {
            v60 = v101;
            if (v52 >= 0x10000)
            {
              v60 = CFUniCharGetBitmapPtrForPlane(8u, HIWORD(v52));
              v52 = v109;
            }
            if (!v60 || ((*(unsigned __int8 *)(v60 + ((unsigned __int16)v52 >> 3)) >> (v52 & 7)) & 1) == 0)
              goto LABEL_240;
            v61 = v101;
            if (v53 >= 0x10000)
            {
              v61 = CFUniCharGetBitmapPtrForPlane(8u, HIWORD(v53));
              v52 = v109;
            }
            if (!v61 || ((*(unsigned __int8 *)(v61 + ((unsigned __int16)v53 >> 3)) >> (v53 & 7)) & 1) == 0)
              goto LABEL_240;
          }
        }
        v110 = 0;
        v111 = 0;
        v62 = __CFStringFoldCharacterClusterAtIndex(v52, buffer, v56, 16, 0, __s1, &v111, 0);
        v63 = v53;
        v64 = v62;
        v65 = v63;
        v66 = __CFStringFoldCharacterClusterAtIndex(v63, v114, v23 - 1, 16, 0, __s2, &v110, 0);
        v67 = v66;
        if (v64 && v64 == v66)
        {
          v68 = memcmp(__s1, __s2, 4 * v64);
          v52 = v109;
          if (v68)
            goto LABEL_140;
        }
        else
        {
          v52 = v109;
          if (v64 || v66 != 1 || v109 != __s2[0])
          {
LABEL_140:
            if (v67 || v64 != 1 || v65 != __s1[0])
            {
              v53 = v65;
LABEL_240:
              v93 = v52 >= v53;
LABEL_241:
              if (v93)
                return 1;
              else
                return -1;
            }
          }
        }
        if (v52 < 0x10000)
          v69 = 1;
        else
          v69 = 2;
        if (v64)
          v69 = v111;
        v24 = v69 + v24 - 1;
        if (v65 < 0x10000)
          v70 = 1;
        else
          v70 = 2;
        if (v67)
          v70 = v110;
        v23 = v70 + v23 - 1;
        v22 = v105;
        v15 = v106;
        v19 = Length;
        p_vtable = (void **)(NSTimer + 24);
LABEL_154:
        v21 = v23 < v12;
        v20 = v24 < v19;
      }
      while (v24 < v19 && v23 < v12);
    }
  }
  if (v20 || v21)
  {
    if (v21)
      return -1;
    else
      return 1;
  }
  else
  {
    if ((a3 & 0x200) != 0)
    {
      v80 = 0;
      v81 = 0;
      if (v19 >= v12)
        v82 = v12;
      else
        v82 = v19;
      v83 = 64;
      v84 = NSTimer.vtable;
      while (1)
      {
        v85 = (unint64_t)v81 >= 4 ? 4 : v81;
        v86 = -v85;
        v87 = v85 + v80;
        v88 = v83 - v85;
        if (CharactersPtr)
        {
          v89 = CharactersPtr[v81];
        }
        else if (v22)
        {
          v89 = *((_WORD *)v84[455] + *(unsigned __int8 *)(v22 + v81));
        }
        else
        {
          v90 = v136;
          if ((uint64_t)v136 <= v81)
          {
            v89 = 0;
          }
          else if (theString[1])
          {
            v89 = *((_WORD *)&theString[1]->isa + v81 + *((_QWORD *)&v135 + 1));
          }
          else if ((_QWORD)v135)
          {
            v89 = *(char *)(v135 + *((_QWORD *)&v135 + 1) + v81);
          }
          else
          {
            if (v137 <= v81 || (v94 = *((_QWORD *)&v136 + 1), *((uint64_t *)&v136 + 1) > v81))
            {
              v95 = v81 + v86 + 64;
              if (v95 >= (uint64_t)v136)
                v95 = v136;
              *((_QWORD *)&v136 + 1) = v81 + v86;
              v137 = v95;
              if ((uint64_t)v136 >= v88)
                v90 = v88;
              v143.length = v90 + v87;
              v96 = v84;
              v143.location = v81 + v86 + *((_QWORD *)&v135 + 1);
              CFStringGetCharacters(theString[0], v143, buffer);
              v84 = v96;
              v22 = v105;
              v15 = v106;
              v94 = *((_QWORD *)&v136 + 1);
            }
            v89 = buffer[v81 - v94];
          }
        }
        if (v6)
        {
          v91 = v6[v81];
        }
        else if (v15)
        {
          v91 = *((_WORD *)v84[455] + *(unsigned __int8 *)(v15 + v81));
        }
        else
        {
          v92 = v124;
          if ((uint64_t)v124 <= v81)
          {
            v91 = 0;
          }
          else if (v122[1])
          {
            v91 = *((_WORD *)&v122[1]->isa + v81 + *((_QWORD *)&v123 + 1));
          }
          else if ((_QWORD)v123)
          {
            v91 = *(char *)(v123 + *((_QWORD *)&v123 + 1) + v81);
          }
          else
          {
            if (v125 <= v81 || (v97 = *((_QWORD *)&v124 + 1), *((uint64_t *)&v124 + 1) > v81))
            {
              v98 = v81 + v86 + 64;
              if (v98 >= (uint64_t)v124)
                v98 = v124;
              *((_QWORD *)&v124 + 1) = v81 + v86;
              v125 = v98;
              if ((uint64_t)v124 >= v88)
                v92 = v88;
              v144.length = v92 + v87;
              v99 = v84;
              v144.location = v81 + v86 + *((_QWORD *)&v123 + 1);
              CFStringGetCharacters(v122[0], v144, v114);
              v84 = v99;
              v22 = v105;
              v15 = v106;
              v97 = *((_QWORD *)&v124 + 1);
            }
            v91 = v114[v81 - v97];
          }
        }
        v93 = v89 >= v91;
        if (v89 != v91)
          break;
        ++v81;
        --v80;
        ++v83;
        if (v81 >= v82)
          return 0;
      }
      goto LABEL_241;
    }
    return 0;
  }
}

CFStringRef __rangeCopyDescription(_QWORD *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("{%ld, %ld}"), *a1, a1[1]);
}

BOOL __rangeEqual(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2 && a1[1] == a2[1];
}

BOOL _CFStringIsJoiningPulliAtIndex(void *__src, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  CFIndex v6;
  uint64_t v11;
  uint64_t v12;
  CFIndex v13;
  UniChar *v14;
  CFIndex v15;
  CFIndex v16;
  uint64_t v17;
  CFRange v18;
  char *v19;
  UniChar v20;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  if (a3 >= a2 || a3 + a4 <= a2)
    return 0;
  v5 = a2 - 1;
  if (a3 + a4 - (a2 - 1) >= 4)
    v6 = 4;
  else
    v6 = a3 + a4 - (a2 - 1);
  v21[0] = 0;
  if (*((_QWORD *)__src + 17))
  {
    __memmove_chk();
  }
  else
  {
    v11 = *((_QWORD *)__src + 21);
    if (v11 < a2 && (v12 = *((_QWORD *)__src + 22), v12 >= a2))
    {
      v15 = v12 - v5;
      if (v6 >= v15)
        v16 = v15;
      else
        v16 = v6;
      __memmove_chk();
      v14 = (UniChar *)v21 + v16;
      v5 += v16;
      v6 -= v16;
    }
    else
    {
      v13 = v6 + v5 - v11;
      if (v6 + v5 <= v11)
      {
        v14 = (UniChar *)v21;
      }
      else
      {
        v14 = (UniChar *)v21;
        if (v6 + v5 < *((_QWORD *)__src + 22))
        {
          v6 = v11 - v5;
          memmove((char *)v21 + 2 * (v11 - v5), __src, 2 * v13);
        }
      }
    }
    if (v6 >= 1)
    {
      v17 = *((_QWORD *)__src + 18);
      v18.location = *((_QWORD *)__src + 19) + v5;
      if (v17)
      {
        v19 = (char *)(v17 + v18.location);
        do
        {
          v20 = *v19++;
          *v14++ = v20;
          --v6;
        }
        while (v6);
      }
      else
      {
        v18.length = v6;
        CFStringGetCharacters(*((CFStringRef *)__src + 16), v18, v14);
      }
    }
  }
  return LODWORD(v21[0]) == 197987221 && WORD2(v21[0]) == 2999
      || v21[0] == 0xBC00BB00BCD0BB6
      || v21[0] == 0xBC00BB00BCD0BB8;
}

CFRange CFStringGetRangeOfComposedCharactersAtIndex(CFStringRef theString, CFIndex theIndex)
{
  CFIndex RangeOfCharacterClusterAtIndex;
  CFIndex v3;
  CFRange result;

  RangeOfCharacterClusterAtIndex = CFStringGetRangeOfCharacterClusterAtIndex((__CFString *)theString, theIndex, 2);
  result.length = v3;
  result.location = RangeOfCharacterClusterAtIndex;
  return result;
}

CFStringEncoding CFStringGetSmallestEncoding(CFStringRef theString)
{
  uint64_t *p_info;
  char v4;
  CFStringEncoding v5;
  char v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  char **p_data;
  char *v11;
  CFIndex length;
  uint64_t v13;
  uint64_t v14;
  CFIndex v15;
  uint64_t v16;
  CFRange v17;
  CFRange v18;

  if (CF_IS_OBJC(7uLL, (__objc2_class **)theString))
    return -[__CFString _smallestEncodingInCFStringEncoding]((id)theString, "_smallestEncodingInCFStringEncoding");
  p_info = &theString->info;
  v4 = atomic_load((unint64_t *)&theString->info);
  if ((v4 & 0x10) != 0)
  {
    v6 = atomic_load((unint64_t *)p_info);
    v7 = v6 & 5;
    v8 = atomic_load((unint64_t *)p_info);
    v9 = v8 & 0x60;
    if (v7 == 4)
    {
      p_data = &theString->data;
      if (v9)
      {
        v11 = *p_data;
      }
      else
      {
        v13 = atomic_load((unint64_t *)&theString->info);
        v11 = (char *)&p_data[(v13 & 5) != 4];
      }
      length = *v11;
    }
    else if ((v8 & 0x60) != 0)
    {
      length = theString->length;
    }
    else
    {
      length = (CFIndex)theString->data;
    }
    v14 = __CFDefaultEightBitStringEncoding;
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      v14 = __CFDefaultEightBitStringEncoding;
    }
    v17.location = 0;
    v17.length = length;
    v15 = __CFStringEncodeByteStream(theString, v17, 0, v14, 0, 0, 0x7FFFFFFFFFFFFFFFLL, 0);
    v5 = __CFDefaultEightBitStringEncoding;
    if (v15 == length)
    {
      if (__CFDefaultEightBitStringEncoding != -1)
        return v5;
      goto LABEL_5;
    }
    if (__CFDefaultEightBitStringEncoding == -1)
    {
      __CFStringComputeEightBitStringEncoding();
      v5 = __CFDefaultEightBitStringEncoding;
    }
    if ((__CFDefaultSystemEncoding & 1) != 0)
    {
      if (!v5)
        return 256;
    }
    else
    {
      CFStringGetSystemEncoding();
      if (v5 == __CFDefaultSystemEncoding - 1)
        return 256;
      if ((__CFDefaultSystemEncoding & 1) == 0)
      {
        CFStringGetSystemEncoding();
        v16 = __CFDefaultSystemEncoding - 1;
LABEL_28:
        v18.location = 0;
        v18.length = length;
        if (__CFStringEncodeByteStream(theString, v18, 0, v16, 0, 0, 0x7FFFFFFFFFFFFFFFLL, 0) == length)
        {
          if ((__CFDefaultSystemEncoding & 1) != 0)
            return 0;
          CFStringGetSystemEncoding();
          return __CFDefaultSystemEncoding - 1;
        }
        return 256;
      }
    }
    v16 = 0;
    goto LABEL_28;
  }
  v5 = __CFDefaultEightBitStringEncoding;
  if (__CFDefaultEightBitStringEncoding == -1)
  {
LABEL_5:
    __CFStringComputeEightBitStringEncoding();
    return __CFDefaultEightBitStringEncoding;
  }
  return v5;
}

void CFStringAppendPascalString(CFMutableStringRef theString, ConstStr255Param pStr, CFStringEncoding encoding)
{
  char v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = atomic_load((unint64_t *)&theString->info);
  if ((v3 & 1) != 0)
  {
    __CFStringAppendBytes((unint64_t *)theString, (unsigned __int8 *)pStr + 1, *pStr, *(uint64_t *)&encoding);
  }
  else
  {
    v4 = _CFOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      CFStringAppendPascalString_cold_1(v4, v5, v6, v7, v8, v9, v10, v11);
  }
}

uint64_t __CFStringNoteErrors()
{
  return 1;
}

void _CFStringAppendValidatedFormatAndArguments(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int16 *a6, CFErrorRef *a7)
{
  __CFStringAppendFormatCore(a1, 0, 0, a2, 0, a3, a4, a5, 0, 0, 0, 0, a6, 0, a7);
}

void _CFStringAppendFormatAndArgumentsAux(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 *a5)
{
  _CFStringAppendFormatAndArgumentsAux2(a1, a2, 0, a3, 0, a4, a5);
}

BOOL _CFStringValidateFormat(uint64_t a1, uint64_t a2)
{
  return __CFStringValidateFormat(a2, a1) >= 0;
}

void CFShowStr(CFStringRef str)
{
  FILE *v2;
  const char *v3;
  size_t v4;
  CFAllocatorRef v5;
  FILE **v6;
  char v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  char **p_data;
  char **length;
  uint64_t v13;
  unsigned int v14;
  FILE *v15;
  unsigned int v16;
  unsigned int v17;
  char v18;
  FILE *v19;
  FILE *v20;
  uint64_t *p_info;
  char v22;
  char v23;
  char v24;
  char v25;
  BOOL v26;
  uint64_t v27;
  FILE *v28;
  char v29;
  char v30;
  char v31;
  const char *v32;
  unint64_t info;
  char v34;
  char **v35;
  char *v36;
  char v37;

  if (!str)
  {
    v2 = (FILE *)*MEMORY[0x1E0C80C20];
    v3 = "(null)\n";
    v4 = 7;
    goto LABEL_5;
  }
  if (CF_IS_OBJC(7uLL, (__objc2_class **)str))
  {
    v2 = (FILE *)*MEMORY[0x1E0C80C20];
    v3 = "This is an NSString, not CFString\n";
    v4 = 34;
LABEL_5:
    fwrite(v3, v4, 1uLL, v2);
    return;
  }
  v5 = CFGetAllocator(str);
  v6 = (FILE **)MEMORY[0x1E0C80C20];
  v7 = atomic_load((unint64_t *)&str->info);
  v8 = v7 & 5;
  v9 = atomic_load((unint64_t *)&str->info);
  v10 = v9 & 0x60;
  if (v8 == 4)
  {
    p_data = &str->data;
    if (v10)
    {
      length = (char **)*p_data;
    }
    else
    {
      v13 = atomic_load((unint64_t *)&str->info);
      length = &p_data[(v13 & 5) != 4];
    }
    LODWORD(length) = *(unsigned __int8 *)length;
  }
  else if ((v9 & 0x60) != 0)
  {
    length = (char **)str->length;
  }
  else
  {
    length = (char **)str->data;
  }
  v14 = atomic_load((unint64_t *)&str->info);
  fprintf((FILE *)*MEMORY[0x1E0C80C20], "\nLength %d\nIsEightBit %d\n", (_DWORD)length, ((v14 >> 4) & 1) == 0);
  v15 = *v6;
  v16 = atomic_load((unint64_t *)&str->info);
  v17 = atomic_load((unint64_t *)&str->info);
  v18 = atomic_load((unint64_t *)&str->info);
  fprintf(v15, "HasLengthByte %d\nHasNullByte %d\nInlineContents %d\n", (v16 >> 2) & 1, (v17 >> 3) & 1, (v18 & 0x60) == 0);
  fwrite("Allocator ", 0xAuLL, 1uLL, *v6);
  v19 = *v6;
  if (v5 == (CFAllocatorRef)&__kCFAllocatorSystemDefault)
    fwrite("SystemDefault\n", 0xEuLL, 1uLL, v19);
  else
    fprintf(v19, "%p\n", v5);
  v20 = *v6;
  p_info = &str->info;
  v22 = atomic_load((unint64_t *)&str->info);
  fprintf(v20, "Mutable %d\n", v22 & 1);
  v23 = atomic_load((unint64_t *)&str->info);
  if ((v23 & 1) != 0 || (v24 = atomic_load((unint64_t *)p_info), (~v24 & 0x60) != 0))
  {
    v29 = atomic_load((unint64_t *)p_info);
    if ((v29 & 1) != 0)
    {
      v30 = atomic_load((unint64_t *)&str->info);
      if ((~v30 & 0x60) == 0)
        fprintf(*v6, "ExternalContentsAllocator %p\n");
    }
  }
  else
  {
    v25 = atomic_load((unint64_t *)&str->info);
    v26 = (v25 & 5) == 4;
    v27 = 32;
    if (v26)
      v27 = 24;
    v28 = *v6;
    if (*(void **)((char *)&str->isa + v27))
    {
      atomic_load((unint64_t *)&str->info);
      fprintf(v28, "ContentsDeallocatorFunc %p\n");
    }
    else
    {
      fwrite("ContentsDeallocatorFunc None\n", 0x1DuLL, 1uLL, v28);
    }
  }
  v31 = atomic_load((unint64_t *)&str->info);
  if ((v31 & 1) != 0)
  {
    v32 = "Fixed";
    info = str[1].info;
    if ((info & 2) == 0)
      v32 = "Desired";
    fprintf(*v6, "CurrentCapacity %d\n%sCapacity %d\n", str[1].isa, v32, info >> 4);
  }
  v34 = atomic_load((unint64_t *)&str->info);
  v35 = &str->data;
  if ((v34 & 0x60) != 0)
  {
    v36 = *v35;
  }
  else
  {
    v37 = atomic_load((unint64_t *)&str->info);
    v36 = (char *)&v35[(v37 & 5) != 4];
  }
  fprintf(*v6, "Contents %p\n", v36);
}

uint64_t __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_CONTEXT__(uint64_t (*a1)(uint64_t, uint64_t, const __CFString *), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3, CFSTR("%@NSCONTEXT"));
}

uint64_t __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT_WITH_LOCALE__(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

CFStringRef __CFSTRING_IS_CALLING_OUT_TO_AN_OBJECT_FORMAT_ARGUMENT__(const void *a1)
{
  return CFCopyDescription(a1);
}

void OUTLINED_FUNCTION_0_13(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

uint64_t (**__CFStringEncodingGetKoreanConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingIsDecomposableCharacter_0)
  {
    __CFStringEncodingIsDecomposableCharacter_0 = (_UNKNOWN *)a2(1);
    __CFStringEncodingDecomposeCharacter_0 = (_UNKNOWN *)a2(2);
  }
  if (a1 > 2111)
  {
    if (a1 != 2112)
    {
      if (a1 == 2368)
        return __CFConverterEUC_KR;
      return 0;
    }
    return &__CFConverterISO_2022_KR;
  }
  else
  {
    if (a1 != 3)
    {
      if (a1 == 1058)
        return __CFConverterDOSKorean;
      return 0;
    }
    return __CFConverterMacKorean;
  }
}

uint64_t __CFToDOSKorean(char a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  BOOL v15;
  unsigned int v17;
  unsigned __int16 v18;
  unsigned int v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  uint64_t v22;
  unsigned __int16 *v23;
  unsigned int v24;
  unsigned __int16 *v25;
  unsigned __int16 *v26;
  uint64_t v27;
  unsigned __int16 *v28;
  unsigned int v29;
  char v30;
  char v31;
  _QWORD *v32;
  unsigned int v33;
  unsigned __int16 *v34;
  unsigned __int16 *v35;
  uint64_t v36;
  unsigned __int16 *v37;
  unsigned int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  BOOL v47;
  uint64_t v49;
  int v50;

  if (a3 < 1)
  {
    v12 = 0;
    v11 = 0;
    goto LABEL_97;
  }
  v11 = 0;
  v12 = 0;
  v13 = 0xF73Eu;
  v50 = 1;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0)
        break;
      v14 = *a2;
      v15 = v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0;
      if (v15 && v14 - 12441 >= 2)
        break;
    }
    else
    {
      v14 = *a2;
      if (v14 <= 0x7F)
      {
        if (a5)
          *a4++ = v14;
        ++v11;
        ++a2;
        ++v12;
        v50 = 1;
        continue;
      }
    }
    if (v14 - 4352 > 0xFE)
    {
LABEL_35:
      if (v14 < 0xA1)
        goto LABEL_55;
    }
    else if (a3 - v12 >= 2 && ((v14 << 24) | 0xFFFFFFu) <= 0x14FFFFFE)
    {
      v17 = a2[1] - 4449;
      if (v17 <= 0x15)
      {
        if ((unint64_t)(a3 - v12) < 3)
        {
          v18 = 0;
        }
        else
        {
          v18 = a2[2] - 4519;
          if (v18 > 0x1Cu)
            v18 = 0;
        }
        v19 = (unsigned __int16)(v18 + 28 * (v17 + 21 * (char)v14) - 21504);
        if (v19 >= 0xA1)
        {
          v20 = (unsigned __int16 *)&KSX1001_from_uni;
          v21 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
          while (1)
          {
            v22 = (0xF83E0F83E0F83E1 * (v21 - v20)) >> 1;
            v23 = &v20[33 * v22];
            v24 = *v23;
            if (v24 <= v19)
            {
              if (v24 + 32 > v19)
              {
                v40 = v20[33 * v22 + 1 + (int)(v19 - v24)];
                if (v40)
                {
                  v47 = (__int16)v18 <= 0;
                  v41 = 2;
                  if (!v47)
                    v41 = 3;
                  goto LABEL_72;
                }
                goto LABEL_35;
              }
              v20 = v23 + 33;
            }
            else
            {
              v21 = v23 - 33;
            }
            if (v20 > v21)
              goto LABEL_35;
          }
        }
      }
    }
    v25 = (unsigned __int16 *)&KSX1001_from_uni;
    v26 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
    while (1)
    {
      v27 = (0xF83E0F83E0F83E1 * (v26 - v25)) >> 1;
      v28 = &v25[33 * v27];
      v29 = *v28;
      if (v29 <= v14)
        break;
      v26 = v28 - 33;
LABEL_41:
      if (v25 > v26)
        goto LABEL_42;
    }
    if (v29 + 32 <= v14)
    {
      v25 = v28 + 33;
      goto LABEL_41;
    }
    v39 = (uint64_t)&v25[33 * v27 + (int)(v14 - v29)];
    v40 = *(unsigned __int16 *)(v39 + 2);
    if (*(_WORD *)(v39 + 2))
    {
      v41 = 1;
LABEL_72:
      if (v40 != 65533)
      {
        if (a5)
        {
          if (v11 + 2 > a5)
            break;
          *a4 = BYTE1(v40);
          a4[1] = v40;
          a4 += 2;
        }
        v50 = 0;
        v12 += v41;
        v11 += 2;
        a2 += v41;
        continue;
      }
    }
LABEL_42:
    if ((unsigned __int16)(v14 + 0x2000) <= 0xBBu)
    {
      if (a5)
      {
        if (v11 + 2 > a5)
          break;
        if (v14 >= 0xE05E)
          v30 = -2;
        else
          v30 = -55;
        *a4 = v30;
        if (v14 >= 0xE05E)
          v31 = 67;
        else
          v31 = -95;
        a4[1] = v31 + v14;
        a4 += 2;
      }
      v50 = 0;
      ++a2;
      ++v12;
      v11 += 2;
      continue;
    }
    if ((unsigned __int16)(v14 - 4447) <= 1u)
    {
      ++a2;
      ++v12;
      continue;
    }
LABEL_55:
    if ((a1 & 8) != 0 || v12 < 1)
      break;
    if ((a1 & 0x10) == 0)
      continue;
    if ((v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0) && v14 - 12441 >= 2)
      break;
    v32 = a6;
    v33 = __CFPrecomposeCharKorean(a2 - 1);
    if (!v33)
    {
      a6 = v32;
      break;
    }
    a6 = v32;
    if (v33 < 0xA1)
      break;
    v13 = 0xF73Eu;
    v34 = (unsigned __int16 *)&KSX1001_from_uni;
    v35 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
LABEL_64:
    v36 = (0xF83E0F83E0F83E1 * (v35 - v34)) >> 1;
    v37 = &v34[33 * v36];
    v38 = *v37;
    if (v38 > v33)
    {
      v35 = v37 - 33;
      goto LABEL_68;
    }
    if (v38 + 32 <= v33)
    {
      v34 = v37 + 33;
LABEL_68:
      if (v34 > v35)
        break;
      goto LABEL_64;
    }
    v42 = v34[33 * v36 + 1 + (int)(v33 - v38)];
    if (v42)
      v43 = v42 == 65533;
    else
      v43 = 1;
    if (v43)
      break;
    if (v50)
      v44 = v11 + 1;
    else
      v44 = v11;
    if (!a5)
      goto LABEL_89;
    if (v44 > a5)
    {
      v49 = v44 - 1;
      if (v50)
        v11 = v49;
      break;
    }
    v45 = -2;
    if (v50)
      v45 = -1;
    v46 = &a4[v45];
    *(_WORD *)v46 = __rev16(v42);
    a4 = v46 + 2;
LABEL_89:
    v50 = 0;
    ++a2;
    ++v12;
    v11 = v44;
  }
  while (v12 < a3);
LABEL_97:
  *a6 = v11;
  return v12;
}

uint64_t __CFFromDOSKorean(unsigned int a1, char *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  unint64_t v9;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  void *v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  uint64_t v22;
  unsigned __int16 *v23;
  unsigned int v24;
  unsigned __int16 v25;
  BOOL v26;
  unsigned __int16 v27;
  BOOL v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  __int16 *v33;
  unsigned __int16 v34;
  int v36;
  unsigned int v37;
  _BYTE v38[10];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (a3 < 1)
    return 0;
  v9 = a3;
  v11 = a1;
  v12 = 0;
  v13 = 0;
  v14 = a1 & 0xC0;
  v15 = 0x9F74u;
  v16 = &unk_1EDCD1000;
LABEL_3:
  if (a5)
  {
    if (v12 >= a5)
      return v13;
    v17 = *a2;
    if ((*a2 & 0x80000000) == 0)
    {
      *a4++ = v17;
LABEL_8:
      v18 = 1;
LABEL_32:
      *a6 = ++v12;
      goto LABEL_33;
    }
  }
  else
  {
    if ((*a2 & 0x80000000) == 0)
      goto LABEL_8;
    v17 = *a2;
  }
  if (v9 < 2)
    return v13;
  v19 = a2[1] | (v17 << 8);
  if ((unsigned __int16)(v19 + 478) >= 0x831Fu)
  {
    v20 = (unsigned __int16 *)((char *)&KSX1001_to_uni + v15);
    v21 = (unsigned __int16 *)&KSX1001_to_uni;
    while (1)
    {
      v22 = (0xFC0FC0FC0FC0FC1 * (v20 - v21)) >> 1;
      v23 = &v21[65 * v22];
      v24 = *v23;
      if (v24 <= v19)
      {
        if (v24 + 64 > v19)
        {
          v25 = v21[65 * v22 + 1 + (int)(v19 - v24)];
          if (v25)
            v26 = v25 == 65533;
          else
            v26 = 1;
          if (v26)
          {
LABEL_24:
            if ((unsigned __int16)(v19 + 13919) > 0x5Du)
              break;
            if (a5)
            {
              v27 = v19 + 5727;
              goto LABEL_30;
            }
            goto LABEL_31;
          }
          if (!v14
            || (v36 = v14,
                v37 = v11,
                v29 = (*((uint64_t (**)(_QWORD, _QWORD))v16 + 74))(v21[65 * v22 + 1 + (int)(v19 - v24)], (v11 >> 7) & 1), v16 = &unk_1EDCD1000, v15 = 40820, v14 = v36, v11 = v37, !v29))
          {
            if (a5)
              *a4++ = v25;
            v12 = *a6;
            goto LABEL_31;
          }
          v30 = __CFStringEncodingDecomposeCharacter_0(v37, v25, v38, 13919, 5727, 65533, 0x1EDCD1000, &KSX1001_to_uni);
          v31 = *a6;
          v12 = *a6 + v30;
          *a6 = v12;
          if (!a5)
          {
            v18 = 2;
            v14 = v36;
            v11 = v37;
            v15 = 40820;
            v16 = &unk_1EDCD1000;
            goto LABEL_33;
          }
          v16 = &unk_1EDCD1000;
          if (v12 > a5)
          {
            *a6 = v31;
            return v13;
          }
          if (v30 < 1)
          {
            v18 = 2;
            v14 = v36;
            v11 = v37;
            v15 = 40820;
          }
          else
          {
            v32 = v30 + 1;
            v33 = (__int16 *)v38;
            v14 = v36;
            v11 = v37;
            v15 = 40820;
            do
            {
              v34 = *v33++;
              *a4++ = v34;
              --v32;
            }
            while (v32 > 1);
            v18 = 2;
          }
LABEL_33:
          v13 += v18;
          a2 += v18;
          v28 = (uint64_t)v9 <= v18;
          v9 -= v18;
          if (v28)
            return v13;
          goto LABEL_3;
        }
        v21 = v23 + 65;
      }
      else
      {
        v20 = v23 - 65;
      }
      if (v21 > v20)
        goto LABEL_24;
    }
  }
  if ((unsigned __int16)(v19 + 351) <= 0x5Du)
  {
    if (a5)
    {
      v27 = v19 - 3907;
LABEL_30:
      *a4++ = v27;
    }
LABEL_31:
    v18 = 2;
    goto LABEL_32;
  }
  return v13;
}

uint64_t __CFToDOSKoreanLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t result;
  unsigned int v4;
  uint64_t v5;

  for (result = 0; a3; --a3)
  {
    v4 = *a2++;
    if (v4 < 0x80)
      v5 = 1;
    else
      v5 = 2;
    result += v5;
  }
  return result;
}

uint64_t __CFFromDOSKoreanLen(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t result;
  _BOOL4 v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;

  if (a3 < 1)
    return 0;
  result = 0;
  do
  {
    v5 = a3 == 1 || *a2 >= 0;
    v6 = !v5;
    if (v5)
      v7 = 1;
    else
      v7 = 2;
    a2 += v7;
    if (v6)
      v8 = -2;
    else
      v8 = -1;
    ++result;
    v9 = __OFADD__(v8, a3);
    a3 += v8;
  }
  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

uint64_t __CFFromDOSKoreanFallback(char *a1, uint64_t a2, _WORD *a3, uint64_t a4, _QWORD *a5)
{
  if (a4)
    *a3 = 63;
  *a5 = 1;
  if (*a1 > -1 || a2 < 2)
    return 1;
  else
    return 2;
}

uint64_t __CFToKSX1001(unsigned __int16 *a1, uint64_t a2, uint64_t *a3, unsigned __int16 *a4)
{
  unsigned int v4;
  unsigned int v5;
  __int16 v6;
  unsigned __int16 v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;
  uint64_t result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v4 = *a1;
  if (v4 - 4352 > 0xFE)
    goto LABEL_17;
  if (a2 >= 2 && ((v4 << 24) | 0xFFFFFFu) <= 0x14FFFFFE)
  {
    v5 = a1[1] - 4449;
    if (v5 <= 0x15)
    {
      if ((unint64_t)a2 < 3)
      {
        v6 = 0;
      }
      else
      {
        v6 = a1[2] - 4519;
        if ((unsigned __int16)v6 > 0x1Cu)
          v6 = 0;
      }
      v7 = v6 + 28 * (v5 + 21 * (char)v4) - 21504;
      if (v7 >= 0xA1u)
      {
        v8 = (unsigned __int16 *)&KSX1001_from_uni;
        v9 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
        while (1)
        {
          v10 = (0xF83E0F83E0F83E1 * (v9 - v8)) >> 1;
          v11 = &v8[33 * v10];
          v12 = *v11;
          if (v12 <= v7)
          {
            if (v12 + 32 > v7)
            {
              v21 = (uint64_t)&v8[33 * v10 + (int)(v7 - v12)];
              result = *(unsigned __int16 *)(v21 + 2);
              if (*(_WORD *)(v21 + 2))
              {
                if (a4)
                  *a4 = v7;
                v20 = 2;
                if (v6 > 0)
                  v20 = 3;
LABEL_27:
                *a3 = v20;
                return result;
              }
LABEL_17:
              if (v4 < 0xA1)
                return 65533;
              break;
            }
            v8 = v11 + 33;
          }
          else
          {
            v9 = v11 - 33;
          }
          if (v8 > v9)
            goto LABEL_17;
        }
      }
    }
  }
  v13 = (unsigned __int16 *)&KSX1001_from_uni;
  v14 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
  while (1)
  {
    v15 = (0xF83E0F83E0F83E1 * (v14 - v13)) >> 1;
    v16 = &v13[33 * v15];
    v17 = *v16;
    if (v17 <= v4)
      break;
    v14 = v16 - 33;
LABEL_23:
    if (v13 > v14)
      return 65533;
  }
  if (v17 + 32 <= v4)
  {
    v13 = v16 + 33;
    goto LABEL_23;
  }
  v19 = (uint64_t)&v13[33 * v15 + (int)(v4 - v17)];
  result = *(unsigned __int16 *)(v19 + 2);
  if (*(_WORD *)(v19 + 2))
  {
    v20 = 1;
    goto LABEL_27;
  }
  return 65533;
}

uint64_t __CFPrecomposeCharKorean(unsigned __int16 *a1)
{
  int v1;
  unsigned int v2;
  unsigned __int16 v3;
  char v4;

  v1 = *a1;
  v2 = a1[1];
  if (v2 <= 0x337)
  {
    if (v2 != 774)
    {
      if (v2 != 776)
        return 0;
      if (v1 == 1077)
        v3 = 1105;
      else
        v3 = 0;
      if (v1 == 1045)
        return 1025;
      return v3;
    }
    if ((v1 & 0xFFFFFFDF) != 0x418)
      return 0;
    return (unsigned __int16)(v1 + 1);
  }
  if (v2 == 824)
  {
    v3 = 8800;
    if (*a1 > 0x2260u)
    {
      v4 = v1 - 100;
      if ((v1 - 8804) <= 0x1F)
      {
        if (((1 << v4) & 0xC0080000) != 0)
          return (unsigned __int16)(v1 + 2);
        if (((1 << v4) & 3) != 0)
          return (unsigned __int16)(v1 + 12);
        if (((1 << v4) & 0xC00000) != 0)
          return (unsigned __int16)(v1 + 6);
      }
      if (v1 != 8801)
        return 0;
    }
    else
    {
      if (*a1 <= 0x2207u)
      {
        if (v1 == 60)
          return 8814;
        if (v1 != 61)
        {
          if (v1 == 62)
            return 8815;
          return 0;
        }
        return v3;
      }
      if ((v1 - 8712) > 0x1D || ((1 << (v1 - 8)) & 0x20000009) == 0)
        return 0;
    }
    return (unsigned __int16)(v1 + 1);
  }
  if (v2 != 12441)
  {
    if (v2 == 12442)
      return (unsigned __int16)(v1 + 2);
    return 0;
  }
  if (v1 == 12454)
    return 12532;
  else
    return (unsigned __int16)(v1 + 1);
}

uint64_t __CFFromKSX1001(unsigned int a1)
{
  unsigned __int16 *v1;
  unsigned __int16 *v2;
  uint64_t v3;
  unsigned __int16 *v4;
  unsigned int v5;
  unsigned __int16 v6;

  if ((unsigned __int16)(a1 + 478) < 0x831Fu)
    return (unsigned __int16)-3;
  v1 = (unsigned __int16 *)&KSX1001_to_uni;
  v2 = (unsigned __int16 *)((char *)&KSX1001_to_uni + 40820);
  while (1)
  {
    v3 = (0xFC0FC0FC0FC0FC1 * (v2 - v1)) >> 1;
    v4 = &v1[65 * v3];
    v5 = *v4;
    if (v5 <= a1)
      break;
    v2 = v4 - 65;
LABEL_7:
    if (v1 > v2)
      return (unsigned __int16)-3;
  }
  if (v5 + 64 <= a1)
  {
    v1 = v4 + 65;
    goto LABEL_7;
  }
  v6 = v1[65 * v3 + 1 + (int)(a1 - v5)];
  if (!v6)
    return (unsigned __int16)-3;
  return v6;
}

uint64_t __CFToEUC_KR(char a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  BOOL v15;
  unsigned int v17;
  unsigned __int16 v18;
  unsigned int v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  uint64_t v22;
  unsigned __int16 *v23;
  unsigned int v24;
  unsigned __int16 *v25;
  unsigned __int16 *v26;
  uint64_t v27;
  unsigned __int16 *v28;
  unsigned int v29;
  char v30;
  char v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  _QWORD *v35;
  unsigned int v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  uint64_t v39;
  unsigned __int16 *v40;
  unsigned int v41;
  unsigned int v42;
  BOOL v43;
  uint64_t v44;
  char *v45;
  BOOL v46;
  int v48;

  if (a3 < 1)
  {
    v12 = 0;
    v11 = 0;
    goto LABEL_103;
  }
  v11 = 0;
  v12 = 0;
  v13 = 0xF73Eu;
  v48 = 1;
  while (2)
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0)
        goto LABEL_103;
      v14 = *a2;
      v15 = v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0;
      if (v15 && v14 - 12441 >= 2)
        goto LABEL_103;
    }
    else
    {
      v14 = *a2;
      if (v14 <= 0x7F)
      {
        if (a5)
          *a4++ = v14;
        ++v11;
        ++a2;
        ++v12;
        v48 = 1;
        goto LABEL_58;
      }
    }
    if (v14 - 4352 > 0xFE)
      goto LABEL_35;
    if (a3 - v12 < 2)
      goto LABEL_36;
    if (((v14 << 24) | 0xFFFFFFu) > 0x14FFFFFE)
      goto LABEL_36;
    v17 = a2[1] - 4449;
    if (v17 > 0x15)
      goto LABEL_36;
    if ((unint64_t)(a3 - v12) < 3)
    {
      v18 = 0;
    }
    else
    {
      v18 = a2[2] - 4519;
      if (v18 > 0x1Cu)
        v18 = 0;
    }
    v19 = (unsigned __int16)(v18 + 28 * (v17 + 21 * (char)v14) - 21504);
    if (v19 < 0xA1)
      goto LABEL_36;
    v20 = (unsigned __int16 *)&KSX1001_from_uni;
    v21 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
    while (1)
    {
      v22 = (0xF83E0F83E0F83E1 * (v21 - v20)) >> 1;
      v23 = &v20[33 * v22];
      v24 = *v23;
      if (v24 <= v19)
        break;
      v21 = v23 - 33;
LABEL_34:
      if (v20 > v21)
        goto LABEL_35;
    }
    if (v24 + 32 <= v19)
    {
      v20 = v23 + 33;
      goto LABEL_34;
    }
    v33 = v20[33 * v22 + 1 + (int)(v19 - v24)];
    if (!v33)
    {
LABEL_35:
      if (v14 < 0xA1)
        goto LABEL_55;
LABEL_36:
      v25 = (unsigned __int16 *)&KSX1001_from_uni;
      v26 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
      while (1)
      {
        v27 = (0xF83E0F83E0F83E1 * (v26 - v25)) >> 1;
        v28 = &v25[33 * v27];
        v29 = *v28;
        if (v29 <= v14)
        {
          if (v29 + 32 > v14)
          {
            v32 = (uint64_t)&v25[33 * v27 + (int)(v14 - v29)];
            v33 = *(unsigned __int16 *)(v32 + 2);
            if (*(_WORD *)(v32 + 2))
            {
              v34 = 1;
              goto LABEL_62;
            }
            goto LABEL_42;
          }
          v25 = v28 + 33;
        }
        else
        {
          v26 = v28 - 33;
        }
        if (v25 > v26)
          goto LABEL_42;
      }
    }
    v46 = (__int16)v18 <= 0;
    v34 = 2;
    if (!v46)
      v34 = 3;
LABEL_62:
    if (v33 != 65533
      && v33 >> 8 >= 0xA1
      && v33 >> 8 != 255
      && v33 >= 0xA1u
      && v33 != 255)
    {
      v11 += 2;
      if (a5)
      {
        if (v11 > a5)
          goto LABEL_103;
        *a4 = BYTE1(v33);
        a4[1] = v33;
        a4 += 2;
      }
      v48 = 0;
      a2 += v34;
      v12 += v34;
      goto LABEL_58;
    }
LABEL_42:
    if ((unsigned __int16)(v14 + 0x2000) <= 0xBBu)
    {
      v11 += 2;
      if (!a5)
        goto LABEL_52;
      if (v11 <= a5)
      {
        if (v14 >= 0xE05E)
          v30 = -2;
        else
          v30 = -55;
        *a4 = v30;
        if (v14 >= 0xE05E)
          v31 = 67;
        else
          v31 = -95;
        a4[1] = v31 + v14;
        a4 += 2;
        goto LABEL_52;
      }
      goto LABEL_103;
    }
    if ((unsigned __int16)(v14 - 4447) <= 1u)
    {
LABEL_54:
      ++a2;
      ++v12;
      goto LABEL_58;
    }
LABEL_55:
    if ((a1 & 8) != 0 || v12 < 1)
      goto LABEL_103;
    if ((a1 & 0x10) == 0)
    {
LABEL_58:
      if (v12 >= a3)
        goto LABEL_103;
      continue;
    }
    break;
  }
  if ((v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0) && v14 - 12441 >= 2)
    goto LABEL_103;
  v35 = a6;
  v36 = __CFPrecomposeCharKorean(a2 - 1);
  if (v36 <= 0xA0)
  {
    a6 = v35;
    goto LABEL_103;
  }
  v13 = 0xF73Eu;
  v37 = (unsigned __int16 *)&KSX1001_from_uni;
  v38 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v13);
  a6 = v35;
  while (2)
  {
    v39 = (0xF83E0F83E0F83E1 * (v38 - v37)) >> 1;
    v40 = &v37[33 * v39];
    v41 = *v40;
    if (v41 > v36)
    {
      v38 = v40 - 33;
      goto LABEL_80;
    }
    if (v41 + 32 <= v36)
    {
      v37 = v40 + 33;
LABEL_80:
      if (v37 > v38)
        goto LABEL_103;
      continue;
    }
    break;
  }
  v42 = v37[33 * v39 + 1 + (int)(v36 - v41)];
  if (v37[33 * v39 + 1 + (int)(v36 - v41)])
    v43 = v42 == 65533;
  else
    v43 = 1;
  if (v43
    || v42 >> 8 < 0xA1
    || v42 >> 8 == 255
    || v37[33 * v39 + 1 + (int)(v36 - v41)] < 0xA1u
    || v37[33 * v39 + 1 + (int)(v36 - v41)] == 255)
  {
    goto LABEL_103;
  }
  if (v48)
    ++v11;
  if (!a5)
  {
LABEL_52:
    v48 = 0;
    goto LABEL_54;
  }
  if (v11 <= a5)
  {
    v44 = -2;
    if (v48)
      v44 = -1;
    v45 = &a4[v44];
    *v45 = BYTE1(v42);
    a4 = v45 + 2;
    v45[1] = v42;
    goto LABEL_52;
  }
LABEL_103:
  *a6 = v11;
  return v12;
}

uint64_t __CFFromEUC_KR(unsigned int a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  unint64_t v9;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  void *v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  unsigned __int16 *v22;
  unsigned __int16 *v23;
  uint64_t v24;
  unsigned __int16 *v25;
  unsigned int v26;
  unsigned __int16 v27;
  BOOL v28;
  unsigned __int16 v29;
  BOOL v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  __int16 *v35;
  unsigned __int16 v36;
  int v38;
  unsigned int v39;
  _BYTE v40[10];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (a3 < 1)
    return 0;
  v9 = a3;
  v11 = a1;
  v12 = 0;
  v13 = 0;
  v14 = a1 & 0xC0;
  v15 = 0x9F74u;
  v16 = &unk_1EDCD1000;
LABEL_3:
  if (a5)
  {
    if (v12 >= a5)
      return v13;
    v17 = (char)*a2;
    v18 = *a2;
    if ((v17 & 0x80000000) == 0)
    {
      *a4++ = v18;
LABEL_8:
      v19 = 1;
LABEL_34:
      *a6 = ++v12;
      goto LABEL_35;
    }
  }
  else
  {
    v17 = (char)*a2;
    if ((v17 & 0x80000000) == 0)
      goto LABEL_8;
    v18 = *a2;
  }
  if (v9 < 2)
    return v13;
  if ((v17 + 1) < 0xA2u)
    return v13;
  v20 = a2[1];
  if ((v20 + 1) < 0xA2u)
    return v13;
  v21 = v20 | (v18 << 8);
  if ((unsigned __int16)(v21 + 478) >= 0x831Fu)
  {
    v22 = (unsigned __int16 *)((char *)&KSX1001_to_uni + v15);
    v23 = (unsigned __int16 *)&KSX1001_to_uni;
    while (1)
    {
      v24 = (0xFC0FC0FC0FC0FC1 * (v22 - v23)) >> 1;
      v25 = &v23[65 * v24];
      v26 = *v25;
      if (v26 <= v21)
      {
        if (v26 + 64 > v21)
        {
          v27 = v23[65 * v24 + 1 + (int)(v21 - v26)];
          if (v27)
            v28 = v27 == 65533;
          else
            v28 = 1;
          if (v28)
          {
LABEL_26:
            if ((unsigned __int16)(v21 + 13919) > 0x5Du)
              break;
            if (a5)
            {
              v29 = v21 + 5727;
              goto LABEL_32;
            }
            goto LABEL_33;
          }
          if (!v14
            || (v38 = v14,
                v39 = v11,
                v31 = (*((uint64_t (**)(_QWORD, _QWORD))v16 + 74))(v23[65 * v24 + 1 + (int)(v21 - v26)], (v11 >> 7) & 1), v16 = &unk_1EDCD1000, v15 = 40820, v14 = v38, v11 = v39, !v31))
          {
            if (a5)
              *a4++ = v27;
            v12 = *a6;
            goto LABEL_33;
          }
          v32 = __CFStringEncodingDecomposeCharacter_0(v39, v27, v40, 13919, 5727, 65533, 0x1EDCD1000, &KSX1001_to_uni);
          v33 = *a6;
          v12 = *a6 + v32;
          *a6 = v12;
          if (!a5)
          {
            v19 = 2;
            v14 = v38;
            v11 = v39;
            v15 = 40820;
            v16 = &unk_1EDCD1000;
            goto LABEL_35;
          }
          v16 = &unk_1EDCD1000;
          if (v12 > a5)
          {
            *a6 = v33;
            return v13;
          }
          if (v32 < 1)
          {
            v19 = 2;
            v14 = v38;
            v11 = v39;
            v15 = 40820;
          }
          else
          {
            v34 = v32 + 1;
            v35 = (__int16 *)v40;
            v14 = v38;
            v11 = v39;
            v15 = 40820;
            do
            {
              v36 = *v35++;
              *a4++ = v36;
              --v34;
            }
            while (v34 > 1);
            v19 = 2;
          }
LABEL_35:
          v13 += v19;
          a2 += v19;
          v30 = (uint64_t)v9 <= v19;
          v9 -= v19;
          if (v30)
            return v13;
          goto LABEL_3;
        }
        v23 = v25 + 65;
      }
      else
      {
        v22 = v25 - 65;
      }
      if (v23 > v22)
        goto LABEL_26;
    }
  }
  if ((unsigned __int16)(v21 + 351) <= 0x5Du)
  {
    if (a5)
    {
      v29 = v21 - 3907;
LABEL_32:
      *a4++ = v29;
    }
LABEL_33:
    v19 = 2;
    goto LABEL_34;
  }
  return v13;
}

uint64_t __CFToISO_2022_KR(int a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  BOOL v15;
  uint64_t v17;
  unsigned int v18;
  unsigned __int16 v19;
  unsigned int v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  uint64_t v23;
  unsigned __int16 *v24;
  unsigned int v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  unsigned __int16 *v29;
  unsigned int v30;
  uint64_t v31;
  char v32;
  char v33;
  int v34;
  uint64_t v35;
  BOOL v36;
  char *v37;
  uint64_t *v38;
  unsigned int v39;
  unsigned __int16 *v40;
  unsigned __int16 *v41;
  uint64_t v42;
  unsigned __int16 *v43;
  unsigned int v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  BOOL v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v55;
  unsigned __int16 *v56;
  unsigned int v57;
  unsigned int v58;
  uint64_t v59;
  unsigned int v62;
  unsigned int v63;
  BOOL v64;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;

  if ((a1 & 0x100) != 0)
  {
    if (a5)
    {
      if (a5 < 4)
        return 0;
      *(_DWORD *)a4 = 1126769691;
      a4 += 4;
    }
    v8 = 4;
  }
  else
  {
    v8 = 0;
  }
  if (a3 < 1)
  {
    v9 = 0;
    goto LABEL_134;
  }
  v10 = 0;
  v9 = 0;
  v11 = 0xF73Eu;
  v12 = 1;
  v13 = v8;
LABEL_10:
  if (a5 && v13 >= a5)
  {
    if ((a1 & 0x10) == 0)
      goto LABEL_132;
    v14 = *a2;
    v15 = v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0;
    if (v15 && v14 - 12441 >= 2)
      goto LABEL_132;
    goto LABEL_32;
  }
  v14 = *a2;
  if (v14 > 0x7F)
  {
LABEL_32:
    if ((unsigned __int16)(v14 - 4447) <= 1u)
      goto LABEL_72;
    if (v14 - 4352 > 0xFE)
    {
LABEL_49:
      if (v14 < 0xA1)
        goto LABEL_75;
LABEL_50:
      v26 = (unsigned __int16 *)&KSX1001_from_uni;
      v27 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v11);
      while (1)
      {
        v28 = (0xF83E0F83E0F83E1 * (v27 - v26)) >> 1;
        v29 = &v26[33 * v28];
        v30 = *v29;
        if (v30 <= v14)
        {
          if (v30 + 32 > v14)
          {
            v45 = (uint64_t)&v26[33 * v28 + (int)(v14 - v30)];
            v46 = *(unsigned __int16 *)(v45 + 2);
            if (*(_WORD *)(v45 + 2))
            {
              v47 = 1;
              goto LABEL_92;
            }
            goto LABEL_56;
          }
          v26 = v29 + 33;
        }
        else
        {
          v27 = v29 - 33;
        }
        if (v26 > v27)
          goto LABEL_56;
      }
    }
    if (a3 - v9 < 2)
      goto LABEL_50;
    if (((v14 << 24) | 0xFFFFFFu) > 0x14FFFFFE)
      goto LABEL_50;
    v18 = a2[1] - 4449;
    if (v18 > 0x15)
      goto LABEL_50;
    if ((unint64_t)(a3 - v9) < 3)
    {
      v19 = 0;
    }
    else
    {
      v19 = a2[2] - 4519;
      if (v19 > 0x1Cu)
        v19 = 0;
    }
    v20 = (unsigned __int16)(v19 + 28 * (v18 + 21 * (char)v14) - 21504);
    if (v20 < 0xA1)
      goto LABEL_50;
    v21 = (unsigned __int16 *)&KSX1001_from_uni;
    v22 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v11);
    while (1)
    {
      v23 = (0xF83E0F83E0F83E1 * (v22 - v21)) >> 1;
      v24 = &v21[33 * v23];
      v25 = *v24;
      if (v25 <= v20)
      {
        if (v25 + 32 > v20)
        {
          v46 = v21[33 * v23 + 1 + (int)(v20 - v25)];
          if (!v46)
            goto LABEL_49;
          v64 = (__int16)v19 <= 0;
          v47 = 2;
          if (!v64)
            v47 = 3;
LABEL_92:
          if (v46 != 65533
            && v46 >> 8 >= 0xA1
            && v46 >> 8 != 255
            && v46 >= 0xA1u
            && v46 != 255)
          {
            v10 = v12 != 0;
            if (v12)
              v48 = v13 + 1;
            else
              v48 = v13;
            v13 = v48 + 2;
            if (!a5)
            {
LABEL_105:
              v12 = 0;
              a2 += v47;
              v9 += v47;
              goto LABEL_73;
            }
            if (v13 <= a5)
            {
              if (v12)
                *a4++ = 14;
              *a4 = BYTE1(v46) & 0x7F;
              a4[1] = v46 & 0x7F;
              a4 += 2;
              goto LABEL_105;
            }
LABEL_165:
            v66 = -3;
            if (!v12)
              v66 = -2;
            v13 += v66;
LABEL_168:
            v8 = v13 + 1;
            goto LABEL_142;
          }
LABEL_56:
          if ((unsigned __int16)(v14 + 0x2000) <= 0xBBu)
          {
            v10 = v12 != 0;
            if (v12)
              v31 = v13 + 1;
            else
              v31 = v13;
            v13 = v31 + 2;
            if (!a5)
              goto LABEL_71;
            if (v13 <= a5)
            {
              if (v12)
                *a4++ = 14;
              if (v14 >= 0xE05E)
                v32 = 126;
              else
                v32 = 73;
              *a4 = v32;
              if (v14 >= 0xE05E)
                v33 = 67;
              else
                v33 = 33;
              a4[1] = (v33 + v14) & 0x7F;
              a4 += 2;
              goto LABEL_71;
            }
            goto LABEL_165;
          }
LABEL_75:
          if ((a1 & 8) != 0 || v9 < 1)
            goto LABEL_132;
          if ((a1 & 0x10) == 0)
            goto LABEL_73;
          if ((v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0) && v14 - 12441 >= 2)
            goto LABEL_132;
          v34 = v12;
          v35 = v13;
          v68 = a3;
          v69 = a1;
          v36 = v10;
          v37 = a4;
          v38 = a6;
          v39 = __CFPrecomposeCharKorean(a2 - 1);
          if (!v39)
          {
            a6 = v38;
            a4 = v37;
LABEL_140:
            v10 = v36;
            v13 = v35;
            if (v34)
              goto LABEL_133;
            goto LABEL_141;
          }
          a6 = v38;
          a4 = v37;
          if (v39 < 0xA1)
            goto LABEL_140;
          v11 = 0xF73Eu;
          v40 = (unsigned __int16 *)&KSX1001_from_uni;
          v41 = (unsigned __int16 *)((char *)&KSX1001_from_uni + v11);
          v12 = v34;
          while (2)
          {
            v42 = (0xF83E0F83E0F83E1 * (v41 - v40)) >> 1;
            v43 = &v40[33 * v42];
            v44 = *v43;
            if (v44 > v39)
            {
              v41 = v43 - 33;
              goto LABEL_88;
            }
            if (v44 + 32 <= v39)
            {
              v40 = v43 + 33;
LABEL_88:
              if (v40 > v41)
                goto LABEL_130;
              continue;
            }
            break;
          }
          v49 = v40[33 * v42 + 1 + (int)(v39 - v44)];
          if (v40[33 * v42 + 1 + (int)(v39 - v44)])
            v50 = v49 == 65533;
          else
            v50 = 1;
          if (v50)
          {
LABEL_130:
            v10 = v36;
LABEL_131:
            v13 = v35;
            goto LABEL_132;
          }
          v10 = v36;
          if (v49 >> 8 < 0xA1)
            goto LABEL_131;
          v13 = v35;
          if (v49 >> 8 == 255
            || v40[33 * v42 + 1 + (int)(v39 - v44)] < 0xA1u
            || v40[33 * v42 + 1 + (int)(v39 - v44)] == 255)
          {
            goto LABEL_132;
          }
          v10 = v34 != 0;
          if (v34)
            v51 = v35 + 1;
          else
            v51 = v35;
          v52 = -2;
          if (v34 != 0 && !v36)
            v52 = -1;
          v13 = v51 + ((v34 != 0) & !v36);
          if (!a5)
          {
            a1 = v69;
            a3 = v68;
            goto LABEL_71;
          }
          a1 = v69;
          if (v13 > a5)
          {
            if (v34)
              v67 = -1;
            else
              v67 = 0;
            v13 += v67 - ((v34 != 0) & !v36);
            goto LABEL_168;
          }
          v53 = &a4[v52];
          if (v34)
            *v53++ = 14;
          a3 = v68;
          *v53 = BYTE1(v49) & 0x7F;
          a4 = v53 + 2;
          v53[1] = v49 & 0x7F;
LABEL_71:
          v12 = 0;
LABEL_72:
          ++a2;
          ++v9;
LABEL_73:
          if (v9 >= a3)
          {
LABEL_132:
            if (v12)
            {
LABEL_133:
              v8 = v13;
              goto LABEL_134;
            }
LABEL_141:
            v8 = v13 + 1;
            if (!a5)
              goto LABEL_134;
LABEL_142:
            if (v13 < a5)
            {
              *a4 = 15;
              goto LABEL_134;
            }
            v56 = a2 - 1;
            while (1)
            {
              v58 = *v56--;
              v57 = v58;
              v59 = (1 << (v58 - 6)) & 0x4000000000005;
              if ((v58 - 774 > 0x32 || v59 == 0) && v57 - 12441 >= 2)
              {
                v62 = v57 >> 5;
                v63 = v57 >> 9;
                v64 = v62 < 0x8B || v63 > 8;
                if (v64 || v9 < 2)
                {
LABEL_162:
                  --v9;
                  if (v10)
                  {
                    v8 = v13 - 3;
                  }
                  else
                  {
                    *(a4 - 2) = 15;
                    v8 = v13 - 1;
                  }
                  goto LABEL_134;
                }
              }
              else if (v9 <= 1)
              {
                goto LABEL_162;
              }
              --v9;
            }
          }
          goto LABEL_10;
        }
        v21 = v24 + 33;
      }
      else
      {
        v22 = v24 - 33;
      }
      if (v21 > v22)
        goto LABEL_49;
    }
  }
  v10 = v12 == 0;
  if (v12)
    v17 = v13;
  else
    v17 = v13 + 1;
  v13 = v17 + 1;
  if (!a5)
  {
LABEL_31:
    ++a2;
    ++v9;
    v12 = 1;
    goto LABEL_73;
  }
  if (v17 < a5)
  {
    if (!v12)
      *a4++ = 15;
    *a4++ = v14;
    goto LABEL_31;
  }
  v55 = -2;
  if (v12)
    v55 = -1;
  v8 = v13 + v55;
LABEL_134:
  *a6 = v8;
  return v9;
}

uint64_t __CFFromISO_2022_KR(uint64_t a1, char *__s1, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  unint64_t v9;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  unsigned __int16 v19;
  unsigned int v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  uint64_t v23;
  unsigned __int16 *v24;
  unsigned int v25;
  BOOL v26;
  unsigned __int16 v27;
  BOOL v28;
  unsigned __int16 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  __int16 *v38;
  unsigned __int16 v39;
  int v41;
  _BYTE v42[10];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (a3 < 1)
    return 0;
  v9 = a3;
  v12 = 0;
  v13 = 0;
  v41 = a1 & 0xC0;
  v14 = 1;
  while (2)
  {
    if (a5 && v12 >= a5)
      goto LABEL_67;
    v15 = *__s1;
    if (v9 >= 4 && v15 == 27)
    {
      if (!strncmp(__s1, "\x1B$)C", 4uLL))
      {
        v17 = 4;
        goto LABEL_36;
      }
      v16 = 27;
    }
    else
    {
      if (v15 == 14)
      {
        v14 = 0;
        v17 = 1;
        goto LABEL_36;
      }
      v16 = *__s1;
      if (v15 == 15)
        goto LABEL_15;
    }
    if (v14)
    {
      if (a5)
        *a4++ = v15;
      *a6 = ++v12;
LABEL_15:
      v17 = 1;
      v14 = 1;
      goto LABEL_36;
    }
    if (v9 < 2
      || (v16 | 0x80u) < 0xA1
      || (v16 | 0x80) == 0xFF
      || (v18 = __s1[1], (v18 | 0x80u) < 0xA1)
      || (v18 | 0x80) == 0xFF)
    {
      if ((a1 & 1) != 0)
      {
        if (a5)
          *a4++ = 63;
        v14 = 0;
        *a6 = ++v12;
        v17 = 1;
        if (v9 > 1)
          v17 = 2;
        goto LABEL_36;
      }
      goto LABEL_66;
    }
    v19 = v18 | ((_WORD)v16 << 8) | 0x8080;
    v20 = v19;
    if ((unsigned __int16)(v19 + 478) < 0x831Fu)
      break;
    v21 = (unsigned __int16 *)&KSX1001_to_uni;
    v22 = (unsigned __int16 *)((char *)&KSX1001_to_uni + 40820);
    while (1)
    {
      v23 = (0xFC0FC0FC0FC0FC1 * (v22 - v21)) >> 1;
      v24 = &v21[65 * v23];
      v25 = *v24;
      if (v25 <= v20)
        break;
      v22 = v24 - 65;
LABEL_28:
      if (v21 > v22)
        goto LABEL_44;
    }
    if (v25 + 64 <= v20)
    {
      v21 = v24 + 65;
      goto LABEL_28;
    }
    v27 = v21[65 * v23 + 1 + (int)(v20 - v25)];
    if (v27)
      v28 = v21[65 * v23 + 1 + (int)(v20 - v25)] == 65533;
    else
      v28 = 1;
    if (!v28)
    {
      if (!v41
        || !__CFStringEncodingIsDecomposableCharacter_0(v21[65 * v23 + 1 + (int)(v20 - v25)], (a1 >> 7) & 1))
      {
        if (a5)
          *a4++ = v27;
        v14 = 0;
        v12 = *a6 + 1;
        goto LABEL_52;
      }
      v35 = __CFStringEncodingDecomposeCharacter_0(a1, v27, v42, v30, v31, v32, v33, v34);
      v36 = *a6;
      v12 = *a6 + v35;
      *a6 = v12;
      if (!a5)
        goto LABEL_61;
      if (v12 > a5)
      {
        v14 = 0;
        *a6 = v36;
        v12 = v36;
        goto LABEL_68;
      }
      if (v35 >= 1)
      {
        v37 = v35 + 1;
        v38 = (__int16 *)v42;
        do
        {
          v39 = *v38++;
          *a4++ = v39;
          --v37;
        }
        while (v37 > 1);
      }
LABEL_61:
      v14 = 0;
LABEL_53:
      v17 = 2;
LABEL_36:
      v13 += v17;
      __s1 += v17;
      v26 = (uint64_t)v9 <= v17;
      v9 -= v17;
      if (v26)
        return v13;
      continue;
    }
    break;
  }
LABEL_44:
  if ((unsigned __int16)(v20 + 13919) <= 0x5Du)
  {
    if (a5)
    {
      v29 = v20 + 5727;
      goto LABEL_50;
    }
    goto LABEL_51;
  }
  if ((unsigned __int16)(v20 + 351) <= 0x5Du)
  {
    if (a5)
    {
      v29 = v20 - 3907;
LABEL_50:
      *a4++ = v29;
    }
LABEL_51:
    v14 = 0;
    ++v12;
LABEL_52:
    *a6 = v12;
    goto LABEL_53;
  }
LABEL_66:
  v14 = 0;
LABEL_67:
  if (a5)
  {
LABEL_68:
    if (v9 == 1 && !v14 && v12 == a5 && *__s1 == 15)
      ++v13;
  }
  return v13;
}

uint64_t __CFToISO_2022_KRLen(unsigned int a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3;
  BOOL v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;

  v3 = (a1 >> 6) & 4;
  if (a3)
  {
    v4 = 1;
    do
    {
      v6 = *a2++;
      v5 = v6;
      if (v4)
        v7 = 1;
      else
        v7 = 2;
      if (v4)
        v8 = 3;
      else
        v8 = 2;
      v4 = v5 < 0x80;
      if (v5 >= 0x80)
        v7 = v8;
      v3 += v7;
      --a3;
    }
    while (a3);
    v9 = v5 > 0x7F;
  }
  else
  {
    v9 = 0;
  }
  return v3 + v9;
}

uint64_t __CFFromISO_2022_KRLen(int a1, char *__s1, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  char v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  int v11;
  BOOL v12;
  BOOL v13;

  if (a3 >= 1)
  {
    v3 = a3;
    v5 = 0;
    v6 = 1;
    while (1)
    {
      v7 = *__s1;
      if ((unint64_t)v3 >= 4 && v7 == 27)
      {
        if (strncmp(__s1, "\x1B$)C", 4uLL))
          goto LABEL_10;
        v8 = -4;
        v9 = 4;
      }
      else if (v7 == 14)
      {
        v6 = 0;
        v8 = -1;
        v9 = 1;
      }
      else
      {
        if (v7 != 15)
        {
LABEL_10:
          if (v6)
            v10 = 0;
          else
            v10 = (unint64_t)v3 >= 2;
          v11 = !v10;
          ++v5;
          v12 = v11 == 0;
          if (v11)
            v9 = 1;
          else
            v9 = 2;
          if (v11)
            v8 = -1;
          else
            v8 = -2;
          if (v12)
            v6 = 0;
          goto LABEL_26;
        }
        v9 = 1;
        v8 = -1;
        v6 = 1;
      }
LABEL_26:
      __s1 += v9;
      v13 = __OFADD__(v3, v8);
      v3 += v8;
      if ((v3 < 0) ^ v13 | (v3 == 0))
        return v5;
    }
  }
  return 0;
}

uint64_t __CFToMacKorean(int a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v10;
  uint64_t v11;
  _BOOL4 v12;
  unsigned int v13;
  uint64_t v16;
  unsigned __int16 *v17;
  unsigned __int16 *v18;
  uint64_t v19;
  unsigned __int16 *v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  uint64_t v34;
  unsigned __int16 *v35;
  unsigned int v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  uint64_t v39;
  unsigned __int16 *v40;
  unsigned int v41;
  unint64_t v42;
  unint64_t v43;
  char v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  _BOOL4 v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  char v54;
  char v55;
  int v56;
  uint64_t v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int *v60;
  unsigned int *v61;
  uint64_t v62;
  unsigned int *v63;
  int v64;
  int v65;
  unsigned int v66;
  unsigned int *v67;
  unsigned int *v68;
  uint64_t v69;
  unsigned int *v70;
  unsigned int *v71;
  unsigned int *v72;
  __int16 v73;
  unsigned int v74;
  char v75;
  char v76;
  int v77;
  unsigned int v78;
  char v79;
  int v80;
  char v81;
  int v82;
  unsigned int v83;
  __int16 v84;
  BOOL v85;
  __int16 v86;
  unsigned int v87;
  unsigned int *v88;
  unsigned int *v89;
  uint64_t v90;
  unsigned int *v91;
  unsigned int v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  unsigned __int16 *v96;
  unsigned __int16 *v97;
  uint64_t v98;
  unsigned __int16 *v99;
  unsigned int v100;
  unsigned __int16 *v101;
  unsigned __int16 *v102;
  uint64_t v103;
  unsigned __int16 *v104;
  unsigned int v105;
  int v106;
  __int16 v107;
  unsigned int v108;
  unsigned int *v109;
  unsigned int *v110;
  uint64_t v111;
  unsigned int *v112;
  int v113;
  int v114;
  unsigned int v115;
  char v116;
  int v117;
  unsigned int v118;
  uint64_t v119;
  uint64_t v120;
  char *v121;
  char *v122;
  uint64_t v123;
  __int16 v124;
  unsigned __int16 *v125;
  unsigned __int16 *v126;
  uint64_t v127;
  unsigned __int16 *v128;
  unsigned int v129;
  unsigned __int16 *v130;
  uint64_t v131;
  unsigned __int16 *v132;
  unsigned __int16 *v133;
  uint64_t v134;
  unsigned __int16 *v135;
  unsigned int v136;
  char v137;
  uint64_t v138;
  unsigned int v139;
  uint64_t v140;
  char *v141;
  unsigned __int16 v142;
  unsigned __int16 *v143;
  unsigned __int16 *v144;
  uint64_t v145;
  unsigned __int16 *v146;
  unsigned int v147;
  unsigned __int16 v148;
  unsigned __int16 *v149;
  unsigned __int16 *v150;
  uint64_t v151;
  unsigned __int16 *v152;
  unsigned int v153;
  uint64_t v154;
  uint64_t v155;
  char *v156;
  uint64_t v158;
  BOOL v159;
  char *v160;
  int v161;
  _QWORD *v162;
  int v163;
  _BOOL4 v164;
  unsigned __int16 v165;
  uint64_t v166[2];

  v166[1] = *MEMORY[0x1E0C80C00];
  if (a3 < 1)
  {
    v10 = 0;
    v11 = 0;
    goto LABEL_452;
  }
  v10 = 0;
  v11 = 0;
  v163 = 0;
  v166[0] = 0;
  v165 = 0;
  v12 = 1;
LABEL_3:
  if (a5 && v10 >= a5)
  {
    if ((a1 & 0x10) == 0)
      goto LABEL_452;
    v13 = *a2;
    if (v13 - 774 <= 0x32 && ((1 << (v13 - 6)) & 0x4000000000005) != 0 || v13 - 12441 < 2)
    {
LABEL_13:
      v165 = *a2;
      goto LABEL_16;
    }
    v26 = v13 & 0xFFF0;
    if (v26 != 8400 && v26 != 8416 && v26 != 63600)
    {
      if (v13 != 839 && v13 != 822)
        goto LABEL_452;
      goto LABEL_13;
    }
  }
  else
  {
    v13 = *a2;
  }
  v165 = v13;
  if (v13 < 0x80)
    goto LABEL_18;
LABEL_16:
  if ((a1 & 0x80) != 0 && (unsigned __int16)(v13 - 133) <= 0x1Au)
  {
LABEL_18:
    if (a5)
      *a4++ = v13;
    ++v10;
    ++a2;
    v16 = v11 + 1;
    v12 = 1;
    goto LABEL_110;
  }
  v16 = v11 + 1;
  if (v11 + 1 < a3 && (__int16)a2[1] == -1921 && (v13 == 8211 || v13 == 65343 || v13 == 8230))
  {
    if (a5)
    {
      if (v13 != 65343)
      {
        if (v13 != 8230)
          *a4++ = -126;
        *a4++ = -1;
      }
      *a4++ = -124;
    }
    v12 = 0;
    ++v10;
    v16 = v11 + 2;
    a2 += 2;
    goto LABEL_110;
  }
  if ((unsigned __int16)(v13 + 418) < 0x242u)
    goto LABEL_40;
  v17 = (unsigned __int16 *)&MacKorean_from_uni_one_char;
  v18 = (unsigned __int16 *)&unk_182CF461A;
  while (1)
  {
    v19 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (v18 - v17)) >> 1;
    v20 = &v17[5 * v19];
    v21 = *v20;
    if (v21 <= v13)
      break;
    v18 = v20 - 5;
LABEL_39:
    if (v17 > v18)
      goto LABEL_40;
  }
  if (v21 + 4 <= v13)
  {
    v17 = v20 + 5;
    goto LABEL_39;
  }
  v27 = (uint64_t)&v17[5 * v19 + (int)(v13 - v21)];
  v28 = *(unsigned __int16 *)(v27 + 2);
  if (*(_WORD *)(v27 + 2))
  {
    v12 = v28 < 0x100;
    if (v28 < 0x100)
      v29 = 1;
    else
      v29 = 2;
    v30 = v29 + v10;
    if (a5)
    {
      if (v30 > a5)
        goto LABEL_452;
      if (v28 >= 0x100)
        *a4++ = BYTE1(v28);
      *a4++ = v28;
    }
    goto LABEL_108;
  }
LABEL_40:
  v164 = v12;
  v22 = a3 - v11;
  v23 = *a2;
  if (v23 - 4352 > 0xFE)
    goto LABEL_71;
  if (v22 < 2)
    goto LABEL_72;
  if (((v23 << 24) | 0xFFFFFFu) > 0x14FFFFFE)
    goto LABEL_72;
  v24 = a2[1] - 4449;
  if (v24 > 0x15)
    goto LABEL_72;
  if ((unint64_t)v22 < 3)
  {
    v25 = 0;
  }
  else
  {
    v25 = a2[2] - 4519;
    if ((unsigned __int16)(a2[2] - 4519) > 0x1Cu)
      v25 = 0;
  }
  v31 = v25 + 28 * (v24 + 21 * (char)v23) - 21504;
  if ((unsigned __int16)v31 < 0xA1u)
  {
LABEL_72:
    v37 = (unsigned __int16 *)&KSX1001_from_uni;
    v38 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
    while (1)
    {
      v39 = (0xF83E0F83E0F83E1 * (v38 - v37)) >> 1;
      v40 = &v37[33 * v39];
      v41 = *v40;
      if (v41 <= v23)
      {
        if (v41 + 32 > v23)
        {
          v46 = (uint64_t)&v37[33 * v39 + (int)(v23 - v41)];
          LODWORD(v43) = *(unsigned __int16 *)(v46 + 2);
          if (*(_WORD *)(v46 + 2))
          {
            v47 = 1;
            goto LABEL_97;
          }
          goto LABEL_78;
        }
        v37 = v40 + 33;
      }
      else
      {
        v38 = v40 - 33;
      }
      if (v37 > v38)
        goto LABEL_78;
    }
  }
  v32 = (unsigned __int16 *)&KSX1001_from_uni;
  v33 = (unsigned __int16 *)((char *)&KSX1001_from_uni + 63294);
  while (1)
  {
    v34 = (0xF83E0F83E0F83E1 * (v33 - v32)) >> 1;
    v35 = &v32[33 * v34];
    v36 = *v35;
    if (v36 <= (unsigned __int16)v31)
      break;
    v33 = v35 - 33;
LABEL_70:
    if (v32 > v33)
      goto LABEL_71;
  }
  if (v36 + 32 <= (unsigned __int16)v31)
  {
    v32 = v35 + 33;
    goto LABEL_70;
  }
  v57 = (uint64_t)&v32[33 * v34 + (int)((unsigned __int16)v31 - v36)];
  LODWORD(v43) = *(unsigned __int16 *)(v57 + 2);
  if (!*(_WORD *)(v57 + 2))
  {
LABEL_71:
    if (v23 < 0xA1)
      goto LABEL_78;
    goto LABEL_72;
  }
  if ((__int16)v25 <= 0)
    v47 = 2;
  else
    v47 = 3;
  v163 = v31;
LABEL_97:
  v166[0] = v47;
  if ((_DWORD)v43 == 65533)
  {
LABEL_78:
    LOBYTE(v42) = -1;
    LOBYTE(v43) = -3;
  }
  else
  {
    LODWORD(v42) = v43 >> 8;
    if (v43 >> 8 >= 0xA1
      && (_DWORD)v42 != 255
      && v43 >= 0xA1u
      && v43 != 255)
    {
      if (a5)
      {
        if (v10 + 2 > a5)
          goto LABEL_452;
        *(_WORD *)a4 = __rev16(v43);
        a4 += 2;
        v47 = v166[0];
      }
      v12 = 0;
      v16 = v47 + v11;
      v10 += 2;
      goto LABEL_106;
    }
  }
  if ((unsigned __int16)(v13 + 0x2000) <= 0xBBu)
  {
    v30 = v10 + 2;
    if (a5)
    {
      if (v30 > a5)
        goto LABEL_452;
      if (v13 >= 0xE05E)
        v44 = -2;
      else
        v44 = -55;
      *a4 = v44;
      if (v165 >= 0xE05Eu)
        v45 = 67;
      else
        v45 = -95;
      a4[1] = v45 + v165;
      a4 += 2;
    }
LABEL_107:
    v12 = 0;
LABEL_108:
    ++a2;
LABEL_109:
    v10 = v30;
    goto LABEL_110;
  }
  if ((unsigned __int16)(v13 - 4447) <= 1u)
  {
    ++a2;
LABEL_94:
    v12 = v164;
    goto LABEL_110;
  }
  if ((a1 & 8) != 0)
    goto LABEL_452;
  if ((a1 & 0x10) == 0)
  {
    v16 = v11;
    goto LABEL_94;
  }
  v49 = v13 == 63584 || (unsigned __int16)(v13 + 1945) < 3u;
  if (v22 < 3 || !v49)
  {
    if (v22 > 3 && v13 == 63585)
    {
      v53 = a2[1];
      if (v53 == 40)
      {
        v74 = a2[2];
        v75 = v74 - 65;
        if (v74 - 65 > 0x19 || a2[3] != 41)
          goto LABEL_452;
        if (v74 >= 0x56)
          v76 = 108;
        else
          v76 = 105;
        v55 = v75 + v76;
        v54 = -93;
      }
      else
      {
        if (v53 != 8224 || a2[2] != 8224 || a2[3] != 8224)
          goto LABEL_452;
        v54 = -90;
        v55 = 70;
      }
      v30 = v10 + 2;
      if (a5)
      {
        if (v30 > a5)
          goto LABEL_452;
        *a4 = v54;
        a4[1] = v55;
        a4 += 2;
      }
      v12 = 0;
      a2 += 4;
      v16 = v11 + 4;
      goto LABEL_109;
    }
    if (v22 >= 5 && (unsigned __int16)(v13 + 1950) <= 4u)
    {
      v56 = a2[1];
      if (v56 == 91)
      {
        v77 = a2[2];
        if (v77 == 50)
        {
          if (a2[3] == 48 && a2[4] == 93)
          {
            v79 = v13 - 98;
            if ((unsigned __int16)(v13 + 1950) < 5u)
            {
              v43 = 0xF66854F954uLL >> (8 * v79);
              v42 = 0xACA4A3A2A4uLL >> (8 * v79);
            }
            goto LABEL_399;
          }
        }
        else if (v77 == 49)
        {
          v78 = a2[3];
          if (v78 - 48 <= 9 && a2[4] == 93)
          {
            switch(v13)
            {
              case 0xF862u:
                LOBYTE(v43) = v78 + 26;
                goto LABEL_394;
              case 0xF863u:
                LOBYTE(v43) = v78 - 65;
                LOBYTE(v42) = -94;
                break;
              case 0xF864u:
                LOBYTE(v43) = v78 + 26;
                LOBYTE(v42) = -93;
                break;
              case 0xF865u:
                LOBYTE(v43) = v78 + 46;
LABEL_394:
                LOBYTE(v42) = -92;
                break;
              case 0xF866u:
                if (v78 >= 0x36)
                  v137 = -20;
                else
                  v137 = -53;
                LOBYTE(v43) = v78 - 48 + v137;
                LOBYTE(v42) = -84;
                break;
              default:
                goto LABEL_399;
            }
            goto LABEL_399;
          }
        }
      }
      else if (v56 == 51452 && a2[2] == 49885 && a2[3] == 54924 && a2[4] == 49324)
      {
        if (v13 == 63587)
        {
          LOBYTE(v42) = -89;
          LOBYTE(v43) = -127;
        }
        else if (v13 == 63586)
        {
          LOBYTE(v42) = -89;
          LOBYTE(v43) = 125;
        }
        goto LABEL_399;
      }
      if (v13 > 0xF864)
        goto LABEL_452;
      if (v56 != 40)
      {
        if (v13 > 0xF863 || v56 != 91 || a2[4] != 93)
          goto LABEL_452;
        v82 = a2[2];
        if (v82 == 21313)
        {
          v87 = a2[3] | (v13 << 16);
          if (v87 + 127707428 < 0xFFFEF724)
            goto LABEL_452;
          v88 = (unsigned int *)&MacKorean_from_uni_0xF862_3;
          v89 = (unsigned int *)&unk_182CF4DF0;
          while (1)
          {
            v90 = ((char *)v89 - (char *)v88) >> 4;
            v91 = &v88[2 * v90];
            if (*v91 <= v87)
            {
              if (*v91 >= v87)
              {
                LODWORD(v43) = LOWORD(v88[2 * v90 + 1]);
                LODWORD(v42) = v43 >> 8;
                goto LABEL_399;
              }
              v88 = v91 + 2;
            }
            else
            {
              v89 = v91 - 2;
            }
            if (v88 > v89)
              goto LABEL_452;
          }
        }
        if (v82 != 20108 || a2[3] != 21313)
          goto LABEL_452;
        if (v13 == 63586)
          LOBYTE(v43) = 104;
        else
          LOBYTE(v43) = 84;
        LOBYTE(v42) = -83;
        goto LABEL_399;
      }
      v80 = a2[2];
      if (v80 != 50)
      {
        if (v80 != 51 || a2[3] != 48 || a2[4] != 41)
          goto LABEL_452;
        v81 = v13 - 98;
        if ((unsigned __int16)(v13 + 1950) < 3u)
        {
          LODWORD(v43) = 0xFCFEFAu >> (8 * v81);
          LODWORD(v42) = 0xA5A7ABu >> (8 * v81);
        }
        goto LABEL_399;
      }
      v83 = a2[3];
      v84 = v83 - 49;
      if (v83 - 49 > 8 || a2[4] != 41)
        goto LABEL_452;
      switch(v13)
      {
        case 0xF864u:
          v85 = v83 >= 0x37;
          LOWORD(v42) = -23053;
          v86 = -22791;
          break;
        case 0xF863u:
          LOBYTE(v43) = v83 - 60;
          LOBYTE(v42) = -89;
LABEL_399:
          if (a5)
          {
            if (v10 + 2 > a5)
              goto LABEL_452;
            *a4 = v42;
            a4[1] = v43;
            a4 += 2;
          }
          v12 = 0;
          a2 += 5;
          v16 = v11 + 5;
          v10 += 2;
          goto LABEL_110;
        case 0xF862u:
          v85 = v83 >= 0x37;
          LOWORD(v42) = -21519;
          v86 = -21767;
          break;
        default:
          goto LABEL_399;
      }
      if (!v85)
        LOWORD(v42) = v86;
      LOBYTE(v43) = v84 + v42;
      LOBYTE(v42) = (unsigned __int16)(v84 + v42) >> 8;
      goto LABEL_399;
    }
    if (v22 > 1)
    {
      v64 = a2[1];
      v65 = v64 & 0xFFF0;
      v66 = v64 | (v13 << 16);
      if (v65 == 63600 && v66 + 12584832 >= 0xE1FFF7)
      {
        v67 = (unsigned int *)&MacKorean_from_uni_0xF870;
        v68 = (unsigned int *)&unk_182CF59E8;
        do
        {
          v69 = ((char *)v68 - (char *)v67) >> 4;
          v70 = &v67[2 * v69];
          if (*v70 <= v66)
          {
            if (*v70 >= v66)
            {
LABEL_247:
              v30 = v10 + 2;
              if (a5)
              {
                if (v30 > a5)
                  goto LABEL_452;
                *(_WORD *)a4 = __rev16(LOWORD(v67[2 * v69 + 1]));
                a4 += 2;
              }
              v12 = 0;
              a2 += 2;
              v16 = v11 + 2;
              goto LABEL_109;
            }
            v67 = v70 + 2;
          }
          else
          {
            v68 = v70 - 2;
          }
        }
        while (v67 <= v68);
      }
      if (v66 - 721224520 >= 0xFAB71D9C)
      {
        v67 = (unsigned int *)&MacKorean_from_uni_other_two_char;
        v71 = (unsigned int *)&unk_182CF5A08;
        do
        {
          v69 = ((char *)v71 - (char *)v67) >> 4;
          v72 = &v67[2 * v69];
          if (*v72 <= v66)
          {
            if (*v72 >= v66)
              goto LABEL_247;
            v67 = v72 + 2;
          }
          else
          {
            v71 = v72 - 2;
          }
        }
        while (v67 <= v71);
      }
    }
    if (v11 < 1)
      goto LABEL_452;
    v162 = a6;
    if ((int)v13 > 823)
    {
      if (v13 - 12441 >= 2)
      {
        if (v13 != 824)
        {
          if (v13 == 839)
          {
            if (*(a2 - 1) != 8741)
              goto LABEL_309;
            if (a5)
            {
              v73 = -24924;
              goto LABEL_209;
            }
LABEL_210:
            v12 = 0;
            ++a2;
            goto LABEL_110;
          }
LABEL_282:
          switch(v13)
          {
            case 0x20DDu:
              v95 = v163;
              if (*(a2 - 1) - 4352 >= 0xFF)
                v95 = *(a2 - 1);
              if (v22 < 2
                || (__int16)a2[1] != -1926
                || (unsigned __int16)((unsigned __int16)v95 >> 10) < 0x2Bu
                || (unsigned __int16)v95 > 0xD574u)
              {
                goto LABEL_295;
              }
              v96 = (unsigned __int16 *)&MacKorean_from_uni_0x20DD_0xF87A;
              v97 = (unsigned __int16 *)&unk_182CF46B0;
              while (1)
              {
                v98 = ((char *)v97 - (char *)v96) >> 3;
                v99 = &v96[2 * v98];
                v100 = *v99;
                if (v100 <= (unsigned __int16)v95)
                {
                  if (v100 >= (unsigned __int16)v95)
                  {
                    v130 = &v96[2 * v98 + 1];
                    v131 = 2;
LABEL_404:
                    if (v164)
                      v138 = v10 + 1;
                    else
                      v138 = v10;
                    v163 = v95;
                    if (!a5)
                    {
LABEL_412:
                      v12 = 0;
                      v16 = v131 + v11;
                      v10 = v138;
                      a2 += v131;
                      goto LABEL_110;
                    }
                    if (v138 <= a5)
                    {
                      v139 = *v130;
                      v140 = -2;
                      if (v164)
                        v140 = -1;
                      v141 = &a4[v140];
                      *(_WORD *)v141 = __rev16(v139);
                      a4 = v141 + 2;
                      goto LABEL_412;
                    }
                    v158 = v138 - 1;
                    v159 = !v164;
LABEL_458:
                    if (!v159)
                      v10 = v158;
                    goto LABEL_452;
                  }
                  v96 = v99 + 2;
                }
                else
                {
                  v97 = v99 - 2;
                }
                if (v96 > v97)
                {
LABEL_295:
                  if ((unsigned __int16)(v95 + 10443) < 0x29C2u)
                    goto LABEL_452;
                  v101 = (unsigned __int16 *)&MacKorean_from_uni_0x20DD;
                  v102 = (unsigned __int16 *)&unk_182CF4844;
                  while (1)
                  {
                    v103 = ((char *)v102 - (char *)v101) >> 3;
                    v104 = &v101[2 * v103];
                    v105 = *v104;
                    if (v105 <= (unsigned __int16)v95)
                    {
                      if (v105 >= (unsigned __int16)v95)
                      {
                        v130 = &v101[2 * v103 + 1];
                        v131 = 1;
                        goto LABEL_404;
                      }
                      v101 = v104 + 2;
                    }
                    else
                    {
                      v102 = v104 - 2;
                    }
                    if (v101 > v102)
                      goto LABEL_452;
                  }
                }
              }
            case 0x20DEu:
              v113 = v163;
              if (*(a2 - 1) - 4352 >= 0xFF)
                v113 = *(a2 - 1);
              if (v22 < 2)
                goto LABEL_426;
              v114 = a2[1];
              if ((v114 & 0xFFF0) == 0xF870)
              {
                v165 = v113;
                if ((unsigned __int16)(v113 - 49) <= 8u)
                {
                  v47 = 2;
                  switch(v114)
                  {
                    case 63605:
                      LOBYTE(v43) = v113 - 111;
                      LOBYTE(v42) = -84;
                      goto LABEL_441;
                    case 63610:
                      LOBYTE(v43) = v113 + 36;
                      goto LABEL_440;
                    case 63611:
                      LOBYTE(v43) = v113 + 16;
                      LOBYTE(v42) = -93;
                      goto LABEL_441;
                    case 63612:
                      LOBYTE(v43) = v113 - 75;
                      LOBYTE(v42) = -94;
                      goto LABEL_441;
                    case 63615:
                      LOBYTE(v43) = v113 + 16;
LABEL_440:
                      LOBYTE(v42) = -92;
                      goto LABEL_441;
                    default:
                      goto LABEL_442;
                  }
                }
              }
              if (v114 != 63612)
              {
                if (v114 == 63610)
                {
                  if ((unsigned __int16)(v113 + 2042) < 0x82Au)
                    goto LABEL_452;
                  v125 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE;
                  v126 = (unsigned __int16 *)&unk_182CF4998;
                  while (1)
                  {
                    v127 = ((char *)v126 - (char *)v125) >> 3;
                    v128 = &v125[2 * v127];
                    v129 = *v128;
                    if (v129 <= (unsigned __int16)v113)
                    {
                      if (v129 >= (unsigned __int16)v113)
                      {
                        v142 = v125[2 * v127 + 1];
                        if ((unsigned __int16)(v142 + 21163) > 9u)
                        {
LABEL_415:
                          if ((unsigned __int16)(v113 + 10891) < 0xB4C6u)
                            goto LABEL_452;
                          v143 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE_F87A;
                          v144 = (unsigned __int16 *)&unk_182CF49C4;
                          while (1)
                          {
                            v145 = ((char *)v144 - (char *)v143) >> 3;
                            v146 = &v143[2 * v145];
                            v147 = *v146;
                            if (v147 <= (unsigned __int16)v113)
                            {
                              if (v147 >= (unsigned __int16)v113)
                              {
                                LODWORD(v43) = v143[2 * v145 + 1];
                                LODWORD(v42) = v43 >> 8;
                                goto LABEL_441;
                              }
                              v143 = v146 + 2;
                            }
                            else
                            {
                              v144 = v146 - 2;
                            }
                            if (v143 > v144)
                              goto LABEL_452;
                          }
                        }
                        LOBYTE(v43) = v142 - 20;
LABEL_425:
                        LOBYTE(v42) = -83;
LABEL_441:
                        v47 = 2;
LABEL_442:
                        if (v164)
                          v154 = v10 + 1;
                        else
                          v154 = v10;
                        v163 = v113;
                        if (a5)
                        {
                          if (v154 > a5)
                          {
                            v158 = v154 - 1;
                            v159 = !v164;
                            goto LABEL_458;
                          }
                          v155 = -2;
                          if (v164)
                            v155 = -1;
                          v156 = &a4[v155];
                          *v156 = v42;
                          a4 = v156 + 2;
                          v156[1] = v43;
                        }
                        v12 = 0;
                        v16 = v47 + v11;
                        v10 = v154;
LABEL_106:
                        a2 += v47;
                        goto LABEL_110;
                      }
                      v125 = v128 + 2;
                    }
                    else
                    {
                      v126 = v128 - 2;
                    }
                    if (v125 > v126)
                      goto LABEL_415;
                  }
                }
LABEL_426:
                if ((unsigned __int16)(v113 + 2042) < 0x82Au)
                  goto LABEL_452;
                v149 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE;
                v150 = (unsigned __int16 *)&unk_182CF4998;
                while (1)
                {
                  v151 = ((char *)v150 - (char *)v149) >> 3;
                  v152 = &v149[2 * v151];
                  v153 = *v152;
                  if (v153 <= (unsigned __int16)v113)
                  {
                    if (v153 >= (unsigned __int16)v113)
                    {
                      LODWORD(v43) = v149[2 * v151 + 1];
                      LODWORD(v42) = v43 >> 8;
                      v47 = 1;
                      goto LABEL_442;
                    }
                    v149 = v152 + 2;
                  }
                  else
                  {
                    v150 = v152 - 2;
                  }
                  if (v149 > v150)
                    goto LABEL_452;
                }
              }
              if ((unsigned __int16)(v113 + 2042) < 0x82Au)
                goto LABEL_452;
              v132 = (unsigned __int16 *)&MacKorean_from_uni_0x20DE;
              v133 = (unsigned __int16 *)&unk_182CF4998;
              while (1)
              {
                v134 = ((char *)v133 - (char *)v132) >> 3;
                v135 = &v132[2 * v134];
                v136 = *v135;
                if (v136 <= (unsigned __int16)v113)
                {
                  if (v136 >= (unsigned __int16)v113)
                  {
                    v148 = v132[2 * v134 + 1];
                    if ((unsigned __int16)(v148 + 21143) <= 6u)
                    {
                      LOBYTE(v43) = v148 + 14;
                      goto LABEL_425;
                    }
                    goto LABEL_426;
                  }
                  v132 = v135 + 2;
                }
                else
                {
                  v133 = v135 - 2;
                }
                if (v132 > v133)
                  goto LABEL_426;
              }
            case 0x20DFu:
              v115 = *(a2 - 1);
              if (v115 > 0x25C6)
              {
                if (v115 == 9671)
                {
                  if (v16 < a3 && a2[1] == 8415)
                  {
                    v116 = 97;
                    ++a2;
                    ++v11;
                  }
                  else
                  {
                    v116 = 87;
                  }
                }
                else
                {
                  if (v115 != 63494)
                    goto LABEL_452;
                  v116 = 96;
                }
              }
              else if (v115 == 9632)
              {
                v116 = 86;
              }
              else
              {
                if (v115 != 9633)
                  goto LABEL_452;
                v116 = 89;
              }
              if (a5)
              {
                *(a4 - 2) = -90;
                *(a4 - 1) = v116;
              }
              v12 = 0;
              ++a2;
              v16 = v11 + 1;
              goto LABEL_110;
            case 0x20E0u:
            case 0x20E1u:
            case 0x20E2u:
            case 0x20E3u:
              goto LABEL_309;
            case 0x20E4u:
              if (*(a2 - 1) != 35036)
                goto LABEL_452;
              if (a5)
                *((_WORD *)a4 - 1) = 31911;
              goto LABEL_372;
            case 0x20E5u:
              v117 = *(a2 - 1);
              if (v117 == 8801)
              {
                if (!a5)
                  goto LABEL_368;
                v124 = 25511;
                goto LABEL_367;
              }
              if (v117 != 61)
                goto LABEL_452;
              v30 = v10 + 1;
              if (a5)
              {
                if (v10 >= a5)
                  goto LABEL_452;
                v107 = 25255;
                goto LABEL_337;
              }
              goto LABEL_107;
            default:
              if (v13 != 8402)
                goto LABEL_309;
              v106 = *(a2 - 1);
              if (v106 == 8801)
              {
                if (a5)
                {
                  v124 = 28327;
LABEL_367:
                  *((_WORD *)a4 - 1) = v124;
                }
LABEL_368:
                v30 = v10;
              }
              else
              {
                if (v106 != 61)
                  goto LABEL_452;
                v30 = v10 + 1;
                if (a5)
                {
                  if (v10 >= a5)
                    goto LABEL_452;
                  v107 = 26023;
LABEL_337:
                  *(_WORD *)(a4++ - 1) = v107;
                }
              }
              goto LABEL_107;
          }
        }
        if (*(a2 - 1) == 8869)
        {
          if (a5)
            *((_WORD *)a4 - 1) = 28071;
          v12 = 0;
          ++a2;
          goto LABEL_110;
        }
      }
    }
    else if (v13 != 774)
    {
      if (v13 != 776)
      {
        if (v13 == 822)
        {
          if (*(a2 - 1) != 8765)
          {
LABEL_309:
            if ((v13 & 0xFFF0) != 0xF870)
              goto LABEL_452;
            v108 = v13 | (*(a2 - 1) << 16);
            if (v108 + 12584832 < 0xE1FFF7)
              goto LABEL_452;
            v109 = (unsigned int *)&MacKorean_from_uni_0xF870;
            v110 = (unsigned int *)&unk_182CF59E8;
            while (1)
            {
              v111 = ((char *)v110 - (char *)v109) >> 4;
              v112 = &v109[2 * v111];
              if (*v112 <= v108)
              {
                if (*v112 >= v108)
                {
                  v118 = LOWORD(v109[2 * v111 + 1]);
                  if (v118 >= 0x100)
                    v119 = 0;
                  else
                    v119 = -1;
                  if (v164)
                    v119 = 1;
                  v10 += v119;
                  if (a5)
                  {
                    if (v10 <= a5)
                    {
                      v120 = -2;
                      if (v164)
                        v120 = -1;
                      v121 = &a4[v120];
                      if (v118 < 0x100)
                      {
                        v123 = 1;
                        v122 = v121;
                      }
                      else
                      {
                        *v121 = BYTE1(v118);
                        v122 = v121 + 1;
                        v123 = 2;
                      }
                      a4 = &v121[v123];
                      *v122 = v118;
                      goto LABEL_372;
                    }
                    if (v164)
                    {
                      --v10;
                    }
                    else if (v118 < 0x100)
                    {
                      ++v10;
                    }
LABEL_463:
                    a6 = v162;
                    goto LABEL_452;
                  }
LABEL_372:
                  v12 = 0;
LABEL_373:
                  ++a2;
LABEL_110:
                  v11 = v16;
                  if (v16 >= a3)
                    goto LABEL_452;
                  goto LABEL_3;
                }
                v109 = v112 + 2;
              }
              else
              {
                v110 = v112 - 2;
              }
              if (v109 > v110)
                goto LABEL_452;
            }
          }
          if (a5)
          {
            v73 = 31143;
LABEL_209:
            *((_WORD *)a4 - 1) = v73;
            goto LABEL_210;
          }
          goto LABEL_210;
        }
        goto LABEL_282;
      }
      if (*(a2 - 1) == 45)
      {
        if (a5)
        {
          if (v10 >= a5)
            goto LABEL_452;
          *(_WORD *)(a4++ - 1) = 26535;
        }
        v12 = 0;
        ++v10;
        goto LABEL_373;
      }
    }
    v160 = a4;
    v161 = a1;
    v92 = __CFPrecomposeCharKorean(a2 - 1);
    v165 = v92;
    if (!v92)
      goto LABEL_463;
    v13 = v92;
    LODWORD(v43) = __CFToKSX1001(&v165, 1, v166, 0);
    LODWORD(v42) = v43 >> 8;
    if ((_DWORD)v43 == 65533)
    {
      a6 = v162;
      a1 = v161;
      a4 = v160;
    }
    else
    {
      a6 = v162;
      a1 = v161;
      a4 = v160;
      if (v42 >= 0xA1
        && (v43 & 0xFF00) != 0xFF00
        && v43 >= 0xA1u
        && v43 != 255)
      {
        if (v164)
          v93 = v10 + 1;
        else
          v93 = v10;
        if (a5)
        {
          if (v93 > a5)
          {
            v158 = v93 - 1;
            v159 = !v164;
            goto LABEL_458;
          }
          v94 = -2;
          if (v164)
            v94 = -1;
          *(_WORD *)&v160[v94] = __rev16(v43);
          a4 = &v160[v94 + 2];
        }
        v12 = 0;
        ++a2;
        v10 = v93;
        goto LABEL_110;
      }
    }
    goto LABEL_282;
  }
  v50 = a2[1];
  if (v50 == 8225)
  {
    if (a2[2] == 8225)
    {
      LOBYTE(v51) = -90;
      LOBYTE(v52) = 69;
      goto LABEL_199;
    }
    goto LABEL_452;
  }
  if (v50 == 8224)
  {
    if (a2[2] == 8224)
    {
      LOBYTE(v51) = -90;
      LOBYTE(v52) = 68;
      goto LABEL_199;
    }
    goto LABEL_452;
  }
  if (v50 > 0x7F)
    goto LABEL_452;
  v58 = a2[2];
  if (v58 > 0x7F)
    goto LABEL_452;
  v59 = (v50 << 8) | (v13 << 16) | v58;
  if (v59 + 127325910 < 0xFFF6F815)
    goto LABEL_452;
  v60 = (unsigned int *)&MacKorean_from_uni_0xF860;
  v61 = (unsigned int *)&unk_182CF4D60;
  while (2)
  {
    v62 = ((char *)v61 - (char *)v60) >> 4;
    v63 = &v60[2 * v62];
    if (*v63 > v59)
    {
      v61 = v63 - 2;
      goto LABEL_156;
    }
    if (*v63 < v59)
    {
      v60 = v63 + 2;
LABEL_156:
      if (v60 > v61)
        goto LABEL_452;
      continue;
    }
    break;
  }
  v52 = LOWORD(v60[2 * v62 + 1]);
  v51 = v52 >> 8;
LABEL_199:
  if (!a5)
  {
LABEL_202:
    v12 = 0;
    a2 += 3;
    v16 = v11 + 3;
    v10 += 2;
    goto LABEL_110;
  }
  if (v10 + 2 <= a5)
  {
    *a4 = v51;
    a4[1] = v52;
    a4 += 2;
    goto LABEL_202;
  }
LABEL_452:
  *a6 = v10;
  return v11;
}

uint64_t __CFFromMacKoreanLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t result;
  unsigned int v4;
  BOOL v5;

  if (a3 < 1)
    return 0;
  result = 0;
  do
  {
    v4 = *a2;
    v5 = v4 >= 0x85 && (unint64_t)a3 >= 2;
    if (!v5 || v4 == 255)
    {
      ++a2;
      --a3;
    }
    else
    {
      a2 += 2;
      a3 -= 2;
      if ((v4 + 95) < 0xDu)
        result += 5;
    }
    ++result;
  }
  while (a3 > 0);
  return result;
}

uint64_t CFStringEncodingByteLengthForCharacters(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4)
{
  int v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  uint64_t (*v12)(uint64_t, unsigned __int16 *, uint64_t);
  uint64_t v13[2];

  v7 = a1;
  v13[1] = *MEMORY[0x1E0C80C00];
  v8 = (uint64_t *)__CFGetConverter(a1);
  if (!v8)
    return 0;
  v9 = *v8;
  v10 = *(unsigned __int8 *)(*v8 + 20);
  if (v10 == 4)
    return __CFStringEncodingPlatformByteLengthForCharacters();
  if (v10 == 5)
    return __CFStringEncodingICUByteLength(v8[1], a2, (unint64_t)a3, a4);
  if (*(_WORD *)(v9 + 16) != 1)
  {
    v12 = *(uint64_t (**)(uint64_t, unsigned __int16 *, uint64_t))(v9 + 24);
    if (v12)
      return v12(a2, a3, a4);
    v13[0] = 0;
    if (CFStringEncodingUnicodeToBytes(v7, a2, a3, a4, 0, 0, 0, v13))
      return 0;
    else
      return v13[0];
  }
  return a4;
}

_OWORD *CFStringEncodingRegisterFallbackProcedures(uint64_t a1, uint64_t (*a2)(unsigned __int16 *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t *a5), uint64_t (*a3)(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, _QWORD *a5))
{
  _OWORD *result;
  _OWORD *v7;
  uint64_t v8;

  result = __CFGetConverter(a1);
  if (result)
  {
    v7 = result;
    result = __CFGetConverter(a1);
    if (result)
    {
      v8 = *(_QWORD *)result;
      if (!a2)
      {
        if (v8)
          a2 = *(uint64_t (**)(unsigned __int16 *, uint64_t, char *, uint64_t, uint64_t *))(v8 + 40);
        else
          a2 = __CFDefaultToBytesFallbackProc;
      }
    }
    else
    {
      v8 = 0;
      if (!a2)
        a2 = __CFDefaultToBytesFallbackProc;
    }
    *((_QWORD *)v7 + 4) = a2;
    if (!a3)
    {
      if (v8)
        a3 = *(uint64_t (**)(uint64_t, uint64_t, _WORD *, uint64_t, _QWORD *))(v8 + 48);
      else
        a3 = __CFDefaultToUnicodeFallbackProc;
    }
    *((_QWORD *)v7 + 5) = a3;
  }
  return result;
}

uint64_t __CFDefaultToBytesFallbackProc(unsigned __int16 *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t *a5)
{
  unint64_t v8;
  char v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  __int16 v22;
  unsigned int v23[10];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v8 = *a1;
  if (v8 <= 0x9F)
  {
    v9 = v8 ^ 0x80;
LABEL_3:
    result = 1;
LABEL_4:
    if (a4)
      *a3 = v9;
    v11 = 1;
    goto LABEL_7;
  }
  if (v8 <= 0xFF)
  {
    if (a4 >= 4 || a4 == 0)
      v13 = 4;
    else
      v13 = a4;
    if (v13 < 1)
    {
      v14 = 0;
    }
    else
    {
      v14 = 0;
      v15 = (char *)&_toLossyASCIITable + 4 * v8 - 640;
      while (v15[v14])
      {
        if (a4)
          a3[v14] = v15[v14];
        if (v13 == ++v14)
        {
          v14 = v13;
          break;
        }
      }
    }
    *a5 = v14;
    return 1;
  }
  if (v8 >> 11 == 27)
  {
    v9 = 63;
    result = 1;
    if (a2 >= 2 && v8 <= 0xDC00)
    {
      v17 = a1[1];
      v18 = v17 >> 10;
      v19 = v17 >= 0xE000;
      v20 = 1;
      if (!v19)
        v20 = 2;
      if (v18 >= 0x37)
        result = v20;
      else
        result = 1;
      v9 = 63;
    }
    goto LABEL_4;
  }
  if ((CFUniCharIsMemberOf(*a1, 2u) & 1) != 0)
  {
    v9 = 32;
    goto LABEL_3;
  }
  if ((CFUniCharIsMemberOf(*a1, 3u) & 1) != 0)
  {
    v9 = 10;
    goto LABEL_3;
  }
  v21 = *a1;
  if (v21 == 8230)
  {
    if (!a4)
    {
      result = 1;
      v11 = 3;
LABEL_7:
      *a5 = v11;
      return result;
    }
    if (a4 >= 3)
    {
      a3[2] = 46;
      *(_WORD *)a3 = 11822;
      *a5 = 3;
      return 1;
    }
LABEL_45:
    v9 = 63;
    goto LABEL_3;
  }
  if (!CFUniCharIsMemberOf(v21, 9u))
    goto LABEL_45;
  CFUniCharDecomposeCharacter(*a1, v23, 10);
  v9 = v23[0];
  if (v23[0] <= 0x7F)
    goto LABEL_3;
  v22 = v23[0];
  return __CFDefaultToBytesFallbackProc(&v22, 1, a3, a4, a5);
}

uint64_t __CFDefaultToUnicodeFallbackProc(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, _QWORD *a5)
{
  if (a4)
    *a3 = 63;
  *a5 = 1;
  return 1;
}

uint64_t CFStringEncodingListOfAvailableEncodings()
{
  uint64_t result;
  unint64_t ICUEncodings;
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t Typed;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  int *v10;
  int v11;
  int *v12;
  int *v13;
  int v14;
  char v16;
  uint64_t v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  result = CFStringEncodingListOfAvailableEncodings_encodings;
  if (!CFStringEncodingListOfAvailableEncodings_encodings)
  {
    v18 = 0;
    v19[0] = 0;
    ICUEncodings = (unint64_t)__CFStringEncodingCreateICUEncodings(0, v19);
    v2 = __CFStringEncodingCreateListOfAvailablePlatformConverters(0, &v18);
    if (ICUEncodings | v2)
    {
      v3 = (void *)v2;
      v4 = v19[0] + v18 + 14;
      Typed = CFAllocatorAllocateTyped(0, 4 * v4, 0x100004052888210, 0);
      v9 = (__int128 *)Typed;
      *(_QWORD *)(Typed + 48) = -3825204992;
      *(_OWORD *)Typed = __CFBuiltinEncodings;
      *(_OWORD *)(Typed + 16) = unk_182CF7CEC;
      *(_OWORD *)(Typed + 32) = xmmword_182CF7CFC;
      if (ICUEncodings)
      {
        memcpy((void *)(Typed + 56), (const void *)ICUEncodings, 4 * v19[0]);
        CFAllocatorDeallocate(0, (void *)ICUEncodings);
      }
      if (v3)
      {
        memcpy((char *)v9 + 4 * v19[0] + 56, v3, 4 * v18);
        CFAllocatorDeallocate(0, v3);
      }
      CFQSortArray(v9, v4, 4, (uint64_t)__CFStringEncodingComparator, 0, v6, v7, v8);
      if (v4 >= 1)
      {
        v10 = (int *)v9 + v4;
        v11 = -1;
        v12 = (int *)v9;
        do
        {
          v13 = v12 + 1;
          v14 = *v12;
          if (v11 == *v12)
          {
            if (v13 < v10)
              memmove(v12, v13, (char *)v10 - (char *)v12 - 4);
            --v10;
          }
          else
          {
            ++v12;
            v11 = v14;
          }
        }
        while (v12 < v10);
      }
      while (!__ldaxr((unint64_t *)&CFStringEncodingListOfAvailableEncodings_encodings))
      {
        if (!__stlxr((unint64_t)v9, (unint64_t *)&CFStringEncodingListOfAvailableEncodings_encodings))
        {
          v16 = 1;
          goto LABEL_22;
        }
      }
      v16 = 0;
      __clrex();
LABEL_22:
      if (v9 != &__CFBuiltinEncodings && (v16 & 1) == 0)
        CFAllocatorDeallocate(0, v9);
    }
    else
    {
      while (!__ldaxr((unint64_t *)&CFStringEncodingListOfAvailableEncodings_encodings))
      {
        if (!__stlxr((unint64_t)&__CFBuiltinEncodings, (unint64_t *)&CFStringEncodingListOfAvailableEncodings_encodings))return CFStringEncodingListOfAvailableEncodings_encodings;
      }
      __clrex();
    }
    return CFStringEncodingListOfAvailableEncodings_encodings;
  }
  return result;
}

uint64_t __CFStringEncodingComparator(_DWORD *a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = (unsigned __int16)*a1;
  v3 = *a2;
  v4 = *a1 - v3;
  v5 = v2 - (unsigned __int16)v3;
  if ((_DWORD)v2 == (unsigned __int16)*a2)
    return v4;
  else
    return v5;
}

uint64_t __CFToUnicodeCheapEightBitWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v9;
  uint64_t v15;
  __int16 v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a6 >= a4 || a6 == 0)
    v9 = a4;
  else
    v9 = a6;
  if (v9 < 1)
  {
    v15 = 0;
  }
  else
  {
    v15 = 0;
    v17 = 0;
    while ((*(unsigned int (**)(uint64_t, _QWORD, __int16 *))(*(_QWORD *)a1 + 8))(a2, *(unsigned __int8 *)(a3 + v15), &v17))
    {
      if (a6)
        *(_WORD *)(a5 + 2 * v15) = v17;
      if (v9 == ++v15)
      {
        v15 = v9;
        break;
      }
    }
  }
  *a7 = v15;
  return v15;
}

uint64_t __CFToCanonicalUnicodeCheapEightBitWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned __int16 v21;
  unsigned int v22[10];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a4 < 1)
  {
    v15 = 0;
    v14 = 0;
  }
  else
  {
    v14 = 0;
    v15 = 0;
    v21 = 0;
    while ((!a6 || v14 < a6)
         && (*(unsigned int (**)(uint64_t, _QWORD, unsigned __int16 *))(*(_QWORD *)a1 + 8))(a2, *(unsigned __int8 *)(a3 + v15), &v21))
    {
      if (v21 >= 0x80u && CFUniCharIsMemberOf(v21, 0x65u))
      {
        v16 = CFUniCharDecomposeCharacter(v21, v22, 10);
        *a7 = v14;
        if (v16 >= 1)
        {
          v17 = v22;
          do
          {
            v18 = *v17;
            v19 = *v17 - 0x10000;
            if (*v17 < 0x10000)
            {
              if (v14 >= a6)
                return v15;
              ++v14;
              *a5++ = v18;
            }
            else
            {
              v14 += 2;
              if (v14 > a6)
                return v15;
              if (a6)
              {
                *v17 = v19;
                *a5 = (v19 >> 10) - 10240;
                a5[1] = v18 & 0x3FF | 0xDC00;
                a5 += 2;
              }
            }
            ++v17;
            --v16;
          }
          while (v16);
        }
      }
      else
      {
        if (a6)
          *a5++ = v21;
        ++v14;
      }
      if (++v15 == a4)
      {
        v15 = a4;
        break;
      }
    }
  }
  *a7 = v14;
  return v15;
}

uint64_t __CFToBytesStandardEightBitWrapper(uint64_t (***a1)(uint64_t, uint64_t, uint64_t, char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v10;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  *a7 = 0;
  if (!a4)
    return 0;
  v10 = a4;
  v14 = 0;
  v15 = 0;
  do
  {
    if (a6 && v14 >= a6)
      break;
    v16 = (**a1)(a2, a3, v10, &v18);
    if (!v16)
      break;
    if (a6)
      *(_BYTE *)(a5 + *a7) = v18;
    v14 = *a7 + 1;
    *a7 = v14;
    a3 += 2 * v16;
    v15 += v16;
    v10 -= v16;
  }
  while (v10);
  return v15;
}

uint64_t __CFToUnicodeStandardEightBitWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  _QWORD v18[6];

  v18[5] = *MEMORY[0x1E0C80C00];
  *a7 = 0;
  if (a4 < 1)
    return 0;
  v14 = 0;
  v15 = 0;
  while (!a6 || v14 < a6)
  {
    v16 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)a1 + 8))(a2, *(unsigned __int8 *)(a3 + v15), v18);
    if (!v16)
      break;
    v14 = *a7 + v16;
    if (a6)
    {
      if (v14 > a6)
        return v15;
      memcpy((void *)(a5 + 2 * *a7), v18, 2 * v16);
    }
    *a7 = v14;
    if (a4 == ++v15)
      return a4;
  }
  return v15;
}

uint64_t __CFToCanonicalUnicodeStandardEightBitWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _WORD *a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v23;
  _WORD v26[20];
  unsigned int v27[10];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a4 < 1)
  {
    v13 = 0;
    v12 = 0;
  }
  else
  {
    v10 = a3;
    v11 = a2;
    v12 = 0;
    v13 = 0;
    v23 = a2;
    while (!a6 || v12 < a6)
    {
      v14 = a1;
      v15 = (*(uint64_t (**)(uint64_t, _QWORD, _WORD *))(*(_QWORD *)a1 + 8))(v11, *(unsigned __int8 *)(v10 + v13), v26);
      if (!v15)
        break;
      v16 = 0;
      v17 = v15;
      do
      {
        v18 = (unsigned __int16)v26[v16];
        if (v18 >= 0x80 && CFUniCharIsMemberOf(v18, 0x65u))
        {
          v19 = CFUniCharDecomposeCharacter((unsigned __int16)v26[v16], v27, 10);
          *a7 = v12;
          if (v19 >= 1)
          {
            v20 = v27;
            do
            {
              v21 = *v20++;
              if (v21 < 0x10000)
              {
                if (v12 >= a6)
                  return v13;
                ++v12;
                *a5++ = v26[v16];
              }
              else
              {
                v12 += 2;
                if (v12 > a6)
                  return v13;
                if (a6)
                {
                  *a5 = (v26[v16] >> 10) | 0xD800;
                  a5[1] = v26[v16] & 0x3FF | 0xDC00;
                  a5 += 2;
                }
              }
              --v19;
            }
            while (v19);
          }
        }
        else
        {
          if (a6)
            *a5++ = v26[v16];
          ++v12;
        }
        ++v16;
      }
      while (v16 != v17);
      ++v13;
      v10 = a3;
      v11 = v23;
      a1 = v14;
      if (v13 == a4)
      {
        v13 = a4;
        break;
      }
    }
  }
  *a7 = v12;
  return v13;
}

uint64_t __CFToBytesCheapMultiByteWrapper(uint64_t (***a1)(uint64_t, _QWORD, _BYTE *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int64_t a6, int64_t *a7)
{
  int64_t v14;
  uint64_t v15;
  unsigned int v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  _BYTE v22[20];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  *a7 = 0;
  if (a4 < 1)
    return 0;
  v14 = 0;
  v15 = 0;
  while (!a6 || v14 < a6)
  {
    v16 = (**a1)(a2, *(unsigned __int16 *)(a3 + 2 * v15), v22);
    if (!v16)
      break;
    if (a6)
    {
      if (*a7 + v16 > a6)
        return v15;
      v17 = v22;
      v18 = a5;
      v19 = v16;
      do
      {
        v20 = *v17++;
        *(_BYTE *)(v18 + *a7) = v20;
        ++v18;
        --v19;
      }
      while (v19);
    }
    v14 = *a7 + v16;
    *a7 = v14;
    if (++v15 == a4)
      return a4;
  }
  return v15;
}

uint64_t __CFToUnicodeCheapMultiByteWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _WORD *a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v10;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  __int16 v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  *a7 = 0;
  if (!a4)
    return 0;
  v10 = a4;
  v14 = 0;
  v15 = 0;
  do
  {
    if (a6 && v14 >= a6)
      break;
    v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __int16 *))(*(_QWORD *)a1 + 8))(a2, a3, v10, &v18);
    if (!v16)
      break;
    if (a6)
      *a5++ = v18;
    v14 = *a7 + 1;
    *a7 = v14;
    v15 += v16;
    a3 += v16;
    v10 -= v16;
  }
  while (v10);
  return v15;
}

uint64_t __CFToCanonicalUnicodeCheapMultiByteWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, _QWORD *a7)
{
  uint64_t v10;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned __int16 v23;
  unsigned int v24[10];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v10 = a4;
    v14 = 0;
    v15 = 0;
    v23 = 0;
    do
    {
      if (a6 && v14 >= a6)
        break;
      v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned __int16 *))(*(_QWORD *)a1 + 8))(a2, a3, v10, &v23);
      if (!v16)
        break;
      v17 = v16;
      if (v23 >= 0x80u && CFUniCharIsMemberOf(v23, 0x65u))
      {
        v18 = CFUniCharDecomposeCharacter(v23, v24, 10);
        *a7 = v14;
        if (v18 >= 1)
        {
          v19 = v24;
          do
          {
            v20 = *v19;
            v21 = *v19 - 0x10000;
            if (*v19 < 0x10000)
            {
              if (v14 >= a6)
                return v15;
              ++v14;
              *a5++ = v20;
            }
            else
            {
              v14 += 2;
              if (v14 > a6)
                return v15;
              if (a6)
              {
                *v19 = v21;
                *a5 = (v21 >> 10) - 10240;
                a5[1] = v20 & 0x3FF | 0xDC00;
                a5 += 2;
              }
            }
            ++v19;
            --v18;
          }
          while (v18);
        }
      }
      else
      {
        if (a6)
          *a5++ = v23;
        ++v14;
      }
      v15 += v17;
      a3 += v17;
      v10 -= v17;
    }
    while (v10);
  }
  else
  {
    v15 = 0;
    v14 = 0;
  }
  *a7 = v14;
  return v15;
}

uint64_t _CFStringEncodingSetForceASCIICompatibility(uint64_t result)
{
  __CFWantsToUseASCIICompatibleConversion = (_DWORD)result != 0;
  return result;
}

uint64_t __CFStringDecodeByteStream2(char *a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5, _BYTE *a6)
{
  return __CFStringDecodeByteStream3(a1, a2, a3, a4, a5, a6, 0);
}

uint64_t _CFStringGetInstallationEncodingAndRegion(_DWORD *a1, _DWORD *a2)
{
  uint64_t result;
  int v5;
  int v6;
  const char *v7;
  ssize_t v8;
  char *v9;
  char v10[1025];
  _BYTE v11[64];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  *a1 = 0;
  *a2 = 0;
  result = (uint64_t)getpwuid(0);
  if (result)
  {
    __strlcpy_chk();
    __strlcat_chk();
    if (__CFProphylacticAutofsAccess)
      v5 = open("/dev/autofs_nowait", 0);
    else
      v5 = -1;
    result = open(v10, 0, 0);
    if ((result & 0x80000000) != 0)
    {
      v7 = 0;
    }
    else
    {
      v6 = result;
      v7 = v11;
      v8 = read(result, v11, 0x3FuLL);
      v11[v8 & ~(v8 >> 63)] = 0;
      result = close(v6);
      v9 = v11;
    }
    if (v5 != -1)
      result = close(v5);
    if (v7)
    {
      result = strtol_l(v7, &v9, 0, 0);
      *a1 = result;
      if (result <= 9 && ((1 << result) & 0x230) != 0)
        *a1 = 0;
      if (*v9 == 58)
      {
        result = strtol_l(++v9, 0, 0, 0);
        *a2 = result;
      }
    }
  }
  return result;
}

BOOL _CFStringSaveUserDefaultEncoding(int a1, int a2)
{
  uid_t v4;
  int v5;
  _BOOL8 v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  char __str[64];
  char v15[1025];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v4 = getuid();
  if (!getpwuid(v4))
    return 0;
  if (!issetugid())
    __CFgetenv("CFFIXED_USER_HOME");
  __strlcpy_chk();
  __strlcat_chk();
  if (__CFProphylacticAutofsAccess)
    v5 = open("/dev/autofs_nowait", 0);
  else
    v5 = -1;
  unlink(v15);
  v7 = open(v15, 513, 256);
  if (v7 < 0)
  {
    v6 = 0;
  }
  else
  {
    v8 = v7;
    if ((a1 & 0xFFFFFFFE) == 4)
      v9 = 0;
    else
      v9 = a1;
    v10 = snprintf(__str, 0x40uLL, "0x%X:0x%X", v9, a2);
    v6 = 0;
    if (v10 <= 0x40)
      v6 = v10 <= (unint64_t)(int)write(v8, __str, v10);
    v11 = *__error();
    close(v8);
    *__error() = v11;
  }
  v12 = *__error();
  if (v5 != -1)
    close(v5);
  *__error() = v12;
  return v6;
}

uint64_t __CFStringScanHex(UniChar *buffer, int *a2, unsigned int *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  UniChar v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  UniChar v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  UniChar v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  CFRange v41;
  CFRange v42;
  CFRange v43;
  CFRange v44;

  v6 = *a2;
  if (*a2 < 0)
    goto LABEL_5;
LABEL_2:
  v7 = v6;
  v8 = *((_QWORD *)buffer + 20);
  if (v8 > v7)
  {
    v9 = *((_QWORD *)buffer + 17);
    if (v9)
    {
      v10 = *(_WORD *)(v9 + 2 * (*((_QWORD *)buffer + 19) + v7));
    }
    else
    {
      v11 = *((_QWORD *)buffer + 18);
      if (v11)
      {
        v10 = *(char *)(v11 + *((_QWORD *)buffer + 19) + v7);
      }
      else
      {
        if (*((_QWORD *)buffer + 22) <= v7 || (v12 = *((_QWORD *)buffer + 21), v12 > v7))
        {
          v13 = v7 - 4;
          if (v7 < 4)
            v13 = 0;
          if (v13 + 64 < v8)
            v8 = v13 + 64;
          *((_QWORD *)buffer + 21) = v13;
          *((_QWORD *)buffer + 22) = v8;
          v41.location = *((_QWORD *)buffer + 19) + v13;
          v41.length = v8 - v13;
          CFStringGetCharacters(*((CFStringRef *)buffer + 16), v41, buffer);
          v12 = *((_QWORD *)buffer + 21);
        }
        v10 = buffer[v7 - v12];
      }
    }
    goto LABEL_6;
  }
LABEL_5:
  while (1)
  {
    v10 = -1;
LABEL_6:
    if (v10 != 12288
      && (unsigned __int16)(v10 - 0x2000) >= 0xCu
      && v10 >= 0x21u
      && (unsigned __int16)(v10 - 127) > 0x21u)
    {
      break;
    }
    v6 = *a2 + 1;
    *a2 = v6;
    if ((v6 & 0x80000000) == 0)
      goto LABEL_2;
  }
  v14 = v10 - 48;
  if (v10 != 48)
  {
    if ((unsigned __int16)(v10 - 48) > 9u)
    {
      if ((unsigned __int16)(v10 - 65) > 5u)
      {
        if ((unsigned __int16)(v10 - 97) > 5u)
          return 0;
        v14 = v10 - 87;
      }
      else
      {
        v14 = v10 - 55;
      }
    }
    if (v14 != -1)
      goto LABEL_33;
    return 0;
  }
  v15 = *a2;
  v16 = v15 + 1;
  *a2 = v15 + 1;
  if ((int)v15 >= -1)
  {
    v17 = *((_QWORD *)buffer + 20);
    if (v17 > v16)
    {
      v18 = *((_QWORD *)buffer + 17);
      if (v18)
      {
        v19 = *(_WORD *)(v18 + 2 * (*((_QWORD *)buffer + 19) + v16));
      }
      else
      {
        v31 = *((_QWORD *)buffer + 18);
        if (v31)
        {
          v19 = *(char *)(v31 + *((_QWORD *)buffer + 19) + v16);
        }
        else
        {
          if (*((_QWORD *)buffer + 22) <= v16 || (v32 = *((_QWORD *)buffer + 21), v32 > v16))
          {
            v33 = v16 - 4;
            if (v16 < 4)
              v33 = 0;
            if (v33 + 64 < v17)
              v17 = v33 + 64;
            *((_QWORD *)buffer + 21) = v33;
            *((_QWORD *)buffer + 22) = v17;
            v43.location = *((_QWORD *)buffer + 19) + v33;
            v43.length = v17 - v33;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v43, buffer);
            v32 = *((_QWORD *)buffer + 21);
          }
          v19 = buffer[v16 - v32];
        }
      }
      if ((v19 & 0xFFDF) == 0x58)
      {
        v34 = *a2;
        v35 = v34 + 1;
        *a2 = v34 + 1;
        if ((int)v34 < -1)
          goto LABEL_93;
        v36 = *((_QWORD *)buffer + 20);
        if (v36 <= v35)
          goto LABEL_93;
        v37 = *((_QWORD *)buffer + 17);
        if (v37)
        {
          v19 = *(_WORD *)(v37 + 2 * (*((_QWORD *)buffer + 19) + v35));
        }
        else
        {
          v38 = *((_QWORD *)buffer + 18);
          if (v38)
          {
            v19 = *(char *)(v38 + *((_QWORD *)buffer + 19) + v35);
          }
          else
          {
            if (*((_QWORD *)buffer + 22) <= v35 || (v39 = *((_QWORD *)buffer + 21), v39 > v35))
            {
              v40 = v35 - 4;
              if (v35 < 4)
                v40 = 0;
              if (v40 + 64 < v36)
                v36 = v40 + 64;
              *((_QWORD *)buffer + 21) = v40;
              *((_QWORD *)buffer + 22) = v36;
              v44.location = *((_QWORD *)buffer + 19) + v40;
              v44.length = v36 - v40;
              CFStringGetCharacters(*((CFStringRef *)buffer + 16), v44, buffer);
              v39 = *((_QWORD *)buffer + 21);
            }
            v19 = buffer[v35 - v39];
          }
        }
      }
      if ((unsigned __int16)(v19 - 48) > 9u)
      {
        if (v19 - 65 > 5)
        {
          if (v19 - 97 > 5)
            goto LABEL_93;
          v14 = v19 - 87;
        }
        else
        {
          v14 = v19 - 55;
        }
      }
      else
      {
        v14 = v19 - 48;
      }
      if (v14 != -1)
      {
LABEL_33:
        v20 = 0;
        do
        {
          v21 = v14 + 16 * v20;
          if (v20 >> 28)
            v20 = -1;
          else
            v20 = v21;
          v22 = *a2;
          v23 = v22 + 1;
          *a2 = v22 + 1;
          if ((int)v22 < -1)
            break;
          v24 = *((_QWORD *)buffer + 20);
          if (v24 <= v23)
            break;
          v25 = *((_QWORD *)buffer + 17);
          if (v25)
          {
            v26 = *(_WORD *)(v25 + 2 * (*((_QWORD *)buffer + 19) + v23));
          }
          else
          {
            v27 = *((_QWORD *)buffer + 18);
            if (v27)
            {
              v26 = *(char *)(v27 + *((_QWORD *)buffer + 19) + v23);
            }
            else
            {
              if (*((_QWORD *)buffer + 22) <= v23 || (v28 = *((_QWORD *)buffer + 21), v28 > v23))
              {
                v29 = v23 - 4;
                if (v23 < 4)
                  v29 = 0;
                if (v29 + 64 < v24)
                  v24 = v29 + 64;
                *((_QWORD *)buffer + 21) = v29;
                *((_QWORD *)buffer + 22) = v24;
                v42.location = *((_QWORD *)buffer + 19) + v29;
                v42.length = v24 - v29;
                CFStringGetCharacters(*((CFStringRef *)buffer + 16), v42, buffer);
                v28 = *((_QWORD *)buffer + 21);
              }
              v26 = buffer[v23 - v28];
            }
          }
          if ((unsigned __int16)(v26 - 48) > 9u)
          {
            if (v26 - 65 > 5)
            {
              if (v26 - 97 > 5)
                break;
              v14 = v26 - 87;
            }
            else
            {
              v14 = v26 - 55;
            }
          }
          else
          {
            v14 = v26 - 48;
          }
        }
        while (v14 != -1);
        if (!a3)
          return 1;
        goto LABEL_95;
      }
    }
  }
LABEL_93:
  --*a2;
  if (a3)
  {
    v20 = 0;
LABEL_95:
    *a3 = v20;
  }
  return 1;
}

CFTypeID CFStringTokenizerGetTypeID(void)
{
  return 40;
}

CFStringRef CFStringTokenizerCopyBestStringLanguage(CFStringRef string, CFRange range)
{
  CFIndex length;
  CFIndex location;

  length = range.length;
  location = range.location;
  if (__CFSTLoadCoreNLP_once != -1)
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  if (__CFSTLoadCoreNLP_isCoreNLPAvailable)
    return (CFStringRef)__NLStringTokenizerCopyBestStringLanguage(string, location, length);
  else
    return 0;
}

CFStringTokenizerTokenType CFStringTokenizerGoToTokenAtIndex(CFStringTokenizerRef tokenizer, CFIndex index)
{
  return __NLStringTokenizerGoToTokenAtIndex(*((_QWORD *)tokenizer + 2), index);
}

CFTypeRef CFStringTokenizerCopyCurrentTokenAttribute(CFStringTokenizerRef tokenizer, CFOptionFlags attribute)
{
  return (CFTypeRef)__NLStringTokenizerCopyCurrentTokenAttribute(*((_QWORD *)tokenizer + 2), attribute);
}

CFIndex CFStringTokenizerGetCurrentSubTokens(CFStringTokenizerRef tokenizer, CFRange *ranges, CFIndex maxRangeLength, CFMutableArrayRef derivedSubTokens)
{
  return __NLStringTokenizerGetCurrentSubTokens(*((_QWORD *)tokenizer + 2), ranges, maxRangeLength, derivedSubTokens);
}

uint64_t CFStringTokenizerCopyBestStringLanguageWithHints(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (__CFSTLoadCoreNLP_once != -1)
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  if (__CFSTLoadCoreNLP_isCoreNLPAvailable)
    return __NLStringTokenizerCopyBestStringLanguageWithHints(a1, a2, a3, a4);
  else
    return 0;
}

uint64_t _CFStringTokenizerCopyPossibleStringLanguages(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (__CFSTLoadCoreNLP_once != -1)
    dispatch_once(&__CFSTLoadCoreNLP_once, &__block_literal_global_20);
  if (__CFSTLoadCoreNLP_isCoreNLPAvailable)
    return ___NLStringTokenizerCopyPossibleStringLanguages(a1, a2, a3);
  else
    return 0;
}

uint64_t _CFStringTokenizerTokenize(uint64_t a1)
{
  return ___NLStringTokenizerTokenize(*(_QWORD *)(a1 + 16));
}

uint64_t _CFStringTokenizerTokenizeWithTranscriptions(uint64_t a1)
{
  return ___NLStringTokenizerTokenizeWithTranscriptions(*(_QWORD *)(a1 + 16));
}

uint64_t _CFStringTokenizerTokenizeCompoundWord(uint64_t a1)
{
  return ___NLStringTokenizerTokenizeCompoundWord(*(_QWORD *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetDerivedTokens(uint64_t a1)
{
  return ___NLStringTokenizerGetDerivedTokens(*(_QWORD *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetNextBestTokens(uint64_t a1)
{
  return ___NLStringTokenizerGetNextBestTokens(*(_QWORD *)(a1 + 16));
}

uint64_t _CFStringTokenizerCreateNamePartsArrayWithString(uint64_t a1)
{
  return ___NLStringTokenizerCreateNamePartsArrayWithString(*(_QWORD *)(a1 + 16));
}

uint64_t _CFStringTokenizerCreateNamePartsArrayWithStringAsCompositeName(uint64_t a1)
{
  return ___NLStringTokenizerCreateNamePartsArrayWithStringAsCompositeName(*(_QWORD *)(a1 + 16));
}

uint64_t _CFStringTokenizerCreatePossibleNamePartsArrayWithStringAsCompositeName(uint64_t a1)
{
  return ___NLStringTokenizerCreatePossibleNamePartsArrayWithStringAsCompositeName(*(_QWORD *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetCurrentTokenPartOfSpeech(uint64_t a1)
{
  return ___NLStringTokenizerGetCurrentTokenPartOfSpeech(*(_QWORD *)(a1 + 16));
}

uint64_t _CFStringTokenizerSetLocale(uint64_t a1)
{
  return ___NLStringTokenizerSetLocale(*(_QWORD *)(a1 + 16));
}

uint64_t _CFStringTokenizerSetTokenizerAttribute(uint64_t a1)
{
  return ___NLStringTokenizerSetTokenizerAttribute(*(_QWORD *)(a1 + 16));
}

uint64_t _CFStringTokenizerGetTokenizerAttribute(uint64_t a1)
{
  return ___NLStringTokenizerGetTokenizerAttribute(*(_QWORD *)(a1 + 16));
}

uint64_t CFStringTokenizerSetStringWithOptions(uint64_t a1)
{
  return __NLStringTokenizerSetStringWithOptions(*(_QWORD *)(a1 + 16));
}

uint64_t (**__CFStringEncodingGetSymbolConverterDefinition(int a1))()
{
  uint64_t (**v1)();

  v1 = __CFConverterMacSymbol;
  if (a1 != 33)
    v1 = 0;
  if (a1 == 34)
    return __CFConverterMacDingbats;
  else
    return v1;
}

uint64_t __CFToMacDingbats(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4)
{
  unsigned int v4;
  const __int16 *v6;
  const __int16 *v7;
  uint64_t v8;
  const __int16 *v9;
  unsigned int v10;

  v4 = *a2;
  if (v4 > 0x1F)
  {
    if (v4 <= 0x3015)
    {
      v6 = MacDingbats_from_uni;
      v7 = (const __int16 *)&unk_182CF8600;
      do
      {
        v8 = ((char *)v7 - (char *)v6) >> 3;
        v9 = &v6[2 * v8];
        v10 = *(unsigned __int16 *)v9;
        if (v10 <= v4)
        {
          if (v10 >= v4)
          {
            LOBYTE(v4) = v6[2 * v8 + 1];
            goto LABEL_2;
          }
          v6 = v9 + 2;
        }
        else
        {
          v7 = v9 - 2;
        }
      }
      while (v6 <= v7);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a4 = v4;
    return 1;
  }
}

BOOL __CFFromMacDingbats(uint64_t a1, unsigned int a2, _WORD *a3)
{
  unsigned int v3;
  unsigned __int16 *v4;

  if (a2 > 0x1F)
  {
    if (a2 > 0x8F)
    {
      v3 = a2 - 160;
      if (a2 < 0xA0)
        return 0;
      v4 = (unsigned __int16 *)&MacDingbats_to_uni_FF;
    }
    else
    {
      v3 = a2 - 32;
      v4 = (unsigned __int16 *)&MacDingbats_to_uni_8F;
    }
    a2 = v4[v3];
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacDingbatsLen(uint64_t a1, __int16 *a2, uint64_t a3)
{
  uint64_t result;
  __int16 v4;

  for (result = 0; a3; --a3)
  {
    v4 = *a2++;
    if ((v4 & 0xFFF0) != 0xF870)
      ++result;
  }
  return result;
}

uint64_t __CFFromMacDingbatsLen(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v4;
  char v5;
  char v6;
  uint64_t v7;

  if (a3 < 1)
    return 0;
  result = 0;
  v4 = a3 + 1;
  do
  {
    v5 = *a2++;
    v6 = v5 + 126;
    if ((v5 + 126) > 7u)
      v7 = 1;
    else
      v7 = qword_182CF8BE0[v6];
    result += v7;
    --v4;
  }
  while (v4 > 1);
  return result;
}

uint64_t __CFToMacSymbol(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4)
{
  unsigned int v4;
  int v6;
  char v7;
  const __int16 *v8;
  const __int16 *v9;
  uint64_t v10;
  const __int16 *v11;
  unsigned int v12;

  v4 = *a2;
  if (v4 <= 0x1F)
  {
LABEL_2:
    *a4 = v4;
    return 1;
  }
  if (a3 < 2 || (v6 = a2[1], (v6 & 0xFFF0) != 0xF870))
  {
LABEL_10:
    if (v4 >> 8 > 0xF8)
      return 0;
    goto LABEL_11;
  }
  if (v4 == 169)
  {
    if (v6 == 63615)
    {
      v7 = -29;
      goto LABEL_23;
    }
LABEL_11:
    v8 = MacSymbol_from_uni;
    v9 = (const __int16 *)&unk_182CF8A90;
    while (1)
    {
      v10 = ((char *)v9 - (char *)v8) >> 3;
      v11 = &v8[2 * v10];
      v12 = *(unsigned __int16 *)v11;
      if (v12 <= v4)
      {
        if (v12 >= v4)
        {
          LOBYTE(v4) = v8[2 * v10 + 1];
          goto LABEL_2;
        }
        v8 = v11 + 2;
      }
      else
      {
        v9 = v11 - 2;
      }
      if (v8 > v9)
        return 0;
    }
  }
  if (v4 == 8482)
  {
    if (v6 == 63615)
    {
      v7 = -28;
      goto LABEL_23;
    }
    goto LABEL_11;
  }
  if (v4 != 174)
    goto LABEL_10;
  if (v6 != 63615)
    goto LABEL_11;
  v7 = -30;
LABEL_23:
  *a4 = v7;
  return 2;
}

uint64_t __CFFromMacSymbol(__int16 a1, unsigned int a2, __int16 *a3)
{
  __int16 v3;
  unsigned int v4;
  _WORD *v5;
  unsigned __int16 v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  if (a2 <= 0x3F)
  {
    switch(a2)
    {
      case '"':
        v3 = 8704;
        goto LABEL_15;
      case '$':
        v3 = 8707;
        goto LABEL_15;
      case '\'':
        v3 = 8717;
        goto LABEL_15;
      case '*':
        v3 = 8727;
        goto LABEL_15;
      case '-':
        v3 = 8722;
        goto LABEL_15;
      default:
        *a3 = a2;
        break;
    }
    return 1;
  }
  if (a2 <= 0x7E)
  {
    v4 = a2 - 64;
    v5 = &MacSymbol_to_uni_to7E;
    goto LABEL_9;
  }
  v4 = a2 - 160;
  if (a2 < 0xA0)
    return 0;
  if (a2 <= 0xDF)
  {
    v5 = &MacSymbol_to_uni_toDF;
LABEL_9:
    v3 = v5[v4];
LABEL_15:
    *a3 = v3;
    return 1;
  }
  v8 = a2 - 224;
  v9 = MacSymbol_to_uni_toFF[v8];
  *a3 = v9;
  if (a2 == 255)
    return 0;
  v10 = v8 - 2;
  v6 = 1;
  if (v10 <= 2)
  {
    *(_DWORD *)a3 = __CFMacSymbolTwoCharDecompSeqTable[v9];
    if ((a1 & 0x200) != 0)
      return 1;
    else
      return 2;
  }
  return v6;
}

uint64_t __CFToMacSymbolLen(uint64_t a1, __int16 *a2, uint64_t a3)
{
  uint64_t result;
  __int16 v4;

  for (result = 0; a3; --a3)
  {
    v4 = *a2++;
    if ((v4 & 0xFFF0) != 0xF870)
      ++result;
  }
  return result;
}

uint64_t __CFFromMacSymbolLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v4;
  unsigned int v5;
  uint64_t v6;

  if (a3 < 1)
    return 0;
  result = 0;
  v4 = a3 + 1;
  do
  {
    v5 = *a2++;
    if (v5 < 0xE0)
      v6 = 1;
    else
      v6 = 2;
    result += v6;
    --v4;
  }
  while (v4 > 1);
  return result;
}

uint64_t __CFPrecomposeCharMacSymbol(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, _QWORD *a6)
{
  int v6;
  char v7;

  if (a3 < 2 || a2[1] != 824)
    return 0;
  if (a5)
  {
    v6 = *a2;
    switch(v6)
    {
      case 61:
        v7 = -71;
        goto LABEL_11;
      case 8834:
        v7 = -53;
        goto LABEL_11;
      case 8712:
        v7 = -49;
LABEL_11:
        *a4 = v7;
        break;
    }
  }
  *a6 = 1;
  return 2;
}

BOOL __CFIsValidCombiningCharMacSymbol(int a1)
{
  return a1 == 824;
}

BOOL CFDateComponentsIsLeapMonthSet(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56) != 0x7FFFFFFFFFFFFFFFLL;
}

BOOL CFDateComponentsIsLeapMonth(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 56);
  return v1 != 0x7FFFFFFFFFFFFFFFLL && v1 != 0;
}

__CFString *_CFDateComponentsCopyDescriptionInner(_QWORD *a1)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0);
  CFStringAppend(Mutable, CFSTR("{"));
  if (a1[2])
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Calendar: %@"), a1[2]);
  if (a1[3])
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    TimeZone: %@"), a1[3]);
  if (a1[4] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Era: %ld"), a1[4]);
  if (a1[5] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Calendar Year: %ld"), a1[5]);
  if (a1[20] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Day of Year: %ld"), a1[20]);
  if (a1[6] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Month: %ld"), a1[6]);
  if (a1[7] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Leap Month: %ld"), a1[7]);
  if (a1[8] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Day: %ld"), a1[8]);
  if (a1[9] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Hour: %ld"), a1[9]);
  if (a1[10] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Minute: %ld"), a1[10]);
  if (a1[11] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Second: %ld"), a1[11]);
  if (a1[19] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Nanosecond: %ld"), a1[19]);
  if (a1[15] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Quarter: %ld"), a1[15]);
  if (a1[18] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Year for Week of Year: %ld"), a1[18]);
  if (a1[17] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Week of Year: %ld"), a1[17]);
  if (a1[16] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Week of Month: %ld"), a1[16]);
  if (a1[12] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Week (obsolete): %ld"), a1[12]);
  if (a1[13] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Weekday: %ld"), a1[13]);
  if (a1[14] != 0x7FFFFFFFFFFFFFFFLL)
    CFStringAppendFormat(Mutable, 0, CFSTR("\n    Weekday Ordinal: %ld"), a1[14]);
  return Mutable;
}

uint64_t __CFDateComponentsHash(_QWORD *a1)
{
  const void *v2;
  CFHashCode v3;
  CFHashCode v4;
  CFHashCode v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!a1)
    __CFDateComponentsHash_cold_1();
  v2 = (const void *)a1[2];
  if (v2)
    v3 = CFHash(v2);
  else
    v3 = 0;
  v4 = a1[3];
  if (v4)
    v4 = CFHash((CFTypeRef)v4);
  v5 = v4 ^ v3;
  v6 = a1[5];
  v7 = a1[6];
  if (v6 == 0x7FFFFFFFFFFFFFFFLL)
    v6 = 0;
  v8 = 2678437 * v7;
  v9 = a1[8];
  v10 = a1[9];
  if (v9 == 0x7FFFFFFFFFFFFFFFLL)
    v9 = 0;
  v12 = a1[10];
  v11 = a1[11];
  if (v11 == 0x7FFFFFFFFFFFFFFFLL)
    v11 = 0;
  v13 = a1[18];
  if (v13 == 0x7FFFFFFFFFFFFFFFLL)
    v13 = 0;
  v14 = v13 + v6;
  v15 = a1[20];
  if (v15 == 0x7FFFFFFFFFFFFFFFLL)
    v15 = 0;
  if (v7 == 0x7FFFFFFFFFFFFFFFLL)
    v8 = 0;
  v16 = v15 + v9;
  if (v10 == 0x7FFFFFFFFFFFFFFFLL)
    v17 = 0;
  else
    v17 = 3607 * v10;
  if (v12 == 0x7FFFFFFFFFFFFFFFLL)
    v18 = 0;
  else
    v18 = 61 * v12;
  return v8
       + v5
       + v17
       + v18
       + v11
       + 32832013 * v14
       + 86413 * v16
       + 32 * (41 * a1[17] + 11 * a1[16] - a1[13] + 8 * a1[13] + 3 * a1[14] + a1[15]);
}

CFStringRef __CFDateComponentsCopyDescription(_QWORD *a1)
{
  __CFString *v2;
  CFAllocatorRef v3;
  CFStringRef v4;

  if (!a1)
    __CFDateComponentsCopyDescription_cold_1();
  v2 = _CFDateComponentsCopyDescriptionInner(a1);
  v3 = CFGetAllocator(a1);
  v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFDateComponents %p [%p]>%@"), a1, v3, v2);
  CFRelease(v2);
  return v4;
}

uint64_t CFDateComponentsGetTypeID()
{
  return 66;
}

BOOL CFDateComponentsIsValidDate(_QWORD *a1)
{
  void *v1;

  v1 = (void *)a1[2];
  return v1 && CFDateComponentsIsValidDateInCalendar(a1, v1);
}

uint64_t CFDateComponentsDateMatchesComponents()
{
  return 0;
}

Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse)
{
  int v4;
  CFStringRef v8;
  uint64_t v9;
  uint64_t v10;
  const NSStringTransform *v11;
  __CFString **v12;
  __CFString *v13;
  CFTypeRef *p_isa;
  __CFString **v15;
  __CFString *v16;
  uint64_t Length;
  UniChar *Typed;
  UniChar *v19;
  const char *v20;
  int64_t v21;
  UniChar *v22;
  int64_t v23;
  UniChar v24;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  Boolean v27;
  int v29;
  uint64_t v30;
  CFIndex v31;
  UniChar buffer[4];
  CFIndex v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  CFMutableStringRef v42;
  const UniChar *v43;
  const char *v44;
  uint64_t v45;
  CFIndex v46;
  uint64_t v47;
  uint64_t v48;
  CFTypeRef cf;
  uint64_t v50;
  CFRange v51;
  CFRange v52;

  v4 = reverse;
  v50 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  if (__CFStringTransformCacheID && __CFStringTransformCacheRev == (v4 != 0))
  {
    v8 = transform;
    if ((CFStringRef)__CFStringTransformCacheID == transform)
    {
LABEL_6:
      CFRelease(v8);
      __CFStringTransformCacheID = 0;
      v9 = __CFStringTransformCacheTL;
      __CFStringTransformCacheTL = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
      goto LABEL_30;
    }
    if (CFEqual(transform, (CFTypeRef)__CFStringTransformCacheID))
    {
      v8 = (CFStringRef)__CFStringTransformCacheID;
      goto LABEL_6;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  LODWORD(v30) = 0;
  if (CFStringGetLength(transform) >= 1 && CFStringGetCharacterAtIndex(transform, 0) == 41)
  {
    v10 = 0;
    v11 = &kCFStringTransformStripCombiningMarks;
    v12 = &off_1E1332DE0;
    while (*(CFStringRef *)v11 != transform)
    {
      ++v10;
      v13 = *v12;
      v12 += 2;
      v11 = (const NSStringTransform *)v13;
      if (v10 == 16)
      {
        v10 = 0;
        p_isa = (CFTypeRef *)&kCFStringTransformStripCombiningMarks;
        v15 = &off_1E1332DE0;
        while (!CFEqual(*p_isa, transform))
        {
          ++v10;
          v16 = *v15;
          v15 += 2;
          p_isa = (CFTypeRef *)&v16->isa;
          if (v10 == 16)
            goto LABEL_17;
        }
        break;
      }
    }
    v20 = (const char *)*(&__CFStringTransformNameMap + 2 * v10 + 1);
    v21 = strlen(v20);
    if (v21 >= 1)
    {
      v22 = buffer;
      v23 = v21;
      do
      {
        v24 = *v20++;
        *v22++ = v24;
        --v23;
      }
      while (v23);
    }
    goto LABEL_25;
  }
LABEL_17:
  Length = CFStringGetLength(transform);
  if (CFStringGetCharactersPtr(transform))
  {
LABEL_25:
    v9 = utrans_openU();
    goto LABEL_26;
  }
  if (Length <= 1024)
  {
    v51.location = 0;
    v51.length = Length;
    CFStringGetCharacters(transform, v51, buffer);
    goto LABEL_25;
  }
  Typed = (UniChar *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 2 * Length, 0x1000040BDFB0063, 0);
  if (!Typed)
  {
LABEL_29:
    v9 = 0;
    goto LABEL_30;
  }
  v19 = Typed;
  v52.location = 0;
  v52.length = Length;
  CFStringGetCharacters(transform, v52, Typed);
  v9 = utrans_openU();
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v19);
LABEL_26:
  if ((int)v30 >= 1 && v9)
  {
    utrans_close();
    goto LABEL_29;
  }
LABEL_30:
  if (!v9)
    return 0;
  v30 = 0;
  v31 = 0;
  if (!range)
  {
    v31 = CFStringGetLength(string);
    range = (CFRange *)&v30;
  }
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  *(_QWORD *)buffer = string;
  v33 = CFStringGetLength(string);
  v42 = string;
  v45 = 0;
  v46 = v33;
  CharactersPtr = CFStringGetCharactersPtr(string);
  CStringPtr = 0;
  v43 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(string, 0x600u);
  v44 = CStringPtr;
  v47 = 0;
  v48 = 0;
  cf = 0;
  v29 = LODWORD(range->length) + LODWORD(range->location);
  utrans_trans();
  if (cf)
    CFRelease(cf);
  range->length = v29 - range->location;
  v27 = 1;
  os_unfair_lock_lock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  if (__CFStringTransformCacheID)
  {
    CFRelease((CFTypeRef)__CFStringTransformCacheID);
    utrans_close();
  }
  __CFStringTransformCacheID = (uint64_t)CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, transform);
  __CFStringTransformCacheTL = v9;
  __CFStringTransformCacheRev = v4 != 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFStringTransformGlobalLock);
  return v27;
}

uint64_t __CFStringReplaceableLength(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t __CFStringReplaceableCharAt(uint64_t a1, signed int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFRange v11;

  if (*(_QWORD *)(a1 + 8) <= a2)
  {
    return (unsigned __int16)-1;
  }
  else
  {
    if (a2 < 0)
      return 0;
    v3 = a2;
    v4 = *(_QWORD *)(a1 + 176);
    if (v4 <= a2)
    {
      return 0;
    }
    else
    {
      v5 = *(_QWORD *)(a1 + 152);
      if (v5)
      {
        return *(unsigned __int16 *)(v5 + 2 * (*(_QWORD *)(a1 + 168) + a2));
      }
      else
      {
        v8 = *(_QWORD *)(a1 + 160);
        if (v8)
        {
          return (unsigned __int16)*(char *)(v8 + *(_QWORD *)(a1 + 168) + a2);
        }
        else
        {
          if (*(_QWORD *)(a1 + 192) <= a2 || (v9 = *(_QWORD *)(a1 + 184), v9 > a2))
          {
            v10 = a2 - 4;
            if (a2 < 4)
              v10 = 0;
            if (v10 + 64 < v4)
              v4 = v10 + 64;
            *(_QWORD *)(a1 + 184) = v10;
            *(_QWORD *)(a1 + 192) = v4;
            v11.location = *(_QWORD *)(a1 + 168) + v10;
            v11.length = v4 - v10;
            CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v11, (UniChar *)(a1 + 16));
            v9 = *(_QWORD *)(a1 + 184);
          }
          return *(unsigned __int16 *)(a1 + 16 + 2 * (v3 - v9));
        }
      }
    }
  }
}

uint64_t __CFStringReplaceableChar32At(uint64_t a1, signed int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int16 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CFRange v20;
  CFRange v21;

  if (*(_QWORD *)(a1 + 8) <= a2)
    return 0xFFFFLL;
  if (a2 < 0)
    return 0;
  v4 = *(_QWORD *)(a1 + 176);
  if (v4 <= a2)
    return 0;
  v5 = a1 + 16;
  v6 = *(_QWORD *)(a1 + 152);
  if (v6)
  {
    v7 = *(_WORD *)(v6 + 2 * (*(_QWORD *)(a1 + 168) + a2));
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 160);
    if (v10)
    {
      v7 = *(char *)(v10 + *(_QWORD *)(a1 + 168) + a2);
    }
    else
    {
      if (*(_QWORD *)(a1 + 192) <= a2 || (v11 = *(_QWORD *)(a1 + 184), v11 > a2))
      {
        v12 = a2 - 4;
        if (a2 < 4)
          v12 = 0;
        if (v12 + 64 < v4)
          v4 = v12 + 64;
        *(_QWORD *)(a1 + 184) = v12;
        *(_QWORD *)(a1 + 192) = v4;
        v20.location = *(_QWORD *)(a1 + 168) + v12;
        v20.length = v4 - v12;
        CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v20, (UniChar *)(a1 + 16));
        v11 = *(_QWORD *)(a1 + 184);
      }
      v7 = *(_WORD *)(v5 + 2 * (a2 - v11));
    }
  }
  if (v7 >> 10 != 54 || *(_QWORD *)(a1 + 8) - 1 <= a2)
    return v7;
  v8 = v7;
  v13 = a2 + 1;
  v14 = *(_QWORD *)(a1 + 176);
  if (v14 > v13)
  {
    v15 = *(_QWORD *)(a1 + 152);
    if (v15)
    {
      v16 = *(_WORD *)(v15 + 2 * (*(_QWORD *)(a1 + 168) + v13));
    }
    else
    {
      v17 = *(_QWORD *)(a1 + 160);
      if (v17)
      {
        v16 = *(char *)(v17 + *(_QWORD *)(a1 + 168) + v13);
      }
      else
      {
        if (*(_QWORD *)(a1 + 192) <= v13 || (v18 = *(_QWORD *)(a1 + 184), v18 > v13))
        {
          v19 = a2 - 3;
          if (a2 < 3)
            v19 = 0;
          if (v19 + 64 < v14)
            v14 = v19 + 64;
          *(_QWORD *)(a1 + 184) = v19;
          *(_QWORD *)(a1 + 192) = v14;
          v21.location = *(_QWORD *)(a1 + 168) + v19;
          v21.length = v14 - v19;
          CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v21, (UniChar *)(a1 + 16));
          v18 = *(_QWORD *)(a1 + 184);
        }
        v16 = *(_WORD *)(v5 + 2 * (v13 - v18));
      }
    }
    if (v16 >> 10 == 55)
      return ((_DWORD)v8 << 10) + v16 - 56613888;
  }
  return v8;
}

const char *__CFStringReplaceableReplace(uint64_t a1, int a2, int a3, UniChar *chars, int a5)
{
  __CFString *v8;
  const __CFString *MutableWithExternalCharactersNoCopy;
  CFIndex Length;
  const __CFString *v11;
  const UniChar *CharactersPtr;
  const char *result;
  CFRange v14;

  v8 = *(__CFString **)(a1 + 200);
  if (v8)
  {
    CFStringSetExternalCharactersNoCopy(v8, chars, a5, a5);
    MutableWithExternalCharactersNoCopy = *(const __CFString **)(a1 + 200);
  }
  else
  {
    MutableWithExternalCharactersNoCopy = CFStringCreateMutableWithExternalCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, chars, a5, a5, (CFAllocatorRef)&__kCFAllocatorNull);
    *(_QWORD *)(a1 + 200) = MutableWithExternalCharactersNoCopy;
  }
  v14.location = a2;
  v14.length = a3 - a2;
  CFStringReplace(*(CFMutableStringRef *)a1, v14, MutableWithExternalCharactersNoCopy);
  Length = CFStringGetLength(*(CFStringRef *)a1);
  *(_QWORD *)(a1 + 8) = Length;
  v11 = *(const __CFString **)a1;
  *(_QWORD *)(a1 + 144) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = Length;
  CharactersPtr = CFStringGetCharactersPtr(v11);
  result = 0;
  *(_QWORD *)(a1 + 152) = CharactersPtr;
  if (!CharactersPtr)
    result = CFStringGetCStringPtr(v11, 0x600u);
  *(_QWORD *)(a1 + 160) = result;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  return result;
}

void __CFStringReplaceableExtract(uint64_t a1, int a2, int a3, UniChar *__dst)
{
  UniChar *v4;
  uint64_t v6;
  CFIndex v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  CFIndex v11;
  uint64_t v12;
  BOOL v13;
  CFIndex v14;
  CFIndex v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  CFRange v19;
  char *v20;
  UniChar v21;

  v4 = __dst;
  v6 = a2;
  v7 = a3 - a2;
  v8 = *(_QWORD *)(a1 + 152);
  if (v8)
  {
    memmove(__dst, (const void *)(v8 + 2 * *(_QWORD *)(a1 + 168) + 2 * a2), 2 * v7);
  }
  else
  {
    v9 = (char *)(a1 + 16);
    v10 = *(_QWORD *)(a1 + 184);
    v11 = v10 - v6;
    if (v10 > v6 || (v12 = *(_QWORD *)(a1 + 192), v13 = v12 <= v6, v14 = v12 - v6, v13))
    {
      v16 = __OFSUB__(v7 + v6, v10);
      v17 = v7 + v6 - v10;
      if (!((v17 < 0) ^ v16 | (v17 == 0)) && v7 + v6 < *(_QWORD *)(a1 + 192))
      {
        memmove(&__dst[v11], v9, 2 * v17);
        v7 = v11;
      }
    }
    else
    {
      if (v14 >= v7)
        v15 = v7;
      else
        v15 = v14;
      memmove(__dst, &v9[2 * (v6 - v10)], 2 * v15);
      v4 += v15;
      v6 += v15;
      v7 -= v15;
    }
    if (v7 >= 1)
    {
      v18 = *(_QWORD *)(a1 + 160);
      v19.location = *(_QWORD *)(a1 + 168) + v6;
      if (v18)
      {
        v20 = (char *)(v18 + v19.location);
        do
        {
          v21 = *v20++;
          *v4++ = v21;
          --v7;
        }
        while (v7);
      }
      else
      {
        v19.length = v7;
        CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v19, v4);
      }
    }
  }
}

const char *__CFStringReplaceableCopy(uint64_t a1, int a2, int a3, int a4)
{
  const __CFString *v6;
  CFIndex Length;
  const __CFString *v8;
  const UniChar *CharactersPtr;
  const char *result;
  CFRange v11;

  v11.length = a3 - a2;
  v11.location = a2;
  v6 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFStringRef *)a1, v11);
  CFStringInsert(*(CFMutableStringRef *)a1, a4, v6);
  CFRelease(v6);
  Length = CFStringGetLength(*(CFStringRef *)a1);
  *(_QWORD *)(a1 + 8) = Length;
  v8 = *(const __CFString **)a1;
  *(_QWORD *)(a1 + 144) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = Length;
  CharactersPtr = CFStringGetCharactersPtr(v8);
  result = 0;
  *(_QWORD *)(a1 + 152) = CharactersPtr;
  if (!CharactersPtr)
    result = CFStringGetCStringPtr(v8, 0x600u);
  *(_QWORD *)(a1 + 160) = result;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  return result;
}

uint64_t (**__CFStringEncodingGetHebrewConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  uint64_t (**v4)();
  uint64_t (**v5)();

  if (!__CFStringEncodingPrecomposeLatinCharacter_4)
  {
    __CFStringEncodingPrecomposeLatinCharacter_4 = a2(4);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_2 = a2(3);
  }
  v4 = __CFConverterISOLatinHebrew;
  v5 = __CFConverterMacHebrew;
  if (a1 != 5)
    v5 = 0;
  if (a1 != 520)
    v4 = v5;
  if (a1 == 1285)
    return __CFConverterWindowsHebrew;
  else
    return v4;
}

uint64_t __CFToISOLatinHebrew(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  uint64_t result;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0xA0)
  {
    v3 = a2;
    goto LABEL_3;
  }
  result = 0;
  if (a2 != 161 && a2 <= 0x203E)
  {
    v5 = (unsigned __int16 *)&ISOLatinHebrew_from_uni;
    v6 = (unsigned __int16 *)&unk_182CF8D00;
    while (1)
    {
      v7 = ((char *)v6 - (char *)v5) >> 3;
      v8 = &v5[2 * v7];
      v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1;
        }
        v5 = v8 + 2;
      }
      else
      {
        v6 = v8 - 2;
      }
      if (v5 > v6)
        return 0;
    }
  }
  return result;
}

BOOL __CFFromISOLatinHebrew(uint64_t a1, unsigned int a2, _WORD *a3)
{
  unsigned int v3;
  unsigned __int16 *v4;

  if (a2 > 0xA0)
  {
    if (a2 <= 0xBE)
    {
      v3 = a2 - 161;
      v4 = (unsigned __int16 *)&ISOLatinHebrew_to_uni;
LABEL_7:
      a2 = v4[v3];
      goto LABEL_8;
    }
    if ((a2 + 5) >= 0xE4u)
    {
      v3 = a2 - 223;
      v4 = (unsigned __int16 *)&ISOLatinHebrew_to_uni2;
      goto LABEL_7;
    }
    a2 = 65533;
  }
LABEL_8:
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacHebrew(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v7;
  uint64_t result;
  unsigned int v9;
  unsigned __int16 *v10;
  unsigned __int16 *v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unsigned int v14;

  if (a5 >= a3 || a5 == 0)
    v7 = a3;
  else
    v7 = a5;
  if (v7 < 1)
  {
    result = 0;
    goto LABEL_24;
  }
  result = 0;
  while (1)
  {
    v9 = *(unsigned __int16 *)(a2 + 2 * result);
    if (v9 <= 0x7F)
      goto LABEL_19;
    if ((unsigned __int16)(v9 + 1204) < 0x554u)
      break;
    v10 = (unsigned __int16 *)&unk_182CF8EDC;
    v11 = (unsigned __int16 *)&MacHebrew_from_uni;
    while (1)
    {
      v12 = ((char *)v10 - (char *)v11) >> 3;
      v13 = &v11[2 * v12];
      v14 = *v13;
      if (v14 <= v9)
        break;
      v10 = v13 - 2;
LABEL_16:
      if (v11 > v10)
        goto LABEL_24;
    }
    if (v14 < v9)
    {
      v11 = v13 + 2;
      goto LABEL_16;
    }
    LOBYTE(v9) = v11[2 * v12 + 1];
LABEL_19:
    if (a5)
      *(_BYTE *)(a4 + result) = v9;
    if (++result == v7)
    {
      result = v7;
      break;
    }
  }
LABEL_24:
  *a6 = result;
  return result;
}

uint64_t __CFFromMacHebrew(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v7;
  uint64_t result;
  unsigned int v9;

  if (a5 >= a3 || a5 == 0)
    v7 = a3;
  else
    v7 = a5;
  if (v7 < 1)
  {
    result = 0;
    goto LABEL_19;
  }
  for (result = 0; result != v7; ++result)
  {
    v9 = *(unsigned __int8 *)(a2 + result);
    if ((*(char *)(a2 + result) & 0x80000000) == 0)
    {
      if (!a5)
        continue;
LABEL_11:
      *(_WORD *)(a4 + 2 * result) = v9;
      continue;
    }
    v9 -= 128;
    if (v9 == 64 || v9 == 94)
      goto LABEL_19;
    LOWORD(v9) = MacHebrew_to_uni[v9];
    if (a5)
      goto LABEL_11;
  }
  result = v7;
LABEL_19:
  *a6 = result;
  return result;
}

uint64_t __CFToWindowsHebrew(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  uint64_t result;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0xA3)
  {
    v3 = a2;
    goto LABEL_3;
  }
  result = 0;
  if (a2 != 164 && a2 <= 0x2122)
  {
    v5 = (unsigned __int16 *)&WindowsHebrew_from_uni;
    v6 = (unsigned __int16 *)&unk_182CF9170;
    while (1)
    {
      v7 = ((char *)v6 - (char *)v5) >> 3;
      v8 = &v5[2 * v7];
      v9 = *v8;
      if (v9 <= a2)
      {
        if (v9 >= a2)
        {
          v3 = v5[2 * v7 + 1];
LABEL_3:
          *a3 = v3;
          return 1;
        }
        v5 = v8 + 2;
      }
      else
      {
        v6 = v8 - 2;
      }
      if (v5 > v6)
        return 0;
    }
  }
  return result;
}

BOOL __CFFromWindowsHebrew(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = WindowsHebrew_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

CFStringRef __CFUUIDCopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  CFStringRef v3;
  CFStringRef v4;

  v2 = CFGetAllocator(a1);
  v3 = CFUUIDCreateString(v2, (CFUUIDRef)a1);
  v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFUUID %p> %@"), a1, v3);
  CFRelease(v3);
  return v4;
}

CFUUIDRef CFUUIDCreateWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return (CFUUIDRef)__CFUUIDCreateWithBytesPrimitive((uint64_t)alloc, (byte6 << 48) | ((unint64_t)byte7 << 56) | (byte5 << 40) | (byte4 << 32) | ((unint64_t)byte3 << 24) | ((unint64_t)byte2 << 16) | ((unint64_t)byte1 << 8) | byte0, byte8 | ((unint64_t)byte9 << 8) | ((unint64_t)byte10 << 16) | ((unint64_t)byte11 << 24) | ((unint64_t)byte12 << 32) | ((unint64_t)byte13 << 40) | ((unint64_t)byte14 << 48) | ((unint64_t)byte15 << 56), 0);
}

UText *CFMutableStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 8, a2);
}

UText *CFAttributedStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 16, a2);
}

UText *CFMutableAttributedStringOpenUText(UText *a1, const void *a2)
{
  return __CFStringUTextInit(a1, 24, a2);
}

CFIndex __CFAttributedStringLength(uint64_t a1)
{
  return CFAttributedStringGetLength(*(CFAttributedStringRef *)(a1 + 72));
}

uint64_t __CFAttributedStringAccess(uint64_t a1, uint64_t a2, int a3)
{
  const __CFString *String;

  String = CFAttributedStringGetString(*(CFAttributedStringRef *)(a1 + 72));
  return doAccess(a1, a2, a3, String);
}

uint64_t __CFAttributedStringExtract(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  const __CFString *String;

  String = CFAttributedStringGetString(*(CFAttributedStringRef *)(a1 + 72));
  return doExtract(a2, a3, a4, a5, a6, String);
}

CFIndex __CFAttributedStringReplace(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  const __CFAttributedString *v12;
  const __CFString *String;
  CFIndex Length;
  CFIndex v15;
  CFIndex v16;
  int v17;
  CFIndex v18;
  CFIndex v19;
  const __CFString *MutableWithExternalCharactersNoCopy;
  const __CFString *v21;
  CFRange v23;

  v12 = *(const __CFAttributedString **)(a1 + 72);
  String = CFAttributedStringGetString(v12);
  Length = CFAttributedStringGetLength(v12);
  if (*a6 > 0)
    return 0;
  v16 = Length;
  if (!a4 && a5)
  {
    v15 = 0;
    v17 = 1;
LABEL_8:
    *a6 = v17;
    return v15;
  }
  if (a2 > a3)
  {
    v15 = 0;
    v17 = 8;
    goto LABEL_8;
  }
  v18 = __pinIndex(a2, Length, String, 1, 1);
  v19 = __pinIndex(a3, v16, String, 0, 1);
  MutableWithExternalCharactersNoCopy = *(const __CFString **)(a1 + 80);
  if (MutableWithExternalCharactersNoCopy)
  {
    CFStringSetExternalCharactersNoCopy(*(CFMutableStringRef *)(a1 + 80), a4, a5, a5);
  }
  else
  {
    MutableWithExternalCharactersNoCopy = CFStringCreateMutableWithExternalCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a4, a5, a5, (CFAllocatorRef)&__kCFAllocatorNull);
    *(_QWORD *)(a1 + 80) = MutableWithExternalCharactersNoCopy;
  }
  v23.length = v19 - v18;
  v23.location = v18;
  CFAttributedStringReplaceString(v12, v23, MutableWithExternalCharactersNoCopy);
  if (*(_QWORD *)(a1 + 16) > v18 || *(_QWORD *)(a1 + 48) != *(_QWORD *)(a1 + 88))
  {
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 28) = 0;
    *(_QWORD *)(a1 + 44) = 0;
    *(_QWORD *)(a1 + 36) = 0;
    *(_DWORD *)(a1 + 52) = 0;
  }
  v15 = CFAttributedStringGetLength(v12) - v16;
  v21 = CFAttributedStringGetString(v12);
  doAccess(a1, v15 + v19, 1, v21);
  return v15;
}

uint64_t __CFAttributedStringCopy(uint64_t a1, CFIndex a2, CFIndex a3, CFIndex a4, int a5, int *a6)
{
  const __CFAttributedString *v12;
  const __CFString *String;
  uint64_t result;
  CFIndex v15;
  CFIndex v16;
  CFIndex v17;
  CFIndex v18;
  const __CFAttributedString *v19;
  CFIndex v21;
  const __CFString *v22;
  CFIndex v23;
  CFRange v24;
  CFRange v25;
  CFRange v26;

  v12 = *(const __CFAttributedString **)(a1 + 72);
  String = CFAttributedStringGetString(v12);
  result = CFAttributedStringGetLength(v12);
  if (*a6 <= 0)
  {
    if (a2 > a3 || (v15 = result, a2 < a4) && a4 < a3)
    {
      *a6 = 8;
      return result;
    }
    v16 = __pinIndex(a2, result, String, 1, 1);
    v17 = __pinIndex(a3, v15, String, 0, 1);
    v18 = v17 - v16;
    v26.location = v16;
    v26.length = v17 - v16;
    v19 = CFAttributedStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v26);
    CFAttributedStringBeginEditing(v12);
    v24.location = a4;
    v24.length = 0;
    CFAttributedStringReplaceAttributedString(v12, v24, v19);
    CFRelease(v19);
    if (a5)
    {
      if (v16 > a4)
        v16 = v17;
      v25.location = v16;
      v25.length = v18;
      CFAttributedStringReplaceString(v12, v25, &stru_1E1337B18);
    }
    CFAttributedStringEndEditing(v12);
    if (v16 >= a4 || a5 == 0)
      v21 = a4;
    else
      v21 = v16;
    if (*(_QWORD *)(a1 + 48) == *(_QWORD *)(a1 + 88))
    {
      v23 = *(_QWORD *)(a1 + 16);
      if (a5)
      {
        if (v23 <= v21)
          goto LABEL_19;
      }
      else if (v23 <= a4)
      {
        goto LABEL_19;
      }
    }
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 28) = 0;
    *(_QWORD *)(a1 + 44) = 0;
    *(_QWORD *)(a1 + 36) = 0;
    *(_DWORD *)(a1 + 52) = 0;
LABEL_19:
    v22 = CFAttributedStringGetString(v12);
    return doAccess(a1, v18 + a4, 1, v22);
  }
  return result;
}

uint64_t doExtract(CFIndex a1, CFIndex a2, UniChar *a3, int a4, int *a5, CFStringRef theString)
{
  CFIndex Length;
  uint64_t v13;
  CFIndex v14;
  int v15;
  CFIndex v17;
  int v18;
  CFRange v19;

  Length = CFStringGetLength(theString);
  if (*a5 > 0)
    return 0;
  if (a4 < 0 || (v14 = Length, !a3) && a4)
  {
    v13 = 0;
    v15 = 1;
LABEL_7:
    *a5 = v15;
    return v13;
  }
  if (a1 < 0 || a2 < a1 || a2 - a1 >= 0x80000000)
  {
    v13 = 0;
    v15 = 8;
    goto LABEL_7;
  }
  v17 = __pinIndex(a1, Length, theString, 1, 1);
  v13 = __pinIndex(a2, v14, theString, 1, 1) - v17;
  if (a3 && a4)
  {
    if ((int)v13 >= a4)
      v18 = a4;
    else
      v18 = v13;
    v19.length = v18;
    v19.location = v17;
    CFStringGetCharacters(theString, v19, a3);
  }
  if (*a5 <= 0)
  {
    if (v13 < 1 || v13 >= a4)
    {
      if (v13 == a4)
        v15 = -124;
      else
        v15 = 15;
    }
    else
    {
      v15 = 0;
      a3[v13] = 0;
      if (*a5 != -124)
        return v13;
    }
    goto LABEL_7;
  }
  return v13;
}

uint64_t __CFStringExtract(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  return doExtract(a2, a3, a4, a5, a6, *(CFStringRef *)(a1 + 72));
}

CFIndex __CFStringReplace(uint64_t a1, CFIndex a2, CFIndex a3, UniChar *a4, int a5, int *a6)
{
  __CFString *v12;
  CFIndex Length;
  CFIndex v14;
  CFIndex v15;
  int v16;
  CFIndex v17;
  CFIndex v18;
  const __CFString *MutableWithExternalCharactersNoCopy;
  CFRange v21;

  v12 = *(__CFString **)(a1 + 72);
  Length = CFStringGetLength(v12);
  if (*a6 > 0)
    return 0;
  v15 = Length;
  if (!a4 && a5)
  {
    v14 = 0;
    v16 = 1;
LABEL_8:
    *a6 = v16;
    return v14;
  }
  if (a2 > a3)
  {
    v14 = 0;
    v16 = 8;
    goto LABEL_8;
  }
  v17 = __pinIndex(a2, Length, v12, 1, 1);
  v18 = __pinIndex(a3, v15, v12, 0, 1);
  MutableWithExternalCharactersNoCopy = *(const __CFString **)(a1 + 80);
  if (MutableWithExternalCharactersNoCopy)
  {
    CFStringSetExternalCharactersNoCopy(*(CFMutableStringRef *)(a1 + 80), a4, a5, a5);
  }
  else
  {
    MutableWithExternalCharactersNoCopy = CFStringCreateMutableWithExternalCharactersNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a4, a5, a5, (CFAllocatorRef)&__kCFAllocatorNull);
    *(_QWORD *)(a1 + 80) = MutableWithExternalCharactersNoCopy;
  }
  v21.length = v18 - v17;
  v21.location = v17;
  CFStringReplace(v12, v21, MutableWithExternalCharactersNoCopy);
  if (*(_QWORD *)(a1 + 16) > v17 || *(_QWORD *)(a1 + 48) != *(_QWORD *)(a1 + 88))
  {
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 28) = 0;
    *(_QWORD *)(a1 + 44) = 0;
    *(_QWORD *)(a1 + 36) = 0;
    *(_DWORD *)(a1 + 52) = 0;
  }
  v14 = CFStringGetLength(v12) - v15;
  doAccess(a1, v14 + v18, 1, v12);
  return v14;
}

CFIndex __CFStringCopy(uint64_t a1, CFIndex a2, CFIndex a3, CFIndex a4, int a5, int *a6)
{
  __CFString *v12;
  CFIndex result;
  CFIndex v14;
  CFIndex v15;
  CFIndex v16;
  const __CFString *v17;
  CFIndex v18;
  CFIndex v19;
  CFRange v20;
  CFRange v21;

  v12 = *(__CFString **)(a1 + 72);
  result = CFStringGetLength(v12);
  if (*a6 <= 0)
  {
    if (a2 > a3 || (v14 = result, a2 < a4) && a4 < a3)
    {
      *a6 = 8;
      return result;
    }
    v15 = __pinIndex(a2, result, v12, 1, 1);
    v16 = __pinIndex(a3, v14, v12, 0, 1);
    v21.location = v15;
    v21.length = v16 - v15;
    v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, v21);
    CFStringInsert(v12, a4, v17);
    CFRelease(v17);
    if (a5)
    {
      if (v15 <= a4)
        v18 = v15;
      else
        v18 = v16;
      v20.location = v18;
      v20.length = v16 - v15;
      CFStringDelete(v12, v20);
      if (*(_QWORD *)(a1 + 48) == *(_QWORD *)(a1 + 88))
      {
        v19 = v18 >= a4 ? a4 : v18;
        if (*(_QWORD *)(a1 + 16) <= v19)
          return doAccess(a1, v16 - v15 + a4, 1, v12);
      }
    }
    else if (*(_QWORD *)(a1 + 48) == *(_QWORD *)(a1 + 88) && *(_QWORD *)(a1 + 16) <= a4)
    {
      return doAccess(a1, v16 - v15 + a4, 1, v12);
    }
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 36) = 0;
    *(_QWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 44) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    return doAccess(a1, v16 - v15 + a4, 1, v12);
  }
  return result;
}

CFStringRef CFStringGetNameOfEncoding(CFStringEncoding encoding)
{
  unint64_t v1;
  const __CFString *Value;
  const char *Name;
  CFStringRef v4;
  CFStringRef v5;
  __CFDictionary *Mutable;

  LODWORD(v1) = encoding;
  os_unfair_lock_lock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
  if (CFStringGetNameOfEncoding_mappingTable)
  {
    Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)CFStringGetNameOfEncoding_mappingTable, (const void *)v1);
    os_unfair_lock_unlock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
    if (Value)
      return Value;
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
  }
  Name = __CFStringEncodingGetName(v1);
  if (Name)
  {
    v4 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, Name, 0x600u);
    if (v4)
    {
      v5 = v4;
      os_unfair_lock_lock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
      if (CFStringGetNameOfEncoding_mappingTable)
      {
        v1 = v1;
        Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)CFStringGetNameOfEncoding_mappingTable, (const void *)v1);
        if (Value)
        {
LABEL_13:
          os_unfair_lock_unlock((os_unfair_lock_t)&CFStringGetNameOfEncoding_mappingTableLock);
          CFRelease(v5);
          return Value;
        }
        Mutable = (__CFDictionary *)CFStringGetNameOfEncoding_mappingTable;
      }
      else
      {
        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, &kCFTypeDictionaryValueCallBacks);
        CFStringGetNameOfEncoding_mappingTable = (uint64_t)Mutable;
        v1 = v1;
      }
      CFDictionaryAddValue(Mutable, (const void *)v1, v5);
      Value = v5;
      goto LABEL_13;
    }
  }
  return 0;
}

UInt32 CFStringConvertEncodingToWindowsCodepage(CFStringEncoding encoding)
{
  UInt32 result;

  result = __CFStringEncodingGetWindowsCodePage(encoding);
  if (!result)
    return -1;
  return result;
}

CFStringEncoding CFStringConvertWindowsCodepageToEncoding(UInt32 codepage)
{
  return __CFStringEncodingGetFromWindowsCodePage((unsigned __int16)codepage);
}

CFURLRef _CFCreateContainerURLForSecurityApplicationGroupIdentifier(const void *a1)
{
  _CFGetEUID();
  return _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser(0, a1);
}

__n128 cow_copy_instance_0(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int *v4;
  int *v5;
  int *v6;
  unint64_t v7;
  uint64_t v8;
  int *v9;
  __n128 result;

  v4 = &OBJC_IVAR_____NSFrozenOrderedSetM_cow;
  if (a2 == 1)
    v5 = &OBJC_IVAR_____NSOrderedSetM_cow;
  else
    v5 = &OBJC_IVAR_____NSFrozenOrderedSetM_cow;
  if (a2 == 1)
    v6 = &OBJC_IVAR_____NSOrderedSetM_storage;
  else
    v6 = &OBJC_IVAR_____NSFrozenOrderedSetM_storage;
  v7 = atomic_load((unint64_t *)(a1 + *v5));
  v8 = *v6;
  if (a4 == 1)
  {
    v4 = &OBJC_IVAR_____NSOrderedSetM_cow;
    v9 = &OBJC_IVAR_____NSOrderedSetM_storage;
  }
  else
  {
    v9 = &OBJC_IVAR_____NSFrozenOrderedSetM_storage;
  }
  atomic_store(v7, (unint64_t *)(a3 + *v4));
  result = *(__n128 *)(a1 + v8);
  *(__n128 *)(a3 + *v9) = result;
  return result;
}

uint64_t cow_copy_storage_0(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  result = objc_msgSend(*(id *)(a1 + 24), "mutableCopyWithZone:", 0);
  if (result)
  {
    v4 = result;
    result = CFBasicHashCreateCopy(0, v2);
    if (result)
    {
      *(_QWORD *)(a1 + 16) = result;
      *(_QWORD *)(a1 + 24) = v4;
      return 1;
    }
  }
  return result;
}

uint64_t cow_set_cow_0(uint64_t result, unint64_t a2)
{
  atomic_store(a2, (unint64_t *)(result + 8));
  return result;
}

void __CFTreeDeallocate(CFTypeRef cf)
{
  char v2;
  int v3;
  __int128 *v4;
  void (*v5)(_QWORD);
  char v6;
  const __CFAllocator *v7;

  v2 = atomic_load((unint64_t *)cf + 1);
  v3 = v2 & 3;
  if (v3)
  {
    if (v3 == 1)
      v4 = (__int128 *)&__kCFTypeTreeCallBacks;
    else
      v4 = (__int128 *)*((_QWORD *)cf + 7);
  }
  else
  {
    v4 = &__kCFNullTreeCallBacks;
  }
  v5 = (void (*)(_QWORD))*((_QWORD *)v4 + 1);
  if (v5)
    v5(*((_QWORD *)cf + 6));
  v6 = atomic_load((unint64_t *)cf + 1);
  if ((~v6 & 3) == 0)
  {
    v7 = CFGetAllocator(cf);
    CFAllocatorDeallocate(v7, *((void **)cf + 7));
  }
}

__CFString *__CFTreeCopyDescription(unint64_t *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  char v4;
  int v5;
  __int128 *v6;
  uint64_t (*v7)(unint64_t);
  CFStringRef v8;
  CFIndex ChildCount;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = atomic_load(a1 + 1);
  v5 = v4 & 3;
  if (v5)
  {
    if (v5 == 1)
      v6 = (__int128 *)&__kCFTypeTreeCallBacks;
    else
      v6 = (__int128 *)a1[7];
  }
  else
  {
    v6 = &__kCFNullTreeCallBacks;
  }
  v7 = (uint64_t (*)(unint64_t))*((_QWORD *)v6 + 2);
  if (!v7 || (v8 = (CFStringRef)v7(a1[6])) == 0)
    v8 = CFStringCreateWithFormat(v2, 0, CFSTR("<CFTree context %p>"), a1[6]);
  ChildCount = CFTreeGetChildCount((CFTreeRef)a1);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFTree %p [%p]>{children = %lu, context = %@}"), a1, v2, ChildCount, v8);
  if (v8)
    CFRelease(v8);
  return Mutable;
}

CFTypeID CFTreeGetTypeID(void)
{
  return 28;
}

CFTreeRef CFTreeCreate(CFAllocatorRef allocator, const CFTreeContext *context)
{
  unint64_t *Instance;
  __CFTree *v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  int v8;

  Instance = (unint64_t *)_CFRuntimeCreateInstance((__objc2_class **)allocator, 0x1CuLL, 48, 0);
  v4 = (__CFTree *)Instance;
  if (Instance)
  {
    v5 = Instance + 1;
    v6 = atomic_load(Instance + 1);
    while (1)
    {
      v7 = __ldaxr(v5);
      if (v7 != v6)
        break;
      if (__stlxr(v6 & 0xFFFFFFFFFFFFFFFCLL, v5))
        goto LABEL_7;
      v8 = 1;
LABEL_8:
      v6 = v7;
      if (v8)
      {
        CFTreeSetContext((CFTreeRef)Instance, context);
        return v4;
      }
    }
    __clrex();
LABEL_7:
    v8 = 0;
    goto LABEL_8;
  }
  return v4;
}

void CFTreeSetContext(CFTreeRef tree, const CFTreeContext *context)
{
  unint64_t v4;
  unint64_t *v5;
  char v6;
  char v7;
  int v8;
  __int128 *v9;
  uint64_t v10;
  CFAllocatorRef v11;
  const __CFAllocator *v12;
  CFTypeRef (__cdecl *retain)(CFTypeRef);
  uint64_t copyDescription;
  uint64_t Typed;
  unint64_t v16;
  unint64_t v17;
  int v18;
  char v19;
  int v20;
  __int128 *v21;
  uint64_t (*v22)(void *);
  void *info;
  void (*v24)(uint64_t);

  v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  v5 = (unint64_t *)((char *)tree + 8);
  v6 = atomic_load((unint64_t *)tree + 1);
  v7 = atomic_load((unint64_t *)tree + 1);
  v8 = v7 & 3;
  if (v8)
  {
    if (v8 == 1)
      v9 = (__int128 *)&__kCFTypeTreeCallBacks;
    else
      v9 = (__int128 *)*((_QWORD *)tree + 7);
  }
  else
  {
    v9 = &__kCFNullTreeCallBacks;
  }
  v10 = *((_QWORD *)tree + 6);
  v11 = CFGetAllocator(tree);
  v12 = v11;
  if (!context)
  {
    copyDescription = 0;
    goto LABEL_19;
  }
  retain = context->retain;
  if (!retain)
  {
    if (!context->release)
    {
      copyDescription = (uint64_t)context->copyDescription;
      if (!copyDescription)
        goto LABEL_19;
    }
LABEL_16:
    Typed = CFAllocatorAllocateTyped(v11, 24, 0x80040D6874129, 0);
    *((_QWORD *)tree + 7) = Typed;
    if (__CFOASafe)
    {
      __CFSetLastAllocationEventName();
      Typed = *((_QWORD *)tree + 7);
    }
    *(_OWORD *)Typed = *(_OWORD *)&context->retain;
    *(_QWORD *)(Typed + 16) = context->copyDescription;
    copyDescription = 3;
    goto LABEL_19;
  }
  if (retain != CFRetain || context->release != CFRelease || context->copyDescription != CFCopyDescription)
    goto LABEL_16;
  copyDescription = 1;
LABEL_19:
  v16 = atomic_load(v5);
  do
  {
    v17 = __ldaxr(v5);
    if (v17 == v16)
    {
      if (!__stlxr(v16 & 0xFFFFFFFFFFFFFFFCLL | copyDescription, v5))
      {
        v18 = 1;
        goto LABEL_25;
      }
    }
    else
    {
      __clrex();
    }
    v18 = 0;
LABEL_25:
    v16 = v17;
  }
  while (!v18);
  v19 = atomic_load(v5);
  v20 = v19 & 3;
  if (v20)
  {
    if (v20 == 1)
      v21 = (__int128 *)&__kCFTypeTreeCallBacks;
    else
      v21 = (__int128 *)*((_QWORD *)tree + 7);
  }
  else
  {
    v21 = &__kCFNullTreeCallBacks;
  }
  v22 = *(uint64_t (**)(void *))v21;
  info = context->info;
  if (v22)
    info = (void *)v22(info);
  *((_QWORD *)tree + 6) = info;
  v24 = (void (*)(uint64_t))*((_QWORD *)v9 + 1);
  if (v24)
    v24(v10);
  if ((~v6 & 3) == 0)
    CFAllocatorDeallocate(v12, v9);
}

CFIndex CFTreeGetChildCount(CFTreeRef tree)
{
  unint64_t v2;
  uint64_t v3;
  CFIndex result;

  v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  v3 = *((_QWORD *)tree + 4);
  if (!v3)
    return 0;
  result = 0;
  do
  {
    v3 = *(_QWORD *)(v3 + 24);
    ++result;
  }
  while (v3);
  return result;
}

CFTreeRef CFTreeGetParent(CFTreeRef tree)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  return (CFTreeRef)*((_QWORD *)tree + 2);
}

CFTreeRef CFTreeGetNextSibling(CFTreeRef tree)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  return (CFTreeRef)*((_QWORD *)tree + 3);
}

CFTreeRef CFTreeGetFirstChild(CFTreeRef tree)
{
  unint64_t v2;

  v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  return (CFTreeRef)*((_QWORD *)tree + 4);
}

CFTreeRef CFTreeFindRoot(CFTreeRef tree)
{
  CFTreeRef v1;
  unint64_t v2;
  CFTreeRef result;

  v1 = tree;
  v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  do
  {
    result = v1;
    v1 = (CFTreeRef)*((_QWORD *)v1 + 2);
  }
  while (v1);
  return result;
}

void CFTreeGetContext(CFTreeRef tree, CFTreeContext *context)
{
  unint64_t v4;
  char v5;
  int v6;
  __int128 *v7;
  void *v8;

  v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  v5 = atomic_load((unint64_t *)tree + 1);
  v6 = v5 & 3;
  if (v6)
  {
    if (v6 == 1)
      v7 = (__int128 *)&__kCFTypeTreeCallBacks;
    else
      v7 = (__int128 *)*((_QWORD *)tree + 7);
  }
  else
  {
    v7 = &__kCFNullTreeCallBacks;
  }
  v8 = (void *)*((_QWORD *)tree + 6);
  context->version = 0;
  context->info = v8;
  *(_OWORD *)&context->retain = *v7;
  context->copyDescription = (CFTreeCopyDescriptionCallBack)*((_QWORD *)v7 + 2);
}

CFTreeRef CFTreeGetChildAtIndex(CFTreeRef tree, CFIndex idx)
{
  unint64_t v4;
  CFTreeRef result;
  BOOL v6;
  CFIndex v7;
  BOOL v8;

  v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  result = (CFTreeRef)*((_QWORD *)tree + 4);
  if (result)
    v6 = idx == 0;
  else
    v6 = 1;
  if (!v6)
  {
    v7 = idx - 1;
    do
    {
      result = (CFTreeRef)*((_QWORD *)result + 3);
      if (result)
        v8 = v7 == 0;
      else
        v8 = 1;
      --v7;
    }
    while (!v8);
  }
  return result;
}

void CFTreeGetChildren(CFTreeRef tree, CFTreeRef *children)
{
  unint64_t v4;
  __CFTree *i;

  v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  for (i = (__CFTree *)*((_QWORD *)tree + 4); i; i = (__CFTree *)*((_QWORD *)i + 3))
    *children++ = i;
}

void CFTreeApplyFunctionToChildren(CFTreeRef tree, CFTreeApplierFunction applier, void *context)
{
  unint64_t v6;
  uint64_t i;

  v6 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v6 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v6);
  for (i = *((_QWORD *)tree + 4); i; i = *(_QWORD *)(i + 24))
    ((void (*)(uint64_t, void *))applier)(i, context);
}

void CFTreePrependChild(CFTreeRef tree, CFTreeRef newChild)
{
  unint64_t v4;

  v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  CFRetain(newChild);
  *((_QWORD *)newChild + 2) = tree;
  *((_QWORD *)newChild + 3) = *((_QWORD *)tree + 4);
  if (!*((_QWORD *)tree + 4))
    *((_QWORD *)tree + 5) = newChild;
  *((_QWORD *)tree + 4) = newChild;
}

void CFTreeAppendChild(CFTreeRef tree, CFTreeRef newChild)
{
  unint64_t v4;
  CFTreeRef *v5;

  v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28 || (v4 = _CFGetNonObjCTypeID((unint64_t *)newChild), v4 != 28))
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  if (*((_QWORD *)newChild + 2))
  {
    __break(1u);
  }
  else
  {
    CFRetain(newChild);
    CFGetAllocator(tree);
    *((_QWORD *)newChild + 2) = tree;
    *((_QWORD *)newChild + 3) = 0;
    v5 = (CFTreeRef *)((char *)tree + 32);
    if (*((_QWORD *)tree + 4))
      v5 = (CFTreeRef *)(*((_QWORD *)tree + 5) + 24);
    *v5 = newChild;
    *((_QWORD *)tree + 5) = newChild;
  }
}

void CFTreeInsertSibling(CFTreeRef tree, CFTreeRef newSibling)
{
  unint64_t v4;
  uint64_t v5;

  v4 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v4 != 28 || (v4 = _CFGetNonObjCTypeID((unint64_t *)newSibling), v4 != 28))
    _CFAssertMismatchedTypeID(0x1CuLL, v4);
  CFRetain(newSibling);
  CFGetAllocator(tree);
  *((_QWORD *)newSibling + 2) = *((_QWORD *)tree + 2);
  *((_QWORD *)newSibling + 3) = *((_QWORD *)tree + 3);
  *((_QWORD *)tree + 3) = newSibling;
  v5 = *((_QWORD *)tree + 2);
  if (v5)
  {
    if (*(CFTreeRef *)(v5 + 40) == tree)
      *(_QWORD *)(v5 + 40) = newSibling;
  }
}

void CFTreeRemove(CFTreeRef tree)
{
  unint64_t v2;
  char *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;

  v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  v3 = (char *)tree + 16;
  v4 = *((_QWORD *)tree + 2);
  if (v4)
  {
    v5 = *(_QWORD **)(v4 + 32);
    if (v5 == (_QWORD *)tree)
    {
      *(_QWORD *)(v4 + 32) = *((_QWORD *)tree + 3);
      if (!*((_QWORD *)tree + 3))
        *(_QWORD *)(*(_QWORD *)v3 + 40) = 0;
    }
    else
    {
      while (v5)
      {
        v6 = v5;
        v5 = (_QWORD *)v5[3];
        if (v5 == (_QWORD *)tree)
        {
          v6[3] = *((_QWORD *)tree + 3);
          v7 = *((_QWORD *)tree + 2);
          if (*(CFTreeRef *)(v7 + 40) == tree)
            *(_QWORD *)(v7 + 40) = v6;
          break;
        }
      }
    }
    *(_QWORD *)v3 = 0;
    *((_QWORD *)tree + 3) = 0;
    CFRelease(tree);
  }
}

void CFTreeRemoveAllChildren(CFTreeRef tree)
{
  unint64_t v2;
  _QWORD *v3;
  _QWORD *v4;

  v2 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v2 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v2);
  v3 = (_QWORD *)*((_QWORD *)tree + 4);
  *((_QWORD *)tree + 4) = 0;
  *((_QWORD *)tree + 5) = 0;
  if (v3)
  {
    do
    {
      v4 = (_QWORD *)v3[3];
      v3[2] = 0;
      v3[3] = 0;
      CFRelease(v3);
      v3 = v4;
    }
    while (v4);
  }
}

void CFTreeSortChildren(CFTreeRef tree, CFComparatorFunction comparator, void *context)
{
  unint64_t v6;
  CFIndex ChildCount;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BOOL4 v12;
  _OWORD *Typed;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD v17[2];
  _OWORD v18[64];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v6 = _CFGetNonObjCTypeID((unint64_t *)tree);
  if (v6 != 28)
    _CFAssertMismatchedTypeID(0x1CuLL, v6);
  ChildCount = CFTreeGetChildCount(tree);
  if (ChildCount >= 2)
  {
    v11 = ChildCount;
    memset(v18, 0, 512);
    if ((unint64_t)ChildCount >= 0x80)
    {
      Typed = (_OWORD *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 8 * ChildCount, 0x2004093837F09, 0);
      v12 = Typed != v18;
      if (__CFOASafe && Typed != v18)
      {
        __CFSetLastAllocationEventName();
        v12 = 1;
      }
    }
    else
    {
      v12 = 0;
      Typed = v18;
    }
    v14 = *((_QWORD *)tree + 4);
    if (v14)
    {
      v15 = Typed;
      do
      {
        *v15++ = v14;
        v14 = *(_QWORD *)(v14 + 24);
      }
      while (v14);
    }
    v17[0] = comparator;
    v17[1] = context;
    CFQSortArray(Typed, v11, 8, (uint64_t)__CFTreeCompareValues, (uint64_t)v17, v8, v9, v10);
    v16 = 0;
    *((_QWORD *)tree + 4) = *(_QWORD *)Typed;
    do
    {
      *(_QWORD *)(*((_QWORD *)Typed + v16) + 24) = *((_QWORD *)Typed + v16 + 1);
      ++v16;
    }
    while (v11 - 1 != v16);
    *(_QWORD *)(*((_QWORD *)Typed + v16) + 24) = 0;
    *((_QWORD *)tree + 5) = *((_QWORD *)Typed + v11 - 1);
    if (v12)
      CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
  }
}

uint64_t __CFTreeCompareValues(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))a3)(*a1, *a2, *(_QWORD *)(a3 + 8));
}

CFDictionaryRef _CFURLPromiseCreateProperties(void *a1, void *a2, int a3)
{
  const NSURLFileResourceType *v3;
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  keys[0] = CFSTR("NSURLNameKey");
  keys[1] = CFSTR("NSURLFileSizeKey");
  keys[2] = CFSTR("NSURLFileResourceTypeKey");
  values[0] = a1;
  values[1] = a2;
  v3 = &kCFURLFileResourceTypeRegular;
  if (a3)
    v3 = &kCFURLFileResourceTypeDirectory;
  values[2] = *(void **)v3;
  return CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

void *_CFURLCopyPropertiesOfPromiseAtURL(CFURLRef fileURL, __CFError **a2)
{
  __CFReadStream *v3;
  __CFReadStream *v4;
  void *v5;
  const void *Value;
  const void *v7;
  __objc2_class **v8;
  __CFDictionary *v9;
  const __CFDictionary *v10;
  CFErrorDomain Domain;
  CFIndex v12;
  __CFError *v13;
  void *values;
  CFErrorRef error[2];

  error[1] = *(CFErrorRef *)MEMORY[0x1E0C80C00];
  v3 = CFReadStreamCreateWithFile(0, fileURL);
  error[0] = 0;
  if (v3)
  {
    v4 = v3;
    if (!CFReadStreamOpen(v3))
    {
      values = CFReadStreamCopyError(v4);
      v10 = CFDictionaryCreate(0, (const void **)&kCFErrorUnderlyingErrorKey, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (values && (Domain = CFErrorGetDomain((CFErrorRef)values), CFEqual(Domain, CFSTR("NSPOSIXErrorDomain"))))
      {
        if (CFErrorGetCode((CFErrorRef)values) == 2)
          v12 = 4;
        else
          v12 = 256;
      }
      else
      {
        v12 = 256;
      }
      error[0] = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), v12, v10);
      if (values)
        CFRelease(values);
      if (v10)
        CFRelease(v10);
      v5 = 0;
LABEL_29:
      v13 = error[0];
      if (!error[0])
        goto LABEL_32;
      goto LABEL_30;
    }
    v5 = (void *)CFPropertyListCreateWithStream(0, v4, 0, 1uLL, 0, error);
    CFReadStreamClose(v4);
    if (v5)
    {
      if (CFGetTypeID(v5) != 18)
      {
        CFRelease(v5);
        v13 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 259, 0);
        error[0] = v13;
        if (v13)
          goto LABEL_25;
        goto LABEL_21;
      }
      Value = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("NSURLFileResourceTypeKey"));
      if (Value)
      {
        v7 = Value;
        CFDictionarySetValue((CFMutableDictionaryRef)v5, CFSTR("NSURLIsSymbolicLinkKey"), &__kCFBooleanFalse);
        CFDictionarySetValue((CFMutableDictionaryRef)v5, CFSTR("NSURLIsAliasFileKey"), &__kCFBooleanFalse);
        CFDictionarySetValue((CFMutableDictionaryRef)v5, CFSTR("NSURLIsVolumeKey"), &__kCFBooleanFalse);
        if (CFEqual(v7, CFSTR("NSURLFileResourceTypeRegular")))
        {
          CFDictionarySetValue((CFMutableDictionaryRef)v5, CFSTR("NSURLIsPackageKey"), &__kCFBooleanFalse);
          CFDictionarySetValue((CFMutableDictionaryRef)v5, CFSTR("NSURLIsDirectoryKey"), &__kCFBooleanFalse);
          v8 = &__kCFBooleanTrue;
          v9 = (__CFDictionary *)v5;
        }
        else
        {
          CFDictionarySetValue((CFMutableDictionaryRef)v5, CFSTR("NSURLIsPackageKey"), &__kCFBooleanTrue);
          CFDictionarySetValue((CFMutableDictionaryRef)v5, CFSTR("NSURLIsDirectoryKey"), &__kCFBooleanTrue);
          v9 = (__CFDictionary *)v5;
          v8 = &__kCFBooleanFalse;
        }
        CFDictionarySetValue(v9, CFSTR("NSURLIsRegularFileKey"), v8);
        goto LABEL_29;
      }
      CFRelease(v5);
    }
    v13 = error[0];
    if (error[0])
    {
LABEL_25:
      v5 = 0;
      if (a2)
      {
LABEL_31:
        *a2 = v13;
        goto LABEL_32;
      }
      goto LABEL_26;
    }
LABEL_21:
    v13 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 256, 0);
    v5 = 0;
    error[0] = v13;
    if (!v13)
      goto LABEL_32;
LABEL_30:
    if (a2)
      goto LABEL_31;
LABEL_26:
    CFRelease(v13);
LABEL_32:
    CFRelease(v4);
    return v5;
  }
  return 0;
}

CFStringRef _CFURLCopyLogicalNameOfPromiseAtURL(const __CFURL *a1, CFErrorRef *a2)
{
  ssize_t v3;
  CFIndex v4;
  CFStringEncoding v5;
  CFStringRef v6;
  UInt8 value[765];
  UInt8 buffer[1026];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1026)
    && (v3 = getxattr((const char *)buffer, "com.apple.icloud.itemName", value, 0x2FCuLL, 0, 1), v3 >= 1))
  {
    v4 = v3;
    v5 = CFStringFileSystemEncoding();
    v6 = CFStringCreateWithBytes(0, value, v4, v5, 0);
    if (!a2)
      return v6;
  }
  else
  {
    v6 = 0;
    if (!a2)
      return v6;
  }
  if (!v6)
    *a2 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 256, 0);
  return v6;
}

const __CFURL *_CFURLCopyLogicalURLOfPromiseAtURL(const __CFURL *a1, CFErrorRef *a2)
{
  CFStringRef v4;
  const __CFString *v5;
  const __CFURL *PathComponent;
  const __CFURL *v7;
  const __CFURL *v8;

  v4 = _CFURLCopyLogicalNameOfPromiseAtURL(a1, a2);
  if (!v4)
    return 0;
  v5 = v4;
  PathComponent = CFURLCreateCopyDeletingLastPathComponent(0, a1);
  if (!PathComponent)
  {
    v8 = 0;
    if (!a2)
      goto LABEL_9;
LABEL_7:
    if (!v8)
    {
      *a2 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 256, 0);
      CFRelease(v5);
      return v8;
    }
    goto LABEL_9;
  }
  v7 = PathComponent;
  v8 = CFURLCreateCopyAppendingPathComponent(0, PathComponent, v5, 0);
  CFRelease(v7);
  if (a2)
    goto LABEL_7;
LABEL_9:
  CFRelease(v5);
  if (v8)
    _CFURLPromiseSetPhysicalURL(v8, a1);
  return v8;
}

CFStringRef _CFURLCopyPromiseNameOfLogicalURL(const __CFURL *a1)
{
  const __CFString *PathComponent;
  const __CFString *v3;
  uint64_t location;
  CFIndex v5;
  uint64_t v6;
  CFStringRef v7;
  CFIndex Length;
  CFIndex v9;
  uint64_t v10;
  CFIndex v11;
  CFIndex v12;
  UInt8 *v13;
  CFIndex usedBufLen;
  uint64_t v16;
  uint64_t v17;
  CFRange range;
  UInt8 bytes[255];
  uint64_t v20;
  CFRange v21;
  CFRange v22;
  CFRange v23;

  v20 = *MEMORY[0x1E0C80C00];
  if (_CFURLIsFileURL((__objc2_class **)a1))
  {
    PathComponent = CFURLCopyLastPathComponent(a1);
    if (PathComponent)
    {
      v3 = PathComponent;
      if (CFStringGetLength(PathComponent) < 1)
      {
        v7 = 0;
LABEL_27:
        CFRelease(v3);
        return v7;
      }
      range.location = 0;
      range.length = 0;
      v16 = 0;
      v17 = 0;
      _CFGetPathExtensionRangesFromPathComponent(v3, &range.location, &v16);
      location = range.location;
      if (range.location == -1 || (v5 = range.length, range.length > 50))
      {
        Length = CFStringGetLength(v3);
        v5 = 0;
        location = -1;
      }
      else
      {
        if (v16 != -1 && v17 + range.length <= 49)
        {
          v6 = 0;
          while (CFStringCompareWithOptions(v3, _CFURLCopyPromiseNameOfLogicalURL_compressionExtensions[v6], range, 0))
          {
            if (++v6 == 4)
            {
              location = range.location;
              v5 = range.length;
              goto LABEL_16;
            }
          }
          location = v16;
          v5 = v17 + range.length + 1;
        }
LABEL_16:
        Length = location - 1;
        if (v5 >= 1)
        {
          usedBufLen = 0;
          v21.location = location;
          v21.length = v5;
          if (CFStringGetBytes(v3, v21, 0x8000100u, 0, 0, 0, 0, &usedBufLen) <= 0)
            v9 = 248;
          else
            v9 = 247 - usedBufLen;
LABEL_21:
          bytes[0] = 46;
          if (CFStringGetCharacterAtIndex(v3, 0) == 95)
          {
            bytes[1] = 46;
            v10 = 2;
          }
          else
          {
            v10 = 1;
          }
          usedBufLen = 0;
          v22.location = 0;
          v22.length = Length;
          CFStringGetBytes(v3, v22, 0x8000100u, 0, 0, &bytes[v10], v9 - v10, &usedBufLen);
          v11 = usedBufLen + v10;
          if (location != -1)
          {
            v12 = v11 + 1;
            bytes[v11] = 46;
            v23.location = location;
            v23.length = v5;
            CFStringGetBytes(v3, v23, 0x8000100u, 0, 0, &bytes[v11 + 1], 254 - v11, &usedBufLen);
            v11 = usedBufLen + v12;
          }
          v13 = &bytes[v11];
          *(_DWORD *)(v13 + 3) = 1685417836;
          *(_DWORD *)v13 = 1818454318;
          v7 = CFStringCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, bytes, v11 + 7, 0x8000100u, 0);
          goto LABEL_27;
        }
      }
      v9 = 248;
      goto LABEL_21;
    }
  }
  return 0;
}

const __CFURL *_CFURLCopyPromiseURLOfLogicalURL(const __CFURL *a1)
{
  const __CFURL *v1;
  CFStringRef v2;
  const __CFString *v3;
  const __CFURL *PathComponent;
  const __CFURL *v5;

  v1 = a1;
  if (a1)
  {
    v2 = _CFURLCopyPromiseNameOfLogicalURL(a1);
    if (v2)
    {
      v3 = v2;
      PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1);
      if (PathComponent)
      {
        v5 = PathComponent;
        v1 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, PathComponent, v3, 0);
        CFRelease(v5);
      }
      else
      {
        v1 = 0;
      }
      CFRelease(v3);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t _CFURLPromiseCopyResourcePropertyForKey(const __CFURL *a1, CFTypeRef cf1, _QWORD *a3, CFErrorRef *a4)
{
  uint64_t result;

  if (CFEqual(cf1, CFSTR("_NSURLPromiseLogicalNameKey"))
    || CFEqual(cf1, CFSTR("_NSURLCloudDocsPlaceholderLogicalNameKey")))
  {
    if (_CFURLIsItemPromiseAtURL((__objc2_class **)a1))
    {
      result = (uint64_t)_CFURLCopyLogicalNameOfPromiseAtURL(a1, a4);
      if (!result)
        return result;
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  if (!CFEqual(cf1, CFSTR("_NSURLPromisePropertiesKey"))
    && !CFEqual(cf1, CFSTR("_NSURLCloudDocsPlaceholderDictionaryKey")))
  {
    return 1;
  }
  if (!_CFURLIsItemPromiseAtURL((__objc2_class **)a1))
  {
LABEL_11:
    result = 0;
    goto LABEL_12;
  }
  result = (uint64_t)_CFURLCopyPropertiesOfPromiseAtURL(a1, a4);
  if (result)
  {
LABEL_12:
    *a3 = result;
    return 1;
  }
  return result;
}

uint64_t _CFURLPromiseSetResourcePropertyForKey()
{
  return 1;
}

double _CFAuditTokenForSelf@<D0>(_OWORD *a1@<X8>)
{
  double result;
  __int128 v3;

  if (_CFAuditTokenForSelf_onceToken != -1)
    dispatch_once(&_CFAuditTokenForSelf_onceToken, &__block_literal_global_21);
  result = *(double *)&_CFAuditTokenForSelf_auditToken;
  v3 = unk_1ECCFA5A0;
  *a1 = _CFAuditTokenForSelf_auditToken;
  a1[1] = v3;
  return result;
}

CFStringRef _CFPrefsCopyUserConstantForUserName(const __CFString *a1)
{
  const __CFString *v2;
  CFStringRef v3;
  int v4;
  BOOL v5;

  if (CFEqual(a1, CFSTR("kCFPreferencesCurrentUser")))
    return CFSTR("kCFPreferencesCurrentUser");
  v2 = CFSTR("kCFPreferencesAnyUser");
  if (!CFEqual(a1, CFSTR("kCFPreferencesAnyUser")))
  {
    v3 = CFCopyUserName();
    v4 = CFEqual(a1, v3);
    CFRelease(v3);
    v5 = !CFSTR("kCFPreferencesCurrentUser") || v4 == 0;
    v2 = CFSTR("kCFPreferencesCurrentUser");
    if (v5)
      return CFStringCreateCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1);
  }
  return v2;
}

void _CFPreferencesAlwaysUseVolatileUserDomains()
{
  __overrideUseVolatileDomainsForUser = 1;
}

uint64_t _CFPrefsValidateValueForKey(const void *a1, uint64_t a2)
{
  NSObject *v5;

  if (a1 && !CFPropertyListIsValid(a1, kCFPropertyListBinaryFormat_v1_0))
  {
    _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
    v5 = _CFPrefsClientLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      _CFPrefsValidateValueForKey_cold_2();
    _CFSetTSD(0xFu, 0, 0);
    if (_CFPreferencesDoesNSUserDefaultsExist())
    {
      _CFSetTSD(0xFu, (uint64_t)&__kCFBooleanTrue, 0);
      _CFThrowFormattedException((uint64_t)CFSTR("NSInvalidArgumentException"), CFSTR("Attempt to insert non-property list object %@ for key %@"), a1, a2);
    }
    _CFPrefsValidateValueForKey_cold_1();
  }
  return 1;
}

void sub_182BE2B2C(void *a1)
{
  objc_begin_catch(a1);
  JUMPOUT(0x182BE2AD4);
}

void sub_182BE2B3C(void *a1)
{
  objc_begin_catch(a1);
  _CFSetTSD(0xFu, 0, 0);
  objc_exception_rethrow();
}

void sub_182BE2B58(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182BE2F20(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  free(*(void **)(v2 - 160));
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BE2F8C(uint64_t a1, int a2)
{
  if (!a2)
    JUMPOUT(0x182BE2F90);
  objc_terminate();
}

void sub_182BE2F9C(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    JUMPOUT(0x182BE2DDCLL);
  }
  JUMPOUT(0x182BE2F84);
}

void __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_182BE3664(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182BE3A40(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

CFStringRef __CFURLCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  const __CFString *v3;
  const __CFString *v4;
  CFComparisonResult v5;
  const void *v6;
  CFStringRef TruncatedURLString;
  unint64_t v8;
  CFStringRef v9;
  CFStringRef v10;
  unint64_t v11;
  const __CFString *v13;
  const void *v14;
  CFStringRef v15;

  v2 = CFGetAllocator((CFTypeRef)a1);
  v3 = CFURLCopyScheme((CFURLRef)a1);
  if (v3 && (v4 = v3, v5 = CFStringCompare(v3, CFSTR("data"), 1uLL), CFRelease(v4), v5 == kCFCompareEqualTo))
  {
    v13 = (const __CFString *)atomic_load((unint64_t *)(a1 + 24));
    TruncatedURLString = CreateTruncatedURLString(v2, v13);
    v14 = *(const void **)(a1 + 32);
    if (v14)
    {
      v15 = CFCopyDescription(v14);
      v10 = CFStringCreateWithFormat(v2, 0, CFSTR("<CFURL %p [%p]>{string = %@, encoding = %u\n\tbase = %@}"), a1, v2, TruncatedURLString, *(unsigned int *)(a1 + 20), v15);
      CFRelease(v15);
      goto LABEL_9;
    }
    v9 = CFStringCreateWithFormat(v2, 0, CFSTR("<CFURL %p [%p]>{string = %@, encoding = %u, base = (null)}"), a1, v2, TruncatedURLString, *(unsigned int *)(a1 + 20));
  }
  else
  {
    v6 = *(const void **)(a1 + 32);
    if (!v6)
    {
      v11 = atomic_load((unint64_t *)(a1 + 24));
      return CFStringCreateWithFormat(v2, 0, CFSTR("<CFURL %p [%p]>{string = %@, encoding = %u, base = (null)}"), a1, v2, v11, *(unsigned int *)(a1 + 20));
    }
    TruncatedURLString = CFCopyDescription(v6);
    v8 = atomic_load((unint64_t *)(a1 + 24));
    v9 = CFStringCreateWithFormat(v2, 0, CFSTR("<CFURL %p [%p]>{string = %@, encoding = %u\n\tbase = %@}"), a1, v2, v8, *(unsigned int *)(a1 + 20), TruncatedURLString);
  }
  v10 = v9;
LABEL_9:
  CFRelease(TruncatedURLString);
  return v10;
}

size_t CFShowURL(uint64_t a1)
{
  FILE **v1;
  FILE *v2;
  int v4;
  const char *v5;
  size_t v6;
  const void *v8;
  FILE *v9;

  v1 = (FILE **)MEMORY[0x1E0C80C20];
  v2 = (FILE *)*MEMORY[0x1E0C80C20];
  if (!a1)
  {
    v5 = "(null)\n";
    v6 = 7;
    return fwrite(v5, v6, 1uLL, v2);
  }
  fprintf(v2, "<CFURL %p>{", (const void *)a1);
  v4 = CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1);
  v2 = *v1;
  if (v4)
  {
    v5 = "ObjC bridged object}\n";
    v6 = 21;
    return fwrite(v5, v6, 1uLL, v2);
  }
  fwrite("\n\tRelative string: ", 0x13uLL, 1uLL, v2);
  v8 = (const void *)atomic_load((unint64_t *)(a1 + 24));
  CFShow(v8);
  fwrite("\tBase URL: ", 0xBuLL, 1uLL, *v1);
  v9 = *v1;
  if (*(_QWORD *)(a1 + 32))
  {
    fprintf(v9, "<%p> ", *(const void **)(a1 + 32));
    CFShow(*(CFTypeRef *)(a1 + 32));
  }
  else
  {
    fwrite("(null)\n", 7uLL, 1uLL, v9);
  }
  return fprintf(*v1, "\tFlags: 0x%x\n}\n", *(_DWORD *)(a1 + 16));
}

unint64_t *_CFURLCreateWithRangesAndFlags(CFStringRef theString, _QWORD *a2, unsigned int a3, unsigned int a4, const void *a5)
{
  unsigned int v6;
  uint64_t v10;
  int HasPrefix;
  unsigned int v12;
  unsigned int v13;
  int v14;
  size_t v15;
  unint64_t *Instance;
  unint64_t *v17;
  CFTypeRef v18;

  v6 = a4;
  if ((a4 & 1) == 0)
    goto LABEL_14;
  v10 = a2[1];
  switch(v10)
  {
    case 5:
      HasPrefix = CFStringHasPrefix(theString, CFSTR("https"));
      v12 = 0x40000000;
      break;
    case 4:
      if (CFStringHasPrefix(theString, CFSTR("http")))
      {
        v14 = 0x20000000;
LABEL_13:
        v6 = v14 & 0xE0000000 | v6 & 0x1FFFFFFF;
        goto LABEL_14;
      }
      if (CFStringHasPrefix(theString, CFSTR("file")))
      {
        v14 = 1610612736;
        goto LABEL_13;
      }
      HasPrefix = CFStringHasPrefix(theString, CFSTR("data"));
      v12 = 0x80000000;
      break;
    case 3:
      HasPrefix = CFStringHasPrefix(theString, CFSTR("ftp"));
      v12 = -1610612736;
      break;
    default:
      goto LABEL_14;
  }
  v13 = v12 & 0xE0000000 | v6 & 0x1FFFFFFF;
  if (HasPrefix)
    v6 = v13;
LABEL_14:
  v15 = 16 * a3;
  Instance = (unint64_t *)_CFRuntimeCreateInstance(0, 0x1DuLL, v15 + 40, 0);
  v17 = Instance;
  if (Instance)
  {
    *((_DWORD *)Instance + 4) = v6;
    *((_DWORD *)Instance + 5) = 134217984;
    memcpy(Instance + 7, a2, v15);
    atomic_store((unint64_t)CFStringCreateCopy(0, theString), v17 + 3);
    if (a5)
      v18 = CFRetain(a5);
    else
      v18 = 0;
    v17[4] = (unint64_t)v18;
  }
  return v17;
}

unint64_t *_CFURLInitWithURLString(unint64_t *a1, const __CFString *a2, int a3, const __CFURL *a4)
{
  unint64_t *result;
  void *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;

  result = _CFURLCreateWithURLString(&__kCFAllocatorSystemDefault, a2, a3, a4);
  if (result)
  {
    v6 = result;
    a1[2] = result[2];
    v7 = atomic_load(result + 3);
    atomic_store(v7, a1 + 3);
    a1[5] = result[5];
    v8 = atomic_load(result + 6);
    atomic_store(v8, a1 + 6);
    a1[4] = result[4];
    LODWORD(v7) = *((_DWORD *)result + 4);
    v9 = *(_QWORD *)&vshl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v7) & 0xFF00FF00FF00FFLL), (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01;
    LOWORD(v9) = vaddv_s16((int16x4_t)v9);
    v10 = v9
        + (v7 & 1)
        + ((v7 >> 5) & 1)
        + ((v7 >> 6) & 1)
        + ((v7 >> 8) & 1)
        + ((v7 & 0x80) >> 7);
    if ((_BYTE)v10)
      memcpy(a1 + 7, result + 7, 16 * v10);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6);
    return (unint64_t *)1;
  }
  return result;
}

CFDataRef CFURLCreateData(CFAllocatorRef allocator, CFURLRef url, CFStringEncoding encoding, Boolean escapeWhitespace)
{
  const __CFString *v6;

  if (url && (v6 = CFURLGetString(url)) != 0)
    return CFStringCreateExternalRepresentation(allocator, v6, encoding, 0);
  else
    return 0;
}

CFURLRef _CFURLInitAbsoluteURLWithBytes(unint64_t *a1, const UInt8 *a2, CFIndex a3, CFStringEncoding a4, const __CFURL *a5)
{
  CFURLRef result;
  void *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;

  result = CFURLCreateAbsoluteURLWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, a2, a3, a4, a5, 0);
  if (result)
  {
    v7 = result;
    a1[2] = *((_QWORD *)result + 2);
    v8 = atomic_load((unint64_t *)result + 3);
    atomic_store(v8, a1 + 3);
    a1[5] = *((_QWORD *)result + 5);
    v9 = atomic_load((unint64_t *)result + 6);
    atomic_store(v9, a1 + 6);
    a1[4] = *((_QWORD *)result + 4);
    LODWORD(v8) = *((_DWORD *)result + 4);
    v10 = *(_QWORD *)&vshl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v8) & 0xFF00FF00FF00FFLL), (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01;
    LOWORD(v10) = vaddv_s16((int16x4_t)v10);
    v11 = v10
        + (v8 & 1)
        + ((v8 >> 5) & 1)
        + ((v8 >> 6) & 1)
        + ((v8 >> 8) & 1)
        + ((v8 & 0x80) >> 7);
    if ((_BYTE)v11)
      memcpy(a1 + 7, (char *)result + 56, 16 * v11);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
    return (CFURLRef)1;
  }
  return result;
}

CFIndex CFURLGetBytesUsingEncoding(unint64_t *a1, UInt8 *a2, CFIndex a3, CFStringEncoding a4)
{
  const __CFString *v8;
  CFIndex Length;
  CFIndex usedBufLen[2];
  CFRange v12;

  usedBufLen[1] = *MEMORY[0x1E0C80C00];
  usedBufLen[0] = 0;
  if (CF_IS_OBJC(0x1DuLL, (__objc2_class **)a1))
    v8 = CFURLGetString((CFURLRef)a1);
  else
    v8 = (const __CFString *)atomic_load(a1 + 3);
  Length = CFStringGetLength(v8);
  v12.location = 0;
  v12.length = Length;
  if (CFStringGetBytes(v8, v12, a4, 0, 0, a2, a3, usedBufLen) == Length)
    return usedBufLen[0];
  else
    return -1;
}

CFStringRef CFURLCopyStrictPath(CFURLRef anURL, Boolean *isAbsolute)
{
  const __CFString *v3;
  const __CFString *v4;
  const __CFAllocator *v5;
  const __CFString *v6;
  CFRange v8;

  v3 = CFURLCopyPath(anURL);
  if (!v3)
    goto LABEL_8;
  v4 = v3;
  if (!CFStringGetLength(v3))
  {
    CFRelease(v4);
LABEL_8:
    v4 = 0;
    goto LABEL_9;
  }
  if (CFStringGetCharacterAtIndex(v4, 0) == 47)
  {
    if (isAbsolute)
      *isAbsolute = 1;
    v5 = CFGetAllocator(v4);
    v8.length = CFStringGetLength(v4) - 1;
    v8.location = 1;
    v6 = CFStringCreateWithSubstring(v5, v4, v8);
    CFRelease(v4);
    return v6;
  }
LABEL_9:
  if (isAbsolute)
    *isAbsolute = 0;
  return v4;
}

const __CFString *_CFURLCopyQueryString(const __CFURL *a1, int a2)
{
  if (a2)
    return CFURLCopyQueryString(a1, &stru_1E1337B18);
  else
    return _unescapedQueryString((uint64_t)a1);
}

const __CFString *_CFURLCopyFragment(const __CFURL *a1, int a2)
{
  if (a2)
    return CFURLCopyFragment(a1, &stru_1E1337B18);
  else
    return _unescapedFragment((__objc2_class **)a1);
}

_QWORD *__CFURLSetReservedPtr(_QWORD *result, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;

  if (result)
  {
    v3 = result;
    v4 = (_QWORD *)result[5];
    if (a2 && !v4)
    {
      result = _CFURLAllocateExtraDataspace(result);
      v4 = (_QWORD *)v3[5];
    }
    if (v4)
      *v4 = a2;
  }
  return result;
}

unint64_t *_CFURLCreateWithFileSystemPathCachingResourcePropertiesForKeys(__objc2_class **a1, const __CFString *a2, const __CFArray *a3, CFErrorRef *a4)
{
  unint64_t *v8;
  unint64_t *v9;
  CFIndex Count;
  CFIndex v11;
  uint64_t IsDirectoryKeyArray;
  CFArrayRef Copy;
  unint64_t *v14;
  unint64_t *v15;
  CFErrorRef v17;
  __CFArray *MutableCopy;
  const __CFArray *v20;
  CFBooleanRef propertyValueTypeRefPtr;
  CFErrorRef error[2];
  CFRange v23;

  error[1] = *(CFErrorRef *)MEMORY[0x1E0C80C00];
  error[0] = 0;
  v8 = (unint64_t *)_CFURLCreateWithFileSystemPath(a1, a2, 0, 0, 0);
  if (!v8)
  {
LABEL_21:
    v17 = error[0];
    if (a4)
    {
      if (!error[0])
        v17 = CFErrorCreate(0, CFSTR("NSPOSIXErrorDomain"), 12, 0);
      v9 = 0;
      *a4 = v17;
    }
    else
    {
      if (error[0])
        CFRelease(error[0]);
      return 0;
    }
    return v9;
  }
  v9 = v8;
  if (!a3 || (Count = CFArrayGetCount(a3)) == 0)
  {
    IsDirectoryKeyArray = _CopyIsDirectoryKeyArray();
    goto LABEL_7;
  }
  v11 = Count;
  v23.location = 0;
  v23.length = Count;
  if (CFArrayContainsValue(a3, v23, CFSTR("NSURLIsDirectoryKey")))
  {
    IsDirectoryKeyArray = (uint64_t)CFRetain(a3);
LABEL_7:
    Copy = (CFArrayRef)IsDirectoryKeyArray;
    goto LABEL_8;
  }
  MutableCopy = CFArrayCreateMutableCopy(0, v11 + 1, a3);
  if (MutableCopy)
  {
    v20 = MutableCopy;
    CFArrayAppendValue(MutableCopy, CFSTR("NSURLIsDirectoryKey"));
    Copy = CFArrayCreateCopy(0, v20);
    CFRelease(v20);
  }
  else
  {
    Copy = 0;
  }
LABEL_8:
  if (_CFURLCacheResourcePropertiesForKeys((__objc2_class **)v9)
    && (propertyValueTypeRefPtr = 0,
        CFURLCopyResourcePropertyForKey((CFURLRef)v9, CFSTR("NSURLIsDirectoryKey"), &propertyValueTypeRefPtr, error)))
  {
    if (propertyValueTypeRefPtr)
    {
      if (CFBooleanGetValue(propertyValueTypeRefPtr))
      {
        v14 = (unint64_t *)_CFURLCreateWithFileSystemPath(a1, a2, 0, 1, 0);
        if (v14)
        {
          v15 = v14;
          if (atomic_load(v9 + 6))
            atomic_store(_FileCacheCreateShallowCopy(), v15 + 6);
          CFRelease(v9);
          v9 = v15;
        }
      }
      CFRelease(propertyValueTypeRefPtr);
    }
  }
  else
  {
    CFRelease(v9);
    v9 = 0;
  }
  if (Copy)
    CFRelease(Copy);
  if (!v9)
    goto LABEL_21;
  return v9;
}

uint64_t _CFURLCacheResourcePropertiesForKeys(__objc2_class **a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v9;
  char v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  if (_CFURLHasFileURLScheme(a1, &v10))
  {
    __CFURLResourceInfoPtr(a1);
    _FSURLCacheResourcePropertiesForKeys();
  }
  else if (!v10)
  {
    CFLog(4, (uint64_t)CFSTR("_CFURLCacheResourcePropertiesForKeys failed because it was passed a URL which has no scheme"), v2, v3, v4, v5, v6, v7, v9);
  }
  return 1;
}

void _CFURLInitWithFileSystemPathRelativeToBase(unint64_t *a1, const __CFString *a2, uint64_t a3, _BOOL4 a4, const void *a5)
{
  unint64_t *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;

  v6 = (unint64_t *)_CFURLCreateWithFileSystemPath(&__kCFAllocatorSystemDefault, a2, a3, a4, a5);
  if (v6)
  {
    v7 = v6;
    a1[2] = v6[2];
    v8 = atomic_load(v6 + 3);
    atomic_store(v8, a1 + 3);
    a1[5] = v6[5];
    v9 = atomic_load(v6 + 6);
    atomic_store(v9, a1 + 6);
    a1[4] = v6[4];
    LODWORD(v8) = *((_DWORD *)v6 + 4);
    v10 = *(_QWORD *)&vshl_u16((uint16x4_t)(*(_QWORD *)&vdup_n_s16(v8) & 0xFF00FF00FF00FFLL), (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0xFF01FF01FF01FF01;
    LOWORD(v10) = vaddv_s16((int16x4_t)v10);
    v11 = v10
        + (v8 & 1)
        + ((v8 >> 5) & 1)
        + ((v8 >> 6) & 1)
        + ((v8 >> 8) & 1)
        + ((v8 & 0x80) >> 7);
    if ((_BYTE)v11)
      memcpy(a1 + 7, v6 + 7, 16 * v11);
    CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
  }
}

CFURLRef CFURLCreateFromFSRef(CFAllocatorRef allocator, const FSRef *fsRef)
{
  return 0;
}

Boolean CFURLGetFSRef(CFURLRef url, FSRef *fsRef)
{
  return 0;
}

uint64_t _CFURLCreateDisplayPathComponentsArray(__objc2_class **a1, CFErrorRef *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFErrorRef v10;
  __int16 v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  if (!_CFURLHasFileURLScheme(a1, &v13))
  {
    if (v13)
    {
      if (a2)
      {
LABEL_7:
        v10 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 262, 0);
        v9 = 0;
        goto LABEL_8;
      }
    }
    else
    {
      CFLog(4, (uint64_t)CFSTR("_CFURLCreateDisplayPathComponentsArray failed because it was passed a URL which has no scheme"), v3, v4, v5, v6, v7, v8, v12);
      if (a2)
        goto LABEL_7;
    }
    return 0;
  }
  v9 = _FileURLCreateDisplayPathComponentsArray();
  if (!v9 && a2)
  {
    v10 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 4, 0);
LABEL_8:
    *a2 = v10;
  }
  return v9;
}

uint64_t _CFURLGetResourcePropertyFlags(__objc2_class **a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  __int16 v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  if (_CFURLHasFileURLScheme(a1, &v13))
  {
    __CFURLResourceInfoPtr(a1);
    result = _FSURLGetResourcePropertyFlags();
    if ((_DWORD)result)
      return result;
  }
  else if (!v13)
  {
    CFLog(4, (uint64_t)CFSTR("_CFURLGetResourcePropertyFlags failed because it was passed a URL which has no scheme"), v5, v6, v7, v8, v9, v10, v12);
  }
  *a3 = 0;
  return 1;
}

CFDictionaryRef _CFURLCopyResourcePropertiesForKeysFromCache(__objc2_class **a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const __CFAllocator *v9;
  __int16 v10;
  char v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  if (_CFURLHasFileURLScheme(a1, &v11))
  {
    __CFURLResourceInfoPtr(a1);
    return (CFDictionaryRef)_FSURLCopyResourcePropertiesForKeysFromCache();
  }
  else
  {
    if (!v11)
      CFLog(4, (uint64_t)CFSTR("_CFURLCopyResourcePropertiesForKeysFromCache failed because it was passed a URL which has no scheme"), v2, v3, v4, v5, v6, v7, v10);
    v9 = CFGetAllocator(a1);
    return CFDictionaryCreate(v9, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
}

uint64_t _CFURLCacheResourcePropertyForKey(__objc2_class **a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v9;
  char v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  if (_CFURLHasFileURLScheme(a1, &v10))
  {
    __CFURLResourceInfoPtr(a1);
    _FSURLCacheResourcePropertyForKey();
  }
  else if (!v10)
  {
    CFLog(4, (uint64_t)CFSTR("_CFURLCacheResourcePropertyForKey failed because it was passed a URL which has no scheme"), v2, v3, v4, v5, v6, v7, v9);
  }
  return 1;
}

uint64_t _CFURLCacheSetAutoFlushingEnabled(__objc2_class **a1)
{
  __CFURLResourceInfoPtr(a1);
  return _FSURLSetCacheAutoFlushingEnabled();
}

uint64_t _CFURLCacheGetAutoFlushingEnabled(__objc2_class **a1)
{
  __CFURLResourceInfoPtr(a1);
  return _FSURLGetCacheAutoFlushingEnabled();
}

uint64_t _CFURLNoteSecurityScopedResourceMoved(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (_CFURLNoteSecurityScopedResourceMoved_onceToken != -1)
    dispatch_once(&_CFURLNoteSecurityScopedResourceMoved_onceToken, &__block_literal_global_22);
  if (_CFURLNoteSecurityScopedResourceMoved__NS_FSURLNoteSecurityScopedResourceMovedWithFileIdentifier)
    return _CFURLNoteSecurityScopedResourceMoved__NS_FSURLNoteSecurityScopedResourceMovedWithFileIdentifier(a1, a2, a3, a4);
  else
    return _FSURLNoteSecurityScopedResourceMoved();
}

CFStringRef CreateTruncatedURLString(const __CFAllocator *a1, CFStringRef theString)
{
  CFIndex Length;
  CFIndex v6;
  CFStringRef v7;
  CFStringRef v8;
  CFStringRef v9;
  CFRange v10;
  CFRange v11;

  Length = CFStringGetLength(theString);
  if (Length <= 128)
    return CFStringCreateCopy(a1, theString);
  v6 = Length;
  v10.location = 0;
  v10.length = 120;
  v7 = CFStringCreateWithSubstring(a1, theString, v10);
  v11.location = v6 - 8;
  v11.length = 8;
  v8 = CFStringCreateWithSubstring(a1, theString, v11);
  v9 = CFStringCreateWithFormat(a1, 0, CFSTR("%@ ... %@"), v7, v8);
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  return v9;
}

CFStringRef WindowsPathToURLPath(const __CFString *a1, const __CFAllocator *a2, int a3, int a4)
{
  CFMutableStringRef MutableCopy;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v10;
  CFIndex v11;
  const void *ValueAtIndex;
  const __CFString *v13;
  const __CFString *v14;
  CFIndex v15;
  CFIndex Count;
  CFIndex v17;
  const __CFString *v18;
  unint64_t Length;
  CFIndex MaximumSizeForEncoding;
  CFIndex v21;
  char *v22;
  size_t v23;
  CFStringRef StringFromFileSystemRepresentationByAddingPercentEscapes;
  CFIndex v25;
  const __CFString *v26;
  CFStringRef v27;
  char buffer[1024];
  uint64_t v30;
  CFRange v31;

  v30 = *MEMORY[0x1E0C80C00];
  if (!CFStringGetLength(a1))
    return CFStringCreateWithCString(a2, "", 0x600u);
  MutableCopy = CFStringCreateMutableCopy(a2, 0, a1);
  v31.length = CFStringGetLength(MutableCopy);
  v31.location = 0;
  CFStringFindAndReplace(MutableCopy, CFSTR("/"), CFSTR("\\"), v31, 0);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(a2, MutableCopy, CFSTR("\\"));
  CFRelease(MutableCopy);
  v10 = CFArrayCreateMutableCopy(a2, 0, ArrayBySeparatingStrings);
  CFRelease(ArrayBySeparatingStrings);
  if (!a3)
  {
    v11 = CFArrayGetCount(v10) - 1;
    ValueAtIndex = CFArrayGetValueAtIndex(v10, v11);
    if (CFEqual(ValueAtIndex, &stru_1E1337B18))
      CFArrayRemoveValueAtIndex(v10, v11);
  }
  v13 = (const __CFString *)CFArrayGetValueAtIndex(v10, 0);
  v15 = a4 && (v14 = v13, CFStringGetLength(v13) == 2) && CFStringGetCharacterAtIndex(v14, 1) == 58;
  Count = CFArrayGetCount(v10);
  if (v15 < Count)
  {
    v17 = Count;
    while (1)
    {
      v18 = (const __CFString *)CFArrayGetValueAtIndex(v10, v15);
      Length = CFStringGetLength(v18);
      if (Length <= 1)
        Length = 1;
      MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
      v21 = MaximumSizeForEncoding + 1;
      if (MaximumSizeForEncoding >= 1024)
        v22 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xBB047E6uLL);
      else
        v22 = buffer;
      if (CFStringGetCString(v18, v22, v21, 0x8000100u))
      {
        v23 = strlen(v22);
        StringFromFileSystemRepresentationByAddingPercentEscapes = CreateStringFromFileSystemRepresentationByAddingPercentEscapes(0, v22, v23, 0, 0, 1, 0);
      }
      else
      {
        StringFromFileSystemRepresentationByAddingPercentEscapes = 0;
      }
      if (v22 != buffer)
        free(v22);
      if (!StringFromFileSystemRepresentationByAddingPercentEscapes)
        break;
      if (StringFromFileSystemRepresentationByAddingPercentEscapes != v18)
        CFArraySetValueAtIndex(v10, v15, StringFromFileSystemRepresentationByAddingPercentEscapes);
      CFRelease(StringFromFileSystemRepresentationByAddingPercentEscapes);
      if (v17 == ++v15)
        goto LABEL_25;
    }
    CFRelease(v10);
    return CFStringCreateWithCString(a2, "", 0x600u);
  }
LABEL_25:
  if (a3)
  {
    v25 = CFArrayGetCount(v10);
    v26 = (const __CFString *)CFArrayGetValueAtIndex(v10, v25 - 1);
    if (CFStringGetLength(v26))
      CFArrayAppendValue(v10, &stru_1E1337B18);
  }
  if (a4)
    CFArrayInsertValueAtIndex(v10, 0, CFSTR("file://"));
  if (!v10)
    return CFStringCreateWithCString(a2, "", 0x600u);
  v27 = CFStringCreateByCombiningStrings(a2, v10, CFSTR("/"));
  CFRelease(v10);
  return v27;
}

uint64_t _CopyIsDirectoryKeyArray()
{
  const void *v0;
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 3221225472;
  v3[2] = ___CopyIsDirectoryKeyArray_block_invoke;
  v3[3] = &unk_1E12E5FF0;
  v3[4] = &v4;
  if (_CopyIsDirectoryKeyArray_onceToken != -1)
    dispatch_once(&_CopyIsDirectoryKeyArray_onceToken, v3);
  v0 = (const void *)v5[3];
  if (v0)
  {
    CFRetain(v0);
    v1 = v5[3];
  }
  else
  {
    v1 = 0;
  }
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_182BE5140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL _CFDataURLCreateDataAndPropertiesFromResource(const __CFAllocator *a1, CFTypeRef cf, __CFString *a3, const __CFArray *a4, CFDictionaryRef *a5, __CFString *a6)
{
  __CFString *v6;
  const __CFAllocator *v11;
  const __CFString *v12;
  const __CFString *v13;
  CFIndex location;
  const __CFString *v15;
  const __CFString *v16;
  const __CFString *v17;
  CFMutableStringRef MutableCopy;
  uint64_t Length;
  const __CFCharacterSet *Predefined;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v23;
  uint64_t v24;
  CFIndex v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  UniChar v30;
  uint64_t v31;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int IsCharacterMember;
  uint64_t v38;
  uint64_t v39;
  __CFString *v40;
  const __CFAllocator *v41;
  __CFString *v42;
  const __CFString *v43;
  CFIndex v44;
  __CFString *v45;
  CFCharacterSetRef v46;
  CFIndex v47;
  const __CFCharacterSet *v48;
  CFIndex v49;
  uint64_t v50;
  int CharacterAtIndex;
  uint64_t v52;
  const __CFAllocator *v53;
  __CFString *v54;
  CFIndex v55;
  CFIndex v56;
  UInt8 *v57;
  CFIndex v58;
  CFIndex v59;
  CFRange v60;
  const __CFAllocator *v61;
  CFIndex v62;
  int v63;
  uint64_t v64;
  int64_t v65;
  int v66;
  const __CFData *v67;
  const __CFData *v68;
  const UInt8 *BytePtr;
  int64_t v70;
  const __CFData *v71;
  CFRange *v72;
  const __CFString *v73;
  CFStringRef v74;
  const __CFArray *v75;
  int64_t v76;
  CFIndex v77;
  int64_t i;
  int v79;
  const UInt8 *v81;
  int v82;
  UInt8 v84;
  BOOL v85;
  int v86;
  UInt8 v87;
  int v88;
  char v89;
  char v90;
  CFIndex v91;
  int v92;
  int v93;
  char v94;
  char v95;
  int v96;
  int v97;
  char v98;
  char v99;
  CFStringRef Copy;
  CFDictionaryRef *v101;
  CFDataRef v102;
  uint64_t v103;
  _BOOL8 v104;
  uint64_t v106;
  const void **v107;
  uint64_t v108;
  CFIndex Count;
  CFIndex v110;
  const __CFArray *v111;
  CFIndex v112;
  int v113;
  const void *ValueAtIndex;
  const void *v115;
  const __CFString *v116;
  uint64_t v117;
  CFDictionaryRef v118;
  CFDictionaryRef *v119;
  const void *v120;
  CFStringRef v121;
  const void *v122[4];
  const void *v123[4];
  uint64_t v124;
  const __CFArray *v125;
  __CFString *v126;
  const __CFAllocator *v127;
  const __CFString *v128;
  CFDictionaryRef *v129;
  CFStringRef v130;
  CFStringRef v131;
  CFAllocatorRef v132;
  CFIndex v133;
  unsigned __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  CFStringRef v142;
  const UniChar *v143;
  const char *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  CFRange v150;
  CFRange v151;
  CFRange v152;
  CFRange v153;
  CFRange v154;
  CFRange v155;
  CFRange v156;

  v6 = a6;
  v132 = a1;
  v149 = *MEMORY[0x1E0C80C00];
  if (a6)
    LODWORD(a6->isa) = 0;
  v11 = CFGetAllocator(cf);
  v12 = CFURLCopyResourceSpecifier((CFURLRef)cf);
  if (!v12)
    goto LABEL_199;
  v13 = v12;
  location = CFStringFind(v12, CFSTR(","), 0).location;
  if (location == -1)
  {
    CFRelease(v13);
    goto LABEL_199;
  }
  v155.length = location;
  v130 = v6;
  v128 = v13;
  v155.location = 0;
  v15 = CFStringCreateWithSubstring(v11, v13, v155);
  v16 = CFURLCreateStringByReplacingPercentEscapes(v11, v15, &stru_1E1337B18);
  if (v16)
  {
    v17 = v16;
    MutableCopy = CFStringCreateMutableCopy(v11, 0, v16);
    CFRelease(v17);
  }
  else
  {
    MutableCopy = CFStringCreateMutableCopy(v11, 0, v15);
  }
  CFRelease(v15);
  CFStringTrimWhitespace(MutableCopy);
  Length = CFStringGetLength(MutableCopy);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  v142 = MutableCopy;
  v145 = 0;
  v146 = Length;
  CharactersPtr = CFStringGetCharactersPtr(MutableCopy);
  CStringPtr = 0;
  v143 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(MutableCopy, 0x600u);
  v131 = MutableCopy;
  v127 = v11;
  v147 = 0;
  v148 = 0;
  v144 = CStringPtr;
  v129 = a5;
  if (Length < 1)
  {
    v40 = 0;
    goto LABEL_52;
  }
  v124 = Length - 1;
  v125 = a4;
  v126 = a3;
  v23 = 0;
  v24 = 0;
  v140 = 0u;
  v141 = 0u;
  v138 = 0u;
  v139 = 0u;
  v136 = 0u;
  v137 = 0u;
  v25 = -1;
  v26 = 64;
  v27 = -1;
  v134 = 0u;
  v135 = 0u;
  while (1)
  {
    v28 = (unint64_t)v24 >= 4 ? 4 : v24;
    v29 = v146;
    if (v146 > v24)
      break;
    v30 = 0;
LABEL_33:
    IsCharacterMember = CFCharacterSetIsCharacterMember(Predefined, v30);
    if (IsCharacterMember)
      v38 = v27;
    else
      v38 = v24;
    if (IsCharacterMember)
      v39 = -1;
    else
      v39 = v24;
    if (v25 == -1)
      v25 = v39;
    else
      v27 = v38;
    ++v24;
    --v23;
    ++v26;
    if (Length == v24)
      goto LABEL_43;
  }
  if (v143)
  {
    v30 = v143[v24 + v145];
  }
  else if (v144)
  {
    v30 = v144[v145 + v24];
  }
  else
  {
    v31 = v147;
    if (v148 <= v24 || v147 > v24)
    {
      v33 = v28 + v23;
      v34 = v26 - v28;
      v35 = v24 - v28;
      v36 = v35 + 64;
      if (v35 + 64 >= v146)
        v36 = v146;
      v147 = v35;
      v148 = v36;
      if (v146 >= v34)
        v29 = v34;
      v150.length = v29 + v33;
      v150.location = v145 + v35;
      CFStringGetCharacters(v142, v150, (UniChar *)&v134);
      v31 = v147;
    }
    v30 = *((_WORD *)&v134 + v24 - v31);
  }
  if (v30 != 59)
    goto LABEL_33;
LABEL_43:
  v40 = 0;
  if (v25 == -1)
  {
    a4 = v125;
    a3 = v126;
  }
  else
  {
    a4 = v125;
    a3 = v126;
    if (v27 != -1)
    {
      v41 = CFGetAllocator(v131);
      v42 = CFStringCreateMutableCopy(v41, Length, v131);
      v40 = v42;
      if (v27 != v124)
      {
        v151.location = v27 + 1;
        v151.length = Length + ~v27;
        CFStringDelete(v42, v151);
      }
      if (v25 >= 1)
      {
        v152.location = 0;
        v152.length = v25;
        CFStringDelete(v40, v152);
      }
      CFStringLowercase(v40, 0);
    }
  }
LABEL_52:
  *(_QWORD *)&v134 = 0;
  *((_QWORD *)&v134 + 1) = 0;
  v43 = v131;
  v44 = CFStringGetLength(v131);
  v156.location = 0;
  v156.length = v44;
  v45 = 0;
  if (CFStringFindWithOptions(v131, CFSTR("charset="), v156, 1uLL, (CFRange *)&v134) && *((_QWORD *)&v134 + 1))
  {
    v46 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
    v47 = *((_QWORD *)&v134 + 1) + v134;
    if (*((_QWORD *)&v134 + 1) + (_QWORD)v134 >= v44)
    {
      v45 = 0;
    }
    else
    {
      v48 = v46;
      v126 = a3;
      v49 = -1;
      v50 = -1;
      do
      {
        CharacterAtIndex = CFStringGetCharacterAtIndex(v131, v47);
        if (CharacterAtIndex == 44 || CharacterAtIndex == 59)
          break;
        if (CFCharacterSetIsCharacterMember(v48, CharacterAtIndex))
        {
          v52 = -1;
        }
        else
        {
          v50 = v47;
          v52 = v47;
        }
        if (v49 == -1)
          v49 = v52;
        ++v47;
      }
      while (v47 < v44);
      if (v49 != -1)
      {
        v43 = v131;
        v53 = CFGetAllocator(v131);
        v54 = CFStringCreateMutableCopy(v53, v44, v131);
        v45 = v54;
        if (v50 != v44)
        {
          v153.location = v50 + 1;
          v153.length = v44 + ~v50;
          CFStringDelete(v54, v153);
        }
        v154.location = 0;
        v154.length = v49;
        CFStringDelete(v45, v154);
        CFStringLowercase(v45, 0);
        a3 = v126;
        goto LABEL_71;
      }
      v45 = 0;
      a3 = v126;
    }
    v43 = v131;
  }
LABEL_71:
  v126 = v45;
  v55 = CFStringFind(v43, CFSTR(";base64"), 1uLL).location;
  if (!v40)
    v40 = (__CFString *)CFRetain(CFSTR("text/plain"));
  v56 = CFURLGetBytes((CFURLRef)cf, 0, 0);
  v57 = (UInt8 *)malloc_type_malloc(v56, 0x42E57B1BuLL);
  CFURLGetBytes((CFURLRef)cf, v57, v56);
  v60 = CFURLGetByteRangeForComponent((CFURLRef)cf, kCFURLComponentResourceSpecifier, 0);
  v59 = v60.length;
  v58 = v60.location;
  v61 = v127;
  if (v57[v60.location] == 44)
  {
    v62 = v60.location;
    v6 = (__CFString *)v130;
  }
  else
  {
    v6 = (__CFString *)v130;
    do
    {
      v62 = v58 + 1;
      --v59;
      v63 = v57[++v58];
    }
    while (v63 != 44);
  }
  v64 = v62 + 1;
  v65 = v59 - 1;
  if (v55 == -1)
  {
    v71 = percentEscapeDecodeBuffer(v127, (uint64_t)v57, v64, v65, 0);
    if (v71)
      goto LABEL_185;
    goto LABEL_83;
  }
  v66 = 1;
  v67 = percentEscapeDecodeBuffer(v127, (uint64_t)v57, v64, v65, 1);
  if (!v67)
  {
    v71 = 0;
    v130 = 0;
    v73 = 0;
    goto LABEL_85;
  }
  v68 = v67;
  BytePtr = CFDataGetBytePtr(v67);
  v130 = (CFStringRef)v68;
  v70 = CFDataGetLength(v68);
  if ((v70 & 3) != 0)
  {
    v71 = 0;
    v72 = 0;
LABEL_81:
    free(v72);
  }
  else
  {
    if (v70 < 1025)
    {
      if (v70 <= 0)
      {
        v71 = CFDataCreate(v127, (const UInt8 *)&v134, 0);
        goto LABEL_184;
      }
      v72 = (CFRange *)&v134;
    }
    else
    {
      v75 = a4;
      v76 = v70;
      v72 = (CFRange *)malloc_type_malloc(v70, 0xBEBC29B3uLL);
      v70 = v76;
      a4 = v75;
    }
    v77 = 0;
    for (i = 0; i < v70; i += 4)
    {
      v79 = BytePtr[i];
      if (((v79 & 0xDF) - 65) >= 0x1Au && v79 != 43 && (v79 - 47) > 0xAu)
        goto LABEL_180;
      v81 = &BytePtr[i];
      v82 = BytePtr[i + 1];
      if (((v82 & 0xDF) - 65) >= 0x1Au && v82 != 43 && (v82 - 47) > 0xAu)
        goto LABEL_180;
      v84 = v81[2];
      v85 = (v84 - 47) >= 0xBu && ((v84 & 0xDF) - 65) >= 0x1Au;
      if (v85 && (v86 = v81[2], v86 != 61) && v86 != 43
        || (v87 = BytePtr[i + 3], (v87 - 47) >= 0xBu)
        && ((v87 & 0xDF) - 65) >= 0x1Au
        && (v88 = BytePtr[i + 3], v88 != 43)
        && v88 != 61)
      {
LABEL_180:
        if (v72 != (CFRange *)&v134)
          free(v72);
        v71 = 0;
        goto LABEL_184;
      }
      v89 = v79 - 65;
      if ((v79 - 65) >= 0x1A)
      {
        if ((v79 - 97) > 0x19)
        {
          if ((v79 - 48) > 9)
          {
            if (v79 == 47)
              v89 = 63;
            else
              v89 = 0;
            if (v79 == 43)
              v89 = 62;
          }
          else
          {
            v89 = v79 + 4;
          }
        }
        else
        {
          v89 = v79 - 71;
        }
      }
      v90 = v82 - 65;
      if ((v82 - 65) >= 0x1A)
      {
        if ((v82 - 97) > 0x19)
        {
          if ((v82 - 48) > 9)
          {
            if (v82 == 47)
              v90 = 63;
            else
              v90 = 0;
            if (v82 == 43)
              v90 = 62;
          }
          else
          {
            v90 = v82 + 4;
          }
        }
        else
        {
          v90 = v82 - 71;
        }
      }
      v91 = v77 + 1;
      *((_BYTE *)&v72->location + v77) = (4 * v89) | ((v90 & 0xF0) >> 4);
      v92 = v81[2];
      if (v92 != 61)
      {
        v93 = v81[1];
        v94 = v93 - 65;
        if ((v93 - 65) >= 0x1A)
        {
          if ((v93 - 97) > 0x19)
          {
            if ((v93 - 48) > 9)
            {
              if (v93 == 47)
                v94 = 63;
              else
                v94 = 0;
              if (v93 == 43)
                v94 = 62;
            }
            else
            {
              v94 = v93 + 4;
            }
          }
          else
          {
            v94 = v93 - 71;
          }
        }
        v95 = v92 - 65;
        if ((v92 - 65) >= 0x1A)
        {
          if ((v92 - 97) > 0x19)
          {
            if ((v92 - 48) > 9)
            {
              if (v92 == 47)
                v95 = 63;
              else
                v95 = 0;
              if (v92 == 43)
                v95 = 62;
            }
            else
            {
              v95 = v92 + 4;
            }
          }
          else
          {
            v95 = v92 - 71;
          }
        }
        *((_BYTE *)&v72->location + v91) = (16 * v94) | ((v95 & 0xFC) >> 2);
        v91 = v77 + 2;
      }
      v96 = BytePtr[i + 3];
      if (v96 == 61)
      {
        v77 = v91;
      }
      else
      {
        v97 = v81[2];
        v98 = v97 - 65;
        if ((v97 - 65) >= 0x1A)
        {
          if ((v97 - 97) > 0x19)
          {
            if ((v97 - 48) > 9)
            {
              if (v97 == 47)
                v98 = 63;
              else
                v98 = 0;
              if (v97 == 43)
                v98 = 62;
            }
            else
            {
              v98 = v97 + 4;
            }
          }
          else
          {
            v98 = v97 - 71;
          }
        }
        v99 = v96 - 65;
        if ((v96 - 65) >= 0x1A)
        {
          if ((v96 - 97) > 0x19)
          {
            if ((v96 - 48) > 9)
            {
              if (v96 == 47)
                v99 = 63;
              else
                v99 = 0;
              if (v96 == 43)
                v99 = 62;
            }
            else
            {
              v99 = v96 + 4;
            }
          }
          else
          {
            v99 = v96 - 71;
          }
        }
        v77 = v91 + 1;
        *((_BYTE *)&v72->location + v91) = v99 | (v98 << 6);
      }
    }
    v71 = CFDataCreate(v61, (const UInt8 *)v72, v77);
    if (v72 != (CFRange *)&v134)
      goto LABEL_81;
  }
LABEL_184:
  CFRelease(v130);
  if (!v71)
  {
LABEL_83:
    v130 = 0;
    v73 = 0;
    v66 = 1;
LABEL_85:
    v74 = v126;
    goto LABEL_192;
  }
LABEL_185:
  if (v40)
    Copy = CFStringCreateCopy(v61, v40);
  else
    Copy = 0;
  v130 = Copy;
  v74 = v126;
  if (v126)
    v73 = CFStringCreateCopy(v61, v126);
  else
    v73 = 0;
  v66 = 0;
LABEL_192:
  free(v57);
  v101 = v129;
  if (v131)
    CFRelease(v131);
  if (v40)
    CFRelease(v40);
  if (v74)
    CFRelease(v74);
  CFRelease(v128);
  if (v66)
  {
LABEL_199:
    if (v6)
      LODWORD(v6->isa) = -10;
    v104 = 0;
    if (a3)
      a3->isa = 0;
    return v104;
  }
  if (a3)
  {
    v102 = CFDataCreateCopy(v132, v71);
    a3->isa = v102;
  }
  if (v101)
  {
    v131 = v73;
    v134 = xmmword_1E1333298;
    *(_QWORD *)&v135 = CFSTR("kCFDataURLTextEncodingName");
    if (!a4)
    {
      a4 = (const __CFArray *)_CFDataURLCreateDataAndPropertiesFromResource_sAllProps;
      if (!_CFDataURLCreateDataAndPropertiesFromResource_sAllProps)
      {
        v102 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&v134, 3, &kCFTypeArrayCallBacks);
        a4 = v102;
        _CFDataURLCreateDataAndPropertiesFromResource_sAllProps = (uint64_t)v102;
      }
    }
    v128 = (const __CFString *)&v124;
    v106 = MEMORY[0x1E0C80A78](v102, v103);
    v107 = v123;
    memset(v123, 0, 24);
    MEMORY[0x1E0C80A78](v106, v108);
    memset(v122, 0, 24);
    Count = CFArrayGetCount(a4);
    if (Count >= 1)
    {
      v110 = Count;
      v111 = a4;
      v112 = 0;
      v113 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v111, v112);
        if (CFEqual(ValueAtIndex, CFSTR("kCFDataURLDataLength")))
        {
          v133 = 0;
          v133 = CFDataGetLength(v71);
          v122[v113] = ValueAtIndex;
          v115 = CFNumberCreate(v132, kCFNumberCFIndexType, &v133);
        }
        else
        {
          if (CFEqual(ValueAtIndex, CFSTR("kCFDataURLMimeType")))
          {
            v116 = v130;
            if (!v130)
              goto LABEL_221;
          }
          else
          {
            if (!CFEqual(ValueAtIndex, CFSTR("kCFDataURLTextEncodingName")))
              goto LABEL_221;
            v116 = v131;
            if (!v131)
              goto LABEL_221;
          }
          v122[v113] = ValueAtIndex;
          v115 = CFStringCreateCopy(v132, v116);
        }
        v123[v113++] = v115;
LABEL_221:
        if (v110 == ++v112)
          goto LABEL_225;
      }
    }
    v113 = 0;
LABEL_225:
    v117 = v113;
    v118 = CFDictionaryCreate(v132, v122, v123, v113, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v119 = v129;
    *v129 = v118;
    if (v113 < 1)
    {
      v73 = v131;
    }
    else
    {
      v73 = v131;
      do
      {
        v120 = *v107++;
        CFRelease(v120);
        --v117;
      }
      while (v117);
      v118 = *v119;
    }
    v104 = v118 != 0;
  }
  else
  {
    v104 = 1;
  }
  v121 = v130;
  if (v71)
  {
    CFRelease(v71);
    v121 = v130;
  }
  if (v121)
    CFRelease(v121);
  if (v73)
    CFRelease(v73);
  return v104;
}

CFTypeRef CFURLCreatePropertyFromResource(CFAllocatorRef alloc, CFURLRef url, CFStringRef property, SInt32 *errorCode)
{
  CFArrayRef v7;
  const void *Value;
  const void *v9;
  CFDictionaryRef properties;
  void *values[2];

  values[1] = *(void **)MEMORY[0x1E0C80C00];
  values[0] = (void *)property;
  v7 = CFArrayCreate(alloc, (const void **)values, 1, &kCFTypeArrayCallBacks);
  properties = 0;
  if (CFURLCreateDataAndPropertiesFromResource(alloc, url, 0, &properties, v7, errorCode))
  {
    Value = CFDictionaryGetValue(properties, values[0]);
    v9 = Value;
    if (Value)
      CFRetain(Value);
    CFRelease(v7);
    v7 = properties;
  }
  else
  {
    if (properties)
      CFRelease(properties);
    v9 = 0;
  }
  CFRelease(v7);
  return v9;
}

Boolean CFURLWriteDataAndPropertiesToResource(CFURLRef url, CFDataRef dataToWrite, CFDictionaryRef propertiesToWrite, SInt32 *errorCode)
{
  const __CFString *v8;
  const __CFString *v9;
  CFComparisonResult v10;
  int v11;
  SInt32 v12;
  _BOOL4 v13;
  SInt32 v14;
  int Length;
  const UInt8 *BytePtr;
  int v17;
  int Count;
  const void **v19;
  uint64_t v20;
  const void **Typed;
  char v22;
  SInt32 v23;
  CFAllocatorRef v24;
  uint64_t v25;
  __CFString *v26;
  const __CFNumber *v27;
  CFTypeID TypeID;
  mode_t v29;
  const __CFAllocator *v30;
  CFURLRef cf;
  int valuePtr;
  UInt8 buffer[1026];
  _OWORD keys[4];
  const void *v36[12];

  v36[9] = *(const void **)MEMORY[0x1E0C80C00];
  v8 = CFURLCopyScheme(url);
  if (!v8)
  {
    if (errorCode)
    {
      LOBYTE(v11) = 0;
      v12 = -15;
LABEL_22:
      *errorCode = v12;
      return v11;
    }
    goto LABEL_61;
  }
  v9 = v8;
  v10 = CFStringCompare(v8, CFSTR("file"), 0);
  CFRelease(v9);
  if (v10 == kCFCompareEqualTo)
  {
    if (errorCode)
      *errorCode = 0;
    if (!dataToWrite)
    {
      LOBYTE(v11) = 1;
      if (!propertiesToWrite)
        return v11;
      goto LABEL_36;
    }
    if (CFURLHasDirectoryPath(url))
    {
      if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026))
      {
        if (!errorCode)
        {
          LOBYTE(v11) = 0;
          if (!propertiesToWrite)
            return v11;
          goto LABEL_36;
        }
        v14 = -15;
        goto LABEL_29;
      }
      v13 = _CFCreateDirectory((char *)buffer);
      LOBYTE(v11) = v13;
      if (errorCode && !v13)
      {
        v14 = -10;
LABEL_29:
        LOBYTE(v11) = 0;
LABEL_34:
        *errorCode = v14;
      }
    }
    else
    {
      Length = CFDataGetLength(dataToWrite);
      if (Length)
        BytePtr = CFDataGetBytePtr(dataToWrite);
      else
        BytePtr = (const UInt8 *)"";
      v17 = _CFWriteBytesToFile(url, BytePtr, Length);
      LOBYTE(v11) = v17;
      if (errorCode && !v17)
      {
        v14 = -10;
        goto LABEL_34;
      }
    }
    if (!propertiesToWrite)
      return v11;
LABEL_36:
    memset(v36, 0, 64);
    memset(keys, 0, sizeof(keys));
    if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026))
    {
      if (!errorCode)
        goto LABEL_61;
      v22 = 0;
      v23 = -15;
      goto LABEL_59;
    }
    Count = CFDictionaryGetCount(propertiesToWrite);
    if (Count >= 8)
    {
      cf = url;
      v24 = CFGetAllocator(url);
      v20 = Count;
      Typed = (const void **)CFAllocatorAllocateTyped(v24, 16 * Count, 1644699173, 0);
      v19 = &Typed[Count];
      CFDictionaryGetKeysAndValues(propertiesToWrite, Typed, v19);
    }
    else
    {
      v19 = v36;
      CFDictionaryGetKeysAndValues(propertiesToWrite, (const void **)keys, v36);
      if (Count < 1)
      {
        v22 = 1;
        if (errorCode)
        {
LABEL_56:
          if (v22)
            v23 = 0;
          else
            v23 = -10;
LABEL_59:
          *errorCode = v23;
        }
LABEL_60:
        if (v22)
          return v11;
        goto LABEL_61;
      }
      cf = url;
      v20 = Count;
      Typed = (const void **)keys;
    }
    v25 = 0;
    v22 = 1;
    do
    {
      v26 = (__CFString *)Typed[v25];
      v27 = (const __CFNumber *)v19[v25];
      if (v26 == CFSTR("kCFURLFilePOSIXMode") || CFEqual(CFSTR("kCFURLFilePOSIXMode"), v26))
      {
        valuePtr = 0;
        TypeID = CFNumberGetTypeID();
        if (TypeID == CFGetTypeID(v27))
        {
          CFNumberGetValue(v27, kCFNumberSInt32Type, &valuePtr);
          v29 = valuePtr;
        }
        else
        {
          v29 = *(_WORD *)CFDataGetBytePtr(v27);
          valuePtr = v29;
        }
        if (chmod((const char *)buffer, v29))
          v22 = 0;
      }
      else
      {
        v22 = 0;
      }
      ++v25;
    }
    while (v20 != v25);
    if (Typed != (const void **)keys)
    {
      v30 = CFGetAllocator(cf);
      CFAllocatorDeallocate(v30, Typed);
    }
    if (errorCode)
      goto LABEL_56;
    goto LABEL_60;
  }
  if (__CFNetwork__CFURLWriteDataAndPropertiesToResource_onceToken != -1)
    dispatch_once(&__CFNetwork__CFURLWriteDataAndPropertiesToResource_onceToken, &__block_literal_global_39);
  if (!__CFNetwork__CFURLWriteDataAndPropertiesToResource_dyfunc)
  {
    if (errorCode)
    {
      v11 = 0;
      *errorCode = -15;
      goto LABEL_20;
    }
LABEL_61:
    LOBYTE(v11) = 0;
    return v11;
  }
  v11 = __CFNetwork__CFURLWriteDataAndPropertiesToResource_dyfunc(url, dataToWrite, propertiesToWrite, errorCode);
  if (!errorCode)
    return v11;
LABEL_20:
  if (!v11)
  {
    v12 = -11;
    goto LABEL_22;
  }
  return v11;
}

Boolean CFURLDestroyResource(CFURLRef url, SInt32 *errorCode)
{
  const __CFString *v4;
  const __CFString *v5;
  CFComparisonResult v6;
  SInt32 v7;
  BOOL v8;
  UInt8 buffer[1026];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v4 = CFURLCopyScheme(url);
  if (!v4)
  {
LABEL_11:
    if (errorCode)
    {
      v7 = -15;
LABEL_22:
      *errorCode = v7;
      return v4;
    }
    return v4;
  }
  v5 = v4;
  v6 = CFStringCompare(v4, CFSTR("file"), 0);
  CFRelease(v5);
  if (v6 == kCFCompareEqualTo)
  {
    LODWORD(v4) = CFURLGetFileSystemRepresentation(url, 1u, buffer, 1026);
    if ((_DWORD)v4)
    {
      if (CFURLHasDirectoryPath(url))
        LODWORD(v4) = _CFRemoveDirectory((char *)buffer);
      else
        LODWORD(v4) = _CFDeleteFile((char *)buffer);
      v8 = (_DWORD)v4 == 0;
      LOBYTE(v4) = (_DWORD)v4 != 0;
      if (v8)
        v7 = -10;
      else
        v7 = 0;
      if (errorCode)
        goto LABEL_22;
      return v4;
    }
    goto LABEL_11;
  }
  if (__CFNetwork__CFURLDestroyResource_onceToken != -1)
    dispatch_once(&__CFNetwork__CFURLDestroyResource_onceToken, &__block_literal_global_42);
  if (__CFNetwork__CFURLDestroyResource_dyfunc)
  {
    LODWORD(v4) = __CFNetwork__CFURLDestroyResource_dyfunc(url, errorCode);
    if (!errorCode)
      return v4;
  }
  else
  {
    LODWORD(v4) = 0;
    if (!errorCode)
      return v4;
    *errorCode = -15;
  }
  if (!(_DWORD)v4)
  {
    v7 = -11;
    goto LABEL_22;
  }
  return v4;
}

CFDataRef percentEscapeDecodeBuffer(const __CFAllocator *a1, uint64_t a2, uint64_t a3, int64_t size, int a5)
{
  UInt8 *v9;
  CFIndex v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  char v15;
  unsigned __int8 v16;
  BOOL v17;
  char v18;
  char v19;
  unsigned int v20;
  BOOL v21;
  unsigned __int8 v22;
  unsigned int v23;
  unsigned __int8 v24;
  unsigned __int8 v25;
  char v26;
  char v27;
  char v28;
  char v29;
  CFDataRef v30;
  const __CFAllocator *allocator;
  UInt8 bytes[1024];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (size < 1025)
  {
    if (size <= 0)
      return CFDataCreate(a1, bytes, 0);
    allocator = a1;
    v9 = bytes;
  }
  else
  {
    allocator = a1;
    v9 = (UInt8 *)malloc_type_malloc(size, 0x350685CAuLL);
  }
  v10 = 0;
  v11 = a3 + size;
  v12 = MEMORY[0x1E0C80978];
  do
  {
    v13 = *(unsigned __int8 *)(a2 + a3);
    if (v13 != 37)
      goto LABEL_36;
    v14 = a3 + 2;
    if (v11 <= a3 + 2
      || (v15 = *(_BYTE *)(a3 + a2 + 1), v16 = v15 - 48, (v15 - 48) >= 0xAu)
      && (*(unsigned __int8 *)(a3 + a2 + 1) - 65 <= 0x25
        ? (v17 = ((1 << (v15 - 65)) & 0x3F0000003FLL) == 0)
        : (v17 = 1),
          v17)
      || (v18 = *(_BYTE *)(a2 + v14), v19 = v18 - 48, v20 = (v18 - 48), v20 >= 0xA)
      && (*(unsigned __int8 *)(a2 + v14) - 65 <= 0x25
        ? (v21 = ((1 << (v18 - 65)) & 0x3F0000003FLL) == 0)
        : (v21 = 1),
          v21))
    {
      LOBYTE(v13) = 37;
LABEL_36:
      v14 = a3;
      if (!a5)
        goto LABEL_39;
      goto LABEL_37;
    }
    v22 = v18 - 65;
    v23 = (v15 - 65);
    if ((v15 - 97) >= 6u)
      v24 = 0;
    else
      v24 = v15 - 87;
    v25 = v15 - 55;
    if (v23 > 5)
      v25 = v24;
    if (v16 >= 0xAu)
      v16 = v25;
    v26 = 16 * v16;
    if ((v18 - 97) >= 6u)
      v27 = 0;
    else
      v27 = v18 - 87;
    v28 = v18 - 55;
    if (v22 <= 5u)
      v29 = v28;
    else
      v29 = v27;
    if (v20 < 0xA)
      v29 = v19;
    LOBYTE(v13) = v29 | v26;
    if (!a5)
      goto LABEL_39;
LABEL_37:
    if ((v13 & 0x80) == 0)
    {
      if ((*(_DWORD *)(v12 + 4 * (char)v13 + 60) & 0x4000) != 0)
        goto LABEL_40;
LABEL_39:
      v9[v10++] = v13;
      goto LABEL_40;
    }
    if (!__maskrune((char)v13, 0x4000uLL))
      goto LABEL_39;
LABEL_40:
    a3 = v14 + 1;
  }
  while (v14 + 1 < v11);
  v30 = CFDataCreate(allocator, v9, v10);
  if (v9 != bytes)
    free(v9);
  return v30;
}

uint64_t CFUniCharGetMappingData(unsigned int a1)
{
  return (uint64_t)*(&__CFUniCharMappingTables + a1);
}

uint64_t CFUniCharMapTo(unsigned int a1, __int16 *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5)
{
  __int16 *v5;
  uint64_t result;
  unsigned int *v8;
  uint64_t v9;
  int v10;
  unsigned int v11[10];
  uint64_t v12;

  v5 = a2;
  v12 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a4 != 4)
    return CFUniCharMapCaseTo(a1, a2, a3, a4, a5, 0);
  if (a1 >= 0x80 && CFUniCharIsMemberOf(a1, 0x65u))
  {
    result = CFUniCharDecomposeCharacter(a1, v11, 10);
    if (result >= 1)
    {
      v8 = v11;
      v9 = result;
      do
      {
        v10 = *v8++;
        *v5++ = v10;
        --v9;
      }
      while (v9);
    }
  }
  else
  {
    *v5 = a1;
    return 1;
  }
  return result;
}

uint64_t CFUniCharGetConditionalCaseMappingFlags(unsigned int a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5, unsigned __int16 *a6, unsigned int a7)
{
  uint64_t v8;
  unint64_t v10;
  unsigned __int16 *v11;
  int v12;
  unsigned __int16 *v13;
  int v15;
  int v16;
  unsigned __int16 *v17;
  int v18;
  char IsMemberOf;
  uint64_t result;
  unsigned __int16 *v21;
  int v22;
  unsigned __int16 *v23;
  int v25;
  BOOL v26;
  unsigned __int16 *v27;
  int v28;
  char v29;
  unsigned int v31;
  uint64_t v32;
  unint64_t v33;
  unsigned int v34;
  int v35;
  unsigned __int16 *v36;
  uint64_t v37;
  unsigned __int16 *v38;
  int v39;
  unsigned __int16 v40;
  uint64_t v41;
  unsigned __int16 *v42;
  uint64_t v43;
  unsigned __int16 *v44;
  int v45;
  unsigned __int16 v46;
  uint64_t v47;
  unint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  int v52;
  int v53;
  uint64_t v54;
  int *v55;
  uint64_t v56;
  __int16 v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v61;
  _BYTE v62[44];

  v8 = a3;
  *(_QWORD *)&v62[36] = *MEMORY[0x1E0C80C00];
  if (a1 == 931)
  {
    if (a3 >= 1 && !a5)
    {
      v10 = a2 + 2 * a4;
      v11 = (unsigned __int16 *)(a2 + 2 * a3 - 2);
      while ((unint64_t)v11 >= a2)
      {
        v13 = v11 - 1;
        v12 = *v11;
        if ((v12 & 0xFC00) == 0xDC00 && (unint64_t)v13 >= a2)
        {
          v15 = *v13;
          v16 = v15 & 0xFC00;
          v17 = v11 - 2;
          v18 = v12 - 56613888 + (v15 << 10);
          if (v16 == 55296)
          {
            v13 = v17;
            v12 = v18;
          }
        }
        IsMemberOf = CFUniCharIsMemberOf(v12, 0x6Du);
        v11 = v13;
        if ((IsMemberOf & 1) == 0)
        {
          if ((CFUniCharIsMemberOf(v12, 7u) & 1) == 0)
          {
            result = CFUniCharIsMemberOf(v12, 6u);
            if (!(_DWORD)result)
              return result;
          }
          break;
        }
      }
      v21 = (unsigned __int16 *)(a2 + 2 * v8 + 2);
      do
      {
        if ((unint64_t)v21 >= v10)
          return 1;
        v23 = v21 + 1;
        v22 = *v21;
        if ((v22 & 0xFC00) == 0xD800 && (unint64_t)v23 < v10)
        {
          v25 = *v23;
          v26 = (v25 & 0xFC00) == 56320;
          v27 = v21 + 2;
          v28 = (v22 << 10) - 56613888 + v25;
          if (v26)
            v23 = v27;
          if (v26)
            v22 = v28;
        }
        v29 = CFUniCharIsMemberOf(v22, 0x6Du);
        v21 = v23;
      }
      while ((v29 & 1) != 0);
      if ((CFUniCharIsMemberOf(v22, 7u) & 1) == 0 && (CFUniCharIsMemberOf(v22, 6u) & 1) == 0)
        return 1;
    }
    return 0;
  }
  if (!a6)
    return 0;
  v31 = *a6;
  if (v31 > 0x746B)
  {
    if (v31 == 31329)
      goto LABEL_44;
    if (v31 != 29804)
      goto LABEL_45;
    if (a1 == 775 && (a7 & 6) == 6)
    {
      v32 = a3 - 1;
      if (a3 >= 1)
      {
        v33 = a2 + 2 * a3;
        if (a3 == 1)
        {
LABEL_43:
          v34 = *(unsigned __int16 *)(v33 - 2);
        }
        else
        {
          do
          {
            v48 = v33 - 2;
            v34 = *(unsigned __int16 *)(v33 - 2);
            if ((v34 & 0xFC00) == 0xDC00)
            {
              if (v8 < 3)
                goto LABEL_113;
              v50 = *(unsigned __int16 *)(v33 - 4);
              v33 -= 4;
              v49 = v50;
              if ((v50 & 0xFC00) != 0xD800)
                goto LABEL_113;
              v34 = v34 - 56613888 + (v49 << 10);
              v8 -= 2;
            }
            else
            {
              v33 -= 2;
              v8 = v32;
            }
            if (!CFUniCharIsMemberOf(v34, 8u))
            {
              v48 = v33;
              goto LABEL_113;
            }
            if (!(v34 >> 17))
            {
              v51 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + HIWORD(v34));
              if (v51)
              {
                if (*(_BYTE *)(v51 + BYTE1(v34))
                  && *(unsigned __int8 *)(v51
                                        + (*(unsigned __int8 *)(v51 + BYTE1(v34)) << 8)
                                        - 256
                                        + v34
                                        + 256) == 230)
                {
                  return 0;
                }
              }
            }
            v32 = v8 - 1;
          }
          while ((unint64_t)v8 >= 2);
          v48 = v33;
          if (v8 == 1)
            goto LABEL_43;
LABEL_113:
          if ((v34 & 0xFC00) == 0xDC00)
          {
            v52 = *(unsigned __int16 *)(v48 - 2);
            v26 = (v52 & 0xFC00) == 55296;
            v53 = (unsigned __int16)v34 - 56613888 + (v52 << 10);
            if (v26)
              v34 = v53;
          }
        }
        v54 = CFUniCharDecomposeCharacter(v34, &v61, 10);
        if (v54 < 2)
          return 2;
        v55 = (int *)v62;
        v56 = v54 - 1;
        while (1)
        {
          v58 = *v55++;
          v57 = v58;
          v59 = BYTE2(v58);
          if (BYTE2(v58) <= 1u)
          {
            v60 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + v59);
            if (v60)
            {
              if (*(_BYTE *)(v60 + HIBYTE(v57))
                && *(unsigned __int8 *)(v60
                                      + (*(unsigned __int8 *)(v60 + HIBYTE(v57)) << 8)
                                      - 256
                                      + v57
                                      + 256) == 230)
              {
                break;
              }
            }
          }
          if (!--v56)
            return 2;
        }
      }
      return 0;
    }
    if (a5)
    {
      if (a1 - 105 > 1)
        goto LABEL_45;
      v36 = (unsigned __int16 *)(a2 + 2 * (a3 + 1));
      v37 = a4 - (a3 + 1);
      while (1)
      {
        if (v37 < 1)
          return 0;
        v38 = v36 + 1;
        v39 = *v36;
        if (v37 != 1 && (v39 & 0xFC00) == 0xD800 && (v40 = v36[2], v36 += 2, (v40 & 0xFC00) == 0xDC00))
        {
          v39 = (v39 << 10) - 56613888 + *v38;
          v37 -= 2;
        }
        else
        {
          v36 = v38;
          --v37;
        }
        result = CFUniCharIsMemberOf(v39, 8u);
        if (!(_DWORD)result)
          return result;
        if (BYTE2(v39) > 1u)
          break;
        v41 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + BYTE2(v39));
        if (v41)
        {
          if (!*(_BYTE *)(v41 + BYTE1(v39)))
            break;
          LODWORD(v41) = *(unsigned __int8 *)(v41
                                            + (*(unsigned __int8 *)(v41 + BYTE1(v39)) << 8)
                                            - 256
                                            + v39
                                            + 256);
        }
LABEL_77:
        result = 6;
        if ((_DWORD)v41 == 230)
          return result;
      }
      LODWORD(v41) = 0;
      goto LABEL_77;
    }
    if (a1 - 73 >= 2 && a1 != 302)
      goto LABEL_45;
    v42 = (unsigned __int16 *)(a2 + 2 * (a3 + 1));
    v43 = a4 - (a3 + 1);
    while (1)
    {
      if (v43 < 1)
        return 0;
      v44 = v42 + 1;
      v45 = *v42;
      if (v43 != 1 && (v45 & 0xFC00) == 0xD800 && (v46 = v42[2], v42 += 2, (v46 & 0xFC00) == 0xDC00))
      {
        v45 = (v45 << 10) - 56613888 + *v44;
        v43 -= 2;
      }
      else
      {
        v42 = v44;
        --v43;
      }
      result = CFUniCharIsMemberOf(v45, 8u);
      if (!(_DWORD)result)
        return result;
      if (BYTE2(v45) > 1u)
        break;
      v47 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + BYTE2(v45));
      if (v47)
      {
        if (!*(_BYTE *)(v47 + BYTE1(v45)))
          break;
        LODWORD(v47) = *(unsigned __int8 *)(v47
                                          + (*(unsigned __int8 *)(v47 + BYTE1(v45)) << 8)
                                          - 256
                                          + v45
                                          + 256);
      }
LABEL_97:
      result = 4;
      if ((_DWORD)v47 == 230)
        return result;
    }
    LODWORD(v47) = 0;
    goto LABEL_97;
  }
  if (v31 != 27758)
  {
    if (v31 != 29300)
    {
LABEL_45:
      if ((a7 & 0x10) != 0 && (CFUniCharIsMemberOf(a1, 8u) & 1) != 0
        || (a1 - 880 < 0x90 || a1 >> 8 == 31) && a5 == 1 && (CFUniCharIsMemberOf(a1, 5u) & 1) != 0)
      {
        return 16;
      }
      return 0;
    }
LABEL_44:
    if (!a5)
    {
      if (a1 == 73)
      {
        if (a3 + 1 < a4)
          return 4 * (*(_WORD *)(a2 + 2 * (a3 + 1)) == 775);
        return 0;
      }
      if (a1 == 775)
        return (a7 >> 1) & 2;
    }
    goto LABEL_45;
  }
  if ((a7 & 8) != 0)
    return 8 * ((a1 & 0xFFFFFFDF) == 74);
  if ((a1 & 0xFFFFFFDF) != 0x49 || a5 != 2)
    goto LABEL_45;
  if (a3 + 1 >= a4)
    return 0;
  v35 = *(unsigned __int16 *)(a2 + 2 * (a3 + 1));
  if (v35 == 106)
    return 8;
  else
    return 8 * (v35 == 74);
}

uint64_t CFUniCharGetNumberOfPlanesForUnicodePropertyData(int a1)
{
  return __CFUniCharUnicodePropertyTable[4 * a1];
}

uint64_t CFUniCharGetUnicodeProperty(int a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;

  if (a2 == 1)
  {
    if (BYTE2(a1) > 0xEu)
      return 1;
    v2 = (uint64_t)*(&__CFUniCharBidiProperty + BYTE2(a1));
    if (!v2)
      return 1;
    v3 = *(unsigned __int8 *)(v2 + BYTE1(a1));
    if (v3 >= 0x13)
    {
      v4 = -4864;
      return *(unsigned __int8 *)(v2 + ((v4 + ((_DWORD)v3 << 8)) & 0xFFFFFF00) + a1 + 256);
    }
  }
  else
  {
    if (a2)
      return 0;
    if (BYTE2(a1) > 1u)
      return 0;
    v2 = (uint64_t)*(&__CFUniCharCombiningPriorityTable + BYTE2(a1));
    if (!v2)
    {
      return 0;
    }
    else
    {
      v3 = *(unsigned __int8 *)(v2 + BYTE1(a1));
      if (*(_BYTE *)(v2 + BYTE1(a1)))
      {
        v4 = -256;
        return *(unsigned __int8 *)(v2 + ((v4 + ((_DWORD)v3 << 8)) & 0xFFFFFF00) + a1 + 256);
      }
    }
  }
  return v3;
}

uint64_t CFUniCharFillDestinationBuffer(unsigned int *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  BOOL v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  int v22;

  v6 = *a5;
  if (a6 != 2)
  {
    if (a6)
    {
      v7 = *a3;
      if (a2 >= 1)
      {
        v11 = v6 + a2;
        v20 = a2 + 1;
        do
        {
          v22 = *a1++;
          v21 = v22;
          if (a4)
          {
            if (v6 >= a4)
              return 0;
            *(_DWORD *)v7 = v21;
            v7 += 4;
          }
          --v20;
          ++v6;
        }
        while (v20 > 1);
        goto LABEL_47;
      }
    }
    else
    {
      v7 = *a3;
      if (a2 >= 1)
      {
        v8 = a2 + 1;
        do
        {
          v10 = *a1++;
          v9 = v10;
          if (v10 < 0x10000)
          {
            v11 = v6 + 1;
            if (a4)
            {
              if (v6 >= a4)
                return 0;
              *(_WORD *)v7 = v9;
              v7 += 2;
            }
          }
          else
          {
            v11 = v6 + 2;
            if (a4)
            {
              if (v11 > a4)
                return 0;
              *(_WORD *)v7 = ((v9 + 67043328) >> 10) - 10240;
              *(_WORD *)(v7 + 2) = v9 & 0x3FF | 0xDC00;
              v7 += 4;
            }
          }
          --v8;
          v6 = v11;
        }
        while (v8 >= 2);
        goto LABEL_47;
      }
    }
LABEL_46:
    v11 = *a5;
LABEL_47:
    *a3 = v7;
    *a5 = v11;
    return 1;
  }
  v7 = *a3;
  if (a2 < 1)
    goto LABEL_46;
  v12 = a2 + 1;
  v11 = *a5;
  while (1)
  {
    v14 = *a1++;
    v13 = v14;
    v15 = v14 >= 0x200000;
    if (v14 >= 0x200000)
      v16 = 65533;
    else
      v16 = v13;
    if (v15)
      v17 = 2;
    else
      v17 = 4;
    if (v13 < 0x10000)
    {
      v16 = v13;
      v17 = 3;
    }
    if (v13 < 0x800)
    {
      v16 = v13;
      v17 = 2;
    }
    if (v13 >= 0x80)
    {
      v18 = v17;
    }
    else
    {
      v16 = v13;
      v18 = 1;
    }
    v11 += v18;
    if (!a4)
      goto LABEL_37;
    if (v11 > a4)
      return 0;
    v19 = v7 + v18;
    switch((int)v18)
    {
      case 1:
        goto LABEL_35;
      case 2:
        goto LABEL_34;
      case 3:
        goto LABEL_33;
      case 4:
        *(_BYTE *)--v19 = v16 & 0x3F | 0x80;
        v16 >>= 6;
LABEL_33:
        *(_BYTE *)--v19 = v16 & 0x3F | 0x80;
        v16 >>= 6;
LABEL_34:
        *(_BYTE *)--v19 = v16 & 0x3F | 0x80;
        v16 >>= 6;
LABEL_35:
        *(_BYTE *)--v19 = CFUniCharFillDestinationBuffer_firstByteMark[v18] | v16;
        break;
      default:
        break;
    }
    v7 = v19 + v18;
LABEL_37:
    if ((unint64_t)--v12 < 2)
      goto LABEL_47;
  }
}

BOOL CFUniCharDecompose(unsigned __int16 *a1, uint64_t a2, _QWORD *a3, unsigned int *a4, uint64_t a5, _QWORD *a6, int a7, int a8, char a9)
{
  return CFUniCharDecomposeWithErrorLocation(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0);
}

uint64_t (**__CFStringEncodingGetTraditionalChineseConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  uint64_t (**v4)();

  if (!__CFStringEncodingIsDecomposableCharacter_1)
  {
    __CFStringEncodingIsDecomposableCharacter_1 = (_UNKNOWN *)a2(1);
    __CFStringEncodingDecomposeCharacter_1 = (_UNKNOWN *)a2(2);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_3 = (_UNKNOWN *)a2(3);
    __CFStringEncodingPrecomposeLatinCharacter_5 = (_UNKNOWN *)a2(4);
  }
  v4 = __CFConverterMacTraditionalChinese;
  if (a1 != 2)
    v4 = 0;
  if (a1 == 2563)
    return __CFConverterBig5;
  else
    return v4;
}

uint64_t __CFToBig5(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  uint64_t result;
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;

  if (a2 < 0x80)
  {
    result = 1;
    goto LABEL_3;
  }
  if (a2 < 0xA2)
    return 0;
  v4 = (unsigned __int16 *)&__CFToBig5CharMap;
  v5 = (unsigned __int16 *)((char *)&__CFToBig5CharMap + 42642);
  while (1)
  {
    v6 = (uint64_t)(0x8E38E38E38E38E39 * (v5 - v4)) >> 1;
    v7 = &v4[9 * v6];
    v8 = *v7;
    if (v8 <= a2)
      break;
    v5 = v7 - 9;
LABEL_10:
    if (v4 > v5)
      return 0;
  }
  if (v8 + 8 <= a2)
  {
    v4 = v7 + 9;
    goto LABEL_10;
  }
  LOWORD(a2) = v4[9 * v6 + 1 + (int)(a2 - v8)];
  if (!(_WORD)a2 || (unsigned __int16)a2 == 65533)
    return 0;
  *a3++ = BYTE1(a2);
  result = 2;
LABEL_3:
  *a3 = a2;
  return result;
}

uint64_t __CFFromBig5(uint64_t a1, char *a2, uint64_t a3, unsigned __int16 *a4)
{
  int v4;
  unsigned int v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  uint64_t v9;
  unsigned __int16 *v10;
  unsigned int v11;
  unsigned __int16 v12;

  v4 = *a2;
  if ((*a2 & 0x80000000) == 0)
  {
    *a4 = v4;
    return 1;
  }
  if (a3 < 2)
    return 0;
  v6 = a2[1] | (v4 << 8);
  if ((unsigned __int16)(v6 + 1566) < 0xA75Eu)
    goto LABEL_11;
  v7 = (unsigned __int16 *)&__CFFromBig5CharMap;
  v8 = (unsigned __int16 *)((char *)&__CFFromBig5CharMap + 28248);
  while (1)
  {
    v9 = (0xF83E0F83E0F83E1 * (v8 - v7)) >> 1;
    v10 = &v7[33 * v9];
    v11 = *v10;
    if (v11 <= v6)
      break;
    v8 = v10 - 33;
LABEL_10:
    if (v7 > v8)
      goto LABEL_11;
  }
  if (v11 + 32 <= v6)
  {
    v7 = v10 + 33;
    goto LABEL_10;
  }
  v12 = v7[33 * v9 + 1 + (int)(v6 - v11)];
  if (!v12)
  {
LABEL_11:
    *a4 = -3;
    return 0;
  }
  *a4 = v12;
  if (v12 == 65533)
    return 0;
  return 2;
}

uint64_t __CFToBig5Len(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t result;
  unsigned int v4;
  uint64_t v5;

  for (result = 0; a3; --a3)
  {
    v4 = *a2++;
    if (v4 < 0x80)
      v5 = 1;
    else
      v5 = 2;
    result += v5;
  }
  return result;
}

uint64_t __CFFromBig5Len(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t result;
  _BOOL4 v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;

  if (a3 < 1)
    return 0;
  result = 0;
  do
  {
    v5 = a3 == 1 || *a2 >= 0;
    v6 = !v5;
    if (v5)
      v7 = 1;
    else
      v7 = 2;
    a2 += v7;
    if (v6)
      v8 = -2;
    else
      v8 = -1;
    ++result;
    v9 = __OFADD__(v8, a3);
    a3 += v8;
  }
  while (!((a3 < 0) ^ v9 | (a3 == 0)));
  return result;
}

uint64_t __CFToBig5Precompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  char v19;
  BOOL v20;
  uint64_t result;
  _BYTE v22[2];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v9 = *a2;
  if (v9 > 0x7F)
  {
    v11 = a2[1];
    if (v9 == 12454)
      v12 = 12532;
    else
      v12 = v9 + 1;
    v13 = v9 + 2;
    if (v11 != 12442)
      v13 = 65533;
    if (v11 == 12441)
      v14 = v12;
    else
      v14 = v13;
    if ((v9 & 0xFFFFFFDF) == 0x418)
      v15 = v9 + 1;
    else
      v15 = -3;
    if (v9 == 1077)
      v16 = 1105;
    else
      v16 = -3;
    if (v9 == 1045)
      v17 = 1025;
    else
      v17 = v16;
    if (v11 != 776)
      v17 = 65533;
    if (v11 == 774)
      v17 = v15;
    if (a2[1] <= 0x3098u)
      v10 = v17;
    else
      v10 = v14;
  }
  else
  {
    v10 = __CFStringEncodingPrecomposeLatinCharacter_5(a2, a3, 0);
  }
  v18 = __CFToBig5(v10, (unsigned __int16)v10, v22);
  v19 = v22[0];
  if (v18)
    v20 = v22[0] == 0;
  else
    v20 = 1;
  if (!v20)
  {
    result = 2;
    *a6 = 2;
    if (!a5)
      return result;
    if (a5 >= 2)
    {
      *a4 = v19;
      a4[1] = v22[1];
      return 2;
    }
  }
  return 0;
}

uint64_t __CFIsValidCombiningCharTraditionalChinese(int a1)
{
  if ((a1 - 774) <= 0x32 && ((1 << (a1 - 6)) & 0x4000000000005) != 0
    || (a1 - 12441) < 2)
  {
    return 1;
  }
  else
  {
    return __CFStringEncodingIsValidCombiningCharacterForLatin1_3();
  }
}

uint64_t __CFToMacTraditionalChinese(char a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v11;
  uint64_t v12;
  unsigned int (**v13)(_QWORD, uint64_t, void *);
  uint64_t v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned __int16 *v17;
  uint64_t v18;
  unsigned __int16 *v19;
  unsigned int v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  uint64_t v23;
  unsigned __int16 *v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  BOOL v28;
  int v29;
  unsigned __int16 v30;
  __int16 v31;
  int v32;
  char v33;
  unsigned __int16 *v34;
  unsigned __int16 *v35;
  uint64_t v36;
  unsigned __int16 *v37;
  unsigned int v38;
  unsigned int v39;
  BOOL v40;
  unsigned int v41;
  unsigned int v42;
  char v43;
  char v44;
  _QWORD *v46;

  if (a3 < 1)
  {
    v12 = 0;
    v11 = 0;
    goto LABEL_159;
  }
  v11 = 0;
  v12 = 0;
  v13 = (unsigned int (**)(_QWORD, uint64_t, void *))&unk_1EDCD1000;
  v14 = 0xA692u;
  while (1)
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0)
        goto LABEL_159;
      v15 = *a2;
      if ((v15 & 0xFFF0) != 0xF870)
        goto LABEL_159;
    }
    else
    {
      v15 = *a2;
    }
    if (v15 < 0x80 || (_DWORD)v15 == 160 || a1 < 0 && (unsigned __int16)(v15 - 131) <= 0x1Cu)
    {
      ++v11;
      if (a5)
        *a4++ = v15;
      goto LABEL_41;
    }
    if ((unsigned __int16)(v15 + 1918) < 0x827u)
      break;
    v16 = (unsigned __int16 *)&__CFToMacTraditionalChineseMap;
    v17 = (unsigned __int16 *)&unk_182DAD29A;
    while (1)
    {
      v18 = ((char *)v17 - (char *)v16) >> 3;
      v19 = &v16[2 * v18];
      v20 = *v19;
      if (v20 <= v15)
        break;
      v17 = v19 - 2;
LABEL_21:
      if (v16 > v17)
        goto LABEL_22;
    }
    if (v20 < v15)
    {
      v16 = v19 + 2;
      goto LABEL_21;
    }
    v26 = v16[2 * v18 + 1];
    if (v26 > 0xFF)
    {
      if (a5)
      {
        if (v11 + 2 > a5)
          goto LABEL_159;
        *a4 = BYTE1(v26);
        a4[1] = v26;
        a4 += 2;
      }
      v11 += 2;
      goto LABEL_41;
    }
    ++v11;
    if (a5)
      *a4++ = v26;
LABEL_41:
    ++a2;
    if (++v12 == a3)
    {
      v12 = a3;
      goto LABEL_159;
    }
  }
LABEL_22:
  if (v15 < 0xA2)
    goto LABEL_38;
  v21 = (unsigned __int16 *)((char *)&__CFToBig5CharMap + v14);
  v22 = (unsigned __int16 *)&__CFToBig5CharMap;
  while (2)
  {
    v23 = (uint64_t)(0x8E38E38E38E38E39 * (v21 - v22)) >> 1;
    v24 = &v22[9 * v23];
    v25 = *v24;
    if (v25 > v15)
    {
      v21 = v24 - 9;
      goto LABEL_28;
    }
    if (v25 + 8 <= v15)
    {
      v22 = v24 + 9;
LABEL_28:
      if (v22 > v21)
        goto LABEL_38;
      continue;
    }
    break;
  }
  v27 = v22[9 * v23 + 1 + (int)(v15 - v25)];
  if ((_WORD)v27)
    v28 = (unsigned __int16)v27 == 65533;
  else
    v28 = 1;
  if (!v28)
  {
    if (a5)
    {
      if (v11 + 2 > a5)
        goto LABEL_159;
      *(_WORD *)a4 = bswap32(v27) >> 16;
      a4 += 2;
    }
    v11 += 2;
    goto LABEL_41;
  }
LABEL_38:
  if ((a1 & 8) != 0 || !v12)
    goto LABEL_159;
  if ((a1 & 0x10) == 0)
    goto LABEL_41;
  if (((v15 - 774) > 0x32 || ((1 << (v15 - 6)) & 0x4000000000005) == 0)
    && (v15 - 12441) >= 2)
  {
    v46 = a6;
    if (v13[94](v15, 1025, &__CFToBig5CharMap))
    {
      LODWORD(v15) = *a2;
      a6 = v46;
      v13 = (unsigned int (**)(_QWORD, uint64_t, void *))&unk_1EDCD1000;
      v14 = 0xA692u;
      goto LABEL_48;
    }
    a6 = v46;
    switch((int)v15)
    {
      case 63612:
        v32 = *(a2 - 1);
        v13 = (unsigned int (**)(_QWORD, uint64_t, void *))&unk_1EDCD1000;
        v14 = 42642;
        switch(v32)
        {
          case 8254:
            v33 = -61;
            goto LABEL_142;
          case 65343:
            v33 = -59;
            goto LABEL_142;
          case 65099:
            v33 = -53;
            goto LABEL_142;
        }
        goto LABEL_159;
      case 63613:
        v41 = *(a2 - 1);
        v13 = (unsigned int (**)(_QWORD, uint64_t, void *))&unk_1EDCD1000;
        v14 = 42642;
        if (v41 <= 0xFF0D)
        {
          switch(v41)
          {
            case 0x3001u:
              v33 = 78;
              break;
            case 0xFF01u:
              v33 = 84;
              break;
            case 0xFF0Cu:
              v33 = 77;
              break;
            default:
              goto LABEL_159;
          }
        }
        else if (*(a2 - 1) > 0xFF1Au)
        {
          if (v41 == 65307)
          {
            v33 = 81;
          }
          else
          {
            if (v41 != 65311)
              goto LABEL_159;
            v33 = 83;
          }
        }
        else if (v41 == 65294)
        {
          v33 = 79;
        }
        else
        {
          if (v41 != 65306)
            goto LABEL_159;
          v33 = 82;
        }
LABEL_142:
        if (a5)
        {
          *(a4 - 2) = -95;
          *(a4 - 1) = v33;
        }
        goto LABEL_41;
      case 63614:
        v13 = (unsigned int (**)(_QWORD, uint64_t, void *))&unk_1EDCD1000;
        v14 = 42642;
        if ((__int16)*(a2 - 1) != -242)
          goto LABEL_159;
        if (a5)
          *((_WORD *)a4 - 1) = 20641;
        goto LABEL_41;
      case 63615:
        v42 = *(a2 - 1);
        v13 = (unsigned int (**)(_QWORD, uint64_t, void *))&unk_1EDCD1000;
        v14 = 42642;
        if (v42 > 0xFF07)
        {
          if (*(a2 - 1) > 0xFF3Bu)
          {
            if (*(a2 - 1) > 0xFF5Au)
            {
              if (v42 == 65371)
              {
                v44 = -95;
                v43 = -95;
                goto LABEL_155;
              }
              if (v42 != 65373)
                goto LABEL_159;
              v43 = -94;
              goto LABEL_151;
            }
            if (v42 != 65340)
            {
              if (v42 != 65343)
                goto LABEL_159;
              v43 = 90;
              goto LABEL_151;
            }
            v43 = 64;
            v44 = -94;
LABEL_155:
            if (!a5)
              goto LABEL_41;
            *(a4 - 2) = v44;
            goto LABEL_157;
          }
          switch(v42)
          {
            case 0xFF08u:
              v43 = 125;
              v44 = -95;
              goto LABEL_155;
            case 0xFF09u:
              v43 = 126;
              break;
            case 0xFF0Fu:
              v43 = -2;
              break;
            default:
              goto LABEL_159;
          }
LABEL_151:
          v44 = -95;
          goto LABEL_155;
        }
        if (*(a2 - 1) > 0x3014u)
        {
          switch(v42)
          {
            case 0x3015u:
              v43 = -92;
              goto LABEL_151;
            case 0x5341u:
              v43 = -52;
              break;
            case 0x5345u:
              v43 = -50;
              break;
            default:
              goto LABEL_159;
          }
        }
        else
        {
          if (v42 == 92)
          {
            if (!a5)
              goto LABEL_41;
            v43 = 0x80;
LABEL_157:
            *(a4 - 1) = v43;
            goto LABEL_41;
          }
          if (v42 != 9474)
          {
            if (v42 != 12308)
              goto LABEL_159;
            v43 = -93;
            goto LABEL_151;
          }
          v43 = 121;
        }
        v44 = -94;
        goto LABEL_155;
      default:
        goto LABEL_159;
    }
  }
LABEL_48:
  v29 = *(a2 - 1);
  if ((int)v15 <= 823)
  {
    if ((_DWORD)v15 != 774)
    {
      if ((_DWORD)v15 == 776)
      {
        if (v29 == 1077)
          v31 = 1105;
        else
          v31 = -3;
        if (v29 == 1045)
          v30 = 1025;
        else
          v30 = v31;
        goto LABEL_83;
      }
      goto LABEL_71;
    }
    if ((v29 & 0xFFFFFFDF) == 0x418)
    {
      v30 = v29 + 1;
      goto LABEL_83;
    }
    goto LABEL_71;
  }
  if ((_DWORD)v15 == 824)
  {
    if (v29 == 61)
    {
      v30 = 8800;
      goto LABEL_83;
    }
LABEL_71:
    v30 = -3;
    goto LABEL_83;
  }
  if ((_DWORD)v15 != 12441)
  {
    if ((_DWORD)v15 == 12442)
    {
      v30 = v29 + 2;
      goto LABEL_82;
    }
    goto LABEL_71;
  }
  if (v29 != 12454)
  {
    v30 = v29 + 1;
LABEL_82:
    if (v30 < 0xA2u)
      goto LABEL_159;
    goto LABEL_83;
  }
  v30 = 12532;
LABEL_83:
  v34 = (unsigned __int16 *)((char *)&__CFToBig5CharMap + v14);
  v35 = (unsigned __int16 *)&__CFToBig5CharMap;
  while (1)
  {
    v36 = (uint64_t)(0x8E38E38E38E38E39 * (v34 - v35)) >> 1;
    v37 = &v35[9 * v36];
    v38 = *v37;
    if (v38 <= v30)
      break;
    v34 = v37 - 9;
LABEL_88:
    if (v35 > v34)
      goto LABEL_159;
  }
  if (v38 + 8 <= v30)
  {
    v35 = v37 + 9;
    goto LABEL_88;
  }
  v39 = v35[9 * v36 + 1 + (int)(v30 - v38)];
  if ((_WORD)v39)
    v40 = (unsigned __int16)v39 == 65533;
  else
    v40 = 1;
  if (!v40)
  {
    if (a5)
      *((_WORD *)a4 - 1) = bswap32(v39) >> 16;
    goto LABEL_41;
  }
LABEL_159:
  *a6 = v11;
  return v12;
}

uint64_t __CFFromMacTraditionalChinese(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4, uint64_t a5, uint64_t *a6)
{
  unint64_t v9;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  BOOL v19;
  unsigned int v20;
  int v21;
  __int16 v22;
  unsigned int v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  uint64_t v26;
  unsigned __int16 *v27;
  unsigned int v28;
  unsigned __int16 v29;
  BOOL v30;
  int IsDecomposableCharacter_1;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  __int16 *v35;
  __int16 v36;
  unint64_t v37;
  uint64_t v39;
  _BYTE v40[4];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (a3 < 1)
    return 0;
  v9 = a3;
  v12 = 0;
  v13 = 0;
  v14 = a1 & 0xC0;
  if ((a1 & 0x200) != 0)
    v15 = 1;
  else
    v15 = 2;
LABEL_5:
  if (a5 && v12 >= a5)
    return v13;
  v16 = (char)*a2;
  v17 = *a2;
  if ((v16 & 0x80000000) == 0 || v16 == -96 || (a1 & 0x80) != 0 && (v17 + 125) <= 0x1Cu)
    goto LABEL_11;
  if (v17 != 128)
  {
    if ((v17 + 3) <= 0x85u)
    {
      if (*a2 > 0xFCu)
      {
        if (v17 == 253)
        {
          LOWORD(v17) = 169;
        }
        else if (v17 == 254)
        {
          LOWORD(v17) = 8482;
        }
        else
        {
          LOWORD(v17) = 8230;
        }
        goto LABEL_11;
      }
      if (v17 == 129)
      {
        if ((a1 & 0x200) == 0)
        {
          LOWORD(v17) = -1920;
          goto LABEL_11;
        }
      }
      else if (v17 == 130 && (a1 & 0x200) == 0)
      {
        LOWORD(v17) = -1919;
LABEL_11:
        if (a5)
          *a4++ = v17;
        ++v12;
        goto LABEL_14;
      }
      v18 = 1;
      goto LABEL_16;
    }
    if (v9 < 2)
      return v13;
    if (v17 != 161)
    {
      if (v17 == 162)
      {
        v20 = a2[1];
        if (v20 > 0xCB)
        {
          if (v20 == 204)
          {
            if ((a1 & 0x200) != 0)
            {
              v22 = 21313;
              goto LABEL_157;
            }
            v21 = 1396832383;
            goto LABEL_92;
          }
          if (v20 == 206)
          {
            if ((a1 & 0x200) != 0)
            {
              v22 = 21317;
              goto LABEL_157;
            }
            v21 = 1397094527;
            goto LABEL_92;
          }
        }
        else
        {
          if (v20 == 64)
          {
            if ((a1 & 0x200) != 0)
            {
              v22 = -196;
              goto LABEL_157;
            }
            v21 = -12781441;
            goto LABEL_92;
          }
          if (v20 == 121)
          {
            if ((a1 & 0x200) != 0)
            {
              v22 = 9474;
              goto LABEL_157;
            }
            v21 = 620951679;
            goto LABEL_92;
          }
        }
      }
      else
      {
        v20 = a2[1];
      }
      goto LABEL_46;
    }
    v20 = a2[1];
    if (v20 <= 0x7D)
    {
      v22 = 183;
      switch(a2[1])
      {
        case 'E':
          goto LABEL_157;
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'L':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
          goto LABEL_46;
        case 'K':
          v22 = 8943;
          goto LABEL_157;
        case 'M':
          if ((a1 & 0x200) == 0)
          {
            v21 = -15927171;
            goto LABEL_92;
          }
          v22 = -244;
          goto LABEL_157;
        case 'N':
          if ((a1 & 0x200) == 0)
          {
            v21 = 805435517;
            goto LABEL_92;
          }
          v22 = 12289;
          goto LABEL_157;
        case 'O':
          if ((a1 & 0x200) != 0)
            goto LABEL_139;
          v21 = -15796099;
          goto LABEL_92;
        case 'P':
          if ((a1 & 0x200) == 0)
          {
            v21 = -15796098;
            goto LABEL_92;
          }
LABEL_139:
          v22 = -242;
          goto LABEL_157;
        case 'Q':
          if ((a1 & 0x200) == 0)
          {
            v21 = -14944131;
            goto LABEL_92;
          }
          v22 = -229;
          goto LABEL_157;
        case 'R':
          if ((a1 & 0x200) == 0)
          {
            v21 = -15009667;
            goto LABEL_92;
          }
          v22 = -230;
          goto LABEL_157;
        case 'S':
          if ((a1 & 0x200) == 0)
          {
            v21 = -14681987;
            goto LABEL_92;
          }
          v22 = -225;
          goto LABEL_157;
        case 'T':
          if ((a1 & 0x200) == 0)
          {
            v21 = -16648067;
            goto LABEL_92;
          }
          v22 = -255;
          goto LABEL_157;
        case 'Z':
          if ((a1 & 0x200) != 0)
            goto LABEL_138;
          v21 = -12584833;
          goto LABEL_92;
        default:
          if (v20 != 125)
            goto LABEL_46;
          if ((a1 & 0x200) == 0)
          {
            v21 = -16189313;
            goto LABEL_92;
          }
          v22 = -248;
          break;
      }
      goto LABEL_157;
    }
    if (a2[1] <= 0xC2u)
    {
      switch(a2[1])
      {
        case 0xA1u:
          if ((a1 & 0x200) != 0)
          {
            v22 = -165;
            goto LABEL_157;
          }
          v21 = -10749825;
          break;
        case 0xA2u:
          if ((a1 & 0x200) == 0)
          {
            v21 = -10618753;
            break;
          }
          v22 = -163;
          goto LABEL_157;
        case 0xA3u:
          if ((a1 & 0x200) == 0)
          {
            v21 = 806680703;
            break;
          }
          v22 = 12308;
          goto LABEL_157;
        case 0xA4u:
          if ((a1 & 0x200) == 0)
          {
            v21 = 806746239;
            break;
          }
          v22 = 12309;
          goto LABEL_157;
        default:
          if (v20 != 126)
            goto LABEL_46;
          if ((a1 & 0x200) == 0)
          {
            v21 = -16123777;
            break;
          }
          v22 = -247;
          goto LABEL_157;
      }
LABEL_92:
      v12 += 2;
      if (!a5)
        goto LABEL_160;
      if (v12 <= a5)
      {
        HIDWORD(v37) = v21;
        LODWORD(v37) = v21;
        *(_DWORD *)a4 = v37 >> 16;
        a4 += 2;
        goto LABEL_160;
      }
      return v13;
    }
    if (a2[1] <= 0xCAu)
    {
      if (v20 == 195)
      {
        if ((a1 & 0x200) == 0)
        {
          v21 = 540997756;
          goto LABEL_92;
        }
        v22 = 8254;
        goto LABEL_157;
      }
      if (v20 == 197)
      {
        if ((a1 & 0x200) == 0)
        {
          v21 = -12584836;
          goto LABEL_92;
        }
LABEL_138:
        v22 = -193;
        goto LABEL_157;
      }
    }
    else
    {
      switch(v20)
      {
        case 0xCBu:
          if ((a1 & 0x200) == 0)
          {
            v21 = -28575620;
            goto LABEL_92;
          }
          v22 = -437;
          goto LABEL_157;
        case 0xF2u:
          v22 = 8853;
          goto LABEL_157;
        case 0xFEu:
          if ((a1 & 0x200) == 0)
          {
            v21 = -15730561;
            goto LABEL_92;
          }
          v22 = -241;
LABEL_157:
          if (a5)
            *a4++ = v22;
          goto LABEL_159;
      }
    }
LABEL_46:
    v23 = v20 | (v17 << 8);
    if ((unsigned __int16)(v23 + 1566) < 0xA75Eu)
      return v13;
    v24 = (unsigned __int16 *)&__CFFromBig5CharMap;
    v25 = (unsigned __int16 *)((char *)&__CFFromBig5CharMap + 28248);
    while (1)
    {
      v26 = (0xF83E0F83E0F83E1 * (v25 - v24)) >> 1;
      v27 = &v24[33 * v26];
      v28 = *v27;
      if (v28 <= v23)
      {
        if (v28 + 32 > v23)
        {
          v29 = v24[33 * v26 + 1 + (int)(v23 - v28)];
          if (v29)
            v30 = v29 == 65533;
          else
            v30 = 1;
          if (v30)
            return v13;
          if (v14 != 64
            || (v39 = v15,
                IsDecomposableCharacter_1 = __CFStringEncodingIsDecomposableCharacter_1(),
                v15 = v39,
                v14 = 64,
                !IsDecomposableCharacter_1))
          {
            if (a5)
              *a4++ = v29;
            v12 = *a6;
LABEL_159:
            ++v12;
LABEL_160:
            v18 = 2;
LABEL_15:
            *a6 = v12;
            goto LABEL_16;
          }
          v32 = __CFStringEncodingDecomposeCharacter_1(a1, v29, v40, 4279957629, 327680, 4282382460, 4278777983, &jpt_182BE7EC0);
          v33 = *a6;
          v12 = *a6 + v32;
          *a6 = v12;
          if (!a5)
            goto LABEL_149;
          if (v12 > a5)
          {
            *a6 = v33;
            return v13;
          }
          if (v32 < 1)
          {
LABEL_149:
            v18 = 2;
            v14 = 64;
            v15 = v39;
            goto LABEL_16;
          }
          v34 = v32 + 1;
          v35 = (__int16 *)v40;
          v14 = 64;
          v15 = v39;
          do
          {
            v36 = *v35++;
            *a4++ = v36;
            --v34;
          }
          while (v34 > 1);
          v18 = 2;
LABEL_16:
          v13 += v18;
          a2 += v18;
          v19 = (uint64_t)v9 <= v18;
          v9 -= v18;
          if (v19)
            return v13;
          goto LABEL_5;
        }
        v24 = v27 + 33;
      }
      else
      {
        v25 = v27 - 33;
      }
      if (v24 > v25)
        return v13;
    }
  }
  v12 += v15;
  if (!a5)
  {
LABEL_14:
    v18 = 1;
    goto LABEL_15;
  }
  if (v12 <= a5)
  {
    *a4 = 92;
    if ((a1 & 0x200) != 0)
    {
      ++a4;
    }
    else
    {
      a4[1] = -1921;
      a4 += 2;
    }
    goto LABEL_14;
  }
  return v13;
}

uint64_t __CFFromMacTraditionalChineseLen(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  uint64_t result;
  BOOL v4;
  BOOL v5;
  int v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;

  if (a3 < 1)
    return 0;
  result = 0;
  do
  {
    if ((*a2 & 0x80) != 0
      && (*a2 - 129 <= 0x1F ? (v4 = ((1 << (*a2 + 127)) & 0x80000003) == 0) : (v4 = 1),
          v4 ? (v5 = (unint64_t)a3 >= 2) : (v5 = 0),
          v5 && *a2 < 0xFDu))
    {
      v6 = *a2;
      v7 = a3 - 1;
      if (v6 == 128)
        v8 = a2 + 1;
      else
        v8 = a2 + 2;
      if (v6 == 128)
      {
        v9 = result + 1;
      }
      else
      {
        v7 = a3 - 2;
        v9 = result;
      }
      if (v6 == 161)
        a2 += 2;
      else
        a2 = v8;
      if (v6 == 161)
        a3 -= 2;
      else
        a3 = v7;
      if (v6 == 161)
        ++result;
      else
        result = v9;
    }
    else
    {
      ++a2;
      --a3;
    }
    ++result;
  }
  while (a3 > 0);
  return result;
}

uint64_t CFUniCharPrecomposeCharacter(unsigned int a1, unsigned int a2)
{
  unsigned int *v2;
  unsigned int *v3;
  uint64_t v4;
  unsigned int *v5;
  uint64_t result;
  unsigned int v7;
  uint64_t v8;
  char *v9;
  unsigned __int16 *v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned int v13;
  char *v14;
  char *v15;
  uint64_t v16;
  char *v17;

  if (a2 - 71985 < 0xFFFEE9CF)
    return 65533;
  v2 = (unsigned int *)&__CFUniCharPrecompSourceTable;
  v3 = (unsigned int *)&unk_182C49C08;
  while (1)
  {
    v4 = ((char *)v3 - (char *)v2) >> 4;
    v5 = &v2[2 * v4];
    if (*v5 <= a2)
      break;
    v3 = v5 - 2;
LABEL_7:
    if (v2 > v3)
      return 65533;
  }
  if (*v5 < a2)
  {
    v2 = v5 + 2;
    goto LABEL_7;
  }
  v7 = v2[2 * v4 + 1];
  if (!v7)
    return 65533;
  v8 = (unsigned __int16)v2[2 * v4 + 1];
  if ((v7 & 0x80000000) != 0)
  {
    v14 = (char *)&__CFUniCharNonBMPPrecompDestinationTable + 4 * v8;
    if (*(_DWORD *)v14 > a1)
      return 65533;
    v15 = &v14[8 * (HIWORD(v7) & 0x7FFF) - 8];
    if (*(_DWORD *)v15 < a1)
      return 65533;
    while (1)
    {
      v16 = (v15 - v14) >> 4;
      v17 = &v14[8 * v16];
      if (*(_DWORD *)v17 <= a1)
      {
        if (*(_DWORD *)v17 >= a1)
        {
          result = *(unsigned int *)&v14[8 * v16 + 4];
LABEL_30:
          if (!(_DWORD)result)
            return 65533;
          return result;
        }
        v14 = v17 + 8;
      }
      else
      {
        v15 = v17 - 8;
      }
      if (v14 > v15)
        return 65533;
    }
  }
  v9 = (char *)&__CFUniCharBMPPrecompDestinationTable + 4 * v8;
  if (*(unsigned __int16 *)v9 <= (unsigned __int16)a1)
  {
    v10 = (unsigned __int16 *)&v9[4 * HIWORD(v7) - 4];
    if (*v10 >= (unsigned __int16)a1)
    {
      do
      {
        v11 = ((char *)v10 - v9) >> 3;
        v12 = (unsigned __int16 *)&v9[4 * v11];
        v13 = *v12;
        if (v13 <= (unsigned __int16)a1)
        {
          if (v13 >= (unsigned __int16)a1)
          {
            result = *(unsigned __int16 *)&v9[4 * v11 + 2];
            goto LABEL_30;
          }
          v9 = (char *)(v12 + 2);
        }
        else
        {
          v10 = v12 - 2;
        }
      }
      while (v9 <= (char *)v10);
    }
  }
  return 65533;
}

uint64_t CFUniCharPrecompose(unsigned __int16 *a1, uint64_t a2, _QWORD *a3, char *a4, uint64_t a5, _QWORD *a6)
{
  _QWORD *v6;
  _QWORD *v7;
  unsigned int v9;
  unsigned int v10;
  int v11;
  char *v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  unsigned __int8 *BitmapPtrForPlane;
  unsigned __int8 UnicodeProperty;
  int v20;
  int v21;
  int v22;
  BOOL v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unsigned int v30;
  unsigned __int16 *v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t result;
  char v47;
  char *v49;
  uint64_t v50;

  v6 = a6;
  v7 = a3;
  if (a2 < 1)
  {
    v28 = 0;
    v13 = a2;
    if (a3)
LABEL_103:
      *v7 = a2 - v13;
    goto LABEL_104;
  }
  v9 = 0;
  v49 = a4;
  v50 = 0;
  v10 = 0;
  v47 = 1;
  v11 = 65533;
  v12 = a4;
  v13 = a2;
  while (1)
  {
    while (1)
    {
      v14 = *a1;
      if (v13 != 1 && (v14 & 0xFC00) == 0xD800)
        break;
      --v13;
      ++a1;
      if (v10)
        goto LABEL_16;
LABEL_32:
      v22 = v14 << 24;
      v25 = v14 - 4352 <= 0xFE && v13 != 0 && v22 >= -16777215 && v22 <= 335544319;
      if (v25 && (v30 = *a1 - 4449, v30 <= 0x15))
      {
        v31 = a1 + 1;
        if ((unint64_t)v13 < 2)
        {
          v13 = 0;
          v33 = 0;
        }
        else
        {
          v32 = *v31 - 4519;
          if ((v32 << 16) <= 0x1C0000)
            v13 -= 2;
          else
            --v13;
          if ((v32 << 16) > 0x1C0000)
          {
            v33 = 0;
          }
          else
          {
            v31 = a1 + 2;
            v33 = v32;
          }
        }
        v26 = 28 * ((__int16)v30 + 21 * (char)v14) + v33 + 44032;
        a1 = v31;
      }
      else
      {
        v26 = v14;
      }
      if (v11 == 65533)
      {
        v27 = v50;
      }
      else if ((v47 & 1) != 0)
      {
        if (v10 < 0x10000)
        {
          v27 = v50;
        }
        else
        {
          v27 = v50 - 1;
          memmove(v49 + 2, v49 + 4, v12 - (v49 + 4));
        }
        *(_WORD *)v49 = v11;
      }
      else
      {
        if (HIWORD(v10))
        {
          v27 = v50;
        }
        else
        {
          if (v50 >= a5)
          {
            v21 = v11;
            ++v50;
            v14 = v26;
LABEL_90:
            v7 = a3;
            v6 = a6;
            goto LABEL_91;
          }
          v34 = v12 - v49 - 2;
          if (v34 >= 1)
          {
            v35 = (unint64_t)v34 >> 1;
            do
            {
              *(_WORD *)&v49[2 * v35 + 2] = *(_WORD *)&v49[2 * v35];
              v36 = v35-- + 1;
            }
            while (v36 > 2);
          }
          v27 = v50 + 1;
        }
        *(_WORD *)v49 = ((v11 + 67043328) >> 10) - 10240;
        *((_WORD *)v49 + 1) = v11 & 0x3FF | 0xDC00;
      }
      v14 = v26 - 0x10000;
      if (v26 < 0x10000)
      {
        v28 = v27 + 1;
        if (v27 >= a5)
        {
LABEL_84:
          v7 = a3;
          v6 = a6;
          if (a3)
            goto LABEL_103;
          goto LABEL_104;
        }
        v9 = 0;
        *(_WORD *)v12 = v26;
        v29 = v12 + 2;
        v47 = 1;
        v11 = 65533;
        v14 = v26;
      }
      else
      {
        v28 = v27 + 2;
        if (v27 + 2 > a5)
          goto LABEL_84;
        v9 = 0;
        v47 = 0;
        *(_WORD *)v12 = (v14 >> 10) - 10240;
        v29 = v12 + 4;
        *((_WORD *)v12 + 1) = v26 & 0x3FF | 0xDC00;
        v11 = 65533;
      }
      v10 = v26;
      v49 = v12;
LABEL_78:
      v50 = v28;
      v12 = v29;
      if (v13 <= 0)
        goto LABEL_87;
    }
    v15 = a1[1];
    v16 = v15 & 0xFC00;
    v17 = v15 + (v14 << 10) - 56613888;
    if (v16 == 56320)
      v13 -= 2;
    else
      --v13;
    if (v16 == 56320)
      a1 += 2;
    else
      ++a1;
    if (v16 == 56320)
      v14 = v17;
    if (!v10)
      goto LABEL_32;
LABEL_16:
    BitmapPtrForPlane = (unsigned __int8 *)&__CFUniCharNonBaseCharacterSetBitmapPlane0_0;
    if (v14 >= 0x10000)
    {
      BitmapPtrForPlane = (unsigned __int8 *)CFUniCharGetBitmapPtrForPlane(8u, BYTE2(v14));
      if (!BitmapPtrForPlane)
        goto LABEL_32;
    }
    if (((BitmapPtrForPlane[(unsigned __int16)v14 >> 3] >> (v14 & 7)) & 1) == 0)
      goto LABEL_32;
    if (v11 != 65533)
      v10 = v11;
    if (v14 < 0x10000)
    {
      if (__CFUniCharCombiningPriorityTablePlane0_1[(unint64_t)v14 >> 8])
      {
        UnicodeProperty = __CFUniCharCombiningPriorityTablePlane0_1[256
                                                                  * __CFUniCharCombiningPriorityTablePlane0_1[(unint64_t)v14 >> 8]
                                                                  + v14];
        if (!v9)
          goto LABEL_29;
      }
      else
      {
        UnicodeProperty = 0;
        if (!v9)
          goto LABEL_29;
      }
    }
    else
    {
      UnicodeProperty = CFUniCharGetUnicodeProperty(v14, 0);
      if (!v9)
        goto LABEL_29;
    }
    if (UnicodeProperty <= v9)
      goto LABEL_49;
LABEL_29:
    v20 = CFUniCharPrecomposeCharacter(v10, v14);
    if (v20 == 65533)
      break;
    v21 = v20;
    v11 = v20;
    if (v13 < 1)
      goto LABEL_90;
  }
  v9 = UnicodeProperty;
LABEL_49:
  if (v14 >= 0x10000)
  {
    v28 = v50 + 2;
    if (v50 + 2 > a5)
      goto LABEL_86;
    *(_WORD *)v12 = ((v14 - 0x10000) >> 10) - 10240;
    v29 = v12 + 4;
    *((_WORD *)v12 + 1) = v14 & 0x3FF | 0xDC00;
    v14 -= 0x10000;
    goto LABEL_78;
  }
  v28 = v50 + 1;
  if (v50 < a5)
  {
    *(_WORD *)v12 = v14;
    v29 = v12 + 2;
    goto LABEL_78;
  }
LABEL_86:
  v29 = v12;
LABEL_87:
  v12 = v29;
  v21 = v11;
  v50 = v28;
  v7 = a3;
  v6 = a6;
  if (v11 == 65533)
  {
LABEL_102:
    if (!v7)
      goto LABEL_104;
    goto LABEL_103;
  }
LABEL_91:
  if (v14 < 0x10000)
  {
    if (v10 < 0x10000)
    {
      v41 = v50;
    }
    else
    {
      v41 = v50 - 1;
      memmove(v49 + 2, v49 + 4, v12 - (v49 + 4));
    }
    *(_WORD *)v49 = v21;
    v28 = v41;
    if (v7)
      goto LABEL_103;
LABEL_104:
    v42 = 1;
    result = 1;
    if (v6)
    {
LABEL_105:
      *v6 = v28;
      return v42;
    }
    return result;
  }
  if (HIWORD(v10))
  {
    v40 = v50;
LABEL_101:
    *(_WORD *)v49 = ((v21 + 67043328) >> 10) - 10240;
    *((_WORD *)v49 + 1) = v21 & 0x3FF | 0xDC00;
    v28 = v40;
    goto LABEL_102;
  }
  v28 = v50 + 1;
  if (v50 < a5)
  {
    v37 = v12 - v49 - 2;
    if (v37 >= 1)
    {
      v38 = (unint64_t)v37 >> 1;
      do
      {
        *(_WORD *)&v49[2 * v38 + 2] = *(_WORD *)&v49[2 * v38];
        v39 = v38-- + 1;
      }
      while (v39 > 2);
    }
    v40 = v50 + 1;
    goto LABEL_101;
  }
  if (v7)
    *v7 = a2 - v13;
  v42 = 0;
  result = 0;
  if (v6)
    goto LABEL_105;
  return result;
}

void __CFUserNotificationDeallocate(uint64_t a1)
{
  unint64_t *v2;
  __CFMachPort *v3;
  mach_port_name_t v4;
  const void *v5;
  const void *v6;

  v2 = (unint64_t *)(a1 + 64);
  do
    v3 = (__CFMachPort *)__ldaxr(v2);
  while (__stlxr(0, v2));
  if (v3)
  {
    CFMachPortInvalidate(v3);
    CFRelease(v3);
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    if (v4)
      mach_port_mod_refs(*MEMORY[0x1E0C83DA0], v4, 1u, -1);
  }
  v5 = *(const void **)(a1 + 48);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 56);
  if (v6)
    CFRelease(v6);
}

__CFString *__CFUserNotificationCopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;

  v2 = CFGetAllocator(a1);
  Mutable = CFStringCreateMutable(v2, 0);
  CFStringAppendFormat(Mutable, 0, CFSTR("<CFUserNotification %p>"), a1);
  return Mutable;
}

CFTypeID CFUserNotificationGetTypeID(void)
{
  return 54;
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  pid_t v10;
  int v11;
  const __CFString *Value;
  const __CFAllocator *v13;
  int v14;
  ipc_space_t *v15;
  SInt32 v16;
  BOOL v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t Instance;
  __CFUserNotification *v26;
  mach_port_name_t name;
  mach_port_options_t options;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  v10 = getpid();
  v11 = (unsigned __int16)_getNextToken_tokenCounter++;
  if (dictionary)
    Value = (const __CFString *)CFDictionaryGetValue(dictionary, CFSTR("SessionID"));
  else
    Value = 0;
  name = 0;
  if (!allocator)
  {
    v13 = (const __CFAllocator *)_CFGetTSD(1u);
    if (v13)
      allocator = v13;
    else
      allocator = (CFAllocatorRef)&__kCFAllocatorSystemDefault;
  }
  v14 = v11 | (v10 << 16);
  options.reserved[1] = 0;
  *(_OWORD *)&options.flags = xmmword_182DB14A0;
  v15 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  v16 = mach_port_construct(*MEMORY[0x1E0C83DA0], &options, 0, &name);
  if (v16)
    v17 = 1;
  else
    v17 = name == 0;
  if (!v17)
    v16 = _CFUserNotificationSendRequest(allocator, Value, name, v14, flags, dictionary, timeout);
  if (v16)
  {
    if (dictionary)
    {
      v18 = (unsigned __int16)CFDictionaryGetValue(dictionary, CFSTR("AlertHeader"));
      CFDictionaryGetValue(dictionary, CFSTR("AlertMessage"));
      CFLog(3, (uint64_t)CFSTR("%@:  %@"), v19, v20, v21, v22, v23, v24, v18);
    }
  }
  else
  {
    Instance = _CFRuntimeCreateInstance((__objc2_class **)allocator, 0x36uLL, 64, 0);
    if (Instance)
    {
      v26 = (__CFUserNotification *)Instance;
      *(_DWORD *)(Instance + 16) = name;
      *(_DWORD *)(Instance + 20) = v14;
      *(CFTimeInterval *)(Instance + 24) = timeout;
      *(_QWORD *)(Instance + 32) = flags;
      if (Value)
      {
        v16 = 0;
        *(_QWORD *)(Instance + 48) = CFStringCreateCopy(allocator, Value);
        if (!error)
          return v26;
      }
      else
      {
        v16 = 0;
        if (!error)
          return v26;
      }
      goto LABEL_28;
    }
    v16 = 49164;
  }
  if (name)
    mach_port_mod_refs(*v15, name, 1u, -1);
  v26 = 0;
  if (error)
LABEL_28:
    *error = v16;
  return v26;
}

uint64_t _CFUserNotificationSendRequest(const __CFAllocator *a1, const __CFString *a2, int a3, int a4, int a5, const __CFDictionary *a6, double a7)
{
  int v14;
  uint64_t v15;
  BOOL v16;
  const void *v17;
  CFMutableDictionaryRef Mutable;
  CFNumberRef v19;
  CFNumberRef v20;
  const __CFURL *Value;
  const __CFURL *v22;
  CFTypeID v23;
  const __CFURL *v24;
  CFStringRef v25;
  const __CFURL *v26;
  const __CFURL *v27;
  CFTypeID v28;
  const __CFURL *v29;
  CFStringRef v30;
  const __CFURL *v31;
  const __CFURL *v32;
  CFTypeID v33;
  const __CFURL *v34;
  CFStringRef v35;
  const __CFURL *v36;
  const __CFURL *v37;
  CFTypeID v38;
  const __CFURL *v39;
  CFStringRef v40;
  const __CFData *Data;
  const __CFData *v42;
  int *Typed;
  int v44;
  int v45;
  CFIndex usedBufLen;
  int v48;
  mach_port_t special_port;
  int valuePtr;
  UInt8 buffer[23];
  char v52;
  uint64_t v53;
  CFRange v54;
  CFRange v55;

  v53 = *MEMORY[0x1E0C80C00];
  v48 = 0;
  special_port = 0;
  if (a7 >= 2147483650.0 || a7 <= 0.0)
    v14 = 0;
  else
    v14 = (int)a7;
  usedBufLen = 0;
  __strlcpy_chk();
  if (a2)
  {
    v54.length = CFStringGetLength(a2);
    v54.location = 0;
    CFStringGetBytes(a2, v54, 0x8000100u, 0, 0, buffer, 24, &usedBufLen);
    v52 = 0;
    __strlcat_chk();
    __strlcat_chk();
  }
  v15 = task_get_special_port(*MEMORY[0x1E0C83DA0], 4, &special_port);
  if ((_DWORD)v15)
    v16 = 1;
  else
    v16 = special_port == 0;
  if (!v16)
  {
    v15 = bootstrap_look_up2();
    if (!(_DWORD)v15)
    {
      if (v48)
      {
        v17 = (const void *)_CFProcessNameString();
        valuePtr = v14;
        *(_DWORD *)buffer = a4;
        Mutable = CFDictionaryCreateMutable(a1, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        v19 = CFNumberCreate(a1, kCFNumberSInt32Type, buffer);
        v20 = CFNumberCreate(a1, kCFNumberSInt32Type, &valuePtr);
        if (a6)
          CFDictionaryApplyFunction(a6, (CFDictionaryApplierFunction)_CFUserNotificationAddToDictionary, Mutable);
        if (v17)
          CFDictionaryAddValue(Mutable, CFSTR("AlertSource"), v17);
        if (v19)
        {
          CFDictionaryAddValue(Mutable, CFSTR("Token"), v19);
          CFRelease(v19);
        }
        if (v20)
        {
          CFDictionaryAddValue(Mutable, CFSTR("Timeout"), v20);
          CFRelease(v20);
        }
        Value = (const __CFURL *)CFDictionaryGetValue(Mutable, CFSTR("IconURL"));
        if (Value)
        {
          v22 = Value;
          v23 = CFGetTypeID(Value);
          if (v23 == CFURLGetTypeID())
          {
            v24 = CFURLCopyAbsoluteURL(v22);
            CFDictionaryRemoveValue(Mutable, CFSTR("IconURL"));
            v25 = CFURLCopyFileSystemPath(v24, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, CFSTR("IconPath"), v25);
            CFRelease(v24);
            CFRelease(v25);
          }
        }
        v26 = (const __CFURL *)CFDictionaryGetValue(Mutable, CFSTR("SoundURL"));
        if (v26)
        {
          v27 = v26;
          v28 = CFGetTypeID(v26);
          if (v28 == CFURLGetTypeID())
          {
            v29 = CFURLCopyAbsoluteURL(v27);
            CFDictionaryRemoveValue(Mutable, CFSTR("SoundURL"));
            v30 = CFURLCopyFileSystemPath(v29, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, CFSTR("SoundPath"), v30);
            CFRelease(v29);
            CFRelease(v30);
          }
        }
        v31 = (const __CFURL *)CFDictionaryGetValue(Mutable, CFSTR("LocalizationURL"));
        if (v31)
        {
          v32 = v31;
          v33 = CFGetTypeID(v31);
          if (v33 == CFURLGetTypeID())
          {
            v34 = CFURLCopyAbsoluteURL(v32);
            CFDictionaryRemoveValue(Mutable, CFSTR("LocalizationURL"));
            v35 = CFURLCopyFileSystemPath(v34, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, CFSTR("LocalizationPath"), v35);
            CFRelease(v34);
            CFRelease(v35);
          }
        }
        v36 = (const __CFURL *)CFDictionaryGetValue(Mutable, CFSTR("HelpBundleURL"));
        if (v36)
        {
          v37 = v36;
          v38 = CFGetTypeID(v36);
          if (v38 == CFURLGetTypeID())
          {
            v39 = CFURLCopyAbsoluteURL(v37);
            CFDictionaryRemoveValue(Mutable, CFSTR("HelpBundleURL"));
            v40 = CFURLCopyFileSystemPath(v39, kCFURLPOSIXPathStyle);
            CFDictionaryAddValue(Mutable, CFSTR("HelpBundlePath"), v40);
            CFRelease(v39);
            CFRelease(v40);
          }
        }
        if (Mutable)
        {
          Data = CFPropertyListCreateData(a1, Mutable, kCFPropertyListXMLFormat_v1_0, 0, 0);
          if (Data)
          {
            v42 = Data;
            usedBufLen = ((CFDataGetLength(Data) + 3) & 0xFFFFFFFFFFFFFFFCLL) + 28;
            Typed = (int *)CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, usedBufLen, 2858208393, 0);
            if (__CFOASafe)
              __CFSetLastAllocationEventName();
            if (Typed)
            {
              bzero(Typed, usedBufLen);
              if (a3)
                v44 = 5395;
              else
                v44 = 19;
              *Typed = v44;
              v45 = v48;
              Typed[1] = usedBufLen;
              Typed[2] = v45;
              Typed[3] = a3;
              Typed[5] = a5;
              Typed[6] = 0;
              v55.length = CFDataGetLength(v42);
              v55.location = 0;
              CFDataGetBytes(v42, v55, (UInt8 *)Typed + 28);
              v15 = mach_msg((mach_msg_header_t *)Typed, 17, usedBufLen, 0, 0, 0x64u, 0);
              CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, Typed);
            }
            else
            {
              v15 = 49164;
            }
            CFRelease(v42);
          }
          else
          {
            v15 = 49164;
          }
          CFRelease(Mutable);
        }
        else
        {
          return 49164;
        }
      }
    }
  }
  return v15;
}

SInt32 CFUserNotificationReceiveResponse(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags *responseFlags)
{
  unint64_t v6;
  unsigned int v7;
  uint64_t Typed;
  mach_msg_option_t v9;
  mach_msg_timeout_t v10;
  mach_msg_return_t v11;
  uint64_t v12;
  const __CFData *v13;
  const __CFData *v14;
  unint64_t *v15;
  __CFMachPort *v16;

  if (userNotification)
  {
    v6 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v6 != 54)
      _CFAssertMismatchedTypeID(0x36uLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (timeout <= 0.0 || timeout * 1000.0 >= 2147483650.0)
  {
    v7 = 0;
    if (!userNotification)
      return 0;
  }
  else
  {
    v7 = (timeout * 1000.0);
    if (!userNotification)
      return 0;
  }
  if (!*((_DWORD *)userNotification + 4))
    return 0;
  Typed = CFAllocatorAllocateTyped(&__kCFAllocatorSystemDefault, 0x4000, 4098098314, 0);
  if (__CFOASafe)
    __CFSetLastAllocationEventName();
  if (!Typed)
    return 49164;
  bzero((void *)Typed, 0x4000uLL);
  *(_DWORD *)(Typed + 4) = 0x4000;
  if (v7)
  {
    v9 = 258;
    v10 = v7;
  }
  else
  {
    v9 = 2;
    v10 = 0;
  }
  v11 = mach_msg((mach_msg_header_t *)Typed, v9, 0, 0x4000u, *((_DWORD *)userNotification + 4), v10, 0);
  if (!v11)
  {
    if (responseFlags)
      *responseFlags = *(int *)(Typed + 20);
    v12 = *(unsigned int *)(Typed + 4);
    if (v12 >= 0x1D)
    {
      v13 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)(Typed + 28), v12 - 28);
      if (v13)
      {
        v14 = v13;
        *((_QWORD *)userNotification + 7) = CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v13, 0, 0, 0);
        CFRelease(v14);
      }
    }
    v15 = (unint64_t *)((char *)userNotification + 64);
    do
      v16 = (__CFMachPort *)__ldaxr(v15);
    while (__stlxr(0, v15));
    if (v16)
    {
      CFMachPortInvalidate(v16);
      CFRelease(v16);
    }
    mach_port_mod_refs(*MEMORY[0x1E0C83DA0], *((_DWORD *)userNotification + 4), 1u, -1);
    *((_DWORD *)userNotification + 4) = 0;
  }
  CFAllocatorDeallocate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (void *)Typed);
  return v11;
}

CFStringRef CFUserNotificationGetResponseValue(CFUserNotificationRef userNotification, CFStringRef key, CFIndex idx)
{
  unint64_t v6;
  CFStringRef result;
  const __CFString *v8;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID TypeID;

  if (userNotification)
  {
    v6 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v6 != 54)
      _CFAssertMismatchedTypeID(0x36uLL, v6);
  }
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (!userNotification)
    return 0;
  result = (CFStringRef)*((_QWORD *)userNotification + 7);
  if (result)
  {
    result = (CFStringRef)CFDictionaryGetValue((CFDictionaryRef)result, key);
    if (result)
    {
      v8 = result;
      v9 = CFGetTypeID(result);
      if (v9 == CFStringGetTypeID())
      {
        if (idx)
          return 0;
        else
          return v8;
      }
      v10 = CFGetTypeID(v8);
      TypeID = CFArrayGetTypeID();
      result = 0;
      if ((idx & 0x8000000000000000) == 0 && v10 == TypeID)
      {
        if (CFArrayGetCount((CFArrayRef)v8) > idx)
          return (CFStringRef)CFArrayGetValueAtIndex((CFArrayRef)v8, idx);
        return 0;
      }
    }
  }
  return result;
}

CFDictionaryRef CFUserNotificationGetResponseDictionary(CFUserNotificationRef userNotification)
{
  unint64_t v2;

  if (userNotification)
  {
    v2 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v2 != 54)
      _CFAssertMismatchedTypeID(0x36uLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (userNotification)
    return (CFDictionaryRef)*((_QWORD *)userNotification + 7);
  else
    return 0;
}

SInt32 CFUserNotificationUpdate(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags flags, CFDictionaryRef dictionary)
{
  int v5;
  unint64_t v8;
  const __CFAllocator *v9;

  v5 = flags;
  if (userNotification)
  {
    v8 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v8 != 54)
      _CFAssertMismatchedTypeID(0x36uLL, v8);
  }
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (!userNotification || !*((_DWORD *)userNotification + 4))
    return 0;
  v9 = CFGetAllocator(userNotification);
  return _CFUserNotificationSendRequest(v9, *((const __CFString **)userNotification + 6), 0, *((_DWORD *)userNotification + 5), v5 | 0x10u, dictionary, timeout);
}

SInt32 CFUserNotificationCancel(CFUserNotificationRef userNotification)
{
  unint64_t v2;
  const __CFAllocator *v3;

  if (userNotification)
  {
    v2 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v2 != 54)
      _CFAssertMismatchedTypeID(0x36uLL, v2);
  }
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (!userNotification || !*((_DWORD *)userNotification + 4))
    return 0;
  v3 = CFGetAllocator(userNotification);
  return _CFUserNotificationSendRequest(v3, *((const __CFString **)userNotification + 6), 0, *((_DWORD *)userNotification + 5), 8, 0, 0.0);
}

CFRunLoopSourceRef CFUserNotificationCreateRunLoopSource(CFAllocatorRef allocator, CFUserNotificationRef userNotification, CFUserNotificationCallBack callout, CFIndex order)
{
  unint64_t v8;
  const __CFAllocator *v10;
  __CFMachPort *v12;
  CFRunLoopSourceRef result;
  CFMachPortContext v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (userNotification)
  {
    v8 = _CFGetNonObjCTypeID((unint64_t *)userNotification);
    if (v8 != 54)
      _CFAssertMismatchedTypeID(0x36uLL, v8);
  }
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if (userNotification && callout)
  {
    if (!atomic_load((unint64_t *)userNotification + 8))
    {
      if (*((_DWORD *)userNotification + 4))
      {
        v14.version = 0;
        memset(&v14.retain, 0, 24);
        v14.info = userNotification;
        v10 = CFGetAllocator(userNotification);
        atomic_store((unint64_t)CFMachPortCreateWithPort(v10, *((_DWORD *)userNotification + 4), (CFMachPortCallBack)_CFUserNotificationMachPortCallBack, &v14, 0), (unint64_t *)userNotification + 8);
      }
    }
  }
  else if (!userNotification)
  {
    return 0;
  }
  if (atomic_load((unint64_t *)userNotification + 8))
  {
    v12 = (__CFMachPort *)atomic_load((unint64_t *)userNotification + 8);
    result = CFMachPortCreateRunLoopSource(allocator, v12, order);
    *((_QWORD *)userNotification + 9) = callout;
    return result;
  }
  return 0;
}

uint64_t _CFUserNotificationMachPortCallBack(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  const __CFData *v7;
  const __CFData *v8;
  unint64_t *v9;
  __CFMachPort *v10;

  v5 = *(int *)(a2 + 20);
  v6 = *(unsigned int *)(a2 + 4);
  if (v6 >= 0x1D)
  {
    v7 = CFDataCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)(a2 + 28), v6 - 28);
    if (v7)
    {
      v8 = v7;
      *(_QWORD *)(a4 + 56) = CFPropertyListCreateWithData((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7, 0, 0, 0);
      CFRelease(v8);
    }
  }
  v9 = (unint64_t *)(a4 + 64);
  do
    v10 = (__CFMachPort *)__ldaxr(v9);
  while (__stlxr(0, v9));
  if (v10)
  {
    CFMachPortInvalidate(v10);
    CFRelease(v10);
  }
  mach_port_mod_refs(*MEMORY[0x1E0C83DA0], *(_DWORD *)(a4 + 16), 1u, -1);
  *(_DWORD *)(a4 + 16) = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 72))(a4, v5);
}

SInt32 CFUserNotificationDisplayNotice(CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle)
{
  int v14;
  __CFDictionary *Mutable;
  __CFDictionary *v17;
  uint64_t v18;
  const __CFAllocator *v19;
  pid_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  SInt32 v28;

  v14 = flags;
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v17 = Mutable;
  if (iconURL)
    CFDictionaryAddValue(Mutable, CFSTR("IconURL"), iconURL);
  if (soundURL)
    CFDictionaryAddValue(v17, CFSTR("SoundURL"), soundURL);
  if (localizationURL)
    CFDictionaryAddValue(v17, CFSTR("LocalizationURL"), localizationURL);
  if (alertHeader)
    CFDictionaryAddValue(v17, CFSTR("AlertHeader"), alertHeader);
  if (alertMessage)
    CFDictionaryAddValue(v17, CFSTR("AlertMessage"), alertMessage);
  if (defaultButtonTitle)
    CFDictionaryAddValue(v17, CFSTR("DefaultButtonTitle"), defaultButtonTitle);
  v18 = _CFGetTSD(1u);
  if (v18)
    v19 = (const __CFAllocator *)v18;
  else
    v19 = (const __CFAllocator *)&__kCFAllocatorSystemDefault;
  v20 = getpid();
  v21 = (unsigned __int16)_getNextToken_tokenCounter++;
  v28 = _CFUserNotificationSendRequest(v19, 0, 0, v21 | (v20 << 16), v14, v17, timeout);
  if (v28)
    CFLog(3, (uint64_t)CFSTR("%@:  %@"), v22, v23, v24, v25, v26, v27, (__int16)alertHeader);
  CFRelease(v17);
  return v28;
}

uint64_t _CFUserNotificationSetWarningThread(uint64_t result)
{
  __CFUserNotificationWarningThread = result;
  return result;
}

SInt32 CFUserNotificationDisplayAlert(CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle, CFStringRef alternateButtonTitle, CFStringRef otherButtonTitle, CFOptionFlags *responseFlags)
{
  __CFDictionary *Mutable;
  __CFDictionary *v21;
  CFUserNotificationRef v22;
  __CFUserNotification *v23;
  _opaque_pthread_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  SInt32 error;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  error = 0;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v21 = Mutable;
  if (iconURL)
    CFDictionaryAddValue(Mutable, CFSTR("IconURL"), iconURL);
  if (soundURL)
    CFDictionaryAddValue(v21, CFSTR("SoundURL"), soundURL);
  if (localizationURL)
    CFDictionaryAddValue(v21, CFSTR("LocalizationURL"), localizationURL);
  if (alertHeader)
    CFDictionaryAddValue(v21, CFSTR("AlertHeader"), alertHeader);
  if (alertMessage)
    CFDictionaryAddValue(v21, CFSTR("AlertMessage"), alertMessage);
  if (defaultButtonTitle)
    CFDictionaryAddValue(v21, CFSTR("DefaultButtonTitle"), defaultButtonTitle);
  if (alternateButtonTitle)
    CFDictionaryAddValue(v21, CFSTR("AlternateButtonTitle"), alternateButtonTitle);
  if (otherButtonTitle)
    CFDictionaryAddValue(v21, CFSTR("OtherButtonTitle"), otherButtonTitle);
  v22 = CFUserNotificationCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, timeout, flags, &error, v21);
  if (v22)
  {
    v23 = v22;
    v24 = pthread_self();
    if (pthread_equal(v24, (pthread_t)__CFUserNotificationWarningThread))
      CFLog(3, (uint64_t)CFSTR("%@:  %@"), v25, v26, v27, v28, v29, v30, (__int16)CFSTR("CFUserNotificationDisplayAlert"));
    error = CFUserNotificationReceiveResponse(v23, timeout, responseFlags);
    if (error == 268451843)
    {
      error = CFUserNotificationCancel(v23);
      if (responseFlags)
        *responseFlags = 3;
    }
    CFRelease(v23);
  }
  CFRelease(v21);
  return error;
}

void _CFUserNotificationAddToDictionary(const void *a1, const void *a2, __CFDictionary *a3)
{
  CFTypeID v6;

  v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
    CFDictionarySetValue(a3, a1, a2);
}

uint64_t _CFMethodSignatureROMLog()
{
  if (_CFMethodSignatureROMLog_onceToken != -1)
    dispatch_once(&_CFMethodSignatureROMLog_onceToken, &__block_literal_global_4);
  return _CFMethodSignatureROMLog_logger;
}

uint64_t _CFRuntimeIssuesLog()
{
  if (_CFRuntimeIssuesLog_onceToken != -1)
    dispatch_once(&_CFRuntimeIssuesLog_onceToken, &__block_literal_global_7);
  return _CFRuntimeIssuesLog_logger;
}

uint64_t _CFFoundationRuntimeIssuesLog()
{
  if (_CFFoundationRuntimeIssuesLog_onceToken != -1)
    dispatch_once(&_CFFoundationRuntimeIssuesLog_onceToken, &__block_literal_global_11_1);
  return _CFFoundationRuntimeIssuesLog_logger;
}

uint64_t CFBSearch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, unint64_t, uint64_t), uint64_t a6)
{
  uint64_t v8;
  unint64_t v11;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v8 = a3;
  if (a4 >= 1)
  {
    v11 = a4;
    v8 = a3;
    while (1)
    {
      v13 = v11 >> 1;
      v14 = a5(a1, v8 + (v11 >> 1) * a2, a6);
      if (!v14)
        break;
      if (v14 < 0)
      {
        v15 = 0;
      }
      else
      {
        v8 += (v11 >> 1) * a2 + a2;
        v15 = (v11 & 1) - 1;
      }
      v11 = v13 + v15;
      if (((uint64_t)(v13 + v15) < 0) ^ __OFADD__(v13, v15) | (v13 + v15 == 0))
        return (v8 - a3) / a2;
    }
    v8 += (v11 >> 1) * a2;
  }
  return (v8 - a3) / a2;
}

mach_vm_address_t __CFFindPointer(uint64_t a1, mach_vm_address_t a2)
{
  vm_map_read_t v4;
  mach_vm_address_t result;
  mach_vm_address_t v6;
  _QWORD *v7;
  mach_port_t object_name;
  mach_msg_type_number_t infoCnt;
  mach_vm_size_t size;
  mach_vm_address_t address;
  int info[4];
  __int128 i;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = *MEMORY[0x1E0C83DA0];
  size = 0;
  address = a2;
  v14 = 0;
  *(_OWORD *)info = 0u;
  for (i = 0u; ; i = 0u)
  {
    object_name = 0;
    infoCnt = 9;
    if (mach_vm_region(v4, &address, &size, 9, info, &infoCnt, &object_name))
      return 0;
    result = address;
    if ((info[0] & 2) == 0)
    {
      v6 = address + size;
      goto LABEL_10;
    }
    v6 = size + address;
    if (address < size + address)
      break;
LABEL_10:
    size = 0;
    address = v6;
    v14 = 0;
    *(_OWORD *)info = 0u;
  }
  v7 = (_QWORD *)address;
  while ((unint64_t)v7 < a2 || *v7 != a1)
  {
    ++v7;
    result += 8;
    if ((unint64_t)v7 >= v6)
      goto LABEL_10;
  }
  return result;
}

uint64_t __CFDumpAllPointerLocations(uint64_t a1)
{
  const void *v2;
  uint64_t result;

  v2 = 0;
  do
  {
    v2 = (const void *)__CFFindPointer(a1, (mach_vm_address_t)v2 + 8);
    result = printf("%p\n", v2);
  }
  while (v2);
  return result;
}

uint64_t __CFProcessorCount()
{
  int v0;
  int v1;
  size_t v3;
  int v4;
  int v5[2];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4 = 0;
  *(_QWORD *)v5 = 0x300000006;
  v3 = 4;
  v0 = sysctl(v5, 2u, &v4, &v3, 0, 0);
  v1 = v4;
  if (v0)
    return 0;
  return v1;
}

uint64_t __CFMemorySize()
{
  size_t v1;
  uint64_t v2;
  int v3[2];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = 0;
  *(_QWORD *)v3 = 0x1800000006;
  v1 = 8;
  if (sysctl(v3, 2u, &v2, &v1, 0, 0))
    return 0;
  else
    return v2;
}

uint64_t _CFGetEGID()
{
  unsigned int v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  __CFGetUGIDs(0, &v1);
  return v1;
}

_BYTE *_CFPrintForDebugger(void *a1)
{
  CFTypeID v2;
  const __CFString *v3;
  const __CFString *v4;
  _BYTE *result;
  CFIndex maxBufLen[2];
  CFRange v7;
  CFRange v8;

  maxBufLen[1] = *MEMORY[0x1E0C80C00];
  maxBufLen[0] = 0;
  free((void *)_CFPrintForDebugger_result);
  _CFPrintForDebugger_result = 0;
  if (a1)
  {
    v2 = CFGetTypeID(a1);
    if (v2 == CFStringGetTypeID())
    {
      v3 = (const __CFString *)__CFCopyFormattingDescription((unint64_t *)a1, 0);
      if (v3)
        goto LABEL_7;
    }
    v4 = CFCopyDescription(a1);
  }
  else
  {
    v4 = (const __CFString *)CFRetain(CFSTR("(null)"));
  }
  v3 = v4;
  if (v4)
  {
LABEL_7:
    v7.length = CFStringGetLength(v3);
    v7.location = 0;
    CFStringGetBytes(v3, v7, 0x8000100u, 0, 0, 0, 0, maxBufLen);
    _CFPrintForDebugger_result = (uint64_t)malloc_type_malloc(maxBufLen[0] + 2, 0x7A2E7CA1uLL);
    v8.length = CFStringGetLength(v3);
    v8.location = 0;
    CFStringGetBytes(v3, v8, 0x8000100u, 0, 0, (UInt8 *)_CFPrintForDebugger_result, maxBufLen[0], maxBufLen);
    *(_BYTE *)(_CFPrintForDebugger_result + maxBufLen[0]) = 0;
    CFRelease(v3);
    return (_BYTE *)_CFPrintForDebugger_result;
  }
  result = malloc_type_malloc(2uLL, 0x7A2E7CA1uLL);
  _CFPrintForDebugger_result = (uint64_t)result;
  *result = 0;
  return result;
}

void CFShow(CFTypeRef obj)
{
  _CFShowToFile((FILE *)*MEMORY[0x1E0C80C10], (void *)obj);
}

void _CFShowToFile(FILE *a1, void *cf)
{
  CFTypeID v4;
  const __CFString *v5;
  const __CFString *v6;
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v10;
  int64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  UniChar v15;
  int64_t v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int64_t v21;
  CFIndex v22;
  int v23;
  const __CFString *cfa;
  UniChar buffer[8];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  CFStringRef theString;
  const UniChar *v34;
  const char *v35;
  uint64_t v36;
  CFIndex v37;
  int64_t v38;
  int64_t v39;
  uint64_t v40;
  CFRange v41;

  v40 = *MEMORY[0x1E0C80C00];
  if (!cf)
  {
    v6 = (const __CFString *)CFRetain(CFSTR("(null)"));
    goto LABEL_6;
  }
  v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID()
    || (v5 = (const __CFString *)__CFCopyFormattingDescription((unint64_t *)cf, 0)) == 0)
  {
    v6 = CFCopyDescription(cf);
LABEL_6:
    v5 = v6;
  }
  Length = CFStringGetLength(v5);
  theString = v5;
  v36 = 0;
  v37 = Length;
  CharactersPtr = CFStringGetCharactersPtr(v5);
  CStringPtr = 0;
  v34 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(v5, 0x600u);
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  *(_OWORD *)buffer = 0u;
  v26 = 0u;
  v38 = 0;
  v39 = 0;
  v35 = CStringPtr;
  if (Length < 1)
    goto LABEL_33;
  cfa = v5;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 64;
  do
  {
    if ((unint64_t)v11 >= 4)
      v14 = 4;
    else
      v14 = v11;
    if (v34)
    {
      v15 = v34[v11 + v36];
    }
    else if (v35)
    {
      v15 = v35[v36 + v11];
    }
    else
    {
      v16 = v38;
      if (v39 <= v11 || v38 > v11)
      {
        v18 = -v14;
        v19 = v14 + v10;
        v20 = v13 - v14;
        v21 = v11 + v18;
        v22 = v21 + 64;
        if (v21 + 64 >= v37)
          v22 = v37;
        v38 = v21;
        v39 = v22;
        if (v37 < v20)
          v20 = v37;
        v41.length = v20 + v19;
        v41.location = v21 + v36;
        CFStringGetCharacters(theString, v41, buffer);
        v16 = v38;
      }
      v15 = buffer[v11 - v16];
    }
    v23 = v15;
    if (v15 > 0x7Fu)
    {
      fprintf_l(a1, 0, "\\u%04x", v15);
    }
    else
    {
      fprintf_l(a1, 0, "%c", v15);
      v12 = v23 == 10;
    }
    ++v11;
    --v10;
    ++v13;
  }
  while (Length != v11);
  v5 = cfa;
  if (!v12)
  {
LABEL_33:
    fprintf_l(a1, 0, "\n");
    fflush(a1);
  }
  if (v5)
    CFRelease(v5);
}

unint64_t _CFLogvEx2(void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int16 *a7)
{
  return _CFLogvEx2Predicate(a1, a2, a3, a4, a5, a6, a7, 1);
}

unint64_t _CFLogvEx(void (*a1)(uint64_t, char *, size_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int16 *a6)
{
  return _CFLogvEx2Predicate(a1, a2, 0, a3, a4, a5, a6, 1);
}

void _CFLogSimple(int a1, char *__format, ...)
{
  int v3;
  char __str[1024];
  uint64_t v5;
  va_list va;

  va_start(va, __format);
  v5 = *MEMORY[0x1E0C80C00];
  v3 = vsnprintf(__str, 0x400uLL, __format, va);
  if (v3 >= 1)
    __CFLogCStringLegacy(a1, __str, v3, 0);
}

void __CFLogCStringLegacy(int a1, const char *a2, uint64_t a3, int a4)
{
  const char *v7;
  __asl_object_s *v8;
  __asl_object_s *v9;
  int v10;
  char *v11;
  char *v12;
  char *value;
  char *__s[2];

  __s[1] = *(char **)MEMORY[0x1E0C80C00];
  value = 0;
  __s[0] = 0;
  v11 = 0;
  v12 = 0;
  if (a4)
    _populateBanner(__s, &value, &v11);
  v10 = 0;
  __CFGetUGIDs(&v10, 0);
  asprintf(&v12, "%d", v10);
  v7 = "com.apple.console";
  if (__CFBundleMainID && *(_BYTE *)__CFBundleMainID)
    v7 = (const char *)__CFBundleMainID;
  v8 = asl_open(0, v7, 2u);
  v9 = asl_new(0);
  asl_set(v9, "CFLog Local Time", value);
  asl_set(v9, "CFLog Thread", v11);
  asl_set(v9, "ReadUID", v12);
  asl_set(v9, "Level", __CFLogCStringLegacy_levstr[a1]);
  asl_set(v9, "Message", a2);
  asl_send(v8, v9);
  MEMORY[0x186DAF874](v9);
  MEMORY[0x186DAF868](v8);
  if (also_do_stderr(1))
    _logToStderr(__s[0], (uint64_t)a2, a3);
  if (v11)
    free(v11);
  if (value)
    free(value);
  if (__s[0])
    free(__s[0]);
  if (v12)
    free(v12);
}

void _CFLogSimpleCString(int a1, const char *a2, uint64_t a3)
{
  __CFLogCStringLegacy(a1, a2, a3, 0);
}

void CFLogTest(char a1, CFStringRef format, ...)
{
  uint64_t v3;
  __CFArray *v4;
  const __CFArray *v5;
  const __CFURL *ValueAtIndex;
  uint64_t v7;
  char *v8;
  const char *v9;
  pid_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  timeval v18;
  va_list v19;
  tm buffer[18];
  _BYTE v21[14];
  va_list va;

  va_start(va, format);
  *(_QWORD *)&v21[6] = *MEMORY[0x1E0C80C00];
  v3 = CFLogTest_file;
  if (CFLogTest_file)
    goto LABEL_14;
  if ((a1 & 1) == 0)
  {
    v4 = CFCopySearchPathForDirectoriesInDomains(5, 1, 1);
    if (!v4)
      goto LABEL_13;
    v5 = v4;
    if (CFArrayGetCount(v4) >= 1
      && (ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v5, 0),
          CFURLGetFileSystemRepresentation(ValueAtIndex, 1u, (UInt8 *)buffer, 1026)))
    {
      v7 = (uint64_t)buffer + strlen((const char *)buffer);
    }
    else
    {
      v7 = 0;
    }
    CFRelease(v5);
    if (!v7)
      goto LABEL_13;
    goto LABEL_11;
  }
  v7 = __stpcpy_chk();
  if (v7)
  {
LABEL_11:
    snprintf((char *)v7, (size_t)&v21[-v7], "/Logs");
    mkdir((const char *)buffer, 0x1FFu);
    v8 = (char *)(v7 + strlen((const char *)v7));
    v9 = (const char *)*_CFGetProgname();
    v10 = getpid();
    snprintf(v8, v21 - v8, "/%s_%d.selftest.txt", v9, v10);
    CFLogTest_file = (uint64_t)fopen((const char *)buffer, "w");
    if (!CFLogTest_file)
    {
      CFLog(3, (uint64_t)CFSTR("Couldn't write to self test log file %s"), v11, v12, v13, v14, v15, v16, (__int16)buffer);
      CFLogTest_file = -1;
    }
  }
LABEL_13:
  v3 = CFLogTest_file;
LABEL_14:
  if (v3 != -1)
  {
    va_copy(v19, va);
    v17 = (__CFString *)CFStringCreateWithFormatAndArguments((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, format, va);
    v18.tv_sec = 0;
    *(_QWORD *)&v18.tv_usec = 0;
    memset(buffer, 0, 56);
    gettimeofday(&v18, 0);
    gmtime_r(&v18.tv_sec, buffer);
    fprintf_l((FILE *)CFLogTest_file, 0, "%04d-%02d-%02d %02d:%02d:%02d ", buffer[0].tm_year + 1900, buffer[0].tm_mon + 1, buffer[0].tm_mday, buffer[0].tm_hour, buffer[0].tm_min, buffer[0].tm_sec);
    _CFShowToFile((FILE *)CFLogTest_file, v17);
    CFRelease(v17);
  }
}

uint64_t _CFReadMappedFromFile(__CFString *a1, int a2, int a3, _QWORD *a4, off_t *a5, CFErrorRef *a6)
{
  int v12;
  int v13;
  void *v14;
  void *v15;
  off_t v16;
  const __CFString *v17;
  CFIndex v18;
  CFIndex v19;
  char *v20;
  unint64_t st_size;
  char *v22;
  size_t v23;
  ssize_t v24;
  CFErrorRef v25;
  uint64_t result;
  stat v27;
  char buffer[1026];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!CFStringGetFileSystemRepresentation(a1, buffer, 1026))
  {
    if (!a6)
      return 0;
    v17 = CFSTR("NSCocoaErrorDomain");
    v18 = -1;
LABEL_33:
    v25 = _CFErrorWithFilePathCodeDomain(v17, v18, a1);
    result = 0;
    *a6 = v25;
    return result;
  }
  memset(&v27, 0, sizeof(v27));
  v12 = open(buffer, 0, 438);
  if (v12 < 0)
  {
    if (!a6)
      return 0;
    v18 = *__error();
    v17 = CFSTR("NSPOSIXErrorDomain");
    goto LABEL_33;
  }
  v13 = v12;
  if (a3)
    fcntl(v12, 48, 1);
  if (fstat(v13, &v27) < 0)
    goto LABEL_16;
  if ((v27.st_mode & 0xF000) != 0x8000)
  {
    close(v13);
    if (a6)
    {
      v17 = CFSTR("NSPOSIXErrorDomain");
      v18 = 13;
      goto LABEL_33;
    }
    return 0;
  }
  if (v27.st_size < 0)
  {
LABEL_31:
    close(v13);
    if (a6)
    {
      v17 = CFSTR("NSPOSIXErrorDomain");
      v18 = 12;
      goto LABEL_33;
    }
    return 0;
  }
  if (!v27.st_size)
  {
    v15 = malloc_type_malloc(8uLL, 0x92AD61D0uLL);
    v16 = 0;
    goto LABEL_37;
  }
  if (!a2)
  {
    v20 = (char *)malloc_type_malloc(v27.st_size, 0x7D7BD453uLL);
    if (v20)
    {
      v15 = v20;
      st_size = v27.st_size;
      if (!v27.st_size)
        goto LABEL_36;
      v22 = v20;
      while (1)
      {
        v23 = st_size >= 0x7FFFFFFF ? 0x7FFFFFFFLL : st_size;
        v24 = read(v13, v22, v23);
        if (v24 <= 0)
          break;
        v22 += v24;
        st_size -= v24;
        if (!st_size)
          goto LABEL_36;
      }
      if ((v24 & 0x8000000000000000) == 0)
      {
LABEL_36:
        v16 = v27.st_size - st_size;
        goto LABEL_37;
      }
      v19 = *__error();
      free(v15);
LABEL_17:
      close(v13);
      if (a6)
      {
        v17 = CFSTR("NSPOSIXErrorDomain");
        v18 = v19;
        goto LABEL_33;
      }
      return 0;
    }
    goto LABEL_31;
  }
  v14 = mmap(0, v27.st_size, 1, 2, v13, 0);
  if (v14 == (void *)-1)
  {
LABEL_16:
    v19 = *__error();
    goto LABEL_17;
  }
  v15 = v14;
  v16 = v27.st_size;
LABEL_37:
  close(v13);
  *a4 = v15;
  *a5 = v16;
  return 1;
}

CFErrorRef _CFErrorWithFilePathCodeDomain(const __CFString *a1, CFIndex a2, void *a3)
{
  const __CFDictionary *v5;
  CFErrorRef v6;
  void *keys;
  void *values[2];

  values[1] = *(void **)MEMORY[0x1E0C80C00];
  keys = CFSTR("NSFilePath");
  values[0] = a3;
  v5 = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&keys, (const void **)values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v6 = CFErrorCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, a1, a2, v5);
  CFRelease(v5);
  return v6;
}

uint64_t _CFSuddenTerminationDisablingCount()
{
  return 1;
}

uint64_t _CFAppVersionLessThan(CFTypeRef cf2, double a2)
{
  uint64_t result;

  if (_bundleInfo_onceToken != -1)
    dispatch_once(&_bundleInfo_onceToken, &__block_literal_global_25);
  result = CFEqual((CFTypeRef)_bundleInfo_info_0, cf2);
  if ((_DWORD)result)
    return *(double *)&_bundleInfo_info_2 < a2 || a2 < 0.0;
  return result;
}

const char *_CFGetExecutableLinkedLibraryVersion@<X0>(const char *result@<X0>, uint64_t a2@<X8>)
{
  *(_QWORD *)(a2 + 16) = 0;
  *(_OWORD *)a2 = xmmword_182DB1530;
  if (result)
  {
    result = (const char *)NSVersionOfLinkTimeLibrary(result);
    if ((_DWORD)result != -1)
    {
      *(_QWORD *)a2 = result >> 16;
      *(_QWORD *)(a2 + 8) = BYTE1(result);
      *(_QWORD *)(a2 + 16) = result;
    }
  }
  return result;
}

uint64_t _CFLibraryVersionCompare(_QWORD *a1, _QWORD *a2)
{
  _BOOL4 v2;
  _BOOL4 v3;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  BOOL v7;
  uint64_t v8;

  v2 = (*a1 & 0x8000000000000000) == 0 && (a1[1] & 0x8000000000000000) == 0 && a1[2] >= 0;
  if ((*a2 & 0x8000000000000000) != 0
    || (a2[1] & 0x8000000000000000) != 0
    || ((uint64_t)a2[2] >= 0 ? (v3 = v2) : (v3 = 0), !v3))
  {
    if (v2)
      return -1;
    else
      return 1;
  }
  else
  {
    v4 = (*a1 << 16) | (*((_DWORD *)a1 + 2) << 8) | *((unsigned __int8 *)a1 + 16);
    v5 = (*a2 << 16) | (a2[1] << 8) | a2[2];
    v6 = v4 == v5;
    v7 = v4 > v5;
    v8 = 1;
    if (!v7)
      v8 = -1;
    if (v6)
      return 0;
    else
      return v8;
  }
}

BOOL _CFLinkedOnOrAfter(__int128 *a1, uint64_t a2)
{
  _QWORD v3[3];
  __int128 v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  v5 = *((_QWORD *)a1 + 2);
  v3[1] = 0;
  v3[2] = 0;
  v3[0] = a2;
  return _CFLibraryVersionCompare(&v4, v3) != -1;
}

uint64_t _CFBundleGrokObjCImageInfoFromMainExecutable(_DWORD *a1, _DWORD *a2)
{
  uint64_t result;
  const section_64 *SectData;
  int v6;
  int v7;
  uint64_t v8[2];

  v8[1] = *MEMORY[0x1E0C80C00];
  v8[0] = 0;
  result = (uint64_t)getsegbyname("__DATA");
  if (!result)
  {
    v6 = 0;
    v7 = 0;
    goto LABEL_7;
  }
  SectData = _CFBundleGetSectData("__DATA", "__objc_imageinfo", v8);
  result = 0;
  if (SectData)
  {
    v6 = 0;
    v7 = 0;
    if (v8[0] >= 8)
    {
      v6 = *(_DWORD *)SectData->sectname;
      v7 = *(_DWORD *)&SectData->sectname[4];
      result = 1;
      if (!a1)
        goto LABEL_9;
LABEL_8:
      *a1 = v6;
      goto LABEL_9;
    }
LABEL_7:
    if (!a1)
      goto LABEL_9;
    goto LABEL_8;
  }
  v6 = 0;
  v7 = 0;
  if (a1)
    goto LABEL_8;
LABEL_9:
  if (a2)
    *a2 = v7;
  return result;
}

CFStringRef _CFBundleCopyFileTypeForFileURL(const __CFURL *a1, int32x4_t a2)
{
  CFStringRef v3[2];

  v3[1] = *(CFStringRef *)MEMORY[0x1E0C80C00];
  v3[0] = 0;
  _CFBundleGrokFileType(a1, 0, v3, 0, 0, 0, 0, 0, a2, 0);
  return v3[0];
}

CFStringRef _CFBundleCopyFileTypeForFileData(const __CFData *a1, int32x4_t a2)
{
  CFStringRef v3[2];

  v3[1] = *(CFStringRef *)MEMORY[0x1E0C80C00];
  v3[0] = 0;
  _CFBundleGrokFileType(0, a1, v3, 0, 0, 0, 0, 0, a2, 0);
  return v3[0];
}

CFMutableDictionaryRef _CFBundleCopyInfoDictionaryForExecutableFileData(const __CFData *a1, BOOL *a2, int32x4_t a3)
{
  int v5;
  CFMutableDictionaryRef v6[2];

  v6[1] = *(CFMutableDictionaryRef *)MEMORY[0x1E0C80C00];
  v6[0] = 0;
  v5 = 0;
  _CFBundleGrokFileType(0, a1, 0, &v5, 0, v6, 0, 0, a3, 0);
  if (a2)
    *a2 = (v5 & 0xFFFFFFFB) == 2;
  return v6[0];
}

const __CFArray *_CFBundleCopyArchitecturesForExecutable(const __CFURL *a1, int32x4_t a2)
{
  const __CFArray *v3[2];

  v3[1] = *(const __CFArray **)MEMORY[0x1E0C80C00];
  v3[0] = 0;
  _CFBundleGrokFileType(a1, 0, 0, 0, v3, 0, 0, 0, a2, 0);
  return v3[0];
}

uint64_t _CFBundleGetObjCImageInfo(__CFBundle *a1, _DWORD *a2, _DWORD *a3)
{
  const __CFURL *v5;
  int32x4_t v6;
  const __CFURL *v7;
  uint64_t v8;
  unsigned int v10;
  unsigned int v11;
  unsigned __int8 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v11 = 0;
  v5 = CFBundleCopyExecutableURL(a1);
  if (v5)
  {
    v7 = v5;
    v12 = 0;
    _CFBundleGrokFileType(v5, 0, 0, 0, 0, 0, (char *)&v12, &v11, v6, &v10);
    v8 = v12;
    CFRelease(v7);
    if (!a2)
      goto LABEL_4;
    goto LABEL_3;
  }
  v8 = 0;
  if (a2)
LABEL_3:
    *a2 = v11;
LABEL_4:
  if (a3)
    *a3 = v10;
  return v8;
}

const char *_CFBundleGrokFileTypeForZipFile(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  uint64_t v8;
  const char *v9;
  const char *v10;
  int v11;
  char v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  _BOOL4 v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  const char *v20;
  const char *v21;
  int v22;
  int v23;
  const char *v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  const char *v30;
  uint64_t v31;
  const char *v32;
  int v33;
  BOOL v34;
  off_t v35;
  void *v36;
  uint64_t v37;
  ssize_t v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const char *v47;
  int v48;
  int v49;
  BOOL v50;
  BOOL v51;
  unint64_t v53;
  int v55;
  __int128 v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;

  v7 = a1;
  if (a3 < 31)
  {
    v57 = 0;
    v58 = 0;
    v56 = 0uLL;
    v59 = 0;
    v33 = 0;
    v9 = "zip";
    goto LABEL_125;
  }
  v55 = 0;
  v57 = 0;
  v58 = 0;
  v56 = 0uLL;
  v59 = 0;
  v8 = 0;
  v53 = a2 + a3;
  v9 = "zip";
  while (1)
  {
    v10 = (const char *)(a2 + v8);
    if (*(_BYTE *)(a2 + v8) != 80 || *(_BYTE *)(v8 + a2 + 1) != 75)
      goto LABEL_12;
    v11 = *(unsigned __int8 *)(v8 + a2 + 2);
    if (v11 != 3)
      break;
    if (*(_BYTE *)(v8 + a2 + 3) == 4)
    {
      v13 = 30;
      v12 = 1;
      v14 = 26;
      goto LABEL_11;
    }
LABEL_12:
    v16 = 0;
LABEL_13:
    v17 = v8 + 31;
    ++v8;
    if (v17 >= a3)
      goto LABEL_124;
  }
  if (v11 != 1 || *(_BYTE *)(v8 + a2 + 3) != 2)
    goto LABEL_12;
  v12 = 0;
  v13 = 46;
  v14 = 28;
LABEL_11:
  v15 = *(unsigned __int16 *)&v10[v14];
  if (v8 + v13 + v15 > a3)
    goto LABEL_12;
  v18 = v13;
  v19 = v12 ^ 1;
  if ((_DWORD)v15 != 8)
    v19 = 1;
  if ((v19 & 1) != 0)
  {
    if (*(unsigned __int16 *)&v10[v14] <= 0x12u)
    {
      if ((_DWORD)v15 == 9)
      {
        if (!strncasecmp_l(&v10[v13], "META-INF/", 9uLL, 0))
        {
          v16 = 0;
          LODWORD(v56) = 1;
          goto LABEL_78;
        }
        goto LABEL_19;
      }
      if ((_DWORD)v15 == 11)
      {
        if (!strncasecmp_l(&v10[v13], "content.xml", 0xBuLL, 0))
        {
          v16 = 0;
          DWORD1(v56) = 1;
          goto LABEL_78;
        }
        if (!strncasecmp_l(&v10[v18], "_rels/.rels", 0xBuLL, 0))
        {
          v16 = 0;
          LODWORD(v59) = 1;
          goto LABEL_78;
        }
        goto LABEL_19;
      }
    }
    else
    {
      switch((_DWORD)v15)
      {
        case 0x13:
          if (!strncasecmp_l(&v10[v13], "[Content_Types].xml", 0x13uLL, 0))
          {
            v16 = 0;
            HIDWORD(v59) = 1;
            goto LABEL_78;
          }
          goto LABEL_19;
        case 0x14:
          if (!strncasecmp_l(&v10[v13], "META-INF/MANIFEST.MF", 0x14uLL, 0))
          {
            v16 = 0;
            v55 = 1;
            goto LABEL_78;
          }
          goto LABEL_19;
        case 0x15:
          if (!strncasecmp_l(&v10[v13], "META-INF/manifest.xml", 0x15uLL, 0))
          {
            v16 = 0;
            DWORD2(v56) = 1;
            goto LABEL_78;
          }
LABEL_19:
          v20 = &v10[v18];
          v21 = &v10[v18 + v15];
          if (!strncasecmp_l(v21 - 4, ".opf", 4uLL, 0))
          {
            v16 = 0;
            HIDWORD(v58) = 1;
            goto LABEL_78;
          }
          if (!strncasecmp_l(v21 - 4, ".sml", 4uLL, 0))
            goto LABEL_60;
          if (v15 < 6)
            goto LABEL_75;
          if (!strncasecmp_l(v21 - 5, ".smil", 5uLL, 0))
          {
LABEL_60:
            v16 = 0;
            HIDWORD(v57) = 1;
            goto LABEL_78;
          }
          if (v15 < 8)
            goto LABEL_75;
          if (strncasecmp_l(v20, "xl/", 3uLL, 0) || strncasecmp_l(v21 - 4, ".xml", 4uLL, 0))
          {
            if (v15 < 9)
              goto LABEL_75;
            if (!strncasecmp_l(v20, "ppt/", 4uLL, 0) && !strncasecmp_l(v21 - 4, ".xml", 4uLL, 0))
            {
              v16 = 0;
              v23 = 1;
LABEL_107:
              HIDWORD(v56) = v23;
              goto LABEL_78;
            }
            if (v15 < 0xA)
              goto LABEL_75;
            if (!strncasecmp_l(v20, "word/", 5uLL, 0) && !strncasecmp_l(v21 - 4, ".xml", 4uLL, 0))
            {
              v16 = 0;
              LODWORD(v58) = 1;
              goto LABEL_78;
            }
            if (v15 < 0xB)
            {
LABEL_75:
              v16 = 0;
              goto LABEL_78;
            }
            if (strncasecmp_l(v20, "excel/", 6uLL, 0) || strncasecmp_l(v21 - 4, ".xml", 4uLL, 0))
            {
              if (v15 >= 0x10 && !strncasecmp_l(v20, "powerpoint/", 0xBuLL, 0))
              {
                v22 = strncasecmp_l(v21 - 4, ".xml", 4uLL, 0);
                v16 = 0;
                v23 = HIDWORD(v56);
                if (!v22)
                  v23 = 1;
                goto LABEL_107;
              }
              goto LABEL_75;
            }
          }
          v16 = 0;
          LODWORD(v57) = 1;
          goto LABEL_78;
      }
    }
    if (v15 < 5)
      goto LABEL_75;
    goto LABEL_19;
  }
  if (strncasecmp_l(&v10[v13], "mimetype", 8uLL, 0))
    goto LABEL_19;
  v24 = &v10[*((unsigned __int16 *)v10 + 13) + *((unsigned __int16 *)v10 + 14)];
  v25 = (unint64_t)(v24 + 30);
  if (v24 + 30 <= v10
    || (unint64_t)(v24 + 86) > v53
    || *((_WORD *)v10 + 4)
    || strncasecmp_l((const char *)v25, "application/vnd.", 0x10uLL, 0)
    && strncasecmp_l((const char *)v25, "application/x-vnd.", 0x12uLL, 0))
  {
    if (v25 > (unint64_t)v10
      && v25 + 41 <= v53
      && *((_WORD *)v10 + 4) == 8
      && *(_DWORD *)v25 == -936891317
      && *(_DWORD *)(v25 + 4) == 743328969)
    {
      v26 = -1;
      v9 = "odt";
      goto LABEL_77;
    }
    if (v25 <= (unint64_t)v10
      || v25 + 29 > v53
      || strncasecmp_l((const char *)v25, "application/oebps-package+xml", 0x1DuLL, 0))
    {
      v26 = -1;
      if (v25 <= (unint64_t)v10 || v25 + 20 > v53)
        goto LABEL_77;
      if (strncasecmp_l((const char *)v25, "application/epub+zip", 0x14uLL, 0))
        goto LABEL_67;
    }
    v26 = 0;
    v9 = "epub";
    goto LABEL_77;
  }
  v27 = 16;
  if (*(_BYTE *)(v25 + 15) != 46)
    v27 = 18;
  v28 = (const char *)(v25 + v27);
  if (!strncasecmp_l(v28, "sun.xml.", 8uLL, 0))
  {
    v30 = v28 + 8;
    if (strncasecmp_l(v30, "calc", 4uLL, 0))
    {
      if (strncasecmp_l(v30, "draw", 4uLL, 0))
      {
        if (strncasecmp_l(v30, "writer.global", 0xDuLL, 0))
        {
          if (strncasecmp_l(v30, "impress", 7uLL, 0))
          {
            v26 = 4;
            if (strncasecmp_l(v30, "math", 4uLL, 0))
            {
              if (strncasecmp_l(v30, "writer", 6uLL, 0))
                goto LABEL_67;
              v26 = 5;
            }
          }
          else
          {
            v26 = 3;
          }
        }
        else
        {
          v26 = 2;
        }
      }
      else
      {
        v26 = 1;
      }
    }
    else
    {
      v26 = 0;
    }
    v31 = (5 * v26);
    v32 = "sxc";
    goto LABEL_122;
  }
  if (strncasecmp_l(v28, "oasis.opendocument.", 0x13uLL, 0))
    goto LABEL_67;
  v29 = v28 + 19;
  if (!strncasecmp_l(v29, "chart", 5uLL, 0))
  {
    v26 = 0;
LABEL_121:
    v31 = (5 * v26);
    v32 = (const char *)&unk_182DB17E4;
LABEL_122:
    v9 = &v32[v31];
    goto LABEL_77;
  }
  if (!strncasecmp_l(v29, "formula", 7uLL, 0))
  {
    v26 = 1;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "graphics", 8uLL, 0))
  {
    v26 = 2;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "text-web", 8uLL, 0))
  {
    v26 = 3;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "image", 5uLL, 0))
  {
    v26 = 4;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "text-master", 0xBuLL, 0))
  {
    v26 = 5;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "presentation", 0xCuLL, 0))
  {
    v26 = 6;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "spreadsheet", 0xBuLL, 0))
  {
    v26 = 7;
    goto LABEL_121;
  }
  if (!strncasecmp_l(v29, "text", 4uLL, 0))
  {
    v26 = 8;
    goto LABEL_121;
  }
LABEL_67:
  v26 = -1;
LABEL_77:
  v16 = v26 >= 0;
LABEL_78:
  v8 += (v18 + v15 - 1);
  if (!v16)
    goto LABEL_13;
LABEL_124:
  v7 = a1;
  v33 = v55;
  if (!v16)
  {
LABEL_125:
    v34 = a4 < 1024;
    v35 = a4 - 1024;
    if (!v34)
    {
      if (v7 < 0 || lseek(v7, v35, 0) != v35)
      {
        if (a3 >= 1024)
        {
          v39 = 0;
          v37 = a2 + a3 - 1024;
          goto LABEL_133;
        }
      }
      else
      {
        v36 = malloc_type_malloc(0x400uLL, 0x2B428188uLL);
        if (v36)
        {
          v37 = (uint64_t)v36;
          v38 = read(v7, v36, 0x400uLL);
          v39 = (void *)v37;
          if (v38 <= 1023)
          {
            v39 = (void *)v37;
            goto LABEL_192;
          }
LABEL_133:
          v40 = 0;
          while (2)
          {
            v41 = v37 + v40;
            if (*(_BYTE *)(v37 + v40) != 80 || *(_BYTE *)(v40 + v37 + 1) != 75)
              goto LABEL_185;
            v42 = *(unsigned __int8 *)(v40 + v37 + 2);
            if (v42 != 3)
            {
              if (v42 == 1 && *(_BYTE *)(v40 + v37 + 3) == 2)
              {
                v43 = 46;
                v44 = 28;
                goto LABEL_142;
              }
              goto LABEL_185;
            }
            if (*(_BYTE *)(v40 + v37 + 3) != 4)
              goto LABEL_185;
            v43 = 30;
            v44 = 26;
LABEL_142:
            v45 = *(unsigned __int16 *)(v41 + v44);
            if (v40 + v43 + v45 > 1024)
            {
LABEL_185:
              v34 = v40++ < 993;
              if (!v34)
                goto LABEL_192;
              continue;
            }
            break;
          }
          v46 = v43;
          if (*(unsigned __int16 *)(v41 + v44) <= 0x12u)
          {
            if ((_DWORD)v45 == 9)
            {
              if (!strncasecmp_l((const char *)(v41 + v43), "META-INF/", 9uLL, 0))
              {
                LODWORD(v56) = 1;
                goto LABEL_184;
              }
              goto LABEL_161;
            }
            if ((_DWORD)v45 == 11)
            {
              if (!strncasecmp_l((const char *)(v41 + v43), "content.xml", 0xBuLL, 0))
              {
                DWORD1(v56) = 1;
                goto LABEL_184;
              }
              if (!strncasecmp_l((const char *)(v41 + v46), "_rels/.rels", 0xBuLL, 0))
              {
                LODWORD(v59) = 1;
                goto LABEL_184;
              }
              goto LABEL_161;
            }
          }
          else
          {
            switch((_DWORD)v45)
            {
              case 0x13:
                if (!strncasecmp_l((const char *)(v41 + v43), "[Content_Types].xml", 0x13uLL, 0))
                {
                  HIDWORD(v59) = 1;
                  goto LABEL_184;
                }
                goto LABEL_161;
              case 0x14:
                if (!strncasecmp_l((const char *)(v41 + v43), "META-INF/MANIFEST.MF", 0x14uLL, 0))
                {
                  v33 = 1;
                  goto LABEL_184;
                }
                goto LABEL_161;
              case 0x15:
                if (!strncasecmp_l((const char *)(v41 + v43), "META-INF/manifest.xml", 0x15uLL, 0))
                {
                  DWORD2(v56) = 1;
                  goto LABEL_184;
                }
LABEL_161:
                v47 = (const char *)(v41 + v46);
                if (!strncasecmp_l(&v47[v45 - 4], ".opf", 4uLL, 0))
                {
                  HIDWORD(v58) = 1;
                  goto LABEL_184;
                }
                if (!strncasecmp_l(&v47[v45 - 4], ".sml", 4uLL, 0))
                  goto LABEL_182;
                if (v45 < 6)
                  goto LABEL_184;
                if (!strncasecmp_l(&v47[v45 - 5], ".smil", 5uLL, 0))
                {
LABEL_182:
                  HIDWORD(v57) = 1;
                  goto LABEL_184;
                }
                if (v45 < 8)
                  goto LABEL_184;
                if (strncasecmp_l(v47, "xl/", 3uLL, 0) || strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0))
                {
                  if (v45 < 9)
                    goto LABEL_184;
                  if (!strncasecmp_l(v47, "ppt/", 4uLL, 0) && !strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0))
                  {
                    v49 = 1;
LABEL_189:
                    HIDWORD(v56) = v49;
                    goto LABEL_184;
                  }
                  if (v45 < 0xA)
                    goto LABEL_184;
                  if (!strncasecmp_l(v47, "word/", 5uLL, 0) && !strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0))
                  {
                    LODWORD(v58) = 1;
                    goto LABEL_184;
                  }
                  if (v45 < 0xB)
                  {
LABEL_184:
                    v40 += (v46 + v45 - 1);
                    goto LABEL_185;
                  }
                  if (strncasecmp_l(v47, "excel/", 6uLL, 0) || strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0))
                  {
                    if (v45 < 0x10 || strncasecmp_l(v47, "powerpoint/", 0xBuLL, 0))
                      goto LABEL_184;
                    v48 = strncasecmp_l(&v47[v45 - 4], ".xml", 4uLL, 0);
                    v49 = HIDWORD(v56);
                    if (!v48)
                      v49 = 1;
                    goto LABEL_189;
                  }
                }
                LODWORD(v57) = 1;
                goto LABEL_184;
            }
          }
          if (v45 < 5)
            goto LABEL_184;
          goto LABEL_161;
        }
      }
    }
    v39 = 0;
LABEL_192:
    if (v33)
    {
LABEL_193:
      v9 = "jar";
    }
    else
    {
      v50 = v59 != 0;
      if (v59 && (_DWORD)v58)
      {
        v9 = "docx";
      }
      else
      {
        if ((_DWORD)v57)
          v51 = v59 != 0;
        else
          v51 = 0;
        if (v51)
        {
          v9 = "xlsx";
        }
        else
        {
          if (!BYTE12(v56))
            v50 = 0;
          if (v50)
          {
            v9 = "pptx";
          }
          else if (*(_QWORD *)((char *)&v56 + 4))
          {
            v9 = "odt";
          }
          else
          {
            if ((_DWORD)v56)
              goto LABEL_193;
            if (HIDWORD(v58) && HIDWORD(v57))
            {
              v9 = "dtb";
            }
            else if (HIDWORD(v58))
            {
              v9 = "oeb";
            }
          }
        }
      }
    }
    if (v39)
      free(v39);
  }
  return v9;
}

const char *_CFBundleGrokFileTypeForOLEFile(int a1, uint64_t a2, off_t a3, off_t a4)
{
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  const char *v11;
  unint64_t v12;
  unint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  int v21;
  BOOL v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  int v27;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unsigned __int8 *v32;
  int v33;
  int v34;
  unsigned int v36;
  uint64_t v37;
  unint64_t v38;
  unsigned __int8 *v39;
  int v40;
  int v41;

  if (a1 < 0 || lseek(a1, a4, 0) != a4)
  {
    v11 = "ole";
    if (a4 + 512 > a3 || !a2)
      return v11;
    v9 = 0;
    v10 = (unsigned __int8 *)(a2 + a4);
  }
  else
  {
    v8 = (unsigned __int8 *)malloc_type_malloc(0x200uLL, 0x5D77337uLL);
    if (!v8)
      return "ole";
    v9 = v8;
    if (read(a1, v8, 0x200uLL) <= 511)
    {
      v11 = "ole";
      goto LABEL_60;
    }
    v10 = v9;
  }
  v12 = 0;
  v11 = "xls";
  while (1)
  {
    v13 = v12 << 7;
    v14 = v10[128 * v12 + 64];
    v15 = (int)((v14 + (v14 >> 7)) << 24) >> 25;
    v16 = v14 & 0xFE;
    if (v16 <= 25)
    {
      if (v16 == 10)
      {
        v29 = (v15 - 1);
        if (v15 == 1)
          goto LABEL_56;
        v30 = 0;
        v31 = 0;
        v32 = &v10[v13];
        do
        {
          v33 = v32[v30 & 0xFFFFFFFE];
          v34 = aBook[v31++];
          v30 += 2;
        }
        while (v33 == v34 && v31 < v29);
        if (v33 == v34)
          goto LABEL_56;
      }
      else if (v16 == 18)
      {
        v17 = (v15 - 1);
        if (!(_DWORD)v17)
          goto LABEL_56;
        v18 = 0;
        v19 = 0;
        do
        {
          v20 = v10[v13 + (v18 & 0xFFFFFFFE)];
          v21 = aWorkbook[v19++];
          v18 += 2;
          v22 = v20 != v21 || v19 >= v17;
        }
        while (!v22);
        if (v20 == v21)
          goto LABEL_56;
      }
      goto LABEL_50;
    }
    if (v16 != 40)
      break;
    v36 = v15 - 1;
    if (!v36)
      goto LABEL_55;
    v37 = 0;
    v38 = 0;
    v39 = &v10[v13];
    do
    {
      v40 = v39[v37 & 0xFFFFFFFE];
      v41 = aPowerpointDocu[v38++];
      v37 += 2;
    }
    while (v40 == v41 && v38 < v36);
    if (v40 == v41)
    {
LABEL_55:
      v11 = "ppt";
LABEL_56:
      if (v9)
        goto LABEL_60;
      return v11;
    }
LABEL_50:
    v22 = v12++ >= 3;
    if (v22)
    {
      v11 = "ole";
      if (v9)
        goto LABEL_60;
      return v11;
    }
  }
  if (v16 != 26)
    goto LABEL_50;
  v23 = v15 - 1;
  if (v23)
  {
    v24 = 0;
    v25 = 0;
    do
    {
      v26 = v10[v13 + (v24 & 0xFFFFFFFE)];
      v27 = aWorddocument[v25++];
      v24 += 2;
    }
    while (v26 == v27 && v25 < v23);
    if (v26 != v27)
      goto LABEL_50;
  }
  v11 = "doc";
  if (!v9)
    return v11;
LABEL_60:
  free(v9);
  return v11;
}

BOOL _CFBundleGrokX11FromFile(int a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6)
{
  uint64_t v11;
  void *v13;
  void *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  _BOOL8 v19;
  unsigned int v20;
  unsigned int v21;
  unint64_t v22;
  int *v23;
  unsigned int v24;
  unint64_t v25;
  int v26;
  unsigned int v27;
  const char *v28;
  unsigned int v29;
  unint64_t v30;
  BOOL v31;
  int *v33;
  unsigned int v34;
  unint64_t v35;
  int v36;
  unsigned int v37;
  const char *v38;
  unsigned int v39;
  void *v40;

  v11 = a4;
  if ((a1 & 0x80000000) == 0 && lseek(a1, a4, 0) == a4)
  {
    v13 = malloc_type_malloc(0x1000uLL, 0xD7DD8ABDuLL);
    if (v13)
    {
      v14 = v13;
      if (read(a1, v13, 0x1000uLL) <= 4095)
      {
        v19 = 0;
LABEL_51:
        free(v14);
        return v19;
      }
      v40 = v14;
      v15 = (unsigned int *)v14;
      if (!a6)
        goto LABEL_6;
      goto LABEL_15;
    }
    return 0;
  }
  v15 = (unsigned int *)(a2 + v11);
  if (a4 + 4096 > a3 || v15 == 0)
    return 0;
  v40 = 0;
  if (!a6)
  {
LABEL_6:
    v16 = v15[4];
    if (a5)
    {
      v16 = bswap32(v16);
      v17 = bswap32(v15[5]);
    }
    else
    {
      v17 = v15[5];
    }
    if (v17 <= 0xFE4)
      v30 = v17 + 28;
    else
      v30 = 4096;
    if (v16)
      v31 = v30 >= 0x1D;
    else
      v31 = 0;
    if (!v31)
    {
      v19 = 0;
      goto LABEL_50;
    }
    v33 = (int *)(v15 + 7);
    v34 = 1;
    v35 = 28;
    while (1)
    {
      v36 = *v33;
      if (a5)
        break;
      if (v36 == 12)
      {
        v37 = v33[2];
LABEL_59:
        v38 = (char *)v15 + v35 + v37;
        v19 = v38 + 20 <= (const char *)v15 + v30 && strncmp(v38, "/usr/X11R6/lib/libX", 0x13uLL) == 0;
        v39 = v33[1];
        if (a5)
          goto LABEL_64;
        goto LABEL_65;
      }
      v19 = 0;
      v39 = v33[1];
LABEL_66:
      if (v34 < v16)
      {
        v35 += v39;
        v33 = (int *)((char *)v15 + v35);
        ++v34;
        if (v35 < v30)
          continue;
      }
      goto LABEL_50;
    }
    if (v36 == 201326592)
    {
      v37 = bswap32(v33[2]);
      goto LABEL_59;
    }
    v19 = 0;
    v39 = v33[1];
LABEL_64:
    v39 = bswap32(v39);
LABEL_65:
    if (v19)
      goto LABEL_50;
    goto LABEL_66;
  }
LABEL_15:
  v20 = v15[4];
  if (a5)
  {
    v20 = bswap32(v20);
    v21 = bswap32(v15[5]);
  }
  else
  {
    v21 = v15[5];
  }
  v19 = 0;
  if (v21 <= 0xFE0)
    v22 = v21 + 32;
  else
    v22 = 4096;
  if (v20 && v22 >= 0x21)
  {
    v23 = (int *)(v15 + 8);
    v24 = 1;
    v25 = 32;
    while (1)
    {
      v26 = *v23;
      if (a5)
        break;
      if (v26 == 12)
      {
        v27 = v23[2];
LABEL_29:
        v28 = (char *)v15 + v25 + v27;
        v19 = v28 + 20 <= (const char *)v15 + v22 && strncmp(v28, "/usr/X11R6/lib/libX", 0x13uLL) == 0;
        v29 = v23[1];
        if (a5)
          goto LABEL_34;
        goto LABEL_35;
      }
      v19 = 0;
      v29 = v23[1];
LABEL_36:
      if (v24 < v20)
      {
        v25 += v29;
        v23 = (int *)((char *)v15 + v25);
        ++v24;
        if (v25 < v22)
          continue;
      }
      goto LABEL_50;
    }
    if (v26 == 201326592)
    {
      v27 = bswap32(v23[2]);
      goto LABEL_29;
    }
    v19 = 0;
    v29 = v23[1];
LABEL_34:
    v29 = bswap32(v29);
LABEL_35:
    if (v19)
      goto LABEL_50;
    goto LABEL_36;
  }
LABEL_50:
  v14 = v40;
  if (v40)
    goto LABEL_51;
  return v19;
}

void _CFBundleGrokObjcImageInfoFromFile(int a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6, char *a7, unsigned int *a8, unsigned int *a9)
{
  uint64_t v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int *v20;
  unsigned int v22;
  char v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unint64_t v29;
  int v30;
  int *v31;
  unint64_t v32;
  int v33;
  unsigned int v34;
  unint64_t v35;
  unsigned int v36;
  unint64_t v37;
  char *v38;
  const char *v39;
  int v40;
  int v41;
  unsigned int v42;
  int v43;
  BOOL v44;
  uint64_t v45;
  BOOL v46;
  unint64_t v47;
  BOOL v48;
  int v49;
  int *v50;
  unint64_t v51;
  int v52;
  unsigned int v53;
  unsigned int v54;
  unint64_t v55;
  char *v56;
  const char *v57;
  int v58;
  unint64_t v59;
  int v60;
  unsigned int v61;
  int v62;
  unsigned int v64;
  unsigned int *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unsigned int v69;
  unsigned int *v70;
  char *v71;
  unsigned int *v72;
  int v73;
  unsigned int v74;
  uint64_t v75;
  unsigned int v76;
  unsigned int v77;
  int v78;
  int v79;
  unint64_t v80;
  unsigned int *v81;
  unsigned int v82;
  unsigned int v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v17 = a4;
  if (a1 < 0 || lseek(a1, a4, 0) != a4)
  {
    v20 = (unsigned int *)(a2 + v17);
    if (a4 + 4096 <= a3 && v20 != 0)
    {
      v19 = 0;
      goto LABEL_12;
    }
LABEL_11:
    v22 = 0;
    v23 = 0;
    v24 = 0;
    goto LABEL_114;
  }
  v18 = (unsigned int *)malloc_type_malloc(0x1000uLL, 0xEF974ABDuLL);
  if (!v18)
    goto LABEL_11;
  v19 = v18;
  if (read(a1, v18, 0x1000uLL) <= 4095)
  {
    v22 = 0;
    v23 = 0;
    v24 = 0;
    goto LABEL_113;
  }
  v20 = v19;
LABEL_12:
  v78 = a5;
  v81 = v20;
  if (!a6)
  {
    v27 = v20[4];
    if (a5)
    {
      v27 = bswap32(v27);
      v28 = bswap32(v20[5]);
    }
    else
    {
      v28 = v20[5];
    }
    v45 = v28 + 28;
    v46 = v28 > 0xFE4;
    v47 = 4096;
    if (!v46)
      v47 = v45;
    v80 = v47;
    if (v27)
      v48 = v47 >= 0x1D;
    else
      v48 = 0;
    if (!v48)
    {
      v23 = 0;
      goto LABEL_106;
    }
    v73 = a1;
    v74 = 0;
    v69 = a4;
    v67 = a3;
    v68 = v17;
    v66 = a2;
    v70 = v19;
    v71 = a7;
    v72 = a8;
    LODWORD(v75) = 0;
    v23 = 0;
    v49 = 0;
    v50 = (int *)(v20 + 7);
    v51 = 28;
    v77 = v27;
    while (1)
    {
      v52 = *v50;
      if (a5)
        break;
      if (v52 == 1)
      {
        v53 = v50[12];
        if (!v53)
          goto LABEL_87;
        goto LABEL_73;
      }
      v61 = v50[1];
LABEL_90:
      if (++v49 < v27)
      {
        v51 += v61;
        v50 = (int *)((char *)v20 + v51);
        if (v51 >= 0x1C && v51 < v80)
          continue;
      }
      goto LABEL_98;
    }
    if (v52 == 0x1000000)
    {
      v53 = bswap32(v50[12]);
      if (!v53)
      {
LABEL_87:
        v60 = 0;
        v62 = 0;
        v61 = v50[1];
        v27 = v77;
        a5 = v78;
        if (!v78)
          goto LABEL_89;
        goto LABEL_88;
      }
LABEL_73:
      if (v51 + 56 >= v80)
        goto LABEL_87;
      v54 = 1;
      v55 = v51;
      while (1)
      {
        v56 = (char *)v20 + v55;
        v57 = (char *)v20 + v55 + 56;
        v58 = strncmp((const char *)v20 + v55 + 72, "__OBJC", 0x10uLL);
        if (!v58)
          v23 = 1;
        if (!(strncmp(v57, "__image_info", 0x10uLL) | v58))
          break;
        if (v54 >= v53)
        {
          v20 = v81;
          goto LABEL_87;
        }
        v59 = v55 + 124;
        v55 += 68;
        ++v54;
        v20 = v81;
        if (v59 >= v80)
          goto LABEL_87;
      }
      a5 = v78;
      if (!v78)
      {
        LODWORD(v75) = *((_DWORD *)v56 + 23);
        v74 = *(unsigned int *)((char *)v81 + v55 + 96);
        goto LABEL_98;
      }
      LODWORD(v75) = bswap32(*((_DWORD *)v56 + 23));
      v20 = v81;
      v74 = bswap32(*(unsigned int *)((char *)v81 + v55 + 96));
      v60 = 1;
      v27 = v77;
    }
    else
    {
      v60 = 0;
    }
    v61 = v50[1];
LABEL_88:
    v61 = bswap32(v61);
    v62 = v60;
LABEL_89:
    if (v62)
      goto LABEL_98;
    goto LABEL_90;
  }
  v25 = v20[4];
  v73 = a1;
  if (a5)
  {
    v25 = bswap32(v25);
    v26 = bswap32(v20[5]);
  }
  else
  {
    v26 = v20[5];
  }
  v23 = 0;
  if (v26 <= 0xFE0)
    v29 = v26 + 32;
  else
    v29 = 4096;
  if (!v25)
  {
    v24 = 0;
    v22 = 0;
    goto LABEL_112;
  }
  v69 = a4;
  v68 = v17;
  v24 = 0;
  v22 = 0;
  if (v29 < 0x21)
    goto LABEL_112;
  v66 = a2;
  v67 = a3;
  v70 = v19;
  v71 = a7;
  v72 = a8;
  LODWORD(v75) = 0;
  v74 = 0;
  v23 = 0;
  v30 = 0;
  v31 = (int *)(v20 + 8);
  v32 = 32;
  v76 = v25;
  while (1)
  {
    v33 = *v31;
    if (a5)
      break;
    if (v33 == 25)
    {
      v34 = v31[16];
      goto LABEL_29;
    }
    v42 = v31[1];
LABEL_48:
    if (++v30 < v25)
    {
      v32 += v42;
      v31 = (int *)((char *)v20 + v32);
      v44 = v32 < 0x20 || v32 >= v29;
      if (!v44)
        continue;
    }
    goto LABEL_98;
  }
  if (v33 != 419430400)
  {
    v41 = 0;
LABEL_43:
    v42 = v31[1];
LABEL_46:
    v42 = bswap32(v42);
    v43 = v41;
LABEL_47:
    if (v43)
      goto LABEL_98;
    goto LABEL_48;
  }
  v34 = bswap32(v31[16]);
LABEL_29:
  v79 = v30;
  if (!v34 || v32 + 72 >= v29)
  {
LABEL_45:
    v41 = 0;
    v43 = 0;
    v42 = v31[1];
    v25 = v76;
    a5 = v78;
    v30 = v79;
    if (!v78)
      goto LABEL_47;
    goto LABEL_46;
  }
  v35 = v32 + 152;
  v36 = 1;
  while (1)
  {
    v37 = v29;
    v38 = (char *)v20 + v35;
    v39 = (char *)v20 + v35 - 80;
    v40 = strncmp((const char *)v20 + v35 - 64, "__DATA", 0x10uLL);
    if (!v40)
      v23 = 1;
    if (!(strncmp(v39, "__objc_imageinfo", 0x10uLL) | v40))
      break;
    if (v36 >= v34)
    {
      v20 = v81;
      v29 = v37;
      goto LABEL_45;
    }
    ++v36;
    v29 = v37;
    v44 = v35 >= v37;
    v35 += 80;
    v20 = v81;
    if (v44)
      goto LABEL_45;
  }
  a5 = v78;
  if (v78)
  {
    LODWORD(v75) = bswap64(*((_QWORD *)v38 - 5));
    v20 = v81;
    v74 = bswap32(*(unsigned int *)((char *)v81 + v35 - 32));
    v41 = 1;
    v25 = v76;
    v29 = v37;
    v30 = v79;
    goto LABEL_43;
  }
  v74 = *(unsigned int *)((char *)v81 + v35 - 32);
  v75 = *((_QWORD *)v38 - 5);
LABEL_98:
  if (v75 < 8)
  {
    v24 = 0;
    v22 = 0;
    a7 = v71;
    a8 = v72;
    v19 = v70;
    goto LABEL_112;
  }
  if (v73 < 0 || lseek(v73, v74 + v69, 0) != v74 + v69 || read(v73, &v82, 8uLL) < 8)
  {
    a7 = v71;
    a8 = v72;
    v19 = v70;
    if (v69 + v74 + 8 <= v67)
    {
      v65 = (unsigned int *)(v66 + v68 + v74);
      v22 = *v65;
      if (a5)
      {
        v22 = bswap32(v22);
        v64 = v65[1];
LABEL_109:
        v24 = bswap32(v64);
      }
      else
      {
        v24 = v65[1];
      }
      goto LABEL_112;
    }
LABEL_106:
    v24 = 0;
    v22 = 0;
    goto LABEL_112;
  }
  v22 = v82;
  a7 = v71;
  a8 = v72;
  v19 = v70;
  if (a5)
  {
    v22 = bswap32(v82);
    v64 = v83;
    goto LABEL_109;
  }
  v24 = v83;
LABEL_112:
  if (v19)
LABEL_113:
    free(v19);
LABEL_114:
  if (a7)
    *a7 = v23;
  if (a8)
    *a8 = v22;
  if (a9)
    *a9 = v24;
}

uint64_t _CFBundleGrokMachTypeForFatFile(int a1, UInt8 *a2, uint64_t a3, int a4, BOOL *a5, const __CFArray **a6, CFMutableDictionaryRef *a7, char *a8, unsigned int *a9, unsigned int *a10)
{
  const NXArchInfo *v18;
  cpu_type_t v19;
  unsigned int *v20;
  uint64_t v21;
  uint64_t v22;
  uint32_t v23;
  fat_arch *v24;
  int v25;
  UInt8 *v26;
  fat_arch *v27;
  const __CFArray *Mutable;
  uint64_t v29;
  CFNumberRef v30;
  uint32_t *v32;
  int *v33;
  BOOL v34;
  uint32_t *p_offset;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  int v40;
  unsigned int v41;
  unsigned int *v42;
  int *v43;
  uint32_t *v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  unsigned int *v50;
  int *v51;
  uint32_t *v52;
  unsigned int v53;
  unsigned int *v54;
  int *v55;
  uint32_t *v56;
  int v57;
  unsigned int *v58;
  int *v59;
  uint32_t *v60;
  unsigned int *v61;
  CFMutableDictionaryRef *v62;
  BOOL *v63;
  fat_arch *v64;
  _BYTE v65[36];
  unsigned int v66;
  fat_arch v67[25];
  uint64_t v68;
  CFRange v69;

  v68 = *MEMORY[0x1E0C80C00];
  v18 = NXGetLocalArchInfo();
  v19 = _CFBundleCurrentArchitecture();
  if (a5)
    *a5 = 0;
  v63 = a5;
  if (a6)
    *a6 = 0;
  v20 = a9;
  if (a7)
    *a7 = 0;
  if (a8)
    *a8 = 0;
  if (a9)
    *a9 = 0;
  v62 = a7;
  if (a10)
    *a10 = 0;
  if (a3 >= 512)
    v21 = 512;
  else
    v21 = a3;
  __memmove_chk();
  if (a4 && a3 >= 1)
  {
    v22 = 0;
    do
    {
      *(_DWORD *)&v65[v22 + 32] = bswap32(*(_DWORD *)&v65[v22 + 32]);
      v22 += 4;
    }
    while (v21 > v22);
  }
  if (v66 >= ((v21 - 8) / 0x14uLL))
    v23 = (v21 - 8) / 0x14uLL;
  else
    v23 = v66;
  if (!v23)
    return 0;
  if (v18)
    v24 = NXFindBestFatArch(v18->cputype, v18->cpusubtype, v67, v23);
  else
    v24 = 0;
  v25 = a1;
  v26 = a2;
  if (!v24 && v19)
    v24 = NXFindBestFatArch(v19, 0, v67, v23);
  v64 = v24;
  if (a6)
  {
    v27 = v67;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
    v29 = -(uint64_t)v23;
    do
    {
      v30 = CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, kCFNumberSInt32Type, v27);
      v69.length = CFArrayGetCount(Mutable);
      v69.location = 0;
      if (CFArrayGetFirstIndexOfValue(Mutable, v69, v30) < 0)
        CFArrayAppendValue(Mutable, v30);
      CFRelease(v30);
      ++v27;
    }
    while (!__CFADD__(v29++, 1));
    *a6 = Mutable;
    v20 = a9;
    v24 = v64;
  }
  if (v25 < 0
    || (v24 ? (v32 = &v24->offset) : (v32 = &v67[0].offset),
        (v37 = lseek(v25, *v32, 0) == *v32, v24 = v64, !v37)
     || (v33 = (int *)v65, v34 = read(v25, v65, 0x20uLL) <= 31, v24 = v64, v34)))
  {
    p_offset = &v67[0].offset;
    if (v24)
      p_offset = &v24->offset;
    v36 = *p_offset;
    v33 = (int *)&v26[v36];
    v37 = v36 + 32 > (unint64_t)a3 || v33 == 0;
    if (v37)
      return 0;
  }
  v38 = 0;
  v40 = *v33;
  if (*v33 <= -17958195)
  {
    if (v40 != -822415874)
    {
      if (v40 == -805638658)
      {
        v41 = v33[3];
        if (v63 && v41 == 0x2000000)
        {
          v42 = &v67[0].offset;
          if (v24)
            v42 = &v24->offset;
          *v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v42, 1, 1);
          v24 = v64;
        }
        v38 = bswap32(v41);
        if (v62)
        {
          v43 = (int *)&v67[0].offset;
          if (v24)
            v43 = (int *)&v24->offset;
          *v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v43, 1, 1);
          v24 = v64;
        }
        if (a8 || v20 || a10)
        {
          v44 = &v67[0].offset;
          if (v24)
            v44 = &v24->offset;
          v45 = *v44;
          v61 = a10;
          v46 = v25;
          v47 = (uint64_t)v26;
          v48 = a3;
          v49 = 1;
LABEL_120:
          v57 = 1;
          goto LABEL_121;
        }
      }
      return v38;
    }
    v53 = v33[3];
    if (v63 && v53 == 0x2000000)
    {
      v54 = &v67[0].offset;
      if (v24)
        v54 = &v24->offset;
      *v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v54, 1, 0);
      v24 = v64;
    }
    v38 = bswap32(v53);
    if (v62)
    {
      v55 = (int *)&v67[0].offset;
      if (v24)
        v55 = (int *)&v24->offset;
      *v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v55, 1, 0);
      v24 = v64;
    }
    if (!a8 && !v20 && !a10)
      return v38;
    v56 = &v67[0].offset;
    if (v24)
      v56 = &v24->offset;
    v45 = *v56;
    v61 = a10;
    v46 = v25;
    v47 = (uint64_t)v26;
    v48 = a3;
    v49 = 1;
LABEL_104:
    v57 = 0;
LABEL_121:
    _CFBundleGrokObjcImageInfoFromFile(v46, v47, v48, v45, v49, v57, a8, v20, v61);
    return v38;
  }
  if (v40 != -17958193)
  {
    if (v40 != -17958194)
      return v38;
    v38 = v33[3];
    if (v63 && (_DWORD)v38 == 2)
    {
      v50 = &v67[0].offset;
      if (v24)
        v50 = &v24->offset;
      *v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v50, 0, 0);
      v24 = v64;
    }
    if (v62)
    {
      v51 = (int *)&v67[0].offset;
      if (v24)
        v51 = (int *)&v24->offset;
      *v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v51, 0, 0);
      v24 = v64;
    }
    if (!a8 && !v20 && !a10)
      return v38;
    v52 = &v67[0].offset;
    if (v24)
      v52 = &v24->offset;
    v45 = *v52;
    v61 = a10;
    v46 = v25;
    v47 = (uint64_t)v26;
    v48 = a3;
    v49 = 0;
    goto LABEL_104;
  }
  v38 = v33[3];
  if (v63 && (_DWORD)v38 == 2)
  {
    v58 = &v67[0].offset;
    if (v24)
      v58 = &v24->offset;
    *v63 = _CFBundleGrokX11FromFile(v25, (uint64_t)v26, a3, *v58, 0, 1);
    v24 = v64;
  }
  if (v62)
  {
    v59 = (int *)&v67[0].offset;
    if (v24)
      v59 = (int *)&v24->offset;
    *v62 = _CFBundleCreateInfoDictFromFile(v25, v26, a3, *v59, 0, 1);
    v24 = v64;
  }
  if (a8 || v20 || a10)
  {
    v60 = &v67[0].offset;
    if (v24)
      v60 = &v24->offset;
    v45 = *v60;
    v61 = a10;
    v46 = v25;
    v47 = (uint64_t)v26;
    v48 = a3;
    v49 = 0;
    goto LABEL_120;
  }
  return v38;
}

uint64_t _CFURLComponentsGetURLUserAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1)
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  return *(_QWORD *)sURLAllowedCharacterSets;
}

uint64_t _CFURLComponentsGetURLPasswordAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1)
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  return *(_QWORD *)(sURLAllowedCharacterSets + 8);
}

uint64_t _CFURLComponentsGetURLPortAllowedCharacterSet()
{
  if (InitializeURLAllowedCharacterSets_static_init != -1)
    dispatch_once(&InitializeURLAllowedCharacterSets_static_init, &__block_literal_global_26);
  return *(_QWORD *)(sURLAllowedCharacterSets + 48);
}

uint64_t (**__CFStringEncodingGetJapaneseConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  uint64_t (**result)();

  if (!__CFStringEncodingIsDecomposableCharacter_2)
  {
    __CFStringEncodingIsDecomposableCharacter_2 = (_UNKNOWN *)a2(1);
    __CFStringEncodingDecomposeCharacter_2 = (_UNKNOWN *)a2(2);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_4 = (_UNKNOWN *)a2(3);
    __CFStringEncodingPrecomposeLatinCharacter_6 = (_UNKNOWN *)a2(4);
  }
  if (a1 > 2560)
  {
    switch(a1)
    {
      case 3056:
        return __CFConverterShiftJIS_NTT_Docomo;
      case 3057:
        return __CFConverterShiftJIS_KDDI;
      case 3058:
        return __CFConverterShiftJIS_SoftBank;
      case 3059:
        return 0;
      case 3060:
        return __CFConverterISO_2022_JP_KDDI;
      default:
        if (a1 == 2561)
        {
          result = __CFConverterShiftJIS;
        }
        else
        {
          if (a1 != 2814)
            return 0;
          result = __CFConverterAutoDetect_JP;
        }
        break;
    }
  }
  else
  {
    if (a1 > 2079)
    {
      if (a1 == 2080)
        return __CFConverterISO_2022_JP;
      if (a1 == 2336)
        return __CFConverterEUC_JP;
    }
    else
    {
      if (a1 == 1)
        return __CFConverterMacJapanese;
      if (a1 == 1056)
        return __CFConverterDOSJapanese;
    }
    return 0;
  }
  return result;
}

uint64_t __CFToDOSJapanese(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  int v20;
  char v21;
  unsigned int v22;

  if (a2 <= 0x7F)
    goto LABEL_4;
  if ((unsigned __int16)(a2 + 159) <= 0x3Eu)
  {
    LOBYTE(a2) = a2 + 64;
LABEL_4:
    *a3 = a2;
    return 1;
  }
  if ((unsigned __int16)((unsigned __int16)(a2 + 23) >> 2) < 0x80Bu)
    goto LABEL_12;
  v4 = (unsigned __int16 *)&DOSJapanese_from_uni;
  v5 = (unsigned __int16 *)&unk_182DB2816;
  while (1)
  {
    v6 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (v5 - v4)) >> 1;
    v7 = &v4[5 * v6];
    v8 = *v7;
    if (v8 <= a2)
      break;
    v5 = v7 - 5;
LABEL_11:
    if (v4 > v5)
      goto LABEL_12;
  }
  if (v8 + 4 <= a2)
  {
    v4 = v7 + 5;
    goto LABEL_11;
  }
  v15 = v4[5 * v6 + 1 + (int)(a2 - v8)];
  if (v15)
  {
    v16 = v15 >> 8;
LABEL_37:
    *a3 = v16;
    a3[1] = v15;
    return 2;
  }
LABEL_12:
  if ((unsigned __int16)(a2 + 12) < 0xACu)
    return 0;
  v9 = (unsigned __int16 *)&__CFToJISCharMap;
  v10 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (2)
  {
    v11 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v10 - v9)) >> 1;
    v12 = &v9[17 * v11];
    v13 = *v12;
    if (v13 > a2)
    {
      v10 = v12 - 17;
      goto LABEL_18;
    }
    if (v13 + 16 <= a2)
    {
      v9 = v12 + 17;
LABEL_18:
      if (v9 > v10)
        goto LABEL_19;
      continue;
    }
    break;
  }
  v17 = v9[17 * v11 + 1 + (int)(a2 - v13)];
  if (v17 && (unsigned __int16)(v17 - 256) <= 0x7431u && (unsigned __int16)(v17 - 12111) <= 0xF9D1u)
  {
    v18 = v17 >> 8;
    v19 = v17 & 0x7F;
    if ((v17 & 0x100) != 0)
      v20 = 31;
    else
      v20 = 125;
    v15 = v20 + v19;
    v16 = (v18 + 479) >> 1;
    v21 = v16 - 127;
    v22 = (v16 - 127);
    if (v15 > 0x7E)
      LOBYTE(v15) = v15 + 1;
    LOBYTE(v16) = v16 - 63;
    if (v22 <= 0x9F)
      LOBYTE(v16) = v21;
    goto LABEL_37;
  }
LABEL_19:
  if ((unsigned __int16)(a2 + 0x2000) > 0x757u)
    return 0;
  if ((a2 - 57344) % 0xBC <= 0x3E)
    v14 = a2 + 68 * ((a2 - 57344) / 0xBC);
  else
    v14 = a2 + 68 * ((a2 - 57344) / 0xBC) + 1;
  *(_WORD *)a3 = bswap32(v14 + 4160) >> 16;
  return 2;
}

uint64_t __CFFromDOSJapanese(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4)
{
  int v5;
  int v7;
  unsigned int v8;
  __int16 v9;
  unsigned int v10;
  int v11;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned int v16;
  __int16 v17;

  v5 = *a2;
  if (((char)*a2 & 0x80000000) == 0)
  {
    *a4 = v5;
    return 1;
  }
  if ((v5 + 95) <= 0x3Eu)
  {
    *a4 = v5 - 320;
    return 1;
  }
  if (a3 < 2)
    return 0;
  v7 = a2[1];
  v8 = v7 | (v5 << 8);
  if ((int)v8 <= 33147)
  {
    switch(v8)
    {
      case 0x815Cu:
        v9 = 8213;
        goto LABEL_29;
      case 0x815Du:
      case 0x815Eu:
      case 0x815Fu:
      case 0x8162u:
        goto LABEL_20;
      case 0x8160u:
        v9 = -162;
        goto LABEL_29;
      case 0x8161u:
        v9 = 8741;
        goto LABEL_29;
      case 0x8163u:
        v9 = 8230;
        goto LABEL_29;
      default:
        if (v8 != 33104)
          goto LABEL_20;
        v9 = -29;
        break;
    }
    goto LABEL_29;
  }
  if ((int)v8 > 33169)
  {
    if (v8 == 33170)
    {
      v9 = -31;
      goto LABEL_29;
    }
    if (v8 == 33226)
    {
      v9 = -30;
      goto LABEL_29;
    }
  }
  else
  {
    if (v8 == 33148)
    {
      v9 = -243;
      goto LABEL_29;
    }
    if (v8 == 33169)
    {
      v9 = -32;
LABEL_29:
      *a4 = v9;
      return 2;
    }
  }
LABEL_20:
  if (v7 != 127 && (v5 + 6) >= 0xF6u && (v7 + 3) >= 0x43u)
  {
    v9 = v8 - 68 * (v5 & 0xF) + ((char)v7 >> 7) - 4160;
    goto LABEL_29;
  }
  if (v8 >> 6 <= 0x3B4 && v8 - 34624 > 0x5C)
  {
    v10 = ShiftJISToJIS0208(a2);
    v11 = __CFFromJIS0208(v10);
    *a4 = v11;
    return 2 * (v11 != 65533);
  }
  if (v8 > 0xFC60 || v8 >> 6 < 0x21D)
  {
LABEL_42:
    *a4 = 0;
    return 0;
  }
  v12 = (unsigned __int16 *)&DOSJapanese_to_uni;
  v13 = (unsigned __int16 *)&unk_182DBCBCE;
  while (1)
  {
    v14 = (0xF83E0F83E0F83E1 * (v13 - v12)) >> 1;
    v15 = &v12[33 * v14];
    v16 = *v15;
    if (v16 <= v8)
      break;
    v13 = v15 - 33;
LABEL_41:
    if (v12 > v13)
      goto LABEL_42;
  }
  if (v16 + 32 <= v8)
  {
    v12 = v15 + 33;
    goto LABEL_41;
  }
  v17 = v12[33 * v14 + 1 + (int)(v8 - v16)];
  *a4 = v17;
  if (!v17)
    return 0;
  return 2;
}

uint64_t __CFToShiftJISLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t result;
  unsigned int v4;
  unsigned int v5;
  uint64_t v7;

  for (result = 0; a3; --a3)
  {
    v5 = *a2++;
    v4 = v5;
    if ((unsigned __int16)(v5 + 159) >= 0x3Fu && v4 >= 0xA5)
      v7 = 2;
    else
      v7 = 1;
    result += v7;
  }
  return result;
}

uint64_t __CFFromShiftJISLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;

  if (a3 >= 1)
  {
    result = 0;
    while (1)
    {
      if (((char)*a2 & 0x80000000) == 0)
        goto LABEL_4;
      if (*a2 < 0xA1u)
        break;
      v4 = -1;
      if ((unint64_t)a3 >= 2)
      {
        v5 = 1;
        if (*a2 < 0xE0u)
          goto LABEL_6;
LABEL_14:
        v4 = -2;
        v5 = 2;
        goto LABEL_6;
      }
LABEL_5:
      v5 = 1;
LABEL_6:
      a2 += v5;
      ++result;
      v6 = __OFADD__(a3, v4);
      a3 += v4;
      if ((a3 < 0) ^ v6 | (a3 == 0))
        return result;
    }
    if ((unint64_t)a3 >= 2)
      goto LABEL_14;
LABEL_4:
    v4 = -1;
    goto LABEL_5;
  }
  return 0;
}

uint64_t __CFFromShiftJISFallback(char *a1, uint64_t a2, _WORD *a3, uint64_t a4, _QWORD *a5)
{
  if (a4)
    *a3 = 63;
  *a5 = 1;
  if (*a1 > -1 || a2 < 2)
    return 1;
  else
    return 2;
}

uint64_t __CFToShiftJISPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  int v10;
  uint64_t result;
  char v12;
  char v13[2];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v9 = __CFPrecomposeCharJapanese(a2, 0);
  v10 = __CFToShiftJIS(v9, v9, v13);
  result = 0;
  if (v10)
  {
    v12 = v13[0];
    if (v13[0])
    {
      result = 2;
      *a6 = 2;
      if (a5)
      {
        if (a5 >= 2)
        {
          *a4 = v12;
          a4[1] = v13[1];
          return 2;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

BOOL __CFIsValidCombiningCharJapanese(int a1)
{
  _BOOL8 result;

  result = 1;
  if ((a1 - 774) > 0x32 || ((1 << (a1 - 6)) & 0x4000000000005) == 0)
    return (a1 - 12441) < 2;
  return result;
}

uint64_t __CFToJIS(unsigned int a1, int a2)
{
  unsigned __int16 *v2;
  unsigned __int16 *v3;
  uint64_t v4;
  unsigned __int16 *v5;
  unsigned int v6;
  uint64_t result;
  uint64_t v8;

  if ((unsigned __int16)(a1 + 12) < 0xACu)
    return 65533;
  v2 = (unsigned __int16 *)&__CFToJISCharMap;
  v3 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (1)
  {
    v4 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v3 - v2)) >> 1;
    v5 = &v2[17 * v4];
    v6 = *v5;
    if (v6 <= a1)
      break;
    v3 = v5 - 17;
LABEL_7:
    if (v2 > v3)
      return 65533;
  }
  if (v6 + 16 <= a1)
  {
    v2 = v5 + 17;
    goto LABEL_7;
  }
  v8 = v2[17 * v4 + 1 + (int)(a1 - v6)];
  if (!(_DWORD)v8)
    return 65533;
  if (!a2)
    return v8;
  result = 65533;
  if (v8 <= 0x7531 && (v8 - 10529) >= 0x62E)
    return v8;
  return result;
}

uint64_t JIS0208ToShiftJIS(uint64_t result, _BYTE *a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;
  char v5;
  unsigned int v6;
  char v7;

  if ((result & 0x100) != 0)
    v2 = 31;
  else
    v2 = 125;
  v3 = v2 + (result & 0x7F);
  v4 = ((result >> 8) + 479) >> 1;
  v5 = v4 - 127;
  v6 = (v4 - 127);
  if (v3 > 0x7E)
    LOBYTE(v3) = v3 + 1;
  v7 = v4 - 63;
  if (v6 <= 0x9F)
    v7 = v5;
  *a2 = v7;
  a2[1] = v3;
  return result;
}

uint64_t __CFFromJIS0208(unsigned int a1)
{
  unsigned __int16 *v1;
  unsigned __int16 *v2;
  uint64_t v3;
  unsigned __int16 *v4;
  unsigned int v5;
  unsigned __int16 v6;

  if (a1 - 30067 < 0xFFFFABAE)
    return (unsigned __int16)-3;
  v1 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
  v2 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
  while (1)
  {
    v3 = (0xF83E0F83E0F83E1 * (v2 - v1)) >> 1;
    v4 = &v1[33 * v3];
    v5 = *v4;
    if (v5 <= a1)
      break;
    v2 = v4 - 33;
LABEL_7:
    if (v1 > v2)
      return (unsigned __int16)-3;
  }
  if (v5 + 32 <= a1)
  {
    v1 = v4 + 33;
    goto LABEL_7;
  }
  v6 = v1[33 * v3 + 1 + (int)(a1 - v5)];
  if (!v6)
    return (unsigned __int16)-3;
  return v6;
}

uint64_t ShiftJISToJIS0208(unsigned __int8 *a1)
{
  unsigned int v1;
  __int16 v2;
  __int16 v3;
  unsigned int v4;
  BOOL v5;
  __int16 v6;
  char v7;

  v1 = *a1;
  if (v1 >= 0xA0)
    v2 = 79;
  else
    v2 = 15;
  v3 = v2 + v1;
  v4 = (a1[1] + ((char)a1[1] >> 7));
  v5 = v4 > 0x9D;
  if (v4 <= 0x9D)
    v6 = (2 * (v3 & 0x1FF)) | 1;
  else
    v6 = 2 * v3 + 2;
  if (v5)
    v7 = -125;
  else
    v7 = -31;
  return (unsigned __int16)((v7 + a1[1] + ((char)a1[1] >> 7)) | (unsigned __int16)((v6 & 0x7FF) << 8));
}

uint64_t __CFToShiftJIS(uint64_t a1, unsigned int a2, char *a3)
{
  char v4;
  unsigned int v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  unsigned int v10;
  uint64_t v11;
  BOOL v12;
  unsigned int v13;

  if ((int)a2 <= 164)
  {
    if (a2 == 92)
    {
      LOWORD(v5) = 24449;
      goto LABEL_11;
    }
    if (a2 == 126)
      return 0;
    goto LABEL_8;
  }
  if (a2 == 165)
  {
    v4 = 92;
    goto LABEL_16;
  }
  if (a2 == 8254)
  {
    v4 = 126;
LABEL_16:
    *a3 = v4;
    return 1;
  }
LABEL_8:
  if (a2 <= 0x7F)
  {
    *a3 = a2;
    return 1;
  }
  if ((unsigned __int16)(a2 + 159) <= 0x3Eu)
  {
    v4 = a2 + 64;
    goto LABEL_16;
  }
  if ((unsigned __int16)(a2 + 12) < 0xACu)
    return 0;
  v6 = (unsigned __int16 *)&__CFToJISCharMap;
  v7 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (1)
  {
    v8 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v7 - v6)) >> 1;
    v9 = &v6[17 * v8];
    v10 = *v9;
    if (v10 <= a2)
      break;
    v7 = v9 - 17;
LABEL_24:
    if (v6 > v7)
      goto LABEL_33;
  }
  if (v10 + 16 <= a2)
  {
    v6 = v9 + 17;
    goto LABEL_24;
  }
  v11 = v6[17 * v8 + 1 + (int)(a2 - v10)];
  if (v6[17 * v8 + 1 + (int)(a2 - v10)])
    v12 = v11 > 0x7531;
  else
    v12 = 1;
  if (!v12 && (unsigned __int16)(v11 - 10529) >= 0x62Eu)
  {
    if (v11 < 0x100)
      return 0;
    JIS0208ToShiftJIS(v11, a3);
    return 2;
  }
LABEL_33:
  if ((unsigned __int16)(a2 + 0x2000) > 0x98Bu)
    return 0;
  if ((a2 - 57344) % 0xBC <= 0x3E)
    v13 = a2 + 68 * ((a2 - 57344) / 0xBC);
  else
    v13 = a2 + 68 * ((a2 - 57344) / 0xBC) + 1;
  v5 = bswap32(v13 + 4160) >> 16;
LABEL_11:
  *(_WORD *)a3 = v5;
  return 2;
}

uint64_t __CFPrecomposeCharJapanese(unsigned __int16 *a1, int a2)
{
  int v2;
  unsigned int v3;
  unsigned __int16 v4;
  uint64_t v6;
  BOOL v7;
  unsigned __int16 v8;

  v2 = *a1;
  v3 = a1[1];
  if (v3 > 0x337)
  {
    if (v3 == 824)
    {
      if (v2 == 61)
        return 8800;
    }
    else
    {
      if (v3 != 12441)
      {
        if (v3 == 12442
          && ((v2 - 12399) <= 0xC && ((1 << (v2 - 111)) & 0x1249) != 0
           || (v2 - 12495) <= 0xC && ((1 << (v2 + 49)) & 0x1249) != 0))
        {
          return (unsigned __int16)(v2 + 2);
        }
        return (unsigned __int16)-3;
      }
      if (*a1 > 0x309Cu)
      {
        v6 = (v2 - 12445);
        if (v6 > 0x3E)
          goto LABEL_32;
        if (((1 << (v2 + 99)) & 0x49240A9555554001) == 0)
        {
          if (v6 == 9)
          {
            v7 = a2 == 0;
            v8 = 12532;
            goto LABEL_41;
          }
LABEL_32:
          switch(*a1)
          {
            case 0x30EFu:
              v7 = a2 == 0;
              v8 = 12535;
              goto LABEL_41;
            case 0x30F0u:
              v7 = a2 == 0;
              v8 = 12536;
              goto LABEL_41;
            case 0x30F1u:
              v7 = a2 == 0;
              v8 = 12537;
              goto LABEL_41;
            case 0x30F2u:
              v7 = a2 == 0;
              v8 = 12538;
              goto LABEL_41;
            default:
              if (v2 != 12541)
                return (unsigned __int16)-3;
              v7 = a2 == 0;
              v8 = 12542;
              break;
          }
          goto LABEL_41;
        }
        return (unsigned __int16)(v2 + 1);
      }
      if ((v2 - 12358) <= 0x35)
      {
        if (((1 << (v2 - 70)) & 0x2492054AAAAAA0) != 0)
          return (unsigned __int16)(v2 + 1);
        if (v2 == 12358)
        {
          v7 = a2 == 0;
          v8 = 12436;
LABEL_41:
          if (v7)
            return (unsigned __int16)-3;
          else
            return v8;
        }
      }
    }
    return (unsigned __int16)-3;
  }
  if (v3 == 774)
  {
    if ((v2 & 0xFFFFFFDF) == 0x418)
      return (unsigned __int16)(v2 + 1);
    return (unsigned __int16)-3;
  }
  if (v3 != 776)
    return (unsigned __int16)-3;
  if (v2 == 1077)
    v4 = 1105;
  else
    v4 = -3;
  if (v2 == 1045)
    return 1025;
  else
    return v4;
}

uint64_t __CFToEUC_JP(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  uint64_t result;
  __int16 v4;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;
  int v10;

  if (a2 <= 0x7F)
  {
    *a3 = a2;
    return 1;
  }
  if ((unsigned __int16)(a2 + 159) <= 0x3Eu)
  {
    *a3 = -114;
    LOBYTE(v4) = a2 + 64;
    goto LABEL_5;
  }
  if ((unsigned __int16)(a2 + 12) < 0xACu)
    return 0;
  v5 = (unsigned __int16 *)&__CFToJISCharMap;
  v6 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
  while (1)
  {
    v7 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v6 - v5)) >> 1;
    v8 = &v5[17 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 17;
LABEL_13:
    if (v5 > v6)
      return 0;
  }
  if (v9 + 16 <= a2)
  {
    v5 = v8 + 17;
    goto LABEL_13;
  }
  v10 = v5[17 * v7 + 1 + (int)(a2 - v9)];
  if (!v10)
    return 0;
  result = 0;
  if ((v10 - 30002) >= 0xFFFF8BCE && (v10 - 10529) >= 0x62E)
  {
    v4 = v10 | 0x8080;
    *a3 = HIBYTE(v4);
LABEL_5:
    a3[1] = v4;
    return 2;
  }
  return result;
}

uint64_t __CFFromEUC_JP(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4)
{
  int v4;
  __int16 v6;
  unsigned int v7;
  unsigned int v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  uint64_t v11;
  unsigned __int16 *v12;
  unsigned int v13;
  unsigned int v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  uint64_t v17;
  unsigned __int16 *v18;
  unsigned int v19;
  uint64_t v20;
  unsigned __int16 v21;

  v4 = *a2;
  if (((char)*a2 & 0x80000000) == 0)
  {
    *a4 = v4;
    return 1;
  }
  switch(v4)
  {
    case 160:
      if (a3 < 2)
        return 0;
      v6 = 169;
      goto LABEL_10;
    case 143:
      if (a3 < 3)
        return 0;
      v7 = *(unsigned __int16 *)(a2 + 1);
      if ((unsigned __int16)((bswap32(v7) >> 16) + 4638) >= 0xB4CDu)
      {
        v8 = __rev16(v7);
        v9 = (unsigned __int16 *)&__CFFromJIS0212CharMap;
        v10 = (unsigned __int16 *)((char *)&__CFFromJIS0212CharMap + 13002);
        do
        {
          v11 = (0xF83E0F83E0F83E1 * (v10 - v9)) >> 1;
          v12 = &v9[33 * v11];
          v13 = *v12;
          if (v13 <= v8)
          {
            if (v13 + 32 > v8)
            {
              v20 = (uint64_t)&v9[33 * v11 + (int)(v8 - v13)];
              goto LABEL_32;
            }
            v9 = v12 + 33;
          }
          else
          {
            v10 = v12 - 33;
          }
        }
        while (v9 <= v10);
      }
      goto LABEL_35;
    case 142:
      if (a3 < 2)
        return 0;
      v6 = a2[1] - 320;
LABEL_10:
      *a4 = v6;
      return 2;
  }
  if (a3 < 2)
    return 0;
  v14 = a2[1] & 0x7F | ((v4 & 0x7F) << 8);
  if ((unsigned __int16)(v14 - 30067) < 0xABAEu)
    goto LABEL_35;
  v15 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
  v16 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
  while (1)
  {
    v17 = (0xF83E0F83E0F83E1 * (v16 - v15)) >> 1;
    v18 = &v15[33 * v17];
    v19 = *v18;
    if (v19 <= v14)
      break;
    v16 = v18 - 33;
LABEL_28:
    if (v15 > v16)
      goto LABEL_35;
  }
  if (v19 + 32 <= v14)
  {
    v15 = v18 + 33;
    goto LABEL_28;
  }
  v20 = (uint64_t)&v15[33 * v17 + (int)(v14 - v19)];
LABEL_32:
  v21 = *(_WORD *)(v20 + 2);
  if (!v21)
  {
LABEL_35:
    *a4 = -3;
    return 0;
  }
  *a4 = v21;
  if (v21 != 65533)
    return 2;
  return 0;
}

unint64_t __CFToEUC_JPLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  if (!a3)
  {
    v7 = 0;
    v3 = 0;
    v4 = 0;
LABEL_13:
    v9 = v3 - v7;
    v8 = 3 * v7 + v4;
    return v8 + 2 * v9;
  }
  v3 = 0;
  v4 = 0;
  do
  {
    v6 = *a2++;
    v5 = v6;
    if (v6 < 0x80)
      ++v4;
    if (v5 > 0x7F)
      ++v3;
    --a3;
  }
  while (a3);
  v7 = v3 / 3;
  if (v4 <= v3 / 3)
    goto LABEL_13;
  v8 = v4 - v7;
  if (v3 < 3)
    v7 = 1;
  v9 = v7 + v3;
  return v8 + 2 * v9;
}

uint64_t __CFFromEUC_JPLen(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v4;
  int v5;
  _BOOL4 v6;
  _BOOL4 v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  BOOL v13;

  if (a3 < 1)
    return 0;
  result = 0;
  do
  {
    v4 = -1;
    if (a3 == 1)
    {
      v12 = 1;
    }
    else
    {
      v5 = *a2;
      v6 = v5 == -113;
      v7 = (unint64_t)a3 > 2;
      v8 = !v7 || !v6;
      if (v7 && v6)
        v9 = 3;
      else
        v9 = 2;
      if (v8)
        v10 = -2;
      else
        v10 = -3;
      v11 = v5 >= 0;
      if (v5 < 0)
        v12 = v9;
      else
        v12 = 1;
      if (!v11)
        v4 = v10;
    }
    a2 += v12;
    ++result;
    v13 = __OFADD__(a3, v4);
    a3 += v4;
  }
  while (!((a3 < 0) ^ v13 | (a3 == 0)));
  return result;
}

uint64_t __CFFromEUC_JPFallback(unsigned __int8 *a1, uint64_t a2, _WORD *a3, uint64_t a4, _QWORD *a5)
{
  int v5;
  int v6;
  BOOL v7;
  uint64_t v8;

  if (a4)
    *a3 = 63;
  *a5 = 1;
  v5 = *a1;
  v6 = (char)v5;
  v7 = v5 != 143 || a2 <= 2;
  v8 = 2;
  if (!v7)
    v8 = 3;
  if (v6 > -1 || a2 < 2)
    return 1;
  else
    return v8;
}

uint64_t __CFToEUC_JPPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  int v10;
  uint64_t result;
  char v12;
  _BYTE v13[2];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (*a2 > 0x7Fu)
    v9 = __CFPrecomposeCharJapanese(a2, 0);
  else
    v9 = __CFStringEncodingPrecomposeLatinCharacter_6(a2, a3, 0);
  v10 = __CFToEUC_JP(v9, v9, v13);
  result = 0;
  if (v10)
  {
    v12 = v13[0];
    if (v13[0])
    {
      result = 2;
      *a6 = 2;
      if (a5)
      {
        if (a5 >= 2)
        {
          *a4 = v12;
          a4[1] = v13[1];
          return 2;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t __CFIsValidCombiningCharJapaneseWithJIS212(int a1)
{
  if ((a1 - 774) <= 0x32 && ((1 << (a1 - 6)) & 0x4000000000005) != 0
    || (a1 - 12441) < 2)
  {
    return 1;
  }
  else
  {
    return __CFStringEncodingIsValidCombiningCharacterForLatin1_4();
  }
}

uint64_t __CFToISO_2022_JP(char a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  BOOL v15;
  uint64_t v17;
  char v18;
  unsigned __int16 *v19;
  unsigned __int16 *v20;
  uint64_t v21;
  unsigned __int16 *v22;
  unsigned int v23;
  unsigned int v24;
  BOOL v25;
  int IsValidCombiningCharacterForLatin1_4;
  uint64_t v27;
  unsigned __int16 *v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  __int16 v32;
  char **v33;
  uint64_t v34;
  char **v35;
  uint64_t v36;
  char *v37;
  __int16 v38;
  char **v39;
  char *v40;
  char *v41;
  __int16 v42;
  char **v43;
  char *v44;
  uint64_t (**v45)(void);
  uint64_t v46;
  uint64_t v47;
  int v48;
  char v51;
  _QWORD *v53;
  uint64_t v54;

  if (a3 < 1)
  {
    v8 = 0;
    v46 = 0;
    goto LABEL_142;
  }
  v8 = a3;
  v53 = a6;
  v9 = a2 - 2;
  v54 = a2;
  while (2)
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    while (2)
    {
      if (a5 && a5 <= v11)
      {
        if ((a1 & 0x10) == 0)
          goto LABEL_116;
        v14 = *(unsigned __int16 *)(a2 + 2 * v12);
        v15 = v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0;
        if (v15 && v14 - 12441 >= 2)
          goto LABEL_116;
      }
      else
      {
        v14 = *(unsigned __int16 *)(a2 + 2 * v12);
        if (v14 <= 0x7F)
        {
          v10 = v13 != 0;
          if (v13)
            v17 = 4;
          else
            v17 = 1;
          if (!a5)
          {
            v13 = 0;
            goto LABEL_114;
          }
          if (a5 - v11 >= v17)
          {
            if (v13)
            {
              *a4 = 27;
              *(_WORD *)(a4 + 1) = 16936;
              a4 += 3;
            }
            v13 = 0;
            *a4++ = v14;
            goto LABEL_114;
          }
          goto LABEL_116;
        }
      }
      if ((unsigned __int16)(v14 + 159) <= 0x3Eu)
      {
        v10 = v13 != 3;
        if (v13 == 3)
          v17 = 1;
        else
          v17 = 4;
        if (a5)
        {
          if (a5 - v11 < v17)
            goto LABEL_116;
          if (v13 != 3)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 18728;
            a4 += 3;
          }
          *a4++ = v14 - 64;
        }
        v13 = 3;
        goto LABEL_114;
      }
      if (v14 == 8254 || v14 == 165)
      {
        v10 = v13 != 2;
        if (v13 == 2)
          v17 = 1;
        else
          v17 = 4;
        if (a5)
        {
          if (a5 - v11 < v17)
            goto LABEL_116;
          if (v13 != 2)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 18984;
            a4 += 3;
          }
          if (v14 == 165)
            v18 = 92;
          else
            v18 = 126;
          *a4++ = v18;
        }
        v13 = 2;
        goto LABEL_114;
      }
      if ((unsigned __int16)(v14 + 12) < 0xACu)
        break;
      v19 = (unsigned __int16 *)&__CFToJISCharMap;
      v20 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
      while (1)
      {
        v21 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v20 - v19)) >> 1;
        v22 = &v19[17 * v21];
        v23 = *v22;
        if (v23 <= v14)
          break;
        v20 = v22 - 17;
LABEL_55:
        if (v19 > v20)
          goto LABEL_72;
      }
      if (v23 + 16 <= v14)
      {
        v19 = v22 + 17;
        goto LABEL_55;
      }
      v24 = v19[17 * v21 + 1 + (int)(v14 - v23)];
      if (v19[17 * v21 + 1 + (int)(v14 - v23)])
        v25 = v24 > 0x7531;
      else
        v25 = 1;
      if (!v25 && v24 - 10529 >= 0x62E)
      {
        if (v24 < 0x100)
          goto LABEL_116;
        v10 = v13 != 1;
        if (v13 == 1)
          v17 = 2;
        else
          v17 = 5;
        if (!a5)
          goto LABEL_102;
        if (a5 - v11 < v17)
          goto LABEL_116;
        if (v13 != 1)
        {
          *a4 = 27;
          *(_WORD *)(a4 + 1) = 16932;
          a4 += 3;
        }
        *a4 = BYTE1(v24);
        a4[1] = v24 & 0x7F;
        a4 += 2;
LABEL_102:
        v13 = 1;
LABEL_114:
        v11 += v17;
        if (++v12 == v8)
        {
LABEL_117:
          v45 = (uint64_t (**)(void))&unk_1EDCD1000;
          if (v13)
            goto LABEL_118;
LABEL_139:
          v46 = v11;
          goto LABEL_141;
        }
        continue;
      }
      break;
    }
LABEL_72:
    if ((a1 & 8) != 0)
      goto LABEL_116;
    if ((v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0) && v14 - 12441 >= 2)
    {
      IsValidCombiningCharacterForLatin1_4 = __CFStringEncodingIsValidCombiningCharacterForLatin1_4();
      a2 = v54;
      if (!IsValidCombiningCharacterForLatin1_4)
        goto LABEL_116;
    }
    if ((a1 & 0x10) == 0)
    {
      v17 = 0;
      goto LABEL_114;
    }
    if (!v12)
    {
      v8 = 0;
      goto LABEL_117;
    }
    v27 = a2 + 2 * v12;
    v29 = *(unsigned __int16 *)(v27 - 2);
    v28 = (unsigned __int16 *)(v27 - 2);
    if (v29 > 0x7F)
      v30 = __CFPrecomposeCharJapanese(v28, 0);
    else
      v30 = __CFStringEncodingPrecomposeLatinCharacter_6(v28, v8 + 1 - v12, 0);
    v31 = __CFToJIS(v30, 1);
    if (v31 && v31 != 65533)
    {
      v32 = v31;
      a2 = v54;
      if (((__int16)v31 & 0x80000000) == 0)
      {
        if (v13 == 1)
        {
          v17 = 0;
          v33 = 0;
          v10 = 0;
          v34 = 2;
          if (!a5)
            goto LABEL_102;
        }
        else
        {
          if (v13)
            v34 = 2;
          else
            v34 = 1;
          if (v10)
            v34 += LOBYTE((&__CFISO2022JPSequences)[2 * v13 + 1]) + 1;
          v17 = 5 - v34;
          v10 = 1;
          v33 = &off_1E1333CA8;
          if (!a5)
            goto LABEL_102;
        }
        if (a5 - v11 >= v17)
        {
          v37 = &a4[-v34];
          if (v13 != 1)
          {
            *v37 = 27;
            v38 = v32;
            v39 = v33;
            v40 = strncpy(v37 + 1, *v33, *((unsigned __int8 *)v33 + 8));
            v32 = v38;
            a2 = v54;
            v37 = &v40[*((unsigned __int8 *)v39 + 8)];
          }
          *v37 = HIBYTE(v32);
          a4 = v37 + 2;
          v37[1] = v32 & 0x7F;
          goto LABEL_102;
        }
        goto LABEL_116;
      }
      if (v13 == 4)
      {
        v17 = 0;
        v35 = 0;
        v10 = 0;
        v36 = 2;
        if (!a5)
        {
LABEL_113:
          v13 = 4;
          goto LABEL_114;
        }
      }
      else
      {
        if (v13)
          v36 = 2;
        else
          v36 = 1;
        if (v10)
          v36 += LOBYTE((&__CFISO2022JPSequences)[2 * v13 + 1]) + 1;
        v17 = 6 - v36;
        v10 = 1;
        v35 = &off_1E1333CD8;
        if (!a5)
          goto LABEL_113;
      }
      if (a5 - v11 >= v17)
      {
        v41 = &a4[-v36];
        if (v13 != 4)
        {
          *v41 = 27;
          v42 = v32;
          v43 = v35;
          v44 = strncpy(v41 + 1, *v35, *((unsigned __int8 *)v35 + 8));
          v32 = v42;
          a2 = v54;
          v41 = &v44[*((unsigned __int8 *)v43 + 8)];
        }
        *v41 = HIBYTE(v32) & 0x7F;
        a4 = v41 + 2;
        v41[1] = v32 & 0x7F;
        goto LABEL_113;
      }
LABEL_116:
      v8 = v12;
      goto LABEL_117;
    }
    v8 = v12;
    a2 = v54;
    v45 = (uint64_t (**)(void))&unk_1EDCD1000;
    if (!v13)
      goto LABEL_139;
LABEL_118:
    v46 = v11 + 3;
    if (a5)
    {
      if (v46 <= a5)
      {
        *a4 = 27;
        *(_WORD *)(a4 + 1) = 16936;
        break;
      }
      do
      {
        v47 = v8;
        v48 = *(unsigned __int16 *)(v9 + 2 * v8);
        if (((v48 - 774) > 0x32 || ((1 << (v48 - 6)) & 0x4000000000005) == 0)
          && (v48 - 12441) >= 2)
        {
          v51 = v45[107]();
          a2 = v54;
        }
        else
        {
          v51 = 1;
        }
        --v8;
      }
      while (v47 >= 2 && (v51 & 1) != 0);
      if (v47 < 2)
      {
        v46 = 0;
        break;
      }
      a4 -= v11;
      continue;
    }
    break;
  }
LABEL_141:
  a6 = v53;
LABEL_142:
  *a6 = v46;
  return v8;
}

uint64_t __CFFromISO_2022_JP(unsigned int a1, const char *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, _QWORD *a6)
{
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  const char *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t i;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unsigned __int16 *v25;
  unsigned __int16 *v26;
  uint64_t v27;
  unsigned __int16 *v28;
  unsigned int v29;
  __int16 v30;
  unsigned int v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  uint64_t v34;
  unsigned __int16 *v35;
  unsigned int v36;
  unsigned __int16 v37;
  unsigned __int16 v39;
  BOOL v41;
  int v44;
  unsigned __int16 *v46;
  unint64_t v47;

  v6 = a6;
  v7 = (unint64_t)&a2[a3];
  if (__CFADD__(a2, a3))
  {
    v8 = 0;
    v9 = 0;
    if (a6)
      goto LABEL_101;
    return v9;
  }
  v10 = a3;
  if (a3 < 1)
  {
    v8 = 0;
    v9 = 0;
    goto LABEL_101;
  }
  v13 = a2;
  v14 = 0;
  v8 = 0;
  v9 = 0;
  v44 = a1 & 0xC0;
  while (2)
  {
    if (a5 && v8 >= a5)
      goto LABEL_93;
    v15 = *(unsigned __int8 *)v13;
    if (v15 == 27)
    {
      v46 = a4;
      v47 = v10;
      v16 = v9;
      v17 = a5;
      v18 = v8;
      v19 = v14;
      for (i = 0; i != 18; i += 2)
      {
        v21 = LOBYTE((&__CFISO2022JPSequences)[i + 1]);
        if (v7 >= (unint64_t)&v13[v21 + 1]
          && !strncmp((&__CFISO2022JPSequences)[i], v13 + 1, LOBYTE((&__CFISO2022JPSequences)[i + 1])))
        {
          v14 = *((unsigned __int8 *)&__CFISO2022JPSequences + 8 * i + 9);
          v23 = v21 + 1;
          v8 = v18;
          a5 = v17;
          v9 = v16;
          a4 = v46;
          v10 = v47;
          goto LABEL_85;
        }
      }
      v14 = v19;
      if ((v19 & 0xFD) == 0)
      {
        v22 = v18;
        a5 = v17;
        if (v17)
        {
          *v46 = 27;
          a4 = v46 + 1;
          v9 = v16;
        }
        else
        {
          v9 = v16;
          a4 = v46;
        }
        v10 = v47;
        v8 = v22 + 1;
        v23 = 1;
        goto LABEL_85;
      }
      v8 = v18;
      a5 = v17;
      v9 = v16;
      v10 = v47;
      goto LABEL_93;
    }
    switch((int)v14)
    {
      case 0:
        if (!a5)
          goto LABEL_43;
        goto LABEL_42;
      case 1:
        if (v10 < 2)
          goto LABEL_92;
        v24 = *((unsigned __int8 *)v13 + 1) | (v15 << 8);
        if (v24 - 30067 < 0xFFFFABAE)
          goto LABEL_58;
        v25 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
        v26 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
        while (2)
        {
          v27 = (0xF83E0F83E0F83E1 * (v26 - v25)) >> 1;
          v28 = &v25[33 * v27];
          v29 = *v28;
          if (v29 <= v24)
          {
            if (v29 + 32 > v24)
            {
              v37 = v25[33 * v27 + 1 + (int)(v24 - v29)];
              if (v37 == 65533 || v37 == 0)
              {
LABEL_58:
                if ((a1 & 1) == 0)
                  goto LABEL_91;
                v37 = 63;
              }
              if (!v44 || !__CFStringEncodingIsDecomposableCharacter_2(v37, (a1 >> 7) & 1))
              {
                if (a5)
                  *a4++ = v37;
                v23 = 2;
                goto LABEL_84;
              }
              if (!a5)
              {
                ++v8;
                v23 = 2;
                goto LABEL_84;
              }
              if (v8 + 2 <= a5)
              {
                __CFStringEncodingDecomposeCharacter_2(a1, v37, a4);
                ++v8;
                v23 = 2;
                a4 += 2;
                goto LABEL_84;
              }
              return v9;
            }
            v25 = v28 + 33;
          }
          else
          {
            v26 = v28 - 33;
          }
          if (v25 > v26)
            goto LABEL_58;
          continue;
        }
      case 2:
        if (!a5)
          goto LABEL_43;
        if (v15 == 126)
          v30 = 8254;
        else
          v30 = *(unsigned __int8 *)v13;
        if (v15 == 92)
          LOWORD(v15) = 165;
        else
          LOWORD(v15) = v30;
        goto LABEL_42;
      case 3:
        if ((v15 - 96) < 0xFFFFFFC1)
          goto LABEL_91;
        if (!a5)
          goto LABEL_43;
        LOWORD(v15) = v15 - 192;
LABEL_42:
        *a4++ = v15;
LABEL_43:
        v23 = 1;
        goto LABEL_84;
      case 4:
        if (v10 < 2)
        {
LABEL_92:
          LODWORD(v14) = 4;
          v10 = 1;
          goto LABEL_93;
        }
        v31 = *((unsigned __int8 *)v13 + 1) | (v15 << 8);
        if ((unsigned __int16)(v31 + 4638) < 0xB4CDu)
          goto LABEL_73;
        v32 = (unsigned __int16 *)&__CFFromJIS0212CharMap;
        v33 = (unsigned __int16 *)((char *)&__CFFromJIS0212CharMap + 13002);
        while (2)
        {
          v34 = (0xF83E0F83E0F83E1 * (v33 - v32)) >> 1;
          v35 = &v32[33 * v34];
          v36 = *v35;
          if (v36 > v31)
          {
            v33 = v35 - 33;
            goto LABEL_51;
          }
          if (v36 + 32 <= v31)
          {
            v32 = v35 + 33;
LABEL_51:
            if (v32 > v33)
              goto LABEL_73;
            continue;
          }
          break;
        }
        v39 = v32[33 * v34 + 1 + (int)(v31 - v36)];
        if (v39 != 65533 && v39 != 0)
        {
LABEL_75:
          if (!v44 || !__CFStringEncodingIsDecomposableCharacter_2(v39, (a1 >> 7) & 1))
          {
            if (a5)
              *a4++ = v39;
            goto LABEL_83;
          }
          if (!a5)
            goto LABEL_80;
          if (v8 >= a5)
            return v9;
          __CFStringEncodingDecomposeCharacter_2(a1, v39, a4);
          a4 += 2;
LABEL_80:
          ++v8;
LABEL_83:
          v23 = 2;
LABEL_84:
          ++v8;
LABEL_85:
          v9 += v23;
          v13 += v23;
          v41 = (uint64_t)v10 <= v23;
          v10 -= v23;
          if (v41)
            goto LABEL_93;
          continue;
        }
LABEL_73:
        if ((a1 & 1) != 0)
        {
          v39 = 63;
          goto LABEL_75;
        }
LABEL_91:
        LODWORD(v14) = 4;
LABEL_93:
        v6 = a6;
        if (a5
          && (_DWORD)v14
          && v10 == 3
          && v8 == a5
          && *v13 == 27
          && v7 >= (unint64_t)(v13 + 3)
          && !strncmp("(B", v13 + 1, 2uLL))
        {
          v9 += 3;
        }
LABEL_101:
        *v6 = v8;
        return v9;
      default:
        goto LABEL_93;
    }
  }
}

uint64_t __CFToMacJapanese(uint64_t a1, unsigned __int16 *a2, uint64_t a3, char *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v7;
  uint64_t v8;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unsigned int v14;
  uint64_t v17;
  unsigned __int16 *v18;
  unsigned __int16 *v19;
  uint64_t v20;
  unsigned __int16 *v21;
  unsigned int v22;
  _BOOL4 v24;
  int v25;
  unsigned __int16 *v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  _QWORD *v36;
  unsigned int v37;
  unsigned __int16 v38;
  uint64_t v39;
  char v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned __int16 v45;
  int v46;
  unsigned __int16 *v47;
  uint64_t v48;
  int v49;
  char v50;
  int v52;
  unsigned __int16 *v53;
  uint64_t v54;
  int v55;
  int v56;
  unsigned __int16 *v57;
  uint64_t v58;
  int v59;
  int v60;
  unsigned int v61;
  unsigned int v62;
  char v63;
  unsigned int v64;
  char v65;
  int v67;
  uint64_t v68;

  if (a3 < 1)
  {
    v11 = 0;
    v12 = 0;
    goto LABEL_238;
  }
  v7 = 0;
  v8 = 0;
  v67 = a1 & 0x480;
  v9 = (unsigned __int16 *)&__CFToJISCharMap;
  v10 = 0x4E4Bu;
LABEL_3:
  v11 = v7;
  v12 = v8;
  v13 = a2;
  while (1)
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0)
        goto LABEL_238;
      v14 = *v13;
      if (v14 - 774 <= 0x32 && ((1 << (v14 - 6)) & 0x4000000000005) != 0 || v14 - 12441 < 2)
        goto LABEL_20;
      if (v14 != 8413 && (v14 & 0xFFF0) != 0xF870)
        goto LABEL_238;
    }
    else
    {
      v14 = *v13;
    }
    if (v14 <= 0x7F)
    {
      v7 = v11 + 1;
      if (!a5)
        goto LABEL_232;
      if (v14 != 92 || v67 == 1024)
        v40 = v14;
      else
        v40 = 0x80;
      goto LABEL_114;
    }
LABEL_20:
    if ((unsigned __int16)(v14 + 159) <= 0x3Eu)
    {
      v7 = v11 + 1;
      if (!a5)
        goto LABEL_232;
      v40 = v14 + 64;
LABEL_114:
      *a4++ = v40;
      goto LABEL_232;
    }
    v17 = v12 + 1;
    if (v12 + 1 < a3 && v14 == 8230)
      break;
    if ((unsigned __int16)(v14 + 12) >= 0xACu)
      goto LABEL_26;
LABEL_33:
    v24 = v12 > 0 || (v14 & 0xFFF0) == 63584;
    if ((a1 & 8) != 0 || !v24)
      goto LABEL_238;
    if ((a1 & 0x10) == 0)
    {
      v13 = a2;
      v12 = v8;
      goto LABEL_232;
    }
    if (v14 != 63615)
    {
      if ((int)v14 <= 12440)
      {
        if (v14 - 774 > 0x32 || ((1 << (v14 - 6)) & 0x4000000000005) == 0)
        {
          if (v14 == 8413)
          {
            v28 = *(v13 - 1);
            switch(v28)
            {
              case 22823:
                LOBYTE(v29) = -111;
                break;
              case 25511:
                LOBYTE(v29) = -99;
                break;
              case 23567:
                LOBYTE(v29) = -110;
                break;
              default:
                goto LABEL_238;
            }
            if (a5)
            {
              v50 = -121;
LABEL_126:
              *(a4 - 2) = v50;
              *(a4 - 1) = v29;
            }
LABEL_231:
            v7 = v11;
LABEL_232:
            a2 = v13 + 1;
            v8 = v12 + 1;
            v11 = v7;
            v12 = v8;
            if (v8 >= a3)
              goto LABEL_238;
            goto LABEL_3;
          }
LABEL_92:
          v7 = v11 + 2;
          if (a5 && v7 > a5)
            goto LABEL_238;
          if (v14 == 63586)
          {
            if (v12 + 5 > a3)
              goto LABEL_238;
            v52 = 34219;
            v53 = (unsigned __int16 *)&__CFF862SeqTable;
LABEL_129:
            v54 = 1;
            do
            {
              if (v13[v54] != v53[v54])
              {
                v55 = v53[5];
                v53 += 5;
                v52 = v55;
                if (v55)
                  goto LABEL_129;
                goto LABEL_238;
              }
              ++v54;
            }
            while ((_DWORD)(v54 * 2) != 10);
            if (!v52)
              goto LABEL_238;
            if (a5)
            {
              *a4 = BYTE1(v52);
              a4[1] = v52;
              a4 += 2;
            }
            v13 += 4;
            v12 += 4;
          }
          else if (v14 == 63585)
          {
            if (v12 + 4 > a3)
              goto LABEL_238;
            v56 = 34220;
            v57 = (unsigned __int16 *)&__CFF861SeqTable;
LABEL_137:
            v58 = 1;
            do
            {
              if (v13[v58] != v57[v58])
              {
                v59 = v57[5];
                v57 += 5;
                v56 = v59;
                if (v59)
                  goto LABEL_137;
                goto LABEL_238;
              }
              ++v58;
            }
            while ((_DWORD)(v58 * 2) != 8);
            if (!v56)
              goto LABEL_238;
            if (a5)
            {
              *a4 = BYTE1(v56);
              a4[1] = v56;
              a4 += 2;
            }
            v13 += 3;
            v12 += 3;
          }
          else
          {
            if (v14 != 63584 || v12 + 3 > a3)
              goto LABEL_238;
            v46 = 34193;
            v47 = (unsigned __int16 *)&__CFF860SeqTable;
LABEL_99:
            v48 = 1;
            do
            {
              if (v13[v48] != v47[v48])
              {
                v49 = v47[5];
                v47 += 5;
                v46 = v49;
                if (v49)
                  goto LABEL_99;
                goto LABEL_238;
              }
              ++v48;
            }
            while ((_DWORD)(v48 * 2) != 6);
            if (!v46)
              goto LABEL_238;
            if (a5)
            {
              *a4 = BYTE1(v46);
              a4[1] = v46;
              a4 += 2;
            }
            v13 += 2;
            v12 += 2;
          }
          goto LABEL_232;
        }
LABEL_70:
        v68 = v12;
        v32 = a5;
        v33 = a1;
        v34 = a3;
        v35 = (char *)v9;
        v36 = a6;
        v37 = __CFPrecomposeCharJapanese(v13 - 1, 1);
        v38 = __CFToJIS(v37, 0);
        if ((v38 & 0x8000) != 0)
        {
          a6 = v36;
          v12 = v68;
          goto LABEL_238;
        }
        if (v32)
        {
          v39 = -2;
          if (*(a4 - 1) == 61)
            v39 = -1;
          JIS0208ToShiftJIS(v38, &a4[v39]);
        }
        a5 = v32;
        v7 = v11;
        a6 = v36;
        v9 = (unsigned __int16 *)v35;
        a3 = v34;
        a1 = v33;
        v12 = v68;
        v10 = 20043;
        goto LABEL_232;
      }
      if (v14 - 12441 < 2)
        goto LABEL_70;
      if (v14 != 63610)
      {
        if (v14 == 63614)
        {
          v30 = *(v13 - 1);
          if (v30 <= 0x30A0)
          {
            if (*(v13 - 1) <= 0x3040u)
            {
              if (*(v13 - 1) > 0x3000u)
              {
                switch(v30)
                {
                  case 0x3001u:
                    v31 = 60225;
                    break;
                  case 0x3002u:
                    v31 = 60226;
                    break;
                  case 0x301Cu:
                    v31 = 60256;
                    break;
                  default:
                    goto LABEL_238;
                }
              }
              else
              {
                switch(v30)
                {
                  case 0x2010u:
                    v31 = 60253;
                    break;
                  case 0x2016u:
                    v31 = 60257;
                    break;
                  case 0x2026u:
                    v31 = 60259;
                    break;
                  default:
                    goto LABEL_238;
                }
              }
            }
            else
            {
              if (*(v13 - 1) <= 0x3062u)
              {
                switch(*(v13 - 1))
                {
                  case 0x3041u:
                    v31 = 60575;
                    goto LABEL_229;
                  case 0x3043u:
                    v31 = 60577;
                    goto LABEL_229;
                  case 0x3045u:
                    v31 = 60579;
                    goto LABEL_229;
                  case 0x3047u:
                    v31 = 60581;
                    goto LABEL_229;
                  case 0x3049u:
                    v31 = 60583;
                    goto LABEL_229;
                  default:
                    goto LABEL_238;
                }
                goto LABEL_238;
              }
              if (*(v13 - 1) <= 0x3084u)
              {
                if (v30 == 12387)
                {
                  v31 = 60609;
                }
                else
                {
                  if (v30 != 12419)
                    goto LABEL_238;
                  v31 = 60641;
                }
              }
              else
              {
                switch(v30)
                {
                  case 0x3085u:
                    v31 = 60643;
                    break;
                  case 0x3087u:
                    v31 = 60645;
                    break;
                  case 0x308Eu:
                    v31 = 60652;
                    break;
                  default:
                    goto LABEL_238;
                }
              }
            }
          }
          else if (*(v13 - 1) > 0x30EDu)
          {
            if (*(v13 - 1) <= 0xFF1Cu)
            {
              if (*(v13 - 1) > 0x30F5u)
              {
                if (v30 == 12534)
                {
                  v31 = 60822;
                }
                else
                {
                  if (v30 != 12540)
                    goto LABEL_238;
                  v31 = 60251;
                }
              }
              else if (v30 == 12526)
              {
                v31 = 60814;
              }
              else
              {
                if (v30 != 12533)
                  goto LABEL_238;
                v31 = 60821;
              }
            }
            else if (*(v13 - 1) <= 0xFF3Cu)
            {
              if (v30 == 65309)
              {
                v31 = 60289;
              }
              else
              {
                if (v30 != 65339)
                  goto LABEL_238;
                v31 = 60269;
              }
            }
            else
            {
              switch(v30)
              {
                case 0xFF3Du:
                  v31 = 60270;
                  break;
                case 0xFF5Cu:
                  v31 = 60258;
                  break;
                case 0xFFE3u:
                  v31 = 60240;
                  break;
                default:
                  goto LABEL_238;
              }
            }
          }
          else
          {
            if (*(v13 - 1) <= 0x30C2u)
            {
              switch(*(v13 - 1))
              {
                case 0x30A1u:
                  v31 = 60736;
                  goto LABEL_229;
                case 0x30A3u:
                  v31 = 60738;
                  goto LABEL_229;
                case 0x30A5u:
                  v31 = 60740;
                  goto LABEL_229;
                case 0x30A7u:
                  v31 = 60742;
                  goto LABEL_229;
                case 0x30A9u:
                  v31 = 60744;
                  goto LABEL_229;
                default:
                  goto LABEL_238;
              }
              goto LABEL_238;
            }
            if (*(v13 - 1) > 0x30E4u)
            {
              if (v30 == 12517)
              {
                v31 = 60805;
              }
              else
              {
                if (v30 != 12519)
                  goto LABEL_238;
                v31 = 60807;
              }
            }
            else if (v30 == 12483)
            {
              v31 = 60770;
            }
            else
            {
              if (v30 != 12515)
                goto LABEL_238;
              v31 = 60803;
            }
          }
LABEL_229:
          if (a5)
            *((_WORD *)a4 - 1) = __rev16(v31);
          goto LABEL_231;
        }
        goto LABEL_92;
      }
      v45 = *(v13 - 1) - 8678;
      if (v45 > 3u)
        goto LABEL_238;
      if (!a5)
        goto LABEL_231;
      v29 = 0xD6D3D5D4 >> (8 * v45);
LABEL_106:
      v50 = -122;
      goto LABEL_126;
    }
    v25 = *(v13 - 1);
    if (v25 != 8230)
    {
      if (v25 == 65351)
      {
        LOBYTE(v29) = 75;
        if (!a5)
          goto LABEL_231;
      }
      else
      {
        if (v25 != 65357)
          goto LABEL_238;
        LOBYTE(v29) = 69;
        if (!a5)
          goto LABEL_231;
      }
      goto LABEL_106;
    }
    if (a5)
      *(a4 - 2) = -1;
    --v11;
    ++v13;
    ++v12;
    if (v17 >= a3)
    {
      if (a3 <= v8 + 1)
        v12 = v8 + 1;
      else
        v12 = a3;
      goto LABEL_238;
    }
  }
  if ((__int16)v13[1] == -1921)
  {
    ++v13;
    v7 = v11 + 1;
    if (a5)
      *a4++ = -1;
    ++v12;
    goto LABEL_232;
  }
LABEL_26:
  v18 = &v9[v10];
  v19 = v9;
  while (2)
  {
    v20 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v18 - v19)) >> 1;
    v21 = &v19[17 * v20];
    v22 = *v21;
    if (v22 > v14)
    {
      v18 = v21 - 17;
      goto LABEL_31;
    }
    if (v22 + 16 <= v14)
    {
      v19 = v21 + 17;
LABEL_31:
      if (v19 > v18)
        goto LABEL_32;
      continue;
    }
    break;
  }
  v26 = &v19[17 * v20];
  v27 = v26[v14 - v22 + 1];
  if (!v26[v14 - v22 + 1])
  {
LABEL_32:
    if ((unsigned __int16)(v14 + 0x2000) > 0x98Bu)
      goto LABEL_33;
LABEL_83:
    v41 = v14 - 57344;
    v42 = (v14 - 57344) / 0xBC;
    v43 = v14 + 68 * v42;
    if (v41 - 188 * v42 <= 0x3E)
      v44 = v43;
    else
      v44 = v43 + 1;
    v7 = v11 + 2;
    if (a5)
    {
      if (v7 > a5)
        goto LABEL_238;
      *(_WORD *)a4 = bswap32(v44 + 4160) >> 16;
      a4 += 2;
    }
    goto LABEL_232;
  }
  if (v27 <= 0xFF)
  {
    v7 = v11 + 1;
    if (a5)
      *a4++ = v27;
    goto LABEL_232;
  }
  if ((v27 & 0x8000) != 0)
  {
    if ((unsigned __int16)(v14 + 0x2000) >= 0x98Cu)
    {
      if (v27 == 65533)
        goto LABEL_33;
      goto LABEL_238;
    }
    goto LABEL_83;
  }
  v7 = v11 + 2;
  if (!a5)
    goto LABEL_232;
  if (v7 <= a5)
  {
    if ((v27 & 0x100) != 0)
      v60 = 31;
    else
      v60 = 125;
    v61 = v60 + (v27 & 0x7F);
    v62 = ((v27 >> 8) + 479) >> 1;
    v63 = v62 - 127;
    v64 = (v62 - 127);
    if (v61 > 0x7E)
      LOBYTE(v61) = v61 + 1;
    v65 = v62 - 63;
    if (v64 <= 0x9F)
      v65 = v63;
    *a4 = v65;
    a4[1] = v61;
    a4 += 2;
    goto LABEL_232;
  }
LABEL_238:
  *a6 = v11;
  return v12;
}

uint64_t __CFFromMacJapanese(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v9;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned __int16 v15;
  __int16 v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  unsigned __int16 *v21;
  unsigned __int16 v22;
  int v23;
  __int16 v24;
  __int16 v25;
  __int16 v26;
  char v27;
  unsigned int v28;
  unsigned __int16 *v29;
  unsigned __int16 *v30;
  uint64_t v31;
  unsigned __int16 *v32;
  unsigned int v33;
  BOOL v35;
  unsigned int v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  uint64_t v39;
  unsigned __int16 *v40;
  unsigned int v41;
  uint64_t v42;
  unsigned int v43;
  char *v45;
  uint64_t v46;
  unsigned __int16 *v47;
  unsigned __int16 v48;
  unsigned int v50;
  int v51;
  int v52;
  _BYTE v53[10];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (a3 < 1)
    return 0;
  v9 = a3;
  v12 = 0;
  v13 = 0;
  v50 = a1 & 0x200;
  v51 = a1 & 0x480;
  v52 = a1 & 0xC0;
  while (1)
  {
    if (a5 && v12 >= a5)
      return v13;
    v14 = *a2;
    if (v14 < 0x81 || v14 == 160)
    {
      if (v14 == 128)
        v16 = 92;
      else
        v16 = *a2;
      if (v14 == 92)
        v16 = 165;
      if (v51 == 1024)
        v15 = *a2;
      else
        v15 = v16;
      v17 = 1;
      goto LABEL_23;
    }
    if ((v14 + 95) <= 0x3Eu)
    {
      v15 = v14 - 320;
LABEL_22:
      v17 = 1;
LABEL_23:
      if (v52 && __CFStringEncodingIsDecomposableCharacter_2(v15, (a1 >> 7) & 1))
      {
        v18 = __CFStringEncodingDecomposeCharacter_2(a1, v15, v53);
        v19 = *a6;
        v12 = *a6 + v18;
        *a6 = v12;
        if (a5)
        {
          if (v12 > a5)
          {
            *a6 = v19;
            return v13;
          }
          if (v18)
          {
            v20 = v18 + 1;
            v21 = (unsigned __int16 *)v53;
            do
            {
              v22 = *v21++;
              *a4++ = v22;
              --v20;
            }
            while (v20 > 1);
          }
        }
      }
      else
      {
        if (a5)
          *a4++ = v15;
        v12 = *a6 + 1;
        *a6 = v12;
      }
      v13 += v17;
      a2 += v17;
      v9 -= v17;
      goto LABEL_35;
    }
    if (v14 == 253)
    {
      v15 = 169;
      goto LABEL_22;
    }
    if (v14 == 254)
    {
      v15 = 8482;
      goto LABEL_22;
    }
    if ((unint64_t)v9 >= 2)
    {
      v23 = a2[1];
      if (v14 >= 0xA0)
        v24 = 79;
      else
        v24 = 15;
      v25 = v24 + v14;
      if ((v23 + ((char)v23 >> 7)) <= 0x9Du)
        v26 = (2 * (v25 & 0x1FF)) | 1;
      else
        v26 = 2 * v25 + 2;
      if ((v23 + ((char)v23 >> 7)) <= 0x9Du)
        v27 = -31;
      else
        v27 = -125;
      if ((unsigned __int16)(((v27 + v23 + ((char)v23 >> 7)) | (unsigned __int16)(v26 << 8)) - 30067) < 0xABAEu)
        goto LABEL_60;
      v28 = (unsigned __int16)((v27 + v23 + ((char)v23 >> 7)) | (unsigned __int16)(v26 << 8));
      v29 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
      v30 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
      while (1)
      {
        v31 = (0xF83E0F83E0F83E1 * (v30 - v29)) >> 1;
        v32 = &v29[33 * v31];
        v33 = *v32;
        if (v33 <= v28)
          break;
        v30 = v32 - 33;
LABEL_53:
        if (v29 > v30)
          goto LABEL_60;
      }
      if (v33 + 32 <= v28)
      {
        v29 = v32 + 33;
        goto LABEL_53;
      }
      v15 = v29[33 * v31 + 1 + (int)(v28 - v33)];
      if (v15 != 65533 && v15 != 0)
      {
LABEL_64:
        v17 = 2;
        goto LABEL_23;
      }
LABEL_60:
      if ((v14 + 16) <= 0xCu)
        break;
    }
    if (v14 != 255)
      goto LABEL_66;
    v12 += 2;
    if (a5)
    {
      if (v12 > a5)
        return v13;
      *(_DWORD *)a4 = -125886426;
      a4 += 2;
    }
    *a6 = v12;
    ++v13;
    ++a2;
    --v9;
LABEL_35:
    if (v9 <= 0)
      return v13;
  }
  if (v23 != 127 && (v23 + 3) >= 0x43u)
  {
    v15 = (v23 | ((_WORD)v14 << 8)) - 68 * (v14 & 0xF) + ((char)v23 >> 7) - 4160;
    goto LABEL_64;
  }
LABEL_66:
  v35 = v9 < 2;
  v9 -= 2;
  if (v35)
    return v13;
  v36 = a2[1] | (v14 << 8);
  if ((unsigned __int16)(v36 + 4713) < 0x97FAu)
    return v13;
  v37 = (unsigned __int16 *)&macjapanese_to_uni_decomp;
  v38 = (unsigned __int16 *)&unk_182DC4054;
  while (2)
  {
    v39 = ((char *)v38 - (char *)v37) >> 3;
    v40 = &v37[2 * v39];
    v41 = *v40;
    if (v41 > v36)
    {
      v38 = v40 - 2;
      goto LABEL_73;
    }
    if (v41 < v36)
    {
      v37 = v40 + 2;
LABEL_73:
      if (v37 > v38)
        return v13;
      continue;
    }
    break;
  }
  v42 = LOBYTE(v37[2 * v39 + 1]);
  v43 = (v42 >> 6) + 2;
  if (v50)
  {
    if ((unint64_t)(v42 - 7) >= 3 || v42 >= 0x40)
      v43 = (v42 >> 6) + 1;
  }
  v12 += v43;
  if (!a5)
  {
LABEL_94:
    *a6 = v12;
    v13 += 2;
    a2 += 2;
    goto LABEL_35;
  }
  if (v12 <= a5)
  {
    if (v42 >= 0x40)
      v45 = (char *)&__CFF86XCharDecompSeqTable + 10 * (v42 & 0x3F) + 2 * (v50 >> 9) - 10;
    else
      v45 = (char *)&__CFTwoCharDecompSeqTable_0 + 4 * v42 - 4;
    v46 = v43;
    v47 = a4;
    do
    {
      v48 = *(_WORD *)v45;
      v45 += 2;
      *v47++ = v48;
      --v46;
    }
    while (v46);
    a4 += v43;
    goto LABEL_94;
  }
  return v13;
}

uint64_t __CFFromMacJapaneseLen(__int16 a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t result;
  int v5;
  unsigned int v6;
  BOOL v7;
  int v8;

  if (a3 < 1)
    return 0;
  result = 0;
  v5 = a1 & 0x480;
  do
  {
    v6 = *a2;
    if (v6 == 255)
    {
      ++a2;
      --a3;
      ++result;
    }
    else if ((v6 & 0x80) == 0
           || (v6 + 95) < 0x3Fu
           || (v5 != 1024 ? (v7 = v6 == 128) : (v7 = 0),
               !v7 ? (v8 = 0) : (v8 = 1),
               (unint64_t)a3 < 2 || v6 > 0xFC || v8))
    {
      ++a2;
      --a3;
    }
    else
    {
      if (v6 - 235 >= 3 && v6 - 133 > 2)
      {
        a2 += 2;
      }
      else
      {
        a2 += 2;
        result += 5;
      }
      a3 -= 2;
    }
    ++result;
  }
  while (a3 > 0);
  return result;
}

uint64_t __CFFromShiftJIS(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int16 *a4)
{
  unsigned int v5;
  __int16 v6;
  __int16 v7;
  uint64_t result;
  int v9;
  unsigned int v10;
  int v11;

  v5 = *a2;
  if (((char)*a2 & 0x80000000) == 0)
  {
    if (v5 == 126)
      v6 = 8254;
    else
      v6 = *a2;
    if (v5 == 92)
      v7 = 165;
    else
      v7 = v6;
    goto LABEL_10;
  }
  if ((v5 + 95) <= 0x3Eu)
  {
    v7 = v5 - 320;
LABEL_10:
    *a4 = v7;
    return 1;
  }
  if (a3 < 2)
    return 0;
  if ((v5 + 16) <= 0xCu)
  {
    result = 0;
    v9 = a2[1];
    if (v9 != 127 && (v9 + 3) >= 0x43u)
    {
      *a4 = (v9 | ((_WORD)v5 << 8)) - 68 * (v5 & 0xF) + ((char)v9 >> 7) - 4160;
      return 2;
    }
    return result;
  }
  if (v5 == 128)
    return 0;
  result = 0;
  if (v5 <= 0xEA && (v5 + 123) >= 3u)
  {
    v10 = ShiftJISToJIS0208(a2);
    v11 = __CFFromJIS0208(v10);
    *a4 = v11;
    return 2 * (v11 != 65533);
  }
  return result;
}

uint64_t __CFToAutoDetect_JP(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6)
{
  *a6 = 0;
  return 0;
}

uint64_t __CFFromAutoDetect_JP(uint64_t a1, char *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t *a6)
{
  unsigned __int16 *v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  char *v17;
  unsigned int v18;
  char v19;
  char v20;
  char v21;
  unsigned __int8 *v22;
  unint64_t v23;
  unsigned int v24;
  BOOL v25;
  unsigned int v26;
  int v27;
  uint64_t v30;
  uint64_t i;
  char v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  int v37;
  __int16 v38;
  __int16 v39;
  char v40;
  int v41;
  int v42;
  char v43;
  char v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  unsigned __int8 *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  unsigned __int16 v59;
  uint64_t v60;

  v8 = a4;
  v9 = a3;
  v10 = (unsigned __int8 *)a2;
  v11 = a1;
  v60 = *MEMORY[0x1E0C80C00];
  v12 = a2;
  v13 = a3;
  do
  {
    v14 = v13-- < 1;
    if (v14)
    {
      if (a3 < 1)
      {
LABEL_41:
        if (a5 >= a3 || a5 == 0)
          v30 = a3;
        else
          v30 = a5;
        *a6 = v30;
        if (v30 && a5)
        {
          for (i = 0; i != v30; ++i)
            a4[i] = a2[i];
        }
        return v30;
      }
      v22 = (unsigned __int8 *)(a2 + 1);
      v23 = a3;
      while (1)
      {
        if (*(v22 - 1) == 27)
        {
          if (v23 < 5)
          {
            if (v23 == 4)
            {
              v26 = *v22 - 96;
              v14 = v26 > 0x1E;
              v27 = (1 << v26) & 0x7000C00F;
              if (!v14 && v27 != 0)
                return __CFFromISO_2022_JP(a1, a2, a3, a4, a5, a6);
            }
          }
          else
          {
            v24 = *v22;
            v25 = v24 - 96 > 0x1E || ((1 << (v24 - 96)) & 0x7000C00F) == 0;
            if (!v25 || v24 <= 0x28 && ((1 << v24) & 0x11600000000) != 0)
              return __CFFromISO_2022_JP(a1, a2, a3, a4, a5, a6);
          }
        }
        --v23;
        ++v22;
        if (v23 + 1 <= 1)
          goto LABEL_41;
      }
    }
    v15 = *v12++;
  }
  while ((v15 & 0x80000000) == 0);
  if (a3 < 1)
    goto LABEL_92;
  v16 = a3;
  v17 = a2;
  while (1)
  {
    if ((*v17 & 0x80000000) == 0)
    {
      --v16;
      goto LABEL_8;
    }
    v18 = *v17;
    if (v18 == 142)
    {
      v20 = *++v17;
      if ((v20 + 32) < 0xC1u)
        goto LABEL_53;
      v16 -= 2;
      goto LABEL_8;
    }
    if (v18 != 143)
      break;
    if ((v17[1] + 32) < 0xC1u)
      goto LABEL_53;
    v21 = v17[2];
    v17 += 2;
    if ((v21 + 32) < 0xC1u)
      goto LABEL_53;
    v16 -= 3;
LABEL_8:
    ++v17;
    if (v16 <= 0)
    {
      v33 = 1;
      goto LABEL_54;
    }
  }
  if (v18 != 255)
  {
    v33 = 0;
    v16 -= 2;
    if (!v16 || v18 < 0xA0)
      goto LABEL_54;
    v19 = *++v17;
    if ((v19 + 1) >= 0xA1u)
      goto LABEL_8;
  }
LABEL_53:
  v33 = 0;
LABEL_54:
  v34 = a3;
  v35 = a2;
  while (2)
  {
    v36 = v34 - 1;
    v37 = *v35;
    if ((v37 & 0x80000000) == 0 || (v37 + 32) > 0xC0u)
    {
LABEL_69:
      ++v35;
      v34 = v36;
      if (v36 <= 0)
      {
        if ((v33 & 1) == 0)
        {
          v30 = 0;
          *a6 = 0;
          v59 = 0;
          v46 = 1;
          while (1)
          {
            if (a5)
            {
              if (v46 - 1 >= a5)
                return v30;
              a1 = __CFFromShiftJIS(a1, v10, v9, (__int16 *)&v59);
              if (!(_DWORD)a1)
                return v30;
              v47 = a1;
              *v8++ = v59;
            }
            else
            {
              a1 = __CFFromShiftJIS(a1, v10, v9, (__int16 *)&v59);
              if (!(_DWORD)a1)
                return v30;
              v47 = a1;
            }
            *a6 = v46;
            v30 += v47;
            v10 += v47;
            ++v46;
            v14 = v9 <= v47;
            v9 -= v47;
            if (v14)
              return v30;
          }
        }
        goto LABEL_92;
      }
      continue;
    }
    break;
  }
  if (*v35 >= 0xA0u)
    v38 = 79;
  else
    v38 = 15;
  v39 = v38 + *v35;
  v40 = 2 * v39;
  a1 = (2 * (v39 & 0x1FF)) | 1u;
  v41 = *++v35;
  v42 = v41 + ((char)(2 * v39) >> 7);
  v43 = v40 + 2;
  if (v42 <= 0x9Du)
    v44 = a1;
  else
    v44 = v43;
  if (v42 <= 0x9Du)
    v45 = -31;
  else
    v45 = -125;
  if ((v44 - 127) >= 0xA1u && (v42 + v45 - 127) >= 0xA1u)
  {
    v36 = v34 - 2;
    goto LABEL_69;
  }
  if ((v33 & 1) != 0)
  {
    v30 = 0;
    *a6 = 0;
    v59 = 0;
    v48 = 1;
    while (1)
    {
      if (a5)
      {
        if (v48 - 1 >= a5)
          return v30;
        a1 = __CFFromEUC_JP(a1, v10, v9, (__int16 *)&v59);
        if (!(_DWORD)a1)
          return v30;
        v49 = a1;
        *v8++ = v59;
      }
      else
      {
        a1 = __CFFromEUC_JP(a1, v10, v9, (__int16 *)&v59);
        if (!(_DWORD)a1)
          return v30;
        v49 = a1;
      }
      *a6 = v48;
      v30 += v49;
      v10 += v49;
      ++v48;
      v14 = v9 <= v49;
      v9 -= v49;
      if (v14)
        return v30;
    }
  }
LABEL_92:
  v50 = __CFFromMacJapanese(0, (unsigned __int8 *)a2, a3, 0, 0, a6);
  v51 = v50;
  if (v9 > v50)
  {
    *a6 = 0;
    if (v9 >= 1)
    {
      v58 = v11;
      v52 = 0;
      v53 = 1;
      v54 = v10;
      v55 = v9;
      do
      {
        v50 = __CFFromDOSJapanese(v50, v54, v55, (__int16 *)&v59);
        if (!(_DWORD)v50)
          break;
        *a6 = v53;
        v52 += v50;
        v54 += v50;
        v55 -= v50;
        ++v53;
      }
      while (v55 > 0);
      v11 = v58;
      if (v52 > v51)
      {
        *a6 = 0;
        v30 = 0;
        v59 = 0;
        v56 = 1;
        while (1)
        {
          if (a5)
          {
            if (v56 - 1 >= a5)
              return v30;
            v50 = __CFFromDOSJapanese(v50, v10, v9, (__int16 *)&v59);
            if (!(_DWORD)v50)
              return v30;
            v57 = v50;
            *v8++ = v59;
          }
          else
          {
            v50 = __CFFromDOSJapanese(v50, v10, v9, (__int16 *)&v59);
            if (!(_DWORD)v50)
              return v30;
            v57 = v50;
          }
          *a6 = v56;
          v30 += v57;
          v10 += v57;
          ++v56;
          v14 = v9 <= v57;
          v9 -= v57;
          if (v14)
            return v30;
        }
      }
    }
  }
  return __CFFromMacJapanese(v11, v10, v9, v8, a5, a6);
}

uint64_t __CFToNTTDocomoSJIS(char a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  uint64_t v17;
  const char *v18;
  size_t v19;
  uint64_t v20;
  size_t v21;
  unsigned int v22;
  uint64_t v23;
  int v24;
  unsigned __int16 *v25;
  unsigned __int16 *v26;
  uint64_t v27;
  unsigned __int16 *v28;
  unsigned int v29;
  unsigned int v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  uint64_t v33;
  unsigned __int16 *v34;
  unsigned int v35;
  char *v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  char v42;
  unsigned int v43;
  char v44;
  int v45;
  uint64_t v46;
  _BYTE *v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  char v53;
  unsigned int v54;
  char v55;
  uint64_t v58[2];

  v58[1] = *MEMORY[0x1E0C80C00];
  if (a3 < 1)
  {
    v12 = 0;
    v20 = 0;
    goto LABEL_85;
  }
  v11 = 0;
  v12 = 0;
  v58[0] = 0;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0)
        goto LABEL_83;
      v13 = *a2;
      v14 = (v13 - 774) > 0x32 || ((1 << (v13 - 6)) & 0x4000000000005) == 0;
      v15 = v13 - 12441;
      if (v14 && v15 >= 2)
        goto LABEL_83;
    }
    v17 = __CFToEmojiIndex(a2, a3 - v12, v58);
    if (v17 != -1)
    {
      if (v17 == 312 || v17 == 69)
      {
        v18 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFNTTDocomoTable[v17] - 6;
        v19 = strlen(v18);
        v20 = v19 + v11;
        if (a5)
        {
          if (v20 > a5)
            goto LABEL_83;
          v21 = v19;
          memcpy(a4, v18, v19);
          a4 += v21;
        }
      }
      else
      {
        v20 = v11 + 2;
        if (a5)
        {
          if (v20 > a5)
            goto LABEL_83;
          *(_WORD *)a4 = __rev16(__CFNTTDocomoTable[v17]);
          a4 += 2;
        }
      }
      v23 = v58[0];
      goto LABEL_32;
    }
    v22 = *a2;
    if (v22 <= 0x7F)
    {
      v20 = v11 + 1;
      if (!a5)
        goto LABEL_31;
      goto LABEL_30;
    }
    if ((unsigned __int16)(v22 + 159) <= 0x3Eu)
    {
      v20 = v11 + 1;
      if (!a5)
        goto LABEL_31;
      LOBYTE(v22) = v22 + 64;
LABEL_30:
      *a4++ = v22;
      goto LABEL_31;
    }
    if ((unsigned __int16)(v22 + 12) < 0xACu)
    {
      LOWORD(v24) = -3;
      goto LABEL_43;
    }
    v25 = (unsigned __int16 *)&__CFToJISCharMap;
    v26 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (1)
    {
      v27 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v26 - v25)) >> 1;
      v28 = &v25[17 * v27];
      v29 = *v28;
      if (v29 <= v22)
        break;
      v26 = v28 - 17;
LABEL_41:
      if (v25 > v26)
        goto LABEL_42;
    }
    if (v29 + 16 <= v22)
    {
      v25 = v28 + 17;
      goto LABEL_41;
    }
    v36 = (char *)&v25[17 * v27];
    v24 = *(__int16 *)&v36[2 * (v22 - v29) + 2];
    if (*(_WORD *)&v36[2 * (v22 - v29) + 2])
    {
      if (v24 >= 256)
      {
        v20 = v11 + 2;
        if (a5)
        {
          if (v20 <= a5)
          {
            v37 = BYTE1(v24);
            v38 = v24 & 0x7F;
            if ((v24 & 0x100) != 0)
              v39 = 31;
            else
              v39 = 125;
            v40 = v39 + v38;
            v41 = (v37 + 479) >> 1;
            v42 = v41 - 127;
            v43 = (v41 - 127);
            if (v40 > 0x7E)
              LOBYTE(v40) = v40 + 1;
            v44 = v41 - 63;
            if (v43 <= 0x9F)
              v44 = v42;
            *a4 = v44;
            a4[1] = v40;
            a4 += 2;
            goto LABEL_31;
          }
LABEL_83:
          v20 = v11;
          break;
        }
LABEL_31:
        v23 = 1;
        goto LABEL_32;
      }
    }
    else
    {
LABEL_42:
      LOWORD(v24) = -3;
    }
LABEL_43:
    if ((a1 & 8) != 0 || v12 < 1 || (unsigned __int16)v24 != 65533)
      goto LABEL_83;
    if ((a1 & 0x10) == 0)
      goto LABEL_47;
    if ((v22 - 774 > 0x32 || ((1 << (v22 - 6)) & 0x4000000000005) == 0) && v22 - 12441 >= 2)
      goto LABEL_83;
    v30 = __CFPrecomposeCharJapanese(a2 - 1, 1);
    if ((unsigned __int16)(v30 + 12) < 0xACu)
      goto LABEL_83;
    v31 = (unsigned __int16 *)&__CFToJISCharMap;
    v32 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (2)
    {
      v33 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v32 - v31)) >> 1;
      v34 = &v31[17 * v33];
      v35 = *v34;
      if (v35 > v30)
      {
        v32 = v34 - 17;
        goto LABEL_57;
      }
      if (v35 + 16 <= v30)
      {
        v31 = v34 + 17;
LABEL_57:
        if (v31 > v32)
          goto LABEL_83;
        continue;
      }
      break;
    }
    v45 = (__int16)v31[17 * v33 + 1 + (int)(v30 - v35)];
    if (v45 < 1)
      goto LABEL_83;
    if (a5)
    {
      v46 = -2;
      if (*(a4 - 1) == 61)
        v46 = -1;
      v47 = &a4[v46];
      v48 = BYTE1(v45);
      v49 = v45 & 0x7F;
      if ((v45 & 0x100) != 0)
        v50 = 31;
      else
        v50 = 125;
      v51 = v50 + v49;
      v52 = (v48 + 479) >> 1;
      v53 = v52 - 127;
      v54 = (v52 - 127);
      if (v51 > 0x7E)
        LOBYTE(v51) = v51 + 1;
      v55 = v52 - 63;
      if (v54 <= 0x9F)
        v55 = v53;
      *v47 = v55;
      v47[1] = v51;
    }
LABEL_47:
    v23 = 1;
    v20 = v11;
LABEL_32:
    a2 += v23;
    v12 += v23;
    v11 = v20;
  }
  while (v12 < a3);
LABEL_85:
  *a6 = v20;
  return v12;
}

uint64_t __CFFromNTTDocomoSJIS(unsigned int a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t v17;
  __int16 *v18;
  __int16 v19;
  uint64_t v20;
  int v21;
  __int16 v22;
  __int16 v23;
  __int16 v24;
  char v25;
  unsigned int v26;
  unsigned __int16 *v27;
  unsigned __int16 *v28;
  uint64_t v29;
  unsigned __int16 *v30;
  unsigned int v31;
  unsigned __int16 v32;
  unsigned int v34;
  unsigned __int16 *v35;
  unsigned __int16 *v36;
  uint64_t v37;
  unsigned __int16 *v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v44;
  int v45;
  __int16 __src[10];
  _BYTE v47[10];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (a3 < 1)
    return 0;
  v9 = a3;
  v11 = 0;
  v12 = 0;
  v44 = (a1 >> 7) & 1;
  v45 = a1 & 0xC0;
  do
  {
    if (a5 && a5 <= v11)
      return v12;
    v13 = *a2;
    if ((*a2 & 0x80000000) == 0)
      goto LABEL_8;
    if ((v13 + 95) <= 0x3Eu)
    {
      LOWORD(v13) = v13 - 320;
LABEL_8:
      v14 = 1;
LABEL_9:
      if (v45 && __CFStringEncodingIsDecomposableCharacter_2((unsigned __int16)v13, v44))
      {
        v15 = __CFStringEncodingDecomposeCharacter_2(a1, (unsigned __int16)v13, v47);
        v16 = *a6;
        v11 = *a6 + v15;
        *a6 = v11;
        if (a5)
        {
          if (v11 > a5)
          {
            *a6 = v16;
            return v12;
          }
          if (v15)
          {
            v17 = v15 + 1;
            v18 = (__int16 *)v47;
            do
            {
              v19 = *v18++;
              *a4++ = v19;
              --v17;
            }
            while (v17 > 1);
          }
        }
      }
      else
      {
        if (a5)
          *a4++ = v13;
        v11 = *a6 + 1;
        *a6 = v11;
      }
      v12 += v14;
      a2 += v14;
      v9 -= v14;
      continue;
    }
    v20 = v9 - 2;
    if ((unint64_t)v9 < 2)
      return v12;
    v21 = a2[1];
    if (v13 >= 0xA0)
      v22 = 79;
    else
      v22 = 15;
    v23 = v22 + v13;
    if ((v21 + ((char)v21 >> 7)) <= 0x9Du)
      v24 = (2 * (v23 & 0x1FF)) | 1;
    else
      v24 = 2 * v23 + 2;
    if ((v21 + ((char)v21 >> 7)) <= 0x9Du)
      v25 = -31;
    else
      v25 = -125;
    if ((unsigned __int16)(((v25 + v21 + ((char)v21 >> 7)) | (unsigned __int16)(v24 << 8)) - 30067) < 0xABAEu)
      goto LABEL_46;
    v26 = (unsigned __int16)((v25 + v21 + ((char)v21 >> 7)) | (unsigned __int16)(v24 << 8));
    v27 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
    v28 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
    while (1)
    {
      v29 = (0xF83E0F83E0F83E1 * (v28 - v27)) >> 1;
      v30 = &v27[33 * v29];
      v31 = *v30;
      if (v31 <= v26)
        break;
      v28 = v30 - 33;
LABEL_36:
      if (v27 > v28)
        goto LABEL_46;
    }
    if (v31 + 32 <= v26)
    {
      v27 = v30 + 33;
      goto LABEL_36;
    }
    v32 = v27[33 * v29 + 1 + (int)(v26 - v31)];
    if (v32 != 65533 && v32 != 0)
    {
      LOWORD(v13) = v32;
      v14 = 2;
      goto LABEL_9;
    }
LABEL_46:
    v34 = v21 | (v13 << 8);
    if ((unsigned __int16)(v34 + 1539) < 0xFEA2u)
      return v12;
    v35 = (unsigned __int16 *)&__CFEmojiIndexFromNTTDocomoSJIS;
    v36 = (unsigned __int16 *)&unk_182DC506E;
    while (2)
    {
      v37 = ((char *)v36 - (char *)v35) >> 3;
      v38 = &v35[2 * v37];
      v39 = *v38;
      if (v39 > v34)
      {
        v36 = v38 - 2;
        goto LABEL_52;
      }
      if (v39 < v34)
      {
        v35 = v38 + 2;
LABEL_52:
        if (v35 > v36)
          return v12;
        continue;
      }
      break;
    }
    v40 = __CFFromEmojiIndex(v35[2 * v37 + 1], __src);
    v41 = v40;
    if (!a5)
      goto LABEL_57;
    if (a5 - v11 < v40)
      break;
    memcpy(a4, __src, 2 * v40);
    a4 += v41;
    v11 = *a6;
LABEL_57:
    v11 += v41;
    *a6 = v11;
    v12 += 2;
    a2 += 2;
    v9 = v20;
  }
  while (v9 > 0);
  return v12;
}

uint64_t __CFToEmojiIndex(unsigned __int16 *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  char *v13;
  unsigned int v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  __int16 *v17;
  __int16 *v18;
  char *v19;
  unsigned int v20;
  unsigned __int16 *v21;
  __int16 *v22;
  uint64_t v23;
  unsigned __int16 *v24;
  unsigned int v25;
  unsigned __int16 *v26;
  char *v27;
  unsigned int v28;
  unsigned __int16 *v29;
  unsigned __int16 *v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  char *v33;
  unsigned int v34;
  unsigned __int16 *v35;
  unsigned __int16 *v36;
  char __s1[2];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = *a1;
  if (v4 <= 0x7F)
  {
    if (a2 >= 2 && a1[1] == 8419)
    {
      *a3 = 2;
      if ((v4 - 48) >= 0xA)
        v5 = -1;
      else
        v5 = v4 + 654;
      if ((_DWORD)v4 == 35)
        return 701;
      else
        return v5;
    }
    return -1;
  }
  if ((v4 & 0xFFFE) != 0xD83C)
  {
    v11 = (unsigned __int16 *)&unk_182DC4C98;
    v12 = __CFBMPEmojiList;
    while (1)
    {
      v13 = (char *)&v12[((char *)v11 - (char *)v12) >> 2];
      v14 = *(unsigned __int16 *)v13;
      if (v14 == (_DWORD)v4)
        break;
      v15 = (unsigned __int16 *)(v13 - 2);
      v16 = (unsigned __int16 *)(v13 + 2);
      if (v14 > v4)
        v11 = v15;
      else
        v12 = v16;
      if (v12 > v11)
        goto LABEL_29;
    }
    if (v13 - (char *)__CFBMPEmojiList == -2)
    {
LABEL_29:
      v17 = (__int16 *)&unk_182DC4C9C;
      v18 = __CFCompatibilityEmojiList;
      while (1)
      {
        v19 = (char *)&v18[((char *)v17 - (char *)v18) >> 2];
        v20 = *(unsigned __int16 *)v19;
        if (v20 == (_DWORD)v4)
          break;
        v21 = (unsigned __int16 *)(v19 - 2);
        v22 = (__int16 *)(v19 + 2);
        if (v20 > v4)
          v17 = (__int16 *)v21;
        else
          v18 = v22;
        if (v18 > v17)
          return -1;
      }
      if (v19 - (char *)__CFCompatibilityEmojiList == -2)
        return -1;
      result = ((v19 - (char *)__CFCompatibilityEmojiList) >> 1) + 722;
    }
    else
    {
      result = (v13 - (char *)__CFBMPEmojiList) >> 1;
    }
    v23 = 1;
    goto LABEL_41;
  }
  if (a2 < 2)
    return -1;
  v7 = a1[1];
  if (v7 >> 10 != 55)
    return -1;
  v8 = v7 + ((_DWORD)v4 << 10);
  if (v8 - 56741350 > 0x19)
  {
    v24 = (unsigned __int16 *)&unk_182DC4AB0;
    v25 = ((_WORD)v8 + 1024) & 0xFFF;
    v26 = __CFSMPEmojiList;
    while (1)
    {
      v27 = (char *)&v26[((char *)v24 - (char *)v26) >> 2];
      v28 = *(unsigned __int16 *)v27;
      if (v28 == v25)
        break;
      v29 = (unsigned __int16 *)(v27 - 2);
      v30 = (unsigned __int16 *)(v27 + 2);
      if (v28 > v25)
        v24 = v29;
      else
        v26 = v30;
      if (v26 > v24)
        goto LABEL_50;
    }
    if (v27 - (char *)__CFSMPEmojiList != -2)
    {
      result = ((v27 - (char *)__CFSMPEmojiList) >> 1) + 119;
      v23 = 2;
      goto LABEL_41;
    }
LABEL_50:
    v31 = (unsigned __int16 *)&unk_182DC4BAA;
    v32 = (unsigned __int16 *)&__CFSMPUnicodeOnlyEmojiList;
    result = -1;
    while (1)
    {
      v33 = (char *)&v32[((char *)v31 - (char *)v32) >> 2];
      v34 = *(unsigned __int16 *)v33;
      if (v34 == v25)
        break;
      v35 = (unsigned __int16 *)(v33 - 2);
      v36 = (unsigned __int16 *)(v33 + 2);
      if (v34 > v25)
        v31 = v35;
      else
        v32 = v36;
      if (v32 > v31)
        return result;
    }
    if (v33 - (char *)&__CFSMPUnicodeOnlyEmojiList != -2)
    {
      *a3 = 2;
      return 724;
    }
    return -1;
  }
  if ((unint64_t)a2 < 4)
    return -1;
  if ((a1[2] & 0xFC00) != 0xD800)
    return -1;
  v9 = a1[3];
  if (v9 >> 10 != 55)
    return -1;
  v10 = 0;
  __s1[0] = v7 + 91;
  __s1[1] = v9 + 91;
  while (strncmp(__s1, __CFRegionSequences[v10], 2uLL))
  {
    if (++v10 == 10)
      return -1;
  }
  result = v10 + 712;
  v23 = 4;
LABEL_41:
  *a3 = v23;
  return result;
}

uint64_t __CFFromEmojiIndex(unint64_t a1, __int16 *a2)
{
  __int16 v2;
  int v4;
  __int16 v5;
  char *v6;
  __int16 v7;
  __int16 v8;

  if ((uint64_t)a1 <= 118)
  {
    v2 = __CFBMPEmojiList[a1];
LABEL_3:
    *a2 = v2;
    return 1;
  }
  if (a1 <= 0x2BC)
  {
    if (a2)
    {
      v4 = __CFSMPEmojiList[a1 - 119];
      *a2 = ((v4 + 61440) >> 10) | 0xD800;
      a2[1] = v4 & 0x3FF | 0xDC00;
    }
    return 2;
  }
  if (a1 <= 0x2C7)
  {
    v5 = a1 - 654;
    if (a1 == 701)
      v5 = 35;
    *a2 = v5;
    a2[1] = 8419;
    return 2;
  }
  if (a1 > 0x2D1)
  {
    if (a1 <= 0x2D3)
    {
      v2 = __CFCompatibilityEmojiList[a1 - 722];
      goto LABEL_3;
    }
    return 0;
  }
  else
  {
    v6 = __CFRegionSequences[a1 - 712];
    if (a2)
    {
      v7 = *v6;
      *a2 = -10180;
      a2[1] = (v7 + 421) | 0xDC00;
    }
    v8 = v6[1];
    a2[2] = -10180;
    a2[3] = (v8 + 421) | 0xDC00;
    return 4;
  }
}

uint64_t __CFToKDDISJIS(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  size_t v20;
  uint64_t v21;
  size_t v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  unsigned __int16 *v26;
  unsigned __int16 *v27;
  uint64_t v28;
  unsigned __int16 *v29;
  unsigned int v30;
  unsigned int v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  uint64_t v34;
  unsigned __int16 *v35;
  unsigned int v36;
  char *v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  char v43;
  unsigned int v44;
  char v45;
  int v46;
  uint64_t v47;
  _BYTE *v48;
  int v49;
  int v50;
  int v51;
  unsigned int v52;
  unsigned int v53;
  char v54;
  unsigned int v55;
  char v56;
  uint64_t v60[2];

  v60[1] = *MEMORY[0x1E0C80C00];
  if (a3 < 1)
  {
    v12 = 0;
    v21 = 0;
    goto LABEL_84;
  }
  v8 = a3;
  v11 = 0;
  v12 = 0;
  v60[0] = 0;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0)
        goto LABEL_82;
      v13 = *a2;
      v14 = (v13 - 774) > 0x32 || ((1 << (v13 - 6)) & 0x4000000000005) == 0;
      v15 = v13 - 12441;
      if (v14 && v15 >= 2)
        goto LABEL_82;
    }
    v17 = __CFToEmojiIndex(a2, v8 - v12, v60);
    if (v17 != -1)
    {
      if (v17 == 613)
      {
        v18 = a1;
        v19 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFKDDITable[613] - 6;
        v20 = strlen(v19);
        v21 = v20 + v11;
        if (a5)
        {
          if (v21 > a5)
            goto LABEL_82;
          v22 = v20;
          memcpy(a4, v19, v20);
          a4 += v22;
          a1 = v18;
          v8 = a3;
        }
        else
        {
          a1 = v18;
          v8 = a3;
        }
      }
      else
      {
        v21 = v11 + 2;
        if (a5)
        {
          if (v21 > a5)
            goto LABEL_82;
          *(_WORD *)a4 = __rev16(__CFKDDITable[v17]);
          a4 += 2;
        }
      }
      v24 = v60[0];
      goto LABEL_31;
    }
    v23 = *a2;
    if (v23 <= 0x7F)
    {
      v21 = v11 + 1;
      if (!a5)
        goto LABEL_28;
      goto LABEL_27;
    }
    if ((unsigned __int16)(v23 + 159) <= 0x3Eu)
    {
      v21 = v11 + 1;
      if (!a5)
        goto LABEL_28;
      LOBYTE(v23) = v23 + 64;
LABEL_27:
      *a4++ = v23;
      goto LABEL_28;
    }
    if ((unsigned __int16)(v23 + 12) < 0xACu)
    {
      LOWORD(v25) = -3;
      goto LABEL_42;
    }
    v26 = (unsigned __int16 *)&__CFToJISCharMap;
    v27 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (1)
    {
      v28 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v27 - v26)) >> 1;
      v29 = &v26[17 * v28];
      v30 = *v29;
      if (v30 <= v23)
        break;
      v27 = v29 - 17;
LABEL_40:
      if (v26 > v27)
        goto LABEL_41;
    }
    if (v30 + 16 <= v23)
    {
      v26 = v29 + 17;
      goto LABEL_40;
    }
    v37 = (char *)&v26[17 * v28];
    v25 = *(__int16 *)&v37[2 * (v23 - v30) + 2];
    if (*(_WORD *)&v37[2 * (v23 - v30) + 2])
    {
      if (v25 >= 256)
      {
        v21 = v11 + 2;
        if (a5)
        {
          if (v21 <= a5)
          {
            v38 = BYTE1(v25);
            v39 = v25 & 0x7F;
            if ((v25 & 0x100) != 0)
              v40 = 31;
            else
              v40 = 125;
            v41 = v40 + v39;
            v42 = (v38 + 479) >> 1;
            v43 = v42 - 127;
            v44 = (v42 - 127);
            if (v41 > 0x7E)
              LOBYTE(v41) = v41 + 1;
            v45 = v42 - 63;
            if (v44 <= 0x9F)
              v45 = v43;
            *a4 = v45;
            a4[1] = v41;
            a4 += 2;
            goto LABEL_28;
          }
LABEL_82:
          v21 = v11;
          break;
        }
LABEL_28:
        v24 = 1;
        goto LABEL_31;
      }
    }
    else
    {
LABEL_41:
      LOWORD(v25) = -3;
    }
LABEL_42:
    if ((a1 & 8) != 0 || v12 < 1 || (unsigned __int16)v25 != 65533)
      goto LABEL_82;
    if ((a1 & 0x10) == 0)
      goto LABEL_46;
    if ((v23 - 774 > 0x32 || ((1 << (v23 - 6)) & 0x4000000000005) == 0) && v23 - 12441 >= 2)
      goto LABEL_82;
    v31 = __CFPrecomposeCharJapanese(a2 - 1, 1);
    if ((unsigned __int16)(v31 + 12) < 0xACu)
      goto LABEL_82;
    v32 = (unsigned __int16 *)&__CFToJISCharMap;
    v33 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (2)
    {
      v34 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v33 - v32)) >> 1;
      v35 = &v32[17 * v34];
      v36 = *v35;
      if (v36 > v31)
      {
        v33 = v35 - 17;
        goto LABEL_56;
      }
      if (v36 + 16 <= v31)
      {
        v32 = v35 + 17;
LABEL_56:
        if (v32 > v33)
          goto LABEL_82;
        continue;
      }
      break;
    }
    v46 = (__int16)v32[17 * v34 + 1 + (int)(v31 - v36)];
    if (v46 < 1)
      goto LABEL_82;
    if (a5)
    {
      v47 = -2;
      if (*(a4 - 1) == 61)
        v47 = -1;
      v48 = &a4[v47];
      v49 = BYTE1(v46);
      v50 = v46 & 0x7F;
      if ((v46 & 0x100) != 0)
        v51 = 31;
      else
        v51 = 125;
      v52 = v51 + v50;
      v53 = (v49 + 479) >> 1;
      v54 = v53 - 127;
      v55 = (v53 - 127);
      if (v52 > 0x7E)
        LOBYTE(v52) = v52 + 1;
      v56 = v53 - 63;
      if (v55 <= 0x9F)
        v56 = v54;
      *v48 = v56;
      v48[1] = v52;
    }
LABEL_46:
    v24 = 1;
    v21 = v11;
LABEL_31:
    a2 += v24;
    v12 += v24;
    v11 = v21;
  }
  while (v12 < v8);
LABEL_84:
  *a6 = v21;
  return v12;
}

uint64_t __CFFromKDDISJIS(unsigned int a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t v17;
  __int16 *v18;
  __int16 v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  __int16 v23;
  __int16 v24;
  __int16 v25;
  int v26;
  __int16 v27;
  __int16 v28;
  char v29;
  unsigned __int16 v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  uint64_t v33;
  unsigned __int16 *v34;
  unsigned int v35;
  unsigned int v36;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  uint64_t v40;
  unsigned __int16 *v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v47;
  int v48;
  __int16 __src[10];
  _BYTE v50[10];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (a3 < 1)
    return 0;
  v9 = a3;
  v11 = 0;
  v12 = 0;
  v47 = (a1 >> 7) & 1;
  v48 = a1 & 0xC0;
  do
  {
    if (a5 && a5 <= v11)
      return v12;
    v13 = *a2;
    if ((*a2 & 0x80000000) == 0)
      goto LABEL_8;
    if ((v13 + 95) <= 0x3Eu)
    {
      LOWORD(v13) = v13 - 320;
LABEL_8:
      v14 = 1;
      goto LABEL_9;
    }
    v20 = v9 - 2;
    if ((unint64_t)v9 < 2)
      return v12;
    v21 = a2[1];
    v22 = v21 | (v13 << 8);
    if (v13 >= 0xA0)
      v23 = 79;
    else
      v23 = 15;
    v24 = v23 + v13;
    v25 = (2 * (v24 & 0x1FF)) | 1;
    v26 = v21 + ((char)v21 >> 7);
    v27 = 2 * v24 + 2;
    if (v26 <= 0x9Du)
      v28 = v25;
    else
      v28 = v27;
    if (v26 <= 0x9Du)
      v29 = -31;
    else
      v29 = -125;
    v30 = (v29 + v26) | (unsigned __int16)(v28 << 8);
    if ((unsigned __int16)(v30 - 30067) < 0xABAEu)
      goto LABEL_37;
    v31 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
    v32 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
    while (1)
    {
      v33 = (0xF83E0F83E0F83E1 * (v32 - v31)) >> 1;
      v34 = &v31[33 * v33];
      v35 = *v34;
      if (v35 <= v30)
        break;
      v32 = v34 - 33;
LABEL_36:
      if (v31 > v32)
        goto LABEL_37;
    }
    if (v35 + 32 <= v30)
    {
      v31 = v34 + 33;
      goto LABEL_36;
    }
    LOWORD(v13) = v31[33 * v33 + 1 + (int)(v30 - v35)];
    if ((_WORD)v13)
    {
      v36 = (unsigned __int16)(v22 + 31054);
      if ((unsigned __int16)v13 == 65533 || v36 <= 3)
      {
        if (v36 > 3)
          goto LABEL_48;
LABEL_38:
        LOWORD(v22) = __CFFromKDDISJIS_KDDI_old_2_new_table[v22 - 34482] - 2128;
        goto LABEL_49;
      }
      v14 = 2;
LABEL_9:
      if (v48 && __CFStringEncodingIsDecomposableCharacter_2((unsigned __int16)v13, v47))
      {
        v15 = __CFStringEncodingDecomposeCharacter_2(a1, (unsigned __int16)v13, v50);
        v16 = *a6;
        v11 = *a6 + v15;
        *a6 = v11;
        if (a5)
        {
          if (v11 > a5)
          {
            *a6 = v16;
            return v12;
          }
          if (v15)
          {
            v17 = v15 + 1;
            v18 = (__int16 *)v50;
            do
            {
              v19 = *v18++;
              *a4++ = v19;
              --v17;
            }
            while (v17 > 1);
          }
        }
      }
      else
      {
        if (a5)
          *a4++ = v13;
        v11 = *a6 + 1;
        *a6 = v11;
      }
      v12 += v14;
      a2 += v14;
      v9 -= v14;
      continue;
    }
LABEL_37:
    if ((unsigned __int16)(v22 + 31054) < 4u)
      goto LABEL_38;
LABEL_48:
    if (v22 >> 6 < 0x3CD)
      return v12;
LABEL_49:
    if ((unsigned __int16)v22 > 0xF7FCu)
      return v12;
    v38 = (unsigned __int16 *)&__CFEmojiIndexFromKDDI_SJIS;
    v39 = (unsigned __int16 *)&unk_182DC6000;
    while (2)
    {
      v40 = ((char *)v39 - (char *)v38) >> 3;
      v41 = &v38[2 * v40];
      v42 = *v41;
      if (v42 > (unsigned __int16)v22)
      {
        v39 = v41 - 2;
        goto LABEL_55;
      }
      if (v42 < (unsigned __int16)v22)
      {
        v38 = v41 + 2;
LABEL_55:
        if (v38 > v39)
          return v12;
        continue;
      }
      break;
    }
    v43 = __CFFromEmojiIndex(v38[2 * v40 + 1], __src);
    v44 = v43;
    if (!a5)
      goto LABEL_60;
    if (a5 - v11 < v43)
      break;
    memcpy(a4, __src, 2 * v43);
    a4 += v44;
    v11 = *a6;
LABEL_60:
    v11 += v44;
    *a6 = v11;
    v12 += 2;
    a2 += 2;
    v9 = v20;
  }
  while (v9 > 0);
  return v12;
}

uint64_t __CFToISO_2022_JP_KDDI(char a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v8;
  uint64_t v9;
  _BOOL8 v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned __int16 *v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v18;
  char v19;
  _BOOL8 v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  const char *v24;
  int64_t v25;
  unsigned __int8 *v26;
  unsigned int v27;
  int v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  char v32;
  char v33;
  char v34;
  int v35;
  unsigned int v36;
  char v37;
  BOOL v38;
  char v39;
  char v40;
  unsigned __int16 *v41;
  unsigned __int16 *v42;
  uint64_t v43;
  unsigned __int16 *v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  char v48;
  char v49;
  unsigned int v50;
  char v51;
  char v52;
  unsigned int v53;
  BOOL v54;
  char v55;
  unsigned int v56;
  int IsValidCombiningCharacterForLatin1_4;
  uint64_t v58;
  unsigned __int16 *v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  char **v63;
  uint64_t v64;
  char *v65;
  _BOOL8 v66;
  __int16 v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char v73;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v78[2];

  v78[1] = *MEMORY[0x1E0C80C00];
  if (a3 < 1)
  {
    v12 = 0;
    v68 = 0;
    goto LABEL_172;
  }
  v8 = a3;
  v75 = a6;
  v76 = a2;
  v9 = a2 - 2;
  while (2)
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    do
    {
      if (a5 && a5 <= v11)
      {
        if ((a1 & 0x10) == 0)
          break;
        v14 = (unsigned __int16 *)(a2 + 2 * v12);
        v15 = *v14;
        v16 = (v15 - 774) > 0x32 || ((1 << (v15 - 6)) & 0x4000000000005) == 0;
        if (v16 && (v15 - 12441) >= 2)
          break;
      }
      else
      {
        v14 = (unsigned __int16 *)(a2 + 2 * v12);
        v15 = *v14;
        if (v15 <= 0x7F)
        {
          if (v14[1] != 8419)
          {
            v10 = v13 != 0;
            if (v13)
              v18 = 4;
            else
              v18 = 1;
            if (!a5)
            {
              v13 = 0;
              goto LABEL_50;
            }
            if (a5 - v11 >= v18)
            {
              if (v13)
              {
                *a4 = 27;
                *(_WORD *)(a4 + 1) = 16936;
                a4 += 3;
              }
              v13 = 0;
              *a4++ = v15;
              goto LABEL_50;
            }
            break;
          }
          goto LABEL_36;
        }
      }
      if ((unsigned __int16)(v15 + 159) <= 0x3Eu)
      {
        v10 = v13 != 3;
        if (v13 == 3)
          v18 = 1;
        else
          v18 = 4;
        if (a5)
        {
          if (a5 - v11 < v18)
            break;
          if (v13 != 3)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 18728;
            a4 += 3;
          }
          *a4++ = v15 - 64;
        }
        v13 = 3;
        goto LABEL_50;
      }
LABEL_36:
      if ((_DWORD)v15 == 8254 || (_DWORD)v15 == 165)
      {
        v10 = v13 != 2;
        if (v13 == 2)
          v18 = 1;
        else
          v18 = 4;
        if (a5)
        {
          if (a5 - v11 < v18)
            break;
          if (v13 != 2)
          {
            *a4 = 27;
            *(_WORD *)(a4 + 1) = 18984;
            a4 += 3;
          }
          if ((_DWORD)v15 == 165)
            v19 = 92;
          else
            v19 = 126;
          *a4++ = v19;
        }
        v13 = 2;
        goto LABEL_50;
      }
      v20 = v10;
      v78[0] = 0;
      v21 = __CFToEmojiIndex(v14, v8 - v12, v78);
      if (v21 != -1)
      {
        v22 = __CFKDDITable[v21];
        v10 = v13 != 1;
        if (v13 == 1)
          v23 = 0;
        else
          v23 = 3;
        if (v21 == 613)
        {
          v24 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFKDDITable[613] - 6;
          v25 = strlen(v24);
          v18 = v25 + v23;
          if (!a5)
          {
            v10 = v13 != 1;
LABEL_108:
            v12 += v78[0];
            v13 = 1;
            a2 = v76;
            goto LABEL_51;
          }
          if (a5 - v11 >= v18)
          {
            v10 = v13 != 1;
            if (v13 != 1)
            {
              *a4 = 27;
              *(_WORD *)(a4 + 1) = 16932;
              a4 += 3;
            }
            if (v25 >= 1)
            {
              v26 = (unsigned __int8 *)&v24[v25];
              do
              {
                v27 = *(unsigned __int8 *)v24;
                v28 = *((unsigned __int8 *)v24 + 1);
                v29 = v28 | (v27 << 8);
                v30 = (unsigned __int16)((v28 | ((_WORD)v27 << 8)) + 3264);
                if ((unsigned __int16)((v28 | ((_WORD)v27 << 8)) + 2496) <= 0x1BCu)
                  v27 = (v29 - 2816) >> 8;
                v31 = (v29 - 1536) >> 8;
                if (v30 <= 0x14D)
                  LOBYTE(v27) = v31;
                if ((v27 & 0xE0) >= 0xA0)
                  v32 = 79;
                else
                  v32 = 15;
                v33 = 2 * (v32 + v27);
                v34 = v33 | 1;
                v35 = v28 + ((char)v28 >> 7);
                v36 = (v28 + ((char)v28 >> 7));
                v37 = v33 + 2;
                v38 = v36 > 0x9D;
                if (v36 <= 0x9D)
                  v39 = v34;
                else
                  v39 = v37;
                if (v38)
                  v40 = 3;
                else
                  v40 = 97;
                *a4 = v39 & 0x7F;
                a4[1] = (v40 + v35) & 0x7F;
                a4 += 2;
                v24 += 2;
              }
              while (v24 < (const char *)v26);
            }
            goto LABEL_108;
          }
        }
        else
        {
          v46 = v22 >> 8;
          if ((unsigned __int16)(v22 + 2496) <= 0x1BCu)
            v46 = (v22 - 2816) >> 8;
          if ((unsigned __int16)(v22 + 3264) <= 0x14Du)
            v47 = (v22 - 1536) >> 8;
          else
            LOBYTE(v47) = v46;
          if ((v47 & 0xE0) >= 0xA0)
            v48 = 79;
          else
            v48 = 15;
          v49 = v48 + v47;
          v50 = v22 + ((char)v22 >> 7);
          if (v50 <= 0x9Du)
            v51 = (2 * v49) | 1;
          else
            v51 = 2 * v49 + 2;
          if (v50 <= 0x9Du)
            v52 = 97;
          else
            v52 = 3;
          v18 = v23 + 2;
          if (!a5)
            goto LABEL_108;
          if (a5 - v11 >= v18)
          {
            if (v13 != 1)
            {
              *a4 = 27;
              *(_WORD *)(a4 + 1) = 16932;
              a4 += 3;
            }
            *a4 = v51 & 0x7F;
            a4[1] = (v52 + v50) & 0x7F;
            a4 += 2;
            goto LABEL_108;
          }
        }
LABEL_149:
        a2 = v76;
        break;
      }
      v10 = v20;
      if ((unsigned __int16)(v15 + 12) < 0xACu)
        goto LABEL_122;
      v41 = (unsigned __int16 *)&__CFToJISCharMap;
      v42 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
      while (1)
      {
        v43 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v42 - v41)) >> 1;
        v44 = &v41[17 * v43];
        v45 = *v44;
        if (v45 <= v15)
          break;
        v42 = v44 - 17;
LABEL_85:
        if (v41 > v42)
          goto LABEL_122;
      }
      if (v45 + 16 <= v15)
      {
        v41 = v44 + 17;
        goto LABEL_85;
      }
      v53 = v41[17 * v43 + 1 + (int)(v15 - v45)];
      if (v41[17 * v43 + 1 + (int)(v15 - v45)])
        v54 = v53 > 0x7531;
      else
        v54 = 1;
      if (v54 || v53 - 10529 < 0x62E)
      {
LABEL_122:
        if ((a1 & 8) != 0)
          goto LABEL_149;
        if (((v15 - 774) > 0x32 || ((1 << (v15 - 6)) & 0x4000000000005) == 0)
          && (v15 - 12441) >= 2)
        {
          IsValidCombiningCharacterForLatin1_4 = __CFStringEncodingIsValidCombiningCharacterForLatin1_4(v15);
          v10 = v20;
          if (!IsValidCombiningCharacterForLatin1_4)
            goto LABEL_149;
        }
        if ((a1 & 0x10) == 0)
        {
          v18 = 0;
LABEL_148:
          a2 = v76;
          goto LABEL_50;
        }
        v58 = v76 + 2 * v12;
        v60 = *(unsigned __int16 *)(v58 - 2);
        v59 = (unsigned __int16 *)(v58 - 2);
        if (v60 > 0x7F)
          v61 = __CFPrecomposeCharJapanese(v59, 0);
        else
          v61 = __CFStringEncodingPrecomposeLatinCharacter_6(v59, v8 - v12 + 1, 0);
        v62 = __CFToJIS(v61, 1);
        if (!v62 || v62 == 65533 || (v62 & 0x8000) != 0)
          goto LABEL_149;
        if (v13 == 1)
        {
          v18 = 0;
          v63 = 0;
          v10 = 0;
          v64 = 2;
          if (a5)
            goto LABEL_137;
        }
        else
        {
          if (v13)
            v64 = 2;
          else
            v64 = 1;
          if (v20)
            v64 += LOBYTE((&__CFISO2022JPSequences)[2 * v13 + 1]) + 1;
          v18 = 5 - v64;
          v10 = 1;
          v63 = &off_1E1333CA8;
          if (a5)
          {
LABEL_137:
            if (a5 - v11 >= v18)
            {
              a4 -= v64;
              v55 = v62;
              v56 = v62 >> 8;
              if (v13 != 1)
              {
                *a4 = 27;
                v65 = a4 + 1;
                v66 = v10;
                v67 = v62;
                strncpy(v65, *v63, *((unsigned __int8 *)v63 + 8));
                LOBYTE(v56) = HIBYTE(v67);
                v55 = v67;
                v10 = v66;
                a4 = &v65[*((unsigned __int8 *)v63 + 8)];
              }
              goto LABEL_140;
            }
            goto LABEL_149;
          }
        }
LABEL_147:
        v13 = 1;
        goto LABEL_148;
      }
      if (v53 < 0x100)
        goto LABEL_149;
      v10 = v13 != 1;
      if (v13 == 1)
        v18 = 2;
      else
        v18 = 5;
      if (!a5)
        goto LABEL_147;
      if (a5 - v11 < v18)
        goto LABEL_149;
      v55 = v41[17 * v43 + 1 + (int)(v15 - v45)];
      v56 = v53 >> 8;
      if (v13 != 1)
      {
        *a4 = 27;
        *(_WORD *)(a4 + 1) = 16932;
        a4 += 3;
      }
LABEL_140:
      a2 = v76;
      *a4 = v56;
      a4[1] = v55 & 0x7F;
      a4 += 2;
      v13 = 1;
LABEL_50:
      ++v12;
LABEL_51:
      v11 += v18;
    }
    while (v12 < v8);
    if (!v13)
    {
      v68 = v11;
      goto LABEL_171;
    }
    v68 = v11 + 3;
    if (!a5)
      goto LABEL_171;
    if (v68 <= a5)
    {
      *a4 = 27;
      *(_WORD *)(a4 + 1) = 16936;
      goto LABEL_171;
    }
    do
    {
      v69 = v12;
      v70 = *(unsigned __int16 *)(v9 + 2 * v12);
      if (((v70 - 774) > 0x32 || ((1 << (v70 - 6)) & 0x4000000000005) == 0)
        && (v70 - 12441) >= 2)
      {
        v73 = __CFStringEncodingIsValidCombiningCharacterForLatin1_4(v70);
        a2 = v76;
      }
      else
      {
        v73 = 1;
      }
      --v12;
    }
    while (v69 >= 2 && (v73 & 1) != 0);
    if (v69 >= 2)
    {
      a4 -= v11;
      v8 = v69 - 1;
      continue;
    }
    break;
  }
  v68 = 0;
LABEL_171:
  a6 = v75;
LABEL_172:
  *a6 = v68;
  return v12;
}

uint64_t __CFFromISO_2022_JP_KDDI(unsigned int a1, unsigned __int8 *a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, _QWORD *a6)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned __int8 *v12;
  uint64_t v14;
  uint64_t v15;
  unsigned __int16 *v16;
  const char *v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  __int16 v24;
  unsigned int v25;
  __int16 v26;
  unsigned __int16 v27;
  unsigned int v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  uint64_t v33;
  unsigned __int16 *v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  BOOL v38;
  unsigned int v39;
  unsigned __int16 *v40;
  unsigned __int16 *v41;
  uint64_t v42;
  unsigned __int16 *v43;
  unsigned int v44;
  unsigned __int16 v45;
  BOOL v46;
  uint64_t v47;
  int IsDecomposableCharacter_2;
  uint64_t v49;
  uint64_t v50;
  uint64_t i;
  uint64_t v52;
  int v53;
  __int16 v54;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  unsigned int v60;
  uint64_t v62;
  __int16 __src[10];
  uint64_t v64;

  v6 = a6;
  v64 = *MEMORY[0x1E0C80C00];
  if (__CFADD__(a2, a3))
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    if (a6)
      goto LABEL_104;
  }
  else
  {
    v10 = a3;
    if (a3 < 1)
    {
      v7 = 0;
      v8 = 0;
      goto LABEL_104;
    }
    v11 = a4;
    v12 = a2;
    v56 = (unint64_t)&a2[a3];
    v14 = 0;
    v15 = 0;
    v8 = 0;
    v59 = a1 & 0xC0;
    v60 = a1;
    v7 = 0;
    v16 = a4;
    v62 = a5;
    while (2)
    {
      v9 = v8;
      v17 = (const char *)v12;
      v18 = v10;
LABEL_8:
      if (a5 && a5 <= v7)
        goto LABEL_93;
      v19 = *(unsigned __int8 *)v17;
      if (v19 != 27)
      {
        switch((_DWORD)v14)
        {
          case 1:
            if ((unint64_t)v18 < 2)
              goto LABEL_92;
            v20 = *((unsigned __int8 *)v17 + 1);
            if ((v19 & 1) != 0)
              v21 = 31;
            else
              v21 = 125;
            v22 = (v20 & 0x7F) + v21;
            v23 = (v19 + 479) >> 1;
            v24 = v23 - 127;
            v25 = (v23 - 127);
            if (v22 > 0x7E)
              LOBYTE(v22) = v22 + 1;
            v26 = v23 - 63;
            if (v25 <= 0x9F)
              v26 = v24;
            v27 = v22 | (unsigned __int16)(v26 << 8);
            v28 = (unsigned __int16)(v27 + 4800);
            if ((unsigned __int16)(v27 + 5312) >= 0x1BDu)
              v29 = v27;
            else
              v29 = v27 + 2816;
            v30 = v27 + 1536;
            if (v28 > 0x14D)
              v30 = v29;
            if ((unsigned __int16)(v30 + 2051) < 0xFB43u)
            {
LABEL_39:
              if ((a1 & 1) != 0)
              {
                v45 = 63;
                v11 = v16;
                goto LABEL_58;
              }
              v39 = v20 | (v19 << 8);
              if ((unsigned __int16)(v39 - 30067) < 0xABAEu)
              {
LABEL_92:
                LODWORD(v14) = 1;
LABEL_93:
                v10 = v18;
                v12 = (unsigned __int8 *)v17;
                v8 = v9;
                goto LABEL_94;
              }
              v11 = v16;
              v40 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
              v41 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
              while (2)
              {
                v42 = (0xF83E0F83E0F83E1 * (v41 - v40)) >> 1;
                v43 = &v40[33 * v42];
                v44 = *v43;
                if (v44 > v39)
                {
                  v41 = v43 - 33;
                  goto LABEL_46;
                }
                if (v44 + 32 <= v39)
                {
                  v40 = v43 + 33;
LABEL_46:
                  if (v40 > v41)
                    goto LABEL_92;
                  continue;
                }
                break;
              }
              v45 = v40[33 * v42 + 1 + (int)(v39 - v44)];
              if (v45)
                v46 = v45 == 65533;
              else
                v46 = 1;
              if (v46)
                goto LABEL_92;
LABEL_58:
              v47 = v14;
              if (!v59
                || (IsDecomposableCharacter_2 = __CFStringEncodingIsDecomposableCharacter_2(v45, (a1 >> 7) & 1),
                    a1 = v60,
                    a5 = v62,
                    !IsDecomposableCharacter_2))
              {
                if (a5)
                  *v11++ = v45;
                v8 = v9;
                v12 = (unsigned __int8 *)v17;
                v10 = v18;
                v15 = v7;
                goto LABEL_67;
              }
              v15 = v7 + 1;
              if (!v62)
                goto LABEL_63;
              if (v7 + 2 > v62)
                return v9;
              __CFStringEncodingDecomposeCharacter_2(v60, v45, v11);
              v15 = v7 + 1;
              a1 = v60;
              a5 = v62;
              v11 += 2;
LABEL_63:
              v8 = v9;
              v12 = (unsigned __int8 *)v17;
              v10 = v18;
LABEL_67:
              v49 = 2;
              v14 = v47;
              v6 = a6;
LABEL_68:
              v7 = v15 + 1;
              v9 = v8;
              v17 = (const char *)v12;
              v18 = v10;
LABEL_69:
              v8 = v49 + v9;
              v12 = (unsigned __int8 *)&v17[v49];
              v10 = v18 - v49;
              v15 = v7;
              v16 = v11;
              if (v18 - v49 < 1)
                goto LABEL_94;
              continue;
            }
            v31 = (unsigned __int16 *)&__CFEmojiIndexFromKDDI_SJIS;
            v32 = (unsigned __int16 *)&unk_182DC6000;
            while (1)
            {
              v33 = ((char *)v32 - (char *)v31) >> 3;
              v34 = &v31[2 * v33];
              v35 = *v34;
              if (v35 <= v30)
              {
                if (v35 >= v30)
                {
                  v57 = v15;
                  v36 = __CFFromEmojiIndex(v31[2 * v33 + 1], __src);
                  a5 = v62;
                  v37 = v36;
                  if (v62)
                  {
                    if (v62 - v7 < v36)
                    {
                      LODWORD(v14) = 1;
                      v10 = v18;
                      v12 = (unsigned __int8 *)v17;
                      v8 = v9;
                      v6 = a6;
                      goto LABEL_94;
                    }
                    memcpy(v16, __src, 2 * v36);
                    a5 = v62;
                    v16 += v37;
                  }
                  a1 = v60;
                  v7 += v37;
                  v9 += 2;
                  v17 += 2;
                  v38 = v18 <= 2;
                  v18 -= 2;
                  v6 = a6;
                  v14 = 1;
                  v15 = v57;
                  if (v38)
                    goto LABEL_92;
                  goto LABEL_8;
                }
                v31 = v34 + 2;
              }
              else
              {
                v32 = v34 - 2;
              }
              if (v31 > v32)
                goto LABEL_39;
            }
          case 3:
            if ((v19 - 96) < 0xFFFFFFC1)
            {
              LODWORD(v14) = 1;
              goto LABEL_108;
            }
            if (a5)
            {
              LOWORD(v19) = v19 - 192;
LABEL_89:
              *v11++ = v19;
            }
            break;
          case 2:
            if (a5)
            {
              if (v19 == 126)
                v54 = 8254;
              else
                v54 = *(unsigned __int8 *)v17;
              if (v19 == 92)
                LOWORD(v19) = 165;
              else
                LOWORD(v19) = v54;
              goto LABEL_89;
            }
            break;
          case 0:
            if (!a5)
              break;
            goto LABEL_89;
          default:
LABEL_108:
            v7 = v15;
            goto LABEL_94;
        }
        v49 = 1;
        goto LABEL_68;
      }
      break;
    }
    v58 = v7;
    v50 = v14;
    for (i = 0; i != 18; i += 2)
    {
      v52 = LOBYTE((&__CFISO2022JPSequences)[i + 1]);
      if (v56 >= (unint64_t)&v17[v52 + 1])
      {
        v53 = strncmp((&__CFISO2022JPSequences)[i], v17 + 1, LOBYTE((&__CFISO2022JPSequences)[i + 1]));
        a5 = v62;
        if (!v53)
        {
          v14 = *((unsigned __int8 *)&__CFISO2022JPSequences + 8 * i + 9);
          v49 = v52 + 1;
          v6 = a6;
          a1 = v60;
          v11 = v16;
          v7 = v58;
          goto LABEL_69;
        }
      }
    }
    v14 = v50;
    if ((v50 & 0xFD) == 0)
    {
      v11 = v16;
      v6 = a6;
      if (a5)
      {
        *v16 = 27;
        v11 = v16 + 1;
      }
      a1 = v60;
      v7 = v58 + 1;
      v49 = 1;
      goto LABEL_69;
    }
    v10 = v18;
    v12 = (unsigned __int8 *)v17;
    v8 = v9;
    v6 = a6;
    v7 = v58;
LABEL_94:
    if (a5
      && (_DWORD)v14
      && v10 == 3
      && v7 == a5
      && *v12 == 27
      && v56 >= (unint64_t)(v12 + 3)
      && !strncmp("(B", (const char *)v12 + 1, 2uLL))
    {
      v8 += 3;
    }
LABEL_104:
    *v6 = v7;
    return v8;
  }
  return v9;
}

uint64_t __CFToSoftBankSJIS(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v8;
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  const char *v20;
  size_t v21;
  uint64_t v22;
  size_t v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  unsigned __int16 *v27;
  unsigned __int16 *v28;
  uint64_t v29;
  unsigned __int16 *v30;
  unsigned int v31;
  unsigned int v32;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  uint64_t v35;
  unsigned __int16 *v36;
  unsigned int v37;
  char *v38;
  int v39;
  int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  char v44;
  unsigned int v45;
  char v46;
  int v47;
  uint64_t v48;
  _BYTE *v49;
  int v50;
  int v51;
  int v52;
  unsigned int v53;
  unsigned int v54;
  char v55;
  unsigned int v56;
  char v57;
  uint64_t v61[2];

  v61[1] = *MEMORY[0x1E0C80C00];
  if (a3 < 1)
  {
    v12 = 0;
    v22 = 0;
    goto LABEL_84;
  }
  v8 = a3;
  v11 = 0;
  v12 = 0;
  v61[0] = 0;
  do
  {
    if (a5 && v11 >= a5)
    {
      if ((a1 & 0x10) == 0)
        goto LABEL_82;
      v13 = *a2;
      v14 = (v13 - 774) > 0x32 || ((1 << (v13 - 6)) & 0x4000000000005) == 0;
      v15 = v13 - 12441;
      if (v14 && v15 >= 2)
        goto LABEL_82;
    }
    v17 = __CFToEmojiIndex(a2, v8 - v12, v61);
    if (v17 != -1)
    {
      v18 = __CFSoftBankTable[v17];
      if (v18 > 6)
      {
        v22 = v11 + 2;
        if (a5)
        {
          if (v22 > a5)
            goto LABEL_82;
          *a4 = BYTE1(v18);
          a4[1] = v18;
          a4 += 2;
        }
      }
      else
      {
        v19 = a1;
        v20 = (char *)&__CFCompatibilityEmojiSequences + 6 * __CFSoftBankTable[v17] - 6;
        v21 = strlen(v20);
        v22 = v21 + v11;
        if (a5)
        {
          if (v22 > a5)
            goto LABEL_82;
          v23 = v21;
          memcpy(a4, v20, v21);
          a4 += v23;
          a1 = v19;
          v8 = a3;
        }
        else
        {
          a1 = v19;
          v8 = a3;
        }
      }
      v25 = v61[0];
      goto LABEL_31;
    }
    v24 = *a2;
    if (v24 <= 0x7F)
    {
      v22 = v11 + 1;
      if (!a5)
        goto LABEL_28;
      goto LABEL_27;
    }
    if ((unsigned __int16)(v24 + 159) <= 0x3Eu)
    {
      v22 = v11 + 1;
      if (!a5)
        goto LABEL_28;
      LOBYTE(v24) = v24 + 64;
LABEL_27:
      *a4++ = v24;
      goto LABEL_28;
    }
    if ((unsigned __int16)(v24 + 12) < 0xACu)
    {
      LOWORD(v26) = -3;
      goto LABEL_42;
    }
    v27 = (unsigned __int16 *)&__CFToJISCharMap;
    v28 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (1)
    {
      v29 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v28 - v27)) >> 1;
      v30 = &v27[17 * v29];
      v31 = *v30;
      if (v31 <= v24)
        break;
      v28 = v30 - 17;
LABEL_40:
      if (v27 > v28)
        goto LABEL_41;
    }
    if (v31 + 16 <= v24)
    {
      v27 = v30 + 17;
      goto LABEL_40;
    }
    v38 = (char *)&v27[17 * v29];
    v26 = *(__int16 *)&v38[2 * (v24 - v31) + 2];
    if (*(_WORD *)&v38[2 * (v24 - v31) + 2])
    {
      if (v26 >= 256)
      {
        v22 = v11 + 2;
        if (a5)
        {
          if (v22 <= a5)
          {
            v39 = BYTE1(v26);
            v40 = v26 & 0x7F;
            if ((v26 & 0x100) != 0)
              v41 = 31;
            else
              v41 = 125;
            v42 = v41 + v40;
            v43 = (v39 + 479) >> 1;
            v44 = v43 - 127;
            v45 = (v43 - 127);
            if (v42 > 0x7E)
              LOBYTE(v42) = v42 + 1;
            v46 = v43 - 63;
            if (v45 <= 0x9F)
              v46 = v44;
            *a4 = v46;
            a4[1] = v42;
            a4 += 2;
            goto LABEL_28;
          }
LABEL_82:
          v22 = v11;
          break;
        }
LABEL_28:
        v25 = 1;
        goto LABEL_31;
      }
    }
    else
    {
LABEL_41:
      LOWORD(v26) = -3;
    }
LABEL_42:
    if ((a1 & 8) != 0 || v12 < 1 || (unsigned __int16)v26 != 65533)
      goto LABEL_82;
    if ((a1 & 0x10) == 0)
      goto LABEL_46;
    if ((v24 - 774 > 0x32 || ((1 << (v24 - 6)) & 0x4000000000005) == 0) && v24 - 12441 >= 2)
      goto LABEL_82;
    v32 = __CFPrecomposeCharJapanese(a2 - 1, 1);
    if ((unsigned __int16)(v32 + 12) < 0xACu)
      goto LABEL_82;
    v33 = (unsigned __int16 *)&__CFToJISCharMap;
    v34 = (unsigned __int16 *)((char *)&__CFToJISCharMap + 40086);
    while (2)
    {
      v35 = (uint64_t)(0xF0F0F0F0F0F0F0F1 * (v34 - v33)) >> 1;
      v36 = &v33[17 * v35];
      v37 = *v36;
      if (v37 > v32)
      {
        v34 = v36 - 17;
        goto LABEL_56;
      }
      if (v37 + 16 <= v32)
      {
        v33 = v36 + 17;
LABEL_56:
        if (v33 > v34)
          goto LABEL_82;
        continue;
      }
      break;
    }
    v47 = (__int16)v33[17 * v35 + 1 + (int)(v32 - v37)];
    if (v47 < 1)
      goto LABEL_82;
    if (a5)
    {
      v48 = -2;
      if (*(a4 - 1) == 61)
        v48 = -1;
      v49 = &a4[v48];
      v50 = BYTE1(v47);
      v51 = v47 & 0x7F;
      if ((v47 & 0x100) != 0)
        v52 = 31;
      else
        v52 = 125;
      v53 = v52 + v51;
      v54 = (v50 + 479) >> 1;
      v55 = v54 - 127;
      v56 = (v54 - 127);
      if (v53 > 0x7E)
        LOBYTE(v53) = v53 + 1;
      v57 = v54 - 63;
      if (v56 <= 0x9F)
        v57 = v55;
      *v49 = v57;
      v49[1] = v53;
    }
LABEL_46:
    v25 = 1;
    v22 = v11;
LABEL_31:
    a2 += v25;
    v12 += v25;
    v11 = v22;
  }
  while (v12 < v8);
LABEL_84:
  *a6 = v22;
  return v12;
}

uint64_t __CFFromSoftBankSJIS(unsigned int a1, char *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t v17;
  __int16 *v18;
  __int16 v19;
  uint64_t v20;
  int v21;
  __int16 v22;
  __int16 v23;
  __int16 v24;
  char v25;
  unsigned int v26;
  unsigned __int16 *v27;
  unsigned __int16 *v28;
  uint64_t v29;
  unsigned __int16 *v30;
  unsigned int v31;
  unsigned __int16 v32;
  unsigned int v34;
  unsigned __int16 *v35;
  unsigned __int16 *v36;
  uint64_t v37;
  unsigned __int16 *v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v44;
  int v45;
  __int16 __src[10];
  _BYTE v47[10];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (a3 < 1)
    return 0;
  v9 = a3;
  v11 = 0;
  v12 = 0;
  v44 = (a1 >> 7) & 1;
  v45 = a1 & 0xC0;
  do
  {
    if (a5 && a5 <= v11)
      return v12;
    v13 = *a2;
    if ((*a2 & 0x80000000) == 0)
      goto LABEL_8;
    if ((v13 + 95) <= 0x3Eu)
    {
      LOWORD(v13) = v13 - 320;
LABEL_8:
      v14 = 1;
LABEL_9:
      if (v45 && __CFStringEncodingIsDecomposableCharacter_2((unsigned __int16)v13, v44))
      {
        v15 = __CFStringEncodingDecomposeCharacter_2(a1, (unsigned __int16)v13, v47);
        v16 = *a6;
        v11 = *a6 + v15;
        *a6 = v11;
        if (a5)
        {
          if (v11 > a5)
          {
            *a6 = v16;
            return v12;
          }
          if (v15)
          {
            v17 = v15 + 1;
            v18 = (__int16 *)v47;
            do
            {
              v19 = *v18++;
              *a4++ = v19;
              --v17;
            }
            while (v17 > 1);
          }
        }
      }
      else
      {
        if (a5)
          *a4++ = v13;
        v11 = *a6 + 1;
        *a6 = v11;
      }
      v12 += v14;
      a2 += v14;
      v9 -= v14;
      continue;
    }
    v20 = v9 - 2;
    if ((unint64_t)v9 < 2)
      return v12;
    v21 = a2[1];
    if (v13 >= 0xA0)
      v22 = 79;
    else
      v22 = 15;
    v23 = v22 + v13;
    if ((v21 + ((char)v21 >> 7)) <= 0x9Du)
      v24 = (2 * (v23 & 0x1FF)) | 1;
    else
      v24 = 2 * v23 + 2;
    if ((v21 + ((char)v21 >> 7)) <= 0x9Du)
      v25 = -31;
    else
      v25 = -125;
    if ((unsigned __int16)(((v25 + v21 + ((char)v21 >> 7)) | (unsigned __int16)(v24 << 8)) - 30067) < 0xABAEu)
      goto LABEL_46;
    v26 = (unsigned __int16)((v25 + v21 + ((char)v21 >> 7)) | (unsigned __int16)(v24 << 8));
    v27 = (unsigned __int16 *)&__CFFromJIS0208CharMap;
    v28 = (unsigned __int16 *)((char *)&__CFFromJIS0208CharMap + 15972);
    while (1)
    {
      v29 = (0xF83E0F83E0F83E1 * (v28 - v27)) >> 1;
      v30 = &v27[33 * v29];
      v31 = *v30;
      if (v31 <= v26)
        break;
      v28 = v30 - 33;
LABEL_36:
      if (v27 > v28)
        goto LABEL_46;
    }
    if (v31 + 32 <= v26)
    {
      v27 = v30 + 33;
      goto LABEL_36;
    }
    v32 = v27[33 * v29 + 1 + (int)(v26 - v31)];
    if (v32 != 65533 && v32 != 0)
    {
      LOWORD(v13) = v32;
      v14 = 2;
      goto LABEL_9;
    }
LABEL_46:
    v34 = v21 | (v13 << 8);
    if ((unsigned __int16)(v34 + 1064) < 0xFB69u)
      return v12;
    v35 = (unsigned __int16 *)&__CFEmojiIndexFromSoftBankSJIS;
    v36 = (unsigned __int16 *)&unk_182DC6D06;
    while (2)
    {
      v37 = ((char *)v36 - (char *)v35) >> 3;
      v38 = &v35[2 * v37];
      v39 = *v38;
      if (v39 > v34)
      {
        v36 = v38 - 2;
        goto LABEL_52;
      }
      if (v39 < v34)
      {
        v35 = v38 + 2;
LABEL_52:
        if (v35 > v36)
          return v12;
        continue;
      }
      break;
    }
    v40 = __CFFromEmojiIndex(v35[2 * v37 + 1], __src);
    v41 = v40;
    if (!a5)
      goto LABEL_57;
    if (a5 - v11 < v40)
      break;
    memcpy(a4, __src, 2 * v40);
    a4 += v41;
    v11 = *a6;
LABEL_57:
    v11 += v41;
    *a6 = v11;
    v12 += 2;
    a2 += 2;
    v9 = v20;
  }
  while (v9 > 0);
  return v12;
}

void sub_182BF3388(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182BF5BA8(_Unwind_Exception *a1)
{
  free(0);
  _Unwind_Resume(a1);
}

void sub_182BF6080(_Unwind_Exception *a1)
{
  free(0);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_0_15(objc_class *a1)
{
  uint64_t v1;

  __CFRequireConcreteImplementation(a1, v1);
}

void _systemClockChangedNotification()
{
  __CFNotificationCenter *LocalCenter;

  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, CFSTR("NSSystemClockDidChangeNotification"), 0, 0, 1u);
}

const void *__CFDateCopyDescription(void *a1)
{
  void *v2;
  const void *v3;
  const void *v4;

  v2 = (void *)_CFAutoreleasePoolPush();
  v3 = (const void *)objc_msgSend(a1, "description");
  v4 = v3;
  if (v3)
    CFRetain(v3);
  _CFAutoreleasePoolPop(v2);
  return v4;
}

void OUTLINED_FUNCTION_0_16(objc_class *a1)
{
  uint64_t v1;

  __CFRequireConcreteImplementation(a1, v1);
}

uint64_t _NSCFCalendarLogger()
{
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  return _NSCFCalendarLogger__logger;
}

void _CFICULog(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  const __CFString *v10;
  const __CFString *v11;
  CFIndex Length;
  CFIndex v13;
  char *v14;
  char *v15;
  int CString;
  size_t v17;
  FILE *v18;
  BOOL v19;
  const char *v20;

  _CFLogvEx3(0, 0, 0, 0, 7, a1, &a9);
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    if (a1)
    {
      v10 = _CFStringCreateWithFormatAndArgumentsAux2((const __CFAllocator *)&__kCFAllocatorSystemDefault, 0, 0, 0, 0, a1, &a9);
      if (v10)
      {
        v11 = v10;
        Length = CFStringGetLength(v10);
        v13 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 16;
        v14 = (char *)malloc_type_malloc(v13, 0xD17E509DuLL);
        if (!v14)
        {
LABEL_17:
          CFRelease(v11);
          return;
        }
        v15 = v14;
        CString = CFStringGetCString(v11, v14, v13, 0x8000100u);
        v17 = strlen(v15);
        os_unfair_lock_lock((os_unfair_lock_t)&__CFICULogLock);
        fputs("// ", (FILE *)___CFICULoggingFD);
        v18 = (FILE *)___CFICULoggingFD;
        if (CString)
          v19 = v17 == 0;
        else
          v19 = 1;
        if (v19 || v17 > 0x10000)
        {
          v20 = "<unloggable message>\n";
        }
        else
        {
          fputs(v15, (FILE *)___CFICULoggingFD);
          if (v15[v17 - 1] == 10)
          {
LABEL_16:
            os_unfair_lock_unlock((os_unfair_lock_t)&__CFICULogLock);
            free(v15);
            goto LABEL_17;
          }
          v18 = (FILE *)___CFICULoggingFD;
          v20 = "\n";
        }
        fputs(v20, v18);
        goto LABEL_16;
      }
    }
  }
}

uint64_t ___CFICUCreateVariableNameForStatus(const void *a1)
{
  CFStringRef v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  v2 = ___CFICUCreateVariableNameForStackPointerLocked("status", a1);
  v6[3] = (uint64_t)v2;
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  v3 = v6[3];
  _Block_object_dispose(&v5, 8);
  ___CFICULogWithArguments(1, &stru_1E1337B18);
  ___CFICULogWithArguments(1, CFSTR("UErrorCode %@ = U_ZERO_ERROR;"), v3);
  return v3;
}

void sub_182BF6F30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFStringRef ___CFICUCreateErrorStringWithComment(int *a1, int a2)
{
  CFTypeRef v4;
  const char *v5;

  v4 = CFRetain(&stru_1E1337B18);
  if (*a1 < 1)
    return (CFStringRef)v4;
  v5 = u_errorName((UErrorCode)*a1);
  if (a2)
    return CFStringCreateWithFormat(0, 0, CFSTR("// ERROR: %s"), v5);
  else
    return CFStringCreateWithFormat(0, 0, CFSTR("(ERROR: %s)"), v5);
}

CFStringRef ___CFICUCreateArgumentForUCharInput(UChar *s, int32_t a2, uint64_t a3)
{
  int32_t v4;
  const void *v6;
  CFStringRef v7;
  CFStringRef v8;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (!s)
    return (CFStringRef)CFRetain(CFSTR("NULL"));
  v4 = a2;
  if (a2 == -1)
    v4 = u_strlen(s);
  v10 = MEMORY[0x1E0C809B0];
  v11 = 0x40000000;
  v12 = _____CFICUCreateArgumentForUCharInput_block_invoke;
  v13 = &__block_descriptor_tmp_183;
  LODWORD(v14) = a3;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCreateArgumentForUCharInput_block_invoke((uint64_t)&v10);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  v6 = (const void *)___CFICUCreateVariableName("temp");
  v7 = CFStringCreateWithCharacters(0, s, v4);
  v8 = CFStringCreateWithFormat(0, 0, CFSTR("TEMP_UCHAR%d(\"%@\")"), a3, v7, v10, v11, v12, v13, v14, v15);
  CFRelease(v7);
  CFRelease(v6);
  return v8;
}

uint64_t ___CFICUCreateVariableNameForStatusIfNeeded(uint64_t a1)
{
  uint64_t v1;
  char v3;
  _QWORD v4[8];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[2] = _____CFICUCreateVariableNameForStackPointerIfNeeded_block_invoke;
  v4[3] = &unk_1E1333F60;
  v4[1] = 0x40000000;
  v4[4] = &v5;
  v4[5] = "status";
  v4[6] = a1;
  v4[7] = &v3;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCreateVariableNameForStackPointerIfNeeded_block_invoke((uint64_t)v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  v1 = v6[3];
  _Block_object_dispose(&v5, 8);
  if (v3)
  {
    ___CFICULogWithArguments(1, &stru_1E1337B18);
    ___CFICULogWithArguments(1, CFSTR("UErrorCode %@ = U_ZERO_ERROR;"), v1);
  }
  return v1;
}

void sub_182BF7224(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

uint64_t __cficu_ucal_getAttribute(uint64_t a1, unsigned int a2)
{
  uint64_t Attribute;
  CFStringRef v5;
  NSObject *v6;
  const char *v8;
  int v9;
  CFStringRef v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  Attribute = ucal_getAttribute();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v5 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v6 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        if (a2 > 4)
          v8 = "<unknown UCalendarAttribute>";
        else
          v8 = off_1E1333F80[a2];
        v9 = 138412802;
        v10 = v5;
        v11 = 2080;
        v12 = v8;
        v13 = 1024;
        v14 = Attribute;
        _os_log_debug_impl(&dword_182A8C000, v6, OS_LOG_TYPE_DEBUG, "ucal_getAttribute(%@, %s); // %d",
          (uint8_t *)&v9,
          0x1Cu);
      }
      CFRelease(v5);
    }
  }
  return Attribute;
}

CFStringRef ___CFICUCreateArgumentForDouble(double a1)
{
  if (fabs(a1) != INFINITY)
    return CFStringCreateWithFormat(0, 0, CFSTR("%f"), *(_QWORD *)&a1);
  if (a1 <= 0.0)
    return (CFStringRef)CFRetain(CFSTR("-INFINITY"));
  return (CFStringRef)CFRetain(CFSTR("INFINITY"));
}

void __cficu_ucal_setMillis(uint64_t a1, int *a2, double a3)
{
  CFStringRef v6;
  const void *v7;
  CFStringRef v8;
  CFStringRef v9;
  NSObject *v10;
  int v11;
  CFStringRef v12;
  __int16 v13;
  CFStringRef v14;
  __int16 v15;
  const void *v16;
  __int16 v17;
  CFStringRef v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  ucal_setMillis();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      v8 = ___CFICUCreateArgumentForDouble(a3);
      v9 = ___CFICUCreateErrorStringWithComment(a2, 1);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v10 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v11 = 138413058;
        v12 = v6;
        v13 = 2112;
        v14 = v8;
        v15 = 2112;
        v16 = v7;
        v17 = 2112;
        v18 = v9;
        _os_log_debug_impl(&dword_182A8C000, v10, OS_LOG_TYPE_DEBUG, "ucal_setMillis(%@, %@, &%@); %@",
          (uint8_t *)&v11,
          0x2Au);
      }
      CFRelease(v6);
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }
}

const char *___CFICUGetEnumStringForUCalendarDateFields(unsigned int a1)
{
  if (a1 > 0x18)
    return "<unknown UCalendarDateFields>";
  else
    return off_1E1333FA8[a1];
}

uint64_t __cficu_ucal_getDayOfWeekType(uint64_t a1, int a2, int *a3)
{
  uint64_t DayOfWeekType;
  CFStringRef v7;
  const void *v8;
  CFStringRef v9;
  NSObject *v10;
  const char *v12;
  const char *v13;
  int v14;
  CFStringRef v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const void *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  CFStringRef v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  DayOfWeekType = ucal_getDayOfWeekType();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      v9 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v10 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        if ((a2 - 1) > 6)
          v12 = "<unknown UCalendarDaysOfWeek>";
        else
          v12 = off_1E1334088[a2 - 1];
        if ((DayOfWeekType - 1) > 2)
          v13 = "UCAL_WEEKDAY";
        else
          v13 = off_1E1334070[(int)DayOfWeekType - 1];
        v14 = 138413314;
        v15 = v7;
        v16 = 2080;
        v17 = v12;
        v18 = 2112;
        v19 = v8;
        v20 = 2080;
        v21 = v13;
        v22 = 2112;
        v23 = v9;
        _os_log_debug_impl(&dword_182A8C000, v10, OS_LOG_TYPE_DEBUG, "ucal_getDayOfWeekType(%@, %s, &%@); // %s %@",
          (uint8_t *)&v14,
          0x34u);
      }
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }
  return DayOfWeekType;
}

uint64_t __cficu_ucal_getWeekendTransition(uint64_t a1, int a2, int *a3)
{
  uint64_t WeekendTransition;
  CFStringRef v7;
  const void *v8;
  CFStringRef v9;
  NSObject *v10;
  const char *v12;
  int v13;
  CFStringRef v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  const void *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  CFStringRef v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  WeekendTransition = ucal_getWeekendTransition();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      v9 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v10 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        if ((a2 - 1) > 6)
          v12 = "<unknown UCalendarDaysOfWeek>";
        else
          v12 = off_1E1334088[a2 - 1];
        v13 = 138413314;
        v14 = v7;
        v15 = 2080;
        v16 = v12;
        v17 = 2112;
        v18 = v8;
        v19 = 1024;
        v20 = WeekendTransition;
        v21 = 2112;
        v22 = v9;
        _os_log_debug_impl(&dword_182A8C000, v10, OS_LOG_TYPE_DEBUG, "ucal_getWeekendTransition(%@, %s, &%@); // %d %@",
          (uint8_t *)&v13,
          0x30u);
      }
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v9);
    }
  }
  return WeekendTransition;
}

uint64_t __cficu_ucal_isWeekend(uint64_t a1, int *a2, double a3)
{
  uint64_t isWeekend;
  CFStringRef v7;
  const void *v8;
  CFStringRef v9;
  CFStringRef v10;
  NSObject *v11;
  int v13;
  CFStringRef v14;
  __int16 v15;
  CFStringRef v16;
  __int16 v17;
  const void *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  CFStringRef v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  isWeekend = ucal_isWeekend();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v7 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v8 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
      v9 = ___CFICUCreateArgumentForDouble(a3);
      v10 = ___CFICUCreateErrorStringWithComment(a2, 0);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v11 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v13 = 138413314;
        v14 = v7;
        v15 = 2112;
        v16 = v9;
        v17 = 2112;
        v18 = v8;
        v19 = 1024;
        v20 = isWeekend;
        v21 = 2112;
        v22 = v10;
        _os_log_debug_impl(&dword_182A8C000, v11, OS_LOG_TYPE_DEBUG, "ucal_isWeekend(%@, %@, &%@); // %d %@",
          (uint8_t *)&v13,
          0x30u);
      }
      CFRelease(v7);
      CFRelease(v8);
      CFRelease(v10);
      CFRelease(v9);
    }
  }
  return isWeekend;
}

uint64_t __cficu_ucal_getLimit(uint64_t a1, unsigned int a2, unsigned int a3, int *a4)
{
  uint64_t Limit;
  CFStringRef v9;
  const void *v10;
  CFStringRef v11;
  NSObject *v12;
  const char *v14;
  const char *v15;
  int v16;
  CFStringRef v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const void *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  CFStringRef v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  Limit = ucal_getLimit();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      v11 = ___CFICUCreateErrorStringWithComment(a4, 0);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v12 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v14 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        if (a3 > 5)
          v15 = "<unknown UCalendarLimitType>";
        else
          v15 = off_1E13340C0[a3];
        v16 = 138413570;
        v17 = v9;
        v18 = 2080;
        v19 = v14;
        v20 = 2080;
        v21 = v15;
        v22 = 2112;
        v23 = v10;
        v24 = 1024;
        v25 = Limit;
        v26 = 2112;
        v27 = v11;
        _os_log_debug_impl(&dword_182A8C000, v12, OS_LOG_TYPE_DEBUG, "ucal_getLimit(%@, %s, %s, &%@); // %d %@",
          (uint8_t *)&v16,
          0x3Au);
      }
      CFRelease(v9);
      CFRelease(v10);
      CFRelease(v11);
    }
  }
  return Limit;
}

void __cficu_ucal_add(uint64_t a1, unsigned int a2, int a3, int *a4)
{
  CFStringRef v8;
  const void *v9;
  CFStringRef v10;
  NSObject *v11;
  int v12;
  CFStringRef v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  const void *v19;
  __int16 v20;
  CFStringRef v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  ucal_add();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v8 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v9 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      v10 = ___CFICUCreateErrorStringWithComment(a4, 1);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v11 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v12 = 138413314;
        v13 = v8;
        v14 = 2080;
        v15 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        v16 = 1024;
        v17 = a3;
        v18 = 2112;
        v19 = v9;
        v20 = 2112;
        v21 = v10;
        _os_log_debug_impl(&dword_182A8C000, v11, OS_LOG_TYPE_DEBUG, "ucal_add(%@, %s, %d, &%@); %@",
          (uint8_t *)&v12,
          0x30u);
      }
      CFRelease(v8);
      CFRelease(v9);
      CFRelease(v10);
    }
  }
}

void __cficu_ucal_roll(uint64_t a1, unsigned int a2, int a3, int *a4)
{
  CFStringRef v8;
  const void *v9;
  CFStringRef v10;
  NSObject *v11;
  int v12;
  CFStringRef v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  const void *v19;
  __int16 v20;
  CFStringRef v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  ucal_roll();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v8 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v9 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a4);
      v10 = ___CFICUCreateErrorStringWithComment(a4, 1);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v11 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v12 = 138413314;
        v13 = v8;
        v14 = 2080;
        v15 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        v16 = 1024;
        v17 = a3;
        v18 = 2112;
        v19 = v9;
        v20 = 2112;
        v21 = v10;
        _os_log_debug_impl(&dword_182A8C000, v11, OS_LOG_TYPE_DEBUG, "ucal_roll(%@, %s, %d, &%@); %@",
          (uint8_t *)&v12,
          0x30u);
      }
      CFRelease(v8);
      CFRelease(v9);
      CFRelease(v10);
    }
  }
}

uint64_t __cficu_ucal_getFieldDifference(uint64_t a1, unsigned int a2, int *a3, double a4)
{
  uint64_t FieldDifference;
  CFStringRef v9;
  const void *v10;
  CFStringRef v11;
  CFStringRef v12;
  NSObject *v13;
  int v15;
  CFStringRef v16;
  __int16 v17;
  CFStringRef v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const void *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  CFStringRef v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  FieldDifference = ucal_getFieldDifference();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
  {
    if (___CFICULoggingEnabled_oncep != -1)
      dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
    if (___CFICULoggingEnabled_loggingEnabled == 1)
    {
      v9 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"cal", a1);
      v10 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a3);
      v11 = ___CFICUCreateArgumentForDouble(a4);
      v12 = ___CFICUCreateErrorStringWithComment(a3, 0);
      if (_NSCFCalendarLogger_onceToken != -1)
        dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
      v13 = _NSCFCalendarLogger__logger;
      if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
      {
        v15 = 138413570;
        v16 = v9;
        v17 = 2112;
        v18 = v11;
        v19 = 2080;
        v20 = ___CFICUGetEnumStringForUCalendarDateFields(a2);
        v21 = 2112;
        v22 = v10;
        v23 = 1024;
        v24 = FieldDifference;
        v25 = 2112;
        v26 = v12;
        _os_log_debug_impl(&dword_182A8C000, v13, OS_LOG_TYPE_DEBUG, "ucal_getFieldDifference(%@, %@, %s, &%@); // %d %@",
          (uint8_t *)&v15,
          0x3Au);
      }
      CFRelease(v9);
      CFRelease(v10);
      CFRelease(v11);
      CFRelease(v12);
    }
  }
  return FieldDifference;
}

double __cficu_ucal_getNow()
{
  double v0;
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v0 = MEMORY[0x186DB0D14]();
  if (_NSCFCalendarLogger_onceToken != -1)
    dispatch_once(&_NSCFCalendarLogger_onceToken, &__block_literal_global_28);
  v1 = _NSCFCalendarLogger__logger;
  if (os_log_type_enabled((os_log_t)_NSCFCalendarLogger__logger, OS_LOG_TYPE_DEBUG))
    __cficu_ucal_getNow_cold_1(v1, v2, v3, v4, v5, v6, v7, v8);
  return v0;
}

void ___CFICULogWithArguments(int a1, CFStringRef format, ...)
{
  const __CFString *v3;
  char *v4;
  CFIndex Length;
  CFIndex v6;
  va_list va;

  va_start(va, format);
  v3 = CFStringCreateWithFormatAndArguments(0, 0, format, va);
  if (CFStringGetCStringPtr(v3, 0x8000100u))
  {
    v4 = 0;
  }
  else
  {
    Length = CFStringGetLength(v3);
    v6 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    v4 = (char *)malloc_type_malloc(v6, 0x100004077774924uLL);
    CFStringGetCString(v3, v4, v6, 0x8000100u);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__CFICULogLock);
  if (a1)
    fprintf((FILE *)___CFICULoggingFD, "\t%s\n");
  else
    fprintf((FILE *)___CFICULoggingFD, "%s\n");
  os_unfair_lock_unlock((os_unfair_lock_t)&__CFICULogLock);
  if (v4)
    free(v4);
  CFRelease(v3);
}

void __cficu_udatpg_close(const void *a1)
{
  CFStringRef v2;

  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dtpg", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    udatpg_close();
    ___CFICULogWithArguments(1, CFSTR("udatpg_close(%@);"), v2);
    CFRelease(v2);
  }
  else
  {
    udatpg_close();
  }
}

CFTypeRef ___CFICUCreateVariableNameForUCharOutput(char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  if (!a2)
    return CFRetain(CFSTR("NULL"));
  v4 = ___CFICUCreateVariableName(a1);
  ___CFICULogWithArguments(1, CFSTR("UChar %@[%d];"), v4, a3);
  return (CFTypeRef)v4;
}

const char *___CFICUGetEnumStringForUDateFormatSymbolType(unsigned int a1)
{
  if (a1 > 0x15)
    return "<unknown UDateFormatSymbolType>";
  else
    return off_1E13340F0[a1];
}

uint64_t __cficu_udat_formatForFields(uint64_t a1, const UniChar *a2, uint64_t a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12;
  CFStringRef v13;
  const void *v14;
  CFTypeRef v15;
  CFStringRef v16;
  CFStringRef v17;
  CFStringRef v18;

  v12 = udat_formatForFields();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    v15 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a2, a3);
    v16 = ___CFICUCreateArgumentForDouble(a6);
    v17 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0)
    {
      v18 = CFStringCreateWithCharacters(0, a2, (int)v12);
      if (!a4)
        goto LABEL_7;
    }
    else
    {
      v18 = 0;
      if (!a4)
      {
LABEL_7:
        ___CFICULogWithArguments(1, CFSTR("udat_format(%@, %@, %@, %d, NULL, &%@); // %d %@ %@"),
          v13,
          v16,
          v15,
          a3,
          v14,
          v12,
          v18,
          v17);
        ___CFICULogWithArguments(1, CFSTR("u_printf(\"%@: '%%S'\\n\", %@);"), v15, v15);
        CFRelease(v13);
        CFRelease(v14);
        CFRelease(v15);
        CFRelease(v16);
        if (v18)
          CFRelease(v18);
        CFRelease(v17);
        return v12;
      }
    }
    ___CFICULogWithArguments(1, CFSTR("#warning non-NULL UFieldPositionIterator ignored"));
    goto LABEL_7;
  }
  return v12;
}

double __cficu_udat_get2DigitYearStart(uint64_t a1, int *a2)
{
  double v4;
  double v5;
  CFStringRef v6;
  const void *v7;
  CFStringRef v8;

  udat_get2DigitYearStart();
  v5 = v4;
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v7 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    v8 = ___CFICUCreateErrorStringWithComment(a2, 0);
    ___CFICULogWithArguments(1, CFSTR("udat_get2DigitYearStart(%@, &%@);
    CFRelease(v6);
    CFRelease(v7);
    CFRelease(v8);
  }
  return v5;
}

uint64_t __cficu_udat_isLenient(uint64_t a1)
{
  uint64_t isLenient;
  CFStringRef v3;

  isLenient = udat_isLenient();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v3 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    ___CFICULogWithArguments(1, CFSTR("udat_isLenient(%@);
    CFRelease(v3);
  }
  return isLenient;
}

uint64_t ___CFICUCreateVariableName(char *a1)
{
  CFStringRef v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  v2 = ___CFICUCreateVariableNameLocked(a1);
  v6[3] = (uint64_t)v2;
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  v3 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v3;
}

void sub_182BF8AB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const char *___CFICUGetEnumStringForUDateFormatStyle(int a1)
{
  int v1;
  const char *result;

  v1 = a1 + 2;
  result = "UDAT_FULL";
  switch(v1)
  {
    case 0:
      result = "UDAT_IGNORE";
      break;
    case 1:
      result = "UDAT_NONE";
      break;
    case 2:
      return result;
    case 3:
      result = "UDAT_LONG";
      break;
    case 4:
      result = "UDAT_MEDIUM";
      break;
    case 5:
      result = "UDAT_SHORT";
      break;
    default:
      switch("UDAT_FULL")
      {
        case 0x80u:
          result = "UDAT_RELATIVE";
          break;
        case 0x81u:
          result = "UDAT_LONG_RELATIVE";
          break;
        case 0x82u:
          result = "UDAT_MEDIUM_RELATIVE";
          break;
        case 0x83u:
          result = "UDAT_SHORT_RELATIVE";
          break;
        default:
          result = "<unknown UDateFormatStyle>";
          break;
      }
      break;
  }
  return result;
}

CFStringRef ___CFICUCreateArgumentForParsePosition(unsigned int *a1)
{
  const void *v2;
  CFStringRef v3;

  if (!a1)
    return (CFStringRef)CFRetain(CFSTR("NULL"));
  v2 = (const void *)___CFICUCreateVariableName("parsePos");
  v3 = CFStringCreateWithFormat(0, 0, CFSTR("&%@"), v2);
  ___CFICULogWithArguments(1, CFSTR("int32_t %@ = %d;"), v2, *a1);
  CFRelease(v2);
  return v3;
}

void __cficu_udat_setSymbols(uint64_t a1, unsigned int a2, uint64_t a3, UChar *a4, uint64_t a5, int *a6)
{
  CFStringRef v12;
  const void *v13;
  CFStringRef v14;
  CFStringRef v15;
  const char *v16;

  udat_setSymbols();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"dateFmt", a1);
    v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a6);
    v14 = ___CFICUCreateErrorStringWithComment(a6, 1);
    v15 = ___CFICUCreateArgumentForUCharInput(a4, a5, 0);
    v16 = ___CFICUGetEnumStringForUDateFormatSymbolType(a2);
    ___CFICULogWithArguments(1, CFSTR("udat_setSymbols(%@, %s, %d, %@, %d, &%@); %@"), v12, v16, a3, v15, a5, v13, v14);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v15);
    CFRelease(v14);
  }
}

const char *___CFICUGetEnumStringForUNumberFormatAttribute(int a1)
{
  const char *result;

  result = "UNUM_PARSE_INT_ONLY";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = "UNUM_GROUPING_USED";
      break;
    case 2:
      result = "UNUM_DECIMAL_ALWAYS_SHOWN";
      break;
    case 3:
      result = "UNUM_MAX_INTEGER_DIGITS";
      break;
    case 4:
      result = "UNUM_MIN_INTEGER_DIGITS";
      break;
    case 5:
      result = "UNUM_INTEGER_DIGITS";
      break;
    case 6:
      result = "UNUM_MAX_FRACTION_DIGITS";
      break;
    case 7:
      result = "UNUM_MIN_FRACTION_DIGITS";
      break;
    case 8:
      result = "UNUM_FRACTION_DIGITS";
      break;
    case 9:
      result = "UNUM_MULTIPLIER";
      break;
    case 10:
      result = "UNUM_GROUPING_SIZE";
      break;
    case 11:
      result = "UNUM_ROUNDING_MODE";
      break;
    case 12:
      result = "UNUM_ROUNDING_INCREMENT";
      break;
    case 13:
      result = "UNUM_FORMAT_WIDTH";
      break;
    case 14:
      result = "UNUM_PADDING_POSITION";
      break;
    case 15:
      result = "UNUM_SECONDARY_GROUPING_SIZE";
      break;
    case 16:
      result = "UNUM_SIGNIFICANT_DIGITS_USED";
      break;
    case 17:
      result = "UNUM_MIN_SIGNIFICANT_DIGITS";
      break;
    case 18:
      result = "UNUM_MAX_SIGNIFICANT_DIGITS";
      break;
    case 19:
      result = "UNUM_LENIENT_PARSE";
      break;
    case 20:
      result = "UNUM_PARSE_ALL_INPUT";
      break;
    default:
      switch(a1)
      {
        case 4095:
          result = "UNUM_MAX_NONBOOLEAN_ATTRIBUTE";
          break;
        case 4096:
          result = "UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS";
          break;
        case 4097:
          result = "UNUM_PARSE_NO_EXPONENT";
          break;
        case 4101:
          result = "UNUM_LIMIT_BOOLEAN_ATTRIBUTE";
          break;
        default:
          result = "<unknown UNumberFormatAttribute>";
          break;
      }
      break;
  }
  return result;
}

double __cficu_unum_getDoubleAttribute(uint64_t a1, int a2)
{
  double v4;
  double v5;
  CFStringRef v6;
  const char *v7;

  unum_getDoubleAttribute();
  v5 = v4;
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v6 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v7 = ___CFICUGetEnumStringForUNumberFormatAttribute(a2);
    ___CFICULogWithArguments(1, CFSTR("unum_getAttribute(%@, %s);
    CFRelease(v6);
  }
  return v5;
}

const char *___CFICUGetEnumStringForUNumberFormatSymbol(unsigned int a1)
{
  if (a1 > 0x1D)
    return "<unknown UNumberFormatSymbol>";
  else
    return off_1E13341A0[a1];
}

uint64_t __cficu_unum_getTextAttribute(uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5)
{
  uint64_t TextAttribute;
  CFStringRef v11;
  CFTypeRef v12;
  const void *v13;
  CFStringRef v14;
  CFStringRef v15;
  const char *v16;

  TextAttribute = unum_getTextAttribute();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v11 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
    v12 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a3, a4);
    v13 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    v14 = ___CFICUCreateErrorStringWithComment(a5, 0);
    if (*a5 <= 0)
      v15 = CFStringCreateWithCharacters(0, a3, (int)TextAttribute);
    else
      v15 = 0;
    if (a2 > 7)
      v16 = "<unknown UNumberFormatTextAttribute>";
    else
      v16 = off_1E1334320[a2];
    ___CFICULogWithArguments(1, CFSTR("unum_getTextAttribute(%@, %s, %@, %d, &%@); // %d %@ %@"),
      v11,
      v16,
      v12,
      a4,
      v13,
      TextAttribute,
      v15,
      v14);
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    if (v15)
      CFRelease(v15);
    CFRelease(v14);
  }
  return TextAttribute;
}

uint64_t __cficu_unum_parse(uint64_t a1, UChar *a2, uint64_t a3, unsigned int *a4, int *a5)
{
  CFStringRef v10;
  uint64_t v11;
  CFStringRef v12;
  CFStringRef v13;
  const void *v14;
  CFStringRef v15;

  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if ((___CFICULoggingEnabled_loggingEnabled & 1) == 0)
    return unum_parse();
  v10 = ___CFICUCreateArgumentForParsePosition(a4);
  v11 = unum_parse();
  v12 = ___CFICUCreateArgumentForUCharInput(a2, a3, 0);
  v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a1);
  v14 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
  v15 = ___CFICUCreateErrorStringWithComment(a5, 0);
  ___CFICULogWithArguments(1, CFSTR("unum_parse(%@, %@, %d, %@, &%@);
  CFRelease(v13);
  CFRelease(v14);
  CFRelease(v12);
  CFRelease(v10);
  CFRelease(v15);
  return v11;
}

uint64_t __cficu_ulistfmt_open(uint64_t a1, void *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  CFStringRef v7;

  v4 = ulistfmt_open();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v5 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"listFmt", v4);
    v6 = (const void *)___CFICUCreateVariableNameForStatus(a2);
    v7 = ___CFICUCreateErrorStringWithComment((int *)a2, 1);
    ___CFICULogWithArguments(1, CFSTR("UListFormatter *%@ = ulistfmt_open(\"%s\", &%@); %@"), v5, a1, v6, v7);
    CFRelease(v5);
    CFRelease(v6);
    CFRelease(v7);
  }
  return v4;
}

uint64_t __cficu_ulistfmt_format(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const UniChar *a5, uint64_t a6, int *a7)
{
  uint64_t v14;
  __CFArray *Mutable;
  uint64_t v16;
  CFStringRef v17;
  unint64_t v18;
  const void *ValueAtIndex;
  const void *v20;
  unint64_t v21;
  const void *v22;
  CFTypeRef v23;
  CFStringRef v24;
  CFStringRef v25;
  const void *v27;
  const void *v28;

  v14 = ulistfmt_format();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v28 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"listFmt", a1);
    Mutable = CFArrayCreateMutable(0, (int)a4, &kCFTypeArrayCallBacks);
    if ((int)a4 >= 1)
    {
      v16 = 0;
      do
      {
        v17 = ___CFICUCreateArgumentForUCharInput(*(UChar **)(a2 + 8 * v16), *(_DWORD *)(a3 + 4 * v16), v16);
        CFArrayAppendValue(Mutable, v17);
        CFRelease(v17);
        ++v16;
      }
      while (a4 != v16);
    }
    v27 = (const void *)___CFICUCreateVariableName("strings");
    ___CFICULogWithArguments(1, CFSTR("UChar* const %@[%d] = {"), v27, a4);
    if ((int)a4 >= 1)
    {
      v18 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v18);
        if (v18 >= (a4 - 1))
          ___CFICULogWithArguments(1, CFSTR("%@"), ValueAtIndex);
        else
          ___CFICULogWithArguments(1, CFSTR("%@,"), ValueAtIndex);
        ++v18;
      }
      while (a4 != v18);
    }
    ___CFICULogWithArguments(1, CFSTR("};\n"));
    CFRelease(Mutable);
    v20 = (const void *)___CFICUCreateVariableName("stringLengths");
    ___CFICULogWithArguments(1, CFSTR("int32_t %@[%d] = {"), v20, a4);
    if ((int)a4 >= 1)
    {
      v21 = 0;
      do
      {
        if (v21 >= (a4 - 1))
          ___CFICULogWithArguments(1, CFSTR("%d"), *(unsigned int *)(a3 + 4 * v21));
        else
          ___CFICULogWithArguments(1, CFSTR("%d,"), *(unsigned int *)(a3 + 4 * v21));
        ++v21;
      }
      while (a4 != v21);
    }
    ___CFICULogWithArguments(1, CFSTR("};\n"));
    v22 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a7);
    v23 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a5, a6);
    v24 = ___CFICUCreateErrorStringWithComment(a7, 0);
    if (*a7 <= 0)
      v25 = CFStringCreateWithCharacters(0, a5, (int)v14);
    else
      v25 = 0;
    ___CFICULogWithArguments(1, CFSTR("ulistfmt_format(%@, %@, %@, %d, %@, %d, &%@); // %d %@  %@"),
      v28,
      v27,
      v20,
      a4,
      v23,
      a6,
      v22,
      v14,
      v25,
      v24);
    CFRelease(v28);
    CFRelease(v27);
    CFRelease(v20);
    CFRelease(v22);
    CFRelease(v23);
    CFRelease(v24);
    if (v25)
      CFRelease(v25);
  }
  return v14;
}

void __cficu_ulistfmt_close(const void *a1)
{
  CFStringRef v2;

  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"listFmt", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    ulistfmt_close();
    ___CFICULogWithArguments(1, CFSTR("ulistfmt_close(%@);"), v2);
    CFRelease(v2);
  }
  else
  {
    ulistfmt_close();
  }
}

uint64_t __cficu_ucurr_getDefaultFractionDigits(UChar *a1, int *a2)
{
  uint64_t DefaultFractionDigits;
  const void *v5;
  CFStringRef v6;
  int32_t v7;
  CFStringRef v8;

  DefaultFractionDigits = ucurr_getDefaultFractionDigits();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v5 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    v6 = ___CFICUCreateErrorStringWithComment(a2, 0);
    v7 = u_strlen(a1);
    v8 = ___CFICUCreateArgumentForUCharInput(a1, v7, 0);
    ___CFICULogWithArguments(1, CFSTR("ucurr_getDefaultFractionDigits(%@, &%@); // %d %@"),
      v8,
      v5,
      DefaultFractionDigits,
      v6);
    CFRelease(v5);
    CFRelease(v8);
    CFRelease(v6);
  }
  return DefaultFractionDigits;
}

double __cficu_ucurr_getRoundingIncrement(UChar *a1, int *a2)
{
  double v4;
  double v5;
  const void *v6;
  CFStringRef v7;
  int32_t v8;
  CFStringRef v9;

  ucurr_getRoundingIncrement();
  v5 = v4;
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v6 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a2);
    v7 = ___CFICUCreateErrorStringWithComment(a2, 0);
    v8 = u_strlen(a1);
    v9 = ___CFICUCreateArgumentForUCharInput(a1, v8, 0);
    ___CFICULogWithArguments(1, CFSTR("ucurr_getRoundingIncrement(%@, &%@); // %d %@"),
      v9,
      v6,
      (int)v5,
      v7);
    CFRelease(v6);
    CFRelease(v9);
    CFRelease(v7);
  }
  return (double)(int)v5;
}

uint64_t __cficu_ureldatefmt_open(uint64_t a1, uint64_t a2, unsigned int a3, int a4, void *a5)
{
  uint64_t v10;
  const void *v11;
  CFStringRef v12;
  const void *v13;
  CFStringRef v14;
  CFStringRef v15;
  const char *v16;
  const char *v17;

  v10 = ureldatefmt_open();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v11 = (const void *)___CFICUCreateVariableNameForHeapPointer((uint64_t)"relDateFmt", v10);
    v12 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"numFmt", a2);
    v13 = (const void *)___CFICUCreateVariableNameForStatus(a5);
    v14 = ___CFICUCreateErrorStringWithComment((int *)a5, 1);
    v15 = v14;
    if (a3 > 2)
      v16 = "<unknown UDateRelativeDateTimeFormatterStyle>";
    else
      v16 = off_1E1334360[a3];
    if ((a4 - 256) > 4)
      v17 = "<unknown UDisplayContext>";
    else
      v17 = off_1E1334378[a4 - 256];
    ___CFICULogWithArguments(1, CFSTR("URelativeDateTimeFormatter *%@ = ureldatefmt_open(\"%s\", %@, %s, %s, &%@); %@"),
      v11,
      a1,
      v12,
      v16,
      v17,
      v13,
      v14);
    CFRelease(v11);
    CFRelease(v13);
    CFRelease(v15);
    CFRelease(v12);
  }
  return v10;
}

uint64_t __cficu_ureldatefmt_formatNumeric(uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12;
  CFStringRef v13;
  CFTypeRef v14;
  const void *v15;
  CFStringRef v16;
  CFStringRef v17;
  const char *v18;

  v12 = ureldatefmt_formatNumeric();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"relDateFmt", a1);
    v14 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a3, a4);
    v15 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    v16 = ___CFICUCreateErrorStringWithComment(a5, 1);
    if (*a5 <= 0)
      v17 = CFStringCreateWithCharacters(0, a3, (int)v12);
    else
      v17 = 0;
    if (a2 > 7)
      v18 = "<unknown URelativeDateTimeUnit>";
    else
      v18 = off_1E13343A0[a2];
    ___CFICULogWithArguments(1, CFSTR("ureldatefmt_formatNumeric(%@, %lf, %s, %@, %d, &%@); // %d, %@, %@"),
      v13,
      *(_QWORD *)&a6,
      v18,
      v14,
      a4,
      v15,
      v12,
      v17,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
  }
  return v12;
}

uint64_t __cficu_ureldatefmt_format(uint64_t a1, unsigned int a2, const UniChar *a3, uint64_t a4, int *a5, double a6)
{
  uint64_t v12;
  CFStringRef v13;
  CFTypeRef v14;
  const void *v15;
  CFStringRef v16;
  CFStringRef v17;
  const char *v18;

  v12 = ureldatefmt_format();
  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if (___CFICULoggingEnabled_loggingEnabled == 1)
  {
    v13 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"relDateFmt", a1);
    v14 = ___CFICUCreateVariableNameForUCharOutput("result", (uint64_t)a3, a4);
    v15 = (const void *)___CFICUCreateVariableNameForStatusIfNeeded((uint64_t)a5);
    v16 = ___CFICUCreateErrorStringWithComment(a5, 1);
    if (*a5 <= 0)
      v17 = CFStringCreateWithCharacters(0, a3, (int)v12);
    else
      v17 = 0;
    if (a2 > 7)
      v18 = "<unknown URelativeDateTimeUnit>";
    else
      v18 = off_1E13343A0[a2];
    ___CFICULogWithArguments(1, CFSTR("ureldatefmt_formatNumeric(%@, %lf, %s, %@, %d, &%@); // %d, %@, %@"),
      v13,
      *(_QWORD *)&a6,
      v18,
      v14,
      a4,
      v15,
      v12,
      v17,
      v16);
    CFRelease(v13);
    CFRelease(v14);
    CFRelease(v15);
    CFRelease(v16);
    CFRelease(v17);
  }
  return v12;
}

void __cficu_ureldatefmt_close(const void *a1)
{
  CFStringRef v2;

  if (___CFICULoggingEnabled_oncep != -1)
    dispatch_once(&___CFICULoggingEnabled_oncep, &__block_literal_global_126);
  if ((___CFICULoggingEnabled_loggingEnabled & 1) != 0)
  {
    v2 = ___CFICUCopyVariableNameForHeapPointer((uint64_t)"relDateFmt", (uint64_t)a1);
    ___CFICURemoveVariableNameForHeapPointer(a1);
    ureldatefmt_close();
    ___CFICULogWithArguments(1, CFSTR("ureldatefmt_close(%@);"), v2);
    CFRelease(v2);
  }
  else
  {
    ureldatefmt_close();
  }
}

void ___CFICUEmitPostamble()
{
  ___CFICULogWithArguments(1, &stru_1E1337B18);
  ___CFICULogWithArguments(1, CFSTR("return 0;"));
  ___CFICULogWithArguments(0, CFSTR("}"));
}

uint64_t ___CFICUCreateVariableNameForHeapPointer(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = _____CFICUCreateVariableNameForHeapPointer_block_invoke;
  v4[3] = &unk_1E1333EF0;
  v4[4] = &v5;
  v4[5] = a1;
  v4[6] = a2;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCreateVariableNameForHeapPointer_block_invoke((uint64_t)v4);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_182BF9ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFStringRef ___CFICUCreateVariableNameLocked(char *cStr)
{
  CFStringRef v2;
  const __CFNumber *Value;
  uint64_t v4;
  CFStringRef v5;
  CFNumberRef v6;
  uint64_t v8;
  _QWORD valuePtr[2];

  valuePtr[1] = *MEMORY[0x1E0C80C00];
  if (!generationByPrefix)
    generationByPrefix = (uint64_t)CFDictionaryCreateMutable(0, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v2 = CFStringCreateWithCString(0, cStr, 0x8000100u);
  valuePtr[0] = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)generationByPrefix, v2);
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberCFIndexType, valuePtr);
    v4 = valuePtr[0];
  }
  else
  {
    v4 = 0;
  }
  v5 = CFStringCreateWithFormat(0, 0, CFSTR("%@%ld"), v2, v4);
  v8 = valuePtr[0] + 1;
  v6 = CFNumberCreate(0, kCFNumberCFIndexType, &v8);
  CFDictionarySetValue((CFMutableDictionaryRef)generationByPrefix, v2, v6);
  CFRelease(v6);
  CFRelease(v2);
  return v5;
}

CFStringRef ___CFICUCreateVariableNameForStackPointerLocked(char *a1, const void *a2)
{
  CFStringRef v4;
  CFStringRef v5;

  v4 = ___CFICUCreateVariableNameLocked(a1);
  if (!stackPointersByPrefix)
    stackPointersByPrefix = (uint64_t)CFDictionaryCreateMutable(0, 0, &kCFCopyStringDictionaryKeyCallBacks, 0);
  if (!lastStackPointerVariableNamesByPrefix)
    lastStackPointerVariableNamesByPrefix = (uint64_t)CFDictionaryCreateMutable(0, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v5 = CFStringCreateWithCString(0, a1, 0x8000100u);
  CFDictionarySetValue((CFMutableDictionaryRef)stackPointersByPrefix, v5, a2);
  CFDictionarySetValue((CFMutableDictionaryRef)lastStackPointerVariableNamesByPrefix, v5, v4);
  CFRelease(v5);
  return v4;
}

CFStringRef ___CFICUCopyVariableNameForHeapPointer(uint64_t a1, uint64_t a2)
{
  CFStringRef v3;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = _____CFICUCopyVariableNameForHeapPointer_block_invoke;
  v5[3] = &unk_1E1333F38;
  v5[4] = &v6;
  v5[5] = a2;
  v5[6] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  _____CFICUCopyVariableNameForHeapPointer_block_invoke((uint64_t)v5);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
  v3 = (CFStringRef)v7[3];
  if (!v3)
  {
    v3 = CFStringCreateWithFormat(0, 0, CFSTR("<unknown variable for %s>"), a1);
    v7[3] = (uint64_t)v3;
  }
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_182BFA2DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

void ___CFICURemoveVariableNameForHeapPointer(const void *a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)&___CFICUSync_lock);
  if (variableNamesByHeapPointer)
    CFDictionaryRemoveValue((CFMutableDictionaryRef)variableNamesByHeapPointer, a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&___CFICUSync_lock);
}

void OUTLINED_FUNCTION_0_17(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void sub_182BFA7F8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void OUTLINED_FUNCTION_0_18(objc_class *a1)
{
  uint64_t v1;

  __CFRequireConcreteImplementation(a1, v1);
}

SInt32 CFBundleOpenBundleResourceFiles(CFBundleRef bundle, CFBundleRefNum *refNum, CFBundleRefNum *localizedRefNum)
{
  return -1;
}

CFBundleRefNum CFBundleOpenBundleResourceMap(CFBundleRef bundle)
{
  return -1;
}

uint64_t _CFBundleCopyInfoDictionaryInResourceFork()
{
  return 0;
}

uint64_t _CFBundleOpenBundleResourceFork()
{
  return 0xFFFFFFFFLL;
}

uint64_t __NSFastEnumerationShouldThrowExceptionOnMutation()
{
  return 1;
}

void __NSFastEnumerationMutationHandler(uint64_t a1)
{
  objc_class *v2;
  const char *Name;
  NSException *v4;

  v2 = (objc_class *)objc_opt_class();
  Name = class_getName(v2);
  CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** Collection <%s: %p> was mutated while being enumerated."), Name, a1);
  v4 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSGenericException"), _CFAutoreleasePoolAddObject(), 0);
  objc_exception_throw(v4);
}

void __handleUncaughtException(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t i;
  char *v7;
  const __CFString *v8;
  CFStringEncoding SystemEncoding;
  const char *CStringPtr;
  void *v11;
  size_t v12;
  const char *ClassName;
  char __str[68];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (objectIsKindOfClass((void *)a1, (objc_class *)NSException))
  {
    v2 = objc_msgSend((id)a1, "name");
    v3 = objc_msgSend((id)a1, "reason");
    v4 = (void *)objc_msgSend(*(id *)(a1 + 32), "objectForKey:", CFSTR("callStackReturnAddresses"));
    os_unfair_lock_lock((os_unfair_lock_t)&__last_exception_backtrace_lock__);
    if (v4)
    {
      v5 = objc_msgSend(v4, "count");
      __strlcpy_chk();
      if (v5)
      {
        for (i = 0; i != v5; ++i)
        {
          snprintf(__str, 0x44uLL, "%p ", (const void *)objc_msgSend((id)objc_msgSend(v4, "objectAtIndex:", i), "unsignedIntegerValue"));
          __strlcat_chk();
        }
      }
      v7 = strrchr(__last_exception_backtrace__, 32);
      if (v7)
        *(_WORD *)v7 = 41;
      else
        __strlcat_chk();
    }
    else
    {
      __strlcpy_chk();
    }
    __last_exception_class_name__ = (uint64_t)object_getClassName((id)a1);
    v8 = *(const __CFString **)(a1 + 8);
    if (_NSIsNSCFConstantString((uint64_t)v8))
    {
      SystemEncoding = CFStringGetSystemEncoding();
      CStringPtr = CFStringGetCStringPtr(v8, SystemEncoding);
    }
    else
    {
      CStringPtr = 0;
    }
    __last_exception_name__ = (uint64_t)CStringPtr;
    bzero(&__last_exception_os_log_pack__, 0x400uLL);
    v11 = (void *)objc_msgSend(*(id *)(a1 + 32), "objectForKey:", CFSTR("osLogPack"));
    if (v11)
      objc_msgSend(v11, "getBytes:length:", &__last_exception_os_log_pack__, 1024);
    os_unfair_lock_unlock((os_unfair_lock_t)&__last_exception_backtrace_lock__);
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** Terminating app due to uncaught exception '%@', reason: '%@'\n*** First throw call stack:\n%@\n"), v2, v3, objc_msgSend(v4, "description"));
  }
  else
  {
    ClassName = object_getClassName((id)a1);
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** Terminating app due to uncaught exception of class '%s'"), ClassName);
  }
  qword_1EDCD1038 = objc_msgSend((id)_CFAutoreleasePoolAddObject(), "UTF8String");
  v12 = strlen((const char *)qword_1EDCD1038);
  _CFLogSimpleCString(3, (const char *)qword_1EDCD1038, v12);
  if (__uncaughtExceptionHandler)
  {
    if (objectIsKindOfClass((void *)a1, (objc_class *)NSException))
      __uncaughtExceptionHandler(a1);
  }
}

void typeStringRelease(int a1, char *__s)
{
  strlen(__s);
  if ((_dyld_is_memory_immutable() & 1) == 0)
    free(__s);
}

CFStringRef copyTypeStringDesc(char *cStr)
{
  return CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, cStr, 0x600u);
}

_QWORD *__NSMS5(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  size_t v4;

  if (result)
  {
    v1 = result;
    v2 = __NSMS5(*result);
    v3 = __NSMS5(v1[1]) + v2;
    v1 = (_QWORD *)((char *)v1 + 37);
    v4 = strlen((const char *)v1);
    return (_QWORD *)(v3 + CFStringHashCString((unsigned __int8 *)v1, v4));
  }
  return result;
}

void __NSMS7(__CFString *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  const char *v9;
  const char *v11;
  const char *v12;
  const char *v14;
  const char *v15;
  const char *v17;
  const char *v18;
  const char *v20;
  const char *v21;
  const char *v23;
  const char *v24;
  const char *v25;
  const char *v26;
  const char *v27;
  int v28;
  const char *v29;
  uint64_t v30;
  const char *v31;
  const char *v32;
  const char *v33;
  const char *v34;
  const char *v35;
  const char *v36;
  const char *v37;
  const char *v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  if (!a3)
  {
    if (*((_BYTE *)a2 + 36))
    {
      CFStringAppendFormat(a1, 0, CFSTR("type encoding (%c) '%s'\n"), *((unsigned __int8 *)a2 + 36), (char *)a2 + 37);
      goto LABEL_11;
    }
LABEL_81:
    if ((*((_WORD *)a2 + 17) & 0x2000) != 0)
      CFStringAppendFormat(a1, 0, CFSTR("class '%s'\n"), (char *)a2 + 37);
    else
      CFStringAppendFormat(a1, 0, CFSTR("conforms to protocol '%s'\n"), (char *)a2 + 37);
    goto LABEL_112;
  }
  v6 = a3;
  do
  {
    CFStringAppendFormat(a1, 0, CFSTR("    "));
    --v6;
  }
  while (v6);
  if (!*((_BYTE *)a2 + 36))
    goto LABEL_81;
  CFStringAppendFormat(a1, 0, CFSTR("type encoding (%c) '%s'\n"), *((unsigned __int8 *)a2 + 36), (char *)a2 + 37);
  if (a3)
  {
    v7 = a3;
    do
    {
      CFStringAppendFormat(a1, 0, CFSTR("    "));
      --v7;
    }
    while (v7);
  }
LABEL_11:
  v8 = *((_WORD *)a2 + 17);
  v9 = "isSigned";
  if ((v8 & 0x100) == 0)
    v9 = "";
  if ((*((_WORD *)a2 + 17) & 0x7E00) == 0 || (v8 & 0x100) == 0)
    v11 = "";
  else
    v11 = ", ";
  v12 = "isFloat";
  if ((*((_WORD *)a2 + 17) & 0x200) == 0)
    v12 = "";
  if ((*((_WORD *)a2 + 17) & 0x7C00) == 0 || (v8 & 0x200) == 0)
    v14 = "";
  else
    v14 = ", ";
  v15 = "isStruct";
  if ((*((_WORD *)a2 + 17) & 0x400) == 0)
    v15 = "";
  if ((*((_WORD *)a2 + 17) & 0x7800) == 0 || (v8 & 0x400) == 0)
    v17 = "";
  else
    v17 = ", ";
  v18 = "isArray";
  if ((*((_WORD *)a2 + 17) & 0x800) == 0)
    v18 = "";
  if ((*((_WORD *)a2 + 17) & 0x7000) == 0 || (v8 & 0x800) == 0)
    v20 = "";
  else
    v20 = ", ";
  v21 = "isPointer";
  if ((*((_WORD *)a2 + 17) & 0x1000) == 0)
    v21 = "";
  if ((*((_WORD *)a2 + 17) & 0x6000) == 0 || (v8 & 0x1000) == 0)
    v23 = "";
  else
    v23 = ", ";
  if (v8 < 0)
    v24 = "isObject, isBlock";
  else
    v24 = "isObject";
  if ((*((_WORD *)a2 + 17) & 0x2000) == 0)
    v24 = "";
  if ((v8 & 0x6000) == 0x6000)
    v25 = ", ";
  else
    v25 = "";
  if ((*((_WORD *)a2 + 17) & 0x4000) != 0)
    v26 = "isCString";
  else
    v26 = "";
  CFStringAppendFormat(a1, 0, CFSTR("flags {%s%s%s%s%s%s%s%s%s%s%s%s%s}\n"), v9, v11, v12, v14, v15, v17, v18, v20, v21, v23, v24, v25, v26);
  v27 = "out";
  v28 = *((unsigned __int16 *)a2 + 17);
  if ((v28 & 2) == 0)
    v27 = 0;
  if ((v28 & 1) != 0)
    v27 = "in";
  if ((~v28 & 3) != 0)
    v29 = v27;
  else
    v29 = "inout";
  if (a3)
  {
    v30 = a3;
    do
    {
      CFStringAppendFormat(a1, 0, CFSTR("    "));
      --v30;
    }
    while (v30);
    v28 = *((unsigned __int16 *)a2 + 17);
  }
  if (v29)
    v31 = v29;
  else
    v31 = "";
  if (v29)
  {
    v32 = ", ";
    if ((v28 & 0x1C) == 0 && (v28 & 0x20) == 0)
      v32 = "";
  }
  else
  {
    v32 = "";
  }
  v33 = "bycopy";
  if ((v28 & 4) == 0)
    v33 = "";
  v34 = "";
  if ((v28 & 4) != 0)
  {
    v34 = ", ";
    if ((v28 & 0x18) == 0 && (v28 & 0x20) == 0)
      v34 = "";
  }
  v35 = "byref";
  if ((v28 & 8) != 0)
  {
    v36 = ", ";
    if ((v28 & 0x10) != 0)
    {
LABEL_97:
      v37 = "const";
      goto LABEL_98;
    }
    if ((v28 & 0x20) == 0)
      v36 = "";
  }
  else
  {
    v35 = "";
    v36 = "";
    if ((v28 & 0x10) != 0)
      goto LABEL_97;
  }
  v37 = "";
LABEL_98:
  if ((~v28 & 0x30) != 0)
    v38 = "";
  else
    v38 = ", ";
  if ((v28 & 0x20) != 0)
    v39 = "oneway";
  else
    v39 = "";
  CFStringAppendFormat(a1, 0, CFSTR("modifiers {%s%s%s%s%s%s%s%s%s}\n"), v31, v32, v33, v34, v35, v36, v37, v38, v39);
  if (a3)
  {
    v40 = a3;
    do
    {
      CFStringAppendFormat(a1, 0, CFSTR("    "));
      --v40;
    }
    while (v40);
  }
  CFStringAppendFormat(a1, 0, CFSTR("frame {offset = %d, offset adjust = %d, size = %d, size adjust = %d}\n"), *((unsigned int *)a2 + 7), *((unsigned __int8 *)a2 + 32), *((unsigned int *)a2 + 6), *((char *)a2 + 33));
  if (a3)
  {
    v41 = a3;
    do
    {
      CFStringAppendFormat(a1, 0, CFSTR("    "));
      --v41;
    }
    while (v41);
  }
  CFStringAppendFormat(a1, 0, CFSTR("memory {offset = %d, size = %d}\n"), *((unsigned int *)a2 + 5), *((unsigned int *)a2 + 4));
LABEL_112:
  v42 = *a2;
  if (v42)
  {
    v43 = a3 + 1;
    do
    {
      __NSMS7(a1, v42, v43);
      v42 = *(_QWORD *)(v42 + 8);
    }
    while (v42);
  }
}

void copyBlock(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 32), *(const void **)(a2 + 32), 7);
}

_BYTE **setAndAdvance(_BYTE **result, unint64_t a2, char a3)
{
  _BYTE *v3;

  v3 = *result;
  if ((unint64_t)*result >= a2)
    objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), CFSTR("+[NSMethodSignature signatureWithObjCTypes:]: malformed struct spec"), 0));
  *result = v3 + 1;
  *v3 = a3;
  return result;
}

uint64_t copyMemStateToFrameState(uint64_t result)
{
  uint64_t *v1;

  if (result)
  {
    v1 = (uint64_t *)result;
    do
    {
      v1[3] = v1[2];
      result = *v1;
      if (*v1)
        result = copyMemStateToFrameState();
      v1 = (uint64_t *)v1[1];
    }
    while (v1);
  }
  return result;
}

uint64_t OUTLINED_FUNCTION_0_19()
{
  return __CFRecordAllocationEvent();
}

void __CFDateIntervalDeallocate(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 16));
}

BOOL __CFDateIntervalEqual(uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
    return 1;
  if (*(double *)(a1 + 24) == *(double *)(a2 + 24))
    return CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16)) != 0;
  return 0;
}

uint64_t __CFDateIntervalHash(uint64_t a1)
{
  CFAbsoluteTime AbsoluteTime;
  CFAbsoluteTime v3;
  _QWORD v5[3];

  v5[2] = *MEMORY[0x1E0C80C00];
  AbsoluteTime = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  v3 = AbsoluteTime + *(double *)(a1 + 24);
  *(CFAbsoluteTime *)v5 = AbsoluteTime;
  *(CFAbsoluteTime *)&v5[1] = v3;
  return CFHashBytes((uint64_t)v5, 16);
}

CFStringRef __CFDateIntervalCopyDescription(_QWORD *a1)
{
  CFAllocatorRef v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("<CFDateInterval %p [%p]> %@ %f"), a1, v2, a1[2], a1[3]);
}

uint64_t CFDateIntervalGetTypeID()
{
  return 71;
}

uint64_t CFDateIntervalCreate(__objc2_class **Default, const void *a2, double a3)
{
  uint64_t result;
  uint64_t v6;

  if (!Default)
    Default = (__objc2_class **)CFAllocatorGetDefault();
  result = _CFRuntimeCreateInstance(Default, 0x47uLL, 16, 0);
  if (result)
  {
    v6 = result;
    *(_QWORD *)(result + 16) = CFRetain(a2);
    *(double *)(v6 + 24) = a3;
    return v6;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t CFDateIntervalCreateWithEndDate(__objc2_class **a1, const __CFDate *a2, CFDateRef theDate)
{
  double AbsoluteTime;
  double v6;

  AbsoluteTime = CFDateGetAbsoluteTime(theDate);
  v6 = AbsoluteTime - CFDateGetAbsoluteTime(a2);
  return CFDateIntervalCreate(a1, a2, v6);
}

double CFDateIntervalGetDuration(uint64_t a1)
{
  return *(double *)(a1 + 24);
}

CFTypeRef CFDateIntervalCopyStartDate(uint64_t a1)
{
  return CFRetain(*(CFTypeRef *)(a1 + 16));
}

CFDateRef CFDateIntervalCopyEndDate(uint64_t a1)
{
  CFAbsoluteTime v1;

  v1 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16)) + *(double *)(a1 + 24);
  return CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1);
}

CFComparisonResult CFDateIntervalCompare(uint64_t a1, uint64_t a2)
{
  CFComparisonResult result;
  double v5;
  double v6;

  result = CFDateCompare(*(CFDateRef *)(a1 + 16), *(CFDateRef *)(a2 + 16), 0);
  if (result == kCFCompareEqualTo)
  {
    v5 = *(double *)(a1 + 24);
    v6 = *(double *)(a2 + 24);
    if (v5 >= v6)
      return (unint64_t)(v5 > v6);
    else
      return -1;
  }
  return result;
}

BOOL CFDateIntervalIntersectsDateInterval(uint64_t a1, uint64_t a2)
{
  CFAbsoluteTime AbsoluteTime;
  const __CFDate *v5;
  CFAbsoluteTime v6;
  const __CFDate *v7;
  double v8;
  double v9;
  BOOL v10;
  double v11;
  double v12;
  BOOL v13;
  double v14;
  double v15;
  _BOOL8 v16;
  double v18;
  double v19;

  AbsoluteTime = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16));
  v5 = CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, AbsoluteTime + *(double *)(a2 + 24));
  v6 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  v7 = CFDateCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v6 + *(double *)(a1 + 24));
  v8 = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16));
  v9 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  v10 = v8 < v9 || v8 > v9 + *(double *)(a1 + 24);
  if (v10
    && ((v11 = CFDateGetAbsoluteTime(v5), v12 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16)), v11 >= v12)
      ? (v13 = v11 > v12 + *(double *)(a1 + 24))
      : (v13 = 1),
        v13
     && ((v14 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16)),
          v15 = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16)),
          v14 < v15)
      || v14 > v15 + *(double *)(a2 + 24))))
  {
    v18 = CFDateGetAbsoluteTime(v7);
    v19 = CFDateGetAbsoluteTime(*(CFDateRef *)(a2 + 16));
    v16 = v18 <= v19 + *(double *)(a2 + 24) && v18 >= v19;
  }
  else
  {
    v16 = 1;
  }
  CFRelease(v5);
  CFRelease(v7);
  return v16;
}

BOOL CFDateIntervalContainsDate(uint64_t a1, CFDateRef theDate)
{
  double AbsoluteTime;
  double v4;

  AbsoluteTime = CFDateGetAbsoluteTime(theDate);
  v4 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 16));
  return AbsoluteTime <= v4 + *(double *)(a1 + 24) && AbsoluteTime >= v4;
}

CFTypeRef CFDateIntervalCreateIntersectionWithDateInterval(__objc2_class **a1, CFDateRef *cf1, CFDateRef *cf2)
{
  double AbsoluteTime;
  double v8;
  double v9;
  CFDateRef *v10;
  CFDateRef v11;
  double v12;
  double v13;

  if (CFEqual(cf1, cf2))
    return CFRetain(cf1);
  if (!CFDateIntervalIntersectsDateInterval((uint64_t)cf1, (uint64_t)cf2))
    return 0;
  AbsoluteTime = CFDateGetAbsoluteTime(cf1[2]);
  v8 = AbsoluteTime + *((double *)cf1 + 3);
  v9 = CFDateGetAbsoluteTime(cf2[2]);
  if (v9 >= AbsoluteTime)
    v10 = cf2;
  else
    v10 = cf1;
  v11 = v10[2];
  if (v9 + *((double *)cf2 + 3) < v8)
    v12 = v9 + *((double *)cf2 + 3);
  else
    v12 = v8;
  v13 = v12 - CFDateGetAbsoluteTime(v10[2]);
  return (CFTypeRef)CFDateIntervalCreate(a1, v11, v13);
}

void sub_182BFD61C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

size_t _CFPrefsCreatePreferencesDirectory(const char *a1)
{
  size_t result;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  int v8;
  int v9;

  result = strlen(a1);
  if (!result)
    return result;
  v3 = (char *)&a1[result];
  v4 = 0xFFFFFFFFLL;
  do
  {
    while (1)
    {
      if (*v3 != 47)
        goto LABEL_6;
      *v3 = 0;
      v5 = open(a1, 1074790400);
      v4 = v5;
      *v3 = 47;
      if ((_DWORD)v5 != -1)
        break;
      --v3;
      if (*__error() != 2 || v3 == a1)
        return 0;
    }
    if ((v5 & 0x80000000) == 0)
    {
      v7 = (uint64_t)(v3 + 1);
      goto LABEL_18;
    }
LABEL_6:
    --v3;
  }
  while (v3 != a1);
  if ((v4 & 0x80000000) != 0)
    return 0;
  v7 = 0;
LABEL_18:
  v8 = _safe_recursive_mkdir_chown(v7, v4);
  v9 = *__error();
  close(v4);
  *__error() = v9;
  return v8 == 0;
}

uint64_t _safe_recursive_mkdir_chown(uint64_t a1, uint64_t a2)
{
  const char *v2;
  int v3;
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  const char *v13;
  char *i;
  int v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  char v19;
  uint64_t v20;
  int v21;
  char v22;
  uint64_t v23;
  int v24;
  statfs v26;
  statfs v27;
  uint64_t v28;

  v2 = (const char *)MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v3;
  v13 = v2;
  v28 = *MEMORY[0x1E0C80C00];
  for (i = (char *)v2; ; ++i)
  {
    v15 = *i;
    if (!*i || v15 == 47)
      break;
  }
  *i = 0;
  v16 = openat(v3, v2, 0x100000);
  v17 = v16;
  if ((v16 & 0x80000000) != 0)
  {
    if ((_DWORD)v16 == -1)
    {
      if (*__error() != 2)
        return 0xFFFFFFFFLL;
      goto LABEL_26;
    }
  }
  else
  {
    memset(&v27, 0, 512);
    if (fstatfs(v16, &v27) != -1 && (v27.f_flags & 1) != 0)
    {
      memset(&v26, 0, 512);
      if (fstatfs(v12, &v26) != -1 && (v26.f_flags & 0x20) != 0)
      {
        close(v17);
LABEL_26:
        if (mkdirat(v12, v13, v11) != -1)
        {
          v23 = openat(v12, v13, 1048832);
          if ((_DWORD)v23 != -1)
          {
            v17 = v23;
            if (fchown(v23, v9, v7) != -1
              || (v24 = *__error(), memset(&v27, 0, 144), !fstat(v17, (stat *)&v27))
              && v27.f_bfree == __PAIR64__(v7, v9))
            {
              v18 = 1;
              goto LABEL_13;
            }
            close(v17);
            unlinkat(v12, v13, 128);
            *__error() = v24;
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  v18 = 0;
LABEL_13:
  *i = v15;
  while (v15 == 47)
  {
    v19 = *++i;
    LOBYTE(v15) = v19;
  }
  if ((_BYTE)v15)
  {
    v20 = _safe_recursive_mkdir_chown(i, v17, v11, v9, v7, v5);
    v21 = *__error();
    close(v17);
    v22 = v18 ^ 1;
    if ((_DWORD)v20 != -1)
      v22 = 1;
    if ((v22 & 1) == 0)
      unlinkat(v12, v13, 128);
    *__error() = v21;
  }
  else if (v5)
  {
    v20 = 0;
    *v5 = v17;
  }
  else
  {
    close(v17);
    return 0;
  }
  return v20;
}

CFURLRef _CFPrefsCopyDirectoryURLForTriplet_testing(uint64_t a1, const __CFString *a2, int a3, const void *a4)
{
  return _CFPrefsCreatePreferencesDirectoryURLForTriplet(a2, a3, a4);
}

__CFArray *_CFPreferencesCopyApplicationList(const __CFString *a1, int a2)
{
  char v2;
  const __CFURL *PreferencesDirectoryURLForTriplet;
  const __CFURL *v4;
  CFURLRef v5;
  const __CFString *v6;
  const __CFString *v7;
  __CFArray *Mutable;
  const __CFString *v9;
  CFIndex Length;
  __CFArray *v11;
  const __CFArray *MutableCopy;
  CFIndex Count;
  unint64_t v14;
  const __CFURL *ValueAtIndex;
  const __CFString *v16;
  CFStringRef v17;
  const __CFString *v18;
  CFURLRef cf;
  CFRange v21;

  v2 = a2;
  PreferencesDirectoryURLForTriplet = _CFPrefsCreatePreferencesDirectoryURLForTriplet(a1, a2, 0);
  if (!PreferencesDirectoryURLForTriplet)
    return 0;
  v4 = PreferencesDirectoryURLForTriplet;
  v5 = CFURLCopyAbsoluteURL(PreferencesDirectoryURLForTriplet);
  CFRelease(v4);
  if ((v2 & 1) != 0)
  {
    v6 = _CFXPreferencesGetByHostIdentifierString();
    v7 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR(".%@.plist"), v6);
  }
  else
  {
    v7 = CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, ".plist", 0x600u);
  }
  v9 = v7;
  Length = CFStringGetLength(v7);
  v11 = _CFCreateContentsOfDirectory((uint64_t)&__kCFAllocatorSystemDefault, 0);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  cf = v5;
  if (v11)
  {
    MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v11);
    CFRelease(v11);
  }
  else
  {
    MutableCopy = CFArrayCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeArrayCallBacks);
  }
  Count = CFArrayGetCount(MutableCopy);
  if (Count >= 1)
  {
    v14 = Count + 1;
    do
    {
      ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(MutableCopy, v14 - 2);
      v16 = CFURLCopyFileSystemPath(ValueAtIndex, kCFURLPOSIXPathStyle);
      if (CFStringHasSuffix(v16, v9))
      {
        v21.length = CFStringGetLength(v16) - Length;
        v21.location = 0;
        v17 = CFStringCreateWithSubstring((CFAllocatorRef)&__kCFAllocatorSystemDefault, v16, v21);
        if (CFEqual(v17, CFSTR(".GlobalPreferences")))
          v18 = CFSTR("kCFPreferencesAnyApplication");
        else
          v18 = v17;
        CFArrayAppendValue(Mutable, v18);
        CFRelease(v17);
      }
      CFRelease(v16);
      --v14;
    }
    while (v14 > 1);
  }
  if (MutableCopy)
    CFRelease(MutableCopy);
  CFRelease(cf);
  CFRelease(v9);
  return Mutable;
}

uint64_t _CFPreferencesCopyApplicationMap()
{
  return 0;
}

uint64_t _CFPreferencesCopyInUseContainerURLMatchingApplication()
{
  return 0;
}

CFURLRef _CFPreferencesCopyManagedPreferencesContainerURL()
{
  const char *v0;
  UInt8 *v1;
  size_t v2;
  const __CFURL *v3;
  const __CFURL *v4;
  CFURLRef v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v15[0] = 1;
  v0 = (const char *)container_system_group_path_for_identifier();
  if (v0)
  {
    v1 = (UInt8 *)v0;
    v2 = strlen(v0);
    v3 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, v1, v2, 1u);
    if (v3)
    {
      v4 = v3;
      v5 = CFURLCreateWithFileSystemPathRelativeToBase((CFAllocatorRef)&__kCFAllocatorSystemDefault, CFSTR("Library/Managed Preferences/"), kCFURLPOSIXPathStyle, 1u, v3);
      CFRelease(v4);
      if (v5)
      {
LABEL_7:
        free(v1);
        return v5;
      }
      v6 = _CFPrefsDaemonLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
        _CFPreferencesCopyManagedPreferencesContainerURL_cold_2();
    }
    v5 = 0;
    goto LABEL_7;
  }
  v7 = _CFPrefsDaemonLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
    _CFPreferencesCopyManagedPreferencesContainerURL_cold_1((uint64_t)v15, v7, v8, v9, v10, v11, v12, v13);
  return 0;
}

CFStringRef _CFPreferencesCopyPathForManagedDomain(__CFString *a1, const __CFString *a2, int a3)
{
  CFStringRef result;
  char buffer[1026];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x402uLL);
  if (!_CFPrefsGetPathForManagedBundleID(a1, a2, a3 != 0, (UInt8 *)buffer))
    return 0;
  result = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, buffer);
  if (!result)
    return 0;
  return result;
}

uint64_t _CFPreferencesUIDForUsername(const void *a1)
{
  const void *v3[2];

  v3[1] = *(const void **)MEMORY[0x1E0C80C00];
  v3[0] = (const void *)4294967195;
  os_unfair_lock_lock((os_unfair_lock_t)&_cfprefsUsernameLock);
  if (!_cfprefsUsernameToUid || !CFDictionaryGetValueIfPresent((CFDictionaryRef)_cfprefsUsernameToUid, a1, v3))
    v3[0] = (const void *)4294967195;
  os_unfair_lock_unlock((os_unfair_lock_t)&_cfprefsUsernameLock);
  return LODWORD(v3[0]);
}

void OUTLINED_FUNCTION_0_20(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x12u);
}

void OUTLINED_FUNCTION_2_8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_4_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 2u);
}

void OUTLINED_FUNCTION_5_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void sub_182BFF848(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182BFFE84(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C002E4(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C00740(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C00EAC(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C04490(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C04908(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C04D7C(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C053A8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182C05640(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void OUTLINED_FUNCTION_0_21(objc_class *a1, uint64_t a2)
{
  __CFRequireConcreteImplementation(a1, a2);
}

void __CFZombifyNSObject()
{
  objc_class *v0;
  objc_method *InstanceMethod;
  objc_method *v2;

  v0 = objc_lookUpClass("NSObject");
  InstanceMethod = class_getInstanceMethod(v0, sel_dealloc);
  v2 = class_getInstanceMethod(v0, sel___dealloc_zombie);
  method_exchangeImplementations(InstanceMethod, v2);
}

void __CFOAInitializeNSObject()
{
  objc_class *v0;
  objc_method *InstanceMethod;
  objc_method *v2;
  objc_method *v3;
  objc_method *v4;
  objc_method *v5;
  objc_method *v6;
  objc_method *v7;
  objc_method *v8;
  objc_class *Class;
  objc_method *v10;
  objc_method *v11;

  v0 = objc_lookUpClass("NSObject");
  InstanceMethod = class_getInstanceMethod(v0, sel_retain);
  v2 = class_getInstanceMethod(v0, sel___retain_OA);
  method_exchangeImplementations(InstanceMethod, v2);
  v3 = class_getInstanceMethod(v0, sel_release);
  v4 = class_getInstanceMethod(v0, sel___release_OA);
  method_exchangeImplementations(v3, v4);
  v5 = class_getInstanceMethod(v0, sel_autorelease);
  v6 = class_getInstanceMethod(v0, sel___autorelease_OA);
  method_exchangeImplementations(v5, v6);
  v7 = class_getInstanceMethod(v0, sel__tryRetain);
  v8 = class_getInstanceMethod(v0, sel____tryRetain_OA);
  method_exchangeImplementations(v7, v8);
  Class = object_getClass(v0);
  v10 = class_getInstanceMethod(Class, sel_allocWithZone_);
  v11 = class_getInstanceMethod(Class, sel___allocWithZone_OA_);
  method_exchangeImplementations(v10, v11);
}

void couldNotInstantiate(objc_class *a1)
{
  const char *Name;
  NSException *v2;

  Name = class_getName(a1);
  CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** -[NSObject allocWithZone:]: attempt to allocate object of class '%s' failed"), Name);
  v2 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSMallocException"), _CFAutoreleasePoolAddObject(), 0);
  objc_exception_throw(v2);
}

uint64_t _objc_getTaggedPointerTag_0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int v6;

  v1 = 0;
  v2 = *MEMORY[0x1E0DE7C58];
  if ((~a1 & 0xC000000000000007) == 0)
    v2 = 0;
  v3 = v2 ^ a1;
  do
  {
    if ((v3 & 7) == *(_BYTE *)(MEMORY[0x1E0DE7C48] + v1))
      break;
    ++v1;
  }
  while (v1 != 7);
  v4 = v1 | v3;
  v5 = v1 & 7;
  v6 = (v4 >> 55) + 8;
  if (v5 == 7)
    return v6;
  else
    return v5;
}

uint64_t _NSIsNSURL(uint64_t a1)
{
  uint64_t (*MethodImplementation)(uint64_t, char *);
  Class Class;

  if (_NSURLClass)
  {
    if (a1)
      goto LABEL_3;
LABEL_7:
    LOBYTE(Class) = 0;
    return Class & 1;
  }
  Class = objc_getClass("NSURL");
  _NSURLClass = (uint64_t)Class;
  if (!Class)
    return Class & 1;
  if (!a1)
    goto LABEL_7;
LABEL_3:
  MethodImplementation = (uint64_t (*)(uint64_t, char *))object_getMethodImplementation();
  if (MethodImplementation != (uint64_t (*)(uint64_t, char *))MEMORY[0x1E0DE79B8])
    return MethodImplementation(a1, sel_isNSURL__);
  LOBYTE(Class) = objc_opt_isKindOfClass();
  return Class & 1;
}

uint64_t _NSIsNSAttributedString()
{
  Class Class;

  if (_NSAttributedStringClass
    || (Class = objc_getClass("NSAttributedString"), (_NSAttributedStringClass = (uint64_t)Class) != 0))
  {
    LOBYTE(Class) = objc_opt_isKindOfClass();
  }
  return Class & 1;
}

unint64_t makeAtom(unint64_t a1)
{
  unint64_t result;
  uint64_t v3;
  _QWORD *v4;
  unsigned int v5;
  uint64_t v6;
  signed int v7;
  unsigned int v8;
  id v9;
  int v10;
  int v11;
  _UNKNOWN **v12;
  void *v13;
  unint64_t *v14;
  void *v15;
  unint64_t v17;
  unint64_t v18;
  unsigned int v19;

  if ((dyld_program_sdk_at_least() & 1) != 0 || !*MEMORY[0x1E0DE7C50])
    return 0;
  if ((a1 & 0x8000000000000000) != 0 && !_objc_getTaggedPointerTag_0(a1))
    return a1;
  v3 = 0;
  while (2)
  {
    v4 = *(&__atom_buckets + v3);
    if (v4)
    {
      v5 = 16 << v3;
      if ((16 << v3) <= 1)
        v6 = 1;
      else
        v6 = v5;
      v7 = v5 - 16;
      do
      {
        if (*v4 == a1)
        {
          a1 = ((uint64_t)v7 << 7) | 0x8000000000000000;
          v17 = *MEMORY[0x1E0DE7C58] ^ a1;
          if ((~v17 & 0xC000000000000007) != 0)
            return v17 & 0xFFFFFFFFFFFFFFF8 | *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + (*MEMORY[0x1E0DE7C58] & 7));
          return a1;
        }
        ++v7;
        ++v4;
        --v6;
      }
      while (v6);
      if (++v3 != 24)
        continue;
    }
    break;
  }
  do
    v8 = __ldxr((unsigned int *)&__natoms);
  while (__stxr(v8 + 1, (unsigned int *)&__natoms));
  v9 = (id)a1;
  v19 = v8 + 1;
  result = flsl(((v8 + 1) >> 4) + 1);
  if ((int)result < 25)
  {
    v10 = 1 << (result + 3);
    v11 = v8 - v10 + 17;
    v12 = &__atom_buckets + (int)result;
    v15 = *(v12 - 1);
    v14 = (unint64_t *)(v12 - 1);
    v13 = v15;
    if (!v15)
    {
      v13 = malloc_type_calloc(8uLL, v10, 0xF3174764uLL);
      while (!__ldaxr(v14))
      {
        if (!__stlxr((unint64_t)v13, v14))
          goto LABEL_26;
      }
      __clrex();
      free(v13);
      v13 = (void *)*v14;
    }
LABEL_26:
    *((_QWORD *)v13 + v11) = a1;
    __dmb(0xBu);
    a1 = ((((unint64_t)(16 * v19) >> 4) & 0xFFFFFFF) << 7) | 0x8000000000000000;
    v18 = *MEMORY[0x1E0DE7C58] ^ a1;
    if ((~v18 & 0xC000000000000007) != 0)
      return v18 & 0xFFFFFFFFFFFFFFF8 | *(unsigned __int8 *)(MEMORY[0x1E0DE7C48] + (*MEMORY[0x1E0DE7C58] & 7));
    return a1;
  }
  __break(1u);
  return result;
}

uint64_t getAtomTarget(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;

  result = dyld_program_sdk_at_least();
  if ((result & 1) != 0)
    return 0;
  v3 = *MEMORY[0x1E0DE7C58];
  if ((~a1 & 0xC000000000000007) == 0)
    v3 = 0;
  v4 = v3 ^ a1;
  v5 = 0xFFFFFFFFFFFFFFFLL;
  if ((~(_BYTE)v4 & 7) == 0)
    v5 = 0xFFFFFFFFFFFFFLL;
  v6 = v5 & (v4 >> 3);
  if (__natoms < v6 >> 4)
  {
    __break(1u);
  }
  else
  {
    v7 = v6 >> 4;
    v8 = flsl((v6 >> 8) + 1);
    return *((_QWORD *)*(&__atom_buckets + v8 - 1) + (int)v7 + (-1 << (v8 + 3)) + 16);
  }
  return result;
}

void _NSSetDeallocHandler()
{
  qword_1EDCD1038 = (uint64_t)"Unsupported functionality";
  __break(1u);
}

uint64_t __CFFullMethodName(objc_class *a1, objc_class *a2, const char *a3)
{
  uint64_t v4;
  const char *Name;
  const char *v6;
  uint64_t v7;
  char *cStr[2];

  cStr[1] = *(char **)MEMORY[0x1E0C80C00];
  cStr[0] = 0;
  if (a2 == a1)
    v4 = 43;
  else
    v4 = 45;
  if (a1)
  {
    Name = class_getName(a1);
    if (a3)
    {
LABEL_6:
      v6 = sel_getName(a3);
      goto LABEL_9;
    }
  }
  else
  {
    Name = "(null class)";
    if (a3)
      goto LABEL_6;
  }
  v6 = "(null selector)";
LABEL_9:
  asprintf(cStr, "%c[%s %s]", v4, Name, v6);
  if (!cStr[0])
    return 0;
  CFStringCreateWithCString((CFAllocatorRef)&__kCFAllocatorSystemDefault, cStr[0], 0x8000100u);
  v7 = _CFAutoreleasePoolAddObject();
  free(cStr[0]);
  return v7;
}

uint64_t __CFExceptionProem(objc_class *a1, const char *a2)
{
  objc_class *v4;

  v4 = (objc_class *)objc_opt_class();
  return __CFFullMethodName(v4, a1, a2);
}

id _NSObjectLoadWeakRetained(id *a1, _BYTE *a2)
{
  if (*a2)
    return *a1;
  else
    return objc_loadWeakRetained(a1);
}

uint64_t OUTLINED_FUNCTION_0_22(objc_class *a1)
{
  objc_class *v1;
  const char *v2;

  return __CFFullMethodName(a1, v1, v2);
}

void sub_182C07078(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C07AB4(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_0_23(objc_class *a1)
{
  uint64_t v1;

  __CFRequireConcreteImplementation(a1, v1);
}

void sub_182C07FF0(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182C082B8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

__n128 cow_copy_instance_1(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int *v4;
  int *v5;
  int *v6;
  int *v7;
  uint64_t v8;
  unint64_t v9;
  __n128 result;

  v4 = &OBJC_IVAR_____NSFrozenSetM_storage;
  if (a2 == 1)
    v5 = &OBJC_IVAR_____NSSetM_storage;
  else
    v5 = &OBJC_IVAR_____NSFrozenSetM_storage;
  v6 = &OBJC_IVAR_____NSFrozenSetM_cow;
  if (a2 == 1)
    v7 = &OBJC_IVAR_____NSSetM_cow;
  else
    v7 = &OBJC_IVAR_____NSFrozenSetM_cow;
  v8 = *v5;
  v9 = atomic_load((unint64_t *)(a1 + *v7));
  if (a4 == 1)
  {
    v6 = &OBJC_IVAR_____NSSetM_cow;
    v4 = &OBJC_IVAR_____NSSetM_storage;
  }
  atomic_store(v9, (unint64_t *)(a3 + *v6));
  result = *(__n128 *)(a1 + v8);
  *(__n128 *)(a3 + *v4) = result;
  return result;
}

uint64_t cow_copy_storage_1(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  id v12;

  v2 = *(unsigned int *)(a1 + 28);
  if ((v2 & 0x3FFFFFF) == 0)
  {
    v5 = 0;
    *(_DWORD *)(a1 + 28) = 0;
LABEL_16:
    result = 1;
    goto LABEL_17;
  }
  v3 = *(unsigned int *)((char *)__NSSetSizes_0 + ((v2 >> 23) & 0x1F8));
  result = (uint64_t)malloc_type_malloc(8 * v3, 0x80040B8603338uLL);
  v5 = result;
  if (result)
  {
    if (v2 >> 26)
    {
      v6 = 0;
      v7 = *(_QWORD *)(a1 + 16);
      if (v3 <= 1)
        v8 = 1;
      else
        v8 = v3;
      v9 = 8 * v8;
      do
      {
        v10 = *(_QWORD *)(v7 + v6);
        if (v10 >= 1 && v10 != (_QWORD)&___NSSetM_DeletedMarker)
          v12 = (id)v10;
        *(_QWORD *)(v5 + v6) = v10;
        v6 += 8;
      }
      while (v9 != v6);
    }
    goto LABEL_16;
  }
LABEL_17:
  *(_QWORD *)(a1 + 16) = v5;
  return result;
}

uint64_t cow_set_cow_1(uint64_t result, unint64_t a2)
{
  atomic_store(a2, (unint64_t *)(result + 8));
  return result;
}

uint64_t _compare_clumpiness_1(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

_QWORD *__mset_enumerateObjectsWithOptionsUsingBlock_block_invoke(_QWORD *result, uint64_t a2)
{
  void *v2;
  BOOL v3;
  _QWORD *v4;
  void *v5;

  v2 = *(void **)(result[5] + 8 * a2);
  if (v2)
    v3 = v2 == &___NSSetM_DeletedMarker;
  else
    v3 = 1;
  if (!v3)
  {
    v4 = result;
    v5 = (void *)_CFAutoreleasePoolPush();
    __NSSET_IS_CALLING_OUT_TO_A_BLOCK__(v4[4]);
    return _CFAutoreleasePoolPop(v5);
  }
  return result;
}

uint64_t _CFListFormatterGetTypeID()
{
  return 68;
}

void __CFListFormatterDeallocate(uint64_t a1)
{
  const void *v1;

  if (!a1)
    __CFListFormatterDeallocate_cold_1();
  v1 = *(const void **)(a1 + 16);
  if (v1)
    CFRelease(v1);
}

CFStringRef __CFListFormatterCopyDescription(const void *a1)
{
  const __CFAllocator *v2;
  CFAllocatorRef v3;

  if (!a1)
    __CFListFormatterCopyDescription_cold_1();
  v2 = CFGetAllocator(a1);
  v3 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CFListFormatter %p>[%p]"), a1, v3);
}

uint64_t _CFListFormatterCreate(__objc2_class **a1, const void *a2)
{
  uint64_t Instance;

  if (!a1)
    _CFListFormatterCreate_cold_1();
  if (!a2)
    _CFListFormatterCreate_cold_2();
  Instance = _CFRuntimeCreateInstance(a1, 0x44uLL, 8, 0);
  if (Instance)
    *(_QWORD *)(Instance + 16) = CFRetain(a2);
  return Instance;
}

const __CFString *_CFListFormatterCreateStringByJoiningStrings(const __CFAllocator *a1, unint64_t *a2, const __CFArray *a3)
{
  unint64_t v6;
  CFIndex Count;
  uint64_t v8;
  _QWORD *v9;
  _DWORD *v10;
  _BYTE *v11;
  CFIndex i;
  const __CFString *ValueAtIndex;
  CFIndex Length;
  UniChar *CharactersPtr;
  const __CFString *Identifier;
  void *CStringPtr;
  uint64_t v18;
  CFStringRef v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  UniChar *v23;
  int v24;
  const __CFAllocator *alloc;
  const __CFLocale *locale;
  _QWORD v28[2];
  void (*v29)(uint64_t);
  void *v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  _BYTE *v34;
  _DWORD *v35;
  int v36;
  UniChar chars[769];
  char buffer[256];
  uint64_t v39;
  CFRange v40;

  v39 = *MEMORY[0x1E0C80C00];
  v6 = _CFGetNonObjCTypeID(a2);
  if (v6 != 68)
    _CFAssertMismatchedTypeID(0x44uLL, v6);
  if (!a3)
    return 0;
  Count = CFArrayGetCount(a3);
  if (!Count)
    return &stru_1E1337B18;
  v8 = Count;
  alloc = a1;
  locale = (const __CFLocale *)a2[2];
  v9 = malloc_type_malloc(8 * Count, 0x10040436913F5uLL);
  v10 = malloc_type_malloc(4 * v8, 0x100004052888210uLL);
  v11 = malloc_type_calloc(v8, 1uLL, 0x100004077774924uLL);
  if (v8 >= 1)
  {
    for (i = 0; i != v8; ++i)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a3, i);
      Length = CFStringGetLength(ValueAtIndex);
      CharactersPtr = (UniChar *)CFStringGetCharactersPtr(ValueAtIndex);
      if (!CharactersPtr)
      {
        CharactersPtr = (UniChar *)malloc_type_malloc(2 * Length, 0x1000040BDFB0063uLL);
        v40.location = 0;
        v40.length = Length;
        CFStringGetCharacters(ValueAtIndex, v40, CharactersPtr);
        v11[i] = 1;
      }
      v10[i] = Length;
      v9[i] = CharactersPtr;
    }
  }
  v36 = 0;
  Identifier = CFLocaleGetIdentifier(locale);
  CStringPtr = (void *)CFStringGetCStringPtr(Identifier, 0x600u);
  if (!CStringPtr)
  {
    if (CFStringGetCString(Identifier, buffer, 256, 0x600u))
      CStringPtr = buffer;
    else
      CStringPtr = 0;
  }
  v18 = __cficu_ulistfmt_open((uint64_t)CStringPtr, &v36);
  v28[0] = MEMORY[0x1E0C809B0];
  v28[1] = 0x40000000;
  v29 = ___CFListFormatterCreateStringByJoiningStrings_block_invoke;
  v30 = &__block_descriptor_tmp_20;
  v31 = v18;
  v32 = v8;
  v33 = v9;
  v34 = v11;
  v35 = v10;
  if (v36 >= 1)
  {
    ___CFListFormatterCreateStringByJoiningStrings_block_invoke((uint64_t)v28);
    return 0;
  }
  v20 = v18;
  v36 = 0;
  v21 = __cficu_ulistfmt_format(v18, (uint64_t)v9, (uint64_t)v10, v8, chars, 768, &v36);
  if (v36 <= 0)
  {
    v19 = CFStringCreateWithCharacters(alloc, chars, v21);
  }
  else if (v36 == 15 || v8 < v21)
  {
    v36 = 0;
    v22 = (v21 + 1);
    v23 = (UniChar *)malloc_type_malloc(2 * (int)v22, 0x1000040BDFB0063uLL);
    v24 = __cficu_ulistfmt_format(v20, (uint64_t)v9, (uint64_t)v10, v8, v23, v22, &v36);
    if (v36 <= 0)
      v19 = CFStringCreateWithCharacters(alloc, v23, v24);
    else
      v19 = 0;
    free(v23);
  }
  else
  {
    v19 = 0;
  }
  v29((uint64_t)v28);
  return v19;
}

uint64_t cbDestroy(void **a1)
{
  void *v2;
  uint64_t v3;

  if (!a1)
    return 0;
  v2 = *a1;
  if (v2)
  {
    free(v2);
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  free(a1);
  return v3;
}

uint64_t _CFCalendarResetCurrent()
{
  return +[NSCalendar _resetCurrent](NSCalendar, "_resetCurrent");
}

void ____initDayChangedNotification_block_invoke_2()
{
  __postAndResetMidnight(1, 1);
}

void _dayChangedNotification(int a1, int a2, CFTypeRef cf2)
{
  int v3;

  v3 = CFEqual(CFSTR("com.apple.system.timezone"), cf2);
  __postAndResetMidnight(1, v3);
}

void sub_182C09DD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_182C0A158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _CFCalendarGetUnitsFromDateFormat(const __CFString *a1)
{
  CFIndex Length;
  CFIndex v3;
  uint64_t v4;
  CFIndex i;
  unsigned int v6;
  uint64_t v7;

  Length = CFStringGetLength(a1);
  if (Length < 1)
    return 0;
  v3 = Length;
  v4 = 0;
  for (i = 0; i != v3; ++i)
  {
    CFStringGetCharacterAtIndex(a1, i);
    udat_patternCharToDateFormatField();
    v6 = udat_toCalendarDateField();
    if (v6 > 0x16)
      v7 = 0;
    else
      v7 = qword_182DC7330[v6];
    v4 |= v7;
  }
  return v4;
}

void OUTLINED_FUNCTION_0_24(objc_class *a1)
{
  uint64_t v1;

  __CFRequireConcreteImplementation(a1, v1);
}

void OUTLINED_FUNCTION_2_11(objc_class *a1, uint64_t a2)
{
  __CFRequireConcreteImplementation(a1, a2);
}

void _systemTimeZoneChangedNotification()
{
  const void *v0;
  __CFNotificationCenter *LocalCenter;

  ++__noteCount_0;
  v0 = (const void *)+[NSTimeZone _resetSystemTimeZone](NSTimeZone, "_resetSystemTimeZone");
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterPostNotification(LocalCenter, CFSTR("kCFTimeZoneSystemTimeZoneDidChangeNotification-4"), v0, 0, 1u);
  CFNotificationCenterPostNotification(LocalCenter, CFSTR("kCFTimeZoneSystemTimeZoneDidChangeNotification-2"), v0, 0, 1u);
  CFNotificationCenterPostNotification(LocalCenter, CFSTR("kCFTimeZoneSystemTimeZoneDidChangeNotification"), v0, 0, 1u);
}

void OUTLINED_FUNCTION_0_25(objc_class *a1)
{
  uint64_t v1;

  __CFRequireConcreteImplementation(a1, v1);
}

uint64_t OUTLINED_FUNCTION_0_26()
{
  return _os_log_pack_fill();
}

uint64_t OUTLINED_FUNCTION_1_17()
{
  return _CFAutoreleasePoolAddObject();
}

BOOL _CFIsMatchingLibrary(char *a1, const char *a2)
{
  const char *v3;
  char *v4;
  size_t v5;

  v3 = a1;
  v4 = strrchr(a1, 47);
  if (v4)
    v3 = v4 + 1;
  v5 = strlen(a2);
  return strncmp(v3, a2, v5) == 0;
}

void *_CFGetHandleForLoadedLibrary(const char *a1)
{
  uint32_t v2;
  uint32_t v3;
  uint32_t v4;
  char *image_name;
  void *result;

  v2 = _dyld_image_count();
  if (!v2)
    return 0;
  v3 = v2;
  v4 = 0;
  while (1)
  {
    image_name = (char *)_dyld_get_image_name(v4);
    if (_CFIsMatchingLibrary(image_name, a1))
      break;
    if (v3 == ++v4)
      return 0;
  }
  if (!image_name)
    return 0;
  result = dlopen(image_name, 21);
  if (!result)
    _CFGetHandleForLoadedLibrary_cold_1();
  return result;
}

CFTypeID CFTimeZoneGetTypeID(void)
{
  return 48;
}

void CFTimeZoneResetSystem(void)
{
  void *v0;

  v0 = (void *)_CFAutoreleasePoolPush();
  +[NSTimeZone resetSystemTimeZone](NSTimeZone, "resetSystemTimeZone");
  _CFAutoreleasePoolPop(v0);
}

void CFTimeZoneSetDefault(CFTimeZoneRef tz)
{
  void *v2;

  v2 = (void *)_CFAutoreleasePoolPush();
  +[NSTimeZone setDefaultTimeZone:](NSTimeZone, "setDefaultTimeZone:", tz);
  _CFAutoreleasePoolPop(v2);
}

CFArrayRef CFTimeZoneCopyKnownNames(void)
{
  void *v0;
  NSArray *v1;
  const __CFArray *v2;

  v0 = (void *)_CFAutoreleasePoolPush();
  v1 = +[NSTimeZone knownTimeZoneNames](NSTimeZone, "knownTimeZoneNames");
  if (v1)
    v2 = (const __CFArray *)CFRetain(v1);
  else
    v2 = 0;
  _CFAutoreleasePoolPop(v0);
  return v2;
}

CFDictionaryRef CFTimeZoneCopyAbbreviationDictionary(void)
{
  void *v0;
  NSDictionary *v1;
  const __CFDictionary *v2;

  v0 = (void *)_CFAutoreleasePoolPush();
  v1 = +[NSTimeZone abbreviationDictionary](NSTimeZone, "abbreviationDictionary");
  if (v1)
    v2 = (const __CFDictionary *)CFRetain(v1);
  else
    v2 = 0;
  _CFAutoreleasePoolPop(v0);
  return v2;
}

void CFTimeZoneSetAbbreviationDictionary(CFDictionaryRef dict)
{
  void *v2;

  v2 = (void *)_CFAutoreleasePoolPush();
  +[NSTimeZone setAbbreviationDictionary:](NSTimeZone, "setAbbreviationDictionary:", dict);
  _CFAutoreleasePoolPop(v2);
}

CFTimeZoneRef CFTimeZoneCreate(CFAllocatorRef allocator, CFStringRef name, CFDataRef data)
{
  void *v5;
  NSTimeZone *v6;

  v5 = (void *)_CFAutoreleasePoolPush();
  v6 = -[NSTimeZone initWithName:data:]([NSTimeZone alloc], "initWithName:data:", name, data);
  _CFAutoreleasePoolPop(v5);
  return (CFTimeZoneRef)v6;
}

CFStringRef CFTimeZoneCopyAbbreviation(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  void *v4;
  const void *v5;
  const __CFString *v6;

  v4 = (void *)_CFAutoreleasePoolPush();
  v5 = (const void *)-[__CFTimeZone abbreviationForDate:](tz, "abbreviationForDate:", +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", at));
  if (v5)
    v6 = (const __CFString *)CFRetain(v5);
  else
    v6 = 0;
  _CFAutoreleasePoolPop(v4);
  return v6;
}

Boolean CFTimeZoneIsDaylightSavingTime(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  void *v4;

  v4 = (void *)_CFAutoreleasePoolPush();
  LOBYTE(tz) = -[__CFTimeZone isDaylightSavingTimeForDate:](tz, "isDaylightSavingTimeForDate:", +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", at));
  _CFAutoreleasePoolPop(v4);
  return tz;
}

CFTimeInterval CFTimeZoneGetDaylightSavingTimeOffset(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  void *v4;
  double v5;
  double v6;

  v4 = (void *)_CFAutoreleasePoolPush();
  -[__CFTimeZone daylightSavingTimeOffsetForDate:](tz, "daylightSavingTimeOffsetForDate:", +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", at));
  v6 = v5;
  _CFAutoreleasePoolPop(v4);
  return v6;
}

CFAbsoluteTime CFTimeZoneGetNextDaylightSavingTimeTransition(CFTimeZoneRef tz, CFAbsoluteTime at)
{
  void *v4;
  void *v5;
  double v6;
  double v7;

  v4 = (void *)_CFAutoreleasePoolPush();
  v5 = (void *)-[__CFTimeZone nextDaylightSavingTimeTransitionAfterDate:](tz, "nextDaylightSavingTimeTransitionAfterDate:", +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:", at));
  if (v5)
  {
    objc_msgSend(v5, "timeIntervalSinceReferenceDate");
    v7 = v6;
  }
  else
  {
    v7 = 0.0;
  }
  _CFAutoreleasePoolPop(v4);
  return v7;
}

CFStringRef CFTimeZoneCopyLocalizedName(CFTimeZoneRef tz, CFTimeZoneNameStyle style, CFLocaleRef locale)
{
  void *v6;
  const void *v7;
  const __CFString *v8;

  v6 = (void *)_CFAutoreleasePoolPush();
  v7 = (const void *)-[__CFTimeZone localizedName:locale:](tz, "localizedName:locale:", style, locale);
  if (v7)
    v8 = (const __CFString *)CFRetain(v7);
  else
    v8 = 0;
  _CFAutoreleasePoolPop(v6);
  return v8;
}

void OUTLINED_FUNCTION_0_27(objc_class *a1)
{
  uint64_t v1;

  __CFRequireConcreteImplementation(a1, v1);
}

const char *__CFStringEncodingGetICUName(int a1)
{
  const char *result;
  int WindowsCodePage;
  char __str[60];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a1 == 2576)
    return "IMAP-mailbox-name";
  if ((a1 & 0xF00) == 0x100
    || (WindowsCodePage = __CFStringEncodingGetWindowsCodePage(a1)) == 0
    || snprintf(__str, 0x3CuLL, "windows-%d", WindowsCodePage) > 59
    || (result = (const char *)ucnv_getAlias()) == 0)
  {
    if (__CFStringEncodingGetCanonicalName(a1, __str, 60))
      return (const char *)ucnv_getAlias();
    else
      return 0;
  }
  return result;
}

uint64_t __CFStringEncodingGetFromICUName(const char *a1)
{
  const char *StandardName;
  const char *v3;
  size_t v4;
  uint64_t result;
  const char *v6;
  const char *v7;
  size_t v8;
  const char *v9;
  const char *v10;
  size_t v11;
  int v12;
  char *__endptr[2];

  __endptr[1] = *(char **)MEMORY[0x1E0C80C00];
  __endptr[0] = 0;
  if (!strncasecmp_l(a1, "windows-", 8uLL, 0))
  {
    v12 = strtol(a1 + 8, __endptr, 10);
    if (v12)
    {
      if (!*__endptr[0])
        return __CFStringEncodingGetFromWindowsCodePage((unsigned __int16)v12);
    }
  }
  if (!ucnv_countAliases())
    return 0xFFFFFFFFLL;
  StandardName = (const char *)ucnv_getStandardName();
  if (!StandardName)
    goto LABEL_23;
  v3 = StandardName;
  if (!strncasecmp_l(StandardName, "windows-", 8uLL, 0))
  {
    v12 = strtol(v3 + 8, __endptr, 10);
    if (v12)
    {
      if (!*__endptr[0])
        return __CFStringEncodingGetFromWindowsCodePage((unsigned __int16)v12);
    }
  }
  v4 = strlen(v3);
  if (!strncasecmp_l(a1, v3, v4, 0) || (result = __CFStringEncodingGetFromCanonicalName(v3), (_DWORD)result == -1))
  {
LABEL_23:
    v6 = (const char *)ucnv_getStandardName();
    if (!v6
      || (v7 = v6, v8 = strlen(v6), !strncasecmp_l(a1, v7, v8, 0))
      || (result = __CFStringEncodingGetFromCanonicalName(v7), (_DWORD)result == -1))
    {
      v9 = (const char *)ucnv_getStandardName();
      if (v9)
      {
        v10 = v9;
        v11 = strlen(v9);
        if (strncasecmp_l(a1, v10, v11, 0))
          return __CFStringEncodingGetFromCanonicalName(v10);
      }
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t __CFStringEncodingICUToBytes(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, _QWORD *a8)
{
  _QWORD *Typed;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unint64_t v20;

  if ((a2 & 0xFF0000) == 0)
    goto LABEL_6;
  Typed = (_QWORD *)_CFGetTSD(7u);
  if (!Typed)
  {
    Typed = (_QWORD *)CFAllocatorAllocateTyped(0, 16, 0x1080040EF48E34ELL, 0);
    *Typed = 0;
    Typed[1] = 0;
    _CFSetTSD(7u, (uint64_t)Typed, (uint64_t)__CFICUThreadDataDestructor);
  }
  if (*(unsigned __int8 *)Typed <= (BYTE2(a2) - 1)
    || (v16 = *(_QWORD *)(Typed[1] + 8 * (BYTE2(a2) - 1))) == 0)
  {
LABEL_6:
    v17 = ucnv_open();
    if (!v17)
      return 3;
    v16 = v17;
    v18 = HIBYTE(a2);
    if ((a2 & 0xFF000001) == 1)
      v18 = 63;
    if (v18)
      ucnv_setSubstChars();
    else
      ucnv_setFromUCallBack();
  }
  v20 = a3 + 2 * a4;
  if (a7)
  {
    ucnv_fromUnicode();
    if (a8)
      *a8 = a6 - a6;
  }
  else
  {
    while (a3 < v20)
      ucnv_fromUnicode();
    if (a8)
      *a8 = 0;
  }
  if (a5)
    *a5 = (uint64_t)(a3 - a3) >> 1;
  return __CFStringEncodingConverterReleaseICUConverter(v16, a2, 0);
}

uint64_t __CFStringEncodingConverterReleaseICUConverter(uint64_t a1, unsigned int a2, uint64_t a3)
{
  void *v4;
  unsigned __int8 *v5;
  unsigned __int8 v6;
  uint64_t v7;
  unsigned __int8 *Typed;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  unsigned __int8 v13;
  size_t v14;
  unsigned __int8 v15;
  uint64_t v16;

  LODWORD(v4) = HIWORD(a2);
  if (a3 != 1 && ((a2 & 0x1000) != 0 || a3 == 2 && (a2 & 0x2000) != 0))
  {
    if ((a2 & 0xFF0000) != 0)
      return v4 << 16;
    Typed = (unsigned __int8 *)_CFGetTSD(7u);
    if (!Typed)
    {
      Typed = (unsigned __int8 *)CFAllocatorAllocateTyped(0, 16, 0x1080040EF48E34ELL, 0);
      *(_QWORD *)Typed = 0;
      *((_QWORD *)Typed + 1) = 0;
      _CFSetTSD(7u, (uint64_t)Typed, (uint64_t)__CFICUThreadDataDestructor);
    }
    v4 = (void *)*((_QWORD *)Typed + 1);
    if (!v4)
    {
      v11 = (_OWORD *)CFAllocatorAllocateTyped(0, 80, 0x2004093837F09, 0);
      LOBYTE(v9) = 0;
      *((_QWORD *)Typed + 1) = v11;
      *v11 = 0u;
      v11[1] = 0u;
      v11[2] = 0u;
      v11[3] = 0u;
      v11[4] = 0u;
      LOBYTE(v10) = 10;
      *Typed = 10;
      v4 = (void *)*((_QWORD *)Typed + 1);
      goto LABEL_29;
    }
    v9 = Typed[1];
    v10 = *Typed;
    if (v9 >= v10)
    {
      if (!*Typed)
      {
        v10 = 0;
LABEL_28:
        v13 = v10 + 10;
        v14 = 8 * (v10 + 10);
        v4 = (void *)CFAllocatorAllocateTyped(0, v14, 0x2004093837F09, 0);
        bzero(v4, v14);
        memcpy(v4, *((const void **)Typed + 1), 8 * *Typed);
        CFAllocatorDeallocate(0, *((void **)Typed + 1));
        *((_QWORD *)Typed + 1) = v4;
        LOBYTE(v9) = *Typed;
        LOBYTE(v10) = v13;
        *Typed = v13;
        goto LABEL_29;
      }
    }
    else if (!*((_QWORD *)v4 + v9))
    {
      goto LABEL_29;
    }
    v9 = 0;
    while (*((_QWORD *)v4 + v9))
    {
      if (v10 == ++v9)
      {
        if (v10 <= 0xF5)
          goto LABEL_28;
        CFLog(3, CFSTR("Per-thread streaming ID for ICU converters exhausted. Ignoring..."));
        goto LABEL_26;
      }
    }
LABEL_29:
    *((_QWORD *)v4 + v9) = a1;
    LOBYTE(v4) = v9 + 1;
    v15 = v9 + 1;
    Typed[1] = v15;
    if (v15 >= v10)
    {
      if (!(_BYTE)v10)
      {
        LOBYTE(v10) = 0;
LABEL_39:
        Typed[1] = v10;
        return v4 << 16;
      }
    }
    else if (!*(_QWORD *)(*((_QWORD *)Typed + 1) + 8 * v15))
    {
      return v4 << 16;
    }
    v16 = 0;
    while (*(_QWORD *)(*((_QWORD *)Typed + 1) + 8 * v16))
    {
      if (v10 == ++v16)
        goto LABEL_39;
    }
    LOBYTE(v10) = v16;
    goto LABEL_39;
  }
  if ((a2 & 0xFF0000) != 0)
  {
    v5 = (unsigned __int8 *)_CFGetTSD(7u);
    if (!v5)
    {
      v5 = (unsigned __int8 *)CFAllocatorAllocateTyped(0, 16, 0x1080040EF48E34ELL, 0);
      *(_QWORD *)v5 = 0;
      *((_QWORD *)v5 + 1) = 0;
      _CFSetTSD(7u, (uint64_t)v5, (uint64_t)__CFICUThreadDataDestructor);
    }
    v6 = (_BYTE)v4 - 1;
    if (*v5 > ((_BYTE)v4 - 1))
    {
      v7 = *((_QWORD *)v5 + 1);
      if (*(_QWORD *)(v7 + 8 * ((_BYTE)v4 - 1)) == a1)
      {
        *(_QWORD *)(v7 + 8 * ((_BYTE)v4 - 1)) = 0;
        if (v5[1] > v6)
          v5[1] = v6;
      }
    }
  }
LABEL_26:
  ucnv_close();
  return 0;
}

uint64_t __CFStringEncodingICUByteLength(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  _QWORD v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  v5[0] = 0;
  if (__CFStringEncodingICUToBytes(a1, a2, a3, a4, 0, 0, 0, v5))
    return 0;
  else
    return v5[0];
}

_DWORD *__CFStringEncodingCreateICUEncodings(const __CFAllocator *a1, _QWORD *a2)
{
  int v4;
  uint64_t v5;
  _DWORD *Typed;
  uint64_t v7;
  uint64_t v8;
  const char *AvailableName;
  int v10;

  v4 = ucnv_countAvailable();
  if (!v4)
    return 0;
  v5 = v4;
  Typed = (_DWORD *)CFAllocatorAllocateTyped(0, 4 * v4, 0x100004052888210, 0);
  if ((int)v5 < 1)
    goto LABEL_8;
  v7 = 0;
  v8 = 0;
  do
  {
    AvailableName = (const char *)ucnv_getAvailableName();
    v10 = __CFStringEncodingGetFromICUName(AvailableName);
    if (v10 != -1)
      Typed[v8++] = v10;
    ++v7;
  }
  while (v5 != v7);
  if (!v8)
  {
LABEL_8:
    CFAllocatorDeallocate(a1, Typed);
    v8 = 0;
    Typed = 0;
  }
  *a2 = v8;
  return Typed;
}

void __CFICUThreadDataDestructor(_QWORD *ptr)
{
  char *v2;
  char *v3;

  v2 = (char *)ptr[1];
  if (v2)
  {
    if (*(_BYTE *)ptr)
    {
      v3 = &v2[8 * *(unsigned __int8 *)ptr];
      do
      {
        v2 += 8;
        ucnv_close();
      }
      while (v2 < v3);
      v2 = (char *)ptr[1];
    }
    CFAllocatorDeallocate(0, v2);
  }
  CFAllocatorDeallocate(0, ptr);
}

uint64_t __CFStringEncodingGetWindowsCodePage(int a1)
{
  unsigned int v1;
  unint64_t v2;
  __int16 *v4;
  unsigned int v5;
  __int16 *v6;
  char *v7;
  unsigned int v8;
  unsigned __int16 *v9;
  __int16 *v10;

  if ((a1 & 0xF00) == 0x200)
    return a1 + 28590;
  if ((a1 & 0xF00) == 0x100)
  {
    HIDWORD(v2) = a1 - 256;
    LODWORD(v2) = a1 - 256;
    v1 = v2 >> 26;
    if (v1 < 7)
      return word_182DC759C[v1];
    return 0;
  }
  v4 = (__int16 *)&unk_182DC759A;
  v5 = a1 & 0xFFF;
  v6 = &__CFKnownEncodingList;
  while (1)
  {
    v7 = (char *)&v6[((char *)v4 - (char *)v6) >> 2];
    v8 = *(unsigned __int16 *)v7;
    if (v5 == v8)
      break;
    v9 = (unsigned __int16 *)(v7 - 2);
    v10 = (__int16 *)(v7 + 2);
    if (v5 < v8)
      v4 = (__int16 *)v9;
    else
      v6 = v10;
    if (v6 > v4)
      return 0;
  }
  if (v7 - (char *)&__CFKnownEncodingList == -2)
    return 0;
  return *(unsigned __int16 *)((char *)&__CFWindowsCPList + v7 - (char *)&__CFKnownEncodingList);
}

uint64_t __CFStringEncodingGetMostCompatibleMacScript()
{
  return 0xFFFFFFFFLL;
}

const char *__CFStringEncodingGetName(int a1)
{
  const char *result;

  if (a1 > 67109119)
  {
    if (a1 <= 268435711)
    {
      switch(a1)
      {
        case 67109120:
          return "Unicode (UTF-7)";
        case 134217984:
          return "Unicode (UTF-8)";
        case 201326848:
          return "Unicode (UTF-32)";
      }
    }
    else if (a1 > 402653439)
    {
      if (a1 == 402653440)
        return "Unicode (UTF-32BE)";
      if (a1 == 469762304)
        return "Unicode (UTF-32LE)";
    }
    else
    {
      if (a1 == 268435712)
        return "Unicode (UTF-16BE)";
      if (a1 == 335544576)
        return "Unicode (UTF-16LE)";
    }
    return 0;
  }
  else
  {
    switch(a1)
    {
      case 3056:
        result = "Japanese (NTT Docomo Shift JIS)";
        break;
      case 3057:
        result = "Japanese (KDDI Shift JIS)";
        break;
      case 3058:
        result = "Japanese (SoftBank Shift JIS)";
        break;
      case 3059:
        result = "Japanese (NTT Docomo ISO 2022-JP)";
        break;
      case 3060:
        result = "Japanese (KDDI ISO 2022-JP)";
        break;
      default:
        if (a1 == 256)
        {
          result = "Unicode (UTF-16)";
        }
        else
        {
          if (a1 != 3071)
            return 0;
          result = "Non-lossy ASCII";
        }
        break;
    }
  }
  return result;
}

const __CFString *_CFPrefsCopyDescriptionOfAllSearchLists()
{
  return CFSTR("Obsolete");
}

void _CFPrefsDumpDescriptionOfAllSearchLists(const char *a1)
{
  id v2;
  const __CFString *v3;
  size_t v4;
  const __CFURL *v5;
  uint64_t v6;
  uint64_t v7;
  CFAbsoluteTime Current;
  const __CFString *v9;
  const __CFString *v10;
  CFIndex Length;
  CFIndex v12;
  char *v13;
  size_t v14;

  v2 = +[_CFXPreferences copyDefaultPreferences](_CFXPreferences, "copyDefaultPreferences");
  v3 = -[_CFXPreferences copyDescriptionOfSearchLists]((uint64_t)v2);

  if (v3)
  {
    if (a1)
    {
      v4 = strlen(a1);
      v5 = CFURLCreateWithBytes((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)a1, v4, 0x8000100u, 0);
      if (!v5)
        goto LABEL_9;
    }
    else
    {
      v6 = _CFProcessNameString();
      v7 = getpid();
      Current = CFAbsoluteTimeGetCurrent();
      v9 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("/tmp/%@-preferences-search-lists(%d:%f).txt"), v6, v7, *(_QWORD *)&Current);
      if (!v9)
        goto LABEL_9;
      v10 = v9;
      v5 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v9, kCFURLPOSIXPathStyle, 0);
      CFRelease(v10);
      if (!v5)
        goto LABEL_9;
    }
    Length = CFStringGetLength(v3);
    v12 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    v13 = (char *)malloc_type_calloc(v12, 1uLL, 0x100004077774924uLL);
    CFStringGetCString(v3, v13, v12, 0x8000100u);
    v14 = strlen(v13);
    _CFWriteBytesToFile(v5, v13, v14);
    CFRelease(v5);
    free(v13);
LABEL_9:
    CFRelease(v3);
  }
}

uint64_t _CFPrefsSetEphemeralMultiUserEnabled(uint64_t result)
{
  eduModeOverride = result;
  return result;
}

const __CFString *_CFPrefsCreateConfigurationFileNameFromIdentifier(const __CFString *a1)
{
  const __CFString *v1;
  _BOOL4 v2;
  __CFString *MutableCopy;
  const __CFString *v4;

  v1 = a1;
  if (a1)
  {
    v2 = eduModeEnabled();
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, v1);
    v1 = MutableCopy;
    if (v2)
      v4 = CFSTR("-cloud-users.defaults");
    else
      v4 = CFSTR(".defaults");
    CFStringAppend(MutableCopy, v4);
  }
  return v1;
}

CFURLRef _CFPrefsCopyCloudConfigurationURLFromBundle(__CFBundle *a1, const __CFString *Identifier)
{
  CFURLRef v4;
  const __CFURL *v5;
  const __CFString *ConfigurationFileNameFromIdentifier;
  const __CFString *v7;
  CFURLRef v8;

  v4 = CFBundleCopyResourcesDirectoryURL(a1);
  if (!v4)
    return 0;
  v5 = v4;
  if (!Identifier)
    Identifier = CFBundleGetIdentifier(a1);
  ConfigurationFileNameFromIdentifier = _CFPrefsCreateConfigurationFileNameFromIdentifier(Identifier);
  if (ConfigurationFileNameFromIdentifier)
  {
    v7 = ConfigurationFileNameFromIdentifier;
    v8 = CFURLCreateCopyAppendingPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v5, ConfigurationFileNameFromIdentifier, 0);
    CFRelease(v7);
  }
  else
  {
    v8 = 0;
  }
  CFRelease(v5);
  return v8;
}

void _CFPrefsEnableWritingToExternalAppCloudPreferences()
{
  _CFPrefsOverrideEnableWritingToExternalAppCloudPreferences = 1;
}

CFURLRef _CFPrefsCopyCloudConfigurationURLForIdentifier(const void *a1)
{
  const __CFDictionary *Mutable;
  const __CFURL *Value;
  CFURLRef v4;
  void *v5;
  const char *v6;
  id v7;
  const __CFURL *v8;
  const __CFURL *v9;
  __CFBundle *Unique;

  os_unfair_lock_lock((os_unfair_lock_t)&_CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMappingLock);
  Mutable = (const __CFDictionary *)_CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMapping;
  if (!_CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMapping)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    _CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMapping = (uint64_t)Mutable;
  }
  Value = (const __CFURL *)CFDictionaryGetValue(Mutable, a1);
  if (Value)
  {
    v4 = Value;
    CFRetain(Value);
    goto LABEL_12;
  }
  v5 = (void *)MEMORY[0x186DB02F4]();
  v6 = sel_registerName("applicationProxyForIdentifier:");
  v7 = objc_msgSend((void *)getLSApplicationProxyClass[0](), v6, a1);
  if (!v7 || (v8 = (const __CFURL *)objc_msgSend(v7, sel_registerName("bundleURL"))) == 0)
  {
    objc_autoreleasePoolPop(v5);
    goto LABEL_11;
  }
  v9 = v8;
  CFRetain(v8);
  objc_autoreleasePoolPop(v5);
  Unique = (__CFBundle *)_CFBundleCreateUnique((const __CFAllocator *)&__kCFAllocatorSystemDefault, v9);
  CFRelease(v9);
  if (!Unique)
  {
LABEL_11:
    v4 = 0;
    goto LABEL_12;
  }
  v4 = _CFPrefsCopyCloudConfigurationURLFromBundle(Unique, 0);
  CFRelease(Unique);
  if (v4)
    CFDictionarySetValue((CFMutableDictionaryRef)_CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMapping, a1, v4);
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)&_CFPrefsCopyCloudConfigurationURLForIdentifier_cachedMappingLock);
  return v4;
}

void sub_182C0D704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C0D894(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void pendingKVODestructor()
{
  qword_1EDCD1038 = (uint64_t)"Unexpected pending notifications upon thread exit";
  abort();
}

void sub_182C0DE0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_182C0E2D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *copyDescriptionApplier(uint64_t a1, void *a2, __CFString *a3)
{
  void *v5;
  const __CFString *v6;

  v5 = (void *)_CFAutoreleasePoolPush();
  CFStringAppend(a3, CFSTR("\n*********\n"));
  v6 = (const __CFString *)objc_msgSend(a2, "description");
  if (v6)
    CFStringAppend(a3, v6);
  return _CFAutoreleasePoolPop(v5);
}

BOOL _CFPrefsWritingToExternalAppCloudPreferencesEnabled()
{
  if (_CFPrefsOverrideEnableWritingToExternalAppCloudPreferences)
    return 1;
  if (_CFPrefsWritingToExternalAppCloudPreferencesEnabled_onceToken != -1)
    dispatch_once(&_CFPrefsWritingToExternalAppCloudPreferencesEnabled_onceToken, &__block_literal_global_135_0);
  return _CFPrefsOverrideEnableWritingToExternalAppCloudPreferences != 0;
}

void *initLSApplicationProxy()
{
  void *result;

  if (MobileCoreServicesLibrary_frameworkLibrary
    || (result = dlopen("/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices", 2),
        (MobileCoreServicesLibrary_frameworkLibrary = (uint64_t)result) != 0))
  {
    result = objc_getClass("LSApplicationProxy");
    classLSApplicationProxy = (uint64_t)result;
    getLSApplicationProxyClass[0] = LSApplicationProxyFunction;
  }
  return result;
}

uint64_t LSApplicationProxyFunction()
{
  return classLSApplicationProxy;
}

__CFBundle *__appIsInternal_block_invoke()
{
  const char *v0;
  __CFBundle *result;
  BOOL v2;

  v0 = _CFProcessPath();
  if (strncmp(v0, "/private/var/", 0xDuLL))
  {
    result = (__CFBundle *)strncmp(v0, "/var/", 5uLL);
    if ((_DWORD)result)
    {
      v2 = 1;
LABEL_7:
      appIsInternal_isInternal = v2;
      return result;
    }
  }
  result = CFBundleGetMainBundle();
  if (result)
  {
    result = (__CFBundle *)CFBundleGetIdentifier(result);
    if (result)
    {
      result = (__CFBundle *)CFStringHasPrefix((CFStringRef)result, CFSTR("com.apple."));
      v2 = (_DWORD)result != 0;
      goto LABEL_7;
    }
  }
  return result;
}

void OUTLINED_FUNCTION_0_28(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x16u);
}

uint64_t OUTLINED_FUNCTION_0_29(objc_class *a1)
{
  const char *v1;
  objc_class *v2;

  return __CFFullMethodName(a1, v2, v1);
}

void OUTLINED_FUNCTION_1_19(uint64_t a1, const __CFString *a2)
{
  uint64_t v2;

  _CFThrowFormattedException(v2, a2);
}

void NSMoribundCache_invalidAccess()
{
  if (NSMoribundCache_invalidAccess_oGuard != -1)
    dispatch_once(&NSMoribundCache_invalidAccess_oGuard, &__block_literal_global_34);
}

void __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void __NSCacheApplicationDidEnterBackgroundCallBack(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v3;

  v3 = a2;
  if (a2[24] != 255)
    cache_remove_with_block();

}

void sub_182C0EE18(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    objc_begin_catch(exception_object);
    JUMPOUT(0x182C0EDDCLL);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CFBasicHashHasStrongValues()
{
  return 0;
}

uint64_t CFBasicHashHasStrongKeys()
{
  return 0;
}

uint64_t CFBasicHashGetNumBuckets(uint64_t a1)
{
  return __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
}

uint64_t CFBasicHashGetCapacity(uint64_t a1)
{
  return __CFBasicHashTableCapacities[*(unsigned __int8 *)(a1 + 26)];
}

unint64_t CFBasicHashGetFlags(uint64_t a1)
{
  unsigned int v1;

  v1 = *(unsigned __int16 *)(a1 + 18);
  if ((v1 & 0x18) != 0)
    return (unsigned __int16)(*(__int128 *)(a1 + 24) >> 51) & 0x8000 | (unint64_t)(((v1 & 3) << 13) | (v1 >> 2) & 1) | 2;
  else
    return (unsigned __int16)(*(__int128 *)(a1 + 24) >> 51) & 0x8000 | (unint64_t)(((v1 & 3) << 13) | (v1 >> 2) & 1);
}

uint64_t CFBasicHashApplyIndexed(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t (*v8)(uint64_t, _OWORD *);
  _OWORD v9[2];
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a3 < 0)
    goto LABEL_8;
  v4 = a3;
  if (!a3)
    return result;
  v5 = a2;
  v6 = result;
  if (__CFBasicHashTableSizes[*(unsigned __int8 *)(result + 26)] < a2 + a3)
LABEL_8:
    __break(1u);
  do
  {
    v10 = 0u;
    v11 = 0u;
    result = CFBasicHashGetBucket(v6, v5, &v10);
    if (*((_QWORD *)&v11 + 1))
    {
      v8 = *(uint64_t (**)(uint64_t, _OWORD *))(a4 + 16);
      v9[0] = v10;
      v9[1] = v11;
      result = v8(a4, v9);
      if (!(_DWORD)result)
        break;
    }
    ++v5;
    --v4;
  }
  while (v4);
  return result;
}

unint64_t CFBasicHashRemoveValueAtIndex(uint64_t a1, uint64_t a2)
{
  char v2;
  unint64_t v4;
  int v5;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x40) != 0)
    __break(1u);
  v8 = 0u;
  v9 = 0u;
  CFBasicHashGetBucket(a1, a2, &v8);
  v4 = *((_QWORD *)&v9 + 1);
  if (*((_QWORD *)&v9 + 1) < 2uLL)
  {
    if (*((_QWORD *)&v9 + 1) == 1)
      __CFBasicHashRemoveValue(a1, v8);
  }
  else
  {
    ++*(_WORD *)(a1 + 16);
    v5 = *(unsigned __int16 *)(a1 + 18);
    if (v4 <= 0x7FFFFFFFFFFFFFFELL && (v5 & 0x18) != 0)
      __asm { BR              X12 }
  }
  return v4;
}

uint64_t CFBasicHashAddIntValueAndInc(uint64_t a1, unint64_t a2, unint64_t a3)
{
  char v3;
  int v7;
  uint64_t result;
  uint64_t v9;
  int v10;
  uint64_t Bucket_Exponential_Indirect_NoCollision;
  uint64_t v12;
  uint64_t i;
  uint64_t v14;
  unint64_t v15;
  BOOL v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v3 = atomic_load((unint64_t *)(a1 + 8));
  if ((v3 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233 || a3 == 2780474809 || a3 == 2814029233)
    goto LABEL_57;
  v18 = 0u;
  v19 = 0u;
  if (*(_BYTE *)(a1 + 26))
  {
    v7 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential_Indirect(a1, a2, (uint64_t *)&v18);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double_Indirect(a1, a2, (uint64_t *)&v18);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear_Indirect(a1, a2, (uint64_t *)&v18);
          break;
        default:
          goto LABEL_57;
      }
    }
    else
    {
      switch(v7)
      {
        case 3:
          ___CFBasicHashFindBucket_Exponential(a1, a2, (uint64_t *)&v18);
          break;
        case 2:
          ___CFBasicHashFindBucket_Double(a1, a2, (uint64_t *)&v18);
          break;
        case 1:
          ___CFBasicHashFindBucket_Linear(a1, a2, (uint64_t *)&v18);
          break;
        default:
          goto LABEL_57;
      }
    }
  }
  else
  {
    v18 = xmmword_182DC7A10;
    v19 = unk_182DC7A20;
  }
  if (*((_QWORD *)&v19 + 1))
  {
    result = 0;
    ++*(_WORD *)(a1 + 16);
    return result;
  }
  v9 = *(unsigned __int8 *)(a1 + 26);
  if (__CFBasicHashTableCapacities[v9] < (uint64_t)(*(_DWORD *)(a1 + 20) + 1))
  {
    __CFBasicHashRehash(a1, 1);
    if (!*(_BYTE *)(a1 + 26))
    {
      Bucket_Exponential_Indirect_NoCollision = -1;
      goto LABEL_39;
    }
    v10 = *(_WORD *)(a1 + 18) & 3;
    if ((*(_WORD *)(a1 + 18) & 0x8000) != 0)
    {
      switch(v10)
      {
        case 3:
          Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_Indirect_NoCollision(a1, a2);
          goto LABEL_39;
        case 2:
          Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_Indirect_NoCollision(a1, a2);
          goto LABEL_39;
        case 1:
          Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(a1, a2);
          goto LABEL_39;
      }
    }
    else
    {
      switch(v10)
      {
        case 3:
          Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Exponential_NoCollision(a1, a2);
          goto LABEL_39;
        case 2:
          Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Double_NoCollision(a1, a2);
          goto LABEL_39;
        case 1:
          Bucket_Exponential_Indirect_NoCollision = ___CFBasicHashFindBucket_Linear_NoCollision(a1, a2);
LABEL_39:
          *(_QWORD *)&v18 = Bucket_Exponential_Indirect_NoCollision;
          v9 = *(unsigned __int8 *)(a1 + 26);
          goto LABEL_40;
      }
    }
LABEL_57:
    __break(1u);
  }
LABEL_40:
  v12 = __CFBasicHashTableSizes[v9];
  if (v12 >= 1)
  {
    for (i = 0; v12 != i; ++i)
    {
      v14 = *(_QWORD *)(a1 + 40);
      v15 = *(_QWORD *)(v14 + 8 * i);
      if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (v15 == 2780474809)
        {
          v15 = -1;
        }
        else
        {
          if (v15 == 2814029233)
            v15 = 0;
          if (v15 < a3)
            continue;
        }
        v16 = __CFADD__(v15, 1);
        v17 = v15 + 1;
        if (v16)
          v17 = 2814029233;
        if (v17 == -1)
          v17 = 2780474809;
        *(_QWORD *)(v14 + 8 * i) = v17;
        ++*(_WORD *)(a1 + 16);
      }
    }
  }
  __CFBasicHashAddValue(a1, v18, a2, a3);
  return 1;
}

void CFBasicHashRemoveIntValueAndDec(uint64_t a1, unint64_t a2)
{
  char v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;

  v2 = atomic_load((unint64_t *)(a1 + 8));
  if ((v2 & 0x40) != 0 || a2 == 2780474809 || a2 == 2814029233)
  {
    __break(1u);
  }
  else
  {
    v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
    if (v3 >= 1)
    {
      v4 = 0;
      v5 = -1;
      while (1)
      {
        v6 = *(_QWORD *)(a1 + 40);
        v7 = *(_QWORD *)(v6 + 8 * v4);
        if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          if (v7 == 2780474809)
          {
            v7 = -1;
LABEL_13:
            if (v7 == a2)
              v5 = v4;
            if (v7 > a2)
            {
              v8 = v7 - 1;
              if (!v8)
                v8 = 2814029233;
              *(_QWORD *)(v6 + 8 * v4) = v8;
              ++*(_WORD *)(a1 + 16);
            }
            goto LABEL_19;
          }
          if (v7 != 2814029233)
            goto LABEL_13;
          if (!a2)
            v5 = v4;
        }
LABEL_19:
        if (v3 == ++v4)
          goto LABEL_22;
      }
    }
    v5 = -1;
LABEL_22:
    __CFBasicHashRemoveValue(a1, v5);
  }
}

uint64_t CFBasicHashGetSize(uint64_t a1, int a2)
{
  __int16 v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v6;

  v2 = *(_WORD *)(a1 + 18);
  v3 = 56;
  if ((v2 & 4) == 0)
    v3 = 48;
  if ((v2 & 0x18) != 0)
    v4 = v3 + 8;
  else
    v4 = v3;
  if (a2 && (uint64_t)__CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)] >= 1)
  {
    v4 += malloc_size(*(const void **)(a1 + 40));
    v6 = *(unsigned __int16 *)(a1 + 18);
    if ((v6 & 4) != 0)
    {
      v4 += malloc_size(*(const void **)(a1 + 8 * ((v6 >> 2) & 1) + 40));
      LODWORD(v6) = *(unsigned __int16 *)(a1 + 18);
    }
    if ((v6 & 0x18) != 0)
      v4 += malloc_size(*(const void **)(a1 + 8 * ((v6 >> 3) & 3) + 40));
  }
  return v4;
}

void CFBasicHashShow(uint64_t a1)
{
  __CFString *v1;

  v1 = CFBasicHashCopyDescription(a1, 1, (uint64_t)&stru_1E1337B18, (uint64_t)CFSTR("\t"), 0);
  CFShow(v1);
  CFRelease(v1);
}

uint64_t CFBasicHashGetTypeID()
{
  return 3;
}

unint64_t ___CFBasicHashFindBucket_Linear_Indirect@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6;
  uint64_t (*v7)(unint64_t);
  unint64_t result;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t (*v17)(uint64_t);
  uint64_t (*v18)(uint64_t, unint64_t);
  unint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t *v24;

  v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  result = a2;
  if (v7)
    result = v7(a2);
  v9 = *(unsigned __int16 *)(a1 + 18);
  if ((v9 & 4) != 0)
    v10 = (uint64_t *)(a1 + 40 + 8 * ((v9 >> 2) & 1));
  else
    v10 = (uint64_t *)(a1 + 40);
  v24 = a3;
  if (!v6)
  {
    v13 = -1;
LABEL_29:
    v15 = 0;
    v20 = v24;
    v24[1] = 0;
    v24[2] = 0;
    *v24 = v13;
    goto LABEL_30;
  }
  v11 = result % v6;
  v12 = *v10;
  v13 = -1;
  v14 = v6;
  while (1)
  {
    v15 = *(_QWORD *)(v12 + 8 * v11);
    switch(v15)
    {
      case -1:
        if (v13 == -1)
          v13 = v11;
        goto LABEL_23;
      case 0:
        v20 = v24;
        v24[1] = 0;
        v24[2] = 0;
        if (v13 == -1)
          v21 = v11;
        else
          v21 = v13;
        *v24 = v21;
        goto LABEL_30;
      case 2814029233:
        v15 = 0;
        break;
    }
    if (v15 == 2780474809)
      v16 = -1;
    else
      v16 = v15;
    v17 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(a1 + 32) >> 54) >> 5]
                                            + 8 * ((*(_QWORD *)(a1 + 32) >> 54) & 0x1FLL));
    if (v17)
    {
      result = v17(v16);
      v16 = result;
    }
    if (v16 == a2)
      break;
    v18 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8 * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v18)
    {
      result = v18(v16, a2);
      if ((_DWORD)result)
        goto LABEL_36;
    }
LABEL_23:
    if (v6 <= v11 + 1)
      v19 = v6;
    else
      v19 = 0;
    v11 = v11 + 1 - v19;
    if (!--v14)
      goto LABEL_29;
  }
  v16 = a2;
LABEL_36:
  v20 = v24;
  *v24 = v11;
  v22 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v11);
  if (v22 == 2814029233)
  {
    v22 = 0;
  }
  else if (v22 == 2780474809)
  {
    v22 = -1;
  }
  v24[1] = v16;
  v24[2] = v22;
  v23 = *(unsigned __int16 *)(a1 + 18);
  if ((v23 & 0x18) != 0)
    __asm { BR              X11 }
  v15 = 1;
LABEL_30:
  v20[3] = v15;
  return result;
}

void sub_182C0F8AC()
{
  JUMPOUT(0x182C0F7E8);
}

void sub_182C0F8B4()
{
  JUMPOUT(0x182C0F7E8);
}

void sub_182C0F8BC()
{
  JUMPOUT(0x182C0F7E8);
}

unint64_t ___CFBasicHashFindBucket_Double_Indirect@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6;
  uint64_t (*v7)(unint64_t);
  unint64_t result;
  unint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t);
  uint64_t (*v19)(uint64_t, unint64_t);
  unint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t *v25;

  v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  result = a2;
  if (v7)
    result = v7(a2);
  if (result / v6 % v6)
    v9 = result / v6 % v6;
  else
    v9 = v6 - 1;
  v10 = *(unsigned __int16 *)(a1 + 18);
  if ((v10 & 4) != 0)
    v11 = (uint64_t *)(a1 + 40 + 8 * ((v10 >> 2) & 1));
  else
    v11 = (uint64_t *)(a1 + 40);
  v25 = a3;
  if (!v6)
  {
    v14 = -1;
LABEL_32:
    v16 = 0;
    v21 = v25;
    v25[1] = 0;
    v25[2] = 0;
    *v25 = v14;
    goto LABEL_33;
  }
  v12 = result % v6;
  v13 = *v11;
  v14 = -1;
  v15 = v6;
  while (1)
  {
    v16 = *(_QWORD *)(v13 + 8 * v12);
    switch(v16)
    {
      case -1:
        if (v14 == -1)
          v14 = v12;
        goto LABEL_26;
      case 0:
        v21 = v25;
        v25[1] = 0;
        v25[2] = 0;
        if (v14 == -1)
          v22 = v12;
        else
          v22 = v14;
        *v25 = v22;
        goto LABEL_33;
      case 2814029233:
        v16 = 0;
        break;
    }
    if (v16 == 2780474809)
      v17 = -1;
    else
      v17 = v16;
    v18 = *(uint64_t (**)(uint64_t))(CFBasicHashCallBackPtrs[(*(_QWORD *)(a1 + 32) >> 54) >> 5]
                                            + 8 * ((*(_QWORD *)(a1 + 32) >> 54) & 0x1FLL));
    if (v18)
    {
      result = v18(v17);
      v17 = result;
    }
    if (v17 == a2)
      break;
    v19 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8 * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v19)
    {
      result = v19(v17, a2);
      if ((_DWORD)result)
        goto LABEL_39;
    }
LABEL_26:
    if (v6 <= v12 + v9)
      v20 = v6;
    else
      v20 = 0;
    v12 = v12 + v9 - v20;
    if (!--v15)
      goto LABEL_32;
  }
  v17 = a2;
LABEL_39:
  v21 = v25;
  *v25 = v12;
  v23 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v12);
  if (v23 == 2814029233)
  {
    v23 = 0;
  }
  else if (v23 == 2780474809)
  {
    v23 = -1;
  }
  v25[1] = v17;
  v25[2] = v23;
  v24 = *(unsigned __int16 *)(a1 + 18);
  if ((v24 & 0x18) != 0)
    __asm { BR              X11 }
  v16 = 1;
LABEL_33:
  v21[3] = v16;
  return result;
}

void sub_182C0FB04()
{
  JUMPOUT(0x182C0FA40);
}

void sub_182C0FB0C()
{
  JUMPOUT(0x182C0FA40);
}

void sub_182C0FB14()
{
  JUMPOUT(0x182C0FA40);
}

unint64_t ___CFBasicHashFindBucket_Double@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  unint64_t v6;
  uint64_t (*v7)(unint64_t);
  unint64_t result;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t (*v19)(uint64_t, unint64_t);
  unint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t *v27;

  v6 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  result = a2;
  if (v7)
    result = v7(a2);
  if (result / v6 % v6)
    v9 = result / v6 % v6;
  else
    v9 = v6 - 1;
  v10 = *(unsigned __int16 *)(a1 + 18);
  v11 = (_QWORD *)(a1 + 40);
  if ((v10 & 4) != 0)
    v12 = (uint64_t *)(a1 + 40 + 8 * ((v10 >> 2) & 1));
  else
    v12 = (uint64_t *)(a1 + 40);
  v27 = a3;
  if (!v6)
  {
    v15 = -1;
LABEL_30:
    v17 = 0;
    v21 = v27;
    v27[1] = 0;
    v27[2] = 0;
    *v27 = v15;
    goto LABEL_31;
  }
  v13 = result % v6;
  v14 = *v12;
  v15 = -1;
  v16 = v6;
  while (1)
  {
    v17 = *(_QWORD *)(v14 + 8 * v13);
    switch(v17)
    {
      case -1:
        if (v15 == -1)
          v15 = v13;
        goto LABEL_24;
      case 0:
        v21 = v27;
        v27[1] = 0;
        v27[2] = 0;
        if (v15 == -1)
          v22 = v13;
        else
          v22 = v15;
        *v27 = v22;
        goto LABEL_31;
      case 2814029233:
        v17 = 0;
        break;
    }
    v18 = v17 == 2780474809 ? -1 : v17;
    if (v18 == a2)
      break;
    v19 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(a1 + 35) >> 5) & 0x1F]
                                                              + 8 * (*(_DWORD *)(a1 + 35) & 0x1F));
    if (v19)
    {
      result = v19(v18, a2);
      if ((_DWORD)result)
        goto LABEL_37;
    }
LABEL_24:
    if (v6 <= v13 + v9)
      v20 = v6;
    else
      v20 = 0;
    v13 = v13 + v9 - v20;
    if (!--v16)
      goto LABEL_30;
  }
  v18 = a2;
LABEL_37:
  v23 = *(_QWORD *)(*v11 + 8 * v13);
  v24 = -1;
  if (v23 != 2780474809)
    v24 = *(_QWORD *)(*v11 + 8 * v13);
  if (v23 == 2814029233)
    v25 = 0;
  else
    v25 = v24;
  v21 = v27;
  v27[1] = v18;
  v27[2] = v25;
  *v27 = v13;
  v26 = *(unsigned __int16 *)(a1 + 18);
  if ((v26 & 0x18) != 0)
    __asm { BR              X11 }
  v17 = 1;
LABEL_31:
  v21[3] = v17;
  return result;
}

void sub_182C0FD30()
{
  JUMPOUT(0x182C0FC74);
}

void sub_182C0FD38()
{
  JUMPOUT(0x182C0FC74);
}

void sub_182C0FD40()
{
  JUMPOUT(0x182C0FC74);
}

unint64_t ___CFBasicHashFindBucket_Exponential@<X0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v3;
  uint64_t v5;
  unint64_t v6;
  uint64_t (*v7)(unint64_t);
  unint64_t result;
  unint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, unint64_t);
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  _QWORD *v28;
  uint64_t *v29;
  uint64_t v30;
  unint64_t v31;

  v3 = a1;
  v5 = *(unsigned __int8 *)(a1 + 26);
  v6 = __CFBasicHashTableSizes[v5];
  v7 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  result = a2;
  v30 = v3;
  v31 = a2;
  if (v7)
  {
    result = v7(a2);
    v3 = v30;
    a2 = v31;
  }
  if (result / v6 % v6)
    v9 = result / v6 % v6;
  else
    v9 = v6 - 1;
  v10 = *(unsigned __int16 *)(v3 + 18);
  if ((v10 & 4) != 0)
    v11 = (uint64_t *)(v3 + 40 + 8 * ((v10 >> 2) & 1));
  else
    v11 = (uint64_t *)(v3 + 40);
  v29 = a3;
  if (!v6)
  {
    v15 = -1;
LABEL_31:
    v19 = 0;
    v22 = v29;
    v29[1] = 0;
    v29[2] = 0;
    *v29 = v15;
    goto LABEL_32;
  }
  v28 = (_QWORD *)(v3 + 40);
  v12 = result % v6;
  v13 = __CFBasicHashPrimitiveRoots[v5];
  v14 = *v11;
  v15 = -1;
  v16 = v6;
  v17 = v13;
  v18 = result % v6;
  while (1)
  {
    v19 = *(_QWORD *)(v14 + 8 * v18);
    switch(v19)
    {
      case -1:
        if (v15 == -1)
          v15 = v18;
        goto LABEL_24;
      case 0:
        v22 = v29;
        v29[1] = 0;
        v29[2] = 0;
        if (v15 == -1)
          v23 = v18;
        else
          v23 = v15;
        *v29 = v23;
        goto LABEL_32;
      case 2814029233:
        v19 = 0;
        break;
    }
    v20 = v19 == 2780474809 ? -1 : v19;
    if (v20 == a2)
      break;
    v21 = *(uint64_t (**)(uint64_t, unint64_t))(CFBasicHashCallBackPtrs[(*(_DWORD *)(v3 + 35) >> 5) & 0x1F]
                                                              + 8 * (*(_DWORD *)(v3 + 35) & 0x1F));
    if (v21)
    {
      result = v21(v20, v31);
      v3 = v30;
      a2 = v31;
      if ((_DWORD)result)
        goto LABEL_38;
    }
LABEL_24:
    v18 = v12 + v17 * v9;
    if (v6 <= v18)
      v18 %= v6;
    v17 *= v13;
    if (v6 <= v17)
      v17 %= v6;
    if (!--v16)
      goto LABEL_31;
  }
  v20 = a2;
LABEL_38:
  v22 = v29;
  v24 = *(_QWORD *)(*v28 + 8 * v18);
  v25 = -1;
  if (v24 != 2780474809)
    v25 = *(_QWORD *)(*v28 + 8 * v18);
  if (v24 == 2814029233)
    v26 = 0;
  else
    v26 = v25;
  v29[1] = v20;
  v29[2] = v26;
  *v29 = v18;
  v27 = *(unsigned __int16 *)(v3 + 18);
  if ((v27 & 0x18) != 0)
    __asm { BR              X11 }
  v19 = 1;
LABEL_32:
  v22[3] = v19;
  return result;
}

void sub_182C0FF94()
{
  JUMPOUT(0x182C0FED8);
}

void sub_182C0FF9C()
{
  JUMPOUT(0x182C0FED8);
}

void sub_182C0FFA4()
{
  JUMPOUT(0x182C0FED8);
}

uint64_t ___CFBasicHashFindBucket_Linear_Indirect_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t (*v4)(unint64_t);
  unint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t result;
  unint64_t v9;
  unint64_t v10;

  v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4)
    a2 = v4(a2);
  v5 = *(unsigned __int16 *)(a1 + 18);
  if ((v5 & 4) != 0)
    v6 = (uint64_t *)(a1 + 40 + 8 * ((v5 >> 2) & 1));
  else
    v6 = (uint64_t *)(a1 + 40);
  if (!v3)
    return -1;
  v7 = *v6;
  result = a2 % v3;
  v9 = v3;
  while (*(_QWORD *)(v7 + 8 * result))
  {
    if (v3 <= result + 1)
      v10 = v3;
    else
      v10 = 0;
    result = result + 1 - v10;
    if (!--v9)
      return -1;
  }
  return result;
}

uint64_t ___CFBasicHashFindBucket_Double_Indirect_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t (*v4)(unint64_t);
  unint64_t v5;
  unint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t result;
  unint64_t v10;
  unint64_t v11;

  v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4)
    a2 = v4(a2);
  v5 = a2 / v3 % v3;
  if (!v5)
    v5 = v3 - 1;
  v6 = *(unsigned __int16 *)(a1 + 18);
  if ((v6 & 4) != 0)
    v7 = (uint64_t *)(a1 + 40 + 8 * ((v6 >> 2) & 1));
  else
    v7 = (uint64_t *)(a1 + 40);
  v8 = *v7;
  result = a2 % v3;
  v10 = v3;
  while (*(_QWORD *)(v8 + 8 * result))
  {
    if (v3 <= result + v5)
      v11 = v3;
    else
      v11 = 0;
    result = result + v5 - v11;
    if (!--v10)
      return -1;
  }
  return result;
}

uint64_t ___CFBasicHashFindBucket_Double_NoCollision(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t (*v4)(unint64_t);
  unint64_t v5;
  unint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t result;
  unint64_t v10;
  unint64_t v11;

  v3 = __CFBasicHashTableSizes[*(unsigned __int8 *)(a1 + 26)];
  v4 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  if (v4)
    a2 = v4(a2);
  v5 = a2 / v3 % v3;
  if (!v5)
    v5 = v3 - 1;
  v6 = *(unsigned __int16 *)(a1 + 18);
  if ((v6 & 4) != 0)
    v7 = (uint64_t *)(a1 + 40 + 8 * ((v6 >> 2) & 1));
  else
    v7 = (uint64_t *)(a1 + 40);
  v8 = *v7;
  result = a2 % v3;
  v10 = v3;
  while (*(_QWORD *)(v8 + 8 * result))
  {
    if (v3 <= result + v5)
      v11 = v3;
    else
      v11 = 0;
    result = result + v5 - v11;
    if (!--v10)
      return -1;
  }
  return result;
}

unint64_t ___CFBasicHashFindBucket_Exponential_NoCollision(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t (*v5)(unint64_t);
  unint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t result;

  v3 = *(unsigned __int8 *)(a1 + 26);
  v4 = __CFBasicHashTableSizes[v3];
  v5 = *(uint64_t (**)(unint64_t))(CFBasicHashCallBackPtrs[((*(_QWORD *)(a1 + 32) >> 44) >> 5) & 0x1F]
                                                  + 8 * ((*(_QWORD *)(a1 + 32) >> 44) & 0x1FLL));
  if (v5)
    a2 = v5(a2);
  v6 = a2 / v4 % v4;
  if (!v6)
    v6 = v4 - 1;
  v7 = *(unsigned __int16 *)(a1 + 18);
  v8 = (uint64_t *)(a1 + 40 + 8 * ((v7 >> 2) & 1));
  if ((v7 & 4) == 0)
    v8 = (uint64_t *)(a1 + 40);
  v9 = *v8;
  v10 = v4;
  v11 = __CFBasicHashPrimitiveRoots[v3];
  result = a2 % v4;
  while (*(_QWORD *)(v9 + 8 * result))
  {
    result = a2 % v4 + v11 * v6;
    if (v4 <= result)
      result %= v4;
    v11 *= __CFBasicHashPrimitiveRoots[v3];
    if (v4 <= v11)
      v11 %= v4;
    if (!--v10)
      return -1;
  }
  return result;
}

uint64_t CFXNotificationRegistrarGetTypeID()
{
  return 70;
}

uint64_t CFXNotificationRegistrarGetOptions(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

void CFXNotificationRegistrarEnumerate(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v4;

  v4 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[8], 0, a2);
  _CFXNotificationRegistrarEnumerateObjectTable((uint64_t)a1, (uint64_t)&a1[12], (uint64_t)CFSTR("kCFNotificationAnyName"), a2);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[16], 1, a2);
  _CFXNotificationRegistrarEnumerateObserverTable((uint64_t)a1, &a1[20]._os_unfair_lock_opaque, (uint64_t)CFSTR("kCFNotificationAnyName"), (uint64_t)CFSTR("kCFNotificationAnyObject"), a2);
  os_unfair_lock_unlock(v4);
}

void _CFXNotificationRegistrarEnumerateNameTable(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFTypeRef v11;
  unsigned int *v12;
  uint64_t v13;

  v4 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v4)
  {
    v8 = 0;
    v13 = a2;
    do
    {
      v9 = *(unsigned int *)(*(_QWORD *)a2 + 4 * v8);
      if ((_DWORD)v9 != -1)
      {
        do
        {
          v10 = *(_QWORD *)(a1 + 96) + 40 * v9;
          v9 = *(unsigned int *)(v10 + 4);
          v11 = CFCachedStringCopyString((CFTypeRef *)(v10 + 8));
          v12 = (unsigned int *)(v10 + 24);
          if (a3 == 1)
            _CFXNotificationRegistrarEnumerateObserverTable(a1, v12, (uint64_t)v11, (uint64_t)CFSTR("kCFNotificationAnyObject"), a4);
          else
            _CFXNotificationRegistrarEnumerateObjectTable(a1, (uint64_t)v12, (uint64_t)v11, a4);
          CFRelease(v11);
        }
        while (v9 != 0xFFFFFFFFLL);
        a2 = v13;
        v4 = *(unsigned int *)(v13 + 8);
      }
      ++v8;
    }
    while (v8 < v4);
  }
}

uint64_t _CFXNotificationRegistrarEnumerateObjectTable(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v8;
  unint64_t i;
  uint64_t v10;
  uint64_t v11;

  v4 = *(unsigned int *)(a2 + 8);
  if ((_DWORD)v4)
  {
    v8 = result;
    for (i = 0; i < v4; ++i)
    {
      v10 = *(unsigned int *)(*(_QWORD *)a2 + 4 * i);
      if ((_DWORD)v10 != -1)
      {
        do
        {
          v11 = *(_QWORD *)(v8 + 120) + 32 * v10;
          v10 = *(unsigned int *)(v11 + 4);
          result = _CFXNotificationRegistrarEnumerateObserverTable(v8, (unsigned int *)(v11 + 16), a3, *(_QWORD *)(v11 + 8), a4);
        }
        while ((_DWORD)v10 != -1);
        v4 = *(unsigned int *)(a2 + 8);
      }
    }
  }
  return result;
}

uint64_t _CFXNotificationRegistrarEnumerateObserverTable(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v5 = *a2;
  if ((_DWORD)v5 != -1)
  {
    v9 = result;
    do
    {
      v10 = *(_QWORD *)(v9 + 144) + 56 * v5;
      v11 = *(unsigned int *)(v10 + 4);
      v14 = 0u;
      v15 = 0u;
      v12 = 0u;
      v13 = 0u;
      *(_QWORD *)&v13 = *(_QWORD *)(v10 + 8);
      v14 = *(_OWORD *)(v10 + 16);
      *(_QWORD *)&v12 = a3;
      *((_QWORD *)&v12 + 1) = a4;
      *((_QWORD *)&v13 + 1) = *(unsigned int *)(v10 + 44);
      *(_QWORD *)&v15 = v5 | ((unint64_t)*(unsigned int *)(v10 + 40) << 32);
      *((_QWORD *)&v15 + 1) = *(_QWORD *)(v10 + 32);
      result = (*(uint64_t (**)(uint64_t, __int128 *))(a5 + 16))(a5, &v12);
      v5 = v11;
    }
    while ((_DWORD)v11 != -1);
  }
  return result;
}

void CFXNotificationRegistrarUpdateDistributedConnections(os_unfair_lock_s *a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v4;
  _QWORD v5[8];

  v5[7] = *MEMORY[0x1E0C80C00];
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __CFXNotificationRegistrarUpdateDistributedConnections_block_invoke;
  v5[3] = &unk_1E1335B50;
  v5[5] = a1;
  v5[6] = a2;
  v5[4] = a3;
  v4 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[8], 0, (uint64_t)v5);
  _CFXNotificationRegistrarEnumerateObjectTable((uint64_t)a1, (uint64_t)&a1[12], (uint64_t)CFSTR("kCFNotificationAnyName"), (uint64_t)v5);
  _CFXNotificationRegistrarEnumerateNameTable((uint64_t)a1, (uint64_t)&a1[16], 1, (uint64_t)v5);
  _CFXNotificationRegistrarEnumerateObserverTable((uint64_t)a1, &a1[20]._os_unfair_lock_opaque, (uint64_t)CFSTR("kCFNotificationAnyName"), (uint64_t)CFSTR("kCFNotificationAnyObject"), (uint64_t)v5);
  os_unfair_lock_unlock(v4);
}

BOOL CFXNotificationRegistrarIsEmpty(os_unfair_lock_s *a1)
{
  os_unfair_lock_s *v2;
  _BOOL8 v3;

  v2 = a1 + 4;
  os_unfair_lock_lock(a1 + 4);
  v3 = a1[15]._os_unfair_lock_opaque
     + a1[11]._os_unfair_lock_opaque
     + a1[19]._os_unfair_lock_opaque
     + a1[21]._os_unfair_lock_opaque == 0;
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t _CFBundleSearchForLocalizedString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  os_unfair_lock_s *v8;
  void *v9;
  uint64_t v10;
  _QWORD v12[8];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = 0;
  v8 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  v9 = *(void **)(a1 + 144);
  if (v9)
  {
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = ___CFBundleSearchForLocalizedString_block_invoke;
    v12[3] = &unk_1E1335C00;
    v12[6] = a3;
    v12[7] = a4;
    v12[4] = &v13;
    v12[5] = a2;
    CFDictionaryApply(v9, (uint64_t)v12);
  }
  os_unfair_lock_unlock(v8);
  v10 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_182C10D70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _CFBundleCreateMappedBPlistFile()
{
  return __NSCreateBPlistMappedDataFromURL();
}

void _CFBundleFlushStringSourceCache(uint64_t a1)
{
  os_unfair_lock_s *v2;
  const void *v3;

  v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock_with_options();
  v3 = *(const void **)(a1 + 168);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 168) = 0;
  }
  os_unfair_lock_unlock(v2);
}

CFMutableDictionaryRef _CFBundleCopyFilteredLocalizedStringsForAllLocalizations(__CFBundle *a1, const __CFString *a2, uint64_t a3)
{
  const __CFArray *v6;
  CFIndex Count;
  CFMutableDictionaryRef Mutable;
  _QWORD v10[9];

  v10[8] = *MEMORY[0x1E0C80C00];
  CFBundleAllowMixedLocalizations();
  if (!a2 || CFEqual(a2, &stru_1E1337B18))
    a2 = CFSTR("Localizable");
  v6 = CFBundleCopyBundleLocalizations(a1);
  Count = CFArrayGetCount(v6);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = ___CFBundleCopyFilteredLocalizedStringsForAllLocalizations_block_invoke;
  v10[3] = &__block_descriptor_64_e13_v24__0r_v8_16l;
  v10[4] = a1;
  v10[5] = a2;
  v10[6] = a3;
  v10[7] = Mutable;
  CFArrayApply((uint64_t)v6, 0, Count, (uint64_t)v10);
  CFRelease(v6);
  return Mutable;
}

CFSetRef _CFBundleCopyLocalizationInfoDictionaryKeys()
{
  _OWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[0] = xmmword_1E1335CC0;
  v1[1] = *(_OWORD *)off_1E1335CD0;
  return CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)v1, 4, &kCFTypeSetCallBacks);
}

CFDictionaryRef _CFBundleCopyFilteredLocalizedStringsForAllLocalizationsForURL(const __CFURL *a1, const __CFString *a2, uint64_t a3, char a4)
{
  const __CFSet *v8;
  __CFBundle *UniqueWithOptions;
  CFMutableDictionaryRef v10;
  _OWORD v12[2];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!_CFBundleCouldBeBundle(a1))
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v12[0] = xmmword_1E1335CC0;
  v12[1] = *(_OWORD *)off_1E1335CD0;
  v8 = CFSetCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)v12, 4, &kCFTypeSetCallBacks);
  UniqueWithOptions = (__CFBundle *)_CFBundleCreateUniqueWithOptions((const __CFAllocator *)&__kCFAllocatorSystemDefault, a1, v8, a4);
  CFRelease(v8);
  if (!UniqueWithOptions)
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v10 = _CFBundleCopyFilteredLocalizedStringsForAllLocalizations(UniqueWithOptions, a2, a3);
  CFRelease(UniqueWithOptions);
  return v10;
}

const void *___postProcessStringsDict_block_invoke(uint64_t a1, const void *a2)
{
  const void *result;
  NSSet *v5;
  uint64_t v6;
  const __CFDictionary *v7;
  uint64_t v8;
  _QWORD v9[5];
  uint64_t v10;
  const void *v11[2];

  v11[1] = *(const void **)MEMORY[0x1E0C80C00];
  v11[0] = a2;
  result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (!result)
  {
    result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
    if (!result)
    {
      v5 = -[NSSet initWithObjects:count:]([NSSet alloc], "initWithObjects:count:", v11, 1);
      _loadStringsInOrder(*(const void **)(a1 + 48), *(void **)(a1 + 56), v5, *(CFDictionaryRef *)(a1 + 40), *(_QWORD *)(a1 + 64), 0);

      if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v11[0]))
      {
        v10 = 0;
        v6 = *(_QWORD *)(a1 + 64);
        v7 = *(const __CFDictionary **)(a1 + 40);
        v8 = *(_QWORD *)(a1 + 48);
        v9[0] = *(_QWORD *)(v6 + 88);
        v9[1] = v7;
        v9[2] = 0;
        v9[3] = v8;
        v9[4] = *(_QWORD *)(v6 + 24);
        LOBYTE(v10) = *(_BYTE *)(a1 + 72);
        CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)__CFPlatformSpecificStringDictionaryApplyFunction, v9);
        CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 40), (CFDictionaryApplierFunction)__CFLocalizedFormatStringApplyFunction, v9);
      }
      return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v11[0]);
    }
  }
  return result;
}

void __CFVariableWidthStringApplyFunction(const void *a1, const void *a2, CFMutableDictionaryRef *a3)
{
  CFTypeID TypeID;
  CFTypeID v7;
  uint64_t v8;
  const void *v9;
  CFTypeID v10;

  TypeID = CFStringGetTypeID();
  v7 = CFGetTypeID(a2);
  if (a3)
  {
    if (TypeID == v7)
    {
      if (a3[1])
      {
        if (*a3)
        {
          v8 = (*((uint64_t (**)(CFMutableDictionaryRef, const void *))*a3 + 2))(*a3, a2);
          if (v8)
          {
            v9 = (const void *)v8;
            v10 = CFStringGetTypeID();
            if (v10 == CFGetTypeID(v9))
              CFDictionarySetValue(a3[1], a1, v9);
          }
        }
      }
    }
  }
}

uint64_t (**__CFStringEncodingGetCyrillicConverterDefinition(int a1))()
{
  uint64_t (**result)();

  if (a1 > 1050)
  {
    switch(a1)
    {
      case 1051:
        return __CFConverterDOSRussian;
      case 2562:
        return __CFConverterKOI8R;
      case 1282:
        return __CFConverterWinCyrillic;
    }
    return 0;
  }
  result = __CFConverterMacCyrillic;
  if (a1 != 7 && a1 != 152)
  {
    if (a1 == 517)
      return __CFConverterISOCyrillic;
    return 0;
  }
  return result;
}

uint64_t __CFToMacCyrillic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8806 < 0xFFFFDE3A)
    return 0;
  v5 = (unsigned __int16 *)&maccyrillic_from_uni;
  v6 = (unsigned __int16 *)&unk_182DC7E3C;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromMacCyrillic(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    LOWORD(a2) = maccyrillic_to_uni[a2 - 128];
  *a3 = a2;
  return 1;
}

uint64_t __CFToMacCyrillicPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFPrecomposeCyrillicCharacter(a2);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8806) >= 0xDE3Au)
    {
      v11 = (unsigned __int16 *)&maccyrillic_from_uni;
      v12 = (unsigned __int16 *)&unk_182DC7E3C;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

BOOL __CFIsValidCombiningCharacterForCyrillic(int a1)
{
  uint64_t v1;

  if ((a1 - 768) > 0xE)
    return a1 == 824;
  v1 = 1;
  if (((1 << ~(_BYTE)a1) & 0xCA800000) == 0)
    return a1 == 824;
  return v1;
}

uint64_t __CFPrecomposeCyrillicCharacter(unsigned __int16 *a1)
{
  unsigned int v1;
  unsigned int *v2;
  unsigned int *v3;
  uint64_t v4;
  unsigned int *v5;

  v1 = a1[1] | (*a1 << 16);
  if (v1 - 82379529 < 0xFB54002F)
    return 65533;
  v2 = (unsigned int *)&__CFCyrillicPrecompMap;
  v3 = (unsigned int *)&unk_182DC80E0;
  while (1)
  {
    v4 = ((char *)v3 - (char *)v2) >> 4;
    v5 = &v2[2 * v4];
    if (*v5 <= v1)
      break;
    v3 = v5 - 2;
LABEL_7:
    if (v2 > v3)
      return 65533;
  }
  if (*v5 < v1)
  {
    v2 = v5 + 2;
    goto LABEL_7;
  }
  return LOWORD(v2[2 * v4 + 1]);
}

uint64_t __CFToWinCyrillic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;

  if (a2 < 0x80)
  {
LABEL_4:
    *a3 = a2;
    return 1;
  }
  else
  {
    if ((unsigned __int16)(a2 - 1040) <= 0x3Fu)
    {
      LOBYTE(a2) = a2 - 80;
      goto LABEL_4;
    }
    if ((unsigned __int16)(a2 - 8483) >= 0xDF7Du)
    {
      v4 = (unsigned __int16 *)&cp1251_from_uni;
      v5 = (unsigned __int16 *)&unk_182DC81E0;
      do
      {
        v6 = ((char *)v5 - (char *)v4) >> 3;
        v7 = &v4[2 * v6];
        v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_4;
          }
          v4 = v7 + 2;
        }
        else
        {
          v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
}

BOOL __CFFromWinCyrillic(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
  {
    if (a2 < 0xC0)
      a2 = cp1251_to_uni[a2 - 128];
    else
      a2 += 848;
  }
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinCyrillicPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  int v10;
  uint64_t result;
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v9 = __CFPrecomposeCyrillicCharacter(a2);
  v10 = __CFToWinCyrillic(v9, v9, &v12);
  result = 0;
  if (v10 && v12)
  {
    if (a5)
      *a4 = v12;
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFToISOCyrillic(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  uint64_t result;

  if (a2 < 0xA1)
    goto LABEL_12;
  switch(a2)
  {
    case 0xA7u:
      LOBYTE(a2) = -3;
      goto LABEL_12;
    case 0x2116u:
      LOBYTE(a2) = -16;
      goto LABEL_12;
    case 0xADu:
LABEL_12:
      *a3 = a2;
      return 1;
  }
  if (a2 - 1025 > 0x5E)
    return 0;
  result = 0;
  if (a2 != 1037 && a2 != 1104 && a2 != 1117)
  {
    LOBYTE(a2) = a2 - 96;
    goto LABEL_12;
  }
  return result;
}

uint64_t __CFFromISOCyrillic(uint64_t a1, unsigned int a2, __int16 *a3)
{
  __int16 v3;
  __int16 v4;

  v3 = a2 + 864;
  if (a2 == 253)
    v3 = 167;
  if (a2 == 240)
    v4 = 8470;
  else
    v4 = v3;
  if (a2 == 173)
    v4 = 173;
  if (a2 < 0xA1)
    v4 = a2;
  *a3 = v4;
  return 1;
}

uint64_t __CFToISOCyrillicPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  int v10;
  uint64_t result;
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v9 = __CFPrecomposeCyrillicCharacter(a2);
  v10 = __CFToISOCyrillic(v9, v9, &v12);
  result = 0;
  if (v10 && v12)
  {
    if (a5)
      *a4 = v12;
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFToKOI8R(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF)
    return 0;
  v5 = (unsigned __int16 *)&koi8r_from_uni;
  v6 = (unsigned __int16 *)&unk_182DC8460;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromKOI8R(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    LOWORD(a2) = koi8r_to_uni[a2 - 128];
  *a3 = a2;
  return 1;
}

uint64_t __CFToDOSRussian(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF)
    return 0;
  v5 = (unsigned __int16 *)&DOSRussian_from_uni;
  v6 = (unsigned __int16 *)&unk_182DC8760;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSRussian(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = DOSRussian_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSRussianPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFPrecomposeCyrillicCharacter(a2);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      v11 = (unsigned __int16 *)&DOSRussian_from_uni;
      v12 = (unsigned __int16 *)&unk_182DC8760;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

void sub_182C1209C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182C147E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  free(v2);
  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C15140(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void OUTLINED_FUNCTION_0_31(objc_class *a1)
{
  uint64_t v1;

  __CFRequireConcreteImplementation(a1, v1);
}

objc_class *_CFStringCreateWithWidthContexts(uint64_t a1)
{
  objc_class *result;

  result = (objc_class *)__NSVariableWidthStringClass;
  if (__NSVariableWidthStringClass)
    return (objc_class *)objc_msgSend([result alloc], "initWithWidthContexts:", a1);
  result = __CFLookUpClass("__NSVariableWidthString");
  __NSVariableWidthStringClass = (uint64_t)result;
  if (result)
    return (objc_class *)objc_msgSend([result alloc], "initWithWidthContexts:", a1);
  return result;
}

const __CFString *_CFStringFindAffixRuleFormat(const void *a1, CFStringRef theString)
{
  const __CFString *v4;
  CFIndex Length;
  unsigned int CharacterAtIndex;
  CFCharacterSetRef v7;
  CFCharacterSetRef v8;
  int IsCharacterMember;
  const __CFString *v10;
  const __CFString *v11;
  uint64_t v13;
  int v14;
  const __CFString *v15;
  BOOL v16;
  unsigned int v17[10];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (CFStringGetLength(theString) < 2)
    return 0;
  Length = CFStringGetLength(theString);
  CharacterAtIndex = CFStringGetCharacterAtIndex(theString, Length - 1);
  if (CFEqual(a1, CFSTR("fi")))
  {
    v7 = CFCharacterSetCreateWithCharactersInString(0, CFSTR("aeiouy"));
    v8 = CFCharacterSetCreateWithCharactersInString(0, CFSTR("bcdfghjklmnpqrstvwxz"));
    if (CFCharacterSetIsCharacterMember(v7, CharacterAtIndex))
    {
      v4 = CFSTR("vowel");
LABEL_16:
      CFRelease(v7);
      CFRelease(v8);
      return v4;
    }
    IsCharacterMember = CFCharacterSetIsCharacterMember(v8, CharacterAtIndex);
    v10 = CFSTR("consonant");
    v11 = CFSTR("other");
    goto LABEL_13;
  }
  if (CFEqual(a1, CFSTR("ru")))
  {
    v7 = CFCharacterSetCreateWithCharactersInString(0, CFSTR(""));
    v8 = CFCharacterSetCreateWithCharactersInString(0, CFSTR(""));
    v4 = CFSTR("other");
    if ((unsigned __int16)((unsigned __int16)(CharacterAtIndex - 1104) >> 6) < 0x3FFu
      || CharacterAtIndex == 1068
      || CharacterAtIndex == 1100)
    {
      goto LABEL_16;
    }
    if (CFCharacterSetIsCharacterMember(v7, CharacterAtIndex))
    {
      v4 = CFSTR("neuter");
      goto LABEL_16;
    }
    IsCharacterMember = CFCharacterSetIsCharacterMember(v8, CharacterAtIndex);
    v10 = CFSTR("feminine");
    v11 = CFSTR("masculine");
LABEL_13:
    if (IsCharacterMember)
      v4 = v10;
    else
      v4 = v11;
    goto LABEL_16;
  }
  if (!CFEqual(a1, CFSTR("ko")))
    return 0;
  v13 = CFUniCharDecomposeCharacter(CharacterAtIndex, v17, 10);
  if (v13 < 1)
  {
    v15 = 0;
  }
  else
  {
    v14 = LOWORD(v17[v13 - 1]);
    if ((v14 - 4449) >= 0x47)
    {
      v16 = (v14 - 4520) >= 0x58 && (v14 - 4352) >= 0x5F;
      v15 = CFSTR("consonant");
      if (v16)
        v15 = 0;
    }
    else
    {
      v15 = CFSTR("vowel");
    }
  }
  if (v15)
    return v15;
  else
    return CFSTR("other");
}

uint64_t _CFStringCreateWithMarkdownAndConfiguration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (__NSGetCFLocalizedAttributedStringClass_onceToken != -1)
    dispatch_once(&__NSGetCFLocalizedAttributedStringClass_onceToken, &__block_literal_global_96_0);
  return objc_msgSend((id)__NSCFLocalizedAttributedStringClass, "copyStringWithMarkdown:formatConfiguration:bundle:tableURL:", a1, a2, a3, a4);
}

uint64_t _CFStringCreateFormatWithInflectionAndArguments(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend((id)__NSCFLocalizedAttributedStringClass, "createStringRequiringInflectionWithFormat:formatOptions:arguments:", a3, a2, a4);
}

xpc_object_t _CFXPCCreateXPCObjectFromOutOfRangeCFTimeInterval(double a1)
{
  xpc_object_t v1;
  void *v2;
  void *v3;
  xpc_object_t v4;
  xpc_object_t v6;
  void *v7;
  xpc_object_t values[2];
  char *keys[2];
  uuid_t uu;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v1 = xpc_double_create(a1);
  if (!v1)
    return 0;
  v2 = v1;
  memset(uu, 0, sizeof(uu));
  if (uuid_parse("C119A421-DF31-48EF-843D-21B4030D1621", uu) || (v6 = xpc_uuid_create(uu)) == 0)
  {
    v3 = v2;
LABEL_4:
    xpc_release(v3);
    return 0;
  }
  v7 = v6;
  keys[0] = "com.apple.CFDate.magic";
  keys[1] = "com.apple.CFDate.ti";
  values[0] = v6;
  values[1] = v2;
  v4 = xpc_dictionary_create((const char *const *)keys, values, 2uLL);
  xpc_release(v2);
  xpc_release(v7);
  if (v4 && xpc_dictionary_get_count(v4) != 2)
  {
    v3 = v4;
    goto LABEL_4;
  }
  return v4;
}

CFTypeID CFFileSecurityGetTypeID(void)
{
  return 64;
}

CFFileSecurityRef CFFileSecurityCreate(CFAllocatorRef allocator)
{
  CFFileSecurityRef result;
  _filesec *v2;

  result = filesec_init();
  if (result)
  {
    v2 = result;
    result = -[NSFileSecurity initWithFileSec:]([NSFileSecurity alloc], "initWithFileSec:", result);
    if (!result)
    {
      filesec_free(v2);
      return 0;
    }
  }
  return result;
}

Boolean CFFileSecurityCopyOwnerUUID(CFFileSecurityRef fileSec, CFUUIDRef *ownerUUID)
{
  const __CFUUID *v4;
  const __CFAllocator *v5;
  CFUUIDBytes v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v7.byte0 = 0;
  *(_QWORD *)&v7.byte8 = 0;
  LODWORD(v4) = -[__CFFileSecurity getOwnerUUID:](fileSec, "getOwnerUUID:", &v7);
  if ((_DWORD)v4)
  {
    v5 = CFGetAllocator(fileSec);
    v4 = CFUUIDCreateFromUUIDBytes(v5, v7);
    if (v4)
    {
      *ownerUUID = v4;
      LOBYTE(v4) = 1;
    }
  }
  return v4;
}

Boolean CFFileSecuritySetOwnerUUID(CFFileSecurityRef fileSec, CFUUIDRef ownerUUID)
{
  CFUUIDBytes v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v4 = CFUUIDGetUUIDBytes(ownerUUID);
  return -[__CFFileSecurity setOwnerUUID:](fileSec, "setOwnerUUID:", &v4);
}

Boolean CFFileSecurityCopyGroupUUID(CFFileSecurityRef fileSec, CFUUIDRef *groupUUID)
{
  const __CFUUID *v4;
  const __CFAllocator *v5;
  CFUUIDBytes v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v7.byte0 = 0;
  *(_QWORD *)&v7.byte8 = 0;
  LODWORD(v4) = -[__CFFileSecurity getGroupUUID:](fileSec, "getGroupUUID:", &v7);
  if ((_DWORD)v4)
  {
    v5 = CFGetAllocator(fileSec);
    v4 = CFUUIDCreateFromUUIDBytes(v5, v7);
    if (v4)
    {
      *groupUUID = v4;
      LOBYTE(v4) = 1;
    }
  }
  return v4;
}

Boolean CFFileSecuritySetGroupUUID(CFFileSecurityRef fileSec, CFUUIDRef groupUUID)
{
  CFUUIDBytes v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v4 = CFUUIDGetUUIDBytes(groupUUID);
  return -[__CFFileSecurity setGroupUUID:](fileSec, "setGroupUUID:", &v4);
}

Boolean CFFileSecuritySetAccessControlList(CFFileSecurityRef fileSec, acl_t accessControlList)
{
  return -[__CFFileSecurity setAccessControlList:](fileSec, "setAccessControlList:", accessControlList);
}

Boolean CFFileSecuritySetOwner(CFFileSecurityRef fileSec, uid_t owner)
{
  return -[__CFFileSecurity setOwner:](fileSec, "setOwner:", *(_QWORD *)&owner);
}

Boolean CFFileSecuritySetGroup(CFFileSecurityRef fileSec, gid_t group)
{
  return -[__CFFileSecurity setGroup:](fileSec, "setGroup:", *(_QWORD *)&group);
}

Boolean CFFileSecuritySetMode(CFFileSecurityRef fileSec, mode_t mode)
{
  return -[__CFFileSecurity setMode:](fileSec, "setMode:", mode);
}

Boolean CFFileSecurityClearProperties(CFFileSecurityRef fileSec, CFFileSecurityClearOptions clearPropertyMask)
{
  return -[__CFFileSecurity clearProperties:](fileSec, "clearProperties:", clearPropertyMask);
}

uint64_t CFBurstTrieInsert(unint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, int a5)
{
  return CFBurstTrieAddWithWeight(a1, a2, a3, a4, 1, a5);
}

uint64_t CFBurstTrieAddWithWeight(unint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, int a5, int a6)
{
  uint64_t v6;
  CFIndex v13;
  UInt8 *v14;
  CFIndex v15;
  CFIndex usedBufLen;
  _BYTE v18[343];
  uint64_t v19;
  CFRange v20;

  v6 = 0;
  v19 = *MEMORY[0x1E0C80C00];
  if (a6 && !*(_QWORD *)(a1 + 2056) && a4 <= 1023)
  {
    usedBufLen = 0;
    if (a4 < 86)
    {
      v13 = 342;
      v14 = v18;
    }
    else
    {
      v13 = 4 * a4;
      v14 = (UInt8 *)malloc_type_malloc((4 * a4) | 1, 0xCB444817uLL);
    }
    v20.location = a3;
    v20.length = a4;
    CFStringGetBytes(a2, v20, 0x8000100u, 0x2Du, 0, v14, v13, &usedBufLen);
    v15 = usedBufLen;
    v14[usedBufLen] = 0;
    v6 = CFBurstTrieAddUTF8StringWithWeight(a1, (uint64_t)v14, v15, a5, a6);
    if (v18 != v14)
      free(v14);
  }
  return v6;
}

uint64_t CFBurstTrieAdd(unint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, int a5)
{
  return CFBurstTrieAddWithWeight(a1, a2, a3, a4, 1, a5);
}

uint64_t CFBurstTrieInsertCharacters(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddCharactersWithWeight(a1, a2, a3, 1, a4);
}

uint64_t CFBurstTrieAddCharactersWithWeight(unint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  _BYTE *v11;
  uint64_t v12;
  _BYTE v14[343];
  uint64_t v15;

  v5 = 0;
  v15 = *MEMORY[0x1E0C80C00];
  if (a5 && a3 <= 1023 && !*(_QWORD *)(a1 + 2056))
  {
    v11 = v14;
    if (a3 >= 86)
      v11 = malloc_type_malloc((4 * a3) | 1, 0xD5BE4744uLL);
    v12 = burstTrieConvertCharactersToUTF8(a2, a3, (uint64_t)v11);
    v11[v12] = 0;
    v5 = CFBurstTrieAddUTF8StringWithWeight(a1, (uint64_t)v11, v12, a4, a5);
    if (v14 != v11)
      free(v11);
  }
  return v5;
}

uint64_t CFBurstTrieAddCharacters(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddCharactersWithWeight(a1, a2, a3, 1, a4);
}

uint64_t CFBurstTrieInsertUTF8String(unint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  return CFBurstTrieAddUTF8StringWithWeight(a1, a2, a3, 1, a4);
}

uint64_t CFBurstTrieFind(uint64_t a1, const __CFString *a2, CFIndex a3, CFIndex a4, _QWORD *a5)
{
  uint64_t result;
  unsigned int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v7 = 0;
  result = CFBurstTrieContains(a1, a2, a3, a4, &v7);
  if ((_DWORD)result)
  {
    if (a5)
      *a5 = v7;
    return 1;
  }
  return result;
}

uint64_t CFBurstTrieFindCharacters(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t result;
  unsigned int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  result = CFBurstTrieContainsCharacters(a1, a2, a3, &v6);
  if ((_DWORD)result)
  {
    if (a4)
      *a4 = v6;
    return 1;
  }
  return result;
}

uint64_t CFBurstTrieFindUTF8String(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t result;
  unsigned int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  result = CFBurstTrieContainsUTF8String(a1, a2, a3, &v6);
  if ((_DWORD)result)
  {
    if (a4)
      *a4 = v6;
    return 1;
  }
  return result;
}

uint64_t burstTrieMappedFind(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, char a6)
{
  int v6;
  char *v7;
  int v8;
  int v9;

  if (a4)
  {
    v6 = 1 - a4;
    v7 = (char *)(a3 + 1);
    while (1)
    {
      v8 = *(_DWORD *)(a1 + 4 * *(v7 - 1));
      v9 = v8 & 3;
      if (v9 != 1)
        break;
      a1 = (v8 & 0xFFFFFFFC) + a2;
      ++v6;
      ++v7;
      if (v6 == 1)
        goto LABEL_5;
    }
    if (v9 != 2)
    {
      if (v9 == 3)
        return burstTrieCompactTrieMappedFind((int8x8_t *)((v8 & 0xFFFFFFFC) + a2), a2, v7, -v6, a5, a6);
      return 0;
    }
    return burstTrieMappedPageFind((unsigned int *)((v8 & 0xFFFFFFFC) + a2), v7, -v6, a5, a6);
  }
  else
  {
LABEL_5:
    if (!*(_DWORD *)(a1 + 1024))
      return 0;
    if (a5)
      *a5 = *(_DWORD *)(a1 + 1028);
    return 1;
  }
}

uint64_t CFBurstTrieSerialize(uint64_t a1, CFStringRef theString, int a3)
{
  uint64_t v3;
  uint64_t v7;
  int v8;
  char buffer[1024];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 2056))
    return 0;
  if (!CFStringGetCString(theString, buffer, 1024, 0x8000100u))
    return 0;
  v7 = open(buffer, 1538, 384);
  if ((v7 & 0x80000000) != 0)
    return 0;
  v8 = v7;
  v3 = CFBurstTrieSerializeWithFileDescriptor(a1, v7, a3);
  close(v8);
  return v3;
}

uint64_t CFBurstTrieSerializeWithFileDescriptor(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  off_t v7;
  int v8;
  int v10;
  uint64_t __buf;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;

  v3 = 0;
  v24 = *MEMORY[0x1E0C80C00];
  if ((a2 & 0x80000000) == 0 && !*(_QWORD *)(a1 + 2056))
  {
    v7 = lseek(a2, 0, 2);
    *(_DWORD *)(a1 + 2072) = a3;
    v23 = 0;
    v22 = 0u;
    v21 = 0u;
    v20 = 0u;
    v19 = 0u;
    v18 = 0u;
    v17 = 0u;
    v16 = 0u;
    __buf = 14531089;
    v12 = *(_DWORD *)(a1 + 2076);
    v13 = 0;
    v14 = a3;
    v15 = 0;
    lseek(a2, v7, 0);
    write(a2, &__buf, 0x94uLL);
    serializeCFBurstTrieLists(a1, a1, v7, a2);
    v3 = 1;
    v10 = lseek(a2, 0, 1) - v7;
    pwrite(a2, &v10, 4uLL, v7 + 4);
    serializeCFBurstTrieLevels(a1, (_DWORD *)a1, &v10, v7, 0, 1, a2);
    pwrite(a2, &v10, 4uLL, v7 + 12);
    v8 = lseek(a2, 0, 2);
    *(_DWORD *)(a1 + 2064) = v8 - v7;
    *(_QWORD *)(a1 + 2056) = mmap(0, (v8 - v7), 1, 1, a2, v7);
  }
  return v3;
}

uint64_t CFBurstTrieTraverse(uint64_t result)
{
  int *v1;
  int v2;

  v1 = *(int **)(result + 2056);
  if (!v1)
    return traverseCFBurstTrieWithCursor(result, (uint64_t)"");
  v2 = *v1;
  if (v2 == 14531089 || v2 == -889275714)
    return traverseCFBurstTrieWithCursor(result, (uint64_t)"");
  return result;
}

uint64_t foundKey(_QWORD *a1)
{
  void (*v1)(void);

  if (a1)
  {
    if (*a1)
    {
      v1 = (void (*)(void))a1[1];
      if (v1)
        v1();
    }
  }
  return 0;
}

size_t CFBurstTrieTraverseWithCursor(uint64_t a1, uint64_t a2)
{
  return traverseCFBurstTrieWithCursor(a1, a2);
}

uint64_t CFBurstTrieGetCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 2076);
}

char *CFBurstTrieCursorCreateByCopy(char *result)
{
  char *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    result = (char *)malloc_type_calloc(0x21uLL, 1uLL, 0xDCBD4FD0uLL);
    v2 = *(_QWORD *)(v1 + 17);
    if (v2 == 1)
    {
      result[16] = v1[16];
      *(_OWORD *)result = *(_OWORD *)v1;
    }
    else if (!v2)
    {
      CFBurstTrieCursorCreateByCopy_cold_1();
    }
    *(_QWORD *)(result + 17) = v2;
    *(_QWORD *)(result + 25) = *(_QWORD *)(v1 + 25);
  }
  return result;
}

BOOL CFBurstTrieCursorIsEqual(uint64_t a1, uint64_t a2)
{
  BOOL v2;

  if (*(_QWORD *)(a1 + 25) == *(_QWORD *)(a2 + 25)
    && (*(_QWORD *)(a1 + 17) == 1 ? (v2 = *(_QWORD *)(a2 + 17) == 1) : (v2 = 0),
        v2
     && *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4)
     && *(unsigned __int8 *)(a1 + 16) == *(unsigned __int8 *)(a2 + 16)
     && *(_DWORD *)a1 == *(_DWORD *)a2))
  {
    return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
  }
  else
  {
    return 0;
  }
}

void CFBurstTrieTraverseFromCursor(__int128 *a1)
{
  void *v2;
  __int128 v3;
  char v4;
  char v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = malloc_type_calloc(1uLL, 0x1000uLL, 0x48558A54uLL);
    v5 = 0;
    if (*(_QWORD *)((char *)a1 + 17) == 1)
    {
      v4 = *((_BYTE *)a1 + 16);
      v3 = *a1;
      traverseFromMapCursor(*(_QWORD *)((char *)a1 + 25), (uint64_t)&v3);
    }
    free(v2);
  }
}

void traverseFromMapCursor(uint64_t a1, uint64_t a2)
{
  __asm { BR              X11 }
}

uint64_t sub_182C17AAC@<X0>(int a1@<W8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__dst,void *__s2,size_t __n,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t result;
  uint64_t v35;
  uint64_t (*v36)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  _BYTE *v37;

  if (a1 == *(_DWORD *)(*(_QWORD *)(v33 + 2056) + 4))
    return traverseFromMapCursorMappedLevel(v33, v32, v29, v30, v31, v37, v35, v36);
  return result;
}

uint64_t traverseCFBurstTrieMappedLevel(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t))
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  _BYTE *v22;
  _DWORD *v23;

  v11 = result;
  v12 = 0;
  v13 = a3[6];
  v14 = (char *)a3 + v13 + 36;
  *v14 = 0;
  v15 = (v13 + 1);
  v22 = (char *)a3 + v15 + 36;
  v23 = a3 + 9;
  while (1)
  {
    v16 = *(_DWORD *)(a2 + 4 * v12);
    a3[6] = v15;
    *v14 = v12;
    v17 = v16 & 3;
    if (v17 == 3)
      break;
    if (v17 == 2)
    {
      a3[4] = v16;
      *v22 = 0;
      result = findCFBurstTrieMappedPage(v11, (uint64_t)a3, a5, a6);
    }
    else if (v17 == 1)
    {
      v18 = *(_QWORD *)(v11 + 2056) + (v16 & 0xFFFFFFFC);
      v19 = v15;
      if (*(_DWORD *)(v18 + 1024))
      {
        result = a6(a5, (uint64_t)v23);
        if ((result & 1) != 0)
          return result;
        v19 = a3[6];
      }
      if (v19 == a3[5] && (a4 & 1) != 0)
        return result;
      result = traverseCFBurstTrieMappedLevel(v11, v18, a3, a4, a5, a6);
    }
LABEL_18:
    if (++v12 == 256)
      return result;
  }
  v20 = *(_QWORD *)(v11 + 2056) + (v16 & 0xFFFFFFFC);
  v21 = v15;
  if (*(_DWORD *)(v20 + 32))
  {
    result = a6(a5, (uint64_t)v23);
    if ((result & 1) != 0)
      return result;
    v21 = a3[6];
  }
  if (v21 != a3[5] || (a4 & 1) == 0)
  {
    result = traverseCFBurstTrieCompactMappedLevel(v11, v20, a3, a4, a5, a6);
    goto LABEL_18;
  }
  return result;
}

uint64_t traverseCFBurstTrieCompactMappedLevel(uint64_t result, int8x8_t *a2, _DWORD *a3, unsigned int a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t))
{
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  int8x8_t v16;
  int v17;
  int8x8_t *v18;
  int8x8_t v19;
  uint8x8_t v20;
  uint8x8_t v21;
  __int32 v22;
  int v23;
  uint64_t v24;
  int v25;
  _DWORD *v26;
  _BYTE *v27;

  v10 = result;
  v11 = 0;
  v12 = a3[6];
  v13 = (char *)a3 + v12 + 36;
  *v13 = 0;
  v14 = (v12 + 1);
  v26 = a3 + 9;
  v27 = (char *)a3 + v14 + 36;
  while (1)
  {
    if (v11 >> 6 <= 1)
      v15 = 1;
    else
      v15 = v11 >> 6;
    v16 = a2[v11 >> 6];
    a3[6] = v12;
    if ((*(_QWORD *)&v16 & (1 << v11)) == 0)
      goto LABEL_21;
    if (v11 >= 0x40)
    {
      v17 = 0;
      v18 = a2;
      do
      {
        v19 = *v18++;
        v20 = (uint8x8_t)vcnt_s8(v19);
        v20.i16[0] = vaddlv_u8(v20);
        v17 += v20.i32[0];
        --v15;
      }
      while (v15);
    }
    else
    {
      v17 = 0;
    }
    v21 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)&v16 & ((1 << v11) - 1)));
    v21.i16[0] = vaddlv_u8(v21);
    v22 = a2[4].i32[v17 + v21.i32[0] + 1];
    a3[6] = v14;
    *v13 = v11;
    v23 = v22 & 3;
    if (v23 == 1)
    {
      result = traverseCFBurstTrieMappedLevel(v10, *(_QWORD *)(v10 + 2056) + (v22 & 0xFFFFFFFC), a3, a4, a5, a6);
      goto LABEL_21;
    }
    if (v23 == 2)
    {
      a3[4] = v22;
      *v27 = 0;
      result = findCFBurstTrieMappedPage(v10, (uint64_t)a3, a5, a6);
      goto LABEL_21;
    }
    if (v23 == 3)
      break;
LABEL_21:
    if ((_DWORD)++v11 == 256)
      return result;
  }
  v24 = *(_QWORD *)(v10 + 2056) + (v22 & 0xFFFFFFFC);
  v25 = v12 + 1;
  if (*(_DWORD *)(v24 + 32))
  {
    result = a6(a5, (uint64_t)v26);
    if ((result & 1) != 0)
      return result;
    v25 = a3[6];
  }
  if (v25 != a3[5] || (a4 & 1) == 0)
  {
    result = traverseCFBurstTrieCompactMappedLevel(v10, v24, a3, a4, a5, a6);
    goto LABEL_21;
  }
  return result;
}

uint64_t traverseCFBurstTrieLevel(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  int v18;
  uint64_t v19;

  v9 = result;
  v10 = 0;
  v11 = *(unsigned int *)(a2 + 24);
  v12 = (_BYTE *)(a2 + 40 + v11);
  *v12 = 0;
  v13 = (v11 + 1);
  v19 = a2 + 40;
  v14 = (_BYTE *)(a2 + 40 + v13);
  while (1)
  {
    v15 = *(_QWORD *)(v9 + 8 * v10);
    *(_DWORD *)(a2 + 24) = v13;
    *v12 = v10;
    if ((v15 & 3) == 2)
    {
      *(_QWORD *)(a2 + 16) = v15;
      *v14 = 0;
      result = findCFBurstTrieList(a2, a4, a5);
      goto LABEL_11;
    }
    if ((v15 & 3) == 1)
      break;
LABEL_11:
    if (++v10 == 256)
      return result;
  }
  v16 = v15 & 0xFFFFFFFFFFFFFFFCLL;
  v17 = *(_DWORD *)((v15 & 0xFFFFFFFFFFFFFFFCLL) + 2052);
  v18 = v13;
  if (v17)
  {
    result = a5(a4, v19);
    if ((result & 1) != 0)
      return result;
    v18 = *(_DWORD *)(a2 + 24);
  }
  if (v18 != *(_DWORD *)(a2 + 28) || (a3 & 1) == 0)
  {
    result = traverseCFBurstTrieLevel(v16, a2, a3, a4, a5);
    goto LABEL_11;
  }
  return result;
}

uint64_t traverseFromMapCursorMappedLevel(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, _BYTE *a6, uint64_t a7, uint64_t (*a8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))
{
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t (*v15)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;

  v21 = (*(_DWORD *)a2 & 0xFFFFFFFC) + *(_QWORD *)(result + 2056);
  v22 = result;
  v12 = *(unsigned int *)(v21 + 1024);
  v13 = a5;
  if ((_DWORD)v12)
  {
    v14 = a7;
    v15 = a8;
    result = a8(a7, a3, a5, v12, a6);
    if (v13 >= a4)
      return result;
    LODWORD(a5) = v13;
    v16 = a4;
    if (*a6)
      return result;
  }
  else
  {
    v14 = a7;
    v15 = a8;
    v16 = a4;
    if (a5 >= a4)
      return result;
  }
  v17 = 0;
  v18 = a5;
  do
  {
    *(_BYTE *)(a3 + v18) = v17;
    *(_DWORD *)a2 = *(_DWORD *)(v21 + 4 * v17);
    if (v17)
      v19 = v13 + 1;
    else
      v19 = v13;
    *(_QWORD *)(a2 + 4) = 0;
    *(_QWORD *)(a2 + 9) = 0;
    result = traverseFromMapCursor(v22, a2, a3, v16 - (v17 != 0), v19, a6, v14, v15);
    if (*a6)
      break;
  }
  while (v17++ != 255);
  return result;
}

uint64_t burstTrieCompactTrieMappedFind(int8x8_t *a1, uint64_t a2, char *a3, int a4, _DWORD *a5, char a6)
{
  unint64_t v6;
  uint64_t v7;
  int8x8_t v8;
  uint64_t v9;
  int v10;
  int8x8_t *v11;
  int8x8_t v12;
  uint8x8_t v13;
  uint8x8_t v14;
  __int32 v15;
  int v16;

  if (a4)
  {
    do
    {
      v6 = *a3;
      v7 = v6 >> 6;
      v8 = a1[v6 >> 6];
      v9 = 1 << v6;
      if (((1 << v6) & *(_QWORD *)&v8) == 0)
        return 0;
      if (v6 >= 0x40)
      {
        v10 = 0;
        if (v7 <= 1)
          v7 = 1;
        else
          v7 = v7;
        v11 = a1;
        do
        {
          v12 = *v11++;
          v13 = (uint8x8_t)vcnt_s8(v12);
          v13.i16[0] = vaddlv_u8(v13);
          v10 += v13.i32[0];
          --v7;
        }
        while (v7);
      }
      else
      {
        v10 = 0;
      }
      v14 = (uint8x8_t)vcnt_s8((int8x8_t)((v9 - 1) & *(_QWORD *)&v8));
      v14.i16[0] = vaddlv_u8(v14);
      v15 = a1[5].i32[v10 + v14.i32[0]];
      v16 = v15 & 3;
      if (v16 != 3)
      {
        if (v16 == 1)
          return burstTrieMappedFind((v15 & 0xFFFFFFFC) + a2, a2, a3 + 1, (a4 - 1));
        if (v16 != 2)
          return 0;
        return burstTrieMappedPageFind((unsigned int *)((v15 & 0xFFFFFFFC) + a2), a3 + 1, (a4 - 1), a5, a6);
      }
      a1 = (int8x8_t *)((v15 & 0xFFFFFFFC) + a2);
      ++a3;
    }
    while (--a4);
  }
  if (!a1[4].i32[0])
    return 0;
  if (a5)
    *a5 = a1[4].i32[1];
  return 1;
}

uint64_t burstTrieMappedPageFind(unsigned int *a1, char *__s2, size_t __n, _DWORD *a4, char a5)
{
  unsigned int v6;
  unsigned int v9;
  unsigned int v10;
  char *v11;
  size_t v12;
  char *v13;
  unsigned int v14;
  int v15;
  size_t v16;
  unsigned int v17;
  char *v18;
  char *v19;
  int v20;
  int v21;
  int v23;
  _BYTE v24[256];
  uint64_t v25;

  v6 = __n;
  v25 = *MEMORY[0x1E0C80C00];
  v9 = *a1;
  if ((a5 & 1) != 0)
  {
    if (v9)
    {
      v10 = 0;
      while (1)
      {
        v11 = (char *)a1 + v10;
        v14 = v11[4];
        v13 = v11 + 4;
        v12 = v14;
        v15 = (unsigned __int16)(*(_WORD *)(v13 + 1) + v14);
        if (v15 == v6 && !memcmp(v24, __s2, v12) && !memcmp(v13 + 7, &__s2[v12], v6 - v12))
          break;
        if ((v12 ^ 0xFF) >= v6 - v12)
          v16 = v6 - v12;
        else
          v16 = v12 ^ 0xFF;
        memcpy(&v24[v12], v13 + 7, v16);
        v10 = v10 - v12 + v15 + 7;
        if (v10 >= v9)
          return 0;
      }
      if (!a4)
        return 1;
      v23 = *(_DWORD *)(v13 + 3);
LABEL_23:
      *a4 = v23;
      return 1;
    }
  }
  else if (v9)
  {
    v17 = 0;
    while (1)
    {
      v18 = (char *)a1 + v17;
      v21 = *((unsigned __int16 *)v18 + 2);
      v19 = v18 + 4;
      v20 = v21;
      if (v21 == v6 && !memcmp(v19 + 6, __s2, v6))
        break;
      v17 += v20 + 6;
      if (v17 >= v9)
        return 0;
    }
    if (!a4)
      return 1;
    v23 = *(_DWORD *)(v19 + 2);
    goto LABEL_23;
  }
  return 0;
}

void serializeCFBurstTrieLists(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t i;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  _QWORD *v12;

  for (i = 0; i != 256; ++i)
  {
    v9 = *(_QWORD *)(a2 + 8 * i);
    if ((v9 & 3) == 2)
    {
      v10 = (_QWORD *)(v9 & 0xFFFFFFFFFFFFFFFCLL);
      v11 = lseek(a4, 0, 1);
      serializeCFBurstTrieList(a1, (uint64_t)v10);
      do
      {
        v12 = (_QWORD *)*v10;
        free(v10);
        v10 = v12;
      }
      while (v12);
      *(_QWORD *)(a2 + 8 * i) = (v11 - a3) | 2;
    }
    else if ((v9 & 3) == 1)
    {
      serializeCFBurstTrieLists(a1, v9 & 0xFFFFFFFFFFFFFFFCLL, a3, a4);
    }
  }
}

uint64_t serializeCFBurstTrieLevels(uint64_t a1, _DWORD *a2, int *a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  uint64_t v13;
  int32x4_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  size_t v24;
  uint64_t v25;
  int8x16_t *v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  __int8 *v31;
  int v32;
  int v33;
  uint64_t v34;
  size_t v35;
  int v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  _DWORD v42[260];
  uint64_t v43;

  v13 = 0;
  v43 = *MEMORY[0x1E0C80C00];
  v14 = 0uLL;
  do
  {
    v14 = vsubq_s32(v14, (int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64(*(int64x2_t *)&a2[v13]), (int32x4_t)vceqzq_s64(*(int64x2_t *)&a2[v13 + 4]))));
    v13 += 8;
  }
  while (v13 != 512);
  v15 = vaddvq_s32(v14);
  v16 = *a3;
  if ((*(_BYTE *)(a1 + 2072) & 4) == 0 || v15 > 0xC7)
    a6 = 1;
  v38 = a6;
  v39 = v16;
  if ((a6 & 1) != 0)
  {
    v19 = 0;
    memset(&v42[8], 0, 480);
    *a3 = v16 + 1028;
    memset(v42, 0, 32);
    do
    {
      v20 = *(_QWORD *)&a2[2 * v19];
      if ((v20 & 3) == 1)
      {
        v21 = *a3;
        if (serializeCFBurstTrieLevels(a1, v20 & 0xFFFFFFFFFFFFFFFCLL, a3, a4, 1, 0, a7))
          v22 = v21 | 1;
        else
          v22 = v21 | 3;
        v42[v19] = v22;
      }
      else
      {
        v42[v19] = v20;
      }
      ++v19;
    }
    while (v19 != 256);
    v42[256] = a2[513];
    pwrite(a7, v42, 0x404uLL, v39 + a4);
    if (a5)
LABEL_19:
      free(a2);
  }
  else
  {
    v40 = a4;
    v41 = a7;
    v36 = a5;
    v37 = v15;
    v24 = 4 * v15 + 36;
    MEMORY[0x1E0C80A78](a1, a2);
    v26 = (int8x16_t *)((char *)&v34 - v25);
    bzero((char *)&v34 - v25, v24);
    bzero(v26, v24);
    v27 = v16;
    v28 = 0;
    v29 = 0;
    v35 = v24;
    *a3 = v27 + v24;
    do
    {
      v30 = *(_QWORD *)&a2[2 * v28];
      if (v30)
      {
        v26->i64[v28 >> 6] |= 1 << v28;
        v31 = &v26->i8[4 * v29];
        if ((v30 & 3) == 1)
        {
          v32 = *a3;
          if (serializeCFBurstTrieLevels(a1, v30 & 0xFFFFFFFFFFFFFFFCLL, a3, v40, 1, 0, v41))
            v33 = v32 | 1;
          else
            v33 = v32 | 3;
          *((_DWORD *)v31 + 9) = v33;
        }
        else
        {
          *((_DWORD *)v31 + 9) = v30;
        }
        ++v29;
      }
      ++v28;
    }
    while (v28 != 256);
    v26[2].i32[0] = a2[513];
    if (vaddvq_s32(vuzp1q_s32((int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*v26)))), (int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(v26[1])))))) != (_DWORD)v37)serializeCFBurstTrieLevels_cold_1();
    pwrite(v41, v26, v35, v39 + v40);
    if (v36)
      goto LABEL_19;
  }
  return v38;
}

void serializeCFBurstTrieList(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  unsigned int i;
  _DWORD *v11;
  int v12;
  uint64_t v13;
  int (__cdecl *v14)(const void *, const void *);
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int16 v23;
  unsigned int v24;
  char *v25;
  _BYTE v26[16384];
  uint64_t v27;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v4 = v3;
  v6 = v5;
  v7 = v2;
  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(unsigned int *)(v2 + 2080);
  v9 = malloc_type_malloc(8 * v8, 0x2004093837F09uLL);
  for (i = 0; v6; ++i)
  {
    if (v8 <= i)
    {
      v9 = (_QWORD *)__CFSafelyReallocateTyped(v9, 16 * v8, 0x2004093837F09, 0);
      v8 *= 2;
    }
    v9[i] = v6;
    v6 = (_QWORD *)*v6;
  }
  if (v8 >= 0x10)
    v11 = malloc_type_malloc(1031 * v8 + 4, 0x1B8E6C21uLL);
  else
    v11 = v26;
  v12 = *(_DWORD *)(v7 + 2072);
  if ((v12 & 8) != 0)
  {
    v19 = i;
    qsort(v9, i, 8uLL, (int (__cdecl *)(const void *, const void *))nodeStringCompare);
    if (i)
    {
      v20 = 0;
      v21 = 0;
      i = 0;
      v15 = 10;
      do
      {
        v22 = v21;
        v21 = v9[v20];
        v23 = 0;
        if (v22)
        {
          v24 = *(unsigned __int16 *)(v21 + 16);
          while (v24 > v23
               && *(unsigned __int16 *)(v22 + 16) > v23
               && *(unsigned __int8 *)(v21 + v23 + 18) == *(unsigned __int8 *)(v22 + v23 + 18))
          {
            if (++v23 == 255)
            {
              v23 = 255;
              break;
            }
          }
        }
        else
        {
          LOWORD(v24) = *(_WORD *)(v21 + 16);
        }
        v25 = (char *)v11 + i;
        *(_WORD *)(v25 + 5) = v24 - v23;
        *(_DWORD *)(v25 + 7) = *(_DWORD *)(v21 + 12);
        v25[4] = v23;
        memcpy(v25 + 11, (const void *)(v21 + v23 + 18), *(unsigned __int16 *)(v21 + 16) - (unint64_t)v23);
        i = i - v23 + *(unsigned __int16 *)(v21 + 16) + 7;
        ++v20;
      }
      while (v20 != v19);
    }
    else
    {
      v15 = 10;
    }
  }
  else
  {
    v13 = i;
    if ((v12 & 0x10) != 0)
      v14 = (int (__cdecl *)(const void *, const void *))nodeStringCompare;
    else
      v14 = (int (__cdecl *)(const void *, const void *))nodeWeightCompare;
    qsort(v9, i, 8uLL, v14);
    if (i)
    {
      i = 0;
      v15 = 7;
      v16 = v9;
      do
      {
        v17 = *v16++;
        v18 = (char *)v11 + i;
        *((_WORD *)v18 + 2) = *(_WORD *)(v17 + 16);
        *(_DWORD *)(v18 + 6) = *(_DWORD *)(v17 + 12);
        memcpy(v18 + 10, (const void *)(v17 + 18), *(unsigned __int16 *)(v17 + 16));
        i += *(unsigned __int16 *)(v17 + 16) + 6;
        --v13;
      }
      while (v13);
    }
    else
    {
      v15 = 7;
    }
  }
  *v11 = i;
  write(v4, v11, (v15 + i) & 0x1FFFFFFFCLL);
  free(v9);
  if (v11 != (_DWORD *)v26)
    free(v11);
}

uint64_t nodeStringCompare(_QWORD *a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  const void *v4;
  const void *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  size_t v9;
  uint64_t result;

  v2 = *a1;
  v3 = *a2;
  v4 = (const void *)(*a1 + 18);
  v5 = (const void *)(*a2 + 18);
  v6 = *(unsigned __int16 *)(v2 + 16);
  v7 = *(unsigned __int16 *)(v3 + 16);
  v8 = v6 - v7;
  if (v6 >= v7)
    v9 = v7;
  else
    v9 = v6;
  LODWORD(result) = memcmp(v4, v5, v9);
  if ((_DWORD)result)
    return result;
  else
    return v8;
}

uint64_t nodeWeightCompare(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(*(_QWORD *)a2 + 8) - *(_DWORD *)(*(_QWORD *)a1 + 8));
}

void _CFFileCoordinateReadingItemAtURL2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  objc_class *v8;
  id v9;
  CFErrorRef v10;
  _QWORD v11[6];

  v11[5] = *MEMORY[0x1E0C80C00];
  v8 = objc_lookUpClass("NSFileCoordinator");
  if (v8)
  {
    v9 = objc_alloc_init(v8);
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = ___CFFileCoordinateReadingItemAtURL2_block_invoke_2;
    v11[3] = &unk_1E1336028;
    v11[4] = a4;
    objc_msgSend(v9, "__coordinateReadingItemAtURL:options:purposeID:byAccessor:", a1, a2, a3, v11);

  }
  else
  {
    v10 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 3328, 0);
    (*(void (**)(uint64_t, _QWORD, CFErrorRef, void *))(a4 + 16))(a4, 0, v10, &__block_literal_global_40);
    CFRelease(v10);
  }
}

void _CFFileCoordinateWritingItemAtURL2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  objc_class *v8;
  id v9;
  CFErrorRef v10;
  _QWORD v11[6];

  v11[5] = *MEMORY[0x1E0C80C00];
  v8 = objc_lookUpClass("NSFileCoordinator");
  if (v8)
  {
    v9 = objc_alloc_init(v8);
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 3221225472;
    v11[2] = ___CFFileCoordinateWritingItemAtURL2_block_invoke_2;
    v11[3] = &unk_1E1336028;
    v11[4] = a4;
    objc_msgSend(v9, "__coordinateWritingItemAtURL:options:purposeID:byAccessor:", a1, a2, a3, v11);

  }
  else
  {
    v10 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 3328, 0);
    (*(void (**)(uint64_t, _QWORD, CFErrorRef, void *))(a4 + 16))(a4, 0, v10, &__block_literal_global_3);
    CFRelease(v10);
  }
}

void _CFFileCoordinateReadingWritingItemsAtURLs2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  objc_class *v12;
  id v13;
  CFErrorRef v14;
  _QWORD v15[6];

  v15[5] = *MEMORY[0x1E0C80C00];
  v12 = objc_lookUpClass("NSFileCoordinator");
  if (v12)
  {
    v13 = objc_alloc_init(v12);
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = ___CFFileCoordinateReadingWritingItemsAtURLs2_block_invoke_2;
    v15[3] = &unk_1E1336070;
    v15[4] = a6;
    objc_msgSend(v13, "__coordinateReadingItemAtURL:options:writingItemAtURL:options:purposeID:byAccessor:", a1, a2, a3, a4, a5, v15);

  }
  else
  {
    v14 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 3328, 0);
    (*(void (**)(uint64_t, _QWORD, _QWORD, CFErrorRef, void *))(a6 + 16))(a6, 0, 0, v14, &__block_literal_global_4_0);
    CFRelease(v14);
  }
}

void _CFFileCoordinateWritingItemsAtURLs2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  objc_class *v12;
  id v13;
  CFErrorRef v14;
  _QWORD v15[6];

  v15[5] = *MEMORY[0x1E0C80C00];
  v12 = objc_lookUpClass("NSFileCoordinator");
  if (v12)
  {
    v13 = objc_alloc_init(v12);
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = ___CFFileCoordinateWritingItemsAtURLs2_block_invoke_2;
    v15[3] = &unk_1E1336070;
    v15[4] = a6;
    objc_msgSend(v13, "__coordinateWritingItemAtURL:options:writingItemAtURL:options:purposeID:byAccessor:", a1, a2, a3, a4, a5, v15);

  }
  else
  {
    v14 = CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 3328, 0);
    (*(void (**)(uint64_t, _QWORD, _QWORD, CFErrorRef, void *))(a6 + 16))(a6, 0, 0, v14, &__block_literal_global_6_0);
    CFRelease(v14);
  }
}

uint64_t _CFFileDidMove2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return -[objc_class __itemAtURL:didMoveToURL:purposeID:](objc_lookUpClass("NSFileCoordinator"), "__itemAtURL:didMoveToURL:purposeID:", a1, a2, a3);
}

uint64_t _CFFileDidDisconnect2(uint64_t a1, uint64_t a2)
{
  return -[objc_class __itemAtURL:didDisconnectWithPurposeID:](objc_lookUpClass("NSFileCoordinator"), "__itemAtURL:didDisconnectWithPurposeID:", a1, a2);
}

uint64_t _CFFileDidReconnect2(uint64_t a1, uint64_t a2)
{
  return -[objc_class __itemAtURL:didReconnectWithPurposeID:](objc_lookUpClass("NSFileCoordinator"), "__itemAtURL:didReconnectWithPurposeID:", a1, a2);
}

uint64_t _CFFileDidGainVersion2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return -[objc_class __itemAtURL:didGainVersionWithClientID:name:purposeID:](objc_lookUpClass("NSFileCoordinator"), "__itemAtURL:didGainVersionWithClientID:name:purposeID:", a1, a2, a3, a4);
}

uint64_t _CFFileDidLoseVersion2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return -[objc_class __itemAtURL:didLoseVersionWithClientID:name:purposeID:](objc_lookUpClass("NSFileCoordinator"), "__itemAtURL:didLoseVersionWithClientID:name:purposeID:", a1, a2, a3, a4);
}

uint64_t _CFFileDidResolveConflictVersion2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return -[objc_class __itemAtURL:didResolveConflictVersionWithClientID:name:purposeID:](objc_lookUpClass("NSFileCoordinator"), "__itemAtURL:didResolveConflictVersionWithClientID:name:purposeID:", a1, a2, a3, a4);
}

void _CFFileCoordinateReadingItemAtURL(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _CFFileCoordinateReadingItemAtURL2(a1, a2, (uint64_t)CFSTR("com.apple.GenericUbiquity"), a3);
}

void _CFFileCoordinateWritingItemAtURL(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _CFFileCoordinateWritingItemAtURL2(a1, a2, (uint64_t)CFSTR("com.apple.GenericUbiquity"), a3);
}

void _CFFileCoordinateReadWriteItemsAtURLs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _CFFileCoordinateReadingWritingItemsAtURLs2(a1, a2, a3, a4, (uint64_t)CFSTR("com.apple.GenericUbiquity"), a5);
}

void _CFHyphenationSetLinguisticDataPath(const void *a1)
{
  CFRetain(a1);
  if (_CFCustomHyphenationLinguisticDataPath)
    CFRelease((CFTypeRef)_CFCustomHyphenationLinguisticDataPath);
  _CFCustomHyphenationLinguisticDataPath = (uint64_t)a1;
}

uint64_t _CFHyphenationGetAllPossibleHyphenationLocations(const __CFString *a1, CFIndex a2, CFIndex a3, int a4, CFLocaleRef locale, uint64_t a6, uint64_t a7)
{
  return _CFHyphenationGetHyphenationLocations(a1, a2, a3, a4, 0, locale, a6, a7);
}

uint64_t _CFStringHyphenationCompileHyphenatorData(const char *a1)
{
  __CFDictionary *Mutable;
  CFNumberRef v3;
  _QWORD *v4;
  const __CFCharacterSet *Predefined;
  _DWORD *v6;
  uint64_t v7;
  const __CFString *v8;
  CFIndex Length;
  UniChar *v10;
  CFIndex v11;
  unsigned int v12;
  int v13;
  UniChar *v14;
  UniChar *v15;
  unsigned int v16;
  int IsCharacterMember;
  unint64_t v19;
  unsigned int v20;
  BOOL v21;
  uint64_t v22;
  unsigned int v24;
  uint64_t v25;
  _DWORD *v27;
  _QWORD *v28;
  const __CFString *v29;
  CFIndex v30;
  UniChar *v31;
  CFIndex v32;
  unsigned int v33;
  int v34;
  UniChar *v35;
  UniChar *v36;
  int v37;
  const __CFString *v39;
  UniChar *v41;
  const __CFString *cf;
  _QWORD *v43;
  int valuePtr;
  int v45;
  _WORD v46[28];
  _WORD v47[9];
  char cStr[1024];
  char v49[1024];
  char __str[1024];
  uint64_t v51;
  CFRange v52;
  CFRange v53;

  v51 = *MEMORY[0x1E0C80C00];
  snprintf(__str, 0x400uLL, "%s%c%s", a1, 47, "patterns.txt");
  snprintf(v49, 0x400uLL, "%s%c%s", a1, 47, "exceptions.txt");
  snprintf(cStr, 0x400uLL, "%s%c%s", a1, 47, "hyphenation.dat");
  v45 = 0;
  Mutable = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  valuePtr = 64;
  v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(Mutable, CFSTR("ContainerSize"), v3);
  v4 = CFBurstTrieCreateWithOptions(Mutable);
  CFRelease(Mutable);
  CFRelease(v3);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
  v6 = __CFHyphenationMapFileContents(__str, &v45);
  if (v45)
  {
    if (v4)
      CFBurstTrieRelease(v4);
    v7 = 1;
    fwrite("error: failed to map patterns file\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
    return v7;
  }
  v43 = v6;
  v8 = CFStringCreateWithBytes(0, *(const UInt8 **)v6, *((_QWORD *)v6 + 1), 0x8000100u, 1u);
  Length = CFStringGetLength(v8);
  v10 = (UniChar *)malloc_type_malloc(2 * Length, 0x1000040BDFB0063uLL);
  v52.location = 0;
  v52.length = Length;
  CFStringGetCharacters(v8, v52, v10);
  cf = v8;
  v11 = CFStringGetLength(v8);
  v41 = v10;
  v7 = 0;
  if (v11 >= 1)
  {
    v12 = 0;
    v13 = 0;
    v14 = v10;
    v15 = &v10[v11];
    do
    {
      v16 = *v14;
      IsCharacterMember = CFCharacterSetIsCharacterMember(Predefined, *v14);
      if (v16 != 46 && IsCharacterMember == 0)
      {
        if (v16 - 48 > 9)
        {
          v19 = (0x100002400uLL >> v16) & 1;
          if (v16 > 0x20)
            LODWORD(v19) = 0;
          goto LABEL_19;
        }
        v13 |= v16 - 48;
      }
      else
      {
        if (v12 > 7)
        {
          LODWORD(v19) = 0;
LABEL_19:
          while (v14 < v15)
          {
            v20 = *v14;
            v21 = v20 > 0x20;
            v22 = (1 << v20) & 0x100002400;
            if (!v21 && v22 != 0)
              break;
            ++v14;
          }
          while (v14 < v15)
          {
            v24 = *v14;
            v21 = v24 > 0x20;
            v25 = (1 << v24) & 0x100002400;
            if (v21 || v25 == 0)
              break;
            ++v14;
          }
          if ((_DWORD)v19)
          {
            v47[v12] = 0;
            CFBurstTrieAddCharacters((unint64_t)v4, (uint64_t)v47, v12, v13);
            v13 = 0;
            v12 = 0;
          }
          else
          {
            v13 = 0;
            v12 = 0;
            v7 = (v7 + 1);
          }
          continue;
        }
        v47[v12++] = v16;
        v13 *= 8;
      }
      ++v14;
    }
    while (v14 < v15);
  }
  __CFHyphenationDestroyMMapType(v43);
  CFRelease(cf);
  free(v41);
  v27 = __CFHyphenationMapFileContents(v49, &v45);
  if (v45)
  {
    fwrite("warning: failed to map exceptions file\n", 0x27uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
  }
  else
  {
    v28 = v27;
    v29 = CFStringCreateWithBytes(0, *(const UInt8 **)v27, *((_QWORD *)v27 + 1), 0x8000100u, 1u);
    v30 = CFStringGetLength(v29);
    v31 = (UniChar *)malloc_type_malloc(2 * v30, 0x1000040BDFB0063uLL);
    v53.location = 0;
    v53.length = v30;
    CFStringGetCharacters(v29, v53, v31);
    v32 = CFStringGetLength(v29);
    if (v32 >= 1)
    {
      v33 = 0;
      v34 = -1;
      v35 = v31;
      v36 = &v31[v32];
      do
      {
        v37 = *v35;
        if (v37 == 10 || v37 == 13)
        {
          v46[v33] = 0;
          CFBurstTrieAddCharacters((unint64_t)v4, (uint64_t)v46, v33, v34);
          v33 = 0;
          v34 = -1;
        }
        else if (v37 == 45)
        {
          if (v33)
            v34 &= ~(1 << (v33 - 1));
          else
            v33 = 0;
        }
        else
        {
          if (v33 > 0x1B)
            break;
          v46[v33++] = v37;
        }
        ++v35;
      }
      while (v35 < v36);
    }
    __CFHyphenationDestroyMMapType(v28);
    CFRelease(v29);
    free(v31);
  }
  fprintf((FILE *)*MEMORY[0x1E0C80C10], "writing trie to %s...\n", cStr);
  v39 = CFStringCreateWithCString(0, cStr, 0x8000100u);
  CFBurstTrieSerialize((uint64_t)v4, v39, 6);
  CFRelease(v39);
  CFBurstTrieRelease(v4);
  return v7;
}

_DWORD *__CFHyphenationMapFileContents(const char *a1, int *a2)
{
  _DWORD *v4;
  _DWORD *v5;
  int v6;
  void *v7;
  int v8;
  stat v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v4 = malloc_type_malloc(0x18uLL, 0x1010040E2407E0AuLL);
  v5 = v4;
  if (!v4)
  {
    v8 = 1;
    goto LABEL_11;
  }
  memset(&v10, 0, sizeof(v10));
  v4[4] = -1;
  *(_QWORD *)v4 = 0;
  *((_QWORD *)v4 + 1) = 0;
  if (stat(a1, &v10) == -1)
  {
    v8 = 2;
LABEL_10:
    __CFHyphenationDestroyMMapType(v5);
    v5 = 0;
    goto LABEL_11;
  }
  *((_QWORD *)v5 + 1) = v10.st_size;
  v6 = open(a1, 0);
  v5[4] = v6;
  if (v6 < 0)
  {
    v8 = 3;
    goto LABEL_10;
  }
  v7 = mmap(0, *((_QWORD *)v5 + 1), 1, 1, v6, 0);
  *(_QWORD *)v5 = v7;
  if (v7 == (void *)-1)
  {
    v8 = 4;
    goto LABEL_10;
  }
  v8 = 0;
LABEL_11:
  *a2 = v8;
  return v5;
}

void __CFHyphenationDestroyMMapType(_QWORD *a1)
{
  void *v2;
  int v3;

  if (a1)
  {
    v2 = (void *)*a1;
    if (v2)
    {
      munmap(v2, a1[1]);
      *a1 = 0;
    }
    v3 = *((_DWORD *)a1 + 4);
    if ((v3 & 0x80000000) == 0)
      close(v3);
    free(a1);
  }
}

void _CFBurstTrieReleaseWrapper(int a1, _QWORD *a2)
{
  CFBurstTrieRelease(a2);
}

uint64_t _CFPropertyListMissingSemicolon()
{
  return CFLog(4, CFSTR("CFPropertyListCreateFromXMLData(): Old-style plist parser: missing semicolon in dictionary on line %d. Parsing will be abandoned. Break on _CFPropertyListMissingSemicolon to debug."));
}

uint64_t _CFPropertyListMissingSemicolonOrValue()
{
  return CFLog(4, CFSTR("CFPropertyListCreateFromXMLData(): Old-style plist parser: missing semicolon or value in dictionary on line %d. Parsing will be abandoned. Break on _CFPropertyListMissingSemicolonOrValue to debug."));
}

void sub_182C19DE4(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

void sub_182C1B110(_Unwind_Exception *a1, int a2)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  id v7;

  *(_QWORD *)(v4 - 224) = v3;
  free(*(void **)(v4 - 224));
  if (a2 == 1)
  {
    v7 = objc_begin_catch(a1);

    objc_exception_throw(v7);
  }
  cleanup_sentinel_pair(v4 - 144);
  cleanup_sentinel_pair(v4 - 120);
  _Unwind_Resume(a1);
}

CFErrorRef __archiveIsCorrupt(uint64_t a1)
{
  const __CFString *v2;
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v2 = CFSTR("NSLocalizedDescription");
  v3[0] = a1;
  return CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 4864, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v3, &v2, 1));
}

void cleanup_sentinel_pair(uint64_t a1)
{
  void *v1;
  _QWORD *v2;
  BOOL v3;

  v1 = *(void **)(a1 + 16);
  v2 = (_QWORD *)(a1 + 8);
  if (*(_QWORD *)(a1 + 8))
    v3 = v1 == 0;
  else
    v3 = 1;
  if (!v3)
    objc_msgSend(*(id *)a1, "replaceObject:withObject:", v1);

  *v2 = 0;
  v2[1] = 0;
}

void sub_182C1BBC8()
{
  __break(1u);
}

void sub_182C1BC10(void *a1, int a2)
{
  uint64_t v2;

  if (a2)
  {
    objc_end_catch();
    objc_begin_catch(a1);
    if (!v2)
      JUMPOUT(0x182C1B94CLL);
    JUMPOUT(0x182C1B938);
  }
  JUMPOUT(0x182C1BBF8);
}

void sub_182C1BC34(uint64_t a1, int a2)
{
  if (a2)
    objc_terminate();
  JUMPOUT(0x182C1BBF8);
}

CFErrorRef __archiveIsCorrupt_0(uint64_t a1)
{
  const __CFString *v2;
  _QWORD v3[2];

  v3[1] = *MEMORY[0x1E0C80C00];
  v2 = CFSTR("NSLocalizedDescription");
  v3[0] = a1;
  return CFErrorCreate(0, CFSTR("NSCocoaErrorDomain"), 4864, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v3, &v2, 1));
}

uint64_t _CFPrefsSynchronizeDirtySourceForDaemonTermination(void *a1)
{
  _QWORD v2[6];

  v2[5] = *MEMORY[0x1E0C80C00];
  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 3221225472;
  v2[2] = ___CFPrefsSynchronizeDirtySourceForDaemonTermination_block_invoke;
  v2[3] = &unk_1E12E5C68;
  v2[4] = a1;
  return objc_msgSend(a1, "lockedSync:", v2);
}

void _CFPrefsSynchronizeForDaemonTermination()
{
  const __CFSet *v0;

  v0 = (const __CFSet *)+[_CFPrefsSynchronizer sharedInstance]();
  -[_CFPrefsSynchronizer synchronizeForDaemonTermination](v0);
}

void sub_182C1CD40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  _Block_object_dispose(&a36, 8);
  _Block_object_dispose(&a20, 8);
  _Block_object_dispose(&a24, 8);
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose(&a32, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__4(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__4(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

const __CFString *_CFPrefsDCopyCurrentUserName()
{
  uid_t v0;

  v0 = cfprefsdEuid();
  return _CFPrefsCopyUserNameForUID(v0);
}

uint64_t __cfprefsdEuid_block_invoke()
{
  uint64_t result;

  if (xpc_user_sessions_enabled())
    result = xpc_user_sessions_get_session_uid();
  else
    result = geteuid();
  cfprefsdEuid_euid = result;
  return result;
}

BOOL isSpecialKey(char *__s2)
{
  return __s2
      && (!strcmp("AppleLanguages", __s2)
       || !strcmp("AppleLocale", __s2)
       || !strcmp("AppleKeyboards", __s2)
       || !strcmp("AppleKeyboardsExpanded", __s2)
       || !strcmp("AppleLanguagesDidMigrate", __s2)
       || !strcmp("ApplePasscodeKeyboards", __s2)
       || !strcmp("AddingEmojiKeyboardHandled", __s2));
}

void DEBUG_READ_EMPTY(void *a1, void *a2, uint64_t a3)
{
  NSObject *v6;
  _QWORD v7[6];

  v7[5] = *MEMORY[0x1E0C80C00];
  v6 = _CFPrefsDaemonLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 3221225472;
    v7[2] = __DEBUG_READ_EMPTY_block_invoke;
    v7[3] = &__block_descriptor_40_e29_v64__0i8_12_20_28_36_44_52B60l;
    v7[4] = a3;
    _extractCFPDBits(a1, 0, a2, (uint64_t)v7);
  }
}

void sub_182C1DC04(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 48));
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__321(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 135);
}

void __Block_byref_object_dispose__322(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 135);
}

uint64_t ___extractCFPDBits_block_invoke(uint64_t a1, char *__s)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += strlen(__s) + 2;
  return 1;
}

uint64_t ___extractCFPDBits_block_invoke_2(uint64_t a1, char *__s)
{
  size_t v4;
  int v5;
  uint64_t v6;

  v4 = strlen(__s);
  v5 = v4;
  strncpy((char *)(*(_QWORD *)(a1 + 40) + *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)), __s, v4);
  v6 = *(_QWORD *)(a1 + 40);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v5;
  *(_WORD *)(v6 + *(int *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)) = 8236;
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += 2;
  return 1;
}

void *__initializeFSEvents_block_invoke()
{
  void *v0;
  void *result;

  v0 = dlopen("/System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices", 256);
  fsEventStreamCreate = dlsym(v0, "FSEventStreamCreate");
  fsEventStreamInvalidate = dlsym(v0, "FSEventStreamInvalidate");
  fsEventStreamRelease = dlsym(v0, "FSEventStreamRelease");
  fsEventStreamSetDispatchQueue = dlsym(v0, "FSEventStreamSetDispatchQueue");
  fsEventStreamStart = dlsym(v0, "FSEventStreamStart");
  fsEventStreamStop = dlsym(v0, "FSEventStreamStop");
  result = dlsym(v0, "FSEventStreamGetLatestEventId");
  fsEventStreamGetLatestEventId = (uint64_t)result;
  return result;
}

uint64_t _onqueue_locked_CFPrefsRecreateFileWatcher()
{
  dispatch_assert_queue_V2((dispatch_queue_t)fseventsQueue);
  os_unfair_lock_assert_owner((const os_unfair_lock *)&dirWatcherLock);
  if (dirWatcher)
  {
    fsEventStreamStop();
    fsEventStreamInvalidate(dirWatcher);
    fsEventStreamRelease(dirWatcher);
    dirWatcher = 0;
  }
  dirWatcher = fsEventStreamCreate(&__kCFAllocatorSystemDefault, deletionStreamCallback, 0, watchedDirs, -1, 25, 0.0);
  fsEventStreamSetDispatchQueue();
  return dirWatcher;
}

uint64_t __deletionStreamCallback_block_invoke(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "clearCacheForReason:", CFSTR("directory was deleted"));
}

void OUTLINED_FUNCTION_0_32(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x16u);
}

void OUTLINED_FUNCTION_2_15(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 393, a4);
}

void OUTLINED_FUNCTION_7_2(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_8_2(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void OUTLINED_FUNCTION_9_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 8u);
}

void OUTLINED_FUNCTION_10(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

int *OUTLINED_FUNCTION_12()
{
  return __error();
}

uint64_t _CFBigNumInitWithInt8(uint64_t result, int a2)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  if (a2 < 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -a2;
  }
  *(_DWORD *)result = a2;
  return result;
}

uint64_t _CFBigNumInitWithInt16(uint64_t result, int a2)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  if (a2 < 0)
  {
    *(_DWORD *)(result + 20) |= 0xFFu;
    a2 = -a2;
  }
  *(_DWORD *)result = (unsigned __int16)a2;
  return result;
}

_QWORD *_CFBigNumInitWithUInt8(_QWORD *result, int a2)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  *(_DWORD *)result = a2;
  return result;
}

_QWORD *_CFBigNumInitWithUInt16(_QWORD *result, int a2)
{
  *result = 0;
  result[1] = 0;
  result[2] = 0;
  *(_DWORD *)result = a2;
  return result;
}

uint64_t _CFBigNumInitWithUInt32(uint64_t result, unsigned int a2)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_DWORD *)result = a2 % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 / 0x3B9ACA00;
  return result;
}

uint64_t _CFBigNumInitWithUInt64(uint64_t result, unint64_t a2)
{
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_DWORD *)result = a2 % 0xDE0B6B3A7640000 % 0x3B9ACA00;
  *(_DWORD *)(result + 4) = a2 % 0xDE0B6B3A7640000 / 0x3B9ACA00;
  *(_DWORD *)(result + 8) = a2 / 0xDE0B6B3A7640000;
  return result;
}

__n128 _CFBigNumInitWithUInt128(_QWORD *a1, int a2)
{
  int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned __int32 v7;
  __n128 result;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v4 = __udivti3();
  v5 = __udivti3();
  v6 = __udivti3();
  v7 = __udivti3();
  result.n128_u32[0] = 1486618624 * v6 + 402653184 * v5 + a2 - 1000000000 * v7;
  result.n128_u32[1] = v7;
  result.n128_u64[1] = __PAIR64__(v5, v6);
  *(__n128 *)a1 = result;
  *((_DWORD *)a1 + 4) = v4;
  return result;
}

uint64_t _CFBigNumGetInt8(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)a1;
  if ((*(_BYTE *)(a1 + 20) & 0x80) != 0)
    v1 = -v1;
  return (char)v1;
}

uint64_t _CFBigNumGetInt16(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)a1;
  if ((*(_BYTE *)(a1 + 20) & 0x80) != 0)
    v1 = -v1;
  return (__int16)v1;
}

uint64_t _CFBigNumGetInt32(uint64_t a1)
{
  unsigned int v1;

  v1 = *(_DWORD *)a1 + 1000000000 * *(_DWORD *)(a1 + 4);
  if ((*(_BYTE *)(a1 + 20) & 0x80) != 0)
    return -v1;
  else
    return v1;
}

uint64_t _CFBigNumGetInt64(unsigned int *a1)
{
  if ((a1[5] & 0x80) != 0)
    return -(*a1 + 1000000000 * a1[1] + 1000000000000000000 * a1[2]);
  else
    return *a1 + 1000000000 * a1[1] + 1000000000000000000 * a1[2];
}

uint64_t _CFBigNumGetInt128(unsigned int *a1)
{
  if ((a1[5] & 0x80) != 0)
    return 0x4CB460F000000000 * a1[4]
         - (*a1
          + 1000000000 * a1[1]
          + 1000000000000000000 * a1[2]
          - 0x602F7FC318000000 * a1[3]);
  else
    return *a1
         + 1000000000 * a1[1]
         + 1000000000000000000 * a1[2]
         - 0x602F7FC318000000 * a1[3]
         - 0x4CB460F000000000 * a1[4];
}

uint64_t _CFBigNumGetUInt8(unsigned __int8 *a1)
{
  return *a1;
}

uint64_t _CFBigNumGetUInt16(unsigned __int16 *a1)
{
  return *a1;
}

uint64_t _CFBigNumGetUInt32(_DWORD *a1)
{
  return (*a1 + 1000000000 * a1[1]);
}

uint64_t _CFBigNumGetUInt64(unsigned int *a1)
{
  return *a1 + 1000000000 * a1[1] + 1000000000000000000 * a1[2];
}

uint64_t _CFBigNumGetUInt128(unsigned int *a1)
{
  return *a1
       + 1000000000 * a1[1]
       + 1000000000000000000 * a1[2]
       - 0x602F7FC318000000 * a1[3]
       - 0x4CB460F000000000 * a1[4];
}

double _CFBigNumInitWithCFNumber(uint64_t a1, unint64_t *a2)
{
  CFNumberType Type2;
  _OWORD v6[8];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  memset(v6, 0, sizeof(v6));
  Type2 = _CFNumberGetType2(a2);
  CFNumberGetValue((CFNumberRef)a2, Type2, v6);
  return _CFBigNumInitWithBytes(a1, (char *)v6, Type2);
}

double _CFBigNumInitWithBytes(uint64_t a1, char *a2, uint64_t a3)
{
  double result;

  switch(a3)
  {
    case 1:
    case 7:
      _CFBigNumInitWithInt8(a1, *a2);
      break;
    case 2:
    case 8:
      _CFBigNumInitWithInt16(a1, *(__int16 *)a2);
      break;
    case 3:
    case 9:
      _CFBigNumInitWithInt32(a1, *(_DWORD *)a2);
      break;
    case 4:
    case 10:
    case 11:
    case 14:
    case 15:
      _CFBigNumInitWithInt64(a1, *(_QWORD *)a2);
      break;
    case 17:
      *(_QWORD *)&result = _CFBigNumInitWithInt128(a1, *((_QWORD *)a2 + 1), *(_QWORD *)a2).n128_u64[0];
      break;
    default:
      return result;
  }
  return result;
}

CFNumberRef _CFNumberCreateWithBigNum(unsigned int *a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFNumberRef result;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int128 v13;
  _BYTE *v14;
  CFNumberType v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  _QWORD v23[2];
  _BYTE v24[24];
  _BYTE v25[24];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v2 = a1[4];
  if (!(_DWORD)v2)
  {
    if (!a1[3])
    {
      if (!a1[2] && !a1[1])
      {
        v22 = *a1;
        if (*a1 <= 0x7F)
        {
          if ((a1[5] & 0x80) != 0)
            v22 = -v22;
          v25[0] = v22;
          v14 = v25;
          v15 = kCFNumberSInt8Type;
          return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
        }
        if (!(v22 >> 15))
        {
          if ((a1[5] & 0x80) != 0)
            v22 = -v22;
          *(_WORD *)v25 = v22;
          v14 = v25;
          v15 = kCFNumberSInt16Type;
          return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
        }
      }
      if (!a1[2])
      {
        *(_QWORD *)&v25[16] = 0;
        *(_OWORD *)v25 = 0x208CA6BFFuLL;
        *(_QWORD *)&v24[16] = 0xFF00000000;
        *(_OWORD *)v24 = 0x208CA6C00uLL;
        v19 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v25);
        v20 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v24);
        if ((unint64_t)(v19 - 1) >= 0xFFFFFFFFFFFFFFFELL && v20 != -1)
        {
          v21 = *a1 + 1000000000 * a1[1];
          if ((a1[5] & 0x80) != 0)
            v21 = -v21;
          LODWORD(v23[0]) = v21;
          v14 = v23;
          v15 = kCFNumberSInt32Type;
          return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
        }
      }
    }
    if (!a1[3])
    {
      *(_DWORD *)&v25[20] = 0;
      *(_QWORD *)&v25[12] = 0;
      *(_QWORD *)v25 = 0xD50630432F2D7FFLL;
      *(_DWORD *)&v25[8] = 9;
      *(_QWORD *)&v24[12] = 0;
      *(_DWORD *)&v24[20] = 255;
      *(_QWORD *)v24 = 0xD50630432F2D800;
      *(_DWORD *)&v24[8] = 9;
      v16 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v25);
      v17 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v24);
      if ((unint64_t)(v16 - 1) >= 0xFFFFFFFFFFFFFFFELL && v17 != -1)
      {
        v18 = *a1 + 1000000000 * a1[1] + 1000000000000000000 * a1[2];
        if ((a1[5] & 0x80) != 0)
          v18 = -v18;
        v23[0] = v18;
        v14 = v23;
        v15 = kCFNumberSInt64Type;
        return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
      }
    }
  }
  *(_OWORD *)v25 = xmmword_182DC8D90;
  *(_QWORD *)&v25[16] = 170;
  *(_OWORD *)v24 = xmmword_182DC8DA0;
  *(_QWORD *)&v24[16] = 0xFF000000AALL;
  v3 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v25);
  v4 = _CFBigNumCompare((uint64_t)a1, (uint64_t)v24);
  result = 0;
  if ((unint64_t)(v3 + 1) <= 1 && v4 != -1)
  {
    v6 = *a1 + 1000000000 * a1[1];
    v7 = 1000000000000000000 * a1[2];
    v8 = __CFADD__(v6, v7);
    v9 = v6 + v7;
    if (v8)
      v10 = ((a1[2] * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64) + 1;
    else
      v10 = (a1[2] * (unsigned __int128)0xDE0B6B3A7640000uLL) >> 64;
    v13 = __PAIR128__(v10, v9)
        + __PAIR128__(((a1[3] * (unsigned __int128)0x9FD0803CE8000000) >> 64) + 54210108 * a1[3], 0x9FD0803CE8000000 * a1[3])+ __PAIR128__(0xC097CE7BC90715, 0xB34B9F1000000000) * v2;
    v12 = *((_QWORD *)&v13 + 1);
    v11 = v13;
    if ((a1[5] & 0x80) != 0)
    {
      v12 = (unsigned __int128)-(__int128)__PAIR128__((v2 * (unsigned __int128)0xB34B9F1000000000) >> 64, v13) >> 64;
      v11 = -(uint64_t)v13;
    }
    v23[0] = v11;
    v23[1] = v12;
    v14 = v23;
    v15 = kCFNumberMaxType|kCFNumberSInt8Type;
    return CFNumberCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, v15, v14);
  }
  return result;
}

uint64_t _CFBigNumCompare(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;

  v2 = *(_DWORD *)(a1 + 20);
  v3 = *(char *)(a2 + 20);
  if ((char)v2 == v3)
  {
    v4 = v2 << 24;
    v5 = 16;
    while (1)
    {
      if (v5 == -4)
        return 0;
      v6 = *(_DWORD *)(a1 + v5);
      v7 = *(_DWORD *)(a2 + v5);
      if (v6 < v7)
        break;
      v5 -= 4;
      if (v6 > v7)
      {
        v8 = v4 < 0;
        v9 = 1;
        goto LABEL_12;
      }
    }
    v8 = v4 < 0;
    v9 = -1;
LABEL_12:
    if (v8)
      return -v9;
    else
      return v9;
  }
  else if ((char)v2 < v3)
  {
    return -1;
  }
  else
  {
    return 1;
  }
}

uint64_t _CFBigNumNeg(uint64_t result, __int128 *a2)
{
  uint64_t v2;
  __int128 v3;

  v2 = 0;
  v3 = *a2;
  *(_QWORD *)(result + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)result = v3;
  while (!*(_DWORD *)((char *)a2 + v2))
  {
    v2 += 4;
    if (v2 == 20)
      return result;
  }
  *(_BYTE *)(result + 20) = *(_BYTE *)(result + 20) * *(_BYTE *)(result + 20) - 1;
  return result;
}

unint64_t _CFBigNumAdd(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t i;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  int v16;
  int v17;
  unsigned int v18;

  LODWORD(v3) = *(unsigned __int8 *)(a3 + 20) ^ *(unsigned __int8 *)(a2 + 20);
  if ((_DWORD)v3)
  {
    v4 = 16;
    while (1)
    {
      if (v4 == -4)
      {
LABEL_6:
        v7 = a2;
        goto LABEL_13;
      }
      v5 = *(_DWORD *)(a2 + v4);
      v6 = *(_DWORD *)(a3 + v4);
      if (v5 < v6)
        break;
      v4 -= 4;
      if (v5 > v6)
        goto LABEL_6;
    }
    v7 = a3;
    a3 = a2;
LABEL_13:
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = *(unsigned int *)(a3 + v10);
      v13 = v11 + *(unsigned int *)(v7 + v10);
      v15 = v13 - v12;
      v14 = v13 < v12;
      v16 = v13 - v12 + 1000000000;
      v11 = v15 >> 63;
      if (!v14)
        v16 = v15;
      *(_DWORD *)(a1 + v10) = v16;
      v10 += 4;
    }
    while (v10 != 20);
    v3 = (unint64_t)v15 >> 63;
    v17 = *(_DWORD *)(a1 + 20);
    if ((*(_BYTE *)(v7 + 20) & 0x80) != 0)
      v18 = v17 | 0xFF;
    else
      v18 = v17 & 0xFFFFFF00;
    *(_DWORD *)(a1 + 20) = v18;
  }
  else
  {
    for (i = 0; i != 20; i += 4)
    {
      v9 = *(_DWORD *)(a2 + i) + v3 + *(_DWORD *)(a3 + i);
      v3 = v9 > 0x3B9ACA00;
      if (v9 > 0x3B9ACA00)
        v9 -= 1000000000;
      *(_DWORD *)(a1 + i) = v9;
    }
    *(_BYTE *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  }
  return v3;
}

unint64_t _CFBigNumSub(uint64_t a1, uint64_t a2, __int128 *a3)
{
  _QWORD v6[4];

  v6[3] = *MEMORY[0x1E0C80C00];
  memset(v6, 0, 24);
  _CFBigNumNeg((uint64_t)v6, a3);
  return _CFBigNumAdd(a1, a2, (uint64_t)v6);
}

void _CFBigNumFromCString(uint64_t a1, char *__s)
{
  size_t v4;
  unsigned __int8 *v5;
  size_t v6;
  int v7;
  unsigned __int8 *v8;
  const char *v9;
  int v10;
  size_t v11;
  unint64_t v12;
  unint64_t v13;
  const char *v14;
  _DWORD *v15;
  unint64_t v16;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v4 = strlen(__s);
  v5 = (unsigned __int8 *)malloc_type_calloc(v4 + 1, 1uLL, 0x100004077774924uLL);
  v6 = strlen(__s);
  memcpy(v5, __s, v6 + 1);
  v7 = *v5;
  if (v7 == 43)
    goto LABEL_4;
  v8 = v5;
  if (v7 == 45)
  {
    *(_DWORD *)(a1 + 20) |= 0xFFu;
LABEL_4:
    v8 = v5 + 1;
  }
  v9 = (const char *)(v8 - 1);
  do
    v10 = *(unsigned __int8 *)++v9;
  while (v10 == 48);
  v11 = strlen(v9);
  if (v11)
  {
    if (v11 < 0xA)
    {
      v13 = 0;
    }
    else
    {
      v12 = (v11 - 10) / 9;
      if (v12 >= 3)
        v12 = 3;
      v13 = v12 + 1;
      v14 = &v9[v11 - 9];
      v15 = (_DWORD *)a1;
      v16 = v12 + 1;
      do
      {
        *v15++ = atol(v14);
        *v14 = 0;
        v14 -= 9;
        --v16;
      }
      while (v16);
    }
    *(_DWORD *)(a1 + 4 * v13) = atol(v9);
  }
  free(v5);
}

char *_CFBigNumCopyDescription(_DWORD *a1)
{
  char *v2;
  char *v3;
  const char *v4;

  v2 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x100004077774924uLL);
  v3 = v2;
  v4 = "-";
  if ((a1[5] & 0x80) == 0)
    v4 = "+";
  snprintf(v2, 0x400uLL, "sign:%s 1st:%u 2nd:%u 3rd:%u 4th:%u 5th:%u", v4, *a1, a1[1], a1[2], a1[3], a1[4]);
  return v3;
}

uint64_t _CFPrefsPIDForMessage(void *a1)
{
  __int128 *data;
  __int128 v3;
  void *value;
  uint64_t v5;
  uint64_t v6;
  size_t length;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  length = 0;
  v9 = 0u;
  v10 = 0u;
  data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
  if (data && length == 32)
  {
    v3 = data[1];
    v9 = *data;
    v10 = v3;
  }
  else
  {
    if (!xpc_dictionary_get_remote_connection(a1))
    {
      value = xpc_dictionary_get_value(a1, "connection");
      if (!value || (value = object_getClass(value), value != (void *)MEMORY[0x1E0C812E0]))
        _CFPrefsPIDForMessage_cold_1((uint64_t)value, v5, v6);
    }
    xpc_connection_get_audit_token();
  }
  return DWORD1(v10);
}

uint64_t _CFPrefsSandboxCheckForMessage_0(void *a1)
{
  __int128 *data;
  __int128 v3;
  void *value;
  uint64_t v5;
  uint64_t v6;
  size_t length;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  length = 0;
  v9 = 0u;
  v10 = 0u;
  data = (__int128 *)xpc_dictionary_get_data(a1, "CFPreferencesAuditToken", &length);
  if (data && length == 32)
  {
    v3 = data[1];
    v9 = *data;
    v10 = v3;
  }
  else
  {
    if (!xpc_dictionary_get_remote_connection(a1))
    {
      value = xpc_dictionary_get_value(a1, "connection");
      if (!value || (value = object_getClass(value), value != (void *)MEMORY[0x1E0C812E0]))
        _CFPrefsSandboxCheckForMessage_cold_1_0((uint64_t)value, v5, v6);
    }
    xpc_connection_get_audit_token();
  }
  return sandbox_check_by_audit_token();
}

void sub_182C20AA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Unwind_Resume(a1);
}

uint64_t indexSearchCallback(void *a1, uint64_t a2)
{
  uint64_t result;

  objc_opt_class();
  result = objc_opt_isKindOfClass();
  if ((result & 1) != 0)
  {
    result = objc_msgSend(a1, "shmemIndex");
    if (*(_DWORD *)a2 == (_DWORD)result)
      **(_QWORD **)(a2 + 8) = a1;
  }
  return result;
}

uint64_t _CFPrefsBooleanEntitlementValueForMessage(void *a1, uint64_t a2)
{
  _xpc_connection_s *remote_connection;
  _xpc_connection_s *value;
  uint64_t v6;
  _QWORD v8[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v12 = 0;
  remote_connection = xpc_dictionary_get_remote_connection(a1);
  if (!remote_connection)
  {
    value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
    remote_connection = value;
    if (!value || object_getClass(value) != (Class)MEMORY[0x1E0C812E0])
      __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
  }
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___CFPrefsBooleanEntitlementValueForMessage_block_invoke;
  v8[3] = &unk_1E1336D38;
  v8[4] = a1;
  v8[5] = &v9;
  v8[6] = a2;
  withClientContext(remote_connection, (uint64_t)v8);
  v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_182C20E14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__5(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t _CFPrefsCopyEntitlementForMessage(void *a1, uint64_t a2)
{
  _xpc_connection_s *remote_connection;
  _xpc_connection_s *value;
  uint64_t v6;
  _QWORD v8[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  void (*v12)(uint64_t, uint64_t);
  void (*v13)(uint64_t);
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v10 = &v9;
  v11 = 0x3052000000;
  v12 = __Block_byref_object_copy__5;
  v13 = __Block_byref_object_dispose__5;
  v14 = 0;
  remote_connection = xpc_dictionary_get_remote_connection(a1);
  if (!remote_connection)
  {
    value = (_xpc_connection_s *)xpc_dictionary_get_value(a1, "connection");
    remote_connection = value;
    if (!value || object_getClass(value) != (Class)MEMORY[0x1E0C812E0])
      __assert_rtn("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", 393, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
  }
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = ___CFPrefsCopyEntitlementForMessage_block_invoke;
  v8[3] = &unk_1E1336D88;
  v8[4] = a1;
  v8[5] = &v9;
  v8[6] = a2;
  withClientContext(remote_connection, (uint64_t)v8);
  v6 = v10[5];
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_182C20F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __CFXPreferencesDaemon_main(int a1)
{
  NSObject *v1;
  int v2;
  NSObject *v3;
  NSObject *v4;
  CFPrefsDaemon *v5;
  _BOOL4 v6;
  _DWORD v7[2];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a1 >= 1)
  {
    isCFPrefsD = 1;
    if (setiopolicy_np(9, 0, 1) < 0)
    {
      v1 = _CFPrefsDaemonLog();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      {
        v2 = *__error();
        v7[0] = 67109120;
        v7[1] = v2;
        _os_log_error_impl(&dword_182A8C000, v1, OS_LOG_TYPE_ERROR, "An error occurred while setting iopolicy: %{darwin.errno}d", (uint8_t *)v7, 8u);
      }
    }
    v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    v4 = dispatch_queue_create("com.apple.cfprefsd", v3);
    signal(15, (void (__cdecl *)(int))1);
    signal(30, (void (__cdecl *)(int))1);
    __CFXPreferencesDaemon_main_sigtermHandler = (uint64_t)dispatch_source_create(MEMORY[0x1E0C80DC0], 0xFuLL, 0, v4);
    dispatch_source_set_event_handler((dispatch_source_t)__CFXPreferencesDaemon_main_sigtermHandler, &__block_literal_global_136);
    dispatch_resume((dispatch_object_t)__CFXPreferencesDaemon_main_sigtermHandler);
    v5 = [CFPrefsDaemon alloc];
    if (__CFProcessIsRestricted())
      v6 = 0;
    else
      v6 = getenv("__CFPreferencesTestDaemon") != 0;
    cfprefsd = (uint64_t)-[CFPrefsDaemon initWithRole:testMode:](v5, 0, v6);
    objc_msgSend((id)cfprefsd, "enterSandbox");
    __CFXPreferencesDaemon_main_sigusrHandler = (uint64_t)dispatch_source_create(MEMORY[0x1E0C80DC0], 0x1EuLL, 0, v4);
    dispatch_source_set_event_handler((dispatch_source_t)__CFXPreferencesDaemon_main_sigusrHandler, &__block_literal_global_138);
    dispatch_resume((dispatch_object_t)__CFXPreferencesDaemon_main_sigusrHandler);
    dispatch_main();
  }
  printf("cfprefsd is not intended to be used directly");
  exit(0);
}

void __dumpDebugInfoCallback_block_invoke(uint64_t a1)
{
  const __CFString *v2;
  const void *v3;
  const void *v4;

  v2 = (const __CFString *)objc_msgSend(*(id *)(a1 + 32), "debugDump");
  CFStringAppend(*(CFMutableStringRef *)(a1 + 40), v2);
  CFRelease(v2);
  v3 = (const void *)objc_msgSend(*(id *)(a1 + 32), "copyUncanonicalizedPath");
  if (v3)
  {
    v4 = v3;
    if (CFSetContainsValue(*(CFSetRef *)(a1 + 48), v3))
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0, CFSTR("\nPATH COLLISION: %@\n"), v4);
    else
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), v4);
    CFRelease(v4);
  }
}

void OUTLINED_FUNCTION_0_33(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 393, a4);
}

void OUTLINED_FUNCTION_1_22(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_182C21DE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 56));
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__6(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void _CFPrefsResetManagedPreferencesStateCache()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;

  os_unfair_lock_lock((os_unfair_lock_t)&managedPreferencesLock);
  Mutable = (__CFDictionary *)locked_getManagedStateCache_knownContainerizedManagedPrefsStates;
  if (!locked_getManagedStateCache_knownContainerizedManagedPrefsStates)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    locked_getManagedStateCache_knownContainerizedManagedPrefsStates = (uint64_t)Mutable;
  }
  CFDictionaryRemoveAllValues(Mutable);
  v1 = (__CFDictionary *)locked_getManagedStateCache_knownManagedPrefsStates;
  if (!locked_getManagedStateCache_knownManagedPrefsStates)
  {
    v1 = CFDictionaryCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    locked_getManagedStateCache_knownManagedPrefsStates = (uint64_t)v1;
  }
  CFDictionaryRemoveAllValues(v1);
  os_unfair_lock_unlock((os_unfair_lock_t)&managedPreferencesLock);
}

void sub_182C21FD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C220F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C22420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C2267C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C22CE4(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182C22E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C233B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 56), 8);
  _Unwind_Resume(a1);
}

void sub_182C234FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C2368C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182C23764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _CFPrefsSetDirectModeConnection(void *a1)
{
  uint64_t v2;
  id v3;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v2 = objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v3 = (id)v2;
  -[_CFXPreferences _replaceDirectConnection:](v2, a1);

}

_xpc_connection_s *_CFPrefsCopyDirectModeConnection()
{
  _xpc_connection_s **v0;
  _xpc_connection_s *v1;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v0 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v0 = (_xpc_connection_s **)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v1 = -[_CFXPreferences _copyDaemonConnectionSettingUpIfNecessaryForRole:andUserIdentifier:](v0, 3, 0);

  return v1;
}

void _CFPrefsResetUserSessionPreferences()
{
  NSObject *v0;
  void *v1;
  os_activity_scope_state_s state;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v0 = _os_activity_create(&dword_182A8C000, "Resetting CFPreferences/NSUserDefaults", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0;
  state.opaque[1] = 0;
  os_activity_scope_enter(v0, &state);
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v1 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v1 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  -[_CFXPreferences resetUserPreferences]((uint64_t)v1);

  os_activity_scope_leave(&state);
}

void sub_182C24118(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t _CFPreferencesDoesNSUserDefaultsExist()
{
  return _NSUserDefaultsRegisteredAtLeastOnce;
}

id _CFPreferencesCopyStandardUserDefaults()
{
  void *v0;

  if (_NSUserDefaultsRegisteredAtLeastOnce != 1)
    return 0;
  v0 = (void *)objc_opt_class();
  return objc_msgSend(v0, sel_registerName("_copyStandardUserDefaultsIfPresent"));
}

void _CFPrefsUnregisterUserDefaultsInstance(uint64_t a1)
{
  void *v2;
  id v3;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v2 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v3 = v2;
  objc_msgSend(v2, "unregisterUserDefaultsInstance:", a1);

}

const __CFString *_CFXPreferencesGetByHostIdentifierString()
{
  return &stru_1E1337B18;
}

uint64_t _CFPreferencesCopyValueNoCache(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _CFPreferencesCopyValueWithContainer(a1, a2, a3, a4, 0);
}

CFDictionaryRef __CFXPreferencesCopyCurrentApplicationState()
{
  char v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  return __CFXPreferencesCopyCurrentApplicationStateWithDeadlockAvoidance(&v1);
}

void _CFXPreferencesReplaceValuesInNamedVolatileSource(uint64_t a1, const __CFDictionary *a2)
{
  void *v4;
  uint64_t v5;
  _QWORD v6[7];

  v6[6] = *MEMORY[0x1E0C80C00];
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v5 = objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
    v4 = (void *)v5;
    if (v5)
    {
      v6[0] = MEMORY[0x1E0C809B0];
      v6[1] = 3221225472;
      v6[2] = __65___CFXPreferences_replaceValuesInVolatileSourceNamed_withValues___block_invoke;
      v6[3] = &unk_1E1336FF0;
      v6[4] = v5;
      v6[5] = a1;
      withKeysAndValues(a2, (uint64_t)v6);
    }
  }

}

uint64_t _CFXPreferencesCopyVolatileSourceNames()
{
  void *v0;
  uint64_t v1;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v0 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v0 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v1 = -[_CFXPreferences volatileSourceNames]((uint64_t)v0);

  return v1;
}

uint64_t _CFXPreferencesCopyDictionaryForNamedVolatileSource(__CFString *a1)
{
  void *v2;
  uint64_t v3;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v2 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v3 = -[_CFXPreferences copyDictionaryForVolatileSourceWithName:]((uint64_t)v2, a1);

  return v3;
}

void _CFXPreferencesRemoveNamedVolatileSource(__CFString *a1)
{
  uint64_t v2;
  id v3;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v2 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v2 = objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v3 = (id)v2;
  -[_CFXPreferences removeVolatileSourceForName:](v2, a1);

}

CFMutableDictionaryRef _CFPrefsCopyAppDictionary(__CFString *a1)
{
  return _CFPrefsCopyAppDictionaryWithContainer(a1, 0);
}

CFMutableDictionaryRef _CFXPreferencesCopyDictionaryForApplicationPreferences()
{
  return _CFPrefsCopyAppDictionaryWithContainer(CFSTR("kCFPreferencesCurrentApplication"), 0);
}

void _CFXPreferencesReplaceValuesInSourceWithBundleIDWithContainer(uint64_t a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v10;
  uint64_t v11;
  _QWORD v12[10];

  v12[9] = *MEMORY[0x1E0C80C00];
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v11 = objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
    v10 = (void *)v11;
    if (v11)
    {
      v12[0] = MEMORY[0x1E0C809B0];
      v12[1] = 3221225472;
      v12[2] = __85___CFXPreferences_replaceValuesInSourceForIdentifier_user_host_container_withValues___block_invoke;
      v12[3] = &unk_1E13370A0;
      v12[4] = v11;
      v12[5] = a1;
      v12[6] = a3;
      v12[7] = a4;
      v12[8] = a5;
      withKeysAndValues(a2, (uint64_t)v12);
    }
  }

}

void _CFXPreferencesReplaceValuesInSourceWithBundleID(uint64_t a1, const __CFDictionary *a2)
{
  _CFXPreferencesReplaceValuesInSourceWithBundleIDWithContainer(a1, a2, (uint64_t)CFSTR("kCFPreferencesCurrentUser"), (uint64_t)CFSTR("kCFPreferencesAnyHost"), 0);
}

void _CFPreferencesSetAppCloudSyncEnabled(uint64_t a1, int a2, __CFString *a3, const __CFString *a4)
{
  uint64_t v8;
  id v9;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v8 = objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v9 = (id)v8;
  -[_CFXPreferences setCloudSyncEnabled:forKey:appIdentifier:container:](v8, a2 != 0, a1, a3, a4);

}

void _CFPreferencesAppFullCloudSynchronizeWithConfiguration(__CFString *a1, const __CFString *a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  uint64_t v9;
  _QWORD v10[6];

  v10[5] = *MEMORY[0x1E0C80C00];
  if (_CFPrefsCurrentProcessIsCFPrefsD())
  {
    v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v9 = objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
    v8 = (void *)v9;
    if (v9)
    {
      v10[0] = MEMORY[0x1E0C809B0];
      v10[1] = 3221225472;
      v10[2] = __101___CFXPreferences_fullCloudSynchronizeForAppIdentifier_container_configurationURL_completionHandler___block_invoke;
      v10[3] = &unk_1E1336F80;
      v10[4] = a4;
      -[_CFXPreferences withSearchListForIdentifier:container:cloudConfigurationURL:perform:](v9, a1, a2, a3, (uint64_t)v10);
    }
  }

}

void _CFPreferencesAppFullCloudSynchronize(__CFString *a1, const __CFString *a2, uint64_t a3)
{
  _CFPreferencesAppFullCloudSynchronizeWithConfiguration(a1, a2, 0, a3);
}

BOOL _CFPreferencesHasAppCloudValue(uint64_t a1, __CFString *a2, const __CFString *a3, uint64_t a4)
{
  void *v8;
  _BOOL8 v9;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v8 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v9 = -[_CFXPreferences hasCloudValueForKey:appIdentifier:container:configurationURL:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

BOOL _CFPreferencesHasAppValue(uint64_t a1, __CFString *a2, const __CFString *a3, uint64_t a4)
{
  void *v8;
  _BOOL8 v9;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v8 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v9 = -[_CFXPreferences hasNonRegisteredValueForKey:appIdentifier:container:configurationURL:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

void CFPreferencesAddSuitePreferencesToApp(CFStringRef applicationID, CFStringRef suiteID)
{
  _CFPreferencesAddSuitePreferencesToAppWithContainer(applicationID, suiteID, 0);
}

void _CFPreferencesAppPreload(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  id v9;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v8 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
    if (v8)
    {
      v9 = v8;
      +[CFPrefsSearchListSource preloadDomainsForIdentifiers:containers:cloudConfigurationURLs:count:containingPreferences:](CFPrefsSearchListSource, a1, a2, a3, a4, v8);
      v8 = v9;
    }
  }

}

void CFPreferencesSetMultiple(CFDictionaryRef keysToSet, CFArrayRef keysToRemove, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  const os_unfair_lock *v10;
  os_unfair_lock *v11;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v10 = (const os_unfair_lock *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v11 = (os_unfair_lock *)v10;
  -[_CFXPreferences setValuesForKeys:removingValuesForKeys:identifier:user:host:container:](v10, (uint64_t)keysToSet, (uint64_t)keysToRemove, (__CFString *)applicationID, userName, hostName, 0);

}

void _CFPreferencesSetAccessRestricted(__CFString *a1, int a2)
{
  uint64_t v4;
  id v5;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v4 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v4 = objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v5 = (id)v4;
  -[_CFXPreferences setAccessRestricted:forAppIdentifier:](v4, a2 != 0, a1);

}

void _CFPreferencesNotifyOfImpendingUserDeletion()
{
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {

  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);

  }
}

void _CFPreferencesSetFileProtectionClass(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4, int a5)
{
  uint64_t v10;
  id v11;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v10 = objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v11 = (id)v10;
  -[_CFXPreferences setFileProtectionClass:identifier:user:host:container:](v10, a5, a1, a2, a3, a4);

}

uint64_t _CFPreferencesGetFileProtectionClass(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  void *v8;
  uint64_t v9;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v8 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v9 = -[_CFXPreferences fileProtectionClassForIdentifier:user:host:container:]((uint64_t)v8, a1, a2, a3, a4);

  return v9;
}

void _CFPreferencesSetDaemonCacheEnabled(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  void *v10;
  id v11;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v10 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v11 = v10;
  objc_msgSend(v10, "setDaemonCacheEnabled:identifier:user:host:container:", a5 != 0, a1, a2, a3, a4);

}

CFArrayRef CFPreferencesCopyApplicationList(CFStringRef userName, CFStringRef hostName)
{
  _BOOL4 v3;

  v3 = CFEqual(hostName, CFSTR("kCFPreferencesCurrentHost")) != 0;
  return _CFPreferencesCopyApplicationList(userName, v3);
}

CFMutableDictionaryRef _CFPreferencesCopyMultipleManaged(uint64_t a1, __CFString *a2, int a3)
{
  void *v6;
  CFMutableDictionaryRef v7;

  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v6 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v6 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v7 = -[_CFXPreferences copyManagedValuesForKeys:identifier:useSystemContainer:]((uint64_t)v6, a1, a2, a3 != 0);

  return v7;
}

BOOL _CFPreferencesIsManaged()
{
  CFStringRef v0;
  const __CFString *v1;
  _BOOL8 IsManaged;

  v0 = CFCopyUserName();
  if (_CFGetEUID())
    v1 = v0;
  else
    v1 = CFSTR("kCFPreferencesAnyUser");
  IsManaged = CFPreferencesIsManaged(v1, 0);
  CFRelease(v0);
  return IsManaged;
}

unint64_t _CFPreferencesWriteDomainDictionaryToPath(unint64_t a1, uint64_t a2, void *a3)
{
  unint64_t v3;
  const __CFString *v4;
  const __CFString *v5;
  CFURLRef v6;
  const __CFURL *v7;
  __CFWriteStream *v8;
  const __CFData *v9;
  CFURLRef PathComponent;
  CFArrayRef v11;
  SInt32 errorCode;
  void *values;
  UInt8 buffer[1026];
  uint64_t v16;

  v3 = a1;
  v16 = *MEMORY[0x1E0C80C00];
  values = a3;
  if (a1)
  {
    errorCode = 0;
    v4 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("%@/%@%@"), a2, a3, CFSTR(".plist"));
    if (!v4)
    {
      v3 = 0;
LABEL_17:
      v11 = CFArrayCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
      _CFPreferencesManagementStatusChangedForDomains();
      CFRelease(v11);
      return v3;
    }
    v5 = v4;
    v6 = CFURLCreateWithFileSystemPath((CFAllocatorRef)&__kCFAllocatorSystemDefault, v4, kCFURLPOSIXPathStyle, 0);
    if (!v6)
    {
      v3 = 0;
LABEL_16:
      CFRelease(v5);
      goto LABEL_17;
    }
    v7 = v6;
    if (CFDictionaryGetCount((CFDictionaryRef)v3))
    {
      v8 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)&__kCFAllocatorSystemDefault, (CFAllocatorRef)&__kCFAllocatorSystemDefault);
      CFWriteStreamOpen(v8);
      CFPropertyListWrite((CFPropertyListRef)v3, v8, kCFPropertyListBinaryFormat_v1_0, 0, 0);
      CFWriteStreamClose(v8);
      v9 = (const __CFData *)CFWriteStreamCopyProperty(v8, CFSTR("kCFStreamPropertyDataWritten"));
      CFRelease(v8);
      if (v9)
      {
        v3 = CFURLWriteDataAndPropertiesToResource(v7, v9, 0, &errorCode);
        goto LABEL_7;
      }
    }
    else
    {
      bzero(buffer, 0x402uLL);
      if (CFURLGetFileSystemRepresentation(v7, 1u, buffer, 1024))
      {
        v3 = unlink((const char *)buffer) == 0;
        PathComponent = CFURLCreateCopyDeletingLastPathComponent((CFAllocatorRef)&__kCFAllocatorSystemDefault, v7);
        if (!PathComponent)
          goto LABEL_15;
        v9 = PathComponent;
        bzero(buffer, 0x402uLL);
        if (CFURLGetFileSystemRepresentation(v9, 1u, buffer, 1024))
          rmdir((const char *)buffer);
LABEL_7:
        CFRelease(v9);
LABEL_15:
        CFRelease(v7);
        goto LABEL_16;
      }
    }
    v3 = 0;
    goto LABEL_15;
  }
  return v3;
}

uint64_t _CFPreferencesManagementStatusChangedForDomains()
{
  _handleExternalNotification(CFSTR("com.apple.MCX._managementStatusChangedForDomains"));
  notify_post("com.apple.MCX._managementStatusChangedForDomains");
  _handleExternalNotification(&stru_1E1337B18);
  return notify_post("com.apple.CFPreferences._domainsChangedExternally");
}

unint64_t _CFPreferencesWriteManagedDomain(unint64_t a1, const __CFString *a2, int a3, void *a4)
{
  _BOOL4 v7;
  size_t v8;
  const __CFURL *v9;
  const __CFURL *v10;
  CFStringRef v11;
  unint64_t v12;
  char __s[1024];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v7 = a3 != 0;
  bzero(__s, 0x400uLL);
  if (!_CFPrefsGetPathForManagedBundleID(0, a2, v7, (UInt8 *)__s))
    return 0;
  v8 = strlen(__s);
  v9 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)__s, v8, 1u);
  if (!v9)
    return 0;
  v10 = v9;
  v11 = CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle);
  CFRelease(v10);
  if (!v11)
    return 0;
  v12 = _CFPreferencesWriteDomainDictionaryToPath(a1, (uint64_t)v11, a4);
  CFRelease(v11);
  return v12;
}

unint64_t _CFPreferencesWriteManagedDomainForUser(unint64_t a1, const __CFString *a2, void *a3)
{
  return _CFPreferencesWriteManagedDomain(a1, a2, 0, a3);
}

uint64_t _CFPrefsDirectModeEnabledForDomain(__CFString *a1, const __CFString *a2, const void *a3, const __CFString *a4)
{
  void *v8;
  _BOOL4 v9;
  uint64_t v10;
  _QWORD v12[5];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = 0;
  if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
  {
    v8 = 0;
  }
  else
  {
    if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
      dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
    v8 = (void *)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
  }
  v9 = CFEqual(a3, CFSTR("kCFPreferencesCurrentHost")) != 0;
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v12[2] = ___CFPrefsDirectModeEnabledForDomain_block_invoke;
  v12[3] = &unk_1E1336E70;
  v12[4] = &v13;
  -[_CFXPreferences withSourceForIdentifier:user:byHost:container:cloud:perform:]((uint64_t)v8, a1, a2, v9, a4, 0, (uint64_t)v12);

  v10 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_182C252F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _handleExternalNotification(const __CFString *a1)
{
  _xpc_connection_s **v2;
  __CFNotificationCenter *DarwinNotifyCenter;

  if ((__CF_FORK_STATE & 2) == 0)
    __CF_USED();
  if ((__CF_FORK_STATE & 1) != 0)
    __THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__();
  if ((__CF_FORK_STATE & 1) == 0)
  {
    if ((_CFPrefsCurrentProcessIsCFPrefsD() & 1) != 0)
    {
      v2 = 0;
    }
    else
    {
      if (_CFPrefsCopyDefaultPreferences_onceToken != -1)
        dispatch_once(&_CFPrefsCopyDefaultPreferences_onceToken, &__block_literal_global_188);
      v2 = (_xpc_connection_s **)objc_msgSend((id)_CFPrefsCopyDefaultPreferences_defaultPrefs, "copyPrefs");
    }
    -[_CFXPreferences flushManagedSources](v2);

    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterPostNotificationWithOptions(DarwinNotifyCenter, a1, 0, 0, 0);
  }
}

uint64_t _CFPreferencesPostValuesChangedInDomains()
{
  _handleExternalNotification(&stru_1E1337B18);
  return notify_post("com.apple.CFPreferences._domainsChangedExternally");
}

void OUTLINED_FUNCTION_1_23(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_2_17(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(a1 + 56) = v1;
  abort();
}

uint64_t (**__CFStringEncodingGetLatin2ConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_7)
    __CFStringEncodingPrecomposeLatinCharacter_7 = (_UNKNOWN *)a2(4);
  if (a1 > 513)
  {
    switch(a1)
    {
      case 514:
        return __CFConverterISOLatin2;
      case 1042:
        return __CFConverterDOSLatin2;
      case 1281:
        return __CFConverterWinLatin2;
    }
  }
  else
  {
    switch(a1)
    {
      case 29:
        return __CFConverterMacCentEuro;
      case 36:
        return __CFConverterMacCroatian;
      case 38:
        return __CFConverterMacRomanian;
    }
  }
  return 0;
}

uint64_t __CFToMacCentEuro(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9675 < 0xFFFFDAD5)
    return 0;
  v5 = (unsigned __int16 *)&maccenteuro_from_uni;
  v6 = (unsigned __int16 *)&unk_182DC8FDC;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromMacCentEuro(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    LOWORD(a2) = maccenteuro_to_uni[a2 - 128];
  *a3 = a2;
  return 1;
}

uint64_t __CFToMacCentEuroPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9675) >= 0xDAD5u)
    {
      v11 = (unsigned __int16 *)&maccenteuro_from_uni;
      v12 = (unsigned __int16 *)&unk_182DC8FDC;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

uint64_t __CFIsValidCombiningCharacterForLatin2(int a1)
{
  if ((a1 - 768) > 0x5F)
    return 0;
  else
    return (__CFLatin2CombiningCharBitmap[(a1 - 768) >> 5] >> ~(_BYTE)a1) & 1;
}

uint64_t __CFToMacCroatian(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;

  if (a2 > 0x7F)
  {
    if ((unsigned __int16)(a2 + 1792) >= 0x7A0u)
    {
      v4 = (unsigned __int16 *)&maccroatian_from_uni;
      v5 = (unsigned __int16 *)&unk_182DC92E8;
      do
      {
        v6 = ((char *)v5 - (char *)v4) >> 3;
        v7 = &v4[2 * v6];
        v8 = *v7;
        if (v8 <= a2)
        {
          if (v8 >= a2)
          {
            LOBYTE(a2) = v4[2 * v6 + 1];
            goto LABEL_2;
          }
          v4 = v7 + 2;
        }
        else
        {
          v5 = v7 - 2;
        }
      }
      while (v4 <= v5);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a3 = a2;
    return 1;
  }
}

uint64_t __CFFromMacCroatian(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    LOWORD(a2) = maccroatian_to_uni[a2 - 128];
  *a3 = a2;
  return 1;
}

uint64_t __CFToMacCroatianPrecompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  int v10;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned __int16 *v15;
  unsigned int v16;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
  if (v9 <= 0x7F)
  {
    LOBYTE(v10) = v9;
    if (!(_BYTE)v9)
      return 0;
    goto LABEL_3;
  }
  if ((unsigned __int16)(v9 + 1792) < 0x7A0u)
    return 0;
  v12 = (unsigned __int16 *)&maccroatian_from_uni;
  v13 = (unsigned __int16 *)&unk_182DC92E8;
  while (1)
  {
    v14 = ((char *)v13 - (char *)v12) >> 3;
    v15 = &v12[2 * v14];
    v16 = *v15;
    if (v16 <= v9)
      break;
    v13 = v15 - 2;
LABEL_12:
    if (v12 > v13)
      return 0;
  }
  if (v16 < v9)
  {
    v12 = v15 + 2;
    goto LABEL_12;
  }
  v10 = LOBYTE(v12[2 * v14 + 1]);
  if (!v10)
    return 0;
LABEL_3:
  if (a5)
    *a4 = v10;
  *a6 = 1;
  return 2;
}

uint64_t __CFToMacRomanian(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4)
{
  unsigned int v4;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  uint64_t v8;
  unsigned __int16 *v9;
  unsigned int v10;

  v4 = *a2;
  if (v4 > 0x7F)
  {
    if ((unsigned __int16)(v4 + 1792) >= 0x7A0u)
    {
      v6 = (unsigned __int16 *)&macromanian_from_uni;
      v7 = (unsigned __int16 *)&unk_182DC95E8;
      do
      {
        v8 = ((char *)v7 - (char *)v6) >> 3;
        v9 = &v6[2 * v8];
        v10 = *v9;
        if (v10 <= v4)
        {
          if (v10 >= v4)
          {
            LOBYTE(v4) = v6[2 * v8 + 1];
            goto LABEL_2;
          }
          v6 = v9 + 2;
        }
        else
        {
          v7 = v9 - 2;
        }
      }
      while (v6 <= v7);
    }
    return 0;
  }
  else
  {
LABEL_2:
    *a4 = v4;
    return 1;
  }
}

BOOL __CFFromMacRomanian(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = macromanian_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacRomanianLen(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t result;
  int v4;

  for (result = 0; a3; --a3)
  {
    v4 = *a2++;
    if (v4 != 806)
      ++result;
  }
  return result;
}

uint64_t __CFFromMacRomanianLen(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t result;
  int v4;
  uint64_t v5;
  uint64_t v7;

  for (result = 0; a3; --a3)
  {
    v4 = *a2++;
    v5 = (1 << (v4 + 81)) & 0x1800000010001;
    if ((v4 - 175) > 0x30 || v5 == 0)
      v7 = 1;
    else
      v7 = 2;
    result += v7;
  }
  return result;
}

uint64_t __CFToMacRomanianPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t result;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;

  if (a3 < 2 || a2[1] != 806)
  {
    v12 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
    if (v12 <= 0x7F)
    {
      LOBYTE(v11) = v12;
      if (!(_BYTE)v12)
        return 0;
      goto LABEL_10;
    }
    if ((unsigned __int16)(v12 + 1792) < 0x7A0u)
      return 0;
    v13 = (unsigned __int16 *)&macromanian_from_uni;
    v14 = (unsigned __int16 *)&unk_182DC95E8;
    while (1)
    {
      v15 = ((char *)v14 - (char *)v13) >> 3;
      v16 = &v13[2 * v15];
      v17 = *v16;
      if (v17 <= v12)
      {
        if (v17 >= v12)
        {
          v11 = LOBYTE(v13[2 * v15 + 1]);
          if (!v11)
            return 0;
LABEL_10:
          if (a5)
LABEL_11:
            *a4 = v11;
LABEL_12:
          *a6 = 1;
          return 2;
        }
        v13 = v16 + 2;
      }
      else
      {
        v14 = v16 - 2;
      }
      if (v13 > v14)
        return 0;
    }
  }
  result = 0;
  v10 = *a2;
  if (v10 <= 0x72)
  {
    if (v10 == 83)
    {
      if (a5)
      {
        LOBYTE(v11) = -81;
        goto LABEL_11;
      }
    }
    else
    {
      if (v10 != 84)
        return result;
      if (a5)
      {
        LOBYTE(v11) = -34;
        goto LABEL_11;
      }
    }
    goto LABEL_12;
  }
  if (v10 == 115)
  {
    if (a5)
    {
      LOBYTE(v11) = -65;
      goto LABEL_11;
    }
    goto LABEL_12;
  }
  if (v10 == 116)
  {
    if (a5)
    {
      LOBYTE(v11) = -33;
      goto LABEL_11;
    }
    goto LABEL_12;
  }
  return result;
}

uint64_t __CFToDOSLatin2(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;
  unsigned __int16 *v10;
  unsigned __int16 *v11;
  unsigned int v12;

  if (a2 > 0x7F)
  {
    if (a2 - 9633 >= 0xFFFFDAFF)
    {
      v5 = (unsigned __int16 *)&cp852_from_uni;
      v6 = (unsigned __int16 *)&unk_182DC98E8;
      do
      {
        v7 = ((char *)v6 - (char *)v5) >> 3;
        v8 = &v5[2 * v7];
        v9 = *v8;
        if (v9 <= a2)
        {
          if (v9 >= a2)
          {
LABEL_19:
            v3 = v5[2 * v7 + 1];
            goto LABEL_3;
          }
          v5 = v8 + 2;
        }
        else
        {
          v6 = v8 - 2;
        }
      }
      while (v5 <= v6);
      if (a2 - 734 >= 0xFFFFFDC2)
      {
        v5 = (unsigned __int16 *)&latin2_from_uni;
        v10 = (unsigned __int16 *)&unk_182DC9A68;
        do
        {
          v7 = ((char *)v10 - (char *)v5) >> 3;
          v11 = &v5[2 * v7];
          v12 = *v11;
          if (v12 <= a2)
          {
            if (v12 >= a2)
              goto LABEL_19;
            v5 = v11 + 2;
          }
          else
          {
            v10 = v11 - 2;
          }
        }
        while (v5 <= v10);
      }
    }
    return 0;
  }
  else
  {
    v3 = a2;
LABEL_3:
    *a3 = v3;
    return 1;
  }
}

BOOL __CFFromDOSLatin2(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = cp852_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSLatin2Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  int v10;
  uint64_t result;
  BOOL v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
  v10 = __CFToDOSLatin2(v9, v9, &v13);
  result = 0;
  if (v10)
    v12 = v13 == 0;
  else
    v12 = 1;
  if (!v12)
  {
    if (a5)
      *a4 = v13;
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFToWinLatin2(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  uint64_t v6;
  unsigned __int16 *v7;
  unsigned int v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  unsigned int v11;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_19;
  }
  if (a2 - 8483 < 0xFFFFDF83)
  {
LABEL_10:
    if (a2 - 734 >= 0xFFFFFDC2)
    {
      v4 = (unsigned __int16 *)&latin2_from_uni;
      v9 = (unsigned __int16 *)&unk_182DC9A68;
      do
      {
        v6 = ((char *)v9 - (char *)v4) >> 3;
        v10 = &v4[2 * v6];
        v11 = *v10;
        if (v11 <= a2)
        {
          if (v11 >= a2)
            goto LABEL_18;
          v4 = v10 + 2;
        }
        else
        {
          v9 = v10 - 2;
        }
      }
      while (v4 <= v9);
    }
    return 0;
  }
  v4 = (unsigned __int16 *)&cp1250_from_uni;
  v5 = (unsigned __int16 *)&unk_182DC9C10;
  while (1)
  {
    v6 = ((char *)v5 - (char *)v4) >> 3;
    v7 = &v4[2 * v6];
    v8 = *v7;
    if (v8 <= a2)
      break;
    v5 = v7 - 2;
LABEL_9:
    if (v4 > v5)
      goto LABEL_10;
  }
  if (v8 < a2)
  {
    v4 = v7 + 2;
    goto LABEL_9;
  }
LABEL_18:
  v3 = v4[2 * v6 + 1];
LABEL_19:
  *a3 = v3;
  return 1;
}

BOOL __CFFromWinLatin2(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = cp1250_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWinLatin2Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  uint64_t v9;
  int v10;
  uint64_t result;
  BOOL v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
  v10 = __CFToWinLatin2(v9, v9, &v13);
  result = 0;
  if (v10)
    v12 = v13 == 0;
  else
    v12 = 1;
  if (!v12)
  {
    if (a5)
      *a4 = v13;
    *a6 = 1;
    return 2;
  }
  return result;
}

uint64_t __CFToISOLatin2(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 734 < 0xFFFFFDC2)
    return 0;
  v5 = (unsigned __int16 *)&latin2_from_uni;
  v6 = (unsigned __int16 *)&unk_182DC9A68;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

uint64_t __CFFromISOLatin2(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0x9F)
    LOWORD(a2) = latin2_to_uni[a2 - 160];
  *a3 = a2;
  return 1;
}

uint64_t __CFToISOLatin2Precompose(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;

  v9 = __CFStringEncodingPrecomposeLatinCharacter_7(a2, a3, 0);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 734) >= 0xFDC2u)
    {
      v11 = (unsigned __int16 *)&latin2_from_uni;
      v12 = (unsigned __int16 *)&unk_182DC9A68;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return 2;
}

uint64_t (**__CFStringEncodingGetThaiConverterDefinition(int a1))()
{
  uint64_t (**v1)();
  uint64_t (**v2)();

  v1 = __CFConverterDOSThai;
  v2 = __CFConverterISOLatinThai;
  if (a1 != 523)
    v2 = 0;
  if (a1 != 1053)
    v1 = v2;
  if (a1 == 21)
    return __CFConverterMacThai;
  else
    return v1;
}

uint64_t __CFToDOSThai(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8365 < 0xFFFFDFF3)
    return 0;
  v5 = (unsigned __int16 *)&DOSThai_from_uni;
  v6 = (unsigned __int16 *)&unk_182DC9F58;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSThai(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = DOSThai_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToThaiPrecompose(uint64_t a1, _WORD *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  if (*a2 != 3661 || a2[1] != 3634)
    return 0;
  if (a5)
    *a4 = -45;
  *a6 = 1;
  return 2;
}

BOOL __CFIsValidCombiningCharacterForThai(int a1)
{
  return a1 == 3634;
}

uint64_t __CFToISOLatinThai(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0xA0)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 3676 < 0xFFFFFFA5)
    return 0;
  v5 = (unsigned __int16 *)&ISOLatinThai_from_uni;
  v6 = (unsigned __int16 *)&unk_182DCA1B4;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromISOLatinThai(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0)
    a2 = ISOLatinThai_to_uni[a2 - 161];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacThai(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4)
{
  unsigned int v4;
  uint64_t result;
  unsigned __int16 v6;
  uint64_t v7;
  char *v8;
  unsigned __int16 *v9;
  uint64_t v10;
  unsigned __int16 *v11;
  unsigned int v12;
  unsigned __int16 *v13;
  unsigned __int16 *v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;

  v4 = *a2;
  if (v4 <= 0x7F)
    goto LABEL_2;
  if (a3 < 2 || (v6 = a2[1] + 1933, v6 > 2u))
  {
    if (v4 - 8483 >= 0xFFFFDF7D)
    {
      v13 = (unsigned __int16 *)&MacThai_from_uni;
      v14 = (unsigned __int16 *)&unk_182DCA45A;
      do
      {
        v15 = ((char *)v14 - (char *)v13) >> 3;
        v16 = &v13[2 * v15];
        v17 = *v16;
        if (v17 <= v4)
        {
          if (v17 >= v4)
          {
            LOBYTE(v4) = v13[2 * v15 + 1];
LABEL_2:
            *a4 = v4;
            return 1;
          }
          v13 = v16 + 2;
        }
        else
        {
          v14 = v16 - 2;
        }
      }
      while (v13 <= v14);
    }
    return 0;
  }
  v7 = (__int16)v6;
  v8 = (char *)*(&off_1E1337538 + (__int16)v6);
  if (*(unsigned __int16 *)v8 > v4)
    return 0;
  v9 = (unsigned __int16 *)&v8[4 * qword_182DCA560[v7]];
  if (*v9 < v4)
    return 0;
  while (1)
  {
    v10 = ((char *)v9 - v8) >> 3;
    v11 = (unsigned __int16 *)&v8[4 * v10];
    v12 = *v11;
    if (v12 <= v4)
      break;
    v9 = v11 - 2;
LABEL_11:
    result = 0;
    if (v8 > (char *)v9)
      return result;
  }
  if (v12 < v4)
  {
    v8 = (char *)(v11 + 2);
    goto LABEL_11;
  }
  *a4 = v8[4 * v10 + 2];
  return 2;
}

BOOL __CFFromMacThai(uint64_t a1, int a2, _WORD *a3)
{
  _BOOL8 result;

  if ((a2 & 0x80) != 0)
  {
    a2 = MacThai_to_uni[a2 - 128];
    result = a2 != 65533;
  }
  else
  {
    result = 1;
  }
  *a3 = a2;
  return result;
}

uint64_t __CFToMacThaiLen(uint64_t a1, __int16 *a2, uint64_t a3)
{
  uint64_t result;
  __int16 v4;

  for (result = 0; a3; --a3)
  {
    v4 = *a2++;
    if ((unsigned __int16)(v4 + 1930) < 0xFFFDu)
      ++result;
  }
  return result;
}

uint64_t __CFFromMacThaiLen(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a3 & ~(a3 >> 63);
}

_QWORD *__mdict_keysOfEntriesWithOptionsPassingTest_block_invoke(_QWORD *result, uint64_t a2)
{
  void *v2;
  BOOL v3;
  _QWORD *v4;
  void *v5;

  v2 = *(void **)(result[6] + 8 * a2);
  if (v2)
    v3 = v2 == &___NSDictionaryM_DeletedMarker;
  else
    v3 = 1;
  if (!v3)
  {
    v4 = result;
    v5 = (void *)_CFAutoreleasePoolPush();
    if ((*(unsigned int (**)(void))(v4[5] + 16))())
    {
      os_unfair_lock_lock((os_unfair_lock_t)v4[8]);
      objc_msgSend((id)v4[4], "addObject:", v2);
      os_unfair_lock_unlock((os_unfair_lock_t)v4[8]);
    }
    return _CFAutoreleasePoolPop(v5);
  }
  return result;
}

void sub_182C26A70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_182C26E40(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_182C27058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 cow_copy_instance_2(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int *v4;
  int *v5;
  int *v6;
  unint64_t v7;
  uint64_t v8;
  int *v9;
  __n128 result;

  v4 = &OBJC_IVAR_____NSFrozenDictionaryM_cow;
  if (a2 == 1)
    v5 = &OBJC_IVAR_____NSDictionaryM_cow;
  else
    v5 = &OBJC_IVAR_____NSFrozenDictionaryM_cow;
  if (a2 == 1)
    v6 = &OBJC_IVAR_____NSDictionaryM_storage;
  else
    v6 = &OBJC_IVAR_____NSFrozenDictionaryM_storage;
  v7 = atomic_load((unint64_t *)(a1 + *v5));
  v8 = *v6;
  if (a4 == 1)
  {
    v4 = &OBJC_IVAR_____NSDictionaryM_cow;
    v9 = &OBJC_IVAR_____NSDictionaryM_storage;
  }
  else
  {
    v9 = &OBJC_IVAR_____NSFrozenDictionaryM_storage;
  }
  atomic_store(v7, (unint64_t *)(a3 + *v4));
  result = *(__n128 *)(a1 + v8);
  *(__n128 *)(a3 + *v9) = result;
  return result;
}

uint64_t cow_copy_storage_2(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  id v9;
  uint64_t v10;
  unint64_t v11;
  id v12;

  v2 = *(_QWORD *)(a1 + 16);
  if ((v2 & 0x1FFFFFF00000000) == 0)
  {
    v5 = 0;
    *(_QWORD *)(a1 + 16) = v2 & 0x3FFFFFFFFFFFFFFLL;
LABEL_18:
    result = 1;
    goto LABEL_19;
  }
  v3 = *(unsigned int *)((char *)__NSDictionarySizes_0 + ((v2 >> 55) & 0x1F8));
  result = (uint64_t)malloc_type_calloc(1uLL, 16 * v3, 0xEEB3C61BuLL);
  v5 = result;
  if (result)
  {
    if (v2 >> 58)
    {
      v6 = 0;
      v7 = *(_QWORD *)(a1 + 8);
      do
      {
        v8 = *(_QWORD *)(v7 + 8 * v6);
        if (v8)
        {
          *(_QWORD *)(v5 + 8 * v6) = v8;
          if ((_UNKNOWN *)v8 != &___NSDictionaryM_DeletedMarker && (v8 & 0x8000000000000000) == 0)
            v9 = (id)v8;
        }
        ++v6;
      }
      while (v3 != v6);
      v10 = 8 * v3;
      do
      {
        v11 = *(_QWORD *)(v7 + v10);
        if (v11)
        {
          if ((v11 & 0x8000000000000000) == 0)
            v12 = (id)v11;
          *(_QWORD *)(v5 + v10) = v11;
        }
        v10 += 8;
        --v3;
      }
      while (v3);
    }
    goto LABEL_18;
  }
LABEL_19:
  *(_QWORD *)(a1 + 8) = v5;
  return result;
}

uint64_t cow_set_cow_2(uint64_t result, unint64_t a2)
{
  atomic_store(a2, (unint64_t *)(result + 24));
  return result;
}

_QWORD *__mdict_keyOfEntryWithOptionsPassingTest_block_invoke(_QWORD *result, uint64_t a2, _BYTE *a3)
{
  void *v3;
  BOOL v4;
  _QWORD *v6;
  void *v7;

  v3 = *(void **)(result[6] + 8 * a2);
  if (v3)
    v4 = v3 == &___NSDictionaryM_DeletedMarker;
  else
    v4 = 1;
  if (!v4)
  {
    v6 = result;
    v7 = (void *)_CFAutoreleasePoolPush();
    if ((*(unsigned int (**)(void))(v6[4] + 16))())
    {
      atomic_store((unint64_t)v3, (unint64_t *)(*(_QWORD *)(v6[5] + 8) + 24));
      *a3 = 1;
    }
    return _CFAutoreleasePoolPop(v7);
  }
  return result;
}

uint64_t _compare_clumpiness_2(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

void *__CFGenerateReport()
{
  int v0;
  char **v1;
  void *v2;
  unint64_t v3;
  char *v4;
  char *v5;
  int v6;
  int v7;
  char **v8;
  const char *v9;
  int v10;
  int v11;
  int v12;
  unint64_t v13;
  uint64_t v15;
  const char **v16;
  int v17;
  char *v18;
  size_t v19;
  time_t v20;
  _QWORD v21[2];
  uint64_t (*v22)(uint64_t, uint64_t);
  void *v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  void *v34[2];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v30 = 0;
  v31 = &v30;
  v32 = 0x2020000000;
  v33 = 0;
  v26 = 0;
  v27 = &v26;
  v28 = 0x2020000000;
  v29 = 1;
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3221225472;
  v22 = ____CFGenerateReport_block_invoke;
  v23 = &unk_1E13375D0;
  v24 = &v30;
  v25 = &v26;
  v64 = 0u;
  v65 = 0u;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  *(_OWORD *)v34 = 0u;
  v35 = 0u;
  v0 = backtrace(v34, 128);
  v1 = backtrace_symbols(v34, v0);
  v2 = 0;
  if (v0 > 0xFFFFFFFA)
  {
    v4 = 0;
    goto LABEL_14;
  }
  v3 = v0 + 5;
  v4 = 0;
  if (v3 >> 61)
    goto LABEL_14;
  v5 = (char *)malloc_type_malloc(8 * v3, 0x10040436913F5uLL);
  v4 = v5;
  if (!v5)
    goto LABEL_12;
  v31[3] = (uint64_t)v5;
  v20 = time(0);
  if (v20 == -1)
    goto LABEL_12;
  v6 = asprintf((char **)v31[3], "%s%25s", "Date/Time:     ", "");
  if (v22((uint64_t)v21, v6))
    goto LABEL_12;
  ctime_r(&v20, (char *)(*(_QWORD *)(v31[3] - 8) + 15));
  v19 = 0;
  if (sysctlbyname("kern.osversion", 0, &v19, 0, 0)
    || (v7 = asprintf((char **)v31[3], "%s%*s", "OS Version:    ", v19, ""), v22((uint64_t)v21, v7))
    || sysctlbyname("kern.osversion", (void *)(*(_QWORD *)(v31[3] - 8) + 15), &v19, 0, 0)
    || (*(_BYTE *)(*(_QWORD *)(v31[3] - 8) + v19 + 14) = 10,
        v8 = (char **)v31[3],
        v9 = getprogname(),
        v10 = asprintf(v8, "%s%s\n", "Application:   ", v9),
        v22((uint64_t)v21, v10))
    || (v11 = asprintf((char **)v31[3], "\n"), v22((uint64_t)v21, v11))
    || (v12 = asprintf((char **)v31[3], "Backtrace:\n"), v22((uint64_t)v21, v12)))
  {
LABEL_12:
    v2 = 0;
    goto LABEL_14;
  }
  if (v0 < 1)
  {
LABEL_25:
    v2 = malloc_type_malloc(v27[3], 0xB346118AuLL);
    if (v2 && (unint64_t)v4 < v31[3])
    {
      v18 = v4;
      do
      {
        v18 += 8;
        __stpcpy_chk();
      }
      while ((unint64_t)v18 < v31[3]);
    }
LABEL_14:
    if (!v1)
      goto LABEL_16;
    goto LABEL_15;
  }
  v15 = v0;
  v16 = (const char **)v1;
  while (1)
  {
    v17 = asprintf((char **)v31[3], "%s\n", *v16);
    if (v22((uint64_t)v21, v17))
      break;
    ++v16;
    if (!--v15)
      goto LABEL_25;
  }
  v2 = 0;
LABEL_15:
  free(v1);
LABEL_16:
  if (v4)
  {
    while (1)
    {
      v13 = v31[3];
      if ((unint64_t)v4 >= v13)
        break;
      v31[3] = v13 - 8;
      free(*(void **)(v13 - 8));
    }
    free(v4);
  }
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  return v2;
}

void sub_182C276C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v14;
  va_list va;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a13);
  va_start(va, a13);
  v14 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void bufferWrite_0(uint64_t a1, _BYTE *__src, uint64_t a3)
{
  size_t v3;
  int v6;
  size_t v7;
  uint64_t v8;
  int v9;

  if (a3)
  {
    v3 = a3;
    if (a3 < 8144)
    {
      v6 = *(_DWORD *)(a1 + 40);
      if (8144 - v6 >= a3)
        v7 = a3;
      else
        v7 = 8144 - v6;
      if (*(_QWORD *)a1 || *(_QWORD *)(a1 + 8))
      {
        v8 = v6;
        switch(v7)
        {
          case 1uLL:
            goto LABEL_13;
          case 2uLL:
            goto LABEL_12;
          case 3uLL:
            goto LABEL_11;
          case 4uLL:
            *(_BYTE *)(v6 + a1 + 47) = __src[3];
            v6 = *(_DWORD *)(a1 + 40);
LABEL_11:
            *(_BYTE *)(a1 + v6 + 46) = __src[2];
            v6 = *(_DWORD *)(a1 + 40);
LABEL_12:
            *(_BYTE *)(a1 + v6 + 45) = __src[1];
            v8 = *(int *)(a1 + 40);
LABEL_13:
            *(_BYTE *)(a1 + v8 + 44) = *__src;
            break;
          default:
            memmove((void *)(a1 + v6 + 44), __src, v7);
            break;
        }
      }
      v9 = *(_DWORD *)(a1 + 40) + v7;
      *(_DWORD *)(a1 + 40) = v9;
      if (v9 == 8144)
      {
        writeBytes_0(a1, (void *)(a1 + 44), 8144);
        if (*(_QWORD *)a1 || *(_QWORD *)(a1 + 8))
        {
          v3 -= v7;
          memmove((void *)(a1 + 44), &__src[v7], v3);
        }
        else
        {
          LODWORD(v3) = v3 - v7;
        }
        *(_DWORD *)(a1 + 40) = v3;
      }
    }
    else
    {
      writeBytes_0(a1, (void *)(a1 + 44), *(int *)(a1 + 40));
      *(_DWORD *)(a1 + 40) = 0;
      writeBytes_0(a1, __src, v3);
    }
  }
}

void writeBytes_0(uint64_t a1, void *__src, uint64_t __len)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (__len >= 1)
  {
    v14 = v5;
    v15 = v4;
    v16 = v3;
    if (!*(_QWORD *)(a1 + 24))
    {
      v12 = *(_QWORD *)(a1 + 8);
      if (v12)
      {
        v13 = *(_QWORD *)(a1 + 32);
        if (__CFADD__(__len, v13) || *(_QWORD *)(a1 + 16) < (unint64_t)(v13 + __len))
        {
          *(_QWORD *)(a1 + 24) = __CFPropertyListCreateError(3851, CFSTR("Binary property list writing could not be completed because databytes is full."), v6, v14, v15, v16, v7, v8);
          return;
        }
        memmove((void *)(v12 + v13), __src, __len);
      }
      if (*(_QWORD *)a1)
        CFDataAppendBytes(*(CFMutableDataRef *)a1, (const UInt8 *)__src, __len);
      *(_QWORD *)(a1 + 32) += __len;
    }
  }
}

const __CFString *_CFGetPlatformName()
{
  return CFSTR("iphoneos");
}

const __CFString *_CFGetAlternatePlatformName()
{
  return CFSTR("macos");
}

uint64_t _CFBundleSupportedPlatformName(const __CFString *a1, CFRange rangeToSearch)
{
  return CFStringFindWithOptions(a1, CFSTR("iphoneos"), rangeToSearch, 8uLL, 0);
}

CFMutableDictionaryRef _CFBundleLoadLimitedInfoDictionary(uint64_t a1, const __CFSet *a2)
{
  CFMutableDictionaryRef result;
  CFTypeRef v4[2];

  v4[1] = *(CFTypeRef *)MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 24))
    _CFBundleLoadLimitedInfoDictionary_cold_2();
  v4[0] = 0;
  result = _CFBundleCopyInfoDictionaryInDirectoryWithVersion((CFAllocatorRef)&__kCFAllocatorSystemDefault, *(CFURLRef *)(a1 + 16), v4, a2, *(unsigned __int8 *)(a1 + 55), *(unsigned __int8 *)(a1 + 53));
  *(_QWORD *)(a1 + 24) = result;
  if (*(_QWORD *)(a1 + 216))
    _CFBundleLoadLimitedInfoDictionary_cold_1();
  *(CFTypeRef *)(a1 + 216) = v4[0];
  return result;
}

uint64_t _CFBundleGetPackageInfoInDirectory(int a1, CFURLRef baseURL, int *a3, _DWORD *a4)
{
  return _CFBundleGetPackageInfoInDirectoryWithInfoDictionary(baseURL, 0, a3, a4);
}

void _CFBundleReleaseStringsSources_0(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;

  v2 = *(const void **)a1;
  if (v2)
    CFRelease(v2);
  v3 = *(const void **)(a1 + 8);
  if (v3)
    CFRelease(v3);
  v4 = *(const void **)(a1 + 16);
  if (v4)
    CFRelease(v4);
  v5 = *(const void **)(a1 + 24);
  if (v5)
    CFRelease(v5);
  v6 = *(const void **)(a1 + 32);
  if (v6)
    CFRelease(v6);
  v7 = *(const void **)(a1 + 40);
  if (v7)
    CFRelease(v7);
  v8 = *(const void **)(a1 + 48);
  if (v8)
    CFRelease(v8);
  v9 = *(const void **)(a1 + 56);
  if (v9)
    CFRelease(v9);
}

CFDictionaryRef _CFBundleCreateFilteredInfoPlist(uint64_t a1, void *a2, char a3)
{
  const __CFURL *v6;
  const __CFURL *v7;
  uint64_t v8;
  const __CFURL *v9;
  __CFString *v10;
  int v11;
  int v12;
  const __CFData *v13;
  void *FilteredInfoPlistWithData;
  size_t v16;
  void *v17[2];

  v17[1] = *(void **)MEMORY[0x1E0C80C00];
  v6 = (const __CFURL *)_CFBundleCopyInfoPlistURL(a1);
  if (!v6)
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v7 = v6;
  v8 = *(unsigned __int8 *)(a1 + 55);
  v9 = CFURLCopyAbsoluteURL(v6);
  v10 = (__CFString *)CFURLCopyFileSystemPath(v9, kCFURLPOSIXPathStyle);
  CFRelease(v9);
  if (v10
    && (v16 = 0,
        v17[0] = 0,
        v11 = a3 & 1,
        v12 = _CFReadMappedFromFile(v10, v11, 0, v17, (off_t *)&v16, 0),
        CFRelease(v10),
        v12))
  {
    v13 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)v17[0], v16, (CFAllocatorRef)&__kCFAllocatorNull);
    FilteredInfoPlistWithData = (void *)_CFBundleCreateFilteredInfoPlistWithData(v13, a2, v8, 0, (uint64_t)v7);
    CFRelease(v13);
    if (v11)
      munmap(v17[0], v16);
    else
      free(v17[0]);
  }
  else
  {
    FilteredInfoPlistWithData = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  CFRelease(v7);
  return (CFDictionaryRef)FilteredInfoPlistWithData;
}

CFDictionaryRef _CFBundleCreateFilteredLocalizedInfoPlist(uint64_t a1, void *a2, void *a3, char a4)
{
  const __CFArray *v7;
  const __CFData *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  const void *v13;
  const __CFDictionary *FilteredInfoPlistWithData;
  CFMutableDictionaryRef v15;
  _OWORD v16[4];
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  void *values[2];

  values[1] = *(void **)MEMORY[0x1E0C80C00];
  values[0] = a3;
  if (!a1)
    return CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (a3)
    v7 = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
  else
    v7 = 0;
  v22 = 0;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  _CFBundleGetStringsSources(a1, a4 & 1, CFSTR("InfoPlist"), v7, (uint64_t)&v18);
  if (v7)
    CFRelease(v7);
  v9 = (const __CFData *)v19;
  if ((_QWORD)v19)
  {
    v10 = *(unsigned __int8 *)(a1 + 55);
    v11 = v18;
    v12 = a2;
    v13 = 0;
  }
  else
  {
    v9 = (const __CFData *)*((_QWORD *)&v21 + 1);
    v10 = *(unsigned __int8 *)(a1 + 55);
    v13 = values[0];
    v12 = a2;
    v11 = 0;
  }
  FilteredInfoPlistWithData = (const __CFDictionary *)_CFBundleCreateFilteredInfoPlistWithData(v9, v12, v10, v13, v11);
  v16[2] = v20;
  v16[3] = v21;
  v17 = v22;
  v16[0] = v18;
  v16[1] = v19;
  _CFBundleReleaseStringsSources_0((uint64_t)v16);
  if (!FilteredInfoPlistWithData)
    return 0;
  v15 = _parseBundleStrings(a1, FilteredInfoPlistWithData);
  CFRelease(FilteredInfoPlistWithData);
  return v15;
}

CFTypeRef _CFBundleCreateFilteredInfoPlistWithData(const __CFData *a1, void *a2, uint64_t a3, const void *a4, uint64_t a5)
{
  CFIndex Count;
  const __CFSet *Mutable;
  uint64_t v11;
  CFIndex v12;
  CFMutableSetRef v13;
  BOOL v14;
  CFTypeID TypeID;
  CFTypeID v16;
  void *v17;
  void *Value;
  CFTypeID v19;
  NSObject *v20;
  CFTypeRef cf;
  _QWORD v23[6];
  _QWORD v24[6];

  v24[5] = *MEMORY[0x1E0C80C00];
  CFSetApply(a2, (uint64_t)&__block_literal_global_119);
  Count = CFSetGetCount((CFSetRef)a2);
  Mutable = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, Count, &kCFTypeSetCallBacks);
  v11 = MEMORY[0x1E0C809B0];
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 0x40000000;
  v24[2] = ___CFBundleCreateFilteredInfoPlistWithData_block_invoke_2;
  v24[3] = &__block_descriptor_tmp_133;
  v24[4] = Mutable;
  CFSetApply(a2, (uint64_t)v24);
  if (a4)
  {
    v12 = CFSetGetCount(Mutable);
    v13 = CFSetCreateMutable((CFAllocatorRef)&__kCFAllocatorSystemDefault, v12, &kCFTypeSetCallBacks);
    v23[0] = v11;
    v23[1] = 0x40000000;
    v23[2] = ___CFBundleCreateFilteredInfoPlistWithData_block_invoke_3;
    v23[3] = &__block_descriptor_tmp_136;
    v23[4] = a4;
    v23[5] = v13;
    CFSetApply(Mutable, (uint64_t)v23);
    CFRelease(Mutable);
    Mutable = v13;
  }
  cf = 0;
  if (_CFPropertyListCreateFiltered((const __CFAllocator *)&__kCFAllocatorSystemDefault, a1, 1, Mutable, &cf, 0))v14 = cf == 0;
  else
    v14 = 1;
  if (v14)
    goto LABEL_14;
  TypeID = CFDictionaryGetTypeID();
  v16 = CFGetTypeID(cf);
  v17 = (void *)cf;
  if (TypeID != v16)
  {
    CFRelease(cf);
    v20 = _CFBundleResourceLogger();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      _CFBundleCreateFilteredInfoPlistWithData_cold_1(a5, (uint64_t)a2, v20);
LABEL_14:
    cf = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    goto LABEL_18;
  }
  if (a4)
  {
    Value = (void *)CFDictionaryGetValue((CFDictionaryRef)cf, a4);
    if (Value && (v17 = Value, v19 = CFDictionaryGetTypeID(), v19 == CFGetTypeID(v17)))
    {
      CFRetain(v17);
      CFRelease(cf);
    }
    else
    {
      CFRelease(cf);
      v17 = CFDictionaryCreate((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    }
    cf = v17;
  }
  _CFBundleInfoPlistProcessInfoDictionary(v17);
LABEL_18:
  CFRelease(Mutable);
  return cf;
}

void _CFBundleLogLoadingInfoPlistError(uint64_t a1, CFErrorRef err)
{
  CFErrorDomain Domain;
  CFIndex Code;
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  CFErrorDomain v10;
  __int16 v11;
  CFIndex v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  Domain = CFErrorGetDomain(err);
  Code = CFErrorGetCode(err);
  v6 = _CFBundleResourceLogger();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    v7 = 134349570;
    v8 = a1;
    v9 = 2114;
    v10 = Domain;
    v11 = 2050;
    v12 = Code;
    _os_log_error_impl(&dword_182A8C000, v6, OS_LOG_TYPE_ERROR, "There was an error parsing the Info.plist for the bundle at URL <%{public}p>: %{public}@ - %{public}ld", (uint8_t *)&v7, 0x20u);
  }
}

void OUTLINED_FUNCTION_0_35(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_1_24(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 2u);
}

void OUTLINED_FUNCTION_0_36(uint64_t a1, const __CFString *a2)
{
  uint64_t v2;

  _CFThrowFormattedException(v2, a2);
}

uint64_t _CFPrefsSetSynchronizeIsSynchronous(uint64_t result)
{
  _CFPrefsSynchronizeIsSynchronous = (_DWORD)result != 0;
  return result;
}

void _CFPrefsImpersonateApplicationWithIdentifierAndPID()
{
  NSObject *v0;

  v0 = _CFOSLog();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_FAULT))
    _CFPrefsImpersonateApplicationWithIdentifierAndPID_cold_1();
}

uint64_t _CFPrefsImpersonateApplicationWithIdentifierAndAuditToken(uint64_t a1, __int128 *a2)
{
  __int128 v2;

  v2 = a2[1];
  _CFPrefsAuditTokenToImpersonate = *a2;
  *(_OWORD *)&qword_1EDCD15CC = v2;
  return _CFPrefsImpersonateApplicationWithIdentifierAndContainerDataPath(a1, 0);
}

void __Block_byref_object_copy__7(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__7(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t _CFPrefSetInvalidPropertyListDeletionEnabled(uint64_t result)
{
  atomic_store((_DWORD)result != 0, requestInvalidPropertyListDeletion);
  return result;
}

void sub_182C28E64(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

uint64_t applyDictBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_182C290D4(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182C2950C(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182C298E4(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_182C29DB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _approximateSizeOfPlistValue(__CFString *cf, CFStringRef *a2, CFIndex *a3)
{
  CFTypeID v6;
  CFIndex Length;
  BOOL v8;
  char v9;
  CFIndex v10;
  CFStringRef v11;
  uint64_t v12;
  const __CFString *v13;
  CFIndex ByteSize;
  CFIndex *p_usedBufLen;
  CFIndex Count;
  CFIndex v17;
  CFIndex *v18;
  CFIndex v19;
  CFIndex v20;
  _QWORD v22[6];
  _QWORD v23[6];
  CFIndex usedBufLen;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  CFRange v30;

  v29 = *MEMORY[0x1E0C80C00];
  if (a2 && a3)
    _approximateSizeOfPlistValue_cold_1();
  if (!cf)
    return 0;
  v6 = CFGetTypeID(cf);
  v25 = 0;
  v26 = &v25;
  v27 = 0x2020000000;
  v28 = 0;
  switch(v6)
  {
    case 7uLL:
      Length = CFStringGetLength(cf);
      usedBufLen = 0;
      v30.location = 0;
      v30.length = Length;
      if (CFStringGetBytes(cf, v30, 0x600u, 0, 0, 0, 0, &usedBufLen))
        v8 = usedBufLen == Length;
      else
        v8 = 0;
      v9 = !v8;
      v10 = Length << v9;
      v26[3] = v10;
      if (a2)
      {
        v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("string value, approximate encoded size: %ld"), v10);
        goto LABEL_31;
      }
      break;
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x11uLL:
      break;
    case 0x10uLL:
      if (a2)
      {
        v13 = CFSTR("deleted value");
        goto LABEL_34;
      }
      break;
    case 0x12uLL:
      usedBufLen = 0;
      p_usedBufLen = &usedBufLen;
      if (a3)
        p_usedBufLen = a3;
      v23[0] = MEMORY[0x1E0C809B0];
      v23[1] = 3221225472;
      v23[2] = ___approximateSizeOfPlistValue_block_invoke;
      v23[3] = &unk_1E13379F8;
      v23[4] = &v25;
      v23[5] = p_usedBufLen;
      CFDictionaryApply(cf, (uint64_t)v23);
      if (a2)
      {
        Count = CFDictionaryGetCount((CFDictionaryRef)cf);
        v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("dictionary value, count: %ld, total nested objects: %ld, approximate encoded size: %ld"), Count, usedBufLen, v26[3]);
        goto LABEL_31;
      }
      break;
    case 0x13uLL:
      usedBufLen = 0;
      v17 = CFArrayGetCount((CFArrayRef)cf);
      v18 = &usedBufLen;
      v22[0] = MEMORY[0x1E0C809B0];
      v22[1] = 3221225472;
      if (a3)
        v18 = a3;
      v22[2] = ___approximateSizeOfPlistValue_block_invoke_2;
      v22[3] = &unk_1E1335DC8;
      v22[4] = &v25;
      v22[5] = v18;
      CFArrayApply((uint64_t)cf, 0, v17, (uint64_t)v22);
      if (a2)
      {
        v19 = CFArrayGetCount((CFArrayRef)cf);
        v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("array value, count: %ld, tested nested objects: %ld, approximate encoded size: %ld"), v19, usedBufLen, v26[3]);
        goto LABEL_31;
      }
      break;
    case 0x14uLL:
      v20 = CFDataGetLength((CFDataRef)cf);
      v26[3] = v20;
      if (a2)
      {
        v11 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("data value, size: %ld"), v20);
LABEL_31:
        *a2 = v11;
      }
      break;
    case 0x15uLL:
      v28 = 1;
      if (a2)
      {
        v13 = CFSTR("BOOLean value");
        goto LABEL_34;
      }
      break;
    case 0x16uLL:
      ByteSize = CFNumberGetByteSize((CFNumberRef)cf);
      v26[3] = ByteSize;
      if (a2)
      {
        v13 = CFSTR("number value");
        goto LABEL_34;
      }
      break;
    default:
      if (v6 == 42)
      {
        v28 = 8;
        if (a2)
        {
          v13 = CFSTR("date value");
LABEL_34:
          *a2 = v13;
        }
      }
      break;
  }
  if (a3)
    ++*a3;
  v12 = v26[3];
  _Block_object_dispose(&v25, 8);
  return v12;
}

void sub_182C2A30C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 72), 8);
  _Unwind_Resume(a1);
}

uint64_t _compareSizes(unint64_t a1, unint64_t a2)
{
  uint64_t v2;

  v2 = 1;
  if (a1 >= a2)
    v2 = -1;
  if (a1 == a2)
    return 0;
  else
    return v2;
}

_QWORD *_CFPrefsTestOversizeWarning(const void *a1, const void **a2, const void **a3, CFIndex a4)
{
  return -[_CFPrefsOversizedPlistDescription initWithDict:setKeys:andValues:count:]([_CFPrefsOversizedPlistDescription alloc], a1, a2, a3, a4);
}

uint64_t ___approximateSizeOfPlistValue_block_invoke(uint64_t a1, CFTypeRef cf, const void *a3)
{
  uint64_t v5;
  uint64_t result;

  v5 = _approximateSizeOfPlistValue(cf);
  result = _approximateSizeOfPlistValue(a3);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += result + v5;
  return result;
}

uint64_t ___approximateSizeOfPlistValue_block_invoke_2(uint64_t a1, CFTypeRef cf)
{
  uint64_t result;

  result = _approximateSizeOfPlistValue(cf);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += result;
  return result;
}

void OUTLINED_FUNCTION_0_37(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_3_9(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_5_5(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0x16u);
}

void OUTLINED_FUNCTION_8_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void OUTLINED_FUNCTION_9_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 2u);
}

void OUTLINED_FUNCTION_10_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_13_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x12u);
}

uint64_t (**__CFStringEncodingGetGreekConverterDefinition(int a1, uint64_t (*a2)(uint64_t)))()
{
  if (!__CFStringEncodingPrecomposeLatinCharacter_8)
  {
    __CFStringEncodingPrecomposeLatinCharacter_8 = (_UNKNOWN *)a2(4);
    __CFStringEncodingIsValidCombiningCharacterForLatin1_5 = (_UNKNOWN *)a2(3);
  }
  if (a1 > 1028)
  {
    if (a1 != 1029)
    {
      if (a1 == 1283)
        return __CFConverterWindowsGreek;
      return 0;
    }
    return __CFConverterDOSGreek;
  }
  else
  {
    if (a1 != 6)
    {
      if (a1 == 519)
        return __CFConverterISOLatinGreek;
      return 0;
    }
    return __CFConverterMacGreek;
  }
}

uint64_t __CFToISOLatinGreek(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0xA0)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8218 < 0xFFFFE089)
    return 0;
  v5 = (unsigned __int16 *)&ISOLatinGreek_from_uni;
  v6 = (unsigned __int16 *)&unk_182DCAAB8;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromISOLatinGreek(uint64_t a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 0xA0)
    a2 = ISOLatinGreek_to_uni[a2 - 161];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToISOLatinGreekPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v16[0] = 0;
  v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0xA0)
  {
    if ((unsigned __int16)(v9 - 8218) >= 0xE089u)
    {
      v11 = (unsigned __int16 *)&ISOLatinGreek_from_uni;
      v12 = (unsigned __int16 *)&unk_182DCAAB8;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return v16[0];
}

uint64_t __CFIsValidCombiningCharacterForGreek()
{
  return __CFStringEncodingIsValidCombiningCharacterForLatin1_5();
}

uint64_t __CFPrecomposeGreekCharacter(unsigned __int16 *a1, uint64_t a2, _QWORD *a3)
{
  unsigned int v3;
  unsigned int v5;
  unsigned int *v6;
  unsigned int *v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v10;

  *a3 = 2;
  v3 = *a1;
  if (v3 <= 0x7F)
    return __CFStringEncodingPrecomposeLatinCharacter_8();
  v5 = a1[1] | (v3 << 16);
  if (v5 > 0x3D20308)
    return 65533;
  v6 = (unsigned int *)&__CFGreekPrecompMap;
  v7 = (unsigned int *)&unk_182DCAC3C;
  while (1)
  {
    v8 = ((char *)v7 - (char *)v6) >> 4;
    v9 = &v6[2 * v8];
    if (*v9 <= v5)
      break;
    v7 = v9 - 2;
LABEL_9:
    if (v6 > v7)
      return 65533;
  }
  if (*v9 < v5)
  {
    v6 = v9 + 2;
    goto LABEL_9;
  }
  v10 = LOWORD(v6[2 * v8 + 1]);
  if (a2 >= 3 && a1[2] == 769)
  {
    if ((_DWORD)v10 == 971)
    {
      *a3 = 3;
      return 944;
    }
    else if ((_DWORD)v10 == 970)
    {
      *a3 = 3;
      return 912;
    }
  }
  return v10;
}

uint64_t __CFToMacGreek(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8806 < 0xFFFFDE3A)
    return 0;
  v5 = (unsigned __int16 *)&MacGreek_from_uni;
  v6 = (unsigned __int16 *)&unk_182DCAE40;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromMacGreek(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = MacGreek_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToMacGreekPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v16[0] = 0;
  v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8806) >= 0xDE3Au)
    {
      v11 = (unsigned __int16 *)&MacGreek_from_uni;
      v12 = (unsigned __int16 *)&unk_182DCAE40;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return v16[0];
}

uint64_t __CFToDOSGreek(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 9633 < 0xFFFFDAFF)
    return 0;
  v5 = (unsigned __int16 *)&DOSGreek_from_uni;
  v6 = (unsigned __int16 *)&unk_182DCB140;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromDOSGreek(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = DOSGreek_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToDOSGreekPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v16[0] = 0;
  v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 9633) >= 0xDAFFu)
    {
      v11 = (unsigned __int16 *)&DOSGreek_from_uni;
      v12 = (unsigned __int16 *)&unk_182DCB140;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return v16[0];
}

uint64_t __CFToWindowsGreek(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  char v3;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned __int16 *v8;
  unsigned int v9;

  if (a2 <= 0x7F)
  {
    v3 = a2;
    goto LABEL_3;
  }
  if (a2 - 8483 < 0xFFFFDF7D)
    return 0;
  v5 = (unsigned __int16 *)&WindowsGreek_from_uni;
  v6 = (unsigned __int16 *)&unk_182DCB3FC;
  while (1)
  {
    v7 = ((char *)v6 - (char *)v5) >> 3;
    v8 = &v5[2 * v7];
    v9 = *v8;
    if (v9 <= a2)
      break;
    v6 = v8 - 2;
LABEL_10:
    if (v5 > v6)
      return 0;
  }
  if (v9 < a2)
  {
    v5 = v8 + 2;
    goto LABEL_10;
  }
  v3 = v5[2 * v7 + 1];
LABEL_3:
  *a3 = v3;
  return 1;
}

BOOL __CFFromWindowsGreek(uint64_t a1, int a2, _WORD *a3)
{
  if ((a2 & 0x80) != 0)
    a2 = WindowsGreek_to_uni[a2 - 128];
  *a3 = a2;
  return a2 != 65533;
}

uint64_t __CFToWindowsGreekPrecompose(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _BYTE *a4, uint64_t a5, _QWORD *a6)
{
  unsigned int v9;
  unsigned __int16 *v11;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  unsigned int v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v16[0] = 0;
  v9 = __CFPrecomposeGreekCharacter(a2, a3, v16);
  if (v9 > 0x7F)
  {
    if ((unsigned __int16)(v9 - 8483) >= 0xDF7Du)
    {
      v11 = (unsigned __int16 *)&WindowsGreek_from_uni;
      v12 = (unsigned __int16 *)&unk_182DCB3FC;
      while (1)
      {
        v13 = ((char *)v12 - (char *)v11) >> 3;
        v14 = &v11[2 * v13];
        v15 = *v14;
        if (v15 <= v9)
        {
          if (v15 >= v9)
          {
            LOBYTE(v9) = v11[2 * v13 + 1];
            goto LABEL_2;
          }
          v11 = v14 + 2;
        }
        else
        {
          v12 = v14 - 2;
        }
        if (v11 > v12)
          return 0;
      }
    }
    return 0;
  }
LABEL_2:
  if (!(_BYTE)v9)
    return 0;
  if (a5)
    *a4 = v9;
  *a6 = 1;
  return v16[0];
}

void __CFArrayHandleOutOfMemory(uint64_t a1)
{
  CFStringRef v1;

  v1 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("Attempt to allocate %ld bytes for CFArray failed"), a1);
  _CFRaiseMemoryException((uint64_t)v1);
}

#error "182C2AF14: call analysis failed (funcsize=5)"

void __CFAttributedStringCopyDescription_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Ridiculous size count";
  __break(1u);
}

void CFAttributedStringSetAttributes_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Ridiculous size count";
  __break(1u);
}

uint64_t __CFReallocationFailed(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  int v5;
  CFStringRef v6;
  char v7;
  char __str[256];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v7 = 0;
  if (!a3 || (result = (*(uint64_t (**)(uint64_t, uint64_t, char *))(a3 + 16))(a3, a1, &v7), !v7))
  {
    bzero(__str, 0x100uLL);
    v5 = snprintf(__str, 0x100uLL, "Failed to grow buffer to %ld", a2);
    v6 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)&__kCFAllocatorSystemDefault, (const UInt8 *)__str, v5, 0x600u, 0, 0);
    if (!v6)
      _CFRaiseMemoryException((uint64_t)CFSTR("Failed to grow buffer - malloc failure"));
    _CFRaiseMemoryException((uint64_t)v6);
  }
  return result;
}

void sub_182C2B01C()
{
  const void *v0;

  CFRelease(v0);
  JUMPOUT(0x182C2B024);
}

uint64_t sub_182C2B0C4()
{
  return 0;
}

void __CFGetSignatureROMEntryAtIndex_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to access an invalid NSMethodSignature index";
  __break(1u);
}

void __CFRelativeDateTimeFormatterDeallocate_cold_1()
{
  __assert_rtn("__CFRelativeDateTimeFormatterDeallocate", "CFRelativeDateTimeFormatter.c", 80, "cf != NULL");
}

void __CFRelativeDateTimeFormatterCopyDescription_cold_1()
{
  __assert_rtn("__CFRelativeDateTimeFormatterCopyDescription", "CFRelativeDateTimeFormatter.c", 86, "cf != NULL");
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Invalid CFRelativeDateTimeFormatterStyle";
  __break(1u);
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"Invalid CFCalendarUnit";
  __break(1u);
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_3()
{
  qword_1EDCD1038 = (uint64_t)"Invalid CFRelativeDateTimeFormatterStyle";
  __break(1u);
}

void _CFRelativeDateTimeFormatterCreateStringWithCalendarUnit_cold_4()
{
  qword_1EDCD1038 = (uint64_t)"Invalid CFRelativeDateTimeFormattingContext";
  __break(1u);
}

void _CFCreateArrayStorage_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"failed to create array buffer";
  __break(1u);
}

void _CFCreateArrayStorage_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"size unreasonably big";
  __break(1u);
}

void __NSArrayM_new_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"size unreasonably big";
  __break(1u);
}

void __CFBinaryPlistCreateObjectFiltered_cold_1(os_log_t log)
{
  uint8_t v1[8];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  *(_WORD *)v1 = 0;
  _os_log_fault_impl(&dword_182A8C000, log, OS_LOG_TYPE_FAULT, "Too many nested arrays or dictionaries", v1, 2u);
}

void _CFURLCreateResolvedDirectoryWithString_cold_1(NSObject *a1)
{
  int v2;
  _DWORD v3[2];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl(&dword_182A8C000, a1, OS_LOG_TYPE_ERROR, "Unable to resolve directory (%d)", (uint8_t *)v3, 8u);
  OUTLINED_FUNCTION_1();
}

void _CFBundleCreate_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_182A8C000, v0, v1, "Unable to create bundle at URL (%@): normalized URL null", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1();
}

void _CFBundleCreate_cold_2()
{
  int v0;
  os_log_t v1;
  uint8_t v2[12];
  __int16 v3;
  int v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_2();
  v3 = 1024;
  v4 = v0;
  _os_log_debug_impl(&dword_182A8C000, v1, OS_LOG_TYPE_DEBUG, "Unable to create bundle at URL (%@): does not exist or not a directory (%d)", v2, 0x12u);
  OUTLINED_FUNCTION_1();
}

void _CFBundleCreate_cold_3()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_182A8C000, v0, v1, "Unable to create bundle at URL (%@): malloc failure", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1();
}

void _CFBundleCreate_cold_4()
{
  __assert_rtn("_CFBundleCreate", "CFBundle.c", 1015, "!addToTables");
}

void _CFBundleCreate_cold_5()
{
  int v0;
  os_log_t v1;
  uint8_t v2[12];
  __int16 v3;
  int v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_2();
  v3 = 1024;
  v4 = v0;
  _os_log_error_impl(&dword_182A8C000, v1, OS_LOG_TYPE_ERROR, "Unable to create bundle at URL (%@): unable to create file system representation of URL (%d)", v2, 0x12u);
  OUTLINED_FUNCTION_1();
}

void _CFBundleLoadExecutableAndReturnError_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_182A8C000, v0, v1, "Cannot recognize type of executable for %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1();
}

void _CFBundleLoadExecutableAndReturnError_cold_2()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_182A8C000, v0, v1, "Attempt to load executable of a type that cannot be dynamically loaded for %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1();
}

void _CFBundleLoadExecutableAndReturnError_cold_3()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_182A8C000, v0, v1, "Cannot find executable for %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1();
}

void _CFBundleEnsureBundleExistsForImagePath_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_3(&dword_182A8C000, v0, v1, "Ensure bundle exists failed for path %{private}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1();
}

void _CFBundleEnsureBundleExistsForImagePath_cold_2()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_3(&dword_182A8C000, v0, v1, "Ensure bundle %{private}@ set loaded fallback", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1();
}

void _CFBundleAddToTablesLocked_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_3(&dword_182A8C000, v0, v1, "More than one bundle with the same identifier has been added: %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1();
}

void _CFBundleGetBundleVersionForURL_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_1_0();
}

void _CFBundleGetBundleVersionForURL_cold_2()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_1_0();
}

void _CFBundleGetBundleVersionForURL_cold_3()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_0_1(&dword_182A8C000, v0, v1, "Extensions of wrapped bundles did not match at %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_0();
}

void _CFBundleGetBundleVersionForURL_cold_4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_0();
  OUTLINED_FUNCTION_0_1(&dword_182A8C000, v0, v1, "Extensions of wrapped bundles did not match (one missing) at %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_0();
}

void CFCharacterSetGetPredefined_cold_1()
{
  CFLog(3, CFSTR("%s: Unknown builtin type %ld"));
  qword_1EDCD1038 = (uint64_t)"Unknown builtin CFCharacterSet type";
  __break(1u);
}

void CFCharacterSetAddCharactersInString_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetInvert_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetIntersect_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetAddCharactersInRange_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetRemoveCharactersInRange_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetRemoveCharactersInString_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

void CFCharacterSetUnion_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Immutable character set passed to mutable function";
  __break(1u);
}

uint64_t sub_182C2BB00()
{
  return 0;
}

void __CFDataHandleOutOfMemory(uint64_t a1)
{
  CFStringRef v1;

  if ((unint64_t)(a1 - 1) > 0x3FFFFFFFFFELL)
    v1 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("Attempt to allocate %ld bytes for NS/CFData failed. Maximum size: %lld"), a1, 0x3FFFFFFFFFFLL);
  else
    v1 = CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("Attempt to allocate %ld bytes for NS/CFData failed"), a1);
  _CFRaiseMemoryException((uint64_t)v1);
}

#error "182C2BB80: call analysis failed (funcsize=5)"

void CFDataReplaceBytes_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_3_0("__CFDataValidateRange", "CFData.c", a3, "range.location <= dataLength");
}

void CFDataReplaceBytes_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"Negative buffer length passed to CFDataReplaceBytes";
  __break(1u);
}

void CFDataReplaceBytes_cold_3()
{
  qword_1EDCD1038 = (uint64_t)"Invalid range passed to CFDataReplaceBytes";
  __break(1u);
}

void CFDataReplaceBytes_cold_4()
{
  qword_1EDCD1038 = (uint64_t)"Invalid length passed to CFDataReplaceBytes when newBytes == NULL";
  __break(1u);
}

void CFDataReplaceBytes_cold_5()
{
  qword_1EDCD1038 = (uint64_t)"fixed-capacity CFMutableData is full";
  __break(1u);
}

void CFDataReplaceBytes_cold_6()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "range.location out of range (>len)", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFDataReplaceBytes_cold_7(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_6("__CFDataValidateRange", "CFData.c", a3, "range.location + range.length <= dataLength");
}

void CFDataReplaceBytes_cold_8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "ending index out of bounds", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFDataReplaceBytes_cold_9(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_5("__CFDataValidateRange", "CFData.c", a3, "range.length >= 0");
}

void CFDataReplaceBytes_cold_10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "length cannot be less than zero", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFDataReplaceBytes_cold_11(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_4("__CFDataValidateRange", "CFData.c", a3, "range.location >= 0");
}

void CFDataReplaceBytes_cold_12()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "range.location out of range (<0)", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFDataGetBytes_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_3_0("__CFDataValidateRange", "CFData.c", a3, "range.location <= dataLength");
}

void CFDataGetBytes_cold_2()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "range.location out of range (>len)", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFDataGetBytes_cold_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_6("__CFDataValidateRange", "CFData.c", a3, "range.location + range.length <= dataLength");
}

void CFDataGetBytes_cold_4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "ending index out of bounds", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFDataGetBytes_cold_5(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_5("__CFDataValidateRange", "CFData.c", a3, "range.length >= 0");
}

void CFDataGetBytes_cold_6()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "length cannot be less than zero", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFDataGetBytes_cold_7(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_4("__CFDataValidateRange", "CFData.c", a3, "range.location >= 0");
}

void CFDataGetBytes_cold_8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "range.location out of range (<0)", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFDataSetLength_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"fixed-capacity CFMutableData is full";
  __break(1u);
}

void CFDataFind_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_3_0("__CFDataValidateRange", "CFData.c", a3, "range.location <= dataLength");
}

void CFDataFind_cold_2()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "range.location out of range (>len)", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFDataFind_cold_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_6("__CFDataValidateRange", "CFData.c", a3, "range.location + range.length <= dataLength");
}

void CFDataFind_cold_4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "ending index out of bounds", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFDataFind_cold_5(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_5("__CFDataValidateRange", "CFData.c", a3, "range.length >= 0");
}

void CFDataFind_cold_6()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "length cannot be less than zero", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFDataFind_cold_7(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_4("__CFDataValidateRange", "CFData.c", a3, "range.location >= 0");
}

void CFDataFind_cold_8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_2();
  OUTLINED_FUNCTION_0_3(&dword_182A8C000, v0, v1, "range.location out of range (<0)", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_2();
}

void CFGregorianDateIsValid_cold_1(int a1)
{
  _DWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[0] = 67109120;
  v1[1] = a1;
  _os_log_error_impl(&dword_182A8C000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Month %d is out of bounds", (uint8_t *)v1, 8u);
}

void __ResetUDateFormat_cold_1(uint64_t *a1, NSObject *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3 = 138412290;
  v4 = v2;
  _os_log_error_impl(&dword_182A8C000, a2, OS_LOG_TYPE_ERROR, "Error: CFDateFormatter time zone has an empty name: %@", (uint8_t *)&v3, 0xCu);
}

void _cow_failure(const __CFString *a1)
{
  qword_1EDCD1038 = (uint64_t)CFStringGetCStringPtr(a1, 0x600u);
  __break(1u);
}

void _cow_create_cold_1()
{
  _cow_failure(CFSTR("Unable to create CoW control block"));
}

void _cow_copy_cold_1()
{
  _cow_failure(CFSTR("Failed to grow buffer"));
}

void _cow_mutate_slow_cold_1()
{
  _cow_failure(CFSTR("Failed to grow buffer"));
}

uint64_t _CFErrorSetCallStackCaptureEnabled(int a1)
{
  unsigned __int8 v1;

  do
    v1 = __ldaxr(_CFErrorCallStackCaptureEnabled);
  while (__stlxr(a1 != 0, _CFErrorCallStackCaptureEnabled));
  return v1 & 1;
}

void userInfoKeyValueShow_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** userInfoKeyValueShow() called with NULL context ***";
  __break(1u);
}

void _CFPrefsEncodeKeyValuePairsIntoMessage_cold_1()
{
  __assert_rtn("_CFPrefsEncodeKeyValuePairsIntoMessage", "CFPrefsBuffers.m", 152, "count > 0");
}

void deallocatePurgeable_cold_1(int a1, NSObject *a2)
{
  _DWORD v2[2];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v2[0] = 67240192;
  v2[1] = a1;
  _os_log_fault_impl(&dword_182A8C000, a2, OS_LOG_TYPE_FAULT, "couldn't deallocate purgable buffer. Leaking it to avoid crashing. Error was %{public}d", (uint8_t *)v2, 8u);
}

void _cfmp_record_intent_to_invalidate_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Unable to allocate mach_port deallocation record";
  __break(1u);
}

void _cfmp_log_failure_cold_1(uint64_t a1, unsigned __int8 a2, int a3)
{
  int v3;
  uint64_t v4;
  __int16 v5;
  int v6;
  __int16 v7;
  int v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = 136446722;
  v4 = a1;
  v5 = 1024;
  v6 = a2;
  v7 = 1024;
  v8 = a3;
  _os_log_error_impl(&dword_182A8C000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "*** %{public}s, break on '_CFMachPortDeallocationFailure' to debug: {null - ic:%d,ip:%d}", (uint8_t *)&v3, 0x18u);
}

void _cfmp_deallocation_record_retain_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"refcnt overflow";
  __break(1u);
}

void _CFBundleDlfcnLoadBundle_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_8();
  OUTLINED_FUNCTION_7(&dword_182A8C000, v0, v1, "Cannot find executable for bundle %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_4_0();
}

void _CFBundleDlfcnLoadBundle_cold_2()
{
  const char *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  OUTLINED_FUNCTION_6_0();
  strlen(v0);
  OUTLINED_FUNCTION_5_0();
  OUTLINED_FUNCTION_1_3(&dword_182A8C000, v1, v2, "Error loading %{public}s (%lu):  %{public}s", v3, v4, v5, v6, 2u);
  OUTLINED_FUNCTION_3_1();
}

void _CFBundleDlfcnLoadBundle_cold_3()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_2_3();
  OUTLINED_FUNCTION_0_4(&dword_182A8C000, v0, v1, "dlfcn load bundle %{public}@ closing existing reference to handle %p");
  OUTLINED_FUNCTION_4_0();
}

void _CFBundleDlfcnLoadFramework_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_8();
  OUTLINED_FUNCTION_7(&dword_182A8C000, v0, v1, "Cannot find executable for bundle %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_4_0();
}

void _CFBundleDlfcnLoadFramework_cold_2()
{
  const char *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  OUTLINED_FUNCTION_6_0();
  strlen(v0);
  OUTLINED_FUNCTION_5_0();
  OUTLINED_FUNCTION_1_3(&dword_182A8C000, v1, v2, "Error loading %{public}s (%lu):  %{public}s", v3, v4, v5, v6, 2u);
  OUTLINED_FUNCTION_3_1();
}

void _CFBundleDlfcnLoadFramework_cold_3()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_2_3();
  OUTLINED_FUNCTION_0_4(&dword_182A8C000, v0, v1, "dlfcn load framework %{public}@ closing existing reference to handle %p");
  OUTLINED_FUNCTION_4_0();
}

void _CFBundleDlfcnUnload_cold_1(uint64_t a1, NSObject *a2)
{
  int v3;
  uint64_t v4;
  __int16 v5;
  char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v3 = 138543618;
  v4 = a1;
  v5 = 2080;
  v6 = dlerror();
  _os_log_error_impl(&dword_182A8C000, a2, OS_LOG_TYPE_ERROR, "Internal error unloading bundle %{public}@ : %s", (uint8_t *)&v3, 0x16u);
}

void _CFBundleDlfcnUnload_cold_2()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_2_3();
  OUTLINED_FUNCTION_0_4(&dword_182A8C000, v0, v1, "dlfcn unload bundle %{public}@, handle %p");
  OUTLINED_FUNCTION_4_0();
}

void _NSDictionaryRaiseInsertNilKeyException(objc_class *a1, const char *a2)
{
  uint64_t v2;

  v2 = __CFExceptionProem(a1, a2);
  OUTLINED_FUNCTION_0_5(v2, CFSTR("%@: attempt to insert nil key"));
}

void _NSDictionaryRaiseInsertNilValueException(objc_class *a1, const char *a2, uint64_t a3)
{
  uint64_t v4;

  v4 = __CFExceptionProem(a1, a2);
  _CFThrowFormattedException((uint64_t)CFSTR("NSInvalidArgumentException"), CFSTR("%@: attempt to insert nil value (key: %@)"), v4, a3);
}

void _NSDictionaryRaiseRemoveNilKeyException(objc_class *a1, const char *a2)
{
  uint64_t v2;

  v2 = __CFExceptionProem(a1, a2);
  OUTLINED_FUNCTION_0_5(v2, CFSTR("%@: attempt to remove nil key"));
}

void _CFMachPortCreateWithPort4_cold_1(int a1, uint64_t a2, NSObject *a3)
{
  uint64_t v3;

  LODWORD(v3) = 134218240;
  HIDWORD(v3) = a1;
  OUTLINED_FUNCTION_0_6(&dword_182A8C000, a2, a3, "*** CFMachPortCreateWithPort(): mach_port_type for 0x%lx failed with %d", v3, 0);
  OUTLINED_FUNCTION_2_4();
}

void _CFMachPortCreateWithPort4_cold_2(os_log_t log)
{
  uint8_t v1[8];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  *(_WORD *)v1 = 0;
  _os_log_error_impl(&dword_182A8C000, log, OS_LOG_TYPE_ERROR, "*** CFMachPortCreateWithPort(): allocation failure", v1, 2u);
  OUTLINED_FUNCTION_3_2();
}

void _CFMachPortCreateWithPort4_cold_3(uint64_t a1, uint64_t a2, NSObject *a3)
{
  const void *v3;

  LODWORD(v3) = 134218240;
  HIDWORD(v3) = a1;
  OUTLINED_FUNCTION_0_6(&dword_182A8C000, a2, a3, "*** CFMachPortCreateWithPort(): invalid mach port %p (from cache: %d)", v3, HIDWORD(a1));
  OUTLINED_FUNCTION_2_4();
}

void _CFMachPortCreateReply_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_1_4(&dword_182A8C000, a2, a3, "*** _CFMachPortCreateReply failed. mach_port_construct() returned %d", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_3_2();
}

void _CFMachPortCreate4_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_1_4(&dword_182A8C000, a2, a3, "*** CFMachPortCreate failed. mach_port_allocate() returned %d", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_3_2();
}

void _CFMachPortCreate4_cold_2(int *a1, int a2, os_log_t log)
{
  int v3;
  _DWORD v4[2];
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v3 = *a1;
  v4[0] = 67109376;
  v4[1] = a2;
  v5 = 1024;
  v6 = v3;
  _os_log_error_impl(&dword_182A8C000, log, OS_LOG_TYPE_ERROR, "*** CFMachPortCreate failed. mach_port_insert_right() returned %d for port %d", (uint8_t *)v4, 0xEu);
  OUTLINED_FUNCTION_2_4();
}

void __CFMessagePortCreateLocal_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_7(&dword_182A8C000, a1, a3, "*** CFMessagePortCreateLocal(): memory allocation failed", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_1_5();
}

void __CFMessagePortCreateLocal_cold_2(int *a1, NSObject *a2)
{
  int v2;
  _DWORD v3[2];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  v3[0] = 67240192;
  v3[1] = v2;
  _os_log_error_impl(&dword_182A8C000, a2, OS_LOG_TYPE_ERROR, "*** CFMessagePortCreateLocal(): CFMachPortCreateWithPort() failed, port = %{public}d", (uint8_t *)v3, 8u);
  OUTLINED_FUNCTION_1_5();
}

void __CFMessagePortCreateLocal_cold_3(int *a1, int a2, os_log_t log)
{
  int v3;
  _DWORD v4[2];
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v3 = *a1;
  v4[0] = 67240448;
  v4[1] = a2;
  v5 = 1026;
  v6 = v3;
  _os_log_error_impl(&dword_182A8C000, log, OS_LOG_TYPE_ERROR, "*** CFMessagePortCreateLocal(): mach_port_insert_right(MACH_MSG_TYPE_MAKE_SEND) returned %{public}d, port = %{public}d", (uint8_t *)v4, 0xEu);
}

void __CFMessagePortCreateLocal_cold_4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_7(&dword_182A8C000, a1, a3, "*** CFMessagePortCreateLocal(): CFMachPortCreate() failed", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_1_5();
}

void __CFMessagePortCreateLocal_cold_5(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_7(&dword_182A8C000, a1, a3, "*** CFMessagePortCreateLocal(): existing port invalid", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_1_5();
}

void CFMessagePortSetName_cold_1()
{
  __assert_rtn("CFMessagePortSetName", "CFMessagePort.c", 729, "ms->_dispatchSource == NULL");
}

void _CFNotificationCenterRegisterDependentNotificationList_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Too many invocations of _CFNotificationCenterRegisterDependentNotifications.";
  __break(1u);
}

void _CFXNotificationPost_cold_1(double a1)
{
  int v1;
  double v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v1 = 134217984;
  v2 = a1;
  _os_log_error_impl(&dword_182A8C000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Detected potentially harmful notification post rate of %g notifications per second", (uint8_t *)&v1, 0xCu);
}

void _CFThrowFormattedException(uint64_t a1, CFStringRef format, ...)
{
  CFStringRef v4;
  CFStringRef v5;
  uint64_t v6;
  va_list va;

  va_start(va, format);
  v6 = *MEMORY[0x1E0C80C00];
  v4 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, format, va);
  CFAutorelease(v4);
  if (v4)
    v5 = v4;
  else
    v5 = format;
  objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", a1, v5, 0, va, v6));
}

void __remoteStoreChanged_block_invoke_cold_1(id *a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v3 = objc_msgSend(*a1, "domain");
  v4 = 138543362;
  v5 = v3;
  _os_log_debug_impl(&dword_182A8C000, a2, OS_LOG_TYPE_DEBUG, "cloud preferences changed for %{public}@", (uint8_t *)&v4, 0xCu);
}

void visit_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"unable to allocate memory";
  __break(1u);
}

void _NSArrayRaiseBoundException(uint64_t a1, const char *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  void *v17;

  v7 = _os_log_pack_size();
  MEMORY[0x1E0C80A78](v7, v8);
  v9 = OUTLINED_FUNCTION_1_6();
  v10 = PROEM_CLS();
  v11 = PROEM_SEL(a2);
  if (a3 >> 62)
    v12 = " (or possibly larger)";
  else
    v12 = "";
  __os_log_helper_1_2_5_8_32_8_32_8_0_8_32_8_0(v9, (uint64_t)v10, (uint64_t)v11, a3, (uint64_t)v12, a4);
  v13 = PROEM_CLS();
  v14 = PROEM_SEL(a2);
  CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("-[%s %s]: index (%ld%s) beyond bounds (%ld)"), v13, v14, a3, v12, a4);
  v15 = OUTLINED_FUNCTION_2_5();
  v17 = (void *)OUTLINED_FUNCTION_0_9(NSException, v16, (uint64_t)CFSTR("NSInvalidArgumentException"), v15);
  objc_exception_throw(v17);
}

void _NSArrayRaiseInsertNilException(uint64_t a1, const char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  uint64_t v10;
  const char *v11;
  void *v12;

  v3 = _os_log_pack_size();
  MEMORY[0x1E0C80A78](v3, v4);
  v5 = OUTLINED_FUNCTION_1_6();
  v6 = PROEM_CLS();
  v7 = PROEM_SEL(a2);
  *(_DWORD *)v5 = 136315394;
  *(_QWORD *)(v5 + 4) = v6;
  *(_WORD *)(v5 + 12) = 2080;
  *(_QWORD *)(v5 + 14) = v7;
  v8 = PROEM_CLS();
  v9 = PROEM_SEL(a2);
  CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("-[%s %s]: attempt to insert nil"), v8, v9);
  v10 = OUTLINED_FUNCTION_2_5();
  v12 = (void *)OUTLINED_FUNCTION_0_9(NSException, v11, (uint64_t)CFSTR("NSInvalidArgumentException"), v10);
  objc_exception_throw(v12);
}

void _CFCopyHomeDirURLForUser_cold_1(uint64_t a1, NSObject *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(*(_QWORD *)a1 + 24);
  v3 = 138543362;
  v4 = v2;
  _os_log_error_impl(&dword_182A8C000, a2, OS_LOG_TYPE_ERROR, "_CFCopyHomeDirURLForUser failed to create a proper home directory. Falling back to /var/empty. Error(s):\n%{public}@", (uint8_t *)&v3, 0xCu);
}

void _CFGetTSDCreateIfNeeded_cold_1(int a1)
{
  _CFLogSimple(3, "Error: TSD slot %d out of range (get)", a1);
  __break(1u);
}

void _CFSetTSD_cold_1(int a1)
{
  _CFLogSimple(3, "Error: TSD slot %d out of range (set)", a1);
  __break(1u);
}

void CFPlugInInstanceCreate_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_6_1();
  OUTLINED_FUNCTION_5_1(&dword_182A8C000, v0, v1, "Cannot find factory %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_6();
}

void CFPlugInInstanceCreate_cold_2(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_4_1(&dword_182A8C000, a2, a3, "Attempted to create instance, but factory %{public}@ is disabled", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_2_6();
}

void CFPlugInInstanceCreate_cold_3()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_1_7();
  OUTLINED_FUNCTION_0_10(&dword_182A8C000, v0, v1, "Created instance of plugin for factory %{public}@ type %{public}@");
  OUTLINED_FUNCTION_2_6();
}

void CFPlugInInstanceCreate_cold_4()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_1_7();
  OUTLINED_FUNCTION_7_0(&dword_182A8C000, v0, v1, "Factory %{public}@ does not support type %{public}@");
  OUTLINED_FUNCTION_2_6();
}

void _CFPFactoryCommonCreateLocked_cold_1()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_1_7();
  OUTLINED_FUNCTION_0_10(&dword_182A8C000, v0, v1, "Registered factory %{public}@ (%{public}@)");
  OUTLINED_FUNCTION_2_6();
}

void CFPlugInUnregisterFactory_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_6_1();
  OUTLINED_FUNCTION_5_1(&dword_182A8C000, v0, v1, "UnregisterFactory: No factory registered for id %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_6();
}

void _CFPFactoryDisableLocked_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_4_1(&dword_182A8C000, a2, a3, "Factory %{public}@ has been disabled", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_2_6();
}

void _CFPlugInRegisterPlugInTypeLocked_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_6_1();
  OUTLINED_FUNCTION_5_1(&dword_182A8C000, v0, v1, "RegisterPlugInType: No factory registered for id %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_6();
}

void _CFPlugInRegisterPlugInTypeLocked_cold_2()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_8_0();
  OUTLINED_FUNCTION_0_10(&dword_182A8C000, v0, v1, "Type %{public}@ added to factory %{public}@");
  OUTLINED_FUNCTION_2_6();
}

void CFPlugInUnregisterPlugInType_cold_1()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_1_7();
  OUTLINED_FUNCTION_7_0(&dword_182A8C000, v0, v1, "UnregisterPlugInType: No factory registered for id %{public}@ type %{public}@");
  OUTLINED_FUNCTION_2_6();
}

void _CFPFactoryRemoveTypeLocked_cold_1()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_8_0();
  OUTLINED_FUNCTION_0_10(&dword_182A8C000, v0, v1, "Type %{public}@ removed from factory %{public}@");
  OUTLINED_FUNCTION_2_6();
}

void CFPlugInAddInstanceForFactory_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_6_1();
  OUTLINED_FUNCTION_5_1(&dword_182A8C000, v0, v1, "AddInstanceForFactory: No factory registered for id %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_6();
}

void CFPlugInAddInstanceForFactory_cold_2()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_1_7();
  OUTLINED_FUNCTION_0_10(&dword_182A8C000, v0, v1, "AddInstanceForFactory: Added instance on %p for %{public}@");
  OUTLINED_FUNCTION_2_6();
}

void CFPlugInRemoveInstanceForFactory_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_6_1();
  OUTLINED_FUNCTION_5_1(&dword_182A8C000, v0, v1, "RemoveInstanceForFactory: No factory registered for id %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_6();
}

void CFPlugInRemoveInstanceForFactory_cold_2()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_1_7();
  OUTLINED_FUNCTION_0_10(&dword_182A8C000, v0, v1, "RemoveInstanceForFactory: Removed instance on %p for %{public}@");
  OUTLINED_FUNCTION_2_6();
}

void _CFPFactoryRemoveInstanceLocked_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_6_1();
  OUTLINED_FUNCTION_4_1(&dword_182A8C000, v0, v1, "PlugIn %{public}@ is now scheduled for unloading", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_6();
}

void _CFBundleInitPlugIn_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_6_1();
  OUTLINED_FUNCTION_4_1(&dword_182A8C000, v0, v1, "Bundle %{public}@ contains a factory UUID of 00000000-0000-0000-0000-000000000000 with function 'MyFactoryFunction'. This bundle is not a valid plugin.", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_2_6();
}

void _registerTypeLocked_cold_1()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_1_7();
  OUTLINED_FUNCTION_0_10(&dword_182A8C000, v0, v1, "Registering factory %{public}@ type %{public}@");
  OUTLINED_FUNCTION_2_6();
}

void _CFBundleDeallocatePlugIn_cold_1(uint64_t a1, NSObject *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(__CFBundleGetPlugInData(a1) + 16);
  v6 = 134349312;
  v7 = v4;
  v8 = 2050;
  v9 = a1;
  OUTLINED_FUNCTION_3_4(&dword_182A8C000, a2, v5, "Disabling factories in array %{public}p for bundle %{public}p", (uint8_t *)&v6);
  OUTLINED_FUNCTION_9();
}

void _CFPFactoryDeallocate_cold_1()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_1_7();
  OUTLINED_FUNCTION_0_10(&dword_182A8C000, v0, v1, "Unregistered factory %{public}@ (%{public}@)");
  OUTLINED_FUNCTION_2_6();
}

void CFPlugInFindFactoriesForPlugInType_cold_1(const __CFArray *Count, uint64_t a2, NSObject *a3)
{
  int v5;
  const __CFArray *v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (Count)
    Count = (const __CFArray *)CFArrayGetCount(Count);
  v5 = 134349314;
  v6 = Count;
  v7 = 2114;
  v8 = a2;
  OUTLINED_FUNCTION_3_4(&dword_182A8C000, a3, (uint64_t)a3, "%{public}ld factories found for requested plugin type %{public}@", (uint8_t *)&v5);
  OUTLINED_FUNCTION_9();
}

void __CFPropertyListCreateTopLevelKeyPaths_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateTopLevelKeyPaths_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_3()
{
  qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFPropertyListCreateSplitKeypaths_cold_4()
{
  qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void CFPropertyListCreateDeepCopy_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void CFPropertyListCreateDeepCopy_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void _arrayDeepImmutableCopy_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void _arrayDeepImmutableCopy_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void _CFAppendXML0_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"CFPropertyList ran out of memory while attempting to allocate temporary storage.";
  __break(1u);
}

void __CFRunLoopDeallocate_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to deallocate CFRunLoop outside of thread destructor -- this is likely an over-r"
                             "elease of the run loop";
  __break(1u);
}

void _CFRunLoopGet2_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Foundation-only CFRunLoop function called without Foundation present";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** Unable to create run loop mode queue port. ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"*** Unable to create timer Port ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_3()
{
  qword_1EDCD1038 = (uint64_t)"*** Unable to insert wake up port into port set. ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_4()
{
  qword_1EDCD1038 = (uint64_t)"*** Unable to insert timer port into port set. ***";
  __break(1u);
}

void __CFRunLoopCopyMode_cold_5()
{
  qword_1EDCD1038 = (uint64_t)"*** Unable to insert timer port into port set. ***";
  __break(1u);
}

void CFRunLoopRunSpecific_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Too many nested CFRunLoopRuns";
  __break(1u);
}

void CFRunLoopRunSpecific_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"CFRunLoopRun underflow";
  __break(1u);
}

void CFRunLoopWakeUp_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** Unable to send message to wake up port. ***";
  __break(1u);
}

void CFRunLoopSourceCreate_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** NULL context value passed to CFRunLoopSourceCreate(). ***";
  __break(1u);
}

void CFRunLoopTimerCreate_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"NaN was used as an interval for a CFRunLoopTimer";
  __break(1u);
}

void __CFRunLoopServiceMachPort_cold_1(char *a1)
{
  unint64_t v1;

  if ((~(_DWORD)a1 & 0x1000400B) != 0 && (a1 & 0x1000400C) != 0x1000400C)
  {
    a1 = mach_error_string((mach_error_t)a1);
LABEL_4:
    qword_1EDCD1038 = (uint64_t)a1;
LABEL_5:
    __break(1u);
  }
  HIDWORD(v1) = (unsigned __int16)a1 & 0x3E00;
  LODWORD(v1) = HIDWORD(v1) - 1024;
  a1 = "Out of IPC space";
  switch((v1 >> 10))
  {
    case 0u:
      a1 = "Kernel resource shortage handling out-of-line memory";
      goto LABEL_4;
    case 1u:
      a1 = "Kernel resource shortage handling IPC";
      goto LABEL_4;
    case 3u:
      a1 = "Out of VM address space";
      goto LABEL_4;
    case 7u:
      goto LABEL_4;
    default:
      goto LABEL_5;
  }
}

void __CFRunLoopDoTimer_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"A CFRunLoopTimer with an interval of 0 is set to repeat";
  __break(1u);
}

void _CFAssertMismatchedTypeID(unint64_t a1, unint64_t a2)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  const char *v7;
  char __str[255];

  v4 = _CFGetTypeIDDescription(a1);
  if (v4)
    v5 = (const char *)v4;
  else
    v5 = "<unknown>";
  v6 = _CFGetTypeIDDescription(a2);
  if (v6)
    v7 = (const char *)v6;
  else
    v7 = "<unknown>";
  snprintf(__str, 0xFFuLL, "Expected typeID %lu (%s) does not match actual typeID %lu (%s)", a1, v5, a2, v7);
  qword_1EDCD1038 = (uint64_t)__str;
  __break(1u);
}

void _CFRuntimeRegisterClass_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Unable to allocate memory for CF runtime type registration";
  __break(1u);
}

void _CFRuntimeUnregisterClassWithTypeID_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Built-in CFTypes cannot be unregistered";
  __break(1u);
}

void __CFGenericTypeID_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFGetTypeID_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFGetNonObjCTypeID_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFRetain_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFRetain_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void CFAutorelease_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** CFAutorelease() called with NULL ***";
  __break(1u);
}

void _CFRelease_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFRelease_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFRelease_cold_3(char *__str, uint64_t a2)
{
  if (a2)
    snprintf(__str, 0x100uLL, "Detected over-release of a CFTypeRef %p (%lu / %s)");
  else
    snprintf(__str, 0x100uLL, "Detected over-release of a CFTypeRef %p (unknown type)");
  qword_1EDCD1038 = (uint64_t)__str;
  __break(1u);
}

void __CFStringCollectionCopy_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** __CFStringCollectionCopy() called with NULL ***";
  __break(1u);
}

void __CFTypeCollectionRetain_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** __CFTypeCollectionRetain() called with NULL; likely a collection has been corrupted ***";
  __break(1u);
}

void __CFTypeCollectionRelease_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** __CFTypeCollectionRelease() called with NULL; likely a collection has been corrupted ***";
  __break(1u);
}

void CFGetRetainCount_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** CFGetRetainCount() called with NULL ***";
  __break(1u);
}

void CFGetRetainCount_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"Detected bogus CFTypeRef";
  __break(1u);
}

void _CFNonObjCEqual_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** CFEqual() called with NULL second argument ***";
  __break(1u);
}

void _CFNonObjCEqual_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCEqual_cold_3()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCEqual_cold_4()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCEqual_cold_5()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** CFEqual() called with NULL first argument ***";
  __break(1u);
}

void CFEqual_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"*** CFEqual() called with NULL second argument ***";
  __break(1u);
}

void CFEqual_cold_3()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_4()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_5()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_6()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFEqual_cold_7()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void _CFNonObjCHash_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFHash_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"*** CFHash() called with NULL ***";
  __break(1u);
}

void CFHash_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFHash_cold_3()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFHash_cold_4()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFCopyDescription_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFCopyDescription_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void CFCopyDescription_cold_3()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void __CFCopyFormattingDescription_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void __CFCopyFormattingDescription_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void __CFCopyFormattingDescription_cold_3()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

uint64_t sub_182C2E878()
{
  return 0;
}

void CFSortIndexes_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Size of array to be sorted is too big";
  __break(1u);
}

void CFQSortArray_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 vars0;

  CFLog(3, (uint64_t)CFSTR("unable to qsort array - malloc failed"), a3, a4, a5, a6, a7, a8, vars0);
  qword_1EDCD1038 = (uint64_t)"qsort - malloc failed";
  __break(1u);
}

void CFMergeSortArray_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 vars0;

  CFLog(3, (uint64_t)CFSTR("unable to mergesort array - malloc failed"), a3, a4, a5, a6, a7, a8, vars0);
  qword_1EDCD1038 = (uint64_t)"merge sort - malloc failure";
  __break(1u);
}

void __CFStringHandleOutOfMemory()
{
  _CFRaiseMemoryException((uint64_t)CFSTR("Out of memory. We suggest restarting the application. If you have an unsaved document, create a backup copy in Finder, then try to save."));
}

#error "182C2E924: call analysis failed (funcsize=7)"

void __CFStringCreateImmutableFunnel3_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"CFString cannot be created from a negative number of bytes";
  __break(1u);
}

void __CFStringMakeConstantString_cold_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 vars0;

  CFLog(3, (uint64_t)CFSTR("Can't interpret CFSTR() as MacOS Roman, crashing"), a3, a4, a5, a6, a7, a8, vars0);
  __break(1u);
}

void CFStringAppendFormat_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringSetExternalCharactersNoCopy_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringInsert_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringDelete_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringReplace_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringReplaceAll_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringAppend_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringAppendCharacters_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringAppendPascalString_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringAppendCString_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringAppendFormatAndArguments_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringFindAndReplace_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringPad_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringTrim_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringTrimWhitespace_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringLowercase_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringUppercase_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringCapitalize_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringNormalize_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void CFStringFold_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_13(&dword_182A8C000, a1, a3, "CFString: %s(): Expect mutable string", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_8();
}

void __CFStringChangeSizeMultiple_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"String had a capacity but NULL buffer pointer";
  __break(1u);
}

void __CFStringFormatLocalizedNumber_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Unexpected formatter style";
  __break(1u);
}

void _CFStringFormatAppendMetadata_cold_1()
{
  __assert_rtn("_CFStringFormatAppendMetadata", "CFString.c", 7910, "spec.mainArgNum < valuesCount");
}

void __CFDateComponentsDeallocate_cold_1()
{
  __assert_rtn("__CFDateComponentsDeallocate", "CFDateComponents.c", 139, "NULL != cf");
}

void __CFDateComponentsEqual_cold_1()
{
  __assert_rtn("__CFDateComponentsEqual", "CFDateComponents.c", 20, "NULL != cf1");
}

void __CFDateComponentsEqual_cold_2()
{
  __assert_rtn("__CFDateComponentsEqual", "CFDateComponents.c", 21, "NULL != cf2");
}

void __CFDateComponentsHash_cold_1()
{
  __assert_rtn("__CFDateComponentsHash", "CFDateComponents.c", 56, "NULL != cf");
}

void __CFDateComponentsCopyDescription_cold_1()
{
  __assert_rtn("__CFDateComponentsCopyDescription", "CFDateComponents.c", 130, "NULL != cf");
}

void CFDateComponentsCreateCopy_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Out of memory";
  __break(1u);
}

void CFDateComponentsCopyCalendar_cold_1()
{
  __assert_rtn("CFDateComponentsCopyCalendar", "CFDateComponents.c", 356, "NULL != dateComp");
}

void CFDateComponentsSetCalendar_cold_1()
{
  __assert_rtn("CFDateComponentsSetCalendar", "CFDateComponents.c", 365, "NULL != dateComp");
}

void CFDateComponentsCopyTimeZone_cold_1()
{
  __assert_rtn("CFDateComponentsCopyTimeZone", "CFDateComponents.c", 386, "NULL != dateComp");
}

void CFDateComponentsSetTimeZone_cold_1()
{
  __assert_rtn("CFDateComponentsSetTimeZone", "CFDateComponents.c", 395, "NULL != dateComp");
}

void CFDateComponentsGetValue_cold_1()
{
  __assert_rtn("CFDateComponentsGetValue", "CFDateComponents.c", 228, "NULL != dateComp");
}

void CFDateComponentsSetValue_cold_1()
{
  __assert_rtn("CFDateComponentsSetValue", "CFDateComponents.c", 293, "NULL != dateComp");
}

void CFDateComponentsIsValidDateInCalendar_cold_1()
{
  __assert_rtn("CFDateComponentsIsValidDateInCalendar", "CFDateComponents.c", 424, "NULL != dateComp");
}

void CFDateComponentsIsValidDateInCalendar_cold_2()
{
  __assert_rtn("CFDateComponentsIsValidDateInCalendar", "CFDateComponents.c", 425, "NULL != inCalendar");
}

void _CFCompareStringsWithLocale_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Invalid string range produced for character buffer in _CFCompareStringsWithLocale.";
  __break(1u);
}

void _CFCreateContainerURLForSecurityApplicationIdentifierGroupIdentifierAndUser_cold_1(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3;
  uint64_t v4;
  __int16 v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v3 = 136315394;
  v4 = a1;
  v5 = 2080;
  v6 = a2;
  _os_log_error_impl(&dword_182A8C000, log, OS_LOG_TYPE_ERROR, "Error getting app group containers for %s: %s", (uint8_t *)&v3, 0x16u);
}

void _CFPrefsExtractQuadrupleFromPathIfPossible_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Mismatched string find result";
  __break(1u);
}

void _CFPrefsValidateValueForKey_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Attempt to set a non-property-list object as an NSUserDefaults/CFPreferences value";
  abort();
}

void _CFPrefsValidateValueForKey_cold_2()
{
  os_log_t v0;
  uint8_t v1[24];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_0_14();
  _os_log_fault_impl(&dword_182A8C000, v0, OS_LOG_TYPE_FAULT, "Attempt to set a non-property-list object %{public}@ as an NSUserDefaults/CFPreferences value for key %{public}@", v1, 0x16u);
}

void _CFURLCopyHostName_cold_1()
{
  __assert_rtn("_CFURLCopyHostName", "CFURL.c", 3611, "anURL");
}

void _CFURLCopyUserName_cold_1()
{
  __assert_rtn("_CFURLCopyUserName", "CFURL.c", 3670, "anURL");
}

void _CFURLCopyPassword_cold_1()
{
  __assert_rtn("_CFURLCopyPassword", "CFURL.c", 3693, "anURL");
}

void _unescapedQueryString_cold_1()
{
  __assert_rtn("_unescapedQueryString", "CFURL.c", 3773, "anURL");
}

void _CFAppVersionCheckLessThan_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"invalid bundleID provided, must be non-null";
  __break(1u);
}

void _CFAppVersionCheckLessThan_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"version check: bundle ID corrupted";
  __break(1u);
}

void sub_182C2F9B0()
{
  OUTLINED_FUNCTION_1_9();
}

void sub_182C2F9E0()
{
  OUTLINED_FUNCTION_1_9();
}

void sub_182C2FA10()
{
  OUTLINED_FUNCTION_1_9();
}

double sub_182C2FA40()
{
  return 0.0;
}

uint64_t sub_182C2FA74()
{
  uint64_t v0;

  return v0;
}

void decodeTaggedTimeInterval_cold_1()
{
  __assert_rtn("decodeTaggedTimeInterval", "NSDate.m", 244, "encodedBits.unused == 0");
}

void __cficu_ucal_close_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_17(&dword_182A8C000, a2, a3, "ucal_close(%@);", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_10();
}

void __cficu_ucal_clear_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_17(&dword_182A8C000, a2, a3, "ucal_clear(%@);", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_1_10();
}

void __cficu_ucal_getNow_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_0_17(&dword_182A8C000, a1, a3, "ucal_getNow();
  OUTLINED_FUNCTION_1_10();
}

void sub_182C2FC4C()
{
  OUTLINED_FUNCTION_1_11();
}

void sub_182C2FC78()
{
  OUTLINED_FUNCTION_1_11();
}

void sub_182C2FCA4()
{
  OUTLINED_FUNCTION_1_11();
}

void sub_182C2FCD0()
{
  OUTLINED_FUNCTION_1_11();
}

uint64_t sub_182C2FD08()
{
  return 0;
}

void _CFRaiseMemoryException(uint64_t a1)
{
  objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSMallocException"), a1, 0));
}

void __NSICreateBackingForArgumentIfNeeded_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Out of memory";
  __break(1u);
}

void __NSICreateBackingForArgumentIfNeeded_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"Out of memory";
  __break(1u);
}

void ___forwarding____cold_1()
{
  qword_1EDCD1038 = (uint64_t)"Attempting to address object pointer with invalid tag";
  __break(1u);
}

void ___forwarding____cold_2(int a1, __int16 a2, SEL sel)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (__CFOASafe)
    OUTLINED_FUNCTION_0_19();
  sel_getName(sel);
  CFLog(3, (uint64_t)CFSTR("*** -[%s %s]: message sent to deallocated instance %p"), v5, v6, v7, v8, v9, v10, a2 + 10);
  __break(1u);
}

void ___forwarding____cold_3(void *a1)
{
  __int16 v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v1 = (__int16)a1;
  object_getClassName(a1);
  CFLog(4, (uint64_t)CFSTR("*** NSForwarding: warning: object %p of class '%s' does not implement doesNotRecognizeSelector: -- abort"), v2, v3, v4, v5, v6, v7, v1);
  __break(1u);
}

void ___forwarding____cold_4(char *a1, id a2)
{
  const char *ClassName;

  ClassName = object_getClassName(a2);
  snprintf(a1, 0x100uLL, "*** NSForwarding: object %p of class '%s' does not implement forwardInvocation:", a2, ClassName);
  qword_1EDCD1038 = (uint64_t)a1;
  __break(1u);
}

void __block_forwarding____cold_1(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (__CFOASafe)
    OUTLINED_FUNCTION_0_19();
  CFLog(3, (uint64_t)CFSTR("*** NSBlockInvocation: invocation of deallocated Block instance %p"), a3, a4, a5, a6, a7, a8, a1);
  __break(1u);
}

void __block_forwarding____cold_2(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFLog(4, (uint64_t)CFSTR("*** NSBlockInvocation: Block %p does not have a type signature -- abort"), a3, a4, a5, a6, a7, a8, a1);
  __break(1u);
}

void _CFPreferencesCopyManagedPreferencesContainerURL_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_2_8(&dword_182A8C000, a2, a3, "Couldn't get container path for managed preferences due to error %llu", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_1_12();
}

void _CFPreferencesCopyManagedPreferencesContainerURL_cold_2()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_7_1();
  OUTLINED_FUNCTION_4_2(&dword_182A8C000, v0, v1, "Couldn't create URL for managed preferences container", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_3_5();
}

void _CFPreferencesGetUserIdentifierForUID_cold_1(int *a1, int a2, os_log_t log)
{
  int v3;
  _DWORD v4[2];
  __int16 v5;
  int v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v3 = *a1;
  v4[0] = 67109376;
  v4[1] = v3;
  v5 = 1024;
  v6 = a2;
  _os_log_error_impl(&dword_182A8C000, log, OS_LOG_TYPE_ERROR, "_CFPreferencesGetUserIdentifierForUID(): Could not resolve user with UID %i: %{darwin.errno}d", (uint8_t *)v4, 0xEu);
  OUTLINED_FUNCTION_1_12();
}

void _CFPrefsTemporaryFDToWriteTo_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_7_1();
  OUTLINED_FUNCTION_5_2(&dword_182A8C000, v0, v1, "Simulating out of disk space on creation", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_3_5();
}

void _CFPrefsTemporaryFDToWriteTo_cold_2()
{
  os_log_t v0;
  uint8_t v1[24];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_8_1();
  _os_log_error_impl(&dword_182A8C000, v0, OS_LOG_TYPE_ERROR, "failed to get file system representation for url: %{private}@", v1, 0xCu);
  OUTLINED_FUNCTION_1_12();
}

void _CFPrefsTemporaryFDToWriteTo_cold_3()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_7_1();
  OUTLINED_FUNCTION_5_2(&dword_182A8C000, v0, v1, "failed to get file system representation for temporary file path appropriate", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_3_5();
}

void _CFPrefsTemporaryFDToWriteTo_cold_4(int a1, uint64_t a2, NSObject *a3)
{
  uint8_t v5[12];
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  strerror(a1);
  OUTLINED_FUNCTION_8_1();
  v6 = 2081;
  v7 = a2;
  _os_log_fault_impl(&dword_182A8C000, a3, OS_LOG_TYPE_FAULT, "error \"%{public}s\" creating file %{private}s", v5, 0x16u);
}

void _CFPrefsWritePlistToFDThenClose_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_2_8(&dword_182A8C000, a1, a3, "Error creating data ref from plist, data was %p.", a5, a6, a7, a8, 0);
  OUTLINED_FUNCTION_1_12();
}

void _CFPrefsWritePlistToFDThenClose_cold_2(int a1, NSObject *a2)
{
  _DWORD v2[2];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl(&dword_182A8C000, a2, OS_LOG_TYPE_FAULT, "Couldn't get path for fd %d", (uint8_t *)v2, 8u);
  OUTLINED_FUNCTION_3_5();
}

void _CFPrefsWritePlistToFDThenClose_cold_3()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_7_1();
  OUTLINED_FUNCTION_4_2(&dword_182A8C000, v0, v1, "Simulating out of disk space on write", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_3_5();
}

void _CFPrefsWritePlistToFDThenClose_cold_4()
{
  os_log_t v0;
  uint8_t v1[24];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_8_1();
  _os_log_debug_impl(&dword_182A8C000, v0, OS_LOG_TYPE_DEBUG, "wrote file %{public}s", v1, 0xCu);
  OUTLINED_FUNCTION_1_12();
}

void _CFPrefsWritePlistToFDThenClose_cold_5(uint64_t a1, uint64_t a2, NSObject *a3)
{
  __int128 v3;

  LOWORD(v3) = 2080;
  *(_QWORD *)((char *)&v3 + 2) = a1;
  OUTLINED_FUNCTION_0_20(&dword_182A8C000, a2, a3, "error %d setting do-not-back-up attribute on file %s", 67109378, (const char *)v3);
  OUTLINED_FUNCTION_1_12();
}

void _CFPrefsWritePlistToFDThenClose_cold_6()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_8_1();
  OUTLINED_FUNCTION_2_8(&dword_182A8C000, v0, v1, "Invalid data written from preferences to path %s", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_12();
}

void _CFPrefsWritePlistToFDThenClose_cold_7()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_6_2();
  OUTLINED_FUNCTION_0_20(&dword_182A8C000, v0, v1, "CFPreferences: error fsyncing file %s: %{darwin.errno}d\n");
  OUTLINED_FUNCTION_1_12();
}

void _CFPrefsWritePlistToFDThenClose_cold_8()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_6_2();
  OUTLINED_FUNCTION_0_20(&dword_182A8C000, v0, v1, "CFPreferences: error writing file %s: %{darwin.errno}d\n");
  OUTLINED_FUNCTION_1_12();
}

uint64_t sub_182C305BC()
{
  return 0;
}

void __CFRequireConcreteImplementation(objc_class *a1, uint64_t a2)
{
  objc_class *v4;
  uint64_t v5;
  uint64_t v6;
  NSException *v7;

  v4 = (objc_class *)objc_opt_class();
  v5 = OUTLINED_FUNCTION_0_22(a1);
  if (v4 == a1)
  {
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** %@: method sent to an instance (%p) of an abstract class.  Create a concrete instance!"), v5, a2);
  }
  else
  {
    v6 = OUTLINED_FUNCTION_0_22(v4);
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** %@: method only defined for abstract class.  Define %@!"), v5, v6);
  }
  v7 = +[NSException exceptionWithName:reason:userInfo:](NSException, "exceptionWithName:reason:userInfo:", CFSTR("NSInvalidArgumentException"), _CFAutoreleasePoolAddObject(), 0);
  objc_exception_throw(v7);
}

void sub_182C30698()
{
  OUTLINED_FUNCTION_1_14();
}

void sub_182C306C4()
{
  OUTLINED_FUNCTION_1_14();
}

void sub_182C306F0()
{
  OUTLINED_FUNCTION_1_14();
}

void sub_182C3071C()
{
  OUTLINED_FUNCTION_1_14();
}

void __CFListFormatterDeallocate_cold_1()
{
  __assert_rtn("__CFListFormatterDeallocate", "CFListFormatter.c", 26, "cf != NULL");
}

void __CFListFormatterCopyDescription_cold_1()
{
  __assert_rtn("__CFListFormatterCopyDescription", "CFListFormatter.c", 32, "cf != NULL");
}

void _CFListFormatterCreate_cold_1()
{
  __assert_rtn("_CFListFormatterCreate", "CFListFormatter.c", 54, "allocator != NULL");
}

void _CFListFormatterCreate_cold_2()
{
  __assert_rtn("_CFListFormatterCreate", "CFListFormatter.c", 57, "locale != NULL");
}

void cbRead_cold_1()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 188, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_2()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 195, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_3()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 173, "pCircBuf->available == 0");
}

void cbRead_cold_4()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 221, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_5()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 228, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_6()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 204, "pCircBuf->available == (pCircBuf->pDataBegin - pCircBuf->pDataEnd)");
}

void cbRead_cold_7()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 256, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_8()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 247, "pCircBuf->pDataBegin <= pCircBuf->pBufferEnd");
}

void cbRead_cold_9()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 245, "pCircBuf->pDataBegin == pCircBuf->pDataEnd");
}

void cbRead_cold_10()
{
  __assert_rtn("cbRead", "tsCircularBuffer.c", 237, "pCircBuf->available == ((pCircBuf->pDataBegin - pCircBuf->pData) + (pCircBuf->pBufferEnd - pCircBuf->pDataEnd))");
}

void __cbRead_cold_1()
{
  __assert_rtn("__cbRead", "tsCircularBuffer.c", 124, "pDestination != NULL");
}

void __cbRead_cold_2()
{
  __assert_rtn("__cbRead", "tsCircularBuffer.c", 125, "pSource != NULL");
}

void __cbRead_cold_3()
{
  __assert_rtn("__cbRead", "tsCircularBuffer.c", 126, "bufferLength > 0");
}

void cbWrite_cold_1()
{
  __assert_rtn("cbWrite", "tsCircularBuffer.c", 338, "pCircBuf->available == pCircBuf->length");
}

void cbWrite_cold_2()
{
  __assert_rtn("cbWrite", "tsCircularBuffer.c", 371, "pCircBuf->available == (pCircBuf->pDataBegin - pCircBuf->pDataEnd)");
}

void cbWrite_cold_3()
{
  __assert_rtn("cbWrite", "tsCircularBuffer.c", 391, "pCircBuf->available == ((pCircBuf->pDataBegin - pCircBuf->pData) + (pCircBuf->pBufferEnd - pCircBuf->pDataEnd))");
}

void __cbWrite_cold_1()
{
  __assert_rtn("__cbWrite", "tsCircularBuffer.c", 295, "pDestination != NULL");
}

void __cbWrite_cold_2()
{
  __assert_rtn("__cbWrite", "tsCircularBuffer.c", 296, "pSource != NULL");
}

void __cbWrite_cold_3()
{
  __assert_rtn("__cbWrite", "tsCircularBuffer.c", 297, "bufferLength > 0");
}

uint64_t sub_182C30B58()
{
  return 0;
}

uint64_t sub_182C30B88()
{
  return 0;
}

void sub_182C30BE0()
{
  OUTLINED_FUNCTION_3_6();
}

void sub_182C30C34()
{
  OUTLINED_FUNCTION_3_6();
}

void sub_182C30C88()
{
  OUTLINED_FUNCTION_3_6();
}

void sub_182C30CDC()
{
  OUTLINED_FUNCTION_3_6();
}

void sub_182C30D30()
{
  OUTLINED_FUNCTION_3_6();
}

void sub_182C30D5C()
{
  OUTLINED_FUNCTION_5_3();
}

void sub_182C30D8C()
{
  OUTLINED_FUNCTION_5_3();
}

void sub_182C30DBC()
{
  OUTLINED_FUNCTION_5_3();
}

void sub_182C30DEC()
{
  OUTLINED_FUNCTION_3_6();
}

void sub_182C30E18()
{
  OUTLINED_FUNCTION_3_6();
}

void sub_182C30E44()
{
  OUTLINED_FUNCTION_3_6();
}

void sub_182C30E70()
{
  OUTLINED_FUNCTION_3_6();
}

void sub_182C30E9C()
{
  OUTLINED_FUNCTION_3_6();
}

void sub_182C30EC8()
{
  OUTLINED_FUNCTION_1_16();
}

void sub_182C30EF4()
{
  OUTLINED_FUNCTION_1_16();
}

void sub_182C30F20()
{
  OUTLINED_FUNCTION_1_16();
}

void sub_182C30F4C()
{
  OUTLINED_FUNCTION_1_16();
}

uint64_t sub_182C30F78()
{
  return 0;
}

void sub_182C30FA8()
{
  OUTLINED_FUNCTION_1_16();
}

void sub_182C30FD4()
{
  OUTLINED_FUNCTION_1_16();
}

void __boundsFail(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  double v13;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v9 = a2;
    v3 = _os_log_pack_size();
    v11 = (char *)v14 - ((MEMORY[0x1E0C80A78](v3, v10) + 15) & 0xFFFFFFFFFFFFFFF0);
    v12 = OUTLINED_FUNCTION_0_26();
    v13 = __os_log_helper_1_2_3_8_32_8_0_8_0(v12, (uint64_t)"__boundsFail", a1, --v9);
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** %s: index %lu beyond bounds [0 .. %lu]"), v13, "__boundsFail", a1, v9);
    v7 = OUTLINED_FUNCTION_1_17();
    v8 = v11;
  }
  else
  {
    v3 = _os_log_pack_size();
    v5 = (char *)v14 - ((MEMORY[0x1E0C80A78](v3, v4) + 15) & 0xFFFFFFFFFFFFFFF0);
    v6 = OUTLINED_FUNCTION_0_26();
    *(_DWORD *)v6 = 136315394;
    *(_QWORD *)(v6 + 4) = "__boundsFail";
    *(_WORD *)(v6 + 12) = 2048;
    *(_QWORD *)(v6 + 14) = a1;
    CFStringCreateWithFormat((CFAllocatorRef)&__kCFAllocatorSystemDefault, 0, CFSTR("*** %s: index %lu beyond bounds for empty array"), "__boundsFail", a1);
    v7 = OUTLINED_FUNCTION_1_17();
    v8 = v5;
  }
  objc_exception_throw(+[NSException exceptionWithName:reason:userInfo:osLogPack:size:](NSException, "exceptionWithName:reason:userInfo:osLogPack:size:", CFSTR("NSRangeException"), v7, 0, v8, v3));
}

void _CFGetHandleForLoadedLibrary_cold_1()
{
  __assert_rtn("_CFGetHandleForLoadedLibrary", "CFLibraryLoading.c", 40, "handle && \"Using exact image path to retrieve handle for already-loaded library must succeed\"");
}

void _CFGetHandleForInsertedOrInterposingLibrary_cold_1()
{
  __assert_rtn("_CFGetHandleForInsertedOrInterposingLibrary", "CFLibraryLoading.c", 45, "namePrefix && \"Library name prefix cannot be null\"");
}

uint64_t sub_182C31208()
{
  return 0;
}

uint64_t sub_182C3123C()
{
  return 0;
}

void normalizeQuintuplet_cold_1()
{
  __assert_rtn("normalizeQuintuplet", "CFPrefsSearchListSource.m", 57, "!cloud");
}

void __CFBasicHashRehash_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_2()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_3()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_4()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_5()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_6()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_7()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_8()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_9()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_10()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_11()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void __CFBasicHashIncSlotCount_cold_12()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void CFBasicHashCreateCopy_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"overflow while growing CFBasicHash";
  __break(1u);
}

void _CFXNotificationRegistrarAddObserver_cold_1()
{
  __assert_rtn("_CFXNotificationRegistrarAddObserver", "CFXNotificationRegistrar.c", 2222, "(options & kCFXNotificationValidHandlers) != 0");
}

void _CFXNotificationRegistrarAddObserver_cold_2()
{
  __assert_rtn("_CFXNotificationRegistrarGrowObserverPool", "CFXNotificationRegistrar.c", 1120, "registrar->observerPool.capacity == newCapacity");
}

void _CFXNotificationRegistrarAddObject_cold_1()
{
  __assert_rtn("_CFXNotificationObjectTableRehash", "CFXNotificationRegistrar.c", 2035, "newBucketCount != 0");
}

void _CFXNotificationRegistrarAddName_cold_1()
{
  __assert_rtn("_CFXNotificationNameTableRehash", "CFXNotificationRegistrar.c", 1966, "newBucketCount != 0");
}

void _CFBundleGetStringsSources_cold_1()
{
  os_log_t v0;
  uint8_t v1[24];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_0_30();
  _os_log_debug_impl(&dword_182A8C000, v0, OS_LOG_TYPE_DEBUG, "loctable overridden by installed files. Bundle: %@, table: %@", v1, 0x16u);
}

void _CFBundleIngestResultForBundleCache_cold_1()
{
  __assert_rtn("_CFBundleIngestDefaultLocalizationResultsIntoExistingCachedResult", "CFBundle_Strings.m", 847, "!existingCachedResult->stringsDictData");
}

void _CFBundleIngestResultForBundleCache_cold_2()
{
  __assert_rtn("_CFBundleIngestDefaultLocalizationResultsIntoExistingCachedResult", "CFBundle_Strings.m", 846, "!existingCachedResult->stringsDictTableURL");
}

void _CFBundleIngestResultForBundleCache_cold_3()
{
  __assert_rtn("_CFBundleIngestDefaultLocalizationResultsIntoExistingCachedResult", "CFBundle_Strings.m", 837, "!existingCachedResult->stringsData");
}

void _CFBundleIngestResultForBundleCache_cold_4()
{
  __assert_rtn("_CFBundleIngestDefaultLocalizationResultsIntoExistingCachedResult", "CFBundle_Strings.m", 836, "!existingCachedResult->stringsTableURL");
}

void __CFBundleCreateStringsFromPlistData_cold_1()
{
  os_log_t v0;
  uint8_t v1[24];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  OUTLINED_FUNCTION_0_30();
  _os_log_error_impl(&dword_182A8C000, v0, OS_LOG_TYPE_ERROR, "Unable to load .strings file: %@ / %@: Top-level object was not a dictionary", v1, 0x16u);
}

void sub_182C31CC8()
{
  OUTLINED_FUNCTION_1_20();
}

void sub_182C31CF4()
{
  OUTLINED_FUNCTION_1_20();
}

void sub_182C31D20()
{
  OUTLINED_FUNCTION_1_20();
}

void sub_182C31D4C()
{
  OUTLINED_FUNCTION_1_20();
}

void CFBurstTrieAddUTF8StringWithWeight_cold_1()
{
  qword_1EDCD1038 = (uint64_t)"list is NULL";
  __break(1u);
}

void CFBurstTrieCursorCreateByCopy_cold_1()
{
  __assert_rtn("CFBurstTrieCursorCreateByCopy", "CFBurstTrie.c", 766, "false");
}

void serializeCFBurstTrieLevels_cold_1()
{
  __assert_rtn("serializeCFBurstTrieLevels", "CFBurstTrie.c", 1849, "bitcount == count");
}

void _CFPrefsApplyChangesQueueToDictionary_cold_1()
{
  __assert_rtn("_CFPrefsApplyChangesQueueToDictionary", "CFPDSource.m", 1600, "queue");
}

void _CFPrefsApplyChangesQueueToDictionary_cold_2()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_13();
  OUTLINED_FUNCTION_10(&dword_182A8C000, v0, v1, "Couldn't apply changes: %{private}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_21();
}

void _CFPrefsApplyChangesQueueToDictionary_cold_3()
{
  __assert_rtn("_CFPrefsApplyChangesQueueToDictionary", "CFPDSource.m", 1603, "count % CHANGE_QUEUE_TUPLE_COUNT == 0");
}

void _CFPrefsApplyChangesQueueToDictionary_cold_4()
{
  __assert_rtn("_CFPrefsApplyChangesQueueToDictionary", "CFPDSource.m", 1601, "xpc_get_type(queue) == XPC_TYPE_ARRAY");
}

void _CFPrefsMessageSenderIsSandboxed_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_2_15("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", a3, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsSandboxCheckForMessage_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_2_15("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", a3, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _calculateUserNameForUID_cold_1(int a1, NSObject *a2)
{
  _DWORD v2[2];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v2[0] = 67240192;
  v2[1] = a1;
  _os_log_fault_impl(&dword_182A8C000, a2, OS_LOG_TYPE_FAULT, "Could not look up the username for %{public}d after three tries", (uint8_t *)v2, 8u);
  OUTLINED_FUNCTION_14();
}

void _extractCFPDBits_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_2_15("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", a3, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void populateErrorReply_cold_1()
{
  __assert_rtn("populateErrorReply", "cfprefsd.m", 141, "reply");
}

void withClientContext_cold_1()
{
  __assert_rtn("withClientContext", "cfprefsd.m", 193, "ctxt");
}

void _CFPrefsFixUpIncomingMessageForPIDImpersonationIfNeeded_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_33("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", a3, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsGetEntitlementForMessageWithLockedContext_cold_1()
{
  __assert_rtn("_CFPrefsGetEntitlementForMessageWithLockedContext", "cfprefsd.m", 213, "message");
}

void _CFPrefsGetEntitlementForMessageWithLockedContext_cold_2()
{
  __assert_rtn("_CFPrefsGetEntitlementForMessageWithLockedContext", "cfprefsd.m", 243, "matched");
}

void _CFPrefsGetEntitlementForMessageWithLockedContext_cold_3(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_33("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", a3, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsPIDForMessage_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_33("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", a3, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsGetFixedUpDomainForMessage_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_1_22(&dword_182A8C000, a2, a3, "invalid argument (path instead of domain/application identifier) %{public}s", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_3_8();
}

void _CFPrefsCopyFixedUpContainerForMessage_cold_1()
{
  __assert_rtn("_CFPrefsGetSuiteContainer", "cfprefsd.m", 322, "domain");
}

void _CFPrefsCopyFixedUpContainerForMessage_cold_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_33("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", a3, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsCopyFixedUpContainerForMessage_cold_3(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_1_22(&dword_182A8C000, a2, a3, "attempt to write to a container %{public}s that does not yet exist. Using client-provided container path without resolving symlinks.", a5, a6, a7, a8, 2u);
  OUTLINED_FUNCTION_3_8();
}

void _CFPrefsSandboxCheckForMessage_cold_1_0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_33("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", a3, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void _CFPrefsCopyFixedUpUserForMessage_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_33("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", a3, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void log_client_activity_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_33("_CFPrefsConnectionForMessage", "CFXPreferences_Internal.h", a3, "conn && xpc_get_type(conn) == XPC_TYPE_CONNECTION");
}

void client_context_finalizer_cold_1()
{
  __assert_rtn("client_context_finalizer", "cfprefsd.m", 170, "!context->_valid");
}

void _CFPrefsIsUserManaged_cold_1(int a1, uint64_t a2, os_log_t log)
{
  const char *v3;
  int v4;
  const char *v5;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v3 = "enabled";
  if (a1 != 1)
    v3 = "disabled";
  v4 = 136446467;
  v5 = v3;
  v6 = 2113;
  v7 = a2;
  _os_log_debug_impl(&dword_182A8C000, log, OS_LOG_TYPE_DEBUG, "Managed preferences are %{public}s for %{private}@", (uint8_t *)&v4, 0x16u);
  OUTLINED_FUNCTION_0_34();
}

void _CFBundleLoadLimitedInfoDictionary_cold_1()
{
  __assert_rtn("_CFBundleLoadLimitedInfoDictionary", "CFBundle_InfoPlist.c", 1156, "!bundle->_infoPlistUrl");
}

void _CFBundleLoadLimitedInfoDictionary_cold_2()
{
  __assert_rtn("_CFBundleLoadLimitedInfoDictionary", "CFBundle_InfoPlist.c", 1151, "bundle->_infoDict == NULL");
}

void _CFBundleCreateFilteredInfoPlistWithData_cold_1(uint64_t a1, uint64_t a2, NSObject *a3)
{
  _BYTE v3[24];

  *(_DWORD *)v3 = 138478083;
  *(_QWORD *)&v3[4] = a1;
  *(_WORD *)&v3[12] = 2114;
  *(_QWORD *)&v3[14] = a2;
  OUTLINED_FUNCTION_0_35(&dword_182A8C000, a2, a3, "A filtered Info.plist result was not a dictionary at URL %{private}@ (for key paths %{public}@)", *(_QWORD *)v3, *(_QWORD *)&v3[8], *(_QWORD *)&v3[16]);
  OUTLINED_FUNCTION_2_18();
}

void ___parseBundleStrings_block_invoke_cold_1(uint64_t a1, _QWORD *a2, NSObject *a3)
{
  _BYTE v3[24];

  *(_DWORD *)v3 = 138543618;
  *(_QWORD *)&v3[4] = a1;
  *(_WORD *)&v3[12] = 2114;
  *(_QWORD *)&v3[14] = *a2;
  OUTLINED_FUNCTION_0_35(&dword_182A8C000, (uint64_t)a2, a3, "Could not parse markdown while retrieving localized string for key %{public}@ in bundle %{public}@", *(_QWORD *)v3, *(_QWORD *)&v3[8], *(_QWORD *)&v3[16]);
  OUTLINED_FUNCTION_2_18();
}

void __CFPREFERENCES_HAS_DETECTED_THIS_APP_TRYING_TO_STORE_TOO_MUCH_DATA__(void *a1, const void **a2, const void **a3, CFIndex a4)
{
  NSObject *v8;
  void *v9;
  const void *v10;
  const void *v11;
  _QWORD *v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  const void *v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  _QWORD *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v8 = _CFPrefsClientLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
  {
    v9 = (void *)MEMORY[0x186DB02F4]();
    v10 = (const void *)objc_msgSend(a1, "copyOSLogDescription");
    v11 = (const void *)objc_msgSend(a1, "alreadylocked_copyDictionary");
    v12 = -[_CFPrefsOversizedPlistDescription initWithDict:setKeys:andValues:count:]([_CFPrefsOversizedPlistDescription alloc], v11, a2, a3, a4);
    v13 = _CFPrefsClientLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_FAULT))
    {
      _CFProcessNameString();
      v15 = 138544130;
      v16 = v10;
      OUTLINED_FUNCTION_11_0();
      v17 = 2114;
      v18 = v14;
      v19 = 2112;
      v20 = v12;
      _os_log_fault_impl(&dword_182A8C000, v13, OS_LOG_TYPE_FAULT, "%{public}@: Attempting to store >= %d bytes of data in CFPreferences/NSUserDefaults on this platform is invalid. This is a bug in %{public}@ or a library it uses.\n%@", (uint8_t *)&v15, 0x26u);
    }

    CFRelease(v10);
    if (v11)
      CFRelease(v11);
    objc_autoreleasePoolPop(v9);
  }
}

void _CFPrefsImpersonateApplicationWithIdentifierAndPID_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_12_0();
  OUTLINED_FUNCTION_9_1(&dword_182A8C000, v0, v1, "_CFPrefsImpersonateApplicationWithIdentifierAndPID is deprecated and does nothing. Use _CFPrefsImpersonateApplicationWithIdentifierAndAuditToken instead", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_7_3();
}

void _copyValueForKey_cold_1()
{
  uint64_t v0;
  os_log_t v1;

  OUTLINED_FUNCTION_6_4();
  OUTLINED_FUNCTION_5_5(&dword_182A8C000, v0, v1, "found no value for key %{public}@ in %{public}@");
  OUTLINED_FUNCTION_1_25();
}

void _copyValueForKey_cold_2()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_19();
  OUTLINED_FUNCTION_0_37(&dword_182A8C000, v0, v1, "Source was stale because shmem was null: %{public}@", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_25();
}

void _plistSizeIsAppropriateToRead_cold_1()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_19();
  OUTLINED_FUNCTION_0_37(&dword_182A8C000, v0, v1, "plist had invalid size: %zu.", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_25();
}

void _plistSizeIsAppropriateToRead_cold_2()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2_19();
  OUTLINED_FUNCTION_0_37(&dword_182A8C000, v0, v1, "plist is too large to deserialize in this process: %zu.", v2, v3, v4, v5, v6);
  OUTLINED_FUNCTION_1_25();
}

void _approximateSizeOfPlistValue_cold_1()
{
  __assert_rtn("_approximateSizeOfPlistValue", "CFPrefsPlistSource.m", 1905, "outObjectCounter == NULL");
}

int32_t NSVersionOfLinkTimeLibrary(const char *libraryName)
{
  return MEMORY[0x1E0C805C8](libraryName);
}

fat_arch *__cdecl NXFindBestFatArch(cpu_type_t cputype, cpu_subtype_t cpusubtype, fat_arch *fat_archs, uint32_t nfat_archs)
{
  return (fat_arch *)MEMORY[0x1E0C805D8](*(_QWORD *)&cputype, *(_QWORD *)&cpusubtype, fat_archs, *(_QWORD *)&nfat_archs);
}

const NXArchInfo *NXGetLocalArchInfo(void)
{
  return (const NXArchInfo *)MEMORY[0x1E0C805F0]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1E0C80928](aBlock);
}

BOOL _Block_isDeallocating(const void *aBlock)
{
  return MEMORY[0x1E0C80938](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
  MEMORY[0x1E0C80940](a1, a2, *(_QWORD *)&a3);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

void _Block_release(const void *aBlock)
{
  MEMORY[0x1E0C80958](aBlock);
}

const char *__cdecl _Block_signature(void *aBlock)
{
  return (const char *)MEMORY[0x1E0C80960](aBlock);
}

BOOL _Block_tryRetain(const void *aBlock)
{
  return MEMORY[0x1E0C80968](aBlock);
}

void _Block_use_RR2(const Block_callbacks_RR *callbacks)
{
  MEMORY[0x1E0C80970](callbacks);
}

uint64_t _CFURLBookmarkDataCopyDescription()
{
  return MEMORY[0x1E0D18938]();
}

uint64_t _CFURLCreateBookmarkData()
{
  return MEMORY[0x1E0D18940]();
}

uint64_t _CFURLCreateBookmarkDataFromFile()
{
  return MEMORY[0x1E0D18948]();
}

uint64_t _CFURLCreateByResolvingBookmarkData()
{
  return MEMORY[0x1E0D18950]();
}

uint64_t _CFURLCreateResourcePropertiesForKeysFromBookmarkData()
{
  return MEMORY[0x1E0D18958]();
}

uint64_t _CFURLCreateResourcePropertyForKeyFromBookmarkData()
{
  return MEMORY[0x1E0D18960]();
}

uint64_t _CFURLStartAccessingSecurityScopedResource()
{
  return MEMORY[0x1E0D18968]();
}

uint64_t _CFURLStopAccessingSecurityScopedResource()
{
  return MEMORY[0x1E0D18970]();
}

uint64_t _CFURLWriteBookmarkDataToFile()
{
  return MEMORY[0x1E0D18978]();
}

uint64_t _FSCreatePathForFileID()
{
  return MEMORY[0x1E0D18980]();
}

uint64_t _FSGetFileSystemRepresentationForFileID()
{
  return MEMORY[0x1E0D18988]();
}

uint64_t _FSURLBeginResourcePropertyCacheAccess()
{
  return MEMORY[0x1E0D18990]();
}

uint64_t _FSURLCacheResourcePropertiesForKeys()
{
  return MEMORY[0x1E0D18998]();
}

uint64_t _FSURLCacheResourcePropertyForKey()
{
  return MEMORY[0x1E0D189A0]();
}

uint64_t _FSURLClearResourcePropertyCacheForKey()
{
  return MEMORY[0x1E0D189A8]();
}

uint64_t _FSURLCopyResourcePropertiesForKeys()
{
  return MEMORY[0x1E0D189B0]();
}

uint64_t _FSURLCopyResourcePropertiesForKeysFromCache()
{
  return MEMORY[0x1E0D189B8]();
}

uint64_t _FSURLCopyResourcePropertyForKey()
{
  return MEMORY[0x1E0D189C0]();
}

uint64_t _FSURLCopyResourcePropertyForKeyFromCache()
{
  return MEMORY[0x1E0D189C8]();
}

uint64_t _FSURLCopyResourcePropertyValuesAndFlags()
{
  return MEMORY[0x1E0D189D0]();
}

uint64_t _FSURLCreateStandardError()
{
  return MEMORY[0x1E0D189D8]();
}

uint64_t _FSURLEndResourcePropertyCacheAccess()
{
  return MEMORY[0x1E0D189E0]();
}

uint64_t _FSURLGetCacheAutoFlushingEnabled()
{
  return MEMORY[0x1E0D189E8]();
}

uint64_t _FSURLGetCatalogInfo()
{
  return MEMORY[0x1E0D189F0]();
}

uint64_t _FSURLGetResourcePropertyFlags()
{
  return MEMORY[0x1E0D189F8]();
}

uint64_t _FSURLGetVolumePropertyFlags()
{
  return MEMORY[0x1E0D18A00]();
}

uint64_t _FSURLNoteSecurityScopedResourceMoved()
{
  return MEMORY[0x1E0D18A08]();
}

uint64_t _FSURLResourceIsReachable()
{
  return MEMORY[0x1E0D18A10]();
}

uint64_t _FSURLSetCacheAutoFlushingEnabled()
{
  return MEMORY[0x1E0D18A18]();
}

uint64_t _FSURLSetPermanentResourcePropertyForKey()
{
  return MEMORY[0x1E0D18A20]();
}

uint64_t _FSURLSetResourcePropertiesForKeys()
{
  return MEMORY[0x1E0D18A28]();
}

uint64_t _FSURLSetResourcePropertyForKey()
{
  return MEMORY[0x1E0D18A30]();
}

uint64_t _FileCacheClearPropertyValueForKey()
{
  return MEMORY[0x1E0D18A38]();
}

uint64_t _FileCacheCreateShallowCopy()
{
  return MEMORY[0x1E0D18A40]();
}

uint64_t _FileCacheGetFinderInfo()
{
  return MEMORY[0x1E0D18A48]();
}

uint64_t _FileCacheGetFlags()
{
  return MEMORY[0x1E0D18A50]();
}

uint64_t _FileCacheGetName()
{
  return MEMORY[0x1E0D18A58]();
}

uint64_t _FileCacheGetPropertyValueForKey()
{
  return MEMORY[0x1E0D18A60]();
}

uint64_t _FileCacheSetPropertyValueForKey()
{
  return MEMORY[0x1E0D18A68]();
}

uint64_t _FileURLCreateDisplayPathComponentsArray()
{
  return MEMORY[0x1E0D18A70]();
}

int *_NSGetArgc(void)
{
  return (int *)MEMORY[0x1E0C809C0]();
}

char ***_NSGetArgv(void)
{
  return (char ***)MEMORY[0x1E0C809C8]();
}

int _NSGetExecutablePath(char *buf, uint32_t *bufsize)
{
  return MEMORY[0x1E0C809D8](buf, bufsize);
}

mach_header_64 *_NSGetMachExecuteHeader(void)
{
  return (mach_header_64 *)MEMORY[0x1E0C809E0]();
}

uint64_t _RegisterFilePropertyProvider()
{
  return MEMORY[0x1E0D18A78]();
}

uint64_t _RegisterFilePropertyWithOptions()
{
  return MEMORY[0x1E0D18A80]();
}

uint64_t _URLAttachSecurityScopeToFileURL()
{
  return MEMORY[0x1E0D18A88]();
}

uint64_t _URLCopySecurityScopeFromFileURL()
{
  return MEMORY[0x1E0D18A90]();
}

uint64_t _URLCreateByResolvingAliasFile()
{
  return MEMORY[0x1E0D18A98]();
}

uint64_t _URLEnumeratorCreateForDirectoryURL()
{
  return MEMORY[0x1E0D18AA0]();
}

uint64_t _URLEnumeratorCreateForMountedVolumes()
{
  return MEMORY[0x1E0D18AA8]();
}

uint64_t _URLEnumeratorGetDescendentLevel()
{
  return MEMORY[0x1E0D18AB0]();
}

uint64_t _URLEnumeratorGetNextURL()
{
  return MEMORY[0x1E0D18AB8]();
}

uint64_t _URLEnumeratorGetSourceDidChange()
{
  return MEMORY[0x1E0D18AC0]();
}

uint64_t _URLEnumeratorGetTypeID()
{
  return MEMORY[0x1E0D18AC8]();
}

uint64_t _URLEnumeratorGetURLsBulk()
{
  return MEMORY[0x1E0D18AD0]();
}

uint64_t _URLEnumeratorSkipDescendents()
{
  return MEMORY[0x1E0D18AD8]();
}

uint64_t _URLReplaceObject()
{
  return MEMORY[0x1E0D18AE0]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

uint64_t __NSCreateBPlistMappedDataFromURL()
{
  return MEMORY[0x1E0CB3C80]();
}

uint64_t __NSCreateBPlistMappedString()
{
  return MEMORY[0x1E0CB3C88]();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x1E0C80A58](a1, a2, *(_QWORD *)&a3, a4);
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return MEMORY[0x1E0C80AA0](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

int *__error(void)
{
  return (int *)MEMORY[0x1E0C80AC0]();
}

double __exp10(double a1)
{
  double result;

  MEMORY[0x1E0C80AC8](a1);
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1E0C80B50](*(_QWORD *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1E0C80B68]();
}

uint64_t __memmove_chk()
{
  return MEMORY[0x1E0C80B70]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x1E0C80B78]();
}

uint64_t __stpcpy_chk()
{
  return MEMORY[0x1E0C80C28]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x1E0C80C40]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1E0C80C48]();
}

uint64_t __strncat_chk()
{
  return MEMORY[0x1E0C80C50]();
}

uint64_t __strncpy_chk()
{
  return MEMORY[0x1E0C80C58]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C70](*(_QWORD *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1E0C80C78](*(_QWORD *)&a1);
}

uint64_t __udivti3()
{
  return MEMORY[0x1E0C80C80]();
}

uint64_t _dispatch_get_main_queue_port_4CF()
{
  return MEMORY[0x1E0C80D20]();
}

uint64_t _dispatch_main_queue_callback_4CF()
{
  return MEMORY[0x1E0C80D40]();
}

uint64_t _dispatch_runloop_root_queue_create_4CF()
{
  return MEMORY[0x1E0C80D58]();
}

uint64_t _dispatch_runloop_root_queue_get_port_4CF()
{
  return MEMORY[0x1E0C80D60]();
}

uint64_t _dispatch_runloop_root_queue_perform_4CF()
{
  return MEMORY[0x1E0C80D68]();
}

const mach_header *__cdecl _dyld_get_image_header(uint32_t image_index)
{
  return (const mach_header *)MEMORY[0x1E0C80E60](*(_QWORD *)&image_index);
}

const char *__cdecl _dyld_get_image_name(uint32_t image_index)
{
  return (const char *)MEMORY[0x1E0C80E68](*(_QWORD *)&image_index);
}

intptr_t _dyld_get_image_vmaddr_slide(uint32_t image_index)
{
  return MEMORY[0x1E0C80E80](*(_QWORD *)&image_index);
}

uint32_t _dyld_image_count(void)
{
  return MEMORY[0x1E0C80EB8]();
}

uint64_t _dyld_is_memory_immutable()
{
  return MEMORY[0x1E0C80EC8]();
}

BOOL _dyld_shared_cache_contains_path(const char *path)
{
  return MEMORY[0x1E0C80F60](path);
}

uint64_t _objc_autoreleasePoolPrint()
{
  return MEMORY[0x1E0DE7968]();
}

uint64_t _objc_getFreedObjectClass()
{
  return MEMORY[0x1E0DE79A8]();
}

uint64_t _objc_registerTaggedPointerClass()
{
  return MEMORY[0x1E0DE79C8]();
}

uint64_t _objc_rootAllocWithZone()
{
  return MEMORY[0x1E0DE79D8]();
}

uint64_t _objc_rootAutorelease()
{
  return MEMORY[0x1E0DE79E0]();
}

uint64_t _objc_rootDealloc()
{
  return MEMORY[0x1E0DE79E8]();
}

uint64_t _objc_rootRelease()
{
  return MEMORY[0x1E0DE7A08]();
}

uint64_t _objc_rootRetain()
{
  return MEMORY[0x1E0DE7A18]();
}

uint64_t _objc_rootTryRetain()
{
  return MEMORY[0x1E0DE7A28]();
}

uint64_t _objc_setBadAllocHandler()
{
  return MEMORY[0x1E0DE7A38]();
}

os_activity_t _os_activity_create(void *dso, const char *description, os_activity_t activity, os_activity_flag_t flags)
{
  return (os_activity_t)MEMORY[0x1E0C80FC0](dso, description, activity, *(_QWORD *)&flags);
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1E0C81010]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81020](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81040](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

uint64_t _os_log_pack_fill()
{
  return MEMORY[0x1E0C81058]();
}

uint64_t _os_log_pack_size()
{
  return MEMORY[0x1E0C81060]();
}

uint64_t _os_log_set_nscf_formatter()
{
  return MEMORY[0x1E0C81070]();
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1E0C813C8](*(_QWORD *)&a1, a2, a3);
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1E0C813D0](a1, *(_QWORD *)&a2);
}

acl_t acl_dup(acl_t acl)
{
  return (acl_t)MEMORY[0x1E0C81430](acl);
}

int acl_free(void *obj_p)
{
  return MEMORY[0x1E0C81438](obj_p);
}

acl_t acl_from_text(const char *buf_p)
{
  return (acl_t)MEMORY[0x1E0C81440](buf_p);
}

char *__cdecl acl_to_text(acl_t acl, ssize_t *len_p)
{
  return (char *)MEMORY[0x1E0C814F8](acl, len_p);
}

uint32_t arc4random(void)
{
  return MEMORY[0x1E0C81570]();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
  MEMORY[0x1E0C81580](__buf, __nbytes);
}

void asl_close(asl_object_t obj)
{
  MEMORY[0x1E0C815C0](obj);
}

void asl_free(asl_object_t obj)
{
  MEMORY[0x1E0C815C8](obj);
}

asl_object_t asl_new(uint32_t type)
{
  return (asl_object_t)MEMORY[0x1E0C815D8](*(_QWORD *)&type);
}

asl_object_t asl_open(const char *ident, const char *facility, uint32_t opts)
{
  return (asl_object_t)MEMORY[0x1E0C815E0](ident, facility, *(_QWORD *)&opts);
}

int asl_send(asl_object_t obj, asl_object_t msg)
{
  return MEMORY[0x1E0C815E8](obj, msg);
}

int asl_set(asl_object_t obj, const char *key, const char *value)
{
  return MEMORY[0x1E0C815F0](obj, key, value);
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1E0C81608](a1, a2);
}

int atexit(void (*a1)(void))
{
  return MEMORY[0x1E0C81648](a1);
}

uint64_t atol(const char *a1)
{
  return MEMORY[0x1E0C81678](a1);
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1E0C816B8](a1, *(_QWORD *)&a2);
}

char **__cdecl backtrace_symbols(void *const *a1, int a2)
{
  return (char **)MEMORY[0x1E0C816C8](a1, *(_QWORD *)&a2);
}

char *__cdecl basename_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1E0C816E0](a1, a2);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1E0C816F0](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

kern_return_t bootstrap_check_in(mach_port_t bp, const name_t service_name, mach_port_t *sp)
{
  return MEMORY[0x1E0C816F8](*(_QWORD *)&bp, service_name, sp);
}

uint64_t bootstrap_look_up2()
{
  return MEMORY[0x1E0C81710]();
}

uint64_t bootstrap_register2()
{
  return MEMORY[0x1E0C81728]();
}

const char *__cdecl bootstrap_strerror(kern_return_t r)
{
  return (const char *)MEMORY[0x1E0C81730](*(_QWORD *)&r);
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return (void *)MEMORY[0x1E0C81738](__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

int cache_create(const char *name, const cache_attributes_t *attrs, cache_t **cache_out)
{
  return MEMORY[0x1E0C81770](name, attrs, cache_out);
}

int cache_destroy(cache_t *cache)
{
  return MEMORY[0x1E0C81778](cache);
}

uint64_t cache_get()
{
  return MEMORY[0x1E0C81780]();
}

uint64_t cache_get_cost_hint()
{
  return MEMORY[0x1E0C81790]();
}

uint64_t cache_get_count_hint()
{
  return MEMORY[0x1E0C81798]();
}

uint64_t cache_get_minimum_values_hint()
{
  return MEMORY[0x1E0C817B0]();
}

uint64_t cache_get_name()
{
  return MEMORY[0x1E0C817B8]();
}

uint64_t cache_invoke()
{
  return MEMORY[0x1E0C817C8]();
}

int cache_release_value(cache_t *cache, void *value)
{
  return MEMORY[0x1E0C817D8](cache, value);
}

int cache_remove(cache_t *cache, void *key)
{
  return MEMORY[0x1E0C817E0](cache, key);
}

int cache_remove_all(cache_t *cache)
{
  return MEMORY[0x1E0C817E8](cache);
}

uint64_t cache_remove_with_block()
{
  return MEMORY[0x1E0C817F0]();
}

int cache_set_and_retain(cache_t *cache, void *key, void *value, cache_cost_t cost)
{
  return MEMORY[0x1E0C817F8](cache, key, value, cost);
}

uint64_t cache_set_cost_hint()
{
  return MEMORY[0x1E0C81800]();
}

uint64_t cache_set_count_hint()
{
  return MEMORY[0x1E0C81808]();
}

uint64_t cache_set_minimum_values_hint()
{
  return MEMORY[0x1E0C81810]();
}

uint64_t cache_set_name()
{
  return MEMORY[0x1E0C81818]();
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x1E0C82638](a1, a2);
}

Protocol **__cdecl class_copyProtocolList(Class cls, unsigned int *outCount)
{
  return (Protocol **)MEMORY[0x1E0DE7A88](cls, outCount);
}

id class_createInstance(Class cls, size_t extraBytes)
{
  return (id)MEMORY[0x1E0DE7A90](cls, extraBytes);
}

Method class_getInstanceMethod(Class cls, SEL name)
{
  return (Method)MEMORY[0x1E0DE7AA8](cls, name);
}

size_t class_getInstanceSize(Class cls)
{
  return MEMORY[0x1E0DE7AB0](cls);
}

IMP class_getMethodImplementation(Class cls, SEL name)
{
  return (IMP)MEMORY[0x1E0DE7AC0](cls, name);
}

const char *__cdecl class_getName(Class cls)
{
  return (const char *)MEMORY[0x1E0DE7AC8](cls);
}

Class class_getSuperclass(Class cls)
{
  return (Class)MEMORY[0x1E0DE7AD8](cls);
}

BOOL class_isMetaClass(Class cls)
{
  return MEMORY[0x1E0DE7AE8](cls);
}

BOOL class_respondsToSelector(Class cls, SEL sel)
{
  return MEMORY[0x1E0DE7AF8](cls, sel);
}

Class class_setSuperclass(Class cls, Class newSuper)
{
  return (Class)MEMORY[0x1E0DE7B00](cls, newSuper);
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return MEMORY[0x1E0C82668](*(_QWORD *)&__clock_id, __tp);
}

int close(int a1)
{
  return MEMORY[0x1E0C82688](*(_QWORD *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1E0C82698](a1);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return MEMORY[0x1E0C826D8](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

uint64_t container_create_or_lookup_app_group_path_by_app_group_identifier()
{
  return MEMORY[0x1E0C827F8]();
}

uint64_t container_error_copy_unlocalized_description()
{
  return MEMORY[0x1E0C82868]();
}

uint64_t container_get_error_description()
{
  return MEMORY[0x1E0C828D0]();
}

uint64_t container_get_identifier()
{
  return MEMORY[0x1E0C828D8]();
}

uint64_t container_get_path()
{
  return MEMORY[0x1E0C828E8]();
}

uint64_t container_query_create()
{
  return MEMORY[0x1E0C829B8]();
}

uint64_t container_query_free()
{
  return MEMORY[0x1E0C829C8]();
}

uint64_t container_query_get_last_error()
{
  return MEMORY[0x1E0C829D0]();
}

uint64_t container_query_iterate_results_sync()
{
  return MEMORY[0x1E0C829E0]();
}

uint64_t container_query_operation_set_flags()
{
  return MEMORY[0x1E0C829E8]();
}

uint64_t container_query_set_class()
{
  return MEMORY[0x1E0C829F8]();
}

uint64_t container_query_set_identifiers()
{
  return MEMORY[0x1E0C82A08]();
}

uint64_t container_query_set_persona_unique_string()
{
  return MEMORY[0x1E0C82A18]();
}

uint64_t container_query_set_uid()
{
  return MEMORY[0x1E0C82A28]();
}

uint64_t container_system_group_path_for_identifier()
{
  return MEMORY[0x1E0C82A90]();
}

uint64_t csops()
{
  return MEMORY[0x1E0C82B68]();
}

uint64_t csops_audittoken()
{
  return MEMORY[0x1E0C82B70]();
}

char *__cdecl ctime_r(const time_t *a1, char *a2)
{
  return (char *)MEMORY[0x1E0C82B88](a1, a2);
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1E0C82BB0](a1, a2);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
  MEMORY[0x1E0C82BD8](iterations, queue, block);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x1E0C82BE8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1E0C82C60](flags, block);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return (dispatch_data_t)MEMORY[0x1E0C82CB0](buffer, size, queue, destructor);
}

uint64_t dispatch_data_create_alloc()
{
  return MEMORY[0x1E0C82CB8]();
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1E0C82D00](identifier, flags);
}

void dispatch_main(void)
{
  MEMORY[0x1E0C82DF0]();
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E28](attr, frequency);
}

uint64_t dispatch_queue_attr_make_with_overcommit()
{
  return MEMORY[0x1E0C82E30]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E38](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E50](label, attr, target);
}

void dispatch_release(dispatch_object_t object)
{
  MEMORY[0x1E0C82E98](object);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

void dispatch_retain(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA8](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F48](source, handler);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x1E0C82F78](source, start, interval, leeway);
}

void dispatch_suspend(dispatch_object_t object)
{
  MEMORY[0x1E0C82F88](object);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  return MEMORY[0x1E0C82FC8](when, delta);
}

int dladdr(const void *a1, Dl_info *a2)
{
  return MEMORY[0x1E0C83028](a1, a2);
}

int dlclose(void *__handle)
{
  return MEMORY[0x1E0C83030](__handle);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1E0C83038]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

BOOL dlopen_preflight(const char *__path)
{
  return MEMORY[0x1E0C83048](__path);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

int dup(int a1)
{
  return MEMORY[0x1E0C83078](*(_QWORD *)&a1);
}

int dup2(int a1, int a2)
{
  return MEMORY[0x1E0C83088](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

uint64_t dyld_get_active_platform()
{
  return MEMORY[0x1E0C830A0]();
}

uint64_t dyld_has_inserted_or_interposing_libraries()
{
  return MEMORY[0x1E0C830C8]();
}

uint64_t dyld_image_path_containing_address()
{
  return MEMORY[0x1E0C83100]();
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1E0C83158]();
}

void exit(int a1)
{
  MEMORY[0x1E0C83278](*(_QWORD *)&a1);
}

int fchmod(int a1, mode_t a2)
{
  return MEMORY[0x1E0C832D0](*(_QWORD *)&a1, a2);
}

int fchown(int a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x1E0C832E0](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1E0C83300](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1E0C83370](a1);
}

filesec_t filesec_dup(filesec_t a1)
{
  return (filesec_t)MEMORY[0x1E0C833C8](a1);
}

void filesec_free(filesec_t a1)
{
  MEMORY[0x1E0C833D0](a1);
}

int filesec_get_property(filesec_t a1, filesec_property_t a2, void *a3)
{
  return MEMORY[0x1E0C833D8](a1, *(_QWORD *)&a2, a3);
}

filesec_t filesec_init(void)
{
  return (filesec_t)MEMORY[0x1E0C833E0]();
}

int filesec_set_property(filesec_t a1, filesec_property_t a2, const void *a3)
{
  return MEMORY[0x1E0C833E8](a1, *(_QWORD *)&a2, a3);
}

int filesec_unset_property(filesec_t a1, filesec_property_t a2)
{
  return MEMORY[0x1E0C833F0](a1, *(_QWORD *)&a2);
}

int flsl(uint64_t a1)
{
  return MEMORY[0x1E0C83420](a1);
}

long double fmod(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C83440](__x, __y);
  return result;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1E0C83460](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

int fprintf_l(FILE *a1, locale_t a2, const char *a3, ...)
{
  return MEMORY[0x1E0C83480](a1, a2, a3);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1E0C83490](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

int fsetxattr(int fd, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1E0C83548](*(_QWORD *)&fd, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1E0C83560](*(_QWORD *)&a1, a2);
}

int fstatat(int a1, const char *a2, stat *a3, int a4)
{
  return MEMORY[0x1E0C83568](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

int fstatfs(int a1, statfs *a2)
{
  return MEMORY[0x1E0C83570](*(_QWORD *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x1E0C83578](*(_QWORD *)&a1);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1E0C83590](*(_QWORD *)&a1, a2);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1E0C835E0](__ptr, __size, __nitems, __stream);
}

char *__cdecl getcwd(char *a1, size_t a2)
{
  return (char *)MEMORY[0x1E0C83648](a1, a2);
}

gid_t getegid(void)
{
  return MEMORY[0x1E0C83658]();
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1E0C83660](a1);
}

uid_t geteuid(void)
{
  return MEMORY[0x1E0C83668]();
}

int gethostname(char *a1, size_t a2)
{
  return MEMORY[0x1E0C836B8](a1, a2);
}

int getpeername(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1E0C83748](*(_QWORD *)&a1, a2, a3);
}

pid_t getpid(void)
{
  return MEMORY[0x1E0C83760]();
}

const char *getprogname(void)
{
  return (const char *)MEMORY[0x1E0C83778]();
}

passwd *__cdecl getpwnam(const char *a1)
{
  return (passwd *)MEMORY[0x1E0C83790](a1);
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return (passwd *)MEMORY[0x1E0C837A0](*(_QWORD *)&a1);
}

int getrlimit(int a1, rlimit *a2)
{
  return MEMORY[0x1E0C837B8](*(_QWORD *)&a1, a2);
}

const section_64 *__cdecl getsectbynamefromheader_64(const mach_header_64 *mhp, const char *segname, const char *sectname)
{
  return (const section_64 *)MEMORY[0x1E0C837C8](mhp, segname, sectname);
}

const segment_command_64 *__cdecl getsegbyname(const char *segname)
{
  return (const segment_command_64 *)MEMORY[0x1E0C837E8](segname);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return MEMORY[0x1E0C83810](*(_QWORD *)&a1, a2, a3);
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return MEMORY[0x1E0C83818](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1E0C83820](a1, a2);
}

uid_t getuid(void)
{
  return MEMORY[0x1E0C83828]();
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1E0C83840](path, name, value, size, *(_QWORD *)&position, *(_QWORD *)&options);
}

tm *__cdecl gmtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1E0C83860](a1, a2);
}

kern_return_t host_check_multiuser_mode(host_t host, uint32_t *multiuser_mode)
{
  return MEMORY[0x1E0C83898](*(_QWORD *)&host, multiuser_mode);
}

uint64_t instrumentObjcMessageSends()
{
  return MEMORY[0x1E0DE7B20]();
}

int ioctl(int a1, unint64_t a2, ...)
{
  return MEMORY[0x1E0C83980](*(_QWORD *)&a1, a2);
}

int issetugid(void)
{
  return MEMORY[0x1E0C839B8]();
}

uint64_t kdebug_is_enabled()
{
  return MEMORY[0x1E0C83A10]();
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1E0C83A20]();
}

uint64_t kdebug_trace_string()
{
  return MEMORY[0x1E0C83A28]();
}

uint64_t kpersona_info()
{
  return MEMORY[0x1E0C83A60]();
}

int listen(int a1, int a2)
{
  return MEMORY[0x1E0C83B80](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  return (tm *)MEMORY[0x1E0C83BB0](a1, a2);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1E0C83C38](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C83C40](a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1E0C83C50]();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return (char *)MEMORY[0x1E0C83C80](*(_QWORD *)&error_value);
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return MEMORY[0x1E0C83CB0](msg, *(_QWORD *)&option, *(_QWORD *)&send_size, *(_QWORD *)&rcv_size, *(_QWORD *)&rcv_name, *(_QWORD *)&timeout, *(_QWORD *)&notify);
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
  MEMORY[0x1E0C83CC0](a1);
}

kern_return_t mach_port_allocate(ipc_space_t task, mach_port_right_t right, mach_port_name_t *name)
{
  return MEMORY[0x1E0C83CE0](*(_QWORD *)&task, *(_QWORD *)&right, name);
}

kern_return_t mach_port_construct(ipc_space_t task, mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  return MEMORY[0x1E0C83CE8](*(_QWORD *)&task, options, context, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return MEMORY[0x1E0C83CF8](*(_QWORD *)&task, *(_QWORD *)&name);
}

kern_return_t mach_port_destruct(ipc_space_t task, mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  return MEMORY[0x1E0C83D08](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&srdelta, guard);
}

kern_return_t mach_port_extract_member(ipc_space_t task, mach_port_name_t name, mach_port_name_t pset)
{
  return MEMORY[0x1E0C83D10](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&pset);
}

kern_return_t mach_port_get_attributes(ipc_space_read_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info_out, mach_msg_type_number_t *port_info_outCnt)
{
  return MEMORY[0x1E0C83D20](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&flavor, port_info_out, port_info_outCnt);
}

kern_return_t mach_port_insert_member(ipc_space_t task, mach_port_name_t name, mach_port_name_t pset)
{
  return MEMORY[0x1E0C83D40](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&pset);
}

kern_return_t mach_port_insert_right(ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly)
{
  return MEMORY[0x1E0C83D48](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&poly, *(_QWORD *)&polyPoly);
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return MEMORY[0x1E0C83D58](*(_QWORD *)&task, *(_QWORD *)&name, *(_QWORD *)&right, *(_QWORD *)&delta);
}

kern_return_t mach_port_type(ipc_space_t task, mach_port_name_t name, mach_port_type_t *ptype)
{
  return MEMORY[0x1E0C83D88](*(_QWORD *)&task, *(_QWORD *)&name, ptype);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1E0C83DB8](info);
}

kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags)
{
  return MEMORY[0x1E0C83DC0](*(_QWORD *)&target, address, size, *(_QWORD *)&flags);
}

kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  return MEMORY[0x1E0C83DD0](*(_QWORD *)&target, address, size);
}

kern_return_t mach_vm_region(vm_map_read_t target_task, mach_vm_address_t *address, mach_vm_size_t *size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t *infoCnt, mach_port_t *object_name)
{
  return MEMORY[0x1E0C83E00](*(_QWORD *)&target_task, address, size, *(_QWORD *)&flavor, info, infoCnt, object_name);
}

malloc_zone_t *malloc_default_zone(void)
{
  return (malloc_zone_t *)MEMORY[0x1E0C83E88]();
}

size_t malloc_good_size(size_t size)
{
  return MEMORY[0x1E0C83EB0](size);
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x1E0C83EE0](ptr);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F10](ptr, size, type_id);
}

void *__cdecl malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F20](zone, count, size, type_id);
}

void *__cdecl malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F28](zone, size, type_id);
}

void *__cdecl malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F38](zone, alignment, size, type_id);
}

void *__cdecl malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F40](zone, ptr, size, type_id);
}

void malloc_zone_free(malloc_zone_t *zone, void *ptr)
{
  MEMORY[0x1E0C83F70](zone, ptr);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1E0C84070](__s, *(_QWORD *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

void method_exchangeImplementations(Method m1, Method m2)
{
  MEMORY[0x1E0DE7B50](m1, m2);
}

SEL method_getName(Method m)
{
  return (SEL)MEMORY[0x1E0DE7B70](m);
}

const char *__cdecl method_getTypeEncoding(Method m)
{
  return (const char *)MEMORY[0x1E0DE7B88](m);
}

uint64_t mk_timer_arm()
{
  return MEMORY[0x1E0C84138]();
}

uint64_t mk_timer_cancel()
{
  return MEMORY[0x1E0C84148]();
}

uint64_t mk_timer_create()
{
  return MEMORY[0x1E0C84150]();
}

uint64_t mk_timer_destroy()
{
  return MEMORY[0x1E0C84158]();
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1E0C84160](a1, a2);
}

int mkdirat(int a1, const char *a2, mode_t a3)
{
  return MEMORY[0x1E0C84168](*(_QWORD *)&a1, a2, a3);
}

int mkstemp(char *a1)
{
  return MEMORY[0x1E0C841A0](a1);
}

int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
{
  return MEMORY[0x1E0C841A8](path, *(_QWORD *)&dpclass, *(_QWORD *)&dpflags);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1E0C841D8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

long double modf(long double __x, long double *__y)
{
  long double result;

  MEMORY[0x1E0C841E0](__y, __x);
  return result;
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1E0C84220](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1E0C843D8](*(_QWORD *)&token);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1E0C843F8](name);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1E0C84408](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

id objc_allocWithZone(Class a1)
{
  return (id)MEMORY[0x1E0DE7BB0](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x1E0DE7BC0](superclass, name, extraBytes);
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x1E0DE7BD8](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1E0DE7BE0]();
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1E0DE7BF0](exc_buf);
}

id objc_constructInstance(Class cls, void *bytes)
{
  return (id)MEMORY[0x1E0DE7C00](cls, bytes);
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x1E0DE7C38](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x1E0DE7C60](location);
}

void *__cdecl objc_destructInstance(id obj)
{
  return (void *)MEMORY[0x1E0DE7C68](obj);
}

Class objc_duplicateClass(Class original, const char *name, size_t extraBytes)
{
  return (Class)MEMORY[0x1E0DE7C78](original, name, extraBytes);
}

void objc_end_catch(void)
{
  MEMORY[0x1E0DE7C80]();
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x1E0DE7C90](obj);
}

void objc_exception_rethrow(void)
{
  MEMORY[0x1E0DE7C98]();
}

void objc_exception_throw(id exception)
{
  MEMORY[0x1E0DE7CA0](exception);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7CB0](name);
}

Class objc_getFutureClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7CC0](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1E0DE7CD0](self, _cmd, offset, atomic);
}

Protocol *__cdecl objc_getProtocol(const char *name)
{
  return (Protocol *)MEMORY[0x1E0DE7CD8](name);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1E0DE7CE0](location, val);
}

uint64_t objc_initializeClassPair()
{
  return MEMORY[0x1E0DE7CF0]();
}

id objc_loadWeak(id *location)
{
  return (id)MEMORY[0x1E0DE7D00](location);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1E0DE7D08](location);
}

Class objc_lookUpClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7D10](name);
}

void objc_moveWeak(id *to, id *from)
{
  MEMORY[0x1E0DE7D18](to, from);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D20](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1E0DE7D48]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1E0DE7D50]();
}

uint64_t objc_opt_self()
{
  return MEMORY[0x1E0DE7D58]();
}

void objc_registerClassPair(Class cls)
{
  MEMORY[0x1E0DE7D68](cls);
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
  MEMORY[0x1E0DE7F40](object, key, value, policy);
}

void objc_setEnumerationMutationHandler(void (__cdecl *handler)(id))
{
  MEMORY[0x1E0DE7F48](handler);
}

objc_exception_matcher objc_setExceptionMatcher(objc_exception_matcher fn)
{
  return (objc_exception_matcher)MEMORY[0x1E0DE7F50](fn);
}

objc_exception_preprocessor objc_setExceptionPreprocessor(objc_exception_preprocessor fn)
{
  return (objc_exception_preprocessor)MEMORY[0x1E0DE7F58](fn);
}

void objc_setForwardHandler(void *fwd, void *fwd_stret)
{
  MEMORY[0x1E0DE7F60](fwd, fwd_stret);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F88](self, _cmd, newValue, offset);
}

objc_uncaught_exception_handler objc_setUncaughtExceptionHandler(objc_uncaught_exception_handler fn)
{
  return (objc_uncaught_exception_handler)MEMORY[0x1E0DE7FA8](fn);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1E0DE7FB8](location, obj);
}

id objc_storeWeakOrNil(id *location, id obj)
{
  return (id)MEMORY[0x1E0DE7FC0](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1E0DE7FC8](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1E0DE7FD0](obj);
}

void objc_terminate(void)
{
  MEMORY[0x1E0DE7FD8]();
}

id object_dispose(id a1)
{
  return (id)MEMORY[0x1E0DE7FF0](a1);
}

Class object_getClass(id a1)
{
  return (Class)MEMORY[0x1E0DE7FF8](a1);
}

const char *__cdecl object_getClassName(id a1)
{
  return (const char *)MEMORY[0x1E0DE8000](a1);
}

void *__cdecl object_getIndexedIvars(id a1)
{
  return (void *)MEMORY[0x1E0DE8008](a1);
}

uint64_t object_getMethodImplementation()
{
  return MEMORY[0x1E0DE8020]();
}

Class object_setClass(id a1, Class a2)
{
  return (Class)MEMORY[0x1E0DE8030](a1, a2);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1E0C84480](a1, *(_QWORD *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x1E0C84488](a1, *(_QWORD *)&a2, *(_QWORD *)&a3, *(_QWORD *)&a4);
}

int openat(int a1, const char *a2, int a3, ...)
{
  return MEMORY[0x1E0C844A0](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1E0C844C0](a1);
}

void os_activity_scope_enter(os_activity_t activity, os_activity_scope_state_t state)
{
  MEMORY[0x1E0C84510](activity, state);
}

void os_activity_scope_leave(os_activity_scope_state_t state)
{
  MEMORY[0x1E0C84518](state);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

uint64_t os_log_shim_enabled()
{
  return MEMORY[0x1E0C84760]();
}

uint64_t os_log_shim_with_CFString()
{
  return MEMORY[0x1E0C84770]();
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

uint64_t os_transaction_create()
{
  return MEMORY[0x1E0C84970]();
}

void os_unfair_lock_assert_not_owner(const os_unfair_lock *lock)
{
  MEMORY[0x1E0C84988](lock);
}

void os_unfair_lock_assert_owner(const os_unfair_lock *lock)
{
  MEMORY[0x1E0C84990](lock);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C84998](lock);
}

uint64_t os_unfair_lock_lock_with_options()
{
  return MEMORY[0x1E0C849A0]();
}

BOOL os_unfair_lock_trylock(os_unfair_lock_t lock)
{
  return MEMORY[0x1E0C849A8](lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C849B0](lock);
}

uint64_t os_unfair_recursive_lock_lock_with_options()
{
  return MEMORY[0x1E0C849B8]();
}

uint64_t os_unfair_recursive_lock_unlock()
{
  return MEMORY[0x1E0C849D0]();
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x1E0C849F8]();
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1E0C84BD0](a1);
}

int proc_name(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1E0C84C20](*(_QWORD *)&pid, buffer, *(_QWORD *)&buffersize);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return MEMORY[0x1E0C84C40](*(_QWORD *)&pid, *(_QWORD *)&flavor, arg, buffer, *(_QWORD *)&buffersize);
}

int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1E0C84C50](*(_QWORD *)&pid, buffer, *(_QWORD *)&buffersize);
}

objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
{
  const char *v4;
  char *v5;
  objc_method_description result;

  v4 = (const char *)MEMORY[0x1E0DE80A8](p, aSel, isRequiredMethod, isInstanceMethod);
  result.types = v5;
  result.name = v4;
  return result;
}

uint64_t pselect_DARWIN_EXTSN()
{
  return MEMORY[0x1E0C84C90]();
}

int pthread_atfork(void (*a1)(void), void (*a2)(void), void (*a3)(void))
{
  return MEMORY[0x1E0C84CA8](a1, a2, a3);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1E0C84CB0](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1E0C84CC8](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x1E0C84CD0](__attr, *(_QWORD *)&__qos_class, *(_QWORD *)&__relative_priority);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1E0C84CD8](a1, *(_QWORD *)&a2);
}

int pthread_attr_setscope(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1E0C84CF8](a1, *(_QWORD *)&a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1E0C84D50](a1, a2, a3, a4);
}

int pthread_equal(pthread_t a1, pthread_t a2)
{
  return MEMORY[0x1E0C84D80](a1, a2);
}

int pthread_getugid_np(uid_t *a1, gid_t *a2)
{
  return MEMORY[0x1E0C84DC8](a1, a2);
}

int pthread_is_threaded_np(void)
{
  return MEMORY[0x1E0C84DD0]();
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x1E0C84DE0](a1, a2);
}

uint64_t pthread_key_init_np()
{
  return MEMORY[0x1E0C84DF0]();
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x1E0C84E00](a1);
}

int pthread_main_np(void)
{
  return MEMORY[0x1E0C84E08]();
}

uint64_t pthread_main_thread_np()
{
  return MEMORY[0x1E0C84E10]();
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E18](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1E0C84E20](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E28](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1E0C84E38](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E40](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x1E0C84E48](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x1E0C84E60](a1, *(_QWORD *)&a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1E0C84ED8]();
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x1E0C84F08](a1);
}

int pthread_threadid_np(pthread_t a1, __uint64_t *a2)
{
  return MEMORY[0x1E0C84F38](a1, a2);
}

int puts(const char *a1)
{
  return MEMORY[0x1E0C84F60](a1);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1E0C84F68](*(_QWORD *)&__fd, __buf, __nbyte, a4);
}

qos_class_t qos_class_main(void)
{
  return MEMORY[0x1E0C84F78]();
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x1E0C84F80]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x1E0C84F88](__base, __nel, __width, __compar);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1E0C85000](*(_QWORD *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1E0C85008](a1);
}

int readdir_r(DIR *a1, dirent *a2, dirent **a3)
{
  return MEMORY[0x1E0C85010](a1, a2, a3);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x1E0C85018](a1, a2, a3);
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return MEMORY[0x1E0C85060](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

ssize_t recvfrom(int a1, void *a2, size_t a3, int a4, sockaddr *a5, socklen_t *a6)
{
  return MEMORY[0x1E0C85068](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4, a5, a6);
}

int renameat(int a1, const char *a2, int a3, const char *a4)
{
  return MEMORY[0x1E0C85108](*(_QWORD *)&a1, a2, *(_QWORD *)&a3, a4);
}

int rmdir(const char *a1)
{
  return MEMORY[0x1E0C85138](a1);
}

uint64_t sandbox_check()
{
  return MEMORY[0x1E0C85178]();
}

uint64_t sandbox_check_by_audit_token()
{
  return MEMORY[0x1E0C85180]();
}

uint64_t sandbox_container_path_for_audit_token()
{
  return MEMORY[0x1E0C85188]();
}

uint64_t sandbox_passthrough_access()
{
  return MEMORY[0x1E0C85220]();
}

long double scalbn(long double __x, int __y)
{
  long double result;

  MEMORY[0x1E0C85240](*(_QWORD *)&__y, __x);
  return result;
}

const char *__cdecl sel_getName(SEL sel)
{
  return (const char *)MEMORY[0x1E0DE80C8](sel);
}

SEL sel_getUid(const char *str)
{
  return (SEL)MEMORY[0x1E0DE80D0](str);
}

SEL sel_registerName(const char *str)
{
  return (SEL)MEMORY[0x1E0DE80E8](str);
}

uint64_t select_DARWIN_EXTSN()
{
  return MEMORY[0x1E0C85288]();
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return MEMORY[0x1E0C852F8](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4);
}

ssize_t sendto(int a1, const void *a2, size_t a3, int a4, const sockaddr *a5, socklen_t a6)
{
  return MEMORY[0x1E0C85310](*(_QWORD *)&a1, a2, a3, *(_QWORD *)&a4, a5, *(_QWORD *)&a6);
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  return MEMORY[0x1E0C85328](__name, __value, *(_QWORD *)&__overwrite);
}

int setiopolicy_np(int a1, int a2, int a3)
{
  return MEMORY[0x1E0C85340](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int setrlimit(int a1, const rlimit *a2)
{
  return MEMORY[0x1E0C85380](*(_QWORD *)&a1, a2);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return MEMORY[0x1E0C85388](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3, a4, *(_QWORD *)&a5);
}

int shm_open(const char *a1, int a2, ...)
{
  return MEMORY[0x1E0C853A8](a1, *(_QWORD *)&a2);
}

int shutdown(int a1, int a2)
{
  return MEMORY[0x1E0C853C0](*(_QWORD *)&a1, *(_QWORD *)&a2);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return (void (__cdecl *)(int))MEMORY[0x1E0C853F0](*(_QWORD *)&a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x1E0C85438](*(_QWORD *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int snprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, ...)
{
  return MEMORY[0x1E0C85448](a1, a2, a3, a4);
}

int socket(int a1, int a2, int a3)
{
  return MEMORY[0x1E0C85450](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int socketpair(int a1, int a2, int a3, int *a4)
{
  return MEMORY[0x1E0C85458](*(_QWORD *)&a1, *(_QWORD *)&a2, *(_QWORD *)&a3, a4);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1E0C854D8](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x1E0C854E0](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C85518](__s, *(_QWORD *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1E0C85540](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1E0C85548](*(_QWORD *)&__errnum);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85568](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1E0C85570](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return MEMORY[0x1E0C85590](a1, a2, a3);
}

int strncasecmp_l(const char *a1, const char *a2, size_t a3, locale_t a4)
{
  return MEMORY[0x1E0C85598](a1, a2, a3, a4);
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return (char *)MEMORY[0x1E0C855A0](__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1E0C855B0](__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1E0C855C0](__s1, __n);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return (char *)MEMORY[0x1E0C855C8](__big, __little, __len);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x1E0C855E8](__s, *(_QWORD *)&__c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x1E0C85610](__s1, __s2);
}

double strtod_l(const char *a1, char **a2, locale_t a3)
{
  double result;

  MEMORY[0x1E0C85620](a1, a2, a3);
  return result;
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85658](__str, __endptr, *(_QWORD *)&__base);
}

uint64_t strtol_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x1E0C85660](a1, a2, *(_QWORD *)&a3, a4);
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1E0C85678](__str, __endptr, *(_QWORD *)&__base);
}

uint64_t strtoll_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x1E0C85680](a1, a2, *(_QWORD *)&a3, a4);
}

unint64_t strtoul_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return MEMORY[0x1E0C856A0](a1, a2, *(_QWORD *)&a3, a4);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1E0C85798](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x1E0C857A0](a1, a2, a3, a4, a5);
}

sysdir_search_path_enumeration_state sysdir_get_next_search_path_enumeration(sysdir_search_path_enumeration_state state, char *path)
{
  return MEMORY[0x1E0C857B8](*(_QWORD *)&state, path);
}

uint64_t sysdir_start_search_path_enumeration_private()
{
  return MEMORY[0x1E0C857C8]();
}

kern_return_t task_get_special_port(task_inspect_t task, int which_port, mach_port_t *special_port)
{
  return MEMORY[0x1E0C85828](*(_QWORD *)&task, *(_QWORD *)&which_port, special_port);
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return MEMORY[0x1E0C85838](*(_QWORD *)&target_task, *(_QWORD *)&flavor, task_info_out, task_info_outCnt);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1E0C85950](a1);
}

const char *__cdecl u_errorName(UErrorCode code)
{
  return (const char *)MEMORY[0x1E0DE5988](*(_QWORD *)&code);
}

int32_t u_getIntPropertyValue(UChar32 c, UProperty which)
{
  return MEMORY[0x1E0DE59C0](*(_QWORD *)&c, *(_QWORD *)&which);
}

UBool u_hasBinaryProperty(UChar32 c, UProperty which)
{
  return MEMORY[0x1E0DE59E0](*(_QWORD *)&c, *(_QWORD *)&which);
}

UBool u_isdigit(UChar32 c)
{
  return MEMORY[0x1E0DE5A30](*(_QWORD *)&c);
}

int32_t u_strlen(const UChar *s)
{
  return MEMORY[0x1E0DE5AF8](s);
}

uint64_t uadatpg_remapPatternWithOptions()
{
  return MEMORY[0x1E0DE5B50]();
}

uint64_t ualoc_localizationsToUse()
{
  return MEMORY[0x1E0DE5B78]();
}

uint64_t ubidi_close()
{
  return MEMORY[0x1E0DE5BD8]();
}

uint64_t ubidi_getLevels()
{
  return MEMORY[0x1E0DE5BF8]();
}

uint64_t ubidi_getParaLevel()
{
  return MEMORY[0x1E0DE5C10]();
}

uint64_t ubidi_open()
{
  return MEMORY[0x1E0DE5C38]();
}

uint64_t ubidi_setContext()
{
  return MEMORY[0x1E0DE5C50]();
}

uint64_t ubidi_setParaWithControls()
{
  return MEMORY[0x1E0DE5C68]();
}

uint64_t ubrk_close()
{
  return MEMORY[0x1E0DE5C98]();
}

uint64_t ubrk_last()
{
  return MEMORY[0x1E0DE5CD8]();
}

uint64_t ubrk_open()
{
  return MEMORY[0x1E0DE5CE8]();
}

uint64_t ubrk_preceding()
{
  return MEMORY[0x1E0DE5CF0]();
}

uint64_t ubrk_setText()
{
  return MEMORY[0x1E0DE5D08]();
}

uint64_t ucal_add()
{
  return MEMORY[0x1E0DE5D18]();
}

uint64_t ucal_clear()
{
  return MEMORY[0x1E0DE5D20]();
}

uint64_t ucal_clone()
{
  return MEMORY[0x1E0DE5D28]();
}

uint64_t ucal_close()
{
  return MEMORY[0x1E0DE5D30]();
}

uint64_t ucal_get()
{
  return MEMORY[0x1E0DE5D38]();
}

uint64_t ucal_getAttribute()
{
  return MEMORY[0x1E0DE5D40]();
}

uint64_t ucal_getDayOfWeekType()
{
  return MEMORY[0x1E0DE5D58]();
}

uint64_t ucal_getFieldDifference()
{
  return MEMORY[0x1E0DE5D60]();
}

uint64_t ucal_getGregorianChange()
{
  return MEMORY[0x1E0DE5D68]();
}

uint64_t ucal_getLimit()
{
  return MEMORY[0x1E0DE5D80]();
}

uint64_t ucal_getMillis()
{
  return MEMORY[0x1E0DE5D88]();
}

uint64_t ucal_getNow()
{
  return MEMORY[0x1E0DE5D90]();
}

uint64_t ucal_getWeekendTransition()
{
  return MEMORY[0x1E0DE5DC0]();
}

uint64_t ucal_isWeekend()
{
  return MEMORY[0x1E0DE5DD0]();
}

uint64_t ucal_open()
{
  return MEMORY[0x1E0DE5DD8]();
}

uint64_t ucal_roll()
{
  return MEMORY[0x1E0DE5DF0]();
}

uint64_t ucal_set()
{
  return MEMORY[0x1E0DE5DF8]();
}

uint64_t ucal_setAttribute()
{
  return MEMORY[0x1E0DE5E00]();
}

uint64_t ucal_setGregorianChange()
{
  return MEMORY[0x1E0DE5E18]();
}

uint64_t ucal_setMillis()
{
  return MEMORY[0x1E0DE5E20]();
}

uint64_t ucal_setTimeZone()
{
  return MEMORY[0x1E0DE5E28]();
}

uint64_t ucnv_close()
{
  return MEMORY[0x1E0DE5E98]();
}

uint64_t ucnv_countAliases()
{
  return MEMORY[0x1E0DE5EB0]();
}

uint64_t ucnv_countAvailable()
{
  return MEMORY[0x1E0DE5EB8]();
}

uint64_t ucnv_fromUnicode()
{
  return MEMORY[0x1E0DE5EC8]();
}

uint64_t ucnv_getAlias()
{
  return MEMORY[0x1E0DE5ED0]();
}

uint64_t ucnv_getAvailableName()
{
  return MEMORY[0x1E0DE5EE0]();
}

uint64_t ucnv_getInvalidChars()
{
  return MEMORY[0x1E0DE5EF0]();
}

uint64_t ucnv_getInvalidUChars()
{
  return MEMORY[0x1E0DE5EF8]();
}

uint64_t ucnv_getStandardName()
{
  return MEMORY[0x1E0DE5F18]();
}

uint64_t ucnv_open()
{
  return MEMORY[0x1E0DE5F20]();
}

uint64_t ucnv_resetFromUnicode()
{
  return MEMORY[0x1E0DE5F30]();
}

uint64_t ucnv_setFromUCallBack()
{
  return MEMORY[0x1E0DE5F48]();
}

uint64_t ucnv_setSubstChars()
{
  return MEMORY[0x1E0DE5F50]();
}

uint64_t ucnv_setToUCallBack()
{
  return MEMORY[0x1E0DE5F58]();
}

uint64_t ucnv_toUnicode()
{
  return MEMORY[0x1E0DE5F68]();
}

uint64_t ucol_close()
{
  return MEMORY[0x1E0DE5F70]();
}

uint64_t ucol_closeElements()
{
  return MEMORY[0x1E0DE5F78]();
}

uint64_t ucol_getOffset()
{
  return MEMORY[0x1E0DE5FB8]();
}

uint64_t ucol_next()
{
  return MEMORY[0x1E0DE5FF8]();
}

uint64_t ucol_open()
{
  return MEMORY[0x1E0DE6008]();
}

uint64_t ucol_openElements()
{
  return MEMORY[0x1E0DE6018]();
}

uint64_t ucol_setAttribute()
{
  return MEMORY[0x1E0DE6030]();
}

uint64_t ucol_setStrength()
{
  return MEMORY[0x1E0DE6038]();
}

uint64_t ucol_strcoll()
{
  return MEMORY[0x1E0DE6040]();
}

uint64_t ucurr_getDefaultFractionDigits()
{
  return MEMORY[0x1E0DE60A8]();
}

uint64_t ucurr_getRoundingIncrement()
{
  return MEMORY[0x1E0DE60C8]();
}

uint64_t udat_applyPattern()
{
  return MEMORY[0x1E0DE60E0]();
}

uint64_t udat_applyPatternRelative()
{
  return MEMORY[0x1E0DE60E8]();
}

uint64_t udat_clone()
{
  return MEMORY[0x1E0DE60F0]();
}

uint64_t udat_close()
{
  return MEMORY[0x1E0DE60F8]();
}

uint64_t udat_countSymbols()
{
  return MEMORY[0x1E0DE6100]();
}

uint64_t udat_format()
{
  return MEMORY[0x1E0DE6108]();
}

uint64_t udat_formatForFields()
{
  return MEMORY[0x1E0DE6110]();
}

uint64_t udat_get2DigitYearStart()
{
  return MEMORY[0x1E0DE6118]();
}

uint64_t udat_getCalendar()
{
  return MEMORY[0x1E0DE6120]();
}

uint64_t udat_getContext()
{
  return MEMORY[0x1E0DE6128]();
}

uint64_t udat_getSymbols()
{
  return MEMORY[0x1E0DE6130]();
}

uint64_t udat_isLenient()
{
  return MEMORY[0x1E0DE6138]();
}

uint64_t udat_open()
{
  return MEMORY[0x1E0DE6140]();
}

uint64_t udat_parseCalendar()
{
  return MEMORY[0x1E0DE6148]();
}

uint64_t udat_patternCharToDateFormatField()
{
  return MEMORY[0x1E0DE6150]();
}

uint64_t udat_set2DigitYearStart()
{
  return MEMORY[0x1E0DE6158]();
}

uint64_t udat_setCalendar()
{
  return MEMORY[0x1E0DE6168]();
}

uint64_t udat_setContext()
{
  return MEMORY[0x1E0DE6170]();
}

uint64_t udat_setLenient()
{
  return MEMORY[0x1E0DE6178]();
}

uint64_t udat_setSymbols()
{
  return MEMORY[0x1E0DE6180]();
}

uint64_t udat_toCalendarDateField()
{
  return MEMORY[0x1E0DE6188]();
}

uint64_t udat_toPattern()
{
  return MEMORY[0x1E0DE6190]();
}

uint64_t udat_toPatternRelativeDate()
{
  return MEMORY[0x1E0DE6198]();
}

uint64_t udat_toPatternRelativeTime()
{
  return MEMORY[0x1E0DE61A0]();
}

uint64_t udatpg_close()
{
  return MEMORY[0x1E0DE61B0]();
}

uint64_t udatpg_getBestPattern()
{
  return MEMORY[0x1E0DE61C0]();
}

uint64_t udatpg_getSkeleton()
{
  return MEMORY[0x1E0DE61E0]();
}

uint64_t udatpg_open()
{
  return MEMORY[0x1E0DE61E8]();
}

uint64_t udtitvfmt_close()
{
  return MEMORY[0x1E0DE61F0]();
}

uint64_t udtitvfmt_format()
{
  return MEMORY[0x1E0DE6200]();
}

uint64_t udtitvfmt_open()
{
  return MEMORY[0x1E0DE6218]();
}

uint64_t udtitvfmt_setAttribute()
{
  return MEMORY[0x1E0DE6230]();
}

uint64_t uenum_close()
{
  return MEMORY[0x1E0DE6240]();
}

uint64_t uenum_next()
{
  return MEMORY[0x1E0DE6250]();
}

uint64_t ufieldpositer_close()
{
  return MEMORY[0x1E0DE6260]();
}

uint64_t ufieldpositer_next()
{
  return MEMORY[0x1E0DE6268]();
}

uint64_t ufieldpositer_open()
{
  return MEMORY[0x1E0DE6270]();
}

uint64_t ulistfmt_close()
{
  return MEMORY[0x1E0DE6348]();
}

uint64_t ulistfmt_format()
{
  return MEMORY[0x1E0DE6358]();
}

uint64_t ulistfmt_open()
{
  return MEMORY[0x1E0DE6368]();
}

uint64_t uloc_canonicalize()
{
  return MEMORY[0x1E0DE6390]();
}

uint64_t uloc_getCountry()
{
  return MEMORY[0x1E0DE63C0]();
}

uint64_t uloc_getKeywordValue()
{
  return MEMORY[0x1E0DE6420]();
}

uint64_t uloc_getLanguage()
{
  return MEMORY[0x1E0DE6430]();
}

uint64_t uloc_getScript()
{
  return MEMORY[0x1E0DE6448]();
}

uint64_t uloc_getVariant()
{
  return MEMORY[0x1E0DE6450]();
}

uint64_t uloc_openKeywords()
{
  return MEMORY[0x1E0DE6460]();
}

uint64_t uloc_setKeywordValue()
{
  return MEMORY[0x1E0DE6468]();
}

int unlink(const char *a1)
{
  return MEMORY[0x1E0C859B8](a1);
}

int unlinkat(int a1, const char *a2, int a3)
{
  return MEMORY[0x1E0C859C0](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

uint64_t unum_applyPattern()
{
  return MEMORY[0x1E0DE6520]();
}

uint64_t unum_close()
{
  return MEMORY[0x1E0DE6530]();
}

uint64_t unum_formatDecimal()
{
  return MEMORY[0x1E0DE6540]();
}

uint64_t unum_formatDouble()
{
  return MEMORY[0x1E0DE6548]();
}

uint64_t unum_getAttribute()
{
  return MEMORY[0x1E0DE6568]();
}

uint64_t unum_getContext()
{
  return MEMORY[0x1E0DE6578]();
}

uint64_t unum_getDoubleAttribute()
{
  return MEMORY[0x1E0DE6580]();
}

uint64_t unum_getSymbol()
{
  return MEMORY[0x1E0DE6588]();
}

uint64_t unum_getTextAttribute()
{
  return MEMORY[0x1E0DE6590]();
}

uint64_t unum_open()
{
  return MEMORY[0x1E0DE6598]();
}

uint64_t unum_parse()
{
  return MEMORY[0x1E0DE65A0]();
}

uint64_t unum_parseDecimal()
{
  return MEMORY[0x1E0DE65A8]();
}

uint64_t unum_setAttribute()
{
  return MEMORY[0x1E0DE65C8]();
}

uint64_t unum_setContext()
{
  return MEMORY[0x1E0DE65D0]();
}

uint64_t unum_setDoubleAttribute()
{
  return MEMORY[0x1E0DE65D8]();
}

uint64_t unum_setSymbol()
{
  return MEMORY[0x1E0DE65E0]();
}

uint64_t unum_setTextAttribute()
{
  return MEMORY[0x1E0DE65E8]();
}

uint64_t unum_toPattern()
{
  return MEMORY[0x1E0DE65F0]();
}

uint64_t uplrules_close()
{
  return MEMORY[0x1E0DE66B8]();
}

uint64_t uplrules_open()
{
  return MEMORY[0x1E0DE66C8]();
}

uint64_t uplrules_select()
{
  return MEMORY[0x1E0DE66D8]();
}

uint64_t ureldatefmt_close()
{
  return MEMORY[0x1E0DE6818]();
}

uint64_t ureldatefmt_format()
{
  return MEMORY[0x1E0DE6820]();
}

uint64_t ureldatefmt_formatNumeric()
{
  return MEMORY[0x1E0DE6828]();
}

uint64_t ureldatefmt_open()
{
  return MEMORY[0x1E0DE6830]();
}

uint64_t uscript_getScript()
{
  return MEMORY[0x1E0DE6898]();
}

uint64_t usearch_close()
{
  return MEMORY[0x1E0DE68C8]();
}

uint64_t usearch_first()
{
  return MEMORY[0x1E0DE68D0]();
}

uint64_t usearch_getMatchedLength()
{
  return MEMORY[0x1E0DE68E0]();
}

uint64_t usearch_last()
{
  return MEMORY[0x1E0DE68E8]();
}

uint64_t usearch_openFromCollator()
{
  return MEMORY[0x1E0DE6900]();
}

uint64_t uset_close()
{
  return MEMORY[0x1E0DE6988]();
}

uint64_t uset_getItem()
{
  return MEMORY[0x1E0DE69B0]();
}

uint64_t uset_getItemCount()
{
  return MEMORY[0x1E0DE69B8]();
}

uint64_t uset_openPattern()
{
  return MEMORY[0x1E0DE69E0]();
}

UText *__cdecl utext_setup(UText *ut, int32_t extraSpace, UErrorCode *status)
{
  return (UText *)MEMORY[0x1E0DE6AB0](ut, *(_QWORD *)&extraSpace, status);
}

uint64_t utrans_close()
{
  return MEMORY[0x1E0DE6AC8]();
}

uint64_t utrans_openU()
{
  return MEMORY[0x1E0DE6AD0]();
}

uint64_t utrans_trans()
{
  return MEMORY[0x1E0DE6AD8]();
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x1E0C85A08](uu1, uu2);
}

void uuid_generate_random(uuid_t out)
{
  MEMORY[0x1E0C85A20](out);
}

void uuid_generate_time(uuid_t out)
{
  MEMORY[0x1E0C85A28](out);
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return MEMORY[0x1E0C85A38](in, uu);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x1E0C85A80](*(_QWORD *)&target_task, address, size, *(_QWORD *)&flags);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x1E0C85A98](*(_QWORD *)&target_task, address, size);
}

kern_return_t vm_purgable_control(vm_map_t target_task, vm_address_t address, vm_purgable_t control, int *state)
{
  return MEMORY[0x1E0C85AE8](*(_QWORD *)&target_task, address, *(_QWORD *)&control, state);
}

uint64_t voucher_copy()
{
  return MEMORY[0x1E0C85B18]();
}

uint64_t voucher_get_current_persona()
{
  return MEMORY[0x1E0C85B30]();
}

voucher_mach_msg_state_t voucher_mach_msg_adopt(mach_msg_header_t *msg)
{
  return (voucher_mach_msg_state_t)MEMORY[0x1E0C85B48](msg);
}

void voucher_mach_msg_revert(voucher_mach_msg_state_t state)
{
  MEMORY[0x1E0C85B58](state);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1E0C85B98](__str, __size, __format, a4);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1E0C85D40](*(_QWORD *)&__fd, __buf, __nbyte);
}

ssize_t writev(int a1, const iovec *a2, int a3)
{
  return MEMORY[0x1E0C85D48](*(_QWORD *)&a1, a2, *(_QWORD *)&a3);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
  MEMORY[0x1E0C85DE0](xarray, value);
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return MEMORY[0x1E0C85DF8](xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C85E00](objects, count);
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return MEMORY[0x1E0C85E30](xarray);
}

const char *__cdecl xpc_array_get_string(xpc_object_t xarray, size_t index)
{
  return (const char *)MEMORY[0x1E0C85E70](xarray, index);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return (xpc_object_t)MEMORY[0x1E0C85E90](xarray, index);
}

void xpc_array_set_uint64(xpc_object_t xarray, size_t index, uint64_t value)
{
  MEMORY[0x1E0C85ED8](xarray, index, value);
}

void xpc_array_set_value(xpc_object_t xarray, size_t index, xpc_object_t value)
{
  MEMORY[0x1E0C85EE8](xarray, index, value);
}

xpc_object_t xpc_BOOL_create(BOOL value)
{
  return (xpc_object_t)MEMORY[0x1E0C85EF0](value);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return MEMORY[0x1E0C85F00](xBOOL);
}

void xpc_connection_activate(xpc_connection_t connection)
{
  MEMORY[0x1E0C85F50](connection);
}

void xpc_connection_cancel(xpc_connection_t connection)
{
  MEMORY[0x1E0C85F68](connection);
}

uint64_t xpc_connection_copy_bundle_id()
{
  return MEMORY[0x1E0C85F70]();
}

xpc_connection_t xpc_connection_create(const char *name, dispatch_queue_t targetq)
{
  return (xpc_connection_t)MEMORY[0x1E0C85F90](name, targetq);
}

xpc_connection_t xpc_connection_create_from_endpoint(xpc_endpoint_t endpoint)
{
  return (xpc_connection_t)MEMORY[0x1E0C85FA0](endpoint);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x1E0C85FB0](name, targetq, flags);
}

uint64_t xpc_connection_get_audit_token()
{
  return MEMORY[0x1E0C85FD0]();
}

void *__cdecl xpc_connection_get_context(xpc_connection_t connection)
{
  return (void *)MEMORY[0x1E0C85FE0](connection);
}

gid_t xpc_connection_get_egid(xpc_connection_t connection)
{
  return MEMORY[0x1E0C85FE8](connection);
}

uid_t xpc_connection_get_euid(xpc_connection_t connection)
{
  return MEMORY[0x1E0C85FF0](connection);
}

pid_t xpc_connection_get_pid(xpc_connection_t connection)
{
  return MEMORY[0x1E0C86008](connection);
}

void xpc_connection_send_barrier(xpc_connection_t connection, dispatch_block_t barrier)
{
  MEMORY[0x1E0C86020](connection, barrier);
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
  MEMORY[0x1E0C86030](connection, message);
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
  MEMORY[0x1E0C86038](connection, message, replyq, handler);
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x1E0C86048](connection, message);
}

void xpc_connection_set_context(xpc_connection_t connection, void *context)
{
  MEMORY[0x1E0C86070](connection, context);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
  MEMORY[0x1E0C86080](connection, handler);
}

void xpc_connection_set_finalizer_f(xpc_connection_t connection, xpc_finalizer_t finalizer)
{
  MEMORY[0x1E0C86088](connection, finalizer);
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
  MEMORY[0x1E0C860C8](connection, targetq);
}

uint64_t xpc_connection_set_target_user_session_uid()
{
  return MEMORY[0x1E0C860D8]();
}

xpc_object_t xpc_copy(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1E0C860E8](object);
}

uint64_t xpc_copy_bootstrap()
{
  return MEMORY[0x1E0C860F0]();
}

char *__cdecl xpc_copy_description(xpc_object_t object)
{
  return (char *)MEMORY[0x1E0C86108](object);
}

uint64_t xpc_copy_entitlement_for_self()
{
  return MEMORY[0x1E0C86118]();
}

uint64_t xpc_copy_entitlement_for_token()
{
  return MEMORY[0x1E0C86120]();
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return (xpc_object_t)MEMORY[0x1E0C86178](bytes, length);
}

xpc_object_t xpc_data_create_with_dispatch_data(dispatch_data_t ddata)
{
  return (xpc_object_t)MEMORY[0x1E0C86188](ddata);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return (const void *)MEMORY[0x1E0C86198](xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return MEMORY[0x1E0C861A8](xdata);
}

xpc_object_t xpc_date_create(int64_t interval)
{
  return (xpc_object_t)MEMORY[0x1E0C861B8](interval);
}

int64_t xpc_date_get_value(xpc_object_t xdate)
{
  return MEMORY[0x1E0C861D0](xdate);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return MEMORY[0x1E0C861F0](xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1E0C86208](keys, values, count);
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return (xpc_object_t)MEMORY[0x1E0C86228](original);
}

int xpc_dictionary_dup_fd(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C86230](xdict, key);
}

xpc_object_t xpc_dictionary_get_array(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C86248](xdict, key);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C86260](xdict, key);
}

size_t xpc_dictionary_get_count(xpc_object_t xdict)
{
  return MEMORY[0x1E0C86270](xdict);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return (const void *)MEMORY[0x1E0C86278](xdict, key, length);
}

double xpc_dictionary_get_double(xpc_object_t xdict, const char *key)
{
  double result;

  MEMORY[0x1E0C86298](xdict, key);
  return result;
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862A0](xdict, key);
}

xpc_connection_t xpc_dictionary_get_remote_connection(xpc_object_t xdict)
{
  return (xpc_connection_t)MEMORY[0x1E0C862B0](xdict);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1E0C862C8](xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1E0C862D0](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1E0C862E0](xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
  MEMORY[0x1E0C86310](xdict, key, value);
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
  MEMORY[0x1E0C86330](xdict, key, bytes, length);
}

void xpc_dictionary_set_fd(xpc_object_t xdict, const char *key, int fd)
{
  MEMORY[0x1E0C86358](xdict, key, *(_QWORD *)&fd);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
  MEMORY[0x1E0C86360](xdict, key, value);
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
  MEMORY[0x1E0C86390](xdict, key, string);
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
  MEMORY[0x1E0C86398](xdict, key, value);
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
  MEMORY[0x1E0C863B8](xdict, key, value);
}

xpc_object_t xpc_double_create(double value)
{
  return (xpc_object_t)MEMORY[0x1E0C863D0](value);
}

double xpc_double_get_value(xpc_object_t xdouble)
{
  double result;

  MEMORY[0x1E0C863E0](xdouble);
  return result;
}

xpc_endpoint_t xpc_endpoint_create(xpc_connection_t connection)
{
  return (xpc_endpoint_t)MEMORY[0x1E0C863F0](connection);
}

BOOL xpc_equal(xpc_object_t object1, xpc_object_t object2)
{
  return MEMORY[0x1E0C86420](object1, object2);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1E0C86520](object);
}

xpc_object_t xpc_int64_create(int64_t value)
{
  return (xpc_object_t)MEMORY[0x1E0C86568](value);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return MEMORY[0x1E0C86570](xint);
}

xpc_object_t xpc_null_create(void)
{
  return (xpc_object_t)MEMORY[0x1E0C86628]();
}

void xpc_release(xpc_object_t object)
{
  MEMORY[0x1E0C86658](object);
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x1E0C86660](object);
}

xpc_object_t xpc_string_create(const char *string)
{
  return (xpc_object_t)MEMORY[0x1E0C86720](string);
}

size_t xpc_string_get_length(xpc_object_t xstring)
{
  return MEMORY[0x1E0C86748](xstring);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return (const char *)MEMORY[0x1E0C86758](xstring);
}

uint64_t xpc_user_sessions_enabled()
{
  return MEMORY[0x1E0C867C8]();
}

uint64_t xpc_user_sessions_get_foreground_uid()
{
  return MEMORY[0x1E0C867D0]();
}

uint64_t xpc_user_sessions_get_session_uid()
{
  return MEMORY[0x1E0C867D8]();
}

xpc_object_t xpc_uuid_create(const unsigned __int8 *uuid)
{
  return (xpc_object_t)MEMORY[0x1E0C867E0](uuid);
}

const uint8_t *__cdecl xpc_uuid_get_bytes(xpc_object_t xuuid)
{
  return (const uint8_t *)MEMORY[0x1E0C867F8](xuuid);
}

