uint64_t SecCertificateGetLength(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

unint64_t SecDERItemHash(uint64_t *a1)
{
  unint64_t result;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  result = a1[1];
  v3 = result - 8;
  if (result < 8)
    v3 = 0;
  if (v3 < result)
  {
    v4 = *a1;
    v5 = 8;
    if (result < 8)
      v5 = result;
    v6 = -v5;
    v7 = v4 + result;
    do
      result = (result << 9) + (result >> 23) + *(unsigned __int8 *)(v7 + v6);
    while (!__CFADD__(v6++, 1));
  }
  return result;
}

uint64_t SecPolicyGetName(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

double SecCertificateNotValidBefore(uint64_t a1)
{
  return *(double *)(a1 + 168);
}

void SecTaskFinalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 56);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = 0;
    CFRelease(v2);
  }
}

double SecCertificateNotValidAfter(uint64_t a1)
{
  return *(double *)(a1 + 176);
}

uint64_t SecCertificateGetNormalizedIssuerContent(uint64_t a1)
{
  return *(_QWORD *)(a1 + 576);
}

BOOL SecCertificateIsWeakHash(uint64_t a1)
{
  return !a1 || SecSignatureHashAlgorithmForAlgorithmOid((_QWORD *)(a1 + 120)) < 5;
}

CFDataRef SecCertificateCopySubjectPublicKeyInfoSHA256Digest(const void *a1)
{
  CFDataRef result;
  const __CFData *v3;
  const __CFAllocator *v4;
  const UInt8 *BytePtr;
  CFIndex Length;
  __CFData *v7;

  result = SecCertificateCopySPKIEncoded((uint64_t)a1);
  if (result)
  {
    v3 = result;
    v4 = CFGetAllocator(a1);
    BytePtr = CFDataGetBytePtr(v3);
    Length = CFDataGetLength(v3);
    v7 = SecSHA256DigestCreate(v4, (uint64_t)BytePtr, Length);
    CFRelease(v3);
    return v7;
  }
  return result;
}

__CFData *SecSHA256DigestCreate(const __CFAllocator *a1, uint64_t a2, unint64_t a3)
{
  __CFData *Mutable;

  Mutable = 0;
  if (a2 && !(a3 >> 31))
  {
    Mutable = CFDataCreateMutable(a1, 32);
    CFDataSetLength(Mutable, 32);
    CFDataGetMutableBytePtr(Mutable);
    CCDigest();
  }
  return Mutable;
}

const void *SecCFAllocatorDeallocate(const void *result, uint64_t a2)
{
  const void *v3;

  if (result)
  {
    v3 = result;
    if (malloc_size(result))
      cc_clear();
    return (const void *)off_1ECD35A60(v3, a2);
  }
  return result;
}

uint64_t cfdata_compare_der_contents(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length;
  CFIndex v5;
  unint64_t v6;
  size_t v7;
  const UInt8 *BytePtr;
  const UInt8 *v9;
  int v10;
  uint64_t v12;
  uint64_t v13;

  Length = CFDataGetLength(a1);
  v5 = CFDataGetLength(a2);
  v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5)
      v12 = 0;
    else
      v12 = -1;
    if (Length <= v5)
      return v12;
    else
      return 1;
  }
  else
  {
    if (Length >= v5)
      v7 = v5;
    else
      v7 = Length;
    BytePtr = CFDataGetBytePtr(a1);
    v9 = CFDataGetBytePtr(a2);
    v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6)
        LODWORD(v13) = 0;
      if (v10 < 0)
        v13 = 1;
      else
        v13 = v13;
      return v13 << 63 >> 63;
    }
    else
    {
      return 1;
    }
  }
}

BOOL SecDERItemEqual(uint64_t a1, uint64_t a2)
{
  return DEROidCompare(a1, a2);
}

uint64_t SecSignatureHashAlgorithmForAlgorithmOid(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v4;

  if (!a1 || !*a1 || !a1[1])
    return 0;
  if (DEROidCompare((uint64_t)a1, (uint64_t)&oidEd448) || DEROidCompare((uint64_t)a1, (uint64_t)&oidSHAKE256))
    return 9;
  v2 = 8;
  if (DEROidCompare((uint64_t)a1, (uint64_t)&oidEd25519))
    v4 = 8;
  else
    v4 = 0;
  if (!DEROidCompare((uint64_t)a1, (uint64_t)&oidSha512Ecdsa)
    && !DEROidCompare((uint64_t)a1, (uint64_t)&oidSha512Rsa)
    && !DEROidCompare((uint64_t)a1, (uint64_t)&oidSha512))
  {
    if (DEROidCompare((uint64_t)a1, (uint64_t)&oidSha384Ecdsa)
      || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha384Rsa)
      || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha384))
    {
      return 7;
    }
    else if (DEROidCompare((uint64_t)a1, (uint64_t)&oidSha256Ecdsa)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha256Rsa)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha256))
    {
      return 6;
    }
    else if (DEROidCompare((uint64_t)a1, (uint64_t)&oidSha224Ecdsa)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha224Rsa)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha224))
    {
      return 5;
    }
    else if (DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1Ecdsa)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1Rsa)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1Dsa)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1DsaOIW)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1DsaCommonOIW)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1RsaOIW)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1Fee)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidSha1))
    {
      return 4;
    }
    else if (DEROidCompare((uint64_t)a1, (uint64_t)&oidMd5Rsa)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidMd5Fee)
           || DEROidCompare((uint64_t)a1, (uint64_t)&oidMd5))
    {
      return 3;
    }
    else if (DEROidCompare((uint64_t)a1, (uint64_t)&oidMd4Rsa) || DEROidCompare((uint64_t)a1, (uint64_t)&oidMd4))
    {
      return 2;
    }
    else
    {
      if (DEROidCompare((uint64_t)a1, (uint64_t)&oidMd2Rsa))
        return 1;
      v2 = v4;
      if (DEROidCompare((uint64_t)a1, (uint64_t)&oidMd2))
        return 1;
    }
  }
  return v2;
}

BOOL DEROidCompare(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  size_t v4;

  result = 0;
  if (a1 && a2)
  {
    v4 = *(_QWORD *)(a1 + 8);
    return v4 == *(_QWORD *)(a2 + 8) && memcmp(*(const void **)a1, *(const void **)a2, v4) == 0;
  }
  return result;
}

uint64_t SecCertificateParse(uint64_t a1)
{
  __CFSet *Mutable;
  const __CFAllocator *v3;
  __int128 v4;
  __int128 v5;
  unsigned int v6;
  NSObject *v7;
  int v8;
  unint64_t v9;
  NSObject *v10;
  _BOOL4 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  int v16;
  void *v17;
  uint64_t v18;
  int v19;
  __int128 v20;
  CFDataRef v21;
  uint64_t (*Value)(uint64_t, uint64_t);
  uint64_t v23;
  _BYTE *v24;
  void *v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t result;
  _QWORD v30[3];
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  char v35;
  __int128 v36;
  UInt8 *bytes[2];
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _BYTE v49[32];
  __int128 v50;
  uint8_t buf[24];
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  v3 = CFGetAllocator((CFTypeRef)a1);
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v46 = v4;
  v47 = v4;
  v48 = v4;
  if (DERParseSequence(a1 + 16, (unsigned __int16)DERNumSignedCertCrlItemSpecs, (uint64_t)&DERSignedCertCrlItemSpecs, (unint64_t)&v46, 0x30uLL))goto LABEL_85;
  *(_OWORD *)(a1 + 32) = v46;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v36 = v5;
  *(_OWORD *)bytes = v5;
  v38 = v5;
  v39 = v5;
  v40 = v5;
  v41 = v5;
  v42 = v5;
  v43 = v5;
  v44 = v5;
  v45 = v5;
  if (DERParseSequence((uint64_t)&v46, (unsigned __int16)DERNumTBSCertItemSpecs, (uint64_t)&DERTBSCertItemSpecs, (unint64_t)&v36, 0xA0uLL))goto LABEL_85;
  if (DERParseSequenceContent((unint64_t *)&v47, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, a1 + 48, 0x20uLL))goto LABEL_85;
  v35 = -86;
  if (DERParseBitString((uint64_t)&v48, (unint64_t *)(a1 + 80), &v35))
    goto LABEL_85;
  if (*((_QWORD *)&v36 + 1))
  {
    memset(v49, 170, 24);
    if (DERDecodeItem((uint64_t)&v36, (unint64_t *)v49)
      || *(_QWORD *)v49 != 2
      || *(_QWORD *)&v49[16] != 1)
    {
      goto LABEL_85;
    }
    v6 = **(_BYTE **)&v49[8];
    *(_BYTE *)(a1 + 96) = v6;
    if (v6 >= 3)
    {
      v7 = secLogObjForScope("SecWarning");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v8 = *(unsigned __int8 *)(a1 + 96);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v8;
        _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "Invalid certificate version (%d), must be 0..2", buf, 8u);
      }
      v6 = *(unsigned __int8 *)(a1 + 96);
    }
    if (v6 - 3 <= 0xFFFFFFFD)
      goto LABEL_85;
  }
  else
  {
    *(_BYTE *)(a1 + 96) = 0;
  }
  *(_OWORD *)(a1 + 104) = *(_OWORD *)bytes;
  v9 = (unint64_t)bytes[1];
  if ((unint64_t)(bytes[1] - 22) < 0xFFFFFFFFFFFFFFEBLL)
    goto LABEL_19;
  if (bytes[1] == (UInt8 *)21)
  {
    if (*bytes[0])
    {
LABEL_19:
      v10 = secLogObjForScope("SecWarning");
      v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      v9 = (unint64_t)bytes[1];
      if (v11)
      {
        *(_DWORD *)v49 = 134217984;
        *(UInt8 **)&v49[4] = bytes[1];
        _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, "Invalid serial number length (%ld), must be 1..20", v49, 0xCu);
        v9 = (unint64_t)bytes[1];
      }
      goto LABEL_22;
    }
    v9 = 21;
  }
LABEL_22:
  if (bytes[0])
  {
    if (v9)
    {
      if (v9 <= 0x25)
      {
        *(_QWORD *)(a1 + 568) = CFDataCreate(v3, bytes[0], v9);
        if (!DERParseSequenceContent((unint64_t *)&v38, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, a1 + 120, 0x20uLL))
        {
          *(_OWORD *)(a1 + 152) = v39;
          *(_QWORD *)(a1 + 576) = createNormalizedX501Name(v3, (uint64_t)&v39);
          *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v33 = v12;
          v34 = v12;
          if (!DERParseSequenceContent((unint64_t *)&v40, (unsigned __int16)DERNumValidityItemSpecs, (uint64_t)&DERValidityItemSpecs, (unint64_t)&v33, 0x20uLL)&& derDateGetAbsoluteTime((uint64_t)&v33, (double *)(a1 + 168))&& derDateGetAbsoluteTime((uint64_t)&v34, (double *)(a1 + 176)))
          {
            *(_OWORD *)(a1 + 184) = v41;
            *(_QWORD *)(a1 + 584) = createNormalizedX501Name(v3, (uint64_t)&v41);
            *(_OWORD *)(a1 + 200) = v42;
            *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v31 = v13;
            v32 = v13;
            if (!DERParseSequenceContent((unint64_t *)&v42, (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs, (uint64_t)&DERSubjPubKeyInfoItemSpecs, (unint64_t)&v31, 0x20uLL)&& !DERParseSequenceContent((unint64_t *)&v31, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, a1 + 216, 0x20uLL)&& !DERParseBitString((uint64_t)&v32, (unint64_t *)(a1 + 248), &v35))
            {
              v14 = v44;
              *(_OWORD *)(a1 + 264) = v43;
              *(_OWORD *)(a1 + 280) = v14;
              *(_QWORD *)(a1 + 528) = -1;
              *(_QWORD *)(a1 + 536) = -1;
              if (!*((_QWORD *)&v45 + 1))
              {
LABEL_82:
                v28 = 1;
                result = 1;
                if (!Mutable)
                  return result;
                goto LABEL_83;
              }
              memset(v30, 170, sizeof(v30));
              if (!DERDecodeSeqInit((uint64_t)&v45, v30, &v30[1]) && v30[0] == 0x2000000000000010)
              {
                v15 = 0;
                memset(buf, 170, sizeof(buf));
                while (1)
                {
                  v16 = DERDecodeSeqNext(&v30[1], (unint64_t *)buf);
                  if (v16)
                    break;
                  ++v15;
                }
                if (v16 == 1 && (unint64_t)(v15 - 10000) >= 0xFFFFFFFFFFFFD8F1)
                {
                  *(_QWORD *)(a1 + 512) = v15;
                  v17 = malloc_type_malloc(40 * v15, 0x1010040134DF15DuLL);
                  *(_QWORD *)(a1 + 520) = v17;
                  if (v17)
                  {
                    if (!DERDecodeSeqInit((uint64_t)&v45, v30, &v30[1]))
                    {
                      v18 = 0;
                      while (1)
                      {
                        v19 = DERDecodeSeqNext(&v30[1], (unint64_t *)buf);
                        if (v19 && (v18 != v15 - 1 || v19 != 1))
                          break;
                        if (*(_QWORD *)buf != 0x2000000000000010)
                          break;
                        *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
                        *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
                        *(_OWORD *)&v49[16] = v20;
                        v50 = v20;
                        *(_OWORD *)v49 = v20;
                        if (DERParseSequenceContent((unint64_t *)&buf[8], (unsigned __int16)DERNumExtensionItemSpecs, (uint64_t)&DERExtensionItemSpecs, (unint64_t)v49, 0x30uLL))break;
                        *(_OWORD *)(*(_QWORD *)(a1 + 520) + 40 * v18) = *(_OWORD *)v49;
                        if ((*(_QWORD *)&v49[8] & 0x8000000000000000) == 0)
                        {
                          v21 = CFDataCreate(0, *(const UInt8 **)v49, *(CFIndex *)&v49[8]);
                          if (CFSetContainsValue(Mutable, v21))
                          {
                            if (v21)
                              CFRelease(v21);
                            *(_QWORD *)(a1 + 536) = v18;
                          }
                          else
                          {
                            CFSetAddValue(Mutable, v21);
                            if (v21)
                              CFRelease(v21);
                          }
                        }
                        if (DERParseBooleanWithDefault((unsigned __int8 **)&v49[16], 0, (BOOL *)(*(_QWORD *)(a1 + 520) + 40 * v18 + 16)))break;
                        *(_OWORD *)(*(_QWORD *)(a1 + 520) + 40 * v18 + 24) = v50;
                        Value = (uint64_t (*)(uint64_t, uint64_t))CFDictionaryGetValue((CFDictionaryRef)sExtensionParsers, (const void *)(*(_QWORD *)(a1 + 520)+ 40 * v18));
                        v23 = *(_QWORD *)(a1 + 520);
                        if (Value)
                        {
                          if ((Value(a1, v23 + 40 * v18) & 1) == 0)
                          {
                            *(_QWORD *)(a1 + 528) = v18;
                            if (*(_BYTE *)(*(_QWORD *)(a1 + 520) + 40 * v18 + 16))
                              break;
                          }
                        }
                        else if (*(_BYTE *)(v23 + 40 * v18 + 16))
                        {
                          v24 = *(_BYTE **)v49;
                          if (!*(_QWORD *)v49)
                            goto LABEL_73;
                          v25 = *(void **)&v49[8];
                          if (*(_QWORD *)&v49[8] < 9uLL)
                          {
                            if (*(_QWORD *)&v49[8])
                              goto LABEL_64;
LABEL_73:
                            *(_BYTE *)(a1 + 296) = 1;
                            goto LABEL_74;
                          }
                          if (**(_QWORD **)v49 != 0x66463F78648862ALL
                            && **(_QWORD **)v49 != 0xB6463F78648862ALL
                            && **(_QWORD **)v49 != 0xC6463F78648862ALL
                            && **(_QWORD **)v49 != 0xD6463F78648862ALL
                            && **(_QWORD **)v49 != 0xF6463F78648862ALL)
                          {
LABEL_64:
                            v26 = 0;
                            while (v25 != *(_UNKNOWN **)((char *)&unparsed_known_extensions + v26 + 8)
                                 || memcmp(v24, *(_UNKNOWN **)((char *)&unparsed_known_extensions + v26), (size_t)v25))
                            {
                              v26 += 16;
                              if (v26 == 48)
                              {
                                if ((unint64_t)v25 >= 0xA
                                  && *(_QWORD *)v24 == 0x69C482010401062BLL
                                  && v24[8] == 5)
                                {
                                  break;
                                }
                                goto LABEL_73;
                              }
                            }
                          }
                        }
LABEL_74:
                        if (++v18 == v15)
                          goto LABEL_82;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_85:
  v28 = 0;
  result = 0;
  if (!Mutable)
    return result;
LABEL_83:
  CFRelease(Mutable);
  return v28;
}

unint64_t *DERParseSequenceContent(unint64_t *result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4)
    return (unint64_t *)DERParseSequenceContentToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  __break(0x5519u);
  return result;
}

uint64_t DERParseBooleanWithDefault(unsigned __int8 **a1, BOOL a2, BOOL *a3)
{
  unsigned __int8 *v3;
  int v4;
  uint64_t result;

  v3 = a1[1];
  if (!v3)
    goto LABEL_9;
  if (v3 == (unsigned __int8 *)1)
  {
    v4 = **a1;
    if (v4 == 255 || v4 == 0)
    {
      a2 = v4 != 0;
LABEL_9:
      result = 0;
      *a3 = a2;
      return result;
    }
  }
  return 3;
}

uint64_t DERDecodeSeqInit(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8[4];

  v8[3] = *MEMORY[0x1E0C80C00];
  memset(v8, 170, 24);
  result = DERDecodeItemPartialBufferGetLength(a1, v8, 0);
  if (!(_DWORD)result)
  {
    v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }
      else
      {
        v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          result = 0;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }
      __break(0x5519u);
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t DERParseSequenceToObject(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  uint64_t result;
  unint64_t v12[4];

  v12[3] = *MEMORY[0x1E0C80C00];
  memset(v12, 170, 24);
  result = DERDecodeItemPartialBufferGetLength(a1, v12, 0);
  if (!(_DWORD)result)
  {
    if (v12[0] == 0x2000000000000010)
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    else
      return 2;
  }
  return result;
}

uint64_t DERParseSequence(uint64_t result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4)
    return DERParseSequenceToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  __break(0x5519u);
  return result;
}

uint64_t DERParseBitString(uint64_t result, unint64_t *a2, _BYTE *a3)
{
  unsigned int v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned __int8 *v8;
  unint64_t v10;

  *a3 = 0;
  *a2 = 0;
  a2[1] = 0;
  if (!*(_QWORD *)(result + 8))
    return 3;
  v3 = **(unsigned __int8 **)result;
  *a3 = v3;
  v4 = *(_QWORD *)(result + 8);
  if (v4 != 1)
  {
    if (v3 <= 7)
    {
      v5 = v4 - 1;
      if (!v4)
      {
LABEL_20:
        __break(0x5515u);
        goto LABEL_21;
      }
      v6 = *(_QWORD *)result;
      v7 = *(_QWORD *)result + v4;
      v8 = (unsigned __int8 *)(*(_QWORD *)result + v5);
      if ((unint64_t)v8 >= v7 || (unint64_t)v8 < v6)
      {
LABEL_19:
        __break(0x5519u);
        goto LABEL_20;
      }
      if (((0xFFu >> (8 - v3)) & *v8) == 0)
      {
        if (v6 == -1)
        {
LABEL_21:
          __break(0x5513u);
          return result;
        }
        v10 = v6 + 1;
        if (v6 + 1 <= v7 && v6 <= v10)
        {
          result = 0;
          *a2 = v10;
          a2[1] = v5;
          return result;
        }
        goto LABEL_19;
      }
    }
    return 3;
  }
  if (v3)
    return 3;
  else
    return 0;
}

__CFData *createNormalizedX501Name(const __CFAllocator *a1, uint64_t a2)
{
  CFIndex v2;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  unint64_t v6;
  unint64_t *v7;
  const void *i;
  int v9;
  unint64_t v10;
  unint64_t v11;
  UInt8 *v12;
  const void *v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  UInt8 *v17;
  __int128 v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  BOOL v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  char v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  UInt8 *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  size_t v39;
  unint64_t v40;
  __CFData *v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  UInt8 *v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56[3];
  __int128 v57;
  __int128 v58;
  unint64_t v59[3];
  unint64_t v60[2];
  unint64_t v61[3];
  unint64_t v62[3];

  v2 = *(_QWORD *)(a2 + 8);
  if (v2 < 0)
    return 0;
  Mutable = CFDataCreateMutable(a1, *(_QWORD *)(a2 + 8));
  CFDataSetLength(Mutable, v2);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  v62[0] = 0xAAAAAAAAAAAAAAAALL;
  v62[1] = 0xAAAAAAAAAAAAAAAALL;
  if (DERDecodeSeqContentInit((unint64_t *)a2, v62))
    goto LABEL_55;
  v6 = 0;
  v7 = &v61[1];
  memset(v61, 170, sizeof(v61));
  for (i = (const void *)v62[0]; ; i = (const void *)v62[0])
  {
    v9 = DERDecodeSeqNext(v62, v61);
    if (v9)
      break;
    if (v61[0] != 0x2000000000000011)
      goto LABEL_55;
    v10 = v61[2];
    if (!v61[2])
      goto LABEL_55;
    v11 = v61[1] - (_QWORD)i;
    if (v61[1] <= (unint64_t)i)
      goto LABEL_55;
    v12 = &MutableBytePtr[v6];
    memcpy(&MutableBytePtr[v6], i, v61[1] - (_QWORD)i);
    v60[0] = 0xAAAAAAAAAAAAAAAALL;
    v60[1] = 0xAAAAAAAAAAAAAAAALL;
    if (DERDecodeSeqContentInit(v7, v60))
      goto LABEL_55;
    v50 = v11;
    v51 = v10;
    memset(v59, 170, sizeof(v59));
    v52 = v11 + v6;
    v48 = (unint64_t)(v12 + 1);
    while (1)
    {
      v13 = (const void *)v60[0];
      v14 = DERDecodeSeqNext(v60, v59);
      if (v14)
        break;
      if (v59[0] != 0x2000000000000010)
        goto LABEL_55;
      v15 = v59[1] - (_QWORD)v13;
      if (v59[1] <= (unint64_t)v13)
        goto LABEL_55;
      v16 = v59[2];
      v17 = &MutableBytePtr[v52];
      memcpy(&MutableBytePtr[v52], v13, v59[2] + v15);
      *(_QWORD *)&v18 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v57 = v18;
      v58 = v18;
      if (DERParseSequenceContent(&v59[1], (unsigned __int16)DERNumAttributeTypeAndValueItemSpecs, (uint64_t)&DERAttributeTypeAndValueItemSpecs, (unint64_t)&v57, 0x20uLL))goto LABEL_55;
      if (!*((_QWORD *)&v57 + 1))
        goto LABEL_55;
      memset(v56, 170, sizeof(v56));
      if (DERDecodeItem((uint64_t)&v58, v56))
        goto LABEL_55;
      if (v56[0] == 19)
      {
        v46 = v58 + v52 - (_QWORD)v13;
        if ((unint64_t)v58 + v52 <= (unint64_t)v13)
          goto LABEL_55;
        v19 = v56[1] - v58;
        if (v56[1] <= (unint64_t)v58)
          goto LABEL_55;
        v49 = v12;
        v44 = v6;
        v45 = v7;
        v20 = v56[2];
        v43 = v56[1] - v58;
        v21 = v19 + v46;
        if (v56[2])
        {
          v42 = Mutable;
          v22 = 0;
          v23 = 0;
          v24 = v19 + v46;
          while (1)
          {
            v25 = *(unsigned __int8 *)(v56[1] + v22);
            v26 = *(char *)(v56[1] + v22) < 0
                ? __maskrune(*(unsigned __int8 *)(v56[1] + v22), 0x20000uLL)
                : *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v25 + 60) & 0x20000;
            LODWORD(v27) = v26 != 0;
            if (!v26)
              break;
            if (!v23 && v24 > v21)
            {
              v28 = 32;
LABEL_30:
              MutableBytePtr[v24++] = v28;
            }
            ++v22;
            v23 = v26 != 0;
            if (v20 == v22)
            {
              v29 = v56[2];
              Mutable = v42;
              goto LABEL_34;
            }
          }
          if ((v25 - 97) >= 0x1Au)
            v28 = v25;
          else
            v28 = v25 - 32;
          goto LABEL_30;
        }
        v29 = 0;
        LODWORD(v27) = 0;
        v24 = v21;
LABEL_34:
        v30 = v24 - v21;
        if (v24 > v21)
          v27 = v27;
        else
          v27 = 0;
        v31 = v30 - v27;
        v32 = v29 - (v30 - v27);
        v12 = v49;
        if (v29 == v30 - v27)
        {
          v6 = v44;
          v7 = v45;
        }
        else
        {
          v55 = v43 - 1;
          v33 = &MutableBytePtr[v46];
          if (DEREncodeLength(v31, (unint64_t)&MutableBytePtr[v46 + 1], &v55))
            goto LABEL_55;
          v34 = v55;
          v35 = v55 + 1;
          v55 = v35;
          if (v43 != v35)
          {
            v47 = ~v34;
            memmove(&v33[v35], &v33[v43], v31);
            v32 += v43 + v47;
          }
          v16 -= v32;
          v54 = v15 - 1;
          if (DEREncodeLength(v16, (unint64_t)(v17 + 1), &v54))
            goto LABEL_55;
          v36 = v54;
          v37 = v54 + 1;
          v54 = v37;
          v7 = v45;
          if (v15 != v37)
          {
            v38 = ~v36;
            memmove(&v17[v37], &v17[v15], v16);
            v32 += v15 + v38;
            v15 = v54;
          }
          v39 = v51 - v32;
          v53 = v50 - 1;
          if (DEREncodeLength(v51 - v32, v48, &v53))
            goto LABEL_55;
          v40 = v53 + 1;
          v53 = v40;
          if (v50 != v40)
          {
            memmove(&v49[v40], &v49[v50], v39);
            v52 = v52 - v50 + v40;
            v50 = v53;
          }
          v6 = v44;
          v51 = v39;
          v12 = v49;
        }
      }
      v52 += v15 + v16;
    }
    if (v14 != 1)
      goto LABEL_55;
    v6 += v50 + v51;
  }
  if (v9 != 1 || v6 > 0x7FFFFFFFFFFFFFFELL)
  {
LABEL_55:
    CFRelease(Mutable);
    return 0;
  }
  CFDataSetLength(Mutable, v6);
  return Mutable;
}

uint64_t DERParseSequenceContentToObject(unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int16 v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t result;
  unsigned __int16 v17;
  __int16 v18;
  unint64_t v19;
  char *v21;
  uint64_t v23;
  unint64_t v24;
  __int16 *v25;
  unint64_t v26;
  __int16 v27;
  unint64_t v28;
  char *v29;
  unint64_t v31[3];
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v32 = 0;
  if (a6)
  {
    if (a6 > a5)
      goto LABEL_59;
    bzero((void *)a4, a6);
  }
  v10 = *a1;
  v11 = a1[1];
  if (__CFADD__(*a1, v11))
    goto LABEL_58;
  v12 = v10 + v11;
  if (v10 > v12)
LABEL_59:
    __break(0x5519u);
  v32 = *a1;
  v33 = v12;
  if (a2)
  {
    v13 = 0;
    v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      v15 = v32;
      v14 = v33;
      result = DERDecodeSeqNext(&v32, v31);
      if ((_DWORD)result)
        break;
      if (a2 <= v13)
        return 2;
      while (1)
      {
        if (24 * (__int16)v13 > (unint64_t)~a3)
          goto LABEL_58;
        v17 = v13;
        v18 = *(_WORD *)(a3 + 24 * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(_QWORD *)(a3 + 24 * v13 + 8))
          break;
        result = 2;
        if ((v18 & 1) != 0)
        {
          ++v13;
          if (a2 > (unsigned __int16)(v17 + 1))
            continue;
        }
        return result;
      }
      if ((v18 & 4) == 0)
      {
        v19 = *(_QWORD *)(a3 + 24 * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5)
          return 7;
        if (v19 > ~a4)
          goto LABEL_58;
        v21 = (char *)(a4 + v19);
        if (v21 >= v29 || (unint64_t)v21 < a4)
          goto LABEL_59;
        *(_OWORD *)v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((_QWORD *)v21 + 1) <= v14 - v15)
            {
              *(_QWORD *)v21 = v15;
              return 3;
            }
            goto LABEL_59;
          }
          if (v21 + 16 > v29)
            goto LABEL_59;
          v23 = *((_QWORD *)v21 + 1);
          v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }
          if (v14 < v15 || v24 > v14 - v15)
            goto LABEL_59;
          *(_QWORD *)v21 = v15;
          *((_QWORD *)v21 + 1) = v24;
        }
      }
      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            v10 = v31[1] + v31[2];
            v12 = *a1 + v28;
            goto LABEL_47;
          }
        }
LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }
      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        v10 = v32;
        v12 = v33;
        goto LABEL_47;
      }
    }
    if ((_DWORD)result == 1)
    {
      if (a2 <= v13)
      {
        return 0;
      }
      else
      {
        v25 = (__int16 *)(a3 + 24 * v13 + 16);
        v26 = a2 - (unint64_t)v13;
        result = 0;
        while (1)
        {
          v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0)
            break;
          if (!--v26)
            return result;
        }
        return 5;
      }
    }
  }
  else
  {
LABEL_47:
    if (v10 == v12)
      return 0;
    else
      return 3;
  }
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  v10[0] = 0;
  v2 = *a1;
  v3 = a1[1];
  if (*a1 >= v3)
    return 1;
  v10[0] = *a1;
  v10[1] = v3 - v2;
  result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0);
  if (!(_DWORD)result)
  {
    v8 = a2[1];
    v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        result = 0;
        *a1 = v9;
        return result;
      }
      __break(0x5519u);
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  unsigned __int8 *v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  BOOL v10;
  unint64_t v11;
  char *v12;
  unsigned __int8 v13;
  _BYTE *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned int v24;
  BOOL v25;
  char v26;
  unint64_t v27;
  _BYTE *v28;

  v3 = *(_QWORD *)(result + 8);
  if (v3 < 2)
    return 3;
  v4 = *(_BYTE **)result;
  if (*(_QWORD *)result == -1)
    goto LABEL_68;
  v5 = &v4[v3];
  v6 = v4 + 1;
  v7 = v3 - 1;
  v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4)
        goto LABEL_69;
      v14 = v12 + 1;
      v15 = *v12;
      v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15)
            v17 = *v12;
          else
            v17 = v7 - 1;
          v10 = v5 >= v14;
          v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3)
              return 0;
LABEL_34:
            result = 0;
            *a3 = v15;
            return result;
          }
LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }
        return 3;
      }
      v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8)
        return 3;
      if ((v15 & 0x7F) == 0 || v16 < v19)
        return 3;
      if (v14 >= v5 || v14 < v4)
        goto LABEL_69;
      if (!*v14)
        return 3;
      v15 = 0;
      v21 = (v19 - 1);
      v22 = v7 - v21 - 2;
      v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (_BYTE *)-1)
      {
        if (v14 >= v5)
          goto LABEL_69;
        v10 = v16-- != 0;
        if (!v10)
          goto LABEL_70;
        v24 = *v14++;
        v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!(_DWORD)v19)
        {
          if (a3)
            v25 = 0;
          else
            v25 = v15 > v22;
          v26 = v25;
          result = 3;
          if (v15 < 0x80 || (v26 & 1) != 0)
            return result;
          if (v15 >= v22)
            v27 = v22;
          else
            v27 = v15;
          v10 = (unint64_t)v5 >= v23;
          v28 = &v5[-v23];
          if (!v10 || (unint64_t)v4 > v23 || v27 > (unint64_t)v28)
            goto LABEL_69;
          a2[1] = v23;
          a2[2] = v27;
          if (a3)
            goto LABEL_34;
          return 0;
        }
      }
    }
LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }
  v9 = *v6;
  v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10)
    return 3;
  v8 = 0;
  result = 3;
  while (v7 >= 2)
  {
    v11 = v8;
    if (v8 >> 57)
      break;
    if (v6 == (unsigned __int8 *)-1)
      goto LABEL_68;
    if (v6 >= v5 || v6 < v4)
      goto LABEL_69;
    v12 = (char *)(v6 + 1);
    --v7;
    v13 = *v6;
    v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54)
        return 3;
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t der_sizeof_plist(const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeID v10;
  CFIndex Count;
  uint64_t v12;
  unint64_t v13;
  const void *ValueAtIndex;
  const __CFString *v15;
  const __CFString *v16;
  char v18;

  if (!a1)
  {
    v15 = (const __CFString *)sSecDERErrorDomain;
    v16 = CFSTR("Null CFType");
LABEL_8:
    SecCFCreateErrorWithFormat(-5, v15, 0, a2, a5, v16, a7, a8, v18);
    return 0;
  }
  v10 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() == v10)
  {
    Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      v12 = 0;
      v13 = Count + 1;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v13 - 2);
        v12 += der_sizeof_plist(ValueAtIndex, a2);
        --v13;
      }
      while (v13 > 1);
    }
    return ccder_sizeof();
  }
  if (CFBooleanGetTypeID() == v10)
    return ccder_sizeof();
  if (CFDataGetTypeID() == v10)
  {
    CFDataGetLength((CFDataRef)a1);
    return ccder_sizeof_raw_octet_string();
  }
  if (CFDateGetTypeID() == v10)
    return der_sizeof_date();
  if (CFDictionaryGetTypeID() == v10)
    return der_sizeof_dictionary((const __CFDictionary *)a1, (uint64_t)a2);
  if (CFSetGetTypeID() == v10)
    return der_sizeof_set((const __CFSet *)a1, (uint64_t)a2);
  if (CFStringGetTypeID() == v10)
    return der_sizeof_string(a1);
  if (CFNumberGetTypeID() != v10)
  {
    if (CFNullGetTypeID() != v10)
    {
      v15 = (const __CFString *)sSecDERErrorDomain;
      v16 = CFSTR("Unsupported CFType");
      goto LABEL_8;
    }
    return ccder_sizeof();
  }
  return der_sizeof_number((const __CFNumber *)a1, a2);
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0);
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = *result;
  v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }
  else
  {
    v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

void add_sequence_to_array(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFIndex v6;
  CFIndex v7;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  UInt8 *v10;
  CFTypeRef *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  CFRange v19;

  if (*(_BYTE *)a3)
  {
    v6 = der_sizeof_key_value(a1, a2, *(CFTypeRef **)(a3 + 8));
    if (!v6)
    {
      *(_BYTE *)a3 = 0;
      return;
    }
    v7 = v6;
    Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a3 + 24), v6);
    CFDataSetLength(Mutable, v7);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v10 = &MutableBytePtr[v7];
    v11 = *(CFTypeRef **)(a3 + 8);
    v12 = *(unsigned __int8 *)(a3 + 1);
    v13 = der_encode_plist_repair(a2, v11, v12, MutableBytePtr, v10);
    der_encode_plist_repair(a1, v11, v12, MutableBytePtr, v13);
    v14 = ccder_encode_constructed_tl();
    if (v14)
    {
      v19.length = v14 - (_QWORD)MutableBytePtr;
      v19.location = 0;
      CFDataDeleteBytes(Mutable, v19);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), Mutable);
      if (!Mutable)
        return;
    }
    else
    {
      SecCFCreateErrorWithFormat(-7, (const __CFString *)sSecDERErrorDomain, 0, v11, v15, CFSTR("ccder failed to encode"), v16, v17, v18);
      *(_BYTE *)a3 = 0;
      if (!Mutable)
        return;
    }
    CFRelease(Mutable);
  }
}

uint64_t der_encode_plist_repair(const __CFString *a1, CFTypeRef *a2, uint64_t a3, UInt8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeID v13;
  CFIndex Count;
  unint64_t v15;
  uint64_t v16;
  const void *ValueAtIndex;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFString *v22;
  const __CFString *v23;
  uint64_t v24;
  double v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;

  if (!a1)
  {
    v22 = (const __CFString *)sSecDERErrorDomain;
    v23 = CFSTR("Null CFType");
LABEL_8:
    SecCFCreateErrorWithFormat(-5, v22, 0, a2, a5, v23, a7, a8, v31);
    return 0;
  }
  v13 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() == v13)
  {
    Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      v15 = Count + 1;
      v16 = a5;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v15 - 2);
        v16 = der_encode_plist_repair(ValueAtIndex, a2, a3, a4, v16);
        --v15;
      }
      while (v15 > 1);
    }
    goto LABEL_6;
  }
  if (CFBooleanGetTypeID() == v13)
  {
    CFBooleanGetValue((CFBooleanRef)a1);
    ccder_encode_body();
    v18 = ccder_encode_tl();
LABEL_11:
    v24 = v18;
    if (!v18)
      SecCFCreateErrorWithFormat(-7, (const __CFString *)sSecDERErrorDomain, 0, a2, v19, CFSTR("ccder failed to encode"), v20, v21, v31);
    return v24;
  }
  if (CFDataGetTypeID() == v13)
    return der_encode_data((const __CFData *)a1, a2);
  if (CFDateGetTypeID() == v13)
  {
    v26 = MEMORY[0x18D76F188](a1);
    der_encode_generalizedtime_body_repair(a2, a3, (uint64_t)a4, a5, v26);
LABEL_6:
    v18 = ccder_encode_constructed_tl();
    goto LABEL_11;
  }
  if (CFDictionaryGetTypeID() == v13)
    return der_encode_dictionary_repair((const __CFDictionary *)a1, a2, a3);
  if (CFSetGetTypeID() == v13)
    return der_encode_set_repair((const __CFSet *)a1, a2, a3);
  if (CFStringGetTypeID() == v13)
    return der_encode_string(a1, a2, a4, a5, v27, v28, v29, v30);
  if (CFNumberGetTypeID() == v13)
    return der_encode_number((const __CFNumber *)a1, a2, (uint64_t)a4, a5);
  if (CFNullGetTypeID() != v13)
  {
    v22 = (const __CFString *)sSecDERErrorDomain;
    v23 = CFSTR("Unsupported CFType");
    goto LABEL_8;
  }
  return der_encode_null(a2);
}

uint64_t add_key_value_size(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)a3)
  {
    result = der_sizeof_key_value(result, a2, *(CFTypeRef **)(a3 + 16));
    if (result)
      *(_QWORD *)(a3 + 8) += result;
    else
      *(_BYTE *)a3 = 0;
  }
  return result;
}

uint64_t der_sizeof_key_value(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  if (der_sizeof_plist(a1, a3) && der_sizeof_plist(a2, a3))
    return ccder_sizeof();
  SecCFCreateErrorWithFormat(-6, (const __CFString *)sSecDERErrorDomain, 0, a3, v5, CFSTR("null input"), v6, v7, v9);
  return 0;
}

uint64_t der_sizeof_string(const __CFString *a1)
{
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  CFIndex usedBufLen;
  CFRange v6;

  Length = CFStringGetLength(a1);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  usedBufLen = 0;
  v6.location = 0;
  v6.length = Length;
  CFStringGetBytes(a1, v6, 0x8000100u, 0, 0, 0, MaximumSizeForEncoding, &usedBufLen);
  return ccder_sizeof();
}

uint64_t der_encode_string(const __CFString *a1, CFTypeRef *a2, UInt8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex Length;
  uint64_t result;
  const __CFString *v14;
  const __CFString *v15;
  CFIndex v16;
  char usedBufLen;
  CFIndex v18;
  CFRange v19;

  if (a4)
  {
    Length = CFStringGetLength(a1);
    v18 = 0;
    v19.location = 0;
    v19.length = Length;
    if (CFStringGetBytes(a1, v19, 0x8000100u, 0, 0, a3, a4 - (_QWORD)a3, &v18) == Length)
    {
      ccder_encode_body();
      result = ccder_encode_tl();
      if (result)
        return result;
      v14 = (const __CFString *)sSecDERErrorDomain;
      v15 = CFSTR("ccder failed to encode");
      v16 = -7;
    }
    else
    {
      v14 = (const __CFString *)sSecDERErrorDomain;
      v15 = CFSTR("String extraction failed");
      v16 = -5;
    }
  }
  else
  {
    v14 = (const __CFString *)sSecDERErrorDomain;
    v15 = CFSTR("null input");
    v16 = -6;
  }
  SecCFCreateErrorWithFormat(v16, v14, 0, a2, a5, v15, a7, a8, usedBufLen);
  return 0;
}

BOOL derDateGetAbsoluteTime(uint64_t a1, double *a2)
{
  unint64_t v4[3];

  if (*(_QWORD *)(a1 + 8) && (memset(v4, 170, sizeof(v4)), !DERDecodeItem(a1, v4)))
    return derDateContentGetAbsoluteTime(v4[0], (unsigned __int8 *)v4[1], v4[2], a2);
  else
    return 0;
}

BOOL derDateContentGetAbsoluteTime(uint64_t a1, unsigned __int8 *a2, uint64_t a3, double *a4)
{
  double v5;
  CFTypeRef v6;
  NSObject *v7;
  uint8_t v9[8];
  CFTypeRef cf;

  cf = 0;
  v5 = SecAbsoluteTimeFromDateContentWithError(a1, a2, a3, (CFErrorRef *)&cf);
  v6 = cf;
  if (cf)
  {
    v7 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v9 = 0;
      _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "Invalid date specification in certificate (see RFC5280 4.1.2.5)", v9, 2u);
    }
    CFRelease(cf);
  }
  else
  {
    *a4 = v5;
  }
  return v6 == 0;
}

double SecAbsoluteTimeFromDateContentWithError(uint64_t a1, unsigned __int8 *a2, uint64_t a3, CFErrorRef *a4)
{
  int v4;
  char v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  char v10;
  char v11;
  int v12;
  unsigned __int8 *v13;
  int v14;
  double v15;
  int v16;
  _BYTE *v17;
  double v18;
  int v19;
  unsigned int v20;
  signed int v21;
  int v22;
  int v23;
  unsigned int v24;
  unint64_t v25;
  _BOOL4 v26;
  int v30;
  int v31;
  int v33;
  BOOL v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;

  if (a4)
    *a4 = 0;
  if (a2 && a3)
  {
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    switch(a3)
    {
      case 11:
        v6 = 0;
        v5 = 1;
        goto LABEL_8;
      case 13:
        v5 = 0;
        v6 = 0;
LABEL_8:
        v7 = 1;
        goto LABEL_11;
      case 15:
        goto LABEL_11;
      case 17:
        v4 = 1;
        goto LABEL_10;
      case 19:
LABEL_10:
        v5 = 0;
        v6 = 1;
        v7 = v4;
LABEL_11:
        if (a1 == 24)
        {
          if ((v7 & 1) != 0)
            goto LABEL_66;
        }
        else if (a1 != 23 || (v7 & 1) == 0)
        {
          goto LABEL_66;
        }
        v8 = 0;
        break;
      default:
        goto LABEL_66;
    }
    while (1)
    {
      v9 = a2[v8];
      if ((v9 - 48) >= 0xA)
      {
        v10 = v6 ^ 1;
        if (a3 - 5 != v8)
          v10 = 1;
        if ((v10 & 1) != 0 || v9 != 43 && v9 != 45)
        {
          v11 = a3 - 1 == v8 ? v6 : 1;
          if ((v11 & 1) != 0 || v9 != 90)
            break;
        }
      }
      if (a3 == ++v8)
      {
        v12 = a2[1] + 10 * *a2 - 528;
        if (v7)
        {
          v13 = a2 + 2;
          if (v12 > 49)
          {
            v15 = 0.0;
            if (v12 < 0x46)
              return v15;
            v14 = a2[1] + 10 * *a2 + 1372;
          }
          else
          {
            v14 = a2[1] + 10 * *a2 + 1472;
          }
        }
        else
        {
          v13 = a2 + 4;
          v14 = a2[3] + 10 * a2[2] + 100 * v12 - 528;
        }
        if ((v5 & 1) != 0)
        {
          v16 = 0;
          v17 = v13 + 8;
        }
        else
        {
          v17 = v13 + 10;
          v16 = v13[9] + 10 * v13[8] - 528;
        }
        v18 = 0.0;
        if (v6)
        {
          if (*v17 == 43)
            v19 = 60;
          else
            v19 = -60;
          v18 = (double)((v17[4]
                        + 10 * v17[3]
                        + 60 * (v17[2] + 10 * v17[1])
                        - 32208)
                       * v19);
        }
        v20 = v13[1] + 10 * *v13 - 528;
        v21 = v13[3] + 10 * v13[2] - 528;
        v22 = v13[5] + 10 * v13[4] - 528;
        if ((v14 & 3) != 0)
        {
          v23 = 0;
        }
        else
        {
          HIDWORD(v25) = -1030792151 * v14 + 85899344;
          LODWORD(v25) = HIDWORD(v25);
          v24 = v25 >> 2;
          LODWORD(v25) = HIDWORD(v25);
          v26 = (v25 >> 4) < 0xA3D70B;
          v23 = v24 > 0x28F5C28 || v26;
        }
        if (v13[1] + 10 * *v13 - 541 < 0xFFFFFFF4 || v21 < 1 || v21 > 31 || v22 > 23)
          break;
        v30 = v13[7] + 10 * v13[6] - 528;
        if (v30 > 59 || v16 > 60 || v20 == 2 && v21 > (v23 | 0x1Cu))
          break;
        if (v20 == 2)
        {
          v31 = 31;
        }
        else
        {
          v31 = mdays[v20 - 1];
          if (v21 > mdays[v20] - v31)
            break;
        }
        v33 = v14 - 2000;
        v34 = __OFSUB__(v14, 2001);
        v35 = v14 - 2001;
        if (v35 < 0 != v34)
        {
          v36 = -2;
        }
        else
        {
          v33 = v35;
          v36 = -1;
        }
        v37 = v33 / -100;
        v38 = v33 / 400;
        v39 = v33 + (v33 < 0 ? 3 : 0);
        if (v20 <= 2)
          v40 = 0;
        else
          v40 = v23;
        return (double)v16
             + ((double)v30
              + ((double)v22 + (double)(v36 + 365 * v35 + (v39 >> 2) + v37 + v38 + v21 + v40 + v31) * 24.0) * 60.0)
             * 60.0
             - v18;
      }
    }
  }
LABEL_66:
  v15 = 0.0;
  if (a4)
    *a4 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -26275, 0);
  return v15;
}

uint64_t der_sizeof_number(const __CFNumber *a1, CFTypeRef *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v10;
  uint64_t valuePtr;

  valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    if ((HIBYTE(valuePtr) + 1) <= 1u)
    {
      v6 = 9;
      v7 = 48;
      do
      {
        if ((unint64_t)(v6 - 2) < 2)
          break;
        v8 = valuePtr >> v7;
        --v6;
        v7 -= 8;
      }
      while (HIBYTE(valuePtr) == v8);
    }
    return ccder_sizeof();
  }
  else
  {
    SecCFCreateErrorWithFormat(-4, (const __CFString *)sSecDERErrorDomain, 0, a2, v3, CFSTR("Unable to get number from data"), v4, v5, v10);
    return 0;
  }
}

uint64_t SecCEPKeyUsage(uint64_t a1, uint64_t a2)
{
  int v4;
  unint64_t v5;
  int v6;
  unsigned __int16 v7;
  int v8;
  int v9;
  int i;
  int v11;
  uint64_t result;
  NSObject *v13;
  _BOOL4 v14;
  uint8_t v15[8];
  unint64_t v16[3];

  v4 = *(unsigned __int8 *)(a2 + 16) != 0;
  memset(v16, 170, sizeof(v16));
  if (!DERDecodeItem(a2 + 24, v16)
    && v16[0] == 3
    && v16[1] + v16[2] == *(_QWORD *)(a2 + 24) + *(_QWORD *)(a2 + 32)
    && (v16[2] & 0xFFFFFFFFFFFFFFFELL) == 2
    && (v5 = *(unsigned __int8 *)v16[1], v5 <= 7))
  {
    v6 = v4 << 31;
    v7 = 8 * (LOWORD(v16[2]) - 1) - v5;
    v8 = *(unsigned __int8 *)(v16[1] + 1);
    if (v16[2] - 1 < 2)
    {
      v9 = 128;
    }
    else
    {
      v8 = *(unsigned __int8 *)(v16[1] + 2) | (v8 << 8);
      v9 = 0x8000;
    }
    if (v7)
    {
      for (i = 0; i != v7; ++i)
      {
        v11 = 1 << i;
        if ((v8 & v9) == 0)
          v11 = 0;
        v6 |= v11;
        v9 = (unsigned __int16)v9 >> 1;
      }
    }
    *(_DWORD *)(a1 + 384) = v6;
    return 1;
  }
  else
  {
    *(_DWORD *)(a1 + 384) = 0;
    v13 = secLogObjForScope("SecWarning");
    v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v14)
    {
      *(_WORD *)v15 = 0;
      _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, "Invalid KeyUsage Extension", v15, 2u);
      return 0;
    }
  }
  return result;
}

uint64_t SecCEPBasicConstraints(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t result;
  NSObject *v6;
  _BOOL4 v7;
  uint8_t v8[16];
  __int128 v9;
  __int128 v10;

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9 = v4;
  v10 = v4;
  if (!DERParseSequence(a2 + 24, (unsigned __int16)DERNumBasicConstraintsItemSpecs, (uint64_t)&DERBasicConstraintsItemSpecs, (unint64_t)&v9, 0x20uLL)&& !DERParseBooleanWithDefault((unsigned __int8 **)&v9, 0, (BOOL *)(a1 + 302)))
  {
    if (!*((_QWORD *)&v10 + 1))
    {
LABEL_6:
      result = 1;
      *(_BYTE *)(a1 + 300) = 1;
      *(_BYTE *)(a1 + 301) = *(_BYTE *)(a2 + 16);
      return result;
    }
    if (!DERParseInteger((char **)&v10, (_DWORD *)(a1 + 304)))
    {
      *(_BYTE *)(a1 + 303) = 1;
      goto LABEL_6;
    }
  }
  *(_BYTE *)(a1 + 300) = 0;
  v6 = secLogObjForScope("SecWarning");
  v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v7)
  {
    *(_WORD *)v8 = 0;
    _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "Invalid BasicConstraints Extension", v8, 2u);
    return 0;
  }
  return result;
}

uint64_t SecCEPSubjectKeyIdentifier(uint64_t a1, uint64_t a2)
{
  BOOL v3;
  uint64_t v4;
  NSObject *v6;
  uint8_t v8[8];
  unint64_t v9[3];

  memset(v9, 170, sizeof(v9));
  if (DERDecodeItem(a2 + 24, v9))
    v3 = 0;
  else
    v3 = v9[0] == 4;
  v4 = v3;
  if (v3)
  {
    *(_OWORD *)(a1 + 392) = *(_OWORD *)&v9[1];
  }
  else
  {
    v6 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v8 = 0;
      _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "Invalid SubjectKeyIdentifier Extension", v8, 2u);
    }
  }
  return v4;
}

uint64_t SecCEPAuthorityKeyIdentifier(uint64_t a1, uint64_t a2)
{
  __int128 v3;
  uint64_t result;
  NSObject *v5;
  _BOOL4 v6;
  uint8_t v7[16];
  __int128 v8;
  __int128 v9;
  __int128 v10;

  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9 = v3;
  v10 = v3;
  v8 = v3;
  if (!DERParseSequence(a2 + 24, (unsigned __int16)DERNumAuthorityKeyIdentifierItemSpecs, (uint64_t)&DERAuthorityKeyIdentifierItemSpecs, (unint64_t)&v8, 0x30uLL))
  {
    if (*((_QWORD *)&v8 + 1))
      *(_OWORD *)(a1 + 408) = v8;
    if (!(*((_QWORD *)&v9 + 1) | *((_QWORD *)&v10 + 1)))
      return 1;
    if (*((_QWORD *)&v9 + 1) && *((_QWORD *)&v10 + 1))
    {
      *(_OWORD *)(a1 + 424) = v9;
      *(_OWORD *)(a1 + 440) = v10;
      return 1;
    }
  }
  v5 = secLogObjForScope("SecWarning");
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v6)
  {
    *(_WORD *)v7 = 0;
    _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "Invalid AuthorityKeyIdentifier Extension", v7, 2u);
    return 0;
  }
  return result;
}

uint64_t der_sizeof_dictionary(const __CFDictionary *a1, uint64_t a2)
{
  __int128 v3;
  uint64_t v4;

  v3 = xmmword_18AA61B50;
  LOBYTE(v3) = 1;
  v4 = a2;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)add_key_value_size, &v3);
  if ((_BYTE)v3)
    return ccder_sizeof();
  else
    return 0;
}

uint64_t der_sizeof_date()
{
  MEMORY[0x18D76F188]();
  __dtoa();
  __freedtoa();
  return ccder_sizeof();
}

uint64_t SecCEPAuthorityInfoAccess(uint64_t a1, uint64_t a2)
{
  __CFArray **v3;
  const __CFAllocator *v4;
  int i;
  uint64_t result;
  __int128 v7;
  __CFArray **v9;
  CFURLRef v10;
  CFURLRef v11;
  __CFArray *Mutable;
  NSObject *v13;
  _BOOL4 v14;
  __CFArray **v15;
  unint64_t v16[3];
  uint8_t buf[16];
  __int128 v18;
  unint64_t v19[3];
  unint64_t v20[3];

  memset(v20, 170, sizeof(v20));
  if (DERDecodeSeqInit(a2 + 24, &v20[2], v20) || v20[2] != 0x2000000000000010 || v20[0] == v20[1])
    goto LABEL_23;
  memset(v19, 170, sizeof(v19));
  v15 = (__CFArray **)(a1 + 480);
  v3 = (__CFArray **)(a1 + 472);
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  for (i = 1023; ; --i)
  {
    result = DERDecodeSeqNext(v20, v19);
    if ((_DWORD)result)
      break;
    if (v19[0] != 0x2000000000000010)
      goto LABEL_23;
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)buf = v7;
    v18 = v7;
    if (DERParseSequenceContent(&v19[1], (unsigned __int16)DERNumAccessDescriptionItemSpecs, (uint64_t)&DERAccessDescriptionItemSpecs, (unint64_t)buf, 0x20uLL)|| i == 0)
    {
      goto LABEL_23;
    }
    v9 = v3;
    if (!DEROidCompare((uint64_t)buf, (uint64_t)&oidAdOCSP))
    {
      v9 = v15;
      if (!DEROidCompare((uint64_t)buf, (uint64_t)&oidAdCAIssuer))
        continue;
    }
    memset(v16, 170, sizeof(v16));
    if (DERDecodeItem((uint64_t)&v18, v16)
      || v16[0] != 0x8000000000000006
      || v16[2] > 0x7FFFFFFFFFFFFFFELL)
    {
      goto LABEL_23;
    }
    v10 = CFURLCreateWithBytes(v4, (const UInt8 *)v16[1], v16[2], 0x600u, 0);
    if (v10)
    {
      v11 = v10;
      Mutable = *v9;
      if (!*v9)
      {
        Mutable = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]);
        *v9 = Mutable;
      }
      CFArrayAppendValue(Mutable, v11);
      CFRelease(v11);
    }
  }
  if ((_DWORD)result != 1)
  {
LABEL_23:
    v13 = secLogObjForScope("SecWarning");
    v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v14)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, "Invalid Authority Information Access extension", buf, 2u);
      return 0;
    }
  }
  return result;
}

uint64_t SecCEPExtendedKeyUsage(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t result;
  NSObject *v5;
  _BOOL4 v6;
  uint8_t v7[16];
  unint64_t v8[3];
  _QWORD v9[3];

  memset(v9, 170, sizeof(v9));
  if (DERDecodeSeqInit(a2 + 24, v9, &v9[1]) || v9[0] != 0x2000000000000010 || v9[1] == v9[2])
    goto LABEL_14;
  v2 = 0;
  memset(v8, 170, sizeof(v8));
  while (1)
  {
    result = DERDecodeSeqNext(&v9[1], v8);
    if ((_DWORD)result)
      break;
    if (v8[0] != 6 || v2++ >= 0x1FFF)
      goto LABEL_14;
  }
  if ((_DWORD)result != 1)
  {
LABEL_14:
    v5 = secLogObjForScope("SecWarning");
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v6)
    {
      *(_WORD *)v7 = 0;
      _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "Invalidate EKU Extension", v7, 2u);
      return 0;
    }
  }
  return result;
}

uint64_t SecCEPCrlDistributionPoints(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t result;
  __int128 v6;
  uint64_t v7;
  NSObject *v8;
  _BOOL4 v9;
  unint64_t v10[3];
  uint8_t buf[16];
  __int128 v12;
  __int128 v13;
  unint64_t v14[3];
  _QWORD v15[3];

  memset(v15, 170, sizeof(v15));
  if (DERDecodeSeqInit(a2 + 24, v15, &v15[1]) || v15[0] != 0x2000000000000010 || v15[1] == v15[2])
    goto LABEL_23;
  v3 = 0;
  memset(v14, 170, sizeof(v14));
  v4 = a1 + 464;
  while (1)
  {
    result = DERDecodeSeqNext(&v15[1], v14);
    if ((_DWORD)result)
      break;
    if (v14[0] != 0x2000000000000010)
      goto LABEL_23;
    *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v12 = v6;
    v13 = v6;
    *(_OWORD *)buf = v6;
    if (DERParseSequenceContent(&v14[1], (unsigned __int16)DERNumDistributionPointItemSpecs, (uint64_t)&DERDistributionPointItemSpecs, (unint64_t)buf, 0x30uLL))goto LABEL_23;
    v7 = v13;
    if (!(*(_QWORD *)buf | (unint64_t)v13))
      goto LABEL_23;
    if (*(_QWORD *)buf)
    {
      memset(v10, 170, sizeof(v10));
      if (DERDecodeItem((uint64_t)buf, v10)
        || v10[0] != 0xA000000000000001
        && (v10[0] != 0xA000000000000000
         || parseGeneralNamesContent(&v10[1], v4, (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendCRLDPFromGeneralNames)))
      {
        goto LABEL_23;
      }
      v7 = v13;
    }
    if (v7)
    {
      if (parseGeneralNamesContent((unint64_t *)&v13, v4, (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendCRLDPFromGeneralNames)|| v3 > 0x3FE)
      {
        goto LABEL_23;
      }
    }
    else if (v3 >= 0x3FF)
    {
      goto LABEL_23;
    }
    ++v3;
  }
  if ((_DWORD)result != 1)
  {
LABEL_23:
    v8 = secLogObjForScope("SecWarning");
    v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v9)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "Invalid CRL Distribution Points extension", buf, 2u);
      return 0;
    }
  }
  return result;
}

uint64_t parseGeneralNamesContent(unint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t))
{
  int v5;
  int v6;
  uint64_t result;
  NSObject *v8;
  _BOOL4 v9;
  unint64_t v10[3];
  unint64_t v11[2];
  uint8_t buf[4];
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v11[0] = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = 0xAAAAAAAAAAAAAAAALL;
  if (DERDecodeSeqContentInit(a1, v11))
    return 4294941021;
  memset(v10, 170, sizeof(v10));
  v5 = 8193;
  while (1)
  {
    v6 = DERDecodeSeqNext(v11, v10);
    if (v6)
      break;
    result = SecCertificateParseGeneralNameContentProperty(v10[0], (uint64_t)&v10[1], a2, a3);
    if ((_DWORD)result)
      return result;
    if (!--v5)
    {
      v8 = secLogObjForScope("SecWarning");
      v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (v9)
      {
        *(_DWORD *)buf = 67109120;
        v13 = 0x2000;
        _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "Skipping general names after the first %d", buf, 8u);
        return 0;
      }
      return result;
    }
  }
  if (v6 == 1)
    return 0;
  else
    return 4294941021;
}

uint64_t SecCertificateParseGeneralNameContentProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t))
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  unint64_t v11[3];

  result = 4294941021;
  switch(a1)
  {
    case 0x8000000000000001:
      v8 = a3;
      v9 = 1;
      goto LABEL_13;
    case 0x8000000000000002:
      v8 = a3;
      v9 = 2;
      goto LABEL_13;
    case 0x8000000000000003:
    case 0x8000000000000004:
    case 0x8000000000000005:
      return result;
    case 0x8000000000000006:
      v8 = a3;
      v9 = 6;
      goto LABEL_13;
    case 0x8000000000000007:
      v8 = a3;
      v9 = 7;
      goto LABEL_13;
    case 0x8000000000000008:
      v8 = a3;
      v9 = 8;
LABEL_13:
      result = a4(v8, v9, a2);
      break;
    default:
      switch(a1)
      {
        case 0xA000000000000000:
          v8 = a3;
          v9 = 0;
          goto LABEL_13;
        case 0xA000000000000003:
          v8 = a3;
          v9 = 3;
          goto LABEL_13;
        case 0xA000000000000004:
          v8 = a3;
          v9 = 4;
          goto LABEL_13;
        case 0xA000000000000005:
          v8 = a3;
          v9 = 5;
          goto LABEL_13;
        case 0xA000000000000006:
          memset(v11, 170, sizeof(v11));
          if (DERDecodeItem(a2, v11) || v11[0] != 22)
            result = 4294941021;
          else
            result = a4(a3, 6, (uint64_t)&v11[1]);
          break;
        default:
          return result;
      }
      break;
  }
  return result;
}

uint64_t verifySubjectAltGeneralName()
{
  return 0;
}

uint64_t appendDNSNamesFromGeneralNames(__CFArray *a1, int a2, uint64_t a3)
{
  const __CFString *v4;
  const __CFString *v5;

  if (a2 != 2)
    return 0;
  if ((*(_QWORD *)(a3 + 8) & 0x8000000000000000) != 0)
    return 4294941021;
  v4 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(const UInt8 **)a3, *(_QWORD *)(a3 + 8), 0x8000100u, 0);
  if (!v4)
    return 4294941021;
  v5 = v4;
  if (SecFrameworkIsDNSName(v4))
    CFArrayAppendValue(a1, v5);
  CFRelease(v5);
  return 0;
}

BOOL SecFrameworkIsDNSName(const __CFString *a1)
{
  CFIndex Length;
  uint64_t v3;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v6;
  int64_t v7;
  int v8;
  int v9;
  int64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFIndex v14;
  UniChar v15;
  uint64_t v17;
  uint64_t v18;
  int64_t v19;
  CFIndex v20;
  _OWORD v22[8];
  CFStringRef theString;
  const UniChar *v24;
  const char *v25;
  uint64_t v26;
  CFIndex v27;
  int64_t v28;
  int64_t v29;
  CFRange v30;

  memset(v22, 0, sizeof(v22));
  Length = CFStringGetLength(a1);
  if (Length > 255)
    return 0;
  v3 = Length;
  theString = a1;
  v26 = 0;
  v27 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v24 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v28 = 0;
  v29 = 0;
  v25 = CStringPtr;
  if (v3 < 1)
    return 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 64;
  do
  {
    if ((unint64_t)v10 >= 4)
      v13 = 4;
    else
      v13 = v10;
    v14 = v27;
    if (v27 <= v10)
    {
      v15 = 0;
      ++v11;
    }
    else
    {
      if (v24)
      {
        v15 = v24[v10 + v26];
      }
      else if (v25)
      {
        v15 = v25[v26 + v10];
      }
      else
      {
        if (v29 <= v10 || v7 > v10)
        {
          v17 = v13 + v6;
          v18 = v12 - v13;
          v19 = v10 - v13;
          v20 = v19 + 64;
          if (v19 + 64 >= v27)
            v20 = v27;
          v28 = v19;
          v29 = v20;
          if (v27 >= v18)
            v14 = v18;
          v30.length = v14 + v17;
          v30.location = v19 + v26;
          CFStringGetCharacters(theString, v30, (UniChar *)v22);
          v7 = v28;
        }
        v15 = *((_WORD *)v22 + v10 - v7);
      }
      if (v15 == 46)
      {
        if (v11 > 63 || (v9 & 0xFFFFFFFE) != 2)
          return 0;
        v11 = 0;
        v8 = 0;
        v9 = 1;
        goto LABEL_41;
      }
      ++v11;
      if ((unsigned __int16)(v15 - 65) < 0x1Au)
      {
        v8 = 1;
LABEL_40:
        v9 = 2;
        goto LABEL_41;
      }
    }
    if (v15 == 42 || (unsigned __int16)(v15 - 97) < 0x1Au)
    {
      v9 = 2;
      v8 = 1;
      goto LABEL_41;
    }
    if ((unsigned __int16)(v15 - 48) < 0xAu)
    {
      v9 = 3;
      goto LABEL_41;
    }
    if (v15 == 95)
      goto LABEL_40;
    if (v15 != 45 || (v9 - 2) > 2)
      return 0;
    v9 = 4;
LABEL_41:
    ++v10;
    --v6;
    ++v12;
  }
  while (v3 != v10);
  return v11 <= 63 && (v9 & 6) == 2 && v8 == 1;
}

CFURLRef appendCRLDPFromGeneralNames(__CFArray **a1, int a2, uint64_t a3)
{
  CFURLRef result;
  const void *v5;
  __CFArray *Mutable;

  if (a2 != 6)
    return 0;
  if ((*(_QWORD *)(a3 + 8) & 0x8000000000000000) != 0)
    return (CFURLRef)4294941021;
  result = CFURLCreateWithBytes(0, *(const UInt8 **)a3, *(_QWORD *)(a3 + 8), 0x600u, 0);
  if (result)
  {
    v5 = result;
    Mutable = *a1;
    if (!*a1)
    {
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      *a1 = Mutable;
    }
    CFArrayAppendValue(Mutable, v5);
    CFRelease(v5);
    return 0;
  }
  return result;
}

uint64_t SecCEPCertificatePolicies(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  int v6;
  NSObject *v8;
  _BOOL4 v9;
  uint64_t result;
  _OWORD *v11;
  _OWORD *v12;
  _OWORD *v13;
  unint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  unint64_t v18[3];
  unint64_t v19[3];

  v4 = a2 + 24;
  memset(v19, 170, sizeof(v19));
  if (DERDecodeSeqInit(a2 + 24, &v19[2], v19) || v19[2] != 0x2000000000000010)
    goto LABEL_10;
  v5 = 0;
  memset(v18, 170, sizeof(v18));
  while (1)
  {
    v6 = DERDecodeSeqNext(v19, v18);
    if (v6)
      break;
    if (v18[0] != 0x2000000000000010 || v5++ >= 0x1FFF)
      goto LABEL_10;
  }
  if (!v5)
    goto LABEL_10;
  if (v6 != 1)
    goto LABEL_10;
  v11 = malloc_type_malloc(32 * v5, 0x1010040E633A1C4uLL);
  if (!v11)
    goto LABEL_10;
  v12 = v11;
  if (DERDecodeSeqInit(v4, &v19[2], v19))
  {
LABEL_22:
    free(v12);
LABEL_10:
    *(_BYTE *)(a1 + 352) = 0;
    v8 = secLogObjForScope("SecWarning");
    v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v9)
    {
      LOWORD(v16) = 0;
      _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "Invalid CertificatePolicies Extension", (uint8_t *)&v16, 2u);
      return 0;
    }
    return result;
  }
  v13 = v12 + 1;
  v14 = v5;
  do
  {
    if (DERDecodeSeqNext(v19, v18))
      break;
    *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v16 = v15;
    v17 = v15;
    if (DERParseSequenceContent(&v18[1], (unsigned __int16)DERNumPolicyInformationItemSpecs, (uint64_t)&DERPolicyInformationItemSpecs, (unint64_t)&v16, 0x20uLL))goto LABEL_22;
    *(v13 - 1) = v16;
    *v13 = v17;
    v13 += 2;
    --v14;
  }
  while (v14);
  result = 1;
  *(_BYTE *)(a1 + 352) = 1;
  *(_BYTE *)(a1 + 353) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 360) = v5;
  *(_QWORD *)(a1 + 368) = v12;
  return result;
}

uint64_t der_encode_data(const __CFData *a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccder_encode_body();
  v7 = ccder_encode_tl();
  if (!v7)
    SecCFCreateErrorWithFormat(-7, (const __CFString *)sSecDERErrorDomain, 0, a2, v4, CFSTR("ccder failed to encode"), v5, v6, v9);
  return v7;
}

uint64_t der_encode_dictionary_repair(const __CFDictionary *a1, CFTypeRef *a2, char a3)
{
  CFMutableArrayRef Mutable;
  CFIndex Count;
  unint64_t v8;
  const __CFData *ValueAtIndex;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[4];
  CFRange v15;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v14[0] = 0xAAAAAAAAAAAAAA01;
  v14[1] = a2;
  BYTE1(v14[0]) = a3;
  v14[2] = Mutable;
  v14[3] = 0;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)add_sequence_to_array, v14);
  if (!LOBYTE(v14[0]))
  {
    if (Mutable)
      CFRelease(Mutable);
    return 0;
  }
  v15.length = CFArrayGetCount(Mutable);
  v15.location = 0;
  CFArraySortValues(Mutable, v15, (CFComparatorFunction)cfdata_compare_der_contents, 0);
  Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    v8 = Count + 1;
    do
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v8 - 2);
      CFDataGetLength(ValueAtIndex);
      CFDataGetBytePtr(ValueAtIndex);
      ccder_encode_body();
      --v8;
    }
    while (v8 > 1);
  }
  if (Mutable)
    CFRelease(Mutable);
  result = ccder_encode_constructed_tl();
  if (!result)
  {
    SecCFCreateErrorWithFormat(-7, (const __CFString *)sSecDERErrorDomain, 0, a2, v11, CFSTR("ccder failed to encode"), v12, v13, v14[0]);
    return 0;
  }
  return result;
}

uint64_t der_encode_number(const __CFNumber *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  const __CFString *v17;
  CFIndex v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t result;
  char v22;
  uint64_t valuePtr;

  valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (!CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    v16 = (const __CFString *)sSecDERErrorDomain;
    v17 = CFSTR("Unable to get number from data");
    v18 = -4;
LABEL_23:
    SecCFCreateErrorWithFormat(v18, v16, 0, a2, v7, v17, v8, v9, v22);
    return 0;
  }
  v10 = valuePtr;
  v11 = HIBYTE(valuePtr);
  if ((HIBYTE(valuePtr) + 1) > 1u)
  {
    v19 = 8;
    if (!a4)
      goto LABEL_22;
  }
  else
  {
    v12 = 9;
    v13 = 48;
    v14 = 1;
    while ((unint64_t)(v12 - 2) >= 2)
    {
      v15 = valuePtr >> v13;
      --v12;
      v13 -= 8;
      if ((_DWORD)v11 != v15)
      {
        v14 = v12 - 1;
        goto LABEL_11;
      }
    }
    v12 = 2;
LABEL_11:
    if ((((valuePtr >> (8 * v14 - 8)) ^ v11) & 0x80) != 0)
      v19 = v12;
    else
      v19 = v14;
    if (!a4)
      goto LABEL_22;
  }
  if (a4 - a3 < (uint64_t)v19)
  {
LABEL_22:
    v16 = (const __CFString *)sSecDERErrorDomain;
    v17 = CFSTR("Unknown size");
    v18 = -3;
    goto LABEL_23;
  }
  if (v19 <= 1)
    v20 = 1;
  else
    v20 = v19;
  do
  {
    *(_BYTE *)--a4 = v10;
    v10 >>= 8;
    --v20;
  }
  while (v20);
  valuePtr = v10;
  result = ccder_encode_tl();
  if (!result)
  {
    v16 = (const __CFString *)sSecDERErrorDomain;
    v17 = CFSTR("ccder failed to encode");
    v18 = -7;
    goto LABEL_23;
  }
  return result;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  uint64_t result;
  unint64_t v4[2];

  v4[1] = *MEMORY[0x1E0C80C00];
  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  result = DERParseInteger64(a1, v4);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v4[0]))
    {
      return 7;
    }
    else
    {
      result = 0;
      *a2 = v4[0];
    }
  }
  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2;
  unsigned __int8 *v3;
  uint64_t result;
  unint64_t v5;
  unsigned int v6;

  v2 = (unint64_t)a1[1];
  if (!v2)
    return 3;
  v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0)
    return 3;
  if (**a1)
  {
    if (v2 > 8)
      return 7;
    goto LABEL_10;
  }
  if (v2 >= 2)
  {
    if (((char)v3[1] & 0x80000000) == 0)
      return 3;
    if (v2 > 9)
      return 7;
  }
LABEL_10:
  v5 = 0;
  do
  {
    v6 = *v3++;
    v5 = v6 | (v5 << 8);
    --v2;
  }
  while (v2);
  result = 0;
  *a2 = v5;
  return result;
}

BOOL SecCEPSubjectAltName(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v6;
  uint8_t v7[16];

  v4 = SecCertificateParseGeneralNames(a2 + 24, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t))verifySubjectAltGeneralName);
  if (v4)
  {
    *(_QWORD *)(a1 + 456) = 0;
    v6 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v7 = 0;
      _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "Invalid SubjectAltName Extension", v7, 2u);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 456) = a2;
  }
  return v4 == 0;
}

uint64_t SecCertificateParseGeneralNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t))
{
  int v5;
  uint64_t result;
  unint64_t v8[3];

  memset(v8, 170, sizeof(v8));
  v5 = DERDecodeItem(a1, v8);
  result = 4294941021;
  if (!v5 && v8[0] == 0x2000000000000010 && v8[2] != 0)
    return parseGeneralNamesContent(&v8[1], a2, a3);
  return result;
}

uint64_t SecCEPOCSPNoCheck()
{
  return 1;
}

uint64_t appendIPAddressesFromGeneralNames(__CFArray *a1, int a2, uint64_t a3)
{
  uint64_t v3;
  CFDataRef v6;

  if (a2 != 7)
    return 0;
  v3 = *(_QWORD *)(a3 + 8);
  if (v3 != 16 && v3 != 4)
    return 4294941021;
  v6 = CFDataCreate(0, *(const UInt8 **)a3, *(_QWORD *)(a3 + 8));
  CFArrayAppendValue(a1, v6);
  if (v6)
    CFRelease(v6);
  return 0;
}

uint64_t SecCertificateGetNormalizedSubjectContent(uint64_t a1)
{
  return *(_QWORD *)(a1 + 584);
}

BOOL SecPolicyCheckCertExtendedKeyUsage(uint64_t a1, const __CFString *a2)
{
  return SecPolicyCheckCertExtendedKeyUsageFiltered(a1, a2, 1);
}

uint64_t SecCertificateGetBytePtr(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

unint64_t SecCertificateHash(_QWORD *a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = 0;
  v2 = a1[11];
  v3 = v2 - 4;
  if (v2 < 4)
    v3 = 0;
  if (v3 < v2)
  {
    v1 = 0;
    v4 = 4;
    if (v2 < 4)
      v4 = a1[11];
    v5 = -v4;
    do
      v1 = *(unsigned __int8 *)(a1[10] + v2 + v5) | (v1 << 8);
    while (!__CFADD__(v5++, 1));
  }
  return v2 + a1[3] + v1;
}

uint64_t SecCertificateGetPermittedSubtrees(uint64_t a1)
{
  return *(_QWORD *)(a1 + 488);
}

uint64_t SecCertificateGetExcludedSubtrees(uint64_t a1)
{
  return *(_QWORD *)(a1 + 496);
}

uint64_t SecCertificateGetBasicConstraints(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 300))
    return a1 + 300;
  else
    return 0;
}

BOOL SecCertificateIsValid(_BOOL8 result, double a2)
{
  if (result)
    return *(double *)(result + 168) <= a2 && *(double *)(result + 176) >= a2;
  return result;
}

uint64_t SecCertificateGetKeyUsage(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 384);
  return result;
}

uint64_t SecCertificateVersion(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 96) + 1;
}

SecConcrete_sec_array *sec_array_create()
{
  return objc_alloc_init(SecConcrete_sec_array);
}

uint64_t SecCertificateGetPublicKeyData(uint64_t a1)
{
  return a1 + 248;
}

__CFData *SecCertificateCopyIssuerSequence(uint64_t a1)
{
  return SecDERItemCopySequence(a1 + 152);
}

__CFData *SecCertificateCopySHA256Digest(_QWORD *cf)
{
  const __CFAllocator *v2;

  if (!cf || !cf[2] || (cf[3] & 0x8000000000000000) != 0)
    return 0;
  v2 = CFGetAllocator(cf);
  return SecSHA256DigestCreate(v2, cf[2], cf[3]);
}

CFStringRef SecTaskCopySigningIdentifier(SecTaskRef task, CFErrorRef *error)
{
  return SecTaskCopyIdentifier((uint64_t)task, 11, error);
}

CFDataRef SecCertificateCopyNormalizedIssuerSequence(SecCertificateRef certificate)
{
  const __CFData *v1;

  if (certificate && (v1 = (const __CFData *)*((_QWORD *)certificate + 72)) != 0)
    return SecCopySequenceFromContent(v1);
  else
    return 0;
}

__CFString *SecTrustStoreForDomain(int a1)
{
  __CFString *result;

  if ((a1 - 1) > 2)
    return 0;
  result = off_1E1FDB9E0[a1 - 1];
  if (gTrustd)
    return (__CFString *)(*(uint64_t (**)(__CFString *, _QWORD))gTrustd)(result, 0);
  return result;
}

uint64_t SecCertificateGetCertificatePolicies(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 352))
    return a1 + 352;
  else
    return 0;
}

CFDataRef SecCertificateCopyNormalizedSubjectSequence(SecCertificateRef certificate)
{
  const __CFData *v1;

  if (certificate && (v1 = (const __CFData *)*((_QWORD *)certificate + 73)) != 0)
    return SecCopySequenceFromContent(v1);
  else
    return 0;
}

uint64_t SecKeyDestroy(uint64_t result)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)(result + 16) + 32);
  if (v1)
    return v1();
  return result;
}

BOOL SecPolicyCheckCertDuplicateExtension(uint64_t a1)
{
  return !a1 || *(_QWORD *)(a1 + 536) == -1;
}

BOOL SecPolicyCheckCertUnparseableExtension(uint64_t a1)
{
  return !a1 || *(_QWORD *)(a1 + 528) == -1;
}

BOOL SecCertificateHasUnknownCriticalExtension(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 296) != 0;
  return result;
}

uint32_t SecTaskGetCodeSignStatus(SecTaskRef task)
{
  if (csops_task((uint64_t)task))
    return 0;
  else
    return 0;
}

CFDictionaryRef SecTaskCopyValuesForEntitlements(SecTaskRef task, CFArrayRef entitlements, CFErrorRef *error)
{
  CFTypeID TypeID;
  int v7;
  uint64_t Count;
  const __CFAllocator *v9;
  __CFDictionary *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const void *Value;

  TypeID = SecTaskGetTypeID();
  if (TypeID != CFGetTypeID(task))
    return 0;
  v7 = *((unsigned __int8 *)task + 48);
  if (!*((_BYTE *)task + 48))
  {
    SecTaskLoadEntitlements((uint64_t)task, error);
    v7 = *((unsigned __int8 *)task + 48);
  }
  if (v7 != 1)
    return 0;
  Count = CFArrayGetCount(entitlements);
  v9 = CFGetAllocator(task);
  Mutable = CFDictionaryCreateMutable(v9, Count, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (*((_QWORD *)task + 7) && Count >= 1)
  {
    for (i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(entitlements, i);
      Value = CFDictionaryGetValue(*((CFDictionaryRef *)task + 7), ValueAtIndex);
      if (Value)
        CFDictionarySetValue(Mutable, ValueAtIndex, Value);
    }
  }
  return Mutable;
}

SecTaskRef SecTaskCreateFromSelf(CFAllocatorRef allocator)
{
  uint64_t Instance;
  mach_msg_type_number_t task_info_outCnt;

  SecTaskGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    task_info_outCnt = 8;
    if (task_info(*MEMORY[0x1E0C83DA0], 0xFu, (task_info_t)(Instance + 16), &task_info_outCnt))
    {
      CFRelease((CFTypeRef)Instance);
      return 0;
    }
    else
    {
      *(_BYTE *)(Instance + 48) = 0;
      *(_QWORD *)(Instance + 56) = 0;
    }
  }
  return (SecTaskRef)Instance;
}

CFStringRef SecTaskCopyIdentifier(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  uint64_t v5;
  CFStringRef v6;
  int v7;
  char *v9;
  char *v10;

  if (csops_task(a1) != -1 || *__error() != 34)
    return 0;
  v5 = bswap32(0xAAAAAAAA);
  if ((v5 - 1048577) >= 0xFFF00007)
  {
    v9 = (char *)malloc_type_malloc((v5 + 1), 0x1ACEABFEuLL);
    if (v9)
    {
      v10 = v9;
      if (csops_task(a1))
      {
        v6 = 0;
        v7 = *__error();
      }
      else
      {
        v10[v5] = 0;
        v6 = CFStringCreateWithCString(0, v10 + 8, 0x8000100u);
        v7 = 0;
      }
      free(v10);
    }
    else
    {
      v6 = 0;
      v7 = 12;
    }
  }
  else
  {
    v6 = 0;
    v7 = 22;
  }
  if (a3 && v7)
    *a3 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFD0], v7, 0);
  return v6;
}

SecTaskRef SecTaskCreateWithAuditToken(CFAllocatorRef allocator, audit_token_t *token)
{
  SecTaskRef result;
  __int128 v4;

  SecTaskGetTypeID();
  result = (SecTaskRef)_CFRuntimeCreateInstance();
  if (result)
  {
    v4 = *(_OWORD *)&token->val[4];
    *((_OWORD *)result + 1) = *(_OWORD *)token->val;
    *((_OWORD *)result + 2) = v4;
    *((_BYTE *)result + 48) = 0;
    *((_QWORD *)result + 7) = 0;
  }
  return result;
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  CFTypeID TypeID;
  const __CFDictionary *v7;
  const void *Value;
  const void *v9;

  TypeID = SecTaskGetTypeID();
  if (TypeID != CFGetTypeID(task) || !*((_BYTE *)task + 48) && !SecTaskLoadEntitlements((uint64_t)task, error))
    return 0;
  v7 = (const __CFDictionary *)*((_QWORD *)task + 7);
  if (!v7)
    return 0;
  Value = CFDictionaryGetValue(v7, entitlement);
  v9 = Value;
  if (Value)
    CFRetain(Value);
  return v9;
}

CFTypeID SecTaskGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTaskGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_13821;
  block[4] = &SecTaskGetTypeID_sSecTaskGetTypeIDSingleton;
  if (SecTaskGetTypeID_sSecTaskGetTypeIDOnce != -1)
    dispatch_once(&SecTaskGetTypeID_sSecTaskGetTypeIDOnce, block);
  return SecTaskGetTypeID_sSecTaskGetTypeIDSingleton;
}

BOOL SecTaskLoadEntitlements(uint64_t a1, CFErrorRef *a2)
{
  int v4;
  int v5;
  UInt8 *v6;
  CFTypeRef v7;
  _BOOL8 result;
  size_t v9;
  int *v10;
  __int128 v11;
  const __CFString *v12;
  CFIndex v13;
  char *v14;
  CFDataRef v15;
  uint64_t v16;
  _QWORD *v17;
  __int128 v18;
  NSObject *v19;
  const char *v20;
  __int128 v21;
  pid_t pidp;
  pid_t v23;
  uint64_t v24;
  unint64_t v25;
  CFTypeRef cf;
  audit_token_t atoken;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  cf = 0;
  v25 = 0xAAAAAAAAAAAAAAAALL;
  v24 = 0;
  v4 = csops_task(a1);
  if (v4 != -1)
  {
    v5 = v4;
    v6 = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_BYTE *)(a1 + 48) = 1;
    goto LABEL_3;
  }
  if (*__error() != 34)
  {
    v5 = *__error();
    v23 = -1;
    if (csops_task(a1) == -1)
    {
      v10 = __error();
      syslog(5, "Failed to get cs_flags, error=%d", *v10);
    }
    pidp = -1431655766;
    v11 = *(_OWORD *)(a1 + 32);
    *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&atoken.val[4] = v11;
    audit_token_to_au32(&atoken, 0, 0, 0, 0, 0, &pidp, 0, 0);
    syslog(5, "SecTaskLoadEntitlements failed error=%d cs_flags=%x, pid=%d", v5, v23, pidp);
    v12 = SecTaskCopyDebugDescription(a1);
    v13 = 4 * CFStringGetLength(v12);
    v14 = (char *)malloc_type_malloc(v13, 0x91B41A4AuLL);
    if (!CFStringGetCString(v12, v14, v13, 0x8000100u))
      *v14 = 0;
    syslog(5, "SecTaskCopyDebugDescription: %s", v14);
    if (v12)
      CFRelease(v12);
    free(v14);
    *(_DWORD *)(a1 + 64) = v5;
    if (v5 == 22)
    {
      result = 1;
      *(_BYTE *)(a1 + 48) = 1;
      return result;
    }
    v6 = 0;
LABEL_3:
    v7 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v7);
    }
    if (!v6)
      goto LABEL_7;
    goto LABEL_6;
  }
  v9 = bswap32(HIDWORD(v25));
  if ((v9 - 1048577) < 0xFFF00007)
  {
    v6 = 0;
    v5 = 7;
    goto LABEL_3;
  }
  v6 = (UInt8 *)malloc_type_malloc(v9, 0x9CF7F223uLL);
  if (!v6)
  {
    v5 = 12;
    goto LABEL_3;
  }
  if (csops_task(a1))
  {
    v5 = *__error();
    goto LABEL_3;
  }
  v15 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6 + 8, (v9 - 8), (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v16 = CEManagedContextFromCFData();
  v17 = (_QWORD *)MEMORY[0x1E0DDFFA0];
  if (v16 != *MEMORY[0x1E0DDFFA0])
  {
    v23 = -1431655766;
    v18 = *(_OWORD *)(a1 + 32);
    *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&atoken.val[4] = v18;
    audit_token_to_au32(&atoken, 0, 0, 0, 0, 0, &v23, 0, 0);
    v19 = secLogObjForScope("SecTask");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      atoken.val[0] = 67109120;
      atoken.val[1] = v23;
      v20 = "couldn't create a managed context from csops call %d";
      goto LABEL_40;
    }
    goto LABEL_33;
  }
  if (CEQueryContextToCFDictionary() != *v17)
  {
    v23 = -1431655766;
    v21 = *(_OWORD *)(a1 + 32);
    *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&atoken.val[4] = v21;
    audit_token_to_au32(&atoken, 0, 0, 0, 0, 0, &v23, 0, 0);
    v19 = secLogObjForScope("SecTask");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      atoken.val[0] = 67109120;
      atoken.val[1] = v23;
      v20 = "couldn't convert CE to CF %d";
LABEL_40:
      _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, v20, (uint8_t *)&atoken, 8u);
      if (!v15)
        goto LABEL_35;
      goto LABEL_34;
    }
LABEL_33:
    if (!v15)
    {
LABEL_35:
      v5 = 33;
      goto LABEL_3;
    }
LABEL_34:
    CFRelease(v15);
    goto LABEL_35;
  }
  if (v15)
    CFRelease(v15);
  v5 = 33;
LABEL_6:
  free(v6);
LABEL_7:
  if (a2 && v5 && !*a2)
    *a2 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFD0], v5, 0);
  CEReleaseManagedContext();
  return v5 == 0;
}

uint64_t csops_task(uint64_t a1)
{
  __int128 v2;
  uint64_t v3;
  int v4;
  audit_token_t atoken;
  pid_t pidp;

  pidp = -1431655766;
  v2 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&atoken.val[4] = v2;
  audit_token_to_au32(&atoken, 0, 0, 0, 0, 0, &pidp, 0, 0);
  v3 = csops_audittoken();
  if ((_DWORD)v3 == -1)
    v4 = *__error();
  else
    v4 = 0;
  *(_DWORD *)(a1 + 64) = v4;
  return v3;
}

CFStringRef SecTaskCopyDebugDescription(uint64_t a1)
{
  __int128 v2;
  char *v3;
  int *v4;
  const __CFAllocator *v5;
  uint64_t v6;
  uint64_t v7;
  const __CFDictionary *v8;
  CFIndex Count;
  size_t v11;
  pid_t pidp;
  _BYTE atoken[648];
  int v14[2];
  int v15;
  pid_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  pidp = -1431655766;
  v2 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)atoken = *(_OWORD *)(a1 + 16);
  *(_OWORD *)&atoken[16] = v2;
  audit_token_to_au32((audit_token_t *)atoken, 0, 0, 0, 0, 0, &pidp, 0, 0);
  *(_QWORD *)v14 = 0xE00000001;
  v15 = 1;
  v16 = pidp;
  memset(atoken, 170, sizeof(atoken));
  v11 = 648;
  if (sysctl(v14, 4u, atoken, &v11, 0, 0) == -1 || !v11)
  {
    v4 = __error();
    v3 = strerror(*v4);
  }
  else
  {
    v3 = &atoken[243];
  }
  v5 = CFGetAllocator((CFTypeRef)a1);
  v6 = pidp;
  v7 = *(unsigned __int8 *)(a1 + 48);
  v8 = *(const __CFDictionary **)(a1 + 56);
  if (v8)
    Count = CFDictionaryGetCount(v8);
  else
    Count = 0xFFFFFFFFLL;
  return CFStringCreateWithFormat(v5, 0, CFSTR("%s[%d]/%d#%d LF=%d"), v3, v6, v7, Count, *(unsigned int *)(a1 + 64));
}

void SecAccessControlDestroy(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 16);
  if (v1)
    CFRelease(v1);
}

uint64_t SecIsInternalRelease()
{
  return os_variant_allows_internal_security_policies();
}

uint64_t SecCertificateGetPolicyConstraints(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 308))
    return a1 + 308;
  else
    return 0;
}

_QWORD *SecPolicyCreateSSLWithKeyUsage(int a1, const __CFString *a2, int a3)
{
  return SecPolicyCreateSSL_internal(a1, a2, a3, 0);
}

SecCertificateRef sec_certificate_copy_ref(sec_certificate_t certificate)
{
  Class isa;

  if (certificate && (isa = certificate[1].isa) != 0)
    return (SecCertificateRef)CFRetain(isa);
  else
    return 0;
}

uint64_t SecECPublicKeyDestroy(uint64_t result)
{
  if (**(_QWORD **)(result + 24))
    return cc_clear();
  return result;
}

void check_for_marker(const __CFString *a1, const __CFString *a2, uint64_t a3)
{
  CFTypeID v6;
  const __CFArray *OidDataFromString;
  const __CFData *v8;
  CFTypeID v9;

  if (a1)
  {
    if (!*(_BYTE *)a3)
    {
      v6 = CFGetTypeID(a1);
      if (v6 == CFStringGetTypeID())
      {
        OidDataFromString = SecCertificateCreateOidDataFromString(0, a1);
        if (OidDataFromString)
        {
          v8 = OidDataFromString;
          v9 = CFGetTypeID(OidDataFromString);
          if (v9 == CFDataGetTypeID() && cert_contains_marker_extension_value(*(_QWORD *)(a3 + 8), v8, a2))
            *(_BYTE *)a3 = 1;
          CFRelease(v8);
        }
      }
    }
  }
}

BOOL SecPolicyCheckCertLeafMarkerOid(uint64_t a1, const __CFString *a2)
{
  return a2 && (SecCertificateHasMarkerExtension(a1, a2) & 1) != 0;
}

uint64_t SecCertificateHasMarkerExtension(uint64_t a1, const __CFString *a2)
{
  uint64_t result;
  CFTypeID v5;
  CFIndex Count;
  CFIndex v7;
  CFIndex v8;
  const void *ValueAtIndex;
  CFTypeID v11;
  CFTypeID v12;
  CFTypeID v13;
  const void *v14;
  _BOOL8 v15;
  _QWORD v16[2];

  result = 0;
  if (!a1 || !a2)
    return result;
  v5 = CFGetTypeID(a2);
  if (v5 == CFArrayGetTypeID())
  {
    Count = CFArrayGetCount((CFArrayRef)a2);
    v7 = Count - 1;
    if (Count >= 1)
    {
      v8 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v8);
        result = SecCertificateHasMarkerExtension(a1, ValueAtIndex);
        if ((result & 1) != 0)
          break;
      }
      while (v7 != v8++);
      return result;
    }
    return 0;
  }
  v11 = CFGetTypeID(a2);
  if (v11 == CFDictionaryGetTypeID())
  {
    v16[0] = 0xAAAAAAAAAAAAAA00;
    v16[1] = a1;
    CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)check_for_marker, v16);
    return LOBYTE(v16[0]) != 0;
  }
  v12 = CFGetTypeID(a2);
  if (v12 == CFDataGetTypeID())
    return cert_contains_marker_extension_value(a1, (CFDataRef)a2, 0);
  v13 = CFGetTypeID(a2);
  if (v13 != CFStringGetTypeID())
    return 0;
  result = (uint64_t)SecCertificateCreateOidDataFromString(0, a2);
  if (result)
  {
    v14 = (const void *)result;
    v15 = cert_contains_marker_extension_value(a1, (CFDataRef)result, 0);
    CFRelease(v14);
    return v15;
  }
  return result;
}

BOOL cert_contains_marker_extension_value(uint64_t a1, CFDataRef theData, const __CFString *a3)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *i;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _BOOL8 v16;
  CFTypeID v17;
  const __CFString *v18;
  CFTypeID v19;
  CFTypeID v20;
  CFTypeID v21;
  int v22;
  int v24;
  SInt32 valuePtr;
  unint64_t v26[3];
  _QWORD v27[2];

  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (Length < 0)
    return 0;
  v8 = *(_QWORD *)(a1 + 512);
  if (v8 < 1)
    return 0;
  v9 = Length;
  v10 = 0;
  v11 = *(_QWORD *)(a1 + 520);
  for (i = (_QWORD *)(v11 + 8); *i != v9 || memcmp((const void *)*(i - 1), BytePtr, v9); i += 5)
  {
    if (v8 == ++v10)
      return 0;
  }
  v13 = v11 + 40 * v10;
  v15 = *(_QWORD *)(v13 + 24);
  v14 = *(_QWORD *)(v13 + 32);
  v27[0] = v15;
  v27[1] = v14;
  if (v14 < 2)
    return 0;
  memset(v26, 170, sizeof(v26));
  DERDecodeItem((uint64_t)v27, v26);
  if ((v26[2] & 0x8000000000000000) != 0)
    return 0;
  if ((uint64_t)v26[0] > 4)
  {
    if (v26[0] != 22 && v26[0] != 12)
    {
      if (v26[0] == 5)
        return ((unint64_t)a3 | v26[2]) == 0;
      return 0;
    }
    if (!a3)
      return 0;
    v19 = CFGetTypeID(a3);
    if (v19 != CFStringGetTypeID())
      return 0;
    v18 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v26[1], v26[2], 0x8000100u, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    v16 = CFStringCompare(a3, v18, 0) == kCFCompareEqualTo;
    if (!v18)
      return v16;
LABEL_24:
    CFRelease(v18);
    return v16;
  }
  if (v26[0] != 2)
  {
    if (v26[0] != 4)
      return 0;
    if (!a3)
      return 0;
    v17 = CFGetTypeID(a3);
    if (v17 != CFDataGetTypeID())
      return 0;
    v18 = (const __CFString *)CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v26[1], v26[2], (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    v16 = CFEqual(a3, v18) != 0;
    if (!v18)
      return v16;
    goto LABEL_24;
  }
  valuePtr = 0;
  if (a3)
  {
    v20 = CFGetTypeID(a3);
    if (v20 == CFStringGetTypeID())
    {
      valuePtr = CFStringGetIntValue(a3);
    }
    else
    {
      v21 = CFGetTypeID(a3);
      if (v21 == CFNumberGetTypeID())
        CFNumberGetValue((CFNumberRef)a3, kCFNumberSInt32Type, &valuePtr);
    }
  }
  v24 = 0;
  v22 = DERParseInteger((char **)&v26[1], &v24);
  v16 = valuePtr == v24;
  if (v22)
    return 0;
  return v16;
}

BOOL SecPolicyCheckCertExtendedKeyUsageFiltered(uint64_t a1, const __CFString *a2, char a3)
{
  __CFArray *v5;
  CFTypeID v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  BOOL v10;
  const __CFString *ValueAtIndex;

  v5 = SecCertificateCopyExtendedKeyUsage(a1);
  if (!a2)
    goto LABEL_8;
  v6 = CFGetTypeID(a2);
  if (v6 != CFArrayGetTypeID())
  {
    v10 = isExtendedKeyUsageAllowed(v5, a2, a3);
    if (!v5)
      return v10;
    goto LABEL_10;
  }
  Count = CFArrayGetCount((CFArrayRef)a2);
  if (Count >= 1)
  {
    v8 = Count;
    v9 = 0;
    v10 = 1;
    do
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a2, v9);
      if (isExtendedKeyUsageAllowed(v5, ValueAtIndex, a3))
        break;
      v10 = ++v9 < v8;
    }
    while (v8 != v9);
  }
  else
  {
LABEL_8:
    v10 = 0;
  }
  if (v5)
LABEL_10:
    CFRelease(v5);
  return v10;
}

BOOL isExtendedKeyUsageAllowed(const __CFArray *a1, const __CFString *cf, char a3)
{
  CFTypeID v6;
  CFTypeID v8;
  const __CFArray *OidDataFromString;
  const __CFArray *v10;
  _BOOL8 v11;

  if (!cf)
    return 0;
  v6 = CFGetTypeID(cf);
  if (v6 == CFDataGetTypeID())
    return extendedkeyusage_allows(a1, (CFDataRef)cf, a3);
  v8 = CFGetTypeID(cf);
  if (v8 != CFStringGetTypeID())
    return 0;
  OidDataFromString = SecCertificateCreateOidDataFromString(0, cf);
  if (!OidDataFromString)
    return 0;
  v10 = OidDataFromString;
  v11 = extendedkeyusage_allows(a1, OidDataFromString, a3);
  CFRelease(v10);
  return v11;
}

BOOL extendedkeyusage_allows(CFArrayRef theArray, CFDataRef theData, char a3)
{
  CFDataRef v6;
  CFDataRef v7;
  int v8;
  BOOL v9;
  CFRange v10;

  if ((a3 & 1) != 0)
  {
    if (!theArray)
      return CFDataGetLength(theData) == 0;
    goto LABEL_12;
  }
  v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], _oidAnyExtendedKeyUsage, 4);
  if (v6)
  {
    v7 = v6;
    v8 = CFEqual(theData, v6);
    CFRelease(v7);
    if (v8)
      v9 = 1;
    else
      v9 = theArray == 0;
    if (!v9)
      goto LABEL_12;
    return 0;
  }
  if (!theArray)
    return 0;
LABEL_12:
  v10.length = CFArrayGetCount(theArray);
  v10.location = 0;
  return CFArrayContainsValue(theArray, v10, theData) != 0;
}

__CFArray *SecCertificateCopyExtendedKeyUsage(uint64_t a1)
{
  const __CFAllocator *v2;
  CFMutableArrayRef Mutable;
  __CFArray *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  int v10;
  CFDataRef v11;
  CFDataRef v12;
  unint64_t v14[3];
  unint64_t v15[3];

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v4 = Mutable;
  if (!a1 || !Mutable)
    goto LABEL_8;
  v5 = *(_QWORD *)(a1 + 512);
  if (v5 < 1)
    goto LABEL_9;
  v6 = 0;
  v7 = *(_QWORD *)(a1 + 520);
  v8 = (_QWORD *)(v7 + 8);
  while (*v8 != 3 || memcmp((const void *)*(v8 - 1), &_oidExtendedKeyUsage, 3uLL))
  {
    ++v6;
    v8 += 5;
    if (v5 == v6)
      goto LABEL_8;
  }
  memset(v15, 170, sizeof(v15));
  if (DERDecodeSeqInit(v7 + 40 * v6 + 24, &v15[2], v15) || v15[2] != 0x2000000000000010)
    goto LABEL_8;
  memset(v14, 170, sizeof(v14));
  while (1)
  {
    v10 = DERDecodeSeqNext(v15, v14);
    if (v10)
      break;
    if (v14[0] != 6)
      goto LABEL_8;
    if (v14[2] > 0x7FFFFFFFFFFFFFFELL)
      goto LABEL_8;
    v11 = CFDataCreate(v2, (const UInt8 *)v14[1], v14[2]);
    if (!v11)
      goto LABEL_8;
    v12 = v11;
    CFArrayAppendValue(v4, v11);
    CFRelease(v12);
  }
  if (v10 != 1)
  {
LABEL_8:
    if (!v4)
      return v4;
LABEL_9:
    CFRelease(v4);
    return 0;
  }
  return v4;
}

const __CFArray *SecCertificateCreateOidDataFromString(const __CFAllocator *a1, CFStringRef theString)
{
  const __CFArray *result;
  const __CFArray *v5;
  CFIndex Count;
  uint64_t v7;
  __CFData *Mutable;
  const __CFString *ValueAtIndex;
  char v10;
  const __CFString *v11;
  CFIndex v12;
  const __CFString *v13;
  int32x4_t v14;
  unint64_t v15;
  int16x8_t v16;
  unint64_t v17;
  int v18;
  unsigned __int32 v19;
  char v20;
  UInt8 bytes;
  SInt32 v22;

  if (!theString)
    return 0;
  if (!SecCertificateIsOidString(theString))
    return 0;
  result = CFStringCreateArrayBySeparatingStrings(a1, theString, CFSTR("."));
  if (!result)
    return result;
  v5 = result;
  Count = CFArrayGetCount(result);
  v7 = Count;
  if (!Count)
    goto LABEL_25;
  Mutable = CFDataCreateMutable(a1, 5 * Count - 9);
  v22 = -1431655766;
  bytes = -86;
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v5, 0);
  if (GetDecimalValueOfString(ValueAtIndex, &v22) && v22 <= 6)
  {
    v10 = 40 * v22;
    bytes = 40 * v22;
    if (v7 <= 1)
    {
      CFDataAppendBytes(Mutable, &bytes, 1);
LABEL_24:
      v7 = (uint64_t)Mutable;
      goto LABEL_25;
    }
    v11 = (const __CFString *)CFArrayGetValueAtIndex(v5, 1);
    if (GetDecimalValueOfString(v11, &v22) && v22 <= 39)
    {
      bytes = v10 + v22;
      CFDataAppendBytes(Mutable, &bytes, 1);
      if ((unint64_t)v7 >= 3)
      {
        v12 = 2;
        while (1)
        {
          v13 = (const __CFString *)CFArrayGetValueAtIndex(v5, v12);
          if (!GetDecimalValueOfString(v13, &v22))
            break;
          v15 = 0;
          v20 = v22 & 0x7F;
          v14.i32[0] = v22;
          v16 = (int16x8_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v22), (uint32x4_t)xmmword_18AA61B40);
          v16.i32[0] = vshlq_s32(v14, (int32x4_t)xmmword_18AA61B40).u32[0];
          v16.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v16) | 0x80008000800080;
          v19 = vmovn_s16(v16).u32[0];
          do
          {
            v17 = v15;
            v18 = *((unsigned __int8 *)&v19 + v15++);
          }
          while (v18 == 128);
          if (v17 > 5 || 5 - v17 > 0x7FFFFFFFFFFFFFFELL)
            goto LABEL_21;
          CFDataAppendBytes(Mutable, (const UInt8 *)&v19 + v17, 5 - v17);
          if (++v12 == v7)
            goto LABEL_24;
        }
      }
      goto LABEL_24;
    }
  }
LABEL_21:
  CFRelease(v5);
  v7 = 0;
  result = 0;
  v5 = Mutable;
  if (Mutable)
  {
LABEL_25:
    CFRelease(v5);
    return (const __CFArray *)v7;
  }
  return result;
}

uint64_t GetDecimalValueOfString(const __CFString *a1, SInt32 *a2)
{
  const __CFCharacterSet *Predefined;
  CFCharacterSetRef InvertedSet;
  uint64_t v6;
  CFRange v8;

  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  InvertedSet = CFCharacterSetCreateInvertedSet(0, Predefined);
  if (CFStringGetLength(a1) < 1
    || (v8.length = CFStringGetLength(a1),
        v8.location = 0,
        CFStringFindCharacterFromSet(a1, InvertedSet, v8, 0x200uLL, 0)))
  {
    v6 = 0;
    if (InvertedSet)
LABEL_4:
      CFRelease(InvertedSet);
  }
  else
  {
    if (a2)
      *a2 = CFStringGetIntValue(a1);
    v6 = 1;
    if (InvertedSet)
      goto LABEL_4;
  }
  return v6;
}

const __CFString *SecCertificateIsOidString(CFStringRef theString)
{
  const __CFString *v1;
  const __CFCharacterSet *v2;
  const __CFCharacterSet *InvertedSet;
  int CharacterFromSet;
  UniChar buffer[2];
  CFRange v7;
  CFRange v8;

  v1 = theString;
  if (theString)
  {
    if (CFStringGetLength(theString) >= 3)
    {
      v2 = CFCharacterSetCreateWithCharactersInString(0, CFSTR("0123456789."));
      InvertedSet = CFCharacterSetCreateInvertedSet(0, v2);
      v8.length = CFStringGetLength(v1);
      v8.location = 0;
      CharacterFromSet = CFStringFindCharacterFromSet(v1, InvertedSet, v8, 0x200uLL, 0);
      *(_DWORD *)buffer = -1431655766;
      v7.location = 0;
      v7.length = 2;
      CFStringGetCharacters(v1, v7, buffer);
      if (buffer[1] != 46
        || (v1 = (const __CFString *)(CharacterFromSet == 0), buffer[0] - 51 <= 0xFFFFFFFC))
      {
        v1 = 0;
      }
      if (v2)
        CFRelease(v2);
      if (InvertedSet)
        CFRelease(InvertedSet);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

void sec_release(void *obj)
{
  if (obj)
    os_release(obj);
}

uint64_t __sec_protocol_metadata_access_peer_certificate_chain_block_invoke_2(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return 1;
}

uint64_t SecCertificateGetOCSPResponders(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 472);
  return result;
}

sec_certificate_t sec_certificate_create(SecCertificateRef certificate)
{
  return (sec_certificate_t)-[SecConcrete_sec_certificate initWithCertificate:]([SecConcrete_sec_certificate alloc], "initWithCertificate:", certificate);
}

uint64_t SecCertificateGetPolicyMappings(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 328))
    return a1 + 328;
  else
    return 0;
}

uint64_t SecCertificateGetInhibitAnyPolicySkipCerts(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 376))
    return a1 + 376;
  else
    return 0;
}

void sec_array_append(void *a1, void *a2)
{
  id v3;
  uint64_t v4;
  id v5;
  _QWORD *v6;

  v6 = a1;
  v3 = a2;
  if (v6)
  {
    if (v6[1])
    {
      v4 = MEMORY[0x18D7718B8]();
      if (v3)
      {
        if (v4 == MEMORY[0x1E0C812C8])
        {
          v5 = v3;
          xpc_array_set_pointer();
        }
      }
    }
  }

}

uint64_t SecCertificateGetSignatureHashAlgorithm(uint64_t a1)
{
  if (a1)
    return SecSignatureHashAlgorithmForAlgorithmOid((_QWORD *)(a1 + 120));
  else
    return SecSignatureHashAlgorithmForAlgorithmOid(0);
}

void sec_protocol_options_add_tls_ciphersuite_group(sec_protocol_options_t options, SSLCiphersuiteGroup group)
{
  uint64_t v2;
  uint64_t v3;
  __int16 v4;
  uint64_t v5;
  uint64_t v6;
  BOOL (*v7)(uint64_t, uint64_t);
  void *v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v10 = v2;
  v11 = v3;
  switch(group)
  {
    case kSSLCiphersuiteGroupDefault:
      if (options)
      {
        v5 = MEMORY[0x1E0C809B0];
        v6 = 0x40000000;
        v7 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
        v8 = &__block_descriptor_tmp_11;
        v9 = 0;
        goto LABEL_13;
      }
      break;
    case kSSLCiphersuiteGroupCompatibility:
      if (options)
      {
        v5 = MEMORY[0x1E0C809B0];
        v6 = 0x40000000;
        v7 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
        v8 = &__block_descriptor_tmp_11;
        v4 = 1;
        goto LABEL_12;
      }
      break;
    case kSSLCiphersuiteGroupLegacy:
      if (options)
      {
        v5 = MEMORY[0x1E0C809B0];
        v6 = 0x40000000;
        v7 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
        v8 = &__block_descriptor_tmp_11;
        v4 = 2;
        goto LABEL_12;
      }
      break;
    case kSSLCiphersuiteGroupATS:
      if (options)
      {
        v5 = MEMORY[0x1E0C809B0];
        v6 = 0x40000000;
        v7 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
        v8 = &__block_descriptor_tmp_11;
        v4 = 3;
        goto LABEL_12;
      }
      break;
    case kSSLCiphersuiteGroupATSCompatibility:
      if (options)
      {
        v5 = MEMORY[0x1E0C809B0];
        v6 = 0x40000000;
        v7 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
        v8 = &__block_descriptor_tmp_11;
        v4 = 4;
LABEL_12:
        v9 = v4;
LABEL_13:
        sec_protocol_options_access_handle((uint64_t)options, (uint64_t)&v5);
      }
      break;
    default:
      return;
  }
}

uint64_t SecPolicyCheckCertNonEmptySubject(uint64_t a1)
{
  uint64_t v3;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 192))
      return 1;
    if ((SecCertificateIsCA(a1) & 1) == 0)
    {
      v3 = *(_QWORD *)(a1 + 456);
      if (v3)
      {
        if (*(_BYTE *)(v3 + 16))
          return 1;
      }
    }
  }
  else
  {
    SecCertificateIsCA(0);
  }
  return 0;
}

_QWORD *SecCertificateIsCA(uint64_t a1)
{
  _QWORD *result;

  result = SecCertificateIsCertificate((_QWORD *)a1);
  if ((_DWORD)result)
  {
    if (*(unsigned __int8 *)(a1 + 96) < 2u)
    {
      return (_QWORD *)_SecCertificateIsSelfSigned(a1);
    }
    else if (*(_BYTE *)(a1 + 300))
    {
      return (_QWORD *)(*(_BYTE *)(a1 + 302) != 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

__CFData *SecCertificateCopyPublicKeySHA1Digest(_QWORD *cf)
{
  const __CFAllocator *v2;

  if (!cf || !cf[31] || (cf[32] & 0x8000000000000000) != 0)
    return 0;
  v2 = CFGetAllocator(cf);
  return SecSHA1DigestCreate(v2, cf[31], cf[32]);
}

const void *SecAccessControlGetProtection(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("prot"));
}

CFDataRef SecCertificateCopySerialNumberData(SecCertificateRef certificate, CFErrorRef *error)
{
  CFDataRef result;
  __CFError *v5;

  if (certificate)
  {
    result = (CFDataRef)*((_QWORD *)certificate + 71);
    if (result)
    {
      CFRetain(result);
      return (CFDataRef)*((_QWORD *)certificate + 71);
    }
  }
  else if (error)
  {
    v5 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -26275, 0);
    result = 0;
    *error = v5;
  }
  else
  {
    return 0;
  }
  return result;
}

__CFData *SecDigestCreate(const __CFAllocator *a1, SecAsn1Oid *oid1, uint64_t a3, uint64_t a4, unint64_t a5)
{
  __CFData *Mutable;
  void (*v10)(uint64_t, unint64_t, UInt8 *);
  CFIndex v11;
  UInt8 *MutableBytePtr;

  Mutable = 0;
  if (a4 && !(a5 >> 31))
  {
    if (SecAsn1OidCompare(oid1, &CSSMOID_SHA1))
    {
      v10 = (void (*)(uint64_t, unint64_t, UInt8 *))MEMORY[0x1E0C80328];
      v11 = 20;
    }
    else if (SecAsn1OidCompare(oid1, &CSSMOID_SHA224))
    {
      v10 = (void (*)(uint64_t, unint64_t, UInt8 *))MEMORY[0x1E0C80348];
      v11 = 28;
    }
    else if (SecAsn1OidCompare(oid1, &CSSMOID_SHA256))
    {
      v10 = (void (*)(uint64_t, unint64_t, UInt8 *))MEMORY[0x1E0C80368];
      v11 = 32;
    }
    else if (SecAsn1OidCompare(oid1, &CSSMOID_SHA384))
    {
      v10 = (void (*)(uint64_t, unint64_t, UInt8 *))MEMORY[0x1E0C80388];
      v11 = 48;
    }
    else
    {
      if (!SecAsn1OidCompare(oid1, &CSSMOID_SHA512))
        return 0;
      v10 = (void (*)(uint64_t, unint64_t, UInt8 *))MEMORY[0x1E0C803A8];
      v11 = 64;
    }
    Mutable = CFDataCreateMutable(a1, v11);
    CFDataSetLength(Mutable, v11);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v10(a4, a5, MutableBytePtr);
  }
  return Mutable;
}

uint64_t SecKeyDigestAndVerify(uint64_t a1, const SecAsn1Oid *a2, const UInt8 *a3, CFIndex a4, const UInt8 *a5, CFIndex a6)
{
  const SecAsn1Oid *AlgorithmForSecAsn1AlgId;
  _QWORD v13[6];

  AlgorithmForSecAsn1AlgId = SecKeyGetAlgorithmForSecAsn1AlgId(a1, a2, 1u);
  if (!AlgorithmForSecAsn1AlgId)
    return 4294967292;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __SecKeyDigestAndVerify_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  v13[4] = a1;
  v13[5] = AlgorithmForSecAsn1AlgId;
  return SecKeyPerformLegacyOperation(a3, a4, a5, a6, 0, 0, v13);
}

uint64_t SecKeyPerformLegacyOperation(const UInt8 *a1, CFIndex a2, const UInt8 *a3, CFIndex a4, UInt8 *a5, CFIndex *a6, void *a7)
{
  const __CFAllocator *v13;
  uint64_t (**v14)(id, CFDataRef, CFDataRef, CFRange *, CFTypeRef *);
  CFDataRef v15;
  CFDataRef v16;
  const void *v17;
  CFTypeID v18;
  CFTypeID TypeID;
  CFRange v20;
  unsigned int OSStatus;
  uint64_t v22;
  CFRange range;
  CFTypeRef cf;

  cf = 0;
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
  v14 = a7;
  v15 = CFDataCreateWithBytesNoCopy(0, a1, a2, v13);
  v16 = CFDataCreateWithBytesNoCopy(0, a3, a4, v13);
  range = (CFRange)xmmword_18AA61BC0;
  v17 = (const void *)v14[2](v14, v15, v16, &range, &cf);

  if (!v17 || (v18 = CFGetTypeID(v17), TypeID = CFDataGetTypeID(), !a6) || v18 != TypeID)
  {
LABEL_8:
    if (!v15)
      goto LABEL_10;
    goto LABEL_9;
  }
  v20.length = range.length;
  if (range.length == -1)
  {
    v20.length = CFDataGetLength((CFDataRef)v17);
    range.length = v20.length;
  }
  if (v20.length <= (unint64_t)*a6)
  {
    *a6 = v20.length;
    v20.location = range.location;
    CFDataGetBytes((CFDataRef)v17, v20, a5);
    goto LABEL_8;
  }
  SecError(-50, (__CFString **)&cf, CFSTR("buffer too small (required %d, provided %d)"), v20.length, *a6);
  if (v15)
LABEL_9:
    CFRelease(v15);
LABEL_10:
  if (v16)
    CFRelease(v16);
  if (v17)
    CFRelease(v17);
  if (!cf)
    return 0;
  OSStatus = SecErrorGetOSStatus((uint64_t)cf);
  if (OSStatus == -67808)
    v22 = 4294957487;
  else
    v22 = OSStatus;
  CFRelease(cf);
  return v22;
}

const SecAsn1Oid *SecKeyGetAlgorithmForSecAsn1AlgId(uint64_t a1, const SecAsn1Oid *a2, unsigned int a3)
{
  uint64_t AlgorithmId;
  SecAsn1Oid **v6;
  const SecAsn1Oid *result;
  const SecAsn1Oid *v8;
  const SecAsn1Oid *v9;

  AlgorithmId = SecKeyGetAlgorithmId(a1);
  if (AlgorithmId == 1)
  {
    v6 = SecKeyGetAlgorithmForSecAsn1AlgId_translationTableRSA;
  }
  else
  {
    if (AlgorithmId != 3)
      return 0;
    v6 = SecKeyGetAlgorithmForSecAsn1AlgId_translationTableECDSA;
  }
  result = *v6;
  if (*v6)
  {
    while (!SecAsn1OidCompare(result, a2))
    {
      v8 = v6[1];
      if (v8)
      {
        if (SecAsn1OidCompare(v8, a2))
          break;
      }
      v9 = v6[4];
      v6 += 4;
      result = v9;
      if (!v9)
        return result;
    }
    return (const SecAsn1Oid *)v6[a3 + 2]->Length;
  }
  return result;
}

BOOL SecAsn1OidCompare(const SecAsn1Oid *oid1, const SecAsn1Oid *oid2)
{
  if (!oid1 || !oid2)
    return oid1 == oid2;
  if (oid1->Length == oid2->Length)
    return memcmp(oid1->Data, oid2->Data, oid1->Length) == 0;
  return 0;
}

OSStatus SecTrustCreateWithCertificates(CFTypeRef certificates, CFTypeRef policies, SecTrustRef *trust)
{
  const __CFAllocator *v6;
  CFTypeID v7;
  uint64_t Count;
  uint64_t v9;
  CFMutableArrayRef Mutable;
  __CFArray *v11;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v14;
  CFTypeID v15;
  NSObject *v16;
  CFTypeID v17;
  uint64_t v18;
  uint64_t v19;
  CFMutableArrayRef v20;
  __CFArray *v21;
  CFIndex j;
  const void *v23;
  const void *v24;
  CFTypeID v25;
  NSObject *v26;
  OSStatus v27;
  NSObject *v28;
  NSObject *v29;
  dispatch_group_t v30;
  dispatch_group_t v31;
  uint64_t Instance;
  CFTypeID v33;
  NSObject *v34;
  SecTrustRef *v36;
  SecTrustRef *v37;
  uint8_t buf[8];
  void *v39;
  void *values;

  v39 = (void *)policies;
  values = (void *)certificates;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFGetTypeID(certificates);
  if (v7 != CFArrayGetTypeID())
  {
    if (v7 != SecCertificateGetTypeID())
    {
      v28 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v28, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: certificates contains unsupported value type", buf, 2u);
      }
      return -50;
    }
    v11 = CFArrayCreate(v6, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
    if (v11)
      goto LABEL_13;
    return -108;
  }
  Count = CFArrayGetCount((CFArrayRef)certificates);
  if (Count < 1)
    return -50;
  v9 = Count;
  Mutable = CFArrayCreateMutable(v6, Count, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return -108;
  v11 = Mutable;
  v36 = trust;
  for (i = 0; i != v9; ++i)
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)certificates, i);
    if (ValueAtIndex && (v14 = ValueAtIndex, v15 = CFGetTypeID(ValueAtIndex), v15 == SecCertificateGetTypeID()))
    {
      CFArrayAppendValue(v11, v14);
    }
    else
    {
      v16 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: certificates array contains non-certificate value", buf, 2u);
      }
    }
  }
  if (v9 != CFArrayGetCount(v11))
    goto LABEL_43;
  trust = v36;
LABEL_13:
  if (!policies)
  {
    *(_QWORD *)buf = SecPolicyCreateBasicX509();
    v21 = CFArrayCreate(v6, (const void **)buf, 1, MEMORY[0x1E0C9B378]);
    CFRelease(*(CFTypeRef *)buf);
    if (v21)
      goto LABEL_33;
    goto LABEL_40;
  }
  v17 = CFGetTypeID(policies);
  if (v17 != CFArrayGetTypeID())
  {
    v33 = CFGetTypeID(policies);
    if (v33 == SecPolicyGetTypeID())
    {
      v21 = CFArrayCreate(v6, (const void **)&v39, 1, MEMORY[0x1E0C9B378]);
      if (v21)
        goto LABEL_33;
      goto LABEL_40;
    }
    v34 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v34, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: policies contains unsupported value type", buf, 2u);
    }
LABEL_43:
    v27 = -50;
    goto LABEL_44;
  }
  v18 = CFArrayGetCount((CFArrayRef)policies);
  if (v18 < 1)
    goto LABEL_43;
  v19 = v18;
  v20 = CFArrayCreateMutable(v6, v18, MEMORY[0x1E0C9B378]);
  if (!v20)
  {
LABEL_40:
    v27 = -108;
LABEL_44:
    CFRelease(v11);
    return v27;
  }
  v21 = v20;
  v37 = trust;
  for (j = 0; j != v19; ++j)
  {
    v23 = CFArrayGetValueAtIndex((CFArrayRef)policies, j);
    if (v23 && (v24 = v23, v25 = CFGetTypeID(v23), v25 == SecPolicyGetTypeID()))
    {
      CFArrayAppendValue(v21, v24);
    }
    else
    {
      v26 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v26, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: policies array contains non-policy value", buf, 2u);
      }
    }
  }
  if (v19 != CFArrayGetCount(v21))
  {
    CFRelease(v11);
    CFRelease(v21);
    return -50;
  }
  trust = v37;
LABEL_33:
  v29 = dispatch_queue_create("trust", 0);
  v30 = dispatch_group_create();
  v27 = -108;
  if (v29)
  {
    v31 = v30;
    if (v30)
    {
      SecTrustGetTypeID();
      Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        *(_OWORD *)(Instance + 24) = 0u;
        *(_OWORD *)(Instance + 104) = 0u;
        *(_OWORD *)(Instance + 136) = 0u;
        *(_OWORD *)(Instance + 152) = 0u;
        *(_OWORD *)(Instance + 120) = 0u;
        *(_OWORD *)(Instance + 88) = 0u;
        *(_OWORD *)(Instance + 72) = 0u;
        *(_OWORD *)(Instance + 56) = 0u;
        *(_OWORD *)(Instance + 40) = 0u;
        *(_QWORD *)(Instance + 16) = v11;
        *(_QWORD *)(Instance + 32) = v21;
        *(_BYTE *)(Instance + 117) = 1;
        *(_QWORD *)(Instance + 136) = v29;
        *(_QWORD *)(Instance + 168) = v31;
        if (trust)
        {
          v27 = 0;
          *trust = (SecTrustRef)Instance;
        }
        else
        {
          CFRelease((CFTypeRef)Instance);
          return 0;
        }
        return v27;
      }
      v27 = -50;
    }
  }
  CFRelease(v11);
  CFRelease(v21);
  if (v29)
    dispatch_release(v29);
  return v27;
}

uint64_t validate_array_of_items(const __CFArray *a1, uint64_t a2, uint64_t a3, int a4)
{
  char v4;
  CFIndex Count;
  CFIndex v9;
  uint64_t v10;
  CFIndex v11;
  _QWORD *ValueAtIndex;
  _QWORD *v13;
  CFTypeID v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  const void *v20;
  CFTypeID v21;
  NSObject *v22;
  NSObject *v23;
  uint8_t buf[4];
  uint64_t v26;
  __int16 v27;
  const __CFString *v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v4 = a4;
  v31 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    Count = CFArrayGetCount(a1);
    v9 = Count;
    if (Count || (v4 & 1) == 0)
    {
      if (Count >= 1)
      {
        v10 = 0;
        v11 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a1, v11);
          if (!ValueAtIndex)
          {
            v17 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412802;
              v26 = a2;
              v27 = 2112;
              v28 = CFSTR("reference is nil");
              v29 = 1024;
              v30 = v11;
              _os_log_impl(&dword_18A900000, v17, OS_LOG_TYPE_DEFAULT, "%@ %@ (index %d)", buf, 0x1Cu);
            }
            v10 = 4294967246;
            goto LABEL_29;
          }
          v13 = ValueAtIndex;
          v14 = CFGetTypeID(ValueAtIndex);
          if (v14 != a3)
          {
            v15 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412802;
              v26 = a2;
              v27 = 2112;
              v28 = CFSTR("is not the expected CF type");
              v29 = 1024;
              v30 = v11;
              _os_log_impl(&dword_18A900000, v15, OS_LOG_TYPE_DEFAULT, "%@ %@ (index %d)", buf, 0x1Cu);
            }
            v10 = 4294967246;
          }
          if (v14 == SecCertificateGetTypeID())
          {
            v16 = v13[2];
            if (!v13[3])
            {
              v18 = secLogObjForScope("SecError");
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412802;
                v26 = a2;
                v27 = 2112;
                v28 = CFSTR("has zero length");
                v29 = 1024;
                v30 = v11;
                _os_log_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEFAULT, "%@ %@ (index %d)", buf, 0x1Cu);
              }
              v10 = 4294967246;
              if (v16)
                goto LABEL_24;
LABEL_21:
              v19 = secLogObjForScope("SecError");
              if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412802;
                v26 = a2;
                v27 = 2112;
                v28 = CFSTR("has nil bytes");
                v29 = 1024;
                v30 = v11;
                _os_log_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEFAULT, "%@ %@ (index %d)", buf, 0x1Cu);
              }
              v10 = 4294967246;
              goto LABEL_24;
            }
            if (!v16)
              goto LABEL_21;
          }
LABEL_24:
          if (v14 == SecPolicyGetTypeID())
          {
            v20 = (const void *)v13[2];
            if (!v20 || (v21 = CFGetTypeID(v20), v21 != CFStringGetTypeID()))
            {
              v22 = secLogObjForScope("SecError");
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412802;
                v26 = a2;
                v27 = 2112;
                v28 = CFSTR("has invalid OID string!");
                v29 = 1024;
                v30 = v11;
                _os_log_impl(&dword_18A900000, v22, OS_LOG_TYPE_DEFAULT, "%@ %@ (index %d)", buf, 0x1Cu);
              }
            }
          }
LABEL_29:
          if (v9 == ++v11)
            return v10;
        }
      }
      return 0;
    }
  }
  else if (!a4)
  {
    return 0;
  }
  v23 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v26 = a2;
    _os_log_impl(&dword_18A900000, v23, OS_LOG_TYPE_DEFAULT, "no %@ in array!", buf, 0xCu);
  }
  return 4294967246;
}

CFTypeID SecPolicyGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecPolicyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_11105;
  block[4] = &SecPolicyGetTypeID_sSecPolicyGetTypeIDSingleton;
  if (SecPolicyGetTypeID_sSecPolicyGetTypeIDOnce != -1)
    dispatch_once(&SecPolicyGetTypeID_sSecPolicyGetTypeIDOnce, block);
  return SecPolicyGetTypeID_sSecPolicyGetTypeIDSingleton;
}

_QWORD *SecCertificateCreateWithXPCArrayAtIndex(void *a1, size_t a2, __CFString **a3)
{
  const void *data;
  _QWORD *result;
  size_t length;

  length = 0;
  data = xpc_array_get_data(a1, a2, &length);
  if (!data
    || length > 0x7FFFFFFFFFFFFFFELL
    || (result = SecCertificateCreateWithBytes(*MEMORY[0x1E0C9AE00], data, length)) == 0)
  {
    SecError(-50, a3, CFSTR("certificates[%zu] failed to decode"), a2);
    return 0;
  }
  return result;
}

_QWORD *SecCertificateCreateWithBytes(uint64_t a1, const void *a2, int64_t a3)
{
  _QWORD *v3;
  uint64_t Instance;

  v3 = 0;
  if (a2)
  {
    if (a3 >= 1)
    {
      SecCertificateGetTypeID();
      Instance = _CFRuntimeCreateInstance();
      v3 = (_QWORD *)Instance;
      if (Instance)
      {
        bzero((void *)(Instance + 32), 0x258uLL);
        v3[2] = v3 + 79;
        v3[3] = a3;
        memcpy(v3 + 79, a2, a3);
        if ((SecCertificateParse((uint64_t)v3) & 1) == 0)
        {
          CFRelease(v3);
          return 0;
        }
      }
    }
  }
  return v3;
}

uint64_t SecPolicyCheckCertWeakSignature(_QWORD *a1)
{
  __CFArray *Mutable;
  __CFArray *v3;
  unsigned int v4;
  _BOOL4 IsSelfSigned;
  uint64_t v6;
  BOOL v7;
  unsigned int v8;

  Mutable = CFArrayCreateMutable(0, 3, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return 1;
  v3 = Mutable;
  CFArrayAppendValue(Mutable, CFSTR("SignatureDigestMD2"));
  CFArrayAppendValue(v3, CFSTR("SignatureDigestMD4"));
  CFArrayAppendValue(v3, CFSTR("SignatureDigestMD5"));
  v4 = SecCertificateIsCertificate(a1);
  if (v4)
    IsSelfSigned = _SecCertificateIsSelfSigned((uint64_t)a1);
  else
    IsSelfSigned = 0;
  v7 = SecPolicyCheckCertSignatureHashAlgorithms(a1, v3);
  if (IsSelfSigned)
    v8 = v4;
  else
    v8 = 0;
  if (v7)
    v6 = 1;
  else
    v6 = v8;
  CFRelease(v3);
  return v6;
}

BOOL SecPolicyCheckCertSignatureHashAlgorithms(_QWORD *a1, const __CFArray *a2)
{
  _QWORD *v5;
  const void *v6;
  _QWORD v7[11];
  CFRange v8;

  v7[10] = *MEMORY[0x1E0C80C00];
  if (SecCertificateIsCertificate(a1) && _SecCertificateIsSelfSigned((uint64_t)a1))
    return 1;
  if (a1)
    v5 = a1 + 15;
  else
    v5 = 0;
  v7[0] = CFSTR("SignatureDigestUnknown");
  v7[1] = CFSTR("SignatureDigestMD2");
  v7[2] = CFSTR("SignatureDigestMD4");
  v7[3] = CFSTR("SignatureDigestMD5");
  v7[4] = CFSTR("SignatureDigestSHA1");
  v7[5] = CFSTR("SignatureDigestSHA224");
  v7[6] = CFSTR("SignatureDigestSHA256");
  v7[7] = CFSTR("SignatureDigestSHA284");
  v7[8] = CFSTR("SignatureDigestSHA512");
  v7[9] = CFSTR("SignatureDigestSHAKE256");
  v6 = (const void *)v7[SecSignatureHashAlgorithmForAlgorithmOid(v5)];
  v8.length = CFArrayGetCount(a2);
  v8.location = 0;
  return CFArrayContainsValue(a2, v8, v6) == 0;
}

uint64_t SecCertificateIsSelfSigned(_QWORD *a1, BOOL *a2)
{
  BOOL IsSelfSigned;
  uint64_t result;

  if (!SecCertificateIsCertificate(a1))
    return 4294941021;
  if (!a2)
    return 4294967246;
  IsSelfSigned = _SecCertificateIsSelfSigned((uint64_t)a1);
  result = 0;
  *a2 = IsSelfSigned;
  return result;
}

CFTypeID SecCertificateGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecCertificateGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_37_7451;
  block[4] = &SecCertificateGetTypeID_sSecCertificateGetTypeIDSingleton;
  if (SecCertificateGetTypeID_sSecCertificateGetTypeIDOnce != -1)
    dispatch_once(&SecCertificateGetTypeID_sSecCertificateGetTypeIDOnce, block);
  return SecCertificateGetTypeID_sSecCertificateGetTypeIDSingleton;
}

BOOL _SecCertificateIsSelfSigned(uint64_t a1)
{
  SecKeyRef v2;
  __SecKey *v3;
  const void *v4;
  const void *v5;
  CFDataRef AuthorityKeyID;
  CFDataRef SubjectKeyID;

  if (!*(_BYTE *)(a1 + 624))
  {
    *(_BYTE *)(a1 + 624) = 1;
    if (SecCertificateIsCertificate((_QWORD *)a1))
    {
      v2 = SecCertificateCopyKey((SecCertificateRef)a1);
      if (v2)
      {
        v3 = v2;
        v4 = *(const void **)(a1 + 576);
        if (v4)
        {
          v5 = *(const void **)(a1 + 584);
          if (v5)
          {
            if (CFEqual(v4, v5))
            {
              AuthorityKeyID = SecCertificateGetAuthorityKeyID((CFDataRef)a1);
              SubjectKeyID = SecCertificateGetSubjectKeyID((CFDataRef)a1);
              if ((!AuthorityKeyID || SubjectKeyID && CFEqual(SubjectKeyID, AuthorityKeyID))
                && !SecCertificateIsSignedBy((_QWORD *)a1, v3))
              {
                *(_BYTE *)(a1 + 624) = 2;
              }
            }
          }
        }
        CFRelease(v3);
      }
    }
  }
  return *(_BYTE *)(a1 + 624) == 2;
}

CFDataRef SecCertificateGetSubjectKeyID(CFDataRef result)
{
  CFDataRef v1;
  CFIndex v2;

  if (result)
  {
    v1 = result;
    result = (CFDataRef)*((_QWORD *)result + 75);
    if (!result)
    {
      v2 = *((_QWORD *)v1 + 50);
      if ((unint64_t)(v2 - 1) > 0x7FFFFFFFFFFFFFFDLL)
      {
        return 0;
      }
      else
      {
        result = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *((const UInt8 **)v1 + 49), v2);
        *((_QWORD *)v1 + 75) = result;
      }
    }
  }
  return result;
}

CFDataRef SecCertificateGetAuthorityKeyID(CFDataRef result)
{
  CFDataRef v1;
  CFIndex v2;

  if (result)
  {
    v1 = result;
    result = (CFDataRef)*((_QWORD *)result + 74);
    if (!result)
    {
      v2 = *((_QWORD *)v1 + 52);
      if ((unint64_t)(v2 - 1) > 0x7FFFFFFFFFFFFFFDLL)
      {
        return 0;
      }
      else
      {
        result = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *((const UInt8 **)v1 + 51), v2);
        *((_QWORD *)v1 + 74) = result;
      }
    }
  }
  return result;
}

uint64_t SecCertificateIsSignedBy(_QWORD *a1, __SecKey *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  const UInt8 *v8;
  const UInt8 *v9;
  const __CFString *v10;
  char v11;
  NSObject *v12;
  CFDataRef v14;
  const __CFData *v15;
  const __CFData *v16;
  __CFData *v17;
  const __CFData *v18;
  CFErrorRef v19;
  int v20;
  CFDataRef v21;
  CFErrorRef v22;
  void *v23;
  CFErrorRef error;
  uint8_t buf[8];
  uint64_t v26;
  void *userInfoKeys[2];

  userInfoKeys[1] = *(void **)MEMORY[0x1E0C80C00];
  v4 = (uint64_t)(a1 + 15);
  if (!DEROidCompare((uint64_t)(a1 + 6), (uint64_t)(a1 + 15)))
  {
    v12 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEFAULT, "Signature algorithm mismatch in certificate (see RFC5280 4.1.1.2)", buf, 2u);
    }
    return 4294941029;
  }
  error = 0;
  v5 = a1[5];
  v6 = a1[11];
  if (v5 > 0x7FFFFFFFFFFFFFFELL || v6 > 0x7FFFFFFFFFFFFFFELL)
  {
LABEL_63:
    v22 = error;
    if (error
      || (v23 = (void *)*MEMORY[0x1E0C9AFB0],
          v26 = 0,
          userInfoKeys[0] = v23,
          *(_QWORD *)buf = CFSTR("Unable to verify signature"),
          v22 = CFErrorCreateWithUserInfoKeysAndValues((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -50, (const void *const *)userInfoKeys, (const void *const *)buf, 1), (error = v22) != 0))
    {
      CFRelease(v22);
    }
    return 4294941029;
  }
  v8 = (const UInt8 *)a1[4];
  v9 = (const UInt8 *)a1[10];
  v10 = 0;
  v11 = 1;
  switch(SecKeyGetAlgorithmId((uint64_t)a2))
  {
    case 1:
      if (DEROidCompare(v4, (uint64_t)&oidMd5Rsa) || DEROidCompare(v4, (uint64_t)&oidMd5))
      {
        v11 = 0;
        v10 = CFSTR("algid:sign:RSA:message-PKCS1v15:MD5");
      }
      else if (DEROidCompare(v4, (uint64_t)&oidSha1Rsa) || DEROidCompare(v4, (uint64_t)&oidSha1))
      {
        v11 = 0;
        v10 = CFSTR("algid:sign:RSA:message-PKCS1v15:SHA1");
      }
      else if (DEROidCompare(v4, (uint64_t)&oidSha224Rsa) || DEROidCompare(v4, (uint64_t)&oidSha224))
      {
        v11 = 0;
        v10 = CFSTR("algid:sign:RSA:message-PKCS1v15:SHA224");
      }
      else if (DEROidCompare(v4, (uint64_t)&oidSha256Rsa) || DEROidCompare(v4, (uint64_t)&oidSha256))
      {
        v11 = 0;
        v10 = CFSTR("algid:sign:RSA:message-PKCS1v15:SHA256");
      }
      else if (DEROidCompare(v4, (uint64_t)&oidSha384Rsa) || DEROidCompare(v4, (uint64_t)&oidSha384))
      {
        v11 = 0;
        v10 = CFSTR("algid:sign:RSA:message-PKCS1v15:SHA384");
      }
      else
      {
        if (!DEROidCompare(v4, (uint64_t)&oidSha512Rsa) && !DEROidCompare(v4, (uint64_t)&oidSha512))
          goto LABEL_60;
        v11 = 0;
        v10 = CFSTR("algid:sign:RSA:message-PKCS1v15:SHA512");
      }
      break;
    case 3:
      if (DEROidCompare(v4, (uint64_t)&oidSha1Ecdsa) || DEROidCompare(v4, (uint64_t)&oidSha1))
      {
        v11 = 0;
        v10 = CFSTR("algid:sign:ECDSA:message-X962:SHA1");
      }
      else if (DEROidCompare(v4, (uint64_t)&oidSha224Ecdsa) || DEROidCompare(v4, (uint64_t)&oidSha224))
      {
        v11 = 0;
        v10 = CFSTR("algid:sign:ECDSA:message-X962:SHA224");
      }
      else if (DEROidCompare(v4, (uint64_t)&oidSha256Ecdsa) || DEROidCompare(v4, (uint64_t)&oidSha256))
      {
        v11 = 0;
        v10 = CFSTR("algid:sign:ECDSA:message-X962:SHA256");
      }
      else if (DEROidCompare(v4, (uint64_t)&oidSha384Ecdsa) || DEROidCompare(v4, (uint64_t)&oidSha384))
      {
        v11 = 0;
        v10 = CFSTR("algid:sign:ECDSA:message-X962:SHA384");
      }
      else if (DEROidCompare(v4, (uint64_t)&oidSha512Ecdsa) || DEROidCompare(v4, (uint64_t)&oidSha512))
      {
        v11 = 0;
        v10 = CFSTR("algid:sign:ECDSA:message-X962:SHA512");
      }
      else
      {
LABEL_60:
        v10 = 0;
      }
      break;
    case 4:
      v11 = 0;
      v10 = CFSTR("algid:sign:EdDSA:message-Curve25519:SHA512");
      break;
    case 6:
      v11 = 0;
      v10 = CFSTR("algid:sign:EdDSA:message-Curve448:SHAKE256");
      break;
    default:
      break;
  }
  v14 = CFDataCreate(0, v8, v5);
  v15 = CFDataCreate(0, v9, v6);
  v16 = v15;
  if ((v11 & 1) != 0 || !v14 || !v15)
  {
    if (v14)
      CFRelease(v14);
    if (!v16)
      goto LABEL_63;
    v21 = v16;
    goto LABEL_62;
  }
  if (!SecKeyVerifySignature(a2, v10, v14, v15, &error))
  {
    CFRelease(v16);
    v17 = SecRecreateSignatureWithDERAlgorithmId((uint64_t)a2, v4, (uint64_t)v9, v6);
    if (v17)
    {
      v18 = v17;
      v19 = error;
      if (error)
      {
        error = 0;
        CFRelease(v19);
      }
      v20 = SecKeyVerifySignature(a2, v10, v14, v18, &error);
      CFRelease(v14);
      CFRelease(v18);
      if (v20)
        return 0;
      goto LABEL_63;
    }
    v21 = v14;
LABEL_62:
    CFRelease(v21);
    goto LABEL_63;
  }
  CFRelease(v14);
  CFRelease(v16);
  return 0;
}

__CFData *SecKeyAlgorithmAdaptorCopyBigEndianToCCUnit(uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  uint64_t v9;
  uint64_t (*v10)(uint64_t);
  unint64_t v11;
  uint64_t v12;
  _QWORD v13[8];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  if (a1[3] == 1)
    return SecKeyRunAlgorithmAndCopyResult(a1, 0, 0, a4);
  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 0;
  v9 = *a1;
  _SecKeyCheck(*a1, (uint64_t)"SecKeyGetBlockSize");
  v10 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 16) + 80);
  if (v10)
    v11 = v10(v9);
  else
    v11 = 0;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __SecKeyAlgorithmAdaptorCopyBigEndianToCCUnit_block_invoke;
  v13[3] = &unk_1E1FD8218;
  v13[4] = &v14;
  v13[5] = a1;
  v13[6] = a3;
  v13[7] = a4;
  PerformWithBigEndianToCCUnit(a2, v11, v13);
  v12 = v15[3];
  _Block_object_dispose(&v14, 8);
  return (__CFData *)v12;
}

void sub_18A909500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void PerformWithBigEndianToCCUnit(const __CFData *a1, unint64_t a2, void *a3)
{
  id v5;
  void *v6;
  unint64_t Length;
  unint64_t v8;
  size_t v9;
  _QWORD v10[4];
  id v11;
  unint64_t v12;
  unint64_t v13;
  const __CFData *v14;

  v5 = a3;
  v6 = v5;
  if (a1)
  {
    Length = CFDataGetLength(a1);
    if (Length <= a2)
      v8 = a2;
    else
      v8 = Length;
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 3221225472;
    v9 = (v8 + 7) & 0xFFFFFFFFFFFFFFF8;
    v10[2] = __PerformWithBigEndianToCCUnit_block_invoke;
    v10[3] = &unk_1E1FD8240;
    v12 = v8;
    v13 = Length;
    v14 = a1;
    v11 = v6;
    PerformWithCFDataBuffer(v9, v10);

  }
  else
  {
    (*((void (**)(id, _QWORD))v5 + 2))(v5, 0);
  }

}

__CFData *SecKeyCopyDigestForMessage(uint64_t *a1, uint64_t a2, uint64_t a3, size_t *a4, __CFString **a5)
{
  size_t v6;
  uint64_t v7;
  _QWORD v8[10];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  unint64_t v12;

  if (a1[3] == 1)
    return SecKeyRunAlgorithmAndCopyResult(a1, 0, 0, a5);
  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v12 = 0xAAAAAAAAAAAAAAAALL;
  v6 = *a4;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = __SecKeyCopyDigestForMessage_block_invoke;
  v8[3] = &unk_1E1FD8290;
  v8[4] = &v9;
  v8[5] = a4;
  v8[6] = a2;
  v8[7] = a1;
  v8[8] = a3;
  v8[9] = a5;
  PerformWithCFDataBuffer(v6, v8);
  v7 = v10[3];
  _Block_object_dispose(&v9, 8);
  return (__CFData *)v7;
}

void PerformWithCFDataBuffer(size_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  id v5;
  _QWORD v6[4];
  id v7;
  _QWORD v8[5];

  v3 = a2;
  v4 = MEMORY[0x1E0C809B0];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __PerformWithCFDataBuffer_block_invoke;
  v6[3] = &unk_1E1FD81F0;
  v7 = v3;
  v5 = v3;
  v8[0] = v4;
  v8[1] = 0x40000000;
  v8[2] = __PerformWithBufferAndClear_block_invoke;
  v8[3] = &unk_1E1FDC2B8;
  v8[4] = v6;
  PerformWithBuffer(a1, (uint64_t)v8);

}

void PerformWithBuffer(size_t size, uint64_t a2)
{
  void *v4;
  _QWORD v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  if (size)
  {
    if (size > 0x800)
    {
      v4 = malloc_type_malloc(size, 0x9C1A2F70uLL);
      (*(void (**)(uint64_t, size_t, void *))(a2 + 16))(a2, size, v4);
      if (v4)
        free(v4);
    }
    else
    {
      MEMORY[0x1E0C80A78]();
      memset((char *)v5 - ((size + 15) & 0xFFFFFFFFFFFFFFF0), 170, size);
      (*(void (**)(uint64_t, size_t, char *))(a2 + 16))(a2, size, (char *)v5 - ((size + 15) & 0xFFFFFFFFFFFFFFF0));
    }
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD, _QWORD))(a2 + 16))(a2, 0, 0);
  }
}

Boolean SecKeyVerifySignature(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef signedData, CFDataRef signature, CFErrorRef *error)
{
  void *v10;
  NSObject *v11;
  __CFArray *Mutable;
  __CFData *v13;
  __CFData *v14;
  __CFData *v15;
  _BOOL8 v16;
  CFTypeRef v17;
  uint64_t v19[2];
  CFTypeRef cf;
  uint64_t v21;
  __CFString *v22;
  os_activity_scope_state_s state;

  v10 = (void *)MEMORY[0x18D770A24]();
  v11 = _os_activity_create(&dword_18A900000, "SecKeyVerifySignature", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v11, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyVerifySignature");
  if (!signedData)
    objc_msgSend(MEMORY[0x1E0C99DA0], "raise:format:", *MEMORY[0x1E0C99778], CFSTR("SecKeyVerifySignature() called with NULL signedData"));
  if (!signature)
    objc_msgSend(MEMORY[0x1E0C99DA0], "raise:format:", *MEMORY[0x1E0C99778], CFSTR("SecKeyVerifySignature() called with NULL signature"));
  v22 = 0;
  v19[0] = (uint64_t)key;
  v19[1] = 1;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue(Mutable, algorithm);
  cf = Mutable;
  v21 = 0;
  v13 = SecKeyRunAlgorithmAndCopyResult(v19, signedData, signature, &v22);
  v14 = v13;
  v15 = (__CFData *)*MEMORY[0x1E0C9AE50];
  if (v13 && v15)
  {
    v16 = CFEqual(v13, v15) != 0;
  }
  else
  {
    v16 = v13 == v15;
    if (!v13)
      goto LABEL_10;
  }
  CFRelease(v14);
LABEL_10:
  v17 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v17);
  }
  _SecKeyErrorPropagate(v16, (uint64_t)"SecKeyVerifySignature", v22, error);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v10);
  return v16;
}

void sub_18A909B58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

__CFData *SecKeyRunAlgorithmAndCopyResult(uint64_t *a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  void *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  CFIndex v12;
  const void *ValueAtIndex;
  const void *v14;
  CFIndex v15;
  const void *v16;
  const void *v17;
  __CFData *v18;
  uint64_t v19;
  uint64_t (*v20)(void);
  __CFData *Mutable;
  uint64_t AlgorithmId;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t (*v28)(uint64_t, uint64_t, const UInt8 *, CFIndex, UInt8 *, CFIndex *);
  uint64_t v29;
  uint64_t (*v30)(uint64_t);
  uint64_t v31;
  uint64_t v32;
  int v33;
  UInt8 *MutableBytePtr;
  uint64_t v35;
  CFTypeID v36;
  uint64_t v37;
  uint64_t (*Value)(uint64_t *, const __CFData *, const __CFData *, __CFString **);
  void *v39;
  const void *v40;
  const __CFDictionary *v42;
  NSObject *v43;
  int v44;
  CFIndex v45;
  const UInt8 *BytePtr;
  uint64_t v47;
  uint64_t (*v48)(uint64_t, uint64_t, const UInt8 *, CFIndex, UInt8 *, CFIndex *);
  CFIndex length;
  __int16 v50;
  const void *v51;
  __int16 v52;
  int v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v8 = (void *)MEMORY[0x18D770A24]();
  Count = CFArrayGetCount((CFArrayRef)a1[2]);
  v10 = Count - 1;
  if (Count > 1)
  {
    v11 = Count;
    v12 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1[2], v12++);
      if (v12 < v11)
        break;
LABEL_7:
      if (v12 == v10)
        goto LABEL_8;
    }
    v14 = ValueAtIndex;
    v15 = v12;
    while (1)
    {
      v16 = CFArrayGetValueAtIndex((CFArrayRef)a1[2], v15);
      if (CFEqual(v14, v16))
        break;
      if (v11 == ++v15)
        goto LABEL_7;
    }
LABEL_50:
    if (a1[3])
    {
      Mutable = (__CFData *)*MEMORY[0x1E0C9B0D0];
    }
    else
    {
      v40 = CFArrayGetValueAtIndex((CFArrayRef)a1[2], 0);
      SecError(-50, a4, CFSTR("%@: algorithm not supported by the key %@"), v40, *a1);
      Mutable = 0;
    }
    goto LABEL_53;
  }
LABEL_8:
  v17 = CFArrayGetValueAtIndex((CFArrayRef)a1[2], v10);
  v18 = (__CFData *)*MEMORY[0x1E0C9B0D0];
  if (CFArrayGetCount((CFArrayRef)a1[2]) < 1)
    __security_simulatecrash(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
  v19 = *(_QWORD *)(*a1 + 16);
  if (*(_DWORD *)v19 >= 4u && (v20 = *(uint64_t (**)(void))(v19 + 152)) != 0)
  {
    Mutable = (__CFData *)v20();
  }
  else
  {
    AlgorithmId = SecKeyGetAlgorithmId(*a1);
    v23 = 0;
    v24 = &qword_1E1FD73B8;
    while (AlgorithmId != *v24 || !CFEqual(v17, *(CFTypeRef *)*(v24 - 1)))
    {
      ++v23;
      v24 += 3;
      if (v23 == 7)
        goto LABEL_39;
    }
    v25 = LODWORD((&SecKeyCopyBackendOperationResult_paddingMap)[3 * v23 + 2]);
    length = 0;
    switch(a1[1])
    {
      case 0:
        Mutable = v18;
        if (!*(_QWORD *)(*(_QWORD *)(*a1 + 16) + 40))
          goto LABEL_36;
        if (a1[3])
          goto LABEL_30;
        v26 = v25;
        length = SecKeyGetSize(*a1, 1);
        Mutable = CFDataCreateMutable(0, 0);
        CFDataSetLength(Mutable, length);
        v27 = *a1;
        v28 = *(uint64_t (**)(uint64_t, uint64_t, const UInt8 *, CFIndex, UInt8 *, CFIndex *))(*(_QWORD *)(*a1 + 16) + 40);
        goto LABEL_32;
      case 1:
        v29 = *a1;
        v30 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(*a1 + 16) + 48);
        Mutable = v18;
        if (!v30)
          goto LABEL_36;
        Mutable = (__CFData *)*MEMORY[0x1E0C9AE50];
        if (a1[3])
          goto LABEL_36;
        v47 = v25;
        CFDataGetBytePtr(a2);
        CFDataGetLength(a2);
        CFDataGetBytePtr(a3);
        CFDataGetLength(a3);
        v31 = v29;
        v32 = v47;
        v33 = v30(v31);
        goto LABEL_33;
      case 2:
        Mutable = v18;
        if (!*(_QWORD *)(*(_QWORD *)(*a1 + 16) + 56))
          goto LABEL_36;
        if (a1[3])
          goto LABEL_30;
        v26 = v25;
        length = SecKeyGetSize(*a1, 2);
        Mutable = CFDataCreateMutable(0, 0);
        CFDataSetLength(Mutable, length);
        v27 = *a1;
        v28 = *(uint64_t (**)(uint64_t, uint64_t, const UInt8 *, CFIndex, UInt8 *, CFIndex *))(*(_QWORD *)(*a1 + 16) + 56);
        goto LABEL_32;
      case 3:
        Mutable = v18;
        if (!*(_QWORD *)(*(_QWORD *)(*a1 + 16) + 64))
          goto LABEL_36;
        if (a1[3])
        {
LABEL_30:
          Mutable = (__CFData *)*MEMORY[0x1E0C9AE50];
        }
        else
        {
          v26 = v25;
          length = SecKeyGetSize(*a1, 2);
          Mutable = CFDataCreateMutable(0, 0);
          CFDataSetLength(Mutable, length);
          v27 = *a1;
          v28 = *(uint64_t (**)(uint64_t, uint64_t, const UInt8 *, CFIndex, UInt8 *, CFIndex *))(*(_QWORD *)(*a1 + 16) + 64);
LABEL_32:
          v48 = v28;
          BytePtr = CFDataGetBytePtr(a2);
          v45 = CFDataGetLength(a2);
          MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
          v35 = v27;
          v32 = v26;
          v33 = v48(v35, v26, BytePtr, v45, MutableBytePtr, &length);
LABEL_33:
          if (v33)
          {
            SecError(v33, a4, CFSTR("legacy SecKey backend operation:%d(%d) failed"), a1[1], v32);
            if (Mutable)
            {
              CFRelease(Mutable);
              Mutable = 0;
            }
            break;
          }
        }
LABEL_36:
        v36 = CFGetTypeID(Mutable);
        if (v36 == CFDataGetTypeID())
          CFDataSetLength(Mutable, length);
        break;
      default:
        goto LABEL_39;
    }
  }
  if (Mutable == v18)
  {
LABEL_39:
    if (v18)
      CFRelease(v18);
    v37 = a1[1];
    if (SecKeyGetAlgorithmAdaptor_onceToken != -1)
      dispatch_once(&SecKeyGetAlgorithmAdaptor_onceToken, &__block_literal_global_9913);
    Value = (uint64_t (*)(uint64_t *, const __CFData *, const __CFData *, __CFString **))CFDictionaryGetValue((CFDictionaryRef)SecKeyGetAlgorithmAdaptor_adaptors[v37], v17);
    if (Value)
    {
      Mutable = (__CFData *)Value(a1, a2, a3, a4);
      if (Mutable != v18)
        goto LABEL_53;
    }
    else
    {
      if (_SECKEY_LOG_once_9914 != -1)
        dispatch_once(&_SECKEY_LOG_once_9914, &__block_literal_global_270);
      v39 = (void *)_SECKEY_LOG_log_9915;
      if (os_log_type_enabled((os_log_t)_SECKEY_LOG_log_9915, OS_LOG_TYPE_DEBUG))
      {
        v42 = (const __CFDictionary *)SecKeyGetAlgorithmAdaptor_adaptors[v37];
        v43 = v39;
        v44 = CFDictionaryGetCount(v42);
        LODWORD(length) = 67109634;
        HIDWORD(length) = v37;
        v50 = 2114;
        v51 = v17;
        v52 = 1024;
        v53 = v44;
        _os_log_debug_impl(&dword_18A900000, v43, OS_LOG_TYPE_DEBUG, "failed to find adaptor: operation=%d, algorithm=%{public}@ (adaptors:%d)", (uint8_t *)&length, 0x18u);

      }
    }
    goto LABEL_50;
  }
LABEL_53:
  objc_autoreleasePoolPop(v8);
  return Mutable;
}

__CFData *SecRSAPublicKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  __CFData *Mutable;
  CFIndex Length;
  const __CFAllocator *v15;
  uint64_t v16;

  if (!CFEqual(cf1, CFSTR("algid:encrypt:RSA:raw-cc")))
    return (__CFData *)*MEMORY[0x1E0C9B0D0];
  Mutable = (__CFData *)*MEMORY[0x1E0C9AE50];
  if (a2 != 3)
  {
    if (a2 == 2)
    {
      if (!a5)
      {
        Length = CFDataGetLength(a6);
        if (Length == ((ccrsa_block_size() + 7) & 0xFFFFFFFFFFFFFFF8))
        {
          CFDataGetLength(a6);
          CFDataGetBytePtr(a6);
          if ((ccn_cmpn() & 0x80000000) == 0)
          {
            SecError(-50, a8, CFSTR("RSApubkey wrong size of buffer to encrypt"));
            return 0;
          }
          v15 = 0;
          goto LABEL_14;
        }
        goto LABEL_19;
      }
      return Mutable;
    }
    return (__CFData *)*MEMORY[0x1E0C9B0D0];
  }
  if (!a5)
  {
    Length = CFDataGetLength(a6);
    if (Length == ((ccrsa_block_size() + 7) & 0xFFFFFFFFFFFFFFF8))
    {
      if (SecCFAllocatorZeroize_sOnce != -1)
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
      v15 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
LABEL_14:
      Mutable = CFDataCreateMutable(v15, 0);
      CFDataSetLength(Mutable, Length);
      CFDataGetMutableBytePtr(Mutable);
      CFDataGetBytePtr(a6);
      v16 = ccrsa_pub_crypt();
      if (!(_DWORD)v16)
        return Mutable;
      if (Mutable)
        CFRelease(Mutable);
      SecError(-50, a8, CFSTR("rsa_pub_crypt failed, ccerr=%d"), v16);
      return 0;
    }
LABEL_19:
    SecError(-50, a8, CFSTR("%@: sign - input buffer bad size (%d bytes)"), a1, Length);
    return 0;
  }
  return Mutable;
}

uint64_t SecECPublicKeyCopyOperationResult(int a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, const __CFData *a7, __CFString **a8)
{
  uint64_t v12;
  uint64_t v14;

  if (a2 != 1 || !CFEqual(cf1, CFSTR("algid:sign:ECDSA:digest-X962")))
  {
    v12 = MEMORY[0x1E0C9B0D0];
    return *(_QWORD *)v12;
  }
  if (a5)
  {
    v12 = MEMORY[0x1E0C9AE50];
    return *(_QWORD *)v12;
  }
  CFDataGetLength(a7);
  CFDataGetBytePtr(a7);
  CFDataGetLength(a6);
  CFDataGetBytePtr(a6);
  v14 = ccec_verify();
  if ((_DWORD)v14)
    SecError(-67808, a8, CFSTR("EC signature verification failed (ccerr %d)"), v14);
  else
    SecError(-67808, a8, CFSTR("EC signature verification failed, no match"));
  return 0;
}

size_t SecKeyGetBlockSize(SecKeyRef key)
{
  uint64_t (*v2)(SecKeyRef);

  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyGetBlockSize");
  v2 = *(uint64_t (**)(SecKeyRef))(*((_QWORD *)key + 2) + 80);
  if (v2)
    return v2(key);
  else
    return 0;
}

__SecCertificate *SecCertificateIsAtLeastMinKeySize(__SecCertificate *result, const __CFDictionary *a2)
{
  unint64_t v3;
  const void *v4;
  BOOL v5;
  unint64_t valuePtr;
  void *value;
  unint64_t v8;

  if (result)
  {
    value = (void *)0xAAAAAAAAAAAAAAAALL;
    v8 = 0;
    valuePtr = 0xAAAAAAAAAAAAAAAALL;
    v3 = SecCertificateGetPublicKeyAlgorithmIdAndSize(result, (uint64_t *)&v8) - 1;
    if (v3 <= 5
      && ((0x2Du >> v3) & 1) != 0
      && (v4 = *off_1E1FD5668[v3]) != 0
      && (CFDictionaryGetValueIfPresent(a2, v4, (const void **)&value) ? (v5 = value == 0) : (v5 = 1), !v5))
    {
      result = (__SecCertificate *)CFNumberGetValue((CFNumberRef)value, kCFNumberLongType, &valuePtr);
      if ((_DWORD)result)
        return (__SecCertificate *)(v8 >= (valuePtr + 7) >> 3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SecCertificateIsWeakKey(__SecCertificate *a1)
{
  uint64_t v1;
  uint64_t result;
  BOOL v3;
  unint64_t v4;

  if (!a1)
    return 1;
  v4 = 0;
  v1 = SecCertificateGetPublicKeyAlgorithmIdAndSize(a1, (uint64_t *)&v4) - 1;
  result = 0;
  switch(v1)
  {
    case 0:
      v3 = v4 >= 0x80;
      goto LABEL_6;
    case 2:
      v3 = v4 >= 0x14;
LABEL_6:
      result = !v3;
      break;
    case 3:
    case 5:
      return result;
    default:
      result = 1;
      break;
  }
  return result;
}

uint64_t SecCertificateGetPublicKeyAlgorithmIdAndSize(__SecCertificate *a1, uint64_t *a2)
{
  SecKeyRef v3;
  _QWORD *v4;
  uint64_t (*v5)(_QWORD *);
  uint64_t v6;
  uint64_t AlgorithmId;

  v3 = SecCertificateCopyKey(a1);
  if (!v3)
  {
    AlgorithmId = 0;
    v6 = 0;
    if (!a2)
      return AlgorithmId;
    goto LABEL_6;
  }
  v4 = v3;
  _SecKeyCheck((uint64_t)v3, (uint64_t)"SecKeyGetBlockSize");
  v5 = *(uint64_t (**)(_QWORD *))(v4[2] + 80);
  if (v5)
    v6 = v5(v4);
  else
    v6 = 0;
  AlgorithmId = SecKeyGetAlgorithmId((uint64_t)v4);
  CFRelease(v4);
  if (a2)
LABEL_6:
    *a2 = v6;
  return AlgorithmId;
}

uint64_t SecKeyGetAlgorithmId(uint64_t a1)
{
  uint64_t v2;
  uint64_t (*v3)(uint64_t);
  NSObject *v5;
  uint8_t v6[16];

  _SecKeyCheck(a1, (uint64_t)"SecKeyGetAlgorithmId");
  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    if (*(_DWORD *)v2 && (v3 = *(uint64_t (**)(uint64_t))(v2 + 104)) != 0)
      return v3(a1);
    else
      return 1;
  }
  else
  {
    _SECKEY_LOG_9290();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v6 = 0;
      _os_log_fault_impl(&dword_18A900000, v5, OS_LOG_TYPE_FAULT, "Key with NULL class detected!", v6, 2u);
    }

    return 0;
  }
}

SecKeyRef SecCertificateCopyKey(SecCertificateRef certificate)
{
  const void *v1;
  const __CFData *v3;
  const __CFData *v4;

  v1 = (const void *)*((_QWORD *)certificate + 68);
  if (v1)
    goto LABEL_5;
  v3 = SecCertificateCopySPKIEncoded((uint64_t)certificate);
  if (v3)
  {
    v4 = v3;
    *((_QWORD *)certificate + 68) = SecKeyCreateFromSubjectPublicKeyInfoData(0, v3);
    CFRelease(v4);
  }
  v1 = (const void *)*((_QWORD *)certificate + 68);
  if (v1)
LABEL_5:
    CFRetain(v1);
  return (SecKeyRef)v1;
}

uint64_t SecRSAPublicKeyBlockSize()
{
  return ccrsa_block_size();
}

uint64_t SecECKeyGetAlgorithmID()
{
  return 3;
}

_QWORD *SecKeyCreateFromSubjectPublicKeyInfoData(uint64_t a1, CFDataRef theData)
{
  __int128 v4;
  uint8_t *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v11;
  char v12;
  uint8_t *v13;
  unint64_t v14;
  _BYTE v15[32];
  __int128 v16;
  __int128 v17;
  _QWORD v18[2];
  uint8_t buf[8];
  __int128 v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;

  v18[0] = CFDataGetBytePtr(theData);
  v18[1] = CFDataGetLength(theData);
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16 = v4;
  v17 = v4;
  *(_OWORD *)v15 = v4;
  *(_OWORD *)&v15[16] = v4;
  v13 = (uint8_t *)0xAAAAAAAAAAAAAAAALL;
  v14 = 0xAAAAAAAAAAAAAAAALL;
  if (!DERParseSequence((uint64_t)v18, (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs, (uint64_t)&DERSubjPubKeyInfoItemSpecs, (unint64_t)&v16, 0x20uLL)&& !DERParseSequenceContent((unint64_t *)&v16, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)v15, 0x20uLL))
  {
    v12 = -86;
    if (!DERParseBitString((uint64_t)&v17, (unint64_t *)&v13, &v12))
    {
      if (DEROidCompare((uint64_t)v15, (uint64_t)&oidRsa))
      {
        v5 = v13;
        v6 = v14;
        v7 = &kSecRSAPublicKeyDescriptor;
        v8 = a1;
        v9 = 1;
        return SecKeyCreate(v8, (uint64_t)v7, (uint64_t)v5, v6, v9);
      }
      if (DEROidCompare((uint64_t)v15, (uint64_t)&oidEcPubKey))
      {
        *(_QWORD *)buf = *(_QWORD *)v15;
        v20 = *(_OWORD *)&v15[8];
        v21 = *(_QWORD *)&v15[24];
        v22 = (unint64_t)v13;
        v23 = v14;
        v7 = &kSecECPublicKeyDescriptor;
        v5 = buf;
        v8 = a1;
        v6 = 48;
        v9 = 4;
        return SecKeyCreate(v8, (uint64_t)v7, (uint64_t)v5, v6, v9);
      }
      if (DEROidCompare((uint64_t)v15, (uint64_t)&oidEd25519))
      {
        v5 = v13;
        v6 = v14;
        v7 = &kSecEd25519PublicKeyDescriptor;
LABEL_12:
        v8 = a1;
        v9 = 7;
        return SecKeyCreate(v8, (uint64_t)v7, (uint64_t)v5, v6, v9);
      }
      if (DEROidCompare((uint64_t)v15, (uint64_t)&oidEd448))
      {
        v5 = v13;
        v6 = v14;
        v7 = &kSecEd448PublicKeyDescriptor;
        goto LABEL_12;
      }
      _SECKEY_LOG_9290();
      v11 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "Unsupported algorithm oid", buf, 2u);
      }

    }
  }
  return 0;
}

_QWORD *SecKeyCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  size_t v10;
  uint64_t Instance;
  _QWORD *v12;
  uint64_t (*v13)(_QWORD *, uint64_t, uint64_t, uint64_t);
  int v14;
  int v15;
  NSObject *v16;
  uint64_t v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a2)
    objc_msgSend(MEMORY[0x1E0C99DA0], "raise:format:", *MEMORY[0x1E0C99778], CFSTR("Attempting to create SecKeyRef with NULL key_class"));
  v9 = *(unsigned int *)(a2 + 16);
  SecKeyGetTypeID();
  v10 = v9 + 16;
  Instance = _CFRuntimeCreateInstance();
  v12 = (_QWORD *)Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), v10);
    v12[2] = a2;
    if (*(_DWORD *)(a2 + 16))
      v12[3] = v12 + 4;
    v13 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t))(a2 + 24);
    if (v13)
    {
      v14 = v13(v12, a3, a4, a5);
      if (v14)
      {
        v15 = v14;
        _SECKEY_LOG_9290();
        v16 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          v18 = *(_QWORD *)(a2 + 8);
          v19 = 136446466;
          v20 = v18;
          v21 = 1024;
          v22 = v15;
          _os_log_error_impl(&dword_18A900000, v16, OS_LOG_TYPE_ERROR, "SecKeyCreate init(%{public}s) failed: %d", (uint8_t *)&v19, 0x12u);
        }

        CFRelease(v12);
        return 0;
      }
    }
  }
  return v12;
}

CFTypeID SecKeyGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __SecKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SecKeyGetTypeID_sSecKeyGetTypeIDSingleton;
  if (SecKeyGetTypeID_sSecKeyGetTypeIDOnce != -1)
    dispatch_once(&SecKeyGetTypeID_sSecKeyGetTypeIDOnce, block);
  return SecKeyGetTypeID_sSecKeyGetTypeIDSingleton;
}

CFDataRef SecCertificateCopySPKIEncoded(uint64_t a1)
{
  unint64_t v2;
  CFDataRef v3;
  UInt8 *v4;
  UInt8 *v5;
  CFIndex length;

  if (!a1 || !*(_QWORD *)(a1 + 200))
    return 0;
  v2 = DERLengthOfItem(0x2000000000000010uLL, *(_QWORD *)(a1 + 208));
  v3 = 0;
  length = v2;
  if ((v2 & 0x8000000000000000) != 0 || v2 < *(_QWORD *)(a1 + 208))
    return v3;
  v4 = (UInt8 *)malloc_type_malloc(v2, 0x97024632uLL);
  if (!v4)
    return 0;
  v5 = v4;
  if (DEREncodeItem(0x2000000000000010uLL, *(_QWORD *)(a1 + 208), *(const void **)(a1 + 200), (unint64_t)v4, (unint64_t *)&length))v3 = 0;
  else
    v3 = CFDataCreate(0, v5, length);
  free(v5);
  return v3;
}

uint64_t DEREncodeItemSized(unint64_t a1, unint64_t a2, const void *a3, unint64_t a4, unint64_t a5, unint64_t *a6)
{
  unint64_t v12;
  unint64_t v13;
  uint64_t result;
  unint64_t v15;
  uint64_t v16;
  BOOL v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  void *v21;
  uint64_t v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  v12 = *a6;
  v13 = DERLengthOfItem(a1, a2);
  if (v13 > a5)
    return 7;
  v15 = v13;
  if (v13 > *a6)
    goto LABEL_20;
  *a6 = v13;
  v22[0] = v13;
  if (v13 > v12)
    goto LABEL_20;
  result = DEREncodeTag(a1, a4, (unint64_t *)v22);
  if ((_DWORD)result)
    return result;
  v16 = v22[0];
  if (__CFADD__(a4, v22[0]))
  {
LABEL_21:
    __break(0x5513u);
    goto LABEL_22;
  }
  v17 = v15 >= v22[0];
  v18 = v15 - v22[0];
  if (!v17)
    goto LABEL_22;
  v19 = a4 + v12;
  v20 = a4 + v22[0];
  v22[0] = v18;
  if (a4 + v16 > a4 + v12 || v20 < a4 || v18 > v19 - v20)
LABEL_20:
    __break(0x5519u);
  result = DEREncodeLengthSized(a2, v20, v18, v22);
  if ((_DWORD)result)
    return result;
  if (__CFADD__(v20, v22[0]))
    goto LABEL_21;
  if (v18 < v22[0])
  {
LABEL_22:
    __break(0x5515u);
    return result;
  }
  v21 = (void *)(v20 + v22[0]);
  if (v19 < v20 + v22[0] || (unint64_t)v21 < a4 || v19 - (v20 + v22[0]) < a2)
    goto LABEL_20;
  memmove(v21, a3, a2);
  return 0;
}

unint64_t DERLengthOfItem(unint64_t result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  uint64_t v8;

  v2 = result & 0x1FFFFFFFFFFFFFFFLL;
  v3 = 1;
  if ((result & 0x1FFFFFFFFFFFFFFFLL) >= 0x1F)
  {
    do
    {
      ++v3;
      v4 = v2 > 0x7F;
      v2 >>= 7;
    }
    while (v4);
  }
  v5 = 1;
  if (a2 >= 0x80)
  {
    v6 = a2;
    do
    {
      ++v5;
      v4 = v6 > 0xFF;
      v6 >>= 8;
    }
    while (v4);
  }
  v7 = __CFADD__(v3, v5);
  v8 = v3 + v5;
  if (v7 || (result = v8 + a2, __CFADD__(v8, a2)))
    __break(0x5500u);
  return result;
}

uint64_t DEREncodeItem(unint64_t a1, unint64_t a2, const void *a3, unint64_t a4, unint64_t *a5)
{
  return DEREncodeItemSized(a1, a2, a3, a4, *a5, a5);
}

unint64_t SecECPublicKeyBlockSize()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

uint64_t SecRSAPublicKeyInit(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  unint64_t *v12;
  unint64_t *v13;
  __int128 v14;
  uint64_t v15;
  _BYTE *v16;
  unint64_t *v17;
  unint64_t v18;
  _BYTE *v19;
  size_t v20;
  _QWORD *v21;
  void *v22;
  const void *v23;
  _OWORD v24[3];
  _QWORD v25[2];

  result = 4294967246;
  switch(a4)
  {
    case 1:
    case 7:
      v8 = ccrsa_import_pub_n();
      if ((unint64_t)(v8 - 129) >= 0xFFFFFFFFFFFFFF80)
      {
        v9 = v8;
        v10 = malloc_type_calloc(1uLL, 24 * v8 + 40, 0x7A1A06D3uLL);
        *(_QWORD *)(a1 + 24) = v10;
        if (!v10)
          goto LABEL_17;
        *v10 = v9;
        v11 = ccrsa_import_pub();
        goto LABEL_11;
      }
      result = 4294967246;
      break;
    case 2:
      v12 = (unint64_t *)malloc_type_calloc(1uLL, 0xC28uLL, 0x997E5DB9uLL);
      *(_QWORD *)(a1 + 24) = v12;
      if (!v12)
        goto LABEL_17;
      v13 = v12;
      *v12 = 128;
      v25[0] = a2;
      v25[1] = a3;
      *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v24[1] = v14;
      v24[2] = v14;
      v24[0] = v14;
      if (!DERParseSequence((uint64_t)v25, (unsigned __int16)DERNumRSAPubKeyAppleItemSpecs, (uint64_t)&DERRSAPubKeyAppleItemSpecs, (unint64_t)v24, 0x30uLL))
      {
        v15 = *((_QWORD *)&v24[0] + 1);
        v16 = *(_BYTE **)&v24[0];
        v17 = v13;
        goto LABEL_10;
      }
      result = 4294941021;
      break;
    case 3:
      v18 = *(_QWORD *)(a2 + 8) + 7;
      v17 = (unint64_t *)malloc_type_calloc(1uLL, 3 * (v18 & 0xFFFFFFFFFFFFFFF8) + 40, 0xBF3D5D62uLL);
      *(_QWORD *)(a1 + 24) = v17;
      if (!v17)
        goto LABEL_17;
      *v17 = v18 >> 3;
      v16 = *(_BYTE **)a2;
      v15 = *(_QWORD *)(a2 + 8);
LABEL_10:
      v11 = ccrsa_pub_init(v17, v15, v16);
LABEL_11:
      if (v11)
        result = 4294967246;
      else
        result = 0;
      break;
    case 6:
      v19 = *(_BYTE **)a2;
      v20 = 24 * *(_QWORD *)a2 + 40;
      v21 = malloc_type_calloc(1uLL, v20, 0xBEFB1072uLL);
      *(_QWORD *)(a1 + 24) = v21;
      if (v21)
      {
        v22 = v21;
        *v21 = v19;
        v23 = (const void *)ccrsa_ctx_public();
        memcpy(v22, v23, v20);
        result = 0;
      }
      else
      {
LABEL_17:
        result = 4294967188;
      }
      break;
    default:
      return result;
  }
  return result;
}

__CFData *SecKeyRSACopyCCUnitToBigEndian(const __CFData *a1, CFIndex a2)
{
  __CFData *Mutable;

  if (!a1)
    return 0;
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  CFDataSetLength(Mutable, a2);
  CFDataGetLength(Mutable);
  CFDataGetMutableBytePtr(Mutable);
  ccn_write_uint_padded();
  return Mutable;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_EncryptDecrypt_RSAEncryptionRaw(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:encrypt:RSA:raw-cc"));
  return SecKeyAlgorithmAdaptorCopyBigEndianToCCUnit((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA256(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA256_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyRSAVerifyAdaptorCopyResult(uint64_t a1, const __CFData *a2, __CFString **a3, void *a4)
{
  unsigned int (**v7)(id, __CFData *);
  __CFData *v8;
  __CFData *v9;
  BOOL v10;
  __CFData *v11;
  __CFData *v12;

  v7 = a4;
  *(_QWORD *)(a1 + 8) = 3;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:encrypt:RSA:raw"));
  v8 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, a2, 0, a3);
  v9 = v8;
  if (*(_QWORD *)(a1 + 24))
    v10 = 1;
  else
    v10 = v8 == 0;
  if (v10)
    goto LABEL_15;
  if (!v7[2](v7, v8))
  {
    v12 = (__CFData *)*MEMORY[0x1E0C9AE40];
    if (v9 != (__CFData *)*MEMORY[0x1E0C9AE40])
    {
      if (v12)
        CFRetain((CFTypeRef)*MEMORY[0x1E0C9AE40]);
      CFRelease(v9);
      v9 = v12;
    }
    SecError(-67808, a3, CFSTR("RSA signature verification failed, no match"));
    goto LABEL_15;
  }
  v11 = (__CFData *)*MEMORY[0x1E0C9AE50];
  if (v9 == (__CFData *)*MEMORY[0x1E0C9AE50])
  {
LABEL_15:
    v11 = v9;
    goto LABEL_16;
  }
  if (v11)
    CFRetain((CFTypeRef)*MEMORY[0x1E0C9AE50]);
  CFRelease(v9);
LABEL_16:

  return v11;
}

uint64_t SecECPublicKeyInit(uint64_t a1, unint64_t **__src, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  if (a4 == 7)
  {
    v6 = 4294941021;
    if (!getCPForPublicSize())
      return v6;
    goto LABEL_11;
  }
  if (a4 == 6)
  {
    v7 = **__src;
    if (v7 <= 9)
    {
      memcpy(*(void **)(a1 + 24), __src, 24 * v7 + 16);
      return 0;
    }
    return 4294967246;
  }
  if (a4 != 4)
    return 4294967246;
  if (a3 != 48)
    return 4294941021;
  v4 = (uint64_t)__src[2];
  if (!v4)
    return 4294941021;
  v5 = (uint64_t)__src[3];
  if (v5 < 3 || v5 - 2 < (unint64_t)*(unsigned __int8 *)(v4 + 1))
    return 4294941021;
  v6 = 4294941021;
  if (ccec_cp_for_oid_0(v4))
  {
LABEL_11:
    if (ccec_import_pub())
      return 4294941021;
    else
      return 0;
  }
  return v6;
}

uint64_t ccec_cp_for_oid(int **a1)
{
  int *v1;
  int *v3;
  int v5;
  int v6;

  if (!a1)
    return 0;
  v1 = a1[1];
  if (v1 != (int *)7)
  {
    if (v1 == (int *)10 && *(_QWORD *)*a1 == 0x33DCE48862A0806 && *((_WORD *)*a1 + 4) == 1793)
      JUMPOUT(0x18D76FFBCLL);
    return 0;
  }
  v3 = *a1;
  if (**a1 == -2127887098 && *(int *)((char *)*a1 + 3) == 570426497)
    JUMPOUT(0x18D76FFC8);
  v5 = *v3;
  v6 = *(int *)((char *)v3 + 3);
  if (v5 != -2127887098 || v6 != 587203713)
    return 0;
  return ccec_cp_521();
}

uint64_t ccec_cp_for_oid_0(uint64_t a1)
{
  if (!a1)
    return 0;
  if (ccoid_equal())
    return ccec_cp_192();
  if (ccoid_equal())
    JUMPOUT(0x18D76FFBCLL);
  if (ccoid_equal())
    JUMPOUT(0x18D76FFB0);
  if ((ccoid_equal() & 1) != 0 || ccoid_equal())
    JUMPOUT(0x18D76FFC8);
  if ((ccoid_equal() & 1) != 0 || ccoid_equal())
    return ccec_cp_521();
  else
    return 0;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA256(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PKCS1v15:SHA256"));
  v8 = (size_t *)ccsha256_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyCopyECDSASignatureForDigest(uint64_t a1, const __CFData *a2, const __CFData *a3, uint64_t a4, _QWORD *a5, __CFString **a6)
{
  uint64_t *v12;
  const __CFData *v13;
  const __CFData *v14;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-X962"));
  if (*(_QWORD *)(a1 + 24) == 1)
  {
    v12 = (uint64_t *)a1;
    v13 = 0;
    v14 = 0;
    return SecKeyRunAlgorithmAndCopyResult(v12, v13, v14, a6);
  }
  if (CFDataGetLength(a2) == *a5)
  {
    v12 = (uint64_t *)a1;
    v13 = a2;
    v14 = a3;
    return SecKeyRunAlgorithmAndCopyResult(v12, v13, v14, a6);
  }
  SecError(-50, a6, CFSTR("bad digest size for signing with algorithm %@"), a4);
  return 0;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA256(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  _QWORD *v8;

  v8 = (_QWORD *)ccsha256_di();
  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, (uint64_t)CFSTR("algid:sign:ECDSA:digest-X962:SHA256"), v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA256(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-X962:SHA256"));
  v8 = (size_t *)ccsha256_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

CFTypeID SecTrustGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_11493;
  block[4] = &SecTrustGetTypeID_sSecTrustGetTypeIDSingleton;
  if (SecTrustGetTypeID_sSecTrustGetTypeIDOnce != -1)
    dispatch_once(&SecTrustGetTypeID_sSecTrustGetTypeIDOnce, block);
  return SecTrustGetTypeID_sSecTrustGetTypeIDSingleton;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA1(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA1_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PKCS1v15:SHA1"));
  v8 = (size_t *)ccsha1_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA384(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA384_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PKCS1v15:SHA384"));
  v8 = (size_t *)ccsha384_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

SecPolicyRef SecPolicyCreateBasicX509(void)
{
  SecPolicyRef result;
  __CFDictionary *v1;
  __SecPolicy *v2;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (result)
  {
    v1 = result;
    SecPolicyAddBasicX509Options(result);
    CFDictionaryAddValue(v1, CFSTR("NoNetworkAccess"), (const void *)*MEMORY[0x1E0C9AE50]);
    v2 = (__SecPolicy *)SecPolicyCreate(CFSTR("1.2.840.113635.100.1.2"), CFSTR("basicX509"), v1);
    CFRelease(v1);
    return v2;
  }
  return result;
}

uint64_t SecRSAPrivateKeyBlockSize()
{
  return ccn_write_uint_size();
}

uint64_t SecRSAPrivateKeyInit(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  int fips186_key;
  const __CFNumber *Value;
  const __CFNumber *v12;
  CFTypeID v13;
  uint64_t IntValue;
  CFTypeID v15;
  NSObject *v16;
  unint64_t v17;
  _QWORD *v18;
  uint8_t v19[24];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a4 == 7)
  {
LABEL_4:
    v6 = ccrsa_import_priv_n();
    if ((unint64_t)(v6 - 129) >= 0xFFFFFFFFFFFFFF80)
    {
      v7 = v6;
      v8 = malloc_type_calloc(1uLL, 7 * ((4 * v6) & 0x7FFFFFFFFFFFFFF8) + 32 * v6 + 176, 0xA61AF433uLL);
      *(_QWORD *)(a1 + 24) = v8;
      if (v8)
      {
        *v8 = v7;
        fips186_key = ccrsa_import_priv();
        goto LABEL_7;
      }
      return 4294967188;
    }
    return 4294967246;
  }
  if (a4 != 5)
  {
    if (a4 != 1)
      return 4294967246;
    goto LABEL_4;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("bsiz"));
  if (Value)
  {
    v12 = Value;
    v13 = CFGetTypeID(Value);
    if (v13 == CFNumberGetTypeID())
    {
      *(_QWORD *)v19 = 0xAAAAAAAAAAAAAAAALL;
      CFNumberGetValue(v12, kCFNumberCFIndexType, v19);
      IntValue = *(_QWORD *)v19;
    }
    else
    {
      v15 = CFGetTypeID(v12);
      if (v15 != CFStringGetTypeID())
        goto LABEL_17;
      IntValue = CFStringGetIntValue((CFStringRef)v12);
    }
    if ((unint64_t)(IntValue - 8193) > 0xFFFFFFFFFFFFE1FELL)
    {
      v17 = (unint64_t)(IntValue + 63) >> 6;
      v18 = malloc_type_calloc(1uLL, 7 * (((unint64_t)(IntValue + 63) >> 4) & 0xFFFFFFFFFFFFFF8) + 32 * v17 + 176, 0x476EA970uLL);
      *(_QWORD *)(a1 + 24) = v18;
      if (v18)
      {
        *v18 = v17;
        ccrng();
        ccrng();
        fips186_key = ccrsa_generate_fips186_key();
LABEL_7:
        if (fips186_key)
          return 4294967246;
        else
          return 0;
      }
      return 4294967188;
    }
  }
LABEL_17:
  v16 = secLogObjForScope("SecWarning");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v19 = 138412290;
    *(_QWORD *)&v19[4] = theDict;
    _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEFAULT, "Invalid or missing key size in: %@", v19, 0xCu);
  }
  return 4294941985;
}

__CFData *SecRSAPrivateKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  __CFData *Mutable;
  CFIndex Length;
  const __CFAllocator *v14;
  uint64_t v15;
  CFIndex v17;

  Mutable = (__CFData *)*MEMORY[0x1E0C9B0D0];
  if (a2 == 3)
  {
    if (CFEqual(cf1, CFSTR("algid:encrypt:RSA:raw-cc")))
    {
      if (!a5)
      {
        Length = CFDataGetLength(a6);
        ccrsa_ctx_public();
        if (Length == ((ccrsa_block_size() + 7) & 0xFFFFFFFFFFFFFFF8))
        {
          if (SecCFAllocatorZeroize_sOnce != -1)
            dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
          v14 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
LABEL_15:
          Mutable = CFDataCreateMutable(v14, 0);
          CFDataSetLength(Mutable, Length);
          CFDataGetMutableBytePtr(Mutable);
          CFDataGetBytePtr(a6);
          v15 = ccrsa_priv_crypt();
          if (!(_DWORD)v15)
            return Mutable;
          if (Mutable)
            CFRelease(Mutable);
          SecError(-50, a8, CFSTR("rsa_priv_crypt failed, ccerr=%d"), v15);
          return 0;
        }
LABEL_21:
        SecError(-50, a8, CFSTR("%@: sign - input buffer bad size (%d bytes)"), a1, Length);
        return 0;
      }
      return (__CFData *)*MEMORY[0x1E0C9AE50];
    }
  }
  else if (!a2 && CFEqual(cf1, CFSTR("algid:sign:RSA:raw-cc")))
  {
    if (!a5)
    {
      Length = CFDataGetLength(a6);
      ccrsa_ctx_public();
      if (Length == ((ccrsa_block_size() + 7) & 0xFFFFFFFFFFFFFFF8))
      {
        CFDataGetLength(a6);
        CFDataGetBytePtr(a6);
        if ((ccn_cmpn() & 0x80000000) == 0)
        {
          v17 = CFDataGetLength(a6);
          SecError(-50, a8, CFSTR("%@: sign - digest too big (%d bytes)"), a1, v17);
          return 0;
        }
        v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        goto LABEL_15;
      }
      goto LABEL_21;
    }
    return (__CFData *)*MEMORY[0x1E0C9AE50];
  }
  return Mutable;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-X962:SHA384"));
  v8 = (size_t *)ccsha384_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA384(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  _QWORD *v8;

  v8 = (_QWORD *)ccsha384_di();
  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, (uint64_t)CFSTR("algid:sign:ECDSA:digest-X962:SHA384"), v8, a4);
}

__CFData *SecKeyRSACopyEMSASignature(uint64_t a1, uint64_t a2, __CFString **a3, int a4, _QWORD *a5)
{
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  const void *Value;
  const void *v13;
  uint64_t v14;
  const __CFArray *v15;
  CFIndex Count;
  const void *ValueAtIndex;
  __CFData *v18;
  SecKeyRef v19;
  uint64_t (*v20)(SecKeyRef);
  uint64_t v21;
  _QWORD v23[11];
  char v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;

  v25 = 0;
  v26 = &v25;
  v27 = 0x2020000000;
  v28 = 0;
  v10 = SecKeyCopyAttributes(*(SecKeyRef *)a1);
  v11 = v10;
  if (!v10)
  {
    SecError(-50, a3, CFSTR("Unable to export key parameters"));
    goto LABEL_16;
  }
  Value = CFDictionaryGetValue(v10, CFSTR("type"));
  if (!CFEqual(Value, CFSTR("42")) || (v13 = CFDictionaryGetValue(v11, CFSTR("kcls")), !CFEqual(v13, CFSTR("1"))))
  {
    v26[3] = *MEMORY[0x1E0C9B0D0];
    goto LABEL_20;
  }
  if (a4)
  {
    v14 = objc_msgSend((id)CFDictionaryGetValue(v11, CFSTR("bsiz")), "integerValue");
    if (v14 < ((16 * *a5) | 9))
    {
      v15 = *(const __CFArray **)(a1 + 16);
      Count = CFArrayGetCount(v15);
      ValueAtIndex = CFArrayGetValueAtIndex(v15, Count - 1);
      SecError(-50, a3, CFSTR("algorithm %@ incompatible with %lubit RSA key"), ValueAtIndex, v14);
LABEL_20:
      CFRelease(v11);
LABEL_16:
      v18 = (__CFData *)v26[3];
      goto LABEL_18;
    }
  }
  else
  {
    v14 = 0;
  }
  CFRelease(v11);
  if (a5 && (a4 & 1) == 0)
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PKCS1v15"));
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:raw-cc"));
  if (*(_QWORD *)(a1 + 24) != 1)
  {
    v19 = *(SecKeyRef *)a1;
    _SecKeyCheck(*(_QWORD *)a1, (uint64_t)"SecKeyGetBlockSize");
    v20 = *(uint64_t (**)(SecKeyRef))(*((_QWORD *)v19 + 2) + 80);
    if (!v20 || (v21 = v20(v19)) == 0)
    {
      SecError(-50, a3, CFSTR("expecting RSA key"));
      v18 = 0;
      goto LABEL_18;
    }
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 3221225472;
    v23[2] = __SecKeyRSACopyEMSASignature_block_invoke;
    v23[3] = &unk_1E1FD81C8;
    v24 = a4;
    v23[6] = a3;
    v23[7] = a5;
    v23[8] = a2;
    v23[9] = v14;
    v23[4] = &v25;
    v23[5] = v21;
    v23[10] = a1;
    PerformWithCFDataBuffer((v21 + 7) & 0xFFFFFFFFFFFFFFF8, v23);
    goto LABEL_16;
  }
  v18 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0, 0, a3);
LABEL_18:
  _Block_object_dispose(&v25, 8);
  return v18;
}

void sub_18A90C250(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA256(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha256_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyRSACopyEncryptedWithPadding(uint64_t a1, _QWORD *a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8;
  uint64_t (*v9)(uint64_t);
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD v14[10];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:encrypt:RSA:raw-cc"));
  v8 = *(_QWORD *)a1;
  _SecKeyCheck(*(_QWORD *)a1, (uint64_t)"SecKeyGetBlockSize");
  v9 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v8 + 16) + 80);
  if (v9)
  {
    v10 = v9(v8);
    if (a2)
    {
LABEL_3:
      v11 = 2 * *a2 + 2;
      goto LABEL_6;
    }
  }
  else
  {
    v10 = 0;
    if (a2)
      goto LABEL_3;
  }
  v11 = 11;
LABEL_6:
  if (v10 < v11)
    return (__CFData *)*MEMORY[0x1E0C9B0D0];
  if (*(_QWORD *)(a1 + 24) == 1)
    return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0, 0, a4);
  v15 = 0;
  v16 = &v15;
  v17 = 0x2020000000;
  v18 = 0;
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 3221225472;
  v14[2] = __SecKeyRSACopyEncryptedWithPadding_block_invoke;
  v14[3] = &unk_1E1FD8290;
  v14[6] = v10;
  v14[7] = a3;
  v14[4] = &v15;
  v14[5] = a2;
  v14[8] = a4;
  v14[9] = a1;
  PerformWithCFDataBuffer((v10 + 7) & 0xFFFFFFFFFFFFFFF8, v14);
  v12 = v16[3];
  _Block_object_dispose(&v15, 8);
  return (__CFData *)v12;
}

__CFData *SecKeyCreateEncryptedDataWithParameters(uint64_t a1, const void *a2, const __CFData *a3, const __CFData *a4, _QWORD *a5)
{
  void *v10;
  NSObject *v11;
  __CFArray *Mutable;
  __CFData *v13;
  CFTypeRef v14;
  uint64_t v16[2];
  CFTypeRef cf;
  uint64_t v18;
  __CFString *v19;
  os_activity_scope_state_s state;

  v10 = (void *)MEMORY[0x18D770A24]();
  v11 = _os_activity_create(&dword_18A900000, "SecKeyCreateEncryptedDataWithParameters", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v11, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateEncryptedDataWithParameters");
  if (!a3)
    objc_msgSend(MEMORY[0x1E0C99DA0], "raise:format:", *MEMORY[0x1E0C99778], CFSTR("SecKeyCreateEncryptedData() called with NULL plaintext"));
  v19 = 0;
  v16[0] = a1;
  v16[1] = 2;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue(Mutable, a2);
  cf = Mutable;
  v18 = 0;
  v13 = SecKeyRunAlgorithmAndCopyResult(v16, a3, a4, &v19);
  v14 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v14);
  }
  _SecKeyErrorPropagate(v13 != 0, (uint64_t)"SecKeyCreateEncryptedDataWithParameters", v19, a5);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v10);
  return v13;
}

void sub_18A90C6D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionPKCS1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSACopyEncryptedWithPadding(a1, 0, a2, a4);
}

SecTrustRef sec_trust_copy_ref(sec_trust_t trust)
{
  Class isa;

  if (trust && (isa = trust[1].isa) != 0)
    return (SecTrustRef)CFRetain(isa);
  else
    return 0;
}

uint64_t __sec_array_apply_block_invoke(uint64_t a1)
{
  xpc_array_get_pointer();
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

void SecPolicyDestroy(uint64_t a1)
{
  const void *v2;

  CFRelease(*(CFTypeRef *)(a1 + 16));
  v2 = *(const void **)(a1 + 24);
  if (v2)
    CFRelease(v2);
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

uint64_t SecCertificateHasOCSPNoCheckMarkerExtension(uint64_t a1)
{
  if (SecCertificateHasOCSPNoCheckMarkerExtension_onceToken != -1)
    dispatch_once(&SecCertificateHasOCSPNoCheckMarkerExtension_onceToken, &__block_literal_global_104);
  return SecCertificateHasMarkerExtension(a1, (const __CFString *)SecCertificateHasOCSPNoCheckMarkerExtension_sOCSPNoCheckOIDData);
}

void *__cdecl sec_retain(void *obj)
{
  if (obj)
    return os_retain(obj);
  return obj;
}

_QWORD *SecPolicyCreateSSLWithATSPinning(int a1, const __CFString *a2, const __CFDictionary *a3)
{
  return SecPolicyCreateSSL_internal(a1, a2, 0, a3);
}

void SecRSAPublicKeyDestroy(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 24))
  {
    cc_clear();
    free(*(void **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t SecCFAllocatorZeroize()
{
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  return SecCFAllocatorZeroize_sAllocator;
}

void SecCertificateDestroy(_QWORD *a1)
{
  void *v2;
  void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;

  v2 = (void *)a1[46];
  if (v2)
  {
    free(v2);
    a1[46] = 0;
  }
  v3 = (void *)a1[43];
  if (v3)
  {
    free(v3);
    a1[43] = 0;
  }
  v4 = (const void *)a1[58];
  if (v4)
  {
    a1[58] = 0;
    CFRelease(v4);
  }
  v5 = (const void *)a1[59];
  if (v5)
  {
    a1[59] = 0;
    CFRelease(v5);
  }
  v6 = (const void *)a1[60];
  if (v6)
  {
    a1[60] = 0;
    CFRelease(v6);
  }
  v7 = (void *)a1[65];
  if (v7)
  {
    free(v7);
    a1[65] = 0;
  }
  v8 = (const void *)a1[68];
  if (v8)
  {
    a1[68] = 0;
    CFRelease(v8);
  }
  v9 = (const void *)a1[69];
  if (v9)
  {
    a1[69] = 0;
    CFRelease(v9);
  }
  v10 = (const void *)a1[70];
  if (v10)
  {
    a1[70] = 0;
    CFRelease(v10);
  }
  v11 = (const void *)a1[71];
  if (v11)
  {
    a1[71] = 0;
    CFRelease(v11);
  }
  v12 = (const void *)a1[72];
  if (v12)
  {
    a1[72] = 0;
    CFRelease(v12);
  }
  v13 = (const void *)a1[73];
  if (v13)
  {
    a1[73] = 0;
    CFRelease(v13);
  }
  v14 = (const void *)a1[74];
  if (v14)
  {
    a1[74] = 0;
    CFRelease(v14);
  }
  v15 = (const void *)a1[75];
  if (v15)
  {
    a1[75] = 0;
    CFRelease(v15);
  }
  v16 = (const void *)a1[76];
  if (v16)
  {
    a1[76] = 0;
    CFRelease(v16);
  }
  v17 = (const void *)a1[77];
  if (v17)
  {
    a1[77] = 0;
    CFRelease(v17);
  }
  v18 = (const void *)a1[61];
  if (v18)
  {
    a1[61] = 0;
    CFRelease(v18);
  }
  v19 = (const void *)a1[62];
  if (v19)
  {
    a1[62] = 0;
    CFRelease(v19);
  }
}

sec_trust_t sec_trust_create(SecTrustRef trust)
{
  return (sec_trust_t)-[SecConcrete_sec_trust initWithTrust:]([SecConcrete_sec_trust alloc], "initWithTrust:", trust);
}

BOOL SecCertificateAppendToXPCArray(uint64_t a1, xpc_object_t xarray, __CFString **a3)
{
  size_t v3;
  const void *v4;
  BOOL v5;

  if (a1)
  {
    v3 = *(_QWORD *)(a1 + 24);
    if ((v3 & 0x8000000000000000) == 0)
    {
      v4 = *(const void **)(a1 + 16);
      if (v3)
        v5 = v4 == 0;
      else
        v5 = 1;
      if (v5)
        return SecError(-50, a3, CFSTR("failed to der encode certificate"));
      xpc_array_set_data(xarray, 0xFFFFFFFFFFFFFFFFLL, v4, v3);
    }
  }
  return 1;
}

void serializeCertificate(__SecCertificate *a1, __CFArray *a2)
{
  CFTypeID TypeID;
  CFDataRef v5;
  CFDataRef v6;

  if (a1)
  {
    TypeID = SecCertificateGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      v5 = SecCertificateCopyData(a1);
      if (v5)
      {
        v6 = v5;
        CFArrayAppendValue(a2, v5);
        CFRelease(v6);
      }
    }
  }
}

CFDataRef SecCertificateCopyData(CFDataRef certificate)
{
  CFDataRef v1;
  const void *v2;
  const __CFAllocator *v3;

  if (certificate)
  {
    v1 = certificate;
    v2 = (const void *)*((_QWORD *)certificate + 69);
    if (v2)
    {
      CFRetain(v2);
      return (CFDataRef)*((_QWORD *)v1 + 69);
    }
    else
    {
      v3 = CFGetAllocator(v1);
      return CFDataCreate(v3, *((const UInt8 **)v1 + 2), *((_QWORD *)v1 + 3));
    }
  }
  return certificate;
}

void __filterIPAddresses_block_invoke(uint64_t a1, const __CFString *a2)
{
  if ((convertIPAddress(a2, 0) & 1) == 0)
    CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2);
}

uint64_t convertIPAddress(const __CFString *a1, CFTypeRef *a2)
{
  const __CFCharacterSet *v4;
  CFCharacterSetRef InvertedSet;
  CFMutableDataRef Mutable;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  const __CFString *ValueAtIndex;
  const __CFString *v12;
  CFIndex Length;
  CFIndex v14;
  char *v15;
  int v16;
  char v17;
  uint64_t v18;
  CFIndex v19;
  CFIndex v20;
  const __CFString *v21;
  const __CFString *v22;
  CFMutableStringRef MutableCopy;
  const __CFLocale *System;
  const __CFCharacterSet *v25;
  const __CFCharacterSet *v26;
  __CFData *v27;
  const __CFArray *v28;
  const __CFArray *v29;
  CFIndex v30;
  CFIndex i;
  const __CFString *v32;
  const __CFString *v33;
  CFIndex v34;
  CFIndex v35;
  char *v36;
  size_t v37;
  CFIndex v38;
  CFTypeRef *v41;
  CFTypeRef *v42;
  UInt8 bytes;
  UInt8 v44[2];
  CFRange v45;
  CFRange v46;
  CFRange v47;

  if (!a1)
    return 0;
  if (CFStringGetLength(a1) >= 7 && CFStringGetLength(a1) <= 15)
  {
    v4 = CFCharacterSetCreateWithCharactersInString(0, CFSTR("0123456789."));
    InvertedSet = CFCharacterSetCreateInvertedSet(0, v4);
    Mutable = CFDataCreateMutable(0, 0);
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, a1, CFSTR("."));
    v8 = ArrayBySeparatingStrings;
    if (ArrayBySeparatingStrings)
      Count = CFArrayGetCount(ArrayBySeparatingStrings);
    else
      Count = 0;
    v45.length = CFStringGetLength(a1);
    v45.location = 0;
    if (CFStringFindCharacterFromSet(a1, InvertedSet, v45, 0x200uLL, 0) || CFArrayGetCount(v8) != 4)
    {
      v17 = 0;
      if (!Mutable)
        goto LABEL_24;
    }
    else
    {
      v41 = a2;
      if (Count < 1)
      {
LABEL_18:
        a2 = v41;
        if (v41)
          *v41 = CFRetain(Mutable);
        v17 = 1;
        if (!Mutable)
          goto LABEL_24;
      }
      else
      {
        v10 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, v10);
          if (ValueAtIndex)
          {
            v12 = ValueAtIndex;
            CFRetain(ValueAtIndex);
            Length = CFStringGetLength(v12);
            v14 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
            v15 = (char *)malloc_type_malloc(v14, 0x5ECC0363uLL);
            if (!CFStringGetCString(v12, v15, v14, 0x8000100u))
              *v15 = 0;
            CFRelease(v12);
          }
          else
          {
            v15 = strdup((const char *)&unk_18AA61AAF);
          }
          v16 = atoi(v15);
          free(v15);
          if (v16 > 255)
            break;
          bytes = v16;
          CFDataAppendBytes(Mutable, &bytes, 1);
          if (Count == ++v10)
            goto LABEL_18;
        }
        v17 = 0;
        a2 = v41;
        if (!Mutable)
        {
LABEL_24:
          if (v8)
            CFRelease(v8);
          if (v4)
            CFRelease(v4);
          if (InvertedSet)
          {
            CFRelease(InvertedSet);
            if ((v17 & 1) != 0)
              return 1;
          }
          else if ((v17 & 1) != 0)
          {
            return 1;
          }
          goto LABEL_32;
        }
      }
    }
    CFRelease(Mutable);
    goto LABEL_24;
  }
LABEL_32:
  v19 = CFStringGetLength(a1);
  if ((unint64_t)(v19 - 42) < 0xFFFFFFFFFFFFFFD8)
    return 0;
  v20 = v19;
  if (!CFStringHasPrefix(a1, CFSTR("["))
    || !CFStringHasSuffix(a1, CFSTR("]"))
    || (v46.length = v20 - 2, v46.location = 1, (v21 = CFStringCreateWithSubstring(0, a1, v46)) == 0)
    || (v22 = v21, MutableCopy = CFStringCreateMutableCopy(0, 0, v21), CFRelease(v22), !MutableCopy))
  {
    MutableCopy = CFStringCreateMutableCopy(0, 0, a1);
  }
  System = CFLocaleGetSystem();
  CFStringUppercase(MutableCopy, System);
  v25 = CFCharacterSetCreateWithCharactersInString(0, CFSTR("0123456789ABCDEF:"));
  v26 = CFCharacterSetCreateInvertedSet(0, v25);
  v27 = CFDataCreateMutable(0, 0);
  v28 = CFStringCreateArrayBySeparatingStrings(0, MutableCopy, CFSTR(":"));
  v29 = v28;
  if (v28)
    v30 = CFArrayGetCount(v28);
  else
    v30 = 0;
  v47.length = CFStringGetLength(MutableCopy);
  v47.location = 0;
  if (CFStringFindCharacterFromSet(MutableCopy, v26, v47, 0x200uLL, 0)
    || CFArrayGetCount(v29) < 3
    || CFArrayGetCount(v29) > 8)
  {
    goto LABEL_69;
  }
  v42 = a2;
  if (v30 >= 1)
  {
    for (i = 0; i != v30; ++i)
    {
      *(_WORD *)v44 = 0;
      v32 = (const __CFString *)CFArrayGetValueAtIndex(v29, i);
      if (v32)
      {
        v33 = v32;
        CFRetain(v32);
        v34 = CFStringGetLength(v33);
        v35 = CFStringGetMaximumSizeForEncoding(v34, 0x8000100u) + 1;
        v36 = (char *)malloc_type_malloc(v35, 0x5ECC0363uLL);
        if (!CFStringGetCString(v33, v36, v35, 0x8000100u))
          *v36 = 0;
        CFRelease(v33);
        if (!v36)
        {
LABEL_56:
          if (i && i != v30 - 1)
          {
            if ((unint64_t)v30 <= 8)
            {
              v38 = v30 - 9;
              do
                CFDataAppendBytes(v27, v44, 2);
              while (!__CFADD__(v38++, 1));
            }
            goto LABEL_64;
          }
          goto LABEL_63;
        }
      }
      else
      {
        v36 = strdup((const char *)&unk_18AA61AAF);
        if (!v36)
          goto LABEL_56;
      }
      v37 = strlen(v36);
      if (!v37)
        goto LABEL_56;
      if (v37 <= 4)
      {
        *(_WORD *)v44 = bswap32(strtoul(v36, 0, 16)) >> 16;
LABEL_63:
        CFDataAppendBytes(v27, v44, 2);
      }
LABEL_64:
      free(v36);
    }
  }
  if (CFDataGetLength(v27) != 16)
  {
LABEL_69:
    v18 = 0;
  }
  else
  {
    if (v42)
      *v42 = CFRetain(v27);
    v18 = 1;
  }
  if (v27)
    CFRelease(v27);
  if (v29)
    CFRelease(v29);
  if (v25)
    CFRelease(v25);
  if (v26)
    CFRelease(v26);
  if (MutableCopy)
    CFRelease(MutableCopy);
  return v18;
}

BOOL __sec_protocol_options_set_min_tls_protocol_version_block_invoke(uint64_t a1, _WORD *a2)
{
  if (a2)
    *a2 = *(_WORD *)(a1 + 32);
  return a2 != 0;
}

SecPolicyRef SecPolicyCreateSSL(Boolean server, CFStringRef hostname)
{
  return (SecPolicyRef)SecPolicyCreateSSL_internal(server, hostname, 0, 0);
}

CFTypeRef CFPropertyListCreateWithDERData(uint64_t a1, CFDataRef theData, uint64_t a3, _QWORD *a4, CFTypeRef *a5)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFTypeRef v19;
  char v21;
  CFTypeRef cf;

  cf = 0;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v11 = &BytePtr[Length];
  v15 = der_decode_plist(a1, (uint64_t)&cf, a5, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length], v12, v13, v14);
  if (!v15 || (const UInt8 *)v15 == v11)
  {
    if (a4)
      *a4 = 400;
  }
  else
  {
    SecCFCreateErrorWithFormat(-1, (const __CFString *)sSecDERErrorDomain, 0, a5, v16, CFSTR("trailing garbage after plist item"), v17, v18, v21);
    v19 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v19);
    }
  }
  return cf;
}

uint64_t SecTrustEvaluateInternal(__SecTrust *a1, _DWORD *a2)
{
  uint64_t result;
  NSObject *v5;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;

  if (a2)
    *a2 = 0;
  if (!a1)
    return 4294967246;
  result = SecTrustEvaluateIfNecessary(a1);
  if (!(_DWORD)result)
  {
    v7 = 0;
    v8 = &v7;
    v9 = 0x2000000000;
    v10 = 0;
    v5 = *((_QWORD *)a1 + 17);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __SecTrustEvaluateInternal_block_invoke;
    v6[3] = &unk_1E1FDAD28;
    v6[4] = &v7;
    v6[5] = a1;
    dispatch_sync(v5, v6);
    SecTrustLogFailureDescription(a1, *((_DWORD *)v8 + 6));
    if (a2)
      *a2 = *((_DWORD *)v8 + 6);
    _Block_object_dispose(&v7, 8);
    return 0;
  }
  return result;
}

CFErrorRef SecCreateCFErrorWithXPCObject(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFErrorRef v5;
  const char *string;
  uint64_t *v7;
  const __CFString *v8;
  int64_t int64;
  const void *data;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  CFTypeRef v16;
  size_t length;
  CFTypeRef cf;
  CFTypeRef v20;

  v20 = 0;
  if (MEMORY[0x18D7718B8]() != MEMORY[0x1E0C812F8])
  {
    SecCFCreateErrorWithFormat(1, (const __CFString *)sSecXPCErrorDomain, 0, &v20, v2, CFSTR("Remote error not dictionary!: %@"), v3, v4, (char)a1);
    return (CFErrorRef)v20;
  }
  string = xpc_dictionary_get_string(a1, "domain");
  v7 = (uint64_t *)MEMORY[0x1E0C9AE00];
  if (string)
  {
    v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], string, 0x8000100u);
  }
  else
  {
    v8 = (const __CFString *)sSecXPCErrorDomain;
    CFRetain((CFTypeRef)sSecXPCErrorDomain);
  }
  int64 = xpc_dictionary_get_int64(a1, "code");
  length = 0;
  cf = 0;
  data = xpc_dictionary_get_data(a1, "userinfo", &length);
  if (data)
  {
    v14 = (size_t)data + length;
    v15 = der_decode_plist(*v7, (uint64_t)&cf, 0, (uint64_t)data, (uint64_t)data + length, v11, v12, v13);
    v16 = cf;
    if (v15 == v14)
    {
      v5 = CFErrorCreate(0, v8, int64, (CFDictionaryRef)cf);
      if (v16)
        CFRelease(v16);
      goto LABEL_11;
    }
    if (cf)
      CFRelease(cf);
  }
  v5 = CFErrorCreate(0, v8, int64, 0);
LABEL_11:
  if (v8)
    CFRelease(v8);
  return v5;
}

uint64_t __handle_trust_evaluate_xpc_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  const void **v6;
  const void *v7;
  const void **v8;
  const void *v9;
  const void **v10;
  const void *v11;
  uint64_t result;
  int NonZeroInteger;

  v6 = *(const void ***)(a1 + 40);
  v7 = *v6;
  if (*v6)
  {
    *v6 = 0;
    CFRelease(v7);
  }
  v8 = *(const void ***)(a1 + 48);
  v9 = *v8;
  if (*v8)
  {
    *v8 = 0;
    CFRelease(v9);
  }
  v10 = *(const void ***)(a1 + 56);
  v11 = *v10;
  if (*v10)
  {
    *v10 = 0;
    CFRelease(v11);
  }
  result = SecXPCDictionaryCopyArrayOptional(a2, "details", *(_QWORD **)(a1 + 40), a3);
  if ((_DWORD)result)
  {
    result = SecXPCDictionaryCopyDictionaryOptional(a2, "info", *(_QWORD **)(a1 + 48), a3);
    if ((_DWORD)result)
    {
      result = SecXPCDictionaryCopyChainOptional(a2, *(CFMutableArrayRef **)(a1 + 56), a3);
      if ((_DWORD)result)
      {
        NonZeroInteger = SecXPCDictionaryGetNonZeroInteger(a2, a3);
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = NonZeroInteger;
        return NonZeroInteger != 0;
      }
    }
  }
  return result;
}

void __handle_trust_evaluate_xpc_async_block_invoke_2(uint64_t a1, void *a2, uint64_t a3)
{
  const void **v5;
  const void *v6;
  const void **v7;
  const void *v8;
  const void **v9;
  const void *v10;
  CFTypeRef v11;
  CFTypeRef cf;

  if (!a2 || a3)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }
  else
  {
    v5 = *(const void ***)(a1 + 40);
    v6 = *v5;
    if (*v5)
    {
      *v5 = 0;
      CFRelease(v6);
    }
    v7 = *(const void ***)(a1 + 48);
    v8 = *v7;
    if (*v7)
    {
      *v7 = 0;
      CFRelease(v8);
    }
    v9 = *(const void ***)(a1 + 56);
    v10 = *v9;
    if (*v9)
    {
      *v9 = 0;
      CFRelease(v10);
    }
    cf = 0;
    if (SecXPCDictionaryCopyArrayOptional(a2, "details", *(_QWORD **)(a1 + 40), (__CFString **)&cf)
      && SecXPCDictionaryCopyDictionaryOptional(a2, "info", *(_QWORD **)(a1 + 48), (__CFString **)&cf)
      && SecXPCDictionaryCopyChainOptional(a2, *(CFMutableArrayRef **)(a1 + 56), (__CFString **)&cf))
    {
      SecXPCDictionaryGetNonZeroInteger(a2, (__CFString **)&cf);
    }
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    v11 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v11);
    }
  }
}

int64_t SecXPCDictionaryGetNonZeroInteger(void *a1, __CFString **a2)
{
  int64_t int64;
  int64_t v4;

  int64 = xpc_dictionary_get_int64(a1, "result");
  v4 = int64;
  if (int64)
  {
    if (int64 < 0)
      SecError(-26276, a2, CFSTR("object for key %s is negative"), "result");
  }
  else
  {
    SecError(-26276, a2, CFSTR("object for key %s is 0"), "result");
  }
  return v4;
}

uint64_t SecXPCDictionaryCopyChainOptional(void *a1, CFMutableArrayRef *a2, __CFString **a3)
{
  xpc_object_t value;
  void *v6;
  unint64_t count;
  unint64_t v8;
  CFMutableArrayRef Mutable;
  size_t i;
  _QWORD *v11;
  const void *v12;
  CFMutableArrayRef v13;

  value = xpc_dictionary_get_value(a1, "chain");
  if (!value)
  {
    *a2 = 0;
    return 1;
  }
  v6 = value;
  if (MEMORY[0x18D7718B8]() == MEMORY[0x1E0C812C8])
  {
    count = xpc_array_get_count(v6);
    if (count)
    {
      v8 = count;
      if (count < 0x7FFFFFFFFFFFFFFFLL)
      {
        Mutable = CFArrayCreateMutable(0, count, MEMORY[0x1E0C9B378]);
        for (i = 0; i != v8; ++i)
        {
          v11 = SecCertificateCreateWithXPCArrayAtIndex(v6, i, a3);
          if (!v11)
          {
            if (Mutable)
              CFRelease(Mutable);
            return 0;
          }
          v12 = v11;
          CFArrayAppendValue(Mutable, v11);
          CFRelease(v12);
        }
        if (!Mutable)
          return 0;
        v13 = *a2;
        if (*a2)
        {
          *a2 = 0;
          CFRelease(v13);
        }
        *a2 = Mutable;
        return 1;
      }
      SecError(-26275, a3, CFSTR("xpc_path array count > LONG_MAX"));
    }
    else
    {
      SecError(-26275, a3, CFSTR("xpc_path array count == 0"));
    }
  }
  else
  {
    SecError(-26275, a3, CFSTR("xpc_path value is not an array"));
  }
  return 0;
}

BOOL SecXPCDictionaryCopyArrayOptional(void *a1, char *a2, _QWORD *a3, __CFString **a4)
{
  void *value;
  _BOOL8 v9;

  value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    value = (void *)SecXPCDictionaryCopyArray(a1, a2, a4);
    v9 = value != 0;
  }
  else
  {
    v9 = 1;
  }
  *a3 = value;
  return v9;
}

BOOL SecXPCDictionaryCopyDictionaryOptional(void *a1, char *a2, _QWORD *a3, __CFString **a4)
{
  void *value;
  _BOOL8 v9;

  value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    value = (void *)SecXPCDictionaryCopyDictionaryAndPossiblyMutateMessage(1, a1, a2, a4);
    v9 = value != 0;
  }
  else
  {
    v9 = 1;
  }
  *a3 = value;
  return v9;
}

const void *SecXPCDictionaryCopyDictionaryAndPossiblyMutateMessage(int a1, void *a2, char *a3, __CFString **a4)
{
  CFTypeRef v6;
  const void *v7;
  CFTypeID v8;
  CFStringRef v9;

  v6 = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(a1, a2, a3, a4);
  v7 = v6;
  if (v6)
  {
    v8 = CFGetTypeID(v6);
    if (v8 != CFDictionaryGetTypeID())
    {
      v9 = CFCopyTypeIDDescription(v8);
      SecError(-50, a4, CFSTR("object for key %s not dictionary but %@"), a3, v9);
      if (v9)
        CFRelease(v9);
      CFRelease(v7);
      return 0;
    }
  }
  return v7;
}

const void *SecXPCDictionaryCopyArray(void *a1, char *a2, __CFString **a3)
{
  CFTypeRef v5;
  const void *v6;
  CFTypeID v7;
  CFStringRef v8;

  v5 = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(1, a1, a2, a3);
  v6 = v5;
  if (v5)
  {
    v7 = CFGetTypeID(v5);
    if (v7 != CFArrayGetTypeID())
    {
      v8 = CFCopyTypeIDDescription(v7);
      SecError(-50, a3, CFSTR("object for key %s not array but %@"), a2, v8);
      if (v8)
        CFRelease(v8);
      CFRelease(v6);
      return 0;
    }
  }
  return v6;
}

BOOL SecXPCDictionaryCopyPListOptional(void *a1, _QWORD *a2, __CFString **a3)
{
  const void *data;
  _BOOL8 v7;
  size_t length;

  length = 0;
  data = xpc_dictionary_get_data(a1, "status", &length);
  if (data)
  {
    data = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(1, a1, "status", a3);
    v7 = data != 0;
  }
  else
  {
    v7 = 1;
  }
  *a2 = data;
  return v7;
}

_QWORD *SecAccessControlCreateFromData(const __CFAllocator *a1, const __CFData *a2, __CFString **a3)
{
  _QWORD *v5;
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v15;

  v5 = (_QWORD *)SecAccessControlCreate(a1, a3);
  if (v5)
  {
    v15 = 0;
    BytePtr = CFDataGetBytePtr(a2);
    Length = CFDataGetLength(a2);
    v8 = &BytePtr[Length];
    v12 = der_decode_plist(0, (uint64_t)&v15, (CFTypeRef *)a3, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length], v9, v10, v11);
    if (!v12)
    {
LABEL_5:
      CFRelease(v5);
      return 0;
    }
    if ((const UInt8 *)v12 != v8)
    {
      SecError(-26275, a3, CFSTR("trailing garbage at end of SecAccessControl data"));
      goto LABEL_5;
    }
    v13 = (const void *)v5[2];
    if (v13)
      CFRelease(v13);
    v5[2] = v15;
  }
  return v5;
}

unint64_t der_encode_generalizedtime_body_repair(CFTypeRef *a1, int a2, uint64_t a3, unint64_t a4, double a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  __CFString *v14;
  NSObject *v15;
  const char *v16;
  CFErrorRef v17;
  unint64_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unint64_t v26;
  _BYTE *v27;
  char v28;
  CFTypeRef *v29;
  int v30;
  size_t v31;
  void *v32;
  int v33;
  NSObject *v34;
  CFTypeRef v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unsigned int v40;
  unint64_t v41;
  char v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  CFErrorRef err;
  CFErrorRef *p_err;
  uint64_t v52;
  char v53;
  int v54;
  int v55;
  _BYTE buf[24];
  void *v57;
  CFErrorRef *v58;
  double v59;
  char *v60;
  uint64_t *v61;
  char *v62;
  uint64_t *v63;
  char *v64;
  uint64_t *v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v48 = 0;
  v49 = 0;
  v47 = 0;
  err = 0;
  p_err = &err;
  v52 = 0x2000000000;
  v53 = -86;
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = __SecAbsoluteTimeGetGregorianDate_block_invoke;
  v57 = &unk_1E1FDC148;
  v58 = &err;
  v59 = a5;
  v60 = (char *)&v49 + 4;
  v61 = &v49;
  v62 = (char *)&v48 + 4;
  v63 = &v48;
  v64 = (char *)&v47 + 4;
  v65 = &v47;
  SecCFCalendarDoWithZuluCalendar((uint64_t)buf);
  if (*((_BYTE *)p_err + 24))
  {
    _Block_object_dispose(&err, 8);
  }
  else
  {
    SecCFCreateErrorWithFormat(-1, (const __CFString *)sSecDERErrorDomain, 0, a1, v10, CFSTR("Failed to encode date."), v11, v12, v43);
    v13 = *((unsigned __int8 *)p_err + 24);
    _Block_object_dispose(&err, 8);
    if (!v13)
    {
      v34 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
          v35 = *a1;
        else
          v35 = 0;
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)&buf[4] = v35;
        _os_log_impl(&dword_18A900000, v34, OS_LOG_TYPE_DEFAULT, "der: unable to encode date: %@", buf, 0xCu);
      }
      return 0;
    }
  }
  err = 0;
  if ((validateDateComponents(HIDWORD(v49), v49, HIDWORD(v48), v48, HIDWORD(v47), v47, 0, (__CFString **)&err) & 1) == 0)
  {
    v14 = (__CFString *)CFErrorCopyDescription(err);
    __security_simulatecrash(v14, 0x53C00002u);
    if (v14)
      CFRelease(v14);
    v15 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = "continuing";
      if (a2)
        v16 = "setting default value";
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = err;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v16;
      _os_log_impl(&dword_18A900000, v15, OS_LOG_TYPE_DEFAULT, "der: invalid date: %@; %s", buf, 0x16u);
    }
    v17 = err;
    if (err)
    {
      err = 0;
      CFRelease(v17);
    }
    if (a2)
    {
      v49 = 0x7D100000001;
      HIDWORD(v48) = 1;
      HIDWORD(v47) = 1;
    }
  }
  if (a3 + 1 <= a4)
  {
    *(_BYTE *)(a4 - 1) = 90;
    v18 = a4 - 1;
  }
  else
  {
    v18 = 0;
  }
  v20 = v49;
  v19 = HIDWORD(v49);
  v21 = HIDWORD(v47);
  v45 = HIDWORD(v48);
  v46 = v48;
  v22 = v47;
  v54 = -1431655766;
  v55 = -1431655766;
  *(_QWORD *)buf = 0xAAAAAAAAAAAAAAAALL;
  v23 = __dtoa();
  v24 = v55;
  v25 = *(_QWORD *)buf;
  if (a5 < 0.0)
  {
    v26 = v23 + (v55 & ~(v55 >> 31));
    if (v26 < *(_QWORD *)buf)
    {
      v27 = (_BYTE *)(*(_QWORD *)buf - 1);
      for (*v27 = 106 - *(_BYTE *)(*(_QWORD *)buf - 1); (unint64_t)v27 > v26; *v27 = 105 - v28)
        v28 = *--v27;
    }
    v24 = v55;
    v25 = *(_QWORD *)buf;
  }
  if (v25 - v23 > v24)
  {
    if ((v24 & 0x80000000) == 0)
    {
      v18 = ccder_encode_body();
LABEL_31:
      if (a3 + 1 <= v18)
        *(_BYTE *)--v18 = 46;
      else
        v18 = 0;
      goto LABEL_38;
    }
    v44 = v20;
    v29 = a1;
    v30 = v19;
    ccder_encode_body();
    v31 = -(uint64_t)v55;
    v32 = (void *)ccder_encode_body_nocopy();
    v18 = (unint64_t)v32;
    if (v32)
    {
      if (a5 >= 0.0)
        v33 = 48;
      else
        v33 = 57;
      memset(v32, v33, v31);
      v19 = v30;
      a1 = v29;
      v20 = v44;
      goto LABEL_31;
    }
    v19 = v30;
    a1 = v29;
    v20 = v44;
  }
LABEL_38:
  __freedtoa();
  if (v18)
  {
    v39 = a3 + 2;
    if (a3 + 2 <= v18)
    {
      *(_BYTE *)(v18 - 2) = v22 / 10 + 48;
      *(_BYTE *)(v18 - 1) = v22 % 10 + 48;
      if (v39 <= v18 - 2)
      {
        *(_BYTE *)(v18 - 4) = v21 / 10 + 48;
        *(_BYTE *)(v18 - 3) = v21 % 10 + 48;
        if (v39 <= v18 - 4)
        {
          *(_BYTE *)(v18 - 6) = v46 / 10 + 48;
          *(_BYTE *)(v18 - 5) = v46 % 10 + 48;
          if (v39 <= v18 - 6)
          {
            *(_BYTE *)(v18 - 8) = v45 / 10 + 48;
            *(_BYTE *)(v18 - 7) = v45 % 10 + 48;
            if (v39 <= v18 - 8)
            {
              *(_BYTE *)(v18 - 10) = v20 / 10 + 48;
              *(_BYTE *)(v18 - 9) = v20 % 10 + 48;
              if (v39 <= v18 - 10)
              {
                v40 = (((103 * (v19 % 100)) >> 15) & 1) + ((103 * (v19 % 100)) >> 10);
                *(_BYTE *)(v18 - 12) = v40 + 48;
                *(_BYTE *)(v18 - 11) = v19 % 100 - 10 * v40 + 48;
                if (v39 <= v18 - 12)
                {
                  *(_BYTE *)(v18 - 14) = v19 / 1000 + 48;
                  v41 = v18 - 14;
                  *(_BYTE *)(v41 + 1) = v19 / 100 % 10 + 48;
                  return v41;
                }
              }
            }
          }
        }
      }
    }
  }
  SecCFCreateErrorWithFormat(-7, (const __CFString *)sSecDERErrorDomain, 0, a1, v36, CFSTR("ccder failed to encode"), v37, v38, v43);
  return 0;
}

CFTypeRef SecXPCDictionaryCopyPListAndPossiblyMutateMessage(int a1, xpc_object_t xdict, char *key, __CFString **a4)
{
  const void *data;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __CFString *v13;
  NSObject *v14;
  __CFString *v15;
  CFTypeRef v16;
  size_t length;
  CFTypeRef cf;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  length = 0;
  cf = 0;
  data = xpc_dictionary_get_data(xdict, key, &length);
  if (data)
  {
    v11 = (uint64_t)data;
    v12 = (uint64_t)data + length;
    if (SecCFAllocatorZeroize_sOnce != -1)
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
    if (der_decode_plist(SecCFAllocatorZeroize_sAllocator, (uint64_t)&cf, (CFTypeRef *)a4, v11, v12, v8, v9, v10) != v12)
    {
      v13 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("trailing garbage after der decoded object for key %s"), key);
      SecError(-50, a4, CFSTR("%@"), v13);
      if (a4)
      {
        v14 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          v15 = *a4;
          *(_DWORD *)buf = 138412290;
          v21 = v15;
          _os_log_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEFAULT, "xpc: %@", buf, 0xCu);
        }
      }
      __security_simulatecrash(v13, 0x53C00002u);
      if (v13)
        CFRelease(v13);
      v16 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v16);
      }
    }
    if (a1)
      cc_clear();
    return cf;
  }
  else
  {
    SecError(-50, a4, CFSTR("no object for key %s"), key);
    return 0;
  }
}

uint64_t der_decode_dictionary(const __CFAllocator *a1, CFMutableDictionaryRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFMutableDictionaryRef Mutable;
  char v20;
  uint64_t v21;

  if (a4)
  {
    v14 = ccder_decode_constructed_tl();
    if (v14)
    {
      Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        CFRelease(Mutable);
      }
      else
      {
        SecCFCreateErrorWithFormat(-3, (const __CFString *)sSecDERErrorDomain, 0, a3, v15, CFSTR("Failed to create dictionary"), v16, v17, 0);
        v14 = 0;
        if (!v21)
          *a2 = Mutable;
      }
    }
    else
    {
      SecCFCreateErrorWithFormat(-1, (const __CFString *)sSecDERErrorDomain, 0, a3, v11, CFSTR("Unknown data encoding, expected CCDER_CONSTRUCTED_SET"), v12, v13, 0);
    }
  }
  else
  {
    SecCFCreateErrorWithFormat(-6, (const __CFString *)sSecDERErrorDomain, 0, a3, a5, CFSTR("null input"), a7, a8, v20);
    return 0;
  }
  return v14;
}

uint64_t der_decode_plist(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFString *v13;
  const __CFString *v14;
  CFIndex v15;
  char v17;

  v8 = a4;
  if (a4)
  {
    if (ccder_decode_tag())
    {
      v13 = (const __CFString *)sSecDERErrorDomain;
      v14 = CFSTR("Unsupported DER Type");
      v15 = -2;
    }
    else
    {
      v13 = (const __CFString *)sSecDERErrorDomain;
      v14 = CFSTR("invalid tag");
      v15 = -1;
    }
    SecCFCreateErrorWithFormat(v15, v13, 0, a3, v10, v14, v11, v12, 170);
    return 0;
  }
  else
  {
    SecCFCreateErrorWithFormat(-6, (const __CFString *)sSecDERErrorDomain, 0, a3, a5, CFSTR("null input"), a7, a8, v17);
  }
  return v8;
}

const UInt8 *der_decode_string(const __CFAllocator *a1, CFStringRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const UInt8 *v12;
  const UInt8 *v13;
  const __CFString *v14;
  const __CFString *v15;
  CFIndex v16;
  CFStringRef v18;
  char v19;

  if (a4)
  {
    v12 = (const UInt8 *)ccder_decode_tl();
    if (v12 && (v13 = v12, a5 - (uint64_t)v12 >= 0))
    {
      v18 = CFStringCreateWithBytes(a1, v12, 0, 0x8000100u, 0);
      *a2 = v18;
      if (v18)
        return v13;
      v14 = (const __CFString *)sSecDERErrorDomain;
      v15 = CFSTR("String allocation failed");
      v16 = -3;
    }
    else
    {
      v14 = (const __CFString *)sSecDERErrorDomain;
      v15 = CFSTR("Unknown string encoding");
      v16 = -1;
    }
  }
  else
  {
    v14 = (const __CFString *)sSecDERErrorDomain;
    v15 = CFSTR("null input");
    v16 = -6;
  }
  SecCFCreateErrorWithFormat(v16, v14, 0, a3, a5, v15, a7, a8, v19);
  return 0;
}

const UInt8 *der_decode_data(const __CFAllocator *a1, CFDataRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const UInt8 *v12;
  const UInt8 *v13;
  const __CFString *v14;
  const __CFString *v15;
  CFIndex v16;
  CFDataRef v18;
  char v19;

  if (a4)
  {
    v12 = (const UInt8 *)ccder_decode_tl();
    if (v12 && (v13 = v12, a5 - (uint64_t)v12 >= 0))
    {
      v18 = CFDataCreate(a1, v12, 0);
      *a2 = v18;
      if (v18)
        return v13;
      v14 = (const __CFString *)sSecDERErrorDomain;
      v15 = CFSTR("Failed to create data");
      v16 = -3;
    }
    else
    {
      v14 = (const __CFString *)sSecDERErrorDomain;
      v15 = CFSTR("Unknown data encoding");
      v16 = -1;
    }
  }
  else
  {
    v14 = (const __CFString *)sSecDERErrorDomain;
    v15 = CFSTR("null input");
    v16 = -6;
  }
  SecCFCreateErrorWithFormat(v16, v14, 0, a3, a5, v15, a7, a8, v19);
  return 0;
}

unint64_t der_decode_date(const __CFAllocator *a1, CFDateRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  CFDateRef v39;
  const __CFString *v40;
  const __CFString *v41;
  CFIndex v42;
  char v44;
  CFAbsoluteTime at;
  unint64_t v46;
  unsigned __int8 *v47;

  v46 = a5;
  if (!a4)
  {
    v40 = (const __CFString *)sSecDERErrorDomain;
    v41 = CFSTR("null input");
    v42 = -6;
    goto LABEL_6;
  }
  at = 0.0;
  v47 = (unsigned __int8 *)ccder_decode_constructed_tl();
  v16 = der_decode_decimal(&v47, v46, a3, v11, v12, v13, v14, v15);
  v22 = der_decode_decimal(&v47, v46, a3, v17, v18, v19, v20, v21) + 10 * v16;
  v28 = der_decode_decimal(&v47, v46, a3, v23, v24, v25, v26, v27);
  v34 = der_decode_decimal(&v47, v46, a3, v29, v30, v31, v32, v33);
  v38 = der_decode_commontime_body(&at, a3, v34 + 10 * v28 + 100 * v22, v47, v46, v35, v36, v37);
  if (v38)
  {
    v39 = CFDateCreate(a1, at);
    *a2 = v39;
    if (!v39)
    {
      v40 = (const __CFString *)sSecDERErrorDomain;
      v41 = CFSTR("Failed to create date");
      v42 = -3;
LABEL_6:
      SecCFCreateErrorWithFormat(v42, v40, 0, a3, a5, v41, a7, a8, v44);
      return 0;
    }
  }
  return v38;
}

unint64_t der_decode_commontime_body(double *a1, CFTypeRef *a2, unsigned int a3, unsigned __int8 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  unsigned __int8 *v67;
  unsigned __int8 *v68;
  double v69;
  int v70;
  unsigned __int8 *v71;
  const __CFString *v72;
  const __CFString *v73;
  int v74;
  CFIndex v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  int v79;
  int v80;
  double v81;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  double v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  unsigned __int8 *v114;
  _QWORD v115[6];
  unsigned int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  uint64_t v121;
  int v122;
  double *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t *v127;
  uint64_t v128;
  char v129;
  _DWORD v130[3];

  v8 = a5;
  v114 = a4;
  v111 = der_decode_decimal(&v114, a5, a2, (uint64_t)a4, a5, a6, a7, a8);
  v110 = der_decode_decimal(&v114, v8, a2, v10, v11, v12, v13, v14);
  v109 = der_decode_decimal(&v114, v8, a2, v15, v16, v17, v18, v19);
  v25 = der_decode_decimal(&v114, v8, a2, v20, v21, v22, v23, v24);
  v31 = der_decode_decimal(&v114, v8, a2, v26, v27, v28, v29, v30);
  v37 = der_decode_decimal(&v114, v8, a2, v32, v33, v34, v35, v36);
  v43 = der_decode_decimal(&v114, v8, a2, v38, v39, v40, v41, v42);
  v49 = der_decode_decimal(&v114, v8, a2, v44, v45, v46, v47, v48);
  v55 = der_decode_decimal(&v114, v8, a2, v50, v51, v52, v53, v54);
  v66 = der_decode_decimal(&v114, v8, a2, v56, v57, v58, v59, v60);
  v67 = 0;
  v68 = v114;
  v69 = NAN;
  if (!v114 || (unint64_t)v114 >= v8)
    goto LABEL_24;
  v70 = *v114;
  if (v70 == 46)
  {
    v71 = v114 + 1;
    if ((unint64_t)(v114 + 1) < v8)
    {
      v70 = *v71;
      if ((v70 - 58) < 0xFFFFFFF6)
      {
        v72 = (const __CFString *)sSecDERErrorDomain;
        v73 = CFSTR("fraction without digits");
LABEL_14:
        v75 = -1;
LABEL_23:
        SecCFCreateErrorWithFormat(v75, v72, 0, a2, v62, v73, v64, v65, v107);
        v67 = 0;
        goto LABEL_24;
      }
      v76 = 0;
      v77 = v8 - (_QWORD)v114 - 2;
      v78 = 1;
      while (v77)
      {
        v79 = v70;
        if (v78 < 0x1999999999999999)
        {
          v78 *= 10;
          v76 = (v70 - 48) + 10 * v76;
        }
        v80 = *++v71;
        v70 = v80;
        --v77;
        if ((v80 - 58) < 0xFFFFFFF6)
        {
          if (v79 == 48)
          {
            v72 = (const __CFString *)sSecDERErrorDomain;
            v73 = CFSTR("fraction ends in 0");
            goto LABEL_14;
          }
          v69 = (double)(unint64_t)v76 / (double)v78;
          v68 = v71;
          goto LABEL_8;
        }
      }
    }
    v72 = (const __CFString *)sSecDERErrorDomain;
    v73 = CFSTR("overflow");
    v75 = -8;
    goto LABEL_23;
  }
  v69 = 0.0;
LABEL_8:
  if ((unint64_t)v68 >= v8)
  {
    v72 = (const __CFString *)sSecDERErrorDomain;
    v73 = CFSTR("Unexpected end of datetime");
    goto LABEL_14;
  }
  v67 = v68 + 1;
  v114 = v68 + 1;
  switch(v70)
  {
    case 'Z':
      v81 = 0.0;
      goto LABEL_26;
    case '-':
      v74 = -60;
      break;
    case '+':
      v74 = 60;
      break;
    default:
LABEL_24:
      SecCFCreateErrorWithFormat(-1, (const __CFString *)sSecDERErrorDomain, 0, a2, v62, CFSTR("Invalid datetime character"), v64, v65, v107);
      v81 = NAN;
      goto LABEL_25;
  }
  v108 = v74;
  v90 = der_decode_decimal(&v114, v8, a2, v61, v62, v63, v64, v65);
  v107 = der_decode_decimal(&v114, v8, a2, v91, v92, v93, v94, v95) + 10 * v90;
  v101 = der_decode_decimal(&v114, v8, a2, v96, v97, v98, v99, v100);
  v81 = (double)(int)((der_decode_decimal(&v114, v8, a2, v102, v103, v104, v105, v106) + 10 * v101 + 60 * v107) * v108);
  v67 = v114;
LABEL_25:
  if (!v67)
    return 0;
LABEL_26:
  if (v67 != (unsigned __int8 *)v8)
  {
    SecCFCreateErrorWithFormat(-1, (const __CFString *)sSecDERErrorDomain, 0, a2, v62, CFSTR("trailing garbage at end of datetime"), v64, v65, v107);
    return 0;
  }
  v83 = (v25 + 10 * v109);
  v84 = (v37 + 10 * v31);
  v85 = (v49 + 10 * v43);
  v130[0] = 0;
  if ((validateDateComponents(a3, (v110 + 10 * v111), v83, v84, v85, (v66 + 10 * v55), v130, (__CFString **)a2) & 1) != 0)
  {
    v126 = 0;
    v127 = &v126;
    v128 = 0x2000000000;
    v129 = 0;
    v122 = 0;
    v123 = (double *)((char *)&v121 + 4);
    v124 = 0x2000000000;
    v125 = 0;
    v115[0] = MEMORY[0x1E0C809B0];
    v115[1] = 0x40000000;
    v115[2] = __SecGregorianDateGetAbsoluteTime_block_invoke;
    v115[3] = &unk_1E1FDC120;
    v115[4] = &v126;
    v115[5] = (char *)&v121 + 4;
    v116 = a3;
    v117 = v110 + 10 * v111;
    v118 = v83;
    v119 = v84;
    v120 = v85;
    v121 = (v66 + 10 * v55);
    SecCFCalendarDoWithZuluCalendar((uint64_t)v115);
    if (*((_BYTE *)v127 + 24))
    {
      v89 = v123[3] - v81;
    }
    else
    {
      SecCFCreateErrorWithFormat(-1, (const __CFString *)sSecDERErrorDomain, 0, a2, v86, CFSTR("Failed to encode date from components"), v87, v88, v107);
      v89 = NAN;
    }
    _Block_object_dispose((char *)&v121 + 4, 8);
    _Block_object_dispose(&v126, 8);
    *a1 = v89;
    *a1 = v69 + v89;
  }
  else
  {
    v8 = 0;
    *a1 = NAN;
  }
  return v8;
}

uint64_t der_decode_decimal(unsigned __int8 **a1, unint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 *v10;
  int v11;
  int v12;
  char v14;

  v10 = *a1;
  if (*a1)
  {
    if ((unint64_t)v10 >= a2)
    {
      SecCFCreateErrorWithFormat(-1, (const __CFString *)sSecDERErrorDomain, 0, a3, a5, CFSTR("Unexpected end of datetime"), a7, a8, v14);
      *a1 = 0;
    }
    else
    {
      v12 = *v10;
      v11 = v12;
      *a1 = v10 + 1;
      if (((v12 << 24) - 956301313) > 0xF6FFFFFE)
        return (v11 - 48);
    }
  }
  SecCFCreateErrorWithFormat(-1, (const __CFString *)sSecDERErrorDomain, 0, a3, a5, CFSTR("Not a decimal digit"), a7, a8, v14);
  *a1 = 0;
  return 0xFFFFFFFFLL;
}

void SecCFCalendarDoWithZuluCalendar(uint64_t a1)
{
  _QWORD block[5];

  if (SecCFCalendarGetZuluQueue_onceToken != -1)
    dispatch_once(&SecCFCalendarGetZuluQueue_onceToken, &__block_literal_global_12793);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecCFCalendarDoWithZuluCalendar_block_invoke;
  block[3] = &unk_1E1FDBF20;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)fqueue_cf, block);
}

uint64_t validateDateComponents(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7, __CFString **a8)
{
  _BOOL8 v8;
  unint64_t v9;
  unint64_t v10;

  if ((a1 & 3) != 0)
  {
    v8 = 0;
  }
  else
  {
    HIDWORD(v9) = -1030792151 * a1 + 85899344;
    LODWORD(v9) = HIDWORD(v9);
    if ((v9 >> 2) <= 0x28F5C28)
    {
      HIDWORD(v10) = -1030792151 * a1 + 85899344;
      LODWORD(v10) = HIDWORD(v10);
      v8 = (v10 >> 4) < 0xA3D70B;
    }
    else
    {
      v8 = 1;
    }
  }
  if (a7)
    *a7 = v8;
  if ((int)a6 <= 61
    && (int)a5 <= 59
    && (int)a4 <= 23
    && (a2 - 13) >= 0xFFFFFFF4
    && (a3 - 32) >= 0xFFFFFFE1
    && ((_DWORD)a2 != 2 || (v8 | 0x1C) >= a3)
    && ((_DWORD)a2 == 2 || mdays[a2] - mdays[(a2 - 1)] >= (int)a3))
  {
    return 1;
  }
  SecError(-1, a8, CFSTR("Invalid date: %i, %i, %i, %i, %i, %i, %i"), a1, a2, a3, a4, a5, a6, v8);
  return 0;
}

uint64_t der_decode_number(const __CFAllocator *a1, CFNumberRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  const __CFString *v15;
  CFIndex v16;
  CFNumberRef v17;
  uint64_t v19;
  uint64_t v20;

  if (a4)
  {
    v20 = 0;
    v12 = ccder_decode_tl();
    if (v12 && (v13 = v12, a5 - v12 >= v20))
    {
      v19 = 0;
      v17 = CFNumberCreate(a1, kCFNumberLongLongType, &v19);
      *a2 = v17;
      if (v17)
        return v13 + v20;
      v14 = (const __CFString *)sSecDERErrorDomain;
      v15 = CFSTR("Number allocation failed");
      v16 = -3;
    }
    else
    {
      v14 = (const __CFString *)sSecDERErrorDomain;
      v15 = CFSTR("Unknown number encoding");
      v16 = -1;
    }
  }
  else
  {
    v14 = (const __CFString *)sSecDERErrorDomain;
    v15 = CFSTR("null input");
    v16 = -6;
  }
  SecCFCreateErrorWithFormat(v16, v14, 0, a3, a5, v15, a7, a8, v19);
  return 0;
}

uint64_t SecAccessControlCreate(const __CFAllocator *a1, __CFString **a2)
{
  uint64_t Instance;

  SecAccessControlGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
    *(_QWORD *)(Instance + 16) = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  else
    SecError(-108, a2, CFSTR("allocate memory for SecAccessControl"));
  return Instance;
}

CFTypeID SecAccessControlGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __SecAccessControlGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SecAccessControlGetTypeID_sSecAccessControlGetTypeIDSingleton;
  if (SecAccessControlGetTypeID_sSecAccessControlGetTypeIDOnce != -1)
    dispatch_once(&SecAccessControlGetTypeID_sSecAccessControlGetTypeIDOnce, block);
  return SecAccessControlGetTypeID_sSecAccessControlGetTypeIDSingleton;
}

void SecTrustLogFailureDescription(__SecTrust *a1, int a2)
{
  __CFString *v2;
  NSObject *v3;
  int v4;
  __CFString *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a2 != 1 && a2 != 4)
  {
    v2 = SecTrustCopyFailureDescription(a1);
    v3 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = 138543362;
      v5 = v2;
      _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "Trust evaluate failure:%{public}@", (uint8_t *)&v4, 0xCu);
    }
    CFRelease(v2);
  }
}

uint64_t SecCMSVerifySignedData_internal(const __CFData *a1, const __CFData *a2, void *a3, SecTrustRef *a4, const __CFArray *a5, uint64_t *a6, const __CFDictionary **a7)
{
  uint64_t *p_cf2;
  CFTypeRef *p_cf;
  __SecTrust **v16;
  uint64_t BytePtr;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t OID;
  uint64_t v23;
  CFTypeRef v24;
  CFTypeRef v25;
  const __CFDictionary *v26;
  __SecTrust *v27;
  CFTypeRef v28;
  CFTypeRef v29;
  CFTypeRef v30;
  uint64_t v31;
  uint64_t started;
  int v33;
  CFIndex Length;
  const void *v35;
  _QWORD *v36;
  uint64_t *v37;
  int v38;
  uint64_t v39;
  CFAllocatorRef *v40;
  uint64_t InnerContent;
  const __CFAllocator *v42;
  uint64_t *v43;
  uint64_t v44;
  CFDataRef v45;
  CFDataRef v46;
  uint64_t v47;
  __CFArray *Mutable;
  uint64_t *v49;
  uint64_t v50;
  uint64_t *v51;
  CFDataRef v52;
  CFDataRef v53;
  uint64_t v54;
  __CFArray *v55;
  __CFArray *v56;
  CFIndex Count;
  uint64_t v58;
  uint64_t *v59;
  __CFArray *v60;
  uint64_t v61;
  uint64_t *v62;
  _QWORD *v63;
  const void *v64;
  uint64_t v65;
  double v66;
  int v67;
  CFDateRef v68;
  CFDateRef v69;
  BOOL v70;
  double v71;
  BOOL v72;
  int v73;
  CFDateRef v74;
  CFDateRef v75;
  NSObject *v76;
  uint64_t v77;
  SecTrustRef *v78;
  const __CFDictionary *v79;
  NSObject *v80;
  const __CFDictionary *v81;
  __SecTrust *v82;
  __SecTrust *v83;
  const void *v84;
  CFAbsoluteTime v85;
  NSObject *v86;
  SecTrustRef v87;
  NSObject *v88;
  CFTypeRef v89;
  CFTypeRef v90;
  CFTypeRef v91;
  const void *ValueAtIndex;
  const void *v94;
  const void *v95;
  void *v96;
  CFArrayRef v97;
  int v98;
  CFAbsoluteTime v99;
  double VerifyTime;
  int v101;
  const __CFDictionary *theDict;
  SecTrustRef *v103;
  _QWORD v104[2];
  uint64_t v105;
  CFTypeRef v106;
  CFTypeRef cf;
  CFTypeRef cf2;
  CFAbsoluteTime v109;
  CFArrayRef policies;
  void *value;
  _BYTE at[14];
  CFTypeRef v113;
  uint64_t v114;
  CFRange v115;

  v114 = *MEMORY[0x1E0C80C00];
  cf = 0;
  cf2 = 0;
  if (a6)
    p_cf2 = (uint64_t *)&cf2;
  else
    p_cf2 = 0;
  if (a7)
    p_cf = &cf;
  else
    p_cf = 0;
  v106 = 0;
  if (a4)
    v16 = (__SecTrust **)&v106;
  else
    v16 = 0;
  BytePtr = MS_SecCMSVerifySignedData_internal((uint64_t)a1, (uint64_t)a2, a3, v16, (uint64_t)a5, p_cf2, p_cf);
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1)
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_2932);
  if (isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound && (_DWORD)BytePtr)
  {
    v103 = a4;
    v105 = 0;
    if (!a1)
      goto LABEL_167;
    v104[0] = CFDataGetLength(a1);
    v104[1] = CFDataGetBytePtr(a1);
    v19 = SecCmsMessageDecode((uint64_t)v104, 0, 0, v18, 0, 0, 0, &v105);
    v20 = v105;
    if (v19)
    {
      v23 = 4294941021;
      goto LABEL_111;
    }
    if (!v105)
    {
LABEL_167:
      v23 = 4294967246;
      goto LABEL_26;
    }
    OID = *(_QWORD *)(v105 + 32);
    if (OID || (OID = SECOID_FindOID(v105), (*(_QWORD *)(v20 + 32) = OID) != 0))
    {
      if (*(_DWORD *)(OID + 16) == 26 && OID != 0)
      {
        v31 = *(_QWORD *)(v20 + 16);
        if (v31)
        {
          if (a2)
          {
            if (*(_QWORD *)(v31 + 168))
              goto LABEL_24;
            started = SecCmsDigestContextStartMultiple(*(uint64_t **)(v31 + 136));
            v33 = BytePtr;
            BytePtr = (uint64_t)CFDataGetBytePtr(a2);
            Length = CFDataGetLength(a2);
            v35 = (const void *)BytePtr;
            LODWORD(BytePtr) = v33;
            SecCmsDigestContextUpdate(started, v35, Length);
            SecCmsSignedDataSetDigestContext((_QWORD *)v31, started);
            SecCmsDigestContextCancel(started);
          }
          if (!a5 || !SecCmsSignedDataAddCertList(v31, a5))
          {
            if (!a3)
              goto LABEL_63;
            v36 = *(_QWORD **)(v31 + 160);
            if (v36 && *v36)
            {
              v37 = v36 + 1;
              v38 = -1;
              do
              {
                v39 = *v37++;
                ++v38;
              }
              while (v39);
              if (v38)
              {
                v23 = 4294967246;
                goto LABEL_111;
              }
              if (SecCmsSignedDataVerifySignerInfo_internal(v31, 0, a3, v103))
              {
                v23 = 4294942003;
                goto LABEL_111;
              }
LABEL_63:
              v40 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
              if (a6)
              {
                InnerContent = SecCmsContentInfoGetInnerContent(v20);
                if (InnerContent)
                  InnerContent = (uint64_t)CFDataCreate(*v40, *(const UInt8 **)(InnerContent + 8), *(_QWORD *)InnerContent);
                *a6 = InnerContent;
              }
              if (!a7)
                goto LABEL_110;
              v101 = BytePtr;
              v42 = *v40;
              theDict = CFDictionaryCreateMutable(*v40, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
              if (theDict)
              {
                v43 = *(uint64_t **)(**(_QWORD **)(v31 + 160) + 64);
                if (v43)
                {
                  v44 = *v43;
                  if (*v43)
                  {
                    do
                    {
                      v45 = CFDataCreate(v42, *(const UInt8 **)(v44 + 8), *(_QWORD *)v44);
                      if (v45)
                      {
                        v46 = v45;
                        v47 = *v43;
                        Mutable = CFArrayCreateMutable(v42, 0, MEMORY[0x1E0C9B378]);
                        v49 = *(uint64_t **)(v47 + 16);
                        if (v49)
                        {
                          v50 = *v49;
                          if (*v49)
                          {
                            v51 = v49 + 1;
                            do
                            {
                              v52 = CFDataCreate(v42, *(const UInt8 **)(v50 + 8), *(_QWORD *)v50);
                              if (v52)
                              {
                                v53 = v52;
                                CFArrayAppendValue(Mutable, v52);
                                CFRelease(v53);
                              }
                              v54 = *v51++;
                              v50 = v54;
                            }
                            while (v54);
                          }
                        }
                        if (Mutable)
                        {
                          v55 = (__CFArray *)CFDictionaryGetValue(theDict, v46);
                          if (v55)
                          {
                            v56 = v55;
                            Count = CFArrayGetCount(Mutable);
                            if (Count)
                            {
                              v115.length = Count;
                              v115.location = 0;
                              CFArrayAppendArray(v56, Mutable, v115);
                            }
                          }
                          else
                          {
                            CFDictionarySetValue(theDict, v46, Mutable);
                          }
                          CFRelease(Mutable);
                        }
                        CFRelease(v46);
                      }
                      v58 = v43[1];
                      ++v43;
                      v44 = v58;
                    }
                    while (v58);
                  }
                }
                v59 = *(uint64_t **)(v31 + 144);
                v60 = CFArrayCreateMutable(v42, 0, MEMORY[0x1E0C9B378]);
                if (v59)
                {
                  v61 = *v59;
                  if (*v59)
                  {
                    v62 = v59 + 1;
                    do
                    {
                      v63 = SecCertificateCreateWithBytes(0, *(const void **)(v61 + 8), *(_QWORD *)v61);
                      if (v63)
                      {
                        v64 = v63;
                        CFArrayAppendValue(v60, v63);
                        CFRelease(v64);
                      }
                      v65 = *v62++;
                      v61 = v65;
                    }
                    while (v65);
                  }
                }
                CFDictionaryAddValue(theDict, (const void *)kSecCMSAllCerts, v60);
                *(_QWORD *)at = -1;
                SecCmsSignerInfoGetSigningTime(**(_QWORD **)(v31 + 160), (double *)at, v66);
                if (!v67)
                {
                  v68 = CFDateCreate(v42, *(CFAbsoluteTime *)at);
                  if (v68)
                  {
                    v69 = v68;
                    CFDictionarySetValue(theDict, (const void *)kSecCMSSignDate, v68);
                    CFRelease(v69);
                  }
                }
                value = 0;
                if (SecCmsSignerInfoGetAppleCodesigningHashAgility(**(_QWORD **)(v31 + 160), (CFDataRef *)&value))v70 = 1;
                else
                  v70 = value == 0;
                LODWORD(BytePtr) = v101;
                if (!v70)
                  CFDictionarySetValue(theDict, (const void *)kSecCMSHashAgility, value);
                policies = 0;
                if (SecCmsSignerInfoGetAppleCodesigningHashAgilityV2(**(_QWORD **)(v31 + 160), &policies))
                  v72 = 1;
                else
                  v72 = policies == 0;
                if (!v72)
                  CFDictionarySetValue(theDict, (const void *)kSecCMSHashAgilityV2, policies);
                v109 = NAN;
                SecCmsSignerInfoGetAppleExpirationTime(**(_QWORD **)(v31 + 160), &v109, v71);
                if (!v73)
                {
                  v74 = CFDateCreate(0, v109);
                  if (v74)
                  {
                    v75 = v74;
                    CFDictionarySetValue(theDict, (const void *)kSecCMSExpirationDate, v74);
                    CFRelease(v75);
                  }
                }
                *a7 = theDict;
                if (v60)
                  CFRelease(v60);
LABEL_110:
                v23 = 0;
                goto LABEL_111;
              }
              v23 = 0;
LABEL_111:
              if (!v20)
              {
LABEL_26:
                if (!a6)
                  goto LABEL_116;
                v24 = (CFTypeRef)*a6;
                if (*a6 && cf2)
                {
                  if (CFEqual(v24, cf2))
                    goto LABEL_116;
                }
                else if (v24 == cf2)
                {
                  goto LABEL_116;
                }
                v76 = secLogObjForScope("SecWarning");
                if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
                {
                  v77 = *a6;
                  *(_DWORD *)at = 138412546;
                  *(_QWORD *)&at[4] = v77;
                  *(_WORD *)&at[12] = 2112;
                  v113 = cf2;
                  _os_log_impl(&dword_18A900000, v76, OS_LOG_TYPE_DEFAULT, "MessageSecurity and Security frameworks have different attached contents results, returning Security result. sec: %@, ms: %@", at, 0x16u);
                }
LABEL_116:
                v78 = v103;
                if (a7)
                {
                  v79 = *a7;
                  if (*a7 && cf)
                  {
                    if (CFEqual(v79, cf))
                      goto LABEL_124;
                  }
                  else if (v79 == cf)
                  {
                    goto LABEL_124;
                  }
                  v80 = secLogObjForScope("SecWarning");
                  if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
                  {
                    v81 = *a7;
                    *(_DWORD *)at = 138412546;
                    *(_QWORD *)&at[4] = v81;
                    *(_WORD *)&at[12] = 2112;
                    v113 = cf;
                    _os_log_impl(&dword_18A900000, v80, OS_LOG_TYPE_DEFAULT, "MessageSecurity and Security frameworks have different signed attributes results, returning Security result. sec: %@, ms: %@", at, 0x16u);
                  }
                }
LABEL_124:
                if (!v103 || (v82 = *v103, v83 = (__SecTrust *)v106, *v103 == v106))
                {
LABEL_137:
                  if ((_DWORD)v23 != (_DWORD)BytePtr)
                  {
                    v88 = secLogObjForScope("SecWarning");
                    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)at = 67109376;
                      *(_DWORD *)&at[4] = v23;
                      *(_WORD *)&at[8] = 1024;
                      *(_DWORD *)&at[10] = BytePtr;
                      _os_log_impl(&dword_18A900000, v88, OS_LOG_TYPE_DEFAULT, "MessageSecurity and Security frameworks have different status results, returning Security result. sec: %d, ms: %d", at, 0xEu);
                    }
                  }
                  v89 = cf2;
                  if (cf2)
                  {
                    cf2 = 0;
                    CFRelease(v89);
                  }
                  v90 = cf;
                  if (cf)
                  {
                    cf = 0;
                    CFRelease(v90);
                  }
                  v91 = v106;
                  if (v106)
                  {
                    v106 = 0;
                    CFRelease(v91);
                  }
                  return v23;
                }
                if (!v82 || !v106)
                {
LABEL_135:
                  v86 = secLogObjForScope("SecWarning");
                  if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
                  {
                    v87 = *v78;
                    *(_DWORD *)at = 138412546;
                    *(_QWORD *)&at[4] = v87;
                    *(_WORD *)&at[12] = 2112;
                    v113 = v106;
                    _os_log_impl(&dword_18A900000, v86, OS_LOG_TYPE_DEFAULT, "MessageSecurity and Security frameworks have different trustref results, returning Security result. sec: %@, ms: %@", at, 0x16u);
                  }
                  goto LABEL_137;
                }
                value = 0;
                *(_QWORD *)at = 0;
                if (SecTrustCopyInputCertificates((uint64_t)v82, at)
                  || SecTrustCopyInputCertificates((uint64_t)v83, &value))
                {
                  v84 = *(const void **)at;
                  if (!*(_QWORD *)at)
                  {
LABEL_132:
                    v85 = *(double *)&value;
                    if (!value)
                      goto LABEL_135;
                    value = 0;
                    goto LABEL_134;
                  }
LABEL_131:
                  *(_QWORD *)at = 0;
                  CFRelease(v84);
                  goto LABEL_132;
                }
                ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)at, 0);
                v94 = CFArrayGetValueAtIndex((CFArrayRef)value, 0);
                if (ValueAtIndex && v94)
                {
                  if (!CFEqual(ValueAtIndex, v94))
                    goto LABEL_165;
                }
                else if (ValueAtIndex != v94)
                {
                  goto LABEL_165;
                }
                if (!certArrayIsSubset(*(const __CFArray **)at, (CFArrayRef)value)
                  || (certArrayIsSubset((const __CFArray *)value, *(CFArrayRef *)at) & 1) == 0)
                {
LABEL_165:
                  v84 = *(const void **)at;
                  v78 = v103;
                  if (!*(_QWORD *)at)
                    goto LABEL_132;
                  goto LABEL_131;
                }
                v95 = *(const void **)at;
                v78 = v103;
                if (*(_QWORD *)at)
                {
                  *(_QWORD *)at = 0;
                  CFRelease(v95);
                }
                v96 = value;
                if (value)
                {
                  value = 0;
                  CFRelease(v96);
                }
                v109 = 0.0;
                policies = 0;
                if (SecTrustCopyPolicies(v82, &policies) || SecTrustCopyPolicies(v83, (CFArrayRef *)&v109))
                {
                  v97 = policies;
LABEL_161:
                  if (v97)
                  {
                    policies = 0;
                    CFRelease(v97);
                  }
                  v85 = v109;
                  if (!*(_QWORD *)&v109)
                    goto LABEL_135;
                  v109 = 0.0;
LABEL_134:
                  CFRelease(*(CFTypeRef *)&v85);
                  goto LABEL_135;
                }
                v97 = policies;
                if (policies && *(_QWORD *)&v109)
                {
                  v98 = CFEqual(policies, *(CFTypeRef *)&v109);
                  v97 = policies;
                  if (!v98)
                    goto LABEL_161;
                }
                else if (policies != *(CFArrayRef *)&v109)
                {
                  goto LABEL_161;
                }
                if (v97)
                {
                  policies = 0;
                  CFRelease(v97);
                }
                v99 = v109;
                if (*(_QWORD *)&v109)
                {
                  v109 = 0.0;
                  CFRelease(*(CFTypeRef *)&v99);
                }
                VerifyTime = SecTrustGetVerifyTime(v82);
                v78 = v103;
                if (vabdd_f64(VerifyTime, SecTrustGetVerifyTime(v83)) <= 0.1)
                  goto LABEL_137;
                goto LABEL_135;
              }
LABEL_25:
              SecCmsMessageDestroy(v20);
              goto LABEL_26;
            }
          }
        }
      }
    }
LABEL_24:
    v23 = 4294967246;
    goto LABEL_25;
  }
  if (a6)
  {
    v25 = cf2;
    if (cf2)
      CFRetain(cf2);
    *a6 = (uint64_t)v25;
  }
  if (a7)
  {
    v26 = (const __CFDictionary *)cf;
    if (cf)
      CFRetain(cf);
    *a7 = v26;
  }
  if (a4)
  {
    v27 = (__SecTrust *)v106;
    if (v106)
      CFRetain(v106);
    *a4 = v27;
  }
  v28 = cf2;
  if (cf2)
  {
    cf2 = 0;
    CFRelease(v28);
  }
  v29 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v29);
  }
  v30 = v106;
  if (v106)
  {
    v106 = 0;
    CFRelease(v30);
  }
  return BytePtr;
}

BOOL SecCertificateEqual(uint64_t a1, uint64_t a2)
{
  size_t v2;

  if (a1 == a2)
    return 1;
  if (!a2)
    return 0;
  v2 = *(_QWORD *)(a1 + 24);
  return v2 == *(_QWORD *)(a2 + 24) && memcmp(*(const void **)(a1 + 16), *(const void **)(a2 + 16), v2) == 0;
}

OSStatus SecTrustCopyPolicies(SecTrustRef trust, CFArrayRef *policies)
{
  OSStatus v2;
  NSObject *v4;
  const __CFArray *v5;
  _QWORD v7[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v2 = -50;
  if (trust && policies)
  {
    v8 = 0;
    v9 = &v8;
    v10 = 0x2000000000;
    v11 = 0;
    v4 = *((_QWORD *)trust + 17);
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = __SecTrustCopyPolicies_block_invoke;
    v7[3] = &unk_1E1FDA1A8;
    v7[4] = &v8;
    v7[5] = trust;
    dispatch_sync(v4, v7);
    v5 = (const __CFArray *)v9[3];
    if (v5)
    {
      v2 = 0;
      *policies = v5;
    }
    else
    {
      v2 = -108;
    }
    _Block_object_dispose(&v8, 8);
  }
  return v2;
}

uint64_t SecTrustEvaluateFastAsync(dispatch_queue_t *a1, dispatch_queue_t queue, uint64_t a3)
{
  uint64_t result;
  _QWORD v7[6];

  result = 4294967246;
  if (a1 && queue)
  {
    if (a3)
    {
      dispatch_assert_queue_V2(queue);
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 0x40000000;
      v7[2] = __SecTrustEvaluateFastAsync_block_invoke;
      v7[3] = &unk_1E1FDA7F0;
      v7[4] = a3;
      v7[5] = a1;
      SecTrustEvaluateIfNecessaryFastAsync(a1, queue, (uint64_t)v7);
      return 0;
    }
  }
  return result;
}

void SecTrustEvaluateIfNecessaryFastAsync(dispatch_queue_t *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;
  _QWORD block[8];
  _QWORD v17[3];
  CFAbsoluteTime VerifyTime;
  uint8_t buf[4];
  dispatch_queue_t *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v17[0] = 0;
    v17[1] = v17;
    v17[2] = 0x2000000000;
    VerifyTime = NAN;
    VerifyTime = SecTrustGetVerifyTime((SecTrustRef)a1);
    SecTrustAddPolicyAnchors((uint64_t)a1);
    dispatch_retain(a2);
    CFRetain(a1);
    v6 = MEMORY[0x1E0C809B0];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke;
    block[3] = &unk_1E1FDB398;
    block[6] = a1;
    block[7] = a2;
    block[4] = a3;
    block[5] = v17;
    v12 = 0;
    v13 = &v12;
    v14 = 0x2000000000;
    v15 = 0;
    v7 = secLogObjForScope("trust");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      v20 = a1;
      _os_log_debug_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEBUG, "(Trust %p) waiting for queue", buf, 0xCu);
    }
    v8 = a1[17];
    v11[0] = v6;
    v11[1] = 0x40000000;
    v11[2] = __SecTrustEvaluateIfNecessaryFastAsync_block_invoke_405;
    v11[3] = &unk_1E1FDB3C0;
    v11[4] = &v12;
    v11[5] = a1;
    dispatch_sync(v8, v11);
    if (*((_BYTE *)v13 + 24))
    {
      v9 = secLogObjForScope("trust");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        v20 = a1;
        _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "(Trust %p) Waiting for pending eval", buf, 0xCu);
      }
      dispatch_group_notify(a1[21], a1[17], block);
    }
    else
    {
      dispatch_sync(a1[17], block);
      v10 = secLogObjForScope("trust");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        v20 = a1;
        _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, "(Trust %p) Completed async eval kickoff", buf, 0xCu);
      }
      dispatch_group_leave(a1[21]);
    }
    _Block_object_dispose(&v12, 8);
    _Block_object_dispose(v17, 8);
  }
}

uint64_t SecTrustEvaluateIfNecessary(__SecTrust *a1)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD block[7];
  _QWORD v6[3];
  CFAbsoluteTime VerifyTime;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = -1431655766;
  if (pthread_main_np() == 1)
  {
    if (SecTrustEvaluateThreadRuntimeCheck_queueToken != -1)
      dispatch_once(&SecTrustEvaluateThreadRuntimeCheck_queueToken, &__block_literal_global_329);
    dispatch_async((dispatch_queue_t)SecTrustEvaluateThreadRuntimeCheck_runtimeLogQueue, &__block_literal_global_332);
  }
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x2000000000;
  VerifyTime = NAN;
  VerifyTime = SecTrustGetVerifyTime(a1);
  SecTrustAddPolicyAnchors((uint64_t)a1);
  v2 = *((_QWORD *)a1 + 17);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustEvaluateIfNecessary_block_invoke;
  block[3] = &unk_1E1FDB0A0;
  block[5] = &v8;
  block[6] = a1;
  block[4] = v6;
  dispatch_sync(v2, block);
  v3 = *((unsigned int *)v9 + 6);
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v8, 8);
  return v3;
}

CFAbsoluteTime SecTrustGetVerifyTime(SecTrustRef trust)
{
  NSObject *v2;
  double v3;
  _QWORD v5[6];
  uint64_t v6;
  double *v7;
  uint64_t v8;
  CFAbsoluteTime Current;

  v6 = 0;
  v7 = (double *)&v6;
  v8 = 0x2000000000;
  Current = NAN;
  Current = CFAbsoluteTimeGetCurrent();
  if (trust)
  {
    v2 = *((_QWORD *)trust + 17);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 0x40000000;
    v5[2] = __SecTrustGetVerifyTime_block_invoke;
    v5[3] = &unk_1E1FDA278;
    v5[4] = &v6;
    v5[5] = trust;
    dispatch_sync(v2, v5);
  }
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void SecTrustAddPolicyAnchors(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  CFTypeRef *ValueAtIndex;
  const __CFAllocator *v8;
  CFArrayRef v9;
  NSObject *v10;
  const void *v11;
  _QWORD v12[6];
  _QWORD v13[3];
  unint64_t v14;
  _QWORD block[6];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  void *values;

  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v2 = *(NSObject **)(a1 + 136);
  v3 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustAddPolicyAnchors_block_invoke;
  block[3] = &unk_1E1FDB188;
  block[4] = &v16;
  block[5] = a1;
  dispatch_sync(v2, block);
  Count = CFArrayGetCount((CFArrayRef)v17[3]);
  if (Count >= 1)
  {
    v5 = Count;
    v6 = 0;
    while (1)
    {
      ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex((CFArrayRef)v17[3], v6);
      if (ValueAtIndex)
      {
        if (CFEqual(ValueAtIndex[2], CFSTR("1.2.840.113635.100.1.32")))
          break;
      }
      if (v5 == ++v6)
        goto LABEL_12;
    }
    v13[0] = 0;
    v13[1] = v13;
    v13[2] = 0x2000000000;
    v14 = 0xAAAAAAAAAAAAAAAALL;
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    values = SecCertificateCreateWithBytes(*MEMORY[0x1E0C9AE00], &_SEC_TestAppleRootCAECC, 555);
    if (values)
    {
      v9 = CFArrayCreate(v8, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
      if (values)
        CFRelease(values);
    }
    else
    {
      v9 = 0;
    }
    v14 = (unint64_t)v9;
    v10 = *(NSObject **)(a1 + 136);
    v12[0] = v3;
    v12[1] = 0x40000000;
    v12[2] = __SecTrustAddPolicyAnchors_block_invoke_2;
    v12[3] = &unk_1E1FDB1B8;
    v12[4] = v13;
    v12[5] = a1;
    dispatch_sync(v10, v12);
    *(_BYTE *)(a1 + 116) = 1;
    _Block_object_dispose(v13, 8);
  }
LABEL_12:
  v11 = (const void *)v17[3];
  if (v11)
    CFRelease(v11);
  _Block_object_dispose(&v16, 8);
}

uint64_t certArrayIsSubset(const __CFArray *a1, CFArrayRef theArray)
{
  uint64_t result;
  CFIndex v5;
  CFIndex Count;
  BOOL v7;
  const void *ValueAtIndex;
  CFRange v9;

  if (a1 == theArray)
    return 1;
  result = 0;
  if (a1 && theArray)
  {
    v5 = 0;
    do
    {
      Count = CFArrayGetCount(theArray);
      v7 = v5 < Count;
      result = v5 >= Count;
      if (!v7)
        break;
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v5);
      v9.length = CFArrayGetCount(a1);
      v9.location = 0;
      result = CFArrayContainsValue(a1, v9, ValueAtIndex);
      ++v5;
    }
    while ((_DWORD)result);
  }
  return result;
}

uint64_t SecTrustCopyInputCertificates(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  NSObject *v4;
  uint64_t v5;
  _QWORD v7[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v2 = 4294967246;
  if (a1 && a2)
  {
    v8 = 0;
    v9 = &v8;
    v10 = 0x2000000000;
    v11 = 0;
    v4 = *(NSObject **)(a1 + 136);
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = __SecTrustCopyInputCertificates_block_invoke;
    v7[3] = &unk_1E1FD9F68;
    v7[4] = &v8;
    v7[5] = a1;
    dispatch_sync(v4, v7);
    v5 = v9[3];
    if (v5)
    {
      v2 = 0;
      *a2 = v5;
    }
    else
    {
      v2 = 4294967188;
    }
    _Block_object_dispose(&v8, 8);
  }
  return v2;
}

void SecCmsDigestContextCancel(uint64_t a1)
{
  int v2;
  uint64_t i;
  uint64_t v4;
  void *v5;

  v2 = *(_DWORD *)(a1 + 12);
  if (v2 >= 1)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = *(void **)(v4 + 8 * i);
        if (v5)
        {
          free(v5);
          *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * i) = 0;
          v2 = *(_DWORD *)(a1 + 12);
        }
      }
    }
  }
  PORT_FreeArena(*(_QWORD **)a1, 1);
}

BOOL useMessageSecurityEnabled()
{
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1)
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_2932);
  return isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound == 0;
}

uint64_t SecCmsSignerInfoGetAppleCodesigningHashAgility(uint64_t a1, CFDataRef *a2)
{
  uint64_t result;
  CFDataRef v5;
  uint64_t v6;
  CFIndex *v7;
  const UInt8 *v8;
  CFIndex v9;

  result = 4294967246;
  if (a1 && a2)
  {
    *a2 = 0;
    v5 = *(CFDataRef *)(a1 + 184);
    if (v5)
    {
LABEL_4:
      result = 0;
      *a2 = v5;
      return result;
    }
    result = SecCmsAttributeArrayFindAttrByOidTag(*(uint64_t **)(a1 + 64), 0xD6u, 1);
    if (result)
    {
      v6 = *(_QWORD *)(result + 16);
      v7 = *(CFIndex **)v6;
      if (*(_QWORD *)v6 && (v8 = (const UInt8 *)v7[1]) != 0 && (v9 = *v7) != 0 && !*(_QWORD *)(v6 + 8))
      {
        if ((v9 & 0x8000000000000000) == 0)
        {
          v5 = CFDataCreate(0, v8, v9);
          *(_QWORD *)(a1 + 184) = v5;
          if (v5)
            goto LABEL_4;
        }
        return 4294967188;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t SecCmsMessageDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v10;
  uint64_t *v12;
  uint64_t v13;
  uint64_t *v14;

  v14 = 0;
  v10 = SecCmsDecoderCreate(a2, a3, a3, a5, a6, a7, &v14);
  if ((_DWORD)v10)
    return v10;
  if ((*(_QWORD *)a1 & 0x8000000000000000) != 0)
    return 4294967246;
  v12 = v14;
  v13 = SecCmsDecoderUpdate((uint64_t)v14, *(char **)(a1 + 8), *(_QWORD *)a1);
  if ((_DWORD)v13)
  {
    v10 = v13;
    SecCmsDecoderDestroy(v12);
    return v10;
  }
  return SecCmsDecoderFinish(v12, a8);
}

void SecCmsDigestContextUpdate(uint64_t a1, const void *a2, unint64_t a3)
{
  NSObject *v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t OID;
  int v10;
  int v11;
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (HIDWORD(a3))
  {
    v4 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v11 = 134217984;
      v12 = a3;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "SecCmsDigestContextUpdate: data size too big (%zu), skipping", (uint8_t *)&v11, 0xCu);
    }
  }
  else
  {
    *(_BYTE *)(a1 + 8) = 1;
    if (*(int *)(a1 + 12) >= 1)
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v7))
        {
          v8 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v7);
          if (v8)
          {
            if (*(_QWORD *)(v8 + 8))
            {
              OID = SECOID_FindOID(v8);
              if (OID)
              {
                v10 = *(_DWORD *)(OID + 16);
                switch(v10)
                {
                  case 191:
                    CC_SHA224_Update(*(CC_SHA256_CTX **)(*(_QWORD *)(a1 + 16) + 8 * v7), a2, a3);
                    break;
                  case 192:
                    CC_SHA256_Update(*(CC_SHA256_CTX **)(*(_QWORD *)(a1 + 16) + 8 * v7), a2, a3);
                    break;
                  case 193:
                    CC_SHA384_Update(*(CC_SHA512_CTX **)(*(_QWORD *)(a1 + 16) + 8 * v7), a2, a3);
                    break;
                  case 194:
                    CC_SHA512_Update(*(CC_SHA512_CTX **)(*(_QWORD *)(a1 + 16) + 8 * v7), a2, a3);
                    break;
                  default:
                    if (v10 == 3)
                    {
                      CC_MD5_Update(*(CC_MD5_CTX **)(*(_QWORD *)(a1 + 16) + 8 * v7), a2, a3);
                    }
                    else if (v10 == 4)
                    {
                      CC_SHA1_Update(*(CC_SHA1_CTX **)(*(_QWORD *)(a1 + 16) + 8 * v7), a2, a3);
                    }
                    break;
                }
              }
            }
          }
        }
        ++v7;
      }
      while (v7 < *(int *)(a1 + 12));
    }
  }
}

double SecCmsSignerInfoGetAppleExpirationTime(uint64_t a1, double *a2, double result)
{
  uint64_t AttrByOidTag;
  uint64_t v6;
  _QWORD *v7;

  if (a1 && a2)
  {
    result = *(double *)(a1 + 200);
    if (result == 0.0)
    {
      AttrByOidTag = SecCmsAttributeArrayFindAttrByOidTag(*(uint64_t **)(a1 + 64), 0xD8u, 1);
      if (AttrByOidTag)
      {
        v6 = *(_QWORD *)(AttrByOidTag + 16);
        v7 = *(_QWORD **)v6;
        if (*(_QWORD *)v6)
        {
          if (v7[1] && *v7 && !*(_QWORD *)(v6 + 8) && !SecAsn1DecodeTime((uint64_t)v7, a2))
          {
            result = *a2;
            *(double *)(a1 + 200) = *a2;
          }
        }
      }
    }
    else
    {
      *a2 = result;
    }
  }
  return result;
}

uint64_t SecECKeyCopyPublicBits(uint64_t a1)
{
  uint64_t v2;

  v2 = 0;
  SecKeyCopyPublicBytes(a1, (uint64_t)&v2);
  return v2;
}

__CFData *SecDistinguishedNameCopyNormalizedSequence(const __CFData *a1)
{
  __CFData *v1;
  __CFData *v2;
  __CFData *v3;

  if (!a1)
    return 0;
  v1 = SecDistinguishedNameCopyNormalizedContent(a1);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = SecCopySequenceFromContent(v1);
  CFRelease(v2);
  return v3;
}

__CFData *SecDistinguishedNameCopyNormalizedContent(const __CFData *a1)
{
  int v2;
  __CFData *result;
  unint64_t v4[3];
  _QWORD v5[2];

  if (CFDataGetLength(a1) < 0)
    return 0;
  v5[0] = CFDataGetBytePtr(a1);
  v5[1] = CFDataGetLength(a1);
  memset(v4, 170, sizeof(v4));
  v2 = DERDecodeItem((uint64_t)v5, v4);
  result = 0;
  if (!v2 && v4[0] == 0x2000000000000010)
    return createNormalizedX501Name((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (uint64_t)&v4[1]);
  return result;
}

CFDataRef SecTrustCopyExceptions(SecTrustRef trust)
{
  SecTrustRef Data;
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  const __CFArray *v6;
  uint64_t Count;
  const __CFAllocator *v8;
  __CFArray *Mutable;
  uint64_t ExceptionResetCount;
  NSObject *v11;
  CFNumberRef v12;
  CFIndex v13;
  const CFDictionaryKeyCallBacks *v14;
  const CFDictionaryValueCallBacks *v15;
  const __CFDictionary *ValueAtIndex;
  CFIndex v17;
  __CFDictionary *MutableCopy;
  __CFData *v19;
  __CFData *SHA1Digest;
  NSObject *v21;
  NSObject *v22;
  uint64_t v23;
  NSObject *v24;
  unint64_t v25;
  const __CFDictionary *v26;
  const void *v27;
  const void *v28;
  const char *v30;
  _QWORD v31[6];
  uint64_t valuePtr;
  CFTypeRef cf;
  _QWORD v34[7];
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD block[6];
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE buf[24];
  void *v49;
  SecTrustRef v50;
  uint64_t v51;

  Data = trust;
  v51 = *MEMORY[0x1E0C80C00];
  if (trust)
  {
    v44 = 0;
    v45 = &v44;
    v46 = 0x2000000000;
    v47 = 0;
    v2 = *((_QWORD *)trust + 17);
    v3 = MEMORY[0x1E0C809B0];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SecTrustCopyExceptions_block_invoke;
    block[3] = &unk_1E1FDA9D0;
    block[4] = &v44;
    block[5] = Data;
    dispatch_sync(v2, block);
    if (v45[3])
    {
      v4 = *((_QWORD *)Data + 17);
      *(_QWORD *)buf = v3;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = __SecTrustSetNeedsEvaluation_block_invoke;
      v49 = &__block_descriptor_tmp_49_11514;
      v50 = Data;
      dispatch_sync(v4, buf);
    }
    v39 = 0;
    v40 = &v39;
    v41 = 0x2000000000;
    v42 = 0;
    v35 = 0;
    v36 = &v35;
    v37 = 0x2000000000;
    v38 = 0;
    SecTrustEvaluateIfNecessary(Data);
    v5 = *((_QWORD *)Data + 17);
    v34[0] = v3;
    v34[1] = 0x40000000;
    v34[2] = __SecTrustCopyExceptions_block_invoke_2;
    v34[3] = &unk_1E1FDA9F8;
    v34[5] = &v35;
    v34[6] = Data;
    v34[4] = &v39;
    dispatch_sync(v5, v34);
    v6 = (const __CFArray *)v40[3];
    if (v6)
      Count = CFArrayGetCount(v6);
    else
      Count = 0;
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
    cf = 0;
    ExceptionResetCount = SecTrustGetExceptionResetCount(&cf);
    valuePtr = ExceptionResetCount;
    v11 = secLogObjForScope("trust");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      v30 = "Error";
      if (!cf)
        v30 = "OK";
      *(_DWORD *)buf = 134218242;
      *(_QWORD *)&buf[4] = ExceptionResetCount;
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v30;
      _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "The current exceptions epoch is %llu. (%{public}s)", buf, 0x16u);
    }
    v12 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
    if (Count >= 1)
    {
      v13 = 0;
      v14 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
      v15 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v40[3], v13);
        v17 = CFDictionaryGetCount(ValueAtIndex);
        if (v13 && v17 < 1)
        {
          MutableCopy = CFDictionaryCreate(v8, 0, 0, 0, v14, v15);
        }
        else
        {
          MutableCopy = CFDictionaryCreateMutableCopy(v8, 0, ValueAtIndex);
          v19 = (__CFData *)CFArrayGetValueAtIndex((CFArrayRef)v36[3], v13);
          SHA1Digest = SecCertificateGetSHA1Digest(v19);
          if (SHA1Digest)
          {
            CFDictionaryAddValue(MutableCopy, CFSTR("SHA1Digest"), SHA1Digest);
          }
          else
          {
            v21 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 134217984;
              *(_QWORD *)&buf[4] = v13;
              _os_log_impl(&dword_18A900000, v21, OS_LOG_TYPE_DEFAULT, "Unable to get digest of certificate at index %lld", buf, 0xCu);
            }
          }
          if (valuePtr && !cf && v12)
            CFDictionaryAddValue(MutableCopy, CFSTR("ExceptionResetCount"), v12);
        }
        CFArrayAppendValue(Mutable, MutableCopy);
        if (MutableCopy)
          CFRelease(MutableCopy);
        ++v13;
      }
      while (Count != v13);
    }
    if (v45[3])
    {
      v22 = *((_QWORD *)Data + 17);
      v23 = MEMORY[0x1E0C809B0];
      v31[0] = MEMORY[0x1E0C809B0];
      v31[1] = 0x40000000;
      v31[2] = __SecTrustCopyExceptions_block_invoke_218;
      v31[3] = &unk_1E1FDAA20;
      v31[4] = &v44;
      v31[5] = Data;
      dispatch_sync(v22, v31);
      v24 = *((_QWORD *)Data + 17);
      *(_QWORD *)buf = v23;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = __SecTrustSetNeedsEvaluation_block_invoke;
      v49 = &__block_descriptor_tmp_49_11514;
      v50 = Data;
      dispatch_sync(v24, buf);
    }
    if (Count >= 2)
    {
      v25 = Count + 1;
      do
      {
        v26 = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v25 - 2);
        if (CFDictionaryGetCount(v26))
          break;
        CFArrayRemoveValueAtIndex(Mutable, v25 - 2);
        --v25;
      }
      while (v25 > 2);
    }
    Data = CFPropertyListCreateData(v8, Mutable, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    CFRelease(Mutable);
    v27 = (const void *)v40[3];
    if (v27)
      CFRelease(v27);
    v28 = (const void *)v36[3];
    if (v28)
      CFRelease(v28);
    if (v12)
      CFRelease(v12);
    if (cf)
      CFRelease(cf);
    _Block_object_dispose(&v35, 8);
    _Block_object_dispose(&v39, 8);
    _Block_object_dispose(&v44, 8);
  }
  return Data;
}

__CFData *SecCertificateGetSHA1Digest(__CFData *cf)
{
  __CFData *v1;
  const __CFAllocator *v2;

  if (cf)
  {
    v1 = cf;
    if (!*((_QWORD *)cf + 2) || (*((_QWORD *)cf + 3) & 0x8000000000000000) != 0)
    {
      return 0;
    }
    else
    {
      cf = (__CFData *)*((_QWORD *)cf + 76);
      if (!cf)
      {
        v2 = CFGetAllocator(v1);
        cf = SecSHA1DigestCreate(v2, *((_QWORD *)v1 + 2), *((_QWORD *)v1 + 3));
        *((_QWORD *)v1 + 76) = cf;
      }
    }
  }
  return cf;
}

uint64_t SecCmsSignerInfoVerifyCertificate(uint64_t a1, const void *a2, SecTrustRef *a3)
{
  __CFArray *Mutable;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  const __CFData *v10;
  const __CFData *v11;
  int v12;
  const __CFData *SubjectKeyID;
  size_t *v14;
  size_t v15;
  const void *v16;
  const UInt8 *BytePtr;
  uint64_t v18;
  CFTypeRef *v19;
  CFTypeRef *v20;
  double v21;
  CFTypeRef v22;
  const void *v23;
  int v24;
  double Current;
  uint64_t v26;
  uint64_t v28;

  *(double *)&v28 = NAN;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v7 = *(uint64_t **)(*(_QWORD *)(a1 + 128) + 144);
  if (v7)
  {
    v8 = *v7;
    if (*v7)
    {
      v9 = v7 + 1;
      while (1)
      {
        if ((*(_QWORD *)v8 & 0x8000000000000000) != 0)
        {
          while (1)
            ;
        }
        v10 = (const __CFData *)SecCertificateCreateWithBytes(0, *(const void **)(v8 + 8), *(_QWORD *)v8);
        if (!v10)
          goto LABEL_15;
        v11 = v10;
        v12 = *(_DWORD *)(a1 + 16);
        if (v12 == 1)
          break;
        if (!v12)
        {
          if (CERT_CheckIssuerAndSerial((uint64_t)v10, (size_t *)(*(_QWORD *)(a1 + 24) + 24), (size_t *)(*(_QWORD *)(a1 + 24) + 8)))
          {
            goto LABEL_13;
          }
LABEL_12:
          CFArrayAppendValue(Mutable, v11);
        }
LABEL_14:
        CFRelease(v11);
LABEL_15:
        v18 = *v9++;
        v8 = v18;
        if (!v18)
          goto LABEL_16;
      }
      SubjectKeyID = SecCertificateGetSubjectKeyID(v10);
      v14 = *(size_t **)(a1 + 24);
      v15 = *v14;
      if (v15 == CFDataGetLength(SubjectKeyID))
      {
        v16 = (const void *)v14[1];
        BytePtr = CFDataGetBytePtr(SubjectKeyID);
        if (!memcmp(v16, BytePtr, *v14))
        {
LABEL_13:
          CFArrayInsertValueAtIndex(Mutable, 0, v11);
          goto LABEL_14;
        }
      }
      goto LABEL_12;
    }
  }
LABEL_16:
  if (!CFArrayGetCount(Mutable) && !*(_DWORD *)(a1 + 16))
  {
    v19 = CERT_FindByIssuerAndSN(*(const void **)(*(_QWORD *)(a1 + 128) + 176), CFSTR("cert"), *(_QWORD *)(a1 + 24));
    if (v19)
    {
      v20 = v19;
      CFArrayAppendValue(Mutable, v19);
      CFRelease(v20);
    }
  }
  if (!CFArrayGetCount(Mutable) && *(_DWORD *)(a1 + 16) == 1)
  {
    v22 = CERT_FindBySubjectKeyID(*(const void **)(*(_QWORD *)(a1 + 128) + 176), CFSTR("cert"), *(CFIndex **)(a1 + 24));
    if (v22)
    {
      v23 = v22;
      CFArrayAppendValue(Mutable, v22);
      CFRelease(v23);
    }
  }
  if (Mutable)
  {
    SecCmsSignerInfoGetSigningTime(a1, (double *)&v28, v21);
    if (v24)
    {
      Current = CFAbsoluteTimeGetCurrent();
      *(double *)&v28 = Current;
    }
    else
    {
      Current = *(double *)&v28;
    }
    v26 = CERT_VerifyCert(Mutable, a2, a3, Current);
    CFRelease(Mutable);
    if ((!a3 || (_DWORD)v26) && PORT_GetError() == -8171 && *(_DWORD *)(a1 + 160) == 1)
      *(_DWORD *)(a1 + 160) = 5;
  }
  else
  {
    *(_DWORD *)(a1 + 160) = 4;
    return 0xFFFFFFFFLL;
  }
  return v26;
}

BOOL CERT_CheckIssuerAndSerial(uint64_t a1, size_t *a2, size_t *a3)
{
  __CFData *v6;
  const __CFData *v7;
  size_t v8;
  const void *v9;
  const UInt8 *BytePtr;
  _BOOL8 v11;
  const void *v12;
  size_t v13;
  const void *v14;
  const UInt8 *v15;

  v6 = SecDERItemCopySequence(a1 + 152);
  if (!v6)
    return 0;
  v7 = v6;
  v8 = *a2;
  if (v8 != CFDataGetLength(v6))
    goto LABEL_4;
  v9 = (const void *)a2[1];
  BytePtr = CFDataGetBytePtr(v7);
  if (memcmp(v9, BytePtr, *a2))
    goto LABEL_4;
  CFRelease(v7);
  if (!a1)
    return 0;
  v12 = *(const void **)(a1 + 568);
  if (!v12)
    return 0;
  CFRetain(v12);
  v7 = *(const __CFData **)(a1 + 568);
  if (!v7)
    return 0;
  v13 = *a3;
  if (v13 == CFDataGetLength(v7))
  {
    v14 = (const void *)a3[1];
    v15 = CFDataGetBytePtr(v7);
    v11 = memcmp(v14, v15, *a3) == 0;
    goto LABEL_5;
  }
LABEL_4:
  v11 = 0;
LABEL_5:
  CFRelease(v7);
  return v11;
}

CFDictionaryRef SecKeyCopyAttributeDictionaryWithLocalKey(const void *a1, uint64_t a2, const __CFData *a3)
{
  const __CFAllocator *v6;
  __int128 v7;
  CFNumberRef v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  __CFData *v11;
  __CFData *v12;
  const __CFString *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFDataRef v18;
  CFDictionaryRef v19;
  uint64_t Size;
  CFDataRef theData;
  void *values[2];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  unint64_t v35;
  void *keys[2];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  unint64_t v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v6 = CFGetAllocator(a1);
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)keys = v7;
  v37 = v7;
  v38 = v7;
  v39 = v7;
  v40 = v7;
  v41 = v7;
  v42 = v7;
  v43 = v7;
  v44 = v7;
  v45 = v7;
  v46 = v7;
  v47 = v7;
  v48 = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)values = v7;
  v24 = v7;
  v25 = v7;
  v26 = v7;
  v27 = v7;
  v28 = v7;
  v29 = v7;
  v30 = v7;
  v31 = v7;
  v32 = v7;
  v33 = v7;
  v34 = v7;
  v35 = 0xAAAAAAAAAAAAAAAALL;
  theData = 0;
  Size = SecKeyGetSize((uint64_t)a1, 0);
  v8 = CFNumberCreate(v6, kCFNumberLongType, &Size);
  if (SecKeyCopyPublicBytes((uint64_t)a1, (uint64_t)&theData))
    goto LABEL_20;
  if (!theData)
  {
    v19 = 0;
    if (!v8)
      return v19;
    goto LABEL_18;
  }
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v11 = SecSHA1DigestCreate(v6, (uint64_t)BytePtr, Length);
  if (!v11)
  {
LABEL_20:
    v19 = 0;
  }
  else
  {
    v12 = v11;
    keys[0] = CFSTR("class");
    keys[1] = CFSTR("kcls");
    v13 = CFSTR("1");
    if (!a3)
      v13 = CFSTR("0");
    values[0] = CFSTR("keys");
    values[1] = (void *)v13;
    *(_QWORD *)&v37 = CFSTR("klbl");
    *((_QWORD *)&v37 + 1) = CFSTR("perm");
    v14 = *MEMORY[0x1E0C9AE50];
    *(_QWORD *)&v24 = v11;
    *((_QWORD *)&v24 + 1) = v14;
    *(_QWORD *)&v38 = CFSTR("priv");
    *((_QWORD *)&v38 + 1) = CFSTR("modi");
    *(_QWORD *)&v25 = v14;
    *((_QWORD *)&v25 + 1) = v14;
    *(_QWORD *)&v39 = CFSTR("type");
    *((_QWORD *)&v39 + 1) = CFSTR("bsiz");
    *(_QWORD *)&v26 = a2;
    *((_QWORD *)&v26 + 1) = v8;
    *(_QWORD *)&v40 = CFSTR("esiz");
    *((_QWORD *)&v40 + 1) = CFSTR("sens");
    v15 = *MEMORY[0x1E0C9AE40];
    *(_QWORD *)&v27 = v8;
    *((_QWORD *)&v27 + 1) = v15;
    *(_QWORD *)&v41 = CFSTR("asen");
    *((_QWORD *)&v41 + 1) = CFSTR("extr");
    *(_QWORD *)&v28 = v15;
    *((_QWORD *)&v28 + 1) = v14;
    *(_QWORD *)&v42 = CFSTR("next");
    *((_QWORD *)&v42 + 1) = CFSTR("encr");
    if (a3)
      v16 = v15;
    else
      v16 = v14;
    *(_QWORD *)&v29 = v15;
    *((_QWORD *)&v29 + 1) = v16;
    if (a3)
      v17 = v14;
    else
      v17 = v15;
    *(_QWORD *)&v43 = CFSTR("decr");
    *((_QWORD *)&v43 + 1) = CFSTR("drve");
    *(_QWORD *)&v30 = v17;
    *((_QWORD *)&v30 + 1) = v14;
    *(_QWORD *)&v44 = CFSTR("sign");
    *((_QWORD *)&v44 + 1) = CFSTR("vrfy");
    *(_QWORD *)&v31 = v17;
    *((_QWORD *)&v31 + 1) = v16;
    *(_QWORD *)&v45 = CFSTR("snrc");
    *((_QWORD *)&v45 + 1) = CFSTR("vyrc");
    *(_QWORD *)&v32 = v15;
    *((_QWORD *)&v32 + 1) = v15;
    *(_QWORD *)&v46 = CFSTR("wrap");
    *((_QWORD *)&v46 + 1) = CFSTR("unwp");
    *(_QWORD *)&v33 = v16;
    *((_QWORD *)&v33 + 1) = v17;
    *(_QWORD *)&v47 = CFSTR("v_Data");
    v18 = theData;
    if (a3)
      v18 = a3;
    *(_QWORD *)&v34 = v18;
    v19 = CFDictionaryCreate(v6, (const void **)keys, (const void **)values, 23, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFRelease(v12);
  }
  if (theData)
    CFRelease(theData);
  if (v8)
LABEL_18:
    CFRelease(v8);
  return v19;
}

__CFData *SecSHA1DigestCreate(const __CFAllocator *a1, uint64_t a2, unint64_t a3)
{
  __CFData *Mutable;

  Mutable = 0;
  if (a2 && !(a3 >> 31))
  {
    Mutable = CFDataCreateMutable(a1, 20);
    CFDataSetLength(Mutable, 20);
    CFDataGetMutableBytePtr(Mutable);
    CCDigest();
  }
  return Mutable;
}

CFTypeRef SecKeyCopySubjectPublicKeyInfo(__SecKey *a1)
{
  uint64_t AlgorithmId;
  __CFData *Mutable;
  const UInt8 *BytePtr;
  CFIndex v5;
  CFTypeRef v6;
  uint64_t v7;
  int NamedCurve;
  void *v9;
  void *v10;
  __CFData *v11;
  UInt8 *MutableBytePtr;
  const __CFData *v13;
  CFIndex length;
  __int128 v16;
  __int128 v17;
  const __CFData *v18;

  v18 = 0;
  AlgorithmId = SecKeyGetAlgorithmId((uint64_t)a1);
  v16 = 0u;
  v17 = 0u;
  if (SecKeyCopyPublicBytes((uint64_t)a1, (uint64_t)&v18))
    goto LABEL_15;
  if (!v18)
    return 0;
  if (!CFDataGetLength(v18))
  {
LABEL_15:
    v6 = 0;
    goto LABEL_22;
  }
  Mutable = CFDataCreateMutable(0, 0);
  CFDataAppendBytes(Mutable, byte_18AA5F058, 1);
  BytePtr = CFDataGetBytePtr(v18);
  v5 = CFDataGetLength(v18);
  CFDataAppendBytes(Mutable, BytePtr, v5);
  if (v18)
    CFRelease(v18);
  v18 = Mutable;
  *(_QWORD *)&v17 = CFDataGetBytePtr(Mutable);
  v6 = 0;
  *((_QWORD *)&v17 + 1) = CFDataGetLength(v18);
  switch(AlgorithmId)
  {
    case 1:
      *(_QWORD *)&v16 = &encodedAlgIdRSA;
      v7 = 13;
      goto LABEL_19;
    case 3:
      NamedCurve = SecECKeyGetNamedCurve(a1);
      if (NamedCurve == 25)
      {
        v10 = &encodedAlgIdECsecp521;
LABEL_18:
        *(_QWORD *)&v16 = v10;
        v7 = 16;
        goto LABEL_19;
      }
      if (NamedCurve == 24)
      {
        v10 = &encodedAlgIdECsecp384;
        goto LABEL_18;
      }
      if (NamedCurve != 23)
        goto LABEL_15;
      *(_QWORD *)&v16 = &encodedAlgIdECsecp256;
      v7 = 19;
LABEL_19:
      *((_QWORD *)&v16 + 1) = v7;
      length = DERLengthOfEncodedSequence(0x2000000000000010, (unint64_t)&v16, (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs, (uint64_t)&DERSubjPubKeyInfoItemSpecs);
      v11 = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], length);
      CFDataSetLength(v11, length);
      MutableBytePtr = CFDataGetMutableBytePtr(v11);
      if (!DEREncodeSequence(0x2000000000000010, (unint64_t)&v16, (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs, (uint64_t)&DERSubjPubKeyInfoItemSpecs, (unint64_t)MutableBytePtr, (unint64_t *)&length))
      {
        CFDataSetLength(v11, length);
        v6 = CFRetain(v11);
        if (!v11)
          goto LABEL_22;
        goto LABEL_21;
      }
      v6 = 0;
      if (v11)
LABEL_21:
        CFRelease(v11);
LABEL_22:
      v13 = v18;
      if (v18)
      {
        v18 = 0;
        CFRelease(v13);
      }
      return v6;
    case 4:
      v9 = &encodedAlgIdEd25519;
      goto LABEL_14;
    case 6:
      v9 = &encodedAlgIdEd448;
LABEL_14:
      *(_QWORD *)&v16 = v9;
      v7 = 5;
      goto LABEL_19;
    default:
      goto LABEL_22;
  }
}

uint64_t SecKeyCopyPublicBytes(uint64_t a1, uint64_t a2)
{
  void *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t (*v7)(uint64_t, uint64_t);
  uint64_t v8;
  os_activity_scope_state_s v10;

  v4 = (void *)MEMORY[0x18D770A24]();
  v5 = _os_activity_create(&dword_18A900000, "SecKeyCopyPublicBytes", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v10.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v10.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &v10);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCopyPublicBytes");
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)v6 >= 2u && (v7 = *(uint64_t (**)(uint64_t, uint64_t))(v6 + 112)) != 0)
    v8 = v7(a1, a2);
  else
    v8 = 4294967292;
  os_activity_scope_leave(&v10);

  objc_autoreleasePoolPop(v4);
  return v8;
}

void sub_18A912184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

CFDataRef SecCertificateCopyPrecertTBS(uint64_t a1)
{
  CFDataRef v1;
  unint64_t v2;
  _OWORD *v4;
  char *v5;
  char *v6;
  __int128 v7;
  unint64_t v8;
  int v9;
  __int128 v10;
  char *v11;
  void *v12;
  size_t v13;
  UInt8 *v14;
  _OWORD v16[3];
  unint64_t v17[3];
  _QWORD v18[3];
  _OWORD v19[9];
  __int128 v20;
  __int128 v21;
  UInt8 *v22;
  CFIndex v23;
  __int128 v24;

  v1 = 0;
  v24 = *(_OWORD *)(a1 + 32);
  v22 = 0;
  v23 = 0;
  v21 = 0uLL;
  v2 = *(_QWORD *)(a1 + 512);
  if (v2 > 0x555555555555554)
    return v1;
  v4 = malloc_type_malloc(16 * v2, 0x1010040FDD9F14CuLL);
  v5 = (char *)malloc_type_malloc(24 * *(_QWORD *)(a1 + 512), 0x1000040D248FAB4uLL);
  v6 = v5;
  v1 = 0;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19[8] = v7;
  v20 = v7;
  v19[6] = v7;
  v19[7] = v7;
  v19[4] = v7;
  v19[5] = v7;
  v19[2] = v7;
  v19[3] = v7;
  v19[0] = v7;
  v19[1] = v7;
  if (!v4 || !v5)
    goto LABEL_25;
  if (DERParseSequence((uint64_t)&v24, (unsigned __int16)DERNumTBSCertItemSpecs, (uint64_t)&DERTBSCertItemSpecs, (unint64_t)v19, 0xA0uLL))goto LABEL_34;
  if (*((_QWORD *)&v20 + 1))
  {
    memset(v18, 170, sizeof(v18));
    if (DERDecodeSeqInit((uint64_t)&v20, v18, &v18[1]) || v18[0] != 0x2000000000000010)
      goto LABEL_34;
    v8 = 0;
    memset(v17, 170, sizeof(v17));
    while (1)
    {
      v9 = DERDecodeSeqNext(&v18[1], v17);
      if (v9)
        break;
      if (v17[0] != 0x2000000000000010)
        goto LABEL_34;
      *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v16[1] = v10;
      v16[2] = v10;
      v16[0] = v10;
      if (DERParseSequenceContent(&v17[1], (unsigned __int16)DERNumExtensionItemSpecs, (uint64_t)&DERExtensionItemSpecs, (unint64_t)v16, 0x30uLL))goto LABEL_34;
      if (*((_QWORD *)&v16[0] + 1) != 10
        || memcmp(*(const void **)&v16[0], &_oidGoogleEmbeddedSignedCertificateTimestamp, 0xAuLL))
      {
        if (v8 > *(_QWORD *)(a1 + 512))
          goto LABEL_34;
        v4[v8] = *(_OWORD *)&v17[1];
        v11 = &v6[24 * v8];
        *((_WORD *)v11 + 8) = 0;
        *(_QWORD *)v11 = 16 * v8;
        *((_QWORD *)v11 + 1) = 0x2000000000000010;
        ++v8;
      }
    }
    if (v9 != 1)
      goto LABEL_34;
  }
  else
  {
    LOWORD(v8) = 0;
  }
  *((_QWORD *)&v21 + 1) = DERLengthOfEncodedSequence(0x2000000000000010, (unint64_t)v4, (unsigned __int16)v8, (uint64_t)v6);
  v12 = malloc_type_malloc(*((size_t *)&v21 + 1), 0x52BFE9E9uLL);
  *(_QWORD *)&v21 = v12;
  if (v12)
  {
    if (!DEREncodeSequence(0x2000000000000010, (unint64_t)v4, (unsigned __int16)v8, (uint64_t)v6, (unint64_t)v12, (unint64_t *)&v21 + 1))
    {
      v20 = v21;
      v13 = DERLengthOfEncodedSequence(0x2000000000000010, (unint64_t)v19, (unsigned __int16)DERNumTBSCertItemSpecs, (uint64_t)&DERTBSCertItemSpecs);
      v23 = v13;
      if (v13 <= 0x7FFFFFFFFFFFFFFELL)
      {
        v14 = (UInt8 *)malloc_type_malloc(v13, 0x26C57AFBuLL);
        v22 = v14;
        if (v14)
        {
          if (!DEREncodeSequence(0x2000000000000010, (unint64_t)v19, (unsigned __int16)DERNumTBSCertItemSpecs, (uint64_t)&DERTBSCertItemSpecs, (unint64_t)v14, (unint64_t *)&v23))
          {
            v1 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v22, v23);
            goto LABEL_25;
          }
        }
      }
    }
LABEL_34:
    v1 = 0;
LABEL_25:
    if ((_QWORD)v21)
      free((void *)v21);
    goto LABEL_27;
  }
  v1 = 0;
LABEL_27:
  if (v22)
    free(v22);
  if (v4)
    free(v4);
  if (v6)
    free(v6);
  return v1;
}

uint64_t DEREncodeSequence(uint64_t result, unint64_t a2, unsigned int a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  if ((a2 | 0x7FFFFFFFFFFFFFFFLL) >= a2)
    return DEREncodeSequenceFromObject(result, a2, ~a2 & 0x7FFFFFFFFFFFFFFFLL, a3, a4, a5, *a6, a6);
  __break(0x5519u);
  return result;
}

uint64_t SecECPublicKeyCopyPublicOctets(const void *a1, __CFData **a2)
{
  const __CFAllocator *v3;
  __CFData *v4;

  v3 = CFGetAllocator(a1);
  v4 = SecECPublicKeyExport(v3);
  *a2 = v4;
  if (v4)
    return 0;
  else
    return 4294941021;
}

__CFData *SecECPublicKeyExport(const __CFAllocator *a1)
{
  CFIndex v2;
  __CFData *Mutable;

  v2 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  Mutable = CFDataCreateMutable(a1, 0);
  CFDataSetLength(Mutable, v2);
  CFDataGetMutableBytePtr(Mutable);
  ccec_export_pub();
  return Mutable;
}

__CFData *SecRSAPublicKeyCreatePKCS1(const __CFAllocator *a1)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  CFIndex v6;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  UInt8 *v9;
  UInt8 *v10;
  UInt8 *v11;
  UInt8 *v12;
  unint64_t v14;
  unint64_t v15;

  v2 = ccn_write_int_size();
  v3 = ccn_write_int_size();
  v4 = DERLengthOfItem(2uLL, v2);
  v5 = DERLengthOfItem(2uLL, v3) + v4;
  v6 = DERLengthOfItem(0x10uLL, v5);
  Mutable = CFDataCreateMutable(a1, 0);
  CFDataSetLength(Mutable, v6);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  *MutableBytePtr = 48;
  v9 = MutableBytePtr + 1;
  v14 = 4;
  DEREncodeLength(v5, (unint64_t)(MutableBytePtr + 1), &v14);
  v10 = &v9[v14];
  *v10++ = 2;
  v15 = 4;
  DEREncodeLength(v2, (unint64_t)v10, &v15);
  v11 = &v10[v15];
  ccn_write_int();
  v12 = &v11[v2];
  *v12 = 2;
  v15 = 4;
  DEREncodeLength(v3, (unint64_t)(v12 + 1), &v15);
  ccn_write_int();
  return Mutable;
}

__CFData *SecCopySequenceFromContent(const __CFData *a1)
{
  _QWORD v3[2];

  if (CFDataGetLength(a1) < 0)
    return 0;
  v3[0] = CFDataGetBytePtr(a1);
  v3[1] = CFDataGetLength(a1);
  return SecDERItemCopySequence((uint64_t)v3);
}

__CFData *SecDERItemCopySequence(uint64_t a1)
{
  CFIndex v2;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  UInt8 *v5;
  uint64_t v7;

  v7 = DERLengthOfLength(*(_QWORD *)(a1 + 8));
  v2 = v7 + *(_QWORD *)(a1 + 8) + 1;
  if (v2 < 0)
    return 0;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v2);
  CFDataSetLength(Mutable, v2);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  *MutableBytePtr = 48;
  v5 = MutableBytePtr + 1;
  if (DEREncodeLength(*(_QWORD *)(a1 + 8), (unint64_t)(MutableBytePtr + 1), (unint64_t *)&v7))
  {
    if (!Mutable)
      return Mutable;
    CFRelease(Mutable);
    return 0;
  }
  memcpy(&v5[v7], *(const void **)a1, *(_QWORD *)(a1 + 8));
  return Mutable;
}

unint64_t DEREncodeLength(unint64_t a1, unint64_t a2, unint64_t *a3)
{
  return DEREncodeLengthSized(a1, a2, *a3, (uint64_t *)a3);
}

uint64_t DERLengthOfLength(unint64_t a1)
{
  uint64_t result;
  unint64_t v2;
  BOOL v3;

  if (a1 < 0x80)
    return 1;
  v2 = a1;
  result = 1;
  do
  {
    ++result;
    v3 = v2 > 0xFF;
    v2 >>= 8;
  }
  while (v3);
  return result;
}

uint64_t DEREncodeSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5, unint64_t a6, unint64_t a7, unint64_t *a8)
{
  unint64_t v8;
  unint64_t v11;
  uint64_t result;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _BYTE *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  const void **v27;
  __int16 v28;
  unint64_t v30;
  unint64_t v31;
  char v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  size_t v36;
  unint64_t v37;
  size_t v39;
  BOOL v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v44;
  unint64_t v45[2];

  v45[1] = *MEMORY[0x1E0C80C00];
  v8 = ~a6;
  if (~a6 < a7)
    goto LABEL_73;
  v11 = *a8;
  v44 = a7;
  v45[0] = 0;
  if (v11 < a7)
    goto LABEL_74;
  result = DEREncodeTag(a1, a6, &v44);
  if ((_DWORD)result)
    return result;
  if (v44 > v8)
    goto LABEL_73;
  v17 = a7 - v44;
  if (a7 < v44)
    goto LABEL_75;
  v18 = a6 + a7;
  v19 = a6 + v44;
  if (a6 + v44 < v18)
  {
    result = DERContentLengthOfEncodedSequence(a2, a3, a4, a5, v45);
    if ((_DWORD)result)
      return result;
    v44 = v17;
    if (v19 > a6 + v11 || v19 < a6 || v17 > a6 + v11 - v19)
      goto LABEL_74;
    v42 = a6 + v11;
    v20 = v45[0];
    result = DEREncodeLengthSized(v45[0], v19, v17, (uint64_t *)&v44);
    if ((_DWORD)result)
      return result;
    v21 = v42;
    if (__CFADD__(v19, v44))
    {
LABEL_73:
      __break(0x5513u);
      goto LABEL_74;
    }
    v22 = v17 - v44;
    if (v17 >= v44)
    {
      v23 = (_BYTE *)(v19 + v44);
      if (!__CFADD__(v19 + v44, v20))
      {
        if ((unint64_t)&v23[v20] > v18)
          return 7;
        if (a4)
        {
          v24 = 0;
          v25 = a2 + a3;
          v41 = 24 * a4;
          while (1)
          {
            if (v24 > ~a5)
              goto LABEL_73;
            v26 = *(_QWORD *)(a5 + v24);
            if (v26 > ~a2)
              goto LABEL_73;
            v27 = (const void **)(a2 + v26);
            v28 = *(_WORD *)(a5 + v24 + 16);
            if ((v28 & 0x200) != 0)
              break;
            if ((v28 & 1) == 0)
              goto LABEL_29;
            if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
              goto LABEL_74;
            if (v27[1])
            {
LABEL_29:
              v44 = v22;
              if ((unint64_t)v23 > v21 || (unint64_t)v23 < a6 || v22 > v21 - (unint64_t)v23)
                goto LABEL_74;
              result = DEREncodeTag(*(_QWORD *)(a5 + v24 + 8), (unint64_t)v23, &v44);
              if ((_DWORD)result)
                return result;
              if (__CFADD__(v23, v44))
                goto LABEL_73;
              v30 = v22 - v44;
              if (v22 < v44)
                goto LABEL_75;
              if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
                goto LABEL_74;
              v31 = (unint64_t)v27[1];
              v45[0] = v31;
              v32 = 1;
              if ((v28 & 0x100) != 0 && v31 && *(char *)*v27 < 0)
              {
                v32 = 0;
                v45[0] = ++v31;
              }
              v33 = (unint64_t)&v23[v44];
              v44 = v30;
              if (v33 > v42 || v33 < a6 || v30 > v42 - v33)
                goto LABEL_74;
              result = DEREncodeLengthSized(v31, v33, v30, (uint64_t *)&v44);
              if ((_DWORD)result)
                return result;
              v34 = v44;
              if (__CFADD__(v33, v44))
                goto LABEL_73;
              v35 = v30 - v44;
              if (v30 < v44)
                goto LABEL_75;
              v23 = (_BYTE *)(v33 + v44);
              if ((v32 & 1) == 0)
              {
                if (v23 == (_BYTE *)-1)
                  goto LABEL_73;
                if ((unint64_t)v23 >= v42 || (unint64_t)v23 < a6)
                  goto LABEL_74;
                *v23 = 0;
                --v35;
                if (v30 == v34)
                  goto LABEL_75;
                ++v23;
              }
              if ((unint64_t)v23 > v42)
                goto LABEL_74;
              if ((unint64_t)v23 < a6)
                goto LABEL_74;
              v36 = (size_t)v27[1];
              if (v36 > v42 - (unint64_t)v23)
                goto LABEL_74;
              result = (uint64_t)memmove(v23, *v27, v36);
              v21 = v42;
              v37 = (unint64_t)v27[1];
              if (__CFADD__(v23, v37))
                goto LABEL_73;
              v22 = v35 - v37;
              if (v35 < v37)
                goto LABEL_75;
              goto LABEL_69;
            }
LABEL_70:
            v24 += 24;
            if (v41 == v24)
              goto LABEL_71;
          }
          if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25)
            goto LABEL_74;
          if ((unint64_t)v23 > v21)
            goto LABEL_74;
          if ((unint64_t)v23 < a6)
            goto LABEL_74;
          v39 = (size_t)v27[1];
          if (v39 > v21 - (unint64_t)v23)
            goto LABEL_74;
          result = (uint64_t)memmove(v23, *v27, v39);
          v21 = v42;
          v37 = (unint64_t)v27[1];
          if (__CFADD__(v23, v37))
            goto LABEL_73;
          v40 = v22 >= v37;
          v22 -= v37;
          if (!v40)
            goto LABEL_75;
LABEL_69:
          v23 += v37;
          goto LABEL_70;
        }
LABEL_71:
        if ((unint64_t)&v23[-a6] <= *a8)
        {
          result = 0;
          *a8 = (unint64_t)&v23[-a6];
          return result;
        }
LABEL_74:
        __break(0x5519u);
      }
      goto LABEL_73;
    }
LABEL_75:
    __break(0x5515u);
    return result;
  }
  return 7;
}

unint64_t DEREncodeLengthSized(unint64_t result, unint64_t a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;

  if (result >= 0x80)
  {
    v5 = 0;
    v6 = result;
    do
    {
      --v5;
      v7 = v6 > 0xFF;
      v6 >>= 8;
    }
    while (v7);
    v8 = -v5;
    v9 = 7;
    if (-v5 < a3 && v8 <= 0x7E)
    {
      if (*a4)
      {
        v4 = 1 - v5;
        *(_BYTE *)a2 = -(char)v5 | 0x80;
        if (v8 < ~a2)
        {
          v10 = (_BYTE *)(a2 - v5);
          if (a2 - v5 != -2)
          {
            v11 = (_BYTE *)(a2 + *a4);
            while (v10 != (_BYTE *)-1)
            {
              if (v10 >= v11 || (unint64_t)v10 < a2)
                goto LABEL_23;
              *v10-- = result;
              v7 = result > 0xFF;
              result >>= 8;
              if (!v7)
              {
                if (v8 >= *a4)
                  goto LABEL_23;
                goto LABEL_19;
              }
            }
          }
        }
        __break(0x5513u);
      }
      goto LABEL_23;
    }
    return v9;
  }
  if (!a3)
    return 7;
  if (*a4)
  {
    *(_BYTE *)a2 = result;
    if (*a4)
    {
      v4 = 1;
LABEL_19:
      v9 = 0;
      *a4 = v4;
      return v9;
    }
  }
LABEL_23:
  __break(0x5519u);
  return result;
}

uint64_t DEREncodeTag(uint64_t result, unint64_t a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  unint64_t v11;

  v3 = result & 0x1FFFFFFFFFFFFFFFLL;
  if ((result & 0x1FFFFFFFFFFFFFFFuLL) < 0x1F)
  {
    if (*a3)
    {
      *(_BYTE *)a2 = HIBYTE(result) & 0xE0 | result;
      v8 = 1;
      goto LABEL_17;
    }
    return 7;
  }
  v4 = 0;
  v5 = result & 0x1FFFFFFFFFFFFFFFLL;
  do
  {
    ++v4;
    v6 = v5 > 0x7F;
    v5 >>= 7;
  }
  while (v6);
  v7 = *a3;
  if (v4 >= *a3)
    return 7;
  if (v4 >= ~a2 || (*(_BYTE *)a2 = HIBYTE(result) | 0x1F, a2 + v4 == -2))
  {
LABEL_20:
    __break(0x5513u);
    goto LABEL_21;
  }
  if (a2 + v4 >= a2)
  {
    v8 = v4 + 1;
    *(_BYTE *)(a2 + v4) = result & 0x7F;
    if (v3 >= 0x80)
    {
      v9 = (_BYTE *)(a2 + v4 - 1);
      v10 = (_BYTE *)(a2 + v7);
      while (v9 != (_BYTE *)-2)
      {
        if (v9 >= v10 || (unint64_t)v9 < a2)
          goto LABEL_21;
        v11 = v3 >> 14;
        v3 >>= 7;
        *v9-- = v3 | 0x80;
        if (!v11)
          goto LABEL_17;
      }
      goto LABEL_20;
    }
LABEL_17:
    if (v8 <= *a3)
    {
      result = 0;
      *a3 = v8;
      return result;
    }
  }
LABEL_21:
  __break(0x5519u);
  return result;
}

uint64_t DERLengthOfEncodedSequence(uint64_t a1, unint64_t a2, int a3, uint64_t a4)
{
  uint64_t v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  v5[0] = 0;
  if ((a2 | 0x7FFFFFFFFFFFFFFFLL) < a2)
    __break(0x5519u);
  if (DERLengthOfEncodedSequenceFromObject(a1, a2, ~a2 & 0x7FFFFFFFFFFFFFFFLL, a3, a4, v5))
    return 0;
  else
    return v5[0];
}

unint64_t DERLengthOfEncodedSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t *a6)
{
  unint64_t result;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v17[0] = 0;
  result = DERContentLengthOfEncodedSequence(a2, a3, a4, a5, v17);
  if (!(_DWORD)result)
  {
    v9 = a1 & 0x1FFFFFFFFFFFFFFFLL;
    v10 = 1;
    if ((a1 & 0x1FFFFFFFFFFFFFFFuLL) >= 0x1F)
    {
      do
      {
        ++v10;
        v11 = v9 > 0x7F;
        v9 >>= 7;
      }
      while (v11);
    }
    v12 = 1;
    if (v17[0] >= 0x80uLL)
    {
      v13 = v17[0];
      do
      {
        ++v12;
        v11 = v13 > 0xFF;
        v13 >>= 8;
      }
      while (v11);
    }
    v14 = __CFADD__(v10, v12);
    v15 = v10 + v12;
    if (v14 || (v14 = __CFADD__(v15, v17[0]), v16 = v15 + v17[0], v14))
    {
      __break(0x5500u);
    }
    else
    {
      result = 0;
      *a6 = v16;
    }
  }
  return result;
}

unint64_t DERContentLengthOfEncodedSequence(unint64_t result, unint64_t a2, int a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  unsigned __int8 **v10;
  __int16 v11;
  unint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned __int8 *v20;
  unint64_t v21;
  uint64_t v22;

  v5 = 0;
  if (!a3)
  {
LABEL_38:
    result = 0;
LABEL_40:
    *a5 = v5;
    return result;
  }
  v6 = 0;
  v7 = result + a2;
  while (24 * (unint64_t)v6 <= ~a4)
  {
    v8 = *(_QWORD *)(a4 + 24 * v6);
    v9 = v8 > 0xFFFFFFFFFFFFFFEFLL || v8 + 16 > a2;
    if (v9)
    {
      v5 = 0;
      result = 7;
      goto LABEL_40;
    }
    if (v8 > ~result)
      break;
    v10 = (unsigned __int8 **)(result + v8);
    v11 = *(_WORD *)(a4 + 24 * v6 + 16);
    if ((v11 & 0x200) == 0)
    {
      if ((v11 & 1) != 0)
      {
        if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
          goto LABEL_43;
        if (!v10[1])
          goto LABEL_37;
      }
      v13 = *(_QWORD *)(a4 + 24 * v6 + 8) & 0x1FFFFFFFFFFFFFFFLL;
      v14 = 1;
      if (v13 >= 0x1F)
      {
        do
        {
          ++v14;
          v9 = v13 > 0x7F;
          v13 >>= 7;
        }
        while (v9);
      }
      v15 = __CFADD__(v5, v14);
      v16 = v5 + v14;
      if (v15)
        goto LABEL_42;
      if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
        goto LABEL_43;
      v17 = (unint64_t)v10[1];
      if ((*(_WORD *)(a4 + 24 * v6 + 16) & 0x100) != 0)
      {
        if (v17)
        {
          v17 += (unint64_t)**v10 >> 7;
          goto LABEL_24;
        }
LABEL_25:
        v18 = 1;
      }
      else
      {
LABEL_24:
        if (v17 < 0x80)
          goto LABEL_25;
        v18 = 1;
        v21 = v17;
        do
        {
          ++v18;
          v9 = v21 > 0xFF;
          v21 >>= 8;
        }
        while (v9);
      }
      v15 = __CFADD__(v16, v18);
      v22 = v16 + v18;
      if (v15)
        goto LABEL_42;
      v15 = __CFADD__(v22, v17);
      v5 = v22 + v17;
      if (v15)
        goto LABEL_42;
      goto LABEL_37;
    }
    if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7)
      goto LABEL_43;
    v20 = v10[1];
    v15 = __CFADD__(v5, v20);
    v5 += (uint64_t)v20;
    if (v15)
      goto LABEL_42;
LABEL_37:
    if (++v6 == a3)
      goto LABEL_38;
  }
  __break(0x5513u);
LABEL_42:
  __break(0x5500u);
LABEL_43:
  __break(0x5519u);
  return result;
}

uint64_t SecRSAPublicKeyCopyPublicSerialization(const void *a1, __CFData **a2)
{
  const __CFAllocator *v3;
  __CFData *PKCS1;

  v3 = CFGetAllocator(a1);
  PKCS1 = SecRSAPublicKeyCreatePKCS1(v3);
  *a2 = PKCS1;
  if (PKCS1)
    return 0;
  else
    return 4294941021;
}

uint64_t SecKeyGetSize(uint64_t a1, int a2)
{
  uint64_t (*v4)(uint64_t);
  unint64_t v5;
  int v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;

  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  v4 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 80);
  if (v4)
    v5 = v4(a1);
  else
    v5 = 0;
  if (SecKeyGetAlgorithmId(a1) == 3)
  {
    if (a2 == 10 || a2 == 0)
      v7 = 0;
    else
      v7 = a2;
    if (v7)
    {
      v8 = 8;
      if (v5 > 0x41)
        v8 = 9;
      v9 = v8 + 2 * v5;
      if (v7 == 2)
        v10 = 0;
      else
        v10 = v5;
      if (v7 == 1)
        v5 = v9;
      else
        v5 = v10;
    }
    else if (v5 > 0x41)
    {
      return 521;
    }
  }
  if (a2 == 10 || !a2)
    v5 *= 8;
  return v5;
}

uint64_t SecECKeyGetNamedCurve(__SecKey *a1)
{
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  const __CFNumber *Value;
  const __CFNumber *v5;
  CFTypeID v6;
  uint64_t v7;
  uint64_t valuePtr;

  if (SecKeyGetAlgorithmId((uint64_t)a1) != 3)
    return 0xFFFFFFFFLL;
  v2 = SecKeyCopyAttributes(a1);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = v2;
  Value = (const __CFNumber *)CFDictionaryGetValue(v2, CFSTR("bsiz"));
  valuePtr = 0;
  if (!Value)
    goto LABEL_10;
  v5 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 != CFNumberGetTypeID() || !CFNumberGetValue(v5, kCFNumberCFIndexType, &valuePtr))
    goto LABEL_10;
  switch(valuePtr)
  {
    case 521:
      v7 = 25;
      break;
    case 384:
      v7 = 24;
      break;
    case 256:
      v7 = 23;
      break;
    default:
LABEL_10:
      v7 = 0xFFFFFFFFLL;
      break;
  }
  CFRelease(v3);
  return v7;
}

CFDictionaryRef SecKeyCopyAttributes(SecKeyRef key)
{
  void *v2;
  NSObject *v3;
  uint64_t (*v4)(SecKeyRef);
  __CFDictionary *Mutable;
  const __CFAllocator *v6;
  uint64_t (*v7)(SecKeyRef);
  CFNumberRef v8;
  unint64_t v9;
  _QWORD *v10;
  const void **v11;
  uint64_t valuePtr;
  os_activity_scope_state_s state;

  v2 = (void *)MEMORY[0x18D770A24]();
  v3 = _os_activity_create(&dword_18A900000, "SecKeyCopyAttributes", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyCopyAttributes");
  v4 = *(uint64_t (**)(SecKeyRef))(*((_QWORD *)key + 2) + 88);
  if (v4)
  {
    Mutable = (__CFDictionary *)v4(key);
    goto LABEL_14;
  }
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = *(uint64_t (**)(SecKeyRef))(*((_QWORD *)key + 2) + 80);
  if (v7)
  {
    valuePtr = 8 * v7(key);
    if (valuePtr >= 1)
    {
      v8 = CFNumberCreate(v6, kCFNumberCFIndexType, &valuePtr);
      CFDictionarySetValue(Mutable, CFSTR("bsiz"), v8);
      CFRelease(v8);
    }
  }
  else
  {
    valuePtr = 0;
  }
  v9 = SecKeyGetAlgorithmId((uint64_t)key) - 1;
  if (v9 <= 6 && ((0x7Du >> v9) & 1) != 0)
    CFDictionarySetValue(Mutable, CFSTR("type"), *off_1E1FD7458[v9]);
  v10 = (_QWORD *)*((_QWORD *)key + 2);
  if (v10[5] || v10[8])
  {
    v11 = (const void **)&kSecAttrKeyClassPrivate;
LABEL_13:
    CFDictionarySetValue(Mutable, CFSTR("kcls"), *v11);
    goto LABEL_14;
  }
  if (v10[6] || v10[7])
  {
    v11 = (const void **)&kSecAttrKeyClassPublic;
    goto LABEL_13;
  }
LABEL_14:
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v2);
  return Mutable;
}

void sub_18A913480(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

__CFDictionary *SecECPublicKeyCopyAttributeDictionary(const void *a1)
{
  const __CFDictionary *v1;
  __CFDictionary *MutableCopy;

  v1 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)CFSTR("73"), 0);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v1);
  CFDictionarySetValue(MutableCopy, CFSTR("drve"), (const void *)*MEMORY[0x1E0C9AE40]);
  if (v1)
    CFRelease(v1);
  return MutableCopy;
}

uint64_t CERT_VerifyCert(const void *a1, const void *a2, SecTrustRef *a3, CFAbsoluteTime a4)
{
  uint64_t v6;
  const __CFDate *v7;
  SecTrustRef v8;
  SecTrustRef v10;
  _QWORD *ThreadErrInfo;
  int v12;
  SecTrustRef trust;
  int v14;

  trust = 0;
  v6 = SecTrustCreateWithCertificates(a1, a2, &trust);
  if ((_DWORD)v6)
    goto LABEL_5;
  v7 = CFDateCreate(0, a4);
  v6 = SecTrustSetVerifyDate(trust, v7);
  if (v7)
    CFRelease(v7);
  if ((_DWORD)v6)
    goto LABEL_5;
  if (a3)
  {
    v6 = 0;
    *a3 = trust;
    return v6;
  }
  v12 = -1431655766;
  v6 = SecTrustEvaluateInternal(trust, &v12);
  if ((_DWORD)v6)
    goto LABEL_5;
  if (v12 != 4 && v12 != 1)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v14);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0xFFFFE01500000000;
    v6 = 0xFFFFFFFFLL;
LABEL_5:
    v8 = trust;
    if (trust)
    {
      trust = 0;
      CFRelease(v8);
    }
    return v6;
  }
  v10 = trust;
  if (trust)
  {
    trust = 0;
    CFRelease(v10);
  }
  return 0;
}

OSStatus SecTrustSetVerifyDate(SecTrustRef trust, CFDateRef verifyDate)
{
  OSStatus result;
  CFTypeID v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  _QWORD v9[6];
  _QWORD block[5];

  result = -50;
  if (trust && verifyDate)
  {
    v5 = CFGetTypeID(verifyDate);
    if (v5 == CFDateGetTypeID())
    {
      v6 = MEMORY[0x1E0C809B0];
      v7 = *((_QWORD *)trust + 17);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
      block[3] = &__block_descriptor_tmp_49_11514;
      block[4] = trust;
      dispatch_sync(v7, block);
      v8 = *((_QWORD *)trust + 17);
      v9[0] = v6;
      v9[1] = 0x40000000;
      v9[2] = __SecTrustSetVerifyDate_block_invoke;
      v9[3] = &__block_descriptor_tmp_56_11533;
      v9[4] = trust;
      v9[5] = verifyDate;
      dispatch_sync(v8, v9);
      return 0;
    }
    else
    {
      return -50;
    }
  }
  return result;
}

uint64_t SecTrustGetExceptionResetCount(CFTypeRef *a1)
{
  NSObject *v2;
  uint64_t (*v3)(CFTypeRef *);
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  os_activity_scope_state_s v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  __int128 buf;
  BOOL (*v14)(uint64_t, xpc_object_t, _QWORD *);
  void *v15;
  uint64_t *v16;
  CFTypeRef *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v2 = _os_activity_create(&dword_18A900000, "SecTrustExceptionGetResetCount", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v8.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v8.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &v8);
  if (gTrustd && (v3 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 176)) != 0)
  {
    v4 = v3(a1);
  }
  else
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2000000000;
    v12 = 0;
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 0x40000000;
    v14 = __to_uint_error_request_block_invoke;
    v15 = &unk_1E1FDB4F0;
    v16 = &v9;
    v17 = a1;
    securityd_send_sync_and_do(0x78u, a1, 0, (uint64_t)&buf);
    v4 = v10[3];
    _Block_object_dispose(&v9, 8);
  }
  os_release(v2);
  if (a1)
  {
    if (*a1)
    {
      v5 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "Failed to get the exceptions epoch.", (uint8_t *)&buf, 2u);
      }
    }
  }
  v6 = secLogObjForScope("trust");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v4;
    _os_log_debug_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEBUG, "The exceptions epoch is %lld.", (uint8_t *)&buf, 0xCu);
  }
  os_activity_scope_leave(&v8);
  return v4;
}

uint64_t SecRSAPrivateKeyCopyPublicSerialization(const void *a1, __CFData **a2)
{
  const __CFAllocator *v3;
  __CFData *PKCS1;

  v3 = CFGetAllocator(a1);
  ccrsa_ctx_public();
  PKCS1 = SecRSAPublicKeyCreatePKCS1(v3);
  *a2 = PKCS1;
  if (PKCS1)
    return 0;
  else
    return 4294941021;
}

__CFDictionary *SecRSAPrivateKeyCopyAttributeDictionary(const void *a1)
{
  __CFData *v2;
  __CFData *v3;
  const __CFDictionary *v4;
  __CFDictionary *MutableCopy;
  CFNumberRef v6;
  uint64_t valuePtr;

  v2 = SecRSAPrivateKeyCopyPKCS1(a1);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)CFSTR("42"), v2);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v4);
  CFDictionarySetValue(MutableCopy, CFSTR("drve"), (const void *)*MEMORY[0x1E0C9AE40]);
  valuePtr = cczp_bitlen();
  v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, &valuePtr);
  CFDictionarySetValue(MutableCopy, CFSTR("bsiz"), v6);
  CFDictionarySetValue(MutableCopy, CFSTR("esiz"), v6);
  if (v6)
    CFRelease(v6);
  if (v4)
    CFRelease(v4);
  CFRelease(v3);
  return MutableCopy;
}

__CFData *SecRSAPrivateKeyCopyPKCS1(const void *a1)
{
  const __CFAllocator *v1;
  CFIndex v2;
  __CFData *Mutable;
  __CFData *v4;

  v1 = CFGetAllocator(a1);
  v2 = ccrsa_export_priv_size();
  Mutable = CFDataCreateMutable(v1, v2);
  v4 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, v2);
    CFDataGetMutableBytePtr(v4);
    if (ccrsa_export_priv())
    {
      CFRelease(v4);
      return 0;
    }
  }
  return v4;
}

__CFData *SecSHA256DigestCreateFromData(const __CFAllocator *a1, const __CFData *a2)
{
  __CFData *Mutable;

  Mutable = CFDataCreateMutable(a1, 32);
  CFDataSetLength(Mutable, 32);
  CFDataGetBytePtr(a2);
  CFDataGetLength(a2);
  CFDataGetMutableBytePtr(Mutable);
  CCDigest();
  return Mutable;
}

int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes)
{
  return CCRandomCopyBytes();
}

uint64_t SecCertificateGetCRLDistributionPoints(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 464);
  return result;
}

uint64_t sec_protocol_helper_ciphersuite_group_to_ciphersuite_list(unsigned int a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t result;

  if (!a2)
    return 0;
  if (a1 > 4)
  {
    v2 = 0;
    result = 0;
  }
  else
  {
    v2 = qword_18AA5AB78[a1];
    result = (uint64_t)*(&off_1E1FCD898 + a1);
  }
  *a2 = v2;
  return result;
}

BOOL __sec_protocol_options_get_enable_encrypted_client_hello_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_DWORD *)(a2 + 361) & 0x2000000) != 0;
  return a2 != 0;
}

CFTypeRef SecPolicyCheckCertSubjectCountry(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2;
  CFTypeID v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const void *ValueAtIndex;

  v2 = cf;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (v5 = SecCertificateCopyCountry(a1)) != 0)
    {
      v6 = v5;
      v2 = (CFTypeRef)(CFArrayGetCount(v5) == 1
                    && (ValueAtIndex = CFArrayGetValueAtIndex(v6, 0), CFEqual(v2, ValueAtIndex)));
      CFRelease(v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

CFMutableArrayRef SecCertificateCopyCountry(uint64_t a1)
{
  CFMutableArrayRef Mutable;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendCountryFromX501Name, 1)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

CFMutableStringRef SecCertificateCopyCompanyName(uint64_t a1)
{
  CFMutableStringRef Mutable;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendToCompanyNameString, 1)|| !CFStringGetLength(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t SecPolicyCheckCertSubjectCommonNameTEST(uint64_t a1, CFTypeRef cf)
{
  uint64_t v2;
  CFTypeID v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const void *ValueAtIndex;
  CFStringRef v8;

  v2 = (uint64_t)cf;
  if (!cf)
    return v2;
  v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID())
    return 0;
  v5 = SecCertificateCopyCommonNames(a1);
  v6 = v5;
  if (v5 && CFArrayGetCount(v5) == 1)
  {
    v2 = 1;
LABEL_14:
    CFRelease(v6);
    return v2;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(v6, 0);
  v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("TEST %@ TEST"), v2);
  if (!CFEqual((CFTypeRef)v2, ValueAtIndex))
  {
    if (!v8)
    {
      v2 = 0;
      if (!v6)
        return v2;
      goto LABEL_14;
    }
    v2 = CFEqual(v8, ValueAtIndex) != 0;
    goto LABEL_12;
  }
  v2 = 1;
  if (v8)
LABEL_12:
    CFRelease(v8);
  if (v6)
    goto LABEL_14;
  return v2;
}

CFTypeRef SecPolicyCheckCertSubjectOrganization(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2;
  CFTypeID v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const void *ValueAtIndex;

  v2 = cf;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID()
      && (v5 = SecCertificateCopyOrganizationFromX501NameContent((unint64_t *)(a1 + 184))) != 0)
    {
      v6 = v5;
      v2 = (CFTypeRef)(CFArrayGetCount(v5) == 1
                    && (ValueAtIndex = CFArrayGetValueAtIndex(v6, 0), CFEqual(v2, ValueAtIndex)));
      CFRelease(v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

CFMutableArrayRef SecCertificateCopyOrganizationFromX501NameContent(unint64_t *a1)
{
  CFMutableArrayRef Mutable;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (parseX501NameContent(a1, (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendOrganizationFromX501Name, 1)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

CFTypeRef SecPolicyCheckCertSubjectCommonName(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2;
  CFTypeID v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const void *ValueAtIndex;

  v2 = cf;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (v5 = SecCertificateCopyCommonNames(a1)) != 0)
    {
      v6 = v5;
      v2 = (CFTypeRef)(CFArrayGetCount(v5) == 1
                    && (ValueAtIndex = CFArrayGetValueAtIndex(v6, 0), CFEqual(v2, ValueAtIndex)));
      CFRelease(v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

CFMutableArrayRef SecCertificateCopyCommonNames(uint64_t a1)
{
  CFMutableArrayRef Mutable;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendCommonNamesFromX501Name, 1)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

CFStringRef SecCertificateCopyDescription(__SecCertificate *a1)
{
  CFStringRef v2;
  CFTypeRef v3;
  CFStringRef v4;

  v2 = SecCertificateCopySubjectSummary(a1);
  v3 = SecCertificateCopyIssuerSummary((uint64_t)a1);
  v4 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<cert(%p) s: %@ i: %@>"), a1, v2, v3);
  if (v3)
    CFRelease(v3);
  if (v2)
    CFRelease(v2);
  return v4;
}

CFStringRef SecCertificateCopySubjectSummary(CFStringRef certificate)
{
  CFStringRef v1;
  int v2;
  CFTypeRef v3;
  const __CFString *v4;
  CFStringRef v5;
  const __CFArray *v6;
  CFTypeRef v7;
  uint64_t v8;
  CFTypeRef cf;
  CFTypeRef v10;

  if (certificate)
  {
    v1 = certificate;
    v8 = 0;
    cf = 0;
    v10 = 0;
    v2 = parseX501NameContent((unint64_t *)&certificate[5].length, (uint64_t)&v8, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))obtainSummaryFromX501Name, 1);
    certificate = 0;
    if (!v2)
    {
      v3 = v10;
      if (v10)
      {
        if ((_DWORD)v8 == 4)
        {
          v4 = SecFrameworkCopyLocalizedString(CFSTR("%@ (%@)"), CFSTR("Certificate"));
          v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v4, cf, v10);
          CFRelease(v4);
          CFRelease(cf);
          cf = v5;
          v3 = v10;
        }
        CFRelease(v3);
      }
      if ((_DWORD)v8 != 4)
      {
        v6 = SecCertificateCopyRFC822Names((uint64_t)v1);
        if (v6 || (v6 = SecCertificateCopyDNSNames((uint64_t)v1)) != 0)
        {
          v7 = cf;
          if (cf)
          {
            cf = 0;
            CFRelease(v7);
          }
          cf = CFArrayGetValueAtIndex(v6, 0);
          CFRetain(cf);
          CFRelease(v6);
        }
      }
      return (CFStringRef)cf;
    }
  }
  return certificate;
}

uint64_t parseX501NameContent(unint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v7;
  unsigned int v8;
  int v9;
  unsigned int v11;
  int v12;
  unint64_t v14[3];
  unint64_t v15[2];

  LODWORD(v7) = -1431655766;
  v15[0] = 0xAAAAAAAAAAAAAAAALL;
  v15[1] = 0xAAAAAAAAAAAAAAAALL;
  if (DERDecodeSeqContentInit(a1, v15))
    return 4294941021;
  v8 = 0;
  memset(v14, 170, sizeof(v14));
  while (1)
  {
    v9 = DERDecodeSeqNext(v15, v14);
    if (v9)
      break;
    if (v14[0] != 0x2000000000000011 || v14[2] == 0)
      return 4294941021;
    v11 = parseRDNContent(&v14[1], a2, a3, a4);
    v12 = 4 * (v8 > 0x3FE);
    if (v11)
      v7 = v11;
    else
      v7 = v7;
    if (v11)
      v12 = 1;
    else
      ++v8;
    if (v12)
    {
      if (v12 != 4)
        return v7;
      return 4294941021;
    }
  }
  if (v9 != 1)
    return 4294941021;
  return 0;
}

uint64_t parseRDNContent(unint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v7;
  int v8;
  __int128 v9;
  uint64_t result;
  __int128 v12;
  __int128 v13;
  unint64_t v14[3];
  unint64_t v15[2];

  v15[0] = 0xAAAAAAAAAAAAAAAALL;
  v15[1] = 0xAAAAAAAAAAAAAAAALL;
  if (DERDecodeSeqContentInit(a1, v15))
    return 4294941021;
  v7 = 0;
  memset(v14, 170, sizeof(v14));
  while (1)
  {
    v8 = DERDecodeSeqNext(v15, v14);
    if (v8)
      break;
    if (v14[0] != 0x2000000000000010)
      return 4294941021;
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v12 = v9;
    v13 = v9;
    if (DERParseSequenceContent(&v14[1], (unsigned __int16)DERNumAttributeTypeAndValueItemSpecs, (uint64_t)&DERAttributeTypeAndValueItemSpecs, (unint64_t)&v12, 0x20uLL)|| *((_QWORD *)&v12 + 1) == 0)
    {
      return 4294941021;
    }
    result = a3(a2, &v12, &v13, v7++, a4);
    if ((_DWORD)result)
      return result;
  }
  if (v8 == 1)
    return 0;
  else
    return 4294941021;
}

uint64_t obtainSummaryFromX501Name(unsigned int *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  __CFString *v9;
  unsigned int v10;
  const __CFAllocator *v11;
  __CFString *v12;
  uint64_t v13;
  const __CFString *v14;
  CFStringRef v15;
  CFStringRef v16;
  unsigned int v17;
  __CFString *v18;
  const __CFString *v19;
  CFStringRef v20;
  CFStringRef v21;
  const void *v22;

  if (DEROidCompare(a2, (uint64_t)&oidCommonName))
  {
    v9 = 0;
    v10 = 4;
    goto LABEL_18;
  }
  if (DEROidCompare(a2, (uint64_t)&oidOrganizationalUnitName))
  {
    v9 = 0;
    v10 = 3;
    goto LABEL_18;
  }
  if (DEROidCompare(a2, (uint64_t)&oidOrganizationName))
  {
    v9 = 0;
    v10 = 2;
    goto LABEL_18;
  }
  if (DEROidCompare(a2, (uint64_t)&oidDescription))
  {
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v12 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, 1, a5);
    v9 = v12;
    if (!v12)
    {
      v10 = 0;
      goto LABEL_18;
    }
    v13 = *((_QWORD *)a1 + 2);
    if (v13)
    {
      if (a5)
      {
        v14 = SecFrameworkCopyLocalizedString(CFSTR("%@, %@"), CFSTR("Certificate"));
        v15 = CFStringCreateWithFormat(v11, 0, v14, v9, *((_QWORD *)a1 + 2));
      }
      else
      {
        v14 = CFSTR("%@, %@");
        v15 = CFStringCreateWithFormat(v11, 0, CFSTR("%@, %@"), v12, v13);
      }
      v16 = v15;
      CFRelease(v14);
      CFRelease(*((CFTypeRef *)a1 + 2));
      *((_QWORD *)a1 + 2) = v16;
    }
    else
    {
      *((_QWORD *)a1 + 2) = v12;
      CFRetain(v12);
    }
  }
  else
  {
    v9 = 0;
  }
  v10 = 1;
LABEL_18:
  v17 = *a1;
  if (*a1 <= v10)
  {
    if (!v9)
    {
      v18 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, 1, a5);
      if (!v18)
        return 0;
      v9 = v18;
      v17 = *a1;
    }
    if (v17 == v10)
    {
      if (a5)
      {
        v19 = SecFrameworkCopyLocalizedString(CFSTR("%@, %@"), CFSTR("Certificate"));
        v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v19, v9, *((_QWORD *)a1 + 1));
      }
      else
      {
        v19 = CFSTR("%@, %@");
        v20 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@, %@"), v9, *((_QWORD *)a1 + 1));
      }
      v21 = v20;
      CFRelease(v19);
      CFRelease(v9);
      v9 = (__CFString *)v21;
    }
    else
    {
      *a1 = v10;
    }
    v22 = (const void *)*((_QWORD *)a1 + 1);
    if (v22)
      CFRelease(v22);
    *((_QWORD *)a1 + 1) = v9;
  }
  else if (v9)
  {
    CFRelease(v9);
  }
  return 0;
}

__CFString *copyDERThingDescription(const __CFAllocator *a1, unsigned __int8 **a2, char a3, int a4)
{
  int v9[6];

  memset(v9, 170, sizeof(v9));
  if (!DERDecodeItem((uint64_t)a2, (unint64_t *)v9))
    return (__CFString *)copyDERThingContentDescription(a1, *(uint64_t *)v9, (uint64_t)&v9[2], a4);
  if ((a3 & 1) != 0)
    return 0;
  return copyHexDescription(a1, a2);
}

CFStringRef copyDERThingContentDescription(const __CFAllocator *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7;
  CFStringEncoding v8;
  const __CFString *v9;
  CFStringRef result;
  const __CFString *v11;
  const __CFString *v12;
  CFStringRef v13;

  if (!a3)
    return 0;
  switch(a2)
  {
    case 1:
    case 2:
      return copyIntegerContentDescription(a1, a3);
    case 3:
      v9 = CFSTR("Bit string");
      v12 = CFSTR("bits");
      return copyBlobString(a1, v9, v12, a3, a4);
    case 4:
      v9 = CFSTR("Byte string");
      goto LABEL_19;
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 23:
    case 24:
    case 25:
    case 29:
      goto LABEL_10;
    case 6:
      return copyOidDescription(a1, a3, a4);
    case 12:
    case 27:
    case 28:
      v7 = a3;
      v8 = 134217984;
      return copyContentString(a1, v7, v8);
    case 19:
    case 22:
      v7 = a3;
      v8 = 1536;
      return copyContentString(a1, v7, v8);
    case 20:
    case 21:
    case 26:
      v7 = a3;
      v8 = 513;
      return copyContentString(a1, v7, v8);
    case 30:
      v7 = a3;
      v8 = 256;
      return copyContentString(a1, v7, v8);
    default:
      if (a2 == 0x2000000000000010)
      {
        v9 = CFSTR("Sequence");
LABEL_19:
        v12 = CFSTR("bytes");
        return copyBlobString(a1, v9, v12, a3, a4);
      }
      if (a2 == 0x2000000000000011)
      {
        v9 = CFSTR("Set");
        goto LABEL_19;
      }
LABEL_10:
      if (a4)
      {
        v11 = SecFrameworkCopyLocalizedString(CFSTR("not displayed (tag = %ld; length %ld)"), CFSTR("Certificate"));
        if (!v11)
          return 0;
      }
      else
      {
        v11 = CFSTR("not displayed (tag = %ld; length %ld)");
      }
      v13 = CFStringCreateWithFormat(a1, 0, v11, a2, *(_QWORD *)(a3 + 8));
      CFRelease(v11);
      result = v13;
      break;
  }
  return result;
}

__CFString *copyContentString(CFAllocatorRef alloc, uint64_t a2, CFStringEncoding encoding)
{
  const UInt8 *v6;
  CFIndex v7;
  BOOL v9;
  CFIndex v10;
  __CFString *result;

  v6 = *(const UInt8 **)a2;
  v7 = *(_QWORD *)(a2 + 8);
  if (v7)
  {
    if (v6[v7 - 1])
      v9 = 1;
    else
      v9 = encoding == 256;
    if (v9)
      v10 = v7;
    else
      v10 = v7 - 1;
    if (v10 < 0)
      return 0;
  }
  else
  {
    v10 = 0;
  }
  result = (__CFString *)CFStringCreateWithBytes(alloc, v6, v10, encoding, encoding == 256);
  if (!result)
    return copyHexDescription(alloc, (unsigned __int8 **)a2);
  return result;
}

uint64_t appendCommonNamesFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result;
  __CFString *v9;
  __CFString *v10;

  result = DEROidCompare(a2, (uint64_t)&oidCommonName);
  if ((_DWORD)result)
  {
    v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, 1, a5);
    if (v9)
    {
      v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0;
    }
    else
    {
      return 4294941021;
    }
  }
  return result;
}

uint64_t appendToCompanyNameString(__CFString *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  __CFString *v9;
  __CFString *v10;

  if (!CFStringGetLength(a1) && DEROidCompare(a2, (uint64_t)&oidOrganizationName))
  {
    v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, 1, a5);
    if (v9)
    {
      v10 = v9;
      CFStringAppend(a1, v9);
      CFRelease(v10);
    }
  }
  return 0;
}

uint64_t appendOrganizationFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result;
  __CFString *v9;
  __CFString *v10;

  result = DEROidCompare(a2, (uint64_t)&oidOrganizationName);
  if ((_DWORD)result)
  {
    v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, 1, a5);
    if (v9)
    {
      v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0;
    }
    else
    {
      return 4294941021;
    }
  }
  return result;
}

CFTypeRef SecCertificateCopyIssuerSummary(uint64_t a1)
{
  int v1;
  CFTypeRef result;
  CFTypeRef v3;
  const __CFString *v4;
  CFStringRef v5;
  uint64_t v6;
  CFTypeRef cf;
  CFTypeRef v8;

  v6 = 0;
  cf = 0;
  v8 = 0;
  v1 = parseX501NameContent((unint64_t *)(a1 + 152), (uint64_t)&v6, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))obtainSummaryFromX501Name, 1);
  result = 0;
  if (!v1)
  {
    v3 = v8;
    if (v8)
    {
      if ((_DWORD)v6 == 4)
      {
        v4 = SecFrameworkCopyLocalizedString(CFSTR("%@ (%@)"), CFSTR("Certificate"));
        v5 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v4, cf, v8);
        CFRelease(v4);
        CFRelease(cf);
        cf = v5;
        v3 = v8;
      }
      CFRelease(v3);
    }
    return cf;
  }
  return result;
}

uint64_t appendCountryFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result;
  __CFString *v9;
  __CFString *v10;

  result = DEROidCompare(a2, (uint64_t)&oidCountryName);
  if ((_DWORD)result)
  {
    v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, 1, a5);
    if (v9)
    {
      v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0;
    }
    else
    {
      return 4294941021;
    }
  }
  return result;
}

const void *SecAccessControlGetConstraints(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("acl"));
}

_QWORD *SEC_ASN1EncodeItem(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  _QWORD *item;
  unint64_t v11;

  v11 = 0;
  v8 = 0;
  if (!SEC_ASN1Encode(a3, a4, (uint64_t)sec_asn1e_encode_item_count, (uint64_t)&v11))
  {
    item = (_QWORD *)sec_asn1e_allocate_item(a1, a2, v11);
    v8 = item;
    if (item)
    {
      if (item[1])
      {
        *item = 0;
        SEC_ASN1Encode(a3, a4, (uint64_t)sec_asn1e_encode_item_store, (uint64_t)item);
      }
      else
      {
        return 0;
      }
    }
  }
  return v8;
}

uint64_t sec_asn1e_allocate_item(uint64_t a1, _QWORD *a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;

  v4 = (uint64_t)a2;
  if (a1)
  {
    if (a2 || (result = PORT_ArenaAlloc(a1, 0x10uLL), (v4 = result) != 0))
    {
      v7 = PORT_ArenaAlloc(a1, a3);
      *(_QWORD *)(v4 + 8) = v7;
      if (v7)
        return v4;
      else
        return 0;
    }
  }
  else
  {
    v8 = a2;
    if (a2 || (result = (uint64_t)PORT_Alloc(0x10uLL), (v8 = (_QWORD *)result) != 0))
    {
      v9 = (unint64_t)PORT_Alloc(a3);
      v8[1] = v9;
      result = v9 ? (uint64_t)v8 : 0;
      if (!(v4 | v9))
      {
        free(v8);
        return 0;
      }
    }
  }
  return result;
}

uint64_t SecCmsDecoderUpdate(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t result;
  int Error;
  int v6;
  _QWORD *ThreadErrInfo;
  int v8;

  result = 4294967246;
  if (a1 && (a3 & 0x8000000000000000) == 0)
  {
    if (*(_QWORD *)a1 && !*(_DWORD *)(a1 + 44) && SEC_ASN1DecoderUpdate(*(_QWORD *)a1, a2, a3))
    {
      Error = PORT_GetError();
      if (Error)
        v6 = Error;
      else
        v6 = -1;
      *(_DWORD *)(a1 + 44) = v6;
    }
    if (*(_DWORD *)(a1 + 44))
    {
      if (*(_QWORD *)a1)
      {
        SEC_ASN1DecoderFinish(*(_QWORD *)a1);
        *(_QWORD *)a1 = 0;
      }
      ThreadErrInfo = PR_getThreadErrInfo(1, &v8);
      if (ThreadErrInfo)
        *ThreadErrInfo = 0;
      return *(unsigned int *)(a1 + 44);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SecCmsDigestContextFinishMultiple(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  int v4;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t *v17;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t OID;
  int v23;
  unint64_t v24;
  CC_SHA256_CTX *v25;
  unsigned __int8 *v26;
  uint64_t v27;

  v4 = *(_DWORD *)(a1 + 12);
  if (v4 <= 134217725)
  {
    v7 = *(_QWORD *)a1;
    v8 = 8 * (v4 + 1);
    if (v8 <= 1)
      v9 = 1;
    else
      v9 = v8;
    v10 = (_QWORD *)PORT_ArenaAlloc(v7, v9);
    v11 = v10;
    if (v10)
      bzero(v10, v9);
    if ((unint64_t)(8 * *(int *)(a1 + 12) + 8) <= 1)
      v12 = 1;
    else
      v12 = 8 * *(int *)(a1 + 12) + 8;
    v13 = (_QWORD *)PORT_ArenaAlloc(*(_QWORD *)a1, v12);
    v14 = v13;
    if (v13)
      bzero(v13, v12);
    v15 = (unint64_t)(16 * *(int *)(a1 + 12)) <= 1 ? 1 : 16 * *(int *)(a1 + 12);
    v16 = (unint64_t *)PORT_ArenaAlloc(*(_QWORD *)a1, v15);
    if (v16)
    {
      v17 = v16;
      bzero(v16, v15);
      if (v11 && v14 != 0)
      {
        if (*(int *)(a1 + 12) < 1)
        {
          v27 = 0;
LABEL_53:
          result = 0;
          v11[v27] = 0;
          v14[v27] = 0;
          *a2 = v11;
          *a3 = v14;
          goto LABEL_22;
        }
        v20 = 0;
        while (2)
        {
          v21 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v20);
          if (v21)
          {
            if (*(_QWORD *)(v21 + 8))
            {
              OID = SECOID_FindOID(v21);
              if (OID)
              {
                v23 = *(_DWORD *)(OID + 16);
                switch(v23)
                {
                  case 191:
                    v24 = 28;
                    goto LABEL_37;
                  case 192:
                    v24 = 32;
                    goto LABEL_37;
                  case 193:
                    v24 = 48;
                    goto LABEL_37;
                  case 194:
                    v24 = 64;
                    goto LABEL_37;
                  default:
                    if (v23 == 4)
                    {
                      v24 = 20;
                    }
                    else
                    {
                      if (v23 != 3)
                        goto LABEL_21;
                      v24 = 16;
                    }
LABEL_37:
                    v25 = *(CC_SHA256_CTX **)(*(_QWORD *)(a1 + 16) + 8 * v20);
                    if (v25)
                    {
                      v26 = (unsigned __int8 *)PORT_ArenaAlloc(*(_QWORD *)a1, v24);
                      v17[1] = (unint64_t)v26;
                      if (!v26)
                        goto LABEL_21;
                      *v17 = v24;
                      switch(v23)
                      {
                        case 191:
                          CC_SHA224_Final(v26, v25);
                          goto LABEL_49;
                        case 192:
                          CC_SHA256_Final(v26, v25);
                          goto LABEL_49;
                        case 193:
                          CC_SHA384_Final(v26, (CC_SHA512_CTX *)v25);
                          goto LABEL_49;
                        case 194:
                          CC_SHA512_Final(v26, (CC_SHA512_CTX *)v25);
                          goto LABEL_49;
                        default:
                          if (v23 == 3)
                          {
                            CC_MD5_Final(v26, (CC_MD5_CTX *)v25);
                          }
                          else
                          {
                            if (v23 != 4)
                              goto LABEL_21;
                            CC_SHA1_Final(v26, (CC_SHA1_CTX *)v25);
                          }
LABEL_49:
                          free(v25);
                          v11[v20] = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * v20);
                          v14[v20] = v17;
                          break;
                      }
                    }
                    else
                    {
                      *v17 = 0;
                      v17[1] = 0;
                    }
                    ++v20;
                    v17 += 2;
                    if (v20 < *(int *)(a1 + 12))
                      continue;
                    v27 = v20;
                    break;
                }
                goto LABEL_53;
              }
            }
          }
          break;
        }
      }
    }
  }
LABEL_21:
  result = 0xFFFFFFFFLL;
LABEL_22:
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

uint64_t SecCmsDigestContextStartMultiple(uint64_t *a1)
{
  _DWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  void *v11;
  uint64_t OID;
  int v13;
  CC_SHA256_CTX *v14;
  uint64_t v15;
  uint64_t v16;

  v2 = PORT_NewArena(1024);
  if (!v2)
    return 0;
  v3 = v2;
  if (a1 && *a1)
  {
    v4 = 0;
    while (a1[++v4])
      ;
  }
  else
  {
    LODWORD(v4) = 0;
  }
  v6 = PORT_ArenaAlloc((uint64_t)v2, 0x20uLL);
  if (!v6)
  {
LABEL_35:
    PORT_FreeArena(v3, 0);
    return 0;
  }
  v7 = v6;
  *(_QWORD *)v6 = v3;
  if ((int)v4 >= 1)
  {
    if (v4 <= 0xFFFFFFD)
    {
      v8 = PORT_ArenaAlloc((uint64_t)v3, 8 * v4);
      *(_QWORD *)(v7 + 16) = v8;
      if (v8)
      {
        if (8 * (unint64_t)(v4 + 1) <= 1)
          v9 = 1;
        else
          v9 = 8 * (v4 + 1);
        v10 = (void *)PORT_ArenaAlloc((uint64_t)v3, v9);
        if (v10)
        {
          v11 = v10;
          v4 = v4;
          bzero(v10, v9);
          *(_QWORD *)(v7 + 24) = v11;
          *(_DWORD *)(v7 + 12) = 0;
          while (1)
          {
            OID = SECOID_FindOID(*a1);
            if (OID)
            {
              v13 = *(_DWORD *)(OID + 16);
              switch(v13)
              {
                case 191:
                  v14 = (CC_SHA256_CTX *)malloc_type_calloc(1uLL, 0x68uLL, 0x1000040ED882C02uLL);
                  CC_SHA224_Init(v14);
                  break;
                case 192:
                  v14 = (CC_SHA256_CTX *)malloc_type_calloc(1uLL, 0x68uLL, 0x1000040ED882C02uLL);
                  CC_SHA256_Init(v14);
                  break;
                case 193:
                  v14 = (CC_SHA256_CTX *)malloc_type_calloc(1uLL, 0xD0uLL, 0x10000400F93440CuLL);
                  CC_SHA384_Init((CC_SHA512_CTX *)v14);
                  break;
                case 194:
                  v14 = (CC_SHA256_CTX *)malloc_type_calloc(1uLL, 0xD0uLL, 0x10000400F93440CuLL);
                  CC_SHA512_Init((CC_SHA512_CTX *)v14);
                  break;
                default:
                  if (v13 == 3)
                  {
                    v14 = (CC_SHA256_CTX *)malloc_type_calloc(1uLL, 0x5CuLL, 0x100004034A301B9uLL);
                    CC_MD5_Init((CC_MD5_CTX *)v14);
                  }
                  else
                  {
                    if (v13 != 4)
                      goto LABEL_23;
                    v14 = (CC_SHA256_CTX *)malloc_type_calloc(1uLL, 0x60uLL, 0x1000040565EDBD2uLL);
                    CC_SHA1_Init((CC_SHA1_CTX *)v14);
                  }
                  break;
              }
            }
            else
            {
LABEL_23:
              v14 = 0;
            }
            *(_QWORD *)(*(_QWORD *)(v7 + 16) + 8 * *(int *)(v7 + 12)) = v14;
            v15 = PORT_ArenaAlloc((uint64_t)v3, 0x20uLL);
            v16 = *(int *)(v7 + 12);
            *(_QWORD *)(*(_QWORD *)(v7 + 24) + 8 * v16) = v15;
            if (SECITEM_CopyItem((uint64_t)v3, *(unint64_t **)(*(_QWORD *)(v7 + 24) + 8 * v16), *a1)|| SECITEM_CopyItem((uint64_t)v3, (unint64_t *)(*(_QWORD *)(*(_QWORD *)(v7 + 24) + 8 * *(int *)(v7 + 12)) + 16), *a1 + 16))
            {
              break;
            }
            ++*(_DWORD *)(v7 + 12);
            ++a1;
            if (!--v4)
              goto LABEL_33;
          }
        }
        else
        {
          *(_QWORD *)(v7 + 24) = 0;
        }
      }
    }
    goto LABEL_35;
  }
  *(_DWORD *)(v6 + 12) = 0;
LABEL_33:
  *(_BYTE *)(v7 + 8) = 0;
  return v7;
}

uint64_t SECITEM_CopyItem(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  void *v5;
  unint64_t v6;
  uint64_t result;

  if (!*(_QWORD *)(a3 + 8) || !*(_QWORD *)a3)
  {
    v6 = 0;
    a2[1] = 0;
LABEL_9:
    result = 0;
    *a2 = v6;
    return result;
  }
  if (a1)
    v5 = (void *)PORT_ArenaAlloc(a1, *(_QWORD *)a3);
  else
    v5 = PORT_Alloc(*(_QWORD *)a3);
  a2[1] = (unint64_t)v5;
  if (v5)
  {
    memcpy(v5, *(const void **)(a3 + 8), *(_QWORD *)a3);
    v6 = *(_QWORD *)a3;
    goto LABEL_9;
  }
  return 0xFFFFFFFFLL;
}

uint64_t SEC_ASN1DecoderUpdate(uint64_t a1, char *a2, unint64_t a3)
{
  __int16 *v3;
  uint64_t v7;
  int v8;
  _QWORD *v9;
  uint64_t result;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  __int16 *v19;
  char v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unsigned __int8 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  unint64_t v31;
  unsigned __int8 v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  BOOL v36;
  char *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t (**v44)(uint64_t, _QWORD, unsigned __int8 *, unint64_t);
  uint64_t v45;
  int v46;
  _QWORD *v49;
  int v50;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  BOOL v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  void (*v63)(_QWORD, _QWORD, uint64_t, uint64_t);
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  void (*v70)(_QWORD, uint64_t, _QWORD, uint64_t);
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t v75;
  void (*v76)(_QWORD, _QWORD);
  uint64_t v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  void (*v81)(_QWORD, _QWORD, uint64_t, uint64_t);
  uint64_t v82;
  uint64_t v83;
  int v84;
  unint64_t v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  void (*v90)(_QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t v91;
  uint64_t v92;
  char v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t *v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  __int16 *v101;
  unint64_t v102;
  _QWORD *v103;
  uint64_t v104;
  _QWORD **v105;
  uint64_t v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v109;
  unsigned int v110;
  char *v112;
  uint64_t v113;
  uint64_t v114;
  char *v115;
  uint64_t v116;
  uint64_t v117;
  _QWORD *v118;
  int v119;
  _QWORD *v120;
  unint64_t *v121;
  _QWORD *v122;
  uint64_t v123;
  int v124;
  BOOL v125;
  char v127;
  uint64_t v128;
  char *v129;
  char *v130;
  int v131;
  unint64_t v132;
  unint64_t v133;
  _QWORD *v134;
  _QWORD *v135;
  _QWORD *v136;
  _DWORD *v137;
  void *v138;
  uint64_t v139;
  _QWORD *v140;
  uint64_t *v141;
  uint64_t v142;
  uint64_t v143;
  void *v144;
  _QWORD *v145;
  _QWORD *j;
  uint64_t v147;
  unsigned int *v148;
  uint64_t v149;
  unsigned int v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  _QWORD *v154;
  unint64_t *v155;
  uint64_t i;
  size_t v157;
  _QWORD *ThreadErrInfo;
  _QWORD *v159;
  _QWORD *v160;
  uint64_t v161;
  _QWORD *inited;
  uint64_t v163;
  uint64_t (**v164)(uint64_t, _QWORD, unsigned __int8 *, unint64_t);
  int *v165;
  int *v166;
  int v167;
  char v168;
  uint64_t v169;
  _QWORD *v170;
  uint64_t v171;
  uint64_t v172;
  _QWORD *v173;
  _QWORD *v174;
  uint64_t v175;
  const SecAsn1Template *v176;
  uint64_t v177;
  uint64_t *v178;
  _BYTE *v179;
  uint64_t v180;
  void (*v181)(_QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  void *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  _QWORD *v189;
  uint64_t *v190;
  void *v191;
  void (*v192)(_QWORD, char *, unint64_t, uint64_t, uint64_t);
  uint64_t v193;
  _QWORD *v194;
  _QWORD *v195;
  _QWORD *v196;
  uint64_t v197;
  uint64_t v198;
  unint64_t v199;

  v7 = *(_QWORD *)(a1 + 16);
  v8 = *(_DWORD *)(a1 + 24);
  if (v8 == 2)
    goto LABEL_4;
  if (v8 == 3)
  {
    *(_DWORD *)(a1 + 24) = 2;
LABEL_4:
    v198 = v7;
    while (1)
    {
      v9 = *(_QWORD **)(a1 + 16);
      while (2)
      {
        result = 0;
        switch(*((_DWORD *)v9 + 12))
        {
          case 0:
            if (!a3)
              goto LABEL_163;
            v19 = v3;
            v20 = *a2;
            if ((*a2 & 0x1F) == 0x1F)
            {
              *((_DWORD *)v9 + 12) = 1;
              v9[8] = 0;
              v9[12] = 1;
LABEL_229:
              v15 = 0;
              v17 = 0;
              v161 = 0;
              *((_BYTE *)v9 + 52) = v20 & 0xE0;
              v14 = 1;
              v16 = 1;
              goto LABEL_386;
            }
            if (*a2 || !sec_asn1d_parent_allows_EOC(v9[4]))
            {
              *((_DWORD *)v9 + 12) = 2;
              v9[8] = v20 & 0x1F;
              goto LABEL_229;
            }
            *((_DWORD *)v9 + 12) = 21;
            v9[12] = 2;
            v9[8] = 0;
            *((_BYTE *)v9 + 52) = 0;
            v16 = 1;
            v17 = *((unsigned __int8 *)v9 + 141);
            v14 = 0;
            v15 = 0;
            if (*((_BYTE *)v9 + 141))
            {
              v17 = 0;
              v161 = 0;
              *((_BYTE *)v9 + 140) = 1;
            }
            else
            {
              v161 = 0;
            }
            goto LABEL_386;
          case 1:
            if (!a3)
            {
LABEL_163:
              v14 = 0;
              v15 = 0;
              v17 = 0;
              v161 = 0;
              *(_DWORD *)(*v9 + 24) = 3;
              goto LABEL_164;
            }
            v14 = 0;
            v21 = v9[12];
            v22 = a3;
LABEL_19:
            --v22;
            v23 = v14;
            while (1)
            {
              if (!v21)
                goto LABEL_27;
              v24 = v9[8];
              if (v24 >> 57)
                break;
              v9[8] = v24 << 7;
              v25 = v23 + 1;
              v26 = a2[v23];
              v9[8] = v26 & 0x7F | (v24 << 7);
              if ((v26 & 0x80) == 0)
              {
                v21 = 0;
                v9[12] = 0;
                v14 = v25;
                if (!v22)
                {
                  v14 = a3;
LABEL_27:
                  v15 = 0;
                  v17 = 0;
                  v161 = 0;
                  *((_DWORD *)v9 + 12) = 2;
LABEL_164:
                  v16 = 1;
                  goto LABEL_340;
                }
                goto LABEL_19;
              }
              --v22;
              v16 = 1;
              v23 = v25;
              if (v22 == -1)
              {
                v15 = 0;
                v17 = 0;
                v161 = 0;
                v14 = a3;
                goto LABEL_340;
              }
            }
            ThreadErrInfo = PR_getThreadErrInfo(1, (int *)&v199);
            if (ThreadErrInfo)
              *ThreadErrInfo = 0xFFFFE00900000000;
            v14 = 0;
            v15 = 0;
            v17 = 0;
            v161 = 0;
            v16 = 1;
            *(_DWORD *)(*v9 + 24) = 1;
            goto LABEL_340;
          case 2:
            v27 = v9[7];
            if ((v27 & *((_BYTE *)v9 + 52)) == (unint64_t)*((unsigned __int8 *)v9 + 53)
              && (v9[8] & v27) == v9[9])
            {
              v14 = 0;
              v15 = 0;
              v16 = 0;
              v17 = 0;
              *((_DWORD *)v9 + 12) = 3;
              goto LABEL_339;
            }
            if (!*((_BYTE *)v9 + 141))
              goto LABEL_172;
            v14 = 0;
            v15 = 0;
            v16 = 0;
            v17 = 0;
            *((_BYTE *)v9 + 140) = 1;
            goto LABEL_272;
          case 3:
            if (!a3)
              goto LABEL_167;
            *((_DWORD *)v9 + 12) = 5;
            v28 = *a2;
            if (*a2 < 0)
            {
              v143 = v28 & 0x7F;
              v9[11] = 0;
              v9[12] = v143;
              if ((_DWORD)v143)
                *((_DWORD *)v9 + 12) = 4;
              else
                *((_BYTE *)v9 + 139) = 1;
            }
            else
            {
              v9[11] = v28;
            }
            if (*((_BYTE *)v9 + 139) || (*((_BYTE *)v9 + 81) & 0x84) == 0)
            {
              v15 = 0;
              v16 = 0;
            }
            else
            {
              v15 = 0;
              v16 = 0;
              *((_BYTE *)v9 + 52) &= ~0x20u;
            }
            v14 = 1;
            goto LABEL_321;
          case 4:
            if (!a3)
            {
LABEL_167:
              v14 = 0;
              v15 = 0;
              v16 = 0;
              *(_DWORD *)(*v9 + 24) = 3;
              goto LABEL_321;
            }
            v29 = 0;
            v14 = v9[12];
            v30 = a2;
            while (1)
            {
              if (!(v14 + v29))
                goto LABEL_233;
              v31 = v9[11];
              if (v31 >> 55)
                break;
              v9[11] = v31 << 8;
              v32 = *v30++;
              v9[11] = v32 | (v31 << 8);
              v9[12] = v14 + v29-- - 1;
              if (!(a3 + v29))
              {
                v33 = v14 + v29;
                v14 = a3;
                if (v33)
                {
                  v15 = 0;
                  v16 = 0;
                  v17 = 1;
                  v14 = a3;
                  goto LABEL_322;
                }
LABEL_233:
                v15 = 0;
                v16 = 0;
                *((_DWORD *)v9 + 12) = 5;
LABEL_321:
                v17 = 1;
                goto LABEL_322;
              }
            }
            v159 = PR_getThreadErrInfo(1, (int *)&v199);
            if (v159)
              *v159 = 0xFFFFE00900000000;
            v14 = 0;
            v15 = 0;
            v16 = 0;
            v17 = 1;
            *(_DWORD *)(*v9 + 24) = 1;
LABEL_322:
            v161 = 1;
            goto LABEL_340;
          case 5:
            v34 = v9[4];
            if (!v34)
              goto LABEL_51;
            while (1)
            {
              v35 = *(_DWORD *)(v34 + 48);
              v36 = (v35 - 16) < 4 || v35 == 11;
              if (!v36 && v35 != 24)
                break;
              v34 = *(_QWORD *)(v34 + 32);
              if (!v34)
                goto LABEL_51;
            }
LABEL_69:
            if (*(_BYTE *)(v34 + 139))
            {
              while (1)
              {
                v34 = *(_QWORD *)(v34 + 32);
                if (!v34)
                  break;
                v46 = *(_DWORD *)(v34 + 48);
                if ((v46 - 16) >= 4 && v46 != 24 && v46 != 11)
                  goto LABEL_69;
              }
            }
            else
            {
              v199 = *(_QWORD *)(v34 + 96);
              v49 = v9;
LABEL_71:
              if (!sec_asn1d_check_and_subtract_length(&v199, v49[13], *v9)
                || !sec_asn1d_check_and_subtract_length(&v199, v49[11], *v9)
                || *((_BYTE *)v49 + 139) && !sec_asn1d_check_and_subtract_length(&v199, 2uLL, *v9))
              {
                goto LABEL_337;
              }
              while (1)
              {
                v49 = (_QWORD *)v49[4];
                if (!v49)
                  break;
                v50 = *((_DWORD *)v49 + 12);
                if ((v50 - 16) >= 4 && v50 != 24 && v50 != 11)
                {
                  if (*((_BYTE *)v49 + 139))
                    goto LABEL_71;
                  break;
                }
              }
            }
LABEL_51:
            if (*((_BYTE *)v9 + 136))
            {
              v38 = (char *)sec_asn1d_zalloc(*(_QWORD *)(*v9 + 8), *(unsigned int *)(v9[1] + 16));
              if (!v38)
                goto LABEL_174;
              v9[2] = &v38[*(unsigned int *)(v9[1] + 4)];
              v39 = v9[4];
              if (*(_DWORD *)(v39 + 48) == 18)
                **(_QWORD **)(v39 + 16) = v38;
            }
            v40 = v9[11];
            v9[12] = v40;
            if (*((_BYTE *)v9 + 138))
            {
              *((_DWORD *)v9 + 12) = 15;
              v42 = *v9;
              v41 = v9[1];
              v43 = v9[2];
              v44 = *(uint64_t (***)(uint64_t, _QWORD, unsigned __int8 *, unint64_t))(v41 + 8);
              if (v44 && (*(_BYTE *)(v41 + 1) & 0x40) != 0)
              {
                if (*v44)
                {
                  if (v43)
                    v45 = v43 - *(unsigned int *)(v41 + 4);
                  else
                    v45 = 0;
                  v44 = (uint64_t (**)(uint64_t, _QWORD, unsigned __int8 *, unint64_t))(*v44)(v45, 0, (unsigned __int8 *)a2, a3);
                  v43 = v9[2];
                }
                else
                {
                  v44 = 0;
                }
              }
              v173 = sec_asn1d_push_state(v42, (uint64_t)v44, v43, 1);
              if (v173)
LABEL_336:
                sec_asn1d_init_state_based_on_template(v173, (uint64_t)a2, a3);
              goto LABEL_337;
            }
            v139 = v9[10];
            if ((v139 & 0x2000) == 0)
            {
              if (v139 <= 1023)
              {
                switch(v139)
                {
                  case 3:
                  case 4:
                  case 12:
                  case 19:
                  case 20:
                  case 22:
                  case 23:
                  case 26:
                    goto LABEL_238;
                  case 5:
                    if (v40 || *((_BYTE *)v9 + 139))
                      goto LABEL_172;
                    v189 = (_QWORD *)v9[2];
                    if (v189)
                    {
                      *v189 = 0;
                      v189[1] = 0;
                    }
                    goto LABEL_270;
                  case 16:
                    *((_DWORD *)v9 + 12) = 12;
                    v190 = sec_asn1d_push_state(*v9, v9[1] + 24, v9[2], 1);
                    v14 = (unint64_t)v190;
                    if (!v190)
                      goto LABEL_338;
                    v19 = v3;
                    v180 = *v190;
                    goto LABEL_381;
                  case 17:
                    goto LABEL_172;
                  case 28:
                    if ((v40 & 3) == 0)
                      goto LABEL_238;
                    goto LABEL_172;
                  case 30:
                    if ((v40 & 1) == 0)
                      goto LABEL_238;
                    goto LABEL_172;
                  default:
                    goto LABEL_352;
                }
              }
              if (v139 != 1024 && v139 != 0x8000 && v139 != 66560)
              {
LABEL_352:
                if (!v40)
                  goto LABEL_172;
                v19 = v3;
                v174 = (_QWORD *)v9[2];
                if (!v174)
                  goto LABEL_431;
                *v174 = 0;
                if (*(_DWORD *)(*v9 + 72))
                {
                  v174[1] = 0;
LABEL_431:
                  v14 = 0;
                  v15 = 0;
                  v16 = 0;
                  v17 = 0;
                  *((_DWORD *)v9 + 12) = 10;
                  goto LABEL_385;
                }
                v191 = sec_asn1d_zalloc(*(_QWORD *)(*v9 + 8), v40);
                v174[1] = v191;
                if (v191)
                  goto LABEL_431;
LABEL_432:
                v14 = 0;
                v15 = 0;
                v16 = 0;
                v17 = 0;
                *(_DWORD *)(*v9 + 24) = 1;
                goto LABEL_385;
              }
LABEL_238:
              v140 = (_QWORD *)v9[2];
              if (!v140)
                goto LABEL_359;
              v141 = (uint64_t *)*v9;
              if (*(_DWORD *)(*v9 + 72))
              {
                v142 = 0;
                *v140 = 0;
                v140[1] = 0;
LABEL_360:
                if (*((_BYTE *)v9 + 139))
                  goto LABEL_361;
                v178 = v9 + 15;
                v177 = v9[15];
                if (!v177)
                  goto LABEL_361;
                if (!v140)
                  goto LABEL_172;
                v19 = v3;
                v40 = 0;
                do
                {
LABEL_390:
                  v184 = *(_QWORD *)(v177 + 8);
                  v177 = *(_QWORD *)(v177 + 16);
                  v40 += v184;
                }
                while (v177);
LABEL_391:
                v185 = sec_asn1d_zalloc(v142, v40);
                v140[1] = v185;
                if (v185)
                {
                  v186 = *v178;
                  if (*v178)
                  {
                    v187 = 0;
                    do
                    {
                      memcpy((void *)(v140[1] + v187), *(const void **)v186, *(_QWORD *)(v186 + 8));
                      v188 = *(_QWORD *)(v186 + 8);
                      v186 = *(_QWORD *)(v186 + 16);
                      v187 += v188;
                    }
                    while (v186);
                  }
                  else
                  {
                    v187 = 0;
                  }
                  *v140 = v187;
                  v9[15] = 0;
                  v9[16] = 0;
                  v40 = v9[11];
                  v3 = v19;
LABEL_361:
                  if (!v40)
                  {
                    v16 = *((unsigned __int8 *)v9 + 139);
                    if (!*((_BYTE *)v9 + 139))
                    {
                      v14 = 0;
                      v15 = 0;
                      goto LABEL_271;
                    }
                  }
                  if ((*((_BYTE *)v9 + 52) & 0x20) == 0)
                  {
                    if (*((_BYTE *)v9 + 139))
                      goto LABEL_172;
                    v14 = 0;
                    v15 = 0;
                    v16 = 0;
                    v17 = 0;
                    if (v9[10] == 3)
                      v18 = 6;
                    else
                      v18 = 10;
                    goto LABEL_273;
                  }
                  v175 = v9[10];
                  if (v175 > 1023)
                  {
                    if (v175 == 1024)
                    {
                      v176 = kSecAsn1AnyTemplate;
                    }
                    else if (v175 == 0x8000)
                    {
                      v176 = kSecAsn1SkipTemplate;
                    }
                    else
                    {
                      v176 = kSecAsn1AnyTemplate;
                      if (v175 != 66560)
LABEL_416:
                        v176 = 0;
                    }
                  }
                  else
                  {
                    switch(v175)
                    {
                      case 12:
                        v176 = kSecAsn1UTF8StringTemplate;
                        break;
                      case 13:
                      case 14:
                      case 15:
                      case 16:
                      case 17:
                      case 18:
                      case 21:
                      case 25:
                      case 27:
                      case 29:
                        goto LABEL_416;
                      case 19:
                        v176 = kSecAsn1PrintableStringTemplate;
                        break;
                      case 20:
                        v176 = kSecAsn1T61StringTemplate;
                        break;
                      case 22:
                        v176 = kSecAsn1IA5StringTemplate;
                        break;
                      case 23:
                        v176 = kSecAsn1UTCTimeTemplate;
                        break;
                      case 24:
                        v176 = kSecAsn1GeneralizedTimeTemplate;
                        break;
                      case 26:
                        v176 = kSecAsn1VisibleStringTemplate;
                        break;
                      case 28:
                        v176 = kSecAsn1UniversalStringTemplate;
                        break;
                      case 30:
                        v176 = kSecAsn1BMPStringTemplate;
                        break;
                      default:
                        if (v175 == 3)
                        {
                          v176 = kSecAsn1BitStringTemplate;
                        }
                        else
                        {
                          if (v175 != 4)
                            goto LABEL_416;
                          v176 = kSecAsn1OctetStringTemplate;
                        }
                        break;
                    }
                  }
                  *((_DWORD *)v9 + 12) = 8;
                  v173 = sec_asn1d_push_state(*v9, (uint64_t)v176, (uint64_t)v140, 1);
                  if (v173)
                  {
                    *((_BYTE *)v173 + 142) = 1;
                    goto LABEL_336;
                  }
LABEL_337:
                  v14 = 0;
LABEL_338:
                  v15 = 0;
                  v16 = 0;
                  v17 = 0;
LABEL_339:
                  v161 = 2;
                  goto LABEL_340;
                }
                goto LABEL_432;
              }
              if (*((_BYTE *)v9 + 142))
              {
                if (v140[1])
                {
LABEL_359:
                  v142 = 0;
                  goto LABEL_360;
                }
              }
              else
              {
                ++v141;
                *v140 = 0;
                v140[1] = 0;
              }
              v142 = *v141;
              if (!v40)
                goto LABEL_360;
              v19 = v3;
              v178 = v9 + 15;
              v177 = v9[15];
              if (v177)
                goto LABEL_390;
              goto LABEL_391;
            }
            if (!v40)
            {
              v16 = *((unsigned __int8 *)v9 + 139);
              if (!*((_BYTE *)v9 + 139))
              {
                v14 = 0;
                v15 = 0;
                v17 = 0;
LABEL_247:
                v18 = 14;
LABEL_273:
                *((_DWORD *)v9 + 12) = v18;
                goto LABEL_339;
              }
            }
            *((_DWORD *)v9 + 12) = 9;
            v163 = v9[1];
            v164 = *(uint64_t (***)(uint64_t, _QWORD, unsigned __int8 *, unint64_t))(v163 + 8);
            if (v164 && (*(_BYTE *)(v163 + 1) & 0x40) != 0)
            {
              if (*v164)
              {
                v171 = v9[2];
                if (v171)
                  v172 = v171 - *(unsigned int *)(v163 + 4);
                else
                  v172 = 0;
                v19 = v3;
                v164 = (uint64_t (**)(uint64_t, _QWORD, unsigned __int8 *, unint64_t))(*v164)(v172, 0, (unsigned __int8 *)a2, a3);
              }
              else
              {
                v19 = v3;
                v164 = 0;
              }
            }
            else
            {
              v19 = v3;
            }
            v179 = sec_asn1d_push_state(*v9, (uint64_t)v164, 0, 1);
            v14 = (unint64_t)v179;
            if (v179)
            {
              v180 = *(_QWORD *)v179;
              if (!*(_DWORD *)(*(_QWORD *)v179 + 72))
                v179[136] = 1;
LABEL_381:
              v181 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v180 + 32);
              if (v181)
              {
                v182 = *(unsigned int *)(v14 + 112);
                v183 = *(_QWORD *)(v14 + 16);
                *(_DWORD *)(v180 + 48) = 1;
                v181(*(_QWORD *)(v180 + 40), 1, v183, v182);
                *(_DWORD *)(v180 + 48) = 0;
              }
              sec_asn1d_init_state_based_on_template((_QWORD *)v14, (uint64_t)a2, a3);
              v14 = 0;
            }
            v15 = 0;
            v16 = 0;
            v17 = 0;
LABEL_385:
            v161 = 2;
LABEL_386:
            v3 = v19;
LABEL_340:
            v131 = *(_DWORD *)(a1 + 24);
LABEL_341:
            if (v131 == 1)
              goto LABEL_450;
            if (a3 < v14)
            {
              v194 = PR_getThreadErrInfo(1, (int *)&v199);
              if (v194)
                *v194 = 0xFFFFE00900000000;
              *(_DWORD *)(a1 + 24) = 1;
LABEL_450:
              v7 = v198;
LABEL_451:
              if (v9)
              {
LABEL_452:
                v195 = *(_QWORD **)(v7 + 32);
                do
                {
                  if (v195 == v9)
                    break;
                  if (v9[5])
                  {
                    v9[5] = 0;
                    v9[3] = 0;
                  }
                  *((_DWORD *)v9 + 12) = 20;
                  v9 = (_QWORD *)v9[4];
                }
                while (v9);
              }
              return 0xFFFFFFFFLL;
            }
            v9 = *(_QWORD **)(a1 + 16);
            if (!v9 || *(_DWORD *)v9[1] == 0x80000)
            {
              result = 0;
              *(_DWORD *)(a1 + 24) = 0;
              return result;
            }
            if (!v14)
            {
              if (v131 != 2)
                return 0;
              continue;
            }
            if (v9[10] == 1024 && (v16 | v17) == 1 && !*(_DWORD *)(a1 + 72))
              sec_asn1d_record_any_header(*(uint64_t ***)(a1 + 16), a2, v14);
            v192 = *(void (**)(_QWORD, char *, unint64_t, uint64_t, uint64_t))(*v9 + 56);
            if (v192)
            {
              v193 = *((unsigned int *)v9 + 28);
              if (v15)
                v193 = v193 - (*((_BYTE *)v9 + 139) == 0);
              v192(*(_QWORD *)(*v9 + 64), a2, v14, v193, v161);
            }
            v9[13] += v14;
            a2 += v14;
            v8 = *(_DWORD *)(a1 + 24);
            a3 -= v14;
            if (v8 != 2)
            {
              v7 = v198;
              goto LABEL_444;
            }
            break;
          case 6:
            v53 = v9[12];
            if (!v53)
            {
              v118 = (_QWORD *)v9[2];
              if (v118)
              {
                v14 = 0;
                v15 = 0;
                v16 = 0;
                v17 = 0;
                *v118 = 0;
                v118[1] = 0;
                v161 = 2;
                v119 = 20;
                goto LABEL_170;
              }
            }
            if (!a3)
            {
              v14 = 0;
              v15 = 0;
              v16 = 0;
              v17 = 0;
              *(_DWORD *)(*v9 + 24) = 3;
              goto LABEL_339;
            }
            v54 = *a2;
            if (v54 >= 8)
              goto LABEL_172;
            v15 = 0;
            v16 = 0;
            v17 = 0;
            *((_DWORD *)v9 + 29) = v54;
            *((_DWORD *)v9 + 12) = 7;
            v9[12] = v53 - 1;
            v161 = 2;
            v14 = 1;
            goto LABEL_340;
          case 7:
            if (v9[12])
              goto LABEL_90;
            v16 = *((_DWORD *)v9 + 29);
            if (v16)
              goto LABEL_172;
            v14 = 0;
            v15 = 0;
            v17 = 0;
            goto LABEL_13;
          case 8:
            v55 = v9[5];
            v56 = *(_QWORD *)(v55 + 104);
            *(_QWORD *)(v55 + 104) = 0;
            v57 = v9[12];
            v9[13] += v56;
            if (v57)
            {
              v58 = v57 >= v56;
              v59 = v57 - v56;
              if (!v58)
                goto LABEL_172;
              v9[12] = v59;
              if (v59)
                goto LABEL_95;
            }
            else
            {
              v121 = *(unint64_t **)(v55 + 16);
              v122 = v9;
              while (v121 == (unint64_t *)v122[2])
              {
                if (!*((_BYTE *)v122 + 139))
                  break;
                v123 = v122[4];
                if (!v123)
                  break;
                while (1)
                {
                  v124 = *(_DWORD *)(v123 + 48);
                  v125 = (v124 - 16) < 4 || v124 == 24;
                  if (!v125 && v124 != 11)
                    break;
                  v123 = *(_QWORD *)(v123 + 32);
                  if (!v123)
                    goto LABEL_219;
                }
                if (*(_QWORD *)(v123 + 80) != v122[10])
                  break;
                v122 = (_QWORD *)v123;
                if (!*(_BYTE *)(v123 + 139))
                {
                  v127 = 1;
                  goto LABEL_220;
                }
              }
LABEL_219:
              v127 = 0;
LABEL_220:
              if (v121)
              {
                v138 = (void *)v121[1];
                if (!v138)
                  v127 = 1;
                if ((v127 & 1) == 0)
                {
                  sec_asn1d_add_to_subitems((uint64_t **)v9, v138, *v121, 0);
                  *v121 = 0;
                  v121[1] = 0;
                }
              }
              if (!*(_BYTE *)(v55 + 137))
              {
LABEL_95:
                v14 = 0;
                v15 = 0;
                v16 = 0;
                v17 = 0;
                *(_DWORD *)(v55 + 48) = 0;
                *(_BYTE *)(v55 + 137) = 0;
                *(_WORD *)(v55 + 139) = 0;
                *(_QWORD *)(*v9 + 16) = v55;
                goto LABEL_339;
              }
            }
            v14 = 0;
            v15 = 0;
            v16 = 0;
            v17 = 0;
            *(_DWORD *)(v55 + 48) = 26;
            v18 = 13;
            goto LABEL_273;
          case 9:
            v60 = v9[5];
            v61 = *(_QWORD *)(v60 + 104);
            *(_QWORD *)(v60 + 104) = 0;
            v9[13] += v61;
            if (*(_BYTE *)(v60 + 137) && !*(_BYTE *)(v60 + 139))
            {
              v144 = *(void **)(v60 + 16);
              if (v144 && !v9[15])
              {
                sec_asn1d_add_to_subitems((uint64_t **)v9, v144, 0, 0);
                *(_QWORD *)(v60 + 16) = 0;
              }
LABEL_246:
              v14 = 0;
              v15 = 0;
              v16 = 0;
              v17 = 0;
              *(_DWORD *)(v60 + 48) = 26;
              goto LABEL_247;
            }
            v19 = v3;
            v62 = *v9;
            v63 = *(void (**)(_QWORD, _QWORD, uint64_t, uint64_t))(*v9 + 32);
            if (v63)
            {
              v64 = *(unsigned int *)(v60 + 112);
              v65 = *(_QWORD *)(v60 + 16);
              *(_DWORD *)(v62 + 48) = 1;
              v63(*(_QWORD *)(v62 + 40), 0, v65, v64);
              *(_DWORD *)(v62 + 48) = 0;
            }
            v66 = *(_QWORD *)(v60 + 16);
            if (v66)
            {
              sec_asn1d_add_to_subitems((uint64_t **)v9, (void *)(v66 - *(unsigned int *)(*(_QWORD *)(v60 + 8) + 4)), 0, 0);
              *(_QWORD *)(v60 + 16) = 0;
            }
            v67 = v9[12];
            if (v67)
            {
              v3 = v19;
              v58 = v67 >= v61;
              v68 = v67 - v61;
              if (!v58)
                goto LABEL_172;
              v9[12] = v68;
              if (!v68)
                goto LABEL_246;
            }
            v69 = *v9;
            v70 = *(void (**)(_QWORD, uint64_t, _QWORD, uint64_t))(*v9 + 32);
            if (v70)
            {
              v71 = *(unsigned int *)(v60 + 112);
              *(_DWORD *)(v69 + 48) = 1;
              v70(*(_QWORD *)(v69 + 40), 1, 0, v71);
              *(_DWORD *)(v69 + 48) = 0;
            }
            *(_DWORD *)(v60 + 48) = 0;
            *(_BYTE *)(v60 + 137) = 0;
            *(_WORD *)(v60 + 139) = 0;
            sec_asn1d_init_state_based_on_template((_QWORD *)v60, (uint64_t)a2, a3);
            v14 = 0;
            v15 = 0;
            v16 = 0;
            v17 = 0;
            *(_QWORD *)(*v9 + 16) = v60;
            goto LABEL_385;
          case 0xA:
LABEL_90:
            v14 = sec_asn1d_parse_leaf((uint64_t)v9, a2, a3);
            goto LABEL_338;
          case 0xB:
            v72 = v9[5];
            v73 = *(_QWORD *)(v72 + 104);
            *(_QWORD *)(v72 + 104) = 0;
            v74 = (uint64_t *)v9[2];
            if (*(_QWORD *)(v72 + 40))
            {
              *(_QWORD *)(v72 + 40) = 0;
              *(_QWORD *)(v72 + 24) = 0;
            }
            *(_DWORD *)(v72 + 48) = 20;
            v75 = *v9;
            v76 = *(void (**)(_QWORD, _QWORD))(*v9 + 32);
            if (v76)
            {
              v77 = *((unsigned int *)v9 + 28);
              *(_DWORD *)(v75 + 48) = 1;
              ((void (*)(_QWORD, _QWORD, uint64_t *, uint64_t))v76)(*(_QWORD *)(v75 + 40), 0, v74, v77);
              *(_DWORD *)(v75 + 48) = 0;
              v78 = (uint64_t *)v9[2];
              v75 = *v9;
              v76 = *(void (**)(_QWORD, _QWORD))(*v9 + 32);
            }
            else
            {
              v78 = v74;
            }
            v128 = v9[1];
            v129 = (char *)v78 - *(unsigned int *)(v128 + 4);
            v9[1] = v128 + 24;
            v130 = &v129[*(unsigned int *)(v128 + 28)];
            *(_QWORD *)(v72 + 8) = v128 + 24;
            *(_QWORD *)(v72 + 16) = v130;
            if (v76)
            {
              *(_DWORD *)(v75 + 48) = 1;
              v76(*(_QWORD *)(v75 + 40), 1);
              *(_DWORD *)(v75 + 48) = 0;
              v75 = *v9;
            }
            *((_DWORD *)v9 + 12) = 19;
            *(_QWORD *)(v75 + 16) = v72;
            sec_asn1d_init_state_based_on_template((_QWORD *)v72, v74[1], *v74);
            if (!SEC_ASN1DecoderUpdate(*v9, v74[1], *v74) && *(_DWORD *)(*v9 + 24) != 3)
            {
              *(_QWORD *)(v72 + 104) = 0;
              v9[13] += v73;
              *(_DWORD *)(v72 + 48) = 26;
              *((_DWORD *)v9 + 12) = 22;
            }
            v131 = *(_DWORD *)(a1 + 24);
            if (v131 == 1)
              return 0xFFFFFFFFLL;
            if (v131 == 3)
              goto LABEL_458;
            v14 = 0;
            v15 = 0;
            v16 = 0;
            v17 = 0;
            v161 = 2;
            goto LABEL_341;
          case 0xC:
            v197 = (uint64_t)a2;
            v79 = v9[5];
            v80 = *v9;
            v81 = *(void (**)(_QWORD, _QWORD, uint64_t, uint64_t))(*v9 + 32);
            if (v81)
            {
              v82 = *(unsigned int *)(v79 + 112);
              v83 = *(_QWORD *)(v79 + 16);
              *(_DWORD *)(v80 + 48) = 1;
              v81(*(_QWORD *)(v80 + 40), 0, v83, v82);
              *(_DWORD *)(v80 + 48) = 0;
            }
            v84 = *(unsigned __int8 *)(v79 + 140);
            v85 = *(_QWORD *)(v79 + 104);
            *(_QWORD *)(v79 + 104) = 0;
            v3 = &jpt_18A9154FC;
            if (v84)
              goto LABEL_116;
            v9[13] += v85;
            if (*(_QWORD *)(v79 + 40))
            {
              *(_QWORD *)(v79 + 40) = 0;
              *(_QWORD *)(v79 + 24) = 0;
            }
            *(_DWORD *)(v79 + 48) = 20;
            v132 = v9[12];
            if (!v132)
              goto LABEL_116;
            v58 = v132 >= v85;
            v133 = v132 - v85;
            if (!v58)
            {
              v134 = PR_getThreadErrInfo(1, (int *)&v199);
              if (v134)
                *v134 = 0xFFFFE00900000000;
              v14 = 0;
              v15 = 0;
              v16 = 0;
              v17 = 0;
              *(_DWORD *)(*v9 + 24) = 1;
LABEL_329:
              v161 = 2;
              a2 = (char *)v197;
              goto LABEL_340;
            }
            v9[12] = v133;
            if (v133)
            {
LABEL_116:
              v86 = *(_QWORD *)(v79 + 8);
              v87 = *(_DWORD *)(v86 + 24);
              *(_QWORD *)(v79 + 8) = v86 + 24;
              if (v87)
              {
                v88 = v9[2];
                if (v88)
                  *(_QWORD *)(v79 + 16) = v88 + *(unsigned int *)(v86 + 28);
                v89 = *v9;
                v90 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(*v9 + 32);
                if (v90)
                {
                  v91 = *(unsigned int *)(v79 + 112);
                  v92 = *(_QWORD *)(v79 + 16);
                  *(_DWORD *)(v89 + 48) = 1;
                  v90(*(_QWORD *)(v89 + 40), 1, v92, v91);
                  *(_DWORD *)(v89 + 48) = 0;
                }
                if (v84)
                {
                  v93 = *(_BYTE *)(v79 + 52);
                  v94 = *(_QWORD *)(v79 + 64);
                }
                else
                {
                  v93 = 0;
                  v94 = 0;
                }
                *(_QWORD *)(*v9 + 16) = v79;
                inited = sec_asn1d_init_state_based_on_template((_QWORD *)v79, v197, a3);
                v15 = 0;
                v14 = 0;
                v161 = 2;
                if (v84 && inited)
                {
                  *((_DWORD *)inited + 12) = 2;
                  *((_BYTE *)inited + 52) = v93;
                  inited[8] = v94;
                  inited[13] = v85;
                  if (inited[10] == 1024)
                  {
                    a2 = (char *)v197;
                    if (!*(_DWORD *)(*inited + 72))
                    {
                      LOBYTE(v199) = v93 | v94;
                      sec_asn1d_record_any_header((uint64_t **)inited, &v199, 1uLL);
                    }
                    v14 = 0;
                    v15 = 0;
                    v16 = 0;
                    v17 = 0;
                    goto LABEL_301;
                  }
                  v14 = 0;
                  v15 = 0;
                  v16 = 0;
                  v17 = 0;
                }
                else
                {
                  v16 = 0;
                  v17 = 0;
                }
                a2 = (char *)v197;
LABEL_301:
                v3 = &jpt_18A9154FC;
                goto LABEL_340;
              }
              *(_DWORD *)(v79 + 48) = 26;
              if (v9[12])
              {
LABEL_231:
                v120 = PR_getThreadErrInfo(1, (int *)&v199);
                a2 = (char *)v197;
                if (v120)
                  goto LABEL_173;
LABEL_174:
                v14 = 0;
                v15 = 0;
                v16 = 0;
                v17 = 0;
                *(_DWORD *)(*v9 + 24) = 1;
                goto LABEL_339;
              }
              if (v84)
              {
                if (!*((_BYTE *)v9 + 139) || !*(_BYTE *)(v79 + 137) || v85 != 2)
                  goto LABEL_231;
                v14 = 0;
                v15 = 0;
                v16 = 0;
                v17 = 0;
                v9[13] += 2;
                v167 = 22;
              }
              else
              {
                v14 = 0;
                v15 = 0;
                v16 = 0;
                v17 = 0;
                v167 = 20;
              }
              *((_DWORD *)v9 + 12) = v167;
              goto LABEL_329;
            }
            v165 = (int *)(*(_QWORD *)(v79 + 8) + 24);
            a2 = (char *)v197;
            while (1)
            {
              v166 = v165;
              v17 = *v165;
              if (!*v165)
                break;
              v165 += 6;
              if ((v17 & 0x100) == 0)
              {
                *(_QWORD *)(v79 + 8) = v166;
                goto LABEL_172;
              }
            }
            v14 = 0;
            v15 = 0;
            v16 = 0;
            *(_QWORD *)(v79 + 8) = v166;
            *(_DWORD *)(v79 + 48) = 26;
            v161 = 2;
            v119 = 22;
LABEL_170:
            *((_DWORD *)v9 + 12) = v119;
            goto LABEL_340;
          case 0xD:
            v96 = v9 + 15;
            v95 = v9[15];
            if (!v95)
              goto LABEL_270;
            v97 = 0;
            v98 = v9[10];
            while (2)
            {
              while (1)
              {
                v99 = *(_QWORD *)(v95 + 16);
                if (v98 == 3)
                  break;
                v97 += *(_QWORD *)(v95 + 8);
                v95 = *(_QWORD *)(v95 + 16);
                if (!v99)
                {
                  v101 = v3;
                  v102 = v97;
                  if (v98 == 1024)
                  {
                    if (*((_BYTE *)v9 + 139))
                      v97 += 2;
                    v102 = v97;
                  }
                  goto LABEL_263;
                }
              }
              v100 = *(_QWORD *)(v95 + 8);
              if (v99)
              {
                if ((v100 & 7) == 0)
                {
                  v97 += v100;
                  v95 = v99;
                  continue;
                }
LABEL_172:
                v120 = PR_getThreadErrInfo(1, (int *)&v199);
                if (v120)
LABEL_173:
                  *v120 = 0xFFFFE00900000000;
                goto LABEL_174;
              }
              break;
            }
            v101 = v3;
            v102 = v100 + v97;
            v97 = (v100 + v97 + 7) >> 3;
LABEL_263:
            v155 = (unint64_t *)v9[2];
            v14 = (unint64_t)sec_asn1d_zalloc(*(_QWORD *)(*v9 + 8), v97);
            v155[1] = v14;
            if (!v14)
            {
              v15 = 0;
              v16 = 0;
              v17 = 0;
              *(_DWORD *)(*v9 + 24) = 1;
              v161 = 2;
LABEL_325:
              v3 = v101;
              goto LABEL_340;
            }
            *v155 = v102;
            for (i = *v96; i; i = *(_QWORD *)(i + 16))
            {
              if (v98 == 3)
                v157 = (unint64_t)(*(_QWORD *)(i + 8) + 7) >> 3;
              else
                v157 = *(_QWORD *)(i + 8);
              memcpy((void *)v14, *(const void **)i, v157);
              v14 += v157;
            }
            *v96 = 0;
            v9[16] = 0;
            v3 = v101;
LABEL_270:
            v14 = 0;
            v15 = 0;
            v16 = 0;
LABEL_271:
            v17 = 0;
LABEL_272:
            v18 = 22;
            goto LABEL_273;
          case 0xE:
            v103 = (_QWORD *)v9[2];
            if (!v103)
              goto LABEL_270;
            v105 = (_QWORD **)(v9 + 15);
            v104 = v9[15];
            if (v104)
            {
              v106 = 0;
              do
              {
                ++v106;
                v104 = *(_QWORD *)(v104 + 16);
              }
              while (v104);
              v107 = 8 * v106 + 8;
            }
            else
            {
              v107 = 8;
            }
            v145 = sec_asn1d_zalloc(*(_QWORD *)(*v9 + 8), v107);
            if (!v145)
              goto LABEL_174;
            *v103 = v145;
            for (j = *v105; j; j = (_QWORD *)j[2])
              *v145++ = *j;
            *v145 = 0;
            *v105 = 0;
            v9[16] = 0;
            goto LABEL_270;
          case 0xF:
          case 0x10:
          case 0x11:
          case 0x12:
            v11 = v9[5];
            v12 = *(unsigned __int8 *)(v11 + 140);
            *((_BYTE *)v9 + 140) = v12;
            if (v12)
            {
              v9[8] = *(_QWORD *)(v11 + 64);
              *((_BYTE *)v9 + 52) = *(_BYTE *)(v11 + 52);
              *((_BYTE *)v9 + 137) = *(_BYTE *)(v11 + 137);
            }
            v13 = v9[12];
            v9[13] += *(_QWORD *)(v11 + 104);
            if (!v13)
              goto LABEL_12;
            if (v13 != *(_QWORD *)(v11 + 104))
              goto LABEL_172;
            v9[12] = 0;
LABEL_12:
            v14 = 0;
            v15 = 0;
            v16 = 0;
            v17 = 0;
            *(_QWORD *)(v11 + 104) = 0;
LABEL_13:
            v18 = 20;
            goto LABEL_273;
          case 0x13:
            return result;
          case 0x14:
            if (*((_BYTE *)v9 + 139))
            {
              v9[12] = 2;
              v18 = 21;
            }
            else
            {
              v18 = 22;
            }
            v14 = 0;
            v15 = 0;
            v16 = 0;
            v17 = 0;
            goto LABEL_273;
          case 0x15:
            if (!a3)
            {
              v14 = 0;
              v16 = 0;
              v17 = 0;
              v161 = 3;
              *(_DWORD *)(*v9 + 24) = 3;
              v15 = 1;
              goto LABEL_340;
            }
            v108 = v9[12];
            if (v108 >= a3)
              v14 = a3;
            else
              v14 = v9[12];
            if (!v14)
              goto LABEL_149;
            v109 = 0;
            v110 = 1;
            while (!a2[v109])
            {
              v109 = v110;
              if (v14 <= v110++)
              {
LABEL_149:
                v9[12] = v108 - v14;
                v15 = 1;
                if (v108 <= a3)
                {
                  v16 = 0;
                  v17 = 0;
                  *((_DWORD *)v9 + 12) = 22;
                  *((_BYTE *)v9 + 137) = 1;
                }
                else
                {
                  v16 = 0;
                  v17 = 0;
                }
                goto LABEL_283;
              }
            }
            v160 = PR_getThreadErrInfo(1, (int *)&v199);
            if (v160)
              *v160 = 0xFFFFE00900000000;
            v14 = 0;
            v16 = 0;
            v17 = 0;
            v15 = 1;
            *(_DWORD *)(*v9 + 24) = 1;
LABEL_283:
            v161 = 3;
            goto LABEL_340;
          case 0x16:
            if (v9[5])
            {
              v9[5] = 0;
              v9[3] = 0;
            }
            v14 = 0;
            v15 = 0;
            v16 = 0;
            v17 = 0;
            goto LABEL_162;
          case 0x17:
            if (*((_BYTE *)v9 + 136))
            {
              v112 = (char *)sec_asn1d_zalloc(*(_QWORD *)(*v9 + 8), *(unsigned int *)(v9[1] + 16));
              if (!v112)
                goto LABEL_260;
              v113 = v9[1];
              v114 = *(unsigned int *)(v113 + 4);
              v115 = &v112[v114];
              v9[2] = &v112[v114];
            }
            else
            {
              v113 = v9[1];
              v115 = (char *)v9[2];
              v114 = *(unsigned int *)(v113 + 4);
            }
            v135 = sec_asn1d_push_state(*v9, v113 + 24, (uint64_t)&v115[-v114], 0);
            if (v135)
            {
              *((_DWORD *)v135 + 12) = 0;
              *((_BYTE *)v135 + 137) = 0;
              *(_WORD *)((char *)v135 + 139) = 0;
              v136 = sec_asn1d_init_state_based_on_template(v135, (uint64_t)a2, a3);
              if (v136)
              {
                v14 = 0;
                v15 = 0;
                v16 = 0;
                v17 = 0;
                *((_BYTE *)v136 + 141) = 1;
                *((_DWORD *)v9 + 12) = 24;
                v161 = 2;
                v9 = v136;
                goto LABEL_340;
              }
            }
            v9 = 0;
            goto LABEL_337;
          case 0x18:
            v116 = v9[5];
            if (!*(_BYTE *)(v116 + 140))
            {
              v137 = (_DWORD *)v9[2];
              if (v137)
                *v137 = *(_DWORD *)(*(_QWORD *)(v116 + 8) + 16);
              v14 = 0;
              v15 = 0;
              v16 = 0;
              v17 = 0;
              *(_DWORD *)(v116 + 48) = 26;
              v18 = 25;
              goto LABEL_273;
            }
            v9[13] += *(_QWORD *)(v116 + 104);
            if (*(_BYTE *)(v116 + 137))
            {
              *(_DWORD *)(v116 + 48) = 26;
              *((_DWORD *)v9 + 12) = 25;
              *((_BYTE *)v9 + 137) = 1;
              if (sec_asn1d_parent_allows_EOC(v9[4]))
                goto LABEL_337;
            }
            else
            {
              v148 = *(unsigned int **)(v116 + 8);
              v147 = *(_QWORD *)(v116 + 16);
              v149 = v148[1];
              v150 = v148[6];
              *(_QWORD *)(v116 + 8) = v148 + 6;
              if (v150)
              {
                *(_QWORD *)(v116 + 16) = v147 - v149 + v148[7];
                v151 = v9[12];
                if (!v151
                  || (v152 = *(_QWORD *)(v116 + 104), v58 = v151 >= v152, v153 = v151 - v152, v58)
                  && (v9[12] = v153) != 0)
                {
                  v101 = v3;
                  *(_QWORD *)(v116 + 104) = 0;
                  *(_DWORD *)(v116 + 48) = 0;
                  *(_BYTE *)(v116 + 137) = 0;
                  *(_WORD *)(v116 + 139) = 0;
                  *(_QWORD *)(*v9 + 16) = v116;
                  v168 = *(_BYTE *)(v116 + 52);
                  v169 = *(_QWORD *)(v116 + 64);
                  v170 = sec_asn1d_init_state_based_on_template((_QWORD *)v116, (uint64_t)a2, a3);
                  v9 = v170;
                  v161 = 2;
                  v14 = 0;
                  v15 = 0;
                  v16 = 0;
                  v17 = 0;
                  if (v170)
                  {
                    *((_BYTE *)v170 + 52) = v168;
                    v170[8] = v169;
                    *((_BYTE *)v170 + 141) = 1;
                    *((_DWORD *)v170 + 12) = 2;
                  }
                  goto LABEL_325;
                }
              }
            }
            v154 = PR_getThreadErrInfo(1, (int *)&v199);
            if (v154)
              *v154 = 0xFFFFE00900000000;
LABEL_260:
            v14 = 0;
            v15 = 0;
            v16 = 0;
            v17 = 0;
            *(_DWORD *)(*v9 + 24) = 1;
            v161 = 2;
            v9 = 0;
            goto LABEL_340;
          case 0x19:
            v14 = 0;
            v15 = 0;
            v16 = 0;
            v17 = 0;
            v117 = v9[5];
            v9[13] += *(_QWORD *)(v117 + 104);
            *(_QWORD *)(v117 + 104) = 0;
            v9[5] = 0;
            v9[3] = 0;
LABEL_162:
            *((_DWORD *)v9 + 12) = 20;
            *(_QWORD *)(*v9 + 16) = v9[4];
            goto LABEL_339;
          default:
LABEL_458:
            v196 = PR_getThreadErrInfo(1, (int *)&v199);
            if (v196)
              *v196 = 0xFFFFE00900000000;
            *(_DWORD *)(a1 + 24) = 1;
            v7 = v198;
            goto LABEL_452;
        }
        break;
      }
    }
  }
  v9 = 0;
LABEL_444:
  if (v8 == 1)
    goto LABEL_451;
  return 0;
}

void nss_cms_decoder_notify(uint64_t a1, int a2, uint64_t a3)
{
  unsigned int v4;
  uint64_t v6;
  _BOOL4 v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *p_plainTextLen;
  _QWORD *v21;
  int v22;
  int v23;
  uint64_t started;
  uint64_t v25;
  uint64_t *v26;
  int v27;
  _QWORD *ThreadErrInfo;
  uint64_t v29;
  uint64_t v30;
  uint64_t (*v31)(_QWORD, uint64_t);
  const __CFData *v32;
  const __CFData *v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  int v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t *v42;
  unint64_t v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  char *v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  _QWORD *v54;
  _QWORD *v55;
  char *v56;
  const void *v57;
  const void *v58;
  int *v59;
  int *v60;
  uint64_t v61;
  uint64_t v62;
  __SecKey *v63;
  int v64;
  uint64_t OID;
  size_t v66;
  uint8_t *v67;
  const UInt8 *v68;
  CFDataRef v69;
  _QWORD *v70;
  unint64_t v71;
  uint64_t v72;
  _QWORD *v73;
  uint64_t v74;
  __int128 v75;
  _DWORD *v76;
  _QWORD *v77;
  CFTypeRef v78;
  _QWORD *v79;
  int v80;
  _DWORD *v81;
  uint64_t v82;
  uint64_t v83;
  __int128 *v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  uint64_t v90;
  unsigned int v91;
  const __CFData *v92;
  CFNumberRef v93;
  const __CFDictionary *v94;
  const __CFData *v95;
  CFDataRef v96;
  CFNumberRef v97;
  const __CFData *v98;
  const UInt8 *BytePtr;
  CFIndex v100;
  UInt8 *v101;
  size_t OutputLength;
  const __CFData *v103;
  const __CFDictionary *v104;
  CFNumberRef v105;
  CFDataRef v106;
  CCOptions v107;
  CCAlgorithm v108;
  unsigned int v109;
  UInt8 *v110;
  UInt8 *v111;
  CFTypeRef v112;
  CFNumberRef v113;
  const UInt8 *publicKey;
  __SecKey *publicKeya;
  size_t v116;
  size_t dataOutMoved;
  unsigned int v118;
  CFTypeRef valuePtr;
  CCCryptorRef cryptorRef;
  CFTypeRef cf;
  int v122;
  __int16 v123;
  CFIndex length;
  UInt8 *bytes;
  uint64_t v126;
  void *iv;
  __int128 v128;
  __int128 v129;
  int v130;
  void *v131[2];
  void *v132[2];
  void *values[3];
  void *keys[3];
  __int128 plainTextLen;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  uint64_t v139;

  v139 = *MEMORY[0x1E0C80C00];
  v4 = *(_DWORD *)(a1 + 16);
  if (v4 > 0x1E)
    goto LABEL_15;
  v6 = *(_QWORD *)(a1 + 8);
  if (((1 << v4) & 0x6C000000) != 0)
  {
    v7 = a2 != 0;
    v8 = (uint64_t *)(v6 + 16);
    if (a2 && v8 == (uint64_t *)a3)
      return;
    v9 = *(_QWORD *)(a1 + 24);
    if ((v9 || (v9 = *v8, *(_QWORD *)(a1 + 24) = *v8, v9)) && ((1 << v4) & 0x6C000000) != 0)
    {
      v10 = v9;
      if (!a2)
        goto LABEL_26;
    }
    else
    {
      v10 = 0;
      if (!a2)
      {
LABEL_26:
        if (v10 + 72 != a3)
          v7 = 0;
        if (v7)
        {
          v16 = *(_QWORD *)a1;
          v17 = *(_QWORD *)(a1 + 48) != 0;
          *(_QWORD *)(v16 + 56) = nss_cms_decoder_update_filter;
          *(_QWORD *)(v16 + 64) = a1;
          *(_DWORD *)(v16 + 72) = v17;
          v18 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120);
          switch(v4)
          {
            case 0x1Au:
              v19 = *(_QWORD **)(a1 + 24);
              p_plainTextLen = (uint64_t *)v19[17];
              if (!p_plainTextLen)
                goto LABEL_57;
              if (v19[21])
                goto LABEL_56;
              goto LABEL_46;
            case 0x1Bu:
              v25 = *(_QWORD *)(a1 + 24);
              v26 = *(uint64_t **)(v25 + 144);
              if (!v26
                || !*v26
                || (v27 = nss_cms_recipients_traverse(*(uint64_t **)(v25 + 144), 0),
                    (v27 - 268435454) <= 0xF0000002))
              {
                ThreadErrInfo = PR_getThreadErrInfo(1, (int *)&plainTextLen);
                if (ThreadErrInfo)
                  *ThreadErrInfo = 0xFFFFE00200000000;
                goto LABEL_120;
              }
              v49 = (char *)PORT_ZAlloc(8 * (v27 + 1));
              if (!v49)
                goto LABEL_120;
              v50 = v49;
              if ((nss_cms_recipients_traverse(v26, (uint64_t)v49) & 0x80000000) != 0)
                goto LABEL_119;
              v51 = *(_QWORD *)v50;
              if (!*(_QWORD *)v50)
                goto LABEL_116;
              v52 = 0;
              break;
            case 0x1Du:
              v19 = *(_QWORD **)(a1 + 24);
              if (!v19[17])
                goto LABEL_120;
              plainTextLen = (unint64_t)(v19 + 17);
              p_plainTextLen = (uint64_t *)&plainTextLen;
LABEL_46:
              started = SecCmsDigestContextStartMultiple(p_plainTextLen);
              v19[13] = started;
              if (!started)
                goto LABEL_120;
              goto LABEL_56;
            case 0x1Eu:
              v29 = *(_QWORD *)(a1 + 24);
              v30 = *(_QWORD *)(v29 + 24);
              v31 = *(uint64_t (**)(_QWORD, uint64_t))(v30 + 144);
              if (v31)
              {
                v32 = (const __CFData *)v31(*(_QWORD *)(v30 + 152), v29 + 40);
                if (v32)
                {
                  v33 = v32;
                  SecCmsContentInfoSetBulkKey(v29, v32);
                  v34 = SecCmsCipherContextStart(0, v33, v29 + 40, 0);
                  *(_QWORD *)(v29 + 96) = v34;
                  CFRelease(v33);
                  if (v34)
                    goto LABEL_56;
                }
              }
              goto LABEL_120;
            default:
              goto LABEL_120;
          }
          while (1)
          {
            v53 = *(_DWORD *)(v51 + 8);
            if (v53 == 1)
            {
              v54 = CERT_FindBySubjectKeyID(0, CFSTR("idnt"), *(CFIndex **)(v51 + 16));
            }
            else
            {
              if (v53)
                goto LABEL_97;
              v54 = CERT_FindByIssuerAndSN(0, CFSTR("idnt"), *(_QWORD *)(v51 + 16));
            }
            v55 = v54;
            if (v54)
            {
              v57 = (const void *)v54[2];
              CFRetain(v57);
              v58 = (const void *)v55[3];
              CFRetain(v58);
              CFRelease(v55);
              *(_QWORD *)(v51 + 24) = v57;
              *(_QWORD *)(v51 + 32) = v58;
              if ((v52 & 0x80000000) != 0)
              {
LABEL_116:
                v70 = PR_getThreadErrInfo(1, (int *)&plainTextLen);
                if (!v70)
                  goto LABEL_119;
                v71 = 0xFFFFE02D00000000;
              }
              else
              {
                v59 = *(int **)&v50[8 * v52];
                if (!*((_QWORD *)v59 + 3) || !*((_QWORD *)v59 + 4))
                  goto LABEL_119;
                v60 = *(int **)(*(_QWORD *)(v25 + 144) + 8 * *v59);
                if (SecCmsContentInfoGetContentEncAlgTag(v25))
                {
                  v61 = v59[1];
                  v62 = *((_QWORD *)v59 + 3);
                  v63 = (__SecKey *)*((_QWORD *)v59 + 4);
                  if (v62)
                    CFRetain(*((CFTypeRef *)v59 + 3));
                  *((_QWORD *)v60 + 18) = v62;
                  v64 = *v60;
                  if (*v60 == 2)
                    goto LABEL_140;
                  if (v64 != 1)
                  {
                    if (!v64)
                    {
                      if (*((_QWORD *)v60 + 6))
                      {
                        OID = SECOID_FindOID((uint64_t)(v60 + 10));
                        if (OID)
                        {
                          if (*(_DWORD *)(OID + 16) == 16)
                          {
                            v66 = *((_QWORD *)v60 + 9);
                            *(_QWORD *)&plainTextLen = v66;
                            if (v66 <= 0x400
                              && (v67 = (uint8_t *)malloc_type_malloc(v66, 0xA6A0B44AuLL)) != 0
                              && (v68 = v67,
                                  !SecKeyDecrypt(v63, 1u, *((const uint8_t **)v60 + 10), *((_QWORD *)v60 + 9), v67, (size_t *)&plainTextLen)))
                            {
                              v69 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v68, plainTextLen, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
                            }
                            else
                            {
                              v69 = 0;
                            }
                            goto LABEL_145;
                          }
                        }
                      }
LABEL_140:
                      v80 = -8144;
LABEL_141:
                      v81 = PR_getThreadErrInfo(1, (int *)&plainTextLen);
                      if (v81)
                      {
                        *v81 = 0;
                        v81[1] = v80;
                      }
                    }
LABEL_119:
                    nss_cms_recipient_list_destroy(v50);
                    goto LABEL_120;
                  }
                  if (!*((_QWORD *)v60 + 13))
                    goto LABEL_140;
                  v74 = SECOID_FindOID((uint64_t)(v60 + 24));
                  if (!v74 || *(_DWORD *)(v74 + 16) != 204)
                    goto LABEL_140;
                  if (v60[6] != 2)
                  {
                    v80 = -8191;
                    goto LABEL_141;
                  }
                  v110 = *(UInt8 **)(*((_QWORD *)v60 + 16) + 8 * v61);
                  v112 = (CFTypeRef)*((_QWORD *)v60 + 8);
                  publicKey = (const UInt8 *)*((_QWORD *)v60 + 9);
                  *(_QWORD *)&v75 = 0xAAAAAAAAAAAAAAAALL;
                  *((_QWORD *)&v75 + 1) = 0xAAAAAAAAAAAAAAAALL;
                  v128 = v75;
                  v129 = v75;
                  v126 = 0;
                  iv = 0;
                  v137 = v75;
                  v138 = v75;
                  plainTextLen = v75;
                  v136 = v75;
                  length = 0;
                  bytes = 0;
                  v123 = 5;
                  v122 = -1431655766;
                  cryptorRef = 0;
                  cf = 0;
                  valuePtr = 0;
                  v76 = PORT_NewArena(1024);
                  if (v76)
                  {
                    v77 = v76;
                    v128 = 0u;
                    v129 = 0u;
                    if (!SEC_ASN1Decode((uint64_t)v76, (uint64_t)&v128, (uint64_t)&SECOID_AlgorithmIDTemplate, *((char **)v60 + 15), *((_QWORD *)v60 + 14)))
                    {
                      v83 = SECOID_FindOID((uint64_t)&v128);
                      if (v83)
                      {
                        v84 = (__int128 *)v83;
                        v85 = *(_DWORD *)(v83 + 16);
                        switch(v85)
                        {
                          case 183:
                            v108 = 0;
                            v86 = 2;
                            goto LABEL_156;
                          case 184:
                            v108 = 0;
                            v86 = 1;
LABEL_156:
                            v107 = v86;
                            v87 = 128;
                            break;
                          case 185:
                            v108 = 0;
                            v88 = 2;
                            goto LABEL_159;
                          case 186:
                            v108 = 0;
                            v88 = 1;
LABEL_159:
                            v107 = v88;
                            v87 = 192;
                            break;
                          case 187:
                            v108 = 0;
                            v89 = 2;
                            goto LABEL_162;
                          case 188:
                            v108 = 0;
                            v89 = 1;
LABEL_162:
                            v107 = v89;
                            v87 = 256;
                            break;
                          default:
                            v107 = 1;
                            v108 = 2;
                            v109 = 192;
                            switch(v85)
                            {
                              case 7:
                                goto LABEL_164;
                              case 9:
                                v107 = 2;
                                break;
                              case 10:
                                break;
                              case 14:
                                v108 = 2;
                                v109 = 192;
                                v107 = 2;
                                goto LABEL_164;
                              default:
                                goto LABEL_131;
                            }
                            v108 = 1;
                            v87 = 64;
                            break;
                        }
                        v109 = v87;
LABEL_164:
                        if (!SEC_ASN1Decode((uint64_t)v77, (uint64_t)&v126, (uint64_t)kSecAsn1OctetStringTemplate, *((char **)&v129 + 1), v129))
                        {
                          v137 = 0u;
                          v138 = 0u;
                          plainTextLen = 0u;
                          v136 = 0u;
                          plainTextLen = *v84;
                          *(_QWORD *)&v136 = 2;
                          *((_QWORD *)&v136 + 1) = &v123;
                          v137 = *((_OWORD *)v60 + 5);
                          v90 = 3;
                          v91 = v109;
                          do
                          {
                            *((_BYTE *)&v122 + v90) = v91;
                            v91 >>= 8;
                            --v90;
                          }
                          while (v90 != -1);
                          *(_QWORD *)&v138 = 4;
                          *((_QWORD *)&v138 + 1) = &v122;
                          if (SEC_ASN1EncodeItem((uint64_t)v77, &length, (uint64_t)&plainTextLen, (uint64_t)&ECC_CMS_SharedInfoTemplate))
                          {
                            valuePtr = v112;
                            v92 = CFDataCreate(0, publicKey, ((unint64_t)v112 + 7) >> 3);
                            v93 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
                            keys[0] = CFSTR("type");
                            keys[1] = CFSTR("kcls");
                            keys[2] = CFSTR("bsiz");
                            values[0] = CFSTR("73");
                            values[1] = CFSTR("0");
                            v105 = v93;
                            values[2] = v93;
                            v103 = v92;
                            v104 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                            publicKeya = SecKeyCreateWithData(v92, v104, (CFErrorRef *)&cf);
                            v69 = 0;
                            if (cf)
                            {
                              v106 = 0;
                              v113 = 0;
                              v94 = 0;
                              v95 = 0;
                            }
                            else
                            {
                              v106 = 0;
                              v113 = 0;
                              v94 = 0;
                              v95 = 0;
                              if ((length & 0x8000000000000000) == 0)
                              {
                                v96 = CFDataCreate(0, bytes, length);
                                v118 = v109 >> 3;
                                v97 = CFNumberCreate(0, kCFNumberSInt32Type, &v118);
                                v132[0] = CFSTR("requestedSize");
                                v132[1] = CFSTR("sharedInfo");
                                v113 = v97;
                                v131[0] = v97;
                                v131[1] = v96;
                                v106 = v96;
                                v94 = CFDictionaryCreate(0, (const void **)v132, (const void **)v131, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                                v98 = SecKeyCopyKeyExchangeResult(v63, CFSTR("algid:keyexchange:ECDH:KDFX963:SHA1"), publicKeya, v94, (CFErrorRef *)&cf);
                                v95 = v98;
                                if (cf
                                  || CFDataGetLength(v98) < 0
                                  || (BytePtr = CFDataGetBytePtr(v95),
                                      v100 = CFDataGetLength(v95),
                                      CCCryptorCreate(1u, v108, v107, BytePtr, v100, iv, &cryptorRef))
                                  || (v101 = v110,
                                      OutputLength = CCCryptorGetOutputLength(cryptorRef, *((_QWORD *)v110 + 7), 1),
                                      dataOutMoved = 0,
                                      v111 = (UInt8 *)PORT_ArenaAlloc((uint64_t)v77, OutputLength),
                                      CCCryptorUpdate(cryptorRef, *((const void **)v101 + 8), *((_QWORD *)v101 + 7), v111, OutputLength, &dataOutMoved))|| (v116 = 0, CCCryptorFinal(cryptorRef, &v111[dataOutMoved], OutputLength - dataOutMoved, &v116))|| (uint64_t)(v116 + dataOutMoved) < 0)
                                {
                                  v69 = 0;
                                }
                                else
                                {
                                  v69 = CFDataCreate(0, v111, v116 + dataOutMoved);
                                }
                              }
                            }
                            PORT_FreeArena(v77, 0);
                            if (v103)
                              CFRelease(v103);
                            if (v105)
                              CFRelease(v105);
                            if (publicKeya)
                              CFRelease(publicKeya);
                            if (v104)
                              CFRelease(v104);
                            if (v106)
                              CFRelease(v106);
                            if (v113)
                              CFRelease(v113);
                            if (v94)
                              CFRelease(v94);
                            if (v95)
                              CFRelease(v95);
                            goto LABEL_133;
                          }
                        }
                      }
                    }
LABEL_131:
                    PORT_FreeArena(v77, 0);
                  }
                  v69 = 0;
LABEL_133:
                  v78 = cf;
                  if (cf)
                  {
                    cf = 0;
                    CFRelease(v78);
                  }
                  if (cryptorRef)
                    CCCryptorRelease(cryptorRef);
                  if (!v69)
                  {
                    v79 = PR_getThreadErrInfo(1, &v130);
                    if (v79)
                      *v79 = 0xFFFFE01A00000000;
                  }
LABEL_145:
                  if (!v69)
                    goto LABEL_119;
                  SecCmsContentInfoSetBulkKey(v25, v69);
                  CFRetain(*((CFTypeRef *)v59 + 4));
                  *(_QWORD *)(v25 + 112) = *((_QWORD *)v59 + 4);
                  v82 = SecCmsCipherContextStart(0, v69, v25 + 40, 0);
                  *(_QWORD *)(v25 + 96) = v82;
                  CFRelease(v69);
                  nss_cms_recipient_list_destroy(v50);
                  if (v82)
                  {
LABEL_56:
                    v19 = *(_QWORD **)(a1 + 24);
                    if (v19)
                    {
LABEL_57:
                      v35 = *(_DWORD *)(a1 + 16);
                      if (v35 > 0x1E || ((1 << v35) & 0x6C000000) == 0)
                        v19 = 0;
                    }
                    v36 = v19[4];
                    if (v36 || (v36 = SECOID_FindOID((uint64_t)v19), (v19[4] = v36) != 0))
                    {
                      v37 = *(_DWORD *)(v36 + 16);
                      if (v37 == 25)
                      {
                        v38 = SECITEM_AllocItem(v18, 0, 0);
                        v19[2] = v38;
                        if (v38)
                        {
                          *(_QWORD *)(a1 + 32) = 0;
                          return;
                        }
                      }
                      else
                      {
                        v39 = (v37 - 26);
                        if (v39 <= 4 && v37 != 28)
                        {
                          v40 = (uint64_t)*(&off_1E1FD08A0 + v39);
                          v41 = (uint64_t *)PORT_ZAlloc(0x40uLL);
                          if (v41)
                          {
                            v42 = v41;
                            if (qword_18AA5B648[v39] <= 1uLL)
                              v43 = 1;
                            else
                              v43 = qword_18AA5B648[v39];
                            v44 = (void *)PORT_ArenaAlloc(v18, v43);
                            if (v44)
                            {
                              v45 = (uint64_t)v44;
                              bzero(v44, v43);
                              v42[3] = v45;
                              v46 = SEC_ASN1DecoderStart(v18, v45, v40, 0, 0);
                              *v42 = v46;
                              if (v46)
                              {
                                *(_QWORD *)(v46 + 32) = nss_cms_decoder_notify;
                                *(_QWORD *)(v46 + 40) = v42;
                                *(_QWORD *)(a1 + 32) = v42;
                                *((_DWORD *)v42 + 4) = v37;
                                v42[1] = *(_QWORD *)(a1 + 8);
                                *((_OWORD *)v42 + 3) = *(_OWORD *)(a1 + 48);
                                *(_QWORD *)(a1 + 48) = SecCmsDecoderUpdate;
                                *(_QWORD *)(a1 + 56) = v42;
                                return;
                              }
                            }
                            free(v42);
                            *(_QWORD *)(a1 + 32) = 0;
                          }
                        }
                      }
                    }
                  }
LABEL_120:
                  v72 = *(_QWORD *)a1;
                  *(_QWORD *)(v72 + 56) = 0;
                  *(_QWORD *)(v72 + 64) = 0;
                  *(_DWORD *)(v72 + 72) = 0;
                  *(_DWORD *)(a1 + 44) = PORT_GetError();
                  v73 = PR_getThreadErrInfo(1, (int *)&plainTextLen);
                  if (v73)
                    *v73 = 0;
                  return;
                }
                v70 = PR_getThreadErrInfo(1, (int *)&plainTextLen);
                if (!v70)
                  goto LABEL_119;
                v71 = 0xFFFFE00600000000;
              }
              *v70 = v71;
              goto LABEL_119;
            }
LABEL_97:
            v56 = &v50[8 * v52++];
            v51 = *((_QWORD *)v56 + 1);
            if (!v51)
              goto LABEL_116;
          }
        }
        if (a2 || v10 + 72 != a3)
          return;
        nss_cms_decoder_work_data(a1, 0, 0, 1);
        v21 = *(_QWORD **)(a1 + 32);
        if (!v21)
        {
          v22 = -1;
LABEL_77:
          switch(*(_DWORD *)(a1 + 16))
          {
            case 0x19:
              goto LABEL_82;
            case 0x1A:
              v22 = SecCmsSignedDataDecodeAfterData(*(_QWORD **)(a1 + 24));
              goto LABEL_82;
            case 0x1B:
              SecCmsEnvelopedDataDecodeAfterData(*(_QWORD *)(a1 + 24));
              goto LABEL_86;
            case 0x1D:
              v22 = SecCmsDigestedDataEncodeAfterData(*(_QWORD **)(a1 + 24));
LABEL_82:
              if (v22)
                goto LABEL_83;
              goto LABEL_86;
            case 0x1E:
              SecCmsEncryptedDataEncodeAfterData(*(_QWORD *)(a1 + 24));
              goto LABEL_86;
            default:
              goto LABEL_83;
          }
        }
        if (!*v21)
        {
          v23 = -1;
LABEL_75:
          free(v21);
          v22 = v23;
LABEL_76:
          *(_QWORD *)(a1 + 32) = 0;
          goto LABEL_77;
        }
        if (!SEC_ASN1DecoderFinish(*v21))
        {
          v22 = nss_cms_after_end((uint64_t)v21);
          if (!v22)
          {
            v23 = 0;
            v21 = *(_QWORD **)(a1 + 32);
            if (!v21)
              goto LABEL_76;
            goto LABEL_75;
          }
        }
LABEL_83:
        *(_DWORD *)(a1 + 44) = PORT_GetError();
        v47 = PR_getThreadErrInfo(1, (int *)&plainTextLen);
        if (v47)
          *v47 = 0;
LABEL_86:
        v48 = *(_QWORD *)a1;
        *(_QWORD *)(v48 + 56) = 0;
        *(_QWORD *)(v48 + 64) = 0;
        *(_DWORD *)(v48 + 72) = 0;
        return;
      }
    }
    if (v10 == a3 && ((1 << v4) & 0x6C000000) != 0)
      *(_QWORD *)(v9 + 24) = v6;
    goto LABEL_26;
  }
  if (!v4)
  {
    if (!a2 && v6 == a3)
    {
      v14 = *(_QWORD *)(a3 + 32);
      if (v14 || (v14 = SECOID_FindOID(a3), (*(_QWORD *)(a3 + 32) = v14) != 0))
        v15 = *(_DWORD *)(v14 + 16);
      else
        v15 = 0;
      *(_DWORD *)(a1 + 16) = v15;
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a3 + 16);
    }
    return;
  }
  if (v4 != 25)
  {
LABEL_15:
    *(_DWORD *)(a1 + 44) = -8058;
    return;
  }
  v11 = v6 + 16;
  if (a2 && v11 == a3)
  {
    v12 = *(_QWORD *)a1;
    v13 = *(_QWORD *)(a1 + 48) != 0;
    *(_QWORD *)(v12 + 56) = nss_cms_decoder_update_filter;
    *(_QWORD *)(v12 + 64) = a1;
    *(_DWORD *)(v12 + 72) = v13;
    return;
  }
  if (!a2 && v11 == a3)
    goto LABEL_86;
}

uint64_t sec_asn1d_check_and_subtract_length(unint64_t *a1, unint64_t a2, uint64_t a3)
{
  _QWORD *ThreadErrInfo;
  uint64_t result;
  _QWORD *v6;
  int v7;
  int v8;

  if (a1 && a3)
  {
    if (*a1 >= a2)
    {
      *a1 -= a2;
      return 1;
    }
    else
    {
      ThreadErrInfo = PR_getThreadErrInfo(1, &v8);
      if (ThreadErrInfo)
        *ThreadErrInfo = 0xFFFFE00900000000;
      result = 0;
      *(_DWORD *)(a3 + 24) = 1;
    }
  }
  else
  {
    v6 = PR_getThreadErrInfo(1, &v7);
    if (v6)
      *v6 = 0xFFFFE00500000000;
    result = 0;
    if (a3)
      *(_DWORD *)(a3 + 24) = 1;
  }
  return result;
}

_QWORD *sec_asn1d_init_state_based_on_template(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  void (*v9)(_QWORD, _QWORD, uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(_QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t v18;
  unint64_t v19;
  int v20;
  BOOL v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  int v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t (**v29)(uint64_t, _QWORD, uint64_t, uint64_t);
  uint64_t v30;
  _QWORD *v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  BOOL v37;
  char v38;
  uint64_t v39;
  uint64_t inited;

  while (1)
  {
    if (!a1)
      return a1;
    v6 = *a1;
    if (*(_DWORD *)(*a1 + 24) == 1)
      return a1;
    v7 = (unsigned int *)a1[1];
    if (!v7)
      return a1;
    v8 = *v7;
    if ((*v7 & 0x20000) == 0)
      goto LABEL_19;
    if (*(_DWORD *)(v6 + 72))
      break;
    *((_BYTE *)a1 + 137) = 0;
    *(_WORD *)((char *)a1 + 139) = 0;
    *((_DWORD *)a1 + 12) = 11;
    a1 = sec_asn1d_push_state(v6, (uint64_t)kSecAsn1AnyTemplate, a1[2], 0);
    if (!a1)
      return a1;
  }
  v9 = *(void (**)(_QWORD, _QWORD, uint64_t, uint64_t))(v6 + 32);
  if (v9)
  {
    v10 = *((unsigned int *)a1 + 28);
    v11 = a1[2];
    *(_DWORD *)(v6 + 48) = 1;
    v9(*(_QWORD *)(v6 + 40), 0, v11, v10);
    *(_DWORD *)(v6 + 48) = 0;
  }
  v12 = a1[2];
  if (v12)
  {
    v13 = (unsigned int *)a1[1];
    v14 = v12 - v13[1];
  }
  else
  {
    v14 = *(_QWORD *)(a1[4] + 16);
    v13 = (unsigned int *)a1[1];
  }
  v7 = v13 + 6;
  a1[1] = v13 + 6;
  a1[2] = v14;
  if (v14)
  {
    v15 = v14 + v13[7];
    a1[2] = v15;
  }
  else
  {
    v15 = 0;
  }
  v16 = *a1;
  v17 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(*a1 + 32);
  if (v17)
  {
    v18 = *((unsigned int *)a1 + 28);
    *(_DWORD *)(v16 + 48) = 1;
    v17(*(_QWORD *)(v16 + 40), 1, v15, v18);
    *(_DWORD *)(v16 + 48) = 0;
    v7 = (unsigned int *)a1[1];
  }
  v8 = *v7;
LABEL_19:
  if ((v8 & 0x100000) != 0)
  {
    *((_DWORD *)a1 + 12) = 23;
    return a1;
  }
  v19 = v8 & 0x200;
  v20 = (v8 >> 8) & 1;
  v22 = (v8 & 0xC0) == 0 || v19 != 0;
  if ((v8 & 0x1800) == 0 && v22)
  {
    v23 = v8 & 0xFFFBBCFF;
    if ((v8 & 0x200) != 0)
      v23 = 0;
    goto LABEL_54;
  }
  *((_DWORD *)a1 + 12) = 0;
  *((_BYTE *)a1 + 137) = 0;
  *(_WORD *)((char *)a1 + 139) = 0;
  if ((v8 & 0x1000) != 0)
  {
    v25 = 0;
    v24 = *(_DWORD *)(*a1 + 72) == 0;
    v26 = 18;
  }
  else
  {
    v24 = 0;
    v25 = a1[2];
    if ((v8 & 0x800) != 0)
      v26 = 17;
    else
      v26 = 16;
  }
  *((_DWORD *)a1 + 12) = v26;
  *((_BYTE *)a1 + 141) = v20;
  v27 = a1;
  while (1)
  {
    v28 = v27[2];
    if (v28)
      break;
    v27 = (_QWORD *)v27[4];
    if (!v27)
    {
      v29 = (uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))*((_QWORD *)v7 + 1);
      if (v29 && (v8 & 0x4000) != 0)
      {
        if (*v29)
        {
          v30 = ((uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t, _QWORD))*v29)(0, 0, a2, a3, 0);
LABEL_48:
          v29 = (uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))v30;
          goto LABEL_50;
        }
LABEL_49:
        v29 = 0;
        goto LABEL_50;
      }
      goto LABEL_50;
    }
  }
  v29 = (uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))*((_QWORD *)v7 + 1);
  if (v29 && (v8 & 0x4000) != 0)
  {
    if (*v29)
    {
      v30 = (*v29)(v28 - v7[1], 0, a2, a3);
      goto LABEL_48;
    }
    goto LABEL_49;
  }
LABEL_50:
  v31 = sec_asn1d_push_state(*a1, (uint64_t)v29, v25, 0);
  a1 = v31;
  if (v31)
  {
    *((_BYTE *)v31 + 136) = v24;
    if ((v8 & 0xC0) != 0 && (v8 & 0x4000) == 0)
    {
      v23 = *(_DWORD *)v31[1] & 0xFFFBFFFF;
LABEL_54:
      if ((v8 & 0x8400) != 0)
      {
        v32 = 0;
        v33 = 0;
        v34 = 0;
        if ((v8 & 0x8000) != 0)
          a1[2] = 0;
      }
      else
      {
        v32 = v8 & 0xE0;
        v34 = v8 & 0x1F;
        v35 = 1 << (v23 & 0x1F);
        v36 = v8 & 0xC0 | 0x20;
        if ((v35 & 0x30000) == 0)
          v36 = v8 & 0xE0;
        v37 = (v35 & 0x55D81018) == 0;
        if ((v35 & 0x55D81018) != 0)
          v38 = v8 & 0xE0;
        else
          v38 = v36;
        if (v37)
          v39 = 255;
        else
          v39 = 223;
        if ((v23 & 0x1F) == 0x1F)
        {
          v33 = 255;
        }
        else
        {
          v32 = v38;
          v33 = v39;
        }
      }
      a1[7] = v33;
      *((_BYTE *)a1 + 53) = v32;
      a1[9] = v34;
      a1[10] = v23;
      *((_BYTE *)a1 + 138) = v19 >> 9;
      *((_BYTE *)a1 + 141) = v20;
      *((_DWORD *)a1 + 12) = 0;
      *((_BYTE *)a1 + 137) = 0;
      *(_WORD *)((char *)a1 + 139) = 0;
      return a1;
    }
    inited = sec_asn1d_init_state_based_on_template(v31, a2, a3);
    a1 = (_QWORD *)inited;
    if (inited)
      *(_BYTE *)(inited + 141) = v20;
  }
  return a1;
}

_QWORD *sec_asn1d_push_state(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5;
  _QWORD *result;
  int v10;
  _QWORD *ThreadErrInfo;
  _QWORD *v12;
  int v13;
  int v14;

  v5 = *(_QWORD *)(a1 + 16);
  if (a2)
  {
    if (v5)
      *(_QWORD *)(v5 + 24) = -1;
    result = sec_asn1d_zalloc(*(_QWORD *)a1, 0x90uLL);
    if (result)
    {
      result[4] = v5;
      *result = a1;
      result[1] = a2;
      *((_DWORD *)result + 12) = 26;
      if (a3)
        result[2] = a3 + *(unsigned int *)(a2 + 4);
      if (v5)
      {
        v10 = *(_DWORD *)(v5 + 112);
        *((_DWORD *)result + 28) = v10;
        if (a4)
        {
          *((_DWORD *)result + 28) = v10 + 1;
          if (v10 >= 32)
          {
            ThreadErrInfo = PR_getThreadErrInfo(1, &v14);
            if (ThreadErrInfo)
              *ThreadErrInfo = 0xFFFFE00900000000;
            *(_DWORD *)(a1 + 24) = 1;
            goto LABEL_16;
          }
        }
        *(_QWORD *)(v5 + 40) = result;
      }
      *(_QWORD *)(a1 + 16) = result;
      return result;
    }
  }
  else
  {
    v12 = PR_getThreadErrInfo(1, &v13);
    if (v12)
      *v12 = 0xFFFFE08800000000;
  }
  *(_DWORD *)(a1 + 24) = 1;
  if (v5)
  {
LABEL_16:
    result = 0;
    *(_QWORD *)(v5 + 24) = 0;
    return result;
  }
  return 0;
}

void sec_asn1d_add_to_subitems(uint64_t **a1, void *a2, unint64_t a3, int a4)
{
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t *v13;

  v8 = (uint64_t *)sec_asn1d_zalloc(**a1, 0x18uLL);
  if (!v8)
  {
    *((_DWORD *)*a1 + 6) = 1;
    return;
  }
  v9 = v8;
  if (!a4)
  {
    v12 = (uint64_t)a2;
LABEL_10:
    *v9 = v12;
    v9[1] = a3;
    v9[2] = 0;
    if (a1[15])
      a1[16][2] = (uint64_t)v9;
    else
      a1[15] = v9;
    a1[16] = v9;
    return;
  }
  v10 = **a1;
  if (v10)
    v11 = (void *)PORT_ArenaAlloc(v10, a3);
  else
    v11 = PORT_Alloc(a3);
  v12 = (uint64_t)v11;
  if (v11)
  {
    memcpy(v11, a2, a3);
    goto LABEL_10;
  }
  v13 = *a1;
  *((_DWORD *)v13 + 6) = 1;
  if (!*v13)
    free(v9);
}

void *sec_asn1d_zalloc(uint64_t a1, unint64_t a2)
{
  void *v3;
  void *v4;

  if (a1)
    v3 = (void *)PORT_ArenaAlloc(a1, a2);
  else
    v3 = PORT_Alloc(a2);
  v4 = v3;
  if (v3)
    bzero(v3, a2);
  return v4;
}

uint64_t PORT_ArenaAlloc(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  unsigned int v5;
  uint64_t result;
  _QWORD *ThreadErrInfo;
  int v8;

  if (a2 <= 1)
    v2 = 1;
  else
    v2 = a2;
  if (!(v2 >> 31))
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = (*(_QWORD *)(a1 + 48) + v2) & ~*(_QWORD *)(a1 + 48);
    result = *(_QWORD *)(v4 + 24);
    if (v5 >= v2)
    {
      if (v5 <= (unint64_t)(*(_QWORD *)(v4 + 16) - result))
      {
        *(_QWORD *)(v4 + 24) = v5 + result;
        if (result)
          return result;
      }
      else
      {
        result = PL_ArenaAllocate(a1, v5);
        if (result)
          return result;
      }
    }
  }
  ++port_allocFailures;
  ThreadErrInfo = PR_getThreadErrInfo(1, &v8);
  if (ThreadErrInfo)
    *ThreadErrInfo = 0xFFFFE01300000000;
  return 0;
}

unint64_t sec_asn1d_parse_leaf(uint64_t a1, char *__src, unint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  size_t v12;
  unint64_t v13;
  unint64_t v14;
  _QWORD *ThreadErrInfo;
  int v17;

  if (!a3)
  {
    v5 = 0;
    *(_DWORD *)(*(_QWORD *)a1 + 24) = 3;
    return v5;
  }
  v4 = *(_QWORD *)(a1 + 96);
  if (v4 >= a3)
    v5 = a3;
  else
    v5 = *(_QWORD *)(a1 + 96);
  v6 = *(unint64_t **)(a1 + 16);
  if (!v6)
    goto LABEL_30;
  v7 = v6[1];
  if (!v7)
    goto LABEL_30;
  v8 = __src;
  v9 = *(_QWORD *)(a1 + 80);
  v10 = *v6;
  if (v9 == 2)
  {
    if (v10)
      v11 = 0;
    else
      v11 = v5 >= 2;
    if (!v11)
    {
      v12 = v5;
      goto LABEL_25;
    }
    __src = &__src[v5 - 1];
    v12 = v5;
    while (!*v8)
    {
      ++v8;
      if (--v12 <= 1)
      {
        v12 = 1;
        goto LABEL_20;
      }
    }
    __src = v8;
  }
  else
  {
    v12 = v5;
  }
LABEL_20:
  if (v9 != 3)
  {
LABEL_25:
    v13 = v12;
    v14 = *v6;
    if (0xFFFFFFFF - v10 < v12)
    {
LABEL_26:
      ThreadErrInfo = PR_getThreadErrInfo(1, &v17);
      if (ThreadErrInfo)
        *ThreadErrInfo = 0xFFFFE00900000000;
      v5 = 0;
      *(_DWORD *)(*(_QWORD *)a1 + 24) = 1;
      return v5;
    }
    goto LABEL_29;
  }
  if ((v10 & 7) != 0)
    goto LABEL_26;
  if (v12 >> 61)
    goto LABEL_26;
  v13 = 8 * v12 - *(unsigned int *)(a1 + 116);
  if (0xFFFFFFFF - v10 < v13)
    goto LABEL_26;
  v14 = v10 >> 3;
LABEL_29:
  *v6 = v13 + v10;
  memcpy((void *)(v7 + v14), __src, v12);
  v4 = *(_QWORD *)(a1 + 96);
LABEL_30:
  *(_QWORD *)(a1 + 96) = v4 - v5;
  if (v4 == v5)
    *(_DWORD *)(a1 + 48) = 20;
  return v5;
}

uint64_t PL_ArenaAllocate(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t result;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  _QWORD *v11;
  _BOOL4 v12;
  BOOL v13;
  _QWORD *v14;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = (v2 + a2) & ~(_DWORD)v2;
  if (v3 < a2)
    return 0;
  v6 = *(_QWORD **)(a1 + 32);
  v7 = (v2 + a2) & ~(_DWORD)v2;
  do
  {
    result = v6[3];
    if (v7 <= v6[2] - result)
    {
      *(_QWORD *)(a1 + 32) = v6;
      v6[3] = result + v7;
      return result;
    }
    v6 = (_QWORD *)*v6;
  }
  while (v6);
  if (*(_DWORD *)(a1 + 40) > v3)
    v3 = *(_DWORD *)(a1 + 40);
  v8 = v2 + 32;
  if (v8 > ~v3)
    return 0;
  v9 = v3 + v8;
  if (v9 <= 1)
    v10 = 1;
  else
    v10 = v3 + v8;
  v11 = malloc_type_malloc(v10, 0x7C9B19FDuLL);
  result = ((unint64_t)v11 + *(_QWORD *)(a1 + 48) + 32) & ~*(_QWORD *)(a1 + 48);
  v12 = __CFADD__(result, v7);
  if (v11)
    v13 = !v12;
  else
    v13 = 1;
  if (!v13)
  {
    free(v11);
    return 0;
  }
  if (!v11)
    return 0;
  v11[2] = (char *)v11 + v9;
  v11[3] = result + v7;
  v14 = *(_QWORD **)(a1 + 32);
  *v11 = *v14;
  v11[1] = result;
  *v14 = v11;
  *(_QWORD *)(a1 + 32) = v11;
  if (!*(_QWORD *)a1)
    *(_QWORD *)a1 = v11;
  return result;
}

void sec_asn1d_record_any_header(uint64_t **a1, void *a2, unint64_t a3)
{
  uint64_t *v4;
  _QWORD *ThreadErrInfo;
  int v6;

  v4 = a1[2];
  if (v4 && v4[1])
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v6);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0xFFFFE00100000000;
    *((_DWORD *)*a1 + 6) = 1;
  }
  else
  {
    sec_asn1d_add_to_subitems(a1, a2, a3, 1);
  }
}

uint64_t nss_cms_choose_content_template(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;

  if (result)
  {
    v1 = result;
    result = *(_QWORD *)(result + 32);
    if (result || (result = SECOID_FindOID(v1), (*(_QWORD *)(v1 + 32) = result) != 0))
    {
      v2 = *(_DWORD *)(result + 16) - 25;
      if (v2 > 5)
        return 0;
      else
        return (uint64_t)*(&off_1E1FD1290 + v2);
    }
  }
  return result;
}

uint64_t SecCmsSignedDataSetDigestContext(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  unint64_t **v5;

  v4 = 0xAAAAAAAAAAAAAAAALL;
  v5 = (unint64_t **)0xAAAAAAAAAAAAAAAALL;
  if (SecCmsDigestContextFinishMultiple(a2, &v5, &v4))
    return PORT_GetError();
  result = SecCmsSignedDataSetDigests(a1, v5, v4);
  if ((_DWORD)result)
    return PORT_GetError();
  return result;
}

uint64_t SecCmsSignedDataSetDigests(_QWORD *a1, unint64_t **a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v9;
  int v10;
  _DWORD *ThreadErrInfo;
  uint64_t result;
  uint64_t *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  void *v20;
  void *v21;
  unint64_t *v22;
  uint64_t v23;
  unint64_t *v24;
  uint64_t v25;
  const void *v26;
  unint64_t v27;
  unint64_t v28;
  size_t v29;
  const void *v31;
  unint64_t v32;
  unint64_t v33;
  size_t v34;
  _QWORD *v36;
  uint64_t v37;
  int v38;

  if (a1)
  {
    v4 = (_QWORD *)a1[17];
    if (v4)
    {
      v5 = a1[3];
      if (v5)
      {
        v6 = *(_QWORD *)(v5 + 120);
        if (v6)
        {
          v9 = (_QWORD *)a1[21];
          if (v9)
          {
            if (*v9)
              return 0;
            goto LABEL_23;
          }
          if (*v4)
          {
            v13 = v4 + 1;
            v14 = -1;
            do
            {
              v15 = v14;
              v16 = *v13++;
              ++v14;
            }
            while (v16);
            if (v14 > 0xFFFFFFC)
            {
LABEL_53:
              v10 = -8173;
              goto LABEL_9;
            }
            v17 = v15 + 2;
          }
          else
          {
            v17 = 0;
          }
          v18 = 8 * (v17 + 1);
          if (v18 <= 1)
            v19 = 1;
          else
            v19 = v18;
          v20 = (void *)PORT_ArenaAlloc(v6, v19);
          if (v20)
          {
            v21 = v20;
            bzero(v20, v19);
            a1[21] = v21;
            v4 = (_QWORD *)a1[17];
LABEL_23:
            v22 = (unint64_t *)*v4;
            if (*v4)
            {
              v23 = 0;
              while (a2)
              {
                v24 = *a2;
                if (!*a2)
                  break;
                v37 = v23;
                v25 = 0;
                v27 = *v22;
                v26 = (const void *)v22[1];
                while (1)
                {
                  v28 = *v24;
                  v29 = *v24 >= v27 ? v27 : *v24;
                  if (!memcmp((const void *)v24[1], v26, v29) && v28 == v27)
                  {
                    v32 = v24[2];
                    v31 = (const void *)v24[3];
                    v33 = v22[2];
                    v34 = v32 >= v33 ? v22[2] : v32;
                    if (!memcmp(v31, (const void *)v22[3], v34) && v32 == v33)
                      break;
                  }
                  v24 = a2[++v25];
                  if (!v24)
                    goto LABEL_51;
                }
                v10 = -8059;
                if ((v25 & 0x80000000) != 0)
                  goto LABEL_9;
                v36 = SECITEM_AllocItem(*(_QWORD *)(a1[3] + 120), 0, 0);
                *(_QWORD *)(a1[21] + 8 * v37) = v36;
                if (!v36)
                  goto LABEL_53;
                result = SECITEM_CopyItem(*(_QWORD *)(a1[3] + 120), *(unint64_t **)(a1[21] + 8 * v37), *(_QWORD *)(a3 + 8 * v25));
                if ((_DWORD)result)
                  goto LABEL_53;
                v23 = v37 + 1;
                v22 = *(unint64_t **)(a1[17] + 8 * (v37 + 1));
                if (!v22)
                  return result;
              }
LABEL_51:
              v10 = -8059;
              goto LABEL_9;
            }
            return 0;
          }
          a1[21] = 0;
          goto LABEL_53;
        }
      }
    }
  }
  v10 = -8187;
LABEL_9:
  ThreadErrInfo = PR_getThreadErrInfo(1, &v38);
  if (ThreadErrInfo)
  {
    *ThreadErrInfo = 0;
    ThreadErrInfo[1] = v10;
  }
  return 0xFFFFFFFFLL;
}

_QWORD *SECITEM_AllocItem(uint64_t a1, _QWORD *a2, unint64_t a3)
{
  _QWORD *v4;
  uint64_t v6;
  uint64_t v7;

  v4 = a2;
  if (a1)
  {
    if (!a2)
    {
      v6 = PORT_ArenaAlloc(a1, 0x10uLL);
      v4 = (_QWORD *)v6;
      if (!v6)
        return v4;
      *(_QWORD *)(v6 + 8) = 0;
    }
    *v4 = a3;
    if (a3)
    {
      v7 = PORT_ArenaAlloc(a1, a3);
LABEL_11:
      v4[1] = v7;
    }
  }
  else if (a2 || (v4 = PORT_ZAlloc(0x10uLL)) != 0)
  {
    *v4 = a3;
    if (a3)
    {
      v7 = (uint64_t)PORT_Alloc(a3);
      goto LABEL_11;
    }
  }
  return v4;
}

uint64_t sec_asn1d_parent_allows_EOC(uint64_t result)
{
  int v1;
  BOOL v2;
  _BOOL4 v4;

  if (result)
  {
    while (1)
    {
      v1 = *(_DWORD *)(result + 48);
      v2 = (v1 - 16) < 4 || v1 == 24;
      if (!v2 && v1 != 11)
        break;
      result = *(_QWORD *)(result + 32);
      if (!result)
        return result;
    }
    v4 = (v1 & 0xFFFFFFFE) == 8 || *(_BYTE *)(*(_QWORD *)(result + 40) + 141) != 0;
    return *(_BYTE *)(result + 139) && v4;
  }
  return result;
}

void nss_cms_decoder_work_data(uint64_t a1, char *dataIn, size_t dataInLength, int a4)
{
  BOOL v4;
  char v6;
  size_t v8;
  char *v9;
  unsigned int v10;
  BOOL v11;
  int v12;
  uint64_t v14;
  uint64_t v15;
  unsigned int v17;
  int v18;
  unsigned int v19;
  size_t v20;
  char *v21;
  uint64_t v22;
  void (*v23)(_QWORD, char *, size_t);
  char *v24;
  char *v25;
  int v26;
  int Error;
  uint64_t OID;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;

  if (dataIn)
    v4 = dataInLength == 0;
  else
    v4 = 1;
  v6 = v4 && a4 == 0;
  if (!HIDWORD(dataInLength) && (v6 & 1) == 0 && *(_QWORD *)(a1 + 24))
  {
    v8 = dataInLength;
    v9 = dataIn;
    v10 = *(_DWORD *)(a1 + 16);
    v11 = v10 > 0x1E;
    v12 = (1 << v10) & 0x6C000000;
    if (v11 || v12 == 0)
      v14 = 0;
    else
      v14 = *(_QWORD *)(a1 + 24);
    v15 = *(_QWORD *)(v14 + 96);
    if (v15)
    {
      v33 = 0;
      v17 = *(_DWORD *)(v15 + 12);
      if (a4)
        v18 = *(_DWORD *)(v15 + 12);
      else
        v18 = 0;
      v19 = (dataInLength + v17 - 1) / v17;
      v20 = v18 + v19 * v17;
      if (!dataInLength && !(_DWORD)v20)
      {
        v9 = 0;
LABEL_46:
        v21 = v9;
        goto LABEL_47;
      }
      if ((_DWORD)v20)
      {
        v24 = (char *)PORT_Alloc(v18 + v19 * v17);
        if (!v24)
        {
          v9 = 0;
          Error = -8173;
          goto LABEL_45;
        }
        v25 = v24;
        v26 = SecCmsCipherContextCrypt(*(CCCryptorRef **)(v14 + 96), v24, &v33, v20, v9, v8, a4);
        v9 = v25;
        if (v26)
        {
LABEL_34:
          Error = PORT_GetError();
LABEL_45:
          *(_DWORD *)(a1 + 44) = Error;
          goto LABEL_46;
        }
      }
      else
      {
        v9 = 0;
        if (SecCmsCipherContextCrypt((CCCryptorRef *)v15, 0, &v33, 0, dataIn, dataInLength, a4))
          goto LABEL_34;
      }
      v8 = v33;
      v21 = v9;
      if (!v33)
      {
LABEL_47:
        if (v21)
          free(v21);
        return;
      }
    }
    else
    {
      v21 = 0;
      if (!dataInLength)
        goto LABEL_47;
    }
    v22 = *(_QWORD *)(v14 + 104);
    if (v22)
      SecCmsDigestContextUpdate(v22, v9, v8);
    v23 = *(void (**)(_QWORD, char *, size_t))(a1 + 48);
    if (v23)
    {
      v23(*(_QWORD *)(a1 + 56), v9, v8);
    }
    else
    {
      OID = *(_QWORD *)(v14 + 32);
      if (OID || (OID = SECOID_FindOID(v14), (*(_QWORD *)(v14 + 32) = OID) != 0))
      {
        if (*(_DWORD *)(OID + 16) == 25)
        {
          v29 = *(_QWORD *)(v14 + 16);
          v30 = *(_QWORD *)v29;
          if (v8 < 0x7FFFFFFFLL - *(_QWORD *)v29
            && ((v31 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 120), !v30)
              ? (v32 = PORT_ArenaAlloc(v31, v8))
              : (v32 = (uint64_t)PORT_ArenaGrow(v31, *(char **)(v29 + 8), *(_QWORD *)v29, v30 + v8)),
                v32))
          {
            *(_QWORD *)v29 += v8;
            *(_QWORD *)(v29 + 8) = v32;
            if (v9)
              memcpy((void *)(v32 + v30), v9, v8);
          }
          else
          {
            *(_DWORD *)(a1 + 44) = -8173;
          }
        }
      }
    }
    goto LABEL_47;
  }
}

void nss_cms_decoder_update_filter(uint64_t a1, char *a2, size_t a3, uint64_t a4, int a5)
{
  if (a3)
  {
    *(_BYTE *)(a1 + 40) = 1;
    if (a5 == 2)
      nss_cms_decoder_work_data(a1, a2, a3, 0);
  }
}

uint64_t SecCmsSignedDataDecodeAfterData(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unint64_t **v4;
  uint64_t v5;

  result = a1[13];
  if (result)
  {
    v3 = (_QWORD *)a1[2];
    if (v3 && *v3)
    {
      v4 = 0;
      v5 = 0;
      if (SecCmsDigestContextFinishMultiple(result, &v4, &v5)
        || SecCmsSignedDataSetDigests(a1, v4, v5))
      {
        return 0xFFFFFFFFLL;
      }
      result = a1[13];
    }
    SecCmsDigestContextCancel(result);
    result = 0;
    a1[13] = 0;
  }
  return result;
}

void *PORT_Alloc(size_t a1)
{
  void *result;
  _QWORD *ThreadErrInfo;
  int v3;

  if (a1 >> 31)
    goto LABEL_5;
  if (a1 <= 1)
    a1 = 1;
  result = malloc_type_malloc(a1, 0x7C9B19FDuLL);
  if (!result)
  {
LABEL_5:
    ++port_allocFailures;
    ThreadErrInfo = PR_getThreadErrInfo(1, &v3);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0xFFFFE01300000000;
    return 0;
  }
  return result;
}

BOOL __sec_protocol_options_add_transport_specific_application_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4;
  void *v5;

  if (a2)
  {
    if (!*(_QWORD *)(a2 + 48))
      *(_QWORD *)(a2 + 48) = xpc_array_create(0, 0);
    v4 = xpc_array_create(0, 0);
    if (v4)
    {
      v5 = v4;
      xpc_array_set_string(v4, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(a1 + 32));
      xpc_array_set_uint64(v5, 0xFFFFFFFFFFFFFFFFLL, *(unsigned int *)(a1 + 40));
      xpc_array_append_value(*(xpc_object_t *)(a2 + 48), v5);
      xpc_release(v5);
    }
  }
  return a2 != 0;
}

CFDataRef Security::CodeSigning::MachORep::copyDiskRepInformation(Security::CodeSigning::MachORep *this)
{
  off_t *v1;
  Security::MachOBase *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFDataRef v17;
  unsigned int v19;
  unsigned int v20[2];
  CFDataRef v21;

  v1 = (off_t *)(*(uint64_t (**)(Security::CodeSigning::MachORep *))(*(_QWORD *)this + 80))(this);
  v2 = (Security::MachOBase *)Security::Universal::architecture(v1);
  *(_QWORD *)v20 = 0;
  v21 = 0;
  v19 = 0;
  if ((Security::MachOBase::version(v2, &v20[1], v20, &v19) & 1) != 0)
  {
    v17 = Security::cfmake<__CFDictionary const*>((uint64_t)"{%O = %d,%O = %d,%O = %d}", v3, v4, v5, v6, v7, v8, v9, (uint64_t)CFSTR("VersionPlatform"));
    if (v21)
      CFRelease(v21);
    v21 = v17;
    if (v20[1] == 1 && v19 >> 8 <= 0xA08)
    {
      v17 = Security::cfmake<__CFDictionary const*>((uint64_t)"{+%O, %O = 'OS X SDK version before 10.9 does not support Library Validation'}", v10, v11, v12, v13, v14, v15, v16, (uint64_t)v17);
      if (v21)
        CFRelease(v21);
    }
  }
  else
  {
    v17 = v21;
  }
  v21 = 0;
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v21);
  (*(void (**)(Security::MachOBase *))(*(_QWORD *)v2 + 8))(v2);
  return v17;
}

void sub_18A918C94(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)(v2 - 24));
  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

unint64_t Security::MachOBase::version(Security::MachOBase *this, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  const load_command *Command;
  unsigned int cmd;
  int v10;
  unsigned int v11;
  const load_command *v12;
  int v13;
  unsigned int v14;
  unint64_t result;
  unsigned int cmdsize;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;

  Command = (const load_command *)*((_QWORD *)this + 2);
  if (Command)
  {
    do
    {
      cmd = Command->cmd;
      v10 = *((unsigned __int8 *)this + 33);
      v11 = bswap32(Command->cmd);
      if (*((_BYTE *)this + 33))
        cmd = v11;
      if (cmd == 50)
      {
        cmdsize = Command->cmdsize;
        v18 = bswap32(cmdsize);
        if (*((_BYTE *)this + 33))
          cmdsize = v18;
        if (cmdsize <= 0x17)
          goto LABEL_56;
        if (a2)
        {
          v19 = Command[1].cmd;
          v20 = bswap32(v19);
          if (*((_BYTE *)this + 33))
            v19 = v20;
          *a2 = v19;
        }
        if (a3)
        {
          v21 = Command[1].cmdsize;
          v22 = bswap32(v21);
          if (v10)
            v21 = v22;
          *a3 = v21;
        }
        if (a4)
        {
          v23 = Command[2].cmd;
          goto LABEL_51;
        }
        return 1;
      }
      Command = (const load_command *)Security::MachOBase::nextCommand(this, Command);
    }
    while (Command);
    v12 = (const load_command *)*((_QWORD *)this + 2);
    if (v12)
    {
      while (1)
      {
        v13 = v12->cmd;
        v10 = *((unsigned __int8 *)this + 33);
        v14 = bswap32(v12->cmd);
        if (*((_BYTE *)this + 33))
          v13 = v14;
        if (v13 <= 0x30 && ((1 << v13) & 0x1803000000000) != 0)
          break;
        result = Security::MachOBase::nextCommand(this, v12);
        v12 = (const load_command *)result;
        if (!result)
          return result;
      }
      v24 = v12->cmdsize;
      v25 = bswap32(v24);
      if (*((_BYTE *)this + 33))
        v24 = v25;
      if (v24 > 0xF)
      {
        if (v13 > 46)
        {
          if (v13 == 47)
          {
            v26 = 3;
          }
          else
          {
            if (v13 != 48)
              goto LABEL_42;
            v26 = 4;
          }
        }
        else if (v13 == 36)
        {
          v26 = 1;
        }
        else
        {
          if (v13 == 37)
          {
            v26 = 2;
            goto LABEL_43;
          }
LABEL_42:
          v26 = 0;
        }
LABEL_43:
        if (a2)
          *a2 = v26;
        if (a3)
        {
          v27 = v12[1].cmd;
          v28 = bswap32(v27);
          if (v10)
            v27 = v28;
          *a3 = v27;
        }
        if (a4)
        {
          v23 = v12[1].cmdsize;
LABEL_51:
          v29 = bswap32(v23);
          if (v10)
            v30 = v29;
          else
            v30 = v23;
          *a4 = v30;
        }
        return 1;
      }
LABEL_56:
      Security::UnixError::throwMe((Security::UnixError *)8);
    }
  }
  return 0;
}

CFDataRef Security::cfmake<__CFDictionary const*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t *v10;
  _QWORD v11[3];
  int v12;

  v10 = &a9;
  v11[0] = a1;
  v11[1] = &v10;
  v11[2] = 0;
  v12 = 0;
  return Security::CFMake::make((Security::CFMake *)v11);
}

__CFDictionary *Security::CFMake::add(Security::CFMake *this, __CFDictionary *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;
  const void *v7;

  while (Security::CFMunge::next(this) != 125)
  {
    v4 = Security::CFMake::make(this);
    if (!v4)
      return 0;
    v5 = (const void *)v4;
    if (Security::CFMunge::next(this) != 61
      || (++*(_QWORD *)this, (v6 = (const void *)Security::CFMake::make(this)) == 0))
    {
      CFRelease(v5);
      return 0;
    }
    v7 = v6;
    CFDictionaryAddValue(a2, v5, v6);
    CFRelease(v5);
    CFRelease(v7);
  }
  ++*(_QWORD *)this;
  return a2;
}

CFDataRef Security::CFMake::make(Security::CFMake *this)
{
  uint64_t v2;
  int v3;
  _QWORD **v4;
  _QWORD *v5;
  _DWORD **v6;
  _DWORD *v7;
  int v8;
  __CFArray *MutableCopy;
  char *v10;
  int v11;
  uint64_t v12;
  CFDictionaryRef **v13;
  CFDictionaryRef *v14;
  Security *v15;
  uint64_t v16;
  CFArrayRef **v17;
  CFArrayRef *v18;
  uint64_t v19;
  int v20;
  const UInt8 ***v21;
  const UInt8 **v22;
  const UInt8 *v23;
  CFIndex **v24;
  CFIndex *v25;
  unsigned int v27;
  const __CFAllocator *v29;
  CFNumberType v30;
  const void *v31;
  const void *v32;
  unsigned int **v33;
  unsigned int *v34;
  int v35;
  _DWORD **v36;
  _DWORD *v37;
  CFTypeRef **v38;
  CFTypeRef *v39;
  _DWORD **v40;
  _DWORD *v41;
  const __CFAllocator *v42;
  const char ***v43;
  const char **v44;
  double valuePtr;

  while (Security::CFMunge::next(this) == 64)
  {
    v2 = (*(_QWORD *)this)++;
    v3 = *(char *)(v2 + 1);
    if (v3 == 69)
    {
      *(_QWORD *)this = v2 + 2;
      v6 = (_DWORD **)*((_QWORD *)this + 1);
      v7 = *v6;
      *v6 += 2;
      *((_DWORD *)this + 6) = *v7;
    }
    else if (v3 == 65)
    {
      *(_QWORD *)this = v2 + 2;
      v4 = (_QWORD **)*((_QWORD *)this + 1);
      v5 = (*v4)++;
      *((_QWORD *)this + 2) = *v5;
    }
  }
  v8 = Security::CFMunge::next(this);
  MutableCopy = 0;
  if (v8 > 90)
  {
    if (v8 <= 122)
    {
      if (v8 != 91)
      {
        if (v8 == 93)
          return MutableCopy;
        goto LABEL_43;
      }
      ++*(_QWORD *)this;
      if (Security::CFMunge::next(this) == 33)
        ++*(_QWORD *)this;
      v15 = (Security *)Security::CFMunge::next(this);
      if ((_DWORD)v15 == 43)
      {
        ++*(_QWORD *)this;
        if (Security::CFMunge::next(this) != 37)
          return 0;
        ++*(_QWORD *)this;
        if (Security::CFMunge::next(this) != 79)
          return 0;
        v17 = (CFArrayRef **)*((_QWORD *)this + 1);
        ++*(_QWORD *)this;
        v18 = (*v17)++;
        MutableCopy = CFArrayCreateMutableCopy(*((CFAllocatorRef *)this + 2), 0, *v18);
        if (Security::CFMunge::next(this) != 125)
          goto LABEL_50;
      }
      else
      {
        MutableCopy = Security::makeCFMutableArray(v15, v16);
LABEL_50:
        while (Security::CFMunge::next(this) != 93)
        {
          v31 = (const void *)Security::CFMake::make(this);
          if (!v31)
            goto LABEL_60;
          v32 = v31;
          CFArrayAppendValue(MutableCopy, v31);
          CFRelease(v32);
        }
      }
LABEL_37:
      ++*(_QWORD *)this;
      return MutableCopy;
    }
    if (v8 == 125)
      return MutableCopy;
    if (v8 != 123)
      goto LABEL_43;
    ++*(_QWORD *)this;
    if (Security::CFMunge::next(this) == 33)
      ++*(_QWORD *)this;
    if (Security::CFMunge::next(this) == 43)
    {
      ++*(_QWORD *)this;
      if (Security::CFMunge::next(this) != 37)
        return 0;
      ++*(_QWORD *)this;
      if (Security::CFMunge::next(this) != 79)
        return 0;
      v13 = (CFDictionaryRef **)*((_QWORD *)this + 1);
      ++*(_QWORD *)this;
      v14 = (*v13)++;
      MutableCopy = CFDictionaryCreateMutableCopy(*((CFAllocatorRef *)this + 2), 0, *v14);
      if (Security::CFMunge::next(this) == 125)
        goto LABEL_37;
    }
    else
    {
      MutableCopy = CFDictionaryCreateMutable(*((CFAllocatorRef *)this + 2), 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
    if (!MutableCopy || Security::CFMake::add(this, MutableCopy))
      return MutableCopy;
LABEL_60:
    CFRelease(MutableCopy);
    return 0;
  }
  if (v8 <= 36)
  {
    if (!v8)
      return MutableCopy;
    if (v8 == 35)
    {
      MutableCopy = 0;
      v10 = *(char **)this;
      *(_QWORD *)this += 2;
      v11 = v10[1];
      if (v11 <= 83)
      {
        if (v11 != 70)
        {
          if (v11 == 78)
          {
            v12 = MEMORY[0x1E0C9B0D0];
            return *(CFDataRef *)v12;
          }
          return MutableCopy;
        }
      }
      else
      {
        if (v11 == 84)
        {
LABEL_14:
          v12 = MEMORY[0x1E0C9AE50];
          return *(CFDataRef *)v12;
        }
        if (v11 != 102)
        {
          if (v11 == 116)
            goto LABEL_14;
          return MutableCopy;
        }
      }
      v12 = MEMORY[0x1E0C9AE40];
      return *(CFDataRef *)v12;
    }
    goto LABEL_43;
  }
  if (v8 != 37)
  {
    if (v8 == 39)
      return (CFDataRef)Security::CFMake::makestring((CFAllocatorRef *)this);
LABEL_43:
    v27 = **(char **)this;
    if ((v27 & 0x80000000) != 0)
    {
      v35 = __maskrune(**(char **)this, 0x100uLL);
    }
    else
    {
      if (v27 == 45 || (*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v27 + 60) & 0x400) != 0)
      {
        valuePtr = strtod(*(const char **)this, (char **)this);
        v29 = (const __CFAllocator *)*((_QWORD *)this + 2);
        v30 = kCFNumberDoubleType;
        return CFNumberCreate(v29, v30, &valuePtr);
      }
      v35 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v27 + 60) & 0x100;
    }
    if (v35)
      return (CFDataRef)Security::CFMake::makestring((CFAllocatorRef *)this);
    return 0;
  }
  MutableCopy = 0;
  v19 = *(_QWORD *)this;
  *(_QWORD *)this += 2;
  v20 = *(char *)(v19 + 1);
  if (v20 <= 99)
  {
    if (v20 != 66)
    {
      if (v20 == 79)
      {
        v38 = (CFTypeRef **)*((_QWORD *)this + 1);
        v39 = (*v38)++;
        return (CFDataRef)CFRetain(*v39);
      }
      if (v20 == 98)
      {
        v21 = (const UInt8 ***)*((_QWORD *)this + 1);
        v22 = (*v21)++;
        v23 = *v22;
        v24 = (CFIndex **)*((_QWORD *)this + 1);
        v25 = (*v24)++;
        return CFDataCreate(*((CFAllocatorRef *)this + 2), v23, *v25);
      }
      return MutableCopy;
    }
    v36 = (_DWORD **)*((_QWORD *)this + 1);
    v37 = *v36;
    *v36 += 2;
    v12 = MEMORY[0x1E0C9AE50];
    if (!*v37)
      v12 = MEMORY[0x1E0C9AE40];
    return *(CFDataRef *)v12;
  }
  if (v20 == 100)
  {
    v40 = (_DWORD **)*((_QWORD *)this + 1);
    v41 = *v40;
    *v40 += 2;
    LODWORD(valuePtr) = *v41;
    v29 = 0;
    v30 = kCFNumberIntType;
    return CFNumberCreate(v29, v30, &valuePtr);
  }
  if (v20 != 115)
  {
    if (v20 != 117)
      return MutableCopy;
    v33 = (unsigned int **)*((_QWORD *)this + 1);
    v34 = *v33;
    *v33 += 2;
    *(_QWORD *)&valuePtr = *v34;
    v29 = 0;
    v30 = kCFNumberLongLongType;
    return CFNumberCreate(v29, v30, &valuePtr);
  }
  v43 = (const char ***)*((_QWORD *)this + 1);
  v42 = (const __CFAllocator *)*((_QWORD *)this + 2);
  v44 = (*v43)++;
  return (CFDataRef)CFStringCreateWithCString(v42, *v44, 0x8000100u);
}

uint64_t Security::CFMunge::next(Security::CFMunge *this)
{
  unsigned __int8 *v1;
  int v2;
  uint64_t v4;
  int v5;

  v1 = *(unsigned __int8 **)this;
  LOBYTE(v2) = **(_BYTE **)this;
  if ((_BYTE)v2)
  {
    v4 = MEMORY[0x1E0C80978];
    do
    {
      if ((v2 & 0x80) != 0)
      {
        v5 = __maskrune((char)v2, 0x4000uLL);
        v1 = *(unsigned __int8 **)this;
        if (!v5)
        {
LABEL_7:
          v2 = *v1;
          if (v2 != 44)
            return (char)v2;
        }
      }
      else if ((*(_DWORD *)(v4 + 4 * (char)v2 + 60) & 0x4000) == 0)
      {
        goto LABEL_7;
      }
      *(_QWORD *)this = v1 + 1;
      v2 = *++v1;
    }
    while (v2);
  }
  return (char)v2;
}

void Security::CodeSigning::SecStaticCode::~SecStaticCode(Security::CodeSigning::SecStaticCode *this)
{
  char *v1;

  Security::CodeSigning::SecStaticCode::~SecStaticCode(this);
  Security::SecCFObject::operator delete(v1);
}

{
  uint64_t v2;
  uint64_t v3;
  Security::CodeSigning::ResourceBuilder *v4;
  uint64_t i;

  *(_QWORD *)this = off_1E1FC8B50;
  CEReleaseManagedContext();
  free(*((void **)this + 64));
  v2 = *((_QWORD *)this + 25);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 73);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (Security::CodeSigning::ResourceBuilder *)*((_QWORD *)this + 2);
  if (v4)
  {
    Security::CodeSigning::ResourceBuilder::~ResourceBuilder(v4);
    MEMORY[0x18D76FAA0]();
  }
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 80);
  Security::CFRef<__CFArray const*>::~CFRef((const void **)this + 78);
  Security::CFRef<__SecTrust *>::~CFRef((const void **)this + 77);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)this + 71);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 69);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 67);
  Security::CFRef<__CFArray const*>::~CFRef((const void **)this + 66);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 65);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 63);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 62);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 61);
  for (i = 0; i != -96; i -= 8)
    Security::CFRef<__CFData const*>::~CFRef((const void **)((char *)this + i + 480));
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 46);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)this + 44));
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 42);
  Security::Dispatch::Queue::~Queue((Security::CodeSigning::SecStaticCode *)((char *)this + 224));
  Security::CFRef<__CFArray const*>::~CFRef((const void **)this + 21);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)this + 19));
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 17);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 16);
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*((const void ***)this + 14));
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((_QWORD *)this + 4);
}

void sub_18A919698(void *a1)
{
  uint64_t v1;
  uint64_t i;

  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)(v1 + 640));
  Security::CFRef<__CFArray const*>::~CFRef((const void **)(v1 + 624));
  Security::CFRef<__SecTrust *>::~CFRef((const void **)(v1 + 616));
  Security::CFRef<__CFURL const*>::~CFRef((const void **)(v1 + 568));
  Security::CFRef<__CFData const*>::~CFRef((const void **)(v1 + 552));
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)(v1 + 536));
  Security::CFRef<__CFArray const*>::~CFRef((const void **)(v1 + 528));
  Security::CFRef<__CFData const*>::~CFRef((const void **)(v1 + 520));
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)(v1 + 504));
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)(v1 + 496));
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)(v1 + 488));
  for (i = 0; i != -96; i -= 8)
    Security::CFRef<__CFData const*>::~CFRef((const void **)(v1 + 480 + i));
  Security::CFRef<__CFData const*>::~CFRef((const void **)(v1 + 368));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)(v1 + 352));
  Security::CFRef<__CFData const*>::~CFRef((const void **)(v1 + 336));
  Security::Dispatch::Queue::~Queue((Security::Dispatch::Queue *)(v1 + 224));
  Security::CFRef<__CFArray const*>::~CFRef((const void **)(v1 + 168));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)(v1 + 152));
  Security::CFRef<__CFData const*>::~CFRef((const void **)(v1 + 136));
  Security::CFRef<__CFData const*>::~CFRef((const void **)(v1 + 128));
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*(const void ***)(v1 + 112));
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((_QWORD *)(v1 + 32));
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18A919684);
}

const void **Security::CFRef<__CFDictionary const*>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(const void **a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*a1);
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(a1[1]);
    Security::CFRef<__CFData const*>::~CFRef(a1 + 5);
    operator delete(a1);
  }
}

const void **Security::CFRef<__CFArray const*>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void Security::Dispatch::Queue::~Queue(Security::Dispatch::Queue *this)
{
  *(_QWORD *)this = &off_1E1FC93C0;
  dispatch_barrier_sync(*((dispatch_queue_t *)this + 11), &__block_literal_global_13437);
  dispatch_release(*((dispatch_object_t *)this + 11));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)this + 10);
  Security::Mutex::~Mutex((pthread_mutex_t *)((char *)this + 8));
}

{
  Security::Dispatch::Queue::~Queue(this);
  JUMPOUT(0x18D76FAA0);
}

const void **Security::CFRef<__SecTrust *>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t Security::CodeSigning::SecStaticCode::entitlements(UInt8 *this)
{
  uint64_t v3;
  const __CFData *v4;
  Security::CodeSigning::CodeDirectory *v5;
  const UInt8 *BytePtr;
  unsigned int v7;
  const UInt8 *v9;
  NSObject *v10;
  _QWORD *v11;
  CFDataRef v12;
  NSObject *v13;
  unint64_t v14;
  const void *v15;
  CFIndex v16;
  CFIndex Length;
  NSObject *v18;
  NSObject *v19;
  unint64_t v20;
  uint8_t buf[4];
  UInt8 *v22;
  __int16 v23;
  CFIndex v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 62))
  {
    Security::CodeSigning::SecStaticCode::validateDirectory(this);
    v3 = (*(uint64_t (**)(UInt8 *, uint64_t, uint64_t))(*(_QWORD *)this + 80))(this, 7, 4294900235);
    if (v3)
    {
      v4 = (const __CFData *)v3;
      v5 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)this, 1);
      if (Security::CodeSigning::CodeDirectory::slotIsPresent(v5, -7))
        (*(void (**)(UInt8 *, uint64_t, uint64_t))(*(_QWORD *)this + 96))(this, 7, 4294900235);
      BytePtr = CFDataGetBytePtr(v4);
      v7 = bswap32(*((_DWORD *)BytePtr + 1));
      if (*(_DWORD *)BytePtr == 1920065274 && v7 > 7)
      {
        v9 = BytePtr;
        v10 = secLogObjForScope("staticCode");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          v16 = bswap32(*((_DWORD *)v9 + 1));
          *(_DWORD *)buf = 134218240;
          v22 = this;
          v23 = 2048;
          v24 = v16;
          _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, "%p loaded DER blob with length %zu", buf, 0x16u);
        }
        v11 = (_QWORD *)MEMORY[0x1E0DDFFA0];
        if (!*((_QWORD *)this + 68))
        {
          v12 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9 + 8, bswap32(*((_DWORD *)v9 + 1)) - 8, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
          v20 = (unint64_t)v12;
          v13 = secLogObjForScope("staticCode");
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            Length = CFDataGetLength(v12);
            *(_DWORD *)buf = 134218240;
            v22 = this;
            v23 = 2048;
            v24 = Length;
            _os_log_debug_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEBUG, "%p creating new CEQueryContext DER blob with length %lu", buf, 0x16u);
          }
          if (CEManagedContextFromCFData() != *v11)
          {
            *((_QWORD *)this + 68) = 0;
            v19 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 134217984;
              v22 = this;
              _os_log_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEFAULT, "%p caused an error during CoreEntitlements parsing", buf, 0xCu);
            }
            Security::MacOSError::throwMe((Security::MacOSError *)0xFFFF995DLL);
          }
          Security::CFRef<__CFData const*>::~CFRef((const void **)&v20);
        }
        v20 = 0xAAAAAAAAAAAAAAAALL;
        if (CEQueryContextToCFDictionary() != *v11)
        {
          v18 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v22 = this;
            _os_log_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEFAULT, "%p caused an error during CoreEntitlements dictionary generation", buf, 0xCu);
          }
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFF995DLL);
        }
        v14 = v20;
        v15 = (const void *)*((_QWORD *)this + 62);
        if (v15)
          CFRelease(v15);
        *((_QWORD *)this + 62) = v14;
      }
      else
      {
        *__error() = 22;
      }
    }
  }
  return *((_QWORD *)this + 62);
}

void sub_18A919BD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

_QWORD *Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(_QWORD *a1)
{
  pthread_mutex_t *v2;
  Security::UnixError *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  _QWORD v8[2];

  v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01;
  v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3)
    Security::UnixError::throwMe(v3);
  if (*a1)
  {
    v4 = (unsigned int *)(*a1 + 8);
    do
    {
      v5 = __ldxr(v4);
      v6 = v5 - 1;
    }
    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1)
        (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 8))(*a1);
      *a1 = 0;
    }
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

uint64_t *Security::Universal::architectures(uint64_t *this, uint64_t *a2)
{
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;

  v3 = this;
  if (this[1])
  {
    if (*((_DWORD *)this + 4))
    {
      v4 = 0;
      v5 = 0;
      do
      {
        this = std::__tree<Security::Architecture>::__emplace_unique_key_args<Security::Architecture,Security::Architecture>(a2, *(_QWORD *)(v3[1] + v4), *(_QWORD *)(v3[1] + v4));
        ++v5;
        v4 += 20;
      }
      while (v5 < *((unsigned int *)v3 + 4));
    }
  }
  else
  {
    v6 = Security::Universal::architecture(this);
    v7 = *(_QWORD *)(v6 + 8);
    v8 = *(_DWORD *)(v7 + 4);
    LODWORD(v7) = *(_DWORD *)(v7 + 8);
    v9 = bswap32(v8);
    if (*(_BYTE *)(v6 + 33))
      v10 = v9;
    else
      v10 = v8;
    v11 = bswap32(v7);
    if (*(_BYTE *)(v6 + 33))
      v7 = v11;
    else
      v7 = v7;
    std::__tree<Security::Architecture>::__emplace_unique_key_args<Security::Architecture,Security::Architecture>(a2, v10 | (v7 << 32), v10 | (v7 << 32));
    return (uint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  }
  return this;
}

void sub_18A919D4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t Security::Universal::architecture(off_t *this)
{
  const Security::Architecture *v2;
  uint64_t v4;
  unsigned int v5;
  char v6;

  if (this[1])
  {
    v2 = (const Security::Architecture *)Security::Universal::bestNativeArch((Security::Universal *)this);
    return Security::Universal::findImage((Security::Universal **)this, v2, SHIDWORD(v2));
  }
  else
  {
    v4 = operator new();
    v5 = *(_DWORD *)this;
    v6 = *((_BYTE *)this + 4);
    Security::MachO::MachO(v4, &v5, this[4], this[5]);
    return v4;
  }
}

void sub_18A919DF4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x10E1C40592D68B5);
  _Unwind_Resume(a1);
}

uint64_t Security::MachO::MachO(uint64_t a1, unsigned int *a2, off_t a3, uint64_t a4)
{
  off_t v4;
  timespec v7;
  unsigned int v8;
  unsigned int v9;
  size_t v10;
  void *v11;
  uint64_t v12;
  unint64_t Command;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  NSObject *v30;
  const char *v31;
  const char *v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  const char *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  NSObject *v44;
  NSObject *v45;
  const char *v47;
  int *v48;
  stat v49;
  uint64_t v50;

  v4 = a3;
  v50 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(a1 + 36) = *a2;
  *(_BYTE *)(a1 + 40) = *((_BYTE *)a2 + 4);
  *(_QWORD *)a1 = &off_1E1FC92E8;
  *(_QWORD *)(a1 + 48) = a3;
  *(_QWORD *)(a1 + 56) = a4;
  *(_BYTE *)(a1 + 104) = 0;
  if (!a3)
  {
    v7.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v7.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v49.st_blksize = v7;
    *(timespec *)v49.st_qspare = v7;
    v49.st_birthtimespec = v7;
    *(timespec *)&v49.st_size = v7;
    v49.st_mtimespec = v7;
    v49.st_ctimespec = v7;
    *(timespec *)&v49.st_uid = v7;
    v49.st_atimespec = v7;
    *(timespec *)&v49.st_dev = v7;
    Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*a2, &v49);
    *(_QWORD *)(a1 + 56) = v49.st_size;
    v4 = *(_QWORD *)(a1 + 48);
  }
  if (Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*a2, (void *)(a1 + 64), 0x1CuLL, v4) != 28)
    goto LABEL_65;
  Security::MachOBase::initHeader(a1, (const mach_header *)(a1 + 64));
  v8 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 20);
  v9 = bswap32(v8);
  if (*(_BYTE *)(a1 + 33))
    v10 = v9;
  else
    v10 = v8;
  v11 = malloc_type_malloc(v10, 0xFE326764uLL);
  *(_QWORD *)(a1 + 96) = v11;
  if (!v11)
  {
    v48 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v48);
  }
  v12 = 32;
  if (!*(_BYTE *)(a1 + 32))
    v12 = 28;
  if (Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*a2, v11, v10, v12 + *(_QWORD *)(a1 + 48)) != v10)goto LABEL_65;
  Security::MachOBase::initCommands(a1, *(const load_command **)(a1 + 96));
  if (!*(_QWORD *)(a1 + 56))
    return a1;
  Command = *(_QWORD *)(a1 + 16);
  if (!Command)
    goto LABEL_57;
  while (1)
  {
    v14 = *(_DWORD *)Command;
    v15 = *(unsigned __int8 *)(a1 + 33);
    v16 = bswap32(*(_DWORD *)Command);
    if (*(_BYTE *)(a1 + 33))
      v14 = v16;
    if (v14 == 1)
      break;
    if (v14 == 25)
    {
      v19 = *(_DWORD *)(Command + 4);
      v20 = bswap32(v19);
      if (*(_BYTE *)(a1 + 33))
        v19 = v20;
      if (v19 <= 0x47)
        goto LABEL_65;
      if (strncmp((const char *)(Command + 8), "__LINKEDIT", 0x10uLL))
        goto LABEL_28;
      v38 = *(_QWORD *)(Command + 40);
      v39 = *(_QWORD *)(Command + 48);
      v40 = bswap64(v38);
      if (v15)
        v38 = v40;
      v41 = bswap64(v39);
      if (v15)
        v39 = v41;
      v42 = v39 + v38;
      v43 = *(_QWORD *)(a1 + 56);
      v29 = v39 + v38 == v43;
      v44 = secLogObjForScope("macho");
      if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        goto LABEL_56;
      v47 = " NOT";
      if (v42 == v43)
        v47 = (const char *)&unk_18AA61AAF;
      v49.st_dev = 136315138;
      *(_QWORD *)&v49.st_mode = v47;
      _os_log_debug_impl(&dword_18A900000, v44, OS_LOG_TYPE_DEBUG, "64-bit linkedit is%s valid", (uint8_t *)&v49, 0xCu);
      if (v42 == v43)
        return a1;
      goto LABEL_57;
    }
    if (v14 == 2)
    {
      v21 = *(_DWORD *)(Command + 4);
      v22 = bswap32(v21);
      if (*(_BYTE *)(a1 + 33))
        v21 = v22;
      if (v21 > 0x17)
      {
        v23 = *(_DWORD *)(Command + 16);
        v24 = *(_DWORD *)(Command + 20);
        v25 = bswap32(v23);
        if (*(_BYTE *)(a1 + 33))
          v23 = v25;
        v26 = bswap32(v24);
        if (*(_BYTE *)(a1 + 33))
          v24 = v26;
        v27 = v24 + v23;
        v28 = *(_QWORD *)(a1 + 56);
        v29 = v28 == v27;
        v30 = secLogObjForScope("macho");
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          v31 = " NOT";
          if (v28 == v27)
            v31 = (const char *)&unk_18AA61AAF;
          v49.st_dev = 136315138;
          *(_QWORD *)&v49.st_mode = v31;
          v32 = "symtab is%s valid";
          goto LABEL_49;
        }
LABEL_56:
        if (v29)
          return a1;
        goto LABEL_57;
      }
LABEL_65:
      Security::UnixError::throwMe((Security::UnixError *)8);
    }
LABEL_28:
    Command = Security::MachOBase::nextCommand((Security::MachOBase *)a1, (const load_command *)Command);
    if (!Command)
      goto LABEL_57;
  }
  v17 = *(_DWORD *)(Command + 4);
  v18 = bswap32(v17);
  if (*(_BYTE *)(a1 + 33))
    v17 = v18;
  if (v17 <= 0x37)
    goto LABEL_65;
  if (strncmp((const char *)(Command + 8), "__LINKEDIT", 0x10uLL))
    goto LABEL_28;
  v33 = *(_DWORD *)(Command + 32);
  v34 = *(_DWORD *)(Command + 36);
  v35 = bswap32(v33);
  if (v15)
    v33 = v35;
  v36 = bswap32(v34);
  if (v15)
    v34 = v36;
  v27 = v34 + v33;
  v28 = *(_QWORD *)(a1 + 56);
  v29 = v28 == v27;
  v30 = secLogObjForScope("macho");
  if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    goto LABEL_56;
  v37 = " NOT";
  if (v28 == v27)
    v37 = (const char *)&unk_18AA61AAF;
  v49.st_dev = 136315138;
  *(_QWORD *)&v49.st_mode = v37;
  v32 = "32-bit linkedit is%s valid";
LABEL_49:
  _os_log_debug_impl(&dword_18A900000, v30, OS_LOG_TYPE_DEBUG, v32, (uint8_t *)&v49, 0xCu);
  if (v28 != v27)
  {
LABEL_57:
    v45 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v49.st_dev) = 0;
      _os_log_impl(&dword_18A900000, v45, OS_LOG_TYPE_DEFAULT, "STRICT VALIDATION ERROR: invalid structure", (uint8_t *)&v49, 2u);
    }
    *(_BYTE *)(a1 + 104) = 1;
  }
  return a1;
}

ssize_t Security::UnixPlusPlus::FileDesc::read(Security::UnixPlusPlus::FileDesc *this, void *a2, size_t a3, off_t a4)
{
  ssize_t result;
  int *v5;

  result = pread((int)this, a2, a3, a4);
  if (result == -1)
  {
    v5 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v5);
  }
  return result;
}

uint64_t Security::UnixPlusPlus::FileDesc::fstat(Security::UnixPlusPlus::FileDesc *this, stat *a2)
{
  uint64_t result;
  int *v3;

  result = fstat((int)this, a2);
  if ((_DWORD)result)
  {
    v3 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v3);
  }
  return result;
}

void __securityd_create_connection_block_invoke(int a1, xpc_object_t xdict)
{
  const char *string;
  NSObject *v3;
  int v4;
  const char *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  string = xpc_dictionary_get_string(xdict, (const char *)*MEMORY[0x1E0C81270]);
  v3 = secLogObjForScope("xpc");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    v4 = 136315138;
    v5 = string;
    _os_log_debug_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEBUG, "got event: %s", (uint8_t *)&v4, 0xCu);
  }
}

CFDataRef Security::CodeSigning::CodeDirectory::cdhash(Security::CodeSigning::CodeDirectory *this, int a2)
{
  __int128 v4;
  Security::CCHashInstance *v5;
  unsigned int *v6;
  unsigned int v7;
  size_t v8;
  const UInt8 *v9;
  uint64_t (*v10)(void);
  unint64_t v11;
  CFIndex v12;
  CFDataRef v13;
  void *__p[3];
  _OWORD v16[4];
  unint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v17 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[2] = v4;
  v16[3] = v4;
  v16[0] = v4;
  v16[1] = v4;
  v5 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)*((unsigned __int8 *)this
                                                                                             + 37));
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)v16 + 8));
  v6 = (unsigned int *)((char *)v5 + 8);
  do
    v7 = __ldxr(v6);
  while (__stxr(v7 + 1, v6));
  *(_QWORD *)&v16[0] = v5;
  memset(__p, 170, sizeof(__p));
  v8 = (*(uint64_t (**)(Security::CCHashInstance *))(*(_QWORD *)v5 + 16))(v5);
  std::vector<unsigned char>::vector(__p, v8);
  (*(void (**)(_QWORD, Security::CodeSigning::CodeDirectory *, _QWORD))(**(_QWORD **)&v16[0] + 24))(*(_QWORD *)&v16[0], this, bswap32(*((_DWORD *)this + 1)));
  (*(void (**)(_QWORD, void *))(**(_QWORD **)&v16[0] + 32))(*(_QWORD *)&v16[0], __p[0]);
  v9 = (const UInt8 *)__p[0];
  v10 = *(uint64_t (**)(void))(**(_QWORD **)&v16[0] + 16);
  if (a2)
  {
    v11 = v10();
    if (v11 >= 0x14)
      v12 = 20;
    else
      v12 = v11;
  }
  else
  {
    v12 = v10();
  }
  v13 = CFDataCreate(0, v9, v12);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  Security::RefPointer<Security::DynamicHash>::~RefPointer(v16);
  return v13;
}

void sub_18A91A4C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  Security::RefPointer<Security::DynamicHash>::~RefPointer(&a13);
  _Unwind_Resume(a1);
}

BOOL Security::CodeSigning::CodeDirectory::validateSlot(Security::CodeSigning::CodeDirectory *this, const void *a2, uint64_t a3, int a4)
{
  NSObject *v8;
  __int128 v9;
  Security::CCHashInstance *v10;
  unsigned int *v11;
  unsigned int v12;
  size_t v13;
  uint64_t v14;
  void *v15;
  const void *v16;
  int v17;
  size_t v18;
  int v19;
  void *__p[3];
  _BYTE buf[32];
  __int128 v23;
  __int128 v24;
  unint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v8 = secLogObjForScope("codedir");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = this;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a4;
    _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%p validating slot %d", buf, 0x12u);
  }
  v25 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23 = v9;
  v24 = v9;
  *(_OWORD *)buf = v9;
  *(_OWORD *)&buf[16] = v9;
  v10 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)*((unsigned __int8 *)this
                                                                                              + 37));
  Security::Mutex::Mutex((pthread_mutex_t *)&buf[8]);
  v11 = (unsigned int *)((char *)v10 + 8);
  do
    v12 = __ldxr(v11);
  while (__stxr(v12 + 1, v11));
  *(_QWORD *)buf = v10;
  memset(__p, 170, sizeof(__p));
  v13 = (*(uint64_t (**)(Security::CCHashInstance *))(*(_QWORD *)v10 + 16))(v10);
  std::vector<unsigned char>::vector(__p, v13);
  v14 = *(_QWORD *)buf;
  v15 = __p[0];
  (*(void (**)(_QWORD, const void *, uint64_t))(**(_QWORD **)buf + 24))(*(_QWORD *)buf, a2, a3);
  (*(void (**)(uint64_t, void *))(*(_QWORD *)v14 + 32))(v14, v15);
  v16 = __p[0];
  LODWORD(v14) = *((_DWORD *)this + 4);
  v17 = *((unsigned __int8 *)this + 36);
  v18 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)buf + 16))(*(_QWORD *)buf);
  v19 = memcmp(v16, (char *)this + bswap32(v14) + v17 * (uint64_t)a4, v18);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  Security::RefPointer<Security::DynamicHash>::~RefPointer(buf);
  return v19 == 0;
}

void sub_18A91A6C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13)
{
  Security::RefPointer<Security::DynamicHash>::~RefPointer(&a13);
  _Unwind_Resume(a1);
}

const void *secLogObjForScope(const char *a1)
{
  const __CFString *v2;
  const void *v3;

  pthread_mutex_lock(&loggingMutex);
  pthread_mutex_unlock(&loggingMutex);
  if (!a1)
    return secLogObjForCFScope(0);
  v2 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x600u);
  v3 = secLogObjForCFScope(v2);
  if (v2)
    CFRelease(v2);
  return v3;
}

const void *secLogObjForCFScope(const __CFString *a1)
{
  const __CFString *v1;
  const __CFDictionary *Mutable;
  const void *Value;
  _QWORD v5[5];
  _QWORD v6[5];

  if (a1)
    v1 = a1;
  else
    v1 = CFSTR("logging");
  os_unfair_lock_lock_with_options();
  Mutable = (const __CFDictionary *)secLogObjForCFScope_scopeMap;
  if (!secLogObjForCFScope_scopeMap)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9AEB8], 0);
    secLogObjForCFScope_scopeMap = (uint64_t)Mutable;
  }
  Value = CFDictionaryGetValue(Mutable, v1);
  if (!Value)
  {
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 0x40000000;
    v5[2] = __secLogObjForCFScope_block_invoke;
    v5[3] = &__block_descriptor_tmp_19_12735;
    v5[4] = v1;
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __CFStringPerformWithCString_block_invoke;
    v6[3] = &unk_1E1FDBF70;
    v6[4] = v5;
    CFStringPerformWithCStringAndLength(v1, (uint64_t)v6);
    Value = CFDictionaryGetValue((CFDictionaryRef)secLogObjForCFScope_scopeMap, v1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&secLogObjForCFScope_lock);
  return Value;
}

uint64_t Security::CCHashInstance::digestLength(Security::CCHashInstance *this)
{
  if (*((_QWORD *)this + 3))
    return *((_QWORD *)this + 3);
  else
    return CCDigestOutputSize();
}

pthread_mutex_t *Security::Mutex::Mutex(pthread_mutex_t *this)
{
  Security::UnixError *v2;

  v2 = (Security::UnixError *)pthread_mutex_init(this, 0);
  if ((_DWORD)v2)
    Security::UnixError::throwMe(v2);
  return this;
}

_QWORD *Security::RefPointer<Security::DynamicHash>::~RefPointer(_QWORD *a1)
{
  pthread_mutex_t *v2;
  Security::UnixError *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  _QWORD v8[2];

  v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01;
  v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3)
    Security::UnixError::throwMe(v3);
  if (*a1)
  {
    v4 = (unsigned int *)(*a1 + 8);
    do
    {
      v5 = __ldxr(v4);
      v6 = v5 - 1;
    }
    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1)
        (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 8))(*a1);
      *a1 = 0;
    }
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

void Security::Mutex::~Mutex(pthread_mutex_t *this)
{
  int v1;
  NSObject *v2;
  unsigned int v3;
  Security::UnixError *v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  v1 = pthread_mutex_destroy(this);
  if (v1)
  {
    v3 = v1;
    v2 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v4) = 67109120;
      HIDWORD(v4) = v3;
      _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "Probable bug: error destroying Mutex: %d", (uint8_t *)&v4, 8u);
    }
    Security::UnixError::throwMe((Security::UnixError *)v3);
  }
}

void sub_18A91AA14(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  __clang_call_terminate(a1);
}

uint64_t Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock(uint64_t a1)
{
  Security::UnixError *v2;

  if (*(_BYTE *)(a1 + 8))
  {
    v2 = (Security::UnixError *)pthread_mutex_unlock(*(pthread_mutex_t **)a1);
    if ((_DWORD)v2)
      Security::UnixError::throwMe(v2);
  }
  return a1;
}

_QWORD *std::vector<unsigned char>::vector(_QWORD *a1, size_t __sz)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (__sz)
  {
    if ((__sz & 0x8000000000000000) != 0)
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    v4 = (char *)operator new(__sz);
    *a1 = v4;
    v5 = &v4[__sz];
    a1[2] = &v4[__sz];
    bzero(v4, __sz);
    a1[1] = v5;
  }
  return a1;
}

void sub_18A91AAC4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Security::CCHashInstance::update(Security::CCHashInstance *this, const void *a2)
{
  return CCDigestUpdate();
}

void *Security::CCHashInstance::finish(Security::CCHashInstance *this, unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t v5;
  size_t v6;
  char *v7;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 3))
    return (void *)CCDigestFinal();
  v4 = CCDigestOutputSize();
  v5 = MEMORY[0x1E0C80A78](v4);
  v7 = (char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v5)
    memset((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), 170, v6);
  CCDigestFinal();
  return memcpy(a2, v7, *((_QWORD *)this + 3));
}

Security::CCHashInstance *Security::CodeSigning::CodeDirectory::hashFor(Security::CodeSigning::CodeDirectory *this)
{
  Security::CCHashInstance *v1;

  switch((int)this)
  {
    case 1:
      v1 = (Security::CCHashInstance *)operator new();
      Security::CCHashInstance::CCHashInstance(v1, 8u, 0);
      break;
    case 2:
      v1 = (Security::CCHashInstance *)operator new();
      Security::CCHashInstance::CCHashInstance(v1, 0xAu, 0);
      break;
    case 3:
      v1 = (Security::CCHashInstance *)operator new();
      Security::CCHashInstance::CCHashInstance(v1, 0xAu, 20);
      break;
    case 4:
      v1 = (Security::CCHashInstance *)operator new();
      Security::CCHashInstance::CCHashInstance(v1, 0xBu, 0);
      break;
    default:
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0DLL);
  }
  return v1;
}

void sub_18A91ACD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x10A1C40F954CD6DLL);
  _Unwind_Resume(a1);
}

Security::CCHashInstance *Security::CCHashInstance::CCHashInstance(Security::CCHashInstance *this, unsigned int a2, uint64_t a3)
{
  uint64_t v5;

  *((_DWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_1E1FC9220;
  v5 = CCDigestCreate();
  *((_QWORD *)this + 2) = v5;
  if (!v5)
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  *((_QWORD *)this + 3) = a3;
  return this;
}

void Security::CCHashInstance::~CCHashInstance(Security::CCHashInstance *this)
{
  Security::CCHashInstance::~CCHashInstance(this);
  JUMPOUT(0x18D76FAA0);
}

{
  *(_QWORD *)this = &off_1E1FC9220;
  CCDigestDestroy();
}

uint64_t Security::MachOBase::initHeader(uint64_t this, const mach_header *a2)
{
  uint32_t magic;
  char v3;
  char v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  uint8_t buf[4];
  uint64_t v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(this + 8) = a2;
  magic = a2->magic;
  if ((int)a2->magic > -17958195)
  {
    if (magic == -17958194)
    {
      v3 = 0;
      v4 = 0;
      goto LABEL_11;
    }
    if (magic == -17958193)
    {
      v3 = 0;
      goto LABEL_8;
    }
LABEL_12:
    v7 = this;
    v5 = secLogObjForScope("macho");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v6 = **(_DWORD **)(v7 + 8);
      *(_DWORD *)buf = 134218240;
      v9 = v7;
      v10 = 1024;
      v11 = v6;
      _os_log_debug_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEBUG, "%p: unrecognized header magic (%x)", buf, 0x12u);
    }
    Security::UnixError::throwMe((Security::UnixError *)8);
  }
  if (magic == -822415874)
  {
    v4 = 0;
    v3 = 1;
    goto LABEL_11;
  }
  if (magic != -805638658)
    goto LABEL_12;
  v3 = 1;
LABEL_8:
  v4 = 1;
LABEL_11:
  *(_BYTE *)(this + 33) = v3;
  *(_BYTE *)(this + 32) = v4;
  return this;
}

BOOL SecXPCDictionarySetString(uint64_t a1, uint64_t a2, const __CFString *a3, __CFString **a4)
{
  uint64_t v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;
  _QWORD v11[5];

  if (!a3)
    return SecError(-50, a4, CFSTR("string for key %s is NULL"), a2);
  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 1;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __SecXPCDictionarySetString_block_invoke;
  v6[3] = &unk_1E1FDBA18;
  v6[4] = &v7;
  v6[5] = a1;
  v6[6] = a2;
  v6[7] = a4;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = __CFStringPerformWithCString_block_invoke;
  v11[3] = &unk_1E1FDBF70;
  v11[4] = v6;
  CFStringPerformWithCStringAndLength(a3, (uint64_t)v11);
  v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void CFStringPerformWithCStringAndLength(const __CFString *a1, uint64_t a2)
{
  const char *CStringPtr;
  const char *v5;
  size_t v6;
  CFIndex Length;
  _QWORD v8[9];
  CFIndex usedBufLen;
  CFRange v10;

  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    v5 = CStringPtr;
    v6 = strlen(CStringPtr);
    (*(void (**)(uint64_t, const char *, size_t))(a2 + 16))(a2, v5, v6);
  }
  else
  {
    usedBufLen = 0;
    Length = CFStringGetLength(a1);
    v10.location = 0;
    v10.length = Length;
    CFStringGetBytes(a1, v10, 0x8000100u, 0, 0, 0, 0, &usedBufLen);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __CFStringPerformWithCStringAndLength_block_invoke;
    v8[3] = &unk_1E1FDBF48;
    v8[6] = 0;
    v8[7] = Length;
    v8[8] = usedBufLen;
    v8[4] = a2;
    v8[5] = a1;
    PerformWithBuffer(usedBufLen + 1, (uint64_t)v8);
  }
}

void __secLogObjForCFScope_block_invoke(uint64_t a1, const char *a2)
{
  __CFDictionary *v2;
  const void *v3;
  os_log_t v4;

  v2 = (__CFDictionary *)secLogObjForCFScope_scopeMap;
  v3 = *(const void **)(a1 + 32);
  v4 = os_log_create("com.apple.securityd", a2);
  CFDictionaryAddValue(v2, v3, v4);
}

uint64_t *std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>(uint64_t **a1, uint64_t *a2, unsigned int a3, int a4)
{
  uint64_t *v5;
  uint64_t **v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  void **v12;
  void **v13;
  uint64_t **v14;
  void **v15;
  uint64_t *v16;
  BOOL v17;
  uint64_t *v18;
  unsigned int v19;
  void **v20;
  uint64_t *v21;
  unsigned int v22;

  v5 = a2;
  v7 = a1 + 1;
  if (a1 + 1 == (uint64_t **)a2 || (v8 = *((_DWORD *)a2 + 7), v8 > a3))
  {
    v9 = *a2;
    if (*a1 == a2)
    {
      v11 = a2;
LABEL_16:
      if (v9)
        v14 = (uint64_t **)v11;
      else
        v14 = (uint64_t **)a2;
      if (v9)
        v12 = (void **)(v11 + 1);
      else
        v12 = (void **)a2;
      goto LABEL_22;
    }
    if (v9)
    {
      v10 = (uint64_t *)*a2;
      do
      {
        v11 = v10;
        v10 = (uint64_t *)v10[1];
      }
      while (v10);
    }
    else
    {
      v16 = a2;
      do
      {
        v11 = (uint64_t *)v16[2];
        v17 = *v11 == (_QWORD)v16;
        v16 = v11;
      }
      while (v17);
    }
    if (*((_DWORD *)v11 + 7) < a3)
      goto LABEL_16;
    v18 = *v7;
    if (*v7)
    {
      while (1)
      {
        while (1)
        {
          v14 = (uint64_t **)v18;
          v19 = *((_DWORD *)v18 + 7);
          if (v19 <= a3)
            break;
          v18 = *v14;
          v7 = v14;
          if (!*v14)
            goto LABEL_44;
        }
        if (v19 >= a3)
          break;
        v7 = v14 + 1;
        v18 = v14[1];
        if (!v18)
          goto LABEL_44;
      }
LABEL_46:
      v12 = (void **)v7;
      goto LABEL_22;
    }
    goto LABEL_43;
  }
  if (v8 >= a3)
    return v5;
  v12 = (void **)(a2 + 1);
  v13 = (void **)a2[1];
  if (v13)
  {
    do
    {
      v12 = v13;
      v13 = (void **)*v13;
      v14 = (uint64_t **)v12;
      v15 = v12;
    }
    while (v13);
  }
  else
  {
    v15 = (void **)a2;
    do
    {
      v20 = v15;
      v15 = (void **)v15[2];
    }
    while (*v15 != v20);
    v14 = (uint64_t **)a2;
  }
  if (v15 != (void **)v7 && *((_DWORD *)v15 + 7) <= a3)
  {
    v21 = *v7;
    if (*v7)
    {
      while (1)
      {
        while (1)
        {
          v14 = (uint64_t **)v21;
          v22 = *((_DWORD *)v21 + 7);
          if (v22 <= a3)
            break;
          v21 = *v14;
          v7 = v14;
          if (!*v14)
            goto LABEL_44;
        }
        if (v22 >= a3)
          goto LABEL_46;
        v7 = v14 + 1;
        v21 = v14[1];
        if (!v21)
          goto LABEL_44;
      }
    }
LABEL_43:
    v14 = a1 + 1;
LABEL_44:
    v5 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v5 + 7) = a4;
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(a1, (uint64_t)v14, v7, v5);
    return v5;
  }
LABEL_22:
  v5 = (uint64_t *)*v12;
  v7 = (uint64_t **)v12;
  if (!*v12)
    goto LABEL_44;
  return v5;
}

_QWORD *Security::CodeSigning::SecStaticCode::codeDirectories(Security::CodeSigning::SecStaticCode *this, int a2)
{
  char *v2;
  _QWORD *v3;
  uint64_t v6;
  BOOL v7;
  BOOL v8;
  uint64_t *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  __int128 v17;
  uint64_t *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD v29[2];
  BOOL (*v30)(_QWORD *, int);
  void *v31;
  uint64_t *v32;
  uint64_t *v33;
  uint64_t *v34;
  Security::CodeSigning::SecStaticCode *v35;
  uint64_t v36;
  CFTypeRef *v37;
  uint64_t v38;
  uint64_t (*v39)(uint64_t, uint64_t);
  const void **(*v40)(uint64_t);
  const void *v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  _QWORD *(*v45)(_QWORD *, _QWORD *);
  void (*v46)(uint64_t);
  _QWORD **v47;
  _QWORD *v48[2];
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  _QWORD *(*v52)(_QWORD *, _QWORD *);
  void (*v53)(uint64_t);
  const void ***v54;
  const void **v55[2];

  v2 = (char *)this + 104;
  v3 = (_QWORD *)((char *)this + 104);
  if (!*((_QWORD *)this + 15))
  {
    v49 = 0;
    v50 = &v49;
    v51 = 0x4002000000;
    v52 = __Block_byref_object_copy__14246;
    v53 = __Block_byref_object_dispose__14247;
    v55[0] = 0;
    v55[1] = 0;
    v54 = v55;
    v42 = 0;
    v43 = &v42;
    v44 = 0x4002000000;
    v45 = __Block_byref_object_copy__13;
    v46 = __Block_byref_object_dispose__14;
    v48[0] = 0;
    v48[1] = 0;
    v47 = v48;
    v36 = 0;
    v37 = (CFTypeRef *)&v36;
    v38 = 0x3002000000;
    v39 = __Block_byref_object_copy__15;
    v40 = __Block_byref_object_dispose__16;
    v41 = 0;
    v29[0] = MEMORY[0x1E0C809B0];
    v29[1] = 0x40000000;
    v30 = ___ZNK8Security11CodeSigning13SecStaticCode19loadCodeDirectoriesERNSt3__13mapIjNS_9CFCopyRefIPK8__CFDataEENS2_4lessIjEENS2_9allocatorINS2_4pairIKjS8_EEEEEE_block_invoke;
    v31 = &unk_1E1FDC870;
    v32 = &v49;
    v33 = &v42;
    v34 = &v36;
    v35 = this;
    if (___ZNK8Security11CodeSigning13SecStaticCode19loadCodeDirectoriesERNSt3__13mapIjNS_9CFCopyRefIPK8__CFDataEENS2_4lessIjEENS2_9allocatorINS2_4pairIKjS8_EEEEEE_block_invoke(v29, 0))
    {
      v6 = 4096;
      do
      {
        v7 = v30(v29, v6);
        v8 = (_DWORD)v6 == 4100;
        v6 = (v6 + 1);
      }
      while (!v8 && v7);
      v10 = v50;
      if (!v50[7])
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0BLL);
      v11 = v50 + 5;
      v12 = *((_QWORD *)this + 13);
      *((_QWORD *)this + 13) = v50[5];
      v10[5] = v12;
      v15 = *((_QWORD *)this + 14);
      v14 = *((_QWORD *)this + 15);
      v13 = (_QWORD *)((char *)this + 112);
      v17 = *((_OWORD *)v10 + 3);
      v16 = v10 + 6;
      *((_OWORD *)this + 7) = v17;
      *v16 = v15;
      v16[1] = v14;
      if (*((_QWORD *)this + 15))
        v3 = (_QWORD *)(*v13 + 16);
      *v3 = v13;
      if (v14)
        v11 = (_QWORD *)(*v16 + 16);
      *v11 = v16;
      v18 = v43;
      v19 = v43 + 5;
      v20 = *((_QWORD *)this + 43);
      *((_QWORD *)this + 43) = v43[5];
      *v19 = v20;
      v21 = (_QWORD *)((char *)this + 352);
      v23 = *((_OWORD *)v18 + 3);
      v22 = v18 + 6;
      v25 = *((_QWORD *)this + 44);
      v24 = *((_QWORD *)this + 45);
      *((_OWORD *)this + 22) = v23;
      *v22 = v25;
      v22[1] = v24;
      if (*((_QWORD *)this + 45))
        v26 = (_QWORD *)(*v21 + 16);
      else
        v26 = (_QWORD *)((char *)this + 344);
      *v26 = v21;
      if (v24)
        v19 = (_QWORD *)(*v22 + 16);
      *v19 = v22;
      Security::CFRef<__CFData const*>::operator=((CFTypeRef *)this + 16, v37 + 5);
    }
    _Block_object_dispose(&v36, 8);
    Security::CFRef<__CFData const*>::~CFRef(&v41);
    _Block_object_dispose(&v42, 8);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v48[0]);
    _Block_object_dispose(&v49, 8);
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(v55[0]);
    v27 = *((_QWORD *)this + 15);
    if (v27)
      v3 = v2;
    else
      v3 = 0;
    if (!v27 && a2)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ALL);
  }
  return v3;
}

void sub_18A91B630()
{
  __break(1u);
}

void sub_18A91B6C4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

BOOL ___ZNK8Security11CodeSigning13SecStaticCode19loadCodeDirectoriesERNSt3__13mapIjNS_9CFCopyRefIPK8__CFDataEENS2_4lessIjEENS2_9allocatorINS2_4pairIKjS8_EEEEEE_block_invoke(_QWORD *a1, int a2)
{
  const __CFData *v4;
  const __CFData *v5;
  const UInt8 *BytePtr;
  unint64_t Length;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  NSObject *v11;
  _BOOL4 v12;
  unsigned int v13;
  _BOOL4 v14;
  unsigned int v15;
  unint64_t v16;
  UInt8 *v17;
  unsigned int v19;
  unsigned int v20;
  UInt8 *v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v29;
  BOOL v30;
  unint64_t v31;
  unsigned int v33;
  uint64_t v34;
  unsigned int *v35;
  int v36;
  uint64_t v37;
  int v38;
  const UInt8 *v39;
  int v40;
  uint64_t v41;
  BOOL v42;
  unsigned int v43;
  const UInt8 *v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  const void *v49;
  int v50;
  _DWORD *v51;
  uint64_t **v52;
  uint64_t *v53;
  uint64_t **v54;
  unsigned int v55;
  unsigned int v56;
  _DWORD v58[3];
  _BYTE buf[24];
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFData *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1[7] + 32) + 24))(*(_QWORD *)(a1[7] + 32));
  v5 = v4;
  *(_QWORD *)&v58[1] = v4;
  if (!v4)
    goto LABEL_73;
  BytePtr = CFDataGetBytePtr(v4);
  Length = CFDataGetLength(*(CFDataRef *)&v58[1]);
  v58[0] = -67061;
  if (Length < 0x60)
    goto LABEL_42;
  if (*(_DWORD *)BytePtr != 34397946 || (v8 = bswap32(*((_DWORD *)BytePtr + 1)), v8 <= 0x5F))
  {
    *__error() = 22;
    goto LABEL_42;
  }
  if (Length != v8)
    goto LABEL_42;
  v9 = *((_DWORD *)BytePtr + 2);
  v10 = bswap32(v9);
  if (v10 - 192513 < 0xFFFF1000)
  {
    v58[0] = -67059;
    goto LABEL_42;
  }
  if (v10 > 0x20500)
  {
    v11 = secLogObjForScope("codedir");
    v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
    v9 = *((_DWORD *)BytePtr + 2);
    if (v12)
    {
      *(_DWORD *)buf = 134218496;
      *(_QWORD *)&buf[4] = BytePtr;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = bswap32(v9);
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = 132352;
      _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "%p version 0x%x newer than current 0x%x", buf, 0x18u);
      v9 = *((_DWORD *)BytePtr + 2);
    }
  }
  v13 = bswap32(v9);
  v14 = v13 > 0x204FF && *((_DWORD *)BytePtr + 23) != 0;
  v15 = bswap32(*((_DWORD *)BytePtr + 5));
  v16 = bswap32(*((_DWORD *)BytePtr + 1));
  if (v16 <= v15)
    goto LABEL_42;
  v17 = (UInt8 *)&BytePtr[v15];
  if (!memchr(v17, 0, v16 - v15) || v17 == 0)
    goto LABEL_42;
  if (v13 > 0x201FF)
  {
    v19 = *((_DWORD *)BytePtr + 12);
    if (v19)
    {
      v20 = bswap32(v19);
      if (v16 <= v20)
        goto LABEL_42;
      v21 = (UInt8 *)&BytePtr[v20];
      if (!memchr(v21, 0, v16 - v20) || v21 == 0)
        goto LABEL_42;
    }
  }
  v23 = bswap32(*((_DWORD *)BytePtr + 4));
  v24 = BytePtr[36];
  v25 = bswap32(*((_DWORD *)BytePtr + 6));
  v26 = v23 - v24 * v25;
  v27 = bswap32(*((_DWORD *)BytePtr + 7));
  if (v26 < 8 || v26 + (v27 + v25) * v24 > v16)
    goto LABEL_42;
  if (v14)
  {
    v29 = bswap32(*((_DWORD *)BytePtr + 23));
    v30 = v29 >= 8;
    v31 = v27 * (unint64_t)v24 + v29;
    if (!v30 || v31 > v16)
      goto LABEL_42;
  }
  if (v13 <= 0x200FF)
  {
LABEL_57:
    v47 = bswap32(*((_DWORD *)BytePtr + 8));
    goto LABEL_58;
  }
  v33 = *((_DWORD *)BytePtr + 11);
  if (v33)
  {
    v34 = bswap32(v33);
    v35 = (unsigned int *)&BytePtr[v34];
    if (&BytePtr[v34])
    {
      if (v34 < 8)
        goto LABEL_42;
      v36 = 0;
      v37 = v34;
      while (1)
      {
        if (v34 + 24 > v16)
          goto LABEL_42;
        if (!*v35)
          break;
        v36 += bswap32(*v35);
        v35 += 6;
        v34 = (char *)v35 - (char *)BytePtr;
        v37 += 24;
        if (v37 <= 7)
          goto LABEL_42;
      }
      v38 = v36 - 1;
      v39 = &BytePtr[v23];
      v40 = v38 * v24;
      v41 = &v39[v38 * (int)v24] - BytePtr;
      v42 = v41 < 8 || v41 + v24 > v16;
      if (v42
        || v14
        && (v13 <= 0x204FF || (v43 = *((_DWORD *)BytePtr + 23)) == 0
          ? (v44 = 0)
          : (v44 = &BytePtr[bswap32(v43) + v40]),
            (v45 = v44 - BytePtr, v45 < 8) || v45 + v24 > v16))
      {
LABEL_42:
        Security::MacOSError::throwMe((Security::MacOSError *)v58[0]);
      }
    }
  }
  if (v13 <= 0x202FF)
    goto LABEL_57;
  v46 = *((_QWORD *)BytePtr + 7);
  if (!v46)
    goto LABEL_57;
  v47 = bswap64(v46);
LABEL_58:
  if (BytePtr[39])
  {
    if (!v47 || ((v47 - 1) >> BytePtr[39]) + 1 != v27)
      goto LABEL_42;
  }
  else if ((_DWORD)v27 != (v47 != 0))
  {
    goto LABEL_42;
  }
  v48 = *(_QWORD *)(a1[4] + 8);
  v49 = *(const void **)&v58[1];
  v50 = BytePtr[37];
  *(_QWORD *)&buf[16] = 0xAAAAAAAAAAAAAAAALL;
  v51 = operator new(0x30uLL);
  v52 = (uint64_t **)(v48 + 48);
  *(_QWORD *)buf = v51;
  *(_QWORD *)&buf[8] = v48 + 48;
  buf[16] = 0;
  v51[8] = v50;
  Security::CFCopyRef<__CFData const*>::CFCopyRef((_QWORD *)v51 + 5, v49);
  buf[16] = 1;
  v53 = *(uint64_t **)(v48 + 48);
  v54 = (uint64_t **)(v48 + 48);
  if (v53)
  {
    v55 = v51[8];
    do
    {
      while (1)
      {
        v54 = (uint64_t **)v53;
        v56 = *((_DWORD *)v53 + 8);
        if (v55 >= v56)
          break;
        v53 = *v54;
        v52 = v54;
        if (!*v54)
          goto LABEL_71;
      }
      if (v56 >= v55)
      {
        std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)buf);
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA1BLL);
      }
      v53 = v54[1];
    }
    while (v53);
    v52 = v54 + 1;
  }
LABEL_71:
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at((uint64_t **)(v48 + 40), (uint64_t)v54, v52, (uint64_t *)v51);
  *(_QWORD *)buf = 0;
  std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)buf);
  std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)(*(_QWORD *)(a1[5] + 8) + 40), BytePtr[37], BytePtr[37]);
  if (!a2)
    Security::CFRef<__CFData const*>::operator=((CFTypeRef *)(*(_QWORD *)(a1[6] + 8) + 40), (CFTypeRef *)&v58[1]);
LABEL_73:
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v58[1]);
  return v5 != 0;
}

void sub_18A91BB94(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree<Security::Architecture>::__emplace_unique_key_args<Security::Architecture,Security::Architecture>(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  int v7;
  int v8;
  _BOOL4 v9;
  uint64_t **v10;
  _BOOL4 v11;
  int v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;

  v4 = result;
  v6 = result + 1;
  v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v6 = (uint64_t *)v5;
        v7 = *(_DWORD *)(v5 + 28);
        v8 = *((_DWORD *)v6 + 8);
        v9 = SHIDWORD(a2) < v8;
        if ((_DWORD)a2 != v7)
          v9 = (int)a2 < v7;
        if (!v9)
          break;
        v5 = *v6;
        v10 = (uint64_t **)v6;
        if (!*v6)
          goto LABEL_14;
      }
      v11 = v8 < SHIDWORD(a2);
      v12 = (_DWORD)a2 == v7 ? v11 : v7 < (int)a2;
      if (v12 != 1)
        break;
      v10 = (uint64_t **)(v6 + 1);
      v5 = v6[1];
      if (!v5)
        goto LABEL_14;
    }
  }
  else
  {
    v10 = (uint64_t **)(result + 1);
LABEL_14:
    v13 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v13 + 28) = a3;
    *v13 = 0;
    v13[1] = 0;
    v13[2] = (uint64_t)v6;
    *v10 = v13;
    v14 = *(_QWORD *)*v4;
    if (v14)
    {
      *v4 = v14;
      v15 = *v10;
    }
    else
    {
      v15 = v13;
    }
    result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v4[1], v15);
    ++v4[2];
  }
  return result;
}

uint64_t *std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>(uint64_t *result, unsigned int a2, int a3)
{
  uint64_t **v4;
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unsigned int v8;
  uint64_t *v9;

  v4 = (uint64_t **)result;
  v6 = (uint64_t **)(result + 1);
  v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = (uint64_t **)(result + 1);
LABEL_9:
    v9 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v9 + 7) = a3;
    return std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

_QWORD *Security::CFCopyRef<__CFData const*>::CFCopyRef(_QWORD *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf)
    CFRetain(cf);
  return a1;
}

void sub_18A91BDCC(_Unwind_Exception *a1)
{
  const void **v1;

  Security::CFRef<__CFData const*>::~CFRef(v1);
  _Unwind_Resume(a1);
}

const load_command *Security::MachOBase::findCommand(Security::MachOBase *this, int a2)
{
  const load_command *i;
  uint32_t cmd;
  unsigned int v6;

  for (i = (const load_command *)*((_QWORD *)this + 2);
        i;
        i = (const load_command *)Security::MachOBase::nextCommand(this, i))
  {
    cmd = i->cmd;
    v6 = bswap32(i->cmd);
    if (*((_BYTE *)this + 33))
      cmd = v6;
    if (cmd == a2)
      break;
  }
  return i;
}

unint64_t Security::MachOBase::nextCommand(Security::MachOBase *this, const load_command *a2)
{
  uint32_t cmdsize;
  int v3;
  unsigned int v4;
  unint64_t result;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;

  cmdsize = a2->cmdsize;
  v3 = *((unsigned __int8 *)this + 33);
  v4 = bswap32(cmdsize);
  if (*((_BYTE *)this + 33))
    cmdsize = v4;
  if (!cmdsize)
LABEL_10:
    Security::UnixError::throwMe((Security::UnixError *)8);
  result = (unint64_t)a2 + cmdsize;
  v7 = *((_QWORD *)this + 3);
  if (v7 <= result)
    return 0;
  if (v7 < result + 8)
    goto LABEL_10;
  v8 = *(_DWORD *)(result + 4);
  v9 = bswap32(v8);
  v10 = v3 ? v9 : v8;
  if (v7 < result + v10)
    goto LABEL_10;
  return result;
}

void Security::CodeSigning::MachORep::~MachORep(Security::CodeSigning::MachORep *this)
{
  Security::CodeSigning::MachORep::~MachORep(this);
  JUMPOUT(0x18D76FAA0);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_1E1FC8FD0;
  *((_QWORD *)this + 6) = &unk_1E1FC90F0;
  v2 = *((_QWORD *)this + 7);
  if (v2)
  {
    free(*(void **)(v2 + 8));
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)(v2 + 56));
    MEMORY[0x18D76FAA0](v2, 0x1020C4076728D04);
  }
  free(*((void **)this + 8));
  *(_QWORD *)this = off_1E1FC8C10;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::MachORep *)((char *)this + 40));
  if (*((char *)this + 39) < 0)
    operator delete(*((void **)this + 2));
  Security::CodeSigning::DiskRep::~DiskRep(this);
}

void std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

const __CFData *Security::CodeSigning::SecStaticCode::getDictionary(UInt8 *this, uint64_t a2, int a3)
{
  const __CFData *result;
  const __CFData *v6;
  const __CFData *v7;

  if (a3)
    Security::CodeSigning::SecStaticCode::validateDirectory(this);
  result = (const __CFData *)(*(uint64_t (**)(UInt8 *, uint64_t, uint64_t))(*(_QWORD *)this + 80))(this, a2, 4294900235);
  if (result)
  {
    v6 = result;
    (*(void (**)(UInt8 *, uint64_t, uint64_t))(*(_QWORD *)this + 96))(this, a2, 4294900235);
    result = (const __CFData *)Security::makeCFDictionaryFrom(v6, v7);
    if (!result)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ELL);
  }
  return result;
}

BOOL Security::CodeSigning::SecStaticCode::validateComponent(Security::CodeSigning::SecStaticCode *this, unsigned int a2, Security::MacOSError *a3)
{
  const __CFData *v5;
  const __CFData *v6;
  Security::CodeSigning::CodeDirectory *v7;
  Security::CodeSigning::CodeDirectory *v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  _BOOL8 result;

  v5 = (const __CFData *)*((_QWORD *)this + a2 + 49);
  v6 = (const __CFData *)*MEMORY[0x1E0C9B0D0];
  v7 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory(this, 1);
  v8 = v7;
  if (v5 != v6)
  {
    BytePtr = CFDataGetBytePtr(v5);
    Length = CFDataGetLength(v5);
    result = Security::CodeSigning::CodeDirectory::validateSlot(v8, BytePtr, Length, -a2);
    if (result)
      return result;
LABEL_5:
    Security::MacOSError::throwMe(a3);
  }
  result = Security::CodeSigning::CodeDirectory::slotIsPresent(v7, -a2);
  if (result)
    goto LABEL_5;
  return result;
}

CFPropertyListRef Security::makeCFDictionaryFrom(CFDataRef xmlData, const __CFData *a2)
{
  CFPropertyListRef v2;
  CFPropertyListRef v3;
  CFTypeID v4;
  Security::CFError *TypeID;

  if (!xmlData)
    return 0;
  v2 = CFPropertyListCreateFromXMLData(0, xmlData, 0, 0);
  v3 = v2;
  if (v2)
  {
    v4 = CFGetTypeID(v2);
    TypeID = (Security::CFError *)CFDictionaryGetTypeID();
    if ((Security::CFError *)v4 != TypeID)
      Security::CFError::throwMe(TypeID);
  }
  return v3;
}

void Security::CodeSigning::BundleDiskRep::~BundleDiskRep(Security::CodeSigning::BundleDiskRep *this)
{
  Security::CodeSigning::BundleDiskRep::~BundleDiskRep(this);
  JUMPOUT(0x18D76FAA0);
}

{
  *(_QWORD *)this = &off_1E1FC8908;
  *((_QWORD *)this + 2) = &unk_1E1FC8A28;
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)this + 27));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)this + 24));
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((_QWORD *)this + 13);
  if (*((char *)this + 103) < 0)
    operator delete(*((void **)this + 10));
  Security::CFRef<__CFURL const*>::~CFRef((const void **)this + 8);
  if (*((char *)this + 55) < 0)
    operator delete(*((void **)this + 4));
  Security::CFRef<__CFBundle *>::~CFRef((const void **)this + 3);
  Security::CodeSigning::DiskRep::~DiskRep(this);
}

void Security::CodeSigning::DiskRep::~DiskRep(Security::CodeSigning::DiskRep *this)
{
  *(_QWORD *)this = off_1E1FC8E70;
}

const void **Security::CFRef<__CFBundle *>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

BOOL __sec_protocol_options_set_tls_resumption_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFE7FFFF | (*(unsigned __int8 *)(a1 + 32) << 19) | 0x100000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFE7FFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }
  return a2 != 0;
}

BOOL __sec_protocol_options_set_tls_false_start_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFFFF9FF | (*(unsigned __int8 *)(a1 + 32) << 9) | 0x400;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFFFF9FFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }
  return a2 != 0;
}

BOOL __sec_protocol_options_set_tls_is_fallback_attempt_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFFFFE7F | ((*(_BYTE *)(a1 + 32) & 1) << 7) | 0x100;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFFFFE7FLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }
  return a2 != 0;
}

void sec_protocol_options_set_tls_min_version(sec_protocol_options_t options, SSLProtocol version)
{
  uint64_t v2;
  int *v3;
  int v4;
  __int16 v5;
  _QWORD v6[4];
  __int16 v7;

  v2 = 0;
  v3 = ssl_protocol_version_map;
  while (1)
  {
    v4 = *v3;
    v3 += 2;
    if (v4 == version)
      break;
    if (++v2 == 8)
      return;
  }
  if (v2 != 7)
  {
    if (options)
    {
      v5 = ssl_protocol_version_map[2 * v2 + 1];
      v6[0] = MEMORY[0x1E0C809B0];
      v6[1] = 0x40000000;
      v6[2] = __sec_protocol_options_set_min_tls_protocol_version_block_invoke;
      v6[3] = &__block_descriptor_tmp_14;
      v7 = v5;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v6);
    }
  }
}

_xpc_connection_s *__trustd_connection_block_invoke()
{
  _xpc_connection_s *result;

  result = securityd_create_connection("com.apple.trustd", -1);
  sTrustdConnection = (uint64_t)result;
  return result;
}

void ___securityd_connection_block_invoke_2(uint64_t a1)
{
  NSObject *v2;
  _DWORD v3[2];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (CFArrayGetCount((CFArrayRef)sSecuritydConnectionsPool) < 1)
  {
    if (sSecuritydConnectionsCount <= 4)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = securityd_create_connection("com.apple.securityd", -1);
      ++sSecuritydConnectionsCount;
      v2 = secLogObjForScope("xpc");
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        v3[0] = 67109120;
        v3[1] = sSecuritydConnectionsCount;
        _os_log_debug_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEBUG, "Adding securityd connection to pool, total now %d", (uint8_t *)v3, 8u);
      }
    }
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFArrayGetValueAtIndex((CFArrayRef)sSecuritydConnectionsPool, 0);
    CFArrayRemoveValueAtIndex((CFMutableArrayRef)sSecuritydConnectionsPool, 0);
  }
}

_xpc_connection_s *securityd_create_connection(const char *a1, int a2)
{
  _xpc_connection_s *mach_service;

  if (!a1)
    a1 = "com.apple.securityd";
  mach_service = xpc_connection_create_mach_service(a1, 0, 0);
  xpc_connection_set_event_handler(mach_service, &__block_literal_global_37);
  if (a2 != -1)
    xpc_connection_set_target_user_session_uid();
  xpc_connection_resume(mach_service);
  return mach_service;
}

void ___securityd_message_with_reply_async_inner_block_invoke(uint64_t a1, void *a2)
{
  CFTypeRef v3;
  int v4;
  CFTypeRef cf;
  xpc_object_t v6;

  v6 = a2;
  if (a2 == (void *)MEMORY[0x1E0C81258] && (v4 = *(_DWORD *)(a1 + 72)) != 0)
  {
    _securityd_message_with_reply_async_inner(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 32), (v4 - 1));
  }
  else
  {
    cf = 0;
    _securityd_process_message_reply(&v6, &cf, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    v3 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v3);
    }
  }
  xpc_release(*(xpc_object_t *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  _Block_release(*(const void **)(a1 + 32));
  return_securityd_connection_to_pool(*(_DWORD *)(a1 + 64), *(_BYTE *)(a1 + 76), *(_xpc_connection_s **)(a1 + 56));
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  void *v4;
  NSObject *v5;
  const __CFBoolean *Value;
  _BOOL4 v7;
  const __CFBoolean *v8;
  _BOOL4 v9;
  __CFDictionary *v10;
  const __CFDictionary *v11;
  OSStatus v12;
  _QWORD v14[7];
  os_activity_scope_state_s state;
  uint64_t v16;
  const __CFDictionary **v17;
  uint64_t v18;
  void *v19;
  CFDictionaryRef v20;
  uint64_t v21;
  OSStatus v22;

  v4 = (void *)MEMORY[0x18D770A24]();
  v22 = -1431655766;
  v16 = 0;
  v17 = (const __CFDictionary **)&v16;
  v18 = 0x3010000000;
  v19 = &unk_18AA98BF6;
  v20 = query;
  v21 = 0;
  v5 = _os_activity_create(&dword_18A900000, "SecItemCopyMatching_ios", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  if ((explode_identity(v17[4], SecItemCopyMatching, &v22, (__CFData **)result) & 1) == 0)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(v17[4], CFSTR("r_Data"));
    if (Value)
      v7 = CFBooleanGetValue(Value) == 0;
    else
      v7 = 1;
    v8 = (const __CFBoolean *)CFDictionaryGetValue(v17[4], CFSTR("r_Attributes"));
    if (v8)
      v9 = CFBooleanGetValue(v8) != 0;
    else
      v9 = 0;
    if (!v7 && !v9)
    {
      v10 = SecCFDictionaryCOWGetMutable(v17 + 4);
      CFDictionarySetValue(v10, CFSTR("r_Attributes"), (const void *)*MEMORY[0x1E0C9AE50]);
    }
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __SecItemCopyMatching_block_invoke;
    v14[3] = &unk_1E1FD5E30;
    v14[4] = &v16;
    v14[5] = query;
    v14[6] = result;
    v22 = SecOSStatusWith((uint64_t)v14);
  }
  v11 = v17[5];
  if (v11)
    CFRelease(v11);
  v12 = v22;
  os_activity_scope_leave(&state);

  _Block_object_dispose(&v16, 8);
  objc_autoreleasePoolPop(v4);
  return v12;
}

void sub_18A91C820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, os_activity_scope_state_s state, char a17)
{
  os_activity_scope_leave(&state);
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

BOOL SecTrustStoreContains(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  _BOOL8 v4;
  NSObject *v5;
  const char *v6;
  _QWORD v8[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;
  uint8_t buf[4];
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  if (!a1)
    goto LABEL_5;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __SecTrustStoreContains_block_invoke;
  v8[3] = &unk_1E1FDB588;
  v8[5] = a1;
  v8[6] = a2;
  v8[4] = &v9;
  if (SecOSStatusWith((uint64_t)v8))
  {
    v3 = secLogObjForScope("SecError");
    v4 = 0;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 141558274;
      v14 = 1752392040;
      v15 = 2112;
      v16 = a2;
      _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "Failed to read trust settings for %{mask.hash}@", buf, 0x16u);
LABEL_5:
      v4 = 0;
    }
  }
  else
  {
    if (!gTrustd)
    {
      v5 = secLogObjForScope("truststore");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        if (*((_BYTE *)v10 + 24))
          v6 = (const char *)&unk_18AA61AAF;
        else
          v6 = "do not ";
        *(_DWORD *)buf = 136446722;
        v14 = (uint64_t)v6;
        v15 = 2160;
        v16 = 1752392040;
        v17 = 2112;
        v18 = a2;
        _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "Trust settings %{public}s exist for %{mask.hash}@", buf, 0x20u);
      }
    }
    v4 = *((_BYTE *)v10 + 24) != 0;
  }
  _Block_object_dispose(&v9, 8);
  return v4;
}

uint64_t SecOSStatusWith(uint64_t a1)
{
  int v1;
  CFTypeRef v2;
  uint64_t OSStatus;
  NSObject *v4;
  CFTypeRef v5;
  CFTypeRef cf;
  uint8_t buf[4];
  int v9;
  __int16 v10;
  CFTypeRef v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  cf = 0;
  v1 = (*(uint64_t (**)(uint64_t, CFTypeRef *))(a1 + 16))(a1, &cf);
  v2 = cf;
  if (v1)
  {
    if (cf)
      __security_simulatecrash(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
    SetLastError(0);
    return 0;
  }
  else
  {
    if (!cf)
    {
      __security_simulatecrash(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
      v2 = cf;
    }
    SetLastError(v2);
    OSStatus = SecErrorGetOSStatus((uint64_t)cf);
    if ((_DWORD)OSStatus != -25300)
    {
      secLogObjForScope("OSStatus");
      v4 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109378;
        v9 = OSStatus;
        v10 = 2112;
        v11 = cf;
        _os_log_debug_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEBUG, "error:[%d] %@", buf, 0x12u);
      }

    }
    v5 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v5);
    }
  }
  return OSStatus;
}

void SetLastError(const void *a1)
{
  pthread_key_t v2;
  void *v3;

  if (getLastErrorKey_onceToken != -1)
    dispatch_once(&getLastErrorKey_onceToken, &__block_literal_global_81_8204);
  if (getLastErrorKey_haveKey == 1)
  {
    v2 = getLastErrorKey_key;
    v3 = pthread_getspecific(getLastErrorKey_key);
    if (v3)
      CFRelease(v3);
    if (a1)
      CFRetain(a1);
    pthread_setspecific(v2, a1);
  }
}

uint64_t explode_identity(const __CFDictionary *a1, OSStatus (__cdecl *a2)(CFDictionaryRef attributes, CFTypeRef *result), OSStatus *a3, __CFData **a4)
{
  const void *Value;
  const void *v9;
  CFTypeID v10;
  const void *v11;
  CFMutableDictionaryRef v12;
  __CFDictionary *MutableCopy;
  CFTypeRef *v14;
  OSStatus v15;
  _BOOL4 v16;
  _BOOL4 v17;
  BOOL v18;
  OSStatus v19;
  BOOL v20;
  OSStatus v21;
  int v22;
  OSStatus v24;
  CFTypeRef v25;
  __CFData *UUIDBasedPersistentRef;
  uint64_t result;
  int v28;
  const __CFDictionary *v29;
  const __CFDictionary *v30;
  void *v31;
  const __CFDictionary *v32;
  const __CFDictionary *v33;
  OSStatus v34;
  NSObject *v35;
  CFDataRef v36;
  CFTypeRef v37;
  OSStatus *v38;
  CFTypeRef cf;
  CFDataRef theData;
  CFTypeRef v41;
  void *values[2];
  __int128 keys;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  Value = CFDictionaryGetValue(a1, CFSTR("v_Ref"));
  if (Value)
  {
    v9 = Value;
    v10 = CFGetTypeID(Value);
    if (v10 != SecIdentityGetTypeID())
      return 0;
    v38 = a3;
    v11 = (const void *)*((_QWORD *)v9 + 2);
    CFRetain(v11);
    v12 = (CFMutableDictionaryRef)*((_QWORD *)v9 + 3);
    CFRetain(v12);
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a1);
    CFDictionarySetValue(MutableCopy, CFSTR("v_Ref"), v11);
    CFDictionaryRemoveValue(MutableCopy, CFSTR("class"));
    CFDictionarySetValue(MutableCopy, CFSTR("class"), CFSTR("cert"));
    v41 = 0;
    if (a4)
      v14 = &v41;
    else
      v14 = 0;
    v15 = ((uint64_t (*)(__CFDictionary *, CFTypeRef *))a2)(MutableCopy, v14);
    v16 = a2 == SecItemAdd;
    v17 = v15 == -25299;
    v18 = v16 && v17;
    if (v16 && v17)
      v19 = 0;
    else
      v19 = v15;
    if (v19)
      v20 = v19 == -25300;
    else
      v20 = 1;
    if (!v20)
    {
      v24 = v15;
      a3 = v38;
      if (!MutableCopy)
        goto LABEL_59;
      goto LABEL_58;
    }
    if ((char *)a2 == (char *)SecItemDelete)
    {
      v29 = SecKeyCopyAttributes(v12);
      if (v29)
      {
        v30 = v29;
        v31 = (void *)CFDictionaryGetValue(v29, CFSTR("klbl"));
        *(_QWORD *)&keys = CFSTR("class");
        *((_QWORD *)&keys + 1) = CFSTR("pkhh");
        values[0] = CFSTR("cert");
        values[1] = v31;
        if (v31 && (v32 = CFDictionaryCreate(0, (const void **)&keys, (const void **)values, 2, 0, 0)) != 0)
        {
          v33 = v32;
          v34 = SecItemCopyMatching(v32, 0);
          CFRelease(v33);
          CFRelease(v30);
          if (!v34)
          {
            v24 = v19;
            goto LABEL_24;
          }
        }
        else
        {
          CFRelease(v30);
        }
      }
    }
    CFDictionarySetValue(MutableCopy, CFSTR("v_Ref"), v12);
    CFDictionarySetValue(MutableCopy, CFSTR("r_PersistentRef"), (const void *)*MEMORY[0x1E0C9AE40]);
    CFDictionaryRemoveValue(MutableCopy, CFSTR("class"));
    CFDictionarySetValue(MutableCopy, CFSTR("class"), CFSTR("keys"));
    v21 = ((uint64_t (*)(__CFDictionary *, _QWORD))a2)(MutableCopy, 0);
    if (v18)
      v22 = -25299;
    else
      v22 = 0;
    if (v21 == -25299 && a2 == SecItemAdd)
      v24 = v22;
    else
      v24 = v21;
LABEL_24:
    a3 = v38;
    v25 = v41;
    if (v41)
    {
      if (!v24)
      {
        values[0] = (void *)-1;
        cf = 0;
        theData = 0;
        if (_SecItemParsePersistentRef(v41, 0, values, (const void **)&theData, (CFDictionaryRef *)&cf))
        {
          if (SecKeychainIsStaticPersistentRefsEnabled() && theData && CFDataGetLength(theData) == 16)
          {
            UUIDBasedPersistentRef = _SecItemCreateUUIDBasedPersistentRef(CFSTR("idnt"), theData, (const __CFDictionary *)cf);
          }
          else
          {
            if (SecKeychainIsStaticPersistentRefsEnabled())
            {
              secLogObjForScope("pref");
              v35 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(keys) = 134217984;
                *(void **)((char *)&keys + 4) = values[0];
                _os_log_impl(&dword_18A900000, v35, OS_LOG_TYPE_DEFAULT, "explode_identity: Creating old persistent ref for %llu", (uint8_t *)&keys, 0xCu);
              }

            }
            UUIDBasedPersistentRef = _SecItemCreatePersistentRef(CFSTR("idnt"), (unint64_t)values[0], (CFDictionaryRef)cf);
          }
          *a4 = UUIDBasedPersistentRef;
        }
        v36 = theData;
        if (theData)
        {
          theData = 0;
          CFRelease(v36);
        }
        v37 = cf;
        if (cf)
        {
          cf = 0;
          CFRelease(v37);
        }
        v25 = v41;
        if (!v41)
        {
          v24 = 0;
          if (!MutableCopy)
          {
LABEL_59:
            if (v11)
              CFRelease(v11);
            if (!v12)
              goto LABEL_63;
            goto LABEL_62;
          }
LABEL_58:
          CFRelease(MutableCopy);
          goto LABEL_59;
        }
      }
      v41 = 0;
      CFRelease(v25);
    }
    if (!MutableCopy)
      goto LABEL_59;
    goto LABEL_58;
  }
  result = (uint64_t)CFDictionaryGetValue(a1, CFSTR("class"));
  if (result)
  {
    v28 = CFEqual(CFSTR("idnt"), (CFTypeRef)result);
    result = 0;
    if ((char *)a2 == (char *)SecItemDelete)
    {
      if (v28)
      {
        v12 = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a1);
        CFDictionaryRemoveValue(v12, CFSTR("class"));
        CFDictionarySetValue(v12, CFSTR("class"), CFSTR("cert"));
        v24 = SecItemDelete(v12);
        if (!v24)
        {
          CFDictionarySetValue(v12, CFSTR("class"), CFSTR("keys"));
          v24 = SecItemDelete(v12);
        }
LABEL_62:
        CFRelease(v12);
LABEL_63:
        *a3 = v24;
        return 1;
      }
    }
  }
  return result;
}

BOOL SecItemAuthDoQuery(CFDictionaryRef *a1, CFDictionaryRef *a2, OSStatus (__cdecl *a3)(CFDictionaryRef attributes, CFTypeRef *result), __CFString **a4, void *a5)
{
  CFDictionaryRef *v8;
  const __CFDictionary *v9;
  CFDictionaryRef *v10;
  CFDictionaryRef *v11;
  const void **v12;
  CFTypeID v13;
  _BOOL4 v14;
  const void *v15;
  const void *v16;
  int v17;
  int v18;
  const __CFDictionary **v19;
  const void *v20;
  __CFDictionary *v21;
  __CFDictionary *v22;
  const void *v23;
  __CFDictionary *v24;
  __CFDictionary *v25;
  const __CFString *v26;
  const void *v27;
  const void *v28;
  _BOOL4 v29;
  __CFDictionary *v30;
  __CFDictionary *v31;
  __CFDictionary *v32;
  const void *v33;
  __CFDictionary *v34;
  const void *v35;
  __CFDictionary *v36;
  const void *v37;
  uint64_t (*v38)(void);
  _QWORD *v39;
  int v40;
  int v41;
  void *v42;
  objc_class *LAContextClass;
  __CFDictionary *v44;
  __CFDictionary *v45;
  const __CFArray *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t i;
  void *v50;
  const __CFData *v51;
  CFMutableDictionaryRef *v52;
  void *v53;
  void *v54;
  __CFString *v55;
  BOOL v56;
  void *v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  __CFData *v66;
  __CFDictionary *v67;
  const void *v68;
  CFNumberRef v69;
  __CFDictionary *v70;
  const void *v71;
  CFNumberRef v72;
  __CFDictionary *v73;
  const void *v74;
  CFNumberRef v75;
  __CFDictionary *v76;
  _BOOL8 v77;
  const __CFDictionary *v78;
  const __CFString *format;
  id v81;
  id v82;
  void *v83;
  const __CFDictionary **v84;
  const __CFAllocator *v85;
  id value;
  _QWORD v88[2];
  uint64_t (*v89)(uint64_t, CFTypeRef *, __CFString **);
  void *v90;
  id v91;
  uint64_t *v92;
  _QWORD *v93;
  CFDictionaryRef *v94;
  CFDictionaryRef *v95;
  OSStatus (__cdecl *v96)(CFDictionaryRef, CFTypeRef *);
  _QWORD v97[5];
  id v98;
  uint64_t v99;
  const __CFDictionary **v100;
  uint64_t v101;
  void *v102;
  uint64_t v103;
  uint64_t v104;
  id v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  const __CFDictionary *v110;
  CFTypeRef cf;
  const __CFArray *v112;
  uint64_t valuePtr;
  _BYTE v114[128];
  uint64_t v115;

  v115 = *MEMORY[0x1E0C80C00];
  v82 = a5;
  v99 = 0;
  v100 = (const __CFDictionary **)&v99;
  v101 = 0x3010000000;
  v103 = 0;
  v104 = 0;
  v102 = &unk_18AA98BF6;
  v97[0] = 0;
  v97[1] = v97;
  v97[2] = 0x3032000000;
  v97[3] = __Block_byref_object_copy__8233;
  v97[4] = __Block_byref_object_dispose__8234;
  v98 = 0;
  if (a2)
    v8 = a2;
  else
    v8 = a1;
  v9 = *v8;
  v10 = (CFDictionaryRef *)CFDictionaryGetValue(*v8, CFSTR("accc"));
  v11 = v10;
  v12 = (const void **)MEMORY[0x1E0C9AE50];
  if (!v10)
  {
    v14 = (char *)a3 == (char *)SecItemUpdate;
    goto LABEL_17;
  }
  v13 = CFGetTypeID(v10);
  if (v13 != SecAccessControlGetTypeID())
  {
    SecError(-50, a4, CFSTR("Unexpected type of kSecAttrAccessControl attribute"));
    goto LABEL_111;
  }
  v14 = (char *)a3 == (char *)SecItemUpdate;
  if (a3 != SecItemAdd && (char *)a3 != (char *)SecItemUpdate)
  {
    v14 = 0;
    goto LABEL_17;
  }
  if (CFDictionaryGetValue(v11[2], CFSTR("acl")))
  {
    v15 = CFDictionaryGetValue(v9, CFSTR("sync"));
    v16 = *v12;
    if (v15 && v16)
    {
      if (!CFEqual(v15, v16))
        goto LABEL_17;
    }
    else if (v15 != v16)
    {
      goto LABEL_17;
    }
    if (SecError(-50, a4, CFSTR("item with kSecAttrAccessControl is not synchronizable")))
      goto LABEL_17;
LABEL_111:
    v77 = 0;
    goto LABEL_101;
  }
LABEL_17:
  v17 = (char *)a3 == (char *)SecItemDelete || v14;
  if ((char *)a3 == (char *)SecItemShareWithGroup)
    v17 = 1;
  if (a3 == SecItemCopyMatching)
    v18 = 1;
  else
    v18 = v17;
  if (!SecItemAttributesPrepare(a1, v18, a4) || a2 && !SecItemAttributesPrepare(a2, 0, a4))
    goto LABEL_111;
  v19 = v100;
  v20 = CFDictionaryGetValue(*a1, CFSTR("u_OpPrompt"));
  if (v20)
  {
    v21 = SecCFDictionaryCOWGetMutable(v19 + 4);
    CFDictionarySetValue(v21, CFSTR("u_OpPrompt"), v20);
    v22 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionaryRemoveValue(v22, CFSTR("u_OpPrompt"));
  }
  v23 = CFDictionaryGetValue(*a1, CFSTR("u_CallerName"));
  if (v23)
  {
    v24 = SecCFDictionaryCOWGetMutable(v19 + 4);
    CFDictionarySetValue(v24, CFSTR("u_CallerName"), v23);
    v25 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionaryRemoveValue(v25, CFSTR("u_CallerName"));
  }
  v26 = (const __CFString *)CFDictionaryGetValue(*a1, CFSTR("u_AuthUI"));
  if (!v26)
  {
    v27 = CFDictionaryGetValue(*a1, CFSTR("u_NoAuthUI"));
    v28 = *v12;
    if (v27 && v28)
      v29 = CFEqual(v27, v28) != 0;
    else
      v29 = v27 == v28;
    if (v29)
      v26 = CFSTR("u_AuthUIF");
    else
      v26 = CFSTR("u_AuthUIA");
  }
  if (!CFEqual(v26, CFSTR("u_AuthUIS")) || CFDictionaryGetValue(*a1, CFSTR("u_NoAuthUI")))
  {
    if (CFDictionaryContainsKey(*a1, CFSTR("u_NoAuthUI")))
    {
      v30 = SecCFDictionaryCOWGetMutable(a1);
      CFDictionaryRemoveValue(v30, CFSTR("u_NoAuthUI"));
    }
    if ((!v26 || !CFEqual(v26, CFSTR("u_AuthUIS"))) && CFDictionaryContainsKey(*a1, CFSTR("u_AuthUI")))
    {
      v31 = SecCFDictionaryCOWGetMutable(a1);
      CFDictionaryRemoveValue(v31, CFSTR("u_AuthUI"));
    }
  }
  if (!CFEqual(v26, CFSTR("u_AuthUIA")))
  {
    v32 = SecCFDictionaryCOWGetMutable(v19 + 4);
    CFDictionarySetValue(v32, CFSTR("u_AuthUI"), v26);
  }
  v33 = CFDictionaryGetValue(*a1, CFSTR("u_CredRef"));
  if (v33)
  {
    v34 = SecCFDictionaryCOWGetMutable(v19 + 4);
    CFDictionarySetValue(v34, CFSTR("u_CredRef"), v33);
  }
  v35 = CFDictionaryGetValue(*a1, CFSTR("u_SystemKeychain"));
  if (v35)
  {
    v36 = SecCFDictionaryCOWGetMutable(v19 + 4);
    CFDictionarySetValue(v36, CFSTR("u_SystemKeychain"), v35);
  }
  if (a3 != SecItemCopyMatching)
  {
    v37 = CFDictionaryGetValue(*a1, CFSTR("u_AuthUI"));
    if (v37)
    {
      if (CFEqual(v37, CFSTR("u_AuthUIS")))
      {
        SecError(-50, a4, CFSTR("kSecUseAuthenticationUISkip is allowed only for SecItemCopyMatching"));
        goto LABEL_111;
      }
    }
  }
  v84 = v100 + 4;
  v88[0] = MEMORY[0x1E0C809B0];
  v38 = (uint64_t (*)(void))__SecItemAuthDoQuery_block_invoke;
  v88[1] = 3221225472;
  v89 = __SecItemAuthDoQuery_block_invoke;
  v90 = &unk_1E1FD6200;
  v94 = a1;
  v95 = a2;
  v96 = a3;
  v92 = &v99;
  v93 = v97;
  v91 = v82;
  v39 = v88;
  v40 = 0;
  v112 = 0;
  v110 = 0;
  cf = 0;
  format = CFSTR("Unable to create LAContext from externalizedContext");
  v83 = (void *)*v12;
  v85 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v81 = v39;
  while (1)
  {
    v41 = v38();
    if (v41 != 2)
      break;
    if (!LocalAuthenticationLibraryCore())
    {
      SecError(-4, a4, CFSTR("LocalAuthentication is not available"));
      goto LABEL_95;
    }
    SecCFDictionaryCOWGetMutable(v84);
    -[__CFDictionary objectForKey:](*v84, "objectForKey:", CFSTR("u_AuthCtx"));
    value = (id)objc_claimAutoreleasedReturnValue();
    if (!value)
    {
      -[__CFDictionary objectForKey:](*v84, "objectForKey:", CFSTR("u_CredRef"));
      v42 = (void *)objc_claimAutoreleasedReturnValue();
      LAContextClass = (objc_class *)getLAContextClass();
      if (v42)
        value = (id)objc_msgSend([LAContextClass alloc], "initWithExternalizedContext:", v42);
      else
        value = objc_alloc_init(LAContextClass);
      if (!value)
      {
        value = 0;
        goto LABEL_113;
      }
      v44 = SecCFDictionaryCOWGetMutable(v84);
      CFDictionarySetValue(v44, CFSTR("u_AuthCtx"), value);
      if (!v42)
      {
        objc_msgSend(value, "externalizedContext");
        v42 = (void *)objc_claimAutoreleasedReturnValue();
        if (!v42)
        {
          format = CFSTR("Failed to get externalized context from LAContext");
LABEL_113:
          SecError(-25293, a4, format, format);

LABEL_114:
LABEL_95:
          v77 = 0;
          goto LABEL_96;
        }
        v45 = SecCFDictionaryCOWGetMutable(v84);
        CFDictionarySetValue(v45, CFSTR("u_CredRef"), v42);
      }

    }
    if (v40 == 20)
    {
      SecItemAuthMaxAttemptsReached(v112, a4);
      goto LABEL_114;
    }
    if (!v110)
    {
      v68 = CFDictionaryGetValue(*v84, CFSTR("u_OpPrompt"));
      if (v68)
      {
        valuePtr = 2;
        v69 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
        v70 = SecCFDictionaryCOWGetMutable(&v110);
        CFDictionarySetValue(v70, v69, v68);
        CFRelease(v69);
      }
      v71 = CFDictionaryGetValue(*v84, CFSTR("u_CallerName"));
      if (v71)
      {
        valuePtr = 1021;
        v72 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
        v73 = SecCFDictionaryCOWGetMutable(&v110);
        CFDictionarySetValue(v73, v72, v71);
        CFRelease(v72);
      }
      v74 = CFDictionaryGetValue(*v84, CFSTR("u_AuthUI"));
      if (v74 && CFEqual(v74, CFSTR("u_AuthUIF")))
      {
        valuePtr = 1000;
        v75 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
        v76 = SecCFDictionaryCOWGetMutable(&v110);
        CFDictionarySetValue(v76, v75, v83);
        CFRelease(v75);
      }
    }
    v108 = 0u;
    v109 = 0u;
    v106 = 0u;
    v107 = 0u;
    v46 = v112;
    v47 = -[__CFArray countByEnumeratingWithState:objects:count:](v46, "countByEnumeratingWithState:objects:count:", &v106, v114, 16);
    if (v47)
    {
      v48 = *(_QWORD *)v107;
      while (2)
      {
        for (i = 0; i != v47; ++i)
        {
          if (*(_QWORD *)v107 != v48)
            objc_enumerationMutation(v46);
          v50 = *(void **)(*((_QWORD *)&v106 + 1) + 8 * i);
          objc_msgSend(v50, "objectAtIndexedSubscript:", 0, format);
          v51 = (const __CFData *)objc_claimAutoreleasedReturnValue();
          v52 = (CFMutableDictionaryRef *)SecAccessControlCreateFromData(v85, v51, a4);

          if (!v52)
          {

            goto LABEL_95;
          }
          objc_msgSend(v50, "objectAtIndexedSubscript:", 1);
          v53 = (void *)objc_claimAutoreleasedReturnValue();
          v105 = 0;
          objc_msgSend(value, "evaluateAccessControl:aksOperation:options:error:", v52, v53, v110, &v105);
          v54 = (void *)objc_claimAutoreleasedReturnValue();
          v55 = (__CFString *)v105;

          v56 = a4 == 0;
          if (v54)
            v56 = 1;
          if (!v56)
          {
            v55 = v55;
            *a4 = v55;
LABEL_94:

            goto LABEL_95;
          }
          if (!v54)
            goto LABEL_94;
          objc_msgSend(v50, "objectAtIndexedSubscript:", 1);
          v57 = (void *)objc_claimAutoreleasedReturnValue();
          v58 = objc_msgSend(v57, "isEqual:", &stru_1E1FDD448);

          if (v58)
          {
            CFDictionarySetValue(v52[2], CFSTR("bound"), v83);
            v66 = SecAccessControlCopyData((uint64_t)v52, v59, v60, v61, v62, v63, v64, v65);
            v67 = SecCFDictionaryCOWGetMutable(v84);
            CFDictionarySetValue(v67, CFSTR("accc"), v66);

          }
        }
        v47 = -[__CFArray countByEnumeratingWithState:objects:count:](v46, "countByEnumeratingWithState:objects:count:", &v106, v114, 16);
        if (v47)
          continue;
        break;
      }
    }

    ++v40;
    v38 = (uint64_t (*)(void))v89;
  }
  v77 = v41 != 1;
LABEL_96:
  if (cf)
    CFRelease(cf);
  if (v112)
    CFRelease(v112);

LABEL_101:
  v78 = v100[5];
  if (v78)
    CFRelease(v78);
  _Block_object_dispose(v97, 8);

  _Block_object_dispose(&v99, 8);
  return v77;
}

void sub_18A91DBFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose(&a34, 8);
  _Unwind_Resume(a1);
}

uint64_t SecItemAttributesPrepare(CFDictionaryRef *a1, int a2, __CFString **a3)
{
  _QWORD *Value;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  __CFDictionary *v9;
  const __CFDictionary *v10;
  CFDictionaryRef v11;
  const __CFDictionary *v12;
  void *v13;
  int v14;
  void *v15;
  NSObject *v16;
  __CFDictionary *v17;
  const void *v18;
  uint64_t v19;
  CFTypeID v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __CFData *v28;
  __CFData *v29;
  __CFDictionary *v30;
  const void *v31;
  __CFDictionary *v32;
  __CFDictionary *v33;
  void *v34;
  void *v35;
  CFTypeID v36;
  const __CFArray *v37;
  xpc_object_t v38;
  CFIndex Count;
  CFIndex v40;
  CFIndex v41;
  CFStringRef *ValueAtIndex;
  CFStringRef *v43;
  __CFString *MutableCopy;
  __CFString *v45;
  xpc_object_t v46;
  uint64_t v47;
  const void *v48;
  __CFDictionary *v49;
  const __CFData *v50;
  const __CFData *v51;
  CFTypeID v52;
  __CFData *NormalizedX501Name;
  __CFData *v54;
  __CFDictionary *v55;
  __CFDictionary *v56;
  uint64_t v57;
  const __CFString *v59;
  const __CFDictionary *v60;
  const __CFDictionary *v61;
  __CFString **v62;
  uint64_t context;
  uint64_t v64;
  void (*v65)(uint64_t, const void *, const void *);
  void *v66;
  CFDictionaryRef *v67;
  xpc_object_t objects[3];
  void *values[3];

  values[2] = *(void **)MEMORY[0x1E0C80C00];
  Value = CFDictionaryGetValue(*a1, CFSTR("v_Ref"));
  if (!Value)
  {
    v10 = 0;
    goto LABEL_17;
  }
  v7 = SecItemCopyAttributeDictionary(Value, a2);
  v8 = v7;
  if (!v7)
  {
    SecError(-50, a3, CFSTR("unsupported kSecValueRef in query"));
    v57 = 0;
    goto LABEL_77;
  }
  if ((a2 & 1) != 0)
  {
    context = MEMORY[0x1E0C809B0];
    v64 = 3221225472;
    v65 = __SecItemAttributesPrepare_block_invoke;
    v66 = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    v67 = a1;
    CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)apply_block_2_8228, &context);
    v9 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionaryRemoveValue(v9, CFSTR("toid"));
LABEL_16:
    v17 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionaryRemoveValue(v17, CFSTR("v_Ref"));
    v10 = v8;
    goto LABEL_17;
  }
  v11 = *a1;
  v10 = v7;
  v12 = v11;
  -[__CFDictionary objectForKeyedSubscript:](v10, "objectForKeyedSubscript:", CFSTR("class"));
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v14 = objc_msgSend(v13, "isEqual:", CFSTR("keys"));

  if (v14)
  {
    -[__CFDictionary objectForKeyedSubscript:](v10, "objectForKeyedSubscript:", CFSTR("tkid"));
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0
      && objc_msgSend(v15, "hasPrefix:", CFSTR("com.apple.setoken"))
      && SecItemAttributesSpecifySystemKeychain(v12)
      && (SecItemAttributesSpecifySystemKeychain(v10) & 1) == 0)
    {
      secLogObjForScope("seckey");
      v16 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
      {
        LOWORD(objects[0]) = 0;
        _os_log_fault_impl(&dword_18A900000, v16, OS_LOG_TYPE_FAULT, "Storing non-system-session key into system keychain, will always lead to unusable key when retrieved from keychain!", (uint8_t *)objects, 2u);
      }

    }
  }

  context = MEMORY[0x1E0C809B0];
  v64 = 3221225472;
  v65 = __SecItemAttributesPrepare_block_invoke;
  v66 = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
  v67 = a1;
  CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)apply_block_2_8228, &context);
  if (!CFDictionaryContainsKey(*a1, CFSTR("tkid")))
    goto LABEL_16;
LABEL_17:
  v18 = CFDictionaryGetValue(*a1, CFSTR("accc"));
  if (!v18)
  {
    v29 = 0;
    goto LABEL_22;
  }
  v19 = (uint64_t)v18;
  v20 = CFGetTypeID(v18);
  if (v20 != SecAccessControlGetTypeID())
  {
    SecError(-50, a3, CFSTR("Unexpected type of kSecAttrAccessControl attribute"));
    goto LABEL_85;
  }
  v28 = SecAccessControlCopyData(v19, v21, v22, v23, v24, v25, v26, v27);
  if (!v28)
  {
    SecError(-50, a3, CFSTR("unsupported kSecAttrAccessControl in query"));
LABEL_85:
    v8 = 0;
    v57 = 0;
    if (v10)
      goto LABEL_76;
    goto LABEL_77;
  }
  v29 = v28;
  v30 = SecCFDictionaryCOWGetMutable(a1);
  CFDictionarySetValue(v30, CFSTR("accc"), v29);
LABEL_22:
  -[__CFDictionary objectForKey:](*a1, "objectForKey:", CFSTR("u_AuthCtx"));
  v8 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
  if (v8)
  {
    if (CFDictionaryContainsKey(*a1, CFSTR("u_CredRef")))
    {
      SecError(-50, a3, CFSTR("kSecUseAuthenticationContext cannot be used together with kSecUseCredentialReference"));
      v31 = 0;
      goto LABEL_80;
    }
    -[__CFDictionary externalizedContext](v8, "externalizedContext");
    v31 = (const void *)objc_claimAutoreleasedReturnValue();
    if (!v31)
    {
      SecError(-25293, a3, CFSTR("Unable to get externalizedContext from LAContext"));
      goto LABEL_80;
    }
    v32 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionaryRemoveValue(v32, CFSTR("u_AuthCtx"));
    v33 = SecCFDictionaryCOWGetMutable(a1);
    CFDictionarySetValue(v33, CFSTR("u_CredRef"), v31);
  }
  else
  {
    v31 = 0;
  }
  v34 = (void *)CFDictionaryGetValue(*a1, CFSTR("m_Policy"));
  if (!v34)
    goto LABEL_63;
  v35 = v34;
  v36 = CFGetTypeID(v34);
  if (v36 != SecPolicyGetTypeID())
  {
    v59 = CFSTR("unsupported kSecMatchPolicy in query");
    goto LABEL_79;
  }
  values[0] = v35;
  v37 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)values, 1, MEMORY[0x1E0C9B378]);
  v38 = xpc_array_create(0, 0);
  if (!v38)
  {
    SecError(-108, a3, CFSTR("failed to create xpc_array"));
    if (v37)
      goto LABEL_59;
    goto LABEL_60;
  }
  v62 = a3;
  Count = CFArrayGetCount(v37);
  if (Count < 1)
  {
    if (v37)
      goto LABEL_59;
    goto LABEL_60;
  }
  v40 = Count;
  v60 = v8;
  v61 = v10;
  v41 = 0;
  while (1)
  {
    ValueAtIndex = (CFStringRef *)CFArrayGetValueAtIndex(v37, v41);
    if (ValueAtIndex)
      break;
LABEL_50:
    if (v40 == ++v41)
      goto LABEL_58;
  }
  v43 = ValueAtIndex;
  objects[0] = 0;
  objects[1] = 0;
  MutableCopy = CFStringCreateMutableCopy(0, 0, ValueAtIndex[2]);
  v45 = MutableCopy;
  if (MutableCopy)
  {
    if (v43[3])
    {
      CFStringAppend(MutableCopy, CFSTR("++"));
      CFStringAppend(v45, v43[3]);
    }
    objects[0] = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
    if (!objects[0])
    {
      SecError(-50, v62, CFSTR("failed to create xpc_object from policy oid and name"), v60, v61);
LABEL_54:
      v46 = 0;
      goto LABEL_44;
    }
  }
  else
  {
    objects[0] = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
    if (!objects[0])
    {
      SecError(-50, v62, CFSTR("failed to create xpc_object from policy oid"), v60, v61);
      goto LABEL_54;
    }
  }
  objects[1] = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
  if (objects[1])
  {
    v46 = xpc_array_create(objects, 2uLL);
    if (!v46)
      SecError(-108, v62, CFSTR("failed to create xpc_array for policy"));
  }
  else
  {
    SecError(-50, v62, CFSTR("failed to create xpc_object from policy options"));
    v46 = 0;
  }
  if (objects[0])
    xpc_release(objects[0]);
LABEL_44:
  if (objects[1])
    xpc_release(objects[1]);
  if (v45)
    CFRelease(v45);
  if (v46)
  {
    xpc_array_append_value(v38, v46);
    xpc_release(v46);
    goto LABEL_50;
  }
  xpc_release(v38);
  v38 = 0;
LABEL_58:
  v10 = v61;
  a3 = v62;
  v8 = v60;
  if (v37)
LABEL_59:
    CFRelease(v37);
LABEL_60:
  if (!v38)
  {
    SecError(-26276, a3, CFSTR("Failed to copy XPC policy"), v60, v61);
LABEL_94:

    goto LABEL_80;
  }
  v47 = _CFXPCCreateCFObjectFromXPCObject();
  if (!v47)
  {
    SecError(-26276, a3, CFSTR("Failed to create CFObject from XPC policy"), v60, v61);
    goto LABEL_94;
  }
  v48 = (const void *)v47;
  v49 = SecCFDictionaryCOWGetMutable(a1);
  CFDictionarySetValue(v49, CFSTR("m_Policy"), v48);
  CFRelease(v48);

LABEL_63:
  v50 = (const __CFData *)CFDictionaryGetValue(*a1, CFSTR("issr"));
  if (!v50)
  {
LABEL_69:
    if (CFDictionaryContainsKey(*a1, CFSTR("u_TokenRawItems")))
    {
      v56 = SecCFDictionaryCOWGetMutable(a1);
      CFDictionaryRemoveValue(v56, CFSTR("u_TokenRawItems"));
    }
    v57 = 1;
    if (!v29)
      goto LABEL_73;
LABEL_72:
    CFRelease(v29);
    goto LABEL_73;
  }
  v51 = v50;
  v52 = CFGetTypeID(v50);
  if (v52 == CFDataGetTypeID())
  {
    values[0] = (void *)CFDataGetBytePtr(v51);
    values[1] = (void *)CFDataGetLength(v51);
    memset(objects, 170, sizeof(objects));
    if (!DERDecodeItem((uint64_t)values, (unint64_t *)objects)
      && objects[0] == (xpc_object_t)0x2000000000000010)
    {
      NormalizedX501Name = createNormalizedX501Name((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (uint64_t)&objects[1]);
      if (NormalizedX501Name)
      {
        v54 = NormalizedX501Name;
        v55 = SecCFDictionaryCOWGetMutable(a1);
        CFDictionarySetValue(v55, CFSTR("issr"), v54);
        CFRelease(v54);
      }
    }
    goto LABEL_69;
  }
  v59 = CFSTR("Unexpected type");
LABEL_79:
  SecError(-50, a3, v59, v60, v61);
LABEL_80:
  v57 = 0;
  if (v29)
    goto LABEL_72;
LABEL_73:
  if (v31)
    CFRelease(v31);
  if (v10)
LABEL_76:
    CFRelease(v10);
LABEL_77:

  return v57;
}

uint64_t SecSecurityClientGet()
{
  dispatch_once_t *onceTokenThreadLocalClient;
  uint64_t v1;
  void (*v2)(uint64_t);

  if (SecSecurityClientGet_onceToken != -1)
    dispatch_once(&SecSecurityClientGet_onceToken, &__block_literal_global_713);
  onceTokenThreadLocalClient = (dispatch_once_t *)SecSecurityClientGet_onceTokenThreadLocalClient();
  if (*onceTokenThreadLocalClient != -1)
    dispatch_once(onceTokenThreadLocalClient, &__block_literal_global_2);
  if (gSecurityd && *(_QWORD *)(gSecurityd + 688))
  {
    v1 = threadLocalClient(&threadLocalClient);
    v2(v1);
  }
  return threadLocalClient(&threadLocalClient);
}

uint64_t securityd_send_sync_and_do(unsigned int a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  xpc_object_t message;
  void *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;

  message = securityd_create_message(a1, a2);
  if (!message)
    return 0;
  v8 = message;
  if ((!a3 || (*(unsigned int (**)(uint64_t, xpc_object_t, CFTypeRef *))(a3 + 16))(a3, message, a2))
    && (v9 = securityd_message_with_reply_sync(v8, (uint64_t)a2)) != 0)
  {
    v10 = (void *)v9;
    if (securityd_message_no_error(v9, (CFErrorRef *)a2))
    {
      if (a4)
        v11 = (*(uint64_t (**)(uint64_t, void *, CFTypeRef *))(a4 + 16))(a4, v10, a2);
      else
        v11 = 1;
    }
    else
    {
      v11 = 0;
    }
    xpc_release(v10);
  }
  else
  {
    v11 = 0;
  }
  xpc_release(v8);
  return v11;
}

uint64_t securityd_message_no_error(uint64_t result, CFErrorRef *a2)
{
  xpc_object_t value;
  CFErrorRef CFErrorWithXPCObject;
  CFErrorRef v5;

  if (result)
  {
    value = xpc_dictionary_get_value((xpc_object_t)result, "error");
    if (value)
    {
      CFErrorWithXPCObject = SecCreateCFErrorWithXPCObject(value);
      v5 = CFErrorWithXPCObject;
      if (a2)
      {
        result = 0;
        *a2 = v5;
      }
      else
      {
        if (CFErrorWithXPCObject)
          CFRelease(CFErrorWithXPCObject);
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

xpc_object_t securityd_create_message(unsigned int a1, CFTypeRef *a2)
{
  xpc_object_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  xpc_object_t v8;
  char v10;

  v4 = xpc_dictionary_create(0, 0, 0);
  v8 = v4;
  if (v4)
    xpc_dictionary_set_uint64(v4, "operation", a1);
  else
    SecCFCreateErrorWithFormat(3, (const __CFString *)sSecXPCErrorDomain, 0, a2, v5, CFSTR("xpc_dictionary_create returned NULL"), v6, v7, v10);
  return v8;
}

uint64_t securityd_message_with_reply_sync(void *a1, uint64_t a2)
{
  uint64_t uint64;
  uint64_t v5;
  _xpc_connection_s *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v12;

  uint64 = xpc_dictionary_get_uint64(a1, "operation");
  v5 = securityd_message_is_for_system_keychain(a1);
  v12 = 6;
  v6 = securityd_connection_for_operation(uint64, v5, &v12);
  switch(v12)
  {
    case 0:
      v7 = a1;
      v8 = uint64;
      v9 = v5;
      v10 = a2;
      break;
    case 1:
      v7 = a1;
      v8 = uint64;
      v9 = v5;
      v10 = a2;
      break;
    case 2:
      v7 = a1;
      v8 = uint64;
      v9 = v5;
      v10 = a2;
      break;
    case 3:
      v7 = a1;
      v8 = uint64;
      v9 = v5;
      v10 = a2;
      break;
    case 4:
      v7 = a1;
      v8 = uint64;
      v9 = v5;
      v10 = a2;
      break;
    case 5:
      v7 = a1;
      v8 = uint64;
      v9 = v5;
      v10 = a2;
      break;
    default:
      v7 = a1;
      v8 = uint64;
      v9 = v5;
      v10 = a2;
      break;
  }
  return security_fw_CALLING_SECD_OR_SECURITYD(v7, v6, v8, v9, v10);
}

uint64_t securityd_message_is_for_system_keychain(void *a1)
{
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  CFTypeRef v4;
  unsigned int BoolValue;
  int v6;
  unsigned int v7;
  NSObject *v8;
  NSObject *v9;
  const char *v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  CFTypeRef cf;
  uint8_t buf[4];
  _BYTE v17[10];
  __int16 v18;
  unsigned int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (_SecSystemKeychainAlwaysIsEnabled_onceToken != -1)
    dispatch_once(&_SecSystemKeychainAlwaysIsEnabled_onceToken, &__block_literal_global_2582);
  if (_SecSystemKeychainAlwaysIsEnabled_ffSystemKeychainAlwaysSupported)
  {
    cf = 0;
    v2 = (const __CFDictionary *)SecXPCDictionaryCopyDictionaryAndPossiblyMutateMessage(0, a1, "query", (__CFString **)&cf);
    if (v2)
    {
      v3 = v2;
      v4 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v4);
      }
      BoolValue = getBoolValue(v3, CFSTR("u_SystemKeychainAlways"));
      if (SecIsEduMode_once != -1)
        dispatch_once(&SecIsEduMode_once, &__block_literal_global_13303);
      v6 = SecIsEduMode_result;
      v7 = getBoolValue(v3, CFSTR("u_SystemKeychain"));
      v8 = secLogObjForScope("xpc");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)v17 = BoolValue;
        *(_WORD *)&v17[4] = 1024;
        *(_DWORD *)&v17[6] = v6;
        v18 = 1024;
        v19 = v7;
        _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "flagAlways:%{BOOL}d inEduMode:%{BOOL}d flagOld:%{BOOL}d", buf, 0x14u);
        if (BoolValue)
          goto LABEL_11;
      }
      else if (BoolValue)
      {
LABEL_11:
        v9 = secLogObjForScope("xpc");
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
LABEL_23:
          v12 = 1;
          goto LABEL_27;
        }
        *(_WORD *)buf = 0;
        v10 = "kSecUseSystemKeychainAlways… present, using system keychain";
LABEL_22:
        _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
        goto LABEL_23;
      }
      v13 = secLogObjForScope("xpc");
      v9 = v13;
      if ((v6 & v7) != 1)
      {
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)buf = 0;
          _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "not using system keychain", buf, 2u);
        }
        v12 = 0;
        goto LABEL_27;
      }
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        goto LABEL_23;
      *(_WORD *)buf = 0;
      v10 = "kSecUseSystemKeychain present, using system keychain";
      goto LABEL_22;
    }
    v11 = secLogObjForScope("xpc");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)v17 = cf;
      _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "no query dict to determine whether for system keychain: %@", buf, 0xCu);
    }
    v3 = (const __CFDictionary *)cf;
    if (cf)
    {
      v12 = 0;
      cf = 0;
LABEL_27:
      CFRelease(v3);
      return v12;
    }
  }
  return 0;
}

xpc_object_t security_fw_send_message_with_reply_sync_inner(xpc_object_t message, xpc_connection_t connection, unsigned int a3, char a4, CFTypeRef *a5)
{
  void *v10;
  char v11;
  int v12;
  xpc_object_t v13;
  xpc_object_t v14;
  BOOL v15;
  xpc_object_t v17;

  v10 = 0;
  v11 = 1;
  v12 = -3;
  v13 = (xpc_object_t)MEMORY[0x1E0C81258];
  do
  {
    if ((v11 & 1) == 0)
      xpc_release(v10);
    v14 = xpc_connection_send_message_with_reply_sync(connection, message);
    v11 = 0;
    v15 = v14 != v13 || v12++ == 0;
    v10 = v13;
  }
  while (!v15);
  v17 = v14;
  _securityd_process_message_reply(&v17, a5, (uint64_t)connection, a3);
  return_securityd_connection_to_pool(a3, a4, connection);
  return v17;
}

void _securityd_process_message_reply(xpc_object_t *a1, CFTypeRef *a2, uint64_t a3, unsigned int a4)
{
  NSObject *v9;
  int v10;
  const char *v11;
  CFIndex v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  const __CFString *v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (MEMORY[0x18D7718B8](*a1) == MEMORY[0x1E0C81310])
  {
    if (*a1 == (xpc_object_t)MEMORY[0x1E0C81258] || *a1 == (xpc_object_t)MEMORY[0x1E0C81260])
    {
      v9 = secLogObjForScope("SecCritical");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = is_trust_operation(a4);
        v11 = "securityd";
        if (v10)
          v11 = "trustd";
        *(_DWORD *)buf = 136315394;
        v20 = v11;
        v21 = 1024;
        v22 = 4;
        _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "Failed to talk to %s after %d attempts.", buf, 0x12u);
      }
      v12 = 3;
    }
    else
    {
      v12 = 4;
    }
    v13 = (void *)MEMORY[0x18D771774](a3);
    xpc_dictionary_get_string(*a1, (const char *)*MEMORY[0x1E0C81270]);
    v17 = (void *)xpc_connection_copy_invalidation_reason();
    if (v17)
      v18 = CFSTR("%s: %s - %s");
    else
      v18 = CFSTR("%s: %s");
    SecCFCreateErrorWithFormat(v12, (const __CFString *)sSecXPCErrorDomain, 0, a2, v14, v18, v15, v16, (char)v13);
    free(v13);
    free(v17);
    xpc_release(*a1);
    *a1 = 0;
  }
}

_xpc_connection_s *securityd_connection_for_operation(unsigned int a1, int a2, _DWORD *a3)
{
  char v5;
  _xpc_connection_s *connection;
  const char *name;
  int v9;
  int v10;
  int v11;
  unsigned int i;
  int v13;
  int foreground_uid;
  NSObject *v15;
  int v16;
  NSObject *v17;
  const char *v18;
  int v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  NSObject *v24;
  NSObject *v25;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint8_t buf[8];
  uint64_t v32;
  void (*v33)(uint64_t);
  void *v34;
  uint64_t *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v5 = is_trust_operation(a1);
  if (a1 - 100 <= 0x21 && ((1 << (a1 - 100)) & 0x220000003) != 0 || a1 - 4 < 3)
  {
    if ((v5 & 1) != 0)
    {
      *a3 = 5;
      if (trustd_system_connection_once != -1)
        dispatch_once(&trustd_system_connection_once, &__block_literal_global_42);
      return (_xpc_connection_s *)sTrustdSystemInstanceConnection;
    }
    goto LABEL_17;
  }
  if ((v5 & 1) == 0)
  {
LABEL_17:
    v10 = 1;
    if ((a1 - 95 > 4 || ((1 << (a1 - 95)) & 0x13) == 0) && a1 != 8)
      v10 = 0;
    v11 = 0;
    for (i = 1; ; ++i)
    {
      v13 = v11;
      if (v10)
        break;
      if (a2)
      {
        *a3 = 2;
        v17 = secLogObjForScope("xpc");
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18A900000, v17, OS_LOG_TYPE_DEFAULT, "using system keychain XPC", buf, 2u);
        }
        v18 = "com.apple.securityd.systemkeychain";
LABEL_33:
        v19 = -1;
        goto LABEL_44;
      }
      *a3 = 0;
      if (_securityd_connection_onceToken != -1)
        dispatch_once(&_securityd_connection_onceToken, &__block_literal_global_46);
      v27 = 0;
      v28 = &v27;
      v29 = 0x2000000000;
      v30 = 0;
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      v32 = 0x40000000;
      v33 = ___securityd_connection_block_invoke_2;
      v34 = &unk_1E1FCBB28;
      v35 = &v27;
      dispatch_sync((dispatch_queue_t)sSecuritydConnectionsQueue, buf);
      connection = (_xpc_connection_s *)v28[3];
      _Block_object_dispose(&v27, 8);
      if (connection)
        goto LABEL_46;
LABEL_45:
      usleep(0x9C4u);
LABEL_46:
      ++v11;
      if (100 * (i / 0x64) - 1 == v13)
      {
        v22 = secLogObjForScope("SecWarning");
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v11;
          _os_log_impl(&dword_18A900000, v22, OS_LOG_TYPE_DEFAULT, "xpc: have been trying %d times to get a securityd connection", buf, 8u);
        }
      }
      if (connection)
        return connection;
    }
    *a3 = 1;
    if ((xpc_user_sessions_enabled() & 1) == 0)
    {
      v18 = "com.apple.securityd";
      goto LABEL_33;
    }
    LODWORD(v27) = 0;
    foreground_uid = xpc_user_sessions_get_foreground_uid();
    if ((_DWORD)v27)
    {
      v15 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v27;
        _os_log_impl(&dword_18A900000, v15, OS_LOG_TYPE_DEFAULT, "xpc: could not get foreground uid %d", buf, 8u);
      }
      v16 = -1;
    }
    else
    {
      v16 = foreground_uid;
      v20 = secLogObjForScope("xpc");
      v21 = v20;
      if (v16 == 501)
      {
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = 501;
          _os_log_debug_impl(&dword_18A900000, v21, OS_LOG_TYPE_DEBUG, "user sessions enabled, targeting %d", buf, 8u);
        }
      }
      else if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v16;
        _os_log_impl(&dword_18A900000, v21, OS_LOG_TYPE_DEFAULT, "user sessions enabled, targeting %d", buf, 8u);
      }
    }
    v18 = "com.apple.securityd";
    v19 = v16;
LABEL_44:
    connection = securityd_create_connection(v18, v19);
    if (connection)
      goto LABEL_46;
    goto LABEL_45;
  }
  if ((a1 - 95 > 4 || ((1 << (a1 - 95)) & 0x13) == 0) && a1 != 8)
  {
    *a3 = 3;
    if (trustd_connection_once != -1)
      dispatch_once(&trustd_connection_once, &__block_literal_global_33);
    return (_xpc_connection_s *)sTrustdConnection;
  }
  *a3 = 4;
  if (trustd_connection_once != -1)
    dispatch_once(&trustd_connection_once, &__block_literal_global_33);
  name = xpc_connection_get_name((xpc_connection_t)sTrustdConnection);
  if ((xpc_user_sessions_enabled() & 1) != 0)
  {
    LODWORD(v27) = 0;
    v9 = xpc_user_sessions_get_foreground_uid();
    v23 = v9;
    v24 = secLogObjForScope("xpc");
    v25 = v24;
    if (v23 == 501)
    {
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = 501;
        _os_log_debug_impl(&dword_18A900000, v25, OS_LOG_TYPE_DEBUG, "user sessions enabled, targeting %d", buf, 8u);
      }
    }
    else if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v23;
      _os_log_impl(&dword_18A900000, v25, OS_LOG_TYPE_DEFAULT, "user sessions enabled, targeting %d", buf, 8u);
    }
    return securityd_create_connection(name, v23);
  }
  return securityd_create_connection(name, -1);
}

void return_securityd_connection_to_pool(unsigned int a1, char a2, _xpc_connection_s *a3)
{
  int v6;
  unsigned int v7;
  NSObject *v8;
  const char *v9;
  _QWORD block[5];
  uint8_t buf[4];
  _xpc_connection_s *v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v6 = is_trust_operation(a1);
  v7 = a1 - 95;
  if (!v6)
  {
    if ((v7 > 4 || ((1 << v7) & 0x13) == 0) && a1 != 8 && (a2 & 1) == 0)
    {
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __return_securityd_connection_to_pool_block_invoke;
      block[3] = &__block_descriptor_tmp_56;
      block[4] = a3;
      dispatch_sync((dispatch_queue_t)sSecuritydConnectionsQueue, block);
      return;
    }
    v8 = secLogObjForScope("xpc");
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      goto LABEL_12;
    *(_DWORD *)buf = 134217984;
    v12 = a3;
    v9 = "cleaning up unpooled xpc conn %p";
    goto LABEL_16;
  }
  if (v7 <= 4 && ((1 << v7) & 0x13) != 0 || a1 == 8)
  {
    v8 = secLogObjForScope("xpc");
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
LABEL_12:
      xpc_connection_cancel(a3);
      xpc_release(a3);
      return;
    }
    *(_DWORD *)buf = 134217984;
    v12 = a3;
    v9 = "cleaning up unpooled xpc conn to trustd %p";
LABEL_16:
    _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, v9, buf, 0xCu);
    goto LABEL_12;
  }
}

uint64_t is_trust_operation(unsigned int a1)
{
  uint64_t result;

  result = 1;
  if ((a1 - 100 > 0x23 || ((1 << (a1 - 100)) & 0xE7FFF8007) == 0)
    && (a1 > 0x1A || ((1 << a1) & 0x6980170) == 0))
  {
    return 0;
  }
  return result;
}

size_t SecXPCDictionarySetPListWithRepair(void *a1, const char *a2, const __CFString *a3, __CFString **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t result;
  size_t v13;
  UInt8 *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;

  if (!a3)
    return SecError(-50, a4, CFSTR("object for key %s is NULL"), a2);
  result = der_sizeof_plist(a3, (CFTypeRef *)a4, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
  if (result)
  {
    v13 = result;
    v14 = (UInt8 *)malloc_type_malloc(result, 0x91A96E61uLL);
    v15 = (unint64_t)&v14[v13];
    v19 = (const void *)der_encode_plist_repair(a3, (CFTypeRef *)a4, 0, v14, v15, v16, v17, v18);
    if (v19 && v15 > (unint64_t)v19)
    {
      xpc_dictionary_set_data(a1, a2, v19, v15 - (_QWORD)v19);
      free(v14);
      return 1;
    }
    else
    {
      free(v14);
      return 0;
    }
  }
  return result;
}

__CFData *SecAccessControlCopyData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v9;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v9 = der_sizeof_plist(*(const __CFString **)(a1 + 16), 0, a3, a4, a5, a6, a7, a8);
  Mutable = CFDataCreateMutable(0, v9);
  CFDataSetLength(Mutable, v9);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (!der_encode_plist_repair(*(const __CFString **)(a1 + 16), 0, 0, MutableBytePtr, (unint64_t)&MutableBytePtr[v9], v12, v13, v14)&& Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t SecItemResultProcess(const __CFDictionary *a1, const __CFDictionary *a2, void *a3, const void *a4, CFTypeRef *a5, __CFString **a6)
{
  id v11;
  uint64_t v12;
  CFTypeID v13;
  CFIndex Count;
  CFIndex v15;
  const void *ValueAtIndex;
  const void *v17;
  CFErrorDomain Domain;
  CFTypeRef v19;
  CFErrorRef err;
  void *value;

  v11 = a3;
  v12 = 1;
  if (!a4 || !a5)
    goto LABEL_22;
  v13 = CFGetTypeID(a4);
  if (v13 != CFArrayGetTypeID())
  {
    if (!SecItemResultCopyPrepared(a4, v11, a1, a2, a5, a6))
      goto LABEL_28;
    goto LABEL_21;
  }
  Count = CFArrayGetCount((CFArrayRef)a4);
  *a5 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (Count < 1)
  {
LABEL_21:
    v12 = 1;
    goto LABEL_22;
  }
  v15 = 0;
  while (1)
  {
    err = 0;
    value = (void *)0xAAAAAAAAAAAAAAAALL;
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a4, v15);
    if ((SecItemResultCopyPrepared(ValueAtIndex, v11, a1, a2, (CFTypeRef *)&value, (__CFString **)&err) & 1) != 0)
    {
      v17 = value;
      if (value)
      {
        CFArrayAppendValue((CFMutableArrayRef)*a5, value);
LABEL_17:
        CFRelease(v17);
        goto LABEL_18;
      }
      goto LABEL_18;
    }
    if (!err)
      goto LABEL_28;
    if (!CryptoTokenKitLibraryCore())
      break;
    if (!getTKErrorDomainSymbolLoc())
      break;
    Domain = CFErrorGetDomain(err);
    getTKErrorDomain();
    if (!CFEqual(Domain, v19) || CFErrorGetCode(err) != -7 && CFErrorGetCode(err) != -6)
      break;
    v17 = err;
    if (err)
    {
      err = 0;
      goto LABEL_17;
    }
LABEL_18:
    if (Count == ++v15)
      goto LABEL_21;
  }
  if (err)
  {
    if (a6 && !*a6)
      *a6 = (__CFString *)err;
    else
      CFRelease(err);
  }
LABEL_28:
  v12 = 0;
LABEL_22:

  return v12;
}

uint64_t SecItemResultCopyPrepared(const void *a1, void *a2, const __CFDictionary *a3, const __CFDictionary *a4, CFTypeRef *a5, __CFString **a6)
{
  id v10;
  const __CFBoolean *v11;
  _BOOL4 v12;
  const __CFBoolean *v13;
  _BOOL4 v14;
  const __CFBoolean *v15;
  const __CFBoolean *v16;
  id v17;
  __CFString *v18;
  _BOOL4 v19;
  _BOOL4 v20;
  const __CFBoolean *v21;
  const void *v22;
  const __CFDictionary *v23;
  CFTypeRef v24;
  CFTypeRef v25;
  const void *v26;
  CFTypeID v27;
  __CFString *v28;
  CFTypeID v29;
  const void *v30;
  const void *v31;
  CFTypeID v32;
  BOOL v33;
  CFTypeID v34;
  const __CFDictionary *v35;
  const __CFDictionary *v36;
  const void *v37;
  const void *v38;
  CFTypeID v39;
  const void *v40;
  CFTypeID v41;
  const void *v42;
  const void *v43;
  CFTypeID v44;
  const void *v45;
  const void *v46;
  int v47;
  CFTypeID v48;
  CFTypeID v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  __CFDictionary *MutableCopy;
  __CFDictionary *v58;
  const void *v59;
  BOOL v60;
  char v61;
  const void *v62;
  const void *v63;
  void *v64;
  CFTypeID v65;
  const void *v66;
  CFTypeID v67;
  const void *v68;
  const void *v69;
  _QWORD *v70;
  const void *v71;
  void *v72;
  void *v73;
  uint64_t v74;
  void *v75;
  const void *v76;
  id v77;
  const void *v78;
  void *v80;
  id v81;
  void *v82;
  id v83;
  void *v84;
  __CFString *v85;
  __CFString *v86;
  __CFString *v87;
  uint64_t v88;
  void *v89;
  void *v90;
  __CFString *theString;
  __CFString *theStringa;
  char v93;
  CFTypeRef *v94;
  uint64_t v95;
  CFTypeRef cf;
  _BOOL4 v98;
  _BOOL4 v99;
  _BOOL4 v100;
  _BOOL4 v101;
  _BOOL4 v102;
  void *value;
  id v104;
  id v105;
  CFDictionaryRef v106;
  CFTypeRef v107;

  v10 = a2;
  v106 = a4;
  v107 = 0;
  v11 = (const __CFBoolean *)CFDictionaryGetValue(a3, CFSTR("r_Ref"));
  if (v11)
    v12 = CFBooleanGetValue(v11) != 0;
  else
    v12 = 0;
  v13 = (const __CFBoolean *)CFDictionaryGetValue(a3, CFSTR("r_Data"));
  if (v13)
    v14 = CFBooleanGetValue(v13) != 0;
  else
    v14 = 0;
  v15 = (const __CFBoolean *)CFDictionaryGetValue(a3, CFSTR("r_Attributes"));
  if (v15)
    v101 = CFBooleanGetValue(v15) != 0;
  else
    v101 = 0;
  v16 = (const __CFBoolean *)CFDictionaryGetValue(a3, CFSTR("r_PersistentRef"));
  if (v16)
    v102 = CFBooleanGetValue(v16) != 0;
  else
    v102 = 0;
  v98 = v14;
  v95 = (uint64_t)v10;
  if (v10)
  {
    v17 = v10;
    v18 = 0;
    v19 = 1;
    v20 = 1;
  }
  else
  {
    v27 = CFGetTypeID(a1);
    if (v27 == CFDictionaryGetTypeID())
    {
      v28 = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("tkid"));
      v18 = v28;
      if (v28 && (v29 = CFGetTypeID(v28), v29 != CFStringGetTypeID())
        || (v19 = v18 != 0, v30 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("certtkid")), (v31 = v30) != 0)
        && (v32 = CFGetTypeID(v30), v33 = v32 == CFStringGetTypeID(), v14 = v98, !v33))
      {
        SecError(-50, a6, CFSTR("Unexpected type"));
        v73 = 0;
        v74 = 0;
        v75 = 0;
        goto LABEL_148;
      }
      v20 = v31 != 0;
      if (v31)
        goto LABEL_15;
    }
    else
    {
      v20 = 0;
      v19 = 0;
      v18 = 0;
    }
    if (!v19)
    {
      if (!v14 && !v12)
      {
        theString = v18;
        v99 = v12;
        v94 = (CFTypeRef *)a6;
        v20 = 0;
        v22 = 0;
        v23 = 0;
        v24 = 0;
        v25 = 0;
        v26 = 0;
        v75 = 0;
        v93 = 0;
        goto LABEL_58;
      }
      goto LABEL_34;
    }
  }
LABEL_15:
  v21 = (const __CFBoolean *)CFDictionaryGetValue(a3, CFSTR("u_TokenRawItems"));
  if (!v21 || !CFBooleanGetValue(v21))
  {
    if (v14 || v12)
      goto LABEL_35;
    if (v19)
    {
      v19 = 1;
      if (v101)
        goto LABEL_35;
      theString = v18;
      v93 = 1;
      v99 = v12;
      v94 = (CFTypeRef *)a6;
    }
    else
    {
      theString = v18;
      v99 = v12;
      v94 = (CFTypeRef *)a6;
      v93 = 0;
    }
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    goto LABEL_57;
  }
  v19 = 0;
  if (!v14 && !v12)
  {
    theString = v18;
    v99 = v12;
    v94 = (CFTypeRef *)a6;
    v20 = 0;
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v93 = 0;
LABEL_57:
    v75 = v10;
    goto LABEL_58;
  }
LABEL_34:
  v20 = v19;
LABEL_35:
  theString = v18;
  v34 = CFGetTypeID(a1);
  v93 = v19;
  if (v34 == CFDictionaryGetTypeID())
  {
    v24 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("v_Data"));
    if (!v24)
      goto LABEL_49;
  }
  else
  {
    v24 = a1;
    if (!a1)
    {
LABEL_49:
      v94 = (CFTypeRef *)a6;
      v22 = 0;
      v36 = 0;
      v25 = 0;
      v26 = 0;
      v75 = v10;
LABEL_50:
      if (!v101)
      {
        cf = v25;
        if (!v102)
        {
          if (v12)
          {
            v99 = v12;
            v89 = v75;
            v45 = v22;
            v46 = v26;
            v76 = 0;
            v47 = 1;
            v23 = v36;
            goto LABEL_72;
          }
          if (v24)
            CFRetain(v24);
          v78 = 0;
          v77 = 0;
          v76 = 0;
          *a5 = v24;
          goto LABEL_131;
        }
LABEL_60:
        v48 = CFGetTypeID(a1);
        if (v48 == CFDictionaryGetTypeID())
        {
          v76 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("v_PersistentRef"));
          v14 = v98;
          if (!v76)
            goto LABEL_66;
        }
        else
        {
          v76 = a1;
          v14 = v98;
          if (!a1)
          {
LABEL_66:
            if (v101 || v14 || v12)
            {
              v99 = v12;
              v23 = v36;
LABEL_68:
              if (v99 || v101)
              {
                v89 = v75;
                v45 = v22;
                v46 = v26;
                v47 = 1;
              }
              else
              {
                if (!v14 || !v102)
                {
                  v78 = 0;
                  v77 = 0;
                  *a5 = 0;
                  v74 = 1;
                  v36 = v23;
                  if (!v23)
                    goto LABEL_133;
                  goto LABEL_132;
                }
                v89 = v75;
                v45 = v22;
                v46 = v26;
                v47 = 0;
              }
LABEL_72:
              v49 = CFGetTypeID(a1);
              if (v49 == CFDictionaryGetTypeID())
                MutableCopy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)a1);
              else
                MutableCopy = CFDictionaryCreateForCFTypes(0, v50, v51, v52, v53, v54, v55, v56, 0, v88);
              v58 = MutableCopy;
              *a5 = MutableCopy;
              if (v98)
              {
                v59 = v24;
                if (v24)
                {
LABEL_77:
                  CFDictionarySetValue(MutableCopy, CFSTR("v_Data"), v59);
                  goto LABEL_82;
                }
              }
              else
              {
                v59 = v24;
                v60 = v99;
                if (!v24)
                  v60 = 0;
                if (v60)
                  goto LABEL_77;
              }
              CFDictionaryRemoveValue(MutableCopy, CFSTR("v_Data"));
LABEL_82:
              v61 = !v102;
              if (!v76)
                v61 = 1;
              if ((v61 & 1) != 0)
              {
                CFDictionaryRemoveValue(v58, CFSTR("v_PersistentRef"));
                if (!v47)
                  goto LABEL_86;
              }
              else
              {
                CFDictionarySetValue(v58, CFSTR("v_PersistentRef"), v76);
                if (!v47)
                {
LABEL_86:
                  v77 = 0;
                  v78 = 0;
                  v36 = v23;
                  v26 = v46;
                  v22 = v45;
                  v75 = v89;
                  goto LABEL_115;
                }
              }
              if (v20 && (v62 = CFDictionaryGetValue(v58, CFSTR("class"))) != 0 && CFEqual(v62, CFSTR("idnt")))
              {
                v63 = CFDictionaryGetValue(v58, CFSTR("certdata"));
                v26 = v46;
                if (v63)
                {
                  v36 = SecTokenItemValueCopy(v63, v94);
                  if (v23)
                    CFRelease(v23);
                  v22 = v45;
                  if (!v36)
                  {
                    v74 = 0;
                    v77 = 0;
                    v78 = 0;
                    v75 = v89;
                    goto LABEL_133;
                  }
                  v64 = (void *)CFDictionaryGetValue(v36, CFSTR("data"));
                  v77 = v64;
                  v75 = v89;
                  if (!v64 || (CFRetain(v64), v65 = CFGetTypeID(v77), v65 == CFDataGetTypeID()))
                  {
                    v66 = CFDictionaryGetValue(v36, CFSTR("oid"));
                    v78 = v66;
                    if (v66)
                    {
                      CFRetain(v66);
                      v67 = CFGetTypeID(v78);
                      if (v67 != CFDataGetTypeID())
                      {
                        SecError(-50, (__CFString **)v94, CFSTR("Unexpected type"));
                        v74 = 0;
                        goto LABEL_132;
                      }
                    }
                    if (v77)
                    {
LABEL_100:
                      CFDictionarySetValue(v58, CFSTR("certdata"), v77);
LABEL_106:
                      if ((v93 & 1) != 0 || (v68 = CFDictionaryGetValue(v58, CFSTR("accc")), v22 == v68))
                      {
                        if (!v22)
                          goto LABEL_115;
                      }
                      else
                      {
                        v69 = v68;
                        if (!v68)
                        {
                          CFRelease(v22);
                          v22 = 0;
                          goto LABEL_115;
                        }
                        CFRetain(v68);
                        if (v22)
                          CFRelease(v22);
                        v22 = v69;
                      }
                      v70 = SecAccessControlCreateFromData((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (const __CFData *)v22, (__CFString **)v94);
                      if (!v70)
                        goto LABEL_184;
                      v71 = v70;
                      CFDictionarySetValue(v58, CFSTR("accc"), v70);
                      CFRelease(v71);
LABEL_115:
                      if (!v99)
                        goto LABEL_131;
                      value = (void *)0xAAAAAAAAAAAAAAAALL;
                      if (SecTokenItemCreateFromAttributes(v58, v106, v75, v26, (uint64_t *)&value, (__CFString **)v94))
                      {
                        v72 = value;
                        if (v101 || v98 || v102)
                        {
                          if (value)
                          {
                            CFDictionarySetValue(v58, CFSTR("v_Ref"), value);
                            CFRelease(v72);
                            if (!v98)
                              CFDictionaryRemoveValue(v58, CFSTR("v_Data"));
                          }
                        }
                        else
                        {
                          if (*a5)
                            CFRelease(*a5);
                          *a5 = v72;
                        }
                        goto LABEL_131;
                      }
LABEL_184:
                      v74 = 0;
                      if (!v36)
                      {
LABEL_133:
                        if (cf)
                          CFRelease(cf);
                        if (v78)
                          CFRelease(v78);
                        if (v77)
                          CFRelease(v77);
                        if (v22)
                          CFRelease(v22);
                        if (!v24)
                          goto LABEL_143;
                        goto LABEL_142;
                      }
LABEL_132:
                      CFRelease(v36);
                      goto LABEL_133;
                    }
                    if (!v95)
                    {
                      SecTokenSessionCreate(theString, &v106, (__CFString **)v94);
                      v95 = objc_claimAutoreleasedReturnValue();
                      if (!v95)
                      {
                        v74 = 0;
                        v77 = 0;
                        v95 = 0;
                        goto LABEL_132;
                      }
                    }
                    v104 = 0;
                    objc_msgSend(v89, "objectForObjectID:error:", v78, &v104);
                    v84 = (void *)objc_claimAutoreleasedReturnValue();
                    v85 = (__CFString *)v104;
                    v86 = v85;
                    if (!v94 || v84)
                    {
                      if (v84)
                      {
                        objc_msgSend(v84, "value");
                        theStringa = v86;
                        v77 = (id)objc_claimAutoreleasedReturnValue();

                        if (!v77)
                        {
                          CFDictionaryRemoveValue(v58, CFSTR("certdata"));
                          goto LABEL_106;
                        }
                        goto LABEL_100;
                      }
                    }
                    else
                    {
                      v87 = v85;

                      *v94 = v87;
                    }

                    v74 = 0;
                    v77 = 0;
                    goto LABEL_132;
                  }
                  SecError(-50, (__CFString **)v94, CFSTR("Unexpected type"));
                  v74 = 0;
LABEL_165:
                  v78 = 0;
                  goto LABEL_132;
                }
                v78 = 0;
                v77 = 0;
                v36 = v23;
              }
              else
              {
                v78 = 0;
                v77 = 0;
                v36 = v23;
                v26 = v46;
              }
              v22 = v45;
              v75 = v89;
              goto LABEL_106;
            }
            if (v76)
              CFRetain(v76);
            v78 = 0;
            v77 = 0;
            *a5 = v76;
LABEL_131:
            v74 = 1;
            if (!v36)
              goto LABEL_133;
            goto LABEL_132;
          }
        }
        CFRetain(v76);
        goto LABEL_66;
      }
      v99 = v12;
      v23 = v36;
LABEL_58:
      cf = v25;
      if (!v102)
      {
        v76 = 0;
        goto LABEL_68;
      }
      v36 = v23;
      v12 = v99;
      goto LABEL_60;
    }
  }
  CFRetain(v24);
  if (!v19)
    goto LABEL_49;
  v35 = SecTokenItemValueCopy(v24, (CFTypeRef *)a6);
  if (v35)
  {
    v36 = v35;
    v37 = CFDictionaryGetValue(v35, CFSTR("oid"));
    v26 = v37;
    if (v37)
    {
      CFRetain(v37);
      v38 = v26;
      v39 = CFGetTypeID(v26);
      v33 = v39 == CFDataGetTypeID();
      v26 = v38;
      if (!v33)
      {
        SecError(-50, a6, CFSTR("Unexpected type"));
        v74 = 0;
        v75 = v10;
        v76 = 0;
        v77 = 0;
        v78 = 0;
        cf = 0;
        v22 = 0;
        goto LABEL_132;
      }
    }
    v40 = CFDictionaryGetValue(v36, CFSTR("ac"));
    v22 = v40;
    if (v40 && (CFRetain(v40), v41 = CFGetTypeID(v22), v41 != CFDataGetTypeID()))
    {
      SecError(-50, a6, CFSTR("Unexpected type"));
      v74 = 0;
      v75 = v10;
    }
    else
    {
      v42 = CFDictionaryGetValue(v36, CFSTR("data"));
      if (v42)
      {
        v43 = v42;
        CFRetain(v42);
        cf = v43;
        v44 = CFGetTypeID(v43);
        if (v44 != CFDataGetTypeID())
        {
          SecError(-50, a6, CFSTR("Unexpected type"));
          v74 = 0;
          v75 = v10;
          v76 = 0;
          v77 = 0;
          goto LABEL_165;
        }
        v94 = (CFTypeRef *)a6;
        v75 = v10;
        goto LABEL_168;
      }
      v94 = (CFTypeRef *)a6;
      v14 = v98;
      if (!v98 && !v12)
      {
        cf = 0;
        v75 = v10;
        goto LABEL_173;
      }
      v100 = v12;
      v75 = v10;
      if (!v10)
      {
        SecTokenSessionCreate(theString, &v106, (__CFString **)v94);
        v75 = (void *)objc_claimAutoreleasedReturnValue();
        if (!v75)
        {
          v74 = 0;
          v76 = 0;
          v77 = 0;
          v78 = 0;
          v95 = 0;
          cf = 0;
          goto LABEL_132;
        }
      }
      v105 = 0;
      objc_msgSend(v75, "objectForObjectID:error:", v26, &v105);
      v80 = (void *)objc_claimAutoreleasedReturnValue();
      v81 = v105;
      v82 = v81;
      if (!v94 || v80)
      {
        if (v80)
        {
          objc_msgSend(v80, "value");
          v90 = v82;
          v83 = (id)objc_claimAutoreleasedReturnValue();

          cf = v83;
          v12 = v100;
LABEL_168:
          v14 = v98;
          if (v24 == cf)
          {
            v25 = v24;
            goto LABEL_50;
          }
          if (cf)
            CFRetain(cf);
          else
            cf = 0;
LABEL_173:
          CFRelease(v24);
          v25 = cf;
          v24 = cf;
          goto LABEL_50;
        }
      }
      else
      {
        *v94 = v81;
      }

      v74 = 0;
    }
    v76 = 0;
    v77 = 0;
    v78 = 0;
    cf = 0;
    goto LABEL_132;
  }
  v26 = 0;
  v75 = v10;
  v76 = 0;
  v74 = 0;
LABEL_142:
  CFRelease(v24);
LABEL_143:
  if (v76)
    CFRelease(v76);
  if (v26)
    CFRelease(v26);
  v73 = (void *)v95;
LABEL_148:
  if (v107)
    CFRelease(v107);

  return v74;
}

CFMutableDictionaryRef SecCFDictionaryCOWGetMutable(const __CFDictionary **a1)
{
  CFMutableDictionaryRef result;
  const __CFDictionary *v3;
  _QWORD context[5];

  result = a1[1];
  if (!result)
  {
    result = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    a1[1] = result;
    v3 = *a1;
    if (*a1)
    {
      context[0] = MEMORY[0x1E0C809B0];
      context[1] = 3221225472;
      context[2] = __SecCFDictionaryCOWGetMutable_block_invoke;
      context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
      context[4] = a1;
      CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)apply_block_2_8228, context);
      result = a1[1];
    }
    *a1 = result;
  }
  return result;
}

uint64_t SecErrorGetOSStatus(uint64_t result)
{
  __CFError *v1;
  CFErrorDomain Domain;
  CFErrorDomain v3;
  NSObject *v4;
  int v5;
  CFIndex Code;
  unint64_t v7;
  unint64_t v8;
  CFTypeRef v9;
  CFIndex v10;
  CFTypeRef v11;
  unint64_t v12;
  NSObject *v13;
  int v14;
  __CFError *v15;
  __int16 v16;
  __CFError *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (!result)
    return result;
  v1 = (__CFError *)result;
  Domain = CFErrorGetDomain((CFErrorRef)result);
  if (!Domain)
  {
    secLogObjForScope("SecError");
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v14 = 138412290;
      v15 = v1;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "No error domain for error: %@", (uint8_t *)&v14, 0xCu);
    }

    return 4294941020;
  }
  v3 = Domain;
  if (CFEqual((CFTypeRef)*MEMORY[0x1E0C9AFC8], Domain))
    return CFErrorGetCode(v1);
  if (!CFEqual(CFSTR("com.apple.utilities.sqlite3"), v3))
  {
    if (CFEqual((CFTypeRef)*MEMORY[0x1E0C9AFD0], v3))
      return CFErrorGetCode(v1);
    if (CFEqual((CFTypeRef)*MEMORY[0x1E0C9AFC0], v3))
    {
      Code = CFErrorGetCode(v1);
      return osstatus_for_kern_return(Code);
    }
    if (CFEqual((CFTypeRef)sSecXPCErrorDomain, v3))
    {
      v7 = CFErrorGetCode(v1);
      if (v7 < 4)
        return dword_18AA61BB0[v7];
    }
    else if (CFEqual((CFTypeRef)sSecDERErrorDomain, v3))
    {
      v8 = CFErrorGetCode(v1);
      if (v8 > 0xFFFFFFFFFFFFFFFALL)
        return *((unsigned int *)&unk_18AA5F024 + v8 + 5);
    }
    else
    {
      if (LocalAuthenticationLibraryCore())
      {
        if (getLAErrorDomainSymbolLoc())
        {
          getLAErrorDomain();
          if (CFEqual(v9, v3))
          {
            v10 = CFErrorGetCode(v1);
            switch(v10)
            {
              case -1004:
                return 4294941988;
              case -2:
                return 4294967168;
              case -1001:
                return 4294967246;
            }
            return 4294942003;
          }
        }
      }
      if (CryptoTokenKitLibraryCore() && getTKErrorDomainSymbolLoc() && (getTKErrorDomain(), CFEqual(v11, v3)))
      {
        v12 = CFErrorGetCode(v1);
        if (v12 > 0xFFFFFFFFFFFFFFF7)
          return *((unsigned int *)&unk_18AA5F038 + v12 + 8);
      }
      else if (!CFEqual(CFSTR("com.apple.security.sos.error"), v3))
      {
        secLogObjForScope("securityd");
        v13 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v14 = 138412546;
          v15 = (__CFError *)v3;
          v16 = 2112;
          v17 = v1;
          _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, "unknown error domain: %@ for error: %@", (uint8_t *)&v14, 0x16u);
        }

      }
    }
    return 4294941020;
  }
  v5 = CFErrorGetCode(v1);
  result = 0;
  if (v5 > 18)
  {
    switch(v5)
    {
      case 19:
        return 4294941997;
      case 20:
        return 4294941993;
      case 101:
        break;
      default:
        return 4294942005;
    }
  }
  else
  {
    switch(v5)
    {
      case 0:
        return result;
      case 2:
        result = 4294965226;
        break;
      case 4:
        result = 0xFFFFFFFFLL;
        break;
      case 7:
        result = 4294967188;
        break;
      case 8:
        result = 4294942004;
        break;
      case 10:
        result = 4294967260;
        break;
      default:
        return 4294942005;
    }
  }
  return result;
}

void __securityd_send_async_and_do_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v5;
  uint64_t v6;
  CFTypeRef v7;
  CFTypeRef cf;

  if (a3)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }
  else
  {
    cf = 0;
    v5 = securityd_message_no_error(a2, (CFErrorRef *)&cf);
    v6 = *(_QWORD *)(a1 + 32);
    if ((v5 & 1) != 0)
    {
      (*(void (**)(uint64_t, uint64_t, _QWORD))(v6 + 16))(v6, a2, 0);
    }
    else
    {
      (*(void (**)(uint64_t, _QWORD, CFTypeRef))(v6 + 16))(v6, 0, cf);
      v7 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v7);
      }
    }
  }
}

size_t __dict_to_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SecXPCDictionarySetPListWithRepair(a2, "query", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
}

BOOL __to_uint_error_request_block_invoke(uint64_t a1, xpc_object_t xdict, _QWORD *a3)
{
  uint64_t uint64;
  NSObject *v6;
  _QWORD *v7;
  uint8_t v9[16];

  uint64 = xpc_dictionary_get_uint64(xdict, "status");
  if ((uint64 & 0x8000000000000000) != 0)
  {
    v6 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v9 = 0;
      _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "Invalid exceptions epoch.", v9, 2u);
    }
    if (*(_QWORD *)(a1 + 40))
      **(_QWORD **)(a1 + 40) = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFD0], 34, 0);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = uint64;
  }
  if (a3)
  {
    v7 = *(_QWORD **)(a1 + 40);
    if (v7)
    {
      if (*a3)
        *v7 = *a3;
    }
  }
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t SecTokenItemCreateFromAttributes(const __CFDictionary *a1, const __CFDictionary *a2, void *a3, const void *a4, uint64_t *a5, __CFString **a6)
{
  id v11;
  __CFDictionary *MutableCopy;
  __CFString *Value;
  __CFString *v14;
  CFTypeID v15;
  uint64_t v16;
  const void *v17;
  SecKeyRef v18;
  uint64_t v19;
  uint64_t v20;
  const __CFData *v22;
  uint64_t v23;
  SecCertificateRef v24;
  SecKeyRef v25;
  uint64_t v26;
  NSObject *v27;
  _QWORD context[5];
  CFDictionaryRef v29;
  CFTypeRef cf;
  uint8_t buf[16];

  v11 = a3;
  v29 = a2;
  cf = 0;
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a1);
  Value = (__CFString *)CFDictionaryGetValue(a1, CFSTR("tkid"));
  if (!a4)
    goto LABEL_10;
  v14 = Value;
  if (!Value)
    goto LABEL_10;
  v15 = CFGetTypeID(Value);
  if (v15 != CFStringGetTypeID())
  {
    SecError(-50, a6, CFSTR("Unexpected type"));
    v20 = 0;
LABEL_17:

    if (!MutableCopy)
      goto LABEL_19;
    goto LABEL_18;
  }
  if (v11)
  {
LABEL_7:
    if (a2)
    {
      context[0] = MEMORY[0x1E0C809B0];
      context[1] = 3221225472;
      context[2] = __SecTokenItemCreateFromAttributes_block_invoke;
      context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
      context[4] = MutableCopy;
      CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)apply_block_2_8228, context);
    }
    CFDictionarySetValue(MutableCopy, CFSTR("u_TokenSession"), v11);
    CFDictionarySetValue(MutableCopy, CFSTR("toid"), a4);
LABEL_10:
    v17 = CFDictionaryGetValue(MutableCopy, CFSTR("class"));
    if (CFEqual(v17, CFSTR("keys")))
    {
      v18 = SecKeyCreateFromAttributeDictionary(MutableCopy);
LABEL_14:
      v19 = (uint64_t)v18;
LABEL_15:
      *a5 = v19;
      v20 = 1;
      goto LABEL_17;
    }
    if (CFEqual(v17, CFSTR("cert")))
    {
      v18 = SecCertificateCreateFromAttributeDictionary(MutableCopy);
      goto LABEL_14;
    }
    if (!CFEqual(v17, CFSTR("idnt")))
    {
      v19 = 0;
      goto LABEL_15;
    }
    v22 = (const __CFData *)CFDictionaryGetValue(MutableCopy, CFSTR("certdata"));
    v23 = *MEMORY[0x1E0C9AE00];
    v24 = SecCertificateCreateWithData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v22);
    v25 = SecKeyCreateFromAttributeDictionary(MutableCopy);
    if (v25 && v24)
    {
      v26 = SecIdentityCreate(v23, v24, v25);
    }
    else
    {
      secLogObjForScope("SecError");
      v27 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v27, OS_LOG_TYPE_DEFAULT, "SecItem: failed to create identity", buf, 2u);
      }

      v26 = 0;
      v19 = 0;
      if (!v25)
        goto LABEL_31;
    }
    CFRelease(v25);
    v19 = v26;
LABEL_31:
    if (v24)
      CFRelease(v24);
    goto LABEL_15;
  }
  SecTokenSessionCreate(v14, &v29, a6);
  v16 = objc_claimAutoreleasedReturnValue();
  if (v16)
  {
    v11 = (id)v16;
    a2 = v29;
    goto LABEL_7;
  }
  v20 = 0;
  if (MutableCopy)
LABEL_18:
    CFRelease(MutableCopy);
LABEL_19:
  if (cf)
    CFRelease(cf);
  return v20;
}

SecKeyRef SecKeyCreateFromAttributeDictionary(const __CFDictionary *a1)
{
  const __CFData *Value;
  SecKeyRef v3;
  CFErrorRef error;

  error = 0;
  Value = (const __CFData *)CFDictionaryGetValue(a1, CFSTR("v_Data"));
  v3 = SecKeyCreateWithData(Value, a1, &error);
  if (!v3)
    CFRelease(error);
  return v3;
}

uint64_t __data_array_to_array_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  const __CFData *v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v5 = *(const __CFData **)(a1 + 32);
  v6 = a2;
  SecXPCDictionarySetData(v6, "normIssuer", v5, a3);
  SecXPCDictionarySetPListWithRepair(v6, "accessGroups", *(const __CFString **)(a1 + 40), a3, v7, v8, v9, v10);

  return 1;
}

uint64_t SecItemUpdateWithError(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  _QWORD *Value;
  _QWORD *v8;
  CFTypeID v9;
  const void *v10;
  const void *v11;
  __CFDictionary *MutableCopy;
  __CFDictionary *v13;
  uint64_t v14;
  const void *v15;
  __CFDictionary *v16;
  CFTypeRef v17;
  uint64_t v19;
  CFTypeRef v20;
  const __CFDictionary *v21;
  CFTypeRef cf;

  v6 = (void *)MEMORY[0x18D770A24]();
  v21 = a1;
  cf = 0;
  v19 = a2;
  v20 = 0;
  Value = CFDictionaryGetValue(a1, CFSTR("v_Ref"));
  if (Value)
  {
    v8 = Value;
    v9 = CFGetTypeID(Value);
    if (v9 == SecIdentityGetTypeID())
    {
      v10 = (const void *)v8[2];
      CFRetain(v10);
      v11 = (const void *)v8[3];
      CFRetain(v11);
      MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a1);
      if (!MutableCopy)
      {
        v14 = 0;
        if (!v10)
          goto LABEL_13;
        goto LABEL_12;
      }
      v13 = MutableCopy;
      CFDictionarySetValue(MutableCopy, CFSTR("v_Ref"), v10);
      if (SecItemUpdateWithError(v13, a2, a3))
      {
        CFDictionarySetValue(v13, CFSTR("v_Ref"), v11);
        v14 = SecItemUpdateWithError(v13, a2, a3);
        goto LABEL_11;
      }
      goto LABEL_24;
    }
LABEL_15:
    v14 = SecItemAuthDoQuery(&v21, &v19, SecItemUpdate, a3, &__block_literal_global_8304);
    v17 = cf;
    if (!cf)
      goto LABEL_17;
    goto LABEL_16;
  }
  v15 = CFDictionaryGetValue(a1, CFSTR("class"));
  if (!v15 || !CFEqual(CFSTR("idnt"), v15))
    goto LABEL_15;
  v16 = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a1);
  if (v16)
  {
    v13 = v16;
    CFDictionarySetValue(v16, CFSTR("class"), CFSTR("cert"));
    if (SecItemUpdateWithError(v13, a2, a3))
    {
      CFDictionarySetValue(v13, CFSTR("class"), CFSTR("keys"));
      v10 = 0;
      v14 = (SecItemUpdateWithError(v13, a2, a3) & 1) != 0;
      v11 = 0;
      goto LABEL_11;
    }
    v10 = 0;
    v11 = 0;
LABEL_24:
    v14 = 0;
LABEL_11:
    CFRelease(v13);
    if (!v10)
    {
LABEL_13:
      if (!v11)
        goto LABEL_17;
      v17 = v11;
LABEL_16:
      CFRelease(v17);
      goto LABEL_17;
    }
LABEL_12:
    CFRelease(v10);
    goto LABEL_13;
  }
  v14 = 0;
LABEL_17:
  if (v20)
    CFRelease(v20);
  objc_autoreleasePoolPop(v6);
  return v14;
}

void deserializeCert(const void *a1, __CFArray *a2)
{
  CFTypeID v4;
  SecCertificateRef v5;
  SecCertificateRef v6;

  if (a1)
  {
    v4 = CFGetTypeID(a1);
    if (v4 == CFDataGetTypeID())
    {
      v5 = SecCertificateCreateWithData(0, (CFDataRef)a1);
      if (v5)
      {
        v6 = v5;
        CFArrayAppendValue(a2, v5);
        CFRelease(v6);
      }
    }
  }
}

SecCertificateRef SecCertificateCreateWithData(CFAllocatorRef allocator, CFDataRef data)
{
  uint64_t Instance;
  uint64_t v5;
  const __CFData *Copy;

  if (!data || CFDataGetLength(data) < 0)
    return 0;
  SecCertificateGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  v5 = Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), 0x268uLL);
    Copy = CFDataCreateCopy(allocator, data);
    *(_QWORD *)(v5 + 552) = Copy;
    *(_QWORD *)(v5 + 16) = CFDataGetBytePtr(Copy);
    *(_QWORD *)(v5 + 24) = CFDataGetLength(*(CFDataRef *)(v5 + 552));
    if ((SecCertificateParse(v5) & 1) == 0)
    {
      CFRelease((CFTypeRef)v5);
      return 0;
    }
  }
  return (SecCertificateRef)v5;
}

uint64_t SecCmsDecoderFinish(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t Error;
  _QWORD *ThreadErrInfo;
  int v11;

  v3 = *a1;
  v4 = a1[1];
  v6 = v4;
  if (v3)
  {
    if (!SEC_ASN1DecoderFinish(v3) && !nss_cms_after_end((uint64_t)a1))
    {
      Error = 0;
      *a2 = v4;
      goto LABEL_8;
    }
    v6 = a1[1];
  }
  if (v6)
    SecCmsMessageDestroy(v4);
  Error = PORT_GetError();
LABEL_8:
  free(a1);
  ThreadErrInfo = PR_getThreadErrInfo(1, &v11);
  if (ThreadErrInfo)
    *ThreadErrInfo = 0;
  return Error;
}

uint64_t nss_cms_after_end(uint64_t a1)
{
  int v1;
  uint64_t result;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;

  v1 = *(_DWORD *)(a1 + 16) - 25;
  result = 0;
  switch(v1)
  {
    case 0:
    case 2:
    case 5:
      return result;
    case 1:
      v4 = *(_QWORD *)(a1 + 24);
      if (!v4)
        goto LABEL_8;
      v5 = *(uint64_t **)(v4 + 160);
      if (v5)
      {
        v6 = *v5;
        if (*v5)
        {
          v7 = v5 + 1;
          do
          {
            *(_QWORD *)(v6 + 128) = v4;
            v8 = *v7++;
            v6 = v8;
          }
          while (v8);
        }
      }
      result = 0;
      break;
    case 4:
      if (*(_QWORD *)(a1 + 24))
        result = 0;
      else
        result = 0xFFFFFFFFLL;
      break;
    default:
LABEL_8:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

void addSignedAttribues(void *a1, _QWORD *a2)
{
  id v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  id v22;
  void *v23;
  id v24;
  void *v25;
  uint64_t v26;
  id v27;
  void *v28;
  void *v29;
  NSObject *v30;
  int v31;
  void *v32;
  id v33;
  NSObject *v34;
  void *v35;
  id v36;
  id v37;
  void *v38;
  void *v39;
  NSObject *v40;
  int v41;
  void *v42;
  id v43;
  id v44;
  id v45;
  id v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t j;
  uint64_t v51;
  void *v52;
  id v53;
  void *v54;
  NSObject *v55;
  uint64_t OID;
  uint64_t v57;
  void *v58;
  void *v59;
  void *v60;
  NSObject *v61;
  id v62;
  void *v63;
  uint64_t v64;
  id v65;
  void *v66;
  void *v67;
  NSObject *v68;
  int v69;
  void *v70;
  id v71;
  NSObject *v72;
  void *v73;
  id v74;
  NSObject *v75;
  NSObject *v76;
  void *v77;
  void *v78;
  id v79;
  void *v81;
  void *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  id v87;
  id v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  _BYTE v93[128];
  uint8_t v94[16];
  uint8_t buf[4];
  NSObject *v96;
  uint64_t v97;

  v97 = *MEMORY[0x1E0C80C00];
  v2 = a1;
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "certificates");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  if (v4)
  {
    objc_msgSend(v2, "certificates");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "allObjects");
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "setObject:forKeyedSubscript:", v6, kSecCMSAllCerts);

  }
  v81 = v2;
  objc_msgSend(v2, "signers");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "objectAtIndexedSubscript:", 0);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v85 = 0u;
  v86 = 0u;
  v83 = 0u;
  v84 = 0u;
  objc_msgSend(v8, "protectedAttributes");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v83, v93, 16);
  if (v10)
  {
    v11 = v10;
    v12 = *(_QWORD *)v84;
    do
    {
      for (i = 0; i != v11; ++i)
      {
        if (*(_QWORD *)v84 != v12)
          objc_enumerationMutation(v9);
        v14 = *(void **)(*((_QWORD *)&v83 + 1) + 8 * i);
        objc_msgSend(v14, "attributeType");
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v15, "OIDBytes");
        v16 = (void *)objc_claimAutoreleasedReturnValue();

        objc_msgSend(v14, "attributeValues");
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        v18 = (void *)objc_msgSend(v17, "mutableCopy");

        objc_msgSend(v3, "objectForKey:", v16);
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        v20 = v19;
        if (v19)
          objc_msgSend(v19, "addObjectsFromArray:", v18);
        else
          objc_msgSend(v3, "setObject:forKey:", v18, v16);

      }
      v11 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v83, v93, 16);
    }
    while (v11);
  }

  objc_msgSend(v8, "unprotectedAttributes");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v21, "removeAllObjects");

  v22 = v3;
  getSigningTime(v8);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v22, "setObject:forKeyedSubscript:", v23, kSecCMSSignDate);

  v24 = v22;
  v25 = (void *)MEMORY[0x1E0D4D7B8];
  v26 = *MEMORY[0x1E0D4D698];
  v27 = v8;
  objc_msgSend(v25, "OIDWithString:error:", v26, 0);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v27, "getAttributesWithType:", v28);
  v29 = (void *)objc_claimAutoreleasedReturnValue();

  if (v29)
  {
    if ((unint64_t)objc_msgSend(v29, "count") >= 2)
    {
      secLogObjForScope("SecWarning");
      v30 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        v31 = objc_msgSend(v29, "count");
        *(_DWORD *)buf = 67109120;
        LODWORD(v96) = v31;
        _os_log_impl(&dword_18A900000, v30, OS_LOG_TYPE_DEFAULT, "too many hash agility attributes (%d), skipping", buf, 8u);
      }
      goto LABEL_27;
    }
    objc_msgSend(v29, "objectAtIndexedSubscript:", 0);
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v33 = objc_alloc(MEMORY[0x1E0D4D750]);
      *(_QWORD *)&v89 = 0;
      v34 = objc_msgSend(v33, "initWithAttribute:error:", v32, &v89);
      v30 = (id)v89;
      if (!v34)
      {
LABEL_24:
        secLogObjForScope("SecWarning");
        v34 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          v96 = v30;
          _os_log_impl(&dword_18A900000, v34, OS_LOG_TYPE_DEFAULT, "skipping hash agility attribute that failed to decode: %@", buf, 0xCu);
        }
        goto LABEL_26;
      }
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        v30 = 0;
        goto LABEL_24;
      }
      v34 = v32;
      v30 = 0;
      if (!v34)
        goto LABEL_24;
    }
    -[NSObject hashAgilityValue](v34, "hashAgilityValue");
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v24, "setObject:forKeyedSubscript:", v35, kSecCMSHashAgility);

LABEL_26:
LABEL_27:

  }
  v36 = v27;
  v37 = v24;
  objc_msgSend(MEMORY[0x1E0D4D7B8], "OIDWithString:error:", *MEMORY[0x1E0D4D6A0], 0);
  v38 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v36, "getAttributesWithType:", v38);
  v39 = (void *)objc_claimAutoreleasedReturnValue();

  if (!v39)
    goto LABEL_57;
  if ((unint64_t)objc_msgSend(v39, "count") >= 2)
  {
    secLogObjForScope("SecWarning");
    v40 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      v41 = objc_msgSend(v39, "count");
      *(_DWORD *)buf = 67109120;
      LODWORD(v96) = v41;
      _os_log_impl(&dword_18A900000, v40, OS_LOG_TYPE_DEFAULT, "too many hash agility V2 attributes (%d), skipping", buf, 8u);
    }
    goto LABEL_56;
  }
  objc_msgSend(v39, "objectAtIndexedSubscript:", 0);
  v42 = (void *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      v40 = 0;
      goto LABEL_53;
    }
    v44 = v42;
    v40 = 0;
    if (!v44)
      goto LABEL_53;
LABEL_37:
    v79 = v36;
    objc_msgSend(v44, "hashAgilityValues", v44, v40, v42, v39);
    v45 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithCapacity:", objc_msgSend(v45, "count"));
    v82 = (void *)objc_claimAutoreleasedReturnValue();
    v89 = 0u;
    v90 = 0u;
    v91 = 0u;
    v92 = 0u;
    v46 = v45;
    v47 = objc_msgSend(v46, "countByEnumeratingWithState:objects:count:", &v89, buf, 16);
    if (v47)
    {
      v48 = v47;
      v49 = *(_QWORD *)v90;
      do
      {
        for (j = 0; j != v48; ++j)
        {
          if (*(_QWORD *)v90 != v49)
            objc_enumerationMutation(v46);
          v51 = *(_QWORD *)(*((_QWORD *)&v89 + 1) + 8 * j);
          v88 = 0;
          objc_msgSend(MEMORY[0x1E0D4D7B8], "OIDWithString:error:", v51, &v88);
          v52 = (void *)objc_claimAutoreleasedReturnValue();
          v53 = v88;
          if (v52)
          {
            objc_msgSend(v52, "OIDBytes");
            v54 = (void *)objc_claimAutoreleasedReturnValue();
            memset(v94, 170, sizeof(v94));
            *(_QWORD *)v94 = objc_msgSend(v54, "length");
            v55 = objc_retainAutorelease(v54);
            *(_QWORD *)&v94[8] = -[NSObject bytes](v55, "bytes");
            OID = SECOID_FindOID((uint64_t)v94);
            if (OID)
              v57 = *(unsigned int *)(OID + 16);
            else
              v57 = 0;
            objc_msgSend(v46, "objectForKeyedSubscript:", v51);
            v58 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v57);
            v59 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v82, "setObject:forKey:", v58, v59);

          }
          else
          {
            secLogObjForScope("SecWarning");
            v55 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v94 = 138412290;
              *(_QWORD *)&v94[4] = v51;
              _os_log_impl(&dword_18A900000, v55, OS_LOG_TYPE_DEFAULT, "skipping hash agility entry with invalid OID: %@", v94, 0xCu);
            }
          }

        }
        v48 = objc_msgSend(v46, "countByEnumeratingWithState:objects:count:", &v89, buf, 16);
      }
      while (v48);
    }

    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithDictionary:", v82);
    v60 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v37, "setObject:forKeyedSubscript:", v60, kSecCMSHashAgilityV2);
    v36 = v79;
    v42 = v77;
    v39 = v78;
    v61 = v75;
    v40 = v76;
    goto LABEL_55;
  }
  v43 = objc_alloc(MEMORY[0x1E0D4D758]);
  v87 = 0;
  v44 = (id)objc_msgSend(v43, "initWithAttribute:error:", v42, &v87);
  v40 = v87;
  if (v44)
    goto LABEL_37;
LABEL_53:
  secLogObjForScope("SecWarning");
  v61 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v96 = v40;
    _os_log_impl(&dword_18A900000, v61, OS_LOG_TYPE_DEFAULT, "skipping hash agility V2 attribute that failed to decode: %@", buf, 0xCu);
  }
LABEL_55:

LABEL_56:
LABEL_57:

  v62 = v37;
  v63 = (void *)MEMORY[0x1E0D4D7B8];
  v64 = *MEMORY[0x1E0D4D690];
  v65 = v36;
  objc_msgSend(v63, "OIDWithString:error:", v64, 0);
  v66 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v65, "getAttributesWithType:", v66);
  v67 = (void *)objc_claimAutoreleasedReturnValue();

  if (v67)
  {
    if ((unint64_t)objc_msgSend(v67, "count") >= 2)
    {
      secLogObjForScope("SecWarning");
      v68 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
      {
        v69 = objc_msgSend(v67, "count");
        *(_DWORD *)buf = 67109120;
        LODWORD(v96) = v69;
        _os_log_impl(&dword_18A900000, v68, OS_LOG_TYPE_DEFAULT, "too many expiration time attributes (%d), skipping", buf, 8u);
      }
      goto LABEL_71;
    }
    objc_msgSend(v67, "objectAtIndexedSubscript:", 0);
    v70 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v71 = objc_alloc(MEMORY[0x1E0D4D748]);
      *(_QWORD *)&v89 = 0;
      v72 = objc_msgSend(v71, "initWithAttribute:error:", v70, &v89);
      v68 = (id)v89;
      if (!v72)
      {
LABEL_68:
        secLogObjForScope("SecWarning");
        v72 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          v96 = v68;
          _os_log_impl(&dword_18A900000, v72, OS_LOG_TYPE_DEFAULT, "skipping expration time that failed to decode: %@", buf, 0xCu);
        }
        goto LABEL_70;
      }
    }
    else
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        v68 = 0;
        goto LABEL_68;
      }
      v72 = v70;
      v68 = 0;
      if (!v72)
        goto LABEL_68;
    }
    -[NSObject expirationTime](v72, "expirationTime");
    v73 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v62, "setObject:forKeyedSubscript:", v73, kSecCMSExpirationDate);

LABEL_70:
LABEL_71:

  }
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithDictionary:", v62);
  v74 = (id)objc_claimAutoreleasedReturnValue();
  *a2 = v74;

}

id getSigningTime(void *a1)
{
  void *v1;
  uint64_t v2;
  id v3;
  void *v4;
  void *v5;
  NSObject *v6;
  void *v7;
  void *v8;
  NSObject *v9;
  id v11;
  uint8_t buf[4];
  NSObject *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v1 = (void *)MEMORY[0x1E0D4D7B8];
  v2 = *MEMORY[0x1E0D4D6C0];
  v3 = a1;
  objc_msgSend(v1, "OIDWithString:error:", v2, 0);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "getAttributesWithType:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (v5)
  {
    if ((unint64_t)objc_msgSend(v5, "count") >= 2)
    {
      secLogObjForScope("SecWarning");
      v6 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v13) = objc_msgSend(v5, "count");
        _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "too many signing time attributes (%d), skipping", buf, 8u);
      }
      v7 = 0;
      goto LABEL_18;
    }
    objc_msgSend(v5, "objectAtIndexedSubscript:", 0);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v11 = 0;
      v9 = objc_msgSend(objc_alloc(MEMORY[0x1E0D4D7A8]), "initWithAttribute:error:", v8, &v11);
      v6 = v11;
      if (!v9)
        goto LABEL_14;
LABEL_12:
      -[NSObject signingTime](v9, "signingTime");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_17:

LABEL_18:
      goto LABEL_19;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v9 = v8;
      v6 = 0;
      if (v9)
        goto LABEL_12;
    }
    else
    {
      v6 = 0;
    }
LABEL_14:
    secLogObjForScope("SecWarning");
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v13 = v6;
      _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "skipping signing time that failed to decode: %@", buf, 0xCu);
    }
    v7 = 0;
    goto LABEL_17;
  }
  v7 = 0;
LABEL_19:

  return v7;
}

uint64_t MS_SecCMSVerifySignedData_internal(uint64_t a1, uint64_t a2, void *a3, __SecTrust **a4, uint64_t a5, uint64_t *a6, _QWORD *a7)
{
  id v14;
  void *v15;
  id v16;
  void *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  char isKindOfClass;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  void *v25;
  char v26;
  NSObject *v27;
  _QWORD *v28;
  CFTypeID v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v33;
  CFTypeID v34;
  void *v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t v39;
  char v40;
  id v41;
  __SecTrust *v42;
  const __CFDate *v43;
  NSObject *v44;
  void *v45;
  int v46;
  char v47;
  uint64_t v48;
  void *v49;
  char v50;
  NSObject *v51;
  void *v52;
  NSObject *v53;
  const char *v54;
  NSObject *v55;
  void *v56;
  const __CFDate *verifyDate;
  uint64_t *v58;
  _QWORD *v59;
  id v60;
  id v61;
  id v62;
  id v63;
  void *v64;
  uint8_t buf[4];
  id v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  if (a5)
  {
    v14 = objc_alloc_init(MEMORY[0x1E0D4D7B0]);
    objc_msgSend(v14, "setAdditionalCertificates:", a5);
  }
  else
  {
    v14 = 0;
  }
  v63 = 0;
  objc_msgSend(MEMORY[0x1E0D4D770], "decodeMessageSecurityObject:options:error:", a1, v14, &v63);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v16 = v63;
  if (v15)
  {
    objc_msgSend(v15, "contentType");
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v17, "isEqualToString:", *MEMORY[0x1E0D4D6E0])
      && (objc_msgSend(v15, "embeddedContent"), (v18 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      v19 = (void *)v18;
      v58 = a6;
      v59 = a7;
      objc_msgSend(v15, "embeddedContent");
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      isKindOfClass = objc_opt_isKindOfClass();

      if ((isKindOfClass & 1) != 0)
      {
        objc_msgSend(v15, "embeddedContent");
        v22 = objc_claimAutoreleasedReturnValue();
        v23 = v22;
        if (a2)
        {
          if ((-[NSObject detached](v22, "detached") & 1) == 0)
          {
            secLogObjForScope("SecWarning");
            v24 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18A900000, v24, OS_LOG_TYPE_DEFAULT, "CMS message has attached content but caller passed in detached contents, using detached contents", buf, 2u);
            }

          }
          -[NSObject contentType](v23, "contentType");
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          v26 = objc_msgSend(v25, "isEqualToString:", *MEMORY[0x1E0D4D6D0]);

          if ((v26 & 1) == 0)
          {
            secLogObjForScope("SecWarning");
            v27 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18A900000, v27, OS_LOG_TYPE_DEFAULT, "Caller passed a detached content by the content is not a data type.", buf, 2u);
            }

          }
          -[NSObject setDataContent:](v23, "setDataContent:", a2);
        }
        v28 = v59;
        if (!a3)
        {
          secLogObjForScope("SecWarning");
          v33 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18A900000, v33, OS_LOG_TYPE_DEFAULT, "SecCMSVerify called without policy -- skipping verification!", buf, 2u);
          }
          goto LABEL_50;
        }
        v29 = CFGetTypeID(a3);
        if (v29 == SecPolicyGetTypeID())
        {
          v64 = a3;
          objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v64, 1);
          v30 = objc_claimAutoreleasedReturnValue();
        }
        else
        {
          v34 = CFGetTypeID(a3);
          if (v34 != CFArrayGetTypeID())
          {
            secLogObjForScope("SecError");
            v33 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18A900000, v33, OS_LOG_TYPE_DEFAULT, "policy is not a SecPolicy or CFArr0ay", buf, 2u);
            }
            v31 = 4294967246;
            goto LABEL_46;
          }
          v30 = a3;
        }
        v33 = v30;
        -[NSObject signers](v23, "signers");
        v35 = (void *)objc_claimAutoreleasedReturnValue();
        v36 = objc_msgSend(v35, "count");

        if (v36 == 1)
        {
          -[NSObject signers](v23, "signers");
          v37 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v37, "objectAtIndexedSubscript:", 0);
          v38 = (void *)objc_claimAutoreleasedReturnValue();

          getSigningTime(v38);
          v39 = objc_claimAutoreleasedReturnValue();
          verifyDate = (const __CFDate *)v39;
          if (a4)
          {
            v62 = v16;
            v40 = -[NSObject verifySignatures:](v23, "verifySignatures:", &v62);
            v41 = v62;

            v28 = v59;
            if ((v40 & 1) != 0)
            {
              v61 = v41;
              v56 = v38;
              v42 = (__SecTrust *)objc_msgSend(v38, "createTrustObjectWithPolicies:error:", v33, &v61);
              v16 = v61;

              if (v42)
              {
                v43 = verifyDate;
                if (verifyDate)
                  SecTrustSetVerifyDate(v42, verifyDate);
                *a4 = v42;
                v38 = v56;
                goto LABEL_49;
              }
              secLogObjForScope("SecError");
              v55 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412290;
                v66 = v16;
                _os_log_impl(&dword_18A900000, v55, OS_LOG_TYPE_DEFAULT, "Failed to create trust ref to verify signer: %@", buf, 0xCu);
              }

              v31 = objc_msgSend(v16, "code");
              v41 = v16;
              v38 = v56;
LABEL_68:

              v16 = v41;
              goto LABEL_28;
            }
            secLogObjForScope("SecError");
            v53 = objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
LABEL_67:

              v31 = 4294942003;
              goto LABEL_68;
            }
            *(_DWORD *)buf = 138412290;
            v66 = v41;
            v54 = "CMS signature verification failed: %@";
          }
          else
          {
            v60 = v16;
            v47 = -[NSObject verifySignaturesAndSignersWithPolicies:verifyTime:error:](v23, "verifySignaturesAndSignersWithPolicies:verifyTime:error:", v33, v39, &v60);
            v41 = v60;

            v28 = v59;
            if ((v47 & 1) != 0)
            {
              v16 = v41;
              v43 = verifyDate;
LABEL_49:

LABEL_50:
              if (v58)
              {
                if ((-[NSObject detached](v23, "detached") & 1) != 0)
                {
                  objc_msgSend(MEMORY[0x1E0C99D50], "data");
                  v48 = objc_claimAutoreleasedReturnValue();
                }
                else
                {
                  -[NSObject contentType](v23, "contentType");
                  v49 = (void *)objc_claimAutoreleasedReturnValue();
                  v50 = objc_msgSend(v49, "isEqualToString:", *MEMORY[0x1E0D4D6D0]);

                  if ((v50 & 1) == 0)
                  {
                    secLogObjForScope("SecWarning");
                    v51 = objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                    {
                      -[NSObject contentType](v23, "contentType");
                      v52 = (void *)objc_claimAutoreleasedReturnValue();
                      *(_DWORD *)buf = 138412290;
                      v66 = v52;
                      _os_log_impl(&dword_18A900000, v51, OS_LOG_TYPE_DEFAULT, "returning attached embedded content of type %@", buf, 0xCu);

                    }
                  }
                  -[NSObject dataContent](v23, "dataContent");
                  v48 = objc_claimAutoreleasedReturnValue();
                  v28 = v59;
                }
                *v58 = v48;
              }
              if (v28)
                addSignedAttribues(v23, v28);
              v31 = 0;
              goto LABEL_28;
            }
            secLogObjForScope("SecError");
            v53 = objc_claimAutoreleasedReturnValue();
            if (!os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
              goto LABEL_67;
            *(_DWORD *)buf = 138412290;
            v66 = v41;
            v54 = "Signature/signer verification failed: %@";
          }
          _os_log_impl(&dword_18A900000, v53, OS_LOG_TYPE_DEFAULT, v54, buf, 0xCu);
          goto LABEL_67;
        }
        secLogObjForScope("SecError");
        v44 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          -[NSObject signers](v23, "signers");
          v45 = (void *)objc_claimAutoreleasedReturnValue();
          v46 = objc_msgSend(v45, "count");
          *(_DWORD *)buf = 67109120;
          LODWORD(v66) = v46;
          _os_log_impl(&dword_18A900000, v44, OS_LOG_TYPE_DEFAULT, "CMS message has %d signers, expected 1", buf, 8u);

        }
        v31 = 4294942003;
LABEL_46:

        goto LABEL_28;
      }
    }
    else
    {

    }
    secLogObjForScope("SecError");
    v23 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v23, OS_LOG_TYPE_DEFAULT, "CMS message does not contain a SignedData", buf, 2u);
    }
    v31 = 4294941021;
  }
  else
  {
    secLogObjForScope("SecError");
    v23 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v66 = v16;
      _os_log_impl(&dword_18A900000, v23, OS_LOG_TYPE_DEFAULT, "failed to decode CMS message: %@", buf, 0xCu);
    }
    v31 = 4294942003;
  }
LABEL_28:

  return v31;
}

uint64_t SecCmsDecoderCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t **a7)
{
  _QWORD *ThreadErrInfo;
  _QWORD *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t Error;
  _QWORD *v20;
  int v22;
  int v23;

  ThreadErrInfo = PR_getThreadErrInfo(1, &v22);
  if (ThreadErrInfo)
    *ThreadErrInfo = 0;
  v14 = (_QWORD *)SecCmsMessageCreate();
  if (v14)
  {
    v15 = (uint64_t)v14;
    v14[17] = a4;
    v14[18] = a5;
    v14[19] = a6;
    v16 = (uint64_t *)PORT_ZAlloc(0x40uLL);
    if (v16)
    {
      v17 = v16;
      v18 = SEC_ASN1DecoderStart(*(_QWORD *)(v15 + 120), v15, (uint64_t)&SecCmsMessageTemplate, 0, 0);
      *v17 = v18;
      if (v18)
      {
        Error = 0;
        *(_QWORD *)(v18 + 32) = nss_cms_decoder_notify;
        *(_QWORD *)(v18 + 40) = v17;
        v17[1] = v15;
        *((_DWORD *)v17 + 4) = 0;
        v17[6] = a1;
        v17[7] = a2;
        *a7 = v17;
        return Error;
      }
      free(v17);
    }
    SecCmsMessageDestroy(v15);
  }
  Error = PORT_GetError();
  v20 = PR_getThreadErrInfo(1, &v23);
  if (v20)
    *v20 = 0;
  return Error;
}

_QWORD *PR_getThreadErrInfo(int a1, int *a2)
{
  _QWORD *v4;
  int v5;
  int v6;
  int v7;
  _QWORD *v8;
  _QWORD *v9;

  if ((PR_threadKeyInitFlag & 1) == 0)
  {
    pthread_mutex_lock(&PR_threadKeyLock);
    if (!a1 && PR_threadKeyErrorFlag)
    {
      pthread_mutex_unlock(&PR_threadKeyLock);
      v4 = 0;
      v5 = -5991;
LABEL_15:
      *a2 = v5;
      return v4;
    }
    if ((PR_threadKeyInitFlag & 1) == 0)
    {
      v6 = pthread_key_create((pthread_key_t *)&PR_threadKey, (void (__cdecl *)(void *))MEMORY[0x1E0C834A8]);
      if (v6)
      {
        v7 = v6;
        PR_threadKeyErrorFlag = 1;
        pthread_mutex_unlock(&PR_threadKeyLock);
        v4 = 0;
        *a2 = v7;
        return v4;
      }
      PR_threadKeyErrorFlag = 0;
      PR_threadKeyInitFlag = 1;
    }
    pthread_mutex_unlock(&PR_threadKeyLock);
  }
  *a2 = 0;
  v8 = pthread_getspecific(PR_threadKey);
  v4 = v8;
  if (a1 && !v8)
  {
    v9 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
    v4 = v9;
    if (!v9)
    {
      v5 = -6000;
      goto LABEL_15;
    }
    *v9 = 0;
    pthread_setspecific(PR_threadKey, v9);
  }
  return v4;
}

uint64_t SecCmsMessageCreate()
{
  uint64_t result;
  _QWORD *v1;

  result = (uint64_t)PORT_NewArena(1024);
  if (result)
  {
    v1 = (_QWORD *)result;
    result = PORT_ArenaAlloc(result, 0xA0uLL);
    if (result)
    {
      *(_OWORD *)(result + 128) = 0u;
      *(_OWORD *)(result + 144) = 0u;
      *(_OWORD *)(result + 96) = 0u;
      *(_OWORD *)(result + 112) = 0u;
      *(_OWORD *)(result + 64) = 0u;
      *(_OWORD *)(result + 80) = 0u;
      *(_OWORD *)(result + 32) = 0u;
      *(_OWORD *)(result + 48) = 0u;
      *(_OWORD *)result = 0u;
      *(_OWORD *)(result + 16) = 0u;
      *(_QWORD *)(result + 120) = v1;
      *(_QWORD *)(result + 24) = result;
      *(_DWORD *)(result + 128) = 1;
    }
    else
    {
      PORT_FreeArena(v1, 0);
      return 0;
    }
  }
  return result;
}

uint64_t SecCmsSignedDataVerifySignerInfo_internal(uint64_t a1, int a2, const void *a3, SecTrustRef *a4)
{
  uint64_t *v5;
  uint64_t v8;
  uint64_t v10;
  uint64_t OID;
  uint64_t v12;
  uint64_t started;
  unsigned int IndexByAlgTag;
  uint64_t v15;
  uint64_t v16;
  __SecCertificate *SigningCert_internal;
  SecKeyRef v18;
  SecKeyRef v19;
  uint64_t *v20;
  uint64_t AttrByOidTag;
  uint64_t v22;
  _DWORD *v23;
  _QWORD *v24;
  int v25;
  int v26;
  CFIndex v28;
  _QWORD *ThreadErrInfo;
  _QWORD *v30;
  CFIndex v31;
  const UInt8 *v32;
  int v33;

  if (a1)
  {
    v5 = *(uint64_t **)(a1 + 160);
    if (v5)
    {
      v8 = *v5;
      if (*v5)
      {
        v8 = 0;
        while (v5[++v8])
          ;
      }
      if ((int)v8 > a2)
      {
        v10 = v5[a2];
        OID = SECOID_FindOID(v10 + 32);
        if (!OID)
          return 4294899481;
        v12 = OID;
        if (!*(_QWORD *)(a1 + 168))
        {
          started = SecCmsDigestContextStartMultiple(*(uint64_t **)(a1 + 136));
          SecCmsSignedDataSetDigestContext((_QWORD *)a1, started);
          SecCmsDigestContextCancel(started);
          if (!*(_QWORD *)(a1 + 168))
            return 4294941980;
        }
        IndexByAlgTag = SecCmsAlgArrayGetIndexByAlgTag(*(size_t ***)(a1 + 136), *(_DWORD *)(v12 + 16));
        if ((IndexByAlgTag & 0x80000000) != 0)
          return 4294941980;
        v15 = *(_QWORD *)(*(_QWORD *)(a1 + 168) + 8 * IndexByAlgTag);
        if (!v15)
          return 4294941980;
        v16 = *(_QWORD *)(a1 + 32);
        if (!v16)
        {
          v16 = SECOID_FindOID(a1);
          *(_QWORD *)(a1 + 32) = v16;
        }
        v31 = 0xAAAAAAAAAAAAAAAALL;
        v32 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
        if (!v10)
          return 0xFFFFFFFFLL;
        SigningCert_internal = (__SecCertificate *)SecCmsSignerInfoGetSigningCert_internal(v10);
        if (!SigningCert_internal)
        {
          v25 = 4;
          goto LABEL_46;
        }
        v18 = SecCertificateCopyKey(SigningCert_internal);
        if (!v18)
        {
          v25 = 0;
          goto LABEL_46;
        }
        v19 = v18;
        v20 = *(uint64_t **)(v10 + 64);
        if (!v20 || !*v20)
        {
          v28 = *(_QWORD *)(v10 + 104);
          if (v28)
          {
            if (!SecKeyVerifyDigest((uint64_t)v19, (const SecAsn1Oid *)(v10 + 32), *(const UInt8 **)(v15 + 8), *(_QWORD *)v15, *(const UInt8 **)(v10 + 112), v28))goto LABEL_30;
LABEL_38:
            if (PORT_GetError() == -8182)
            {
              ThreadErrInfo = PR_getThreadErrInfo(1, &v33);
              if (ThreadErrInfo)
                *ThreadErrInfo = 0xFFFFE02F00000000;
            }
            CFRelease(v19);
            *(_DWORD *)(v10 + 160) = 2;
            return 0xFFFFFFFFLL;
          }
          v25 = 0;
          goto LABEL_45;
        }
        if (v16)
        {
          AttrByOidTag = SecCmsAttributeArrayFindAttrByOidTag(v20, 0x21u, 1);
          if (!AttrByOidTag || !SecCmsAttributeCompareValue(AttrByOidTag, v16))
            goto LABEL_43;
          v20 = *(uint64_t **)(v10 + 64);
        }
        v22 = SecCmsAttributeArrayFindAttrByOidTag(v20, 0x22u, 1);
        if (v22)
        {
          if (SecCmsAttributeCompareValue(v22, v15))
          {
            v23 = PORT_NewArena(1024);
            if (v23)
            {
              v24 = v23;
              v31 = 0;
              v32 = 0;
              v25 = 9;
              if (SEC_ASN1EncodeItem((uint64_t)v23, &v31, v10 + 64, (uint64_t)&nss_cms_set_of_attribute_template)
                && v32
                && v31)
              {
                v26 = SecKeyDigestAndVerify((uint64_t)v19, (const SecAsn1Oid *)(v10 + 32), v32, v31, *(const UInt8 **)(v10 + 112), *(_QWORD *)(v10 + 104));
                PORT_FreeArena(v24, 0);
                if (!v26)
                {
LABEL_30:
                  CFRelease(v19);
                  *(_DWORD *)(v10 + 160) = 1;
                  return SecCmsSignerInfoVerifyCertificate(v10, a3, a4);
                }
                goto LABEL_38;
              }
            }
            else
            {
              v25 = 9;
            }
          }
          else
          {
            v25 = 3;
          }
          goto LABEL_45;
        }
LABEL_43:
        v25 = 8;
LABEL_45:
        CFRelease(v19);
LABEL_46:
        *(_DWORD *)(v10 + 160) = v25;
        v30 = PR_getThreadErrInfo(1, &v33);
        if (v30)
          *v30 = 0xFFFFE02F00000000;
        return 0xFFFFFFFFLL;
      }
    }
  }
  return 4294967246;
}

const void *SecCmsAttributeCompareValue(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  size_t *v3;
  const void *result;
  size_t v5;

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(size_t **)v2;
  if (!*(_QWORD *)v2)
    return 0;
  result = (const void *)v3[1];
  if (!result)
    return result;
  v5 = *v3;
  if (*v3 && !*(_QWORD *)(v2 + 8) && v5 == *(_QWORD *)a2)
    return (const void *)(memcmp(result, *(const void **)(a2 + 8), v5) == 0);
  else
    return 0;
}

double SecCmsSignerInfoGetSigningTime(uint64_t a1, double *a2, double result)
{
  uint64_t AttrByOidTag;
  uint64_t v6;
  _QWORD *v7;

  if (a1)
  {
    result = *(double *)(a1 + 152);
    if (result == 0.0)
    {
      AttrByOidTag = SecCmsAttributeArrayFindAttrByOidTag(*(uint64_t **)(a1 + 64), 0x23u, 1);
      if (AttrByOidTag)
      {
        v6 = *(_QWORD *)(AttrByOidTag + 16);
        v7 = *(_QWORD **)v6;
        if (*(_QWORD *)v6)
        {
          if (v7[1] && *v7 && !*(_QWORD *)(v6 + 8) && !SecAsn1DecodeTime((uint64_t)v7, a2))
          {
            result = *a2;
            *(double *)(a1 + 152) = *a2;
          }
        }
      }
    }
    else
    {
      *a2 = result;
    }
  }
  return result;
}

uint64_t SecCmsAttributeArrayFindAttrByOidTag(uint64_t *a1, unsigned int a2, int a3)
{
  uint64_t *v5;
  uint64_t v6;
  size_t *v7;
  size_t v8;
  uint64_t *v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;

  if (!a1)
    return 0;
  v5 = a1;
  pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
  v6 = 0;
  if (a2 <= 0xD8)
    v7 = (size_t *)&oids[40 * a2];
  else
    v7 = 0;
  if (a2 <= 0xD8)
  {
    v6 = *v5;
    if (*v5)
    {
      v8 = *v7;
      while (1)
      {
        v9 = v5 + 1;
        if (*(_QWORD *)v6 == v8)
        {
          v10 = (const void *)v7[1];
          if (!memcmp(*(const void **)(v6 + 8), v10, v8))
            break;
        }
        v6 = *v9;
        ++v5;
        if (!*v9)
          return v6;
      }
      if (a3)
      {
        v11 = *v9;
        if (*v9)
        {
          v12 = 2;
          while (*(_QWORD *)v11 != v8 || memcmp(*(const void **)(v11 + 8), v10, v8))
          {
            v11 = v5[v12++];
            if (!v11)
              return v6;
          }
          return 0;
        }
      }
    }
  }
  return v6;
}

const void *SecCmsSignerInfoGetSigningCert_internal(uint64_t a1)
{
  const void *v1;
  uint64_t *v4;
  uint64_t v5;
  uint64_t *v6;
  const __CFData *v7;
  int v8;
  const __CFData *SubjectKeyID;
  size_t *v10;
  size_t v11;
  const void *v12;
  const UInt8 *BytePtr;
  uint64_t v14;
  int v15;

  v1 = *(const void **)(a1 + 136);
  if (!v1)
  {
    v4 = *(uint64_t **)(*(_QWORD *)(a1 + 128) + 144);
    if (v4)
    {
      v5 = *v4;
      if (*v4)
      {
        v6 = v4 + 1;
        do
        {
          if ((*(_QWORD *)v5 & 0x8000000000000000) != 0)
          {
            while (1)
              ;
          }
          v7 = (const __CFData *)SecCertificateCreateWithBytes(0, *(const void **)(v5 + 8), *(_QWORD *)v5);
          if (v7)
          {
            v1 = v7;
            v8 = *(_DWORD *)(a1 + 16);
            if (v8 == 1)
            {
              SubjectKeyID = SecCertificateGetSubjectKeyID(v7);
              v10 = *(size_t **)(a1 + 24);
              v11 = *v10;
              if (v11 == CFDataGetLength(SubjectKeyID))
              {
                v12 = (const void *)v10[1];
                BytePtr = CFDataGetBytePtr(SubjectKeyID);
                if (!memcmp(v12, BytePtr, *v10))
                  goto LABEL_21;
              }
            }
            else if (!v8
                   && CERT_CheckIssuerAndSerial((uint64_t)v7, (size_t *)(*(_QWORD *)(a1 + 24) + 24), (size_t *)(*(_QWORD *)(a1 + 24) + 8)))
            {
              goto LABEL_21;
            }
            if (*(_QWORD *)(a1 + 136))
              return v1;
            CFRelease(v1);
          }
          v14 = *v6++;
          v5 = v14;
        }
        while (v14);
        if (*(_QWORD *)(a1 + 136))
          return 0;
      }
    }
    v15 = *(_DWORD *)(a1 + 16);
    if (!v15)
    {
      v1 = CERT_FindByIssuerAndSN(*(const void **)(*(_QWORD *)(a1 + 128) + 176), CFSTR("cert"), *(_QWORD *)(a1 + 24));
      *(_QWORD *)(a1 + 136) = v1;
      if (v1)
        return v1;
      v15 = *(_DWORD *)(a1 + 16);
    }
    if (v15 != 1)
    {
      return 0;
    }
    else
    {
      v1 = CERT_FindBySubjectKeyID(*(const void **)(*(_QWORD *)(a1 + 128) + 176), CFSTR("cert"), *(CFIndex **)(a1 + 24));
LABEL_21:
      *(_QWORD *)(a1 + 136) = v1;
    }
  }
  return v1;
}

uint64_t SecCmsSignerInfoGetAppleCodesigningHashAgilityV2(uint64_t a1, __CFDictionary **a2)
{
  uint64_t result;
  __CFDictionary *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  CFIndex v10;
  __CFDictionary *Mutable;
  uint64_t v12;
  uint64_t *v13;
  __int128 v14;
  _DWORD *v15;
  _QWORD *v16;
  uint64_t OID;
  uint64_t v18;
  CFNumberRef v19;
  CFDataRef v20;
  uint64_t v21;
  CFIndex Count;
  uint64_t *v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t valuePtr;
  __int128 v28;
  __int128 v29;

  result = 4294967246;
  if (a1 && a2)
  {
    *a2 = 0;
    v5 = *(__CFDictionary **)(a1 + 192);
    if (v5)
    {
      result = 0;
      *a2 = v5;
      return result;
    }
    result = SecCmsAttributeArrayFindAttrByOidTag(*(uint64_t **)(a1 + 64), 0xD7u, 1);
    if (result)
    {
      v6 = result;
      v7 = *(uint64_t **)(result + 16);
      if (v7)
      {
        if (*v7)
        {
          v8 = 0;
          while (v7[++v8])
            ;
          v10 = v8;
        }
        else
        {
          v10 = 0;
        }
        Mutable = CFDictionaryCreateMutable(0, v10, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v12 = *v7;
        if (*v7)
        {
          v13 = v7 + 1;
          do
          {
            *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v28 = v14;
            v29 = v14;
            v15 = PORT_NewArena(1024);
            if (v15)
            {
              v16 = v15;
              if (!SEC_ASN1Decode((uint64_t)v15, (uint64_t)&v28, (uint64_t)&CMSAppleAgileHashTemplate, *(char **)(v12 + 8), *(_QWORD *)v12)&& (v29 & 0x8000000000000000) == 0)
              {
                OID = SECOID_FindOID((uint64_t)&v28);
                if (OID)
                  v18 = *(unsigned int *)(OID + 16);
                else
                  v18 = 0;
                valuePtr = v18;
                v19 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
                v20 = CFDataCreate(0, *((const UInt8 **)&v29 + 1), v29);
                CFDictionaryAddValue(Mutable, v19, v20);
                if (v20)
                  CFRelease(v20);
                if (v19)
                  CFRelease(v19);
              }
              PORT_FreeArena(v16, 0);
            }
            v21 = *v13++;
            v12 = v21;
          }
          while (v21);
        }
        Count = CFDictionaryGetCount(Mutable);
        v23 = *(uint64_t **)(v6 + 16);
        if (v23)
        {
          v24 = *v23;
          if (*v23)
          {
            v24 = 0;
            v25 = v23 + 1;
            while (v25[v24++])
              ;
            v24 = v24;
          }
        }
        else
        {
          v24 = 0;
        }
        if (Count == v24)
        {
          *(_QWORD *)(a1 + 192) = Mutable;
          if (!Mutable)
            return 4294967188;
          result = 0;
          *a2 = Mutable;
          return result;
        }
        if (Mutable)
          CFRelease(Mutable);
      }
      return 4294941021;
    }
  }
  return result;
}

uint64_t SEC_ASN1Encode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD **v5;
  uint64_t v6;

  v4 = SEC_ASN1EncoderStart(a1, a2, a3, a4);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = (_QWORD **)v4;
  v6 = SEC_ASN1EncoderUpdate(v4, 0, 0);
  PORT_FreeArena(*v5, 0);
  return v6;
}

uint64_t SEC_ASN1DecoderFinish(uint64_t a1)
{
  uint64_t v2;
  _QWORD *ThreadErrInfo;
  uint64_t v4;
  int *v5;
  int v6;
  int *v7;
  int v8;
  int v10;

  if (*(_DWORD *)(a1 + 24) != 3)
    goto LABEL_10;
  v2 = *(_QWORD *)(a1 + 16);
  if (!*(_DWORD *)(v2 + 48))
  {
    v5 = *(int **)(v2 + 8);
    v6 = *v5;
    if (*v5)
    {
      v7 = v5 + 6;
      while ((v6 & 0x100) != 0)
      {
        v8 = *v7;
        v7 += 6;
        LOWORD(v6) = v8;
        if (!v8)
          goto LABEL_10;
      }
      goto LABEL_3;
    }
LABEL_10:
    v4 = 0;
    goto LABEL_11;
  }
LABEL_3:
  ThreadErrInfo = PR_getThreadErrInfo(1, &v10);
  if (ThreadErrInfo)
    *ThreadErrInfo = 0xFFFFE00900000000;
  v4 = 0xFFFFFFFFLL;
LABEL_11:
  PORT_FreeArena(*(_QWORD **)a1, 0);
  return v4;
}

void PORT_FreeArena(_QWORD *a1, int a2)
{
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  _QWORD *v6;

  if (a2)
  {
    v3 = (_QWORD *)*a1;
    if (!*a1)
      goto LABEL_7;
    do
    {
      v4 = (void *)v3[1];
      v5 = v3[2];
      v3[3] = v4;
      bzero(v4, v5 - (_QWORD)v4);
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  while (1)
  {
    v6 = (_QWORD *)*a1;
    if (!*a1)
      break;
    *a1 = *v6;
    free(v6);
  }
LABEL_7:
  free(a1);
}

uint64_t SEC_ASN1EncoderStart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _DWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v8 = PORT_NewArena(2048);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = PORT_ArenaAlloc((uint64_t)v8, 0x48uLL);
  if (!v10)
    goto LABEL_5;
  v11 = v10;
  *(_OWORD *)(v10 + 8) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_QWORD *)v10 = v9;
  *(_QWORD *)(v10 + 56) = a3;
  *(_QWORD *)(v10 + 64) = a4;
  *(_DWORD *)(v10 + 16) = 2;
  if (!sec_asn1e_push_state(v10, a2, a1, 0) || !sec_asn1e_init_state_based_on_template(*(_QWORD *)(v11 + 8)))
  {
LABEL_5:
    PORT_FreeArena(v9, 0);
    return 0;
  }
  return v11;
}

uint64_t SEC_ASN1DecoderStart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _DWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;

  v10 = PORT_NewArena(2048);
  if (!v10)
    return 0;
  v11 = v10;
  v12 = PORT_ArenaAlloc((uint64_t)v10, 0x50uLL);
  if (!v12)
    goto LABEL_7;
  v13 = v12;
  *(_QWORD *)(v12 + 72) = 0;
  *(_OWORD *)(v12 + 56) = 0u;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 24) = 0u;
  *(_OWORD *)(v12 + 8) = 0u;
  *(_QWORD *)v12 = v11;
  if (a1)
    *(_QWORD *)(v12 + 8) = a1;
  *(_DWORD *)(v12 + 24) = 3;
  if (!sec_asn1d_push_state(v12, a3, a2, 0) || !sec_asn1d_init_state_based_on_template(*(_QWORD **)(v13 + 16), a4, a5))
  {
LABEL_7:
    PORT_FreeArena(v11, 0);
    return 0;
  }
  return v13;
}

_DWORD *PORT_NewArena(int a1)
{
  _DWORD *result;
  unint64_t v3;

  result = PORT_ZAlloc(0x40uLL);
  if (result)
  {
    result[14] = -1196647457;
    *((_QWORD *)result + 6) = 7;
    v3 = ((unint64_t)result + 39) & 0xFFFFFFFFFFFFFFF8;
    *((_QWORD *)result + 2) = v3;
    *((_QWORD *)result + 3) = v3;
    *(_QWORD *)result = 0;
    *((_QWORD *)result + 1) = v3;
    *((_QWORD *)result + 4) = result;
    result[10] = a1;
  }
  return result;
}

void *PORT_ZAlloc(unint64_t a1)
{
  size_t v1;
  void *result;
  _QWORD *ThreadErrInfo;
  int v4;

  if (a1 >> 31 || (a1 <= 1 ? (v1 = 1) : (v1 = a1), (result = malloc_type_calloc(1uLL, v1, 0xC17C3709uLL)) == 0))
  {
    ++port_allocFailures;
    ThreadErrInfo = PR_getThreadErrInfo(1, &v4);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0xFFFFE01300000000;
    return 0;
  }
  return result;
}

uint64_t SEC_ASN1EncoderUpdate(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  int v6;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(_QWORD, _QWORD, uint64_t, uint64_t);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  void (*v31)(_QWORD, uint64_t);
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  _BOOL8 v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  unsigned int *v39;
  _DWORD *v40;
  int *v41;
  uint64_t v42;
  int v43;
  char v44;
  char v45;
  unint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  unint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void (*v58)(_QWORD, uint64_t, uint64_t, uint64_t);
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  char *v68;
  int v69;
  int v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t (**v79)(_QWORD, uint64_t, _QWORD, _QWORD);
  uint64_t v80;
  uint64_t v81;
  uint64_t **v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v89;
  unint64_t v90;
  int v91;
  unint64_t v92;
  char v93;
  uint64_t v94;

  v3 = a3;
  v4 = a2;
  v94 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD *)(a1 + 16);
  if (v6 == 3)
  {
    v6 = 2;
    *(_DWORD *)(a1 + 16) = 2;
  }
  if (a2)
    v7 = a3 == 0;
  else
    v7 = 1;
  v8 = v7;
  v9 = a3 + 1;
  while (2)
  {
    if (v6 != 2)
      goto LABEL_145;
    v10 = *(_QWORD *)(a1 + 8);
    switch(*(_DWORD *)(v10 + 40))
    {
      case 0:
        v91 = 0;
        v11 = *(_QWORD *)(v10 + 48);
        if (v11 == 1024)
          goto LABEL_14;
        if ((v11 & 0x100000) != 0)
        {
          v39 = *(unsigned int **)(v10 + 8);
          if (!v39[6])
          {
LABEL_57:
            *(_DWORD *)(*(_QWORD *)v10 + 16) = 1;
            goto LABEL_131;
          }
          v40 = *(_DWORD **)(v10 + 16);
          v41 = (int *)(v39 + 12);
          v42 = 1;
          while (*v40 != *(v41 - 2))
          {
            ++v42;
            v43 = *v41;
            v41 += 6;
            if (!v43)
              goto LABEL_57;
          }
          *(_DWORD *)(v10 + 40) = 8;
          v53 = *(_QWORD *)v10;
          v54 = (uint64_t)&v39[6 * v42];
          v55 = (uint64_t)v40 - v39[1];
        }
        else
        {
          v90 = v9;
          if (*(_DWORD *)(*(_QWORD *)v10 + 20) && *(_DWORD *)(v10 + 72))
          {
            v32 = v4;
            v33 = v3;
            v34 = v8;
            if (*(_DWORD *)(*(_QWORD *)v10 + 24))
              v35 = 1;
            else
              v35 = *(_DWORD *)(v10 + 68) == 0;
          }
          else
          {
            v33 = v3;
            v32 = v4;
            v34 = v8;
            v35 = 0;
          }
          v44 = *(_BYTE *)(v10 + 45);
          v45 = *(_BYTE *)(v10 + 44);
          v46 = sec_asn1e_contents_length(*(_DWORD **)(v10 + 8), *(unint64_t **)(v10 + 16), *(_DWORD *)(v10 + 80), v35, &v91);
          if (v91 || !v46 && *(_DWORD *)(v10 + 76))
          {
            *(_DWORD *)(v10 + 40) = 4;
            v47 = *(_QWORD *)v10;
            v8 = v34;
            v4 = v32;
            v3 = v33;
            v9 = v90;
            if (*(_DWORD *)(*(_QWORD *)v10 + 20) && *(_DWORD *)(v10 + 72) && *(_DWORD *)(v47 + 24))
              *(_DWORD *)(v47 + 16) = 3;
            goto LABEL_131;
          }
          if (v35)
          {
            v46 = 0;
            *(_DWORD *)(v10 + 64) = 1;
            v45 |= 0x20u;
          }
          v89 = v46;
          LOBYTE(v92) = v45 | v44;
          (*(void (**)(_QWORD, unint64_t *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), &v92, 1, *(unsigned int *)(v10 + 56), 0);
          v51 = *(_DWORD *)(v10 + 64);
          v93 = -86;
          v92 = 0xAAAAAAAAAAAAAAAALL;
          if (v51)
          {
            LOBYTE(v92) = 0x80;
            v52 = 1;
            v8 = v34;
            v4 = v32;
            v3 = v33;
            v9 = v90;
          }
          else
          {
            v8 = v34;
            v3 = v33;
            if (v89 < 0x80)
            {
              LOBYTE(v92) = v89;
              v52 = 1;
              v4 = v32;
              v9 = v90;
            }
            else
            {
              v73 = 0;
              v74 = v89;
              v4 = v32;
              v9 = v90;
              do
              {
                v75 = v73++;
                v15 = v74 >= 0x100;
                v74 >>= 8;
              }
              while (v15);
              v52 = v75 + 2;
              LOBYTE(v92) = v73 | 0x80;
              v76 = v89;
              do
              {
                *((_BYTE *)&v92 + v73) = v76;
                v76 >>= 8;
                --v73;
              }
              while (v73);
            }
          }
          (*(void (**)(_QWORD, unint64_t *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), &v92, v52, *(unsigned int *)(v10 + 56), 1);
          if (!v89 && !*(_DWORD *)(v10 + 64))
          {
            *(_DWORD *)(v10 + 40) = 4;
            goto LABEL_131;
          }
          if (*(_DWORD *)(v10 + 60))
          {
            *(_DWORD *)(v10 + 40) = 4;
            v78 = *(_QWORD *)(v10 + 8);
            v77 = *(_QWORD *)(v10 + 16);
            v79 = *(uint64_t (***)(_QWORD, uint64_t, _QWORD, _QWORD))(v78 + 8);
            if (v79 && (*(_BYTE *)(v78 + 1) & 0x40) != 0)
            {
              if (*v79)
              {
                if (v77)
                  v80 = v77 - *(unsigned int *)(v78 + 4);
                else
                  v80 = 0;
                v79 = (uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(*v79)(v80, 1, 0, 0);
                v77 = *(_QWORD *)(v10 + 16);
              }
              else
              {
                v79 = 0;
              }
            }
            v86 = *(_QWORD *)v10;
            v84 = v77;
LABEL_129:
            v87 = sec_asn1e_push_state(v86, (uint64_t)v79, v84, 1);
            if (v87)
              sec_asn1e_init_state_based_on_template(v87);
            goto LABEL_131;
          }
          v81 = *(_QWORD *)(v10 + 48);
          if ((unint64_t)(v81 - 16) >= 2)
          {
            if ((unint64_t)(v81 - 8208) > 1)
            {
LABEL_14:
              *(_DWORD *)(v10 + 40) = 1;
              goto LABEL_131;
            }
            v82 = *(uint64_t ***)(v10 + 16);
            v83 = *v82;
            if (!*v82 || (v84 = *v83) == 0)
            {
              *(_DWORD *)(v10 + 40) = 4;
              goto LABEL_131;
            }
            *(_DWORD *)(v10 + 40) = 2;
            v85 = *(_QWORD *)(v10 + 8);
            v79 = *(uint64_t (***)(_QWORD, uint64_t, _QWORD, _QWORD))(v85 + 8);
            if (v79 && (*(_BYTE *)(v85 + 1) & 0x40) != 0)
            {
              if (*v79)
              {
                v79 = (uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))(*v79)((char *)v82- *(unsigned int *)(v85 + 4), 1, 0, 0);
                v84 = *v83;
              }
              else
              {
                v79 = 0;
              }
            }
            v86 = *(_QWORD *)v10;
            goto LABEL_129;
          }
          *(_DWORD *)(v10 + 40) = 3;
          v53 = *(_QWORD *)v10;
          v54 = *(_QWORD *)(v10 + 8) + 24;
          v55 = *(_QWORD *)(v10 + 16);
        }
        v56 = sec_asn1e_push_state(v53, v54, v55, 1);
        if (v56)
        {
          v23 = v56;
          v57 = *(_QWORD *)v56;
          v58 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v56 + 32);
          if (v58)
          {
            v59 = *(unsigned int *)(v56 + 56);
            v60 = *(_QWORD *)(v56 + 16);
            *(_DWORD *)(v57 + 48) = 1;
            v58(*(_QWORD *)(v57 + 40), 1, v60, v59);
            *(_DWORD *)(v57 + 48) = 0;
          }
LABEL_35:
          sec_asn1e_init_state_based_on_template(v23);
        }
        goto LABEL_131;
      case 1:
        if (!*(_DWORD *)(a1 + 24))
        {
          v36 = *(_QWORD *)(v10 + 48);
          if (v36 <= 15)
          {
            if (v36 == 2)
            {
              v66 = *(uint64_t **)(v10 + 16);
              v67 = *v66;
              if (*v66)
              {
                v68 = (char *)v66[1];
                v69 = *(_DWORD *)(v10 + 84);
                v70 = *v68;
                if ((*v68 & 0x80000000) == 0)
                {
                  v71 = v67;
                  v72 = v68;
                  goto LABEL_136;
                }
LABEL_141:
                v71 = v67;
                v72 = v68;
                if (v69)
                {
LABEL_136:
                  while (!v70)
                  {
                    v67 = v71 - 1;
                    if (v71 == 1)
                      break;
                    v68 = v72 + 1;
                    if (v72[1] < 0)
                    {
                      if (v69)
                        break;
                    }
                    v70 = v72[1];
                    --v71;
                    ++v72;
                    if ((v70 & 0x80) != 0)
                      goto LABEL_141;
                  }
                  (*(void (**)(_QWORD, char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), v72, v71, *(unsigned int *)(v10 + 56), 2);
                }
                else
                {
                  LOBYTE(v92) = 0;
                  (*(void (**)(_QWORD, unint64_t *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), &v92, 1, *(unsigned int *)(v10 + 56), 2);
                  (*(void (**)(_QWORD, char *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), v68, v67, *(unsigned int *)(v10 + 56), 2);
                }
              }
              goto LABEL_12;
            }
            if (v36 == 3)
            {
              v48 = *(_QWORD **)(v10 + 16);
              v49 = *v48 + 7;
              v50 = v49 >> 3;
              LOBYTE(v92) = (v49 & 0xF8) - *v48;
              (*(void (**)(_QWORD, unint64_t *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), &v92, 1, *(unsigned int *)(v10 + 56), 2);
              (*(void (**)(_QWORD, _QWORD, unint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), v48[1], v50, *(unsigned int *)(v10 + 56), 2);
              goto LABEL_12;
            }
          }
          else
          {
            if ((unint64_t)(v36 - 16) < 2)
              goto LABEL_12;
            if (v36 == 28)
            {
              v37 = *(uint64_t **)(v10 + 16);
              v38 = *v37;
              if ((*v37 & 3) != 0)
              {
LABEL_83:
                *(_DWORD *)(*(_QWORD *)v10 + 16) = 1;
                goto LABEL_12;
              }
              goto LABEL_88;
            }
            if (v36 == 30)
            {
              v37 = *(uint64_t **)(v10 + 16);
              v38 = *v37;
              if ((*v37 & 1) != 0)
                goto LABEL_83;
              goto LABEL_88;
            }
          }
          v37 = *(uint64_t **)(v10 + 16);
          v38 = *v37;
LABEL_88:
          (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), v37[1], v38, *(unsigned int *)(v10 + 56), 2);
LABEL_12:
          *(_DWORD *)(v10 + 40) = 4;
          goto LABEL_131;
        }
        if ((v8 & 1) == 0)
        {
          if (*(_QWORD *)(v10 + 48) != 1024)
          {
            LOBYTE(v92) = *(_QWORD *)(v10 + 48);
            (*(void (**)(_QWORD, unint64_t *, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), &v92, 1, *(unsigned int *)(v10 + 56), 0);
            if (*(_QWORD *)(v10 + 48) == 3)
            {
              v93 = -86;
              v92 = 0xAAAAAAAAAAAAAAAALL;
              if (v9 < 0x80)
              {
                LOBYTE(v92) = v9;
                v16 = 1;
              }
              else
              {
                v12 = 0;
                v13 = v9;
                do
                {
                  v14 = v12++;
                  v15 = v13 >= 0x100;
                  v13 >>= 8;
                }
                while (v15);
                v16 = v14 + 2;
                LOBYTE(v92) = v12 | 0x80;
                v17 = v9;
                do
                {
                  *((_BYTE *)&v92 + v12) = v17;
                  v17 >>= 8;
                  --v12;
                }
                while (v12);
              }
              (*(void (**)(_QWORD, unint64_t *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), &v92, v16, *(unsigned int *)(v10 + 56), 1);
              LOBYTE(v92) = 0;
              (*(void (**)(_QWORD, unint64_t *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), &v92, 1, *(unsigned int *)(v10 + 56), 2);
            }
            else
            {
              v92 = 0xAAAAAAAAAAAAAAAALL;
              v93 = -86;
              if (v3 < 0x80)
              {
                LOBYTE(v92) = v3;
                v64 = 1;
              }
              else
              {
                v61 = 0;
                v62 = v3;
                do
                {
                  v63 = v61++;
                  v15 = v62 >= 0x100;
                  v62 >>= 8;
                }
                while (v15);
                v64 = v63 + 2;
                LOBYTE(v92) = v61 | 0x80;
                v65 = v3;
                do
                {
                  *((_BYTE *)&v92 + v61) = v65;
                  v65 >>= 8;
                  --v61;
                }
                while (v61);
              }
              (*(void (**)(_QWORD, unint64_t *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), &v92, v64, *(unsigned int *)(v10 + 56), 1);
            }
          }
          (*(void (**)(_QWORD, uint64_t, unint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), v4, v3, *(unsigned int *)(v10 + 56), 2);
        }
        *(_DWORD *)(*(_QWORD *)v10 + 16) = 3;
LABEL_131:
        v6 = *(_DWORD *)(a1 + 16);
        if (v6 == 1)
          goto LABEL_145;
        if (*(_QWORD *)(a1 + 8))
          continue;
        v6 = 0;
LABEL_144:
        *(_DWORD *)(a1 + 16) = v6;
LABEL_145:
        if (v6 == 1)
          return 0xFFFFFFFFLL;
        else
          return 0;
      case 2:
        v18 = *(_QWORD *)(v10 + 32);
        v19 = **(uint64_t ***)(v10 + 16);
        v20 = *(unsigned int *)(*(_QWORD *)(v18 + 8) + 4);
        do
          v21 = *v19++;
        while (v21 != *(_QWORD *)(v18 + 16) - v20);
        v22 = *v19;
        if (!v22)
        {
          *(_DWORD *)(v18 + 40) = 9;
          goto LABEL_12;
        }
        *(_QWORD *)(v18 + 16) = v22 + v20;
        *(_DWORD *)(v18 + 40) = 0;
        *(_DWORD *)(v18 + 64) = 0;
LABEL_39:
        *(_QWORD *)(*(_QWORD *)v10 + 8) = v18;
        goto LABEL_131;
      case 3:
        v23 = *(_QWORD *)(v10 + 32);
        v24 = *(_QWORD *)v10;
        v25 = *(void (**)(_QWORD, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v10 + 32);
        if (v25)
        {
          v26 = *(unsigned int *)(v23 + 56);
          v27 = *(_QWORD *)(v23 + 16);
          *(_DWORD *)(v24 + 48) = 1;
          v25(*(_QWORD *)(v24 + 40), 0, v27, v26);
          *(_DWORD *)(v24 + 48) = 0;
        }
        v28 = *(_QWORD *)(v23 + 8);
        v29 = *(_DWORD *)(v28 + 24);
        *(_QWORD *)(v23 + 8) = v28 + 24;
        if (!v29)
        {
          *(_DWORD *)(v23 + 40) = 9;
          *(_DWORD *)(v10 + 40) = 4;
          goto LABEL_131;
        }
        *(_QWORD *)(v23 + 16) = *(_QWORD *)(v10 + 16) + *(unsigned int *)(v28 + 28);
        v30 = *(_QWORD *)v10;
        v31 = *(void (**)(_QWORD, uint64_t))(*(_QWORD *)v10 + 32);
        if (v31)
        {
          *(_DWORD *)(v30 + 48) = 1;
          v31(*(_QWORD *)(v30 + 40), 1);
          *(_DWORD *)(v30 + 48) = 0;
          v30 = *(_QWORD *)v10;
        }
        *(_QWORD *)(v30 + 8) = v23;
        goto LABEL_35;
      case 4:
        if (*(_DWORD *)(v10 + 64))
        {
          LOWORD(v92) = 0;
          (*(void (**)(_QWORD, unint64_t *, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v10 + 56))(*(_QWORD *)(*(_QWORD *)v10 + 64), &v92, 2, *(unsigned int *)(v10 + 56), 3);
        }
        v18 = *(_QWORD *)(v10 + 24);
        goto LABEL_39;
      case 5:
      case 6:
      case 7:
      case 8:
        goto LABEL_12;
      default:
        v6 = 1;
        goto LABEL_144;
    }
  }
}

unint64_t sec_asn1e_contents_length(_DWORD *a1, unint64_t *a2, unsigned int a3, uint64_t a4, int *a5)
{
  _DWORD *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t, _QWORD, _QWORD, unint64_t *);
  uint64_t v13;
  int *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  unint64_t result;
  uint64_t v19;
  unint64_t v20;
  BOOL v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  uint64_t *v25;
  uint64_t v26;
  _DWORD *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  unint64_t v33;
  _BYTE *v34;
  int v35;
  unint64_t v36;
  char *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  __int16 v44;

  v8 = a1;
  v9 = *a1;
  if ((*a1 & 0x200000) != 0)
    v10 = 1;
  else
    v10 = a3;
  if ((v9 & 0x100000) != 0)
  {
    while (v8[6])
    {
      v14 = v8 + 12;
      v15 = 1;
      while (*(_DWORD *)a2 != *(v14 - 2))
      {
        ++v15;
        v16 = *v14;
        v14 += 6;
        if (!v16)
          return 0;
      }
      v17 = (uint64_t)a2 - v8[1];
      v8 += 6 * v15;
      v9 = *v8;
      a2 = (unint64_t *)(v17 + v8[1]);
      if ((*v8 & 0x200000) != 0)
        v10 = 1;
      else
        v10 = v10;
      if ((v9 & 0x100000) == 0)
        goto LABEL_5;
    }
    return 0;
  }
LABEL_5:
  if ((v9 & 0x18C0) == 0)
  {
    if ((v9 & 0x20000) != 0)
    {
      result = 0;
      v24 = 2;
LABEL_100:
      *a5 = v24;
      return result;
    }
    v19 = v9 & 0xFFDBBCFF;
    if ((int)(v9 & 0xFFDBBCFF) > 8207)
    {
      if ((v19 - 8208) > 1)
      {
LABEL_72:
        v23 = *a2;
        goto LABEL_88;
      }
      v25 = (uint64_t *)*a2;
      if (*a2)
      {
        v26 = *((_QWORD *)v8 + 1);
        if (v26 && (v9 & 0x4000) != 0)
        {
          if (*(_QWORD *)v26)
            v26 = (*(uint64_t (**)(char *, uint64_t, _QWORD, _QWORD, unint64_t *))v26)((char *)a2 - v8[1], 1, 0, 0, a2);
          else
            v26 = 0;
        }
        v39 = *v25;
        if (*v25)
        {
          v23 = 0;
          do
          {
            v40 = sec_asn1e_contents_length(v26, v39 + *(unsigned int *)(v26 + 4), v10, a4, a5);
            v23 += v40;
            if (!*a5)
            {
              v41 = 1;
              if (v40 >= 0x80)
              {
                do
                {
                  ++v41;
                  v31 = v40 > 0xFF;
                  v40 >>= 8;
                }
                while (v31);
              }
              v23 += v41 + 1;
            }
            v42 = v25[1];
            ++v25;
            v39 = v42;
          }
          while (v42);
          goto LABEL_88;
        }
      }
    }
    else
    {
      if ((v19 - 16) >= 2)
      {
        if ((_DWORD)v19 != 2)
        {
          if ((_DWORD)v19 == 3)
          {
            v20 = *a2 + 7;
            v21 = v20 >= 8;
            v22 = v20 >> 3;
            if (v21)
              v23 = v22 + 1;
            else
              v23 = 0;
            goto LABEL_88;
          }
          goto LABEL_72;
        }
        v23 = *a2;
        if (*a2)
        {
          v34 = (_BYTE *)a2[1];
          LOBYTE(v35) = *v34;
          if (*v34)
          {
            v36 = *a2;
LABEL_66:
            if ((*(_QWORD *)&v9 & 0x800000) == 0 && (v35 & 0x80u) != 0)
              v23 = v36 + 1;
            else
              v23 = v36;
          }
          else
          {
            v38 = v34 + 1;
            while (1)
            {
              v36 = v23 - 1;
              if (v23 == 1)
                break;
              v35 = *v38;
              if (v35 < 0)
                break;
              ++v38;
              --v23;
              if ((_BYTE)v35)
                goto LABEL_66;
            }
          }
        }
LABEL_88:
        if ((_DWORD)a4)
          v43 = v23 == 0;
        else
          v43 = 0;
        v44 = v43;
        if ((((_DWORD)v10 == 0) & *(_DWORD *)&v44 & (v9 >> 18)) != 0)
          result = 1;
        else
          result = v23;
        if ((v9 & 0x100) == 0 || result)
        {
          if (v19 != 1024)
            goto LABEL_104;
          v24 = 1;
          goto LABEL_100;
        }
        goto LABEL_99;
      }
      v27 = v8 + 6;
      if (v8[6])
      {
        v23 = 0;
        do
        {
          v28 = v8[7];
          v8 = v27;
          v29 = sec_asn1e_contents_length(v27, (char *)a2 + v28, v10, a4, a5);
          v23 += v29;
          if (!*a5)
          {
            v30 = 1;
            if (v29 >= 0x80)
            {
              do
              {
                ++v30;
                v31 = v29 > 0xFF;
                v29 >>= 8;
              }
              while (v31);
            }
            v23 += v30 + 1;
          }
          v27 = v8 + 6;
        }
        while (v8[6]);
        goto LABEL_88;
      }
    }
    v23 = 0;
    goto LABEL_88;
  }
  v11 = *((_QWORD *)v8 + 1);
  if (v11 && (v9 & 0x4000) != 0)
  {
    v12 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, unint64_t *))v11;
    if (*(_QWORD *)v11)
    {
      if (a2)
        v13 = (uint64_t)a2 - v8[1];
      else
        v13 = 0;
      v11 = v12(v13, 1, 0, 0, a2);
      if ((v9 & 0x1000) == 0)
        goto LABEL_53;
      goto LABEL_33;
    }
    v11 = 0;
  }
  if ((v9 & 0x1000) == 0)
    goto LABEL_53;
LABEL_33:
  a2 = (unint64_t *)*a2;
  if (!a2)
  {
    result = 0;
    if ((v9 & 0x100) != 0)
      v24 = 3;
    else
      v24 = 0;
    goto LABEL_100;
  }
LABEL_53:
  result = sec_asn1e_contents_length(v11, (char *)a2 + *(unsigned int *)(v11 + 4), v10, a4, a5);
  if ((v9 & 0x100) != 0 && !result)
  {
LABEL_99:
    v24 = 3;
    goto LABEL_100;
  }
  if ((v9 & 0x200) != 0)
  {
    if (*a5)
    {
      if (*a5 != 1)
        return result;
LABEL_104:
      *a5 = 0;
      return result;
    }
    v32 = 1;
    if (result >= 0x80)
    {
      v33 = result;
      do
      {
        ++v32;
        v31 = v33 > 0xFF;
        v33 >>= 8;
      }
      while (v31);
    }
    result += v32 + 1;
  }
  return result;
}

_QWORD *sec_asn1e_encode_item_store(_QWORD *result, const void *a2, size_t a3)
{
  _QWORD *v4;

  if (a3)
  {
    v4 = result;
    result = memcpy((void *)(result[1] + *result), a2, a3);
    *v4 += a3;
  }
  return result;
}

_QWORD *sec_asn1e_encode_item_count(_QWORD *result, uint64_t a2, uint64_t a3)
{
  *result += a3;
  return result;
}

const SecAsn1Template *cms_attr_choose_attr_value_template(const SecAsn1Template *result, int a2)
{
  uint64_t v3;
  uint64_t OID;
  int v5;
  char v6;

  if (!result)
    return result;
  v3 = (uint64_t)result;
  if (a2 && LOBYTE(result[1].sub))
    return kSecAsn1AnyTemplate;
  OID = *(_QWORD *)&result[1].kind;
  if (OID || (OID = SECOID_FindOID(v3), (*(_QWORD *)(v3 + 24) = OID) != 0))
  {
    v5 = *(_DWORD *)(OID + 16);
    v6 = 1;
    result = kSecAsn1AnyTemplate;
    if (v5 <= 33)
    {
      if ((v5 - 31) >= 2)
      {
        if (v5 == 33)
        {
          result = kSecAsn1ObjectIDTemplate;
          v6 = 0;
        }
        else
        {
          v6 = 1;
        }
        if (!a2)
          goto LABEL_21;
        return result;
      }
LABEL_17:
      v6 = 0;
      result = kSecAsn1IA5StringTemplate;
      if (a2)
        return result;
      goto LABEL_21;
    }
    if (v5 == 34 || v5 == 214)
    {
      v6 = 0;
      result = kSecAsn1OctetStringTemplate;
    }
    else if (v5 == 99)
    {
      goto LABEL_17;
    }
    if (a2)
      return result;
    goto LABEL_21;
  }
  v6 = 1;
  result = kSecAsn1AnyTemplate;
  if (!a2)
LABEL_21:
    *(_BYTE *)(v3 + 32) = v6;
  return result;
}

uint64_t sec_asn1e_init_state_based_on_template(uint64_t a1)
{
  unsigned int *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  BOOL v6;
  char v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t (**v11)(char *, uint64_t, _QWORD, _QWORD);
  char *v12;
  uint64_t v13;
  unsigned int v14;
  unint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;
  char v20;
  unsigned int v21;
  char v22;
  char v23;
  char v24;
  uint64_t v25;
  char v26;
  _BOOL4 v27;
  char v28;
  int v29;
  char v30;

  do
  {
    v2 = *(unsigned int **)(a1 + 8);
    v3 = *v2;
    v4 = v3 & 0x200;
    v5 = (v3 >> 8) & 1;
    if ((v3 & 0x100000) != 0)
    {
      v14 = (v3 >> 18) & 1;
      LODWORD(v15) = (v3 >> 21) & 1;
      v18 = 0x100000;
LABEL_39:
      LODWORD(v16) = v3;
      goto LABEL_40;
    }
    v6 = (v3 & 0xC0) != 0 && v4 == 0;
    v7 = !v6;
    if ((v3 & 0x1800) == 0 && (v7 & 1) != 0)
    {
      v14 = (v3 >> 18) & 1;
      LODWORD(v15) = (v3 >> 21) & 1;
      v18 = v3 & 0xFF5BBCFF;
      goto LABEL_39;
    }
    *(_DWORD *)(a1 + 64) = 0;
    v8 = *(uint64_t **)(a1 + 16);
    if ((v3 & 0x1000) != 0)
    {
      v9 = *v8;
      *(_DWORD *)(a1 + 40) = 7;
      if ((v3 & 0x100) != 0 && v9 == 0)
        return a1;
    }
    else
    {
      if ((v3 & 0x800) != 0)
      {
        *(_DWORD *)(a1 + 40) = 6;
      }
      else
      {
        *(_BYTE *)(a1 + 44) = v3 & 0xE0;
        *(_BYTE *)(a1 + 45) = v3 & 0x1F;
        *(_DWORD *)(a1 + 40) = 5;
        *(_DWORD *)(a1 + 76) = v5;
      }
      v9 = (uint64_t)v8;
    }
    v11 = (uint64_t (**)(char *, uint64_t, _QWORD, _QWORD))*((_QWORD *)v2 + 1);
    if (v11 && (v3 & 0x4000) != 0)
    {
      if (*v11)
      {
        if (v8)
          v12 = (char *)v8 - v2[1];
        else
          v12 = 0;
        v11 = (uint64_t (**)(char *, uint64_t, _QWORD, _QWORD))(*v11)(v12, 1, 0, 0);
      }
      else
      {
        v11 = 0;
      }
    }
    v13 = sec_asn1e_push_state(*(_QWORD *)a1, (uint64_t)v11, v9, 0);
    a1 = v13;
    if (!v13)
      return a1;
  }
  while ((v3 & 0xC0) == 0);
  v14 = (v3 >> 18) & 1;
  v15 = (v3 & 0x200000) >> 21;
  v16 = **(unsigned int **)(v13 + 8);
  if ((v3 & 0x200000) != 0)
    v17 = (v3 >> 18) & 1;
  else
    v17 = 1;
  if ((v16 & 0x40000) != 0)
  {
    v14 = v17;
    v18 = v16 & 0xFFFFFFFFFFFBFFFFLL;
  }
  else
  {
    v18 = **(unsigned int **)(v13 + 8);
  }
LABEL_40:
  v19 = v4 >> 9;
  if ((v3 & 0x400) != 0)
  {
    v30 = 0;
    v24 = 0;
    v29 = 1;
  }
  else
  {
    v20 = v16 & 0x1F;
    v21 = (v16 >> 9) & 1;
    v22 = v16 & 0x20 | v3 & 0xE0;
    if ((v3 & 0x4000) != 0)
    {
      LODWORD(v19) = v21;
      v23 = v22;
    }
    else
    {
      v23 = v3 & 0xE0;
    }
    if ((v3 & 0x4000) != 0)
      v24 = v20;
    else
      v24 = v3 & 0x1F;
    v25 = 1 << (v18 & 0x1F);
    v26 = v23 | 0x20;
    if ((v25 & 0x30000) == 0)
      v26 = v23;
    v6 = (v25 & 0x55D81018) == 0;
    v27 = (v25 & 0x55D81018) != 0;
    if (v6)
      v28 = v26;
    else
      v28 = v23;
    v29 = (v18 & 0x1F) != 0x1F && v27;
    if ((v18 & 0x1F) == 0x1F)
      v30 = v23;
    else
      v30 = v28;
  }
  *(_BYTE *)(a1 + 44) = v30;
  *(_BYTE *)(a1 + 45) = v24;
  *(_QWORD *)(a1 + 48) = v18;
  *(_DWORD *)(a1 + 68) = v29;
  *(_DWORD *)(a1 + 72) = v14;
  *(_DWORD *)(a1 + 76) = v5;
  *(_DWORD *)(a1 + 80) = v15;
  *(_DWORD *)(a1 + 84) = (v3 >> 23) & 1;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 60) = v19;
  *(_DWORD *)(a1 + 64) = 0;
  return a1;
}

uint64_t sec_asn1e_push_state(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t result;
  int v10;

  v8 = *(_QWORD *)(a1 + 8);
  result = PORT_ArenaAlloc(*(_QWORD *)a1, 0x58uLL);
  if (result)
  {
    *(_OWORD *)(result + 16) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_QWORD *)(result + 80) = 0;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_QWORD *)(result + 24) = v8;
    *(_QWORD *)result = a1;
    *(_QWORD *)(result + 8) = a2;
    *(_DWORD *)(result + 40) = 9;
    if (a3)
      *(_QWORD *)(result + 16) = a3 + *(unsigned int *)(a2 + 4);
    if (v8)
    {
      v10 = *(_DWORD *)(v8 + 56);
      if (a4)
        ++v10;
      *(_DWORD *)(result + 56) = v10;
      *(_QWORD *)(v8 + 32) = result;
    }
    *(_QWORD *)(a1 + 8) = result;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = 1;
  }
  return result;
}

uint64_t SECOID_FindOID(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t *v7;
  _QWORD *ThreadErrInfo;
  uint64_t result;
  int v10;

  pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
  v2 = oidhash;
  v3 = (*(uint64_t (**)(uint64_t))(oidhash + 16))(a1);
  v4 = *(_QWORD *)v2 + 8 * ((-1640531527 * v3) >> *(_DWORD *)(v2 + 12));
  v5 = *(_QWORD *)v4;
  if (!*(_QWORD *)v4)
    goto LABEL_6;
  v6 = v3;
  while (1)
  {
    v7 = (uint64_t *)v5;
    if (*(_DWORD *)(v5 + 8) == v6)
    {
      if ((*(unsigned int (**)(uint64_t, _QWORD))(v2 + 24))(a1, *(_QWORD *)(v5 + 16)))
        break;
    }
    v5 = *v7;
    v4 = (uint64_t)v7;
    if (!*v7)
      goto LABEL_6;
  }
  if (!*(_QWORD *)v4 || (result = *(_QWORD *)(*(_QWORD *)v4 + 24)) == 0)
  {
LABEL_6:
    ThreadErrInfo = PR_getThreadErrInfo(1, &v10);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0xFFFFE00100000000;
    return 0;
  }
  return result;
}

BOOL SECITEM_HashCompare(size_t *a1, _QWORD *a2)
{
  return SECITEM_ItemsAreEqual(a1, a2);
}

BOOL SECITEM_ItemsAreEqual(size_t *a1, _QWORD *a2)
{
  size_t v2;
  const void *v3;
  const void *v4;

  v2 = *a1;
  if (*a1 != *a2)
    return 0;
  if (!v2)
    return 1;
  v3 = (const void *)a1[1];
  v4 = (const void *)a2[1];
  if (v3 && v4)
    return memcmp(v3, v4, v2) == 0;
  else
    return v3 == v4;
}

uint64_t SECITEM_Hash(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v5;

  v5 = 0;
  v1 = *a1;
  if (!*a1)
    return 0;
  v2 = 0;
  v3 = a1[1];
  do
  {
    *(_BYTE *)((unint64_t)&v5 | v2 & 3) ^= *(_BYTE *)(v3 + v2);
    ++v2;
  }
  while (v1 != v2);
  return v5;
}

uint64_t SEC_ASN1Decode(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t result;

  v7 = SEC_ASN1DecoderStart(a1, a2, a3, (uint64_t)a4, a5);
  if (!v7)
    return 0xFFFFFFFFLL;
  v8 = v7;
  v9 = SEC_ASN1DecoderUpdate(v7, a4, a5);
  LODWORD(result) = SEC_ASN1DecoderFinish(v8);
  if (v9)
    return 0xFFFFFFFFLL;
  else
    return result;
}

uint64_t SecCmsAlgArrayGetIndexByAlgTag(size_t **a1, unsigned int a2)
{
  char *v4;
  size_t *v6;
  uint64_t v7;
  _QWORD *v8;
  unsigned int v9;

  if (!a1)
    return 0xFFFFFFFFLL;
  if (!*a1)
    return 0xFFFFFFFFLL;
  pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
  v4 = a2 <= 0xD8 ? &oids[40 * a2] : 0;
  if (a2 > 0xD8)
    return 0xFFFFFFFFLL;
  v6 = *a1;
  if (*a1)
  {
    v7 = 0;
    v8 = a1 + 1;
    while (!SECITEM_ItemsAreEqual(v6, v4))
    {
      v9 = v7 + 1;
      v6 = (size_t *)v8[v7++];
      if (!v6)
        goto LABEL_16;
    }
    v9 = v7;
  }
  else
  {
    v9 = 0;
  }
LABEL_16:
  if (v6)
    return v9;
  else
    return 0xFFFFFFFFLL;
}

uint64_t SecKeyVerifyDigest(uint64_t a1, const SecAsn1Oid *a2, const UInt8 *a3, CFIndex a4, const UInt8 *a5, CFIndex a6)
{
  const SecAsn1Oid *AlgorithmForSecAsn1AlgId;
  _QWORD v13[6];

  AlgorithmForSecAsn1AlgId = SecKeyGetAlgorithmForSecAsn1AlgId(a1, a2, 0);
  if (!AlgorithmForSecAsn1AlgId)
    return 4294967292;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __SecKeyVerifyDigest_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  v13[4] = a1;
  v13[5] = AlgorithmForSecAsn1AlgId;
  return SecKeyPerformLegacyOperation(a3, a4, a5, a6, 0, 0, v13);
}

void __return_securityd_connection_to_pool_block_invoke(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  int v4;
  CFIndex Count;
  _DWORD v6[2];
  __int16 v7;
  CFIndex v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (CFArrayGetCount((CFArrayRef)sSecuritydConnectionsPool) >= 5)
  {
    xpc_connection_cancel(*(xpc_connection_t *)(a1 + 32));
    v2 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6[0]) = 0;
      _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "xpc: Unable to re-enqueue securityd connection because already at limit", (uint8_t *)v6, 2u);
    }
    if (sSecuritydConnectionsCount <= 4)
    {
      v3 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        v4 = sSecuritydConnectionsCount;
        Count = CFArrayGetCount((CFArrayRef)sSecuritydConnectionsPool);
        v6[0] = 67109376;
        v6[1] = v4;
        v7 = 2048;
        v8 = Count;
        _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "xpc: connection pool full but tracker does not agree (%d vs %ld)", (uint8_t *)v6, 0x12u);
      }
    }
    abort();
  }
  CFArrayAppendValue((CFMutableArrayRef)sSecuritydConnectionsPool, *(const void **)(a1 + 32));
}

BOOL __sec_protocol_options_set_tls_server_name_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    free(*(void **)(a2 + 8));
    *(_QWORD *)(a2 + 8) = strdup(*(const char **)(a1 + 32));
  }
  return a2 != 0;
}

BOOL __sec_protocol_options_append_tls_ciphersuite_group_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  unsigned __int16 *v5;
  unsigned int v6;

  if (a2)
  {
    v3 = *(unsigned __int16 *)(a1 + 32);
    if (v3 <= 4)
    {
      v4 = qword_18AA5AB78[v3];
      v5 = (unsigned __int16 *)*(&off_1E1FCD898 + v3);
      if (!*(_QWORD *)(a2 + 40))
        *(_QWORD *)(a2 + 40) = xpc_array_create(0, 0);
      do
      {
        v6 = *v5++;
        xpc_array_set_uint64(*(xpc_object_t *)(a2 + 40), 0xFFFFFFFFFFFFFFFFLL, v6);
        --v4;
      }
      while (v4);
    }
  }
  return a2 != 0;
}

CFStringRef SecTaskCopyTeamIdentifier(uint64_t a1, CFErrorRef *a2)
{
  return SecTaskCopyIdentifier(a1, 14, a2);
}

uint64_t __sec_protocol_metadata_peers_are_equal_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[5];

  if (!a2)
    return 0;
  v2 = *(_QWORD *)(a1 + 32);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __sec_protocol_metadata_peers_are_equal_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_100;
  v4[4] = a2;
  return sec_protocol_metadata_access_handle(v2, (uint64_t)v4);
}

BOOL sec_protocol_metadata_peers_are_equal(sec_protocol_metadata_t metadataA, sec_protocol_metadata_t metadataB)
{
  BOOL v2;
  _QWORD v4[5];

  v2 = 0;
  if (metadataA && metadataB)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __sec_protocol_metadata_peers_are_equal_block_invoke;
    v4[3] = &__block_descriptor_tmp_101;
    v4[4] = metadataB;
    return sec_protocol_metadata_access_handle((uint64_t)metadataA, (uint64_t)v4);
  }
  return v2;
}

BOOL __sec_protocol_sec_array_of_sec_certificate_are_equal_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;
  _QWORD v5[7];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __sec_protocol_sec_array_of_sec_certificate_are_equal_block_invoke_2;
  v5[3] = &unk_1E1FCD5A0;
  v5[5] = a2;
  v5[6] = a3;
  v3 = *(void **)(a1 + 40);
  v5[4] = *(_QWORD *)(a1 + 32);
  return sec_array_apply(v3, v5);
}

uint64_t sec_protocol_metadata_copy_quic_transport_parameters(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_copy_quic_transport_parameters_block_invoke;
  v3[3] = &unk_1E1FCD300;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t sec_protocol_metadata_copy_serialized_session(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_copy_serialized_session_block_invoke;
  v3[3] = &unk_1E1FCD1F0;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL sec_protocol_metadata_access_distinguished_names(sec_protocol_metadata_t metadata, void *handler)
{
  BOOL v2;
  _QWORD v4[5];

  v2 = 0;
  if (metadata && handler)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __sec_protocol_metadata_access_distinguished_names_block_invoke;
    v4[3] = &unk_1E1FCCFC0;
    v4[4] = handler;
    return sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v4);
  }
  return v2;
}

uint64_t __sec_protocol_metadata_access_distinguished_names_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD v4[5];

  if (!a2)
    return 0;
  result = *(_QWORD *)(a2 + 144);
  if (result)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __sec_protocol_metadata_access_distinguished_names_block_invoke_2;
    v4[3] = &unk_1E1FCCF98;
    v4[4] = *(_QWORD *)(a1 + 32);
    sec_array_apply((void *)result, v4);
    return 1;
  }
  return result;
}

uint64_t sec_protocol_metadata_copy_sec_identity(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_copy_sec_identity_block_invoke;
  v3[3] = &unk_1E1FCD3C8;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t sec_protocol_metadata_copy_sec_trust(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_copy_sec_trust_block_invoke;
  v3[3] = &unk_1E1FCD3A0;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

SSLProtocol sec_protocol_metadata_get_negotiated_protocol_version(sec_protocol_metadata_t metadata)
{
  SSLProtocol v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;

  if (!metadata)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_negotiated_protocol_version_block_invoke;
  v3[3] = &unk_1E1FCCE68;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
  v1 = *((_DWORD *)v5 + 6);
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL sec_protocol_metadata_access_peer_certificate_chain(sec_protocol_metadata_t metadata, void *handler)
{
  BOOL v2;
  _QWORD v4[5];

  v2 = 0;
  if (metadata && handler)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __sec_protocol_metadata_access_peer_certificate_chain_block_invoke;
    v4[3] = &unk_1E1FCCDF0;
    v4[4] = handler;
    return sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v4);
  }
  return v2;
}

tls_protocol_version_t sec_protocol_metadata_get_negotiated_tls_protocol_version(sec_protocol_metadata_t metadata)
{
  tls_protocol_version_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  __int16 v7;

  if (!metadata)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_negotiated_tls_protocol_version_block_invoke;
  v3[3] = &unk_1E1FCCE40;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
  v1 = *((_WORD *)v5 + 12);
  _Block_object_dispose(&v4, 8);
  return v1;
}

const char *__cdecl sec_protocol_metadata_get_negotiated_protocol(sec_protocol_metadata_t metadata)
{
  const char *v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!metadata)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_negotiated_protocol_block_invoke;
  v3[3] = &unk_1E1FCCC60;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
  v1 = (const char *)v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

tls_ciphersuite_t sec_protocol_metadata_get_negotiated_tls_ciphersuite(sec_protocol_metadata_t metadata)
{
  tls_ciphersuite_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  __int16 v7;

  v1 = tls_ciphersuite_CHACHA20_POLY1305_SHA256|tls_ciphersuite_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256|0x2054;
  if (metadata)
  {
    v4 = 0;
    v5 = &v4;
    v6 = 0x2000000000;
    v7 = -1;
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 0x40000000;
    v3[2] = __sec_protocol_metadata_get_negotiated_tls_ciphersuite_block_invoke;
    v3[3] = &unk_1E1FCCE90;
    v3[4] = &v4;
    sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
    v1 = *((_WORD *)v5 + 12);
    _Block_object_dispose(&v4, 8);
  }
  return v1;
}

uint64_t sec_protocol_metadata_access_handle(uint64_t a1, uint64_t a2)
{
  if (sec_protocol_metadata_access_handle_onceToken != -1)
    dispatch_once(&sec_protocol_metadata_access_handle_onceToken, &__block_literal_global_4);
  if (sec_protocol_metadata_access_handle__nw_protocol_metadata_access_handle)
    return sec_protocol_metadata_access_handle__nw_protocol_metadata_access_handle(a1, a2);
  else
    return 0;
}

BOOL __sec_protocol_metadata_get_negotiated_tls_ciphersuite_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 34);
  return a2 != 0;
}

BOOL __sec_protocol_metadata_get_negotiated_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 40);
  return a2 != 0;
}

BOOL __sec_protocol_metadata_get_negotiated_tls_protocol_version_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 32);
  return a2 != 0;
}

uint64_t __sec_protocol_metadata_access_peer_certificate_chain_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD v4[5];

  if (!a2)
    return 0;
  result = *(_QWORD *)(a2 + 88);
  if (result)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __sec_protocol_metadata_access_peer_certificate_chain_block_invoke_2;
    v4[3] = &unk_1E1FCCDC8;
    v4[4] = *(_QWORD *)(a1 + 32);
    sec_array_apply((void *)result, v4);
    return 1;
  }
  return result;
}

BOOL sec_array_apply(void *a1, void *a2)
{
  _QWORD *v3;
  id v4;
  _BOOL8 v5;
  void *v7;
  _QWORD v8[4];
  _QWORD *v9;
  id v10;

  v3 = a1;
  v4 = a2;
  if (v3 && v3[1] && MEMORY[0x18D7718B8]() == MEMORY[0x1E0C812C8])
  {
    v7 = (void *)v3[1];
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = __sec_array_apply_block_invoke;
    v8[3] = &unk_1E1FCDB98;
    v9 = v3;
    v10 = v4;
    v5 = xpc_array_apply(v7, v8);

  }
  else
  {
    v5 = 0;
  }

  return v5;
}

BOOL __sec_protocol_metadata_get_negotiated_protocol_version_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  __int16 *v3;
  int v4;
  int v5;

  if (a2)
  {
    v2 = 0;
    v3 = &word_18AA5C44C;
    while (1)
    {
      v4 = (unsigned __int16)*v3;
      v3 += 4;
      if (v4 == *(unsigned __int16 *)(a2 + 32))
        break;
      if (++v2 == 8)
      {
        v5 = 0;
        goto LABEL_7;
      }
    }
    v5 = ssl_protocol_version_map[2 * v2];
LABEL_7:
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v5;
  }
  return a2 != 0;
}

BOOL __sec_protocol_metadata_copy_sec_trust_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;

  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 168);
    if (v3)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v3;
      v4 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v4)
        os_retain(v4);
    }
  }
  return a2 != 0;
}

BOOL __sec_protocol_metadata_copy_sec_identity_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;

  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 160);
    if (v3)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v3;
      v4 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v4)
        os_retain(v4);
    }
  }
  return a2 != 0;
}

BOOL __sec_protocol_metadata_copy_serialized_session_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t (*v3)(void);

  if (a2)
  {
    v3 = *(uint64_t (**)(void))(a2 + 24);
    if (v3)
    {
      if (*(_QWORD *)(a2 + 16))
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v3();
    }
  }
  return a2 != 0;
}

BOOL __sec_protocol_metadata_copy_quic_transport_parameters_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 152);
    if (v3)
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v3;
      dispatch_retain(*(dispatch_object_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    }
  }
  return a2 != 0;
}

BOOL __sec_protocol_metadata_peers_are_equal_block_invoke_2(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  size_t count;
  int v7;
  _BOOL8 result;
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;

  if (!a2)
    return 0;
  v4 = *(void **)(*(_QWORD *)(a1 + 32) + 88);
  v5 = *(void **)(a2 + 88);
  count = sec_array_get_count(v4);
  if (count != sec_array_get_count(v5))
    return 0;
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 1;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __sec_protocol_sec_array_of_sec_certificate_are_equal_block_invoke;
  v9[3] = &unk_1E1FCD5C8;
  v9[4] = &v10;
  v9[5] = v5;
  sec_array_apply(v4, v9);
  v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  if (!v7)
    return 0;
  result = sec_protocol_dispatch_data_are_equal(*(dispatch_data_t *)(*(_QWORD *)(a1 + 32) + 104), *(NSObject **)(a2 + 104));
  if (result)
  {
    result = sec_protocol_xpc_object_are_equal(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112), *(_QWORD *)(a2 + 112));
    if (result)
    {
      result = sec_protocol_sec_array_of_dispatch_data_are_equal(*(void **)(*(_QWORD *)(a1 + 32) + 136), *(void **)(a2 + 136));
      if (result)
        return sec_protocol_sec_array_of_dispatch_data_are_equal(*(void **)(*(_QWORD *)(a1 + 32) + 144), *(void **)(a2 + 144));
    }
  }
  return result;
}

BOOL sec_protocol_xpc_object_are_equal(unint64_t a1, unint64_t a2)
{
  if (!a1 && a2 || a1 && !a2)
    return 0;
  if (a1 | a2)
    return xpc_equal((xpc_object_t)a1, (xpc_object_t)a2);
  return 1;
}

BOOL sec_protocol_sec_array_of_dispatch_data_are_equal(void *a1, void *a2)
{
  size_t count;
  _BOOL8 v5;
  _QWORD v7[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;

  count = sec_array_get_count(a1);
  if (count != sec_array_get_count(a2))
    return 0;
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 1;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[2] = __sec_protocol_sec_array_of_dispatch_data_are_equal_block_invoke;
  v7[3] = &unk_1E1FCD668;
  v7[4] = &v8;
  v7[5] = a2;
  sec_array_apply(a1, v7);
  v5 = *((_BYTE *)v9 + 24) != 0;
  _Block_object_dispose(&v8, 8);
  return v5;
}

size_t sec_array_get_count(void *a1)
{
  xpc_object_t *v1;
  xpc_object_t *v2;
  size_t count;

  v1 = a1;
  v2 = v1;
  if (v1 && v1[1] && MEMORY[0x18D7718B8]() == MEMORY[0x1E0C812C8])
    count = xpc_array_get_count(v2[1]);
  else
    count = 0;

  return count;
}

BOOL sec_protocol_dispatch_data_are_equal(dispatch_data_t data, NSObject *a2)
{
  _BOOL8 v2;
  size_t size;
  _QWORD v7[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;

  v2 = data == a2;
  if (data != a2 && data && a2)
  {
    size = dispatch_data_get_size(data);
    if (size == dispatch_data_get_size(a2))
    {
      v8 = 0;
      v9 = &v8;
      v10 = 0x2000000000;
      v11 = 1;
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 0x40000000;
      v7[2] = __sec_protocol_dispatch_data_are_equal_block_invoke;
      v7[3] = &unk_1E1FCD618;
      v7[4] = &v8;
      v7[5] = a2;
      dispatch_data_apply(data, v7);
      v2 = *((_BYTE *)v9 + 24) != 0;
      _Block_object_dispose(&v8, 8);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t __sec_protocol_dispatch_data_are_equal_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v6;
  _QWORD v8[8];

  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __sec_protocol_dispatch_data_are_equal_block_invoke_2;
  v8[3] = &unk_1E1FCD5F0;
  v6 = *(NSObject **)(a1 + 40);
  v8[4] = *(_QWORD *)(a1 + 32);
  v8[5] = a3;
  v8[6] = a5;
  v8[7] = a4;
  dispatch_data_apply(v6, v8);
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

BOOL __sec_protocol_dispatch_data_are_equal_block_invoke_2(_QWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  size_t v12;

  v7 = a1[5];
  v6 = a1[6];
  if (v7 <= a3)
    v8 = a3;
  else
    v8 = a1[5];
  v9 = v6 + v7;
  if (v6 + v7 >= a5 + a3)
    v10 = a5 + a3;
  else
    v10 = v6 + v7;
  v11 = v10 > v8;
  v12 = v10 - v8;
  if (v11)
  {
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = memcmp((const void *)(a4 + v8 - a3), (const void *)(a1[7] + v8 - v7), v12) == 0;
  }
  else
  {
    if (v9 < a3)
      return 0;
    if (a5 + a3 < v7)
      return 1;
  }
  return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) != 0;
}

__CFArray *SecCertificateCopySignedCertificateTimestamps(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *i;
  __CFArray *v5;
  unsigned __int16 *v8;
  unint64_t v9;
  const __CFAllocator *v10;
  CFMutableArrayRef Mutable;
  unint64_t v12;
  const UInt8 *v13;
  unint64_t v14;
  BOOL v15;
  const UInt8 *v16;
  CFDataRef v17;
  CFDataRef v18;
  unint64_t v19[3];

  if (!a1)
    return 0;
  v1 = *(_QWORD *)(a1 + 512);
  if (v1 < 1)
    return 0;
  v2 = 0;
  v3 = *(_QWORD *)(a1 + 520);
  for (i = (_QWORD *)(v3 + 8);
        *i != 10 || memcmp((const void *)*(i - 1), &_oidGoogleEmbeddedSignedCertificateTimestamp, 0xAuLL);
        i += 5)
  {
    if (v1 == ++v2)
      return 0;
  }
  memset(v19, 170, sizeof(v19));
  if (DERDecodeItem(v3 + 40 * v2 + 24, v19) || v19[0] != 4)
    return 0;
  v8 = (unsigned __int16 *)v19[1];
  v9 = v19[2];
  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v5 = Mutable;
  if (v9 < 3 || !Mutable)
    goto LABEL_24;
  v12 = __rev16(*v8);
  if (v12 == v9 - 2)
  {
    v13 = (const UInt8 *)(v8 + 1);
    if (!v12)
      return v5;
    while (v12 != 1)
    {
      v14 = __rev16(*(unsigned __int16 *)v13);
      v15 = v12 - 2 >= v14;
      v12 = v12 - 2 - v14;
      if (!v15)
        break;
      v16 = v13 + 2;
      v17 = CFDataCreate(v10, v16, v14);
      if (!v17)
        break;
      v18 = v17;
      v13 = &v16[v14];
      CFArrayAppendValue(v5, v17);
      CFRelease(v18);
      if (!v12)
        return v5;
    }
LABEL_24:
    if (!v5)
      return v5;
  }
  CFRelease(v5);
  return 0;
}

void sec_protocol_options_set_tls_tickets_enabled(sec_protocol_options_t options, BOOL tickets_enabled)
{
  _QWORD v2[4];
  BOOL v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_tickets_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_29;
    v3 = tickets_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

BOOL sec_protocol_options_get_quic_use_legacy_codepoint(sec_protocol_options_t options)
{
  BOOL v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  if (!options)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 1;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_options_get_quic_use_legacy_codepoint_block_invoke;
  v3[3] = &unk_1E1FCC528;
  v3[4] = &v4;
  sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
  v1 = *((_BYTE *)v5 + 24) != 0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t sec_protocol_options_set_tls_encryption_secret_update_block(uint64_t result, uint64_t a2, uint64_t a3)
{
  _QWORD v3[6];

  if (result && a2)
  {
    if (a3)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 0x40000000;
      v3[2] = __sec_protocol_options_set_tls_encryption_secret_update_block_block_invoke;
      v3[3] = &unk_1E1FCC918;
      v3[4] = a2;
      v3[5] = a3;
      return sec_protocol_options_access_handle(result, (uint64_t)v3);
    }
  }
  return result;
}

void sec_protocol_options_set_quic_use_legacy_codepoint(sec_protocol_options_t options, BOOL quic_use_legacy_codepoint)
{
  _QWORD v2[4];
  BOOL v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_quic_use_legacy_codepoint_block_invoke;
    v2[3] = &__block_descriptor_tmp_43;
    v3 = quic_use_legacy_codepoint;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

uint64_t sec_protocol_options_set_output_handler_access_block(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_set_output_handler_access_block_block_invoke;
      v2[3] = &unk_1E1FCCAB0;
      v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }
  return result;
}

uint64_t sec_protocol_options_set_tls_encryption_level_update_block(uint64_t result, uint64_t a2, uint64_t a3)
{
  _QWORD v3[6];

  if (result && a2)
  {
    if (a3)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 0x40000000;
      v3[2] = __sec_protocol_options_set_tls_encryption_level_update_block_block_invoke;
      v3[3] = &unk_1E1FCC940;
      v3[4] = a2;
      v3[5] = a3;
      return sec_protocol_options_access_handle(result, (uint64_t)v3);
    }
  }
  return result;
}

uint64_t sec_protocol_options_set_allow_unknown_alpn_protos(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_allow_unknown_alpn_protos_block_invoke;
    v2[3] = &__block_descriptor_tmp_65;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

uint64_t sec_protocol_options_set_tls_certificate_compression_enabled(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_certificate_compression_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_59;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

uint64_t sec_protocol_options_set_session_update_block(uint64_t result, uint64_t a2, uint64_t a3)
{
  _QWORD v3[6];

  if (result && a2)
  {
    if (a3)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 0x40000000;
      v3[2] = __sec_protocol_options_set_session_update_block_block_invoke;
      v3[3] = &unk_1E1FCC8F0;
      v3[4] = a2;
      v3[5] = a3;
      return sec_protocol_options_access_handle(result, (uint64_t)v3);
    }
  }
  return result;
}

uint64_t sec_protocol_options_set_quic_transport_parameters(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_set_quic_transport_parameters_block_invoke;
      v2[3] = &__block_descriptor_tmp_51;
      v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }
  return result;
}

xpc_object_t sec_protocol_options_copy_transport_specific_application_protocol(uint64_t a1, int a2)
{
  xpc_object_t v4;
  _QWORD v6[5];
  int v7;

  if (!a1)
    return 0;
  v4 = xpc_array_create(0, 0);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __sec_protocol_options_copy_transport_specific_application_protocol_block_invoke;
  v6[3] = &__block_descriptor_tmp_22;
  v6[4] = v4;
  v7 = a2;
  if ((sec_protocol_options_access_handle(a1, (uint64_t)v6) & 1) == 0)
  {
    xpc_release(v4);
    return 0;
  }
  return v4;
}

void sec_protocol_options_set_verify_block(sec_protocol_options_t options, sec_protocol_verify_t verify_block, dispatch_queue_t verify_block_queue)
{
  _QWORD v3[6];

  if (options)
  {
    if (verify_block_queue)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 0x40000000;
      v3[2] = __sec_protocol_options_set_verify_block_block_invoke;
      v3[3] = &unk_1E1FCC8C8;
      v3[4] = verify_block;
      v3[5] = verify_block_queue;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
    }
  }
}

BOOL sec_protocol_options_get_enable_encrypted_client_hello(sec_protocol_options_t options)
{
  BOOL v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  if (!options)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_options_get_enable_encrypted_client_hello_block_invoke;
  v3[3] = &unk_1E1FCC500;
  v3[4] = &v4;
  sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
  v1 = *((_BYTE *)v5 + 24) != 0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sec_protocol_options_set_challenge_block(sec_protocol_options_t options, sec_protocol_challenge_t challenge_block, dispatch_queue_t challenge_queue)
{
  _QWORD v3[6];

  if (options)
  {
    if (challenge_queue)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 0x40000000;
      v3[2] = __sec_protocol_options_set_challenge_block_block_invoke;
      v3[3] = &unk_1E1FCC8A0;
      v3[4] = challenge_block;
      v3[5] = challenge_queue;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
    }
  }
}

void sec_protocol_options_set_tls_is_fallback_attempt(sec_protocol_options_t options, BOOL is_fallback_attempt)
{
  _QWORD v2[4];
  BOOL v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_is_fallback_attempt_block_invoke;
    v2[3] = &__block_descriptor_tmp_28;
    v3 = is_fallback_attempt;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

void sec_protocol_options_set_tls_server_name(sec_protocol_options_t options, const char *server_name)
{
  _QWORD v2[5];

  if (options)
  {
    if (server_name)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_set_tls_server_name_block_invoke;
      v2[3] = &__block_descriptor_tmp_23;
      v2[4] = server_name;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
    }
  }
}

void sec_protocol_options_set_tls_resumption_enabled(sec_protocol_options_t options, BOOL resumption_enabled)
{
  _QWORD v2[4];
  BOOL v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_resumption_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_30;
    v3 = resumption_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

void sec_protocol_options_set_tls_false_start_enabled(sec_protocol_options_t options, BOOL false_start_enabled)
{
  _QWORD v2[4];
  BOOL v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_false_start_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_31;
    v3 = false_start_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

void sec_protocol_options_set_min_tls_protocol_version(sec_protocol_options_t options, tls_protocol_version_t version)
{
  _QWORD v2[4];
  tls_protocol_version_t v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_min_tls_protocol_version_block_invoke;
    v2[3] = &__block_descriptor_tmp_14;
    v3 = version;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

void sec_protocol_options_append_tls_ciphersuite_group(sec_protocol_options_t options, tls_ciphersuite_group_t group)
{
  _QWORD v2[4];
  tls_ciphersuite_group_t v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
    v2[3] = &__block_descriptor_tmp_11;
    v3 = group;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

uint64_t sec_protocol_options_add_transport_specific_application_protocol(uint64_t result, uint64_t a2, int a3)
{
  _QWORD v3[5];
  int v4;

  if (result)
  {
    if (a2)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 0x40000000;
      v3[2] = __sec_protocol_options_add_transport_specific_application_protocol_block_invoke;
      v3[3] = &__block_descriptor_tmp_21;
      v3[4] = a2;
      v4 = a3;
      return sec_protocol_options_access_handle(result, (uint64_t)v3);
    }
  }
  return result;
}

uint64_t sec_protocol_options_access_handle(uint64_t a1, uint64_t a2)
{
  if (sec_protocol_options_access_handle_onceToken != -1)
    dispatch_once(&sec_protocol_options_access_handle_onceToken, &__block_literal_global_2811);
  if (sec_protocol_options_access_handle__nw_protocol_options_access_handle)
    return sec_protocol_options_access_handle__nw_protocol_options_access_handle(a1, a2);
  else
    return 0;
}

OSStatus SecCodeCopySigningInformation(SecStaticCodeRef code, SecCSFlags flags, CFDictionaryRef *information)
{
  char *v5;
  char *v6;
  unsigned __int8 *v7;
  unsigned __int8 v8;
  const void *v9;
  const __CFURL *v10;
  void **v11;
  void *v12;
  const void *v13;
  const UInt8 *v14;
  __CFDictionary *v15;
  const UInt8 *v16;
  __CFDictionary *v17;
  __CFDictionary *v18;
  __CFDictionary *v19;
  const void *v20;
  char *v21;
  char *v22;
  __CFDictionary *v23;
  CFDataRef v24;
  __CFDictionary *v25;
  uint64_t v26;
  CFTypeRef v27;
  Security *v28;
  __CFDictionary *v29;
  const void *v30;
  CFMutableDictionaryRef CFMutableDictionary;
  CFDictionaryRef *v32;
  char *v33;
  uint64_t v34;
  Security::CodeSigning::CodeDirectory *BytePtr;
  __CFDictionary *v36;
  char *v37;
  char *v38;
  BOOL v39;
  const UInt8 *v40;
  __CFDictionary *v41;
  const void **v42;
  _QWORD *v43;
  unint64_t v44;
  _OWORD *v45;
  _QWORD *v46;
  _OWORD *v47;
  const void **v48;
  uint64_t v49;
  unsigned int v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  CFArrayRef v54;
  __CFDictionary *v55;
  unsigned int v56;
  __CFDictionary *v57;
  const void *v58;
  const void *v59;
  const char *v60;
  __CFDictionary *v61;
  const void *v62;
  const void *v63;
  double v64;
  CFDateRef v65;
  double v66;
  CFDateRef v67;
  __CFDictionary *v68;
  const void *v69;
  const void *v70;
  const void *v71;
  NSObject *v72;
  uint64_t v73;
  _QWORD *v74;
  NSObject *v75;
  unint64_t v76;
  CFDictionaryRef *v77;
  void *v78;
  void *v79;
  NSObject *v80;
  size_t v81;
  void *v82;
  UInt8 *v83;
  NSObject *v84;
  const __CFData *v85;
  __CFData *Mutable;
  CFIndex Length;
  UInt8 *MutableBytePtr;
  int v89;
  const UInt8 *v90;
  CFIndex v91;
  const void *v92;
  const void *v93;
  __CFDictionary *v94;
  const __CFData *Dictionary;
  const void *v96;
  CFAbsoluteTime v97;
  CFDateRef v98;
  NSObject *v99;
  uint64_t v100;
  const UInt8 *v101;
  __CFDictionary *v102;
  const void *v103;
  const void *v104;
  const void *v105;
  const void *v106;
  const void *v107;
  __CFDictionary *v108;
  uint64_t v109;
  const UInt8 *v110;
  __int128 v111;
  Security::CCHashInstance *v112;
  unsigned int *v113;
  unsigned int v114;
  CFIndex v115;
  __CFData *v116;
  CFIndex v117;
  uint64_t v118;
  UInt8 *v119;
  const void *v120;
  const void *v121;
  _QWORD *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  _QWORD *v130;
  unsigned __int8 *v131;
  unsigned __int8 v132;
  const void *v133;
  uint64_t v134;
  CFDataRef v135;
  uint64_t v137;
  NSObject *v138;
  NSObject *v139;
  NSObject *v140;
  NSObject *v141;
  char v142;
  CFTypeRef cf;
  unint64_t v144;
  std::string v145;
  void *v146[2];
  char v147;
  void *v148[2];
  char v149;
  void *__p[2];
  char v151;
  CFMutableDictionaryRef theDict;
  int v153;
  size_t __sz;
  void *value;
  unint64_t v156;
  _OWORD valuePtr[4];
  unint64_t v158;
  uint64_t v159;

  v159 = *MEMORY[0x1E0C80C00];
  v142 = flags;
  if (flags >= 0x80)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v144 = 0xAAAAAAAAAAAAAAAALL;
  v5 = (char *)Security::CodeSigning::SecStaticCode::requiredStatic(code, *(const __SecCode **)&flags);
  v6 = v5;
  if (v5)
  {
    v7 = (unsigned __int8 *)(v5 - 8);
    do
      v8 = __ldaxr(v7);
    while (__stlxr(1u, v7));
    if ((v8 & 1) != 0)
    {
      v9 = (const void *)(*(uint64_t (**)(char *))(*(_QWORD *)v5 + 16))(v5);
      CFRetain(v9);
    }
  }
  cf = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  v144 = (unint64_t)v6;
  theDict = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)v6 + 4) + 40))(__p);
  if (v151 >= 0)
    v11 = __p;
  else
    v11 = (void **)__p[0];
  *(_QWORD *)&valuePtr[0] = Security::makeCFURL((Security *)v11, 0, 0, v10);
  theDict = Security::makeCFMutableDictionary(*(Security **)&valuePtr[0], v12, v13, CFSTR("main-executable"), *(_QWORD *)&valuePtr[0]);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)valuePtr);
  if (v151 < 0)
    operator delete(__p[0]);
  v14 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 0);
  v15 = theDict;
  if (!v14)
  {
    theDict = 0;
    goto LABEL_160;
  }
  v16 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 1);
  std::string::basic_string[abi:ne180100]<0>(v148, (char *)&v16[bswap32(*((_DWORD *)v16 + 5))]);
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)valuePtr, (char *)v148);
  CFDictionaryAddValue(v15, CFSTR("identifier"), *(const void **)&valuePtr[0]);
  Security::CFRef<__CFString const*>::~CFRef((const void **)valuePtr);
  if (v149 < 0)
    operator delete(v148[0]);
  v17 = theDict;
  *(_QWORD *)&valuePtr[0] = bswap32(*((_DWORD *)Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 0)+ 3));
  v146[0] = CFNumberCreate(0, kCFNumberLongLongType, valuePtr);
  CFDictionaryAddValue(v17, CFSTR("flags"), v146[0]);
  Security::CFRef<__CFNumber const*>::~CFRef((const void **)v146);
  v18 = theDict;
  (*(void (**)(void **__return_ptr))(**((_QWORD **)v6 + 4) + 128))(v146);
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)valuePtr, (char *)v146);
  CFDictionaryAddValue(v18, CFSTR("format"), *(const void **)&valuePtr[0]);
  Security::CFRef<__CFString const*>::~CFRef((const void **)valuePtr);
  if (v147 < 0)
    operator delete(v146[0]);
  v19 = theDict;
  if (Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 0))
  {
    v20 = (const void *)*((_QWORD *)v6 + 4);
    if (v20)
    {
      if (v21)
      {
        if (v21[151] < 0)
          std::string::__init_copy_ctor_external(&v145, *((const std::string::value_type **)v21 + 16), *((_QWORD *)v21 + 17));
        else
          v145 = *(std::string *)(v21 + 128);
        goto LABEL_26;
      }
    }
    v22 = "embedded";
  }
  else
  {
    v22 = "unsigned";
  }
  std::string::basic_string[abi:ne180100]<0>(&v145, v22);
LABEL_26:
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)valuePtr, (char *)&v145);
  CFDictionaryAddValue(v19, CFSTR("source"), *(const void **)&valuePtr[0]);
  Security::CFRef<__CFString const*>::~CFRef((const void **)valuePtr);
  if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v145.__r_.__value_.__l.__data_);
  v23 = theDict;
  v24 = Security::CodeSigning::SecStaticCode::cdHash((CFDataRef *)v6);
  CFDictionaryAddValue(v23, CFSTR("unique"), v24);
  v25 = theDict;
  v27 = Security::CodeSigning::SecStaticCode::cdHashes((Security::CodeSigning::SecStaticCode *)v6, v26);
  CFDictionaryAddValue(v25, CFSTR("cdhashes"), v27);
  v29 = theDict;
  v30 = (const void *)*((_QWORD *)v6 + 67);
  if (!v30)
  {
    CFMutableDictionary = Security::makeCFMutableDictionary(v28);
    v32 = information;
    v156 = (unint64_t)CFMutableDictionary;
    v33 = (char *)*((_QWORD *)v6 + 13);
    if (v33 != v6 + 112)
    {
      do
      {
        v34 = *((unsigned int *)v33 + 8);
        BytePtr = (Security::CodeSigning::CodeDirectory *)CFDataGetBytePtr(*((CFDataRef *)v33 + 5));
        value = (void *)0xAAAAAAAAAAAAAAAALL;
        value = Security::CodeSigning::CodeDirectory::cdhash(BytePtr, 0);
        if (value)
        {
          v36 = (__CFDictionary *)v156;
          *(_QWORD *)&valuePtr[0] = v34;
          __sz = (size_t)CFNumberCreate(0, kCFNumberLongLongType, valuePtr);
          CFDictionaryAddValue(v36, (const void *)__sz, value);
          Security::CFRef<__CFNumber const*>::~CFRef((const void **)&__sz);
        }
        Security::CFRef<__CFData const*>::~CFRef((const void **)&value);
        v37 = (char *)*((_QWORD *)v33 + 1);
        if (v37)
        {
          do
          {
            v38 = v37;
            v37 = *(char **)v37;
          }
          while (v37);
        }
        else
        {
          do
          {
            v38 = (char *)*((_QWORD *)v33 + 2);
            v39 = *(_QWORD *)v38 == (_QWORD)v33;
            v33 = v38;
          }
          while (!v39);
        }
        v33 = v38;
      }
      while (v38 != v6 + 112);
      CFMutableDictionary = (CFMutableDictionaryRef)v156;
    }
    Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)v6 + 67, CFMutableDictionary);
    Security::CFRef<__CFDictionary *>::~CFRef((const void **)&v156);
    v30 = (const void *)*((_QWORD *)v6 + 67);
    information = v32;
  }
  CFDictionaryAddValue(v29, CFSTR("cdhashes-full"), v30);
  v40 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 0);
  v41 = theDict;
  LODWORD(v156) = v40[37];
  *(_QWORD *)&valuePtr[0] = CFNumberCreate(0, kCFNumberIntType, &v156);
  CFDictionaryAddValue(v41, CFSTR("digest-algorithm"), *(const void **)&valuePtr[0]);
  v42 = Security::CFRef<__CFNumber const*>::~CFRef((const void **)valuePtr);
  value = (void *)0xAAAAAAAAAAAAAAAALL;
  std::set<unsigned int>::set[abi:ne180100]((uint64_t)v42, (_QWORD *)v6 + 43);
  v43 = *(_QWORD **)&valuePtr[0];
  if (*(_OWORD **)&valuePtr[0] == (_OWORD *)((char *)valuePtr + 8))
  {
    v48 = (const void **)operator new[]();
    v44 = 0;
  }
  else
  {
    v44 = 0;
    v45 = *(_OWORD **)&valuePtr[0];
    do
    {
      v46 = (_QWORD *)*((_QWORD *)v45 + 1);
      if (v46)
      {
        do
        {
          v47 = v46;
          v46 = (_QWORD *)*v46;
        }
        while (v46);
      }
      else
      {
        do
        {
          v47 = (_OWORD *)*((_QWORD *)v45 + 2);
          v39 = *(_QWORD *)v47 == (_QWORD)v45;
          v45 = v47;
        }
        while (!v39);
      }
      ++v44;
      v45 = v47;
    }
    while (v47 != (_OWORD *)((char *)valuePtr + 8));
    v48 = (const void **)operator new[]();
    if (v44)
    {
      v49 = 0;
      v50 = 0;
      do
      {
        v51 = (_QWORD *)v43[1];
        v52 = v43;
        if (v51)
        {
          do
          {
            v53 = v51;
            v51 = (_QWORD *)*v51;
          }
          while (v51);
        }
        else
        {
          do
          {
            v53 = (_QWORD *)v52[2];
            v39 = *v53 == (_QWORD)v52;
            v52 = v53;
          }
          while (!v39);
        }
        v48[v49] = ___ZN8Security11CodeSigning13SecStaticCode18signingInformationEj_block_invoke((uint64_t)&__block_literal_global_71, *((_DWORD *)v43 + 7));
        v49 = ++v50;
        v43 = v53;
      }
      while (v44 > v50);
    }
  }
  v54 = CFArrayCreate(0, v48, v44, MEMORY[0x1E0C9B378]);
  MEMORY[0x18D76FA88](v48, 0xC0C80B8AA526DLL);
  value = v54;
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)&valuePtr[0] + 1));
  CFDictionaryAddValue(theDict, CFSTR("digest-algorithms"), value);
  if (v40[38])
  {
    v55 = theDict;
    LODWORD(v156) = v40[38];
    *(_QWORD *)&valuePtr[0] = CFNumberCreate(0, kCFNumberIntType, &v156);
    CFDictionaryAddValue(v55, CFSTR("platform-identifier"), *(const void **)&valuePtr[0]);
    Security::CFRef<__CFNumber const*>::~CFRef((const void **)valuePtr);
  }
  if (bswap32(*((_DWORD *)v40 + 2)) >> 8 >= 0x205)
  {
    v56 = *((_DWORD *)v40 + 22);
    if (v56)
    {
      v57 = theDict;
      *(_QWORD *)&valuePtr[0] = bswap32(v56);
      v156 = (unint64_t)CFNumberCreate(0, kCFNumberLongLongType, valuePtr);
      CFDictionaryAddValue(v57, CFSTR("runtime-version"), (const void *)v156);
      Security::CFRef<__CFNumber const*>::~CFRef((const void **)&v156);
    }
  }
  v58 = (const void *)(*(uint64_t (**)(char *))(*(_QWORD *)v6 + 88))(v6);
  if (v58)
    CFDictionaryAddValue(theDict, CFSTR("info-plist"), v58);
  if ((v142 & 2) != 0)
  {
    v59 = (const void *)Security::CodeSigning::SecStaticCode::signature((Security::CodeSigning::SecStaticCode *)v6);
    CFDictionaryAddValue(theDict, CFSTR("cms"), v59);
    v60 = (const char *)Security::CodeSigning::SecStaticCode::teamID((Security::CodeSigning::SecStaticCode *)v6);
    if (v60)
    {
      v61 = theDict;
      Security::CFTempString::CFTempString<char const*>((CFStringRef *)valuePtr, v60);
      CFDictionaryAddValue(v61, CFSTR("teamid"), *(const void **)&valuePtr[0]);
      Security::CFRef<__CFString const*>::~CFRef((const void **)valuePtr);
    }
    v62 = (const void *)*((_QWORD *)v6 + 77);
    if (v62)
      CFDictionaryAddValue(theDict, CFSTR("trust"), v62);
    Security::CodeSigning::SecStaticCode::validateDirectory((UInt8 *)v6);
    v63 = (const void *)*((_QWORD *)v6 + 78);
    if (v63)
      CFDictionaryAddValue(theDict, CFSTR("certificates"), v63);
    Security::CodeSigning::SecStaticCode::validateDirectory((UInt8 *)v6);
    v64 = *((double *)v6 + 47);
    if (v64 != 0.0)
    {
      *(_QWORD *)&valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
      v65 = CFDateCreate(0, v64);
      *(_QWORD *)&valuePtr[0] = v65;
      if (v65)
        CFDictionaryAddValue(theDict, CFSTR("signing-time"), v65);
      Security::CFRef<__CFDate const*>::~CFRef((const void **)valuePtr);
    }
    Security::CodeSigning::SecStaticCode::validateDirectory((UInt8 *)v6);
    v66 = *((double *)v6 + 48);
    if (v66 != 0.0)
    {
      *(_QWORD *)&valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
      v67 = CFDateCreate(0, v66);
      *(_QWORD *)&valuePtr[0] = v67;
      if (v67)
        CFDictionaryAddValue(theDict, CFSTR("signing-timestamp"), v67);
      Security::CFRef<__CFDate const*>::~CFRef((const void **)valuePtr);
    }
  }
  if ((v142 & 4) != 0
    && Security::CodeSigning::SecStaticCode::defaultDesignatedLightWeightCodeRequirement((Security::CodeSigning::SecStaticCode *)v6))
  {
    v68 = theDict;
    v69 = (const void *)Security::CodeSigning::SecStaticCode::defaultDesignatedLightWeightCodeRequirement((Security::CodeSigning::SecStaticCode *)v6);
    CFDictionaryAddValue(v68, CFSTR("default-designated-lwcr"), v69);
  }
  if ((*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)v6 + 80))(v6, 7, 4294900235))
  {
    v70 = (const void *)Security::CodeSigning::SecStaticCode::entitlements((UInt8 *)v6);
    if (v70)
    {
      v71 = (const void *)*((_QWORD *)v6 + 69);
      if (!v71)
      {
        v72 = secLogObjForScope("staticCode");
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
        {
          v137 = *((_QWORD *)v6 + 68);
          LODWORD(valuePtr[0]) = 134218240;
          *(_QWORD *)((char *)valuePtr + 4) = v6;
          WORD6(valuePtr[0]) = 2048;
          *(_QWORD *)((char *)valuePtr + 14) = v137;
          _os_log_debug_impl(&dword_18A900000, v72, OS_LOG_TYPE_DEBUG, "%p reconstituting XML entitlements with context %p", (uint8_t *)valuePtr, 0x16u);
        }
        v156 = 0;
        v73 = CESizeDeserialization();
        v74 = (_QWORD *)MEMORY[0x1E0DDFFA0];
        if (v73 != *MEMORY[0x1E0DDFFA0])
        {
          v138 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(valuePtr[0]) = 134217984;
            *(_QWORD *)((char *)valuePtr + 4) = v6;
            _os_log_impl(&dword_18A900000, v138, OS_LOG_TYPE_DEFAULT, "%p: couldn't size XML entitlements", (uint8_t *)valuePtr, 0xCu);
          }
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFF995DLL);
        }
        v75 = secLogObjForScope("staticCode");
        if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(valuePtr[0]) = 134218240;
          *(_QWORD *)((char *)valuePtr + 4) = v6;
          WORD6(valuePtr[0]) = 2048;
          *(_QWORD *)((char *)valuePtr + 14) = v156;
          _os_log_debug_impl(&dword_18A900000, v75, OS_LOG_TYPE_DEBUG, "%p desirialized size: %zu", (uint8_t *)valuePtr, 0x16u);
        }
        v76 = v156;
        if (v156)
        {
          v77 = information;
          if (v156 >> 59)
            std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
          v78 = operator new(32 * v156);
          bzero(v78, 32 * v76);
          v79 = v78;
        }
        else
        {
          v77 = information;
          v79 = 0;
        }
        if (CEDeserialize() != *v74)
        {
          v139 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(valuePtr[0]) = 134217984;
            *(_QWORD *)((char *)valuePtr + 4) = v6;
            _os_log_impl(&dword_18A900000, v139, OS_LOG_TYPE_DEFAULT, "%p: couldn't deserialize XML entitlements", (uint8_t *)valuePtr, 0xCu);
          }
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFF995DLL);
        }
        __sz = 0;
        if (CESizeXMLSerialization() != *v74)
        {
          v140 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(valuePtr[0]) = 134217984;
            *(_QWORD *)((char *)valuePtr + 4) = v6;
            _os_log_impl(&dword_18A900000, v140, OS_LOG_TYPE_DEFAULT, "%p: couldn't deserialize XML entitlements", (uint8_t *)valuePtr, 0xCu);
          }
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFF995DLL);
        }
        v80 = secLogObjForScope("staticCode");
        if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(valuePtr[0]) = 134218240;
          *(_QWORD *)((char *)valuePtr + 4) = v6;
          WORD6(valuePtr[0]) = 2048;
          *(_QWORD *)((char *)valuePtr + 14) = __sz;
          _os_log_debug_impl(&dword_18A900000, v80, OS_LOG_TYPE_DEBUG, "%p xml size: %zu", (uint8_t *)valuePtr, 0x16u);
        }
        v81 = __sz;
        if (__sz)
        {
          if ((__sz & 0x8000000000000000) != 0)
            std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
          v82 = operator new(__sz);
          bzero(v82, v81);
          v83 = (UInt8 *)v82;
        }
        else
        {
          v83 = 0;
        }
        if (CESerializeXML() != *v74)
        {
          v141 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(valuePtr[0]) = 134217984;
            *(_QWORD *)((char *)valuePtr + 4) = v6;
            _os_log_impl(&dword_18A900000, v141, OS_LOG_TYPE_DEFAULT, "%p: couldn't make up XML", (uint8_t *)valuePtr, 0xCu);
          }
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFF995DLL);
        }
        v84 = secLogObjForScope("staticCode");
        if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(valuePtr[0]) = 134218242;
          *(_QWORD *)((char *)valuePtr + 4) = v6;
          WORD6(valuePtr[0]) = 2080;
          *(_QWORD *)((char *)valuePtr + 14) = v83;
          _os_log_debug_impl(&dword_18A900000, v84, OS_LOG_TYPE_DEBUG, "%p done serializing %s", (uint8_t *)valuePtr, 0x16u);
        }
        v85 = CFDataCreateWithBytesNoCopy(0, v83, __sz, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
        *(_QWORD *)&valuePtr[0] = v85;
        Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
        Length = CFDataGetLength(v85);
        CFDataSetLength(Mutable, Length + 8);
        if (!Mutable)
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFF94);
        MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
        v89 = CFDataGetLength(v85);
        *(_DWORD *)MutableBytePtr = 1903288058;
        *((_DWORD *)MutableBytePtr + 1) = bswap32(v89 + 8);
        v90 = CFDataGetBytePtr(v85);
        v91 = CFDataGetLength(v85);
        memcpy(MutableBytePtr + 8, v90, v91);
        v92 = (const void *)*((_QWORD *)v6 + 69);
        if (v92)
          CFRelease(v92);
        *((_QWORD *)v6 + 69) = Mutable;
        Security::CFRef<__CFData const*>::~CFRef((const void **)valuePtr);
        if (v83)
          operator delete(v83);
        information = v77;
        if (v79)
          operator delete(v79);
        v71 = (const void *)*((_QWORD *)v6 + 69);
      }
      CFDictionaryAddValue(theDict, CFSTR("entitlements"), v71);
      CFDictionaryAddValue(theDict, CFSTR("entitlements-dict"), v70);
    }
  }
  if ((v142 & 1) != 0)
  {
    v93 = (const void *)*((_QWORD *)v6 + 42);
    if (v93)
      CFDictionaryAddValue(theDict, CFSTR("CodeDirectory"), v93);
    v94 = theDict;
    v156 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v6 + 4) + 88))(*((_QWORD *)v6 + 4));
    *(_QWORD *)&valuePtr[0] = CFNumberCreate(0, kCFNumberLongLongType, &v156);
    CFDictionaryAddValue(v94, CFSTR("CodeOffset"), *(const void **)&valuePtr[0]);
    Security::CFRef<__CFNumber const*>::~CFRef((const void **)valuePtr);
    if ((v142 & 0x20) == 0)
    {
      *(_QWORD *)&valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
      Dictionary = Security::CodeSigning::SecStaticCode::getDictionary((UInt8 *)v6, 3, 0);
      *(_QWORD *)&valuePtr[0] = Dictionary;
      if (Dictionary)
        CFDictionaryAddValue(theDict, CFSTR("ResourceDirectory"), Dictionary);
      Security::CFRef<__CFDictionary const*>::~CFRef((const void **)valuePtr);
    }
    *(_QWORD *)&valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
    v96 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)v6 + 4) + 160))(*((_QWORD *)v6 + 4));
    *(_QWORD *)&valuePtr[0] = v96;
    if (v96)
      CFDictionaryAddValue(theDict, CFSTR("DiskRepInfo"), v96);
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)valuePtr);
    if (v6[596])
    {
      v97 = *((double *)v6 + 75);
      __sz = 0xAAAAAAAAAAAAAAAALL;
      v98 = CFDateCreate(0, v97);
      __sz = (size_t)v98;
      if (v98)
      {
        CFDictionaryAddValue(theDict, CFSTR("NotarizationDate"), v98);
      }
      else
      {
        v99 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v99, OS_LOG_TYPE_DEFAULT))
        {
          v100 = *((_QWORD *)v6 + 75);
          LODWORD(valuePtr[0]) = 134217984;
          *(_QWORD *)((char *)valuePtr + 4) = v100;
          _os_log_impl(&dword_18A900000, v99, OS_LOG_TYPE_DEFAULT, "Error creating date from timestamp: %f", (uint8_t *)valuePtr, 0xCu);
        }
      }
      Security::CFRef<__CFDate const*>::~CFRef((const void **)&__sz);
    }
    if (Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 1))
    {
      v101 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v6, 1);
      v102 = theDict;
      *(_QWORD *)&valuePtr[0] = bswap32(*((_DWORD *)v101 + 2));
      __sz = (size_t)CFNumberCreate(0, kCFNumberLongLongType, valuePtr);
      CFDictionaryAddValue(v102, CFSTR("SignatureVersion"), (const void *)__sz);
      Security::CFRef<__CFNumber const*>::~CFRef((const void **)&__sz);
    }
    v103 = (const void *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)v6 + 80))(v6, 7, 4294900235);
    if (v103)
      CFDictionaryAddValue(theDict, CFSTR("entitlements-DER"), v103);
    v104 = (const void *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)v6 + 80))(v6, 8, 4294900235);
    if (v104)
      CFDictionaryAddValue(theDict, CFSTR("LaunchConstraints-self"), v104);
    v105 = (const void *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)v6 + 80))(v6, 9, 4294900235);
    if (v105)
      CFDictionaryAddValue(theDict, CFSTR("LaunchConstraints-parent"), v105);
    v106 = (const void *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)v6 + 80))(v6, 10, 4294900235);
    if (v106)
      CFDictionaryAddValue(theDict, CFSTR("LaunchConstraints-responsible"), v106);
    v107 = (const void *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*(_QWORD *)v6 + 80))(v6, 11, 4294900235);
    if (v107)
      CFDictionaryAddValue(theDict, CFSTR("LibraryConstraints"), v107);
  }
  if ((v142 & 0x40) != 0)
  {
    v108 = theDict;
    v153 = 2;
    *(_QWORD *)&valuePtr[0] = CFNumberCreate(0, kCFNumberIntType, &v153);
    CFDictionaryAddValue(v108, CFSTR("CMSDigestHashType"), *(const void **)&valuePtr[0]);
    Security::CFRef<__CFNumber const*>::~CFRef((const void **)valuePtr);
    v109 = *Security::CodeSigning::SecStaticCode::codeDirectories((Security::CodeSigning::SecStaticCode *)v6, 1);
    if ((_QWORD *)v109 == Security::CodeSigning::SecStaticCode::codeDirectories((Security::CodeSigning::SecStaticCode *)v6, 1)+ 1)
    {
      __sz = 0;
    }
    else
    {
      v110 = CFDataGetBytePtr(*(CFDataRef *)(v109 + 40));
      v158 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v111 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v111 + 1) = 0xAAAAAAAAAAAAAAAALL;
      valuePtr[2] = v111;
      valuePtr[3] = v111;
      valuePtr[0] = v111;
      valuePtr[1] = v111;
      v112 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)2);
      Security::Mutex::Mutex((pthread_mutex_t *)((char *)valuePtr + 8));
      v113 = (unsigned int *)((char *)v112 + 8);
      do
        v114 = __ldxr(v113);
      while (__stxr(v114 + 1, v113));
      *(_QWORD *)&valuePtr[0] = v112;
      v115 = (*(uint64_t (**)(Security::CCHashInstance *))(*(_QWORD *)v112 + 16))(v112);
      v116 = CFDataCreateMutable(0, v115);
      v117 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)&valuePtr[0] + 16))(*(_QWORD *)&valuePtr[0]);
      CFDataSetLength(v116, v117);
      (*(void (**)(_QWORD, const UInt8 *, _QWORD))(**(_QWORD **)&valuePtr[0] + 24))(*(_QWORD *)&valuePtr[0], v110, bswap32(*((_DWORD *)v110 + 1)));
      v118 = *(_QWORD *)&valuePtr[0];
      v119 = CFDataGetMutableBytePtr(v116);
      (*(void (**)(uint64_t, UInt8 *))(*(_QWORD *)v118 + 32))(v118, v119);
      Security::RefPointer<Security::DynamicHash>::~RefPointer(valuePtr);
      __sz = (size_t)v116;
      if (v116)
        CFDictionaryAddValue(theDict, CFSTR("CMSDigest"), v116);
    }
    Security::CFRef<__CFData const*>::~CFRef((const void **)&__sz);
  }
  if ((v142 & 0x10) != 0)
  {
    if ((v142 & 0x20) == 0)
    {
      v120 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)v6 + 4) + 136))(*((_QWORD *)v6 + 4));
      __sz = (size_t)v120;
      if (v120)
        CFDictionaryAddValue(theDict, CFSTR("changed-files"), v120);
      Security::CFRef<__CFArray const*>::~CFRef((const void **)&__sz);
    }
    v121 = (const void *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)v6 + 4) + 176))(*((_QWORD *)v6 + 4));
    __sz = (size_t)v121;
    if (v121)
      CFDictionaryAddValue(theDict, CFSTR("stapled-ticket"), v121);
    Security::CFRef<__CFData const*>::~CFRef((const void **)&__sz);
  }
  v15 = theDict;
  theDict = 0;
  Security::CFRef<__CFArray const*>::~CFRef((const void **)&value);
LABEL_160:
  Security::CFRef<__CFDictionary *>::~CFRef((const void **)&theDict);
  cf = v15;
  if ((v142 & 8) == 0)
    goto LABEL_175;
  __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  if (!code)
    goto LABEL_179;
  {
    if (v122)
    {
      v130 = v122;
      v131 = (unsigned __int8 *)(v122 - 1);
      do
        v132 = __ldaxr(v131);
      while (__stlxr(1u, v131));
      if ((v132 & 1) != 0)
      {
        v133 = (const void *)(*(uint64_t (**)(_QWORD *))(*v122 + 16))(v122);
        CFRetain(v133);
      }
      __p[0] = v130;
      v134 = v130[2];
      if (v134)
        (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v134 + 104))(v134, v130);
      v135 = Security::cfmake<__CFDictionary const*>((uint64_t)"{+%O,%O=%u}", v123, v124, v125, v126, v127, v128, v129, (uint64_t)cf);
      if (cf)
        CFRelease(cf);
      cf = v135;
      goto LABEL_174;
    }
LABEL_179:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  __p[0] = 0;
LABEL_174:
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)__p);
  v15 = (__CFDictionary *)cf;
LABEL_175:
  cf = 0;
  if (!information)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  *information = v15;
  Security::CFRef<__CFDictionary const*>::~CFRef(&cf);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v144);
  return 0;
}

void sub_18A928898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,char a45,uint64_t a46,char a47,int a48,__int16 a49,char a50,char a51)
{
  void *v51;
  void *v52;

  if (a2)
  {
    if (v52)
      operator delete(v52);
    if (v51)
      operator delete(v51);
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x18A927F78);
  }
  _Unwind_Resume(a1);
}

CFTypeRef Security::CodeSigning::SecStaticCode::component(Security::CodeSigning::SecStaticCode *this, unsigned int a2)
{
  char *v2;
  CFTypeRef v3;
  CFTypeRef *v4;
  CFTypeRef *v7;
  Security::CodeSigning::CodeDirectory *v8;
  Security::CodeSigning::CodeDirectory *v9;
  const UInt8 *BytePtr;
  CFIndex Length;
  Security::CodeSigning::CodeDirectory *v12;
  const __CFData *v13;
  unsigned int *v14;
  unsigned int v15;
  NSObject *v18;
  __CFData *v19;
  unsigned int v20;
  uint64_t v21;
  CFPropertyListRef v22;
  CFDataRef theData;
  uint8_t buf[4];
  Security::CodeSigning::SecStaticCode *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v2 = (char *)this + 8 * a2;
  v3 = (CFTypeRef)*((_QWORD *)v2 + 49);
  v4 = (CFTypeRef *)MEMORY[0x1E0C9B0D0];
  if (v3)
    goto LABEL_23;
  v7 = (CFTypeRef *)(v2 + 392);
  theData = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
  theData = (CFDataRef)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 24))(*((_QWORD *)this + 4));
  if (theData)
  {
    if (!*((_BYTE *)this + 176))
      goto LABEL_6;
    v8 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory(this, 1);
    if (!Security::CodeSigning::CodeDirectory::slotIsPresent(v8, -a2))
    {
      Security::CFRef<__CFData const*>::~CFRef((const void **)&theData);
      return 0;
    }
    v9 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory(this, 1);
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    if (Security::CodeSigning::CodeDirectory::validateSlot(v9, BytePtr, Length, -a2))
    {
LABEL_6:
      Security::CFRef<__CFData const*>::operator=(v7, (CFTypeRef *)&theData);
      goto LABEL_22;
    }
LABEL_29:
    if (a2 == 3)
      v20 = -67023;
    else
      v20 = -67061;
    if (a2 == 1)
      v21 = 4294900266;
    else
      v21 = v20;
    Security::MacOSError::throwMe((Security::MacOSError *)v21);
  }
  if (*((_BYTE *)this + 176))
  {
    v12 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory(this, 1);
    if (Security::CodeSigning::CodeDirectory::slotIsPresent(v12, -a2))
      goto LABEL_29;
  }
  if (a2 == 7)
  {
    v13 = (const __CFData *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *, uint64_t, uint64_t))(*(_QWORD *)this + 80))(this, 5, 4294900235);
    if (v13)
    {
      (*(void (**)(Security::CodeSigning::SecStaticCode *, uint64_t, uint64_t))(*(_QWORD *)this + 96))(this, 5, 4294900235);
      v14 = (unsigned int *)CFDataGetBytePtr(v13);
      v15 = bswap32(v14[1]);
      if (*v14 == 1903288058 && v15 > 7)
      {
        v22 = Security::CodeSigning::EntitlementBlob::entitlements((Security::CodeSigning::EntitlementBlob *)v14);
        if (CESerializeCFDictionary() == *MEMORY[0x1E0DDFFA0])
        {
          v19 = Security::Blob<Security::CodeSigning::EntitlementDERBlob,4208882034u>::blobify(0);
          if (*v7)
            CFRelease(*v7);
          *v7 = v19;
          CFRelease(0);
          Security::CFRef<__CFDictionary const*>::~CFRef(&v22);
          goto LABEL_22;
        }
        v18 = secLogObjForScope("staticCode");
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 134217984;
          v25 = this;
          _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%p the XML cannot be converted to valid DER", buf, 0xCu);
        }
        Security::CFRef<__CFDictionary const*>::~CFRef(&v22);
      }
      else
      {
        *__error() = 22;
      }
    }
  }
  Security::CFRef<__CFArray const*>::operator=(v7, *v4);
LABEL_22:
  Security::CFRef<__CFData const*>::~CFRef((const void **)&theData);
  v3 = *v7;
LABEL_23:
  if (v3 == *v4)
    return 0;
  else
    return v3;
}

void sub_18A929278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

const UInt8 *Security::CodeSigning::SecStaticCode::codeDirectory(Security::CodeSigning::SecStaticCode *this, int a2)
{
  const __CFData *v3;
  const __CFData **v5;
  _QWORD *v6;
  int *v7;
  unsigned int v8;
  _DWORD *v9;
  uint64_t v10;
  unsigned int v11;
  BOOL v12;
  uint64_t *v13;
  unsigned int v14;
  uint64_t *v15;
  unsigned int v16;

  v3 = (const __CFData *)*((_QWORD *)this + 42);
  if (v3)
    return CFDataGetBytePtr(v3);
  v5 = (const __CFData **)((char *)this + 336);
  v6 = Security::CodeSigning::SecStaticCode::codeDirectories(this, a2);
  if (v6)
  {
    v7 = &Security::CodeSigning::hashPriorities;
    v8 = 4;
    while (1)
    {
      if (*((_QWORD *)this + 44))
      {
        v9 = (_DWORD *)((char *)this + 352);
        v10 = *((_QWORD *)this + 44);
        do
        {
          v11 = *(_DWORD *)(v10 + 28);
          v12 = v11 >= v8;
          if (v11 >= v8)
            v13 = (uint64_t *)v10;
          else
            v13 = (uint64_t *)(v10 + 8);
          if (v12)
            v9 = (_DWORD *)v10;
          v10 = *v13;
        }
        while (*v13);
        if (v9 != (_DWORD *)((char *)this + 352) && v8 >= v9[7])
          break;
      }
      v14 = v7[1];
      ++v7;
      v8 = v14;
      if (!v14)
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA48);
    }
    v15 = (uint64_t *)v6[1];
    if (!v15)
LABEL_23:
      std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
    while (1)
    {
      while (1)
      {
        v16 = *((_DWORD *)v15 + 8);
        if (v8 >= v16)
          break;
        v15 = (uint64_t *)*v15;
        if (!v15)
          goto LABEL_23;
      }
      if (v16 >= v8)
        break;
      v15 = (uint64_t *)v15[1];
      if (!v15)
        goto LABEL_23;
    }
    Security::CFRef<__CFData const*>::operator=((CFTypeRef *)this + 42, (CFTypeRef *)v15 + 5);
  }
  v3 = *v5;
  if (*v5)
    return CFDataGetBytePtr(v3);
  if (a2)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ALL);
  return 0;
}

void sub_18A9293C8(void *a1)
{
  int v1;
  _QWORD *v2;
  const char *v3;

  __cxa_begin_catch(a1);
  if (!v1)
  {
    if (!*v2)
    {
      __cxa_end_catch();
      if (!*v2)
        JUMPOUT(0x18A9293A8);
      JUMPOUT(0x18A929394);
    }
    Security::Syslog::warning((Security::Syslog *)"code signing internal problem: mDir set despite exception exit", v3);
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
  }
  __cxa_rethrow();
}

void sub_18A929410(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

CFDataRef Security::CodeSigning::BundleDiskRep::component(Security::CodeSigning::BundleDiskRep *this, Security::CodeSigning::CodeDirectory *a2)
{
  const void *v4;
  const __CFURL *v5;
  void **v6;
  Security::UnixPlusPlus::FileDesc *v7;
  timespec v8;
  CFDataRef v9;
  const char *v10;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  stat *v15;
  const void *v16;
  Security::UnixPlusPlus::FileDesc *v17;
  void *__p[3];
  stat v19;
  uint8_t buf[4];
  stat *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a2 == 3)
  {
    std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)this + 23, 3u, 3);
    v10 = Security::CodeSigning::CodeDirectory::canonicalSlotName((Security::CodeSigning::CodeDirectory *)3);
    if (v10)
      return Security::CodeSigning::BundleDiskRep::metaData(this, v10);
  }
  else
  {
    if ((_DWORD)a2 == 1)
    {
      v4 = (const void *)_CFBundleCopyInfoPlistURL();
      v16 = v4;
      if (v4)
      {
        v5 = (const __CFURL *)v4;
        memset(__p, 170, sizeof(__p));
        Security::cfString((Security *)__p, (const __CFURL *)v4);
        v17 = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAFFFFFFFFLL;
        if (SHIBYTE(__p[2]) >= 0)
          v6 = __p;
        else
          v6 = (void **)__p[0];
        Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v17, (const char *)v6, 0, 438);
        v7 = (Security::UnixPlusPlus::FileDesc *)v17;
        Security::CodeSigning::BundleDiskRep::checkPlainFile((uint64_t)this, (Security::UnixPlusPlus::FileDesc *)v17, (uint64_t)__p);
        v8.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v8.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        *(timespec *)&v19.st_blksize = v8;
        *(timespec *)v19.st_qspare = v8;
        *(timespec *)&v19.st_size = v8;
        v19.st_ctimespec = v8;
        v19.st_birthtimespec = v8;
        v19.st_atimespec = v8;
        v19.st_mtimespec = v8;
        *(timespec *)&v19.st_dev = v8;
        *(timespec *)&v19.st_uid = v8;
        Security::UnixPlusPlus::FileDesc::fstat(v7, &v19);
        v9 = Security::cfMapFile(v7, v19.st_size);
        if (!v9)
        {
          v14 = secLogObjForScope("bundlediskrep");
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            Security::cfString((Security *)&v19, v5);
            if ((v19.st_gid & 0x80000000) == 0)
              v15 = &v19;
            else
              v15 = *(stat **)&v19.st_dev;
            *(_DWORD *)buf = 136315138;
            v21 = v15;
            _os_log_debug_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEBUG, "failed to load %s", buf, 0xCu);
            if (SHIBYTE(v19.st_gid) < 0)
              operator delete(*(void **)&v19.st_dev);
          }
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA45);
        }
        Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v17);
        if (SHIBYTE(__p[2]) < 0)
          operator delete(__p[0]);
      }
      else
      {
        v9 = 0;
      }
      Security::CFRef<__CFURL const*>::~CFRef(&v16);
      return v9;
    }
    v12 = (*(uint64_t (**)(_QWORD, Security::CodeSigning::CodeDirectory *))(**((_QWORD **)this + 13) + 24))(*((_QWORD *)this + 13), a2);
    *(_QWORD *)&v19.st_dev = v12;
    if (v12)
    {
      v9 = (CFDataRef)v12;
      if (*((_BYTE *)this + 177))
      {
        if (!*((_BYTE *)this + 176))
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0BLL);
      }
      else
      {
        *((_WORD *)this + 88) = 257;
      }
LABEL_29:
      *(_QWORD *)&v19.st_dev = 0;
      Security::CFRef<__CFData const*>::~CFRef((const void **)&v19);
      return v9;
    }
    Security::CFRef<__CFData const*>::~CFRef((const void **)&v19);
    *(_QWORD *)&v19.st_dev = 0xAAAAAAAAAAAAAAAALL;
    v13 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
    if (v13)
    {
      *(_QWORD *)&v19.st_dev = Security::CodeSigning::BundleDiskRep::metaData(this, v13);
      if (*(_QWORD *)&v19.st_dev)
      {
        if (*((_BYTE *)this + 177))
        {
          if (*((_BYTE *)this + 176))
            Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0BLL);
        }
        else
        {
          *((_WORD *)this + 88) = 256;
        }
        std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)this + 23, a2, (int)a2);
        v9 = *(CFDataRef *)&v19.st_dev;
        goto LABEL_29;
      }
    }
    else
    {
      *(_QWORD *)&v19.st_dev = 0;
    }
    Security::CFRef<__CFData const*>::~CFRef((const void **)&v19);
  }
  return 0;
}

void sub_18A92972C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  _Unwind_Resume(exception_object);
}

const void **Security::CFRef<__CFData const*>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

CFDataRef Security::CodeSigning::MachORep::component(Security::CodeSigning::MachORep *this, Security::CodeSigning::EmbeddedSignatureBlob *a2)
{
  CFDataRef result;
  Security::CodeSigning::EmbeddedSignatureBlob *v5;
  const Security::BlobCore *v6;

  if ((_DWORD)a2 == 1)
    return (CFDataRef)Security::CodeSigning::MachORep::infoPlist(this);
  result = (CFDataRef)Security::CodeSigning::MachORep::signingData(this);
  if (result)
  {
    v5 = (Security::CodeSigning::EmbeddedSignatureBlob *)Security::CodeSigning::MachORep::signingData(this);
    return Security::CodeSigning::EmbeddedSignatureBlob::component(v5, a2, v6);
  }
  return result;
}

uint64_t Security::CodeSigning::MachORep::signingData(Security::CodeSigning::MachORep *this)
{
  uint64_t result;
  off_t *v3;
  uint64_t v4;
  const load_command *CodeSignature;
  unsigned int cmd;
  unsigned int cmdsize;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  size_t v11;
  _DWORD *Blob;
  void *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unsigned int v18;
  unint64_t v19;
  BOOL v20;
  NSObject *v21;
  NSObject *v22;
  _BYTE *v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  cpu_type_t v28;
  unsigned int v29;
  const NXArchInfo *v30;
  const char *v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;
  _BYTE *v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  cpu_type_t v40;
  unsigned int v41;
  const NXArchInfo *v42;
  uint64_t v43;
  unsigned int v44;
  const char *name;
  _BYTE v46[12];
  __int16 v47;
  const char *v48;
  char v49;
  _BYTE __p[12];
  __int16 v51;
  unsigned int v52;
  __int16 v53;
  _BYTE *v54;
  __int16 v55;
  const char *v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  result = *((_QWORD *)this + 8);
  if (!result)
  {
    v3 = (off_t *)(*(uint64_t (**)(Security::CodeSigning::MachORep *))(*(_QWORD *)this + 80))(this);
    v4 = Security::Universal::architecture(v3);
    CodeSignature = Security::MachOBase::findCodeSignature((Security::MachOBase *)v4);
    if (CodeSignature)
    {
      cmd = CodeSignature[1].cmd;
      cmdsize = CodeSignature[1].cmdsize;
      v8 = bswap32(cmd);
      if (*(_BYTE *)(v4 + 33))
        v9 = v8;
      else
        v9 = cmd;
      v10 = bswap32(cmdsize);
      if (*(_BYTE *)(v4 + 33))
        v11 = v10;
      else
        v11 = cmdsize;
      Blob = Security::BlobCore::readBlob((Security::BlobCore *)*(unsigned int *)(v4 + 36), *(_QWORD *)(v4 + 48) + v9, -86111040, v11);
      v13 = Blob;
      if (Blob)
      {
        if (*Blob == -1072898310)
        {
          v14 = bswap32(Blob[2]);
          v15 = 8 * v14 + 12;
          v16 = bswap32(Blob[1]);
          if (v15 <= v16)
          {
            v17 = (unint64_t)&Blob[2 * v14 + 3];
            while (1)
            {
              v17 -= 8;
              if (v17 < (unint64_t)(Blob + 3))
                break;
              v18 = *(_DWORD *)(v17 + 4);
              if (v18)
              {
                v19 = bswap32(v18);
                v20 = v15 > v19 || v19 + 8 > v16;
                if (v20 || bswap32(*(_DWORD *)((char *)Blob + v19 + 4)) + v19 > v16)
                  goto LABEL_25;
              }
            }
            *((_QWORD *)this + 8) = Blob;
            v21 = secLogObjForScope("machorep");
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
              v32 = *((_QWORD *)this + 8);
              v34 = *(_DWORD *)(v32 + 4);
              v33 = *(_DWORD *)(v32 + 8);
              v35 = v46;
              (*(void (**)(_BYTE *__return_ptr, Security::CodeSigning::MachORep *))(*(_QWORD *)this + 40))(v46, this);
              if (v49 < 0)
                v35 = *(_BYTE **)v46;
              v36 = *(_QWORD *)(v4 + 8);
              v38 = *(_DWORD *)(v36 + 4);
              v37 = *(_DWORD *)(v36 + 8);
              v39 = bswap32(v38);
              if (*(_BYTE *)(v4 + 33))
                v40 = v39;
              else
                v40 = v38;
              v41 = bswap32(v37);
              if (*(_BYTE *)(v4 + 33))
                v37 = v41;
              v42 = NXGetArchInfoFromCpuType(v40, v37 & 0xFFFFFF);
              v43 = bswap32(v34);
              v44 = bswap32(v33);
              if (v42)
                name = v42->name;
              else
                name = 0;
              *(_DWORD *)__p = 134218754;
              *(_QWORD *)&__p[4] = v43;
              v51 = 1024;
              v52 = v44;
              v53 = 2080;
              v54 = v35;
              v55 = 2080;
              v56 = name;
              _os_log_debug_impl(&dword_18A900000, v21, OS_LOG_TYPE_DEBUG, "%zd signing bytes in %d blob(s) from %s(%s)", __p, 0x26u);
              if (v49 < 0)
                operator delete(*(void **)v46);
            }
            goto LABEL_22;
          }
        }
        *__error() = 22;
LABEL_25:
        free(v13);
      }
      *((_QWORD *)this + 8) = 0;
      v22 = secLogObjForScope("machorep");
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        (*(void (**)(_BYTE *__return_ptr, Security::CodeSigning::MachORep *))(*(_QWORD *)this + 40))(__p, this);
        if (SBYTE3(v54) >= 0)
          v23 = __p;
        else
          v23 = *(_BYTE **)__p;
        v24 = *(_QWORD *)(v4 + 8);
        v26 = *(_DWORD *)(v24 + 4);
        v25 = *(_DWORD *)(v24 + 8);
        v27 = bswap32(v26);
        if (*(_BYTE *)(v4 + 33))
          v28 = v27;
        else
          v28 = v26;
        v29 = bswap32(v25);
        if (*(_BYTE *)(v4 + 33))
          v25 = v29;
        v30 = NXGetArchInfoFromCpuType(v28, v25 & 0xFFFFFF);
        if (v30)
          v31 = v30->name;
        else
          v31 = 0;
        *(_DWORD *)v46 = 136315394;
        *(_QWORD *)&v46[4] = v23;
        v47 = 2080;
        v48 = v31;
        _os_log_debug_impl(&dword_18A900000, v22, OS_LOG_TYPE_DEBUG, "failed to read signing bytes from %s(%s)", v46, 0x16u);
        if (SBYTE3(v54) < 0)
          operator delete(*(void **)__p);
      }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA1BLL);
    }
LABEL_22:
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    return *((_QWORD *)this + 8);
  }
  return result;
}

void sub_18A929B6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v21;

  if (a14 < 0)
    operator delete(__p);
  (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
  _Unwind_Resume(a1);
}

BOOL Security::CodeSigning::CodeDirectory::slotIsPresent(Security::CodeSigning::CodeDirectory *this, signed int a2)
{
  _BOOL8 result;
  uint64_t v4;
  unsigned __int8 *v5;
  uint64_t v6;
  int v7;
  BOOL v8;

  result = 0;
  if ((signed int)-bswap32(*((_DWORD *)this + 6)) <= a2)
  {
    if ((int)bswap32(*((_DWORD *)this + 7)) > a2 && (v4 = *((unsigned __int8 *)this + 36), *((_BYTE *)this + 36)))
    {
      v5 = (unsigned __int8 *)this + bswap32(*((_DWORD *)this + 4)) + (int)v4 * a2;
      v6 = v4 - 1;
      do
      {
        v7 = *v5++;
        result = v7 != 0;
        if (v7)
          v8 = 1;
        else
          v8 = v6 == 0;
        --v6;
      }
      while (!v8);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFDataRef Security::CodeSigning::EmbeddedSignatureBlob::component(Security::CodeSigning::EmbeddedSignatureBlob *this, Security::CodeSigning::EmbeddedSignatureBlob *a2, const Security::BlobCore *a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  const UInt8 *v9;
  BOOL v10;

  v3 = *((_DWORD *)this + 2);
  if (!v3)
    return 0;
  v4 = 0;
  LODWORD(v5) = bswap32(v3);
  v5 = v5 <= 1 ? 1 : v5;
  v6 = (unsigned int *)((char *)this + 12);
  while (1)
  {
    v7 = *v6;
    v6 += 2;
    if (bswap32(v7) == (_DWORD)a2)
      break;
    if (v5 == ++v4)
      return 0;
  }
  v8 = *((_DWORD *)this + 2 * v4 + 4);
  v10 = v8 == 0;
  v9 = (const UInt8 *)this + bswap32(v8);
  v10 = v10 || v9 == 0;
  if (v10)
    return 0;
  else
    return Security::CodeSigning::EmbeddedSignatureBlob::blobData(a2, v9, a3);
}

CFTypeRef *Security::CFRef<__CFArray const*>::operator=(CFTypeRef *a1, CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  if (*a1)
    CFRelease(*a1);
  *a1 = cf;
  return a1;
}

const void **Security::CFRef<__CFNumber const*>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const char *Security::CodeSigning::CodeDirectory::canonicalSlotName(Security::CodeSigning::CodeDirectory *this)
{
  int v1;
  int v2;
  const char *result;

  v1 = (int)this;
  v2 = (int)this;
  result = "CodeRequirements";
  switch(v2)
  {
    case 0:
      result = "CodeDirectory";
      break;
    case 1:
LABEL_7:
      result = 0;
      break;
    case 2:
      return result;
    case 3:
      result = "CodeResources";
      break;
    case 4:
      result = "CodeTopDirectory";
      break;
    case 5:
      result = "CodeEntitlements";
      break;
    case 6:
      result = "CodeRepSpecific";
      break;
    case 7:
      result = "CodeEntitlementDER";
      break;
    case 8:
      result = "LaunchConstraintSelf";
      break;
    case 9:
      result = "LaunchConstraintParent";
      break;
    case 10:
      result = "LaunchConstraintResponsible";
      break;
    case 11:
      result = "LibraryConstraint";
      break;
    default:
      switch(v1)
      {
        case 4096:
          result = "CodeRequirements-1";
          break;
        case 4097:
          result = "CodeRequirements-2";
          break;
        case 4098:
          result = "CodeRequirements-3";
          break;
        case 4099:
          result = "CodeRequirements-4";
          break;
        case 4100:
          result = "CodeRequirements-5";
          break;
        default:
          if (v1 != 0x10000)
            goto LABEL_7;
          result = "CodeSignature";
          break;
      }
      break;
  }
  return result;
}

CFDataRef Security::CodeSigning::BundleDiskRep::metaData(Security::CodeSigning::BundleDiskRep *this, const char *a2)
{
  const __CFURL *v3;
  Security *p_p;
  CFURLRef CFURL;
  const __CFURL *v6;
  Security *v7;
  CFDataRef File;
  NSObject *v9;
  CFURLRef v11;
  std::string __p;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  Security::CodeSigning::BundleDiskRep::metaPath(&__p, (const char *)this, a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = (Security *)&__p;
  else
    p_p = (Security *)__p.__r_.__value_.__r.__words[0];
  CFURL = Security::makeCFURL(p_p, 0, 0, v3);
  v7 = CFURL;
  v11 = CFURL;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v7)
      goto LABEL_6;
  }
  else if (CFURL)
  {
LABEL_6:
    File = Security::cfLoadFile(v7, v6);
    goto LABEL_11;
  }
  v9 = secLogObjForScope("bundlediskrep");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "no metapath for %s", (uint8_t *)&__p, 0xCu);
  }
  File = 0;
LABEL_11:
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v11);
  return File;
}

void sub_18A929F44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  Security::CFRef<__CFURL const*>::~CFRef(&a10);
  _Unwind_Resume(a1);
}

const void **Security::CFRef<__CFURL const*>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

CFURLRef Security::makeCFURL(Security *this, const char *a2, uint64_t a3, const __CFURL *a4)
{
  CFURLRef v6;
  CFURLRef v7;
  CFStringRef filePath;

  if (a3)
  {
    Security::CFTempString::CFTempString<char const*>(&filePath, (const char *)this);
    v6 = (CFURLRef)MEMORY[0x18D76F668](0, filePath, 0, a2, a3);
  }
  else
  {
    Security::CFTempString::CFTempString<char const*>(&filePath, (const char *)this);
    v6 = CFURLCreateWithFileSystemPath(0, filePath, kCFURLPOSIXPathStyle, (Boolean)a2);
  }
  v7 = v6;
  Security::CFRef<__CFString const*>::~CFRef((const void **)&filePath);
  return v7;
}

void sub_18A92A028(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFString const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **Security::CFRef<__CFString const*>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

CFStringRef *Security::CFTempString::CFTempString<char const*>(CFStringRef *a1, const char *a2)
{
  CFStringRef v4;

  if (a2)
  {
    v4 = CFStringCreateWithCString(0, a2, 0x8000100u);
    if (!v4)
    {
      v4 = CFStringCreateWithCString(0, a2, 0x600u);
      if (!v4)
        Security::CFError::throwMe(0);
    }
  }
  else
  {
    v4 = 0;
  }
  *a1 = v4;
  return a1;
}

void Security::CodeSigning::BundleDiskRep::metaPath(std::string *this, const char *a2, const char *a3)
{
  char *v6;
  const __CFURL *v7;
  std::string::size_type size;
  _BYTE *v9;
  std::string *v10;
  const char *v11;
  size_t v12;
  std::string *v13;
  char *v14;
  std::string::size_type v15;
  std::string *v16;
  _BYTE v17[24];
  std::string v18;

  v6 = (char *)(a2 + 32);
  if (a2[55] < 0)
  {
    if (*((_QWORD *)a2 + 5))
      goto LABEL_20;
  }
  else if (a2[55])
  {
    goto LABEL_20;
  }
  memset(&v18, 170, sizeof(v18));
  v7 = CFBundleCopySupportFilesDirectoryURL(*((CFBundleRef *)a2 + 3));
  Security::cfStringRelease((Security *)&v18, v7);
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v18.__r_.__value_.__r.__words[2]);
  else
    size = v18.__r_.__value_.__l.__size_;
  memset(v17, 170, sizeof(v17));
  v9 = v17;
  std::string::basic_string[abi:ne180100]((uint64_t)v17, size + 15);
  if (v17[23] < 0)
    v9 = *(_BYTE **)v17;
  if (size)
  {
    if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v10 = &v18;
    else
      v10 = (std::string *)v18.__r_.__value_.__r.__words[0];
    memmove(v9, v10, size);
  }
  strcpy(&v9[size], "/_CodeSignature");
  if (a2[55] < 0)
    operator delete(*(void **)v6);
  *(_OWORD *)v6 = *(_OWORD *)v17;
  *((_QWORD *)v6 + 2) = *(_QWORD *)&v17[16];
  v11 = v6;
  if (a2[55] < 0)
    v11 = *(const char **)v6;
  *((_BYTE *)a2 + 56) = access(v11, 0) == 0;
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v18.__r_.__value_.__l.__data_);
    if (a3)
      goto LABEL_21;
LABEL_34:
    if (a2[55] < 0)
    {
      std::string::__init_copy_ctor_external(this, *((const std::string::value_type **)a2 + 4), *((_QWORD *)a2 + 5));
    }
    else
    {
      *(_OWORD *)&this->__r_.__value_.__l.__data_ = *(_OWORD *)v6;
      this->__r_.__value_.__r.__words[2] = *((_QWORD *)v6 + 2);
    }
    return;
  }
LABEL_20:
  if (!a3)
    goto LABEL_34;
LABEL_21:
  if (a2[55] >= 0)
    v12 = *((unsigned __int8 *)a2 + 55);
  else
    v12 = *((_QWORD *)a2 + 5);
  memset(&v18, 170, sizeof(v18));
  v13 = &v18;
  std::string::basic_string[abi:ne180100]((uint64_t)&v18, v12 + 1);
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v13 = (std::string *)v18.__r_.__value_.__r.__words[0];
  if (v12)
  {
    if (a2[55] >= 0)
      v14 = v6;
    else
      v14 = (char *)*((_QWORD *)a2 + 4);
    memmove(v13, v14, v12);
  }
  *(_WORD *)((char *)&v13->__r_.__value_.__l.__data_ + v12) = 47;
  v15 = strlen(a3);
  v16 = std::string::append(&v18, a3, v15);
  *this = *v16;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v18.__r_.__value_.__l.__data_);
}

void sub_18A92A2F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFDataRef Security::cfLoadFile(Security *this, const __CFURL *a2)
{
  void **v2;
  timespec v3;
  Security::UnixPlusPlus::FileDesc *v4;
  CFDataRef v5;
  timespec v6;
  stat v8;
  int v9[2];
  void *__p[2];
  uint64_t v11;
  stat v12;

  Security::cfString((Security *)&v12, this);
  *(_OWORD *)__p = *(_OWORD *)&v12.st_dev;
  v11 = *(_QWORD *)&v12.st_uid;
  if ((v12.st_gid & 0x80000000) == 0)
    v2 = __p;
  else
    v2 = (void **)__p[0];
  *(_QWORD *)v9 = 0xAAAAAAAAFFFFFFFFLL;
  Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)v9, (const char *)v2, 0, 4534);
  v3.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v8.st_blksize = v3;
  *(timespec *)v8.st_qspare = v3;
  v8.st_birthtimespec = v3;
  *(timespec *)&v8.st_size = v3;
  v8.st_mtimespec = v3;
  v8.st_ctimespec = v3;
  *(timespec *)&v8.st_uid = v3;
  v8.st_atimespec = v3;
  *(timespec *)&v8.st_dev = v3;
  v4 = (Security::UnixPlusPlus::FileDesc *)v9[0];
  if (v9[0] == -1)
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    if (!fstat(v9[0], &v8) && (v8.st_size & 0x8000000000000000) == 0)
    {
      v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&v12.st_blksize = v6;
      *(timespec *)v12.st_qspare = v6;
      v12.st_birthtimespec = v6;
      *(timespec *)&v12.st_size = v6;
      v12.st_mtimespec = v6;
      v12.st_ctimespec = v6;
      *(timespec *)&v12.st_uid = v6;
      v12.st_atimespec = v6;
      *(timespec *)&v12.st_dev = v6;
      Security::UnixPlusPlus::FileDesc::fstat(v4, &v12);
      v5 = Security::cfMapFile(v4, v12.st_size);
    }
  }
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)v9);
  if (SHIBYTE(v11) < 0)
    operator delete(__p[0]);
  return v5;
}

void sub_18A92A42C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *Security::cfString(Security *this, const __CFURL *a2)
{
  Security *v3;
  UInt8 __b[1025];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (!a2
    || (v3 = this,
        memset(__b, 170, sizeof(__b)),
        this = (Security *)CFURLGetFileSystemRepresentation(a2, 1u, __b, 1025),
        !(_DWORD)this))
  {
    Security::CFError::throwMe(this);
  }
  return std::string::basic_string[abi:ne180100]<0>(v3, (char *)__b);
}

void Security::UnixPlusPlus::FileDesc::closeAndLog(Security::UnixPlusPlus::FileDesc *this)
{
  int v2;
  int v3;
  int v4;
  NSObject *v5;
  int v6;
  NSObject *v7;
  int v8;
  uint8_t buf[4];
  int v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = *(_DWORD *)this;
  if ((v2 & 0x80000000) == 0)
  {
    v3 = 0;
    v4 = 2;
    while (close(v2) == -1 && v4)
    {
      v3 = *__error();
      if ((v3 & 0xFFFFFFFE) == 4)
      {
        --v4;
      }
      else
      {
        v5 = secLogObjForScope("unixio");
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        {
          v6 = *(_DWORD *)this;
          *(_DWORD *)buf = 67109376;
          v10 = v6;
          v11 = 1024;
          v12 = v3;
          _os_log_debug_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEBUG, "close(%d) error %d", buf, 0xEu);
        }
        v4 = 0;
      }
      v2 = *(_DWORD *)this;
    }
    v7 = secLogObjForScope("unixio");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v8 = *(_DWORD *)this;
      *(_DWORD *)buf = 67109376;
      v10 = v8;
      v11 = 1024;
      v12 = v3;
      _os_log_debug_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEBUG, "close(%d) err: %d", buf, 0xEu);
    }
    *(_DWORD *)this = -1;
  }
}

void Security::UnixPlusPlus::FileDesc::open(Security::UnixPlusPlus::FileDesc *this, const char *a2, int a3, int a4)
{
  int v8;
  NSObject *v9;
  int v10;
  int *v11;
  int *v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v8 = open(a2, a3, a4 & 0xFFF);
  *(_DWORD *)this = v8;
  if (v8 == -1)
  {
    v11 = __error();
    if ((a4 & 0xF000) != 0x1000 || *v11 != 2)
    {
      v12 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v12);
    }
  }
  else
  {
    *((_BYTE *)this + 4) = 0;
    v9 = secLogObjForScope("unixio");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      v10 = *(_DWORD *)this;
      *(_DWORD *)buf = 136315906;
      v14 = a2;
      v15 = 1024;
      v16 = a3;
      v17 = 1024;
      v18 = a4;
      v19 = 1024;
      v20 = v10;
      _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "open(%s,0x%x,0x%x) = %d", buf, 0x1Eu);
    }
  }
}

CFTypeRef *Security::CFRef<__CFData const*>::operator=(CFTypeRef *a1, CFTypeRef *a2)
{
  CFTypeRef v4;

  if (*a2)
  {
    CFRetain(*a2);
    v4 = *a2;
  }
  else
  {
    v4 = 0;
  }
  if (*a1)
    CFRelease(*a1);
  *a1 = v4;
  return a1;
}

UInt8 *Security::CodeSigning::SecStaticCode::validateDirectory(UInt8 *this)
{
  uint64_t v1;
  const UInt8 *v2;
  const __CFData *v3;
  const void *v4;
  CFArrayRef CFArray;
  const __CFData *v6;
  const void *v7;
  Security::MacOSError *v8;
  Security::MacOSError *v9;
  const void *Value;
  const __CFData *v11;
  const void *v12;
  uint64_t v13;
  CFTypeRef v14;
  CFArrayRef v15;
  const void *v16;
  BOOL v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  const __CFDictionary *CFDictionaryFrom;
  int v24;
  unint64_t v25;
  CFTypeRef cf;
  void *__p[7];

  v1 = (uint64_t)this;
  __p[6] = *(void **)MEMORY[0x1E0C80C00];
  if (!this[176] || (this[211] & 0x40) != 0 && !this[177])
  {
    v2 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)this, 0);
    if (!v2 || (v2[15] & 2) == 0)
    {
      __p[3] = (void *)v1;
      v3 = (const __CFData *)Security::CodeSigning::SecStaticCode::signature((Security::CodeSigning::SecStaticCode *)v1);
      Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v1, 1);
      *(_QWORD *)(v1 + 376) = 0;
      v25 = 0xAAAAAAAAAAAAAAAALL;
      cf = 0;
      if ((*(_BYTE *)(v1 + 209) & 4) != 0)
        __p[0] = SecPolicyCreateAppleSoftwareSigning();
      else
        __p[0] = SecPolicyCreateiPhoneApplicationSigning();
      CFArray = Security::makeCFArray((Security *)__p[0], v4, __p[0]);
      Security::CFRef<__SecPolicy *>::~CFRef((const void **)__p);
      v25 = (unint64_t)CFArray;
      v6 = *(const __CFData **)(v1 + 128);
      v7 = *(const void **)(v1 + 616);
      if (v7)
        CFRelease(v7);
      *(_QWORD *)(v1 + 616) = 0;
      if (cf)
        CFRelease(cf);
      cf = 0;
      v8 = (Security::MacOSError *)SecCMSVerifySignedData_internal(v3, v6, CFArray, (SecTrustRef *)(v1 + 616), 0, 0, (const __CFDictionary **)&cf);
      if ((_DWORD)v8)
        Security::MacOSError::throwMe(v8);
      *(CFAbsoluteTime *)(v1 + 376) = SecTrustGetVerifyTime(*(SecTrustRef *)(v1 + 616));
      v24 = 0;
      v9 = (Security::MacOSError *)SecTrustEvaluateInternal(*(__SecTrust **)(v1 + 616), &v24);
      if ((_DWORD)v9)
        Security::MacOSError::throwMe(v9);
      __p[0] = 0;
      Value = CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)kSecCMSHashAgility);
      Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)__p, Value);
      if (__p[0])
      {
        CFDictionaryFrom = (const __CFDictionary *)Security::makeCFDictionaryFrom((CFDataRef)__p[0], v11);
        v12 = CFDictionaryGetValue(CFDictionaryFrom, CFSTR("cdhashes"));
        v14 = Security::CodeSigning::SecStaticCode::cdHashes((Security::CodeSigning::SecStaticCode *)v1, v13);
        if (!v12 || !CFEqual(v12, v14))
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0BLL);
        Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&CFDictionaryFrom);
      }
      v15 = SecTrustCopyCertificateChain(*(SecTrustRef *)(v1 + 616));
      v16 = *(const void **)(v1 + 624);
      if (v16)
        CFRelease(v16);
      *(_QWORD *)(v1 + 624) = v15;
      v18 = v24 == 4 || v24 == 1;
      *(_BYTE *)(v1 + 632) = v18;
      Security::CFRef<__CFData const*>::~CFRef((const void **)__p);
      Security::CFRef<__CFArray const*>::~CFRef((const void **)&v25);
      Security::CFRef<__CFDictionary const*>::~CFRef(&cf);
      Security::CodeSigning::SecStaticCode::verifySignature(void)::_DTFrameCODESIGN_EVAL_STATIC_SIGNATURE::~_DTFrameCODESIGN_EVAL_STATIC_SIGNATURE();
    }
    *(_BYTE *)(v1 + 184) = 0;
    if ((*(_BYTE *)(v1 + 211) & 0x40) != 0)
      *(_BYTE *)(v1 + 177) = 1;
    this = (UInt8 *)Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v1, 1);
    v19 = bswap32(*((_DWORD *)this + 6));
    if (v19 >= 0xB)
      v20 = 11;
    else
      v20 = v19;
    for (; (_DWORD)v20; --v20)
    {
      if (*(_QWORD *)(v1 + 392 + 8 * v20))
      {
        if (v20 == 3)
          v21 = -67023;
        else
          v21 = -67061;
        if (v20 == 1)
          v22 = 4294900266;
        else
          v22 = v21;
        this = (UInt8 *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1 + 96))(v1, v20, v22);
      }
    }
    *(_BYTE *)(v1 + 176) = 1;
    *(_DWORD *)(v1 + 180) = 0;
  }
  return this;
}

void sub_18A92AB2C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void *a13, void *__p, uint64_t a15, uint64_t a16, __int128 buf)
{
  uint64_t v17;
  void *v20;
  NSObject *v21;
  const char *v22;

  if (a2)
  {
    Security::CFRef<__SecPolicy *>::~CFRef((const void **)&__p);
    Security::CFRef<__CFDictionary const*>::~CFRef(&a13);
    Security::CodeSigning::SecStaticCode::verifySignature(void)::_DTFrameCODESIGN_EVAL_STATIC_SIGNATURE::~_DTFrameCODESIGN_EVAL_STATIC_SIGNATURE();
    v20 = __cxa_begin_catch(a1);
    if (a2 == 2)
    {
      *(_BYTE *)(v17 + 176) = 1;
      *(_DWORD *)(v17 + 180) = (*(uint64_t (**)(void *))(*(_QWORD *)v20 + 24))(v20);
      __cxa_rethrow();
    }
    v21 = secLogObjForScope("staticCode");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v17;
      _os_log_debug_impl(&dword_18A900000, v21, OS_LOG_TYPE_DEBUG, "%p validation threw non-common exception", (uint8_t *)&buf, 0xCu);
    }
    *(_BYTE *)(v17 + 176) = 1;
    Security::Syslog::notice((Security::Syslog *)"code signing internal problem: unknown exception thrown by validation", v22);
    *(_DWORD *)(v17 + 180) = -67048;
    __cxa_rethrow();
  }
  _Unwind_Resume(a1);
}

void sub_18A92ACD4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_18A92ACE0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_18A92ACEC(void *a1, int a2)
{
  if (!a2)
    JUMPOUT(0x18A92ACF4);
  __clang_call_terminate(a1);
}

CFDataRef Security::CodeSigning::EmbeddedSignatureBlob::blobData(Security::CodeSigning::EmbeddedSignatureBlob *this, const UInt8 *a2, const Security::BlobCore *a3)
{
  uint64_t v4;
  const UInt8 *v6;
  CFIndex v7;

  if (Security::CodeSigning::CodeDirectory::slotAttributes(this) >= 2)
  {
    v7 = bswap32(*((_DWORD *)a2 + 1));
    v6 = a2;
  }
  else
  {
    if (!a2)
      goto LABEL_11;
    v4 = bswap32(*((_DWORD *)a2 + 1));
    if (*(_DWORD *)a2 != 17555194 || v4 <= 7)
    {
      *__error() = 22;
LABEL_11:
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA1BLL);
    }
    v6 = a2 + 8;
    v7 = v4 - 8;
  }
  return CFDataCreate(0, v6, v7);
}

uint64_t Security::CodeSigning::CodeDirectory::slotAttributes(Security::CodeSigning::CodeDirectory *this)
{
  if ((int)this <= 4095)
  {
    if (this > 0xB)
      return 0;
    if (((1 << (char)this) & 0xFA4) != 0)
      return 2;
    if ((_DWORD)this)
      return 0;
    return 3;
  }
  if ((int)this < 0x10000)
  {
    if (((_DWORD)this - 4096) < 5)
      return 3;
    return 0;
  }
  return (_DWORD)this == 0x10000 || (_DWORD)this == 65537;
}

void Security::MachO::~MachO(void **this)
{
  *this = &off_1E1FC92E8;
  free(this[12]);
  JUMPOUT(0x18D76FAA0);
}

{
  *this = &off_1E1FC92E8;
  free(this[12]);
}

CFArrayRef SecTrustCopyCertificateChain(SecTrustRef trust)
{
  SecTrustRef v1;
  NSObject *v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v1 = trust;
  if (trust)
  {
    v5 = 0;
    v6 = &v5;
    v7 = 0x2000000000;
    v8 = 0;
    SecTrustEvaluateIfNecessary(trust);
    v2 = *((_QWORD *)v1 + 17);
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __SecTrustCopyCertificateChain_block_invoke;
    v4[3] = &unk_1E1FDA958;
    v4[4] = &v5;
    v4[5] = v1;
    dispatch_sync(v2, v4);
    v1 = (SecTrustRef)v6[3];
    _Block_object_dispose(&v5, 8);
  }
  return v1;
}

CFStringRef *Security::CFTempString::CFTempString<std::string>(CFStringRef *a1, char *cStr)
{
  const char *v2;
  CFStringRef v4;

  v2 = cStr;
  if (cStr[23] < 0 && (v2 = *(const char **)cStr) == 0)
  {
    v4 = 0;
  }
  else
  {
    v4 = CFStringCreateWithCString(0, v2, 0x8000100u);
    if (!v4)
    {
      v4 = CFStringCreateWithCString(0, v2, 0x600u);
      if (!v4)
        Security::CFError::throwMe(0);
    }
  }
  *a1 = v4;
  return a1;
}

CFNumberRef ___ZN8Security11CodeSigning13SecStaticCode18signingInformationEj_block_invoke(uint64_t a1, unsigned int a2)
{
  CFNumberRef v2;
  unint64_t valuePtr;

  valuePtr = a2;
  v2 = CFNumberCreate(0, kCFNumberLongLongType, &valuePtr);
  valuePtr = (unint64_t)v2;
  Security::CFRef<__CFNumber const*>::~CFRef((const void **)&valuePtr);
  return v2;
}

const void **Security::CFRef<__CFDictionary *>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t Security::CodeSigning::SecStaticCode::signature(Security::CodeSigning::SecStaticCode *this)
{
  uint64_t v1;
  const void *v3;

  v1 = *((_QWORD *)this + 46);
  if (!v1)
  {
    v1 = (*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 4) + 24))(*((_QWORD *)this + 4), 0x10000);
    v3 = (const void *)*((_QWORD *)this + 46);
    if (v3)
      CFRelease(v3);
    *((_QWORD *)this + 46) = v1;
    if (!v1)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ALL);
  }
  return v1;
}

CFTypeRef Security::CodeSigning::SecStaticCode::cdHashes(Security::CodeSigning::SecStaticCode *this, uint64_t a2)
{
  CFTypeRef result;
  __CFArray *CFMutableArray;
  Security::CodeSigning::SecStaticCode *v5;
  Security::CodeSigning::CodeDirectory *BytePtr;
  CFDataRef v7;
  Security::CodeSigning::SecStaticCode *v8;
  Security::CodeSigning::SecStaticCode *v9;
  BOOL v10;
  CFMutableArrayRef v11;
  CFTypeRef *v12;
  unint64_t v13;
  CFMutableArrayRef theArray;

  result = (CFTypeRef)*((_QWORD *)this + 66);
  if (!result)
  {
    CFMutableArray = Security::makeCFMutableArray(0, a2);
    theArray = CFMutableArray;
    v5 = (Security::CodeSigning::SecStaticCode *)*((_QWORD *)this + 13);
    if (v5 == (Security::CodeSigning::SecStaticCode *)((char *)this + 112))
    {
      v11 = CFMutableArray;
    }
    else
    {
      do
      {
        BytePtr = (Security::CodeSigning::CodeDirectory *)CFDataGetBytePtr(*((CFDataRef *)v5 + 5));
        v13 = 0xAAAAAAAAAAAAAAAALL;
        v7 = Security::CodeSigning::CodeDirectory::cdhash(BytePtr, 1);
        v13 = (unint64_t)v7;
        if (v7)
          CFArrayAppendValue(theArray, v7);
        Security::CFRef<__CFData const*>::~CFRef((const void **)&v13);
        v8 = (Security::CodeSigning::SecStaticCode *)*((_QWORD *)v5 + 1);
        if (v8)
        {
          do
          {
            v9 = v8;
            v8 = *(Security::CodeSigning::SecStaticCode **)v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            v9 = (Security::CodeSigning::SecStaticCode *)*((_QWORD *)v5 + 2);
            v10 = *(_QWORD *)v9 == (_QWORD)v5;
            v5 = v9;
          }
          while (!v10);
        }
        v5 = v9;
      }
      while (v9 != (Security::CodeSigning::SecStaticCode *)((char *)this + 112));
      v11 = theArray;
    }
    v12 = (CFTypeRef *)((char *)this + 528);
    Security::CFRef<__CFArray const*>::operator=(v12, v11);
    Security::CFRef<__CFArray *>::~CFRef((const void **)&theArray);
    return *v12;
  }
  return result;
}

void sub_18A92B100(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFArray *>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

const void **Security::CFRef<__SecPolicy *>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void *Security::BlobCore::readBlob(Security::BlobCore *this, off_t a2, int a3, size_t a4)
{
  int v7;
  size_t v8;
  int v10;
  void *v11;
  _QWORD *v13;
  size_t v14;
  uint64_t __buf;

  v7 = (int)this;
  __buf = 0;
  if (pread((int)this, &__buf, 8uLL, a2) != 8)
    return 0;
  v8 = bswap32(HIDWORD(__buf));
  if (bswap32(__buf) != a3 || v8 < 0xC)
    goto LABEL_6;
  if (a4 && v8 > a4)
  {
    v10 = 12;
    goto LABEL_11;
  }
  v13 = malloc_type_malloc(v8, 0x6DF4DA55uLL);
  v11 = v13;
  if (v13)
  {
    *v13 = __buf;
    v14 = bswap32(HIDWORD(__buf)) - 8;
    if (pread(v7, v13 + 1, v14, a2 + 8) != v14)
    {
      free(v11);
LABEL_6:
      v10 = 22;
LABEL_11:
      v11 = 0;
      *__error() = v10;
    }
  }
  return v11;
}

uint64_t Security::Universal::archOffset(Security::Universal *this)
{
  uint64_t v1;
  unint64_t v3;

  v1 = *((_QWORD *)this + 4);
  if (*((_QWORD *)this + 1))
  {
    v3 = Security::Universal::bestNativeArch(this);
    v1 += *((unsigned int *)Security::Universal::findArch(*((Security::Universal **)this + 1), (const Security::Architecture *)*((unsigned int *)this + 4), v3, SHIDWORD(v3))+ 2);
  }
  return v1;
}

const load_command *Security::MachOBase::findCodeSignature(Security::MachOBase *this)
{
  const load_command *result;
  unsigned int cmdsize;
  unsigned int v4;

  result = Security::MachOBase::findCommand(this, 29);
  if (result)
  {
    cmdsize = result->cmdsize;
    v4 = bswap32(cmdsize);
    if (*((_BYTE *)this + 33))
      cmdsize = v4;
    if (cmdsize <= 0xF)
      Security::UnixError::throwMe((Security::UnixError *)8);
  }
  return result;
}

CFDataRef Security::cfMapFile(Security *this, size_t a2)
{
  int v3;
  off_t v4;
  UInt8 *v5;
  UInt8 *v6;
  CFDataRef v7;
  const __CFAllocator *v9;
  CFAllocatorContext context;
  CFDataRef v11;
  UInt8 bytes[8];

  v3 = (int)this;
  v4 = lseek((int)this, 0, 1);
  v5 = (UInt8 *)mmap(0, a2, 1, 2, v3, v4);
  if (v5 == (UInt8 *)-1)
    return 0;
  v6 = v5;
  *(_QWORD *)bytes = a2;
  v11 = CFDataCreate(0, bytes, 8);
  context.version = 0;
  *(_OWORD *)&context.retain = unk_1E1FDC3C8;
  *(_OWORD *)&context.copyDescription = xmmword_1E1FDC3D8;
  *(_OWORD *)&context.reallocate = unk_1E1FDC3E8;
  context.preferredSize = (CFAllocatorPreferredSizeCallBack)Security::mmapPreferredSize;
  context.info = v11;
  v9 = CFAllocatorCreate(0, &context);
  v7 = CFDataCreateWithBytesNoCopy(0, v6, *(CFIndex *)bytes, v9);
  if (!v7)
    munmap(v6, a2);
  Security::CFRef<__CFAllocator const*>::~CFRef((const void **)&v9);
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v11);
  return v7;
}

void sub_18A92B400(_Unwind_Exception *a1)
{
  uint64_t v1;

  Security::CFRef<__CFData const*>::~CFRef((const void **)(v1 - 48));
  _Unwind_Resume(a1);
}

const void **Security::CFRef<__CFDate const*>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **Security::CFRef<__CFAllocator const*>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **Security::CFRef<__CFArray *>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

CFMutableArrayRef Security::makeCFMutableArray(Security *this, uint64_t a2, ...)
{
  return CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
}

CFArrayRef Security::makeCFArray(Security *this, const void *a2, ...)
{
  const void *v3[2];
  va_list va;

  va_start(va, a2);
  va_copy((va_list)&v3[1], va);
  v3[0] = a2;
  return CFArrayCreate(0, v3, 1, MEMORY[0x1E0C9B378]);
}

uint64_t Security::CodeSigning::MachORep::signingBase(Security::CodeSigning::MachORep *this)
{
  Security::Universal *v1;

  v1 = (Security::Universal *)(*(uint64_t (**)(Security::CodeSigning::MachORep *))(*(_QWORD *)this + 80))(this);
  return Security::Universal::archOffset(v1);
}

const UInt8 *Security::CodeSigning::SecStaticCode::teamID(Security::CodeSigning::SecStaticCode *this)
{
  const UInt8 *v1;
  unsigned int v2;

  v1 = Security::CodeSigning::SecStaticCode::codeDirectory(this, 1);
  if (bswap32(*((_DWORD *)v1 + 2)) >> 9 >= 0x101 && (v2 = *((_DWORD *)v1 + 12)) != 0)
    return &v1[bswap32(v2)];
  else
    return 0;
}

CFDataRef Security::CodeSigning::SecStaticCode::cdHash(CFDataRef *this)
{
  Security::CodeSigning::CodeDirectory *v2;
  const __CFData *v3;
  CFDataRef v4;

  if (!this[65])
  {
    v2 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)this, 0);
    if (v2)
    {
      v3 = Security::CodeSigning::CodeDirectory::cdhash(v2, 1);
      v4 = this[65];
      if (v4)
        CFRelease(v4);
      this[65] = v3;
      CFDataGetBytePtr(v3);
      CFDataGetLength(this[65]);
    }
  }
  return this[65];
}

uint64_t Security::CodeSigning::SecStaticCode::infoDictionary(Security::CodeSigning::SecStaticCode *this)
{
  uint64_t result;
  const __CFData *Dictionary;
  const void *v4;
  NSObject *v5;
  _BOOL4 v6;
  int v7;
  Security::CodeSigning::SecStaticCode *v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  result = *((_QWORD *)this + 61);
  if (!result)
  {
    Dictionary = Security::CodeSigning::SecStaticCode::getDictionary((UInt8 *)this, 1, 1);
    v4 = (const void *)*((_QWORD *)this + 61);
    if (v4)
      CFRelease(v4);
    *((_QWORD *)this + 61) = Dictionary;
    v5 = secLogObjForScope("staticCode");
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
    result = *((_QWORD *)this + 61);
    if (v6)
    {
      v7 = 134218240;
      v8 = this;
      v9 = 2048;
      v10 = result;
      _os_log_debug_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEBUG, "%p loaded InfoDict %p", (uint8_t *)&v7, 0x16u);
      return *((_QWORD *)this + 61);
    }
  }
  return result;
}

void Security::CodeSigning::BundleDiskRep::format(Security::CodeSigning::BundleDiskRep *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 103) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 10), *((_QWORD *)this + 11));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *((_OWORD *)this + 5);
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)this + 12);
  }
}

uint64_t Security::CodeSigning::BundleDiskRep::copyDiskRepInformation(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 160))(*((_QWORD *)this + 13));
}

uint64_t Security::CodeSigning::BundleDiskRep::signingBase(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 88))(*((_QWORD *)this + 13));
}

void Security::MacOSError::throwMe(Security::MacOSError *this)
{
  int v1;
  Security::MacOSError *exception;

  v1 = (int)this;
  exception = (Security::MacOSError *)__cxa_allocate_exception(0x98uLL);
  Security::MacOSError::MacOSError(exception, v1);
}

void sub_18A92B754(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

_QWORD *SecPolicyCreateAppleSoftwareSigning()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, CFSTR("IssuerCommonName"), CFSTR("Apple Code Signing Certification Authority")),
        add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.22")),
        add_element(v1, CFSTR("ExtendedKeyUsage"), CFSTR("1.3.6.1.5.5.7.3.3")),
        add_element(v1, CFSTR("Revocation"), CFSTR("AnyRevocationMethod")),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.64"), CFSTR("SoftwareSigning"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

uint64_t Security::CFClass::finalizeType(Security::CFClass *this, const void *a2)
{
  char *v2;
  pthread_mutex_t *v3;
  Security::UnixError *v4;
  unsigned __int8 *v5;
  _QWORD v7[2];

  if (this)
    v2 = (char *)this + 24;
  else
    v2 = 0;
  v3 = (pthread_mutex_t *)(*(uint64_t (**)(char *, const void *))(*(_QWORD *)v2 + 64))(v2, a2);
  if (!v3)
    return (*(uint64_t (**)(char *))(*(_QWORD *)v2 + 56))(v2);
  v7[0] = v3;
  v7[1] = 0xAAAAAAAAAAAAAA01;
  v4 = (Security::UnixError *)pthread_mutex_lock(v3);
  if ((_DWORD)v4)
    Security::UnixError::throwMe(v4);
  v5 = (unsigned __int8 *)(v2 - 8);
  do
    __ldaxr(v5);
  while (__stlxr(1u, v5));
  (*(void (**)(char *))(*(_QWORD *)v2 + 56))(v2);
  return Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v7);
}

void sub_18A92B90C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&a9);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18A92B8F4);
}

uint64_t Security::CFClass::refCountForType(Security::CFClass *this, Security::CFClass *a2, const void *a3)
{
  char *v5;
  pthread_mutex_t *v6;
  BOOL *v7;
  Security::UnixError *v8;
  BOOL *v9;
  uint64_t v10;
  _QWORD v12[2];
  char v13;

  v13 = 0;
  if (a2)
    v5 = (char *)a2 + 24;
  else
    v5 = 0;
  v6 = (pthread_mutex_t *)(*(uint64_t (**)(char *))(*(_QWORD *)v5 + 64))(v5);
  if (v6)
  {
    v12[0] = v6;
    v12[1] = 0xAAAAAAAAAAAAAA01;
    v8 = (Security::UnixError *)pthread_mutex_lock(v6);
    if ((_DWORD)v8)
      Security::UnixError::throwMe(v8);
    v10 = Security::CFClass::cleanupObject(this, a2, &v13, v9);
    Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v12);
  }
  else
  {
    v10 = Security::CFClass::cleanupObject(this, a2, &v13, v7);
  }
  if (v13)
    (*(void (**)(char *))(*(_QWORD *)v5 + 8))(v5);
  return v10;
}

void sub_18A92B9F8(void *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18A92B9D8);
}

uint64_t Security::SecCFObject::getMutexForObject(Security::SecCFObject *this)
{
  return 0;
}

uint64_t Security::CFClass::cleanupObject(Security::CFClass *this, Security::CFClass *a2, _BYTE *a3, BOOL *a4)
{
  os_unfair_lock_s *v7;
  uint32_t os_unfair_lock_opaque;
  uint64_t v9;
  const void *v10;

  *a3 = 0;
  if (a2)
    v7 = (os_unfair_lock_s *)((char *)a2 + 24);
  else
    v7 = 0;
  os_unfair_lock_lock(v7 + 3);
  os_unfair_lock_opaque = v7[2]._os_unfair_lock_opaque;
  if (this == (Security::CFClass *)-1)
  {
    if (!os_unfair_lock_opaque)
    {
      os_unfair_lock_unlock(v7 + 3);
      goto LABEL_14;
    }
LABEL_10:
    v9 = os_unfair_lock_opaque + this;
    v7[2]._os_unfair_lock_opaque = v9;
    os_unfair_lock_unlock(v7 + 3);
    if (!this)
      return v9;
    if ((_DWORD)v9)
      return 0;
LABEL_14:
    if ((*(unsigned int (**)(os_unfair_lock_s *))(*(_QWORD *)&v7->_os_unfair_lock_opaque + 72))(v7))
    {
      Security::CFClass::finalizeType(a2, v10);
      v9 = 0;
      *a3 = 1;
      return v9;
    }
    return 0;
  }
  if (os_unfair_lock_opaque != -1)
    goto LABEL_10;
  os_unfair_lock_unlock(v7 + 3);
  if (this)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

void Security::SecCFObject::operator delete(char *a1)
{
  char *v1;
  const __CFAllocator *v2;

  v1 = a1 - 24;
  v2 = CFGetAllocator(a1 - 24);
  CFAllocatorDeallocate(v2, v1);
}

uint64_t Security::SecCFObject::mayDelete(Security::SecCFObject *this)
{
  return 1;
}

BOOL SecPolicyCheckCertSSLHostname(uint64_t a1, const __CFString *cf)
{
  CFTypeID v4;
  const __CFArray *v5;
  const __CFArray *v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  BOOL v10;
  const __CFString *ValueAtIndex;
  _BOOL8 v12;
  CFTypeRef v13;
  const __CFArray *v14;
  const __CFArray *v15;
  CFIndex v16;
  CFIndex v17;
  uint64_t v18;
  const void *v19;
  CFTypeRef v21;

  if (!cf)
    return 0;
  v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID())
    return 0;
  v5 = SecCertificateCopyDNSNamesFromSAN(a1);
  if (v5)
  {
    v6 = v5;
    Count = CFArrayGetCount(v5);
    if (Count < 1)
    {
LABEL_8:
      CFRelease(v6);
    }
    else
    {
      v8 = Count;
      v9 = 0;
      v10 = 1;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, v9);
        if (SecDNSMatch(cf, ValueAtIndex))
          break;
        v10 = ++v9 < v8;
        if (v8 == v9)
          goto LABEL_8;
      }
      CFRelease(v6);
      if (v10)
        return 1;
    }
  }
  v21 = 0;
  v12 = 0;
  if (convertIPAddress(cf, &v21))
  {
    v13 = v21;
    if (v21)
    {
      v14 = SecCertificateCopyIPAddressDatas(a1);
      if (v14)
      {
        v15 = v14;
        v16 = CFArrayGetCount(v14);
        if (v16 < 1)
        {
          v12 = 0;
        }
        else
        {
          v17 = v16;
          v18 = 1;
          do
          {
            v19 = CFArrayGetValueAtIndex(v15, v18 - 1);
            if (v19)
              v12 = CFEqual(v13, v19) != 0;
            else
              v12 = 0;
            if (v18 >= v17)
              break;
            ++v18;
          }
          while (!v12);
        }
        CFRelease(v15);
      }
      else
      {
        v12 = 0;
      }
      CFRelease(v13);
    }
  }
  return v12;
}

uint64_t SecDNSMatch(const __CFString *a1, const __CFString *a2)
{
  CFIndex Length;
  CFIndex v5;
  const __CFString *v6;
  const __CFArray *ArrayBySeparatingStrings;
  uint64_t v8;
  CFArrayRef v9;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  unint64_t v14;
  CFIndex v15;
  CFIndex v16;
  const __CFString *ValueAtIndex;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  CFRange v21;
  CFIndex v23;
  CFRange v24;

  Length = CFStringGetLength(a1);
  v5 = Length - 1;
  if (Length < 1)
    return 0;
  if (CFStringGetCharacterAtIndex(a1, v5) != 46)
  {
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, a1, CFSTR("."));
    if (ArrayBySeparatingStrings)
      goto LABEL_8;
    return 0;
  }
  v24.location = 0;
  v24.length = v5;
  v6 = CFStringCreateWithSubstring(0, a1, v24);
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, v6, CFSTR("."));
  if (v6)
    CFRelease(v6);
  if (!ArrayBySeparatingStrings)
    return 0;
LABEL_8:
  v9 = CFStringCreateArrayBySeparatingStrings(0, a2, CFSTR("."));
  if (v9)
  {
    v10 = v9;
    Count = CFArrayGetCount(ArrayBySeparatingStrings);
    v12 = CFArrayGetCount(v10);
    v8 = Count == v12;
    if (Count == v12)
    {
      v13 = CFArrayGetCount(ArrayBySeparatingStrings);
      if (v13 < 1)
      {
LABEL_19:
        v8 = 1;
      }
      else
      {
        v14 = v13;
        v23 = v13 - 1;
        v15 = v13;
        while (1)
        {
          v16 = v15 - 1;
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v15 - 1);
          if (!ValueAtIndex
            || (v18 = ValueAtIndex, (v19 = (const __CFString *)CFArrayGetValueAtIndex(v10, v15 - 1)) == 0))
          {
LABEL_20:
            v8 = 0;
            goto LABEL_25;
          }
          v20 = v19;
          if (CFEqual(v19, CFSTR("*")))
            break;
          v21 = CFStringFind(v20, CFSTR("*"), 0);
          v8 = 0;
          if (v21.location != -1 || v21.length)
            goto LABEL_25;
          if (CFStringCompare(v18, v20, 1uLL))
            goto LABEL_20;
          --v15;
          if ((unint64_t)(v16 + 1) <= 1)
            goto LABEL_19;
        }
        v8 = 0;
        if (v15 == 1 && v14 >= 3 && v23 != 1)
          v8 = SecDNSIsTLD(a2) ^ 1;
      }
    }
LABEL_25:
    CFRelease(ArrayBySeparatingStrings);
  }
  else
  {
    v8 = 0;
    v10 = ArrayBySeparatingStrings;
  }
  CFRelease(v10);
  return v8;
}

CFMutableArrayRef SecCertificateCopyDNSNamesFromSAN(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  uint64_t v3;
  CFIndex Count;
  uint64_t *v5;
  const void *v6;
  _QWORD context[5];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  CFMutableArrayRef v12;
  CFRange v13;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = *(_QWORD *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames(v3 + 24, (uint64_t)Mutable, (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendDNSNamesFromGeneralNames))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  else
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2000000000;
    v12 = (CFMutableArrayRef)0xAAAAAAAAAAAAAAAALL;
    v12 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 0x40000000;
    context[2] = __filterIPAddresses_block_invoke;
    context[3] = &unk_1E1FD5598;
    context[4] = &v9;
    v13.length = CFArrayGetCount(Mutable);
    v13.location = 0;
    CFArrayApplyFunction(Mutable, v13, (CFArrayApplierFunction)apply_block_1_7636, context);
    if (Mutable)
      CFRelease(Mutable);
    Count = CFArrayGetCount((CFArrayRef)v10[3]);
    v5 = v10;
    if (!Count)
    {
      v6 = (const void *)v10[3];
      if (v6)
      {
        v10[3] = 0;
        CFRelease(v6);
        v5 = v10;
      }
    }
    Mutable = (CFMutableArrayRef)v5[3];
    _Block_object_dispose(&v9, 8);
  }
  return Mutable;
}

uint64_t SecDNSIsTLD(CFStringRef theString)
{
  CFIndex Length;
  uint64_t result;
  const void *v4;
  uint64_t v5;
  CFRange v6;

  if (SecDNSIsTLD_onceToken != -1)
    dispatch_once(&SecDNSIsTLD_onceToken, &__block_literal_global_11142);
  if (!SecDNSIsTLD_CFNIsDomainTopLevelFunctionPtr)
    return 0;
  Length = CFStringGetLength(theString);
  if (Length < 3)
    return 1;
  v6.length = Length - 2;
  v6.location = 2;
  result = (uint64_t)CFStringCreateWithSubstring(0, theString, v6);
  if (result)
  {
    v4 = (const void *)result;
    v5 = SecDNSIsTLD_CFNIsDomainTopLevelFunctionPtr();
    CFRelease(v4);
    return v5;
  }
  return result;
}

BOOL __sec_protocol_options_set_verify_block_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  NSObject *v5;
  void *v6;
  NSObject *v7;

  if (a2)
  {
    v4 = *(const void **)(a2 + 120);
    if (v4)
      _Block_release(v4);
    v5 = *(NSObject **)(a2 + 128);
    if (v5)
      dispatch_release(v5);
    v6 = _Block_copy(*(const void **)(a1 + 32));
    v7 = *(NSObject **)(a1 + 40);
    *(_QWORD *)(a2 + 120) = v6;
    *(_QWORD *)(a2 + 128) = v7;
    dispatch_retain(v7);
  }
  return a2 != 0;
}

BOOL __sec_protocol_options_set_challenge_block_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  NSObject *v5;
  void *v6;
  NSObject *v7;

  if (a2)
  {
    v4 = *(const void **)(a2 + 104);
    if (v4)
      _Block_release(v4);
    v5 = *(NSObject **)(a2 + 112);
    if (v5)
      dispatch_release(v5);
    v6 = _Block_copy(*(const void **)(a1 + 32));
    v7 = *(NSObject **)(a1 + 40);
    *(_QWORD *)(a2 + 104) = v6;
    *(_QWORD *)(a2 + 112) = v7;
    dispatch_retain(v7);
  }
  return a2 != 0;
}

void serializePolicy(uint64_t a1, __CFArray *a2)
{
  CFTypeID TypeID;
  __CFDictionary *Mutable;
  const void *v6;

  if (a1)
  {
    TypeID = SecPolicyGetTypeID();
    if (TypeID == CFGetTypeID((CFTypeRef)a1))
    {
      Mutable = CFDictionaryCreateMutable(0, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionaryAddValue(Mutable, CFSTR("SecPolicyOid"), *(const void **)(a1 + 16));
      CFDictionaryAddValue(Mutable, CFSTR("policyOptions"), *(const void **)(a1 + 32));
      v6 = *(const void **)(a1 + 24);
      if (v6)
        CFDictionaryAddValue(Mutable, CFSTR("SecPolicyPolicyName"), v6);
      if (Mutable)
      {
        CFArrayAppendValue(a2, Mutable);
        CFRelease(Mutable);
      }
    }
  }
}

BOOL sec_protocol_metadata_get_early_data_accepted(sec_protocol_metadata_t metadata)
{
  if (metadata)
    LOBYTE(metadata) = sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)&__block_literal_global_90_2830);
  return (char)metadata;
}

__CFData *SecTrustSerialize(uint64_t a1, __CFString **a2)
{
  CFMutableDictionaryRef Mutable;
  NSObject *v5;
  const __CFString *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __CFData *DERData;
  _QWORD v15[6];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;

  if (!a1)
  {
    SecError(-50, a2, CFSTR("null trust input"));
    return 0;
  }
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v17[3] = (uint64_t)Mutable;
  v5 = *(NSObject **)(a1 + 136);
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 0x40000000;
  v15[2] = __SecTrustCopyPlist_block_invoke;
  v15[3] = &unk_1E1FDB4C8;
  v15[4] = &v16;
  v15[5] = a1;
  dispatch_sync(v5, v15);
  v6 = (const __CFString *)v17[3];
  _Block_object_dispose(&v16, 8);
  if (!v6)
  {
    SecError(-26275, a2, CFSTR("unable to create trust plist"));
    return 0;
  }
  DERData = CFPropertyListCreateDERData(v7, v6, (CFTypeRef *)a2, v8, v9, v10, v11, v12);
  CFRelease(v6);
  return DERData;
}

__CFData *CFPropertyListCreateDERData(uint64_t a1, const __CFString *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v10;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v10 = der_sizeof_plist(a2, a3, (uint64_t)a3, a4, a5, a6, a7, a8);
  Mutable = CFDataCreateMutable(0, v10);
  CFDataSetLength(Mutable, v10);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (!der_encode_plist_repair(a2, a3, 0, MutableBytePtr, (unint64_t)&MutableBytePtr[v10], v13, v14, v15)
    && Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

__CFDictionary *Security::makeCFMutableDictionary(Security *this, void *key, const void *a3, ...)
{
  __CFDictionary *CFMutableDictionary;

  CFMutableDictionary = Security::makeCFMutableDictionary(this);
  CFDictionaryAddValue(CFMutableDictionary, key, a3);
  return CFMutableDictionary;
}

CFMutableDictionaryRef Security::makeCFMutableDictionary(Security *this)
{
  CFMutableDictionaryRef result;

  result = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!result)
    Security::CFError::throwMe(0);
  return result;
}

__CFDictionary *SecPolicyCreateLockdownPairing()
{
  __CFDictionary *result;
  __CFDictionary *v1;
  const void *v2;
  _QWORD *v3;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (result)
  {
    v1 = result;
    v2 = (const void *)*MEMORY[0x1E0C9AE50];
    CFDictionaryAddValue(result, CFSTR("CriticalExtensions"), (const void *)*MEMORY[0x1E0C9AE50]);
    CFDictionaryAddValue(v1, CFSTR("UnparseableExtension"), v2);
    CFDictionaryAddValue(v1, CFSTR("DuplicateExtension"), v2);
    CFDictionaryAddValue(v1, CFSTR("IdLinkage"), v2);
    CFDictionaryAddValue(v1, CFSTR("BasicConstraints"), v2);
    CFDictionaryAddValue(v1, CFSTR("WeakKeySize"), v2);
    CFDictionaryAddValue(v1, CFSTR("RevocationDbIgnored"), v2);
    v3 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.57"), CFSTR("LockdownPairing"), v1);
    CFRelease(v1);
    return (__CFDictionary *)v3;
  }
  return result;
}

SecPolicyRef SecPolicyCreateWithProperties(CFTypeRef policyIdentifier, CFDictionaryRef properties)
{
  __SecPolicy *EAP;
  CFTypeID TypeID;
  __CFString *v5;
  const void *v6;
  _BOOL4 v7;
  const void *v8;
  const __CFString *v9;
  __CFString *v10;
  CFTypeID v11;
  char v12;
  __SecPolicy *SMIME;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  CFTypeID v19;
  CFArrayRef Copy;
  CFTypeID v21;
  CFArrayRef v22;
  NSObject *v23;
  const __CFString *v24;
  const __CFString *v25;
  _UNKNOWN **v26;
  _UNKNOWN **v27;
  __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  const __CFString *v31;
  const __CFString *v32;
  const __CFString *v33;
  __CFString *v34;
  const void *v35;
  int v36;
  const __CFString *v37;
  const __CFString *v38;
  __CFString *v39;
  __CFString *v40;
  const __CFString *cf;
  void *values;
  _BYTE value[12];
  __int16 v44;
  const __CFString *v45;
  uint64_t v46;

  EAP = (__SecPolicy *)policyIdentifier;
  v46 = *MEMORY[0x1E0C80C00];
  values = 0;
  if (!policyIdentifier)
    return EAP;
  TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(EAP))
    return 0;
  if (!properties)
  {
    v10 = 0;
    v9 = 0;
    cf = 0;
    v8 = 0;
    v7 = 0;
    v6 = 0;
    v5 = 0;
LABEL_12:
    v12 = 1;
    goto LABEL_13;
  }
  v5 = (__CFString *)CFDictionaryGetValue(properties, CFSTR("SecPolicyName"));
  values = v5;
  v6 = CFDictionaryGetValue(properties, CFSTR("SecPolicyTeamIdentifier"));
  *(_QWORD *)value = 0xAAAAAAAAAAAAAAAALL;
  v7 = 0;
  if (CFDictionaryGetValueIfPresent(properties, CFSTR("SecPolicyClient"), (const void **)value) && *(_QWORD *)value)
    v7 = CFEqual((CFTypeRef)*MEMORY[0x1E0C9AE50], *(CFTypeRef *)value) != 0;
  v8 = CFDictionaryGetValue(properties, CFSTR("SecPolicyContext"));
  cf = (const __CFString *)CFDictionaryGetValue(properties, CFSTR("SecPolicyPolicyName"));
  v9 = (const __CFString *)CFDictionaryGetValue(properties, CFSTR("SecPolicyIntermediateMarkerOid"));
  v10 = (__CFString *)CFDictionaryGetValue(properties, CFSTR("SecPolicyLeafMarkerOid"));
  properties = (CFDictionaryRef)CFDictionaryGetValue(properties, CFSTR("SecPolicyRootDigest"));
  if (!v5)
    goto LABEL_12;
  v11 = CFGetTypeID(v5);
  if (v11 != CFStringGetTypeID() && !CFEqual(EAP, CFSTR("1.2.840.113635.100.1.9")))
  {
    v15 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)value = 138412546;
      *(_QWORD *)&value[4] = EAP;
      v44 = 2112;
      v45 = CFSTR("SecPolicyName");
      v16 = "policy \"%@\" requires a string value for the %@ key";
      v17 = v15;
      v18 = 22;
LABEL_27:
      _os_log_impl(&dword_18A900000, v17, OS_LOG_TYPE_DEFAULT, v16, value, v18);
      return 0;
    }
    return 0;
  }
  v12 = 0;
LABEL_13:
  if (!CFEqual(EAP, CFSTR("1.2.840.113635.100.1.3")))
  {
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.8")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateSMIME(31, v5);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.9")))
    {
      if ((v12 & 1) != 0)
      {
LABEL_24:
        SMIME = SecPolicyCreateEAP(!v7, 0);
        goto LABEL_17;
      }
      v19 = CFGetTypeID(v5);
      if (v19 == CFStringGetTypeID())
      {
        Copy = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
      }
      else
      {
        v21 = CFGetTypeID(v5);
        if (v21 != CFArrayGetTypeID())
          goto LABEL_24;
        Copy = CFArrayCreateCopy(0, (CFArrayRef)v5);
      }
      v22 = Copy;
      EAP = SecPolicyCreateEAP(!v7, Copy);
      if (v22)
        CFRelease(v22);
      goto LABEL_18;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.11")))
    {
      SMIME = SecPolicyCreateIPSec(!v7, v5);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.19")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateMacAppStoreReceipt();
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.21")))
    {
      SMIME = SecPolicyCreateRevocation(3uLL);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.22")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreatePassbookCardSigner(v5, v6);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.42")))
    {
      if ((v12 & 1) != 0)
      {
        v23 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          return 0;
        *(_DWORD *)value = 138412290;
        *(_QWORD *)&value[4] = EAP;
        v16 = "policy \"%@\" requires kSecPolicyName input";
        goto LABEL_90;
      }
      v24 = CFSTR("1.2.840.113635.100.1.42");
      v25 = CFSTR("AST2");
      v26 = &oidAppleCertExtAST2DiagnosticsServerAuthProd;
      v27 = &oidAppleCertExtAST2DiagnosticsServerAuthProdQA;
      goto LABEL_67;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.43")))
    {
      if ((v12 & 1) != 0)
      {
        v23 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          return 0;
        *(_DWORD *)value = 138412290;
        *(_QWORD *)&value[4] = EAP;
        v16 = "policy \"%@\" requires kSecPolicyName input";
        goto LABEL_90;
      }
      v24 = CFSTR("1.2.840.113635.100.1.43");
      v25 = CFSTR("Escrow");
      v26 = &oidAppleCertExtEscrowProxyServerAuthProd;
      v27 = &oidAppleCertExtEscrowProxyServerAuthProdQA;
LABEL_67:
      v28 = v5;
LABEL_68:
      SMIME = (__SecPolicy *)SecPolicyCreateAppleServerAuthCommon(v28, v24, v25, (uint64_t)v26, (uint64_t)v27);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.44")))
    {
      if ((v12 & 1) == 0)
      {
        v24 = CFSTR("1.2.840.113635.100.1.44");
        v25 = CFSTR("FMiP");
        v26 = &oidAppleCertExtFMiPServerAuthProd;
        v27 = &oidAppleCertExtFMiPServerAuthProdQA;
        goto LABEL_67;
      }
      v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        return 0;
      *(_DWORD *)value = 138412290;
      *(_QWORD *)&value[4] = EAP;
      v16 = "policy \"%@\" requires kSecPolicyName input";
LABEL_90:
      v17 = v23;
      v18 = 12;
      goto LABEL_27;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.45")))
    {
      if ((v12 & 1) == 0)
      {
        v24 = CFSTR("1.2.840.113635.100.1.45");
        v25 = CFSTR("MMCS");
        v26 = &oidAppleCertExtAppleServerAuthenticationMMCSProd;
        v27 = &oidAppleCertExtAppleServerAuthenticationMMCSProdQA;
        goto LABEL_67;
      }
      v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        return 0;
      *(_DWORD *)value = 138412290;
      *(_QWORD *)&value[4] = EAP;
      v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.46")))
    {
      if ((v12 & 1) == 0)
      {
        v24 = CFSTR("1.2.840.113635.100.1.46");
        v25 = CFSTR("GS");
        v26 = &oidAppleCertExtAppleServerAuthenticationGS;
        v28 = v5;
        v27 = 0;
        goto LABEL_68;
      }
      v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        return 0;
      *(_DWORD *)value = 138412290;
      *(_QWORD *)&value[4] = EAP;
      v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.47")))
    {
      if ((v12 & 1) == 0)
      {
        v24 = CFSTR("1.2.840.113635.100.1.47");
        v25 = CFSTR("PPQ");
        v26 = &oidAppleCertExtAppleServerAuthenticationPPQProd;
        v27 = &oidAppleCertExtAppleServerAuthenticationPPQProdQA;
        goto LABEL_67;
      }
      v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        return 0;
      *(_DWORD *)value = 138412290;
      *(_QWORD *)&value[4] = EAP;
      v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.62")))
    {
      if (!cf)
      {
        v23 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          return 0;
        *(_DWORD *)value = 138412290;
        *(_QWORD *)&value[4] = EAP;
        v16 = "policy \"%@\" requires kSecPolicyPolicyName input";
        goto LABEL_90;
      }
      v29 = cf;
      v30 = v9;
      v31 = v10;
LABEL_77:
      SMIME = (__SecPolicy *)SecPolicyCreateApplePinned(v29, v30, v31);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.63")))
    {
      if (cf)
      {
        SMIME = (__SecPolicy *)SecPolicyCreateAppleSSLPinned(cf, v5, v9, v10);
        goto LABEL_17;
      }
      v23 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)value = 138412290;
        *(_QWORD *)&value[4] = EAP;
        v16 = "policy \"%@\" requires kSecPolicyPolicyName input";
        goto LABEL_90;
      }
      return 0;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.68")))
    {
      if ((v12 & 1) == 0)
      {
        v24 = CFSTR("1.2.840.113635.100.1.68");
        v25 = CFSTR("IDS");
        v26 = &oidAppleCertExtAppleServerAuthenticationIDSProd;
        v27 = &oidAppleCertExtAppleServerAuthenticationIDSProdQA;
        goto LABEL_67;
      }
      v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        return 0;
      *(_DWORD *)value = 138412290;
      *(_QWORD *)&value[4] = EAP;
      v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.69")))
    {
      if ((v12 & 1) == 0)
      {
        v24 = CFSTR("1.2.840.113635.100.1.69");
        v25 = CFSTR("APN");
        v26 = &oidAppleCertExtAppleServerAuthenticationAPNProd;
        v27 = &oidAppleCertExtAppleServerAuthenticationAPNProdQA;
        goto LABEL_67;
      }
      v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        return 0;
      *(_DWORD *)value = 138412290;
      *(_QWORD *)&value[4] = EAP;
      v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.72")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleUniqueDeviceCertificate(properties);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.77")))
    {
      if ((v12 & 1) == 0)
      {
        v24 = CFSTR("1.2.840.113635.100.1.77");
        v25 = CFSTR("iCloudSetup");
        v26 = &oidAppleCertExtAppleServerAuthenticationiCloudSetupProd;
        v27 = &oidAppleCertExtAppleServerAuthenticationiCloudSetupProdQA;
        goto LABEL_67;
      }
      v23 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        return 0;
      *(_DWORD *)value = 138412290;
      *(_QWORD *)&value[4] = EAP;
      v16 = "policy \"%@\" requires kSecPolicyName input";
      goto LABEL_90;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.84")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleBasicAttestationSystem(properties);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.85")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleBasicAttestationUser(properties);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.92")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleComponentCertificate(properties);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.102")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAggregateMetricTransparency(!v7);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.106")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAggregateMetricEncryption(!v7);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.107")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateApplePayModelSigning(1);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.108")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateMDLTerminalAuth(1, 1);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.112")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreatePPMAggregatorConfigSigning(!v7);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.117")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateiAPAuthV4(1);
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.118")))
    {
      if ((v12 & 1) != 0)
      {
        v23 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          return 0;
        *(_DWORD *)value = 138412290;
        *(_QWORD *)&value[4] = EAP;
        v16 = "policy \"%@\" requires kSecPolicyName input";
        goto LABEL_90;
      }
      v32 = CFSTR("1.2.840.113635.100.1.118");
      v33 = CFSTR("ParakeetService");
      v34 = v5;
      v35 = v8;
      goto LABEL_129;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.2")))
    {
      SMIME = SecPolicyCreateBasicX509();
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.10")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateAppleSWUpdateSigning();
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.16")))
    {
      SMIME = SecPolicyCreateCodeSigning();
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.17")))
    {
      SMIME = (__SecPolicy *)SecPolicyCreateApplePackageSigning();
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.18")))
    {
LABEL_137:
      SMIME = (__SecPolicy *)SecPolicyCreateAppleIDAuthorityPolicy();
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.20")))
    {
      SMIME = SecPolicyCreateAppleTimeStamping();
      goto LABEL_17;
    }
    if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.23")))
    {
      v36 = 0;
    }
    else
    {
      if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.24")))
      {
        SMIME = (__SecPolicy *)SecPolicyCreateEscrowServiceSigner();
        goto LABEL_17;
      }
      if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.25")) || CFEqual(EAP, CFSTR("1.2.840.113635.100.1.26")))
      {
        SMIME = (__SecPolicy *)SecPolicyCreateConfigurationProfileSigner();
        goto LABEL_17;
      }
      if (!CFEqual(EAP, CFSTR("1.2.840.113635.100.1.27")))
      {
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.30")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleIDValidationRecordSigningPolicy();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.30")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleIDValidationShortcutSigningPolicy();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.31")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleSMPEncryption();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.32")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateTestAppleSMPEncryption();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.33")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleSSLService(v5);
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.34")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreatePCSEscrowServiceSigner();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.35")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateApplePPQSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.36")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateTestApplePPQSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.39")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateApplePayIssuerEncryption();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.40")))
        {
          SMIME = SecPolicyCreateOSXProvisioningProfileSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.41")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleATVVPNProfileSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.48")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateAppleHomeKitServerAuth(v5);
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.49")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneActivation();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.50")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneDeviceCertificate();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.51")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateFactoryDeviceCertificate();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.52")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiAP();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.53")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiTunesStoreURLBag();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.54")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneApplicationSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.55")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneProfileApplicationSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.56")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateiPhoneProvisioningProfileSigning();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.57")))
        {
          SMIME = SecPolicyCreateLockdownPairing();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.58")))
        {
          SMIME = SecPolicyCreateURLBag();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.59")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateOTATasking();
          goto LABEL_17;
        }
        if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.60")))
        {
          SMIME = (__SecPolicy *)SecPolicyCreateMobileAsset();
          goto LABEL_17;
        }
        if (!CFEqual(EAP, CFSTR("1.2.840.113635.100.1.61")))
        {
          if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.64")))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleSoftwareSigning();
            goto LABEL_17;
          }
          if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.65")))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleExternalDeveloperOptionalExpiry(1);
            goto LABEL_17;
          }
          if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.66")))
          {
            SMIME = SecPolicyCreateOCSPSigner();
            goto LABEL_17;
          }
          if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.67")))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleIDSService(v5);
            goto LABEL_17;
          }
          if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.70")))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateApplePushServiceLegacy(v5);
            goto LABEL_17;
          }
          if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.71")))
          {
            SMIME = (__SecPolicy *)SecPolicyCreateAppleTVOSApplicationSigning();
            goto LABEL_17;
          }
          if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.73")))
          {
            v37 = CFSTR("1.2.840.113635.100.1.73");
            v38 = CFSTR("Escrow");
            v39 = CFSTR("1.2.840.113635.100.6.27.7.2");
            v40 = CFSTR("1.2.840.113635.100.6.27.7.1");
          }
          else if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.74")))
          {
            v37 = CFSTR("1.2.840.113635.100.1.74");
            v38 = CFSTR("MMCS");
            v39 = CFSTR("1.2.840.113635.100.6.27.11.2");
            v40 = CFSTR("1.2.840.113635.100.6.27.11.1");
          }
          else
          {
            if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.75")))
            {
              SMIME = (__SecPolicy *)SecPolicyCreateAppleSecureIOStaticAsset();
              goto LABEL_17;
            }
            if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.76")))
            {
              SMIME = (__SecPolicy *)SecPolicyCreateAppleWarsaw();
              goto LABEL_17;
            }
            if (!CFEqual(EAP, CFSTR("1.2.840.113635.100.1.78")))
            {
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.80")))
              {
                SMIME = SecPolicyCreateAppleAppTransportSecurity();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.81")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMacOSProfileApplicationSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.82")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMobileSoftwareUpdate();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.83")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMobileAssetDevelopment();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.86")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateiPhoneVPNApplicationSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.87")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateiAPSWAuthWithExpiration(0);
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.88")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateDemoDigitalCatalogSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.89")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleAssetReceipt();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.90")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleDeveloperIDPlusTicket();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.91")))
              {
                SMIME = SecPolicyCreateAppleFDRProvisioning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.93")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleKeyTransparency(v5);
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.95")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAlisha();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.96")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMeasuredBootPolicySigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.97")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateApplePayQRCodeEncryption();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.98")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateApplePayQRCodeSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.99")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleAccessoryUpdateSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.100")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateEscrowServiceIdKeySigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.101")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreatePCSEscrowServiceIdKeySigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.103")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateDeveloperIDInstaller();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.104")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateMacAppStoreInstaller();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.105")))
              {
                v29 = CFSTR("MacDistributionInstaller");
                v30 = CFSTR("1.2.840.113635.100.6.2.1");
                v31 = CFSTR("1.2.840.113635.100.6.1.8");
                goto LABEL_77;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.109")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleCHIPUpdateSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.110")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateOrderBundleSigner(v5);
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.111")))
              {
                SMIME = SecPolicyCreateQiSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.113")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateAppleXROSApplicationSigning();
                goto LABEL_17;
              }
              if (CFEqual(EAP, CFSTR("1.2.840.113635.100.1.114")))
              {
                SMIME = (__SecPolicy *)SecPolicyCreateEDPSigning();
                goto LABEL_17;
              }
              if (!CFEqual(EAP, CFSTR("1.2.840.113635.100.1.116")))
              {
                v23 = secLogObjForScope("SecError");
                if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                  return 0;
                *(_DWORD *)value = 138412290;
                *(_QWORD *)&value[4] = EAP;
                v16 = "ERROR: policy \"%@\" is unsupported";
                goto LABEL_90;
              }
              v32 = CFSTR("1.2.840.113635.100.1.116");
              v33 = CFSTR("ParakeetSigning");
              v34 = 0;
              v35 = 0;
LABEL_129:
              SMIME = (__SecPolicy *)SecPolicyCreateParakeetCommon(v34, v35, v32, v33);
              goto LABEL_17;
            }
            v37 = CFSTR("1.2.840.113635.100.1.78");
            v38 = CFSTR("iCloudSetup");
            v39 = CFSTR("1.2.840.113635.100.6.27.15.2");
            v40 = CFSTR("1.2.840.113635.100.6.27.15.1");
          }
          SMIME = (__SecPolicy *)SecPolicyCreateAppleGeoTrustServerAuthCommon(v5, v37, v38, v39, v40);
          goto LABEL_17;
        }
        goto LABEL_137;
      }
      v36 = 1;
    }
    SMIME = (__SecPolicy *)CreateMobileStoreSigner(v36);
    goto LABEL_17;
  }
  SMIME = (__SecPolicy *)SecPolicyCreateSSL_internal(!v7, v5, 0, 0);
LABEL_17:
  EAP = SMIME;
LABEL_18:
  if (EAP && cf)
    SecPolicySetName((uint64_t)EAP, cf);
  return EAP;
}

_QWORD *SecPolicyCreateAppleIDSService(const void *a1)
{
  _QWORD *AppleServerAuthCommon;
  __CFDictionary *MutableCopy;
  const void *v3;

  AppleServerAuthCommon = SecPolicyCreateAppleServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.67"), CFSTR("IDSBag"), (uint64_t)&oidAppleCertExtAppleServerAuthenticationIDSProd, (uint64_t)&oidAppleCertExtAppleServerAuthenticationIDSProdQA);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, (CFDictionaryRef)AppleServerAuthCommon[4]);
  CFDictionaryRemoveValue(MutableCopy, CFSTR("Revocation"));
  v3 = (const void *)AppleServerAuthCommon[4];
  if (v3)
    CFRelease(v3);
  AppleServerAuthCommon[4] = MutableCopy;
  return AppleServerAuthCommon;
}

_QWORD *SecPolicyCreateAppleServerAuthCommon(const void *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  __CFDictionary *Mutable;
  __CFDictionary *v11;
  const void *v12;
  CFIndex v13;
  CFDataRef v14;
  CFDataRef v15;
  __CFString *v16;
  __CFString *v17;
  __CFString *v18;
  BOOL v19;
  CFStringRef v20;
  _QWORD *v21;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v11 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (!a1)
    goto LABEL_27;
  CFDictionaryAddValue(v11, CFSTR("SSLHostname"), a1);
  v12 = (const void *)*MEMORY[0x1E0C9AE50];
  CFDictionaryAddValue(v11, CFSTR("BlackListedLeaf"), (const void *)*MEMORY[0x1E0C9AE50]);
  CFDictionaryAddValue(v11, CFSTR("GrayListedLeaf"), v12);
  add_eku(v11, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
  if (!requireUATPinning((uint64_t)a3))
    goto LABEL_20;
  SecPolicyAddAppleAnchorOptions(v11);
  if (a5)
  {
    v13 = *(_QWORD *)(a4 + 8);
    if ((v13 & 0x8000000000000000) == 0 && (*(_QWORD *)(a5 + 8) & 0x8000000000000000) == 0)
    {
      v14 = CFDataCreate(0, *(const UInt8 **)a4, v13);
      v15 = CFDataCreate(0, *(const UInt8 **)a5, *(_QWORD *)(a5 + 8));
      add_leaf_prod_qa_element(v11, v14, v15);
      if (v14)
        CFRelease(v14);
      if (v15)
        CFRelease(v15);
    }
    v16 = (__CFString *)SecDERItemCopyOIDDecimalRepresentation(0, (unsigned __int8 **)a4);
    v17 = (__CFString *)SecDERItemCopyOIDDecimalRepresentation(0, (unsigned __int8 **)a5);
    v18 = v17;
    v19 = v17 != 0;
    if (v16 && v17)
    {
      add_leaf_prod_qa_markers_value_string(v11, v16, v17);
      CFRelease(v16);
LABEL_18:
      CFRelease(v18);
      goto LABEL_19;
    }
    if (!v16)
    {
      if (!v17)
        goto LABEL_19;
      goto LABEL_18;
    }
  }
  else
  {
    add_leaf_marker_value(v11, a4, 0);
    v20 = SecDERItemCopyOIDDecimalRepresentation(0, (unsigned __int8 **)a4);
    if (!v20)
      goto LABEL_19;
    v16 = (__CFString *)v20;
    v18 = 0;
    v19 = 0;
  }
  add_leaf_marker_value_string(v11, CFSTR("1.2.840.113635.100.6.48.1"), v16);
  CFRelease(v16);
  if (v19)
    goto LABEL_18;
LABEL_19:
  add_oid(v11, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleServerAuthentication, 10);
LABEL_20:
  if (!SecPolicyRemoveWeakHashOptions(v11) || !SecPolicyAddStrongKeySizeOptions(v11))
  {
LABEL_27:
    v21 = 0;
    goto LABEL_23;
  }
  CFDictionaryAddValue(v11, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
  v21 = SecPolicyCreate(a2, a3, v11);
LABEL_23:
  CFRelease(v11);
  return v21;
}

_QWORD *SecPolicyCreatePassbookCardSigner(void *a1, const void *a2)
{
  __CFDictionary *Mutable;
  __CFDictionary *v5;
  _BOOL4 v6;
  _QWORD *v7;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v5 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v5))
  {
    v6 = SecPolicyAddChainLengthOptions(v5, 3);
    v7 = 0;
    if (a2 && v6)
    {
      CFDictionaryAddValue(v5, CFSTR("SubjectOrganizationalUnit"), a2);
      add_leaf_marker_value(v5, (uint64_t)&oidAppleInstallerPackagingSigningExternal, a1);
      add_element(v5, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.1"));
      add_eku(v5, oidAppleExtendedKeyUsagePassbook);
      v7 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.22"), CFSTR("ApplePassbook"), v5);
    }
  }
  else
  {
    v7 = 0;
  }
  CFRelease(v5);
  return v7;
}

void add_leaf_marker_value(const __CFDictionary *a1, uint64_t a2, void *a3)
{
  CFIndex v4;
  const __CFAllocator *v6;
  CFStringRef v7;
  CFDictionaryRef v8;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a2 + 8);
  if ((v4 & 0x8000000000000000) == 0)
  {
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (a3)
    {
      v7 = SecDERItemCopyOIDDecimalRepresentation((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (unsigned __int8 **)a2);
      values = a3;
      keys[0] = (void *)v7;
      v8 = CFDictionaryCreate(v6, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v7)
        CFRelease(v7);
    }
    else
    {
      v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(const UInt8 **)a2, v4);
    }
    add_element(a1, CFSTR("LeafMarkerOid"), v8);
    if (v8)
      CFRelease(v8);
  }
}

CFStringRef SecDERItemCopyOIDDecimalRepresentation(const __CFAllocator *a1, unsigned __int8 **a2)
{
  unint64_t v2;
  const __CFString *v3;
  __CFString *Mutable;
  __CFString *v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  unsigned __int8 v17;

  v2 = (unint64_t)a2[1];
  if (!v2)
  {
    v3 = CFSTR("<NULL>");
    return SecFrameworkCopyLocalizedString(v3, CFSTR("Certificate"));
  }
  if (v2 > 0x20)
  {
    v3 = CFSTR("OID too long");
    return SecFrameworkCopyLocalizedString(v3, CFSTR("Certificate"));
  }
  Mutable = CFStringCreateMutable(a1, 0);
  v7 = Mutable;
  v8 = **a2;
  v9 = v8 / 0x28;
  v10 = v8 > 0x77;
  if (v8 <= 0x77)
    v11 = v9;
  else
    v11 = 2;
  if (v10)
    v12 = 40 * v9 - 80;
  else
    v12 = 0;
  CFStringAppendFormat(Mutable, 0, CFSTR("%u.%u"), v11, v12 + **a2 % 0x28u);
  v13 = (unint64_t)a2[1];
  if (v13 >= 2)
  {
    v14 = 0;
    v15 = 2;
    v16 = 1;
    do
    {
      v17 = (*a2)[v16];
      if ((v17 & 0x80) != 0)
      {
        v14 = v17 & 0x7F | (v14 << 7);
      }
      else
      {
        CFStringAppendFormat(v7, 0, CFSTR(".%u"), v17 & 0x7F | (v14 << 7));
        v14 = 0;
        v13 = (unint64_t)a2[1];
      }
      v16 = v15;
      v10 = v13 > v15++;
    }
    while (v10);
  }
  return v7;
}

uint64_t requireUATPinning(uint64_t a1)
{
  const __CFString *v2;
  const __CFString *v3;
  NSObject *v4;
  const char *v5;
  NSObject *v7;
  uint8_t buf[4];
  const __CFString *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (!os_variant_allows_internal_security_policies())
  {
    v4 = secLogObjForScope("pinningQA");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v5 = "could not disable pinning: not an internal release";
LABEL_7:
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 2u);
    }
    return 1;
  }
  v2 = CFStringCreateWithFormat(0, 0, CFSTR("AppleServerAuthenticationNoPinning%@"), a1);
  if (!v2)
    return 1;
  v3 = v2;
  if (!CFPreferencesGetAppBooleanValue(v2, CFSTR("com.apple.security"), 0))
  {
    v7 = secLogObjForScope("pinningQA");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v9 = v3;
      _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "could not disable pinning: %@ not true", buf, 0xCu);
    }
    CFRelease(v3);
    if (CFPreferencesGetAppBooleanValue(CFSTR("AppleServerAuthenticationNoPinning"), CFSTR("com.apple.security"), 0))
      return 0;
    v4 = secLogObjForScope("pinningQA");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v5 = "could not disable pinning: AppleServerAuthenticationNoPinning not true";
      goto LABEL_7;
    }
    return 1;
  }
  CFRelease(v3);
  return 0;
}

void add_oid(const __CFDictionary *a1, const void *a2, UInt8 *bytes, CFIndex length)
{
  CFDataRef v6;
  CFDataRef v7;

  if ((length & 0x8000000000000000) == 0)
  {
    v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, length);
    if (v6)
    {
      v7 = v6;
      add_element(a1, a2, v6);
      CFRelease(v7);
    }
  }
}

void add_leaf_prod_qa_markers_value_string(const __CFDictionary *a1, void *a2, void *a3)
{
  const CFDictionaryKeyCallBacks *v4;
  const CFDictionaryValueCallBacks *v5;
  CFDictionaryRef v6;
  CFDictionaryRef v7;
  void *v8;
  void *values;
  void *v10;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  v10 = CFSTR("1.2.840.113635.100.6.48.1");
  keys[0] = CFSTR("1.2.840.113635.100.6.48.1");
  v8 = a3;
  values = a2;
  v4 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v5 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v6 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v7 = CFDictionaryCreate(0, (const void **)&v10, (const void **)&v8, 1, v4, v5);
  add_leaf_prod_qa_element(a1, v6, v7);
  if (v6)
    CFRelease(v6);
  if (v7)
    CFRelease(v7);
}

void add_leaf_prod_qa_element(const __CFDictionary *a1, const void *a2, const void *a3)
{
  __CFDictionary *Mutable;
  const __CFDictionary *Value;
  const __CFDictionary *v8;
  void *v9;
  void *v10;
  CFTypeID v11;
  CFTypeID v12;
  const CFArrayCallBacks *v13;
  __CFArray *v14;
  __CFArray *v15;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("LeafMarkersProdAndQA"));
  if (Value)
  {
    v8 = Value;
    v9 = (void *)CFDictionaryGetValue(Value, CFSTR("ProdMarker"));
    v10 = (void *)CFDictionaryGetValue(v8, CFSTR("QAMarker"));
    if (v9
      && (v11 = CFGetTypeID(v9), v11 == CFArrayGetTypeID())
      && v10
      && (v12 = CFGetTypeID(v10), v12 == CFArrayGetTypeID()))
    {
      CFRetain(v9);
      CFRetain(v10);
    }
    else
    {
      v13 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
      v14 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      v15 = CFArrayCreateMutable(0, 0, v13);
      CFArrayAppendValue(v14, v9);
      CFArrayAppendValue(v15, v10);
      v10 = v15;
      v9 = v14;
    }
    CFArrayAppendValue((CFMutableArrayRef)v9, a2);
    CFArrayAppendValue((CFMutableArrayRef)v10, a3);
    CFDictionaryAddValue(Mutable, CFSTR("ProdMarker"), v9);
    CFDictionaryAddValue(Mutable, CFSTR("QAMarker"), v10);
    if (v9)
      CFRelease(v9);
    if (v10)
      CFRelease(v10);
  }
  else
  {
    CFDictionaryAddValue(Mutable, CFSTR("ProdMarker"), a2);
    CFDictionaryAddValue(Mutable, CFSTR("QAMarker"), a3);
  }
  CFDictionarySetValue(a1, CFSTR("LeafMarkersProdAndQA"), Mutable);
  if (Mutable)
    CFRelease(Mutable);
}

void deserializePolicy(const void *a1, __CFArray *a2)
{
  CFTypeID v4;
  const void *Value;
  const void *v6;
  CFTypeID v7;
  const void *v8;
  const void *v9;
  CFTypeID v10;
  const void *v11;
  _QWORD *v12;
  const void *v13;

  if (a1)
  {
    v4 = CFGetTypeID(a1);
    if (v4 == CFDictionaryGetTypeID())
    {
      Value = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("SecPolicyOid"));
      if (Value)
      {
        v6 = Value;
        v7 = CFGetTypeID(Value);
        if (v7 == CFStringGetTypeID())
        {
          v8 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("policyOptions"));
          if (v8)
          {
            v9 = v8;
            v10 = CFGetTypeID(v8);
            if (v10 == CFDictionaryGetTypeID())
            {
              v11 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("SecPolicyPolicyName"));
              v12 = SecPolicyCreate(v6, v11, v9);
              if (v12)
              {
                v13 = v12;
                CFArrayAppendValue(a2, v12);
                CFRelease(v13);
              }
            }
          }
        }
      }
    }
  }
}

CFMutableArrayRef SecPolicyXPCArrayCopyArray(void *a1, __CFString **a2)
{
  unint64_t count;
  unint64_t v4;
  CFMutableArrayRef Mutable;
  size_t v6;
  xpc_object_t value;
  void *v8;
  const __CFString *v9;
  const __CFString *v10;
  CFTypeID v11;
  const __CFString *v12;
  const __CFString *v13;
  CFTypeID v14;
  CFRange v15;
  CFStringRef v16;
  CFStringRef v17;
  CFStringRef v18;
  CFStringRef v19;
  _QWORD *v20;
  const __CFString *v21;
  int v22;
  const __CFString *v24;
  uint64_t v25;
  CFRange v27;
  CFRange v28;

  if (MEMORY[0x18D7718B8]() != MEMORY[0x1E0C812C8])
  {
    SecError(-50, a2, CFSTR("policies xpc value is not an array"));
    return 0;
  }
  count = xpc_array_get_count(a1);
  v4 = count;
  if (count >= 0x7FFFFFFFFFFFFFFFLL)
  {
    SecError(-108, a2, CFSTR("failed to create CFArray of capacity %zu"), count);
    return 0;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], count, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    SecError(-108, a2, CFSTR("failed to create CFArray of capacity %zu"), v4);
    return Mutable;
  }
  if (v4)
  {
    v6 = 0;
    while (1)
    {
      value = xpc_array_get_value(a1, v6);
      if (!value)
      {
        v21 = CFSTR("policy xpc value is NULL");
        goto LABEL_35;
      }
      v8 = value;
      if (MEMORY[0x18D7718B8]() != MEMORY[0x1E0C812C8])
      {
        v21 = CFSTR("policy xpc value is not an array");
LABEL_33:
        v22 = -26275;
        goto LABEL_36;
      }
      if (xpc_array_get_count(v8) <= 1)
      {
        v21 = CFSTR("policy xpc array count < 2");
        goto LABEL_33;
      }
      xpc_array_get_value(v8, 0);
      v9 = (const __CFString *)_CFXPCCreateCFObjectFromXPCObject();
      if (!v9)
      {
        v25 = 0;
        v21 = CFSTR("failed to convert xpc policy[0]=%@ to CFString");
LABEL_35:
        v22 = -50;
LABEL_36:
        SecError(v22, a2, v21, v25);
        goto LABEL_37;
      }
      v10 = v9;
      v11 = CFGetTypeID(v9);
      if (v11 != CFStringGetTypeID())
      {
        SecError(-50, a2, CFSTR("failed to convert xpc policy[0]=%@ to CFString"), v10);
        goto LABEL_41;
      }
      xpc_array_get_value(v8, 1uLL);
      v12 = (const __CFString *)_CFXPCCreateCFObjectFromXPCObject();
      if (!v12)
      {
        SecError(-50, a2, CFSTR("failed to convert xpc policy[1]=%@ to CFDictionary"), 0);
LABEL_41:
        v24 = v10;
LABEL_42:
        CFRelease(v24);
LABEL_37:
        CFRelease(Mutable);
        return 0;
      }
      v13 = v12;
      v14 = CFGetTypeID(v12);
      if (v14 != CFDictionaryGetTypeID())
      {
        SecError(-50, a2, CFSTR("failed to convert xpc policy[1]=%@ to CFDictionary"), v13);
        CFRelease(v10);
        v24 = v13;
        goto LABEL_42;
      }
      v15 = CFStringFind(v10, CFSTR("++"), 0);
      if (v15.length != 2)
        break;
      v27.location = 0;
      v27.length = v15.location;
      v16 = CFStringCreateWithSubstring(0, v10, v27);
      v17 = v16;
      if (v16)
      {
        CFRetain(v16);
        CFRelease(v17);
      }
      if (v15.location + 2 >= CFStringGetLength(v10))
      {
        v19 = 0;
      }
      else
      {
        v28.length = CFStringGetLength(v10) - v15.location - 2;
        v28.location = v15.location + 2;
        v18 = CFStringCreateWithSubstring(0, v10, v28);
        v19 = v18;
        if (v18)
        {
          CFRetain(v18);
          CFRelease(v19);
        }
      }
      v20 = SecPolicyCreate(v17, v19, v13);
      if (!v20)
        SecError(-26275, a2, CFSTR("Failed to create policy"));
      CFRelease(v10);
      if (v17)
        CFRelease(v17);
      if (v19)
        goto LABEL_26;
LABEL_27:
      CFRelease(v13);
      if (!v20)
        goto LABEL_37;
      CFArraySetValueAtIndex(Mutable, v6, v20);
      CFRelease(v20);
      if (v4 == ++v6)
        return Mutable;
    }
    SecError(-50, a2, CFSTR("failed to convert combined %@ to name and oid"), v10);
    v20 = 0;
    v19 = v10;
LABEL_26:
    CFRelease(v19);
    goto LABEL_27;
  }
  return Mutable;
}

__CFDictionary *SecPolicyCreateOCSPSigner()
{
  __CFDictionary *result;
  const __CFDictionary *v1;
  _QWORD *v2;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (result)
  {
    v1 = result;
    SecPolicyAddBasicX509Options(result);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageOCSPSigning);
    add_ku(v1, 1);
    CFDictionarySetValue(v1, CFSTR("NotCA"), (const void *)*MEMORY[0x1E0C9AE50]);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.66"), CFSTR("OCSPSigner"), v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

_QWORD *SecPolicyCreateiPhoneApplicationSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1))
    goto LABEL_10;
  if (os_variant_allows_internal_security_policies())
  {
    CFDictionaryAddValue(v1, CFSTR("SubjectCommonNameTEST"), CFSTR("Apple iPhone OS Application Signing"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.3.1"));
  }
  else
  {
    CFDictionaryAddValue(v1, CFSTR("SubjectCommonName"), CFSTR("Apple iPhone OS Application Signing"));
  }
  add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.3"));
  add_eku(v1, 0);
  add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
  add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
  CFDictionaryAddValue(v1, CFSTR("IssuerCommonName"), CFSTR("Apple iPhone Certification Authority"));
  if (SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, CFSTR("NoNetworkAccess"), (const void *)*MEMORY[0x1E0C9AE50]);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.54"), CFSTR("iPhoneApplicationSigning"), v1);
  }
  else
  {
LABEL_10:
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateSSL_internal(int a1, const __CFString *a2, int a3, const __CFDictionary *a4)
{
  __CFDictionary *Mutable;
  __CFDictionary *v9;
  const void *v10;
  const __CFString *Value;
  const __CFString *v12;
  CFTypeID v13;
  CFMutableArrayRef NSPinnedIdentitiesForHostName;
  CFMutableArrayRef v15;
  __CFArray *v16;
  CFDateRef v17;
  CFNumberRef v18;
  __CFArray *v19;
  CFDateRef v20;
  CFNumberRef v21;
  __CFArray *v22;
  __CFArray *v23;
  CFDateRef v24;
  CFNumberRef v25;
  __CFArray *v26;
  _BOOL4 v27;
  const __CFString *v28;
  _QWORD *v29;
  uint64_t v31;
  uint64_t valuePtr;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v9 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (a2)
    CFDictionaryAddValue(v9, CFSTR("SSLHostname"), a2);
  v10 = (const void *)*MEMORY[0x1E0C9AE50];
  CFDictionaryAddValue(v9, CFSTR("BlackListedLeaf"), (const void *)*MEMORY[0x1E0C9AE50]);
  CFDictionaryAddValue(v9, CFSTR("GrayListedLeaf"), v10);
  if (!a1)
    goto LABEL_41;
  if (SecPolicyRemoveWeakHashOptions(v9) && SecPolicyAddStrongKeySizeOptions(v9))
  {
    if (SecPolicyAddPinningRequiredIfInfoSpecified_onceToken != -1)
      dispatch_once(&SecPolicyAddPinningRequiredIfInfoSpecified_onceToken, &__block_literal_global_11133);
    if (SecPolicyAddPinningRequiredIfInfoSpecified_result == 1)
    {
      if (SecPolicyAddPinningRequiredIfInfoSpecified_hasPinningRequiredKey != 1
        || (add_element(v9, CFSTR("PinningRequired"), v10), SecPolicyAddPinningRequiredIfInfoSpecified_result == 1))
      {
        Value = (const __CFString *)CFDictionaryGetValue(v9, CFSTR("SSLHostname"));
        if (Value)
        {
          v12 = Value;
          v13 = CFGetTypeID(Value);
          if (v13 == CFStringGetTypeID())
          {
            NSPinnedIdentitiesForHostName = getNSPinnedIdentitiesForHostName(v12, (uint64_t)CFSTR("NSPinnedLeafIdentities"));
            if (NSPinnedIdentitiesForHostName)
              add_element(v9, CFSTR("LeafSPKISHA256"), NSPinnedIdentitiesForHostName);
            v15 = getNSPinnedIdentitiesForHostName(v12, (uint64_t)CFSTR("NSPinnedCAIdentities"));
            if (v15)
              add_element(v9, CFSTR("CAspkiSHA256"), v15);
          }
        }
        SecPolicyReconcilePinningRequiredIfInfoSpecified(v9);
        v16 = CFArrayCreateMutable(0, 2, MEMORY[0x1E0C9B378]);
        v17 = CFDateCreate(0, 541555200.0);
        valuePtr = 0x4190FECE40000000;
        v18 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
        CFArrayAppendValue(v16, v17);
        CFArrayAppendValue(v16, v18);
        if (v17)
          CFRelease(v17);
        if (v18)
          CFRelease(v18);
        v19 = CFArrayCreateMutable(0, 2, MEMORY[0x1E0C9B378]);
        v20 = CFDateCreate(0, 620611200.0);
        v31 = 0x418065A800000000;
        v21 = CFNumberCreate(0, kCFNumberDoubleType, &v31);
        CFArrayAppendValue(v19, v20);
        CFArrayAppendValue(v19, v21);
        if (v20)
          CFRelease(v20);
        if (v21)
          CFRelease(v21);
        v22 = CFArrayCreateMutable(0, 2, MEMORY[0x1E0C9B378]);
        CFArrayAppendValue(v22, v16);
        CFArrayAppendValue(v22, v19);
        if (v19)
          CFRelease(v19);
        if (v16)
          CFRelease(v16);
        CFDictionaryAddValue(v9, CFSTR("SystemTrustValidityPeriod"), v22);
        if (v22)
          CFRelease(v22);
        v23 = CFArrayCreateMutable(0, 2, MEMORY[0x1E0C9B378]);
        v24 = CFDateCreate(0, 583628400.0);
        v25 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
        CFArrayAppendValue(v23, v24);
        CFArrayAppendValue(v23, v25);
        if (v24)
          CFRelease(v24);
        if (v25)
          CFRelease(v25);
        v26 = CFArrayCreateMutable(0, 1, MEMORY[0x1E0C9B378]);
        CFArrayAppendValue(v26, v23);
        if (v23)
          CFRelease(v23);
        CFDictionaryAddValue(v9, CFSTR("OtherTrustValidityPeriod"), v26);
        if (v26)
          CFRelease(v26);
        CFDictionaryAddValue(v9, CFSTR("ServerAuthEKU"), v10);
        CFDictionaryAddValue(v9, CFSTR("SystemTrustedCTRequired"), v10);
LABEL_41:
        if (a3)
        {
          add_ku(v9, a3);
          add_ku(v9, 0);
        }
        v27 = a1 != 0;
        if (a1)
          v28 = CFSTR("sslServer");
        else
          v28 = CFSTR("sslClient");
        set_ssl_ekus(v9, v27);
        add_ats_options_from_dict(v9, a2, a4);
        v29 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.3"), v28, v9);
        goto LABEL_47;
      }
    }
  }
  v29 = 0;
LABEL_47:
  CFRelease(v9);
  return v29;
}

CFMutableArrayRef getNSPinnedIdentitiesForHostName(const __CFString *a1, uint64_t a2)
{
  CFMutableArrayRef result;

  if (getNSPinnedIdentitiesForHostName_onceToken != -1)
    dispatch_once(&getNSPinnedIdentitiesForHostName_onceToken, &__block_literal_global_755);
  result = (CFMutableArrayRef)getNSPinnedIdentitiesForHostName_nsPinnedDomainsDict;
  if (getNSPinnedIdentitiesForHostName_nsPinnedDomainsDict)
    return parseNSPinnedDomains((const __CFDictionary *)getNSPinnedIdentitiesForHostName_nsPinnedDomainsDict, a1, a2);
  return result;
}

_QWORD *SecPolicyCreate(const void *a1, const void *a2, const void *a3)
{
  _QWORD *Instance;

  if (!a1)
    return 0;
  SecPolicyGetTypeID();
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    CFRetain(a1);
    Instance[2] = a1;
    if (a2)
      CFRetain(a2);
    Instance[3] = a2;
    CFRetain(a3);
    Instance[4] = a3;
  }
  return Instance;
}

void SecPolicyReconcilePinningRequiredIfInfoSpecified(const __CFDictionary *a1)
{
  const void *Value;
  const void *v3;
  const void *v4;
  CFTypeID v5;
  CFTypeID v6;

  if (CFDictionaryContainsKey(a1, CFSTR("PinningRequired")))
  {
    Value = CFDictionaryGetValue(a1, CFSTR("LeafSPKISHA256"));
    v3 = CFDictionaryGetValue(a1, CFSTR("CAspkiSHA256"));
    if (Value)
    {
      v4 = v3;
      v5 = CFGetTypeID(Value);
      if (v5 == CFArrayGetTypeID() && !CFArrayGetCount((CFArrayRef)Value))
      {
        if (v4)
        {
          v6 = CFGetTypeID(v4);
          if (v6 == CFArrayGetTypeID() && !CFArrayGetCount((CFArrayRef)v4))
            CFDictionaryRemoveValue(a1, CFSTR("PinningRequired"));
        }
      }
    }
    CFDictionaryRemoveValue(a1, CFSTR("LeafSPKISHA256"));
    CFDictionaryRemoveValue(a1, CFSTR("CAspkiSHA256"));
  }
}

void add_ku(const __CFDictionary *a1, int a2)
{
  CFNumberRef v3;
  CFNumberRef v4;
  int valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  if (v3)
  {
    v4 = v3;
    add_element(a1, CFSTR("KeyUsage"), v3);
    CFRelease(v4);
  }
}

void SecPolicyAddBasicX509Options(__CFDictionary *a1)
{
  const void *v2;

  SecPolicyAddBasicCertOptions(a1);
  v2 = (const void *)*MEMORY[0x1E0C9AE50];
  CFDictionaryAddValue(a1, CFSTR("TemporalValidity"), (const void *)*MEMORY[0x1E0C9AE50]);
  CFDictionaryAddValue(a1, CFSTR("BlackListedLeaf"), v2);
  CFDictionaryAddValue(a1, CFSTR("GrayListedLeaf"), v2);
}

void SecPolicyAddBasicCertOptions(__CFDictionary *a1)
{
  const void *v2;

  v2 = (const void *)*MEMORY[0x1E0C9AE50];
  CFDictionaryAddValue(a1, CFSTR("CriticalExtensions"), (const void *)*MEMORY[0x1E0C9AE50]);
  CFDictionaryAddValue(a1, CFSTR("UnparseableExtension"), v2);
  CFDictionaryAddValue(a1, CFSTR("DuplicateExtension"), v2);
  CFDictionaryAddValue(a1, CFSTR("IdLinkage"), v2);
  CFDictionaryAddValue(a1, CFSTR("BasicConstraints"), v2);
  CFDictionaryAddValue(a1, CFSTR("NonEmptySubject"), v2);
  CFDictionaryAddValue(a1, CFSTR("WeakKeySize"), v2);
  CFDictionaryAddValue(a1, CFSTR("WeakSignature"), v2);
}

void set_ssl_ekus(__CFDictionary *a1, int a2)
{
  const DERItem *v4;

  CFDictionaryRemoveValue(a1, CFSTR("ExtendedKeyUsage"));
  add_eku(a1, 0);
  add_eku(a1, (const UInt8 *)&oidAnyExtendedKeyUsage);
  if (a2)
  {
    add_eku(a1, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
    add_eku(a1, (const UInt8 *)&oidExtendedKeyUsageMicrosoftSGC);
    v4 = &oidExtendedKeyUsageNetscapeSGC;
  }
  else
  {
    v4 = &oidExtendedKeyUsageClientAuth;
  }
  add_eku(a1, (const UInt8 *)v4);
}

void add_eku(const __CFDictionary *a1, const UInt8 *a2)
{
  CFIndex v3;
  CFDataRef v4;
  CFDataRef v5;

  if (a2)
  {
    v3 = *((_QWORD *)a2 + 1);
    if (v3 < 0)
      return;
    a2 = *(const UInt8 **)a2;
  }
  else
  {
    v3 = 0;
  }
  v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, v3);
  if (v4)
  {
    v5 = v4;
    add_element(a1, CFSTR("ExtendedKeyUsage"), v4);
    CFRelease(v5);
  }
}

void add_element(const __CFDictionary *a1, const void *a2, const void *a3)
{
  __CFArray *Value;
  __CFArray *v7;
  CFTypeID v8;
  __CFArray *Mutable;

  Value = (__CFArray *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    v7 = Value;
    v8 = CFGetTypeID(Value);
    if (v8 != CFArrayGetTypeID())
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      CFArrayAppendValue(Mutable, v7);
      CFDictionarySetValue(a1, a2, Mutable);
      CFRelease(Mutable);
      v7 = Mutable;
    }
    CFArrayAppendValue(v7, a3);
  }
  else
  {
    CFDictionaryAddValue(a1, a2, a3);
  }
}

BOOL SecPolicyRemoveWeakHashOptions(const __CFDictionary *a1)
{
  __CFArray *Mutable;
  __CFArray *v3;

  Mutable = CFArrayCreateMutable(0, 5, MEMORY[0x1E0C9B378]);
  v3 = Mutable;
  if (Mutable)
  {
    CFArrayAppendValue(Mutable, CFSTR("SignatureDigestMD2"));
    CFArrayAppendValue(v3, CFSTR("SignatureDigestMD4"));
    CFArrayAppendValue(v3, CFSTR("SignatureDigestMD5"));
    CFArrayAppendValue(v3, CFSTR("SignatureDigestSHA1"));
    add_element(a1, CFSTR("SignatureHashAlgorithms"), v3);
    CFRelease(v3);
  }
  return v3 != 0;
}

BOOL SecPolicyAddStrongKeySizeOptions(const __CFDictionary *a1)
{
  CFNumberRef v2;
  CFNumberRef v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFDictionaryRef v6;
  _BOOL8 v7;
  CFDictionaryRef v8;
  uint64_t v10;
  void *values[2];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  v10 = 2048;
  v2 = CFNumberCreate(0, kCFNumberCFIndexType, &v10);
  if (!v2)
    return 0;
  v3 = v2;
  v10 = 256;
  v4 = CFNumberCreate(0, kCFNumberCFIndexType, &v10);
  if (v4)
  {
    v5 = v4;
    keys[0] = CFSTR("42");
    keys[1] = CFSTR("73");
    values[0] = v3;
    values[1] = v4;
    v6 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v7 = v6 != 0;
    if (v6)
    {
      v8 = v6;
      add_element(a1, CFSTR("KeySize"), v6);
      CFRelease(v8);
    }
    CFRelease(v3);
  }
  else
  {
    v7 = 0;
    v5 = v3;
  }
  CFRelease(v5);
  return v7;
}

BOOL SecPolicyAddAppleAnchorOptions(const __CFDictionary *a1)
{
  CFMutableDictionaryRef Mutable;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    add_element(a1, CFSTR("AnchorApple"), Mutable);
    CFRelease(Mutable);
  }
  return Mutable != 0;
}

BOOL SecPolicyAddChainLengthOptions(__CFDictionary *a1, uint64_t a2)
{
  CFNumberRef v3;
  uint64_t valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, &valuePtr);
  if (v3)
  {
    CFDictionaryAddValue(a1, CFSTR("ChainLength"), v3);
    CFRelease(v3);
  }
  return v3 != 0;
}

uint64_t SecTrustSetURLRequestAttribution(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD v8[6];
  _QWORD block[5];

  if (!a1)
    return 4294967246;
  v4 = MEMORY[0x1E0C809B0];
  v5 = *(NSObject **)(a1 + 136);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11514;
  block[4] = a1;
  dispatch_sync(v5, block);
  v6 = *(NSObject **)(a1 + 136);
  v8[0] = v4;
  v8[1] = 0x40000000;
  v8[2] = __SecTrustSetURLRequestAttribution_block_invoke;
  v8[3] = &__block_descriptor_tmp_276;
  v8[4] = a1;
  v8[5] = a2;
  dispatch_sync(v6, v8);
  return 0;
}

uint64_t __sec_protocol_metadata_get_early_data_accepted_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    return (*(unsigned __int16 *)(a2 + 328) >> 3) & 1;
  else
    return 0;
}

__CFArray *SecCertificateXPCArrayCopyArray(void *a1, __CFString **a2)
{
  unint64_t count;
  unint64_t v5;
  __CFArray *Mutable;
  size_t v7;
  _QWORD *v8;
  const void *v9;

  if (MEMORY[0x18D7718B8]() != MEMORY[0x1E0C812C8])
  {
    SecError(-50, a2, CFSTR("certificates xpc value is not an array"));
    return 0;
  }
  count = xpc_array_get_count(a1);
  v5 = count;
  if (count >= 0x7FFFFFFFFFFFFFFFLL)
  {
    SecError(-108, a2, CFSTR("failed to create CFArray of capacity %zu"), count);
    return 0;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], count, MEMORY[0x1E0C9B378]);
  if (!Mutable)
  {
    SecError(-108, a2, CFSTR("failed to create CFArray of capacity %zu"), v5);
    return Mutable;
  }
  if (v5)
  {
    v7 = 0;
    while (1)
    {
      v8 = SecCertificateCreateWithXPCArrayAtIndex(a1, v7, a2);
      if (!v8)
        break;
      v9 = v8;
      CFArraySetValueAtIndex(Mutable, v7, v8);
      CFRelease(v9);
      if (v5 == ++v7)
        return Mutable;
    }
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t Security::mmapDeallocatorDeallocate(Security *this, CFDataRef theData, void *a3)
{
  size_t v4;

  v4 = *(_QWORD *)CFDataGetBytePtr(theData);
  return munmap(this, v4);
}

void SecTrustDestroy(_QWORD *a1)
{
  NSObject *v2;
  NSObject *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  void *v17;
  void *v18;

  v2 = a1[17];
  if (v2)
  {
    a1[17] = 0;
    dispatch_release(v2);
  }
  v3 = a1[21];
  if (v3)
  {
    a1[21] = 0;
    dispatch_release(v3);
  }
  v4 = (const void *)a1[2];
  if (v4)
  {
    a1[2] = 0;
    CFRelease(v4);
  }
  v5 = (const void *)a1[4];
  if (v5)
  {
    a1[4] = 0;
    CFRelease(v5);
  }
  v6 = (const void *)a1[5];
  if (v6)
  {
    a1[5] = 0;
    CFRelease(v6);
  }
  v7 = (const void *)a1[6];
  if (v7)
  {
    a1[6] = 0;
    CFRelease(v7);
  }
  v8 = (const void *)a1[7];
  if (v8)
  {
    a1[7] = 0;
    CFRelease(v8);
  }
  v9 = (const void *)a1[8];
  if (v9)
  {
    a1[8] = 0;
    CFRelease(v9);
  }
  v10 = (const void *)a1[3];
  if (v10)
  {
    a1[3] = 0;
    CFRelease(v10);
  }
  v11 = (const void *)a1[9];
  if (v11)
  {
    a1[9] = 0;
    CFRelease(v11);
  }
  v12 = (const void *)a1[10];
  if (v12)
  {
    a1[10] = 0;
    CFRelease(v12);
  }
  v13 = (const void *)a1[11];
  if (v13)
  {
    a1[11] = 0;
    CFRelease(v13);
  }
  v14 = (const void *)a1[12];
  if (v14)
  {
    a1[12] = 0;
    CFRelease(v14);
  }
  v15 = (const void *)a1[13];
  if (v15)
  {
    a1[13] = 0;
    CFRelease(v15);
  }
  v16 = (const void *)a1[18];
  if (v16)
  {
    a1[18] = 0;
    CFRelease(v16);
  }
  v17 = (void *)a1[15];
  if (v17)
    free(v17);
  v18 = (void *)a1[16];
  if (v18)
    free(v18);
}

CFMutableArrayRef SecCertificateArraySerialize(const void *a1)
{
  CFTypeID v2;
  CFIndex Count;
  CFMutableArrayRef Mutable;
  CFRange v6;

  v2 = CFGetTypeID(a1);
  if (v2 != CFArrayGetTypeID())
    return 0;
  Count = CFArrayGetCount((CFArrayRef)a1);
  Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E0C9B378]);
  v6.location = 0;
  v6.length = Count;
  CFArrayApplyFunction((CFArrayRef)a1, v6, (CFArrayApplierFunction)serializeCertificate, Mutable);
  return Mutable;
}

BOOL SecPolicyCheckCertKeyUsage(uint64_t a1, CFTypeRef cf)
{
  int v3;
  CFTypeID v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  BOOL v8;
  const void *ValueAtIndex;

  if (a1)
  {
    v3 = *(_DWORD *)(a1 + 384);
    if (!cf)
      return 0;
  }
  else
  {
    v3 = 0;
    if (!cf)
      return 0;
  }
  v4 = CFGetTypeID(cf);
  if (v4 == CFArrayGetTypeID())
  {
    Count = CFArrayGetCount((CFArrayRef)cf);
    if (Count >= 1)
    {
      v6 = Count;
      v7 = 0;
      v8 = 1;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, v7);
        if (keyusage_allows(v3, ValueAtIndex))
          break;
        v8 = ++v7 < v6;
      }
      while (v6 != v7);
      return v8;
    }
    return 0;
  }
  return keyusage_allows(v3, cf);
}

BOOL keyusage_allows(int a1, CFTypeRef cf)
{
  CFTypeID v4;
  int valuePtr;

  if (!cf)
    return 0;
  v4 = CFGetTypeID(cf);
  if (v4 != CFNumberGetTypeID())
    return 0;
  valuePtr = -1431655766;
  CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt32Type, &valuePtr);
  if (valuePtr)
    return (valuePtr & ~a1) == 0;
  else
    return a1 == 0;
}

uint64_t SecTrustIsTrustResultValid(uint64_t a1, double a2)
{
  double Current;
  uint64_t result;
  const __CFDictionary *v7;
  const void *Value;
  const void *v9;
  CFTypeID v10;
  CFTypeID v11;

  if (!*(_DWORD *)(a1 + 112))
    return 0;
  Current = CFAbsoluteTimeGetCurrent();
  if (Current + 4500.0 < a2 || Current + -4500.0 > a2)
    return 1;
  v7 = *(const __CFDictionary **)(a1 + 96);
  if (!v7)
    return 0;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), CFSTR("TrustResultNotBefore"));
  v9 = CFDictionaryGetValue(v7, CFSTR("TrustResultNotAfter"));
  result = 0;
  if (Value && v9)
  {
    v10 = CFGetTypeID(Value);
    if (v10 == CFDateGetTypeID())
    {
      v11 = CFGetTypeID(v9);
      if (v11 == CFDateGetTypeID() && Current < MEMORY[0x18D76F188](v9) && Current > MEMORY[0x18D76F188](Value))
        return 1;
    }
    return 0;
  }
  return result;
}

uint64_t SecTrustValidateInput(_QWORD *a1)
{
  const __CFArray *v2;
  CFTypeID TypeID;
  unsigned int v4;
  const __CFArray *v5;
  CFTypeID v6;
  unsigned int v7;
  const __CFArray *v8;
  CFTypeID v9;
  uint64_t result;

  v2 = (const __CFArray *)a1[2];
  TypeID = SecCertificateGetTypeID();
  v4 = validate_array_of_items(v2, (uint64_t)CFSTR("certificate"), TypeID, 1);
  v5 = (const __CFArray *)a1[3];
  v6 = SecCertificateGetTypeID();
  v7 = validate_array_of_items(v5, (uint64_t)CFSTR("input anchor"), v6, 0);
  if (v7)
    v4 = v7;
  v8 = (const __CFArray *)a1[4];
  v9 = SecPolicyGetTypeID();
  LODWORD(result) = validate_array_of_items(v8, (uint64_t)CFSTR("policy"), v9, 1);
  if ((_DWORD)result)
    return result;
  else
    return v4;
}

void securityd_send_async_and_do(unsigned int a1, NSObject *a2, uint64_t a3, uint64_t a4)
{
  xpc_object_t v7;
  void *v8;
  CFTypeRef v9;
  _QWORD v10[5];
  CFTypeRef cf;

  cf = 0;
  v7 = securityd_create_message(a1, &cf);
  if (v7)
  {
    v8 = v7;
    if (!a3 || ((*(uint64_t (**)(uint64_t, xpc_object_t, CFTypeRef *))(a3 + 16))(a3, v7, &cf) & 1) != 0)
    {
      v10[0] = MEMORY[0x1E0C809B0];
      v10[1] = 0x40000000;
      v10[2] = __securityd_send_async_and_do_block_invoke;
      v10[3] = &unk_1E1FCBA60;
      v10[4] = a4;
      _securityd_message_with_reply_async_inner(v8, a2, v10, 4);
      xpc_release(v8);
      return;
    }
    (*(void (**)(uint64_t, _QWORD, CFTypeRef))(a4 + 16))(a4, 0, cf);
    xpc_release(v8);
  }
  else
  {
    (*(void (**)(uint64_t, _QWORD, CFTypeRef))(a4 + 16))(a4, 0, cf);
  }
  v9 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v9);
  }
}

void _securityd_message_with_reply_async_inner(void *a1, NSObject *a2, const void *a3, int a4)
{
  uint64_t uint64;
  int v9;
  char v10;
  _xpc_connection_s *v11;
  void *v12;
  _QWORD handler[9];
  int v14;
  char v15;
  int v16;

  uint64 = xpc_dictionary_get_uint64(a1, "operation");
  v9 = securityd_message_is_for_system_keychain(a1);
  v10 = v9;
  v11 = securityd_connection_for_operation(uint64, v9, &v16);
  xpc_retain(a1);
  dispatch_retain(a2);
  v12 = _Block_copy(a3);
  handler[0] = MEMORY[0x1E0C809B0];
  handler[1] = 0x40000000;
  handler[2] = ___securityd_message_with_reply_async_inner_block_invoke;
  handler[3] = &unk_1E1FCBB70;
  v14 = a4;
  handler[4] = v12;
  handler[5] = a1;
  handler[6] = a2;
  handler[7] = v11;
  handler[8] = uint64;
  v15 = v10;
  xpc_connection_send_message_with_reply(v11, a1, a2, handler);
}

size_t __handle_trust_evaluate_xpc_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  size_t result;
  const __CFArray *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFArray *v12;
  const __CFArray *v13;
  const __CFString *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const __CFString *v19;
  const __CFData *v20;

  result = SecXPCDictionarySetCertificates(a2, "certificates", *(const __CFArray **)(a1 + 32), a3);
  if ((_DWORD)result)
  {
    v7 = *(const __CFArray **)(a1 + 40);
    if (!v7 || (result = SecXPCDictionarySetCertificates(a2, "anchors", v7, a3), (_DWORD)result))
    {
      if (*(_BYTE *)(a1 + 112))
        xpc_dictionary_set_BOOL(a2, "anchorsOnly", 1);
      xpc_dictionary_set_BOOL(a2, "keychainsAllowed", *(_BYTE *)(a1 + 113));
      result = SecXPCDictionarySetPolicies(a2, *(const __CFArray **)(a1 + 48), a3);
      if ((_DWORD)result)
      {
        v12 = *(const __CFArray **)(a1 + 56);
        if (!v12 || (result = SecXPCDictionarySetDataArray(a2, "responses", v12, a3), (_DWORD)result))
        {
          v13 = *(const __CFArray **)(a1 + 64);
          if (!v13 || (result = SecXPCDictionarySetDataArray(a2, "scts", v13, a3), (_DWORD)result))
          {
            v14 = *(const __CFString **)(a1 + 72);
            if (!v14
              || (result = SecXPCDictionarySetPListWithRepair(a2, "trustedLogs", v14, a3, v8, v9, v10, v11),
                  (_DWORD)result))
            {
              xpc_dictionary_set_double(a2, "verifyDate", *(double *)(a1 + 80));
              v19 = *(const __CFString **)(a1 + 88);
              if (!v19
                || (result = SecXPCDictionarySetPListWithRepair(a2, "exceptions", v19, a3, v15, v16, v17, v18),
                    (_DWORD)result))
              {
                v20 = *(const __CFData **)(a1 + 96);
                if (!v20 || (result = SecXPCDictionarySetData(a2, "auditToken", v20, a3), (_DWORD)result))
                {
                  xpc_dictionary_set_uint64(a2, "attribution", *(_QWORD *)(a1 + 104));
                  return 1;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

size_t __handle_trust_evaluate_xpc_async_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  size_t result;
  const __CFArray *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFArray *v12;
  const __CFArray *v13;
  const __CFString *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const __CFString *v19;
  const __CFData *v20;

  result = SecXPCDictionarySetCertificates(a2, "certificates", *(const __CFArray **)(a1 + 32), a3);
  if ((_DWORD)result)
  {
    v7 = *(const __CFArray **)(a1 + 40);
    if (!v7 || (result = SecXPCDictionarySetCertificates(a2, "anchors", v7, a3), (_DWORD)result))
    {
      if (*(_BYTE *)(a1 + 112))
        xpc_dictionary_set_BOOL(a2, "anchorsOnly", 1);
      xpc_dictionary_set_BOOL(a2, "keychainsAllowed", *(_BYTE *)(a1 + 113));
      result = SecXPCDictionarySetPolicies(a2, *(const __CFArray **)(a1 + 48), a3);
      if ((_DWORD)result)
      {
        v12 = *(const __CFArray **)(a1 + 56);
        if (!v12 || (result = SecXPCDictionarySetDataArray(a2, "responses", v12, a3), (_DWORD)result))
        {
          v13 = *(const __CFArray **)(a1 + 64);
          if (!v13 || (result = SecXPCDictionarySetDataArray(a2, "scts", v13, a3), (_DWORD)result))
          {
            v14 = *(const __CFString **)(a1 + 72);
            if (!v14
              || (result = SecXPCDictionarySetPListWithRepair(a2, "trustedLogs", v14, a3, v8, v9, v10, v11),
                  (_DWORD)result))
            {
              xpc_dictionary_set_double(a2, "verifyDate", *(double *)(a1 + 80));
              v19 = *(const __CFString **)(a1 + 88);
              if (!v19
                || (result = SecXPCDictionarySetPListWithRepair(a2, "exceptions", v19, a3, v15, v16, v17, v18),
                    (_DWORD)result))
              {
                v20 = *(const __CFData **)(a1 + 96);
                if (!v20 || (result = SecXPCDictionarySetData(a2, "auditToken", v20, a3), (_DWORD)result))
                {
                  xpc_dictionary_set_uint64(a2, "attribution", *(_QWORD *)(a1 + 104));
                  return 1;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t SecXPCDictionarySetCertificates(void *a1, const char *a2, const __CFArray *a3, __CFString **a4)
{
  xpc_object_t v8;
  void *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  _QWORD *ValueAtIndex;
  const void *v14;
  int64_t v15;

  v8 = xpc_array_create(0, 0);
  if (v8)
  {
    v9 = v8;
    Count = CFArrayGetCount(a3);
    if (Count >= 1)
    {
      v11 = Count;
      for (i = 0; v11 != i; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a3, i);
        if (ValueAtIndex)
        {
          v14 = (const void *)ValueAtIndex[2];
          v15 = ValueAtIndex[3];
          if (v15 < 1 || v14 == 0)
          {
            xpc_release(v9);
            goto LABEL_13;
          }
          xpc_array_set_data(v9, 0xFFFFFFFFFFFFFFFFLL, v14, v15);
        }
      }
    }
    xpc_dictionary_set_value(a1, a2, v9);
    xpc_release(v9);
    return 1;
  }
  else
  {
LABEL_13:
    SecError(-108, a4, CFSTR("failed to create xpc_array of certificates"));
    return 0;
  }
}

uint64_t SecXPCDictionarySetPolicies(void *a1, const __CFArray *a2, __CFString **a3)
{
  xpc_object_t v6;
  void *v7;
  CFTypeID TypeID;
  CFIndex Count;
  __int128 v10;
  CFIndex v11;
  CFIndex v12;
  _QWORD *ValueAtIndex;
  _QWORD *v14;
  const void *v15;
  CFTypeID v16;
  const void *v17;
  CFTypeID v18;
  __CFString *MutableCopy;
  __CFString *v20;
  const void *v21;
  CFTypeID v22;
  NSObject *v23;
  const void *v24;
  CFTypeID v25;
  NSObject *v26;
  xpc_object_t v27;
  __int128 v29;
  uint8_t buf[4];
  _QWORD *v31;
  xpc_object_t objects;
  xpc_object_t object;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v6 = xpc_array_create(0, 0);
  if (v6)
  {
    v7 = v6;
    TypeID = SecPolicyGetTypeID();
    validate_array_of_items(a2, (uint64_t)CFSTR("policy"), TypeID, 1);
    Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      v11 = Count;
      v12 = 0;
      *(_QWORD *)&v10 = 134217984;
      v29 = v10;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a2, v12);
        if (!ValueAtIndex)
          goto LABEL_27;
        v14 = ValueAtIndex;
        objects = 0;
        object = 0;
        v15 = (const void *)ValueAtIndex[2];
        if (!v15)
        {
LABEL_14:
          v23 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = v29;
            v31 = v14;
            _os_log_impl(&dword_18A900000, v23, OS_LOG_TYPE_DEFAULT, "policy 0x%lX has no _oid", buf, 0xCu);
          }
          goto LABEL_16;
        }
        v16 = CFGetTypeID(v15);
        if (v16 == CFStringGetTypeID()
          && (v17 = (const void *)v14[3]) != 0
          && (v18 = CFGetTypeID(v17), v18 == CFStringGetTypeID()))
        {
          MutableCopy = CFStringCreateMutableCopy(0, 0, (CFStringRef)v14[2]);
          if (MutableCopy)
          {
            v20 = MutableCopy;
            CFStringAppend(MutableCopy, CFSTR("++"));
            CFStringAppend(v20, (CFStringRef)v14[3]);
            objects = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
            CFRelease(v20);
            goto LABEL_16;
          }
        }
        else
        {
          v21 = (const void *)v14[2];
          if (!v21)
            goto LABEL_14;
          v22 = CFGetTypeID(v21);
          if (v22 != CFStringGetTypeID())
            goto LABEL_14;
        }
        objects = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
LABEL_16:
        v24 = (const void *)v14[4];
        if (v24 && (v25 = CFGetTypeID(v24), v25 == CFDictionaryGetTypeID()))
        {
          object = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
        }
        else
        {
          v26 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = v29;
            v31 = v14;
            _os_log_impl(&dword_18A900000, v26, OS_LOG_TYPE_DEFAULT, "policy 0x%lX has no _options", buf, 0xCu);
          }
        }
        v27 = xpc_array_create(&objects, 2uLL);
        if (objects)
          xpc_release(objects);
        if (object)
          xpc_release(object);
        if (!v27)
        {
          xpc_release(v7);
          goto LABEL_30;
        }
        xpc_array_append_value(v7, v27);
        xpc_release(v27);
LABEL_27:
        ++v12;
      }
      while (v11 != v12);
    }
    xpc_dictionary_set_value(a1, "policies", v7);
    xpc_release(v7);
    return 1;
  }
  else
  {
LABEL_30:
    SecError(-108, a3, CFSTR("failed to create xpc_array of policies"), v29);
    return 0;
  }
}

uint64_t SecXPCDictionarySetDataArray(void *a1, const char *a2, const __CFArray *a3, __CFString **a4)
{
  xpc_object_t v8;
  void *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  const __CFData *ValueAtIndex;
  const __CFData *v14;
  CFIndex Length;
  const UInt8 *BytePtr;

  v8 = xpc_array_create(0, 0);
  if (v8)
  {
    v9 = v8;
    Count = CFArrayGetCount(a3);
    if (Count >= 1)
    {
      v11 = Count;
      for (i = 0; v11 != i; ++i)
      {
        ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(a3, i);
        if (ValueAtIndex)
        {
          v14 = ValueAtIndex;
          Length = CFDataGetLength(ValueAtIndex);
          BytePtr = CFDataGetBytePtr(v14);
          if (Length >= 1 && BytePtr)
          {
            xpc_array_set_data(v9, 0xFFFFFFFFFFFFFFFFLL, BytePtr, Length);
          }
          else if (!SecError(-50, a4, CFSTR("invalid CFDataRef")))
          {
            xpc_release(v9);
            return 0;
          }
        }
      }
    }
    xpc_dictionary_set_value(a1, a2, v9);
    xpc_release(v9);
    return 1;
  }
  else
  {
    SecError(-108, a4, CFSTR("failed to create xpc_array"));
    return 0;
  }
}

BOOL SecXPCDictionarySetData(void *a1, const char *a2, CFDataRef theData, __CFString **a4)
{
  const UInt8 *BytePtr;
  CFIndex Length;

  if (!theData)
    return SecError(-50, a4, CFSTR("data for key %s is NULL"), a2);
  if (CFDataGetLength(theData) < 0)
    return SecError(-50, a4, CFSTR("no data for key %s"), a2);
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  xpc_dictionary_set_data(a1, a2, BytePtr, Length);
  return 1;
}

BOOL __sec_protocol_options_get_quic_use_legacy_codepoint_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361) | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32);
    if ((v2 & 0x2000000000) != 0)
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (v2 & 0x1000000000) != 0;
  }
  return a2 != 0;
}

BOOL __sec_protocol_options_set_output_handler_access_block_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(a2 + 328) = _Block_copy(*(const void **)(a1 + 32));
  return a2 != 0;
}

BOOL SecAccessControlSetProtection(uint64_t a1, CFTypeRef cf, __CFString **a3)
{
  CFTypeID v6;
  uint64_t v7;
  CFTypeRef v8;
  _BOOL8 result;
  _QWORD v10[9];

  v10[8] = *MEMORY[0x1E0C80C00];
  if (cf)
  {
    v6 = CFGetTypeID(cf);
    if (v6 == CFDictionaryGetTypeID())
      goto LABEL_11;
  }
  v7 = 0;
  v10[0] = CFSTR("dk");
  v10[1] = CFSTR("ck");
  v10[2] = CFSTR("ak");
  v10[3] = CFSTR("dku");
  v10[4] = CFSTR("cku");
  v10[5] = CFSTR("aku");
  v10[6] = CFSTR("akpu");
  v10[7] = CFSTR("f");
  do
  {
    v8 = (CFTypeRef)v10[v7];
    if (cf && v8)
    {
      if (CFEqual(cf, v8))
        goto LABEL_11;
    }
    else if (v8 == cf)
    {
      goto LABEL_11;
    }
    ++v7;
  }
  while (v7 != 8);
  result = SecError(-50, a3, CFSTR("%@: %@"), CFSTR("SecAccessControl: invalid protection"), cf);
  if (result)
  {
LABEL_11:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("prot"), cf);
    return 1;
  }
  return result;
}

uint64_t SSLSetAllowAnonymousCiphers()
{
  return 0;
}

BOOL __sec_protocol_options_set_quic_use_legacy_codepoint_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = (v2 | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) & 0xFFFFFFCFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 36) | 0x2000000000;
    *(_DWORD *)(a2 + 361) = v2;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }
  return a2 != 0;
}

BOOL __sec_protocol_options_set_allow_unknown_alpn_protos_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = (v2 | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) & 0xFFFFFFF3FFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 34) | 0x800000000;
    *(_DWORD *)(a2 + 361) = v2;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }
  return a2 != 0;
}

void SecCmsMessageDestroy(uint64_t a1)
{
  int v1;
  BOOL v2;
  int v3;
  _QWORD *v5;

  v1 = *(_DWORD *)(a1 + 128);
  v2 = __OFSUB__(v1, 1);
  v3 = v1 - 1;
  if (v3 < 0 == v2)
  {
    *(_DWORD *)(a1 + 128) = v3;
    if (!v3)
    {
      SecCmsContentInfoDestroy((uint64_t *)a1);
      v5 = *(_QWORD **)(a1 + 120);
      if (v5)
        PORT_FreeArena(v5, 1);
    }
  }
}

void SecCmsContentInfoDestroy(uint64_t *a1)
{
  uint64_t OID;
  uint64_t v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  CCCryptorRef *v7;

  if (a1)
  {
    OID = a1[4];
    if (OID || (OID = SECOID_FindOID((uint64_t)a1), (a1[4] = OID) != 0))
    {
      switch(*(_DWORD *)(OID + 16))
      {
        case 0x1A:
          SecCmsSignedDataDestroy(a1[2]);
          break;
        case 0x1B:
          SecCmsEnvelopedDataDestroy(a1[2]);
          break;
        case 0x1D:
        case 0x1E:
          v3 = a1[2];
          if (v3)
            SecCmsContentInfoDestroy(v3);
          break;
        default:
          break;
      }
    }
    v4 = a1[13];
    if (v4)
    {
      SecCmsDigestContextCancel(v4);
      a1[13] = 0;
    }
    v5 = (const void *)a1[10];
    if (v5)
    {
      a1[10] = 0;
      CFRelease(v5);
    }
    v6 = (const void *)a1[14];
    if (v6)
    {
      a1[14] = 0;
      CFRelease(v6);
    }
    v7 = (CCCryptorRef *)a1[12];
    if (v7)
    {
      CCCryptorRelease(*v7);
      free(v7);
      a1[12] = 0;
    }
  }
}

uint64_t SecCmsSignedDataDestroy(uint64_t result)
{
  uint64_t v1;
  const void *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  _QWORD *v10;

  if (result)
  {
    v1 = result;
    v2 = *(const void **)(result + 176);
    if (v2)
    {
      *(_QWORD *)(v1 + 176) = 0;
      CFRelease(v2);
    }
    v3 = *(_QWORD **)(v1 + 160);
    if (v3)
    {
      v4 = (_QWORD *)*v3;
      if (*v3)
      {
        v5 = v3 + 1;
        do
        {
          v6 = (const void *)v4[17];
          if (v6)
            CFRelease(v6);
          v7 = (const void *)v4[18];
          if (v7)
          {
            v4[18] = 0;
            CFRelease(v7);
          }
          v8 = (const void *)v4[23];
          if (v8)
          {
            v4[23] = 0;
            CFRelease(v8);
          }
          v9 = (const void *)v4[24];
          if (v9)
          {
            v4[24] = 0;
            CFRelease(v9);
          }
          v10 = (_QWORD *)*v5++;
          v4 = v10;
        }
        while (v10);
      }
    }
    return SecCmsContentInfoDestroy(v1);
  }
  return result;
}

SecKeyRef SecTrustCopyKey(SecTrustRef trust)
{
  NSObject *v2;
  uint64_t v3;
  __SecKey *v4;
  NSObject *v5;
  _QWORD v7[6];
  _QWORD block[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  if (!trust)
    return 0;
  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v2 = *((_QWORD *)trust + 17);
  v3 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustCopyKey_block_invoke;
  block[3] = &unk_1E1FDA890;
  block[4] = &v9;
  block[5] = trust;
  dispatch_sync(v2, block);
  v4 = (__SecKey *)v10[3];
  if (!v4)
  {
    SecTrustEvaluateIfNecessary(trust);
    v5 = *((_QWORD *)trust + 17);
    v7[0] = v3;
    v7[1] = 0x40000000;
    v7[2] = __SecTrustCopyKey_block_invoke_2;
    v7[3] = &unk_1E1FDA8B8;
    v7[4] = &v9;
    v7[5] = trust;
    dispatch_sync(v5, v7);
    v4 = (__SecKey *)v10[3];
  }
  _Block_object_dispose(&v9, 8);
  return v4;
}

BOOL __sec_protocol_options_set_tls_certificate_compression_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361) | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32) | 0x40000000;
    *(_DWORD *)(a2 + 361) |= 0x40000000u;
    v3 = v2 & 0xFFDFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 29);
    *(_DWORD *)(a2 + 361) = v3;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }
  return a2 != 0;
}

uint64_t SSLSetInternalRecordLayerProtocolVersion()
{
  return tls_record_set_protocol_version();
}

BOOL __sec_protocol_options_set_quic_transport_parameters_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v4;

  if (a2)
  {
    v4 = *(NSObject **)(a2 + 136);
    if (v4)
      dispatch_release(v4);
    *(_QWORD *)(a2 + 136) = *(_QWORD *)(a1 + 32);
    dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  }
  return a2 != 0;
}

void SecPolicySetName(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  if (a1 && cf)
  {
    v4 = *(const void **)(a1 + 24);
    CFRetain(cf);
    *(_QWORD *)(a1 + 24) = cf;
    if (v4)
      CFRelease(v4);
  }
}

BOOL __sec_protocol_options_set_tls_encryption_secret_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  NSObject *v5;
  void *v6;
  NSObject *v7;

  if (a2)
  {
    v4 = *(const void **)(a2 + 144);
    if (v4)
      _Block_release(v4);
    v5 = *(NSObject **)(a2 + 152);
    if (v5)
      dispatch_release(v5);
    v6 = _Block_copy(*(const void **)(a1 + 32));
    v7 = *(NSObject **)(a1 + 40);
    *(_QWORD *)(a2 + 144) = v6;
    *(_QWORD *)(a2 + 152) = v7;
    dispatch_retain(v7);
  }
  return a2 != 0;
}

BOOL __sec_protocol_options_set_tls_encryption_level_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  NSObject *v5;
  void *v6;
  NSObject *v7;

  if (a2)
  {
    v4 = *(const void **)(a2 + 160);
    if (v4)
      _Block_release(v4);
    v5 = *(NSObject **)(a2 + 168);
    if (v5)
      dispatch_release(v5);
    v6 = _Block_copy(*(const void **)(a1 + 32));
    v7 = *(NSObject **)(a1 + 40);
    *(_QWORD *)(a2 + 160) = v6;
    *(_QWORD *)(a2 + 168) = v7;
    dispatch_retain(v7);
  }
  return a2 != 0;
}

BOOL __sec_protocol_options_set_session_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  NSObject *v5;
  void *v6;
  NSObject *v7;

  if (a2)
  {
    v4 = *(const void **)(a2 + 176);
    if (v4)
      _Block_release(v4);
    v5 = *(NSObject **)(a2 + 184);
    if (v5)
      dispatch_release(v5);
    v6 = _Block_copy(*(const void **)(a1 + 32));
    v7 = *(NSObject **)(a1 + 40);
    *(_QWORD *)(a2 + 176) = v6;
    *(_QWORD *)(a2 + 184) = v7;
    dispatch_retain(v7);
  }
  return a2 != 0;
}

OSStatus SecTrustSetOCSPResponse(SecTrustRef trust, CFTypeRef responseData)
{
  uint64_t v4;
  NSObject *v5;
  CFTypeID v6;
  uint64_t Count;
  const __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v11;
  CFTypeID v12;
  NSObject *v13;
  const void *v14;
  OSStatus v15;
  CFTypeID v16;
  CFArrayRef v17;
  NSObject *v18;
  NSObject *v19;
  _QWORD v21[6];
  uint8_t buf[16];
  void *values;
  uint64_t block;
  uint64_t p_block;
  uint64_t v26;
  void *v27;
  SecTrustRef v28;

  values = (void *)responseData;
  if (trust)
  {
    v4 = MEMORY[0x1E0C809B0];
    v5 = *((_QWORD *)trust + 17);
    block = MEMORY[0x1E0C809B0];
    p_block = 0x40000000;
    v26 = (uint64_t)__SecTrustSetNeedsEvaluation_block_invoke;
    v27 = &__block_descriptor_tmp_49_11514;
    v28 = trust;
    dispatch_sync(v5, &block);
    block = 0;
    p_block = (uint64_t)&block;
    v26 = 0x2000000000;
    v27 = 0;
    if (responseData)
    {
      v6 = CFGetTypeID(responseData);
      if (v6 == CFArrayGetTypeID())
      {
        Count = CFArrayGetCount((CFArrayRef)responseData);
        Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E0C9B378]);
        *(_QWORD *)(p_block + 24) = Mutable;
        if (!Mutable)
        {
          v15 = -108;
          goto LABEL_25;
        }
        if (Count >= 1)
        {
          for (i = 0; i != Count; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)responseData, i);
            if (ValueAtIndex && (v11 = ValueAtIndex, v12 = CFGetTypeID(ValueAtIndex), v12 == CFDataGetTypeID()))
            {
              CFArrayAppendValue(*(CFMutableArrayRef *)(p_block + 24), v11);
            }
            else
            {
              v13 = secLogObjForScope("SecError");
              if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: responseData array contains non-data value", buf, 2u);
              }
            }
          }
          Mutable = *(const __CFArray **)(p_block + 24);
          v4 = MEMORY[0x1E0C809B0];
        }
        if (Count != CFArrayGetCount(Mutable))
        {
          v14 = *(const void **)(p_block + 24);
          if (v14)
            CFRelease(v14);
LABEL_23:
          v15 = -50;
          goto LABEL_25;
        }
      }
      else
      {
        v16 = CFGetTypeID(responseData);
        if (v16 != CFDataGetTypeID())
        {
          v19 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: responseData contains unsupported value type", buf, 2u);
          }
          goto LABEL_23;
        }
        v17 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
        *(_QWORD *)(p_block + 24) = v17;
      }
    }
    v18 = *((_QWORD *)trust + 17);
    v21[0] = v4;
    v21[1] = 0x40000000;
    v21[2] = __SecTrustSetOCSPResponse_block_invoke;
    v21[3] = &unk_1E1FDA098;
    v21[4] = &block;
    v21[5] = trust;
    dispatch_sync(v18, v21);
    v15 = 0;
LABEL_25:
    _Block_object_dispose(&block, 8);
    return v15;
  }
  return -50;
}

uint64_t SecTrustReportNetworkingAnalytics(char *cStr, uint64_t a2)
{
  uint64_t v2;
  CFStringRef v4;
  CFStringRef v5;
  uint64_t (*v6)(CFStringRef, uint64_t, CFErrorRef *);
  NSObject *v7;
  int Code;
  CFErrorRef v9;
  NSObject *v10;
  NSObject *v11;
  int v12;
  CFErrorRef v13;
  NSObject *v14;
  _QWORD v16[5];
  _QWORD v17[6];
  os_activity_scope_state_s state;
  CFErrorRef err;
  uint8_t v20[4];
  int v21;
  uint8_t buf[8];
  uint8_t *v23;
  uint64_t v24;
  char v25;
  uint64_t v26;

  v2 = 0;
  v26 = *MEMORY[0x1E0C80C00];
  if (cStr && a2)
  {
    v4 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x8000100u);
    if (v4)
    {
      v5 = v4;
      err = 0;
      if (gTrustd && (v6 = *(uint64_t (**)(CFStringRef, uint64_t, CFErrorRef *))(gTrustd + 144)) != 0)
      {
        v2 = v6(v4, a2, &err);
        if (err)
        {
          v7 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            Code = CFErrorGetCode(err);
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)&buf[4] = Code;
            _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "SecTrustReportNetworkingAnalytics failed with error: %d", buf, 8u);
          }
        }
        CFRelease(v5);
        v9 = err;
        if (err)
        {
          err = 0;
          CFRelease(v9);
        }
      }
      else
      {
        v10 = _os_activity_create(&dword_18A900000, "SecTrustReportNetworkingAnalytics", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
        state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
        state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
        os_activity_scope_enter(v10, &state);
        *(_QWORD *)buf = 0;
        v23 = buf;
        v24 = 0x2000000000;
        v25 = 0;
        v16[4] = buf;
        v17[0] = MEMORY[0x1E0C809B0];
        v17[1] = 0x40000000;
        v17[2] = __SecTrustReportNetworkingAnalytics_block_invoke;
        v17[3] = &__block_descriptor_tmp_263;
        v17[4] = v5;
        v17[5] = a2;
        v16[0] = MEMORY[0x1E0C809B0];
        v16[1] = 0x40000000;
        v16[2] = __SecTrustReportNetworkingAnalytics_block_invoke_2;
        v16[3] = &unk_1E1FDAC78;
        securityd_send_sync_and_do(0x73u, (CFTypeRef *)&err, (uint64_t)v17, (uint64_t)v16);
        if (err)
        {
          v11 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            v12 = CFErrorGetCode(err);
            *(_DWORD *)v20 = 67109120;
            v21 = v12;
            _os_log_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEFAULT, "SecTrustReportNetworkingAnalytics failed with error: %d", v20, 8u);
          }
          v13 = err;
          if (err)
          {
            err = 0;
            CFRelease(v13);
          }
        }
        CFRelease(v5);
        os_release(v10);
        v2 = v23[24] != 0;
        _Block_object_dispose(buf, 8);
        os_activity_scope_leave(&state);
      }
    }
    else
    {
      v14 = secLogObjForScope("SecError");
      v2 = 0;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEFAULT, "CFStringCreateWithCString failed", buf, 2u);
        return 0;
      }
    }
  }
  return v2;
}

BOOL __sec_protocol_options_copy_transport_specific_application_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v2;
  size_t count;
  size_t v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  xpc_object_t value;
  uint64_t uint64;
  uint64_t v11;
  void *v12;
  const char *string_ptr;

  if (!a2)
    return 0;
  v2 = *(void **)(a2 + 48);
  if (!v2)
    return 0;
  count = xpc_array_get_count(*(xpc_object_t *)(a2 + 48));
  if (count)
  {
    v5 = count;
    v6 = 0;
    v7 = MEMORY[0x1E0C81390];
    v8 = MEMORY[0x1E0C812C8];
    do
    {
      value = xpc_array_get_value(v2, v6);
      if (MEMORY[0x18D7718B8]() == v7)
      {
        v12 = *(void **)(a1 + 32);
        string_ptr = xpc_string_get_string_ptr(value);
      }
      else
      {
        if (MEMORY[0x18D7718B8](value) != v8)
          goto LABEL_12;
        uint64 = xpc_array_get_uint64(value, 1uLL);
        v11 = *(unsigned int *)(a1 + 40);
        if ((_DWORD)v11)
        {
          if (uint64 != v11)
            goto LABEL_12;
        }
        v12 = *(void **)(a1 + 32);
        string_ptr = xpc_array_get_string(value, 0);
      }
      xpc_array_set_string(v12, 0xFFFFFFFFFFFFFFFFLL, string_ptr);
LABEL_12:
      ++v6;
    }
    while (v5 != v6);
  }
  return xpc_array_get_count(*(xpc_object_t *)(a1 + 32)) != 0;
}

uint64_t __getLastErrorKey_block_invoke()
{
  uint64_t result;

  result = pthread_key_create((pthread_key_t *)&getLastErrorKey_key, (void (__cdecl *)(void *))lastErrorReleaseError);
  if (!(_DWORD)result)
    getLastErrorKey_haveKey = 1;
  return result;
}

uint64_t SSLInitInternalRecordLayerPendingCiphers()
{
  return tls_record_init_pending_ciphers();
}

uint64_t SSLAdvanceInternalRecordLayerWriteCipher()
{
  return tls_record_advance_write_cipher();
}

uint64_t tls_handshake_set_protocol_version_callback(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 88) = a2;
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 40) + 48))(*(_QWORD *)(a1 + 48));
}

void sub_18A932410(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id KCSharingSetupServerProtocol(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  _QWORD v7[12];

  v7[11] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  +[SecXPCHelper safeErrorClasses](SecXPCHelper, "safeErrorClasses");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (void *)MEMORY[0x1E0C99E60];
  v7[0] = objc_opt_class();
  v7[1] = objc_opt_class();
  v7[2] = objc_opt_class();
  v7[3] = objc_opt_class();
  v7[4] = objc_opt_class();
  v7[5] = objc_opt_class();
  v7[6] = objc_opt_class();
  v7[7] = objc_opt_class();
  v7[8] = objc_opt_class();
  v7[9] = objc_opt_class();
  v7[10] = objc_opt_class();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v7, 11);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setWithArray:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_provisionWithReply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_setChangeTrackingEnabled_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchRemoteChangesWithReply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_saveLocalChangesWithReply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_getGroupByGroupID_completion_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_wipe_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v5, sel_getGroupsWithRequest_completion_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_getGroupsWithRequest_completion_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v5, sel_createGroupWithRequest_completion_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_createGroupWithRequest_completion_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v5, sel_updateGroupWithRequest_completion_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_updateGroupWithRequest_completion_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v5, sel_leaveGroupWithRequest_completion_, 0, 0);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_leaveGroupWithRequest_completion_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v5, sel_deleteGroupWithRequest_completion_, 0, 0);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_deleteGroupWithRequest_completion_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_acceptInviteForGroupID_completion_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_declineInviteForGroupID_completion_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v5, sel_checkAvailabilityForHandles_completion_, 0, 0);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v5, sel_checkAvailabilityForHandles_completion_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_checkAvailabilityForHandles_completion_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_verifyGroupsInSyncWithCompletion_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_performMaintenanceWithCompletion_, 0, 1);

  return v1;
}

void sub_18A932D24(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

SecKeyRef SecKeyCreateWithData(CFDataRef keyData, CFDictionaryRef attributes, CFErrorRef *error)
{
  void *v6;
  NSObject *v7;
  uint64_t v8;
  const void *Value;
  __SecKey *CTKKey;
  NSObject *v11;
  CFErrorRef v12;
  void *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  int v17;
  const UInt8 *v18;
  CFIndex v19;
  const UInt8 *v20;
  CFIndex v21;
  const UInt8 *v23;
  CFIndex v24;
  void *v25;
  const UInt8 *v26;
  CFIndex v27;
  CFErrorRef v28;
  const char *v29;
  NSObject *v30;
  uint32_t v31;
  const UInt8 *v32;
  CFIndex v33;
  const UInt8 *v34;
  CFIndex v35;
  const UInt8 *v36;
  CFIndex v37;
  const UInt8 *v38;
  CFIndex v39;
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v42;
  CFIndex v43;
  const UInt8 *v44;
  CFIndex v45;
  const UInt8 *v46;
  CFIndex v47;
  const UInt8 *v48;
  CFIndex v49;
  const UInt8 *v50;
  CFIndex v51;
  os_activity_scope_state_s state;
  uint8_t buf[4];
  _BYTE v54[10];
  _WORD v55[9];

  *(_QWORD *)&v55[5] = *MEMORY[0x1E0C80C00];
  v6 = (void *)MEMORY[0x18D770A24]();
  v7 = _os_activity_create(&dword_18A900000, "SecKeyCreateWithData", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v8 = SecCFAllocatorZeroize_sAllocator;
  Value = CFDictionaryGetValue(attributes, CFSTR("tkid"));
  if (!Value)
  {
    if (!keyData)
    {
      SecError(-50, (__CFString **)error, CFSTR("Failed to provide key data to SecKeyCreateWithData"));
LABEL_27:
      CTKKey = 0;
      goto LABEL_28;
    }
    v13 = (void *)CFDictionaryGetValue(attributes, CFSTR("type"));
    v14 = SecKeyParamsAsInt64(v13, (uint64_t)CFSTR("key type"), (__CFString **)error);
    if ((v14 & 0x8000000000000000) == 0)
    {
      v15 = (void *)CFDictionaryGetValue(attributes, CFSTR("kcls"));
      v16 = SecKeyParamsAsInt64(v15, (uint64_t)CFSTR("key class"), (__CFString **)error);
      v17 = v16;
      if (v16 < 0)
        goto LABEL_25;
      if (v16 == 2)
      {
        SecError(-4, (__CFString **)error, CFSTR("Unsupported symmetric key type: %@"), v13);
        goto LABEL_25;
      }
      if (v16 == 1)
      {
        if (v14 <= 104)
        {
          if (v14 == 42)
          {
            BytePtr = CFDataGetBytePtr(keyData);
            Length = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecRSAPrivateKeyDescriptor, (uint64_t)BytePtr, Length, 7);
            if (CTKKey)
              goto LABEL_28;
            SecError(-50, (__CFString **)error, CFSTR("RSA private key creation from data failed"));
          }
          else if (v14 == 43 || v14 == 73)
          {
            v23 = CFDataGetBytePtr(keyData);
            v24 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecECPrivateKeyDescriptor, (uint64_t)v23, v24, 7);
            if (CTKKey)
              goto LABEL_28;
            SecError(-50, (__CFString **)error, CFSTR("EC private key creation from data failed"));
          }
          else
          {
LABEL_56:
            SecError(-50, (__CFString **)error, CFSTR("Unsupported private key type: %@"), v13);
          }
        }
        else
        {
          switch(v14)
          {
            case 'i':
              v20 = CFDataGetBytePtr(keyData);
              v21 = CFDataGetLength(keyData);
              CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecEd25519PrivateKeyDescriptor, (uint64_t)v20, v21, 7);
              if (CTKKey)
                goto LABEL_28;
              SecError(-50, (__CFString **)error, CFSTR("Ed25519 private key creation from data failed"));
              break;
            case 'j':
              v32 = CFDataGetBytePtr(keyData);
              v33 = CFDataGetLength(keyData);
              CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecX25519PrivateKeyDescriptor, (uint64_t)v32, v33, 7);
              if (CTKKey)
                goto LABEL_28;
              SecError(-50, (__CFString **)error, CFSTR("X25519 private key creation from data failed"));
              break;
            case 'k':
              v34 = CFDataGetBytePtr(keyData);
              v35 = CFDataGetLength(keyData);
              CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecEd448PrivateKeyDescriptor, (uint64_t)v34, v35, 7);
              if (CTKKey)
                goto LABEL_28;
              SecError(-50, (__CFString **)error, CFSTR("Ed448 private key creation from data failed"));
              break;
            case 'l':
              v36 = CFDataGetBytePtr(keyData);
              v37 = CFDataGetLength(keyData);
              CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecX448PrivateKeyDescriptor, (uint64_t)v36, v37, 7);
              if (CTKKey)
                goto LABEL_28;
              SecError(-50, (__CFString **)error, CFSTR("X448 private key creation from data failed"));
              break;
            case 'm':
              v38 = CFDataGetBytePtr(keyData);
              v39 = CFDataGetLength(keyData);
              CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecKyberPrivateKeyDescriptor, (uint64_t)v38, v39, 0);
              if (CTKKey)
                goto LABEL_28;
              SecError(-50, (__CFString **)error, CFSTR("Kyber public key creation from data failed"));
              break;
            default:
              goto LABEL_56;
          }
        }
        v17 = 1;
LABEL_25:
        _SECKEY_LOG_9290();
        v11 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          if (error)
            v28 = *error;
          else
            v28 = 0;
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)v54 = v14;
          *(_WORD *)&v54[4] = 1024;
          *(_DWORD *)&v54[6] = v17;
          v55[0] = 2114;
          *(_QWORD *)&v55[1] = v28;
          v29 = "Failed to create key from data, algorithm:%d, class:%d: %{public}@";
          v30 = v11;
          v31 = 24;
          goto LABEL_60;
        }
LABEL_26:

        goto LABEL_27;
      }
      if (v16)
      {
        SecError(-50, (__CFString **)error, CFSTR("Unsupported key class: %@"), v15);
        goto LABEL_25;
      }
      if (v14 <= 104)
      {
        if (v14 == 42)
        {
          v50 = CFDataGetBytePtr(keyData);
          v51 = CFDataGetLength(keyData);
          CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecRSAPublicKeyDescriptor, (uint64_t)v50, v51, 7);
          if (CTKKey)
            goto LABEL_28;
          SecError(-50, (__CFString **)error, CFSTR("RSA public key creation from data failed"));
        }
        else if (v14 == 43 || v14 == 73)
        {
LABEL_39:
          v26 = CFDataGetBytePtr(keyData);
          v27 = CFDataGetLength(keyData);
          CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecECPublicKeyDescriptor, (uint64_t)v26, v27, 7);
          if (CTKKey)
            goto LABEL_28;
          SecError(-50, (__CFString **)error, CFSTR("EC public key creation from data failed"));
        }
        else
        {
LABEL_37:
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v14);
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          SecError(-50, (__CFString **)error, CFSTR("Unsupported public key type: %@ (algorithm: %@)"), v13, v25);

        }
      }
      else
      {
        switch(v14)
        {
          case 'i':
            v18 = CFDataGetBytePtr(keyData);
            v19 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecEd25519PublicKeyDescriptor, (uint64_t)v18, v19, 7);
            if (CTKKey)
              goto LABEL_28;
            SecError(-50, (__CFString **)error, CFSTR("Ed25519 public key creation from data failed"));
            break;
          case 'j':
            v42 = CFDataGetBytePtr(keyData);
            v43 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecX25519PublicKeyDescriptor, (uint64_t)v42, v43, 7);
            if (CTKKey)
              goto LABEL_28;
            SecError(-50, (__CFString **)error, CFSTR("X25519 public key creation from data failed"));
            break;
          case 'k':
            v44 = CFDataGetBytePtr(keyData);
            v45 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecEd448PublicKeyDescriptor, (uint64_t)v44, v45, 7);
            if (CTKKey)
              goto LABEL_28;
            SecError(-50, (__CFString **)error, CFSTR("Ed448 public key creation from data failed"));
            break;
          case 'l':
            v46 = CFDataGetBytePtr(keyData);
            v47 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecX448PublicKeyDescriptor, (uint64_t)v46, v47, 7);
            if (CTKKey)
              goto LABEL_28;
            SecError(-50, (__CFString **)error, CFSTR("X448 public key creation from data failed"));
            break;
          case 'm':
            v48 = CFDataGetBytePtr(keyData);
            v49 = CFDataGetLength(keyData);
            CTKKey = (__SecKey *)SecKeyCreate(v8, (uint64_t)&kSecKyberPublicKeyDescriptor, (uint64_t)v48, v49, 0);
            if (CTKKey)
              goto LABEL_28;
            SecError(-50, (__CFString **)error, CFSTR("Kyber public key creation from data failed"));
            break;
          default:
            if ((unint64_t)(v14 - 2147483678) < 3)
              goto LABEL_39;
            goto LABEL_37;
        }
      }
    }
    v17 = 0;
    goto LABEL_25;
  }
  CTKKey = (__SecKey *)SecKeyCreateCTKKey(v8, (uint64_t)attributes, error);
  if (!CTKKey)
  {
    _SECKEY_LOG_9290();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      if (error)
        v12 = *error;
      else
        v12 = 0;
      *(_DWORD *)buf = 138543618;
      *(_QWORD *)v54 = Value;
      *(_WORD *)&v54[8] = 2114;
      *(_QWORD *)v55 = v12;
      v29 = "Failed to create key for tokenID=%{public}@: %{public}@";
      v30 = v11;
      v31 = 22;
LABEL_60:
      _os_log_debug_impl(&dword_18A900000, v30, OS_LOG_TYPE_DEBUG, v29, buf, v31);
      goto LABEL_26;
    }
    goto LABEL_26;
  }
LABEL_28:
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v6);
  return CTKKey;
}

void sub_18A934D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t SecKeyParamsAsInt64(void *a1, uint64_t a2, __CFString **a3)
{
  uint64_t v6;
  void *v7;
  char v8;
  void *v9;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      return objc_msgSend(a1, "longLongValue");
    SecError(-50, a3, CFSTR("Unsupported %@: %@"), a2, a1);
    return -1;
  }
  v6 = objc_msgSend(a1, "longLongValue");
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%lld"), v6);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = objc_msgSend(v7, "isEqualToString:", a1);

  if ((v8 & 1) == 0)
  {
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", v6);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    SecError(-50, a3, CFSTR("Unsupported %@: %@ (converted value: %@"), a2, a1, v9);

    return -1;
  }
  return v6;
}

OSStatus SSLGetPeerID(SSLContextRef context, const void **peerID, size_t *peerIDLen)
{
  size_t v3;

  v3 = *((_QWORD *)context + 26);
  *peerID = (const void *)*((_QWORD *)context + 27);
  *peerIDLen = v3;
  return 0;
}

const void **Security::CodeSigning::BundleDiskRep::setup(uint64_t a1, uint64_t a2)
{
  const __CFURL *v4;
  std::string::size_type size;
  void **v6;
  std::string *v7;
  std::string::size_type v8;
  void **v9;
  std::string *v10;
  std::string::size_type v11;
  std::string *v12;
  std::string *v13;
  const char *v14;
  std::string::size_type v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  void **v19;
  void **v20;
  const __CFURL *v21;
  char v22;
  std::string *v23;
  uint64_t Unique;
  const void *v25;
  std::string::size_type v26;
  std::string *v27;
  std::string *v28;
  std::string *v29;
  ssize_t v30;
  std::string *v31;
  std::string::size_type v32;
  std::string *v33;
  __int128 v34;
  std::string *v35;
  std::string::size_type v36;
  char v37;
  std::string::size_type v38;
  std::string *p_p;
  std::string::size_type v40;
  std::string *v41;
  __int128 v42;
  std::string *v43;
  std::string::size_type v44;
  std::string::value_type *v45;
  int v46;
  const __CFDictionary *InfoDictionary;
  const __CFString *Value;
  const void *v49;
  const __CFURL *v50;
  const __CFURL *v51;
  char *v52;
  uint64_t v53;
  _QWORD *v54;
  Security::UnixPlusPlus::FileDesc *v55;
  const __CFDictionary *v56;
  const void *v57;
  _BOOL4 v58;
  CFTypeID v59;
  CFURLRef v60;
  const __CFURL *v61;
  Security *v62;
  CFURLRef CFURL;
  const void *v64;
  Security::CodeSigning::FileDiskRep *v65;
  char *v66;
  Security::UnixPlusPlus::FileDesc *v67;
  char *v68;
  std::string *v69;
  std::string::size_type v70;
  char v71;
  void **v72;
  std::string::size_type v73;
  Security::CodeSigning::FileDiskRep *v74;
  char *v75;
  Security::UnixPlusPlus::FileDesc *v76;
  std::string *v77;
  std::string *v79;
  FTS *v80;
  char v81;
  char v82;
  FTSENT *v83;
  int fts_info;
  const std::string::value_type *fts_path;
  uint64_t v87;
  const __CFURL *v88;
  uint64_t v89;
  Security *v90;
  CFURLRef v91;
  const void *v92;
  Security::CodeSigning::FileDiskRep *v93;
  std::string *v94;
  Security::UnixPlusPlus::FileDesc *v95;
  char *v96;
  std::string v97;
  std::string v98;
  std::string __sz;
  void *v100[3];
  void *v101[3];
  std::string v102;
  __CFURL *v103;
  __CFURL *v104;
  std::string v105;
  std::string v106;
  _DWORD v107[2];
  std::string v108;
  unint64_t v109;
  std::string v110;
  std::string __p;
  void *v112[2];
  char v113;
  std::string v114;
  void *v115;
  std::string v116;
  _BYTE __b[1024];
  std::string v118;
  void *v119;
  std::string v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  *(_BYTE *)(a1 + 177) = 0;
  *(_WORD *)(a1 + 72) = 0;
  v104 = CFBundleCopyExecutableURL(*(CFBundleRef *)(a1 + 24));
  v103 = (__CFURL *)_CFBundleCopyInfoPlistURL();
  memset(&v102, 170, sizeof(v102));
  v4 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
  Security::cfStringRelease((Security *)&v102, v4);
  if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v102.__r_.__value_.__r.__words[2]);
  else
    size = v102.__r_.__value_.__l.__size_;
  memset(v101, 170, sizeof(v101));
  v6 = v101;
  std::string::basic_string[abi:ne180100]((uint64_t)v101, size + 9);
  if (SHIBYTE(v101[2]) < 0)
    v6 = (void **)v101[0];
  if (size)
  {
    if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v7 = &v102;
    else
      v7 = (std::string *)v102.__r_.__value_.__r.__words[0];
    memmove(v6, v7, size);
  }
  strcpy((char *)v6 + size, "/Contents");
  if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v8 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
  else
    v8 = v102.__r_.__value_.__l.__size_;
  memset(v100, 170, sizeof(v100));
  v9 = v100;
  std::string::basic_string[abi:ne180100]((uint64_t)v100, v8 + 14);
  if (SHIBYTE(v100[2]) < 0)
    v9 = (void **)v100[0];
  if (v8)
  {
    if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v10 = &v102;
    else
      v10 = (std::string *)v102.__r_.__value_.__r.__words[0];
    memmove(v9, v10, v8);
  }
  strcpy((char *)v9 + v8, "/Support Files");
  if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = HIBYTE(v102.__r_.__value_.__r.__words[2]);
  else
    v11 = v102.__r_.__value_.__l.__size_;
  memset(&v118, 170, sizeof(v118));
  v12 = &v118;
  std::string::basic_string[abi:ne180100]((uint64_t)&v118, v11 + 10);
  if ((v118.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v12 = (std::string *)v118.__r_.__value_.__r.__words[0];
  if (v11)
  {
    if ((v102.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v13 = &v102;
    else
      v13 = (std::string *)v102.__r_.__value_.__r.__words[0];
    memmove(v12, v13, v11);
  }
  strcpy((char *)v12 + v11, "/Versions/");
  v14 = "Current";
  if (a2 && *(_QWORD *)(a2 + 8))
    v14 = *(const char **)(a2 + 8);
  v15 = strlen(v14);
  v16 = std::string::append(&v118, v14, v15);
  v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  *(_QWORD *)&__b[16] = *((_QWORD *)&v16->__r_.__value_.__l + 2);
  *(_OWORD *)__b = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  v18 = std::string::append((std::string *)__b, "/.", 2uLL);
  __sz = *v18;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if ((__b[23] & 0x80000000) != 0)
    operator delete(*(void **)__b);
  if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v118.__r_.__value_.__l.__data_);
  if (SHIBYTE(v101[2]) >= 0)
    v19 = v101;
  else
    v19 = (void **)v101[0];
  if (access((const char *)v19, 0))
  {
    if (SHIBYTE(v100[2]) >= 0)
      v20 = v100;
    else
      v20 = (void **)v100[0];
    if (!access((const char *)v20, 0))
    {
LABEL_147:
      v22 = 0;
      goto LABEL_148;
    }
    if (SHIBYTE(__sz.__r_.__value_.__r.__words[2]) < 0)
    {
      if (!access(__sz.__r_.__value_.__l.__data_, 0))
      {
        std::string::__init_copy_ctor_external(&v98, __sz.__r_.__value_.__l.__data_, __sz.__r_.__value_.__l.__size_);
        goto LABEL_59;
      }
    }
    else if (!access((const char *)&__sz, 0))
    {
      v98 = __sz;
LABEL_59:
      if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v23 = &v98;
      else
        v23 = (std::string *)v98.__r_.__value_.__r.__words[0];
      *(_QWORD *)__b = Security::makeCFURL((Security *)v23, 0, 0, v21);
      Unique = _CFBundleCreateUnique();
      Security::CFRef<__CFURL const*>::~CFRef((const void **)__b);
      if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v98.__r_.__value_.__l.__data_);
      if (!Unique)
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA04);
      v25 = *(const void **)(a1 + 24);
      if (v25)
        CFRelease(v25);
      *(_QWORD *)(a1 + 24) = Unique;
      if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v97, v102.__r_.__value_.__l.__data_, v102.__r_.__value_.__l.__size_);
      else
        v97 = v102;
      memset(&__p, 170, sizeof(__p));
      std::string::basic_string[abi:ne180100]<0>(&__p, "Current");
      memset(__b, 170, sizeof(__b));
      if ((v97.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v26 = HIBYTE(v97.__r_.__value_.__r.__words[2]);
      else
        v26 = v97.__r_.__value_.__l.__size_;
      memset(&v118, 170, sizeof(v118));
      v27 = &v118;
      std::string::basic_string[abi:ne180100]((uint64_t)&v118, v26 + 17);
      if ((v118.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v27 = (std::string *)v118.__r_.__value_.__r.__words[0];
      if (v26)
      {
        if ((v97.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v28 = &v97;
        else
          v28 = (std::string *)v97.__r_.__value_.__r.__words[0];
        memmove(v27, v28, v26);
      }
      strcpy((char *)v27 + v26, "/Versions/Current");
      if ((v118.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v29 = &v118;
      else
        v29 = (std::string *)v118.__r_.__value_.__r.__words[0];
      v30 = readlink((const char *)v29, __b, 0x3FFuLL);
      if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v118.__r_.__value_.__l.__data_);
      if (v30 >= 1)
      {
        __b[v30] = 0;
        std::string::basic_string[abi:ne180100]<0>(&v114, "(Current|");
        std::string::basic_string[abi:ne180100]<0>(&v110, __b);
        Security::CodeSigning::ResourceBuilder::escapeRE(&v108, (std::string::value_type *)&v110);
        if ((v108.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v31 = &v108;
        else
          v31 = (std::string *)v108.__r_.__value_.__r.__words[0];
        if ((v108.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v32 = HIBYTE(v108.__r_.__value_.__r.__words[2]);
        else
          v32 = v108.__r_.__value_.__l.__size_;
        v33 = std::string::append(&v114, (const std::string::value_type *)v31, v32);
        v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
        v118.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v118.__r_.__value_.__l.__data_ = v34;
        v33->__r_.__value_.__l.__size_ = 0;
        v33->__r_.__value_.__r.__words[2] = 0;
        v33->__r_.__value_.__r.__words[0] = 0;
        v35 = std::string::append(&v118, ")", 1uLL);
        v36 = v35->__r_.__value_.__r.__words[0];
        v112[0] = (void *)v35->__r_.__value_.__l.__size_;
        *(void **)((char *)v112 + 7) = *(void **)((char *)&v35->__r_.__value_.__r.__words[1] + 7);
        v37 = HIBYTE(v35->__r_.__value_.__r.__words[2]);
        v35->__r_.__value_.__l.__size_ = 0;
        v35->__r_.__value_.__r.__words[2] = 0;
        v35->__r_.__value_.__r.__words[0] = 0;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        __p.__r_.__value_.__r.__words[0] = v36;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v112[0];
        *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v112 + 7);
        *((_BYTE *)&__p.__r_.__value_.__s + 23) = v37;
        if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v118.__r_.__value_.__l.__data_);
        if (SHIBYTE(v108.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v108.__r_.__value_.__l.__data_);
        if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v110.__r_.__value_.__l.__data_);
        if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v114.__r_.__value_.__l.__data_);
      }
      memset(&v108, 0, sizeof(v108));
      v109 = 0xAAAAAAAA00000000;
      std::string::basic_string[abi:ne180100]<0>(&v118, "^Versions$");
      Security::CodeSigning::DirValidator::require((uint64_t)&v108, (__int128 *)&v118, 34, 0);
      if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v118.__r_.__value_.__l.__data_);
      std::string::basic_string[abi:ne180100]<0>(&v118, "^Versions/[^/]+$");
      Security::CodeSigning::DirValidator::require((uint64_t)&v108, (__int128 *)&v118, 2, 0);
      if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v118.__r_.__value_.__l.__data_);
      std::string::basic_string[abi:ne180100]<0>(&v114, "^Versions/Current$");
      std::string::basic_string[abi:ne180100]<0>(&v110, "^(\\./)?(\\.\\.[^/]+|\\.?[^\\./][^/]*)$");
      v38 = MEMORY[0x1E0C809B0];
      v118.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
      v118.__r_.__value_.__l.__size_ = 1174405120;
      v118.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN8Security11CodeSigning12DirValidator7requireERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjS8__block_invoke;
      v119 = &__block_descriptor_tmp_60_13765;
      if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v120, v110.__r_.__value_.__l.__data_, v110.__r_.__value_.__l.__size_);
      else
        v120 = v110;
      Security::CodeSigning::DirValidator::require((uint64_t)&v108, (__int128 *)&v114, 4, &v118);
      if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v120.__r_.__value_.__l.__data_);
      if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v110.__r_.__value_.__l.__data_);
      if (SHIBYTE(v114.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v114.__r_.__value_.__l.__data_);
      std::string::basic_string[abi:ne180100]<0>(&v118, "^(Versions/)?\\.DS_Store$");
      Security::CodeSigning::DirValidator::allow(&v108.__r_.__value_.__l.__data_, (__int128 *)&v118, 9, 0);
      if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v118.__r_.__value_.__l.__data_);
      std::string::basic_string[abi:ne180100]<0>(&v118, "^[^/]+$");
      v114.__r_.__value_.__r.__words[0] = v38;
      v114.__r_.__value_.__l.__size_ = 1174405120;
      v114.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN8Security11CodeSigning13BundleDiskRep21validateFrameworkRootENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE_block_invoke;
      v115 = &__block_descriptor_tmp_13759;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&v116, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      else
        v116 = __p;
      Security::CodeSigning::DirValidator::allow(&v108.__r_.__value_.__l.__data_, (__int128 *)&v118, 4, &v114);
      if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v118.__r_.__value_.__l.__data_);
      std::string::basic_string[abi:ne180100]<0>(v112, "^module\\.map$");
      std::string::basic_string[abi:ne180100]<0>(&v105, "^(\\./)?Versions/");
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v40 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      else
        v40 = __p.__r_.__value_.__l.__size_;
      v41 = std::string::append(&v105, (const std::string::value_type *)p_p, v40);
      v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
      v106.__r_.__value_.__r.__words[2] = v41->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v106.__r_.__value_.__l.__data_ = v42;
      v41->__r_.__value_.__l.__size_ = 0;
      v41->__r_.__value_.__r.__words[2] = 0;
      v41->__r_.__value_.__r.__words[0] = 0;
      v43 = std::string::append(&v106, "/module\\.map$", 0xDuLL);
      v45 = (std::string::value_type *)v43->__r_.__value_.__r.__words[0];
      v44 = v43->__r_.__value_.__l.__size_;
      v107[0] = v43->__r_.__value_.__r.__words[2];
      *(_DWORD *)((char *)v107 + 3) = *(_DWORD *)((char *)&v43->__r_.__value_.__r.__words[2] + 3);
      v46 = SHIBYTE(v43->__r_.__value_.__r.__words[2]);
      v43->__r_.__value_.__l.__size_ = 0;
      v43->__r_.__value_.__r.__words[2] = 0;
      v43->__r_.__value_.__r.__words[0] = 0;
      v118.__r_.__value_.__r.__words[0] = v38;
      v118.__r_.__value_.__l.__size_ = 1174405120;
      v118.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN8Security11CodeSigning12DirValidator5allowERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjS8__block_invoke;
      v119 = &__block_descriptor_tmp_61_13763;
      if (v46 < 0)
      {
        std::string::__init_copy_ctor_external(&v120, v45, v44);
      }
      else
      {
        v120.__r_.__value_.__r.__words[0] = (std::string::size_type)v45;
        v120.__r_.__value_.__l.__size_ = v44;
        LODWORD(v120.__r_.__value_.__r.__words[2]) = v107[0];
        *(_DWORD *)((char *)&v120.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v107 + 3);
        *((_BYTE *)&v120.__r_.__value_.__s + 23) = v46;
      }
      Security::CodeSigning::DirValidator::allow(&v108.__r_.__value_.__l.__data_, (__int128 *)v112, 13, &v118);
      if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v120.__r_.__value_.__l.__data_);
      if (v46 < 0)
        operator delete(v45);
      if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v106.__r_.__value_.__l.__data_);
      if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v105.__r_.__value_.__l.__data_);
      if (v113 < 0)
        operator delete(v112[0]);
      Security::CodeSigning::DirValidator::validate((uint64_t)&v108, (uint64_t)&v97, 0xFFFEFA40);
      if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v116.__r_.__value_.__l.__data_);
      Security::CodeSigning::DirValidator::~DirValidator((uint64_t **)&v108);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v97.__r_.__value_.__l.__data_);
      goto LABEL_147;
    }
    if (a2 && *(_QWORD *)(a2 + 8))
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA04);
  }
  else
  {
    memset(__b, 0, 24);
    *(_QWORD *)&__b[24] = 0xAAAAAAAA00000000;
    std::string::basic_string[abi:ne180100]<0>(&v118, "^Contents$");
    Security::CodeSigning::DirValidator::require((uint64_t)__b, (__int128 *)&v118, 2, 0);
    if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v118.__r_.__value_.__l.__data_);
    std::string::basic_string[abi:ne180100]<0>(&v118, "^(\\.LSOverride|\\.DS_Store|Icon\r|\\.SoftwareDepot\\.tracking)$");
    Security::CodeSigning::DirValidator::allow((char **)__b, (__int128 *)&v118, 9, 0);
    if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v118.__r_.__value_.__l.__data_);
    Security::CodeSigning::DirValidator::validate((uint64_t)__b, (uint64_t)&v102, 0xFFFEFA3A);
    Security::CodeSigning::DirValidator::~DirValidator((uint64_t **)__b);
  }
  v22 = 1;
LABEL_148:
  InfoDictionary = CFBundleGetInfoDictionary(*(CFBundleRef *)(a1 + 24));
  Value = (const __CFString *)CFDictionaryGetValue(InfoDictionary, CFSTR("MainHTML"));
  v49 = CFDictionaryGetValue(InfoDictionary, CFSTR("IFMajorVersion"));
  v114.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
  v50 = CFBundleCopyExecutableURL(*(CFBundleRef *)(a1 + 24));
  v114.__r_.__value_.__r.__words[0] = (std::string::size_type)v50;
  if (v50 && !Value)
  {
    if (!a2 || !*(_QWORD *)(a2 + 8))
    {
      if (v104)
        Security::CodeSigning::BundleDiskRep::checkMoved((Security::CodeSigning::BundleDiskRep *)a1, v104, v50);
      if (v103)
      {
        *(_QWORD *)__b = 0xAAAAAAAAAAAAAAAALL;
        v51 = (const __CFURL *)_CFBundleCopyInfoPlistURL();
        *(_QWORD *)__b = v51;
        if (v51)
          Security::CodeSigning::BundleDiskRep::checkMoved((Security::CodeSigning::BundleDiskRep *)a1, v103, v51);
        Security::CFRef<__CFURL const*>::~CFRef((const void **)__b);
      }
    }
    Security::CFRef<__CFData const*>::operator=((CFTypeRef *)(a1 + 64), (CFTypeRef *)&v114.__r_.__value_.__l.__data_);
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)a1 + 40))(__b, a1);
    if (__b[23] >= 0)
      v52 = __b;
    else
      v52 = *(char **)__b;
    v53 = Security::CodeSigning::DiskRep::bestFileGuess(v52);
    v54 = (_QWORD *)(a1 + 104);
    Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((_QWORD *)(a1 + 104), v53);
    if ((__b[23] & 0x80000000) != 0)
      operator delete(*(void **)__b);
    v55 = (Security::UnixPlusPlus::FileDesc *)*(unsigned int *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v54
                                                                                                 + 144))(*v54);
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)a1 + 40))(__b, a1);
    Security::CodeSigning::BundleDiskRep::checkPlainFile(a1, v55, (uint64_t)__b);
    if ((__b[23] & 0x80000000) != 0)
      operator delete(*(void **)__b);
    v56 = CFBundleGetInfoDictionary(*(CFBundleRef *)(a1 + 24));
    v58 = v56
       && (v57 = CFDictionaryGetValue(v56, CFSTR("CFBundlePackageType"))) != 0
       && CFEqual(v57, CFSTR("APPL")) != 0;
    (*(void (**)(_BYTE *__return_ptr))(*(_QWORD *)*v54 + 128))(__b);
    v69 = std::string::insert((std::string *)__b, 0, "bundle with ", 0xCuLL);
    v70 = v69->__r_.__value_.__r.__words[0];
    v118.__r_.__value_.__r.__words[0] = v69->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v118.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v69->__r_.__value_.__r.__words[1] + 7);
    v71 = HIBYTE(v69->__r_.__value_.__r.__words[2]);
    v69->__r_.__value_.__l.__size_ = 0;
    v69->__r_.__value_.__r.__words[2] = 0;
    v69->__r_.__value_.__r.__words[0] = 0;
    v72 = (void **)(a1 + 80);
    if (*(char *)(a1 + 103) < 0)
      operator delete(*v72);
    v73 = v118.__r_.__value_.__r.__words[0];
    *(_QWORD *)(a1 + 80) = v70;
    *(_QWORD *)(a1 + 88) = v73;
    *(_QWORD *)(a1 + 95) = *(std::string::size_type *)((char *)v118.__r_.__value_.__r.__words + 7);
    *(_BYTE *)(a1 + 103) = v71;
    if ((__b[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)__b);
      if (!v58)
      {
LABEL_207:
        *(_BYTE *)(a1 + 73) = v22 & v58;
        v77 = &v114;
LABEL_208:
        Security::CFRef<__CFURL const*>::~CFRef((const void **)&v77->__r_.__value_.__l.__data_);
        goto LABEL_211;
      }
    }
    else if (!v58)
    {
      goto LABEL_207;
    }
    std::operator+<char>();
    if (*(char *)(a1 + 103) < 0)
      operator delete(*v72);
    *(_OWORD *)v72 = *(_OWORD *)__b;
    *(_QWORD *)(a1 + 96) = *(_QWORD *)&__b[16];
    goto LABEL_207;
  }
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v114.__r_.__value_.__l.__data_);
  if (Value)
  {
    v59 = CFGetTypeID(Value);
    if (v59 != CFStringGetTypeID())
      goto LABEL_263;
    Security::cfString((std::string *)__b, Value);
    v60 = CFBundleCopySupportFilesDirectoryURL(*(CFBundleRef *)(a1 + 24));
    v118.__r_.__value_.__r.__words[0] = (std::string::size_type)v60;
    if (__b[23] >= 0)
      v62 = (Security *)__b;
    else
      v62 = *(Security **)__b;
    CFURL = Security::makeCFURL(v62, 0, (uint64_t)v60, v61);
    v64 = *(const void **)(a1 + 64);
    if (v64)
      CFRelease(v64);
    *(_QWORD *)(a1 + 64) = CFURL;
    Security::CFRef<__CFURL const*>::~CFRef((const void **)&v118.__r_.__value_.__l.__data_);
    if ((__b[23] & 0x80000000) != 0)
      operator delete(*(void **)__b);
    if (!*(_QWORD *)(a1 + 64))
LABEL_263:
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
    v65 = (Security::CodeSigning::FileDiskRep *)operator new();
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)a1 + 40))(__b, a1);
    if (__b[23] >= 0)
      v66 = __b;
    else
      v66 = *(char **)__b;
    Security::CodeSigning::FileDiskRep::FileDiskRep(v65, v66);
    Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((_QWORD *)(a1 + 104), (uint64_t)v65);
    if ((__b[23] & 0x80000000) != 0)
      operator delete(*(void **)__b);
    v67 = (Security::UnixPlusPlus::FileDesc *)*(unsigned int *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 104)
                                                                                                 + 144))(*(_QWORD *)(a1 + 104));
    (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)a1 + 40))(__b, a1);
    Security::CodeSigning::BundleDiskRep::checkPlainFile(a1, v67, (uint64_t)__b);
    if ((__b[23] & 0x80000000) != 0)
      operator delete(*(void **)__b);
    if (*(char *)(a1 + 103) < 0)
    {
      *(_QWORD *)(a1 + 88) = 13;
      v68 = *(char **)(a1 + 80);
    }
    else
    {
      v68 = (char *)(a1 + 80);
      *(_BYTE *)(a1 + 103) = 13;
    }
    strcpy(v68, "widget bundle");
    *(_BYTE *)(a1 + 73) = 1;
  }
  else
  {
    v118.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
    v118.__r_.__value_.__r.__words[0] = _CFBundleCopyInfoPlistURL();
    if (v118.__r_.__value_.__r.__words[0])
    {
      Security::CFRef<__CFData const*>::operator=((CFTypeRef *)(a1 + 64), (CFTypeRef *)&v118.__r_.__value_.__l.__data_);
      v74 = (Security::CodeSigning::FileDiskRep *)operator new();
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)a1 + 40))(__b, a1);
      if (__b[23] >= 0)
        v75 = __b;
      else
        v75 = *(char **)__b;
      Security::CodeSigning::FileDiskRep::FileDiskRep(v74, v75);
      Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((_QWORD *)(a1 + 104), (uint64_t)v74);
      if ((__b[23] & 0x80000000) != 0)
        operator delete(*(void **)__b);
      v76 = (Security::UnixPlusPlus::FileDesc *)*(unsigned int *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 104) + 144))(*(_QWORD *)(a1 + 104));
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)a1 + 40))(__b, a1);
      Security::CodeSigning::BundleDiskRep::checkPlainFile(a1, v76, (uint64_t)__b);
      if ((__b[23] & 0x80000000) != 0)
        operator delete(*(void **)__b);
      if (v49)
      {
        *(_BYTE *)(a1 + 72) = 1;
        std::string::__assign_external((std::string *)(a1 + 80), "installer package bundle", 0x18uLL);
      }
      else
      {
        if (*(char *)(a1 + 103) < 0)
        {
          *(_QWORD *)(a1 + 88) = 6;
          v96 = *(char **)(a1 + 80);
        }
        else
        {
          v96 = (char *)(a1 + 80);
          *(_BYTE *)(a1 + 103) = 6;
        }
        strcpy(v96, "bundle");
      }
      v77 = &v118;
      goto LABEL_208;
    }
    Security::CFRef<__CFURL const*>::~CFRef((const void **)&v118.__r_.__value_.__l.__data_);
    memset(__b, 170, 24);
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(_QWORD *)a1 + 56))(&v118, a1);
    memset(__b, 0, 24);
    if ((v118.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v79 = &v118;
    else
      v79 = (std::string *)v118.__r_.__value_.__r.__words[0];
    *(_OWORD *)&v114.__r_.__value_.__l.__data_ = (unint64_t)v79;
    v80 = fts_open(&v114.__r_.__value_.__l.__data_, 28, 0);
    v81 = 1;
LABEL_224:
    v82 = v81;
    while (1)
    {
      v83 = fts_read(v80);
      if (!v83)
        break;
      fts_info = v83->fts_info;
      if (fts_info == 8 || fts_info == 11)
      {
        fts_path = v83->fts_path;
        if (!strcmp(&fts_path[v83->fts_pathlen - 5], ".dist"))
        {
          v87 = __b[23];
          if (__b[23] < 0)
            v87 = *(_QWORD *)&__b[8];
          if (v87)
            Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
          std::string::__assign_external((std::string *)__b, fts_path);
        }
      }
      else if (fts_info == 1)
      {
        v81 = 0;
        if ((v82 & 1) == 0)
        {
          fts_set(v80, v83, 4);
          v81 = 0;
        }
        goto LABEL_224;
      }
    }
    fts_close(v80);
    if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v118.__r_.__value_.__l.__data_);
    v89 = __b[23];
    if (__b[23] < 0)
      v89 = *(_QWORD *)&__b[8];
    if (!v89)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
    if (__b[23] >= 0)
      v90 = (Security *)__b;
    else
      v90 = *(Security **)__b;
    v91 = Security::makeCFURL(v90, 0, 0, v88);
    v92 = *(const void **)(a1 + 64);
    if (v92)
      CFRelease(v92);
    *(_QWORD *)(a1 + 64) = v91;
    v93 = (Security::CodeSigning::FileDiskRep *)operator new();
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(_QWORD *)a1 + 40))(&v118, a1);
    if ((v118.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v94 = &v118;
    else
      v94 = (std::string *)v118.__r_.__value_.__r.__words[0];
    Security::CodeSigning::FileDiskRep::FileDiskRep(v93, (char *)v94);
    Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((_QWORD *)(a1 + 104), (uint64_t)v93);
    if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v118.__r_.__value_.__l.__data_);
    v95 = (Security::UnixPlusPlus::FileDesc *)*(unsigned int *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 104)
                                                                                                 + 144))(*(_QWORD *)(a1 + 104));
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(_QWORD *)a1 + 40))(&v118, a1);
    Security::CodeSigning::BundleDiskRep::checkPlainFile(a1, v95, (uint64_t)&v118);
    if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v118.__r_.__value_.__l.__data_);
    *(_BYTE *)(a1 + 72) = 1;
    std::string::__assign_external((std::string *)(a1 + 80), "installer package bundle", 0x18uLL);
    if ((__b[23] & 0x80000000) != 0)
      operator delete(*(void **)__b);
  }
LABEL_211:
  if (SHIBYTE(__sz.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__sz.__r_.__value_.__l.__data_);
  if (SHIBYTE(v100[2]) < 0)
    operator delete(v100[0]);
  if (SHIBYTE(v101[2]) < 0)
    operator delete(v101[0]);
  if (SHIBYTE(v102.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v102.__r_.__value_.__l.__data_);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v103);
  return Security::CFRef<__CFURL const*>::~CFRef((const void **)&v104);
}

void sub_18A936D48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41,const void *a42,const void *a43,void *a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,uint64_t a60,void *a61,uint64_t a62,uint64_t a63)
{
  void *__p;
  char a72;
  uint64_t v72;

  if (a72 < 0)
    operator delete(__p);
  if (*(char *)(v72 - 121) < 0)
    operator delete(*(void **)(v72 - 144));
  if (a22 < 0)
    operator delete(a17);
  if (a29 < 0)
    operator delete(a24);
  if (a35 < 0)
    operator delete(a30);
  if (a41 < 0)
    operator delete(a36);
  Security::CFRef<__CFURL const*>::~CFRef(&a42);
  Security::CFRef<__CFURL const*>::~CFRef(&a43);
  _Unwind_Resume(a1);
}

_QWORD *Security::CodeSigning::BundleDiskRep::mainExecutablePath@<X0>(const __CFURL **this@<X0>, Security *a2@<X8>)
{
  return Security::cfString(a2, this[8]);
}

uint64_t *Security::CodeSigning::BundleDiskRep::checkMoved(Security::CodeSigning::BundleDiskRep *this, const __CFURL *a2, const __CFURL *a3)
{
  void **v6;
  void **v7;
  _BOOL4 v8;
  uint64_t *result;
  void *__p[2];
  char v11;
  void *v12[2];
  char v13;
  char __s2[1024];
  char __b[1024];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  memset(__b, 170, sizeof(__b));
  memset(__s2, 170, sizeof(__s2));
  Security::cfString((Security *)v12, a2);
  if (v13 >= 0)
    v6 = v12;
  else
    v6 = (void **)v12[0];
  if (realpath_DARWIN_EXTSN((const char *)v6, __b))
  {
    Security::cfString((Security *)__p, a3);
    if (v11 >= 0)
      v7 = __p;
    else
      v7 = (void **)__p[0];
    v8 = realpath_DARWIN_EXTSN((const char *)v7, __s2) == 0;
    if (v11 < 0)
      operator delete(__p[0]);
  }
  else
  {
    v8 = 1;
  }
  if (v13 < 0)
    operator delete(v12[0]);
  if (v8)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA3DLL);
  result = (uint64_t *)strcmp(__b, __s2);
  if ((_DWORD)result)
    return std::__tree<int>::__emplace_unique_key_args<int,int const&>((uint64_t *)this + 26, -67011, -67011);
  return result;
}

void sub_18A9373DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

const void **Security::cfStringRelease(Security *this, const __CFURL *a2)
{
  const void *v3;

  v3 = a2;
  Security::cfString(this, a2);
  return Security::CFRef<__CFURL const*>::~CFRef(&v3);
}

void sub_18A93744C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

Security::UnixPlusPlus::FileDesc *Security::CodeSigning::SingleDiskRep::fd(Security::CodeSigning::SingleDiskRep *this)
{
  Security::UnixPlusPlus::FileDesc *v1;
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v5;

  v1 = (Security::CodeSigning::SingleDiskRep *)((char *)this + 40);
  if (*((_DWORD *)this + 10) == -1)
  {
    v4 = (const char *)*((_QWORD *)this + 2);
    v2 = (char *)this + 16;
    v3 = v4;
    if (v2[23] >= 0)
      v5 = v2;
    else
      v5 = v3;
    Security::UnixPlusPlus::FileDesc::open(v1, v5, 0, 438);
  }
  return v1;
}

uint64_t *Security::CodeSigning::BundleDiskRep::checkPlainFile(uint64_t a1, Security::UnixPlusPlus::FileDesc *this, uint64_t a3)
{
  timespec v5;
  const char *v6;
  uint64_t *result;
  int *v8;
  stat v9;
  stat v10;

  v5.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v5.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v10.st_blksize = v5;
  *(timespec *)v10.st_qspare = v5;
  v10.st_birthtimespec = v5;
  *(timespec *)&v10.st_size = v5;
  v10.st_mtimespec = v5;
  v10.st_ctimespec = v5;
  *(timespec *)&v10.st_uid = v5;
  v10.st_atimespec = v5;
  *(timespec *)v9.st_qspare = v5;
  *(timespec *)&v10.st_dev = v5;
  *(timespec *)&v9.st_size = v5;
  *(timespec *)&v9.st_blksize = v5;
  v9.st_ctimespec = v5;
  v9.st_birthtimespec = v5;
  v9.st_atimespec = v5;
  v9.st_mtimespec = v5;
  *(timespec *)&v9.st_dev = v5;
  *(timespec *)&v9.st_uid = v5;
  Security::UnixPlusPlus::FileDesc::fstat(this, &v10);
  if (*(char *)(a3 + 23) >= 0)
    v6 = (const char *)a3;
  else
    v6 = *(const char **)a3;
  result = (uint64_t *)lstat(v6, &v9);
  if ((_DWORD)result)
  {
    v8 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v8);
  }
  if (v10.st_ino != v9.st_ino || (v9.st_mode & 0xF000) != 0x8000)
    return std::__tree<int>::__emplace_unique_key_args<int,int const&>((uint64_t *)(a1 + 208), -67015, -67015);
  return result;
}

void Security::CodeSigning::MachORep::format(Security::CodeSigning::MachORep *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  std::string *p_p;
  std::string::size_type size;
  _QWORD *v8;
  _QWORD **v9;
  BOOL v10;
  std::string::size_type v11;
  std::string *v12;
  void *v13;
  void **v14;
  std::string::size_type v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  void *v20[2];
  unsigned __int8 v21;
  std::string __p;
  std::string v23;
  cpu_type_t *v24;
  _QWORD *v25[2];

  v3 = (uint64_t *)(*(uint64_t (**)(Security::CodeSigning::MachORep *))(*(_QWORD *)this + 80))(this);
  if (!v3)
  {
    std::string::basic_string[abi:ne180100]<0>((_QWORD *)a2, "Mach-O (unrecognized format)");
    return;
  }
  v4 = v3;
  v25[0] = 0;
  v25[1] = 0;
  v24 = (cpu_type_t *)v25;
  Security::Universal::architectures(v3, (uint64_t *)&v24);
  if (v4[1])
  {
    memset(&v23, 170, sizeof(v23));
    std::string::basic_string[abi:ne180100]<0>(&v23, "Mach-O universal (");
    v5 = (uint64_t)v24;
    if (v24 != (cpu_type_t *)v25)
    {
      do
      {
        if ((cpu_type_t *)v5 != v24)
          std::string::append(&v23, " ", 1uLL);
        Security::Architecture::displayName((Security::Architecture *)&__p, (cpu_type_t *)(v5 + 28));
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = &__p;
        else
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        else
          size = __p.__r_.__value_.__l.__size_;
        std::string::append(&v23, (const std::string::value_type *)p_p, size);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        v8 = *(_QWORD **)(v5 + 8);
        if (v8)
        {
          do
          {
            v9 = (_QWORD **)v8;
            v8 = (_QWORD *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            v9 = *(_QWORD ***)(v5 + 16);
            v10 = *v9 == (_QWORD *)v5;
            v5 = (uint64_t)v9;
          }
          while (!v10);
        }
        v5 = (uint64_t)v9;
      }
      while (v9 != v25);
    }
    if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v11 = HIBYTE(v23.__r_.__value_.__r.__words[2]);
    else
      v11 = v23.__r_.__value_.__l.__size_;
    memset((void *)a2, 170, 24);
    std::string::basic_string[abi:ne180100](a2, v11 + 1);
    if (*(char *)(a2 + 23) < 0)
      a2 = *(_QWORD *)a2;
    if (v11)
    {
      if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v12 = &v23;
      else
        v12 = (std::string *)v23.__r_.__value_.__r.__words[0];
      memmove((void *)a2, v12, v11);
    }
    *(_WORD *)(a2 + v11) = 41;
    if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_46;
    v13 = (void *)v23.__r_.__value_.__r.__words[0];
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(&__p, "Mach-O thin (");
    Security::Architecture::displayName((Security::Architecture *)v20, v24 + 7);
    if ((v21 & 0x80u) == 0)
      v14 = v20;
    else
      v14 = (void **)v20[0];
    if ((v21 & 0x80u) == 0)
      v15 = v21;
    else
      v15 = (std::string::size_type)v20[1];
    v16 = std::string::append(&__p, (const std::string::value_type *)v14, v15);
    v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v23.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    v18 = std::string::append(&v23, ")", 1uLL);
    v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    *(_QWORD *)(a2 + 16) = *((_QWORD *)&v18->__r_.__value_.__l + 2);
    *(_OWORD *)a2 = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v23.__r_.__value_.__l.__data_);
    if ((char)v21 < 0)
      operator delete(v20[0]);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_46;
    v13 = (void *)__p.__r_.__value_.__r.__words[0];
  }
  operator delete(v13);
LABEL_46:
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v25[0]);
}

void sub_18A9377FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,_QWORD *a28)
{
  if (a26 < 0)
    operator delete(__p);
  if (a14 < 0)
    operator delete(a9);
  if (a20 < 0)
    operator delete(a15);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a28);
  _Unwind_Resume(a1);
}

_QWORD *Security::Architecture::displayName(Security::Architecture *this, cpu_type_t *a2)
{
  const NXArchInfo *v4;
  char __str[24];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v4 = NXGetArchInfoFromCpuType(*a2, a2[1] & 0xFFFFFF);
  if (v4 && v4->name)
    return std::string::basic_string[abi:ne180100]<0>(this, (char *)v4->name);
  memset(__str, 170, 20);
  snprintf(__str, 0x14uLL, "(%d:%d)", *a2, a2[1] & 0xFFFFFF);
  return std::string::basic_string[abi:ne180100]<0>(this, __str);
}

uint64_t Security::CodeSigning::DiskRep::bestFileGuess(char *a1)
{
  return Security::CodeSigning::DiskRep::bestGuess(a1);
}

void Security::CodeSigning::SecStaticCode::visitOtherArchitectures(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  Security::Universal *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  BOOL v14;
  _QWORD *v15;
  uint64_t v16;
  const Security::CFClass *v17;
  Security::CodeSigning::SecStaticCode *v18;
  char *v19;
  Security::CodeSigning::DiskRep *v20;
  unsigned __int8 *v21;
  unsigned __int8 v22;
  const void *v23;
  _QWORD *v24;
  _QWORD **v25;
  BOOL v26;
  void *__p[2];
  char v28;
  unint64_t v29;
  _QWORD v30[2];
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD **v35;
  _QWORD *v36;
  unint64_t v37;

  v4 = (uint64_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 80))(*(_QWORD *)(a1 + 32));
  if (v4)
  {
    v5 = (Security::Universal *)v4;
    v36 = 0;
    v37 = 0;
    v35 = &v36;
    Security::Universal::architectures(v4, (uint64_t *)&v35);
    if (v37 >= 2)
    {
      v30[0] = 0xFFFFFFFF00000000;
      v30[1] = 0;
      v31 = 0;
      v32 = 0xAAAAAAAAAAAAAA00;
      v33 = 0;
      v34 = 0;
      v6 = Security::Universal::archOffset(v5);
      v7 = (uint64_t)v35;
      if (v35 != &v36)
      {
        v8 = v6;
        v9 = (_QWORD *)((char *)v5 + 56);
        do
        {
          v10 = Security::Universal::archOffset(v5, (const Security::Architecture *)*(unsigned int *)(v7 + 28), *(_DWORD *)(v7 + 32));
          v31 = v10;
          v11 = (_QWORD *)*v9;
          if (!*v9)
            goto LABEL_35;
          v12 = (_QWORD *)((char *)v5 + 56);
          do
          {
            v13 = v11[4];
            v14 = v13 >= v10;
            if (v13 >= v10)
              v15 = v11;
            else
              v15 = v11 + 1;
            if (v14)
              v12 = v11;
            v11 = (_QWORD *)*v15;
          }
          while (*v15);
          if (v12 == v9 || v12[4] > v10)
LABEL_35:
            Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEF7A9);
          v34 = v12[5];
          if (v10 != v8)
          {
            v29 = 0xAAAAAAAAAAAAAAAALL;
            v16 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
            v18 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate((Security::SecCFObject *)0x288, *(_QWORD *)(v16 + 200), v17);
            (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 32) + 40))(__p);
            if (v28 >= 0)
              v19 = (char *)__p;
            else
              v19 = (char *)__p[0];
            v20 = (Security::CodeSigning::DiskRep *)Security::CodeSigning::DiskRep::bestGuess(v19, (unsigned int *)v30);
            Security::CodeSigning::SecStaticCode::SecStaticCode(v18, v20, 0);
            v21 = (unsigned __int8 *)v18 - 8;
            do
              v22 = __ldaxr(v21);
            while (__stlxr(1u, v21));
            if ((v22 & 1) != 0)
            {
              v23 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)v18 + 16))(v18);
              CFRetain(v23);
            }
            v29 = (unint64_t)v18;
            if (v28 < 0)
            {
              operator delete(__p[0]);
              v18 = (Security::CodeSigning::SecStaticCode *)v29;
            }
            *((_DWORD *)v18 + 52) = *(_DWORD *)(a1 + 208) & 0x20010000;
            Security::CodeSigning::SecStaticCode::detachedSignature(v18, *(const __CFData **)(a1 + 136));
            (*(void (**)(uint64_t, unint64_t))(a2 + 16))(a2, v29);
            Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v29);
          }
          v24 = *(_QWORD **)(v7 + 8);
          if (v24)
          {
            do
            {
              v25 = (_QWORD **)v24;
              v24 = (_QWORD *)*v24;
            }
            while (v24);
          }
          else
          {
            do
            {
              v25 = *(_QWORD ***)(v7 + 16);
              v26 = *v25 == (_QWORD *)v7;
              v7 = (uint64_t)v25;
            }
            while (!v26);
          }
          v7 = (uint64_t)v25;
        }
        while (v25 != &v36);
      }
    }
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v36);
  }
}

void sub_18A937C0C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::logic_error a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  __break(1u);
  JUMPOUT(0x18A937CC0);
}

uint64_t Security::CodeSigning::MachORep::mainExecutableImage(Security::CodeSigning::MachORep *this)
{
  return *((_QWORD *)this + 7);
}

uint64_t Security::CodeSigning::BundleDiskRep::mainExecutableImage(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 80))(*((_QWORD *)this + 13));
}

CFURLRef Security::CodeSigning::BundleDiskRep::copyCanonicalPath(CFBundleRef *this)
{
  CFURLRef result;

  result = CFBundleCopyBundleURL(this[3]);
  if (!result)
    Security::CFError::throwMe(0);
  return result;
}

uint64_t Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer(_QWORD *a1, uint64_t a2)
{
  Security::UnixError *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  _QWORD v11[2];

  v11[0] = a1 + 1;
  v11[1] = 0xAAAAAAAAAAAAAA01;
  v4 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v4)
    Security::UnixError::throwMe(v4);
  if (a2)
  {
    v5 = (unsigned int *)(a2 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  if (*a1)
  {
    v7 = (unsigned int *)(*a1 + 8);
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stxr(v9, v7));
    if (!v9 && *a1)
      (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 8))(*a1);
  }
  *a1 = a2;
  return Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v11);
}

OSStatus SecTrustSetPolicies(SecTrustRef trust, CFTypeRef policies)
{
  OSStatus v2;
  uint64_t v5;
  NSObject *v6;
  CFTypeID v7;
  uint64_t Count;
  uint64_t v9;
  CFMutableArrayRef Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v13;
  CFTypeID v14;
  NSObject *v15;
  const void *v16;
  CFTypeID v17;
  CFArrayRef v18;
  NSObject *v19;
  NSObject *v20;
  _QWORD v22[6];
  uint8_t buf[16];
  void *values;
  uint64_t block;
  uint64_t p_block;
  uint64_t v27;
  void *v28;
  SecTrustRef v29;

  values = (void *)policies;
  v2 = -50;
  if (trust && policies)
  {
    v5 = MEMORY[0x1E0C809B0];
    v6 = *((_QWORD *)trust + 17);
    block = MEMORY[0x1E0C809B0];
    p_block = 0x40000000;
    v27 = (uint64_t)__SecTrustSetNeedsEvaluation_block_invoke;
    v28 = &__block_descriptor_tmp_49_11514;
    v29 = trust;
    dispatch_sync(v6, &block);
    block = 0;
    p_block = (uint64_t)&block;
    v27 = 0x2000000000;
    v28 = 0;
    v7 = CFGetTypeID(policies);
    if (v7 == CFArrayGetTypeID())
    {
      Count = CFArrayGetCount((CFArrayRef)policies);
      if (Count < 1)
      {
LABEL_21:
        v2 = -50;
        goto LABEL_22;
      }
      v9 = Count;
      Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E0C9B378]);
      *(_QWORD *)(p_block + 24) = Mutable;
      if (!Mutable)
      {
        v2 = -108;
        goto LABEL_22;
      }
      for (i = 0; i != v9; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)policies, i);
        if (ValueAtIndex && (v13 = ValueAtIndex, v14 = CFGetTypeID(ValueAtIndex), v14 == SecPolicyGetTypeID()))
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(p_block + 24), v13);
        }
        else
        {
          v15 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18A900000, v15, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: newPolicies array contains non-policy value", buf, 2u);
          }
        }
      }
      if (v9 != CFArrayGetCount(*(CFArrayRef *)(p_block + 24)))
      {
        v16 = *(const void **)(p_block + 24);
        if (v16)
          CFRelease(v16);
        goto LABEL_21;
      }
    }
    else
    {
      v17 = CFGetTypeID(policies);
      if (v17 != SecPolicyGetTypeID())
      {
        v20 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18A900000, v20, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: newPolicies contains unsupported value type", buf, 2u);
        }
        goto LABEL_21;
      }
      v18 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
      *(_QWORD *)(p_block + 24) = v18;
    }
    v19 = *((_QWORD *)trust + 17);
    v22[0] = v5;
    v22[1] = 0x40000000;
    v22[2] = __SecTrustSetPolicies_block_invoke;
    v22[3] = &unk_1E1FDA120;
    v22[4] = &block;
    v22[5] = trust;
    dispatch_sync(v19, v22);
    v2 = 0;
LABEL_22:
    _Block_object_dispose(&block, 8);
  }
  return v2;
}

uint64_t tls_handshake_init_pending_cipher_callback(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 48));
}

uint64_t SSLAdvanceInternalRecordLayerReadCipher()
{
  return tls_record_advance_read_cipher();
}

BOOL SecTrustEvaluateWithError(SecTrustRef trust, CFErrorRef *error)
{
  int v4;
  __CFError *v5;
  __CFError *v6;
  BOOL result;
  int v9;

  v9 = 0;
  v4 = SecTrustEvaluateInternal(trust, &v9);
  if (v4)
  {
    if (error)
    {
      v5 = (__CFError *)SecCopyLastError(v4);
LABEL_4:
      v6 = v5;
      result = 0;
LABEL_12:
      *error = v6;
      return result;
    }
  }
  else
  {
    if (v9 == 4 || v9 == 1)
    {
      result = 1;
      if (!error)
        return result;
      v6 = 0;
      goto LABEL_12;
    }
    if (error)
    {
      v5 = SecTrustCopyError((uint64_t)trust);
      goto LABEL_4;
    }
  }
  return 0;
}

OSStatus SecStaticCodeCheckValidityWithErrors(SecStaticCodeRef staticCode, SecCSFlags flags, SecRequirementRef requirement, CFErrorRef *errors)
{
  SecCSFlags v6;
  Security::CodeSigning::SecStaticCode *v7;
  __SecRequirement *v8;
  Security::CodeSigning::SecStaticCode *v9;
  unsigned __int8 *v10;
  unsigned __int8 v11;
  const void *v12;
  int v13;
  char *v14;
  OSStatus v15;
  BOOL v16;
  void *__p;
  Security::CodeSigning::SecStaticCode *v19;

  if ((flags & 0xDFE0020) != 0)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  if (errors)
    v6 = flags | 0x20;
  else
    v6 = flags;
  v19 = (Security::CodeSigning::SecStaticCode *)0xAAAAAAAAAAAAAAAALL;
  v7 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(staticCode, *(const __SecCode **)&flags);
  v9 = v7;
  if (v7)
  {
    v10 = (unsigned __int8 *)v7 - 8;
    do
      v11 = __ldaxr(v10);
    while (__stlxr(1u, v10));
    if ((v11 & 1) != 0)
    {
      v12 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)v7 + 16))(v7);
      CFRetain(v12);
    }
  }
  v13 = v6 | 0x2000000;
  v19 = v9;
  *((_DWORD *)v9 + 52) = v13;
  v14 = Security::CodeSigning::SecRequirement::optional((char *)requirement, v8);
  __p = v19;
  Security::CodeSigning::SecStaticCode::staticValidate(v19, v13, (Security::CodeSigning::Requirement **)v14);
  if (*((_BYTE *)v19 + 632))
    v15 = 0;
  else
    v15 = -66996;
  if (*((_BYTE *)v19 + 632))
    v16 = 1;
  else
    v16 = errors == 0;
  if (!v16)
  {
    *errors = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -66996, 0);
    v15 = -66996;
  }
  SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC::~_DTFrameCODESIGN_EVAL_STATIC((SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC *)&__p);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v19);
  return v15;
}

void sub_18A938298(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  __CFError **v15;
  CFDictionaryRef *v18;
  _DWORD *v19;
  int v20;
  void *v21;
  int v22;
  CFErrorRef v23;
  _DWORD *v24;
  unsigned int v25;
  int v26;
  void *v27;
  int v28;
  const char *v29;

  if (a14 < 0)
    operator delete(__p);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a15);
  switch(a2)
  {
    case 7:
      v18 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v18, v15);
      goto LABEL_34;
    case 6:
      v19 = __cxa_begin_catch(a1);
      if (v19[36] == 8)
        v20 = -67049;
      else
        v20 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v19 + 24))(v19);
      if (v15)
      {
LABEL_32:
        v23 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v20, 0);
        goto LABEL_33;
      }
LABEL_34:
      __cxa_end_catch();
      JUMPOUT(0x18A93826CLL);
    case 5:
      v21 = __cxa_begin_catch(a1);
      v22 = (*(uint64_t (**)(void *))(*(_QWORD *)v21 + 24))(v21);
      if (!v15)
        goto LABEL_34;
      v23 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v22, 0);
LABEL_33:
      *v15 = v23;
      goto LABEL_34;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      v27 = __cxa_begin_catch(a1);
      v28 = (*(uint64_t (**)(void *))(*(_QWORD *)v27 + 24))(v27);
      if (v15)
        *v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v28, 0);
    }
    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v15)
          *v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -108, 0);
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v29);
        if (v15)
          *v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -67048, 0);
      }
    }
    goto LABEL_34;
  }
  v24 = __cxa_begin_catch(a1);
  v25 = v24[36];
  if (v25 > 0x1A)
    goto LABEL_30;
  v20 = -67033;
  v26 = 1 << v25;
  if ((v26 & 0x800108) != 0)
    goto LABEL_31;
  if ((v26 & 0x4014000) != 0)
    v20 = -67032;
  else
LABEL_30:
    v20 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v24 + 24))(v24);
LABEL_31:
  if (!v15)
    goto LABEL_34;
  goto LABEL_32;
}

void sub_18A93850C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t SecCodeSpecialSlotIsPresent(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  int v2;
  Security::CodeSigning::SecStaticCode *v3;
  Security::CodeSigning::CodeDirectory *v4;
  _BOOL4 IsPresent;
  uint64_t v6;

  v2 = (int)a2;
  v3 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  v4 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory(v3, 1);
  IsPresent = Security::CodeSigning::CodeDirectory::slotIsPresent(v4, -v2);
  v6 = MEMORY[0x1E0C9AE50];
  if (!IsPresent)
    v6 = MEMORY[0x1E0C9AE40];
  return *(_QWORD *)v6;
}

void sub_18A9385B8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18A9385A8);
}

void *Security::CodeSigning::SecStaticCode::requiredStatic(Security::CodeSigning::SecStaticCode *this, const __SecCode *a2)
{
  char *v2;
  void *result;
  _BYTE *v4;
  _BYTE *v5;

  if (!this)
    goto LABEL_8;
  v2 = (char *)this + 24;
  if (result)
    return result;
  if (!v4)
LABEL_8:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  v5 = v4;
  if (!v4[24])
  {
    (*(void (**)(_BYTE *))(*(_QWORD *)v4 + 80))(v4);
    v5[24] = 1;
  }
  return (void *)*((_QWORD *)v5 + 4);
}

void Security::SecPointerBase::~SecPointerBase(Security::SecPointerBase *this)
{
  uint64_t v1;
  const void *v2;

  v1 = *(_QWORD *)this;
  if (v1)
  {
    v2 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1);
    CFRelease(v2);
  }
}

uint64_t Security::SecCFObject::operator void const*(uint64_t a1)
{
  return a1 - 24;
}

void SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC::~_DTFrameCODESIGN_EVAL_STATIC(SecStaticCodeCheckValidityWithErrors::_DTFrameCODESIGN_EVAL_STATIC *this)
{
  ;
}

char *Security::CodeSigning::SecRequirement::optional(char *this, __SecRequirement *a2)
{
  if (this)
  {
    if (!this)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  return this;
}

const void **Security::CodeSigning::SecStaticCode::staticValidate(Security::CodeSigning::SecStaticCode *this, int a2, Security::CodeSigning::Requirement **a3)
{
  const void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFDictionary *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFURL *v22;
  const char *v23;
  _BOOL4 v24;
  const char *v25;
  _BOOL4 v26;
  unsigned int v27;
  _BOOL4 v28;
  void **v29;
  _BOOL4 v30;
  NSObject *v31;
  unsigned int *v32;
  std::string::size_type size;
  std::string *p_buf;
  std::string::size_type v35;
  uint64_t v36;
  unsigned __int8 v38;
  Security::CodeSigning::LimitedAsync *v39;
  uint64_t v40;
  const __CFDictionary *v41;
  unsigned int v42;
  const __CFArray *v43;
  const char *v44;
  const __CFArray *v45;
  CFMutableArrayRef MutableCopy;
  CFIndex Count;
  char *v48;
  unint64_t v49;
  _BOOL4 v50;
  uint64_t v51;
  uint64_t v52;
  int *v53;
  int v54;
  BOOL v55;
  uint64_t *v56;
  uint64_t v57;
  int *v58;
  int v59;
  BOOL v60;
  uint64_t *v61;
  __int128 v62;
  uint64_t v63;
  CFMutableDictionaryRef v64;
  const __CFURL *v65;
  __int128 v66;
  __int128 *v67;
  int v68;
  NSObject *v69;
  Security::MacOSError *v70;
  uint64_t v71;
  const UInt8 *v72;
  uint64_t v73;
  const UInt8 *v74;
  uint64_t v75;
  uint64_t v76;
  const void *v77;
  CFTypeID v78;
  uint64_t v79;
  void **v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD v84[6];
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  void *v89;
  CFDictionaryRef *v90;
  Security::CodeSigning::SecStaticCode *v91;
  uint64_t v92;
  std::string *v93;
  int v94;
  unsigned int v95;
  BOOL v96;
  BOOL v97;
  __int128 v98;
  void (*v99)(uint64_t, uint64_t, char, char *);
  void *v100;
  Security::CodeSigning::SecStaticCode *v101;
  std::string *v102;
  int v103;
  void *context[3];
  CFDictionaryRef theDict;
  CFDictionaryRef *p_theDict;
  uint64_t v107;
  uint64_t (*v108)(uint64_t, uint64_t);
  const void **(*v109)(uint64_t);
  const void *v110[2];
  unsigned int v111[5];
  void *__p[3];
  unint64_t v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  std::string buf;
  __int128 v121;
  _BYTE v122[32];
  __int128 v123;
  dispatch_group_t v124;
  uint8_t v125[8];
  uint64_t v126;
  CFRange v127;

  v126 = *MEMORY[0x1E0C80C00];
  *((_DWORD *)this + 52) = a2;
  if ((a2 & 0x10000000) != 0)
  {
    v6 = (const void *)Security::CodeSigning::SecStaticCode::resourceDictionary(this, 1);
    v13 = (const __CFDictionary *)Security::cfget<__CFDictionary const*>(v6, (uint64_t)"files2", v7, v8, v9, v10, v11, v12, v82);
    if (v13
      || (v13 = (const __CFDictionary *)Security::cfget<__CFDictionary const*>(v6, (uint64_t)"files", v14, v15, v16, v17, v18, v19, v83)) != 0)
    {
      LODWORD(v13) = CFDictionaryGetCount(v13);
    }
    Security::CodeSigning::SecStaticCode::prepareProgress(this, (_DWORD)v13 + 2);
  }
  Security::CodeSigning::SecStaticCode::staticValidateCore((UInt8 *)this, a2, a3);
  if ((a2 & 1) != 0)
  {
    v84[0] = MEMORY[0x1E0C809B0];
    v84[1] = 0x40000000;
    v84[2] = ___ZN8Security11CodeSigning13SecStaticCode14staticValidateEjPKNS0_14SecRequirementE_block_invoke;
    v84[3] = &__block_descriptor_tmp_72_14336;
    v85 = a2;
    v84[4] = this;
    v84[5] = a3;
    buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
    buf.__r_.__value_.__l.__size_ = 0x40000000;
    buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN8Security11CodeSigning13SecStaticCode24handleOtherArchitecturesEU13block_pointerFvPS1_E_block_invoke;
    *(_QWORD *)&v121 = &unk_1E1FDCC70;
    *((_QWORD *)&v121 + 1) = v84;
    *(_QWORD *)v122 = this;
    Security::CodeSigning::SecStaticCode::visitOtherArchitectures((uint64_t)this, (uint64_t)&buf);
  }
  Security::CodeSigning::SecStaticCode::reportProgress(this);
  v20 = *((_QWORD *)this + 72);
  if (v20)
  {
    v21 = (*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)this + 16))(this);
    (*(void (**)(uint64_t, uint64_t, const __CFString *, _QWORD))(v20 + 16))(v20, v21, CFSTR("prepared"), 0);
  }
  if ((a2 & 4) == 0)
  {
    if (*((_BYTE *)this + 192) && ((a2 & 8) == 0 || *((_BYTE *)this + 193)))
    {
LABEL_97:
      v70 = (Security::MacOSError *)*((unsigned int *)this + 49);
      if ((_DWORD)v70)
        Security::MacOSError::throwMe(v70);
      if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 25) + 24))(*((_QWORD *)this + 25)))
        (*(void (**)(_QWORD))(**((_QWORD **)this + 25) + 32))(*((_QWORD *)this + 25));
      goto LABEL_100;
    }
    memset(__p, 170, sizeof(__p));
    v22 = (const __CFURL *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 48))(*((_QWORD *)this + 4));
    Security::cfStringRelease((Security *)__p, v22);
    v24 = Security::CodeSigning::itemQualifiesForResourceExemption((char *)__p, v23);
    v26 = v24;
    v27 = *((_DWORD *)this + 52) & 0x4000;
    if (v27)
      v28 = 0;
    else
      v28 = v24;
    if (SHIBYTE(__p[2]) >= 0)
      v29 = __p;
    else
      v29 = (void **)__p[0];
    v30 = Security::CodeSigning::pathFileSystemUsesXattrFiles((Security::CodeSigning *)v29, v25);
    v31 = secLogObjForScope("staticCode");
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
    {
      v81 = __p;
      if (SHIBYTE(__p[2]) < 0)
        v81 = (void **)__p[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v81;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 1024;
      *(_DWORD *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v26;
      WORD1(buf.__r_.__value_.__r.__words[2]) = 1024;
      HIDWORD(buf.__r_.__value_.__r.__words[2]) = v27 >> 14;
      LOWORD(v121) = 1024;
      *(_DWORD *)((char *)&v121 + 2) = v28;
      WORD3(v121) = 1024;
      DWORD2(v121) = v30;
      _os_log_debug_impl(&dword_18A900000, v31, OS_LOG_TYPE_DEBUG, "performing resource validation for %s (%d, %d, %d, %d)", (uint8_t *)&buf, 0x24u);
    }
    if (!*((_QWORD *)this + 73))
    {
      if ((a2 & 0x1000) != 0)
      {
        v38 = 0;
      }
      else
      {
        v32 = (unsigned int *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 144))(*((_QWORD *)this + 4));
        Security::UnixPlusPlus::FileDesc::mediumType(&buf, (Security::UnixPlusPlus::FileDesc *)*v32);
        size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
        if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          size = buf.__r_.__value_.__l.__size_;
        if (size == 11)
        {
          p_buf = (std::string *)buf.__r_.__value_.__r.__words[0];
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            p_buf = &buf;
          v35 = p_buf->__r_.__value_.__r.__words[0];
          v36 = *(std::string::size_type *)((char *)p_buf->__r_.__value_.__r.__words + 3);
          v38 = v35 == 0x74532064696C6F53 && v36 == 0x6574617453206469;
        }
        else
        {
          v38 = 0;
        }
        if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
          operator delete(buf.__r_.__value_.__l.__data_);
      }
      v39 = (Security::CodeSigning::LimitedAsync *)operator new();
      Security::CodeSigning::LimitedAsync::LimitedAsync(v39, v38);
      *((_QWORD *)this + 73) = v39;
    }
    memset(v111, 170, sizeof(v111));
    if (Security::CodeSigning::SecStaticCode::loadResources(this, (const __CFDictionary **)&v111[3], (const __CFDictionary **)&v111[1], v111))
    {
      v110[1] = this;
      v40 = operator new();
      *(_QWORD *)v40 = &off_1E1FC8AE0;
      *(_QWORD *)(v40 + 8) = this;
      *(_QWORD *)(v40 + 16) = 0;
      *(_DWORD *)(v40 + 24) = 0;
      Security::Mutex::Mutex((pthread_mutex_t *)(v40 + 32));
      *((_QWORD *)this + 25) = v40;
      if (!v28 && (a2 & 0x10) != 0)
      {
        v41 = *(const __CFDictionary **)&v111[3];
        v42 = v111[0];
        v43 = (const __CFArray *)*((_QWORD *)this + 21);
        v45 = (const __CFArray *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 240))(*((_QWORD *)this + 4));
        *(_QWORD *)v125 = v45;
        if (!v45)
        {
          Security::Syslog::notice((Security::Syslog *)"code signing internal problem: diskRep returned no allowedResourceOmissions", v44);
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
        }
        v113 = 0xAAAAAAAAAAAAAAAALL;
        MutableCopy = CFArrayCreateMutableCopy(0, 0, v45);
        v113 = (unint64_t)MutableCopy;
        if (v43)
        {
          v127.length = CFArrayGetCount(v43);
          v127.location = 0;
          CFArrayAppendArray(MutableCopy, v43, v127);
          MutableCopy = (CFMutableArrayRef)v113;
        }
        Count = CFArrayGetCount(MutableCopy);
        *((_QWORD *)&v98 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v99 = (void (*)(uint64_t, uint64_t, char, char *))0xAAAAAAAAAAAAAAAALL;
        if (v42 == 1)
          v48 = "^Resources/";
        else
          v48 = "^.*";
        *(_QWORD *)&v98 = 0xAAAAAAAAAAAAAAAALL;
        std::string::basic_string[abi:ne180100]<0>(&v98, v48);
        *(_QWORD *)&v114 = 0;
        *((_QWORD *)&v114 + 1) = &v114;
        *(_QWORD *)&v115 = 0x2000000000;
        BYTE8(v115) = 0;
        v86 = 0;
        v87 = (uint64_t)&v86;
        v88 = 0x2000000000;
        LOBYTE(v89) = 0;
        v49 = v113;
        theDict = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
        p_theDict = (CFDictionaryRef *)0xAAAAAAAAAAAAAAAALL;
        Security::CFDictionary::CFDictionary((Security::CFDictionary *)&theDict, v41, (Security::MacOSError *)0xFFFEFA13);
        buf.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
        buf.__r_.__value_.__l.__size_ = 1174405120;
        buf.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN8Security11CodeSigning13SecStaticCode20hasWeakResourceRulesEPK14__CFDictionaryjPK9__CFArray_block_invoke;
        *(_QWORD *)&v121 = &unk_1E1FDC968;
        if (SHIBYTE(v99) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)&v122[8], (const std::string::value_type *)v98, *((std::string::size_type *)&v98 + 1));
        }
        else
        {
          *(_OWORD *)&v122[8] = v98;
          *(_QWORD *)&v122[24] = v99;
        }
        *((_QWORD *)&v121 + 1) = &v114;
        *(_QWORD *)v122 = &v86;
        v123 = v49;
        v124 = (dispatch_group_t)Count;
        context[0] = &buf;
        CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)Security::CFDictionary::BlockApplier<__CFString const*,void const*>::apply, context);
        if (*(_BYTE *)(*((_QWORD *)&v114 + 1) + 24))
          v50 = *(_BYTE *)(v87 + 24) != 0;
        else
          v50 = 1;
        if ((v122[31] & 0x80000000) != 0)
          operator delete(*(void **)&v122[8]);
        Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&theDict);
        _Block_object_dispose(&v86, 8);
        _Block_object_dispose(&v114, 8);
        if (SHIBYTE(v99) < 0)
          operator delete((void *)v98);
        Security::CFRef<__CFArray *>::~CFRef((const void **)&v113);
        Security::CFRef<__CFArray const*>::~CFRef((const void **)v125);
        if (v50)
        {
          v51 = 4294900283;
          v52 = *((_QWORD *)this + 19);
          if (!v52)
            goto LABEL_119;
          v53 = (int *)((char *)this + 152);
          do
          {
            v54 = *(_DWORD *)(v52 + 28);
            v55 = v54 < -67013;
            if (v54 >= -67013)
              v56 = (uint64_t *)v52;
            else
              v56 = (uint64_t *)(v52 + 8);
            if (!v55)
              v53 = (int *)v52;
            v52 = *v56;
          }
          while (*v56);
          if (v53 == (int *)((char *)this + 152) || v53[7] > -67013)
            goto LABEL_119;
        }
        if (v42 == 1)
        {
          v57 = *((_QWORD *)this + 19);
          if (v57)
          {
            v58 = (int *)((char *)this + 152);
            do
            {
              v59 = *(_DWORD *)(v57 + 28);
              v51 = 4294900289;
              v60 = v59 < -67007;
              if (v59 >= -67007)
                v61 = (uint64_t *)v57;
              else
                v61 = (uint64_t *)(v57 + 8);
              if (!v60)
                v58 = (int *)v57;
              v57 = *v61;
            }
            while (*v61);
            if (v58 != (int *)((char *)this + 152))
            {
              v51 = 4294900289;
              if (v58[7] <= -67007)
                goto LABEL_82;
            }
          }
          else
          {
            v51 = 4294900289;
          }
LABEL_119:
          Security::MacOSError::throwMe((Security::MacOSError *)v51);
        }
      }
LABEL_82:
      *(_QWORD *)&v62 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v62 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v123 = v62;
      *(_OWORD *)&v122[16] = v62;
      *(_OWORD *)v122 = v62;
      v121 = v62;
      *(_OWORD *)&buf.__r_.__value_.__r.__words[1] = v62;
      v124 = (dispatch_group_t)0xAAAAAAAAAAAAAAAALL;
      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E1FC93A0;
      Security::Mutex::Mutex((pthread_mutex_t *)&buf.__r_.__value_.__r.__words[1]);
      LOBYTE(v123) = 0;
      *((_QWORD *)&v123 + 1) = 0;
      v124 = dispatch_group_create();
      theDict = 0;
      p_theDict = &theDict;
      v107 = 0x3002000000;
      v108 = __Block_byref_object_copy__27;
      v109 = __Block_byref_object_dispose__28;
      v110[0] = (const void *)0xAAAAAAAAAAAAAAAALL;
      v63 = *(_QWORD *)&v111[1];
      v64 = CFDictionaryCreateMutableCopy(0, 0, *(CFDictionaryRef *)&v111[1]);
      if (!v64)
        Security::CFError::throwMe(0);
      v110[0] = v64;
      memset(context, 170, sizeof(context));
      v65 = (const __CFURL *)Security::CodeSigning::SecStaticCode::resourceBase(this);
      Security::cfString((Security *)context, v65);
      *(_QWORD *)&v66 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v66 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v118 = v66;
      v119 = v66;
      v116 = v66;
      v117 = v66;
      v114 = v66;
      v115 = v66;
      Security::CodeSigning::ResourceBuilder::ResourceBuilder((std::string::size_type)&v114, (uint64_t)context, (uint64_t)context, *(const void **)&v111[3], (a2 & 0x10) != 0, (uint64_t)this + 144);
      *((_QWORD *)this + 41) = &v114;
      (*(void (**)(_QWORD, __int128 *))(**((_QWORD **)this + 4) + 64))(*((_QWORD *)this + 4), &v114);
      if ((a2 & 0x40000000) != 0)
      {
        *(_QWORD *)&v98 = MEMORY[0x1E0C809B0];
        *((_QWORD *)&v98 + 1) = 0x40000000;
        v99 = ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke;
        v100 = &__block_descriptor_tmp_33_14300;
        v103 = a2;
        v101 = this;
        v102 = &buf;
        v67 = &v98;
      }
      else
      {
        v67 = 0;
      }
      v86 = MEMORY[0x1E0C809B0];
      v87 = 0x40000000;
      v88 = (uint64_t)___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke_2;
      v89 = &unk_1E1FDC930;
      v90 = &theDict;
      v91 = this;
      v96 = v30;
      v97 = v28;
      v94 = a2;
      v95 = v111[0];
      v92 = v63;
      v93 = &buf;
      Security::CodeSigning::ResourceBuilder::scan((uint64_t)&v114, (uint64_t)&v86, (uint64_t)v67);
      Security::Dispatch::Group::wait((Security::Dispatch::Group *)&buf);
      if (!v28)
      {
        v68 = CFDictionaryGetCount(p_theDict[5]);
        if (v68)
        {
          v69 = secLogObjForScope("staticCode");
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v125 = 67109120;
            *(_DWORD *)&v125[4] = v68;
            _os_log_debug_impl(&dword_18A900000, v69, OS_LOG_TYPE_DEBUG, "%d sealed resource(s) not found in code", v125, 8u);
          }
          CFDictionaryApplyFunction(p_theDict[5], (CFDictionaryApplierFunction)Security::CodeSigning::SecStaticCode::checkOptionalResource, *((void **)this + 25));
        }
      }
      *((_BYTE *)this + 192) = 1;
      *((_BYTE *)this + 193) = (a2 & 8) != 0;
      if ((*(unsigned int (**)(_QWORD))(**((_QWORD **)this + 25) + 24))(*((_QWORD *)this + 25)))
        (*(void (**)(_QWORD))(**((_QWORD **)this + 25) + 32))(*((_QWORD *)this + 25));
      Security::CodeSigning::ResourceBuilder::~ResourceBuilder((Security::CodeSigning::ResourceBuilder *)&v114);
      if (SHIBYTE(context[2]) < 0)
        operator delete(context[0]);
      _Block_object_dispose(&theDict, 8);
      Security::CFRef<__CFDictionary *>::~CFRef(v110);
      Security::Dispatch::Group::~Group((Security::Dispatch::Group *)&buf);
      Security::CodeSigning::SecStaticCode::validateResources::_DTFrameCODESIGN_EVAL_STATIC_RESOURCES::~_DTFrameCODESIGN_EVAL_STATIC_RESOURCES();
      if (SHIBYTE(__p[2]) < 0)
        operator delete(__p[0]);
      goto LABEL_97;
    }
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
  }
LABEL_100:
  if ((a2 & 0x10) != 0)
  {
    v73 = *((_QWORD *)this + 4);
    v74 = Security::CodeSigning::SecStaticCode::codeDirectory(this, 1);
    (*(void (**)(uint64_t, const UInt8 *, char *, _QWORD))(*(_QWORD *)v73 + 224))(v73, v74, (char *)this + 144, *((unsigned int *)this + 52));
    Security::CodeSigning::SecStaticCode::reportProgress(this);
  }
  else if ((a2 & 0x2000) != 0)
  {
    v71 = *((_QWORD *)this + 4);
    v72 = Security::CodeSigning::SecStaticCode::codeDirectory(this, 1);
    (*(void (**)(uint64_t, const UInt8 *, char *, _QWORD))(*(_QWORD *)v71 + 232))(v71, v72, (char *)this + 144, *((unsigned int *)this + 52));
  }
  buf.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
  v75 = *((_QWORD *)this + 72);
  if (v75)
  {
    v76 = (*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)this + 16))(this);
    v77 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t, const __CFString *, _QWORD))(v75 + 16))(v75, v76, CFSTR("validated"), 0);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v77;
    if (v77)
    {
      v78 = CFGetTypeID(v77);
      if (v78 == CFNumberGetTypeID())
        v79 = Security::cfNumber<int>((const __CFNumber *)buf.__r_.__value_.__l.__data_);
      else
        v79 = 4294900276;
      Security::MacOSError::throwMe((Security::MacOSError *)v79);
    }
  }
  else
  {
    buf.__r_.__value_.__r.__words[0] = 0;
  }
  return Security::CFRef<void const*>::~CFRef((const void **)&buf.__r_.__value_.__l.__data_);
}

void sub_18A9391BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,const void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,int a55,__int16 a56,char a57,char a58,const void *a59,__int128 buf)
{
  uint64_t v60;
  char v61;
  uint64_t v62;
  void *v65;
  NSObject *v66;
  const char *v67;

  if (a2)
  {
    Security::CFRef<__CFDictionary const*>::~CFRef(&a43);
    _Block_object_dispose(&a17, 8);
    _Block_object_dispose(&buf, 8);
    if (a32 < 0)
      operator delete(__p);
    Security::CFRef<__CFArray *>::~CFRef(&a59);
    Security::CFRef<__CFArray const*>::~CFRef((const void **)(v62 - 112));
    Security::CodeSigning::SecStaticCode::validateResources::_DTFrameCODESIGN_EVAL_STATIC_RESOURCES::~_DTFrameCODESIGN_EVAL_STATIC_RESOURCES();
    v65 = __cxa_begin_catch(exception_object);
    if (a2 == 2)
    {
      *(_BYTE *)(v60 + 192) = 1;
      *(_BYTE *)(v60 + 193) = (v61 & 8) != 0;
      *(_DWORD *)(v60 + 196) = (*(uint64_t (**)(void *))(*(_QWORD *)v65 + 24))(v65);
      __cxa_rethrow();
    }
    v66 = secLogObjForScope("staticCode");
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v60;
      _os_log_debug_impl(&dword_18A900000, v66, OS_LOG_TYPE_DEBUG, "%p executable validation threw non-common exception", (uint8_t *)&buf, 0xCu);
    }
    *(_BYTE *)(v60 + 192) = 1;
    *(_BYTE *)(v60 + 193) = (v61 & 8) != 0;
    *(_DWORD *)(v60 + 196) = -67048;
    Security::Syslog::notice((Security::Syslog *)"code signing internal problem: unknown exception thrown by validation", v67);
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_18A939490(_Unwind_Exception *a1)
{
  uint64_t v1;

  Security::CFRef<void const*>::~CFRef((const void **)(v1 - 208));
  _Unwind_Resume(a1);
}

void sub_18A9394A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52)
{
  __cxa_end_catch();
  if (a52 < 0)
    operator delete(a47);
  JUMPOUT(0x18A9394DCLL);
}

void sub_18A9394AC()
{
  __cxa_end_catch();
  JUMPOUT(0x18A9394B4);
}

void sub_18A9394C8(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

const void **Security::CFRef<void const*>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void Security::CodeSigning::SecStaticCode::staticValidateCore(UInt8 *this, char a2, Security::CodeSigning::Requirement **a3)
{
  const __CFData *v6;
  const __CFData *v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  char *v17;
  Security::CodeSigning::CodeDirectory *v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  int v25;
  int v26;
  int i;
  int v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  char *v34;
  int v35;
  char *v36;
  _BYTE *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  int v42;
  const UInt8 *v43;
  void **v44;
  int v45;
  void *v46;
  float v47;
  Security::Universal *v48;
  off_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unsigned int v53;
  int v54;
  char v55;
  const UInt8 *v56;
  size_t v57;
  size_t v58;
  uint64_t v59;
  char *v60;
  char v61;
  const Security::CodeSigning::SecRequirement *v62;
  const Security::CodeSigning::SecRequirement *v63;
  _BYTE *v64;
  int v65;
  void *__p[2];
  BOOL (*v67)(uint64_t, unsigned int, Security::DynamicHash *);
  void *v68;
  uint64_t *v69;
  UInt8 *v70;
  unsigned int v71;
  _QWORD v72[3];
  int v73;
  char v74;
  _QWORD v75[2];
  uint64_t v76;
  uint64_t *v77;
  uint64_t v78;
  char v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  Security::CodeSigning::SecStaticCode::validateNonResourceComponents(this);
  v6 = (const __CFData *)(*(uint64_t (**)(UInt8 *, uint64_t, uint64_t))(*(_QWORD *)this + 80))(this, 4, 4294900235);
  v7 = v6;
  if (v6)
  {
    BytePtr = CFDataGetBytePtr(v6);
    Length = CFDataGetLength(v7);
    v10 = Length;
    if ((unint64_t)Length >= 4)
    {
      if (Length < 0)
        std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
      v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(Length >> 2);
      v13 = 0;
      do
      {
        *(_DWORD *)&v11[v13] = bswap32(*(_DWORD *)&BytePtr[v13]);
        v13 += 4;
      }
      while (4 * (v10 >> 2) != v13);
      v12 = &v11[v13];
    }
    else
    {
      v11 = 0;
      v12 = 0;
    }
    v60 = v12;
    v61 = a2;
    v62 = (const Security::CodeSigning::SecRequirement *)a3;
    v64 = v11;
    v14 = (char *)operator new(4uLL);
    *(_DWORD *)v14 = 0;
    v15 = v14 + 4;
    v16 = 1;
    v17 = v14 + 4;
    do
    {
      if ((_DWORD)v16 != 7
        || (v18 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)this, 1), Security::CodeSigning::CodeDirectory::slotIsPresent(v18, -7)))
      {
        if ((*(uint64_t (**)(UInt8 *, uint64_t, uint64_t))(*(_QWORD *)this + 80))(this, v16, 4294900235))
        {
          if (v15 >= v17)
          {
            v19 = (v15 - v14) >> 2;
            v20 = v19 + 1;
            if ((unint64_t)(v19 + 1) >> 62)
              std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
            if ((v17 - v14) >> 1 > v20)
              v20 = (v17 - v14) >> 1;
            if ((unint64_t)(v17 - v14) >= 0x7FFFFFFFFFFFFFFCLL)
              v21 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v21 = v20;
            if (v21)
              v21 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v21);
            else
              v22 = 0;
            v23 = (char *)(v21 + 4 * v19);
            *(_DWORD *)v23 = v16;
            v24 = v23 + 4;
            while (v15 != v14)
            {
              v25 = *((_DWORD *)v15 - 1);
              v15 -= 4;
              *((_DWORD *)v23 - 1) = v25;
              v23 -= 4;
            }
            v17 = (char *)(v21 + 4 * v22);
            if (v14)
              operator delete(v14);
            v14 = v23;
            v15 = v24;
          }
          else
          {
            *(_DWORD *)v15 = v16;
            v15 += 4;
          }
        }
      }
      v16 = (v16 + 1);
    }
    while ((_DWORD)v16 != 12);
    v26 = *((_DWORD *)this + 30) - 1;
    if (v26 < 1)
    {
      v29 = v15;
    }
    else
    {
      for (i = 0; i != v26; ++i)
      {
        v28 = i + 4096;
        if (v15 >= v17)
        {
          v30 = (v15 - v14) >> 2;
          v31 = v30 + 1;
          if ((unint64_t)(v30 + 1) >> 62)
            std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
          if ((v17 - v14) >> 1 > v31)
            v31 = (v17 - v14) >> 1;
          if ((unint64_t)(v17 - v14) >= 0x7FFFFFFFFFFFFFFCLL)
            v32 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v32 = v31;
          if (v32)
            v32 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v32);
          else
            v33 = 0;
          v34 = (char *)(v32 + 4 * v30);
          *(_DWORD *)v34 = v28;
          v29 = v34 + 4;
          while (v15 != v14)
          {
            v35 = *((_DWORD *)v15 - 1);
            v15 -= 4;
            *((_DWORD *)v34 - 1) = v35;
            v34 -= 4;
          }
          v17 = (char *)(v32 + 4 * v33);
          if (v14)
            operator delete(v14);
          v14 = v34;
        }
        else
        {
          *(_DWORD *)v15 = v28;
          v29 = v15 + 4;
        }
        v15 = v29;
      }
    }
    if (v29 >= v17)
    {
      v38 = (v29 - v14) >> 2;
      v39 = v38 + 1;
      v37 = v64;
      if ((unint64_t)(v38 + 1) >> 62)
        std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
      if ((v17 - v14) >> 1 > v39)
        v39 = (v17 - v14) >> 1;
      if ((unint64_t)(v17 - v14) >= 0x7FFFFFFFFFFFFFFCLL)
        v40 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v40 = v39;
      if (v40)
        v40 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(v40);
      a3 = (Security::CodeSigning::Requirement **)v62;
      a2 = v61;
      v41 = (char *)(v40 + 4 * v38);
      *(_DWORD *)v41 = 0x10000;
      v36 = v41 + 4;
      while (v29 != v14)
      {
        v42 = *((_DWORD *)v29 - 1);
        v29 -= 4;
        *((_DWORD *)v41 - 1) = v42;
        v41 -= 4;
      }
      if (v14)
        operator delete(v14);
      v14 = v41;
    }
    else
    {
      *(_DWORD *)v29 = 0x10000;
      v36 = v29 + 4;
      a3 = (Security::CodeSigning::Requirement **)v62;
      v37 = v64;
      a2 = v61;
    }
    if (v60 - v37 != v36 - v14 || memcmp(v37, v14, v60 - v37))
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0BLL);
    if (v14)
      operator delete(v14);
    if (v37)
      operator delete(v37);
  }
  if ((a2 & 2) != 0)
    goto LABEL_106;
  if (!this[185])
  {
    v75[1] = this;
    v43 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)this, 1);
    if (!v43)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ALL);
    v75[0] = 0xAAAAAAAAFFFFFFFFLL;
    (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 4) + 40))(__p);
    if (SHIBYTE(v67) >= 0)
      v44 = __p;
    else
      v44 = (void **)__p[0];
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)v75, (const char *)v44, 0, 438);
    if (SHIBYTE(v67) < 0)
      operator delete(__p[0]);
    v47 = Security::UnixPlusPlus::FileDesc::fcntl((Security::UnixPlusPlus::FileDesc *)v75, v45, v46);
    v48 = (Security::Universal *)(*(uint64_t (**)(_QWORD, float))(**((_QWORD **)this + 4) + 80))(*((_QWORD *)this + 4), v47);
    if (v48)
    {
      v49 = Security::Universal::archOffset(v48);
    }
    else
    {
      if (!(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 88))(*((_QWORD *)this + 4)))
      {
LABEL_87:
        v63 = (const Security::CodeSigning::SecRequirement *)a3;
        v65 = v43[39];
        if (v43[39])
          v50 = 1 << v43[39];
        else
          v50 = 0;
        if (bswap32(*((_DWORD *)v43 + 2)) >> 8 >= 0x203 && (v51 = *((_QWORD *)v43 + 7)) != 0)
          v52 = bswap64(v51);
        else
          v52 = bswap32(*((_DWORD *)v43 + 8));
        if (*((_DWORD *)v43 + 7))
        {
          v53 = 0;
          v54 = v75[0];
          v55 = BYTE4(v75[0]);
          do
          {
            v56 = v43;
            if (v50 >= v52)
              v57 = v52;
            else
              v57 = v50;
            v76 = 0;
            v77 = &v76;
            if (v65)
              v58 = v57;
            else
              v58 = v52;
            v78 = 0x2000000000;
            v79 = 1;
            v73 = v54;
            v74 = v55;
            std::set<unsigned int>::set[abi:ne180100]((uint64_t)v72, (_QWORD *)this + 43);
            __p[0] = (void *)MEMORY[0x1E0C809B0];
            __p[1] = (void *)0x40000000;
            v67 = ___ZN8Security11CodeSigning13SecStaticCode18validateExecutableEv_block_invoke;
            v68 = &unk_1E1FDC898;
            v71 = v53;
            v69 = &v76;
            v70 = this;
            Security::CodeSigning::CodeDirectory::multipleHashFileData((uint64_t)&v73, v58, v72, (uint64_t)__p);
            std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((_QWORD *)v72[1]);
            if (!*((_BYTE *)v77 + 24))
              Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0BLL);
            v52 -= v58;
            _Block_object_dispose(&v76, 8);
            ++v53;
            v43 = v56;
          }
          while (v53 < bswap32(*((_DWORD *)v56 + 7)));
        }
        this[185] = 1;
        *((_DWORD *)this + 47) = 0;
        Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)v75);
        Security::CodeSigning::SecStaticCode::validateExecutable(void)::_DTFrameCODESIGN_EVAL_STATIC_EXECUTABLE::~_DTFrameCODESIGN_EVAL_STATIC_EXECUTABLE();
        a3 = (Security::CodeSigning::Requirement **)v63;
        goto LABEL_105;
      }
      v49 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 88))(*((_QWORD *)this + 4));
    }
    Security::UnixPlusPlus::FileDesc::seek((Security::UnixPlusPlus::FileDesc *)LODWORD(v75[0]), v49);
    goto LABEL_87;
  }
LABEL_105:
  v59 = *((unsigned int *)this + 47);
  if ((_DWORD)v59)
    goto LABEL_114;
LABEL_106:
  if (a3 && !Security::CodeSigning::SecStaticCode::satisfiesRequirement((uint64_t)this, a3[2]))
  {
    v59 = 4294900246;
LABEL_114:
    Security::MacOSError::throwMe((Security::MacOSError *)v59);
  }
}

void sub_18A939BC4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  uint64_t v37;
  uint64_t v38;
  void *v40;
  NSObject *v41;
  const char *v42;

  if (a2)
  {
    v40 = __cxa_begin_catch(a1);
    if (a2 == 4)
    {
      *(_BYTE *)(v37 + 185) = 1;
      *(_DWORD *)(v37 + 188) = (*(uint64_t (**)(void *))(*(_QWORD *)v40 + 24))(v40);
      __cxa_rethrow();
    }
    v41 = secLogObjForScope("staticCode");
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)(v38 - 144) = 134217984;
      *(_QWORD *)(v38 - 140) = v37;
      _os_log_debug_impl(&dword_18A900000, v41, OS_LOG_TYPE_DEBUG, "%p executable validation threw non-common exception", (uint8_t *)(v38 - 144), 0xCu);
    }
    *(_BYTE *)(v37 + 185) = 1;
    *(_DWORD *)(v37 + 188) = -67048;
    Security::Syslog::notice((Security::Syslog *)"code signing internal problem: unknown exception thrown by validation", v42);
    __cxa_rethrow();
  }
  JUMPOUT(0x18A939FE0);
}

void sub_18A939D7C()
{
  __cxa_end_catch();
  JUMPOUT(0x18A939DE8);
}

void sub_18A939DB0(uint64_t a1, int a2)
{
  if (!a2)
    JUMPOUT(0x18A939FE0);
  JUMPOUT(0x18A939DE8);
}

void sub_18A939DC4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;
  void *v26;
  uint64_t v27;
  Security::CodeSigning::CSError *v30;
  off_t *v31;
  unsigned int *v32;
  off_t *v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  unsigned int v50;
  const void *v51;

  if (v26)
    operator delete(v26);
  if (__p)
    operator delete(__p);
  if (a2 == 2)
  {
    v30 = (Security::CodeSigning::CSError *)__cxa_begin_catch(a1);
    v31 = (off_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v25 + 32) + 80))(*(_QWORD *)(v25 + 32));
    if (v31)
    {
      v34 = Security::Universal::architecture(v31);
      v35 = *(_QWORD *)(v34 + 8);
      v36 = *(_DWORD *)(v35 + 4);
      LODWORD(v35) = *(_DWORD *)(v35 + 8);
      v37 = bswap32(v36);
      if (*(_BYTE *)(v34 + 33))
        v38 = v37;
      else
        v38 = v36;
      v39 = bswap32(v35);
      if (*(_BYTE *)(v34 + 33))
        v35 = v39;
      else
        v35 = v35;
      *(_QWORD *)(v27 - 152) = v38 | (v35 << 32);
      Security::Architecture::displayName((Security::Architecture *)&a14, (cpu_type_t *)(v27 - 152));
      Security::CFTempString::CFTempString<std::string>((CFStringRef *)(v27 - 144), (char *)&a14);
      Security::CodeSigning::CSError::augment(v30, CFSTR("SecCSArchitecture"), *(_QWORD *)(v27 - 144), v40, v41, v42, v43, v44);
      Security::CFRef<__CFString const*>::~CFRef((const void **)(v27 - 144));
      if (a19 < 0)
        operator delete(a14);
      (*(void (**)(uint64_t))(*(_QWORD *)v34 + 8))(v34);
    }
    __cxa_rethrow();
  }
  if (a2 == 1)
  {
    v32 = (unsigned int *)__cxa_begin_catch(a1);
    v33 = (off_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v25 + 32) + 80))(*(_QWORD *)(v25 + 32));
    if (!v33)
      __cxa_rethrow();
    v45 = Security::Universal::architecture(v33);
    *(_QWORD *)(v27 - 144) = 0xAAAAAAAAAAAAAAAALL;
    v46 = *(_QWORD *)(v45 + 8);
    v47 = *(_DWORD *)(v46 + 4);
    LODWORD(v46) = *(_DWORD *)(v46 + 8);
    v48 = bswap32(v47);
    if (*(_BYTE *)(v45 + 33))
      v49 = v48;
    else
      v49 = v47;
    v50 = bswap32(v46);
    if (*(_BYTE *)(v45 + 33))
      v46 = v50;
    else
      v46 = v46;
    *(_QWORD *)(v27 - 152) = v49 | (v46 << 32);
    Security::Architecture::displayName((Security::Architecture *)&a20, (cpu_type_t *)(v27 - 152));
    Security::CFTempString::CFTempString<std::string>((CFStringRef *)(v27 - 144), (char *)&a20);
    if (a25 < 0)
      operator delete(a20);
    (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
    Security::CodeSigning::CSError::throwMe((Security::CodeSigning::CSError *)v32[36], (uint64_t)CFSTR("SecCSArchitecture"), *(const __CFString **)(v27 - 144), v51);
  }
  JUMPOUT(0x18A939FE0);
}

void sub_18A939F58(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;

  Security::CFRef<__CFString const*>::~CFRef((const void **)(v25 - 144));
  __cxa_end_catch();
  JUMPOUT(0x18A939FE0);
}

void sub_18A939FC8()
{
  __cxa_end_catch();
  JUMPOUT(0x18A939FE0);
}

void sub_18A939FD8(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

const UInt8 *Security::CodeSigning::SecStaticCode::validateNonResourceComponents(UInt8 *this)
{
  const UInt8 *result;
  unsigned int v3;
  uint64_t v4;

  Security::CodeSigning::SecStaticCode::validateDirectory(this);
  result = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)this, 1);
  v3 = bswap32(*((_DWORD *)result + 6));
  if (v3 >= 0xB)
    v4 = 11;
  else
    v4 = v3;
  while (1)
  {
    if ((_DWORD)v4 == 3)
      goto LABEL_7;
    if (!(_DWORD)v4)
      return result;
    result = (const UInt8 *)(*(uint64_t (**)(UInt8 *, uint64_t, uint64_t))(*(_QWORD *)this + 80))(this, v4, 4294900235);
LABEL_7:
    v4 = (v4 - 1);
  }
}

void Security::CodeSigning::SecStaticCode::reportProgress(Security::CodeSigning::SecStaticCode *this)
{
  NSObject *v1;
  _QWORD block[6];
  int v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  if (*((_QWORD *)this + 72) && (*((_BYTE *)this + 211) & 0x10) != 0)
  {
    v4 = 0;
    v5 = &v4;
    v6 = 0x2000000000;
    v7 = 0;
    v1 = *((_QWORD *)this + 39);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___ZN8Security11CodeSigning13SecStaticCode14reportProgressEj_block_invoke;
    block[3] = &unk_1E1FDC848;
    block[4] = &v4;
    block[5] = this;
    v3 = 1;
    dispatch_sync(v1, block);
    if (*((_BYTE *)v5 + 24))
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA42);
    _Block_object_dispose(&v4, 8);
  }
}

void sub_18A93A118(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

_DWORD *tls_handshake_ready_callback(_DWORD *result, int a2, int a3)
{
  int v3;

  if (a2)
  {
    result[19] = a3;
  }
  else
  {
    result[18] = a3;
    if (a3)
      v3 = 2;
    else
      v3 = 1;
    result[20] = v3;
  }
  return result;
}

OSStatus SSLClose(SSLContextRef context)
{
  OSStatus result;

  if (!context)
    return -50;
  result = tls_handshake_close();
  if (!result)
  {
    result = (*(uint64_t (**)(_QWORD))(*((_QWORD *)context + 5) + 64))(*((_QWORD *)context + 6));
    if ((result + 10009) <= 9)
      result = dword_18AA5C3A8[result + 10009];
  }
  *((_DWORD *)context + 20) = 3;
  if (result == -36)
    return 0;
  return result;
}

OSStatus SSLHandshake(SSLContextRef context)
{
  int v2;
  OSStatus result;
  int v4;

  if (!context)
    return -50;
  v2 = *((_DWORD *)context + 20);
  if (v2 == 3)
    return -9805;
  if (v2 == 4)
    return -9806;
  if (*((_BYTE *)context + 104))
  {
    if (*((double *)context + 52) != 0.0 && *((double *)context + 52) < CFAbsoluteTimeGetCurrent())
    {
      result = MEMORY[0x18D771384](*((_QWORD *)context + 7));
      if (result)
        return result;
    }
    v2 = *((_DWORD *)context + 20);
  }
  if (v2 == 6)
  {
    v4 = *((_DWORD *)context + 21);
    if (v4 == -67818 || v4 == -67820)
    {
      tls_handshake_send_alert();
      return SSLClose(context);
    }
    else
    {
LABEL_20:
      while (1)
      {
        result = SSLHandshakeProceed((uint64_t)context);
        if (result)
        {
          if (result != -9849)
            break;
        }
        if (*((_DWORD *)context + 18) && *((_DWORD *)context + 19))
        {
          result = (*(uint64_t (**)(_QWORD))(*((_QWORD *)context + 5) + 64))(*((_QWORD *)context + 6));
          if ((result + 10009) <= 9)
            return dword_18AA5C3A8[result + 10009];
          return result;
        }
      }
    }
  }
  else
  {
    if (v2)
      goto LABEL_20;
    if (*((_DWORD *)context + 27) != 1 || (result = SSLHandshakeStart((uint64_t)context)) == 0)
    {
      *((_DWORD *)context + 20) = 1;
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t SSLHandshakeProceed(uint64_t a1)
{
  uint64_t v2;
  _BYTE v4[24];
  __int128 v5;
  uint64_t v6;

  v2 = tls_handshake_continue();
  if (!(_DWORD)v2)
  {
    v2 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 40) + 64))(*(_QWORD *)(a1 + 48));
    if ((v2 + 10009) <= 9)
      v2 = dword_18AA5C3A8[(v2 + 10009)];
    if (!(_DWORD)v2)
    {
      memset(v4, 170, sizeof(v4));
      v2 = (**(uint64_t (***)(_QWORD, _BYTE *))(a1 + 40))(*(_QWORD *)(a1 + 48), v4);
      if ((v2 + 10009) <= 9)
        v2 = dword_18AA5C3A8[(v2 + 10009)];
      if (!(_DWORD)v2)
      {
        v2 = tls_handshake_process();
        v5 = *(_OWORD *)v4;
        v6 = *(_QWORD *)&v4[16];
        (*(void (**)(_QWORD, __int128 *))(*(_QWORD *)(a1 + 40) + 56))(*(_QWORD *)(a1 + 48), &v5);
      }
      if (*(_DWORD *)(a1 + 108) == 1
        && !*(_BYTE *)(a1 + 552)
        && !*(_BYTE *)(a1 + 553)
        && (_DWORD)v2 != -9803
        && (_DWORD)v2)
      {
        log_SecureTransport_early_fail((int)v2);
      }
    }
  }
  return v2;
}

uint64_t SSLRecordFreeInternal(uint64_t a1, uint64_t a2)
{
  void *v3;

  v3 = *(void **)(a2 + 16);
  if (v3)
    free(v3);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  return 0;
}

OSStatus SSLRead(SSLContextRef context, void *data, size_t dataLength, size_t *processed)
{
  OSStatus result;
  size_t *v9;
  int v10;
  BOOL v11;
  uint64_t v12;
  size_t v13;
  char *v14;
  uint64_t v15;
  size_t v16;
  void *v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE v21[24];
  __int128 v22;
  uint64_t v23;

  memset(v21, 170, sizeof(v21));
  result = -50;
  if (context && data && processed)
  {
    v9 = (size_t *)((char *)context + 288);
    *processed = 0;
    while (2)
    {
      v10 = *((_DWORD *)context + 20) - 3;
      if (v10 < 4)
      {
        return dword_18AA61BE0[v10];
      }
      else
      {
        while (!*((_DWORD *)context + 18))
        {
          result = SSLHandshakeProceed((uint64_t)context);
          if (result)
            goto LABEL_29;
        }
        result = tls_handshake_continue();
        if (result)
          return result;
        result = (*(uint64_t (**)(_QWORD))(*((_QWORD *)context + 5) + 64))(*((_QWORD *)context + 6));
        if ((result + 10009) <= 9)
          result = dword_18AA5C3A8[result + 10009];
        if (result)
          v11 = result == -9803;
        else
          v11 = 1;
        if (!v11)
          goto LABEL_29;
        v12 = *((_QWORD *)context + 37);
        v13 = dataLength;
        v14 = (char *)data;
        if (v12)
        {
          v15 = *((_QWORD *)context + 38);
          v16 = *((_QWORD *)context + 36) - v15 >= dataLength ? dataLength : *((_QWORD *)context + 36) - v15;
          memcpy(data, (const void *)(v12 + v15), v16);
          v13 = dataLength - v16;
          v14 = (char *)data + v16;
          *processed += v16;
          v17 = (void *)*((_QWORD *)context + 37);
          v18 = *((_QWORD *)context + 38) + v16;
          *((_QWORD *)context + 38) = v18;
          if (v17)
          {
            if (v18 >= *v9)
            {
              free(v17);
              *v9 = 0;
              *((_QWORD *)context + 37) = 0;
              *((_QWORD *)context + 38) = 0;
            }
          }
        }
        if (!v13 || *((_DWORD *)context + 20) == 3)
          goto LABEL_33;
        result = (**((uint64_t (***)(_QWORD, _BYTE *))context + 5))(*((_QWORD *)context + 6), v21);
        if ((result + 10009) <= 9)
          result = dword_18AA5C3A8[result + 10009];
        if (result)
        {
LABEL_29:
          v19 = (result + 9851);
          if (v19 <= 0x30)
          {
            if (v19 == 2)
              continue;
            if (((1 << (result + 123)) & 0x1400800000601) != 0)
              return result;
          }
          if (result)
          {
            *((_DWORD *)context + 20) = 4;
            return result;
          }
          goto LABEL_33;
        }
        if (v21[0] != 23 && v21[0])
        {
          result = tls_handshake_process();
          if (result)
          {
            if (result != -9805)
              goto LABEL_29;
            SSLClose(context);
          }
          v22 = *(_OWORD *)v21;
          v23 = *(_QWORD *)&v21[16];
          result = (*(uint64_t (**)(_QWORD, __int128 *))(*((_QWORD *)context + 5) + 56))(*((_QWORD *)context + 6), &v22);
          if (!result)
            goto LABEL_33;
          goto LABEL_29;
        }
        v20 = *(_QWORD *)&v21[8];
        if (*(_QWORD *)&v21[8] > v13)
        {
          memcpy(v14, *(const void **)&v21[16], v13);
          *processed += v13;
          *(_OWORD *)v9 = *(_OWORD *)&v21[8];
          *((_QWORD *)context + 38) = v13;
          goto LABEL_33;
        }
        memcpy(v14, *(const void **)&v21[16], *(size_t *)&v21[8]);
        *processed += v20;
        v22 = *(_OWORD *)v21;
        v23 = *(_QWORD *)&v21[16];
        result = (*(uint64_t (**)(_QWORD, __int128 *))(*((_QWORD *)context + 5) + 56))(*((_QWORD *)context + 6), &v22);
        if (result)
          goto LABEL_29;
LABEL_33:
        result = 0;
        if (dataLength && !*processed)
          continue;
      }
      break;
    }
  }
  return result;
}

uint64_t SSLRecordReadInternal(_QWORD *a1, uint64_t a2)
{
  unint64_t header_size;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t result;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  size_t v16;
  size_t v17;
  void *v18;
  size_t v19;
  unint64_t v20;

  v20 = 0xAAAAAAAAAAAAAAAALL;
  header_size = (int)tls_record_get_header_size();
  v5 = a1[4];
  v6 = header_size - v5;
  if (header_size <= v5)
  {
LABEL_9:
    tls_record_parse_header();
    if (tls_record_parse_ssl2_header())
      return 4294957287;
    if (a1[2] < 0xAAAAAAAAAAAAAAACLL)
      return 4294957288;
    v12 = a1[4];
    if (v12 < 0xAAAAAAAAAAAAAAACLL
      && ((v13 = a1[3] + v12,
           v14 = a1[1],
           v20 = 0xAAAAAAAAAAAAAAACLL - v12,
           result = (*(uint64_t (**)(_QWORD, unint64_t, unint64_t *))(v14 + 16))(*(_QWORD *)(v14 + 32), v13, &v20), (_DWORD)result != -9803)? (v15 = result): (v15 = -10001), v15))
    {
      if (v15 == -10001)
        goto LABEL_7;
    }
    else
    {
      *(_BYTE *)a2 = -86;
      a1[4] = 0;
      v16 = tls_record_decrypted_size();
      if (v16)
      {
        v17 = v16;
        v18 = malloc_type_malloc(v16, 0xEFB4CC30uLL);
        if (v18)
          v19 = v17;
        else
          v19 = 0;
        *(_QWORD *)(a2 + 8) = v19;
        *(_QWORD *)(a2 + 16) = v18;
        if (v18)
          return tls_record_decrypt();
        else
          return 0xFFFFFFFFLL;
      }
      else if (*(_BYTE *)(a1[1] + 104))
      {
        return 4294957287;
      }
      else
      {
        return 4294957292;
      }
    }
    return result;
  }
  v7 = a1[3] + v5;
  v8 = a1[1];
  v20 = v6;
  v9 = (*(uint64_t (**)(_QWORD, unint64_t, unint64_t *))(v8 + 16))(*(_QWORD *)(v8 + 32), v7, &v20);
  if (v9 == -9803)
    v10 = -10001;
  else
    v10 = v9;
  if (!v10)
  {
    a1[4] += v20;
    goto LABEL_9;
  }
  if (v10 == -10001)
  {
LABEL_7:
    a1[4] += v20;
    return 4294957295;
  }
  return 4294957292;
}

OSStatus SSLWrite(SSLContextRef context, const void *data, size_t dataLength, size_t *processed)
{
  OSStatus v4;
  int v9;
  OSStatus v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, _BYTE *);
  _BYTE v14[8];
  size_t v15;
  const void *v16;

  v4 = -50;
  if (context && processed)
  {
    *processed = 0;
    v9 = *((_DWORD *)context + 20);
    v4 = -909;
    v10 = -9805;
    switch(v9)
    {
      case 0:
        return v4;
      case 3:
        return v10;
      case 4:
      case 6:
        return -9806;
      default:
        break;
    }
    while (!*((_DWORD *)context + 19))
    {
      v10 = SSLHandshakeProceed((uint64_t)context);
      if (v10)
        goto LABEL_16;
    }
    v10 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)context + 5) + 64))(*((_QWORD *)context + 6));
    if ((v10 + 10009) <= 9)
      v10 = dword_18AA5C3A8[v10 + 10009];
    if (!v10)
    {
      if (!dataLength)
        goto LABEL_14;
      memset(&v14[1], 170, 7);
      v11 = *((_QWORD *)context + 6);
      v12 = *(uint64_t (**)(uint64_t, _BYTE *))(*((_QWORD *)context + 5) + 8);
      v14[0] = 23;
      v15 = dataLength;
      v16 = data;
      v10 = v12(v11, v14);
      if ((v10 + 10009) <= 9)
        v10 = dword_18AA5C3A8[v10 + 10009];
      if (!v10)
      {
LABEL_14:
        *processed = dataLength;
        v10 = (*(uint64_t (**)(_QWORD))(*((_QWORD *)context + 5) + 64))(*((_QWORD *)context + 6));
        if ((v10 + 10009) <= 9)
          v10 = dword_18AA5C3A8[v10 + 10009];
      }
LABEL_16:
      if ((v10 + 9851) > 0x30 || ((1 << (v10 + 123)) & 0x1400000000605) == 0)
      {
        if (v10)
          *((_DWORD *)context + 20) = 4;
      }
    }
    return v10;
  }
  return v4;
}

uint64_t SSLRecordServiceWriteQueueInternal(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v10;

  while (1)
  {
    v2 = *(_QWORD **)(a1 + 40);
    if (!v2)
      break;
    v3 = v2[1];
    v4 = *(_QWORD *)(a1 + 8);
    v10 = v2[2] - v3;
    v5 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t *))(v4 + 24))(*(_QWORD *)(v4 + 32), (uint64_t)v2 + v3 + 24, &v10);
    if (v5 == -9803)
      v6 = 4294957295;
    else
      v6 = v5;
    v7 = v2[2];
    v8 = v2[1] + v10;
    v2[1] = v8;
    if (v8 >= v7)
    {
      *(_QWORD *)(a1 + 40) = *v2;
      free(v2);
    }
    if ((_DWORD)v6)
      return v6;
  }
  return 0;
}

uint64_t tls_handshake_write_callback(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t (*v6)(uint64_t, _BYTE *);
  _BYTE v8[8];
  uint64_t v9;
  uint64_t v10;

  v5 = *(_QWORD *)(a1 + 40);
  v4 = *(_QWORD *)(a1 + 48);
  v6 = *(uint64_t (**)(uint64_t, _BYTE *))(v5 + 8);
  v8[0] = a4;
  memset(&v8[1], 170, 7);
  v9 = a2;
  v10 = a3;
  return v6(v4, v8);
}

uint64_t SSLRecordWriteInternal(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  v2 = tls_record_encrypted_size();
  v3 = malloc_type_malloc(v2 + 24, 0xEFB4CC30uLL);
  if (!v3)
    return 4294957296;
  v4 = v3;
  *v3 = 0;
  v3[1] = 0;
  v3[2] = v2;
  v5 = tls_record_encrypt();
  if ((_DWORD)v5)
  {
    v8 = v5;
    free(v4);
  }
  else
  {
    v4[2] = v2;
    v6 = *(_QWORD **)(a1 + 40);
    if (v6)
    {
      do
      {
        v7 = v6;
        v6 = (_QWORD *)*v6;
      }
      while (v6);
      v8 = 0;
      *v7 = v4;
    }
    else
    {
      v8 = 0;
      *(_QWORD *)(a1 + 40) = v4;
    }
  }
  return v8;
}

uint64_t SSLHandshakeStart(uint64_t a1)
{
  __int128 v2;
  const __CFArray *v3;
  char *v4;
  __int128 v5;
  uint64_t v6;
  char *v8;
  _QWORD context[5];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  CC_SHA256_CTX v13;
  __int128 md;
  __int128 v15;
  uint64_t v16;
  CFRange v17;

  v16 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  md = v2;
  v15 = v2;
  v10 = 0;
  v11 = &v10;
  v12 = 0x8000000000;
  *(_OWORD *)v13.count = v2;
  *(_OWORD *)&v13.hash[2] = v2;
  *(_OWORD *)&v13.hash[6] = v2;
  *(_OWORD *)&v13.wbuf[2] = v2;
  *(_OWORD *)&v13.wbuf[6] = v2;
  *(_OWORD *)&v13.wbuf[10] = v2;
  *(_QWORD *)&v13.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
  CC_SHA256_Init(&v13);
  CC_SHA256_Update((CC_SHA256_CTX *)(v11 + 3), (const void *)(a1 + 312), 1u);
  CC_SHA256_Update((CC_SHA256_CTX *)(v11 + 3), (const void *)(a1 + 184), 1u);
  v3 = *(const __CFArray **)(a1 + 176);
  if (v3)
  {
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 0x40000000;
    context[2] = __get_extended_peer_id_block_invoke;
    context[3] = &unk_1E1FD4BB0;
    context[4] = &v10;
    v17.length = CFArrayGetCount(v3);
    v17.location = 0;
    CFArrayApplyFunction(v3, v17, (CFArrayApplierFunction)apply_block_1_6541, context);
  }
  CC_SHA256_Final((unsigned __int8 *)&md, (CC_SHA256_CTX *)(v11 + 3));
  v8 = (char *)malloc_type_malloc(*(_QWORD *)(a1 + 208) + 32, 0xEFB4CC30uLL);
  memcpy(v8, *(const void **)(a1 + 216), *(_QWORD *)(a1 + 208));
  v4 = &v8[*(_QWORD *)(a1 + 208)];
  v5 = v15;
  *(_OWORD *)v4 = md;
  *((_OWORD *)v4 + 1) = v5;
  _Block_object_dispose(&v10, 8);
  v6 = tls_handshake_negotiate();
  free(v8);
  if (!(_DWORD)v6)
  {
    *(_QWORD *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 80) = 1;
  }
  return v6;
}

BOOL __sec_protocol_options_set_tls_tickets_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFFFE7FF | (*(unsigned __int8 *)(a1 + 32) << 11) | 0x1000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFFFE7FFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }
  return a2 != 0;
}

uint64_t tls_handshake_advance_read_cipher_callback(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 40) + 40))(*(_QWORD *)(a1 + 48));
}

CFMutableArrayRef ___securityd_connection_block_invoke()
{
  NSObject *v0;
  CFMutableArrayRef result;

  sSecuritydConnectionsCount = 0;
  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  sSecuritydConnectionsQueue = (uint64_t)dispatch_queue_create("com.apple.security.securityd_connections", v0);
  result = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
  sSecuritydConnectionsPool = (uint64_t)result;
  return result;
}

Boolean SecKeyIsAlgorithmSupported(SecKeyRef key, SecKeyOperationType operation, SecKeyAlgorithm algorithm)
{
  void *v6;
  NSObject *v7;
  __CFArray *Mutable;
  __CFData *v9;
  __CFData *v10;
  __CFData *v11;
  Boolean v12;
  CFTypeRef v13;
  CFTypeRef cf;
  uint64_t v16[2];
  CFTypeRef v17;
  uint64_t v18;
  os_activity_scope_state_s state;

  v6 = (void *)MEMORY[0x18D770A24]();
  v7 = _os_activity_create(&dword_18A900000, "SecKeyIsAlgorithmSupported", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyIsAlgorithmSupported");
  v16[0] = (uint64_t)key;
  v16[1] = operation;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue(Mutable, algorithm);
  v17 = Mutable;
  v18 = 1;
  cf = 0;
  v9 = SecKeyRunAlgorithmAndCopyResult(v16, 0, 0, (__CFString **)&cf);
  v10 = v9;
  v11 = (__CFData *)*MEMORY[0x1E0C9AE50];
  if (v9 && v11)
  {
    v12 = CFEqual(v9, v11) != 0;
  }
  else
  {
    v12 = v9 == v11;
    if (!v9)
      goto LABEL_6;
  }
  CFRelease(v10);
LABEL_6:
  if (cf)
    CFRelease(cf);
  v13 = v17;
  if (v17)
  {
    v17 = 0;
    CFRelease(v13);
  }
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v6);
  return v12;
}

void sub_18A93B67C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

const void *SecAccessControlGetConstraint(uint64_t a1, const void *a2)
{
  const __CFDictionary *Value;
  const __CFDictionary *v4;
  const void *result;

  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("acl"));
  if (!Value)
    return (const void *)*MEMORY[0x1E0C9AE50];
  v4 = Value;
  if (!CFDictionaryGetCount(Value))
    return (const void *)*MEMORY[0x1E0C9AE50];
  result = CFDictionaryGetValue(v4, a2);
  if (!result)
    return CFDictionaryGetValue(v4, CFSTR("dacl"));
  return result;
}

_QWORD *SecKeyCreateRSAPrivateKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecRSAPrivateKeyDescriptor, a2, a3, a4);
}

OSStatus SecStaticCodeCreateWithPathAndAttributes(CFURLRef path, SecCSFlags flags, CFDictionaryRef attributes, SecStaticCodeRef *staticCode)
{
  const char *v8;
  const char *v9;
  void **v10;
  const NXArchInfo *v11;
  unint64_t v12;
  int v13;
  int v14;
  void **v15;
  uint64_t v16;
  const Security::CFClass *v17;
  Security::CodeSigning::SecStaticCode *v18;
  char *v19;
  Security::CodeSigning::DiskRep *v20;
  const __SecCode *v21;
  int v23;
  int v24;
  int v25;
  void *__p[2];
  uint64_t v27;
  void *v28[2];
  uint64_t v29;
  unint64_t v30;
  void **v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;

  if (flags >= 2)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v30 = 0xFFFFFFFF00000000;
  v31 = 0;
  v32 = 0;
  v33 = 0xAAAAAAAAAAAAAA00;
  v34 = 0;
  v35 = 0;
  v28[0] = 0;
  v28[1] = 0;
  v29 = 0;
  if (attributes)
  {
    __p[0] = 0;
    __p[1] = 0;
    v27 = 0;
    v24 = -1431655766;
    v25 = -1431655766;
    v23 = -1431655766;
    if (Security::cfscan((const __CFString *)attributes, "{%O=%d}", (const char *)attributes, CFSTR("UniversalFileOffset"), &v23))
    {
      v32 = v23;
LABEL_18:
      if (Security::cfscan((const __CFString *)attributes, "{%O=%s}", v8, CFSTR("bundleversion"), v28))
      {
        v15 = v28;
        if (v29 < 0)
          v15 = (void **)v28[0];
        v31 = v15;
      }
      if (SHIBYTE(v27) < 0)
        operator delete(__p[0]);
      goto LABEL_24;
    }
    if (Security::cfscan((const __CFString *)attributes, "{%O=%s}", v8, CFSTR("architecture"), __p))
    {
      if (v27 >= 0)
        v10 = __p;
      else
        v10 = (void **)__p[0];
      v11 = NXGetArchInfoFromName((const char *)v10);
      if (v11)
        v12 = *(_QWORD *)&v11->cputype;
      else
        v12 = 0;
      v30 = v12;
      goto LABEL_18;
    }
    if (Security::cfscan((const __CFString *)attributes, "{%O=%d,%O=%d}", v9, CFSTR("architecture"), &v25, CFSTR("subarchitecture"), &v24))
    {
      v14 = v24;
      v13 = v25;
    }
    else
    {
      if (!Security::cfscan((const __CFString *)attributes, "{%O=%d}", v8, CFSTR("architecture"), &v25))
        goto LABEL_18;
      v13 = v25;
      v14 = -1;
    }
    v30 = __PAIR64__(v14, v13);
    goto LABEL_18;
  }
LABEL_24:
  v16 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  v18 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate((Security::SecCFObject *)0x288, *(_QWORD *)(v16 + 200), v17);
  Security::cfString((Security *)__p, path);
  if (v27 >= 0)
    v19 = (char *)__p;
  else
    v19 = (char *)__p[0];
  v20 = (Security::CodeSigning::DiskRep *)Security::CodeSigning::DiskRep::bestGuess(v19, (unsigned int *)&v30);
  Security::CodeSigning::SecStaticCode::SecStaticCode(v18, v20, flags);
  v21 = (const __SecCode *)Security::SecCFObject::handle(v18, 1);
  if (!staticCode)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  *staticCode = v21;
  if (SHIBYTE(v27) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v29) < 0)
    operator delete(v28[0]);
  return 0;
}

void sub_18A93BB4C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  _DWORD *v28;
  void *v29;
  unsigned int v30;
  int v31;
  const char *v32;

  if (a20 < 0)
    operator delete(__p);
  if (a26 < 0)
    operator delete(a21);
  switch(a2)
  {
    case 6:
      v28 = __cxa_begin_catch(a1);
      if (v28[36] == 8)
        break;
LABEL_10:
      (*(void (**)(_DWORD *))(*(_QWORD *)v28 + 24))(v28);
      break;
    case 5:
      goto LABEL_9;
    case 4:
      v28 = __cxa_begin_catch(a1);
      v30 = v28[36];
      if (v30 > 0x1A)
        goto LABEL_10;
      v31 = 1 << v30;
      if ((v31 & 0x800108) == 0 && (v31 & 0x4014000) == 0)
        goto LABEL_10;
      break;
    case 3:
LABEL_9:
      v29 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v29 + 24))(v29);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v32);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18A93BB0CLL);
}

void sub_18A93BCE0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::DiskRep::bestGuess(char *a1, unsigned int *a2)
{
  timespec v4;
  const __CFURL *v5;
  uint64_t v6;
  const __CFURL *v7;
  const void *v8;
  Security::UnixPlusPlus::FileDesc *v9;
  int v10;
  BOOL v11;
  unsigned int st_ino_high;
  uint64_t v13;
  uint64_t v14;
  timespec v15;
  int *v16;
  void **v17;
  timespec v18;
  off_t st_size;
  timespec v20;
  char *v21;
  char *v22;
  unint64_t v23;
  const char *matched;
  int v25;
  BOOL v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  Security::Universal **v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  off_t v39;
  Security::Universal *v40;
  Security::Universal *v41;
  off_t v42;
  unsigned int v43;
  timespec v44;
  int *v45;
  uint64_t v46;
  Security::UnixPlusPlus::FileDesc *v47;
  uint64_t v48;
  void *__p[2];
  char v50;
  stat v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (a2 && *((_BYTE *)a2 + 24))
  {
LABEL_14:
    v47 = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAFFFFFFFFLL;
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v47, a1, 0, 438);
    v9 = (Security::UnixPlusPlus::FileDesc *)v47;
    memset(&v51, 170, 28);
    if (Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)v47, &v51, 0x1CuLL, 0) == 28)
    {
      v10 = -4;
      do
      {
        v11 = __CFADD__(v10++, 1);
        if (v11)
          break;
        st_ino_high = 0;
        if (v51.st_dev <= -889275715)
        {
          if (v51.st_dev != -1095041334)
            goto LABEL_24;
        }
        else
        {
          if (v51.st_dev > -822415875)
          {
            if ((v51.st_dev + 17958194) < 2)
            {
              st_ino_high = HIDWORD(v51.st_ino);
            }
            else if (v51.st_dev == -822415874 || v51.st_dev == -805638658)
            {
              st_ino_high = bswap32(HIDWORD(v51.st_ino));
            }
            goto LABEL_24;
          }
          if (v51.st_dev != -889275714)
            goto LABEL_24;
        }
      }
      while (Security::UnixPlusPlus::FileDesc::read(v9, &v51, 0x1CuLL, bswap32(v51.st_uid)) == 28);
    }
    st_ino_high = 0;
LABEL_24:
    if (st_ino_high > 0xB || ((0x9E4u >> st_ino_high) & 1) == 0)
    {
      v51.st_mtimespec.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v15.tv_sec = 0xAAAAAAAAAAAAAAAALL;
      v15.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      *(timespec *)&v51.st_uid = v15;
      v51.st_atimespec = v15;
      *(timespec *)&v51.st_dev = v15;
      if (Security::UnixPlusPlus::FileDesc::read(v9, &v51, 0x38uLL, 0) == 56
        && DYLDCache::matchArchitecture((char *)&v51))
      {
        v6 = operator new();
        std::string::basic_string[abi:ne180100]<0>(&v51, a1);
        Security::CodeSigning::SingleDiskRep::SingleDiskRep(v6, (__int128 *)&v51.st_dev);
        if (SHIBYTE(v51.st_gid) < 0)
          operator delete(*(void **)&v51.st_dev);
        *(_QWORD *)v6 = off_1E1FC8788;
        std::string::basic_string[abi:ne180100]<0>(__p, a1);
        *(_DWORD *)(v6 + 56) = -1;
        v16 = (int *)(v6 + 56);
        *(_BYTE *)(v6 + 60) = 0;
        *(_QWORD *)(v6 + 48) = &off_1E1FC7FA8;
        if (v50 >= 0)
          v17 = __p;
        else
          v17 = (void **)__p[0];
        Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)(v6 + 56), (const char *)v17, 0, 438);
        v18.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v18.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        *(timespec *)&v51.st_blksize = v18;
        *(timespec *)v51.st_qspare = v18;
        *(timespec *)&v51.st_size = v18;
        v51.st_ctimespec = v18;
        v51.st_birthtimespec = v18;
        v51.st_atimespec = v18;
        v51.st_mtimespec = v18;
        *(timespec *)&v51.st_dev = v18;
        *(timespec *)&v51.st_uid = v18;
        Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*v16, &v51);
        st_size = v51.st_size;
        *(_QWORD *)(v6 + 72) = v51.st_size;
        if (!st_size)
        {
          v20.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          v20.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          *(timespec *)&v51.st_blksize = v20;
          *(timespec *)v51.st_qspare = v20;
          *(timespec *)&v51.st_size = v20;
          v51.st_ctimespec = v20;
          v51.st_birthtimespec = v20;
          v51.st_atimespec = v20;
          v51.st_mtimespec = v20;
          *(timespec *)&v51.st_dev = v20;
          *(timespec *)&v51.st_uid = v20;
          Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*v16, &v51);
          st_size = v51.st_size;
        }
        v21 = (char *)mmap(0, st_size, 1, 2, *v16, 0);
        v22 = v21;
        if (v21 == (char *)-1)
        {
          v46 = *__error();
        }
        else
        {
          *(_QWORD *)(v6 + 64) = v21;
          v23 = *(_QWORD *)(v6 + 72);
          if (v23 > 0x37)
          {
            *(_QWORD *)(v6 + 80) = v21;
            matched = DYLDCache::matchArchitecture(v21);
            *(_QWORD *)(v6 + 88) = matched;
            if (matched)
            {
              v25 = *((unsigned __int8 *)matched + 34);
              v26 = v25 == 18;
              *(_BYTE *)(v6 + 96) = v25 != 18;
              v27 = *((_QWORD *)v22 + 5);
              v28 = bswap64(v27);
              if (!v26)
                v27 = v28;
              *(_QWORD *)(v6 + 104) = v27;
              v29 = *((_QWORD *)v22 + 6);
              v30 = bswap64(v29);
              if (!v26)
                v29 = v30;
              *(_QWORD *)(v6 + 112) = v29;
              v11 = __CFADD__(v29, v27);
              v31 = v29 + v27;
              if (v11 || v31 > v23)
                Security::UnixError::throwMe((Security::UnixError *)8);
              if (v50 < 0)
              {
                operator delete(__p[0]);
                v23 = *(_QWORD *)(v6 + 72);
                v27 = *(_QWORD *)(v6 + 104);
              }
              *(_QWORD *)(v6 + 120) = 0;
              if (v23 >= v27 + 8)
              {
                if ((unint64_t)v27 + 12 > v23)
                  Security::UnixError::throwMe((Security::UnixError *)8);
                v32 = v27 + *(_QWORD *)(v6 + 64);
                if (v23 >= v27 + bswap32(*(_DWORD *)(v32 + 4)))
                  *(_QWORD *)(v6 + 120) = v32;
              }
              (*(void (**)(stat *__return_ptr, uint64_t))(*(_QWORD *)v6 + 40))(&v51, v6);
              if (SHIBYTE(v51.st_gid) < 0)
                operator delete(*(void **)&v51.st_dev);
              goto LABEL_65;
            }
          }
          v46 = 8;
        }
        Security::UnixError::throwMe((Security::UnixError *)v46);
      }
      v6 = operator new();
      Security::CodeSigning::FileDiskRep::FileDiskRep((Security::CodeSigning::FileDiskRep *)v6, a1);
LABEL_65:
      Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v47);
      return v6;
    }
    v6 = operator new();
    std::string::basic_string[abi:ne180100]<0>(&v51, a1);
    Security::CodeSigning::SingleDiskRep::SingleDiskRep(v6, (__int128 *)&v51.st_dev);
    if (SHIBYTE(v51.st_gid) < 0)
      operator delete(*(void **)&v51.st_dev);
    *(_QWORD *)v6 = &off_1E1FC8FD0;
    *(_QWORD *)(v6 + 48) = &unk_1E1FC90F0;
    *(_QWORD *)(v6 + 64) = 0;
    if (a2)
    {
      if (*((_QWORD *)a2 + 2))
      {
        v13 = operator new();
        v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 144))(v6);
        v51.st_dev = *(_DWORD *)v14;
        LOBYTE(v51.st_mode) = *(_BYTE *)(v14 + 4);
        Security::Universal::Universal(v13, (unsigned int *)&v51, *((_QWORD *)a2 + 2), *((_QWORD *)a2 + 5));
LABEL_64:
        *(_QWORD *)(v6 + 56) = v13;
        goto LABEL_65;
      }
      if (*a2)
      {
        v35 = (Security::Universal **)operator new();
        v36 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 144))(v6);
        LODWORD(__p[0]) = *(_DWORD *)v36;
        BYTE4(__p[0]) = *(_BYTE *)(v36 + 4);
        Security::Universal::Universal((uint64_t)v35, (unsigned int *)__p, 0, 0);
        v37 = operator new();
        v38 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 144))(v6);
        LODWORD(v48) = *(_DWORD *)v38;
        BYTE4(v48) = *(_BYTE *)(v38 + 4);
        v39 = Security::Universal::archOffset((Security::Universal *)v35, (const Security::Architecture *)*a2, a2[1]);
        v40 = v35[1];
        if (v40)
        {
          v41 = v35[4];
          v42 = (off_t)v41
              + *((unsigned int *)Security::Universal::findArch(v40, (const Security::Architecture *)*((unsigned int *)v35 + 4), *a2, a2[1])+ 3);
        }
        else
        {
          if (*((_DWORD *)v35 + 5) != *a2 || (v43 = a2[1], v43 != -1) && ((*((_DWORD *)v35 + 6) ^ v43) & 0xFFFFFF) != 0)
            Security::UnixError::throwMe((Security::UnixError *)8);
          v44.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          v44.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          *(timespec *)&v51.st_blksize = v44;
          *(timespec *)v51.st_qspare = v44;
          *(timespec *)&v51.st_size = v44;
          v51.st_ctimespec = v44;
          v51.st_birthtimespec = v44;
          v51.st_atimespec = v44;
          v51.st_mtimespec = v44;
          *(timespec *)&v51.st_dev = v44;
          *(timespec *)&v51.st_uid = v44;
          Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v35, &v51);
          v42 = v51.st_size;
        }
        Security::Universal::Universal(v37, (unsigned int *)&v48, v39, v42);
        *(_QWORD *)(v6 + 56) = v37;
        free(v35[1]);
        std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v35[7]);
        MEMORY[0x18D76FAA0](v35, 0x1020C4076728D04);
        goto LABEL_65;
      }
    }
    v13 = operator new();
    v33 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 144))(v6);
    v51.st_dev = *(_DWORD *)v33;
    LOBYTE(v51.st_mode) = *(_BYTE *)(v33 + 4);
    Security::Universal::Universal(v13, (unsigned int *)&v51, 0, 0);
    goto LABEL_64;
  }
  v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v51.st_blksize = v4;
  *(timespec *)v51.st_qspare = v4;
  *(timespec *)&v51.st_size = v4;
  v51.st_ctimespec = v4;
  v51.st_birthtimespec = v4;
  v51.st_atimespec = v4;
  v51.st_mtimespec = v4;
  *(timespec *)&v51.st_dev = v4;
  *(timespec *)&v51.st_uid = v4;
  if (stat(a1, &v51))
  {
    v45 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v45);
  }
  if ((v51.st_mode & 0xF000) == 0x4000)
  {
    v6 = operator new();
    *(_DWORD *)(v6 + 8) = 0;
    *(_QWORD *)v6 = &off_1E1FC8908;
    *(_QWORD *)(v6 + 16) = &unk_1E1FC8A28;
    __p[0] = Security::makeCFURL((Security *)a1, 0, 0, v7);
    *(_QWORD *)(v6 + 24) = _CFBundleCreateUnique();
    Security::CFRef<__CFURL const*>::~CFRef((const void **)__p);
    *(_QWORD *)(v6 + 64) = 0;
    *(_QWORD *)(v6 + 32) = 0;
    *(_QWORD *)(v6 + 40) = 0;
    *(_QWORD *)(v6 + 48) = 0;
    *(_OWORD *)(v6 + 80) = 0u;
    *(_OWORD *)(v6 + 96) = 0u;
    Security::Mutex::Mutex((pthread_mutex_t *)(v6 + 112));
    *(_QWORD *)(v6 + 216) = 0;
    *(_QWORD *)(v6 + 192) = 0;
    *(_QWORD *)(v6 + 184) = v6 + 192;
    *(_QWORD *)(v6 + 224) = 0;
    *(_QWORD *)(v6 + 200) = 0;
    *(_QWORD *)(v6 + 208) = v6 + 216;
    *(_BYTE *)(v6 + 232) = 0;
    if (!*(_QWORD *)(v6 + 24))
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
    Security::CodeSigning::BundleDiskRep::setup(v6, (uint64_t)a2);
    *(_BYTE *)(v6 + 232) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v6 + 104) + 248))(*(_QWORD *)(v6 + 104));
    return v6;
  }
  __p[0] = Security::makeCFURL((Security *)a1, 0, 0, v5);
  if (!__p[0])
  {
LABEL_13:
    Security::CFRef<__CFURL const*>::~CFRef((const void **)__p);
    goto LABEL_14;
  }
  v48 = _CFBundleCreateWithExecutableURLIfMightBeBundle();
  if (!v48)
  {
    Security::CFRef<__CFBundle *>::~CFRef((const void **)&v48);
    goto LABEL_13;
  }
  v6 = operator new();
  v8 = (const void *)v48;
  *(_DWORD *)(v6 + 8) = 0;
  *(_QWORD *)v6 = &off_1E1FC8908;
  *(_QWORD *)(v6 + 16) = &unk_1E1FC8A28;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_QWORD *)(v6 + 64) = 0;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  Security::Mutex::Mutex((pthread_mutex_t *)(v6 + 112));
  *(_QWORD *)(v6 + 216) = 0;
  *(_QWORD *)(v6 + 192) = 0;
  *(_QWORD *)(v6 + 184) = v6 + 192;
  *(_QWORD *)(v6 + 224) = 0;
  *(_QWORD *)(v6 + 200) = 0;
  *(_QWORD *)(v6 + 208) = v6 + 216;
  CFRetain(v8);
  if (*(_QWORD *)(v6 + 24))
    CFRelease(*(CFTypeRef *)(v6 + 24));
  *(_QWORD *)(v6 + 24) = v8;
  Security::CodeSigning::BundleDiskRep::setup(v6, (uint64_t)a2);
  *(_BYTE *)(v6 + 232) = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v6 + 104) + 248))(*(_QWORD *)(v6 + 104));
  Security::CFRef<__CFBundle *>::~CFRef((const void **)&v48);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)__p);
  return v6;
}

void sub_18A93C6E4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;
  uint64_t v27;
  void *v30;

  free(*(void **)(v27 + 8));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)(v27 + 56));
  MEMORY[0x18D76FAA0](v27, 0x1020C4076728D04);
  *(_QWORD *)v26 = off_1E1FC8C10;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(v26 + 40));
  if (*(char *)(v26 + 39) < 0)
    operator delete(*(void **)(v26 + 16));
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)v26);
  MEMORY[0x18D76FAA0](v26, 0x10B3C40BD7F8033);
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&a10);
  if (a2 == 1)
  {
    v30 = __cxa_begin_catch(a1);
    if ((*(unsigned int (**)(void *))(*(_QWORD *)v30 + 32))(v30) == 2)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA04);
    __cxa_rethrow();
  }
  JUMPOUT(0x18A93CA8CLL);
}

void sub_18A93CA78()
{
  __cxa_end_catch();
  JUMPOUT(0x18A93CA8CLL);
}

void sub_18A93CA84(_Unwind_Exception *exception_object, int a2)
{
  if (!a2)
    _Unwind_Resume(exception_object);
  __clang_call_terminate(exception_object);
}

uint64_t Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()()
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EDF7ADA0);
  if (!Security::CodeSigning::gCFObjects)
    Security::CodeSigning::gCFObjects = Security::ModuleNexusCommon::create((Security::ModuleNexusCommon *)&Security::CodeSigning::gCFObjects, (void *(*)(void))Security::ModuleNexus<Security::CodeSigning::CFObjects>::make);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EDF7ADA0);
  return Security::CodeSigning::gCFObjects;
}

void sub_18A93CAF8(void *a1)
{
  __cxa_begin_catch(a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EDF7ADA0);
  __cxa_rethrow();
}

void sub_18A93CB10(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::SingleDiskRep::SingleDiskRep(uint64_t a1, __int128 *a2)
{
  std::string *v3;
  __int128 v4;

  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = off_1E1FC8C10;
  v3 = (std::string *)(a1 + 16);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v4 = *a2;
    v3->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = v4;
  }
  *(_DWORD *)(a1 + 40) = -1;
  *(_BYTE *)(a1 + 44) = 0;
  return a1;
}

void sub_18A93CB88(_Unwind_Exception *a1)
{
  Security::CodeSigning::DiskRep *v1;

  Security::CodeSigning::DiskRep::~DiskRep(v1);
  _Unwind_Resume(a1);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

uint64_t Security::SecCFObject::allocate(Security::SecCFObject *this, unint64_t a2, const Security::CFClass *a3)
{
  uint64_t Instance;
  std::bad_alloc *exception;
  std::bad_alloc *v6;

  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v6 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v6, MEMORY[0x1E0DE4EA8], MEMORY[0x1E0DE4DC0]);
  }
  atomic_store(0, (unsigned __int8 *)(Instance + 16));
  return Instance + 24;
}

BOOL Security::UnixPlusPlus::FileDesc::hasExtendedAttribute(Security::UnixPlusPlus::FileDesc *this, const char *a2)
{
  ssize_t v2;
  _BOOL8 result;
  int *v4;
  int v5;
  int *v6;

  v2 = fgetxattr((int)this, a2, 0, 0, 0, 0);
  if (v2 != -1)
    return v2 != 0;
  v4 = __error();
  result = 0;
  v5 = *v4;
  if (v5 != 1 && v5 != 93)
  {
    v6 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v6);
  }
  return result;
}

BOOL Security::CodeSigning::SingleDiskRep::appleInternalForcePlatform(Security::CodeSigning::SingleDiskRep *this)
{
  return Security::UnixPlusPlus::FileDesc::hasExtendedAttribute((Security::UnixPlusPlus::FileDesc *)*((unsigned int *)this + 10), "com.apple.root.installed");
}

uint64_t Security::Universal::Universal(uint64_t a1, unsigned int *a2, off_t a3, uint64_t a4)
{
  int v6;
  NSObject *v7;
  const NXArchInfo *v8;
  __darwin_ino64_t name;
  unsigned int v10;
  size_t v11;
  void *v12;
  ssize_t v13;
  char *v14;
  int8x16_t *v15;
  int v16;
  int8x16_t *v17;
  NSObject *v18;
  uint64_t **v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t **v23;
  uint64_t *v24;
  const NXArchInfo *v25;
  uint64_t **v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  unint64_t v35;
  _OWORD *v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  unint64_t v40;
  unsigned int v41;
  uint64_t v43;
  Security::Allocator *v44;
  uint64_t v45;
  unint64_t v46;
  size_t v47;
  ssize_t v48;
  Security::Allocator *v49;
  int v50;
  NSObject *v51;
  NSObject *v52;
  const char *v53;
  uint64_t *v54;
  NSObject *v55;
  NSObject *v56;
  timespec v57;
  NSObject *v58;
  timespec v59;
  const char *v60;
  stat *p_buf;
  NSObject *v62;
  uint32_t v63;
  NSObject *v64;
  int v66;
  NSObject *v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  __int128 v71;
  uint64_t *v72;
  uint64_t **v73;
  unint64_t v74;
  int8x8_t v75[4];
  int v76;
  uint64_t v77;
  __int16 v78;
  off_t st_size;
  stat buf;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a1 = *a2;
  *(_BYTE *)(a1 + 4) = *((_BYTE *)a2 + 4);
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = a4;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  v70 = (_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 48) = a1 + 56;
  *(_DWORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 76) = 0;
  memset(v75, 170, 28);
  if (Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*a2, v75, 0x1CuLL, a3) != 28)
    goto LABEL_87;
  if (v75[0].i32[0] <= -805638659)
  {
    if (v75[0].i32[0] != -1095041334 && v75[0].i32[0] != -889275714)
    {
      v6 = -822415874;
      goto LABEL_24;
    }
    v10 = bswap32(v75[0].u32[1]);
    *(_DWORD *)(a1 + 16) = v10;
    if (v10 > 0x64)
      goto LABEL_87;
    v11 = 20 * (v10 + 1);
    v12 = malloc_type_malloc(v11, 0x84149076uLL);
    *(_QWORD *)(a1 + 8) = v12;
    if (v12)
    {
      v13 = Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*a2, v12, v11, *(_QWORD *)(a1 + 32) + 8);
      v14 = *(char **)(a1 + 8);
      if (v13 == v11)
      {
        v15 = *(int8x16_t **)(a1 + 8);
        do
        {
          *v15 = vrev32q_s8(*v15);
          v15[1].i32[0] = bswap32(v15[1].u32[0]);
          v16 = *(_DWORD *)(a1 + 16);
          v17 = (int8x16_t *)&v14[20 * v16];
          v15 = (int8x16_t *)((char *)v15 + 20);
        }
        while (v15 <= v17);
        if (v17->i32[0] == 16777228)
          *(_DWORD *)(a1 + 16) = v16 + 1;
        v18 = secLogObjForScope("macho");
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          v66 = *(_DWORD *)(a1 + 16);
          buf.st_dev = 134218240;
          *(_QWORD *)&buf.st_mode = a1;
          WORD2(buf.st_ino) = 1024;
          *(_DWORD *)((char *)&buf.st_ino + 6) = v66;
          _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%p is a fat file with %d architectures", (uint8_t *)&buf, 0x12u);
        }
        v19 = &v72;
        v72 = (uint64_t *)&v72;
        v73 = &v72;
        v74 = 0;
        v20 = *(unsigned int *)(a1 + 16);
        if ((_DWORD)v20)
        {
          v21 = 0;
          v22 = *(_QWORD *)(a1 + 8);
          v23 = &v72;
          do
          {
            v24 = (uint64_t *)operator new(0x18uLL);
            v24[1] = (uint64_t)&v72;
            v24[2] = v22;
            *v24 = (uint64_t)v23;
            v23[1] = v24;
            ++v21;
            v22 += 20;
            v23 = (uint64_t **)v24;
            v72 = v24;
            v74 = v21;
          }
          while (v20 != v21);
          v19 = v73;
        }
        else
        {
          v21 = 0;
        }
        *(_QWORD *)&buf.st_dev = &__block_literal_global_13521;
        std::list<fat_arch *>::__sort<BOOL({block_pointer})(fat_arch const*,fat_arch const*)>(v19, &v72, v21, (uint64_t)&buf);
        v26 = v73;
        if (v73 == &v72)
        {
          v28 = 0;
          v27 = 0;
LABEL_71:
          if (!*(_BYTE *)(a1 + 76))
          {
            v57.tv_sec = 0xAAAAAAAAAAAAAAAALL;
            v57.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
            *(timespec *)&buf.st_blksize = v57;
            *(timespec *)buf.st_qspare = v57;
            buf.st_birthtimespec = v57;
            *(timespec *)&buf.st_size = v57;
            buf.st_mtimespec = v57;
            buf.st_ctimespec = v57;
            *(timespec *)&buf.st_uid = v57;
            buf.st_atimespec = v57;
            *(timespec *)&buf.st_dev = v57;
            Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*a2, &buf);
            if (v27 + v28 != buf.st_size)
            {
              v58 = secLogObjForScope("SecError");
              if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
              {
                v59.tv_sec = 0xAAAAAAAAAAAAAAAALL;
                v59.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
                *(timespec *)&buf.st_blksize = v59;
                *(timespec *)buf.st_qspare = v59;
                buf.st_birthtimespec = v59;
                *(timespec *)&buf.st_size = v59;
                buf.st_mtimespec = v59;
                buf.st_ctimespec = v59;
                *(timespec *)&buf.st_uid = v59;
                buf.st_atimespec = v59;
                *(timespec *)&buf.st_dev = v59;
                Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*a2, &buf);
                v76 = 134218240;
                v77 = v27 + v28;
                v78 = 2048;
                st_size = buf.st_size;
                v60 = "STRICT VALIDATION ERROR: Extra data after the last slice in a universal file (expected %zu found %zu)";
                p_buf = (stat *)&v76;
                v62 = v58;
                v63 = 22;
                goto LABEL_77;
              }
LABEL_78:
              *(_BYTE *)(a1 + 76) = 1;
            }
          }
          std::__list_imp<fat_arch *>::clear(&v72);
          return a1;
        }
        v27 = 0;
        v28 = 0;
        v29 = *(_QWORD *)(a1 + 32) + 20 * *(unsigned int *)(a1 + 16) + 8;
        v69 = v29;
        while (1)
        {
          v30 = v26[2][1];
          *(_QWORD *)&v31 = v30;
          *((_QWORD *)&v31 + 1) = HIDWORD(v30);
          v71 = v31;
          v32 = v70;
          v33 = (_QWORD *)*v70;
          v34 = v70;
          if (*v70)
          {
            do
            {
              while (1)
              {
                v32 = v33;
                v35 = v33[4];
                if ((unint64_t)v71 >= v35)
                  break;
                v33 = (_QWORD *)*v32;
                v34 = v32;
                if (!*v32)
                  goto LABEL_38;
              }
              if (v35 >= (unint64_t)v71)
              {
                free(*(void **)(a1 + 8));
                v67 = secLogObjForScope("SecError");
                if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf.st_dev) = 0;
                  _os_log_impl(&dword_18A900000, v67, OS_LOG_TYPE_DEFAULT, "Error processing fat file: Two architectures have the same size", (uint8_t *)&buf, 2u);
                }
                Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEF7A9);
              }
              v33 = (_QWORD *)v32[1];
            }
            while (v33);
            v34 = v32 + 1;
          }
LABEL_38:
          v36 = operator new(0x30uLL);
          v36[2] = v71;
          *(_QWORD *)v36 = 0;
          *((_QWORD *)v36 + 1) = 0;
          *((_QWORD *)v36 + 2) = v32;
          *v34 = v36;
          v37 = **(_QWORD **)(a1 + 48);
          if (v37)
          {
            *(_QWORD *)(a1 + 48) = v37;
            v36 = (_OWORD *)*v34;
          }
          v38 = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 56), (uint64_t *)v36);
          ++*(_QWORD *)(a1 + 64);
          v39 = v26[2];
          v40 = *((unsigned int *)v39 + 2) - v29;
          if (v29 != v69)
          {
            v41 = *((_DWORD *)v39 + 4);
            if (v41 > 0x1E || v40 >= 1 << v41)
            {
              v64 = secLogObjForScope("SecError");
              if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf.st_dev) = 0;
                v60 = "STRICT VALIDATION ERROR: the size of the padding after the universal cannot be calculated to a fixed size";
                p_buf = &buf;
                v62 = v64;
                v63 = 2;
LABEL_77:
                _os_log_impl(&dword_18A900000, v62, OS_LOG_TYPE_DEFAULT, v60, (uint8_t *)p_buf, v63);
              }
              goto LABEL_78;
            }
          }
          v43 = Security::Allocator::standard((Security::Allocator *)v38);
          v44 = (Security::Allocator *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v43 + 16))(v43, *MEMORY[0x1E0C85AD8]);
          v45 = Security::Allocator::standard(v44);
          v46 = 0;
LABEL_46:
          if (v40 > v46)
            break;
LABEL_60:
          if (v46 != v40)
          {
            v56 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              buf.st_dev = 134218240;
              *(_QWORD *)&buf.st_mode = v46;
              WORD2(buf.st_ino) = 2048;
              *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = v40;
              _os_log_impl(&dword_18A900000, v56, OS_LOG_TYPE_DEFAULT, "STRICT VALIDATION ERROR: gap size does not match expected (%zu != %zu)", (uint8_t *)&buf, 0x16u);
            }
            *(_BYTE *)(a1 + 76) = 1;
LABEL_70:
            (*(void (**)(uint64_t, Security::Allocator *))(*(_QWORD *)v45 + 24))(v45, v44);
            goto LABEL_71;
          }
          if (*(_BYTE *)(a1 + 76))
            goto LABEL_70;
          v54 = v26[2];
          v27 = *((unsigned int *)v54 + 2);
          v28 = *((unsigned int *)v54 + 3);
          v29 = (v28 + v27);
          (*(void (**)(uint64_t, Security::Allocator *))(*(_QWORD *)v45 + 24))(v45, v44);
          v26 = (uint64_t **)v26[1];
          if (v26 == &v72)
            goto LABEL_71;
        }
        if (*MEMORY[0x1E0C85AD8] >= v40 - v46)
          v47 = v40 - v46;
        else
          v47 = *MEMORY[0x1E0C85AD8];
        v48 = Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*a2, v44, v47, v46 + v29);
        if (v48)
        {
          v46 += v48;
          v49 = v44;
          while (1)
          {
            v50 = *(unsigned __int8 *)v49;
            v49 = (Security::Allocator *)((char *)v49 + 1);
            if (v50)
              break;
            if (!--v48)
            {
              if (!*(_BYTE *)(a1 + 76))
                goto LABEL_46;
              goto LABEL_60;
            }
          }
          v51 = secLogObjForScope("SecError");
          if (!os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
            goto LABEL_59;
          LOWORD(buf.st_dev) = 0;
          v52 = v51;
          v53 = "STRICT VALIDATION ERROR: non-zero gap byte found";
        }
        else
        {
          v55 = secLogObjForScope("SecError");
          if (!os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
            goto LABEL_59;
          LOWORD(buf.st_dev) = 0;
          v52 = v55;
          v53 = "STRICT VALIDATION ERROR: failed to read expected gap bytes";
        }
        _os_log_impl(&dword_18A900000, v52, OS_LOG_TYPE_DEFAULT, v53, (uint8_t *)&buf, 2u);
LABEL_59:
        *(_BYTE *)(a1 + 76) = 1;
        goto LABEL_60;
      }
      free(v14);
      v68 = 8;
    }
    else
    {
      v68 = *__error();
    }
    Security::UnixError::throwMe((Security::UnixError *)v68);
  }
  if ((v75[0].i32[0] + 17958194) >= 2)
  {
    v6 = -805638658;
LABEL_24:
    if (v75[0].i32[0] == v6)
    {
      *(_QWORD *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 16) = 0;
      *(int8x8_t *)(a1 + 20) = vrev32_s8(*(int8x8_t *)((char *)v75 + 4));
      v7 = secLogObjForScope("macho");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v25 = NXGetArchInfoFromCpuType(*(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24) & 0xFFFFFF);
        if (v25)
          name = (__darwin_ino64_t)v25->name;
        else
          name = 0;
LABEL_83:
        buf.st_dev = 134218242;
        *(_QWORD *)&buf.st_mode = a1;
        WORD2(buf.st_ino) = 2080;
        *(__darwin_ino64_t *)((char *)&buf.st_ino + 6) = name;
        _os_log_debug_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEBUG, "%p is a thin file (%s)", (uint8_t *)&buf, 0x16u);
        return a1;
      }
      return a1;
    }
LABEL_87:
    Security::UnixError::throwMe((Security::UnixError *)8);
  }
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(int8x8_t *)(a1 + 20) = *(int8x8_t *)((char *)v75 + 4);
  v7 = secLogObjForScope("macho");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v8 = NXGetArchInfoFromCpuType(*(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24) & 0xFFFFFF);
    if (v8)
      name = (__darwin_ino64_t)v8->name;
    else
      name = 0;
    goto LABEL_83;
  }
  return a1;
}

void sub_18A93D538(_Unwind_Exception *a1, uint64_t a2, _QWORD **a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  std::__list_imp<fat_arch *>::clear((uint64_t *)va);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*a3);
  _Unwind_Resume(a1);
}

const void *Security::SecCFObject::handle(Security::SecCFObject *this, int a2)
{
  const void *v4;
  const void *v5;
  unsigned __int8 *v6;
  unsigned __int8 v7;

  v4 = (const void *)(*(uint64_t (**)(Security::SecCFObject *))(*(_QWORD *)this + 16))(this);
  v5 = v4;
  if (a2)
  {
    v6 = (unsigned __int8 *)this - 8;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(1u, v6));
    if ((v7 & 1) != 0)
      CFRetain(v4);
  }
  return v5;
}

Security::CodeSigning::SecStaticCode *Security::CodeSigning::SecStaticCode::SecStaticCode(Security::CodeSigning::SecStaticCode *this, Security::CodeSigning::DiskRep *a2, int a3)
{
  unsigned int *v6;
  unsigned int v7;
  NSObject *v8;
  dispatch_queue_t v9;

  *((_QWORD *)this + 1) = 1;
  *(_QWORD *)this = off_1E1FC8B50;
  *((_QWORD *)this + 2) = 0;
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)this + 40));
  if (a2)
  {
    v6 = (unsigned int *)((char *)a2 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 4) = a2;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 13) = (char *)this + 112;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_QWORD *)this + 18) = (char *)this + 152;
  *((_BYTE *)this + 176) = 0;
  *((_BYTE *)this + 185) = 0;
  *((_BYTE *)this + 192) = 0;
  *((_QWORD *)this + 28) = &off_1E1FC93C0;
  *((_QWORD *)this + 25) = 0;
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)this + 232));
  *((_BYTE *)this + 296) = 0;
  *((_QWORD *)this + 38) = 0;
  v8 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UNSPECIFIED, 0);
  v9 = dispatch_queue_create("com.apple.security.validation-progress", v8);
  *(_OWORD *)((char *)this + 360) = 0u;
  *((_QWORD *)this + 39) = v9;
  *((_QWORD *)this + 40) = 0;
  *(_OWORD *)((char *)this + 328) = 0u;
  *((_QWORD *)this + 43) = (char *)this + 352;
  *((_QWORD *)this + 44) = 0;
  *((_QWORD *)this + 69) = 0;
  *((_BYTE *)this + 560) = 0;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *((_QWORD *)this + 67) = 0;
  *((_QWORD *)this + 73) = 0;
  *(_OWORD *)((char *)this + 568) = 0u;
  *((_DWORD *)this + 148) = a3;
  *((_WORD *)this + 298) = 0;
  *((_QWORD *)this + 75) = 0x7FF8000000000000;
  *((_BYTE *)this + 608) = 1;
  *((_DWORD *)this + 159) = 0;
  *((_QWORD *)this + 80) = 0;
  *(_OWORD *)((char *)this + 616) = 0u;
  *((_BYTE *)this + 632) = 0;
  return this;
}

void sub_18A93D7B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, const void **a17, const void **a18)
{
  uint64_t v18;
  const void **v19;
  const void **v20;
  Security::Dispatch::Queue *v21;
  const void **v22;
  _QWORD **v23;
  const void **v24;
  const void **v25;
  const void **v26;
  uint64_t i;
  const void **v29;

  v29 = v25;
  Security::CFRef<__CFDictionary const*>::~CFRef(v22);
  Security::CFRef<__CFArray const*>::~CFRef((const void **)(v18 + 624));
  Security::CFRef<__SecTrust *>::~CFRef(v24);
  Security::CFRef<__CFURL const*>::~CFRef(v26);
  Security::CFRef<__CFData const*>::~CFRef(a17);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)(v18 + 536));
  Security::CFRef<__CFArray const*>::~CFRef((const void **)(v18 + 528));
  Security::CFRef<__CFData const*>::~CFRef((const void **)(v18 + 520));
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)(v18 + 504));
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)(v18 + 496));
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)(v18 + 488));
  for (i = 0; i != -96; i -= 8)
    Security::CFRef<__CFData const*>::~CFRef((const void **)(v18 + 480 + i));
  Security::CFRef<__CFData const*>::~CFRef(v20);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*v23);
  Security::CFRef<__CFData const*>::~CFRef(v29);
  Security::Dispatch::Queue::~Queue(v21);
  Security::CFRef<__CFArray const*>::~CFRef(a18);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)(v18 + 152));
  Security::CFRef<__CFData const*>::~CFRef((const void **)(v18 + 136));
  Security::CFRef<__CFData const*>::~CFRef(v19);
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*(const void ***)(v18 + 112));
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((_QWORD *)(v18 + 32));
  _Unwind_Resume(a1);
}

__CFBundle *__getNSPinnedIdentitiesForHostName_block_invoke()
{
  __CFBundle *result;
  const __CFDictionary *v1;
  CFTypeID v2;
  CFTypeID v3;

  result = CFBundleGetMainBundle();
  if (!result)
    goto LABEL_7;
  result = CFBundleGetInfoDictionary(result);
  if (!result)
    goto LABEL_7;
  result = (__CFBundle *)CFDictionaryGetValue(result, CFSTR("NSAppTransportSecurity"));
  if (!result
    || (v1 = result, v2 = CFGetTypeID(result),
                     result = (__CFBundle *)CFDictionaryGetTypeID(),
                     (__CFBundle *)v2 != result)
    || (result = (__CFBundle *)CFDictionaryGetValue(v1, CFSTR("NSPinnedDomains")),
        (getNSPinnedIdentitiesForHostName_nsPinnedDomainsDict = (uint64_t)result) == 0)
    || (v3 = CFGetTypeID(result), result = (__CFBundle *)CFDictionaryGetTypeID(), (__CFBundle *)v3 != result))
  {
LABEL_7:
    getNSPinnedIdentitiesForHostName_nsPinnedDomainsDict = 0;
  }
  return result;
}

void SecRSAPrivateKeyDestroy(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 24))
  {
    cc_clear();
    free(*(void **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = 0;
  }
}

OSStatus SSLSetIOFuncs(SSLContextRef context, SSLReadFunc readFunc, SSLWriteFunc writeFunc)
{
  OSStatus result;
  unsigned int v5;
  BOOL v6;
  int v7;

  if (!context)
    return -50;
  if (*((uint64_t (***)())context + 5) != SSLRecordLayerInternal)
    return -909;
  v5 = *((_DWORD *)context + 20);
  v6 = v5 > 6;
  v7 = (1 << v5) & 0x59;
  if (v6 || v7 == 0)
    return -909;
  result = 0;
  *((_QWORD *)context + 2) = readFunc;
  *((_QWORD *)context + 3) = writeFunc;
  return result;
}

OSStatus SSLSetConnection(SSLContextRef context, SSLConnectionRef connection)
{
  OSStatus result;
  unsigned int v4;
  BOOL v5;
  int v6;

  if (!context)
    return -50;
  if (*((uint64_t (***)())context + 5) != SSLRecordLayerInternal)
    return -909;
  v4 = *((_DWORD *)context + 20);
  v5 = v4 > 6;
  v6 = (1 << v4) & 0x59;
  if (v5 || v6 == 0)
    return -909;
  result = 0;
  *((_QWORD *)context + 4) = connection;
  return result;
}

SecTrustRef SecTrustDeserialize(CFDataRef theData, __CFString **a2, uint64_t a3)
{
  CFTypeRef v4;
  const void *v5;
  CFTypeID TypeID;
  const void *Value;
  CFMutableArrayRef v8;
  CFMutableArrayRef v9;
  const __CFArray *v10;
  const __CFArray *v11;
  CFTypeID v12;
  CFIndex Count;
  CFMutableArrayRef Mutable;
  OSStatus v15;
  const void *v16;
  const void *v17;
  CFTypeID v18;
  CFMutableArrayRef v19;
  const void *v20;
  const void *v21;
  CFTypeID v22;
  const void *v23;
  const void *v24;
  CFTypeID v25;
  const void *v26;
  const void *v27;
  CFTypeID v28;
  const void *v29;
  const void *v30;
  CFTypeID v31;
  const void *v32;
  const void *v33;
  CFTypeID v34;
  CFMutableArrayRef v35;
  const void *v36;
  const void *v37;
  CFTypeID v38;
  const void *v39;
  const void *v40;
  CFTypeID v41;
  const void *v42;
  const void *v43;
  CFTypeID v44;
  const __CFNumber *v45;
  const __CFNumber *v46;
  CFTypeID v47;
  int v48;
  int v49;
  const void *v50;
  SecTrustRef v51;
  BOOL v52;
  SecTrustRef v53;
  int valuePtr;
  SecTrustRef trust;
  CFRange v57;

  if (!theData)
  {
    SecError(-50, a2, CFSTR("null serialized trust input"));
    return 0;
  }
  v4 = CFPropertyListCreateWithDERData(0, theData, a3, 0, (CFTypeRef *)a2);
  if (!v4)
    return 0;
  v5 = v4;
  trust = 0;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v5))
    goto LABEL_57;
  Value = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("certificates"));
  if (!Value)
    goto LABEL_57;
  v8 = SecCertificateArrayDeserialize(Value);
  if (!v8)
    goto LABEL_57;
  v9 = v8;
  v10 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("policies"));
  if (!v10
    || (v11 = v10, v12 = CFGetTypeID(v10), v12 != CFArrayGetTypeID())
    || (Count = CFArrayGetCount(v11),
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]),
        v57.location = 0,
        v57.length = Count,
        CFArrayApplyFunction(v11, v57, (CFArrayApplierFunction)deserializePolicy, Mutable),
        !Mutable))
  {
    CFRelease(v9);
LABEL_57:
    v53 = 0;
    v49 = -50;
    goto LABEL_58;
  }
  v15 = SecTrustCreateWithCertificates(v9, Mutable, &trust);
  if (v15)
  {
    v49 = v15;
    v53 = 0;
    goto LABEL_53;
  }
  v16 = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("anchors"));
  if (v16)
  {
    v17 = v16;
    v18 = CFGetTypeID(v16);
    if (v18 == CFArrayGetTypeID())
    {
      v19 = SecCertificateArrayDeserialize(v17);
      *((_QWORD *)trust + 3) = v19;
    }
  }
  v20 = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("responses"));
  if (v20)
  {
    v21 = v20;
    v22 = CFGetTypeID(v20);
    if (v22 == CFArrayGetTypeID())
    {
      CFRetain(v21);
      *((_QWORD *)trust + 5) = v21;
    }
  }
  v23 = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("scts"));
  if (v23)
  {
    v24 = v23;
    v25 = CFGetTypeID(v23);
    if (v25 == CFArrayGetTypeID())
    {
      CFRetain(v24);
      *((_QWORD *)trust + 6) = v24;
    }
  }
  v26 = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("trustedLogs"));
  if (v26)
  {
    v27 = v26;
    v28 = CFGetTypeID(v26);
    if (v28 == CFArrayGetTypeID())
    {
      CFRetain(v27);
      *((_QWORD *)trust + 7) = v27;
    }
  }
  v29 = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("verifyDate"));
  if (v29)
  {
    v30 = v29;
    v31 = CFGetTypeID(v29);
    if (v31 == CFDateGetTypeID())
    {
      CFRetain(v30);
      *((_QWORD *)trust + 8) = v30;
    }
  }
  v32 = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("chain"));
  if (v32)
  {
    v33 = v32;
    v34 = CFGetTypeID(v32);
    if (v34 == CFArrayGetTypeID())
    {
      v35 = SecCertificateArrayDeserialize(v33);
      *((_QWORD *)trust + 9) = v35;
    }
  }
  v36 = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("details"));
  if (v36)
  {
    v37 = v36;
    v38 = CFGetTypeID(v36);
    if (v38 == CFArrayGetTypeID())
    {
      CFRetain(v37);
      *((_QWORD *)trust + 11) = v37;
    }
  }
  v39 = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("info"));
  if (v39)
  {
    v40 = v39;
    v41 = CFGetTypeID(v39);
    if (v41 == CFDictionaryGetTypeID())
    {
      CFRetain(v40);
      *((_QWORD *)trust + 12) = v40;
    }
  }
  v42 = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("exceptions"));
  if (v42)
  {
    v43 = v42;
    v44 = CFGetTypeID(v42);
    if (v44 == CFArrayGetTypeID())
    {
      CFRetain(v43);
      *((_QWORD *)trust + 13) = v43;
    }
  }
  valuePtr = -1;
  v45 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("result"));
  v46 = v45;
  if (v45)
  {
    v47 = CFGetTypeID(v45);
    if (v47 == CFNumberGetTypeID())
    {
      v48 = CFNumberGetValue(v46, kCFNumberSInt32Type, &valuePtr);
      LODWORD(v46) = 0;
      v49 = -50;
      if (v48 && (valuePtr & 0x80000000) == 0)
      {
        v49 = 0;
        *((_DWORD *)trust + 28) = valuePtr;
        LODWORD(v46) = 1;
      }
      goto LABEL_44;
    }
    LODWORD(v46) = 0;
  }
  v49 = -50;
LABEL_44:
  if (CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("anchorsOnly")) == (const void *)*MEMORY[0x1E0C9AE50])
    *((_BYTE *)trust + 116) = 1;
  v50 = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("keychainsAllowed"));
  v51 = trust;
  if (v50 == (const void *)*MEMORY[0x1E0C9AE40])
    *((_BYTE *)trust + 117) = 0;
  v52 = (_DWORD)v46 == 0;
  if ((_DWORD)v46)
    v53 = v51;
  else
    v53 = 0;
  if (!v52)
    v49 = 0;
LABEL_53:
  CFRelease(Mutable);
  CFRelease(v9);
  if (v49)
LABEL_58:
    SecError(v49, a2, CFSTR("unable to create trust ref"));
  CFRelease(v5);
  return v53;
}

CFMutableArrayRef SecCertificateArrayDeserialize(const void *a1)
{
  CFTypeID v2;
  CFIndex Count;
  CFMutableArrayRef Mutable;
  CFRange v6;

  v2 = CFGetTypeID(a1);
  if (v2 != CFArrayGetTypeID())
    return 0;
  Count = CFArrayGetCount((CFArrayRef)a1);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
  v6.location = 0;
  v6.length = Count;
  CFArrayApplyFunction((CFArrayRef)a1, v6, (CFArrayApplierFunction)deserializeCert, Mutable);
  return Mutable;
}

uint64_t SecItemRawUpdate(const __CFString *a1, const __CFDictionary *a2, CFTypeRef *a3)
{
  CFMutableDictionaryRef Mutable;
  uint64_t (*v7)(const __CFString *, CFMutableDictionaryRef, uint64_t, CFTypeRef *);
  uint64_t v8;
  uint64_t v9;
  xpc_object_t message;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  _QWORD context[5];

  if (gSecurityd)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], 0);
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 3221225472;
    context[2] = __SecItemRawUpdate_block_invoke;
    context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    context[4] = Mutable;
    CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)apply_block_2_8228, context);
    v7 = *(uint64_t (**)(const __CFString *, CFMutableDictionaryRef, uint64_t, CFTypeRef *))(gSecurityd + 16);
    v8 = SecSecurityClientGet();
    v9 = v7(a1, Mutable, v8, a3);
    CFRelease(Mutable);
  }
  else
  {
    message = securityd_create_message(2u, a3);
    v15 = message;
    if (message
      && SecXPCDictionarySetPListWithRepair(message, "query", a1, (__CFString **)a3, v11, v12, v13, v14)
      && SecXPCDictionarySetPListWithRepair(v15, "attributesToUpdate", (const __CFString *)a2, (__CFString **)a3, v16, v17, v18, v19))
    {
      logUnreasonableDataLength(a2);
      v20 = securityd_message_with_reply_sync(v15, (uint64_t)a3);
      v21 = (void *)v20;
      if (v20)
        v9 = securityd_message_no_error(v20, (CFErrorRef *)a3);
      else
        v9 = 0;

    }
    else
    {
      v9 = 0;
    }

  }
  return v9;
}

uint64_t isModifyingAPIRateWithinLimits()
{
  void *v0;
  uint64_t v1;

  +[SecItemRateLimit instance](SecItemRateLimit, "instance");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = objc_msgSend(v0, "isModifyingAPICallWithinLimits");

  return v1;
}

void logUnreasonableDataLength(const void *a1)
{
  CFTypeID v2;
  const __CFData *Value;
  const __CFData *v4;
  CFTypeID v5;
  CFIndex Length;
  CFIndex v7;
  NSObject *v8;
  int v9;
  CFIndex v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = CFGetTypeID(a1);
    if (v2 == CFDictionaryGetTypeID())
    {
      Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("v_Data"));
      if (Value)
      {
        v4 = Value;
        v5 = CFGetTypeID(Value);
        if (v5 == CFDataGetTypeID())
        {
          Length = CFDataGetLength(v4);
          if (Length > 0x8000)
          {
            v7 = Length;
            secLogObjForScope("SecWarning");
            v8 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
            {
              v9 = 134217984;
              v10 = v7;
              _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "keychain item data exceeds reasonable size (%lu bytes)", (uint8_t *)&v9, 0xCu);
            }

          }
        }
      }
    }
  }
}

uint64_t tls_handshake_message_callback(uint64_t a1, int a2)
{
  uint64_t result;
  _QWORD *peer_alpn_data;
  void (*v5)(uint64_t, _QWORD, _QWORD, _QWORD);
  _QWORD *v6;
  uint64_t peer_signature_algorithms;

  result = 0;
  if (a2 > 12)
  {
    switch(a2)
    {
      case 67:
        result = tls_handshake_get_peer_npn_data();
        if (!result)
          return result;
        (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a1 + 520))(a1, *(_QWORD *)(a1 + 528), *(_QWORD *)(result + 8), *(_QWORD *)result);
        break;
      case 14:
        return tls_verify_peer_cert(a1);
      case 13:
        *(_DWORD *)(a1 + 256) = 1;
        *(_QWORD *)(a1 + 408) = tls_handshake_get_peer_acceptable_client_auth_type();
        if (*(_BYTE *)(a1 + 354) && !*(_QWORD *)(a1 + 152))
        {
          *(_BYTE *)(a1 + 357) = 1;
          return 4294957454;
        }
        break;
      default:
        return result;
    }
    return 0;
  }
  switch(a2)
  {
    case 1:
      *(_QWORD *)(a1 + 392) = tls_handshake_get_peer_signature_algorithms();
      if (*(_BYTE *)(a1 + 359))
        return 4294957445;
      else
        return 0;
    case 2:
      *(_BYTE *)(a1 + 553) = 1;
      peer_alpn_data = (_QWORD *)tls_handshake_get_peer_alpn_data();
      if (peer_alpn_data && (v5 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a1 + 536)) != 0)
      {
        v6 = (_QWORD *)(a1 + 544);
      }
      else
      {
        peer_alpn_data = (_QWORD *)tls_handshake_get_peer_npn_data();
        if (!peer_alpn_data)
        {
LABEL_27:
          peer_signature_algorithms = tls_handshake_get_peer_signature_algorithms();
          result = 0;
          *(_QWORD *)(a1 + 392) = peer_signature_algorithms;
          return result;
        }
        v5 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a1 + 520);
        v6 = (_QWORD *)(a1 + 528);
      }
      v5(a1, *v6, peer_alpn_data[1], *peer_alpn_data);
      goto LABEL_27;
    case 11:
      result = tls_helper_set_peer_pubkey();
      if (!(_DWORD)result)
      {
        if (!*(_DWORD *)(a1 + 108))
          return tls_verify_peer_cert(a1);
        return 0;
      }
      break;
  }
  return result;
}

uint64_t __sec_protocol_sec_array_of_sec_certificate_are_equal_block_invoke_2(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  const void *v6;
  CFTypeRef v7;
  const void *v9;
  CFTypeRef v10;
  const void *v11;
  BOOL v12;
  _BOOL4 v13;
  BOOL v14;

  if (a1[5] != a2)
    return 1;
  v5 = a1[6];
  if (v5 && (v6 = *(const void **)(v5 + 8)) != 0)
  {
    v7 = CFRetain(v6);
    if (!a3)
      goto LABEL_12;
  }
  else
  {
    v7 = 0;
    if (!a3)
    {
LABEL_12:
      v13 = 0;
      v11 = 0;
      v12 = v7 == 0;
      goto LABEL_13;
    }
  }
  v9 = *(const void **)(a3 + 8);
  if (!v9)
    goto LABEL_12;
  v10 = CFRetain(v9);
  v11 = v10;
  v12 = v7 == 0;
  v13 = v10 != 0;
  if (!v7 && v10)
  {
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
LABEL_23:
    CFRelease(v11);
    return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) != 0;
  }
LABEL_13:
  if (v7 && !v11)
  {
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
LABEL_21:
    CFRelease(v7);
    goto LABEL_22;
  }
  if (v11)
    v14 = 0;
  else
    v14 = v12;
  if (v14)
    return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) != 0;
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) &= CFEqual(v7, v11);
  if (!v12)
    goto LABEL_21;
LABEL_22:
  if (v13)
    goto LABEL_23;
  return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) != 0;
}

void __sec_protocol_options_access_handle_block_invoke()
{
  void *v0;
  NSObject *v1;
  const char *v2;
  uint8_t *v3;
  __int16 v4;
  __int16 v5;

  v0 = dlopen("/usr/lib/libnetwork.dylib", 5);
  sec_protocol_options_access_handle_libnetworkImage = (uint64_t)v0;
  if (v0)
  {
    sec_protocol_options_access_handle__nw_protocol_options_access_handle = (uint64_t (*)(_QWORD, _QWORD))dlsym(v0, "nw_protocol_options_access_handle");
    if (!sec_protocol_options_access_handle__nw_protocol_options_access_handle
      && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v5 = 0;
      v1 = MEMORY[0x1E0C81028];
      v2 = "dlsym libnetwork nw_protocol_options_access_handle";
      v3 = (uint8_t *)&v5;
LABEL_8:
      _os_log_error_impl(&dword_18A900000, v1, OS_LOG_TYPE_ERROR, v2, v3, 2u);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v4 = 0;
    v1 = MEMORY[0x1E0C81028];
    v2 = "dlopen libnetwork";
    v3 = (uint8_t *)&v4;
    goto LABEL_8;
  }
}

OSStatus SecIdentityCopyPrivateKey(SecIdentityRef identityRef, SecKeyRef *privateKeyRef)
{
  __SecKey *v2;

  v2 = (__SecKey *)*((_QWORD *)identityRef + 3);
  *privateKeyRef = v2;
  CFRetain(v2);
  return 0;
}

OSStatus SecIdentityCopyCertificate(SecIdentityRef identityRef, SecCertificateRef *certificateRef)
{
  __SecCertificate *v2;

  v2 = (__SecCertificate *)*((_QWORD *)identityRef + 2);
  *certificateRef = v2;
  CFRetain(v2);
  return 0;
}

OSStatus SSLSetPeerDomainName(SSLContextRef context, const char *peerName, size_t peerNameLen)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  BOOL v6;

  if (!context)
    return -50;
  v3 = *((_DWORD *)context + 20);
  v4 = v3 >= 6;
  v6 = v3 == 6;
  v5 = (1 << v3) & 0x59;
  v6 = !v6 && v4 || v5 == 0;
  if (v6)
    return -909;
  if (*((_DWORD *)context + 27) == 1)
    return tls_handshake_set_peer_hostname();
  return 0;
}

void __sec_protocol_metadata_access_handle_block_invoke()
{
  void *v0;
  NSObject *v1;
  const char *v2;
  uint8_t *v3;
  __int16 v4;
  __int16 v5;

  v0 = dlopen("/usr/lib/libnetwork.dylib", 5);
  sec_protocol_metadata_access_handle_libnetworkImage = (uint64_t)v0;
  if (v0)
  {
    sec_protocol_metadata_access_handle__nw_protocol_metadata_access_handle = (uint64_t (*)(_QWORD, _QWORD))dlsym(v0, "nw_protocol_metadata_access_handle");
    if (!sec_protocol_metadata_access_handle__nw_protocol_metadata_access_handle
      && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v5 = 0;
      v1 = MEMORY[0x1E0C81028];
      v2 = "dlsym libnetwork _nw_protocol_metadata_access_handle";
      v3 = (uint8_t *)&v5;
LABEL_8:
      _os_log_error_impl(&dword_18A900000, v1, OS_LOG_TYPE_ERROR, v2, v3, 2u);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v4 = 0;
    v1 = MEMORY[0x1E0C81028];
    v2 = "dlopen libnetwork";
    v3 = (uint8_t *)&v4;
    goto LABEL_8;
  }
}

uint64_t SSLProtocolFromVersionCodepoint(int a1)
{
  uint64_t v1;
  __int16 *v2;
  int v3;

  v1 = 0;
  v2 = &word_18AA5C44C;
  while (1)
  {
    v3 = (unsigned __int16)*v2;
    v2 += 4;
    if (v3 == a1)
      break;
    if (++v1 == 8)
      return 0;
  }
  return ssl_protocol_version_map[2 * v1];
}

CFArrayRef CFArrayCreateForCFTypes(CFAllocatorRef allocator, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFIndex v10;
  uint64_t *v11;
  CFMutableArrayRef Mutable;
  __CFArray *v13;
  const void *v14;
  const void **v15;
  const void *v16;
  const void *v17;
  CFArrayRef Copy;
  uint64_t *v20;
  const void **v21;

  v20 = &a9;
  v10 = -1;
  do
  {
    v11 = v20++;
    ++v10;
  }
  while (*v11);
  v21 = (const void **)&a9;
  Mutable = CFArrayCreateMutable(allocator, v10, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return 0;
  v13 = Mutable;
  if (v10)
  {
    v14 = (const void *)*MEMORY[0x1E0C9B0D0];
    do
    {
      v15 = v21++;
      v16 = *v15;
      if (v16)
        v17 = v16;
      else
        v17 = v14;
      CFArrayAppendValue(v13, v17);
      --v10;
    }
    while (v10);
  }
  Copy = CFArrayCreateCopy(allocator, v13);
  CFRelease(v13);
  return Copy;
}

uint64_t SecTrustSetPinningPolicyName(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD v8[6];
  _QWORD block[5];

  result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      v5 = MEMORY[0x1E0C809B0];
      v6 = *(NSObject **)(a1 + 136);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
      block[3] = &__block_descriptor_tmp_49_11514;
      block[4] = a1;
      dispatch_sync(v6, block);
      v7 = *(NSObject **)(a1 + 136);
      v8[0] = v5;
      v8[1] = 0x40000000;
      v8[2] = __SecTrustSetPinningPolicyName_block_invoke;
      v8[3] = &__block_descriptor_tmp_60_11537;
      v8[4] = a1;
      v8[5] = a2;
      dispatch_sync(v7, v8);
      return 0;
    }
  }
  return result;
}

id KCSharingLogObject(void *a1)
{
  id v1;
  void *v2;
  id v3;
  NSObject *v4;
  id v5;
  id v6;
  _QWORD v8[4];
  id v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t, uint64_t);
  void (*v15)(uint64_t);
  id v16;

  v1 = a1;
  v11 = 0;
  v12 = &v11;
  v13 = 0x3032000000;
  v14 = __Block_byref_object_copy__3339;
  v15 = __Block_byref_object_dispose__3340;
  v2 = (void *)MEMORY[0x1E0C81030];
  v3 = MEMORY[0x1E0C81030];
  v16 = v2;
  if (KCSharingLogObject_onceToken != -1)
    dispatch_once(&KCSharingLogObject_onceToken, &__block_literal_global_3341);
  v4 = KCSharingLogObject_logQueue;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = __KCSharingLogObject_block_invoke_2;
  v8[3] = &unk_1E1FDBC88;
  v9 = v1;
  v10 = &v11;
  v5 = v1;
  dispatch_sync(v4, v8);
  v6 = (id)v12[5];

  _Block_object_dispose(&v11, 8);
  return v6;
}

OSStatus SecTrustGetTrustResult(SecTrustRef trust, SecTrustResultType *result)
{
  OSStatus v3;
  NSObject *v5;
  _QWORD v6[6];

  v3 = -50;
  if (trust)
  {
    if (result)
    {
      SecTrustEvaluateIfNecessary(trust);
      v5 = *((_QWORD *)trust + 17);
      v6[0] = MEMORY[0x1E0C809B0];
      v6[1] = 0x40000000;
      v6[2] = __SecTrustGetTrustResult_block_invoke;
      v6[3] = &__block_descriptor_tmp_69_11612;
      v6[4] = result;
      v6[5] = trust;
      dispatch_sync(v5, v6);
      return 0;
    }
  }
  return v3;
}

uint64_t tls_handshake_advance_write_callback(uint64_t a1)
{
  _BOOL8 v2;

  if (*(_BYTE *)(a1 + 315))
    v2 = *(_DWORD *)(a1 + 88) < 0x302u;
  else
    v2 = 0;
  (*(void (**)(_QWORD, _QWORD, _BOOL8))(*(_QWORD *)(a1 + 40) + 72))(*(_QWORD *)(a1 + 48), 0, v2);
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 40) + 24))(*(_QWORD *)(a1 + 48));
}

uint64_t SSLRecordSetOption(uint64_t a1, int a2)
{
  if (a2)
    return 0;
  else
    return tls_record_set_record_splitting();
}

uint64_t _SSLDisposeContext(const void *a1)
{
  if (!a1)
    return 4294967246;
  CFRelease(a1);
  return 0;
}

uint64_t _SSLSetEnableCertVerify(uint64_t a1, char a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t result;

  if (!a1)
    return 4294967246;
  v3 = *(_DWORD *)(a1 + 80);
  v4 = v3 > 6;
  v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0)
    return 4294966387;
  result = 0;
  *(_BYTE *)(a1 + 187) = a2;
  return result;
}

OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result)
{
  void *v4;
  NSObject *v5;
  CFDictionaryRef *v6;
  const void *v7;
  OSStatus v8;
  __SecCertificate *Value;
  __SecCertificate *v11;
  CFTypeID v12;
  CFStringRef v13;
  CFStringRef v14;
  __CFDictionary *v15;
  _QWORD v16[6];
  os_activity_scope_state_s state;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  void *v22;
  CFDictionaryRef v23;
  uint64_t v24;

  v4 = (void *)MEMORY[0x18D770A24]();
  v19 = 0;
  v20 = &v19;
  v21 = 0x3010000000;
  v22 = &unk_18AA98BF6;
  v23 = attributes;
  v24 = 0;
  v18 = -1431655766;
  v5 = _os_activity_create(&dword_18A900000, "SecItemAdd_ios", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  if ((explode_identity(v20[4], SecItemAdd, &v18, result) & 1) == 0)
  {
    v6 = (CFDictionaryRef *)(v20 + 4);
    if (!CFDictionaryContainsKey((CFDictionaryRef)v20[4], CFSTR("labl")))
    {
      Value = (__SecCertificate *)CFDictionaryGetValue(*v6, CFSTR("v_Ref"));
      v11 = Value;
      if (Value)
      {
        v12 = CFGetTypeID(Value);
        if (v12 == SecCertificateGetTypeID())
        {
          v13 = SecCertificateCopySubjectSummary(v11);
          if (v13)
          {
            v14 = v13;
            v15 = SecCFDictionaryCOWGetMutable(v6);
            CFDictionarySetValue(v15, CFSTR("labl"), v14);
            CFRelease(v14);
          }
        }
      }
    }
    v16[0] = MEMORY[0x1E0C809B0];
    v16[1] = 3221225472;
    v16[2] = __SecItemAdd_block_invoke;
    v16[3] = &unk_1E1FD5D98;
    v16[4] = &v19;
    v16[5] = result;
    v18 = SecOSStatusWith((uint64_t)v16);
  }
  v7 = (const void *)v20[5];
  if (v7)
    CFRelease(v7);
  v8 = v18;
  os_activity_scope_leave(&state);

  _Block_object_dispose(&v19, 8);
  objc_autoreleasePoolPop(v4);
  return v8;
}

void sub_18A93F9E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, os_activity_scope_state_s state, uint64_t a17, char a18)
{
  os_activity_scope_leave(&state);
  _Block_object_dispose(&a18, 8);
  _Unwind_Resume(a1);
}

OSStatus SSLSetProtocolVersionMin(SSLContextRef context, SSLProtocol minVersion)
{
  OSStatus result;
  __int32 v4;
  unsigned int v5;

  if (!context)
    return -50;
  result = -9830;
  v4 = minVersion - 2;
  v5 = 768;
  switch(v4)
  {
    case 0:
      goto LABEL_7;
    case 2:
      v5 = 769;
      goto LABEL_7;
    case 5:
      v5 = 770;
      goto LABEL_7;
    case 6:
      v5 = 771;
LABEL_7:
      if (*((_BYTE *)context + 104))
        return result;
      if (v5 > *((_DWORD *)context + 25))
        goto LABEL_9;
      goto LABEL_10;
    case 7:
      if (!*((_BYTE *)context + 104))
        return result;
      v5 = 65279;
      if (*((_DWORD *)context + 25) >> 8 < 0xFFu)
        goto LABEL_10;
LABEL_9:
      *((_DWORD *)context + 25) = v5;
LABEL_10:
      *((_DWORD *)context + 24) = v5;
      tls_handshake_set_min_protocol_version();
      tls_handshake_set_max_protocol_version();
      result = 0;
      break;
    default:
      return result;
  }
  return result;
}

__CFData *_SecItemCreateUUIDBasedPersistentRef(const __CFString *a1, CFDataRef theData, const __CFDictionary *a3)
{
  __CFData *TokenPersistentRefData;
  const __CFData *v6;
  const __CFAllocator *v7;
  CFIndex Length;
  __CFData *Mutable;
  const UInt8 *BytePtr;
  CFIndex v11;
  CFIndex v12;
  CFTypeID v13;
  const __CFAllocator *v14;
  CFTypeID v15;
  CFIndex v16;
  CFIndex v17;
  __CFData *v18;
  UInt8 *MutableBytePtr;
  const UInt8 *v20;
  CFIndex v21;
  _QWORD v23[5];
  CFIndex usedBufLen;
  CFIndex maxBufLen;
  CFRange v26;
  CFRange v27;

  if (a3)
  {
    TokenPersistentRefData = CreateTokenPersistentRefData(a1, a3);
    if (TokenPersistentRefData)
    {
      v6 = TokenPersistentRefData;
      v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Length = CFDataGetLength(TokenPersistentRefData);
      Mutable = CFDataCreateMutable(v7, Length + 4);
      CFDataAppendBytes(Mutable, (const UInt8 *)"tkpr", 4);
      BytePtr = CFDataGetBytePtr(v6);
      v11 = CFDataGetLength(v6);
      CFDataAppendBytes(Mutable, BytePtr, v11);
LABEL_14:
      CFRelease(v6);
      return Mutable;
    }
  }
  if (!theData)
    return 0;
  v12 = CFDataGetLength(theData);
  Mutable = 0;
  if (!a1 || v12 != 16)
    return Mutable;
  v13 = CFGetTypeID(a1);
  if (v13 != CFStringGetTypeID() || CFStringGetLength(a1) < 1)
    return 0;
  v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v15 = CFGetTypeID(a1);
  Mutable = 0;
  if (v15 == CFStringGetTypeID())
  {
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 3221225472;
    v23[2] = ___SecItemCreateUUIDBasedPersistentRef_block_invoke;
    v23[3] = &__block_descriptor_40_e19_v16__0____CFData__8l;
    v23[4] = v6;
    maxBufLen = 0;
    v16 = CFStringGetLength(a1);
    v26.location = 0;
    v26.length = v16;
    CFStringGetBytes(a1, v26, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
    v17 = maxBufLen;
    v18 = CFDataCreateMutable(v14, 0);
    CFDataSetLength(v18, v17);
    usedBufLen = 0xAAAAAAAAAAAAAAAALL;
    MutableBytePtr = CFDataGetMutableBytePtr(v18);
    v27.location = 0;
    v27.length = v16;
    CFStringGetBytes(a1, v27, 0x8000100u, 0, 0, MutableBytePtr, maxBufLen, &usedBufLen);
    ___SecItemCreateUUIDBasedPersistentRef_block_invoke((uint64_t)v23, v18);
    if (v18)
      CFRelease(v18);
    v20 = CFDataGetBytePtr(theData);
    v21 = CFDataGetLength(theData);
    CFDataAppendBytes(v6, v20, v21);
    Mutable = CFDataCreateCopy(v14, v6);
  }
  if (v6)
    goto LABEL_14;
  return Mutable;
}

__CFData *CreateTokenPersistentRefData(const void *a1, CFDictionaryRef theDict)
{
  const void *Value;
  CFTypeID v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFDictionary *v13;
  __CFData *DERData;
  const __CFString *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void *v21;
  CFTypeID v22;
  const __CFString *v23;
  const void *v24;
  CFTypeID v25;
  const void *v26;
  const void *v27;
  CFTypeID v28;
  const __CFDictionary *v29;
  const void *v30;
  CFTypeID v31;

  if (CFDictionaryGetValue(theDict, CFSTR("toid")))
  {
    Value = CFDictionaryGetValue(theDict, CFSTR("tkid"));
    if (Value)
    {
      v5 = CFGetTypeID(Value);
      v13 = 0;
      DERData = 0;
      if (v5 != CFStringGetTypeID())
        return DERData;
      goto LABEL_4;
    }
    return 0;
  }
  if (CFEqual(a1, CFSTR("idnt")))
  {
    v21 = CFDictionaryGetValue(theDict, CFSTR("certtkid"));
    if (!v21)
      return 0;
    v22 = CFGetTypeID(v21);
    if (v22 != CFStringGetTypeID())
      return 0;
    v23 = CFSTR("certdata");
  }
  else
  {
    v24 = CFDictionaryGetValue(theDict, CFSTR("tkid"));
    if (!v24)
      return 0;
    v25 = CFGetTypeID(v24);
    if (v25 != CFStringGetTypeID())
      return 0;
    v23 = CFSTR("v_Data");
  }
  v26 = CFDictionaryGetValue(theDict, v23);
  if (!v26)
    return 0;
  v27 = v26;
  v28 = CFGetTypeID(v26);
  if (v28 != CFDataGetTypeID())
    return 0;
  v29 = SecTokenItemValueCopy(v27, 0);
  if (!v29)
    return 0;
  v13 = v29;
  v30 = CFDictionaryGetValue(v29, CFSTR("oid"));
  if (!v30 || (v31 = CFGetTypeID(v30), v31 != CFDataGetTypeID()))
  {
    DERData = 0;
    goto LABEL_5;
  }
LABEL_4:
  v15 = (const __CFString *)CFArrayCreateForCFTypes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, v7, v8, v9, v10, v11, v12, (uint64_t)a1);
  DERData = CFPropertyListCreateDERData((uint64_t)v15, v15, 0, v16, v17, v18, v19, v20);
  CFRelease(v15);
  if (v13)
LABEL_5:
    CFRelease(v13);
  return DERData;
}

CFDictionaryRef SecPolicyCopyProperties(SecPolicyRef policyRef)
{
  __CFDictionary *Mutable;
  CFTypeRef v3;
  const __CFDictionary *v4;
  const __CFString *v5;
  const __CFDictionary *v6;
  const void *Value;
  const void *v8;
  const __CFString *v9;
  __CFDictionary *v10;
  const void *v11;
  int v13;

  if (!policyRef)
    return 0;
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v3 = CFRetain(*((CFTypeRef *)policyRef + 2));
    v4 = (const __CFDictionary *)*((_QWORD *)policyRef + 4);
    if (v4)
    {
      v5 = CFSTR("SSLHostname");
      if (CFDictionaryContainsKey(v4, CFSTR("SSLHostname"))
        || (v5 = CFSTR("EAPTrustedServerNames"),
            CFDictionaryContainsKey(*((CFDictionaryRef *)policyRef + 4), CFSTR("EAPTrustedServerNames"))))
      {
        CFDictionarySetValue(Mutable, CFSTR("SecPolicyOid"), v3);
      }
      else
      {
        v5 = CFSTR("Email");
        v13 = CFDictionaryContainsKey(*((CFDictionaryRef *)policyRef + 4), CFSTR("Email"));
        CFDictionarySetValue(Mutable, CFSTR("SecPolicyOid"), v3);
        if (!v13)
          goto LABEL_13;
      }
      v6 = (const __CFDictionary *)*((_QWORD *)policyRef + 4);
      if (!v6)
        goto LABEL_13;
      Value = CFDictionaryGetValue(v6, v5);
      if (!Value)
        goto LABEL_13;
      v8 = Value;
      v9 = CFSTR("SecPolicyName");
      v10 = Mutable;
    }
    else
    {
      v9 = CFSTR("SecPolicyOid");
      v10 = Mutable;
      v8 = v3;
    }
    CFDictionarySetValue(v10, v9, v8);
LABEL_13:
    v11 = (const void *)*((_QWORD *)policyRef + 3);
    if (v11)
    {
      CFRetain(v11);
      if (CFEqual(v11, CFSTR("sslClient")) || CFEqual(v11, CFSTR("ipsecClient")) || CFEqual(v11, CFSTR("eapClient")))
        CFDictionarySetValue(Mutable, CFSTR("SecPolicyClient"), (const void *)*MEMORY[0x1E0C9AE50]);
      CFRelease(v11);
    }
    CFRelease(v3);
  }
  return Mutable;
}

OSStatus SecItemDelete(CFDictionaryRef query)
{
  void *v2;
  NSObject *v3;
  const __CFDictionary **v4;
  void *Value;
  void *v6;
  const __CFDictionary *v7;
  OSStatus v8;
  __CFDictionary *v9;
  __CFDictionary *v10;
  const void *v11;
  OSStatus v12;
  _QWORD v14[5];
  os_activity_scope_state_s state;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  void *v19;
  CFDictionaryRef v20;
  uint64_t v21;
  OSStatus v22;
  CFTypeRef result;
  CFTypeRef v24;
  void *values[2];
  void *keys[3];

  keys[2] = *(void **)MEMORY[0x1E0C80C00];
  v2 = (void *)MEMORY[0x18D770A24]();
  v16 = 0;
  v17 = &v16;
  v18 = 0x3010000000;
  v19 = &unk_18AA98BF6;
  v20 = query;
  v21 = 0;
  v3 = _os_activity_create(&dword_18A900000, "SecItemDelete_ios", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &state);
  v4 = (const __CFDictionary **)(v17 + 4);
  Value = (void *)CFDictionaryGetValue((CFDictionaryRef)v17[4], CFSTR("v_PersistentRef"));
  v6 = Value;
  v24 = 0;
  if (Value && _SecItemParsePersistentRef(Value, &v24, 0, 0, 0) && CFEqual(v24, CFSTR("idnt")))
  {
    keys[0] = CFSTR("r_Ref");
    keys[1] = CFSTR("v_PersistentRef");
    values[0] = *(void **)MEMORY[0x1E0C9AE50];
    values[1] = v6;
    v7 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, 0, 0);
    result = 0;
    v8 = SecItemCopyMatching(v7, &result);
    if (v7)
      CFRelease(v7);
    if (v8)
      goto LABEL_7;
    if (!result)
    {
      v8 = -25300;
LABEL_7:
      v22 = v8;
      goto LABEL_12;
    }
    v9 = SecCFDictionaryCOWGetMutable(v4);
    CFDictionaryRemoveValue(v9, CFSTR("v_PersistentRef"));
    v10 = SecCFDictionaryCOWGetMutable(v4);
    CFDictionarySetValue(v10, CFSTR("v_Ref"), result);
    CFRelease(result);
  }
  v22 = 0;
  if ((explode_identity(v17[4], SecItemDelete, &v22, 0) & 1) == 0)
  {
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __SecItemDelete_block_invoke;
    v14[3] = &unk_1E1FD5F00;
    v14[4] = &v16;
    v22 = SecOSStatusWith((uint64_t)v14);
  }
LABEL_12:
  v11 = (const void *)v17[5];
  if (v11)
    CFRelease(v11);
  v12 = v22;
  os_activity_scope_leave(&state);

  _Block_object_dispose(&v16, 8);
  objc_autoreleasePoolPop(v2);
  return v12;
}

void sub_18A94036C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state, char a16)
{
  os_activity_scope_leave(&state);
  _Block_object_dispose(&a16, 8);
  _Unwind_Resume(a1);
}

uint64_t _SSLNewContext(int a1, SSLContextRef *a2)
{
  SSLContextRef v3;

  if (!a2)
    return 4294967246;
  v3 = SSLCreateContext((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (SSLProtocolSide)(a1 == 0), kSSLStreamType);
  *a2 = v3;
  if (v3)
    return 0;
  else
    return 4294967188;
}

SSLContextRef SSLCreateContext(CFAllocatorRef alloc, SSLProtocolSide protocolSide, SSLConnectionType connectionType)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  unsigned int v9;
  BOOL v10;
  int v11;

  v3 = SSLCreateContextWithRecordFuncs((uint64_t)alloc, protocolSide, connectionType, (uint64_t)SSLRecordLayerInternal);
  if (!v3)
    return (SSLContextRef)v3;
  v4 = (uint64_t *)malloc_type_malloc(0x30uLL, 0xEFB4CC30uLL);
  if (!v4)
  {
LABEL_16:
    CFRelease((CFTypeRef)v3);
    return 0;
  }
  v5 = v4;
  *((_OWORD *)v4 + 1) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  *(_OWORD *)v4 = 0u;
  ccrng();
  v6 = tls_record_create();
  *v5 = v6;
  if (!v6)
  {
LABEL_15:
    free(v5);
    goto LABEL_16;
  }
  v7 = malloc_type_malloc(0x4800uLL, 0xEFB4CC30uLL);
  if (v7)
    v8 = 18432;
  else
    v8 = 0;
  v5[2] = v8;
  v5[3] = (uint64_t)v7;
  if (!v7)
  {
    if (*v5)
      tls_record_destroy();
    goto LABEL_15;
  }
  v5[1] = v3;
  v9 = *(_DWORD *)(v3 + 80);
  v10 = v9 > 6;
  v11 = (1 << v9) & 0x59;
  if (!v10 && v11 != 0)
    *(_QWORD *)(v3 + 48) = v5;
  return (SSLContextRef)v3;
}

uint64_t SSLCreateContextWithRecordFuncs(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t Instance;
  uint64_t v8;
  uint64_t v9;

  SSLContextGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  v8 = Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), 0x220uLL);
    v9 = tls_handshake_create();
    *(_QWORD *)(v8 + 56) = v9;
    if (v9)
    {
      if (SSLCreateContextWithRecordFuncs_onceToken != -1)
        dispatch_once(&SSLCreateContextWithRecordFuncs_onceToken, &__block_literal_global_6503);
      *(_QWORD *)(v8 + 64) = g_session_cache;
      tls_handshake_set_callbacks();
      *(_BYTE *)(v8 + 104) = a3 == 1;
      *(_DWORD *)(v8 + 80) = 0;
      *(_QWORD *)(v8 + 424) = 0x3FF0000000000000;
      *(_QWORD *)(v8 + 432) = 1400;
      tls_handshake_get_min_protocol_version();
      tls_handshake_get_max_protocol_version();
      if (a2 == 1)
      {
        tls_handshake_set_sct_enable();
        tls_handshake_set_ocsp_enable();
      }
      *(_DWORD *)(v8 + 88) = 0;
      *(_DWORD *)(v8 + 108) = a2;
      *(_QWORD *)(v8 + 40) = a4;
      *(_BYTE *)(v8 + 187) = 1;
      *(_BYTE *)(v8 + 314) = 1;
      *(_BYTE *)(v8 + 315) = kSSLDisableRecordSplittingDefaultValue == 0;
      *(_BYTE *)(v8 + 513) = 0;
      if (kSSLSessionConfigDefaultValue)
        SSLSetSessionConfig((SSLContextRef)v8, (CFStringRef)kSSLSessionConfigDefaultValue);
      if (kMinDhGroupSizeDefaultValue)
        tls_handshake_set_min_dh_group_size();
      if (kMinProtocolVersionDefaultValue)
        SSLSetProtocolVersionMin((SSLContextRef)v8, (SSLProtocol)kMinProtocolVersionDefaultValue);
      *(_DWORD *)(v8 + 352) = 0;
      *(_DWORD *)(v8 + 355) = 0;
    }
    else
    {
      CFRelease((CFTypeRef)v8);
      return 0;
    }
  }
  return v8;
}

CFTypeID SSLContextGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SSLContextGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_6498;
  block[4] = &SSLContextGetTypeID_sSSLContextGetTypeIDSingleton;
  if (SSLContextGetTypeID_sSSLContextGetTypeIDOnce != -1)
    dispatch_once(&SSLContextGetTypeID_sSSLContextGetTypeIDOnce, block);
  return SSLContextGetTypeID_sSSLContextGetTypeIDSingleton;
}

uint64_t _SSLCopyPeerCertificates(uint64_t a1, CFArrayRef *a2)
{
  __SecTrust *v3;
  CFArrayRef v4;
  CFArrayRef v5;
  uint64_t result;

  if (!a1)
    return 4294967246;
  v3 = *(__SecTrust **)(a1 + 168);
  if (!v3)
  {
    v5 = 0;
    result = 4294966387;
    goto LABEL_7;
  }
  v4 = SecTrustCopyCertificateChain(v3);
  if (v4)
  {
    v5 = v4;
    result = 0;
LABEL_7:
    *a2 = v5;
    return result;
  }
  return 4294967188;
}

void sub_18A940968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A940BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

CFPropertyListRef SSLPreferencesCopyValue(const void *a1, const __CFDictionary *a2)
{
  CFPropertyListRef v4;
  CFPropertyListRef v5;
  const void *Value;

  v4 = CFPreferencesCopyAppValue(CFSTR("SSLSessionConfig"), (CFStringRef)*MEMORY[0x1E0C9B248]);
  v5 = v4;
  if (a2)
  {
    if (!v4)
    {
      Value = CFDictionaryGetValue(a2, a1);
      v5 = Value;
      if (Value)
        CFRetain(Value);
    }
  }
  return v5;
}

const __CFNumber *SSLPreferencesGetInteger(const void *a1, const __CFDictionary *a2)
{
  const __CFNumber *result;
  const __CFNumber *v3;
  CFTypeID v4;
  uint64_t valuePtr;

  result = (const __CFNumber *)SSLPreferencesCopyValue(a1, a2);
  valuePtr = 0;
  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID(result);
    if (v4 == CFNumberGetTypeID())
      CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr);
    CFRelease(v3);
    return (const __CFNumber *)valuePtr;
  }
  return result;
}

uint64_t SecTrustSetClientAuditToken(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD v8[6];
  _QWORD block[5];

  if (!a1)
    return 4294967246;
  v4 = MEMORY[0x1E0C809B0];
  v5 = *(NSObject **)(a1 + 136);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11514;
  block[4] = a1;
  dispatch_sync(v5, block);
  v6 = *(NSObject **)(a1 + 136);
  v8[0] = v4;
  v8[1] = 0x40000000;
  v8[2] = __SecTrustSetClientAuditToken_block_invoke;
  v8[3] = &__block_descriptor_tmp_275;
  v8[4] = a1;
  v8[5] = a2;
  dispatch_sync(v6, v8);
  return 0;
}

OSStatus SSLSetCertificate(SSLContextRef context, CFArrayRef certRefs)
{
  const void *v4;
  OSStatus result;

  if (!context)
    return -50;
  v4 = (const void *)*((_QWORD *)context + 19);
  if (v4)
  {
    *((_QWORD *)context + 19) = 0;
    CFRelease(v4);
  }
  if (certRefs)
  {
    result = tls_helper_set_identity_from_array();
    if (result)
      return result;
    *((_QWORD *)context + 19) = certRefs;
    CFRetain(certRefs);
  }
  return 0;
}

uint64_t SecIdentityCreate(int a1, CFTypeRef cf, const void *a3)
{
  CFTypeID v5;
  CFTypeID TypeID;
  uint64_t Instance;
  CFTypeID v8;

  if (!cf)
    return 0;
  v5 = CFGetTypeID(cf);
  TypeID = SecCertificateGetTypeID();
  Instance = 0;
  if (!a3 || v5 != TypeID)
    return Instance;
  v8 = CFGetTypeID(a3);
  if (v8 != SecKeyGetTypeID())
    return 0;
  SecIdentityGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    CFRetain(cf);
    CFRetain(a3);
    *(_QWORD *)(Instance + 16) = cf;
    *(_QWORD *)(Instance + 24) = a3;
  }
  return Instance;
}

CFTypeID SecIdentityGetTypeID(void)
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecIdentityGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_8118;
  block[4] = &SecIdentityGetTypeID_sSecIdentityGetTypeIDSingleton;
  if (SecIdentityGetTypeID_sSecIdentityGetTypeIDOnce != -1)
    dispatch_once(&SecIdentityGetTypeID_sSecIdentityGetTypeIDOnce, block);
  return SecIdentityGetTypeID_sSecIdentityGetTypeIDSingleton;
}

OSStatus SSLSetClientSideAuthenticate(SSLContextRef context, SSLAuthenticate auth)
{
  unsigned int v2;
  BOOL v3;
  int v4;

  if (!context)
    return -50;
  v2 = *((_DWORD *)context + 20);
  v3 = v2 > 6;
  v4 = (1 << v2) & 0x59;
  if (v3 || v4 == 0)
    return -909;
  *((_DWORD *)context + 63) = auth;
  if (auth <= kTryAuthenticate)
    tls_handshake_set_client_auth();
  return 0;
}

SecCertificateRef SecTrustGetCertificateAtIndex(SecTrustRef trust, CFIndex ix)
{
  SecTrustRef v2;
  NSObject *v4;
  _QWORD *v5;
  _QWORD v7[7];
  _QWORD block[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v2 = trust;
  if (trust)
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2000000000;
    v12 = 0;
    if (ix)
    {
      SecTrustEvaluateIfNecessary(trust);
      v4 = *((_QWORD *)v2 + 17);
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 0x40000000;
      v7[2] = __SecTrustGetCertificateAtIndex_block_invoke_2;
      v7[3] = &unk_1E1FDA930;
      v7[4] = &v9;
      v7[5] = v2;
      v7[6] = ix;
      v5 = v7;
    }
    else
    {
      v4 = *((_QWORD *)trust + 17);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __SecTrustGetCertificateAtIndex_block_invoke;
      block[3] = &unk_1E1FDA908;
      block[4] = &v9;
      block[5] = v2;
      v5 = block;
    }
    dispatch_sync(v4, v5);
    v2 = (SecTrustRef)v10[3];
    _Block_object_dispose(&v9, 8);
  }
  return v2;
}

OSStatus SSLSetProtocolVersionMax(SSLContextRef context, SSLProtocol maxVersion)
{
  OSStatus result;
  unsigned int v4;

  if (!context)
    return -50;
  result = -9830;
  v4 = 768;
  switch(maxVersion)
  {
    case kSSLProtocol3:
      goto LABEL_7;
    case kTLSProtocol1:
      v4 = 769;
      goto LABEL_7;
    case kTLSProtocol11:
      v4 = 770;
      goto LABEL_7;
    case kTLSProtocol12:
      v4 = 771;
LABEL_7:
      if (*((_BYTE *)context + 104))
        return result;
      if (v4 < *((_DWORD *)context + 24))
        *((_DWORD *)context + 24) = v4;
      break;
    case kDTLSProtocol1:
      if (!*((_BYTE *)context + 104))
        return result;
      v4 = 65279;
      if (*((_DWORD *)context + 24) <= 0xFEFEu)
        *((_DWORD *)context + 24) = 65279;
      break;
    default:
      return result;
  }
  *((_DWORD *)context + 25) = v4;
  tls_handshake_set_min_protocol_version();
  tls_handshake_set_max_protocol_version();
  return 0;
}

void SecIdentityDestroy(uint64_t a1)
{
  const void *v2;
  const void *v3;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = 0;
    CFRelease(v2);
  }
  v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    *(_QWORD *)(a1 + 24) = 0;
    CFRelease(v3);
  }
}

BOOL SecAccessControlCompare(uint64_t a1, uint64_t a2)
{
  return a1 == a2 || CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16)) != 0;
}

OSStatus SSLGetSessionState(SSLContextRef context, SSLSessionState *state)
{
  unsigned int v2;
  SSLSessionState v3;
  OSStatus result;

  if (!context)
    return -50;
  v2 = *((_DWORD *)context + 20) - 1;
  if (v2 > 5)
    v3 = kSSLIdle;
  else
    v3 = dword_18AA5C3D0[v2];
  result = 0;
  *state = v3;
  return result;
}

OSStatus SSLGetPeerDomainNameLength(SSLContextRef context, size_t *peerNameLen)
{
  if (context)
    return tls_handshake_get_peer_hostname();
  else
    return -50;
}

uint64_t SecCMSVerifySignedData(const __CFData *a1, const __CFData *a2, void *a3, SecTrustRef *a4, const __CFArray *a5, uint64_t *a6, CFDictionaryRef *a7)
{
  uint64_t v8;
  void *v9;
  void *values;

  values = 0;
  v8 = SecCMSVerifySignedData_internal(a1, a2, a3, a4, a5, a6, (const __CFDictionary **)&values);
  v9 = values;
  if (a7 && !(_DWORD)v8 && values)
  {
    *a7 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&kSecCMSSignedAttributes, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v9 = values;
  }
  if (v9)
    CFRelease(v9);
  return v8;
}

__CFData *SecKeyCopyModulus(_QWORD *a1)
{
  uint64_t v2;
  uint64_t (*v3)(_QWORD *);
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  __CFData *Value;
  __CFData *v7;
  CFIndex v8;
  const __CFAllocator *v9;
  __CFData *Mutable;

  v2 = a1[2];
  if ((_UNKNOWN *)v2 == &kSecRSAPublicKeyDescriptor)
  {
    v8 = ccn_write_uint_size();
    v9 = CFGetAllocator(a1);
    Mutable = CFDataCreateMutable(v9, v8);
    v7 = Mutable;
    if (Mutable)
    {
      CFDataSetLength(Mutable, v8);
      CFDataGetMutableBytePtr(v7);
      ccn_write_uint();
    }
  }
  else
  {
    v3 = *(uint64_t (**)(_QWORD *))(v2 + 88);
    if (v3 && (v4 = (const __CFDictionary *)v3(a1)) != 0)
    {
      v5 = v4;
      Value = (__CFData *)CFDictionaryGetValue(v4, CFSTR("_rsam"));
      v7 = Value;
      if (Value)
        CFRetain(Value);
      CFRelease(v5);
    }
    else
    {
      return 0;
    }
  }
  return v7;
}

void SSLContextDestroy(uint64_t a1)
{
  _QWORD *v2;
  void *v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  tls_handshake_destroy();
  if (*(uint64_t (***)())(a1 + 40) == SSLRecordLayerInternal)
  {
    v2 = *(_QWORD **)(a1 + 48);
    v3 = (void *)v2[3];
    if (v3)
      free(v3);
    v2[2] = 0;
    v2[3] = 0;
    v4 = (_QWORD *)v2[5];
    if (v4)
    {
      do
      {
        v5 = (_QWORD *)*v4;
        free(v4);
        v4 = v5;
      }
      while (v5);
    }
    if (*v2)
      tls_record_destroy();
    free(v2);
  }
  v6 = *(void **)(a1 + 328);
  if (v6)
    free(v6);
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  v7 = *(void **)(a1 + 200);
  if (v7)
    free(v7);
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = 0;
  v8 = *(void **)(a1 + 216);
  if (v8)
    free(v8);
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  v9 = *(void **)(a1 + 232);
  if (v9)
    free(v9);
  *(_QWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 232) = 0;
  v10 = *(void **)(a1 + 296);
  if (v10)
    free(v10);
  *(_QWORD *)(a1 + 288) = 0;
  *(_QWORD *)(a1 + 296) = 0;
  v11 = *(void **)(a1 + 376);
  if (v11)
    free(v11);
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  v12 = *(const void **)(a1 + 272);
  if (v12)
    CFRelease(v12);
  v13 = *(const void **)(a1 + 152);
  if (v13)
    CFRelease(v13);
  v14 = *(const void **)(a1 + 160);
  if (v14)
    CFRelease(v14);
  v15 = *(const void **)(a1 + 176);
  if (v15)
    CFRelease(v15);
  v16 = *(const void **)(a1 + 168);
  if (v16)
    CFRelease(v16);
  sslFreeDnList(a1);
  v17 = *(void **)(a1 + 456);
  if (v17)
    free(v17);
  *(_QWORD *)(a1 + 448) = 0;
  *(_QWORD *)(a1 + 456) = 0;
  v18 = *(void **)(a1 + 472);
  if (v18)
    free(v18);
  *(_QWORD *)(a1 + 464) = 0;
  *(_QWORD *)(a1 + 472) = 0;
  v19 = *(void **)(a1 + 504);
  if (v19)
    free(v19);
  *(_QWORD *)(a1 + 496) = 0;
  *(_QWORD *)(a1 + 504) = 0;
  v20 = *(void **)(a1 + 488);
  if (v20)
    free(v20);
  *(_QWORD *)(a1 + 480) = 0;
  *(_QWORD *)(a1 + 488) = 0;
  v21 = *(void **)(a1 + 144);
  if (v21)
    free(v21);
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  if (*(_QWORD *)(a1 + 64))
    tls_cache_cleanup();
  bzero((void *)(a1 + 16), 0x220uLL);
}

void sslFreeDnList(uint64_t a1)
{
  _QWORD *v2;
  void *v3;
  _QWORD *v4;

  v2 = *(_QWORD **)(a1 + 264);
  if (v2)
  {
    do
    {
      v3 = (void *)v2[2];
      if (v3)
        free(v3);
      v4 = (_QWORD *)*v2;
      free(v2);
      v2 = v4;
    }
    while (v4);
  }
  *(_QWORD *)(a1 + 264) = 0;
}

__CFData *SecKeyCopyExponent(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  __CFData *Value;
  __CFData *v6;
  CFIndex v7;
  __CFData *Mutable;

  v1 = *(_QWORD *)(a1 + 16);
  if ((_UNKNOWN *)v1 == &kSecRSAPublicKeyDescriptor)
  {
    v7 = ccn_write_uint_size();
    if (SecCFAllocatorZeroize_sOnce != -1)
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
    Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v7);
    v6 = Mutable;
    if (Mutable)
    {
      CFDataSetLength(Mutable, v7);
      CFDataGetMutableBytePtr(v6);
      ccn_write_uint();
    }
  }
  else
  {
    v2 = *(uint64_t (**)(void))(v1 + 88);
    if (v2 && (v3 = (const __CFDictionary *)v2()) != 0)
    {
      v4 = v3;
      Value = (__CFData *)CFDictionaryGetValue(v3, CFSTR("_rsae"));
      v6 = Value;
      if (Value)
        CFRetain(Value);
      CFRelease(v4);
    }
    else
    {
      return 0;
    }
  }
  return v6;
}

uint64_t tls_verify_peer_cert(uint64_t a1)
{
  const void *v2;
  __SecTrust *v3;
  _BYTE *v4;
  int v6;
  __SecTrust *v7;

  v7 = 0;
  v2 = *(const void **)(a1 + 168);
  if (v2)
  {
    *(_QWORD *)(a1 + 168) = 0;
    CFRelease(v2);
  }
  sslCreateSecTrust(a1, &v7);
  v3 = v7;
  if (!v7)
  {
    if (*(_DWORD *)(a1 + 108) == 1 || *(_DWORD *)(a1 + 252) == 1)
      goto LABEL_12;
    goto LABEL_13;
  }
  if (!*(_BYTE *)(a1 + 187))
  {
LABEL_13:
    *(_QWORD *)(a1 + 168) = v3;
    goto LABEL_14;
  }
  v6 = -1431655766;
  if (!SecTrustEvaluateInternal(v7, &v6))
  {
    if (v6 != 1 && v6 != 4 && !*(_BYTE *)(a1 + 312))
    {
LABEL_12:
      *(_QWORD *)(a1 + 168) = v3;
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  *(_QWORD *)(a1 + 168) = v3;
LABEL_14:
  tls_handshake_set_peer_trust();
  if (*(_DWORD *)(a1 + 108))
  {
    if (!*(_QWORD *)(a1 + 168))
      return 0;
    v4 = (_BYTE *)(a1 + 353);
  }
  else
  {
    v4 = (_BYTE *)(a1 + 355);
  }
  if (*v4)
    return 4294957455;
  else
    return 0;
}

uint64_t sslCreateSecTrust(uint64_t a1, _QWORD *a2)
{
  uint64_t peer_trust;
  uint64_t v4;

  peer_trust = tls_helper_create_peer_trust();
  if ((_DWORD)peer_trust)
    v4 = peer_trust;
  else
    v4 = 0;
  *a2 = 0;
  return v4;
}

CFIndex SecTrustGetCertificateCount(SecTrustRef trust)
{
  SecTrustRef v1;
  NSObject *v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v1 = trust;
  if (trust)
  {
    SecTrustEvaluateIfNecessary(trust);
    v5 = 0;
    v6 = &v5;
    v7 = 0x2000000000;
    v8 = 1;
    v2 = *((_QWORD *)v1 + 17);
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __SecTrustGetCertificateCount_block_invoke;
    v4[3] = &unk_1E1FDA8E0;
    v4[4] = &v5;
    v4[5] = v1;
    dispatch_sync(v2, v4);
    v1 = (SecTrustRef)v6[3];
    _Block_object_dispose(&v5, 8);
  }
  return (CFIndex)v1;
}

uint64_t SecItemCopyParentCertificates_ios(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  void *v6;
  NSObject *v7;
  uint64_t (*v8)(uint64_t, uint64_t, CFTypeRef *);
  uint64_t v9;
  os_activity_scope_state_s state;
  _QWORD v12[5];
  _QWORD v13[6];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  v6 = (void *)MEMORY[0x18D770A24]();
  v7 = _os_activity_create(&dword_18A900000, "SecItemCopyParentCertificates_ios", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  if (gSecurityd && (v8 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *))(gSecurityd + 40)) != 0)
  {
    v9 = v8(a1, a2, a3);
  }
  else
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v17 = 0;
    v12[4] = &v14;
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __data_array_to_array_error_request_block_invoke;
    v13[3] = &__block_descriptor_48_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v13[4] = a1;
    v13[5] = a2;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __data_array_to_array_error_request_block_invoke_2;
    v12[3] = &unk_1E1FD5DC0;
    securityd_send_sync_and_do(0x6Du, a3, (uint64_t)v13, (uint64_t)v12);
    v9 = v15[3];
    _Block_object_dispose(&v14, 8);
  }
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v6);
  return v9;
}

void sub_18A9424E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

OSStatus SSLGetPeerDomainName(SSLContextRef context, char *peerName, size_t *peerNameLen)
{
  OSStatus result;

  if (!context)
    return -50;
  result = tls_handshake_get_peer_hostname();
  if (!result)
  {
    if (*peerNameLen >= 0xAAAAAAAAAAAAAAAALL)
    {
      memcpy(peerName, (const void *)0xAAAAAAAAAAAAAAAALL, 0xAAAAAAAAAAAAAAAALL);
      result = 0;
      *peerNameLen = 0xAAAAAAAAAAAAAAAALL;
    }
    else
    {
      return -9817;
    }
  }
  return result;
}

OSStatus SSLSetSessionOption(SSLContextRef context, SSLSessionOption option, Boolean value)
{
  unsigned int v4;
  BOOL v5;
  int v6;
  OSStatus result;

  if (!context)
    return -50;
  v4 = *((_DWORD *)context + 20);
  v5 = v4 > 6;
  v6 = (1 << v4) & 0x59;
  if (v5 || v6 == 0)
    return -909;
  switch(option)
  {
    case kSSLSessionOptionBreakOnServerAuth:
      result = 0;
      *((_BYTE *)context + 353) = value;
      goto LABEL_13;
    case kSSLSessionOptionBreakOnCertRequested:
      result = 0;
      *((_BYTE *)context + 354) = value;
      break;
    case kSSLSessionOptionBreakOnClientAuth:
      result = 0;
      *((_BYTE *)context + 355) = value;
LABEL_13:
      *((_BYTE *)context + 187) = value == 0;
      break;
    case kSSLSessionOptionFalseStart:
      tls_handshake_set_false_start();
      result = 0;
      *((_BYTE *)context + 512) = value;
      break;
    case kSSLSessionOptionSendOneByteRecord:
      if (*((unsigned __int8 *)context + 315) != value)
        (*(void (**)(_QWORD, _QWORD, BOOL))(*((_QWORD *)context + 5) + 72))(*((_QWORD *)context + 6), 0, value != 0);
      result = 0;
      *((_BYTE *)context + 315) = value;
      break;
    case kSSLSessionOptionAllowServerIdentityChange:
      tls_handshake_set_server_identity_change();
      result = 0;
      *((_BYTE *)context + 360) = 1;
      break;
    case kSSLSessionOptionFallback:
      tls_handshake_set_fallback();
      result = 0;
      *((_BYTE *)context + 513) = value;
      break;
    case kSSLSessionOptionBreakOnClientHello:
      result = 0;
      *((_BYTE *)context + 359) = value;
      break;
    case kSSLSessionOptionAllowRenegotiation:
      tls_handshake_set_renegotiation();
      result = 0;
      *((_BYTE *)context + 361) = 1;
      break;
    case kSSLSessionOptionEnableSessionTickets:
      tls_handshake_set_session_ticket_enabled();
      result = 0;
      *((_BYTE *)context + 362) = 1;
      break;
    default:
      result = -50;
      break;
  }
  return result;
}

CFDataRef SecKeyCreateSignature(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef dataToSign, CFErrorRef *error)
{
  void *v8;
  NSObject *v9;
  __CFArray *Mutable;
  __CFData *v11;
  CFTypeRef v12;
  uint64_t v14[2];
  CFTypeRef cf;
  uint64_t v16;
  __CFString *v17;
  os_activity_scope_state_s state;

  v8 = (void *)MEMORY[0x18D770A24]();
  v9 = _os_activity_create(&dword_18A900000, "SecKeyCreateSignature", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyCreateSignature");
  if (!dataToSign)
    objc_msgSend(MEMORY[0x1E0C99DA0], "raise:format:", *MEMORY[0x1E0C99778], CFSTR("SecKeyCreateSignature() called with NULL dataToSign"));
  v17 = 0;
  v14[0] = (uint64_t)key;
  v14[1] = 0;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue(Mutable, algorithm);
  cf = Mutable;
  v16 = 0;
  v11 = SecKeyRunAlgorithmAndCopyResult(v14, dataToSign, 0, &v17);
  v12 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v12);
  }
  _SecKeyErrorPropagate(v11 != 0, (uint64_t)"SecKeyCreateSignature", v17, error);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v8);
  return v11;
}

void sub_18A942840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

CFStringRef SecFrameworkCopyLocalizedString(const __CFString *a1, const __CFString *a2)
{
  __CFBundle *Bundle;

  Bundle = (__CFBundle *)SecFrameworkGetBundle();
  if (Bundle)
    return CFBundleCopyLocalizedString(Bundle, a1, a1, a2);
  if (a1)
    CFRetain(a1);
  return a1;
}

OSStatus SSLSetPeerID(SSLContextRef context, const void *peerID, size_t peerIDLen)
{
  OSStatus result;
  unsigned int v7;
  BOOL v8;
  int v9;
  BOOL v10;
  void *v11;
  void *v12;
  size_t v13;

  result = -50;
  if (context && peerID && peerIDLen)
  {
    v7 = *((_DWORD *)context + 20);
    v8 = v7 > 6;
    v9 = (1 << v7) & 0x59;
    v10 = v8 || v9 == 0;
    if (!v10 || *((_DWORD *)context + 64) == 1)
    {
      v11 = (void *)*((_QWORD *)context + 27);
      if (v11)
        free(v11);
      *((_QWORD *)context + 26) = 0;
      *((_QWORD *)context + 27) = 0;
      v12 = malloc_type_malloc(peerIDLen, 0xEFB4CC30uLL);
      if (v12)
        v13 = peerIDLen;
      else
        v13 = 0;
      *((_QWORD *)context + 26) = v13;
      *((_QWORD *)context + 27) = v12;
      if (v12)
      {
        tls_handshake_set_resumption();
        memmove(*((void **)context + 27), peerID, peerIDLen);
        return 0;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return -909;
    }
  }
  return result;
}

OSStatus SecKeyEncrypt(SecKeyRef key, SecPadding padding, const uint8_t *plainText, size_t plainTextLen, uint8_t *cipherText, size_t *cipherTextLen)
{
  uint64_t AlgorithmId;
  OSStatus result;
  uint64_t v14;
  _QWORD v15[6];

  AlgorithmId = SecKeyGetAlgorithmId((uint64_t)key);
  result = -50;
  if (AlgorithmId == 1 && padding <= 2)
  {
    v14 = (uint64_t)*(&off_1E1FDD0B8 + (int)padding);
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = __SecKeyEncrypt_block_invoke;
    v15[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
    v15[4] = key;
    v15[5] = v14;
    return SecKeyPerformLegacyOperation(plainText, plainTextLen, 0, 0, cipherText, (CFIndex *)cipherTextLen, v15);
  }
  return result;
}

OSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate)
{
  void *v4;
  NSObject *v5;
  _QWORD v7[6];
  os_activity_scope_state_s state;

  v4 = (void *)MEMORY[0x18D770A24]();
  v5 = _os_activity_create(&dword_18A900000, "SecItemUpdate_ios", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = __SecItemUpdate_block_invoke;
  v7[3] = &__block_descriptor_48_e20_B16__0_____CFError_8l;
  v7[4] = query;
  v7[5] = attributesToUpdate;
  LODWORD(attributesToUpdate) = SecOSStatusWith((uint64_t)v7);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v4);
  return (int)attributesToUpdate;
}

void sub_18A942AF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t tls_handshake_load_session_data_callback(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  _QWORD *v6;
  void *v7;
  uint64_t session_data;
  size_t v10;
  void *v11;
  _QWORD v12[2];

  v12[0] = a2;
  v12[1] = a3;
  v6 = (_QWORD *)(a1 + 224);
  v7 = *(void **)(a1 + 232);
  if (v7)
    free(v7);
  *v6 = 0;
  v6[1] = 0;
  if (!*(_QWORD *)(a1 + 64))
    return 4294957492;
  v10 = 0;
  v11 = 0;
  session_data = _buildConfigurationSpecificSessionCacheKey(a1, (uint64_t)v12, &v10);
  if (!(_DWORD)session_data)
  {
    session_data = tls_cache_load_session_data();
    *a4 = *(_OWORD *)v6;
    free(v11);
  }
  return session_data;
}

uint64_t _buildConfigurationSpecificSessionCacheKey(uint64_t a1, uint64_t a2, size_t *a3)
{
  size_t v6;
  _WORD *v7;
  _WORD *v8;
  _BYTE *v9;
  _WORD *v10;
  __int16 v11;
  size_t v12;
  void *v13;
  uint64_t v14;

  if (!*(_QWORD *)(a1 + 376))
  {
    v9 = malloc_type_malloc(0xAuLL, 0x97F90E8AuLL);
    if (v9)
    {
      v8 = v9;
      *v9 = *(_BYTE *)(a1 + 353);
      v9[1] = *(_BYTE *)(a1 + 354);
      v9[2] = *(_BYTE *)(a1 + 355);
      v9[3] = *(_BYTE *)(a1 + 356);
      v9[4] = *(_BYTE *)(a1 + 357);
      v9[5] = *(_BYTE *)(a1 + 358);
      v9[6] = *(_BYTE *)(a1 + 359);
      v9[7] = *(_BYTE *)(a1 + 360);
      v9[8] = *(_BYTE *)(a1 + 361);
      v9[9] = *(_BYTE *)(a1 + 362);
      v6 = 10;
      *(_QWORD *)(a1 + 368) = 10;
      v10 = malloc_type_malloc(0xAuLL, 0x112F0A46uLL);
      *(_QWORD *)(a1 + 376) = v10;
      v11 = v8[4];
      *(_QWORD *)v10 = *(_QWORD *)v8;
      v10[4] = v11;
      goto LABEL_6;
    }
    return 4294967188;
  }
  v6 = *(_QWORD *)(a1 + 368);
  v7 = malloc_type_malloc(v6, 0xA78CAAAuLL);
  if (!v7)
    return 4294967188;
  v8 = v7;
  memcpy(v7, *(const void **)(a1 + 376), v6);
LABEL_6:
  v12 = *(_QWORD *)a2 + v6;
  *a3 = v12;
  v13 = malloc_type_malloc(v12, 0x989C50EEuLL);
  a3[1] = (size_t)v13;
  if (v13)
  {
    memcpy(v13, v8, v6);
    memcpy((void *)(a3[1] + v6), *(const void **)(a2 + 8), *(_QWORD *)a2);
    v14 = 0;
  }
  else
  {
    v14 = 4294967188;
  }
  free(v8);
  return v14;
}

OSStatus SecTrustSetAnchorCertificates(SecTrustRef trust, CFArrayRef anchorCertificates)
{
  uint64_t v4;
  NSObject *v5;
  CFTypeID v6;
  uint64_t Count;
  const __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v11;
  CFTypeID v12;
  NSObject *v13;
  NSObject *v14;
  OSStatus v15;
  const void *v16;
  _QWORD v18[7];
  uint8_t buf[8];
  uint64_t block;
  uint64_t p_block;
  uint64_t v22;
  void *v23;
  SecTrustRef v24;

  if (trust)
  {
    v4 = MEMORY[0x1E0C809B0];
    v5 = *((_QWORD *)trust + 17);
    block = MEMORY[0x1E0C809B0];
    p_block = 0x40000000;
    v22 = (uint64_t)__SecTrustSetNeedsEvaluation_block_invoke;
    v23 = &__block_descriptor_tmp_49_11514;
    v24 = trust;
    dispatch_sync(v5, &block);
    block = 0;
    p_block = (uint64_t)&block;
    v22 = 0x2000000000;
    v23 = 0;
    if (!anchorCertificates)
      goto LABEL_15;
    v6 = CFGetTypeID(anchorCertificates);
    if (v6 == CFArrayGetTypeID())
    {
      Count = CFArrayGetCount(anchorCertificates);
      Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E0C9B378]);
      *(_QWORD *)(p_block + 24) = Mutable;
      if (!Mutable)
      {
        v15 = -108;
        goto LABEL_21;
      }
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(anchorCertificates, i);
          if (ValueAtIndex && (v11 = ValueAtIndex, v12 = CFGetTypeID(ValueAtIndex), v12 == SecCertificateGetTypeID()))
          {
            CFArrayAppendValue(*(CFMutableArrayRef *)(p_block + 24), v11);
          }
          else
          {
            v13 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: anchorCertificates array contains non-certificate value", buf, 2u);
            }
          }
        }
        Mutable = *(const __CFArray **)(p_block + 24);
        v4 = MEMORY[0x1E0C809B0];
      }
      if (Count == CFArrayGetCount(Mutable))
      {
LABEL_15:
        v14 = *((_QWORD *)trust + 17);
        v18[0] = v4;
        v18[1] = 0x40000000;
        v18[2] = __SecTrustSetAnchorCertificates_block_invoke;
        v18[3] = &unk_1E1FDA048;
        v18[4] = &block;
        v18[5] = trust;
        v18[6] = anchorCertificates;
        dispatch_sync(v14, v18);
        v15 = 0;
LABEL_21:
        _Block_object_dispose(&block, 8);
        return v15;
      }
      v16 = *(const void **)(p_block + 24);
      if (v16)
        CFRelease(v16);
    }
    v15 = -50;
    goto LABEL_21;
  }
  return -50;
}

void sub_18A9431D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  _Block_object_dispose(&a35, 8);
  _Unwind_Resume(a1);
}

uint64_t tls_handshake_save_session_data_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  size_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[2];

  v11[0] = a2;
  v11[1] = a3;
  v9 = a4;
  v10 = a5;
  if (!*(_QWORD *)(a1 + 64))
    return 4294957492;
  v7 = 0;
  v8 = 0;
  v5 = _buildConfigurationSpecificSessionCacheKey(a1, (uint64_t)v11, &v7);
  if (!(_DWORD)v5)
  {
    v5 = tls_cache_save_session_data();
    free(v8);
  }
  return v5;
}

BOOL __sec_protocol_sec_array_of_dispatch_data_are_equal_block_invoke_2(uint64_t a1, uint64_t a2, NSObject *a3)
{
  BOOL v4;
  uint64_t v5;
  BOOL v6;

  if (*(_QWORD *)(a1 + 40) != a2)
    return 1;
  v4 = sec_protocol_dispatch_data_are_equal(*(dispatch_data_t *)(a1 + 48), a3);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_BYTE *)(v5 + 24))
    v6 = v4;
  else
    v6 = 0;
  *(_BYTE *)(v5 + 24) = v6;
  return *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

BOOL __sec_protocol_sec_array_of_dispatch_data_are_equal_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v3;
  _QWORD v5[7];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __sec_protocol_sec_array_of_dispatch_data_are_equal_block_invoke_2;
  v5[3] = &unk_1E1FCD640;
  v5[5] = a2;
  v5[6] = a3;
  v3 = *(void **)(a1 + 40);
  v5[4] = *(_QWORD *)(a1 + 32);
  return sec_array_apply(v3, v5);
}

OSStatus SecTrustSetNetworkFetchAllowed(SecTrustRef trust, Boolean allowFetch)
{
  int v2;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  OSStatus v7;
  _QWORD block[7];
  Boolean v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;
  _QWORD v19[5];

  if (!trust)
    return -50;
  v2 = allowFetch;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 1;
  v4 = *((_QWORD *)trust + 17);
  v5 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNetworkFetchAllowed_block_invoke;
  block[3] = &unk_1E1FDA1D8;
  block[5] = &v15;
  block[6] = trust;
  v10 = allowFetch;
  block[4] = &v11;
  dispatch_sync(v4, block);
  if (v2 && !*((_BYTE *)v12 + 24))
  {
    v6 = *((_QWORD *)trust + 17);
    v19[0] = v5;
    v19[1] = 0x40000000;
    v19[2] = __SecTrustSetNeedsEvaluation_block_invoke;
    v19[3] = &__block_descriptor_tmp_49_11514;
    v19[4] = trust;
    dispatch_sync(v6, v19);
  }
  v7 = *((_DWORD *)v16 + 6);
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v7;
}

__CFArray *SecTrustCopyOptionsFromPolicies(const __CFArray *a1)
{
  __CFArray *Mutable;
  CFIndex i;
  CFDictionaryRef *ValueAtIndex;
  const void *Value;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  for (i = 0; CFArrayGetCount(a1) > i; ++i)
  {
    ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(a1, i);
    Value = CFDictionaryGetValue(ValueAtIndex[4], CFSTR("NoNetworkAccess"));
    if (Value)
      CFArrayAppendValue(Mutable, Value);
  }
  if (!CFArrayGetCount(Mutable) && Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

__CFData *SecCertificateCopyIssuerSHA1Digest(uint64_t a1)
{
  __CFData *result;
  const __CFData *v2;
  const __CFAllocator *v3;
  const UInt8 *BytePtr;
  CFIndex Length;
  __CFData *v6;

  result = SecDERItemCopySequence(a1 + 152);
  if (result)
  {
    v2 = result;
    v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    BytePtr = CFDataGetBytePtr(result);
    Length = CFDataGetLength(v2);
    v6 = SecSHA1DigestCreate(v3, (uint64_t)BytePtr, Length);
    CFRelease(v2);
    return v6;
  }
  return result;
}

const __CFArray *SecCertificateCopyIPAddresses(uint64_t a1)
{
  const __CFArray *v1;
  CFIndex Count;
  uint64_t *v3;
  const void *v4;
  _QWORD context[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  CFMutableArrayRef Mutable;
  CFRange v11;

  v1 = SecCertificateCopyIPAddressDatas(a1);
  if (v1)
  {
    v7 = 0;
    v8 = &v7;
    v9 = 0x2000000000;
    Mutable = (CFMutableArrayRef)0xAAAAAAAAAAAAAAAALL;
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 0x40000000;
    context[2] = __SecCertificateCopyIPAddresses_block_invoke;
    context[3] = &unk_1E1FD53E0;
    context[4] = &v7;
    v11.length = CFArrayGetCount(v1);
    v11.location = 0;
    CFArrayApplyFunction(v1, v11, (CFArrayApplierFunction)apply_block_1_7636, context);
    CFRelease(v1);
    Count = CFArrayGetCount((CFArrayRef)v8[3]);
    v3 = v8;
    if (!Count)
    {
      v4 = (const void *)v8[3];
      if (v4)
      {
        v8[3] = 0;
        CFRelease(v4);
        v3 = v8;
      }
    }
    v1 = (const __CFArray *)v3[3];
    _Block_object_dispose(&v7, 8);
  }
  return v1;
}

CFMutableArrayRef SecCertificateCopyIPAddressDatas(uint64_t a1)
{
  CFMutableArrayRef Mutable;

  if (!*(_QWORD *)(a1 + 456))
    return 0;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (SecCertificateParseGeneralNames(*(_QWORD *)(a1 + 456) + 24, (uint64_t)Mutable, (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendIPAddressesFromGeneralNames)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

OSStatus SSLGetNegotiatedProtocolVersion(SSLContextRef context, SSLProtocol *protocol)
{
  SSLProtocol v2;
  OSStatus result;

  if (!context)
    return -50;
  v2 = kSSLProtocol3;
  switch(*((_DWORD *)context + 22))
  {
    case 0x300:
      break;
    case 0x301:
      v2 = kTLSProtocol1;
      break;
    case 0x302:
      v2 = kTLSProtocol11;
      break;
    case 0x303:
      v2 = kTLSProtocol12;
      break;
    default:
      v2 = kSSLProtocolUnknown;
      break;
  }
  result = 0;
  *protocol = v2;
  return result;
}

OSStatus SSLGetNegotiatedCipher(SSLContextRef context, SSLCipherSuite *cipherSuite)
{
  unsigned int v3;
  SSLCipherSuite negotiated_cipherspec;
  OSStatus result;

  if (!context)
    return -50;
  v3 = *((_DWORD *)context + 20);
  if (v3 < 7 && ((0x59u >> v3) & 1) != 0)
    return -909;
  negotiated_cipherspec = tls_handshake_get_negotiated_cipherspec();
  result = 0;
  *cipherSuite = negotiated_cipherspec;
  return result;
}

uint64_t get_aks_client_connection()
{
  uint64_t result;

  if (get_aks_client_dispatch_queue_onceToken != -1)
    dispatch_once(&get_aks_client_dispatch_queue_onceToken, &__block_literal_global_168);
  dispatch_sync((dispatch_queue_t)get_aks_client_dispatch_queue_connection_queue, &__block_literal_global_150);
  result = get_aks_client_connection_connection;
  if (!get_aks_client_connection_connection)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStore");
    return get_aks_client_connection_connection;
  }
  return result;
}

void __get_aks_client_connection_block_invoke()
{
  if (!get_aks_client_connection_connection)
    get_aks_client_connection_connection = _copy_aks_client_connection("IOService:/IOResources/AppleKeyStore", "AppleKeyStore");
}

dispatch_queue_t __get_aks_client_dispatch_queue_block_invoke()
{
  dispatch_queue_t result;

  result = dispatch_queue_create("aks-client-queue", 0);
  get_aks_client_dispatch_queue_connection_queue = (uint64_t)result;
  return result;
}

uint64_t _copy_aks_client_connection(char *path, const char *a2)
{
  mach_port_t v3;
  io_service_t v4;
  task_port_t *v5;
  io_object_t v6;
  kern_return_t v7;
  const __CFDictionary *v8;
  io_service_t MatchingService;
  io_object_t v10;
  uint64_t result;
  kern_return_t v12;
  io_connect_t connect;

  connect = 0;
  v3 = *MEMORY[0x1E0CBBAB8];
  v4 = IORegistryEntryFromPath(*MEMORY[0x1E0CBBAB8], path);
  v5 = (task_port_t *)MEMORY[0x1E0C83DA0];
  if (!v4 || (v6 = v4, v7 = IOServiceOpen(v4, *MEMORY[0x1E0C83DA0], 0, &connect), IOObjectRelease(v6), v7))
  {
    v8 = IOServiceMatching(a2);
    MatchingService = IOServiceGetMatchingService(v3, v8);
    if (MatchingService)
    {
      v10 = MatchingService;
      IOServiceOpen(MatchingService, *v5, 0, &connect);
      IOObjectRelease(v10);
    }
  }
  result = connect;
  if (connect)
  {
    v12 = IOConnectCallMethod(connect, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    result = connect;
    if (v12)
    {
      IOServiceClose(connect);
      return 0;
    }
  }
  return result;
}

uint64_t aks_unlock_bag(int a1, uint64_t a2, int a3)
{
  mach_port_t aks_client_connection;
  uint64_t input[4];

  input[3] = *MEMORY[0x1E0C80C00];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    input[2] = a3;
    return IOConnectCallMethod(aks_client_connection, 0xCu, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C20], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unlock_bag", ":", 807, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_create_bag(uint64_t a1, int a2, unsigned int a3, _DWORD *a4)
{
  return _create_bag(a1, a2, 0, 0, a3, -1, a4);
}

uint64_t _create_bag(uint64_t a1, int a2, uint64_t a3, int a4, unsigned int a5, int a6, _DWORD *a7)
{
  uint64_t v14;
  mach_port_t aks_client_connection;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[7];

  input[6] = *MEMORY[0x1E0C80C00];
  v14 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a7)
    {
      input[0] = a5;
      input[1] = a6;
      input[2] = a1;
      input[3] = a2;
      input[4] = a3;
      input[5] = a4;
      output = 0;
      outputCnt = 1;
      v14 = IOConnectCallMethod(aks_client_connection, 2u, input, 6u, 0, 0, &output, &outputCnt, 0, 0);
      if (!(_DWORD)v14)
        *a7 = output;
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C20], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_create_bag", ":", 187, "", 0, "", "");
  }
  return v14;
}

uint64_t aks_load_bag(const void *a1, int a2, _DWORD *a3)
{
  uint64_t v6;
  mach_port_t aks_client_connection;
  uint32_t outputCnt;
  uint64_t output[2];

  output[1] = *MEMORY[0x1E0C80C00];
  v6 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v6 = 3758097090;
    if (a1)
    {
      if (a3)
      {
        output[0] = 0;
        outputCnt = 1;
        v6 = IOConnectCallMethod(aks_client_connection, 6u, 0, 0, a1, a2, output, &outputCnt, 0, 0);
        if (!(_DWORD)v6)
          *a3 = output[0];
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C20], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_load_bag", ":", 574, "", 0, "", "");
  }
  return v6;
}

uint64_t aks_unload_bag(int a1)
{
  mach_port_t aks_client_connection;
  uint64_t input[2];

  input[1] = *MEMORY[0x1E0C80C00];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 4u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C20], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unload_bag", ":", 612, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t aks_save_bag(uint64_t a1)
{
  int v1;
  _DWORD *v2;
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  int v6;
  mach_port_t aks_client_connection;
  mach_port_t v8;
  uint64_t result;
  void *v10;
  size_t __count;
  uint64_t input;
  _BYTE __src[32768];
  uint64_t v14;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v6 = v1;
  v14 = *MEMORY[0x1E0C80C00];
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    v8 = aks_client_connection;
    result = 3758097090;
    if (v5)
    {
      if (v3)
      {
        bzero(__src, 0x8000uLL);
        __count = 0x8000;
        input = v6;
        result = IOConnectCallMethod(v8, 3u, &input, 1u, 0, 0, 0, 0, __src, &__count);
        if (!(_DWORD)result)
        {
          v10 = calloc(__count, 1uLL);
          *v5 = v10;
          if (v10)
          {
            memcpy(v10, __src, __count);
            result = 0;
            *v3 = __count;
          }
          else
          {
            return 3758097085;
          }
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C20], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_save_bag", ":", 646, "", 0, "", "");
    return 3758097084;
  }
  return result;
}

uint64_t aks_get_lock_state(int a1, _DWORD *a2)
{
  uint64_t v4;
  mach_port_t aks_client_connection;
  uint32_t outputCnt;
  uint64_t output;
  uint64_t input[2];

  input[1] = *MEMORY[0x1E0C80C00];
  v4 = 3758097084;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      output = 0;
      input[0] = a1;
      outputCnt = 1;
      v4 = IOConnectCallMethod(aks_client_connection, 7u, input, 1u, 0, 0, &output, &outputCnt, 0, 0);
      if (!(_DWORD)v4)
        *a2 = output;
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C20], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_lock_state", ":", 824, "", 0, "", "");
  }
  return v4;
}

uint64_t aks_assert_hold(int a1, unsigned int a2, uint64_t a3)
{
  mach_port_t aks_client_connection;
  uint64_t input[4];

  input[3] = *MEMORY[0x1E0C80C00];
  input[0] = a2;
  input[1] = a3;
  input[2] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x1Au, input, 3u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x1E0C80C20], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_hold", ":", 1654, "", 0, "", "");
  return 3758097084;
}

uint64_t aks_assert_drop(int a1, unsigned int a2)
{
  mach_port_t aks_client_connection;
  uint64_t input[3];

  input[2] = *MEMORY[0x1E0C80C00];
  input[0] = a2;
  input[1] = a1;
  aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
    return IOConnectCallMethod(aks_client_connection, 0x1Bu, input, 2u, 0, 0, 0, 0, 0, 0);
  fprintf((FILE *)*MEMORY[0x1E0C80C20], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_drop", ":", 1672, "", 0, "", "");
  return 3758097084;
}

uint64_t amfi_interface_cdhash_in_trustcache(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;

  result = 22;
  if (a1 && a2 == 20 && a3)
  {
    *a3 = 0;
    result = __sandbox_ms();
    if ((_DWORD)result)
      return *__error();
    else
      *a3 = 0;
  }
  return result;
}

BOOL amfi_developer_mode_status()
{
  uint64_t v2;
  size_t v3;

  v2 = 0;
  v3 = 8;
  return !sysctlbyname("security.mac.amfi.developer_mode_status", &v2, &v3, 0, 0) && v2 == 1;
}

uint64_t amfi_launch_constraint_matches_process(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  int *v4;
  uint64_t result;
  int v6;
  _QWORD v7[129];

  v4 = (int *)a4;
  v7[128] = *MEMORY[0x1E0C80C00];
  if (a2 && a3)
  {
    if (a3 <= 0x4000)
    {
      bzero(v7, 0x400uLL);
      v6 = 5;
      if (!v4)
        v4 = &v6;
      if (!__sandbox_ms() && !*v4)
        return 1;
    }
    else if (a4)
    {
      result = 0;
      *(_DWORD *)a4 = 5;
      strcpy((char *)(a4 + 4), "Constraint too large");
      return result;
    }
  }
  else if (a4)
  {
    result = 0;
    *(_DWORD *)a4 = 5;
    strcpy((char *)(a4 + 4), "No Constraint provided");
    return result;
  }
  return 0;
}

uint64_t ccder_encode_extension(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, _QWORD *a6)
{
  uint64_t result;
  uint64_t v9;

  if (a6[1] - *a6 < (unint64_t)ccder_sizeof_extension(a2, a4, a5))
    return 0;
  result = ccder_blob_encode_body_tl();
  if (!(_DWORD)result)
    return 0;
  if (!a5)
    goto LABEL_6;
  v9 = a6[1];
  if (v9)
  {
    a6[1] = v9 - 1;
    *(_BYTE *)(v9 - 1) = -1;
    if (ccder_blob_encode_tl())
    {
LABEL_6:
      if (ccder_blob_encode_body_tl())
        return ccder_blob_encode_tl();
    }
    return 0;
  }
  __break(0x5513u);
  return result;
}

uint64_t ccder_sizeof_extension(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v4 = ccder_sizeof();
  v5 = ccder_sizeof();
  if (a3)
    result = ccder_sizeof();
  else
    result = 0;
  if (!__CFADD__(result, v5) && !__CFADD__(result + v5, v4))
    return ccder_sizeof();
  __break(0x5500u);
  return result;
}

uint64_t CTDecompressComputeBufferSize(unint64_t a1, unint64_t a2, _QWORD *a3)
{
  return CTDecompressGeneric(a1, a2, a3, 0, 0);
}

uint64_t CTDecompressGeneric(unint64_t a1, unint64_t a2, _QWORD *a3, unint64_t a4, unint64_t a5)
{
  unint64_t v5;
  uint64_t v6;
  int v11;
  unint64_t v12;
  unint64_t *v13;
  uint64_t Signature;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  BOOL v23;
  unsigned int v24;
  int v25;
  _BYTE *v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  __int128 v37;
  unint64_t v38;
  _BYTE *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  _BOOL4 v45;
  const void *v46;
  unsigned int v47;
  _OWORD *v48;
  uint64_t v49;
  __int128 v50;
  unsigned int v51;
  char v52;
  unint64_t v53;
  void *v54;
  const char *v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  size_t v62;
  unint64_t v63;
  unint64_t v64;
  const void *v65;
  unint64_t v67;
  unint64_t v68;
  char *v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  char *v76;
  unint64_t v77;
  size_t v78;
  unint64_t v79;
  int v80;
  unint64_t v81;
  size_t v82;
  unint64_t *v83;
  unint64_t v84;
  _QWORD *v85;
  uint64_t v86;
  __int128 v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  _OWORD v92[2];
  _BYTE v93[32];
  __int128 v94;
  __int128 v95;
  char v96;
  uint64_t v97;

  v97 = *MEMORY[0x1E0C80C00];
  v6 = 393217;
  if (a1 && a2)
  {
    v85 = a3;
    if ((uint64_t)a2 <= 0)
      goto LABEL_240;
    v11 = *(unsigned __int8 *)a1;
    *(_QWORD *)&v87 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v87 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v84 = ~a4;
    if (~a4 < a5)
      goto LABEL_241;
    v12 = a4 + a5;
    if (a4 + a5 < a4)
      goto LABEL_240;
    *(_QWORD *)&v87 = a4;
    *((_QWORD *)&v87 + 1) = a4 + a5;
    if (a4)
      v13 = (unint64_t *)&v87;
    else
      v13 = 0;
    v86 = 0;
    if ((v11 - 2) >= 2 && (v11 - 162) >= 2)
    {
      v83 = v13;
      v20 = 0;
    }
    else
    {
      *(_QWORD *)v93 = 0;
      *(_QWORD *)&v92[0] = 0;
      Signature = CTDecompressGetSignature(v11, a1, a2, (unint64_t *)v92, v93);
      if ((_DWORD)Signature)
        return Signature;
      v15 = CTNonVariableCompressedSizeForStyle(v11);
      v16 = a2 - v15;
      if (a2 < v15 || (v5 = v16 - *(_QWORD *)v93, v16 < *(_QWORD *)v93))
      {
        __break(0x5515u);
        goto LABEL_204;
      }
      v83 = v13;
      if (__CFADD__(*(_QWORD *)&v92[0], *(_QWORD *)v93))
        goto LABEL_241;
      v17 = *(_QWORD *)&v92[0] + *(_QWORD *)v93;
      if (!((uint64_t)(*(_QWORD *)&v92[0] + *(_QWORD *)v93 - a1) >= 0
           ? *(_QWORD *)&v92[0] + *(_QWORD *)v93 >= a1
           : *(_QWORD *)&v92[0] + *(_QWORD *)v93 < a1))
        goto LABEL_241;
      v19 = ccder_sizeof_extension(v5, 10, 0);
      v20 = v19;
      if (a4)
      {
        if (*((_QWORD *)&v87 + 1) - (_QWORD)v87 < v19)
          return 393220;
        if (a1 + a2 < v17 || v17 < a1 || v5 > a1 + a2 - v17)
          goto LABEL_240;
        if ((ccder_encode_extension(v17, v5, (uint64_t)&CTOidAppleMFI4AccessoryData, 10, 0, &v87) & 1) == 0)
          return 393220;
      }
    }
    if (v11 > 160)
    {
      if (v11 != 163 && v11 != 161)
        goto LABEL_45;
    }
    else if (v11 != 1 && v11 != 3)
    {
LABEL_45:
      if ((v11 - 4) < 2 || (v11 - 164) < 2)
        goto LABEL_47;
      v28 = ccder_sizeof_extension(32, 10, 1);
      v29 = 72;
      if ((~v11 & 0xA0) == 0)
        v29 = 70;
      Signature = 393217;
      if ((v29 | 0x20uLL) > a2)
        return Signature;
      v5 = v28;
      if (!a4)
      {
        if (__CFADD__(a1, v29))
          goto LABEL_241;
LABEL_95:
        v23 = __CFADD__(v20, v5);
        v20 += v5;
        if (v23)
          goto LABEL_245;
LABEL_47:
        a3 = &leaf_5280_extensions_template;
        if (v11 > 159)
        {
          if ((v11 - 160) < 4)
          {
            v25 = 0;
            v26 = &ca_5280_extensions_template;
            v27 = 33;
            v5 = 102;
            goto LABEL_65;
          }
          v24 = v11 - 164;
        }
        else
        {
          v24 = v11 - 4;
          if (v11 < 4)
          {
            v25 = 0;
            v26 = &ca_5280_extensions_template;
            v27 = 33;
            v5 = 104;
            goto LABEL_65;
          }
        }
        Signature = 393218;
        if (v24 >= 2)
          return Signature;
        a3 = &ca_5280_extensions_template;
        v26 = &CTOidAppleMFI4ProductPlanUID;
        v25 = 1;
        v27 = 97;
        v5 = 78;
LABEL_65:
        Signature = 393217;
        if (v5 + 20 > a2)
          return Signature;
        if (a4)
        {
          v30 = v87;
          if (*((_QWORD *)&v87 + 1) - (_QWORD)v87 < v27)
            return 393220;
          v80 = v25;
          if ((unint64_t)v87 > *((_QWORD *)&v87 + 1))
            goto LABEL_240;
          v92[0] = v87;
          v23 = v26 >= (_BYTE *)a3;
          v34 = v26 - (_BYTE *)a3;
          if (!v23 || v27 > v34)
            goto LABEL_240;
          v74 = v27;
          v77 = *((_QWORD *)&v87 + 1);
          if (!ccder_blob_encode_body())
            return 393226;
          if (v80)
          {
            v90 = 0xAAAAAAAAAAAAAAAALL;
            v91 = 0xAAAAAAAAAAAAAAAALL;
            if (v77 >= 0xFFFFFFFFFFFFFFD1)
              goto LABEL_241;
            if (v77 < 0x2F || v30 > v77 - 47)
              goto LABEL_240;
            v90 = v30;
            v91 = v77 - 47;
            if (__CFADD__(a1, v5))
              goto LABEL_241;
            a3 = (_QWORD *)(a1 + v5);
            if (a1 + v5 < a1 || a2 - v5 < 0x14)
              goto LABEL_240;
            if ((ccder_blob_encode_body() & 1) == 0)
              return 393226;
            v5 = v30;
            memset(v93, 170, 20);
            Signature = CTDecompressCAComputeSKID(a1, a2, (uint64_t)v93);
            if ((_DWORD)Signature)
              return Signature;
            if (v5 > v77 - 16)
              goto LABEL_240;
            v88 = v5;
            v89 = v77 - 16;
          }
          else
          {
            if (__CFADD__(a1, v5))
              goto LABEL_241;
            a3 = (_QWORD *)(a1 + v5);
            if (a1 + v5 < a1 || a2 - v5 < 0x14)
              goto LABEL_240;
          }
          if ((ccder_blob_encode_body() & 1) == 0)
            return 393226;
          if (__CFADD__(v20, v74))
            goto LABEL_245;
          if ((ccder_blob_encode_tl() & 1) == 0)
            return 393220;
          ccder_sizeof();
          if ((ccder_blob_encode_tl() & 1) == 0)
            return 393220;
        }
        else
        {
          if (__CFADD__(v20, v27))
            goto LABEL_245;
          ccder_sizeof();
        }
        v5 = ccder_sizeof();
        v86 = v5;
        if (v11 > 159)
        {
          if ((v11 - 160) < 4)
          {
            v33 = 37;
            goto LABEL_109;
          }
          v32 = v11 - 164;
        }
        else
        {
          v32 = v11 - 4;
          if (v11 < 4)
          {
            v33 = 39;
            goto LABEL_109;
          }
        }
        Signature = 393218;
        if (v32 >= 2)
          return Signature;
        v33 = 45;
LABEL_109:
        Signature = 393217;
        if (v33 + 33 > a2)
          return Signature;
        if (a4 && *((_QWORD *)&v87 + 1) - (_QWORD)v87 < 0x5BuLL)
          return 393220;
        v35 = ~a1;
        if (v33 > ~a1)
          goto LABEL_241;
        v36 = a1 + v33;
        if (v36 < a1)
          goto LABEL_240;
        v81 = a1 + a2;
        if (a1 + a2 - v36 <= 0x20)
          goto LABEL_240;
        *(_QWORD *)&v92[0] = v36;
        *((_QWORD *)&v92[0] + 1) = 33;
        v96 = -86;
        *(_QWORD *)&v37 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v37 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v95 = v37;
        *(_OWORD *)&v93[16] = v37;
        v94 = v37;
        *(_OWORD *)v93 = v37;
        Signature = decompressECPublicKey((uint64_t)v92, (int **)&CTOidSECP256r1, (uint64_t)v93, 65);
        if ((_DWORD)Signature)
          return Signature;
        if (a4)
        {
          Signature = 393226;
          if (!ccder_blob_encode_body() || (ccder_blob_encode_body() & 1) == 0)
            return Signature;
        }
        v86 = 91;
        v38 = v5 + 91;
        Signature = 393218;
        if (v5 >= 0xFFFFFFFFFFFFFFA5)
          goto LABEL_245;
        if (v11 > 159)
        {
          if ((v11 - 160) < 4)
          {
            a3 = &attestation_leaf_subject;
            v39 = &attestation_ca_subject;
            v40 = 14;
            v41 = 64;
            v42 = 164;
            v5 = 37;
            v43 = 33;
            goto LABEL_130;
          }
          if ((v11 - 164) >= 2)
            return Signature;
          a3 = &attestation_ca_subject;
          v39 = &root_subject;
          v40 = 58;
          v42 = 108;
        }
        else
        {
          if (v11 < 4)
          {
            a3 = &mfi_leaf_subject;
            v39 = &mfi_ca_subject;
            v40 = 17;
            v41 = 32;
            v42 = 119;
            v5 = 1;
            v43 = 16;
            goto LABEL_130;
          }
          if ((v11 - 4) >= 2)
            return Signature;
          a3 = &mfi_ca_subject;
          v39 = &attestation_leaf_subject;
          v40 = 57;
          v42 = 107;
        }
        v5 = 37;
        v43 = 8;
        v41 = 8;
LABEL_130:
        Signature = 393217;
        if (v5 + v43 > a2)
          return Signature;
        if (a4)
        {
          v44 = v87;
          if (*((_QWORD *)&v87 + 1) - (_QWORD)v87 < v42)
            return 393220;
          v75 = v40;
          v78 = v43;
          v73 = v41;
          v71 = v38;
          if ((unint64_t)v87 > *((_QWORD *)&v87 + 1) || a3 > (_QWORD *)v39 || v42 > v39 - (_BYTE *)a3)
            goto LABEL_240;
          v72 = *((_QWORD *)&v87 + 1);
          v70 = v42;
          if (!ccder_blob_encode_body())
            return 393226;
          if (__CFADD__(*((_QWORD *)&v87 + 1), v75))
            goto LABEL_241;
          v76 = (char *)(*((_QWORD *)&v87 + 1) + v75);
          v45 = (uint64_t)&v76[-v44] >= 0 ? (unint64_t)v76 >= v44 : (unint64_t)v76 < v44;
          if (!v45 || v5 > v35)
            goto LABEL_241;
          v46 = (const void *)(a1 + v5);
          if (a1 + v5 < a1
            || (unint64_t)v76 > v72
            || v44 > (unint64_t)v76
            || v73 > v72 - (unint64_t)v76
            || (unint64_t)v46 > v81
            || v78 > v81 - (unint64_t)v46)
          {
            goto LABEL_240;
          }
          if (v11 > 159)
          {
            if ((v11 - 160) < 4)
            {
              v90 = a1 + v5;
              v91 = v78;
              v96 = -86;
              *(_QWORD *)&v50 = 0xAAAAAAAAAAAAAAAALL;
              *((_QWORD *)&v50 + 1) = 0xAAAAAAAAAAAAAAAALL;
              v95 = v50;
              *(_OWORD *)&v93[16] = v50;
              v94 = v50;
              *(_OWORD *)v93 = v50;
              Signature = decompressECPublicKey((uint64_t)&v90, (int **)&CTOidSECP256r1, (uint64_t)v93, 65);
              if ((_DWORD)Signature)
                goto LABEL_156;
              ccsha256_di();
              memset(v92, 0, sizeof(v92));
              ccdigest();
              v48 = v92;
              v49 = 32;
LABEL_155:
              Signature = CTConvertByteArrayToAsciiHex((unint64_t)v48, v49, v76, v73);
LABEL_156:
              v42 = v70;
              v38 = v71;
              if ((_DWORD)Signature)
                return Signature;
              goto LABEL_162;
            }
            v47 = v11 - 164;
          }
          else
          {
            v47 = v11 - 4;
            if (v11 < 4)
            {
              v48 = (_OWORD *)(a1 + v5);
              v49 = v78;
              goto LABEL_155;
            }
          }
          Signature = 393218;
          if (v47 >= 2)
            return Signature;
          if (v78 > v73)
            goto LABEL_240;
          memcpy(v76, v46, v78);
          v42 = v70;
          v38 = v71;
        }
LABEL_162:
        v86 = v42;
        if (__CFADD__(v38, v42))
          goto LABEL_245;
        v79 = v38 + v42;
        if (v11 > 159)
        {
          if ((v11 - 160) < 4)
          {
LABEL_169:
            v55 = 0;
            v54 = 0;
            v52 = 1;
            v5 = 9;
            v53 = 23;
LABEL_170:
            if (v5 + 14 > a2)
              return 393217;
            Signature = 393217;
            if (v53 + 14 <= a2)
            {
              if (v5 > v35)
                goto LABEL_241;
              if ((v52 & 1) != 0)
              {
                if (v53 > v35)
                  goto LABEL_241;
                v56 = a1 + v53;
                v55 = (const char *)(a1 + a2);
                v54 = (void *)a1;
              }
              else
              {
                v56 = (unint64_t)v54;
              }
              *(_QWORD *)v93 = 0;
              if (v56 <= (unint64_t)v55 && (unint64_t)v54 <= v56 && (uint64_t)&v55[-v56] > 13)
              {
                Signature = CTDecompressDate(v56, v83, (unint64_t *)v93);
                if ((_DWORD)Signature)
                  return Signature;
                v57 = a1 + v5;
                if (a1 + v5 >= a1 && (uint64_t)(v81 - v57) >= 14)
                {
                  v58 = *(_QWORD *)v93;
                  Signature = CTDecompressDate(v57, v83, (unint64_t *)v93);
                  if ((_DWORD)Signature)
                    return Signature;
                  if (__CFADD__(v58, *(_QWORD *)v93))
                    goto LABEL_245;
                  if (a4 && (ccder_blob_encode_tl() & 1) == 0)
                    return 393220;
                  v86 = ccder_sizeof();
                  v59 = v79 + v86;
                  if (__CFADD__(v79, v86))
                    goto LABEL_245;
                  Signature = CTDecompressIssuer(v11, a1, a2, v83, (unint64_t *)&v86);
                  if ((_DWORD)Signature)
                    return Signature;
                  v23 = __CFADD__(v59, v86);
                  v60 = v59 + v86;
                  if (v23)
                    goto LABEL_245;
                  if (a4)
                  {
                    if (*((_QWORD *)&v87 + 1) - (_QWORD)v87 < 0xCuLL)
                      return 393220;
                    if (!ccder_blob_encode_body())
                      return 393226;
                  }
                  v86 = 12;
                  v23 = __CFADD__(v60, 12);
                  v61 = v60 + 12;
                  if (v23)
                    goto LABEL_245;
                  Signature = CTDecompressSerialNumber(v11, (_OWORD *)a1, a2, v83, (unint64_t *)&v86);
                  if ((_DWORD)Signature)
                    return Signature;
                  v23 = __CFADD__(v61, v86);
                  v5 = v61 + v86;
                  if (v23)
                    goto LABEL_245;
                  if (a4)
                  {
                    if (*((_QWORD *)&v87 + 1) - (_QWORD)v87 < 5uLL)
                      return 393220;
                    if ((ccder_blob_encode_body() & 1) != 0)
                    {
                      v86 = 5;
                      if (v5 >= 0xFFFFFFFFFFFFFFFBLL)
                        goto LABEL_245;
                      if (!ccder_blob_encode_tl())
                        return 393226;
LABEL_205:
                      v62 = ccder_sizeof();
                      *(_QWORD *)v93 = 0;
                      *(_QWORD *)&v92[0] = 0;
                      Signature = CTDecompressGetSignature(v11, a1, a2, (unint64_t *)v92, v93);
                      if ((_DWORD)Signature)
                        return Signature;
                      if (*(_QWORD *)v93 == -1)
                        goto LABEL_245;
                      v82 = v62 + 12;
                      if (v62 >= 0xFFFFFFFFFFFFFFF4 || __CFADD__(v82, ccder_sizeof()))
                        goto LABEL_245;
                      v63 = ccder_sizeof_tl();
                      v5 = v63;
                      if (a4)
                      {
                        v64 = v63 + v62;
                        if (__CFADD__(v63, v62))
                          goto LABEL_245;
                        if (v64 > a5)
                          return 393220;
                        if (v63 > v84)
                          goto LABEL_241;
                        v65 = (const void *)*((_QWORD *)&v87 + 1);
                        if (!((uint64_t)(*((_QWORD *)&v87 + 1) - a4) >= 0
                             ? *((_QWORD *)&v87 + 1) >= a4
                             : *((_QWORD *)&v87 + 1) < a4))
                          goto LABEL_241;
                        *(_QWORD *)&v87 = a4;
                        *((_QWORD *)&v87 + 1) = a4 + a5;
                        if ((unint64_t)v65 > v12)
                          goto LABEL_240;
                        if ((unint64_t)v65 < a4)
                          goto LABEL_240;
                        if (v62 > v12 - (unint64_t)v65)
                          goto LABEL_240;
                        v67 = a4 + v63;
                        if (a4 + v63 > v12 || v67 < a4 || v62 > v12 - v67)
                          goto LABEL_240;
                        memmove((void *)(a4 + v63), v65, v62);
                        if (v64 >= 0xFFFFFFFFFFFFFFF4)
                          goto LABEL_245;
                        if (v64 + 12 > a5)
                          return 393220;
                        if (__CFADD__(v67, v62))
                          goto LABEL_241;
                        v68 = v67 + v62;
                        if (v12 < v67 + v62 || v68 < a4 || v12 - (v67 + v62) < 0xC)
                          goto LABEL_240;
                        *(_DWORD *)(v68 + 8) = 33752125;
                        *(_QWORD *)v68 = 0xCE48862A08060A30;
                      }
                      Signature = CTDecompressSignature(v11, a1, a2, v83, (unint64_t *)&v86);
                      if ((_DWORD)Signature)
                        return Signature;
                      a3 = (_QWORD *)(v82 + v86);
                      if (__CFADD__(v82, v86))
                        goto LABEL_245;
                      if (!a4)
                        goto LABEL_242;
                      v69 = (char *)a3 + v5;
                      if (__CFADD__(v5, a3))
                        goto LABEL_245;
                      Signature = 393220;
                      if ((unint64_t)v69 > a5)
                        return Signature;
                      if (v5 <= v84)
                      {
                        if (a4 + v5 <= v12 && a4 + v5 >= a4)
                        {
                          *(_QWORD *)&v87 = a4;
                          *((_QWORD *)&v87 + 1) = a4 + v5;
                          if ((ccder_blob_encode_tl() & 1) == 0)
                            return 393226;
                          goto LABEL_243;
                        }
                        goto LABEL_240;
                      }
LABEL_241:
                      __break(0x5513u);
LABEL_242:
                      v69 = (char *)a3 + v5;
                      if (!__CFADD__(a3, v5))
                      {
LABEL_243:
                        if (v85)
                        {
                          Signature = 0;
                          *v85 = v69;
                          return Signature;
                        }
                        return 0;
                      }
LABEL_245:
                      __break(0x5500u);
                      return 0;
                    }
                    return 393226;
                  }
LABEL_204:
                  v86 = 5;
                  if (v5 >= 0xFFFFFFFFFFFFFFFBLL)
                    goto LABEL_245;
                  goto LABEL_205;
                }
              }
LABEL_240:
              __break(0x5519u);
              goto LABEL_241;
            }
            return Signature;
          }
          v51 = v11 - 164;
        }
        else
        {
          v51 = v11 - 4;
          if (v11 < 4)
          {
            v52 = 0;
            v53 = 0;
            v54 = &endOfTime;
            v55 = nibbleToAsciiByte;
            v5 = 25;
            goto LABEL_170;
          }
        }
        Signature = 393218;
        if (v51 >= 2)
          return Signature;
        goto LABEL_169;
      }
      if (*((_QWORD *)&v87 + 1) - (_QWORD)v87 >= v28)
      {
        if (__CFADD__(a1, v29))
          goto LABEL_241;
        if (a1 + v29 < a1 || a2 - v29 < 0x20)
          goto LABEL_240;
        if (ccder_encode_extension(a1 + v29, 32, (uint64_t)&CTOidAppleMFI4Properties, 10, 1, &v87))
          goto LABEL_95;
      }
      return 393220;
    }
    v21 = ccder_sizeof_extension(36, 10, 0);
    v22 = 124;
    if ((~v11 & 0xA0) == 0)
      v22 = 122;
    Signature = 393217;
    if (v22 + 36 > a2)
      return Signature;
    v5 = v21;
    if (a4)
    {
      if (*((_QWORD *)&v87 + 1) - (_QWORD)v87 < v21)
        return 393220;
      if (__CFADD__(a1, v22))
        goto LABEL_241;
      if (a1 + v22 < a1 || a2 - v22 < 0x24)
        goto LABEL_240;
      if (!ccder_encode_extension(a1 + v22, 36, (uint64_t)&CTOidAppleMFI4ProductPlanUID, 10, 0, &v87))
        return 393220;
    }
    else if (__CFADD__(a1, v22))
    {
      goto LABEL_241;
    }
    v23 = __CFADD__(v20, v5);
    v20 += v5;
    if (v23)
      goto LABEL_245;
    goto LABEL_45;
  }
  return v6;
}

uint64_t CTDecompress(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  return CTDecompressGeneric(a1, a2, 0, a3, a4);
}

uint64_t CTCompressComputeBufferSize(unint64_t a1, uint64_t a2, _QWORD *a3)
{
  __int128 v6;
  uint64_t v7;
  uint64_t result;
  int v9;
  int v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15[2];
  _OWORD v16[4];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (__CFADD__(a1, a2))
  {
    __break(0x5513u);
LABEL_16:
    __break(0x5519u);
  }
  if (a1 + a2 < a1)
    goto LABEL_16;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v30 = v6;
  v31 = v6;
  v28 = v6;
  v29 = v6;
  v26 = v6;
  v27 = v6;
  v24 = v6;
  v25 = v6;
  v22 = v6;
  v23 = v6;
  v20 = v6;
  v21 = v6;
  v18 = v6;
  v19 = v6;
  v16[3] = v6;
  v17 = v6;
  v16[1] = v6;
  v16[2] = v6;
  v16[0] = v6;
  v15[0] = a1;
  v15[1] = a1 + a2;
  v7 = X509CertificateParse((unint64_t *)v16, v15);
  if ((_DWORD)v7)
    return v7;
  v7 = 393218;
  v9 = CTCompressedStyleFromCert((uint64_t)v16);
  if (v9 == 255)
    return v7;
  v10 = v9;
  result = CTNonVariableCompressedSizeForStyle(v9);
  if (result < 0)
    return v7;
  v11 = result + v17;
  if (!__CFADD__(result, (_QWORD)v17))
  {
    if ((v10 - 162) >= 2 && (v10 - 2) > 1)
      goto LABEL_13;
    v13 = 0;
    v14 = 0;
    result = CTParseExtensionValue(a1, a2, &CTOidAppleMFI4AccessoryData, 0xAuLL, &v13, &v14);
    if ((_DWORD)result)
      return result;
    v12 = __CFADD__(v11, v14);
    v11 += v14;
    if (!v12)
    {
LABEL_13:
      v7 = 0;
      if (a3)
        *a3 = v11;
      return v7;
    }
  }
  __break(0x5500u);
  return result;
}

uint64_t CTCompressedStyleFromCert(uint64_t a1)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11[3];

  v11[2] = *MEMORY[0x1E0C80C00];
  v11[0] = 0xAAAAAAAAAAAAAAAALL;
  v11[1] = 0xAAAAAAAAAAAAAAAALL;
  if (X509CertificateSubjectNameGetCommonName((unint64_t *)(a1 + 120), v11))
    return 255;
  if (*(_BYTE *)(a1 + 265))
  {
    X509PolicySetFlagsForCommonNames(a1);
    v3 = *(_QWORD *)(a1 + 240);
    if ((v3 & 0x400000000) != 0)
    {
      v4 = 0;
LABEL_12:
      if (compare_octet_string_partial((uint64_t)&MFi4RootName, (uint64_t)v11))
        return v4 | 5u;
      else
        return v4 | 4u;
    }
    if ((v3 & 0x800000000) != 0)
    {
      v4 = 160;
      goto LABEL_12;
    }
    return 255;
  }
  if ((~*(_QWORD *)(a1 + 240) & 0xC00000000) != 0)
    return 255;
  if (compare_octet_string_partial((uint64_t)&MFi4AccessoryCAName, (uint64_t)v11))
  {
    if (compare_octet_string_partial((uint64_t)&MFi4AttestationCAName, (uint64_t)v11))
      return 255;
    v5 = 160;
  }
  else
  {
    v5 = 0;
  }
  v9 = 0;
  v10 = 0;
  v6 = CTParseExtensionValue(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), &CTOidAppleMFI4AccessoryData, 0xAuLL, &v9, &v10);
  v7 = CTParseExtensionValue(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), &CTOidAppleMFI4ProductPlanUID, 0xAuLL, &v9, &v10);
  v8 = v5 | 2;
  if (v6)
    v8 = v5;
  if (!v7)
    v8 = v5 | 1;
  if (v7 | v6)
    return v8;
  else
    return v5 | 3u;
}

uint64_t CTNonVariableCompressedSizeForStyle(int a1)
{
  uint64_t result;

  result = 124;
  switch(a1)
  {
    case 0:
    case 2:
      return result;
    case 1:
    case 3:
      result = 160;
      break;
    case 4:
    case 5:
LABEL_6:
      result = 98;
      break;
    default:
      switch(a1)
      {
        case 160:
        case 162:
          result = 122;
          break;
        case 161:
        case 163:
          result = 158;
          break;
        case 164:
        case 165:
          goto LABEL_6;
        default:
          result = -1;
          break;
      }
      break;
  }
  return result;
}

uint64_t CTCompress(unint64_t a1, uint64_t a2, _BYTE *a3, size_t a4)
{
  uint64_t result;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  size_t v15;
  unint64_t v16;
  unint64_t v17;
  _OWORD v18[3];
  void *__src[2];
  size_t __n[2];
  __int128 v21;
  __int128 v22;
  _OWORD v23[3];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  size_t v33;
  int *v34[4];
  _QWORD v35[4];
  __int128 v36;
  __int128 v37;
  char v38;
  _QWORD v39[3];

  v39[2] = *MEMORY[0x1E0C80C00];
  v33 = 0;
  result = CTCompressComputeBufferSize(a1, a2, &v33);
  v9 = result;
  if ((_DWORD)result)
    return v9;
  v9 = 393220;
  if (!a4 || v33 > a4)
    return v9;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v31 = v10;
  v32 = v10;
  v29 = v10;
  v30 = v10;
  v27 = v10;
  v28 = v10;
  v25 = v10;
  v26 = v10;
  v23[2] = v10;
  v24 = v10;
  v23[0] = v10;
  v23[1] = v10;
  v21 = v10;
  v22 = v10;
  *(_OWORD *)__src = v10;
  *(_OWORD *)__n = v10;
  v18[1] = v10;
  v18[2] = v10;
  v18[0] = v10;
  v16 = 0xAAAAAAAAAAAAAAAALL;
  v17 = 0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(a1, a2))
    goto LABEL_47;
  v16 = a1;
  v17 = a1 + a2;
  v11 = X509CertificateParse((unint64_t *)v18, &v16);
  if ((_DWORD)v11)
    return v11;
  bzero(a3, a4);
  result = CTCompressedStyleFromCert((uint64_t)v18);
  if ((_DWORD)result == 255)
    return 393218;
  *a3 = result;
  if ((result & 4) == 0)
  {
    if ((~(_DWORD)result & 0xA0) != 0)
      result = CTCompressMFiLeaf((uint64_t)v18, (unint64_t)a3, a4);
    else
      result = CTCompressAttestationLeaf((unint64_t *)v18, (unint64_t)a3, a4);
    goto LABEL_20;
  }
  if (a3 != (_BYTE *)-1)
  {
    result = CTCompressGetCommonNameSuffixPointer((unint64_t *)v23 + 1);
    if (!result)
    {
      v9 = 393224;
      goto LABEL_23;
    }
    if (a4 < 9)
    {
LABEL_23:
      bzero(a3, a4);
      return v9;
    }
    *(_QWORD *)(a3 + 1) = *(_QWORD *)result;
    if ((unint64_t)(a3 + 1) <= 0xFFFFFFFFFFFFFFF7)
    {
      memset(v35, 170, sizeof(v35));
      result = X509CertificateParseValidity((uint64_t)v18);
      if ((_DWORD)result)
        goto LABEL_20;
      memset(v39, 170, 14);
      result = CTGetGeneralizedTime((uint64_t)&v35[2], (unint64_t)v39);
      if ((_DWORD)result)
        goto LABEL_20;
      if (a4 < 0x17)
        goto LABEL_18;
      *(_QWORD *)(a3 + 9) = v39[0];
      *(_QWORD *)(a3 + 15) = *(_QWORD *)((char *)v39 + 6);
      if ((unint64_t)(a3 + 9) <= 0xFFFFFFFFFFFFFFF1)
      {
        result = CTGetGeneralizedTime((uint64_t)v35, (unint64_t)v39);
        if ((_DWORD)result)
          goto LABEL_20;
        if (a4 < 0x25)
          goto LABEL_18;
        *(_QWORD *)(a3 + 23) = v39[0];
        *(_QWORD *)(a3 + 29) = *(_QWORD *)((char *)v39 + 6);
        if ((unint64_t)(a3 + 23) > 0xFFFFFFFFFFFFFFF1)
          goto LABEL_47;
        result = CTCompressGetCommonNameSuffixPointer((unint64_t *)&v22 + 1);
        if (!result)
        {
          result = 393224;
          goto LABEL_20;
        }
        if (a4 < 0x2D)
        {
LABEL_18:
          result = 393220;
          goto LABEL_20;
        }
        *(_QWORD *)(a3 + 37) = *(_QWORD *)result;
        if ((unint64_t)(a3 + 37) > 0xFFFFFFFFFFFFFFF7)
          goto LABEL_47;
        v38 = -86;
        *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v36 = v12;
        v37 = v12;
        memset(v34, 170, sizeof(v34));
        result = X509CertificateParseSPKI((unint64_t *)&v21 + 1, 0, (unint64_t *)v34, &v34[2]);
        if ((_DWORD)result)
          goto LABEL_20;
        result = compressECPublicKey((uint64_t)&v34[2], v34, (uint64_t)&v36, 33);
        if ((_DWORD)result)
          goto LABEL_20;
        if (a4 < 0x4E)
          goto LABEL_18;
        v13 = v37;
        *(_OWORD *)(a3 + 45) = v36;
        *(_OWORD *)(a3 + 61) = v13;
        a3[77] = v38;
        if ((unint64_t)(a3 + 45) <= 0xFFFFFFFFFFFFFFDELL)
        {
          result = 393221;
          if (!*((_QWORD *)&v24 + 1) || (_QWORD)v25 != 20)
            goto LABEL_20;
          if (a4 < 0x62)
            goto LABEL_18;
          v14 = **((_OWORD **)&v24 + 1);
          *(_DWORD *)(a3 + 94) = *(_DWORD *)(*((_QWORD *)&v24 + 1) + 16);
          *(_OWORD *)(a3 + 78) = v14;
          if ((unint64_t)(a3 + 78) <= 0xFFFFFFFFFFFFFFEBLL)
          {
            result = 655619;
            if (__src[1])
            {
              v15 = __n[0];
              if (__n[0] - 73 >= 0xFFFFFFFFFFFFFFFDLL)
              {
                result = 393220;
                if (__n[0] + 98 <= a4)
                {
                  result = (uint64_t)memcpy(a3 + 98, __src[1], __n[0]);
                  if (!__CFADD__(a3 + 98, v15))
                  {
                    result = 0;
                    goto LABEL_20;
                  }
                  goto LABEL_47;
                }
              }
            }
LABEL_20:
            v9 = result;
            if (!(_DWORD)result)
              return 0;
            goto LABEL_23;
          }
        }
      }
    }
  }
LABEL_47:
  __break(0x5513u);
  return result;
}

uint64_t CTCompressAttestationLeaf(unint64_t *a1, unint64_t a2, unint64_t a3)
{
  uint64_t v6;
  uint64_t result;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  __int128 v12;
  _OWORD *v13;
  __int128 v14;
  _OWORD *v15;
  _OWORD *v16;
  __int128 v17;
  unint64_t v18;
  _OWORD *v19;
  __int128 v20;
  _OWORD *v21;
  uint64_t v22;
  const void *v23;
  size_t v24;
  size_t v25;
  unint64_t v26;
  __int128 v27;
  __int128 v28;
  size_t v29;
  char *v30;
  void *__src;
  size_t __n;
  int *v33[4];
  _QWORD v34[4];
  __int128 v35;
  __int128 v36;
  char v37;
  _QWORD v38[3];

  v38[2] = *MEMORY[0x1E0C80C00];
  if (a2 == -1)
    goto LABEL_65;
  v6 = 393220;
  result = CTCompressGetCommonNameSuffixPointer(a1 + 15);
  if (!result)
    return 393224;
  if (a3 < 9)
    return v6;
  v8 = a2 + 1;
  if (a2 + 1 >= a2)
  {
    v9 = a2 + a3;
    if (v8 <= a2 + a3)
    {
      *(_QWORD *)(a2 + 1) = *(_QWORD *)result;
      if (v8 > 0xFFFFFFFFFFFFFFF7)
        goto LABEL_65;
      memset(v34, 170, sizeof(v34));
      result = X509CertificateParseValidity((uint64_t)a1);
      if ((_DWORD)result)
        return result;
      memset(v38, 170, 14);
      result = CTGetGeneralizedTime((uint64_t)&v34[2], (unint64_t)v38);
      if ((_DWORD)result)
        return result;
      if (a3 < 0x17)
        return 393220;
      v10 = (_QWORD *)(a2 + 9);
      if (a2 + 9 >= a2 && (unint64_t)v10 <= v9)
      {
        *v10 = v38[0];
        *(_QWORD *)(a2 + 15) = *(_QWORD *)((char *)v38 + 6);
        if ((unint64_t)v10 > 0xFFFFFFFFFFFFFFF1)
          goto LABEL_65;
        result = CTGetGeneralizedTime((uint64_t)v34, (unint64_t)v38);
        if ((_DWORD)result)
          return result;
        if (a3 < 0x25)
          return 393220;
        v11 = (_QWORD *)(a2 + 23);
        if (a2 + 23 >= a2 && (unint64_t)v11 <= v9)
        {
          *v11 = v38[0];
          *(_QWORD *)(a2 + 29) = *(_QWORD *)((char *)v38 + 6);
          if ((unint64_t)v11 > 0xFFFFFFFFFFFFFFF1)
            goto LABEL_65;
          v37 = -86;
          *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v35 = v12;
          v36 = v12;
          memset(v33, 170, sizeof(v33));
          result = X509CertificateParseSPKI(a1 + 11, 0, (unint64_t *)v33, &v33[2]);
          if ((_DWORD)result)
            return result;
          result = compressECPublicKey((uint64_t)&v33[2], v33, (uint64_t)&v35, 33);
          if ((_DWORD)result)
            return result;
          if (a3 < 0x46)
            return 393220;
          v13 = (_OWORD *)(a2 + 37);
          if (a2 + 37 >= a2 && (unint64_t)v13 <= v9)
          {
            v14 = v36;
            *v13 = v35;
            *(_OWORD *)(a2 + 53) = v14;
            *(_BYTE *)(a2 + 69) = v37;
            if ((unint64_t)v13 > 0xFFFFFFFFFFFFFFDELL)
              goto LABEL_65;
            v15 = (_OWORD *)a1[31];
            result = 393222;
            if (!v15 || a1[32] != 32)
              return result;
            if (a3 < 0x66)
              return 393220;
            v16 = (_OWORD *)(a2 + 70);
            if (a2 + 70 >= a2 && (unint64_t)v16 <= v9)
            {
              v17 = v15[1];
              *v16 = *v15;
              *(_OWORD *)(a2 + 86) = v17;
              if ((unint64_t)v16 > 0xFFFFFFFFFFFFFFDFLL)
                goto LABEL_65;
              v18 = a1[21];
              result = 393221;
              if (!v18 || a1[22] != 20)
                return result;
              if (a3 < 0x7A)
                return 393220;
              v19 = (_OWORD *)(a2 + 102);
              if (a2 + 102 >= a2 && (unint64_t)v19 <= v9)
              {
                v20 = *(_OWORD *)v18;
                *(_DWORD *)(a2 + 118) = *(_DWORD *)(v18 + 16);
                *v19 = v20;
                if ((unint64_t)v19 > 0xFFFFFFFFFFFFFFEBLL)
                  goto LABEL_65;
                v21 = (_OWORD *)(a2 + 122);
                __src = 0;
                __n = 0;
                if (CTParseExtensionValue(*a1, a1[1], &CTOidAppleMFI4ProductPlanUID, 0xAuLL, &__src, &__n))
                {
                  v22 = 122;
                }
                else
                {
                  result = 393222;
                  if (!__src || __n != 36)
                    return result;
                  if (a3 < 0x9E)
                    return 393220;
                  if ((unint64_t)v21 < a2 || (unint64_t)v21 > v9)
                    goto LABEL_67;
                  v27 = *(_OWORD *)__src;
                  v28 = *((_OWORD *)__src + 1);
                  *(_DWORD *)(a2 + 154) = *((_DWORD *)__src + 8);
                  *v21 = v27;
                  *(_OWORD *)(a2 + 138) = v28;
                  if ((unint64_t)v21 > 0xFFFFFFFFFFFFFFDBLL)
                    goto LABEL_65;
                  v21 = (_OWORD *)(a2 + 158);
                  v22 = 158;
                }
                v23 = (const void *)a1[7];
                result = 655619;
                if (!v23)
                  return result;
                v24 = a1[8];
                if (v24 - 73 < 0xFFFFFFFFFFFFFFFDLL)
                  return result;
                v25 = v24 + v22;
                if (v24 + v22 > a3)
                  return 393220;
                if ((unint64_t)v21 <= v9 && (unint64_t)v21 >= a2 && v24 <= v9 - (unint64_t)v21)
                {
                  memcpy(v21, v23, v24);
                  v26 = a1[8];
                  if (__CFADD__(v21, v26))
                    goto LABEL_65;
                  if (CTParseExtensionValue(*a1, a1[1], &CTOidAppleMFI4AccessoryData, 0xAuLL, &__src, &__n))return 0;
                  if (!__src)
                    return 393222;
                  v29 = __n;
                  result = 393220;
                  if (__n + v25 > a3)
                    return result;
                  v30 = (char *)v21 + v26;
                  if ((unint64_t)v21 + v26 <= v9
                    && (unint64_t)v30 >= a2
                    && __n <= v9 - (unint64_t)v30)
                  {
                    memcpy((char *)v21 + v26, __src, __n);
                    if (!__CFADD__(v30, v29))
                      return 0;
LABEL_65:
                    __break(0x5513u);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_67:
  __break(0x5519u);
  return result;
}

uint64_t CTCompressMFiLeaf(uint64_t result, unint64_t a2, unint64_t a3)
{
  unint64_t *v3;
  uint64_t v4;
  _OWORD *v5;
  BOOL v6;
  _OWORD *v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  __int128 v13;
  _OWORD *v14;
  __int128 v15;
  _OWORD *v16;
  _OWORD *v17;
  __int128 v18;
  unint64_t v19;
  _OWORD *v20;
  __int128 v21;
  _OWORD *v22;
  uint64_t v23;
  const void *v24;
  size_t v25;
  size_t v26;
  unint64_t v27;
  __int128 v28;
  __int128 v29;
  size_t v30;
  char *v31;
  void *__src;
  size_t __n;
  int *v34[4];
  _QWORD v35[2];
  __int128 v36;
  __int128 v37;
  char v38;
  _QWORD v39[3];

  v39[2] = *MEMORY[0x1E0C80C00];
  if (a2 == -1)
    goto LABEL_69;
  v3 = (unint64_t *)result;
  v4 = 393220;
  v5 = *(_OWORD **)(result + 136);
  if (v5)
    v6 = *(_QWORD *)(result + 144) == 16;
  else
    v6 = 0;
  if (!v6)
    return 393223;
  if (a3 < 0x11)
    return v4;
  v9 = (_OWORD *)(a2 + 1);
  if (a2 + 1 >= a2)
  {
    v10 = a2 + a3;
    if ((unint64_t)v9 <= a2 + a3)
    {
      *v9 = *v5;
      if ((unint64_t)v9 > 0xFFFFFFFFFFFFFFEFLL)
        goto LABEL_69;
      result = CTCompressGetCommonNameSuffixPointer((unint64_t *)(result + 120));
      if (!result)
        return 393224;
      if (a3 < 0x19)
        return v4;
      v11 = a2 + 17;
      if (a2 + 17 >= a2 && v11 <= v10)
      {
        *(_QWORD *)(a2 + 17) = *(_QWORD *)result;
        if (v11 > 0xFFFFFFFFFFFFFFF7)
          goto LABEL_69;
        v35[0] = 0xAAAAAAAAAAAAAAAALL;
        v35[1] = 0xAAAAAAAAAAAAAAAALL;
        result = X509CertificateParseValidity((uint64_t)v3);
        if ((_DWORD)result)
          return result;
        *(_QWORD *)((char *)v39 + 6) = 0xAAAAAAAAAAAAAAAALL;
        v39[0] = 0xAAAAAAAAAAAAAAAALL;
        result = CTGetGeneralizedTime((uint64_t)v35, (unint64_t)v39);
        if ((_DWORD)result)
          return result;
        if (a3 < 0x27)
          return 393220;
        v12 = (_QWORD *)(a2 + 25);
        if (a2 + 25 >= a2 && (unint64_t)v12 <= v10)
        {
          *v12 = v39[0];
          *(_QWORD *)(a2 + 31) = *(_QWORD *)((char *)v39 + 6);
          if ((unint64_t)v12 > 0xFFFFFFFFFFFFFFF1)
            goto LABEL_69;
          v38 = -86;
          *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v36 = v13;
          v37 = v13;
          memset(v34, 170, sizeof(v34));
          result = X509CertificateParseSPKI(v3 + 11, 0, (unint64_t *)v34, &v34[2]);
          if ((_DWORD)result)
            return result;
          result = compressECPublicKey((uint64_t)&v34[2], v34, (uint64_t)&v36, 33);
          if ((_DWORD)result)
            return result;
          if (a3 < 0x48)
            return 393220;
          v14 = (_OWORD *)(a2 + 39);
          if (a2 + 39 >= a2 && (unint64_t)v14 <= v10)
          {
            v15 = v37;
            *v14 = v36;
            *(_OWORD *)(a2 + 55) = v15;
            *(_BYTE *)(a2 + 71) = v38;
            if ((unint64_t)v14 > 0xFFFFFFFFFFFFFFDELL)
              goto LABEL_69;
            v16 = (_OWORD *)v3[31];
            result = 393222;
            if (!v16 || v3[32] != 32)
              return result;
            if (a3 < 0x68)
              return 393220;
            v17 = (_OWORD *)(a2 + 72);
            if (a2 + 72 >= a2 && (unint64_t)v17 <= v10)
            {
              v18 = v16[1];
              *v17 = *v16;
              *(_OWORD *)(a2 + 88) = v18;
              if ((unint64_t)v17 > 0xFFFFFFFFFFFFFFDFLL)
                goto LABEL_69;
              v19 = v3[21];
              result = 393221;
              if (!v19 || v3[22] != 20)
                return result;
              if (a3 < 0x7C)
                return 393220;
              v20 = (_OWORD *)(a2 + 104);
              if (a2 + 104 >= a2 && (unint64_t)v20 <= v10)
              {
                v21 = *(_OWORD *)v19;
                *(_DWORD *)(a2 + 120) = *(_DWORD *)(v19 + 16);
                *v20 = v21;
                if ((unint64_t)v20 > 0xFFFFFFFFFFFFFFEBLL)
                  goto LABEL_69;
                v22 = (_OWORD *)(a2 + 124);
                __src = 0;
                __n = 0;
                if (CTParseExtensionValue(*v3, v3[1], &CTOidAppleMFI4ProductPlanUID, 0xAuLL, &__src, &__n))
                {
                  v23 = 124;
                }
                else
                {
                  result = 393222;
                  if (!__src || __n != 36)
                    return result;
                  if (a3 < 0xA0)
                    return 393220;
                  if ((unint64_t)v22 < a2 || (unint64_t)v22 > v10)
                    goto LABEL_71;
                  v28 = *(_OWORD *)__src;
                  v29 = *((_OWORD *)__src + 1);
                  *(_DWORD *)(a2 + 156) = *((_DWORD *)__src + 8);
                  *v22 = v28;
                  *(_OWORD *)(a2 + 140) = v29;
                  if ((unint64_t)v22 > 0xFFFFFFFFFFFFFFDBLL)
                    goto LABEL_69;
                  v22 = (_OWORD *)(a2 + 160);
                  v23 = 160;
                }
                v24 = (const void *)v3[7];
                result = 655619;
                if (!v24)
                  return result;
                v25 = v3[8];
                if (v25 - 73 < 0xFFFFFFFFFFFFFFFDLL)
                  return result;
                v26 = v25 + v23;
                if (v25 + v23 > a3)
                  return 393220;
                if ((unint64_t)v22 <= v10 && (unint64_t)v22 >= a2 && v25 <= v10 - (unint64_t)v22)
                {
                  memcpy(v22, v24, v25);
                  v27 = v3[8];
                  if (__CFADD__(v22, v27))
                    goto LABEL_69;
                  if (CTParseExtensionValue(*v3, v3[1], &CTOidAppleMFI4AccessoryData, 0xAuLL, &__src, &__n))return 0;
                  if (!__src)
                    return 393222;
                  v30 = __n;
                  result = 393220;
                  if (__n + v26 > a3)
                    return result;
                  v31 = (char *)v22 + v27;
                  if ((unint64_t)v22 + v27 <= v10
                    && (unint64_t)v31 >= a2
                    && __n <= v10 - (unint64_t)v31)
                  {
                    memcpy((char *)v22 + v27, __src, __n);
                    if (!__CFADD__(v31, v30))
                      return 0;
LABEL_69:
                    __break(0x5513u);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_71:
  __break(0x5519u);
  return result;
}

uint64_t CTDecompressIssuer(int a1, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t result;
  _BYTE *v11;
  _BYTE *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  _BOOL4 v20;
  _QWORD *v21;

  result = 393218;
  if (a1 <= 159)
  {
    v11 = &mfi_ca_subject;
    if (a1 < 4)
    {
      v12 = &attestation_leaf_subject;
      v13 = 57;
      v14 = 107;
      v15 = 17;
      goto LABEL_14;
    }
    if (a1 != 4)
    {
      if (a1 != 5)
        return result;
      v12 = &attestation_leaf_subject;
      v13 = 57;
      v14 = 107;
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if ((a1 - 160) >= 4)
  {
    if (a1 == 164)
    {
LABEL_12:
      v11 = &root_subject;
      v12 = &leaf_5280_extensions_template;
      v13 = 39;
      v14 = 89;
      goto LABEL_13;
    }
    if (a1 != 165)
      return result;
  }
  v11 = &attestation_ca_subject;
  v12 = &root_subject;
  v13 = 58;
  v14 = 108;
LABEL_13:
  v15 = 1;
LABEL_14:
  result = 393217;
  if ((v15 | 8uLL) > a3)
    return result;
  if (!a4)
    goto LABEL_35;
  v17 = *a4;
  v16 = a4[1];
  if (v16 - *a4 < v14)
    return 393220;
  if (v17 > v16 || v11 > v12 || v14 > v12 - v11)
  {
LABEL_40:
    __break(0x5519u);
    return result;
  }
  result = ccder_blob_encode_body();
  if (!(_DWORD)result)
    return 393226;
  v18 = a4[1];
  if (__CFADD__(v18, v13)
    || ((v19 = (_QWORD *)(v18 + v13), (uint64_t)((uint64_t)v19 - v17) >= 0)
      ? (v20 = (unint64_t)v19 >= v17)
      : (v20 = (unint64_t)v19 < v17),
        !v20 || __CFADD__(a2, v15)))
  {
    __break(0x5513u);
    goto LABEL_40;
  }
  if (v16 - (unint64_t)v19 < 8)
    goto LABEL_40;
  if (v17 > (unint64_t)v19)
    goto LABEL_40;
  if ((unint64_t)v19 > v16)
    goto LABEL_40;
  v21 = (_QWORD *)(a2 + v15);
  if (a2 + v15 > a2 + a3 || (unint64_t)v21 < a2 || a3 - v15 < 8)
    goto LABEL_40;
  *v19 = *v21;
LABEL_35:
  result = 0;
  if (a5)
    *a5 = v14;
  return result;
}

uint64_t CTDecompressSerialNumber(int a1, _OWORD *a2, unint64_t a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t result;
  BOOL v11;
  unsigned int v12;
  _BYTE *v13;
  _OWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  __int128 v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  _BYTE *v25;
  unint64_t v27;
  unint64_t v28;
  _OWORD v29[4];
  char v30;
  _BYTE v31[15];

  *(_QWORD *)&v31[7] = *MEMORY[0x1E0C80C00];
  result = 393218;
  if (a1 <= 159)
  {
    v11 = a1 >= 4;
    v12 = a1 - 4;
    if (!v11)
    {
      v13 = 0;
      v14 = 0;
      v15 = 1;
      v16 = 16;
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  if ((a1 - 160) >= 4)
  {
    v12 = a1 - 164;
LABEL_7:
    if (v12 >= 2)
      return result;
    v14 = v29;
    v13 = v31;
    v15 = 45;
    goto LABEL_9;
  }
  v14 = v29;
  v13 = v31;
  v15 = 37;
LABEL_9:
  v16 = 20;
LABEL_10:
  v17 = ccder_sizeof();
  result = 393217;
  if (v15 + v16 > a3)
    return result;
  v30 = -86;
  *(_QWORD *)&v18 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v29[2] = v18;
  v29[3] = v18;
  v29[0] = v18;
  v29[1] = v18;
  if (!v14)
  {
    if (!__CFADD__(a2, v15))
    {
      v13 = (char *)a2 + a3;
      v19 = (unint64_t)a2 + v15;
      v14 = a2;
      if (!a4)
        goto LABEL_37;
      goto LABEL_21;
    }
LABEL_41:
    __break(0x5513u);
LABEL_42:
    __break(0x5519u);
    goto LABEL_43;
  }
  v27 = 0xAAAAAAAAAAAAAAAALL;
  v28 = 0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(a2, v15))
    goto LABEL_41;
  if ((char *)a2 + a3 < (char *)a2 + v15 || (_OWORD *)((char *)a2 + v15) < a2 || a3 - v15 <= 0x20)
    goto LABEL_42;
  v27 = (unint64_t)a2 + v15;
  v28 = 33;
  result = decompressECPublicKey((uint64_t)&v27, (int **)&CTOidSECP256r1, (uint64_t)v29, 65);
  v19 = (unint64_t)v14;
  if ((_DWORD)result)
    return result;
  if (!a4)
    goto LABEL_37;
LABEL_21:
  v20 = *a4;
  v21 = a4[1];
  if (v21 - *a4 < v17)
    return 393220;
  if ((unint64_t)v14 > v19 || v20 > v21 || v19 > (unint64_t)v13 || v16 > (unint64_t)&v13[-v19])
    goto LABEL_42;
  if (!ccder_blob_encode_body_tl())
    return 393226;
  v22 = ccder_sizeof_tag();
  result = ccder_sizeof_len();
  v23 = v22 + result;
  if (__CFADD__(v22, result))
  {
LABEL_43:
    __break(0x5500u);
    return result;
  }
  v24 = a4[1];
  if (__CFADD__(v24, v23))
    goto LABEL_41;
  v25 = (_BYTE *)(v24 + v23);
  if (!((uint64_t)&v25[-v20] >= 0 ? (unint64_t)v25 >= v20 : (unint64_t)v25 < v20))
    goto LABEL_41;
  if ((unint64_t)v25 >= v21 || (unint64_t)v25 < v20)
    goto LABEL_42;
  *v25 &= ~0x80u;
LABEL_37:
  result = 0;
  if (a5)
    *a5 = v17;
  return result;
}

unint64_t CTDecompressGetSignature(int a1, unint64_t a2, unint64_t a3, unint64_t *a4, _QWORD *a5)
{
  uint64_t v9;
  unint64_t result;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;

  v9 = 393217;
  result = CTNonVariableCompressedSizeForStyle(a1);
  if ((result & 0x8000000000000000) != 0)
    return 393218;
  v11 = result;
  if (result + 70 > a3)
    return v9;
  if (~a2 < a3 || result > ~a2)
    goto LABEL_20;
  v12 = a2 + result;
  if (a2 + result > a2 + a3 || v12 < a2)
  {
LABEL_19:
    __break(0x5519u);
LABEL_20:
    __break(0x5513u);
    goto LABEL_21;
  }
  v14 = a2 + result;
  result = ccder_blob_decode_tl();
  if ((result & 1) == 0)
    return 393225;
  v13 = v14 - v12;
  if (!v13)
    return 393225;
  if (!__CFADD__(v11, v13))
  {
    if (v11 + v13 > a3)
      return v9;
    v9 = 0;
    if (!a4 || !a5)
      return v9;
    if (v13 <= a2 + a3 - v12)
    {
      v9 = 0;
      *a4 = v12;
      *a5 = v13;
      return v9;
    }
    goto LABEL_19;
  }
LABEL_21:
  __break(0x5500u);
  return result;
}

uint64_t ccder_sizeof_tl()
{
  uint64_t v0;
  uint64_t v1;
  BOOL v2;
  uint64_t result;

  v0 = ccder_sizeof_tag();
  v1 = ccder_sizeof_len();
  v2 = __CFADD__(v0, v1);
  result = v0 + v1;
  if (v2)
    __break(0x5500u);
  return result;
}

uint64_t CTDecompressSignature(int a1, unint64_t a2, unint64_t a3, _QWORD *a4, unint64_t *a5)
{
  uint64_t result;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v13[0] = 0;
  if ((a3 & 0x8000000000000000) != 0)
    __break(0x5519u);
  result = CTDecompressGetSignature(a1, a2, a3, &v12, v13);
  v8 = result;
  if ((_DWORD)result)
    return v8;
  if (v13[0] == -1)
  {
LABEL_15:
    __break(0x5500u);
    goto LABEL_16;
  }
  v9 = ccder_sizeof();
  v10 = v9;
  if (!a4)
    goto LABEL_12;
  v8 = 393226;
  if (a4[1] - *a4 < v9)
    return 393220;
  result = ccder_blob_encode_body();
  if (!(_DWORD)result)
    return v8;
  v11 = a4[1];
  if (v11)
  {
    a4[1] = v11 - 1;
    *(_BYTE *)(v11 - 1) = 0;
    if (v13[0] != -1)
    {
      if (!ccder_blob_encode_tl())
        return v8;
LABEL_12:
      v8 = 0;
      if (a5)
        *a5 = v10;
      return v8;
    }
    goto LABEL_15;
  }
LABEL_16:
  __break(0x5513u);
  return result;
}

unint64_t CTDecompressCAComputeSKID(unint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v3;
  unint64_t v4;
  _QWORD v6[2];
  _OWORD v7[4];
  char v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 16) = 0;
  if (a1 > 0xFFFFFFFFFFFFFFD2)
  {
    __break(0x5513u);
    goto LABEL_9;
  }
  if ((unint64_t)(a2 - 78) > 0xFFFFFFFFFFFFFFDELL || a1 + 45 < a1 || a1 + 45 > a1 + a2)
LABEL_9:
    __break(0x5519u);
  v6[0] = a1 + 45;
  v6[1] = 33;
  v8 = -86;
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[2] = v3;
  v7[3] = v3;
  v7[0] = v3;
  v7[1] = v3;
  v4 = decompressECPublicKey((uint64_t)v6, (int **)&CTOidSECP256r1, (uint64_t)v7, 65);
  if (!(_DWORD)v4)
  {
    ccsha1_di();
    ccdigest();
  }
  return v4;
}

unint64_t CTConvertByteArrayToAsciiHex(unint64_t result, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v4;
  char *v5;
  unsigned __int8 *v6;
  unint64_t v7;
  const char *v8;
  BOOL v9;
  const char *v10;
  BOOL v11;
  char v13;
  char *v14;

  if (!__CFADD__(result, a2))
  {
    if (a4 != 2 * a2)
      return 393220;
    if (!__CFADD__(a3, a4))
    {
      v4 = 0;
      if (result + a2 > result)
      {
        v5 = &a3[a4];
        if (&a3[a4] > a3)
        {
          v6 = (unsigned __int8 *)result;
          while ((unint64_t)v6 >= result)
          {
            v7 = *v6;
            v8 = &nibbleToAsciiByte[v7 >> 4];
            v9 = v8 < "Apple iPhone Certification Authority" && v8 >= nibbleToAsciiByte;
            v10 = &nibbleToAsciiByte[v7 & 0xF];
            v11 = !v9 || v10 >= "Apple iPhone Certification Authority";
            if (v11 || v10 < nibbleToAsciiByte)
              break;
            v13 = *v10;
            *a3 = *v8;
            v14 = a3 + 1;
            if (v14 == (char *)-1)
              goto LABEL_26;
            v4 = 0;
            *v14 = v13;
            a3 = v14 + 1;
            if ((unint64_t)++v6 >= result + a2 || a3 >= v5)
              return v4;
          }
          __break(0x5519u);
          goto LABEL_26;
        }
      }
      return v4;
    }
  }
LABEL_26:
  __break(0x5513u);
  return result;
}

unint64_t CTDecompressDate(unint64_t result, _QWORD *a2, unint64_t *a3)
{
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = *(unsigned __int8 *)result;
  if (v4 >= 0x32)
  {
    if (v4 != 50)
      goto LABEL_9;
    if (result != -1)
    {
      if (*(_BYTE *)(result + 1) != 48)
        goto LABEL_9;
      if (result <= 0xFFFFFFFFFFFFFFFDLL)
      {
        if (*(unsigned __int8 *)(result + 2) < 0x35u)
          goto LABEL_2;
LABEL_9:
        v7 = 0;
        v5 = 14;
        v6 = 17;
        if (!a2)
          goto LABEL_19;
        goto LABEL_10;
      }
    }
LABEL_22:
    __break(0x5513u);
    goto LABEL_23;
  }
LABEL_2:
  v5 = 12;
  v6 = 15;
  v7 = 2;
  if (!a2)
  {
LABEL_19:
    v8 = 0;
    if (a3)
      *a3 = v6;
    return v8;
  }
LABEL_10:
  v8 = 393226;
  v9 = a2[1];
  if (v9 - *a2 < v6)
    return 393220;
  if (!v9)
    goto LABEL_22;
  a2[1] = v9 - 1;
  *(_BYTE *)(v9 - 1) = 90;
  if (__CFADD__(result, v7))
    goto LABEL_22;
  if (result + v7 <= result + 14 && result + v7 >= result && v5 <= 14 - v7)
  {
    if (!ccder_blob_encode_body() || !ccder_blob_encode_tl())
      return v8;
    goto LABEL_19;
  }
LABEL_23:
  __break(0x5519u);
  return result;
}

unint64_t CTCompressGetCommonNameSuffixPointer(unint64_t *a1)
{
  unint64_t result;
  char **v2;
  char *v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v7 = 0xAAAAAAAAAAAAAAAALL;
  v8 = 0xAAAAAAAAAAAAAAAALL;
  if (X509CertificateSubjectNameGetCommonName(a1, &v7))
    return 0;
  result = compare_octet_string_partial((uint64_t)&MFi4RootName, (uint64_t)&v7);
  if (!(_DWORD)result)
  {
    v4 = v7;
    if (v7 < 0xFFFFFFFFFFFFFFE6)
    {
      v5 = v8;
      result = v7 + 26;
      goto LABEL_11;
    }
LABEL_18:
    __break(0x5513u);
    return result;
  }
  v2 = &MFi4AccessoryCAName;
  result = compare_octet_string_partial((uint64_t)&MFi4AccessoryCAName, (uint64_t)&v7);
  if ((_DWORD)result)
  {
    v2 = &MFi4AttestationCAName;
    result = compare_octet_string_partial((uint64_t)&MFi4AttestationCAName, (uint64_t)&v7);
    if ((_DWORD)result)
      return 0;
  }
  v3 = v2[1];
  v4 = v7;
  if (__CFADD__(v7, v3))
    goto LABEL_18;
  v5 = v8;
  result = (unint64_t)&v3[v7];
  if (!&v3[v7])
    return result;
LABEL_11:
  v6 = __CFADD__(v4, v5);
  if (result > 0xFFFFFFFFFFFFFFF7 || v6)
    goto LABEL_18;
  if (v4 + v5 < result + 8)
    return 0;
  return result;
}

uint64_t CTGetGeneralizedTime(uint64_t result, unint64_t a2)
{
  uint64_t **v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  __int16 v7;

  v2 = (uint64_t **)result;
  v3 = *(_QWORD *)(result + 8);
  if (v3 != 13)
  {
    if (v3 != 15)
      return 720909;
    result = 0;
    v4 = *v2;
    v5 = *v4;
    *(_QWORD *)(a2 + 6) = *(uint64_t *)((char *)v4 + 6);
    *(_QWORD *)a2 = v5;
    return result;
  }
  if (a2 >= 0xFFFFFFFFFFFFFFFELL)
  {
    __break(0x5513u);
    goto LABEL_12;
  }
  v6 = **(_QWORD **)result;
  *(_DWORD *)(a2 + 10) = *(_DWORD *)(*(_QWORD *)result + 8);
  *(_QWORD *)(a2 + 2) = v6;
  if (!*(_QWORD *)(result + 8))
  {
LABEL_12:
    __break(0x5519u);
    return result;
  }
  if (**(unsigned __int8 **)result > 0x34u)
  {
    result = 0;
    v7 = 14641;
  }
  else
  {
    result = 0;
    v7 = 12338;
  }
  *(_WORD *)a2 = v7;
  return result;
}

uint64_t X509PolicySetFlagsForCommonNames(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  unint64_t v4[3];

  v4[2] = *MEMORY[0x1E0C80C00];
  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  v4[1] = 0xAAAAAAAAAAAAAAAALL;
  result = X509CertificateSubjectNameGetCommonName((unint64_t *)(a1 + 104), v4);
  if (!(_DWORD)result)
  {
    result = compare_octet_string((uint64_t)&iPhoneCAName, (uint64_t)v4);
    if ((_DWORD)result)
    {
      result = compare_octet_string((uint64_t)&CodeSigningCAName, (uint64_t)v4);
      if ((_DWORD)result)
      {
        result = compare_octet_string_partial((uint64_t)&MFi4AccessoryCAName, (uint64_t)v4);
        if ((_DWORD)result)
        {
          result = compare_octet_string_partial((uint64_t)&MFi4AttestationCAName, (uint64_t)v4);
          if ((_DWORD)result)
          {
            result = compare_octet_string_partial((uint64_t)&MFi4ProvisioningCAName, (uint64_t)v4);
            if ((_DWORD)result)
              return result;
            v3 = 0x1000000000;
          }
          else
          {
            v3 = 0x800000000;
          }
        }
        else
        {
          v3 = 0x400000000;
        }
      }
      else
      {
        v3 = 8;
      }
    }
    else
    {
      v3 = 3840;
    }
    *(_QWORD *)(a1 + 240) |= v3;
  }
  return result;
}

double X509PolicySetFlagsForMFI(uint64_t a1)
{
  double result;
  time_t v3;
  tm v4;
  time_t v5;
  unint64_t v6[3];

  v6[2] = *MEMORY[0x1E0C80C00];
  v6[0] = 0xAAAAAAAAAAAAAAAALL;
  v6[1] = 0xAAAAAAAAAAAAAAAALL;
  if (!X509CertificateSubjectNameGetCommonName((unint64_t *)(a1 + 104), v6))
  {
    if (compare_octet_string_partial((uint64_t)&MFICommonNamePrefix, (uint64_t)v6))
      goto LABEL_3;
    v5 = 0;
    if (!X509CertificateGetNotBefore(a1, &v5))
    {
      memset(&v4, 0, sizeof(v4));
      strptime("2006-05-31", "%F", &v4);
      v3 = timegm(&v4);
      result = difftime(v3, v5);
      if (result < 0.0)
      {
        *(_QWORD *)(a1 + 240) |= 0x8000000uLL;
LABEL_3:
        if (!compare_octet_string_partial((uint64_t)&MFi4ProvisioningHostNamePrefix, (uint64_t)v6))
          *(_QWORD *)(a1 + 240) |= 0x1000000000uLL;
      }
    }
  }
  return result;
}

uint64_t X509PolicySetFlagsForRoots(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!result)
    return result;
  v3 = result;
  if (*(_BYTE *)(result + 16))
  {
    result = compare_octet_string(a2 + 88, (uint64_t)&AppleRootCASPKI);
    if (!(_DWORD)result
      || (result = compare_octet_string(a2 + 88, (uint64_t)&AppleRootG2SPKI), !(_DWORD)result)
      || (result = compare_octet_string(a2 + 88, (uint64_t)&AppleRootG3SPKI), !(_DWORD)result))
    {
      v5 = *(_QWORD *)(a2 + 240) | 0x58E30653FFF8;
      goto LABEL_11;
    }
  }
  v4 = *(_QWORD *)(v3 + 8);
  if ((v4 & 0x1000000) != 0)
  {
    result = compare_octet_string(a2 + 88, (uint64_t)&UcrtRootSpki);
    if (!(_DWORD)result)
    {
      v5 = *(_QWORD *)(a2 + 240) | 0x1000000;
      goto LABEL_11;
    }
LABEL_13:
    if (*(_BYTE *)(v3 + 17))
      result = X509PolicySetFlagsForTestAnchor((_QWORD *)v3, a2);
    goto LABEL_15;
  }
  if ((v4 & 0x1C00000000) == 0)
    goto LABEL_15;
  result = compare_octet_string(a2 + 88, (uint64_t)&MFi4RootSpki);
  if ((_DWORD)result)
    goto LABEL_13;
  v5 = *(_QWORD *)(a2 + 240) | 0x1C00000000;
LABEL_11:
  *(_QWORD *)(a2 + 240) = v5;
LABEL_15:
  if (*(_BYTE *)(v3 + 16))
  {
    if (*(_BYTE *)(v3 + 17))
    {
      result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootCASPKI);
      if (!(_DWORD)result
        || (result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootG2SPKI), !(_DWORD)result)
        || (result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootG3SPKI), !(_DWORD)result))
      {
        *(_QWORD *)(a2 + 240) |= 0x58E30653FFF8uLL;
      }
    }
    if (*(_BYTE *)(v3 + 16) && *(_BYTE *)(v3 + 17))
    {
      result = compare_octet_string(a2 + 88, (uint64_t)&TestAppleRootECCSPKI);
      if (!(_DWORD)result)
        *(_QWORD *)(a2 + 240) |= 0x6400000uLL;
    }
  }
  return result;
}

uint64_t X509PolicySetFlagsForTestAnchor(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  _QWORD v5[2];
  unint64_t v6[3];

  v6[2] = *MEMORY[0x1E0C80C00];
  v6[0] = 0;
  v6[1] = 0;
  v5[0] = 0;
  v5[1] = 0;
  result = X509CertificateParseSPKI((unint64_t *)(a2 + 88), v6, 0, v5);
  if (!(_DWORD)result)
  {
    result = compare_octet_string(a1[4], (uint64_t)v6);
    if (!(_DWORD)result)
    {
      result = compare_octet_string(a1[3], (uint64_t)v5);
      if (!(_DWORD)result)
        *(_QWORD *)(a2 + 240) |= a1[1];
    }
  }
  return result;
}

uint64_t X509PolicyCheckForBlockedKeys(uint64_t a1)
{
  uint64_t result;

  result = compare_octet_string(a1 + 88, (uint64_t)&BlockedYonkersSPKI);
  if (!(_DWORD)result)
    *(_QWORD *)(a1 + 240) &= 0xFFFFFFFFFFF3FFFFLL;
  return result;
}

uint64_t CTParseAmfiCMS_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, __int128 *))
{
  uint64_t result;

  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = a1 + 24;
  *(_QWORD *)a1 = 4;
  *(_QWORD *)(a1 + 8) = a4;
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a5 + 16);
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_QWORD *)(a1 + 56) = a2;
  *(_QWORD *)(a1 + 64) = 1;
  *(_DWORD *)(a2 + 168) = 327681;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 8) = *(_DWORD *)(a5 + 16);
  *(_BYTE *)(a3 + 12) = *(_BYTE *)(a5 + 84);
  result = CMSParseContentInfoSignedData(*(char **)a5, *(_QWORD *)(a5 + 8), (unint64_t *)a1);
  if (!(_DWORD)result)
  {
    result = CMSParseSignerInfos(a1, a3, a6);
    if (!(_DWORD)result)
      return *(unsigned int *)(a2 + 168);
  }
  return result;
}

uint64_t CTAmfiVerifyCertificateChain(uint64_t a1)
{
  __int128 v2;
  uint64_t result;
  __int128 v4;
  unint64_t v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  _OWORD v9[9];
  _OWORD v10[2];
  _OWORD v11[7];
  uint64_t v12;
  _QWORD v13[2];
  _BYTE __b[1216];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v13[0] = 0xAAAAAAAAAAAAAAAALL;
  v13[1] = 0xAAAAAAAAAAAAAAAALL;
  memset(__b, 170, sizeof(__b));
  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[0] = v2;
  v10[1] = v2;
  v9[7] = v2;
  v9[8] = v2;
  v9[5] = v2;
  v9[6] = v2;
  v9[3] = v2;
  v9[4] = v2;
  v9[1] = v2;
  v9[2] = v2;
  v9[0] = v2;
  memset(v11, 0, sizeof(v11));
  v12 = 0;
  result = CTParseAmfiCMS_internal((uint64_t)v11, (uint64_t)v9, (uint64_t)v13, (uint64_t)__b, a1, (uint64_t (*)(uint64_t, uint64_t, __int128 *))CTBuildPathForVerifiedIndex);
  if (!(_DWORD)result)
  {
    v8 = 0;
    v5 = 0xAAAAAAAAAAAAAA01;
    v4 = xmmword_18AA58EF0;
    BYTE1(v5) = *(_BYTE *)(a1 + 20);
    WORD1(v5) = 0;
    v6 = 0u;
    v7 = 0u;
    result = X509ChainCheckPathWithOptions(29, (uint64_t *)v10 + 1, (uint64_t)&v4, &v8);
    if ((_DWORD)result)
    {
      *(_QWORD *)(a1 + 96) = 0;
      return X509ChainCheckPathWithOptions(29, (uint64_t *)v10 + 1, 0, 0);
    }
    else
    {
      *(_QWORD *)(a1 + 96) = v8;
    }
  }
  return result;
}

uint64_t CTBuildPathForVerifiedIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 12) && *(unsigned __int8 *)(a1 + 12) != *(unsigned __int8 *)(a3 + 144))
    return 327710;
  else
    return CMSBuildPath(a1, a2, a3);
}

uint64_t CTVerifyAmfiCertificateChain(uint64_t a1, uint64_t a2, char a3, int a4, _QWORD *a5)
{
  uint64_t result;
  _QWORD v7[2];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = 0;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v8 = 0u;
  v7[0] = a1;
  v7[1] = a2;
  LODWORD(v8) = a4;
  BYTE4(v8) = a3;
  result = CTAmfiVerifyCertificateChain((uint64_t)v7);
  if (a5)
  {
    if (!(_DWORD)result)
      *a5 = v13;
  }
  return result;
}

char *find_digest(uint64_t a1)
{
  unint64_t v2;
  char *result;

  v2 = 0;
  while (1)
  {
    result = (char *)compare_octet_string_raw((uint64_t)&digests + v2 + 8, *(const void **)a1, *(_QWORD *)(a1 + 8));
    if (!(_DWORD)result)
      break;
    v2 += 32;
    if (v2 == 160)
      return 0;
  }
  if (v2 <= ~(unint64_t)&digests)
    return (char *)&digests + v2;
  __break(0x5513u);
  return result;
}

unint64_t validateSignatureRSA(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5)
{
  unint64_t result;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  __int128 v18;
  unint64_t *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  char v23;
  char v24;
  unint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t vars0;

  result = 0;
  v27 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            result = compare_octet_string((uint64_t)&rsaEncryption, (uint64_t)(a5 + 7));
            if (!(_DWORD)result
              || (result = validateOIDs((uint64_t)&rsaAlgs, (uint64_t)(a5 + 3), (uint64_t)(a5 + 7)), (_DWORD)result))
            {
              v21 = 0xAAAAAAAAAAAAAAAALL;
              v22 = 0xAAAAAAAAAAAAAAAALL;
              v10 = a5[9];
              v9 = a5[10];
              if (__CFADD__(v10, v9))
                goto LABEL_31;
              if (v10 > v10 + v9)
                goto LABEL_32;
              v21 = a5[9];
              v22 = v10 + v9;
              if (!v9 || (result = ccder_blob_check_null(), (_DWORD)result))
              {
                if (!__CFADD__(a1, a2))
                {
                  if (a1 + a2 >= a1)
                  {
                    result = ccder_decode_rsa_pub_n();
                    if (!result)
                      return result;
                    v11 = result;
                    if (result >> 58)
                    {
LABEL_33:
                      __break(0x550Cu);
                      return result;
                    }
                    v12 = result << 6;
                    if (result << 6 < 0x400)
                      return 0;
                    v25 = 0xAAAAAAAAAAAAAAAALL;
                    v26 = -21846;
                    v24 = 6;
                    if (&vars0 != (uint64_t *)82)
                    {
                      v13 = a5[4];
                      LOBYTE(v25) = v13;
                      if ((unint64_t)&v24 <= 0xFFFFFFFFFFFFFFFDLL)
                      {
                        if (v13 <= 9)
                        {
                          v14 = __memcpy_chk();
                          if (v12 > 0x1068)
                            return 0;
                          result = MEMORY[0x1E0C80A78](v14);
                          v16 = (unint64_t *)((char *)&v20 - v15);
                          v17 = 0;
                          *(_QWORD *)&v18 = 0xAAAAAAAAAAAAAAAALL;
                          *((_QWORD *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
                          do
                          {
                            v19 = &v16[v17 / 8];
                            *(_OWORD *)v19 = v18;
                            *((_OWORD *)v19 + 1) = v18;
                            v17 += 32;
                          }
                          while (v15 != v17);
                          if (v15 >= 1)
                          {
                            *v16 = v11;
                            if (ccrsa_import_pub())
                              return 0;
                            if (!ccrsa_verify_pkcs1v15_allowshortsigs())
                              return v23 != 0;
                            result = 0;
                            v23 = 0;
                            return result;
                          }
                        }
                        goto LABEL_32;
                      }
                    }
                    goto LABEL_31;
                  }
LABEL_32:
                  __break(0x5519u);
                  goto LABEL_33;
                }
LABEL_31:
                __break(0x5513u);
                goto LABEL_32;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL validateOIDs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  BOOL v7;

  v6 = 0;
  v7 = 1;
  do
  {
    if (!compare_octet_string(a1, a2) && !compare_octet_string(a1 + 16, a3))
      break;
    v7 = v6 < 3;
    a1 += 32;
    ++v6;
  }
  while (v6 != 4);
  return v7;
}

uint64_t validateSignatureEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t *v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = 0;
  v18 = *MEMORY[0x1E0C80C00];
  HIBYTE(v17) = 0;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            if (!compare_octet_string((uint64_t)&ecPublicKey_0, a5 + 56)
              || (result = validateOIDs((uint64_t)&ecAlgs, a5 + 24, a5 + 56), (_DWORD)result))
            {
              result = ccec_cp_for_oid((int **)(a5 + 72));
              if (result)
              {
                v8 = *(_QWORD *)result;
                if (*(_QWORD *)result >> 61 || !is_mul_ok(8 * v8, 3uLL))
                {
                  __break(0x550Cu);
                }
                else
                {
                  v9 = 24 * v8;
                  v10 = __CFADD__(v9, 16);
                  v11 = v9 + 16;
                  if (!v10 && v11 < 0xFFFFFFFFFFFFFFF0)
                  {
                    result = MEMORY[0x1E0C80A78](result);
                    v14 = (uint64_t *)((char *)&v17 - v12);
                    v15 = 0;
                    do
                    {
                      v16 = &v14[v15 / 8];
                      *v16 = 0xAAAAAAAAAAAAAAAALL;
                      v16[1] = 0xAAAAAAAAAAAAAAAALL;
                      v15 += 16;
                    }
                    while (v12 != v15);
                    if (v13 >= 0x10)
                    {
                      *v14 = result;
                      if (v12 >= 1)
                      {
                        if (!ccec_import_pub())
                        {
                          result = ccec_x963_import_pub_size();
                          if (result == 256 && *(_QWORD *)(a5 + 96) == 64)
                          {
                            if (*(_QWORD *)(a5 + 88) < 0xFFFFFFFFFFFFFFE0)
                            {
                              if (!ccec_verify_composite())
                                return HIBYTE(v17) != 0;
                              goto LABEL_24;
                            }
LABEL_31:
                            __break(0x5513u);
                            return result;
                          }
                          if (ccec_verify())
LABEL_24:
                            HIBYTE(v17) = 0;
                        }
                        return HIBYTE(v17) != 0;
                      }
LABEL_30:
                      __break(0x5519u);
                      goto LABEL_31;
                    }
LABEL_29:
                    __break(1u);
                    goto LABEL_30;
                  }
                }
                __break(0x5500u);
                goto LABEL_29;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t compressECPublicKey(uint64_t a1, int **a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  uint64_t result;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v6 = (_QWORD *)ccec_cp_for_oid(a2);
  if (!v6)
    return 655366;
  v7 = v6;
  v8 = *v6;
  if (*v6 >> 61 || !is_mul_ok(8 * v8, 3uLL))
  {
    __break(0x550Cu);
    goto LABEL_19;
  }
  v9 = 24 * v8;
  v10 = __CFADD__(v9, 16);
  v11 = v9 + 16;
  if (v10 || v11 >= 0xFFFFFFFFFFFFFFF0)
LABEL_19:
    __break(0x5500u);
  result = MEMORY[0x1E0C80A78](v6);
  v15 = (_QWORD *)((char *)v18 - v13);
  v16 = 0;
  do
  {
    v17 = &v15[v16 / 8];
    *v17 = 0xAAAAAAAAAAAAAAAALL;
    v17[1] = 0xAAAAAAAAAAAAAAAALL;
    v16 += 16;
  }
  while (v13 != v16);
  if (v14 < 0x10)
    goto LABEL_21;
  *v15 = v7;
  if (v13 < 1)
  {
LABEL_20:
    __break(0x5519u);
LABEL_21:
    __break(1u);
    return result;
  }
  result = ccec_import_pub();
  if (!(_DWORD)result)
  {
    result = ccec_compressed_x962_export_pub_size();
    if (result == a4)
    {
      if (!a3 || a4)
        return ccec_compressed_x962_export_pub();
      goto LABEL_20;
    }
    return 393220;
  }
  return result;
}

unint64_t decompressECPublicKey(uint64_t a1, int **a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  unint64_t v10;
  unint64_t result;
  uint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  uint64_t v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v6 = (uint64_t *)ccec_cp_for_oid(a2);
  if (!v6)
    return 655366;
  v7 = *v6;
  if ((unint64_t)*v6 >> 61 || !is_mul_ok(8 * v7, 3uLL))
LABEL_22:
    __break(0x550Cu);
  v8 = 24 * v7;
  v9 = __CFADD__(v8, 16);
  v10 = v8 + 16;
  if (v9 || v10 >= 0xFFFFFFFFFFFFFFF0)
  {
LABEL_21:
    __break(0x5500u);
    goto LABEL_22;
  }
  result = MEMORY[0x1E0C80A78](v6);
  v14 = (_QWORD *)((char *)v18 - v12);
  v15 = 0;
  do
  {
    v16 = &v14[v15 / 8];
    *v16 = 0xAAAAAAAAAAAAAAAALL;
    v16[1] = 0xAAAAAAAAAAAAAAAALL;
    v15 += 16;
  }
  while (v12 != v15);
  if (v13 < 0x10)
    goto LABEL_24;
  *v14 = result;
  if (v12 >= 1)
  {
    v17 = ccec_compressed_x962_import_pub();
    if (!(_DWORD)v17)
    {
      result = cczp_bitlen();
      if (result < 0xFFFFFFFFFFFFFFF9)
      {
        if (!a3 || a4)
        {
          if ((((result + 7) >> 2) | 1) == a4)
            v17 = 0;
          else
            v17 = 393220;
          ccec_export_pub();
          return v17;
        }
        goto LABEL_23;
      }
      goto LABEL_21;
    }
    return v17;
  }
LABEL_23:
  __break(0x5519u);
LABEL_24:
  __break(1u);
  return result;
}

uint64_t CMSParseContentInfoSignedDataWithOptions(char *a1, uint64_t a2, unint64_t *a3, char a4)
{
  int v4;
  int v7;
  uint64_t result;
  uint64_t v9;
  _QWORD *v10;
  char *v11;
  int v12;
  char *v13;
  char *v15;
  int v16;
  char *v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  size_t v26;
  __int16 v27;
  char *v28;
  char *v29;
  unint64_t v30[3];
  __int16 v31;
  char *v32;
  unint64_t v33;
  size_t v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  char *v37;
  char *v38;
  unint64_t v39;
  unsigned __int8 v40;
  unint64_t v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v28 = (char *)0xAAAAAAAAAAAAAAAALL;
  v29 = (char *)0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(a1, a2))
    goto LABEL_114;
  if (&a1[a2] < a1)
    goto LABEL_112;
  v4 = 65537;
  v28 = a1;
  v29 = &a1[a2];
  v27 = 0;
  v26 = 0xAAAAAAAAAAAAAAAALL;
  v7 = ccder_blob_decode_ber_tl((uint64_t)&v28, 0x2000000000000010, (_BYTE *)&v27 + 1, &v26);
  result = 65537;
  if (v7)
  {
    v24 = (char *)0xAAAAAAAAAAAAAAAALL;
    v25 = (char *)0xAAAAAAAAAAAAAAAALL;
    if (__CFADD__(v28, v26))
      goto LABEL_114;
    if (v28 > &v28[v26] || &v28[v26] > v29)
      goto LABEL_112;
    v24 = v28;
    v25 = &v28[v26];
    if (ccder_blob_decode_tl())
    {
      if (v25 < v24 || v26 > v25 - v24)
        goto LABEL_112;
      if (compare_octet_string_raw((uint64_t)&pkcs7_signedData_oid, v24, v26))
        return 65539;
      if (__CFADD__(v24, v26))
        goto LABEL_114;
      if (v24 > &v24[v26] || &v24[v26] > v25)
        goto LABEL_112;
      v24 += v26;
      if (!ccder_blob_decode_ber_tl((uint64_t)&v24, 0xA000000000000000, &v27, &v26))
        return 65540;
      v22 = (char *)0xAAAAAAAAAAAAAAAALL;
      v23 = (char *)0xAAAAAAAAAAAAAAAALL;
      if (__CFADD__(v24, v26))
        goto LABEL_114;
      if (v24 > &v24[v26] || &v24[v26] > v25)
        goto LABEL_112;
      v22 = v24;
      v23 = &v24[v26];
      v31 = 0;
      memset(v30, 170, sizeof(v30));
      if ((ccder_blob_decode_ber_tl((uint64_t)&v22, 0x2000000000000010, (_BYTE *)&v31 + 1, v30) & 1) == 0)
        return 131073;
      if (__CFADD__(v22, v30[0]))
        goto LABEL_114;
      v9 = 131080;
      if (&v22[v30[0]] != v23)
        return 131082;
      v10 = a3 + 11;
      if (!ccder_blob_decode_uint64())
        return 131074;
      result = 131092;
      if (*v10 <= 4uLL && ((1 << *v10) & 0x1A) != 0)
      {
        if (!ccder_blob_eat_ber_inner((unint64_t *)&v22, 0x2000000000000011, 0, 125))
          return 131075;
        v35 = 0;
        v34 = 0;
        if ((ccder_blob_decode_ber_tl((uint64_t)&v22, 0x2000000000000010, &v35, &v34) & 1) == 0)
          return 131076;
        v32 = (char *)0xAAAAAAAAAAAAAAAALL;
        v33 = 0xAAAAAAAAAAAAAAAALL;
        if (__CFADD__(v22, v34))
          goto LABEL_114;
        if (v22 > &v22[v34] || &v22[v34] > v23)
          goto LABEL_112;
        v32 = v22;
        v33 = (unint64_t)&v22[v34];
        if (!ccder_blob_decode_tl())
          return 131077;
        if (v33 < (unint64_t)v32 || v34 > v33 - (unint64_t)v32)
          goto LABEL_112;
        if (compare_octet_string_raw((uint64_t)&pkcs7_data_oid, v32, v34))
          return 131078;
        if (__CFADD__(v32, v34))
          goto LABEL_114;
        v11 = &v32[v34];
        if (v32 > &v32[v34] || (unint64_t)v11 > v33)
          goto LABEL_112;
        v32 += v34;
        v12 = v35;
        if (v11 != (char *)v33 || v35)
        {
          v40 = 0;
          v38 = (char *)v33;
          v39 = 0;
          v37 = v11;
          if (ccder_blob_decode_ber_tl((uint64_t)&v37, 0xA000000000000000, &v40, &v39))
          {
            if (!v12)
            {
              if (__CFADD__(v37, v39))
                goto LABEL_114;
              if (&v37[v39] != (char *)v33)
                return v9;
            }
            if (v37 > v38)
              goto LABEL_112;
            v32 = v37;
            v33 = (unint64_t)v38;
            v36 = 0;
            v16 = v40;
            if (v40 && !ccder_blob_decode_ber_tl((uint64_t)&v32, 0x2000000000000004, &v36, &v39))
              return 131079;
            v41 = 0;
            if (!ccder_blob_decode_tl())
              return 131090;
            v17 = v32;
            v18 = v33;
            if (v33 < (unint64_t)v32)
              goto LABEL_112;
            v19 = v41;
            if (v41 > v33 - (unint64_t)v32)
              goto LABEL_112;
            a3[9] = (unint64_t)v32;
            a3[10] = v19;
            if (__CFADD__(v17, v19))
            {
LABEL_114:
              __break(0x5513u);
              return 0;
            }
            v20 = &v17[v19];
            if ((unint64_t)v20 > v18 || v17 > v20)
              goto LABEL_112;
            v32 = v20;
            if ((ccder_blob_decode_eoc((unint64_t *)&v32, v36) & 1) == 0)
              return 131089;
          }
          else
          {
            if (!v12)
              return v9;
            v16 = v40;
          }
          if ((ccder_blob_decode_eoc((unint64_t *)&v32, v16 != 0) & 1) == 0)
            return 131088;
          v11 = v32;
        }
        if (v11 > v23 || v22 > v11)
          goto LABEL_112;
        v22 = v11;
        if ((ccder_blob_decode_eoc((unint64_t *)&v22, v12 != 0) & 1) == 0)
          return 131081;
        v37 = (char *)0xAAAAAAAAAAAAAAAALL;
        v38 = (char *)0xAAAAAAAAAAAAAAAALL;
        if (v22 > v23)
          goto LABEL_112;
        v37 = v22;
        v38 = v23;
        if ((ccder_blob_decode_ber_tl((uint64_t)&v37, 0xA000000000000000, &v31, v30) & 1) == 0)
        {
          v13 = v22;
          v15 = v23;
          goto LABEL_86;
        }
        v32 = (char *)0xAAAAAAAAAAAAAAAALL;
        v33 = 0xAAAAAAAAAAAAAAAALL;
        if (!__CFADD__(v37, v30[0]))
        {
          if (v37 > &v37[v30[0]] || &v37[v30[0]] > v38)
            goto LABEL_112;
          v32 = v37;
          v33 = (unint64_t)&v37[v30[0]];
          if (!CMSParseImplicitCertificateSet((unint64_t *)&v32, a3[1], *a3, a3 + 3, a3 + 2))
            return 131085;
          if (!ccder_blob_decode_eoc((unint64_t *)&v32, v31))
            return 131086;
          v13 = v32;
          if (v32 - v37 >= 0 ? v32 >= v37 : v32 < v37)
          {
            if (v37 > v32)
              goto LABEL_112;
            v15 = v38;
            if (v32 > v38)
              goto LABEL_112;
            v22 = v32;
            v23 = v38;
LABEL_86:
            if (v13 <= v15)
            {
              v37 = v13;
              v38 = v15;
              if (ccder_blob_eat_ber_inner((unint64_t *)&v37, 0xA000000000000001, 0, 125))
              {
                if (v37 > v38)
                  goto LABEL_112;
                v22 = v37;
                v23 = v38;
              }
              if (!ccder_blob_eat_ber_inner((unint64_t *)&v22, 0x2000000000000011, &v30[1], 125))
                return 131083;
              if (v30[2] >= v30[1])
              {
                v21 = &v22[-v30[1]];
                if ((unint64_t)&v22[-v30[1]] <= v30[2] - v30[1])
                {
                  a3[5] = v30[1];
                  a3[6] = (unint64_t)v21;
                  if ((ccder_blob_decode_eoc((unint64_t *)&v22, HIBYTE(v31)) & 1) == 0)
                    return 131084;
                  if (!ccder_blob_decode_eoc((unint64_t *)&v22, v27))
                    return 65541;
                  if (v22 <= v25 && v24 <= v22)
                  {
                    v24 = v22;
                    if (ccder_blob_decode_eoc((unint64_t *)&v24, HIBYTE(v27)))
                    {
                      if ((a4 & 1) == 0 && v24 != v29)
                        return 65543;
                      return 0;
                    }
                    return (v4 + 5);
                  }
                }
              }
            }
LABEL_112:
            __break(0x5519u);
            return (v4 + 5);
          }
        }
        goto LABEL_114;
      }
    }
    else
    {
      return 65538;
    }
  }
  return result;
}

uint64_t ccder_blob_decode_ber_tl(uint64_t a1, uint64_t a2, _BYTE *a3, unint64_t *a4)
{
  int v8;
  uint64_t result;

  v8 = ccder_blob_decode_tag();
  result = 0;
  if (v8)
  {
    if (a2 == 0xAAAAAAAAAAAAAAAALL)
      return ccder_blob_decode_ber_len(a1, a3, a4);
  }
  return result;
}

uint64_t ccder_blob_decode_eoc(unint64_t *a1, int a2)
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5;

  if (!a2)
    return 1;
  result = ccder_blob_decode_tl();
  if (!(_DWORD)result)
    return result;
  v4 = *a1;
  if (*a1 >= 0x5555555555555556)
  {
    __break(0x5513u);
LABEL_12:
    __break(0x5519u);
    return result;
  }
  v5 = v4 - 0x5555555555555556;
  if (v4 > v4 - 0x5555555555555556 || v5 > a1[1])
    goto LABEL_12;
  *a1 = v5;
  return 1;
}

uint64_t CMSParseContentInfoSignedData(char *a1, uint64_t a2, unint64_t *a3)
{
  return CMSParseContentInfoSignedDataWithOptions(a1, a2, a3, 0);
}

uint64_t CMSParseSignerInfos(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, __int128 *))
{
  uint64_t v3;
  unint64_t v4;
  unsigned int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *digest;
  char *v14;
  unsigned int v15;
  uint64_t result;
  unint64_t v17;
  unsigned int v18;
  uint64_t v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  int v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  unsigned int v34;
  unint64_t v35;
  _OWORD *v36;
  unint64_t v37;
  BOOL v38;
  unint64_t v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  unsigned int v48;
  int v49;
  uint64_t v50;
  _OWORD *v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  unsigned __int8 v60;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unsigned __int8 v71;
  unint64_t v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  unint64_t v84;
  unint64_t v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  v84 = 0xAAAAAAAAAAAAAAAALL;
  v85 = 0xAAAAAAAAAAAAAAAALL;
  v4 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 48);
  if (__CFADD__(v4, v3))
    goto LABEL_93;
  if (v4 > v4 + v3)
    goto LABEL_92;
  v84 = *(_QWORD *)(a1 + 40);
  v85 = v4 + v3;
  v72 = 0xAAAAAAAAAAAAAAAALL;
  if (v4 >= v4 + v3)
  {
    v48 = 0;
    result = 0;
    if (v3)
      return (v48 << 8) | 0x30008;
    return result;
  }
  v6 = 0;
  v60 = 0;
  v7 = 256;
  while (1)
  {
    v71 = 0;
    v82 = 0u;
    v83 = 0u;
    v73 = 0u;
    v74 = 0u;
    v75 = 0u;
    v76 = 0u;
    v77 = 0u;
    v78 = 0u;
    v79 = 0u;
    v80 = 0u;
    v81 = 0u;
    DWORD2(v83) = 327681;
    LOBYTE(v82) = v6 + 1;
    if ((ccder_blob_decode_ber_tl((uint64_t)&v84, 0x2000000000000010, &v71, &v72) & 1) == 0)
    {
      v49 = 196609;
      return v7 | v49;
    }
    v69 = 0xAAAAAAAAAAAAAAAALL;
    v70 = 0xAAAAAAAAAAAAAAAALL;
    if (__CFADD__(v84, v72))
      goto LABEL_93;
    if (v84 > v84 + v72 || v84 + v72 > v85)
      goto LABEL_92;
    v69 = v84;
    v70 = v84 + v72;
    if ((ccder_blob_decode_uint64() & 1) == 0)
    {
      v49 = 196610;
      return v7 | v49;
    }
    v9 = v69;
    v8 = v70;
    v67 = 0xAAAAAAAAAAAAAAAALL;
    v68 = 0xAAAAAAAAAAAAAAAALL;
    if (v69 > v70)
      goto LABEL_92;
    v67 = v69;
    v68 = v70;
    v65 = v69;
    v66 = v70;
    if (!ccder_blob_decode_tl())
      break;
    v10 = v69;
LABEL_19:
    if (__CFADD__(v72, v10 - v9))
      goto LABEL_94;
    if (v72 + v10 - v9 > v8 - v9)
      goto LABEL_92;
    *((_QWORD *)&v73 + 1) = v9;
    *(_QWORD *)&v74 = v72 + v10 - v9;
    if (__CFADD__(v10, v72))
      goto LABEL_93;
    if (v10 > v10 + v72 || v10 + v72 > v70)
      goto LABEL_92;
    v69 = v10 + v72;
    if (!ccder_blob_decode_AlgorithmIdentifierNULL(&v69, (unint64_t *)&v74 + 1))
    {
      v49 = 196612;
      return v7 | v49;
    }
    v63 = 0xAAAAAAAAAAAAAAAALL;
    v64 = 0xAAAAAAAAAAAAAAAALL;
    if (v69 > v70)
      goto LABEL_92;
    v63 = v69;
    v64 = v70;
    if (ccder_blob_decode_tl())
    {
      if (v64 < v63 || v72 > v64 - v63)
        goto LABEL_92;
      *((_QWORD *)&v75 + 1) = v63;
      *(_QWORD *)&v76 = v72;
      if (__CFADD__(v63, v72))
        goto LABEL_93;
      if (v63 > v63 + v72 || v63 + v72 > v64)
        goto LABEL_92;
      v69 = v63 + v72;
      v70 = v64;
    }
    else
    {
      *((_QWORD *)&v75 + 1) = 0;
      *(_QWORD *)&v76 = 0;
    }
    if ((ccder_blob_decode_AlgorithmIdentifierNULL(&v69, (unint64_t *)&v76 + 1) & 1) == 0)
    {
      v49 = 196613;
      return v7 | v49;
    }
    if ((ccder_blob_decode_tl() & 1) == 0)
    {
      v49 = 196614;
      return v7 | v49;
    }
    if (v70 < v69 || v72 > v70 - v69)
      goto LABEL_92;
    *((_QWORD *)&v78 + 1) = v69;
    *(_QWORD *)&v79 = v72;
    if (__CFADD__(v69, v72))
      goto LABEL_93;
    v12 = v69 + v72;
    if (v69 > v69 + v72 || v12 > v70)
      goto LABEL_92;
    v69 += v72;
    v63 = v12;
    v64 = v70;
    if (ccder_blob_eat_ber_inner(&v63, 0xA000000000000001, 0, 125))
    {
      if (v63 > v64)
        goto LABEL_92;
      v69 = v63;
      v70 = v64;
    }
    if ((ccder_blob_decode_eoc(&v69, v71) & 1) == 0)
    {
      v49 = 196615;
      return v7 | v49;
    }
    digest = find_digest((uint64_t)&v74 + 8);
    if (digest)
    {
      v14 = digest;
      v15 = *(_DWORD *)(a1 + 96);
      if (!v15 || *(_DWORD *)digest <= v15)
      {
        result = a3(a2, a1, &v73);
        if ((_DWORD)result != 327710)
        {
          if ((_DWORD)result)
            return result;
          v17 = *(_QWORD *)(a1 + 64);
          if (v17 <= v60)
          {
            if (v17)
            {
              v29 = v60 - 1;
              v30 = *(_QWORD *)(a1 + 56);
              v31 = 176 * v29;
              if (__CFADD__(v30, v31))
                goto LABEL_93;
              v32 = v30 + 176 * v29;
              if (v32 >= v30 + 176 * v17 || v32 < v30)
                goto LABEL_92;
              v33 = find_digest(v30 + 176 * v29 + 24);
              if (v33)
              {
                if (*(_DWORD *)v14 > *(_DWORD *)v33)
                {
                  v34 = *(_DWORD *)(a1 + 96);
                  if (!v34 || *(_DWORD *)v14 <= v34)
                  {
                    v35 = *(_QWORD *)(a1 + 56);
                    if (__CFADD__(v35, v31))
                      goto LABEL_93;
                    v36 = (_OWORD *)(v35 + 176 * v29);
                    v37 = v35 + 176 * *(_QWORD *)(a1 + 64);
                    v38 = v37 >= (unint64_t)v36;
                    v39 = v37 - (_QWORD)v36;
                    if (!v38 || v35 > (unint64_t)v36 || v39 < 0xB0)
                      goto LABEL_92;
                    v40 = v73;
                    v41 = v75;
                    v36[1] = v74;
                    v36[2] = v41;
                    *v36 = v40;
                    v42 = v76;
                    v43 = v77;
                    v44 = v79;
                    v36[5] = v78;
                    v36[6] = v44;
                    v36[3] = v42;
                    v36[4] = v43;
                    v45 = v80;
                    v46 = v81;
                    v47 = v83;
                    v36[9] = v82;
                    v36[10] = v47;
                    v36[7] = v45;
                    v36[8] = v46;
                  }
                }
              }
            }
          }
          else
          {
            v18 = *(_DWORD *)(a1 + 96);
            if (!v18 || *(_DWORD *)v14 <= v18)
            {
              v19 = *(_QWORD *)(a1 + 56);
              if (__CFADD__(v19, 176 * (char)v60))
                goto LABEL_93;
              v20 = (_OWORD *)(v19 + 176 * v60);
              if (176 * v17 - 176 * v60 < 0xB0)
                goto LABEL_92;
              v21 = v73;
              v22 = v75;
              v20[1] = v74;
              v20[2] = v22;
              *v20 = v21;
              v23 = v76;
              v24 = v77;
              v25 = v79;
              v20[5] = v78;
              v20[6] = v25;
              v20[3] = v23;
              v20[4] = v24;
              v26 = v80;
              v27 = v81;
              v28 = v83;
              v20[9] = v82;
              v20[10] = v28;
              v20[7] = v26;
              v20[8] = v27;
              if (v60 == 0xFF)
              {
                __break(0x5507u);
                return result;
              }
              ++v60;
            }
          }
        }
      }
    }
    if (v69 > v85 || v84 > v69)
      goto LABEL_92;
    v84 = v69;
    v48 = v6 + 1;
    if (v6 <= 6)
    {
      v7 += 256;
      ++v6;
      if (v69 < v85)
        continue;
    }
    if (v69 == v85)
    {
      if (v60)
        return 0;
      v50 = *(_QWORD *)(a1 + 64);
      if (!v50)
        return 0;
      if ((unint64_t)(176 * v50) >= 0xB0)
      {
        result = 0;
        v51 = *(_OWORD **)(a1 + 56);
        v52 = v73;
        v53 = v75;
        v51[1] = v74;
        v51[2] = v53;
        *v51 = v52;
        v54 = v76;
        v55 = v77;
        v56 = v79;
        v51[5] = v78;
        v51[6] = v56;
        v51[3] = v54;
        v51[4] = v55;
        v57 = v80;
        v58 = v81;
        v59 = v83;
        v51[9] = v82;
        v51[10] = v59;
        v51[7] = v57;
        v51[8] = v58;
        return result;
      }
LABEL_92:
      __break(0x5519u);
LABEL_93:
      __break(0x5513u);
LABEL_94:
      __break(0x5500u);
    }
    return (v48 << 8) | 0x30008;
  }
  if ((ccder_blob_decode_tl() & 1) != 0)
  {
    v10 = v67;
    v11 = v68;
LABEL_17:
    if (v10 > v11)
      goto LABEL_92;
    v69 = v10;
    v70 = v11;
    goto LABEL_19;
  }
  if (ccder_blob_decode_tl())
  {
    v10 = v65;
    v11 = v66;
    goto LABEL_17;
  }
  v49 = 196611;
  return v7 | v49;
}

uint64_t CMSBuildPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t CertificateUsingKeyIdentifier;
  uint64_t v13;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v20 = 0xAAAAAAAAAAAAAAAALL;
  v21 = 0xAAAAAAAAAAAAAAAALL;
  v3 = *(_QWORD *)(a3 + 8);
  v4 = *(_QWORD *)(a3 + 16);
  if (__CFADD__(v3, v4))
LABEL_49:
    __break(0x5513u);
  v5 = v3 + v4;
  if (v3 > v5)
    goto LABEL_48;
  v20 = *(_QWORD *)(a3 + 8);
  v21 = v5;
  v19 = 0xAAAAAAAAAAAAAAAALL;
  if (*(_QWORD *)a3 != 3)
  {
    if (*(_QWORD *)a3 != 1)
      return 524289;
    v8 = 524293;
    if (!ccder_blob_decode_tl())
      return 524290;
    if (!ccder_blob_decode_tl())
      return 524291;
    if (v21 >= v20 && v19 <= v21 - v20)
    {
      v15 = v20;
      v16 = v19;
      if (__CFADD__(v20, v19))
        goto LABEL_49;
      if (v20 <= v20 + v19 && v20 + v19 <= v21)
      {
        v20 += v19;
        if (!ccder_blob_decode_tl())
          return 524292;
        if (v21 >= v20 && v19 <= v21 - v20)
        {
          v17 = v20;
          v18 = v19;
          if (__CFADD__(v20, v19))
            goto LABEL_49;
          if (v20 <= v20 + v19 && v20 + v19 <= v21)
          {
            v20 += v19;
            v9 = *(_QWORD **)(a2 + 24);
            if (!v9)
              return v8;
            while (compare_octet_string((uint64_t)&v15, (uint64_t)(v9 + 15))
                 || compare_octet_string((uint64_t)&v17, (uint64_t)(v9 + 17)))
            {
              v9 = (_QWORD *)v9[34];
              if (!v9)
                return v8;
            }
            goto LABEL_36;
          }
        }
      }
    }
    goto LABEL_48;
  }
  if (*(_QWORD *)(a2 + 88) == 1)
    return 524298;
  v15 = v3;
  v16 = v5;
  if (ccder_blob_decode_tl())
  {
    v11 = v20;
    v10 = v21;
    goto LABEL_29;
  }
  v8 = 524294;
  if (!ccder_blob_decode_tl() || !ccder_blob_decode_tl())
    return v8;
  v11 = v15;
  v10 = v16;
  if (v15 > v16)
  {
LABEL_48:
    __break(0x5519u);
    goto LABEL_49;
  }
  v20 = v15;
  v21 = v16;
LABEL_29:
  if (v10 < v11 || v19 > v10 - v11)
    goto LABEL_48;
  v17 = v11;
  v18 = v19;
  if (__CFADD__(v11, v19))
    goto LABEL_49;
  if (v11 > v11 + v19 || v11 + v19 > v10)
    goto LABEL_48;
  v20 = v11 + v19;
  CertificateUsingKeyIdentifier = X509ChainGetCertificateUsingKeyIdentifier((uint64_t *)(a2 + 24), (uint64_t)&v17);
  if (!CertificateUsingKeyIdentifier)
    return 524295;
  v9 = (_QWORD *)CertificateUsingKeyIdentifier;
LABEL_36:
  if (v20 != v21)
    return 524543;
  v13 = X509ChainBuildPath(v9, (uint64_t *)(a2 + 24), (_QWORD *)(a3 + 152));
  v8 = v13;
  if (*(_DWORD *)(a3 + 168) == 327681)
    *(_DWORD *)(a3 + 168) = v13;
  return v8;
}

uint64_t ccder_blob_decode_ber_len(uint64_t result, _BYTE *a2, unint64_t *a3)
{
  unsigned __int8 *v3;
  unint64_t v4;
  unsigned __int8 *v5;
  unint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unint64_t v10;
  uint64_t v11;

  *a2 = 0;
  v3 = *(unsigned __int8 **)result;
  if (!*(_QWORD *)result)
    return 0;
  v4 = *(_QWORD *)(result + 8);
  if ((unint64_t)v3 >= v4)
    return 0;
  if (v3 == (unsigned __int8 *)-1)
    goto LABEL_42;
  v5 = v3 + 1;
  if (v3 >= v3 + 1 || (unint64_t)v5 > v4)
  {
LABEL_41:
    __break(0x5519u);
LABEL_42:
    __break(0x5513u);
    return result;
  }
  *(_QWORD *)result = v5;
  v7 = *v3;
  if ((char)*v3 < 0)
  {
    switch(*v3)
    {
      case 0x80u:
        v7 = v4 - (_QWORD)v5;
        *a2 = 1;
        break;
      case 0x81u:
        if ((uint64_t)(v4 - (_QWORD)v5) < 1)
          return 0;
        if (v3 == (unsigned __int8 *)-2)
          goto LABEL_42;
        v8 = v3 + 2;
        if (v5 > v8 || (unint64_t)v8 > v4)
          goto LABEL_41;
        *(_QWORD *)result = v8;
        v7 = *v5;
        v5 = v8;
        break;
      case 0x82u:
        if ((uint64_t)(v4 - (_QWORD)v5) < 2)
          return 0;
        if ((unint64_t)v5 >= v4)
          goto LABEL_41;
        if (v3 == (unsigned __int8 *)-2)
          goto LABEL_42;
        if (v3 + 2 < v5 || (unint64_t)(v3 + 2) >= v4)
          goto LABEL_41;
        if ((unint64_t)v5 > 0xFFFFFFFFFFFFFFFDLL)
          goto LABEL_42;
        v9 = v3 + 3;
        if (v5 > v3 + 3 || (unint64_t)v9 > v4)
          goto LABEL_41;
        v10 = (unint64_t)v3[1] << 8;
        v11 = v3[2];
        goto LABEL_40;
      case 0x83u:
        if ((uint64_t)(v4 - (_QWORD)v5) < 3)
          return 0;
        if ((unint64_t)v5 >= v4)
          goto LABEL_41;
        if (v3 == (unsigned __int8 *)-2)
          goto LABEL_42;
        if (v3 + 2 < v5 || (unint64_t)(v3 + 2) >= v4)
          goto LABEL_41;
        if ((unint64_t)v5 > 0xFFFFFFFFFFFFFFFDLL)
          goto LABEL_42;
        if (v3 + 3 < v5 || (unint64_t)(v3 + 3) >= v4)
          goto LABEL_41;
        if ((unint64_t)v5 > 0xFFFFFFFFFFFFFFFCLL)
          goto LABEL_42;
        v9 = v3 + 4;
        if (v5 > v3 + 4 || (unint64_t)v9 > v4)
          goto LABEL_41;
        v10 = ((unint64_t)v3[1] << 16) | ((unint64_t)v3[2] << 8);
        v11 = v3[3];
LABEL_40:
        v7 = v10 | v11;
        *(_QWORD *)result = v9;
        v5 = v9;
        break;
      default:
        return 0;
    }
  }
  if (v4 - (unint64_t)v5 < v7)
    return 0;
  *a3 = v7;
  return 1;
}

uint64_t CMSParseImplicitCertificateSet(unint64_t *a1, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t **v19;
  unint64_t **v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v25;
  unint64_t **v27;
  unint64_t v28;
  char v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v31 = 0xAAAAAAAAAAAAAAAALL;
  v32 = 0xAAAAAAAAAAAAAAAALL;
  *a4 = 0;
  a4[1] = 0;
  v30 = 0xAAAAAAAAAAAAAAAALL;
  v5 = *a1;
  v6 = a1[1];
  if (*a1 > v6)
  {
LABEL_43:
    __break(0x5519u);
LABEL_44:
    __break(0x5513u);
  }
  v30 = *a1;
  v31 = v6;
  v7 = v5 >= v6 || a3 == 0;
  if (v7)
  {
    v12 = 0;
LABEL_8:
    if (a5)
      *a5 = v12;
    return 1;
  }
  else
  {
    v12 = 0;
    v13 = 304 * a3;
    v14 = a2 + 304 * a3;
    v25 = ~a2;
    v27 = (unint64_t **)(a4 + 1);
    v23 = (unint64_t *)(a2 + 272);
    v15 = a2;
    while (1)
    {
      v29 = 0;
      if (!ccder_blob_decode_tag())
        return 0;
      if (!v32)
        goto LABEL_8;
      if (!ccder_blob_decode_ber_len((uint64_t)&v30, &v29, &v28) || v29 || v32 != 0x2000000000000010)
        return 0;
      if ((unsigned __int128)((uint64_t)v12 * (__int128)304) >> 64 != (uint64_t)(304 * v12) >> 63 || 304 * v12 > v25)
        goto LABEL_44;
      if (v15 > v14)
        goto LABEL_43;
      if (v15 < a2)
        goto LABEL_43;
      v16 = v13 >= 0x130;
      v13 -= 304;
      if (!v16)
        goto LABEL_43;
      *(_OWORD *)(v15 + 272) = 0u;
      *(_OWORD *)(v15 + 288) = 0u;
      *(_OWORD *)(v15 + 240) = 0u;
      *(_OWORD *)(v15 + 256) = 0u;
      *(_OWORD *)(v15 + 208) = 0u;
      *(_OWORD *)(v15 + 224) = 0u;
      *(_OWORD *)(v15 + 176) = 0u;
      *(_OWORD *)(v15 + 192) = 0u;
      *(_OWORD *)(v15 + 144) = 0u;
      *(_OWORD *)(v15 + 160) = 0u;
      *(_OWORD *)(v15 + 112) = 0u;
      *(_OWORD *)(v15 + 128) = 0u;
      *(_OWORD *)(v15 + 80) = 0u;
      *(_OWORD *)(v15 + 96) = 0u;
      *(_OWORD *)(v15 + 48) = 0u;
      *(_OWORD *)(v15 + 64) = 0u;
      *(_OWORD *)(v15 + 16) = 0u;
      *(_OWORD *)(v15 + 32) = 0u;
      *(_OWORD *)v15 = 0u;
      if (v12)
      {
        if (v15 + 304 > v14)
          goto LABEL_43;
        *(_QWORD *)(v15 + 272) = 0;
        v17 = *v27;
        *(_QWORD *)(v15 + 280) = *v27;
        if (v15)
        {
          if (v15 >= v14)
            goto LABEL_43;
        }
        *v17 = v15;
        *v27 = (unint64_t *)(v15 + 272);
      }
      else
      {
        if (v15 + 304 > v14)
          goto LABEL_43;
        v18 = *a4;
        *v23 = *a4;
        v19 = (unint64_t **)(v18 + 280);
        v7 = v18 == 0;
        v20 = v27;
        if (!v7)
          v20 = v19;
        *v20 = v23;
        if (v15)
        {
          if (v15 >= v14)
            goto LABEL_43;
        }
        *a4 = v15;
        *(_QWORD *)(a2 + 280) = a4;
      }
      if (X509CertificateParseImplicit(v15, &v30, 0, 0))
        return 0;
      if (v6 < v5)
        goto LABEL_43;
      v21 = v30;
      v22 = v30 - v5;
      if (v30 - v5 > v6 - v5)
        goto LABEL_43;
      if (v15 + 304 > v14)
        goto LABEL_43;
      *(_QWORD *)v15 = v5;
      *(_QWORD *)(v15 + 8) = v22;
      v6 = v31;
      if (v21 > v31)
        goto LABEL_43;
      *a1 = v21;
      a1[1] = v6;
      ++v12;
      if (v21 < v6)
      {
        v15 += 304;
        v5 = v21;
        if (v12 < a3)
          continue;
      }
      goto LABEL_8;
    }
  }
}

uint64_t ccder_blob_eat_ber_inner(unint64_t *a1, uint64_t a2, unint64_t *a3, int a4)
{
  int v8;
  uint64_t result;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v15 = 0;
  v14 = 0xAAAAAAAAAAAAAAAALL;
  v8 = ccder_blob_decode_tag();
  result = 0;
  if (v8 && v14 == a2)
  {
    v13 = 0xAAAAAAAAAAAAAAAALL;
    result = ccder_blob_decode_ber_len((uint64_t)a1, &v15, &v13);
    if ((result & 1) == 0)
      return 0;
    if (a3)
    {
      v10 = a1[1];
      if (*a1 > v10)
        goto LABEL_18;
      *a3 = *a1;
      a3[1] = v10;
    }
    if (v15)
    {
      if (a4 >= 1)
      {
        result = ccder_blob_eat_ber_inner(a1, 0, 0, (char)(a4 - 1));
        if (!(_DWORD)result)
          return result;
        return (ccder_blob_decode_eoc(a1, 1) & 1) != 0;
      }
      return 0;
    }
    v11 = *a1;
    if (__CFADD__(*a1, v13))
    {
LABEL_19:
      __break(0x5513u);
      return result;
    }
    v12 = v11 + v13;
    if (v11 <= v11 + v13 && v12 <= a1[1])
    {
      *a1 = v12;
      return 1;
    }
LABEL_18:
    __break(0x5519u);
    goto LABEL_19;
  }
  return result;
}

uint64_t compare_octet_string(uint64_t a1, uint64_t a2)
{
  size_t v2;
  size_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return memcmp(*(const void **)a1, *(const void **)a2, v2);
  if (v2 > v3)
    return 0xFFFFFFFFLL;
  return 1;
}

uint64_t compare_octet_string_raw(uint64_t a1, const void *a2, size_t a3)
{
  size_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3 == a3)
    return memcmp(*(const void **)a1, a2, a3);
  if (v3 > a3)
    return 0xFFFFFFFFLL;
  return 1;
}

uint64_t compare_octet_string_partial(uint64_t a1, uint64_t a2)
{
  size_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2 <= *(_QWORD *)(a2 + 8))
    return memcmp(*(const void **)a2, *(const void **)a1, v2);
  else
    return 0xFFFFFFFFLL;
}

uint64_t ccder_blob_decode_AlgorithmIdentifierNULL(unint64_t *a1, unint64_t *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    if (*a1 > a1[1])
      goto LABEL_20;
    v5 = *a1;
    v6 = *a1;
    result = ccder_blob_decode_tl();
    if (!(_DWORD)result)
      return result;
    if (a2)
    {
      if (v6 < v5)
        goto LABEL_20;
      *a2 = v5;
      a2[1] = 0;
    }
    if (v5 == v6)
    {
      if (v5 <= a1[1] && *a1 <= v5)
      {
        *a1 = v5;
        return 1;
      }
    }
    else if (v5 <= v6)
    {
      result = ccder_blob_decode_tl();
      if (!(_DWORD)result)
        return result;
      if (v5 != v6)
        return 0;
      if (v5 <= a1[1] && *a1 <= v5)
      {
        *a1 = v5;
        return 1;
      }
    }
LABEL_20:
    __break(0x5519u);
  }
  return result;
}

uint64_t ccder_blob_decode_Time(_QWORD *a1)
{
  if (*a1 > a1[1])
    goto LABEL_6;
  if ((ccder_blob_decode_tl() & 1) != 0)
    return 0;
  if (*a1 > a1[1])
LABEL_6:
    __break(0x5519u);
  ccder_blob_decode_tl();
  return 0;
}

uint64_t ccder_blob_check_null()
{
  return ccder_blob_decode_tl();
}

uint64_t CTParseExtensionValue(unint64_t a1, uint64_t a2, const void *a3, size_t a4, _QWORD *a5, _QWORD *a6)
{
  uint64_t result;
  uint64_t v9;
  unint64_t v10[2];
  _OWORD v11[15];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  memset(v11, 0, sizeof(v11));
  if (__CFADD__(a1, a2))
  {
    __break(0x5513u);
LABEL_11:
    __break(0x5519u);
  }
  if (a1 + a2 < a1)
    goto LABEL_11;
  v10[0] = a1;
  v10[1] = a1 + a2;
  result = X509CertificateParseWithExtension((unint64_t *)v11, v10, a3, a4);
  if (!(_DWORD)result)
  {
    result = 720914;
    if (*((_QWORD *)&v12 + 1))
    {
      v9 = v13;
      if ((_QWORD)v13)
      {
        result = 0;
        if (a5)
        {
          if (a6)
          {
            result = 0;
            *a5 = *((_QWORD *)&v12 + 1);
            *a6 = v9;
          }
        }
      }
    }
  }
  return result;
}

uint64_t X509CertificateParseImplicit(uint64_t a1, unint64_t *a2, const void *a3, size_t a4)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  int v40;
  int v41;
  unint64_t v43;
  unint64_t v51;
  unint64_t v52;
  unsigned __int8 v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  char v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  _OWORD v70[10];
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v68 = 0;
  v69 = 0;
  v66 = 0xAAAAAAAAAAAAAAAALL;
  v67 = 0xAAAAAAAAAAAAAAAALL;
  v4 = *a2;
  v5 = a2[1];
  if (*a2 > v5)
    goto LABEL_186;
  v10 = 720915;
  v66 = *a2;
  v67 = v5;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  result = ccder_blob_decode_tl();
  if (!(_DWORD)result)
    return v10;
  v12 = v69;
  v13 = v66;
  v14 = v69 + v66 - v4;
  if (__CFADD__(v69, v66 - v4))
    goto LABEL_188;
  if (v14 > v5 - v4)
    goto LABEL_186;
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 24) = v14;
  v64 = 0xAAAAAAAAAAAAAAAALL;
  v65 = 0xAAAAAAAAAAAAAAAALL;
  if (__CFADD__(v13, v12))
    goto LABEL_187;
  v15 = v13 + v12;
  if (v13 > v15 || v15 > v67)
    goto LABEL_186;
  v64 = v13;
  v65 = v15;
  v62 = v13;
  v63 = v15;
  if (ccder_blob_decode_tl())
  {
    if (__CFADD__(v62, v68))
      goto LABEL_187;
    v16 = 720916;
    if (ccder_blob_decode_uint64() && v62 == v62 + v68)
    {
      if (v62 + v68 > v63)
        goto LABEL_186;
      v64 = v62 + v68;
      v65 = v63;
      goto LABEL_14;
    }
    return v16;
  }
LABEL_14:
  if (!ccder_blob_decode_tl())
    return 720917;
  v18 = v64;
  v17 = v65;
  if (v65 < v64)
    goto LABEL_186;
  v19 = v68;
  if (v68 > v65 - v64)
    goto LABEL_186;
  *(_QWORD *)(a1 + 136) = v64;
  *(_QWORD *)(a1 + 144) = v19;
  if (__CFADD__(v18, v19))
    goto LABEL_187;
  v20 = v18 + v19;
  if (v18 > v20 || v20 > v17)
    goto LABEL_186;
  v64 = v20;
  if (!ccder_blob_decode_AlgorithmIdentifierNULL(&v64, (unint64_t *)(a1 + 152)))
    return 720918;
  if (!ccder_blob_decode_tl())
    return 720919;
  v22 = v64;
  v21 = v65;
  if (v65 < v64)
    goto LABEL_186;
  v23 = v68;
  if (v68 > v65 - v64)
    goto LABEL_186;
  *(_QWORD *)(a1 + 120) = v64;
  *(_QWORD *)(a1 + 128) = v23;
  if (__CFADD__(v22, v23))
    goto LABEL_187;
  v24 = v22 + v23;
  if (v22 > v24 || v24 > v21)
    goto LABEL_186;
  v64 = v24;
  if (!ccder_blob_decode_tl())
    return 720920;
  v26 = v64;
  v25 = v65;
  if (v65 < v64)
    goto LABEL_186;
  v27 = v68;
  if (v68 > v65 - v64)
    goto LABEL_186;
  *(_QWORD *)(a1 + 72) = v64;
  *(_QWORD *)(a1 + 80) = v27;
  if (__CFADD__(v26, v27))
    goto LABEL_187;
  v28 = v26 + v27;
  if (v26 > v28 || v28 > v25)
    goto LABEL_186;
  v64 = v28;
  if (!ccder_blob_decode_tl())
    return 720921;
  v29 = v64;
  v30 = v65;
  if (v65 < v64)
    goto LABEL_186;
  v31 = v68;
  if (v68 > v65 - v64)
    goto LABEL_186;
  *(_QWORD *)(a1 + 104) = v64;
  *(_QWORD *)(a1 + 112) = v31;
  if (__CFADD__(v29, v31))
    goto LABEL_187;
  v32 = v29 + v31;
  if (v29 > v29 + v31 || v32 > v30)
    goto LABEL_186;
  v64 = v29 + v31;
  result = ccder_blob_decode_tl();
  if (!(_DWORD)result)
    return 720922;
  v33 = v64;
  v34 = v68;
  v35 = v64 - v32 + v68;
  if (!__CFADD__(v64 - v32, v68))
  {
    if (v35 > v30 - v32)
      goto LABEL_186;
    *(_QWORD *)(a1 + 88) = v32;
    *(_QWORD *)(a1 + 96) = v35;
    if (__CFADD__(v33, v34))
      goto LABEL_187;
    v36 = v33 + v34;
    if (v33 > v36 || v36 > v65)
      goto LABEL_186;
    v63 = v65;
    v64 = v36;
    v62 = v36;
    if ((ccder_blob_decode_tl() & 1) != 0)
      return 720923;
    if (v64 > v65)
      goto LABEL_186;
    v62 = v64;
    v63 = v65;
    if ((ccder_blob_decode_tl() & 1) != 0)
      return 720924;
    if (v64 > v65)
      goto LABEL_186;
    v62 = v64;
    v63 = v65;
    if (ccder_blob_decode_tl())
    {
      v60 = 0xAAAAAAAAAAAAAAAALL;
      v61 = 0xAAAAAAAAAAAAAAAALL;
      if (__CFADD__(v62, v68))
        goto LABEL_187;
      if (v62 > v62 + v68 || v62 + v68 > v63)
        goto LABEL_186;
      v60 = v62;
      v61 = v62 + v68;
      if (!ccder_blob_decode_tl() || !v68)
        return 720925;
      v37 = v60;
      if (__CFADD__(v60, v68))
LABEL_187:
        __break(0x5513u);
      v38 = v60 + v68;
      if (v60 > v60 + v68 || v38 > v61)
        goto LABEL_186;
      v61 = v60 + v68;
      *(_BYTE *)(a1 + 266) = 0;
      memset(&v70[2], 0, 128);
      if (a3)
        v39 = a4 == 0;
      else
        v39 = 1;
      v40 = !v39;
      memset(v70, 0, 32);
      if (v37 < v38)
      {
        v53 = 0;
        v41 = 0;
        do
        {
          v58 = 0xAAAAAAAAAAAAAAAALL;
          v59 = 0xAAAAAAAAAAAAAAAALL;
          v57 = 0;
          v56 = 0;
          if ((ccder_blob_decode_tl() & 1) == 0)
            return 720926;
          v54 = 0xAAAAAAAAAAAAAAAALL;
          v55 = 0xAAAAAAAAAAAAAAAALL;
          if (__CFADD__(v60, v56))
            goto LABEL_187;
          if (v60 > v60 + v56 || v60 + v56 > v61)
            goto LABEL_186;
          v54 = v60;
          v55 = v60 + v56;
          if (!ccder_blob_decode_tl())
            return 720927;
          if (v55 < v54 || v68 > v55 - v54)
            goto LABEL_186;
          v58 = v54;
          v59 = v68;
          if (__CFADD__(v54, v68))
            goto LABEL_187;
          if (v54 > v54 + v68 || v54 + v68 > v55)
            goto LABEL_186;
          v54 += v68;
          if (!der_get_BOOLean(&v54, 1, &v57))
            return 720928;
          if (!ccder_blob_decode_tl())
            return 720929;
          if (__CFADD__(v54, v68))
            goto LABEL_187;
          if (v55 != v54 + v68)
            return 720929;
          if (v40 && !compare_octet_string_raw((uint64_t)&v58, a3, a4))
          {
            if (v55 < v54)
              goto LABEL_186;
            v43 = v68;
            if (v68 > v55 - v54)
              goto LABEL_186;
            *(_QWORD *)(a1 + 248) = v54;
            *(_QWORD *)(a1 + 256) = v43;
          }
          if (v59 == 3)
          {
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 15)
            {
              v16 = 720930;
              if ((v41 & 1) != 0 || (X509ExtensionParseKeyUsage() & 1) == 0)
                return v16;
              v41 |= 1u;
              goto LABEL_155;
            }
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 19)
            {
              v16 = 720931;
              if ((v41 & 2) != 0
                || (X509ExtensionParseBasicConstraints(&v54, (_QWORD *)(a1 + 200), (_BYTE *)(a1 + 265)) & 1) == 0)
              {
                return v16;
              }
              v41 |= 2u;
              goto LABEL_155;
            }
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 35)
            {
              v16 = 720932;
              if ((v41 & 4) != 0
                || (X509ExtensionParseAuthorityKeyIdentifier(&v54, (unint64_t *)(a1 + 168), (_QWORD *)(a1 + 176)) & 1) == 0)
              {
                return v16;
              }
              v41 |= 4u;
              goto LABEL_155;
            }
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 14)
            {
              v16 = 720933;
              if ((v41 & 8) != 0
                || (X509ExtensionParseSubjectKeyIdentifier(&v54, (unint64_t *)(a1 + 184), (_QWORD *)(a1 + 192)) & 1) == 0)
              {
                return v16;
              }
              v41 |= 8u;
              goto LABEL_155;
            }
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 37)
            {
              v16 = 720934;
              if ((v41 & 0x10) != 0
                || (X509ExtensionParseExtendedKeyUsage(&v54, (unint64_t *)(a1 + 208), (_QWORD *)(a1 + 216)) & 1) == 0)
              {
                return v16;
              }
              v41 |= 0x10u;
              goto LABEL_155;
            }
            if (*(_WORD *)v58 == 7509 && *(_BYTE *)(v58 + 2) == 17)
            {
              v16 = 720935;
              if ((v41 & 0x20) != 0
                || (X509ExtensionParseSubjectAltName(&v54, (unint64_t *)(a1 + 224), (_QWORD *)(a1 + 232)) & 1) == 0)
              {
                return v16;
              }
              v41 |= 0x20u;
              goto LABEL_155;
            }
          }
          else if (v59 >= 8 && *(_DWORD *)v58 == -2042067414 && *(_DWORD *)(v58 + 3) == 1684273030)
          {
            v16 = 720936;
            if (!X509CertificateVerifyOnlyOneAppleExtension((uint64_t)&v58, (uint64_t)v70, v53))
              return v16;
            result = X509ExtensionParseAppleExtension((uint64_t)&v54, v58, v59, (uint64_t *)(a1 + 240), (unint64_t *)(a1 + 248), v40);
            if (!(_DWORD)result)
              return v16;
            if (v53 == 0xFF)
              goto LABEL_189;
            ++v53;
            goto LABEL_155;
          }
          if (__CFADD__(v54, v68))
            goto LABEL_187;
          if (v54 > v54 + v68 || v54 + v68 > v55)
            goto LABEL_186;
          v54 += v68;
          if (v57)
            *(_BYTE *)(a1 + 266) = 1;
LABEL_155:
          if (v54 != v55)
            return 720926;
          if (__CFADD__(v60, v56))
            goto LABEL_187;
          v37 = v60 + v56;
          if (v60 > v60 + v56)
            goto LABEL_186;
          v38 = v61;
          if (v37 > v61)
            goto LABEL_186;
          v60 += v56;
        }
        while (v37 < v61);
      }
      if (v37 != v38)
        return 720925;
      if (v37 > v65 || v64 > v37)
        goto LABEL_186;
      v64 = v37;
    }
    if (*(_QWORD *)(a1 + 32) < 3uLL)
    {
      v16 = 720915;
      if (v64 != v65)
        return v16;
LABEL_170:
      if (__CFADD__(v66, v69))
        goto LABEL_187;
      if (v66 > v66 + v69 || v66 + v69 > v67)
        goto LABEL_186;
      v66 += v69;
      if (!ccder_blob_decode_AlgorithmIdentifierNULL(&v66, (unint64_t *)(a1 + 40)))
        return 720937;
      *(_QWORD *)&v70[0] = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v70[0] + 1) = 0xAAAAAAAAAAAAAAAALL;
      v60 = 0;
      result = ccder_blob_decode_bitstring();
      if (!(_DWORD)result)
        return 720938;
      if (v60 < 0xFFFFFFFFFFFFFFF9)
      {
        if (*((_QWORD *)&v70[0] + 1) >= *(_QWORD *)&v70[0])
        {
          v51 = (v60 + 7) >> 3;
          if (v51 <= *((_QWORD *)&v70[0] + 1) - *(_QWORD *)&v70[0])
          {
            *(_QWORD *)(a1 + 56) = *(_QWORD *)&v70[0];
            *(_QWORD *)(a1 + 64) = v51;
            v52 = v67;
            if (v66 <= v67)
            {
              v16 = 0;
              *a2 = v66;
              a2[1] = v52;
              return v16;
            }
          }
        }
        goto LABEL_186;
      }
      goto LABEL_188;
    }
    if (v65 <= a2[1] && *a2 <= v65)
    {
      *a2 = v65;
      goto LABEL_170;
    }
LABEL_186:
    __break(0x5519u);
    goto LABEL_187;
  }
LABEL_188:
  __break(0x5500u);
LABEL_189:
  __break(0x5507u);
  return result;
}

uint64_t der_get_BOOLean(_QWORD *a1, int a2, _BYTE *a3)
{
  if (*a1 > a1[1])
    __break(0x5519u);
  if ((ccder_blob_decode_tl() & 1) != 0 || !a2)
    return 0;
  if (a3)
    *a3 = 0;
  return 1;
}

uint64_t X509ExtensionParseKeyUsage()
{
  uint64_t result;

  result = ccder_blob_decode_bitstring();
  if ((_DWORD)result)
    return 0;
  return result;
}

uint64_t X509ExtensionParseBasicConstraints(_QWORD *a1, _QWORD *a2, _BYTE *a3)
{
  uint64_t result;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    result = der_get_BOOLean(a1, 1, a3);
    if ((_DWORD)result)
    {
      if (ccder_blob_decode_uint64())
      {
        if (!*a3)
          return 0;
        *a2 = 0xAAAAAAAAAAAAAAAALL;
        *a2 = 0xAAAAAAAAAAAAAAABLL;
      }
      return 1;
    }
  }
  return result;
}

uint64_t X509ExtensionParseAuthorityKeyIdentifier(unint64_t *a1, unint64_t *a2, _QWORD *a3)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v7 = *a1;
    if (*a1 >= 0x5555555555555556)
      goto LABEL_15;
    if (v7 - 0x5555555555555556 != a1[1])
      return 0;
    if (v7 > v7 - 0x5555555555555556)
      goto LABEL_16;
    v10 = *a1;
    v11 = v7 - 0x5555555555555556;
    result = ccder_blob_decode_tl();
    if ((_DWORD)result)
    {
      if (v11 < v10 || v11 - v10 < 0xAAAAAAAAAAAAAAAALL)
        goto LABEL_16;
      *a2 = v10;
      *a3 = 0xAAAAAAAAAAAAAAAALL;
    }
    v8 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
LABEL_15:
      __break(0x5513u);
    }
    else
    {
      v9 = v8 - 0x5555555555555556;
      if (v8 <= v8 - 0x5555555555555556 && v9 <= a1[1])
      {
        *a1 = v9;
        return 1;
      }
    }
LABEL_16:
    __break(0x5519u);
  }
  return result;
}

uint64_t X509ExtensionParseSubjectKeyIdentifier(unint64_t *a1, unint64_t *a2, _QWORD *a3)
{
  uint64_t result;
  unint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v7 = a1[1];
    v8 = v7 >= *a1;
    v9 = v7 - *a1;
    if (!v8 || v9 < 0xAAAAAAAAAAAAAAAALL)
      goto LABEL_13;
    *a2 = *a1;
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    v11 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
      return result;
    }
    v12 = v11 - 0x5555555555555556;
    if (v11 > v11 - 0x5555555555555556 || v12 > a1[1])
LABEL_13:
      __break(0x5519u);
    *a1 = v12;
  }
  return result;
}

uint64_t X509ExtensionParseExtendedKeyUsage(unint64_t *a1, unint64_t *a2, _QWORD *a3)
{
  int v6;
  uint64_t result;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v6 = ccder_blob_decode_tl();
  result = 0;
  if (v6)
  {
    if (*a1 > a1[1])
      goto LABEL_11;
    v10 = *a1;
    v11 = a1[1];
    result = ccder_blob_decode_tl();
    if (!(_DWORD)result)
      return result;
    if (v11 < v10 || v11 - v10 < 0xAAAAAAAAAAAAAAAALL)
      goto LABEL_11;
    *a2 = v10;
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    v8 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
      return result;
    }
    v9 = v8 - 0x5555555555555556;
    if (v8 > v8 - 0x5555555555555556 || v9 > a1[1])
LABEL_11:
      __break(0x5519u);
    *a1 = v9;
  }
  return result;
}

uint64_t X509ExtensionParseSubjectAltName(unint64_t *a1, unint64_t *a2, _QWORD *a3)
{
  uint64_t result;
  unint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result == 1)
  {
    v7 = a1[1];
    v8 = v7 >= *a1;
    v9 = v7 - *a1;
    if (!v8 || v9 < 0xAAAAAAAAAAAAAAAALL)
      goto LABEL_13;
    *a2 = *a1;
    *a3 = 0xAAAAAAAAAAAAAAAALL;
    v11 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
      return result;
    }
    v12 = v11 - 0x5555555555555556;
    if (v11 > v11 - 0x5555555555555556 || v12 > a1[1])
LABEL_13:
      __break(0x5519u);
    *a1 = v12;
  }
  return result;
}

uint64_t X509CertificateVerifyOnlyOneAppleExtension(uint64_t result, uint64_t a2, unsigned int a3)
{
  _QWORD *v5;
  unsigned __int8 v6;
  unint64_t v7;
  uint64_t v9;
  _QWORD *v10;

  if (a3 > 9)
    return 0;
  v5 = (_QWORD *)result;
  v6 = 0;
  v7 = ~a2;
  while (v7 >= 16 * (char)v6)
  {
    result = compare_octet_string((uint64_t)v5, a2 + 16 * v6);
    if (!(_DWORD)result)
      return result;
    if (a3 <= v6++)
    {
      v9 = v5[1];
      v10 = (_QWORD *)(a2 + 16 * a3);
      *v10 = *v5;
      v10[1] = v9;
      return 1;
    }
  }
  __break(0x5513u);
  return result;
}

uint64_t X509ExtensionParseAppleExtension(uint64_t result, unint64_t a2, unint64_t a3, uint64_t *a4, unint64_t *a5, int a6)
{
  uint64_t v24;
  int v44;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (a6)
    a5 = 0;
  if (a3 == 11)
  {
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x10901066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x400000000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x10301066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x200;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x10601066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x800;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x11801066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x2000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x12401066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x100000000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x11901066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x4000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_QWORD *)(a2 + 3) == 0x21901066463F786)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x8000;
      goto LABEL_261;
    }
LABEL_157:
    v44 = 0;
LABEL_158:
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 27)
      return X509ExtensionParseServerAuthMarker(result, a2, a3, a4, a5);
    if (!v44)
      goto LABEL_232;
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 832)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x400000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3586)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v54 = *a4;
      v55 = 37748736;
    }
    else
    {
      if (*(_QWORD *)a2 != 0x66463F78648862ALL || *(_WORD *)(a2 + 8) != 4354)
      {
        if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 327)
          return (uint64_t)X509ExtensionParseMFI4Properties((unint64_t *)result, a4, a5);
        if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3841)
        {
          v52 = *(_QWORD *)result;
          v51 = *(_QWORD *)(result + 8);
          if (a5)
          {
            if (v52 > v51)
              goto LABEL_265;
            *a5 = v52;
            a5[1] = v51 - v52;
          }
          *a4 |= 0x80000000uLL;
LABEL_233:
          if (v52 <= v51)
          {
            *(_QWORD *)result = v51;
            return 1;
          }
LABEL_265:
          __break(0x5519u);
          return result;
        }
        goto LABEL_232;
      }
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v54 = *a4;
      v55 = 0x8004000000;
    }
LABEL_201:
    v24 = v54 | v55;
    goto LABEL_261;
  }
  if (a3 == 10)
  {
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 5122)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x100000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 258)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v54 = *a4;
      v55 = 0x58600003F0D0;
      goto LABEL_201;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1538)
      goto LABEL_203;
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 4610)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0xF00;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3073)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x10;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1793)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x20000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3329)
    {
LABEL_203:
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x20;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 2305)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x40;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 513)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x80;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1025)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x10000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 769)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x100;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 1537)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x400;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 6145)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x1000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 9217)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x80000000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 8193)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x2000000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 8705)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x4000000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 315)
      return X509ExtensionParseMFISWAuth((unint64_t *)result, a4, a5);
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 3074)
    {
      result = ccder_blob_check_null();
      if (!(_DWORD)result)
        return result;
      v24 = *a4 | 0x300000000;
      goto LABEL_261;
    }
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_WORD *)(a2 + 8) == 304)
      return X509ExtensionParseGenericSSLMarker();
    v44 = 1;
    goto LABEL_158;
  }
  if (a3 != 9)
  {
    if (a3 < 0xA)
      goto LABEL_232;
    goto LABEL_157;
  }
  if (*(_QWORD *)a2 == 0xB6463F78648862ALL && *(_BYTE *)(a2 + 8) == 1)
    return X509ExtensionParseComponentAuth((unint64_t *)result, a4, a5);
  if (*(_QWORD *)a2 != 0x66463F78648862ALL || *(_BYTE *)(a2 + 8) != 49)
  {
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 44)
      return X509ExtensionParseCertifiedChipIntermediate((unint64_t *)result, a4, a5);
    if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 36)
      return X509ExtensionParseMFIAuthv3Leaf((unint64_t *)result);
    if (*(_QWORD *)a2 != 0x66463F78648862ALL || *(_BYTE *)(a2 + 8) != 22)
    {
      if (*(_QWORD *)a2 == 0xC6463F78648862ALL && *(_BYTE *)(a2 + 8) == 19)
      {
        result = ccder_blob_check_null();
        if (!(_DWORD)result)
          return result;
        v24 = *a4 | 0x8000000000;
        goto LABEL_261;
      }
      if (*(_QWORD *)a2 != 0xA6463F78648862ALL || *(_BYTE *)(a2 + 8) != 1)
      {
        if (*(_QWORD *)a2 == 0x66463F78648862ALL && *(_BYTE *)(a2 + 8) == 29)
        {
          result = ccder_blob_check_null();
          if (!(_DWORD)result)
            return result;
          v24 = *a4 | 0x2000000;
        }
        else
        {
          if (*(_QWORD *)a2 != 0xC6463F78648862ALL || *(_BYTE *)(a2 + 8) != 14)
          {
            if (*(_QWORD *)a2 == 0x86463F78648862ALL && *(_BYTE *)(a2 + 8) == 3)
              return X509ExtensionParseDeviceAttestationIdentity((unint64_t *)result, a4, a5);
            goto LABEL_232;
          }
          result = ccder_blob_check_null();
          if (!(_DWORD)result)
            return result;
          v24 = *a4 | 0x4000000;
        }
LABEL_261:
        *a4 = v24;
        return 1;
      }
      *a4 |= 0x1000000uLL;
LABEL_232:
      v52 = *(_QWORD *)result;
      v51 = *(_QWORD *)(result + 8);
      goto LABEL_233;
    }
    result = ccder_blob_check_null();
    if (!(_DWORD)result)
      return result;
    v54 = *a4;
    v55 = 1048584;
    goto LABEL_201;
  }
  v56 = 0;
  result = der_get_BOOLean((_QWORD *)result, 0, &v56);
  if ((_DWORD)result)
  {
    v53 = 0x10000080002;
    if (!v56)
      v53 = 0x20000040001;
    *a4 |= v53;
  }
  return result;
}

uint64_t X509CertificateParseWithExtension(unint64_t *a1, unint64_t *a2, const void *a3, size_t a4)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t result;
  unint64_t v13;

  v8 = 720939;
  v9 = *a2;
  v10 = a2[1];
  if (!ccder_blob_decode_tl())
    return v8;
  v11 = *a2;
  result = X509CertificateParseImplicit((uint64_t)a1, a2, a3, a4);
  v8 = result;
  if ((_DWORD)result)
    return v8;
  if (v11 >= 0x5555555555555556)
  {
    __break(0x5513u);
LABEL_11:
    __break(0x5500u);
    goto LABEL_12;
  }
  v8 = 720939;
  if (*a2 != v11 - 0x5555555555555556)
    return v8;
  v13 = v11 - v9 - 0x5555555555555556;
  if (v11 - v9 >= 0x5555555555555556)
    goto LABEL_11;
  if (v10 >= v9 && v13 <= v10 - v9)
  {
    *a1 = v9;
    a1[1] = v13;
    X509PolicyCheckForBlockedKeys((uint64_t)a1);
    return 0;
  }
LABEL_12:
  __break(0x5519u);
  return result;
}

uint64_t X509CertificateParse(unint64_t *a1, unint64_t *a2)
{
  return X509CertificateParseWithExtension(a1, a2, 0, 0);
}

uint64_t X509CertificateParseSPKI(unint64_t *a1, unint64_t *a2, unint64_t *a3, _QWORD *a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v10;
  unint64_t v11;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  v4 = *a1;
  v5 = a1[1];
  if (__CFADD__(*a1, v5))
    goto LABEL_31;
  v6 = v4 + v5;
  if (v4 > v6)
    goto LABEL_30;
  v10 = 655361;
  v14 = *a1;
  v15 = v6;
  if (!ccder_blob_decode_tl())
    return v10;
  if (!ccder_blob_decode_tl())
    return 655363;
  if (v14 >= 0x5555555555555556)
LABEL_31:
    __break(0x5513u);
  if (v14 > v14 - 0x5555555555555556 || v14 - 0x5555555555555556 > v15)
    goto LABEL_30;
  v13 = v14 - 0x5555555555555556;
  if (!ccder_blob_decode_tl())
    return 655362;
  if (a2)
  {
    if (v13 >= v14)
    {
      *a2 = v14;
      a2[1] = 0xAAAAAAAAAAAAAAAALL;
      goto LABEL_12;
    }
LABEL_30:
    __break(0x5519u);
    goto LABEL_31;
  }
LABEL_12:
  v11 = v14 - 0x5555555555555556;
  if (v14 > v14 - 0x5555555555555556 || v11 > v13)
    goto LABEL_30;
  if (v11 == v13)
  {
    if (a3)
    {
      *a3 = 0;
      a3[1] = 0;
    }
  }
  else if (a3)
  {
    *a3 = v11;
    a3[1] = v13 - v11;
  }
  if (v13 > v15 || v14 > v13)
    goto LABEL_30;
  if (!ccder_blob_decode_bitstring())
    return 655364;
  *a4 = 0;
  a4[1] = 0;
  if (v13 == v15)
    return 0;
  else
    return 655365;
}

uint64_t X509CertificateCheckSignatureDigest(char a1, uint64_t a2, uint64_t *a3, __int128 *a4, __int128 *a5)
{
  uint64_t v9;
  uint64_t result;
  unsigned int (*v11)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *);
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[3];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v28 = 0uLL;
  v27 = 0uLL;
  v25 = 0;
  v26 = 0;
  v24 = 0;
  v23 = 0u;
  v22 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v9 = X509CertificateParseSPKI((unint64_t *)(a2 + 88), (unint64_t *)&v28, (unint64_t *)&v27, &v25);
  if ((_DWORD)v9)
    return v9;
  v9 = 655632;
  if (compare_octet_string((uint64_t)&v28, (uint64_t)&rsaEncryption))
  {
    if (compare_octet_string((uint64_t)&v28, (uint64_t)&ecPublicKey_0))
      return 655617;
    v11 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))validateSignatureEC;
  }
  else
  {
    v11 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))validateSignatureRSA;
  }
  memset(v14, 0, sizeof(v14));
  v19 = *a5;
  v15 = *a4;
  v17 = v28;
  v18 = v27;
  if (((a1 & 1) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha1, 5uLL))
    && ((a1 & 4) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha256, 9uLL))
    && ((a1 & 8) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha384, 9uLL))
    && ((a1 & 0x10) == 0 || compare_octet_string_raw((uint64_t)a4, &CTOidSha512, 9uLL)))
  {
    return v9;
  }
  result = v25;
  if (v26 || !v25)
  {
    v12 = *a3;
    v13 = a3[1];
    if (v13 || !v12)
    {
      if (v11(v25, v26, v12, v13, v14))
        return 0;
      else
        return 655648;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t X509CertificateCheckSignature(char a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5)
{
  __int128 v8;
  uint64_t result;
  __int128 v10;
  uint64_t v11[2];
  _OWORD v12[4];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[2] = v8;
  v12[3] = v8;
  v12[0] = v8;
  v12[1] = v8;
  v11[0] = (uint64_t)v12;
  v11[1] = 64;
  v10 = 0uLL;
  result = X509MatchSignatureAlgorithm(a3, a4, (uint64_t)v11, &v10);
  if (!(_DWORD)result)
    return X509CertificateCheckSignatureDigest(a1, a2, v11, &v10, a5);
  return result;
}

uint64_t X509MatchSignatureAlgorithm(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t result;

  result = compare_octet_string_raw(a2, &sha1WithRSA_oid, 9uLL);
  if (!(_DWORD)result)
    goto LABEL_8;
  result = compare_octet_string_raw(a2, &sha256WithRSA_oid, 9uLL);
  if (!(_DWORD)result)
  {
LABEL_10:
    *a4 = &CTOidSha256;
    a4[1] = 9;
    if (*(_QWORD *)(a3 + 8) < 0x20uLL)
      goto LABEL_15;
    *(_QWORD *)(a3 + 8) = 32;
    ccsha256_di();
    goto LABEL_14;
  }
  result = compare_octet_string_raw(a2, &sha384WithRSA_oid, 9uLL);
  if (!(_DWORD)result)
    goto LABEL_12;
  result = compare_octet_string_raw(a2, &sha1WithECDSA_oid, 7uLL);
  if (!(_DWORD)result)
  {
LABEL_8:
    *a4 = &CTOidSha1;
    a4[1] = 5;
    if (*(_QWORD *)(a3 + 8) < 0x14uLL)
      goto LABEL_15;
    *(_QWORD *)(a3 + 8) = 20;
    ccsha1_di();
LABEL_14:
    ccdigest();
    return 0;
  }
  result = compare_octet_string_raw(a2, &sha256WithECDSA_oid, 8uLL);
  if (!(_DWORD)result)
    goto LABEL_10;
  result = compare_octet_string_raw(a2, &sha384WithECDSA_oid, 8uLL);
  if ((_DWORD)result)
    return 656640;
LABEL_12:
  *a4 = &CTOidSha384;
  a4[1] = 9;
  if (*(_QWORD *)(a3 + 8) >= 0x30uLL)
  {
    *(_QWORD *)(a3 + 8) = 48;
    ccsha384_di();
    goto LABEL_14;
  }
LABEL_15:
  __break(0x5519u);
  return result;
}

uint64_t X509CertificateCheckSignatureWithPublicKey(uint64_t *a1, uint64_t a2, __int128 *a3, uint64_t a4, __int128 *a5, __int128 *a6)
{
  __int128 v11;
  uint64_t matched;
  unsigned int (*v13)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *);
  __int128 v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;
  _OWORD *v30;
  uint64_t v31;
  _OWORD v32[4];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v32[2] = v11;
  v32[3] = v11;
  v32[0] = v11;
  v32[1] = v11;
  v30 = v32;
  v31 = 64;
  v29 = 0uLL;
  matched = X509MatchSignatureAlgorithm(a4, (uint64_t)a5, (uint64_t)&v30, &v29);
  if ((_DWORD)matched)
    return matched;
  matched = 655617;
  if (compare_octet_string(a2, (uint64_t)&rsaEncryption))
  {
    if (compare_octet_string(a2, (uint64_t)&ecPublicKey_0))
      return matched;
    v13 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))validateSignatureEC;
  }
  else
  {
    v13 = (unsigned int (*)(unint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))validateSignatureRSA;
  }
  v28 = 0;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v22 = 0u;
  v20 = 0u;
  v18 = 0u;
  v21 = *a5;
  v17 = 0;
  v23 = *a6;
  v19 = v29;
  if (a3)
    v14 = *a3;
  else
    v14 = null_octet;
  v22 = v14;
  result = *a1;
  v16 = a1[1];
  if ((v16 || !result) && (!v30 || v31))
  {
    if (v13(result, v16, (uint64_t)v30, v31, &v17))
      return 0;
    else
      return 655648;
  }
  __break(0x5519u);
  return result;
}

uint64_t X509CertificateSubjectNameGetCommonName(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v6;
  unint64_t v7;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;

  v2 = *a1;
  v3 = a1[1];
  v20 = v3;
  if (__CFADD__(*a1, v3))
    goto LABEL_59;
  v4 = v2 + v3;
  if (v2 > v4)
  {
LABEL_58:
    __break(0x5519u);
    goto LABEL_59;
  }
  v6 = 720901;
  v18 = *a1;
  v19 = v4;
  *a2 = 0;
  a2[1] = 0;
  if (v2 < v4)
  {
    while (1)
    {
      if (!ccder_blob_decode_tl() || !v20)
        return 720898;
      v2 = v18;
      if (__CFADD__(v18, v20))
        break;
      v7 = v18 + v20;
      if (v18 > v18 + v20 || v7 > v19)
        goto LABEL_58;
      v16 = v18;
      v17 = v18 + v20;
      while (v2 < v7)
      {
        if (!ccder_blob_decode_tl())
          return 720899;
        if (__CFADD__(v16, v20))
          goto LABEL_59;
        if (v16 > v16 + v20 || v16 + v20 > v17)
          goto LABEL_58;
        v15 = v16 + v20;
        if (!ccder_blob_decode_tl())
          return 720900;
        v2 = v16 + v20;
        if (v16 > v15)
          goto LABEL_58;
        if (__CFADD__(v16, v20))
          goto LABEL_59;
        if (v16 > v16 + v20)
          goto LABEL_58;
        v14 = v16 + v20;
        if (v20 == 3 && *(_WORD *)v16 == 1109 && *(_BYTE *)(v16 + 2) == 3)
        {
          v12 = v16 + v20;
          v13 = v16 + v20;
          if ((ccder_blob_decode_tl() & 1) == 0)
          {
            if (v14 > v15)
              goto LABEL_58;
            v12 = v16 + v20;
            v13 = v16 + v20;
            if ((ccder_blob_decode_tl() & 1) == 0)
            {
              if (v14 > v15)
                goto LABEL_58;
              v12 = v16 + v20;
              v13 = v16 + v20;
              if (!ccder_blob_decode_tl())
                return v6;
            }
          }
          if (__CFADD__(v12, v20))
            goto LABEL_59;
          v2 = v12 + v20;
          if (v15 != v12 + v20)
            return 720902;
          if (v13 < v12 || v20 > v13 - v12)
            goto LABEL_58;
          *a2 = v12;
          a2[1] = v20;
        }
        v7 = v18 + v20;
        if (v2 > v17 || v16 > v2)
          goto LABEL_58;
        v16 = v2;
      }
      if (v2 != v7)
        return 720903;
      v4 = v19;
      if (v2 > v19 || v18 > v2)
        goto LABEL_58;
      v18 = v2;
      if (v2 >= v19)
        goto LABEL_46;
    }
LABEL_59:
    __break(0x5513u);
  }
LABEL_46:
  if (v2 != v4)
    return 720904;
  if (a2[1] && *a2)
    return 0;
  *a2 = 0;
  a2[1] = 0;
  return 720905;
}

BOOL X509CertificateValidAtTime(uint64_t a1, time_t a2)
{
  _BOOL8 result;
  time_t v5;
  time_t v6[2];

  result = 0;
  v6[1] = *MEMORY[0x1E0C80C00];
  v5 = 0;
  v6[0] = 0;
  if (a1 && a2 != -1)
    return !X509CertificateGetNotBefore(a1, v6)
        && !X509CertificateGetNotAfter(a1, &v5)
        && difftime(a2, v6[0]) >= 0.0
        && difftime(a2, v5) <= 0.0;
  return result;
}

uint64_t X509CertificateGetNotBefore(uint64_t a1, time_t *a2)
{
  uint64_t result;
  const char *v4[3];

  v4[2] = *(const char **)MEMORY[0x1E0C80C00];
  v4[0] = (const char *)0xAAAAAAAAAAAAAAAALL;
  v4[1] = (const char *)0xAAAAAAAAAAAAAAAALL;
  result = X509CertificateParseValidity(a1);
  if (!(_DWORD)result)
    return X509TimeConvert(v4, a2);
  return result;
}

uint64_t X509CertificateGetNotAfter(uint64_t a1, time_t *a2)
{
  uint64_t result;
  const char *v4[3];

  v4[2] = *(const char **)MEMORY[0x1E0C80C00];
  v4[0] = (const char *)0xAAAAAAAAAAAAAAAALL;
  v4[1] = (const char *)0xAAAAAAAAAAAAAAAALL;
  result = X509CertificateParseValidity(a1);
  if (!(_DWORD)result)
    return X509TimeConvert(v4, a2);
  return result;
}

BOOL X509CertificateIsValid(uint64_t a1)
{
  time_t v2;

  v2 = time(0);
  return X509CertificateValidAtTime(a1, v2);
}

uint64_t X509CertificateParseValidity(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  unint64_t v5;
  _QWORD v6[3];

  v6[2] = *MEMORY[0x1E0C80C00];
  v1 = 720906;
  if (!result)
    return v1;
  v2 = *(_QWORD *)(result + 72);
  v3 = *(_QWORD *)(result + 80);
  if (!v2 || v3 == 0)
    return v1;
  if (__CFADD__(v2, v3))
  {
    __break(0x5513u);
  }
  else
  {
    v5 = v2 + v3;
    if (v2 <= v5)
    {
      v6[0] = *(_QWORD *)(result + 72);
      v6[1] = v5;
      if (!ccder_blob_decode_Time(v6))
        return 720907;
      if (ccder_blob_decode_Time(v6))
        return 0;
      return 720908;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t X509TimeConvert(const char **a1, time_t *a2)
{
  uint64_t v2;
  const char *v4;
  __int128 v6;
  const char *v7;
  uint64_t result;
  const char *v9;
  time_t v10;
  tm v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v2 = 720909;
  if (!a1)
    return v2;
  v4 = a1[1];
  if (((unint64_t)v4 | 2) != 0xF)
    return v2;
  v11.tm_zone = (char *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v11.tm_mon = v6;
  *(_OWORD *)&v11.tm_isdst = v6;
  *(_OWORD *)&v11.tm_sec = v6;
  v7 = *a1;
  if (v4 == (const char *)13)
  {
    result = (uint64_t)strptime(v7, "%y%m%d%H%M%SZ", &v11);
    if (result && v11.tm_year >= 150)
      v11.tm_year -= 100;
  }
  else
  {
    result = (uint64_t)strptime(v7, "%Y%m%d%H%M%SZ", &v11);
  }
  v9 = a1[1];
  if (!__CFADD__(*a1, v9))
  {
    if ((const char *)result != &v9[(_QWORD)*a1])
      return 720910;
    v10 = timegm(&v11);
    if (v10 == -1)
      return 720911;
    v2 = 0;
    if (a2)
      *a2 = v10;
    return v2;
  }
  __break(0x5513u);
  return result;
}

BOOL X509ExtensionParseComponentAuth(unint64_t *a1, _QWORD *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;

  v3 = a1[1];
  if (*a1 > v3)
    goto LABEL_19;
  v12 = *a1;
  v13 = a1[1];
  v11 = v3 - *a1;
  if ((ccder_blob_decode_tl() & 1) != 0)
    goto LABEL_5;
  if (*a1 > a1[1])
    goto LABEL_19;
  v12 = *a1;
  v13 = a1[1];
  if (ccder_blob_decode_tl())
  {
LABEL_5:
    v8 = v12;
    v7 = v13;
    if (v12 > v13)
      goto LABEL_19;
    *a1 = v12;
    a1[1] = v13;
    v9 = v11;
  }
  else
  {
    v8 = *a1;
    v7 = a1[1];
    v9 = v7 - *a1;
  }
  if (__CFADD__(v8, v9))
    goto LABEL_20;
  if (v7 == v8 + v9)
  {
    if (!v9)
      goto LABEL_16;
    if (!a3)
    {
LABEL_15:
      *a2 |= 0x40000000uLL;
LABEL_16:
      if (v8 <= v7)
      {
        *a1 = v7;
        return v7 == v8 + v9;
      }
      goto LABEL_19;
    }
    if (v8 <= v7 && v9 <= v7 - v8)
    {
      *a3 = v8;
      a3[1] = v9;
      goto LABEL_15;
    }
LABEL_19:
    __break(0x5519u);
LABEL_20:
    __break(0x5513u);
  }
  return v7 == v8 + v9;
}

uint64_t X509ExtensionParseCertifiedChipIntermediate(unint64_t *a1, _QWORD *a2, unint64_t *a3)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v8;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v7 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
      goto LABEL_12;
    }
    v8 = v7 - 0x5555555555555556;
    if (a1[1] != v7 - 0x5555555555555556)
      return 0;
    *a2 |= 0x30000000000uLL;
    if (a3)
    {
      if (v7 > v8)
        goto LABEL_12;
      *a3 = v7;
      a3[1] = 0xAAAAAAAAAAAAAAAALL;
    }
    if (v7 <= v8)
    {
      *a1 = v8;
      return 1;
    }
LABEL_12:
    __break(0x5519u);
  }
  return result;
}

uint64_t X509ExtensionParseMFIAuthv3Leaf(unint64_t *a1)
{
  uint64_t result;
  unint64_t v3;
  unint64_t v4;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v3 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
    }
    else
    {
      v4 = a1[1];
      if (v4 != v3 - 0x5555555555555556)
        return 0;
      if (v3 <= v4)
      {
        *a1 = v4;
        return 1;
      }
    }
    __break(0x5519u);
  }
  return result;
}

uint64_t X509ExtensionParseMFISWAuth(unint64_t *a1, _QWORD *a2, unint64_t *a3)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v8;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v7 = *a1;
    if (*a1 >= 0x5555555555555556)
    {
      __break(0x5513u);
    }
    else
    {
      v8 = a1[1];
      if (v8 != v7 - 0x5555555555555556)
        return 0;
      if (a3)
      {
        if (v8 < v7 || v8 - v7 < 0xAAAAAAAAAAAAAAAALL)
          goto LABEL_13;
        *a3 = v7;
        a3[1] = 0xAAAAAAAAAAAAAAAALL;
      }
      *a2 |= 0x30000000uLL;
      if (v7 <= v8)
      {
        *a1 = v8;
        return 1;
      }
    }
LABEL_13:
    __break(0x5519u);
  }
  return result;
}

uint64_t X509ExtensionParseGenericSSLMarker()
{
  ccder_blob_decode_tl();
  return 0;
}

uint64_t X509ExtensionParseServerAuthMarker(uint64_t a1, unint64_t a2, uint64_t a3, _QWORD *a4, unint64_t *a5)
{
  uint64_t result;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  BOOL v13;
  _BOOL4 v14;
  int v15;

  result = ccder_blob_check_null();
  if ((_DWORD)result)
  {
    if (a2 > 0xFFFFFFFFFFFFFFF6)
      goto LABEL_26;
    if (__CFADD__(a2, a3))
      goto LABEL_26;
    v10 = a2 + a3;
    if (a2 + a3 == -1)
      goto LABEL_26;
    v11 = a2 + 9;
    v12 = (char *)(a2 + 9);
    while (1)
    {
      v13 = (unint64_t)v12 < v10 && (unint64_t)v12 >= a2;
      v14 = v13;
      if ((unint64_t)v12 >= v10 - 1)
        break;
      if (!v14)
        goto LABEL_25;
      v15 = *v12++;
      if ((v15 & 0x80000000) == 0)
        return 0;
    }
    if (!v14)
    {
LABEL_25:
      __break(0x5519u);
LABEL_26:
      __break(0x5513u);
      return result;
    }
    if ((*v12 & 0x80000000) == 0)
    {
      if (!a5)
      {
LABEL_22:
        *a4 |= 0x100000000uLL;
        return 1;
      }
      if (v11 >= a2 && v11 <= v10)
      {
        *a5 = v11;
        a5[1] = a3 - 9;
        goto LABEL_22;
      }
      goto LABEL_25;
    }
    return 0;
  }
  return result;
}

uint64_t X509ExtensionParseDeviceAttestationIdentity(unint64_t *a1, _QWORD *a2, unint64_t *a3)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;

  result = ccder_blob_decode_tl();
  if ((_DWORD)result)
  {
    v7 = *a1;
    if (*a1 >= 0x5555555555555556)
      goto LABEL_17;
    if (a1[1] != v7 - 0x5555555555555556)
      return 0;
    if (v7 > v7 - 0x5555555555555556)
      goto LABEL_18;
    v10 = *a1;
    v11 = v7 - 0x5555555555555556;
    result = ccder_blob_decode_tl();
    if ((_DWORD)result)
    {
      result = ccder_blob_decode_tl();
      if ((_DWORD)result)
      {
        if (a3)
        {
          if (v11 < v10 || v11 - v10 < 0xAAAAAAAAAAAAAAAALL)
            goto LABEL_18;
          *a3 = v10;
          a3[1] = 0xAAAAAAAAAAAAAAAALL;
        }
        *a2 |= 0x240000800000uLL;
        v8 = *a1;
        if (*a1 < 0x5555555555555556)
        {
          v9 = v8 - 0x5555555555555556;
          if (v8 <= v8 - 0x5555555555555556 && v9 <= a1[1])
          {
            *a1 = v9;
            return 1;
          }
LABEL_18:
          __break(0x5519u);
          return result;
        }
LABEL_17:
        __break(0x5513u);
        goto LABEL_18;
      }
    }
  }
  return result;
}

unint64_t *X509ExtensionParseMFI4Properties(unint64_t *result, _QWORD *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v4 = *result;
  v3 = result[1];
  v5 = v3 - *result;
  if (v5 != 32)
    return (unint64_t *)(v5 == 32);
  if (a3)
  {
    if (v4 > v3)
    {
LABEL_12:
      __break(0x5519u);
      goto LABEL_13;
    }
    *a3 = v4;
    a3[1] = 32;
  }
  *a2 |= 0xC00000000uLL;
  if (v4 < 0xFFFFFFFFFFFFFFE0)
  {
    v6 = v4 + 32;
    if (v4 + 32 <= v3 && v4 <= v6)
    {
      *result = v6;
      return (unint64_t *)(v5 == 32);
    }
    goto LABEL_12;
  }
LABEL_13:
  __break(0x5513u);
  return result;
}

uint64_t X509ChainGetCertificateUsingKeyIdentifier(uint64_t *a1, uint64_t a2)
{
  uint64_t i;

  for (i = *a1; i; i = *(_QWORD *)(i + 272))
  {
    if (*(_QWORD *)(i + 192) && !compare_octet_string(a2, i + 184))
      break;
  }
  return i;
}

uint64_t X509ChainBuildPathPartial(_QWORD *a1, uint64_t *a2, _QWORD *a3, int a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t CertificateUsingKeyIdentifier;
  _QWORD *v12;
  _QWORD *v13;
  int v14;
  uint64_t BAARootUsingKeyIdentifier;
  unsigned int v16;

  if (!a1)
    return 327691;
  v7 = a1;
  *a3 = a1;
  a3[1] = a1 + 36;
  a1[36] = 0;
  a1[37] = a3;
  v8 = (uint64_t)(a1 + 15);
  result = compare_octet_string((uint64_t)(a1 + 15), (uint64_t)(a1 + 13));
  if ((_DWORD)result)
  {
    while (1)
    {
      v10 = (uint64_t)(v7 + 21);
      if (!v7[22]
        || (CertificateUsingKeyIdentifier = X509ChainGetCertificateUsingKeyIdentifier(a2, (uint64_t)(v7 + 21))) == 0
        || (v7 = (_QWORD *)CertificateUsingKeyIdentifier,
            compare_octet_string(CertificateUsingKeyIdentifier + 104, v8)))
      {
        v7 = (_QWORD *)*a2;
        if (!*a2)
        {
LABEL_16:
          if (X509ChainGetAppleRootUsingKeyIdentifier(v10, 1))
            return 0;
          BAARootUsingKeyIdentifier = X509ChainGetBAARootUsingKeyIdentifier(v10);
          if (a4)
            v16 = 0;
          else
            v16 = 524296;
          if (BAARootUsingKeyIdentifier)
            return 0;
          else
            return v16;
        }
        while (compare_octet_string(v8, (uint64_t)(v7 + 13)))
        {
          v7 = (_QWORD *)v7[34];
          if (!v7)
            goto LABEL_16;
        }
      }
      v12 = (_QWORD *)*a3;
      if (*a3)
        break;
LABEL_13:
      v13 = (_QWORD *)a3[1];
      v7[36] = 0;
      v7[37] = v13;
      *v13 = v7;
      a3[1] = v7 + 36;
      v8 = (uint64_t)(v7 + 15);
      v14 = compare_octet_string((uint64_t)(v7 + 15), (uint64_t)(v7 + 13));
      result = 0;
      if (!v14)
        return result;
    }
    while (v12 != v7)
    {
      v12 = (_QWORD *)v12[36];
      if (!v12)
        goto LABEL_13;
    }
    return 524297;
  }
  return result;
}

uint64_t X509ChainGetAppleRootUsingKeyIdentifier(uint64_t result, int a2)
{
  _BYTE *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *i;
  uint64_t v7;

  v2 = &numAppleRoots;
  if (!a2)
    v2 = &numAppleProdRoots;
  v3 = *v2;
  if (*v2)
  {
    v4 = result;
    for (i = (uint64_t *)&AppleRoots; i < (uint64_t *)&BlockedYonkersSPKI && i >= (uint64_t *)&AppleRoots; ++i)
    {
      v7 = *i;
      result = compare_octet_string(v4, *i + 184);
      if (!(_DWORD)result)
        return v7;
      if (!--v3)
        return 0;
    }
    __break(0x5519u);
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t X509ChainGetBAARootUsingKeyIdentifier(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t *i;
  uint64_t v5;

  v1 = numBAARoots;
  if (numBAARoots)
  {
    v2 = result;
    for (i = (uint64_t *)&BAARoots; i < (uint64_t *)&rsaEncryption && i >= (uint64_t *)&BAARoots; ++i)
    {
      v5 = *i;
      result = compare_octet_string(v2, *i + 184);
      if (!(_DWORD)result)
        return v5;
      if (!--v1)
        return 0;
    }
    __break(0x5519u);
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t X509ChainBuildPath(_QWORD *a1, uint64_t *a2, _QWORD *a3)
{
  return X509ChainBuildPathPartial(a1, a2, a3, 0);
}

uint64_t X509ChainCheckPathWithOptions(char a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  unint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char v16;
  unint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t AppleRootUsingKeyIdentifier;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t *v31;
  uint64_t *v32;
  char v33;
  unint64_t v34[2];
  unint64_t v35[5];

  v6 = a2;
  v35[4] = *MEMORY[0x1E0C80C00];
  v8 = *a2;
  if (a3)
  {
    v9 = *(_QWORD *)(a3 + 48);
    if (v9)
    {
      if (*(_QWORD *)(v9 + 8))
      {
        if (compare_octet_string(v9, v8 + 208))
          return 327701;
        v8 = *v6;
      }
    }
  }
  if (v8)
  {
    v31 = v6;
    v32 = a4;
    v11 = 0;
    v12 = 0;
    v33 = 0;
    v13 = -1;
    while (1)
    {
      v14 = *(_QWORD *)(v8 + 288);
      v15 = v14 + 304;
      if (v14)
      {
LABEL_10:
        v16 = 0;
        goto LABEL_11;
      }
      if (!compare_octet_string(v8 + 120, v8 + 104))
      {
        v16 = 0;
        v15 = v8 + 304;
        v14 = v8;
        goto LABEL_11;
      }
      if (!a3)
        return v12 | 0x9000Du;
      if (*(_BYTE *)(a3 + 16))
      {
        AppleRootUsingKeyIdentifier = X509ChainGetAppleRootUsingKeyIdentifier(v8 + 168, *(unsigned __int8 *)(a3 + 17));
      }
      else
      {
        if (!*(_QWORD *)(a3 + 24))
          goto LABEL_58;
        AppleRootUsingKeyIdentifier = X509ChainGetBAARootUsingKeyIdentifier(v8 + 168);
      }
      v14 = AppleRootUsingKeyIdentifier;
      v33 |= AppleRootUsingKeyIdentifier != 0;
      v15 = AppleRootUsingKeyIdentifier + 304;
      if (AppleRootUsingKeyIdentifier)
        goto LABEL_10;
LABEL_58:
      if (!*(_BYTE *)(a3 + 19))
        return v12 | 0x9000Du;
      v14 = 0;
      v16 = 1;
LABEL_11:
      if (v11 && *(_QWORD *)(v8 + 32) >= 2uLL)
      {
        if (!*(_BYTE *)(v8 + 265))
        {
          v30 = 589825;
          return v12 | v30;
        }
        if ((*(_BYTE *)(v8 + 264) & 4) == 0)
        {
          v30 = 589826;
          return v12 | v30;
        }
      }
      v17 = *(_QWORD *)(v8 + 200);
      if (v17)
        v18 = v17 >= v11;
      else
        v18 = 1;
      if (!v18)
      {
        v30 = 589827;
        return v12 | v30;
      }
      if (*(_BYTE *)(v8 + 266))
      {
        v30 = 589831;
        return v12 | v30;
      }
      if (compare_octet_string(v8 + 40, v8 + 152))
      {
        v30 = 589828;
        return v12 | v30;
      }
      if ((v16 & 1) == 0 && *(_QWORD *)(v8 + 168) && *(_QWORD *)(v8 + 176))
      {
        if (v14 >= v15)
          goto LABEL_100;
        if (compare_octet_string(v8 + 168, v14 + 184))
          return v12 | 0x9000Au;
      }
      if (a3 && v11 && (*(_QWORD *)(v8 + 240) & *(_QWORD *)(a3 + 8)) == 0)
        X509PolicySetFlagsForCommonNames(v8);
      if (v14 == v8 && !*(_QWORD *)(v8 + 240))
      {
        X509PolicySetFlagsForRoots(a3, v8);
        if (a3)
        {
LABEL_34:
          if (*(_BYTE *)(a3 + 18) && !X509CertificateIsValid(v8))
            return v12 | 0x90009u;
          v19 = *(_QWORD *)(a3 + 8);
          if (!v11 && (*(_QWORD *)(v8 + 240) & v19) == 0)
          {
            X509PolicySetFlagsForMFI(v8);
            v19 = *(_QWORD *)(a3 + 8);
          }
          v13 &= *(_QWORD *)(v8 + 240);
          if (v19 && (v19 & v13) == 0)
          {
            v30 = 589829;
            return v12 | v30;
          }
          goto LABEL_49;
        }
      }
      else if (a3)
      {
        goto LABEL_34;
      }
      v13 &= *(_QWORD *)(v8 + 240);
LABEL_49:
      a1 |= v14 == v8;
      if ((v16 & 1) == 0)
      {
        if (v14 >= v15)
          goto LABEL_100;
        result = X509CertificateCheckSignature(a1, v14, v8 + 16, v8 + 40, (__int128 *)(v8 + 56));
        if ((_DWORD)result)
          return result;
      }
      v21 = v11 + 1;
      if (v11 == -1)
        goto LABEL_99;
      v8 = *(_QWORD *)(v8 + 288);
      v12 += 256;
      ++v11;
      if (!v8)
      {
        v6 = v31;
        a4 = v32;
        LOBYTE(v8) = v33;
        if (a3)
          goto LABEL_61;
        goto LABEL_87;
      }
    }
  }
  v21 = 0;
  v13 = -1;
  if (!a3)
    goto LABEL_87;
LABEL_61:
  if (*(_QWORD *)a3)
  {
    v22 = v21;
    if ((v8 & 1) != 0)
    {
      v22 = v21 + 1;
      if (v21 == -1)
      {
LABEL_99:
        __break(0x5500u);
LABEL_100:
        __break(0x5519u);
      }
    }
    if (*(_QWORD *)a3 != v22)
      return ((_DWORD)v22 << 8) | 0x90006u;
  }
  v23 = *(_QWORD *)(a3 + 24);
  if (!v23 || !*(_QWORD *)(v23 + 8))
  {
    if (!*(_BYTE *)(a3 + 16))
      goto LABEL_87;
    v24 = (_DWORD)v21 << 8;
    v25 = **(_QWORD **)(v6[1] + 8);
LABEL_75:
    v27 = 184;
    if ((v8 & 1) != 0)
      v27 = 168;
    v28 = X509ChainGetAppleRootUsingKeyIdentifier(v25 + v27, *(unsigned __int8 *)(a3 + 17));
    if (!v28)
      return v24 | 0x9000Bu;
    v29 = v28;
    if ((v8 & 1) == 0 && !compare_octet_string(v25 + 88, v28 + 88)
      || !X509CertificateCheckSignature(29, v29, v25 + 16, v25 + 40, (__int128 *)(v25 + 56)))
    {
      goto LABEL_87;
    }
    v26 = 589836;
    return v24 | v26;
  }
  v24 = (_DWORD)v21 << 8;
  v25 = **(_QWORD **)(v6[1] + 8);
  if (*(_BYTE *)(a3 + 16))
    goto LABEL_75;
  memset(v35, 170, 32);
  v34[0] = 0xAAAAAAAAAAAAAAAALL;
  v34[1] = 0xAAAAAAAAAAAAAAAALL;
  if (X509CertificateParseSPKI((unint64_t *)(v25 + 88), &v35[2], v34, v35))
  {
LABEL_72:
    v26 = 589832;
    return v24 | v26;
  }
  if (compare_octet_string((uint64_t)&v35[2], *(_QWORD *)(a3 + 32))
    || compare_octet_string((uint64_t)v35, *(_QWORD *)(a3 + 24)))
  {
    if (X509CertificateCheckSignatureWithPublicKey(*(uint64_t **)(a3 + 24), *(_QWORD *)(a3 + 32), *(__int128 **)(a3 + 40), v25 + 16, (__int128 *)(v25 + 40), (__int128 *)(v25 + 56)))goto LABEL_72;
  }
  else if (!compare_octet_string(*(_QWORD *)(a3 + 32), (uint64_t)&ecPublicKey_0))
  {
    compare_octet_string((uint64_t)v34, *(_QWORD *)(a3 + 40));
  }
LABEL_87:
  result = 0;
  if (a4)
    *a4 = v13;
  return result;
}

uint64_t DERParseBoolean(unsigned __int8 **a1, BOOL *a2)
{
  int v2;
  uint64_t result;

  if (a1[1] != (unsigned __int8 *)1)
    return 3;
  v2 = **a1;
  if (v2 != 255 && v2 != 0)
    return 3;
  result = 0;
  *a2 = v2 != 0;
  return result;
}

uint64_t DERDecodeSequenceWithBlock(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v4[4];

  v4[3] = *MEMORY[0x1E0C80C00];
  memset(v4, 170, 24);
  result = DERDecodeItemPartialBufferGetLength(a1, v4, 0);
  if (!(_DWORD)result)
  {
    if (v4[0] - 0x2000000000000012 >= 0xFFFFFFFFFFFFFFFELL)
      return DERDecodeSequenceContentWithBlock(&v4[1], a2);
    else
      return 2;
  }
  return result;
}

uint64_t DERDecodeSequenceContentWithBlock(unint64_t *a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t result;
  char v7;
  unint64_t v8[3];
  unint64_t v9[3];

  v9[2] = *MEMORY[0x1E0C80C00];
  v9[0] = 0;
  v2 = *a1;
  v3 = a1[1];
  if (__CFADD__(*a1, v3))
  {
    __break(0x5513u);
LABEL_13:
    __break(0x5519u);
  }
  v4 = v2 + v3;
  if (v2 > v4)
    goto LABEL_13;
  v9[0] = *a1;
  v9[1] = v4;
  memset(v8, 170, sizeof(v8));
  v7 = 0;
  while (1)
  {
    LODWORD(result) = DERDecodeSeqNext(v9, v8);
    if ((_DWORD)result)
      break;
    LODWORD(result) = (*(uint64_t (**)(uint64_t, unint64_t *, char *))(a2 + 16))(a2, v8, &v7);
    if ((_DWORD)result)
      break;
    if (v7)
      return 0;
  }
  if (result <= 1)
    return 0;
  else
    return result;
}

void *SFSQLiteJournalSuffixes()
{
  return &unk_1E1FFEDB8;
}

void sub_18A950FB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18A952080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getLSApplicationWorkspaceClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;
  void *v4;
  void *v5;

  if (!MobileCoreServicesLibraryCore_frameworkLibrary)
    MobileCoreServicesLibraryCore_frameworkLibrary = _sl_dlopen();
  if (!MobileCoreServicesLibraryCore_frameworkLibrary)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *MobileCoreServicesLibrary(void)");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("SecTapToRadar.m"), 35, CFSTR("%s"), 0);

    goto LABEL_8;
  }
  result = objc_getClass("LSApplicationWorkspace");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getLSApplicationWorkspaceClass(void)_block_invoke");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v5, CFSTR("SecTapToRadar.m"), 36, CFSTR("Unable to find class %s"), "LSApplicationWorkspace");

LABEL_8:
    __break(1u);
  }
  getLSApplicationWorkspaceClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_18A953AE8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void LKAReportKeychainUpgradeOutcome(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  void *v7;

  v6 = (void *)MEMORY[0x18D770A24]();
  +[SFAnalytics logger](LocalKeychainAnalytics, "logger");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "reportKeychainUpgradeFrom:to:outcome:error:", a1, a2, a3, 0);

  objc_autoreleasePoolPop(v6);
}

void LKAReportKeychainUpgradeOutcomeWithError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  void *v9;

  v8 = (void *)MEMORY[0x18D770A24]();
  +[SFAnalytics logger](LocalKeychainAnalytics, "logger");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "reportKeychainUpgradeFrom:to:outcome:error:", a1, a2, a3, a4);

  objc_autoreleasePoolPop(v8);
}

void LKABackupReportStart(int a1, int a2, char a3)
{
  uint64_t v3;
  unsigned int v4;
  void *v5;
  void *v6;

  if ((a3 & 1) != 0)
  {
    v3 = 4;
  }
  else if (a1 && (a2 & 1) != 0)
  {
    v3 = 3;
  }
  else
  {
    if (a2)
      v4 = 2;
    else
      v4 = 0;
    if (a1)
      v3 = 1;
    else
      v3 = v4;
  }
  v5 = (void *)MEMORY[0x18D770A24]();
  +[SFAnalytics logger](LocalKeychainAnalytics, "logger");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "reportKeychainBackupStartWithType:", v3);

  objc_autoreleasePoolPop(v5);
}

void LKABackupReportEnd(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  v4 = (void *)MEMORY[0x18D770A24]();
  +[SFAnalytics logger](LocalKeychainAnalytics, "logger");
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "reportKeychainBackupEnd:error:", a1, a2);

  objc_autoreleasePoolPop(v4);
}

void LKAForceClose()
{
  void *v0;
  void *v1;

  v0 = (void *)MEMORY[0x18D770A24]();
  +[SFAnalytics logger](LocalKeychainAnalytics, "logger");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "removeState");

  objc_autoreleasePoolPop(v0);
}

unint64_t __sec_experiment_host_hash_block_invoke()
{
  unint64_t result;
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  timespec v4;
  uuid_t uu;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v4.tv_sec = 0;
  v4.tv_nsec = 0;
  memset(uu, 0, sizeof(uu));
  result = gethostuuid(uu, &v4);
  if ((_DWORD)result)
  {
    sec_experiment_host_hash_onceToken = 0;
  }
  else
  {
    uuid_unparse(uu, sec_experiment_host_hash_hostuuid);
    result = strlen(sec_experiment_host_hash_hostuuid);
    if (result)
    {
      v1 = 0;
      v2 = 0;
      do
        v2 = sec_experiment_host_hash_hostuuid[v1++] - v2 + 32 * v2;
      while (result > v1);
      v3 = v2 % 0x65;
    }
    else
    {
      v3 = 0;
    }
    sec_experiment_host_hash_hash = v3;
  }
  return result;
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{

}

SecExpConcrete_sec_experiment *sec_experiment_create(uint64_t a1)
{
  return -[SecExpConcrete_sec_experiment initWithName:]([SecExpConcrete_sec_experiment alloc], "initWithName:", a1);
}

uint64_t sec_experiment_set_sampling_disabled(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 8), "setSamplingDisabled:", a2);
}

uint64_t sec_experiment_copy_configuration(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  id v10;
  int v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = (void *)objc_msgSend(v1, "copyExperimentConfiguration");
    v4 = v3;
    if (v3)
    {
      objc_msgSend(v3, "configurationData");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      if ((objc_msgSend(v2, "isSamplingDisabled") & 1) != 0 || objc_msgSend(v4, "isSampled"))
      {
        v6 = _CFXPCCreateXPCObjectFromCFObject();
      }
      else
      {
        sec_experiment_copy_log_handle();
        v7 = objc_claimAutoreleasedReturnValue();
        v8 = v7;
        if (v7 && os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
          v9 = objc_msgSend(v2, "name");
          objc_msgSend(v4, "identifier");
          v10 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
          v12 = 136446466;
          v13 = v9;
          v14 = 2082;
          v15 = objc_msgSend(v10, "UTF8String");
          _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_INFO, "Configuration '%{public}s' for experiment '%{public}s' not sampled to run", (uint8_t *)&v12, 0x16u);

        }
        v6 = 0;
      }

    }
    else
    {
      v6 = 0;
    }

  }
  else
  {
    v6 = 0;
  }

  return v6;
}

id sec_experiment_copy_log_handle()
{
  if (sec_experiment_copy_log_handle_onceToken != -1)
    dispatch_once(&sec_experiment_copy_log_handle_onceToken, &__block_literal_global_156);
  return (id)sec_experiment_copy_log_handle_experiment_log;
}

void __sec_experiment_copy_log_handle_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.security", "experiment");
  v1 = (void *)sec_experiment_copy_log_handle_experiment_log;
  sec_experiment_copy_log_handle_experiment_log = (uint64_t)v0;

}

uint64_t sec_experiment_run_internal(void *a1, int a2, void *a3, void *a4, void *a5, int a6)
{
  id v11;
  NSObject *v12;
  id v13;
  id v14;
  uint64_t v15;
  NSObject *v16;
  void (**v17)(_QWORD);
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  const char *v21;
  NSObject *v22;
  NSObject *v23;
  uint64_t v24;
  const char *v25;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(uint64_t);
  void *v30;
  NSObject *v31;
  id v32;
  id v33;
  char v34;
  uint8_t buf[4];
  uint64_t v36;
  __int16 v37;
  const char *v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v11 = a1;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  if (v13)
  {
    v15 = objc_msgSend(v11, "experimentIsAllowedForProcess");
    if ((v15 & 1) != 0)
    {
      v27 = MEMORY[0x1E0C809B0];
      v28 = 3221225472;
      v29 = __sec_experiment_run_internal_block_invoke;
      v30 = &unk_1E1FCB8B0;
      v16 = v11;
      v31 = v16;
      v34 = a2;
      v32 = v13;
      v33 = v14;
      v17 = (void (**)(_QWORD))_Block_copy(&v27);
      sec_experiment_copy_log_handle();
      v18 = objc_claimAutoreleasedReturnValue();
      v19 = v18;
      if (!v12 || a6)
      {
        if (v18 && os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          v24 = -[NSObject name](v16, "name", v27, v28, v29, v30);
          v25 = "enabled";
          if (a2)
            v25 = "disabled";
          *(_DWORD *)buf = 136315394;
          v36 = v24;
          v37 = 2080;
          v38 = v25;
          _os_log_impl(&dword_18A900000, v19, OS_LOG_TYPE_INFO, "Starting experiment '%s' synchronously with sampling %s", buf, 0x16u);
        }

        v17[2](v17);
      }
      else
      {
        if (v18 && os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          v20 = -[NSObject name](v16, "name", v27, v28, v29, v30);
          v21 = "enabled";
          if (a2)
            v21 = "disabled";
          *(_DWORD *)buf = 136315394;
          v36 = v20;
          v37 = 2080;
          v38 = v21;
          _os_log_impl(&dword_18A900000, v19, OS_LOG_TYPE_INFO, "Starting experiment '%s' asynchronously with sampling %s", buf, 0x16u);
        }

        dispatch_async(v12, v17);
      }

      v23 = v31;
    }
    else
    {
      sec_experiment_copy_log_handle();
      v22 = objc_claimAutoreleasedReturnValue();
      v23 = v22;
      if (v22 && os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v23, OS_LOG_TYPE_INFO, "Not running experiments for disallowed process", buf, 2u);
      }
    }

  }
  else
  {
    v15 = 0;
  }

  return v15;
}

void __sec_experiment_run_internal_block_invoke(uint64_t a1)
{
  int v2;
  void *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  const char *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v2 = objc_msgSend(*(id *)(a1 + 32), "isSamplingDisabledWithDefault:", *(unsigned __int8 *)(a1 + 56));
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 8), "setSamplingDisabled:", objc_msgSend(*(id *)(a1 + 32), "isSamplingDisabledWithDefault:", *(unsigned __int8 *)(a1 + 56)));
  v3 = (void *)sec_experiment_copy_configuration(*(void **)(a1 + 32));
  v4 = objc_msgSend(*(id *)(a1 + 32), "identifier");
  if (v3)
  {
    ++*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16);
    if ((*(unsigned int (**)(void))(*(_QWORD *)(a1 + 40) + 16))())
    {
      ++*(_QWORD *)(*(_QWORD *)(a1 + 32) + 24);
      sec_experiment_copy_log_handle();
      v5 = objc_claimAutoreleasedReturnValue();
      v6 = v5;
      if (!v5 || !os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
        goto LABEL_17;
      v7 = objc_msgSend(*(id *)(a1 + 32), "name");
      v16 = 136315394;
      v17 = v4;
      v18 = 2080;
      v19 = v7;
      v8 = "Configuration '%s' for experiment '%s' succeeded";
    }
    else
    {
      sec_experiment_copy_log_handle();
      v14 = objc_claimAutoreleasedReturnValue();
      v6 = v14;
      if (!v14 || !os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        goto LABEL_17;
      v15 = objc_msgSend(*(id *)(a1 + 32), "name");
      v16 = 136315394;
      v17 = v4;
      v18 = 2080;
      v19 = v15;
      v8 = "Configuration '%s' for experiment '%s' failed";
    }
    _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_INFO, v8, (uint8_t *)&v16, 0x16u);
LABEL_17:

    goto LABEL_18;
  }
  sec_experiment_copy_log_handle();
  v9 = objc_claimAutoreleasedReturnValue();
  v10 = v9;
  if (v9 && os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    v11 = objc_msgSend(*(id *)(a1 + 32), "name");
    v12 = "enabled";
    v16 = 136315650;
    v17 = v4;
    v18 = 2080;
    if (v2)
      v12 = "disabled";
    v19 = v11;
    v20 = 2080;
    v21 = v12;
    _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_INFO, "Configuration '%s' for experiment '%s' not configured to run with sampling %s", (uint8_t *)&v16, 0x20u);
  }

  v13 = *(_QWORD *)(a1 + 48);
  if (v13)
    (*(void (**)(uint64_t, uint64_t))(v13 + 16))(v13, objc_msgSend(*(id *)(a1 + 32), "identifier"));
LABEL_18:

}

uint64_t sec_experiment_run(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  SecExpConcrete_sec_experiment *v7;
  SecExpConcrete_sec_experiment *v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  v7 = -[SecExpConcrete_sec_experiment initWithName:]([SecExpConcrete_sec_experiment alloc], "initWithName:", a1);
  v8 = v7;
  if (v7)
  {
    v9 = sec_experiment_run_internal(v7, 0, 0, v5, v6, 1);
  }
  else
  {
    sec_experiment_copy_log_handle();
    v10 = objc_claimAutoreleasedReturnValue();
    v11 = v10;
    if (v10 && os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      v13 = 136315138;
      v14 = a1;
      _os_log_impl(&dword_18A900000, v11, OS_LOG_TYPE_INFO, "Experiment '%s' not found", (uint8_t *)&v13, 0xCu);
    }

    v9 = 0;
  }

  return v9;
}

uint64_t sec_experiment_run_async(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  SecExpConcrete_sec_experiment *v10;
  SecExpConcrete_sec_experiment *v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  int v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = -[SecExpConcrete_sec_experiment initWithName:]([SecExpConcrete_sec_experiment alloc], "initWithName:", a1);
  v11 = v10;
  if (v10)
  {
    v12 = sec_experiment_run_internal(v10, 0, v7, v8, v9, 0);
  }
  else
  {
    sec_experiment_copy_log_handle();
    v13 = objc_claimAutoreleasedReturnValue();
    v14 = v13;
    if (v13 && os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v16 = 136315138;
      v17 = a1;
      _os_log_impl(&dword_18A900000, v14, OS_LOG_TYPE_INFO, "Experiment '%s' not found", (uint8_t *)&v16, 0xCu);
    }

    v12 = 0;
  }

  return v12;
}

uint64_t sec_experiment_run_with_sampling_disabled(uint64_t a1, void *a2, void *a3, int a4)
{
  id v7;
  id v8;
  SecExpConcrete_sec_experiment *v9;
  SecExpConcrete_sec_experiment *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v8 = a3;
  v9 = -[SecExpConcrete_sec_experiment initWithName:]([SecExpConcrete_sec_experiment alloc], "initWithName:", a1);
  v10 = v9;
  if (v9)
  {
    v11 = sec_experiment_run_internal(v9, a4, 0, v7, v8, 1);
  }
  else
  {
    sec_experiment_copy_log_handle();
    v12 = objc_claimAutoreleasedReturnValue();
    v13 = v12;
    if (v12 && os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      v15 = 136315138;
      v16 = a1;
      _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_INFO, "Experiment '%s' not found", (uint8_t *)&v15, 0xCu);
    }

    v11 = 0;
  }

  return v11;
}

uint64_t sec_experiment_run_async_with_sampling_disabled(uint64_t a1, void *a2, void *a3, void *a4, int a5)
{
  id v9;
  id v10;
  id v11;
  SecExpConcrete_sec_experiment *v12;
  SecExpConcrete_sec_experiment *v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  int v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v9 = a2;
  v10 = a3;
  v11 = a4;
  v12 = -[SecExpConcrete_sec_experiment initWithName:]([SecExpConcrete_sec_experiment alloc], "initWithName:", a1);
  v13 = v12;
  if (v12)
  {
    v14 = sec_experiment_run_internal(v12, a5, v9, v10, v11, 0);
  }
  else
  {
    sec_experiment_copy_log_handle();
    v15 = objc_claimAutoreleasedReturnValue();
    v16 = v15;
    if (v15 && os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      v18 = 136315138;
      v19 = a1;
      _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_INFO, "Experiment '%s' not found", (uint8_t *)&v18, 0xCu);
    }

    v14 = 0;
  }

  return v14;
}

id CKKSSetupControlProtocol(void *a1)
{
  id v1;

  v1 = a1;
  if (CKKSSetupControlProtocol_onceToken != -1)
    dispatch_once(&CKKSSetupControlProtocol_onceToken, &__block_literal_global_443);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_rpcResetLocal_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_rpcResetCloudKit_reason_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_rpcResync_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_rpcResyncLocal_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_rpcStatus_fast_waitForNonTransientState_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_rpcFetchAndProcessChanges_classA_onlyIfNoRecentFetch_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_rpcPushOutgoingChanges_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_rpcGetCKDeviceIDWithReply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_rpcCKMetric_attributes_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_proposeTLKForSEView_proposedTLK_wrappedOldTLK_tlkShares_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_fetchSEViewKeyHierarchy_forceFetch_reply_, 3, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_modifyTLKSharesForSEView_adding_deleting_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_deleteSEView_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_errClasses, sel_pcsMirrorKeysForServices_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_tlkShareArrayClasses, sel_proposeTLKForSEView_proposedTLK_wrappedOldTLK_tlkShares_reply_, 3, 0);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_tlkArrayClasses, sel_fetchSEViewKeyHierarchy_forceFetch_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_tlkShareArrayClasses, sel_fetchSEViewKeyHierarchy_forceFetch_reply_, 2, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_tlkShareArrayClasses, sel_modifyTLKSharesForSEView_adding_deleting_reply_, 1, 0);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", CKKSSetupControlProtocol_tlkShareArrayClasses, sel_modifyTLKSharesForSEView_adding_deleting_reply_, 2, 0);
  return v1;
}

void sub_18A955FF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9)
{
  id v9;
  NSObject *v10;

  if (a2 == 1)
  {
    v9 = objc_begin_catch(exception_object);
    secLogObjForScope("SecError");
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(a9) = 138412290;
      *(_QWORD *)((char *)&a9 + 4) = v9;
      _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, "CKKSSetupControlProtocol failed, continuing, but you might crash later: %@", (uint8_t *)&a9, 0xCu);
    }

    objc_exception_throw(objc_retainAutorelease(v9));
  }
  _Unwind_Resume(exception_object);
}

void *__initCloudKit_block_invoke()
{
  void *result;

  result = dlopen("/System/Library/Frameworks/CloudKit.framework/CloudKit", 1);
  cloudKit = (uint64_t)result;
  return result;
}

id _OctagonSignpostLogSystem()
{
  if (_OctagonSignpostLogSystem_onceToken != -1)
    dispatch_once(&_OctagonSignpostLogSystem_onceToken, &__block_literal_global_570);
  return (id)_OctagonSignpostLogSystem_log;
}

os_signpost_id_t _OctagonSignpostCreate(NSObject *a1)
{
  os_signpost_id_t v1;

  v1 = os_signpost_id_generate(a1);
  mach_continuous_time();
  return v1;
}

unint64_t _OctagonSignpostGetNanoseconds(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;

  if (_OctagonSignpostGetNanoseconds_onceToken != -1)
    dispatch_once(&_OctagonSignpostGetNanoseconds_onceToken, &__block_literal_global_3);
  v3 = mach_continuous_time();
  LODWORD(v4) = _OctagonSignpostGetNanoseconds_timebase_info;
  LODWORD(v5) = *(_DWORD *)algn_1EDF7ADF4;
  return (unint64_t)((double)v4 / (double)v5 * (double)(v3 - a2));
}

uint64_t SecFrameworkGetBundle()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecFrameworkGetBundle_block_invoke;
  block[3] = &__block_descriptor_tmp;
  block[4] = &SecFrameworkGetBundle_sSecFrameworkGetBundleSingleton;
  if (SecFrameworkGetBundle_sSecFrameworkGetBundleOnce != -1)
    dispatch_once(&SecFrameworkGetBundle_sSecFrameworkGetBundleOnce, block);
  return SecFrameworkGetBundle_sSecFrameworkGetBundleSingleton;
}

uint64_t SecFrameworkIsRunningInXcode()
{
  if (SecFrameworkIsRunningInXcode_envCheckOnce != -1)
    dispatch_once(&SecFrameworkIsRunningInXcode_envCheckOnce, &__block_literal_global_710);
  return SecFrameworkIsRunningInXcode_runningInXcode;
}

__int128 *SecSecurityFixUpClientWithPersona(__int128 *result, uint64_t a2)
{
  __int128 v2;
  __int128 v3;
  __int128 v4;
  uint64_t (*v5)(uint64_t);

  v2 = result[3];
  v3 = *result;
  v4 = result[1];
  *(_OWORD *)(a2 + 32) = result[2];
  *(_OWORD *)(a2 + 48) = v2;
  *(_OWORD *)a2 = v3;
  *(_OWORD *)(a2 + 16) = v4;
  *(_QWORD *)(a2 + 24) = 0;
  if (gSecurityd)
  {
    v5 = *(uint64_t (**)(uint64_t))(gSecurityd + 688);
    if (v5)
      return (__int128 *)v5(a2);
  }
  return result;
}

uint64_t SecSecuritySetMusrMode(char a1, int a2, int a3)
{
  uint64_t result;
  uint64_t v7;

  SecSecurityClientGet();
  BYTE4(xmmword_1ECD358F0) = a1;
  DWORD1(xmmword_1ECD358E0) = a2;
  result = threadLocalClient(&threadLocalClient);
  *(_BYTE *)(result + 36) = a1;
  *(_DWORD *)(result + 20) = a2;
  *(_DWORD *)(v7 + 20) = a3;
  *(_DWORD *)(result + 40) = a3;
  return result;
}

void SecSecuritySetPersonaMusr(const __CFString *a1)
{
  uint64_t v2;
  const void *v3;
  const __CFUUID *v4;
  const __CFUUID *v5;
  CFUUIDBytes v6;

  if (BYTE4(xmmword_1ECD358F0))
    goto LABEL_8;
  v2 = SecSecurityClientGet();
  v3 = *(const void **)(v2 + 24);
  if (v3)
  {
    *(_QWORD *)(v2 + 24) = 0;
    CFRelease(v3);
  }
  *(_BYTE *)(v2 + 56) = a1 != 0;
  if (a1)
  {
    v4 = CFUUIDCreateFromString(0, a1);
    if (v4)
    {
      v5 = v4;
      v6 = CFUUIDGetUUIDBytes(v4);
      CFRelease(v5);
      *(_QWORD *)(v2 + 24) = CFDataCreate(0, &v6.byte0, 16);
      return;
    }
LABEL_8:
    abort();
  }
}

uint64_t SecAccessGroupsGetCurrent()
{
  return *(_QWORD *)(SecSecurityClientGet() + 8);
}

void SecAccessGroupsSetCurrent(const void *a1)
{
  NSObject *v2;
  NSObject *v3;
  const void *v4;
  NSObject *v5;
  uint64_t v6;
  const void *v7;
  NSObject *v8;
  int v9;
  const void *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = secLogObjForScope("thread-local-client-debug");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v9 = 138412290;
    v10 = a1;
    _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "SecAccessGroupsSetCurrent begin! Setting access groups: %@", (uint8_t *)&v9, 0xCu);
  }
  SecSecurityClientGet();
  v3 = secLogObjForScope("thread-local-client-debug");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "SecAccessGroupsSetCurrent releasing gClient access groups", (uint8_t *)&v9, 2u);
  }
  v4 = (const void *)*((_QWORD *)&gClient + 1);
  if (*((_QWORD *)&gClient + 1))
  {
    *((_QWORD *)&gClient + 1) = 0;
    CFRelease(v4);
  }
  v5 = secLogObjForScope("thread-local-client-debug");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "SecAccessGroupsSetCurrent releasing threadLocalClient access groups", (uint8_t *)&v9, 2u);
  }
  v6 = threadLocalClient(&threadLocalClient);
  v7 = *(const void **)(v6 + 8);
  if (v7)
  {
    *(_QWORD *)(v6 + 8) = 0;
    CFRelease(v7);
  }
  if (a1)
  {
    CFRetain(a1);
    *((_QWORD *)&gClient + 1) = a1;
    CFRetain(a1);
  }
  else
  {
    *((_QWORD *)&gClient + 1) = 0;
  }
  *(_QWORD *)(v6 + 8) = a1;
  v8 = secLogObjForScope("thread-local-client-debug");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "SecAccessGroupsSetCurrent end!", (uint8_t *)&v9, 2u);
  }
}

uint64_t SecSecurityClientRegularToAppClip()
{
  uint64_t result;
  char v1;

  SecSecurityClientGet();
  BYTE12(xmmword_1ECD358F0) = 1;
  result = threadLocalClient(&threadLocalClient);
  *(_BYTE *)(result + 44) = v1;
  return result;
}

uint64_t SecSecurityClientAppClipToRegular()
{
  uint64_t result;

  SecSecurityClientGet();
  BYTE12(xmmword_1ECD358F0) = 0;
  result = threadLocalClient(&threadLocalClient);
  *(_BYTE *)(result + 44) = 0;
  return result;
}

void SecSecurityClientSetApplicationIdentifier(const void *a1)
{
  const void *v2;
  uint64_t v3;
  const void *v4;

  SecSecurityClientGet();
  v2 = (const void *)xmmword_1ECD35900;
  if ((_QWORD)xmmword_1ECD35900)
  {
    *(_QWORD *)&xmmword_1ECD35900 = 0;
    CFRelease(v2);
  }
  v3 = threadLocalClient(&threadLocalClient);
  v4 = *(const void **)(v3 + 48);
  if (v4)
  {
    *(_QWORD *)(v3 + 48) = 0;
    CFRelease(v4);
  }
  if (a1)
  {
    CFRetain(a1);
    *(_QWORD *)&xmmword_1ECD35900 = a1;
    CFRetain(a1);
  }
  else
  {
    *(_QWORD *)&xmmword_1ECD35900 = 0;
  }
  *(_QWORD *)(v3 + 48) = a1;
}

uint64_t SecSecurityClientSetKeychainSharingState(int a1)
{
  uint64_t result;
  char v3;
  char v4;

  result = SecSecurityClientGet();
  if (a1)
  {
    if (a1 != 1)
      return result;
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  BYTE9(xmmword_1ECD35900) = v3;
  result = threadLocalClient(&threadLocalClient);
  *(_BYTE *)(result + 57) = v4;
  return result;
}

void SecServerSetTrustdMachServiceName(const char *a1)
{
  void *v2;

  if (trustd_connection_once != -1)
    dispatch_once(&trustd_connection_once, &__block_literal_global_33);
  v2 = (void *)sTrustdConnection;
  sTrustdConnection = (uint64_t)securityd_create_connection(a1, -1);
  if (v2)
    xpc_release(v2);
}

_xpc_connection_s *__trustd_system_connection_block_invoke()
{
  _xpc_connection_s *result;

  result = securityd_create_connection("com.apple.trustd", -1);
  sTrustdSystemInstanceConnection = (uint64_t)result;
  return result;
}

const __CFBoolean *getBoolValue(const __CFDictionary *a1, const __CFString *a2)
{
  const __CFBoolean *result;
  const __CFBoolean *v4;
  CFTypeID v5;
  BOOL v6;
  CFTypeID v7;
  NSObject *v8;
  _BOOL4 v9;
  CFTypeID v10;
  const char *CStringPtr;
  const char *v12;
  int v13;
  CFTypeID v14;
  __int16 v15;
  const char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  result = (const __CFBoolean *)CFDictionaryGetValue(a1, a2);
  if (result)
  {
    v4 = result;
    v5 = CFGetTypeID(result);
    if (v5 == CFBooleanGetTypeID())
    {
      v6 = CFBooleanGetValue(v4) == 0;
      return (const __CFBoolean *)!v6;
    }
    v7 = CFGetTypeID(v4);
    if (v7 == CFNumberGetTypeID())
    {
      LOBYTE(v13) = 0;
      CFNumberGetValue(v4, kCFNumberCharType, &v13);
      v6 = v13 == 0;
      return (const __CFBoolean *)!v6;
    }
    v8 = secLogObjForScope("xpc");
    v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v9)
    {
      v10 = CFGetTypeID(v4);
      CStringPtr = CFStringGetCStringPtr(a2, 0x8000100u);
      v12 = "<null>";
      if (CStringPtr)
        v12 = CStringPtr;
      v13 = 134218242;
      v14 = v10;
      v15 = 2080;
      v16 = v12;
      _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "unexpected CF type (%lu) for key %s", (uint8_t *)&v13, 0x16u);
      return 0;
    }
  }
  return result;
}

uint64_t _SecSecuritydCopyWhoAmI(CFTypeRef *a1)
{
  xpc_object_t message;
  void *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  NSObject *v7;
  CFTypeRef v8;
  int v10;
  CFTypeRef v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  message = securityd_create_message(0x5Eu, a1);
  if (!message)
    return 0;
  v3 = message;
  v4 = securityd_message_with_reply_sync(message, (uint64_t)a1);
  if (v4)
  {
    v5 = (void *)v4;
    v6 = _CFXPCCreateCFObjectFromXPCObject();
    xpc_release(v5);
  }
  else
  {
    v7 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if (a1)
        v8 = *a1;
      else
        v8 = 0;
      v10 = 138412290;
      v11 = v8;
      _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "Securityd failed getting whoamid with error: %@", (uint8_t *)&v10, 0xCu);
    }
    v6 = 0;
  }
  xpc_release(v3);
  return v6;
}

BOOL _SecSyncBubbleTransfer(const __CFString *a1, unsigned int a2, CFTypeRef *a3)
{
  xpc_object_t message;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  void *v13;
  _BOOL8 v14;

  message = securityd_create_message(0x5Fu, a3);
  if (!message)
    return 0;
  v7 = message;
  xpc_dictionary_set_int64(message, "uid", a2);
  if (!SecXPCDictionarySetPListWithRepair(v7, "services", a1, (__CFString **)a3, v8, v9, v10, v11))
    return 0;
  v12 = (void *)securityd_message_with_reply_sync(v7, (uint64_t)a3);
  if (v12)
  {
    v13 = v12;
    v14 = xpc_dictionary_get_BOOL(v12, "status");
    if (!v14)
      securityd_message_no_error((uint64_t)v13, (CFErrorRef *)a3);
    xpc_release(v13);
  }
  else
  {
    v14 = 0;
  }
  xpc_release(v7);
  return v14;
}

BOOL _SecSystemKeychainTransfer(CFTypeRef *a1)
{
  xpc_object_t message;
  void *v3;
  void *v4;
  void *v5;
  _BOOL8 v6;

  message = securityd_create_message(0x60u, a1);
  if (!message)
    return 0;
  v3 = message;
  v4 = (void *)securityd_message_with_reply_sync(message, (uint64_t)a1);
  if (v4)
  {
    v5 = v4;
    v6 = xpc_dictionary_get_BOOL(v4, "status");
    if (!v6)
      securityd_message_no_error((uint64_t)v5, (CFErrorRef *)a1);
    xpc_release(v5);
  }
  else
  {
    v6 = 0;
  }
  xpc_release(v3);
  return v6;
}

BOOL _SecSystemKeychainTranscrypt(CFTypeRef *a1)
{
  xpc_object_t message;
  void *v3;
  void *v4;
  void *v5;
  _BOOL8 v6;

  message = securityd_create_message(0x61u, a1);
  if (!message)
    return 0;
  v3 = message;
  v4 = (void *)securityd_message_with_reply_sync(message, (uint64_t)a1);
  if (v4)
  {
    v5 = v4;
    v6 = xpc_dictionary_get_BOOL(v4, "status");
    if (!v6)
      securityd_message_no_error((uint64_t)v5, (CFErrorRef *)a1);
    xpc_release(v5);
  }
  else
  {
    v6 = 0;
  }
  xpc_release(v3);
  return v6;
}

BOOL _SecSyncDeleteUserViews(unsigned int a1, CFTypeRef *a2)
{
  xpc_object_t message;
  void *v5;
  void *v6;
  void *v7;
  _BOOL8 v8;

  message = securityd_create_message(0x63u, a2);
  if (!message)
    return 0;
  v5 = message;
  xpc_dictionary_set_int64(message, "uid", a1);
  v6 = (void *)securityd_message_with_reply_sync(v5, (uint64_t)a2);
  if (v6)
  {
    v7 = v6;
    v8 = xpc_dictionary_get_BOOL(v6, "status");
    if (!v8)
      securityd_message_no_error((uint64_t)v7, (CFErrorRef *)a2);
    xpc_release(v7);
  }
  else
  {
    v8 = 0;
  }
  xpc_release(v5);
  return v8;
}

void *_SecSecuritydCopyEndpoint(unsigned int a1, CFTypeRef *a2)
{
  xpc_object_t message;
  void *v4;
  void *v5;
  void *v6;
  xpc_object_t value;
  void *v8;
  NSObject *v9;
  const char *v10;
  NSObject *v11;
  CFTypeRef v12;
  int v14;
  CFTypeRef v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  message = securityd_create_message(a1, a2);
  if (message)
  {
    v4 = message;
    v5 = (void *)securityd_message_with_reply_sync(message, (uint64_t)a2);
    if (!v5)
    {
      v11 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        if (a2)
          v12 = *a2;
        else
          v12 = 0;
        v14 = 138412290;
        v15 = v12;
        _os_log_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEFAULT, "Securityd failed getting endpoint with error: %@", (uint8_t *)&v14, 0xCu);
      }
      v8 = 0;
      goto LABEL_20;
    }
    v6 = v5;
    value = xpc_dictionary_get_value(v5, "endpoint");
    if (value)
    {
      v8 = value;
      if (MEMORY[0x18D7718B8]() == MEMORY[0x1E0C81308])
      {
        xpc_retain(v8);
        goto LABEL_16;
      }
      v9 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v14) = 0;
        v10 = "endpoint was not an endpoint";
LABEL_13:
        _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v14, 2u);
      }
    }
    else
    {
      v9 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v14) = 0;
        v10 = "endpoint was null";
        goto LABEL_13;
      }
    }
    v8 = 0;
LABEL_16:
    xpc_release(v6);
LABEL_20:
    xpc_release(v4);
    return v8;
  }
  return 0;
}

uint64_t _SecSecuritydCopyCKKSEndpoint()
{
  return 0;
}

void *_SecSecuritydCopyKeychainControlEndpoint(CFTypeRef *a1)
{
  return _SecSecuritydCopyEndpoint(0x72u, a1);
}

void *_SecSecuritydCopySFKeychainEndpoint(CFTypeRef *a1)
{
  return _SecSecuritydCopyEndpoint(0x71u, a1);
}

id SecEscrowRequestSetupControlProtocol(void *a1)
{
  id v1;
  void *v2;

  v1 = a1;
  +[SecXPCHelper safeErrorClasses](SecXPCHelper, "safeErrorClasses");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_triggerEscrowUpdate_options_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_cachePrerecord_serializedPrerecord_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchPrerecord_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchRequestWaitingOnPasscode_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchRequestStatuses_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_resetAllRequests_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_storePrerecordsInEscrow_, 1, 1);

  return v1;
}

CFURLRef SecCopyHomeURL()
{
  uint64_t v0;

  v0 = sCustomHomeURL;
  if (!sCustomHomeURL)
    return CFCopyHomeDirectoryURL();
  CFRetain((CFTypeRef)sCustomHomeURL);
  return (CFURLRef)v0;
}

CFURLRef SecCopyBaseFilesURL(int a1)
{
  uint64_t v1;

  v1 = sCustomHomeURL;
  if (sCustomHomeURL)
  {
    CFRetain((CFTypeRef)sCustomHomeURL);
    return (CFURLRef)v1;
  }
  else if (a1)
  {
    return CFURLCreateWithFileSystemPath(0, CFSTR("/"), kCFURLPOSIXPathStyle, 1u);
  }
  else
  {
    return SecCopyHomeURL();
  }
}

CFTypeRef SecSetCustomHomeURL(CFTypeRef cf)
{
  uint64_t v1;

  v1 = (uint64_t)cf;
  if (cf)
    cf = CFRetain(cf);
  sCustomHomeURL = v1;
  return cf;
}

void SecSetCustomHomeURLString(CFStringRef filePath)
{
  const void *v2;

  v2 = (const void *)sCustomHomeURL;
  if (sCustomHomeURL)
  {
    sCustomHomeURL = 0;
    CFRelease(v2);
  }
  if (filePath)
    sCustomHomeURL = (uint64_t)CFURLCreateWithFileSystemPath(0, filePath, kCFURLPOSIXPathStyle, 1u);
}

BOOL SECSFAActionDropEventReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  char v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char v22;
  BOOL v23;
  int *v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  char v29;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      if ((v10 >> 3) == 2)
        break;
      if ((v10 >> 3) == 1)
      {
        v17 = 0;
        v18 = 0;
        v19 = 0;
        *(_BYTE *)(a1 + 12) |= 2u;
        while (1)
        {
          v20 = *v3;
          v21 = *(_QWORD *)(a2 + v20);
          if (v21 == -1 || v21 >= *(_QWORD *)(a2 + *v4))
          {
            v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeEvent;
            goto LABEL_38;
          }
          v22 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v21);
          *(_QWORD *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0)
            break;
          v17 += 7;
          v23 = v18++ > 8;
          if (v23)
          {
            v19 = 0;
            v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeEvent;
            goto LABEL_41;
          }
        }
        v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeEvent;
LABEL_39:
        if (*(_BYTE *)(a2 + *v5))
          v19 = 0;
LABEL_41:
        *(_BYTE *)(a1 + *v24) = v19 != 0;
        goto LABEL_42;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_42:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    v25 = 0;
    v26 = 0;
    v19 = 0;
    *(_BYTE *)(a1 + 12) |= 1u;
    while (1)
    {
      v27 = *v3;
      v28 = *(_QWORD *)(a2 + v27);
      if (v28 == -1 || v28 >= *(_QWORD *)(a2 + *v4))
        break;
      v29 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v28);
      *(_QWORD *)(a2 + v27) = v28 + 1;
      v19 |= (unint64_t)(v29 & 0x7F) << v25;
      if ((v29 & 0x80) == 0)
      {
        v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeCount;
        goto LABEL_39;
      }
      v25 += 7;
      v23 = v26++ > 8;
      if (v23)
      {
        v19 = 0;
        v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeCount;
        goto LABEL_41;
      }
    }
    v24 = &OBJC_IVAR___SECSFAActionDropEvent__excludeCount;
LABEL_38:
    *(_BYTE *)(a2 + *v5) = 1;
    goto LABEL_39;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t OctagonIsSOSFeatureEnabled()
{
  NSObject *v0;
  const __CFString *v1;
  char *v2;
  int v4;
  const __CFString *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (OctagonSOSFeatureIsEnabledOverrideSet == 1)
  {
    secLogObjForScope("octagon");
    v0 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      if (OctagonSOSFeatureIsEnabledOverride)
        v1 = CFSTR("enabled");
      else
        v1 = CFSTR("disabled");
      v4 = 138412290;
      v5 = v1;
      _os_log_impl(&dword_18A900000, v0, OS_LOG_TYPE_DEFAULT, "SOS Feature is %@ (overridden)", (uint8_t *)&v4, 0xCu);
    }

    v2 = &OctagonSOSFeatureIsEnabledOverride;
  }
  else
  {
    if (OctagonIsSOSFeatureEnabled_onceToken != -1)
      dispatch_once(&OctagonIsSOSFeatureEnabled_onceToken, &__block_literal_global_1147);
    v2 = &OctagonIsSOSFeatureEnabled_sosEnabled;
  }
  return *v2;
}

uint64_t OctagonSetSOSFeatureEnabled(uint64_t result)
{
  OctagonSOSFeatureIsEnabledOverrideSet = 1;
  OctagonSOSFeatureIsEnabledOverride = result;
  return result;
}

BOOL OctagonSupportsPersonaMultiuser()
{
  if (gOctagonSupportsPersonaMultiuserStatus)
    return gOctagonSupportsPersonaMultiuserStatus == 1;
  if (OctagonSupportsPersonaMultiuser_onceToken != -1)
    dispatch_once(&OctagonSupportsPersonaMultiuser_onceToken, &__block_literal_global_26);
  return OctagonSupportsPersonaMultiuser_ffOctagonSupportsPersonaMultiuserStatus != 0;
}

void OctagonSetSupportsPersonaMultiuser(int a1)
{
  int v2;
  NSObject *v3;
  const char *v4;
  int v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a1)
    v2 = 1;
  else
    v2 = 2;
  gOctagonSupportsPersonaMultiuserStatus = v2;
  secLogObjForScope("octagon");
  v3 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = "disabled";
    if (a1)
      v4 = "enabled";
    v5 = 136315138;
    v6 = v4;
    _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "OctagonSupportsMultiuser overridden to %s", (uint8_t *)&v5, 0xCu);
  }

}

void OctagonClearSupportsPersonaMultiuserOverride()
{
  NSObject *v0;
  uint8_t v1[16];

  gOctagonSupportsPersonaMultiuserStatus = 0;
  secLogObjForScope("octagon");
  v0 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v1 = 0;
    _os_log_impl(&dword_18A900000, v0, OS_LOG_TYPE_DEFAULT, "OctagonSupportsMultiuser override removed", v1, 2u);
  }

}

BOOL SOSCompatibilityModeEnabled()
{
  if (gDeferSOSFromSignInStatus)
    return gDeferSOSFromSignInStatus == 1;
  if (SOSCompatibilityModeEnabled_onceToken != -1)
    dispatch_once(&SOSCompatibilityModeEnabled_onceToken, &__block_literal_global_30_1159);
  return SOSCompatibilityModeEnabled_ffDeferSOSFromSignInStatus != 0;
}

void SetSOSCompatibilityMode(int a1)
{
  int v2;
  NSObject *v3;
  const char *v4;
  int v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a1)
    v2 = 1;
  else
    v2 = 2;
  gDeferSOSFromSignInStatus = v2;
  secLogObjForScope("octagon");
  v3 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = "disabled";
    if (a1)
      v4 = "enabled";
    v5 = 136315138;
    v6 = v4;
    _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "DeferSOSFromSignIn overridden to %s", (uint8_t *)&v5, 0xCu);
  }

}

void ClearSOSCompatibilityModeOverride()
{
  NSObject *v0;
  uint8_t v1[16];

  gDeferSOSFromSignInStatus = 0;
  secLogObjForScope("octagon");
  v0 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v1 = 0;
    _os_log_impl(&dword_18A900000, v0, OS_LOG_TYPE_DEFAULT, "DeferSOSFromSignIn override removed", v1, 2u);
  }

}

BOOL IsRollOctagonIdentityEnabled()
{
  if (gRollOctagonIdentityEnabled)
    return gRollOctagonIdentityEnabled == 1;
  if (IsRollOctagonIdentityEnabled_onceToken != -1)
    dispatch_once(&IsRollOctagonIdentityEnabled_onceToken, &__block_literal_global_33_1165);
  return IsRollOctagonIdentityEnabled_ffRollOctagonIdentityEnabled != 0;
}

void SetRollOctagonIdentityEnabled(int a1)
{
  int v2;
  NSObject *v3;
  const char *v4;
  int v5;
  const char *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a1)
    v2 = 1;
  else
    v2 = 2;
  gRollOctagonIdentityEnabled = v2;
  secLogObjForScope("octagon");
  v3 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = "disabled";
    if (a1)
      v4 = "enabled";
    v5 = 136315138;
    v6 = v4;
    _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "RollIdentityOnMIDRotation overridden to %s", (uint8_t *)&v5, 0xCu);
  }

}

void ClearRollOctagonIdentityEnabledOverride()
{
  NSObject *v0;
  uint8_t v1[16];

  gRollOctagonIdentityEnabled = 0;
  secLogObjForScope("octagon");
  v0 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v1 = 0;
    _os_log_impl(&dword_18A900000, v0, OS_LOG_TYPE_DEFAULT, "RollIdentityOnMIDRotation override removed", v1, 2u);
  }

}

void sub_18A95E350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_18A95E450(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18A95E548(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18A95E674(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18A95E844(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18A95E8AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_18A95EC68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

uint64_t NtlmGeneratorCreate(int a1, _QWORD *a2)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t result;

  v4 = malloc_type_malloc(0xCuLL, 0x10000403E1C8BA9uLL);
  if (!v4)
    return 4294967188;
  v5 = v4;
  result = 0;
  v5[1] = 0;
  v5[2] = 0;
  *v5 = a1;
  *a2 = v5;
  return result;
}

void NtlmGeneratorRelease(void *a1)
{
  if (a1)
    free(a1);
}

uint64_t NtlmCreateClientRequest(_DWORD *a1, __CFData **a2)
{
  __CFData *Mutable;
  __CFData *v5;
  int v6;
  uint64_t result;
  uint64_t bytes;

  Mutable = CFDataCreateMutable(0, 0);
  if (!Mutable)
    return 4294967188;
  v5 = Mutable;
  CFDataAppendBytes(Mutable, (const UInt8 *)"NTLMSSP", 8);
  LODWORD(bytes) = 1;
  CFDataAppendBytes(v5, (const UInt8 *)&bytes, 4);
  if ((*a1 & 2) != 0)
    v6 = 557575;
  else
    v6 = 33287;
  a1[2] = v6;
  LODWORD(bytes) = v6;
  CFDataAppendBytes(v5, (const UInt8 *)&bytes, 4);
  appendSecBuf(v5, 0, &bytes);
  appendSecBuf(v5, 0, &bytes);
  result = 0;
  *a2 = v5;
  return result;
}

uint64_t NtlmCreateClientResponse(uint64_t a1, const __CFData *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, __CFData **a6)
{
  uint64_t v11;
  uint64_t PasswordHashes;
  CFTypeRef v13;
  CFTypeRef v15;
  CFTypeRef cf;

  v15 = 0;
  cf = 0;
  PasswordHashes = _NtlmGeneratePasswordHashes((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a5, (CFDataRef *)&cf, (CFDataRef *)&v15);
  v13 = cf;
  if ((_DWORD)PasswordHashes)
  {
    if (!cf)
      goto LABEL_4;
    goto LABEL_3;
  }
  PasswordHashes = _NtlmCreateClientResponse(a1, a2, a3, a4, (const __CFData *)cf, v11, a6);
  if (v13)
LABEL_3:
    CFRelease(v13);
LABEL_4:
  if (v15)
    CFRelease(v15);
  return PasswordHashes;
}

uint64_t _NtlmGeneratePasswordHashes(const __CFAllocator *a1, const __CFString *a2, CFDataRef *a3, CFDataRef *a4)
{
  uint64_t v7;
  uint64_t v8;
  void *v9;
  CC_LONG v10;
  __int128 v11;
  CFDataRef v12;
  int v14;
  unint64_t v15;
  CC_MD4_CTX c;
  unsigned __int8 md[16];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  memset(md, 170, sizeof(md));
  v15 = 0xAAAAAAAAAAAAAAAALL;
  v14 = -1431655766;
  v7 = ntlmStringToLE(a2, &v15, &v14);
  if ((_DWORD)v7)
    return v7;
  v9 = (void *)v15;
  v10 = v14;
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&c.data[13] = v11;
  *(_OWORD *)&c.data[6] = v11;
  *(_OWORD *)&c.data[10] = v11;
  *(_OWORD *)&c.Nl = v11;
  *(_OWORD *)&c.data[2] = v11;
  *(_OWORD *)&c.A = v11;
  CC_MD4_Init(&c);
  CC_MD4_Update(&c, v9, v10);
  CC_MD4_Final(md, &c);
  free(v9);
  v12 = CFDataCreate(a1, md, 16);
  *a3 = v12;
  memset(md, 0, sizeof(md));
  if (v12)
    v8 = 0;
  else
    v8 = 4294967188;
  *a4 = CFDataCreate(0, _NtlmGeneratePasswordHashes_zero, 16);
  return v8;
}

uint64_t _NtlmCreateClientResponse(uint64_t a1, CFDataRef theData, const __CFString *a3, const __CFString *a4, const __CFData *a5, uint64_t a6, __CFData **a7)
{
  unsigned int v13;
  const UInt8 *BytePtr;
  const UInt8 *v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  const UInt8 *v20;
  void *v21;
  int v22;
  void *v23;
  size_t v24;
  uint64_t v25;
  const UInt8 *v26;
  __CFData *Mutable;
  __CFString *MutableCopy;
  UInt8 *v29;
  UInt8 *v30;
  __CFString *v31;
  __CFString *v32;
  __CFData *v33;
  unsigned int v34;
  __CFData *v35;
  const UInt8 *v36;
  const UInt8 *v37;
  unsigned int v38;
  const UInt8 *v39;
  uint8x8_t v40;
  uint64_t v41;
  __int16 v42;
  CFIndex v43;
  size_t __len;
  __CFString *cf;
  void *v46;
  CFIndex length;
  CFIndex v48;
  CFIndex v49;
  int v50;
  CFIndex v51;
  unint64_t v52;
  CFIndex v53;
  unsigned int v54;
  UInt8 *v55;
  CFIndex v56;
  unsigned int v57;
  UInt8 *v58;
  CFIndex v59;
  unsigned int v60;
  UInt8 *v61;
  CFIndex v62;
  CFIndex v63;
  UInt8 v64[4];
  unsigned int v65;
  void *v66;
  UInt8 v67[4];
  __int128 v68;
  _QWORD dataOut[7];
  _OWORD v70[2];
  _QWORD v71[4];
  __int128 bytes;
  UInt8 v73[8];
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  memset(dataOut, 170, sizeof(dataOut));
  v61 = 0;
  v60 = 0;
  v58 = 0;
  v57 = 0;
  v55 = 0;
  v54 = 0;
  *(_QWORD *)&v68 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v68 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if (!theData)
    return 4294967246;
  v13 = CFDataGetLength(theData);
  if (v13 < 0x20)
    return 4294967246;
  BytePtr = CFDataGetBytePtr(theData);
  if (*(_QWORD *)BytePtr != 0x5053534D4C544ELL)
    return 4294967246;
  v15 = BytePtr;
  if (*((_DWORD *)BytePtr + 2) != 2)
    return 4294967246;
  v62 = 0xAAAAAAAAAAAAAAAALL;
  v63 = 0xAAAAAAAAAAAAAAAALL;
  v59 = 0xAAAAAAAAAAAAAAAALL;
  v56 = 0xAAAAAAAAAAAAAAAALL;
  v52 = 0xAAAAAAAAAAAAAAAALL;
  v53 = 0xAAAAAAAAAAAAAAAALL;
  v16 = *((unsigned __int16 *)BytePtr + 6);
  v17 = *((unsigned int *)BytePtr + 4);
  if ((int)v17 + (int)v16 > v13)
    return 4294967246;
  v20 = &BytePtr[v17];
  v21 = malloc_type_malloc(*((unsigned __int16 *)BytePtr + 6), 0xCF5DD0E8uLL);
  memmove(v21, v20, v16);
  v22 = *((_DWORD *)v15 + 5);
  dataOut[6] = *((_QWORD *)v15 + 3);
  if ((v13 & 0xFFFFFFF0) >= 0x30uLL)
  {
    v24 = *((unsigned __int16 *)v15 + 20);
    v25 = *((unsigned int *)v15 + 11);
    if ((int)v25 + (int)v24 > v13)
    {
      free(v21);
      return 4294967246;
    }
    v26 = &v15[v25];
    v23 = malloc_type_malloc(*((unsigned __int16 *)v15 + 20), 0xCC808109uLL);
    memmove(v23, v26, v24);
  }
  else
  {
    v23 = 0;
    LODWORD(v24) = 0;
  }
  Mutable = CFDataCreateMutable(0, 0);
  if (!Mutable)
    goto LABEL_24;
  if (a3)
  {
    MutableCopy = CFStringCreateMutableCopy(0, 0, a3);
    a3 = MutableCopy;
    if (MutableCopy)
    {
      CFStringUppercase(MutableCopy, 0);
      goto LABEL_17;
    }
LABEL_24:
    v29 = 0;
    v30 = 0;
    v18 = 4294967188;
    goto LABEL_25;
  }
LABEL_17:
  CFDataAppendBytes(Mutable, (const UInt8 *)"NTLMSSP", 8);
  LODWORD(bytes) = 3;
  CFDataAppendBytes(Mutable, (const UInt8 *)&bytes, 4);
  if (v23 && (_DWORD)v24 && (v22 & 0x800000) != 0 && (*(_BYTE *)a1 & 4) != 0)
  {
    v50 = v22;
    v48 = (CFIndex)v23;
    *(_QWORD *)v73 = 0xAAAAAAAAAAAAAAAALL;
    CCRandomCopyBytes();
    bytes = *(_OWORD *)CFDataGetBytePtr(a5);
    v31 = CFStringCreateMutableCopy(0, 0, a4);
    v32 = v31;
    if (a3)
      CFStringAppend(v31, a3);
    CFStringUppercase(v32, 0);
    v66 = 0;
    memset(v71, 170, sizeof(v71));
    memset(v70, 170, sizeof(v70));
    *(_DWORD *)v64 = 257;
    v65 = -1431655766;
    ntlmStringToLE(v32, &v66, &v65);
    v46 = v66;
    ntlmHmacMD5(&bytes, v66, v65, &v71[2]);
    v71[0] = dataOut[6];
    v71[1] = *(_QWORD *)v73;
    ntlmHmacMD5(&v71[2], v71, 0x10u, &v70[1]);
    *(_OWORD *)&dataOut[3] = v70[1];
    dataOut[5] = *(_QWORD *)v73;
    v33 = CFDataCreateMutable(0, 0);
    CFDataAppendBytes(v33, v64, 4);
    *(_DWORD *)v67 = 0;
    CFDataAppendBytes(v33, v67, 4);
    ntlmAppendTimestamp(v33);
    CFDataAppendBytes(v33, v73, 8);
    *(_DWORD *)v67 = 0;
    CFDataAppendBytes(v33, v67, 4);
    CFDataAppendBytes(v33, (const UInt8 *)v23, v24);
    *(_DWORD *)v67 = 0;
    CFDataAppendBytes(v33, v67, 4);
    cf = v32;
    v34 = CFDataGetLength(v33);
    v35 = CFDataCreateMutable(0, 0);
    CFDataAppendBytes(v35, (const UInt8 *)&dataOut[6], 8);
    v36 = CFDataGetBytePtr(v33);
    __len = v34;
    CFDataAppendBytes(v35, v36, v34);
    v37 = CFDataGetBytePtr(v35);
    v38 = CFDataGetLength(v35);
    ntlmHmacMD5(&v71[2], v37, v38, v70);
    length = v34 + 16;
    v30 = (UInt8 *)malloc_type_malloc(length, 0x6F508B56uLL);
    *(_OWORD *)v30 = v70[0];
    v39 = CFDataGetBytePtr(v33);
    memmove(v30 + 16, v39, __len);
    if (cf)
      CFRelease(cf);
    if (v33)
      CFRelease(v33);
    v23 = (void *)v48;
    if (v35)
      CFRelease(v35);
    v22 = v50;
    if (v46)
      free(v46);
    appendSecBuf(Mutable, 24, &v63);
    appendSecBuf(Mutable, length, &v62);
    *(_DWORD *)(a1 + 4) = 4;
    goto LABEL_58;
  }
  if ((v22 & 0x80000) != 0 && (*(_BYTE *)a1 & 2) != 0)
  {
    CCRandomCopyBytes();
    dataOut[4] = 0;
    dataOut[5] = 0;
    *(_QWORD *)&bytes = dataOut[6];
    *((_QWORD *)&bytes + 1) = dataOut[3];
    v71[2] = 0xAAAAAAAAAAAAAAAALL;
    v71[3] = 0xAAAAAAAAAAAAAAAALL;
    md5Hash(&bytes, (unsigned __int8 *)&v71[2]);
    v68 = *(_OWORD *)CFDataGetBytePtr(a5);
    v41 = lmv2Response((uint64_t)&v68, &v71[2], (char *)dataOut, *(uint8x8_t *)&v68, v40);
    if ((_DWORD)v41)
    {
      v18 = v41;
      v29 = 0;
      v30 = 0;
      goto LABEL_25;
    }
    *(_DWORD *)(a1 + 4) = 2;
    length = 24;
    appendSecBuf(Mutable, 24, &v63);
    appendSecBuf(Mutable, 24, &v62);
    v30 = (UInt8 *)dataOut;
LABEL_58:
    if (a3)
    {
      if (ntlmStringFlatten(a3, v22 & 1, (char **)&v61, &v60))
      {
LABEL_63:
        v29 = 0;
        v18 = 4294967246;
        goto LABEL_25;
      }
      v42 = v60;
      v51 = v60;
    }
    else
    {
      v51 = 0;
      v42 = 0;
    }
    appendSecBuf(Mutable, v42, &v59);
    if (!ntlmStringFlatten(a4, v22 & 1, (char **)&v58, &v57))
    {
      v49 = v57;
      appendSecBuf(Mutable, v57, &v56);
      ntlmHostName(v22 & 1, &v55, &v54);
      v43 = v54;
      appendSecBuf(Mutable, v54, &v53);
      appendSecBuf(Mutable, 0, &v52);
      LODWORD(bytes) = *(_DWORD *)(a1 + 8) & v22;
      CFDataAppendBytes(Mutable, (const UInt8 *)&bytes, 4);
      secBufOffset(Mutable, v63);
      CFDataAppendBytes(Mutable, (const UInt8 *)&dataOut[3], 24);
      secBufOffset(Mutable, v62);
      CFDataAppendBytes(Mutable, v30, length);
      if (a3)
      {
        secBufOffset(Mutable, v59);
        CFDataAppendBytes(Mutable, v61, v51);
      }
      secBufOffset(Mutable, v56);
      CFDataAppendBytes(Mutable, v58, v49);
      secBufOffset(Mutable, v53);
      v29 = v55;
      CFDataAppendBytes(Mutable, v55, v43);
      v18 = 0;
      goto LABEL_25;
    }
    goto LABEL_63;
  }
  v29 = 0;
  v30 = 0;
  v18 = 4294942003;
LABEL_25:
  if (v21)
    free(v21);
  if (v23)
    free(v23);
  if (v61)
    free(v61);
  if (v58)
    free(v58);
  if (v29)
    free(v29);
  if (a3)
    CFRelease(a3);
  if (v30 != (UInt8 *)dataOut && v30)
    free(v30);
  if ((_DWORD)v18)
  {
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
    *a7 = Mutable;
  }
  return v18;
}

uint64_t NtlmGetNegotiatedVersion(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

uint64_t NtlmGeneratePasswordHashes(const __CFAllocator *a1, const __CFString *a2, CFDataRef *a3, CFDataRef *a4)
{
  _QWORD *v8;
  void *v9;
  uint64_t PasswordHashes;

  v8 = malloc_type_malloc(0xCuLL, 0x10000403E1C8BA9uLL);
  if (!v8)
    return 4294967188;
  v9 = v8;
  *v8 = 6;
  *((_DWORD *)v8 + 2) = 0;
  PasswordHashes = _NtlmGeneratePasswordHashes(a1, a2, a3, a4);
  free(v9);
  return PasswordHashes;
}

void sub_18A960068(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A960168(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A960268(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A960384(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A9604A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A9605BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A9606D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A9607F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A960910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A960A2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A960B48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A960C64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A960D74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A960E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

void sub_18A960ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

void sub_18A960FD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A9610D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A9611D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A96136C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A961518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

id KCSharingSetupInvitationNotificationProtocol(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (void *)MEMORY[0x1E0C99E60];
  v6[0] = objc_opt_class();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v6, 1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setWithArray:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v4, sel_receivedGroupInvitation_, 0, 0);
  return v1;
}

uint64_t SECSFAActionReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  unint64_t v17;
  SECSFAActionTapToRadar *v18;
  uint64_t v19;
  void *v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  uint64_t result;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    do
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      v17 = v10 >> 3;
      if ((int)(v10 >> 3) <= 99)
      {
        if ((_DWORD)v17)
        {
          if ((_DWORD)v17 != 1)
          {
LABEL_41:
            result = PBReaderSkipValueWithTag();
            if (!(_DWORD)result)
              return result;
            continue;
          }
          PBReaderReadString();
          v19 = objc_claimAutoreleasedReturnValue();
          v20 = *(void **)(a1 + 32);
          *(_QWORD *)(a1 + 32) = v19;

        }
        else
        {
          v21 = 0;
          while (1)
          {
            v22 = *v3;
            v23 = *(_QWORD *)(a2 + v22);
            if (v23 == -1 || v23 >= *(_QWORD *)(a2 + *v4))
              break;
            v24 = v23 + 1;
            v25 = *(char *)(*(_QWORD *)(a2 + *v7) + v23);
            *(_QWORD *)(a2 + v22) = v24;
            if (v25 < 0 && v21++ <= 8)
              continue;
            goto LABEL_44;
          }
          *(_BYTE *)(a2 + *v5) = 1;
        }
      }
      else
      {
        switch((_DWORD)v17)
        {
          case 'd':
            objc_msgSend((id)a1, "clearOneofValuesForAction");
            *(_BYTE *)(a1 + 48) |= 1u;
            *(_DWORD *)(a1 + 16) = 1;
            v18 = objc_alloc_init(SECSFAActionTapToRadar);
            objc_storeStrong((id *)(a1 + 40), v18);
            if (!PBReaderPlaceMark() || !SECSFAActionTapToRadarReadFrom((uint64_t)v18, a2))
            {
LABEL_46:

              return 0;
            }
            break;
          case 'e':
            objc_msgSend((id)a1, "clearOneofValuesForAction");
            *(_BYTE *)(a1 + 48) |= 1u;
            *(_DWORD *)(a1 + 16) = 2;
            v18 = objc_alloc_init(SECSFAActionAutomaticBugCapture);
            objc_storeStrong((id *)(a1 + 8), v18);
            if (!PBReaderPlaceMark() || !SECSFAActionAutomaticBugCaptureReadFrom((uint64_t)v18, a2))
              goto LABEL_46;
            break;
          case 'f':
            objc_msgSend((id)a1, "clearOneofValuesForAction");
            *(_BYTE *)(a1 + 48) |= 1u;
            *(_DWORD *)(a1 + 16) = 3;
            v18 = objc_alloc_init(SECSFAActionDropEvent);
            objc_storeStrong((id *)(a1 + 24), v18);
            if (!PBReaderPlaceMark() || !SECSFAActionDropEventReadFrom((uint64_t)v18, a2))
              goto LABEL_46;
            break;
          default:
            goto LABEL_41;
        }
        PBReaderRecallMark();

      }
LABEL_44:
      ;
    }
    while (*(_QWORD *)(a2 + *v3) < *(_QWORD *)(a2 + *v4));
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_18A962FC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9)
{
  id v9;
  NSObject *v10;

  if (a2 == 1)
  {
    v9 = objc_begin_catch(exception_object);
    secLogObjForScope("SecError");
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(a9) = 138412290;
      *(_QWORD *)((char *)&a9 + 4) = v9;
      _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, "Could not configure SecuritydXPCProtocol: %@", (uint8_t *)&a9, 0xCu);
    }

    objc_exception_throw(objc_retainAutorelease(v9));
  }
  _Unwind_Resume(exception_object);
}

id SecuritydXPCProxyObject(uint64_t a1, void *a2)
{
  void (**v3)(id, void *);
  void *v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v11;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if (gSecurityd && (v4 = *(void **)(gSecurityd + 696)) != 0)
  {
    v5 = v4;
  }
  else
  {
    if (SecuritydXPCProxyObject_onceToken != -1)
      dispatch_once(&SecuritydXPCProxyObject_onceToken, &__block_literal_global_1656);
    if (!SecuritydXPCProxyObject_rpc)
    {
      v7 = (void *)MEMORY[0x1E0CB35C8];
      v11 = *MEMORY[0x1E0CB2D50];
      v12[0] = CFSTR("Could not create SecuritydXPCClient");
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v12, &v11, 1);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "errorWithDomain:code:userInfo:", CFSTR("securityd"), -1, v8);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v3[2](v3, v9);

      v6 = 0;
      goto LABEL_10;
    }
    objc_msgSend((id)SecuritydXPCProxyObject_rpc, "protocolWithSync:errorHandler:", a1, v3);
    v5 = (id)objc_claimAutoreleasedReturnValue();
  }
  v6 = v5;
LABEL_10:

  return v6;
}

BOOL SecKeychainIsStaticPersistentRefsEnabled()
{
  int v0;
  NSObject *v1;
  const __CFString *v2;
  int v4;
  const __CFString *v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (SecKeychainStaticPersistentRefsEnabledOverrideSet != 1)
    return 1;
  v0 = persistentRefOverrideLastValue;
  if (persistentRefOverrideLastValue != SecKeychainStaticPersistentRefsEnabledOverride)
  {
    secLogObjForScope("octagon");
    v1 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      if (SecKeychainStaticPersistentRefsEnabledOverride)
        v2 = CFSTR("enabled");
      else
        v2 = CFSTR("disabled");
      v4 = 138412290;
      v5 = v2;
      _os_log_impl(&dword_18A900000, v1, OS_LOG_TYPE_DEFAULT, "Static Persistent Refs are %@ (overridden)", (uint8_t *)&v4, 0xCu);
    }

    v0 = SecKeychainStaticPersistentRefsEnabledOverride;
    persistentRefOverrideLastValue = SecKeychainStaticPersistentRefsEnabledOverride;
  }
  return v0 != 0;
}

uint64_t SecKeychainSetOverrideStaticPersistentRefsIsEnabled(uint64_t result)
{
  SecKeychainStaticPersistentRefsEnabledOverrideSet = 1;
  SecKeychainStaticPersistentRefsEnabledOverride = result;
  return result;
}

id OTSetupControlProtocol(void *a1)
{
  id v1;
  void *v2;

  v1 = a1;
  +[SecXPCHelper safeErrorClasses](SecXPCHelper, "safeErrorClasses");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_appleAccountSignedIn_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_appleAccountSignedOut_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_notifyIDMSTrustLevelChangeForAltDSID_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_rpcEpochWithArguments_configuration_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_rpcPrepareIdentityAsApplicantWithArguments_configuration_reply_, 5, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_rpcVoucherWithArguments_configuration_peerID_permanentInfo_permanentInfoSig_stableInfo_stableInfoSig_maxCapability_reply_, 2, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_rpcJoinWithArguments_configuration_vouchData_vouchSig_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_status_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_status_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchEgoPeerID_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchCliqueStatus_configuration_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchTrustStatus_configuration_reply_, 4, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_startOctagonStateMachine_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_resetAndEstablish_resetReason_idmsTargetContext_idmsCuttlefishPassword_notifyIdMS_accountSettings_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_establish_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_leaveClique_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_removeFriendsInClique_peerIDs_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_peerDeviceNamesByPeerID_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchAllViableBottles_source_reply_, 2, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_restoreFromBottle_entropy_bottleID_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchEscrowContents_reply_, 3, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_createRecoveryKey_recoveryKey_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_joinWithRecoveryKey_recoveryKey_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_healthCheck_skipRateLimitingCheck_repair_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_simulateReceivePush_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_waitForOctagonUpgrade_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_postCDPFollowupResult_success_type_error_reply_, 3, 0);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_postCDPFollowupResult_success_type_error_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_tapToRadar_description_radar_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_refetchCKKSPolicy_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_setCDPEnabled_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_getCDPStatus_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchEscrowRecords_source_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_setUserControllableViewsSyncStatus_enabled_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchUserControllableViewsSyncStatus_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_resetAccountCDPContents_idmsTargetContext_idmsCuttlefishPassword_notifyIdMS_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_setLocalSecureElementIdentity_secureElementIdentity_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_removeLocalSecureElementIdentityPeerID_secureElementIdentityPeerID_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchTrustedSecureElementIdentities_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_setAccountSetting_setting_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchAccountSettings_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchAccountWideSettingsWithForceFetch_arguments_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_waitForPriorityViewKeychainDataRecovery_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_createCustodianRecoveryKey_uuid_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_joinWithCustodianRecoveryKey_custodianRecoveryKey_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_preflightJoinWithCustodianRecoveryKey_custodianRecoveryKey_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_removeCustodianRecoveryKey_uuid_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_createInheritanceKey_uuid_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_generateInheritanceKey_uuid_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_storeInheritanceKey_ik_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_joinWithInheritanceKey_inheritanceKey_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_preflightJoinWithInheritanceKey_inheritanceKey_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_removeInheritanceKey_uuid_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_tlkRecoverabilityForEscrowRecordData_recordData_source_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_setMachineIDOverride_machineID_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_isRecoveryKeySet_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_recoverWithRecoveryKey_recoveryKey_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_removeRecoveryKey_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_preflightRecoverOctagonUsingRecoveryKey_recoveryKey_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_resetAcountData_resetReason_reply_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_totalTrustedPeers_reply_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_areRecoveryKeysDistrusted_reply_, 1, 1);

  return v1;
}

BOOL SECSFAActionAutomaticBugCaptureReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
        break;
      if ((_DWORD)v17 == 2)
      {
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 24;
        goto LABEL_24;
      }
      if ((_DWORD)v17 == 1)
      {
        PBReaderReadString();
        v18 = objc_claimAutoreleasedReturnValue();
        v19 = 8;
LABEL_24:
        v20 = *(void **)(a1 + v19);
        *(_QWORD *)(a1 + v19) = v18;

        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0)
        return 0;
LABEL_26:
      if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
        return *(_BYTE *)(a2 + *v5) == 0;
    }
    PBReaderReadString();
    v18 = objc_claimAutoreleasedReturnValue();
    v19 = 16;
    goto LABEL_24;
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

uint64_t SECSFARuleReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  BOOL v14;
  int v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  SECSFAAction *v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  void *v27;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) >= *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
    return *(_BYTE *)(a2 + *v5) == 0;
  v7 = (int *)MEMORY[0x1E0D82BB8];
  while (2)
  {
    if (*(_BYTE *)(a2 + *v5))
      return *(_BYTE *)(a2 + *v5) == 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = *v3;
      v12 = *(_QWORD *)(a2 + v11);
      if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
        break;
      v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
      *(_QWORD *)(a2 + v11) = v12 + 1;
      v10 |= (unint64_t)(v13 & 0x7F) << v8;
      if ((v13 & 0x80) == 0)
        goto LABEL_12;
      v8 += 7;
      v14 = v9++ >= 9;
      if (v14)
      {
        v10 = 0;
        v15 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
    v15 = *(unsigned __int8 *)(a2 + *v5);
    if (*(_BYTE *)(a2 + *v5))
      v10 = 0;
LABEL_14:
    if (v15 || (v10 & 7) == 4)
      return *(_BYTE *)(a2 + *v5) == 0;
    switch((v10 >> 3))
    {
      case 1u:
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 24;
        goto LABEL_34;
      case 2u:
        PBReaderReadData();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 32;
        goto LABEL_34;
      case 3u:
        v20 = objc_alloc_init(SECSFAAction);
        objc_storeStrong((id *)(a1 + 16), v20);
        if (PBReaderPlaceMark() && (SECSFAActionReadFrom((uint64_t)v20, a2) & 1) != 0)
        {
          PBReaderRecallMark();

LABEL_39:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          continue;
        }

        return 0;
      case 4u:
        v21 = 0;
        v22 = 0;
        v23 = 0;
        *(_BYTE *)(a1 + 48) |= 1u;
        while (2)
        {
          v24 = *v3;
          v25 = *(_QWORD *)(a2 + v24);
          if (v25 == -1 || v25 >= *(_QWORD *)(a2 + *v4))
          {
            *(_BYTE *)(a2 + *v5) = 1;
          }
          else
          {
            v26 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v25);
            *(_QWORD *)(a2 + v24) = v25 + 1;
            v23 |= (unint64_t)(v26 & 0x7F) << v21;
            if (v26 < 0)
            {
              v21 += 7;
              v14 = v22++ >= 9;
              if (v14)
              {
                v23 = 0;
                goto LABEL_38;
              }
              continue;
            }
          }
          break;
        }
        if (*(_BYTE *)(a2 + *v5))
          v23 = 0;
LABEL_38:
        *(_QWORD *)(a1 + 8) = v23;
        goto LABEL_39;
      case 5u:
        PBReaderReadString();
        v17 = objc_claimAutoreleasedReturnValue();
        v18 = 40;
LABEL_34:
        v27 = *(void **)(a1 + v18);
        *(_QWORD *)(a1 + v18) = v17;

        goto LABEL_39;
      default:
        result = PBReaderSkipValueWithTag();
        if (!(_DWORD)result)
          return result;
        goto LABEL_39;
    }
  }
}

void sub_18A965538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
  objc_sync_exit(obj);
  _Unwind_Resume(a1);
}

void sub_18A9655EC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_18A965D8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
  id *v17;

  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_18A9661D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2140(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2141(uint64_t a1)
{

}

CFIndex appendSecBuf(__CFData *a1, __int16 a2, _QWORD *a3)
{
  CFIndex result;
  _WORD v6[2];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6[0] = a2;
  v6[1] = a2;
  v7 = 0;
  CFDataAppendBytes(a1, (const UInt8 *)v6, 8);
  result = CFDataGetLength(a1);
  *a3 = result - 4;
  return result;
}

void secBufOffset(const __CFData *a1, CFIndex a2)
{
  UInt8 newBytes[4];
  CFRange v5;

  *(_DWORD *)newBytes = CFDataGetLength(a1);
  v5.location = a2;
  v5.length = 4;
  CFDataReplaceBytes(a1, v5, newBytes, 4);
}

uint64_t ntlmStringToLE(const __CFString *a1, _QWORD *a2, _DWORD *a3)
{
  CFIndex Length;
  uint64_t v7;
  int v8;
  _WORD *v9;
  _WORD *v10;
  CFIndex v11;
  UniChar *v12;
  uint64_t result;

  Length = CFStringGetLength(a1);
  if (Length > 2048)
    return 4294967188;
  v7 = Length;
  v8 = 2 * Length;
  v9 = malloc_type_malloc(2 * Length, 0xD5697793uLL);
  if (!v9)
    return 4294967188;
  v10 = v9;
  if (v7 >= 1)
  {
    v11 = 0;
    v12 = v9;
    do
      *v12++ = CFStringGetCharacterAtIndex(a1, v11++);
    while (v7 != v11);
  }
  result = 0;
  *a2 = v10;
  *a3 = v8;
  return result;
}

uint64_t ntlmStringFlatten(CFStringRef theString, int a2, char **a3, unsigned int *a4)
{
  uint64_t result;
  CFIndex Length;
  unsigned int v9;
  CFIndex v10;
  char *v11;
  char *v12;
  const __CFData *ExternalRepresentation;
  const __CFData *v14;
  unsigned int v15;
  char *v16;
  char *v17;
  const UInt8 *BytePtr;

  if (a2)
    return ntlmStringToLE(theString, a3, a4);
  Length = CFStringGetLength(theString);
  if (Length <= 2048)
  {
    v9 = Length;
    v10 = Length + 1;
    v11 = (char *)malloc_type_malloc(Length + 1, 0xC66EE4ADuLL);
    if (v11)
    {
      v12 = v11;
      if (CFStringGetCString(theString, v11, v10, 0x600u))
      {
        result = 0;
        *a3 = v12;
        *a4 = v9;
        return result;
      }
      free(v12);
      ExternalRepresentation = CFStringCreateExternalRepresentation(0, theString, 0x8000100u, 0);
      if (!ExternalRepresentation)
        return 4294967246;
      v14 = ExternalRepresentation;
      v15 = CFDataGetLength(ExternalRepresentation);
      *a4 = v15;
      v16 = (char *)malloc_type_malloc(v15, 0xAA4A7504uLL);
      *a3 = v16;
      if (v16)
      {
        v17 = v16;
        BytePtr = CFDataGetBytePtr(v14);
        memcpy(v17, BytePtr, *a4);
        CFRelease(v14);
        return 0;
      }
      CFRelease(v14);
    }
  }
  return 4294967188;
}

char *ntlmHostName(int a1, _QWORD *a2, _DWORD *a3)
{
  char *result;
  uint64_t v6;

  if (a1)
  {
    result = (char *)malloc_type_malloc(0x16uLL, 0x22851FE5uLL);
    v6 = 0;
    *a2 = result;
    do
    {
      *(_WORD *)result = aWorkstation[v6];
      result += 2;
      ++v6;
    }
    while (v6 != 11);
    *a3 = 22;
  }
  else
  {
    result = (char *)malloc_type_malloc(0xCuLL, 0xA94DE47uLL);
    *a2 = result;
    *a3 = 11;
    *(_QWORD *)result = *(_QWORD *)"WORKSTATION";
    *(_DWORD *)(result + 7) = 1313818964;
    a2[11] = 0;
  }
  return result;
}

void __ntlmGetBasis_block_invoke(uint64_t a1)
{
  uint64_t v2;
  _QWORD v3[6];
  int v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __CFAbsoluteTimeForGregorianZuluDay_block_invoke;
  v3[3] = &unk_1E1FCC280;
  v3[4] = &v5;
  v3[5] = 0x100000641;
  v4 = 1;
  SecCFCalendarDoWithZuluCalendar((uint64_t)v3);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  **(_QWORD **)(a1 + 32) = v2;
}

void ntlmAppendTimestamp(__CFData *a1)
{
  double Current;
  _QWORD v3[6];

  v3[5] = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __ntlmGetBasis_block_invoke;
  v3[3] = &__block_descriptor_tmp_2565;
  v3[4] = &ntlmGetBasis_sntlmGetBasisSingleton;
  if (ntlmGetBasis_sntlmGetBasisOnce != -1)
    dispatch_once(&ntlmGetBasis_sntlmGetBasisOnce, v3);
  v3[0] = (unint64_t)((Current - *(double *)&ntlmGetBasis_sntlmGetBasisSingleton) * 10000000.0);
  CFDataAppendBytes(a1, (const UInt8 *)v3, 8);
}

uint64_t md5Hash(const void *a1, unsigned __int8 *a2)
{
  __int128 v4;
  CC_MD5_CTX v6;

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v6.data[13] = v4;
  *(_OWORD *)&v6.data[6] = v4;
  *(_OWORD *)&v6.data[10] = v4;
  *(_OWORD *)&v6.Nl = v4;
  *(_OWORD *)&v6.data[2] = v4;
  *(_OWORD *)&v6.A = v4;
  CC_MD5_Init(&v6);
  CC_MD5_Update(&v6, a1, 0x10u);
  return CC_MD5_Final(a2, &v6);
}

void ntlmHmacMD5(void *key, const void *a2, unsigned int a3, void *a4)
{
  __int128 v7;
  CCHmacContext v8;

  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v8.ctx[88] = v7;
  *(_OWORD *)&v8.ctx[92] = v7;
  *(_OWORD *)&v8.ctx[80] = v7;
  *(_OWORD *)&v8.ctx[84] = v7;
  *(_OWORD *)&v8.ctx[72] = v7;
  *(_OWORD *)&v8.ctx[76] = v7;
  *(_OWORD *)&v8.ctx[64] = v7;
  *(_OWORD *)&v8.ctx[68] = v7;
  *(_OWORD *)&v8.ctx[56] = v7;
  *(_OWORD *)&v8.ctx[60] = v7;
  *(_OWORD *)&v8.ctx[48] = v7;
  *(_OWORD *)&v8.ctx[52] = v7;
  *(_OWORD *)&v8.ctx[40] = v7;
  *(_OWORD *)&v8.ctx[44] = v7;
  *(_OWORD *)&v8.ctx[32] = v7;
  *(_OWORD *)&v8.ctx[36] = v7;
  *(_OWORD *)&v8.ctx[24] = v7;
  *(_OWORD *)&v8.ctx[28] = v7;
  *(_OWORD *)&v8.ctx[16] = v7;
  *(_OWORD *)&v8.ctx[20] = v7;
  *(_OWORD *)&v8.ctx[8] = v7;
  *(_OWORD *)&v8.ctx[12] = v7;
  *(_OWORD *)v8.ctx = v7;
  *(_OWORD *)&v8.ctx[4] = v7;
  CCHmacInit(&v8, 1u, key, 0x10uLL);
  CCHmacUpdate(&v8, a2, a3);
  CCHmacFinal(&v8, a4);
}

uint64_t lmv2Response(uint64_t a1, void *dataIn, char *dataOut, uint8x8_t a4, uint8x8_t a5)
{
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int16x8_t v14;
  int v15;
  unint64_t v16;
  int16x8_t v17;
  int16x4_t v18;
  uint64_t v19;
  uint64_t result;
  size_t dataOutMoved;
  _BYTE v22[3];
  int v23;
  char v24;
  char v25;
  unsigned __int32 v26;
  char v27;
  char v28;
  char v29;
  char key;
  __int32 v31;
  char v32;
  char v33;
  char v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v7 = *(unsigned __int8 *)(a1 + 4);
  v8 = *(unsigned __int8 *)(a1 + 5);
  v9 = *(unsigned __int8 *)(a1 + 6);
  v10 = *(unsigned __int8 *)(a1 + 11);
  v11 = *(unsigned __int8 *)(a1 + 12);
  v12 = *(unsigned __int8 *)(a1 + 13);
  v13 = *(unsigned __int8 *)(a1 + 14);
  a4.i32[0] = *(_DWORD *)a1;
  v14 = (int16x8_t)vmovl_u8(a4);
  v15 = *(unsigned __int8 *)(a1 + 15);
  key = v14.i8[0] & 0xFE;
  a5.i32[0] = *(_DWORD *)(a1 + 1);
  v14.i64[0] = *(_QWORD *)&vshl_u16((uint16x4_t)vorr_s8((int8x8_t)vshl_n_s16(*(int16x4_t *)v14.i8, 8uLL), (int8x8_t)*(_OWORD *)&vmovl_u8(a5)), (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0x80FE80FE80FE80FELL;
  *(int8x8_t *)v14.i8 = vmovn_s16(v14);
  v31 = v14.i32[0];
  HIDWORD(v16) = v7;
  LODWORD(v16) = v8 << 24;
  v32 = (v16 >> 29) & 0xFE;
  HIDWORD(v16) = v8;
  LODWORD(v16) = v9 << 24;
  v33 = (v16 >> 30) & 0xFE;
  v34 = 2 * v9;
  v14.i32[0] = *(_DWORD *)(a1 + 7);
  v17 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v14.i8);
  v25 = v17.i8[0] & 0xFE;
  v18 = (int16x4_t)vext_s8(*(int8x8_t *)v17.i8, *(int8x8_t *)v17.i8, 2uLL);
  v18.i16[3] = v10;
  v17.i64[0] = *(_QWORD *)&vshl_u16((uint16x4_t)vsli_n_s16(v18, *(int16x4_t *)v17.i8, 8uLL), (uint16x4_t)0xFFFCFFFDFFFEFFFFLL) & 0x80FE80FE80FE80FELL;
  v26 = vmovn_s16(v17).u32[0];
  HIDWORD(v16) = v10;
  LODWORD(v16) = v11 << 24;
  v19 = (v16 >> 29) & 0xFE;
  HIDWORD(v16) = v11;
  LODWORD(v16) = v12 << 24;
  v27 = v19;
  v28 = (v16 >> 30) & 0xFE;
  v29 = 2 * v12;
  v22[0] = v13 & 0xFE;
  HIDWORD(v16) = v13;
  LODWORD(v16) = v15 << 24;
  v22[1] = (v16 >> 25) & 0xFE;
  v22[2] = (_BYTE)v15 << 6;
  v23 = 0;
  v24 = 0;
  dataOutMoved = 0xAAAAAAAAAAAAAAAALL;
  result = CCCrypt(0, 1u, 0, &key, 8uLL, 0, dataIn, 8uLL, dataOut, 8uLL, &dataOutMoved);
  if (!(_DWORD)result)
  {
    dataOutMoved = 0xAAAAAAAAAAAAAAAALL;
    result = CCCrypt(0, 1u, 0, &v25, 8uLL, 0, dataIn, 8uLL, dataOut + 8, 8uLL, &dataOutMoved);
    if (!(_DWORD)result)
    {
      dataOutMoved = 0xAAAAAAAAAAAAAAAALL;
      return CCCrypt(0, 1u, 0, v22, 8uLL, 0, dataIn, 8uLL, dataOut + 16, 8uLL, &dataOutMoved);
    }
  }
  return result;
}

void sub_18A96EB10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A96EC9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A96EE44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a16, 8);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_18A96EFCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_18A96F150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_18A96F298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A96F3F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_18A96F764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2730(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2731(uint64_t a1)
{

}

uint64_t sec_protocol_options_contents_compare(unsigned __int16 *a1, unsigned __int16 *a2, int a3)
{
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  const char *v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  const void *v42;
  CFTypeRef v43;
  const void *v44;
  CFTypeRef v45;
  uint64_t v46;
  uint64_t v47;

  result = 1;
  if (a1 != a2 && a3 != 1)
  {
    result = 0;
    if (a1)
    {
      if (a2)
      {
        if (*a1 != *a2)
          return 0;
        if (a1[1] != a2[1])
          return 0;
        if (*((_QWORD *)a1 + 38) != *((_QWORD *)a2 + 38))
          return 0;
        if (*((_QWORD *)a1 + 39) != *((_QWORD *)a2 + 39))
          return 0;
        if (*((_DWORD *)a1 + 80) != *((_DWORD *)a2 + 80))
          return 0;
        if (*((unsigned __int8 *)a1 + 324) != *((unsigned __int8 *)a2 + 324))
          return 0;
        v6 = *(unsigned int *)((char *)a1 + 361) | ((unint64_t)*((unsigned __int8 *)a1 + 365) << 32);
        v7 = *(unsigned int *)((char *)a2 + 361) | ((unint64_t)*((unsigned __int8 *)a2 + 365) << 32);
        if (((v7 ^ v6) & 0x7AEAAAAAFLL) != 0)
          return 0;
        if ((a3 - 4) <= 0xFFFFFFFC)
        {
          v8 = v6 & 0x3000000000;
          v9 = v7 & 0x3000000000;
          if (v8 == 0x2000000000)
          {
            if (v9 != 0x2000000000)
              return 0;
          }
          else if (v9 == 0x2000000000)
          {
            return 0;
          }
        }
        if ((a3 & 0xFE) == 2)
        {
          v10 = *((_QWORD *)a1 + 43);
          v11 = *((_QWORD *)a2 + 43);
          if (v10 | v11)
            goto LABEL_55;
        }
        v12 = *((_QWORD *)a1 + 11);
        v13 = *((_QWORD *)a2 + 11);
        if (v12)
        {
          result = 0;
          if (!v13 || v12 != v13)
            return result;
          if (*((_QWORD *)a1 + 12) != *((_QWORD *)a2 + 12))
            return 0;
        }
        else if (v13)
        {
          return 0;
        }
        v14 = *((_QWORD *)a1 + 32);
        v15 = *((_QWORD *)a2 + 32);
        if (v14)
        {
          result = 0;
          if (!v15 || v14 != v15)
            return result;
          if (*((_QWORD *)a1 + 33) != *((_QWORD *)a2 + 33))
            return 0;
        }
        else if (v15)
        {
          return 0;
        }
        v16 = *((_QWORD *)a1 + 13);
        v17 = *((_QWORD *)a2 + 13);
        if (v16)
        {
          result = 0;
          if (!v17 || v16 != v17)
            return result;
          if (*((_QWORD *)a1 + 14) != *((_QWORD *)a2 + 14))
            return 0;
        }
        else if (v17)
        {
          return 0;
        }
        v18 = *((_QWORD *)a1 + 15);
        v19 = *((_QWORD *)a2 + 15);
        if (v18)
        {
          result = 0;
          if (!v19 || v18 != v19)
            return result;
          if (*((_QWORD *)a1 + 16) != *((_QWORD *)a2 + 16))
            return 0;
        }
        else if (v19)
        {
          return 0;
        }
        v20 = *((_QWORD *)a1 + 18);
        v21 = *((_QWORD *)a2 + 18);
        if (v20)
        {
          result = 0;
          if (!v21 || v20 != v21)
            return result;
          if (*((_QWORD *)a1 + 19) != *((_QWORD *)a2 + 19))
            return 0;
        }
        else if (v21)
        {
          return 0;
        }
        v22 = *((_QWORD *)a1 + 20);
        v23 = *((_QWORD *)a2 + 20);
        if (!v22)
        {
          if (v23)
            return 0;
          goto LABEL_56;
        }
        result = 0;
        if (v23 && v22 == v23)
        {
          v10 = *((_QWORD *)a1 + 21);
          v11 = *((_QWORD *)a2 + 21);
LABEL_55:
          if (v10 != v11)
            return 0;
LABEL_56:
          v24 = (void *)*((_QWORD *)a1 + 28);
          v25 = (void *)*((_QWORD *)a2 + 28);
          if (v24)
          {
            if (!v25 || !sec_protocol_helper_dispatch_data_equal(v24, v25))
              return 0;
          }
          else if (v25)
          {
            return 0;
          }
          v26 = (void *)*((_QWORD *)a1 + 17);
          v27 = (void *)*((_QWORD *)a2 + 17);
          if (v26)
          {
            if (!v27 || !sec_protocol_helper_dispatch_data_equal(v26, v27))
              return 0;
          }
          else if (v27)
          {
            return 0;
          }
          v28 = (void *)*((_QWORD *)a1 + 10);
          v29 = (void *)*((_QWORD *)a2 + 10);
          if (v28)
          {
            if (!v29 || !sec_protocol_helper_dispatch_data_equal(v28, v29))
              return 0;
          }
          else if (v29)
          {
            return 0;
          }
          v30 = (void *)*((_QWORD *)a1 + 6);
          v31 = (void *)*((_QWORD *)a2 + 6);
          if (v30)
          {
            if (!v31 || !xpc_equal(v30, v31))
              return 0;
          }
          else if (v31)
          {
            return 0;
          }
          v32 = (void *)*((_QWORD *)a1 + 5);
          v33 = (void *)*((_QWORD *)a2 + 5);
          if (v32)
          {
            if (!v33 || !xpc_equal(v32, v33))
              return 0;
          }
          else if (v33)
          {
            return 0;
          }
          v34 = (void *)*((_QWORD *)a1 + 29);
          v35 = (void *)*((_QWORD *)a2 + 29);
          if (v34)
          {
            if (!v35 || !xpc_equal(v34, v35))
              return 0;
          }
          else if (v35)
          {
            return 0;
          }
          v36 = (void *)*((_QWORD *)a1 + 9);
          v37 = (void *)*((_QWORD *)a2 + 9);
          if (v36)
          {
            if (!v37 || !xpc_equal(v36, v37))
              return 0;
          }
          else if (v37)
          {
            return 0;
          }
          v38 = (const char *)*((_QWORD *)a1 + 1);
          v39 = (const char *)*((_QWORD *)a2 + 1);
          if (v38)
          {
            if (!v39 || strcmp(v38, v39))
              return 0;
          }
          else if (v39)
          {
            return 0;
          }
          v40 = *((_QWORD *)a1 + 7);
          v41 = *((_QWORD *)a2 + 7);
          if (!v40)
          {
            if (v41)
              return 0;
            goto LABEL_111;
          }
          if (!v41)
            return 0;
          v42 = *(const void **)(v40 + 8);
          if (v42)
          {
            v43 = CFRetain(v42);
            v41 = *((_QWORD *)a2 + 7);
            if (!v41)
              goto LABEL_108;
          }
          else
          {
            v43 = 0;
          }
          v44 = *(const void **)(v41 + 8);
          if (v44)
          {
            v45 = CFRetain(v44);
LABEL_109:
            result = CFEqual(v43, v45);
            if (!(_DWORD)result)
              return result;
            CFRelease(v43);
            CFRelease(v45);
LABEL_111:
            v46 = *((_QWORD *)a1 + 41);
            v47 = *((_QWORD *)a2 + 41);
            if (v46)
            {
              result = 0;
              if (!v47 || v46 != v47)
                return result;
              return 1;
            }
            return !v47;
          }
LABEL_108:
          v45 = 0;
          goto LABEL_109;
        }
      }
    }
  }
  return result;
}

uint64_t sec_protocol_options_contents_are_equal(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return sec_protocol_options_contents_compare(a1, a2, 0);
}

BOOL sec_protocol_options_are_equal(sec_protocol_options_t optionsA, sec_protocol_options_t optionsB)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  _QWORD v6[7];

  if (optionsA == optionsB)
    return 1;
  v4 = 0;
  if (optionsA && optionsB)
  {
    v6[5] = v2;
    v6[6] = v3;
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __sec_protocol_options_are_equal_block_invoke;
    v6[3] = &__block_descriptor_tmp_8;
    v6[4] = optionsB;
    return sec_protocol_options_access_handle((uint64_t)optionsA, (uint64_t)v6);
  }
  return v4;
}

uint64_t __sec_protocol_options_are_equal_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[5];

  v2 = *(_QWORD *)(a1 + 32);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __sec_protocol_options_are_equal_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_7;
  v4[4] = a2;
  return sec_protocol_options_access_handle(v2, (uint64_t)v4);
}

uint64_t __sec_protocol_options_are_equal_block_invoke_2(uint64_t a1, unsigned __int16 *a2)
{
  return sec_protocol_options_contents_compare(*(unsigned __int16 **)(a1 + 32), a2, 0);
}

void sec_protocol_options_set_local_identity(sec_protocol_options_t options, sec_identity_t identity)
{
  _QWORD v2[5];

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_local_identity_block_invoke;
    v2[3] = &__block_descriptor_tmp_9;
    v2[4] = identity;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

BOOL __sec_protocol_options_set_local_identity_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  if (a2)
  {
    v4 = *(void **)(a2 + 56);
    if (v4)
      os_release(v4);
    v5 = *(void **)(a1 + 32);
    if (v5)
      v5 = os_retain(v5);
    *(_QWORD *)(a2 + 56) = v5;
  }
  return a2 != 0;
}

void sec_protocol_options_append_tls_ciphersuite(sec_protocol_options_t options, tls_ciphersuite_t ciphersuite)
{
  _QWORD v2[4];
  tls_ciphersuite_t v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_append_tls_ciphersuite_block_invoke;
    v2[3] = &__block_descriptor_tmp_10;
    v3 = ciphersuite;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

BOOL __sec_protocol_options_append_tls_ciphersuite_block_invoke(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4;

  if (a2)
  {
    v4 = *(xpc_object_t *)(a2 + 40);
    if (!v4)
    {
      v4 = xpc_array_create(0, 0);
      *(_QWORD *)(a2 + 40) = v4;
    }
    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, *(unsigned __int16 *)(a1 + 32));
  }
  return a2 != 0;
}

void sec_protocol_options_add_tls_ciphersuite(sec_protocol_options_t options, SSLCipherSuite ciphersuite)
{
  _QWORD v2[4];
  SSLCipherSuite v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_append_tls_ciphersuite_block_invoke;
    v2[3] = &__block_descriptor_tmp_10;
    v3 = ciphersuite;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

BOOL __sec_protocol_options_clear_tls_ciphersuites_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v3;

  if (a2)
  {
    v3 = *(void **)(a2 + 40);
    if (v3)
    {
      xpc_release(v3);
      *(_QWORD *)(a2 + 40) = 0;
    }
  }
  return a2 != 0;
}

tls_protocol_version_t sec_protocol_options_get_default_min_tls_protocol_version(void)
{
  return 769;
}

tls_protocol_version_t sec_protocol_options_get_default_min_dtls_protocol_version(void)
{
  return -257;
}

void sec_protocol_options_set_tls_max_version(sec_protocol_options_t options, SSLProtocol version)
{
  uint64_t v2;
  int *v3;
  int v4;
  __int16 v5;
  _QWORD v6[4];
  __int16 v7;

  v2 = 0;
  v3 = ssl_protocol_version_map;
  while (1)
  {
    v4 = *v3;
    v3 += 2;
    if (v4 == version)
      break;
    if (++v2 == 8)
      return;
  }
  if (v2 != 7)
  {
    if (options)
    {
      v5 = ssl_protocol_version_map[2 * v2 + 1];
      v6[0] = MEMORY[0x1E0C809B0];
      v6[1] = 0x40000000;
      v6[2] = __sec_protocol_options_set_max_tls_protocol_version_block_invoke;
      v6[3] = &__block_descriptor_tmp_15;
      v7 = v5;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v6);
    }
  }
}

BOOL __sec_protocol_options_set_max_tls_protocol_version_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_WORD *)(a2 + 2) = *(_WORD *)(a1 + 32);
  return a2 != 0;
}

void sec_protocol_options_set_max_tls_protocol_version(sec_protocol_options_t options, tls_protocol_version_t version)
{
  _QWORD v2[4];
  tls_protocol_version_t v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_max_tls_protocol_version_block_invoke;
    v2[3] = &__block_descriptor_tmp_15;
    v3 = version;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

tls_protocol_version_t sec_protocol_options_get_default_max_tls_protocol_version(void)
{
  return 772;
}

tls_protocol_version_t sec_protocol_options_get_default_max_dtls_protocol_version(void)
{
  return -259;
}

void sec_protocol_options_add_tls_application_protocol(sec_protocol_options_t options, const char *application_protocol)
{
  _QWORD v2[5];

  if (options)
  {
    if (application_protocol)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_add_tls_application_protocol_block_invoke;
      v2[3] = &__block_descriptor_tmp_18;
      v2[4] = application_protocol;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
    }
  }
}

BOOL __sec_protocol_options_add_tls_application_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4;

  if (a2)
  {
    v4 = *(xpc_object_t *)(a2 + 48);
    if (!v4)
    {
      v4 = xpc_array_create(0, 0);
      *(_QWORD *)(a2 + 48) = v4;
    }
    xpc_array_set_string(v4, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(a1 + 32));
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_clear_tls_application_protocols(uint64_t result)
{
  if (result)
    return sec_protocol_options_access_handle(result, (uint64_t)&__block_literal_global_20);
  return result;
}

BOOL __sec_protocol_options_clear_tls_application_protocols_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v3;

  if (a2)
  {
    v3 = *(void **)(a2 + 48);
    if (v3)
      xpc_release(v3);
    *(_QWORD *)(a2 + 48) = 0;
  }
  return a2 != 0;
}

void sec_protocol_options_set_tls_diffie_hellman_parameters(sec_protocol_options_t options, dispatch_data_t params)
{
  _QWORD v2[5];

  if (options)
  {
    if (params)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_set_tls_diffie_hellman_parameters_block_invoke;
      v2[3] = &__block_descriptor_tmp_24;
      v2[4] = params;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
    }
  }
}

BOOL __sec_protocol_options_set_tls_diffie_hellman_parameters_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v4;

  if (a2)
  {
    v4 = *(NSObject **)(a2 + 224);
    if (v4)
      dispatch_release(v4);
    *(_QWORD *)(a2 + 224) = *(_QWORD *)(a1 + 32);
    dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  }
  return a2 != 0;
}

void sec_protocol_options_add_pre_shared_key(sec_protocol_options_t options, dispatch_data_t psk, dispatch_data_t psk_identity)
{
  _QWORD v3[6];

  if (options && psk)
  {
    if (psk_identity)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 0x40000000;
      v3[2] = __sec_protocol_options_add_pre_shared_key_block_invoke;
      v3[3] = &__block_descriptor_tmp_25;
      v3[4] = psk;
      v3[5] = psk_identity;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
    }
  }
}

BOOL __sec_protocol_options_add_pre_shared_key_block_invoke(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4;
  xpc_object_t v5;
  xpc_object_t v6;

  if (a2)
  {
    if (!*(_QWORD *)(a2 + 72))
      *(_QWORD *)(a2 + 72) = xpc_array_create(0, 0);
    v4 = xpc_data_create_with_dispatch_data(*(dispatch_data_t *)(a1 + 32));
    v5 = xpc_data_create_with_dispatch_data(*(dispatch_data_t *)(a1 + 40));
    v6 = xpc_array_create(0, 0);
    xpc_array_set_value(v6, 0xFFFFFFFFFFFFFFFFLL, v4);
    xpc_array_set_value(v6, 0xFFFFFFFFFFFFFFFFLL, v5);
    xpc_release(v4);
    xpc_release(v5);
    xpc_array_set_value(*(xpc_object_t *)(a2 + 72), 0xFFFFFFFFFFFFFFFFLL, v6);
    xpc_release(v6);
  }
  return a2 != 0;
}

void sec_protocol_options_set_tls_pre_shared_key_identity_hint(sec_protocol_options_t options, dispatch_data_t psk_identity_hint)
{
  _QWORD v2[5];

  if (options)
  {
    if (psk_identity_hint)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_set_tls_pre_shared_key_identity_hint_block_invoke;
      v2[3] = &__block_descriptor_tmp_26;
      v2[4] = psk_identity_hint;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
    }
  }
}

BOOL __sec_protocol_options_set_tls_pre_shared_key_identity_hint_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v4;

  if (a2)
  {
    v4 = *(NSObject **)(a2 + 80);
    if (v4)
      dispatch_release(v4);
    *(_QWORD *)(a2 + 80) = *(_QWORD *)(a1 + 32);
    dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  }
  return a2 != 0;
}

void sec_protocol_options_set_pre_shared_key_selection_block(sec_protocol_options_t options, sec_protocol_pre_shared_key_selection_t psk_selection_block, dispatch_queue_t psk_selection_queue)
{
  _QWORD v3[6];

  if (options && psk_selection_block)
  {
    if (psk_selection_queue)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 0x40000000;
      v3[2] = __sec_protocol_options_set_pre_shared_key_selection_block_block_invoke;
      v3[3] = &unk_1E1FCC650;
      v3[4] = psk_selection_block;
      v3[5] = psk_selection_queue;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
    }
  }
}

BOOL __sec_protocol_options_set_pre_shared_key_selection_block_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  NSObject *v5;
  void *v6;
  NSObject *v7;

  if (a2)
  {
    v4 = *(const void **)(a2 + 256);
    if (v4)
      _Block_release(v4);
    v5 = *(NSObject **)(a2 + 264);
    if (v5)
      dispatch_release(v5);
    v6 = _Block_copy(*(const void **)(a1 + 32));
    v7 = *(NSObject **)(a1 + 40);
    *(_QWORD *)(a2 + 256) = v6;
    *(_QWORD *)(a2 + 264) = v7;
    dispatch_retain(v7);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_early_data_enabled(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_early_data_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_32_2822;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_tls_early_data_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFE7FFFFF | (*(unsigned __int8 *)(a1 + 32) << 23) | 0x1000000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFE7FFFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_quic_early_data_context(uint64_t result, uint64_t a2, uint64_t a3)
{
  _QWORD v3[6];

  if (result)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 0x40000000;
    v3[2] = __sec_protocol_options_set_quic_early_data_context_block_invoke;
    v3[3] = &__block_descriptor_tmp_33;
    v3[4] = a3;
    v3[5] = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v3);
  }
  return result;
}

BOOL __sec_protocol_options_set_quic_early_data_context_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  if (a2)
  {
    v4 = *(void **)(a2 + 336);
    if (v4)
    {
      free(v4);
      *(_QWORD *)(a2 + 352) = 0;
    }
    v5 = malloc_type_malloc(*(_QWORD *)(a1 + 32), 0x100004077774924uLL);
    *(_QWORD *)(a2 + 336) = v5;
    if (v5)
    {
      memcpy(v5, *(const void **)(a1 + 40), *(_QWORD *)(a1 + 32));
      *(_QWORD *)(a2 + 352) = *(_QWORD *)(a1 + 32);
    }
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_nw_protocol_joining_context(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_nw_protocol_joining_context_block_invoke;
    v2[3] = &__block_descriptor_tmp_34;
    v2[4] = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_nw_protocol_joining_context_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(a2 + 344) = *(_QWORD *)(a1 + 32);
  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_sni_disabled(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_sni_disabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_35;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_tls_sni_disabled_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFFFFFFFFFFFFF9FLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32);
    *(_DWORD *)(a2 + 361) = v2 & 0xFFFFFF9F | (32 * *(_BYTE *)(a1 + 32)) | 0x40;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_enforce_ev(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_enforce_ev_block_invoke;
    v2[3] = &__block_descriptor_tmp_36_2823;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_enforce_ev_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFF9FFFF | (*(unsigned __int8 *)(a1 + 32) << 17) | 0x40000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFF9FFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }
  return a2 != 0;
}

void sec_protocol_options_set_tls_ocsp_enabled(sec_protocol_options_t options, BOOL ocsp_enabled)
{
  _QWORD v2[4];
  BOOL v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_ocsp_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_37;
    v3 = ocsp_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

BOOL __sec_protocol_options_set_tls_ocsp_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFFE7FFF | (*(unsigned __int8 *)(a1 + 32) << 15) | 0x10000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFFE7FFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }
  return a2 != 0;
}

void sec_protocol_options_set_tls_sct_enabled(sec_protocol_options_t options, BOOL sct_enabled)
{
  _QWORD v2[4];
  BOOL v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_sct_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_38;
    v3 = sct_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

BOOL __sec_protocol_options_set_tls_sct_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFFF9FFF | (*(unsigned __int8 *)(a1 + 32) << 13) | 0x4000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFFFF9FFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }
  return a2 != 0;
}

void sec_protocol_options_set_tls_renegotiation_enabled(sec_protocol_options_t options, BOOL renegotiation_enabled)
{
  _QWORD v2[4];
  BOOL v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_renegotiation_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_39;
    v3 = renegotiation_enabled;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

BOOL __sec_protocol_options_set_tls_renegotiation_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFF9FFFFF | (*(unsigned __int8 *)(a1 + 32) << 21) | 0x400000;
    *(_BYTE *)(a2 + 365) = (v2 & 0xFFFFFFFFFF9FFFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) >> 32;
    *(_DWORD *)(a2 + 361) = v3;
  }
  return a2 != 0;
}

void sec_protocol_options_set_peer_authentication_required(sec_protocol_options_t options, BOOL peer_authentication_required)
{
  _QWORD v2[4];
  BOOL v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_peer_authentication_required_block_invoke;
    v2[3] = &__block_descriptor_tmp_40;
    v3 = peer_authentication_required;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

BOOL __sec_protocol_options_set_peer_authentication_required_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFFFFFFFFBFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 26);
    *(_DWORD *)(a2 + 361) = v2 & 0xFBFFFFFF | (*(unsigned __int8 *)(a1 + 32) << 26) | 0x10000000;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }
  return a2 != 0;
}

void sec_protocol_options_set_peer_authentication_optional(sec_protocol_options_t options, BOOL peer_authentication_optional)
{
  _QWORD v2[4];
  BOOL v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_peer_authentication_optional_block_invoke;
    v2[3] = &__block_descriptor_tmp_41_2824;
    v3 = peer_authentication_optional;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

BOOL __sec_protocol_options_set_peer_authentication_optional_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFFFFFFFE7FFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 27);
    *(_DWORD *)(a2 + 361) = v2 & 0xE7FFFFFF | (*(unsigned __int8 *)(a1 + 32) << 27) | 0x10000000;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }
  return a2 != 0;
}

void sec_protocol_options_set_enable_encrypted_client_hello(sec_protocol_options_t options, BOOL enable_encrypted_client_hello)
{
  _QWORD v2[4];
  BOOL v3;

  if (options)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_enable_encrypted_client_hello_block_invoke;
    v2[3] = &__block_descriptor_tmp_42;
    v3 = enable_encrypted_client_hello;
    sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v2);
  }
}

BOOL __sec_protocol_options_set_enable_encrypted_client_hello_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2;

  if (a2)
  {
    v2 = *(_DWORD *)(a2 + 361) & 0xFDFFFFFF | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 25);
    *(_DWORD *)(a2 + 361) = *(_DWORD *)(a2 + 361) & 0xFDFFFFFF | (*(unsigned __int8 *)(a1 + 32) << 25);
    *(_BYTE *)(a2 + 365) = BYTE4(v2);
  }
  return a2 != 0;
}

void sec_protocol_options_set_key_update_block(sec_protocol_options_t options, sec_protocol_key_update_t key_update_block, dispatch_queue_t key_update_queue)
{
  _QWORD v3[6];

  if (options)
  {
    if (key_update_queue)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 0x40000000;
      v3[2] = __sec_protocol_options_set_key_update_block_block_invoke;
      v3[3] = &unk_1E1FCC878;
      v3[4] = key_update_block;
      v3[5] = key_update_queue;
      sec_protocol_options_access_handle((uint64_t)options, (uint64_t)v3);
    }
  }
}

BOOL __sec_protocol_options_set_key_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  NSObject *v5;
  NSObject *v6;

  if (a2)
  {
    v4 = *(const void **)(a2 + 88);
    if (v4)
      _Block_release(v4);
    v5 = *(NSObject **)(a2 + 96);
    if (v5)
      dispatch_release(v5);
    *(_QWORD *)(a2 + 88) = _Block_copy(*(const void **)(a1 + 32));
    v6 = _Block_copy(*(const void **)(a1 + 40));
    *(_QWORD *)(a2 + 96) = v6;
    dispatch_retain(v6);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_session_state(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_set_session_state_block_invoke;
      v2[3] = &__block_descriptor_tmp_50;
      v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }
  return result;
}

BOOL __sec_protocol_options_set_session_state_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v4;

  if (a2)
  {
    v4 = *(NSObject **)(a2 + 192);
    if (v4)
      dispatch_release(v4);
    *(_QWORD *)(a2 + 192) = *(_QWORD *)(a1 + 32);
    dispatch_retain(*(dispatch_object_t *)(a1 + 32));
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_ats_required(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_ats_required_block_invoke;
    v2[3] = &__block_descriptor_tmp_52;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_ats_required_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_DWORD *)(a2 + 361) = *(_DWORD *)(a2 + 361) & 0xFFFFFFFE | *(unsigned __int8 *)(a1 + 32);
  return a2 != 0;
}

uint64_t sec_protocol_options_set_minimum_rsa_key_size(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_minimum_rsa_key_size_block_invoke;
    v2[3] = &__block_descriptor_tmp_53;
    v2[4] = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_minimum_rsa_key_size_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(a2 + 304) = *(_QWORD *)(a1 + 32);
  return a2 != 0;
}

uint64_t sec_protocol_options_set_minimum_ecdsa_key_size(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_minimum_ecdsa_key_size_block_invoke;
    v2[3] = &__block_descriptor_tmp_54;
    v2[4] = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_minimum_ecdsa_key_size_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(a2 + 312) = *(_QWORD *)(a1 + 32);
  return a2 != 0;
}

uint64_t sec_protocol_options_set_minimum_signature_algorithm(uint64_t result, int a2)
{
  _QWORD v2[4];
  int v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_minimum_signature_algorithm_block_invoke;
    v2[3] = &__block_descriptor_tmp_55;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_minimum_signature_algorithm_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_DWORD *)(a2 + 320) = *(_DWORD *)(a1 + 32);
  return a2 != 0;
}

uint64_t sec_protocol_options_set_trusted_peer_certificate(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_trusted_peer_certificate_block_invoke;
    v2[3] = &__block_descriptor_tmp_56_2827;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_trusted_peer_certificate_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFFFFFFFFFFFFFE7 | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32);
    *(_DWORD *)(a2 + 361) = v2 & 0xFFFFFFE7 | (8 * *(_BYTE *)(a1 + 32)) | 0x10;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_private_key_blocks(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v4[7];

  if (result && a2 && a3)
  {
    if (a4)
    {
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 0x40000000;
      v4[2] = __sec_protocol_options_set_private_key_blocks_block_invoke;
      v4[3] = &unk_1E1FCCA48;
      v4[4] = a2;
      v4[5] = a3;
      v4[6] = a4;
      return sec_protocol_options_access_handle(result, (uint64_t)v4);
    }
  }
  return result;
}

BOOL __sec_protocol_options_set_private_key_blocks_block_invoke(uint64_t a1, _QWORD *a2)
{
  const void *v4;
  const void *v5;
  NSObject *v6;
  void *v7;
  NSObject *v8;

  if (a2)
  {
    v4 = (const void *)a2[25];
    if (v4)
      _Block_release(v4);
    v5 = (const void *)a2[26];
    if (v5)
      _Block_release(v5);
    v6 = a2[27];
    if (v6)
      dispatch_release(v6);
    a2[25] = _Block_copy(*(const void **)(a1 + 32));
    v7 = _Block_copy(*(const void **)(a1 + 40));
    v8 = *(NSObject **)(a1 + 48);
    a2[26] = v7;
    a2[27] = v8;
    dispatch_retain(v8);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_local_certificates(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_set_local_certificates_block_invoke;
      v2[3] = &__block_descriptor_tmp_58;
      v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }
  return result;
}

BOOL __sec_protocol_options_set_local_certificates_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;

  if (a2)
  {
    v4 = *(void **)(a2 + 64);
    if (v4)
      os_release(v4);
    v5 = *(void **)(a1 + 32);
    *(_QWORD *)(a2 + 64) = v5;
    if (v5)
      os_retain(v5);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_tls_handshake_message_callback(uint64_t result, uint64_t a2, uint64_t a3)
{
  _QWORD v3[6];

  if (result && a2)
  {
    if (a3)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 0x40000000;
      v3[2] = __sec_protocol_options_tls_handshake_message_callback_block_invoke;
      v3[3] = &unk_1E1FCCAD8;
      v3[4] = a2;
      v3[5] = a3;
      return sec_protocol_options_access_handle(result, (uint64_t)v3);
    }
  }
  return result;
}

BOOL __sec_protocol_options_tls_handshake_message_callback_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  NSObject *v5;
  void *v6;
  NSObject *v7;

  if (a2)
  {
    v4 = *(const void **)(a2 + 240);
    if (v4)
      _Block_release(v4);
    v5 = *(NSObject **)(a2 + 248);
    if (v5)
      dispatch_release(v5);
    v6 = _Block_copy(*(const void **)(a1 + 32));
    v7 = *(NSObject **)(a1 + 40);
    *(_QWORD *)(a2 + 240) = v6;
    *(_QWORD *)(a2 + 248) = v7;
    dispatch_retain(v7);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_eddsa_enabled(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_eddsa_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_62;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_eddsa_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2;

  if (a2)
  {
    v2 = *(_DWORD *)(a2 + 361) & 0x7FFFFFFF | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 31);
    *(_DWORD *)(a2 + 361) = *(_DWORD *)(a2 + 361) & 0x7FFFFFFF | (*(unsigned __int8 *)(a1 + 32) << 31);
    *(_BYTE *)(a2 + 365) = BYTE4(v2);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_delegated_credentials_enabled(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_delegated_credentials_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_63;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_tls_delegated_credentials_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = (v2 | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) & 0xFFFFFFFEFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 32);
    *(_DWORD *)(a2 + 361) = v2;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_grease_enabled(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_grease_enabled_block_invoke;
    v2[3] = &__block_descriptor_tmp_64;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_tls_grease_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = (v2 | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32)) & 0xFFFFFFFDFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a1 + 32) << 33);
    *(_DWORD *)(a2 + 361) = v2;
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_experiment_identifier(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_set_experiment_identifier_block_invoke;
      v2[3] = &__block_descriptor_tmp_66;
      v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }
  return result;
}

BOOL __sec_protocol_options_set_experiment_identifier_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  const char *v5;

  if (a2)
  {
    v4 = *(void **)(a2 + 16);
    if (v4)
      free(v4);
    v5 = *(const char **)(a1 + 32);
    if (v5)
      *(_QWORD *)(a2 + 16) = strdup(v5);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_connection_id(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_set_connection_id_block_invoke;
      v2[3] = &__block_descriptor_tmp_67;
      v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }
  return result;
}

BOOL __sec_protocol_options_set_connection_id_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_OWORD *)(a2 + 24) = *(_OWORD *)*(_QWORD *)(a1 + 32);
  return a2 != 0;
}

uint64_t sec_protocol_options_set_tls_ticket_request_count(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_ticket_request_count_block_invoke;
    v2[3] = &__block_descriptor_tmp_68;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_tls_ticket_request_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_BYTE *)(a2 + 324) = *(_BYTE *)(a1 + 32);
  return a2 != 0;
}

uint64_t sec_protocol_options_set_ats_non_pfs_ciphersuite_allowed(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_ats_non_pfs_ciphersuite_allowed_block_invoke;
    v2[3] = &__block_descriptor_tmp_69;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_ats_non_pfs_ciphersuite_allowed_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFFFFFFFFFFFFFFBLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32);
    *(_DWORD *)(a2 + 361) = v2 & 0xFFFFFFFB | (4 * (*(_BYTE *)(a1 + 32) & 0x3F));
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_set_ats_minimum_tls_version_allowed(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_ats_minimum_tls_version_allowed_block_invoke;
    v2[3] = &__block_descriptor_tmp_70;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_ats_minimum_tls_version_allowed_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;

  if (a2)
  {
    v2 = *(unsigned int *)(a2 + 361);
    v3 = v2 & 0xFFFFFFFFFFFFFFFDLL | ((unint64_t)*(unsigned __int8 *)(a2 + 365) << 32);
    *(_DWORD *)(a2 + 361) = v2 & 0xFFFFFFFD | (2 * (*(_BYTE *)(a1 + 32) & 0x7F));
    *(_BYTE *)(a2 + 365) = BYTE4(v3);
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_append_tls_key_exchange_group(uint64_t result, __int16 a2)
{
  _QWORD v2[4];
  __int16 v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_append_tls_key_exchange_group_block_invoke;
    v2[3] = &__block_descriptor_tmp_71;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_append_tls_key_exchange_group_block_invoke(uint64_t a1, uint64_t a2)
{
  xpc_object_t v4;

  if (a2)
  {
    v4 = *(xpc_object_t *)(a2 + 232);
    if (!v4)
    {
      v4 = xpc_array_create(0, 0);
      *(_QWORD *)(a2 + 232) = v4;
    }
    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, *(unsigned __int16 *)(a1 + 32));
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_add_tls_key_exchange_group(uint64_t result, __int16 a2)
{
  _QWORD v2[4];
  __int16 v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_append_tls_key_exchange_group_block_invoke;
    v2[3] = &__block_descriptor_tmp_71;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

uint64_t sec_protocol_options_append_tls_key_exchange_group_set(uint64_t result, __int16 a2)
{
  _QWORD v2[4];
  __int16 v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_append_tls_key_exchange_group_set_block_invoke;
    v2[3] = &__block_descriptor_tmp_72;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_append_tls_key_exchange_group_set_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  unsigned __int16 *v6;
  unsigned int v7;

  if (a2)
  {
    if (!*(_QWORD *)(a2 + 232))
      *(_QWORD *)(a2 + 232) = xpc_array_create(0, 0);
    v4 = *(unsigned __int16 *)(a1 + 32);
    if (v4 <= 2)
    {
      v5 = qword_18AA5ABA0[v4];
      v6 = (unsigned __int16 *)*(&off_1E1FCD8C0 + v4);
      do
      {
        v7 = *v6++;
        xpc_array_set_uint64(*(xpc_object_t *)(a2 + 232), 0xFFFFFFFFFFFFFFFFLL, v7);
        --v5;
      }
      while (v5);
    }
  }
  return a2 != 0;
}

uint64_t sec_protocol_options_add_tls_key_exchange_group_set(uint64_t result, int a2)
{
  __int16 v2;
  uint64_t v3;
  uint64_t v4;
  BOOL (*v5)(uint64_t, uint64_t);
  void *v6;
  __int16 v7;

  if (a2 == 2)
  {
    if (!result)
      return result;
    v3 = MEMORY[0x1E0C809B0];
    v4 = 0x40000000;
    v5 = __sec_protocol_options_append_tls_key_exchange_group_set_block_invoke;
    v6 = &__block_descriptor_tmp_72;
    v2 = 2;
LABEL_10:
    v7 = v2;
    return sec_protocol_options_access_handle(result, (uint64_t)&v3);
  }
  if (a2 == 1)
  {
    if (!result)
      return result;
    v3 = MEMORY[0x1E0C809B0];
    v4 = 0x40000000;
    v5 = __sec_protocol_options_append_tls_key_exchange_group_set_block_invoke;
    v6 = &__block_descriptor_tmp_72;
    v2 = 1;
    goto LABEL_10;
  }
  if (!a2 && result)
  {
    v3 = MEMORY[0x1E0C809B0];
    v4 = 0x40000000;
    v5 = __sec_protocol_options_append_tls_key_exchange_group_set_block_invoke;
    v6 = &__block_descriptor_tmp_72;
    v7 = 0;
    return sec_protocol_options_access_handle(result, (uint64_t)&v3);
  }
  return result;
}

const char *__cdecl sec_protocol_metadata_get_server_name(sec_protocol_metadata_t metadata)
{
  const char *v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!metadata)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_server_name_block_invoke;
  v3[3] = &unk_1E1FCCC88;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
  v1 = (const char *)v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_server_name_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 48);
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_time_ms(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_handshake_time_ms_block_invoke;
  v3[3] = &unk_1E1FCCCB0;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_time_ms_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 264);
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_byte_count(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_handshake_byte_count_block_invoke;
  v3[3] = &unk_1E1FCCCD8;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_byte_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 272);
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_sent_byte_count(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_handshake_sent_byte_count_block_invoke;
  v3[3] = &unk_1E1FCCD00;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_sent_byte_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 280);
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_received_byte_count(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_handshake_received_byte_count_block_invoke;
  v3[3] = &unk_1E1FCCD28;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_received_byte_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 288);
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_read_stall_count(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_handshake_read_stall_count_block_invoke;
  v3[3] = &unk_1E1FCCD50;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_read_stall_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 296);
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_write_stall_count(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_handshake_write_stall_count_block_invoke;
  v3[3] = &unk_1E1FCCD78;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_write_stall_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 304);
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_async_call_count(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_handshake_async_call_count_block_invoke;
  v3[3] = &unk_1E1FCCDA0;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_async_call_count_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 312);
  return a2 != 0;
}

dispatch_data_t sec_protocol_metadata_copy_peer_public_key(sec_protocol_metadata_t metadata)
{
  NSObject *v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!metadata)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_copy_peer_public_key_block_invoke;
  v3[3] = &unk_1E1FCCE18;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_copy_peer_public_key_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v3;

  if (a2)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 104);
    v3 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v3)
      dispatch_retain(v3);
  }
  return a2 != 0;
}

BOOL sec_protocol_metadata_access_supported_signature_algorithms(sec_protocol_metadata_t metadata, void *handler)
{
  BOOL v2;
  _QWORD v4[5];

  v2 = 0;
  if (metadata && handler)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __sec_protocol_metadata_access_supported_signature_algorithms_block_invoke;
    v4[3] = &unk_1E1FCCF20;
    v4[4] = handler;
    return sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v4);
  }
  return v2;
}

uint64_t __sec_protocol_metadata_access_supported_signature_algorithms_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD applier[5];

  if (!a2)
    return 0;
  result = *(_QWORD *)(a2 + 112);
  if (result)
  {
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 0x40000000;
    applier[2] = __sec_protocol_metadata_access_supported_signature_algorithms_block_invoke_2;
    applier[3] = &unk_1E1FCCEF8;
    applier[4] = *(_QWORD *)(a1 + 32);
    xpc_array_apply((xpc_object_t)result, applier);
    return 1;
  }
  return result;
}

uint64_t __sec_protocol_metadata_access_supported_signature_algorithms_block_invoke_2(uint64_t a1, int a2, xpc_object_t xuint)
{
  uint64_t v3;
  unsigned __int16 value;

  v3 = *(_QWORD *)(a1 + 32);
  value = xpc_uint64_get_value(xuint);
  (*(void (**)(uint64_t, _QWORD))(v3 + 16))(v3, value);
  return 1;
}

BOOL sec_protocol_metadata_access_ocsp_response(sec_protocol_metadata_t metadata, void *handler)
{
  BOOL v2;
  _QWORD v4[5];

  v2 = 0;
  if (metadata && handler)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __sec_protocol_metadata_access_ocsp_response_block_invoke;
    v4[3] = &unk_1E1FCCF70;
    v4[4] = handler;
    return sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v4);
  }
  return v2;
}

uint64_t __sec_protocol_metadata_access_ocsp_response_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD v4[5];

  if (!a2)
    return 0;
  result = *(_QWORD *)(a2 + 136);
  if (result)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __sec_protocol_metadata_access_ocsp_response_block_invoke_2;
    v4[3] = &unk_1E1FCCF48;
    v4[4] = *(_QWORD *)(a1 + 32);
    sec_array_apply((void *)result, v4);
    return 1;
  }
  return result;
}

uint64_t __sec_protocol_metadata_access_ocsp_response_block_invoke_2(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return 1;
}

uint64_t __sec_protocol_metadata_access_distinguished_names_block_invoke_2(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return 1;
}

BOOL sec_protocol_metadata_access_pre_shared_keys(sec_protocol_metadata_t metadata, void *handler)
{
  BOOL v2;
  _QWORD v4[5];

  v2 = 0;
  if (metadata && handler)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __sec_protocol_metadata_access_pre_shared_keys_block_invoke;
    v4[3] = &unk_1E1FCD010;
    v4[4] = handler;
    return sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v4);
  }
  return v2;
}

uint64_t __sec_protocol_metadata_access_pre_shared_keys_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD applier[5];

  if (!a2)
    return 0;
  result = *(_QWORD *)(a2 + 96);
  if (result)
  {
    applier[0] = MEMORY[0x1E0C809B0];
    applier[1] = 0x40000000;
    applier[2] = __sec_protocol_metadata_access_pre_shared_keys_block_invoke_2;
    applier[3] = &unk_1E1FCCFE8;
    applier[4] = *(_QWORD *)(a1 + 32);
    xpc_array_apply((xpc_object_t)result, applier);
    return 1;
  }
  return result;
}

uint64_t __sec_protocol_metadata_access_pre_shared_keys_block_invoke_2(uint64_t a1, int a2, xpc_object_t xarray)
{
  NSObject *value;
  NSObject *v6;
  dispatch_data_t dispatch_data_from_xpc_data;
  dispatch_data_t v8;
  uint64_t result;

  if (xpc_array_get_count(xarray) != 2)
    return 1;
  value = xpc_array_get_value(xarray, 0);
  v6 = xpc_array_get_value(xarray, 1uLL);
  dispatch_data_from_xpc_data = create_dispatch_data_from_xpc_data(value);
  v8 = create_dispatch_data_from_xpc_data(v6);
  result = 0;
  if (dispatch_data_from_xpc_data && v8)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    return 1;
  }
  return result;
}

dispatch_data_t create_dispatch_data_from_xpc_data(NSObject *xdata)
{
  dispatch_data_t v1;
  size_t length;
  size_t v3;
  void *v4;
  void *v5;
  size_t bytes;

  v1 = xdata;
  if (xdata)
  {
    length = xpc_data_get_length(xdata);
    if (length && (v3 = length, (v4 = malloc_type_malloc(length, 0xABA124A2uLL)) != 0))
    {
      v5 = v4;
      bytes = xpc_data_get_bytes(v1, v4, 0, v3);
      v1 = 0;
      if (bytes == v3)
        v1 = dispatch_data_create(v5, v3, 0, 0);
      free(v5);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

BOOL sec_protocol_metadata_challenge_parameters_are_equal(sec_protocol_metadata_t metadataA, sec_protocol_metadata_t metadataB)
{
  BOOL v2;
  _QWORD v4[5];

  v2 = 0;
  if (metadataA && metadataB)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __sec_protocol_metadata_challenge_parameters_are_equal_block_invoke;
    v4[3] = &__block_descriptor_tmp_103;
    v4[4] = metadataB;
    return sec_protocol_metadata_access_handle((uint64_t)metadataA, (uint64_t)v4);
  }
  return v2;
}

uint64_t __sec_protocol_metadata_challenge_parameters_are_equal_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[5];

  if (!a2)
    return 0;
  v2 = *(_QWORD *)(a1 + 32);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __sec_protocol_metadata_challenge_parameters_are_equal_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_102;
  v4[4] = a2;
  return sec_protocol_metadata_access_handle(v2, (uint64_t)v4);
}

BOOL __sec_protocol_metadata_challenge_parameters_are_equal_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return a2
      && sec_protocol_xpc_object_are_equal(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112), *(_QWORD *)(a2 + 112))
      && sec_protocol_sec_array_of_dispatch_data_are_equal(*(void **)(*(_QWORD *)(a1 + 32) + 144), *(void **)(a2 + 144))&& sec_protocol_dispatch_data_are_equal(*(dispatch_data_t *)(*(_QWORD *)(a1 + 32) + 120), *(NSObject **)(a2 + 120));
}

dispatch_data_t sec_protocol_metadata_create_secret(sec_protocol_metadata_t metadata, size_t label_len, const char *label, size_t exporter_length)
{
  NSObject *v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v4 = 0;
  if (metadata && label_len && label && exporter_length)
  {
    v7 = 0;
    v8 = &v7;
    v9 = 0x2000000000;
    v10 = 0;
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __sec_protocol_metadata_create_secret_block_invoke;
    v6[3] = &unk_1E1FCD0B8;
    v6[4] = &v7;
    v6[5] = label_len;
    v6[6] = label;
    v6[7] = exporter_length;
    sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v6);
    v4 = v8[3];
    _Block_object_dispose(&v7, 8);
  }
  return v4;
}

BOOL __sec_protocol_metadata_create_secret_block_invoke(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

  if (a2)
  {
    v3 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a2[1];
    if (v3)
    {
      if (*a2)
        *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v3(*a2, a1[5], a1[6], 0, 0, a1[7]);
    }
  }
  return a2 != 0;
}

dispatch_data_t sec_protocol_metadata_create_secret_with_context(sec_protocol_metadata_t metadata, size_t label_len, const char *label, size_t context_len, const uint8_t *context, size_t exporter_length)
{
  NSObject *v6;
  _QWORD v8[10];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v6 = 0;
  if (metadata && label_len && label && context_len && context && exporter_length)
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2000000000;
    v12 = 0;
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __sec_protocol_metadata_create_secret_with_context_block_invoke;
    v8[3] = &unk_1E1FCD0E0;
    v8[4] = &v9;
    v8[5] = label_len;
    v8[6] = label;
    v8[7] = context_len;
    v8[8] = context;
    v8[9] = exporter_length;
    sec_protocol_metadata_access_handle((uint64_t)metadata, (uint64_t)v8);
    v6 = v10[3];
    _Block_object_dispose(&v9, 8);
  }
  return v6;
}

BOOL __sec_protocol_metadata_create_secret_with_context_block_invoke(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

  if (a2)
  {
    v3 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))a2[1];
    if (v3)
    {
      if (*a2)
        *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v3(*a2, a1[5], a1[6], a1[7], a1[8], a1[9]);
    }
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_tls_false_start_used(uint64_t result)
{
  if (result)
    return sec_protocol_metadata_access_handle(result, (uint64_t)&__block_literal_global_107);
  return result;
}

uint64_t __sec_protocol_metadata_get_tls_false_start_used_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    return (*(unsigned __int16 *)(a2 + 328) >> 4) & 1;
  else
    return 0;
}

uint64_t sec_protocol_metadata_get_ticket_offered(uint64_t result)
{
  if (result)
    return sec_protocol_metadata_access_handle(result, (uint64_t)&__block_literal_global_109);
  return result;
}

uint64_t __sec_protocol_metadata_get_ticket_offered_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    return (*(unsigned __int16 *)(a2 + 328) >> 5) & 1;
  else
    return 0;
}

uint64_t sec_protocol_metadata_get_ticket_received(uint64_t result)
{
  if (result)
    return sec_protocol_metadata_access_handle(result, (uint64_t)&__block_literal_global_111);
  return result;
}

uint64_t __sec_protocol_metadata_get_ticket_received_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    return (*(unsigned __int16 *)(a2 + 328) >> 6) & 1;
  else
    return 0;
}

uint64_t sec_protocol_metadata_get_session_resumed(uint64_t result)
{
  if (result)
    return sec_protocol_metadata_access_handle(result, (uint64_t)&__block_literal_global_113);
  return result;
}

uint64_t __sec_protocol_metadata_get_session_resumed_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    return (*(unsigned __int16 *)(a2 + 328) >> 7) & 1;
  else
    return 0;
}

uint64_t sec_protocol_metadata_get_session_renewed(uint64_t result)
{
  if (result)
    return sec_protocol_metadata_access_handle(result, (uint64_t)&__block_literal_global_115);
  return result;
}

uint64_t __sec_protocol_metadata_get_session_renewed_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    return HIBYTE(*(unsigned __int16 *)(a2 + 328)) & 1;
  else
    return 0;
}

uint64_t sec_protocol_metadata_get_connection_strength(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  int v7;

  v1 = 2;
  if (a1)
  {
    v4 = 0;
    v5 = &v4;
    v6 = 0x2000000000;
    v7 = 2;
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 0x40000000;
    v3[2] = __sec_protocol_metadata_get_connection_strength_block_invoke;
    v3[3] = &unk_1E1FCD1C8;
    v3[4] = &v4;
    sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
    v1 = *((unsigned int *)v5 + 6);
    _Block_object_dispose(&v4, 8);
  }
  return v1;
}

BOOL __sec_protocol_metadata_get_connection_strength_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;

  if (a2)
  {
    v2 = *(unsigned __int16 *)(a2 + 32);
    if (v2 < 0x303)
    {
      v3 = v2 - 769 > 1 ? 2 : 1;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v3;
    }
    else
    {
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(_DWORD *)(v4 + 24) != 2)
    {
      v5 = 0;
      v6 = *(unsigned __int16 *)(a2 + 34);
      do
        v7 = (unsigned __int16)Listtls_ciphersuite_group_legacy[v5];
      while (v7 != v6 && v5++ != 6);
      if (v7 == v6)
        *(_DWORD *)(v4 + 24) = 1;
    }
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_copy_authenticator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v4 = 0;
  if (a1 && a2)
  {
    v7 = 0;
    v8 = &v7;
    v9 = 0x2000000000;
    v10 = 0;
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __sec_protocol_metadata_copy_authenticator_block_invoke;
    v6[3] = &unk_1E1FCD218;
    v6[4] = &v7;
    v6[5] = a2;
    v6[6] = a3;
    v6[7] = a4;
    sec_protocol_metadata_access_handle(a1, (uint64_t)v6);
    v4 = v8[3];
    _Block_object_dispose(&v7, 8);
  }
  return v4;
}

BOOL __sec_protocol_metadata_copy_authenticator_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t (*v3)(uint64_t, _QWORD, _QWORD, _QWORD);
  uint64_t v5;

  if (a2)
  {
    v3 = *(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(a2 + 336);
    if (v3)
    {
      v5 = *(_QWORD *)(a2 + 352);
      if (v5)
        *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v3(v5, a1[5], a1[6], a1[7]);
    }
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_copy_authenticator_trust(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  _QWORD v7[9];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v5 = 0;
  if (a1 && a2 && a3)
  {
    v8 = 0;
    v9 = &v8;
    v10 = 0x2000000000;
    v11 = 0;
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = __sec_protocol_metadata_copy_authenticator_trust_block_invoke;
    v7[3] = &unk_1E1FCD240;
    v7[4] = &v8;
    v7[5] = a2;
    v7[6] = a3;
    v7[7] = a4;
    v7[8] = a5;
    sec_protocol_metadata_access_handle(a1, (uint64_t)v7);
    v5 = v9[3];
    _Block_object_dispose(&v8, 8);
  }
  return v5;
}

BOOL __sec_protocol_metadata_copy_authenticator_trust_block_invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t (*v3)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v5;

  if (a2)
  {
    v3 = *(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a2 + 344);
    if (v3)
    {
      v5 = *(_QWORD *)(a2 + 352);
      if (v5)
        *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v3(v5, a1[5], a1[6], a1[7], a1[8]);
    }
  }
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_experiment_identifier(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_experiment_identifier_block_invoke;
  v3[3] = &unk_1E1FCD268;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_experiment_identifier_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 56);
  return a2 != 0;
}

uint64_t sec_protocol_metadata_copy_connection_id(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_metadata_copy_connection_id_block_invoke;
      v2[3] = &__block_descriptor_tmp_121;
      v2[4] = a2;
      return sec_protocol_metadata_access_handle(result, (uint64_t)v2);
    }
  }
  return result;
}

BOOL __sec_protocol_metadata_copy_connection_id_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_OWORD *)*(_QWORD *)(a1 + 32) = *(_OWORD *)(a2 + 64);
  return a2 != 0;
}

uint64_t sec_protocol_metadata_serialize_with_options(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  xpc_object_t v10;

  v2 = 0;
  if (a1 && a2)
  {
    v7 = 0;
    v8 = &v7;
    v9 = 0x2000000000;
    v10 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    v10 = xpc_dictionary_create(0, 0, 0);
    if (v8[3])
    {
      v6[0] = MEMORY[0x1E0C809B0];
      v6[1] = 0x40000000;
      v6[2] = __sec_protocol_metadata_serialize_with_options_block_invoke;
      v6[3] = &unk_1E1FCD2D8;
      v6[4] = &v7;
      v6[5] = a2;
      sec_protocol_metadata_access_handle(a1, (uint64_t)v6);
      v2 = v8[3];
    }
    else
    {
      v2 = 0;
    }
    _Block_object_dispose(&v7, 8);
  }
  return v2;
}

uint64_t __sec_protocol_metadata_serialize_with_options_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[6];

  if (!a2)
    return 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __sec_protocol_metadata_serialize_with_options_block_invoke_2;
  v4[3] = &unk_1E1FCD2B0;
  v2 = *(_QWORD *)(a1 + 40);
  v4[4] = *(_QWORD *)(a1 + 32);
  v4[5] = a2;
  return sec_protocol_options_access_handle(v2, (uint64_t)v4);
}

BOOL __sec_protocol_metadata_serialize_with_options_block_invoke_2(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;

  if (a2)
  {
    v3 = *(_QWORD *)(a1 + 40);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v5 = *(void **)(v4 + 24);
    if ((*(_WORD *)(v3 + 328) & 1) != 0)
    {
      xpc_dictionary_set_uint64(*(xpc_object_t *)(v4 + 24), "alert_type", *(_QWORD *)(v3 + 216));
      xpc_dictionary_set_uint64(v5, "alert_code", *(_QWORD *)(v3 + 224));
      xpc_dictionary_set_uint64(v5, "handshake_state", *(_QWORD *)(v3 + 232));
      xpc_dictionary_set_uint64(v5, "stack_error", *(_QWORD *)(v3 + 240));
    }
    else
    {
      _serialize_options(*(void **)(v4 + 24), a2);
      xpc_dictionary_set_uint64(v5, "cipher_name", *(unsigned __int16 *)(v3 + 34));
      xpc_dictionary_set_uint64(v5, "version", *(unsigned __int16 *)(v3 + 32));
      xpc_dictionary_set_uint64(v5, "ticket_lifetime", *(_QWORD *)(v3 + 200));
      if (*(_QWORD *)(v3 + 184))
        v6 = *(const char **)(v3 + 184);
      else
        v6 = "none";
      xpc_dictionary_set_string(v5, "peer_public_key_type", v6);
      if (*(_QWORD *)(v3 + 176))
        v7 = *(const char **)(v3 + 176);
      else
        v7 = "none";
      xpc_dictionary_set_string(v5, "neg_curve", v7);
      if (*(_QWORD *)(v3 + 192))
        v8 = *(const char **)(v3 + 192);
      else
        v8 = "none";
      xpc_dictionary_set_string(v5, "cert_request_type", v8);
      if (*(_QWORD *)(v3 + 40))
        v9 = *(const char **)(v3 + 40);
      else
        v9 = "none";
      xpc_dictionary_set_string(v5, "negotiated_protocol", v9);
      xpc_dictionary_set_BOOL(v5, "false_start_used", (*(_WORD *)(v3 + 328) & 0x10) != 0);
      xpc_dictionary_set_BOOL(v5, "session_resumed", (*(_WORD *)(v3 + 328) & 0x80) != 0);
      xpc_dictionary_set_BOOL(v5, "ticket_offered", (*(_WORD *)(v3 + 328) & 0x20) != 0);
      xpc_dictionary_set_BOOL(v5, "ticket_received", (*(_WORD *)(v3 + 328) & 0x40) != 0);
      xpc_dictionary_set_BOOL(v5, "session_renewed", *(_WORD *)(v3 + 328) & 0x100);
      xpc_dictionary_set_BOOL(v5, "resumption_attempted", (*(_WORD *)(v3 + 328) & 0x200) != 0);
      xpc_dictionary_set_BOOL(v5, "alpn_used", (*(_WORD *)(v3 + 328) & 0x400) != 0);
      xpc_dictionary_set_BOOL(v5, "npn_used", (*(_WORD *)(v3 + 328) & 0x800) != 0);
      xpc_dictionary_set_BOOL(v5, "ocsp_enabled", (*(_WORD *)(v3 + 328) & 4) != 0);
      xpc_dictionary_set_BOOL(v5, "ocsp_received", *(_QWORD *)(v3 + 136) != 0);
      xpc_dictionary_set_BOOL(v5, "sct_enabled", (*(_WORD *)(v3 + 328) & 2) != 0);
      xpc_dictionary_set_BOOL(v5, "sct_received", *(_QWORD *)(v3 + 128) != 0);
    }
  }
  return a2 != 0;
}

void _serialize_options(void *a1, unsigned __int16 *a2)
{
  xpc_dictionary_set_uint64(a1, "min_version", *a2);
  xpc_dictionary_set_uint64(a1, "max_version", a2[1]);
  xpc_dictionary_set_uint64(a1, "minimum_rsa_key_size", *((_QWORD *)a2 + 38));
  xpc_dictionary_set_uint64(a1, "minimum_ecdsa_key_size", *((_QWORD *)a2 + 39));
  xpc_dictionary_set_uint64(a1, "minimum_signature_algorithm", *((unsigned int *)a2 + 80));
  xpc_dictionary_set_uint64(a1, "tls_ticket_request_count", *((unsigned __int8 *)a2 + 324));
  xpc_dictionary_set_BOOL(a1, "ats_required", *(_DWORD *)((_BYTE *)a2 + 361) & 1);
  xpc_dictionary_set_BOOL(a1, "ats_minimum_tls_version_allowed", (*(_DWORD *)((_BYTE *)a2 + 361) & 2) != 0);
  xpc_dictionary_set_BOOL(a1, "ats_non_pfs_ciphersuite_allowed", (*(_DWORD *)((_BYTE *)a2 + 361) & 4) != 0);
  xpc_dictionary_set_BOOL(a1, "trusted_peer_certificate", (*(_DWORD *)((_BYTE *)a2 + 361) & 8) != 0);
  xpc_dictionary_set_BOOL(a1, "disable_sni", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x20) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_fallback_attempt", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x80) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_false_start", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x200) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_tickets", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x800) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_sct", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x2000) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_ocsp", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x8000) != 0);
  xpc_dictionary_set_BOOL(a1, "enforce_ev", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x20000) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_ech", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x2000000) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_resumption", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x80000) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_renegotiation", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x200000) != 0);
  xpc_dictionary_set_BOOL(a1, "enable_early_data", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x800000) != 0);
  xpc_dictionary_set_BOOL(a1, "quic_use_legacy_codepoint", (*((_BYTE *)a2 + 365) & 0x10) != 0);
  xpc_dictionary_set_BOOL(a1, "peer_authentication_required", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x4000000) != 0);
  xpc_dictionary_set_BOOL(a1, "peer_authentication_optional", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x8000000) != 0);
  xpc_dictionary_set_BOOL(a1, "certificate_compression_enabled", (*(_DWORD *)((_BYTE *)a2 + 361) & 0x20000000) != 0);
  xpc_dictionary_set_BOOL(a1, "eddsa_enabled", *(int *)((char *)a2 + 361) < 0);
  xpc_dictionary_set_BOOL(a1, "tls_delegated_credentials_enabled", *((_BYTE *)a2 + 365) & 1);
  xpc_dictionary_set_BOOL(a1, "tls_grease_enabled", (*((_BYTE *)a2 + 365) & 2) != 0);
}

BOOL sec_protocol_metadata_get_tls_certificate_compression_used(uint64_t a1)
{
  _BOOL8 v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_tls_certificate_compression_used_block_invoke;
  v3[3] = &unk_1E1FCD328;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = *((_BYTE *)v5 + 24) != 0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_tls_certificate_compression_used_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 328) & 0x2000) != 0;
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_tls_certificate_compression_algorithm(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  __int16 v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_tls_certificate_compression_algorithm_block_invoke;
  v3[3] = &unk_1E1FCD350;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = *((unsigned __int16 *)v5 + 12);
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_tls_certificate_compression_algorithm_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 256);
  return a2 != 0;
}

uint64_t sec_protocol_metadata_get_handshake_rtt(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_handshake_rtt_block_invoke;
  v3[3] = &unk_1E1FCD378;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_handshake_rtt_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 248);
  return a2 != 0;
}

uint64_t sec_protocol_metadata_access_sent_certificates(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[5];

  v2 = 0;
  if (a1 && a2)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __sec_protocol_metadata_access_sent_certificates_block_invoke;
    v4[3] = &unk_1E1FCD418;
    v4[4] = a2;
    return sec_protocol_metadata_access_handle(a1, (uint64_t)v4);
  }
  return v2;
}

BOOL __sec_protocol_metadata_access_sent_certificates_block_invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  void *v4;
  _QWORD v5[5];

  if (!a2)
    return 0;
  v2 = *(NSObject **)(a2 + 160);
  if (v2 && v2[2].isa)
    return sec_identity_access_certificates(v2, *(void **)(a1 + 32));
  v4 = *(void **)(a2 + 80);
  if (!v4)
    return 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __sec_protocol_metadata_access_sent_certificates_block_invoke_2;
  v5[3] = &unk_1E1FCD3F0;
  v5[4] = *(_QWORD *)(a1 + 32);
  return sec_array_apply(v4, v5);
}

uint64_t __sec_protocol_metadata_access_sent_certificates_block_invoke_2(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return 1;
}

uint64_t sec_protocol_metadata_get_tls_negotiated_group(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_metadata_get_tls_negotiated_group_block_invoke;
  v3[3] = &unk_1E1FCD440;
  v3[4] = &v4;
  sec_protocol_metadata_access_handle(a1, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_metadata_get_tls_negotiated_group_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a2 + 176);
  return a2 != 0;
}

uint64_t sec_protocol_options_create_config(uint64_t a1)
{
  uint64_t v1;
  char v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  xpc_object_t v8;

  v1 = a1;
  if (a1)
  {
    v5 = 0;
    v6 = &v5;
    v7 = 0x2000000000;
    v8 = (xpc_object_t)0xAAAAAAAAAAAAAAAALL;
    v8 = xpc_dictionary_create(0, 0, 0);
    if (v6[3])
    {
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 0x40000000;
      v4[2] = __sec_protocol_options_create_config_block_invoke;
      v4[3] = &unk_1E1FCD468;
      v4[4] = &v5;
      v2 = sec_protocol_options_access_handle(v1, (uint64_t)v4);
      v1 = v6[3];
      if ((v2 & 1) != 0)
      {
LABEL_6:
        _Block_object_dispose(&v5, 8);
        return v1;
      }
      xpc_release((xpc_object_t)v6[3]);
    }
    v1 = 0;
    goto LABEL_6;
  }
  return v1;
}

BOOL __sec_protocol_options_create_config_block_invoke(uint64_t a1, unsigned __int16 *a2)
{
  if (a2)
    _serialize_options(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2);
  return a2 != 0;
}

BOOL sec_protocol_options_matches_config(uint64_t a1, void *a2)
{
  _BOOL8 v2;
  uint64_t config;
  void *v6;
  _QWORD v8[6];

  v2 = 0;
  if (a1 && a2)
  {
    if (MEMORY[0x18D7718B8](a2) == MEMORY[0x1E0C812F8] && (config = sec_protocol_options_create_config(a1)) != 0)
    {
      v6 = (void *)config;
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 0x40000000;
      v8[2] = ___options_config_matches_partial_config_block_invoke;
      v8[3] = &__block_descriptor_tmp_202;
      v8[4] = config;
      v8[5] = a2;
      v2 = xpc_dictionary_apply(a2, v8);
      xpc_release(v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

BOOL ___options_config_matches_partial_config_block_invoke(uint64_t a1, char *__s1)
{
  size_t v4;
  uint64_t v5;
  const char *v6;
  size_t v7;
  size_t v8;
  _BOOL8 result;
  uint64_t uint64;
  uint64_t v11;
  const char *v12;
  size_t v13;
  size_t v14;
  _BOOL4 v15;

  v4 = strnlen(__s1, 0x80uLL);
  v5 = 0;
  while (1)
  {
    v6 = _options_uint64_keys[v5];
    v7 = strlen(v6);
    v8 = v4 <= v7 ? v7 : v4;
    if (!strncmp(__s1, v6, v8))
    {
      result = _dictionary_has_key(*(void **)(a1 + 32), (uint64_t)v6);
      if (!result)
        return result;
      uint64 = xpc_dictionary_get_uint64(*(xpc_object_t *)(a1 + 32), v6);
      if (uint64 != xpc_dictionary_get_uint64(*(xpc_object_t *)(a1 + 40), v6))
        break;
    }
    if (++v5 == 6)
    {
      v11 = 0;
      while (1)
      {
        v12 = _options_BOOL_keys[v11];
        v13 = strlen(v12);
        v14 = v4 <= v13 ? v13 : v4;
        if (!strncmp(__s1, v12, v14))
        {
          result = _dictionary_has_key(*(void **)(a1 + 32), (uint64_t)v12);
          if (!result)
            return result;
          v15 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), v12);
          if (v15 != xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 40), v12))
            break;
        }
        if (++v11 == 22)
          return 1;
      }
      return 0;
    }
  }
  return 0;
}

BOOL _dictionary_has_key(void *a1, uint64_t a2)
{
  _QWORD applier[5];

  if (MEMORY[0x18D7718B8]() != MEMORY[0x1E0C812F8])
    return 0;
  applier[0] = MEMORY[0x1E0C809B0];
  applier[1] = 0x40000000;
  applier[2] = ___dictionary_has_key_block_invoke;
  applier[3] = &__block_descriptor_tmp_203;
  applier[4] = a2;
  return !xpc_dictionary_apply(a1, applier);
}

BOOL ___dictionary_has_key_block_invoke(uint64_t a1, const char *a2)
{
  const char *v3;
  size_t v4;

  v3 = *(const char **)(a1 + 32);
  v4 = strlen(v3);
  return strncmp(a2, v3, v4) != 0;
}

uint64_t sec_protocol_options_apply_config(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD v5[6];

  result = 0;
  if (a1 && a2)
  {
    if (MEMORY[0x18D7718B8](a2) == MEMORY[0x1E0C812F8])
    {
      v5[0] = MEMORY[0x1E0C809B0];
      v5[1] = 0x40000000;
      v5[2] = ___apply_config_options_block_invoke;
      v5[3] = &__block_descriptor_tmp_207;
      v5[4] = a2;
      v5[5] = a1;
      return sec_protocol_options_access_handle(a1, (uint64_t)v5);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL ___apply_config_options_block_invoke(int8x16_t *a1, uint64_t a2)
{
  int8x16_t v2;
  _QWORD v4[4];
  int8x16_t v5;

  if (!a2)
    return 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___apply_config_options_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_206;
  v2 = a1[2];
  v5 = vextq_s8(v2, v2, 8uLL);
  return xpc_dictionary_apply((xpc_object_t)v2.i64[0], v4);
}

uint64_t ___apply_config_options_block_invoke_2(uint64_t a1, char *__s1, void *a3)
{
  size_t v6;
  uint64_t i;
  const char *v8;
  size_t v9;
  size_t v10;
  char *v11;
  uint64_t v12;
  _BOOL8 v13;
  uint64_t j;
  const char *v15;
  size_t v16;
  size_t v17;
  char *v18;
  uint64_t v19;
  uint64_t uint64;
  uint64_t v21;
  _QWORD v23[6];

  v6 = strnlen(__s1, 0x80uLL);
  for (i = 0; i != 44; i += 2)
  {
    v8 = (&_options_BOOL_key_setters)[i];
    v9 = strnlen(v8, 0x80uLL);
    if (v6 <= v9)
      v10 = v9;
    else
      v10 = v6;
    if (!strncmp(v8, __s1, v10))
    {
      v11 = (&_options_BOOL_key_setters)[i + 1];
      v12 = *(_QWORD *)(a1 + 32);
      v13 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 40), __s1);
      ((void (*)(uint64_t, _BOOL8))v11)(v12, v13);
    }
  }
  for (j = 0; j != 12; j += 2)
  {
    v15 = (&_options_uint64_key_setters)[j];
    v16 = strnlen(v15, 0x80uLL);
    if (v6 <= v16)
      v17 = v16;
    else
      v17 = v6;
    if (!strncmp(v15, __s1, v17))
    {
      v18 = (&_options_uint64_key_setters)[j + 1];
      v19 = *(_QWORD *)(a1 + 32);
      uint64 = xpc_dictionary_get_uint64(*(xpc_object_t *)(a1 + 40), __s1);
      ((void (*)(uint64_t, uint64_t))v18)(v19, uint64);
    }
  }
  if (!strncmp(__s1, "ciphersuites", v6) && MEMORY[0x18D7718B8](a3) == MEMORY[0x1E0C812C8])
  {
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 0x40000000;
    v23[2] = ___apply_config_options_block_invoke_3;
    v23[3] = &__block_descriptor_tmp_205;
    v21 = *(_QWORD *)(a1 + 32);
    v23[4] = a3;
    v23[5] = v21;
    xpc_array_apply(a3, v23);
  }
  return 1;
}

uint64_t ___apply_config_options_block_invoke_3(uint64_t a1, size_t a2)
{
  __int16 uint64;
  uint64_t v4;
  _QWORD v6[4];
  __int16 v7;

  uint64 = xpc_array_get_uint64(*(xpc_object_t *)(a1 + 32), a2);
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __sec_protocol_options_append_tls_ciphersuite_block_invoke;
    v6[3] = &__block_descriptor_tmp_10;
    v7 = uint64;
    sec_protocol_options_access_handle(v4, (uint64_t)v6);
  }
  return 1;
}

uint64_t sec_protocol_options_set_tls_block_length_padding(uint64_t result, __int16 a2)
{
  _QWORD v2[4];
  __int16 v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_tls_block_length_padding_block_invoke;
    v2[3] = &__block_descriptor_tmp_134;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_tls_block_length_padding_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_WORD *)(a2 + 366) = *(_WORD *)(a1 + 32);
  return a2 != 0;
}

uint64_t sec_protocol_options_set_server_raw_public_key_certificates(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_set_server_raw_public_key_certificates_block_invoke;
      v2[3] = &__block_descriptor_tmp_135;
      v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }
  return result;
}

CFMutableArrayRef __sec_protocol_options_set_server_raw_public_key_certificates_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const __CFAllocator *v5;
  CFIndex Count;
  CFMutableArrayRef result;
  __CFArray *v8;
  CFIndex i;
  const void *ValueAtIndex;

  if (!a2)
    return 0;
  v4 = *(const void **)(a2 + 280);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a2 + 280) = 0;
  }
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  result = CFArrayCreateMutable(v5, Count, MEMORY[0x1E0C9B378]);
  if (result)
  {
    v8 = result;
    for (i = 0; i < CFArrayGetCount(*(CFArrayRef *)(a1 + 32)); ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), i);
      CFArrayAppendValue(v8, ValueAtIndex);
    }
    *(_QWORD *)(a2 + 280) = v8;
    return (CFMutableArrayRef)1;
  }
  return result;
}

void sec_protocol_options_add_server_raw_public_key_certificate(uint64_t a1, const UInt8 *a2, CFIndex a3)
{
  const __CFAllocator *v6;
  CFMutableArrayRef Mutable;
  __CFArray *v8;
  CFDataRef v9;
  CFDataRef v10;
  _QWORD v11[5];

  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v8 = Mutable;
    v9 = CFDataCreate(v6, a2, a3);
    if (v9)
    {
      v10 = v9;
      CFArrayAppendValue(v8, v9);
      CFRelease(v10);
      if (a1)
      {
        v11[0] = MEMORY[0x1E0C809B0];
        v11[1] = 0x40000000;
        v11[2] = __sec_protocol_options_set_server_raw_public_key_certificates_block_invoke;
        v11[3] = &__block_descriptor_tmp_135;
        v11[4] = v8;
        sec_protocol_options_access_handle(a1, (uint64_t)v11);
      }
      CFRelease(v8);
    }
    else
    {
      CFRelease(v8);
    }
  }
}

uint64_t sec_protocol_options_set_client_raw_public_key_certificates(uint64_t result, uint64_t a2)
{
  _QWORD v2[5];

  if (result)
  {
    if (a2)
    {
      v2[0] = MEMORY[0x1E0C809B0];
      v2[1] = 0x40000000;
      v2[2] = __sec_protocol_options_set_client_raw_public_key_certificates_block_invoke;
      v2[3] = &__block_descriptor_tmp_136;
      v2[4] = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v2);
    }
  }
  return result;
}

CFMutableArrayRef __sec_protocol_options_set_client_raw_public_key_certificates_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const __CFAllocator *v5;
  CFIndex Count;
  CFMutableArrayRef result;
  __CFArray *v8;
  CFIndex i;
  const void *ValueAtIndex;

  if (!a2)
    return 0;
  v4 = *(const void **)(a2 + 288);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a2 + 288) = 0;
  }
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  result = CFArrayCreateMutable(v5, Count, MEMORY[0x1E0C9B378]);
  if (result)
  {
    v8 = result;
    for (i = 0; i < CFArrayGetCount(*(CFArrayRef *)(a1 + 32)); ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), i);
      CFArrayAppendValue(v8, ValueAtIndex);
    }
    *(_QWORD *)(a2 + 288) = v8;
    return (CFMutableArrayRef)1;
  }
  return result;
}

uint64_t sec_protocol_options_set_new_session_ticket_request(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_new_session_ticket_request_block_invoke;
    v2[3] = &__block_descriptor_tmp_137;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_new_session_ticket_request_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_BYTE *)(a2 + 296) = *(_BYTE *)(a1 + 32);
  return a2 != 0;
}

uint64_t sec_protocol_options_set_resumed_session_ticket_request(uint64_t result, char a2)
{
  _QWORD v2[4];
  char v3;

  if (result)
  {
    v2[0] = MEMORY[0x1E0C809B0];
    v2[1] = 0x40000000;
    v2[2] = __sec_protocol_options_set_resumed_session_ticket_request_block_invoke;
    v2[3] = &__block_descriptor_tmp_138;
    v3 = a2;
    return sec_protocol_options_access_handle(result, (uint64_t)v2);
  }
  return result;
}

BOOL __sec_protocol_options_set_resumed_session_ticket_request_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_BYTE *)(a2 + 297) = *(_BYTE *)(a1 + 32);
  return a2 != 0;
}

uint64_t sec_protocol_options_set_eap_method(uint64_t result, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v4[4];
  char v5;
  uint64_t v6;
  uint64_t v7;

  if (result)
  {
    if (a2 <= 1)
    {
      v6 = v2;
      v7 = v3;
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 0x40000000;
      v4[2] = __sec_protocol_options_set_eap_method_block_invoke;
      v4[3] = &__block_descriptor_tmp_139;
      v5 = a2;
      return sec_protocol_options_access_handle(result, (uint64_t)v4);
    }
  }
  return result;
}

BOOL __sec_protocol_options_set_eap_method_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_BYTE *)(a2 + 360) = *(_BYTE *)(a1 + 32);
  return a2 != 0;
}

uint64_t sec_protocol_options_get_eap_method(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  if (!a1)
    return 0;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __sec_protocol_options_get_eap_method_block_invoke;
  v3[3] = &unk_1E1FCD550;
  v3[4] = &v4;
  sec_protocol_options_access_handle(a1, (uint64_t)v3);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __sec_protocol_options_get_eap_method_block_invoke(uint64_t a1, uint64_t a2)
{
  if (a2)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_BYTE *)(a2 + 360);
  return a2 != 0;
}

BOOL sec_protocol_metadata_get_eap_key_material(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BOOL8 v3;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;

  v3 = 0;
  if (a1 && a2 && (unint64_t)(a3 - 129) >= 0xFFFFFFFFFFFFFF80)
  {
    v6 = 0;
    v7 = &v6;
    v8 = 0x2000000000;
    v9 = 0;
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 0x40000000;
    v5[2] = __sec_protocol_metadata_get_eap_key_material_block_invoke;
    v5[3] = &unk_1E1FCD578;
    v5[5] = a2;
    v5[6] = a3;
    v5[4] = &v6;
    sec_protocol_metadata_access_handle(a1, (uint64_t)v5);
    v3 = *((_BYTE *)v7 + 24) != 0;
    _Block_object_dispose(&v6, 8);
  }
  return v3;
}

BOOL __sec_protocol_metadata_get_eap_key_material_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;

  if (a2)
  {
    v3 = *(const void **)(a2 + 320);
    if (v3)
    {
      memmove(*(void **)(a1 + 40), v3, *(_QWORD *)(a1 + 48));
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    }
  }
  return a2 != 0;
}

void sub_18A9753D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getSDRDiagnosticReporterClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;
  void *v4;
  void *v5;

  if (!SymptomDiagnosticReporterLibraryCore_frameworkLibrary)
    SymptomDiagnosticReporterLibraryCore_frameworkLibrary = _sl_dlopen();
  if (!SymptomDiagnosticReporterLibraryCore_frameworkLibrary)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *SymptomDiagnosticReporterLibrary(void)");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("SecABC.m"), 16, CFSTR("%s"), 0);

    goto LABEL_8;
  }
  result = objc_getClass("SDRDiagnosticReporter");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getSDRDiagnosticReporterClass(void)_block_invoke");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v5, CFSTR("SecABC.m"), 17, CFSTR("Unable to find class %s"), "SDRDiagnosticReporter");

LABEL_8:
    __break(1u);
  }
  getSDRDiagnosticReporterClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t SecABCTrigger(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return +[SecABC triggerAutoBugCaptureWithType:subType:subtypeContext:domain:events:payload:detectedProcess:](SecABC, "triggerAutoBugCaptureWithType:subType:subtypeContext:domain:events:payload:detectedProcess:", a1, a2, a3, CFSTR("com.apple.security.keychain"), 0, a4, 0);
}

BOOL sec_protocol_helper_ciphersuite_group_contains_ciphersuite(unsigned int a1, int a2)
{
  unsigned __int16 *v2;
  uint64_t v3;
  int v4;
  _BOOL8 result;

  if (a1 > 4)
    return 0;
  v2 = (unsigned __int16 *)*(&off_1E1FCD898 + a1);
  v3 = qword_18AA5AB78[a1] - 1;
  do
  {
    v4 = *v2++;
    result = v4 == a2;
  }
  while (v4 != a2 && v3-- != 0);
  return result;
}

uint64_t sec_protocol_helper_ciphersuite_minimum_TLS_version(int a1)
{
  uint64_t v1;
  __int16 *v2;
  int v3;

  v1 = 0;
  v2 = tls_ciphersuite_definitions;
  while (1)
  {
    v3 = (unsigned __int16)*v2;
    v2 += 35;
    if (v3 == a1)
      break;
    if (++v1 == 37)
      return 0;
  }
  return (unsigned __int16)tls_ciphersuite_definitions[35 * v1 + 1];
}

uint64_t sec_protocol_helper_ciphersuite_maximum_TLS_version(int a1)
{
  uint64_t v1;
  __int16 *v2;
  int v3;

  v1 = 0;
  v2 = tls_ciphersuite_definitions;
  while (1)
  {
    v3 = (unsigned __int16)*v2;
    v2 += 35;
    if (v3 == a1)
      break;
    if (++v1 == 37)
      return 0;
  }
  return (unsigned __int16)tls_ciphersuite_definitions[35 * v1 + 2];
}

const char *sec_protocol_helper_get_ciphersuite_name(int a1)
{
  const char *result;

  if (a1 <= 4866)
  {
    if (a1 > 102)
    {
      if (a1 <= 155)
      {
        if (a1 == 103)
        {
          return "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256";
        }
        else if (a1 == 107)
        {
          return "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256";
        }
        else
        {
          return 0;
        }
      }
      else
      {
        switch(a1)
        {
          case 156:
            result = "TLS_RSA_WITH_AES_128_GCM_SHA256";
            break;
          case 157:
            result = "TLS_RSA_WITH_AES_256_GCM_SHA384";
            break;
          case 158:
            result = "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256";
            break;
          case 159:
            result = "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384";
            break;
          default:
            if (a1 == 4865)
            {
              result = "TLS_AES_128_GCM_SHA256";
            }
            else
            {
              if (a1 != 4866)
                return 0;
              result = "TLS_AES_256_GCM_SHA384";
            }
            break;
        }
      }
    }
    else
    {
      switch(a1)
      {
        case '/':
          return "TLS_RSA_WITH_AES_128_CBC_SHA";
        case '0':
        case '1':
        case '2':
        case '4':
        case '6':
        case '7':
        case '8':
        case ':':
        case ';':
          return 0;
        case '3':
          return "TLS_DHE_RSA_WITH_AES_128_CBC_SHA";
        case '5':
          return "TLS_RSA_WITH_AES_256_CBC_SHA";
        case '9':
          return "TLS_DHE_RSA_WITH_AES_256_CBC_SHA";
        case '<':
          return "TLS_RSA_WITH_AES_128_CBC_SHA256";
        case '=':
          return "TLS_RSA_WITH_AES_256_CBC_SHA256";
        default:
          if (a1 == 10)
          {
            result = "SSL_RSA_WITH_3DES_EDE_CBC_SHA";
          }
          else
          {
            if (a1 != 22)
              return 0;
            result = "SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA";
          }
          break;
      }
    }
  }
  else if (a1 <= 49186)
  {
    switch(a1)
    {
      case 49160:
        result = "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA";
        break;
      case 49161:
        result = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA";
        break;
      case 49162:
        result = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA";
        break;
      case 49163:
      case 49164:
      case 49165:
      case 49166:
      case 49167:
      case 49168:
      case 49169:
        return 0;
      case 49170:
        result = "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA";
        break;
      case 49171:
        result = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA";
        break;
      case 49172:
        result = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA";
        break;
      default:
        if (a1 != 4867)
          return 0;
        result = "TLS_CHACHA20_POLY1305_SHA256";
        break;
    }
  }
  else
  {
    switch(a1)
    {
      case 49187:
        return "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256";
      case 49188:
        return "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384";
      case 49189:
      case 49190:
      case 49193:
      case 49194:
      case 49197:
      case 49198:
        return 0;
      case 49191:
        return "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256";
      case 49192:
        return "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384";
      case 49195:
        return "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256";
      case 49196:
        return "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384";
      case 49199:
        return "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256";
      case 49200:
        return "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384";
      default:
        if (a1 == 52392)
        {
          result = "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256";
        }
        else
        {
          if (a1 != 52393)
            return 0;
          result = "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256";
        }
        break;
    }
  }
  return result;
}

BOOL sec_protocol_helper_dispatch_data_equal(void *a1, void *a2)
{
  NSObject *v3;
  NSObject *v4;
  size_t size;
  _BOOL8 v6;
  _QWORD v8[4];
  NSObject *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;

  v3 = a1;
  v4 = a2;
  if (v3 == v4)
  {
    v6 = 1;
  }
  else
  {
    size = dispatch_data_get_size(v3);
    if (size == dispatch_data_get_size(v4))
    {
      v11 = 0;
      v12 = &v11;
      v13 = 0x2020000000;
      v14 = 1;
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 3221225472;
      v8[2] = __sec_protocol_helper_dispatch_data_equal_block_invoke;
      v8[3] = &unk_1E1FCD878;
      v9 = v4;
      v10 = &v11;
      dispatch_data_apply(v3, v8);
      v6 = *((_BYTE *)v12 + 24) != 0;

      _Block_object_dispose(&v11, 8);
    }
    else
    {
      v6 = 0;
    }
  }

  return v6;
}

uint64_t __sec_protocol_helper_dispatch_data_equal_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v6;
  _QWORD v8[8];

  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = __sec_protocol_helper_dispatch_data_equal_block_invoke_2;
  v8[3] = &unk_1E1FCD850;
  v6 = *(NSObject **)(a1 + 32);
  v8[4] = *(_QWORD *)(a1 + 40);
  v8[5] = a3;
  v8[6] = a5;
  v8[7] = a4;
  dispatch_data_apply(v6, v8);
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
}

BOOL __sec_protocol_helper_dispatch_data_equal_block_invoke_2(_QWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  size_t v12;

  v7 = a1[5];
  v6 = a1[6];
  if (v7 <= a3)
    v8 = a3;
  else
    v8 = a1[5];
  v9 = v6 + v7;
  if (v6 + v7 >= a5 + a3)
    v10 = a5 + a3;
  else
    v10 = v6 + v7;
  v11 = v10 > v8;
  v12 = v10 - v8;
  if (v11)
  {
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = memcmp((const void *)(a4 + v8 - a3), (const void *)(a1[7] + v8 - v7), v12) == 0;
  }
  else
  {
    if (v9 < a3)
      return 0;
    if (a5 + a3 < v7)
      return 1;
  }
  return *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) != 0;
}

void __isMessageSecurityAllowedForCurrentBundleID_block_invoke()
{
  __CFBundle *MainBundle;
  const __CFString *Identifier;
  const __CFString *v2;
  BOOL v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle)
  {
    Identifier = CFBundleGetIdentifier(MainBundle);
    if (Identifier)
    {
      v2 = Identifier;
      v3 = CFStringHasPrefix(Identifier, CFSTR("com.apple.mdmclient"))
        || CFStringHasPrefix(v2, CFSTR("com.apple.managedclient.pds.Certificate"))
        || CFStringHasPrefix(v2, CFSTR("com.apple.managedconfiguration.profiled"))
        || CFStringHasPrefix(v2, CFSTR("com.apple.remotemanagementd"))
        || CFStringHasPrefix(v2, CFSTR("com.apple.RemoteManagementAgent")) != 0;
    }
    else
    {
      v3 = 0;
    }
    isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound = v3;
  }
  secLogObjForScope("SecCMS");
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound)
      v5 = "false";
    else
      v5 = "true";
    v6 = 136315138;
    v7 = v5;
    _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "isMessageSecurityAllowedForCurrentBundleID %s", (uint8_t *)&v6, 0xCu);
  }

}

uint64_t MS_SecCMSCertificatesOnlyMessageCopyCertificates(uint64_t a1)
{
  void *v1;
  id v2;
  void *v3;
  uint64_t v4;
  void *v5;
  void *v6;
  char isKindOfClass;
  NSObject *v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t v15;
  id v17;
  uint8_t buf[4];
  id v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  objc_msgSend(MEMORY[0x1E0D4D770], "decodeMessageSecurityObject:options:error:", a1, 0, &v17);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = v17;
  if (v1)
  {
    objc_msgSend(v1, "contentType");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v3, "isEqualToString:", *MEMORY[0x1E0D4D6E0])
      && (objc_msgSend(v1, "embeddedContent"), (v4 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      v5 = (void *)v4;
      objc_msgSend(v1, "embeddedContent");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      isKindOfClass = objc_opt_isKindOfClass();

      if ((isKindOfClass & 1) != 0)
      {
        objc_msgSend(v1, "embeddedContent");
        v8 = objc_claimAutoreleasedReturnValue();
        -[NSObject signers](v8, "signers");
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        v10 = objc_msgSend(v9, "count");

        if (v10)
        {
          secLogObjForScope("SecError");
          v11 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEFAULT, "certs-only message has signers", buf, 2u);
          }
        }
        else
        {
          -[NSObject certificates](v8, "certificates");
          v11 = objc_claimAutoreleasedReturnValue();
          if (-[NSObject count](v11, "count"))
          {
            -[NSObject allObjects](v11, "allObjects");
            v15 = objc_claimAutoreleasedReturnValue();
LABEL_19:

            goto LABEL_15;
          }
        }
        v15 = 0;
        goto LABEL_19;
      }
    }
    else
    {

    }
    secLogObjForScope("SecError");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v12 = "CMS message does not contain a SignedData";
      v13 = v8;
      v14 = 2;
LABEL_13:
      _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
    }
  }
  else
  {
    secLogObjForScope("SecError");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v19 = v2;
      v12 = "failed to decode CMS message: %@";
      v13 = v8;
      v14 = 12;
      goto LABEL_13;
    }
  }
  v15 = 0;
LABEL_15:

  return v15;
}

uint64_t MS_SecCMSDecodeSignedData(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  void *v5;
  id v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  char isKindOfClass;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  void *v16;
  char v17;
  NSObject *v18;
  void *v19;
  id v20;
  uint8_t buf[4];
  id v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  objc_msgSend(MEMORY[0x1E0D4D770], "decodeMessageSecurityObject:options:error:", a1, 0, &v20);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = v20;
  if (v5)
  {
    objc_msgSend(v5, "contentType");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v7, "isEqualToString:", *MEMORY[0x1E0D4D6E0])
      && (objc_msgSend(v5, "embeddedContent"), (v8 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      v9 = (void *)v8;
      objc_msgSend(v5, "embeddedContent");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      isKindOfClass = objc_opt_isKindOfClass();

      if ((isKindOfClass & 1) != 0)
      {
        objc_msgSend(v5, "embeddedContent");
        v12 = objc_claimAutoreleasedReturnValue();
        v13 = v12;
        if (a2)
        {
          if ((-[NSObject detached](v12, "detached") & 1) != 0)
          {
            objc_msgSend(MEMORY[0x1E0C99D50], "data");
            v14 = objc_claimAutoreleasedReturnValue();
          }
          else
          {
            -[NSObject contentType](v13, "contentType");
            v16 = (void *)objc_claimAutoreleasedReturnValue();
            v17 = objc_msgSend(v16, "isEqualToString:", *MEMORY[0x1E0D4D6D0]);

            if ((v17 & 1) == 0)
            {
              secLogObjForScope("SecWarning");
              v18 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                -[NSObject contentType](v13, "contentType");
                v19 = (void *)objc_claimAutoreleasedReturnValue();
                *(_DWORD *)buf = 138412290;
                v22 = v19;
                _os_log_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEFAULT, "returning attached embedded content of type %@", buf, 0xCu);

              }
            }
            -[NSObject dataContent](v13, "dataContent");
            v14 = objc_claimAutoreleasedReturnValue();
          }
          *a2 = v14;
        }
        if (a3)
        {
          addSignedAttribues(v13, (_QWORD *)a3);
          a3 = 0;
        }
        goto LABEL_15;
      }
    }
    else
    {

    }
    secLogObjForScope("SecError");
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, "CMS message does not contain a SignedData", buf, 2u);
    }
    a3 = 4294941021;
  }
  else
  {
    secLogObjForScope("SecError");
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v6;
      _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, "failed to decode CMS message: %@", buf, 0xCu);
    }
    a3 = 4294942003;
  }
LABEL_15:

  return a3;
}

uint64_t MS_SecCMSDecryptEnvelopedData(uint64_t a1, __CFData *a2, _QWORD *a3)
{
  void *v5;
  id v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  char isKindOfClass;
  NSObject *v12;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  uint64_t v17;
  void *v18;
  NSObject *v19;
  const void *v20;
  const void *v21;
  uint64_t v22;
  const char *v23;
  NSObject *v24;
  uint32_t v25;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  id v30;
  uint8_t buf[4];
  id v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v30 = 0;
  objc_msgSend(MEMORY[0x1E0D4D770], "decodeMessageSecurityObject:options:error:", a1, 0, &v30);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = v30;
  if (v5)
  {
    objc_msgSend(v5, "contentType");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    if (objc_msgSend(v7, "isEqualToString:", *MEMORY[0x1E0D4D6D8])
      && (objc_msgSend(v5, "embeddedContent"), (v8 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      v9 = (void *)v8;
      objc_msgSend(v5, "embeddedContent");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      objc_opt_class();
      isKindOfClass = objc_opt_isKindOfClass();

      if ((isKindOfClass & 1) != 0)
      {
        objc_msgSend(v5, "embeddedContent");
        v12 = objc_claimAutoreleasedReturnValue();
        -[NSObject contentType](v12, "contentType");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        if (objc_msgSend(v13, "isEqualToString:", *MEMORY[0x1E0D4D6D0]))
        {
          -[NSObject dataContent](v12, "dataContent");
          v14 = (void *)objc_claimAutoreleasedReturnValue();
          if (v14)
          {
            v15 = objc_retainAutorelease(v14);
            CFDataAppendBytes(a2, (const UInt8 *)objc_msgSend(v15, "bytes"), objc_msgSend(v15, "length"));

            if (!a3)
            {
              v22 = 0;
LABEL_30:

              goto LABEL_19;
            }
            -[NSObject recipients](v12, "recipients");
            v16 = (void *)objc_claimAutoreleasedReturnValue();
            v17 = objc_msgSend(v16, "count");

            if (v17)
            {
              -[NSObject recipients](v12, "recipients");
              v18 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v18, "objectAtIndex:", 0);
              v19 = objc_claimAutoreleasedReturnValue();

              v20 = (const void *)-[NSObject recipientCertificate](v19, "recipientCertificate");
              v21 = v20;
              if (v20)
                CFRetain(v20);
              v22 = 0;
              *a3 = v21;
              goto LABEL_29;
            }
            v22 = 4294899625;
            secLogObjForScope("SecError");
            v19 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              v27 = "failed to read the recipient after decoding";
              goto LABEL_27;
            }
          }
          else
          {
            v22 = 4294899625;
            secLogObjForScope("SecError");
            v19 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              v27 = "failed to read the decrypted content after decoding";
LABEL_27:
              v28 = v19;
              v29 = 2;
              goto LABEL_28;
            }
          }
        }
        else
        {
          v22 = 4294899625;
          secLogObjForScope("SecError");
          v19 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v32 = v13;
            v27 = "unexpected content type %@";
            v28 = v19;
            v29 = 12;
LABEL_28:
            _os_log_impl(&dword_18A900000, v28, OS_LOG_TYPE_DEFAULT, v27, buf, v29);
          }
        }
LABEL_29:

        goto LABEL_30;
      }
    }
    else
    {

    }
    secLogObjForScope("SecError");
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v23 = "CMS message does not contain a EnvelopedData";
      v24 = v12;
      v25 = 2;
LABEL_17:
      _os_log_impl(&dword_18A900000, v24, OS_LOG_TYPE_DEFAULT, v23, buf, v25);
    }
  }
  else
  {
    secLogObjForScope("SecError");
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v32 = v6;
      v23 = "failed to decode CMS message: %@";
      v24 = v12;
      v25 = 12;
      goto LABEL_17;
    }
  }
  v22 = 4294941021;
LABEL_19:

  return v22;
}

void sub_18A977860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18A977B60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A977C90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A977DAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A977EC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A977FE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_18A9780E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

id KCSharingSetupMessagingdServerProtocol(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  _QWORD v7[5];

  v7[4] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  +[SecXPCHelper safeErrorClasses](SecXPCHelper, "safeErrorClasses");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (void *)MEMORY[0x1E0C99E60];
  v7[0] = objc_opt_class();
  v7[1] = objc_opt_class();
  v7[2] = objc_opt_class();
  v7[3] = objc_opt_class();
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v7, 4);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setWithArray:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v1, "setClass:forSelector:argumentIndex:ofReply:", objc_opt_class(), sel_sendNewInvitesForGroup_completion_, 0, 0);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_sendNewInvitesForGroup_completion_, 0, 1);
  objc_msgSend(v1, "setClass:forSelector:argumentIndex:ofReply:", objc_opt_class(), sel_cancelPendingInvitesForGroup_participantHandles_completion_, 0, 0);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_cancelPendingInvitesForGroup_participantHandles_completion_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_didAcceptInviteForGroupID_completion_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_didDeclineInviteForGroupID_completion_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v5, sel_fetchReceivedInviteWithGroupID_completion_, 0, 0);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v5, sel_fetchReceivedInviteWithGroupID_completion_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchReceivedInviteWithGroupID_completion_, 1, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v5, sel_fetchReceivedInvitesWithCompletion_, 0, 1);
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_fetchReceivedInvitesWithCompletion_, 1, 1);

  return v1;
}

uint64_t __Block_byref_object_copy__3339(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3340(uint64_t a1)
{

}

uint64_t SecPaddingCompute(int a1, unsigned int a2, CFErrorRef *a3)
{
  const __CFAllocator *Default;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a1)
  {
    if (a3)
    {
      Default = CFAllocatorGetDefault();
      v5 = -1;
      *a3 = CFErrorCreate(Default, CFSTR("com.apple.security.padding"), -1, 0);
    }
    else
    {
      return -1;
    }
  }
  else
  {
    v6 = (a2 + 0x1FFFLL) & 0x1FFFFE000;
    if (a2 <= 0x7D00)
      v6 = (a2 + 1023) & 0x1FFFFFC00;
    v7 = 1 << -(char)__clz(a2);
    if ((a2 & (a2 - 1)) == 0)
      v7 = a2;
    if (a2 <= 0x400)
      v6 = v7;
    if (a2 <= 0x40)
      v6 = 64;
    return v6 - a2;
  }
  return v5;
}

void sub_18A979690(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id getOSLog()
{
  if (getOSLog_onceToken != -1)
    dispatch_once(&getOSLog_onceToken, &__block_literal_global_3443);
  return (id)getOSLog_sfaLog;
}

void __getOSLog_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("SFA", "log");
  v1 = (void *)getOSLog_sfaLog;
  getOSLog_sfaLog = (uint64_t)v0;

}

void sub_18A97A558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A97A8AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A97AA70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__3525(uint64_t a1, uint64_t a2)
{
  void *result;

  result = _Block_copy(*(const void **)(a2 + 40));
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__3526(uint64_t a1)
{

}

void sub_18A97AEEC(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  id *v3;
  uint64_t v4;

  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v4 - 80));
  objc_destroyWeak((id *)(v4 - 72));
  _Unwind_Resume(a1);
}

const __CFString *___is_apple_bundle_block_invoke()
{
  __CFBundle *MainBundle;
  const __CFString *result;
  BOOL v2;

  MainBundle = CFBundleGetMainBundle();
  result = CFBundleGetIdentifier(MainBundle);
  if (result)
  {
    result = (const __CFString *)CFStringHasPrefix(result, CFSTR("com.apple."));
    v2 = (_DWORD)result != 0;
  }
  else
  {
    v2 = 1;
  }
  _is_apple_bundle_result = v2;
  return result;
}

sec_identity_t sec_identity_create(SecIdentityRef identity)
{
  return (sec_identity_t)-[SecConcrete_sec_identity initWithIdentity:]([SecConcrete_sec_identity alloc], "initWithIdentity:", identity);
}

sec_identity_t sec_identity_create_with_certificates(SecIdentityRef identity, CFArrayRef certificates)
{
  return (sec_identity_t)-[SecConcrete_sec_identity initWithIdentityAndCertificates:certificates:]([SecConcrete_sec_identity alloc], "initWithIdentityAndCertificates:certificates:", identity, certificates);
}

SecConcrete_sec_identity *sec_identity_create_with_certificates_and_external_private_key(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  id v9;
  SecConcrete_sec_identity *v10;

  v7 = a4;
  v8 = a3;
  v9 = a2;
  v10 = -[SecConcrete_sec_identity initWithCertificates:signBlock:decryptBlock:queue:]([SecConcrete_sec_identity alloc], "initWithCertificates:signBlock:decryptBlock:queue:", a1, v9, v8, v7);

  return v10;
}

SecIdentityRef sec_identity_copy_ref(sec_identity_t identity)
{
  Class isa;

  if (identity && (isa = identity[1].isa) != 0)
    return (SecIdentityRef)CFRetain(isa);
  else
    return 0;
}

CFArrayRef sec_identity_copy_certificates_ref(sec_identity_t identity)
{
  Class isa;

  if (identity && (isa = identity[2].isa) != 0)
    return (CFArrayRef)CFRetain(isa);
  else
    return 0;
}

BOOL sec_identity_access_certificates(sec_identity_t identity, void *handler)
{
  void *v3;
  void *v4;
  _QWORD context[4];
  id v7;
  CFRange v8;

  v3 = handler;
  v4 = v3;
  if (identity)
  {
    identity = (sec_identity_t)identity[2].isa;
    if (identity)
    {
      context[0] = MEMORY[0x1E0C809B0];
      context[1] = 3221225472;
      context[2] = __sec_identity_access_certificates_block_invoke;
      context[3] = &unk_1E1FD4C58;
      v7 = v3;
      v8.length = CFArrayGetCount((CFArrayRef)identity);
      v8.location = 0;
      CFArrayApplyFunction((CFArrayRef)identity, v8, (CFArrayApplierFunction)apply_block_1, context);

      LOBYTE(identity) = 1;
    }
  }

  return (char)identity;
}

void __sec_identity_access_certificates_block_invoke(uint64_t a1, uint64_t a2)
{
  SecConcrete_sec_certificate *v3;

  if (a2)
  {
    v3 = -[SecConcrete_sec_certificate initWithCertificate:]([SecConcrete_sec_certificate alloc], "initWithCertificate:", a2);
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();

  }
}

uint64_t apply_block_1(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

BOOL sec_identity_has_certificates(_BOOL8 result)
{
  if (result)
    return *(_QWORD *)(result + 16) != 0;
  return result;
}

void *sec_identity_copy_private_key_sign_block(uint64_t a1)
{
  const void *v1;

  if (a1 && (v1 = *(const void **)(a1 + 24)) != 0)
    return _Block_copy(v1);
  else
    return 0;
}

void *sec_identity_copy_private_key_decrypt_block(uint64_t a1)
{
  const void *v1;

  if (a1 && (v1 = *(const void **)(a1 + 32)) != 0)
    return _Block_copy(v1);
  else
    return 0;
}

id sec_identity_copy_private_key_queue(uint64_t a1)
{
  void *v1;

  if (a1 && (v1 = *(void **)(a1 + 40)) != 0)
    return v1;
  else
    return 0;
}

SecConcrete_sec_protocol_configuration_builder *sec_protocol_configuration_builder_create(uint64_t a1, uint64_t a2)
{
  return -[SecConcrete_sec_protocol_configuration_builder initWithDictionary:andInternalFlag:]([SecConcrete_sec_protocol_configuration_builder alloc], "initWithDictionary:andInternalFlag:", a1, a2);
}

SecConcrete_sec_protocol_configuration *sec_protocol_configuration_create_with_builder(void *a1)
{
  _QWORD *v1;
  SecConcrete_sec_protocol_configuration *v2;
  int v3;
  _BOOL4 v4;
  OS_xpc_object *v5;
  xpc_object_t v6;
  OS_xpc_object *v7;
  BOOL v8;
  OS_xpc_object *v9;
  void *v10;
  _BOOL4 v11;
  __int16 v13[8];
  uint8_t v14[16];
  uint8_t v15[16];
  uint8_t v16[16];
  uint8_t buf[16];

  v1 = a1;
  v2 = objc_alloc_init(SecConcrete_sec_protocol_configuration);
  if (v2)
  {
    v3 = *((unsigned __int8 *)v1 + 16);
    v4 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
    if (v3)
    {
      if (v4)
      {
        *(_WORD *)buf = 0;
        _os_log_debug_impl(&dword_18A900000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "Building default configuration for first-party bundle", buf, 2u);
      }
      v5 = v2->dictionary;
      v6 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_value(v5, "NSExceptionDomains", v6);
      xpc_dictionary_set_BOOL(v5, "NSAllowsArbitraryLoadsInWebContent", 1);
      xpc_dictionary_set_BOOL(v5, "NSAllowsArbitraryLoadsForMedia", 1);
      xpc_dictionary_set_BOOL(v5, "NSAllowsLocalNetworking", 1);
      v7 = v5;
      v8 = 1;
    }
    else
    {
      if (v4)
      {
        *(_WORD *)v16 = 0;
        _os_log_debug_impl(&dword_18A900000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "Building default configuration for third-party bundle", v16, 2u);
      }
      v5 = v2->dictionary;
      v6 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_value(v5, "NSExceptionDomains", v6);
      xpc_dictionary_set_BOOL(v5, "NSAllowsArbitraryLoadsInWebContent", 0);
      xpc_dictionary_set_BOOL(v5, "NSAllowsArbitraryLoadsForMedia", 0);
      xpc_dictionary_set_BOOL(v5, "NSAllowsLocalNetworking", 0);
      v7 = v5;
      v8 = 0;
    }
    xpc_dictionary_set_BOOL(v7, "NSAllowsArbitraryLoads", v8);

    v9 = v2->dictionary;
    sec_protocol_configuration_register_builtin_exception(v9, "apple.com", 0x303u);
    sec_protocol_configuration_register_builtin_exception(v9, "ls.apple.com", 0x301u);
    sec_protocol_configuration_register_builtin_exception(v9, "gs.apple.com", 0x301u);
    sec_protocol_configuration_register_builtin_exception(v9, "geo.apple.com", 0x301u);
    sec_protocol_configuration_register_builtin_exception(v9, "is.autonavi.com", 0x301u);
    sec_protocol_configuration_register_builtin_exception(v9, "apple-mapkit.com", 0x301u);
    sec_protocol_configuration_register_builtin_exception(v9, "setup.icloud.com", 0x303u);

    v10 = (void *)v1[1];
    v11 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG);
    if (v10)
    {
      if (v11)
      {
        *(_WORD *)v15 = 0;
        _os_log_debug_impl(&dword_18A900000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "Setting configuration overrides based on AppTransportSecurity exceptions", v15, 2u);
      }
      sec_protocol_configuration_set_ats_overrides((uint64_t)v2, v10);
    }
    else if (v11)
    {
      *(_WORD *)v14 = 0;
      _os_log_debug_impl(&dword_18A900000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "Using default configuration settings", v14, 2u);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    v13[0] = 0;
    _os_log_error_impl(&dword_18A900000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "sec_protocol_configuration_create failed", (uint8_t *)v13, 2u);
  }

  return v2;
}

void sub_18A97BBE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A97BDA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *CoreAnalyticsLibrary()
{
  void *v0;
  void *v2;
  void *v3;

  if (!CoreAnalyticsLibraryCore_frameworkLibrary)
    CoreAnalyticsLibraryCore_frameworkLibrary = _sl_dlopen();
  v0 = (void *)CoreAnalyticsLibraryCore_frameworkLibrary;
  if (!CoreAnalyticsLibraryCore_frameworkLibrary)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v0 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *CoreAnalyticsLibrary(void)");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v2, CFSTR("SecCoreAnalytics.m"), 195, CFSTR("%s"), 0);

    __break(1u);
    free(v3);
  }
  return v0;
}

void SecCoreAnalyticsSendValue(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  const __CFString *v5;
  _QWORD v6[2];

  v6[1] = *MEMORY[0x1E0C80C00];
  v5 = CFSTR("value");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLong:", a2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v6[0] = v3;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v6, &v5, 1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  +[SecCoreAnalytics sendEvent:event:](SecCoreAnalytics, "sendEvent:event:", a1, v4);

}

void SecCoreAnalyticsSendKernEntropyAnalytics()
{
  unsigned int v0;
  uint64_t v1;
  unsigned int v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  NSObject *v7;
  uint8_t *v8;
  time_t v9;
  double v10;
  unint64_t v11;
  uint64_t v12;
  NSObject *v13;
  unsigned int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  int v20;
  time_t v21;
  __int128 v22;
  void *v23;
  void *v24;
  double v25;
  unint64_t v26;
  unsigned int v27;
  int v28;
  int v29;
  unsigned int v30;
  _BYTE v31[24];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v20 = -1431655766;
  *(_QWORD *)&v22 = 4;
  if (sysctlbyname("kern.entropy.health.startup_done", &v20, (size_t *)&v22, 0, 0) < 0 || (_QWORD)v22 != 4)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_39;
    LODWORD(v22) = 136315138;
    *(_QWORD *)((char *)&v22 + 4) = "kern.entropy.health.startup_done";
    v7 = MEMORY[0x1E0C81028];
LABEL_37:
    v8 = (uint8_t *)&v22;
LABEL_38:
    _os_log_error_impl(&dword_18A900000, v7, OS_LOG_TYPE_ERROR, "failed to read sysctl %s", v8, 0xCu);
    goto LABEL_39;
  }
  v19 = -1431655766;
  *(_QWORD *)&v22 = 4;
  if (sysctlbyname("kern.entropy.health.adaptive_proportion_test.failure_count", &v19, (size_t *)&v22, 0, 0) < 0
    || (_QWORD)v22 != 4)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_39;
    LODWORD(v22) = 136315138;
    *(_QWORD *)((char *)&v22 + 4) = "kern.entropy.health.adaptive_proportion_test.failure_count";
    v7 = MEMORY[0x1E0C81028];
    goto LABEL_37;
  }
  v18 = -1431655766;
  *(_QWORD *)&v22 = 4;
  if (sysctlbyname("kern.entropy.health.adaptive_proportion_test.max_observation_count", &v18, (size_t *)&v22, 0, 0) < 0|| (_QWORD)v22 != 4)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_39;
    LODWORD(v22) = 136315138;
    *(_QWORD *)((char *)&v22 + 4) = "kern.entropy.health.adaptive_proportion_test.max_observation_count";
    v7 = MEMORY[0x1E0C81028];
    goto LABEL_37;
  }
  v17 = -1431655766;
  *(_QWORD *)&v22 = 4;
  if (sysctlbyname("kern.entropy.health.adaptive_proportion_test.reset_count", &v17, (size_t *)&v22, 0, 0) < 0
    || (_QWORD)v22 != 4)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_39;
    LODWORD(v22) = 136315138;
    *(_QWORD *)((char *)&v22 + 4) = "kern.entropy.health.adaptive_proportion_test.reset_count";
    v7 = MEMORY[0x1E0C81028];
    goto LABEL_37;
  }
  v16 = -1431655766;
  *(_QWORD *)&v22 = 4;
  if (sysctlbyname("kern.entropy.health.repetition_count_test.failure_count", &v16, (size_t *)&v22, 0, 0) < 0
    || (_QWORD)v22 != 4)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_39;
    LODWORD(v22) = 136315138;
    *(_QWORD *)((char *)&v22 + 4) = "kern.entropy.health.repetition_count_test.failure_count";
    v7 = MEMORY[0x1E0C81028];
    goto LABEL_37;
  }
  v15 = -1431655766;
  *(_QWORD *)&v22 = 4;
  if (sysctlbyname("kern.entropy.health.repetition_count_test.max_observation_count", &v15, (size_t *)&v22, 0, 0) < 0
    || (_QWORD)v22 != 4)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_39;
    LODWORD(v22) = 136315138;
    *(_QWORD *)((char *)&v22 + 4) = "kern.entropy.health.repetition_count_test.max_observation_count";
    v7 = MEMORY[0x1E0C81028];
    goto LABEL_37;
  }
  v14 = -1431655766;
  *(_QWORD *)&v22 = 4;
  if ((sysctlbyname("kern.entropy.health.repetition_count_test.reset_count", &v14, (size_t *)&v22, 0, 0) & 0x80000000) == 0
    && (_QWORD)v22 == 4)
  {
    v0 = v17;
    v1 = 1 << -(char)__clz(v17);
    if ((v17 & (v17 - 1)) != 0)
      v0 = v1;
    v17 = v0;
    v2 = v14;
    v3 = 1 << -(char)__clz(v14);
    if ((v14 & (v14 - 1)) != 0)
      v2 = v3;
    v14 = v2;
    v4 = v19 | v16;
    if (!(v19 | v16))
    {
      v6 = 0;
      v5 = -1;
      goto LABEL_56;
    }
    v21 = 0xAAAAAAAAAAAAAAAALL;
    time(&v21);
    *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)v31 = 16;
    if ((sysctlbyname("kern.boottime", &v22, (size_t *)v31, 0, 0) & 0x80000000) == 0 && *(_QWORD *)v31 == 16)
    {
      v5 = ((int)v21 - (int)v22) / 60;
      v4 = v19;
      v6 = v16;
      v0 = v17;
      v2 = v14;
LABEL_56:
      *(_QWORD *)&v22 = MEMORY[0x1E0C809B0];
      *((_QWORD *)&v22 + 1) = 3221225472;
      v23 = __SecCoreAnalyticsSendKernEntropyHealthAnalytics_block_invoke;
      v24 = &__block_descriptor_64_e19___NSDictionary_8__0l;
      v25 = COERCE_DOUBLE(__PAIR64__(v20, v5));
      v26 = __PAIR64__(v18, v4);
      v27 = v0;
      v28 = v6;
      v29 = v15;
      v30 = v2;
      +[SecCoreAnalytics sendEventLazy:builder:](SecCoreAnalytics, "sendEventLazy:builder:", CFSTR("com.apple.kern.entropyHealth"), &v22);
      goto LABEL_39;
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_39;
    *(_DWORD *)v31 = 136315138;
    *(_QWORD *)&v31[4] = "kern.boottime";
    v7 = MEMORY[0x1E0C81028];
    v8 = v31;
    goto LABEL_38;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    LODWORD(v22) = 136315138;
    *(_QWORD *)((char *)&v22 + 4) = "kern.entropy.health.repetition_count_test.reset_count";
    v7 = MEMORY[0x1E0C81028];
    goto LABEL_37;
  }
LABEL_39:
  *(_QWORD *)v31 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v22 = 8;
  if (sysctlbyname("kern.entropy.filter.rejected_sample_count", v31, (size_t *)&v22, 0, 0) < 0
    || (_QWORD)v22 != 8)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      return;
    LODWORD(v22) = 136315138;
    *(_QWORD *)((char *)&v22 + 4) = "kern.entropy.filter.rejected_sample_count";
    v13 = MEMORY[0x1E0C81028];
    goto LABEL_54;
  }
  v21 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v22 = 8;
  if (sysctlbyname("kern.entropy.filter.total_sample_count", &v21, (size_t *)&v22, 0, 0) < 0 || (_QWORD)v22 != 8)
  {
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      return;
    LODWORD(v22) = 136315138;
    *(_QWORD *)((char *)&v22 + 4) = "kern.entropy.filter.total_sample_count";
    v13 = MEMORY[0x1E0C81028];
LABEL_54:
    _os_log_error_impl(&dword_18A900000, v13, OS_LOG_TYPE_ERROR, "failed to read sysctl %s", (uint8_t *)&v22, 0xCu);
    return;
  }
  v9 = v21;
  *((_QWORD *)&v22 + 1) = 3221225472;
  v10 = (double)(unint64_t)v21;
  v11 = __clz(v21);
  if (v11)
    v12 = 1 << -(char)v11;
  else
    v12 = -1;
  if ((v21 & (v21 - 1)) != 0)
    v9 = v12;
  v21 = v9;
  *(_QWORD *)&v22 = MEMORY[0x1E0C809B0];
  v23 = __SecCoreAnalyticsSendKernEntropyFilterAnalytics_block_invoke;
  v24 = &__block_descriptor_48_e19___NSDictionary_8__0l;
  v25 = (double)*(unint64_t *)v31 / v10;
  v26 = v9;
  +[SecCoreAnalytics sendEventLazy:builder:](SecCoreAnalytics, "sendEventLazy:builder:", CFSTR("com.apple.kern.entropy.filter"), &v22);
}

void SecCoreAnalyticsSendLegacyKeychainUIEvent(uint64_t a1, uint64_t a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  __CFString *v7;
  NSObject *v8;
  _QWORD v9[4];
  __CFString *v10;
  id v11;
  uint8_t buf[16];

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  +[SecCoreAnalytics appNameFromPath:](SecCoreAnalytics, "appNameFromPath:", v3);
  v4 = objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", a1, 4);
  v5 = objc_claimAutoreleasedReturnValue();
  v6 = (void *)v5;
  if (v4)
    v7 = (__CFString *)v4;
  else
    v7 = CFSTR("unknown");
  if (v5)
  {
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = __SecCoreAnalyticsSendLegacyKeychainUIEvent_block_invoke;
    v9[3] = &unk_1E1FCDBE8;
    v10 = v7;
    v11 = v6;
    +[SecCoreAnalytics sendEventLazy:builder:](SecCoreAnalytics, "sendEventLazy:builder:", CFSTR("com.apple.security.LegacyAPICounts"), v9);

    v8 = v10;
  }
  else
  {
    secLogObjForScope("SecError");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "Logging keychain UI event failed: couldn't turn dialog type c_str into NSString", buf, 2u);
    }
  }

}

void sub_18A97D048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id sec_protocol_configuration_copy_singleton()
{
  if (sec_protocol_configuration_copy_singleton_onceToken != -1)
    dispatch_once(&sec_protocol_configuration_copy_singleton_onceToken, &__block_literal_global_3846);
  return (id)sec_protocol_configuration_copy_singleton_singleton;
}

void __sec_protocol_configuration_copy_singleton_block_invoke()
{
  SecConcrete_sec_protocol_configuration *v0;
  void *v1;
  SecConcrete_sec_protocol_configuration_builder *v2;

  v2 = objc_alloc_init(SecConcrete_sec_protocol_configuration_builder);
  v0 = sec_protocol_configuration_create_with_builder(v2);
  v1 = (void *)sec_protocol_configuration_copy_singleton_singleton;
  sec_protocol_configuration_copy_singleton_singleton = (uint64_t)v0;

}

void *sec_protocol_configuration_copy_transformed_options(uint64_t a1, void *a2)
{
  id v2;
  void *v3;
  _QWORD v5[4];
  __int16 v6;

  v2 = a2;
  v3 = v2;
  if (v2)
  {
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&__block_literal_global_13);
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 0x40000000;
    v5[2] = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
    v5[3] = &__block_descriptor_tmp_11;
    v6 = 3;
    sec_protocol_options_access_handle((uint64_t)v3, (uint64_t)v5);
  }
  sec_protocol_configuration_copy_transformed_options_with_ats_minimums(v3);
  objc_claimAutoreleasedReturnValue();

  return v3;
}

id sec_protocol_configuration_copy_transformed_options_with_ats_minimums(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    v3 = MEMORY[0x1E0C809B0];
    v5 = MEMORY[0x1E0C809B0];
    v6 = 0x40000000;
    v7 = __sec_protocol_options_set_ats_required_block_invoke;
    v8 = &__block_descriptor_tmp_52;
    LOBYTE(v9) = 1;
    sec_protocol_options_access_handle((uint64_t)v1, (uint64_t)&v5);
    v5 = v3;
    v6 = 0x40000000;
    v7 = __sec_protocol_options_set_trusted_peer_certificate_block_invoke;
    v8 = &__block_descriptor_tmp_56_2827;
    LOBYTE(v9) = 1;
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&v5);
    v5 = v3;
    v6 = 0x40000000;
    v7 = __sec_protocol_options_set_minimum_rsa_key_size_block_invoke;
    v8 = &__block_descriptor_tmp_53;
    v9 = 2048;
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&v5);
    v5 = v3;
    v6 = 0x40000000;
    v7 = __sec_protocol_options_set_minimum_ecdsa_key_size_block_invoke;
    v8 = &__block_descriptor_tmp_54;
    v9 = 256;
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&v5);
    v5 = v3;
    v6 = 0x40000000;
    v7 = __sec_protocol_options_set_minimum_signature_algorithm_block_invoke;
    v8 = &__block_descriptor_tmp_55;
    LODWORD(v9) = 6;
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&v5);
    v5 = v3;
    v6 = 0x40000000;
    v7 = __sec_protocol_options_set_min_tls_protocol_version_block_invoke;
    v8 = &__block_descriptor_tmp_14;
    LOWORD(v9) = 771;
    sec_protocol_options_access_handle((uint64_t)v2, (uint64_t)&v5);
  }
  return v2;
}

uint64_t sec_protocol_configuration_copy_transformed_options_for_host(void *a1, void *a2, const char *a3)
{
  id v5;
  id v6;
  uint64_t v7;

  v5 = a2;
  v6 = a1;
  sec_protocol_configuration_copy_transformed_options_with_ats_minimums(v5);
  objc_claimAutoreleasedReturnValue();
  sec_protocol_configuration_copy_transformed_options_for_host_internal(v6, v5, a3);
  v7 = objc_claimAutoreleasedReturnValue();

  return v7;
}

id sec_protocol_configuration_copy_transformed_options_for_host_internal(void *a1, void *a2, const char *a3)
{
  id *v5;
  id v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  id v13;
  size_t v14;
  const char *v15;
  int v16;
  __int16 int64;
  uint64_t v18;
  id v19;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  void *v24;
  __int16 v25;

  v5 = a1;
  v6 = a2;
  v7 = v5[1];
  v8 = v7;
  if (v7)
  {
    xpc_dictionary_get_dictionary(v7, "NSExceptionDomains");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = v9;
    if (!v9)
    {
      v13 = v6;
LABEL_23:

      goto LABEL_24;
    }
    xpc_dictionary_get_dictionary(v9, a3);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = v11;
    if (!v11)
    {
      v14 = strlen(a3);
      if (!v14)
      {
LABEL_13:
        sec_protocol_configuration_copy_transformed_options(v14, v6);
        v13 = v6;
LABEL_22:

        goto LABEL_23;
      }
      v15 = a3;
      while (1)
      {
        v16 = *(unsigned __int8 *)v15++;
        if (v16 == 46)
          break;
        if (!--v14)
          goto LABEL_13;
      }
      sec_protocol_configuration_copy_transformed_options_for_host_internal(v5, v6, a3 + 1);
      v19 = (id)objc_claimAutoreleasedReturnValue();
LABEL_21:
      v13 = v19;
      goto LABEL_22;
    }
    if (xpc_dictionary_get_BOOL(v11, "NSExceptionRequiresForwardSecrecy"))
    {
      if (!v6)
        goto LABEL_17;
      sec_protocol_options_access_handle((uint64_t)v6, (uint64_t)&__block_literal_global_13);
      v21 = MEMORY[0x1E0C809B0];
      v22 = 0x40000000;
      v23 = __sec_protocol_options_append_tls_ciphersuite_group_block_invoke;
      v24 = &__block_descriptor_tmp_11;
      v25 = 3;
    }
    else
    {
      if (!v6)
        goto LABEL_17;
      v21 = MEMORY[0x1E0C809B0];
      v22 = 0x40000000;
      v23 = __sec_protocol_options_set_ats_non_pfs_ciphersuite_allowed_block_invoke;
      v24 = &__block_descriptor_tmp_69;
      LOBYTE(v25) = 1;
    }
    sec_protocol_options_access_handle((uint64_t)v6, (uint64_t)&v21);
LABEL_17:
    int64 = xpc_dictionary_get_int64(v12, "NSExceptionMinimumTLSVersion");
    if (int64 && v6)
    {
      v18 = MEMORY[0x1E0C809B0];
      v21 = MEMORY[0x1E0C809B0];
      v22 = 0x40000000;
      v23 = __sec_protocol_options_set_min_tls_protocol_version_block_invoke;
      v24 = &__block_descriptor_tmp_14;
      v25 = int64;
      sec_protocol_options_access_handle((uint64_t)v6, (uint64_t)&v21);
      v21 = v18;
      v22 = 0x40000000;
      v23 = __sec_protocol_options_set_ats_minimum_tls_version_allowed_block_invoke;
      v24 = &__block_descriptor_tmp_70;
      LOBYTE(v25) = 1;
      sec_protocol_options_access_handle((uint64_t)v6, (uint64_t)&v21);
    }
    v19 = v6;
    goto LABEL_21;
  }
  v13 = v6;
LABEL_24:

  return v13;
}

BOOL sec_protocol_configuration_tls_required(uint64_t a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;

  v1 = *(id *)(a1 + 8);
  v2 = v1;
  if (v1)
  {
    if (xpc_dictionary_get_BOOL(v1, "NSAllowsArbitraryLoadsForMedia"))
    {
      if (client_is_mediaserverd_onceToken != -1)
        dispatch_once(&client_is_mediaserverd_onceToken, &__block_literal_global_22);
      if (client_is_mediaserverd_is_mediaserverd)
        goto LABEL_10;
    }
    if (!xpc_dictionary_get_BOOL(v2, "NSAllowsArbitraryLoadsInWebContent"))
      goto LABEL_12;
    if (client_is_WebKit_onceToken != -1)
      dispatch_once(&client_is_WebKit_onceToken, &__block_literal_global_25);
    if (client_is_WebKit_is_WebKit)
LABEL_10:
      v3 = 0;
    else
LABEL_12:
      v3 = !xpc_dictionary_get_BOOL(v2, "NSAllowsArbitraryLoads");
  }
  else
  {
    v3 = 1;
  }

  return v3;
}

BOOL process_matches_target(_BOOL8 __s)
{
  const char *v1;
  size_t v2;

  if (__s)
  {
    v1 = (const char *)__s;
    if (get_running_process_onceToken != -1)
      dispatch_once(&get_running_process_onceToken, &__block_literal_global_24);
    if (get_running_process_processName
      && (v2 = strlen(v1), v2 == strlen((const char *)get_running_process_processName)))
    {
      return strncmp((const char *)get_running_process_processName, v1, v2) == 0;
    }
    else
    {
      return 0;
    }
  }
  return __s;
}

uint64_t *__get_running_process_block_invoke()
{
  uint64_t *result;

  result = (uint64_t *)_CFGetProgname();
  get_running_process_processName = *result;
  return result;
}

BOOL __client_is_mediaserverd_block_invoke()
{
  _BOOL8 result;

  result = process_matches_target((_BOOL8)"mediaserverd");
  client_is_mediaserverd_is_mediaserverd = result;
  return result;
}

BOOL sec_protocol_configuration_tls_required_for_host(void *a1, const char *a2, uint64_t a3)
{
  return sec_protocol_configuration_tls_required_for_host_internal(a1, a2, 0, a3);
}

BOOL sec_protocol_configuration_tls_required_for_host_internal(void *a1, const char *a2, int a3, uint64_t a4)
{
  id *v7;
  id v8;
  void *v9;
  _BOOL8 v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  _BOOL4 v15;
  size_t v16;
  const char *v17;
  int v18;
  uint64_t v19;

  v7 = a1;
  v8 = v7[1];
  v9 = v8;
  if (!v8)
  {
    v10 = 1;
    goto LABEL_20;
  }
  if (!(_DWORD)a4 || !xpc_dictionary_get_BOOL(v8, "NSAllowsLocalNetworking"))
  {
    xpc_dictionary_get_dictionary(v9, "NSExceptionDomains");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = v11;
    if (!v11)
    {
      v10 = sec_protocol_configuration_tls_required((uint64_t)v7);
LABEL_19:

      goto LABEL_20;
    }
    xpc_dictionary_get_dictionary(v11, a2);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    v14 = v13;
    if (v13)
    {
      v10 = !xpc_dictionary_get_BOOL(v13, "NSExceptionAllowsInsecureHTTPLoads");
      v15 = xpc_dictionary_get_BOOL(v14, "NSExceptionAllowsInsecureHTTPLoads");
      if (!a3 || !v15)
        goto LABEL_18;
    }
    else
    {
      v16 = strlen(a2);
      if (v16)
      {
        v17 = a2;
        while (1)
        {
          v18 = *(unsigned __int8 *)v17++;
          if (v18 == 46)
            break;
          if (!--v16)
            goto LABEL_16;
        }
        v19 = sec_protocol_configuration_tls_required_for_host_internal(v7, a2 + 1, 1, a4);
        goto LABEL_17;
      }
    }
LABEL_16:
    v19 = sec_protocol_configuration_tls_required((uint64_t)v7);
LABEL_17:
    v10 = v19;
LABEL_18:

    goto LABEL_19;
  }
  v10 = 0;
LABEL_20:

  return v10;
}

BOOL sec_protocol_configuration_tls_required_for_address(uint64_t a1)
{
  id v1;
  void *v2;
  _BOOL8 v3;

  v1 = *(id *)(a1 + 8);
  v2 = v1;
  if (v1)
    v3 = !xpc_dictionary_get_BOOL(v1, "NSAllowsLocalNetworking");
  else
    v3 = 1;

  return v3;
}

uint64_t tls1x_minor_version_digit_to_version(int a1)
{
  if ((a1 - 48) >= 4)
    return 0;
  else
    return (unsigned __int16)(a1 + 721);
}

uint64_t dtls1x_minor_version_digit_to_version(int a1)
{
  unsigned __int16 v1;

  if (a1 == 50)
    v1 = -259;
  else
    v1 = 0;
  if (a1 == 48)
    return (unsigned __int16)-257;
  return v1;
}

void sec_protocol_configuration_register_builtin_exception(void *a1, const char *a2, unsigned int a3)
{
  xpc_object_t v5;
  xpc_object_t value;

  xpc_dictionary_get_dictionary(a1, "NSExceptionDomains");
  value = (xpc_object_t)objc_claimAutoreleasedReturnValue();
  if (value)
  {
    v5 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_value(v5, "NSExceptionDomains", value);
    xpc_dictionary_set_BOOL(v5, "NSIncludesSubdomains", 1);
    xpc_dictionary_set_int64(v5, "NSExceptionMinimumTLSVersion", a3);
    xpc_dictionary_set_BOOL(v5, "NSExceptionAllowsInsecureHTTPLoads", 1);
    xpc_dictionary_set_BOOL(v5, "NSExceptionRequiresForwardSecrecy", 0);
    xpc_dictionary_set_value(value, a2, v5);

  }
}

BOOL sec_protocol_configuration_set_ats_overrides(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  char v9;
  _BOOL8 v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  char v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  char v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  char v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  _QWORD v31[4];
  id v32;

  if (!a2)
    return 0;
  v3 = *(id *)(a1 + 8);
  if (v3)
  {
    v4 = a2;
    v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSAllowsArbitraryLoads");
    objc_msgSend(v4, "objectForKeyedSubscript:", v5);
    v6 = (void *)objc_claimAutoreleasedReturnValue();

    if (v6)
    {
      v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSAllowsArbitraryLoads");
      objc_msgSend(v4, "valueForKey:", v7);
      v8 = (void *)objc_claimAutoreleasedReturnValue();

      if (v8)
        v9 = objc_msgSend(v8, "BOOLValue");
      else
        v9 = 0;

    }
    else
    {
      v9 = 0;
    }
    v11 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSAllowsArbitraryLoadsInWebContent");
    objc_msgSend(v4, "objectForKeyedSubscript:", v11);
    v12 = (void *)objc_claimAutoreleasedReturnValue();

    if (v12)
    {
      v13 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSAllowsArbitraryLoadsInWebContent");
      objc_msgSend(v4, "valueForKey:", v13);
      v14 = (void *)objc_claimAutoreleasedReturnValue();

      if (v14)
        v15 = objc_msgSend(v14, "BOOLValue");
      else
        v15 = 0;

    }
    else
    {
      v15 = 0;
    }
    v16 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSAllowsArbitraryLoadsForMedia");
    objc_msgSend(v4, "objectForKeyedSubscript:", v16);
    v17 = (void *)objc_claimAutoreleasedReturnValue();

    if (v17)
    {
      v18 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSAllowsArbitraryLoadsForMedia");
      objc_msgSend(v4, "valueForKey:", v18);
      v19 = (void *)objc_claimAutoreleasedReturnValue();

      if (v19)
        v20 = objc_msgSend(v19, "BOOLValue");
      else
        v20 = 0;

    }
    else
    {
      v20 = 0;
    }
    v21 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSAllowsLocalNetworking");
    objc_msgSend(v4, "objectForKeyedSubscript:", v21);
    v22 = (void *)objc_claimAutoreleasedReturnValue();

    if (v22)
    {
      v23 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSAllowsLocalNetworking");
      objc_msgSend(v4, "valueForKey:", v23);
      v24 = (void *)objc_claimAutoreleasedReturnValue();

      if (v24)
        v25 = objc_msgSend(v24, "BOOLValue");
      else
        v25 = 0;

    }
    else
    {
      v25 = 0;
    }
    xpc_dictionary_set_BOOL(v3, "NSAllowsArbitraryLoads", v9);
    xpc_dictionary_set_BOOL(v3, "NSAllowsArbitraryLoadsInWebContent", v15);
    xpc_dictionary_set_BOOL(v3, "NSAllowsArbitraryLoadsForMedia", v20);
    xpc_dictionary_set_BOOL(v3, "NSAllowsLocalNetworking", v25);
    v26 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSExceptionDomains");
    objc_msgSend(v4, "valueForKey:", v26);
    v27 = (void *)objc_claimAutoreleasedReturnValue();

    if (v27)
    {
      xpc_dictionary_get_dictionary(v3, "NSExceptionDomains");
      v28 = (void *)objc_claimAutoreleasedReturnValue();
      v29 = v28;
      v10 = v28 != 0;
      if (v28)
      {
        v31[0] = MEMORY[0x1E0C809B0];
        v31[1] = 3221225472;
        v31[2] = __sec_protocol_configuration_set_ats_overrides_block_invoke;
        v31[3] = &unk_1E1FCDCC8;
        v32 = v28;
        objc_msgSend(v27, "enumerateKeysAndObjectsUsingBlock:", v31);

      }
    }
    else
    {
      v10 = 1;
    }

  }
  else
  {
    v10 = 0;
  }

  return v10;
}

void __sec_protocol_configuration_set_ats_overrides_block_invoke(uint64_t a1, void *a2, void *a3, _BYTE *a4)
{
  objc_class *v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  char v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  char v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  char v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  __CFString *v28;
  xpc_object_t v29;
  __CFString *v30;
  unsigned __int8 *v31;
  int v32;
  _BOOL8 v33;
  unsigned __int8 *v34;
  int64_t v35;
  void *v36;
  id v37;
  const char *v38;
  unsigned int v39;
  id v40;

  v40 = a3;
  if (!v40)
    *a4 = 1;
  v7 = (objc_class *)MEMORY[0x1E0CB3940];
  v8 = a2;
  v9 = (void *)objc_msgSend([v7 alloc], "initWithFormat:", CFSTR("%s"), "NSExceptionAllowsInsecureHTTPLoads");
  objc_msgSend(v40, "objectForKeyedSubscript:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();

  if (v10)
  {
    v11 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSExceptionAllowsInsecureHTTPLoads");
    objc_msgSend(v40, "valueForKey:", v11);
    v12 = (void *)objc_claimAutoreleasedReturnValue();

    if (v12)
      v13 = objc_msgSend(v12, "BOOLValue");
    else
      v13 = 0;

  }
  else
  {
    v13 = 0;
  }
  v14 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSIncludesSubdomains");
  objc_msgSend(v40, "objectForKeyedSubscript:", v14);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  if (v15)
  {
    v16 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSIncludesSubdomains");
    objc_msgSend(v40, "valueForKey:", v16);
    v17 = (void *)objc_claimAutoreleasedReturnValue();

    if (v17)
      v18 = objc_msgSend(v17, "BOOLValue");
    else
      v18 = 0;

  }
  else
  {
    v18 = 0;
  }
  v19 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSExceptionRequiresForwardSecrecy");
  objc_msgSend(v40, "objectForKeyedSubscript:", v19);
  v20 = (void *)objc_claimAutoreleasedReturnValue();

  if (v20)
  {
    v21 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSExceptionRequiresForwardSecrecy");
    objc_msgSend(v40, "valueForKey:", v21);
    v22 = (void *)objc_claimAutoreleasedReturnValue();

    if (v22)
      v23 = objc_msgSend(v22, "BOOLValue");
    else
      v23 = 0;

  }
  else
  {
    v23 = 0;
  }
  v24 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSExceptionMinimumTLSVersion");
  objc_msgSend(v40, "objectForKeyedSubscript:", v24);
  v25 = (void *)objc_claimAutoreleasedReturnValue();

  if (v25)
  {
    v26 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithFormat:", CFSTR("%s"), "NSExceptionMinimumTLSVersion");
    objc_msgSend(v40, "valueForKey:", v26);
    v27 = (void *)objc_claimAutoreleasedReturnValue();

    if (v27)
      v28 = v27;
    else
      v28 = CFSTR("TLSv1.2");

  }
  else
  {
    v28 = CFSTR("TLSv1.2");
  }
  v29 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_BOOL(v29, "NSIncludesSubdomains", v18);
  xpc_dictionary_set_BOOL(v29, "NSExceptionAllowsInsecureHTTPLoads", v13);
  xpc_dictionary_set_BOOL(v29, "NSExceptionRequiresForwardSecrecy", v23);
  v30 = objc_retainAutorelease(v28);
  v31 = (unsigned __int8 *)-[__CFString cStringUsingEncoding:](v30, "cStringUsingEncoding:", 4);
  if (v31
    && ((v32 = *v31, v33 = v32 == 68) ? (v34 = v31 + 1) : (v34 = v31),
        !strncmp((const char *)v34, "TLSv1.", 6uLL)
     && (v39 = ((uint64_t (*)(_QWORD))off_1E1FCDCB0[v33])((char)v34[6])) != 0))
  {
    if (v34[7])
      v35 = 0;
    else
      v35 = v39;
  }
  else
  {
    v35 = 0;
  }
  xpc_dictionary_set_int64(v29, "NSExceptionMinimumTLSVersion", v35);
  v36 = *(void **)(a1 + 32);
  v37 = objc_retainAutorelease(v8);
  v38 = (const char *)objc_msgSend(v37, "cStringUsingEncoding:", 4);

  xpc_dictionary_set_value(v36, v38, v29);
}

BOOL SECSFAActionTapToRadarReadFrom(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int *v5;
  int *v7;
  char v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char v13;
  int v15;
  uint64_t v17;
  uint64_t v18;
  void *v19;

  v3 = (int *)MEMORY[0x1E0D82BF0];
  v4 = (int *)MEMORY[0x1E0D82BD8];
  v5 = (int *)MEMORY[0x1E0D82BC8];
  if (*(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BF0]) < *(_QWORD *)(a2 + (int)*MEMORY[0x1E0D82BD8]))
  {
    v7 = (int *)MEMORY[0x1E0D82BB8];
    while (1)
    {
      if (*(_BYTE *)(a2 + *v5))
        return *(_BYTE *)(a2 + *v5) == 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      while (1)
      {
        v11 = *v3;
        v12 = *(_QWORD *)(a2 + v11);
        if (v12 == -1 || v12 >= *(_QWORD *)(a2 + *v4))
          break;
        v13 = *(_BYTE *)(*(_QWORD *)(a2 + *v7) + v12);
        *(_QWORD *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0)
          goto LABEL_12;
        v8 += 7;
        if (v9++ >= 9)
        {
          v10 = 0;
          v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(_BYTE *)(a2 + *v5) = 1;
LABEL_12:
      v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(_BYTE *)(a2 + *v5))
        v10 = 0;
LABEL_14:
      if (v15 || (v10 & 7) == 4)
        return *(_BYTE *)(a2 + *v5) == 0;
      switch((v10 >> 3))
      {
        case 1u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 8;
          goto LABEL_24;
        case 2u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 40;
          goto LABEL_24;
        case 3u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 24;
          goto LABEL_24;
        case 4u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 32;
          goto LABEL_24;
        case 5u:
          PBReaderReadString();
          v17 = objc_claimAutoreleasedReturnValue();
          v18 = 16;
LABEL_24:
          v19 = *(void **)(a1 + v18);
          *(_QWORD *)(a1 + v18) = v17;

          goto LABEL_25;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0)
            return 0;
LABEL_25:
          if (*(_QWORD *)(a2 + *v3) >= *(_QWORD *)(a2 + *v4))
            return *(_BYTE *)(a2 + *v5) == 0;
          break;
      }
    }
  }
  return *(_BYTE *)(a2 + *v5) == 0;
}

void sub_18A97FFC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v17;
  va_list va;

  va_start(va, a17);
  _Block_object_dispose((const void *)(v17 - 160), 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A980850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A980DF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

void sub_18A981B3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a35, 8);
  _Unwind_Resume(a1);
}

void sub_18A98230C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

void sub_18A982B5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A983210(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8;
  va_list va;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a7);
  va_start(va, a7);
  v8 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_18A983968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A983AE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_18A986D40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A987158(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_18A987650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4162(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4163(uint64_t a1)
{

}

id getKCPairingChannelClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getKCPairingChannelClass_softClass;
  v7 = getKCPairingChannelClass_softClass;
  if (!getKCPairingChannelClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getKCPairingChannelClass_block_invoke;
    v3[3] = &unk_1E1FD8CF0;
    v3[4] = &v4;
    __getKCPairingChannelClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_18A988794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getKCPairingChannelClass_block_invoke(uint64_t a1)
{
  void *v2;
  void *v3;

  KeychainCircleLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("KCPairingChannel");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getKCPairingChannelClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getKCPairingChannelClass(void)_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("OTClique.m"), 69, CFSTR("Unable to find class %s"), "KCPairingChannel");

    __break(1u);
  }
}

void *KeychainCircleLibrary()
{
  void *v0;
  void *v2;
  void *v3;

  if (!KeychainCircleLibraryCore_frameworkLibrary)
    KeychainCircleLibraryCore_frameworkLibrary = _sl_dlopen();
  v0 = (void *)KeychainCircleLibraryCore_frameworkLibrary;
  if (!KeychainCircleLibraryCore_frameworkLibrary)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v0 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *KeychainCircleLibrary(void)");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v2, CFSTR("OTClique.m"), 64, CFSTR("%s"), 0);

    __break(1u);
    free(v3);
  }
  return v0;
}

id getAAFAnalyticsEventSecurityClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getAAFAnalyticsEventSecurityClass_softClass;
  v7 = getAAFAnalyticsEventSecurityClass_softClass;
  if (!getAAFAnalyticsEventSecurityClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getAAFAnalyticsEventSecurityClass_block_invoke;
    v3[3] = &unk_1E1FD8CF0;
    v3[4] = &v4;
    __getAAFAnalyticsEventSecurityClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_18A988BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void getkSecurityRTCEventCategoryAccountDataAccessRecovery()
{
  id *v0;
  void *v1;
  id v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = (id *)getkSecurityRTCEventCategoryAccountDataAccessRecoverySymbolLoc_ptr;
  v8 = getkSecurityRTCEventCategoryAccountDataAccessRecoverySymbolLoc_ptr;
  if (!getkSecurityRTCEventCategoryAccountDataAccessRecoverySymbolLoc_ptr)
  {
    v1 = KeychainCircleLibrary();
    v0 = (id *)dlsym(v1, "kSecurityRTCEventCategoryAccountDataAccessRecovery");
    v6[3] = (uint64_t)v0;
    getkSecurityRTCEventCategoryAccountDataAccessRecoverySymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v2 = *v0;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSNumber *getkSecurityRTCEventCategoryAccountDataAccessRecovery(void)");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("OTClique.m"), 74, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

void sub_18A988CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id getSecurityAnalyticsReporterRTCClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getSecurityAnalyticsReporterRTCClass_softClass;
  v7 = getSecurityAnalyticsReporterRTCClass_softClass;
  if (!getSecurityAnalyticsReporterRTCClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getSecurityAnalyticsReporterRTCClass_block_invoke;
    v3[3] = &unk_1E1FD8CF0;
    v3[4] = &v4;
    __getSecurityAnalyticsReporterRTCClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_18A988D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getSecurityAnalyticsReporterRTCClass_block_invoke(uint64_t a1)
{
  void *v2;
  void *v3;

  KeychainCircleLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("SecurityAnalyticsReporterRTC");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getSecurityAnalyticsReporterRTCClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getSecurityAnalyticsReporterRTCClass(void)_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("OTClique.m"), 71, CFSTR("Unable to find class %s"), "SecurityAnalyticsReporterRTC");

    __break(1u);
  }
}

void __getAAFAnalyticsEventSecurityClass_block_invoke(uint64_t a1)
{
  void *v2;
  void *v3;

  KeychainCircleLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("AAFAnalyticsEventSecurity");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getAAFAnalyticsEventSecurityClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getAAFAnalyticsEventSecurityClass(void)_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("OTClique.m"), 72, CFSTR("Unable to find class %s"), "AAFAnalyticsEventSecurity");

    __break(1u);
  }
}

void sub_18A98AB64(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_18A98AE90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_18A98B4C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  uint64_t v11;
  va_list va;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a9);
  va_start(va, a9);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v9 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_18A98BCB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a23, 8);
  _Unwind_Resume(a1);
}

void sub_18A98C100(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98C508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98C910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98CD38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98D164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98D590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98D9BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98DDE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98E1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98E5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98EA1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98EE48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98F288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98F6E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98F8E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A98FAFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v9;
  va_list va;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  va_list va1;

  va_start(va1, a8);
  va_start(va, a8);
  v9 = va_arg(va1, _QWORD);
  v11 = va_arg(va1, _QWORD);
  v12 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_18A990450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a33, 8);
  _Unwind_Resume(a1);
}

void sub_18A9909F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id getSecureBackupClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getSecureBackupClass_softClass;
  v7 = getSecureBackupClass_softClass;
  if (!getSecureBackupClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getSecureBackupClass_block_invoke;
    v3[3] = &unk_1E1FD8CF0;
    v3[4] = &v4;
    __getSecureBackupClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_18A990AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void getkSecureBackupAuthenticationAppleID()
{
  id *v0;
  void *v1;
  id v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = (id *)getkSecureBackupAuthenticationAppleIDSymbolLoc_ptr;
  v8 = getkSecureBackupAuthenticationAppleIDSymbolLoc_ptr;
  if (!getkSecureBackupAuthenticationAppleIDSymbolLoc_ptr)
  {
    v1 = CloudServicesLibrary();
    v0 = (id *)dlsym(v1, "kSecureBackupAuthenticationAppleID");
    v6[3] = (uint64_t)v0;
    getkSecureBackupAuthenticationAppleIDSymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v2 = *v0;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSString *getkSecureBackupAuthenticationAppleID(void)");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("OTClique.m"), 78, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

void sub_18A990BB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void getkSecureBackupAuthenticationPassword()
{
  id *v0;
  void *v1;
  id v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = (id *)getkSecureBackupAuthenticationPasswordSymbolLoc_ptr;
  v8 = getkSecureBackupAuthenticationPasswordSymbolLoc_ptr;
  if (!getkSecureBackupAuthenticationPasswordSymbolLoc_ptr)
  {
    v1 = CloudServicesLibrary();
    v0 = (id *)dlsym(v1, "kSecureBackupAuthenticationPassword");
    v6[3] = (uint64_t)v0;
    getkSecureBackupAuthenticationPasswordSymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v2 = *v0;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSString *getkSecureBackupAuthenticationPassword(void)");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("OTClique.m"), 79, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

void sub_18A990CB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void getkSecureBackupiCloudDataProtectionDeleteAllRecordsKey()
{
  id *v0;
  void *v1;
  id v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = (id *)getkSecureBackupiCloudDataProtectionDeleteAllRecordsKeySymbolLoc_ptr;
  v8 = getkSecureBackupiCloudDataProtectionDeleteAllRecordsKeySymbolLoc_ptr;
  if (!getkSecureBackupiCloudDataProtectionDeleteAllRecordsKeySymbolLoc_ptr)
  {
    v1 = CloudServicesLibrary();
    v0 = (id *)dlsym(v1, "kSecureBackupiCloudDataProtectionDeleteAllRecordsKey");
    v6[3] = (uint64_t)v0;
    getkSecureBackupiCloudDataProtectionDeleteAllRecordsKeySymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v2 = *v0;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSString *getkSecureBackupiCloudDataProtectionDeleteAllRecordsKey(void)");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("OTClique.m"), 80, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

void sub_18A990DAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void getkSecureBackupContainsiCDPDataKey()
{
  id *v0;
  void *v1;
  id v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v0 = (id *)getkSecureBackupContainsiCDPDataKeySymbolLoc_ptr;
  v8 = getkSecureBackupContainsiCDPDataKeySymbolLoc_ptr;
  if (!getkSecureBackupContainsiCDPDataKeySymbolLoc_ptr)
  {
    v1 = CloudServicesLibrary();
    v0 = (id *)dlsym(v1, "kSecureBackupContainsiCDPDataKey");
    v6[3] = (uint64_t)v0;
    getkSecureBackupContainsiCDPDataKeySymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v5, 8);
  if (v0)
  {
    v2 = *v0;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSString *getkSecureBackupContainsiCDPDataKey(void)");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("OTClique.m"), 81, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

void sub_18A990EA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *CloudServicesLibrary()
{
  void *v0;
  void *v2;
  void *v3;

  if (!CloudServicesLibraryCore_frameworkLibrary)
    CloudServicesLibraryCore_frameworkLibrary = _sl_dlopen();
  v0 = (void *)CloudServicesLibraryCore_frameworkLibrary;
  if (!CloudServicesLibraryCore_frameworkLibrary)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v0 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *CloudServicesLibrary(void)");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v2, CFSTR("OTClique.m"), 65, CFSTR("%s"), 0);

    __break(1u);
    free(v3);
  }
  return v0;
}

void __getSecureBackupClass_block_invoke(uint64_t a1)
{
  void *v2;
  void *v3;

  CloudServicesLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("SecureBackup");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getSecureBackupClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getSecureBackupClass(void)_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("OTClique.m"), 76, CFSTR("Unable to find class %s"), "SecureBackup");

    __break(1u);
  }
}

const __CFString *OTCliqueStatusToString(uint64_t a1)
{
  if ((unint64_t)(a1 + 1) > 5)
    return CFSTR("CliqueStatusIn");
  else
    return off_1E1FCE148[a1 + 1];
}

uint64_t OTCliqueStatusFromString(void *a1)
{
  id v1;
  uint64_t v2;

  v1 = a1;
  if ((objc_msgSend(v1, "isEqualToString:", CFSTR("CliqueStatusIn")) & 1) != 0)
  {
    v2 = 0;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("CliqueStatusNotIn")) & 1) != 0)
  {
    v2 = 1;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("CliqueStatusPending")) & 1) != 0)
  {
    v2 = 2;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("CliqueStatusAbsent")) & 1) != 0)
  {
    v2 = 3;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("CliqueStatusNoCloudKitAccount")) & 1) != 0)
  {
    v2 = 4;
  }
  else
  {
    objc_msgSend(v1, "isEqualToString:", CFSTR("CliqueStatusError"));
    v2 = -1;
  }

  return v2;
}

const __CFString *OTCDPStatusToString(uint64_t a1)
{
  const __CFString *v1;

  v1 = CFSTR("unknown");
  if (a1 == 1)
    v1 = CFSTR("disabled");
  if (a1 == 2)
    return CFSTR("enabled");
  else
    return v1;
}

id deserializedRecordFromRow(void *a1)
{
  id v1;
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;
  NSObject *v7;
  id v9;
  uint8_t buf[4];
  id v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = objc_msgSend(v1, "indexForColumnName:", CFSTR("data"));
  if (v2 == 0x7FFFFFFFFFFFFFFFLL)
  {
    v3 = 0;
  }
  else
  {
    v4 = (void *)MEMORY[0x1E0CB38B0];
    objc_msgSend(v1, "blobAtIndex:", v2);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = 0;
    objc_msgSend(v4, "propertyListWithData:options:format:error:", v5, 1, 0, &v9);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = v9;

    if (!v3)
    {
      secLogObjForScope("SecError");
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        v11 = v6;
        _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "SFAnalytics: failed to deserialize record: %{public}@", buf, 0xCu);
      }

    }
  }

  return v3;
}

id makeLightweightCodeRequirement(const __CFData *a1)
{
  void *v1;
  id v2;
  NSObject *v3;
  id v5;
  uint8_t buf[4];
  const char *v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v5 = 0;
  +[sec_LWCR withData:withError:](sec_LWCR, "withData:withError:", a1, &v5);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = v5;
  if (v2)
  {
    secLogObjForScope("SecError");
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v7 = "makeLightweightCodeRequirement";
      _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "%s: failed to parse LightweightCodeRequirement", buf, 0xCu);
    }

  }
  return v1;
}

void bindAndAddBoolFact(void *a1, const char *a2, uint64_t a3)
{
  void *v5;
  id v6;

  v6 = a1;
  +[sec_LWCRFact BOOLFact:](sec_LWCRFact, "BOOLFact:", a3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  bindAndAdd(v6, a2, v5);

}

void sub_18A996244(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void bindAndAdd(void *a1, const char *a2, void *a3)
{
  id v5;
  void *v6;
  id v7;

  v7 = a1;
  v5 = a3;
  objc_msgSend(v5, "bindName:withLength:", a2, strlen(a2));
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a2);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "setObject:forKeyedSubscript:", v5, v6);

}

void sub_18A9962F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void bindAndAddIntegerFact(void *a1, const char *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  id v7;

  v7 = a1;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLongLong:", a3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  +[sec_LWCRFact integerFact:](sec_LWCRFact, "integerFact:", v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  bindAndAdd(v7, a2, v6);
}

void sub_18A99639C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void bindAndAddStringFact(void *a1, const char *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  id v7;

  v7 = a1;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", a3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  +[sec_LWCRFact stringFact:](sec_LWCRFact, "stringFact:", v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  bindAndAdd(v7, a2, v6);
}

void sub_18A996450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_18A996520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)sec_LWCR;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void sub_18A996A78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void *ce_malloc(const CERuntime *a1, size_t size)
{
  return malloc_type_malloc(size, 0x9B56FAB0uLL);
}

void ce_free(const CERuntime *a1, void *a2)
{
  free(a2);
}

void ce_log(const CERuntime *a1, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  vsyslog(7, a2, va);
}

void ce_abort(const CERuntime *a1, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  vsyslog(2, a2, va);
  abort();
}

void sub_18A996B80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)sec_LWCRFact;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_18A996C80(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_18A996D14(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_18A996F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  void *v14;
  void *v15;
  void *v16;

  if (v16)
    operator delete(v16);

  _Unwind_Resume(a1);
}

void sub_18A996FE8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t serializeDict(void *a1, char **a2)
{
  char *v3;
  unint64_t v4;
  char *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  char *v13;
  char *v14;
  __int128 v15;
  void *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  char *v23;
  unint64_t v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  char *v32;
  char *v33;
  _QWORD *v34;
  __int128 v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  char *v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  unint64_t v51;
  __int128 v52;
  void *v53;
  void *v54;
  uint64_t v55;
  char *v56;
  unint64_t v57;
  char *v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  char *v65;
  char *v66;
  _QWORD *v67;
  __int128 v68;
  char *v69;
  unint64_t v70;
  char *v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  _QWORD *v77;
  unint64_t v78;
  char *v79;
  char *v80;
  __int128 v81;
  id obj;
  id v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  _BYTE v89[128];
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  v84 = a1;
  v3 = a2[1];
  v4 = (unint64_t)a2[2];
  if ((unint64_t)v3 >= v4)
  {
    v6 = (v3 - *a2) >> 5;
    v7 = v6 + 1;
    if ((unint64_t)(v6 + 1) >> 59)
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    v8 = v4 - (_QWORD)*a2;
    if (v8 >> 4 > v7)
      v7 = v8 >> 4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0)
      v9 = 0x7FFFFFFFFFFFFFFLL;
    else
      v9 = v7;
    if (v9)
      v9 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v9);
    else
      v10 = 0;
    v11 = (_QWORD *)(v9 + 32 * v6);
    v12 = v9 + 32 * v10;
    *v11 = 7;
    v11[1] = 0;
    v11[2] = 0;
    v11[3] = 0;
    v5 = (char *)(v11 + 4);
    v14 = *a2;
    v13 = a2[1];
    if (v13 != *a2)
    {
      do
      {
        v15 = *((_OWORD *)v13 - 1);
        *((_OWORD *)v11 - 2) = *((_OWORD *)v13 - 2);
        *((_OWORD *)v11 - 1) = v15;
        v11 -= 4;
        v13 -= 32;
      }
      while (v13 != v14);
      v13 = *a2;
    }
    *a2 = (char *)v11;
    a2[1] = v5;
    a2[2] = (char *)v12;
    if (v13)
      operator delete(v13);
  }
  else
  {
    *(_QWORD *)v3 = 7;
    *((_QWORD *)v3 + 1) = 0;
    *((_QWORD *)v3 + 2) = 0;
    *((_QWORD *)v3 + 3) = 0;
    v5 = v3 + 32;
  }
  a2[1] = v5;
  v16 = (void *)MEMORY[0x1E0C99DE8];
  objc_msgSend(v84, "allKeys");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v16, "arrayWithArray:", v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v18, "sortUsingSelector:", sel_compare_);
  v87 = 0u;
  v88 = 0u;
  v85 = 0u;
  v86 = 0u;
  obj = v18;
  v19 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v85, v89, 16);
  if (v19)
  {
    v20 = *(_QWORD *)v86;
LABEL_19:
    v21 = 0;
    while (1)
    {
      if (*(_QWORD *)v86 != v20)
        objc_enumerationMutation(obj);
      v22 = *(void **)(*((_QWORD *)&v85 + 1) + 8 * v21);
      v23 = a2[1];
      v24 = (unint64_t)a2[2];
      if ((unint64_t)v23 >= v24)
      {
        v26 = (v23 - *a2) >> 5;
        v27 = v26 + 1;
        if ((unint64_t)(v26 + 1) >> 59)
          std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
        v28 = v24 - (_QWORD)*a2;
        if (v28 >> 4 > v27)
          v27 = v28 >> 4;
        if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFE0)
          v29 = 0x7FFFFFFFFFFFFFFLL;
        else
          v29 = v27;
        if (v29)
          v29 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v29);
        else
          v30 = 0;
        v31 = (_QWORD *)(v29 + 32 * v26);
        *v31 = 5;
        v31[1] = 0;
        v31[2] = 0;
        v31[3] = 0;
        v33 = *a2;
        v32 = a2[1];
        v34 = v31;
        if (v32 != *a2)
        {
          do
          {
            v35 = *((_OWORD *)v32 - 1);
            *((_OWORD *)v34 - 2) = *((_OWORD *)v32 - 2);
            *((_OWORD *)v34 - 1) = v35;
            v34 -= 4;
            v32 -= 32;
          }
          while (v32 != v33);
          v32 = *a2;
        }
        v25 = (char *)(v31 + 4);
        *a2 = (char *)v34;
        a2[1] = (char *)(v31 + 4);
        a2[2] = (char *)(v29 + 32 * v30);
        if (v32)
          operator delete(v32);
      }
      else
      {
        *(_QWORD *)v23 = 5;
        *((_QWORD *)v23 + 1) = 0;
        v25 = v23 + 32;
        *((_QWORD *)v23 + 2) = 0;
        *((_QWORD *)v23 + 3) = 0;
      }
      a2[1] = v25;
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        break;
      v36 = objc_retainAutorelease(v22);
      v37 = objc_msgSend(v36, "UTF8String");
      v38 = objc_msgSend(v36, "lengthOfBytesUsingEncoding:", 4);
      v39 = v38;
      v40 = a2[1];
      v41 = a2[2];
      if (v40 >= v41)
      {
        v43 = (v40 - *a2) >> 5;
        v44 = v43 + 1;
        if ((unint64_t)(v43 + 1) >> 59)
          std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
        v45 = v41 - *a2;
        if (v45 >> 4 > v44)
          v44 = v45 >> 4;
        if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFE0)
          v46 = 0x7FFFFFFFFFFFFFFLL;
        else
          v46 = v44;
        if (v46)
          v46 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v46);
        else
          v47 = 0;
        v48 = v46 + 32 * v43;
        *(_QWORD *)v48 = 3;
        *(_QWORD *)(v48 + 8) = v37;
        *(_QWORD *)(v48 + 16) = v39;
        *(_BYTE *)(v48 + 24) = 0;
        v50 = *a2;
        v49 = a2[1];
        v51 = v48;
        if (v49 != *a2)
        {
          do
          {
            v52 = *((_OWORD *)v49 - 1);
            *(_OWORD *)(v51 - 32) = *((_OWORD *)v49 - 2);
            *(_OWORD *)(v51 - 16) = v52;
            v51 -= 32;
            v49 -= 32;
          }
          while (v49 != v50);
          v49 = *a2;
        }
        v42 = v48 + 32;
        *a2 = (char *)v51;
        a2[1] = (char *)(v48 + 32);
        a2[2] = (char *)(v46 + 32 * v47);
        if (v49)
          operator delete(v49);
      }
      else
      {
        *(_QWORD *)v40 = 3;
        *((_QWORD *)v40 + 1) = v37;
        *((_QWORD *)v40 + 2) = v38;
        v42 = (unint64_t)(v40 + 32);
        v40[24] = 0;
      }
      a2[1] = (char *)v42;
      objc_msgSend(v84, "objectForKeyedSubscript:", v36);
      v53 = (void *)objc_claimAutoreleasedReturnValue();
      v54 = v53;
      if (!v53)
      {
        v55 = *MEMORY[0x1E0DDFF98];
LABEL_79:

LABEL_80:
        goto LABEL_96;
      }
      v55 = serializeId(v53, (void **)a2);
      if (v55 != *MEMORY[0x1E0DDFFA0])
        goto LABEL_79;
      v56 = a2[1];
      v57 = (unint64_t)a2[2];
      if ((unint64_t)v56 >= v57)
      {
        v59 = (v56 - *a2) >> 5;
        v60 = v59 + 1;
        if ((unint64_t)(v59 + 1) >> 59)
          std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
        v61 = v57 - (_QWORD)*a2;
        if (v61 >> 4 > v60)
          v60 = v61 >> 4;
        if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFE0)
          v62 = 0x7FFFFFFFFFFFFFFLL;
        else
          v62 = v60;
        if (v62)
          v62 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v62);
        else
          v63 = 0;
        v64 = (_QWORD *)(v62 + 32 * v59);
        *v64 = 6;
        v64[1] = 0;
        v64[2] = 0;
        v64[3] = 0;
        v66 = *a2;
        v65 = a2[1];
        v67 = v64;
        if (v65 != *a2)
        {
          do
          {
            v68 = *((_OWORD *)v65 - 1);
            *((_OWORD *)v67 - 2) = *((_OWORD *)v65 - 2);
            *((_OWORD *)v67 - 1) = v68;
            v67 -= 4;
            v65 -= 32;
          }
          while (v65 != v66);
          v65 = *a2;
        }
        v58 = (char *)(v64 + 4);
        *a2 = (char *)v67;
        a2[1] = (char *)(v64 + 4);
        a2[2] = (char *)(v62 + 32 * v63);
        if (v65)
          operator delete(v65);
      }
      else
      {
        *(_QWORD *)v56 = 6;
        *((_QWORD *)v56 + 1) = 0;
        v58 = v56 + 32;
        *((_QWORD *)v56 + 2) = 0;
        *((_QWORD *)v56 + 3) = 0;
      }
      a2[1] = v58;

      if (++v21 == v19)
      {
        v19 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v85, v89, 16);
        if (v19)
          goto LABEL_19;
        goto LABEL_75;
      }
    }
    v55 = *MEMORY[0x1E0DDFF98];
    goto LABEL_80;
  }
LABEL_75:

  v69 = a2[1];
  v70 = (unint64_t)a2[2];
  if ((unint64_t)v69 >= v70)
  {
    v72 = (v69 - *a2) >> 5;
    v73 = v72 + 1;
    if ((unint64_t)(v72 + 1) >> 59)
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    v74 = v70 - (_QWORD)*a2;
    if (v74 >> 4 > v73)
      v73 = v74 >> 4;
    if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFE0)
      v75 = 0x7FFFFFFFFFFFFFFLL;
    else
      v75 = v73;
    if (v75)
      v75 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v75);
    else
      v76 = 0;
    v77 = (_QWORD *)(v75 + 32 * v72);
    v78 = v75 + 32 * v76;
    *v77 = 8;
    v77[1] = 0;
    v77[2] = 0;
    v77[3] = 0;
    v71 = (char *)(v77 + 4);
    v80 = *a2;
    v79 = a2[1];
    if (v79 != *a2)
    {
      do
      {
        v81 = *((_OWORD *)v79 - 1);
        *((_OWORD *)v77 - 2) = *((_OWORD *)v79 - 2);
        *((_OWORD *)v77 - 1) = v81;
        v77 -= 4;
        v79 -= 32;
      }
      while (v79 != v80);
      v79 = *a2;
    }
    *a2 = (char *)v77;
    a2[1] = v71;
    a2[2] = (char *)v78;
    if (v79)
      operator delete(v79);
  }
  else
  {
    *(_QWORD *)v69 = 8;
    *((_QWORD *)v69 + 1) = 0;
    *((_QWORD *)v69 + 2) = 0;
    *((_QWORD *)v69 + 3) = 0;
    v71 = v69 + 32;
  }
  a2[1] = v71;
  v55 = *MEMORY[0x1E0DDFFA0];
LABEL_96:

  return v55;
}

void sub_18A997600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{

  _Unwind_Resume(a1);
}

void std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](unint64_t a1)
{
  if (a1 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a1);
}

uint64_t serializeId(void *a1, void **a2)
{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  CFTypeID v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  void *v21;
  id v22;
  _QWORD *v23;
  unint64_t v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  __int128 v30;
  uint64_t *v31;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  char *v49;
  __int128 v50;
  char *v51;
  __int128 v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  unint64_t v59;
  char *v60;
  char *v61;
  __int128 v62;
  id v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  _QWORD *v69;
  unint64_t v70;
  _QWORD *v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  uint64_t v76;
  char *v77;
  __int128 v78;
  _QWORD *v79;
  unint64_t v80;
  char *v81;
  char *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  _BYTE v88[128];
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v4 = objc_retainAutorelease(v3);
    v5 = objc_msgSend(v4, "UTF8String");
    v6 = objc_msgSend(v4, "lengthOfBytesUsingEncoding:", 4);
    v7 = (uint64_t *)a2[1];
    v8 = (uint64_t *)a2[2];
    if (v7 < v8)
    {
      v9 = 2;
LABEL_4:
      *v7 = v9;
      v7[1] = v5;
      v7[2] = v6;
LABEL_22:
      *((_BYTE *)v7 + 24) = 0;
      v21 = v7 + 4;
LABEL_32:
      a2[1] = v21;

LABEL_33:
      v31 = (uint64_t *)MEMORY[0x1E0DDFFA0];
LABEL_34:
      v19 = *v31;
      goto LABEL_35;
    }
    v14 = ((char *)v7 - (_BYTE *)*a2) >> 5;
    v15 = v14 + 1;
    if ((unint64_t)(v14 + 1) >> 59)
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    v16 = (char *)v8 - (_BYTE *)*a2;
    if (v16 >> 4 > v15)
      v15 = v16 >> 4;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFE0)
      v17 = 0x7FFFFFFFFFFFFFFLL;
    else
      v17 = v15;
    if (v17)
      v17 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v17);
    else
      v18 = 0;
    v26 = v17 + 32 * v14;
    v27 = v17 + 32 * v18;
    *(_QWORD *)v26 = 2;
    *(_QWORD *)(v26 + 8) = v5;
    *(_QWORD *)(v26 + 16) = v6;
    *(_BYTE *)(v26 + 24) = 0;
    v21 = (void *)(v26 + 32);
    v29 = (char *)*a2;
    v28 = (char *)a2[1];
    if (v28 != *a2)
    {
      do
      {
        v30 = *((_OWORD *)v28 - 1);
        *(_OWORD *)(v26 - 32) = *((_OWORD *)v28 - 2);
        *(_OWORD *)(v26 - 16) = v30;
        v26 -= 32;
        v28 -= 32;
      }
      while (v28 != v29);
LABEL_29:
      v28 = (char *)*a2;
      goto LABEL_30;
    }
    goto LABEL_30;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v4 = v3;
    v10 = CFGetTypeID(v4);
    if (v10 == CFBooleanGetTypeID())
    {
      v11 = objc_msgSend(v4, "BOOLValue");
      v7 = (uint64_t *)a2[1];
      v12 = (uint64_t *)a2[2];
      if (v7 >= v12)
      {
        v33 = ((char *)v7 - (_BYTE *)*a2) >> 5;
        v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 59)
          std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
        v35 = (char *)v12 - (_BYTE *)*a2;
        if (v35 >> 4 > v34)
          v34 = v35 >> 4;
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFE0)
          v36 = 0x7FFFFFFFFFFFFFFLL;
        else
          v36 = v34;
        if (v36)
          v36 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v36);
        else
          v37 = 0;
        v26 = v36 + 32 * v33;
        v27 = v36 + 32 * v37;
        *(_QWORD *)v26 = 1;
        *(_QWORD *)(v26 + 8) = v11;
        *(_QWORD *)(v26 + 16) = 0;
        *(_BYTE *)(v26 + 24) = 0;
        v21 = (void *)(v26 + 32);
        v49 = (char *)*a2;
        v28 = (char *)a2[1];
        if (v28 == *a2)
          goto LABEL_30;
        do
        {
          v50 = *((_OWORD *)v28 - 1);
          *(_OWORD *)(v26 - 32) = *((_OWORD *)v28 - 2);
          *(_OWORD *)(v26 - 16) = v50;
          v26 -= 32;
          v28 -= 32;
        }
        while (v28 != v49);
        goto LABEL_29;
      }
      v13 = 1;
    }
    else
    {
      v11 = objc_msgSend(v4, "longLongValue");
      v7 = (uint64_t *)a2[1];
      v20 = (uint64_t *)a2[2];
      if (v7 >= v20)
      {
        v38 = ((char *)v7 - (_BYTE *)*a2) >> 5;
        v39 = v38 + 1;
        if ((unint64_t)(v38 + 1) >> 59)
          std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
        v40 = (char *)v20 - (_BYTE *)*a2;
        if (v40 >> 4 > v39)
          v39 = v40 >> 4;
        if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFE0)
          v41 = 0x7FFFFFFFFFFFFFFLL;
        else
          v41 = v39;
        if (v41)
          v41 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v41);
        else
          v42 = 0;
        v26 = v41 + 32 * v38;
        v27 = v41 + 32 * v42;
        *(_QWORD *)v26 = 4;
        *(_QWORD *)(v26 + 8) = v11;
        *(_QWORD *)(v26 + 16) = 0;
        *(_BYTE *)(v26 + 24) = 0;
        v21 = (void *)(v26 + 32);
        v51 = (char *)*a2;
        v28 = (char *)a2[1];
        if (v28 == *a2)
          goto LABEL_30;
        do
        {
          v52 = *((_OWORD *)v28 - 1);
          *(_OWORD *)(v26 - 32) = *((_OWORD *)v28 - 2);
          *(_OWORD *)(v26 - 16) = v52;
          v26 -= 32;
          v28 -= 32;
        }
        while (v28 != v51);
        goto LABEL_29;
      }
      v13 = 4;
    }
    *v7 = v13;
    v7[1] = v11;
    v7[2] = 0;
    goto LABEL_22;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v22 = v3;
      v23 = a2[1];
      v24 = (unint64_t)a2[2];
      if ((unint64_t)v23 >= v24)
      {
        v44 = ((char *)v23 - (_BYTE *)*a2) >> 5;
        v45 = v44 + 1;
        if ((unint64_t)(v44 + 1) >> 59)
          std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
        v46 = v24 - (_QWORD)*a2;
        if (v46 >> 4 > v45)
          v45 = v46 >> 4;
        if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFE0)
          v47 = 0x7FFFFFFFFFFFFFFLL;
        else
          v47 = v45;
        if (v47)
          v47 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v47);
        else
          v48 = 0;
        v58 = (_QWORD *)(v47 + 32 * v44);
        v59 = v47 + 32 * v48;
        *v58 = 5;
        v58[1] = 0;
        v58[2] = 0;
        v58[3] = 0;
        v25 = v58 + 4;
        v61 = (char *)*a2;
        v60 = (char *)a2[1];
        if (v60 != *a2)
        {
          do
          {
            v62 = *((_OWORD *)v60 - 1);
            *((_OWORD *)v58 - 2) = *((_OWORD *)v60 - 2);
            *((_OWORD *)v58 - 1) = v62;
            v58 -= 4;
            v60 -= 32;
          }
          while (v60 != v61);
          v60 = (char *)*a2;
        }
        *a2 = v58;
        a2[1] = v25;
        a2[2] = (void *)v59;
        if (v60)
          operator delete(v60);
      }
      else
      {
        *v23 = 5;
        v23[1] = 0;
        v23[2] = 0;
        v23[3] = 0;
        v25 = v23 + 4;
      }
      a2[1] = v25;
      v84 = 0u;
      v85 = 0u;
      v86 = 0u;
      v87 = 0u;
      v63 = v22;
      v64 = objc_msgSend(v63, "countByEnumeratingWithState:objects:count:", &v84, v88, 16);
      if (v64)
      {
        v65 = *(_QWORD *)v85;
        v66 = (_QWORD *)MEMORY[0x1E0DDFFA0];
        while (2)
        {
          v67 = 0;
          do
          {
            if (*(_QWORD *)v85 != v65)
              objc_enumerationMutation(v63);
            v68 = *(_QWORD *)(*((_QWORD *)&v84 + 1) + 8 * v67);
            if (!v68 || serializeId(v68, a2) != *v66)
            {

              goto LABEL_117;
            }
            ++v67;
          }
          while (v64 != v67);
          v64 = objc_msgSend(v63, "countByEnumeratingWithState:objects:count:", &v84, v88, 16);
          if (v64)
            continue;
          break;
        }
      }

      v69 = a2[1];
      v70 = (unint64_t)a2[2];
      if ((unint64_t)v69 >= v70)
      {
        v72 = ((char *)v69 - (_BYTE *)*a2) >> 5;
        v73 = v72 + 1;
        if ((unint64_t)(v72 + 1) >> 59)
          std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
        v74 = v70 - (_QWORD)*a2;
        if (v74 >> 4 > v73)
          v73 = v74 >> 4;
        if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFE0)
          v75 = 0x7FFFFFFFFFFFFFFLL;
        else
          v75 = v73;
        if (v75)
          v75 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v75);
        else
          v76 = 0;
        v79 = (_QWORD *)(v75 + 32 * v72);
        v80 = v75 + 32 * v76;
        *v79 = 6;
        v79[1] = 0;
        v79[2] = 0;
        v79[3] = 0;
        v71 = v79 + 4;
        v82 = (char *)*a2;
        v81 = (char *)a2[1];
        if (v81 != *a2)
        {
          do
          {
            v83 = *((_OWORD *)v81 - 1);
            *((_OWORD *)v79 - 2) = *((_OWORD *)v81 - 2);
            *((_OWORD *)v79 - 1) = v83;
            v79 -= 4;
            v81 -= 32;
          }
          while (v81 != v82);
          v81 = (char *)*a2;
        }
        *a2 = v79;
        a2[1] = v71;
        a2[2] = (void *)v80;
        if (v81)
          operator delete(v81);
      }
      else
      {
        *v69 = 6;
        v69[1] = 0;
        v69[2] = 0;
        v69[3] = 0;
        v71 = v69 + 4;
      }
      a2[1] = v71;
LABEL_117:

      goto LABEL_33;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      v31 = (uint64_t *)MEMORY[0x1E0DDFF98];
      goto LABEL_34;
    }
    v4 = objc_retainAutorelease(v3);
    v5 = objc_msgSend(v4, "bytes");
    v6 = objc_msgSend(v4, "length");
    v7 = (uint64_t *)a2[1];
    v43 = (uint64_t *)a2[2];
    if (v7 < v43)
    {
      v9 = 9;
      goto LABEL_4;
    }
    v53 = ((char *)v7 - (_BYTE *)*a2) >> 5;
    v54 = v53 + 1;
    if ((unint64_t)(v53 + 1) >> 59)
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    v55 = (char *)v43 - (_BYTE *)*a2;
    if (v55 >> 4 > v54)
      v54 = v55 >> 4;
    if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFE0)
      v56 = 0x7FFFFFFFFFFFFFFLL;
    else
      v56 = v54;
    if (v56)
      v56 = (unint64_t)std::allocator<CESerializedElement>::allocate_at_least[abi:ne180100](v56);
    else
      v57 = 0;
    v26 = v56 + 32 * v53;
    v27 = v56 + 32 * v57;
    *(_QWORD *)v26 = 9;
    *(_QWORD *)(v26 + 8) = v5;
    *(_QWORD *)(v26 + 16) = v6;
    *(_BYTE *)(v26 + 24) = 0;
    v21 = (void *)(v26 + 32);
    v77 = (char *)*a2;
    v28 = (char *)a2[1];
    if (v28 != *a2)
    {
      do
      {
        v78 = *((_OWORD *)v28 - 1);
        *(_OWORD *)(v26 - 32) = *((_OWORD *)v28 - 2);
        *(_OWORD *)(v26 - 16) = v78;
        v26 -= 32;
        v28 -= 32;
      }
      while (v28 != v77);
      goto LABEL_29;
    }
LABEL_30:
    *a2 = (void *)v26;
    a2[1] = v21;
    a2[2] = (void *)v27;
    if (v28)
      operator delete(v28);
    goto LABEL_32;
  }
  v19 = serializeDict(v3, a2);
LABEL_35:

  return v19;
}

void sub_18A997D94(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E0DE4E98], MEMORY[0x1E0DE4390]);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E1FC5C58, MEMORY[0x1E0DE42D0]);
}

void sub_18A997E54(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

void sub_18A998264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,id a30)
{
  void *v30;
  void *v31;
  uint64_t v32;

  TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(v32 - 112);
  TLE::CallbackEncyclopedia::~CallbackEncyclopedia(&a30);

  _Unwind_Resume(a1);
}

void sub_18A998360(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_18A998408(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_18A998488(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD **libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::reset(_QWORD **a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *exception;

  v2 = *a1;
  if (v2)
  {
    v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
    }
    v4 = v3 - 1;
    v2[1] = v4;
    if (!v4)
      (*(void (**)(_QWORD *))(*v2 + 8))(v2);
  }
  *a1 = 0;
  return a1;
}

void TLE::CallbackEncyclopedia::~CallbackEncyclopedia(id *this)
{

}

{

  JUMPOUT(0x18D76FAA0);
}

uint64_t TLE::CallbackEncyclopedia::getFact(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
}

uint64_t TLE::CallbackEncyclopedia::resolveFact(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 16))();
}

uint64_t TLE::CallbackEncyclopedia::hasFactFor(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 24) + 16))();
}

void TLE::andDeserializer(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v5;
  const char *v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD **v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *exception;
  der_vm_context v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  if (*a3)
  {
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_DWORD *)a4 = 6;
    *(_QWORD *)(a4 + 8) = "$and operator disallowed for active fact";
    *(_QWORD *)(a4 + 16) = 40;
    return;
  }
  v22 = 0;
  v20 = 0u;
  v21 = 0u;
  v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v19.runtime = *(_OWORD *)a2;
  *(_OWORD *)&v19.lookup.index_count = v5;
  *(_OWORD *)&v19.sorted = *(_OWORD *)(a2 + 32);
  v19.var0.ccstate.der_end = *(char **)(a2 + 48);
  TLE::Executor::getDependentOpsFromDictionary((uint64_t)&v20, a1, &v19);
  if ((_DWORD)v20)
  {
    *(_OWORD *)a4 = v20;
    v7 = (_QWORD *)*((_QWORD *)&v21 + 1);
    *(_QWORD *)(a4 + 16) = v21;
    *(_QWORD *)(a4 + 24) = 0;
    if (!v7)
      return;
  }
  else
  {
    if ((_DWORD)v22 != 1)
    {
      v16 = operator new();
      *(_QWORD *)(v16 + 16) = 0;
      *(_QWORD *)(v16 + 24) = 0;
      *(_QWORD *)v16 = &off_1E1FC81C8;
      *(_QWORD *)(v16 + 8) = 1;
      *(_QWORD *)(v16 + 32) = *((_QWORD *)&v21 + 1);
      *(_DWORD *)(v16 + 40) = v22;
      *(_QWORD *)a4 = 0;
      *(_QWORD *)(a4 + 8) = 0;
      *(_QWORD *)(a4 + 16) = 0;
      *(_QWORD *)(a4 + 24) = v16;
      return;
    }
    v7 = (_QWORD *)*((_QWORD *)&v21 + 1);
    if (!*((_QWORD *)&v21 + 1))
      goto LABEL_26;
    v8 = 8 * v22;
    if (*((_QWORD *)&v21 + 1) + v8 < *((_QWORD *)&v21 + 1) || HIDWORD(v8))
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v6);
    if ((v8 & 0xFFFFFFF8) == 0)
LABEL_26:
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally", v6);
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    v9 = (_QWORD *)*v7;
    *(_QWORD *)(a4 + 16) = 0;
    *(_QWORD *)(a4 + 24) = v9;
    if (v9)
    {
      v10 = v9[1];
      if (v10 < 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        *exception = "Attempted resurection of an object";
        __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
      }
      v9[1] = v10 + 1;
    }
  }
  if ((_DWORD)v22)
  {
    v11 = 8 * v22;
    v12 = (_QWORD **)v7;
    do
    {
      v13 = *v12;
      if (*v12)
      {
        v14 = v13[1];
        if (v14 <= 0)
        {
          v17 = __cxa_allocate_exception(8uLL);
          *v17 = "Over-release of an object";
          __cxa_throw(v17, MEMORY[0x1E0DE4E50], 0);
        }
        v15 = v14 - 1;
        v13[1] = v15;
        if (!v15)
          (*(void (**)(_QWORD *))(*v13 + 8))(v13);
      }
      *v12++ = 0;
      v11 -= 8;
    }
    while (v11);
  }
  free(v7);
}

void sub_18A9987F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple((uint64_t)va);
  _Unwind_Resume(a1);
}

void TLE::orDeserializer(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  __int128 v5;
  const char *v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD **v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *exception;
  der_vm_context v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  if (*a3)
  {
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_DWORD *)a4 = 6;
    *(_QWORD *)(a4 + 8) = "$or operator disallowed for active fact";
    *(_QWORD *)(a4 + 16) = 39;
    return;
  }
  v22 = 0;
  v20 = 0u;
  v21 = 0u;
  v5 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v19.runtime = *(_OWORD *)a2;
  *(_OWORD *)&v19.lookup.index_count = v5;
  *(_OWORD *)&v19.sorted = *(_OWORD *)(a2 + 32);
  v19.var0.ccstate.der_end = *(char **)(a2 + 48);
  TLE::Executor::getDependentOpsFromDictionary((uint64_t)&v20, a1, &v19);
  if ((_DWORD)v20)
  {
    *(_OWORD *)a4 = v20;
    v7 = (_QWORD *)*((_QWORD *)&v21 + 1);
    *(_QWORD *)(a4 + 16) = v21;
    *(_QWORD *)(a4 + 24) = 0;
    if (!v7)
      return;
  }
  else
  {
    if ((_DWORD)v22 != 1)
    {
      v16 = operator new();
      *(_QWORD *)(v16 + 16) = 0;
      *(_QWORD *)(v16 + 24) = 0;
      *(_QWORD *)v16 = &off_1E1FC8198;
      *(_QWORD *)(v16 + 8) = 1;
      *(_QWORD *)(v16 + 32) = *((_QWORD *)&v21 + 1);
      *(_DWORD *)(v16 + 40) = v22;
      *(_QWORD *)a4 = 0;
      *(_QWORD *)(a4 + 8) = 0;
      *(_QWORD *)(a4 + 16) = 0;
      *(_QWORD *)(a4 + 24) = v16;
      return;
    }
    v7 = (_QWORD *)*((_QWORD *)&v21 + 1);
    if (!*((_QWORD *)&v21 + 1))
      goto LABEL_26;
    v8 = 8 * v22;
    if (*((_QWORD *)&v21 + 1) + v8 < *((_QWORD *)&v21 + 1) || HIDWORD(v8))
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v6);
    if ((v8 & 0xFFFFFFF8) == 0)
LABEL_26:
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally", v6);
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    v9 = (_QWORD *)*v7;
    *(_QWORD *)(a4 + 16) = 0;
    *(_QWORD *)(a4 + 24) = v9;
    if (v9)
    {
      v10 = v9[1];
      if (v10 < 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        *exception = "Attempted resurection of an object";
        __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
      }
      v9[1] = v10 + 1;
    }
  }
  if ((_DWORD)v22)
  {
    v11 = 8 * v22;
    v12 = (_QWORD **)v7;
    do
    {
      v13 = *v12;
      if (*v12)
      {
        v14 = v13[1];
        if (v14 <= 0)
        {
          v17 = __cxa_allocate_exception(8uLL);
          *v17 = "Over-release of an object";
          __cxa_throw(v17, MEMORY[0x1E0DE4E50], 0);
        }
        v15 = v14 - 1;
        v13[1] = v15;
        if (!v15)
          (*(void (**)(_QWORD *))(*v13 + 8))(v13);
      }
      *v12++ = 0;
      v11 -= 8;
    }
    while (v11);
  }
  free(v7);
}

void sub_18A998A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple((uint64_t)va);
  _Unwind_Resume(a1);
}

void TLE::inDeserializer(__int128 *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  const char *v10;
  uint64_t v11;

  if (*(_DWORD *)a2 > 6u || ((1 << *(_DWORD *)a2) & 0x58) == 0)
  {
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)a3 = 3;
    v10 = "Got an unexpected type (not an integer, string or data) when trying to generate an In operation.";
    v11 = 96;
  }
  else
  {
    if (der_vm_CEType_from_context() == 2)
    {
      v7 = operator new();
      v8 = *a1;
      v9 = a1[2];
      *(_OWORD *)(v7 + 48) = a1[1];
      *(_OWORD *)(v7 + 64) = v9;
      *(_QWORD *)(v7 + 80) = *((_QWORD *)a1 + 6);
      *(_QWORD *)v7 = &off_1E1FC8168;
      *(_QWORD *)(v7 + 8) = 1;
      *(_OWORD *)(v7 + 16) = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(v7 + 32) = v8;
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = v7;
      return;
    }
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)a3 = 3;
    v10 = "Got an unexpected type (not a sequence) when trying to read the array of matches.";
    v11 = 81;
  }
  *(_QWORD *)(a3 + 8) = v10;
  *(_QWORD *)(a3 + 16) = v11;
}

double _ZN3TLE17intOpDeserializerINS_11BinaryIntOpIxXtlNS_3__0EEEEEEENS_5TupleINS_5ErrorEN7libkern20intrusive_shared_ptrINS_9OperationENS_14RefCountPolicyEEEEERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE@<D0>(uint64_t a1@<X2>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;

  if (*(_DWORD *)a1 == 3 && der_vm_CEType_from_context() == 3)
  {
    v4 = der_vm_integer_from_context();
    v5 = operator new();
    *(_QWORD *)v5 = &off_1E1FC8018;
    *(_QWORD *)(v5 + 8) = 1;
    *(_QWORD *)(v5 + 32) = v4;
    v6 = *(_OWORD *)(a1 + 8);
    *(_OWORD *)(v5 + 16) = v6;
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    a2[3] = v5;
  }
  else
  {
    *(_QWORD *)&v6 = 0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_DWORD *)a2 = 3;
    a2[1] = "Got an unexpected type (not an integer) when trying to generate an integer operation.";
    a2[2] = 85;
  }
  return *(double *)&v6;
}

double _ZN3TLE17intOpDeserializerINS_11BinaryIntOpIxXtlNS_3__1EEEEEEENS_5TupleINS_5ErrorEN7libkern20intrusive_shared_ptrINS_9OperationENS_14RefCountPolicyEEEEERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE@<D0>(uint64_t a1@<X2>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;

  if (*(_DWORD *)a1 == 3 && der_vm_CEType_from_context() == 3)
  {
    v4 = der_vm_integer_from_context();
    v5 = operator new();
    *(_QWORD *)v5 = &off_1E1FC8048;
    *(_QWORD *)(v5 + 8) = 1;
    *(_QWORD *)(v5 + 32) = v4;
    v6 = *(_OWORD *)(a1 + 8);
    *(_OWORD *)(v5 + 16) = v6;
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    a2[3] = v5;
  }
  else
  {
    *(_QWORD *)&v6 = 0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_DWORD *)a2 = 3;
    a2[1] = "Got an unexpected type (not an integer) when trying to generate an integer operation.";
    a2[2] = 85;
  }
  return *(double *)&v6;
}

double _ZN3TLE17intOpDeserializerINS_11BinaryIntOpIxXtlNS_3__2EEEEEEENS_5TupleINS_5ErrorEN7libkern20intrusive_shared_ptrINS_9OperationENS_14RefCountPolicyEEEEERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE@<D0>(uint64_t a1@<X2>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;

  if (*(_DWORD *)a1 == 3 && der_vm_CEType_from_context() == 3)
  {
    v4 = der_vm_integer_from_context();
    v5 = operator new();
    *(_QWORD *)v5 = &off_1E1FC8078;
    *(_QWORD *)(v5 + 8) = 1;
    *(_QWORD *)(v5 + 32) = v4;
    v6 = *(_OWORD *)(a1 + 8);
    *(_OWORD *)(v5 + 16) = v6;
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    a2[3] = v5;
  }
  else
  {
    *(_QWORD *)&v6 = 0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_DWORD *)a2 = 3;
    a2[1] = "Got an unexpected type (not an integer) when trying to generate an integer operation.";
    a2[2] = 85;
  }
  return *(double *)&v6;
}

double _ZN3TLE17intOpDeserializerINS_11BinaryIntOpIxXtlNS_3__3EEEEEEENS_5TupleINS_5ErrorEN7libkern20intrusive_shared_ptrINS_9OperationENS_14RefCountPolicyEEEEERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE@<D0>(uint64_t a1@<X2>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;

  if (*(_DWORD *)a1 == 3 && der_vm_CEType_from_context() == 3)
  {
    v4 = der_vm_integer_from_context();
    v5 = operator new();
    *(_QWORD *)v5 = &off_1E1FC80A8;
    *(_QWORD *)(v5 + 8) = 1;
    *(_QWORD *)(v5 + 32) = v4;
    v6 = *(_OWORD *)(a1 + 8);
    *(_OWORD *)(v5 + 16) = v6;
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    a2[3] = v5;
  }
  else
  {
    *(_QWORD *)&v6 = 0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_DWORD *)a2 = 3;
    a2[1] = "Got an unexpected type (not an integer) when trying to generate an integer operation.";
    a2[2] = 85;
  }
  return *(double *)&v6;
}

double _ZN3TLE17intOpDeserializerINS_11BinaryIntOpIxXtlNS_3__4EEEEEEENS_5TupleINS_5ErrorEN7libkern20intrusive_shared_ptrINS_9OperationENS_14RefCountPolicyEEEEERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE@<D0>(uint64_t a1@<X2>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;

  if (*(_DWORD *)a1 == 3 && der_vm_CEType_from_context() == 3)
  {
    v4 = der_vm_integer_from_context();
    v5 = operator new();
    *(_QWORD *)v5 = &off_1E1FC80D8;
    *(_QWORD *)(v5 + 8) = 1;
    *(_QWORD *)(v5 + 32) = v4;
    v6 = *(_OWORD *)(a1 + 8);
    *(_OWORD *)(v5 + 16) = v6;
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    a2[3] = v5;
  }
  else
  {
    *(_QWORD *)&v6 = 0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *(_DWORD *)a2 = 3;
    a2[1] = "Got an unexpected type (not an integer) when trying to generate an integer operation.";
    a2[2] = 85;
  }
  return *(double *)&v6;
}

void TLE::optionalOpDeserializer(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v4;
  const char *v5;
  _QWORD **v6;
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD **v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *exception;
  der_vm_context v16;
  __int128 v17;
  void *v18[2];
  uint64_t v19;

  v19 = 0;
  v17 = 0u;
  *(_OWORD *)v18 = 0u;
  v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)&v16.runtime = *(_OWORD *)a2;
  *(_OWORD *)&v16.lookup.index_count = v4;
  *(_OWORD *)&v16.sorted = *(_OWORD *)(a2 + 32);
  v16.var0.ccstate.der_end = *(char **)(a2 + 48);
  TLE::Executor::getDependentOpsFromDictionary((uint64_t)&v17, a1, &v16);
  if ((_DWORD)v17)
  {
    *(_OWORD *)a3 = v17;
    *(void **)(a3 + 16) = v18[0];
    *(_QWORD *)(a3 + 24) = 0;
    v6 = (_QWORD **)v18[1];
    if (!v18[1])
      return;
    goto LABEL_12;
  }
  if ((_DWORD)v19 != 1)
  {
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_DWORD *)a3 = 6;
    *(_QWORD *)(a3 + 8) = "$optional only supports a single dependent operation";
    *(_QWORD *)(a3 + 16) = 52;
    v6 = (_QWORD **)v18[1];
    if (!v18[1])
      return;
    goto LABEL_12;
  }
  v7 = v18[1];
  if (!v18[1])
    goto LABEL_23;
  v8 = 8 * v19;
  if ((char *)v18[1] + v8 < v18[1] || HIDWORD(v8))
    os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v5);
  if ((v8 & 0xFFFFFFF8) == 0)
LABEL_23:
    os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally", v5);
  v9 = operator new();
  *(_QWORD *)(v9 + 16) = 0;
  *(_QWORD *)(v9 + 24) = 0;
  *(_QWORD *)v9 = &off_1E1FC8258;
  *(_QWORD *)(v9 + 8) = 1;
  *(_QWORD *)(v9 + 32) = *v7;
  *v7 = 0;
  *(_BYTE *)(v9 + 40) = 0;
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = v9;
  v6 = (_QWORD **)v18[1];
  if (v18[1])
  {
LABEL_12:
    if ((_DWORD)v19)
    {
      v10 = 8 * v19;
      v11 = v6;
      do
      {
        v12 = *v11;
        if (*v11)
        {
          v13 = v12[1];
          if (v13 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
          }
          v14 = v13 - 1;
          v12[1] = v14;
          if (!v14)
            (*(void (**)(_QWORD *))(*v12 + 8))(v12);
        }
        *v11++ = 0;
        v10 -= 8;
      }
      while (v10);
    }
    free(v6);
  }
}

void sub_18A999210(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple((uint64_t)va);
  _Unwind_Resume(a1);
}

void TLE::queryOpDeserializer(__int128 *a1@<X1>, uint64_t a2@<X2>, _QWORD *a3@<X8>)
{
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  if (*(_DWORD *)a2 == 1)
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2000000000;
    v12 = 1;
    der_vm_iterate_b();
    if (*((_BYTE *)v10 + 24))
    {
      v6 = operator new();
      v7 = *a1;
      v8 = a1[2];
      *(_OWORD *)(v6 + 48) = a1[1];
      *(_OWORD *)(v6 + 64) = v8;
      *(_QWORD *)(v6 + 80) = *((_QWORD *)a1 + 6);
      *(_QWORD *)v6 = &off_1E1FC8228;
      *(_QWORD *)(v6 + 8) = 1;
      *(_OWORD *)(v6 + 16) = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(v6 + 32) = v7;
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      a3[3] = v6;
    }
    else
    {
      *(_OWORD *)a3 = 0u;
      *((_OWORD *)a3 + 1) = 0u;
      *(_DWORD *)a3 = 6;
      a3[1] = "$query deserialization failed since it has an invalid query definition";
      a3[2] = 70;
    }
    _Block_object_dispose(&v9, 8);
  }
  else
  {
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
    *(_DWORD *)a3 = 3;
    a3[1] = "Got an unexpected type (not a dictionary) when trying to generate a query operation.";
    a3[2] = 84;
  }
}

void sub_18A999370(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void TLE::andArrayOpDeserializer(uint64_t a1@<X0>, const der_vm_context *a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  const char *v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD **v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *exception;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v20 = 0;
  v18 = 0u;
  v19 = 0u;
  TLE::opArrayOpDeserializer((uint64_t)&v18, a1, a2, a3);
  if ((_DWORD)v18)
  {
    *(_OWORD *)a4 = v18;
    v6 = (_QWORD *)*((_QWORD *)&v19 + 1);
    *(_QWORD *)(a4 + 16) = v19;
    *(_QWORD *)(a4 + 24) = 0;
    if (!v6)
      return;
  }
  else
  {
    if ((_DWORD)v20 != 1)
    {
      v15 = operator new();
      *(_QWORD *)(v15 + 16) = 0;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)v15 = &off_1E1FC81C8;
      *(_QWORD *)(v15 + 8) = 1;
      *(_QWORD *)(v15 + 32) = *((_QWORD *)&v19 + 1);
      *(_DWORD *)(v15 + 40) = v20;
      *(_QWORD *)a4 = 0;
      *(_QWORD *)(a4 + 8) = 0;
      *(_QWORD *)(a4 + 16) = 0;
      *(_QWORD *)(a4 + 24) = v15;
      return;
    }
    v6 = (_QWORD *)*((_QWORD *)&v19 + 1);
    if (!*((_QWORD *)&v19 + 1))
      goto LABEL_24;
    v7 = 8 * v20;
    if (*((_QWORD *)&v19 + 1) + v7 < *((_QWORD *)&v19 + 1) || HIDWORD(v7))
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v5);
    if ((v7 & 0xFFFFFFF8) == 0)
LABEL_24:
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally", v5);
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    v8 = (_QWORD *)*v6;
    *(_QWORD *)(a4 + 16) = 0;
    *(_QWORD *)(a4 + 24) = v8;
    if (v8)
    {
      v9 = v8[1];
      if (v9 < 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        *exception = "Attempted resurection of an object";
        __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
      }
      v8[1] = v9 + 1;
    }
  }
  if ((_DWORD)v20)
  {
    v10 = 8 * v20;
    v11 = (_QWORD **)v6;
    do
    {
      v12 = *v11;
      if (*v11)
      {
        v13 = v12[1];
        if (v13 <= 0)
        {
          v16 = __cxa_allocate_exception(8uLL);
          *v16 = "Over-release of an object";
          __cxa_throw(v16, MEMORY[0x1E0DE4E50], 0);
        }
        v14 = v13 - 1;
        v12[1] = v14;
        if (!v14)
          (*(void (**)(_QWORD *))(*v12 + 8))(v12);
      }
      *v11++ = 0;
      v10 -= 8;
    }
    while (v10);
  }
  free(v6);
}

void sub_18A99955C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void TLE::orArrayOpDeserializer(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  const char *v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD **v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *exception;
  __int128 v18;
  __int128 v19;
  uint64_t v20;

  v20 = 0;
  v18 = 0u;
  v19 = 0u;
  TLE::opArrayOpDeserializer(&v18, a1, a2, a3);
  if ((_DWORD)v18)
  {
    *(_OWORD *)a4 = v18;
    v6 = (_QWORD *)*((_QWORD *)&v19 + 1);
    *(_QWORD *)(a4 + 16) = v19;
    *(_QWORD *)(a4 + 24) = 0;
    if (!v6)
      return;
  }
  else
  {
    if ((_DWORD)v20 != 1)
    {
      v15 = operator new();
      *(_QWORD *)(v15 + 16) = 0;
      *(_QWORD *)(v15 + 24) = 0;
      *(_QWORD *)v15 = &off_1E1FC8198;
      *(_QWORD *)(v15 + 8) = 1;
      *(_QWORD *)(v15 + 32) = *((_QWORD *)&v19 + 1);
      *(_DWORD *)(v15 + 40) = v20;
      *(_QWORD *)a4 = 0;
      *(_QWORD *)(a4 + 8) = 0;
      *(_QWORD *)(a4 + 16) = 0;
      *(_QWORD *)(a4 + 24) = v15;
      return;
    }
    v6 = (_QWORD *)*((_QWORD *)&v19 + 1);
    if (!*((_QWORD *)&v19 + 1))
      goto LABEL_24;
    v7 = 8 * v20;
    if (*((_QWORD *)&v19 + 1) + v7 < *((_QWORD *)&v19 + 1) || HIDWORD(v7))
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v5);
    if ((v7 & 0xFFFFFFF8) == 0)
LABEL_24:
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally", v5);
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    v8 = (_QWORD *)*v6;
    *(_QWORD *)(a4 + 16) = 0;
    *(_QWORD *)(a4 + 24) = v8;
    if (v8)
    {
      v9 = v8[1];
      if (v9 < 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        *exception = "Attempted resurection of an object";
        __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
      }
      v8[1] = v9 + 1;
    }
  }
  if ((_DWORD)v20)
  {
    v10 = 8 * v20;
    v11 = (_QWORD **)v6;
    do
    {
      v12 = *v11;
      if (*v11)
      {
        v13 = v12[1];
        if (v13 <= 0)
        {
          v16 = __cxa_allocate_exception(8uLL);
          *v16 = "Over-release of an object";
          __cxa_throw(v16, MEMORY[0x1E0DE4E50], 0);
        }
        v14 = v13 - 1;
        v12[1] = v14;
        if (!v14)
          (*(void (**)(_QWORD *))(*v12 + 8))(v12);
      }
      *v11++ = 0;
      v10 -= 8;
    }
    while (v10);
  }
  free(v6);
}

void sub_18A999750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void TLE::opArrayOpDeserializer(uint64_t a1, uint64_t a2, const der_vm_context *a3, _DWORD *a4)
{
  const char *v5;
  uint64_t v6;
  __int128 v8;
  unint64_t v9;
  unint64_t v10;
  void *v11;
  _QWORD *v12;
  __int128 v13;
  void *v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *exception;
  _QWORD v21[4];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  __n128 (*v25)(uint64_t, uint64_t);
  uint64_t (*v26)();
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  char *der_end;

  if (*a4)
  {
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 6;
    v5 = "factless operator disallowed for active fact";
    v6 = 44;
LABEL_11:
    *(_QWORD *)(a1 + 8) = v5;
    *(_QWORD *)(a1 + 16) = v6;
    return;
  }
  v8 = *(_OWORD *)&a3->lookup.index_count;
  v32 = *(_OWORD *)&a3->runtime;
  v33 = v8;
  v34 = *(_OWORD *)&a3->sorted;
  der_end = a3->var0.ccstate.der_end;
  if (der_vm_CEType_from_context() != 2)
  {
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 3;
    v5 = "Got an unexpected type (not a sequence) when trying to read the array of matches.";
    v6 = 81;
    goto LABEL_11;
  }
  v9 = count_ce_elements(a3);
  if (!v9)
  {
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 4;
    v5 = "The array of dependent operations is empty.";
    v6 = 43;
    goto LABEL_11;
  }
  v10 = v9;
  v31 = 0;
  if (HIDWORD(v9))
  {
    v11 = 0;
    LODWORD(v10) = 0;
  }
  else
  {
    v11 = malloc_type_malloc(8 * v9, 0x61F7200BuLL);
    bzero(v11, 8 * v10);
  }
  v30 = v11;
  LODWORD(v31) = v10;
  v22 = 0;
  v23 = &v22;
  v24 = 0x4002000000;
  v25 = __Block_byref_object_copy__4512;
  v26 = __Block_byref_object_dispose__4513;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  v21[0] = 0;
  v21[1] = v21;
  v21[2] = 0x2000000000;
  v21[3] = 0;
  der_vm_iterate_b();
  v12 = v23 + 5;
  if (*((_DWORD *)v23 + 10))
  {
    *(_DWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    v13 = *(_OWORD *)v12;
    *(_QWORD *)(a1 + 16) = v12[2];
    *(_OWORD *)a1 = v13;
  }
  else
  {
    TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::Tuple(a1, (uint64_t)&v30);
  }
  _Block_object_dispose(v21, 8);
  _Block_object_dispose(&v22, 8);
  v14 = v30;
  if (v30)
  {
    if ((_DWORD)v31)
    {
      v15 = 8 * v31;
      v16 = (_QWORD **)v30;
      do
      {
        v17 = *v16;
        if (*v16)
        {
          v18 = v17[1];
          if (v18 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
          }
          v19 = v18 - 1;
          v17[1] = v19;
          if (!v19)
            (*(void (**)(_QWORD *))(*v17 + 8))(v17);
        }
        *v16++ = 0;
        v15 -= 8;
      }
      while (v15);
    }
    free(v14);
  }
}

void sub_18A999A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>::~safe_allocation(v11 - 144);
  _Unwind_Resume(a1);
}

void os_detail::panic_trapping_policy::trap(os_detail::panic_trapping_policy *this, const char *a2)
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = this;
  __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
}

uint64_t TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD **v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *exception;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 8 * v3;
      v5 = *(_QWORD ***)(a1 + 24);
      do
      {
        v6 = *v5;
        if (*v5)
        {
          v7 = v6[1];
          if (v7 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
          }
          v8 = v7 - 1;
          v6[1] = v8;
          if (!v8)
            (*(void (**)(_QWORD *))(*v6 + 8))(v6);
        }
        *v5++ = 0;
        v4 -= 8;
      }
      while (v4);
    }
    free(v2);
  }
  return a1;
}

uint64_t count_ce_elements(const der_vm_context *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  der_vm_iterate_b();
  v1 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_18A999BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__4512(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

void sub_18A99A118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  TLE::Tuple<TLE::Error,libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>::~Tuple((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>::~safe_allocation(uint64_t a1)
{
  _QWORD **v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD **v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *exception;

  v2 = *(_QWORD ***)a1;
  if (*(_QWORD *)a1)
  {
    v3 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 8 * v3;
      v5 = *(_QWORD ***)a1;
      do
      {
        v6 = *v5;
        if (*v5)
        {
          v7 = v6[1];
          if (v7 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
          }
          v8 = v7 - 1;
          v6[1] = v8;
          if (!v8)
            (*(void (**)(_QWORD *))(*v6 + 8))(v6);
        }
        *v5++ = 0;
        v4 -= 8;
      }
      while (v4);
    }
    free(v2);
  }
  return a1;
}

uint64_t TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::Tuple(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 32) = 0;
  *(_OWORD *)result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  if (result + 24 != a2)
  {
    *(_QWORD *)(result + 24) = *(_QWORD *)a2;
    *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 8);
    *(_QWORD *)a2 = 0;
    *(_DWORD *)(a2 + 8) = 0;
  }
  return result;
}

uint64_t TLE::Tuple<TLE::Error,libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>::~Tuple(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *exception;

  v2 = *(_QWORD **)(a1 + 24);
  if (v2)
  {
    v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
    }
    v4 = v3 - 1;
    v2[1] = v4;
    if (!v4)
      (*(void (**)(_QWORD *))(*v2 + 8))(v2);
  }
  *(_QWORD *)(a1 + 24) = 0;
  return a1;
}

double TLE::keyForContext(TLE *this, der_vm_context *a2)
{
  uint64_t v3;
  double result;
  uint64_t v5;

  der_vm_execute_nocopy();
  if (der_vm_CEType_from_context() == 4)
  {
    v3 = der_vm_string_from_context();
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 3) = v3;
    *((_QWORD *)this + 4) = v5;
  }
  else
  {
    result = 0.0;
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
    *((_QWORD *)this + 4) = 0;
    *(_DWORD *)this = 3;
    *((_QWORD *)this + 1) = "Expected operator string in Array tuple";
    *((_QWORD *)this + 2) = 39;
  }
  return result;
}

uint64_t ___ZL17count_ce_elementsRK14der_vm_context_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  BOOL v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  int v7;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v2 = *(_QWORD *)(v1 + 24);
  v3 = __CFADD__(v2, 1);
  v4 = v2 + 1;
  v5 = v3;
  v6 = v5 << 63 >> 63 != v5 || v5 << 63 >> 63 == -1;
  v7 = v6;
  if (!v6)
    *(_QWORD *)(v1 + 24) = v4;
  return v7 ^ 1u;
}

uint64_t ___ZN3TLE19queryOpDeserializerERNS_8ExecutorER14der_vm_contextRKNS_14FactDefinitionE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a2 + 116) == 2 && count_ce_elements((const der_vm_context *)(a2 + 56)) == 2)
    return 1;
  result = 0;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

void TLE::Executor::getDependentOpsFromDictionary(uint64_t a1, uint64_t a2, const der_vm_context *a3)
{
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  _QWORD *v13;
  int v14;
  __int128 v15;
  void *v16;
  uint64_t v17;
  _QWORD **v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *exception;
  _QWORD v23[4];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  __n128 (*v27)(uint64_t, uint64_t);
  uint64_t (*v28)();
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  char *der_end;

  v5 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = v5 + 1;
  if ((unint64_t)(v5 + 1) >= 6)
  {
    *(_QWORD *)(a2 + 8) = v5;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 8;
    v6 = "Constraint is too deeply nested. Failing to avoid recursion overflow";
    v7 = 68;
LABEL_11:
    *(_QWORD *)(a1 + 8) = v6;
    *(_QWORD *)(a1 + 16) = v7;
    return;
  }
  v9 = *(_OWORD *)&a3->lookup.index_count;
  v34 = *(_OWORD *)&a3->runtime;
  v35 = v9;
  v36 = *(_OWORD *)&a3->sorted;
  der_end = a3->var0.ccstate.der_end;
  if (der_vm_CEType_from_context() != 1)
  {
    --*(_QWORD *)(a2 + 8);
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 3;
    v6 = "Got an unexpected type (not a dictionary) when trying to generate dependent operations for evaluation.";
    v7 = 102;
    goto LABEL_11;
  }
  v10 = count_ce_elements(a3);
  if (!v10)
  {
    --*(_QWORD *)(a2 + 8);
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)a1 = 4;
    v6 = "The dictionary of dependent operations is empty.";
    v7 = 48;
    goto LABEL_11;
  }
  v11 = v10;
  v33 = 0;
  if (HIDWORD(v10))
  {
    v12 = 0;
    LODWORD(v11) = 0;
  }
  else
  {
    v12 = malloc_type_malloc(8 * v10, 0x61F7200BuLL);
    bzero(v12, 8 * v11);
  }
  v32 = v12;
  LODWORD(v33) = v11;
  v24 = 0;
  v25 = &v24;
  v26 = 0x4002000000;
  v27 = __Block_byref_object_copy__4512;
  v28 = __Block_byref_object_dispose__4513;
  v30 = 0;
  v31 = 0;
  v29 = 0;
  v23[0] = 0;
  v23[1] = v23;
  v23[2] = 0x2000000000;
  v23[3] = 0;
  der_vm_iterate_b();
  v13 = v25 + 5;
  v14 = *((_DWORD *)v25 + 10);
  --*(_QWORD *)(a2 + 8);
  if (v14)
  {
    *(_DWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    v15 = *(_OWORD *)v13;
    *(_QWORD *)(a1 + 16) = v13[2];
    *(_OWORD *)a1 = v15;
  }
  else
  {
    TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::Tuple(a1, (uint64_t)&v32);
  }
  _Block_object_dispose(v23, 8);
  _Block_object_dispose(&v24, 8);
  v16 = v32;
  if (v32)
  {
    if ((_DWORD)v33)
    {
      v17 = 8 * v33;
      v18 = (_QWORD **)v32;
      do
      {
        v19 = *v18;
        if (*v18)
        {
          v20 = v19[1];
          if (v20 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
          }
          v21 = v20 - 1;
          v19[1] = v21;
          if (!v21)
            (*(void (**)(_QWORD *))(*v19 + 8))(v19);
        }
        *v18++ = 0;
        v17 -= 8;
      }
      while (v17);
    }
    free(v16);
  }
}

void sub_18A99A6EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  uint64_t v15;
  va_list va;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  va_list va1;

  va_start(va1, a13);
  va_start(va, a13);
  v15 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>::~safe_allocation(v13 - 160);
  _Unwind_Resume(a1);
}

uint64_t ___ZN3TLE8Executor29getDependentOpsFromDictionaryE14der_vm_contextRKNS_14FactDefinitionEbmPK8CEBuffer_block_invoke(uint64_t a1, der_vm_context *a2)
{
  der_vm_context *v3;
  uint64_t result;
  uint64_t v5;
  __int128 v6;
  const char *v7;
  unint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int64_t i;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  unint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  BOOL v38;
  unint64_t v39;
  unint64_t *v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  _QWORD *v45;
  const char *v46;
  unint64_t *v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  BOOL v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  _QWORD *exception;
  uint64_t v65;
  const char *v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  BOOL v71;
  char *v72;
  _QWORD **v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD *v76;
  _QWORD *v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t *v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t v87;
  BOOL v88;
  uint64_t v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  const char *v93;
  unint64_t *v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  uint64_t v100;
  char *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  _BOOL4 v110;
  uint64_t v111;
  unint64_t *v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  uint64_t v119;
  BOOL v120;
  char *v121;
  uint64_t v122;
  uint64_t v123;
  _QWORD **v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  char *v128;
  uint64_t v129;
  _QWORD **v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  _BOOL4 v135;
  uint64_t v136;
  _QWORD *v137;
  _QWORD *v138;
  _QWORD *v139;
  _QWORD *v140;
  uint64_t v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  char *der_end;
  _OWORD v147[3];
  uint64_t v148;
  _OWORD v149[3];
  _OWORD v150[2];
  uint64_t v151;

  v151 = *MEMORY[0x1E0C80C00];
  v140 = *(_QWORD **)(a1 + 48);
  memset(v149, 0, 40);
  v3 = a2 + 1;
  TLE::keyForContext((TLE *)v149, a2 + 1);
  if (LODWORD(v149[0]))
  {
    result = 0;
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_OWORD *)(v5 + 40) = v149[0];
    *(_QWORD *)(v5 + 56) = *(_QWORD *)&v149[1];
    return result;
  }
  v148 = 0;
  memset(v147, 0, sizeof(v147));
  v6 = *(_OWORD *)&v3->lookup.index_count;
  v143 = *(_OWORD *)&v3->runtime;
  v144 = v6;
  v145 = *(_OWORD *)&v3->sorted;
  der_end = v3->var0.ccstate.der_end;
  der_vm_execute_nocopy();
  v9 = *(_QWORD *)(a1 + 56);
  if (v9)
  {
    v10 = (_BYTE *)*((_QWORD *)&v149[1] + 1);
    v11 = *(_QWORD *)(a1 + 64) + 8;
    while (1)
    {
      result = CEBuffer_cmp();
      if (!(_DWORD)result)
        break;
      v11 += 16;
      if (!--v9)
        goto LABEL_9;
    }
    v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_DWORD *)(v25 + 40) = 6;
    v26 = "Unexpected key for parsing context";
    v27 = 34;
    goto LABEL_45;
  }
  v10 = (_BYTE *)*((_QWORD *)&v149[1] + 1);
LABEL_9:
  if (*v10 != 36)
  {
    if (!*(_BYTE *)(a1 + 88))
    {
      result = 0;
      v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      *(_DWORD *)(v25 + 40) = 6;
      v26 = "Fact not allowed in context";
      v27 = 27;
LABEL_45:
      *(_QWORD *)(v25 + 48) = v26;
      *(_QWORD *)(v25 + 56) = v27;
      return result;
    }
    v21 = *(_QWORD *)&v149[2];
    if (((*(uint64_t (**)(_QWORD, _BYTE *, _QWORD))(*(_QWORD *)*v140 + 32))(*v140, v10, *(_QWORD *)&v149[2]) & 1) == 0)
    {
      *(_OWORD *)((char *)v150 + 4) = *(_OWORD *)((char *)&v149[1] + 8);
      v33 = operator new();
      *(_DWORD *)(v33 + 32) = 5;
      *(_OWORD *)(v33 + 36) = v150[0];
      *(_DWORD *)(v33 + 52) = v150[1];
      *(_QWORD *)(v33 + 16) = 0;
      *(_QWORD *)(v33 + 24) = 0;
      *(_QWORD *)v33 = &off_1E1FC8288;
      *(_QWORD *)(v33 + 8) = 1;
      v141 = v33;
      v34 = *(unint64_t **)(a1 + 80);
      v35 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
      v36 = *v34;
      if (*v34)
      {
        v37 = v36 + 8 * *((unsigned int *)v34 + 2);
        v38 = v37 >= v36;
        v39 = v37 - v36;
        if (!v38 || HIDWORD(v39))
          os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v32);
      }
      else
      {
        LODWORD(v39) = 0;
      }
      if (v35 >= 0)
        v52 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
      else
        v52 = -v35;
      v53 = ((unint64_t)v35 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
      if (v35 >= 0)
        v54 = 8 * v52;
      else
        v54 = -8 * v52;
      if (v52 >> 61)
        v55 = 1;
      else
        v55 = 8 * v52 > v53;
      if (v55)
      {
        v56 = "bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) would "
              "trigger an overflow";
      }
      else if (v54 == (int)v54)
      {
        v56 = "bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally";
        if ((v54 & 0x80000000) == 0 && (int)v54 + 8 <= v39)
        {
          v57 = (int)v54;
          v58 = (uint64_t)(int)v54 >> 63;
          v59 = (uint64_t *)(v36 + v57);
          v60 = __CFADD__(v36, v57) ? v58 + 1 : v58;
          v61 = v60 << 63 >> 63;
          v56 = "This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.";
          if (v61 == v60 && (v61 & 0x8000000000000000) == 0)
          {
            v62 = (_QWORD *)*v59;
            if (*v59)
            {
              v63 = v62[1];
              if (v63 <= 0)
              {
                exception = __cxa_allocate_exception(8uLL);
                *exception = "Over-release of an object";
                __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
              }
              goto LABEL_158;
            }
LABEL_160:
            *v59 = v33;
            v105 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
            v106 = *(_QWORD *)(v105 + 24);
            v107 = v106 + 1;
            v108 = v106 == -1;
            v110 = v108 << 63 >> 63 != v108 || v108 << 63 >> 63 == -1;
            if (v110)
            {
              v111 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
              *(_DWORD *)(v111 + 40) = 10;
              *(_QWORD *)(v111 + 48) = "Too many elements in dictionary";
              *(_QWORD *)(v111 + 56) = 31;
              return 0;
            }
            else
            {
              *(_QWORD *)(v105 + 24) = v107;
              return !v110;
            }
          }
        }
      }
      else
      {
        v56 = "bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the current"
              " position would overflow.";
      }
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)v56, v32);
    }
    v141 = 0;
    v142 = 0uLL;
    (*(void (**)(uint64_t *__return_ptr, _QWORD, _BYTE *, uint64_t))(*(_QWORD *)*v140 + 16))(&v141, *v140, v10, v21);
    v22 = der_vm_CEType_from_context();
    if (v22 == 1)
    {
      memset(v150, 0, sizeof(v150));
      TLE::factOpDeserializer((uint64_t)v150, (uint64_t)v140, (uint64_t)v147, (uint64_t)&v141);
      if (LODWORD(v150[0]))
      {
        v24 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        *(_OWORD *)(v24 + 40) = v150[0];
        *(_QWORD *)(v24 + 56) = *(_QWORD *)&v150[1];
        TLE::Tuple<TLE::Error,libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>::~Tuple((uint64_t)v150);
        return 0;
      }
      v112 = *(unint64_t **)(a1 + 80);
      v113 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
      v114 = *v112;
      if (*v112)
      {
        v115 = v114 + 8 * *((unsigned int *)v112 + 2);
        v38 = v115 >= v114;
        v116 = v115 - v114;
        if (!v38 || HIDWORD(v116))
          os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v23);
      }
      else
      {
        LODWORD(v116) = 0;
      }
      if (v113 >= 0)
        v117 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
      else
        v117 = -v113;
      v118 = ((unint64_t)v113 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
      if (v113 >= 0)
        v119 = 8 * v117;
      else
        v119 = -8 * v117;
      if (v117 >> 61)
        v120 = 1;
      else
        v120 = 8 * v117 > v118;
      if (v120)
      {
        v121 = "bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) would"
               " trigger an overflow";
      }
      else if (v119 == (int)v119)
      {
        v121 = "bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally";
        if ((v119 & 0x80000000) == 0 && (int)v119 + 8 <= v116)
        {
          v122 = (int)v119;
          v123 = (uint64_t)(int)v119 >> 63;
          v38 = __CFADD__(v114, v122);
          v124 = (_QWORD **)(v114 + v122);
          if (v38)
            ++v123;
          v125 = v123 << 63 >> 63;
          v121 = "This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.";
          if (v125 == v123 && (v125 & 0x8000000000000000) == 0)
          {
            libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::operator=(v124, (_QWORD *)&v150[1] + 1);
            TLE::Tuple<TLE::Error,libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>::~Tuple((uint64_t)v150);
LABEL_212:
            v81 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
            v82 = *(_QWORD *)(v81 + 24);
            goto LABEL_213;
          }
        }
      }
      else
      {
        v121 = "bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the curren"
               "t position would overflow.";
      }
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)v121, v23);
    }
    if (v22 == (_DWORD)v141)
    {
      v45 = TLE::opForContext(v22);
      if (v45)
      {
        *((_OWORD *)v45 + 1) = v142;
        *(_QWORD *)&v150[0] = v45;
        v47 = *(unint64_t **)(a1 + 80);
        v48 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
        v49 = *v47;
        if (*v47)
        {
          v50 = v49 + 8 * *((unsigned int *)v47 + 2);
          v38 = v50 >= v49;
          v51 = v50 - v49;
          if (!v38 || HIDWORD(v51))
            os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v46);
        }
        else
        {
          LODWORD(v51) = 0;
        }
        if (v48 >= 0)
          v126 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
        else
          v126 = -v48;
        if (v48 >= 0)
          v127 = 8 * v126;
        else
          v127 = -8 * v126;
        v128 = "bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) would"
               " trigger an overflow";
        if (!(v126 >> 61) && 8 * v126 <= ((unint64_t)v48 >> 63) + 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v127 == (int)v127)
          {
            v128 = "bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally";
            if ((v127 & 0x80000000) == 0 && (int)v127 + 8 <= v51)
            {
              v129 = (uint64_t)(int)v127 >> 63;
              v38 = __CFADD__(v49, (int)v127);
              v130 = (_QWORD **)(v49 + (int)v127);
              if (v38)
                ++v129;
              v131 = v129 << 63 >> 63;
              v128 = "This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.";
              if (v131 == v129 && (v131 & 0x8000000000000000) == 0)
              {
                libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::operator=(v130, v150);
                libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::~intrusive_shared_ptr((_QWORD **)v150);
                goto LABEL_212;
              }
            }
          }
          else
          {
            v128 = "bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the cu"
                   "rrent position would overflow.";
          }
        }
        os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)v128, v46);
      }
      v65 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      *(_DWORD *)(v65 + 40) = 3;
      v66 = "Unexpected type of an fact declaration.";
      v67 = 39;
    }
    else
    {
      v65 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      *(_DWORD *)(v65 + 40) = 3;
      v66 = "Unexpected type of an operation declaration.";
      v67 = 44;
    }
    *(_QWORD *)(v65 + 48) = v66;
    *(_QWORD *)(v65 + 56) = v67;
    return 0;
  }
  {
    os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v7);
  }
    LOBYTE(v12) = v12 + 1;
                                   - (_UNKNOWN *)&TLE::details::operations
                                   + 0x80000000) >> 32))
    os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The offset of the pointer inside its valid memory range can't be represented using int32_t", v7);
  v13 = (unint64_t)&TLE::details::operations >= 0xFFFFFFFFFFFFFEE0;
  v14 = v13 << 63 >> 63;
  v15 = v14 ^ v13;
  if (v14 < 0 || v15 != 0)
    os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.", v7);
  {
    v18 = (char *)&TLE::details::operations + (i >> 32);
    if (__CFADD__(&TLE::details::operations, i >> 32))
      v19 = (i >> 63) + 1;
    else
      v19 = i >> 63;
    v20 = v19 << 63 >> 63;
    if (v20 != v19 || v20 < 0)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.", v7);
      goto LABEL_110;
    if (i < 0 || HIDWORD(i) + 24 > i)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally", v7);
    if (!CEBuffer_cmp())
      break;
    if ((unint64_t)((i >> 32) - 2147483624) < 0xFFFFFFFF00000000)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the current position would overflow.", v7);
  }
  memset(v150, 0, sizeof(v150));
  (*((void (**)(_OWORD *__return_ptr, _QWORD *, _OWORD *, _QWORD))v18 + 2))(v150, v140, v147, *(_QWORD *)(a1 + 72));
  if (!LODWORD(v150[0]))
  {
    v40 = *(unint64_t **)(a1 + 80);
    v41 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    v42 = *v40;
    if (*v40)
    {
      v43 = v42 + 8 * *((unsigned int *)v40 + 2);
      v38 = v43 >= v42;
      v44 = v43 - v42;
      if (!v38 || HIDWORD(v44))
        os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v7);
    }
    else
    {
      LODWORD(v44) = 0;
    }
    if (v41 >= 0)
      v68 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
    else
      v68 = -v41;
    v69 = ((unint64_t)v41 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
    if (v41 >= 0)
      v70 = 8 * v68;
    else
      v70 = -8 * v68;
    if (v68 >> 61)
      v71 = 1;
    else
      v71 = 8 * v68 > v69;
    if (v71)
    {
      v72 = "bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) would tr"
            "igger an overflow";
    }
    else if (v70 == (int)v70)
    {
      v72 = "bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally";
      if ((v70 & 0x80000000) == 0 && (int)v70 + 8 <= v44)
      {
        v73 = (_QWORD **)(v42 + (int)v70);
        v74 = __CFADD__(v42, (int)v70) ? ((uint64_t)(int)v70 >> 63) + 1 : (uint64_t)(int)v70 >> 63;
        v75 = v74 << 63 >> 63;
        v72 = "This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.";
        if (v75 == v74 && (v75 & 0x8000000000000000) == 0)
        {
          v76 = (_QWORD *)*((_QWORD *)&v150[1] + 1);
          v77 = *v73;
          if (*v73)
          {
            v78 = v77[1];
            if (v78 <= 0)
            {
              v139 = __cxa_allocate_exception(8uLL);
              *v139 = "Over-release of an object";
              __cxa_throw(v139, MEMORY[0x1E0DE4E50], 0);
            }
            v79 = v78 - 1;
            v77[1] = v79;
            if (!v79)
              (*(void (**)(_QWORD *))(*v77 + 8))(v77);
          }
          *v73 = v76;
LABEL_110:
          v80 = *(unint64_t **)(a1 + 80);
          v81 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
          v82 = *(_QWORD *)(v81 + 24);
          v83 = *v80;
          if (*v80)
          {
            v84 = v83 + 8 * *((unsigned int *)v80 + 2);
            v38 = v84 >= v83;
            v85 = v84 - v83;
            if (!v38 || HIDWORD(v85))
              os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v7);
          }
          else
          {
            LODWORD(v85) = 0;
          }
          if (v82 >= 0)
            v86 = *(_QWORD *)(v81 + 24);
          else
            v86 = -v82;
          if (v82 >= 0)
            v87 = 8 * v86;
          else
            v87 = -8 * v86;
          if (v86 >> 61)
            v88 = 1;
          else
            v88 = 8 * v86 > ((unint64_t)v82 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
          if (v88)
            os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) would trigger an overflow", v7);
          if (v87 != (int)v87)
            os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the current position would overflow.", v7);
          if ((v87 & 0x80000000) != 0 || (int)v87 + 8 > v85)
            os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally", v7);
          v89 = (int)v87;
          v90 = (uint64_t)(int)v87 >> 63;
          v38 = __CFADD__(v83, v89);
          v91 = (_QWORD *)(v83 + v89);
          if (v38)
            ++v90;
          v92 = v90 << 63 >> 63;
          if (v92 != v90 || v92 < 0)
            os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.", v7);
          if (!*v91)
          {
            *(_OWORD *)((char *)v150 + 4) = *(_OWORD *)((char *)&v149[1] + 8);
            v33 = operator new();
            *(_DWORD *)(v33 + 32) = 1;
            *(_OWORD *)(v33 + 36) = v150[0];
            *(_DWORD *)(v33 + 52) = v150[1];
            *(_QWORD *)(v33 + 16) = 0;
            *(_QWORD *)(v33 + 24) = 0;
            *(_QWORD *)v33 = &off_1E1FC8288;
            *(_QWORD *)(v33 + 8) = 1;
            v141 = v33;
            v94 = *(unint64_t **)(a1 + 80);
            v95 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
            v96 = *v94;
            if (*v94)
            {
              v97 = v96 + 8 * *((unsigned int *)v94 + 2);
              v38 = v97 >= v96;
              v98 = v97 - v96;
              if (!v38 || HIDWORD(v98))
                os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v93);
            }
            else
            {
              LODWORD(v98) = 0;
            }
            if (v95 >= 0)
              v99 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
            else
              v99 = -v95;
            if (v95 >= 0)
              v100 = 8 * v99;
            else
              v100 = -8 * v99;
            v101 = "bounded_ptr<T>::operator+=(n): Calculating the number of bytes to add to the offset (n * sizeof(T)) w"
                   "ould trigger an overflow";
            if (!(v99 >> 61) && 8 * v99 <= ((unint64_t)v95 >> 63) + 0x7FFFFFFFFFFFFFFFLL)
            {
              if (v100 == (int)v100)
              {
                v101 = "bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally";
                if ((v100 & 0x80000000) == 0 && (int)v100 + 8 <= v98)
                {
                  v59 = (uint64_t *)(v96 + (int)v100);
                  v102 = __CFADD__(v96, (int)v100) ? ((uint64_t)(int)v100 >> 63) + 1 : (uint64_t)(int)v100 >> 63;
                  v103 = v102 << 63 >> 63;
                  v101 = "This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.";
                  if (v103 == v102 && (v103 & 0x8000000000000000) == 0)
                  {
                    v62 = (_QWORD *)*v59;
                    if (*v59)
                    {
                      v63 = v62[1];
                      if (v63 <= 0)
                      {
                        v138 = __cxa_allocate_exception(8uLL);
                        *v138 = "Over-release of an object";
                        __cxa_throw(v138, MEMORY[0x1E0DE4E50], 0);
                      }
LABEL_158:
                      v104 = v63 - 1;
                      v62[1] = v104;
                      if (!v104)
                        (*(void (**)(_QWORD *))(*v62 + 8))(v62);
                      goto LABEL_160;
                    }
                    goto LABEL_160;
                  }
                }
              }
              else
              {
                v101 = "bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing th"
                       "e current position would overflow.";
              }
            }
            os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)v101, v93);
          }
LABEL_213:
          v132 = v82 + 1;
          v133 = v82 == -1;
          v135 = v133 << 63 >> 63 != v133 || v133 << 63 >> 63 == -1;
          if (v135)
          {
            v136 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
            *(_DWORD *)(v136 + 40) = 10;
            *(_QWORD *)(v136 + 48) = "Too many elements in dictionary";
            *(_QWORD *)(v136 + 56) = 31;
          }
          else
          {
            *(_QWORD *)(v81 + 24) = v132;
          }
          return !v135;
        }
      }
    }
    else
    {
      v72 = "bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the current p"
            "osition would overflow.";
    }
    os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)v72, v7);
  }
  v28 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  *(_OWORD *)(v28 + 40) = v150[0];
  v29 = (_QWORD *)*((_QWORD *)&v150[1] + 1);
  *(_QWORD *)(v28 + 56) = *(_QWORD *)&v150[1];
  if (v29)
  {
    v30 = v29[1];
    if (v30 <= 0)
    {
      v137 = __cxa_allocate_exception(8uLL);
      *v137 = "Over-release of an object";
      __cxa_throw(v137, MEMORY[0x1E0DE4E50], 0);
    }
    v31 = v30 - 1;
    v29[1] = v31;
    if (!v31)
      (*(void (**)(_QWORD *))(*v29 + 8))(v29);
  }
  return 0;
}

void sub_18A99B34C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

_QWORD **libkern::intrusive_shared_ptr<TLE::ConstErrorOperation,TLE::RefCountPolicy>::~intrusive_shared_ptr(_QWORD **a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *exception;

  v2 = *a1;
  if (v2)
  {
    v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
    }
    v4 = v3 - 1;
    v2[1] = v4;
    if (!v4)
      (*(void (**)(_QWORD *))(*v2 + 8))(v2);
  }
  *a1 = 0;
  return a1;
}

__n128 TLE::factOpDeserializer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int128 v5;
  const char *v6;
  __n128 result;
  _QWORD **v8;
  uint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD **v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *exception;
  _OWORD v20[3];
  uint64_t v21;
  __n128 v22;
  void *v23[2];
  uint64_t v24;

  v24 = 0;
  v22 = 0u;
  *(_OWORD *)v23 = 0u;
  v5 = *(_OWORD *)(a3 + 16);
  v20[0] = *(_OWORD *)a3;
  v20[1] = v5;
  v20[2] = *(_OWORD *)(a3 + 32);
  v21 = *(_QWORD *)(a3 + 48);
  TLE::Executor::getDependentOpsFromDictionary(&v22, a2, v20, a4, 0, 0, 0);
  if (v22.n128_u32[0])
  {
    result = v22;
    *(__n128 *)a1 = v22;
    *(void **)(a1 + 16) = v23[0];
    *(_QWORD *)(a1 + 24) = 0;
    v8 = (_QWORD **)v23[1];
    if (!v23[1])
      return result;
    goto LABEL_13;
  }
  if ((_DWORD)v24 != 1)
  {
    result = 0uLL;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_DWORD *)a1 = 6;
    *(_QWORD *)(a1 + 8) = "There should only be one operation to match a fact";
    *(_QWORD *)(a1 + 16) = 50;
    v8 = (_QWORD **)v23[1];
    if (!v23[1])
      return result;
    goto LABEL_13;
  }
  v9 = (uint64_t *)v23[1];
  if (!v23[1])
    goto LABEL_27;
  v10 = 8 * v24;
  if ((char *)v23[1] + v10 < v23[1] || HIDWORD(v10))
    os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", v6);
  if ((v10 & 0xFFFFFFF8) == 0)
LABEL_27:
    os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally", v6);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v11 = *v9;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = v11;
  if (v11)
  {
    v12 = *(_QWORD *)(v11 + 8);
    if (v12 < 1)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = "Attempted resurection of an object";
      __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
    }
    *(_QWORD *)(v11 + 8) = v12 + 1;
  }
  v8 = (_QWORD **)v23[1];
  if (v23[1])
  {
LABEL_13:
    if ((_DWORD)v24)
    {
      v13 = 8 * v24;
      v14 = v8;
      do
      {
        v15 = *v14;
        if (*v14)
        {
          v16 = v15[1];
          if (v16 <= 0)
          {
            v18 = __cxa_allocate_exception(8uLL);
            *v18 = "Over-release of an object";
            __cxa_throw(v18, MEMORY[0x1E0DE4E50], 0);
          }
          v17 = v16 - 1;
          v15[1] = v17;
          if (!v17)
            (*(void (**)(_QWORD *))(*v15 + 8))(v15);
        }
        *v14++ = 0;
        v13 -= 8;
      }
      while (v13);
    }
    free(v8);
  }
  return result;
}

void sub_18A99B630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  TLE::Tuple<TLE::Error,libkern::safe_allocation<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>,os_detail::IOKit_typed_allocator<libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>>,os_detail::panic_trapping_policy>>::~Tuple((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD **libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::operator=(_QWORD **a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *exception;

  v4 = (_QWORD *)*a2;
  v5 = *a1;
  if (v5)
  {
    v6 = v5[1];
    if (v6 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
    }
    v7 = v6 - 1;
    v5[1] = v7;
    if (!v7)
      (*(void (**)(_QWORD *))(*v5 + 8))(v5);
  }
  *a1 = v4;
  *a2 = 0;
  return a1;
}

_QWORD *TLE::opForContext(int a1)
{
  _QWORD *v1;
  uint64_t v2;
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t (**v6)();

  switch(a1)
  {
    case 3:
      v1 = (_QWORD *)operator new();
      v2 = der_vm_integer_from_context();
      v1[2] = 0;
      v1[3] = 0;
      *v1 = &off_1E1FC8108;
      v1[1] = 1;
      v1[4] = v2;
      break;
    case 4:
      v1 = (_QWORD *)operator new();
      v4 = der_vm_string_from_context();
      v1[2] = 0;
      v1[3] = 0;
      v6 = &off_1E1FC8138;
      goto LABEL_7;
    case 5:
      v1 = (_QWORD *)operator new();
      v3 = der_vm_BOOL_from_context();
      v1[2] = 0;
      v1[3] = 0;
      *v1 = &off_1E1FC7FE8;
      v1[1] = 1;
      *((_BYTE *)v1 + 32) = v3;
      break;
    case 6:
      v1 = (_QWORD *)operator new();
      v4 = der_vm_data_from_context();
      v1[2] = 0;
      v1[3] = 0;
      v6 = &off_1E1FC81F8;
LABEL_7:
      *v1 = v6;
      v1[1] = 1;
      v1[4] = v4;
      v1[5] = v5;
      break;
    default:
      v1 = 0;
      break;
  }
  return v1;
}

void sub_18A99B890(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x10D1C40478F9E52);
  _Unwind_Resume(a1);
}

_QWORD **libkern::intrusive_shared_ptr<TLE::Operation,TLE::RefCountPolicy>::~intrusive_shared_ptr(_QWORD **a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *exception;

  v2 = *a1;
  if (v2)
  {
    v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
    }
    v4 = v3 - 1;
    v2[1] = v4;
    if (!v4)
      (*(void (**)(_QWORD *))(*v2 + 8))(v2);
  }
  *a1 = 0;
  return a1;
}

_QWORD *_ZN3TLE12BinaryDataOpI8CEBufferXtlNS_3__8EEEED1Ev(_QWORD *result)
{
  _QWORD *exception;

  *result = &off_1E1FC7FC8;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  return result;
}

void _ZN3TLE12BinaryDataOpI8CEBufferXtlNS_3__8EEEED0Ev(_QWORD *a1)
{
  _QWORD *exception;

  *a1 = &off_1E1FC7FC8;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

_QWORD *_ZN3TLE12BinaryDataOpI8CEBufferXtlNS_3__8EEEE7ExecuteERNS_12EncyclopediaE@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = (*(_QWORD *(**)(_OWORD *__return_ptr, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(v5, a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  if (LODWORD(v5[0]) == 6)
  {
    result = (_QWORD *)CEBuffer_cmp();
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_BYTE *)(a3 + 24) = (_DWORD)result == 0;
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = "Invalid fact type for this operation (expected data)";
    *(_DWORD *)a3 = 3;
    *(_QWORD *)(a3 + 16) = 52;
  }
  return result;
}

uint64_t TLE::Operation::shouldIgnore(TLE::Operation *this)
{
  return 0;
}

void TLE::RefCounted::~RefCounted(TLE::RefCounted *this)
{
  _QWORD *exception;

  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
}

{
  _QWORD *exception;

  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

_QWORD *_ZN3TLE11BinaryStrOpI8CEBufferXtlNS_3__7EEEED1Ev(_QWORD *result)
{
  _QWORD *exception;

  *result = &off_1E1FC7FC8;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  return result;
}

void _ZN3TLE11BinaryStrOpI8CEBufferXtlNS_3__7EEEED0Ev(_QWORD *a1)
{
  _QWORD *exception;

  *a1 = &off_1E1FC7FC8;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

_QWORD *_ZN3TLE11BinaryStrOpI8CEBufferXtlNS_3__7EEEE7ExecuteERNS_12EncyclopediaE@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  _OWORD v5[2];
  uint64_t v6;

  v6 = 0;
  memset(v5, 0, sizeof(v5));
  result = (*(_QWORD *(**)(_OWORD *__return_ptr, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(v5, a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  if (LODWORD(v5[0]) == 4)
  {
    result = (_QWORD *)CEBuffer_cmp();
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_BYTE *)(a3 + 24) = (_DWORD)result == 0;
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = "Invalid fact type for this operation (expected a string)";
    *(_DWORD *)a3 = 3;
    *(_QWORD *)(a3 + 16) = 56;
  }
  return result;
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__6EEEED1Ev(_QWORD *result)
{
  _QWORD *exception;

  *result = &off_1E1FC7FC8;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__6EEEED0Ev(_QWORD *a1)
{
  _QWORD *exception;

  *a1 = &off_1E1FC7FC8;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__6EEEE7ExecuteERNS_12EncyclopediaE@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  BOOL v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  result = (*(_QWORD *(**)(__int128 *__return_ptr, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(&v8, a2, a1[2], a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    v7 = *((_QWORD *)&v9 + 1) == a1[4];
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_BYTE *)(a3 + 24) = v7;
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(_QWORD *)(a3 + 16) = 66;
  }
  return result;
}

_QWORD *_ZN3TLE11BinaryIntOpIbXtlNS_3__5EEEED1Ev(_QWORD *result)
{
  _QWORD *exception;

  *result = &off_1E1FC7FC8;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  return result;
}

void _ZN3TLE11BinaryIntOpIbXtlNS_3__5EEEED0Ev(_QWORD *a1)
{
  _QWORD *exception;

  *a1 = &off_1E1FC7FC8;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

_QWORD *_ZN3TLE11BinaryIntOpIbXtlNS_3__5EEEE7ExecuteERNS_12EncyclopediaE@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  BOOL v7;
  BOOL v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = 0;
  v9 = 0u;
  v10 = 0u;
  result = (*(_QWORD *(**)(__int128 *__return_ptr, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(&v9, a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  if ((_DWORD)v9 == 3 || (_DWORD)v9 == 5)
  {
    v7 = *((_QWORD *)&v10 + 1) == 0;
    v8 = *(_BYTE *)(a1 + 32) != 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_BYTE *)(a3 + 24) = v7 ^ v8;
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(_QWORD *)(a3 + 16) = 66;
  }
  return result;
}

void TLE::ConstErrorOperation::~ConstErrorOperation(TLE::ConstErrorOperation *this)
{
  _QWORD *exception;

  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
}

{
  _QWORD *exception;

  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

__n128 TLE::ConstErrorOperation::Execute@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result;

  a2[1].n128_u8[8] = 0;
  result = a1[2];
  *a2 = result;
  a2[1].n128_u64[0] = a1[3].n128_u64[0];
  return result;
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__4EEEED1Ev(_QWORD *result)
{
  _QWORD *exception;

  *result = &off_1E1FC7FC8;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__4EEEED0Ev(_QWORD *a1)
{
  _QWORD *exception;

  *a1 = &off_1E1FC7FC8;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__4EEEE7ExecuteERNS_12EncyclopediaE@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  BOOL v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  result = (*(_QWORD *(**)(__int128 *__return_ptr, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(&v8, a2, a1[2], a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    v7 = (a1[4] & ~*((_QWORD *)&v9 + 1)) == 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_BYTE *)(a3 + 24) = v7;
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(_QWORD *)(a3 + 16) = 66;
  }
  return result;
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__3EEEED1Ev(_QWORD *result)
{
  _QWORD *exception;

  *result = &off_1E1FC7FC8;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__3EEEED0Ev(_QWORD *a1)
{
  _QWORD *exception;

  *a1 = &off_1E1FC7FC8;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__3EEEE7ExecuteERNS_12EncyclopediaE@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  BOOL v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  result = (*(_QWORD *(**)(__int128 *__return_ptr, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(&v8, a2, a1[2], a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    v7 = *((_QWORD *)&v9 + 1) >= a1[4];
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_BYTE *)(a3 + 24) = v7;
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(_QWORD *)(a3 + 16) = 66;
  }
  return result;
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__2EEEED1Ev(_QWORD *result)
{
  _QWORD *exception;

  *result = &off_1E1FC7FC8;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__2EEEED0Ev(_QWORD *a1)
{
  _QWORD *exception;

  *a1 = &off_1E1FC7FC8;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__2EEEE7ExecuteERNS_12EncyclopediaE@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  BOOL v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  result = (*(_QWORD *(**)(__int128 *__return_ptr, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(&v8, a2, a1[2], a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    v7 = *((_QWORD *)&v9 + 1) > a1[4];
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_BYTE *)(a3 + 24) = v7;
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(_QWORD *)(a3 + 16) = 66;
  }
  return result;
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__1EEEED1Ev(_QWORD *result)
{
  _QWORD *exception;

  *result = &off_1E1FC7FC8;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__1EEEED0Ev(_QWORD *a1)
{
  _QWORD *exception;

  *a1 = &off_1E1FC7FC8;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__1EEEE7ExecuteERNS_12EncyclopediaE@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  BOOL v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  result = (*(_QWORD *(**)(__int128 *__return_ptr, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(&v8, a2, a1[2], a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    v7 = *((_QWORD *)&v9 + 1) <= a1[4];
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_BYTE *)(a3 + 24) = v7;
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(_QWORD *)(a3 + 16) = 66;
  }
  return result;
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__0EEEED1Ev(_QWORD *result)
{
  _QWORD *exception;

  *result = &off_1E1FC7FC8;
  if (result[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  return result;
}

void _ZN3TLE11BinaryIntOpIxXtlNS_3__0EEEED0Ev(_QWORD *a1)
{
  _QWORD *exception;

  *a1 = &off_1E1FC7FC8;
  if (a1[1])
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

_QWORD *_ZN3TLE11BinaryIntOpIxXtlNS_3__0EEEE7ExecuteERNS_12EncyclopediaE@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *result;
  BOOL v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;

  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  result = (*(_QWORD *(**)(__int128 *__return_ptr, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(&v8, a2, a1[2], a1[3]);
  if ((_DWORD)v8 == 3 || (_DWORD)v8 == 5)
  {
    v7 = *((_QWORD *)&v9 + 1) < a1[4];
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_BYTE *)(a3 + 24) = v7;
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = "Invalid fact type for this operation (expected an integer or BOOL)";
    *(_DWORD *)a3 = 3;
    *(_QWORD *)(a3 + 16) = 66;
  }
  return result;
}

void TLE::AndOperation::~AndOperation(TLE::AndOperation *this)
{
  TLE::AndOperation::~AndOperation(this);
  JUMPOUT(0x18D76FAA0);
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD **v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *exception;
  _QWORD *v10;

  *(_QWORD *)this = &off_1E1FC81C8;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    v3 = *((unsigned int *)this + 10);
    if ((_DWORD)v3)
    {
      v4 = 8 * v3;
      v5 = (_QWORD **)*((_QWORD *)this + 4);
      do
      {
        v6 = *v5;
        if (*v5)
        {
          v7 = v6[1];
          if (v7 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
          }
          v8 = v7 - 1;
          v6[1] = v8;
          if (!v8)
            (*(void (**)(_QWORD *))(*v6 + 8))(v6);
        }
        *v5++ = 0;
        v4 -= 8;
      }
      while (v4);
    }
    free(v2);
  }
  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    v10 = __cxa_allocate_exception(8uLL);
    *v10 = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(v10, MEMORY[0x1E0DE4E50], 0);
  }
}

_QWORD *TLE::AndOperation::Execute@<X0>(_QWORD *result@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _BOOL4 v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;

  v5 = result[4];
  if (v5)
  {
    v6 = v5 + 8 * *((unsigned int *)result + 10);
    if (v6 < v5 || (8 * (unint64_t)*((unsigned int *)result + 10)) >> 32)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", a2);
    v8 = (v6 - (unsigned __int128)v5) >> 64;
    v7 = 8 * *((unsigned int *)result + 10);
    if ((v8 & 1) != (unint64_t)(int)v7 >> 63 || v7 != (int)v7)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The offset of the pointer inside its valid memory range can't be represented using int32_t", a2);
    v10 = (8 * *((_DWORD *)result + 10));
  }
  else
  {
    v10 = 0;
    LODWORD(v7) = 0;
  }
  v11 = (int)v7;
  v12 = (uint64_t)(int)v7 >> 63;
  v13 = (_QWORD *)(v5 + v11);
  if (__CFADD__(v5, v11))
    v14 = v12 + 1;
  else
    v14 = v12;
  v16 = v14 << 63 >> 63 != v14 || v14 << 63 >> 63 == -1;
  while (1)
  {
    v17 = (_QWORD *)(v5 + (v10 >> 32));
    if (__CFADD__(v5, v10 >> 32))
      v18 = (v10 >> 63) + 1;
    else
      v18 = v10 >> 63;
    v19 = v18 << 63 >> 63;
    if (v19 != v18 || v19 < 0 || v16)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.", a2);
    if (v17 == v13)
    {
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_BYTE *)(a3 + 24) = 1;
      return result;
    }
    if (v10 < 0 || HIDWORD(v10) + 8 > v10)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally", a2);
    v20 = 0u;
    v21 = 0u;
    result = (*(_QWORD *(**)(__int128 *__return_ptr, _QWORD, const char *))(*(_QWORD *)*v17 + 16))(&v20, *v17, a2);
    if ((_DWORD)v20)
    {
      *(_BYTE *)(a3 + 24) = 0;
      *(_OWORD *)a3 = v20;
      *(_QWORD *)(a3 + 16) = v21;
      return result;
    }
    if (!BYTE8(v21))
      break;
    if ((unint64_t)((v10 >> 32) - 2147483640) < 0xFFFFFFFF00000000)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the current position would overflow.", a2);
    v10 += 0x800000000;
  }
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  return result;
}

void TLE::OrOperation::~OrOperation(TLE::OrOperation *this)
{
  TLE::OrOperation::~OrOperation(this);
  JUMPOUT(0x18D76FAA0);
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD **v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *exception;
  _QWORD *v10;

  *(_QWORD *)this = &off_1E1FC8198;
  v2 = (void *)*((_QWORD *)this + 4);
  if (v2)
  {
    v3 = *((unsigned int *)this + 10);
    if ((_DWORD)v3)
    {
      v4 = 8 * v3;
      v5 = (_QWORD **)*((_QWORD *)this + 4);
      do
      {
        v6 = *v5;
        if (*v5)
        {
          v7 = v6[1];
          if (v7 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            *exception = "Over-release of an object";
            __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
          }
          v8 = v7 - 1;
          v6[1] = v8;
          if (!v8)
            (*(void (**)(_QWORD *))(*v6 + 8))(v6);
        }
        *v5++ = 0;
        v4 -= 8;
      }
      while (v4);
    }
    free(v2);
  }
  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    v10 = __cxa_allocate_exception(8uLL);
    *v10 = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(v10, MEMORY[0x1E0DE4E50], 0);
  }
}

uint64_t TLE::OrOperation::Execute@<X0>(uint64_t result@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _BOOL4 v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;

  v5 = *(_QWORD *)(result + 32);
  if (v5)
  {
    v6 = v5 + 8 * *(unsigned int *)(result + 40);
    if (v6 < v5 || (8 * (unint64_t)*(unsigned int *)(result + 40)) >> 32)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The range of valid memory is too large to be represented by this type, or [begin, end) is not a well-formed range", a2);
    v8 = (v6 - (unsigned __int128)v5) >> 64;
    v7 = 8 * *(unsigned int *)(result + 40);
    if ((v8 & 1) != (unint64_t)(int)v7 >> 63 || v7 != (int)v7)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"The offset of the pointer inside its valid memory range can't be represented using int32_t", a2);
    v10 = (8 * *(_DWORD *)(result + 40));
  }
  else
  {
    v10 = 0;
    LODWORD(v7) = 0;
  }
  v11 = (int)v7;
  v12 = (uint64_t)(int)v7 >> 63;
  v13 = (_QWORD *)(v5 + v11);
  if (__CFADD__(v5, v11))
    v14 = v12 + 1;
  else
    v14 = v12;
  v16 = v14 << 63 >> 63 != v14 || v14 << 63 >> 63 == -1;
  while (1)
  {
    v17 = (_QWORD *)(v5 + (v10 >> 32));
    if (__CFADD__(v5, v10 >> 32))
      v18 = (v10 >> 63) + 1;
    else
      v18 = v10 >> 63;
    v19 = v18 << 63 >> 63;
    if (v19 != v18 || v19 < 0 || v16)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"This bounded_ptr is pointing to memory outside of what can be represented by a native pointer.", a2);
    if (v17 == v13)
    {
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_BYTE *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      return result;
    }
    if (v10 < 0 || HIDWORD(v10) + 8 > v10)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator*: Dereferencing this pointer would access memory outside of the bounds set originally", a2);
    v20 = 0u;
    v21 = 0u;
    result = (uint64_t)(*(_QWORD *(**)(__int128 *__return_ptr, _QWORD, const char *))(*(_QWORD *)*v17 + 16))(&v20, *v17, a2);
    if ((_DWORD)v20)
    {
      *(_BYTE *)(a3 + 24) = 0;
      *(_OWORD *)a3 = v20;
      *(_QWORD *)(a3 + 16) = v21;
      return result;
    }
    result = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v17 + 24))(*v17);
    if ((result & 1) == 0)
    {
      if (BYTE8(v21))
        break;
    }
    if ((unint64_t)((v10 >> 32) - 2147483640) < 0xFFFFFFFF00000000)
      os_detail::panic_trapping_policy::trap((os_detail::panic_trapping_policy *)"bounded_ptr<T>::operator+=(n): Adding the specified number of bytes to the offset representing the current position would overflow.", a2);
    v10 += 0x800000000;
  }
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void TLE::InOperation::~InOperation(TLE::InOperation *this)
{
  _QWORD *exception;

  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
}

{
  _QWORD *exception;

  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

void TLE::InOperation::Execute(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *v4;
  _OWORD v5[2];
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v6 = 0;
  memset(v5, 0, sizeof(v5));
  (*(void (**)(_OWORD *__return_ptr, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(v5, a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  if (LODWORD(v5[0]) == 3 || LODWORD(v5[0]) == 4 || LODWORD(v5[0]) == 6)
  {
    der_vm_iterate_b();
    v4 = v8;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_BYTE *)(a3 + 24) = *((_BYTE *)v4 + 24);
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = "In Operation expected the Fact to be an integer, string or data";
    *(_DWORD *)a3 = 3;
    *(_QWORD *)(a3 + 16) = 63;
  }
  _Block_object_dispose(&v7, 8);
}

void sub_18A99CF14(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN3TLE11InOperation7ExecuteERNS_12EncyclopediaE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;

  if (*(_DWORD *)(a2 + 116) != 3)
    return 1;
  v3 = der_vm_integer_from_context();
  result = 1;
  if (v3 == *(_QWORD *)(a1 + 40))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    return 0;
  }
  return result;
}

uint64_t ___ZN3TLE11InOperation7ExecuteERNS_12EncyclopediaE_block_invoke_2(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t result;

  if (*(_DWORD *)(a2 + 116) != 4)
    return 1;
  der_vm_string_from_context();
  v3 = CEBuffer_cmp();
  result = 1;
  if (!v3)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    return 0;
  }
  return result;
}

uint64_t ___ZN3TLE11InOperation7ExecuteERNS_12EncyclopediaE_block_invoke_3(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t result;

  if (*(_DWORD *)(a2 + 116) != 6)
    return 1;
  der_vm_data_from_context();
  v3 = CEBuffer_cmp();
  result = 1;
  if (!v3)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    return 0;
  }
  return result;
}

void TLE::QueryOperation::~QueryOperation(TLE::QueryOperation *this)
{
  _QWORD *exception;

  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
}

{
  _QWORD *exception;

  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

void TLE::QueryOperation::Execute(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  char is_valid;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  __n128 (*v13)(uint64_t, uint64_t);
  uint64_t (*v14)();
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[5];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  v23 = 0u;
  v24 = 0u;
  (*(void (**)(__int128 *__return_ptr, uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 24))(&v23, a2, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24));
  if ((_DWORD)v23 == 1)
  {
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    v26 = 0u;
    v27 = 0u;
    v18[0] = 0;
    v18[1] = v18;
    v18[2] = 0x6002000000;
    v18[3] = __Block_byref_object_copy__4593;
    v18[4] = __Block_byref_object_dispose__4594;
    v19 = 0u;
    v20 = 0u;
    v21 = 0u;
    v22 = 0;
    v5 = *(_OWORD *)(*((_QWORD *)&v24 + 1) + 16);
    v4 = *(_OWORD *)(*((_QWORD *)&v24 + 1) + 32);
    v6 = *(_QWORD *)(*((_QWORD *)&v24 + 1) + 48);
    v19 = **((_OWORD **)&v24 + 1);
    v22 = v6;
    v21 = v4;
    v20 = v5;
    v10 = 0;
    v11 = &v10;
    v12 = 0x4002000000;
    v13 = __Block_byref_object_copy__5;
    v14 = __Block_byref_object_dispose__6;
    v16 = 0;
    v17 = 0;
    v15 = 0;
    v7 = der_vm_iterate_b();
    v8 = v11 + 5;
    if (*((_DWORD *)v11 + 10))
    {
      *(_BYTE *)(a3 + 24) = 0;
      *(_OWORD *)a3 = *(_OWORD *)v8;
      *(_QWORD *)(a3 + 16) = v8[2];
    }
    else if (v7 == *MEMORY[0x1E0DDFFA0])
    {
      is_valid = der_vm_context_is_valid();
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_BYTE *)(a3 + 24) = is_valid;
    }
    else
    {
      *(_BYTE *)(a3 + 24) = 0;
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = "Attempted to execute a non-iterable query";
      *(_DWORD *)a3 = 6;
      *(_QWORD *)(a3 + 16) = 41;
    }
    _Block_object_dispose(&v10, 8);
    _Block_object_dispose(v18, 8);
  }
  else
  {
    *(_BYTE *)(a3 + 24) = 0;
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = "Query Operation expected the Fact to be a CoreEntitlements dictionary";
    *(_DWORD *)a3 = 3;
    *(_QWORD *)(a3 + 16) = 69;
  }
}

void sub_18A99D3E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__4593(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;
  __int128 v4;

  result = *(__n128 *)(a2 + 40);
  v3 = *(_OWORD *)(a2 + 56);
  v4 = *(_OWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v4;
  *(_OWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 40) = result;
  return result;
}

__n128 __Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t ___ZN3TLE14QueryOperation7ExecuteERNS_12EncyclopediaE_block_invoke(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;

  der_vm_execute_nocopy();
  der_vm_execute_nocopy();
  v2 = der_vm_integer_from_context() & 0xBFFFFFFFFFFFFFFFLL;
  **(_QWORD **)(a1 + 48) = v2;
  if (v2 > 0xB)
    goto LABEL_12;
  if (((1 << v2) & 0x35A) == 0)
  {
    if (((1 << v2) & 0xC80) != 0)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) = der_vm_integer_from_context();
      goto LABEL_8;
    }
    if (v2 == 5)
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) = der_vm_BOOL_from_context();
      goto LABEL_8;
    }
LABEL_12:
    result = 0;
    v8 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    *(_DWORD *)(v8 + 40) = 1;
    *(_QWORD *)(v8 + 48) = "Attempted to execute unknown CoreEntitlements operation";
    *(_QWORD *)(v8 + 56) = 55;
    return result;
  }
  v3 = der_vm_string_from_context();
  v4 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(v4 + 8) = v3;
  *(_QWORD *)(v4 + 16) = v5;
  **(_QWORD **)(a1 + 48) |= 0x4000000000000000uLL;
LABEL_8:
  if (der_vm_context_is_valid())
  {
    der_vm_execute_nocopy();
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    *(_OWORD *)(v6 + 40) = v9;
    *(_OWORD *)(v6 + 56) = v10;
    *(_OWORD *)(v6 + 72) = v11;
    *(_QWORD *)(v6 + 88) = v12;
  }
  return 1;
}

void TLE::OptionalOperation::~OptionalOperation(TLE::OptionalOperation *this)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *exception;

  *(_QWORD *)this = &off_1E1FC8258;
  v2 = (_QWORD *)*((_QWORD *)this + 4);
  if (v2)
  {
    v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
    }
    v4 = v3 - 1;
    v2[1] = v4;
    if (!v4)
      (*(void (**)(_QWORD *))(*v2 + 8))(v2);
  }
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    v5 = __cxa_allocate_exception(8uLL);
    *v5 = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(v5, MEMORY[0x1E0DE4E50], 0);
  }
}

{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *exception;

  *(_QWORD *)this = &off_1E1FC8258;
  v2 = (_QWORD *)*((_QWORD *)this + 4);
  if (v2)
  {
    v3 = v2[1];
    if (v3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      *exception = "Over-release of an object";
      __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
    }
    v4 = v3 - 1;
    v2[1] = v4;
    if (!v4)
      (*(void (**)(_QWORD *))(*v2 + 8))(v2);
  }
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = &off_1E1FC7FC8;
  if (*((_QWORD *)this + 1))
  {
    v5 = __cxa_allocate_exception(8uLL);
    *v5 = "RefCounted object destroyed, but is not fully released";
    __cxa_throw(v5, MEMORY[0x1E0DE4E50], 0);
  }
  JUMPOUT(0x18D76FAA0);
}

double TLE::OptionalOperation::Execute@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  double result;
  char v6;
  __int128 v7;
  __int128 v8;

  v7 = 0u;
  v8 = 0u;
  (*(void (**)(__int128 *__return_ptr))(**(_QWORD **)(a1 + 32) + 16))(&v7);
  if ((_DWORD)v7)
  {
    if ((_DWORD)v7 != 5 && (_DWORD)v7 != 1)
    {
      *(_BYTE *)(a2 + 24) = 0;
      result = *(double *)&v7;
      *(_OWORD *)a2 = v7;
      *(_QWORD *)(a2 + 16) = v8;
      return result;
    }
    v6 = 1;
    *(_BYTE *)(a1 + 40) = 1;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    *(_QWORD *)a2 = 0;
  }
  else
  {
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v6 = BYTE8(v8);
  }
  *(_BYTE *)(a2 + 24) = v6;
  return result;
}

uint64_t TLE::OptionalOperation::shouldIgnore(TLE::OptionalOperation *this)
{
  return *((unsigned __int8 *)this + 40);
}

double SecCmsSignedDataCreate(uint64_t a1)
{
  uint64_t v2;
  double result;

  v2 = PORT_ArenaAlloc(*(_QWORD *)(a1 + 120), 0xB8uLL);
  if (v2)
  {
    result = 0.0;
    *(_QWORD *)(v2 + 176) = 0;
    *(_OWORD *)(v2 + 144) = 0u;
    *(_OWORD *)(v2 + 160) = 0u;
    *(_OWORD *)(v2 + 112) = 0u;
    *(_OWORD *)(v2 + 128) = 0u;
    *(_OWORD *)(v2 + 80) = 0u;
    *(_OWORD *)(v2 + 96) = 0u;
    *(_OWORD *)(v2 + 48) = 0u;
    *(_OWORD *)(v2 + 64) = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_OWORD *)(v2 + 32) = 0u;
    *(_OWORD *)v2 = 0u;
    *(_QWORD *)(v2 + 24) = a1;
  }
  return result;
}

uint64_t SecCmsSignedDataEncodeBeforeStart(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t OID;
  unsigned int v9;
  uint64_t i;
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v14;
  int v15;
  uint64_t v17;
  unsigned int v18;
  int IndexByAlgTag;
  BOOL v20;
  uint64_t v22;

  v2 = *(_QWORD **)(a1 + 136);
  if (v2 && (v3 = *(_QWORD **)(a1 + 168)) != 0)
  {
    if (*v2)
    {
      v4 = v2 + 1;
      while (1)
      {
        v5 = *v3 != 0;
        if (!*v3)
          break;
        v6 = *v4++;
        ++v3;
        if (!v6)
          goto LABEL_7;
      }
    }
    else
    {
LABEL_7:
      v5 = 1;
    }
  }
  else
  {
    v5 = 0;
  }
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 120);
  OID = *(_QWORD *)(a1 + 32);
  if (OID || (OID = SECOID_FindOID(a1), (*(_QWORD *)(a1 + 32) = OID) != 0))
  {
    if (*(_DWORD *)(OID + 16) == 25)
      v9 = 1;
    else
      v9 = 3;
  }
  else
  {
    v9 = 3;
  }
  for (i = 0; ; ++i)
  {
    v11 = *(uint64_t **)(a1 + 160);
    if (v11)
    {
      v12 = *v11;
      if (*v11)
      {
        v12 = 0;
        while (v11[++v12])
          ;
      }
    }
    else
    {
      LODWORD(v12) = 0;
    }
    if (i >= (int)v12)
      break;
    v14 = (uint64_t *)v11[i];
    v22 = 0xAAAAAAAAAAAAAAAALL;
    v15 = SEC_ASN1DecodeInteger(v14, &v22);
    if ((_DWORD)v22 != 1 || v15 != 0)
      v9 = 3;
    v17 = SECOID_FindOID((uint64_t)(v14 + 4));
    if (v17)
      v18 = *(_DWORD *)(v17 + 16);
    else
      v18 = 0;
    IndexByAlgTag = SecCmsAlgArrayGetIndexByAlgTag(*(size_t ***)(a1 + 136), v18);
    v20 = IndexByAlgTag < 0 && v5;
    if (v20 || IndexByAlgTag < 0 && SecCmsSignedDataAddDigest(v7, a1, v18, 0))
      return 0xFFFFFFFFLL;
  }
  if (!SEC_ASN1EncodeInteger(v7, (_QWORD *)(a1 + 120), v9))
    return 0xFFFFFFFFLL;
  if (SecCmsArraySortByDER(*(int8x16_t **)(a1 + 136), (uint64_t)&SECOID_AlgorithmIDTemplate, *(int8x16_t **)(a1 + 168)))return 0xFFFFFFFFLL;
  else
    return 0;
}

uint64_t SecCmsSignedDataAddDigest(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t result;

  v8 = PORT_ArenaAlloc(a1, 0x20uLL);
  if (!v8)
    return 0xFFFFFFFFLL;
  v9 = v8;
  *(_OWORD *)v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  if (SECOID_SetAlgorithmID(a1, (unint64_t *)v8, a3, 0))
    return 0xFFFFFFFFLL;
  if (SecCmsArrayAdd(a1, (char **)(a2 + 136), v9))
    return 0xFFFFFFFFLL;
  result = SecCmsArrayAdd(a1, (char **)(a2 + 168), a4);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t SecCmsSignedDataSignerInfoCount(uint64_t a1)
{
  _QWORD *v1;
  uint64_t result;
  _QWORD *v3;

  v1 = *(_QWORD **)(a1 + 160);
  if (!v1 || !*v1)
    return 0;
  result = 0;
  v3 = v1 + 1;
  while (v3[result++])
    ;
  return result;
}

uint64_t SecCmsSignedDataGetSignerInfo(uint64_t a1, int a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8 * a2);
}

uint64_t SecCmsSignedDataEncodeAfterData(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFIndex v5;
  int8x16_t *v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t OID;
  unsigned int v11;
  unsigned int IndexByAlgTag;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  int v20;
  const void *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  __int128 *v28;
  const void *v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  signed int v33;
  uint64_t v34;
  _DWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  const __CFArray *v39;
  _QWORD *ThreadErrInfo;
  const __CFArray *v41;
  uint64_t result;
  _QWORD *v43;
  unint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  CFIndex i;
  _QWORD *v51;
  _QWORD *ValueAtIndex;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  const __CFArray *v57;
  CFIndex j;
  _QWORD *v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  _QWORD *v64;
  int8x16_t *v65;
  uint64_t v66;
  uint64_t v67;
  CFIndex v68;
  CFIndex v69;
  const UInt8 *v70;
  __int128 v71;
  __int128 v72;
  unint64_t **Size;
  void *v74;
  int v75;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 120);
  v3 = *(_QWORD *)(a1 + 104);
  if (v3)
  {
    *(_QWORD *)&v71 = 0;
    Size = 0;
    if (SecCmsDigestContextFinishMultiple(v3, &Size, &v71)
      || Size && (_QWORD)v71 && SecCmsSignedDataSetDigests((_QWORD *)a1, Size, v71))
    {
      return 0xFFFFFFFFLL;
    }
    SecCmsDigestContextCancel(*(_QWORD *)(a1 + 104));
    *(_QWORD *)(a1 + 104) = 0;
  }
  v4 = 0;
  v5 = 0;
  v6 = *(int8x16_t **)(a1 + 160);
  v65 = v6;
  v66 = v2;
  if (!v6)
    goto LABEL_12;
LABEL_8:
  v7 = v6->i64[0];
  if (v6->i64[0])
  {
    v7 = 0;
    while (v6->i64[++v7])
      ;
  }
  while (v4 < (int)v7)
  {
    v9 = v6->i64[v4];
    OID = SECOID_FindOID(v9 + 32);
    if (OID)
      v11 = *(_DWORD *)(OID + 16);
    else
      v11 = 0;
    IndexByAlgTag = SecCmsAlgArrayGetIndexByAlgTag(*(size_t ***)(a1 + 136), v11);
    if ((IndexByAlgTag & 0x80000000) != 0
      || (v13 = *(_QWORD *)(a1 + 168)) == 0
      || (v14 = IndexByAlgTag, (v15 = *(_QWORD *)(v13 + 8 * IndexByAlgTag)) == 0))
    {
      ThreadErrInfo = PR_getThreadErrInfo(1, (int *)&v71);
      if (ThreadErrInfo)
        *ThreadErrInfo = 0xFFFFE08500000000;
      return 0xFFFFFFFFLL;
    }
    v16 = *(unint64_t **)(a1 + 32);
    if (!v16)
    {
      v17 = SECOID_FindOID(a1);
      *(_QWORD *)(a1 + 32) = v17;
      if (!v17)
        return 0xFFFFFFFFLL;
      v16 = (unint64_t *)v17;
      v15 = *(_QWORD *)(*(_QWORD *)(a1 + 168) + 8 * v14);
    }
    Size = 0;
    v74 = 0;
    v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 128) + 24) + 120);
    *(_QWORD *)&v19 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v71 = v19;
    v72 = v19;
    v20 = *(_DWORD *)(v9 + 16);
    if (v20 == 1)
    {
      v21 = *(const void **)(v9 + 168);
      v29 = *(const void **)(v9 + 176);
      *(_QWORD *)(v9 + 168) = 0;
      if (v29)
      {
        *(_QWORD *)(v9 + 176) = 0;
        CFRelease(v29);
      }
      v28 = 0;
    }
    else
    {
      if (v20)
      {
        v45 = PR_getThreadErrInfo(1, (int *)&v69);
        if (v45)
          *v45 = 0xFFFFE08600000000;
        goto LABEL_117;
      }
      v21 = *(const void **)(v9 + 168);
      *(_QWORD *)(v9 + 168) = 0;
      v22 = *(_QWORD **)(v9 + 136);
      v24 = v22[27];
      v23 = v22[28];
      v27 = v22 + 29;
      v25 = v22[29];
      v26 = v27[1];
      *(_QWORD *)&v71 = v23;
      *((_QWORD *)&v71 + 1) = v24;
      *(_QWORD *)&v72 = v26;
      *((_QWORD *)&v72 + 1) = v25;
      v28 = &v71;
    }
    v30 = SECOID_FindOID(v9 + 32);
    v67 = v4;
    v68 = v5;
    if (v30)
    {
      v31 = *(_DWORD *)(v30 + 16);
      if (v28 && *((_QWORD *)v28 + 1) && (v32 = SECOID_FindOID((uint64_t)v28)) != 0)
        v33 = *(_DWORD *)(v32 + 16);
      else
        v33 = 0;
      if (v31 == 3)
      {
        v43 = PR_getThreadErrInfo(1, (int *)&v69);
        if (v43)
        {
          v44 = 0xFFFFE00600000000;
          goto LABEL_104;
        }
        goto LABEL_118;
      }
    }
    else if (v28 && *((_QWORD *)v28 + 1) && (v34 = SECOID_FindOID((uint64_t)v28)) != 0)
    {
      v31 = 0;
      v33 = *(_DWORD *)(v34 + 16);
    }
    else
    {
      v33 = 0;
      v31 = 0;
    }
    if (*(_QWORD *)(v9 + 64))
    {
      if (SecCmsAttributeArraySetAttr(v18, (uint64_t **)(v9 + 64), 0x22u, (unint64_t *)v15)
        || SecCmsAttributeArraySetAttr(v18, (uint64_t **)(v9 + 64), 0x21u, v16))
      {
        goto LABEL_118;
      }
      v35 = PORT_NewArena(1024);
      if (!v35)
      {
        v43 = PR_getThreadErrInfo(1, &v75);
        if (v43)
        {
          v44 = 0xFFFFE01300000000;
LABEL_104:
          *v43 = v44;
        }
LABEL_118:
        v36 = 0;
LABEL_119:
        if (Size)
        {
          if (v74)
            free(v74);
          v74 = 0;
LABEL_123:
          Size = 0;
        }
        if (v21)
          CFRelease(v21);
        if (v36)
          PORT_FreeArena(v36, 0);
        return 0xFFFFFFFFLL;
      }
      v36 = v35;
      if (SecCmsArraySortByDER(*(int8x16_t **)(v9 + 64), (uint64_t)&nss_cms_attribute_template, 0))
        goto LABEL_119;
      v69 = 0;
      v70 = 0;
      if (!SEC_ASN1EncodeItem((uint64_t)v36, &v69, v9 + 64, (uint64_t)&nss_cms_set_of_attribute_template))
        goto LABEL_119;
      Size = (unint64_t **)SecKeyGetSize((uint64_t)v21, 1);
      v37 = PORT_ZAlloc((unint64_t)Size);
      v74 = v37;
      if (!v37)
      {
        Size = 0;
        goto LABEL_119;
      }
      if (SecKeyDigestAndSign((uint64_t)v21, (const SecAsn1Oid *)(v9 + 32), v70, v69, (UInt8 *)v37, (CFIndex *)&Size))
      {
        if (v74)
          free(v74);
        Size = 0;
        PORT_FreeArena(v36, 0);
        if (!v21)
          goto LABEL_118;
LABEL_116:
        CFRelease(v21);
LABEL_117:
        v21 = 0;
        goto LABEL_118;
      }
      PORT_FreeArena(v36, 0);
    }
    else
    {
      Size = (unint64_t **)SecKeyGetSize((uint64_t)v21, 1);
      v38 = PORT_ZAlloc((unint64_t)Size);
      v74 = v38;
      if (!v38)
      {
        v36 = 0;
        goto LABEL_123;
      }
      if (SecKeySignDigest((uint64_t)v21, (const SecAsn1Oid *)(v9 + 32), *(const UInt8 **)(v15 + 8), *(_QWORD *)v15, (UInt8 *)v38, (CFIndex *)&Size))
      {
        if (v74)
          free(v74);
        Size = 0;
        if (v21)
          goto LABEL_116;
        return 0xFFFFFFFFLL;
      }
    }
    if (v21)
      CFRelease(v21);
    if (SECITEM_CopyItem(v18, (unint64_t *)(v9 + 104), (uint64_t)&Size))
      goto LABEL_117;
    if (v74)
      free(v74);
    Size = 0;
    v74 = 0;
    if (v33 > 123)
    {
      if (v33 == 124)
      {
LABEL_72:
        if (v31 == 4)
          v33 = 125;
        else
          v33 = 0;
        goto LABEL_75;
      }
      if (v33 != 202)
        goto LABEL_75;
      if (v31 > 192)
      {
        if (v31 != 193)
        {
          if (v31 == 194)
          {
            v33 = 213;
            goto LABEL_75;
          }
          goto LABEL_87;
        }
        v33 = 212;
      }
      else
      {
        if (v31 != 4)
        {
          if (v31 == 192)
          {
            v33 = 211;
            goto LABEL_75;
          }
          goto LABEL_87;
        }
        v33 = 203;
      }
    }
    else
    {
      if ((v33 - 56) < 2)
        goto LABEL_72;
      if (v33 != 16)
        goto LABEL_75;
      if (v31 <= 191)
      {
        if (v31 != 1)
        {
          if (v31 == 4)
          {
            v33 = 20;
            goto LABEL_75;
          }
          goto LABEL_87;
        }
        v33 = 17;
      }
      else
      {
        switch(v31)
        {
          case 192:
            v33 = 195;
            break;
          case 193:
            v33 = 196;
            break;
          case 194:
            v33 = 197;
            break;
          default:
LABEL_87:
            v33 = 0;
            break;
        }
      }
    }
LABEL_75:
    if (SECOID_SetAlgorithmID(v18, (unint64_t *)(v9 + 72), v33, 0))
      goto LABEL_117;
    v39 = *(const __CFArray **)(v9 + 144);
    if (v39)
    {
      v5 = CFArrayGetCount(v39) + v68;
      v2 = v66;
    }
    else
    {
      v2 = v66;
      v5 = v68;
    }
    v4 = v67 + 1;
    v6 = *(int8x16_t **)(a1 + 160);
    if (v6)
      goto LABEL_8;
LABEL_12:
    LODWORD(v7) = 0;
  }
  if (SecCmsArraySortByDER(v65, (uint64_t)&SecCmsSignerInfoTemplate, 0))
    return 0xFFFFFFFFLL;
  v41 = *(const __CFArray **)(a1 + 176);
  if (v41)
    v5 += CFArrayGetCount(v41);
  if ((unint64_t)(v5 - 0xFFFFFFFFFFFFFFELL) <= 0xF000000000000002)
  {
    result = 0;
    *(_QWORD *)(a1 + 144) = 0;
    return result;
  }
  v46 = PORT_ArenaAlloc(v2, 8 * v5 + 8);
  *(_QWORD *)(a1 + 144) = v46;
  if (v46)
  {
    if (v65 && (v47 = v65->i64[0]) != 0)
    {
      v48 = 0;
      v49 = 0;
      do
      {
        for (i = 0; CFArrayGetCount(*(CFArrayRef *)(v47 + 144)) > i; ++i)
        {
          v51 = (_QWORD *)PORT_ArenaAlloc(v2, 0x10uLL);
          if (v51)
          {
            *v51 = 0;
            v51[1] = 0;
          }
          *(_QWORD *)(*(_QWORD *)(a1 + 144) + 8 * v49) = v51;
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v47 + 144), i);
          v53 = ValueAtIndex[3];
          if ((v53 & 0x8000000000000000) == 0)
          {
            v54 = v49;
            v55 = ValueAtIndex[2];
            ++v49;
            v56 = *(_QWORD **)(*(_QWORD *)(a1 + 144) + 8 * v54);
            *v56 = v53;
            v56[1] = v55;
          }
        }
        v47 = v65->i64[++v48];
      }
      while (v47);
    }
    else
    {
      v49 = 0;
    }
    v57 = *(const __CFArray **)(a1 + 176);
    if (v57)
    {
      for (j = 0; CFArrayGetCount(v57) > j; ++j)
      {
        v59 = (_QWORD *)PORT_ArenaAlloc(v2, 0x10uLL);
        if (v59)
        {
          *v59 = 0;
          v59[1] = 0;
        }
        *(_QWORD *)(*(_QWORD *)(a1 + 144) + 8 * v49) = v59;
        v60 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 176), j);
        v61 = v60[3];
        if ((v61 & 0x8000000000000000) == 0)
        {
          v62 = v49;
          v63 = v60[2];
          ++v49;
          v64 = *(_QWORD **)(*(_QWORD *)(a1 + 144) + 8 * v62);
          *v64 = v61;
          v64[1] = v63;
        }
        v57 = *(const __CFArray **)(a1 + 176);
      }
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 144) + 8 * v49) = 0;
    SecCmsArraySort(*(_QWORD **)(a1 + 144), 0, 0);
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t SecCmsSignedDataGetSignerInfos(uint64_t a1)
{
  return *(_QWORD *)(a1 + 160);
}

uint64_t SecCmsSignedDataGetDigestAlgs(uint64_t a1)
{
  return *(_QWORD *)(a1 + 136);
}

uint64_t SecCmsSignedDataGetCertificateList(uint64_t a1)
{
  return *(_QWORD *)(a1 + 144);
}

uint64_t SecCmsSignedDataImportCerts()
{
  return 4294967292;
}

uint64_t SecCmsSignedDataVerifySignerInfo(uint64_t a1, int a2, uint64_t a3, const void *a4, SecTrustRef *a5)
{
  return SecCmsSignedDataVerifySignerInfo_internal(a1, a2, a4, a5);
}

uint64_t SecCmsSignedDataVerifyCertsOnly(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v6;
  const __CFAllocator *v7;
  uint64_t *v8;
  CFArrayRef v9;
  CFAbsoluteTime Current;
  int v11;
  CFTypeRef v12;
  uint64_t v13;
  _QWORD *ThreadErrInfo;
  CFTypeRef cf;
  int v17;

  if (a1 && a2 && (v3 = *(uint64_t **)(a1 + 144)) != 0)
  {
    v4 = *v3;
    if (*v3)
    {
      LODWORD(v6) = 0;
      v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v8 = v3 + 1;
      do
      {
        if ((*(_QWORD *)v4 & 0x8000000000000000) != 0
          || (cf = (CFTypeRef)0xAAAAAAAAAAAAAAAALL,
              (cf = SecCertificateCreateWithBytes(0, *(const void **)(v4 + 8), *(_QWORD *)v4)) == 0))
        {
          v6 = 0xFFFFFFFFLL;
        }
        else
        {
          v9 = CFArrayCreate(v7, &cf, 1, 0);
          Current = CFAbsoluteTimeGetCurrent();
          v11 = CERT_VerifyCert(v9, a3, 0, Current);
          if (v9)
            CFRelease(v9);
          v6 = v11 | v6;
          v12 = cf;
          if (cf)
          {
            cf = 0;
            CFRelease(v12);
          }
        }
        v13 = *v8++;
        v4 = v13;
      }
      while (v13);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v17);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0xFFFFE00500000000;
    return 0xFFFFFFFFLL;
  }
  return v6;
}

uint64_t SecCmsSignedDataVerifyCertsOnlyMessage()
{
  _QWORD *ThreadErrInfo;
  int v2;

  ThreadErrInfo = PR_getThreadErrInfo(1, &v2);
  if (ThreadErrInfo)
    *ThreadErrInfo = 0xFFFFE00500000000;
  return 0xFFFFFFFFLL;
}

BOOL SecCmsSignedDataHasDigests(uint64_t a1)
{
  return *(_QWORD *)(a1 + 168) != 0;
}

uint64_t SecCmsSignedDataAddCertList(uint64_t a1, CFArrayRef theArray)
{
  uint64_t result;
  CFMutableArrayRef MutableCopy;
  CFRange v6;

  if (!theArray)
    return 0xFFFFFFFFLL;
  if (*(_QWORD *)(a1 + 176))
  {
    v6.length = CFArrayGetCount(theArray);
    v6.location = 0;
    CFArrayAppendArray(*(CFMutableArrayRef *)(a1 + 176), theArray, v6);
    return 0;
  }
  else
  {
    MutableCopy = CFArrayCreateMutableCopy(0, 0, theArray);
    result = 0;
    *(_QWORD *)(a1 + 176) = MutableCopy;
  }
  return result;
}

uint64_t SecCmsSignedDataAddCertChain(uint64_t a1, void *a2)
{
  const __CFArray *v3;
  const __CFArray *v4;
  uint64_t v5;

  v3 = CERT_CertChainFromCert(a2, 0, 0);
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = v3;
  v5 = SecCmsSignedDataAddCertList(a1, v3);
  CFRelease(v4);
  return v5;
}

uint64_t SecCmsSignedDataAddCertificate(uint64_t a1, void *value)
{
  __CFArray *Mutable;

  if (!value)
    return 0xFFFFFFFFLL;
  Mutable = *(__CFArray **)(a1 + 176);
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    *(_QWORD *)(a1 + 176) = Mutable;
  }
  CFArrayAppendValue(Mutable, value);
  return 0;
}

BOOL SecCmsSignedDataContainsCertsOrCrls(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  _BOOL8 result;

  v1 = *(_QWORD **)(a1 + 144);
  result = 1;
  if (!v1 || !*v1)
  {
    v2 = *(_QWORD **)(a1 + 152);
    if (!v2 || !*v2)
      return 0;
  }
  return result;
}

uint64_t SecCmsSignedDataSetDigestValue(_QWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  int *v15;
  unint64_t v16;
  unint64_t v17;
  void *v18;
  void *v19;
  size_t **v20;
  unsigned int IndexByAlgTag;
  unsigned int v22;
  uint64_t result;
  _QWORD *ThreadErrInfo;
  char v25;
  char v26;

  v5 = a1[3];
  v6 = *(_QWORD *)(v5 + 120);
  if (a3)
  {
    v8 = (unint64_t *)PORT_ArenaAlloc(*(_QWORD *)(v5 + 120), 0x10uLL);
    v9 = (uint64_t)v8;
    if (v8)
    {
      *v8 = 0;
      v8[1] = 0;
    }
    if (SECITEM_CopyItem(v6, v8, a3))
      return 0xFFFFFFFFLL;
  }
  else
  {
    v9 = 0;
  }
  if (!a1[21])
  {
    v10 = (_QWORD *)a1[17];
    if (v10)
    {
      if (*v10)
      {
        v11 = v10 + 1;
        v12 = -1;
        do
        {
          v13 = v12;
          v14 = *v11++;
          ++v12;
        }
        while (v14);
        if (v12 >= 0xFFFFFFD)
        {
          v15 = (int *)&v25;
          goto LABEL_27;
        }
        LODWORD(v10) = v13 + 2;
      }
      else
      {
        LODWORD(v10) = 0;
      }
    }
    v16 = 8 * ((_DWORD)v10 + 1);
    if (v16 <= 1)
      v17 = 1;
    else
      v17 = v16;
    v18 = (void *)PORT_ArenaAlloc(*(_QWORD *)(a1[3] + 120), v17);
    if (!v18)
    {
      a1[21] = 0;
      v15 = (int *)&v26;
LABEL_27:
      ThreadErrInfo = PR_getThreadErrInfo(1, v15);
      if (ThreadErrInfo)
        *ThreadErrInfo = 0xFFFFE01300000000;
      return 0xFFFFFFFFLL;
    }
    v19 = v18;
    bzero(v18, v17);
    a1[21] = v19;
  }
  v20 = (size_t **)a1[17];
  if (v20)
  {
    IndexByAlgTag = SecCmsAlgArrayGetIndexByAlgTag(v20, a2);
    if ((IndexByAlgTag & 0x80000000) == 0)
    {
      v22 = IndexByAlgTag;
      result = 0;
      *(_QWORD *)(a1[21] + 8 * v22) = v9;
      return result;
    }
  }
  result = SecCmsSignedDataAddDigest(v6, (uint64_t)a1, a2, v9);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

unint64_t *SecCmsSignedDataCreateCertsOnly(uint64_t a1, void *a2, int a3)
{
  uint64_t v6;
  unint64_t *v7;

  v6 = PORT_ArenaAlloc(*(_QWORD *)(a1 + 120), 0xB8uLL);
  v7 = (unint64_t *)v6;
  if (!v6)
    return v7;
  *(_QWORD *)(v6 + 176) = 0;
  *(_OWORD *)(v6 + 144) = 0u;
  *(_OWORD *)(v6 + 160) = 0u;
  *(_OWORD *)(v6 + 112) = 0u;
  *(_OWORD *)(v6 + 128) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_OWORD *)(v6 + 96) = 0u;
  *(_OWORD *)(v6 + 48) = 0u;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)v6 = 0u;
  *(_QWORD *)(v6 + 24) = a1;
  if (!a3)
  {
    if (!SecCmsSignedDataAddCertificate(v6, a2))
      goto LABEL_6;
LABEL_7:
    SecCmsSignedDataDestroy((uint64_t)v7);
    return 0;
  }
  if (SecCmsSignedDataAddCertChain(v6, a2))
    goto LABEL_7;
LABEL_6:
  if (SecCmsContentInfoSetContentData(v7, 0, 1))
    goto LABEL_7;
  return v7;
}

uint64_t InitOIDHashOnce()
{
  _QWORD *v0;
  _QWORD *v1;
  BOOL v2;
  uint64_t i;
  char *v4;
  uint64_t v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t result;
  uint64_t *v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;

  v0 = &unk_1EDF7A000;
  oidhash = (uint64_t)PL_NewHashTable((uint64_t)SECITEM_Hash, (uint64_t)SECITEM_HashCompare);
  v1 = PL_NewHashTable((uint64_t)secoid_HashNumber, (uint64_t)PL_CompareValues);
  oidmechhash = (uint64_t)v1;
  if (oidhash)
    v2 = v1 == 0;
  else
    v2 = 1;
  if (v2)
    goto LABEL_23;
  for (i = 0; i != 217; ++i)
  {
    v4 = &oids[40 * i];
    v5 = v0[455];
    v6 = (*(uint64_t (**)(char *))(v5 + 16))(v4);
    v7 = PL_HashTableRawLookup(v5, v6, (uint64_t)v4);
    v8 = *v7;
    if (*v7)
    {
      result = (*(uint64_t (**)(_QWORD, char *))(v5 + 32))(*(_QWORD *)(v8 + 24), &oids[40 * i]);
      if (!(_DWORD)result)
      {
        if (*(_QWORD *)(v8 + 24))
          result = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)(v5 + 40) + 24))(*(_QWORD *)(v5 + 48), v8, 0);
        *(_QWORD *)(v8 + 24) = v4;
      }
      continue;
    }
    v10 = v7;
    v11 = *(_DWORD *)(v5 + 12);
    v12 = (1 << -(char)v11);
    if (*(_DWORD *)(v5 + 8) >= v12 - (v12 >> 3))
    {
      v13 = v0;
      v14 = *(_QWORD *)v5;
      v15 = 8 * (2 << (32 - v11));
      v16 = (void *)(**(uint64_t (***)(_QWORD, size_t))(v5 + 40))(*(_QWORD *)(v5 + 48), v15);
      *(_QWORD *)v5 = v16;
      if (v16)
      {
        bzero(v16, v15);
        v17 = 0;
        --*(_DWORD *)(v5 + 12);
        do
        {
          v18 = *(_QWORD *)(v14 + 8 * v17);
          if (v18)
          {
            do
            {
              v19 = *(_QWORD *)v18;
              v20 = PL_HashTableRawLookup(v5, *(_DWORD *)(v18 + 8), *(_QWORD *)(v18 + 16));
              *(_QWORD *)v18 = 0;
              *v20 = v18;
              v18 = v19;
            }
            while (v19);
          }
          ++v17;
        }
        while (v17 != v12);
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)(v5 + 40) + 8))(*(_QWORD *)(v5 + 48), v14);
        v10 = PL_HashTableRawLookup(v5, v6, (uint64_t)v4);
        v0 = v13;
        goto LABEL_18;
      }
      *(_QWORD *)v5 = v14;
LABEL_23:
      PORT_SetError(-8191);
      abort();
    }
LABEL_18:
    result = (*(uint64_t (**)(_QWORD, char *))(*(_QWORD *)(v5 + 40) + 16))(*(_QWORD *)(v5 + 48), v4);
    if (!result)
      goto LABEL_23;
    *(_DWORD *)(result + 8) = v6;
    *(_QWORD *)(result + 16) = v4;
    *(_QWORD *)(result + 24) = v4;
    *(_QWORD *)result = *v10;
    *v10 = result;
    ++*(_DWORD *)(v5 + 8);
  }
  return result;
}

uint64_t SecCmsEncryptedDataCreate(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result;
  uint64_t v7;
  int v8;

  result = PORT_ArenaAlloc(*(_QWORD *)(a1 + 120), 0x90uLL);
  if (result)
  {
    v7 = result;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 128) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)result = 0u;
    *(_QWORD *)(result + 24) = a1;
    if (a2 <= 0xA && ((1 << a2) & 0x4A0) != 0)
      goto LABEL_7;
    result = 0;
    if (a2 - 184 <= 4 && ((1 << (a2 + 72)) & 0x15) != 0)
    {
LABEL_7:
      v8 = SECOID_SetAlgorithmID(*(_QWORD *)(a1 + 120), (unint64_t *)(v7 + 40), a2, 0);
      result = 0;
      if (!v8)
      {
        *(_DWORD *)(v7 + 88) = a3;
        return v7;
      }
    }
  }
  return result;
}

void SecCmsEncryptedDataDestroy(uint64_t *a1)
{
  if (a1)
    SecCmsContentInfoDestroy(a1);
}

uint64_t SecCmsEncryptedDataEncodeBeforeStart(_QWORD *a1)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(_QWORD, _QWORD *);
  const void *v6;
  const void *v7;

  v2 = (_QWORD *)a1[17];
  if (v2)
    v3 = 2 * (*v2 != 0);
  else
    v3 = 0;
  if (!SEC_ASN1EncodeInteger(*(_QWORD *)(a1[3] + 120), a1 + 15, v3))
    return 0xFFFFFFFFLL;
  v4 = a1[3];
  v5 = *(uint64_t (**)(_QWORD, _QWORD *))(v4 + 144);
  if (!v5)
    return 0xFFFFFFFFLL;
  v6 = (const void *)v5(*(_QWORD *)(v4 + 152), a1 + 5);
  if (!v6)
    return 0xFFFFFFFFLL;
  v7 = v6;
  SecCmsContentInfoSetBulkKey((uint64_t)a1, v6);
  CFRelease(v7);
  return 0;
}

void SecCmsEncryptedDataEncodeAfterData(uint64_t a1)
{
  CCCryptorRef *v1;

  v1 = *(CCCryptorRef **)(a1 + 96);
  if (v1)
  {
    CCCryptorRelease(*v1);
    free(v1);
    *(_QWORD *)(a1 + 96) = 0;
  }
}

uint64_t SecCmsArrayAdd(uint64_t a1, char **a2, uint64_t a3)
{
  char *v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v9;

  if (!a2)
    return 0xFFFFFFFFLL;
  v5 = *a2;
  if (!v5)
  {
    v9 = PORT_ArenaAlloc(a1, 0x10uLL);
    LODWORD(v6) = 0;
    if (!v9)
      return 0xFFFFFFFFLL;
LABEL_10:
    result = 0;
    *(_QWORD *)(v9 + 8 * v6) = a3;
    *(_QWORD *)(v9 + 8 * (v6 + 1)) = 0;
    *a2 = (char *)v9;
    return result;
  }
  if (*(_QWORD *)v5)
  {
    v6 = 0;
    while (*(_QWORD *)&v5[8 * v6++ + 8])
      ;
    if (v6 > 0xFFFFFFC)
      return 0xFFFFFFFFLL;
  }
  else
  {
    LODWORD(v6) = 0;
  }
  v9 = (uint64_t)PORT_ArenaGrow(a1, v5, (8 * v6 + 8), (8 * v6 + 16));
  if (v9)
    goto LABEL_10;
  return 0xFFFFFFFFLL;
}

_QWORD *SecCmsArraySort(_QWORD *result, int8x16_t *a2, int8x16_t *a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v10;
  unint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int8x16_t *v17;
  int8x16_t *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;

  v5 = result;
  if (result)
  {
    v6 = *result;
    if (*result)
    {
      v6 = 0;
      while (result[++v6])
        ;
    }
    if (!a2)
    {
LABEL_13:
      v21 = 0;
      if (!a3)
        goto LABEL_18;
      goto LABEL_14;
    }
  }
  else
  {
    LODWORD(v6) = 0;
    if (!a2)
      goto LABEL_13;
  }
  if (!a2->i64[0])
    goto LABEL_13;
  v8 = 0;
  while (a2->i64[++v8])
    ;
  v21 = v8;
  if (!a3)
    goto LABEL_18;
LABEL_14:
  if (a3->i64[0])
  {
    v10 = 0;
    while (a3->i64[++v10])
      ;
    v12 = v10;
    goto LABEL_19;
  }
LABEL_18:
  v12 = 0;
LABEL_19:
  if ((int)v6 < 2)
    return result;
  v13 = v6 - 1;
  do
  {
    if (v13 < 1)
      return result;
    v14 = 0;
    v15 = -(uint64_t)v13;
    v16 = 1;
    v17 = a2;
    v18 = a3;
    v13 = 0;
    do
    {
      v19 = v5[v14];
      v20 = v5[v16];
      if (*(_QWORD *)v19 == *(_QWORD *)v20)
      {
        result = (_QWORD *)memcmp(*(const void **)(v19 + 8), *(const void **)(v20 + 8), *(_QWORD *)v19);
        if ((int)result < 1)
          goto LABEL_34;
      }
      else if (*(_QWORD *)v19 < *(_QWORD *)v20)
      {
        goto LABEL_34;
      }
      *(int8x16_t *)&v5[v14] = vextq_s8(*(int8x16_t *)&v5[v14], *(int8x16_t *)&v5[v14], 8uLL);
      if (a2 && v16 < v21)
        *v17 = vextq_s8(*v17, *v17, 8uLL);
      if (a3)
      {
        if (v16 < v12)
          *v18 = vextq_s8(*v18, *v18, 8uLL);
      }
      v13 = v16;
LABEL_34:
      v18 = (int8x16_t *)((char *)v18 + 8);
      v17 = (int8x16_t *)((char *)v17 + 8);
      ++v16;
      ++v14;
    }
    while (v15 + v16 != 1);
  }
  while (v13);
  return result;
}

__CFDictionary *_create_mail_keychain_query(const __CFDictionary *a1)
{
  const __CFAllocator *v2;
  CFIndex Count;
  __CFDictionary *MutableCopy;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Count = CFDictionaryGetCount(a1);
  MutableCopy = CFDictionaryCreateMutableCopy(v2, Count, a1);
  CFDictionarySetValue(MutableCopy, CFSTR("sync"), CFSTR("syna"));
  return MutableCopy;
}

CFTypeRef CERT_FindItemInAllAvailableKeychains(const __CFDictionary *a1)
{
  const __CFDictionary *v2;
  CFTypeRef v3;
  BOOL v4;
  const __CFData *Value;
  const UInt8 *BytePtr;
  CFIndex Count;
  __CFDictionary *MutableCopy;
  CFTypeRef cf;
  CFTypeRef result;

  cf = 0;
  result = 0;
  if (SecItemCopyMatching(a1, &result) != -25300)
    return result;
  v2 = (const __CFDictionary *)_SecSecuritydCopyWhoAmI(&cf);
  v3 = cf;
  if (cf)
    v4 = 1;
  else
    v4 = v2 == 0;
  if (!v4)
  {
    if (CFDictionaryGetValue(v2, CFSTR("status")))
    {
      Value = (const __CFData *)CFDictionaryGetValue(v2, CFSTR("musr"));
      if (CFDictionaryGetValue(v2, CFSTR("system-keychain")))
      {
        if (Value && CFDataGetLength(Value) == 16)
        {
          BytePtr = CFDataGetBytePtr(Value);
          if (*(_QWORD *)BytePtr == 0x104B57A5353A5AA7 && *((_DWORD *)BytePtr + 2) == -1803342146)
          {
            Count = CFDictionaryGetCount(a1);
            MutableCopy = CFDictionaryCreateMutableCopy(0, Count + 1, a1);
            CFDictionaryAddValue(MutableCopy, CFSTR("u_SystemKeychain"), (const void *)*MEMORY[0x1E0C9AE50]);
            SecItemCopyMatching(MutableCopy, &result);
            if (MutableCopy)
              CFRelease(MutableCopy);
          }
        }
      }
    }
    goto LABEL_17;
  }
  if (v2)
  {
LABEL_17:
    CFRelease(v2);
    v3 = cf;
  }
  if (v3)
  {
    cf = 0;
    CFRelease(v3);
  }
  return result;
}

__CFBundle *___is_apple_mail_bundle_block_invoke()
{
  __CFBundle *result;
  const __CFString *v1;
  BOOL v2;

  result = CFBundleGetMainBundle();
  if (result)
  {
    result = (__CFBundle *)CFBundleGetIdentifier(result);
    if (result)
    {
      v1 = (const __CFString *)result;
      result = (__CFBundle *)CFStringHasPrefix((CFStringRef)result, CFSTR("com.apple.mail"));
      if ((_DWORD)result
        || (result = (__CFBundle *)CFStringHasPrefix(v1, CFSTR("com.apple.mobilemail")), (_DWORD)result))
      {
        v2 = 1;
      }
      else
      {
        result = (__CFBundle *)CFStringHasPrefix(v1, CFSTR("com.apple.email"));
        v2 = (_DWORD)result != 0;
      }
    }
    else
    {
      v2 = 0;
    }
    _is_apple_mail_bundle_result = v2;
  }
  return result;
}

const __CFArray *CERT_CertChainFromCert(void *a1, int a2, int a3)
{
  SecPolicyRef BasicX509;
  SecPolicyRef v7;
  CFArrayRef v8;
  const __CFArray *v9;
  SecTrustRef v10;
  const __CFArray *v12;
  uint64_t Count;
  _QWORD *ValueAtIndex;
  uint64_t v15;
  _BOOL4 IsSelfSigned;
  _BOOL4 v17;
  __CFArray *MutableCopy;
  FILE *v19;
  const char *CStringPtr;
  void *v21;
  int v22;
  SecTrustRef trust;
  void *values;

  trust = 0;
  BasicX509 = SecPolicyCreateBasicX509();
  if (!BasicX509)
    return 0;
  v7 = BasicX509;
  values = a1;
  if (a1)
    v8 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  else
    v8 = 0;
  if (!SecTrustCreateWithCertificates(v8, v7, &trust))
  {
    v22 = -1431655766;
    if (!SecTrustEvaluateInternal(trust, &v22))
    {
      v12 = SecTrustCopyCertificateChain(trust);
      v9 = v12;
      if (!v12)
        goto LABEL_9;
      Count = CFArrayGetCount(v12);
      ValueAtIndex = CFArrayGetValueAtIndex(v9, Count - 1);
      if (!ValueAtIndex)
        goto LABEL_9;
      v15 = (uint64_t)ValueAtIndex;
      if (!SecCertificateIsCertificate(ValueAtIndex))
        goto LABEL_9;
      IsSelfSigned = _SecCertificateIsSelfSigned(v15);
      if (IsSelfSigned)
      {
        if (a2)
          v17 = 0;
        else
          v17 = IsSelfSigned;
        if (Count >= 2 && v17)
        {
          MutableCopy = CFArrayCreateMutableCopy(0, Count, v9);
          CFArrayRemoveValueAtIndex(MutableCopy, Count - 1);
          CFRelease(v9);
          v9 = MutableCopy;
        }
        goto LABEL_9;
      }
      values = 0;
      SecCertificateCopyCommonName((SecCertificateRef)a1, (CFStringRef *)&values);
      v19 = (FILE *)*MEMORY[0x1E0C80C10];
      if (values)
        CStringPtr = CFStringGetCStringPtr((CFStringRef)values, 0x8000100u);
      else
        CStringPtr = (const char *)&unk_18AA61AAF;
      fprintf(v19, "Warning: unable to build chain to self-signed root for signer \"%s\"\n", CStringPtr);
      v21 = values;
      if (values)
      {
        values = 0;
        CFRelease(v21);
      }
      if (!a3)
        goto LABEL_9;
      CFRelease(v9);
    }
  }
  v9 = 0;
LABEL_9:
  v10 = trust;
  if (trust)
  {
    trust = 0;
    CFRelease(v10);
  }
  CFRelease(v7);
  if (v8)
    CFRelease(v8);
  return v9;
}

_QWORD *CERT_GetCertIssuerAndSN(uint64_t a1, const __CFData *a2)
{
  const __CFData *v2;
  __CFData *v4;
  const void *v5;
  CFIndex Length;
  const UInt8 *BytePtr;
  CFIndex v8;
  const UInt8 *v9;
  uint64_t v10;
  _QWORD *v11;
  void *v12;
  void *v13;
  _QWORD *ThreadErrInfo;
  int v16;

  v2 = a2;
  v4 = SecDERItemCopySequence((uint64_t)a2 + 152);
  if (v2)
  {
    v5 = (const void *)*((_QWORD *)v2 + 71);
    if (!v5)
    {
      v2 = 0;
      if (!v4)
        goto LABEL_13;
      goto LABEL_5;
    }
    CFRetain(v5);
    v2 = (const __CFData *)*((_QWORD *)v2 + 71);
  }
  if (!v4)
    goto LABEL_13;
LABEL_5:
  if ((CFDataGetLength(v4) & 0x8000000000000000) == 0 && v2)
  {
    if ((CFDataGetLength(v2) & 0x8000000000000000) == 0)
    {
      Length = CFDataGetLength(v2);
      BytePtr = CFDataGetBytePtr(v2);
      v8 = CFDataGetLength(v4);
      v9 = CFDataGetBytePtr(v4);
      v10 = PORT_ArenaAlloc(a1, 0x28uLL);
      if (v10)
      {
        v11 = (_QWORD *)v10;
        *(_QWORD *)(v10 + 32) = 0;
        *(_OWORD *)v10 = 0u;
        *(_OWORD *)(v10 + 16) = 0u;
        v12 = (void *)PORT_ArenaAlloc(a1, v8);
        v11[4] = v12;
        if (v12)
        {
          memcpy(v12, v9, v8);
          v11[3] = v8;
          v13 = (void *)PORT_ArenaAlloc(a1, Length);
          v11[2] = v13;
          if (v13)
          {
            memcpy(v13, BytePtr, Length);
            v11[1] = Length;
            CFRelease(v2);
            CFRelease(v4);
            return v11;
          }
        }
      }
    }
    goto LABEL_14;
  }
LABEL_13:
  if (v2)
LABEL_14:
    CFRelease(v2);
  if (v4)
    CFRelease(v4);
  ThreadErrInfo = PR_getThreadErrInfo(1, &v16);
  if (ThreadErrInfo)
    *ThreadErrInfo = 0xFFFFE02700000000;
  return 0;
}

CFTypeRef *CERT_FindByIssuerAndSN(const void *a1, const void *a2, uint64_t a3)
{
  CFIndex v4;
  const __CFAllocator *v7;
  CFDataRef v8;
  uint64_t v9;
  __CFData *NormalizedX501Name;
  __CFData *v11;
  CFTypeID v12;
  CFIndex Count;
  CFIndex v14;
  CFIndex i;
  CFTypeRef *ValueAtIndex;
  CFTypeRef *ItemInAllAvailableKeychains;
  CFTypeRef v18;
  CFTypeRef v19;
  CFTypeRef v20;
  int v21;
  void *v22;
  const __CFDictionary *v23;
  __CFDictionary *mail_keychain_query;
  unint64_t v26[3];
  _QWORD v27[2];
  void *values[4];
  void *keys[5];

  keys[4] = *(void **)MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a3 + 8);
  if (v4 < 0)
    return 0;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(const UInt8 **)(a3 + 16), v4, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v9 = *(_QWORD *)(a3 + 24);
  v27[0] = *(_QWORD *)(a3 + 32);
  v27[1] = v9;
  memset(v26, 170, sizeof(v26));
  if (DERDecodeItem((uint64_t)v27, v26)
    || (NormalizedX501Name = createNormalizedX501Name(v7, (uint64_t)&v26[1])) == 0)
  {
    ItemInAllAvailableKeychains = 0;
    if (!v8)
      return ItemInAllAvailableKeychains;
    goto LABEL_30;
  }
  v11 = NormalizedX501Name;
  if (a1)
  {
    v12 = CFGetTypeID(a1);
    if (v12 == CFArrayGetTypeID())
    {
      if (a2)
      {
        if (CFEqual(a2, CFSTR("cert")))
        {
          Count = CFArrayGetCount((CFArrayRef)a1);
          if (Count >= 1)
          {
            v14 = Count;
            for (i = 0; v14 != i; ++i)
            {
              ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex((CFArrayRef)a1, i);
              if (ValueAtIndex)
              {
                ItemInAllAvailableKeychains = ValueAtIndex;
                v18 = ValueAtIndex[72];
                if (v18)
                {
                  if (CFEqual(v18, v11))
                  {
                    v19 = ItemInAllAvailableKeychains[71];
                    if (v19)
                    {
                      CFRetain(v19);
                      v20 = ItemInAllAvailableKeychains[71];
                      if (v20)
                      {
                        if (v8)
                        {
                          v21 = CFEqual(ItemInAllAvailableKeychains[71], v8);
                          CFRelease(v20);
                          if (v21)
                          {
                            CFRetain(ItemInAllAvailableKeychains);
                            goto LABEL_29;
                          }
                        }
                        else
                        {
                          CFRelease(ItemInAllAvailableKeychains[71]);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  keys[0] = CFSTR("class");
  keys[1] = CFSTR("issr");
  keys[2] = CFSTR("slnr");
  keys[3] = CFSTR("r_Ref");
  values[0] = (void *)a2;
  values[1] = v11;
  v22 = (void *)*MEMORY[0x1E0C9AE50];
  values[2] = v8;
  values[3] = v22;
  v23 = CFDictionaryCreate(v7, (const void **)keys, (const void **)values, 4, 0, 0);
  if (_is_apple_mail_bundle_onceToken != -1)
    dispatch_once(&_is_apple_mail_bundle_onceToken, &__block_literal_global_4797);
  if (_is_apple_mail_bundle_result)
  {
    mail_keychain_query = _create_mail_keychain_query(v23);
    if (v23)
      CFRelease(v23);
  }
  else
  {
    mail_keychain_query = v23;
  }
  ItemInAllAvailableKeychains = (CFTypeRef *)CERT_FindItemInAllAvailableKeychains(mail_keychain_query);
  if (mail_keychain_query)
    CFRelease(mail_keychain_query);
LABEL_29:
  CFRelease(v11);
  if (v8)
LABEL_30:
    CFRelease(v8);
  return ItemInAllAvailableKeychains;
}

CFTypeRef CERT_FindBySubjectKeyID(const void *a1, const void *a2, CFIndex *a3)
{
  const UInt8 *v4;
  CFIndex v5;
  const __CFAllocator *v7;
  CFDataRef v8;
  CFTypeID v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex v12;
  const __CFData *ValueAtIndex;
  CFTypeRef ItemInAllAvailableKeychains;
  CFDataRef SubjectKeyID;
  const __CFDictionary *v16;
  __CFDictionary *mail_keychain_query;
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  if (!a3)
    return 0;
  v4 = (const UInt8 *)a3[1];
  if (!v4)
    return 0;
  v5 = *a3;
  if (v5 < 1)
    return 0;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4, v5, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (a1)
  {
    v9 = CFGetTypeID(a1);
    if (v9 == CFArrayGetTypeID())
    {
      if (a2)
      {
        if (CFEqual(a2, CFSTR("cert")))
        {
          Count = CFArrayGetCount((CFArrayRef)a1);
          if (Count >= 1)
          {
            v11 = Count;
            v12 = 0;
            while (1)
            {
              ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)a1, v12);
              if (ValueAtIndex)
              {
                ItemInAllAvailableKeychains = ValueAtIndex;
                SubjectKeyID = SecCertificateGetSubjectKeyID(ValueAtIndex);
                if (SubjectKeyID)
                {
                  if (v8 && CFEqual(SubjectKeyID, v8))
                    break;
                }
              }
              if (v11 == ++v12)
                goto LABEL_15;
            }
            CFRetain(ItemInAllAvailableKeychains);
            goto LABEL_26;
          }
        }
      }
    }
  }
LABEL_15:
  keys[0] = CFSTR("class");
  keys[1] = CFSTR("skid");
  keys[2] = CFSTR("r_Ref");
  values[0] = (void *)a2;
  values[1] = v8;
  values[2] = *(void **)MEMORY[0x1E0C9AE50];
  v16 = CFDictionaryCreate(v7, (const void **)keys, (const void **)values, 3, 0, 0);
  if (_is_apple_mail_bundle_onceToken != -1)
    dispatch_once(&_is_apple_mail_bundle_onceToken, &__block_literal_global_4797);
  if (_is_apple_mail_bundle_result)
  {
    mail_keychain_query = _create_mail_keychain_query(v16);
    if (v16)
      CFRelease(v16);
  }
  else
  {
    mail_keychain_query = v16;
  }
  ItemInAllAvailableKeychains = CERT_FindItemInAllAvailableKeychains(mail_keychain_query);
  if (mail_keychain_query)
    CFRelease(mail_keychain_query);
  if (v8)
LABEL_26:
    CFRelease(v8);
  return ItemInAllAvailableKeychains;
}

void SecCmsDecoderDestroy(uint64_t *a1)
{
  SecCmsMessageDestroy(a1[1]);
  a1[1] = 0;
  if (*a1)
    SEC_ASN1DecoderFinish(*a1);
  free(a1);
}

CFTypeID CMSDecoderGetTypeID(void)
{
  CFTypeID result;

  result = cmsDecoderTypeID;
  if (!cmsDecoderTypeID)
  {
    pthread_once(&CMSDecoderGetTypeID_once, (void (*)(void))cmsDecoderClassInitialize);
    return cmsDecoderTypeID;
  }
  return result;
}

uint64_t cmsDecoderClassInitialize()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  cmsDecoderTypeID = result;
  return result;
}

double cmsDecoderInit(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  return result;
}

void cmsDecoderFinalize(_QWORD *a1)
{
  uint64_t *v2;
  const void *v3;
  uint64_t v4;

  if (a1)
  {
    v2 = (uint64_t *)a1[3];
    if (v2)
    {
      SecCmsDecoderDestroy(v2);
      a1[5] = 0;
    }
    v3 = (const void *)a1[4];
    if (v3)
      CFRelease(v3);
    v4 = a1[5];
    if (v4)
    {
      SecCmsMessageDestroy(v4);
      a1[5] = 0;
    }
  }
}

OSStatus CMSDecoderCreate(CMSDecoderRef *cmsDecoderOut)
{
  uint64_t Instance;
  _CMSDecoder *v3;
  OSStatus result;

  if (!cmsDecoderTypeID)
    pthread_once(&CMSDecoderGetTypeID_once, (void (*)(void))cmsDecoderClassInitialize);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return -108;
  v3 = (_CMSDecoder *)Instance;
  result = 0;
  *((_DWORD *)v3 + 4) = 0;
  *cmsDecoderOut = v3;
  return result;
}

OSStatus CMSDecoderUpdateMessage(CMSDecoderRef cmsDecoder, const void *msgBytes, size_t msgBytesLen)
{
  int v4;
  uint64_t v7;
  unsigned int v8;

  if (!cmsDecoder || (v4 = *((_DWORD *)cmsDecoder + 4), v4 == 2))
  {
    LODWORD(v7) = -50;
  }
  else
  {
    if (v4 != 1)
    {
      if (v4)
      {
        LODWORD(v7) = -2070;
        return v7;
      }
      v7 = SecCmsDecoderCreate(0, 0, msgBytesLen, 0, 0, 0, (uint64_t **)cmsDecoder + 3);
      if ((_DWORD)v7)
      {
        v8 = 0;
LABEL_12:
        LODWORD(v7) = cmsRtnToOSStatusDefault(v7, v8);
        return v7;
      }
      *((_DWORD *)cmsDecoder + 4) = 1;
    }
    v7 = SecCmsDecoderUpdate(*((_QWORD *)cmsDecoder + 3), (char *)msgBytes, msgBytesLen);
    if ((_DWORD)v7)
    {
      v8 = -25257;
      goto LABEL_12;
    }
  }
  return v7;
}

OSStatus CMSDecoderFinalizeMessage(CMSDecoderRef cmsDecoder)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t ChildContentInfo;
  int v6;
  unsigned int v7;
  uint64_t v8;
  BOOL v9;
  unsigned int v10;
  uint64_t OID;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  _QWORD *v18;

  if (!cmsDecoder || *((_DWORD *)cmsDecoder + 4) != 1)
    return -50;
  v2 = (uint64_t *)((char *)cmsDecoder + 40);
  v3 = SecCmsDecoderFinish(*((uint64_t **)cmsDecoder + 3), (uint64_t *)cmsDecoder + 5);
  *((_DWORD *)cmsDecoder + 4) = 2;
  *((_QWORD *)cmsDecoder + 3) = 0;
  if ((_DWORD)v3)
    return cmsRtnToOSStatusDefault(v3, 0xFFFF9D57);
  *((_BYTE *)cmsDecoder + 48) = SecCmsMessageIsEncrypted(*((_QWORD *)cmsDecoder + 5));
  ChildContentInfo = *((_QWORD *)cmsDecoder + 5);
  if (ChildContentInfo)
  {
    v6 = -1;
    do
    {
      ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
      ++v6;
    }
    while (ChildContentInfo);
    v7 = 0;
    while (1)
    {
      v8 = *v2;
      if (*v2)
        v9 = v7 == 0;
      else
        v9 = 1;
      if (!v9)
      {
        v10 = 1;
        do
        {
          v8 = SecCmsContentInfoGetChildContentInfo(v8);
          if (!v8)
            break;
        }
        while (v10++ < v7);
      }
      OID = *(_QWORD *)(v8 + 32);
      if (!OID)
      {
        OID = SECOID_FindOID(v8);
        *(_QWORD *)(v8 + 32) = OID;
        if (!OID)
          goto LABEL_25;
      }
      if (*(_DWORD *)(OID + 16) != 26)
        goto LABEL_25;
      v13 = *(_QWORD *)(v8 + 16);
      *((_QWORD *)cmsDecoder + 7) = v13;
      if (v13)
        break;
LABEL_26:
      v9 = v7++ == v6;
      if (v9)
        return 0;
    }
    v14 = *(_QWORD *)(v13 + 32);
    if (!v14)
    {
      v14 = SECOID_FindOID(v13);
      *(_QWORD *)(v13 + 32) = v14;
    }
    *((_QWORD *)cmsDecoder + 9) = v14;
LABEL_25:
    v15 = *((_QWORD *)cmsDecoder + 7);
    if (v15)
      goto LABEL_30;
    goto LABEL_26;
  }
  v15 = *((_QWORD *)cmsDecoder + 7);
  if (v15)
  {
LABEL_30:
    v16 = *(uint64_t **)(v15 + 160);
    if (v16)
    {
      v17 = *v16;
      if (*v16)
      {
        v17 = 0;
        v18 = v16 + 1;
        while (v18[v17++])
          ;
        v17 = v17;
      }
    }
    else
    {
      v17 = 0;
    }
    *((_QWORD *)cmsDecoder + 8) = v17;
    if (*((_QWORD *)cmsDecoder + 4))
      return cmsDigestDetachedContent((uint64_t)cmsDecoder);
  }
  return 0;
}

uint64_t cmsDigestDetachedContent(uint64_t a1)
{
  const __CFData *v2;
  uint64_t *v3;
  uint64_t started;
  uint64_t v5;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v8;

  if (!*(_QWORD *)(a1 + 56))
    return 4294967246;
  v2 = *(const __CFData **)(a1 + 32);
  if (!v2 || CFDataGetLength(v2) < 0)
    return 4294967246;
  v3 = *(uint64_t **)(*(_QWORD *)(a1 + 56) + 136);
  if (!v3)
    return 4294942039;
  started = SecCmsDigestContextStartMultiple(v3);
  if (!started)
    return 4294967188;
  v5 = started;
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 32));
  Length = CFDataGetLength(*(CFDataRef *)(a1 + 32));
  SecCmsDigestContextUpdate(v5, BytePtr, Length);
  v8 = SecCmsSignedDataSetDigestContext(*(_QWORD **)(a1 + 56), v5);
  SecCmsDigestContextCancel(v5);
  if ((_DWORD)v8)
    return cmsRtnToOSStatusDefault(v8, 0);
  else
    return 0;
}

OSStatus CMSDecoderSetDetachedContent(CMSDecoderRef cmsDecoder, CFDataRef detachedContent)
{
  OSStatus result;

  result = -50;
  if (cmsDecoder && detachedContent)
  {
    *((_QWORD *)cmsDecoder + 4) = detachedContent;
    CFRetain(detachedContent);
    if (*((_QWORD *)cmsDecoder + 7))
      return cmsDigestDetachedContent((uint64_t)cmsDecoder);
    else
      return 0;
  }
  return result;
}

OSStatus CMSDecoderCopyDetachedContent(CMSDecoderRef cmsDecoder, CFDataRef *detachedContentOut)
{
  OSStatus result;
  const void *v5;
  const __CFData *v6;

  result = -50;
  if (cmsDecoder && detachedContentOut)
  {
    v5 = (const void *)*((_QWORD *)cmsDecoder + 4);
    if (v5)
    {
      CFRetain(v5);
      v6 = (const __CFData *)*((_QWORD *)cmsDecoder + 4);
    }
    else
    {
      v6 = 0;
    }
    result = 0;
    *detachedContentOut = v6;
  }
  return result;
}

OSStatus CMSDecoderGetNumSigners(CMSDecoderRef cmsDecoder, size_t *numSignersOut)
{
  OSStatus result;

  result = -50;
  if (cmsDecoder && numSignersOut && *((_DWORD *)cmsDecoder + 4) == 2)
  {
    result = 0;
    *numSignersOut = *((_QWORD *)cmsDecoder + 8);
  }
  return result;
}

OSStatus CMSDecoderCopySignerStatus(CMSDecoderRef cmsDecoder, size_t signerIndex, CFTypeRef policyOrArray, Boolean evaluateSecTrust, CMSSignerStatus *signerStatusOut, SecTrustRef *secTrustOut, OSStatus *certVerifyResultCodeOut)
{
  OSStatus v8;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  CFTypeRef v16;
  CMSSignerStatus v17;
  OSStatus v18;
  CMSSignerStatus v19;
  unsigned int v20;
  int v22;
  CFTypeRef cf;

  if (!cmsDecoder)
    return -50;
  v8 = -50;
  if (signerStatusOut && policyOrArray && *((_DWORD *)cmsDecoder + 4) == 2)
  {
    v12 = evaluateSecTrust;
    v13 = signerIndex;
    *signerStatusOut = kCMSSignerUnsigned;
    if (secTrustOut)
      *secTrustOut = 0;
    if (certVerifyResultCodeOut)
      *certVerifyResultCodeOut = 0;
    v14 = *((_QWORD *)cmsDecoder + 7);
    if (!v14)
    {
      v8 = 0;
      *signerStatusOut = kCMSSignerUnsigned;
      return v8;
    }
    if (*((_QWORD *)cmsDecoder + 8) <= signerIndex)
    {
      v8 = 0;
      v17 = kCMSSignerInvalidIndex;
    }
    else
    {
      if (*(_QWORD *)(v14 + 168))
      {
        cf = 0;
        v15 = SecCmsSignedDataVerifySignerInfo_internal(v14, signerIndex, policyOrArray, (SecTrustRef *)&cf);
        v22 = -1431655766;
        if (secTrustOut)
        {
          v16 = cf;
          *secTrustOut = (SecTrustRef)cf;
          if (v16)
            CFRetain(v16);
        }
        if (!*(_QWORD *)(*(_QWORD *)(*((_QWORD *)cmsDecoder + 7) + 160) + 8 * v13))
          goto LABEL_18;
        if (v12)
        {
          if (SecTrustEvaluateInternal((__SecTrust *)cf, &v22))
          {
LABEL_18:
            v8 = -2070;
LABEL_33:
            if (cf)
              CFRelease(cf);
            return v8;
          }
          v20 = v22 - 1;
          if ((v22 - 1) > 3)
          {
            v18 = -67843;
            v19 = kCMSSignerInvalidCert;
          }
          else
          {
            v19 = dword_18AA61B80[v20];
            v18 = dword_18AA61B90[v20];
          }
        }
        else
        {
          v18 = 0;
          v19 = kCMSSignerValid;
        }
        if (certVerifyResultCodeOut)
          *certVerifyResultCodeOut = v18;
        v8 = 0;
        if (v15)
          v19 = kCMSSignerInvalidSignature;
        *signerStatusOut = v19;
        goto LABEL_33;
      }
      v8 = 0;
      v17 = kCMSSignerNeedsDetachedContent;
    }
    *signerStatusOut = v17;
  }
  return v8;
}

OSStatus CMSDecoderCopySignerEmailAddress(CMSDecoderRef cmsDecoder, size_t signerIndex, CFStringRef *signerEmailAddressOut)
{
  OSStatus result;
  uint64_t v6;
  uint64_t v7;
  const __CFString *SignerEmailAddress;

  result = -50;
  if (cmsDecoder && signerEmailAddressOut)
  {
    v6 = *((_QWORD *)cmsDecoder + 7);
    if (v6 && *((_QWORD *)cmsDecoder + 8) > signerIndex && *((_DWORD *)cmsDecoder + 4) == 2)
    {
      v7 = *(_QWORD *)(*(_QWORD *)(v6 + 160) + 8 * (int)signerIndex);
      if (v7)
      {
        SignerEmailAddress = (const __CFString *)SecCmsSignerInfoGetSignerEmailAddress(v7);
        result = 0;
        *signerEmailAddressOut = SignerEmailAddress;
      }
      else
      {
        return -2070;
      }
    }
    else
    {
      return -50;
    }
  }
  return result;
}

OSStatus CMSDecoderCopySignerCert(CMSDecoderRef cmsDecoder, size_t signerIndex, SecCertificateRef *signerCertOut)
{
  OSStatus result;
  uint64_t v6;
  uint64_t v7;
  void *SigningCert_internal;

  result = -50;
  if (cmsDecoder && signerCertOut)
  {
    v6 = *((_QWORD *)cmsDecoder + 7);
    if (v6 && *((_QWORD *)cmsDecoder + 8) > signerIndex && *((_DWORD *)cmsDecoder + 4) == 2)
    {
      v7 = *(_QWORD *)(*(_QWORD *)(v6 + 160) + 8 * (int)signerIndex);
      if (v7
        && (SigningCert_internal = (void *)SecCmsSignerInfoGetSigningCert_internal(v7),
            (*signerCertOut = (SecCertificateRef)SigningCert_internal) != 0))
      {
        CFRetain(SigningCert_internal);
        return 0;
      }
      else
      {
        return -2070;
      }
    }
    else
    {
      return -50;
    }
  }
  return result;
}

OSStatus CMSDecoderIsContentEncrypted(CMSDecoderRef cmsDecoder, Boolean *isEncryptedOut)
{
  OSStatus result;

  result = -50;
  if (cmsDecoder && isEncryptedOut && *((_DWORD *)cmsDecoder + 4) == 2)
  {
    result = 0;
    *isEncryptedOut = *((_BYTE *)cmsDecoder + 48);
  }
  return result;
}

OSStatus CMSDecoderCopyEncapsulatedContentType(CMSDecoderRef cmsDecoder, CFDataRef *eContentTypeOut)
{
  OSStatus result;
  uint64_t v5;
  const __CFData *v6;

  result = -50;
  if (cmsDecoder && eContentTypeOut)
  {
    if (*((_DWORD *)cmsDecoder + 4) == 2)
    {
      if (!*((_QWORD *)cmsDecoder + 7))
      {
        v6 = 0;
        goto LABEL_9;
      }
      v5 = *((_QWORD *)cmsDecoder + 9);
      if ((*(_QWORD *)v5 & 0x8000000000000000) == 0)
      {
        v6 = CFDataCreate(0, *(const UInt8 **)(v5 + 8), *(_QWORD *)v5);
LABEL_9:
        result = 0;
        *eContentTypeOut = v6;
        return result;
      }
    }
    return -50;
  }
  return result;
}

OSStatus CMSDecoderCopyAllCerts(CMSDecoderRef cmsDecoder, CFArrayRef *certsOut)
{
  OSStatus result;
  uint64_t v5;
  uint64_t *v6;
  CFMutableArrayRef Mutable;
  uint64_t v8;
  uint64_t *v9;
  _QWORD *v10;
  const void *v11;
  uint64_t v12;

  result = -50;
  if (cmsDecoder && certsOut)
  {
    if (*((_DWORD *)cmsDecoder + 4) == 2)
    {
      v5 = *((_QWORD *)cmsDecoder + 7);
      if (v5 && (v6 = *(uint64_t **)(v5 + 144)) != 0 && *v6)
      {
        Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
        v8 = *v6;
        if (*v6)
        {
          v9 = v6 + 1;
          while ((*(_QWORD *)v8 & 0x8000000000000000) == 0)
          {
            v10 = SecCertificateCreateWithBytes(0, *(const void **)(v8 + 8), *(_QWORD *)v8);
            if (!v10)
            {
              if (Mutable)
                CFRelease(Mutable);
              return -26275;
            }
            v11 = v10;
            CFArrayAppendValue(Mutable, v10);
            CFRelease(v11);
            v12 = *v9++;
            v8 = v12;
            if (!v12)
              goto LABEL_12;
          }
          if (Mutable)
            CFRelease(Mutable);
          return -108;
        }
        else
        {
LABEL_12:
          result = 0;
          *certsOut = Mutable;
        }
      }
      else
      {
        result = 0;
        *certsOut = 0;
      }
    }
    else
    {
      return -50;
    }
  }
  return result;
}

OSStatus CMSDecoderCopyContent(CMSDecoderRef cmsDecoder, CFDataRef *contentOut)
{
  OSStatus result;
  uint64_t v5;
  uint64_t InnerContent;
  CFIndex v7;
  const __CFData *v8;

  result = -50;
  if (cmsDecoder && contentOut)
  {
    if (*((_DWORD *)cmsDecoder + 4) != 2)
      return -50;
    v5 = *((_QWORD *)cmsDecoder + 5);
    if (!v5)
      return -50;
    InnerContent = SecCmsContentInfoGetInnerContent(v5);
    if (InnerContent && (v7 = *(_QWORD *)InnerContent) != 0)
    {
      if (v7 < 0)
        return -108;
      v8 = CFDataCreate(0, *(const UInt8 **)(InnerContent + 8), v7);
    }
    else
    {
      v8 = 0;
    }
    result = 0;
    *contentOut = v8;
  }
  return result;
}

uint64_t CMSDecoderGetCmsMessage(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_QWORD *)(a1 + 40);
    }
  }
  return result;
}

uint64_t CMSDecoderSetDecoder(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v4;

  result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      v4 = *(_DWORD *)(a1 + 16);
      if ((v4 - 1) >= 2)
      {
        result = 0;
        if (!v4)
        {
          *(_QWORD *)(a1 + 24) = a2;
          *(_DWORD *)(a1 + 16) = 1;
        }
      }
    }
  }
  return result;
}

uint64_t CMSDecoderGetDecoder(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_QWORD *)(a1 + 24);
    }
  }
  return result;
}

OSStatus CMSDecoderCopySignerSigningTime(CMSDecoderRef cmsDecoder, size_t signerIndex, CFAbsoluteTime *signingTime)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t ChildContentInfo;
  double v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t OID;
  uint64_t v16;
  OSStatus result;
  uint64_t v18;

  if (!cmsDecoder)
    return -50;
  if (!signingTime)
    return -50;
  v4 = *((_QWORD *)cmsDecoder + 5);
  if (!v4)
    return -50;
  v5 = signerIndex;
  v6 = 0;
  ChildContentInfo = *((_QWORD *)cmsDecoder + 5);
  do
  {
    ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
    ++v6;
  }
  while (ChildContentInfo);
  v9 = 0;
  v10 = v6 <= 1 ? 1 : v6;
  while (1)
  {
    v11 = v4;
    if (v9)
    {
      v12 = 1;
      v11 = v4;
      do
      {
        v11 = SecCmsContentInfoGetChildContentInfo(v11);
        if (!v11)
          break;
      }
      while (v12++ < v9);
    }
    OID = *(_QWORD *)(v11 + 32);
    if (OID || (OID = SECOID_FindOID(v11), (*(_QWORD *)(v11 + 32) = OID) != 0))
    {
      if (*(_DWORD *)(OID + 16) == 26 && OID != 0)
      {
        v16 = *(_QWORD *)(v11 + 16);
        if (v16)
          break;
      }
    }
    if (++v9 == v10)
      return -50;
  }
  v18 = *(_QWORD *)(*(_QWORD *)(v16 + 160) + 8 * v5);
  if (!v18)
    return -50;
  SecCmsSignerInfoGetSigningTime(v18, signingTime, v8);
  return result;
}

uint64_t CMSDecoderCopySignerAppleCodesigningHashAgility(uint64_t a1, int a2, _QWORD *a3)
{
  CFTypeRef v5;
  uint64_t AppleCodesigningHashAgility;
  uint64_t v7;
  int v9;
  uint64_t ChildContentInfo;
  unsigned int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t OID;
  uint64_t v18;
  CFTypeRef cf;

  v5 = 0;
  cf = 0;
  AppleCodesigningHashAgility = 4294967246;
  if (a1 && a3)
  {
    v7 = *(_QWORD *)(a1 + 40);
    if (!v7)
      goto LABEL_30;
    v9 = 0;
    ChildContentInfo = *(_QWORD *)(a1 + 40);
    do
    {
      ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
      ++v9;
    }
    while (ChildContentInfo);
    v11 = 0;
    v12 = v9 <= 1 ? 1 : v9;
    while (1)
    {
      v13 = v7;
      if (v11)
      {
        v14 = 1;
        v13 = v7;
        do
        {
          v13 = SecCmsContentInfoGetChildContentInfo(v13);
          if (!v13)
            break;
        }
        while (v14++ < v11);
      }
      OID = *(_QWORD *)(v13 + 32);
      if (OID || (OID = SECOID_FindOID(v13), (*(_QWORD *)(v13 + 32) = OID) != 0))
      {
        if (*(_DWORD *)(OID + 16) == 26 && OID != 0)
        {
          v18 = *(_QWORD *)(v13 + 16);
          if (v18)
            break;
        }
      }
      if (++v11 == v12)
      {
        v5 = 0;
LABEL_23:
        AppleCodesigningHashAgility = 4294967246;
        goto LABEL_31;
      }
    }
    v5 = *(CFTypeRef *)(*(_QWORD *)(v18 + 160) + 8 * a2);
    if (!v5)
      goto LABEL_23;
    AppleCodesigningHashAgility = SecCmsSignerInfoGetAppleCodesigningHashAgility((uint64_t)v5, (CFDataRef *)&cf);
    if ((_DWORD)AppleCodesigningHashAgility || cf == 0)
    {
LABEL_30:
      v5 = 0;
    }
    else
    {
      v5 = CFRetain(cf);
      AppleCodesigningHashAgility = 0;
    }
  }
LABEL_31:
  *a3 = v5;
  return AppleCodesigningHashAgility;
}

uint64_t CMSDecoderCopySignerAppleCodesigningHashAgilityV2(uint64_t a1, int a2, _QWORD *a3)
{
  CFTypeRef v5;
  uint64_t AppleCodesigningHashAgilityV2;
  uint64_t v7;
  int v9;
  uint64_t ChildContentInfo;
  unsigned int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t OID;
  uint64_t v18;
  CFTypeRef cf;

  v5 = 0;
  cf = 0;
  AppleCodesigningHashAgilityV2 = 4294967246;
  if (a1 && a3)
  {
    v7 = *(_QWORD *)(a1 + 40);
    if (!v7)
      goto LABEL_30;
    v9 = 0;
    ChildContentInfo = *(_QWORD *)(a1 + 40);
    do
    {
      ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
      ++v9;
    }
    while (ChildContentInfo);
    v11 = 0;
    v12 = v9 <= 1 ? 1 : v9;
    while (1)
    {
      v13 = v7;
      if (v11)
      {
        v14 = 1;
        v13 = v7;
        do
        {
          v13 = SecCmsContentInfoGetChildContentInfo(v13);
          if (!v13)
            break;
        }
        while (v14++ < v11);
      }
      OID = *(_QWORD *)(v13 + 32);
      if (OID || (OID = SECOID_FindOID(v13), (*(_QWORD *)(v13 + 32) = OID) != 0))
      {
        if (*(_DWORD *)(OID + 16) == 26 && OID != 0)
        {
          v18 = *(_QWORD *)(v13 + 16);
          if (v18)
            break;
        }
      }
      if (++v11 == v12)
      {
        v5 = 0;
LABEL_23:
        AppleCodesigningHashAgilityV2 = 4294967246;
        goto LABEL_31;
      }
    }
    v5 = *(CFTypeRef *)(*(_QWORD *)(v18 + 160) + 8 * a2);
    if (!v5)
      goto LABEL_23;
    AppleCodesigningHashAgilityV2 = SecCmsSignerInfoGetAppleCodesigningHashAgilityV2((uint64_t)v5, (__CFDictionary **)&cf);
    if ((_DWORD)AppleCodesigningHashAgilityV2 || cf == 0)
    {
LABEL_30:
      v5 = 0;
    }
    else
    {
      v5 = CFRetain(cf);
      AppleCodesigningHashAgilityV2 = 0;
    }
  }
LABEL_31:
  *a3 = v5;
  return AppleCodesigningHashAgilityV2;
}

double CMSDecoderCopySignerAppleExpirationTime(uint64_t a1, int a2, double *a3, double result)
{
  uint64_t v5;
  int v7;
  uint64_t ChildContentInfo;
  unsigned int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t OID;
  uint64_t v16;
  uint64_t v17;

  if (a1)
  {
    if (a3)
    {
      v5 = *(_QWORD *)(a1 + 40);
      if (v5)
      {
        v7 = 0;
        ChildContentInfo = *(_QWORD *)(a1 + 40);
        do
        {
          ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
          ++v7;
        }
        while (ChildContentInfo);
        v9 = 0;
        if (v7 <= 1)
          v10 = 1;
        else
          v10 = v7;
        while (1)
        {
          v11 = v5;
          if (v9)
          {
            v12 = 1;
            v11 = v5;
            do
            {
              v11 = SecCmsContentInfoGetChildContentInfo(v11);
              if (!v11)
                break;
            }
            while (v12++ < v9);
          }
          OID = *(_QWORD *)(v11 + 32);
          if (OID || (OID = SECOID_FindOID(v11), (*(_QWORD *)(v11 + 32) = OID) != 0))
          {
            if (*(_DWORD *)(OID + 16) == 26 && OID != 0)
            {
              v16 = *(_QWORD *)(v11 + 16);
              if (v16)
                break;
            }
          }
          if (++v9 == v10)
            return result;
        }
        v17 = *(_QWORD *)(*(_QWORD *)(v16 + 160) + 8 * a2);
        if (v17)
          return SecCmsSignerInfoGetAppleExpirationTime(v17, a3, result);
      }
    }
  }
  return result;
}

uint64_t nss_cms_recipients_traverse(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  int v6;
  uint64_t v7;
  _DWORD *v8;
  unsigned int v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t *v15;

  v3 = *a1;
  if (*a1)
  {
    v5 = 0;
    v6 = 0;
    v7 = 0;
    while (1)
    {
      if (*(_DWORD *)v3 != 1)
      {
        if (!*(_DWORD *)v3)
        {
          if (a2)
          {
            v8 = PORT_ZAlloc(0x28uLL);
            if (!v8)
              return 0xFFFFFFFFLL;
            *v8 = v5;
            v8[1] = -1;
            v9 = *(_DWORD *)(v3 + 24);
            if (v9 <= 1)
            {
              v8[2] = v9;
              *((_QWORD *)v8 + 2) = *(_QWORD *)(v3 + 32);
            }
            *(_QWORD *)(a2 + 8 * v6++) = v8;
          }
          else
          {
            v7 = (v7 + 1);
          }
        }
        goto LABEL_25;
      }
      v10 = *(uint64_t **)(v3 + 128);
      if (v10)
      {
        v11 = *v10;
        if (*v10)
          break;
      }
LABEL_25:
      v3 = a1[++v5];
      if (!v3)
      {
        if (!a2)
          return v7;
        goto LABEL_29;
      }
    }
    v12 = 0;
    while (!a2)
    {
      v7 = (v7 + 1);
LABEL_22:
      v15 = &v10[v12++];
      v11 = v15[1];
      if (!v11)
        goto LABEL_25;
    }
    v13 = PORT_ZAlloc(0x28uLL);
    if (!v13)
      return 0xFFFFFFFFLL;
    *v13 = v5;
    v13[1] = v12;
    if (*(_DWORD *)v11 == 1)
    {
      v13[2] = 1;
      v14 = v11 + 8;
    }
    else
    {
      if (*(_DWORD *)v11)
      {
LABEL_21:
        *(_QWORD *)(a2 + 8 * v6++) = v13;
        v10 = *(uint64_t **)(v3 + 128);
        goto LABEL_22;
      }
      v13[2] = 0;
      v14 = *(_QWORD *)(v11 + 8);
    }
    *((_QWORD *)v13 + 2) = v14;
    goto LABEL_21;
  }
  v7 = 0;
  v6 = 0;
  if (a2)
  {
LABEL_29:
    v7 = 0;
    *(_QWORD *)(a2 + 8 * v6) = 0;
  }
  return v7;
}

void nss_cms_recipient_list_destroy(char *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  const void *v4;
  const void *v5;
  _QWORD *v6;

  v2 = *(_QWORD **)a1;
  if (*(_QWORD *)a1)
  {
    v3 = a1 + 8;
    do
    {
      v4 = (const void *)v2[3];
      if (v4)
      {
        v2[3] = 0;
        CFRelease(v4);
      }
      v5 = (const void *)v2[4];
      if (v5)
      {
        v2[4] = 0;
        CFRelease(v5);
      }
      free(v2);
      v6 = (_QWORD *)*v3++;
      v2 = v6;
    }
    while (v6);
  }
  free(a1);
}

uint64_t SecSMIMEFindBulkAlgForRecipients(__SecCertificate **a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __SecCertificate *v13;
  uint64_t v14;
  __SecCertificate **v15;
  uint64_t v16;
  SecKeyRef v17;
  SecKeyRef v18;
  unint64_t Size;
  int v20;
  unint64_t v21;
  int v22;
  uint64_t *v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v30;
  int v31;
  uint64_t result;

  v6 = PORT_NewArena(1024);
  v7 = 65545;
  if (v6)
  {
    v8 = v6;
    v9 = PORT_ArenaAlloc((uint64_t)v6, 0x24uLL);
    v10 = v9;
    if (v9)
    {
      *(_DWORD *)(v9 + 32) = 0;
      *(_OWORD *)v9 = 0u;
      *(_OWORD *)(v9 + 16) = 0u;
    }
    v11 = PORT_ArenaAlloc((uint64_t)v8, 0x24uLL);
    v7 = 65545;
    if (v11)
    {
      v12 = v11;
      *(_DWORD *)(v11 + 32) = 0;
      *(_OWORD *)v11 = 0u;
      *(_OWORD *)(v11 + 16) = 0u;
      v7 = 65545;
      if (v10)
      {
        v13 = *a1;
        if (*a1)
        {
          v14 = 0;
          v15 = a1 + 1;
          do
          {
            v16 = v14;
            v17 = SecCertificateCopyKey(v13);
            if (v17 && (v18 = v17, Size = SecKeyGetSize((uint64_t)v17, 0), CFRelease(v18), Size >= 0x201))
            {
              ++*(_DWORD *)(v10 + 16);
              *(_DWORD *)(v12 + 16) += 9;
              v20 = 8;
            }
            else
            {
              v20 = 9;
            }
            ++*(_DWORD *)(v10 + 4);
            *(_DWORD *)(v12 + 4) += v20;
            v14 = v16 + 1;
            v13 = v15[v16];
          }
          while (v13);
        }
        else
        {
          LODWORD(v14) = 0;
        }
        v21 = 0;
        v22 = 0;
        v7 = 65545;
        v23 = smime_cipher_map;
        do
        {
          if (*(_DWORD *)(v10 + 4 * v21) == (_DWORD)v14 && ((0xDuLL >> v21) & 1) == 0 && v21 >= 4 && *v23 != 65561)
          {
            v24 = *(_DWORD *)(v12 + 4 * v21);
            if (v24 >= v22)
              v7 = *v23;
            if (v24 > v22)
              v22 = *(_DWORD *)(v12 + 4 * v21);
          }
          ++v21;
          v23 += 4;
        }
        while (v21 != 9);
      }
    }
    PORT_FreeArena(v8, 0);
  }
  v25 = smime_keysize_by_cipher(v7);
  v26 = 0;
  if (v25 < 128)
    v27 = 65546;
  else
    v27 = v7;
  v28 = smime_cipher_map;
  while (1)
  {
    v29 = *v28;
    v28 += 4;
    if (v29 == v27)
      break;
    if (++v26 == 9)
      return 0xFFFFFFFFLL;
  }
  if ((v26 & 0x80000000) == 0)
  {
    v30 = &smime_cipher_map[4 * v26];
    *a2 = *((_DWORD *)v30 + 2);
    v31 = smime_keysize_by_cipher(*v30);
    result = 0;
    *a3 = v31;
    return result;
  }
  return 0xFFFFFFFFLL;
}

uint64_t smime_keysize_by_cipher(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = a1 - 65537;
  result = 40;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
    case 8:
      result = 64;
      break;
    case 2:
      result = 128;
      break;
    case 9:
      result = 192;
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

void *SecSMIMEGetCertFromEncryptionKeyPreference(int64_t **a1, uint64_t a2)
{
  _DWORD *v4;
  _QWORD *v5;
  void *v6;
  uint64_t v8;
  __CFArray *Mutable;
  int64_t v11;
  _QWORD *v12;
  const void *v13;
  void *v14;
  unint64_t v15;
  CFIndex *v16;

  v15 = 0xAAAAAAAAAAAAAAAALL;
  v16 = (CFIndex *)0xAAAAAAAAAAAAAAAALL;
  v4 = PORT_NewArena(1024);
  if (!v4)
    return 0;
  v5 = v4;
  if (SEC_ASN1Decode((uint64_t)v4, (uint64_t)&v15, (uint64_t)&smime_encryptionkeypref_template, *(char **)(a2 + 8), *(_QWORD *)a2))
  {
    PORT_FreeArena(v5, 0);
    return 0;
  }
  if (a1 && *a1)
  {
    v8 = 0;
    while (a1[++v8])
      ;
    Mutable = CFArrayCreateMutable(0, v8, MEMORY[0x1E0C9B378]);
    do
    {
      v11 = **a1;
      if ((v11 & 0x8000000000000000) == 0)
      {
        v12 = SecCertificateCreateWithBytes(0, (const void *)(*a1)[1], v11);
        if (v12)
        {
          v13 = v12;
          CFArrayAppendValue(Mutable, v12);
          CFRelease(v13);
        }
      }
      ++a1;
      --v8;
    }
    while (v8);
  }
  else
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  }
  if (!CFArrayGetCount(Mutable) && Mutable)
  {
    CFRelease(Mutable);
    Mutable = 0;
  }
  if ((_DWORD)v15 == 2 || (_DWORD)v15 == 1)
  {
    v14 = (void *)CERT_FindBySubjectKeyID(Mutable, CFSTR("cert"), v16);
    goto LABEL_25;
  }
  if (!(_DWORD)v15)
  {
    v14 = CERT_FindByIssuerAndSN(Mutable, CFSTR("cert"), (uint64_t)v16);
LABEL_25:
    v6 = v14;
    goto LABEL_27;
  }
  v6 = 0;
LABEL_27:
  PORT_FreeArena(v5, 0);
  if (Mutable)
    CFRelease(Mutable);
  return v6;
}

uint64_t SecCmsEncoderCreate(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _QWORD *a9)
{
  _QWORD *ThreadErrInfo;
  _BYTE *v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t OID;
  uint64_t Error;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  _QWORD *v26;
  int v27;
  char v28;
  char v29;

  ThreadErrInfo = PR_getThreadErrInfo(1, &v27);
  if (ThreadErrInfo)
    *ThreadErrInfo = 0;
  a1[17] = a6;
  a1[18] = a7;
  a1[19] = a8;
  v17 = PORT_ZAlloc(0x50uLL);
  if (!v17)
    return 4294967188;
  v18 = v17;
  *((_QWORD *)v17 + 5) = a2;
  v19 = (uint64_t)(v17 + 40);
  *((_QWORD *)v17 + 2) = a1;
  *((_QWORD *)v17 + 6) = a3;
  *((_QWORD *)v17 + 7) = a4;
  *((_DWORD *)v17 + 6) = 0;
  OID = a1[4];
  if (!OID)
  {
    OID = SECOID_FindOID((uint64_t)a1);
    a1[4] = OID;
    if (!OID)
    {
      Error = 4294967246;
LABEL_17:
      free(v18);
      return Error;
    }
  }
  Error = 4294967246;
  switch(*(_DWORD *)(OID + 16))
  {
    case 0x1A:
      v22 = SecCmsSignedDataEncodeBeforeStart(a1[2]);
      break;
    case 0x1B:
      v22 = SecCmsEnvelopedDataEncodeBeforeStart(a1[2]);
      break;
    case 0x1D:
      v22 = SecCmsDigestedDataEncodeBeforeStart((_QWORD *)a1[2]);
      break;
    case 0x1E:
      v22 = SecCmsEncryptedDataEncodeBeforeStart((_QWORD *)a1[2]);
      break;
    default:
      goto LABEL_17;
  }
  Error = v22;
  if ((_DWORD)v22)
    goto LABEL_17;
  v23 = SEC_ASN1EncoderStart((uint64_t)a1, (uint64_t)&SecCmsMessageTemplate, (uint64_t)nss_cms_encoder_out, v19);
  *(_QWORD *)v18 = v23;
  if (v23)
  {
    v18[8] = 0;
    *(_DWORD *)(v23 + 20) = 1;
    *(_QWORD *)(v23 + 32) = nss_cms_encoder_notify;
    *(_QWORD *)(v23 + 40) = v18;
    if (!SEC_ASN1EncoderUpdate(v23, 0, 0))
    {
      Error = 0;
      *a9 = v18;
      return Error;
    }
    Error = PORT_GetError();
    free(v18);
    v24 = (int *)&v29;
  }
  else
  {
    Error = PORT_GetError();
    free(v18);
    v24 = (int *)&v28;
  }
  v26 = PR_getThreadErrInfo(1, v24);
  if (v26)
    *v26 = 0;
  return Error;
}

void nss_cms_encoder_out(uint64_t a1, UInt8 *bytes, unint64_t length)
{
  __CFData *v6;

  if (*(_QWORD *)a1)
    (*(void (**)(_QWORD, UInt8 *, unint64_t))a1)(*(_QWORD *)(a1 + 8), bytes, length);
  if (length <= 0x7FFFFFFFFFFFFFFELL)
  {
    v6 = *(__CFData **)(a1 + 16);
    if (v6)
      CFDataAppendBytes(v6, bytes, length);
  }
}

void nss_cms_encoder_notify(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  int v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  const __CFData *v16;
  uint64_t v17;
  uint64_t OID;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  uint64_t *v24;
  uint64_t started;
  unsigned int v26;
  uint64_t v27;
  unsigned int v28;
  _BYTE *v29;
  _BYTE *v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  _QWORD *ThreadErrInfo;
  uint64_t v38;
  _QWORD *v39;
  _QWORD v40[3];

  v40[2] = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(_DWORD *)(a1 + 24);
  if (v7 > 0x1E)
    goto LABEL_26;
  if (((1 << v7) & 0x6C000000) == 0)
  {
    if (v7 == 25)
    {
      if (!a2 || v6 + 72 != a3)
        return;
      v17 = *(_QWORD *)(v6 + 16);
      if (!v17)
      {
        v36 = *(_QWORD *)a1;
        *(_DWORD *)(*(_QWORD *)a1 + 24) = 1;
LABEL_71:
        *(_QWORD *)(v36 + 32) = 0;
        *(_QWORD *)(v36 + 40) = 0;
        return;
      }
      nss_cms_encoder_work_data(a1, *(char **)(v17 + 8), *(_QWORD *)v17, 1, 1);
LABEL_70:
      v36 = *(_QWORD *)a1;
      goto LABEL_71;
    }
LABEL_26:
    if (!a2 && v6 == a3)
    {
      OID = *(_QWORD *)(a3 + 32);
      if (OID || (OID = SECOID_FindOID(a3), (*(_QWORD *)(a3 + 32) = OID) != 0))
        v19 = *(_DWORD *)(OID + 16);
      else
        v19 = 0;
      *(_DWORD *)(a1 + 24) = v19;
      *(_QWORD *)(a1 + 32) = *(_QWORD *)(a3 + 16);
    }
    return;
  }
  v8 = v7 > 0x1E;
  v9 = (1 << v7) & 0x6C000000;
  if (v8 || v9 == 0)
    v11 = 0;
  else
    v11 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 32))
    v12 = v11;
  else
    v12 = 0;
  v13 = *(_QWORD *)(v12 + 32);
  if (v13 || (v13 = SECOID_FindOID(v12), (*(_QWORD *)(v12 + 32) = v13) != 0))
  {
    v14 = *(_DWORD *)(v13 + 16);
    if (a2)
      goto LABEL_33;
  }
  else
  {
    v14 = 0;
    if (a2)
    {
LABEL_33:
      v20 = v12 + 72;
      if (a2 && v20 == a3)
      {
        if (v14 == 25 && (v21 = *(_QWORD *)(v12 + 16)) != 0)
          nss_cms_encoder_work_data(a1, *(char **)(v21 + 8), *(_QWORD *)v21, 1, 1);
        else
          *(_DWORD *)(*(_QWORD *)a1 + 24) = 1;
        return;
      }
      if (a2 || v20 != a3)
        return;
      switch(*(_DWORD *)(a1 + 24))
      {
        case 0x1A:
          v22 = SecCmsSignedDataEncodeAfterData(*(_QWORD *)(a1 + 32));
          goto LABEL_66;
        case 0x1B:
        case 0x1E:
          SecCmsEncryptedDataEncodeAfterData(*(_QWORD *)(a1 + 32));
          goto LABEL_70;
        case 0x1D:
          v22 = SecCmsDigestedDataEncodeAfterData(*(_QWORD **)(a1 + 32));
LABEL_66:
          if (v22)
            goto LABEL_67;
          goto LABEL_70;
        default:
LABEL_67:
          *(_DWORD *)(a1 + 64) = PORT_GetError();
          ThreadErrInfo = PR_getThreadErrInfo(1, (int *)v40);
          if (ThreadErrInfo)
            *ThreadErrInfo = 0;
          break;
      }
      goto LABEL_70;
    }
  }
  if (v12 != a3)
    goto LABEL_33;
  switch(*(_DWORD *)(a1 + 24))
  {
    case 0x1A:
      v23 = *(uint64_t **)(a1 + 32);
      v24 = (uint64_t *)v23[17];
      if (v24)
        goto LABEL_48;
      goto LABEL_50;
    case 0x1B:
    case 0x1E:
      v15 = *(_QWORD *)(a1 + 32);
      if (!v15)
        goto LABEL_82;
      v16 = *(const __CFData **)(v15 + 80);
      if (!v16)
        goto LABEL_82;
      CFRetain(*(CFTypeRef *)(v15 + 80));
      *(_QWORD *)(v15 + 96) = SecCmsCipherContextStart(*(_QWORD *)(*(_QWORD *)(v15 + 24) + 120), v16, v15 + 40, 1);
      CFRelease(v16);
      if (!*(_QWORD *)(v15 + 96))
        goto LABEL_82;
      goto LABEL_49;
    case 0x1D:
      v23 = *(uint64_t **)(a1 + 32);
      if (!v23[17])
        goto LABEL_53;
      if (!v23[21])
      {
        v40[0] = v23 + 17;
        v40[1] = 0;
        v24 = v40;
LABEL_48:
        started = SecCmsDigestContextStartMultiple(v24);
        v23[13] = started;
        if (!started)
          goto LABEL_82;
      }
LABEL_49:
      v23 = *(uint64_t **)(a1 + 32);
      if (v23)
      {
LABEL_50:
        v26 = *(_DWORD *)(a1 + 24);
        if (v26 > 0x1E || ((1 << v26) & 0x6C000000) == 0)
          v23 = 0;
      }
LABEL_53:
      v27 = v23[4];
      if (!v27)
      {
        v27 = SECOID_FindOID((uint64_t)v23);
        v23[4] = v27;
        if (!v27)
          goto LABEL_64;
      }
      v28 = *(_DWORD *)(v27 + 16);
      if (v28 > 0x1E)
        goto LABEL_64;
      if (((1 << v28) & 0x6C000000) != 0)
      {
        v29 = PORT_ZAlloc(0x50uLL);
        if (v29)
        {
          v30 = v29;
          *((_DWORD *)v29 + 6) = v28;
          v31 = v23[2];
          *((_QWORD *)v29 + 5) = nss_cms_encoder_update;
          v32 = (uint64_t)(v29 + 40);
          *((_QWORD *)v29 + 4) = v31;
          *((_QWORD *)v29 + 6) = a1;
          *((_QWORD *)v29 + 7) = 0;
          *((_QWORD *)v29 + 2) = *(_QWORD *)(a1 + 16);
          v33 = v28 - 26;
          if (v28 != 28)
          {
            v34 = (uint64_t)*(&off_1E1FD08A0 + v33);
            switch(v33)
            {
              case 0u:
                v35 = SecCmsSignedDataEncodeBeforeStart(v23[2]);
                goto LABEL_76;
              case 1u:
                v35 = SecCmsEnvelopedDataEncodeBeforeStart(v23[2]);
                goto LABEL_76;
              case 3u:
                v35 = SecCmsDigestedDataEncodeBeforeStart((_QWORD *)v23[2]);
                goto LABEL_76;
              case 4u:
                v35 = SecCmsEncryptedDataEncodeBeforeStart((_QWORD *)v23[2]);
LABEL_76:
                if (!v35)
                  goto LABEL_77;
                goto LABEL_79;
              default:
LABEL_77:
                v38 = SEC_ASN1EncoderStart(v23[2], v34, (uint64_t)nss_cms_encoder_out, v32);
                *(_QWORD *)v30 = v38;
                if (!v38)
                  goto LABEL_81;
                v30[8] = 0;
                *(_DWORD *)(v38 + 20) = 1;
                *(_QWORD *)(v38 + 32) = nss_cms_encoder_notify;
                *(_QWORD *)(v38 + 40) = v30;
                if (SEC_ASN1EncoderUpdate(v38, 0, 0))
                  goto LABEL_79;
                *(_QWORD *)(a1 + 72) = v30;
                break;
            }
            return;
          }
LABEL_79:
          if (*(_QWORD *)v30)
            PORT_FreeArena(**(_QWORD ***)v30, 0);
LABEL_81:
          free(v30);
        }
LABEL_82:
        *(_DWORD *)(a1 + 64) = PORT_GetError();
        v39 = PR_getThreadErrInfo(1, (int *)v40);
        if (v39)
          *v39 = 0;
        return;
      }
      if (v28 == 25)
        *(_QWORD *)(a1 + 72) = 0;
      else
LABEL_64:
        *(_DWORD *)(a1 + 64) = -8183;
      break;
    default:
      goto LABEL_82;
  }
}

uint64_t nss_cms_encoder_work_data(uint64_t a1, char *dataIn, size_t dataInLength, int a4, int a5)
{
  size_t v7;
  char *v8;
  unsigned int v10;
  BOOL v11;
  int v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  size_t v20;
  char *v21;
  char *v22;
  uint64_t v23;
  unsigned int v25;

  v7 = dataInLength;
  v8 = dataIn;
  if (*(_QWORD *)(a1 + 32))
  {
    v10 = *(_DWORD *)(a1 + 24);
    v11 = v10 > 0x1E;
    v12 = (1 << v10) & 0x6C000000;
    if (v11 || v12 == 0)
      v14 = 0;
    else
      v14 = *(_QWORD *)(a1 + 32);
    if (!dataInLength)
      goto LABEL_13;
  }
  else
  {
    v14 = 0;
    if (!dataInLength)
      goto LABEL_13;
  }
  v15 = *(_QWORD *)(v14 + 104);
  if (v15)
    SecCmsDigestContextUpdate(v15, dataIn, dataInLength);
LABEL_13:
  v16 = *(_QWORD *)(v14 + 96);
  if (!v16)
  {
    v22 = 0;
    goto LABEL_22;
  }
  v25 = 0;
  v17 = *(_DWORD *)(v16 + 12);
  if (a4)
    v18 = *(_DWORD *)(v16 + 12);
  else
    v18 = 0;
  v19 = (v7 + v17 - 1) / v17;
  v20 = v18 + v19 * v17;
  if (!(_DWORD)v20)
    return SecCmsCipherContextCrypt((CCCryptorRef *)v16, 0, 0, 0, v8, v7, a4);
  v21 = (char *)PORT_Alloc(v18 + v19 * v17);
  if (!v21)
    return 0xFFFFFFFFLL;
  v22 = v21;
  v23 = SecCmsCipherContextCrypt(*(CCCryptorRef **)(v14 + 96), v21, &v25, v20, v8, v7, a4);
  if (!(_DWORD)v23)
  {
    v7 = v25;
    v8 = v22;
LABEL_22:
    v23 = 0;
    if (*(_QWORD *)a1 && v7)
    {
      if (a5 && !*(_QWORD *)(v14 + 72))
      {
        v23 = 0;
        if (!v22)
          return v23;
LABEL_28:
        if (*(_QWORD *)(v14 + 96))
          free(v22);
        return v23;
      }
      v23 = SEC_ASN1EncoderUpdate(*(_QWORD *)a1, (uint64_t)v8, v7);
    }
    if (!v22)
      return v23;
    goto LABEL_28;
  }
  return v23;
}

uint64_t nss_cms_encoder_update(uint64_t a1, char *a2, size_t a3)
{
  return nss_cms_encoder_work_data(a1, a2, a3, 0, 0);
}

uint64_t SecCmsEncoderUpdate(uint64_t a1, char *dataIn, size_t dataInLength)
{
  uint64_t v5;
  uint64_t Error;
  unsigned int v7;
  BOOL v8;
  int v9;
  uint64_t v11;
  uint64_t OID;
  _QWORD *ThreadErrInfo;
  int v15;

  if ((dataInLength & 0x8000000000000000) == 0)
  {
    while (a1)
    {
      v5 = a1;
      Error = *(unsigned int *)(a1 + 64);
      if ((_DWORD)Error)
        return Error;
      a1 = *(_QWORD *)(a1 + 72);
      if (!a1)
      {
        if (*(_QWORD *)(v5 + 32))
        {
          v7 = *(_DWORD *)(v5 + 24);
          v8 = v7 > 0x1E;
          v9 = (1 << v7) & 0x6C000000;
          if (v8 || v9 == 0)
            v11 = 0;
          else
            v11 = *(_QWORD *)(v5 + 32);
        }
        else
        {
          v11 = 0;
        }
        OID = *(_QWORD *)(v11 + 32);
        if (OID || (OID = SECOID_FindOID(v11), (*(_QWORD *)(v11 + 32) = OID) != 0))
        {
          if (*(_DWORD *)(OID + 16) == 25 && !*(_QWORD *)(v11 + 16))
          {
            if (!nss_cms_encoder_work_data(v5, dataIn, dataInLength, 0, 1))
              return 0;
            Error = PORT_GetError();
            ThreadErrInfo = PR_getThreadErrInfo(1, &v15);
            if (ThreadErrInfo)
              *ThreadErrInfo = 0;
            return Error;
          }
        }
        return 4294967246;
      }
    }
  }
  return 4294967246;
}

void SecCmsEncoderDestroy(uint64_t *a1)
{
  _BOOL4 v2;
  uint64_t v3;

  if (a1[9])
  {
    SecCmsEncoderDestroy();
    v2 = a1[9] == 0;
  }
  else
  {
    v2 = 1;
  }
  if (!nss_cms_encoder_work_data((uint64_t)a1, 0, 0, 1, v2))
  {
    a1[9] = 0;
    v3 = *a1;
    if (*(_DWORD *)(*a1 + 24))
    {
      *(_DWORD *)(v3 + 24) = 0;
      if (*(_DWORD *)(v3 + 16) == 3)
      {
        *(_DWORD *)(v3 + 16) = 2;
        *(_DWORD *)(*(_QWORD *)(v3 + 8) + 40) = 4;
      }
    }
    *(_DWORD *)(v3 + 20) = 0;
    SEC_ASN1EncoderUpdate(v3, 0, 0);
  }
  PORT_FreeArena(*(_QWORD **)*a1, 0);
  free(a1);
}

uint64_t SecCmsEncoderFinish(_DWORD *a1)
{
  uint64_t Error;
  _BOOL4 v3;
  unsigned int v4;
  BOOL v5;
  int v6;
  uint64_t v8;
  uint64_t OID;
  unsigned int v10;
  BOOL v11;
  _QWORD *ThreadErrInfo;
  uint64_t v14;
  int v15;

  if (*((_QWORD *)a1 + 9))
  {
    Error = SecCmsEncoderFinish();
    if ((_DWORD)Error)
      goto LABEL_26;
    v3 = *((_QWORD *)a1 + 9) == 0;
  }
  else
  {
    v3 = 1;
  }
  if (nss_cms_encoder_work_data((uint64_t)a1, 0, 0, 1, v3))
  {
    Error = PORT_GetError();
  }
  else
  {
    *((_QWORD *)a1 + 9) = 0;
    if (*((_QWORD *)a1 + 4))
    {
      v4 = a1[6];
      v5 = v4 > 0x1E;
      v6 = (1 << v4) & 0x6C000000;
      if (v5 || v6 == 0)
        v8 = 0;
      else
        v8 = *((_QWORD *)a1 + 4);
    }
    else
    {
      v8 = 0;
    }
    OID = *(_QWORD *)(v8 + 32);
    if (OID || (OID = SECOID_FindOID(v8), (*(_QWORD *)(v8 + 32) = OID) != 0))
    {
      if (*(_DWORD *)(OID + 16) == 25 && !*(_QWORD *)(v8 + 16))
      {
        v14 = *(_QWORD *)a1;
        if (*(_DWORD *)(*(_QWORD *)a1 + 24))
        {
          *(_DWORD *)(v14 + 24) = 0;
          if (*(_DWORD *)(v14 + 16) == 3)
          {
            *(_DWORD *)(v14 + 16) = 2;
            *(_DWORD *)(*(_QWORD *)(v14 + 8) + 40) = 4;
          }
        }
        LODWORD(OID) = SEC_ASN1EncoderUpdate(v14, 0, 0);
        if ((_DWORD)OID)
          LODWORD(OID) = PORT_GetError();
      }
      else
      {
        LODWORD(OID) = 0;
      }
    }
    *(_DWORD *)(*(_QWORD *)a1 + 20) = 0;
    v10 = a1[16];
    if ((_DWORD)OID)
      v11 = 1;
    else
      v11 = v10 == 0;
    if (v11)
      Error = OID;
    else
      Error = v10;
  }
LABEL_26:
  PORT_FreeArena(**(_QWORD ***)a1, 0);
  free(a1);
  ThreadErrInfo = PR_getThreadErrInfo(1, &v15);
  if (ThreadErrInfo)
    *ThreadErrInfo = 0;
  return Error;
}

uint64_t SecCmsMessageEncode(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t *v7;
  uint64_t v8;
  int v10[2];

  *(_QWORD *)v10 = 0;
  v5 = 4294967246;
  if (!a1 || !a3)
    return v5;
  if (a2)
  {
    if ((*(_QWORD *)a2 & 0x8000000000000000) != 0)
      return v5;
    v5 = SecCmsEncoderCreate(a1, 0, 0, a3, a5, 0, 0, 0, v10);
    if ((_DWORD)v5)
      return v5;
    v7 = *(uint64_t **)v10;
    v8 = SecCmsEncoderUpdate(*(uint64_t *)v10, *(char **)(a2 + 8), *(_QWORD *)a2);
    if ((_DWORD)v8)
    {
      v5 = v8;
      SecCmsEncoderDestroy(v7);
      return v5;
    }
  }
  else
  {
    v5 = SecCmsEncoderCreate(a1, 0, 0, a3, a5, 0, 0, 0, v10);
    if ((_DWORD)v5)
      return v5;
    v7 = *(uint64_t **)v10;
  }
  return SecCmsEncoderFinish(v7);
}

uint64_t SecCmsArraySortByDER(int8x16_t *a1, uint64_t a2, int8x16_t *a3)
{
  uint64_t v6;
  _DWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;

  if (!a1)
    return 0;
  if (!a1->i64[0])
    return 0;
  v6 = 0;
  while (a1->i64[++v6])
    ;
  if ((_DWORD)v6 == 1)
    return 0;
  v8 = PORT_NewArena(1024);
  if (!v8)
    return 0xFFFFFFFFLL;
  v9 = v8;
  if ((v6 - 1) <= 0xFFFFFFC)
  {
    v10 = 8 * (unint64_t)(v6 + 1) <= 1 ? 1 : 8 * (v6 + 1);
    v11 = (_QWORD *)PORT_ArenaAlloc((uint64_t)v8, v10);
    if (v11)
    {
      v12 = v11;
      bzero(v11, v10);
      v13 = 0;
      v14 = v6;
      while (1)
      {
        v15 = SEC_ASN1EncodeItem((uint64_t)v9, 0, a1->i64[v13], a2);
        v12[v13] = v15;
        if (!v15)
          break;
        ++v13;
        if (!--v6)
        {
          v12[v14] = 0;
          SecCmsArraySort(v12, a1, a3);
          v16 = 0;
          goto LABEL_19;
        }
      }
    }
  }
  v16 = 0xFFFFFFFFLL;
LABEL_19:
  PORT_FreeArena(v9, 0);
  return v16;
}

const char *SecCmsUtilVerificationStatusToString(unsigned int a1)
{
  if (a1 > 9)
    return "Unknown";
  else
    return off_1E1FD08C8[a1];
}

uint64_t SecCmsDigestedDataCreate(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *(_QWORD *)(a1 + 120);
  v5 = PORT_ArenaAlloc(v4, 0xC8uLL);
  if (!v5)
    return 0;
  v6 = v5;
  *(_QWORD *)(v5 + 192) = 0;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 176) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_QWORD *)(v5 + 24) = a1;
  if (SECOID_CopyAlgorithmID(v4, (unint64_t *)(v5 + 136), a2))
    return 0;
  return v6;
}

void SecCmsDigestedDataDestroy(uint64_t *a1)
{
  if (a1)
    SecCmsContentInfoDestroy(a1);
}

uint64_t SecCmsDigestedDataEncodeBeforeStart(_QWORD *a1)
{
  uint64_t OID;
  unint64_t v3;

  OID = a1[4];
  if (OID || (OID = SECOID_FindOID((uint64_t)a1), (a1[4] = OID) != 0))
    v3 = 2 * (*(_DWORD *)(OID + 16) != 25);
  else
    v3 = 2;
  if (SEC_ASN1EncodeInteger(*(_QWORD *)(a1[3] + 120), a1 + 15, v3))
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t SecCmsDigestedDataEncodeAfterData(_QWORD *a1)
{
  uint64_t result;
  __int128 v3;
  uint64_t v4;
  __int128 **v5;

  result = a1[13];
  if (result)
  {
    v5 = (__int128 **)0xAAAAAAAAAAAAAAAALL;
    if (SecCmsDigestContextFinishMultiple(result, &v4, &v5)
      || (v3 = **v5, SECITEM_CopyItem(*(_QWORD *)(a1[3] + 120), a1 + 21, (uint64_t)&v3)))
    {
      result = 0xFFFFFFFFLL;
    }
    else
    {
      SecCmsDigestContextCancel(a1[13]);
      result = 0;
    }
    a1[13] = 0;
  }
  return result;
}

uint64_t SecCmsMessageCopy(uint64_t result)
{
  if (result)
    ++*(_DWORD *)(result + 128);
  return result;
}

uint64_t SecCmsMessageContentLevelCount(uint64_t ChildContentInfo)
{
  uint64_t i;

  for (i = 0; ChildContentInfo; ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo))
    i = (i + 1);
  return i;
}

uint64_t SecCmsMessageContentLevel(uint64_t result, int a2)
{
  int v3;

  if (result && a2 >= 1)
  {
    v3 = 1;
    do
    {
      result = SecCmsContentInfoGetChildContentInfo(result);
      if (!result)
        break;
    }
    while (v3++ < a2);
  }
  return result;
}

uint64_t SecCmsMessageContainsCertsOrCrls(uint64_t result)
{
  uint64_t v1;
  uint64_t OID;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;

  if (result)
  {
    v1 = result;
    while (1)
    {
      OID = *(_QWORD *)(v1 + 32);
      if (OID || (OID = SECOID_FindOID(v1), (*(_QWORD *)(v1 + 32) = OID) != 0))
      {
        if (*(_DWORD *)(OID + 16) == 26)
        {
          v3 = *(_QWORD *)(v1 + 16);
          v4 = *(_QWORD **)(v3 + 144);
          if (v4)
          {
            if (*v4)
              break;
          }
          v5 = *(_QWORD **)(v3 + 152);
          if (v5)
          {
            if (*v5)
              break;
          }
        }
      }
      result = SecCmsContentInfoGetChildContentInfo(v1);
      v1 = result;
      if (!result)
        return result;
    }
    return 1;
  }
  return result;
}

uint64_t SecCmsMessageIsEncrypted(uint64_t result)
{
  uint64_t v1;
  uint64_t OID;
  int v3;

  if (result)
  {
    v1 = result;
    while (1)
    {
      OID = *(_QWORD *)(v1 + 32);
      if (OID || (OID = SECOID_FindOID(v1), (*(_QWORD *)(v1 + 32) = OID) != 0))
      {
        v3 = *(_DWORD *)(OID + 16);
        if (v3 == 27 || v3 == 30)
          break;
      }
      result = SecCmsContentInfoGetChildContentInfo(v1);
      v1 = result;
      if (!result)
        return result;
    }
    return 1;
  }
  return result;
}

uint64_t SecCmsMessageIsSigned(uint64_t result)
{
  uint64_t v1;
  uint64_t OID;
  _QWORD *v3;

  if (result)
  {
    v1 = result;
    while (1)
    {
      OID = *(_QWORD *)(v1 + 32);
      if (OID || (OID = SECOID_FindOID(v1), (*(_QWORD *)(v1 + 32) = OID) != 0))
      {
        if (*(_DWORD *)(OID + 16) == 26)
        {
          v3 = *(_QWORD **)(*(_QWORD *)(v1 + 16) + 160);
          if (v3)
          {
            if (*v3)
              break;
          }
        }
      }
      result = SecCmsContentInfoGetChildContentInfo(v1);
      v1 = result;
      if (!result)
        return result;
    }
    return 1;
  }
  return result;
}

BOOL SecCmsMessageIsContentEmpty(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  unsigned int v4;
  _BOOL8 result;
  BOOL v6;
  int v7;
  BOOL v8;
  _QWORD *v9;

  if (!a1)
    return 1;
  v3 = *(_QWORD *)(a1 + 32);
  if (!v3)
    return 1;
  v4 = *(_DWORD *)(v3 + 16);
  result = 1;
  v6 = v4 >= 0x1E;
  v8 = v4 == 30;
  v7 = (1 << v4) & 0x6E000000;
  v8 = !v8 && v6 || v7 == 0;
  if (!v8)
  {
    v9 = *(_QWORD **)(a1 + 16);
    if (v9)
      return *v9 <= (unint64_t)a2;
  }
  return result;
}

uint64_t SECOID_SetAlgorithmID(uint64_t a1, unint64_t *a2, unsigned int a3, uint64_t a4)
{
  _QWORD *ThreadErrInfo;
  _BYTE *v10;
  int v11;

  pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
  if (a3 >= 0xD9)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v11);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0xFFFFE00600000000;
    return 0xFFFFFFFFLL;
  }
  if (SECITEM_CopyItem(a1, a2, (uint64_t)&oids[40 * a3]))
    return 0xFFFFFFFFLL;
  if (a3 <= 0x14 && ((1 << a3) & 0x1F001E) != 0 || a3 - 192 < 6)
  {
    if (!a4)
    {
      SECITEM_AllocItem(a1, a2 + 2, 2uLL);
      v10 = (_BYTE *)a2[3];
      if (!v10)
        return 0xFFFFFFFFLL;
      *v10 = 5;
      *(_BYTE *)(a2[3] + 1) = 0;
      return 0;
    }
  }
  else if (!a4)
  {
    return 0;
  }
  if (SECITEM_CopyItem(a1, a2 + 2, a4))
    return 0xFFFFFFFFLL;
  return 0;
}

uint64_t SECOID_CopyAlgorithmID(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  if (SECITEM_CopyItem(a1, a2, a3))
    return 0xFFFFFFFFLL;
  else
    return SECITEM_CopyItem(a1, a2 + 2, a3 + 16);
}

uint64_t SecCmsEnvelopedDataCreate(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result;
  uint64_t v7;
  int v8;

  result = PORT_ArenaAlloc(*(_QWORD *)(a1 + 120), 0xA0uLL);
  if (result)
  {
    v7 = result;
    *(_OWORD *)(result + 128) = 0u;
    *(_OWORD *)(result + 144) = 0u;
    *(_OWORD *)(result + 96) = 0u;
    *(_OWORD *)(result + 112) = 0u;
    *(_OWORD *)(result + 64) = 0u;
    *(_OWORD *)(result + 80) = 0u;
    *(_OWORD *)(result + 32) = 0u;
    *(_OWORD *)(result + 48) = 0u;
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    *(_QWORD *)(result + 24) = a1;
    v8 = SECOID_SetAlgorithmID(*(_QWORD *)(a1 + 120), (unint64_t *)(result + 40), a2, 0);
    result = 0;
    if (!v8)
    {
      *(_DWORD *)(v7 + 88) = a3;
      return v7;
    }
  }
  return result;
}

uint64_t SecCmsEnvelopedDataDestroy(uint64_t result)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  const void *v5;
  const void *v6;
  uint64_t v7;

  if (result)
  {
    v1 = result;
    v2 = *(uint64_t **)(result + 144);
    if (v2)
    {
      v3 = *v2;
      if (*v2)
      {
        v4 = v2 + 1;
        do
        {
          v5 = *(const void **)(v3 + 144);
          if (v5)
            CFRelease(v5);
          if (!*(_DWORD *)v3 && *(_DWORD *)(v3 + 24) == 1)
          {
            v6 = *(const void **)(v3 + 96);
            if (v6)
              CFRelease(v6);
          }
          v7 = *v4++;
          v3 = v7;
        }
        while (v7);
      }
      return SecCmsContentInfoDestroy(v1);
    }
  }
  return result;
}

uint64_t SecCmsEnvelopedDataEncodeBeforeStart(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v3;
  unint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  _QWORD *ThreadErrInfo;
  const UInt8 *v9;
  const UInt8 *v10;
  CFDataRef v11;
  CFDataRef v12;
  uint64_t v13;
  uint64_t *v14;
  __SecCertificate *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t OID;
  int v20;
  uint64_t v21;
  __int128 v22;
  _QWORD *v23;
  __SecKey *v24;
  const __CFDictionary *v25;
  const __CFDictionary *v26;
  void *Value;
  void *v28;
  const __CFDictionary *v29;
  int v30;
  CFDataRef v31;
  void *v32;
  int v33;
  const __CFData *v34;
  SecKeyRef v35;
  SecKeyRef v36;
  unint64_t Size;
  uint64_t v38;
  const uint8_t *v39;
  CFIndex v40;
  __SecKey *v41;
  __SecKey *v42;
  SecKeyRef v43;
  SecKeyRef v44;
  CFTypeRef v45;
  void *v46;
  void *v47;
  uint64_t v48;
  CFNumberRef v49;
  const __CFData *v50;
  const UInt8 *BytePtr;
  CFIndex v52;
  CCCryptorStatus v53;
  _CCCryptor *v54;
  CFIndex v55;
  size_t OutputLength;
  const UInt8 *v57;
  CFIndex v58;
  const __CFData *v59;
  CFIndex v60;
  void *v61;
  void *v62;
  const UInt8 *v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  _QWORD *v68;
  unint64_t v69;
  _CCCryptor *v70;
  const __CFDictionary *v71;
  const __CFDictionary *v72;
  __SecKey *cf;
  _QWORD *v74;
  const __CFData *theData;
  const __CFDictionary *v76;
  CFNumberRef v77;
  _QWORD v78[2];
  __int16 v79;
  _QWORD v80[4];
  size_t v81;
  size_t dataOutMoved;
  int valuePtr;
  CCCryptorRef cryptorRef;
  CFTypeRef v85;
  int v86;
  __int16 v87;
  CFIndex length;
  UInt8 *bytes;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  _QWORD v96[2];
  SecKeyRef privateKey;
  SecKeyRef publicKey;
  void *v99[2];
  void *v100[2];
  void *values[2];
  void *keys[2];
  _QWORD iv[4];

  iv[1] = *MEMORY[0x1E0C80C00];
  v1 = *(uint64_t **)(a1 + 144);
  if (!v1)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, (int *)&v90);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0xFFFFE00200000000;
    return 0xFFFFFFFFLL;
  }
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 120);
  if (*(_QWORD *)(a1 + 136) || *(_QWORD *)(a1 + 152))
  {
    v4 = 2;
  }
  else
  {
    v64 = *v1;
    if (*v1)
    {
      v65 = v1 + 1;
      v4 = 2;
      while (1)
      {
        if (*(_DWORD *)v64 <= 2u)
        {
          *(_QWORD *)&v90 = 0xAAAAAAAAAAAAAAAALL;
          if (!SEC_ASN1DecodeInteger((uint64_t *)(v64 + 8), (uint64_t *)&v90))
          {
            if ((_DWORD)v90)
              break;
          }
        }
        v66 = *v65++;
        v64 = v66;
        if (!v66)
          goto LABEL_105;
      }
    }
    else
    {
LABEL_105:
      v4 = 0;
    }
  }
  if (!SEC_ASN1EncodeInteger(v3, (_QWORD *)(a1 + 120), v4))
    return 0xFFFFFFFFLL;
  if (SecCmsContentInfoGetContentEncAlgTag(a1))
  {
    v5 = *(_DWORD *)(a1 + 88);
    v6 = v5 + 7;
    if (v5 < -7)
      v6 = v5 + 14;
    if (v5 < -14)
      return 0xFFFFFFFFLL;
    v7 = (uint64_t)v6 >> 3;
  }
  else
  {
    if (SECOID_SetAlgorithmID(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 120), (unint64_t *)(a1 + 40), 7u, 0))return 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 88) = 192;
    v7 = 24;
  }
  v9 = (const UInt8 *)malloc_type_malloc(v7, 0x5A9ADE4FuLL);
  if (!v9)
    return 0xFFFFFFFFLL;
  v10 = v9;
  if (CCRandomCopyBytes())
    return 0xFFFFFFFFLL;
  v11 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v10, v7, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
  v12 = v11;
  v13 = *v1;
  if (!*v1)
  {
LABEL_106:
    if (SecCmsArraySortByDER(*(int8x16_t **)(a1 + 144), (uint64_t)&SecCmsRecipientInfoTemplate, 0))
      goto LABEL_116;
    SecCmsContentInfoSetBulkKey(a1, v12);
    if (v12)
      CFRelease(v12);
    return 0;
  }
  v14 = v1 + 1;
  theData = v11;
  while (1)
  {
    v79 = 5;
    v15 = *(__SecCertificate **)(v13 + 144);
    if (!v15)
      break;
    v16 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 136) + 24) + 120);
    v17 = *((_QWORD *)v15 + 27);
    v80[0] = *((_QWORD *)v15 + 28);
    v80[1] = v17;
    v18 = *((_QWORD *)v15 + 29);
    v80[2] = *((_QWORD *)v15 + 30);
    v80[3] = v18;
    if (!v17 || (OID = SECOID_FindOID((uint64_t)v80)) == 0)
    {
LABEL_110:
      v68 = PR_getThreadErrInfo(1, (int *)&v90);
      if (!v68)
        goto LABEL_116;
      v69 = 0xFFFFE00600000000;
      goto LABEL_115;
    }
    v20 = *(_DWORD *)(OID + 16);
    if (v20 != 16)
    {
      if (v20 != 202)
        goto LABEL_110;
      v21 = **(_QWORD **)(v13 + 128);
      if (!v21)
        goto LABEL_116;
      v78[1] = &v79;
      v78[0] = 2;
      if (SECOID_SetAlgorithmID(v16, (unint64_t *)(v13 + 32), 0xCAu, (uint64_t)v78))
        goto LABEL_116;
      privateKey = 0;
      publicKey = 0;
      iv[0] = 0xAAAAAAAAAAAAAAAALL;
      v96[0] = 8;
      v96[1] = iv;
      *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v94 = v22;
      v95 = v22;
      v92 = v22;
      v93 = v22;
      v91 = v22;
      v90 = v22;
      length = 0;
      bytes = 0;
      v87 = 5;
      v86 = -1431655766;
      cryptorRef = 0;
      v85 = 0;
      *(_QWORD *)(v21 + 56) = 0;
      *(_QWORD *)(v21 + 64) = 0;
      v23 = (_QWORD *)(v21 + 56);
      v74 = (_QWORD *)(v13 + 80);
      v24 = SecCertificateCopyKey(v15);
      if (v24)
      {
        cf = v24;
        v25 = SecKeyCopyAttributes(v24);
        v26 = v25;
        if (!v25)
        {
          v30 = 0;
          v31 = 0;
          v76 = 0;
          v77 = 0;
          v34 = 0;
          v41 = cf;
          goto LABEL_46;
        }
        Value = (void *)CFDictionaryGetValue(v25, CFSTR("type"));
        v72 = v26;
        v28 = (void *)CFDictionaryGetValue(v26, CFSTR("bsiz"));
        if (CFEqual(CFSTR("73"), Value))
        {
          keys[0] = CFSTR("type");
          keys[1] = CFSTR("bsiz");
          values[0] = Value;
          values[1] = v28;
          v29 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v30 = SecKeyGeneratePair(v29, &publicKey, &privateKey);
          v31 = 0;
          if (!v30 && publicKey && privateKey)
          {
            v32 = PORT_Alloc(8uLL);
            *(_QWORD *)(v13 + 80) = 8;
            *(_QWORD *)(v13 + 88) = v32;
            v33 = CCRandomCopyBytes();
            if (v33)
              goto LABEL_33;
            if (*(_QWORD *)(v13 + 88))
            {
              *v74 = 8;
              v33 = CCRandomCopyBytes();
              if (!v33)
              {
                v71 = v29;
                v94 = 0u;
                v95 = 0u;
                if (!SEC_ASN1EncodeItem(v16, &v95, (uint64_t)v96, (uint64_t)kSecAsn1OctetStringTemplate))
                  goto LABEL_83;
                pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
                v94 = xmmword_1E1FCE5E0;
                *(_OWORD *)(v13 + 96) = 0u;
                *(_OWORD *)(v13 + 112) = 0u;
                if (!SEC_ASN1EncodeItem(v16, (_QWORD *)(v13 + 112), (uint64_t)&v94, (uint64_t)&SECOID_AlgorithmIDTemplate))goto LABEL_83;
                pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
                *(_OWORD *)(v13 + 96) = *(__int128 *)((char *)&xmmword_1E1FCE5E0 + 7880);
                v90 = 0u;
                v91 = 0u;
                v92 = 0u;
                v93 = 0u;
                pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
                v90 = xmmword_1E1FCE5E0;
                *((_QWORD *)&v91 + 1) = &v87;
                *(_QWORD *)&v91 = 2;
                v92 = *(_OWORD *)v74;
                v86 = -1073741824;
                *(_QWORD *)&v93 = 4;
                *((_QWORD *)&v93 + 1) = &v86;
                if (!SEC_ASN1EncodeItem(v16, &length, (uint64_t)&v90, (uint64_t)&ECC_CMS_SharedInfoTemplate))
                {
LABEL_83:
                  v31 = 0;
                  v76 = 0;
                  v77 = 0;
                  v26 = 0;
                  v34 = 0;
                  v30 = -2070;
                  goto LABEL_84;
                }
                if (length < 0)
                {
                  v31 = 0;
                  v76 = 0;
                  v77 = 0;
                  v26 = 0;
                  v34 = 0;
                  v30 = -108;
                  goto LABEL_84;
                }
                v31 = CFDataCreate(0, bytes, length);
                valuePtr = 24;
                v49 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
                v100[0] = CFSTR("requestedSize");
                v100[1] = CFSTR("sharedInfo");
                v77 = v49;
                v99[0] = v49;
                v99[1] = v31;
                v76 = CFDictionaryCreate(0, (const void **)v100, (const void **)v99, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                v50 = SecKeyCopyKeyExchangeResult(privateKey, CFSTR("algid:keyexchange:ECDH:KDFX963:SHA1"), cf, v76, (CFErrorRef *)&v85);
                v26 = v50;
                if (v85 || CFDataGetLength(v50) < 0)
                  goto LABEL_80;
                BytePtr = CFDataGetBytePtr(v26);
                v52 = CFDataGetLength(v26);
                v53 = CCCryptorCreate(0, 2u, 1u, BytePtr, v52, iv, &cryptorRef);
                if (v53)
                  goto LABEL_88;
                if (CFDataGetLength(theData) < 0)
                {
LABEL_80:
                  v30 = 0;
                }
                else
                {
                  v54 = cryptorRef;
                  v55 = CFDataGetLength(theData);
                  OutputLength = CCCryptorGetOutputLength(v54, v55, 1);
                  *(_QWORD *)(v21 + 64) = PORT_ArenaAlloc(v16, OutputLength);
                  dataOutMoved = 0;
                  v70 = cryptorRef;
                  v57 = CFDataGetBytePtr(theData);
                  v58 = CFDataGetLength(theData);
                  v53 = CCCryptorUpdate(v70, v57, v58, *(void **)(v21 + 64), OutputLength, &dataOutMoved);
                  if (!v53)
                  {
                    v81 = 0;
                    v53 = CCCryptorFinal(cryptorRef, (void *)(*(_QWORD *)(v21 + 64) + dataOutMoved), OutputLength - dataOutMoved, &v81);
                    if (!v53)
                    {
                      *v23 = v81 + dataOutMoved;
                      v59 = SecKeyCopyExternalRepresentation(publicKey, (CFErrorRef *)&v85);
                      v34 = v59;
                      if (v85 || CFDataGetLength(v59) < 0)
                      {
                        v30 = 0;
                      }
                      else
                      {
                        v60 = CFDataGetLength(v34);
                        *(_QWORD *)(v13 + 64) = v60;
                        v61 = malloc_type_malloc(v60, 0x1D1FD62AuLL);
                        *(_QWORD *)(v13 + 72) = v61;
                        if (v61)
                        {
                          v62 = v61;
                          v63 = CFDataGetBytePtr(v34);
                          memcpy(v62, v63, *(_QWORD *)(v13 + 64));
                          v30 = 0;
                        }
                        else
                        {
                          v30 = -108;
                        }
                        *(_QWORD *)(v13 + 64) *= 8;
                      }
LABEL_84:
                      v42 = cf;
                      v29 = v71;
LABEL_45:
                      CFRelease(v42);
                      CFRelease(v72);
                      v41 = v29;
                      if (v29)
LABEL_46:
                        CFRelease(v41);
LABEL_47:
                      v43 = publicKey;
                      if (publicKey)
                      {
                        publicKey = 0;
                        CFRelease(v43);
                      }
                      v44 = privateKey;
                      if (privateKey)
                      {
                        privateKey = 0;
                        CFRelease(v44);
                      }
                      if (v31)
                        CFRelease(v31);
                      if (v77)
                        CFRelease(v77);
                      v12 = theData;
                      if (v76)
                        CFRelease(v76);
                      if (v26)
                        CFRelease(v26);
                      v45 = v85;
                      if (v85)
                      {
                        v85 = 0;
                        CFRelease(v45);
                      }
                      if (v34)
                        CFRelease(v34);
                      if (cryptorRef)
                        CCCryptorRelease(cryptorRef);
                      if (v30)
                      {
                        v46 = *(void **)(v21 + 64);
                        if (v46)
                        {
                          free(v46);
                          *v23 = 0;
                          *(_QWORD *)(v21 + 64) = 0;
                        }
                        v47 = *(void **)(v13 + 88);
                        if (v47)
                        {
                          free(v47);
                          *v74 = 0;
                          *(_QWORD *)(v13 + 88) = 0;
                        }
                      }
                      goto LABEL_70;
                    }
                  }
LABEL_88:
                  v30 = v53;
                }
                v34 = 0;
                goto LABEL_84;
              }
LABEL_33:
              v30 = v33;
            }
            else
            {
              v30 = 0;
            }
            v31 = 0;
            v76 = 0;
            v77 = 0;
            v26 = 0;
            v34 = 0;
          }
          else
          {
            v76 = 0;
            v77 = 0;
            v26 = 0;
            v34 = 0;
          }
        }
        else
        {
          v29 = 0;
          v31 = 0;
          v76 = 0;
          v77 = 0;
          v26 = 0;
          v34 = 0;
          v30 = -8152;
        }
        v42 = cf;
        goto LABEL_45;
      }
      v30 = 0;
      v31 = 0;
      v76 = 0;
      v77 = 0;
      v26 = 0;
      v34 = 0;
      goto LABEL_47;
    }
    v35 = SecCertificateCopyKey(v15);
    if (!v35)
      goto LABEL_116;
    v36 = v35;
    Size = SecKeyGetSize((uint64_t)v35, 2);
    v38 = PORT_ArenaAlloc(v16, Size);
    *(_QWORD *)(v13 + 72) = Size;
    *(_QWORD *)(v13 + 80) = v38;
    if (!v38
      || CFDataGetLength(v12) < 0
      || (v39 = CFDataGetBytePtr(v12),
          v40 = CFDataGetLength(v12),
          SecKeyEncrypt(v36, 1u, v39, v40, *(uint8_t **)(v13 + 80), (size_t *)(v13 + 72))))
    {
      CFRelease(v36);
      goto LABEL_116;
    }
    CFRelease(v36);
    v30 = SECOID_SetAlgorithmID(v16, (unint64_t *)(v13 + 40), 0x10u, 0);
LABEL_70:
    if (v30)
      goto LABEL_116;
    v48 = *v14++;
    v13 = v48;
    if (!v48)
      goto LABEL_106;
  }
  v68 = PR_getThreadErrInfo(1, (int *)&v90);
  if (!v68)
    goto LABEL_116;
  v69 = 0xFFFFE00500000000;
LABEL_115:
  *v68 = v69;
LABEL_116:
  if (v12)
    CFRelease(v12);
  return 0xFFFFFFFFLL;
}

void SecCmsEnvelopedDataDecodeAfterData(uint64_t a1)
{
  CCCryptorRef *v2;

  if (a1)
  {
    v2 = *(CCCryptorRef **)(a1 + 96);
    if (v2)
    {
      CCCryptorRelease(*v2);
      free(v2);
      *(_QWORD *)(a1 + 96) = 0;
    }
  }
}

CFTypeID CMSEncoderGetTypeID(void)
{
  CFTypeID result;

  result = cmsEncoderTypeID;
  if (!cmsEncoderTypeID)
  {
    pthread_once(&CMSEncoderGetTypeID_once, (void (*)(void))cmsEncoderClassInitialize);
    return cmsEncoderTypeID;
  }
  return result;
}

uint64_t cmsEncoderClassInitialize()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass();
  cmsEncoderTypeID = result;
  return result;
}

double cmsEncoderInit(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 144) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void cmsEncoderFinalize(_QWORD *a1)
{
  void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  uint64_t v7;
  uint64_t *v8;

  if (a1)
  {
    v2 = (void *)a1[5];
    if (v2)
      free(v2);
    v3 = (const void *)a1[6];
    if (v3)
      CFRelease(v3);
    v4 = (const void *)a1[7];
    if (v4)
      CFRelease(v4);
    v5 = (const void *)a1[8];
    if (v5)
      CFRelease(v5);
    v6 = (const void *)a1[13];
    if (v6)
      CFRelease(v6);
    v7 = a1[11];
    if (v7)
    {
      SecCmsMessageDestroy(v7);
      a1[11] = 0;
    }
    v8 = (uint64_t *)a1[12];
    if (v8)
      SecCmsEncoderDestroy(v8);
  }
}

OSStatus CMSEncoderCreate(CMSEncoderRef *cmsEncoderOut)
{
  uint64_t Instance;
  uint64_t v3;
  OSStatus result;

  if (!cmsEncoderTypeID)
    pthread_once(&CMSEncoderGetTypeID_once, (void (*)(void))cmsEncoderClassInitialize);
  Instance = _CFRuntimeCreateInstance();
  if (!Instance)
    return -108;
  v3 = Instance;
  result = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 116) = 0x200000004;
  *cmsEncoderOut = (CMSEncoderRef)v3;
  return result;
}

OSStatus CMSEncoderSetSignerAlgorithm(CMSEncoderRef cmsEncoder, CFStringRef digestAlgorithm)
{
  int v4;
  OSStatus result;

  if (CFEqual(digestAlgorithm, CFSTR("sha1")))
  {
    v4 = 4;
LABEL_5:
    result = 0;
    *((_DWORD *)cmsEncoder + 29) = v4;
    return result;
  }
  if (CFEqual(digestAlgorithm, CFSTR("sha256")))
  {
    v4 = 192;
    goto LABEL_5;
  }
  return -50;
}

OSStatus CMSEncoderAddSigners(CMSEncoderRef cmsEncoder, CFTypeRef signerOrArray)
{
  CFMutableArrayRef *v4;
  CFTypeID TypeID;

  if (!cmsEncoder || *((_DWORD *)cmsEncoder + 4))
    return -50;
  v4 = (CFMutableArrayRef *)((char *)cmsEncoder + 48);
  TypeID = SecIdentityGetTypeID();
  return cmsAppendToArray((uint64_t)signerOrArray, v4, TypeID);
}

OSStatus CMSEncoderCopySigners(CMSEncoderRef cmsEncoder, CFArrayRef *signersOut)
{
  OSStatus result;
  const void *v5;
  const __CFArray *v6;

  result = -50;
  if (cmsEncoder && signersOut)
  {
    v5 = (const void *)*((_QWORD *)cmsEncoder + 6);
    if (v5)
    {
      CFRetain(v5);
      v6 = (const __CFArray *)*((_QWORD *)cmsEncoder + 6);
    }
    else
    {
      v6 = 0;
    }
    result = 0;
    *signersOut = v6;
  }
  return result;
}

OSStatus CMSEncoderAddRecipients(CMSEncoderRef cmsEncoder, CFTypeRef recipientOrArray)
{
  CFMutableArrayRef *v4;
  CFTypeID TypeID;

  if (!cmsEncoder || *((_DWORD *)cmsEncoder + 4))
    return -50;
  v4 = (CFMutableArrayRef *)((char *)cmsEncoder + 56);
  TypeID = SecCertificateGetTypeID();
  return cmsAppendToArray((uint64_t)recipientOrArray, v4, TypeID);
}

OSStatus CMSEncoderCopyRecipients(CMSEncoderRef cmsEncoder, CFArrayRef *recipientsOut)
{
  OSStatus result;
  const void *v5;
  const __CFArray *v6;

  result = -50;
  if (cmsEncoder && recipientsOut)
  {
    v5 = (const void *)*((_QWORD *)cmsEncoder + 7);
    if (v5)
    {
      CFRetain(v5);
      v6 = (const __CFArray *)*((_QWORD *)cmsEncoder + 7);
    }
    else
    {
      v6 = 0;
    }
    result = 0;
    *recipientsOut = v6;
  }
  return result;
}

OSStatus CMSEncoderAddSupportingCerts(CMSEncoderRef cmsEncoder, CFTypeRef certOrArray)
{
  CFMutableArrayRef *v4;
  CFTypeID TypeID;

  if (!cmsEncoder || *((_DWORD *)cmsEncoder + 4))
    return -50;
  v4 = (CFMutableArrayRef *)((char *)cmsEncoder + 64);
  TypeID = SecCertificateGetTypeID();
  return cmsAppendToArray((uint64_t)certOrArray, v4, TypeID);
}

OSStatus CMSEncoderCopySupportingCerts(CMSEncoderRef cmsEncoder, CFArrayRef *certsOut)
{
  OSStatus result;
  const void *v5;
  const __CFArray *v6;

  result = -50;
  if (cmsEncoder && certsOut)
  {
    v5 = (const void *)*((_QWORD *)cmsEncoder + 8);
    if (v5)
    {
      CFRetain(v5);
      v6 = (const __CFArray *)*((_QWORD *)cmsEncoder + 8);
    }
    else
    {
      v6 = 0;
    }
    result = 0;
    *certsOut = v6;
  }
  return result;
}

OSStatus CMSEncoderSetHasDetachedContent(CMSEncoderRef cmsEncoder, Boolean detachedContent)
{
  OSStatus result;

  if (!cmsEncoder || *((_DWORD *)cmsEncoder + 4))
    return -50;
  result = 0;
  *((_BYTE *)cmsEncoder + 24) = detachedContent;
  return result;
}

OSStatus CMSEncoderGetHasDetachedContent(CMSEncoderRef cmsEncoder, Boolean *detachedContentOut)
{
  OSStatus result;

  result = -50;
  if (cmsEncoder)
  {
    if (detachedContentOut)
    {
      result = 0;
      *detachedContentOut = *((_BYTE *)cmsEncoder + 24);
    }
  }
  return result;
}

OSStatus CMSEncoderSetEncapsulatedContentTypeOID(CMSEncoderRef cmsEncoder, CFTypeRef eContentTypeOID)
{
  OSStatus v3;
  SecAsn1Oid v5;

  v5.Length = 0;
  v5.Data = 0;
  if (!eContentTypeOID || convertOid((const __CFString *)eContentTypeOID, &v5))
    return -50;
  v3 = CMSEncoderSetEncapsulatedContentType(cmsEncoder, &v5);
  if (v5.Data)
    free(v5.Data);
  return v3;
}

uint64_t convertOid(const __CFString *a1, _QWORD *a2)
{
  CFTypeID v4;
  uint64_t v5;
  CFIndex v6;
  uint64_t v7;
  char *v8;
  char *v9;
  const __CFString *v10;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v12;
  CFIndex Count;
  unint64_t v14;
  const __CFString *ValueAtIndex;
  int v16;
  char v17;
  const __CFString *v18;
  int v19;
  _BYTE *v20;
  unsigned int Length;
  CFTypeID v22;
  const UInt8 *BytePtr;
  char v24;
  _DWORD *v25;
  _QWORD *v26;
  unint64_t v28;
  uint64_t v29;
  int v30;
  const __CFString *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  size_t v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  _BYTE *v42;
  uint64_t v43;
  uint64_t v44;
  _BYTE *v45;
  uint64_t v46;
  _BYTE *v47;
  unint64_t v48;
  uint64_t v49;
  char v50;
  char *v51;
  const __CFArray *v52;
  const __CFString *v53;
  unint64_t v54;

  if (!a2)
    return 4294967246;
  v4 = CFGetTypeID(a1);
  if (v4 != CFStringGetTypeID())
  {
    v22 = CFGetTypeID(a1);
    if (v22 == CFDataGetTypeID())
    {
      Length = CFDataGetLength((CFDataRef)a1);
      v20 = malloc_type_malloc(Length, 0xEEBF7B77uLL);
      BytePtr = CFDataGetBytePtr((CFDataRef)a1);
      memcpy(v20, BytePtr, Length);
LABEL_15:
      v5 = 0;
      *a2 = Length;
      a2[1] = v20;
      return v5;
    }
    return 4294967246;
  }
  v5 = 4294899624;
  v6 = CFStringGetLength(a1);
  if ((v6 & 0x8000000000000000) == 0)
  {
    v7 = 3 * v6;
    v8 = (char *)malloc_type_malloc(3 * v6, 0x9CAD8052uLL);
    if (v8)
    {
      v9 = v8;
      if (CFStringGetCString(a1, v8, v7 - 1, 0x600u))
      {
        v10 = CFStringCreateWithCString(0, v9, 0x600u);
        if (v10)
        {
          ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, v10, CFSTR("."));
          v12 = ArrayBySeparatingStrings;
          if (ArrayBySeparatingStrings)
          {
            Count = CFArrayGetCount(ArrayBySeparatingStrings);
            if (Count >= 3)
            {
              v14 = Count;
              ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, 0);
              v16 = cfStringToNumber(ValueAtIndex);
              if ((v16 & 0x80000000) == 0)
              {
                v17 = v16;
                v18 = (const __CFString *)CFArrayGetValueAtIndex(v12, 1);
                v19 = cfStringToNumber(v18);
                if ((v19 & 0x80000000) == 0 && v14 <= 0x1000000000000000)
                {
                  v51 = v9;
                  v50 = v19 + 40 * v17;
                  v28 = v14 - 2;
                  v26 = malloc_type_malloc(8 * (v14 - 2), 0x10040436913F5uLL);
                  v25 = malloc_type_malloc(4 * (v14 - 2), 0x100004052888210uLL);
                  v29 = 0;
                  v30 = 1;
                  v52 = v12;
                  v53 = v10;
                  v54 = v28;
                  do
                  {
                    v31 = (const __CFString *)CFArrayGetValueAtIndex(v12, v29 + 2);
                    v32 = cfStringToNumber(v31);
                    if ((v32 & 0x80000000) != 0)
                    {
                      v20 = 0;
                      Length = 0;
                      v24 = 0;
                      v9 = v51;
                      goto LABEL_19;
                    }
                    v33 = v32;
                    if (v32)
                    {
                      v34 = 0;
                      LODWORD(v35) = 0;
                      v36 = 1;
                      v37 = v32;
                      do
                      {
                        v38 = v35;
                        v39 = v34;
                        v40 = v36;
                        v35 = (v35 + 1);
                        ++v34;
                        ++v36;
                        v41 = v37 > 0x7F;
                        v37 >>= 7;
                      }
                      while (v41);
                      v42 = malloc_type_malloc(v35, 0x77EC65AAuLL);
                      v43 = v39;
                      do
                      {
                        v42[--v40] = v33 & 0x7F;
                        v33 >>= 7;
                        --v43;
                      }
                      while (v43 != -1);
                      if (v38)
                      {
                        v44 = 0;
                        do
                          v42[v44++] |= 0x80u;
                        while (v39 != v44);
                      }
                      v26[v29] = v42;
                      v12 = v52;
                      v10 = v53;
                      v28 = v54;
                    }
                    else
                    {
                      LODWORD(v35) = 1;
                      v45 = malloc_type_malloc(1uLL, 0x8DDCE9A3uLL);
                      v26[v29] = v45;
                      *v45 = 0;
                    }
                    v25[v29] = v35;
                    v30 += v35;
                    ++v29;
                  }
                  while (v29 != v28);
                  Length = v30 + 2;
                  v20 = malloc_type_malloc((v30 + 2), 0x1A486A80uLL);
                  v46 = 0;
                  *v20 = 6;
                  v20[1] = v30;
                  v20[2] = v50;
                  v47 = v20 + 3;
                  v9 = v51;
                  do
                  {
                    if (v25[v46])
                    {
                      v48 = 0;
                      do
                      {
                        v47[v48] = *(_BYTE *)(v26[v46] + v48);
                        ++v48;
                      }
                      while (v48 < v25[v46]);
                      v47 += v48;
                    }
                    ++v46;
                  }
                  while (v46 != v28);
                  if (v26)
                  {
                    v49 = 0;
                    v24 = 1;
                    do
                      free((void *)v26[v49++]);
                    while (v54 != v49);
                  }
                  else
                  {
                    v24 = 1;
                  }
LABEL_19:
                  free(v26);
                  free(v25);
                  if (v10)
                    CFRelease(v10);
                  if (v12)
                    CFRelease(v12);
                  free(v9);
                  if ((v24 & 1) == 0)
                    return 4294967246;
                  goto LABEL_15;
                }
              }
            }
          }
          v20 = 0;
          Length = 0;
        }
        else
        {
          v20 = 0;
          Length = 0;
          v12 = 0;
        }
        v24 = 0;
        v25 = 0;
        v26 = 0;
        goto LABEL_19;
      }
      free(v9);
      return 4294967246;
    }
  }
  return v5;
}

OSStatus CMSEncoderSetEncapsulatedContentType(CMSEncoderRef cmsEncoder, const SecAsn1Oid *eContentType)
{
  OSStatus result;
  void *v5;
  void *v6;

  result = -50;
  if (cmsEncoder && eContentType && !*((_DWORD *)cmsEncoder + 4))
  {
    v5 = (void *)*((_QWORD *)cmsEncoder + 5);
    if (v5)
      free(v5);
    v6 = malloc_type_malloc(eContentType->Length, 0xDBF2B51BuLL);
    *((_QWORD *)cmsEncoder + 5) = v6;
    memmove(v6, eContentType->Data, eContentType->Length);
    result = 0;
    *((_QWORD *)cmsEncoder + 4) = eContentType->Length;
  }
  return result;
}

uint64_t cfStringToNumber(const __CFString *a1)
{
  __int128 v1;
  _OWORD v3[2];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v1 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v3[0] = v1;
  v3[1] = v1;
  if (a1 && CFStringGetCString(a1, (char *)v3, 31, 0x600u))
    return atoi((const char *)v3);
  else
    return 0xFFFFFFFFLL;
}

OSStatus CMSEncoderCopyEncapsulatedContentType(CMSEncoderRef cmsEncoder, CFDataRef *eContentTypeOut)
{
  OSStatus result;
  const UInt8 *v5;
  CFIndex v6;
  const __CFData *v7;

  result = -50;
  if (cmsEncoder && eContentTypeOut)
  {
    v5 = (const UInt8 *)*((_QWORD *)cmsEncoder + 5);
    if (!v5)
    {
      v7 = 0;
      goto LABEL_7;
    }
    v6 = *((_QWORD *)cmsEncoder + 4);
    if ((v6 & 0x8000000000000000) == 0)
    {
      v7 = CFDataCreate(0, v5, v6);
LABEL_7:
      result = 0;
      *eContentTypeOut = v7;
      return result;
    }
    return -108;
  }
  return result;
}

OSStatus CMSEncoderAddSignedAttributes(CMSEncoderRef cmsEncoder, CMSSignedAttributes signedAttributes)
{
  OSStatus result;

  if (!cmsEncoder || *((_DWORD *)cmsEncoder + 4))
    return -50;
  result = 0;
  *((_DWORD *)cmsEncoder + 18) |= signedAttributes;
  return result;
}

uint64_t CMSEncoderSetSigningTime(uint64_t a1, double a2)
{
  uint64_t result;

  if (!a1 || *(_DWORD *)(a1 + 16))
    return 4294967246;
  result = 0;
  *(double *)(a1 + 80) = a2;
  return result;
}

uint64_t CMSEncoderSetAppleCodesigningHashAgility(uint64_t a1, CFTypeRef cf)
{
  uint64_t result;

  if (!a1)
    return 4294967246;
  if (*(_DWORD *)(a1 + 16))
    return 4294967246;
  if (cf)
    CFRetain(cf);
  result = 0;
  *(_QWORD *)(a1 + 128) = cf;
  return result;
}

uint64_t CMSEncoderSetAppleCodesigningHashAgilityV2(uint64_t a1, CFTypeRef cf)
{
  uint64_t result;

  if (!a1)
    return 4294967246;
  if (*(_DWORD *)(a1 + 16))
    return 4294967246;
  if (cf)
    CFRetain(cf);
  result = 0;
  *(_QWORD *)(a1 + 136) = cf;
  return result;
}

uint64_t CMSEncoderSetAppleExpirationTime(uint64_t a1, double a2)
{
  uint64_t result;

  if (!a1 || *(_DWORD *)(a1 + 16))
    return 4294967246;
  result = 0;
  *(double *)(a1 + 144) = a2;
  return result;
}

OSStatus CMSEncoderSetCertificateChainMode(CMSEncoderRef cmsEncoder, CMSCertificateChainMode chainMode)
{
  OSStatus result;

  if (!cmsEncoder)
    return -50;
  result = -50;
  if (chainMode <= kCMSCertificateChainWithRootOrFail && !*((_DWORD *)cmsEncoder + 4))
  {
    result = 0;
    *((_DWORD *)cmsEncoder + 30) = chainMode;
  }
  return result;
}

OSStatus CMSEncoderGetCertificateChainMode(CMSEncoderRef cmsEncoder, CMSCertificateChainMode *chainModeOut)
{
  OSStatus result;

  if (!cmsEncoder)
    return -50;
  result = 0;
  *chainModeOut = *((CMSCertificateChainMode *)cmsEncoder + 30);
  return result;
}

OSStatus CMSEncoderUpdateContent(CMSEncoderRef cmsEncoder, const void *content, size_t contentLen)
{
  CMSEncoderRef v3;
  int v4;

  if (cmsEncoder)
  {
    v3 = cmsEncoder;
    v4 = *((_DWORD *)cmsEncoder + 4);
    LODWORD(cmsEncoder) = -50;
    switch(v4)
    {
      case 0:
        LODWORD(cmsEncoder) = cmsSetupCmsMsg((uint64_t)v3);
        if (!(_DWORD)cmsEncoder)
          goto LABEL_4;
        break;
      case 1:
LABEL_4:
        LODWORD(cmsEncoder) = cmsSetupEncoder((uint64_t)v3);
        if (!(_DWORD)cmsEncoder)
        {
          *((_DWORD *)v3 + 4) = 2;
          goto LABEL_6;
        }
        break;
      case 2:
LABEL_6:
        cmsEncoder = (CMSEncoderRef)SecCmsEncoderUpdate(*((_QWORD *)v3 + 12), (char *)content, contentLen);
        if ((_DWORD)cmsEncoder)
          LODWORD(cmsEncoder) = cmsRtnToOSStatusDefault((uint64_t)cmsEncoder, 0);
        break;
      case 3:
        return (int)cmsEncoder;
      default:
        LODWORD(cmsEncoder) = -2070;
        break;
    }
  }
  else
  {
    LODWORD(cmsEncoder) = -50;
  }
  return (int)cmsEncoder;
}

uint64_t cmsSetupCmsMsg(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const __CFArray *v5;
  unint64_t Count;
  uint64_t v7;
  __SecCertificate **v8;
  CFIndex i;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFIndex v15;
  _QWORD *ValueAtIndex;
  uint64_t v17;
  int v18;
  unsigned int v19;

  if (*(_QWORD *)(a1 + 48) || *(_QWORD *)(a1 + 64))
  {
    *(_DWORD *)(a1 + 20) = 2 * (*(_QWORD *)(a1 + 56) != 0);
    v2 = cmsSetupForSignedData(a1);
  }
  else
  {
    v5 = *(const __CFArray **)(a1 + 56);
    if (!v5)
      return 4294967246;
    *(_DWORD *)(a1 + 20) = 1;
    Count = CFArrayGetCount(v5);
    if (Count > 0xFFFFFFFFFFFFFFDLL)
    {
      v3 = 4294967188;
      goto LABEL_5;
    }
    v7 = Count;
    v8 = (__SecCertificate **)malloc_type_malloc(8 * Count + 8, 0x2004093837F09uLL);
    if (v7)
    {
      for (i = 0; i != v7; ++i)
        v8[i] = (__SecCertificate *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), i);
    }
    v18 = -1431655766;
    v19 = -1431655766;
    v8[v7] = 0;
    v3 = SecSMIMEFindBulkAlgForRecipients(v8, &v19, &v18);
    free(v8);
    if ((_DWORD)v3)
      goto LABEL_5;
    v10 = *(_QWORD *)(a1 + 88);
    if (v10)
      SecCmsMessageDestroy(v10);
    v11 = SecCmsMessageCreate();
    *(_QWORD *)(a1 + 88) = v11;
    if (!v11 || (v12 = SecCmsEnvelopedDataCreate(v11, v19, v18)) == 0)
    {
      v3 = 4294965226;
      goto LABEL_5;
    }
    v13 = v12;
    v14 = SecCmsContentInfoSetContent(*(unint64_t **)(a1 + 88), 0x1Bu, v12);
    if (!(_DWORD)v14)
    {
      v14 = *(_QWORD *)(a1 + 40)
          ? SecCmsContentInfoSetContentOther(v13, 0, 0, a1 + 32)
          : SecCmsContentInfoSetContentData((unint64_t *)v13, 0, *(unsigned __int8 *)(a1 + 24));
      if (!(_DWORD)v14)
      {
        if (v7 < 1)
        {
          v3 = 0;
          goto LABEL_5;
        }
        v15 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 56), v15);
          v17 = nss_cmsrecipientinfo_create(v13, 0, ValueAtIndex, 0);
          if (SecCmsArrayAdd(*(_QWORD *)(*(_QWORD *)(v13 + 24) + 120), (char **)(v13 + 144), v17))
            break;
          v3 = 0;
          if (v7 == ++v15)
            goto LABEL_5;
        }
        v14 = 0xFFFFFFFFLL;
      }
    }
    v2 = cmsRtnToOSStatusDefault(v14, 0);
  }
  v3 = v2;
LABEL_5:
  *(_DWORD *)(a1 + 16) = 1;
  return v3;
}

uint64_t cmsSetupEncoder(uint64_t a1)
{
  CFMutableDataRef Mutable;
  uint64_t v3;
  uint64_t result;

  Mutable = CFDataCreateMutable(0, 0);
  *(_QWORD *)(a1 + 104) = Mutable;
  if (!Mutable)
    return 4294967188;
  result = SecCmsEncoderCreate(*(uint64_t **)(a1 + 88), 0, 0, (uint64_t)Mutable, v3, 0, 0, 0, (_QWORD *)(a1 + 96));
  if ((_DWORD)result)
    return cmsRtnToOSStatusDefault(result, 0);
  return result;
}

uint64_t cmsSetupForSignedData(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  const __CFArray *v10;
  const __CFArray *v11;
  CFIndex Count;
  int v13;
  CFIndex v14;
  CFIndex v15;
  _QWORD *ValueAtIndex;
  const void *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  double Current;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  const void *v25;

  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
    SecCmsMessageDestroy(v2);
  v3 = SecCmsMessageCreate();
  *(_QWORD *)(a1 + 88) = v3;
  if (!v3)
    return 4294965226;
  v4 = v3;
  v5 = PORT_ArenaAlloc(*(_QWORD *)(v3 + 120), 0xB8uLL);
  if (!v5)
    return 4294965226;
  v6 = (unint64_t *)v5;
  *(_QWORD *)(v5 + 176) = 0;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)v5 = 0u;
  *(_QWORD *)(v5 + 24) = v4;
  v7 = SecCmsContentInfoSetContent(*(unint64_t **)(a1 + 88), 0x1Au, v5);
  if (!(_DWORD)v7)
  {
    if (*(_QWORD *)(a1 + 40))
    {
      v7 = SecCmsContentInfoSetContentOther((uint64_t)v6, 0, *(unsigned __int8 *)(a1 + 24), a1 + 32);
      if (!(_DWORD)v7)
      {
LABEL_12:
        v10 = *(const __CFArray **)(a1 + 64);
        if (v10 && SecCmsSignedDataAddCertList((uint64_t)v6, v10))
        {
          v7 = 0xFFFFFFFFLL;
          return cmsRtnToOSStatusDefault(v7, 0);
        }
        v11 = *(const __CFArray **)(a1 + 48);
        if (!v11)
          return 0;
        Count = CFArrayGetCount(v11);
        v13 = *(_DWORD *)(a1 + 120) >= 5u ? 2 : *(_DWORD *)(a1 + 120);
        if (Count < 1)
          return 0;
        v14 = Count;
        v15 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), v15);
          v17 = (const void *)ValueAtIndex[2];
          CFRetain(v17);
          v18 = SecCmsSignerInfoCreate((uint64_t)v6, (uint64_t)ValueAtIndex, *(_DWORD *)(a1 + 116));
          if (!v18)
          {
            v8 = 4294965226;
            goto LABEL_59;
          }
          v19 = v18;
          if (SecCmsSignerInfoIncludeCerts(v18, v13))
          {
LABEL_55:
            v23 = 0xFFFFFFFFLL;
            goto LABEL_58;
          }
          v20 = *(_DWORD *)(a1 + 72);
          if ((v20 & 1) != 0)
          {
            if (SecCmsSignerInfoAddSMIMECaps(v19))
              goto LABEL_55;
            v20 = *(_DWORD *)(a1 + 72);
          }
          if ((v20 & 2) != 0)
          {
            if (SecCmsSignerInfoAddSMIMEEncKeyPrefs_internal(v19, (const __CFData *)v17))
              goto LABEL_55;
            v20 = *(_DWORD *)(a1 + 72);
          }
          if ((v20 & 4) != 0)
          {
            if (SecCmsSignerInfoAddMSSMIMEEncKeyPrefs_internal(v19, (const __CFData *)v17))
              goto LABEL_55;
            v20 = *(_DWORD *)(a1 + 72);
          }
          if ((v20 & 8) != 0)
          {
            Current = *(double *)(a1 + 80);
            if (Current == 0.0)
            {
              Current = CFAbsoluteTimeGetCurrent();
              *(double *)(a1 + 80) = Current;
            }
            v22 = SecCmsSignerInfoAddSigningTime(v19, Current);
            if ((_DWORD)v22)
              break;
            v20 = *(_DWORD *)(a1 + 72);
          }
          if ((v20 & 0x10) != 0)
          {
            v23 = SecCmsSignerInfoAddAppleCodesigningHashAgility(v19, *(CFDataRef *)(a1 + 128));
            v24 = *(const void **)(a1 + 128);
            if (v24)
            {
              *(_QWORD *)(a1 + 128) = 0;
              CFRelease(v24);
            }
            if ((_DWORD)v23)
              goto LABEL_58;
            v20 = *(_DWORD *)(a1 + 72);
          }
          if ((v20 & 0x20) != 0)
          {
            v23 = SecCmsSignerInfoAddAppleCodesigningHashAgilityV2(v19, *(const __CFDictionary **)(a1 + 136));
            v25 = *(const void **)(a1 + 136);
            if (v25)
            {
              *(_QWORD *)(a1 + 136) = 0;
              CFRelease(v25);
            }
            if ((_DWORD)v23)
              goto LABEL_58;
            v20 = *(_DWORD *)(a1 + 72);
          }
          if ((v20 & 0x40) != 0)
          {
            v22 = SecCmsSignerInfoAddAppleExpirationTime(v19, *(CFAbsoluteTime *)(a1 + 144));
            if ((_DWORD)v22)
              break;
          }
          if (v17)
            CFRelease(v17);
          v8 = 0;
          if (v14 == ++v15)
            return v8;
        }
        v23 = v22;
LABEL_58:
        v8 = cmsRtnToOSStatusDefault(v23, 0);
LABEL_59:
        if ((_DWORD)v8 && v17)
          CFRelease(v17);
        return v8;
      }
    }
    else
    {
      v7 = SecCmsContentInfoSetContentData(v6, 0, *(unsigned __int8 *)(a1 + 24));
      if (!(_DWORD)v7)
        goto LABEL_12;
    }
  }
  return cmsRtnToOSStatusDefault(v7, 0);
}

OSStatus CMSEncoderCopyEncodedContent(CMSEncoderRef cmsEncoder, CFDataRef *encodedContentOut)
{
  OSStatus v2;
  unsigned int v5;
  uint64_t v7;
  const __CFData *v8;
  CFIndex Length;
  char *MutableBytePtr;
  __int128 v11;
  SecAsn1CoderRef coder;

  v2 = -50;
  if (!cmsEncoder || !encodedContentOut)
    return v2;
  v5 = *((_DWORD *)cmsEncoder + 4);
  if (v5 >= 2)
  {
    if (v5 == 3)
      return v2;
  }
  else
  {
    if (*((_QWORD *)cmsEncoder + 6))
      return v2;
    if (*((_QWORD *)cmsEncoder + 7))
      return v2;
    if (!*((_QWORD *)cmsEncoder + 8))
      return v2;
    v2 = cmsSetupForSignedData((uint64_t)cmsEncoder);
    if (v2)
      return v2;
    v2 = cmsSetupEncoder((uint64_t)cmsEncoder);
    if (v2)
      return v2;
  }
  v7 = SecCmsEncoderFinish(*((_DWORD **)cmsEncoder + 12));
  *((_QWORD *)cmsEncoder + 12) = 0;
  if (!(_DWORD)v7)
  {
    *((_DWORD *)cmsEncoder + 4) = 3;
    v8 = (const __CFData *)*((_QWORD *)cmsEncoder + 13);
    if (v8)
    {
      if (!*((_BYTE *)cmsEncoder + 112))
      {
        if (*((_DWORD *)cmsEncoder + 5) > 1u)
        {
          coder = 0;
          v11 = 0uLL;
          v2 = SecAsn1CoderCreate(&coder);
          if (!v2)
          {
            if (CFDataGetLength(*((CFDataRef *)cmsEncoder + 13)) < 0)
            {
              return -108;
            }
            else
            {
              Length = CFDataGetLength(*((CFDataRef *)cmsEncoder + 13));
              MutableBytePtr = (char *)CFDataGetMutableBytePtr(*((CFMutableDataRef *)cmsEncoder + 13));
              v2 = cmsContentInfoContent((uint64_t *)coder, Length, MutableBytePtr, &v11);
              if (!v2)
                v2 = CMSEncode(0, *((CFTypeRef *)cmsEncoder + 7), &CSSMOID_PKCS7_SignedData, 0, 0, *((const void **)&v11 + 1), v11, encodedContentOut);
              if (coder)
                SecAsn1CoderRelease(coder);
            }
          }
        }
        else
        {
          v2 = 0;
          *encodedContentOut = CFDataCreateCopy(0, v8);
        }
        return v2;
      }
    }
    else if (!*((_BYTE *)cmsEncoder + 112))
    {
      return -2070;
    }
    v2 = 0;
    *encodedContentOut = 0;
    return v2;
  }
  return cmsRtnToOSStatusDefault(v7, 0);
}

uint64_t cmsContentInfoContent(uint64_t *a1, unint64_t a2, char *a3, _OWORD *a4)
{
  uint64_t result;
  __int128 v7;
  __int128 v8;

  v7 = 0u;
  v8 = 0u;
  result = 4294967246;
  if (a1 && a3)
  {
    if (SEC_ASN1Decode(*a1, (uint64_t)&v7, (uint64_t)&cmsSimpleContentInfoTemplate, a3, a2))
    {
      return 4294941021;
    }
    else if (*((_QWORD *)&v8 + 1))
    {
      result = 0;
      *a4 = v8;
    }
    else
    {
      return 4294965226;
    }
  }
  return result;
}

OSStatus CMSEncode(CFTypeRef signers, CFTypeRef recipients, const SecAsn1Oid *eContentType, Boolean detachedContent, CMSSignedAttributes signedAttributes, const void *content, size_t contentLen, CFDataRef *encodedContentOut)
{
  OSStatus updated;
  int v13;
  CMSEncoderRef v17;
  CMSEncoderRef cmsEncoderOut;

  updated = -50;
  if (!((unint64_t)signers | (unint64_t)recipients))
    return updated;
  if (!encodedContentOut)
    return updated;
  v13 = detachedContent;
  cmsEncoderOut = (CMSEncoderRef)0xAAAAAAAAAAAAAAAALL;
  updated = CMSEncoderCreate(&cmsEncoderOut);
  if (updated)
    return updated;
  v17 = cmsEncoderOut;
  if ((!signers || (updated = CMSEncoderAddSigners(cmsEncoderOut, signers)) == 0)
    && (!recipients || (updated = CMSEncoderAddRecipients(v17, recipients)) == 0)
    && (!eContentType || (updated = CMSEncoderSetEncapsulatedContentType(v17, eContentType)) == 0))
  {
    if (v13)
    {
      if (!v17)
        return -50;
      if (*((_DWORD *)v17 + 4))
      {
LABEL_17:
        updated = -50;
LABEL_23:
        CFRelease(v17);
        return updated;
      }
      *((_BYTE *)v17 + 24) = v13;
    }
    if (!signedAttributes)
    {
LABEL_20:
      updated = CMSEncoderUpdateContent(v17, content, contentLen);
      if (!updated)
        updated = CMSEncoderCopyEncodedContent(v17, encodedContentOut);
      goto LABEL_22;
    }
    if (v17)
    {
      if (*((_DWORD *)v17 + 4))
        goto LABEL_17;
      *((_DWORD *)v17 + 18) |= signedAttributes;
      goto LABEL_20;
    }
    return -50;
  }
LABEL_22:
  if (v17)
    goto LABEL_23;
  return updated;
}

OSStatus CMSEncodeContent(CFTypeRef signers, CFTypeRef recipients, CFTypeRef eContentTypeOID, Boolean detachedContent, CMSSignedAttributes signedAttributes, const void *content, size_t contentLen, CFDataRef *encodedContentOut)
{
  const SecAsn1Oid *v15;
  OSStatus v16;
  uint64_t v18;
  void *v19;

  v18 = 0;
  v19 = 0;
  if (eContentTypeOID)
  {
    v15 = (const SecAsn1Oid *)&v18;
    if (convertOid((const __CFString *)eContentTypeOID, &v18))
      return -50;
  }
  else
  {
    v15 = 0;
  }
  v16 = CMSEncode(signers, recipients, v15, detachedContent, signedAttributes, content, contentLen, encodedContentOut);
  if (v19)
    free(v19);
  return v16;
}

uint64_t CMSEncoderGetCmsMessage(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;

  result = 4294967246;
  if (a1 && a2)
  {
    v5 = *(_QWORD *)(a1 + 88);
    if (v5)
    {
      result = 0;
      *a2 = v5;
    }
    else
    {
      result = cmsSetupCmsMsg(a1);
      if (!(_DWORD)result)
      {
        *a2 = *(_QWORD *)(a1 + 88);
        *(_DWORD *)(a1 + 16) = 1;
      }
    }
  }
  return result;
}

uint64_t CMSEncoderSetEncoder(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;

  result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      v5 = *(_DWORD *)(a1 + 16);
      if (v5 == 1 || !v5 && (result = cmsSetupCmsMsg(a1), !(_DWORD)result))
      {
        result = 0;
        *(_QWORD *)(a1 + 96) = a2;
        *(_DWORD *)(a1 + 16) = 2;
        *(_BYTE *)(a1 + 112) = 1;
      }
    }
  }
  return result;
}

uint64_t CMSEncoderGetEncoder(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_QWORD *)(a1 + 96);
    }
  }
  return result;
}

uint64_t SecCmsRecipientInfoCreate(uint64_t a1, _QWORD *a2)
{
  return nss_cmsrecipientinfo_create(a1, 0, a2, 0);
}

uint64_t nss_cmsrecipientinfo_create(uint64_t a1, int a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t OID;
  int v14;
  int v15;
  _DWORD *ThreadErrInfo;
  _QWORD *CertIssuerAndSN;
  _QWORD *v19;
  unint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  int v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD v27[4];
  int v28;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 120);
  v9 = PORT_ArenaAlloc(v8, 0x98uLL);
  if (!v9)
    return 0;
  v10 = v9;
  *(_OWORD *)(v9 + 112) = 0u;
  *(_OWORD *)(v9 + 128) = 0u;
  *(_OWORD *)(v9 + 80) = 0u;
  *(_OWORD *)(v9 + 96) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)v9 = 0u;
  *(_QWORD *)(v9 + 136) = a1;
  *(_QWORD *)(v9 + 144) = 0;
  if (!a3)
    return 0;
  CFRetain(a3);
  *(_QWORD *)(v10 + 144) = a3;
  v11 = a3[27];
  v27[0] = a3[28];
  v27[1] = v11;
  v12 = a3[29];
  v27[2] = a3[30];
  v27[3] = v12;
  if (!v11 || (OID = SECOID_FindOID((uint64_t)v27)) == 0)
  {
    v15 = -8186;
    goto LABEL_11;
  }
  v14 = *(_DWORD *)(OID + 16);
  v15 = -8186;
  if (v14 > 57)
  {
    switch(v14)
    {
      case 58:
        goto LABEL_21;
      case 174:
        if (a2 == 1)
          return 0;
        *(_DWORD *)v10 = 1;
        if (!*(_QWORD *)(v10 + 32))
          return 0;
        break;
      case 202:
        if (a2 == 1)
          return 0;
        *(_DWORD *)v10 = 1;
        CertIssuerAndSN = CERT_GetCertIssuerAndSN(v8, (const __CFData *)a3);
        *(_QWORD *)(v10 + 32) = CertIssuerAndSN;
        if (!CertIssuerAndSN)
          return 0;
        break;
      default:
        goto LABEL_11;
    }
    v21 = PORT_ArenaAlloc(v8, 0x48uLL);
    if (!v21)
      return 0;
    v22 = v21;
    *(_QWORD *)(v21 + 64) = 0;
    *(_OWORD *)(v21 + 32) = 0u;
    *(_OWORD *)(v21 + 48) = 0u;
    *(_OWORD *)v21 = 0u;
    *(_OWORD *)(v21 + 16) = 0u;
    v23 = CERT_GetCertIssuerAndSN(v8, (const __CFData *)a3);
    *(_QWORD *)(v22 + 8) = v23;
    if (!v23)
      return 0;
    *(_DWORD *)(v10 + 24) = 2;
    if (SecCmsArrayAdd(v8, (char **)(v10 + 128), v22) == -1)
      return 0;
  }
  else
  {
    if (v14 != 16)
    {
      if (v14 != 54 && v14 != 56)
      {
LABEL_11:
        ThreadErrInfo = PR_getThreadErrInfo(1, &v28);
        if (ThreadErrInfo)
        {
          *ThreadErrInfo = 0;
          ThreadErrInfo[1] = v15;
        }
        return 0;
      }
LABEL_21:
      if (a2 == 1)
        return 0;
      *(_DWORD *)v10 = 0;
      *(_DWORD *)(v10 + 24) = 0;
      v19 = CERT_GetCertIssuerAndSN(v8, (const __CFData *)a3);
      *(_QWORD *)(v10 + 32) = v19;
      if (!v19)
        return 0;
      goto LABEL_35;
    }
    *(_DWORD *)v10 = 0;
    *(_DWORD *)(v10 + 24) = a2;
    if (a2)
    {
      v20 = (unint64_t *)PORT_ArenaAlloc(v8, 0x10uLL);
      *(_QWORD *)(v10 + 32) = v20;
      if (!v20)
        goto LABEL_45;
      if (SECITEM_CopyItem(v8, v20, a4))
      {
        v15 = -8077;
        goto LABEL_11;
      }
      if (!*(_QWORD *)(*(_QWORD *)(v10 + 32) + 8))
      {
LABEL_45:
        v15 = -8173;
        goto LABEL_11;
      }
    }
    else
    {
      *(_QWORD *)(v10 + 32) = CERT_GetCertIssuerAndSN(v8, (const __CFData *)a3);
    }
  }
LABEL_35:
  v24 = *(_DWORD *)v10;
  if (*(_DWORD *)v10 == 2)
  {
    v26 = v8;
    v25 = 4;
  }
  else if (v24 == 1)
  {
    v26 = v8;
    v25 = 3;
  }
  else
  {
    if (v24)
      goto LABEL_42;
    v25 = 2 * (*(_DWORD *)(v10 + 24) != 0);
    v26 = v8;
  }
  if (SEC_ASN1EncodeInteger(v26, (_QWORD *)(v10 + 8), v25))
  {
LABEL_42:
    if (!SecCmsArrayAdd(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 120), (char **)(a1 + 144), v10))
      return v10;
  }
  return 0;
}

uint64_t SecCmsRecipientInfoCreateWithSubjKeyID(uint64_t a1, uint64_t a2)
{
  return nss_cmsrecipientinfo_create(a1, 1, 0, a2);
}

const __CFData *SecCmsRecipientInfoCreateWithSubjKeyIDFromCert(uint64_t a1, const __CFData *a2)
{
  const __CFData *result;
  const __CFData *v5;
  _QWORD v6[2];

  result = 0;
  if (a1)
  {
    if (a2)
    {
      result = SecCertificateGetSubjectKeyID(a2);
      if (result)
      {
        v5 = result;
        if (CFDataGetLength(result) < 0)
        {
          return 0;
        }
        else
        {
          v6[0] = CFDataGetLength(v5);
          v6[1] = CFDataGetBytePtr(v5);
          return (const __CFData *)nss_cmsrecipientinfo_create(a1, 1, a2, (uint64_t)v6);
        }
      }
    }
  }
  return result;
}

uint64_t SecCmsContentInfoGetContentTypeTag(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    return *(unsigned int *)(result + 16);
  result = SECOID_FindOID(a1);
  *(_QWORD *)(a1 + 32) = result;
  if (result)
    return *(unsigned int *)(result + 16);
  return result;
}

uint64_t SecCmsContentInfoGetChildContentInfo(uint64_t a1)
{
  uint64_t result;
  unsigned int v3;
  BOOL v4;
  int v5;

  result = *(_QWORD *)(a1 + 32);
  if (result || (result = SECOID_FindOID(a1), (*(_QWORD *)(a1 + 32) = result) != 0))
  {
    v3 = *(_DWORD *)(result + 16);
    v4 = v3 > 0x1E;
    v5 = (1 << v3) & 0x6C000000;
    if (v4 || v5 == 0)
      return 0;
    else
      return *(_QWORD *)(a1 + 16);
  }
  return result;
}

uint64_t SecCmsContentInfoSetContent(unint64_t *a1, unsigned int a2, unint64_t a3)
{
  char *v6;
  _QWORD *v9;
  _QWORD *ThreadErrInfo;
  int v11;

  pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
  if (a2 <= 0xD8)
    v6 = &oids[40 * a2];
  else
    v6 = 0;
  a1[4] = (unint64_t)v6;
  if (a2 > 0xD8)
    return 4294967246;
  if (SECITEM_CopyItem(*(_QWORD *)(a1[3] + 120), a1, (uint64_t)v6))
    return 4294967188;
  a1[2] = a3;
  if (a2 != 25)
  {
    v9 = SECITEM_AllocItem(*(_QWORD *)(a1[3] + 120), 0, 1uLL);
    a1[9] = (unint64_t)v9;
    if (!v9)
    {
      ThreadErrInfo = PR_getThreadErrInfo(1, &v11);
      if (ThreadErrInfo)
        *ThreadErrInfo = 0xFFFFE01300000000;
      return 4294967188;
    }
  }
  return 0;
}

uint64_t SecCmsContentInfoSetContentData(unint64_t *a1, CFDataRef theData, int a3)
{
  size_t *v6;
  CFIndex Length;
  void *v8;
  const UInt8 *BytePtr;
  uint64_t Error;
  _QWORD *ThreadErrInfo;
  int v13;

  if (theData)
  {
    if (CFDataGetLength(theData) < 0)
      return 4294967188;
    v6 = (size_t *)PORT_ArenaAlloc(*(_QWORD *)(a1[3] + 120), 0x10uLL);
    Length = CFDataGetLength(theData);
    *v6 = Length;
    if (Length)
    {
      v8 = (void *)PORT_ArenaAlloc(*(_QWORD *)(a1[3] + 120), Length);
      v6[1] = (size_t)v8;
      BytePtr = CFDataGetBytePtr(theData);
      memcpy(v8, BytePtr, *v6);
    }
    else
    {
      v6[1] = 0;
    }
  }
  else
  {
    v6 = 0;
  }
  if (SecCmsContentInfoSetContent(a1, 0x19u, (unint64_t)v6))
  {
    Error = PORT_GetError();
    ThreadErrInfo = PR_getThreadErrInfo(1, &v13);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0;
  }
  else
  {
    if (a3)
    {
      v6 = 0;
    }
    else if (!v6)
    {
      v6 = SECITEM_AllocItem(*(_QWORD *)(a1[3] + 120), 0, 1uLL);
    }
    Error = 0;
    a1[9] = (unint64_t)v6;
  }
  return Error;
}

uint64_t SecCmsContentInfoSetContentSignedData(unint64_t *a1, unint64_t a2)
{
  return SecCmsContentInfoSetContent(a1, 0x1Au, a2);
}

uint64_t SecCmsContentInfoSetContentEnvelopedData(unint64_t *a1, unint64_t a2)
{
  return SecCmsContentInfoSetContent(a1, 0x1Bu, a2);
}

uint64_t SecCmsContentInfoSetContentDigestedData(unint64_t *a1, unint64_t a2)
{
  return SecCmsContentInfoSetContent(a1, 0x1Du, a2);
}

uint64_t SecCmsContentInfoSetContentEncryptedData(unint64_t *a1, unint64_t a2)
{
  return SecCmsContentInfoSetContent(a1, 0x1Eu, a2);
}

uint64_t SecCmsContentInfoSetContentOther(uint64_t a1, _QWORD *a2, int a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t result;

  if (SECITEM_CopyItem(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 120), (unint64_t *)a1, a4))
    return 4294967188;
  pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
  v8 = PORT_ArenaAlloc(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 120), 0x28uLL);
  if (v8)
  {
    *(_QWORD *)(v8 + 32) = 0;
    *(_OWORD *)v8 = 0u;
    *(_OWORD *)(v8 + 16) = 0u;
  }
  *(_QWORD *)(a1 + 32) = v8;
  *(_OWORD *)v8 = xmmword_1E1FD0430;
  *(_OWORD *)(v8 + 16) = unk_1E1FD0440;
  *(_QWORD *)(v8 + 32) = 0;
  if (SECITEM_CopyItem(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 120), *(unint64_t **)(a1 + 32), a4))
    return 4294967188;
  *(_QWORD *)(a1 + 16) = a2;
  if (a3)
  {
    a2 = 0;
  }
  else if (!a2)
  {
    a2 = SECITEM_AllocItem(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 120), 0, 1uLL);
  }
  result = 0;
  *(_QWORD *)(a1 + 72) = a2;
  return result;
}

uint64_t SecCmsContentInfoGetContent(uint64_t result)
{
  uint64_t v1;
  unsigned int v2;
  BOOL v3;
  int v4;

  if (result)
  {
    v1 = *(_QWORD *)(result + 32);
    if (!v1)
      return 0;
    v2 = *(_DWORD *)(v1 + 16);
    v3 = v2 > 0x1E;
    v4 = (1 << v2) & 0x6E000000;
    if (v3 || v4 == 0)
      return 0;
    else
      return *(_QWORD *)(result + 16);
  }
  return result;
}

uint64_t SecCmsContentInfoGetInnerContent(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  unsigned int v4;
  uint64_t v5;
  unsigned int v6;
  BOOL v7;
  int v8;

  v1 = a1;
  v2 = *(_QWORD *)(a1 + 32);
  if (v2 || (result = SECOID_FindOID(a1), v2 = result, (*(_QWORD *)(v1 + 32) = result) != 0))
  {
    result = 0;
    v4 = *(_DWORD *)(v2 + 16);
    if (v4 <= 0x1E)
    {
      if (((1 << v4) & 0x6C000000) != 0)
      {
        result = SecCmsContentInfoGetChildContentInfo(v1);
        if (!result)
          return result;
        v1 = result;
        v5 = *(_QWORD *)(result + 32);
        if (!v5)
          return 0;
        v6 = *(_DWORD *)(v5 + 16);
        v7 = v6 > 0x1E;
        v8 = (1 << v6) & 0x6E000000;
        if (v7 || v8 == 0)
          return 0;
      }
      else if (v4 != 25)
      {
        return result;
      }
      return *(_QWORD *)(v1 + 16);
    }
  }
  return result;
}

uint64_t SecCmsContentInfoGetContentTypeOID(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (!result)
  {
    result = SECOID_FindOID(a1);
    *(_QWORD *)(a1 + 32) = result;
  }
  return result;
}

uint64_t SecCmsContentInfoGetContentEncAlgTag(uint64_t a1)
{
  uint64_t result;

  result = *(unsigned int *)(a1 + 92);
  if (!(_DWORD)result)
  {
    if (*(_QWORD *)(a1 + 48))
    {
      result = SECOID_FindOID(a1 + 40);
      if (result)
        result = *(unsigned int *)(result + 16);
    }
    else
    {
      result = 0;
    }
    *(_DWORD *)(a1 + 92) = result;
  }
  return result;
}

uint64_t SecCmsContentInfoGetContentEncAlg(uint64_t a1)
{
  return a1 + 40;
}

uint64_t SecCmsContentInfoSetContentEncAlg(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  uint64_t result;

  result = SECOID_SetAlgorithmID(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 120), (unint64_t *)(a1 + 40), a2, a3);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 88) = a4;
  return result;
}

uint64_t SecCmsContentInfoSetContentEncAlgID(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;

  if (SECOID_CopyAlgorithmID(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 120), (unint64_t *)(a1 + 40), a2))return 0xFFFFFFFFLL;
  result = 0;
  if ((a3 & 0x80000000) == 0)
    *(_DWORD *)(a1 + 88) = a3;
  return result;
}

void SecCmsContentInfoSetBulkKey(uint64_t a1, CFTypeRef cf)
{
  CFIndex Length;
  int v5;
  const void *v6;

  if (cf)
  {
    CFRetain(cf);
    if (a1)
    {
      *(_QWORD *)(a1 + 80) = cf;
      Length = CFDataGetLength((CFDataRef)cf);
      if (Length > 0xFFFFFFF)
      {
        v6 = *(const void **)(a1 + 80);
        if (v6)
        {
          *(_QWORD *)(a1 + 80) = 0;
          CFRelease(v6);
        }
        v5 = 0;
      }
      else
      {
        v5 = 8 * Length;
      }
      *(_DWORD *)(a1 + 88) = v5;
    }
  }
}

uint64_t SecCmsContentInfoGetBulkKey(uint64_t a1)
{
  uint64_t v1;

  if (!a1)
    return 0;
  v1 = *(_QWORD *)(a1 + 80);
  if (v1)
    CFRetain(*(CFTypeRef *)(a1 + 80));
  return v1;
}

uint64_t SecCmsContentInfoGetBulkKeySize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

uint64_t SecCmsAttributeCreate(uint64_t a1, unsigned int a2, unint64_t *a3, char a4)
{
  uint64_t result;
  uint64_t v9;
  char *v10;
  uint64_t v11;

  result = PORT_ArenaAlloc(a1, 0x28uLL);
  if (result)
  {
    v9 = result;
    *(_QWORD *)(result + 32) = 0;
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
    result = 0;
    v10 = a2 <= 0xD8 ? &oids[40 * a2] : 0;
    *(_QWORD *)(v9 + 24) = v10;
    if (a2 <= 0xD8)
    {
      if (SECITEM_CopyItem(a1, (unint64_t *)v9, (uint64_t)v10))
        return 0;
      if (!a3)
      {
LABEL_13:
        *(_BYTE *)(v9 + 32) = a4;
        return v9;
      }
      result = (uint64_t)SECITEM_AllocItem(a1, 0, *a3);
      if (result)
      {
        v11 = result;
        if (SECITEM_CopyItem(a1, (unint64_t *)result, (uint64_t)a3)
          || SecCmsArrayAdd(a1, (char **)(v9 + 16), v11))
        {
          return 0;
        }
        goto LABEL_13;
      }
    }
  }
  return result;
}

uint64_t SecCmsAttributeArrayAddAttr(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  uint64_t OID;
  unsigned int v7;
  uint64_t result;

  OID = SECOID_FindOID(a3);
  if (OID)
    v7 = *(_DWORD *)(OID + 16);
  else
    v7 = 0;
  if (SecCmsAttributeArrayFindAttrByOidTag(*a2, v7, 0))
    return 0xFFFFFFFFLL;
  result = SecCmsArrayAdd(a1, (char **)a2, a3);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t SecCmsAttributeArraySetAttr(uint64_t a1, uint64_t **a2, unsigned int a3, unint64_t *a4)
{
  uint64_t AttrByOidTag;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;

  AttrByOidTag = SecCmsAttributeArrayFindAttrByOidTag(*a2, a3, 0);
  if (AttrByOidTag)
  {
    v9 = AttrByOidTag;
    result = 0;
    **(_QWORD **)(v9 + 16) = a4;
    *(_BYTE *)(v9 + 32) = 0;
  }
  else
  {
    v11 = SecCmsAttributeCreate(a1, a3, a4, 0);
    if (!v11)
      return 0xFFFFFFFFLL;
    result = SecCmsArrayAdd(a1, (char **)a2, v11);
    if ((_DWORD)result)
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t SecCmsCipherContextStart(uint64_t a1, CFDataRef theData, uint64_t a3, int a4)
{
  uint64_t result;
  uint64_t v9;
  int v10;
  CCAlgorithm v11;
  uint64_t v13;
  int v14;
  void *v15;
  const UInt8 *BytePtr;
  CFIndex Length;
  _CCCryptor *v18;
  uint64_t v19;
  void *v20;
  CCCryptorRef cryptorRef;
  uint64_t v22;
  void *iv;
  _QWORD v24[3];

  v24[2] = *MEMORY[0x1E0C80C00];
  v24[0] = 0xAAAAAAAAAAAAAAAALL;
  v24[1] = 0xAAAAAAAAAAAAAAAALL;
  v22 = 8;
  iv = v24;
  cryptorRef = 0;
  if (CFDataGetLength(theData) < 0)
    return 0;
  result = SECOID_FindOID(a3);
  if (!result)
    return result;
  v9 = result;
  result = 0;
  v10 = *(_DWORD *)(v9 + 16);
  v11 = 1;
  if (v10 > 183)
  {
    if ((v10 - 184) > 4 || ((1 << (v10 + 72)) & 0x15) == 0)
      return result;
    v11 = 0;
    v13 = 16;
    v22 = 16;
    v14 = 16;
    if (!a4)
      goto LABEL_23;
LABEL_13:
    if (CCRandomCopyBytes())
      return 0;
    if (v10 <= 0xE && ((1 << v10) & 0x5EC0) != 0
      || (result = 0, (v10 - 153) <= 0x23)
      && ((1 << (v10 + 103)) & 0xFC0000001) != 0)
    {
      result = (uint64_t)SEC_ASN1EncodeItem(a1, (_QWORD *)(a3 + 16), (uint64_t)&v22, (uint64_t)kSecAsn1OctetStringTemplate);
      if (result)
        goto LABEL_31;
    }
    return result;
  }
  switch(v10)
  {
    case 5:
      v11 = 5;
      break;
    case 7:
      v11 = 2;
      break;
    case 10:
      break;
    default:
      return result;
  }
  v13 = 8;
  v14 = 8;
  if (a4)
    goto LABEL_13;
LABEL_23:
  if (v10 <= 0xE && ((1 << v10) & 0x5EC0) != 0
    || (result = 0, (v10 - 153) <= 0x23) && ((1 << (v10 + 103)) & 0xFC0000001) != 0)
  {
    v19 = 0;
    v20 = 0;
    if (!SEC_ASN1Decode(0, (uint64_t)&v19, (uint64_t)kSecAsn1OctetStringTemplate, *(char **)(a3 + 24), *(_QWORD *)(a3 + 16)))
    {
      v15 = v20;
      if (v13 == v19)
      {
        __memcpy_chk();
        if (v15)
          free(v15);
LABEL_31:
        BytePtr = CFDataGetBytePtr(theData);
        Length = CFDataGetLength(theData);
        if (CCCryptorCreate(a4 == 0, v11, 1u, BytePtr, Length, iv, &cryptorRef))
        {
          v18 = cryptorRef;
        }
        else
        {
          result = (uint64_t)PORT_ZAlloc(0x10uLL);
          v18 = cryptorRef;
          if (result)
          {
            *(_QWORD *)result = cryptorRef;
            *(_BYTE *)(result + 8) = a4;
            *(_DWORD *)(result + 12) = v14;
            return result;
          }
        }
        if (v18)
          CCCryptorRelease(v18);
        return 0;
      }
      if (v20)
        free(v20);
    }
    return 0;
  }
  return result;
}

uint64_t SecCmsCipherContextCrypt(CCCryptorRef *a1, char *dataOut, _DWORD *a3, size_t dataOutAvailable, void *dataIn, size_t dataInLength, int a7)
{
  unsigned int v8;
  uint64_t v12;
  _QWORD *ThreadErrInfo;
  size_t v15;
  size_t dataOutMoved;

  v8 = dataOutAvailable;
  dataOutMoved = 0;
  if ((_DWORD)dataInLength)
  {
    v12 = CCCryptorUpdate(*a1, dataIn, dataInLength, dataOut, dataOutAvailable, &dataOutMoved);
    if (!a7)
      goto LABEL_7;
  }
  else
  {
    v12 = 0;
    if (!a7)
      goto LABEL_7;
  }
  if (!(_DWORD)v12)
  {
    v15 = 0;
    v12 = CCCryptorFinal(*a1, &dataOut[dataOutMoved], v8 - dataOutMoved, &v15);
    dataOutMoved += v15;
  }
LABEL_7:
  if ((_DWORD)v12)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, (int *)&v15);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0xFFFFE00200000000;
  }
  else if (a3)
  {
    *a3 = dataOutMoved;
  }
  return v12;
}

_QWORD *PL_NewHashTable(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _OWORD *v6;

  v4 = defaultHashAllocOps(0, 0x38uLL);
  v5 = v4;
  if (v4)
  {
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    v4[6] = 0;
    *((_OWORD *)v4 + 2) = 0u;
    *((_DWORD *)v4 + 3) = 28;
    v6 = defaultHashAllocOps(0, 0x80uLL);
    *v5 = v6;
    if (v6)
    {
      v6[6] = 0u;
      v6[7] = 0u;
      v6[4] = 0u;
      v6[5] = 0u;
      v6[2] = 0u;
      v6[3] = 0u;
      *v6 = 0u;
      v6[1] = 0u;
      v5[2] = a1;
      v5[3] = a2;
      v5[4] = PL_CompareValues;
      v5[5] = &defaultHashAllocOps;
      v5[6] = 0;
    }
    else
    {
      off_1EDF77E38(0, v5);
      return 0;
    }
  }
  return v5;
}

void *DefaultAllocTable(uint64_t a1, unint64_t a2)
{
  size_t v2;

  if (a2 <= 1)
    v2 = 1;
  else
    v2 = a2;
  return malloc_type_malloc(v2, 0x7C9B19FDuLL);
}

void DefaultFreeTable(int a1, void *a2)
{
  free(a2);
}

void *DefaultAllocEntry()
{
  return malloc_type_malloc(0x20uLL, 0x7C9B19FDuLL);
}

void DefaultFreeEntry(int a1, void *a2, int a3)
{
  if (a3 == 1)
    free(a2);
}

uint64_t *PL_HashTableRawLookup(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v8;
  uint64_t *v9;

  v3 = (uint64_t *)(*(_QWORD *)a1 + 8 * ((-1640531527 * a2) >> *(_DWORD *)(a1 + 12)));
  v4 = *v3;
  if (*v3)
  {
    v8 = (uint64_t *)(*(_QWORD *)a1 + 8 * ((-1640531527 * a2) >> *(_DWORD *)(a1 + 12)));
    while (1)
    {
      v9 = (uint64_t *)v4;
      if (*(_DWORD *)(v4 + 8) == a2)
      {
        if ((*(unsigned int (**)(uint64_t, _QWORD))(a1 + 24))(a3, *(_QWORD *)(v4 + 16)))
          break;
      }
      v4 = *v9;
      v8 = v9;
      if (!*v9)
        return v9;
    }
    if (v8 != v3)
    {
      *v8 = *v9;
      *v9 = *v3;
      *v3 = (uint64_t)v9;
    }
  }
  return v3;
}

BOOL PL_CompareValues(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t cmsAppendToArray(uint64_t cf, CFMutableArrayRef *a2, uint64_t a3)
{
  const void *v5;
  CFTypeID v6;
  CFRange v7;

  if (cf)
  {
    v5 = (const void *)cf;
    if (!*a2)
      *a2 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    v6 = CFGetTypeID(v5);
    if (v6 == CFArrayGetTypeID())
    {
      v7.length = CFArrayGetCount((CFArrayRef)v5);
      v7.location = 0;
      CFArrayAppendArray(*a2, (CFArrayRef)v5, v7);
      return 0;
    }
    if (v6 == a3)
    {
      CFArrayAppendValue(*a2, v5);
      return 0;
    }
    return 4294967246;
  }
  return cf;
}

uint64_t cmsRtnToOSStatusDefault(uint64_t a1, unsigned int a2)
{
  uint64_t Error;
  _QWORD *ThreadErrInfo;
  int v5;
  int v7;

  Error = a1;
  if ((_DWORD)a1 == -1)
  {
    Error = PORT_GetError();
    ThreadErrInfo = PR_getThreadErrInfo(1, &v7);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0;
    if (!(_DWORD)Error)
    {
LABEL_13:
      if (a2)
        return a2;
      else
        return 4294965226;
    }
  }
  if ((Error + 0x2000) > 0x3E7)
    return Error;
  if ((int)Error > -8106)
  {
    switch((_DWORD)Error)
    {
      case 0xFFFFE057:
        return 4294967168;
      case 0xFFFFE05A:
        return 4294899565;
      case 0xFFFFE08C:
        return 4294941988;
    }
    goto LABEL_13;
  }
  v5 = Error + 0x2000;
  Error = 4294942039;
  switch(v5)
  {
    case 0:
      Error = 4294967260;
      break;
    case 2:
    case 9:
      return Error;
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      Error = 4294967246;
      break;
    case 10:
    case 47:
      Error = 4294899608;
      break;
    case 11:
    case 30:
      Error = 4294899478;
      break;
    case 12:
      Error = 4294899476;
      break;
    case 13:
    case 20:
    case 21:
      Error = 4294899453;
      break;
    case 19:
      Error = 4294967188;
      break;
    case 38:
      return 4294899565;
    case 39:
      Error = 4294965226;
      break;
    default:
      goto LABEL_13;
  }
  return Error;
}

uint64_t SecCmsSignerInfoCreateWithSubjKeyID(uint64_t a1, uint64_t a2, const void *a3, const void *a4, unsigned int a5)
{
  return nss_cmssignerinfo_create(a1, 1, 0, a2, a3, a4, a5);
}

uint64_t nss_cmssignerinfo_create(uint64_t a1, int a2, const void *a3, uint64_t a4, const void *a5, const void *a6, unsigned int a7)
{
  uint64_t v14;
  _OWORD *v15;
  uint64_t v16;
  _QWORD *CertIssuerAndSN;
  unint64_t *v18;
  unint64_t v19;
  uint64_t OID;
  unsigned int v21;

  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 120);
  v15 = (_OWORD *)PORT_ArenaAlloc(v14, 0xD0uLL);
  v16 = (uint64_t)v15;
  if (!v15)
    return v16;
  v15[11] = 0u;
  v15[12] = 0u;
  v15[9] = 0u;
  v15[10] = 0u;
  v15[7] = 0u;
  v15[8] = 0u;
  v15[5] = 0u;
  v15[6] = 0u;
  v15[3] = 0u;
  v15[4] = 0u;
  v15[1] = 0u;
  v15[2] = 0u;
  *v15 = 0u;
  *((_QWORD *)v15 + 16) = a1;
  if (a2 != 1)
  {
    if (a2)
      return 0;
    if (!a3)
      return 0;
    CFRetain(a3);
    *(_QWORD *)(v16 + 136) = a3;
    CertIssuerAndSN = CERT_GetCertIssuerAndSN(v14, (const __CFData *)a3);
    *(_QWORD *)(v16 + 24) = CertIssuerAndSN;
    if (!a6 || !CertIssuerAndSN)
      return 0;
    goto LABEL_12;
  }
  *((_DWORD *)v15 + 4) = 1;
  if (!a4)
    return 0;
  v18 = (unint64_t *)PORT_ArenaAlloc(v14, 0x10uLL);
  *(_QWORD *)(v16 + 24) = v18;
  if (SECITEM_CopyItem(v14, v18, a4))
    return 0;
  if (!a5)
  {
    *(_QWORD *)(v16 + 176) = 0;
    return 0;
  }
  CFRetain(a5);
  *(_QWORD *)(v16 + 176) = a5;
  if (!a6)
    return 0;
LABEL_12:
  CFRetain(a6);
  *(_QWORD *)(v16 + 168) = a6;
  if (*(_DWORD *)(v16 + 16) == 1)
    v19 = 3;
  else
    v19 = 1;
  SEC_ASN1EncodeInteger(v14, (_QWORD *)v16, v19);
  if (SECOID_SetAlgorithmID(v14, (unint64_t *)(v16 + 32), a7, 0)
    || SecCmsArrayAdd(*(_QWORD *)(*(_QWORD *)(a1 + 24) + 120), (char **)(a1 + 160), v16))
  {
    return 0;
  }
  OID = SECOID_FindOID(v16 + 32);
  v21 = OID ? *(_DWORD *)(OID + 16) : 0;
  if (SecCmsSignedDataSetDigestValue((_QWORD *)a1, v21, 0))
    return 0;
  return v16;
}

uint64_t SecCmsSignerInfoCreate(uint64_t a1, uint64_t a2, unsigned int a3)
{
  const void *v6;
  void *v7;
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const void *Value;
  const void *v11;
  CFTypeID v12;
  uint64_t v13;

  v6 = *(const void **)(a2 + 16);
  CFRetain(v6);
  v7 = *(void **)(a2 + 24);
  CFRetain(v7);
  v8 = SecKeyCopyAttributes((SecKeyRef)v7);
  v9 = v8;
  if (!v8
    || (Value = CFDictionaryGetValue(v8, CFSTR("kcls"))) == 0
    || (v11 = Value, v12 = CFGetTypeID(Value), v12 != CFStringGetTypeID())
    || !CFEqual(v11, CFSTR("1")))
  {
    v13 = 0;
    if (!v6)
      goto LABEL_9;
    goto LABEL_8;
  }
  v13 = nss_cmssignerinfo_create(a1, 0, v6, 0, 0, v7, a3);
  if (v6)
LABEL_8:
    CFRelease(v6);
LABEL_9:
  if (v7)
    CFRelease(v7);
  if (v9)
    CFRelease(v9);
  return v13;
}

uint64_t SecCmsSignerInfoGetDigestAlgTag(uint64_t a1)
{
  uint64_t result;

  result = SECOID_FindOID(a1 + 32);
  if (result)
    return *(unsigned int *)(result + 16);
  return result;
}

uint64_t SecCmsSignerInfoGetVerificationStatus(uint64_t a1)
{
  return *(unsigned int *)(a1 + 160);
}

uint64_t SecCmsSignerInfoGetDigestAlg(uint64_t a1)
{
  return SECOID_FindOID(a1 + 32);
}

uint64_t SecCmsSignerInfoGetCertList(uint64_t a1)
{
  return *(_QWORD *)(a1 + 144);
}

const void *SecCmsSignerInfoGetSignerCommonName(uint64_t a1)
{
  const void *SigningCert_internal;
  const __CFArray *v2;
  const __CFArray *v3;
  CFIndex Count;
  const void *ValueAtIndex;
  const void *v6;

  SigningCert_internal = SecCmsSignerInfoGetSigningCert_internal(a1);
  if (!SigningCert_internal)
    return 0;
  v2 = SecCertificateCopyCommonNames((uint64_t)SigningCert_internal);
  if (!v2)
    return 0;
  v3 = v2;
  Count = CFArrayGetCount(v2);
  ValueAtIndex = CFArrayGetValueAtIndex(v3, Count - 1);
  v6 = ValueAtIndex;
  if (ValueAtIndex)
    CFRetain(ValueAtIndex);
  CFRelease(v3);
  return v6;
}

const void *SecCmsSignerInfoGetSignerEmailAddress(uint64_t a1)
{
  const void *SigningCert_internal;
  const __CFArray *v2;
  const __CFArray *v3;
  const void *ValueAtIndex;
  const void *v5;

  SigningCert_internal = SecCmsSignerInfoGetSigningCert_internal(a1);
  if (!SigningCert_internal)
    return 0;
  v2 = SecCertificateCopyRFC822Names((uint64_t)SigningCert_internal);
  if (!v2)
    return 0;
  v3 = v2;
  if (CFArrayGetCount(v2) < 1)
  {
    v5 = 0;
  }
  else
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v3, 0);
    v5 = ValueAtIndex;
    if (ValueAtIndex)
      CFRetain(ValueAtIndex);
  }
  CFRelease(v3);
  return v5;
}

uint64_t SecCmsSignerInfoAddSigningTime(uint64_t a1, CFAbsoluteTime a2)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  _QWORD v6[3];
  unint64_t v7[2];

  v7[0] = 0;
  v7[1] = 0;
  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120);
  memset(v6, 170, sizeof(v6));
  if (SecAsn1EncodeTime(v3, (uint64_t)v6, a2))
    return 4294941020;
  if (SEC_ASN1EncodeItem(v3, v7, (uint64_t)v6, (uint64_t)&kSecAsn1TimeTemplate) != v7)
    return 4294941020;
  v5 = SecCmsAttributeCreate(v3, 0x23u, v7, 1);
  if (!v5)
    return 4294941020;
  result = SecCmsAttributeArrayAddAttr(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120), (uint64_t **)(a1 + 64), v5);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t SecCmsSignerInfoAddSMIMECaps(uint64_t a1)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t *v4;
  void *v5;
  _QWORD *v6;
  int v7;
  uint64_t *v8;
  uint64_t i;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t result;
  uint64_t v23;
  uint64_t v24;
  void *v25;

  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120);
  v3 = SECITEM_AllocItem(v2, 0, 0);
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = v3;
  v5 = PORT_ZAlloc(0x50uLL);
  v25 = v5;
  if (!v5)
    return 0xFFFFFFFFLL;
  v6 = v5;
  v23 = v2;
  v24 = a1;
  v7 = 0;
  v8 = &qword_1E1FD0800;
  for (i = 8; i != -1; --i)
  {
    if (((0xDuLL >> i) & 1) == 0)
    {
      v10 = *(v8 - 2);
      if (v10 != 65561)
      {
        v11 = PORT_ZAlloc(0x28uLL);
        if (!v11)
          break;
        v12 = v11;
        v6[v7] = v11;
        v13 = *((_DWORD *)v8 - 2);
        pthread_once(&hash_once, (void (*)(void))InitOIDHashOnce);
        v14 = *(_QWORD *)&oids[40 * v13 + 8];
        *v12 = *(_QWORD *)&oids[40 * v13];
        v12[1] = v14;
        if (((0x1F2uLL >> i) & 1) != 0)
        {
          v15 = 0;
          v16 = 0;
        }
        else
        {
          v16 = *(_QWORD *)*v8;
          v15 = *(_QWORD *)(*v8 + 8);
        }
        ++v7;
        v12[2] = v16;
        v12[3] = v15;
        v12[4] = v10;
      }
    }
    v8 -= 4;
  }
  v6[v7] = 0;
  v17 = SEC_ASN1EncodeItem(v23, v4, (uint64_t)&v25, (uint64_t)&NSSSMIMECapabilitiesTemplate);
  v18 = v25;
  v19 = *(void **)v25;
  if (*(_QWORD *)v25)
  {
    v20 = 8;
    do
    {
      free(v19);
      v18 = v25;
      v19 = *(void **)((char *)v25 + v20);
      v20 += 8;
    }
    while (v19);
  }
  free(v18);
  if (!v17)
    return 0xFFFFFFFFLL;
  v21 = SecCmsAttributeCreate(v23, 0x28u, v4, 1);
  if (!v21)
    return 0xFFFFFFFFLL;
  result = SecCmsAttributeArrayAddAttr(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v24 + 128) + 24) + 120), (uint64_t **)(v24 + 64), v21);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t SecCmsSignerInfoAddSMIMEEncKeyPrefs_internal(uint64_t a1, const __CFData *a2)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  _DWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t result;
  unint64_t v12;

  v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120);
  v5 = SECITEM_AllocItem(v4, 0, 0);
  if (!v5)
    return 0xFFFFFFFFLL;
  v12 = 0xAAAAAAAA00000000;
  if (!a2)
    return 0xFFFFFFFFLL;
  v6 = v5;
  v7 = PORT_NewArena(1024);
  if (!v7)
    return 0xFFFFFFFFLL;
  v8 = v7;
  if (!CERT_GetCertIssuerAndSN((uint64_t)v7, a2))
  {
    PORT_FreeArena(v8, 0);
    return 0xFFFFFFFFLL;
  }
  v9 = SEC_ASN1EncodeItem(v4, v6, (uint64_t)&v12, (uint64_t)&smime_encryptionkeypref_template);
  PORT_FreeArena(v8, 0);
  if (!v9)
    return 0xFFFFFFFFLL;
  v10 = SecCmsAttributeCreate(v4, 0xB6u, v6, 1);
  if (!v10)
    return 0xFFFFFFFFLL;
  result = SecCmsAttributeArrayAddAttr(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120), (uint64_t **)(a1 + 64), v10);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t SecCmsSignerInfoAddMSSMIMEEncKeyPrefs_internal(uint64_t a1, const __CFData *a2)
{
  uint64_t v4;
  unint64_t *v5;
  BOOL v6;
  unint64_t *v7;
  _DWORD *v8;
  _QWORD *v9;
  _QWORD *CertIssuerAndSN;
  _QWORD *v11;
  uint64_t v12;
  uint64_t result;

  v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120);
  v5 = SECITEM_AllocItem(v4, 0, 0);
  if (v5)
    v6 = a2 == 0;
  else
    v6 = 1;
  if (v6)
    return 0xFFFFFFFFLL;
  v7 = v5;
  v8 = PORT_NewArena(1024);
  if (!v8)
    return 0xFFFFFFFFLL;
  v9 = v8;
  CertIssuerAndSN = CERT_GetCertIssuerAndSN((uint64_t)v8, a2);
  if (!CertIssuerAndSN)
  {
    PORT_FreeArena(v9, 0);
    return 0xFFFFFFFFLL;
  }
  v11 = SEC_ASN1EncodeItem(v4, v7, (uint64_t)CertIssuerAndSN, (uint64_t)&SecCmsIssuerAndSNTemplate);
  PORT_FreeArena(v9, 0);
  if (!v11)
    return 0xFFFFFFFFLL;
  v12 = SecCmsAttributeCreate(v4, 0xBEu, v7, 1);
  if (!v12)
    return 0xFFFFFFFFLL;
  result = SecCmsAttributeArrayAddAttr(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120), (uint64_t **)(a1 + 64), v12);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t SecCmsSignerInfoAddCounterSignature()
{
  return 0xFFFFFFFFLL;
}

uint64_t SecCmsSignerInfoAddAppleCodesigningHashAgility(uint64_t a1, CFDataRef theData)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  unint64_t v7[2];

  if (!theData)
    return 4294967246;
  v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120);
  if (CFDataGetLength(theData) < 0)
    return 4294967246;
  v7[0] = CFDataGetLength(theData);
  v7[1] = (unint64_t)CFDataGetBytePtr(theData);
  v5 = SecCmsAttributeCreate(v4, 0xD6u, v7, 0);
  if (!v5)
    return 4294967188;
  result = SecCmsAttributeArrayAddAttr(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120), (uint64_t **)(a1 + 64), v5);
  if ((_DWORD)result)
    return 4294941020;
  return result;
}

uint64_t SecCmsSignerInfoAddAppleCodesigningHashAgilityV2(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[6];
  _QWORD v9[3];
  unint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  unint64_t v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x2000000000;
  v10 = 0xAAAAAAAAAAAAAAAALL;
  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120);
  v10 = v3;
  if (a2)
  {
    v5 = SecCmsAttributeCreate(v3, 0xD7u, 0, 1);
    v12[3] = v5;
    if (v5)
    {
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 0x40000000;
      v8[2] = __SecCmsSignerInfoAddAppleCodesigningHashAgilityV2_block_invoke;
      v8[3] = &unk_1E1FD1420;
      v8[4] = v9;
      v8[5] = &v11;
      CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)apply_block_2, v8);
      if (SecCmsAttributeArrayAddAttr(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120), (uint64_t **)(a1 + 64), v12[3]))v6 = 4294941020;
      else
        v6 = 0;
    }
    else
    {
      v6 = 4294967188;
    }
  }
  else
  {
    v6 = 4294967246;
  }
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(&v11, 8);
  return v6;
}

uint64_t apply_block_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t SecCmsSignerInfoAddAppleExpirationTime(uint64_t a1, CFAbsoluteTime a2)
{
  uint64_t v3;
  uint64_t result;
  uint64_t v5;
  _QWORD v6[3];
  unint64_t v7[2];

  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120);
  v7[0] = 0;
  v7[1] = 0;
  memset(v6, 170, sizeof(v6));
  if (SecAsn1EncodeTime(v3, (uint64_t)v6, a2))
    return 4294941020;
  if (SEC_ASN1EncodeItem(v3, v7, (uint64_t)v6, (uint64_t)&kSecAsn1TimeTemplate) != v7)
    return 4294941020;
  v5 = SecCmsAttributeCreate(v3, 0xD8u, v7, 1);
  if (!v5)
    return 4294941020;
  result = SecCmsAttributeArrayAddAttr(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 24) + 120), (uint64_t **)(a1 + 64), v5);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t *SecCmsSignerInfoCopyCertFromEncryptionKeyPreference(uint64_t a1)
{
  uint64_t v2;
  int64_t **v3;
  uint64_t *result;
  uint64_t AttrByOidTag;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;

  if (*(_DWORD *)(a1 + 160) != 1)
    return 0;
  v2 = *(_QWORD *)(a1 + 128);
  if (v2)
    v3 = *(int64_t ***)(v2 + 144);
  else
    v3 = 0;
  result = *(uint64_t **)(a1 + 64);
  if (result)
  {
    if (*result)
    {
      AttrByOidTag = SecCmsAttributeArrayFindAttrByOidTag(result, 0xB6u, 1);
      if (!AttrByOidTag)
        goto LABEL_13;
      v6 = *(_QWORD *)(AttrByOidTag + 16);
      v7 = *(_QWORD **)v6;
      if (*(_QWORD *)v6 && v7[1] && *v7 && !*(_QWORD *)(v6 + 8))
      {
        result = (uint64_t *)SecSMIMEGetCertFromEncryptionKeyPreference(v3, (uint64_t)v7);
        if (result)
          return result;
LABEL_13:
        result = *(uint64_t **)(a1 + 64);
        if (!result)
          return result;
        if (*result)
        {
          result = (uint64_t *)SecCmsAttributeArrayFindAttrByOidTag(result, 0xBEu, 1);
          if (!result)
            return result;
          v8 = result[2];
          v9 = *(_QWORD **)v8;
          if (*(_QWORD *)v8 && v9[1] && *v9 && !*(_QWORD *)(v8 + 8))
            return (uint64_t *)SecSMIMEGetCertFromEncryptionKeyPreference(v3, (uint64_t)v9);
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t SecCmsSignerInfoSaveSMIMEProfile()
{
  return 4294967292;
}

uint64_t SecCmsSignerInfoIncludeCerts(uint64_t a1, int a2)
{
  const void *v4;
  CFArrayRef v5;
  void *v6;
  int v7;
  int v8;
  void *values;

  if (!*(_QWORD *)(a1 + 136))
    return 0xFFFFFFFFLL;
  v4 = *(const void **)(a1 + 144);
  if (v4)
  {
    *(_QWORD *)(a1 + 144) = 0;
    CFRelease(v4);
  }
  switch(a2)
  {
    case 0:
      *(_QWORD *)(a1 + 144) = 0;
      return 0;
    case 1:
      values = *(void **)(a1 + 136);
      if (values)
        v5 = CFArrayCreate(0, (const void **)&values, 1, MEMORY[0x1E0C9B378]);
      else
        v5 = 0;
      goto LABEL_14;
    case 2:
      v6 = *(void **)(a1 + 136);
      v7 = 0;
      goto LABEL_11;
    case 3:
      v6 = *(void **)(a1 + 136);
      v7 = 1;
LABEL_11:
      v8 = 0;
      goto LABEL_13;
    case 4:
      v6 = *(void **)(a1 + 136);
      v7 = 1;
      v8 = 1;
LABEL_13:
      v5 = CERT_CertChainFromCert(v6, v7, v8);
LABEL_14:
      *(_QWORD *)(a1 + 144) = v5;
      break;
    default:
      v5 = *(CFArrayRef *)(a1 + 144);
      break;
  }
  if (v5)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t SOSRKNullKey()
{
  if (SOSRKNullKey_onceToken != -1)
    dispatch_once(&SOSRKNullKey_onceToken, &__block_literal_global_5072);
  return SOSRKNullKey_localNullKey;
}

uint64_t SOSBackupSliceKeyBagGetTypeID()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __SOSBackupSliceKeyBagGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSBackupSliceKeyBagGetTypeID_sSOSBackupSliceKeyBagGetTypeIDSingleton;
  if (SOSBackupSliceKeyBagGetTypeID_sSOSBackupSliceKeyBagGetTypeIDOnce != -1)
    dispatch_once(&SOSBackupSliceKeyBagGetTypeID_sSOSBackupSliceKeyBagGetTypeIDOnce, block);
  return SOSBackupSliceKeyBagGetTypeID_sSOSBackupSliceKeyBagGetTypeIDSingleton;
}

void SOSBackupSliceKeyBagDestroy(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0;
    CFRelease(v3);
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0;
    CFRelease(v4);
  }
}

__CFString *SOSBackupSliceKeyBagCopyFormatDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  const __CFSet *v4;
  uint64_t v5;
  const __CFSet *v6;
  _QWORD v8[6];
  _QWORD context[5];

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v4 = CFSetCreateMutable(v2, 0, MEMORY[0x1E0C9B3B0]);
  v5 = MEMORY[0x1E0C809B0];
  if (v4)
  {
    v6 = *(const __CFSet **)(a1 + 24);
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 3221225472;
    context[2] = __SOSBackupSliceKeyBagCopyPeerNames_block_invoke;
    context[3] = &__block_descriptor_40_e10_v16__0r_v8l;
    context[4] = v4;
    CFSetApplyFunction(v6, (CFSetApplierFunction)apply_block_1_5075, context);
  }
  v8[0] = v5;
  v8[1] = 3221225472;
  v8[2] = __SOSBackupSliceKeyBagCopyFormatDescription_block_invoke;
  v8[3] = &__block_descriptor_48_e21_v16__0____CFString__8l;
  v8[4] = Mutable;
  v8[5] = a1;
  CFStringSetPerformWithDescription(v4, (uint64_t)v8);
  if (v4)
    CFRelease(v4);
  CFStringAppend(Mutable, CFSTR(">"));
  return Mutable;
}

__CFString *SOSBackupSliceKeyBagCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();
  return SOSBackupSliceKeyBagCopyFormatDescription(a1);
}

uint64_t apply_block_1_5075(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t der_decode_BackupSliceKeyBag(uint64_t a1, CFTypeRef *a2, CFTypeRef *a3, const UInt8 *a4, uint64_t a5)
{
  uint64_t Instance;
  const UInt8 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFAllocator *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const UInt8 *v17;
  const UInt8 *v19;

  v19 = a4;
  if (!a4)
    return 0;
  SOSBackupSliceKeyBagGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  if (!SecAllocationError(Instance, a3, CFSTR("View bag allocation failed"))
    || (v9 = (const UInt8 *)ccder_decode_sequence_tl(), v19 = v9, a5))
  {
    if (!Instance)
      return 0;
LABEL_11:
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v19 = der_decode_data((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (CFDataRef *)(Instance + 16), a3, (uint64_t)v9, 0, v10, v11, v12);
  *(_QWORD *)(Instance + 24) = SOSPeerInfoSetCreateFromArrayDER(v13, &kSOSPeerSetCallbacks, a3, (uint64_t *)&v19);
  v17 = (const UInt8 *)der_decode_dictionary(v13, (CFMutableDictionaryRef *)(Instance + 32), a3, (uint64_t)v19, 0, v14, v15, v16);
  v19 = v17;
  SecRequirementError(v17 == 0, a3, CFSTR("Extra space in sequence"));
  if (v17 || !a2)
    goto LABEL_11;
  if (*a2)
    CFRelease(*a2);
  *a2 = (CFTypeRef)Instance;
  return 0;
}

uint64_t der_sizeof_BackupSliceKeyBag(const __CFData **a1, CFTypeRef *a2)
{
  const __CFData *v4;
  const __CFData *v5;

  SecRequirementError(a1 != 0, a2, CFSTR("Null BackupSliceKeyBag"));
  if (a1
    && (v4 = a1[2], SecRequirementError(v4 != 0, a2, CFSTR("null aks_bag in BackupSliceKeyBag")), v4)
    && (v5 = a1[2]) != 0
    && (CFDataGetLength(v5), ccder_sizeof_raw_octet_string())
    && SOSPeerInfoSetGetDEREncodedArraySize(a1[3], (uint64_t)a2)
    && der_sizeof_dictionary(a1[4], (uint64_t)a2))
  {
    return ccder_sizeof();
  }
  else
  {
    return 0;
  }
}

uint64_t der_encode_BackupSliceKeyBag(const __CFData **a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  const __CFData *v7;
  const __CFData *v8;
  const __CFSet *v9;
  uint64_t v10;
  uint64_t result;

  if (!a4)
    return 0;
  SecRequirementError(a1 != 0, a2, CFSTR("Null set passed to encode"));
  if (!a1)
    return 0;
  v7 = a1[2];
  SecRequirementError(v7 != 0, a2, CFSTR("Null set passed to encode"));
  if (!v7)
    return 0;
  v8 = a1[2];
  if (!v8)
    return 0;
  v9 = a1[3];
  v10 = der_encode_dictionary_repair(a1[4], a2, 0);
  SOSPeerInfoSetEncodeToArrayDER(v9, (uint64_t)a2, a3, v10);
  der_encode_data(v8, a2);
  result = ccder_encode_constructed_tl();
  if (result != a3)
    return 0;
  return result;
}

CFTypeRef SOSBackupSliceKeyBagCreateFromData(uint64_t a1, CFDataRef theData, CFTypeRef *a3)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v8;
  uint64_t v9;
  CFTypeRef result;
  CFTypeRef cf;

  cf = 0;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v8 = &BytePtr[Length];
  v9 = der_decode_BackupSliceKeyBag(a1, &cf, a3, BytePtr, (uint64_t)&BytePtr[Length]);
  SecRequirementError(v9 == (_QWORD)v8, a3, CFSTR("Didn't consume all data supplied"));
  result = cf;
  if ((const UInt8 *)v9 != v8)
  {
    if (cf)
    {
      cf = 0;
      CFRelease(result);
      return 0;
    }
  }
  return result;
}

BOOL SOSBSKBIsGoodBackupPublic(const __CFData *a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  int v8;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x1E0C80C00];
  v4 = SOSGetBackupKeyCurveParameters();
  MEMORY[0x1E0C80A78](v4);
  if (v6 >= 0x10)
  {
    v7 = (_QWORD *)((char *)v10 - v5);
    do
    {
      *v7 = 0xAAAAAAAAAAAAAAAALL;
      v7[1] = 0xAAAAAAAAAAAAAAAALL;
      v7 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  SOSGetBackupKeyCurveParameters();
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  v8 = ccec_compact_import_pub();
  if (v8)
    SOSErrorCreate(1029, a2, 0, CFSTR("Unable to decode public key: %@"), a1);
  return v8 == 0;
}

__CFData *SOSBSKBCopyEncoded(const __CFData **a1, CFTypeRef *a2)
{
  uint64_t v4;
  CFIndex v5;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  CFIndex Length;

  v4 = der_sizeof_BackupSliceKeyBag(a1, a2);
  if (!v4)
    return 0;
  v5 = v4;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFDataSetLength(Mutable, v5);
  if (!SecAllocationError((uint64_t)Mutable, a2, CFSTR("Faild to create scratch"))
    || (MutableBytePtr = CFDataGetMutableBytePtr(Mutable),
        Length = CFDataGetLength(Mutable),
        MutableBytePtr != (UInt8 *)der_encode_BackupSliceKeyBag(a1, a2, (uint64_t)MutableBytePtr, (uint64_t)&MutableBytePtr[Length])))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

_QWORD *SOSBackupSliceKeyBagCreate(const __CFAllocator *a1, const __CFSet *a2)
{
  CFMutableDictionaryRef Mutable;
  _QWORD *v5;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v5 = SOSBackupSliceKeyBagCreateWithAdditionalKeys(a1, a2, (uint64_t)Mutable, 0);
  if (Mutable)
    CFRelease(Mutable);
  return v5;
}

_QWORD *SOSBackupSliceKeyBagCreateWithAdditionalKeys(const __CFAllocator *a1, const __CFSet *a2, uint64_t a3, CFTypeRef *a4)
{
  _QWORD *Instance;
  CFIndex Count;
  CFMutableSetRef Mutable;
  uint64_t v11;
  const void *v12;
  __int128 v13;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD v22[5];
  _OWORD v23[2];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  SOSBackupSliceKeyBagGetTypeID();
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  if (!SecAllocationError((uint64_t)Instance, a4, CFSTR("View bag allocation failed"))
    || (Count = CFSetGetCount(a2), SecRequirementError(Count > 0, a4, CFSTR("Need peers")), Count < 1))
  {
    if (!Instance)
      return Instance;
LABEL_8:
    CFRelease(Instance);
    return 0;
  }
  Mutable = CFSetCreateMutable(a1, 0, &kSOSPeerSetCallbacks);
  v11 = MEMORY[0x1E0C809B0];
  v15 = MEMORY[0x1E0C809B0];
  v16 = 3221225472;
  v17 = __SOSBackupSliceKeyBagCreatePeerSet_block_invoke;
  v18 = &__block_descriptor_40_e10_v16__0r_v8l;
  v19 = Mutable;
  CFSetApplyFunction(a2, (CFSetApplierFunction)apply_block_1_5075, &v15);
  Instance[3] = Mutable;
  Instance[4] = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v12 = (const void *)Instance[2];
  if (v12)
  {
    Instance[2] = 0;
    CFRelease(v12);
  }
  v17 = __SOSBackupSliceKeyBagCreateBackupBag_block_invoke;
  v18 = &__block_descriptor_56_e11_v24__0Q8_16l;
  v15 = v11;
  v16 = 3221225472;
  v19 = a4;
  v20 = Instance;
  v21 = a3;
  v22[0] = v11;
  v22[1] = 0x40000000;
  v22[2] = __PerformWithBufferAndClear_block_invoke;
  v22[3] = &unk_1E1FDC2B8;
  v22[4] = &v15;
  *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[0] = v13;
  v23[1] = v13;
  __PerformWithBufferAndClear_block_invoke((uint64_t)v22, 0x20uLL, v23);
  if (!Instance[2])
    goto LABEL_8;
  return Instance;
}

void sub_18A9A6F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t apply_block_2_5101(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

__CFData *SOSCopyECWrapped(const __CFData *a1, const __CFData *a2, CFTypeRef *a3)
{
  uint64_t v6;
  uint64_t v7;
  char *v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v6 = SOSGetBackupKeyCurveParameters();
  MEMORY[0x1E0C80A78](v6);
  v8 = (char *)v12 - v7;
  if (v9 >= 0x10)
  {
    v10 = (_QWORD *)((char *)v12 - v7);
    do
    {
      *v10 = 0xAAAAAAAAAAAAAAAALL;
      v10[1] = 0xAAAAAAAAAAAAAAAALL;
      v10 += 2;
      v7 -= 16;
    }
    while (v7);
  }
  SOSGetBackupKeyCurveParameters();
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  if (!ccec_compact_import_pub())
    return SOSCopyECWrappedData((uint64_t)v8, a2, a3);
  SOSErrorCreate(1029, a3, 0, CFSTR("Unable to decode public key: %@"), a1);
  return 0;
}

void CFDataPerformWithHexString(const __CFData *a1, void *a2)
{
  const __CFAllocator *v3;
  CFIndex Length;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex v7;
  CFIndex v8;
  unsigned int v9;
  void (**v10)(id, __CFString *);

  v10 = a2;
  if (a1)
  {
    v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Length = CFDataGetLength(a1);
    Mutable = CFStringCreateMutable(v3, 2 * Length);
    BytePtr = CFDataGetBytePtr(a1);
    v7 = CFDataGetLength(a1);
    if (v7 >= 1)
    {
      v8 = v7;
      do
      {
        v9 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v9);
        --v8;
      }
      while (v8);
    }
  }
  else
  {
    Mutable = CFSTR("(null)");
  }
  v10[2](v10, Mutable);
  CFRelease(Mutable);

}

_QWORD *SOSBackupSliceKeyBagCreateDirect(const __CFAllocator *a1, const void *a2, CFTypeRef *a3)
{
  _QWORD *Instance;

  SOSBackupSliceKeyBagGetTypeID();
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  if (SecAllocationError((uint64_t)Instance, a3, CFSTR("View bag allocation failed"))
    && (SecRequirementError(a2 != 0, a3, CFSTR("Need aks bag")), a2))
  {
    CFRetain(a2);
    Instance[2] = a2;
    Instance[3] = CFSetCreateMutable(a1, 0, &kSOSPeerSetCallbacks);
    Instance[4] = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else if (Instance)
  {
    CFRelease(Instance);
    return 0;
  }
  return Instance;
}

BOOL SOSBSKBIsDirect(uint64_t a1)
{
  return CFSetGetCount(*(CFSetRef *)(a1 + 24)) == 0;
}

uint64_t SOSBSKBCopyAKSBag(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
    CFRetain(*(CFTypeRef *)(a1 + 16));
  return v1;
}

uint64_t SOSBSKBGetPeers(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

const __CFSet *SOSBSKBCountPeers(uint64_t a1)
{
  const __CFSet *result;

  result = *(const __CFSet **)(a1 + 24);
  if (result)
    return (const __CFSet *)CFSetGetCount(result);
  return result;
}

BOOL SOSBSKBPeerIsInKeyBag(uint64_t a1, const void *a2)
{
  return CFSetGetValue(*(CFSetRef *)(a1 + 24), a2) != 0;
}

BOOL SOSBKSBKeyIsInKeyBag(uint64_t a1, const __CFData *a2)
{
  CFStringRef v3;
  CFStringRef v4;
  _BOOL8 v5;

  v3 = SOSCopyIDOfDataBuffer(a2);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), v3) != 0;
  CFRelease(v4);
  return v5;
}

uint64_t SOSBKSBPeerBackupKeyIsInKeyBag(uint64_t a1, const void *a2)
{
  CFMutableDataRef v4;
  const void *Value;
  uint64_t v6;
  CFTypeID v7;
  CFMutableDataRef v8;
  CFMutableDataRef v9;
  _BOOL8 v10;

  v4 = SOSPeerInfoV2DictionaryCopyData((uint64_t)a2, (const void *)sBackupKeyKey);
  Value = CFSetGetValue(*(CFSetRef *)(a1 + 24), a2);
  if (!Value || (v6 = (uint64_t)Value, v7 = CFGetTypeID(Value), v7 != SOSPeerInfoGetTypeID()))
  {
    if (!v4)
      return 1;
    v10 = 0;
    goto LABEL_8;
  }
  v8 = SOSPeerInfoV2DictionaryCopyData(v6, (const void *)sBackupKeyKey);
  v9 = v8;
  if (v4 && v8)
  {
    v10 = CFEqual(v4, v8) != 0;
    CFRelease(v9);
LABEL_8:
    CFRelease(v4);
    return v10;
  }
  v10 = v4 == v8;
  if (v8)
    CFRelease(v8);
  if (v4)
    goto LABEL_8;
  return v10;
}

BOOL SOSBSKBAllPeersBackupKeysAreInKeyBag(uint64_t a1, CFSetRef theSet)
{
  _BOOL8 v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v2 = 1;
  v8 = 1;
  if (a1 && theSet)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 3221225472;
    v4[2] = __SOSBSKBAllPeersBackupKeysAreInKeyBag_block_invoke;
    v4[3] = &unk_1E1FD2620;
    v4[4] = &v5;
    v4[5] = a1;
    CFSetApplyFunction(theSet, (CFSetApplierFunction)apply_block_1_5075, v4);
    v2 = *((_BYTE *)v6 + 24) != 0;
  }
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18A9A7EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL SOSBKSBPrefixedKeyIsInKeyBag(uint64_t a1, const __CFString *a2, const __CFData *a3)
{
  __CFString *v4;
  __CFString *v5;
  _BOOL8 v6;

  v4 = SOSKeyedPubKeyIdentifierCreateWithData(a2, a3);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), v4) != 0;
  CFRelease(v5);
  return v6;
}

uint64_t SOSBSKBLoadLocked(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFIndex Length;
  const UInt8 *BytePtr;
  int v8;
  uint64_t v9;
  BOOL v10;
  unsigned int v12;

  v4 = 0xFFFFFFFFLL;
  v12 = -1;
  v5 = *(_QWORD *)(a1 + 16);
  SecRequirementError(v5 != 0, a2, CFSTR("No aks bag to load"));
  if (v5)
  {
    Length = CFDataGetLength(*(CFDataRef *)(a1 + 16));
    SecRequirementError(Length < 0x7FFFFFFF, a2, CFSTR("No aks bag to load"));
    if (Length > 2147483646)
      return 0xFFFFFFFFLL;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 16));
    v8 = CFDataGetLength(*(CFDataRef *)(a1 + 16));
    v9 = aks_load_bag(BytePtr, v8, &v12);
    v10 = SecKernError(v9, a2, CFSTR("aks_load_bag failed: %d"), v9);
    v4 = v12;
    if (!v10 && v12 != -1)
    {
      aks_unload_bag(v12);
      return 0xFFFFFFFFLL;
    }
  }
  return v4;
}

uint64_t SOSBSKBLoadAndUnlockWithPeerIDAndSecret(uint64_t a1, const void *a2, const __CFData *a3, CFTypeRef *a4)
{
  const void *Value;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[8];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = -1;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  SecRequirementError(Value != 0, a4, CFSTR("%@ has no wrapped key in %@"), a2, a1);
  if (Value)
  {
    v9 = SOSGetBackupKeyCurveParameters();
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 3221225472;
    v12[2] = __SOSBSKBLoadAndUnlockWithPeerIDAndSecret_block_invoke;
    v12[3] = &unk_1E1FD1490;
    v12[4] = &v13;
    v12[5] = Value;
    v12[6] = a4;
    v12[7] = a1;
    SOSPerformWithDeviceBackupFullKey(v9, a3, a4, v12);
  }
  v10 = *((unsigned int *)v14 + 6);
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_18A9A81A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SOSBSKBLoadAndUnlockBagWithSecret(uint64_t a1, unint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8;
  uint64_t v9;
  CFIndex Length;
  const UInt8 *BytePtr;
  int v12;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t v15;
  BOOL v16;
  unsigned int v18;

  v8 = 0xFFFFFFFFLL;
  v18 = -1;
  v9 = *(_QWORD *)(a1 + 16);
  SecRequirementError(v9 != 0, a4, CFSTR("No aks bag to load"));
  if (v9)
  {
    Length = CFDataGetLength(*(CFDataRef *)(a1 + 16));
    SecRequirementError(Length < 0x7FFFFFFF, a4, CFSTR("No aks bag to load"));
    if (Length > 2147483646)
      return 0xFFFFFFFFLL;
    SecRequirementError(a2 >> 31 == 0, a4, CFSTR("secret too big"));
    if (a2 >> 31)
      return 0xFFFFFFFFLL;
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 16));
    v12 = CFDataGetLength(*(CFDataRef *)(a1 + 16));
    v13 = aks_load_bag(BytePtr, v12, &v18);
    v14 = SecKernError(v13, a4, CFSTR("aks_load_bag failed: %d"), v13);
    v8 = v18;
    if (!v14
      || (v15 = aks_unlock_bag(v18, a3, a2),
          v16 = SecKernError(v15, a4, CFSTR("failed to unlock bag: %d"), v15),
          v8 = v18,
          !v16))
    {
      if ((_DWORD)v8 != -1)
      {
        aks_unload_bag(v8);
        return 0xFFFFFFFFLL;
      }
    }
  }
  return v8;
}

uint64_t SOSBSKBLoadAndUnlockWithPeerSecret(uint64_t a1, _QWORD *a2, const __CFData *a3, CFTypeRef *a4)
{
  if (a2)
    a2 = (_QWORD *)a2[5];
  return SOSBSKBLoadAndUnlockWithPeerIDAndSecret(a1, a2, a3, a4);
}

uint64_t SOSBSKBLoadAndUnlockWithDirectSecret(uint64_t a1, const __CFData *a2, CFTypeRef *a3)
{
  CFIndex Count;
  CFIndex Length;
  const UInt8 *BytePtr;

  Count = CFSetGetCount(*(CFSetRef *)(a1 + 24));
  SecRequirementError(Count == 0, a3, CFSTR("Not direct bag"));
  if (Count)
    return 0xFFFFFFFFLL;
  Length = CFDataGetLength(a2);
  BytePtr = CFDataGetBytePtr(a2);
  return SOSBSKBLoadAndUnlockBagWithSecret(a1, Length, (uint64_t)BytePtr, a3);
}

uint64_t SOSBSKBLoadAndUnlockWithWrappingSecret(uint64_t a1, const __CFData *a2, CFTypeRef *a3)
{
  CFDataRef v6;
  uint64_t v7;
  _QWORD v9[8];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = -1;
  v6 = SOSBSKBCopyRecoveryKey(a1);
  SecRequirementError(v6 != 0, a3, CFSTR("no recovery key found in %@"), a1);
  if (v6)
  {
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = __SOSBSKBLoadAndUnlockWithWrappingSecret_block_invoke;
    v9[3] = &unk_1E1FD14B8;
    v9[4] = &v10;
    v9[5] = v6;
    v9[6] = a3;
    v9[7] = a1;
    SOSPerformWithRecoveryKeyFullKey(a2, a3, v9);
    CFRelease(v6);
  }
  v7 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v7;
}

void sub_18A9A8514(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

CFDataRef SOSBSKBCopyRecoveryKey(uint64_t a1)
{
  const __CFAllocator *v1;
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  CFDataRef Copy;
  _QWORD context[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  if (!a1)
    return 0;
  v1 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v2 = SOSBSKBCopyAdditionalKeysWithPrefix((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1, bskbRkbgPrefix);
  if (!v2)
    return 0;
  v3 = v2;
  if (CFDictionaryGetCount(v2) == 1)
  {
    v7 = 0;
    v8 = &v7;
    v9 = 0x2020000000;
    v10 = 0;
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 3221225472;
    context[2] = __SOSBSKBCopyRecoveryKey_block_invoke;
    context[3] = &unk_1E1FD14E0;
    context[4] = &v7;
    CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)apply_block_2_5101, context);
    Copy = CFDataCreateCopy(v1, (CFDataRef)v8[3]);
    _Block_object_dispose(&v7, 8);
  }
  else
  {
    Copy = 0;
  }
  CFRelease(v3);
  return Copy;
}

void sub_18A9A8620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void SOSPerformWithRecoveryKeyFullKey(const __CFData *a1, CFTypeRef *a2, void *a3)
{
  void (**v5)(id, char *, const void *);
  const __CFAllocator *v6;
  const UInt8 *BytePtr;
  CFIndex Length;
  __CFString *v9;
  __CFString *v10;
  void *v11;
  id v12;
  void *v13;
  const __CFData *v14;
  const __CFData *v15;
  const __CFData *v16;
  CFStringRef v17;
  CFStringRef v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  char *v23;
  CFTypeRef *v24;
  void *v25;
  id v26[2];

  v26[1] = *(id *)MEMORY[0x1E0C80C00];
  v5 = a3;
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v6 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  v9 = (__CFString *)CFStringCreateWithBytes(v6, BytePtr, Length, 0x8000100u, 0);
  if (v9)
  {
    v10 = v9;
    v26[0] = 0;
    SecRKCreateRecoveryKeyWithError(v9, v26);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = v26[0];
    v13 = v12;
    if (v11)
    {
      RKBackupCreateECKey((uint64_t)v11, 1);
      v14 = (const __CFData *)objc_claimAutoreleasedReturnValue();
      RKBackupCreateECKey((uint64_t)v11, 0);
      v15 = (const __CFData *)objc_claimAutoreleasedReturnValue();
      v16 = v15;
      if (v14 && v15)
      {
        v17 = SOSCopyIDOfDataBuffer(v15);
        if (v17)
        {
          v18 = v17;
          v24 = a2;
          v25 = v13;
          CFDataGetLength(v14);
          ccec_compact_import_priv_size();
          MEMORY[0x18D76FFBC]();
          MEMORY[0x18D76FFC8]();
          ccec_cp_521();
          v19 = ccec_curve_for_length_lookup();
          MEMORY[0x1E0C80A78](v19);
          v21 = (char *)&v24 - v20;
          v22 = 0;
          do
          {
            v23 = &v21[v22];
            *(_QWORD *)v23 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v22 += 16;
          }
          while (v20 != v22);
          CFDataGetLength(v14);
          CFDataGetBytePtr(v14);
          if (ccec_compact_import_priv())
          {
            SOSErrorCreate(1028, v24, 0, CFSTR("Unable to perform crypto operation from fullKeyBytes."));
          }
          else
          {
            v5[2](v5, v21, v18);
            cc_clear();
          }
          v13 = v25;
          CFRelease(v18);
        }
      }
      else
      {
        SOSErrorCreate(1029, a2, 0, CFSTR("Unable to get recovery key public and private keys."));
      }
    }
    else
    {
      v16 = 0;
      v14 = 0;
      if (a2)
        *a2 = v12;
    }
    CFRelease(v10);

  }
  else
  {
    SOSErrorCreate(1029, a2, 0, CFSTR("Unable to create key string from data."));
  }

}

CFMutableDictionaryRef SOSBSKBCopyAdditionalKeysWithPrefix(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v6;
  _QWORD v8[6];

  if (!*(_QWORD *)(a2 + 32))
    return 0;
  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v6 = *(const __CFDictionary **)(a2 + 32);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = __SOSBSKBCopyAdditionalKeysWithPrefix_block_invoke;
    v8[3] = &__block_descriptor_48_e15_v24__0r_v8r_v16l;
    v8[4] = a3;
    v8[5] = Mutable;
    CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)apply_block_2_5101, v8);
  }
  return Mutable;
}

void SOSBSKBRemoveRecoveryKey(uint64_t a1)
{
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v3;
  const void *v4;
  NSObject *v5;
  _QWORD context[5];
  uint8_t buf[16];

  if (a1)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v3 = *(const __CFDictionary **)(a1 + 32);
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 3221225472;
    context[2] = __SOSBSKBRemoveRecoveryKey_block_invoke;
    context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l;
    context[4] = Mutable;
    CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)apply_block_2_5101, context);
    v4 = *(const void **)(a1 + 32);
    if (v4)
    {
      *(_QWORD *)(a1 + 32) = 0;
      CFRelease(v4);
    }
    if (Mutable)
    {
      CFRetain(Mutable);
      *(_QWORD *)(a1 + 32) = Mutable;
      CFRelease(Mutable);
    }
    else
    {
      *(_QWORD *)(a1 + 32) = 0;
    }
  }
  else
  {
    secLogObjForScope("SecError");
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "bskb-backup: caller passed a nil backup slice keybag", buf, 2u);
    }

  }
}

BOOL SOSBSKBHasRecoveryKey(_BOOL8 result)
{
  uint64_t v1;
  const __CFDictionary *v2;
  const __CFDictionary *v3;
  CFIndex v4;
  const __CFDictionary *v5;
  int Count;
  const __CFSet *v7;
  int v8;
  BOOL v9;

  if (result)
  {
    v1 = result;
    v2 = SOSBSKBCopyAdditionalKeysWithPrefix((const __CFAllocator *)*MEMORY[0x1E0C9AE00], result, bskbRkbgPrefix);
    if (v2 && (v3 = v2, v4 = CFDictionaryGetCount(v2), CFRelease(v3), v4 > 0))
    {
      return 1;
    }
    else
    {
      v5 = *(const __CFDictionary **)(v1 + 32);
      if (v5)
        Count = CFDictionaryGetCount(v5);
      else
        Count = 0;
      v7 = *(const __CFSet **)(v1 + 24);
      if (v7)
      {
        v8 = CFSetGetCount(v7);
        v7 = *(const __CFSet **)(v1 + 24);
      }
      else
      {
        v8 = 0;
      }
      if (CFSetGetCount(v7))
        v9 = Count <= v8;
      else
        v9 = 1;
      return !v9;
    }
  }
  return result;
}

uint64_t SOSBSKBHasThisRecoveryKey(uint64_t a1, const __CFData *a2)
{
  __CFString *v3;
  __CFString *v4;
  _BOOL8 v5;
  uint64_t result;

  if (!a2)
    return 1;
  v3 = SOSKeyedPubKeyIdentifierCreateWithData((const __CFString *)bskbRkbgPrefix, a2);
  v4 = v3;
  if (a1 && v3)
  {
    v5 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), v3) != 0;
  }
  else
  {
    v5 = 0;
    result = 0;
    if (!v4)
      return result;
  }
  CFRelease(v4);
  return v5;
}

uint64_t SOSCircleCreateFromDER(const __CFAllocator *a1, CFTypeRef *a2, uint64_t *a3)
{
  uint64_t Instance;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const __CFAllocator *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFDictionaryRef v19;
  __CFString *v21;
  const __CFString *v22;
  CFIndex v23;
  CFTypeRef *v24;
  const __CFString *v25;
  const __CFString *v26;
  CFDictionaryRef theDict;
  uint64_t v28;
  uint64_t v29;

  SOSCircleGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  v29 = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)(Instance + 16) = 0u;
  *(_OWORD *)(Instance + 32) = 0u;
  *(_OWORD *)(Instance + 48) = 0u;
  *a3 = ccder_decode_constructed_tl();
  if (!v29)
  {
    if (!a2)
    {
      v25 = CFSTR("Bad Circle DER");
      goto LABEL_18;
    }
    v21 = (__CFString *)*a2;
    v22 = CFSTR("Bad Circle DER");
LABEL_13:
    v26 = v22;
    v23 = 1035;
    goto LABEL_14;
  }
  v28 = 0;
  v7 = ccder_decode_uint64();
  *a3 = v7;
  if (v28 != 1)
  {
    v26 = CFSTR("Bad Circle Version");
    v23 = 5;
    v21 = 0;
LABEL_14:
    v24 = a2;
LABEL_19:
    SOSCreateErrorWithFormat(v23, v21, v24, 0, CFSTR("%@"), v26);
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  *a3 = (uint64_t)der_decode_string(a1, (CFStringRef *)(Instance + 16), a2, v7, v29, v8, v9, v10);
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *(_QWORD *)(Instance + 24) = SOSGenCountCreateFromDER((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2, a3, v29, v12, v13, v14, v15);
  *(_QWORD *)(Instance + 32) = SOSPeerInfoSetCreateFromArrayDER(a1, &kSOSPeerSetCallbacks, a2, a3);
  *(_QWORD *)(Instance + 40) = SOSPeerInfoSetCreateFromArrayDER(a1, &kSOSPeerSetCallbacks, a2, a3);
  *(_QWORD *)(Instance + 48) = SOSPeerInfoSetCreateFromArrayDER(a1, &kSOSPeerSetCallbacks, a2, a3);
  theDict = 0;
  *a3 = der_decode_dictionary(a1, &theDict, a2, *a3, v29, v16, v17, v18);
  v19 = theDict;
  if (!theDict)
  {
    if (!a2)
    {
      v25 = CFSTR("Bad Circle DER1");
      goto LABEL_18;
    }
    v21 = (__CFString *)*a2;
    v22 = CFSTR("Bad Circle DER1");
    goto LABEL_13;
  }
  *(_QWORD *)(Instance + 56) = CFDictionaryCreateMutableCopy(v11, 0, theDict);
  CFRelease(v19);
  if (*a3 != v29)
  {
    if (a2)
    {
      v21 = (__CFString *)*a2;
      v22 = CFSTR("Bad Circle DER2");
      goto LABEL_13;
    }
    v25 = CFSTR("Bad Circle DER2");
LABEL_18:
    v26 = v25;
    v23 = 1035;
    v21 = 0;
    v24 = 0;
    goto LABEL_19;
  }
  return Instance;
}

uint64_t SOSCircleCreateFromData(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3)
{
  const UInt8 *BytePtr;

  CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  return SOSCircleCreateFromDER(a1, a3, (uint64_t *)&BytePtr);
}

uint64_t SOSCircleGetDEREncodedSize(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  if (ccder_sizeof_uint64()
    && der_sizeof_string(*(const __CFString **)(a1 + 16))
    && der_sizeof_number(*(const __CFNumber **)(a1 + 24), a2)
    && SOSPeerInfoSetGetDEREncodedArraySize(*(const __CFSet **)(a1 + 32), (uint64_t)a2)
    && SOSPeerInfoSetGetDEREncodedArraySize(*(const __CFSet **)(a1 + 40), (uint64_t)a2)
    && SOSPeerInfoSetGetDEREncodedArraySize(*(const __CFSet **)(a1 + 48), (uint64_t)a2)
    && der_sizeof_dictionary(*(const __CFDictionary **)(a1 + 56), (uint64_t)a2))
  {
    return ccder_sizeof();
  }
  SecCFCreateErrorWithFormat(-1, (const __CFString *)sSecDERErrorDomain, 0, a2, v4, CFSTR("don't know how to encode"), v5, v6, v8);
  return 0;
}

uint64_t SOSCircleEncodeToDER(uint64_t a1, CFTypeRef *a2, UInt8 *a3)
{
  const __CFString *v5;
  const __CFNumber *v6;
  const __CFSet *v7;
  const __CFSet *v8;
  const __CFSet *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v5 = *(const __CFString **)(a1 + 16);
  v6 = *(const __CFNumber **)(a1 + 24);
  v7 = *(const __CFSet **)(a1 + 32);
  v8 = *(const __CFSet **)(a1 + 40);
  v9 = *(const __CFSet **)(a1 + 48);
  v10 = der_encode_dictionary_repair(*(const __CFDictionary **)(a1 + 56), a2, 0);
  v11 = SOSPeerInfoSetEncodeToArrayDER(v9, (uint64_t)a2, (uint64_t)a3, v10);
  v12 = SOSPeerInfoSetEncodeToArrayDER(v8, (uint64_t)a2, (uint64_t)a3, v11);
  v13 = SOSPeerInfoSetEncodeToArrayDER(v7, (uint64_t)a2, (uint64_t)a3, v12);
  v14 = der_encode_number(v6, a2, (uint64_t)a3, v13);
  der_encode_string(v5, a2, a3, v14, v15, v16, v17, v18);
  ccder_encode_uint64();
  return ccder_encode_constructed_tl();
}

__CFData *SOSCircleCreateIncompatibleCircleDER()
{
  CFIndex v0;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  uint64_t v3;
  BOOL v4;

  if (!ccder_sizeof_uint64())
    return 0;
  v0 = ccder_sizeof();
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFDataSetLength(Mutable, v0);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  CFDataGetLength(Mutable);
  ccder_encode_uint64();
  v3 = ccder_encode_constructed_tl();
  if (MutableBytePtr)
    v4 = MutableBytePtr == (UInt8 *)v3;
  else
    v4 = 0;
  if (!v4 && Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

__CFData *SOSCircleCopyEncodedData(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  const __CFAllocator *v5;
  CFIndex DEREncodedSize;
  _QWORD v8[6];

  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  DEREncodedSize = SOSCircleGetDEREncodedSize(a1, a3);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __SOSCircleCopyEncodedData_block_invoke;
  v8[3] = &__block_descriptor_tmp_5155;
  v8[4] = a1;
  v8[5] = a3;
  return CFDataCreateWithDER(v5, DEREncodedSize, v8);
}

uint64_t der_sizeof_data_or_null(const __CFData *a1)
{
  if (!a1)
    return ccder_sizeof();
  CFDataGetLength(a1);
  return ccder_sizeof_raw_octet_string();
}

uint64_t der_encode_data_or_null(const __CFData *a1, CFTypeRef *a2)
{
  if (a1)
    return der_encode_data(a1, a2);
  else
    return der_encode_null(a2);
}

uint64_t der_decode_data_or_null(uint64_t a1, _QWORD *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  CFTypeRef v10;
  CFTypeID v11;
  CFTypeRef cf;

  cf = 0;
  v9 = der_decode_plist(a1, (uint64_t)&cf, a3, a4, a5, a6, a7, a8);
  v10 = cf;
  if (cf)
  {
    v11 = CFGetTypeID(cf);
    if (v11 != CFDataGetTypeID())
    {
      CFRelease(v10);
      v10 = 0;
    }
  }
  if (a2)
    *a2 = v10;
  return v9;
}

uint64_t SOSCircleGetTypeID()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SOSCircleGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_5159;
  block[4] = &SOSCircleGetTypeID_sSOSCircleGetTypeIDSingleton;
  if (SOSCircleGetTypeID_sSOSCircleGetTypeIDOnce != -1)
    dispatch_once(&SOSCircleGetTypeID_sSOSCircleGetTypeIDOnce, block);
  return SOSCircleGetTypeID_sSOSCircleGetTypeIDSingleton;
}

void SOSCircleDestroy(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;

  v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0;
    CFRelease(v3);
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0;
    CFRelease(v4);
  }
  v5 = (const void *)a1[5];
  if (v5)
  {
    a1[5] = 0;
    CFRelease(v5);
  }
  v6 = (const void *)a1[6];
  if (v6)
  {
    a1[6] = 0;
    CFRelease(v6);
  }
  v7 = (const void *)a1[7];
  if (v7)
  {
    a1[7] = 0;
    CFRelease(v7);
  }
}

uint64_t SOSCircleCompare(const void *a1, uint64_t a2)
{
  CFTypeID v4;
  CFTypeID v5;
  CFTypeID v6;
  const void *v7;
  CFTypeID v8;
  uint64_t TypeID;
  uint64_t result;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;

  v4 = CFGetTypeID(a1);
  if (v4 != SOSCircleGetTypeID())
    return 0;
  v5 = CFGetTypeID((CFTypeRef)a2);
  if (v5 != SOSCircleGetTypeID())
    return 0;
  v6 = CFGetTypeID(a1);
  if (v6 == SOSCircleGetTypeID())
    v7 = a1;
  else
    v7 = 0;
  v8 = CFGetTypeID((CFTypeRef)a2);
  TypeID = SOSCircleGetTypeID();
  result = 0;
  if (v8 != TypeID)
    a2 = 0;
  if (v7 && a2)
  {
    v11 = (const void *)*((_QWORD *)v7 + 3);
    v12 = *(const void **)(a2 + 24);
    if (v11 && v12)
    {
      result = CFEqual(v11, v12);
      if (!(_DWORD)result)
        return result;
      goto LABEL_17;
    }
    if (v11 == v12)
    {
LABEL_17:
      result = SOSPeerInfoSetContainsIdenticalPeers(*((CFTypeRef *)v7 + 4), *(CFTypeRef *)(a2 + 32));
      if ((_DWORD)result)
      {
        result = SOSPeerInfoSetContainsIdenticalPeers(*((CFTypeRef *)v7 + 5), *(CFTypeRef *)(a2 + 40));
        if ((_DWORD)result)
        {
          result = SOSPeerInfoSetContainsIdenticalPeers(*((CFTypeRef *)v7 + 6), *(CFTypeRef *)(a2 + 48));
          if ((_DWORD)result)
          {
            v13 = (const void *)*((_QWORD *)v7 + 7);
            v14 = *(const void **)(a2 + 56);
            if (v13 && v14)
              return CFEqual(v13, v14) != 0;
            else
              return v13 == v14;
          }
        }
      }
      return result;
    }
    return 0;
  }
  return result;
}

__CFString *SOSCircleCopyFormatDescription(uint64_t a1, const __CFDictionary *a2)
{
  CFMutableStringRef Mutable;
  __CFString *v5;
  uint64_t v6;
  const __CFSet *v7;
  const __CFSet *v8;
  const __CFSet *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  uint64_t *p_context;
  CFMutableStringRef v16;
  const __CFDictionary *v17;
  uint64_t context;
  uint64_t v19;
  void *v20;
  void *v21;
  uint64_t *v22;
  _QWORD *p_isa;
  const __CFDictionary *v24;
  _QWORD v25[8];
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  const __CFString *v29;

  if (!a2)
    return defaultDescriptionCreate((const __CFNumber **)a1);
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (!CFDictionaryContainsKey(a2, CFSTR("SyncD")))
  {
    if (Mutable)
      CFRelease(Mutable);
    return defaultDescriptionCreate((const __CFNumber **)a1);
  }
  v5 = SOSGenerationCountCopyDescription(*(const __CFNumber **)(a1 + 24));
  CFStringAppendFormat(Mutable, 0, CFSTR("<C: gen:'%@' %@>\n"), v5, *(_QWORD *)(a1 + 16));
  if (v5)
    CFRelease(v5);
  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v29 = CFSTR("\t\t");
  v6 = MEMORY[0x1E0C809B0];
  v25[0] = MEMORY[0x1E0C809B0];
  v25[1] = 0x40000000;
  v25[2] = __descriptionCreateWithFormatOptions_block_invoke;
  v25[3] = &unk_1E1FD1BA0;
  v25[6] = Mutable;
  v25[7] = a2;
  v25[4] = &v26;
  v25[5] = a1;
  v7 = *(const __CFSet **)(a1 + 32);
  context = MEMORY[0x1E0C809B0];
  v19 = 0x40000000;
  v20 = __SOSCircleForEachPeerMatching_block_invoke;
  v21 = &unk_1E1FD1D20;
  v22 = (uint64_t *)&__block_literal_global_54;
  p_isa = v25;
  CFSetApplyFunction(v7, (CFSetApplierFunction)apply_block_1_5164, &context);
  CFStringAppend(Mutable, CFSTR("\n\t\t<A:["));
  v27[3] = (uint64_t)&stru_1E1FDD448;
  if (CFSetGetCount(*(CFSetRef *)(a1 + 40)))
  {
    context = v6;
    v19 = 0x40000000;
    v20 = __descriptionCreateWithFormatOptions_block_invoke_2;
    v21 = &unk_1E1FD1BC8;
    p_isa = &Mutable->isa;
    v24 = a2;
    v22 = &v26;
    v8 = *(const __CFSet **)(a1 + 40);
    v11 = v6;
    v12 = 0x40000000;
    v13 = __SOSCircleForEachApplicant_block_invoke;
    v14 = &unk_1E1FD1918;
    p_context = &context;
    CFSetApplyFunction(v8, (CFSetApplierFunction)apply_block_1_5164, &v11);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("-"));
  }
  CFStringAppend(Mutable, CFSTR("]> \n\t\t<R:["));
  v27[3] = (uint64_t)&stru_1E1FDD448;
  if (CFSetGetCount(*(CFSetRef *)(a1 + 48)))
  {
    v10 = *(const __CFSet **)(a1 + 48);
    v11 = v6;
    v12 = 0x40000000;
    v13 = __descriptionCreateWithFormatOptions_block_invoke_3;
    v14 = &unk_1E1FD1BF0;
    v16 = Mutable;
    v17 = a2;
    p_context = &v26;
    CFSetApplyFunction(v10, (CFSetApplierFunction)apply_block_1_5164, &v11);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("-"));
  }
  CFStringAppend(Mutable, CFSTR("]>"));
  _Block_object_dispose(&v26, 8);
  return Mutable;
}

__CFString *SOSCircleCopyDescription(uint64_t a1)
{
  const __CFDictionary *DebugDescriptionFormatOptions;

  DebugDescriptionFormatOptions = (const __CFDictionary *)SecGetDebugDescriptionFormatOptions();
  return SOSCircleCopyFormatDescription(a1, DebugDescriptionFormatOptions);
}

void __descriptionCreateWithFormatOptions_block_invoke(uint64_t a1, CFDictionaryRef *a2)
{
  const __CFString *v4;
  _QWORD *v5;
  const void *v6;

  if ((SOSCircleVerifyPeerSigned(*(_QWORD *)(a1 + 40), a2, 0) & 1) != 0)
  {
    v4 = CFSTR("√");
  }
  else
  {
    v5 = _SOSPeerInfoCopyPubKey(a2, CFSTR("PublicSigningKey"), 0);
    v4 = CFSTR("-");
    if (v5)
    {
      v6 = v5;
      if (SOSCircleGetSignature(*(_QWORD *)(a1 + 40), (uint64_t)v5, 0))
        v4 = CFSTR("?");
      CFRelease(v6);
    }
  }
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 48), *(CFDictionaryRef *)(a1 + 56), CFSTR("%@%@ %@"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2, v4);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFSTR("\n\t\t");
}

uint64_t apply_block_1_5164(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void __descriptionCreateWithFormatOptions_block_invoke_2(uint64_t a1, uint64_t a2)
{
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), *(CFDictionaryRef *)(a1 + 48), CFSTR("%@A: %@"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFSTR("\n\t\t\t");
}

void __descriptionCreateWithFormatOptions_block_invoke_3(uint64_t a1, uint64_t a2)
{
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), *(CFDictionaryRef *)(a1 + 48), CFSTR("%@R: %@"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFSTR("\n\t\t");
}

__CFString *defaultDescriptionCreate(const __CFNumber **a1)
{
  __CFString *Mutable;
  const __CFNumber *v3;
  uint64_t v4;
  const __CFSet *v5;
  const __CFSet *v6;
  const __CFSet *v7;
  _QWORD v9[7];
  _QWORD v10[7];
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  const __CFString *v15;
  _QWORD v16[6];
  uint64_t context;
  uint64_t v18;
  uint64_t (*v19)(uint64_t);
  void *v20;
  _QWORD *v21;
  _QWORD *v22;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v3 = a1[3];
  v4 = MEMORY[0x1E0C809B0];
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 0x40000000;
  v16[2] = __defaultDescriptionCreate_block_invoke;
  v16[3] = &__block_descriptor_tmp_129_5172;
  v16[4] = Mutable;
  v16[5] = a1;
  SOSGenerationCountWithDescription(v3, (uint64_t)v16);
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = CFSTR("\n");
  v11[0] = v4;
  v11[1] = 0x40000000;
  v11[2] = __defaultDescriptionCreate_block_invoke_2;
  v11[3] = &unk_1E1FD1C38;
  v11[4] = &v12;
  v11[5] = a1;
  v11[6] = Mutable;
  v11[7] = CFSTR("\n");
  v5 = a1[4];
  context = v4;
  v18 = 0x40000000;
  v19 = __SOSCircleForEachPeerMatching_block_invoke;
  v20 = &unk_1E1FD1D20;
  v21 = &__block_literal_global_54;
  v22 = v11;
  CFSetApplyFunction(v5, (CFSetApplierFunction)apply_block_1_5164, &context);
  CFStringAppend(Mutable, CFSTR("], A:["));
  v13[3] = (uint64_t)CFSTR("\n");
  if (CFSetGetCount(a1[5]))
  {
    v10[0] = v4;
    v10[1] = 0x40000000;
    v10[2] = __defaultDescriptionCreate_block_invoke_3;
    v10[3] = &unk_1E1FD1C60;
    v10[4] = &v12;
    v10[5] = Mutable;
    v10[6] = CFSTR("\n");
    v6 = a1[5];
    context = v4;
    v18 = 0x40000000;
    v19 = __SOSCircleForEachApplicant_block_invoke;
    v20 = &unk_1E1FD1918;
    v21 = v10;
    CFSetApplyFunction(v6, (CFSetApplierFunction)apply_block_1_5164, &context);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("-"));
  }
  CFStringAppend(Mutable, CFSTR("], R:["));
  v13[3] = (uint64_t)CFSTR("\n");
  if (CFSetGetCount(a1[6]))
  {
    v7 = a1[6];
    v9[0] = v4;
    v9[1] = 0x40000000;
    v9[2] = __defaultDescriptionCreate_block_invoke_4;
    v9[3] = &unk_1E1FD1C88;
    v9[4] = &v12;
    v9[5] = Mutable;
    v9[6] = CFSTR("\n");
    CFSetApplyFunction(v7, (CFSetApplierFunction)apply_block_1_5164, v9);
  }
  else
  {
    CFStringAppendFormat(Mutable, 0, CFSTR("-"));
  }
  CFStringAppend(Mutable, CFSTR("]>"));
  _Block_object_dispose(&v12, 8);
  return Mutable;
}

void __defaultDescriptionCreate_block_invoke(uint64_t a1, uint64_t a2)
{
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 32), 0, CFSTR("<SOSCircle@%p: '%@' %@ P:["), *(_QWORD *)(a1 + 40), *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16), a2);
}

void __defaultDescriptionCreate_block_invoke_2(uint64_t a1, CFDictionaryRef *a2)
{
  const __CFString *v4;
  _QWORD *v5;
  const void *v6;

  if ((SOSCircleVerifyPeerSigned(*(_QWORD *)(a1 + 40), a2, 0) & 1) != 0)
  {
    v4 = CFSTR("√");
  }
  else
  {
    v5 = _SOSPeerInfoCopyPubKey(a2, CFSTR("PublicSigningKey"), 0);
    v4 = CFSTR("-");
    if (v5)
    {
      v6 = v5;
      if (SOSCircleGetSignature(*(_QWORD *)(a1 + 40), (uint64_t)v5, 0))
        v4 = CFSTR("?");
      CFRelease(v6);
    }
  }
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 48), 0, CFSTR("%@%@ %@"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2, v4);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a1 + 56);
}

void __defaultDescriptionCreate_block_invoke_3(uint64_t a1, uint64_t a2)
{
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0, CFSTR("%@%@"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a1 + 48);
}

void __defaultDescriptionCreate_block_invoke_4(uint64_t a1, uint64_t a2)
{
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0, CFSTR("%@%@"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *(_QWORD *)(a1 + 48);
}

__SecKey *SOSCircleVerifyPeerSigned(uint64_t a1, CFDictionaryRef *a2, CFTypeRef *a3)
{
  __SecKey *result;
  __SecKey *v6;
  const __CFData *v7;

  result = (__SecKey *)_SOSPeerInfoCopyPubKey(a2, CFSTR("PublicSigningKey"), a3);
  if (result)
  {
    v6 = result;
    v7 = SOSCircleVerify(a1, result, a3);
    CFRelease(v6);
    return v7;
  }
  return result;
}

const void *SOSCircleGetSignature(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  CFStringRef v4;
  CFStringRef v5;
  const void *Value;
  const void *v7;
  CFTypeID v8;

  v4 = SOSCopyIDOfKey(a2, a3);
  if (!v4)
    return 0;
  v5 = v4;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), v4);
  v7 = Value;
  if (Value)
  {
    v8 = CFGetTypeID(Value);
    if (v8 != CFDataGetTypeID())
      v7 = 0;
  }
  CFRelease(v5);
  return v7;
}

const __CFData *SOSCircleVerify(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  size_t *v6;
  size_t v7;
  const uint8_t *v8;
  const __CFData *result;
  const __CFData *v10;
  size_t v11;
  const uint8_t *BytePtr;
  CFIndex Length;
  OSStatus v14;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v6 = (size_t *)ccsha256_di();
  MEMORY[0x1E0C80A78](v6);
  v8 = (const uint8_t *)v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v7)
    memset((char *)v15 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), 170, v7);
  SOSCircleHashGenAndPeers((uint64_t)v6, *(const __CFNumber **)(a1 + 24), *(const __CFSet **)(a1 + 32), (uint64_t)v8, (uint64_t)a3);
  result = (const __CFData *)SOSCircleGetSignature(a1, (uint64_t)a2, a3);
  if (result)
  {
    v10 = result;
    v11 = *v6;
    BytePtr = CFDataGetBytePtr(result);
    Length = CFDataGetLength(v10);
    v14 = SecKeyRawVerify(a2, 0, v8, v11, BytePtr, Length);
    return (const __CFData *)SecError(v14, (__CFString **)a3, CFSTR("Signature verification failed."));
  }
  return result;
}

uint64_t SOSCircleHashGenAndPeers(uint64_t a1, const __CFNumber *a2, const __CFSet *a3, uint64_t a4, uint64_t a5)
{
  size_t v10;
  uint64_t v11;
  char *v12;
  unint64_t v13;
  uint64_t v14;
  __CFArray *v15;
  _QWORD valuePtr[2];

  valuePtr[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v12 = (char *)valuePtr - v11;
  if (v13 >= 8)
    memset((char *)valuePtr - v11, 170, v10);
  ccdigest_init();
  if (a2)
  {
    valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(a2, kCFNumberSInt64Type, valuePtr);
    v14 = valuePtr[0];
  }
  else
  {
    v14 = 0;
  }
  valuePtr[0] = v14;
  ccdigest_update();
  v15 = CFSetCopyValuesCFArray(a3);
  SOSCircleDigestArray(a1, v15, a4, a5);
  if (v15)
    CFRelease(v15);
  ccdigest_update();
  return (*(uint64_t (**)(uint64_t, char *, uint64_t))(a1 + 56))(a1, v12, a4);
}

__CFArray *CFSetCopyValuesCFArray(const __CFSet *a1)
{
  CFIndex Count;
  CFMutableArrayRef Mutable;
  __CFArray *v4;
  size_t v5;
  const void **v6;
  const void *v7;
  _QWORD v9[2];

  v9[1] = *MEMORY[0x1E0C80C00];
  Count = CFSetGetCount(a1);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v4 = Mutable;
  if (Count >= 1)
  {
    MEMORY[0x1E0C80A78](Mutable);
    v6 = (const void **)((char *)v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
    memset(v6, 170, v5);
    CFSetGetValues(a1, v6);
    do
    {
      v7 = *v6++;
      CFArrayAppendValue(v4, v7);
      --Count;
    }
    while (Count);
  }
  return v4;
}

void SOSCircleDigestArray(uint64_t a1, const __CFArray *a2, uint64_t a3, uint64_t a4)
{
  size_t v8;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  _QWORD context[8];
  _QWORD v14[3];
  char v15;
  uint64_t v16;
  CFRange v17;
  CFRange v18;

  v16 = *MEMORY[0x1E0C80C00];
  v14[0] = 0;
  v14[1] = v14;
  v14[2] = 0x2000000000;
  v15 = 1;
  MEMORY[0x1E0C80A78](a1);
  v10 = (char *)&context[-1] - v9;
  if (v11 >= 8)
    memset((char *)&context[-1] - v9, 170, v8);
  ccdigest_init();
  v17.length = CFArrayGetCount(a2);
  v17.location = 0;
  CFArraySortValues(a2, v17, (CFComparatorFunction)SOSPeerInfoCompareByID, 0);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleDigestArray_block_invoke;
  context[3] = &unk_1E1FD1B08;
  context[6] = v10;
  context[7] = a4;
  context[4] = v14;
  context[5] = a1;
  v18.length = CFArrayGetCount(a2);
  v18.location = 0;
  CFArrayApplyFunction(a2, v18, (CFArrayApplierFunction)apply_block_1_5164, context);
  (*(void (**)(uint64_t, char *, uint64_t))(a1 + 56))(a1, v10, a3);
  _Block_object_dispose(v14, 8);
}

_QWORD *SOSCircleCreate(const __CFAllocator *a1, const __CFString *a2)
{
  _QWORD *Instance;

  SOSCircleGetTypeID();
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  Instance[2] = CFStringCreateCopy(a1, a2);
  Instance[3] = sosGenerationCreateOrIncrement(0);
  Instance[4] = CFSetCreateMutable(a1, 0, &kSOSPeerSetCallbacks);
  Instance[5] = CFSetCreateMutable(a1, 0, &kSOSPeerSetCallbacks);
  Instance[6] = CFSetCreateMutable(a1, 0, &kSOSPeerSetCallbacks);
  Instance[7] = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  return Instance;
}

_QWORD *SOSCircleCopyCircle(const __CFAllocator *a1, uint64_t a2)
{
  _QWORD *Instance;

  SOSCircleGetTypeID();
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  Instance[2] = CFStringCreateCopy(a1, *(CFStringRef *)(a2 + 16));
  Instance[3] = SOSGenerationCopy(*(const __CFNumber **)(a2 + 24));
  Instance[4] = CFSetOfPeerInfoDeepCopy(a1, *(const __CFSet **)(a2 + 32));
  Instance[5] = CFSetOfPeerInfoDeepCopy(a1, *(const __CFSet **)(a2 + 40));
  Instance[6] = CFSetOfPeerInfoDeepCopy(a1, *(const __CFSet **)(a2 + 48));
  Instance[7] = CFDictionaryCreateMutableCopy(a1, 0, *(CFDictionaryRef *)(a2 + 56));
  return Instance;
}

uint64_t CFSetOfPeerInfoDeepCopy(const __CFAllocator *a1, const __CFSet *a2)
{
  uint64_t v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  CFMutableSetRef Mutable;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  Mutable = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
  Mutable = CFSetCreateMutable(a1, 0, &kSOSPeerSetCallbacks);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __CFSetOfPeerInfoDeepCopy_block_invoke;
  v6[3] = &unk_1E1FD1AE0;
  v6[4] = &v7;
  v6[5] = a1;
  CFSetApplyFunction(a2, (CFSetApplierFunction)apply_block_1_5164, v6);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

BOOL SOSCircleSetSignature(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  CFStringRef v6;

  v6 = SOSCopyIDOfKey(a2, a4);
  if (v6)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), v6, a3);
    CFRelease(v6);
  }
  return v6 != 0;
}

CFDictionaryRef SOSCircleCopyAllSignatures(uint64_t a1)
{
  return CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFDictionaryRef *)(a1 + 56));
}

BOOL SOSCircleSign(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  size_t *v6;
  size_t v7;
  const void *v8;
  _BOOL8 v9;
  const void *v10;
  _QWORD v12[9];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v6 = (size_t *)ccsha256_di();
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  if (!a2)
    goto LABEL_6;
  v7 = *v6;
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 0x40000000;
  v12[2] = __SOSCircleSign_block_invoke;
  v12[3] = &unk_1E1FD15D8;
  v12[6] = a1;
  v12[7] = a3;
  v12[4] = &v13;
  v12[5] = v6;
  v12[8] = a2;
  PerformWithBuffer(v7, (uint64_t)v12);
  v8 = (const void *)v14[3];
  if (v8)
  {
    v9 = SOSCircleSetSignature(a1, a2, v8, a3);
    v10 = (const void *)v14[3];
    if (v10)
    {
      v14[3] = 0;
      CFRelease(v10);
    }
  }
  else
  {
LABEL_6:
    v9 = 0;
  }
  _Block_object_dispose(&v13, 8);
  return v9;
}

__CFData *SecKeyCopyRawHashSignature(size_t *a1, const uint8_t *a2, __SecKey *a3, __CFString **a4)
{
  const __CFAllocator *v8;
  CFIndex Size;
  __CFData *Mutable;
  size_t v11;
  uint8_t *MutableBytePtr;
  uint64_t v13;
  size_t v14;
  size_t sigLen;

  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Size = SecKeyGetSize((uint64_t)a3, 1);
  Mutable = CFDataCreateMutable(v8, 0);
  CFDataSetLength(Mutable, Size);
  sigLen = CFDataGetLength(Mutable);
  v11 = *a1;
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  v13 = SecKeyRawSign(a3, 0, a2, v11, MutableBytePtr, &sigLen);
  if (SecError(v13, a4, CFSTR("Signing failed: %d"), v13))
  {
    v14 = sigLen;
    if (v14 < CFDataGetLength(Mutable))
      CFDataSetLength(Mutable, sigLen);
  }
  else if (Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t SOSCircleCopyNextGenSignatureWithPeerAdded(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t *v8;
  size_t v9;
  uint64_t v10;
  _QWORD v12[10];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v8 = (size_t *)ccsha256_di();
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  if (a3)
  {
    v9 = *v8;
    v12[0] = MEMORY[0x1E0C809B0];
    v12[1] = 0x40000000;
    v12[2] = __SOSCircleCopyNextGenSignatureWithPeerAdded_block_invoke;
    v12[3] = &unk_1E1FD1600;
    v12[6] = a1;
    v12[7] = a2;
    v12[4] = &v13;
    v12[5] = v8;
    v12[8] = a4;
    v12[9] = a3;
    PerformWithBuffer(v9, (uint64_t)v12);
    v10 = v14[3];
  }
  else
  {
    v10 = 0;
  }
  _Block_object_dispose(&v13, 8);
  return v10;
}

BOOL SOSCircleVerifySignatureExists(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  NSObject *v5;
  uint8_t buf[16];

  if (a2)
    return SOSCircleGetSignature(a1, a2, a3) != 0;
  v5 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "SOSCircleVerifySignatureExists no pubKey", buf, 2u);
  }
  if (a3)
    SOSCreateErrorWithFormat(1035, (__CFString *)*a3, a3, 0, CFSTR("%@"), CFSTR("SOSCircleVerifySignatureExists no pubKey"));
  else
    SOSCreateErrorWithFormat(1035, 0, 0, 0, CFSTR("%@"), CFSTR("SOSCircleVerifySignatureExists no pubKey"));
  return 0;
}

CFStringRef SOSCircleCopyHashString(uint64_t a1)
{
  size_t *v2;
  size_t v3;
  _QWORD v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  v2 = (size_t *)ccsha256_di();
  v3 = *v2;
  MEMORY[0x1E0C80A78](v2);
  if (v3)
    memset((char *)v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), 170, v3);
  SOSCircleHashGenAndPeers((uint64_t)v2, *(const __CFNumber **)(a1 + 24), *(const __CFSet **)(a1 + 32), (uint64_t)v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), 0);
  return SOSCopyHashBufAsString((unsigned __int8 *)v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v3);
}

BOOL SOSCircleVerifyPeerSignatureExists(uint64_t a1, CFDictionaryRef *a2)
{
  _QWORD *v3;
  const void *v4;
  _BOOL8 v5;

  v3 = _SOSPeerInfoCopyPubKey(a2, CFSTR("PublicSigningKey"), 0);
  if (!v3)
    return 0;
  v4 = v3;
  v5 = SOSCircleGetSignature(a1, (uint64_t)v3, 0) != 0;
  CFRelease(v4);
  return v5;
}

uint64_t SOSCircleSignOldStyleResetToOfferingCircle(const __CFSet **a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4)
{
  uint64_t result;
  __SecKey *v9;
  SecKeyRef v10;
  NSObject *v11;
  SecKeyRef v12;
  __int16 v13[8];

  result = (uint64_t)SOSFullPeerInfoCopyDeviceKey(a2, a4);
  if (!result)
    return result;
  v9 = (__SecKey *)result;
  if ((SOSCircleUpgradePeerInfo(a1, a3, a2) & 1) == 0)
  {
    v12 = v9;
    goto LABEL_14;
  }
  SOSCircleRemoveRetired((uint64_t)a1);
  CFSetRemoveAllValues(a1[6]);
  v10 = SecKeyCopyPublicKey(a3);
  SOSCircleRejectNonValidApplicants((uint64_t)a1, (uint64_t)v10);
  v11 = secLogObjForScope("Development");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v13[0] = 0;
    _os_log_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEFAULT, "SOSCircleEnsureRingConsistency requires ring membership and generation count consistency check", (uint8_t *)v13, 2u);
  }
  CFDictionaryRemoveAllValues(a1[7]);
  if (!SOSCircleSign((uint64_t)a1, (uint64_t)a3, a4) || !SOSCircleSign((uint64_t)a1, (uint64_t)v9, a4))
  {
    CFRelease(v9);
    if (!v10)
      return 0;
    v12 = v10;
LABEL_14:
    CFRelease(v12);
    return 0;
  }
  CFRelease(v9);
  if (v10)
    CFRelease(v10);
  return 1;
}

uint64_t SOSCircleUpgradePeerInfo(const __CFSet **a1, SecKeyRef key, uint64_t a3)
{
  SecKeyRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  uint64_t updated;
  NSObject *v13;
  __SecKey *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __SecKey *v19;
  const void *v20;
  uint8_t v21[16];

  v6 = SecKeyCopyPublicKey(key);
  if (a3 && (v7 = *(_QWORD *)(a3 + 16)) != 0)
    v8 = *(_QWORD *)(v7 + 40);
  else
    v8 = 0;
  v9 = SOSCircleCopyPeerInfo(a1[4], v8);
  v10 = (const void *)v9;
  if (!v9)
    goto LABEL_17;
  if (SOSPeerInfoApplicationVerify(v9, v6, 0))
  {
    if (v6)
      CFRelease(v6);
    CFRelease(v10);
    return 1;
  }
  v13 = secLogObjForScope("circle");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v21 = 0;
    _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, "SOSCircleGenerationSign: Upgraded peer's Application Signature", v21, 2u);
  }
  v14 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a3, 0);
  if (v14)
  {
    v19 = v14;
    v20 = (const void *)SOSPeerInfoCopyAsApplication((uint64_t)v10, key, v14, 0, v15, v16, v17, v18);
    updated = SOSCircleUpdatePeerInfo(a1, v20);
    if (v20)
      CFRelease(v20);
    CFRelease(v19);
  }
  else
  {
LABEL_17:
    updated = 0;
  }
  if (v6)
    CFRelease(v6);
  if (v10)
    CFRelease(v10);
  return updated;
}

uint64_t SOSCircleRemoveRetired(uint64_t a1)
{
  const __CFSet *v1;
  const __CFArray *Mutable;
  uint64_t v3;
  _QWORD v5[5];
  _QWORD context[6];
  CFRange v7;

  v1 = *(const __CFSet **)(a1 + 32);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
  v3 = MEMORY[0x1E0C809B0];
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __CFSetRemoveAllPassing_block_invoke;
  context[3] = &unk_1E1FD1CB0;
  context[4] = &__block_literal_global_5223;
  context[5] = Mutable;
  CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_5164, context);
  v5[0] = v3;
  v5[1] = 0x40000000;
  v5[2] = __CFSetRemoveAllPassing_block_invoke_2;
  v5[3] = &__block_descriptor_tmp_140_5225;
  v5[4] = v1;
  v7.length = CFArrayGetCount(Mutable);
  v7.location = 0;
  CFArrayApplyFunction(Mutable, v7, (CFArrayApplierFunction)apply_block_1_5164, v5);
  if (Mutable)
    CFRelease(Mutable);
  return 1;
}

void SOSCircleRejectNonValidApplicants(uint64_t a1, uint64_t a2)
{
  const __CFSet *MutableCopy;
  _QWORD v5[6];

  MutableCopy = CFSetCreateMutableCopy(0, 0, *(CFSetRef *)(a1 + 40));
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __SOSCircleRejectNonValidApplicants_block_invoke;
  v5[3] = &__block_descriptor_tmp_87_5222;
  v5[4] = a2;
  v5[5] = a1;
  CFSetApplyFunction(MutableCopy, (CFSetApplierFunction)apply_block_1_5164, v5);
  if (MutableCopy)
    CFRelease(MutableCopy);
}

uint64_t SOSCircleCopyPeerInfo(const __CFSet *a1, uint64_t a2)
{
  const void *v2;
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __SOSCircleCopyPeerInfo_block_invoke;
  v5[3] = &unk_1E1FD1CF8;
  v5[4] = &v6;
  v5[5] = a2;
  CFSetApplyFunction(a1, (CFSetApplierFunction)apply_block_1_5164, v5);
  v2 = (const void *)v7[3];
  if (v2)
  {
    CFRetain(v2);
    v3 = v7[3];
  }
  else
  {
    v3 = 0;
  }
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t SOSCircleUpdatePeerInfo(const __CFSet **a1, const void *a2)
{
  if ((sosCircleUpdatePeerInfoSet(a1[4], a2) & 1) != 0 || (sosCircleUpdatePeerInfoSet(a1[5], a2) & 1) != 0)
    return 1;
  else
    return sosCircleUpdatePeerInfoSet(a1[6], a2);
}

uint64_t sosCircleUpdatePeerInfoSet(const __CFSet *a1, const void *a2)
{
  uint64_t result;

  if (!a2)
    return 0;
  result = (uint64_t)CFSetGetValue(a1, a2);
  if (result)
  {
    if (CFEqual((CFTypeRef)result, a2))
    {
      return 0;
    }
    else
    {
      CFSetReplaceValue(a1, a2);
      return 1;
    }
  }
  return result;
}

uint64_t SOSCirclePreGenerationSign(uint64_t a1, uint64_t a2)
{
  SOSCircleRemoveRetired(a1);
  CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 48));
  SOSCircleRejectNonValidApplicants(a1, a2);
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 56));
  return 1;
}

uint64_t SOSCircleGenerationSign(const __CFSet **a1, SecKeyRef key, uint64_t a3, CFTypeRef *a4)
{
  SecKeyRef v8;
  uint64_t v9;

  v8 = SecKeyCopyPublicKey(key);
  SOSCirclePreGenerationSign((uint64_t)a1, (uint64_t)v8);
  SOSCircleGenerationIncrement((uint64_t)a1);
  v9 = SOSCircleGenerationSign_Internal(a1, key, a3, a4);
  if (v8)
    CFRelease(v8);
  return v9;
}

void SOSCircleGenerationIncrement(uint64_t a1)
{
  const __CFNumber *v1;

  v1 = *(const __CFNumber **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = sosGenerationCreateOrIncrement(v1);
  if (v1)
    CFRelease(v1);
}

uint64_t SOSCircleGenerationSign_Internal(const __CFSet **a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  CFTypeRef v8;
  const void *v9;
  _BOOL8 v10;

  if (!SOSCircleCountPeers((uint64_t)a1))
    return 1;
  v8 = SOSFullPeerInfoCopyDeviceKey(a3, a4);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = SOSCircleUpgradePeerInfo(a1, a2, a3)
     && SOSCircleSign((uint64_t)a1, (uint64_t)a2, a4)
     && SOSCircleSign((uint64_t)a1, (uint64_t)v9, a4);
  CFRelease(v9);
  return v10;
}

uint64_t SOSCircleCountPeers(uint64_t a1)
{
  const __CFSet *v1;
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  _QWORD context[6];

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __SOSCircleCountPeers_block_invoke;
  v4[3] = &unk_1E1FD1650;
  v4[4] = &v5;
  v1 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = &__block_literal_global_48;
  context[5] = v4;
  CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_5164, context);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

BOOL SOSCircleConcordanceSign(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeRef v5;
  const void *v6;
  _BOOL8 v7;
  NSObject *v8;
  uint8_t v10[16];

  v5 = SOSFullPeerInfoCopyDeviceKey(a2, a3);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = SOSCircleSign(a1, (uint64_t)v5, a3);
  v8 = secLogObjForScope("Development");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v10 = 0;
    _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "SOSCircleEnsureRingConsistency requires ring signing op", v10, 2u);
  }
  CFRelease(v6);
  return v7;
}

BOOL SOSCircleIsOlderGeneration(uint64_t a1, uint64_t a2)
{
  unint64_t v2;

  v2 = CFNumberCompare(*(CFNumberRef *)(a1 + 24), *(CFNumberRef *)(a2 + 24), 0) + 1;
  return (v2 & 7) == 0 && v2 < 3;
}

uint64_t SOSCircleSharedTrustedPeers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFSet *v3;
  uint64_t v4;
  _QWORD v6[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;
  _QWORD context[6];

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __SOSCircleSharedTrustedPeers_block_invoke;
  v6[3] = &unk_1E1FD1628;
  v6[5] = a3;
  v6[6] = a2;
  v6[4] = &v7;
  v3 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = &__block_literal_global_48;
  context[5] = v6;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5164, context);
  v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

const void *SOSCircleHasPeerWithID(uint64_t a1, const void *a2)
{
  const void *result;
  uint64_t v3;
  CFTypeID v4;
  const __CFDictionary *v5;

  if (!a2)
    return 0;
  result = CFSetGetValue(*(CFSetRef *)(a1 + 32), a2);
  if (result)
  {
    v3 = (uint64_t)result;
    v4 = CFGetTypeID(result);
    if (v4 != SOSPeerInfoGetTypeID())
      return 0;
    v5 = *(const __CFDictionary **)(v3 + 16);
    if (v5 && CFDictionaryGetValue(v5, CFSTR("RetirementDate")))
      return 0;
    else
      return (const void *)!SOSPeerInfoIsCloudIdentity(v3);
  }
  return result;
}

void SOSCircleForEachPeer(uint64_t a1, uint64_t a2)
{
  const __CFSet *v2;
  _QWORD v3[6];

  v2 = *(const __CFSet **)(a1 + 32);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __SOSCircleForEachPeerMatching_block_invoke;
  v3[3] = &unk_1E1FD1D20;
  v3[4] = &__block_literal_global_48;
  v3[5] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5164, v3);
}

const void *SOSCircleHasPeer(uint64_t a1, uint64_t a2)
{
  if (a2)
    return SOSCircleHasPeerWithID(a1, *(const void **)(a2 + 40));
  else
    return 0;
}

uint64_t SOSCircleConcordanceTrust(uint64_t a1, uint64_t a2, int a3, __SecKey *a4, uint64_t a5, CFTypeRef *a6)
{
  CFComparisonResult v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFComparisonResult v18;
  const __CFSet *v19;
  _QWORD valuePtr[9];
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  int v26;
  _QWORD context[6];

  if (a4)
  {
    valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(*(CFNumberRef *)(a2 + 24), kCFNumberCFIndexType, valuePtr);
    if ((valuePtr[0] || SOSCircleCountPeers(a2))
      && (SOSCircleCountPeers(a2)
       || ((v11 = CFNumberCompare(*(CFNumberRef *)(a1 + 24), *(CFNumberRef *)(a2 + 24), 0),
            (unint64_t)(v11 + 1) <= 2)
         ? (v12 = ((v11 + 1) & 7) == 0)
         : (v12 = 0),
           !v12)))
    {
      if (SOSCircleGetSignature(a2, (uint64_t)a4, a6))
      {
        if ((SOSCircleVerify(a2, a4, a6) & 1) != 0)
        {
          if (SOSCircleCountPeers(a1))
          {
            valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
            CFNumberGetValue(*(CFNumberRef *)(a2 + 24), kCFNumberCFIndexType, valuePtr);
            if (!valuePtr[0] && SOSCircleIsOffering(a2))
            {
              v13 = a2;
              v14 = a2;
              v15 = (uint64_t)a4;
              v16 = 0;
              return GetSignersStatus(v13, v14, v15, v16, (uint64_t)a6);
            }
            v18 = CFNumberCompare(*(CFNumberRef *)(a2 + 24), *(CFNumberRef *)(a1 + 24), 0);
            if ((unint64_t)(v18 + 1) > 2 || (((_BYTE)v18 + 1) & 7) != 0)
            {
              if (!SOSCircleCountRetiredPeers(a2) && SOSCircleCountPeers(a2) == 1)
                return GetOfferingStatus(a2, (uint64_t)a4, (uint64_t)a6);
              v13 = a1;
              v14 = a2;
              v15 = (uint64_t)a4;
              v16 = a5;
              return GetSignersStatus(v13, v14, v15, v16, (uint64_t)a6);
            }
            SOSCreateErrorWithFormat(1039, 0, a6, 0, CFSTR("%@"), CFSTR("Bad generation - proposed circle gencount is older than known circle gencount"));
            debugDumpCircle(CFSTR("isOlderGeneration known_circle"), a1);
            debugDumpCircle(CFSTR("isOlderGeneration proposed_circle"), a2);
            return 1;
          }
          else
          {
            v23 = 0;
            v24 = &v23;
            v25 = 0x2000000000;
            v26 = 4;
            valuePtr[0] = MEMORY[0x1E0C809B0];
            valuePtr[1] = 0x40000000;
            valuePtr[2] = __GetSignersStatus_block_invoke;
            valuePtr[3] = &unk_1E1FD1B50;
            valuePtr[6] = a4;
            valuePtr[7] = a6;
            valuePtr[8] = 0;
            valuePtr[4] = &v23;
            valuePtr[5] = a2;
            v19 = *(const __CFSet **)(a2 + 32);
            context[0] = MEMORY[0x1E0C809B0];
            context[1] = 0x40000000;
            context[2] = __SOSCircleForEachPeerMatching_block_invoke;
            context[3] = &unk_1E1FD1D20;
            context[4] = &__block_literal_global_54;
            context[5] = valuePtr;
            CFSetApplyFunction(v19, (CFSetApplierFunction)apply_block_1_5164, context);
            v17 = *((unsigned int *)v24 + 6);
            _Block_object_dispose(&v23, 8);
          }
        }
        else
        {
          if (a6)
            SOSCreateErrorWithFormat(1038, (__CFString *)*a6, a6, 0, CFSTR("%@"), CFSTR("Bad user public signature"));
          else
            SOSCreateErrorWithFormat(1038, 0, 0, 0, CFSTR("%@"), CFSTR("Bad user public signature"));
          debugDumpCircle(CFSTR("proposed_circle"), a2);
          return 5;
        }
      }
      else
      {
        if (a6)
          SOSCreateErrorWithFormat(1038, (__CFString *)*a6, a6, 0, CFSTR("%@"), CFSTR("No public signature to match current user key"));
        else
          SOSCreateErrorWithFormat(1038, 0, 0, 0, CFSTR("%@"), CFSTR("No public signature to match current user key"));
        return 2;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    SOSCreateErrorWithFormat(2, 0, a6, 0, CFSTR("%@"), CFSTR("Concordance with no user public key"));
    return 3;
  }
  return v17;
}

void debugDumpCircle(__CFString *a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  __CFData *v6;
  const __CFData *v7;
  const __CFAllocator *v8;
  CFIndex Length;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex v12;
  CFIndex v13;
  unsigned int v14;
  NSObject *v15;
  CFTypeRef v16;
  uint8_t buf[4];
  __CFString *v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v16 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  v4 = secLogObjForScope("circledebug");
  if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    if (!a2)
      return;
LABEL_3:
    v6 = SOSCircleCopyEncodedData(a2, v5, &v16);
    if (!v6)
      return;
    v7 = v6;
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Length = CFDataGetLength(v6);
    Mutable = CFStringCreateMutable(v8, 2 * Length);
    BytePtr = CFDataGetBytePtr(v7);
    v12 = CFDataGetLength(v7);
    if (v12 >= 1)
    {
      v13 = v12;
      do
      {
        v14 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v14, v16);
        --v13;
      }
      while (v13);
    }
    v15 = secLogObjForScope("circledebug");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v18 = Mutable;
      _os_log_debug_impl(&dword_18A900000, v15, OS_LOG_TYPE_DEBUG, "Full contents: %@", buf, 0xCu);
      if (!Mutable)
        goto LABEL_10;
    }
    else if (!Mutable)
    {
LABEL_10:
      CFRelease(v7);
      return;
    }
    CFRelease(Mutable);
    goto LABEL_10;
  }
  *(_DWORD *)buf = 138412546;
  v18 = a1;
  v19 = 2112;
  v20 = a2;
  _os_log_debug_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEBUG, "%@: %@", buf, 0x16u);
  if (a2)
    goto LABEL_3;
}

uint64_t GetSignersStatus(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  const __CFSet *v6;
  uint64_t v7;
  _QWORD v9[9];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  _QWORD context[6];

  if (a4)
    v5 = *(_QWORD *)(a4 + 40);
  else
    v5 = 0;
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 4;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __GetSignersStatus_block_invoke;
  v9[3] = &unk_1E1FD1B50;
  v9[6] = a3;
  v9[7] = a5;
  v9[8] = v5;
  v9[4] = &v10;
  v9[5] = a2;
  v6 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = &__block_literal_global_54;
  context[5] = v9;
  CFSetApplyFunction(v6, (CFSetApplierFunction)apply_block_1_5164, context);
  v7 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v7;
}

BOOL SOSCircleIsOffering(uint64_t a1)
{
  return !SOSCircleCountRetiredPeers(a1) && SOSCircleCountPeers(a1) == 1;
}

uint64_t GetOfferingStatus(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFSet *v3;
  uint64_t v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  _QWORD context[6];

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 4;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __GetOfferingStatus_block_invoke;
  v6[3] = &unk_1E1FD1B78;
  v6[4] = &v7;
  v6[5] = a1;
  v6[6] = a2;
  v6[7] = a3;
  v3 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = &__block_literal_global_48;
  context[5] = v6;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5164, context);
  v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t SOSCircleHasActiveValidPeerWithID(uint64_t a1, const void *a2, __SecKey *a3)
{
  const void *Value;
  uint64_t v5;
  CFTypeID v6;

  Value = CFSetGetValue(*(CFSetRef *)(a1 + 32), a2);
  if (Value && (v5 = (uint64_t)Value, v6 = CFGetTypeID(Value), v6 == SOSPeerInfoGetTypeID()))
    return SOSPeerInfoApplicationVerify(v5, a3, 0);
  else
    return 0;
}

uint64_t SOSCircleCountRetiredPeers(uint64_t a1)
{
  const __CFSet *v1;
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  _QWORD context[6];

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __SOSCircleCountRetiredPeers_block_invoke;
  v4[3] = &unk_1E1FD16F0;
  v4[4] = &v5;
  v1 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = &__block_literal_global_50;
  context[5] = v4;
  CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_5164, context);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t SOSCircleGetName(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

char *SOSCircleGetNameC(uint64_t a1)
{
  const __CFString *v1;
  CFIndex Length;
  CFIndex v3;
  char *v4;

  if (!a1)
    return strdup((const char *)&unk_18AA61AAF);
  v1 = *(const __CFString **)(a1 + 16);
  if (!v1)
    return strdup((const char *)&unk_18AA61AAF);
  CFRetain(*(CFTypeRef *)(a1 + 16));
  Length = CFStringGetLength(v1);
  v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  v4 = (char *)malloc_type_malloc(v3, 0x5ECC0363uLL);
  if (!CFStringGetCString(v1, v4, v3, 0x8000100u))
    *v4 = 0;
  CFRelease(v1);
  return v4;
}

uint64_t SOSCircleGetGeneration(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

void SOSCircleSetGeneration(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  v4 = *(const void **)(a1 + 24);
  if (v4)
  {
    *(_QWORD *)(a1 + 24) = 0;
    CFRelease(v4);
  }
  if (cf)
    CFRetain(cf);
  *(_QWORD *)(a1 + 24) = cf;
}

const __CFNumber *SOSCircleGetGenerationSint(uint64_t a1)
{
  const __CFNumber *result;
  unint64_t valuePtr;

  result = *(const __CFNumber **)(a1 + 24);
  if (result)
  {
    valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr);
    return (const __CFNumber *)valuePtr;
  }
  return result;
}

void SOSCircleGenerationSetValue(uint64_t a1, uint64_t a2)
{
  CFNumberRef v3;
  const void *v4;
  uint64_t valuePtr;

  valuePtr = a2;
  v3 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  v4 = *(const void **)(a1 + 24);
  if (v4)
    CFRelease(v4);
  *(_QWORD *)(a1 + 24) = v3;
}

uint64_t SOSCircleCountActivePeers(uint64_t a1)
{
  const __CFSet *v1;
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;
  _QWORD context[6];

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __SOSCircleCountActivePeers_block_invoke;
  v4[3] = &unk_1E1FD1678;
  v4[4] = &v5;
  v1 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = &__block_literal_global_54;
  context[5] = v4;
  CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_5164, context);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void SOSCircleForEachActivePeer(uint64_t a1, uint64_t a2)
{
  const __CFSet *v2;
  _QWORD v3[6];

  v2 = *(const __CFSet **)(a1 + 32);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __SOSCircleForEachPeerMatching_block_invoke;
  v3[3] = &unk_1E1FD1D20;
  v3[4] = &__block_literal_global_54;
  v3[5] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5164, v3);
}

uint64_t SOSCircleCountActiveValidPeers(uint64_t a1, uint64_t a2)
{
  const __CFSet *v2;
  uint64_t v3;
  _QWORD v5[5];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  _QWORD v10[5];
  _QWORD context[6];

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __SOSCircleCountActiveValidPeers_block_invoke;
  v5[3] = &unk_1E1FD16A0;
  v5[4] = &v6;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __SOSCircleForEachActiveValidPeer_block_invoke;
  v10[3] = &__block_descriptor_tmp_55_5259;
  v10[4] = a2;
  v2 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = v10;
  context[5] = v5;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5164, context);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void SOSCircleForEachActiveValidPeer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFSet *v3;
  _QWORD v4[5];
  _QWORD context[6];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __SOSCircleForEachActiveValidPeer_block_invoke;
  v4[3] = &__block_descriptor_tmp_55_5259;
  v4[4] = a2;
  context[0] = MEMORY[0x1E0C809B0];
  v3 = *(const __CFSet **)(a1 + 32);
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = v4;
  context[5] = a3;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5164, context);
}

uint64_t SOSCircleCountValidSyncingPeers(uint64_t a1, uint64_t a2)
{
  const __CFSet *v2;
  uint64_t v3;
  _QWORD v5[5];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  _QWORD v10[5];
  _QWORD context[6];

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __SOSCircleCountValidSyncingPeers_block_invoke;
  v5[3] = &unk_1E1FD16C8;
  v5[4] = &v6;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __SOSCircleForEachValidPeer_block_invoke;
  v10[3] = &__block_descriptor_tmp_56_5261;
  v10[4] = a2;
  v2 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = v10;
  context[5] = v5;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5164, context);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void SOSCircleForEachValidPeer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFSet *v3;
  _QWORD v4[5];
  _QWORD context[6];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __SOSCircleForEachValidPeer_block_invoke;
  v4[3] = &__block_descriptor_tmp_56_5261;
  v4[4] = a2;
  context[0] = MEMORY[0x1E0C809B0];
  v3 = *(const __CFSet **)(a1 + 32);
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = v4;
  context[5] = a3;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5164, context);
}

void SOSCircleForEachValidSyncingPeer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFSet *v3;
  _QWORD v4[5];
  _QWORD context[6];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __SOSCircleForEachValidPeer_block_invoke;
  v4[3] = &__block_descriptor_tmp_56_5261;
  v4[4] = a2;
  context[0] = MEMORY[0x1E0C809B0];
  v3 = *(const __CFSet **)(a1 + 32);
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = v4;
  context[5] = a3;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5164, context);
}

void SOSCircleForEachRetiredPeer(uint64_t a1, uint64_t a2)
{
  const __CFSet *v2;
  _QWORD v3[6];

  v2 = *(const __CFSet **)(a1 + 32);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __SOSCircleForEachPeerMatching_block_invoke;
  v3[3] = &unk_1E1FD1D20;
  v3[4] = &__block_literal_global_50;
  v3[5] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5164, v3);
}

CFIndex SOSCircleCountApplicants(uint64_t a1)
{
  return CFSetGetCount(*(CFSetRef *)(a1 + 40));
}

BOOL SOSCircleHasApplicant(uint64_t a1, const void *a2)
{
  return CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2) != 0;
}

CFMutableSetRef SOSCircleCopyApplicants(uint64_t a1, CFAllocatorRef allocator)
{
  return CFSetCreateMutableCopy(allocator, 0, *(CFSetRef *)(a1 + 40));
}

CFIndex SOSCircleCountRejectedApplicants(uint64_t a1)
{
  return CFSetGetCount(*(CFSetRef *)(a1 + 48));
}

BOOL SOSCircleHasRejectedApplicant(uint64_t a1, const void *a2)
{
  return CFSetContainsValue(*(CFSetRef *)(a1 + 48), a2) != 0;
}

const void *SOSCircleCopyRejectedApplicant(uint64_t a1, const void *a2)
{
  const void *Value;
  const void *v3;

  Value = CFSetGetValue(*(CFSetRef *)(a1 + 48), a2);
  v3 = Value;
  if (Value)
    CFRetain(Value);
  return v3;
}

__CFArray *SOSCircleCopyRejectedApplicants(uint64_t a1)
{
  return CFSetCopyValuesCFArray(*(const __CFSet **)(a1 + 48));
}

uint64_t SOSCircleResetToEmpty(const __CFNumber **a1)
{
  CFNumberRef v2;

  CFSetRemoveAllValues(a1[5]);
  CFSetRemoveAllValues(a1[6]);
  CFSetRemoveAllValues(a1[4]);
  CFDictionaryRemoveAllValues(a1[7]);
  v2 = SOSGenerationCreateWithBaseline(a1[3]);
  SOSCircleSetGeneration((uint64_t)a1, v2);
  if (v2)
    CFRelease(v2);
  return 1;
}

uint64_t SOSCircleResetToEmptyWithSameGeneration(const __CFNumber **a1)
{
  const __CFNumber *v2;

  v2 = SOSGenerationCopy(a1[3]);
  SOSCircleResetToEmpty(a1);
  SOSCircleSetGeneration((uint64_t)a1, v2);
  if (v2)
    CFRelease(v2);
  return 1;
}

uint64_t SOSCircleResetToOffering(const __CFNumber **a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t result;
  void *v9;

  SOSCircleResetToEmpty(a1);
  result = SOSCircleRequestAdmission((uint64_t)a1, a2, a3, a4);
  if ((_DWORD)result)
  {
    if (a3)
      v9 = *(void **)(a3 + 16);
    else
      v9 = 0;
    return SOSCircleAcceptRequest(a1, a2, a3, v9, a4);
  }
  return result;
}

uint64_t SOSCircleRequestAdmission(uint64_t a1, SecKeyRef key, uint64_t a3, CFTypeRef *a4)
{
  SecKeyRef v8;
  SecKeyRef v9;
  const void **v10;
  uint64_t v11;

  v8 = SecKeyCopyPublicKey(key);
  if (v8)
  {
    v9 = v8;
    if (SOSFullPeerInfoPromoteToApplication(a3, key, a4))
    {
      if (a3)
        v10 = *(const void ***)(a3 + 16);
      else
        v10 = 0;
      v11 = SOSCircleRecordAdmissionRequest(a1, v10, a4);
    }
    else
    {
      v11 = 0;
    }
    CFRelease(v9);
  }
  else
  {
    SOSCreateErrorWithFormat(1034, 0, a4, 0, CFSTR("%@"), CFSTR("No public key for key"));
    return 0;
  }
  return v11;
}

uint64_t SOSCircleAcceptRequest(const __CFSet **a1, __SecKey *a2, uint64_t a3, void *value, CFTypeRef *a5)
{
  __SecKey *v10;
  __CFSet *v11;
  uint64_t v12;

  if (!CFSetContainsValue(a1[5], value))
  {
    SOSCreateErrorWithFormat(1031, 0, a5, 0, CFSTR("%@"), CFSTR("Cannot accept non-applicant"));
    return 0;
  }
  v10 = SecKeyCopyPublicKey(a2);
  if (!SOSPeerInfoApplicationVerify((uint64_t)value, v10, a5))
  {
    v12 = 0;
    if (!v10)
      return v12;
    goto LABEL_4;
  }
  v11 = a1[5];
  CFSetAddValue(a1[4], value);
  CFSetRemoveValue(v11, value);
  v12 = SOSCircleGenerationSign(a1, a2, a3, a5);
  if (v10)
LABEL_4:
    CFRelease(v10);
  return v12;
}

uint64_t SOSCircleRecordAdmissionRequest(uint64_t a1, const void **value, CFTypeRef *a3)
{
  __CFSet *v6;

  if (value && SOSCircleHasPeerWithID(a1, value[5]))
  {
    SOSCreateErrorWithFormat(1030, 0, a3, 0, CFSTR("%@"), CFSTR("Cannot request admission when already a peer"));
    return 0;
  }
  else
  {
    v6 = *(__CFSet **)(a1 + 48);
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), value);
    CFSetRemoveValue(v6, value);
    return 1;
  }
}

uint64_t SOSCircleRequestReadmission(uint64_t a1, __SecKey *a2, const void **a3, CFTypeRef *a4)
{
  uint64_t result;

  result = SOSPeerInfoApplicationVerify((uint64_t)a3, a2, a4);
  if ((_DWORD)result)
    return SOSCircleRecordAdmissionRequest(a1, a3, a4);
  return result;
}

uint64_t SOSCircleRemovePeers(const __CFSet **a1, __SecKey *a2, uint64_t a3, CFSetRef theSet, CFTypeRef *a5)
{
  uint64_t v9;
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 1;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = __SOSCircleRemovePeers_block_invoke;
  v11[3] = &unk_1E1FD1758;
  v11[4] = &v12;
  v11[5] = a1;
  v11[6] = a3;
  v11[7] = a5;
  CFSetApplyFunction(theSet, (CFSetApplierFunction)apply_block_1_5164, v11);
  if (*((_BYTE *)v13 + 24))
    v9 = SOSCircleGenerationSign(a1, a2, a3, a5);
  else
    v9 = 0;
  _Block_object_dispose(&v12, 8);
  return v9;
}

uint64_t SOSCircleRemovePeerInternal(uint64_t a1, _QWORD *a2, const void **value, CFTypeRef *a4)
{
  uint64_t v8;

  if (a2)
  {
    v8 = a2[2];
    if (!value)
      goto LABEL_9;
  }
  else
  {
    v8 = 0;
    if (!value)
      goto LABEL_9;
  }
  if (SOSCircleHasPeerWithID(a1, value[5]))
  {
    if (!v8 || (SOSCircleHasPeerWithID(a1, *(const void **)(v8 + 40)) & 1) == 0)
    {
      SOSCreateErrorWithFormat(1030, 0, a4, 0, CFSTR("%@"), CFSTR("Must be peer to remove peer"));
      return 0;
    }
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 32), value);
  }
LABEL_9:
  if (CFSetContainsValue(*(CFSetRef *)(a1 + 40), value))
    return SOSCircleRejectRequest(a1, a2, value, a4);
  else
    return 1;
}

uint64_t SOSCircleRejectRequest(uint64_t a1, _QWORD *a2, _QWORD *a3, CFTypeRef *a4)
{
  const void *v7;
  uint64_t v8;
  int v9;
  __CFSet *v10;
  __CFSet *v11;

  if (a3)
  {
    v7 = (const void *)a3[5];
    if (!a2)
      goto LABEL_8;
  }
  else
  {
    v7 = 0;
    if (!a2)
      goto LABEL_8;
  }
  v8 = a2[2];
  if (v8)
    a2 = *(_QWORD **)(v8 + 40);
  else
    a2 = 0;
LABEL_8:
  v9 = CFEqual(v7, a2);
  v10 = *(__CFSet **)(a1 + 40);
  if (v9)
  {
LABEL_11:
    CFSetRemoveValue(v10, a3);
    return 1;
  }
  if (CFSetContainsValue(v10, a3))
  {
    v11 = *(__CFSet **)(a1 + 40);
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), a3);
    v10 = v11;
    goto LABEL_11;
  }
  SOSCreateErrorWithFormat(1031, 0, a4, 0, CFSTR("%@"), CFSTR("Cannot reject non-applicant"));
  return 0;
}

uint64_t SOSCircleRemovePeersByID(const __CFSet **a1, __SecKey *a2, uint64_t a3, CFSetRef theSet, CFTypeRef *a5)
{
  uint64_t v9;
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 1;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = __SOSCircleRemovePeersByID_block_invoke;
  v11[3] = &unk_1E1FD1780;
  v11[4] = &v12;
  v11[5] = a1;
  v11[6] = a3;
  v11[7] = a5;
  CFSetApplyFunction(theSet, (CFSetApplierFunction)apply_block_1_5164, v11);
  if (*((_BYTE *)v13 + 24))
    v9 = SOSCircleGenerationSign(a1, a2, a3, a5);
  else
    v9 = 0;
  _Block_object_dispose(&v12, 8);
  return v9;
}

uint64_t SOSCircleRemovePeersByIDUnsigned(uint64_t a1, CFSetRef theSet)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 1;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __SOSCircleRemovePeersByIDUnsigned_block_invoke;
  v4[3] = &unk_1E1FD17A8;
  v4[4] = &v5;
  v4[5] = a1;
  CFSetApplyFunction(theSet, (CFSetApplierFunction)apply_block_1_5164, v4);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t SOSCircleRemovePeer(const __CFSet **a1, __SecKey *a2, _QWORD *a3, const void **value, CFTypeRef *a5)
{
  uint64_t result;

  result = SOSCircleRemovePeerInternal((uint64_t)a1, a3, value, a5);
  if ((_DWORD)result)
    return SOSCircleGenerationSign(a1, a2, (uint64_t)a3, a5);
  return result;
}

uint64_t SOSCircleWithdrawRequest(uint64_t a1, const void *a2)
{
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 40), a2);
  return 1;
}

uint64_t SOSCircleRemoveRejectedPeer(uint64_t a1, const void *a2)
{
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 48), a2);
  return 1;
}

uint64_t SOSCircleAcceptRequests(const __CFSet **a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  const __CFSet *v8;
  NSObject *v9;
  uint64_t v10;
  _QWORD v12[9];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;
  _QWORD context[6];

  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 0x40000000;
  v12[2] = __SOSCircleAcceptRequests_block_invoke;
  v12[3] = &unk_1E1FD17D0;
  v12[6] = a2;
  v12[7] = a3;
  v12[8] = a4;
  v12[4] = &v13;
  v12[5] = a1;
  v8 = a1[5];
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachApplicant_block_invoke;
  context[3] = &unk_1E1FD1918;
  context[4] = v12;
  CFSetApplyFunction(v8, (CFSetApplierFunction)apply_block_1_5164, context);
  if (*((_BYTE *)v14 + 24))
  {
    SOSCircleGenerationSign(a1, a2, a3, a4);
    v9 = secLogObjForScope("circle");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context[0]) = 0;
      _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "Countersigned accepted requests", (uint8_t *)context, 2u);
    }
  }
  v10 = *((unsigned __int8 *)v14 + 24);
  _Block_object_dispose(&v13, 8);
  return v10;
}

void SOSCircleForEachApplicant(uint64_t a1, uint64_t a2)
{
  const __CFSet *v2;
  _QWORD context[5];

  v2 = *(const __CFSet **)(a1 + 40);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachApplicant_block_invoke;
  context[3] = &unk_1E1FD1918;
  context[4] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5164, context);
}

uint64_t SOSCirclePeerSigUpdate(const __CFSet **a1, SecKeyRef key, uint64_t a3, CFTypeRef *a4)
{
  SecKeyRef v8;
  const __CFSet *v9;
  const void *v10;
  uint64_t updated;
  NSObject *v12;
  _QWORD v14[7];
  _QWORD context[6];

  v8 = SecKeyCopyPublicKey(key);
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 0x40000000;
  v14[2] = __SOSCirclePeerSigUpdate_block_invoke;
  v14[3] = &__block_descriptor_tmp_45_5277;
  v14[4] = v8;
  v14[5] = a1;
  v14[6] = a3;
  context[0] = MEMORY[0x1E0C809B0];
  v9 = a1[5];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachApplicant_block_invoke;
  context[3] = &unk_1E1FD1918;
  context[4] = v14;
  CFSetApplyFunction(v9, (CFSetApplierFunction)apply_block_1_5164, context);
  if (a3)
    v10 = *(const void **)(a3 + 16);
  else
    v10 = 0;
  updated = SOSCircleUpdatePeerInfo(a1, v10);
  if ((_DWORD)updated)
  {
    SOSCircleGenerationSign(a1, key, a3, a4);
    v12 = secLogObjForScope("circle");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context[0]) = 0;
      _os_log_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEFAULT, "Generation signed updated signatures on peerinfo", (uint8_t *)context, 2u);
    }
  }
  return updated;
}

void SOSCircleForEachiCloudIdentityPeer(uint64_t a1, uint64_t a2)
{
  const __CFSet *v2;
  _QWORD v3[6];

  v2 = *(const __CFSet **)(a1 + 32);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __SOSCircleForEachPeerMatching_block_invoke;
  v3[3] = &unk_1E1FD1D20;
  v3[4] = &__block_literal_global_52;
  v3[5] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5164, v3);
}

void SOSCircleForEachBackupCapablePeerForView(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const __CFSet *v4;
  _QWORD v5[6];
  _QWORD context[6];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __SOSCircleForEachBackupCapablePeerForView_block_invoke;
  v5[3] = &__block_descriptor_tmp_57_5280;
  v5[4] = a3;
  v5[5] = a2;
  v4 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = v5;
  context[5] = a4;
  CFSetApplyFunction(v4, (CFSetApplierFunction)apply_block_1_5164, context);
}

void SOSCircleForEachRejectedApplicant(uint64_t a1, uint64_t a2)
{
  const __CFSet *v2;
  _QWORD context[5];

  v2 = *(const __CFSet **)(a1 + 48);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachRejectedApplicant_block_invoke;
  context[3] = &unk_1E1FD1940;
  context[4] = a2;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_5164, context);
}

uint64_t SOSCircleCopyPeerWithID(uint64_t a1, const void *a2)
{
  const void *Value;
  uint64_t v3;
  CFTypeID v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  Value = CFSetGetValue(*(CFSetRef *)(a1 + 32), a2);
  if (Value && (v3 = (uint64_t)Value, v4 = CFGetTypeID(Value), v4 == SOSPeerInfoGetTypeID()))
    return SOSPeerInfoCreateCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v3, 0, v5, v6, v7, v8, v9);
  else
    return 0;
}

BOOL SOSCircleHasActivePeerWithID(uint64_t a1, const void *a2)
{
  const void *Value;
  CFTypeID v3;

  Value = CFSetGetValue(*(CFSetRef *)(a1 + 32), a2);
  if (Value)
  {
    v3 = CFGetTypeID(Value);
    return v3 == SOSPeerInfoGetTypeID();
  }
  else
  {
    return 0;
  }
}

BOOL SOSCircleHasActivePeer(uint64_t a1, uint64_t a2)
{
  return a2 && SOSCircleHasActivePeerWithID(a1, *(const void **)(a2 + 40));
}

uint64_t SOSCircleHasValidSyncingPeer(uint64_t a1, const void *a2, __SecKey *a3)
{
  const void *Value;
  uint64_t v5;
  CFTypeID v6;
  const __CFDictionary *v7;

  Value = CFSetGetValue(*(CFSetRef *)(a1 + 32), a2);
  if (!Value)
    return 0;
  v5 = (uint64_t)Value;
  v6 = CFGetTypeID(Value);
  if (v6 != SOSPeerInfoGetTypeID())
    return 0;
  v7 = *(const __CFDictionary **)(v5 + 16);
  if (v7)
  {
    if (CFDictionaryGetValue(v7, CFSTR("RetirementDate")))
      return 0;
  }
  if (SOSPeerInfoIsCloudIdentity(v5))
    return 0;
  else
    return SOSPeerInfoApplicationVerify(v5, a3, 0);
}

uint64_t SOSCircleHasActiveValidPeer(uint64_t a1, uint64_t a2, __SecKey *a3)
{
  if (a2)
    return SOSCircleHasActiveValidPeerWithID(a1, *(const void **)(a2 + 40), a3);
  else
    return 0;
}

CFMutableSetRef SOSCircleCopyPeers(uint64_t a1, CFAllocatorRef allocator)
{
  CFMutableSetRef Mutable;
  const __CFSet *v4;
  _QWORD v6[5];
  _QWORD context[6];

  Mutable = CFSetCreateMutable(allocator, 0, &kSOSPeerSetCallbacks);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __SOSCircleCopyPeers_block_invoke;
  v6[3] = &__block_descriptor_tmp_60_5282;
  v6[4] = Mutable;
  context[0] = MEMORY[0x1E0C809B0];
  v4 = *(const __CFSet **)(a1 + 32);
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = &__block_literal_global_48;
  context[5] = v6;
  CFSetApplyFunction(v4, (CFSetApplierFunction)apply_block_1_5164, context);
  return Mutable;
}

CFMutableSetRef SOSCircleCopyBackupCapablePeersForView(uint64_t a1, CFAllocatorRef allocator, uint64_t a3, uint64_t a4)
{
  CFMutableSetRef Mutable;
  const __CFSet *v8;
  _QWORD v10[5];
  _QWORD v11[6];
  _QWORD context[6];

  Mutable = CFSetCreateMutable(allocator, 0, &kSOSPeerSetCallbacks);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __SOSCircleCopyBackupCapablePeersForView_block_invoke;
  v10[3] = &__block_descriptor_tmp_61_5283;
  v10[4] = Mutable;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = __SOSCircleForEachBackupCapablePeerForView_block_invoke;
  v11[3] = &__block_descriptor_tmp_57_5280;
  v11[4] = a4;
  v11[5] = a3;
  v8 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = v11;
  context[5] = v10;
  CFSetApplyFunction(v8, (CFSetApplierFunction)apply_block_1_5164, context);
  return Mutable;
}

uint64_t SOSCircleAppendConcurringPeers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFSet *v3;
  _QWORD v5[7];
  _QWORD context[6];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __SOSCircleAppendConcurringPeers_block_invoke;
  v5[3] = &__block_descriptor_tmp_62_5284;
  v5[4] = a1;
  v5[5] = a3;
  v5[6] = a2;
  v3 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = &__block_literal_global_54;
  context[5] = v5;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5164, context);
  return 1;
}

CFMutableArrayRef SOSCircleCopyConcurringPeers(uint64_t a1, uint64_t a2)
{
  CFMutableArrayRef Mutable;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  SOSCircleAppendConcurringPeers(a1, (uint64_t)Mutable, a2);
  return Mutable;
}

uint64_t SOSCircleCopyiCloudFullPeerInfoRef(uint64_t a1, CFTypeRef *a2)
{
  const __CFSet *v3;
  NSObject *v4;
  CFTypeRef *v5;
  CFTypeRef v6;
  CFTypeRef v7;
  uint64_t v8;
  _QWORD v10[7];
  uint64_t v11;
  CFTypeRef *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD context[6];

  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v11 = 0;
  v12 = (CFTypeRef *)&v11;
  v13 = 0x2000000000;
  v14 = 0;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __SOSCircleCopyiCloudFullPeerInfoRef_block_invoke;
  v10[3] = &unk_1E1FD19C8;
  v10[4] = &v15;
  v10[5] = &v11;
  v10[6] = a1;
  v3 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = &__block_literal_global_54;
  context[5] = v10;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5164, context);
  if (!v16[3] && !v12[3])
  {
    SOSErrorCreate(1044, v12 + 3, 0, CFSTR("No iCloud identity PeerInfo found in circle"));
    v4 = secLogObjForScope("icloud-identity");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context[0]) = 0;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "No iCloud identity PeerInfo found in circle", (uint8_t *)context, 2u);
    }
  }
  v5 = v12;
  if (a2)
  {
    v6 = v12[3];
    v12[3] = 0;
    if (*a2)
    {
      CFRelease(*a2);
      v5 = v12;
    }
    *a2 = v6;
  }
  v7 = v5[3];
  if (v7)
  {
    v5[3] = 0;
    CFRelease(v7);
  }
  v8 = v16[3];
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v8;
}

uint64_t SOSCircleCopyiCloudFullPeerInfoVerifier(uint64_t a1, CFTypeRef *a2)
{
  const __CFSet *v3;
  NSObject *v4;
  CFTypeRef *v5;
  CFTypeRef v6;
  CFTypeRef v7;
  uint64_t v8;
  _QWORD v10[7];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFTypeRef *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD context[6];

  v15 = 0;
  v16 = (CFTypeRef *)&v15;
  v17 = 0x2000000000;
  v18 = 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __SOSCircleCopyiCloudFullPeerInfoVerifier_block_invoke;
  v10[3] = &unk_1E1FD19F0;
  v10[5] = &v15;
  v10[6] = a1;
  v10[4] = &v11;
  v3 = *(const __CFSet **)(a1 + 32);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSCircleForEachPeerMatching_block_invoke;
  context[3] = &unk_1E1FD1D20;
  context[4] = &__block_literal_global_54;
  context[5] = v10;
  CFSetApplyFunction(v3, (CFSetApplierFunction)apply_block_1_5164, context);
  if (!v12[3] && !v16[3])
  {
    SOSErrorCreate(1044, v16 + 3, 0, CFSTR("No iCloud identity PeerInfo found in circle"));
    v4 = secLogObjForScope("icloud-identity");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context[0]) = 0;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "No iCloud identity PeerInfo found in circle", (uint8_t *)context, 2u);
    }
  }
  v5 = v16;
  if (a2)
  {
    v6 = v16[3];
    v16[3] = 0;
    if (*a2)
    {
      CFRelease(*a2);
      v5 = v16;
    }
    *a2 = v6;
  }
  v7 = v5[3];
  if (v7)
  {
    v5[3] = 0;
    CFRelease(v7);
  }
  v8 = v12[3];
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v8;
}

BOOL SOSCircleAcceptPeerFromHSA2(const __CFSet **a1, __SecKey *a2, const __CFNumber *a3, __SecKey *a4, const void *a5, uint64_t a6, CFTypeRef *a7)
{
  const void *v14;
  CFComparisonResult v15;
  unsigned __int8 v17;
  NSObject *v18;
  _BOOL8 result;
  _BOOL4 v20;
  __CFString *v21;
  __CFString *v22;
  const char *v23;
  __CFString *v24;
  __CFString *v25;
  NSObject *v26;
  CFTypeRef v27;
  uint8_t buf[4];
  __CFString *v29;
  __int16 v30;
  __CFString *v31;
  __int16 v32;
  CFTypeRef v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a6)
    v14 = *(const void **)(a6 + 16);
  else
    v14 = 0;
  CFSetAddValue(a1[4], v14);
  v15 = CFNumberCompare(a1[3], a3, 0);
  if ((unint64_t)(v15 + 1) > 2 || ((v15 + 1) & 7) != 0)
  {
    SOSCreateErrorWithFormat(1039, 0, a7, 0, CFSTR("%@"), CFSTR("Generation Count for new circle is too old"));
LABEL_26:
    v24 = SOSGenerationCountCopyDescription(a3);
    v25 = SOSGenerationCountCopyDescription(a1[3]);
    v26 = secLogObjForScope("circleOps");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      if (a7)
        v27 = *a7;
      else
        v27 = 0;
      *(_DWORD *)buf = 138412802;
      v29 = v24;
      v30 = 2112;
      v31 = v25;
      v32 = 2112;
      v33 = v27;
      _os_log_impl(&dword_18A900000, v26, OS_LOG_TYPE_DEFAULT, "Failed to regenerate circle with new gen count: %@  current gencount: %@  error: %@", buf, 0x20u);
    }
    if (v24)
      CFRelease(v24);
    if (v25)
      CFRelease(v25);
    return 0;
  }
  SOSCirclePreGenerationSign((uint64_t)a1, (uint64_t)a2);
  SOSCircleSetGeneration((uint64_t)a1, a3);
  if ((SOSCircleGenerationSign_Internal(a1, a2, a6, a7) & 1) == 0)
    goto LABEL_26;
  if (!SOSCircleSetSignature((uint64_t)a1, (uint64_t)a4, a5, a7))
  {
    v18 = secLogObjForScope("circleOps");
    v20 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v20)
      return result;
    if (a7)
      v21 = (__CFString *)*a7;
    else
      v21 = 0;
    *(_DWORD *)buf = 138412290;
    v29 = v21;
    v23 = "Failed to set signature: %@";
LABEL_25:
    _os_log_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEFAULT, v23, buf, 0xCu);
    return 0;
  }
  v17 = SOSCircleVerify((uint64_t)a1, a4, a7);
  v18 = secLogObjForScope("circleOps");
  result = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  if ((v17 & 1) == 0)
  {
    if (!result)
      return result;
    if (a7)
      v22 = (__CFString *)*a7;
    else
      v22 = 0;
    *(_DWORD *)buf = 138412290;
    v29 = v22;
    v23 = "Circle failed to validate after peer signature: %@";
    goto LABEL_25;
  }
  if (result)
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEFAULT, "Circle accepted successfully", buf, 2u);
  }
  return 1;
}

CFStringRef SOSCirclePeerInfoCopyStateString(uint64_t a1, __SecKey *a2, const void *a3, CFDictionaryRef *a4)
{
  int v7;

  if (SOSCircleVerifyPeerSignatureExists(a1, a4))
    v7 = 86;
  else
    v7 = 118;
  return SOSPeerInfoCopyStateString((uint64_t)a4, a2, a3, v7);
}

CFStringRef SOSCircleCopyStateString(uint64_t a1, uint64_t a2)
{
  __CFString *v4;
  uint64_t v5;
  CFStringRef v6;

  if (!a1)
    return 0;
  v4 = SOSGenerationCountCopyDescription(*(const __CFNumber **)(a1 + 24));
  v5 = 118;
  if (a2)
  {
    if (SOSCircleGetSignature(a1, a2, 0))
      v5 = 86;
    else
      v5 = 118;
  }
  v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("CIRCLE:    [%20@] UserSigned: %c"), v4, v5);
  if (v4)
    CFRelease(v4);
  return v6;
}

void SOSCircleLogState(const char *a1, CFSetRef *a2, uint64_t a3, uint64_t a4)
{
  CFStringRef v8;
  NSObject *v9;
  CFIndex Count;
  NSObject *v11;
  _BOOL4 v12;
  uint64_t v13;
  const __CFSet *v14;
  const __CFSet *v15;
  const __CFSet *v16;
  CFIndex v17;
  NSObject *v18;
  _BOOL4 v19;
  const __CFSet *v20;
  CFIndex v21;
  NSObject *v22;
  _BOOL4 v23;
  const __CFSet *v24;
  _QWORD v25[7];
  _QWORD v26[7];
  _QWORD v27[8];
  _QWORD v28[8];
  _QWORD v29[8];
  __int128 buf;
  uint64_t (*v31)(uint64_t);
  void *v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v8 = SOSCircleCopyStateString((uint64_t)a2, a3);
    v9 = secLogObjForScope(a1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v8;
      _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "CIRCLE:    %@", (uint8_t *)&buf, 0xCu);
    }
    if (v8)
      CFRelease(v8);
    Count = CFSetGetCount(a2[4]);
    v11 = secLogObjForScope(a1);
    v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    v13 = MEMORY[0x1E0C809B0];
    if (Count)
    {
      if (v12)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEFAULT, "Peers In Circle:", (uint8_t *)&buf, 2u);
      }
      v29[0] = v13;
      v29[1] = 0x40000000;
      v29[2] = __SOSCircleLogState_block_invoke;
      v29[3] = &__block_descriptor_tmp_72_5307;
      v29[4] = a1;
      v29[5] = a2;
      v29[6] = a3;
      v29[7] = a4;
      v14 = a2[4];
      *(_QWORD *)&buf = v13;
      *((_QWORD *)&buf + 1) = 0x40000000;
      v31 = __SOSCircleForEachPeerMatching_block_invoke;
      v32 = &unk_1E1FD1D20;
      v33 = &__block_literal_global_48;
      v34 = v29;
      CFSetApplyFunction(v14, (CFSetApplierFunction)apply_block_1_5164, &buf);
      v28[0] = v13;
      v28[1] = 0x40000000;
      v28[2] = __SOSCircleLogState_block_invoke_2;
      v28[3] = &__block_descriptor_tmp_73_5308;
      v28[4] = a1;
      v28[5] = a2;
      v28[6] = a3;
      v28[7] = a4;
      v15 = a2[4];
      *(_QWORD *)&buf = v13;
      *((_QWORD *)&buf + 1) = 0x40000000;
      v31 = __SOSCircleForEachPeerMatching_block_invoke;
      v32 = &unk_1E1FD1D20;
      v33 = &__block_literal_global_50;
      v34 = v28;
      CFSetApplyFunction(v15, (CFSetApplierFunction)apply_block_1_5164, &buf);
      v27[0] = v13;
      v27[1] = 0x40000000;
      v27[2] = __SOSCircleLogState_block_invoke_3;
      v27[3] = &__block_descriptor_tmp_74_5309;
      v27[4] = a1;
      v27[5] = a2;
      v27[6] = a3;
      v27[7] = a4;
      v16 = a2[4];
      *(_QWORD *)&buf = v13;
      *((_QWORD *)&buf + 1) = 0x40000000;
      v31 = __SOSCircleForEachPeerMatching_block_invoke;
      v32 = &unk_1E1FD1D20;
      v33 = &__block_literal_global_52;
      v34 = v27;
      CFSetApplyFunction(v16, (CFSetApplierFunction)apply_block_1_5164, &buf);
    }
    else if (v12)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEFAULT, "Peers In Circle: None", (uint8_t *)&buf, 2u);
    }
    v17 = CFSetGetCount(a2[5]);
    v18 = secLogObjForScope(a1);
    v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
    if (v17)
    {
      if (v19)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEFAULT, "Applicants To Circle:", (uint8_t *)&buf, 2u);
      }
      v26[0] = v13;
      v26[1] = 0x40000000;
      v26[2] = __SOSCircleLogState_block_invoke_75;
      v26[3] = &__block_descriptor_tmp_76_5312;
      v26[4] = a1;
      v26[5] = a3;
      v26[6] = a4;
      v20 = a2[5];
      *(_QWORD *)&buf = v13;
      *((_QWORD *)&buf + 1) = 0x40000000;
      v31 = __SOSCircleForEachApplicant_block_invoke;
      v32 = &unk_1E1FD1918;
      v33 = v26;
      CFSetApplyFunction(v20, (CFSetApplierFunction)apply_block_1_5164, &buf);
    }
    else if (v19)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEFAULT, "Applicants To Circle: None", (uint8_t *)&buf, 2u);
    }
    v21 = CFSetGetCount(a2[6]);
    v22 = secLogObjForScope(a1);
    v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
    if (v21)
    {
      if (v23)
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_18A900000, v22, OS_LOG_TYPE_DEFAULT, "Rejected Applicants To Circle:", (uint8_t *)&buf, 2u);
      }
      v24 = a2[6];
      v25[0] = v13;
      v25[1] = 0x40000000;
      v25[2] = __SOSCircleLogState_block_invoke_77;
      v25[3] = &__block_descriptor_tmp_78_5315;
      v25[4] = a1;
      v25[5] = a3;
      v25[6] = a4;
      CFSetApplyFunction(v24, (CFSetApplierFunction)apply_block_1_5164, v25);
    }
    else if (v23)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_18A900000, v22, OS_LOG_TYPE_DEFAULT, "Rejected Applicants To Circle: None", (uint8_t *)&buf, 2u);
    }
  }
}

uint64_t SOSCircleIsLegacy(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  const __CFSet *v5;
  NSObject *v6;
  const char *v7;
  uint64_t v8;
  _QWORD v10[5];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  _QWORD v15[5];
  __int128 buf;
  uint64_t (*v17)(uint64_t);
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v4 = secLogObjForScope("SOSMonitorMode");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(_QWORD *)((char *)&buf + 4) = a1;
    _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "Checking if circle %@ is legacy", (uint8_t *)&buf, 0xCu);
  }
  if (a1 && a2)
  {
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 0x40000000;
    v10[2] = __SOSCircleIsLegacy_block_invoke;
    v10[3] = &unk_1E1FD1AB8;
    v10[4] = &v11;
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 0x40000000;
    v15[2] = __SOSCircleForEachValidPeer_block_invoke;
    v15[3] = &__block_descriptor_tmp_56_5261;
    v15[4] = a2;
    v5 = *(const __CFSet **)(a1 + 32);
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 0x40000000;
    v17 = __SOSCircleForEachPeerMatching_block_invoke;
    v18 = &unk_1E1FD1D20;
    v19 = v15;
    v20 = v10;
    CFSetApplyFunction(v5, (CFSetApplierFunction)apply_block_1_5164, &buf);
  }
  v6 = secLogObjForScope("SOSMonitorMode");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (*((_BYTE *)v12 + 24))
      v7 = "Legacy";
    else
      v7 = "Not Legacy";
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "END: Circle is %s", (uint8_t *)&buf, 0xCu);
  }
  v8 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  return v8;
}

uint64_t SOSPeerInfoGetTypeID()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __SOSPeerInfoGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSPeerInfoGetTypeID_sSOSPeerInfoGetTypeIDSingleton;
  if (SOSPeerInfoGetTypeID_sSOSPeerInfoGetTypeIDOnce != -1)
    dispatch_once(&SOSPeerInfoGetTypeID_sSOSPeerInfoGetTypeIDOnce, block);
  return SOSPeerInfoGetTypeID_sSOSPeerInfoGetTypeIDSingleton;
}

void SOSPeerInfoDestroy(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;

  if (a1)
  {
    v2 = *(const void **)(a1 + 16);
    if (v2)
    {
      *(_QWORD *)(a1 + 16) = 0;
      CFRelease(v2);
    }
    v3 = *(const void **)(a1 + 24);
    if (v3)
    {
      *(_QWORD *)(a1 + 24) = 0;
      CFRelease(v3);
    }
    v4 = *(const void **)(a1 + 32);
    if (v4)
    {
      *(_QWORD *)(a1 + 32) = 0;
      CFRelease(v4);
    }
    v5 = *(const void **)(a1 + 40);
    if (v5)
    {
      *(_QWORD *)(a1 + 40) = 0;
      CFRelease(v5);
    }
    v6 = *(const void **)(a1 + 48);
    if (v6)
    {
      *(_QWORD *)(a1 + 48) = 0;
      CFRelease(v6);
    }
    v7 = *(const void **)(a1 + 64);
    if (v7)
    {
      *(_QWORD *)(a1 + 64) = 0;
      CFRelease(v7);
    }
    v8 = *(const void **)(a1 + 80);
    if (v8)
    {
      *(_QWORD *)(a1 + 80) = 0;
      CFRelease(v8);
    }
    *(_BYTE *)(a1 + 72) = 0;
  }
}

uint64_t SOSPeerInfoCompare(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const void *v5;
  const void *v6;
  BOOL v7;
  const void *v8;
  const void *v9;

  result = 0;
  if (a1 && a2)
  {
    v5 = *(const void **)(a1 + 16);
    v6 = *(const void **)(a2 + 16);
    if (v5)
      v7 = v6 == 0;
    else
      v7 = 1;
    if (v7)
    {
      if (v5 != v6)
        return 0;
    }
    else
    {
      result = CFEqual(v5, v6);
      if (!(_DWORD)result)
        return result;
    }
    v8 = *(const void **)(a1 + 24);
    v9 = *(const void **)(a2 + 24);
    if (v8 && v9)
      return CFEqual(v8, v9) != 0;
    else
      return v8 == v9;
  }
  return result;
}

CFHashCode SOSPeerInfoHash(uint64_t a1)
{
  CFHashCode v2;

  v2 = CFHash(*(CFTypeRef *)(a1 + 16));
  return CFHash(*(CFTypeRef *)(a1 + 24)) ^ v2;
}

CFStringRef SOSPeerInfoCopyFormatDescription(uint64_t a1, const __CFDictionary *a2)
{
  const __CFDictionary *v4;
  uint64_t v5;
  const __CFString *Value;
  const __CFString *v7;
  const __CFString *v8;
  CFIndex Length;
  const __CFAllocator *v10;
  CFStringRef Copy;
  CFStringRef v12;
  const __CFString *v13;
  CFMutableStringRef v14;
  CFStringRef v15;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30;
  const __CFString *v31;
  const __CFString *v32;
  _BOOL4 v33;
  _BOOL4 v34;
  _BOOL4 HasBackupKey;
  int v36;
  CFRange v37;

  if (!a1)
    return 0;
  v4 = *(const __CFDictionary **)(a1 + 16);
  v5 = 114;
  if (v4)
  {
    if (CFDictionaryGetValue(v4, CFSTR("RetirementDate")))
      v5 = 82;
    else
      v5 = 114;
  }
  v36 = SOSPeerInfoVerify((CFDictionaryRef *)a1, 0);
  HasBackupKey = SOSPeerInfoHasBackupKey(a1);
  v34 = SOSPeerInfoKVSOnly(a1);
  v33 = SOSPeerInfoSupportsCKKSForAll(a1);
  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("OSVersion"));
  v7 = SOSPeerInfoV2DictionaryCopyString(a1, (const void *)sDeviceID);
  if (v7)
  {
    v8 = v7;
    Length = CFStringGetLength(v7);
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (Length > 8)
    {
      v37.location = 0;
      v37.length = 8;
      Copy = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8, v37);
    }
    else
    {
      Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8);
    }
    v13 = Copy;
    CFRelease(v8);
  }
  else
  {
    v13 = 0;
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  }
  v14 = SOSPeerInfoCopySerialNumber(a1);
  v15 = CFStringCreateWithFormat(v10, a2, CFSTR("PI@%p"), a1);
  v16 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("ComputerName"));
  if (v16)
    v17 = v16;
  else
    v17 = CFSTR("Unknown ");
  v18 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("ModelName"));
  if (v18)
    v19 = v18;
  else
    v19 = CFSTR("Unknown ");
  v20 = *(const __CFString **)(a1 + 48);
  if (!v20)
    v20 = CFSTR("Unknown ");
  if (Value)
    v21 = Value;
  else
    v21 = CFSTR("Unknown ");
  if (v13)
    v22 = v13;
  else
    v22 = CFSTR("Unknown ");
  if (v14)
    v23 = v14;
  else
    v23 = CFSTR("Unknown ");
  v32 = v21;
  v31 = v19;
  v24 = 95;
  if (v33)
    v24 = 67;
  v30 = v24;
  v25 = 73;
  if (v34)
    v25 = 75;
  v26 = 98;
  if (HasBackupKey)
    v26 = 66;
  v29 = v25;
  v27 = 115;
  if (v36)
    v27 = 83;
  v12 = CFStringCreateWithFormat(v10, a2, CFSTR("<%@: [name: %20@] [%c%c%c%c%c%c%c%c] [type: %-20@] [spid: %8@] [os: %10@] [devid: %10@] [serial: %12@]"), v15, v17, 45, 45, v27, v5, v26, v29, 45, v30, v31, v20, v32, v22, v23);
  if (v13)
    CFRelease(v13);
  if (v14)
    CFRelease(v14);
  if (v15)
    CFRelease(v15);
  return v12;
}

CFStringRef SOSPeerInfoCopyDescription(uint64_t a1)
{
  const __CFDictionary *DebugDescriptionFormatOptions;

  DebugDescriptionFormatOptions = (const __CFDictionary *)SecGetDebugDescriptionFormatOptions();
  return SOSPeerInfoCopyFormatDescription(a1, DebugDescriptionFormatOptions);
}

uint64_t SOSPeerInfoVerify(CFDictionaryRef *a1, CFTypeRef *a2)
{
  size_t *v4;
  size_t v5;
  const uint8_t *v6;
  __SecKey *v7;
  __SecKey *v8;
  uint64_t v9;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v4 = (size_t *)ccsha256_di();
  MEMORY[0x1E0C80A78](v4);
  v6 = (const uint8_t *)v11 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v5)
    memset((char *)v11 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0), 170, v5);
  v7 = (__SecKey *)_SOSPeerInfoCopyPubKey(a1, CFSTR("PublicSigningKey"), a2);
  if (!v7)
    return 0;
  v8 = v7;
  if (!SOSDescriptionHash((uint64_t)a1, (uint64_t)v4, (uint64_t)v6, a2))
    goto LABEL_11;
  if (!sosVerifyHash(v8, *v4, v6, a1[3]))
  {
    SOSErrorCreate(1038, a2, 0, CFSTR("Signature didn't verify for %@"), a1);
LABEL_11:
    v9 = 0;
    goto LABEL_7;
  }
  v9 = 1;
LABEL_7:
  CFRelease(v8);
  return v9;
}

BOOL SOSPeerInfoHasBackupKey(uint64_t a1)
{
  CFMutableDataRef v1;
  CFMutableDataRef v2;

  v1 = SOSPeerInfoV2DictionaryCopyData(a1, (const void *)sBackupKeyKey);
  v2 = v1;
  if (v1)
    CFRelease(v1);
  return v2 != 0;
}

BOOL SOSPeerInfoKVSOnly(uint64_t a1)
{
  CFMutableStringRef v1;
  CFMutableStringRef v2;
  _BOOL8 v3;

  v1 = SOSPeerInfoCopyTransportType(a1);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = CFEqual(v1, CFSTR("KVS")) != 0;
  CFRelease(v2);
  return v3;
}

CFMutableStringRef SOSPeerInfoCopyTransportType(uint64_t a1)
{
  CFMutableStringRef result;

  result = SOSPeerInfoV2DictionaryCopyString(a1, (const void *)sTransportType);
  if (!result)
    return (CFMutableStringRef)CFRetain(CFSTR("KVS"));
  return result;
}

_QWORD *_SOSPeerInfoCopyPubKey(CFDictionaryRef *a1, const void *a2, CFTypeRef *a3)
{
  const __CFData *Value;
  const __CFData *v6;
  CFTypeID v7;
  CFAllocatorRef v8;
  _QWORD *v9;

  Value = (const __CFData *)CFDictionaryGetValue(a1[2], a2);
  v6 = Value;
  if (Value && (v7 = CFGetTypeID(Value), v7 == CFDataGetTypeID()))
  {
    v8 = CFGetAllocator(a1);
    v9 = SecKeyCreateFromPublicData((uint64_t)v8, 3, v6);
    SecAllocationError((uint64_t)v9, a3, CFSTR("Failed to create public key from data %@"), v6);
  }
  else
  {
    if (a3)
      SecError(-50, (__CFString **)a3, CFSTR("object %@ is not a data"), v6);
    return 0;
  }
  return v9;
}

uint64_t SOSDescriptionHash(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  size_t v8;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t updated;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v10 = (char *)v18 - v9;
  if (v11 >= 8)
    memset((char *)v18 - v9, 170, v8);
  ccdigest_init();
  updated = SOSPeerInfoUpdateDigestWithDescription(a1, a2, (uint64_t)v10, a4, v12, v13, v14, v15);
  if ((_DWORD)updated)
    (*(void (**)(uint64_t, char *, uint64_t))(a2 + 56))(a2, v10, a3);
  return updated;
}

BOOL sosVerifyHash(__SecKey *a1, size_t a2, const uint8_t *a3, CFDataRef theData)
{
  const uint8_t *BytePtr;
  CFIndex Length;

  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  return SecKeyRawVerify(a1, 0, a3, a2, BytePtr, Length) == 0;
}

uint64_t SOSPeerInfoUpdateDigestWithDescription(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v10;
  size_t v11;
  UInt8 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  UInt8 *v16;

  if (*(uint64_t *)(a1 + 56) >= 2)
    SOSPeerInfoPackV2Data(a1, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  v10 = der_sizeof_plist(*(const __CFString **)(a1 + 16), a4, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (v10)
  {
    v11 = v10;
    v12 = (UInt8 *)malloc_type_malloc(v10, 0xFCCDCF19uLL);
    if (v12)
    {
      v16 = v12;
      if (der_encode_plist_repair(*(const __CFString **)(a1 + 16), a4, 0, v12, (unint64_t)&v12[v11], v13, v14, v15))
      {
        ccdigest_update();
        free(v16);
        return 1;
      }
      free(v16);
      SOSCreateErrorWithFormat(1025, 0, a4, 0, CFSTR("Description encode failed"));
    }
    else
    {
      SOSCreateErrorWithFormat(1025, 0, a4, 0, CFSTR("Description alloc failed"));
    }
  }
  else
  {
    SOSCreateErrorWithFormat(1025, 0, a4, 0, CFSTR("Description length failed"));
  }
  return 0;
}

_QWORD *SOSPeerInfoCopyPubKey(CFDictionaryRef *a1, CFTypeRef *a2)
{
  return _SOSPeerInfoCopyPubKey(a1, CFSTR("PublicSigningKey"), a2);
}

_QWORD *SOSPeerInfoCopyOctagonSigningPublicKey(CFDictionaryRef *a1, CFTypeRef *a2)
{
  return _SOSPeerInfoCopyPubKey(a1, CFSTR("OctagonPublicSigningKey"), a2);
}

_QWORD *SOSPeerInfoCopyOctagonEncryptionPublicKey(CFDictionaryRef *a1, CFTypeRef *a2)
{
  return _SOSPeerInfoCopyPubKey(a1, CFSTR("OctagonPublicEncryptionKey"), a2);
}

const void *SOSPeerInfoGetAutoAcceptInfo(uint64_t a1)
{
  const void *Value;
  const void *v2;
  CFTypeID v3;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("PublicSigningKey"));
  if (!Value)
    return 0;
  v2 = Value;
  v3 = CFGetTypeID(Value);
  if (v3 != CFDataGetTypeID())
    return 0;
  return v2;
}

uint64_t SOSPeerInfoSign(__SecKey *a1, uint64_t a2, CFTypeRef *a3)
{
  size_t *v6;
  size_t v7;
  const uint8_t *v8;
  CFDataRef v9;
  CFDataRef v10;
  const void *v11;
  const __CFString *v13;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  v6 = (size_t *)ccsha256_di();
  MEMORY[0x1E0C80A78](v6);
  v8 = (const uint8_t *)v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v7)
    memset((char *)v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), 170, v7);
  if ((SOSDescriptionHash(a2, (uint64_t)v6, (uint64_t)v8, a3) & 1) == 0)
  {
    v13 = CFSTR("Failed to hash description for peer");
LABEL_11:
    SOSCreateErrorWithFormat(1040, 0, a3, 0, CFSTR("%@"), v13);
    return 0;
  }
  v9 = sosCopySignedHash(a1, v6, v8);
  if (!v9)
  {
    v13 = CFSTR("Failed to sign peerinfo for peer");
    goto LABEL_11;
  }
  v10 = v9;
  v11 = *(const void **)(a2 + 24);
  if (v11)
  {
    *(_QWORD *)(a2 + 24) = 0;
    CFRelease(v11);
  }
  *(_QWORD *)(a2 + 24) = v10;
  return 1;
}

CFDataRef sosCopySignedHash(__SecKey *a1, size_t *a2, const uint8_t *a3)
{
  __int128 v3;
  size_t sigLen;
  uint8_t sig[16];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  sigLen = 128;
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12 = v3;
  v13 = v3;
  v10 = v3;
  v11 = v3;
  v8 = v3;
  v9 = v3;
  *(_OWORD *)sig = v3;
  v7 = v3;
  if (SecKeyRawSign(a1, 0, a3, *a2, sig, &sigLen))
    return 0;
  else
    return CFDataCreate(0, sig, sigLen);
}

uint64_t SOSPeerInfoCreate(const __CFAllocator *a1, const void *a2, const void *a3, __SecKey *a4, __SecKey *a5, __SecKey *a6, int a7, CFTypeRef *a8)
{
  return SOSPeerInfoCreate_Internal(a1, a2, a3, 0, a4, a5, a6, a7, a8, &__block_literal_global_5391);
}

uint64_t SOSPeerInfoCreate_Internal(const __CFAllocator *a1, const void *a2, const void *a3, const void *a4, __SecKey *a5, __SecKey *a6, __SecKey *a7, int a8, CFTypeRef *a9, void *a10)
{
  void (**v17)(id, __CFDictionary *);
  uint64_t Instance;
  SecKeyRef v19;
  SecKeyRef v20;
  const __CFString *v21;
  uint64_t v22;
  CFTypeRef v23;
  CFTypeRef v24;
  CFTypeRef v25;
  SecKeyRef v27;
  SecKeyRef v28;
  int v29;
  SecKeyRef v30;
  SecKeyRef v31;
  int v32;
  CFNumberRef v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  __CFDictionary *MutableForCFTypesWith;
  __CFDictionary *v42;
  const __CFString *Copy;
  const __CFString *v44;
  CFIndex Length;
  const __CFAllocator *v46;
  const void **v47;
  int v48;
  CFTypeRef v50;
  CFTypeRef v51;
  CFTypeRef cf;
  uint64_t valuePtr;
  CFRange v54;

  v17 = a10;
  SOSPeerInfoGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  *(_QWORD *)(Instance + 32) = a2;
  CFRetain(a2);
  *(_QWORD *)(Instance + 56) = SOSPeerInfoGetPeerProtocolVersion(Instance);
  v51 = 0;
  cf = 0;
  v50 = 0;
  v19 = SecKeyCopyPublicKey(a5);
  if (!v19)
  {
    SOSCreateErrorWithFormat(1034, 0, a9, 0, CFSTR("%@"), CFSTR("Unable to get public"));
    CFRelease((CFTypeRef)Instance);
    v22 = 0;
    goto LABEL_9;
  }
  v20 = v19;
  if (SecKeyCopyPublicBytes((uint64_t)v19, (uint64_t)&cf))
    goto LABEL_3;
  v48 = a8;
  if (a6)
  {
    v27 = SecKeyCopyPublicKey(a6);
    if (!v27)
      goto LABEL_27;
    v28 = v27;
    v29 = SecKeyCopyPublicBytes((uint64_t)v27, (uint64_t)&v51);
    CFRelease(v28);
    if (v29)
      goto LABEL_3;
  }
  if (!a7)
    goto LABEL_20;
  v30 = SecKeyCopyPublicKey(a7);
  if (!v30)
  {
LABEL_27:
    v21 = CFSTR("Unable to get public key");
    goto LABEL_4;
  }
  v31 = v30;
  v32 = SecKeyCopyPublicBytes((uint64_t)v30, (uint64_t)&v50);
  CFRelease(v31);
  if (!v32)
  {
LABEL_20:
    *(_QWORD *)(Instance + 24) = CFDataCreateMutable(a1, 0);
    valuePtr = *(_QWORD *)(Instance + 56);
    v33 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
    MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, v34, v35, v36, v37, v38, v39, v40, CFSTR("ConflictVersion"), (uint64_t)v33);
    v42 = MutableForCFTypesWith;
    *(_QWORD *)(Instance + 16) = MutableForCFTypesWith;
    if (v51)
    {
      CFDictionarySetValue(MutableForCFTypesWith, CFSTR("OctagonPublicSigningKey"), v51);
      v42 = *(__CFDictionary **)(Instance + 16);
    }
    if (v50)
    {
      CFDictionarySetValue(v42, CFSTR("OctagonPublicEncryptionKey"), v50);
      v42 = *(__CFDictionary **)(Instance + 16);
    }
    v17[2](v17, v42);
    Copy = SOSCopyIDOfKey((uint64_t)v20, a9);
    *(_QWORD *)(Instance + 40) = Copy;
    if (Copy)
    {
      v44 = Copy;
      Length = CFStringGetLength(Copy);
      v46 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (Length > 8)
      {
        v54.location = 0;
        v54.length = 8;
        Copy = CFStringCreateWithSubstring(v46, v44, v54);
      }
      else
      {
        Copy = CFStringCreateCopy(v46, v44);
      }
    }
    *(_QWORD *)(Instance + 48) = Copy;
    *(_QWORD *)(Instance + 64) = 0;
    *(_BYTE *)(Instance + 72) = 0;
    if (*(_QWORD *)(Instance + 40))
    {
      if (!SOSPeerInfoUpdateToV2(Instance, a9))
        goto LABEL_36;
      if (a3)
        SOSPeerInfoV2DictionarySetValue(Instance, (const void *)sBackupKeyKey, a3);
      SOSPeerInfoV2DictionarySetValue(Instance, (const void *)sViewsKey, a4);
      v47 = (const void **)MEMORY[0x1E0C9AE40];
      if (v48)
        v47 = (const void **)MEMORY[0x1E0C9AE50];
      SOSPeerInfoV2DictionarySetValue(Instance, (const void *)sCKKSForAll, *v47);
      if ((SOSPeerInfoSign(a5, Instance, a9) & 1) == 0)
      {
LABEL_36:
        CFRelease((CFTypeRef)Instance);
        Instance = 0;
      }
    }
    v22 = Instance;
    Instance = (uint64_t)v33;
    if (!v33)
      goto LABEL_6;
    goto LABEL_5;
  }
LABEL_3:
  v21 = CFSTR("Failed to export public bytes");
LABEL_4:
  SOSCreateErrorWithFormat(1034, 0, a9, 0, CFSTR("%@"), v21);
  v22 = 0;
LABEL_5:
  CFRelease((CFTypeRef)Instance);
LABEL_6:
  CFRelease(v20);
  v23 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v23);
  }
LABEL_9:
  v24 = v51;
  if (v51)
  {
    v51 = 0;
    CFRelease(v24);
  }
  v25 = v50;
  if (v50)
  {
    v50 = 0;
    CFRelease(v25);
  }

  return v22;
}

uint64_t SOSPeerInfoGetPeerProtocolVersion(uint64_t a1)
{
  uint64_t v1;
  const __CFNumber *Value;
  const __CFNumber *v3;
  CFTypeID v4;
  uint64_t valuePtr;

  v1 = 3;
  valuePtr = 3;
  Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("MessageProtocolVersion"));
  if (Value)
  {
    v3 = Value;
    v4 = CFGetTypeID(Value);
    if (v4 == CFNumberGetTypeID())
    {
      CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr);
      return valuePtr;
    }
    else
    {
      return 3;
    }
  }
  return v1;
}

__CFDictionary *CFDictionaryCreateMutableForCFTypesWith(const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *key, uint64_t a10)
{
  __CFDictionary *Mutable;
  const void *v11;
  const void **v12;
  const void **v14;

  Mutable = CFDictionaryCreateMutable(a1, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v14 = (const void **)&a10;
  v11 = key;
  if (key)
  {
    do
    {
      CFDictionarySetValue(Mutable, v11, *v14);
      v12 = v14 + 1;
      v14 += 2;
      v11 = *v12;
    }
    while (*v12);
  }
  return Mutable;
}

uint64_t SOSPeerInfoCreateWithTransportAndViews(const __CFAllocator *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, __SecKey *a10, __SecKey *a11, __SecKey *a12, unsigned __int8 a13, CFTypeRef *a14)
{
  return SOSPeerInfoCreate_Internal(a1, a2, a3, a9, a10, a11, a12, a13, a14, &__block_literal_global_40);
}

uint64_t SOSPeerInfoCreateCloudIdentity(const __CFAllocator *a1, const void *a2, __SecKey *a3, CFTypeRef *a4)
{
  return SOSPeerInfoCreate_Internal(a1, a2, 0, 0, a3, 0, 0, 0, a4, &__block_literal_global_41);
}

uint64_t SOSPeerInfoCreateCopy(const __CFAllocator *a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Instance;
  CFStringRef Copy;
  uint64_t v13;

  if (!a2)
    return 0;
  SOSPeerInfoPackV2Data(a2, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  SOSPeerInfoGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  *(_QWORD *)(Instance + 16) = CFDictionaryCreateMutableCopy(a1, 0, *(CFDictionaryRef *)(a2 + 16));
  *(_QWORD *)(Instance + 24) = CFDataCreateCopy(a1, *(CFDataRef *)(a2 + 24));
  *(_QWORD *)(Instance + 32) = CFDictionaryCreateCopy(a1, *(CFDictionaryRef *)(a2 + 32));
  *(_QWORD *)(Instance + 40) = CFStringCreateCopy(a1, *(CFStringRef *)(a2 + 40));
  Copy = CFStringCreateCopy(a1, *(CFStringRef *)(a2 + 48));
  *(_QWORD *)(Instance + 64) = 0;
  *(_BYTE *)(Instance + 72) = 0;
  v13 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(Instance + 48) = Copy;
  *(_QWORD *)(Instance + 56) = v13;
  if (v13 <= 1)
    SOSPeerInfoExpandV2Data(Instance, a3);
  return Instance;
}

BOOL SOSPeerInfoVersionHasV2Data(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56) > 1;
}

BOOL SOSPeerInfoVersionIsCurrent(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56) > 2;
}

const void *SOSPeerInfoCreateCurrentCopy(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, const void *a8, __SecKey *a9, CFTypeRef *a10)
{
  uint64_t Copy;
  const void *v12;

  Copy = SOSPeerInfoCreateCopy(a1, a2, a10, a4, a5, a6, a7, (uint64_t)a8);
  v12 = (const void *)Copy;
  if (*(uint64_t *)(Copy + 56) <= 1)
    SOSPeerInfoUpdateToV2(Copy, a10);
  if (a8)
    SOSPeerInfoV2DictionarySetValue((uint64_t)v12, (const void *)sViewsKey, a8);
  if ((SOSPeerInfoSign(a9, (uint64_t)v12, a10) & 1) == 0)
  {
    CFRelease(v12);
    return 0;
  }
  return v12;
}

const void *SOSPeerInfoCopyWithModification(const __CFAllocator *a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4, void *a5)
{
  uint64_t (**v9)(id, const void *, CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *Copy;

  v9 = a5;
  Copy = (const void *)SOSPeerInfoCreateCopy(a1, a2, a4, v10, v11, v12, v13, v14);
  LODWORD(a1) = v9[2](v9, Copy, a4);

  if (!(_DWORD)a1 || (SOSPeerInfoSign(a3, (uint64_t)Copy, a4) & 1) == 0)
  {
    if (Copy)
    {
      CFRelease(Copy);
      return 0;
    }
  }
  return Copy;
}

const void *SOSPeerInfoCopyWithGestaltUpdate(const __CFAllocator *a1, uint64_t a2, uint64_t a3, __SecKey *a4, CFTypeRef *a5)
{
  _QWORD v6[5];

  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __SOSPeerInfoCopyWithGestaltUpdate_block_invoke;
  v6[3] = &__block_descriptor_40_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
  v6[4] = a3;
  return SOSPeerInfoCopyWithModification(a1, a2, a4, a5, v6);
}

const void *SOSPeerInfoCopyWithBackupKeyUpdate(const __CFAllocator *a1, uint64_t a2, uint64_t a3, __SecKey *a4, CFTypeRef *a5)
{
  _QWORD v6[5];

  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __SOSPeerInfoCopyWithBackupKeyUpdate_block_invoke;
  v6[3] = &__block_descriptor_40_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
  v6[4] = a3;
  return SOSPeerInfoCopyWithModification(a1, a2, a4, a5, v6);
}

const void *SOSPeerInfoCopyWithReplacedEscrowRecords(const __CFAllocator *a1, uint64_t a2, uint64_t a3, __SecKey *a4, CFTypeRef *a5)
{
  _QWORD v6[5];

  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __SOSPeerInfoCopyWithReplacedEscrowRecords_block_invoke;
  v6[3] = &__block_descriptor_40_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
  v6[4] = a3;
  return SOSPeerInfoCopyWithModification(a1, a2, a4, a5, v6);
}

CFMutableDataRef SOSPeerInfoCopyBackupKey(uint64_t a1)
{
  return SOSPeerInfoV2DictionaryCopyData(a1, (const void *)sBackupKeyKey);
}

const void *SOSPeerInfoCopyWithViewsChange(const __CFAllocator *a1, uint64_t a2, int a3, const void *a4, _DWORD *a5, __SecKey *a6, CFTypeRef *a7, uint64_t a8)
{
  uint64_t Copy;
  const void *v14;
  int v15;
  int v16;

  Copy = SOSPeerInfoCreateCopy(a1, a2, a7, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  v14 = (const void *)Copy;
  if (a3 == 2)
  {
    v16 = SOSViewsDisable(Copy, a4, a7);
    *a5 = v16;
    if (v16 != 2)
      goto LABEL_9;
  }
  else if (a3 == 1)
  {
    v15 = SOSViewsEnable(Copy, a4, a7);
    *a5 = v15;
    if (v15 != 1)
      goto LABEL_9;
  }
  if ((SOSPeerInfoSign(a6, (uint64_t)v14, a7) & 1) != 0)
    return v14;
  *a5 = 0;
LABEL_9:
  if (v14)
  {
    CFRelease(v14);
    return 0;
  }
  return v14;
}

uint64_t SOSPeerInfoCopyWithPing(const __CFAllocator *a1, uint64_t a2, __SecKey *a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Copy;
  const void *v11;
  _QWORD *v12;
  const void *v13;
  const __CFString *v14;
  const __CFString *v15;
  CFIndex Length;
  const __CFAllocator *v17;
  CFStringRef v18;
  uint64_t v19;
  CFRange v21;

  Copy = SOSPeerInfoCreateCopy(a1, a2, a4, (uint64_t)a4, a5, a6, a7, a8);
  v11 = (const void *)CFDataCreateWithRandomBytes(8uLL);
  SOSPeerInfoV2DictionarySetValue(Copy, CFSTR("Ping"), v11);
  v12 = _SOSPeerInfoCopyPubKey((CFDictionaryRef *)Copy, CFSTR("PublicSigningKey"), a4);
  v13 = v12;
  if (!v12)
    goto LABEL_10;
  v14 = SOSCopyIDOfKey((uint64_t)v12, a4);
  *(_QWORD *)(Copy + 40) = v14;
  if (!v14)
  {
    *(_QWORD *)(Copy + 48) = 0;
    if (!v11)
      goto LABEL_12;
LABEL_11:
    CFRelease(v11);
    goto LABEL_12;
  }
  v15 = v14;
  Length = CFStringGetLength(v14);
  v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (Length > 8)
  {
    v21.location = 0;
    v21.length = 8;
    v18 = CFStringCreateWithSubstring(v17, v15, v21);
  }
  else
  {
    v18 = CFStringCreateCopy(v17, v15);
  }
  v19 = *(_QWORD *)(Copy + 40);
  *(_QWORD *)(Copy + 48) = v18;
  if (!v19 || (SOSPeerInfoSign(a3, Copy, a4) & 1) != 0)
  {
LABEL_10:
    if (!v11)
      goto LABEL_12;
    goto LABEL_11;
  }
  CFRelease((CFTypeRef)Copy);
  Copy = 0;
  if (v11)
    goto LABEL_11;
LABEL_12:
  if (v13)
    CFRelease(v13);
  return Copy;
}

CFComparisonResult SOSPeerInfoCompareByID(const __CFString *info, const __CFString *a2)
{
  if (info && a2)
  {
    info = (const __CFString *)info[1].info;
    a2 = (const __CFString *)a2[1].info;
    if (info && a2 != 0)
      return CFStringCompare(info, a2, 0);
  }
  if ((char *)info - (char *)a2 < 0)
    return -1;
  return (unint64_t)(info != a2);
}

uint64_t SOSPeerInfoGetPeerID(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 40);
  return result;
}

uint64_t SOSPeerInfoCompareByApplicationDate(uint64_t a1, uint64_t a2)
{
  const __CFDate *Date;
  const __CFDate *v4;
  const __CFDate *v5;
  CFComparisonResult v6;

  if (a1 && a2)
  {
    Date = (const __CFDate *)sosPeerInfoGetDate(a1, CFSTR("ApplicationDate"));
    v4 = (const __CFDate *)sosPeerInfoGetDate(a2, CFSTR("ApplicationDate"));
    v5 = v4;
    if (Date && v4)
    {
      v6 = CFDateCompare(Date, v4, 0);
      CFRelease(Date);
      CFRelease(v5);
      return v6;
    }
    else
    {
      if (Date)
        CFRelease(Date);
      if (v5)
        CFRelease(v5);
      if (Date - v5 < 0)
        return -1;
      else
        return Date != v5;
    }
  }
  else if (a1 - a2 < 0)
  {
    return -1;
  }
  else
  {
    return a1 != a2;
  }
}

unint64_t sosPeerInfoGetDate(uint64_t a1, const void *a2)
{
  const __CFData *Value;

  if (a1 && (Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), a2)) != 0)
    return sosCreateCFDate(Value);
  else
    return 0;
}

unint64_t sosCreateCFDate(const __CFData *a1)
{
  const UInt8 *BytePtr;
  const UInt8 *v3;
  CFIndex Length;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v9;

  v9 = 0xAAAAAAAAAAAAAAAALL;
  BytePtr = CFDataGetBytePtr(a1);
  v3 = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  der_decode_date(0, (CFDateRef *)&v9, 0, (uint64_t)BytePtr, (uint64_t)&v3[Length], v5, v6, v7);
  return v9;
}

unint64_t SOSPeerInfoGetApplicationDate(uint64_t a1)
{
  return sosPeerInfoGetDate(a1, CFSTR("ApplicationDate"));
}

CFStringRef SOSPeerInfoCopyStateString(uint64_t a1, __SecKey *a2, const void *a3, int a4)
{
  int v7;
  const __CFDictionary *v8;
  uint64_t v9;
  _BOOL4 HasBackupKey;
  const void *v11;
  _BOOL4 v12;
  CFStringRef v13;
  int HasUserVisibleViewsEnabled;
  _BOOL4 IsLegacy;
  const __CFString *Value;
  const __CFString *v17;
  const __CFString *v18;
  CFIndex Length;
  const __CFAllocator *v20;
  CFStringRef Copy;
  const __CFString *v22;
  CFMutableStringRef v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFString *v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  const __CFString *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const __CFString *v44;
  const __CFString *v45;
  const __CFString *v46;
  _BOOL4 v47;
  _BOOL4 v48;
  _BOOL4 v49;
  _BOOL4 v50;
  int v51;
  int v52;
  CFRange v53;

  if (!a1)
    return 0;
  v7 = SOSPeerInfoApplicationVerify(a1, a2, 0);
  v8 = *(const __CFDictionary **)(a1 + 16);
  v9 = 114;
  if (v8)
  {
    if (CFDictionaryGetValue(v8, CFSTR("RetirementDate")))
      v9 = 82;
    else
      v9 = 114;
  }
  HasBackupKey = SOSPeerInfoHasBackupKey(a1);
  v11 = *(const void **)(a1 + 40);
  v52 = v7;
  v51 = a4;
  v50 = HasBackupKey;
  if (a3 && v11)
    v12 = CFEqual(v11, a3) != 0;
  else
    v12 = v11 == a3;
  v47 = v12;
  v49 = SOSPeerInfoKVSOnly(a1);
  v48 = SOSPeerInfoSupportsCKKSForAll(a1);
  HasUserVisibleViewsEnabled = SOSPeerInfoHasUserVisibleViewsEnabled(a1);
  IsLegacy = SOSPeerInfoIsLegacy(a1);
  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("OSVersion"));
  v17 = SOSPeerInfoV2DictionaryCopyString(a1, (const void *)sMachineIDKey);
  if (v17)
  {
    v18 = v17;
    Length = CFStringGetLength(v17);
    v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (Length > 8)
    {
      v53.location = 0;
      v53.length = 8;
      Copy = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v18, v53);
    }
    else
    {
      Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v18);
    }
    v22 = Copy;
    CFRelease(v18);
  }
  else
  {
    v22 = 0;
    v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  }
  v23 = SOSPeerInfoCopySerialNumber(a1);
  v24 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("ComputerName"));
  if (v24)
    v25 = v24;
  else
    v25 = CFSTR("Unknown ");
  v26 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("ModelName"));
  if (v26)
    v27 = v26;
  else
    v27 = CFSTR("Unknown ");
  v28 = *(const __CFString **)(a1 + 48);
  if (!v28)
    v28 = CFSTR("Unknown ");
  if (Value)
    v29 = Value;
  else
    v29 = CFSTR("Unknown ");
  if (v22)
    v30 = v22;
  else
    v30 = CFSTR("Unknown ");
  if (v23)
    v31 = v23;
  else
    v31 = CFSTR("Unknown ");
  v45 = v28;
  v46 = v29;
  v44 = v27;
  v32 = 79;
  if (IsLegacy)
    v32 = 76;
  v33 = 85;
  if (!HasUserVisibleViewsEnabled)
    v33 = 95;
  v43 = v32;
  v34 = 67;
  if (!v48)
    v34 = 95;
  v35 = 73;
  if (v49)
    v35 = 75;
  v41 = v35;
  v42 = v34;
  v36 = 98;
  if (v50)
    v36 = 66;
  v40 = v36;
  v37 = 97;
  if (v52)
    v37 = 65;
  v38 = 109;
  if (v47)
    v38 = 77;
  v13 = CFStringCreateWithFormat(v20, 0, CFSTR("[name: %-20@] [%c%c%c%c%c%c%c%c%c%c] [type: %-20@] [spid: %8@] [os: %10@] [mid: %10@] [serial: %12@]"), v25, v38, v37, 83, v9, v40, v41, v42, v33, v43, v51, v44, v45, v46, v30, v31);
  if (v22)
    CFRelease(v22);
  if (v23)
    CFRelease(v23);
  return v13;
}

uint64_t SOSPeerInfoApplicationVerify(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  size_t *v6;
  size_t v7;
  const uint8_t *v8;
  CFStringRef v9;
  const __CFString *v10;
  CFStringRef v11;
  const __CFData *Value;
  const __CFData *v13;
  uint64_t v14;
  const __CFString *v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v6 = (size_t *)ccsha256_di();
  MEMORY[0x1E0C80A78](v6);
  v8 = (const uint8_t *)v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v7)
    memset((char *)v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), 170, v7);
  if (!a2)
  {
    SOSErrorCreate(1033, a3, 0, CFSTR("Can't validate PeerInfos with no userKey"));
    return 0;
  }
  v9 = SOSCopyIDOfKey((uint64_t)a2, a3);
  v10 = v9;
  v11 = *(CFStringRef *)(a1 + 64);
  if (!v9 || !v11)
  {
    if (v9 != v11)
      goto LABEL_9;
LABEL_19:
    v14 = *(_BYTE *)(a1 + 72) != 0;
    goto LABEL_15;
  }
  if (CFEqual(v9, v11))
    goto LABEL_19;
  v11 = *(CFStringRef *)(a1 + 64);
LABEL_9:
  if (v11)
  {
    *(_QWORD *)(a1 + 64) = 0;
    CFRelease(v11);
  }
  *(_BYTE *)(a1 + 72) = 0;
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("ApplicationUsig"));
  if (Value)
  {
    v13 = Value;
    if (sospeer_application_hash(a1, (uint64_t)v6, (uint64_t)v8))
    {
      if (sosVerifyHash(a2, *v6, v8, v13))
      {
        *(_QWORD *)(a1 + 64) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v10);
        *(_BYTE *)(a1 + 72) = 1;
        v14 = SOSPeerInfoVerify((CFDictionaryRef *)a1, a3);
        goto LABEL_15;
      }
      v16 = CFSTR("user signature of public key hash fails to verify");
    }
    else
    {
      v16 = CFSTR("Failed to create hash for peer applicant");
    }
  }
  else
  {
    v16 = CFSTR("Peer is not an applicant");
  }
  SOSCreateErrorWithFormat(1040, 0, a3, 0, CFSTR("%@"), v16);
  v14 = 0;
LABEL_15:
  if (v10)
    CFRelease(v10);
  return v14;
}

BOOL SOSPeerInfoIsLegacy(uint64_t a1)
{
  int Class;
  const __CFString *v3;
  _BOOL8 v4;
  const char *v5;
  uint64_t v6;
  int v7;
  const __CFString *Value;

  CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("ModelName"));
  Class = SOSPeerInfoGetClass(a1);
  if (Class)
  {
    if (Class == 3)
    {
      Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("OSVersion"));
      v4 = (int)majorVersion(Value) < 21;
      v5 = "MacOS";
    }
    else
    {
      if (Class != 2)
      {
        reportLegacyStatus((uint64_t)"Default", a1, 0);
        return 0;
      }
      v3 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("OSVersion"));
      v4 = (int)majorVersion(v3) < 19;
      v5 = "IOS";
    }
    v6 = a1;
    v7 = v4;
  }
  else
  {
    v5 = "Unknown";
    v4 = 1;
    v6 = a1;
    v7 = 1;
  }
  reportLegacyStatus((uint64_t)v5, v6, v7);
  return v4;
}

uint64_t SOSPeerInfoGetClass(uint64_t a1)
{
  uint64_t result;
  const __CFString *v3;

  if (SOSPeerInfoIsCloudIdentity(a1))
    return 1;
  result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("ModelName"));
  if (result)
  {
    v3 = (const __CFString *)result;
    if (CFStringHasPrefix((CFStringRef)result, CFSTR("Mac")) || CFStringHasPrefix(v3, CFSTR("iMac")))
    {
      return 3;
    }
    else if (CFStringHasPrefix(v3, CFSTR("iPhone"))
           || CFStringHasPrefix(v3, CFSTR("iPad"))
           || CFStringHasPrefix(v3, CFSTR("iPod")))
    {
      return 2;
    }
    else if (CFStringHasPrefix(v3, CFSTR("Watch")))
    {
      return 4;
    }
    else if (CFStringHasPrefix(v3, CFSTR("AppleTV")))
    {
      return 5;
    }
    else
    {
      return 6;
    }
  }
  return result;
}

uint64_t majorVersion(const __CFString *a1)
{
  NSObject *v2;
  _BOOL4 v3;
  int v4;
  uint64_t v5;
  uint8_t *v6;
  int v7;
  NSObject *v8;
  _DWORD v10[4];
  uint8_t buf[24];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  secLogObjForScope("SOSMonitorMode");
  v2 = objc_claimAutoreleasedReturnValue();
  v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (a1)
  {
    if (v3)
    {
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = a1;
      _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "Parsing :%@:", buf, 0xCu);
    }

    memset(buf, 170, 20);
    if (CFStringGetCString(a1, (char *)buf, 20, 0x600u))
    {
      v4 = (char)buf[0];
      if (((char)buf[0] - 48) > 9)
      {
        v5 = 0;
      }
      else
      {
        LODWORD(v5) = 0;
        v6 = &buf[1];
        do
        {
          v5 = (v4 + 10 * v5 - 48);
          v7 = (char)*v6++;
          v4 = v7;
        }
        while ((v7 - 48) < 0xA);
      }
      secLogObjForScope("SOSMonitorMode");
      v8 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v10[0] = 67109120;
        v10[1] = v5;
        _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "majorVersion: %d", (uint8_t *)v10, 8u);
      }
    }
    else
    {
      secLogObjForScope("SOSMonitorMode");
      v8 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v10[0]) = 0;
        _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "No OS CString to parse", (uint8_t *)v10, 2u);
      }
      v5 = 0xFFFFFFFFLL;
    }

  }
  else
  {
    if (v3)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "No OS String to parse", buf, 2u);
    }

    return 0xFFFFFFFFLL;
  }
  return v5;
}

void reportLegacyStatus(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  const char *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;
  __int16 v12;
  const char *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  secLogObjForScope("SOSMonitorMode");
  v6 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = "Not Legacy";
    v8 = 136315650;
    v9 = a1;
    if (a3)
      v7 = "Legacy";
    v10 = 2112;
    v11 = a2;
    v12 = 2080;
    v13 = v7;
    _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "%s Peer %@ is %s", (uint8_t *)&v8, 0x20u);
  }

}

BOOL SOSPeerInfoIsCloudIdentity(uint64_t a1)
{
  const __CFDictionary *v1;
  const void *Value;
  const void *v3;
  BOOL v4;

  if (a1 && (v1 = *(const __CFDictionary **)(a1 + 16)) != 0)
  {
    Value = CFDictionaryGetValue(v1, CFSTR("CloudIdentity"));
    v3 = (const void *)*MEMORY[0x1E0C9AE50];
    if (Value)
      v4 = v3 == 0;
    else
      v4 = 1;
    if (!v4)
      return CFEqual(Value, v3) != 0;
  }
  else
  {
    Value = 0;
    v3 = (const void *)*MEMORY[0x1E0C9AE50];
  }
  return Value == v3;
}

BOOL sospeer_application_hash(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFData *Value;
  const __CFData *v7;
  CFTypeID v8;
  CFTypeID TypeID;
  size_t v10;
  uint64_t v11;
  char *v12;
  unint64_t v13;
  _BOOL8 updated;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("ApplicationDate"));
  if (!Value)
    return 0;
  v7 = Value;
  v8 = CFGetTypeID(Value);
  TypeID = CFDataGetTypeID();
  if (v8 != TypeID)
    return 0;
  MEMORY[0x1E0C80A78](TypeID);
  v12 = (char *)v16 - v11;
  if (v13 >= 8)
    memset((char *)v16 - v11, 170, v10);
  ccdigest_init();
  CFDataGetLength(v7);
  CFDataGetBytePtr(v7);
  ccdigest_update();
  updated = SOSPeerInfoUpdateDigestWithPublicKeyBytes(a1, a2, (uint64_t)v12, 0);
  if (updated)
    (*(void (**)(uint64_t, char *, uint64_t))(a2 + 56))(a2, v12, a3);
  return updated;
}

BOOL SOSPeerInfoUpdateDigestWithPublicKeyBytes(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  const __CFData *Value;
  const __CFData *v6;

  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("PublicSigningKey"));
  v6 = Value;
  if (Value)
  {
    CFDataGetLength(Value);
    CFDataGetBytePtr(v6);
    ccdigest_update();
  }
  else
  {
    SOSCreateErrorWithFormat(1025, 0, a4, 0, CFSTR("Digest failed – no public key"));
  }
  return v6 != 0;
}

const __CFDictionary *SOSPeerInfoIsRetirementTicket(const __CFDictionary *result)
{
  if (result)
  {
    result = (const __CFDictionary *)*((_QWORD *)result + 2);
    if (result)
      return (const __CFDictionary *)(CFDictionaryGetValue(result, CFSTR("RetirementDate")) != 0);
  }
  return result;
}

const void *SOSPeerInfoGetPeerName(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("ComputerName"));
}

const void *SOSPeerInfoGetPeerDeviceType(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), CFSTR("ModelName"));
}

uint64_t SOSPeerInfoGetSPID(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 48);
  return result;
}

void SOSPeerInfoLogState(const char *a1, uint64_t a2, __SecKey *a3, const void *a4, int a5)
{
  CFStringRef v6;
  NSObject *v7;
  int v8;
  CFStringRef v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v6 = SOSPeerInfoCopyStateString(a2, a3, a4, a5);
    secLogObjForScope(a1);
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 138412290;
      v9 = v6;
      _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "PI:    %@", (uint8_t *)&v8, 0xCu);
    }

    if (v6)
      CFRelease(v6);
  }
}

uint64_t SOSPeerInfoCopyPeerGestalt(uint64_t a1)
{
  CFRetain(*(CFTypeRef *)(a1 + 32));
  return *(_QWORD *)(a1 + 32);
}

uint64_t SOSPeerGetGestalt(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

const void *SOSPeerInfoLookupGestaltValue(uint64_t a1, const void *a2)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
}

BOOL SOSPeerInfoPeerIDEqual(uint64_t a1, CFTypeRef cf1)
{
  CFTypeRef v2;

  if (a1)
  {
    v2 = *(CFTypeRef *)(a1 + 40);
    if (cf1 && v2)
      return CFEqual(cf1, v2) != 0;
  }
  else
  {
    v2 = 0;
  }
  return v2 == cf1;
}

uint64_t SOSPeerInfoGetVersion(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t SOSPeerInfoCopyAsApplication(uint64_t a1, __SecKey *a2, __SecKey *a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Copy;
  size_t *v12;
  size_t v13;
  const uint8_t *v14;
  CFDataRef Date;
  CFDataRef v16;
  CFDataRef v17;
  CFStringRef v18;
  NSObject *v19;
  char v20;
  const __CFString *v22;
  uint8_t buf[8];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  Copy = SOSPeerInfoCreateCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a1, a4, (uint64_t)a4, a5, a6, a7, a8);
  v12 = (size_t *)ccsha256_di();
  MEMORY[0x1E0C80A78](v12);
  v14 = &buf[-((v13 + 15) & 0xFFFFFFFFFFFFFFF0)];
  if (v13)
    memset(&buf[-((v13 + 15) & 0xFFFFFFFFFFFFFFF0)], 170, v13);
  Date = sosCreateDate();
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Copy + 16), CFSTR("ApplicationDate"), Date);
  if (Date)
    CFRelease(Date);
  if (!sospeer_application_hash(Copy, (uint64_t)v12, (uint64_t)v14))
  {
    v22 = CFSTR("Failed to create hash for peer applicant");
LABEL_16:
    SOSCreateErrorWithFormat(1040, 0, a4, 0, CFSTR("%@"), v22);
LABEL_17:
    CFRelease((CFTypeRef)Copy);
    return 0;
  }
  v16 = sosCopySignedHash(a2, v12, v14);
  if (!v16)
  {
    v22 = CFSTR("Failed to sign public key hash for peer");
    goto LABEL_16;
  }
  v17 = v16;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Copy + 16), CFSTR("ApplicationUsig"), v16);
  v18 = SOSCopyIDOfKey((uint64_t)a2, a4);
  *(_QWORD *)(Copy + 64) = v18;
  if (v18)
  {
    *(_BYTE *)(Copy + 72) = 1;
  }
  else
  {
    secLogObjForScope("PICache");
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEFAULT, "failed to get userKeyID", buf, 2u);
    }

  }
  v20 = SOSPeerInfoSign(a3, Copy, a4);
  CFRelease(v17);
  if ((v20 & 1) == 0)
    goto LABEL_17;
  return Copy;
}

CFDataRef sosCreateDate()
{
  CFAbsoluteTime Current;
  CFDateRef v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const UInt8 *v10;
  char v12[8];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  v1 = CFDateCreate(0, Current);
  v2 = der_sizeof_date();
  v3 = MEMORY[0x1E0C80A78](v2);
  v10 = (const UInt8 *)&v12[-v9];
  if (v3)
    memset(&v12[-v9], 170, v2);
  der_encode_date((uint64_t)v1, (uint64_t)v10, (unint64_t)&v10[v2], v4, v5, v6, v7, v8, v12[0]);
  if (v1)
    CFRelease(v1);
  return CFDataCreate(0, v10, v2);
}

unint64_t SOSPeerInfoGetRetirementDate(uint64_t a1)
{
  return sosPeerInfoGetDate(a1, CFSTR("RetirementDate"));
}

const __CFDictionary *SOSPeerGestaltGetName(const __CFDictionary *result)
{
  const __CFDictionary *v1;
  CFTypeID v2;

  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("ComputerName"));
    if (result)
    {
      v1 = result;
      v2 = CFGetTypeID(result);
      if (v2 == CFStringGetTypeID())
        return v1;
      else
        return 0;
    }
  }
  return result;
}

CFDictionaryRef SOSPeerGestaltGetAnswer(CFDictionaryRef theDict, const void *key)
{
  if (theDict)
    return (CFDictionaryRef)CFDictionaryGetValue(theDict, key);
  return theDict;
}

CFMutableDictionaryRef *SOSPeerInfoCreateRetirementTicket(const __CFAllocator *a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFMutableDictionaryRef *Copy;
  CFDataRef Date;

  Copy = (CFMutableDictionaryRef *)SOSPeerInfoCreateCopy(a1, a3, a4, (uint64_t)a4, a5, a6, a7, a8);
  if (Copy)
  {
    Date = sosCreateDate();
    CFDictionaryAddValue(Copy[2], CFSTR("RetirementDate"), Date);
    if (Date)
      CFRelease(Date);
    if ((SOSPeerInfoSign(a2, (uint64_t)Copy, a4) & 1) == 0)
    {
      CFRelease(Copy);
      return 0;
    }
  }
  return Copy;
}

uint64_t SOSPeerInfoInspectRetirementTicket(uint64_t a1, CFTypeRef *a2)
{
  CFAbsoluteTime Current;
  const __CFDate *v5;
  const __CFData *Value;
  const __CFDate *CFDate;
  uint64_t v8;
  const __CFString *v10;

  Current = CFAbsoluteTimeGetCurrent();
  v5 = CFDateCreate(0, Current);
  if (!SOSPeerInfoVerify((CFDictionaryRef *)a1, a2))
    goto LABEL_11;
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("RetirementDate"));
  if (!Value)
  {
    SOSCreateErrorWithFormat(1040, 0, a2, 0, CFSTR("%@"), CFSTR("PeerInfo doesn't have a retirement date"));
LABEL_11:
    CFDate = 0;
    goto LABEL_15;
  }
  CFDate = (const __CFDate *)sosCreateCFDate(Value);
  if (CFDate)
  {
    if (CFDateCompare(v5, CFDate, 0) == kCFCompareGreaterThan)
    {
      v8 = *(_QWORD *)(a1 + 40);
      if (!v5)
        goto LABEL_7;
      goto LABEL_6;
    }
    v10 = CFSTR("Retirement date is after current date");
  }
  else
  {
    v10 = CFSTR("Peer is not retired");
  }
  SOSCreateErrorWithFormat(1040, 0, a2, 0, CFSTR("%@"), v10);
LABEL_15:
  v8 = 0;
  if (v5)
LABEL_6:
    CFRelease(v5);
LABEL_7:
  if (CFDate)
    CFRelease(CFDate);
  return v8;
}

BOOL SOSPeerInfoRetireRetirementTicket(unint64_t a1, uint64_t a2)
{
  CFAbsoluteTime Current;
  const __CFDate *v5;
  const __CFData *Value;
  const __CFDate *CFDate;
  double TimeIntervalSinceDate;

  Current = CFAbsoluteTimeGetCurrent();
  v5 = CFDateCreate(0, Current);
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 16), CFSTR("RetirementDate"));
  CFDate = (const __CFDate *)sosCreateCFDate(Value);
  TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(v5, CFDate);
  if (v5)
    CFRelease(v5);
  if (CFDate)
    CFRelease(CFDate);
  return TimeIntervalSinceDate > (double)a1;
}

uint64_t SOSPeerInfoUpgradeSignatures(int a1, SecKeyRef key, __SecKey *a3, uint64_t a4, CFTypeRef *a5)
{
  SecKeyRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v9 = SecKeyCopyPublicKey(key);
  v14 = SOSPeerInfoCopyAsApplication(a4, key, a3, a5, v10, v11, v12, v13);
  if (v9)
    CFRelease(v9);
  return v14;
}

uint64_t SOSPeerInfoSetOctagonKeysInDescription(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  int v7;
  int v8;
  uint64_t v9;
  void *v10;
  CFTypeRef v11;
  CFTypeRef cf;
  void *value;

  cf = 0;
  value = 0;
  v7 = SecKeyCopyPublicBytes(a2, (uint64_t)&value);
  v8 = SecKeyCopyPublicBytes(a3, (uint64_t)&cf);
  if (v7)
  {
    SecError(v7, a4, CFSTR("failed to copy signing public key bytes"), cf);
  }
  else
  {
    if (!v8)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("OctagonPublicSigningKey"), value);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("OctagonPublicEncryptionKey"), cf);
      v9 = 1;
      goto LABEL_4;
    }
    SecError(v8, a4, CFSTR("failed to copy encryption public key bytes"), cf);
  }
  v9 = 0;
LABEL_4:
  v10 = value;
  if (value)
  {
    value = 0;
    CFRelease(v10);
  }
  v11 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v11);
  }
  return v9;
}

const void *SOSPeerInfoSetOctagonKeys(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, __SecKey *a5, __CFString **a6)
{
  int v11;
  int v12;
  const void *v13;
  const void *v14;
  CFTypeRef v15;
  _QWORD v17[8];
  CFTypeRef cf;
  const void *v19;

  v19 = 0;
  cf = 0;
  v11 = SecKeyCopyPublicBytes(a3, (uint64_t)&v19);
  v12 = SecKeyCopyPublicBytes(a4, (uint64_t)&cf);
  if (v11)
  {
    SecError(v11, a6, CFSTR("failed to copy signing public key bytes"));
  }
  else
  {
    if (!v12)
    {
      v17[0] = MEMORY[0x1E0C809B0];
      v17[1] = 3221225472;
      v17[2] = __SOSPeerInfoSetBothOctagonKeys_block_invoke;
      v17[3] = &__block_descriptor_64_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
      v17[4] = v19;
      v17[5] = CFSTR("OctagonPublicSigningKey");
      v17[6] = cf;
      v17[7] = CFSTR("OctagonPublicEncryptionKey");
      v13 = SOSPeerInfoCopyWithModification(a1, a2, a5, (CFTypeRef *)a6, v17);
      goto LABEL_4;
    }
    SecError(v12, a6, CFSTR("failed to copy encryption public key bytes"));
  }
  v13 = 0;
LABEL_4:
  v14 = v19;
  if (v19)
  {
    v19 = 0;
    CFRelease(v14);
  }
  v15 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v15);
  }
  return v13;
}

const void *SOSPeerInfoSetOctagonSigningKey(const __CFAllocator *a1, uint64_t a2, uint64_t a3, __SecKey *a4, __CFString **a5)
{
  return SOSPeerInfoSetOctagonKey(a1, a2, (uint64_t)CFSTR("OctagonPublicSigningKey"), a3, a4, a5);
}

const void *SOSPeerInfoSetOctagonKey(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, __SecKey *a5, __CFString **a6)
{
  int v11;
  const void *v12;
  CFTypeRef v13;
  _QWORD v15[6];
  CFTypeRef cf;

  cf = 0;
  v11 = SecKeyCopyPublicBytes(a4, (uint64_t)&cf);
  if (v11)
  {
    SecError(v11, a6, CFSTR("failed to copy public key bytes"));
    v12 = 0;
  }
  else
  {
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = __SOSPeerInfoSetOctagonKey_block_invoke;
    v15[3] = &__block_descriptor_48_e170_B24__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8_____CFError_16l;
    v15[4] = cf;
    v15[5] = a3;
    v12 = SOSPeerInfoCopyWithModification(a1, a2, a5, (CFTypeRef *)a6, v15);
  }
  v13 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v13);
  }
  return v12;
}

const void *SOSPeerInfoSetOctagonEncryptionKey(const __CFAllocator *a1, uint64_t a2, uint64_t a3, __SecKey *a4, __CFString **a5)
{
  return SOSPeerInfoSetOctagonKey(a1, a2, (uint64_t)CFSTR("OctagonPublicEncryptionKey"), a3, a4, a5);
}

const __CFString *SOSPeerInfoCopyDeviceID()
{
  return CFSTR("not implemented");
}

uint64_t SOSCloudCopyKVSState()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  if (SOSCloudCopyKVSState_onceToken != -1)
    dispatch_once(&SOSCloudCopyKVSState_onceToken, &__block_literal_global_5491);
  if (SOSCloudCopyKVSState_processQueue)
  {
    v0 = dispatch_semaphore_create(0);
    SOSCloudKeychainGetAllObjectsFromCloud();
    dispatch_semaphore_wait(v0, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v0);
    v1 = v4[3];
  }
  else
  {
    v1 = 0;
  }
  _Block_object_dispose(&v3, 8);
  return v1;
}

uint64_t SOSCloudKeychainGetAllObjectsFromCloud()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))(defaultTransport + 32))();
  return result;
}

void SOSCloudTransportPut(uint64_t a1, uint64_t a2, NSObject *a3, uint64_t a4)
{
  xpc_object_t v7;
  void *v8;
  void *v9;
  CFIndex v10;
  CFErrorRef v11;

  if (a2)
  {
    v7 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_uint64(v7, "version", 1uLL);
    xpc_dictionary_set_string(v7, "operation", "PUTDictionary");
    v8 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    if (v8)
    {
      v9 = v8;
      xpc_dictionary_set_value(v7, "value", v8);
      xpc_release(v9);
      talkWithKVS(a1, (uint64_t)v7, a3, a4);
      xpc_release(v7);
      return;
    }
    v10 = 2;
  }
  else
  {
    v10 = 1;
  }
  v11 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("com.apple.security.sos.transport.error"), v10, 0);
  if (a4)
    (*(void (**)(uint64_t, _QWORD, CFErrorRef))(a4 + 16))(a4, 0, v11);
  if (v11)
    CFRelease(v11);
}

void SOSCloudTransportUpdateKeys(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, uint64_t a5)
{
  xpc_object_t v10;
  xpc_object_t v11;

  v10 = xpc_dictionary_create(0, 0, 0);
  SecXPCDictionarySetCFObject(v10, "AllKeys", a2);
  v11 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v11, "version", 1uLL);
  xpc_dictionary_set_string(v11, "operation", "RegisterKeys");
  xpc_dictionary_set_value(v11, "value", v10);
  SecXPCDictionarySetCFObject(v11, "AcctUUID", a3);
  talkWithKVS(a1, (uint64_t)v11, a4, a5);
  xpc_release(v11);
  xpc_release(v10);
}

void SOSCloudTransportGet(uint64_t a1, uint64_t a2, NSObject *a3, uint64_t a4)
{
  xpc_object_t v8;
  void *v9;
  xpc_object_t v10;
  xpc_object_t v11;
  CFErrorRef v12;

  v8 = xpc_dictionary_create(0, 0, 0);
  if (a2)
  {
    v9 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    if (v9)
    {
      v10 = v9;
      xpc_dictionary_set_value(v8, "KeysToGet", v9);
LABEL_5:
      v11 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_uint64(v11, "version", 1uLL);
      xpc_dictionary_set_string(v11, "operation", "GETv2");
      xpc_dictionary_set_value(v11, "value", v8);
      talkWithKVS(a1, (uint64_t)v11, a3, a4);
      xpc_release(v10);
      xpc_release(v8);
      xpc_release(v11);
      return;
    }
  }
  else
  {
    v10 = xpc_null_create();
    if (v10)
      goto LABEL_5;
  }
  v12 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("com.apple.security.sos.transport.error"), 1, 0);
  if (v8)
    xpc_release(v8);
  if (a4)
    (*(void (**)(uint64_t, _QWORD, CFErrorRef))(a4 + 16))(a4, 0, v12);
  if (v12)
    CFRelease(v12);
}

void SOSCloudTransportGetAll(uint64_t a1, NSObject *a2, uint64_t a3)
{
  SOSCloudTransportGet(a1, 0, a2, a3);
}

void SOSCloudTransportSync(uint64_t a1, NSObject *a2, uint64_t a3)
{
  xpc_object_t v6;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "Synchronize");
  talkWithKVS(a1, (uint64_t)v6, a2, a3);
  xpc_release(v6);
}

void SOSCloudTransportSyncAndWait(uint64_t a1, NSObject *a2, uint64_t a3)
{
  NSObject *v6;
  xpc_object_t v7;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v6 = secLogObjForScope("sync");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v8 = 136315394;
    v9 = "EFRESH";
    v10 = 2080;
    v11 = "SynchronizeAndWait";
    _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "%s XPC request to CKD: %s", (uint8_t *)&v8, 0x16u);
  }
  v7 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v7, "version", 1uLL);
  xpc_dictionary_set_string(v7, "operation", "SynchronizeAndWait");
  talkWithKVS(a1, (uint64_t)v7, a2, a3);
  xpc_release(v7);
}

void SOSCloudTransportClearAll(uint64_t a1, NSObject *a2, uint64_t a3)
{
  xpc_object_t v6;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "ClearStore");
  talkWithKVS(a1, (uint64_t)v6, a2, a3);
  xpc_release(v6);
}

void SOSCloudTransportRequestSyncWithPeers(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, uint64_t a5)
{
  xpc_object_t v10;

  v10 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v10, "version", 1uLL);
  xpc_dictionary_set_string(v10, "operation", "requestSyncWithPeers");
  SecXPCDictionarySetCFObject(v10, "peerIDList", a2);
  SecXPCDictionarySetCFObject(v10, "backupPeerIDList", a3);
  talkWithKVS(a1, (uint64_t)v10, a4, a5);
  xpc_release(v10);
}

BOOL SOSCloudTransportHasPendingKey(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  xpc_object_t v6;
  NSObject *v7;
  dispatch_queue_global_t global_queue;
  _BOOL8 v9;
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "hasPendingKey");
  SecXPCDictionarySetCFObject(v6, "key", a2);
  v7 = dispatch_semaphore_create(0);
  global_queue = dispatch_get_global_queue(-2, 0);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = __SOSCloudTransportHasPendingKey_block_invoke;
  v11[3] = &unk_1E1FD1FD0;
  v11[4] = &v12;
  v11[5] = v7;
  if (messageToProxy(a1, (uint64_t)v6, a3, (uint64_t)global_queue, (uint64_t)v11))
  {
    dispatch_semaphore_wait(v7, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v7);
    v9 = *((_BYTE *)v13 + 24) != 0;
  }
  else
  {
    dispatch_release(v7);
    v9 = 0;
  }
  _Block_object_dispose(&v12, 8);
  return v9;
}

void SOSCloudTransportRequestEnsurePeerRegistration(uint64_t a1, NSObject *a2, uint64_t a3)
{
  xpc_object_t v6;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "requestEnsurePeerRegistration");
  talkWithKVS(a1, (uint64_t)v6, a2, a3);
  xpc_release(v6);
}

void SOSCloudTransportRequestPerfCounters(uint64_t a1, NSObject *a2, uint64_t a3)
{
  xpc_object_t v6;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "PerfCounters");
  talkWithKVS(a1, (uint64_t)v6, a2, a3);
  xpc_release(v6);
}

void SOSCloudTransportFlush(uint64_t a1, NSObject *a2, uint64_t a3)
{
  xpc_object_t v6;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "version", 1uLL);
  xpc_dictionary_set_string(v6, "operation", "Flush");
  talkWithKVS(a1, (uint64_t)v6, a2, a3);
  xpc_release(v6);
}

void SOSCloudTransportRemoveKeys(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, uint64_t a5)
{
  xpc_object_t v10;

  v10 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v10, "version", 1uLL);
  xpc_dictionary_set_string(v10, "operation", "RemoveKeys");
  SecXPCDictionarySetCFObject(v10, "AcctUUID", a3);
  SecXPCDictionarySetCFObject(v10, "value", a2);
  talkWithKVS(a1, (uint64_t)v10, a4, a5);
  xpc_release(v10);
}

void teardownServiceConnection(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  uint8_t v4[16];

  v2 = secLogObjForScope("sync");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "CKP Transport: tearing down xpc connection", v4, 2u);
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 144));
  v3 = *(void **)(a1 + 136);
  if (v3)
  {
    xpc_release(v3);
    *(_QWORD *)(a1 + 136) = 0;
  }
}

void setupServiceConnection(uint64_t a1)
{
  NSObject *v2;
  _xpc_connection_s *mach_service;
  uint64_t v4;
  _QWORD handler[5];
  uint8_t buf[16];

  v2 = secLogObjForScope("sync");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "CKP Transport: setting up xpc connection", buf, 2u);
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 144));
  mach_service = xpc_connection_create_mach_service("com.apple.security.cloudkeychainproxy3", *(dispatch_queue_t *)(a1 + 144), 0);
  v4 = MEMORY[0x1E0C809B0];
  *(_QWORD *)(a1 + 136) = mach_service;
  handler[0] = v4;
  handler[1] = 0x40000000;
  handler[2] = __setupServiceConnection_block_invoke;
  handler[3] = &__block_descriptor_tmp_17_5505;
  handler[4] = a1;
  xpc_connection_set_event_handler(mach_service, handler);
  xpc_connection_activate(*(xpc_connection_t *)(a1 + 136));
}

void __setupServiceConnection_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  _QWORD block[5];
  uint8_t v9[16];
  uint64_t v10;
  uint64_t v11;

  if (a2 == MEMORY[0x1E0C81260])
  {
    v10 = v2;
    v11 = v3;
    v5 = secLogObjForScope("sync");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v9 = 0;
      _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "CKP Transport: xpc connection invalid. Will tear down connection.", v9, 2u);
    }
    v6 = *(_QWORD *)(a1 + 32);
    v7 = *(NSObject **)(v6 + 144);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __setupServiceConnection_block_invoke_15;
    block[3] = &__block_descriptor_tmp_16_5508;
    block[4] = v6;
    dispatch_async(v7, block);
  }
}

void __setupServiceConnection_block_invoke_15(uint64_t a1)
{
  teardownServiceConnection(*(_QWORD *)(a1 + 32));
}

void SecXPCDictionarySetCFObject(void *a1, const char *a2, uint64_t a3)
{
  void *v5;
  void *v6;

  if (a3)
    v5 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  else
    v5 = xpc_null_create();
  v6 = v5;
  xpc_dictionary_set_value(a1, a2, v5);
  xpc_release(v6);
}

void talkWithKVS(uint64_t a1, uint64_t a2, NSObject *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  CFErrorRef v11;
  _QWORD v12[7];
  _QWORD v13[6];
  uint64_t v14;
  uint8_t buf[4];
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((OctagonIsSOSFeatureEnabled() & 1) != 0)
  {
    v14 = 0;
    dispatch_retain(a3);
    v8 = *(_QWORD *)(a1 + 144);
    v9 = MEMORY[0x1E0C809B0];
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 0x40000000;
    v13[2] = __talkWithKVS_block_invoke;
    v13[3] = &unk_1E1FD1E98;
    v13[4] = a4;
    v13[5] = a3;
    if (!messageToProxy(a1, a2, &v14, v8, (uint64_t)v13))
    {
      v10 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v16 = v14;
        _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, "talkWithKVS error: %@", buf, 0xCu);
      }
      v12[0] = v9;
      v12[1] = 0x40000000;
      v12[2] = __talkWithKVS_block_invoke_11;
      v12[3] = &unk_1E1FD1EC0;
      v12[4] = a4;
      v12[5] = v14;
      v12[6] = a3;
      dispatch_async(a3, v12);
    }
  }
  else if (a4)
  {
    v11 = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("com.apple.security.sos.transport.error"), 9, 0);
    (*(void (**)(uint64_t, _QWORD, CFErrorRef))(a4 + 16))(a4, 0, v11);
    if (v11)
      CFRelease(v11);
  }
}

void __talkWithKVS_block_invoke(uint64_t a1, void *a2)
{
  CFErrorRef CFErrorWithXPCObject;
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  xpc_object_t value;
  NSObject *v9;
  _QWORD v10[8];
  uint8_t buf[4];
  void *v12;
  __int16 v13;
  CFErrorRef v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (MEMORY[0x18D7718B8](a2) == MEMORY[0x1E0C812F8])
  {
    if (xpc_dictionary_get_value(a2, "value"))
    {
      v6 = _CFXPCCreateCFObjectFromXPCObject();
    }
    else
    {
      v7 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "missing value reply", buf, 2u);
      }
      v6 = 0;
    }
    value = xpc_dictionary_get_value(a2, "error");
    if (value)
      CFErrorWithXPCObject = SecCreateCFErrorWithXPCObject(value);
    else
      CFErrorWithXPCObject = 0;
  }
  else
  {
    CFErrorWithXPCObject = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("com.apple.security.sos.transport.error"), 8, 0);
    v5 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      v12 = a2;
      v13 = 2112;
      v14 = CFErrorWithXPCObject;
      _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "Odd reply from CloudKeychainProxy: %@: %@", buf, 0x16u);
    }
    v6 = 0;
  }
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __talkWithKVS_block_invoke_7;
  v10[3] = &unk_1E1FD1E70;
  v9 = *(NSObject **)(a1 + 40);
  v10[4] = *(_QWORD *)(a1 + 32);
  v10[5] = v6;
  v10[6] = CFErrorWithXPCObject;
  v10[7] = v9;
  dispatch_async(v9, v10);
}

BOOL messageToProxy(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  NSObject *v6;
  const void *v7;
  _QWORD block[9];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v6 = *(NSObject **)(a1 + 144);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __messageToProxy_block_invoke;
  block[3] = &unk_1E1FD1EE8;
  block[6] = a1;
  block[7] = a2;
  block[8] = a4;
  block[4] = a5;
  block[5] = &v10;
  dispatch_sync(v6, block);
  v7 = (const void *)v11[3];
  if (v7)
  {
    if (a3 && !*a3)
      *a3 = v7;
    else
      CFRelease(v7);
  }
  _Block_object_dispose(&v10, 8);
  return v7 == 0;
}

void __talkWithKVS_block_invoke_11(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(v2 + 16))(v2, 0, *(_QWORD *)(a1 + 40));
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
}

void __messageToProxy_block_invoke(uint64_t a1)
{
  uint64_t v2;
  _xpc_connection_s *v3;
  void *v4;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_xpc_connection_s **)(v2 + 136);
  if ((v3 || (setupServiceConnection(v2), (v3 = *(_xpc_connection_s **)(*(_QWORD *)(a1 + 48) + 136)) != 0))
    && (v4 = *(void **)(a1 + 56)) != 0)
  {
    xpc_connection_send_message_with_reply(v3, v4, *(dispatch_queue_t *)(a1 + 64), *(xpc_handler_t *)(a1 + 32));
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = CFErrorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("com.apple.security.sos.transport.error"), 6, 0);
  }
}

void __talkWithKVS_block_invoke_7(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  NSObject *v4;
  uint64_t v5;
  const void *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    (*(void (**)(uint64_t, _QWORD, _QWORD))(v2 + 16))(v2, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  v3 = *(const void **)(a1 + 40);
  if (v3)
    CFRelease(v3);
  if (*(_QWORD *)(a1 + 48))
  {
    v4 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(_QWORD *)(a1 + 48);
      v7 = 138412290;
      v8 = v5;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "callback error: %@", (uint8_t *)&v7, 0xCu);
    }
    v6 = *(const void **)(a1 + 48);
    if (v6)
      CFRelease(v6);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 56));
}

uint64_t SOSCloudTransportSetDefaultTransport(uint64_t result)
{
  defaultTransport = result;
  return result;
}

void SOSCloudKeychainSetItemsChangedBlock(const void *a1)
{
  uint64_t v2;
  NSObject *v3;
  const void *v4;
  uint8_t v5[16];

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  v2 = defaultTransport;
  if (*(const void **)(defaultTransport + 112) != a1)
  {
    v3 = secLogObjForScope("sync");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "Changing itemsChangedBlock", v5, 2u);
    }
    v4 = *(const void **)(v2 + 112);
    if (v4)
      _Block_release(v4);
    *(_QWORD *)(v2 + 112) = _Block_copy(a1);
  }
}

uint64_t SOSCloudKeychainPutObjectsInCloud()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))defaultTransport)();
  return result;
}

uint64_t SOSCloudKeychainUpdateKeys()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))(defaultTransport + 8))();
  return result;
}

uint64_t SOSCloudKeychainRemoveKeys()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))(defaultTransport + 120))();
  return result;
}

uint64_t SOSCloudKeychainHandleUpdateMessage(uint64_t a1)
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = *(_QWORD *)(defaultTransport + 112);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, a1);
  return result;
}

uint64_t SOSCloudKeychainGetObjectsFromCloud()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))(defaultTransport + 24))();
  return result;
}

uint64_t SOSCloudKeychainSynchronizeAndWait()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))(defaultTransport + 48))();
  return result;
}

uint64_t SOSCloudKeychainSynchronize()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))(defaultTransport + 40))();
  return result;
}

void SOSCloudKeychainClearAll(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  uint8_t v6[16];

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  v4 = defaultTransport;
  v5 = secLogObjForScope("circleOps");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "SOSCloudKeychainClearAll called", v6, 2u);
  }
  if (v4)
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v4 + 56))(v4, a1, a2);
}

uint64_t SOSCloudKeychainRequestSyncWithPeers()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))(defaultTransport + 80))();
  return result;
}

uint64_t SOSCloudKeychainHasPendingKey()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))(defaultTransport + 72))();
  return result;
}

uint64_t SOSCloudKeychainRequestEnsurePeerRegistration()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))(defaultTransport + 88))();
  return result;
}

uint64_t SOSCloudKeychainRequestPerfCounters()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))(defaultTransport + 96))();
  return result;
}

uint64_t SOSCloudKeychainFlush()
{
  uint64_t result;

  if (SOSCloudTransportDefaultTransport_sTransportOnce != -1)
    dispatch_once(&SOSCloudTransportDefaultTransport_sTransportOnce, &__block_literal_global_19_5493);
  result = defaultTransport;
  if (defaultTransport)
    return (*(uint64_t (**)(void))(defaultTransport + 104))();
  return result;
}

__CFData *SOSPiggyBackBlobCopyEncodedData(const __CFNumber *a1, uint64_t a2, const __CFData *a3, CFTypeRef *a4)
{
  const __CFAllocator *v8;
  CFIndex v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeRef v13;
  CFTypeRef v15;
  char v16;
  _QWORD v17[8];
  CFTypeRef cf;

  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  cf = 0;
  if (SecKeyCopyPublicBytes(a2, (uint64_t)&cf))
  {
    SOSCreateErrorWithFormat(1034, 0, a4, 0, CFSTR("%@"), CFSTR("Failed to export public bytes"));
LABEL_3:
    v9 = 0;
    goto LABEL_10;
  }
  if (!der_sizeof_number(a1, a4) || !der_sizeof_data_or_null((const __CFData *)cf) || !der_sizeof_data_or_null(a3))
  {
    SecCFCreateErrorWithFormat(-1, (const __CFString *)sSecDERErrorDomain, 0, a4, v10, CFSTR("don't know how to encode"), v11, v12, v16);
    v15 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v15);
    }
    goto LABEL_3;
  }
  v13 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v13);
  }
  v9 = ccder_sizeof();
LABEL_10:
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3221225472;
  v17[2] = __SOSPiggyBackBlobCopyEncodedData_block_invoke;
  v17[3] = &__block_descriptor_64_e11__24__0Q8_16l;
  v17[4] = a1;
  v17[5] = a2;
  v17[6] = a3;
  v17[7] = a4;
  return CFDataCreateWithDER(v8, v9, v17);
}

uint64_t SOSPiggyBackAddToKeychain(void *a1, void *a2)
{
  id v3;

  v3 = a1;
  objc_msgSend(a2, "enumerateObjectsUsingBlock:", &__block_literal_global_5544);
  objc_msgSend(v3, "enumerateObjectsUsingBlock:", &__block_literal_global_11);

  return 1;
}

id SOSPiggyCopyInitialSyncData(_QWORD *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  void *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  id v19;
  uint64_t v20;
  id v21;
  void *v22;
  id v23;
  id v24;
  void *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __CFString *v32;
  const UInt8 *v33;
  const void *v34;
  NSObject *v35;
  uint8_t *v36;
  NSObject *v37;
  const char *v38;
  uint32_t v39;
  char v40;
  NSObject *v41;
  NSObject *v42;
  id v43;
  NSObject *v44;
  __int128 v46;
  uint64_t v47;
  _QWORD *v48;
  void *v49;
  __int16 v50;
  CFTypeRef cf;
  uint64_t v52;
  id v53;
  id v54;
  uint64_t v55;
  _BYTE buf[12];
  __int16 v57;
  void *v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (!ccder_decode_tl())
  {
    secLogObjForScope("piggy");
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v10 = "Failed to parse CONS SEQ";
LABEL_15:
      _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
    }
LABEL_50:
    v43 = 0;
    goto LABEL_61;
  }
  v3 = ccder_decode_tl();
  if (!v3)
  {
    secLogObjForScope("piggy");
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v10 = "Failed to parse CONS SEQ of ident";
      goto LABEL_15;
    }
    goto LABEL_50;
  }
  v4 = v3;
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v5 = objc_claimAutoreleasedReturnValue();
  v6 = v4 - 0x5555555555555556;
  v7 = v4;
  do
  {
    *(_QWORD *)buf = 0;
    v7 = piggy_decode_data(v7, v6, buf);
    v8 = *(id *)buf;
    v9 = v8;
    if (!v7)
    {

      v5 = 0;
      goto LABEL_17;
    }
    if (v8)
      -[NSObject addObject:](v5, "addObject:", v8);

  }
  while (v7 != v6);
  if (v5)
    objc_msgSend(v2, "setObject:forKeyedSubscript:", v5, CFSTR("idents"));
LABEL_17:
  v11 = ccder_decode_tl();
  if (!v11)
  {
    secLogObjForScope("piggy");
    v42 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v42, OS_LOG_TYPE_DEFAULT, "Failed to parse CONS SEQ of TLKs", buf, 2u);
    }

    goto LABEL_50;
  }
  v12 = v11;
  v48 = a1;
  v13 = v11 - 0x5555555555555556;
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  *(_QWORD *)&v14 = 67109120;
  v46 = v14;
  v47 = v12;
  while (v12 != v13)
  {
    objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    v55 = 0;
    v16 = ccder_decode_tl();
    if (!v16)
    {
      v22 = 0;
LABEL_54:

LABEL_55:
      goto LABEL_56;
    }
    v17 = v16 + v55;
    v54 = 0;
    v18 = piggy_decode_data(v16, v16 + v55, &v54);
    v19 = v54;
    objc_msgSend(v15, "setObject:forKeyedSubscript:", v19, CFSTR("v_Data"));

    v53 = 0;
    v20 = piggy_decode_data(v18, v17, &v53);
    v21 = v53;
    v22 = v21;
    if (!v20 || objc_msgSend(v21, "length") != 16)
      goto LABEL_54;
    v23 = objc_alloc(MEMORY[0x1E0CB3A28]);
    v24 = objc_retainAutorelease(v22);
    v25 = (void *)objc_msgSend(v23, "initWithUUIDBytes:", objc_msgSend(v24, "bytes"));
    objc_msgSend(v25, "UUIDString");
    v26 = (void *)objc_claimAutoreleasedReturnValue();

    objc_msgSend(v15, "setObject:forKeyedSubscript:", v26, CFSTR("acct"));
    v52 = 0;
    v27 = ccder_decode_uint64();
    if (v27)
    {
      v31 = v27;
      v32 = CFSTR("Manatee");
      switch(v52)
      {
        case 1:
          goto LABEL_40;
        case 2:
          v32 = CFSTR("Engram");
          goto LABEL_40;
        case 3:
          v32 = CFSTR("AutoUnlock");
          goto LABEL_40;
        case 4:
          v32 = CFSTR("Health");
          goto LABEL_40;
        default:
          secLogObjForScope("piggy");
          v35 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
            goto LABEL_37;
          *(_DWORD *)buf = v46;
          *(_DWORD *)&buf[4] = v52;
          v36 = buf;
          v37 = v35;
          v38 = "unexpected view number: %d";
          v39 = 8;
          break;
      }
      goto LABEL_36;
    }
    *(_QWORD *)buf = 0;
    cf = 0;
    v33 = der_decode_string(0, (CFStringRef *)&cf, (CFTypeRef *)buf, v20, v17, v28, v29, v30);
    v32 = (__CFString *)cf;
    if (v33 && cf)
    {
      v31 = (uint64_t)v33;
      v34 = *(const void **)buf;
      if (*(_QWORD *)buf)
      {
        *(_QWORD *)buf = 0;
        CFRelease(v34);
      }
LABEL_40:
      objc_msgSend(v15, "setObject:forKeyedSubscript:", v32, CFSTR("srvr"), v46);
      if (v31 == v17)
      {
        secLogObjForScope("piggy");
        v41 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)&buf[4] = v32;
          v57 = 2112;
          v58 = v26;
          _os_log_impl(&dword_18A900000, v41, OS_LOG_TYPE_DEFAULT, "Adding %@ %@", buf, 0x16u);
        }

        objc_msgSend(v49, "addObject:", v15);
        v40 = 1;
        v12 = v17;
      }
      else
      {
        v40 = 0;
      }
      goto LABEL_45;
    }
    if (cf)
      CFRelease(cf);
    secLogObjForScope("piggy");
    v35 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      v50 = 0;
      v36 = (uint8_t *)&v50;
      v37 = v35;
      v38 = "Failed to parse view name";
      v39 = 2;
LABEL_36:
      _os_log_impl(&dword_18A900000, v37, OS_LOG_TYPE_DEFAULT, v38, v36, v39);
    }
LABEL_37:

    v40 = 0;
    v32 = 0;
LABEL_45:

    if ((v40 & 1) == 0)
      goto LABEL_55;
  }
  if (v49)
  {
    objc_msgSend(v2, "setObject:forKeyedSubscript:", v49, CFSTR("tlks"));

  }
LABEL_56:
  *v48 = v47 - 0x5555555555555556;
  if (!objc_msgSend(v2, "count", v46))
  {
    secLogObjForScope("piggy");
    v44 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v44, OS_LOG_TYPE_DEFAULT, "NO DATA, falling back to waiting 5 minutes for initial sync to finish", buf, 2u);
    }

    v2 = 0;
  }
  v43 = v2;
  v2 = v43;
LABEL_61:

  return v43;
}

uint64_t piggy_decode_data(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v5;

  result = ccder_decode_tl();
  if (result)
  {
    v5 = result;
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", result, 0);
    *a3 = (id)objc_claimAutoreleasedReturnValue();
    return v5;
  }
  return result;
}

uint64_t SOSPiggyBackBlobCreateFromDER(_QWORD *a1, _QWORD *a2, _QWORD *a3, uint64_t *a4, uint64_t a5, int a6, _BYTE *a7, CFTypeRef *a8)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  NSObject *v34;
  int v35;
  int v36;
  id v37;
  NSObject *v38;
  _QWORD *v39;
  CFTypeRef v40;
  __CFString *v42;
  const __CFString *v43;
  const __CFString *v44;
  CFTypeRef cf;
  uint64_t v46;
  CFNumberRef v47;
  uint64_t v48;
  uint8_t buf[4];
  int v50;
  __int16 v51;
  int v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v47 = 0;
  v48 = 0xAAAAAAAAAAAAAAAALL;
  cf = 0;
  v46 = 0;
  *a7 = 1;
  v16 = ccder_decode_constructed_tl();
  *a4 = v16;
  if (!v48)
  {
    if (a8)
    {
      v42 = (__CFString *)*a8;
      v43 = CFSTR("Bad Blob DER");
LABEL_22:
      SOSCreateErrorWithFormat(1035, v42, a8, 0, CFSTR("%@"), v43);
      goto LABEL_15;
    }
    v44 = CFSTR("Bad Blob DER");
LABEL_25:
    SOSCreateErrorWithFormat(1035, 0, 0, 0, CFSTR("%@"), v44);
    goto LABEL_15;
  }
  v20 = *MEMORY[0x1E0C9AE00];
  v21 = der_decode_number((const __CFAllocator *)*MEMORY[0x1E0C9AE00], &v47, a8, v16, v48, v17, v18, v19);
  *a4 = v21;
  v25 = der_decode_data_or_null(v20, &cf, a8, v21, v48, v22, v23, v24);
  *a4 = v25;
  v29 = der_decode_data_or_null(v20, &v46, a8, v25, v48, v26, v27, v28);
  *a4 = v29;
  if (!a6 || v29 == a5)
  {
    secLogObjForScope("piggy");
    v38 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v38, OS_LOG_TYPE_DEFAULT, "Piggybacking version 0, setting initial sync timeout to 5 minutes", buf, 2u);
    }

    *a7 = 1;
    if (*a4 && *a4 == a5)
      goto LABEL_13;
    if (a8)
    {
      v42 = (__CFString *)*a8;
      v43 = CFSTR("Didn't consume all bytes for pbblob");
      goto LABEL_22;
    }
    v44 = CFSTR("Didn't consume all bytes for pbblob");
    goto LABEL_25;
  }
  SOSPiggyCopyInitialSyncData(a4);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = v30;
  if (v30)
  {
    objc_msgSend(v30, "objectForKeyedSubscript:", CFSTR("idents"));
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v31, "objectForKeyedSubscript:", CFSTR("tlks"));
    v33 = (void *)objc_claimAutoreleasedReturnValue();
    secLogObjForScope("piggy");
    v34 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      v35 = objc_msgSend(v32, "count");
      v36 = objc_msgSend(v33, "count");
      *(_DWORD *)buf = 67109376;
      v50 = v35;
      v51 = 1024;
      v52 = v36;
      _os_log_impl(&dword_18A900000, v34, OS_LOG_TYPE_DEFAULT, "Piggybacking include identities(%d) and tlks(%d)", buf, 0xEu);
    }

    v37 = v32;
    objc_msgSend(v33, "enumerateObjectsUsingBlock:", &__block_literal_global_5544);
    objc_msgSend(v37, "enumerateObjectsUsingBlock:", &__block_literal_global_11);

    *a7 = 0;
  }

LABEL_13:
  v39 = SecKeyCreateFromPublicData(v20, 3, (CFDataRef)cf);
  *a2 = v39;
  if (v39)
  {
    *a1 = v47;
    *a3 = v46;
  }
LABEL_15:
  v40 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v40);
  }
  return 1;
}

uint64_t SOSPiggyBackBlobCreateFromData(_QWORD *a1, _QWORD *a2, _QWORD *a3, CFDataRef theData, int a5, _BYTE *a6, CFTypeRef *a7)
{
  CFIndex Length;
  const UInt8 *BytePtr;

  Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  SOSPiggyBackBlobCreateFromDER(a1, a2, a3, (uint64_t *)&BytePtr, (uint64_t)&BytePtr[Length], a5, a6, a7);
  return 1;
}

__CFData *SOSCopyECWrappedData(uint64_t a1, const __CFData *a2, CFTypeRef *a3)
{
  CFIndex v6;
  __CFData *Mutable;
  uint64_t v8;
  uint64_t v10;

  SecRequirementError(a2 != 0, a3, CFSTR("data required for wrapping"));
  if (!a2)
    return 0;
  SecRequirementError(a1 != 0, a3, CFSTR("ec pub key required for wrapping"));
  if (!a1)
    return 0;
  CFDataGetLength(a2);
  v6 = ccec_rfc6637_wrap_key_size();
  Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v6);
  if (!SecAllocationError((uint64_t)Mutable, a3, CFSTR("%s CFData allocation failed"), "SOSCopyECWrappedData"))
  {
LABEL_7:
    if (!Mutable)
      return Mutable;
    CFRelease(Mutable);
    return 0;
  }
  CFDataGetMutableBytePtr(Mutable);
  CFDataGetLength(a2);
  CFDataGetBytePtr(a2);
  v10 = ccrng();
  v8 = ccec_rfc6637_wrap_key();
  if ((_DWORD)v8)
  {
    SOSErrorCreate(1028, a3, 0, CFSTR("Wrap failed with %d"), v8, v10);
    goto LABEL_7;
  }
  return Mutable;
}

uint64_t SOSPerformWithUnwrappedData(uint64_t a1, CFDataRef theData, uint64_t a3, uint64_t a4)
{
  CFIndex Length;
  uint64_t v9;
  _QWORD v11[9];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;
  _QWORD v16[5];

  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  Length = CFDataGetLength(theData);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = __SOSPerformWithUnwrappedData_block_invoke;
  v11[3] = &unk_1E1FD20D8;
  v11[6] = a1;
  v11[7] = theData;
  v11[8] = a3;
  v11[4] = a4;
  v11[5] = &v12;
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 0x40000000;
  v16[2] = __PerformWithBufferAndClear_block_invoke;
  v16[3] = &unk_1E1FDC2B8;
  v16[4] = v11;
  PerformWithBuffer(Length, (uint64_t)v16);
  v9 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  return v9;
}

__CFData *SOSCopyECUnwrappedData(int a1, CFDataRef theData, CFTypeRef *a3)
{
  __CFData *Mutable;
  uint64_t v6;
  const UInt8 *BytePtr;
  CFIndex length;

  length = CFDataGetLength(theData);
  Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, length);
  if (SecAllocationError((uint64_t)Mutable, a3, CFSTR("%s CFData allocation failed"), "SOSCopyECUnwrappedData"))
  {
    CFDataGetMutableBytePtr(Mutable);
    CFDataGetLength(theData);
    BytePtr = CFDataGetBytePtr(theData);
    v6 = ccec_rfc6637_unwrap_key();
    if ((_DWORD)v6)
      SOSErrorCreate(1028, a3, 0, CFSTR("Unwrap failed with %d"), v6, BytePtr, length);
    else
      SecRequirementError(0, a3, CFSTR("Unexpected algorithm: %d"), 170);
  }
  if (Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t SOSFullPeerInfoGetTypeID()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __SOSFullPeerInfoGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSFullPeerInfoGetTypeID_sSOSFullPeerInfoGetTypeIDSingleton;
  if (SOSFullPeerInfoGetTypeID_sSOSFullPeerInfoGetTypeIDOnce != -1)
    dispatch_once(&SOSFullPeerInfoGetTypeID_sSOSFullPeerInfoGetTypeIDOnce, block);
  return SOSFullPeerInfoGetTypeID_sSOSFullPeerInfoGetTypeIDSingleton;
}

void SOSFullPeerInfoDestroy(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;

  v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0;
    CFRelease(v3);
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0;
    CFRelease(v4);
  }
  v5 = (const void *)a1[5];
  if (v5)
  {
    a1[5] = 0;
    CFRelease(v5);
  }
}

uint64_t SOSFullPeerInfoCompare(uint64_t a1, uint64_t a2)
{
  _BOOL8 v4;
  CFTypeRef v5;
  CFTypeRef v6;
  const void *v7;
  _BOOL8 v8;

  if (!CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16)))
    return 0;
  if (CFEqual(*(CFTypeRef *)(a1 + 24), *(CFTypeRef *)(a2 + 24)))
    return 1;
  v5 = SOSFullPeerInfoCopyDeviceKey(a1, 0);
  v6 = SOSFullPeerInfoCopyDeviceKey(a2, 0);
  v7 = v6;
  if (v5 && v6)
  {
    v8 = CFEqual(v5, v6) != 0;
  }
  else
  {
    v8 = 0;
    v4 = 0;
    if (!v5)
      goto LABEL_10;
  }
  CFRelease(v5);
  v4 = v8;
LABEL_10:
  if (v7)
    CFRelease(v7);
  return v4;
}

CFHashCode SOSFullPeerInfoHash(uint64_t a1)
{
  return CFHash(*(CFTypeRef *)(a1 + 16));
}

CFStringRef SOSFullPeerInfoCopyFormatDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("<SOSFullPeerInfo@%p: \"%@\">"), a1, *(_QWORD *)(a1 + 16));
}

CFStringRef SOSFullPeerInfoCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();
  return CFStringCreateWithFormat(0, 0, CFSTR("<SOSFullPeerInfo@%p: \"%@\">"), a1, *(_QWORD *)(a1 + 16));
}

CFTypeRef SOSFullPeerInfoCopyDeviceKey(uint64_t a1, CFTypeRef *a2)
{
  CFDictionaryRef *v3;
  _QWORD *v5;
  const void *v6;
  CFTypeRef v7;
  NSObject *v8;
  uint64_t v9;
  int v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v3 = *(CFDictionaryRef **)(a1 + 16);
  if (!v3)
    return 0;
  v5 = _SOSPeerInfoCopyPubKey(v3, CFSTR("PublicSigningKey"), a2);
  if (!v5)
    return 0;
  v6 = v5;
  v7 = SecKeyCopyMatchingPrivateKey(v5, (__CFString **)a2);
  if (!v7)
  {
    secLogObjForScope("circleOp");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(_QWORD *)(a1 + 16);
      if (v9)
        v9 = *(_QWORD *)(v9 + 48);
      v11 = 138412290;
      v12 = v9;
      _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "Failed to find my private key for spid %@", (uint8_t *)&v11, 0xCu);
    }

  }
  CFRelease(v6);
  return v7;
}

BOOL SOSFullPeerInfoUpdate(uint64_t a1, CFTypeRef *a2, void *a3)
{
  uint64_t (**v5)(id, _QWORD, CFTypeRef, CFTypeRef *);
  CFTypeRef v6;
  const void *v7;
  uint64_t v8;
  _BOOL8 v9;
  uint64_t v10;
  const void *v11;

  v5 = a3;
  v6 = SOSFullPeerInfoCopyDeviceKey(a1, a2);
  if (v6)
  {
    v7 = v6;
    v8 = v5[2](v5, *(_QWORD *)(a1 + 16), v6, a2);
    v9 = v8 != 0;
    if (v8)
    {
      v10 = v8;
      v11 = *(const void **)(a1 + 16);
      if (v11)
        CFRelease(v11);
      *(_QWORD *)(a1 + 16) = v10;
    }
    CFRelease(v7);
  }
  else
  {
    v9 = 0;
  }

  return v9;
}

BOOL SOSFullPeerInfoUpdateToThisPeer(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __SOSFullPeerInfoUpdateToThisPeer_block_invoke;
  v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

uint64_t SOSFullPeerInfoCreate(const __CFAllocator *a1, const void *a2, void *a3, const void *a4, __SecKey *a5, __SecKey *a6, __SecKey *a7, CFTypeRef *a8)
{
  return SOSFullPeerInfoCreateWithViews(a1, a3, a2, a4, 0, a5, a6, a7, a8);
}

uint64_t SOSFullPeerInfoCreateWithViews(const __CFAllocator *a1, void *a2, const void *a3, const void *a4, const void *a5, __SecKey *a6, __SecKey *a7, __SecKey *a8, CFTypeRef *a9)
{
  uint64_t Instance;
  uint64_t Internal;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  void *v33;
  void *v34;
  SecKeyRef v35;
  SecKeyRef v36;
  const __CFData *v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  NSObject *v45;
  NSObject *v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  void *v54;
  void *v55;
  SecKeyRef v56;
  SecKeyRef v57;
  const __CFData *v58;
  uint64_t v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  NSObject *v66;
  const char *v67;
  void *v69;
  void *v70;
  uint64_t v71;
  uint64_t v72;
  uint8_t buf[16];

  SOSFullPeerInfoGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  Internal = SOSPeerInfoCreate_Internal(a1, a3, a4, a5, a6, a7, a8, 1, a9, &__block_literal_global_40);
  *(_QWORD *)(Instance + 16) = Internal;
  if (!Internal)
    goto LABEL_31;
  v25 = SecKeyCopyPersistentRef((uint64_t)a6, (CFTypeRef *)(Instance + 24), v19, v20, v21, v22, v23, v24);
  if (!SecError(v25, (__CFString **)a9, CFSTR("Inflating persistent ref")))
    goto LABEL_31;
  v32 = SecKeyCopyPersistentRef((uint64_t)a7, (CFTypeRef *)(Instance + 32), v26, v27, v28, v29, v30, v31);
  if (v32 == -25300)
  {
    v33 = (void *)objc_msgSend(objc_alloc((Class)get_SFECKeyPairClass()), "initWithSecKey:", a7);
    createKeyLabel((const __CFDictionary *)a3, a2, CFSTR("Octagon Peer Signing "));
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    v35 = SecKeyCopyPublicKey(a7);
    if (v35)
    {
      v36 = v35;
      v69 = v33;
      v70 = a2;
      objc_msgSend(v33, "keyData");
      v37 = (const __CFData *)objc_claimAutoreleasedReturnValue();
      v72 = 0;
      LODWORD(v36) = SOSFullPeerInfoSaveOctagonKeysToKeychain(v34, v37, v36, &v72);
      v38 = v72;

      if (!(_DWORD)v36 || v38)
      {
        secLogObjForScope("SecError");
        v46 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18A900000, v46, OS_LOG_TYPE_DEFAULT, "Unable to save octagon signing key to the keychain", buf, 2u);
        }

        v32 = -25300;
      }
      else
      {
        v32 = SecKeyCopyPersistentRef((uint64_t)a7, (CFTypeRef *)(Instance + 32), v39, v40, v41, v42, v43, v44);
      }
      v33 = v69;
      a2 = v70;
    }
    else
    {
      secLogObjForScope("SecError");
      v45 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v45, OS_LOG_TYPE_DEFAULT, "Unable to get public from octagon peer signing key", buf, 2u);
      }

      v32 = -25300;
    }

  }
  if (!SecError(v32, (__CFString **)a9, CFSTR("Inflating octagon peer signing persistent ref")))
    goto LABEL_31;
  v53 = SecKeyCopyPersistentRef((uint64_t)a8, (CFTypeRef *)(Instance + 40), v47, v48, v49, v50, v51, v52);
  if (v53 != -25300)
    goto LABEL_29;
  v54 = (void *)objc_msgSend(objc_alloc((Class)get_SFECKeyPairClass()), "initWithSecKey:", a8);
  createKeyLabel((const __CFDictionary *)a3, a2, CFSTR("Octagon Peer Encryption "));
  v55 = (void *)objc_claimAutoreleasedReturnValue();
  v56 = SecKeyCopyPublicKey(a8);
  if (!v56)
  {
    secLogObjForScope("SecError");
    v66 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v67 = "Unable to get public from octagon peer encryption key";
LABEL_26:
      _os_log_impl(&dword_18A900000, v66, OS_LOG_TYPE_DEFAULT, v67, buf, 2u);
    }
LABEL_27:

    v53 = -25300;
    goto LABEL_28;
  }
  v57 = v56;
  objc_msgSend(v54, "keyData");
  v58 = (const __CFData *)objc_claimAutoreleasedReturnValue();
  v71 = 0;
  LODWORD(v57) = SOSFullPeerInfoSaveOctagonKeysToKeychain(v55, v58, v57, &v71);
  v59 = v71;

  if (!(_DWORD)v57 || v59)
  {
    secLogObjForScope("SecError");
    v66 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v67 = "Unable to save octagon encryption key to the keychain";
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  v53 = SecKeyCopyPersistentRef((uint64_t)a8, (CFTypeRef *)(Instance + 40), v60, v61, v62, v63, v64, v65);
LABEL_28:

LABEL_29:
  if (!SecError(v53, (__CFString **)a9, CFSTR("Inflating octagon peer encryption persistent ref")))
  {
LABEL_31:
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

id get_SFECKeyPairClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)get_SFECKeyPairClass_softClass;
  v7 = get_SFECKeyPairClass_softClass;
  if (!get_SFECKeyPairClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __get_SFECKeyPairClass_block_invoke;
    v3[3] = &unk_1E1FD8CF0;
    v3[4] = &v4;
    __get_SFECKeyPairClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_18A9B6614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id createKeyLabel(const __CFDictionary *a1, void *a2, void *a3)
{
  void *v5;
  id v6;
  id v7;
  void *v8;
  void *v9;

  v5 = (void *)MEMORY[0x1E0CB3940];
  v6 = a3;
  v7 = a2;
  objc_msgSend(v5, "stringWithFormat:", CFSTR("ID for %@-%@"), SOSPeerGestaltGetName(a1), v7);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v6, "stringByAppendingString:", v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  return v9;
}

BOOL SOSFullPeerInfoSaveOctagonKeysToKeychain(void *a1, const __CFData *a2, const void *a3, _QWORD *a4)
{
  id v7;
  CFDictionaryRef v8;
  void *v9;
  uint64_t v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  void *v23;
  void *v24;
  _BOOL8 v25;
  uint64_t v26;
  uint64_t v27;
  CFTypeRef result;

  v7 = a1;
  v8 = SecKeyCopyAttributeDictionaryWithLocalKey(a3, (uint64_t)CFSTR("73"), a2);
  v9 = (void *)-[__CFDictionary mutableCopy](v8, "mutableCopy");

  objc_msgSend(v9, "setObject:forKeyedSubscript:", v7, CFSTR("labl"));
  objc_msgSend(v9, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0], CFSTR("nleg"));
  objc_msgSend(v9, "setObject:forKeyedSubscript:", *MEMORY[0x1E0C9AE40], CFSTR("sync"));
  objc_msgSend(v9, "setObject:forKeyedSubscript:", CFSTR("com.apple.security.sos"), CFSTR("agrp"));
  result = 0;
  v10 = SecItemAdd((CFDictionaryRef)v9, &result);
  if ((_DWORD)v10)
  {
    if ((_DWORD)v10 == -25299)
    {
      v11 = objc_alloc_init(MEMORY[0x1E0C99E08]);
      objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("class"));
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v12, CFSTR("class"));

      objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("73"));
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v13, CFSTR("type"));

      objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("1"));
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v14, CFSTR("kcls"));

      objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("agrp"));
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v15, CFSTR("agrp"));

      objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("labl"));
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v16, CFSTR("labl"));

      objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("klbl"));
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v17, CFSTR("klbl"));

      objc_msgSend(v9, "objectForKeyedSubscript:", CFSTR("nleg"));
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v18, CFSTR("nleg"));

      v19 = (void *)objc_msgSend(v9, "mutableCopy");
      objc_msgSend(v19, "setObject:forKeyedSubscript:", 0, CFSTR("class"));
      v20 = (void *)SecItemUpdate((CFDictionaryRef)v11, (CFDictionaryRef)v19);
      if ((_DWORD)v20)
      {
        v21 = (void *)MEMORY[0x1E0CB35C8];
        v22 = *MEMORY[0x1E0CB2F90];
        objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("SecItemUpdate: %d"), v20);
        v23 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v21, "errorWithDomain:code:description:", v22, (int)v20, v23);
        v24 = (void *)objc_claimAutoreleasedReturnValue();

      }
      else
      {
        v24 = 0;
      }

    }
    else
    {
      v20 = (void *)MEMORY[0x1E0CB35C8];
      v26 = *MEMORY[0x1E0CB2F90];
      v27 = (int)v10;
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("SecItemAdd: %d"), v10);
      v11 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v20, "errorWithDomain:code:description:", v26, v27, v11);
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(v20) = 1;
    }

    if (a4 && v24)
      *a4 = objc_retainAutorelease(v24);
    v25 = (_DWORD)v20 == 0;

  }
  else
  {
    v25 = 1;
  }

  return v25;
}

_QWORD *SOSFullPeerInfoCopyFullPeerInfo(uint64_t a1)
{
  const __CFAllocator *v2;
  uint64_t Instance;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t Copy;
  const void *v13;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  SOSFullPeerInfoGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  v9 = (_QWORD *)Instance;
  if (!a1 || ((v10 = *(_QWORD *)(a1 + 16)) != 0 ? (v11 = Instance == 0) : (v11 = 1), v11))
  {
    if (!Instance)
      return v9;
LABEL_11:
    CFRelease(v9);
    return 0;
  }
  Copy = SOSPeerInfoCreateCopy(v2, v10, 0, v4, v5, v6, v7, v8);
  v9[2] = Copy;
  if (!Copy)
    goto LABEL_11;
  v13 = *(const void **)(a1 + 24);
  if (v13)
    CFRetain(v13);
  v9[3] = v13;
  return v9;
}

uint64_t SOSFullPeerInfoGetPeerInfo(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

BOOL SOSFullPeerInfoUpdateOctagonKeys(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  _QWORD v5[6];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SOSFullPeerInfoUpdateOctagonKeys_block_invoke;
  v5[3] = &__block_descriptor_48_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  v5[4] = a2;
  v5[5] = a3;
  return SOSFullPeerInfoUpdate(a1, a4, v5);
}

BOOL SOSFullPeerInfoUpdateOctagonSigningKey(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __SOSFullPeerInfoUpdateOctagonSigningKey_block_invoke;
  v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

BOOL SOSFullPeerInfoUpdateOctagonEncryptionKey(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __SOSFullPeerInfoUpdateOctagonEncryptionKey_block_invoke;
  v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

BOOL SOSFullPeerInfoSetCKKS4AllSupport(uint64_t a1, int a2, CFTypeRef *a3)
{
  uint64_t v5;
  NSObject *v6;
  const __CFString *v7;
  _QWORD v9[4];
  char v10;
  uint8_t buf[4];
  const __CFString *v12;
  uint64_t v13;

  v5 = a1;
  v13 = *MEMORY[0x1E0C80C00];
  if (a1)
    a1 = *(_QWORD *)(a1 + 16);
  if (SOSPeerInfoSupportsCKKSForAll(a1) == a2)
    return 1;
  secLogObjForScope("circleChange");
  v6 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = CFSTR("not supported");
    if (a2)
      v7 = CFSTR("supported");
    *(_DWORD *)buf = 138412290;
    v12 = v7;
    _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "Setting CKKS4All status to '%@'", buf, 0xCu);
  }

  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = __SOSFullPeerInfoSetCKKS4AllSupport_block_invoke;
  v9[3] = &__block_descriptor_33_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  v10 = a2;
  return SOSFullPeerInfoUpdate(v5, a3, v9);
}

CFTypeRef SOSPeerInfoCopyData(CFDictionaryRef *a1, CFTypeRef *a2)
{
  _QWORD *v3;
  const void *v4;
  __CFData *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  const __CFDictionary *v13;
  OSStatus v14;
  CFTypeRef v15;
  NSObject *v16;
  uint8_t buf[8];
  CFTypeRef result;

  result = 0;
  v3 = _SOSPeerInfoCopyPubKey(a1, CFSTR("PublicSigningKey"), a2);
  if (!v3)
    goto LABEL_7;
  v4 = v3;
  v5 = SecKeyCopyPublicKeyHash(v3);
  v13 = CFDictionaryCreateForCFTypes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, v7, v8, v9, v10, v11, v12, (uint64_t)CFSTR("class"), (uint64_t)CFSTR("keys"));
  if (v5)
    CFRelease(v5);
  v14 = SecItemCopyMatching(v13, &result);
  SecError(v14, (__CFString **)a2, CFSTR("Error finding persistent ref to key from public: %@"), v4);
  if (v13)
    CFRelease(v13);
  CFRelease(v4);
  v15 = result;
  if (!result)
  {
LABEL_7:
    secLogObjForScope("fpi");
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEFAULT, "no private key found", buf, 2u);
    }

    return result;
  }
  return v15;
}

CFDictionaryRef CFDictionaryCreateForCFTypes(CFAllocatorRef allocator, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  unint64_t v11;
  uint64_t *v12;
  unint64_t v13;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v15;
  const void *v16;
  const void **v17;
  const void *v18;
  const void *v19;
  const void *v20;
  CFDictionaryRef Copy;
  uint64_t *v23;
  const void **v24;

  v23 = &a10;
  v11 = 0;
  if (a9)
  {
    do
    {
      v11 += 2;
      v12 = v23;
      v23 += 2;
    }
    while (v12[1]);
  }
  v13 = v11 >> 1;
  v24 = (const void **)&a9;
  Mutable = CFDictionaryCreateMutable(allocator, v11 >> 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v15 = Mutable;
  if (v11)
  {
    v16 = (const void *)*MEMORY[0x1E0C9B0D0];
    do
    {
      v17 = v24;
      v18 = *v24;
      v24 += 2;
      v19 = v17[1];
      if (v19)
        v20 = v19;
      else
        v20 = v16;
      CFDictionarySetValue(v15, v18, v20);
      --v13;
    }
    while (v13);
  }
  Copy = CFDictionaryCreateCopy(allocator, v15);
  CFRelease(v15);
  return Copy;
}

_QWORD *SOSFullPeerInfoCreateCloudIdentity(uint64_t a1, void *a2, CFTypeRef *a3)
{
  _QWORD *Instance;
  _QWORD *v6;
  const void *v7;
  CFTypeRef PersistentRefToMatchingPrivateKey;

  SOSFullPeerInfoGetTypeID();
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  Instance[2] = a2;
  if (!a2 || (CFRetain(a2), !Instance[2]))
  {
    v7 = Instance;
    goto LABEL_7;
  }
  v6 = _SOSPeerInfoCopyPubKey((CFDictionaryRef *)a2, CFSTR("PublicSigningKey"), a3);
  if (v6)
  {
    v7 = v6;
    PersistentRefToMatchingPrivateKey = SecKeyCreatePersistentRefToMatchingPrivateKey(v6, (__CFString **)a3);
    Instance[3] = PersistentRefToMatchingPrivateKey;
    if (PersistentRefToMatchingPrivateKey)
    {
LABEL_8:
      CFRelease(v7);
      return Instance;
    }
    CFRelease(Instance);
LABEL_7:
    Instance = 0;
    goto LABEL_8;
  }
  return Instance;
}

uint64_t SOSFullPeerInfoCreateFromDER(const __CFAllocator *a1, CFTypeRef *a2, uint64_t *a3)
{
  uint64_t Instance;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const UInt8 *v12;

  SOSFullPeerInfoGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  *a3 = ccder_decode_constructed_tl();
  v7 = *(const void **)(Instance + 16);
  if (v7)
  {
    *(_QWORD *)(Instance + 16) = 0;
    CFRelease(v7);
  }
  v8 = SOSPeerInfoCreateFromDER(a1, a2, a3);
  *(_QWORD *)(Instance + 16) = v8;
  if (!v8
    || (v12 = der_decode_data(a1, (CFDataRef *)(Instance + 24), a2, *a3, 0xAAAAAAAAAAAAAAAALL, v9, v10, v11),
        (*a3 = (uint64_t)v12) == 0))
  {
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

uint64_t SOSFullPeerInfoCreateFromData(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3)
{
  const UInt8 *BytePtr;

  if (!theData)
    return 0;
  CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  return SOSFullPeerInfoCreateFromDER(a1, a3, (uint64_t *)&BytePtr);
}

BOOL SOSFullPeerInfoUpdateGestalt(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __SOSFullPeerInfoUpdateGestalt_block_invoke;
  v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

BOOL SOSFullPeerInfoUpdateV2Dictionary(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __SOSFullPeerInfoUpdateV2Dictionary_block_invoke;
  v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

BOOL SOSFullPeerInfoUpdateBackupKey(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __SOSFullPeerInfoUpdateBackupKey_block_invoke;
  v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

BOOL SOSFullPeerInfoReplaceEscrowRecords(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __SOSFullPeerInfoReplaceEscrowRecords_block_invoke;
  v4[3] = &__block_descriptor_40_e375_____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__32__0____OpaqueSOSPeerInfo____CFRuntimeBase_QAQ_____CFDictionary_____CFData_____CFDictionary_____CFString_____CFString_q____CFString_BB____CFDictionary__8____SecKey____CFRuntimeBase_QAQ_____SecKeyDescriptor__v_16_____CFError_24l;
  v4[4] = a2;
  return SOSFullPeerInfoUpdate(a1, a3, v4);
}

uint64_t SOSFullPeerInfoUpdateViews(uint64_t a1, int a2, uint64_t a3, CFTypeRef *a4)
{
  NSObject *v8;
  const char *v9;
  uint64_t v10;
  _QWORD v12[6];
  int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 0;
  secLogObjForScope("viewChange");
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if ((a2 - 1) > 2)
      v9 = "unknownViewAction";
    else
      v9 = off_1E1FD26F0[a2 - 1];
    *(_DWORD *)buf = 136315394;
    v19 = v9;
    v20 = 2112;
    v21 = a3;
    _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "%s view %@", buf, 0x16u);
  }

  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v12[2] = __SOSFullPeerInfoUpdateViews_block_invoke;
  v12[3] = &unk_1E1FD2180;
  v13 = a2;
  v12[4] = &v14;
  v12[5] = a3;
  if (SOSFullPeerInfoUpdate(a1, a4, v12))
    v10 = *((unsigned int *)v15 + 6);
  else
    v10 = 0;
  _Block_object_dispose(&v14, 8);
  return v10;
}

void sub_18A9B782C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SOSFullPeerInfoUpdateToCurrent(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t v6;
  CFMutableSetRef v7;
  CFMutableSetRef v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __SecKey *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  uint64_t v18;
  CFTypeRef v19;
  CFTypeRef v20;
  NSObject *v22;
  const char *v23;
  CFTypeRef v24;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  cf = 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(uint64_t *)(v6 + 56) >= 3 && SOSPeerInfoSerialNumberIsSet(v6))
  {
    v7 = SOSFullPeerInfoCopyViewUpdate(a1, a2, a3);
    if (!v7)
    {
      v18 = 0;
      v14 = 0;
      goto LABEL_11;
    }
    CFRelease(v7);
  }
  v8 = SOSFullPeerInfoCopyViewUpdate(a1, a2, a3);
  v14 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a1, &cf);
  if (!v14)
  {
    secLogObjForScope("upgrade");
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      goto LABEL_23;
    *(_DWORD *)buf = 138412290;
    v27 = cf;
    v23 = "SOSFullPeerInfoCopyDeviceKey failed: %@";
    goto LABEL_22;
  }
  v15 = SOSPeerInfoCreateCurrentCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(_QWORD *)(a1 + 16), v9, v10, v11, v12, v13, v8, v14, &v24);
  if (v15)
  {
    v16 = v15;
    v17 = *(const void **)(a1 + 16);
    if (v17)
      CFRelease(v17);
    *(_QWORD *)(a1 + 16) = v16;
    v18 = 1;
    if (v8)
      goto LABEL_10;
    goto LABEL_11;
  }
  secLogObjForScope("upgrade");
  v22 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v27 = v24;
    v23 = "Peer info v2 create copy failed: %@";
LABEL_22:
    _os_log_impl(&dword_18A900000, v22, OS_LOG_TYPE_DEFAULT, v23, buf, 0xCu);
  }
LABEL_23:

  v18 = 0;
  if (v8)
LABEL_10:
    CFRelease(v8);
LABEL_11:
  v19 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v19);
  }
  v20 = v24;
  if (v24)
  {
    v24 = 0;
    CFRelease(v20);
  }
  if (v14)
    CFRelease(v14);
  return v18;
}

CFMutableSetRef SOSFullPeerInfoCopyViewUpdate(uint64_t a1, const void *a2, const void *a3)
{
  CFMutableSetRef v6;
  CFMutableSetRef v7;
  CFTypeID v8;
  CFTypeID v9;
  BOOL v10;
  __CFSet *v11;
  uint64_t context;
  uint64_t v16;
  void (*v17)(uint64_t, const void *);
  void *v18;
  CFMutableSetRef v19;

  v6 = SOSPeerInfoCopyEnabledViews(*(_QWORD *)(a1 + 16));
  v7 = SOSPeerInfoCopyEnabledViews(*(_QWORD *)(a1 + 16));
  if (a2)
  {
    v8 = CFGetTypeID(a2);
    if (v8 == CFSetGetTypeID())
    {
      context = MEMORY[0x1E0C809B0];
      v16 = 3221225472;
      v17 = __CFSetUnion_block_invoke;
      v18 = &__block_descriptor_40_e10_v16__0r_v8l;
      v19 = v7;
      CFSetApplyFunction((CFSetRef)a2, (CFSetApplierFunction)apply_block_1_5774, &context);
    }
  }
  if (a3)
  {
    v9 = CFGetTypeID(a3);
    if (v9 == CFSetGetTypeID())
    {
      context = MEMORY[0x1E0C809B0];
      v16 = 3221225472;
      v17 = __CFSetSubtract_block_invoke;
      v18 = &__block_descriptor_40_e10_v16__0r_v8l;
      v19 = v7;
      CFSetApplyFunction((CFSetRef)a3, (CFSetApplierFunction)apply_block_1_5774, &context);
    }
  }
  if (v6)
    v10 = v7 == 0;
  else
    v10 = 1;
  if (v10)
  {
    if (v7 == v6)
      v11 = 0;
    else
      v11 = v7;
    if (v7 != v6 || v7 == 0)
    {
      v7 = v11;
      if (!v6)
        return v7;
      goto LABEL_24;
    }
  }
  else if (!CFEqual(v7, v6))
  {
    goto LABEL_24;
  }
  CFRelease(v7);
  v7 = 0;
  if (v6)
LABEL_24:
    CFRelease(v6);
  return v7;
}

uint64_t apply_block_1_5774(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t SOSFullPeerInfoViewStatus(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  uint64_t v3;

  if (a1 && (v3 = *(_QWORD *)(a1 + 16)) != 0)
    return SOSViewsQuery(v3, a2, a3);
  else
    return 0;
}

_QWORD *SOSFullPeerInfoCopyPubKey(uint64_t a1, CFTypeRef *a2)
{
  CFDictionaryRef *v2;

  if (a1 && (v2 = *(CFDictionaryRef **)(a1 + 16)) != 0)
    return _SOSPeerInfoCopyPubKey(v2, CFSTR("PublicSigningKey"), a2);
  else
    return 0;
}

_QWORD *SOSFullPeerInfoCopyOctagonPublicSigningKey(uint64_t a1, CFTypeRef *a2)
{
  CFDictionaryRef *v2;

  if (a1 && (v2 = *(CFDictionaryRef **)(a1 + 16)) != 0)
    return _SOSPeerInfoCopyPubKey(v2, CFSTR("OctagonPublicSigningKey"), a2);
  else
    return 0;
}

_QWORD *SOSFullPeerInfoCopyOctagonPublicEncryptionKey(uint64_t a1, CFTypeRef *a2)
{
  CFDictionaryRef *v2;

  if (a1 && (v2 = *(CFDictionaryRef **)(a1 + 16)) != 0)
    return _SOSPeerInfoCopyPubKey(v2, CFSTR("OctagonPublicEncryptionKey"), a2);
  else
    return 0;
}

BOOL SOSFullPeerInfoValidate(uint64_t a1, CFTypeRef *a2)
{
  return SOSFullPeerInfoGetMatchingPrivateKeyStatus(a1, a2) == 0;
}

uint64_t SOSFullPeerInfoGetMatchingPrivateKeyStatus(uint64_t a1, CFTypeRef *a2)
{
  CFDictionaryRef *v2;
  _QWORD *v4;
  const void *v5;
  uint64_t MatchingPrivateKeyStatus;

  if (!a1)
    return 4294967246;
  v2 = *(CFDictionaryRef **)(a1 + 16);
  if (!v2)
    return 4294967246;
  v4 = _SOSPeerInfoCopyPubKey(v2, CFSTR("PublicSigningKey"), a2);
  if (!v4)
    return 4294967246;
  v5 = v4;
  MatchingPrivateKeyStatus = SecKeyGetMatchingPrivateKeyStatus(v4, (__CFString **)a2);
  CFRelease(v5);
  return MatchingPrivateKeyStatus;
}

BOOL SOSFullPeerInfoPrivKeyExists(uint64_t a1)
{
  int MatchingPrivateKeyStatus;

  MatchingPrivateKeyStatus = SOSFullPeerInfoGetMatchingPrivateKeyStatus(a1, 0);
  return MatchingPrivateKeyStatus != -25300 && MatchingPrivateKeyStatus != -50;
}

uint64_t SOSFullPeerInfoPurgePersistentKey(uint64_t a1, CFTypeRef *a2)
{
  CFDictionaryRef *v3;
  _QWORD *v5;
  CFDictionaryRef *v6;
  _QWORD *v7;
  CFDictionaryRef *v8;
  _QWORD *v9;
  const __CFDictionary *PrivateKeyMatchingQuery;
  const __CFAllocator *v11;
  __CFDictionary *MutableCopy;
  const void *v13;
  OSStatus v14;
  uint64_t v15;
  const __CFDictionary *v16;
  __CFDictionary *v17;
  OSStatus v18;
  const __CFDictionary *v19;
  __CFDictionary *v20;
  OSStatus v21;
  _QWORD *cf;

  if (!a1)
    return 0;
  v3 = *(CFDictionaryRef **)(a1 + 16);
  if (!v3)
    return 0;
  v5 = _SOSPeerInfoCopyPubKey(v3, CFSTR("PublicSigningKey"), a2);
  v6 = *(CFDictionaryRef **)(a1 + 16);
  if (v6)
  {
    v7 = _SOSPeerInfoCopyPubKey(v6, CFSTR("OctagonPublicSigningKey"), a2);
    v8 = *(CFDictionaryRef **)(a1 + 16);
    if (v8)
    {
      v9 = _SOSPeerInfoCopyPubKey(v8, CFSTR("OctagonPublicEncryptionKey"), a2);
      if (v5)
        goto LABEL_6;
      goto LABEL_30;
    }
  }
  else
  {
    v7 = 0;
  }
  v9 = 0;
  if (v5)
  {
LABEL_6:
    PrivateKeyMatchingQuery = CreatePrivateKeyMatchingQuery(v5);
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, PrivateKeyMatchingQuery);
    v13 = (const void *)*MEMORY[0x1E0C9AE40];
    CFDictionaryAddValue(MutableCopy, CFSTR("u_Tomb"), (const void *)*MEMORY[0x1E0C9AE40]);
    v14 = SecItemDelete(MutableCopy);
    v15 = SecError(v14, (__CFString **)a2, CFSTR("Deleting while purging"));
    cf = v7;
    if (v7)
    {
      v16 = CreatePrivateKeyMatchingQuery(v7);
      v17 = CFDictionaryCreateMutableCopy(v11, 0, v16);
      CFDictionaryAddValue(v17, CFSTR("u_Tomb"), v13);
      v18 = SecItemDelete(v17);
      v15 = v15 & SecError(v18, (__CFString **)a2, CFSTR("Deleting signing key while purging"));
      if (v16)
        CFRelease(v16);
      if (v17)
        CFRelease(v17);
    }
    if (v9)
    {
      v19 = CreatePrivateKeyMatchingQuery(v9);
      v20 = CFDictionaryCreateMutableCopy(v11, 0, v19);
      CFDictionaryAddValue(v20, CFSTR("u_Tomb"), v13);
      v21 = SecItemDelete(v20);
      v15 = v15 & SecError(v21, (__CFString **)a2, CFSTR("Deleting encryption key while purging"));
      if (!PrivateKeyMatchingQuery)
        goto LABEL_14;
    }
    else
    {
      v20 = 0;
      v19 = 0;
      if (!PrivateKeyMatchingQuery)
      {
LABEL_14:
        if (MutableCopy)
          CFRelease(MutableCopy);
        CFRelease(v5);
        if (v19)
          CFRelease(v19);
        if (v20)
          CFRelease(v20);
        v7 = cf;
        if (!cf)
          goto LABEL_22;
        goto LABEL_21;
      }
    }
    CFRelease(PrivateKeyMatchingQuery);
    goto LABEL_14;
  }
LABEL_30:
  v15 = 0;
  if (v7)
LABEL_21:
    CFRelease(v7);
LABEL_22:
  if (v9)
    CFRelease(v9);
  return v15;
}

CFTypeRef SOSFullPeerInfoCopyOctagonSigningKey(uint64_t a1, CFTypeRef *a2)
{
  CFDictionaryRef *v2;
  _QWORD *v4;
  const void *v5;
  CFTypeRef v6;

  if (!a1)
    return 0;
  v2 = *(CFDictionaryRef **)(a1 + 16);
  if (!v2)
    return 0;
  v4 = _SOSPeerInfoCopyPubKey(v2, CFSTR("OctagonPublicSigningKey"), a2);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = SecKeyCopyMatchingPrivateKey(v4, (__CFString **)a2);
  CFRelease(v5);
  return v6;
}

CFTypeRef SOSFullPeerInfoCopyOctagonEncryptionKey(uint64_t a1, CFTypeRef *a2)
{
  CFDictionaryRef *v2;
  _QWORD *v4;
  const void *v5;
  CFTypeRef v6;

  if (!a1)
    return 0;
  v2 = *(CFDictionaryRef **)(a1 + 16);
  if (!v2)
    return 0;
  v4 = _SOSPeerInfoCopyPubKey(v2, CFSTR("OctagonPublicEncryptionKey"), a2);
  if (!v4)
    return 0;
  v5 = v4;
  v6 = SecKeyCopyMatchingPrivateKey(v4, (__CFString **)a2);
  CFRelease(v5);
  return v6;
}

uint64_t SOSFullPeerInfoGetDEREncodedSize(uint64_t a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (SOSPeerInfoGetDEREncodedSize(*(_QWORD *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8)
    && (CFDataGetLength(*(CFDataRef *)(a1 + 24)), ccder_sizeof_raw_octet_string()))
  {
    return ccder_sizeof();
  }
  else
  {
    return 0;
  }
}

uint64_t SOSFullPeerInfoEncodeToDER(uint64_t a1, CFTypeRef *a2, UInt8 *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v5 = *(_QWORD *)(a1 + 16);
  v6 = der_encode_data(*(const __CFData **)(a1 + 24), a2);
  SOSPeerInfoEncodeToDER(v5, a2, a3, v6, v7, v8, v9, v10);
  return ccder_encode_constructed_tl();
}

__CFData *SOSFullPeerInfoCopyEncodedData(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFAllocator *v10;
  CFIndex DEREncodedSize;
  _QWORD v13[6];

  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  DEREncodedSize = SOSFullPeerInfoGetDEREncodedSize(a1, a3, (uint64_t)a3, a4, a5, a6, a7, a8);
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __SOSFullPeerInfoCopyEncodedData_block_invoke;
  v13[3] = &__block_descriptor_48_e11__24__0Q8_16l;
  v13[4] = a1;
  v13[5] = a3;
  return CFDataCreateWithDER(v10, DEREncodedSize, v13);
}

BOOL SOSFullPeerInfoPromoteToApplication(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  __SecKey *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __SecKey *v11;
  const void *v12;
  uint64_t v13;
  _BOOL8 v14;

  v6 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a1, a3);
  if (!v6)
    return 0;
  v11 = v6;
  v12 = *(const void **)(a1 + 16);
  v13 = SOSPeerInfoCopyAsApplication((uint64_t)v12, a2, v6, a3, v7, v8, v9, v10);
  *(_QWORD *)(a1 + 16) = v13;
  v14 = v13 != 0;
  if (v13)
  {
    if (v12)
      CFRelease(v12);
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v12;
  }
  CFRelease(v11);
  return v14;
}

BOOL SOSFullPeerInfoUpgradeSignatures(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  __SecKey *v6;
  __SecKey *v7;
  const void *v8;
  uint64_t v9;
  _BOOL8 v10;

  v6 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a1, a3);
  if (!v6)
    return 0;
  v7 = v6;
  v8 = *(const void **)(a1 + 16);
  v9 = SOSPeerInfoUpgradeSignatures((int)v6, a2, v6, (uint64_t)v8, a3);
  *(_QWORD *)(a1 + 16) = v9;
  v10 = v9 != 0;
  if (v9)
  {
    if (v8)
      CFRelease(v8);
  }
  else
  {
    *(_QWORD *)(a1 + 16) = v8;
  }
  CFRelease(v7);
  return v10;
}

CFMutableDictionaryRef *SOSFullPeerInfoPromoteToRetiredAndCopy(uint64_t a1, CFTypeRef *a2)
{
  __SecKey *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __SecKey *v9;
  CFMutableDictionaryRef *RetirementTicket;
  CFMutableDictionaryRef *v11;
  __SecKey *v12;

  v4 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a1, a2);
  if (!v4)
    return 0;
  v9 = v4;
  RetirementTicket = SOSPeerInfoCreateRetirementTicket(0, v4, *(_QWORD *)(a1 + 16), a2, v5, v6, v7, v8);
  v11 = RetirementTicket;
  if (!RetirementTicket
    || (v12 = *(__SecKey **)(a1 + 16),
        *(_QWORD *)(a1 + 16) = RetirementTicket,
        CFRetain(RetirementTicket),
        CFRelease(v9),
        (v9 = v12) != 0))
  {
    CFRelease(v9);
  }
  return v11;
}

BOOL SOSFullPeerInfoPing(uint64_t a1, CFTypeRef *a2)
{
  __SecKey *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __SecKey *v9;
  uint64_t v10;
  _BOOL8 v11;
  uint64_t v12;
  const void *v13;

  v4 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a1, a2);
  if (!v4)
    return 0;
  v9 = v4;
  v10 = SOSPeerInfoCopyWithPing((const __CFAllocator *)*MEMORY[0x1E0C9AE00], *(_QWORD *)(a1 + 16), v4, a2, v5, v6, v7, v8);
  v11 = v10 != 0;
  if (v10)
  {
    v12 = v10;
    v13 = *(const void **)(a1 + 16);
    if (v13)
    {
      *(_QWORD *)(a1 + 16) = 0;
      CFRelease(v13);
    }
    *(_QWORD *)(a1 + 16) = v12;
  }
  CFRelease(v9);
  return v11;
}

void SOSGenerationCountWithDescription(const __CFNumber *a1, uint64_t a2)
{
  __CFString *v3;

  v3 = SOSGenerationCountCopyDescription(a1);
  (*(void (**)(uint64_t, __CFString *))(a2 + 16))(a2, v3);
  if (v3)
    CFRelease(v3);
}

__CFString *SOSGenerationCountCopyDescription(const __CFNumber *a1)
{
  __CFString *MutableCopy;
  __CFString *v3;
  uint64_t v4;
  double v5;
  uint64_t v6;
  const void *v7;
  _QWORD v9[5];
  _QWORD valuePtr[6];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t block;
  uint64_t v16;
  void *v17;
  void *v18;
  uint64_t *v19;

  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("["));
  v3 = MutableCopy;
  if (a1)
  {
    valuePtr[0] = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(a1, kCFNumberSInt64Type, valuePtr);
    v4 = valuePtr[0];
    v5 = (double)((valuePtr[0] >> 31) & 0xFFFFFFFE);
    v6 = MEMORY[0x1E0C809B0];
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = __SOSGenerationCountCopyDescription_block_invoke;
    v9[3] = &__block_descriptor_tmp_5789;
    v9[4] = v3;
    valuePtr[0] = MEMORY[0x1E0C809B0];
    v11 = 0;
    v12 = &v11;
    v13 = 0x2000000000;
    v14 = 0;
    valuePtr[1] = 0x40000000;
    valuePtr[2] = __withStringOfAbsoluteTime_block_invoke;
    valuePtr[3] = &unk_1E1FDC028;
    valuePtr[4] = &v11;
    *(double *)&valuePtr[5] = v5;
    block = MEMORY[0x1E0C809B0];
    v16 = 0x40000000;
    v17 = __GetShortDateFormatterQueue_block_invoke;
    v18 = &__block_descriptor_tmp_41_12834;
    v19 = &GetShortDateFormatterQueue_sGetShortDateFormatterQueueSingleton;
    if (GetShortDateFormatterQueue_sGetShortDateFormatterQueueOnce != -1)
      dispatch_once(&GetShortDateFormatterQueue_sGetShortDateFormatterQueueOnce, &block);
    block = v6;
    v16 = 0x40000000;
    v17 = __withShortDateFormatter_block_invoke;
    v18 = &unk_1E1FDC0F8;
    v19 = valuePtr;
    dispatch_sync((dispatch_queue_t)GetShortDateFormatterQueue_sGetShortDateFormatterQueueSingleton, &block);
    __SOSGenerationCountCopyDescription_block_invoke((uint64_t)v9, (const __CFString *)v12[3]);
    v7 = (const void *)v12[3];
    if (v7)
    {
      v12[3] = 0;
      CFRelease(v7);
    }
    _Block_object_dispose(&v11, 8);
    CFStringAppendFormat(v3, 0, CFSTR(" %u]"), v4);
  }
  else
  {
    CFStringAppend(MutableCopy, CFSTR("NA]"));
  }
  return v3;
}

const __CFNumber *SOSGetGenerationSint(const __CFNumber *result)
{
  unint64_t valuePtr;

  if (result)
  {
    valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr);
    return (const __CFNumber *)valuePtr;
  }
  return result;
}

CFNumberRef SOSGenerationCreate()
{
  return sosGenerationCreateOrIncrement(0);
}

CFNumberRef sosGenerationCreateOrIncrement(const __CFNumber *a1)
{
  unint64_t v1;
  unint64_t valuePtr;

  if (a1)
  {
    valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(a1, kCFNumberSInt64Type, &valuePtr);
    v1 = valuePtr;
    if (HIDWORD(valuePtr))
      goto LABEL_6;
  }
  else
  {
    v1 = 0;
  }
  v1 |= (unint64_t)(CFAbsoluteTimeGetCurrent() >> 1) << 32;
LABEL_6:
  valuePtr = v1 + 1;
  return CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
}

CFNumberRef SOSGenerationCreateWithValue(uint64_t a1)
{
  uint64_t valuePtr;

  valuePtr = a1;
  return CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
}

const __CFNumber *SOSGenerationCopy(const __CFNumber *result)
{
  unint64_t valuePtr;

  if (result)
  {
    valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(result, kCFNumberSInt64Type, &valuePtr);
    return CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  }
  return result;
}

BOOL SOSGenerationIsOlder(const __CFNumber *a1, const __CFNumber *a2)
{
  unint64_t v2;

  v2 = CFNumberCompare(a1, a2, 0) + 1;
  return (v2 & 7) == 0 && v2 < 3;
}

CFNumberRef SOSGenerationCreateWithBaseline(const __CFNumber *a1)
{
  const __CFNumber *v2;

  v2 = sosGenerationCreateOrIncrement(0);
  if ((unint64_t)(CFNumberCompare(v2, a1, 0) + 1) > 1)
    return v2;
  if (v2)
    CFRelease(v2);
  return sosGenerationCreateOrIncrement(a1);
}

CFNumberRef SOSGenCountCreateFromDER(const __CFAllocator *a1, CFTypeRef *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFNumberRef result;
  CFNumberRef v9;

  v9 = 0;
  *a3 = der_decode_number(a1, &v9, a2, *a3, a4, a6, a7, a8);
  result = v9;
  if (!v9)
    return sosGenerationCreateOrIncrement(0);
  return result;
}

BOOL SOSErrorCreate(CFIndex a1, CFTypeRef *a2, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  va_list va;

  va_start(va, format);
  if (a1 && a2 && !*a2)
    SecCFCreateErrorWithFormatAndArguments(a1, CFSTR("com.apple.security.sos.error"), 0, a2, formatOptions, format, va);
  return a1 == 0;
}

uint64_t SOSCreateError(CFIndex a1, uint64_t a2, __CFString *cf, CFTypeRef *a4)
{
  SOSCreateErrorWithFormat(a1, cf, a4, 0, CFSTR("%@"), a2);
  return 0;
}

uint64_t SOSCreateErrorWithFormat(CFIndex a1, __CFString *cf, CFTypeRef *a3, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  va_list va;

  va_start(va, format);
  SecCFCreateErrorWithFormatAndArguments(a1, CFSTR("com.apple.security.sos.error"), cf, a3, formatOptions, format, va);
  return 0;
}

uint64_t SOSCreateErrorWithFormatAndArguments(CFIndex a1, __CFString *cf, CFTypeRef *a3, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  SecCFCreateErrorWithFormatAndArguments(a1, CFSTR("com.apple.security.sos.error"), cf, a3, formatOptions, format, arguments);
  return 0;
}

uint64_t GenerateECPair(int a1, SecKeyRef *a2, SecKeyRef *a3)
{
  return GenerateECPairImp(a1, *MEMORY[0x1E0C9AE40], a2, a3);
}

uint64_t GenerateECPairImp(int a1, uint64_t a2, SecKeyRef *a3, SecKeyRef *a4)
{
  const __CFAllocator *v6;
  CFNumberRef v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  const __CFDictionary *v15;
  uint64_t Pair;
  int valuePtr;

  valuePtr = a1;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  v15 = CFDictionaryCreateForCFTypes(v6, v8, v9, v10, v11, v12, v13, v14, (uint64_t)CFSTR("type"), (uint64_t)CFSTR("73"));
  if (v7)
    CFRelease(v7);
  Pair = SecKeyGeneratePair(v15, a3, a4);
  if (v15)
    CFRelease(v15);
  return Pair;
}

uint64_t GeneratePermanentECPair(int a1, SecKeyRef *a2, SecKeyRef *a3)
{
  return GenerateECPairImp(a1, *MEMORY[0x1E0C9AE50], a2, a3);
}

__CFString *SOSItemsChangedCopyDescription(const __CFDictionary *a1, char a2)
{
  __CFString *MutableCopy;
  _QWORD v6[5];
  char v7;

  MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<Changes: {\n"));
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __SOSItemsChangedCopyDescription_block_invoke;
  v6[3] = &__block_descriptor_41_e15_v24__0r_v8r_v16l;
  v6[4] = MutableCopy;
  v7 = a2;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)apply_block_2_5852, v6);
  CFStringAppendFormat(MutableCopy, 0, CFSTR("}"));
  return MutableCopy;
}

uint64_t apply_block_2_5852(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

CFStringRef SOSCopyHashBufAsString(unsigned __int8 *a1, unint64_t a2)
{
  size_t v4;
  uint64_t v5;
  char *v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = (2 * a2) | 1;
  MEMORY[0x1E0C80A78](a1);
  v6 = (char *)&v12 - ((v5 + 16) & 0xFFFFFFFFFFFFFFF0);
  memset(v6, 170, v4);
  v7 = SecBase64Encode_(a1, a2, v6, v4, 0, (_DWORD *)&v12 + 1);
  v8 = v7;
  if (v7)
    v9 = v7 >= v4;
  else
    v9 = 1;
  if (v9)
    __security_simulatecrash(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
  v10 = 26;
  if (v8 < 0x1A)
    v10 = v8;
  v6[v10] = 0;
  return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, 0x600u);
}

CFStringRef SOSCopyIDOfDataBuffer(const __CFData *a1)
{
  size_t *v2;
  size_t v3;
  _QWORD v5[2];

  v5[1] = *MEMORY[0x1E0C80C00];
  v2 = (size_t *)ccsha1_di();
  v3 = *v2;
  MEMORY[0x1E0C80A78](v2);
  if (v3)
    memset((char *)v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), 170, v3);
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccdigest();
  return SOSCopyHashBufAsString((unsigned __int8 *)v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0), v3);
}

const __CFString *SOSCopyIDOfDataBufferWithLength(const __CFData *a1, CFIndex a2)
{
  const __CFString *result;
  const __CFString *v4;
  CFStringRef v5;
  CFRange v6;

  result = SOSCopyIDOfDataBuffer(a1);
  if (result)
  {
    v4 = result;
    v6.location = 0;
    v6.length = a2;
    v5 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], result, v6);
    CFRelease(v4);
    return v5;
  }
  return result;
}

CFStringRef SOSCopyIDOfKey(uint64_t a1, CFTypeRef *a2)
{
  int v4;
  _BOOL4 v5;
  CFTypeRef v6;
  CFStringRef v7;
  CFTypeRef cf;

  cf = 0;
  if (!a1)
  {
    SOSErrorCreate(1033, a2, 0, CFSTR("NULL key passed to SOSCopyIDOfKey"));
    return 0;
  }
  v4 = SecKeyCopyPublicBytes(a1, (uint64_t)&cf);
  v5 = SecError(v4, (__CFString **)a2, CFSTR("Failed to export public bytes %@"), a1);
  v6 = cf;
  if (!v5)
  {
    v7 = 0;
    if (!cf)
      return v7;
    goto LABEL_4;
  }
  v7 = SOSCopyIDOfDataBuffer((const __CFData *)cf);
  v6 = cf;
  if (cf)
  {
LABEL_4:
    cf = 0;
    CFRelease(v6);
  }
  return v7;
}

const __CFString *SOSCopyIDOfKeyWithLength(uint64_t a1, CFIndex a2, CFTypeRef *a3)
{
  const __CFString *result;
  const __CFString *v5;
  CFStringRef v6;
  CFRange v7;

  result = SOSCopyIDOfKey(a1, a3);
  if (result)
  {
    v5 = result;
    v7.location = 0;
    v7.length = a2;
    v6 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], result, v7);
    CFRelease(v5);
    return v6;
  }
  return result;
}

uint64_t SOSGetBackupKeyCurveParameters()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __SOSGetBackupKeyCurveParameters_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSGetBackupKeyCurveParameters_sSOSGetBackupKeyCurveParametersSingleton;
  if (SOSGetBackupKeyCurveParameters_sSOSGetBackupKeyCurveParametersOnce != -1)
    dispatch_once(&SOSGetBackupKeyCurveParameters_sSOSGetBackupKeyCurveParametersOnce, block);
  return SOSGetBackupKeyCurveParameters_sSOSGetBackupKeyCurveParametersSingleton;
}

uint64_t SOSPerformWithDeviceBackupFullKey(uint64_t a1, const __CFData *a2, CFTypeRef *a3, void *a4)
{
  void (**v7)(id, char *);
  uint64_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  v7 = a4;
  MEMORY[0x1E0C80A78](v7);
  v9 = (char *)v14 - v8;
  v10 = 0;
  do
  {
    v11 = &v9[v10];
    *(_QWORD *)v11 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v10 += 16;
  }
  while (v8 != v10);
  v12 = SOSGenerateDeviceBackupFullKey((uint64_t)v14 - v8, a1, a2, a3);
  if ((_DWORD)v12)
    v7[2](v7, v9);
  cc_clear();

  return v12;
}

uint64_t SOSGenerateDeviceBackupFullKey(uint64_t a1, uint64_t a2, const __CFData *a3, CFTypeRef *a4)
{
  uint64_t v6;
  uint64_t key_deterministic;
  _BYTE __b[1024];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  memset(__b, 170, sizeof(__b));
  ccsha256_di();
  CFDataGetLength(a3);
  CFDataGetBytePtr(a3);
  v6 = ccpbkdf2_hmac();
  if ((_DWORD)v6)
  {
    SOSErrorCreate(1028, a4, 0, CFSTR("ccpbkdf2_hmac failed: %d"), v6);
    return 0;
  }
  ccrng();
  key_deterministic = ccec_generate_key_deterministic();
  if ((_DWORD)key_deterministic)
  {
    SOSErrorCreate(1028, a4, 0, CFSTR("ccec_generate_key_deterministic failed: %d"), key_deterministic);
    return 0;
  }
  return 1;
}

__CFData *SOSCopyDeviceBackupPublicKey(const __CFData *a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  CFIndex v10;
  __CFData *Mutable;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v4 = SOSGetBackupKeyCurveParameters();
  MEMORY[0x1E0C80A78](v4);
  v6 = (char *)v13 - v5;
  v7 = 0;
  do
  {
    v8 = &v6[v7];
    *(_QWORD *)v8 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v7 += 16;
  }
  while (v5 != v7);
  v9 = SOSGetBackupKeyCurveParameters();
  if (!SOSGenerateDeviceBackupFullKey((uint64_t)v6, v9, a1, a2))
    return 0;
  v10 = (unint64_t)(cczp_bitlen() + 7) >> 3;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFDataSetLength(Mutable, v10);
  if (!SecAllocationError((uint64_t)Mutable, a2, CFSTR("Mutable data allocation")))
  {
    if (!Mutable)
      return Mutable;
    CFRelease(Mutable);
    return 0;
  }
  CFDataGetMutableBytePtr(Mutable);
  ccec_compact_export();
  return Mutable;
}

CFDataRef SOSDateCreate()
{
  CFAbsoluteTime Current;
  CFDateRef v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const UInt8 *v10;
  char v12[8];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  v1 = CFDateCreate(0, Current);
  v2 = der_sizeof_date();
  v3 = MEMORY[0x1E0C80A78](v2);
  v10 = (const UInt8 *)&v12[-v9];
  if (v3)
    memset(&v12[-v9], 170, v2);
  der_encode_date((uint64_t)v1, (uint64_t)v10, (unint64_t)&v10[v2], v4, v5, v6, v7, v8, v12[0]);
  if (v1)
    CFRelease(v1);
  return CFDataCreate(0, v10, v2);
}

__CFData *CFDataCreateWithDER(const __CFAllocator *a1, CFIndex a2, void *a3)
{
  uint64_t (**v5)(id, CFIndex, UInt8 *);
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  unint64_t v8;
  CFRange v10;

  v5 = a3;
  if (!a2)
    goto LABEL_9;
  Mutable = CFDataCreateMutable(a1, 0);
  CFDataSetLength(Mutable, a2);
  if (!Mutable)
    goto LABEL_10;
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  v8 = v5[2](v5, a2, MutableBytePtr);
  if ((UInt8 *)v8 == MutableBytePtr)
    goto LABEL_10;
  if (!v8 || v8 < (unint64_t)MutableBytePtr)
  {
    CFRelease(Mutable);
LABEL_9:
    Mutable = 0;
    goto LABEL_10;
  }
  if (v8 > (unint64_t)MutableBytePtr)
  {
    v10.location = 0;
    v10.length = v8 - (_QWORD)MutableBytePtr;
    CFDataDeleteBytes(Mutable, v10);
  }
LABEL_10:

  return Mutable;
}

uint64_t SOSCachedNotificationOperation(uint64_t a1, void *a2)
{
  uint64_t (**v3)(_QWORD);
  void *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  id v12;
  uint32_t v13;
  uint32_t v14;
  NSObject *v15;
  int out_token;
  uint8_t buf[4];
  id v19;
  __int16 v20;
  uint32_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  out_token = -1;
  v4 = (void *)MEMORY[0x18D770A24]();
  os_unfair_lock_lock((os_unfair_lock_t)&SOSCachedNotificationOperation_token_lock);
  if (!SOSCachedNotificationOperation_tokenCache)
  {
    objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v5 = objc_claimAutoreleasedReturnValue();
    v6 = (void *)SOSCachedNotificationOperation_tokenCache;
    SOSCachedNotificationOperation_tokenCache = v5;

  }
  +[SOSCachedNotification notificationName:](SOSCachedNotification, "notificationName:", a1);
  v7 = objc_claimAutoreleasedReturnValue();
  if (v7)
  {
    v8 = (void *)v7;
    objc_msgSend((id)SOSCachedNotificationOperation_tokenCache, "objectForKeyedSubscript:", v7);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = v9;
    if (v9)
    {
      out_token = objc_msgSend(v9, "intValue");
    }
    else
    {
      v12 = objc_retainAutorelease(v8);
      v13 = notify_register_check((const char *)objc_msgSend(v12, "UTF8String"), &out_token);
      if (v13)
      {
        v14 = v13;
        secLogObjForScope("cachedStatus");
        v15 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          v19 = v12;
          v20 = 1024;
          v21 = v14;
          _os_log_impl(&dword_18A900000, v15, OS_LOG_TYPE_DEFAULT, "Failed to retreive token for %@: error %d", buf, 0x12u);
        }
      }
      else
      {
        objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", out_token);
        v15 = objc_claimAutoreleasedReturnValue();
        objc_msgSend((id)SOSCachedNotificationOperation_tokenCache, "setObject:forKeyedSubscript:", v15, v12);
      }

    }
    os_unfair_lock_unlock((os_unfair_lock_t)&SOSCachedNotificationOperation_token_lock);

    objc_autoreleasePoolPop(v4);
    v11 = v3[2](v3);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&SOSCachedNotificationOperation_token_lock);
    objc_autoreleasePoolPop(v4);
    v11 = 0;
  }

  return v11;
}

uint64_t SOSGetCachedCircleBitmask()
{
  uint64_t v0;
  _QWORD v2[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = 0;
  v2[0] = MEMORY[0x1E0C809B0];
  v2[1] = 3221225472;
  v2[2] = __SOSGetCachedCircleBitmask_block_invoke;
  v2[3] = &unk_1E1FD2218;
  v2[4] = &v3;
  SOSCachedNotificationOperation(kSOSCCCircleChangedNotification, v2);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_18A9B975C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SOSGetCachedCircleStatus(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  CFTypeRef v4;
  const __CFString *v5;

  v2 = SOSGetCachedCircleBitmask();
  if ((v2 & 0x8000000000000000) == 0)
    return 4294967197;
  v3 = v2;
  if ((v2 & 0x4000000000000000) == 0)
  {
    if (a1)
    {
      v4 = *a1;
      if (*a1)
      {
        *a1 = 0;
        CFRelease(v4);
      }
      if ((v3 & 0x1000000000000000) != 0)
        v5 = CFSTR("Public Key isn't available, this peer is in the circle, but invalid. The iCloud Password must be provided to keychain syncing subsystem to repair this.");
      else
        v5 = CFSTR("Public Key isn't available. The iCloud Password must be provided to keychain syncing subsystem to repair this.");
      SOSCreateErrorWithFormat(2, 0, a1, 0, CFSTR("%@"), v5);
    }
    return 0xFFFFFFFFLL;
  }
  return v3;
}

uint64_t SOSCachedViewBitmask()
{
  unint64_t v0;
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v0 = SOSGetCachedCircleBitmask();
  if (v0 >> 62 == 3 && v0 == 0)
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 3221225472;
    v4[2] = __SOSCachedViewBitmask_block_invoke;
    v4[3] = &unk_1E1FD2218;
    v4[4] = &v5;
    SOSCachedNotificationOperation(kSOSCCViewMembershipChangedNotification, v4);
  }
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18A9B98E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFMutableSetRef SOSCreateCachedViewStatus()
{
  CFMutableSetRef result;

  result = (CFMutableSetRef)SOSCachedViewBitmask();
  if (result)
    return SOSViewCreateSetFromBitmask((uint64_t)result);
  return result;
}

id SOSCreateRandomDateBetweenNowPlus(double a1, double a2)
{
  unint64_t v3;
  unint64_t v4;

  v3 = (unint64_t)(a2 - a1);
  if (CCRandomCopyBytes())
    v4 = v3 >> 1;
  else
    v4 = 0xAAAAAAAAAAAAAAAALL % v3;
  return (id)objc_msgSend(objc_alloc(MEMORY[0x1E0C99D68]), "initWithTimeIntervalSinceNow:", (double)v4 + a1);
}

id SOSCCCredentialQueue()
{
  if (SOSCCCredentialQueue_onceToken != -1)
    dispatch_once(&SOSCCCredentialQueue_onceToken, &__block_literal_global_5894);
  return (id)SOSCCCredentialQueue_credQueue;
}

uint64_t SOSDoWithCredentialsWhileUnlocked(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  id v5;
  uint64_t v6;
  _QWORD block[4];
  id v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v3 = a2;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  SOSCCCredentialQueue();
  v4 = objc_claimAutoreleasedReturnValue();
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __SOSDoWithCredentialsWhileUnlocked_block_invoke;
  block[3] = &unk_1E1FD2260;
  v10 = &v12;
  v11 = a1;
  v9 = v3;
  v5 = v3;
  dispatch_sync(v4, block);

  v6 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  return v6;
}

void sub_18A9B9CE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SOSVisibleKeychainNotAllowed()
{
  void *v0;
  id v1;
  void *v2;
  int v3;
  NSObject *v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2050000000;
  v0 = (void *)getMCProfileConnectionClass_softClass;
  v10 = getMCProfileConnectionClass_softClass;
  if (!getMCProfileConnectionClass_softClass)
  {
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 3221225472;
    v6[2] = __getMCProfileConnectionClass_block_invoke;
    v6[3] = &unk_1E1FD8CF0;
    v6[4] = &v7;
    __getMCProfileConnectionClass_block_invoke((uint64_t)v6);
    v0 = (void *)v8[3];
  }
  v1 = objc_retainAutorelease(v0);
  _Block_object_dispose(&v7, 8);
  objc_msgSend(v1, "sharedConnection");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "isCloudKeychainSyncAllowed");
  if ((v3 & 1) == 0)
  {
    secLogObjForScope("views");
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6[0]) = 0;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "V0 views disabled by Managed Preferences Profile", (uint8_t *)v6, 2u);
    }

  }
  return v3 ^ 1u;
}

void sub_18A9B9E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getMCProfileConnectionClass_block_invoke(uint64_t a1)
{
  Class result;
  void *v3;
  void *v4;
  void *v5;

  if (!ManagedConfigurationLibraryCore_frameworkLibrary)
    ManagedConfigurationLibraryCore_frameworkLibrary = _sl_dlopen();
  if (!ManagedConfigurationLibraryCore_frameworkLibrary)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *ManagedConfigurationLibrary(void)");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v4, CFSTR("SOSInternal.m"), 486, CFSTR("%s"), 0);

    goto LABEL_8;
  }
  result = objc_getClass("MCProfileConnection");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getMCProfileConnectionClass(void)_block_invoke");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", v5, CFSTR("SOSInternal.m"), 487, CFSTR("Unable to find class %s"), "MCProfileConnection");

LABEL_8:
    __break(1u);
  }
  getMCProfileConnectionClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

void _SOSControlSetupInterface(void *a1)
{
  void *v1;
  id v2;

  v2 = a1;
  +[SecXPCHelper safeErrorClasses](SecXPCHelper, "safeErrorClasses");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_userPublicKey_, 2, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_stashedCredentialPublicKey_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_assertStashedAccountCredential_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_validatedStashedAccountCredential_flowID_deviceSessionID_canSendMetrics_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_stashAccountCredential_altDSID_flowID_deviceSessionID_canSendMetrics_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_ghostBust_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_ghostBustPeriodic_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_ghostBustTriggerTimed_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_ghostBustInfo_, 0, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_iCloudIdentityStatus_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_accountStatus_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_keyStatusFor_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_myPeerInfo_flowID_deviceSessionID_canSendMetrics_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_circleHash_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_circleJoiningBlob_flowID_deviceSessionID_canSendMetrics_applicant_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_joinCircleWithBlob_altDSID_flowID_deviceSessionID_canSendMetrics_version_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_initialSyncCredentials_altDSID_flowID_deviceSessionID_canSendMetrics_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_importInitialSyncCredentials_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_rpcTriggerSync_complete_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_getWatchdogParameters_, 1, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_setWatchdogParmeters_complete_, 0, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_rpcTriggerBackup_complete_, 0, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_rpcTriggerRingUpdate_, 0, 1);
  objc_msgSend(v2, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_removeV0Peers_, 1, 1);

}

CFStringRef SOSCircleKeyCreateWithName(CFStringRef result)
{
  if (result)
    return CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), CFSTR("o"), result);
  return result;
}

uint64_t SOSKVSKeyGetKeyType(const __CFString *a1)
{
  if (CFStringHasPrefix(a1, CFSTR("o")))
    return 0;
  if (CFStringHasPrefix(a1, CFSTR("~")))
    return 7;
  if (CFStringHasPrefix(a1, CFSTR("-")))
    return 4;
  if (CFStringHasPrefix(a1, CFSTR(">KeyParameters")))
    return 2;
  if (CFStringHasPrefix(a1, CFSTR("^InitialSync")))
    return 3;
  if (CFStringHasPrefix(a1, CFSTR("^OfficialDSID")))
    return 5;
  if (CFStringHasPrefix(a1, CFSTR("dbg-")))
    return 6;
  if (CFStringHasPrefix(a1, CFSTR("k")))
    return 9;
  return 1;
}

BOOL SOSKVSKeyParse(int a1, CFStringRef theString, CFStringRef *a3, CFStringRef *a4, CFStringRef *a5, uint64_t a6, CFStringRef *a7, CFStringRef *a8)
{
  _BOOL8 v8;
  CFMutableStringRef MutableCopy;
  CFStringRef v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFString *v17;
  CFIndex Length;
  const __CFString *Copy;
  CFStringRef v20;
  const __CFString *v21;
  CFStringRef v22;
  CFIndex v24;
  CFIndex v25;
  CFStringRef v27;
  const __CFString *v28;
  CFStringRef v29;
  const __CFString *v30;
  const __CFString *v31;
  CFMutableStringRef v32;
  CFStringRef v33;
  CFStringRef v34;
  const __CFString *v35;
  const __CFString *v36;
  CFMutableStringRef v37;
  CFRange v39;
  CFRange v40;
  CFRange v41;
  CFRange v42;

  v8 = 1;
  switch(a1)
  {
    case 0:
      if (!a3)
        return 1;
      v40.length = CFStringGetLength(theString) - 1;
      v8 = 1;
      v40.location = 1;
      *a3 = CFStringCreateWithSubstring(0, theString, v40);
      return v8;
    case 1:
      MutableCopy = CFStringCreateMutableCopy(0, 128, theString);
      v14 = copyStringEndingIn(MutableCopy, CFSTR("|"));
      if (!v14)
        goto LABEL_38;
      v15 = v14;
      v16 = copyStringEndingIn(MutableCopy, CFSTR(":"));
      if (!v16)
      {
        v8 = 0;
        goto LABEL_45;
      }
      v17 = v16;
      Length = CFStringGetLength(v16);
      v8 = Length > 0;
      if (Length < 1)
      {
        Copy = 0;
      }
      else
      {
        Copy = CFStringCreateCopy(0, MutableCopy);
        if (a3)
          *a3 = CFStringCreateCopy(0, v15);
        if (a7)
          *a7 = CFStringCreateCopy(0, v17);
        if (a8 && Copy)
          *a8 = CFStringCreateCopy(0, Copy);
      }
      CFRelease(v15);
      CFRelease(v17);
      v15 = Copy;
      if (!Copy)
        goto LABEL_47;
      goto LABEL_45;
    case 4:
      MutableCopy = CFStringCreateMutableCopy(0, 128, theString);
      v39.location = 0;
      v39.length = 1;
      CFStringDelete(MutableCopy, v39);
      v20 = copyStringEndingIn(MutableCopy, CFSTR("|"));
      if (!v20)
        goto LABEL_38;
      v21 = v20;
      v22 = CFStringCreateCopy(0, MutableCopy);
      v8 = v22 != 0;
      if (v22)
      {
        v15 = v22;
        if (a3)
          *a3 = CFStringCreateCopy(0, v21);
        if (a7)
          *a7 = CFStringCreateCopy(0, v15);
        CFRelease(v21);
      }
      else
      {
        v15 = v21;
      }
LABEL_45:
      v31 = v15;
      goto LABEL_46;
    case 6:
      if (a4)
      {
        v24 = CFStringGetLength(CFSTR("dbg-"));
        v25 = CFStringGetLength(theString);
        v41.length = v25 - CFStringGetLength(CFSTR("dbg-"));
        v41.location = v24;
        *a4 = CFStringCreateWithSubstring(0, theString, v41);
      }
      return 1;
    case 7:
      if (!a5)
        return 1;
      v42.length = CFStringGetLength(theString) - 1;
      v8 = 1;
      v42.location = 1;
      *a5 = CFStringCreateWithSubstring(0, theString, v42);
      return v8;
    case 8:
      v8 = 1;
      if (!a3 || !a7)
        return v8;
      MutableCopy = CFStringCreateMutableCopy(0, 128, theString);
      v27 = copyStringEndingIn(MutableCopy, CFSTR("|"));
      if (v27)
      {
        v28 = v27;
        v29 = CFStringCreateCopy(0, MutableCopy);
        v8 = v29 != 0;
        if (v29)
        {
          v30 = v29;
          *a3 = CFStringCreateCopy(0, v28);
          *a7 = CFStringCreateCopy(0, v30);
          CFRelease(v28);
          v28 = v30;
        }
        v31 = v28;
LABEL_46:
        CFRelease(v31);
      }
      else
      {
LABEL_38:
        v8 = 0;
      }
LABEL_47:
      if (!MutableCopy)
        return v8;
      v37 = MutableCopy;
      goto LABEL_49;
    case 9:
      if (!a7)
        return 1;
      v32 = CFStringCreateMutableCopy(0, 128, theString);
      v33 = copyStringEndingIn(v32, CFSTR("|"));
      if (v33)
      {
        v34 = v33;
        v35 = CFStringCreateCopy(0, v32);
        v8 = v35 != 0;
        if (v35)
        {
          v36 = v35;
          *a7 = CFStringCreateCopy(0, v35);
          CFRelease(v34);
          v34 = v36;
        }
        CFRelease(v34);
        if (!v32)
          return v8;
      }
      else
      {
        v8 = 0;
        if (!v32)
          return v8;
      }
      v37 = v32;
LABEL_49:
      CFRelease(v37);
      return v8;
    default:
      return v8;
  }
}

