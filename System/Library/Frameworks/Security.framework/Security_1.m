CFStringRef copyStringEndingIn(__CFString *theString, const __CFString *a2)
{
  CFIndex location;
  CFIndex v4;
  CFStringRef v5;
  CFRange v7;
  CFRange v8;

  if (!a2)
    return CFStringCreateCopy(0, theString);
  location = CFStringFind(theString, a2, 0).location;
  if (location == -1)
    return 0;
  v4 = location;
  v8.location = 0;
  v8.length = location;
  v5 = CFStringCreateWithSubstring(0, theString, v8);
  v7.length = v4 + 1;
  v7.location = 0;
  CFStringDelete(theString, v7);
  return v5;
}

uint64_t SOSKVSKeyGetKeyTypeAndParse(const __CFString *a1, CFStringRef *a2, CFStringRef *a3, CFStringRef *a4, uint64_t a5, CFStringRef *a6, CFStringRef *a7)
{
  unsigned int KeyType;
  uint64_t v14;

  KeyType = SOSKVSKeyGetKeyType(a1);
  if (SOSKVSKeyParse(KeyType, a1, a2, a3, a4, v14, a6, a7))
    return KeyType;
  else
    return 10;
}

CFStringRef SOSCircleKeyCreateWithCircle(uint64_t a1)
{
  uint64_t v1;

  if (a1 && (v1 = *(_QWORD *)(a1 + 16)) != 0)
    return CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), CFSTR("o"), v1);
  else
    return 0;
}

CFStringRef SOSRingKeyCreateWithName(CFStringRef result)
{
  if (result)
    return CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), CFSTR("~"), result);
  return result;
}

CFTypeRef SOSCircleKeyCopyCircleName(const __CFString *a1, CFTypeRef *a2)
{
  int KeyType;
  uint64_t v5;
  CFTypeRef v6;
  CFTypeRef cf;

  cf = 0;
  KeyType = SOSKVSKeyGetKeyType(a1);
  if (!SOSKVSKeyParse(KeyType, a1, (CFStringRef *)&cf, 0, 0, v5, 0, 0) || KeyType)
  {
    SOSCreateErrorWithFormat(1036, 0, a2, 0, CFSTR("Couldn't find circle name in key '%@'"), a1);
    v6 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v6);
    }
  }
  return cf;
}

CFTypeRef SOSMessageKeyCopyCircleName(const __CFString *a1, CFTypeRef *a2)
{
  int KeyType;
  uint64_t v5;
  CFTypeRef v6;
  CFTypeRef cf;

  cf = 0;
  KeyType = SOSKVSKeyGetKeyType(a1);
  if (!SOSKVSKeyParse(KeyType, a1, (CFStringRef *)&cf, 0, 0, v5, 0, 0) || KeyType != 1)
  {
    SOSCreateErrorWithFormat(1036, 0, a2, 0, CFSTR("Couldn't find circle name in key '%@'"), a1);
    v6 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v6);
    }
  }
  return cf;
}

CFTypeRef SOSMessageKeyCopyFromPeerName(const __CFString *a1, CFTypeRef *a2)
{
  int KeyType;
  uint64_t v5;
  CFTypeRef v6;
  CFTypeRef cf;

  cf = 0;
  KeyType = SOSKVSKeyGetKeyType(a1);
  if (!SOSKVSKeyParse(KeyType, a1, 0, 0, 0, v5, (CFStringRef *)&cf, 0) || KeyType != 1)
  {
    SOSCreateErrorWithFormat(1036, 0, a2, 0, CFSTR("Couldn't find from peer in key '%@'"), a1);
    v6 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v6);
    }
  }
  return cf;
}

CFStringRef SOSMessageKeyCreateWithCircleNameAndPeerNames(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@%@%@"), a1, CFSTR("|"), a2, CFSTR(":"), a3);
}

CFStringRef SOSMessageKeyCreateWithCircleAndPeerNames(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a1)
    v3 = *(_QWORD *)(a1 + 16);
  else
    v3 = 0;
  return CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@%@%@"), v3, CFSTR("|"), a2, CFSTR(":"), a3);
}

CFStringRef SOSMessageKeyCreateWithCircleAndPeerInfos(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 40);
    if (a3)
      goto LABEL_3;
LABEL_6:
    v4 = 0;
    if (a1)
      goto LABEL_4;
LABEL_7:
    v5 = 0;
    return CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@%@%@"), v5, CFSTR("|"), v3, CFSTR(":"), v4);
  }
  v3 = 0;
  if (!a3)
    goto LABEL_6;
LABEL_3:
  v4 = *(_QWORD *)(a3 + 40);
  if (!a1)
    goto LABEL_7;
LABEL_4:
  v5 = *(_QWORD *)(a1 + 16);
  return CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@%@%@"), v5, CFSTR("|"), v3, CFSTR(":"), v4);
}

CFStringRef SOSMessageKeyCreateFromPeerToTransport(void *a1, uint64_t a2, uint64_t a3)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@%@%@"), objc_msgSend(a1, "SOSTransportMessageGetCircleName"), CFSTR("|"), a3, CFSTR(":"), a2);
}

CFStringRef SOSMessageKeyCreateFromTransportToPeer(void *a1, uint64_t a2, uint64_t a3)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@%@%@"), objc_msgSend(a1, "SOSTransportMessageGetCircleName"), CFSTR("|"), a2, CFSTR(":"), a3);
}

CFStringRef SOSRetirementKeyCreateWithCircleNameAndPeer(uint64_t a1, uint64_t a2)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@%@"), CFSTR("-"), a1, CFSTR("|"), a2);
}

CFStringRef SOSRingKeyCreateWithRingName(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), CFSTR("~"), a1);
}

CFStringRef SOSRetirementKeyCreateWithCircleAndPeer(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if (a1)
    v2 = *(_QWORD *)(a1 + 16);
  else
    v2 = 0;
  return CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@%@"), CFSTR("-"), v2, CFSTR("|"), a2);
}

CFStringRef SOSLastKeyParametersPushedKeyCreateWithPeerID(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@%@"), CFSTR("k"), CFSTR(">KeyParameters"), CFSTR("|"), a1);
}

CFStringRef SOSLastKeyParametersPushedKeyCreateWithAccountGestalt(void *a1)
{
  const __CFDictionary *v1;
  __CFString *MutableCopy;
  CFStringRef v3;
  CFStringRef v4;
  _QWORD context[6];
  _QWORD v7[4];

  objc_msgSend(a1, "gestalt");
  v1 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
  if (v1)
  {
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("{"));
    v7[0] = 0;
    v7[1] = v7;
    v7[2] = 0x2000000000;
    v7[3] = &stru_1E1FDD448;
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 0x40000000;
    context[2] = __CFDictionaryCopySuperCompactDescription_block_invoke;
    context[3] = &unk_1E1FDBF98;
    context[4] = v7;
    context[5] = MutableCopy;
    CFDictionaryApplyFunction(v1, (CFDictionaryApplierFunction)apply_block_2_12810, context);
    CFStringAppendFormat(MutableCopy, 0, CFSTR("}"));
    _Block_object_dispose(v7, 8);
  }
  else
  {
    MutableCopy = (__CFString *)CFCopyDescription((CFTypeRef)*MEMORY[0x1E0C9B0D0]);
  }

  v3 = CFStringCreateWithFormat(0, 0, CFSTR("%@"), MutableCopy);
  if (MutableCopy)
    CFRelease(MutableCopy);
  v4 = CFStringCreateWithFormat(0, 0, CFSTR("%@%@%@%@"), CFSTR("k"), CFSTR(">KeyParameters"), CFSTR("|"), v3);
  if (v3)
    CFRelease(v3);
  return v4;
}

CFStringRef SOSDebugInfoKeyCreateWithTypeName(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), CFSTR("dbg-"), a1);
}

__CFString *SOSKeyedPubKeyIdentifierCreateWithData(const __CFString *a1, const __CFData *a2)
{
  CFStringRef v3;
  const __CFString *v4;
  __CFString *MutableCopy;
  NSObject *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v3 = SOSCopyIDOfDataBuffer(a2);
  v4 = v3;
  if (a1 && v3)
  {
    if (CFStringGetLength(a1) == 2)
    {
      MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 50, a1);
      CFStringAppend(MutableCopy, CFSTR("-"));
      CFStringAppend(MutableCopy, v4);
LABEL_5:
      CFRelease(v4);
      return MutableCopy;
    }
LABEL_8:
    MutableCopy = 0;
    goto LABEL_5;
  }
  if (v3)
    goto LABEL_8;
  v7 = secLogObjForScope("kpid");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = 138412290;
    v9 = 0;
    _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "Couldn't create kpid: %@", (uint8_t *)&v8, 0xCu);
  }
  return 0;
}

CFStringRef SOSKeyedPubKeyIdentifierCopyPrefix(const __CFString *a1)
{
  CFRange v3;

  if ((unint64_t)CFStringFind(a1, CFSTR("-"), 0).location != 2)
    return 0;
  v3.location = 0;
  v3.length = 2;
  return CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v3);
}

CFTypeRef SecCFRetainForCollection(int a1, CFTypeRef cf)
{
  return CFRetain(cf);
}

void SecCFReleaseForCollection(int a1, CFTypeRef cf)
{
  CFRelease(cf);
}

BOOL SOSPeerInfoIDEqual(_QWORD *a1, _QWORD *a2)
{
  _QWORD *IDOrString;
  _QWORD *v4;

  IDOrString = GetIDOrString(a1);
  v4 = GetIDOrString(a2);
  if (IDOrString && v4)
    return CFEqual(IDOrString, v4) != 0;
  else
    return IDOrString == v4;
}

CFHashCode SOSPeerInfoIDHash(_QWORD *a1)
{
  _QWORD *IDOrString;

  IDOrString = GetIDOrString(a1);
  return CFHash(IDOrString);
}

_QWORD *GetIDOrString(_QWORD *result)
{
  _QWORD *v1;
  CFTypeID v2;
  CFTypeID v3;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == SOSPeerInfoGetTypeID())
    {
      return (_QWORD *)v1[5];
    }
    else
    {
      v3 = CFGetTypeID(v1);
      if (v3 == CFStringGetTypeID())
        return v1;
      else
        return 0;
    }
  }
  return result;
}

BOOL SOSPeerInfoSetContainsIdenticalPeers(CFTypeRef cf1, CFTypeRef cf2)
{
  _BOOL8 v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 1;
  if (!cf1 || !cf2)
  {
    if (cf1 == cf2)
      goto LABEL_4;
LABEL_6:
    v4 = 0;
    goto LABEL_7;
  }
  if (!CFEqual(cf1, cf2))
    goto LABEL_6;
LABEL_4:
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __SOSPeerInfoSetContainsIdenticalPeers_block_invoke;
  v6[3] = &unk_1E1FD2300;
  v6[4] = &v7;
  v6[5] = cf2;
  CFSetApplyFunction((CFSetRef)cf1, (CFSetApplierFunction)apply_block_1_6023, v6);
  v4 = *((_BYTE *)v8 + 24) != 0;
LABEL_7:
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t apply_block_1_6023(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFMutableSetRef CFSetCreateMutableForSOSPeerInfosByID(const __CFAllocator *a1)
{
  return CFSetCreateMutable(a1, 0, &kSOSPeerSetCallbacks);
}

CFMutableSetRef CFSetCreateMutableForSOSPeerInfosByIDWithArray(const __CFAllocator *a1, const __CFArray *a2)
{
  CFMutableSetRef Mutable;
  _QWORD context[5];
  CFRange v6;

  Mutable = CFSetCreateMutable(a1, 0, &kSOSPeerSetCallbacks);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __CFSetCreateMutableForSOSPeerInfosByIDWithArray_block_invoke;
  context[3] = &__block_descriptor_tmp_1_6027;
  context[4] = Mutable;
  v6.length = CFArrayGetCount(a2);
  v6.location = 0;
  CFArrayApplyFunction(a2, v6, (CFArrayApplierFunction)apply_block_1_6023, context);
  return Mutable;
}

void CFArrayOfSOSPeerInfosSortByID(const __CFArray *a1)
{
  CFRange v2;

  if (a1)
  {
    if (CFArrayGetCount(a1) >= 1)
    {
      v2.length = CFArrayGetCount(a1);
      v2.location = 0;
      CFArraySortValues(a1, v2, (CFComparatorFunction)SOSPeerInfoCompareByID, 0);
    }
  }
}

__CFArray *SOSPeerInfoArrayCreateFromDER(const __CFAllocator *a1, CFTypeRef *a2, uint64_t *a3)
{
  __CFArray *Mutable;
  uint64_t v7;
  const void *v8;
  const void *v9;
  const void *v10;

  Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  v7 = ccder_decode_constructed_tl();
  *a3 = v7;
  if (!v7)
  {
    SOSCreateErrorWithFormat(1035, 0, a2, 0, CFSTR("%@"), CFSTR("Bad Peer Info Array Sequence Header"));
    if (!Mutable)
      goto LABEL_16;
    goto LABEL_15;
  }
  if (v7 != 0xAAAAAAAAAAAAAAAALL)
  {
    while (1)
    {
      v8 = (const void *)SOSPeerInfoCreateFromDER(a1, a2, a3);
      v9 = v8;
      if (!v8)
        break;
      if (!*a3)
      {
        v10 = v8;
        if (!a2)
          goto LABEL_11;
LABEL_9:
        SOSCreateErrorWithFormat(1035, (__CFString *)*a2, a2, 0, CFSTR("%@"), CFSTR("Bad Peer Info Array DER"));
        goto LABEL_12;
      }
      CFArrayAppendValue(Mutable, v8);
      CFRelease(v9);
      if (*a3 == 0xAAAAAAAAAAAAAAAALL)
        goto LABEL_6;
    }
    v10 = 0;
    if (a2)
      goto LABEL_9;
LABEL_11:
    SOSCreateErrorWithFormat(1035, 0, 0, 0, CFSTR("%@"), CFSTR("Bad Peer Info Array DER"));
LABEL_12:
    if (v9)
      CFRelease(v10);
    if (!Mutable)
      goto LABEL_16;
LABEL_15:
    CFRelease(Mutable);
LABEL_16:
    Mutable = 0;
    *a3 = 0;
    return Mutable;
  }
LABEL_6:
  if (!Mutable)
    goto LABEL_16;
  return Mutable;
}

uint64_t SOSPeerInfoArrayGetDEREncodedSize(const __CFArray *a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD context[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;
  _QWORD v10[4];
  CFRange v11;

  v10[0] = 0;
  v10[1] = v10;
  v10[2] = 0x2000000000;
  v10[3] = 0;
  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSPeerInfoArrayGetDEREncodedSize_block_invoke;
  context[3] = &unk_1E1FD2348;
  context[5] = v10;
  context[6] = a2;
  context[4] = &v6;
  v11.length = CFArrayGetCount(a1);
  v11.location = 0;
  CFArrayApplyFunction(a1, v11, (CFArrayApplierFunction)apply_block_1_6023, context);
  v3 = 0;
  if (!*((_BYTE *)v7 + 24))
    v3 = ccder_sizeof();
  _Block_object_dispose(&v6, 8);
  _Block_object_dispose(v10, 8);
  return v3;
}

uint64_t SOSPeerInfoArrayEncodeToDER(const __CFArray *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFIndex Count;
  unint64_t v6;
  const void *ValueAtIndex;
  uint64_t v8;
  _QWORD v10[2];
  uint64_t (*v11)(uint64_t, CFTypeRef);
  void *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;

  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = a4;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v11 = __SOSPeerInfoArrayEncodeToDER_block_invoke;
  v12 = &unk_1E1FD2370;
  v13 = &v16;
  v14 = a2;
  v15 = a3;
  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v6 = Count + 1;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v6 - 2);
      v11((uint64_t)v10, ValueAtIndex);
      --v6;
    }
    while (v6 > 1);
  }
  if (v17[3])
    v8 = ccder_encode_constructed_tl();
  else
    v8 = 0;
  _Block_object_dispose(&v16, 8);
  return v8;
}

CFMutableSetRef SOSPeerInfoSetCreateFromArrayDER(const __CFAllocator *a1, const CFSetCallBacks *a2, CFTypeRef *a3, uint64_t *a4)
{
  __CFArray *v6;
  const __CFArray *v7;
  CFMutableSetRef Mutable;
  _QWORD context[5];
  CFRange v11;

  v6 = SOSPeerInfoArrayCreateFromDER(a1, a3, a4);
  if (!v6)
    return 0;
  v7 = v6;
  Mutable = CFSetCreateMutable(a1, 0, a2);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __CFSetSetValues_block_invoke;
  context[3] = &__block_descriptor_tmp_14_6038;
  context[4] = Mutable;
  v11.length = CFArrayGetCount(v7);
  v11.location = 0;
  CFArrayApplyFunction(v7, v11, (CFArrayApplierFunction)apply_block_1_6023, context);
  CFRelease(v7);
  return Mutable;
}

uint64_t SOSPeerInfoSetGetDEREncodedArraySize(const __CFSet *a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD context[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;
  _QWORD v9[4];

  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x2000000000;
  v9[3] = 0;
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SOSPeerInfoSetGetDEREncodedArraySize_block_invoke;
  context[3] = &unk_1E1FD2398;
  context[5] = v9;
  context[6] = a2;
  context[4] = &v5;
  CFSetApplyFunction(a1, (CFSetApplierFunction)apply_block_1_6023, context);
  v2 = 0;
  if (!*((_BYTE *)v6 + 24))
    v2 = ccder_sizeof();
  _Block_object_dispose(&v5, 8);
  _Block_object_dispose(v9, 8);
  return v2;
}

uint64_t SOSPeerInfoSetEncodeToArrayDER(const __CFSet *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const __CFArray *Mutable;
  uint64_t v9;
  _QWORD context[5];

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __CFSetCopyValues_block_invoke;
  context[3] = &__block_descriptor_tmp_15_6044;
  context[4] = Mutable;
  CFSetApplyFunction(a1, (CFSetApplierFunction)apply_block_1_6023, context);
  CFArrayOfSOSPeerInfosSortByID(Mutable);
  v9 = SOSPeerInfoArrayEncodeToDER(Mutable, a2, a3, a4);
  if (Mutable)
    CFRelease(Mutable);
  return v9;
}

__CFArray *CreateArrayOfPeerInfoWithXPCObject(void *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v10;
  const __CFString *v11;
  CFIndex v12;
  char v14;
  const void *bytes_ptr;

  if (!a1)
  {
    v10 = (const __CFString *)sSecXPCErrorDomain;
    v11 = CFSTR("Unexpected Null Array to encode");
    v12 = 2;
    goto LABEL_5;
  }
  if (MEMORY[0x18D7718B8]() != MEMORY[0x1E0C812E8])
  {
    v10 = (const __CFString *)sSecXPCErrorDomain;
    v11 = CFSTR("Array of peer info not data");
    v12 = 1;
LABEL_5:
    SecCFCreateErrorWithFormat(v12, v10, 0, a2, a5, v11, a7, a8, v14);
    return 0;
  }
  bytes_ptr = xpc_data_get_bytes_ptr(a1);
  xpc_data_get_length(a1);
  return SOSPeerInfoArrayCreateFromDER((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2, (uint64_t *)&bytes_ptr);
}

int64_t CreateXPCObjectWithArrayOfPeerInfo(const __CFArray *a1, uint64_t a2)
{
  size_t DEREncodedSize;
  int64_t v5;
  void *v6;
  void *v7;

  DEREncodedSize = SOSPeerInfoArrayGetDEREncodedSize(a1, a2);
  v5 = DEREncodedSize;
  if (DEREncodedSize)
  {
    v6 = malloc_type_malloc(DEREncodedSize, 0xA3410646uLL);
    if (v6)
    {
      v7 = v6;
      if (SOSPeerInfoArrayEncodeToDER(a1, a2, (uint64_t)v6, (uint64_t)v6 + v5))
        v5 = (int64_t)xpc_data_create(v7, v5);
      else
        v5 = 0;
      free(v7);
    }
    else
    {
      return 0;
    }
  }
  return v5;
}

uint64_t SOSPeerInfoGetDEREncodedSize(uint64_t a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v11;

  if (a1)
  {
    if (der_sizeof_plist(*(const __CFString **)(a1 + 16), a2, a3, a4, a5, a6, a7, a8))
    {
      CFDataGetLength(*(CFDataRef *)(a1 + 24));
      if (ccder_sizeof_raw_octet_string())
        return ccder_sizeof();
      v11 = CFSTR("Peer not signed to encode");
    }
    else
    {
      v11 = CFSTR("No Description to encode");
    }
  }
  else
  {
    v11 = CFSTR("No PeerInfo to encode");
  }
  SOSCreateErrorWithFormat(1045, 0, a2, 0, CFSTR("%@"), v11);
  return 0;
}

uint64_t SOSPeerInfoEncodeToDER(uint64_t a1, CFTypeRef *a2, UInt8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (a1)
  {
    if (*(uint64_t *)(a1 + 56) >= 2)
      SOSPeerInfoPackV2Data(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    v11 = *(const __CFString **)(a1 + 16);
    v12 = der_encode_data(*(const __CFData **)(a1 + 24), a2);
    der_encode_plist_repair(v11, a2, 0, a3, v12, v13, v14, v15);
    return ccder_encode_constructed_tl();
  }
  else
  {
    SOSCreateErrorWithFormat(1045, 0, a2, 0, CFSTR("%@"), CFSTR("No PeerInfo to encode"));
    return 0;
  }
}

__CFData *SOSPeerInfoCopyEncodedData(uint64_t a1, int a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFAllocator *v10;
  CFIndex DEREncodedSize;
  _QWORD v13[6];

  if (a1)
  {
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    DEREncodedSize = SOSPeerInfoGetDEREncodedSize(a1, a3, (uint64_t)a3, a4, a5, a6, a7, a8);
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __SOSPeerInfoCopyEncodedData_block_invoke;
    v13[3] = &__block_descriptor_48_e11__24__0Q8_16l;
    v13[4] = a1;
    v13[5] = a3;
    return CFDataCreateWithDER(v10, DEREncodedSize, v13);
  }
  else
  {
    SOSCreateErrorWithFormat(1045, 0, a3, 0, CFSTR("%@"), CFSTR("No PeerInfo to encode"));
    return 0;
  }
}

uint64_t SOSPeerInfoCreateFromDER(const __CFAllocator *a1, CFTypeRef *a2, _QWORD *a3)
{
  uint64_t Instance;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const UInt8 *v15;
  BOOL v16;
  CFTypeRef v17;
  CFTypeID v18;
  const void *Value;
  const void *v20;
  CFTypeID v21;
  const void *v22;
  const void *v23;
  CFTypeID v24;
  _QWORD *v25;
  const __CFString *v26;
  const __CFString *v27;
  CFIndex Length;
  const __CFAllocator *v29;
  CFStringRef Copy;
  CFTypeID v31;
  CFStringRef v32;
  CFTypeID v33;
  CFStringRef v34;
  CFTypeID v35;
  NSObject *v37;
  CFTypeRef v38;
  CFTypeRef cf;
  const UInt8 *v40;
  uint8_t buf[4];
  CFTypeRef v42;
  uint64_t v43;
  CFRange v44;

  v43 = *MEMORY[0x1E0C80C00];
  SOSPeerInfoGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  cf = 0;
  v40 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)(Instance + 32) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  v7 = ccder_decode_constructed_tl();
  *a3 = v7;
  v11 = der_decode_plist((uint64_t)a1, (uint64_t)&cf, a2, v7, (uint64_t)v40, v8, v9, v10);
  *a3 = v11;
  v15 = der_decode_data(a1, (CFDataRef *)(Instance + 24), a2, v11, (uint64_t)v40, v12, v13, v14);
  *a3 = v15;
  if (v15)
    v16 = v15 == v40;
  else
    v16 = 0;
  if (!v16)
  {
    SOSCreateErrorWithFormat(1035, 0, a2, 0, CFSTR("%@"), CFSTR("Bad Format of Peer Info DER"));
    v17 = cf;
    goto LABEL_20;
  }
  v17 = cf;
  v18 = CFGetTypeID(cf);
  if (v18 == CFDictionaryGetTypeID())
  {
    *(_QWORD *)(Instance + 16) = v17;
    CFRetain(v17);
    if (v17)
    {
      cf = 0;
      CFRelease(v17);
    }
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(Instance + 16), CFSTR("ConflictVersion"));
    if (Value)
    {
      v20 = Value;
      v21 = CFGetTypeID(Value);
      if (v21 != CFNumberGetTypeID())
      {
        v33 = CFGetTypeID(v20);
        v34 = CFCopyTypeIDDescription(v33);
        SOSCreateErrorWithFormat(1040, 0, a2, 0, CFSTR("Expected (version) number got %@"), v34);
        goto LABEL_25;
      }
      CFNumberGetValue((CFNumberRef)v20, kCFNumberCFIndexType, (void *)(Instance + 56));
    }
    v22 = CFDictionaryGetValue(*(CFDictionaryRef *)(Instance + 16), CFSTR("DeviceGestalt"));
    if (!v22)
    {
      SOSCreateErrorWithFormat(1040, 0, a2, 0, CFSTR("gestalt key missing"));
      goto LABEL_27;
    }
    v23 = v22;
    v24 = CFGetTypeID(v22);
    if (v24 == CFDictionaryGetTypeID())
    {
      *(_QWORD *)(Instance + 32) = v23;
      CFRetain(v23);
      v25 = _SOSPeerInfoCopyPubKey((CFDictionaryRef *)Instance, CFSTR("PublicSigningKey"), a2);
      if (v25)
      {
        v17 = v25;
        v26 = SOSCopyIDOfKey((uint64_t)v25, a2);
        *(_QWORD *)(Instance + 40) = v26;
        if (v26)
        {
          v27 = v26;
          Length = CFStringGetLength(v26);
          v29 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          if (Length > 8)
          {
            v44.location = 0;
            v44.length = 8;
            Copy = CFStringCreateWithSubstring(v29, v27, v44);
          }
          else
          {
            Copy = CFStringCreateCopy(v29, v27);
          }
          *(_QWORD *)(Instance + 48) = Copy;
          if (*(uint64_t *)(Instance + 56) >= 2)
            SOSPeerInfoExpandV2Data(Instance, a2);
          if ((SOSPeerInfoVerify((CFDictionaryRef *)Instance, a2) & 1) != 0)
            goto LABEL_29;
          SOSCreateErrorWithFormat(1038, 0, a2, 0, CFSTR("Signature doesn't validate"));
          if (a2)
          {
            secLogObjForScope("SecError");
            v37 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              v38 = *a2;
              *(_DWORD *)buf = 138412290;
              v42 = v38;
              _os_log_impl(&dword_18A900000, v37, OS_LOG_TYPE_DEFAULT, "Can't validate PeerInfo: %@", buf, 0xCu);
            }

          }
        }
        CFRelease((CFTypeRef)Instance);
        goto LABEL_28;
      }
LABEL_27:
      v17 = (CFTypeRef)Instance;
LABEL_28:
      Instance = 0;
      goto LABEL_29;
    }
    v35 = CFGetTypeID(v23);
    v34 = CFCopyTypeIDDescription(v35);
    SOSCreateErrorWithFormat(1040, 0, a2, 0, CFSTR("Expected dictionary got %@"), v34);
LABEL_25:
    if (v34)
      CFRelease(v34);
    goto LABEL_27;
  }
  v31 = CFGetTypeID(v17);
  v32 = CFCopyTypeIDDescription(v31);
  SOSCreateErrorWithFormat(1040, 0, a2, 0, CFSTR("Expected dictionary got %@"), v32);
  if (v32)
    CFRelease(v32);
LABEL_20:
  CFRelease((CFTypeRef)Instance);
  Instance = 0;
  if (v17)
  {
    cf = 0;
LABEL_29:
    CFRelease(v17);
  }
  return Instance;
}

uint64_t SOSPeerInfoCreateFromData(int a1, CFTypeRef *a2, CFDataRef theData)
{
  const UInt8 *BytePtr;

  BytePtr = CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  return SOSPeerInfoCreateFromDER(0, a2, &BytePtr);
}

BOOL SOSPeerInfoSerialNumberIsSet(uint64_t a1)
{
  CFMutableStringRef v1;
  CFMutableStringRef v2;

  v1 = SOSPeerInfoV2DictionaryCopyString(a1, (const void *)sSerialNumberKey);
  v2 = v1;
  if (v1)
    CFRelease(v1);
  return v2 != 0;
}

CFMutableStringRef SOSPeerInfoV2DictionaryCopyString(uint64_t a1, const void *a2)
{
  const __CFString *Value;
  const __CFString *v5;
  CFTypeID v6;
  const __CFAllocator *v7;
  CFIndex Length;

  if (!SOSPeerInfoExpandV2Data(a1, 0))
    return 0;
  Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  if (!Value)
    return 0;
  v5 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 != CFStringGetTypeID())
    return 0;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Length = CFStringGetLength(v5);
  return CFStringCreateMutableCopy(v7, Length, v5);
}

uint64_t SOSPeerInfoExpandV2Data(uint64_t result, CFTypeRef *a2)
{
  uint64_t v2;
  const void *Value;
  const void *v5;
  CFTypeID v6;
  CFTypeID v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFTypeRef v15;
  CFTypeID v16;
  const void *v17;
  const __CFString *v18;
  CFTypeID v19;
  CFStringRef v20;
  CFTypeRef cf;

  if (result)
  {
    v2 = result;
    if (*(uint64_t *)(result + 56) < 2)
      return 0;
    if (*(_BYTE *)(result + 73))
      return 1;
    if (*(_QWORD *)(result + 80))
      goto LABEL_6;
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(result + 16), (const void *)sV2DictionaryKey);
    if (!Value || (v5 = Value, v6 = CFGetTypeID(Value), v6 != CFDataGetTypeID()))
    {
      v18 = CFSTR("No V2 Data in description");
LABEL_25:
      SOSCreateErrorWithFormat(1029, 0, a2, 0, CFSTR("%@"), v18);
      return 0;
    }
    cf = 0;
    v7 = CFGetTypeID(v5);
    if (v7 == CFDataGetTypeID())
    {
      BytePtr = CFDataGetBytePtr((CFDataRef)v5);
      Length = CFDataGetLength((CFDataRef)v5);
      v10 = &BytePtr[Length];
      v14 = der_decode_plist(0, (uint64_t)&cf, a2, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length], v11, v12, v13);
      if (v14 && (const UInt8 *)v14 == v10)
      {
        v15 = cf;
        v16 = CFGetTypeID(cf);
        if (v16 == CFDictionaryGetTypeID())
        {
          if (v15)
          {
            v17 = *(const void **)(v2 + 80);
            if (v17)
            {
              *(_QWORD *)(v2 + 80) = 0;
              CFRelease(v17);
            }
            *(_QWORD *)(v2 + 80) = v15;
LABEL_6:
            result = 1;
            *(_BYTE *)(v2 + 73) = 1;
            return result;
          }
          goto LABEL_24;
        }
        v19 = CFGetTypeID(v15);
        v20 = CFCopyTypeIDDescription(v19);
        SOSCreateErrorWithFormat(1040, 0, a2, 0, CFSTR("Expected dictionary got %@"), v20);
        if (v20)
          CFRelease(v20);
      }
      else
      {
        SOSCreateErrorWithFormat(1035, 0, a2, 0, CFSTR("%@"), CFSTR("Bad Format of Dictionary DER"));
        v15 = cf;
      }
      if (v15)
        CFRelease(v15);
    }
    else
    {
      SOSCreateErrorWithFormat(1035, 0, a2, 0, CFSTR("%@"), CFSTR("Corrupted v2Data Item"));
    }
LABEL_24:
    v18 = CFSTR("Can't expand V2 Dictionary");
    goto LABEL_25;
  }
  return result;
}

void SOSPeerInfoSetSerialNumber(uint64_t a1)
{
  const void *v2;

  if (!SOSGestaltSerial)
  {
    v2 = (const void *)MGCopyAnswer();
    if (!v2)
    {
      SOSCreateErrorWithFormat(1024, 0, 0, 0, CFSTR("%@"), CFSTR("No Memory"));
      return;
    }
LABEL_5:
    SOSPeerInfoV2DictionarySetValue(a1, (const void *)sSerialNumberKey, v2);
    CFRelease(v2);
    return;
  }
  v2 = CFRetain((CFTypeRef)SOSGestaltSerial);
  if (v2)
    goto LABEL_5;
}

void SOSPeerInfoV2DictionarySetValue(uint64_t a1, const void *a2, const void *a3)
{
  __CFDictionary *v6;

  if (SOSPeerInfoExpandV2Data(a1, 0))
  {
    v6 = *(__CFDictionary **)(a1 + 80);
    if (a3)
      CFDictionarySetValue(v6, a2, a3);
    else
      CFDictionaryRemoveValue(v6, a2);
  }
}

void SOSPeerInfoSetTestSerialNumber(uint64_t a1, const void *a2)
{
  if (a2)
    SOSPeerInfoV2DictionarySetValue(a1, (const void *)sSerialNumberKey, a2);
}

CFMutableStringRef SOSPeerInfoCopySerialNumber(uint64_t a1)
{
  CFMutableStringRef result;

  result = SOSPeerInfoV2DictionaryCopyString(a1, (const void *)sSerialNumberKey);
  if (!result)
    return (CFMutableStringRef)CFRetain(CFSTR("Unknown"));
  return result;
}

BOOL SOSPeerInfoUpdateToV2(uint64_t a1, CFTypeRef *a2)
{
  CFNumberRef v4;
  __CFDictionary *Mutable;
  CFMutableSetRef v6;
  CFMutableSetRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFDataRef v14;
  _BOOL8 v15;
  uint64_t valuePtr;

  if (!a1)
    return 0;
  *(_QWORD *)(a1 + 56) = 3;
  valuePtr = 3;
  v4 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), CFSTR("ConflictVersion"), v4);
  if (v4)
    CFRelease(v4);
  *(_BYTE *)(a1 + 73) = 0;
  Mutable = CFDictionaryCreateMutable(0, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v6 = SOSViewCopyViewSet(1u);
  v7 = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  CFDictionaryAddValue(Mutable, (const void *)sViewsKey, v6);
  v14 = SOSCreateDERFromDictionary((const __CFString *)Mutable, a2, v8, v9, v10, v11, v12, v13);
  v15 = v14 != 0;
  if (!v14)
  {
    SOSCreateErrorWithFormat(1024, 0, a2, 0, CFSTR("%@"), CFSTR("No Memory"));
    if (!v6)
      goto LABEL_7;
    goto LABEL_6;
  }
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 16), (const void *)sV2DictionaryKey, v14);
  SOSPeerInfoSetSerialNumber(a1);
  SOSPeerInfoExpandV2Data(a1, a2);
  if (v6)
LABEL_6:
    CFRelease(v6);
LABEL_7:
  if (v14)
    CFRelease(v14);
  if (Mutable)
    CFRelease(Mutable);
  if (v7)
    CFRelease(v7);
  return v15;
}

CFDataRef SOSCreateDERFromDictionary(const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v10;
  CFIndex v11;
  UInt8 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  UInt8 *v16;

  v10 = der_sizeof_plist(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    v11 = v10;
    v12 = (UInt8 *)malloc_type_malloc(v10, 0xF72459D2uLL);
    if (v12)
    {
      v16 = v12;
      if (der_encode_plist_repair(a1, a2, 0, v12, (unint64_t)&v12[v11], v13, v14, v15))
        return CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v16, v11, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
      free(v16);
    }
  }
  return 0;
}

void SOSPeerInfoPackV2Data(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v9;
  CFDataRef v10;

  if (a1)
  {
    if (*(uint64_t *)(a1 + 56) >= 2)
    {
      v9 = *(const __CFString **)(a1 + 80);
      if (v9)
      {
        v10 = SOSCreateDERFromDictionary(v9, 0, a3, a4, a5, a6, a7, a8);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), (const void *)sV2DictionaryKey, v10);
        if (v10)
          CFRelease(v10);
      }
    }
  }
}

void SOSPeerInfoV2DictionaryRemoveValue(uint64_t a1, const void *a2)
{
  if (SOSPeerInfoExpandV2Data(a1, 0))
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 80), a2);
}

uint64_t SOSPeerInfoV2DictionaryHasBoolean(uint64_t a1, const void *a2)
{
  uint64_t result;
  const void *Value;
  CFTypeID v6;

  result = SOSPeerInfoExpandV2Data(a1, 0);
  if ((_DWORD)result)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    result = 0;
    if (Value)
    {
      v6 = CFGetTypeID(Value);
      if (v6 == CFBooleanGetTypeID())
        return 1;
    }
  }
  return result;
}

BOOL SOSPeerInfoV2DictionaryHasStringValue(uint64_t a1, const void *a2, const void *a3)
{
  const void *AsString;

  AsString = SOSPeerInfoV2DictionaryGetAsString(a1, a2);
  if (a3 && AsString)
    return CFEqual(AsString, a3) != 0;
  else
    return AsString == a3;
}

const void *SOSPeerInfoV2DictionaryGetAsString(uint64_t a1, const void *a2)
{
  const void *Value;
  const void *v5;
  CFTypeID v6;

  if (!SOSPeerInfoExpandV2Data(a1, 0))
    return 0;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  if (!Value)
    return 0;
  v5 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 != CFStringGetTypeID())
    return 0;
  return v5;
}

const __CFString *SOSPeerInfoV2DictionaryHasString(uint64_t a1, const void *a2)
{
  const __CFString *result;

  result = (const __CFString *)SOSPeerInfoV2DictionaryGetAsString(a1, a2);
  if (result)
    return (const __CFString *)(CFStringGetLength(result) > 0);
  return result;
}

uint64_t SOSPeerInfoV2DictionaryHasSet(uint64_t a1, const void *a2)
{
  uint64_t result;
  const void *Value;
  CFTypeID v6;

  result = SOSPeerInfoExpandV2Data(a1, 0);
  if ((_DWORD)result)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    result = 0;
    if (Value)
    {
      v6 = CFGetTypeID(Value);
      if (v6 == CFSetGetTypeID())
        return 1;
    }
  }
  return result;
}

uint64_t SOSPeerInfoV2DictionaryHasData(uint64_t a1, const void *a2)
{
  uint64_t result;
  const void *Value;
  CFTypeID v6;

  result = SOSPeerInfoExpandV2Data(a1, 0);
  if ((_DWORD)result)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    result = 0;
    if (Value)
    {
      v6 = CFGetTypeID(Value);
      if (v6 == CFDataGetTypeID())
        return 1;
    }
  }
  return result;
}

void SOSPeerInfoV2DictionaryWithSet(uint64_t a1, const void *a2, void *a3)
{
  id v5;
  id v6;
  _QWORD *v7;
  const void *Value;
  const void *v9;
  _QWORD v10[2];
  CFTypeID (*v11)(CFTypeID, CFTypeRef);
  void *v12;
  id v13;

  v5 = a3;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v11 = __SOSPeerInfoV2DictionaryWithSet_block_invoke;
  v12 = &unk_1E1FD2430;
  v6 = v5;
  v13 = v6;
  v7 = v10;
  if (SOSPeerInfoExpandV2Data(a1, 0))
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    if (Value)
    {
      v9 = Value;
      CFRetain(Value);
      v11((CFTypeID)v7, v9);
      CFRelease(v9);
    }
    else
    {
      v11((CFTypeID)v7, 0);
    }
  }

}

CFMutableSetRef SOSPeerInfoV2DictionaryCopySet(uint64_t a1, const void *a2)
{
  const __CFSet *Value;
  const __CFSet *v5;
  CFTypeID v6;
  const __CFAllocator *v7;
  CFIndex Count;

  if (!SOSPeerInfoExpandV2Data(a1, 0))
    return 0;
  Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  if (!Value)
    return 0;
  v5 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 != CFSetGetTypeID())
    return 0;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Count = CFSetGetCount(v5);
  return CFSetCreateMutableCopy(v7, Count, v5);
}

void SOSPeerInfoV2DictionaryForEachSetValue(uint64_t a1, const void *a2, void *a3)
{
  const __CFSet *Value;
  const __CFSet *v6;
  CFTypeID v7;
  id context;

  context = a3;
  if (SOSPeerInfoExpandV2Data(a1, 0))
  {
    Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    if (Value)
    {
      v6 = Value;
      v7 = CFGetTypeID(Value);
      if (v7 == CFSetGetTypeID())
        CFSetApplyFunction(v6, (CFSetApplierFunction)apply_block_1_6134, context);
    }
  }

}

uint64_t apply_block_1_6134(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

const __CFSet *SOSPeerInfoV2DictionaryHasSetContaining(uint64_t a1, const void *a2, const void *a3)
{
  const __CFSet *result;
  const __CFSet *v7;
  CFTypeID v8;

  result = (const __CFSet *)SOSPeerInfoExpandV2Data(a1, 0);
  if ((_DWORD)result)
  {
    result = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
    if (result)
    {
      v7 = result;
      v8 = CFGetTypeID(result);
      if (v8 == CFSetGetTypeID())
        return (const __CFSet *)(CFSetContainsValue(v7, a3) != 0);
      else
        return 0;
    }
  }
  return result;
}

CFMutableDataRef SOSPeerInfoV2DictionaryCopyData(uint64_t a1, const void *a2)
{
  const __CFData *Value;
  const __CFData *v5;
  CFTypeID v6;
  const __CFAllocator *v7;
  CFIndex Length;

  if (!SOSPeerInfoExpandV2Data(a1, 0))
    return 0;
  Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  if (!Value)
    return 0;
  v5 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 != CFDataGetTypeID())
    return 0;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Length = CFDataGetLength(v5);
  return CFDataCreateMutableCopy(v7, Length, v5);
}

const void *SOSPeerInfoV2DictionaryCopyBoolean(uint64_t a1, const void *a2)
{
  const void *Value;
  const void *v5;
  CFTypeID v6;

  if (!SOSPeerInfoExpandV2Data(a1, 0))
    return 0;
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  v5 = Value;
  if (Value)
  {
    v6 = CFGetTypeID(Value);
    if (v6 == CFBooleanGetTypeID())
    {
      CFRetain(v5);
      return v5;
    }
    return 0;
  }
  return v5;
}

CFMutableDictionaryRef SOSPeerInfoV2DictionaryCopyDictionary(uint64_t a1, const void *a2)
{
  const __CFDictionary *Value;
  const __CFDictionary *v5;
  CFTypeID v6;
  const __CFAllocator *v7;
  CFIndex Count;

  if (!SOSPeerInfoExpandV2Data(a1, 0))
    return 0;
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 80), a2);
  if (!Value)
    return 0;
  v5 = Value;
  v6 = CFGetTypeID(Value);
  if (v6 != CFDictionaryGetTypeID())
    return 0;
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Count = CFDictionaryGetCount(v5);
  return CFDictionaryCreateMutableCopy(v7, Count, v5);
}

const void *SOSPeerInfoCopyWithV2DictionaryUpdate(uint64_t a1, uint64_t a2, const __CFDictionary *a3, __SecKey *a4, CFTypeRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Copy;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD context[5];

  Copy = SOSPeerInfoCreateCopy((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2, a5, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
  v12 = (const void *)Copy;
  if (Copy)
  {
    if ((SOSPeerInfoExpandV2Data(Copy, a5) & 1) == 0
      || (context[0] = MEMORY[0x1E0C809B0],
          context[1] = 3221225472,
          context[2] = __SOSPeerInfoCopyWithV2DictionaryUpdate_block_invoke,
          context[3] = &__block_descriptor_40_e15_v24__0r_v8r_v16l,
          context[4] = v12,
          CFDictionaryApplyFunction(a3, (CFDictionaryApplierFunction)apply_block_2_6139, context),
          SOSPeerInfoPackV2Data((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19),
          (SOSPeerInfoSign(a4, (uint64_t)v12, a5) & 1) == 0))
    {
      CFRelease(v12);
      return 0;
    }
  }
  return v12;
}

uint64_t apply_block_2_6139(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

CFMutableSetRef SOSViewCopyViewSet(unsigned int a1)
{
  const __CFAllocator *v2;
  __CFSet *Mutable;
  __CFSet *v4;
  const __CFString *v6;
  _QWORD context[5];

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
  v4 = Mutable;
  if ((a1 | 4) == 4)
  {
    CFSetAddValue(Mutable, CFSTR("WiFi"));
    CFSetAddValue(v4, CFSTR("Passwords"));
    CFSetAddValue(v4, CFSTR("CreditCards"));
  }
  if (a1 > 5 || a1 == 2 || (CFSetAddValue(v4, CFSTR("iCloudIdentity")), a1 > 4))
  {
LABEL_10:
    if (a1 >= 2 && a1 != 3)
    {
      if (a1 == 6)
      {
        CFSetAddValue(v4, CFSTR("Engram"));
        CFSetAddValue(v4, CFSTR("Manatee"));
        CFSetAddValue(v4, CFSTR("AutoUnlock"));
        CFSetAddValue(v4, CFSTR("Health"));
        CFSetAddValue(v4, CFSTR("ApplePay"));
        CFSetAddValue(v4, CFSTR("Home"));
        CFSetAddValue(v4, CFSTR("LimitedPeersAllowed"));
        CFSetAddValue(v4, CFSTR("MFi"));
        CFSetAddValue(v4, CFSTR("Mail"));
        CFSetAddValue(v4, CFSTR("Contacts"));
        CFSetAddValue(v4, CFSTR("Photos"));
        v6 = CFSTR("Groups");
        goto LABEL_26;
      }
      if (a1 != 5)
        goto LABEL_16;
    }
    CFSetAddValue(v4, CFSTR("PCS-Escrow"));
    if (a1 != 5)
    {
      CFSetAddValue(v4, CFSTR("PCS-FDE"));
      CFSetAddValue(v4, CFSTR("PCS-Feldspar"));
      CFSetAddValue(v4, CFSTR("PCS-Maildrop"));
      CFSetAddValue(v4, CFSTR("PCS-MasterKey"));
      CFSetAddValue(v4, CFSTR("PCS-Notes"));
      CFSetAddValue(v4, CFSTR("PCS-Photos"));
      CFSetAddValue(v4, CFSTR("PCS-Sharing"));
      CFSetAddValue(v4, CFSTR("PCS-Backup"));
      CFSetAddValue(v4, CFSTR("PCS-iCloudDrive"));
      CFSetAddValue(v4, CFSTR("PCS-iMessage"));
      CFSetAddValue(v4, CFSTR("NanoRegistry"));
      CFSetAddValue(v4, CFSTR("WatchMigration"));
      goto LABEL_16;
    }
    v6 = CFSTR("PCS-MasterKey");
LABEL_26:
    CFSetAddValue(v4, v6);
    return v4;
  }
  CFSetAddValue(v4, CFSTR("BackupBagV0"));
  switch(a1)
  {
    case 0u:
    case 4u:
      CFSetAddValue(v4, CFSTR("OtherSyncable"));
      if (a1 > 3)
        goto LABEL_16;
      break;
    case 1u:
    case 3u:
      break;
    default:
      goto LABEL_10;
  }
  CFSetAddValue(v4, CFSTR("ContinuityUnlock"));
  if (a1 <= 3)
  {
    CFSetAddValue(v4, CFSTR("AppleTV"));
    CFSetAddValue(v4, CFSTR("HomeKit"));
    CFSetAddValue(v4, CFSTR("AccessoryPairing"));
    CFSetAddValue(v4, CFSTR("PCS-CloudKit"));
    goto LABEL_10;
  }
LABEL_16:
  if (a1 != 3 || !sTestViewSet)
  {
    if (!a1 && sTestViewSet)
    {
      context[0] = MEMORY[0x1E0C809B0];
      context[1] = 3221225472;
      context[2] = __CFSetUnion_block_invoke_6232;
      context[3] = &__block_descriptor_40_e10_v16__0r_v8l;
      context[4] = v4;
      CFSetApplyFunction((CFSetRef)sTestViewSet, (CFSetApplierFunction)apply_block_1_6233, context);
    }
    return v4;
  }
  if (v4)
    CFRelease(v4);
  return CFSetCreateMutable(v2, 0, MEMORY[0x1E0C9B3B0]);
}

uint64_t apply_block_1_6233(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t SOSViewInSOSSystem(uint64_t result)
{
  const void *v1;

  if (result)
  {
    v1 = (const void *)result;
    if (CFEqual((CFTypeRef)result, CFSTR("KeychainV0"))
      || CFEqual(v1, CFSTR("WiFi"))
      || CFEqual(v1, CFSTR("Passwords"))
      || CFEqual(v1, CFSTR("CreditCards"))
      || CFEqual(v1, CFSTR("iCloudIdentity"))
      || CFEqual(v1, CFSTR("BackupBagV0"))
      || CFEqual(v1, CFSTR("OtherSyncable"))
      || CFEqual(v1, CFSTR("ContinuityUnlock"))
      || CFEqual(v1, CFSTR("AppleTV"))
      || CFEqual(v1, CFSTR("HomeKit"))
      || CFEqual(v1, CFSTR("AccessoryPairing"))
      || CFEqual(v1, CFSTR("PCS-CloudKit"))
      || CFEqual(v1, CFSTR("PCS-Escrow"))
      || CFEqual(v1, CFSTR("PCS-FDE"))
      || CFEqual(v1, CFSTR("PCS-Feldspar"))
      || CFEqual(v1, CFSTR("PCS-Maildrop"))
      || CFEqual(v1, CFSTR("PCS-MasterKey"))
      || CFEqual(v1, CFSTR("PCS-Notes"))
      || CFEqual(v1, CFSTR("PCS-Photos"))
      || CFEqual(v1, CFSTR("PCS-Sharing"))
      || CFEqual(v1, CFSTR("PCS-Backup"))
      || CFEqual(v1, CFSTR("PCS-iCloudDrive"))
      || CFEqual(v1, CFSTR("PCS-iMessage"))
      || CFEqual(v1, CFSTR("NanoRegistry"))
      || CFEqual(v1, CFSTR("WatchMigration")))
    {
      return 1;
    }
    else
    {
      if (!CFEqual(v1, CFSTR("Engram"))
        && !CFEqual(v1, CFSTR("Manatee"))
        && !CFEqual(v1, CFSTR("AutoUnlock"))
        && !CFEqual(v1, CFSTR("Health"))
        && !CFEqual(v1, CFSTR("ApplePay"))
        && !CFEqual(v1, CFSTR("Home"))
        && !CFEqual(v1, CFSTR("LimitedPeersAllowed"))
        && !CFEqual(v1, CFSTR("MFi"))
        && !CFEqual(v1, CFSTR("Mail"))
        && !CFEqual(v1, CFSTR("Contacts"))
        && !CFEqual(v1, CFSTR("Photos")))
      {
        CFEqual(v1, CFSTR("Groups"));
      }
      return 0;
    }
  }
  return result;
}

uint64_t SOSViewHintInSOSSystem(uint64_t result)
{
  const void *v1;

  if (result)
  {
    v1 = (const void *)result;
    if (CFEqual((CFTypeRef)result, CFSTR("ContinuityUnlock"))
      || CFEqual(v1, CFSTR("AppleTV"))
      || CFEqual(v1, CFSTR("HomeKit"))
      || CFEqual(v1, CFSTR("AccessoryPairing"))
      || CFEqual(v1, CFSTR("PCS-CloudKit"))
      || CFEqual(v1, CFSTR("PCS-Escrow"))
      || CFEqual(v1, CFSTR("PCS-FDE"))
      || CFEqual(v1, CFSTR("PCS-Feldspar"))
      || CFEqual(v1, CFSTR("PCS-Maildrop"))
      || CFEqual(v1, CFSTR("PCS-MasterKey"))
      || CFEqual(v1, CFSTR("PCS-Notes"))
      || CFEqual(v1, CFSTR("PCS-Photos"))
      || CFEqual(v1, CFSTR("PCS-Sharing"))
      || CFEqual(v1, CFSTR("PCS-Backup"))
      || CFEqual(v1, CFSTR("PCS-iCloudDrive"))
      || CFEqual(v1, CFSTR("PCS-iMessage"))
      || CFEqual(v1, CFSTR("NanoRegistry"))
      || CFEqual(v1, CFSTR("WatchMigration")))
    {
      return 1;
    }
    else
    {
      if (!CFEqual(v1, CFSTR("Engram"))
        && !CFEqual(v1, CFSTR("Manatee"))
        && !CFEqual(v1, CFSTR("AutoUnlock"))
        && !CFEqual(v1, CFSTR("Health"))
        && !CFEqual(v1, CFSTR("ApplePay"))
        && !CFEqual(v1, CFSTR("Home"))
        && !CFEqual(v1, CFSTR("LimitedPeersAllowed"))
        && !CFEqual(v1, CFSTR("MFi"))
        && !CFEqual(v1, CFSTR("Mail"))
        && !CFEqual(v1, CFSTR("Contacts"))
        && !CFEqual(v1, CFSTR("Photos")))
      {
        CFEqual(v1, CFSTR("Groups"));
      }
      return 0;
    }
  }
  return result;
}

unint64_t SOSViewHintInCKKSSystem(unint64_t result)
{
  const void *v1;

  if (result)
  {
    v1 = (const void *)result;
    return CFEqual((CFTypeRef)result, CFSTR("Engram"))
        || CFEqual(v1, CFSTR("Manatee"))
        || CFEqual(v1, CFSTR("AutoUnlock"))
        || CFEqual(v1, CFSTR("Health"))
        || CFEqual(v1, CFSTR("ApplePay"))
        || CFEqual(v1, CFSTR("Home"))
        || CFEqual(v1, CFSTR("LimitedPeersAllowed"))
        || CFEqual(v1, CFSTR("MFi"))
        || CFEqual(v1, CFSTR("Mail"))
        || CFEqual(v1, CFSTR("Contacts"))
        || CFEqual(v1, CFSTR("Photos"))
        || CFEqual(v1, CFSTR("Groups")) != 0;
  }
  return result;
}

uint64_t SOSViewsGetV0ViewSet()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __SOSViewsGetV0ViewSet_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSViewsGetV0ViewSet_sSOSViewsGetV0ViewSetSingleton;
  if (SOSViewsGetV0ViewSet_sSOSViewsGetV0ViewSetOnce != -1)
    dispatch_once(&SOSViewsGetV0ViewSet_sSOSViewsGetV0ViewSetOnce, block);
  return SOSViewsGetV0ViewSet_sSOSViewsGetV0ViewSetSingleton;
}

uint64_t SOSViewsGetV0SubviewSet()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __SOSViewsGetV0SubviewSet_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSViewsGetV0SubviewSet_sSOSViewsGetV0SubviewSetSingleton;
  if (SOSViewsGetV0SubviewSet_sSOSViewsGetV0SubviewSetOnce != -1)
    dispatch_once(&SOSViewsGetV0SubviewSet_sSOSViewsGetV0SubviewSetOnce, block);
  return SOSViewsGetV0SubviewSet_sSOSViewsGetV0SubviewSetSingleton;
}

uint64_t SOSViewsGetUserVisibleSet()
{
  if (SOSViewsGetUserVisibleSet_onceToken != -1)
    dispatch_once(&SOSViewsGetUserVisibleSet_onceToken, &__block_literal_global_6234);
  return SOSViewsGetUserVisibleSet_subViewSet;
}

uint64_t SOSViewsGetV0BackupViewSet()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __SOSViewsGetV0BackupViewSet_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSViewsGetV0BackupViewSet_sSOSViewsGetV0BackupViewSetSingleton;
  if (SOSViewsGetV0BackupViewSet_sSOSViewsGetV0BackupViewSetOnce != -1)
    dispatch_once(&SOSViewsGetV0BackupViewSet_sSOSViewsGetV0BackupViewSetOnce, block);
  return SOSViewsGetV0BackupViewSet_sSOSViewsGetV0BackupViewSetSingleton;
}

uint64_t SOSViewsGetV0BackupBagViewSet()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __SOSViewsGetV0BackupBagViewSet_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &SOSViewsGetV0BackupBagViewSet_sSOSViewsGetV0BackupBagViewSetSingleton;
  if (SOSViewsGetV0BackupBagViewSet_sSOSViewsGetV0BackupBagViewSetOnce != -1)
    dispatch_once(&SOSViewsGetV0BackupBagViewSet_sSOSViewsGetV0BackupBagViewSetOnce, block);
  return SOSViewsGetV0BackupBagViewSet_sSOSViewsGetV0BackupBagViewSetSingleton;
}

BOOL SOSViewsIsV0Subview(const void *a1)
{
  const __CFSet *V0SubviewSet;

  V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet();
  return CFSetContainsValue(V0SubviewSet, a1) != 0;
}

void SOSViewsSetTestViewsSet(CFTypeRef cf)
{
  const void *v2;
  const void *v3;
  _QWORD context[5];

  v2 = (const void *)sTestViewSet;
  if (sTestViewSet)
  {
    sTestViewSet = 0;
    CFRelease(v2);
  }
  if (cf)
    sTestViewSet = (uint64_t)CFRetain(cf);
  v3 = (const void *)sosAllViews;
  if (sosAllViews)
  {
    sosAllViews = 0;
    CFRelease(v3);
  }
  sosAllViews = (uint64_t)SOSViewCopyViewSet(0);
  CFSetAddValue((CFMutableSetRef)sosAllViews, CFSTR("KeychainV0"));
  if (sTestViewSet)
  {
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 3221225472;
    context[2] = __CFSetUnion_block_invoke_6232;
    context[3] = &__block_descriptor_40_e10_v16__0r_v8l;
    context[4] = sosAllViews;
    CFSetApplyFunction((CFSetRef)sTestViewSet, (CFSetApplierFunction)apply_block_1_6233, context);
  }
}

uint64_t SOSViewsGetAllCurrent()
{
  if (SOSViewsGetAllCurrent_dot != -1)
    dispatch_once(&SOSViewsGetAllCurrent_dot, &__block_literal_global_90_6235);
  return sosAllViews;
}

const __CFSet *SOSViewBitmaskFromSet(CFSetRef theSet)
{
  const __CFSet *v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = theSet;
  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  if (theSet)
  {
    if (SOSViewsGetBitmasks_once != -1)
      dispatch_once(&SOSViewsGetBitmasks_once, &__block_literal_global_107_6236);
    if (SOSViewsGetBitmasks_masks)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 3221225472;
      v3[2] = __SOSViewBitmaskFromSet_block_invoke;
      v3[3] = &unk_1E1FD2620;
      v3[4] = &v4;
      v3[5] = SOSViewsGetBitmasks_masks;
      CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_6233, v3);
    }
    v1 = (const __CFSet *)v5[3];
  }
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_18A9BE518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18A9BE798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

const __CFSet *SOSPeerInfoViewBitMask(uint64_t a1)
{
  const __CFSet *result;
  const __CFSet *v2;
  const __CFSet *v3;

  result = SOSPeerInfoCopyEnabledViews(a1);
  if (result)
  {
    v2 = result;
    v3 = SOSViewBitmaskFromSet(result);
    CFRelease(v2);
    return v3;
  }
  return result;
}

CFMutableSetRef SOSPeerInfoCopyEnabledViews(uint64_t a1)
{
  const __CFSet *V0ViewSet;
  CFIndex Count;
  const __CFSet *v3;
  CFMutableSetRef result;
  NSObject *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (*(uint64_t *)(a1 + 56) > 1)
  {
    result = SOSPeerInfoV2DictionaryCopySet(a1, (const void *)sViewsKey);
    if (!result)
    {
      secLogObjForScope("SecError");
      v6 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_QWORD *)(a1 + 40);
        v8 = 138412290;
        v9 = v7;
        _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "%@ v2 peer has no views", (uint8_t *)&v8, 0xCu);
      }

      return CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
    }
  }
  else
  {
    V0ViewSet = (const __CFSet *)SOSViewsGetV0ViewSet();
    Count = CFSetGetCount(V0ViewSet);
    v3 = (const __CFSet *)SOSViewsGetV0ViewSet();
    return CFSetCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, v3);
  }
  return result;
}

CFMutableSetRef SOSViewCreateSetFromBitmask(uint64_t a1)
{
  const __CFDictionary *v2;
  CFMutableSetRef Mutable;
  _QWORD v5[6];

  if (SOSViewsGetBitmasks_once != -1)
    dispatch_once(&SOSViewsGetBitmasks_once, &__block_literal_global_107_6236);
  v2 = (const __CFDictionary *)SOSViewsGetBitmasks_masks;
  if (!SOSViewsGetBitmasks_masks)
    return 0;
  Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SOSViewCreateSetFromBitmask_block_invoke;
  v5[3] = &__block_descriptor_48_e15_v24__0r_v8r_v16l;
  v5[4] = a1;
  v5[5] = Mutable;
  CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)apply_block_2_6246, v5);
  return Mutable;
}

uint64_t apply_block_2_6246(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

BOOL SOSPeerInfoSupportsCKKSForAll(uint64_t a1)
{
  const __CFBoolean *v1;
  const __CFBoolean *v2;
  _BOOL8 v3;

  if (!a1)
    return 0;
  v1 = (const __CFBoolean *)SOSPeerInfoV2DictionaryCopyBoolean(a1, (const void *)sCKKSForAll);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = CFBooleanGetValue(v1) != 0;
  CFRelease(v2);
  return v3;
}

void SOSPeerInfoSetSupportsCKKSForAll(uint64_t a1, int a2)
{
  const void **v2;

  v2 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v2 = (const void **)MEMORY[0x1E0C9AE40];
  SOSPeerInfoV2DictionarySetValue(a1, (const void *)sCKKSForAll, *v2);
}

const char *SOSViewsXlateAction(int a1)
{
  if ((a1 - 1) > 2)
    return "unknownViewAction";
  else
    return off_1E1FD26F0[a1 - 1];
}

void SOSViewsForEachDefaultEnabledViewName(void *a1)
{
  id v1;
  const __CFSet *v2;
  id v3;
  _QWORD context[4];
  id v5;

  v1 = a1;
  v2 = SOSViewCopyViewSet(1u);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 3221225472;
  context[2] = __SOSViewsForEachDefaultEnabledViewName_block_invoke;
  context[3] = &unk_1E1FD4C58;
  v3 = v1;
  v5 = v3;
  CFSetApplyFunction(v2, (CFSetApplierFunction)apply_block_1_6233, context);
  if (v2)
    CFRelease(v2);

}

const __CFSet *SOSPeerInfoIsEnabledView(uint64_t a1, const void *a2)
{
  const __CFSet *V0ViewSet;

  if (*(uint64_t *)(a1 + 56) > 1)
    return SOSPeerInfoV2DictionaryHasSetContaining(a1, (const void *)sViewsKey, a2);
  V0ViewSet = (const __CFSet *)SOSViewsGetV0ViewSet();
  return (const __CFSet *)(CFSetContainsValue(V0ViewSet, a2) != 0);
}

void SOSPeerInfoWithEnabledViewSet(uint64_t a1, void (**a2)(_QWORD, _QWORD))
{
  void (**v2)(_QWORD, _QWORD);
  uint64_t V0ViewSet;

  if (*(uint64_t *)(a1 + 56) > 1)
  {
    SOSPeerInfoV2DictionaryWithSet(a1, (const void *)sViewsKey, a2);
  }
  else
  {
    v2 = a2;
    V0ViewSet = SOSViewsGetV0ViewSet();
    a2[2](v2, V0ViewSet);
  }

}

uint64_t SOSPeerInfoGetPermittedViews()
{
  if (SOSViewsGetAllCurrent_dot != -1)
    dispatch_once(&SOSViewsGetAllCurrent_dot, &__block_literal_global_90_6235);
  return sosAllViews;
}

uint64_t SOSViewsEnable(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  CFMutableSetRef v6;
  __CFSet *v7;
  uint64_t v8;
  NSObject *v10;
  CFTypeRef v11;
  uint8_t buf[4];
  const void *v13;
  __int16 v14;
  CFTypeRef v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v6 = SOSPeerInfoCopyEnabledViews(a1);
  if (v6)
  {
    v7 = v6;
    if (SOSViewsRequireIsKnownView((uint64_t)a2, a3))
    {
      if (SOSPeerInfoViewIsValid(a2))
      {
        CFSetAddValue(v7, a2);
        SOSPeerInfoV2DictionarySetValue(a1, (const void *)sViewsKey, v7);
        CFRelease(v7);
        return 1;
      }
      v8 = 3;
      SOSCreateErrorWithFormat(1026, 0, a3, 0, CFSTR("Peer is invalid for this view(%@) (ViewResultCode=%d)"), a2, 3);
    }
    else
    {
      v8 = 4;
    }
    CFRelease(v7);
  }
  else
  {
    SOSCreateErrorWithFormat(1024, 0, a3, 0, CFSTR("%@"), CFSTR("Failed to get memory for views in PeerInfo"));
    v8 = 0;
  }
  secLogObjForScope("views");
  v10 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    if (a3)
      v11 = *a3;
    else
      v11 = 0;
    *(_DWORD *)buf = 138412546;
    v13 = a2;
    v14 = 2112;
    v15 = v11;
    _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, "Failed to enable view(%@): %@", buf, 0x16u);
  }

  return v8;
}

uint64_t SOSViewsRequireIsKnownView(uint64_t a1, CFTypeRef *a2)
{
  uint64_t IsKnownView;

  IsKnownView = SOSViewsIsKnownView(a1);
  if ((IsKnownView & 1) == 0)
    SOSCreateErrorWithFormat(1026, 0, a2, 0, CFSTR("Unknown view(%@) (ViewResultCode=%d)"), a1, 4);
  return IsKnownView;
}

BOOL SOSPeerInfoViewIsValid(const void *a1)
{
  const __CFSet *V0SubviewSet;

  V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet();
  return !CFSetContainsValue(V0SubviewSet, a1) || (SOSVisibleKeychainNotAllowed() & 1) == 0;
}

uint64_t SOSViewsIsKnownView(uint64_t value)
{
  const void *v1;
  NSObject *v2;
  uint8_t v3[16];

  if (value)
  {
    v1 = (const void *)value;
    if (SOSViewsGetAllCurrent_dot != -1)
      dispatch_once(&SOSViewsGetAllCurrent_dot, &__block_literal_global_90_6235);
    if (CFSetContainsValue((CFSetRef)sosAllViews, v1))
    {
      return 1;
    }
    else
    {
      secLogObjForScope("views");
      v2 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v3 = 0;
        _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "Not a known view", v3, 2u);
      }

      return 0;
    }
  }
  return value;
}

uint64_t SOSViewSetEnable(uint64_t a1, const __CFSet *a2)
{
  CFMutableSetRef v4;
  CFMutableSetRef v5;
  uint64_t v6;
  NSObject *v8;
  _QWORD context[7];
  uint8_t buf[16];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v14 = 0;
  v4 = SOSPeerInfoCopyEnabledViews(a1);
  v5 = v4;
  if (v4)
  {
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 3221225472;
    context[2] = __SOSViewSetEnable_block_invoke;
    context[3] = &unk_1E1FD2668;
    context[5] = a1;
    context[6] = v4;
    context[4] = &v11;
    CFSetApplyFunction(a2, (CFSetApplierFunction)apply_block_1_6233, context);
    if (*((_BYTE *)v12 + 24))
      SOSPeerInfoV2DictionarySetValue(a1, (const void *)sViewsKey, v5);
    CFRelease(v5);
  }
  else
  {
    secLogObjForScope("views");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "failed to copy enabled views", buf, 2u);
    }

  }
  v6 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  return v6;
}

void sub_18A9BF140(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t SOSViewsDisable(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  __CFSet *v6;
  NSObject *v8;
  CFTypeRef v9;
  uint8_t buf[4];
  const void *v11;
  __int16 v12;
  CFTypeRef v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v6 = SOSPeerInfoCopyEnabledViews(a1);
  if (v6)
  {
    if (SOSViewsRequireIsKnownView((uint64_t)a2, a3))
    {
      CFSetRemoveValue(v6, a2);
      SOSPeerInfoV2DictionarySetValue(a1, (const void *)sViewsKey, v6);
      CFRelease(v6);
      return 2;
    }
    CFRelease(v6);
    v6 = (__CFSet *)4;
  }
  else
  {
    SOSCreateErrorWithFormat(1024, 0, a3, 0, CFSTR("%@"), CFSTR("Failed to get memory for views in PeerInfo"));
  }
  secLogObjForScope("views");
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if (a3)
      v9 = *a3;
    else
      v9 = 0;
    *(_DWORD *)buf = 138412546;
    v11 = a2;
    v12 = 2112;
    v13 = v9;
    _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "Failed to disable view(%@): %@", buf, 0x16u);
  }

  return (uint64_t)v6;
}

uint64_t SOSViewSetDisable(uint64_t a1, const __CFSet *a2)
{
  CFMutableSetRef v4;
  CFMutableSetRef v5;
  uint64_t v6;
  NSObject *v8;
  _QWORD v9[6];
  uint8_t buf[16];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v14 = 0;
  v4 = SOSPeerInfoCopyEnabledViews(a1);
  v5 = v4;
  if (v4)
  {
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = __SOSViewSetDisable_block_invoke;
    v9[3] = &unk_1E1FD2620;
    v9[4] = &v11;
    v9[5] = v4;
    CFSetApplyFunction(a2, (CFSetApplierFunction)apply_block_1_6233, v9);
    if (*((_BYTE *)v12 + 24))
      SOSPeerInfoV2DictionarySetValue(a1, (const void *)sViewsKey, v5);
    CFRelease(v5);
  }
  else
  {
    secLogObjForScope("views");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "failed to copy enabled views", buf, 2u);
    }

  }
  v6 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  return v6;
}

void sub_18A9BF4F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SOSViewsQuery(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  const __CFSet *v6;
  const __CFSet *v7;
  const __CFSet *V0SubviewSet;
  uint64_t v9;
  NSObject *v11;
  CFTypeRef v12;
  int v13;
  const void *v14;
  __int16 v15;
  CFTypeRef v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (SOSViewsRequireIsKnownView((uint64_t)a2, a3))
  {
    v6 = SOSPeerInfoCopyEnabledViews(a1);
    if (v6)
    {
      v7 = v6;
      if (CFSetContainsValue(v6, CFSTR("KeychainV0"))
        && (V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet(), CFSetContainsValue(V0SubviewSet, a2)))
      {
        v9 = 1;
      }
      else if (CFSetContainsValue(v7, a2))
      {
        v9 = 1;
      }
      else
      {
        v9 = 2;
      }
      CFRelease(v7);
    }
    else
    {
      return 2;
    }
  }
  else
  {
    secLogObjForScope("views");
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if (a3)
        v12 = *a3;
      else
        v12 = 0;
      v13 = 138412546;
      v14 = a2;
      v15 = 2112;
      v16 = v12;
      _os_log_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEFAULT, "Failed to query view(%@): %@", (uint8_t *)&v13, 0x16u);
    }

    return 4;
  }
  return v9;
}

BOOL SOSPeerInfoIsViewPermitted(uint64_t a1, const void *a2)
{
  const __CFSet *V0SubviewSet;

  V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet();
  return (!CFSetContainsValue(V0SubviewSet, a2) || (SOSVisibleKeychainNotAllowed() & 1) == 0)
      && SOSViewsQuery(a1, a2, 0) < 3;
}

BOOL SOSViewSetIntersectsV0(const __CFSet *a1)
{
  uint64_t V0ViewSet;
  _BOOL8 v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;

  V0ViewSet = SOSViewsGetV0ViewSet();
  v3 = 0;
  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 1;
  if (a1 && V0ViewSet)
  {
    v5[0] = MEMORY[0x1E0C809B0];
    v5[1] = 3221225472;
    v5[2] = __CFSetIntersectionIsEmpty_block_invoke;
    v5[3] = &unk_1E1FD2620;
    v5[4] = &v6;
    v5[5] = V0ViewSet;
    CFSetApplyFunction(a1, (CFSetApplierFunction)apply_block_1_6233, v5);
    v3 = *((_BYTE *)v7 + 24) == 0;
  }
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_18A9BF87C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL SOSPeerInfoV0ViewsEnabled(uint64_t a1)
{
  const __CFSet *v1;
  _BOOL8 v2;

  if (!a1)
    return 0;
  v1 = SOSPeerInfoCopyEnabledViews(a1);
  v2 = SOSViewSetIntersectsV0(v1);
  if (v1)
    CFRelease(v1);
  return v2;
}

uint64_t SOSPeerInfoHasUserVisibleViewsEnabled(uint64_t result)
{
  const __CFSet *v1;
  _BOOL8 v2;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  if (result)
  {
    v1 = SOSPeerInfoCopyEnabledViews(result);
    if (SOSViewsGetUserVisibleSet_onceToken != -1)
      dispatch_once(&SOSViewsGetUserVisibleSet_onceToken, &__block_literal_global_6234);
    v4 = 0;
    v5 = &v4;
    v6 = 0x2020000000;
    v7 = 1;
    if (v1 && SOSViewsGetUserVisibleSet_subViewSet)
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 3221225472;
      v3[2] = __CFSetIntersectionIsEmpty_block_invoke;
      v3[3] = &unk_1E1FD2620;
      v3[4] = &v4;
      v3[5] = SOSViewsGetUserVisibleSet_subViewSet;
      CFSetApplyFunction(v1, (CFSetApplierFunction)apply_block_1_6233, v3);
      v2 = *((_BYTE *)v5 + 24) == 0;
      _Block_object_dispose(&v4, 8);
    }
    else
    {
      _Block_object_dispose(&v4, 8);
      v2 = 0;
      result = 0;
      if (!v1)
        return result;
    }
    CFRelease(v1);
    return v2;
  }
  return result;
}

void sub_18A9BFA24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id CreateXPCObjectWithCFSetRef(const __CFSet *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v10;
  size_t v11;
  void *v12;
  void *v13;
  xpc_object_t v14;
  char v16;

  if (!a1)
  {
    SecCFCreateErrorWithFormat(2, (const __CFString *)sSecXPCErrorDomain, 0, a2, a5, CFSTR("Unexpected Null Set to encode"), a7, a8, v16);
LABEL_7:
    v14 = 0;
    return v14;
  }
  v10 = der_sizeof_set(a1, (uint64_t)a2);
  if (!v10)
    goto LABEL_7;
  v11 = v10;
  v12 = malloc_type_malloc(v10, 0x86C9D424uLL);
  if (!v12)
    goto LABEL_7;
  v13 = v12;
  der_encode_set_repair(a1, a2, 0);
  v14 = xpc_data_create(v13, v11);
  free(v13);
  return v14;
}

void CFSecRecoveryKeyDestroy(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = 0;
    CFRelease(v2);
  }
}

CFStringRef CFSecRecoveryKeyCopyFormatDescription(uint64_t a1)
{
  return CFStringCreateWithFormat(0, 0, CFSTR("<SecRecoveryKey: %p>"), a1);
}

CFStringRef CFSecRecoveryKeyCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();
  return CFStringCreateWithFormat(0, 0, CFSTR("<SecRecoveryKey: %p>"), a1);
}

__CFString *SecRKCreateRecoveryKeyString(_QWORD *a1)
{
  const __CFString *v2;
  __CFString *v3;
  id v5;
  id v6;

  v6 = 0;
  v2 = SecPasswordGenerate(4, (const __CFDictionary **)&v6, 0);
  if (v2)
  {
    v3 = (__CFString *)v2;
    if (ValidateRecoveryKey(v2, a1))
      return v3;
    v5 = v3;
    goto LABEL_9;
  }
  v5 = v6;
  if (a1)
  {
    *a1 = v6;
    return (__CFString *)0;
  }
  if (v6)
  {
    v6 = 0;
LABEL_9:
    CFRelease(v5);
    v5 = 0;
  }
  return (__CFString *)v5;
}

BOOL ValidateRecoveryKey(CFStringRef theString, _QWORD *a2)
{
  _BOOL8 v3;
  id v4;
  id v6;

  v6 = 0;
  v3 = SecPasswordValidatePasswordFormat(4, theString, (__CFString **)&v6);
  if (!v3)
  {
    v4 = v6;
    if (a2)
    {
      *a2 = v6;
    }
    else if (v6)
    {
      v6 = 0;
      CFRelease(v4);
    }
  }
  return v3;
}

_QWORD *SecRKCreateRecoveryKey(void *a1)
{
  return SecRKCreateRecoveryKeyWithError(a1, 0);
}

_QWORD *SecRKCreateRecoveryKeyWithError(void *a1, _QWORD *a2)
{
  __CFString *v3;
  _QWORD *Instance;
  CFDataRef ExternalRepresentation;
  _QWORD block[5];

  v3 = a1;
  if (!ValidateRecoveryKey(v3, a2))
    goto LABEL_9;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 3221225472;
  block[2] = __CFSecRecoveryKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_40_e5_v8__0l;
  block[4] = &CFSecRecoveryKeyGetTypeID_sCFSecRecoveryKeyGetTypeIDSingleton;
  if (CFSecRecoveryKeyGetTypeID_sCFSecRecoveryKeyGetTypeIDOnce != -1)
    dispatch_once(&CFSecRecoveryKeyGetTypeID_sCFSecRecoveryKeyGetTypeIDOnce, block);
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  if (Instance)
  {
    if (SecCFAllocatorZeroize_sOnce != -1)
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
    ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v3, 0x8000100u, 0);
    Instance[2] = ExternalRepresentation;
    if (!ExternalRepresentation)
    {
      CFRelease(Instance);
LABEL_9:
      Instance = 0;
    }
  }

  return Instance;
}

__CFString *SecRKCopyAccountRecoveryPassword(uint64_t a1)
{
  __CFData *v1;
  const __CFData *v2;
  size_t v3;
  UInt8 *v4;
  UInt8 *v5;
  unsigned __int8 *BytePtr;
  CFIndex Length;
  __CFString *v8;
  int v10;

  v1 = SecRKCreateDerivedSecret(a1, 32);
  if (!v1)
    return (__CFString *)0;
  v2 = v1;
  CFDataGetBytePtr(v1);
  v3 = (2 * (((unint64_t)(CFDataGetLength(v2) + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  if (v3 >= 0x400)
    __security_simulatecrash(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
  v4 = (UInt8 *)malloc_type_malloc(v3, 0x2337017FuLL);
  if (v4)
  {
    v5 = v4;
    BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v2);
    Length = CFDataGetLength(v2);
    SecBase64Encode_(BytePtr, Length, v5, v3, 0, &v10);
    if (SecCFAllocatorZeroize_sOnce != -1)
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
    v8 = (__CFString *)CFStringCreateWithBytes((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v5, v3, 0x8000100u, 0);
    cc_clear();
    free(v5);
  }
  else
  {
    v8 = 0;
  }
  CFRelease(v2);
  return v8;
}

__CFData *SecRKCreateDerivedSecret(uint64_t a1, CFIndex a2)
{
  __CFData *Mutable;

  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  CFDataSetLength(Mutable, a2);
  if (Mutable)
  {
    ccsha256_di();
    CFDataGetLength(*(CFDataRef *)(a1 + 16));
    CFDataGetBytePtr(*(CFDataRef *)(a1 + 16));
    CFDataGetLength(Mutable);
    CFDataGetMutableBytePtr(Mutable);
    if (cchkdf())
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

id SecRKCopyAccountRecoveryVerifier(void *a1, _QWORD *a2)
{
  id v3;
  BOOL v4;
  id v6;
  void *v7;
  id v8;
  void *v9;
  void *v10;
  __CFData *v11;
  __CFData *v12;
  void *v13;
  id v14;
  id v16;
  _QWORD v17[5];
  _QWORD v18[6];

  v18[5] = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v16 = 0;
  if (connectAppleIDFrameworkSymbols_onceToken != -1)
    dispatch_once(&connectAppleIDFrameworkSymbols_onceToken, &__block_literal_global_6304);
  if (connectAppleIDFrameworkSymbols_framework)
    v4 = localProtocolSRPGROUP == 0;
  else
    v4 = 1;
  if (v4 || localAppleIDauthSupportCreateVerifierPtr == 0)
  {
    SOSCreateErrorWithFormat(1041, 0, (CFTypeRef *)&v16, 0, CFSTR("%@"), CFSTR("Recovery Key Creation Not Supported on this platform"));
    v6 = 0;
    if (a2)
      *a2 = v16;
  }
  else
  {
    v7 = (void *)CFDataCreateWithRandomBytes(0x20uLL);
    v8 = (id)localProtocolSRPGROUP;
    v9 = (void *)localAppleIDauthSupportCreateVerifierPtr(localProtocolSRPGROUP, CFSTR("foo"), v7, &unk_1E1FFEF38, v3, &v16);
    SecRKCreateRecoveryKeyWithError(v3, 0);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = SecRKCreateDerivedSecret((uint64_t)v10, 32);
    v12 = v11;
    if (v9 && v11)
    {
      v17[0] = CFSTR("s");
      v17[1] = CFSTR("i");
      v18[0] = v7;
      v18[1] = &unk_1E1FFEF38;
      v17[2] = CFSTR("p");
      v17[3] = CFSTR("v");
      v18[2] = v8;
      v18[3] = v9;
      v17[4] = CFSTR("mkid");
      v18[4] = v11;
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v18, v17, 5);
      v13 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v13 = 0;
      if (a2 && v16)
      {
        v14 = objc_retainAutorelease(v16);
        v13 = 0;
        *a2 = v14;
      }
    }
    v6 = v13;

  }
  return v6;
}

void *__connectAppleIDFrameworkSymbols_block_invoke()
{
  void *result;
  uint64_t *v1;
  uint64_t v2;

  localAppleIDauthSupportCreateVerifierPtr = 0;
  localProtocolSRPGROUP = 0;
  result = dlopen("/System/Library/PrivateFrameworks/AppleIDAuthSupport.framework/AppleIDAuthSupport", 2);
  connectAppleIDFrameworkSymbols_framework = (uint64_t)result;
  if (result)
  {
    v1 = (uint64_t *)dlsym(result, "kAppleIDAuthSupportProtocolSRPGROUP2048SHA256PBKDF");
    if (v1)
      v2 = *v1;
    else
      v2 = 0;
    localProtocolSRPGROUP = v2;
    result = dlsym((void *)connectAppleIDFrameworkSymbols_framework, "AppleIDAuthSupportCreateVerifier");
    localAppleIDauthSupportCreateVerifierPtr = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))result;
  }
  return result;
}

__CFData *SecRKCopyBackupFullKey(uint64_t a1)
{
  return RKBackupCreateECKey(a1, 1);
}

__CFData *RKBackupCreateECKey(uint64_t a1, char a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  __CFData *v8;
  const __CFData *v9;
  CFIndex v10;
  __CFData *Mutable;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v4 = MEMORY[0x18D76FFBC]();
  MEMORY[0x1E0C80A78](v4);
  v6 = 0;
  do
  {
    v7 = (_QWORD *)((char *)&v13[v6 / 8] - v5);
    *v7 = 0xAAAAAAAAAAAAAAAALL;
    v7[1] = 0xAAAAAAAAAAAAAAAALL;
    v6 += 16;
  }
  while (v5 != v6);
  v8 = SecRKCreateDerivedSecret(a1, 128);
  if (v8)
  {
    v9 = v8;
    CFDataGetLength(v8);
    CFDataGetBytePtr(v9);
    ccrng();
    if (ccec_generate_key_deterministic())
    {
      Mutable = 0;
    }
    else
    {
      v10 = (unint64_t)(cczp_bitlen() + 7) >> 3 << a2;
      if (SecCFAllocatorZeroize_sOnce != -1)
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
      Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
      CFDataSetLength(Mutable, v10);
      if (Mutable)
      {
        CFDataGetMutableBytePtr(Mutable);
        ccec_compact_export();
      }
    }
    CFRelease(v9);
  }
  else
  {
    Mutable = 0;
  }
  return Mutable;
}

__CFData *SecRKCopyBackupPublicKey(uint64_t a1)
{
  return RKBackupCreateECKey(a1, 0);
}

uint64_t SecRKRegisterBackupPublicKey(uint64_t a1, CFTypeRef *a2)
{
  __CFData *ECKey;
  __CFData *v4;
  uint64_t v5;

  ECKey = RKBackupCreateECKey(a1, 0);
  if (ECKey)
  {
    v4 = ECKey;
    v5 = SOSCCRegisterRecoveryPublicKey((uint64_t)ECKey, a2);
    CFRelease(v4);
    return v5;
  }
  else
  {
    SOSCreateErrorWithFormat(1034, 0, a2, 0, CFSTR("%@"), CFSTR("Failed to create key from rk"));
    return 0;
  }
}

const SecAsn1Template *NSS_TimeChooser(uint64_t a1, int a2, _BYTE *a3, uint64_t a4, uint64_t a5)
{
  int v5;
  const SecAsn1Template *result;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  if (a2)
  {
    v5 = *(unsigned __int8 *)(a5 + 16);
  }
  else
  {
    if (!a4)
    {
      v5 = 0;
      goto LABEL_9;
    }
    v5 = *a3 & 0x1F;
    *(_BYTE *)(a5 + 16) = v5;
  }
  if (v5 == 24)
    return kSecAsn1GeneralizedTimeTemplate;
LABEL_9:
  v7 = (uint64_t *)&off_1E1FD29C0;
  result = kSecAsn1GeneralizedTimeTemplate;
  while (1)
  {
    v8 = *v7;
    if (!*v7)
      break;
    v9 = *((unsigned __int8 *)v7 - 8);
    v7 += 2;
    if (v5 == v9)
      return (const SecAsn1Template *)v8;
  }
  return result;
}

const SecAsn1Template *NSS_ATVChooser(uint64_t a1, int a2, _BYTE *a3, uint64_t a4, uint64_t a5)
{
  int v5;
  const SecAsn1Template *result;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  if (a2)
  {
    v5 = *(unsigned __int8 *)(a5 + 16);
  }
  else
  {
    if (!a4)
    {
      v5 = 0;
      goto LABEL_9;
    }
    v5 = *a3 & 0x1F;
    *(_BYTE *)(a5 + 16) = v5;
  }
  if (v5 == 19)
    return kSecAsn1PrintableStringTemplate;
LABEL_9:
  v7 = (uint64_t *)&off_1E1FD2F60;
  result = kSecAsn1PrintableStringTemplate;
  while (1)
  {
    v8 = *v7;
    if (!*v7)
      break;
    v9 = *((unsigned __int8 *)v7 - 8);
    v7 += 2;
    if (v5 == v9)
      return (const SecAsn1Template *)v8;
  }
  return result;
}

void *NSS_genNameChooser(uint64_t a1, int a2, _BYTE *a3, uint64_t a4, uint64_t a5)
{
  int v5;
  uint64_t *v6;
  void *result;
  uint64_t v8;
  int v9;

  if (a2)
  {
    v5 = *(unsigned __int8 *)(a5 + 16);
    if (!*(_BYTE *)(a5 + 16))
      return &kSecAsn1OtherNameTemplate;
  }
  else
  {
    if (!a4)
      return &kSecAsn1OtherNameTemplate;
    v5 = *a3 & 0x1F;
    *(_BYTE *)(a5 + 16) = v5;
    if (!v5)
      return &kSecAsn1OtherNameTemplate;
  }
  v6 = (uint64_t *)&off_1E1FD2FD0;
  result = &kSecAsn1OtherNameTemplate;
  while (1)
  {
    v8 = *v6;
    if (!*v6)
      break;
    v9 = *((unsigned __int8 *)v6 - 8);
    v6 += 2;
    if (v5 == v9)
      return (void *)v8;
  }
  return result;
}

uint64_t SecAsn1TaggedTemplateChooser(uint64_t a1, int a2, _BYTE *a3, uint64_t a4, uint64_t a5, unsigned __int8 *a6)
{
  int v6;
  uint64_t result;
  uint64_t *i;
  uint64_t v9;
  int v10;

  if (a2)
  {
    v6 = *(unsigned __int8 *)(a5 + 16);
  }
  else if (a4)
  {
    v6 = *a3 & 0x1F;
    *(_BYTE *)(a5 + 16) = v6;
  }
  else
  {
    v6 = 0;
  }
  result = *((_QWORD *)a6 + 1);
  if (result && v6 != *a6)
  {
    for (i = (uint64_t *)(a6 + 24); ; i += 2)
    {
      v9 = *i;
      if (!*i)
        break;
      v10 = *((unsigned __int8 *)i - 8);
      if (v6 == v10)
        return v9;
    }
  }
  return result;
}

const SecAsn1Template *NSS_P7_ContentInfoChooser(uint64_t a1, int a2)
{
  int v4;
  const SecAsn1Template *v5;

  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_Data))
  {
    v4 = 1;
    v5 = kSecAsn1PointerToOctetStringTemplate;
    goto LABEL_10;
  }
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_EncryptedData))
  {
    v4 = 6;
    v5 = (const SecAsn1Template *)&NSS_P7_PtrToEncryptedDataTemplate;
    goto LABEL_10;
  }
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_SignedData))
  {
    v4 = 2;
LABEL_9:
    v5 = kSecAsn1PointerToAnyTemplate;
    goto LABEL_10;
  }
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_EnvelopedData))
  {
    v4 = 3;
    goto LABEL_9;
  }
  v5 = kSecAsn1PointerToAnyTemplate;
  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_SignedAndEnvelopedData))
  {
    v4 = 4;
  }
  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS7_DigestedData))
  {
    v4 = 5;
  }
  else
  {
    v5 = 0;
    v4 = 0;
  }
LABEL_10:
  if (!a2)
    *(_DWORD *)(a1 + 16) = v4;
  return v5;
}

char *PL_ArenaGrow(uint64_t a1, char *a2, unsigned int a3, unsigned int a4)
{
  _QWORD *v6;
  uint64_t v7;
  unsigned int v8;
  int v11;
  unsigned int v12;
  char *v13;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;

  if (a3 > 0x7FFFFFFE || a4 > 0x7FFFFFFE)
    return 0;
  v6 = (_QWORD *)a1;
  v7 = *(_QWORD *)(a1 + 48);
  v8 = (v7 + a3) & ~(_DWORD)v7;
  if (v8 > 0x7FFFFFFE)
    return 0;
  v11 = v8 + a4;
  if (v8 + a4 <= 2 * v8)
    v11 = 2 * v8;
  v12 = (v7 + v11) & ~(_DWORD)v7;
  if (v12 > 0x7FFFFFFE)
    return 0;
  v15 = *(_QWORD *)(a1 + 32);
  v13 = *(char **)(v15 + 24);
  if ((unint64_t)v12 <= *(_QWORD *)(v15 + 16) - (_QWORD)v13)
  {
    *(_QWORD *)(v15 + 24) = &v13[v12];
    if (!v13)
      return v13;
  }
  else
  {
    v13 = (char *)PL_ArenaAllocate(a1, v12);
    if (!v13)
      return v13;
  }
  *(_QWORD *)(v6[4] + 24) = &v13[~*((_DWORD *)v6 + 12) & (v6[6] + a4 + a3)];
  memcpy(v13, a2, a3);
  v16 = (_QWORD *)*v6;
  if (*v6)
  {
    while (1)
    {
      v17 = v16;
      if ((char *)v16[1] == a2 && &a2[v8] == (char *)v16[3])
        break;
      v16 = (_QWORD *)*v16;
      v6 = v17;
      if (!*v17)
        return v13;
    }
    *v6 = *v16;
    free(v16);
  }
  return v13;
}

_QWORD *SEC_ASN1EncodeInteger(uint64_t a1, _QWORD *a2, unint64_t a3)
{
  char v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  _QWORD *result;

  v3 = a3;
  v4 = -1;
  v5 = a3;
  do
  {
    v6 = v4++;
    v7 = v5 > 0xFF;
    v5 >>= 8;
  }
  while (v7);
  v8 = v6 + 2;
  result = (_QWORD *)sec_asn1e_allocate_item(a1, a2, v6 + 2);
  if (result)
  {
    *result = v8;
    do
    {
      *(_BYTE *)(result[1] + v4) = v3;
      v3 = 0;
      --v4;
    }
    while (v4 != -1);
  }
  return result;
}

uint64_t SecAsn1DecodeTime(uint64_t a1, double *a2)
{
  _DWORD *v4;
  _QWORD *v5;
  uint64_t Code;
  double v8;
  CFErrorRef v9;
  uint64_t v10[3];
  CFErrorRef err;

  err = 0;
  v4 = PORT_NewArena(1024);
  if (!v4)
    return 4294967188;
  v5 = v4;
  memset(v10, 170, sizeof(v10));
  Code = SEC_ASN1Decode((uint64_t)v4, (uint64_t)v10, (uint64_t)&kSecAsn1TimeTemplate, *(char **)(a1 + 8), *(_QWORD *)a1);
  if (!(_DWORD)Code)
  {
    v8 = SecAbsoluteTimeFromDateContentWithError(LOBYTE(v10[2]), (unsigned __int8 *)v10[1], v10[0], &err);
    if (err)
    {
      Code = CFErrorGetCode(err);
      v9 = err;
      if (err)
      {
        err = 0;
        CFRelease(v9);
      }
    }
    else
    {
      Code = 0;
      if (a2)
        *a2 = v8;
    }
  }
  PORT_FreeArena(v5, 0);
  return Code;
}

uint64_t SecAsn1EncodeTime(uint64_t a1, uint64_t a2, CFAbsoluteTime a3)
{
  CFDateFormatterRef ISO8601Formatter;
  __CFDateFormatter *v7;
  CFTimeZoneRef v8;
  const __CFString *StringWithAbsoluteTime;
  CFIndex Length;
  const __CFString *v11;
  char v12;
  uint64_t v13;
  CFIndex v14;
  CFIndex v15;
  UInt8 *v16;
  tm v18;
  time_t v19;
  CFRange v20;
  CFRange v21;

  ISO8601Formatter = CFDateFormatterCreateISO8601Formatter(0, 0);
  if (ISO8601Formatter)
  {
    v7 = ISO8601Formatter;
    v8 = CFTimeZoneCreateWithTimeIntervalFromGMT(0, 0.0);
    CFDateFormatterSetProperty(v7, (CFStringRef)*MEMORY[0x1E0C9AF68], v8);
    CFDateFormatterSetFormat(v7, CFSTR("yyyyMMddHHmmss'Z'"));
    StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(0, v7, a3);
    CFRelease(v8);
    CFRelease(v7);
  }
  else
  {
    v19 = (uint64_t)(*MEMORY[0x1E0C9ADF8] + a3);
    memset(&v18, 0, sizeof(v18));
    StringWithAbsoluteTime = 0;
    if (gmtime_r(&v19, &v18) == &v18)
      StringWithAbsoluteTime = CFStringCreateWithFormat(0, 0, CFSTR("%04d%02d%02d%02d%02d%02dZ"), (v18.tm_year + 1900), (v18.tm_mon + 1), v18.tm_mday, v18.tm_hour, v18.tm_min, v18.tm_sec);
  }
  Length = CFStringGetLength(StringWithAbsoluteTime);
  if (!StringWithAbsoluteTime)
    return 4294967188;
  if (a3 < -1609459200.0 || a3 > 1546300800.0)
  {
    v11 = (const __CFString *)CFRetain(StringWithAbsoluteTime);
    v12 = 24;
  }
  else
  {
    v21.length = Length - 2;
    v21.location = 2;
    v11 = CFStringCreateWithSubstring(0, StringWithAbsoluteTime, v21);
    v12 = 23;
  }
  *(_BYTE *)(a2 + 16) = v12;
  v14 = CFStringGetLength(v11);
  if (v14 < 0)
  {
    v13 = 4294967188;
  }
  else
  {
    v15 = v14;
    *(_QWORD *)a2 = v14;
    v16 = (UInt8 *)PORT_ArenaAlloc(a1, v14);
    *(_QWORD *)(a2 + 8) = v16;
    v13 = 4294967188;
    if (v16)
    {
      v20.location = 0;
      v20.length = v15;
      if (v15 == CFStringGetBytes(v11, v20, 0x8000100u, 0, 0, v16, v15, 0))
        v13 = 0;
      else
        v13 = 4294967188;
    }
  }
  CFRelease(StringWithAbsoluteTime);
  if (v11)
    CFRelease(v11);
  return v13;
}

_DWORD *PORT_SetError(int a1)
{
  _DWORD *result;
  int v3;

  result = PR_getThreadErrInfo(1, &v3);
  if (result)
  {
    *result = 0;
    result[1] = a1;
  }
  return result;
}

uint64_t PORT_GetError()
{
  _QWORD *ThreadErrInfo;
  int v2;

  v2 = -1431655766;
  ThreadErrInfo = PR_getThreadErrInfo(0, &v2);
  if (ThreadErrInfo)
    return *((unsigned int *)ThreadErrInfo + 1);
  if (v2)
    return 4294961322;
  return 0;
}

char *PORT_ArenaGrow(uint64_t a1, char *a2, unint64_t a3, unint64_t a4)
{
  _QWORD *ThreadErrInfo;
  unint64_t v5;
  BOOL v6;
  unsigned int v7;
  uint64_t v9;
  char *v10;
  unint64_t v11;
  uint64_t v15;
  unint64_t v16;
  BOOL v17;
  int v18;
  int v19;

  if (a4 >> 31)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v18);
    if (ThreadErrInfo)
    {
      v5 = 0xFFFFE01300000000;
LABEL_7:
      *ThreadErrInfo = v5;
      return 0;
    }
    return 0;
  }
  v6 = a4 >= a3;
  v7 = a4 - a3;
  if (!v6)
  {
    ThreadErrInfo = PR_getThreadErrInfo(1, &v19);
    if (ThreadErrInfo)
    {
      v5 = 0xFFFFE00100000000;
      goto LABEL_7;
    }
    return 0;
  }
  v9 = *(_QWORD *)(a1 + 32);
  v10 = &a2[a3];
  v11 = (unint64_t)&v10[v7];
  if (v10 > a2 && v11 > (unint64_t)a2 && v11 > (unint64_t)v10)
  {
    v15 = *(_QWORD *)(a1 + 48);
    v16 = (v15 + v11) & ~v15;
    v17 = *(char **)(v9 + 24) != &a2[~(_DWORD)v15 & (v15 + a3)] || v11 > v16;
    if (!v17 && *(_QWORD *)(v9 + 16) >= v16)
    {
      *(_QWORD *)(v9 + 24) = v16;
      return a2;
    }
  }
  return PL_ArenaGrow(a1, a2, a3, v7);
}

BOOL nssCompareSecAsn1Items(_BOOL8 result, uint64_t a2)
{
  size_t *v2;
  const void *v3;

  if (result)
  {
    v2 = (size_t *)result;
    result = 0;
    if (a2)
    {
      v3 = (const void *)v2[1];
      if (v3)
        return *(_QWORD *)(a2 + 8) && *v2 == *(_QWORD *)a2 && memcmp(v3, *(const void **)(a2 + 8), *v2) == 0;
    }
  }
  return result;
}

const SecAsn1Template *NSS_P12_CertBagChooser(uint64_t a1, int a2)
{
  int v4;
  const SecAsn1Template *result;
  _BOOL4 v6;
  _BOOL4 v7;

  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS9_X509Certificate))
  {
    v4 = 1;
    result = kSecAsn1OctetStringTemplate;
    if (a2)
      return result;
    goto LABEL_3;
  }
  v6 = nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS9_SdsiCertificate);
  v7 = v6;
  if (v6)
    result = kSecAsn1IA5StringTemplate;
  else
    result = 0;
  v4 = 2 * v7;
  if (!a2)
LABEL_3:
    *(_DWORD *)(a1 + 16) = v4;
  return result;
}

const SecAsn1Template *NSS_P12_CrlBagChooser(uint64_t a1, int a2)
{
  _BOOL4 v4;

  v4 = nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS9_X509Crl);
  if (!a2)
    *(_DWORD *)(a1 + 16) = v4;
  if (v4)
    return kSecAsn1OctetStringTemplate;
  else
    return 0;
}

const SecAsn1Template *NSS_P12_SafeBagChooser(uint64_t a1, int a2)
{
  int v4;
  const SecAsn1Template *v5;

  if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_keyBag))
  {
    v4 = 1;
    v5 = kSecAsn1PointerToAnyTemplate;
  }
  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_shroudedKeyBag))
  {
    v4 = 2;
    v5 = (const SecAsn1Template *)&NSS_P12_PtrToShroudedKeyBagTemplate;
  }
  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_certBag))
  {
    v4 = 3;
    v5 = (const SecAsn1Template *)&NSS_P12_PtrToCertBagTemplate;
  }
  else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_crlBag))
  {
    v4 = 4;
    v5 = (const SecAsn1Template *)&NSS_P12_PtrToCrlBagTemplate;
  }
  else
  {
    v5 = kSecAsn1PointerToAnyTemplate;
    if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_secretBag))
    {
      v4 = 5;
    }
    else if (nssCompareSecAsn1Items(a1, (uint64_t)&CSSMOID_PKCS12_safeContentsBag))
    {
      v4 = 6;
    }
    else
    {
      v5 = 0;
      v4 = 0;
    }
  }
  if (!a2)
    *(_DWORD *)(a1 + 16) = v4;
  return v5;
}

uint64_t SEC_ASN1DecodeInteger(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  int *v3;
  unsigned __int8 *v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t result;
  _QWORD *ThreadErrInfo;
  char v9;
  char v10;
  char v11;

  if (!a1)
  {
    v3 = (int *)&v9;
    goto LABEL_13;
  }
  v2 = *a1;
  if ((unint64_t)*a1 >= 9)
  {
    v3 = (int *)&v10;
LABEL_13:
    ThreadErrInfo = PR_getThreadErrInfo(1, v3);
    if (ThreadErrInfo)
      *ThreadErrInfo = 0xFFFFE00500000000;
    return 0xFFFFFFFFLL;
  }
  v4 = (unsigned __int8 *)a1[1];
  if (!v4)
  {
    v3 = (int *)&v11;
    goto LABEL_13;
  }
  v5 = (uint64_t)(char)*v4 >> 7;
  if (v2)
  {
    if (v2 <= 1)
      v2 = 1;
    else
      v2 = v2;
    do
    {
      v6 = *v4++;
      v5 = v6 | (unint64_t)(v5 << 8);
      --v2;
    }
    while (v2);
  }
  result = 0;
  *a2 = v5;
  return result;
}

OSStatus SecAsn1CoderCreate(SecAsn1CoderRef *coder)
{
  SecAsn1Coder *v2;
  _DWORD *v3;
  OSStatus result;

  if (!coder)
    return -50;
  v2 = (SecAsn1Coder *)malloc_type_malloc(8uLL, 0x2004093837F09uLL);
  v3 = PORT_NewArena(1024);
  *(_QWORD *)v2 = v3;
  if (v3)
  {
    result = 0;
    *coder = v2;
  }
  else
  {
    free(v2);
    return -108;
  }
  return result;
}

OSStatus SecAsn1CoderRelease(SecAsn1CoderRef coder)
{
  _QWORD *v2;

  if (!coder)
    return -50;
  v2 = *(_QWORD **)coder;
  if (v2)
    PORT_FreeArena(v2, 1);
  free(coder);
  return 0;
}

OSStatus SecAsn1Decode(SecAsn1CoderRef coder, const void *src, size_t len, const SecAsn1Template *templates, void *dest)
{
  OSStatus result;

  result = -50;
  if (coder && src && templates && dest)
  {
    if (SEC_ASN1Decode(*(_QWORD *)coder, (uint64_t)dest, (uint64_t)templates, (char *)src, len))
      return -26275;
    else
      return 0;
  }
  return result;
}

OSStatus SecAsn1DecodeData(SecAsn1CoderRef coder, const SecAsn1Item *src, const SecAsn1Template *templ, void *dest)
{
  return SecAsn1Decode(coder, src->Data, src->Length, templ, dest);
}

OSStatus SecAsn1EncodeItem(SecAsn1CoderRef coder, const void *src, const SecAsn1Template *templates, SecAsn1Item *dest)
{
  OSStatus result;

  result = -50;
  if (coder && src && templates && dest)
  {
    dest->Length = 0;
    dest->Data = 0;
    if (SEC_ASN1EncodeItem(*(_QWORD *)coder, dest, (uint64_t)src, (uint64_t)templates))
      return 0;
    else
      return -50;
  }
  return result;
}

void *__cdecl SecAsn1Malloc(void *coder, size_t len)
{
  if (coder)
    return (void *)PORT_ArenaAlloc(*(_QWORD *)coder, len);
  return coder;
}

OSStatus SecAsn1AllocItem(SecAsn1CoderRef coder, SecAsn1Item *item, size_t len)
{
  OSStatus result;
  uint8_t *v7;

  result = -50;
  if (coder && item)
  {
    v7 = (uint8_t *)PORT_ArenaAlloc(*(_QWORD *)coder, len);
    item->Data = v7;
    if (v7)
    {
      result = 0;
      item->Length = len;
    }
    else
    {
      return -108;
    }
  }
  return result;
}

OSStatus SecAsn1AllocCopy(SecAsn1CoderRef coder, const void *src, size_t len, SecAsn1Item *dest)
{
  OSStatus result;
  uint8_t *v9;

  if (!src)
    return -50;
  result = -50;
  if (coder && dest)
  {
    v9 = (uint8_t *)PORT_ArenaAlloc(*(_QWORD *)coder, len);
    dest->Data = v9;
    if (v9)
    {
      dest->Length = len;
      memmove(v9, src, len);
      return 0;
    }
    else
    {
      return -108;
    }
  }
  return result;
}

OSStatus SecAsn1AllocCopyItem(SecAsn1CoderRef coder, const SecAsn1Item *src, SecAsn1Item *dest)
{
  return SecAsn1AllocCopy(coder, src->Data, src->Length, dest);
}

BOOL SSLContextCompare(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

CFStringRef SSLContextCopyFormatDescription(CFStringRef result)
{
  if (result)
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<SSLContext(%p) { ... }>"), result);
  return result;
}

CFStringRef SSLContextCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();
  if (a1)
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<SSLContext(%p) { ... }>"), a1);
  else
    return 0;
}

OSStatus SSLSetSessionConfig(SSLContextRef context, CFStringRef config)
{
  if (CFEqual(config, CFSTR("ATSv1"))
    || CFEqual(config, CFSTR("ATSv1_noPFS"))
    || CFEqual(config, CFSTR("standard"))
    || CFEqual(config, CFSTR("TLSv1_fallback"))
    || CFEqual(config, CFSTR("TLSv1_RC4_fallback"))
    || CFEqual(config, CFSTR("RC4_fallback"))
    || CFEqual(config, CFSTR("3DES_fallback"))
    || CFEqual(config, CFSTR("TLSv1_3DES_fallback"))
    || CFEqual(config, CFSTR("legacy"))
    || CFEqual(config, CFSTR("legacy_DHE"))
    || CFEqual(config, CFSTR("anonymous"))
    || CFEqual(config, CFSTR("default")))
  {
    return tls_handshake_set_config();
  }
  else
  {
    return -50;
  }
}

uint64_t SSLSetRecordContext(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  uint64_t result;

  if (!a1)
    return 4294967246;
  v3 = *(_DWORD *)(a1 + 80);
  v4 = v3 > 6;
  v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0)
    return 4294966387;
  result = 0;
  *(_QWORD *)(a1 + 48) = a2;
  return result;
}

uint64_t _SSLNewDatagramContext(int a1, SSLContextRef *a2)
{
  SSLContextRef v3;

  if (!a2)
    return 4294967246;
  v3 = SSLCreateContext((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (SSLProtocolSide)(a1 == 0), kSSLDatagramType);
  *a2 = v3;
  if (v3)
    return 0;
  else
    return 4294967188;
}

OSStatus SSLGetSessionOption(SSLContextRef context, SSLSessionOption option, Boolean *value)
{
  OSStatus result;
  Boolean v5;

  result = -50;
  if (context && value)
  {
    switch(option)
    {
      case kSSLSessionOptionBreakOnServerAuth:
        result = 0;
        v5 = *((_BYTE *)context + 353);
        goto LABEL_11;
      case kSSLSessionOptionBreakOnCertRequested:
        result = 0;
        v5 = *((_BYTE *)context + 354);
        goto LABEL_11;
      case kSSLSessionOptionBreakOnClientAuth:
        result = 0;
        v5 = *((_BYTE *)context + 355);
        goto LABEL_11;
      case kSSLSessionOptionFalseStart:
        result = 0;
        v5 = *((_BYTE *)context + 512);
        goto LABEL_11;
      case kSSLSessionOptionSendOneByteRecord:
        result = 0;
        v5 = *((_BYTE *)context + 315);
        goto LABEL_11;
      case kSSLSessionOptionAllowServerIdentityChange:
        tls_handshake_get_server_identity_change();
        return 0;
      case kSSLSessionOptionBreakOnClientHello:
        result = 0;
        v5 = *((_BYTE *)context + 359);
LABEL_11:
        *value = v5;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t SSLSetNPNFunc(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (result)
  {
    v3 = *(_DWORD *)(result + 80);
    v4 = v3 > 6;
    v5 = (1 << v3) & 0x59;
    if (!v4 && v5 != 0)
    {
      *(_QWORD *)(result + 520) = a2;
      *(_QWORD *)(result + 528) = a3;
      if (*(_DWORD *)(result + 108) == 1)
        return tls_handshake_set_npn_enable();
    }
  }
  return result;
}

uint64_t SSLSetNPNData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && (unint64_t)(a3 - 256) >= 0xFFFFFFFFFFFFFF01)
    return tls_handshake_set_npn_data();
  else
    return 4294967246;
}

uint64_t *SSLGetNPNData(uint64_t a1, _QWORD *a2)
{
  uint64_t *result;
  uint64_t v5;

  result = 0;
  if (a1 && a2)
  {
    result = (uint64_t *)tls_handshake_get_peer_npn_data();
    if (result)
    {
      v5 = *result;
      result = (uint64_t *)result[1];
      *a2 = v5;
    }
  }
  return result;
}

uint64_t SSLSetALPNFunc(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;

  if (result)
  {
    v3 = *(_DWORD *)(result + 80);
    v4 = v3 > 6;
    v5 = (1 << v3) & 0x59;
    if (!v4 && v5 != 0)
    {
      *(_QWORD *)(result + 536) = a2;
      *(_QWORD *)(result + 544) = a3;
    }
  }
  return result;
}

uint64_t SSLSetALPNData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && (unint64_t)(a3 - 256) >= 0xFFFFFFFFFFFFFF01)
    return tls_handshake_set_alpn_data();
  else
    return 4294967246;
}

uint64_t *SSLGetALPNData(uint64_t a1, _QWORD *a2)
{
  uint64_t *result;
  uint64_t v5;

  result = 0;
  if (a1 && a2)
  {
    result = (uint64_t *)tls_handshake_get_peer_alpn_data();
    if (result)
    {
      v5 = *result;
      result = (uint64_t *)result[1];
      *a2 = v5;
    }
  }
  return result;
}

OSStatus SSLSetALPNProtocols(SSLContextRef context, CFArrayRef protocols)
{
  OSStatus v2;
  const __CFData *Mutable;
  _QWORD contexta[5];
  CFRange v7;

  v2 = -50;
  if (context && protocols && CFArrayGetCount(protocols))
  {
    Mutable = CFDataCreateMutable(0, 0);
    contexta[0] = MEMORY[0x1E0C809B0];
    contexta[1] = 0x40000000;
    contexta[2] = __SSLSetALPNProtocols_block_invoke;
    contexta[3] = &__block_descriptor_tmp_4_6515;
    contexta[4] = Mutable;
    v7.length = CFArrayGetCount(protocols);
    v7.location = 0;
    CFArrayApplyFunction(protocols, v7, (CFArrayApplierFunction)apply_block_1_6516, contexta);
    if (CFDataGetLength(Mutable) <= 255)
    {
      CFDataGetBytePtr(Mutable);
      CFDataGetLength(Mutable);
      v2 = tls_handshake_set_alpn_data();
    }
    CFRelease(Mutable);
  }
  return v2;
}

uint64_t apply_block_1_6516(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

OSStatus SSLCopyALPNProtocols(SSLContextRef context, CFArrayRef *protocols)
{
  OSStatus result;
  __CFArray *Mutable;
  unint64_t *peer_alpn_data;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  CFIndex v11;
  unint64_t v12;
  CFStringRef v13;

  result = -50;
  if (context && protocols)
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    peer_alpn_data = (unint64_t *)tls_handshake_get_peer_alpn_data();
    if (peer_alpn_data)
    {
      v7 = peer_alpn_data;
      v8 = 0;
      v9 = *peer_alpn_data;
      while (v8 < v9)
      {
        v10 = v7[1];
        v11 = *(char *)(v10 + v8);
        v12 = v8 + 1;
        v8 += 1 + v11;
        if (v8 <= v9)
        {
          v13 = CFStringCreateWithBytes(0, (const UInt8 *)(v10 + v12), v11, 0x600u, 0);
          CFArrayAppendValue(Mutable, v13);
          if (v13)
            CFRelease(v13);
          v9 = *v7;
          if (v8 <= *v7)
            continue;
        }
        goto LABEL_10;
      }
      result = 0;
    }
    else
    {
LABEL_10:
      if (Mutable)
      {
        CFRelease(Mutable);
        Mutable = 0;
      }
      result = -50;
    }
    *protocols = Mutable;
  }
  return result;
}

OSStatus SSLSetOCSPResponse(SSLContextRef context, CFDataRef response)
{
  OSStatus result;

  result = -50;
  if (context)
  {
    if (response)
    {
      CFDataGetBytePtr(response);
      CFDataGetLength(response);
      return tls_handshake_set_ocsp_response();
    }
  }
  return result;
}

OSStatus SSLGetConnection(SSLContextRef context, SSLConnectionRef *connection)
{
  OSStatus result;

  result = -50;
  if (context)
  {
    if (connection)
    {
      result = 0;
      *connection = (SSLConnectionRef)*((_QWORD *)context + 4);
    }
  }
  return result;
}

OSStatus SSLCopyRequestedPeerNameLength(SSLContextRef ctx, size_t *peerNameLen)
{
  uint64_t sni_hostname;
  size_t *v4;
  OSStatus result;

  if (!ctx)
    return -50;
  sni_hostname = tls_handshake_get_sni_hostname();
  if (!sni_hostname)
    return -50;
  v4 = (size_t *)sni_hostname;
  result = 0;
  *peerNameLen = *v4;
  return result;
}

OSStatus SSLCopyRequestedPeerName(SSLContextRef context, char *peerName, size_t *peerNameLen)
{
  uint64_t sni_hostname;
  size_t *v6;
  OSStatus result;

  if (!context)
    return -50;
  sni_hostname = tls_handshake_get_sni_hostname();
  if (!sni_hostname)
    return -50;
  v6 = (size_t *)sni_hostname;
  if (*peerNameLen < *(_QWORD *)sni_hostname)
    return -9817;
  memcpy(peerName, *(const void **)(sni_hostname + 8), *(_QWORD *)sni_hostname);
  result = 0;
  *peerNameLen = *v6;
  return result;
}

OSStatus SSLSetDatagramHelloCookie(SSLContextRef dtlsContext, const void *cookie, size_t cookieLen)
{
  OSStatus result;
  unsigned int v6;
  BOOL v7;
  int v8;
  void *v11;
  void *v12;
  void *v13;
  size_t v14;

  if (!dtlsContext)
    return -50;
  result = -50;
  if (cookieLen <= 0x20 && *((_BYTE *)dtlsContext + 104))
  {
    v6 = *((_DWORD *)dtlsContext + 20);
    v7 = v6 > 6;
    v8 = (1 << v6) & 0x59;
    if (v7 || v8 == 0)
    {
      return -909;
    }
    else
    {
      v11 = (void *)*((_QWORD *)dtlsContext + 15);
      if (v11)
      {
        free(v11);
        *((_QWORD *)dtlsContext + 14) = 0;
        *((_QWORD *)dtlsContext + 15) = 0;
      }
      v12 = malloc_type_malloc(cookieLen, 0xEFB4CC30uLL);
      v13 = v12;
      if (v12)
        v14 = cookieLen;
      else
        v14 = 0;
      if (v12)
        result = 0;
      else
        result = -1;
      *((_QWORD *)dtlsContext + 14) = v14;
      *((_QWORD *)dtlsContext + 15) = v13;
      if (v13)
      {
        memmove(v13, cookie, cookieLen);
        return 0;
      }
    }
  }
  return result;
}

OSStatus SSLSetMaxDatagramRecordSize(SSLContextRef dtlsContext, size_t maxSize)
{
  if (!dtlsContext)
    return -50;
  if (!*((_BYTE *)dtlsContext + 104))
    return -50;
  tls_handshake_set_mtu();
  return 0;
}

OSStatus SSLGetMaxDatagramRecordSize(SSLContextRef dtlsContext, size_t *maxSize)
{
  OSStatus result;

  if (!dtlsContext || !*((_BYTE *)dtlsContext + 104))
    return -50;
  result = 0;
  *maxSize = *((_QWORD *)dtlsContext + 54);
  return result;
}

OSStatus SSLGetDatagramWriteSize(SSLContextRef dtlsContext, size_t *bufSize)
{
  OSStatus result;

  if (!dtlsContext)
    return -50;
  result = -50;
  if (bufSize)
  {
    if (*((_BYTE *)dtlsContext + 104))
    {
      result = 0;
      *bufSize = ((*((_QWORD *)dtlsContext + 54) - 13) & 0xFFFFFFFFFFFFFFF0) - 49;
    }
  }
  return result;
}

OSStatus SSLGetProtocolVersionMin(SSLContextRef context, SSLProtocol *minVersion)
{
  SSLProtocol v2;
  OSStatus result;

  if (!context)
    return -50;
  v2 = kSSLProtocol3;
  switch(*((_DWORD *)context + 24))
  {
    case 0x300:
      break;
    case 0x301:
      v2 = kTLSProtocol1;
      break;
    case 0x302:
      v2 = kTLSProtocol11;
      break;
    case 0x303:
      v2 = kTLSProtocol12;
      break;
    default:
      v2 = kSSLProtocolUnknown;
      break;
  }
  result = 0;
  *minVersion = v2;
  return result;
}

OSStatus SSLGetProtocolVersionMax(SSLContextRef context, SSLProtocol *maxVersion)
{
  SSLProtocol v2;
  OSStatus result;

  if (!context)
    return -50;
  v2 = kSSLProtocol3;
  switch(*((_DWORD *)context + 25))
  {
    case 0x300:
      break;
    case 0x301:
      v2 = kTLSProtocol1;
      break;
    case 0x302:
      v2 = kTLSProtocol11;
      break;
    case 0x303:
      v2 = kTLSProtocol12;
      break;
    default:
      v2 = kSSLProtocolUnknown;
      break;
  }
  result = 0;
  *maxVersion = v2;
  return result;
}

uint64_t _SSLProtocolVersionToWireFormatValue(int a1)
{
  uint64_t result;

  result = 768;
  switch(a1)
  {
    case 0:
    case 1:
    case 3:
    case 5:
    case 6:
      result = 0;
      break;
    case 2:
      return result;
    case 4:
      result = 769;
      break;
    case 7:
      result = 770;
      break;
    case 8:
      result = 771;
      break;
    case 9:
      result = 65279;
      break;
    case 10:
      result = 772;
      break;
    case 11:
      result = 65277;
      break;
    default:
      if (a1 == 999)
        result = 772;
      else
        result = 0;
      break;
  }
  return result;
}

uint64_t _SSLSetProtocolVersionEnabled(uint64_t a1, int a2, int a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  BOOL v6;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;

  if (!a1)
    return 4294967246;
  v3 = *(_DWORD *)(a1 + 80);
  v4 = v3 > 6;
  v5 = (1 << v3) & 0x59;
  v6 = v4 || v5 == 0;
  if (v6 || *(_BYTE *)(a1 + 104))
    return 4294966387;
  v8 = 2;
  switch(a2)
  {
    case 1:
      goto LABEL_18;
    case 2:
      v8 = 768;
      goto LABEL_18;
    case 4:
      v8 = 769;
      goto LABEL_18;
    case 6:
      if (!a3)
        goto LABEL_42;
      *(_QWORD *)(a1 + 96) = 0x30300000300;
      goto LABEL_43;
    case 7:
      v8 = 770;
      goto LABEL_18;
    case 8:
      v8 = 771;
      goto LABEL_18;
    case 9:
      v8 = 65279;
      goto LABEL_18;
    default:
      v8 = 0;
LABEL_18:
      v9 = v8 - 772;
      if (!a3)
      {
        if (v9 < 0xFFFFFCFE)
          return 4294967246;
        if (v8 > 768)
        {
          if (v8 == 769)
          {
            v11 = 770;
            goto LABEL_38;
          }
          if (v8 == 770)
          {
            v11 = 771;
            goto LABEL_38;
          }
        }
        else
        {
          if (v8 == 2)
          {
            v11 = 768;
            goto LABEL_38;
          }
          if (v8 == 768)
          {
            v11 = 769;
            goto LABEL_38;
          }
        }
        v11 = 0;
LABEL_38:
        v12 = *(_DWORD *)(a1 + 100);
        if (*(_DWORD *)(a1 + 96) <= v11)
          v13 = v11;
        else
          v13 = *(_DWORD *)(a1 + 96);
        *(_DWORD *)(a1 + 96) = v13;
        if (v13 > v12)
LABEL_42:
          *(_QWORD *)(a1 + 96) = 0;
        goto LABEL_43;
      }
      if (v9 < 0xFFFFFFFC)
        return 4294967246;
      if (v8 <= *(_DWORD *)(a1 + 100))
      {
        v10 = *(_DWORD *)(a1 + 96);
      }
      else
      {
        *(_DWORD *)(a1 + 100) = v8;
        v10 = *(_DWORD *)(a1 + 96);
        if (!v10)
        {
          *(_DWORD *)(a1 + 96) = v8;
          v10 = v8;
        }
      }
      if (v8 < v10)
        *(_DWORD *)(a1 + 96) = v8;
LABEL_43:
      tls_handshake_set_min_protocol_version();
      tls_handshake_set_max_protocol_version();
      return 0;
  }
}

uint64_t _SSLGetProtocolVersionEnabled(uint64_t a1, int a2, BOOL *a3)
{
  uint64_t v3;
  unsigned int v4;
  BOOL v5;

  if (!a1)
    return 4294967246;
  if (*(_BYTE *)(a1 + 104))
    return 4294966387;
  v3 = 4294967246;
  v4 = 2;
  switch(a2)
  {
    case 1:
      goto LABEL_12;
    case 2:
      v4 = 768;
      goto LABEL_12;
    case 4:
      v4 = 769;
      goto LABEL_12;
    case 6:
      if (*(_DWORD *)(a1 + 96) > 0x300u)
        goto LABEL_13;
      v5 = *(_DWORD *)(a1 + 100) > 0x302u;
      goto LABEL_15;
    case 7:
      v4 = 770;
      goto LABEL_12;
    case 8:
      v4 = 771;
LABEL_12:
      if (*(_DWORD *)(a1 + 96) <= v4)
        v5 = *(_DWORD *)(a1 + 100) >= v4;
      else
LABEL_13:
        v5 = 0;
LABEL_15:
      v3 = 0;
      *a3 = v5;
      break;
    default:
      return v3;
  }
  return v3;
}

uint64_t _SSLSetProtocolVersion(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  BOOL v3;
  int v4;
  BOOL v5;
  int v7;

  if (!a1)
    return 4294967246;
  v2 = *(_DWORD *)(a1 + 80);
  v3 = v2 > 6;
  v4 = (1 << v2) & 0x59;
  v5 = v3 || v4 == 0;
  if (v5 || *(_BYTE *)(a1 + 104))
    return 4294966387;
  if (a2 > 8 || ((0x1FDu >> a2) & 1) == 0)
    return 4294967246;
  v7 = dword_18AA5C40C[a2];
  *(_DWORD *)(a1 + 96) = dword_18AA5C3E8[a2];
  *(_DWORD *)(a1 + 100) = v7;
  tls_handshake_set_min_protocol_version();
  tls_handshake_set_max_protocol_version();
  return 0;
}

uint64_t _SSLGetProtocolVersion(uint64_t a1, int *a2)
{
  uint64_t result;
  int v3;
  int v4;

  if (!a1)
    return 4294967246;
  switch(*(_DWORD *)(a1 + 100))
  {
    case 0x300:
      if (*(_DWORD *)(a1 + 96) != 768)
        return 4294967246;
      result = 0;
      v3 = 2;
      goto LABEL_14;
    case 0x301:
      v4 = *(_DWORD *)(a1 + 96);
      if (v4 == 768)
      {
        result = 0;
        v3 = 4;
      }
      else
      {
        if (v4 != 769)
          return 4294967246;
        result = 4294967246;
        v3 = 5;
      }
LABEL_14:
      *a2 = v3;
      break;
    case 0x302:
      if (*(_DWORD *)(a1 + 96) != 768)
        return 4294967246;
      result = 0;
      v3 = 7;
      goto LABEL_14;
    case 0x303:
      if (*(_DWORD *)(a1 + 96) != 768)
        return 4294967246;
      result = 0;
      v3 = 6;
      goto LABEL_14;
    default:
      return 4294967246;
  }
  return result;
}

uint64_t _SSLGetEnableCertVerify(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  if (!a1)
    return 4294967246;
  result = 0;
  *a2 = *(_BYTE *)(a1 + 187);
  return result;
}

uint64_t _SSLSetAllowsExpiredCerts()
{
  return 0;
}

uint64_t _SSLGetAllowsExpiredCerts()
{
  return 4294967292;
}

uint64_t _SSLSetAllowsExpiredRoots()
{
  return 0;
}

uint64_t _SSLGetAllowsExpiredRoots()
{
  return 4294967292;
}

uint64_t _SSLSetAllowsAnyRoot(uint64_t a1, char a2)
{
  uint64_t result;

  if (!a1)
    return 4294967246;
  result = 0;
  *(_BYTE *)(a1 + 312) = a2;
  return result;
}

uint64_t _SSLGetAllowsAnyRoot(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  if (!a1)
    return 4294967246;
  result = 0;
  *a2 = *(_BYTE *)(a1 + 312);
  return result;
}

uint64_t _SSLSetTrustedRoots(uint64_t a1, CFArrayRef theArray, int a3)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  const void *v9;
  CFMutableArrayRef MutableCopy;
  CFRange v12;

  v3 = *(_DWORD *)(a1 + 80);
  v4 = v3 > 6;
  v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0)
    return 4294966387;
  if (a3)
  {
    *(_BYTE *)(a1 + 184) = 1;
    v9 = *(const void **)(a1 + 176);
    if (v9)
    {
      *(_QWORD *)(a1 + 176) = 0;
      CFRelease(v9);
    }
  }
  if (*(_QWORD *)(a1 + 176))
  {
    v12.length = CFArrayGetCount(theArray);
    v12.location = 0;
    CFArrayAppendArray(*(CFMutableArrayRef *)(a1 + 176), theArray, v12);
    return 0;
  }
  MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theArray);
  *(_QWORD *)(a1 + 176) = MutableCopy;
  if (MutableCopy)
    return 0;
  return 4294967188;
}

uint64_t _SSLCopyTrustedRoots(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v4;

  result = 4294967246;
  if (a1 && a2)
  {
    v4 = *(_QWORD *)(a1 + 176);
    if (v4)
    {
      *a2 = v4;
      CFRetain(*(CFTypeRef *)(a1 + 176));
      return 0;
    }
    else
    {
      result = 0;
      *a2 = 0;
    }
  }
  return result;
}

uint64_t SSLGetClientSideAuthenticate(uint64_t a1, _DWORD *a2)
{
  uint64_t result;

  result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_DWORD *)(a1 + 252);
    }
  }
  return result;
}

OSStatus SSLGetClientCertificateState(SSLContextRef context, SSLClientCertificateState *clientState)
{
  SSLClientCertificateState v2;
  char *v3;
  OSStatus result;
  BOOL v5;

  if (!context)
    return -50;
  v2 = *((_DWORD *)context + 64);
  if (*((_DWORD *)context + 27) == 1)
  {
    if (v2 == kSSLClientCertNone)
    {
LABEL_16:
      result = 0;
      *clientState = v2;
      return result;
    }
    if (v2 == kSSLClientCertRequested)
    {
      v3 = (char *)context + 152;
      goto LABEL_13;
    }
  }
  else
  {
    if (v2)
      v5 = v2 == kSSLClientCertRejected;
    else
      v5 = 1;
    if (v5)
      goto LABEL_16;
    if (v2 == kSSLClientCertRequested)
    {
      v3 = (char *)context + 168;
LABEL_13:
      if (*(_QWORD *)v3)
        v2 = kSSLClientCertSent;
      else
        v2 = kSSLClientCertRequested;
      goto LABEL_16;
    }
  }
  return -9810;
}

OSStatus SSLSetEncryptionCertificate(SSLContextRef context, CFArrayRef certRefs)
{
  unsigned int v3;
  BOOL v4;
  int v5;
  const void *v8;

  if (!context)
    return -50;
  v3 = *((_DWORD *)context + 20);
  v4 = v3 > 6;
  v5 = (1 << v3) & 0x59;
  if (v4 || v5 == 0)
    return -909;
  v8 = (const void *)*((_QWORD *)context + 20);
  if (v8)
  {
    *((_QWORD *)context + 20) = 0;
    CFRelease(v8);
  }
  *((_QWORD *)context + 20) = certRefs;
  CFRetain(certRefs);
  return 0;
}

uint64_t SSLGetCertificate(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  if (!a1)
    return 4294967246;
  result = 0;
  *a2 = *(_QWORD *)(a1 + 152);
  return result;
}

uint64_t SSLGetEncryptionCertificate(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  if (!a1)
    return 4294967246;
  result = 0;
  *a2 = *(_QWORD *)(a1 + 160);
  return result;
}

OSStatus SSLAddDistinguishedName(SSLContextRef context, const void *derDN, size_t derDNLen)
{
  unsigned int v4;
  BOOL v5;
  int v6;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  size_t v13;

  if (!context)
    return -50;
  v4 = *((_DWORD *)context + 20);
  v5 = v4 > 6;
  v6 = (1 << v4) & 0x59;
  if (v5 || v6 == 0)
    return -909;
  v10 = malloc_type_malloc(0x18uLL, 0xEFB4CC30uLL);
  if (!v10)
    return -108;
  v11 = v10;
  v12 = malloc_type_malloc(derDNLen, 0xEFB4CC30uLL);
  if (v12)
    v13 = derDNLen;
  else
    v13 = 0;
  v11[1] = v13;
  v11[2] = v12;
  if (v12)
  {
    memcpy(v12, derDN, derDNLen);
    *v11 = *((_QWORD *)context + 33);
    *((_QWORD *)context + 33) = v11;
    tls_handshake_set_acceptable_dn_list();
    return 0;
  }
  else
  {
    free(v11);
    return -1;
  }
}

uint64_t _SSLSetCertificateAuthorities(uint64_t a1, CFTypeRef cf, int a3)
{
  unsigned int v4;
  BOOL v5;
  int v6;
  BOOL v7;
  uint64_t result;
  const void *v10;
  CFTypeID v11;
  CFIndex Count;
  CFIndex v13;
  CFIndex v14;
  const void *ValueAtIndex;
  CFTypeID v16;

  if (a1)
  {
    v4 = *(_DWORD *)(a1 + 80);
    v5 = v4 > 6;
    v6 = (1 << v4) & 0x59;
    v7 = v5 || v6 == 0;
    if (!v7 && !*(_DWORD *)(a1 + 108))
    {
      if (a3)
      {
        sslFreeDnList(a1);
        v10 = *(const void **)(a1 + 272);
        if (v10)
        {
          CFRelease(v10);
          *(_QWORD *)(a1 + 272) = 0;
        }
      }
      v11 = CFGetTypeID(cf);
      if (v11 == SecCertificateGetTypeID())
        return sslAddCA((SSLContext *)a1, cf);
      if (v11 == CFArrayGetTypeID())
      {
        Count = CFArrayGetCount((CFArrayRef)cf);
        if (Count < 1)
          return 0;
        v13 = Count;
        v14 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, v14);
          v16 = CFGetTypeID(ValueAtIndex);
          if (v16 != SecCertificateGetTypeID())
            break;
          result = sslAddCA((SSLContext *)a1, ValueAtIndex);
          if (!(_DWORD)result && v13 != ++v14)
            continue;
          return result;
        }
      }
    }
  }
  return 4294967246;
}

uint64_t sslAddCA(SSLContext *a1, const void *a2)
{
  __CFData *v4;
  const __CFData *v5;
  __CFArray *Mutable;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v9;

  v4 = SecDERItemCopySequence((uint64_t)a2 + 184);
  if (!v4)
    return 4294967246;
  v5 = v4;
  Mutable = (__CFArray *)*((_QWORD *)a1 + 34);
  if (Mutable
    || (Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]), (*((_QWORD *)a1 + 34) = Mutable) != 0))
  {
    CFArrayAppendValue(Mutable, a2);
    BytePtr = CFDataGetBytePtr(v5);
    Length = CFDataGetLength(v5);
    v9 = SSLAddDistinguishedName(a1, BytePtr, Length);
  }
  else
  {
    v9 = 4294967246;
  }
  CFRelease(v5);
  return v9;
}

uint64_t _SSLCopyCertificateAuthorities(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v4;

  result = 4294967246;
  if (a1 && a2)
  {
    v4 = *(_QWORD *)(a1 + 272);
    if (v4)
    {
      *a2 = v4;
      CFRetain(*(CFTypeRef *)(a1 + 272));
      return 0;
    }
    else
    {
      result = 0;
      *a2 = 0;
    }
  }
  return result;
}

OSStatus SSLCopyDistinguishedNames(SSLContextRef context, CFArrayRef *names)
{
  OSStatus result;
  uint64_t peer_acceptable_dn_list;
  __CFArray *Mutable;
  CFDataRef v7;

  result = -50;
  if (context && names)
  {
    if (*((_DWORD *)context + 27))
    {
      peer_acceptable_dn_list = tls_handshake_get_peer_acceptable_dn_list();
      if (peer_acceptable_dn_list)
        goto LABEL_5;
    }
    else
    {
      peer_acceptable_dn_list = *((_QWORD *)context + 33);
      if (peer_acceptable_dn_list)
      {
LABEL_5:
        Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
        do
        {
          v7 = CFDataCreate(0, *(const UInt8 **)(peer_acceptable_dn_list + 16), *(_QWORD *)(peer_acceptable_dn_list + 8));
          CFArrayAppendValue(Mutable, v7);
          CFRelease(v7);
          peer_acceptable_dn_list = *(_QWORD *)peer_acceptable_dn_list;
        }
        while (peer_acceptable_dn_list);
        goto LABEL_10;
      }
    }
    Mutable = 0;
LABEL_10:
    result = 0;
    *names = Mutable;
  }
  return result;
}

uint64_t _SSLSetDiffieHellmanParams(uint64_t a1, const void *a2, size_t size)
{
  unsigned int v4;
  BOOL v5;
  int v6;
  _QWORD *v10;
  void *v11;
  void *v12;
  void *v13;

  if (!a1)
    return 4294967246;
  v4 = *(_DWORD *)(a1 + 80);
  v5 = v4 > 6;
  v6 = (1 << v4) & 0x59;
  if (v5 || v6 == 0)
    return 4294966387;
  v10 = (_QWORD *)(a1 + 136);
  v11 = *(void **)(a1 + 144);
  if (v11)
    free(v11);
  *v10 = 0;
  *(_QWORD *)(a1 + 144) = 0;
  v12 = malloc_type_malloc(size, 0xEFB4CC30uLL);
  if (v12)
  {
    v13 = v12;
    memmove(v12, a2, size);
    *(_QWORD *)(a1 + 136) = size;
    *(_QWORD *)(a1 + 144) = v13;
    return tls_handshake_set_dh_parameters();
  }
  else
  {
    *(_QWORD *)(a1 + 144) = 0;
    return 0xFFFFFFFFLL;
  }
}

uint64_t _SSLGetDiffieHellmanParams(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  if (!a1)
    return 4294967246;
  result = 0;
  v6 = a1 + 136;
  v5 = *(_QWORD *)(a1 + 136);
  *a2 = *(_QWORD *)(v6 + 8);
  *a3 = v5;
  return result;
}

uint64_t SSLSetDHEEnabled(uint64_t a1, char a2)
{
  *(_BYTE *)(a1 + 552) = a2;
  tls_handshake_get_min_protocol_version();
  tls_handshake_get_max_protocol_version();
  tls_handshake_get_min_dh_group_size();
  tls_handshake_set_config();
  tls_handshake_set_min_protocol_version();
  tls_handshake_set_max_protocol_version();
  tls_handshake_set_min_dh_group_size();
  return 0;
}

uint64_t SSLGetDHEEnabled(uint64_t a1, _BYTE *a2)
{
  *a2 = *(_BYTE *)(a1 + 552);
  return 0;
}

uint64_t SSLSetMinimumDHGroupSize()
{
  return tls_handshake_set_min_dh_group_size();
}

uint64_t SSLGetMinimumDHGroupSize()
{
  return tls_handshake_get_min_dh_group_size();
}

uint64_t _SSLSetRsaBlinding(uint64_t a1, char a2)
{
  uint64_t result;

  if (!a1)
    return 4294967246;
  result = 0;
  *(_BYTE *)(a1 + 314) = a2;
  return result;
}

uint64_t _SSLGetRsaBlinding(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  if (!a1)
    return 4294967246;
  result = 0;
  *a2 = *(_BYTE *)(a1 + 314);
  return result;
}

OSStatus SSLCopyPeerTrust(SSLContextRef context, SecTrustRef *trust)
{
  OSStatus SecTrust;
  __SecTrust *v5;
  CFTypeRef *v6;

  SecTrust = -50;
  if (context && trust)
  {
    v6 = (CFTypeRef *)((char *)context + 168);
    v5 = (__SecTrust *)*((_QWORD *)context + 21);
    if (v5)
    {
      SecTrust = 0;
    }
    else
    {
      SecTrust = sslCreateSecTrust((uint64_t)context, (_QWORD *)context + 21);
      v5 = (__SecTrust *)*((_QWORD *)context + 21);
    }
    *trust = v5;
    if (*v6)
      CFRetain(*v6);
  }
  return SecTrust;
}

uint64_t SSLGetPeerSecTrust(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;

  result = 4294967246;
  if (a1 && a2)
  {
    v5 = *(_QWORD *)(a1 + 168);
    if (v5)
    {
      result = 0;
    }
    else
    {
      result = sslCreateSecTrust(a1, (_QWORD *)(a1 + 168));
      v5 = *(_QWORD *)(a1 + 168);
    }
    *a2 = v5;
  }
  return result;
}

uint64_t SSLInternalMasterSecret(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && a3)
    return tls_handshake_internal_master_secret();
  else
    return 4294967246;
}

uint64_t SSLInternalServerRandom(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && a3)
    return tls_handshake_internal_server_random();
  else
    return 4294967246;
}

uint64_t SSLInternalClientRandom(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2 && a3)
    return tls_handshake_internal_client_random();
  else
    return 4294967246;
}

uint64_t SSLGetCipherSizes(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t result;
  unsigned int SymmetricCipherBlockIvSize;

  result = 4294967246;
  if (a1 && a2 && a3)
  {
    if (a4)
    {
      tls_handshake_get_negotiated_cipherspec();
      *a2 = sslCipherSuiteGetMacSize();
      *a3 = sslCipherSuiteGetSymmetricCipherKeySize();
      SymmetricCipherBlockIvSize = sslCipherSuiteGetSymmetricCipherBlockIvSize();
      result = 0;
      *a4 = SymmetricCipherBlockIvSize;
    }
  }
  return result;
}

uint64_t SSLGetResumableSessionInfo(uint64_t a1, _BYTE *a2, void *a3, unint64_t *a4)
{
  uint64_t result;
  unint64_t v9;

  result = 4294967246;
  if (a1 && a2 && a3 && a4)
  {
    if (*a4 < 0x20)
      return 4294967246;
    if (tls_handshake_get_session_match())
    {
      *a2 = 1;
      v9 = 0xAAAAAAAAAAAAAAAALL;
      if (*a4 < 0xAAAAAAAAAAAAAAAALL)
        return 4294967246;
      memmove(a3, (const void *)0xAAAAAAAAAAAAAAAALL, 0xAAAAAAAAAAAAAAAALL);
    }
    else
    {
      v9 = 0;
      *a2 = 0;
    }
    result = 0;
    *a4 = v9;
  }
  return result;
}

uint64_t SSLGetAllowAnonymousCiphers()
{
  return 0;
}

uint64_t SSLSetSessionCacheTimeout(uint64_t a1, int a2)
{
  uint64_t result;

  if (!a1)
    return 4294967246;
  result = 0;
  *(_DWORD *)(a1 + 316) = a2;
  return result;
}

uint64_t SSLInternalSetMasterSecretFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1)
    return 4294967246;
  *(_QWORD *)(a1 + 336) = a2;
  *(_QWORD *)(a1 + 344) = a3;
  return tls_handshake_internal_set_master_secret_function();
}

uint64_t tls_handshake_master_secret_function(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(a1 + 336))(a1, *(_QWORD *)(a1 + 344), a2, a3);
}

uint64_t SSLInternalSetSessionTicket(uint64_t a1)
{
  unsigned int v1;
  BOOL v2;
  int v3;
  BOOL v4;

  if (!a1)
    return 4294967246;
  v1 = *(_DWORD *)(a1 + 80);
  v2 = v1 >= 6;
  v4 = v1 == 6;
  v3 = (1 << v1) & 0x59;
  v4 = !v4 && v2 || v3 == 0;
  if (v4)
    return 4294966387;
  else
    return tls_handshake_internal_set_session_ticket();
}

uint64_t SSLGetNegotiatedCurve(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  int negotiated_curve;

  result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      negotiated_curve = tls_handshake_get_negotiated_curve();
      result = 0;
      *a2 = negotiated_curve;
    }
  }
  return result;
}

uint64_t SSLGetNumberOfECDSACurves(uint64_t a1, _DWORD *a2)
{
  uint64_t result;

  result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_DWORD *)(a1 + 248);
    }
  }
  return result;
}

uint64_t SSLGetECDSACurves(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;

  v3 = 4294967246;
  if (a1 && a2 && a3)
  {
    v4 = *(_DWORD *)(a1 + 248);
    if (*a3 >= v4)
    {
      if (v4)
      {
        v5 = 0;
        do
        {
          *(_DWORD *)(a2 + 4 * v5) = *(unsigned __int16 *)(*(_QWORD *)(a1 + 240) + 2 * v5);
          ++v5;
          v6 = *(unsigned int *)(a1 + 248);
        }
        while (v5 < v6);
      }
      else
      {
        LODWORD(v6) = 0;
      }
      v3 = 0;
      *a3 = v6;
    }
    else
    {
      return 4294967246;
    }
  }
  return v3;
}

uint64_t SSLSetECDSACurves(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result;
  unsigned int v7;
  BOOL v8;
  int v9;
  _WORD *v11;
  uint64_t v12;
  int v13;

  result = 4294967246;
  if (a1 && a2 && a3)
  {
    v7 = *(_DWORD *)(a1 + 80);
    v8 = v7 > 6;
    v9 = (1 << v7) & 0x59;
    if (v8 || v9 == 0)
    {
      return 4294966387;
    }
    else
    {
      v11 = malloc_type_malloc(2 * a3, 0xEFB4CC30uLL);
      *(_QWORD *)(a1 + 240) = v11;
      if (v11)
      {
        v12 = 0;
        do
        {
          v13 = *(_DWORD *)(a2 + 4 * v12);
          if (v13 > 65534)
            LOWORD(v13) = -1;
          v11[v12++] = v13;
        }
        while (a3 != v12);
        *(_DWORD *)(a1 + 248) = a3;
        tls_handshake_set_curves();
        return 0;
      }
      else
      {
        *(_DWORD *)(a1 + 248) = 0;
        return 4294967188;
      }
    }
  }
  return result;
}

uint64_t SSLGetNumberOfClientAuthTypes(uint64_t a1, _DWORD *a2)
{
  uint64_t result;

  if (!a1 || !*(_DWORD *)(a1 + 256))
    return 4294967246;
  result = 0;
  *a2 = *(_DWORD *)(a1 + 400);
  return result;
}

uint64_t SSLGetClientAuthTypes(uint64_t a1, void *__dst, _DWORD *a3)
{
  uint64_t result;

  if (!a1)
    return 4294967246;
  if (!*(_DWORD *)(a1 + 256))
    return 4294967246;
  memmove(__dst, *(const void **)(a1 + 408), 4 * *(unsigned int *)(a1 + 400));
  result = 0;
  *a3 = *(_DWORD *)(a1 + 400);
  return result;
}

uint64_t SSLGetNegotiatedClientAuthType()
{
  return 4294967292;
}

uint64_t SSLGetNumberOfSignatureAlgorithms(uint64_t a1)
{
  if (!a1)
    return 4294967246;
  tls_handshake_get_peer_signature_algorithms();
  return 0;
}

uint64_t SSLGetSignatureAlgorithms(uint64_t a1, void *a2, _DWORD *a3)
{
  const void *peer_signature_algorithms;
  uint64_t result;

  if (!a1)
    return 4294967246;
  peer_signature_algorithms = (const void *)tls_handshake_get_peer_signature_algorithms();
  memmove(a2, peer_signature_algorithms, 0x555555550uLL);
  result = 0;
  *a3 = -1431655766;
  return result;
}

uint64_t SSLSetPSKSharedSecret(uint64_t a1, const void *a2, size_t size)
{
  _QWORD *v6;
  void *v7;
  void *v8;
  void *v9;

  if (!a1)
    return 4294967246;
  v6 = (_QWORD *)(a1 + 480);
  v7 = *(void **)(a1 + 488);
  if (v7)
  {
    free(v7);
    *v6 = 0;
    v6[1] = 0;
  }
  v8 = malloc_type_malloc(size, 0xEFB4CC30uLL);
  if (v8)
  {
    v9 = v8;
    memmove(v8, a2, size);
    *(_QWORD *)(a1 + 480) = size;
    *(_QWORD *)(a1 + 488) = v9;
    tls_handshake_set_psk_secret();
    return 0;
  }
  else
  {
    *(_QWORD *)(a1 + 488) = 0;
    return 4294967188;
  }
}

uint64_t SSLSetPSKIdentity(uint64_t a1, const void *a2, size_t size)
{
  uint64_t result;
  void *v7;
  void *v8;
  void *v9;

  result = 4294967246;
  if (a1 && a2 && size)
  {
    v7 = *(void **)(a1 + 504);
    if (v7)
    {
      free(v7);
      *(_QWORD *)(a1 + 496) = 0;
      *(_QWORD *)(a1 + 504) = 0;
    }
    v8 = malloc_type_malloc(size, 0xEFB4CC30uLL);
    if (v8)
    {
      v9 = v8;
      memmove(v8, a2, size);
      *(_QWORD *)(a1 + 496) = size;
      *(_QWORD *)(a1 + 504) = v9;
      tls_handshake_set_psk_identity();
      return 0;
    }
    else
    {
      *(_QWORD *)(a1 + 504) = 0;
      return 4294967188;
    }
  }
  return result;
}

uint64_t SSLGetPSKIdentity(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;

  result = 4294967246;
  if (a1 && a2)
  {
    if (a3)
    {
      result = 0;
      v6 = a1 + 496;
      v5 = *(_QWORD *)(a1 + 496);
      *a2 = *(_QWORD *)(v6 + 8);
      *a3 = v5;
    }
  }
  return result;
}

uint64_t SSLInternal_PRF()
{
  return tls_handshake_internal_prf();
}

uint64_t tls_handshake_set_retransmit_timer_callback(uint64_t a1, int a2)
{
  double v3;

  if (a2)
    v3 = CFAbsoluteTimeGetCurrent() + (double)(1 << (a2 - 1)) * *(double *)(a1 + 424);
  else
    v3 = 0.0;
  *(double *)(a1 + 416) = v3;
  return 0;
}

uint64_t tls_handshake_delete_session_data_callback(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 64))
    return tls_cache_delete_session_data();
  else
    return 4294957492;
}

uint64_t tls_handshake_delete_all_sessions_callback(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 64))
    tls_cache_empty();
  return 0;
}

uint64_t tls_handshake_rollback_write_callback(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 40) + 32))(*(_QWORD *)(a1 + 48));
}

uint64_t SSLRollbackInternalRecordLayerWriteCipher()
{
  return tls_record_rollback_write_cipher();
}

void log_SecureTransport_early_fail(uint64_t a1)
{
  CFStringRef v1;
  CFStringRef v2;

  v1 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("com.apple.SecureTransport.early_fail.%ld"), a1);
  if (v1)
  {
    v2 = v1;
    SecCoreAnalyticsSendValue((uint64_t)v1, 1);
    CFRelease(v2);
  }
}

OSStatus SSLReHandshake(SSLContextRef context)
{
  unsigned int v1;

  if (!context)
    return -50;
  v1 = *((_DWORD *)context + 20) - 1;
  if (v1 < 6 && ((0x2Du >> v1) & 1) != 0)
    return dword_18AA5C430[v1];
  if (*((_DWORD *)context + 27) == 1)
    return SSLHandshakeStart((uint64_t)context);
  return tls_handshake_request_renegotiation();
}

uint64_t __get_extended_peer_id_block_invoke(uint64_t a1, uint64_t a2)
{
  return CC_SHA256_Update((CC_SHA256_CTX *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), *(const void **)(a2 + 16), *(_DWORD *)(a2 + 24));
}

uint64_t apply_block_1_6541(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

OSStatus SSLSetError(SSLContextRef context, OSStatus status)
{
  *((_DWORD *)context + 20) = 6;
  *((_DWORD *)context + 21) = status;
  return 0;
}

OSStatus SSLGetBufferedReadSize(SSLContextRef context, size_t *bufferSize)
{
  size_t v2;
  OSStatus result;

  if (!context)
    return -50;
  v2 = *((_QWORD *)context + 37);
  if (v2)
    v2 = *((_QWORD *)context + 36) - *((_QWORD *)context + 38);
  result = 0;
  *bufferSize = v2;
  return result;
}

BOOL SSLIsSessionNegotiatedWithUnsafeDH(_BOOL8 result)
{
  if (result)
    return tls_handshake_get_session_warning() == -49;
  return result;
}

uint64_t SSLCiphersuiteGroupToCiphersuiteList(int a1, _QWORD *a2)
{
  unsigned __int16 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  if ((a1 - 1) >= 4)
    v2 = 0;
  else
    v2 = a1;
  if (!a2)
    return 0;
  if (v2 > 4u)
  {
    v4 = 0;
    result = 0;
  }
  else
  {
    v3 = v2;
    v4 = qword_18AA5AB78[v2];
    result = (uint64_t)*(&off_1E1FCD898 + v3);
  }
  *a2 = v4;
  return result;
}

BOOL SSLCiphersuiteGroupContainsCiphersuite(int a1, int a2)
{
  _BOOL8 result;
  uint64_t v4;
  unsigned __int16 *v5;
  uint64_t v6;
  int v7;

  result = 0;
  if ((a1 - 1) >= 4)
    LOWORD(a1) = 0;
  if ((unsigned __int16)a1 <= 4u)
  {
    v4 = qword_18AA5AB78[(unsigned __int16)a1];
    v5 = (unsigned __int16 *)*(&off_1E1FCD898 + (unsigned __int16)a1);
    v6 = v4 - 1;
    do
    {
      v7 = *v5++;
      result = v7 == a2;
    }
    while (v7 != a2 && v6-- != 0);
  }
  return result;
}

uint64_t SSLProtocolGetVersionCodepoint(int a1)
{
  uint64_t v1;
  int *v2;
  int v3;

  v1 = 0;
  v2 = ssl_protocol_version_map;
  while (1)
  {
    v3 = *v2;
    v2 += 2;
    if (v3 == a1)
      break;
    if (++v1 == 8)
      return 0;
  }
  return LOWORD(ssl_protocol_version_map[2 * v1 + 1]);
}

uint64_t SSLCiphersuiteMinimumTLSVersion(int a1)
{
  uint64_t v1;
  __int16 *v2;
  int v3;
  int v4;
  uint64_t v5;
  __int16 *v6;
  int v7;

  v1 = 0;
  v2 = tls_ciphersuite_definitions;
  while (1)
  {
    v3 = (unsigned __int16)*v2;
    v2 += 35;
    if (v3 == a1)
      break;
    if (++v1 == 37)
    {
      v4 = 0;
      goto LABEL_6;
    }
  }
  v4 = (unsigned __int16)tls_ciphersuite_definitions[35 * v1 + 1];
LABEL_6:
  v5 = 0;
  v6 = &word_18AA5C44C;
  while (1)
  {
    v7 = (unsigned __int16)*v6;
    v6 += 4;
    if (v7 == v4)
      break;
    if (++v5 == 8)
      return 0;
  }
  return ssl_protocol_version_map[2 * v5];
}

uint64_t SSLCiphersuiteMaximumTLSVersion(int a1)
{
  uint64_t v1;
  __int16 *v2;
  int v3;
  int v4;
  uint64_t v5;
  __int16 *v6;
  int v7;

  v1 = 0;
  v2 = tls_ciphersuite_definitions;
  while (1)
  {
    v3 = (unsigned __int16)*v2;
    v2 += 35;
    if (v3 == a1)
      break;
    if (++v1 == 37)
    {
      v4 = 0;
      goto LABEL_6;
    }
  }
  v4 = (unsigned __int16)tls_ciphersuite_definitions[35 * v1 + 2];
LABEL_6:
  v5 = 0;
  v6 = &word_18AA5C44C;
  while (1)
  {
    v7 = (unsigned __int16)*v6;
    v6 += 4;
    if (v7 == v4)
      break;
    if (++v5 == 8)
      return 0;
  }
  return ssl_protocol_version_map[2 * v5];
}

OSStatus SSLGetNumberSupportedCiphers(SSLContextRef context, size_t *numCiphers)
{
  OSStatus result;

  result = -50;
  if (context)
  {
    if (numCiphers)
    {
      result = 0;
      *numCiphers = 67;
    }
  }
  return result;
}

OSStatus SSLGetSupportedCiphers(SSLContextRef context, SSLCipherSuite *ciphers, size_t *numCiphers)
{
  OSStatus result;
  uint64_t i;

  result = -50;
  if (context && ciphers && numCiphers)
  {
    if (*numCiphers >= 0x43)
    {
      for (i = 0; i != 67; ++i)
        ciphers[i] = STKnownCipherSuites[i];
      result = 0;
      *numCiphers = 67;
    }
    else
    {
      return -9817;
    }
  }
  return result;
}

OSStatus SSLSetEnabledCiphers(SSLContextRef context, const SSLCipherSuite *ciphers, size_t numCiphers)
{
  OSStatus result;
  unsigned int v7;
  BOOL v8;
  int v9;
  uint64_t v11;
  int v12;
  uint64_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  OSStatus v20;

  result = -50;
  if (context && ciphers && numCiphers)
  {
    v7 = *((_DWORD *)context + 20);
    v8 = v7 > 6;
    v9 = (0x10000010100uLL >> (8 * v7));
    if (!v8 && v9 == 0)
    {
      v11 = 0;
      v12 = 0;
      do
      {
        v13 = 0;
        while (STKnownCipherSuites[v13] != ciphers[v11])
        {
          if (++v13 == 67)
            goto LABEL_15;
        }
        ++v12;
LABEL_15:
        ++v11;
      }
      while (v11 != numCiphers);
      if (v12)
      {
        v14 = malloc_type_malloc(2 * v12, 0xEFB4CC30uLL);
        if (v14)
        {
          v15 = v14;
          v16 = 0;
          v17 = 0;
          do
          {
            v18 = 0;
            v19 = ciphers[v16];
            while ((unsigned __int16)STKnownCipherSuites[v18] != v19)
            {
              if (++v18 == 67)
                goto LABEL_24;
            }
            *((_WORD *)v14 + v17++) = v19;
LABEL_24:
            ++v16;
          }
          while (v16 != numCiphers);
          v20 = tls_handshake_set_ciphersuites();
          free(v15);
          return v20;
        }
        else
        {
          return -108;
        }
      }
      else
      {
        return -50;
      }
    }
    else
    {
      return -909;
    }
  }
  return result;
}

OSStatus SSLGetNumberEnabledCiphers(SSLContextRef context, size_t *numCiphers)
{
  OSStatus result;

  result = -50;
  if (context && numCiphers)
  {
    result = tls_handshake_get_ciphersuites();
    if (!result)
      *numCiphers = 2863311530;
  }
  return result;
}

OSStatus SSLGetEnabledCiphers(SSLContextRef context, SSLCipherSuite *ciphers, size_t *numCiphers)
{
  OSStatus result;
  SSLCipherSuite *v5;
  SSLCipherSuite *v7;
  uint64_t v8;
  SSLCipherSuite v9;

  result = -50;
  if (context)
  {
    v5 = ciphers;
    if (ciphers)
    {
      if (numCiphers)
      {
        result = tls_handshake_get_ciphersuites();
        if (!result)
        {
          if (*numCiphers >= 0xAAAAAAAA)
          {
            v7 = (SSLCipherSuite *)0xAAAAAAAAAAAAAAAALL;
            v8 = 2863311530;
            do
            {
              v9 = *v7++;
              *v5++ = v9;
              --v8;
            }
            while (v8);
            result = 0;
            *numCiphers = 2863311530;
          }
          else
          {
            return -9817;
          }
        }
      }
    }
  }
  return result;
}

OSStatus SSLSetSessionTicketsEnabled(SSLContextRef context, Boolean enabled)
{
  if (context)
    return tls_handshake_set_session_ticket_enabled();
  else
    return -50;
}

uint64_t SOSCCSetSOSDisabledError(CFTypeRef *a1)
{
  if (a1)
  {
    if (staticSOSDisabledError_onceToken != -1)
      dispatch_once(&staticSOSDisabledError_onceToken, &__block_literal_global_241);
    *a1 = CFRetain((CFTypeRef)staticSOSDisabledError_sosIsDisabledError);
  }
  return 1;
}

void __staticSOSDisabledError_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  SecCFCreateErrorWithFormat(1050, CFSTR("com.apple.security.sos.error"), 0, (CFTypeRef *)&staticSOSDisabledError_sosIsDisabledError, a5, CFSTR("SOS Disabled for this platform"), a7, a8, a9);
}

uint64_t SOSCCThisDeviceIsInCircle(CFTypeRef *a1)
{
  uint64_t result;

  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    result = SOSGetCachedCircleStatus(a1);
    if ((_DWORD)result == -99)
      return SOSCCThisDeviceIsInCircleNonCached(a1);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t SOSCCIsSOSTrustAndSyncingEnabled()
{
  NSObject *v0;
  NSObject *v1;
  uint64_t v2;
  NSObject *v3;
  const __CFString *v4;
  NSObject *v5;
  CFTypeRef v6;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  secLogObjForScope("sos-compatibility-mode");
  v0 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_18A900000, v0, OS_LOG_TYPE_DEBUG, "enter SOSCCIsSOSTrustAndSyncingEnabled", buf, 2u);
  }

  if (!OctagonIsSOSFeatureEnabled() || !SOSCompatibilityModeEnabled())
    return OctagonIsSOSFeatureEnabled();
  secLogObjForScope("sos-compatibility-mode");
  v1 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v1, OS_LOG_TYPE_DEFAULT, "SOS Compatibility Mode feature flag enabled, checking platform availability and sos compat mode", buf, 2u);
  }

  cf = 0;
  v2 = SOSCCFetchCompatibilityMode(&cf);
  secLogObjForScope("sos-compatibility-mode");
  v3 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = CFSTR("disabled");
    if ((_DWORD)v2)
      v4 = CFSTR("enabled");
    *(_DWORD *)buf = 138412290;
    v10 = v4;
    _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "sos trust and syncing is %@", buf, 0xCu);
  }

  if (cf)
  {
    secLogObjForScope("SecError");
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v10 = cf;
      _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "sos-compatibility-mode: fetching compatibility mode error: %@", buf, 0xCu);
    }

    v6 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v6);
    }
  }
  return v2;
}

uint64_t SOSCCThisDeviceIsInCircleNonCached(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __CFString *v15;
  NSObject *v16;
  _QWORD v18[5];
  uint8_t buf[4];
  __CFString *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCThisDeviceIsInCircleNonCached", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v20 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = __SOSCCThisDeviceIsInCircleNonCached_block_invoke;
    v18[3] = &__block_descriptor_40_e5_i8__0l;
    v18[4] = a1;
    v9 = __SOSCCThisDeviceIsInCircleNonCached_block_invoke((uint64_t)v18);
    v15 = SecLogAPICreate(0, "SOSCCThisDeviceIsInCircleNonCached", CFSTR("SOSCCStatus=%d"), v10, v11, v12, v13, v14, v9);
    secLogObjForScope("api_trace");
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v20 = v15;
      _os_log_debug_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v15)
      CFRelease(v15);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0xFFFFFFFFLL;
  }
  return v9;
}

BOOL xpc_dictionary_entry_is_type(void *a1)
{
  uint64_t v1;
  void *v2;
  _BOOL8 v3;

  xpc_dictionary_get_value(a1, "status");
  v1 = objc_claimAutoreleasedReturnValue();
  v2 = (void *)v1;
  if (v1)
    v3 = MEMORY[0x18D7718B8](v1) == MEMORY[0x1E0C81328];
  else
    v3 = 0;

  return v3;
}

uint64_t SOSCCFetchCompatibilityMode(CFTypeRef *a1)
{
  NSObject *v2;
  uint64_t (*v3)(CFTypeRef *);
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __CFString *v11;
  NSObject *v12;
  uint8_t buf[4];
  __CFString *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  secLogObjForScope("sos-compatibility-mode");
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEBUG, "enter SOSCCFetchCompatibilityMode", buf, 2u);
  }

  if (gSecurityd && (v3 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 656)) != 0)
    v4 = v3(a1);
  else
    v4 = simple_BOOL_error_request(0x5Bu, a1);
  v10 = v4;
  v11 = SecLogAPICreate(0, "SOSCCFetchCompatibilityMode", CFSTR("return=%d"), v5, v6, v7, v8, v9, v4);
  secLogObjForScope("api_trace");
  v12 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    v15 = v11;
    _os_log_debug_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v11)
    CFRelease(v11);
  return v10;
}

uint64_t simple_BOOL_error_request(unsigned int a1, CFTypeRef *a2)
{
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __simple_BOOL_error_request_block_invoke;
  v4[3] = &unk_1E1FD5DC0;
  v4[4] = &v5;
  securityd_send_sync_and_do(a1, a2, 0, (uint64_t)v4);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t SOSCCRequestToJoinCircle(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCRequestToJoinCircle", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 240)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_BOOL_error_request(0x32u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCRequestToJoinCircle", CFSTR("return=%d"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCRequestToJoinCircleAfterRestore(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCRequestToJoinCircleAfterRestore", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 248)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_BOOL_error_request(0x33u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCRequestToJoinCircleAfterRestore", CFSTR("return=%d"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCAccountHasPublicKey(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCAccountHasPublicKey", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 600)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_BOOL_error_request(0x55u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCAccountHasPublicKey", CFSTR("return=%d"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCWaitForInitialSync(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCWaitForInitialSync", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 544)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_BOOL_error_request(0x4Fu, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCWaitForInitialSync", CFSTR("return=%d"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCAccountSetToNew(CFTypeRef *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFString *v8;
  NSObject *v9;
  uint64_t (*v10)(CFTypeRef *);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  NSObject *v19;
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("SecWarning");
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "SOSCCAccountSetToNew called", buf, 2u);
    }

    v8 = SecLogAPICreate(0, "SOSCCAccountSetToNew", 0, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v8;
      _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8)
      CFRelease(v8);
    if (gSecurityd && (v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 256)) != 0)
      v11 = v10(a1);
    else
      v11 = simple_BOOL_error_request(0x4Cu, a1);
    v17 = v11;
    v18 = SecLogAPICreate(0, "SOSCCAccountSetToNew", CFSTR("return=%d"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v18;
      _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18)
      CFRelease(v18);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t SOSCCResetToOffering(CFTypeRef *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFString *v8;
  NSObject *v9;
  uint64_t (*v10)(CFTypeRef *);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  NSObject *v19;
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("SecWarning");
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "SOSCCResetToOffering called", buf, 2u);
    }

    v8 = SecLogAPICreate(0, "SOSCCResetToOffering", 0, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v8;
      _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8)
      CFRelease(v8);
    if (gSecurityd && (v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 264)) != 0)
      v11 = v10(a1);
    else
      v11 = simple_BOOL_error_request(0x34u, a1);
    v17 = v11;
    v18 = SecLogAPICreate(0, "SOSCCResetToOffering", CFSTR("return=%d"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v18;
      _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18)
      CFRelease(v18);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t SOSCCResetToEmpty(CFTypeRef *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFString *v8;
  NSObject *v9;
  uint64_t (*v10)(CFTypeRef *);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  NSObject *v19;
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("SecWarning");
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "SOSCCResetToEmpty called", buf, 2u);
    }

    v8 = SecLogAPICreate(0, "SOSCCResetToEmpty", 0, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v8;
      _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8)
      CFRelease(v8);
    if (gSecurityd && (v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 272)) != 0)
      v11 = v10(a1);
    else
      v11 = simple_BOOL_error_request(0x35u, a1);
    v17 = v11;
    v18 = SecLogAPICreate(0, "SOSCCResetToEmpty", CFSTR("return=%d"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v18;
      _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18)
      CFRelease(v18);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t SOSCCRemovePeersFromCircle(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFString *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  _QWORD v20[6];
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v9 = SecLogAPICreate(0, "SOSCCRemovePeersFromCircle", 0, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v9;
      _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9)
      CFRelease(v9);
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __SOSCCRemovePeersFromCircle_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    v20[5] = a2;
    v11 = __SOSCCRemovePeersFromCircle_block_invoke((uint64_t)v20);
    v17 = SecLogAPICreate(0, "SOSCCRemovePeersFromCircle", CFSTR("return=%d"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t info_array_to_BOOL_error_request(unsigned int a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v3;
  _QWORD v5[5];
  _QWORD v6[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v5[4] = &v7;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __info_array_to_BOOL_error_request_block_invoke;
  v6[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  v6[4] = a2;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __info_array_to_BOOL_error_request_block_invoke_2;
  v5[3] = &unk_1E1FD5DC0;
  securityd_send_sync_and_do(a1, a3, (uint64_t)v6, (uint64_t)v5);
  v3 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t SOSCCRemoveThisDeviceFromCircle(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCRemoveThisDeviceFromCircle", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 320)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_BOOL_error_request(0x38u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCRemoveThisDeviceFromCircle", CFSTR("return=%d"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCLoggedIntoAccount(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCLoggedIntoAccount", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 336)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_BOOL_error_request(0x3Au, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCLoggedIntoAccount", CFSTR("return=%d"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCLoggedOutOfAccount(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCLoggedOutOfAccount", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 344)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_BOOL_error_request(0x3Bu, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCLoggedOutOfAccount", CFSTR("return=%d"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCBailFromCircle_BestEffort(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFString *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  _QWORD v20[6];
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v9 = SecLogAPICreate(0, "SOSCCBailFromCircle_BestEffort", 0, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v9;
      _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9)
      CFRelease(v9);
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __SOSCCBailFromCircle_BestEffort_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    v20[5] = a2;
    v11 = __SOSCCBailFromCircle_BestEffort_block_invoke((uint64_t)v20);
    v17 = SecLogAPICreate(0, "SOSCCBailFromCircle_BestEffort", CFSTR("return=%d"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t SOSCCCopyPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCCopyPeerPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 448)) != 0)
      v10 = v9(a1);
    else
      v10 = array_of_info_error_request(0x43u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCCopyPeerPeerInfo", CFSTR("return=%@"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t array_of_info_error_request(unsigned int a1, CFTypeRef *a2)
{
  const void *v3;
  CFTypeID v4;
  CFTypeID TypeID;
  uint64_t *v6;
  uint64_t v7;
  const void *v8;
  uint64_t v9;
  _QWORD v11[5];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = __array_of_info_error_request_block_invoke;
  v11[3] = &unk_1E1FD5DC0;
  v11[4] = &v12;
  securityd_send_sync_and_do(a1, a2, 0, (uint64_t)v11);
  v3 = (const void *)v13[3];
  if (v3)
  {
    v4 = CFGetTypeID(v3);
    TypeID = CFArrayGetTypeID();
    v6 = v13;
    if (v4 == TypeID)
      goto LABEL_7;
    v7 = v13[3];
  }
  else
  {
    v7 = 0;
  }
  SOSErrorCreate(1040, a2, 0, CFSTR("Expected array, got: %@"), v7);
  v6 = v13;
  v8 = (const void *)v13[3];
  if (v8)
  {
    v13[3] = 0;
    CFRelease(v8);
    v6 = v13;
  }
LABEL_7:
  v9 = v6[3];
  _Block_object_dispose(&v12, 8);
  return v9;
}

void sub_18A9C5BEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __array_of_info_error_request_block_invoke(uint64_t a1, xpc_object_t xdict, CFTypeRef *a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  _BOOL8 v14;

  xpc_dictionary_get_value(xdict, "status");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v13 = v6;
  if (xdict && v6)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CreateArrayOfPeerInfoWithXPCObject(v6, a3, v7, v8, v9, v10, v11, v12);
  v14 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;

  return v14;
}

uint64_t SOSCCCopyConcurringPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCCopyConcurringPeerPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 456)) != 0)
      v10 = v9(a1);
    else
      v10 = array_of_info_error_request(0x44u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCCopyConcurringPeerPeerInfo", CFSTR("return=%@"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCCopyGenerationPeerInfo(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __CFString *v15;
  NSObject *v16;
  _QWORD v18[5];
  uint8_t buf[4];
  __CFString *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCCopyGenerationPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v20 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = __SOSCCCopyGenerationPeerInfo_block_invoke;
    v18[3] = &__block_descriptor_40_e17_____CFArray__8__0l;
    v18[4] = a1;
    v9 = __SOSCCCopyGenerationPeerInfo_block_invoke((uint64_t)v18);
    v15 = SecLogAPICreate(0, "SOSCCCopyGenerationPeerInfo", CFSTR("return=%@"), v10, v11, v12, v13, v14, v9);
    secLogObjForScope("api_trace");
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v20 = v15;
      _os_log_debug_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v15)
      CFRelease(v15);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v9;
}

void sub_18A9C6118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __simple_array_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  void *v3;
  _BOOL8 v4;

  xpc_dictionary_get_value(xdict, "status");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
  v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;

  return v4;
}

uint64_t SOSCCCopyApplicantPeerInfo(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCCopyApplicantPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 400)) != 0)
      v10 = v9(a1);
    else
      v10 = array_of_info_error_request(0x3Fu, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCCopyApplicantPeerInfo", CFSTR("return=%@"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCValidateUserPublic(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCValidateUserPublic", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 384)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_BOOL_error_request(0x41u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCValidateUserPublic", 0, v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCCopyValidPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCCopyValidPeerPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 408)) != 0)
      v10 = v9(a1);
    else
      v10 = array_of_info_error_request(0x40u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCCopyValidPeerPeerInfo", CFSTR("return=%@"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCCopyNotValidPeerPeerInfo(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCCopyNotValidPeerPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 416)) != 0)
      v10 = v9(a1);
    else
      v10 = array_of_info_error_request(0x42u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCCopyNotValidPeerPeerInfo", CFSTR("return=%@"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCCopyRetirementPeerInfo(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCCopyRetirementPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 424)) != 0)
      v10 = v9(a1);
    else
      v10 = array_of_info_error_request(0x48u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCCopyRetirementPeerInfo", CFSTR("return=%@"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCCopyViewUnawarePeerInfo(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCCopyViewUnawarePeerInfo", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 432)) != 0)
      v10 = v9(a1);
    else
      v10 = array_of_info_error_request(0x49u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCCopyViewUnawarePeerInfo", CFSTR("return=%@"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCCopyMyPeerInfo(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCCopyMyPeerInfo", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 536)) != 0)
      v10 = v9(a1);
    else
      v10 = peer_info_error_request(0x4Bu, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCCopyMyPeerInfo", CFSTR("return=%@"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t peer_info_error_request(unsigned int a1, CFTypeRef *a2)
{
  const void *v3;
  CFTypeID v4;
  CFTypeID TypeID;
  const __CFData *v6;
  uint64_t v7;
  const void *v8;
  _QWORD v10[5];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v14 = 0;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = __peer_info_error_request_block_invoke;
  v10[3] = &unk_1E1FD5DC0;
  v10[4] = &v11;
  securityd_send_sync_and_do(a1, a2, 0, (uint64_t)v10);
  v3 = (const void *)v12[3];
  if (v3)
  {
    v4 = CFGetTypeID(v3);
    TypeID = CFDataGetTypeID();
    v6 = (const __CFData *)v12[3];
    if (v4 == TypeID)
    {
      v7 = SOSPeerInfoCreateFromData(TypeID, a2, v6);
      goto LABEL_6;
    }
  }
  else
  {
    v6 = 0;
  }
  SOSErrorCreate(1040, a2, 0, CFSTR("Expected CFData, got: %@"), v6);
  v7 = 0;
LABEL_6:
  v8 = (const void *)v12[3];
  if (v8)
  {
    v12[3] = 0;
    CFRelease(v8);
  }
  _Block_object_dispose(&v11, 8);
  return v7;
}

void sub_18A9C6E60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __peer_info_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4;
  void *v5;
  _BOOL8 v6;

  xpc_dictionary_get_value(xdict, "status");
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = (void *)v4;
  if (xdict && v4)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;

  return v6;
}

void SOSCCForEachEngineStateAsStringFromArray(const __CFArray *a1, void *a2)
{
  id v3;
  _QWORD context[4];
  id v5;
  CFRange v6;

  v3 = a2;
  if (SOSCCIsSOSTrustAndSyncingEnabled())
  {
    context[0] = MEMORY[0x1E0C809B0];
    context[1] = 3221225472;
    context[2] = __SOSCCForEachEngineStateAsStringFromArray_block_invoke;
    context[3] = &unk_1E1FD4C58;
    v5 = v3;
    v6.length = CFArrayGetCount(a1);
    v6.location = 0;
    CFArrayApplyFunction(a1, v6, (CFArrayApplierFunction)apply_block_1_6781, context);

  }
}

uint64_t apply_block_1_6781(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t SOSCCForEachEngineStateAsString(CFTypeRef *a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFString *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  _QWORD v20[5];
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v3 = a2;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0 && (SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v9 = SecLogAPICreate(0, "SOSCCCopyEngineState", 0, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v9;
      _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9)
      CFRelease(v9);
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __SOSCCCopyEngineState_block_invoke;
    v20[3] = &__block_descriptor_40_e17_____CFArray__8__0l;
    v20[4] = a1;
    v11 = __SOSCCCopyEngineState_block_invoke((uint64_t)v20);
    v17 = SecLogAPICreate(0, "SOSCCCopyEngineState", CFSTR("return=%@"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
    if (v11)
    {
      SOSCCForEachEngineStateAsStringFromArray((const __CFArray *)v11, v3);
      CFRelease((CFTypeRef)v11);
      v11 = 1;
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    v11 = 0;
  }

  return v11;
}

void sub_18A9C759C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __der_array_error_request_block_invoke(uint64_t a1, xpc_object_t xdict, CFTypeRef *a3)
{
  const void *data;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t length;

  length = 0;
  data = xpc_dictionary_get_data(xdict, "status", &length);
  der_decode_plist(*MEMORY[0x1E0C9AE00], *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, a3, (uint64_t)data, (uint64_t)data + length, v6, v7, v8);
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t SOSCCAcceptApplicants(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFString *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  _QWORD v20[6];
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v9 = SecLogAPICreate(0, "SOSCCAcceptApplicants", 0, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v9;
      _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9)
      CFRelease(v9);
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __SOSCCAcceptApplicants_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    v20[5] = a2;
    v11 = __SOSCCAcceptApplicants_block_invoke((uint64_t)v20);
    v17 = SecLogAPICreate(0, "SOSCCAcceptApplicants", CFSTR("return=%d"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t SOSCCRejectApplicants(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFString *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  _QWORD v20[6];
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v9 = SecLogAPICreate(0, "SOSCCRejectApplicants", CFSTR("applicants=%@"), v4, v5, v6, v7, v8, a1);
    secLogObjForScope("api_trace");
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v9;
      _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9)
      CFRelease(v9);
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __SOSCCRejectApplicants_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    v20[5] = a2;
    v11 = __SOSCCRejectApplicants_block_invoke((uint64_t)v20);
    v17 = SecLogAPICreate(0, "SOSCCRejectApplicants", CFSTR("return=%d"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t SOSCCCopyMyPeerWithNewDeviceRecoverySecret(const __CFData *a1, CFTypeRef *a2)
{
  NSObject *v4;
  __CFData *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __CFString *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __CFString *v20;
  NSObject *v21;
  NSObject *v22;
  uint8_t v24[4];
  __CFString *v25;
  __int128 buf;
  uint64_t (*v27)(uint64_t);
  void *v28;
  __CFData *v29;
  CFTypeRef *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  secLogObjForScope("devRecovery");
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "Enter SOSCCCopyMyPeerWithNewDeviceRecoverySecret()", (uint8_t *)&buf, 2u);
  }

  v5 = SOSCopyDeviceBackupPublicKey(a1, a2);
  secLogObjForScope("devRecovery");
  v6 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(_QWORD *)((char *)&buf + 4) = v5;
    _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "SOSCopyDeviceBackupPublicKey (%@)", (uint8_t *)&buf, 0xCu);
  }

  if (v5)
  {
    if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
    {
      v12 = SecLogAPICreate(0, "SOSSetNewPublicBackupKey", 0, v7, v8, v9, v10, v11, 0);
      secLogObjForScope("api_trace");
      v13 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf) = 138412290;
        *(_QWORD *)((char *)&buf + 4) = v12;
        _os_log_debug_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&buf, 0xCu);
      }

      if (v12)
        CFRelease(v12);
      *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
      *((_QWORD *)&buf + 1) = 3221225472;
      v27 = __SOSSetNewPublicBackupKey_block_invoke;
      v28 = &__block_descriptor_48_e27_____OpaqueSOSPeerInfo__8__0l;
      v29 = v5;
      v30 = a2;
      v14 = __SOSSetNewPublicBackupKey_block_invoke((uint64_t)&buf);
      v20 = SecLogAPICreate(0, "SOSSetNewPublicBackupKey", CFSTR("return=%@"), v15, v16, v17, v18, v19, v14);
      secLogObjForScope("api_trace");
      v21 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)v24 = 138412290;
        v25 = v20;
        _os_log_debug_impl(&dword_18A900000, v21, OS_LOG_TYPE_DEBUG, "%@", v24, 0xCu);
      }

      if (v20)
        CFRelease(v20);
      goto LABEL_19;
    }
    SOSCCSetSOSDisabledError(a2);
  }
  v14 = 0;
LABEL_19:
  secLogObjForScope("devRecovery");
  v22 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(_QWORD *)((char *)&buf + 4) = v14;
    _os_log_impl(&dword_18A900000, v22, OS_LOG_TYPE_DEFAULT, "SOSSetNewPublicBackupKey (%@)", (uint8_t *)&buf, 0xCu);
  }

  if (v5)
    CFRelease(v5);
  return v14;
}

void sub_18A9C7E5C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

BOOL __data_to_peer_info_error_request_block_invoke(uint64_t a1, void *a2)
{
  id v2;
  void *v3;

  v2 = a2;
  v3 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  if (v3)
  {
    xpc_dictionary_set_value(v2, "newPublicBackupKey", v3);

  }
  return v3 != 0;
}

BOOL __data_to_peer_info_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4;
  void *v5;
  _BOOL8 v6;

  xpc_dictionary_get_value(xdict, "status");
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = (void *)v4;
  if (xdict && v4)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;

  return v6;
}

uint64_t SOSCCRegisterSingleRecoverySecret(uint64_t a1, char a2, CFTypeRef *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __CFString *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __CFString *v19;
  NSObject *v20;
  _QWORD v22[6];
  char v23;
  uint8_t buf[4];
  __CFString *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v11 = SecLogAPICreate(0, "SOSCCRegisterSingleRecoverySecret", 0, v6, v7, v8, v9, v10, 0);
    secLogObjForScope("api_trace");
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v25 = v11;
      _os_log_debug_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v11)
      CFRelease(v11);
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3221225472;
    v22[2] = __SOSCCRegisterSingleRecoverySecret_block_invoke;
    v22[3] = &__block_descriptor_49_e5_B8__0l;
    v23 = a2;
    v22[4] = a1;
    v22[5] = a3;
    v13 = __SOSCCRegisterSingleRecoverySecret_block_invoke((uint64_t)v22);
    v19 = SecLogAPICreate(0, "SOSCCRegisterSingleRecoverySecret", CFSTR("return=%d"), v14, v15, v16, v17, v18, v13);
    secLogObjForScope("api_trace");
    v20 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v25 = v19;
      _os_log_debug_impl(&dword_18A900000, v20, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v19)
      CFRelease(v19);
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
  return v13;
}

uint64_t SOSCCRegisterRecoveryPublicKey(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFString *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  _QWORD v20[6];
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v9 = SecLogAPICreate(0, "SOSCCRegisterRecoveryPublicKey", 0, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v9;
      _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9)
      CFRelease(v9);
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __SOSCCRegisterRecoveryPublicKey_block_invoke;
    v20[3] = &__block_descriptor_48_e5_B8__0l;
    v20[4] = a1;
    v20[5] = a2;
    v11 = __SOSCCRegisterRecoveryPublicKey_block_invoke((uint64_t)v20);
    v17 = SecLogAPICreate(0, "SOSCCRegisterRecoveryPublicKey", CFSTR("return=%d"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t SOSCCCopyRecoveryPublicKey(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __CFString *v15;
  NSObject *v16;
  _QWORD v18[5];
  uint8_t buf[4];
  __CFString *v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCCopyRecoveryPublicKey", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v20 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 3221225472;
    v18[2] = __SOSCCCopyRecoveryPublicKey_block_invoke;
    v18[3] = &__block_descriptor_40_e16_____CFData__8__0l;
    v18[4] = a1;
    v9 = __SOSCCCopyRecoveryPublicKey_block_invoke((uint64_t)v18);
    v15 = SecLogAPICreate(0, "SOSCCCopyRecoveryPublicKey", CFSTR("return=%@"), v10, v11, v12, v13, v14, v9);
    secLogObjForScope("api_trace");
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v20 = v15;
      _os_log_debug_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v15)
      CFRelease(v15);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v9;
}

void sub_18A9C8810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __data_to_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4;
  void *v5;
  _BOOL8 v6;

  xpc_dictionary_get_value(xdict, "status");
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = (void *)v4;
  if (xdict && v4)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;

  return v6;
}

uint64_t SOSCCRegisterUserCredentials(__CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  NSObject *v6;
  int v8;
  __CFString *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("circleOps");
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 138412290;
      v9 = a1;
      _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "SOSCCRegisterUserCredentials - calling SOSCCSetUserCredentials for %@\n", (uint8_t *)&v8, 0xCu);
    }

    return SOSCCSetUserCredentials(a1, a2, a3);
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
}

uint64_t SOSCCSetUserCredentials(__CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __CFString *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __CFString *v20;
  NSObject *v21;
  _QWORD v23[7];
  uint8_t buf[4];
  __CFString *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("circleOps");
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v25 = a1;
      _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "SOSCCSetUserCredentials for %@\n", buf, 0xCu);
    }

    v12 = SecLogAPICreate(0, "SOSCCSetUserCredentials", CFSTR("user_label=%@"), v7, v8, v9, v10, v11, (char)a1);
    secLogObjForScope("api_trace");
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v25 = v12;
      _os_log_debug_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v12)
      CFRelease(v12);
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 3221225472;
    v23[2] = __SOSCCSetUserCredentials_block_invoke;
    v23[3] = &__block_descriptor_56_e5_B8__0l;
    v23[4] = a1;
    v23[5] = a2;
    v23[6] = a3;
    v14 = __SOSCCSetUserCredentials_block_invoke(v23);
    v20 = SecLogAPICreate(0, "SOSCCSetUserCredentials", CFSTR("return=%d"), v15, v16, v17, v18, v19, v14);
    secLogObjForScope("api_trace");
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v25 = v20;
      _os_log_debug_impl(&dword_18A900000, v21, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v20)
      CFRelease(v20);
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
  return v14;
}

uint64_t SOSCCSetUserCredentialsAndDSID(__CFString *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __CFString *v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __CFString *v22;
  NSObject *v23;
  _QWORD v25[8];
  uint8_t buf[4];
  __CFString *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("circleOps");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v27 = a1;
      _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "SOSCCSetUserCredentialsAndDSID for %@\n", buf, 0xCu);
    }

    v14 = SecLogAPICreate(0, "SOSCCSetUserCredentialsAndDSID", CFSTR("user_label=%@"), v9, v10, v11, v12, v13, (char)a1);
    secLogObjForScope("api_trace");
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v27 = v14;
      _os_log_debug_impl(&dword_18A900000, v15, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v14)
      CFRelease(v14);
    v25[0] = MEMORY[0x1E0C809B0];
    v25[1] = 3221225472;
    v25[2] = __SOSCCSetUserCredentialsAndDSID_block_invoke;
    v25[3] = &__block_descriptor_64_e5_B8__0l;
    v25[4] = a1;
    v25[5] = a2;
    v25[6] = a3;
    v25[7] = a4;
    v16 = __SOSCCSetUserCredentialsAndDSID_block_invoke((uint64_t)v25);
    v22 = SecLogAPICreate(0, "SOSCCSetUserCredentialsAndDSID", CFSTR("return=%d"), v17, v18, v19, v20, v21, v16);
    secLogObjForScope("api_trace");
    v23 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v27 = v22;
      _os_log_debug_impl(&dword_18A900000, v23, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v22)
      CFRelease(v22);
  }
  else
  {
    SOSCCSetSOSDisabledError(a4);
    return 0;
  }
  return v16;
}

uint64_t label_and_password_and_dsid_to_BOOL_error_request(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, CFTypeRef *a5)
{
  uint64_t v5;
  _QWORD v7[5];
  _QWORD v8[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v12 = 0;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = __label_and_password_and_dsid_to_BOOL_error_request_block_invoke;
  v8[3] = &__block_descriptor_56_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  v8[4] = a2;
  v8[5] = a4;
  v8[6] = a3;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 3221225472;
  v7[2] = __label_and_password_and_dsid_to_BOOL_error_request_block_invoke_4;
  v7[3] = &unk_1E1FD5DC0;
  v7[4] = &v9;
  securityd_send_sync_and_do(a1, a5, (uint64_t)v8, (uint64_t)v7);
  v5 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t SOSCCTryUserCredentialsAndDSID(uint64_t a1, uint64_t a2, const __CFString *a3, CFTypeRef *a4)
{
  NSObject *v8;
  const __CFString *v9;
  int v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    SOSCCSetSOSDisabledError(a4);
    return 0;
  }
  secLogObjForScope("sosops");
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v11 = 138412290;
    v12 = a1;
    _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "SOSCCTryUserCredentialsAndDSID!! %@\n", (uint8_t *)&v11, 0xCu);
  }

  if (!a1)
  {
    SOSErrorCreate(1045, a4, 0, CFSTR("user_label is nil"));
    return 0;
  }
  if (!a2)
  {
    SOSErrorCreate(1045, a4, 0, CFSTR("user_password is nil"));
    return 0;
  }
  if (a3)
    v9 = a3;
  else
    v9 = &stru_1E1FDD448;
  return SOSCCTryUserCredentialsAndDSID_internal(a1, a2, (uint64_t)v9, a4);
}

uint64_t SOSCCTryUserCredentialsAndDSID_internal(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __CFString *v14;
  NSObject *v15;
  _QWORD v17[8];
  uint8_t buf[4];
  __CFString *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 3221225472;
    v17[2] = __SOSCCTryUserCredentialsAndDSID_internal_block_invoke;
    v17[3] = &__block_descriptor_64_e5_B8__0l;
    v17[4] = a1;
    v17[5] = a2;
    v17[6] = a3;
    v17[7] = a4;
    v8 = __SOSCCTryUserCredentialsAndDSID_internal_block_invoke((uint64_t)v17);
    v14 = SecLogAPICreate(0, "SOSCCTryUserCredentialsAndDSID_internal", CFSTR("return=%d"), v9, v10, v11, v12, v13, v8);
    secLogObjForScope("api_trace");
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v19 = v14;
      _os_log_debug_impl(&dword_18A900000, v15, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v14)
      CFRelease(v14);
  }
  else
  {
    SOSCCSetSOSDisabledError(a4);
    return 0;
  }
  return v8;
}

uint64_t SOSCCTryUserCredentials(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
    return SOSCCTryUserCredentialsAndDSID_internal(a1, a2, 0, a3);
  SOSCCSetSOSDisabledError(a3);
  return 0;
}

uint64_t SOSCCCanAuthenticate(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCCanAuthenticate", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 216)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_BOOL_error_request(0x2Fu, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCCanAuthenticate", CFSTR("return=%d"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCPurgeUserCredentials(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCPurgeUserCredentials", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 224)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_BOOL_error_request(0x30u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCPurgeUserCredentials", CFSTR("return=%d"), v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t SOSCCGetLastDepartureReason(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCGetLastDepartureReason", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 464)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_int_error_request(0x46u, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCGetLastDepartureReason", 0, v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

uint64_t simple_int_error_request(unsigned int a1, CFTypeRef *a2)
{
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __simple_int_error_request_block_invoke;
  v4[3] = &unk_1E1FD5DC0;
  v4[4] = &v5;
  securityd_send_sync_and_do(a1, a2, 0, (uint64_t)v4);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

BOOL __simple_int_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  int64_t int64;

  int64 = xpc_dictionary_get_int64(xdict, "status");
  if (int64 == (int)int64)
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = int64;
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t SOSCCSetLastDepartureReason(int a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFString *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  _QWORD v20[5];
  int v21;
  uint8_t buf[4];
  __CFString *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v9 = SecLogAPICreate(0, "SOSCCSetLastDepartureReason", 0, v4, v5, v6, v7, v8, 0);
    secLogObjForScope("api_trace");
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v23 = v9;
      _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v9)
      CFRelease(v9);
    v20[0] = MEMORY[0x1E0C809B0];
    v20[1] = 3221225472;
    v20[2] = __SOSCCSetLastDepartureReason_block_invoke;
    v20[3] = &__block_descriptor_44_e5_B8__0l;
    v21 = a1;
    v20[4] = a2;
    v11 = __SOSCCSetLastDepartureReason_block_invoke((uint64_t)v20);
    v17 = SecLogAPICreate(0, "SOSCCSetLastDepartureReason", 0, v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v23 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v11;
}

uint64_t SOSCCProcessEnsurePeerRegistration(CFTypeRef *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFString *v8;
  NSObject *v9;
  uint64_t (*v10)(CFTypeRef *);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  NSObject *v19;
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("updates");
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "enter SOSCCProcessEnsurePeerRegistration", buf, 2u);
    }

    v8 = SecLogAPICreate(0, "SOSCCProcessEnsurePeerRegistration", 0, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v8;
      _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8)
      CFRelease(v8);
    if (gSecurityd && (v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 496)) != 0)
      v11 = v10(a1);
    else
      v11 = simple_BOOL_error_request(0x22u, a1);
    v17 = v11;
    v18 = SecLogAPICreate(0, "SOSCCProcessEnsurePeerRegistration", CFSTR("return=%d"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v18;
      _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18)
      CFRelease(v18);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t SOSCCProcessSyncWithPeers(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __CFString *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __CFString *v19;
  NSObject *v20;
  _QWORD v22[7];
  uint8_t buf[4];
  __CFString *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v11 = SecLogAPICreate(0, "SOSCCProcessSyncWithPeers", 0, v6, v7, v8, v9, v10, 0);
    secLogObjForScope("api_trace");
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v24 = v11;
      _os_log_debug_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v11)
      CFRelease(v11);
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3221225472;
    v22[2] = __SOSCCProcessSyncWithPeers_block_invoke;
    v22[3] = &__block_descriptor_56_e15_____CFSet__8__0l;
    v22[4] = a1;
    v22[5] = a2;
    v22[6] = a3;
    v13 = __SOSCCProcessSyncWithPeers_block_invoke(v22);
    v19 = SecLogAPICreate(0, "SOSCCProcessSyncWithPeers", 0, v14, v15, v16, v17, v18, v13);
    secLogObjForScope("api_trace");
    v20 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v24 = v19;
      _os_log_debug_impl(&dword_18A900000, v20, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v19)
      CFRelease(v19);
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
  return v13;
}

void sub_18A9CA3C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

size_t __cfset_cfset_to_cfset_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;

  v5 = a2;
  if (SecXPCDictionarySetPListWithRepair(v5, "cfset", *(const __CFString **)(a1 + 32), a3, v6, v7, v8, v9))v14 = SecXPCDictionarySetPListWithRepair(v5, "cfset2", *(const __CFString **)(a1 + 40), a3, v10, v11, v12, v13);
  else
    v14 = 0;

  return v14;
}

BOOL __cfset_cfset_to_cfset_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  CFTypeRef v5;
  const void *v6;
  CFTypeID v7;
  const void *v8;
  CFTypeID v9;
  CFStringRef v10;

  v5 = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(1, a2, "status", a3);
  v6 = v5;
  if (v5 && (v7 = CFGetTypeID(v5), v7 == CFSetGetTypeID()))
  {
    CFRetain(v6);
    v8 = v6;
  }
  else
  {
    if (a3)
      SecError(-50, a3, CFSTR("object %@ is not a set"), v6);
    if (!v6)
    {
      v8 = 0;
      goto LABEL_12;
    }
    v9 = CFGetTypeID(v6);
    v10 = CFCopyTypeIDDescription(v9);
    SecError(-50, a3, CFSTR("object for key %s not set but %@"), "status", v10);
    if (v10)
      CFRelease(v10);
    v8 = 0;
  }
  CFRelease(v6);
LABEL_12:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v8;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t SOSCCProcessSyncWithAllPeers(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFString *v7;
  NSObject *v8;
  uint64_t (*v9)(CFTypeRef *);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __CFString *v17;
  NSObject *v18;
  uint8_t buf[4];
  __CFString *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v7 = SecLogAPICreate(0, "SOSCCProcessSyncWithAllPeers", 0, v2, v3, v4, v5, v6, 0);
    secLogObjForScope("api_trace");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v7;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v7)
      CFRelease(v7);
    if (gSecurityd && (v9 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 488)) != 0)
      v10 = v9(a1);
    else
      v10 = simple_int_error_request(0x1Cu, a1);
    v16 = v10;
    v17 = SecLogAPICreate(0, "SOSCCProcessSyncWithAllPeers", 0, v11, v12, v13, v14, v15, v10);
    secLogObjForScope("api_trace");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v17;
      _os_log_debug_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v17)
      CFRelease(v17);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v16;
}

const __CFString *SOSCCGetStatusDescription(int a1)
{
  if ((a1 + 1) > 4)
    return CFSTR("Unknown Status");
  else
    return off_1E1FD5080[a1 + 1];
}

const __CFString *SOSCCGetViewResultDescription(unsigned int a1)
{
  if (a1 > 4)
    return CFSTR("Unknown View Status");
  else
    return off_1E1FD50A8[a1];
}

uint64_t SOSCCView(const void *a1, int a2, CFTypeRef *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFSet *V0SubviewSet;
  NSObject *v13;
  uint64_t v14;
  __CFString *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __CFString *v22;
  NSObject *v23;
  uint64_t v25;
  const __CFSet *SetFromBitmask;
  _QWORD v27[6];
  int v28;
  uint8_t buf[4];
  __CFString *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
  v6 = SOSVisibleKeychainNotAllowed();
  if (a1 && a2 == 1 && v6)
  {
    V0SubviewSet = (const __CFSet *)SOSViewsGetV0SubviewSet();
    if (CFSetContainsValue(V0SubviewSet, a1))
    {
      secLogObjForScope("views");
      v13 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, "Cannot enable visible keychain views due to profile restrictions", buf, 2u);
      }

      return 0;
    }
  }
  else if (a2 == 3 && SOSGetCachedCircleBitmask() < 0)
  {
    v25 = SOSCachedViewBitmask();
    if (!v25)
      return 2;
    SetFromBitmask = SOSViewCreateSetFromBitmask(v25);
    if (!SetFromBitmask)
      return 2;
    v22 = (__CFString *)SetFromBitmask;
    if (CFSetContainsValue(SetFromBitmask, a1))
      v14 = 1;
    else
      v14 = 2;
    goto LABEL_20;
  }
  v15 = SecLogAPICreate(0, "SOSCCView", 0, v7, v8, v9, v10, v11, 0);
  secLogObjForScope("api_trace");
  v16 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    v30 = v15;
    _os_log_debug_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v15)
    CFRelease(v15);
  v27[0] = MEMORY[0x1E0C809B0];
  v27[1] = 3221225472;
  v27[2] = __SOSCCView_block_invoke;
  v27[3] = &__block_descriptor_52_e5_i8__0l;
  v28 = a2;
  v27[4] = a1;
  v27[5] = a3;
  v14 = __SOSCCView_block_invoke((uint64_t)v27);
  v22 = SecLogAPICreate(0, "SOSCCView", CFSTR("SOSViewResultCode=%d"), v17, v18, v19, v20, v21, v14);
  secLogObjForScope("api_trace");
  v23 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    v30 = v22;
    _os_log_debug_impl(&dword_18A900000, v23, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v22)
LABEL_20:
    CFRelease(v22);
  return v14;
}

uint64_t __name_action_to_code_request_block_invoke(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  const __CFString *v5;
  id v6;
  _QWORD v8[4];
  id v9;
  _QWORD v10[5];

  v3 = a2;
  v4 = MEMORY[0x1E0C809B0];
  v5 = *(const __CFString **)(a1 + 32);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = __name_action_to_code_request_block_invoke_2;
  v8[3] = &unk_1E1FD4FD8;
  v9 = v3;
  v6 = v3;
  v10[0] = v4;
  v10[1] = 0x40000000;
  v10[2] = __CFStringPerformWithCString_block_invoke;
  v10[3] = &unk_1E1FDBF70;
  v10[4] = v8;
  CFStringPerformWithCStringAndLength(v5, (uint64_t)v10);
  xpc_dictionary_set_int64(v6, "viewactioncode", *(_QWORD *)(a1 + 40));

  return 1;
}

BOOL __name_action_to_code_request_block_invoke_3(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  _BOOL8 v5;

  v3 = a2;
  v4 = v3;
  if (v3 && xpc_dictionary_entry_is_type(v3))
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = xpc_dictionary_get_int64(v4, "status");
  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != *(unsigned __int16 *)(a1 + 40);

  return v5;
}

void __name_action_to_code_request_block_invoke_2(uint64_t a1, char *string)
{
  xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 32), "viewname", string);
}

uint64_t SOSCCViewSet(const __CFSet *a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  __CFString *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __CFString *v19;
  NSObject *v20;
  _QWORD v22[8];
  uint8_t buf[8];
  uint8_t *v24;
  uint64_t v25;
  char v26;
  uint8_t v27[4];
  __CFString *v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!SOSCCIsSOSTrustAndSyncingEnabled())
    return 0;
  v4 = SOSVisibleKeychainNotAllowed();
  if (a1 && v4 && CFSetGetCount(a1) && SOSViewSetIntersectsV0(a1))
  {
    secLogObjForScope("views");
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, "Cannot enable visible keychain views due to profile restrictions", buf, 2u);
    }

    return 0;
  }
  *(_QWORD *)buf = 0;
  v24 = buf;
  v25 = 0x2020000000;
  v26 = 0;
  v12 = SecLogAPICreate(0, "SOSCCViewSet", 0, v5, v6, v7, v8, v9, 0);
  secLogObjForScope("api_trace");
  v13 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)v27 = 138412290;
    v28 = v12;
    _os_log_debug_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEBUG, "%@", v27, 0xCu);
  }

  if (v12)
    CFRelease(v12);
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 3221225472;
  v22[2] = __SOSCCViewSet_block_invoke;
  v22[3] = &unk_1E1FD4DC0;
  v22[6] = a2;
  v22[7] = 0;
  v22[4] = buf;
  v22[5] = a1;
  v11 = __SOSCCViewSet_block_invoke(v22);
  v19 = SecLogAPICreate(0, "SOSCCViewSet", CFSTR("return=%d"), v14, v15, v16, v17, v18, v11);
  secLogObjForScope("api_trace");
  v20 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)v27 = 138412290;
    v28 = v19;
    _os_log_debug_impl(&dword_18A900000, v20, OS_LOG_TYPE_DEBUG, "%@", v27, 0xCu);
  }

  if (v19)
    CFRelease(v19);
  _Block_object_dispose(buf, 8);
  return v11;
}

void sub_18A9CAE64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SOSCCIsIcloudKeychainSyncing()
{
  uint64_t result;
  const void *v1[5];

  v1[4] = *(const void **)MEMORY[0x1E0C80C00];
  result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = CFSTR("WiFi");
    v1[1] = CFSTR("Passwords");
    v1[2] = CFSTR("CreditCards");
    v1[3] = CFSTR("OtherSyncable");
    return sosIsViewSetSyncing(4, v1);
  }
  return result;
}

BOOL sosIsViewSetSyncing(uint64_t a1, const void **a2)
{
  const void **v2;
  __CFString *Mutable;
  uint64_t v5;
  int v6;
  _BOOL8 v7;
  int v8;
  NSObject *v9;
  const __CFString *v10;
  _BOOL8 v11;
  uint64_t v12;
  char v13;
  unsigned int v14;
  unsigned int v15;
  NSObject *v16;
  const __CFString *v17;
  __CFString *v18;
  const char *v19;
  NSObject *v20;
  uint32_t v21;
  CFTypeRef v22;
  uint64_t v24;
  CFMutableSetRef SetFromBitmask;
  const __CFSet *v26;
  const void *v27;
  CFTypeRef cf;
  uint8_t buf[4];
  __CFString *v30;
  __int16 v31;
  const __CFString *v32;
  __int16 v33;
  CFTypeRef v34;
  __int16 v35;
  CFTypeRef v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  cf = 0;
  if (!a2)
    return 0;
  v2 = a2;
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppend(Mutable, CFSTR("|"));
  v5 = 0;
  do
  {
    CFStringAppend(Mutable, (CFStringRef)v2[v5]);
    CFStringAppend(Mutable, CFSTR("|"));
    ++v5;
  }
  while (a1 != v5);
  v6 = SOSCCThisDeviceIsInCircle(&cf);
  v7 = v6 == 0;
  if (v6)
  {
    v8 = v6;
    secLogObjForScope("viewCheck");
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if ((v8 + 1) > 4)
        v10 = CFSTR("Unknown Status");
      else
        v10 = off_1E1FD50D0[v8 + 1];
      *(_DWORD *)buf = 138412802;
      v30 = Mutable;
      v31 = 2112;
      v32 = v10;
      v33 = 2112;
      v34 = cf;
      v19 = "Checking view / circle status for %@:  SOSCCStatus: (%@)  Error: (%@)";
      v20 = v9;
      v21 = 32;
      goto LABEL_25;
    }
  }
  else
  {
    if (SOSGetCachedCircleBitmask() < 0)
    {
      v24 = SOSCachedViewBitmask();
      if (v24)
      {
        SetFromBitmask = SOSViewCreateSetFromBitmask(v24);
        if (SetFromBitmask)
        {
          v26 = SetFromBitmask;
          LOBYTE(v11) = 1;
          do
          {
            v27 = *v2++;
            v11 = (CFSetContainsValue(v26, v27) != 0) & v11;
            --a1;
          }
          while (a1);
          v22 = v26;
          goto LABEL_29;
        }
      }
    }
    v12 = 0;
    v13 = 1;
    do
    {
      while (1)
      {
        v14 = SOSCCView(v2[v12], 3, &cf);
        if (v14 == 1)
          break;
        v15 = v14;
        secLogObjForScope("viewCheck");
        v16 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          v17 = CFSTR("Unknown View Status");
          if (v15 <= 4)
            v17 = off_1E1FD50F8[v15];
          v18 = (__CFString *)v2[v12];
          *(_DWORD *)buf = 138413058;
          v30 = v18;
          v31 = 2112;
          v32 = CFSTR("InCircle");
          v33 = 2112;
          v34 = v17;
          v35 = 2112;
          v36 = cf;
          _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEFAULT, "Checking view / circle status for %@:  SOSCCStatus: (%@) SOSViewResultCode(%@) Error: (%@)", buf, 0x2Au);
        }

        v13 = 0;
        v11 = 0;
        if (++v12 == a1)
          goto LABEL_27;
      }
      ++v12;
    }
    while (a1 != v12);
    if ((v13 & 1) == 0)
    {
      v11 = 0;
      goto LABEL_27;
    }
    secLogObjForScope("viewCheck");
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v30 = Mutable;
      v19 = "Checking view / circle status for %@:  ENABLED";
      v20 = v9;
      v21 = 12;
LABEL_25:
      _os_log_impl(&dword_18A900000, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v21);
    }
  }

  v11 = v7;
LABEL_27:
  v22 = cf;
  if (!cf)
    goto LABEL_30;
  cf = 0;
LABEL_29:
  CFRelease(v22);
LABEL_30:
  if (Mutable)
    CFRelease(Mutable);
  return v11;
}

uint64_t SOSCCIsSafariSyncing()
{
  uint64_t result;
  const void *v1[3];

  v1[2] = *(const void **)MEMORY[0x1E0C80C00];
  result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = CFSTR("Passwords");
    v1[1] = CFSTR("CreditCards");
    return sosIsViewSetSyncing(2, v1);
  }
  return result;
}

uint64_t SOSCCIsAppleTVSyncing()
{
  uint64_t result;
  const void *v1[2];

  v1[1] = *(const void **)MEMORY[0x1E0C80C00];
  result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = CFSTR("AppleTV");
    return sosIsViewSetSyncing(1, v1);
  }
  return result;
}

uint64_t SOSCCIsHomeKitSyncing()
{
  uint64_t result;
  const void *v1[2];

  v1[1] = *(const void **)MEMORY[0x1E0C80C00];
  result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = CFSTR("HomeKit");
    return sosIsViewSetSyncing(1, v1);
  }
  return result;
}

uint64_t SOSCCIsWiFiSyncing()
{
  uint64_t result;
  const void *v1[2];

  v1[1] = *(const void **)MEMORY[0x1E0C80C00];
  result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = CFSTR("WiFi");
    return sosIsViewSetSyncing(1, v1);
  }
  return result;
}

uint64_t SOSCCIsContinuityUnlockSyncing()
{
  uint64_t result;
  const void *v1[2];

  v1[1] = *(const void **)MEMORY[0x1E0C80C00];
  result = SOSCCIsSOSTrustAndSyncingEnabled();
  if ((_DWORD)result)
  {
    v1[0] = CFSTR("ContinuityUnlock");
    return sosIsViewSetSyncing(1, v1);
  }
  return result;
}

uint64_t SOSCCCopyApplication(CFTypeRef *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFString *v8;
  NSObject *v9;
  uint64_t (*v10)(CFTypeRef *);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  NSObject *v19;
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("hsa2PB");
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "enter SOSCCCopyApplication applicant", buf, 2u);
    }

    v8 = SecLogAPICreate(0, "SOSCCCopyApplication", 0, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v8;
      _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8)
      CFRelease(v8);
    if (gSecurityd && (v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 560)) != 0)
      v11 = v10(a1);
    else
      v11 = peer_info_error_request(0x51u, a1);
    v17 = v11;
    v18 = SecLogAPICreate(0, "SOSCCCopyApplication", CFSTR("return=%@"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v18;
      _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18)
      CFRelease(v18);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t SOSCCCleanupKVSKeys(CFTypeRef *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFString *v8;
  NSObject *v9;
  uint64_t (*v10)(CFTypeRef *);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  NSObject *v19;
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("cleanup-keys");
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "enter SOSCCCleanupKVSKeys", buf, 2u);
    }

    v8 = SecLogAPICreate(0, "SOSCCCleanupKVSKeys", 0, v3, v4, v5, v6, v7, 0);
    secLogObjForScope("api_trace");
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v8;
      _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v8)
      CFRelease(v8);
    if (gSecurityd && (v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 592)) != 0)
      v11 = v10(a1);
    else
      v11 = simple_BOOL_error_request(0x54u, a1);
    v17 = v11;
    v18 = SecLogAPICreate(0, "SOSCCCleanupKVSKeys", CFSTR("return=%d"), v12, v13, v14, v15, v16, v11);
    secLogObjForScope("api_trace");
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v22 = v18;
      _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18)
      CFRelease(v18);
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
  return v17;
}

uint64_t SOSCCCopyCircleJoiningBlob(uint64_t a1, CFTypeRef *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFString *v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __CFString *v25;
  NSObject *v26;
  _QWORD v28[6];
  uint8_t buf[4];
  __CFString *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("hsa2PB");
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCCopyCircleJoiningBlob approver", buf, 2u);
    }

    v10 = SecLogAPICreate(0, "SOSCCCopyCircleJoiningBlob", 0, v5, v6, v7, v8, v9, 0);
    secLogObjForScope("api_trace");
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v30 = v10;
      _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10)
      CFRelease(v10);
    v28[0] = MEMORY[0x1E0C809B0];
    v28[1] = 3221225472;
    v28[2] = __SOSCCCopyCircleJoiningBlob_block_invoke;
    v28[3] = &__block_descriptor_48_e16_____CFData__8__0l;
    v28[4] = a1;
    v28[5] = a2;
    v19 = __SOSCCCopyCircleJoiningBlob_block_invoke((uint64_t)v28, v12, v13, v14, v15, v16, v17, v18);
    v25 = SecLogAPICreate(0, "SOSCCCopyCircleJoiningBlob", CFSTR("return=%@"), v20, v21, v22, v23, v24, v19);
    secLogObjForScope("api_trace");
    v26 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v30 = v25;
      _os_log_debug_impl(&dword_18A900000, v26, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v25)
      CFRelease(v25);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v19;
}

void sub_18A9CBDC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL __cfdata_error_request_returns_cfdata_block_invoke(uint64_t a1, void *a2)
{
  id v2;
  void *v3;

  v2 = a2;
  v3 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  if (v3)
  {
    xpc_dictionary_set_value(v2, "data", v3);

  }
  return v3 != 0;
}

BOOL __cfdata_error_request_returns_cfdata_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  uint64_t v6;
  void *v7;
  const void *v8;
  const void *v9;
  CFTypeID v10;
  _BOOL8 v11;

  xpc_dictionary_get_value(xdict, "status");
  v6 = objc_claimAutoreleasedReturnValue();
  v7 = (void *)v6;
  if (xdict && v6)
  {
    v8 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
    v9 = v8;
    if (v8)
    {
      v10 = CFGetTypeID(v8);
      if (v10 == CFDataGetTypeID())
      {
        CFRetain(v9);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v9;
LABEL_9:
        CFRelease(v9);
        goto LABEL_10;
      }
    }
    if (a3)
      SecError(-50, a3, CFSTR("object %@ is not a data"), v9);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    if (v9)
      goto LABEL_9;
  }
LABEL_10:
  v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;

  return v11;
}

uint64_t SOSCCCopyInitialSyncData(int a1, CFTypeRef *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFString *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  NSObject *v19;
  _QWORD v21[5];
  int v22;
  uint8_t buf[4];
  __CFString *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("circleJoin");
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCCopyInitialSyncData approver", buf, 2u);
    }

    v10 = SecLogAPICreate(0, "SOSCCCopyInitialSyncData", 0, v5, v6, v7, v8, v9, 0);
    secLogObjForScope("api_trace");
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v24 = v10;
      _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10)
      CFRelease(v10);
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 3221225472;
    v21[2] = __SOSCCCopyInitialSyncData_block_invoke;
    v21[3] = &__block_descriptor_44_e16_____CFData__8__0l;
    v22 = a1;
    v21[4] = a2;
    v12 = __SOSCCCopyInitialSyncData_block_invoke((uint64_t)v21);
    v18 = SecLogAPICreate(0, "SOSCCCopyInitialSyncData", CFSTR("return=%@"), v13, v14, v15, v16, v17, v12);
    secLogObjForScope("api_trace");
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v24 = v18;
      _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18)
      CFRelease(v18);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v12;
}

void sub_18A9CC274(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t __flags_to_data_error_request_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  xpc_dictionary_set_uint64(xdict, "flags", *(unsigned int *)(a1 + 32));
  return 1;
}

BOOL __flags_to_data_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  uint64_t v4;
  void *v5;
  _BOOL8 v6;

  xpc_dictionary_get_value(xdict, "status");
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = (void *)v4;
  if (xdict && v4)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = _CFXPCCreateCFObjectFromXPCObject();
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != 0;

  return v6;
}

uint64_t SOSCCJoinWithCircleJoiningBlob(uint64_t a1, int a2, CFTypeRef *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __CFString *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(_QWORD, _QWORD, _QWORD);
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __CFString *v27;
  NSObject *v28;
  _QWORD v30[6];
  int v31;
  uint8_t buf[4];
  __CFString *v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("hsa2PB");
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "enter SOSCCJoinWithCircleJoiningBlob applicant", buf, 2u);
    }

    v12 = SecLogAPICreate(0, "SOSCCJoinWithCircleJoiningBlob", 0, v7, v8, v9, v10, v11, 0);
    secLogObjForScope("api_trace");
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v33 = v12;
      _os_log_debug_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v12)
      CFRelease(v12);
    v30[0] = MEMORY[0x1E0C809B0];
    v30[1] = 3221225472;
    v30[2] = __SOSCCJoinWithCircleJoiningBlob_block_invoke;
    v30[3] = &__block_descriptor_52_e5_B8__0l;
    v31 = a2;
    v30[4] = a1;
    v30[5] = a3;
    v21 = __SOSCCJoinWithCircleJoiningBlob_block_invoke((uint64_t)v30, v14, v15, v16, v17, v18, v19, v20);
    v27 = SecLogAPICreate(0, "SOSCCJoinWithCircleJoiningBlob", CFSTR("return=%d"), v22, v23, v24, v25, v26, v21);
    secLogObjForScope("api_trace");
    v28 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v33 = v27;
      _os_log_debug_impl(&dword_18A900000, v28, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v27)
      CFRelease(v27);
  }
  else
  {
    SOSCCSetSOSDisabledError(a3);
    return 0;
  }
  return v21;
}

void sub_18A9CC724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SOSCCPeersHaveViewsEnabled(uint64_t a1, CFTypeRef *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFString *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  NSObject *v19;
  _QWORD v21[6];
  uint8_t buf[4];
  __CFString *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("view-enabled");
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCPeersHaveViewsEnabled", buf, 2u);
    }

    v10 = SecLogAPICreate(0, "SOSCCPeersHaveViewsEnabled", 0, v5, v6, v7, v8, v9, 0);
    secLogObjForScope("api_trace");
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v23 = v10;
      _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10)
      CFRelease(v10);
    v21[0] = MEMORY[0x1E0C809B0];
    v21[1] = 3221225472;
    v21[2] = __SOSCCPeersHaveViewsEnabled_block_invoke;
    v21[3] = &__block_descriptor_48_e19_____CFBoolean__8__0l;
    v21[4] = a1;
    v21[5] = a2;
    v12 = __SOSCCPeersHaveViewsEnabled_block_invoke((uint64_t)v21);
    v18 = SecLogAPICreate(0, "SOSCCPeersHaveViewsEnabled", CFSTR("return=%@"), v13, v14, v15, v16, v17, v12);
    secLogObjForScope("api_trace");
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v23 = v18;
      _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v18)
      CFRelease(v18);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v12;
}

size_t __cfarray_to_cfBOOLean_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SecXPCDictionarySetPListWithRepair(a2, "cfarray", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
}

uint64_t __cfarray_to_cfBOOLean_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = xpc_dictionary_get_BOOL(xdict, "status");
  return 1;
}

uint64_t SOSCCMessageFromPeerIsPending(uint64_t a1, CFTypeRef *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __CFString *v11;
  NSObject *v12;
  _QWORD v14[6];
  uint8_t buf[4];
  __CFString *v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    secLogObjForScope("pending-check");
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCMessageFromPeerIsPending", buf, 2u);
    }

    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __SOSCCMessageFromPeerIsPending_block_invoke;
    v14[3] = &__block_descriptor_48_e5_B8__0l;
    v14[4] = a1;
    v14[5] = a2;
    v5 = __SOSCCMessageFromPeerIsPending_block_invoke((uint64_t)v14);
    v11 = SecLogAPICreate(0, "SOSCCMessageFromPeerIsPending", CFSTR("return=%d"), v6, v7, v8, v9, v10, v5);
    secLogObjForScope("api_trace");
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v16 = v11;
      _os_log_debug_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v11)
      CFRelease(v11);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v5;
}

uint64_t peer_info_to_BOOL_error_request(unsigned int a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v3;
  _QWORD v5[5];
  _QWORD v6[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v5[4] = &v7;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __peer_info_to_BOOL_error_request_block_invoke;
  v6[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
  v6[4] = a2;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __peer_info_to_BOOL_error_request_block_invoke_2;
  v5[3] = &unk_1E1FD5DC0;
  securityd_send_sync_and_do(a1, a3, (uint64_t)v6, (uint64_t)v5);
  v3 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t SOSCCSendToPeerIsPending(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFString *v10;
  NSObject *v11;
  _QWORD v13[6];
  uint8_t buf[4];
  __CFString *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 3221225472;
    v13[2] = __SOSCCSendToPeerIsPending_block_invoke;
    v13[3] = &__block_descriptor_48_e5_B8__0l;
    v13[4] = a1;
    v13[5] = a2;
    v4 = __SOSCCSendToPeerIsPending_block_invoke((uint64_t)v13);
    v10 = SecLogAPICreate(0, "SOSCCSendToPeerIsPending", CFSTR("return=%d"), v5, v6, v7, v8, v9, v4);
    secLogObjForScope("api_trace");
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v15 = v10;
      _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
    }

    if (v10)
      CFRelease(v10);
  }
  else
  {
    SOSCCSetSOSDisabledError(a2);
    return 0;
  }
  return v4;
}

uint64_t SOSCCSetCompatibilityMode(char a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  NSObject *v19;
  _QWORD v21[5];
  char v22;
  uint8_t buf[4];
  __CFString *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  secLogObjForScope("sos-compatibility-mode");
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "enter SOSCCSetCompatibilityMode", buf, 2u);
  }

  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3221225472;
  v21[2] = __SOSCCSetCompatibilityMode_block_invoke;
  v21[3] = &__block_descriptor_41_e5_B8__0l;
  v22 = a1;
  v21[4] = a2;
  v12 = __SOSCCSetCompatibilityMode_block_invoke((uint64_t)v21, v5, v6, v7, v8, v9, v10, v11);
  v18 = SecLogAPICreate(0, "SOSCCSetCompatibilityMode", CFSTR("return=%d"), v13, v14, v15, v16, v17, v12);
  secLogObjForScope("api_trace");
  v19 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    v24 = v18;
    _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v18)
    CFRelease(v18);
  return v12;
}

void sub_18A9CD334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SOSCCFetchCompatibilityModeCachedValue(CFTypeRef *a1)
{
  NSObject *v2;
  uint64_t (*v3)(CFTypeRef *);
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __CFString *v11;
  NSObject *v12;
  uint8_t buf[4];
  __CFString *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  secLogObjForScope("sos-compatibility-mode-cached");
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEBUG, "enter SOSCCFetchCompatibilityModeCachedValue", buf, 2u);
  }

  if (gSecurityd && (v3 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 664)) != 0)
    v4 = v3(a1);
  else
    v4 = simple_BOOL_error_request(0x5Cu, a1);
  v10 = v4;
  v11 = SecLogAPICreate(0, "SOSCCFetchCompatibilityModeCachedValue", CFSTR("return=%d"), v5, v6, v7, v8, v9, v4);
  secLogObjForScope("api_trace");
  v12 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    v15 = v11;
    _os_log_debug_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v11)
    CFRelease(v11);
  return v10;
}

uint64_t SOSCCIsSOSTrustAndSyncingEnabledCachedValue()
{
  NSObject *v0;
  NSObject *v1;
  uint64_t v2;
  NSObject *v3;
  const __CFString *v4;
  NSObject *v5;
  CFTypeRef v6;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  secLogObjForScope("sos-compatibility-mode-cached");
  v0 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_18A900000, v0, OS_LOG_TYPE_DEBUG, "enter SOSCCIsSOSTrustAndSyncingEnabledCachedValue", buf, 2u);
  }

  if (!OctagonIsSOSFeatureEnabled() || !SOSCompatibilityModeEnabled())
    return OctagonIsSOSFeatureEnabled();
  secLogObjForScope("sos-compatibility-mode-cached");
  v1 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v1, OS_LOG_TYPE_DEFAULT, "SOS Compatibility Mode feature flag enabled, checking platform availability and sos compat mode", buf, 2u);
  }

  cf = 0;
  v2 = SOSCCFetchCompatibilityModeCachedValue(&cf);
  secLogObjForScope("sos-compatibility-mode-cached");
  v3 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = CFSTR("disabled");
    if ((_DWORD)v2)
      v4 = CFSTR("enabled");
    *(_DWORD *)buf = 138412290;
    v10 = v4;
    _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "sos trust and syncing is %@", buf, 0xCu);
  }

  if (cf)
  {
    secLogObjForScope("SecError");
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      v10 = cf;
      _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "sos-compatibility-mode-cached: fetching compatibility mode error: %@", buf, 0xCu);
    }

    v6 = cf;
    if (cf)
    {
      cf = 0;
      CFRelease(v6);
    }
  }
  return v2;
}

uint64_t SOSCCPushResetCircle(CFTypeRef *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFString *v8;
  NSObject *v9;
  uint64_t (*v10)(CFTypeRef *);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  NSObject *v19;
  uint8_t buf[4];
  __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  secLogObjForScope("push-reset-circle-to-kvs");
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEBUG, "enter SOSCCPushResetCircle", buf, 2u);
  }

  v8 = SecLogAPICreate(0, "SOSCCPushResetCircle", 0, v3, v4, v5, v6, v7, 0);
  secLogObjForScope("api_trace");
  v9 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    v22 = v8;
    _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v8)
    CFRelease(v8);
  if (gSecurityd && (v10 = *(uint64_t (**)(CFTypeRef *))(gSecurityd + 672)) != 0)
    v11 = v10(a1);
  else
    v11 = simple_BOOL_error_request(0x5Du, a1);
  v17 = v11;
  v18 = SecLogAPICreate(0, "SOSCCPushResetCircle", CFSTR("return=%d"), v12, v13, v14, v15, v16, v11);
  secLogObjForScope("api_trace");
  v19 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    v22 = v18;
    _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
  }

  if (v18)
    CFRelease(v18);
  return v17;
}

void SOSCCAccountGetPublicKey(void *a1)
{
  id v1;
  void (*v2)(void);
  void *v3;
  CFTypeRef v4;
  CFTypeRef v5;
  void *v6;
  CFTypeRef cf;

  v1 = a1;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) == 0)
  {
    sosDisabledNSError();
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    (*((void (**)(id, _QWORD, _QWORD, void *))v1 + 2))(v1, 0, 0, v3);
    goto LABEL_15;
  }
  cf = 0;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    if (gSecurityd && (v2 = *(void (**)(void))(gSecurityd + 680)) != 0)
    {
      v2();
      v3 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v3)
      {
LABEL_6:
        v4 = 0;
        goto LABEL_9;
      }
    }
    else
    {
      if (SOSCCGetStatusObject_onceToken != -1)
        dispatch_once(&SOSCCGetStatusObject_onceToken, &__block_literal_global_272);
      objc_msgSend((id)SOSCCGetStatusObject_control, "connection");
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "remoteObjectProxy");
      v3 = (void *)objc_claimAutoreleasedReturnValue();

      if (!v3)
        goto LABEL_6;
    }
    objc_msgSend(v3, "userPublicKey:", v1);
LABEL_15:

    goto LABEL_16;
  }
  SOSCCSetSOSDisabledError(&cf);
  v4 = cf;
LABEL_9:
  (*((void (**)(id, _QWORD, _QWORD, CFTypeRef))v1 + 2))(v1, 0, 0, v4);
  v5 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v5);
  }
LABEL_16:

}

id sosDisabledNSError()
{
  if (staticSOSDisabledError_onceToken != -1)
    dispatch_once(&staticSOSDisabledError_onceToken, &__block_literal_global_241);
  return (id)staticSOSDisabledError_sosIsDisabledError;
}

void SOSCCAccountGetKeyCircleGeneration(void *a1)
{
  id v1;
  void *v2;
  _QWORD v3[4];
  id v4;

  v1 = a1;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __SOSCCAccountGetKeyCircleGeneration_block_invoke;
    v3[3] = &unk_1E1FD4EC0;
    v4 = v1;
    SOSCCAccountGetPublicKey(v3);

  }
  else
  {
    sosDisabledNSError();
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    (*((void (**)(id, _QWORD, void *))v1 + 2))(v1, 0, v2);

  }
}

id SOSCCCircleHash(_QWORD *a1)
{
  void *v2;
  void *v3;
  id v4;
  const void *v6;
  _QWORD v7[5];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t);
  void (*v12)(uint64_t);
  id v13;
  void *v14;

  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v14 = 0;
    SOSCCGetSynchronousStatusObject((CFTypeRef *)&v14);
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    v3 = v2;
    if (v2)
    {
      v8 = 0;
      v9 = &v8;
      v10 = 0x3032000000;
      v11 = __Block_byref_object_copy__6944;
      v12 = __Block_byref_object_dispose__6945;
      v13 = 0;
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = __SOSCCCircleHash_block_invoke;
      v7[3] = &unk_1E1FD4EE8;
      v7[4] = &v8;
      objc_msgSend(v2, "circleHash:", v7);
      v4 = (id)v9[5];
      _Block_object_dispose(&v8, 8);

    }
    else
    {
      if (a1)
        *a1 = objc_retainAutorelease(v14);
      v6 = v14;
      if (v14)
      {
        v14 = 0;
        CFRelease(v6);
      }
      v4 = 0;
    }

  }
  else
  {
    if (a1)
    {
      sosDisabledNSError();
      *a1 = (id)objc_claimAutoreleasedReturnValue();
      return 0;
    }
    v4 = 0;
  }
  return v4;
}

void sub_18A9CDD68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id SOSCCGetSynchronousStatusObject(CFTypeRef *a1)
{
  void (*v2)(void);
  void *v4;
  void *v5;
  const void *v6;
  _QWORD v7[5];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t);
  void (*v12)(uint64_t);
  id v13;

  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    if (gSecurityd && (v2 = *(void (**)(void))(gSecurityd + 680)) != 0)
    {
      v2();
      return (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      if (SOSCCGetSynchronousStatusObject_onceToken != -1)
        dispatch_once(&SOSCCGetSynchronousStatusObject_onceToken, &__block_literal_global_274);
      v8 = 0;
      v9 = &v8;
      v10 = 0x3032000000;
      v11 = __Block_byref_object_copy__6944;
      v12 = __Block_byref_object_dispose__6945;
      v13 = 0;
      objc_msgSend((id)SOSCCGetSynchronousStatusObject_control, "connection");
      v4 = (void *)objc_claimAutoreleasedReturnValue();
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = __SOSCCGetSynchronousStatusObject_block_invoke_2;
      v7[3] = &unk_1E1FD8560;
      v7[4] = &v8;
      objc_msgSend(v4, "synchronousRemoteObjectProxyWithErrorHandler:", v7);
      v5 = (void *)objc_claimAutoreleasedReturnValue();

      if (a1)
      {
        v6 = (const void *)v9[5];
        if (v6)
          *a1 = v6;
      }
      _Block_object_dispose(&v8, 8);

      return v5;
    }
  }
  else
  {
    SOSCCSetSOSDisabledError(a1);
    return 0;
  }
}

void sub_18A9CDEC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__6944(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__6945(uint64_t a1)
{

}

void SOSCCGhostBust(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  NSObject *v5;
  CFTypeRef v6;
  _QWORD v7[4];
  id v8;
  uint8_t buf[8];
  CFTypeRef v10;

  v3 = a2;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v10 = 0;
    SOSCCGetSynchronousStatusObject(&v10);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    if (v4)
    {
      secLogObjForScope("ghostbust");
      v5 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "API Called", buf, 2u);
      }

      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = __SOSCCGhostBust_block_invoke;
      v7[3] = &unk_1E1FD6060;
      v8 = v3;
      objc_msgSend(v4, "ghostBust:complete:", a1, v7);

    }
    else
    {
      (*((void (**)(id, _QWORD, CFTypeRef))v3 + 2))(v3, 0, v10);
      v6 = v10;
      if (v10)
      {
        v10 = 0;
        CFRelease(v6);
      }
    }
  }
  else
  {
    sosDisabledNSError();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    (*((void (**)(id, _QWORD, void *))v3 + 2))(v3, 0, v4);
  }

}

void SOSCCGhostBustTriggerTimed(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  NSObject *v5;
  CFTypeRef v6;
  _QWORD v7[4];
  id v8;
  uint8_t buf[8];
  CFTypeRef v10;

  v3 = a2;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v10 = 0;
    SOSCCGetSynchronousStatusObject(&v10);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    if (v4)
    {
      secLogObjForScope("ghostbust");
      v5 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "API Trigger Timed Called", buf, 2u);
      }

      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 3221225472;
      v7[2] = __SOSCCGhostBustTriggerTimed_block_invoke;
      v7[3] = &unk_1E1FD6060;
      v8 = v3;
      objc_msgSend(v4, "ghostBustTriggerTimed:complete:", a1, v7);

    }
    else
    {
      (*((void (**)(id, _QWORD, CFTypeRef))v3 + 2))(v3, 0, v10);
      v6 = v10;
      if (v10)
      {
        v10 = 0;
        CFRelease(v6);
      }
    }
  }
  else
  {
    sosDisabledNSError();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    (*((void (**)(id, _QWORD, void *))v3 + 2))(v3, 0, v4);
  }

}

void SOSCCGhostBustInfo(void *a1)
{
  id v1;
  void *v2;
  NSObject *v3;
  CFTypeRef v4;
  _QWORD v5[4];
  id v6;
  uint8_t buf[8];
  CFTypeRef v8;

  v1 = a1;
  if ((SOSCCIsSOSTrustAndSyncingEnabled() & 1) != 0)
  {
    v8 = 0;
    SOSCCGetSynchronousStatusObject(&v8);
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    if (v2)
    {
      secLogObjForScope("ghostbust");
      v3 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "API Info Called", buf, 2u);
      }

      v5[0] = MEMORY[0x1E0C809B0];
      v5[1] = 3221225472;
      v5[2] = __SOSCCGhostBustInfo_block_invoke;
      v5[3] = &unk_1E1FD4F10;
      v6 = v1;
      objc_msgSend(v2, "ghostBustInfo:", v5);

    }
    else
    {
      (*((void (**)(id, _QWORD, CFTypeRef))v1 + 2))(v1, 0, v8);
      v4 = v8;
      if (v8)
      {
        v8 = 0;
        CFRelease(v4);
      }
    }
  }
  else
  {
    sosDisabledNSError();
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    (*((void (**)(id, _QWORD, void *))v1 + 2))(v1, 0, v2);
  }

}

CFStringRef SecCopyErrorMessageString(OSStatus status, void *reserved)
{
  uint64_t v2;
  CFStringRef result;

  v2 = *(_QWORD *)&status;
  result = copyErrorMessageFromBundle(*(uint64_t *)&status, CFSTR("SecErrorMessages"));
  if (!result)
  {
    result = copyErrorMessageFromBundle(v2, CFSTR("SecDebugErrorMessages"));
    if (!result)
      return CFStringCreateWithFormat(0, 0, CFSTR("OSStatus %d"), v2);
  }
  return result;
}

CFStringRef copyErrorMessageFromBundle(uint64_t a1, const __CFString *a2)
{
  uint64_t Bundle;
  __CFBundle *v5;
  CFStringRef v6;
  const __CFString *v7;
  CFStringRef v8;

  Bundle = SecFrameworkGetBundle();
  if (!Bundle)
    return 0;
  v5 = (__CFBundle *)Bundle;
  v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%d"), a1);
  if (!v6)
    return 0;
  v7 = v6;
  v8 = CFBundleCopyLocalizedString(v5, v7, v7, a2);
  if (CFStringCompare(v8, v7, 0) == kCFCompareEqualTo && v8)
  {
    CFRelease(v8);
    v8 = 0;
  }
  CFRelease(v7);
  return v8;
}

id SecAccessControlCopyFormatDescription(uint64_t a1)
{
  void *v1;
  id v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;

  v1 = (void *)MEMORY[0x1E0CB37A0];
  v2 = *(id *)(a1 + 16);
  objc_msgSend(v1, "string");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("prot"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  dumpValue(v4, v3, &stru_1E1FDD448);

  objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("acl"));
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  dumpValue(v5, v3, CFSTR(";"));
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("<SecAccessControlRef: %@>"), v3);
  v6 = (id)objc_claimAutoreleasedReturnValue();

  return v6;
}

id SecAccessControlCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();
  return SecAccessControlCopyFormatDescription(a1);
}

void dumpValue(void *a1, void *a2, void *a3)
{
  __CFString *v5;
  id v6;
  id v7;
  CFTypeID v8;
  const __CFString *v9;
  void *v10;
  __CFString *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  __CFString *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const __CFString *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _QWORD v26[4];
  id v27;
  id v28;
  _BYTE v29[128];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (v5)
  {
    v8 = CFGetTypeID(v5);
    if (v8 == CFBooleanGetTypeID())
    {
      if (-[__CFString BOOLValue](v5, "BOOLValue"))
        v9 = CFSTR("true");
      else
        v9 = CFSTR("false");
LABEL_6:
      v10 = v6;
LABEL_7:
      objc_msgSend(v10, "appendString:", v9);
      goto LABEL_11;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      -[__CFString stringValue](v5, "stringValue");
      v11 = (__CFString *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "appendString:", v11);
LABEL_10:

      goto LABEL_11;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v10 = v6;
      v9 = v5;
      goto LABEL_7;
    }
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
      {
        v26[0] = MEMORY[0x1E0C809B0];
        v26[1] = 3221225472;
        v26[2] = __dumpValue_block_invoke;
        v26[3] = &unk_1E1FD5128;
        v27 = v6;
        v28 = v7;
        -[__CFString enumerateKeysAndObjectsUsingBlock:](v5, "enumerateKeysAndObjectsUsingBlock:", v26);

        goto LABEL_11;
      }
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
        goto LABEL_11;
      objc_msgSend(v6, "appendString:", CFSTR("["));
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v15 = v5;
      v16 = -[__CFString countByEnumeratingWithState:objects:count:](v15, "countByEnumeratingWithState:objects:count:", &v22, v29, 16);
      if (v16)
      {
        v17 = v16;
        v18 = *(_QWORD *)v23;
        v19 = &stru_1E1FDD448;
        do
        {
          v20 = 0;
          do
          {
            if (*(_QWORD *)v23 != v18)
              objc_enumerationMutation(v15);
            v21 = *(_QWORD *)(*((_QWORD *)&v22 + 1) + 8 * v20);
            objc_msgSend(v6, "appendString:", v19);
            dumpValue(v21, v6, v7);
            ++v20;
            v19 = CFSTR(",");
          }
          while (v17 != v20);
          v17 = -[__CFString countByEnumeratingWithState:objects:count:](v15, "countByEnumeratingWithState:objects:count:", &v22, v29, 16);
          v19 = CFSTR(",");
        }
        while (v17);
      }

      v9 = CFSTR("]");
      goto LABEL_6;
    }
    v11 = objc_retainAutorelease(v5);
    v12 = -[__CFString bytes](v11, "bytes");
    if ((unint64_t)-[__CFString length](v11, "length") <= 0x40)
    {
      v13 = -[__CFString length](v11, "length");
      if (!v13)
        goto LABEL_22;
    }
    else
    {
      v13 = 64;
    }
    v14 = 0;
    do
      objc_msgSend(v6, "appendFormat:", CFSTR("%02X"), *(unsigned __int8 *)(v12 + v14++));
    while (v13 != v14);
LABEL_22:
    if (v13 < -[__CFString length](v11, "length"))
      objc_msgSend(v6, "appendFormat:", CFSTR("...(%db)"), -[__CFString length](v11, "length"));
    goto LABEL_10;
  }
LABEL_11:

}

uint64_t __dumpValue_block_invoke(uint64_t a1, void *a2, void *a3)
{
  void *v5;
  uint64_t v6;
  id v7;
  id v8;

  v5 = *(void **)(a1 + 32);
  v6 = *(_QWORD *)(a1 + 40);
  v7 = a3;
  v8 = a2;
  objc_msgSend(v5, "appendString:", v6);
  dumpValue(v8, *(_QWORD *)(a1 + 32), &stru_1E1FDD448);

  objc_msgSend(*(id *)(a1 + 32), "appendString:", CFSTR("("));
  dumpValue(v7, *(_QWORD *)(a1 + 32), &stru_1E1FDD448);

  return objc_msgSend(*(id *)(a1 + 32), "appendString:", CFSTR(")"));
}

SecAccessControlRef SecAccessControlCreateWithFlags(CFAllocatorRef allocator, CFTypeRef protection, SecAccessControlCreateFlags flags, CFErrorRef *error)
{
  uint64_t v8;
  __SecAccessControl *v9;
  CFMutableArrayRef Mutable;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  __CFDictionary *MutableForCFTypesWith;
  __CFDictionary *v20;
  __CFDictionary *v21;
  __CFDictionary *v22;
  __CFDictionary *BiometryAny;
  __CFDictionary *v24;
  __CFDictionary *BiometryCurrentSet;
  __CFDictionary *v26;
  __CFDictionary *v27;
  __CFDictionary *v28;
  __CFDictionary *MutableConstraints;
  CFIndex Count;
  uint64_t v31;
  __CFDictionary *ValueOfKofN;
  const void *v33;
  const void *v34;
  const void *v35;
  const void *v36;
  const void *ValueAtIndex;
  const void *v38;
  const void *v39;
  CFDictionaryRef *v40;
  const void *v41;

  v8 = SecAccessControlCreate(allocator, (__CFString **)error);
  v9 = (__SecAccessControl *)v8;
  if (!v8)
    return v9;
  if (!SecAccessControlSetProtection(v8, protection, (__CFString **)error))
  {
LABEL_14:
    Mutable = v9;
    v9 = 0;
LABEL_15:
    CFRelease(Mutable);
    return v9;
  }
  if (flags)
  {
    if ((~(_DWORD)flags & 0xC000) == 0)
    {
      SecError(-50, (__CFString **)error, CFSTR("only one logical operation can be set"));
      goto LABEL_14;
    }
    if ((flags & 8) != 0 && (flags & 0xA) != 8)
    {
      SecError(-50, (__CFString **)error, CFSTR("only one bio constraint can be set"));
      goto LABEL_14;
    }
    if ((flags & 1) != 0 && (flags & 0xFFFFFFFF3FFFFFFELL) != 0)
    {
      SecError(-50, (__CFString **)error, CFSTR("kSecAccessControlUserPresence can be combined only with kSecAccessControlApplicationPassword and kSecAccessControlPrivateKeyUsage"));
      goto LABEL_14;
    }
    Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
    if ((flags & 1) != 0)
    {
      MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(allocator, v12, v13, v14, v15, v16, v17, v18, CFSTR("cpo"), (uint64_t)CFSTR("DeviceOwnerAuthentication"));
      if (!MutableForCFTypesWith)
        goto LABEL_74;
      v20 = MutableForCFTypesWith;
      CFArrayAppendValue(Mutable, MutableForCFTypesWith);
      CFRelease(v20);
    }
    if ((flags & 0x10) != 0)
    {
      v21 = CFDictionaryCreateMutableForCFTypesWith(allocator, v12, v13, v14, v15, v16, v17, v18, CFSTR("cup"), *MEMORY[0x1E0C9AE50]);
      if (!v21)
        goto LABEL_74;
      v22 = v21;
      CFArrayAppendValue(Mutable, v21);
      CFRelease(v22);
    }
    if ((flags & 2) != 0)
    {
      if (_getEmptyData_onceToken != -1)
        dispatch_once(&_getEmptyData_onceToken, &__block_literal_global_7008);
      BiometryAny = SecAccessConstraintCreateBiometryAny(allocator, _getEmptyData_emptyData, v13, v14, v15, v16, v17, v18);
      if (!BiometryAny)
        goto LABEL_74;
      v24 = BiometryAny;
      CFArrayAppendValue(Mutable, BiometryAny);
      CFRelease(v24);
    }
    if ((flags & 8) != 0)
    {
      if (_getEmptyData_onceToken != -1)
        dispatch_once(&_getEmptyData_onceToken, &__block_literal_global_7008);
      BiometryCurrentSet = SecAccessConstraintCreateBiometryCurrentSet(allocator, _getEmptyData_emptyData, (const void *)_getEmptyData_emptyData, v14, v15, v16, v17, v18);
      if (!BiometryCurrentSet)
        goto LABEL_74;
      v26 = BiometryCurrentSet;
      CFArrayAppendValue(Mutable, BiometryCurrentSet);
      CFRelease(v26);
    }
    if ((flags & 0x20) != 0)
    {
      v27 = CFDictionaryCreateMutableForCFTypesWith(allocator, v12, v13, v14, v15, v16, v17, v18, CFSTR("cwtch"), *MEMORY[0x1E0C9AE50]);
      if (!v27)
        goto LABEL_74;
      v28 = v27;
      CFArrayAppendValue(Mutable, v27);
      CFRelease(v28);
    }
    if ((flags & 0x80000000) != 0)
    {
      MutableConstraints = (__CFDictionary *)SecAccessControlGetMutableConstraints((CFDictionaryRef *)v9);
      CFDictionarySetValue(MutableConstraints, CFSTR("prp"), (const void *)*MEMORY[0x1E0C9AE50]);
    }
    Count = CFArrayGetCount(Mutable);
    if (Count >= 2)
    {
      if ((flags & 0x4000) != 0)
        v31 = 1;
      else
        v31 = Count;
      ValueOfKofN = SecAccessConstraintCreateValueOfKofN(allocator, v31, Mutable, (__CFString **)error);
      if (!ValueOfKofN)
        goto LABEL_75;
      if ((flags & 0x40000000) != 0)
      {
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("osgn"), ValueOfKofN, (__CFString **)error)|| !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("ock"), ValueOfKofN, (__CFString **)error)|| !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("okd"), ValueOfKofN, (__CFString **)error)|| (v33 = (const void *)*MEMORY[0x1E0C9AE50], !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("oa"), (CFTypeRef)*MEMORY[0x1E0C9AE50],
                 (__CFString **)error)))
        {
LABEL_75:
          CFRelease(v9);
          if (Mutable)
            CFRelease(Mutable);
          v9 = 0;
          Mutable = ValueOfKofN;
          if (ValueOfKofN)
            goto LABEL_15;
          return v9;
        }
      }
      else
      {
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("od"), ValueOfKofN, (__CFString **)error))goto LABEL_75;
        v33 = (const void *)*MEMORY[0x1E0C9AE50];
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("oe"), (CFTypeRef)*MEMORY[0x1E0C9AE50], (__CFString **)error))goto LABEL_75;
      }
      if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("odel"), v33, (__CFString **)error))
        goto LABEL_75;
      CFRelease(ValueOfKofN);
LABEL_72:
      if (!Mutable)
        return v9;
      goto LABEL_15;
    }
    if (Count == 1)
    {
      if ((flags & 0x40000000) != 0)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(Mutable, 0);
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("osgn"), ValueAtIndex, (__CFString **)error))goto LABEL_74;
        v38 = CFArrayGetValueAtIndex(Mutable, 0);
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("ock"), v38, (__CFString **)error))
          goto LABEL_74;
        v39 = CFArrayGetValueAtIndex(Mutable, 0);
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("okd"), v39, (__CFString **)error))
          goto LABEL_74;
        v35 = (const void *)*MEMORY[0x1E0C9AE50];
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("oa"), (CFTypeRef)*MEMORY[0x1E0C9AE50], (__CFString **)error))goto LABEL_74;
      }
      else
      {
        v34 = CFArrayGetValueAtIndex(Mutable, 0);
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("od"), v34, (__CFString **)error))
          goto LABEL_74;
        v35 = (const void *)*MEMORY[0x1E0C9AE50];
        if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("oe"), (CFTypeRef)*MEMORY[0x1E0C9AE50], (__CFString **)error))goto LABEL_74;
      }
      v40 = (CFDictionaryRef *)v9;
      v41 = v35;
    }
    else
    {
      v36 = (const void *)*MEMORY[0x1E0C9AE50];
      if ((flags & 0x40000000) == 0)
      {
        if (SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("dacl"), (CFTypeRef)*MEMORY[0x1E0C9AE50], (__CFString **)error))
        {
          goto LABEL_72;
        }
        goto LABEL_74;
      }
      if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("osgn"), (CFTypeRef)*MEMORY[0x1E0C9AE50], (__CFString **)error)|| !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("ock"), v36, (__CFString **)error)|| !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("okd"), v36, (__CFString **)error)|| !SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("oa"), v36, (__CFString **)error))
      {
        goto LABEL_74;
      }
      v40 = (CFDictionaryRef *)v9;
      v41 = v36;
    }
    if (SecAccessControlAddConstraintForOperation(v40, CFSTR("odel"), v41, (__CFString **)error))
      goto LABEL_72;
LABEL_74:
    ValueOfKofN = 0;
    goto LABEL_75;
  }
  if (!SecAccessControlAddConstraintForOperation((CFDictionaryRef *)v9, CFSTR("dacl"), (CFTypeRef)*MEMORY[0x1E0C9AE50], (__CFString **)error))goto LABEL_14;
  return v9;
}

__CFDictionary *SecAccessConstraintCreateBiometryAny(const __CFAllocator *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  __CFDictionary *MutableForCFTypesWith;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  __CFDictionary *v17;

  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, CFSTR("pbioc"), a2);
  v17 = CFDictionaryCreateMutableForCFTypesWith(a1, v10, v11, v12, v13, v14, v15, v16, CFSTR("cbio"), (uint64_t)MutableForCFTypesWith);
  if (MutableForCFTypesWith)
    CFRelease(MutableForCFTypesWith);
  return v17;
}

__CFDictionary *SecAccessConstraintCreateBiometryCurrentSet(const __CFAllocator *a1, uint64_t a2, const void *a3, int a4, int a5, int a6, int a7, int a8)
{
  __CFDictionary *MutableForCFTypesWith;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  __CFDictionary *v18;

  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, a2, (int)a3, a4, a5, a6, a7, a8, CFSTR("pbioc"), a2);
  CFDictionarySetValue(MutableForCFTypesWith, CFSTR("pbioh"), a3);
  v18 = CFDictionaryCreateMutableForCFTypesWith(a1, v11, v12, v13, v14, v15, v16, v17, CFSTR("cbio"), (uint64_t)MutableForCFTypesWith);
  if (MutableForCFTypesWith)
    CFRelease(MutableForCFTypesWith);
  return v18;
}

const void *SecAccessControlGetMutableConstraints(CFDictionaryRef *a1)
{
  const void *result;
  const __CFAllocator *v3;
  CFMutableDictionaryRef Mutable;

  result = CFDictionaryGetValue(a1[2], CFSTR("acl"));
  if (!result)
  {
    v3 = CFGetAllocator(a1);
    Mutable = CFDictionaryCreateMutable(v3, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    CFDictionarySetValue(a1[2], CFSTR("acl"), Mutable);
    CFRelease(Mutable);
    return CFDictionaryGetValue(a1[2], CFSTR("acl"));
  }
  return result;
}

__CFDictionary *SecAccessConstraintCreateValueOfKofN(const __CFAllocator *a1, uint64_t a2, const __CFArray *a3, __CFString **a4)
{
  CFNumberRef v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  __CFDictionary *MutableForCFTypesWith;
  CFIndex Count;
  CFIndex v17;
  CFIndex v18;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v20;
  CFTypeID v21;
  uint64_t v22;
  __CFString *v23;
  const void *Value;
  uint64_t valuePtr;

  valuePtr = a2;
  v7 = CFNumberCreate(a1, kCFNumberCFIndexType, &valuePtr);
  MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, v8, v9, v10, v11, v12, v13, v14, CFSTR("pkofn"), (uint64_t)v7);
  CFRelease(v7);
  Count = CFArrayGetCount(a3);
  if (Count >= 1)
  {
    v17 = Count;
    v18 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, v18);
      if (!ValueAtIndex)
        break;
      v20 = ValueAtIndex;
      v21 = CFGetTypeID(ValueAtIndex);
      if (v21 != CFDictionaryGetTypeID())
        break;
      v22 = 0;
      while (1)
      {
        v23 = off_1E1FD5168[v22];
        Value = CFDictionaryGetValue(v20, v23);
        if (Value)
          break;
        if (++v22 == 4)
          goto LABEL_11;
      }
      CFDictionarySetValue(MutableForCFTypesWith, v23, Value);
      if (++v18 == v17)
        return MutableForCFTypesWith;
    }
LABEL_11:
    SecError(-50, a4, CFSTR("SecAccessControl: invalid constraint for k-of-n"));
    if (MutableForCFTypesWith)
    {
      CFRelease(MutableForCFTypesWith);
      return 0;
    }
  }
  return MutableForCFTypesWith;
}

BOOL SecAccessControlAddConstraintForOperation(CFDictionaryRef *a1, const void *a2, CFTypeRef cf, __CFString **a4)
{
  CFTypeID v8;
  __CFDictionary *MutableConstraints;

  if (!cf || (v8 = CFGetTypeID(cf), v8 != CFDictionaryGetTypeID()))
  {
    if (!CFEqual(cf, (CFTypeRef)*MEMORY[0x1E0C9AE50]) && !CFEqual(cf, (CFTypeRef)*MEMORY[0x1E0C9AE40]))
      return SecError(-50, a4, CFSTR("invalid constraint"));
  }
  MutableConstraints = (__CFDictionary *)SecAccessControlGetMutableConstraints(a1);
  CFDictionarySetValue(MutableConstraints, a2, cf);
  return 1;
}

CFMutableDataRef ___getEmptyData_block_invoke()
{
  CFMutableDataRef result;

  result = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  _getEmptyData_emptyData = (uint64_t)result;
  return result;
}

__CFDictionary *SecAccessConstraintCreatePolicy(const __CFAllocator *a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, CFSTR("cpo"), a2);
}

__CFDictionary *SecAccessConstraintCreatePasscode(const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, CFSTR("cup"), *MEMORY[0x1E0C9AE50]);
}

__CFDictionary *SecAccessConstraintCreateCompanion(const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, CFSTR("cwtch"), *MEMORY[0x1E0C9AE50]);
}

void SecAccessControlSetRequirePassword(CFDictionaryRef *a1, int a2)
{
  __CFDictionary *MutableConstraints;
  const void **v4;

  MutableConstraints = (__CFDictionary *)SecAccessControlGetMutableConstraints(a1);
  v4 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v4 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(MutableConstraints, CFSTR("prp"), *v4);
}

__CFDictionary *SecAccessConstraintCreateWatch(const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return CFDictionaryCreateMutableForCFTypesWith(a1, a2, a3, a4, a5, a6, a7, a8, CFSTR("cwtch"), *MEMORY[0x1E0C9AE50]);
}

__CFDictionary *SecAccessConstraintCreateKofN(const __CFAllocator *a1, uint64_t a2, const __CFArray *a3, __CFString **a4)
{
  __CFDictionary *result;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  __CFDictionary *v13;
  __CFDictionary *MutableForCFTypesWith;

  result = SecAccessConstraintCreateValueOfKofN(a1, a2, a3, a4);
  if (result)
  {
    v13 = result;
    MutableForCFTypesWith = CFDictionaryCreateMutableForCFTypesWith(a1, v6, v7, v8, v9, v10, v11, v12, CFSTR("ckon"), (uint64_t)result);
    CFRelease(v13);
    return MutableForCFTypesWith;
  }
  return result;
}

__CFData *SecAccessControlCopyConstraintData(uint64_t a1, const void *a2)
{
  const __CFString *Constraint;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFIndex v9;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  Constraint = (const __CFString *)SecAccessControlGetConstraint(a1, a2);
  v9 = der_sizeof_plist(Constraint, 0, v3, v4, v5, v6, v7, v8);
  Mutable = CFDataCreateMutable(0, v9);
  CFDataSetLength(Mutable, v9);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (!der_encode_plist_repair(Constraint, 0, 0, MutableBytePtr, (unint64_t)&MutableBytePtr[v9], v12, v13, v14)&& Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

void SecAccessControlSetConstraints(CFMutableDictionaryRef *a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;
  CFMutableDictionaryRef MutableCopy;

  v4 = CFGetAllocator(a1);
  MutableCopy = CFDictionaryCreateMutableCopy(v4, 0, a2);
  CFDictionarySetValue(a1[2], CFSTR("acl"), MutableCopy);
  if (MutableCopy)
    CFRelease(MutableCopy);
}

const __CFDictionary *SecAccessControlGetRequirePassword(uint64_t a1)
{
  const __CFDictionary *result;
  const void *Value;
  const void *v3;
  BOOL v4;

  result = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("acl"));
  if (result)
  {
    Value = CFDictionaryGetValue(result, CFSTR("prp"));
    v3 = (const void *)*MEMORY[0x1E0C9AE50];
    if (Value)
      v4 = v3 == 0;
    else
      v4 = 1;
    if (v4)
      return (const __CFDictionary *)(Value == v3);
    else
      return (const __CFDictionary *)(CFEqual(Value, v3) != 0);
  }
  return result;
}

void SecAccessControlSetBound(uint64_t a1, int a2)
{
  __CFDictionary *v2;
  const void **v3;

  v2 = *(__CFDictionary **)(a1 + 16);
  v3 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a2)
    v3 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(v2, CFSTR("bound"), *v3);
}

uint64_t SecAccessControlIsBound(uint64_t a1)
{
  const void *Value;
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  uint64_t i;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("bound"));
  if (Value && *MEMORY[0x1E0C9AE50] && CFEqual(Value, (CFTypeRef)*MEMORY[0x1E0C9AE50]))
    return 1;
  if ((SecAccessControlGetRequirePassword(a1) & 1) != 0)
    return 0;
  CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("acl"));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  objc_msgSend(v4, "allValues", 0);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)v13;
    v9 = (const void *)*MEMORY[0x1E0C9AE50];
    while (2)
    {
      for (i = 0; i != v7; ++i)
      {
        if (*(_QWORD *)v13 != v8)
          objc_enumerationMutation(v5);
        if (!CFEqual(*(CFTypeRef *)(*((_QWORD *)&v12 + 1) + 8 * i), v9))
        {
          v3 = 0;
          goto LABEL_17;
        }
      }
      v7 = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      if (v7)
        continue;
      break;
    }
  }
  v3 = 1;
LABEL_17:

  return v3;
}

void SecItemFetchCurrentItemOutOfBand(void *a1, uint64_t a2, void *a3)
{
  id v5;
  id v6;
  NSObject *v7;
  void *v8;
  uint64_t v9;
  id v10;
  void *v11;
  id v12;
  _QWORD v13[4];
  id v14;
  _QWORD v15[4];
  id v16;
  os_activity_scope_state_s state;

  v5 = a1;
  v6 = a3;
  v7 = _os_activity_create(&dword_18A900000, "fetchCurrentItemOutOfBand", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  v8 = (void *)MEMORY[0x18D770A24]();
  v9 = MEMORY[0x1E0C809B0];
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3221225472;
  v15[2] = __SecItemFetchCurrentItemOutOfBand_block_invoke;
  v15[3] = &unk_1E1FD6038;
  v10 = v6;
  v16 = v10;
  SecuritydXPCProxyObject(0, v15);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v13[0] = v9;
  v13[1] = 3221225472;
  v13[2] = __SecItemFetchCurrentItemOutOfBand_block_invoke_2;
  v13[3] = &unk_1E1FD5190;
  v12 = v10;
  v14 = v12;
  objc_msgSend(v11, "secItemFetchCurrentItemOutOfBand:forceFetch:complete:", v5, a2, v13);

  objc_autoreleasePoolPop(v8);
  os_activity_scope_leave(&state);

}

void sub_18A9D0A20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void SecItemFetchPCSIdentityOutOfBand(void *a1, uint64_t a2, void *a3)
{
  id v5;
  id v6;
  NSObject *v7;
  void *v8;
  uint64_t v9;
  id v10;
  void *v11;
  id v12;
  _QWORD v13[4];
  id v14;
  _QWORD v15[4];
  id v16;
  os_activity_scope_state_s state;

  v5 = a1;
  v6 = a3;
  v7 = _os_activity_create(&dword_18A900000, "fetchPCSIdentityOutOfBand", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  v8 = (void *)MEMORY[0x18D770A24]();
  v9 = MEMORY[0x1E0C809B0];
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 3221225472;
  v15[2] = __SecItemFetchPCSIdentityOutOfBand_block_invoke;
  v15[3] = &unk_1E1FD6038;
  v10 = v6;
  v16 = v10;
  SecuritydXPCProxyObject(0, v15);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v13[0] = v9;
  v13[1] = 3221225472;
  v13[2] = __SecItemFetchPCSIdentityOutOfBand_block_invoke_2;
  v13[3] = &unk_1E1FD5190;
  v12 = v10;
  v14 = v12;
  objc_msgSend(v11, "secItemFetchPCSIdentityByKeyOutOfBand:forceFetch:complete:", v5, a2, v13);

  objc_autoreleasePoolPop(v8);
  os_activity_scope_leave(&state);

}

void sub_18A9D0BA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

unint64_t SecBase64Encode(unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4)
{
  int v5;

  return SecBase64Encode_(a1, a2, a3, a4, 0, &v5);
}

unint64_t SecBase64Encode_(unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4, unsigned int a5, _DWORD *a6)
{
  _BYTE *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  __int16 v20;
  char v21;

  v7 = a3;
  v8 = a2;
  v9 = (2 * (((a2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  *a6 = 0;
  if (a5)
    v9 = v9 + 2 * ((v9 + a5 - 1) / a5) - 2;
  if (a3)
  {
    if (v9 <= a4)
    {
      if (a2 >= 3)
      {
        v10 = 0;
        do
        {
          v11 = v7;
          v12 = *a1;
          v13 = v12 >> 2;
          v14 = a1[1];
          v15 = (v14 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v12 & 3));
          v16 = a1[2];
          *v7 = b64_chars[v13];
          v7[1] = b64_chars[v15];
          v7[2] = b64_chars[(v16 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v14 & 0xF))];
          v7 += 4;
          v11[3] = b64_chars[v16 & 0x3F];
          v10 += 4;
          if (v10 == a5 && v7 != &a3[a4])
          {
            v10 = 0;
            *((_WORD *)v11 + 2) = 2573;
            v7 = v11 + 6;
          }
          a1 += 3;
          v8 -= 3;
        }
        while (v8 > 2);
      }
      if (v8)
      {
        v17 = 0;
        v20 = -21846;
        v21 = -86;
        do
        {
          v18 = v17;
          *((_BYTE *)&v20 + v17) = a1[v17];
          ++v17;
        }
        while (v8 != v17);
        if (v18 < 2)
          bzero((char *)&v20 + v8, v8 ^ 3);
        SecBase64Encode_(&v20, 3, v7, 12, 0, a6);
        memset(&v7[v8 + 1], 61, v8 ^ 3);
      }
    }
    else
    {
      v9 = 0;
      *a6 = 1;
    }
  }
  return v9;
}

unint64_t SecBase64Encode2(unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4, char a5, unsigned int a6, char *a7)
{
  char *v8;
  int v9;
  unsigned int v10;
  unint64_t result;
  char v12;

  if (a7)
    v8 = a7;
  else
    v8 = &v12;
  v9 = a5 & 0xF;
  v10 = 76;
  switch(v9)
  {
    case 0:
      v10 = a6;
      if ((a6 & 0x80000000) == 0)
        goto LABEL_9;
      goto LABEL_6;
    case 1:
      v10 = 0;
      goto LABEL_9;
    case 2:
LABEL_6:
      v10 = 64;
      goto LABEL_9;
    case 3:
LABEL_9:
      result = SecBase64Encode_(a1, a2, a3, a4, v10, v8);
      break;
    default:
      result = 0;
      *(_DWORD *)v8 = 3;
      break;
  }
  return result;
}

_BYTE *SecBase64Decode(unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4)
{
  int v5;
  unsigned __int8 *v6;

  return SecBase64Decode_(a1, a2, a3, a4, 0, &v6, &v5);
}

_BYTE *SecBase64Decode_(unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4, __int16 a5, unsigned __int8 **a6, _DWORD *a7)
{
  unint64_t v7;
  unint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  int v15;

  v7 = a2 >> 2;
  if ((a2 & 3) != 0)
    ++v7;
  v8 = 3 * v7;
  *a6 = 0;
  *a7 = 0;
  if (a3)
  {
    if (v8 > a4)
    {
      v8 = 0;
      *a7 = 1;
      return (_BYTE *)v8;
    }
    v15 = -1431655766;
    v9 = a3;
    if (!a2)
      return (_BYTE *)(v9 - a3);
    v10 = 0;
    v11 = 0;
    v9 = a3;
    while (1)
    {
      v12 = (char)*a1;
      if (v12 == 61)
      {
        *((_BYTE *)&v15 + v11) = 0;
        ++v10;
        goto LABEL_12;
      }
      v13 = b64_indexes[*a1];
      if (v13 != 255)
      {
        v10 = 0;
        *((_BYTE *)&v15 + v11) = v13;
LABEL_12:
        if (++v11 == 4)
        {
          *v9 = (4 * v15) | (BYTE1(v15) >> 4) & 3;
          if (v10 == 2)
            return (_BYTE *)(++v9 - a3);
          v9[1] = (16 * BYTE1(v15)) | (BYTE2(v15) >> 2) & 0xF;
          if (v10 == 1)
          {
            v9 += 2;
            return (_BYTE *)(v9 - a3);
          }
          v9[2] = HIBYTE(v15) + (BYTE2(v15) << 6);
          if (v10)
          {
            v9 += 3;
            return (_BYTE *)(v9 - a3);
          }
          v11 = 0;
          v9 += 3;
        }
        goto LABEL_23;
      }
      if (v12 <= 0x20)
      {
        if (((1 << v12) & 0x100000B00) != 0)
        {
          if ((a5 & 0x200) != 0)
            goto LABEL_30;
          goto LABEL_23;
        }
        if (((1 << v12) & 0x2400) != 0)
          goto LABEL_23;
      }
      if ((a5 & 0x100) != 0)
      {
LABEL_30:
        v8 = 0;
        *a7 = 3;
        *a6 = a1;
        return (_BYTE *)v8;
      }
LABEL_23:
      ++a1;
      if (!--a2)
        return (_BYTE *)(v9 - a3);
    }
  }
  return (_BYTE *)v8;
}

_BYTE *SecBase64Decode2(unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4, __int16 a5, unsigned __int8 **a6, char *a7)
{
  char v8;
  char v9;

  if (!a6)
    a6 = (unsigned __int8 **)&v9;
  if (!a7)
    a7 = &v8;
  return SecBase64Decode_(a1, a2, a3, a4, a5, a6, a7);
}

const __CFString *SecCFAllocatorCopyDescription()
{
  return CFSTR("Custom CFAllocator for sensitive data that zeroizes on deallocate");
}

uint64_t SecCMSCreateEnvelopedData(_QWORD *a1, CFDictionaryRef theDict, const __CFData *a3, uint64_t a4)
{
  const void *Value;
  const void *v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  CFTypeID v15;
  CFIndex Count;
  uint64_t v17;
  uint64_t v18;
  CFIndex v19;
  CFIndex v20;
  _QWORD *ValueAtIndex;
  CFTypeID v22;
  CFIndex *p_Length;
  uint64_t v24;
  int v26;
  CFIndex Length;
  const UInt8 *BytePtr;

  if (theDict && (Value = CFDictionaryGetValue(theDict, (const void *)kSecCMSBulkEncryptionAlgorithm)) != 0)
  {
    v8 = Value;
    if (CFEqual((CFTypeRef)kSecCMSEncryptionAlgorithmDESCBC, Value))
    {
      v9 = 64;
      v10 = 10;
    }
    else
    {
      v26 = CFEqual((CFTypeRef)kSecCMSEncryptionAlgorithmAESCBC, v8);
      if (v26)
        v10 = 184;
      else
        v10 = 7;
      if (v26)
        v9 = 128;
      else
        v9 = 192;
    }
  }
  else
  {
    v9 = 192;
    v10 = 7;
  }
  v11 = SecCmsMessageCreate();
  if (!v11)
    return 4294967246;
  v12 = (unint64_t *)v11;
  v13 = SecCmsEnvelopedDataCreate(v11, v10, v9);
  if (!v13)
    goto LABEL_22;
  v14 = (unint64_t *)v13;
  if (SecCmsContentInfoSetContent(v12, 0x1Bu, v13)
    || SecCmsContentInfoSetContentData(v14, 0, 0))
  {
    goto LABEL_22;
  }
  v15 = CFGetTypeID(a1);
  if (v15 == CFArrayGetTypeID())
  {
    Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      v19 = Count;
      v20 = 0;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v20);
        if (!nss_cmsrecipientinfo_create((uint64_t)v14, 0, ValueAtIndex, 0))
          goto LABEL_22;
      }
      while (v19 != ++v20);
    }
LABEL_18:
    Length = 0;
    BytePtr = 0;
    if (a3)
    {
      Length = CFDataGetLength(a3);
      BytePtr = CFDataGetBytePtr(a3);
      if (Length)
        p_Length = &Length;
      else
        p_Length = 0;
    }
    else
    {
      p_Length = 0;
    }
    if (SecCmsMessageEncode((uint64_t *)v12, (uint64_t)p_Length, a4, v17, v18))
      v24 = 4294967246;
    else
      v24 = 0;
    goto LABEL_27;
  }
  v22 = CFGetTypeID(a1);
  if (v22 == SecCertificateGetTypeID() && nss_cmsrecipientinfo_create((uint64_t)v14, 0, a1, 0))
    goto LABEL_18;
LABEL_22:
  v24 = 4294967246;
LABEL_27:
  SecCmsMessageDestroy((uint64_t)v12);
  return v24;
}

uint64_t SecCMSDecryptEnvelopedData(const __CFData *a1, __CFData *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t OID;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  const void *v15;
  int v16;
  uint64_t ChildContentInfo;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t InnerContent;
  _QWORD v23[2];
  uint64_t v24;

  v6 = MS_SecCMSDecryptEnvelopedData((uint64_t)a1, a2, a3);
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1)
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_2932);
  if (!isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound || !(_DWORD)v6)
    return v6;
  v24 = 0;
  v23[0] = CFDataGetLength(a1);
  v23[1] = CFDataGetBytePtr(a1);
  v8 = SecCmsMessageDecode((uint64_t)v23, 0, 0, v7, 0, 0, 0, &v24);
  v9 = v24;
  if (v8)
  {
    v6 = 4294941021;
    goto LABEL_35;
  }
  if (!v24)
    return 4294967246;
  OID = *(_QWORD *)(v24 + 32);
  if (!OID)
  {
    OID = SECOID_FindOID(v24);
    *(_QWORD *)(v9 + 32) = OID;
    if (!OID)
      goto LABEL_14;
  }
  if (*(_DWORD *)(OID + 16) != 27 || OID == 0)
    goto LABEL_14;
  v12 = *(_QWORD *)(v9 + 16);
  if (!v12)
    goto LABEL_14;
  v13 = *(uint64_t **)(v12 + 144);
  while (1)
  {
    v14 = *v13;
    if (!*v13)
      break;
    v15 = *(const void **)(v14 + 144);
    ++v13;
    if (v15)
      goto LABEL_21;
  }
  v15 = 0;
LABEL_21:
  v16 = 0;
  ChildContentInfo = v9;
  do
  {
    ++v16;
    ChildContentInfo = SecCmsContentInfoGetChildContentInfo(ChildContentInfo);
  }
  while (ChildContentInfo);
  if (v16 != 2)
    goto LABEL_40;
  v18 = SecCmsContentInfoGetChildContentInfo(v9);
  if (!v18)
  {
LABEL_14:
    v6 = 4294967246;
LABEL_36:
    SecCmsMessageDestroy(v9);
    return v6;
  }
  v19 = v18;
  v20 = *(_QWORD *)(v18 + 32);
  if (!v20 && (v20 = SECOID_FindOID(v19), (*(_QWORD *)(v19 + 32) = v20) == 0) || *(_DWORD *)(v20 + 16) != 25)
  {
LABEL_40:
    v6 = 4294967246;
    goto LABEL_35;
  }
  InnerContent = SecCmsContentInfoGetInnerContent(v9);
  if (InnerContent)
    CFDataAppendBytes(a2, *(const UInt8 **)(InnerContent + 8), *(_QWORD *)InnerContent);
  if (a3)
  {
    if (v14)
      CFRetain(v15);
    v6 = 0;
    *a3 = v15;
  }
  else
  {
    v6 = 0;
  }
LABEL_35:
  if (v9)
    goto LABEL_36;
  return v6;
}

uint64_t SecCMSSignDataAndAttributes(uint64_t a1, const __CFData *a2, int a3, uint64_t a4, const __CFDictionary *a5)
{
  return SecCMSSignDataOrDigestAndAttributes(a1, a2, a3, 0, 4u, a4, a5, 2, 0);
}

uint64_t SecCMSSignDataOrDigestAndAttributes(uint64_t a1, const __CFData *a2, int a3, int a4, unsigned int a5, uint64_t a6, const __CFDictionary *a7, int a8, CFArrayRef theArray)
{
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  uint64_t v21;
  void *v22;
  CFAbsoluteTime Current;
  uint64_t v24;
  uint64_t v25;
  CFIndex Length;
  uint64_t *v27;
  CFIndex *v28;
  BOOL v29;
  uint64_t v30;
  CFIndex v32;
  const UInt8 *BytePtr;

  if (!a3 && (a4 & 1) != 0)
    return 4294967246;
  v17 = SecCmsMessageCreate();
  if (!v17)
    return 4294967246;
  v18 = (unint64_t *)v17;
  v19 = PORT_ArenaAlloc(*(_QWORD *)(v17 + 120), 0xB8uLL);
  if (!v19)
    goto LABEL_28;
  v20 = (unint64_t *)v19;
  *(_QWORD *)(v19 + 176) = 0;
  *(_OWORD *)(v19 + 144) = 0u;
  *(_OWORD *)(v19 + 160) = 0u;
  *(_OWORD *)(v19 + 112) = 0u;
  *(_OWORD *)(v19 + 128) = 0u;
  *(_OWORD *)(v19 + 80) = 0u;
  *(_OWORD *)(v19 + 96) = 0u;
  *(_OWORD *)(v19 + 48) = 0u;
  *(_OWORD *)(v19 + 64) = 0u;
  *(_OWORD *)(v19 + 16) = 0u;
  *(_OWORD *)(v19 + 32) = 0u;
  *(_OWORD *)v19 = 0u;
  *(_QWORD *)(v19 + 24) = v18;
  if (SecCmsContentInfoSetContent(v18, 0x1Au, v19))
    goto LABEL_28;
  if (SecCmsContentInfoSetContentData(v20, 0, a3))
    goto LABEL_28;
  v21 = SecCmsSignerInfoCreate((uint64_t)v20, a1, a5);
  if (!v21)
    goto LABEL_28;
  v22 = (void *)v21;
  if (theArray)
  {
    if (SecCmsSignedDataAddCertList((uint64_t)v20, theArray))
      goto LABEL_28;
  }
  if (SecCmsSignerInfoIncludeCerts((uint64_t)v22, a8))
    goto LABEL_28;
  Current = CFAbsoluteTimeGetCurrent();
  if (SecCmsSignerInfoAddSigningTime((uint64_t)v22, Current))
    goto LABEL_28;
  if (a7)
    CFDictionaryApplyFunction(a7, (CFDictionaryApplierFunction)sign_all_attributes, v22);
  v32 = 0;
  BytePtr = 0;
  if (!a2)
  {
    Length = 0;
    if (a4)
      goto LABEL_16;
LABEL_19:
    if (Length)
      v29 = a2 == 0;
    else
      v29 = 1;
    if (v29)
      v28 = 0;
    else
      v28 = &v32;
    v27 = (uint64_t *)v18;
    goto LABEL_26;
  }
  Length = CFDataGetLength(a2);
  v32 = Length;
  BytePtr = CFDataGetBytePtr(a2);
  if (!a4)
    goto LABEL_19;
LABEL_16:
  if (SecCmsSignedDataSetDigestValue(v20, a5, (uint64_t)&v32))
  {
LABEL_28:
    v30 = 4294967246;
    goto LABEL_29;
  }
  v27 = (uint64_t *)v18;
  v28 = 0;
LABEL_26:
  if (SecCmsMessageEncode(v27, (uint64_t)v28, a6, v24, v25))
    goto LABEL_28;
  v30 = 0;
LABEL_29:
  SecCmsMessageDestroy((uint64_t)v18);
  return v30;
}

uint64_t sign_all_attributes(const __CFData *a1, const __CFData *a2, uint64_t a3)
{
  CFIndex Length;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  unint64_t *v10;
  uint64_t v11;
  _QWORD v12[2];
  _QWORD v13[2];

  v13[0] = CFDataGetLength(a1);
  v13[1] = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a2);
  v12[0] = Length;
  v12[1] = CFDataGetBytePtr(a2);
  v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 128) + 24) + 120);
  result = PORT_ArenaAlloc(v7, 0x28uLL);
  if (result)
  {
    v9 = result;
    *(_QWORD *)(result + 32) = 0;
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    if (!SECITEM_CopyItem(v7, (unint64_t *)result, (uint64_t)v13))
    {
      v10 = SECITEM_AllocItem(v7, 0, Length);
      if (v10)
      {
        v11 = (uint64_t)v10;
        if (!SECITEM_CopyItem(v7, v10, (uint64_t)v12)
          && !SecCmsArrayAdd(v7, (char **)(v9 + 16), v11))
        {
          *(_BYTE *)(v9 + 32) = 1;
        }
      }
    }
    return SecCmsAttributeArrayAddAttr(v7, (uint64_t **)(a3 + 64), v9);
  }
  return result;
}

uint64_t SecCMSSignDigestAndAttributes(uint64_t a1, const __CFData *a2, uint64_t a3, const __CFDictionary *a4)
{
  return SecCMSSignDataOrDigestAndAttributes(a1, a2, 1, 1, 4u, a3, a4, 2, 0);
}

uint64_t SecCMSCreateSignedData(uint64_t a1, const __CFData *a2, CFDictionaryRef theDict, const __CFDictionary *a4, uint64_t a5)
{
  const __CFArray *theArray;
  _BOOL4 v10;
  _BOOL4 v11;
  const void *Value;
  const __CFString *v13;
  const __CFString *v14;
  CFTypeID v15;
  SInt32 IntValue;
  const __CFArray *v17;
  CFTypeID v18;
  unsigned int v19;

  theArray = theDict;
  if (!theDict)
  {
    v11 = 0;
    v10 = 0;
    v19 = 4;
    IntValue = 2;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }
  v10 = CFDictionaryGetValueIfPresent(theDict, (const void *)kSecCMSSignDigest, 0) != 0;
  v11 = CFDictionaryGetValueIfPresent(theArray, (const void *)kSecCMSSignDetached, 0) != 0;
  Value = CFDictionaryGetValue(theArray, (const void *)kSecCMSSignHashAlgorithm);
  v13 = (const __CFString *)CFDictionaryGetValue(theArray, (const void *)kSecCMSCertChainMode);
  if (v13 && (v14 = v13, v15 = CFGetTypeID(v13), v15 == CFStringGetTypeID()))
    IntValue = CFStringGetIntValue(v14);
  else
    IntValue = 2;
  v17 = (const __CFArray *)CFDictionaryGetValue(theArray, (const void *)kSecCMSAdditionalCerts);
  theArray = v17;
  if (v17)
  {
    v18 = CFGetTypeID(v17);
    if (v18 != CFArrayGetTypeID())
      theArray = 0;
  }
  if (!Value || CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA1, Value))
  {
    v19 = 4;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }
  if (CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA256, Value))
  {
    v19 = 192;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }
  if (CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA384, Value))
  {
    v19 = 193;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }
  if (CFEqual((CFTypeRef)kSecCMSHashingAlgorithmSHA512, Value))
  {
    v19 = 194;
    return SecCMSSignDataOrDigestAndAttributes(a1, a2, v11, v10, v19, a5, a4, IntValue, theArray);
  }
  return 4294967246;
}

uint64_t SecCMSVerifyCopyDataAndAttributes(const __CFData *a1, const __CFData *a2, void *a3, SecTrustRef *a4, uint64_t *a5, const __CFDictionary **a6)
{
  return SecCMSVerifySignedData_internal(a1, a2, a3, a4, 0, a5, a6);
}

uint64_t SecCMSVerify(const __CFData *a1, const __CFData *a2, void *a3, SecTrustRef *a4, uint64_t *a5)
{
  return SecCMSVerifySignedData_internal(a1, a2, a3, a4, 0, a5, 0);
}

uint64_t SecCMSDecodeSignedData(const __CFData *a1, uint64_t *a2, const __CFDictionary **a3)
{
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1)
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_2932);
  if (isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound)
    return SecCMSVerifySignedData_internal(a1, 0, 0, 0, 0, a2, a3);
  else
    return MS_SecCMSDecodeSignedData((uint64_t)a1, a2, (uint64_t)a3);
}

const __CFArray *SecCMSCertificatesOnlyMessageCopyCertificates(uint64_t a1)
{
  const __CFData *Mutable;
  const __CFArray *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t OID;
  BOOL v7;
  uint64_t v8;
  _QWORD *v9;
  CFIndex Count;
  CFIndex v11;
  const void *ValueAtIndex;
  NSObject *v13;
  uint64_t *v15;
  uint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  const void *v19;
  uint64_t v20;
  _QWORD v21[2];
  uint64_t v22;
  uint8_t buf[4];
  const __CFData *v24;
  __int16 v25;
  const __CFArray *v26;
  uint64_t v27;
  CFRange v28;

  Mutable = (const __CFData *)a1;
  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return Mutable;
  v2 = (const __CFArray *)MS_SecCMSCertificatesOnlyMessageCopyCertificates(a1);
  if (isMessageSecurityAllowedForCurrentBundleID_onceToken != -1)
    dispatch_once(&isMessageSecurityAllowedForCurrentBundleID_onceToken, &__block_literal_global_2932);
  if (!isMessageSecurityAllowedForCurrentBundleID_blockedBundleIDFound)
    return v2;
  v22 = 0;
  v21[0] = CFDataGetLength(Mutable);
  v21[1] = CFDataGetBytePtr(Mutable);
  v4 = SecCmsMessageDecode((uint64_t)v21, 0, 0, v3, 0, 0, 0, &v22);
  v5 = v22;
  if (!v4)
  {
    if (!v22)
      goto LABEL_21;
    OID = *(_QWORD *)(v22 + 32);
    if ((OID || (OID = SECOID_FindOID(v22), (*(_QWORD *)(v5 + 32) = OID) != 0))
      && (*(_DWORD *)(OID + 16) == 26 ? (v7 = OID == 0) : (v7 = 1),
          !v7 && (v8 = *(_QWORD *)(v5 + 16)) != 0 && ((v9 = *(_QWORD **)(v8 + 160)) == 0 || !*v9)))
    {
      v15 = *(uint64_t **)(v8 + 144);
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      if (v15)
      {
        v16 = *v15;
        if (*v15)
        {
          v17 = v15 + 1;
          do
          {
            v18 = SecCertificateCreateWithBytes(0, *(const void **)(v16 + 8), *(_QWORD *)v16);
            if (v18)
            {
              v19 = v18;
              CFArrayAppendValue(Mutable, v18);
              CFRelease(v19);
            }
            v20 = *v17++;
            v16 = v20;
          }
          while (v20);
          if (!v5)
            goto LABEL_18;
        }
      }
    }
    else
    {
      Mutable = 0;
    }
    goto LABEL_17;
  }
  Mutable = 0;
  if (v22)
LABEL_17:
    SecCmsMessageDestroy(v5);
LABEL_18:
  if (!Mutable || CFArrayGetCount(Mutable) > 0)
    goto LABEL_22;
  CFRelease(Mutable);
LABEL_21:
  Mutable = 0;
LABEL_22:
  if (Mutable != v2)
  {
    if (v2 && Mutable && (Count = CFArrayGetCount(Mutable), Count == CFArrayGetCount(v2)))
    {
      v11 = 0;
      while (v11 < CFArrayGetCount(Mutable))
      {
        ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v11);
        v28.length = CFArrayGetCount(v2);
        v28.location = 0;
        ++v11;
        if (!CFArrayContainsValue(v2, v28, ValueAtIndex))
          goto LABEL_29;
      }
    }
    else
    {
LABEL_29:
      v13 = secLogObjForScope("SecWarning");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        v24 = Mutable;
        v25 = 2112;
        v26 = v2;
        _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, "MessageSecurity and Security frameworks have different results, returning Security result. sec: %@, ms: %@", buf, 0x16u);
      }
    }
  }
  if (v2)
    CFRelease(v2);
  return Mutable;
}

CFMutableDataRef SecCMSCreateCertificatesOnlyMessage(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFMutableDataRef Mutable;
  CFTypeID v6;
  const __CFAllocator *v7;
  const __CFArray *Copy;
  CFTypeID v9;
  const __CFArray *v10;
  CFIndex Count;
  uint64_t v12;
  uint64_t v13;
  CFIndex v14;
  _QWORD *ValueAtIndex;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  CFIndex v21;
  const UInt8 *v22;
  void *values;

  values = a1;
  if (!a1)
    return 0;
  v2 = SecCmsMessageCreate();
  if (!v2)
    return 0;
  v3 = v2;
  v4 = PORT_ArenaAlloc(*(_QWORD *)(v2 + 120), 0xB8uLL);
  Mutable = (CFMutableDataRef)v4;
  if (v4)
  {
    *(_QWORD *)(v4 + 176) = 0;
    *(_OWORD *)(v4 + 144) = 0u;
    *(_OWORD *)(v4 + 160) = 0u;
    *(_OWORD *)(v4 + 112) = 0u;
    *(_OWORD *)(v4 + 128) = 0u;
    *(_OWORD *)(v4 + 80) = 0u;
    *(_OWORD *)(v4 + 96) = 0u;
    *(_OWORD *)(v4 + 48) = 0u;
    *(_OWORD *)(v4 + 64) = 0u;
    *(_OWORD *)(v4 + 16) = 0u;
    *(_OWORD *)(v4 + 32) = 0u;
    *(_OWORD *)v4 = 0u;
    *(_QWORD *)(v4 + 24) = v3;
    if (!SecCmsContentInfoSetContentData((unint64_t *)v4, 0, 1)
      && !SecCmsContentInfoSetContent((unint64_t *)v3, 0x1Au, (unint64_t)Mutable)
      && SEC_ASN1EncodeInteger(*(_QWORD *)(v3 + 120), (_QWORD *)Mutable + 15, 1uLL))
    {
      v6 = CFGetTypeID(a1);
      if (v6 == SecCertificateGetTypeID())
      {
        v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Copy = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
        goto LABEL_11;
      }
      v9 = CFGetTypeID(a1);
      if (v9 == CFArrayGetTypeID())
      {
        v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFArrayRef)a1);
LABEL_11:
        v10 = Copy;
        if (Copy)
        {
          Count = CFArrayGetCount(Copy);
          if (Count >= 1)
          {
            v12 = Count;
            v13 = PORT_ArenaAlloc(*(_QWORD *)(v3 + 120), 8 * Count + 8);
            *((_QWORD *)Mutable + 18) = v13;
            if (v13)
            {
              v14 = 0;
              while (1)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v10, v14);
                if (!ValueAtIndex)
                  break;
                v16 = ValueAtIndex;
                v17 = (_QWORD *)PORT_ArenaAlloc(*(_QWORD *)(v3 + 120), 0x10uLL);
                if (v17)
                {
                  *v17 = 0;
                  v17[1] = 0;
                }
                *(_QWORD *)(*((_QWORD *)Mutable + 18) + 8 * v14) = v17;
                v18 = v16[2];
                v19 = *(_QWORD **)(*((_QWORD *)Mutable + 18) + 8 * v14);
                *v19 = v16[3];
                v19[1] = v18;
                if (v12 == ++v14)
                {
                  *(_QWORD *)(*((_QWORD *)Mutable + 18) + 8 * v12) = 0;
                  if (v12 >= 2)
                    SecCmsArraySort(*((_QWORD **)Mutable + 18), 0, 0);
                  Mutable = CFDataCreateMutable(v7, 0);
                  v21 = 0;
                  v22 = 0;
                  if (SEC_ASN1EncodeItem(*(_QWORD *)(v3 + 120), &v21, v3, (uint64_t)&SecCmsMessageTemplate))
                  {
                    CFDataAppendBytes(Mutable, v22, v21);
                    goto LABEL_23;
                  }
                  CFRelease(v10);
                  v10 = Mutable;
                  if (Mutable)
                    goto LABEL_23;
                  goto LABEL_25;
                }
              }
            }
          }
          Mutable = 0;
LABEL_23:
          CFRelease(v10);
          goto LABEL_25;
        }
      }
    }
    Mutable = 0;
  }
LABEL_25:
  SecCmsMessageDestroy(v3);
  return Mutable;
}

__CFData *SecCMSCreateCertificatesOnlyMessageIAP(__SecCertificate *a1)
{
  const __CFData *v1;
  const __CFData *v2;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFIndex v5;
  __CFData *Mutable;
  __CFData *v7;
  UInt8 *MutableBytePtr;
  __int16 v9;

  v1 = SecCertificateCopyData(a1);
  if (!v1)
    return 0;
  v2 = v1;
  BytePtr = CFDataGetBytePtr(v1);
  Length = CFDataGetLength(v2);
  if ((unint64_t)(Length - 0xFFFF) < 0xFFFFFFFFFFFF0101)
  {
    v7 = 0;
  }
  else
  {
    v5 = Length;
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    v7 = Mutable;
    if (Mutable)
    {
      CFDataAppendBytes(Mutable, SecCMSCreateCertificatesOnlyMessageIAP_header, 45);
      CFDataAppendBytes(v7, BytePtr, v5);
      CFDataAppendBytes(v7, SecCMSCreateCertificatesOnlyMessageIAP_trailer, 4);
      MutableBytePtr = CFDataGetMutableBytePtr(v7);
      v9 = CFDataGetLength(v7);
      MutableBytePtr[2] = (unsigned __int16)(v9 - 4) >> 8;
      MutableBytePtr[3] = v9 - 4;
      MutableBytePtr[17] = (unsigned __int16)(v9 - 19) >> 8;
      MutableBytePtr[18] = v9 - 19;
      MutableBytePtr[21] = (unsigned __int16)(v9 - 23) >> 8;
      MutableBytePtr[22] = v9 - 23;
      MutableBytePtr[43] = (unsigned __int16)(v9 - 49) >> 8;
      MutableBytePtr[44] = v9 - 49;
    }
  }
  CFRelease(v2);
  return v7;
}

void sub_18A9D2964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SecCTKIsQueryForSystemKeychain(void *a1)
{
  void *v1;
  uint64_t v2;
  NSObject *v3;
  _BOOL4 v4;
  const char *v5;
  int v7;
  const __CFString *v8;
  __int16 v9;
  void *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a1, "objectForKey:", CFSTR("u_SystemKeychain"));
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0 && objc_msgSend(v1, "BOOLValue"))
  {
    if (SecIsEduMode_once != -1)
      dispatch_once(&SecIsEduMode_once, &__block_literal_global_13303);
    v2 = SecIsEduMode_result;
    if (_SECKEY_LOG_once != -1)
      dispatch_once(&_SECKEY_LOG_once, &__block_literal_global_7362);
    v3 = (id)_SECKEY_LOG_log;
    v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)v2)
    {
      if (v4)
      {
        v7 = 138543618;
        v8 = CFSTR("u_SystemKeychain");
        v9 = 2114;
        v10 = v1;
        v5 = "Forcing CTK systemKey due to %{public}@=%{public}@ on shared iPad";
LABEL_15:
        _os_log_debug_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEBUG, v5, (uint8_t *)&v7, 0x16u);
      }
    }
    else if (v4)
    {
      v7 = 138543618;
      v8 = CFSTR("u_SystemKeychain");
      v9 = 2114;
      v10 = v1;
      v5 = "%{public}@=%{public}@ detected, but not on shared iPad, ignoring this flag";
      goto LABEL_15;
    }

    goto LABEL_13;
  }
  v2 = 0;
LABEL_13:

  return v2;
}

_QWORD *SecKeyCreateCTKKey(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v5;
  SecCTKKey *v6;
  id v7;
  void *v8;
  id v10;

  v5 = SecKeyCreate(a1, (uint64_t)&kSecCTKKeyDescriptor, 0, 0, 0);
  v10 = 0;
  v6 = -[SecCTKKey initWithAttributes:error:]([SecCTKKey alloc], "initWithAttributes:error:", a2, &v10);
  v7 = v10;
  v8 = v7;
  if (v6)
  {
    v5[3] = v6;
  }
  else
  {
    v5 = 0;
    if (a3)
      *a3 = v7;
  }

  return v5;
}

void SecCTKKeyDestroy(uint64_t a1)
{
  void *v2;

  v2 = (void *)MEMORY[0x18D770A24]();

  objc_autoreleasePoolPop(v2);
}

uint64_t SecCTKKeyBlockSize(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "keychainAttributes");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("bsiz"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v4 = objc_msgSend(v3, "integerValue");
    v5 = v4 + 7;
    if (v4 < -7)
      v5 = v4 + 14;
    v6 = v5 >> 3;
  }
  else
  {
    v6 = 0;
  }

  return v6;
}

uint64_t SecCTKKeyCopyAttributeDictionary(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  const __CFAllocator *v14;
  id v15;
  __CFData *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  _BYTE v29[128];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (SecCTKKeyCopyAttributeDictionary_onceToken != -1)
    dispatch_once(&SecCTKKeyCopyAttributeDictionary_onceToken, &__block_literal_global_70);
  +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_alloc_init(MEMORY[0x1E0C99E08]);
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v4 = (id)SecCTKKeyCopyAttributeDictionary_exportableAttributes;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
  if (v5)
  {
    v6 = v5;
    v7 = *(_QWORD *)v26;
    do
    {
      for (i = 0; i != v6; ++i)
      {
        if (*(_QWORD *)v26 != v7)
          objc_enumerationMutation(v4);
        v9 = *(_QWORD *)(*((_QWORD *)&v25 + 1) + 8 * i);
        objc_msgSend(v2, "keychainAttributes", (_QWORD)v25);
        v10 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v10, "objectForKeyedSubscript:", v9);
        v11 = (void *)objc_claimAutoreleasedReturnValue();

        if (v11)
          objc_msgSend(v3, "setObject:forKeyedSubscript:", v11, v9);

      }
      v6 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v25, v29, 16);
    }
    while (v6);
  }

  objc_msgSend(v2, "tokenObject");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v12, "publicKey");
  v13 = (void *)objc_claimAutoreleasedReturnValue();

  v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v15 = objc_retainAutorelease(v13);
  v16 = SecSHA1DigestCreate(v14, objc_msgSend(v15, "bytes"), objc_msgSend(v15, "length"));
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v16, CFSTR("klbl"));

  objc_msgSend(v3, "setObject:forKeyedSubscript:", MEMORY[0x1E0C9AAB0], CFSTR("perm"));
  objc_msgSend(v2, "tokenObject");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v17, "session");
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v18, "token");
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v19, "tokenID");
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v20, CFSTR("tkid"));

  objc_msgSend(v2, "tokenObject");
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v21, "objectID");
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setObject:forKeyedSubscript:", v22, CFSTR("toid"));

  v23 = objc_msgSend(v3, "copy");
  return v23;
}

id SecCTKKeyCopyKeyDescription(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  __CFString *v6;
  __CFString *v7;
  void *v8;
  id v9;

  +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "keychainAttributes");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("tkid"));
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = (void *)v4;
  v6 = CFSTR("uninited");
  if (v4)
    v6 = (__CFString *)v4;
  v7 = v6;

  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("<SecKeyRef:('%@') %p>"), v7, a1);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  v9 = v8;
  return v9;
}

uint64_t SecCTKGetAlgorithmID(uint64_t a1)
{
  void *v1;
  uint64_t v2;

  +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = objc_msgSend(v1, "algorithmID");

  return v2;
}

uint64_t SecCTKKeyCopyPublicOctets(uint64_t a1, uint64_t *a2)
{
  void *v3;
  void *v4;

  +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "tokenObject");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "publicKey");
  *a2 = objc_claimAutoreleasedReturnValue();

  return 0;
}

uint64_t SecCTKKeyCopyOperationResult(uint64_t a1, unint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, __CFString **a8)
{
  uint64_t v9;
  uint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  id v18;
  id v20;

  if (a2 < 7 && ((0x59u >> a2) & 1) != 0)
  {
    v13 = qword_18AA5C7A0[a2];
    +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a1);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v14, "tokenObject");
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v15, "session");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v16, "setAuthenticateWhenNeeded:", 1);

    objc_msgSend(v14, "tokenObject");
    v17 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = 0;
    objc_msgSend(v17, "operation:data:algorithms:parameters:error:", v13, a6, a4, a7, &v20);
    v9 = objc_claimAutoreleasedReturnValue();
    v18 = v20;

    if (a8 && !v9)
      *a8 = (__CFString *)v18;

  }
  else
  {
    SecError(-50, a8, CFSTR("Invalid key operation %d"), a2);
    return 0;
  }
  return v9;
}

uint64_t SecCTKKeyIsEqual(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  uint64_t v5;

  +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v3, "isEqual:", v4);

  return v5;
}

_QWORD *SecCTKKeyCreateDuplicate(const void *a1)
{
  void *v2;
  CFAllocatorRef v3;
  _QWORD *v4;

  +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = CFGetAllocator(a1);
  v4 = SecKeyCreate((uint64_t)v3, (uint64_t)&kSecCTKKeyDescriptor, 0, 0, 0);
  v4[3] = objc_msgSend(v2, "copy");

  return v4;
}

uint64_t SecCTKKeySetParameter(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  void *v6;
  void *v7;
  id v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  uint64_t i;
  void *v15;
  void *v16;
  id v17;
  uint64_t v18;
  void *v19;
  id v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  id v26;
  void *v27;
  void *v28;
  void *v29;
  id v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  void *v34;
  void *v37;
  id v38;
  id v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  const __CFString *v45;
  _BYTE v46[128];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a1);
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v37, "sessionParameters");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = (void *)objc_msgSend(v6, "mutableCopy");

  objc_msgSend(v7, "setObject:forKeyedSubscript:", a3, a2);
  v8 = v7;
  v40 = 0u;
  v41 = 0u;
  v42 = 0u;
  v43 = 0u;
  v9 = (void *)objc_msgSend(v8, "copy");
  v10 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v40, v46, 16);
  if (v10)
  {
    v11 = v10;
    v12 = 0;
    v13 = *(_QWORD *)v41;
    do
    {
      for (i = 0; i != v11; ++i)
      {
        if (*(_QWORD *)v41 != v13)
          objc_enumerationMutation(v9);
        v15 = *(void **)(*((_QWORD *)&v40 + 1) + 8 * i);
        objc_msgSend(v8, "objectForKeyedSubscript:", v15);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        if (objc_msgSend(v15, "isEqual:", CFSTR("u_AuthCtx")))
        {
          v17 = v16;

          objc_msgSend(v8, "removeObjectForKey:", v15);
          v12 = v17;
        }
        if (objc_msgSend(v15, "isEqual:", CFSTR("u_CredRef")))
        {
          if (LocalAuthenticationLibraryCore())
          {
            v18 = objc_msgSend(objc_alloc((Class)getLAContextClass()), "initWithExternalizedContext:", v16);

            v12 = (id)v18;
          }
          objc_msgSend(v8, "removeObjectForKey:", v15);
        }
        if (objc_msgSend(v15, "isEqual:", CFSTR("u_OpPrompt")))
        {
          if (LocalAuthenticationLibraryCore())
          {
            if (!v12)
              v12 = objc_alloc_init((Class)getLAContextClass());
            objc_msgSend(v12, "setLocalizedReason:", v16);
          }
          objc_msgSend(v8, "removeObjectForKey:", v15);
        }
        if (LocalAuthenticationLibraryCore() && objc_msgSend(v15, "isEqual:", CFSTR("u_CallerName")))
        {
          if (LocalAuthenticationLibraryCore())
          {
            if (!v12)
              v12 = objc_alloc_init((Class)getLAContextClass());
            objc_msgSend(v12, "setOptionCallerName:", v16);
          }
          objc_msgSend(v8, "removeObjectForKey:", v15);
        }
        if (objc_msgSend(v15, "isEqual:", CFSTR("u_AuthUI")))
        {
          if (LocalAuthenticationLibraryCore())
          {
            if (!v12)
              v12 = objc_alloc_init((Class)getLAContextClass());
            objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", objc_msgSend(v16, "isEqual:", CFSTR("u_AuthUIF")));
            v19 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v12, "setOptionNotInteractive:", v19);

          }
          objc_msgSend(v8, "removeObjectForKey:", v15);
        }

      }
      v11 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v40, v46, 16);
    }
    while (v11);
  }
  else
  {
    v12 = 0;
  }

  if (CryptoTokenKitLibraryCore())
  {
    v20 = objc_alloc((Class)getTKClientTokenSessionClass());
    v21 = v37;
    objc_msgSend(v37, "tokenObject");
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v22, "session");
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v23, "token");
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    v39 = 0;
    v25 = (void *)objc_msgSend(v20, "initWithToken:LAContext:parameters:error:", v24, v12, v8, &v39);
    v26 = v39;

    objc_msgSend(v37, "tokenObject");
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v27, "objectID");
    v28 = (void *)objc_claimAutoreleasedReturnValue();
    v38 = v26;
    objc_msgSend(v25, "objectForObjectID:error:", v28, &v38);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    v30 = v38;

    if (v29)
    {
      objc_msgSend(v37, "setSessionParameters:", v8);
      objc_msgSend(v37, "setTokenObject:", v29);

      v31 = 1;
      goto LABEL_42;
    }
  }
  else
  {
    v32 = (void *)MEMORY[0x1E0CB35C8];
    v33 = *MEMORY[0x1E0CB2F90];
    v44 = *MEMORY[0x1E0CB2938];
    v45 = CFSTR("CryptoTokenKit is not available");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v45, &v44, 1);
    v34 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v32, "errorWithDomain:code:userInfo:", v33, -4, v34);
    v30 = (id)objc_claimAutoreleasedReturnValue();

    v21 = v37;
  }
  if (a4)
  {
    v30 = v30;
    v31 = 0;
    *a4 = v30;
  }
  else
  {
    v31 = 0;
  }
LABEL_42:

  return v31;
}

_QWORD *SecKeyCopySystemKey(uint64_t a1, __CFString **a2)
{
  const __CFAllocator *v3;
  const UInt8 *v4;
  _QWORD *CTKKey;
  const __CFAllocator *v6;
  CFIndex v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  CFDataRef v15;
  CFDictionaryRef v16;

  switch((int)a1)
  {
    case 0:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_sikObjectIDBytes;
      goto LABEL_5;
    case 1:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_gidObjectIDBytes;
LABEL_5:
      v6 = v3;
      v7 = 23;
      goto LABEL_21;
    case 2:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_uikCommittedObjectIDBytes;
      goto LABEL_20;
    case 3:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_uikProposedObjectIDBytes;
      goto LABEL_20;
    case 4:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v15 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], SecKeyCopySystemKey_casdObjectIDBytes, 29);
      goto LABEL_22;
    case 5:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_oikCommittedObjectIDBytes;
      goto LABEL_20;
    case 6:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_oikProposedObjectIDBytes;
      goto LABEL_20;
    case 7:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_dakCommittedObjectIDBytes;
      goto LABEL_20;
    case 8:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_dakProposedObjectIDBytes;
      goto LABEL_20;
    case 9:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_havenCommittedObjectIDBytes;
      goto LABEL_15;
    case 10:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_havenProposedObjectIDBytes;
LABEL_15:
      v6 = v3;
      v7 = 26;
      goto LABEL_21;
    case 11:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_sdakCommittedObjectIDBytes;
      goto LABEL_18;
    case 12:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_sdakProposedObjectIDBytes;
LABEL_18:
      v6 = v3;
      v7 = 25;
      goto LABEL_21;
    case 13:
      v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v4 = (const UInt8 *)&SecKeyCopySystemKey_dcikObjectIDBytes;
LABEL_20:
      v6 = v3;
      v7 = 24;
LABEL_21:
      v15 = CFDataCreate(v6, v4, v7);
LABEL_22:
      v16 = CFDictionaryCreateForCFTypes(v3, v8, v9, v10, v11, v12, v13, v14, (uint64_t)CFSTR("toid"), (uint64_t)v15);
      if (SecCFAllocatorZeroize_sOnce != -1)
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
      CTKKey = SecKeyCreateCTKKey(SecCFAllocatorZeroize_sAllocator, (uint64_t)v16, a2);
      if (v16)
        CFRelease(v16);
      if (v15)
        CFRelease(v15);
      break;
    default:
      SecError(-50, a2, CFSTR("unexpected system key type %d"), a1);
      CTKKey = 0;
      break;
  }
  return CTKKey;
}

uint64_t SecKeyCreateAttestation(uint64_t a1, uint64_t a2, __CFString **a3)
{
  void *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  id v17;
  id v18;
  os_activity_scope_state_s state;

  v6 = (void *)MEMORY[0x18D770A24]();
  v7 = _os_activity_create(&dword_18A900000, "SecKeyCreateAttestation", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateAttestation");
  +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a1);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a2);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  if (*(_UNKNOWN **)(a1 + 16) == &kSecCTKKeyDescriptor)
  {
    if (*(_UNKNOWN **)(a2 + 16) == &kSecCTKKeyDescriptor)
    {
      objc_msgSend(v8, "tokenObject");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v9, "tokenObject");
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "sessionParameters");
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v14, "objectForKeyedSubscript:", CFSTR("com.apple.security.seckey.setoken.attestation-nonce"));
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      v18 = 0;
      objc_msgSend(v12, "attestKeyObject:nonce:error:", v13, v15, &v18);
      v10 = objc_claimAutoreleasedReturnValue();
      v17 = v18;

      v16 = v17;
      _SecKeyErrorPropagate(v10 != 0, (uint64_t)"SecKeyCreateAttestation", v16, a3);

      goto LABEL_6;
    }
    SecError(-4, a3, CFSTR("attestation not supported for key %@"), a2);
  }
  else
  {
    SecError(-4, a3, CFSTR("attestation not supported by key %@"), a1);
  }
  v10 = 0;
LABEL_6:

  os_activity_scope_leave(&state);
  objc_autoreleasePoolPop(v6);
  return v10;
}

void sub_18A9D4248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

BOOL SecKeyControlLifetime(uint64_t a1, uint64_t a2, __CFString **a3)
{
  void *v6;
  NSObject *v7;
  _BOOL8 v8;
  void *v9;
  void *v10;
  void *v11;
  id *v12;
  uint64_t v13;
  id v14;
  id v15;
  uint64_t v17;
  uint64_t v18;
  os_activity_scope_state_s state;

  v6 = (void *)MEMORY[0x18D770A24]();
  v7 = _os_activity_create(&dword_18A900000, "SecKeyControlLifetime", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyControlLifetime");
  if (*(_UNKNOWN **)(a1 + 16) == &kSecCTKKeyDescriptor)
  {
    +[SecCTKKey fromKeyRef:](SecCTKKey, "fromKeyRef:", a1);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = v9;
    if ((_DWORD)a2)
    {
      if ((_DWORD)a2 != 1)
      {
        v8 = SecError(-50, a3, CFSTR("Unsupported lifetime operation %d requested"), a2);
        v15 = 0;
        goto LABEL_9;
      }
      objc_msgSend(v9, "tokenObject");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      v17 = 0;
      v12 = (id *)&v17;
      v13 = objc_msgSend(v11, "commitKeyWithError:", &v17);
    }
    else
    {
      objc_msgSend(v9, "tokenObject");
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      v18 = 0;
      v12 = (id *)&v18;
      v13 = objc_msgSend(v11, "bumpKeyWithError:", &v18);
    }
    v8 = v13;
    v14 = *v12;

    v15 = v14;
    _SecKeyErrorPropagate(v8, (uint64_t)"SecKeyControlLifetime", v15, a3);
LABEL_9:

    goto LABEL_10;
  }
  v8 = SecError(-4, a3, CFSTR("lifetimecontrol not supported for key %@"), a1);
LABEL_10:
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v6);
  return v8;
}

void sub_18A9D440C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t SecCEPPrivateKeyUsagePeriod()
{
  return 1;
}

uint64_t SecCEPIssuerAltName()
{
  return 1;
}

uint64_t SecCEPNameConstraints(uint64_t a1, uint64_t a2)
{
  __int128 v3;
  uint64_t result;
  NSObject *v5;
  _BOOL4 v6;
  uint8_t v7[16];
  __int128 v8;
  __int128 v9;

  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8 = v3;
  v9 = v3;
  if (!DERParseSequence(a2 + 24, (unsigned __int16)DERNumNameConstraintsItemSpecs, (uint64_t)&DERNameConstraintsItemSpecs, (unint64_t)&v8, 0x20uLL)&& (!*((_QWORD *)&v8 + 1) || !parseGeneralSubtrees((unint64_t *)&v8, (CFTypeRef *)(a1 + 488)))&& (!*((_QWORD *)&v9 + 1) || !parseGeneralSubtrees((unint64_t *)&v9, (CFTypeRef *)(a1 + 496))))
  {
    return 1;
  }
  v5 = secLogObjForScope("SecWarning");
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v6)
  {
    *(_WORD *)v7 = 0;
    _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "Invalid Name Constraints extension", v7, 2u);
    return 0;
  }
  return result;
}

uint64_t SecCEPPolicyMappings(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  int v6;
  NSObject *v8;
  _BOOL4 v9;
  uint64_t result;
  _OWORD *v11;
  unint64_t v12;
  __int128 v13;
  _OWORD *v14;
  uint8_t buf[16];
  __int128 v16;
  unint64_t v17[3];
  unint64_t v18[3];

  v4 = a2 + 24;
  memset(v18, 170, sizeof(v18));
  if (DERDecodeSeqInit(a2 + 24, &v18[2], v18) || v18[2] != 0x2000000000000010)
    goto LABEL_10;
  v5 = 0;
  memset(v17, 170, sizeof(v17));
  while (1)
  {
    v6 = DERDecodeSeqNext(v18, v17);
    if (v6)
      break;
    if (v17[0] != 0x2000000000000010 || v5++ >= 0x1FFF)
      goto LABEL_10;
  }
  if (!v5)
    goto LABEL_10;
  if (v6 != 1)
    goto LABEL_10;
  v14 = malloc_type_malloc(32 * v5, 0x1010040E633A1C4uLL);
  if (!v14)
    goto LABEL_10;
  if (DERDecodeSeqInit(v4, &v18[2], v18))
  {
LABEL_23:
    free(v14);
LABEL_10:
    *(_BYTE *)(a1 + 328) = 0;
    v8 = secLogObjForScope("SecWarning");
    v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v9)
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEFAULT, "Invalid PolicyMappings Extension", buf, 2u);
      return 0;
    }
    return result;
  }
  v11 = v14 + 1;
  v12 = v5;
  do
  {
    if (DERDecodeSeqNext(v18, v17))
      break;
    if (v17[0] != 0x2000000000000010)
      goto LABEL_23;
    *(_QWORD *)&v13 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v13 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)buf = v13;
    v16 = v13;
    if (DERParseSequenceContent(&v17[1], (unsigned __int16)DERNumPolicyMappingItemSpecs, (uint64_t)&DERPolicyMappingItemSpecs, (unint64_t)buf, 0x20uLL))goto LABEL_23;
    *(v11 - 1) = *(_OWORD *)buf;
    *v11 = v16;
    v11 += 2;
    --v12;
  }
  while (v12);
  result = 1;
  *(_BYTE *)(a1 + 328) = 1;
  *(_BYTE *)(a1 + 329) = *(_BYTE *)(a2 + 16);
  *(_QWORD *)(a1 + 336) = v5;
  *(_QWORD *)(a1 + 344) = v14;
  return result;
}

uint64_t SecCEPPolicyConstraints(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  uint64_t result;
  NSObject *v6;
  _BOOL4 v7;
  uint8_t v8[16];
  __int128 v9;
  __int128 v10;

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v9 = v4;
  v10 = v4;
  if (DERParseSequence(a2 + 24, (unsigned __int16)DERNumPolicyConstraintsItemSpecs, (uint64_t)&DERPolicyConstraintsItemSpecs, (unint64_t)&v9, 0x20uLL))goto LABEL_10;
  if (*((_QWORD *)&v9 + 1))
  {
    if (DERParseInteger((char **)&v9, (_DWORD *)(a1 + 312)))
      goto LABEL_10;
    *(_BYTE *)(a1 + 310) = 1;
  }
  if (!*((_QWORD *)&v10 + 1))
  {
LABEL_8:
    result = 1;
    *(_BYTE *)(a1 + 308) = 1;
    *(_BYTE *)(a1 + 309) = *(_BYTE *)(a2 + 16);
    return result;
  }
  if (!DERParseInteger((char **)&v10, (_DWORD *)(a1 + 320)))
  {
    *(_BYTE *)(a1 + 316) = 1;
    goto LABEL_8;
  }
LABEL_10:
  *(_BYTE *)(a1 + 308) = 0;
  v6 = secLogObjForScope("SecWarning");
  v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v7)
  {
    *(_WORD *)v8 = 0;
    _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "Invalid PolicyConstraints Extension", v8, 2u);
    return 0;
  }
  return result;
}

uint64_t SecCEPInhibitAnyPolicy(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  NSObject *v5;
  _BOOL4 v6;
  uint8_t v7[8];
  unint64_t v8[3];

  memset(v8, 170, sizeof(v8));
  if (DERDecodeItem(a2 + 24, v8)
    || v8[0] != 2
    || DERParseInteger((char **)&v8[1], (_DWORD *)(a1 + 380)))
  {
    *(_BYTE *)(a1 + 376) = 0;
    v5 = secLogObjForScope("SecWarning");
    v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v6)
    {
      *(_WORD *)v7 = 0;
      _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "Invalid InhibitAnyPolicy Extension", v7, 2u);
      return 0;
    }
  }
  else
  {
    result = 1;
    *(_BYTE *)(a1 + 376) = 1;
    *(_BYTE *)(a1 + 377) = *(_BYTE *)(a2 + 16);
  }
  return result;
}

uint64_t SecCEPSubjectInfoAccess()
{
  return 1;
}

uint64_t SecCEPNetscapeCertType()
{
  return 1;
}

uint64_t SecCEPEntrustVersInfo()
{
  return 1;
}

uint64_t SecCEPEscrowMarker()
{
  return 1;
}

CFDataRef parseGeneralSubtrees(unint64_t *a1, CFTypeRef *a2)
{
  unint64_t *v3;
  const __CFAllocator *v4;
  CFMutableArrayRef Mutable;
  CFMutableArrayRef v6;
  int i;
  uint64_t v8;
  CFDataRef v9;
  __int128 v10;
  unint64_t *v11;
  NSObject *v12;
  UInt8 *bytes[2];
  __int128 v15;
  __int128 v16;
  unint64_t v17[3];
  unint64_t v18[2];
  uint8_t buf[4];
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v18[0] = 0xAAAAAAAAAAAAAAAALL;
  v18[1] = 0xAAAAAAAAAAAAAAAALL;
  v3 = DERDecodeSeqContentInit(a1, v18);
  if ((_DWORD)v3)
    return (CFDataRef)v3;
  memset(v17, 170, sizeof(v17));
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (!Mutable)
    return 0;
  v6 = Mutable;
  for (i = 0x2000; ; --i)
  {
    v8 = DERDecodeSeqNext(v18, v17);
    if ((_DWORD)v8 == 1)
      goto LABEL_18;
    v9 = (CFDataRef)v8;
    if ((_DWORD)v8)
      goto LABEL_23;
    *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v15 = v10;
    v16 = v10;
    *(_OWORD *)bytes = v10;
    if (v17[0] != 0x2000000000000010)
    {
LABEL_22:
      v9 = 0;
LABEL_23:
      CFRelease(v6);
      return v9;
    }
    v11 = DERParseSequenceContent(&v17[1], (unsigned __int16)DERNumGeneralSubtreeItemSpecs, (uint64_t)&DERGeneralSubtreeItemSpecs, (unint64_t)bytes, 0x30uLL);
    if ((_DWORD)v11)
    {
      v9 = (CFDataRef)v11;
      goto LABEL_23;
    }
    if (*((_QWORD *)&v15 + 1))
    {
      *(_DWORD *)buf = -1431655766;
      if (DERParseInteger((char **)&v15, buf) || *(_DWORD *)buf)
        goto LABEL_22;
    }
    if (*((_QWORD *)&v16 + 1) || (unint64_t)(bytes[1] - 0x7FFFFFFFFFFFFFFFLL) < 0x8000000000000002)
      goto LABEL_22;
    v9 = CFDataCreate(v4, bytes[0], (CFIndex)bytes[1]);
    if (!v9)
      goto LABEL_23;
    CFArrayAppendValue(v6, v9);
    CFRelease(v9);
    if (!i)
      break;
  }
  v12 = secLogObjForScope("SecWarning");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    v20 = 0x2000;
    _os_log_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEFAULT, "Skipping subtrees after the first %d", buf, 8u);
  }
LABEL_18:
  if (*a2)
    CFRelease(*a2);
  v9 = 0;
  *a2 = v6;
  return v9;
}

__CFString *copyHexDescription(const __CFAllocator *a1, unsigned __int8 **a2)
{
  unint64_t v2;
  __CFString *Mutable;
  uint64_t i;

  v2 = (unint64_t)a2[1];
  if (v2 > 0x2AAAAAAAAAAAAAA9)
    return 0;
  Mutable = CFStringCreateMutable(a1, 3 * v2 - 1);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      if (i)
        CFStringAppendFormat(Mutable, 0, CFSTR(" %02X"), (*a2)[i]);
      else
        CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), **a2);
    }
  }
  return Mutable;
}

__CFString *copyIntegerContentDescription(const __CFAllocator *a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v4;
  unsigned __int8 *v5;
  unsigned int v6;

  v2 = *(_QWORD *)(a2 + 8);
  if ((unint64_t)(v2 - 9) < 0xFFFFFFFFFFFFFFF8)
    return copyHexDescription(a1, (unsigned __int8 **)a2);
  v4 = 0;
  v5 = *(unsigned __int8 **)a2;
  do
  {
    v6 = *v5++;
    v4 = v6 | (v4 << 8);
    --v2;
  }
  while (v2);
  return (__CFString *)CFStringCreateWithFormat(a1, 0, CFSTR("%llu"), v4);
}

CFStringRef copyBlobString(const __CFAllocator *a1, const __CFString *cf, const __CFString *a3, uint64_t a4, char a5)
{
  CFStringRef v7;
  const __CFString *v9;
  __CFString *v10;
  CFStringRef v11;

  v7 = cf;
  if ((a5 & 1) != 0)
  {
    v7 = SecFrameworkCopyLocalizedString(cf, CFSTR("Certificate"));
    a3 = SecFrameworkCopyLocalizedString(a3, CFSTR("Certificate"));
    v9 = SecFrameworkCopyLocalizedString(CFSTR("%@; %d %@; data = %@"), CFSTR("Certificate"));
  }
  else
  {
    if (cf)
      CFRetain(cf);
    if (a3)
      CFRetain(a3);
    v9 = CFSTR("%@; %d %@; data = %@");
  }
  v10 = copyHexDescription(a1, (unsigned __int8 **)a4);
  v11 = CFStringCreateWithFormat(a1, 0, v9, v7, *(_QWORD *)(a4 + 8), a3, v10);
  CFRelease(v10);
  CFRelease(v9);
  if (a3)
    CFRelease(a3);
  if (v7)
    CFRelease(v7);
  return v11;
}

CFStringRef copyOidDescription(const __CFAllocator *a1, uint64_t a2, int a3)
{
  CFStringRef v6;
  unint64_t v7;
  CFMutableStringRef Mutable;
  unint64_t v9;
  CFStringRef v10;
  CFStringRef v11;
  CFStringRef v12;

  if (a2 && *(_QWORD *)(a2 + 8))
  {
    v6 = SecDERItemCopyOIDDecimalRepresentation(a1, (unsigned __int8 **)a2);
    if (!a3)
      return v6;
    v7 = *(_QWORD *)(a2 + 8);
    if (v7 > 0x2AAAAAAAAAAAAAA5)
      return v6;
    Mutable = CFStringCreateMutable(a1, 3 * v7 + 5);
    CFStringAppendFormat(Mutable, 0, CFSTR("06 %02lX"), *(_QWORD *)(a2 + 8));
    if (*(_QWORD *)(a2 + 8))
    {
      v9 = 0;
      do
        CFStringAppendFormat(Mutable, 0, CFSTR(" %02X"), *(unsigned __int8 *)(*(_QWORD *)a2 + v9++));
      while (v9 < *(_QWORD *)(a2 + 8));
    }
    v10 = SecFrameworkCopyLocalizedString(Mutable, CFSTR("OID"));
    if (v10)
    {
      v11 = v10;
      if (CFEqual(Mutable, v10))
      {
        v12 = v11;
        v11 = v6;
LABEL_16:
        CFRelease(v12);
        goto LABEL_17;
      }
      v12 = v6;
      if (v6)
        goto LABEL_16;
    }
    else
    {
      v11 = v6;
    }
LABEL_17:
    CFRelease(Mutable);
    return v11;
  }
  if (a3)
    return SecFrameworkCopyLocalizedString(CFSTR("<NULL>"), CFSTR("Certificate"));
  return CFSTR("<NULL>");
}

CFMutableArrayRef SecCertificateCopyRFC822Names(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  uint64_t v3;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = *(_QWORD *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames(v3 + 24, (uint64_t)Mutable, (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendRFC822NamesFromGeneralNames)|| parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendRFC822NamesFromX501Name, 1)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

const __CFArray *SecCertificateCopyDNSNames(uint64_t a1)
{
  const __CFAllocator *v2;
  const __CFArray *Mutable;
  int v4;
  BOOL v5;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (*(_QWORD *)(a1 + 456))
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v4 = SecCertificateParseGeneralNames(*(_QWORD *)(a1 + 456) + 24, (uint64_t)Mutable, (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendDNSNamesFromGeneralNames);
    if (Mutable)
      v5 = v4 == 0;
    else
      v5 = 0;
    if (v5)
    {
      if (CFArrayGetCount(Mutable) > 0)
        return Mutable;
    }
    else if (!Mutable)
    {
      goto LABEL_10;
    }
    CFRelease(Mutable);
  }
LABEL_10:
  Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
  if (parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendDNSNamesFromX501Name, 1)|| !CFArrayGetCount(Mutable))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

uint64_t appendDNSNamesFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result;
  __CFString *v9;
  __CFString *v10;

  result = DEROidCompare(a2, (uint64_t)&oidCommonName);
  if ((_DWORD)result)
  {
    v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, 1, a5);
    if (v9)
    {
      v10 = v9;
      if (SecFrameworkIsDNSName(v9))
        CFArrayAppendValue(a1, v10);
      CFRelease(v10);
      return 0;
    }
    else
    {
      return 4294941021;
    }
  }
  return result;
}

uint64_t appendRFC822NamesFromGeneralNames(__CFArray *a1, int a2, uint64_t a3)
{
  CFStringRef v4;
  CFStringRef v5;

  if (a2 != 1)
    return 0;
  if ((*(_QWORD *)(a3 + 8) & 0x8000000000000000) != 0)
    return 4294941021;
  v4 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(const UInt8 **)a3, *(_QWORD *)(a3 + 8), 0x600u, 0);
  if (!v4)
    return 4294941021;
  v5 = v4;
  CFArrayAppendValue(a1, v4);
  CFRelease(v5);
  return 0;
}

uint64_t appendRFC822NamesFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result;
  __CFString *v9;
  __CFString *v10;

  result = DEROidCompare(a2, (uint64_t)&oidEmailAddress);
  if ((_DWORD)result)
  {
    v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, 1, a5);
    if (v9)
    {
      v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0;
    }
    else
    {
      return 4294941021;
    }
  }
  return result;
}

SecCertificateRef SecCertificateCreateWithKeychainItem(const __CFAllocator *a1, const __CFData *a2, const void *a3)
{
  SecCertificateRef v4;

  v4 = SecCertificateCreateWithData(a1, a2);
  if (v4)
  {
    if (a3)
      CFRetain(a3);
    *((_QWORD *)v4 + 77) = a3;
  }
  return v4;
}

uint64_t SecCertificateSetKeychainItem(uint64_t a1, CFTypeRef cf)
{
  const void *v4;
  uint64_t result;

  if (!a1)
    return 4294967246;
  if (cf)
    CFRetain(cf);
  v4 = *(const void **)(a1 + 616);
  if (v4)
    CFRelease(v4);
  result = 0;
  *(_QWORD *)(a1 + 616) = cf;
  return result;
}

void appendProperty(void *cf, void *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, char a6)
{
  CFStringRef v10;
  const __CFAllocator *v11;
  CFDictionaryRef v12;
  const __CFAllocator *v13;
  CFIndex v14;
  void *values;
  const __CFString *v16;
  const __CFString *v17;
  const __CFString *v18;
  void *keys;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    if ((a6 & 1) != 0)
    {
      if (a4)
      {
        v10 = 0;
      }
      else
      {
        v10 = SecFrameworkCopyLocalizedString(a3, CFSTR("Certificate"));
        a4 = v10;
      }
    }
    else
    {
      CFRetain(a3);
      v10 = a3;
      a4 = a3;
    }
    keys = CFSTR("type");
    v20 = CFSTR("label");
    v21 = CFSTR("localized label");
    v22 = CFSTR("value");
    values = a2;
    v16 = a3;
    v17 = a4;
    v18 = a5;
    v13 = CFGetAllocator(cf);
    if (a5)
      v14 = 4;
    else
      v14 = 3;
    v12 = CFDictionaryCreate(v13, (const void **)&keys, (const void **)&values, v14, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (v10)
      CFRelease(v10);
  }
  else
  {
    keys = CFSTR("type");
    v20 = CFSTR("value");
    values = a2;
    v16 = a5;
    v11 = CFGetAllocator(cf);
    v12 = CFDictionaryCreate(v11, (const void **)&keys, (const void **)&values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  CFArrayAppendValue((CFMutableArrayRef)cf, v12);
  CFRelease(v12);
}

double SecAbsoluteTimeFromDateContent(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  return SecAbsoluteTimeFromDateContentWithError(a1, a2, a3, 0);
}

CFDateRef SecCertificateCopyNotValidBeforeDate(CFDateRef result)
{
  if (result)
    return CFDateCreate(0, *((CFAbsoluteTime *)result + 21));
  return result;
}

CFDateRef SecCertificateCopyNotValidAfterDate(CFDateRef result)
{
  if (result)
    return CFDateCreate(0, *((CFAbsoluteTime *)result + 22));
  return result;
}

CFMutableArrayRef SecCertificateCopySummaryProperties(double *a1, double a2)
{
  const __CFAllocator *v4;
  CFMutableArrayRef Mutable;
  const __CFString *v6;
  const __CFString *v7;
  double v8;
  __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  double v12;
  const __CFString *v13;

  v4 = CFGetAllocator(a1);
  Mutable = CFArrayCreateMutable(v4, 0, MEMORY[0x1E0C9B378]);
  v6 = SecCertificateCopySubjectSummary((SecCertificateRef)a1);
  if (v6)
  {
    v7 = v6;
    appendProperty(Mutable, CFSTR("title"), 0, 0, v6, 1);
    CFRelease(v7);
  }
  v8 = a1[22];
  if (v8 >= a2)
  {
    v12 = a1[21];
    if (v12 <= a2)
      v11 = CFSTR("Expires");
    else
      v11 = CFSTR("Valid from");
    if (v12 <= a2)
    {
      v10 = CFSTR("This certificate is valid");
    }
    else
    {
      v8 = a1[21];
      v10 = CFSTR("This certificate is not yet valid");
    }
    if (v12 <= a2)
      v9 = CFSTR("success");
    else
      v9 = CFSTR("error");
  }
  else
  {
    v9 = CFSTR("error");
    v10 = CFSTR("This certificate has expired");
    v11 = CFSTR("Expired");
  }
  appendDateProperty(Mutable, v11, 1, v8);
  v13 = SecFrameworkCopyLocalizedString(v10, CFSTR("Certificate"));
  appendProperty(Mutable, v9, 0, 0, v13, 1);
  CFRelease(v13);
  return Mutable;
}

void appendDateProperty(void *a1, const __CFString *a2, char a3, CFAbsoluteTime a4)
{
  const __CFAllocator *v8;
  const __CFString *v9;

  v8 = CFGetAllocator(a1);
  v9 = (const __CFString *)CFDateCreate(v8, a4);
  appendProperty(a1, CFSTR("date"), a2, 0, v9, a3);
  CFRelease(v9);
}

CFMutableArrayRef SecCertificateCopyLegacyProperties(uint64_t a1)
{
  const __CFAllocator *v2;
  CFMutableArrayRef Mutable;
  __CFArray *PropertiesForX501NameContent;
  __CFArray *v5;
  const __CFString *v6;
  uint64_t v7;
  uint64_t v8;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E0C9B378]);
  PropertiesForX501NameContent = createPropertiesForX501NameContent(v2, (unint64_t *)(a1 + 184), 0);
  appendProperty(Mutable, CFSTR("section"), CFSTR("Subject Name"), 0, (const __CFString *)PropertiesForX501NameContent, 0);
  CFRelease(PropertiesForX501NameContent);
  v5 = createPropertiesForX501NameContent(v2, (unint64_t *)(a1 + 152), 0);
  appendProperty(Mutable, CFSTR("section"), CFSTR("Issuer Name"), 0, (const __CFString *)v5, 0);
  CFRelease(v5);
  v6 = CFStringCreateWithFormat(v2, 0, CFSTR("%d"), *(unsigned __int8 *)(a1 + 96) + 1);
  appendProperty(Mutable, CFSTR("string"), CFSTR("Version"), 0, v6, 0);
  CFRelease(v6);
  if (*(_QWORD *)(a1 + 112))
    appendIntegerProperty(Mutable, CFSTR("Serial Number"), a1 + 104, 0);
  appendAlgorithmProperty(Mutable, CFSTR("Signature Algorithm"), a1 + 120, 0);
  appendDateProperty(Mutable, CFSTR("Not Valid Before"), 0, *(CFAbsoluteTime *)(a1 + 168));
  appendDateProperty(Mutable, CFSTR("Not Valid After"), 0, *(CFAbsoluteTime *)(a1 + 176));
  if (*(_QWORD *)(a1 + 288))
    appendDataProperty(Mutable, CFSTR("Subject Unique ID"), 0, a1 + 280, 0);
  if (*(_QWORD *)(a1 + 272))
    appendDataProperty(Mutable, CFSTR("Issuer Unique ID"), 0, a1 + 264, 0);
  appendAlgorithmProperty(Mutable, CFSTR("Public Key Algorithm"), a1 + 216, 0);
  appendDataProperty(Mutable, CFSTR("Public Key Data"), 0, a1 + 248, 0);
  appendDataProperty(Mutable, CFSTR("Signature"), 0, a1 + 80, 0);
  if (*(uint64_t *)(a1 + 512) >= 1)
  {
    v7 = 0;
    v8 = 0;
    do
    {
      appendExtension(Mutable, *(_QWORD *)(a1 + 520) + v7, 0);
      ++v8;
      v7 += 40;
    }
    while (v8 < *(_QWORD *)(a1 + 512));
  }
  appendFingerprintsProperty(Mutable, (__CFData *)a1, 0);
  return Mutable;
}

__CFArray *createPropertiesForX501NameContent(const __CFAllocator *a1, unint64_t *a2, uint64_t a3)
{
  __CFArray *Mutable;

  Mutable = CFArrayCreateMutable(a1, 0, MEMORY[0x1E0C9B378]);
  if (parseX501NameContent(a2, (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendRDNProperty, a3))
  {
    CFArrayRemoveAllValues(Mutable);
    appendRelabeledProperty(Mutable, CFSTR("X.501 Name"), 0, (uint64_t)a2, CFSTR("Invalid %@"), a3);
  }
  return Mutable;
}

void appendIntegerProperty(void *a1, const __CFString *a2, uint64_t a3, char a4)
{
  const __CFAllocator *v8;
  __CFString *v9;

  v8 = CFGetAllocator(a1);
  v9 = copyIntegerContentDescription(v8, a3);
  appendProperty(a1, CFSTR("string"), a2, 0, v9, a4);
  CFRelease(v9);
}

void appendAlgorithmProperty(void *a1, const __CFString *a2, uint64_t a3, int a4)
{
  const __CFAllocator *v8;
  __CFString *Mutable;
  uint64_t v10;
  uint64_t v11;
  const __CFString *v12;

  v8 = CFGetAllocator(a1);
  Mutable = (__CFString *)CFArrayCreateMutable(v8, 0, MEMORY[0x1E0C9B378]);
  appendOIDProperty(Mutable, CFSTR("Algorithm"), 0, a3, a4);
  v10 = *(_QWORD *)(a3 + 24);
  if (v10)
  {
    v11 = a3 + 16;
    if (v10 == 2 && **(_BYTE **)v11 == 5 && !*(_BYTE *)(*(_QWORD *)v11 + 1))
    {
      v12 = SecFrameworkCopyLocalizedString(CFSTR("none"), CFSTR("Certificate"));
      appendProperty(Mutable, CFSTR("string"), CFSTR("Parameters"), 0, v12, a4);
      CFRelease(v12);
    }
    else
    {
      appendRelabeledProperty(Mutable, CFSTR("Parameters"), 0, v11, CFSTR("Unparsed %@"), a4);
    }
  }
  appendProperty(a1, CFSTR("section"), a2, 0, Mutable, a4);
  CFRelease(Mutable);
}

void appendDataProperty(void *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, char a5)
{
  const __CFAllocator *v10;
  const __CFString *v11;

  if ((*(_QWORD *)(a4 + 8) & 0x8000000000000000) == 0)
  {
    v10 = CFGetAllocator(a1);
    v11 = (const __CFString *)CFDataCreate(v10, *(const UInt8 **)a4, *(_QWORD *)(a4 + 8));
    appendProperty(a1, CFSTR("data"), a2, a3, v11, a5);
    CFRelease(v11);
  }
}

void appendExtension(void *a1, uint64_t a2, uint64_t a3)
{
  const __CFAllocator *v6;
  __CFString *Mutable;
  uint64_t v8;
  _BYTE *v9;
  unsigned __int8 *v10;
  __CFString **v11;
  __CFString *v12;
  uint64_t v13;
  unsigned __int16 v14;
  int v15;
  char v16;
  int v17;
  const __CFAllocator *v19;
  const __CFString *v20;
  const __CFString *v21;
  const __CFString *v22;
  const __CFString *v23;
  int v24[6];
  unint64_t v25[3];

  v6 = CFGetAllocator(a1);
  Mutable = (__CFString *)CFArrayCreateMutable(v6, 0, MEMORY[0x1E0C9B378]);
  appendBoolProperty(Mutable, CFSTR("Critical"), *(unsigned __int8 *)(a2 + 16), a3);
  v8 = *(_QWORD *)(a2 + 8);
  if (v8 == 3 && (v9 = *(_BYTE **)a2, !memcmp(*(const void **)a2, &_oidSubjectKeyIdentifier, 2uLL)))
  {
    switch(v9[2])
    {
      case 0xE:
        appendSubjectKeyIdentifier(Mutable, a2 + 24, a3);
        break;
      case 0xF:
        v11 = appendKeyUsage_usageNames;
        v12 = Mutable;
        v13 = a2 + 24;
        v14 = 9;
        goto LABEL_7;
      case 0x10:
        appendPrivateKeyUsagePeriod(Mutable, a2 + 24, a3);
        break;
      case 0x11:
      case 0x12:
        appendGeneralNames(Mutable, a2 + 24, a3);
        break;
      case 0x13:
        appendBasicConstraints(Mutable, a2 + 24, a3);
        break;
      case 0x1E:
        appendNameConstraints(Mutable, a2 + 24, a3);
        break;
      case 0x1F:
        appendCrlDistributionPoints(Mutable, a2 + 24, a3);
        break;
      case 0x20:
        appendCertificatePolicies(Mutable, a2 + 24, a3);
        break;
      case 0x23:
        appendAuthorityKeyIdentifier(Mutable, a2 + 24, a3);
        break;
      case 0x24:
        appendPolicyConstraints(Mutable, a2 + 24, a3);
        break;
      case 0x25:
        appendExtendedKeyUsage(Mutable, a2 + 24, a3);
        break;
      default:
        goto LABEL_13;
    }
  }
  else
  {
    if (v8 == 8 && (v10 = *(unsigned __int8 **)a2, !memcmp(*(const void **)a2, &_oidAuthorityInfoAccess, 7uLL)))
    {
      v15 = v10[7];
      if (v15 == 11 || v15 == 1)
      {
        appendInfoAccess(Mutable, a2 + 24, a3);
        goto LABEL_26;
      }
    }
    else if (DEROidCompare(a2, (uint64_t)&oidNetscapeCertType))
    {
      v11 = appendNetscapeCertType_certTypes;
      v12 = Mutable;
      v13 = a2 + 24;
      v14 = 8;
LABEL_7:
      appendBitStringNames(v12, v13, (const __CFString **)v11, v14, a3);
      goto LABEL_26;
    }
LABEL_13:
    memset(v25, 170, sizeof(v25));
    if (DERDecodeSeqInit(a2 + 24, &v25[2], v25) || v25[2] != 0x2000000000000010)
      goto LABEL_25;
    v16 = 0;
    memset(v24, 170, sizeof(v24));
    while (1)
    {
      v17 = DERDecodeSeqNext(v25, (unint64_t *)v24);
      if (v17)
        break;
      if (*(_QWORD *)v24 <= 0x1CuLL && ((1 << SLOBYTE(v24[0])) & 0x1E7C1000) != 0)
      {
        v19 = CFGetAllocator(Mutable);
        v20 = copyDERThingContentDescription(v19, *(uint64_t *)v24, (uint64_t)&v24[2], a3);
        if (!v20)
          goto LABEL_25;
        v21 = v20;
        appendProperty(Mutable, CFSTR("string"), CFSTR("Data"), 0, v20, a3);
        CFRelease(v21);
        v16 = 1;
      }
    }
    if (v17 != 1 || (v16 & 1) == 0)
LABEL_25:
      appendRelabeledProperty(Mutable, CFSTR("Data"), 0, a2 + 24, CFSTR("Unparsed %@"), a3);
  }
LABEL_26:
  v22 = SecDERItemCopyOIDDecimalRepresentation(v6, (unsigned __int8 **)a2);
  v23 = copyOidDescription(v6, a2, a3);
  appendProperty(a1, CFSTR("section"), v22, v23, Mutable, a3);
  if (v23)
    CFRelease(v23);
  if (v22)
    CFRelease(v22);
  if (Mutable)
    CFRelease(Mutable);
}

void appendFingerprintsProperty(void *a1, __CFData *a2, char a3)
{
  const __CFAllocator *v6;
  __CFString *Mutable;
  __CFData *v8;
  __CFData *v9;
  __CFData *SHA1Digest;

  v6 = CFGetAllocator(a1);
  Mutable = (__CFString *)CFArrayCreateMutable(v6, 0, MEMORY[0x1E0C9B378]);
  v8 = SecCertificateCopySHA256Digest(a2);
  if (v8)
  {
    v9 = v8;
    appendProperty(Mutable, CFSTR("data"), CFSTR("SHA-256"), 0, (const __CFString *)v8, a3);
    CFRelease(v9);
  }
  SHA1Digest = SecCertificateGetSHA1Digest(a2);
  appendProperty(Mutable, CFSTR("data"), CFSTR("SHA-1"), 0, (const __CFString *)SHA1Digest, a3);
  appendProperty(a1, CFSTR("section"), CFSTR("Fingerprints"), 0, Mutable, a3);
  if (Mutable)
    CFRelease(Mutable);
}

void appendBoolProperty(void *cf, const __CFString *a2, int a3, int a4)
{
  char v4;
  const __CFString *v7;

  v4 = a4;
  if (a3)
    v7 = CFSTR("Yes");
  else
    v7 = CFSTR("No");
  if (a4)
    v7 = SecFrameworkCopyLocalizedString(v7, CFSTR("Certificate"));
  appendProperty(cf, CFSTR("string"), a2, 0, v7, v4);
  CFRelease(v7);
}

void appendSubjectKeyIdentifier(void *a1, uint64_t a2, char a3)
{
  unint64_t v6[3];

  memset(v6, 170, sizeof(v6));
  if (DERDecodeItem(a2, v6) || v6[0] != 4)
    appendRelabeledProperty(a1, CFSTR("Subject Key Identifier"), 0, a2, CFSTR("Invalid %@"), a3);
  else
    appendDataProperty(a1, CFSTR("Key Identifier"), 0, (uint64_t)&v6[1], a3);
}

void appendBitStringNames(void *a1, uint64_t a2, const __CFString **a3, unsigned __int16 a4, int a5)
{
  unint64_t v10[3];

  memset(v10, 170, sizeof(v10));
  if (DERDecodeItem(a2, v10) || v10[0] != 3)
    appendRelabeledProperty(a1, CFSTR("Usage"), 0, a2, CFSTR("Invalid %@"), a5);
  else
    appendBitStringContentNames(a1, CFSTR("Usage"), (unsigned __int8 **)&v10[1], a3, a4, a5);
}

void appendPrivateKeyUsagePeriod(void *a1, uint64_t a2, char a3)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;

  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7 = v6;
  v8 = v6;
  if (DERParseSequence(a2, (unsigned __int16)DERNumPrivateKeyUsagePeriodItemSpecs, (uint64_t)&DERPrivateKeyUsagePeriodItemSpecs, (unint64_t)&v7, 0x20uLL))
  {
    appendRelabeledProperty(a1, CFSTR("Private Key Usage Period"), 0, a2, CFSTR("Invalid %@"), a3);
  }
  else
  {
    if (*((_QWORD *)&v7 + 1))
      appendDateContentProperty(a1, CFSTR("Not Valid Before"), (uint64_t)&v7, a3);
    if (*((_QWORD *)&v8 + 1))
      appendDateContentProperty(a1, CFSTR("Not Valid After"), (uint64_t)&v8, a3);
  }
}

void appendGeneralNames(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6[3];

  memset(v6, 170, sizeof(v6));
  if (DERDecodeItem(a2, v6) || v6[0] != 0x2000000000000010)
    appendRelabeledProperty(a1, CFSTR("General Names"), 0, a2, CFSTR("Invalid %@"), a3);
  else
    appendGeneralNamesContent(a1, &v6[1], a3);
}

void appendBasicConstraints(void *a1, uint64_t a2, int a3)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  char v9;

  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7 = v6;
  v8 = v6;
  if (DERParseSequence(a2, (unsigned __int16)DERNumBasicConstraintsItemSpecs, (uint64_t)&DERBasicConstraintsItemSpecs, (unint64_t)&v7, 0x20uLL))
  {
    appendRelabeledProperty(a1, CFSTR("Basic Constraints"), 0, a2, CFSTR("Invalid %@"), a3);
  }
  else
  {
    v9 = -86;
    if (DERParseBooleanWithDefault((unsigned __int8 **)&v7, 0, (BOOL *)&v9))
      appendRelabeledProperty(a1, CFSTR("Certificate Authority"), 0, (uint64_t)&v7, CFSTR("Invalid %@"), a3);
    else
      appendBoolProperty(a1, CFSTR("Certificate Authority"), v9, a3);
    if (*((_QWORD *)&v8 + 1))
      appendIntegerProperty(a1, CFSTR("Path Length Constraint"), (uint64_t)&v8, a3);
  }
}

void appendNameConstraints(void *a1, uint64_t a2, uint64_t a3)
{
  __int128 v6;
  int v7;
  __int128 v8;
  __CFString *Mutable;
  __int128 *v10;
  __int128 *v11;
  void *v12;
  const __CFString *v13;
  int v14;
  __int128 v15;
  __int128 *v16;
  __int128 *v17;
  void *v18;
  const __CFString *v19;
  __CFString *v20;
  __CFString *v21;
  uint64_t v22;
  const __CFAllocator *allocator;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  unint64_t v27[3];
  unint64_t v28;
  unint64_t v29;
  __int128 v30;
  unint64_t v31[4];

  allocator = CFGetAllocator(a1);
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v30 = v6;
  *(_OWORD *)v31 = v6;
  v22 = a2;
  if (DERParseSequence(a2, (unsigned __int16)DERNumNameConstraintsItemSpecs, (uint64_t)&DERNameConstraintsItemSpecs, (unint64_t)&v30, 0x20uLL))goto LABEL_29;
  if (*((_QWORD *)&v30 + 1))
  {
    v28 = 0xAAAAAAAAAAAAAAAALL;
    v29 = 0xAAAAAAAAAAAAAAAALL;
    if (DERDecodeSeqContentInit((unint64_t *)&v30, &v28))
      goto LABEL_29;
    memset(v27, 170, sizeof(v27));
    while (1)
    {
      v7 = DERDecodeSeqNext(&v28, v27);
      if (v7)
        break;
      *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v25 = v8;
      v26 = v8;
      v24 = v8;
      if (v27[0] != 0x2000000000000010
        || DERParseSequenceContent(&v27[1], (unsigned __int16)DERNumGeneralSubtreeItemSpecs, (uint64_t)&DERGeneralSubtreeItemSpecs, (unint64_t)&v24, 0x30uLL))
      {
        goto LABEL_29;
      }
      if (*((_QWORD *)&v25 + 1))
        appendIntegerProperty(a1, CFSTR("Permitted Subtree Minimum"), (uint64_t)&v25, a3);
      if (*((_QWORD *)&v26 + 1))
        appendIntegerProperty(a1, CFSTR("Permitted Subtree Maximum"), (uint64_t)&v26, a3);
      if (*((_QWORD *)&v24 + 1))
      {
        Mutable = (__CFString *)CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
        appendProperty(a1, CFSTR("section"), CFSTR("Permitted Subtree General Name"), 0, Mutable, a3);
        appendGeneralNameProperty(Mutable, (uint64_t)&v24, a3);
        CFRelease(Mutable);
      }
    }
    if (v7 != 1)
      goto LABEL_29;
  }
  if (v31[1])
  {
    v28 = 0xAAAAAAAAAAAAAAAALL;
    v29 = 0xAAAAAAAAAAAAAAAALL;
    if (DERDecodeSeqContentInit(v31, &v28))
      goto LABEL_29;
    v10 = &v25;
    v11 = &v26;
    v12 = &DERGeneralSubtreeItemSpecs;
    memset(v27, 170, sizeof(v27));
    v13 = CFSTR("Excluded Subtree Maximum");
    while (1)
    {
      v14 = DERDecodeSeqNext(&v28, v27);
      if (v14)
        break;
      *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v25 = v15;
      v26 = v15;
      v24 = v15;
      if (v27[0] != 0x2000000000000010
        || DERParseSequenceContent(&v27[1], (unsigned __int16)DERNumGeneralSubtreeItemSpecs, (uint64_t)v12, (unint64_t)&v24, 0x30uLL))
      {
        goto LABEL_29;
      }
      if (*((_QWORD *)&v25 + 1))
        appendIntegerProperty(a1, CFSTR("Excluded Subtree Minimum"), (uint64_t)v10, a3);
      if (*((_QWORD *)&v26 + 1))
        appendIntegerProperty(a1, v13, (uint64_t)v11, a3);
      if (*((_QWORD *)&v24 + 1))
      {
        v16 = v11;
        v17 = v10;
        v18 = v12;
        v19 = v13;
        v20 = (__CFString *)CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
        appendProperty(a1, CFSTR("section"), CFSTR("Excluded Subtree General Name"), 0, v20, a3);
        appendGeneralNameProperty(v20, (uint64_t)&v24, a3);
        v21 = v20;
        v13 = v19;
        v12 = v18;
        v10 = v17;
        v11 = v16;
        CFRelease(v21);
      }
    }
    if (v14 != 1)
LABEL_29:
      appendRelabeledProperty(a1, CFSTR("Name Constraints"), 0, v22, CFSTR("Invalid %@"), a3);
  }
}

void appendCrlDistributionPoints(void *a1, uint64_t a2, uint64_t a3)
{
  const __CFAllocator *v6;
  int v7;
  __int128 v8;
  __CFArray *Mutable;
  __CFString *v10;
  unint64_t v11[3];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  unint64_t v15[3];
  unint64_t v16[3];

  v6 = CFGetAllocator(a1);
  memset(v16, 170, sizeof(v16));
  if (DERDecodeSeqInit(a2, &v16[2], v16) || v16[2] != 0x2000000000000010)
    goto LABEL_20;
  memset(v15, 170, sizeof(v15));
  while (1)
  {
    v7 = DERDecodeSeqNext(v16, v15);
    if (v7)
      break;
    if (v15[0] != 0x2000000000000010)
      goto LABEL_20;
    *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v13 = v8;
    v14 = v8;
    v12 = v8;
    if (DERParseSequenceContent(&v15[1], (unsigned __int16)DERNumDistributionPointItemSpecs, (uint64_t)&DERDistributionPointItemSpecs, (unint64_t)&v12, 0x30uLL))goto LABEL_20;
    if (*((_QWORD *)&v12 + 1))
    {
      memset(v11, 170, sizeof(v11));
      if (DERDecodeItem((uint64_t)&v12, v11))
        goto LABEL_20;
      if (v11[0] == 0xA000000000000001)
      {
        Mutable = CFArrayCreateMutable(v6, 0, MEMORY[0x1E0C9B378]);
        if (parseRDNContent((unint64_t *)&v13, (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendRDNProperty, a3))
        {
          CFArrayRemoveAllValues(Mutable);
          appendRelabeledProperty(Mutable, CFSTR("RDN"), 0, (uint64_t)&v13, CFSTR("Invalid %@"), a3);
        }
        appendProperty(a1, CFSTR("section"), CFSTR("Name Relative To CRL Issuer"), 0, (const __CFString *)Mutable, a3);
        CFRelease(Mutable);
      }
      else
      {
        if (v11[0] != 0xA000000000000000)
          goto LABEL_20;
        appendGeneralNamesContent(a1, &v11[1], a3);
      }
    }
    if (*((_QWORD *)&v13 + 1))
      appendBitStringContentNames(a1, CFSTR("Reasons"), (unsigned __int8 **)&v13, (const __CFString **)appendCrlDistributionPoints_reasonNames, 9u, a3);
    if (*((_QWORD *)&v14 + 1))
    {
      v10 = (__CFString *)CFArrayCreateMutable(v6, 0, MEMORY[0x1E0C9B378]);
      appendProperty(a1, CFSTR("section"), CFSTR("CRL Issuer"), 0, v10, a3);
      CFRelease(v10);
      appendGeneralNames(v10, (uint64_t)&v14, a3);
    }
  }
  if (v7 != 1)
LABEL_20:
    appendRelabeledProperty(a1, CFSTR("CRL Distribution Points"), 0, a2, CFSTR("Invalid %@"), a3);
}

void appendCertificatePolicies(void *a1, uint64_t a2, int a3)
{
  const __CFAllocator *v4;
  unint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  __int128 v9;
  CFStringRef v10;
  const __CFString *v11;
  const __CFString *v12;
  uint64_t v13;
  unint64_t *v14;
  const __CFAllocator *v15;
  CFStringRef v16;
  const __CFString *v17;
  uint64_t v18;
  int v19;
  __int128 v20;
  CFStringRef v21;
  CFStringRef v22;
  const __CFString *v23;
  __int128 v24;
  __int128 v25;
  const __CFAllocator *v26;
  CFStringRef v27;
  const __CFString *i;
  int v29;
  __CFString *v30;
  __CFString *v31;
  CFStringRef MutableCopy;
  int v33;
  uint64_t v34;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  unint64_t v41[3];
  __int128 v42;
  __int128 v43;
  unint64_t v44[3];
  unint64_t v45[2];
  __int128 v46;
  __int128 v47;
  unint64_t v48[3];
  unint64_t v49[3];
  unint64_t v50[3];
  unint64_t v51[3];

  v4 = CFGetAllocator(a1);
  memset(v49, 170, sizeof(v49));
  if (DERDecodeSeqInit(a2, &v49[2], v49) || v49[2] != 0x2000000000000010)
  {
LABEL_63:
    appendRelabeledProperty(a1, CFSTR("Certificate Policies"), 0, a2, CFSTR("Invalid %@"), a3);
    return;
  }
  v5 = &v48[1];
  memset(v48, 170, sizeof(v48));
  v6 = 1;
  v7 = (unsigned __int16)DERNumPolicyInformationItemSpecs;
LABEL_4:
  v8 = DERDecodeSeqNext(v49, v48);
  if (!v8)
  {
    if (v48[0] != 0x2000000000000010)
      goto LABEL_63;
    *(_QWORD *)&v9 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v46 = v9;
    v47 = v9;
    if (DERParseSequenceContent(v5, v7, (uint64_t)&DERPolicyInformationItemSpecs, (unint64_t)&v46, 0x20uLL))goto LABEL_63;
    v10 = CFStringCreateWithFormat(v4, 0, CFSTR("Policy Identifier #%d"), v6);
    if (!v10)
      goto LABEL_63;
    v11 = v10;
    v12 = CFSTR("Policy Identifier #%d");
    if (a3)
    {
      v12 = SecFrameworkCopyLocalizedString(CFSTR("Policy Identifier #%d"), CFSTR("Certificate"));
      if (!v12)
        goto LABEL_62;
    }
    v13 = v7;
    v14 = v5;
    v15 = v4;
    v16 = CFStringCreateWithFormat(v4, 0, v12, v6);
    if (!v16)
    {
LABEL_60:
      if (v12)
        CFRelease(v12);
LABEL_62:
      CFRelease(v11);
      goto LABEL_63;
    }
    v17 = v16;
    v6 = (v6 + 1);
    CFRelease(v12);
    appendOIDProperty(a1, v11, v17, (uint64_t)&v46, a3);
    CFRelease(v11);
    CFRelease(v17);
    if (!*((_QWORD *)&v47 + 1))
    {
      v4 = v15;
      goto LABEL_57;
    }
    v45[0] = 0xAAAAAAAAAAAAAAAALL;
    v45[1] = 0xAAAAAAAAAAAAAAAALL;
    if (DERDecodeSeqContentInit((unint64_t *)&v47, v45))
      goto LABEL_63;
    v4 = v15;
    v18 = 1;
    memset(v44, 170, sizeof(v44));
    v12 = CFSTR("Policy Qualifier #%d");
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            v19 = DERDecodeSeqNext(v45, v44);
            if (v19)
            {
              if (v19 != 1)
                goto LABEL_63;
LABEL_57:
              v5 = v14;
              v7 = v13;
              goto LABEL_4;
            }
            *(_QWORD *)&v20 = 0xAAAAAAAAAAAAAAAALL;
            *((_QWORD *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
            v42 = v20;
            v43 = v20;
            if (DERParseSequenceContent(&v44[1], (unsigned __int16)DERNumPolicyQualifierInfoItemSpecs, (uint64_t)&DERPolicyQualifierInfoItemSpecs, (unint64_t)&v42, 0x20uLL))goto LABEL_63;
            memset(v41, 170, sizeof(v41));
            if (DERDecodeItem((uint64_t)&v43, v41))
              goto LABEL_63;
            v21 = CFStringCreateWithFormat(v4, 0, CFSTR("Policy Qualifier #%d"), v18);
            if (!v21)
              goto LABEL_63;
            v11 = v21;
            if (a3)
            {
              v12 = SecFrameworkCopyLocalizedString(CFSTR("Policy Qualifier #%d"), CFSTR("Certificate"));
              if (!v12)
                goto LABEL_62;
            }
            v22 = CFStringCreateWithFormat(v4, 0, v12, v18);
            if (!v22)
              goto LABEL_60;
            v23 = v22;
            v18 = (v18 + 1);
            CFRelease(v12);
            appendOIDProperty(a1, v11, v23, (uint64_t)&v42, a3);
            CFRelease(v11);
            CFRelease(v23);
            if (!DEROidCompare((uint64_t)&oidQtCps, (uint64_t)&v42))
              break;
            v12 = CFSTR("Policy Qualifier #%d");
            if (v41[0] != 22)
              goto LABEL_63;
            v4 = v15;
            appendURLContentProperty(a1, CFSTR("CPS URI"), (uint64_t)&v41[1], a3);
          }
          v4 = v15;
          v12 = CFSTR("Policy Qualifier #%d");
          if (DEROidCompare((uint64_t)&oidQtUNotice, (uint64_t)&v42))
            break;
          appendRelabeledProperty(a1, CFSTR("Qualifier"), 0, (uint64_t)&v43, CFSTR("Unparsed %@"), a3);
        }
        if (v41[0] != 0x2000000000000010)
          goto LABEL_63;
        *(_QWORD *)&v24 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v39 = v24;
        v40 = v24;
        if (DERParseSequenceContent(&v41[1], (unsigned __int16)DERNumUserNoticeItemSpecs, (uint64_t)&DERUserNoticeItemSpecs, (unint64_t)&v39, 0x20uLL))goto LABEL_63;
        if (*((_QWORD *)&v39 + 1))
          break;
        if (*((_QWORD *)&v40 + 1))
          goto LABEL_52;
      }
      v34 = a2;
      *(_QWORD *)&v25 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v37 = v25;
      v38 = v25;
      if (DERParseSequenceContent((unint64_t *)&v39, (unsigned __int16)DERNumNoticeReferenceItemSpecs, (uint64_t)&DERNoticeReferenceItemSpecs, (unint64_t)&v37, 0x20uLL))goto LABEL_63;
      appendDERThingProperty(a1, CFSTR("Organization"), 0, (unsigned __int8 **)&v37, a3);
      v26 = CFGetAllocator(a1);
      v51[0] = 0xAAAAAAAAAAAAAAAALL;
      v51[1] = 0xAAAAAAAAAAAAAAAALL;
      if (!DERDecodeSeqContentInit((unint64_t *)&v38, v51))
      {
        v27 = CFSTR("%@, %@");
        memset(v50, 170, sizeof(v50));
        if (!a3 || (v27 = SecFrameworkCopyLocalizedString(CFSTR("%@, %@"), CFSTR("Certificate"))) != 0)
        {
          for (i = 0; ; i = MutableCopy)
          {
            v29 = DERDecodeSeqNext(v51, v50);
            if (v29)
              break;
            if (v50[0] != 2 || (v30 = copyIntegerContentDescription(v26, (uint64_t)&v50[1])) == 0)
            {
              CFRelease(v27);
              goto LABEL_48;
            }
            v31 = v30;
            if (i)
            {
              MutableCopy = CFStringCreateWithFormat(v26, 0, v27, i, v30);
              CFRelease(i);
              if (!MutableCopy)
                goto LABEL_53;
            }
            else
            {
              MutableCopy = CFStringCreateMutableCopy(v26, 0, v30);
              if (!MutableCopy)
              {
LABEL_53:
                CFRelease(v27);
                i = v31;
                v12 = CFSTR("Policy Qualifier #%d");
                goto LABEL_49;
              }
            }
            CFRelease(v31);
          }
          v33 = v29;
          CFRelease(v27);
          if (v33 == 1 && i)
          {
            appendProperty(a1, CFSTR("string"), CFSTR("Notice Numbers"), 0, i, a3);
            CFRelease(i);
            v4 = v15;
            v12 = CFSTR("Policy Qualifier #%d");
            goto LABEL_51;
          }
LABEL_48:
          v12 = CFSTR("Policy Qualifier #%d");
          if (!i)
            goto LABEL_50;
LABEL_49:
          CFRelease(i);
        }
      }
LABEL_50:
      appendRelabeledProperty(a1, CFSTR("Notice Numbers"), 0, (uint64_t)&v38, CFSTR("Invalid %@"), a3);
      v4 = v15;
LABEL_51:
      a2 = v34;
      if (*((_QWORD *)&v40 + 1))
LABEL_52:
        appendDERThingProperty(a1, CFSTR("Explicit Text"), 0, (unsigned __int8 **)&v40, a3);
    }
  }
  if (v8 != 1)
    goto LABEL_63;
}

void appendAuthorityKeyIdentifier(void *a1, uint64_t a2, uint64_t a3)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8 = v6;
  v9 = v6;
  v7 = v6;
  if (DERParseSequence(a2, (unsigned __int16)DERNumAuthorityKeyIdentifierItemSpecs, (uint64_t)&DERAuthorityKeyIdentifierItemSpecs, (unint64_t)&v7, 0x30uLL))goto LABEL_9;
  if (*((_QWORD *)&v7 + 1))
    appendDataProperty(a1, CFSTR("Key Identifier"), 0, (uint64_t)&v7, a3);
  if (*((_QWORD *)&v8 + 1) | *((_QWORD *)&v9 + 1))
  {
    if (*((_QWORD *)&v8 + 1) && *((_QWORD *)&v9 + 1))
    {
      appendGeneralNamesContent(a1, (unint64_t *)&v8, a3);
      appendIntegerProperty(a1, CFSTR("Authority Certificate Serial Number"), (uint64_t)&v9, a3);
      return;
    }
LABEL_9:
    appendRelabeledProperty(a1, CFSTR("Authority Key Identifier"), 0, a2, CFSTR("Invalid %@"), a3);
  }
}

void appendPolicyConstraints(void *a1, uint64_t a2, char a3)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;

  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7 = v6;
  v8 = v6;
  if (DERParseSequence(a2, (unsigned __int16)DERNumPolicyConstraintsItemSpecs, (uint64_t)&DERPolicyConstraintsItemSpecs, (unint64_t)&v7, 0x20uLL))
  {
    appendRelabeledProperty(a1, CFSTR("Policy Constraints"), 0, a2, CFSTR("Invalid %@"), a3);
  }
  else
  {
    if (*((_QWORD *)&v7 + 1))
      appendIntegerProperty(a1, CFSTR("Require Explicit Policy"), (uint64_t)&v7, a3);
    if (*((_QWORD *)&v8 + 1))
      appendIntegerProperty(a1, CFSTR("Inhibit Policy Mapping"), (uint64_t)&v8, a3);
  }
}

void appendExtendedKeyUsage(void *a1, uint64_t a2, int a3)
{
  int v6;
  unint64_t v7[3];
  unint64_t v8[3];

  memset(v8, 170, sizeof(v8));
  if (DERDecodeSeqInit(a2, &v8[2], v8) || v8[2] != 0x2000000000000010)
    goto LABEL_8;
  memset(v7, 170, sizeof(v7));
  while (1)
  {
    v6 = DERDecodeSeqNext(v8, v7);
    if (v6)
      break;
    if (v7[0] != 6)
      goto LABEL_8;
    appendOIDProperty(a1, CFSTR("Purpose"), 0, (uint64_t)&v7[1], a3);
  }
  if (v6 != 1)
LABEL_8:
    appendRelabeledProperty(a1, CFSTR("Extended Key Usage"), 0, a2, CFSTR("Invalid %@"), a3);
}

void appendInfoAccess(void *a1, uint64_t a2, uint64_t a3)
{
  int v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  unint64_t v10[3];
  unint64_t v11[3];

  memset(v11, 170, sizeof(v11));
  if (DERDecodeSeqInit(a2, &v11[2], v11) || v11[2] != 0x2000000000000010)
    goto LABEL_9;
  memset(v10, 170, sizeof(v10));
  while (1)
  {
    v6 = DERDecodeSeqNext(v11, v10);
    if (v6)
      break;
    if (v10[0] != 0x2000000000000010)
      goto LABEL_9;
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v8 = v7;
    v9 = v7;
    if (DERParseSequenceContent(&v10[1], (unsigned __int16)DERNumAccessDescriptionItemSpecs, (uint64_t)&DERAccessDescriptionItemSpecs, (unint64_t)&v8, 0x20uLL))goto LABEL_9;
    appendOIDProperty(a1, CFSTR("Access Method"), 0, (uint64_t)&v8, a3);
    appendGeneralNameProperty(a1, (uint64_t)&v9, a3);
  }
  if (v6 != 1)
LABEL_9:
    appendRelabeledProperty(a1, CFSTR("Authority Information Access"), 0, a2, CFSTR("Invalid %@"), a3);
}

void appendRelabeledProperty(void *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, const __CFString *a5, char a6)
{
  const __CFAllocator *v12;
  const __CFString *v13;
  const __CFAllocator *v14;
  const __CFString *v15;

  v12 = CFGetAllocator(a1);
  v13 = CFStringCreateWithFormat(v12, 0, a5, a2);
  if ((a6 & 1) != 0)
  {
    if (a3)
    {
      a2 = 0;
    }
    else
    {
      a2 = SecFrameworkCopyLocalizedString(a2, CFSTR("Certificate"));
      a3 = a2;
    }
    a5 = SecFrameworkCopyLocalizedString(a5, CFSTR("Certificate"));
  }
  else
  {
    if (a2)
      CFRetain(a2);
    if (a5)
      CFRetain(a5);
    a3 = a2;
  }
  v14 = CFGetAllocator(a1);
  v15 = CFStringCreateWithFormat(v14, 0, a5, a3);
  if (a2)
    CFRelease(a2);
  if (a5)
    CFRelease(a5);
  appendDataProperty(a1, v13, v15, a4, a6);
  if (v13)
    CFRelease(v13);
  if (v15)
    CFRelease(v15);
}

void appendOIDProperty(void *a1, const __CFString *a2, const __CFString *a3, uint64_t a4, int a5)
{
  const __CFAllocator *v10;
  const __CFString *v11;

  v10 = CFGetAllocator(a1);
  v11 = copyOidDescription(v10, a4, a5);
  appendProperty(a1, CFSTR("string"), a2, a3, v11, a5);
  CFRelease(v11);
}

void appendGeneralNameProperty(void *a1, uint64_t a2, uint64_t a3)
{
  int v6[6];

  memset(v6, 170, sizeof(v6));
  if (DERDecodeItem(a2, (unint64_t *)v6)
    || (appendGeneralNameContentProperty(a1, *(uint64_t *)v6, (unint64_t *)&v6[2], a3) & 1) == 0)
  {
    appendRelabeledProperty(a1, CFSTR("General Name"), 0, a2, CFSTR("Invalid %@"), a3);
  }
}

uint64_t appendGeneralNameContentProperty(void *cf, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  unsigned __int8 **v5;
  uint64_t result;
  __int128 v8;
  const __CFAllocator *v9;
  const __CFString *v10;
  __CFString *Mutable;
  __CFString *v12;
  __CFString *v13;
  const __CFString *v14;
  void *v15;
  const __CFAllocator *v16;
  CFStringRef v17;
  __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  const __CFAllocator *v21;
  const __CFString *v22;
  _BYTE v23[32];

  v5 = (unsigned __int8 **)a3;
  result = 0;
  switch(a2)
  {
    case 0x8000000000000001:
      v14 = CFSTR("Email Address");
      goto LABEL_12;
    case 0x8000000000000002:
      v14 = CFSTR("DNS Name");
LABEL_12:
      appendStringContentProperty(cf, v14, (uint64_t)a3, a4);
      return 1;
    case 0x8000000000000003:
    case 0x8000000000000004:
    case 0x8000000000000005:
      return result;
    case 0x8000000000000006:
      v15 = cf;
LABEL_29:
      appendURLContentProperty(v15, CFSTR("URI"), (uint64_t)a3, a4);
      return 1;
    case 0x8000000000000007:
      v16 = CFGetAllocator(cf);
      v17 = copyIPAddressContentDescription(v16, v5);
      if (v17)
      {
        Mutable = (__CFString *)v17;
        v18 = CFSTR("string");
        v19 = CFSTR("IP Address");
LABEL_23:
        appendProperty(cf, v18, v19, 0, Mutable, a4);
LABEL_24:
        CFRelease(Mutable);
      }
      else
      {
        v20 = CFSTR("IP Address");
LABEL_33:
        v22 = CFSTR("Unparsed %@");
LABEL_34:
        appendRelabeledProperty(cf, v20, 0, (uint64_t)v5, v22, a4);
      }
      return 1;
    case 0x8000000000000008:
      appendOIDProperty(cf, CFSTR("Registered ID"), 0, (uint64_t)a3, a4);
      return 1;
    default:
      switch(a2)
      {
        case 0xA000000000000000:
          *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)v23 = v8;
          *(_OWORD *)&v23[16] = v8;
          if (DERParseSequenceContent(a3, (unsigned __int16)DERNumOtherNameItemSpecs, (uint64_t)&DEROtherNameItemSpecs, (unint64_t)v23, 0x20uLL))
          {
            v20 = CFSTR("Other Name");
            goto LABEL_31;
          }
          v9 = CFGetAllocator(cf);
          v10 = SecDERItemCopyOIDDecimalRepresentation(v9, (unsigned __int8 **)v23);
          Mutable = (__CFString *)copyOidDescription(v9, (uint64_t)v23, a4);
          v12 = copyDERThingDescription(v9, (unsigned __int8 **)&v23[16], 0, a4);
          if (v12)
          {
            v13 = v12;
            appendProperty(cf, CFSTR("string"), v10, Mutable, v12, a4);
            CFRelease(v13);
            if (!v10)
              goto LABEL_7;
            goto LABEL_6;
          }
          appendRelabeledProperty(cf, v10, Mutable, (uint64_t)&v23[16], CFSTR("Unparsed %@"), a4);
          if (v10)
LABEL_6:
            CFRelease(v10);
LABEL_7:
          if (Mutable)
            goto LABEL_24;
          return 1;
        case 0xA000000000000003:
          v20 = CFSTR("X.400 Address");
          goto LABEL_33;
        case 0xA000000000000004:
          v21 = CFGetAllocator(cf);
          Mutable = (__CFString *)CFArrayCreateMutable(v21, 0, MEMORY[0x1E0C9B378]);
          memset(v23, 170, 24);
          if (DERDecodeItem((uint64_t)v5, (unint64_t *)v23)
            || *(_QWORD *)v23 != 0x2000000000000010
            || parseX501NameContent((unint64_t *)&v23[8], (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendRDNProperty, a4))
          {
            CFArrayRemoveAllValues((CFMutableArrayRef)Mutable);
            appendRelabeledProperty(Mutable, CFSTR("X.501 Name"), 0, (uint64_t)v5, CFSTR("Invalid %@"), a4);
          }
          v18 = CFSTR("section");
          v19 = CFSTR("Directory Name");
          goto LABEL_23;
        case 0xA000000000000005:
          v20 = CFSTR("EDI Party Name");
          goto LABEL_33;
        case 0xA000000000000006:
          memset(v23, 170, 24);
          if (!DERDecodeItem((uint64_t)a3, (unint64_t *)v23) && *(_QWORD *)v23 == 22)
          {
            a3 = (unint64_t *)&v23[8];
            v15 = cf;
            goto LABEL_29;
          }
          v20 = CFSTR("URI");
LABEL_31:
          v22 = CFSTR("Invalid %@");
          goto LABEL_34;
        default:
          return result;
      }
  }
}

void appendStringContentProperty(void *cf, const __CFString *a2, uint64_t a3, char a4)
{
  const __CFAllocator *v8;
  const __CFString *v9;
  const __CFString *v10;

  if ((*(_QWORD *)(a3 + 8) & 0x8000000000000000) != 0
    || (v8 = CFGetAllocator(cf),
        (v9 = CFStringCreateWithBytes(v8, *(const UInt8 **)a3, *(_QWORD *)(a3 + 8), 0x600u, 0)) == 0))
  {
    appendRelabeledProperty(cf, a2, 0, a3, CFSTR("Invalid %@"), a4);
  }
  else
  {
    v10 = v9;
    appendProperty(cf, CFSTR("string"), a2, 0, v9, a4);
    CFRelease(v10);
  }
}

uint64_t appendRDNProperty(const __CFArray *cf, unsigned __int8 **a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  const __CFArray *Value;
  CFIndex v10;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v12;
  const __CFAllocator *v13;
  __CFArray *Mutable;
  const __CFAllocator *v15;
  const __CFString *v16;
  const __CFAllocator *v17;
  const __CFString *v18;

  Value = cf;
  if (a4 >= 1)
  {
    v10 = CFArrayGetCount(cf) - 1;
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(Value, v10);
    v12 = ValueAtIndex;
    if (a4 == 1)
    {
      v13 = CFGetAllocator(Value);
      Mutable = CFArrayCreateMutable(v13, 0, MEMORY[0x1E0C9B378]);
      CFArrayAppendValue(Mutable, v12);
      CFArrayRemoveValueAtIndex(Value, v10);
      appendProperty(Value, CFSTR("section"), 0, 0, (const __CFString *)Mutable, a5);
      if (Mutable)
      {
        CFRelease(Mutable);
        Value = Mutable;
      }
      else
      {
        Value = 0;
      }
    }
    else
    {
      Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex, CFSTR("value"));
    }
  }
  v15 = CFGetAllocator(Value);
  v16 = SecDERItemCopyOIDDecimalRepresentation(v15, a2);
  v17 = CFGetAllocator(Value);
  v18 = copyOidDescription(v17, (uint64_t)a2, a5);
  appendDERThingProperty(Value, v16, v18, a3, a5);
  if (v16)
    CFRelease(v16);
  if (v18)
    CFRelease(v18);
  return 0;
}

void appendURLContentProperty(void *cf, const __CFString *a2, uint64_t a3, char a4)
{
  const __CFAllocator *v8;
  const __CFString *v9;
  const __CFString *v10;

  if ((*(_QWORD *)(a3 + 8) & 0x8000000000000000) != 0
    || (v8 = CFGetAllocator(cf),
        (v9 = (const __CFString *)CFURLCreateWithBytes(v8, *(const UInt8 **)a3, *(_QWORD *)(a3 + 8), 0x600u, 0)) == 0))
  {
    appendRelabeledProperty(cf, a2, 0, a3, CFSTR("Invalid %@"), a4);
  }
  else
  {
    v10 = v9;
    appendProperty(cf, CFSTR("url"), a2, 0, v9, a4);
    CFRelease(v10);
  }
}

CFStringRef copyIPAddressContentDescription(const __CFAllocator *a1, unsigned __int8 **a2)
{
  unsigned __int8 *v2;

  v2 = a2[1];
  if (v2 == (unsigned __int8 *)16)
    return CFStringCreateWithFormat(a1, 0, CFSTR("%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X:%02X%02X"), **a2, (*a2)[1], (*a2)[2], (*a2)[3], (*a2)[4], (*a2)[5], (*a2)[6], (*a2)[7], (*a2)[8], (*a2)[9], (*a2)[10], (*a2)[11], (*a2)[12], (*a2)[13], (*a2)[14], (*a2)[15]);
  if (v2 == (unsigned __int8 *)4)
    return CFStringCreateWithFormat(a1, 0, CFSTR("%u.%u.%u.%u"), **a2, (*a2)[1], (*a2)[2], (*a2)[3]);
  return 0;
}

void appendDERThingProperty(void *a1, const __CFString *a2, const __CFString *a3, unsigned __int8 **a4, int a5)
{
  const __CFAllocator *v10;
  __CFString *v11;
  __CFString *v12;

  v10 = CFGetAllocator(a1);
  v11 = copyDERThingDescription(v10, a4, 0, a5);
  if (v11)
  {
    v12 = v11;
    appendProperty(a1, CFSTR("string"), a2, a3, v11, a5);
    CFRelease(v12);
  }
}

void appendGeneralNamesContent(void *a1, unint64_t *a2, uint64_t a3)
{
  int v6;
  int v7[6];
  unint64_t v8[2];

  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  if (DERDecodeSeqContentInit(a2, v8))
    goto LABEL_5;
  memset(v7, 170, sizeof(v7));
  while (1)
  {
    v6 = DERDecodeSeqNext(v8, (unint64_t *)v7);
    if (v6)
      break;
    if ((appendGeneralNameContentProperty(a1, *(uint64_t *)v7, (unint64_t *)&v7[2], a3) & 1) == 0)
      goto LABEL_5;
  }
  if (v6 != 1)
LABEL_5:
    appendRelabeledProperty(a1, CFSTR("General Names"), 0, (uint64_t)a2, CFSTR("Invalid %@"), a3);
}

void appendBitStringContentNames(void *a1, const __CFString *a2, unsigned __int8 **a3, const __CFString **a4, unsigned __int16 a5, int a6)
{
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  const __CFString *v16;
  CFStringRef v17;
  CFStringRef v18;
  const __CFAllocator *v19;
  CFStringRef v20;
  const __CFString *v21;

  v9 = (unint64_t)a3[1];
  if ((v9 & 0xFFFFFFFFFFFFFFFELL) == 2
    && (v10 = (uint64_t)*a3, v11 = **a3, v11 <= 7)
    && (v12 = v9 - 1, LOWORD(v13) = 8 * v12 - v11, (unsigned __int16)v13 <= a5))
  {
    v14 = *(unsigned __int8 *)(v10 + 1);
    if (v12 < 2)
    {
      v15 = 128;
    }
    else
    {
      v14 = *(unsigned __int8 *)(v10 + 2) | (v14 << 8);
      v15 = 0x8000;
    }
    if (a6)
    {
      v16 = SecFrameworkCopyLocalizedString(CFSTR("%@, %@"), CFSTR("Certificate"));
      if ((_WORD)v13)
      {
LABEL_9:
        v17 = 0;
        v13 = (unsigned __int16)v13;
        while (1)
        {
          v18 = *a4;
          if (a6)
          {
            v18 = SecFrameworkCopyLocalizedString(*a4, CFSTR("Certificate"));
          }
          else if (v18)
          {
            CFRetain(*a4);
          }
          if ((v14 & v15) == 0)
            goto LABEL_17;
          if (v17)
            break;
          v15 = (unsigned __int16)v15 >> 1;
          if (!v18)
          {
            v17 = 0;
            goto LABEL_22;
          }
          CFRetain(v18);
          v17 = v18;
LABEL_21:
          CFRelease(v18);
LABEL_22:
          ++a4;
          if (!--v13)
            goto LABEL_27;
        }
        v19 = CFGetAllocator(a1);
        v20 = CFStringCreateWithFormat(v19, 0, v16, v17, v18);
        CFRelease(v17);
        v17 = v20;
LABEL_17:
        v15 = (unsigned __int16)v15 >> 1;
        if (!v18)
          goto LABEL_22;
        goto LABEL_21;
      }
    }
    else
    {
      v16 = CFSTR("%@, %@");
      if (8 * (_WORD)v12 != (_WORD)v11)
        goto LABEL_9;
    }
    v17 = 0;
LABEL_27:
    CFRelease(v16);
    if (v17)
      v21 = v17;
    else
      v21 = &stru_1E1FDD448;
    appendProperty(a1, CFSTR("string"), a2, 0, v21, a6);
    if (v17)
      CFRelease(v17);
  }
  else
  {
    appendRelabeledProperty(a1, a2, 0, (uint64_t)a3, CFSTR("Invalid %@"), a6);
  }
}

void appendDateContentProperty(void *a1, const __CFString *a2, uint64_t a3, char a4)
{
  const __CFAllocator *v8;
  const __CFString *v9;
  CFAbsoluteTime at;

  at = NAN;
  if (derDateContentGetAbsoluteTime(24, *(unsigned __int8 **)a3, *(_QWORD *)(a3 + 8), &at))
  {
    v8 = CFGetAllocator(a1);
    v9 = (const __CFString *)CFDateCreate(v8, at);
    appendProperty(a1, CFSTR("date"), a2, 0, v9, a4);
    CFRelease(v9);
  }
  else
  {
    appendRelabeledProperty(a1, a2, 0, a3, CFSTR("Invalid %@"), a4);
  }
}

uint64_t SecCertificateCopyProperties(unsigned __int8 *a1)
{
  return CopyProperties(a1, 1);
}

uint64_t CopyProperties(unsigned __int8 *cf, int a2)
{
  CFMutableArrayRef v3;
  const __CFAllocator *v5;
  CFMutableArrayRef Mutable;
  __CFArray *PropertiesForX501NameContent;
  __CFArray *v8;
  __CFArray *v9;
  __CFArray *v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const __CFAllocator *v14;
  CFMutableArrayRef v15;
  const __CFString *v16;
  const __CFAllocator *v17;
  __CFString *v18;
  const __CFAllocator *v19;
  __CFString *v20;
  __SecKey *v21;
  __SecKey *v22;
  const __CFDictionary *v23;
  const __CFDictionary *v24;
  const __CFNumber *Value;
  uint64_t (*v26)(__SecKey *);
  const __CFString *v27;
  const __CFString *v28;
  uint64_t v29;
  uint64_t v30;
  const __CFAllocator *v31;
  __CFString *v32;
  uint64_t (*valuePtr)(__SecKey *);

  v3 = (CFMutableArrayRef)*((_QWORD *)cf + 70);
  if (!v3)
  {
    v5 = CFGetAllocator(cf);
    Mutable = CFArrayCreateMutable(v5, 0, MEMORY[0x1E0C9B378]);
    if (Mutable)
    {
      v3 = Mutable;
      PropertiesForX501NameContent = createPropertiesForX501NameContent(v5, (unint64_t *)cf + 23, a2 != 0);
      if (PropertiesForX501NameContent)
      {
        v8 = PropertiesForX501NameContent;
        appendProperty(v3, CFSTR("section"), CFSTR("Subject Name"), 0, (const __CFString *)PropertiesForX501NameContent, a2 != 0);
        CFRelease(v8);
      }
      v9 = createPropertiesForX501NameContent(v5, (unint64_t *)cf + 19, a2 != 0);
      if (v9)
      {
        v10 = v9;
        appendProperty(v3, CFSTR("section"), CFSTR("Issuer Name"), 0, (const __CFString *)v9, a2 != 0);
        CFRelease(v10);
      }
      v11 = SecFrameworkCopyLocalizedString(CFSTR("%d"), CFSTR("Certificate"));
      if (v11)
      {
        v12 = v11;
        v13 = CFStringCreateWithFormat(v5, 0, v11, cf[96] + 1);
        CFRelease(v12);
        if (v13)
        {
          appendProperty(v3, CFSTR("string"), CFSTR("Version"), 0, v13, a2 != 0);
          CFRelease(v13);
        }
      }
      v14 = CFGetAllocator(v3);
      v15 = CFArrayCreateMutable(v14, 0, MEMORY[0x1E0C9B378]);
      v16 = (const __CFString *)v15;
      if (*((_QWORD *)cf + 14))
      {
        appendIntegerProperty(v15, CFSTR("Serial Number"), (uint64_t)(cf + 104), a2 != 0);
        appendProperty(v3, CFSTR("section"), CFSTR("Serial Number"), 0, v16, a2 != 0);
      }
      if (v16)
        CFRelease(v16);
      v17 = CFGetAllocator(v3);
      v18 = (__CFString *)CFArrayCreateMutable(v17, 0, MEMORY[0x1E0C9B378]);
      appendDateProperty(v18, CFSTR("Not Valid Before"), a2 != 0, *((CFAbsoluteTime *)cf + 21));
      appendDateProperty(v18, CFSTR("Not Valid After"), a2 != 0, *((CFAbsoluteTime *)cf + 22));
      appendProperty(v3, CFSTR("section"), CFSTR("Validity Period"), 0, v18, a2 != 0);
      if (v18)
        CFRelease(v18);
      if (*((_QWORD *)cf + 36))
        appendDataProperty(v3, CFSTR("Subject Unique ID"), 0, (uint64_t)(cf + 280), a2 != 0);
      if (*((_QWORD *)cf + 34))
        appendDataProperty(v3, CFSTR("Issuer Unique ID"), 0, (uint64_t)(cf + 264), a2 != 0);
      v19 = CFGetAllocator(v3);
      v20 = (__CFString *)CFArrayCreateMutable(v19, 0, MEMORY[0x1E0C9B378]);
      appendAlgorithmProperty(v20, CFSTR("Public Key Algorithm"), (uint64_t)(cf + 216), a2 != 0);
      v21 = SecCertificateCopyKey((SecCertificateRef)cf);
      if (v21)
      {
        v22 = v21;
        valuePtr = 0;
        v23 = SecKeyCopyAttributes(v21);
        if (!v23)
          goto LABEL_25;
        v24 = v23;
        Value = (const __CFNumber *)CFDictionaryGetValue(v23, CFSTR("bsiz"));
        if (Value)
          CFNumberGetValue(Value, kCFNumberLongType, &valuePtr);
        CFRelease(v24);
        v26 = valuePtr;
        if (!valuePtr)
        {
LABEL_25:
          _SecKeyCheck((uint64_t)v22, (uint64_t)"SecKeyGetBlockSize");
          v26 = *(uint64_t (**)(__SecKey *))(*((_QWORD *)v22 + 2) + 80);
          if (v26)
            v26 = (uint64_t (*)(__SecKey *))(8 * v26(v22));
          valuePtr = v26;
        }
        v27 = CFStringCreateWithFormat(v19, 0, CFSTR("%ld"), v26, valuePtr);
        if (v27)
        {
          v28 = v27;
          appendProperty(v20, CFSTR("string"), CFSTR("Public Key Size"), 0, v27, a2 != 0);
          CFRelease(v28);
        }
        CFRelease(v22);
      }
      appendDataProperty(v20, CFSTR("Public Key Data"), 0, (uint64_t)(cf + 248), a2 != 0);
      appendProperty(v3, CFSTR("section"), CFSTR("Public Key Info"), 0, v20, a2 != 0);
      if (v20)
        CFRelease(v20);
      if (*((uint64_t *)cf + 64) >= 1)
      {
        v29 = 0;
        v30 = 0;
        do
        {
          appendExtension(v3, *((_QWORD *)cf + 65) + v29, a2 != 0);
          ++v30;
          v29 += 40;
        }
        while (v30 < *((_QWORD *)cf + 64));
      }
      v31 = CFGetAllocator(v3);
      v32 = (__CFString *)CFArrayCreateMutable(v31, 0, MEMORY[0x1E0C9B378]);
      appendAlgorithmProperty(v32, CFSTR("Signature Algorithm"), (uint64_t)(cf + 120), a2 != 0);
      appendDataProperty(v32, CFSTR("Signature Data"), 0, (uint64_t)(cf + 80), a2 != 0);
      appendProperty(v3, CFSTR("section"), CFSTR("Signature"), 0, v32, a2 != 0);
      if (v32)
        CFRelease(v32);
      appendFingerprintsProperty(v3, (__CFData *)cf, a2 != 0);
      *((_QWORD *)cf + 70) = v3;
    }
    else
    {
      v3 = (CFMutableArrayRef)*((_QWORD *)cf + 70);
      if (!v3)
        return 0;
    }
  }
  CFRetain(v3);
  return *((_QWORD *)cf + 70);
}

CFDataRef SecCertificateCopySerialNumber(CFDataRef certificate)
{
  CFDataRef v1;

  if (certificate)
  {
    v1 = certificate;
    certificate = (CFDataRef)*((_QWORD *)certificate + 71);
    if (certificate)
    {
      CFRetain(certificate);
      return (CFDataRef)*((_QWORD *)v1 + 71);
    }
  }
  return certificate;
}

uint64_t SecCertificateGetSubjectAltName(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 456);
  if (v1)
    return v1 + 24;
  else
    return 0;
}

uint64_t SecFrameworkIsIPAddress(const __CFString *a1)
{
  return convertIPAddress(a1, 0);
}

CFTypeRef SecFrameworkCopyIPAddressData(const __CFString *a1)
{
  CFTypeRef v2;

  v2 = 0;
  if (convertIPAddress(a1, &v2))
    return v2;
  else
    return 0;
}

uint64_t apply_block_1_7636(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFMutableArrayRef SecCertificateCopyRFC822NamesFromSAN(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  uint64_t v3;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = *(_QWORD *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames(v3 + 24, (uint64_t)Mutable, (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendRFC822NamesFromGeneralNames)|| !CFArrayGetCount(Mutable))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

OSStatus SecCertificateCopyEmailAddresses(SecCertificateRef certificate, CFArrayRef *emailAddresses)
{
  OSStatus result;
  const __CFArray *v5;
  const __CFArray *v6;

  result = -50;
  if (certificate && emailAddresses)
  {
    v5 = SecCertificateCopyRFC822Names((uint64_t)certificate);
    *emailAddresses = v5;
    if (v5)
    {
      return 0;
    }
    else
    {
      v6 = CFArrayCreate(0, 0, 0, MEMORY[0x1E0C9B378]);
      result = 0;
      *emailAddresses = v6;
    }
  }
  return result;
}

CFMutableArrayRef SecCertificateCopyRFC822NamesFromSubject(uint64_t a1)
{
  CFMutableArrayRef Mutable;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendRFC822NamesFromX501Name, 1)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

CFMutableArrayRef SecCertificateCopyURIs(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  uint64_t v3;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = *(_QWORD *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames(v3 + 24, (uint64_t)Mutable, (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendURIsFromGeneralNames)|| !CFArrayGetCount(Mutable))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

uint64_t appendURIsFromGeneralNames(__CFArray *a1, int a2, uint64_t a3)
{
  CFStringRef v4;
  CFStringRef v5;

  if (a2 != 6)
    return 0;
  if ((*(_QWORD *)(a3 + 8) & 0x8000000000000000) != 0)
    return 4294941021;
  v4 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(const UInt8 **)a3, *(_QWORD *)(a3 + 8), 0x600u, 0);
  if (!v4)
    return 4294941021;
  v5 = v4;
  CFArrayAppendValue(a1, v4);
  CFRelease(v5);
  return 0;
}

OSStatus SecCertificateCopyCommonName(SecCertificateRef certificate, CFStringRef *commonName)
{
  const __CFArray *v3;
  const __CFArray *v4;
  CFIndex Count;
  const __CFString *ValueAtIndex;
  const __CFString *v7;

  if (!certificate)
    return -50;
  v3 = SecCertificateCopyCommonNames((uint64_t)certificate);
  if (!v3)
    return -26276;
  v4 = v3;
  if (commonName)
  {
    Count = CFArrayGetCount(v3);
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v4, Count - 1);
    v7 = ValueAtIndex;
    if (ValueAtIndex)
      CFRetain(ValueAtIndex);
    *commonName = v7;
  }
  CFRelease(v4);
  return 0;
}

CFMutableArrayRef SecCertificateCopyOrganization(uint64_t a1)
{
  return SecCertificateCopyOrganizationFromX501NameContent((unint64_t *)(a1 + 184));
}

CFMutableArrayRef SecCertificateCopyOrganizationalUnit(uint64_t a1)
{
  CFMutableArrayRef Mutable;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendOrganizationalUnitFromX501Name, 1)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t appendOrganizationalUnitFromX501Name(__CFArray *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result;
  __CFString *v9;
  __CFString *v10;

  result = DEROidCompare(a2, (uint64_t)&oidOrganizationalUnitName);
  if ((_DWORD)result)
  {
    v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, 1, a5);
    if (v9)
    {
      v10 = v9;
      CFArrayAppendValue(a1, v9);
      CFRelease(v10);
      return 0;
    }
    else
    {
      return 4294941021;
    }
  }
  return result;
}

const void *SecCertificateCopySubjectAttributeValue(uint64_t a1, uint64_t a2)
{
  int v2;
  const void *result;
  _QWORD v4[2];
  const void *v5;

  v5 = 0;
  v4[0] = a2;
  v4[1] = &v5;
  v2 = parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)v4, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))copyAttributeValueFromX501Name, 0);
  result = v5;
  if (v2)
  {
    if (v5)
    {
      v5 = 0;
      CFRelease(result);
      return v5;
    }
  }
  return result;
}

uint64_t copyAttributeValueFromX501Name(uint64_t *a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, int a5)
{
  uint64_t result;
  __CFString *v9;
  __CFString *v10;
  CFTypeRef *v11;

  result = DEROidCompare(a2, *a1);
  if ((_DWORD)result)
  {
    v9 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a3, 1, a5);
    if (v9)
    {
      v10 = v9;
      v11 = (CFTypeRef *)a1[1];
      if (*v11)
        CFRelease(*v11);
      result = 0;
      *v11 = v10;
    }
    else
    {
      return 4294941021;
    }
  }
  return result;
}

CFMutableArrayRef SecCertificateCopyNTPrincipalNames(uint64_t a1)
{
  CFMutableArrayRef Mutable;
  uint64_t v3;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v3 = *(_QWORD *)(a1 + 456);
  if (v3
    && SecCertificateParseGeneralNames(v3 + 24, (uint64_t)Mutable, (uint64_t (*)(uint64_t, uint64_t, uint64_t))appendNTPrincipalNamesFromGeneralNames)|| !CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t appendNTPrincipalNamesFromGeneralNames(__CFArray *a1, int a2, unint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  __int128 v7;
  __CFString *v8;
  __CFString *v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;

  if (a2)
    return 0;
  v12 = v3;
  v13 = v4;
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10 = v7;
  v11 = v7;
  if (DERParseSequenceContent(a3, (unsigned __int16)DERNumOtherNameItemSpecs, (uint64_t)&DEROtherNameItemSpecs, (unint64_t)&v10, 0x20uLL))return 4294941021;
  if (DEROidCompare((uint64_t)&v10, (uint64_t)&oidMSNTPrincipalName))
  {
    v8 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (unsigned __int8 **)&v11, 1, 1);
    if (v8)
    {
      v9 = v8;
      CFArrayAppendValue(a1, v8);
      CFRelease(v9);
      return 0;
    }
    return 4294941021;
  }
  return 0;
}

CFMutableStringRef SecCertificateCopySubjectString(uint64_t a1)
{
  CFMutableStringRef Mutable;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (parseX501NameContent((unint64_t *)(a1 + 184), (uint64_t)Mutable, (uint64_t (*)(uint64_t, __int128 *, __int128 *, uint64_t, uint64_t))appendToRFC2253String, 1)|| !CFStringGetLength(Mutable))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t appendToRFC2253String(__CFString *theString, unsigned __int8 **a2, uint64_t a3, uint64_t a4, int a5)
{
  const __CFString *v9;
  CFStringRef v10;
  const __CFString *v11;
  unint64_t v12;
  __CFString *v14;
  const __CFString *v15;
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v19;
  int64_t v20;
  uint64_t v21;
  uint64_t v22;
  CFIndex v23;
  UniChar v24;
  int64_t v25;
  uint64_t v27;
  uint64_t v28;
  int64_t v29;
  CFIndex v30;
  UniChar *v31;
  __CFString *v32;
  CFIndex v33;
  UniChar chars[2];
  __int16 v35;
  UniChar buffer[8];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  CFStringRef v44;
  const UniChar *v45;
  const char *v46;
  uint64_t v47;
  CFIndex v48;
  int64_t v49;
  int64_t v50;
  CFRange v51;

  if (a4 <= 0)
  {
    if (!CFStringGetLength(theString))
      goto LABEL_6;
    v9 = CFSTR(",");
  }
  else
  {
    v9 = CFSTR("+");
  }
  CFStringAppend(theString, v9);
LABEL_6:
  if (DEROidCompare((uint64_t)a2, (uint64_t)&oidCommonName))
  {
    v10 = 0;
    v11 = CFSTR("CN");
  }
  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidLocalityName))
  {
    v10 = 0;
    v11 = CFSTR("L");
  }
  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidStateOrProvinceName))
  {
    v10 = 0;
    v11 = CFSTR("ST");
  }
  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidOrganizationName))
  {
    v10 = 0;
    v11 = CFSTR("O");
  }
  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidOrganizationalUnitName))
  {
    v10 = 0;
    v11 = CFSTR("OU");
  }
  else if (DEROidCompare((uint64_t)a2, (uint64_t)&oidCountryName))
  {
    v10 = 0;
    v11 = CFSTR("C");
  }
  else
  {
    v10 = SecDERItemCopyOIDDecimalRepresentation((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2);
    v11 = v10;
  }
  CFStringAppend(theString, v11);
  CFStringAppend(theString, CFSTR("="));
  if (v10
    || (v14 = copyDERThingDescription((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (unsigned __int8 **)a3, 1, a5)) == 0)
  {
    CFStringAppend(theString, CFSTR("#"));
    if (*(_QWORD *)(a3 + 8))
    {
      v12 = 0;
      do
        CFStringAppendFormat(theString, 0, CFSTR("%02X"), *(unsigned __int8 *)(*(_QWORD *)a3 + v12++));
      while (v12 < *(_QWORD *)(a3 + 8));
    }
    if (v10)
      CFRelease(v10);
  }
  else
  {
    v15 = v14;
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    *(_OWORD *)buffer = 0u;
    v37 = 0u;
    Length = CFStringGetLength(v14);
    v44 = v15;
    v47 = 0;
    v48 = Length;
    CharactersPtr = CFStringGetCharactersPtr(v15);
    CStringPtr = 0;
    v45 = CharactersPtr;
    if (!CharactersPtr)
      CStringPtr = CFStringGetCStringPtr(v15, 0x600u);
    v46 = CStringPtr;
    v49 = 0;
    v50 = 0;
    if (Length >= 1)
    {
      v19 = 0;
      v20 = 0;
      v21 = 64;
      do
      {
        if ((unint64_t)v20 >= 4)
          v22 = 4;
        else
          v22 = v20;
        v35 = -21846;
        v23 = v48;
        if (v48 <= v20)
        {
          v24 = 0;
          v35 = 0;
        }
        else
        {
          if (v45)
          {
            v24 = v45[v20 + v47];
          }
          else if (v46)
          {
            v24 = v46[v47 + v20];
          }
          else
          {
            v25 = v49;
            if (v50 <= v20 || v49 > v20)
            {
              v27 = v22 + v19;
              v28 = v21 - v22;
              v29 = v20 - v22;
              v30 = v29 + 64;
              if (v29 + 64 >= v48)
                v30 = v48;
              v49 = v29;
              v50 = v30;
              if (v48 >= v28)
                v23 = v28;
              v51.length = v23 + v27;
              v51.location = v29 + v47;
              CFStringGetCharacters(v44, v51, buffer);
              v25 = v49;
            }
            v24 = buffer[v20 - v25];
          }
          v35 = v24;
          if (v24 > 0x1Fu)
          {
            if (v24 - 32 > 0x3C)
              goto LABEL_63;
            if (((1 << (v24 - 32)) & 0x1000000058001804) != 0)
              goto LABEL_54;
            if (v24 == 32)
            {
              if (!v20 || Length - 1 == v20)
                goto LABEL_54;
LABEL_64:
              v31 = (UniChar *)&v35;
              v32 = theString;
              v33 = 1;
            }
            else
            {
LABEL_63:
              if (v20 || v24 != 35)
                goto LABEL_64;
LABEL_54:
              chars[0] = 92;
              chars[1] = v24;
              v31 = chars;
              v32 = theString;
              v33 = 2;
            }
            CFStringAppendCharacters(v32, v31, v33);
            goto LABEL_56;
          }
        }
        CFStringAppendFormat(theString, 0, CFSTR("\\%02X"), v24);
LABEL_56:
        ++v20;
        --v19;
        ++v21;
      }
      while (Length != v20);
    }
    CFRelease(v15);
  }
  return 0;
}

__CFData *SecCertificateCopySubjectSequence(uint64_t a1)
{
  return SecDERItemCopySequence(a1 + 184);
}

uint64_t SecCertificateGetPublicKeyAlgorithm(uint64_t a1)
{
  return a1 + 216;
}

uint64_t SecCertificateIsStrongKey(uint64_t result)
{
  uint64_t v1;
  BOOL v2;
  unint64_t v3;

  if (result)
  {
    v3 = 0;
    v1 = SecCertificateGetPublicKeyAlgorithmIdAndSize((__SecCertificate *)result, (uint64_t *)&v3) - 1;
    result = 1;
    switch(v1)
    {
      case 0:
        v2 = v3 > 0xFF;
        goto LABEL_5;
      case 2:
        v2 = v3 > 0x1B;
LABEL_5:
        result = v2;
        break;
      case 3:
      case 5:
        return result;
      default:
        result = 0;
        break;
    }
  }
  return result;
}

__CFData *SecCertificateCopyIssuerSHA256Digest(uint64_t a1)
{
  __CFData *result;
  const __CFData *v2;
  const __CFAllocator *v3;
  const UInt8 *BytePtr;
  CFIndex Length;
  __CFData *v6;

  result = SecDERItemCopySequence(a1 + 152);
  if (result)
  {
    v2 = result;
    v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    BytePtr = CFDataGetBytePtr(result);
    Length = CFDataGetLength(v2);
    v6 = SecSHA256DigestCreate(v3, (uint64_t)BytePtr, Length);
    CFRelease(v2);
    return v6;
  }
  return result;
}

__CFData *SecCertificateCopyPublicKeySHA256Digest(_QWORD *cf)
{
  const __CFAllocator *v2;

  if (!cf || !cf[31] || (cf[32] & 0x8000000000000000) != 0)
    return 0;
  v2 = CFGetAllocator(cf);
  return SecSHA256DigestCreate(v2, cf[31], cf[32]);
}

CFDataRef SecCertificateCopySubjectPublicKeyInfoSHA1Digest(const void *a1)
{
  CFDataRef result;
  const __CFData *v3;
  const __CFAllocator *v4;
  const UInt8 *BytePtr;
  CFIndex Length;
  __CFData *v7;

  result = SecCertificateCopySPKIEncoded((uint64_t)a1);
  if (result)
  {
    v3 = result;
    v4 = CFGetAllocator(a1);
    BytePtr = CFDataGetBytePtr(v3);
    Length = CFDataGetLength(v3);
    v7 = SecSHA1DigestCreate(v4, (uint64_t)BytePtr, Length);
    CFRelease(v3);
    return v7;
  }
  return result;
}

_QWORD *SecCertificateCopyKeychainItem(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    v1 = result;
    result = (_QWORD *)result[77];
    if (result)
    {
      CFRetain(result);
      return (_QWORD *)v1[77];
    }
  }
  return result;
}

uint64_t SecCertificateGetCAIssuers(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 480);
  return result;
}

BOOL SecCertificateHasCriticalSubjectAltName(_BOOL8 result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(result + 456);
    return v1 && *(unsigned __int8 *)(v1 + 16) != 0;
  }
  return result;
}

BOOL SecCertificateHasSubject(_BOOL8 result)
{
  if (result)
    return *(_QWORD *)(result + 192) != 0;
  return result;
}

uint64_t SecCertificateShow(const void *a1)
{
  FILE **v1;

  v1 = (FILE **)MEMORY[0x1E0C80C10];
  fprintf((FILE *)*MEMORY[0x1E0C80C10], "SecCertificate instance %p:\n", a1);
  return fputc(10, *v1);
}

CFDictionaryRef SecCertificateCopyAttributeDictionary(uint64_t a1)
{
  const __CFAllocator *v2;
  uint64_t v3;
  __int128 v4;
  const __CFAllocator *v5;
  uint64_t v6;
  __int128 v7;
  int v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFDataRef v11;
  CFDataRef v12;
  CFDataRef SubjectKeyID;
  __CFData *v14;
  __CFData *v15;
  const void *v16;
  CFTypeID v17;
  uint64_t v18;
  CFDictionaryRef v19;
  const void *v20;
  CFTypeID v21;
  const void *v22;
  CFTypeID v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  unint64_t v38;
  uint64_t v39;
  CFNumberRef v40;
  int v41;
  int valuePtr;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (!SecCertificateIsCertificate((_QWORD *)a1))
    return 0;
  v2 = CFGetAllocator((CFTypeRef)a1);
  v3 = MEMORY[0x1E0C80A78](v2);
  v38 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v36 = v4;
  v37 = v4;
  v34 = v4;
  v35 = v4;
  v33 = v4;
  v5 = (const __CFAllocator *)MEMORY[0x1E0C80A78](v3);
  v32 = v6;
  v30 = v7;
  v31 = v7;
  v28 = v7;
  v29 = v7;
  v27 = v7;
  v8 = *(unsigned __int8 *)(a1 + 96) + 1;
  v41 = 3;
  valuePtr = v8;
  v40 = CFNumberCreate(v5, kCFNumberSInt32Type, &valuePtr);
  if (!v40)
    return 0;
  v9 = CFNumberCreate(v2, kCFNumberSInt32Type, &v41);
  if (v9)
  {
    v10 = v9;
    v11 = SecCertificateCopyData((SecCertificateRef)a1);
    if (v11)
    {
      v12 = v11;
      SubjectKeyID = SecCertificateGetSubjectKeyID((CFDataRef)a1);
      v14 = SecCertificateCopyPublicKeySHA1Digest((_QWORD *)a1);
      if (v14)
      {
        v15 = v14;
        *(_QWORD *)&v33 = CFSTR("class");
        *((_QWORD *)&v33 + 1) = CFSTR("ctyp");
        *(_QWORD *)&v27 = CFSTR("cert");
        *((_QWORD *)&v27 + 1) = v40;
        *(_QWORD *)&v34 = CFSTR("cenc");
        *(_QWORD *)&v28 = v10;
        v16 = *(const void **)(a1 + 584);
        v39 = (uint64_t)&v39;
        if (v16 && (v17 = CFGetTypeID(v16), v17 == CFDataGetTypeID()))
        {
          *((_QWORD *)&v34 + 1) = CFSTR("subj");
          *((_QWORD *)&v28 + 1) = *(_QWORD *)(a1 + 584);
          v18 = 4;
        }
        else
        {
          v18 = 3;
        }
        v20 = *(const void **)(a1 + 576);
        if (v20
          && (v21 = CFGetTypeID(v20), v21 == CFDataGetTypeID())
          && (*((_QWORD *)&v33 + v18) = CFSTR("issr"),
              *((_QWORD *)&v27 + v18) = *(_QWORD *)(a1 + 576),
              (v22 = *(const void **)(a1 + 568)) != 0)
          && (v23 = CFGetTypeID(v22), v23 == CFDataGetTypeID()))
        {
          *((_QWORD *)&v33 + v18 + 1) = CFSTR("slnr");
          *((_QWORD *)&v27 + v18 + 1) = *(_QWORD *)(a1 + 568);
          v24 = v18 + 2;
          if (SubjectKeyID)
          {
            *((_QWORD *)&v33 + v24) = CFSTR("skid");
            *((_QWORD *)&v27 + v24) = SubjectKeyID;
            v24 = v18 + 3;
          }
          *((_QWORD *)&v33 + v24) = CFSTR("pkhh");
          *((_QWORD *)&v27 + v24) = v15;
          v25 = 8 * v24 + 8;
          *(_QWORD *)((char *)&v33 + v25) = CFSTR("v_Data");
          *(_QWORD *)((char *)&v27 + v25) = v12;
          v19 = CFDictionaryCreate(v2, (const void **)&v33, (const void **)&v27, v24 + 2, 0, MEMORY[0x1E0C9B3A0]);
        }
        else
        {
          v19 = 0;
        }
        CFRelease(v15);
      }
      else
      {
        v19 = 0;
      }
      CFRelease(v12);
    }
    else
    {
      v19 = 0;
    }
    CFRelease(v10);
  }
  else
  {
    v19 = 0;
  }
  CFRelease(v40);
  return v19;
}

_QWORD *SecCertificateIsCertificate(_QWORD *result)
{
  CFTypeID v1;

  if (result)
  {
    if (!result[2] || (result[3] & 0x8000000000000000) != 0)
    {
      return 0;
    }
    else
    {
      v1 = CFGetTypeID(result);
      return (_QWORD *)(v1 == SecCertificateGetTypeID());
    }
  }
  return result;
}

const __CFData *SecCertificateCreateFromAttributeDictionary(const __CFDictionary *a1)
{
  const __CFData *result;

  result = (const __CFData *)CFDictionaryGetValue(a1, CFSTR("v_Data"));
  if (result)
    return SecCertificateCreateWithData(0, result);
  return result;
}

_QWORD *SecCertificateIsSelfSignedCA(uint64_t a1)
{
  _QWORD *result;

  result = (_QWORD *)_SecCertificateIsSelfSigned(a1);
  if ((_DWORD)result)
    return SecCertificateIsCA(a1);
  return result;
}

uint64_t SecCertificateGetExtensionValue(uint64_t a1, const __CFString *cf)
{
  CFTypeID v4;
  CFTypeID v6;
  const __CFArray *OidDataFromString;
  const __CFArray *v8;
  uint64_t v9;

  if (!a1 || !cf)
    return 0;
  v4 = CFGetTypeID(cf);
  if (v4 == CFDataGetTypeID())
    return cert_extension_value_for_marker(a1, (CFDataRef)cf);
  v6 = CFGetTypeID(cf);
  if (v6 != CFStringGetTypeID())
    return 0;
  OidDataFromString = SecCertificateCreateOidDataFromString(0, cf);
  if (!OidDataFromString)
    return 0;
  v8 = OidDataFromString;
  v9 = cert_extension_value_for_marker(a1, OidDataFromString);
  CFRelease(v8);
  return v9;
}

uint64_t cert_extension_value_for_marker(uint64_t a1, CFDataRef theData)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *i;

  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (Length < 0)
    return 0;
  v6 = *(_QWORD *)(a1 + 512);
  if (v6 < 1)
    return 0;
  v7 = Length;
  v8 = 0;
  v9 = *(_QWORD *)(a1 + 520);
  for (i = (_QWORD *)(v9 + 8); *i != v7 || memcmp((const void *)*(i - 1), BytePtr, v7); i += 5)
  {
    if (v6 == ++v8)
      return 0;
  }
  return v9 + 40 * v8 + 24;
}

CFDataRef SecCertificateCopyExtensionValue(uint64_t a1, const __CFString *cf, _BYTE *a3)
{
  CFDataRef v3;
  const __CFString *OidDataFromString;
  CFTypeID v7;
  CFTypeID v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  CFIndex v17;

  v3 = 0;
  if (a1)
  {
    OidDataFromString = cf;
    if (cf)
    {
      v7 = CFGetTypeID(cf);
      if (v7 == CFDataGetTypeID())
      {
        CFRetain(OidDataFromString);
      }
      else
      {
        v8 = CFGetTypeID(OidDataFromString);
        if (v8 != CFStringGetTypeID())
          return 0;
        OidDataFromString = (const __CFString *)SecCertificateCreateOidDataFromString(0, OidDataFromString);
        if (!OidDataFromString)
          return 0;
      }
      BytePtr = CFDataGetBytePtr((CFDataRef)OidDataFromString);
      Length = CFDataGetLength((CFDataRef)OidDataFromString);
      if (Length < 0)
        goto LABEL_13;
      v11 = *(_QWORD *)(a1 + 512);
      if (v11 < 1)
        goto LABEL_13;
      v12 = Length;
      v13 = 0;
      v14 = *(_QWORD *)(a1 + 520);
      v15 = (_QWORD *)(v14 + 8);
      while (*v15 != v12 || memcmp((const void *)*(v15 - 1), BytePtr, v12))
      {
        ++v13;
        v15 += 5;
        if (v11 == v13)
          goto LABEL_13;
      }
      if (a3)
        *a3 = *(_BYTE *)(v14 + 40 * v13 + 16);
      v17 = *(_QWORD *)(v14 + 40 * v13 + 32);
      if (v17 < 0)
LABEL_13:
        v3 = 0;
      else
        v3 = CFDataCreate(0, *(const UInt8 **)(v14 + 40 * v13 + 24), v17);
      CFRelease(OidDataFromString);
    }
  }
  return v3;
}

CFDataRef SecCertificateCopyiAPAuthCapabilities(uint64_t a1)
{
  int v2;
  CFDataRef result;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6[3];

  v2 = SecCertificateGetiAuthVersion(a1);
  if (v2 == 5)
  {
    result = (CFDataRef)SecCertificateGetExtensionValue(a1, CFSTR("1.2.840.113635.100.6.71.1"));
    if (!result)
      return result;
    if (*((_QWORD *)result + 1) == 32)
      return CFDataCreate(0, *(const UInt8 **)result, 32);
  }
  else if (v2 == 3)
  {
    result = (CFDataRef)SecCertificateGetExtensionValue(a1, CFSTR("1.2.840.113635.100.6.36"));
    if (!result)
      return result;
    v4 = (unint64_t *)result;
    if (*((_QWORD *)result + 1) == 34)
    {
      memset(v6, 170, sizeof(v6));
      if (!DERDecodeItem((uint64_t)result, v6))
      {
        if (v6[0] == 4)
        {
          if (v6[2] == 32)
          {
            v5 = v6[1];
            return CFDataCreate(0, (const UInt8 *)v5, 32);
          }
        }
        else
        {
          v5 = *v4;
          if (!*(_BYTE *)(*v4 + 33) && !*(_BYTE *)(v5 + 32))
            return CFDataCreate(0, (const UInt8 *)v5, 32);
        }
      }
    }
  }
  return 0;
}

uint64_t SecCertificateGetiAuthVersion(uint64_t result)
{
  uint64_t v1;
  unsigned __int8 *v2;

  if (result)
  {
    v1 = result;
    if (SecCertificateGetExtensionValue(result, CFSTR("1.2.840.113635.100.6.36")))
    {
      return 3;
    }
    else if (SecCertificateGetExtensionValue(v1, CFSTR("1.2.840.113635.100.6.59.1")))
    {
      return 4;
    }
    else if (SecCertificateGetExtensionValue(v1, CFSTR("1.2.840.113635.100.6.71.1")))
    {
      return 5;
    }
    else
    {
      v2 = *(unsigned __int8 **)(v1 + 104);
      if (v2 && *(_QWORD *)(v1 + 112) == 15 && v2[2] == 170 && v2[6] == 170 && v2[8] == 170 && v2[11] == 170)
        return 2;
      else
        return 0;
    }
  }
  return result;
}

CFDataRef SecCertificateCopyiAPSWAuthCapabilities(uint64_t a1, unsigned int a2)
{
  unint64_t v2;
  unint64_t v3;
  CFDataRef result;
  BOOL v6;
  unint64_t v7[5];

  result = 0;
  if (a1)
  {
    if (a2 <= 2)
    {
      v7[3] = v2;
      v7[4] = v3;
      result = (CFDataRef)SecCertificateGetExtensionValue(a1, off_1E1FD5698[a2]);
      if (result)
      {
        memset(v7, 170, 24);
        if (DERDecodeItem((uint64_t)result, v7))
          v6 = 0;
        else
          v6 = v7[0] == 4;
        if (v6 && v7[2] <= 0x7FFFFFFFFFFFFFFELL)
          return CFDataCreate(0, (const UInt8 *)v7[1], v7[2]);
        else
          return 0;
      }
    }
  }
  return result;
}

CFStringRef SecCertificateCopyComponentType(CFStringRef result)
{
  CFStringRef v1;
  int v2;
  unint64_t info;
  const UInt8 *isa;
  CFStringEncoding v5;
  unint64_t v6[3];

  if (result)
  {
    result = (CFStringRef)SecCertificateGetExtensionValue((uint64_t)result, CFSTR("1.2.840.113635.100.11.1"));
    if (result)
    {
      v1 = result;
      memset(v6, 170, sizeof(v6));
      v2 = DERDecodeItem((uint64_t)result, v6);
      if (!v2 && v6[0] == 22)
      {
        info = v6[2];
        if (v6[2] <= 0x7FFFFFFFFFFFFFFELL)
        {
          isa = (const UInt8 *)v6[1];
          v5 = 1536;
          return CFStringCreateWithBytes(0, isa, info, v5, 0);
        }
        return 0;
      }
      if (v2 || v6[0] != 12)
      {
        if (v2 != 3)
          return 0;
        info = v1->info;
        if (info > 0x7FFFFFFFFFFFFFFELL)
          return 0;
        isa = (const UInt8 *)v1->isa;
      }
      else
      {
        info = v6[2];
        if (v6[2] > 0x7FFFFFFFFFFFFFFELL)
          return 0;
        isa = (const UInt8 *)v6[1];
      }
      v5 = 134217984;
      return CFStringCreateWithBytes(0, isa, info, v5, 0);
    }
  }
  return result;
}

CFDictionaryRef SecCertificateCopyComponentAttributes(const __CFDictionary *a1)
{
  CFDictionaryRef Copy;
  uint64_t ExtensionValue;
  const __CFDictionary *v3;
  const void *v4;
  _QWORD v6[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  CFMutableDictionaryRef Mutable;

  Copy = a1;
  if (a1)
  {
    v7 = 0;
    v8 = &v7;
    v9 = 0x2000000000;
    Mutable = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    ExtensionValue = SecCertificateGetExtensionValue((uint64_t)Copy, CFSTR("1.2.840.113635.100.11.3"));
    if (ExtensionValue
      && (v6[0] = MEMORY[0x1E0C809B0],
          v6[1] = 0x40000000,
          v6[2] = __SecCertificateCopyComponentAttributes_block_invoke,
          v6[3] = &unk_1E1FD5448,
          v6[4] = &v7,
          !DERDecodeSequenceWithBlock(ExtensionValue, (uint64_t)v6))
      && (v3 = (const __CFDictionary *)v8[3]) != 0
      && CFDictionaryGetCount(v3) >= 1)
    {
      Copy = CFDictionaryCreateCopy(0, (CFDictionaryRef)v8[3]);
    }
    else
    {
      Copy = 0;
    }
    v4 = (const void *)v8[3];
    if (v4)
    {
      v8[3] = 0;
      CFRelease(v4);
    }
    _Block_object_dispose(&v7, 8);
  }
  return Copy;
}

CFDataRef SecCertificateCopyCompressedMFiCert(uint64_t a1)
{
  uint64_t v2;
  int v3;
  _BYTE *v4;
  int v5;
  CFDataRef v6;
  NSObject *v7;
  size_t size;
  uint8_t buf[4];
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v2 = *(_QWORD *)(a1 + 24);
  if (v2 < 0)
    return 0;
  size = 0;
  v3 = CTCompressComputeBufferSize(*(_QWORD *)(a1 + 16), v2, &size);
  if (v3)
  {
    v5 = v3;
LABEL_10:
    v7 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v11 = v5;
      _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "coretrust compress failed: %04x", buf, 8u);
    }
    return 0;
  }
  v4 = malloc_type_malloc(size, 0xF7C031DuLL);
  if (!v4)
  {
    v6 = 0;
    goto LABEL_8;
  }
  v5 = CTCompress(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), v4, size);
  if (v5 || size > 0x7FFFFFFFFFFFFFFELL)
  {
    free(v4);
    if (v5)
      goto LABEL_10;
    return 0;
  }
  v6 = CFDataCreate(0, v4, size);
LABEL_8:
  free(v4);
  return v6;
}

const __CFData *SecCertificateCreateWithCompressedMFiCert(const __CFData *cf)
{
  const __CFData *v1;
  CFTypeID v2;
  const UInt8 *BytePtr;
  CFIndex Length;
  int v5;
  void *v6;
  const UInt8 *v7;
  CFIndex v8;
  int v9;
  int v10;
  NSObject *v11;
  size_t size;
  uint8_t buf[4];
  int v15;
  uint64_t v16;

  v1 = cf;
  v16 = *MEMORY[0x1E0C80C00];
  if (cf)
  {
    v2 = CFGetTypeID(cf);
    if (v2 == CFDataGetTypeID() && (CFDataGetLength(v1) & 0x8000000000000000) == 0)
    {
      size = 0;
      BytePtr = CFDataGetBytePtr(v1);
      Length = CFDataGetLength(v1);
      v5 = CTDecompressComputeBufferSize((unint64_t)BytePtr, Length, &size);
      if (v5)
      {
        v10 = v5;
        v6 = 0;
      }
      else
      {
        v6 = malloc_type_malloc(size, 0x77BDE150uLL);
        if (!v6)
          goto LABEL_9;
        v7 = CFDataGetBytePtr(v1);
        v8 = CFDataGetLength(v1);
        v9 = CTDecompress((unint64_t)v7, v8, (unint64_t)v6, size);
        if (!v9)
        {
          if (size <= 0x7FFFFFFFFFFFFFFELL)
          {
            v1 = (const __CFData *)SecCertificateCreateWithBytes(0, v6, size);
LABEL_10:
            free(v6);
            return v1;
          }
LABEL_9:
          v1 = 0;
          goto LABEL_10;
        }
        v10 = v9;
      }
      free(v6);
      v11 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        v15 = v10;
        _os_log_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEFAULT, "coretrust decompress failed: %04x", buf, 8u);
      }
    }
    return 0;
  }
  return v1;
}

_QWORD *SecCertificateCreateWithPEM(int a1, CFDataRef theData)
{
  const char *BytePtr;
  CFIndex Length;
  char *v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  uint64_t v9;
  int v10;
  int v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  _BYTE *v19;
  void *v20;
  _BYTE *v21;
  int v23;
  unsigned __int8 *v24;

  if (!theData || CFDataGetLength(theData) < 1)
    return 0;
  BytePtr = (const char *)CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v5 = strnstr(BytePtr, "-----BEGIN CERTIFICATE-----", Length);
  v6 = strnstr(BytePtr, "-----END CERTIFICATE-----", Length);
  v7 = 0;
  if (!v5 || !v6 || v5 > v6)
    return v7;
  v8 = v5 + 27;
  if (v5 + 27 < v6)
  {
    v9 = v6 - v5 - 27;
    while (1)
    {
      v10 = *v8;
      if (v10 != 32 && v10 != 9)
        break;
      ++v8;
      if (!--v9)
      {
        v8 = v6;
        break;
      }
    }
  }
  v12 = *v8;
  if (v12 == 13)
  {
    v15 = v8[1];
    v14 = (unsigned __int8 *)(v8 + 1);
    if (v15 == 10)
      v13 = v14 + 1;
    else
      v13 = v14;
    goto LABEL_21;
  }
  if (v12 != 10)
    return 0;
  v13 = (unsigned __int8 *)(v8 + 1);
LABEL_21:
  if (v13 > (unsigned __int8 *)v6)
    return 0;
  v16 = v6 - (char *)v13;
  v17 = (unint64_t)(v6 - (char *)v13) >> 2;
  if (((v6 - (char *)v13) & 3) != 0)
    ++v17;
  if (!v17)
    return 0;
  v18 = 3 * v17;
  if (3 * v17 >= CFDataGetLength(theData))
    return 0;
  v19 = malloc_type_calloc(1uLL, v18, 0x9866277FuLL);
  if (!v19)
    return 0;
  v20 = v19;
  v21 = SecBase64Decode_(v13, v16, v19, v18, 0, &v24, &v23);
  if (v21)
    v7 = SecCertificateCreateWithBytes(*MEMORY[0x1E0C9AE00], v20, (int64_t)v21);
  else
    v7 = 0;
  free(v20);
  return v7;
}

CFStringRef SecCertificateCopyPEMRepresentation(uint64_t a1)
{
  unsigned __int8 *v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  size_t v6;
  char *v7;
  char *v8;
  unint64_t v9;
  CFStringRef v10;
  int v12;

  if (!a1)
    return 0;
  v1 = *(unsigned __int8 **)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 24);
  v3 = (2 * (((v2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  v4 = v3 + 2 * ((unint64_t)(v3 + 63) >> 6);
  v5 = v4 - 2;
  v6 = v4 + 53;
  v7 = (char *)malloc_type_malloc(v4 + 53, 0x80BA09DCuLL);
  v8 = &v7[snprintf(v7, v6, "-----BEGIN %s-----\n", "CERTIFICATE")];
  v12 = -1431655766;
  v9 = SecBase64Encode_(v1, v2, v8, v5, 0x40u, &v12);
  if (v12)
  {
    v10 = 0;
  }
  else
  {
    snprintf(&v8[v9], &v7[v6] - &v8[v9], "\n-----END %s-----\n", "CERTIFICATE");
    v10 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v7, v6, 0x8000100u, 0);
  }
  free(v7);
  return v10;
}

xpc_object_t SecCertificateArrayCopyXPCArray(const __CFArray *a1, __CFString **a2)
{
  xpc_object_t v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const void *ValueAtIndex;

  v4 = xpc_array_create(0, 0);
  if (v4)
  {
    Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      v6 = Count;
      v7 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, v7);
        if (!SecCertificateAppendToXPCArray((uint64_t)ValueAtIndex, v4, a2))
          break;
        if (v6 == ++v7)
          return v4;
      }
      xpc_release(v4);
      return 0;
    }
  }
  else
  {
    SecError(-108, a2, CFSTR("failed to create xpc_array"));
  }
  return v4;
}

CFArrayRef SecCertificateCopyEscrowRoots(uint64_t a1)
{
  CFIndex v1;
  _UNKNOWN **v2;
  size_t v3;
  CFTypeRef *v4;
  uint64_t v5;
  const __CFAllocator *v6;
  CFIndex *v7;
  const UInt8 *v8;
  const __CFData *v9;
  const __CFData *v10;
  CFArrayRef v11;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  if (a1 > 5)
  {
    v2 = &kBaseLineEscrowEnrollmentRoots;
    v1 = 4;
  }
  else
  {
    v1 = qword_18AA5EE80[a1];
    v2 = off_1E1FD56B0[a1];
  }
  MEMORY[0x1E0C80A78](a1);
  v4 = (CFTypeRef *)((char *)v13 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  memset(v4, 170, v3);
  v5 = 0;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  do
  {
    v7 = (CFIndex *)v2[v5];
    if (v7)
    {
      if (*v7 >= 1)
      {
        v8 = (const UInt8 *)v7[1];
        if (v8)
        {
          v9 = CFDataCreate(v6, v8, *v7);
          if (v9)
          {
            v10 = v9;
            v4[v5] = SecCertificateCreateWithData(v6, v9);
            CFRelease(v10);
          }
        }
      }
    }
    ++v5;
  }
  while (v1 != v5);
  v11 = CFArrayCreate(v6, v4, v1, MEMORY[0x1E0C9B378]);
  do
  {
    if (*v4)
      CFRelease(*v4);
    ++v4;
    --v1;
  }
  while (v1);
  return v11;
}

uint64_t SecCertificateCopyTrustedCTLogs()
{
  uint64_t (*v0)(CFTypeRef *);
  uint64_t v1;
  CFTypeRef cf;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  cf = 0;
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  if (gTrustd && (v0 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 104)) != 0)
  {
    v1 = v0(&cf);
  }
  else
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __CopyTrustedCTLogs_block_invoke_2;
    v4[3] = &unk_1E1FD5600;
    v4[4] = &v5;
    securityd_send_sync_and_do(0x19u, &cf, (uint64_t)&__block_literal_global_417, (uint64_t)v4);
    v1 = v6[3];
  }
  _Block_object_dispose(&v5, 8);
  if (cf)
    CFRelease(cf);
  return v1;
}

uint64_t SecCertificateCopyCTLogForKeyID(const __CFData *a1)
{
  CFTypeID v2;
  const UInt8 *BytePtr;
  const UInt8 *v4;
  uint64_t (*v5)(const __CFData *, CFTypeRef *);
  uint64_t v6;
  CFTypeRef cf;
  _QWORD v9[5];
  _QWORD v10[5];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;

  cf = 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  if (a1 && (v2 = CFGetTypeID(a1), v2 == CFDataGetTypeID()))
  {
    BytePtr = CFDataGetBytePtr(a1);
    if (BytePtr && (v4 = BytePtr, CFDataGetLength(a1) == 32))
    {
      if (gTrustd)
      {
        v5 = *(uint64_t (**)(const __CFData *, CFTypeRef *))(gTrustd + 112);
        if (v5)
        {
          v6 = v5(a1, &cf);
          goto LABEL_11;
        }
      }
      v10[0] = MEMORY[0x1E0C809B0];
      v10[1] = 0x40000000;
      v10[2] = __CopyCTLogForKeyID_block_invoke;
      v10[3] = &__block_descriptor_tmp_425;
      v10[4] = v4;
      v9[0] = MEMORY[0x1E0C809B0];
      v9[1] = 0x40000000;
      v9[2] = __CopyCTLogForKeyID_block_invoke_2;
      v9[3] = &unk_1E1FD5648;
      v9[4] = &v11;
      securityd_send_sync_and_do(0x1Au, &cf, (uint64_t)v10, (uint64_t)v9);
    }
    else
    {
      SecError(-50, (__CFString **)&cf, CFSTR("keyID data was not the expected length"));
    }
  }
  else
  {
    SecError(-50, (__CFString **)&cf, CFSTR("keyID was not a valid CFDataRef"));
  }
  v6 = v12[3];
LABEL_11:
  _Block_object_dispose(&v11, 8);
  if (cf)
    CFRelease(cf);
  return v6;
}

__CFArray *SecCertificateCopyiPhoneDeviceCAChain()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;
  const void *v3;
  _QWORD *v4;
  __CFArray *Mutable;
  __CFArray *v6;

  v0 = SecCertificateCreateWithBytes(0, &_AppleiPhoneDeviceCA, 877);
  if (!v0)
    return 0;
  v1 = v0;
  v2 = SecCertificateCreateWithBytes(0, &_AppleiPhoneCA, 1015);
  if (!v2)
  {
    v6 = 0;
    v4 = v1;
LABEL_7:
    CFRelease(v4);
    return v6;
  }
  v3 = v2;
  v4 = SecCertificateCreateWithBytes(0, &_AppleRootCA, 1215);
  if (v4)
  {
    Mutable = CFArrayCreateMutable(0, 3, MEMORY[0x1E0C9B378]);
    v6 = Mutable;
    if (Mutable)
    {
      CFArrayAppendValue(Mutable, v1);
      CFArrayAppendValue(v6, v3);
      CFArrayAppendValue(v6, v4);
    }
  }
  else
  {
    v6 = 0;
  }
  CFRelease(v1);
  CFRelease(v3);
  if (v4)
    goto LABEL_7;
  return v6;
}

BOOL SecCertificateGetDeveloperIDDate(uint64_t a1, double *a2, __CFString **a3)
{
  uint64_t ExtensionValue;
  _BOOL8 result;
  CFTypeRef cf;
  unint64_t v8[3];

  if (!a1 || !a2)
    return SecError(-50, a3, CFSTR("DeveloperID Date parsing: missing required input"));
  ExtensionValue = SecCertificateGetExtensionValue(a1, CFSTR("1.2.840.113635.100.6.1.33"));
  if (!ExtensionValue)
    return SecError(-67880, a3, CFSTR("DeveloperID Date parsing: extension not found"));
  memset(v8, 170, sizeof(v8));
  if (DERDecodeItem(ExtensionValue, v8))
    return SecError(-26275, a3, CFSTR("DeveloperID Date parsing: extension value failed to decode"), cf);
  cf = 0;
  if (v8[0] != 12)
    return SecError(-26275, a3, CFSTR("DeveloperID Date parsing: extension value wrong tag"), cf);
  *a2 = SecAbsoluteTimeFromDateContentWithError(24, (unsigned __int8 *)v8[1], v8[2], (CFErrorRef *)&cf);
  if (!cf)
    return 1;
  if (a3 && !*a3)
  {
    result = 0;
    *a3 = (__CFString *)cf;
  }
  else
  {
    CFRelease(cf);
    return 0;
  }
  return result;
}

uint64_t SecCertificateGetUnparseableKnownExtension(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 528);
  else
    return -1;
}

uint64_t SecCertificateGetDuplicateExtension(uint64_t a1)
{
  if (a1)
    return *(_QWORD *)(a1 + 536);
  else
    return -1;
}

__CFArray *SecCertificateCopyAppleExternalRoots()
{
  _QWORD *v0;
  const void *v1;
  _QWORD *v2;
  const void *v3;
  __CFArray *Mutable;
  __CFArray *v5;

  v0 = SecCertificateCreateWithBytes(0, &_AppleExternalECRootCA, 519);
  if (!v0)
    return 0;
  v1 = v0;
  v2 = SecCertificateCreateWithBytes(0, &_TestAppleExternalECRootCA, 530);
  if (v2)
  {
    v3 = v2;
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    v5 = Mutable;
    if (Mutable)
    {
      CFArrayAppendValue(Mutable, v1);
      if (os_variant_allows_internal_security_policies())
        CFArrayAppendValue(v5, v3);
    }
    CFRelease(v1);
  }
  else
  {
    v5 = 0;
    v3 = v1;
  }
  CFRelease(v3);
  return v5;
}

__CFArray *SecCertificateCopyAppleCorporateRoots()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;
  const void *v3;
  _QWORD *v4;
  __CFArray *Mutable;
  __CFArray *v6;

  v0 = SecCertificateCreateWithBytes(0, &_AppleCorporateRootCA, 949);
  if (!v0)
    return 0;
  v1 = v0;
  v2 = SecCertificateCreateWithBytes(0, &_AppleCorporateRootCA2, 585);
  if (!v2)
  {
    v6 = 0;
    v4 = v1;
LABEL_7:
    CFRelease(v4);
    return v6;
  }
  v3 = v2;
  v4 = SecCertificateCreateWithBytes(0, &_AppleCorporateRootCA3, 1417);
  if (v4)
  {
    Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    v6 = Mutable;
    if (Mutable)
    {
      CFArrayAppendValue(Mutable, v1);
      CFArrayAppendValue(v6, v3);
      CFArrayAppendValue(v6, v4);
    }
  }
  else
  {
    v6 = 0;
  }
  CFRelease(v1);
  CFRelease(v3);
  if (v4)
    goto LABEL_7;
  return v6;
}

uint64_t SecCurve25519PublicKeyInit(uint64_t a1, _OWORD *a2, uint64_t a3, int a4)
{
  _OWORD *v4;
  uint64_t result;
  __int128 v6;
  void *v7;
  int v9;
  NSObject *v10;
  const char *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v4 = *(_OWORD **)(a1 + 24);
  if (a4 != 6)
  {
    if (a4 != 7)
      return 4294967246;
    if (a3 == 32)
    {
      result = 0;
      v6 = a2[1];
      *v4 = *a2;
      v4[1] = v6;
      return result;
    }
    return 4294941021;
  }
  if (a3 != 32)
    return 4294941021;
  v7 = *(void **)(a1 + 16);
  if (v7 == &kSecEd25519PublicKeyDescriptor || v7 == &kSecEd25519PrivateKeyDescriptor)
  {
    ccsha512_di();
    ccrng();
    result = cced25519_make_pub_with_rng();
    if (!(_DWORD)result)
      return result;
    v9 = result;
    _SECKEY_LOG_7721();
    v10 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      goto LABEL_18;
    v13 = 67109120;
    v14 = v9;
    v11 = "cced25519_make_pub_with_rng() failed, error %d";
    goto LABEL_21;
  }
  ccrng();
  result = cccurve25519_make_pub_with_rng();
  if ((_DWORD)result)
  {
    v12 = result;
    _SECKEY_LOG_7721();
    v10 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
LABEL_18:

      return 4294941021;
    }
    v13 = 67109120;
    v14 = v12;
    v11 = "cccurve25519_make_pub_with_rng() failed, error %d";
LABEL_21:
    _os_log_error_impl(&dword_18A900000, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v13, 8u);
    goto LABEL_18;
  }
  return result;
}

uint64_t SecCurve25519PublicKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve25519PublicKeyBlockSize()
{
  return 32;
}

__CFDictionary *SecCurve25519PublicKeyCopyAttributeDictionary(_QWORD *a1)
{
  void *v1;
  const __CFString *v3;
  const __CFDictionary *v4;
  __CFDictionary *MutableCopy;

  v1 = (void *)a1[2];
  if (v1 == &kSecEd25519PrivateKeyDescriptor || v1 == &kSecEd25519PublicKeyDescriptor)
    v3 = CFSTR("105");
  else
    v3 = CFSTR("106");
  v4 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v3, 0);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v4);
  CFDictionarySetValue(MutableCopy, CFSTR("drve"), (const void *)*MEMORY[0x1E0C9AE40]);
  if (v4)
    CFRelease(v4);
  return MutableCopy;
}

uint64_t SecCurve25519PublicKeyCopyKeyDescription(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t AlgorithmId;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t);
  BOOL v9;
  const char *v10;

  v2 = *(void **)(a1 + 16);
  v3 = (void *)MEMORY[0x1E0CB3940];
  AlgorithmId = SecKeyGetAlgorithmId(a1);
  v5 = *(unsigned int **)(a1 + 16);
  v6 = *((_QWORD *)v5 + 1);
  v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  v8 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 80);
  if (v8)
    v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  v9 = v2 == &kSecEd25519PrivateKeyDescriptor || v2 == &kSecEd25519PublicKeyDescriptor;
  v10 = "kSecX25519";
  if (v9)
    v10 = "kSecEd25519";
  objc_msgSend(v3, "stringWithFormat:", CFSTR("<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>"), v10, AlgorithmId, v6, v7, v8, a1);
  return objc_claimAutoreleasedReturnValue();
}

uint64_t SecCurve25519KeyGetAlgorithmID(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd25519PrivateKeyDescriptor || v1 == &kSecEd25519PublicKeyDescriptor)
    return 4;
  else
    return 5;
}

uint64_t SecCurve25519PublicKeyCopyPublicOctets(_QWORD *a1, CFDataRef *a2)
{
  const UInt8 *v3;
  const __CFAllocator *v4;
  CFDataRef v5;

  v3 = (const UInt8 *)a1[3];
  v4 = CFGetAllocator(a1);
  v5 = CFDataCreate(v4, v3, 32);
  *a2 = v5;
  if (v5)
    return 0;
  else
    return 4294941021;
}

uint64_t SecCurve25519KeyCopyWrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  SecError(-4, a6, CFSTR("unsupported curve"));
  return 0;
}

CFDataRef SecCurve25519PublicKeyCopyExternalRepresentation(_QWORD *a1)
{
  const UInt8 *v1;
  const __CFAllocator *v2;

  v1 = (const UInt8 *)a1[3];
  v2 = CFGetAllocator(a1);
  return CFDataCreate(v2, v1, 32);
}

uint64_t SecCurve25519PublicKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, const __CFData *a7, __CFString **a8)
{
  void *v8;
  BOOL v9;
  uint64_t v14;
  CFIndex Length;
  uint64_t v17;

  v8 = *(void **)(a1 + 16);
  v9 = v8 == &kSecEd25519PublicKeyDescriptor || v8 == &kSecEd25519PrivateKeyDescriptor;
  if (!v9 || a2 != 1 || !CFEqual(cf1, CFSTR("algid:sign:EdDSA:message-Curve25519:SHA512")))
  {
    v14 = MEMORY[0x1E0C9B0D0];
    return *(_QWORD *)v14;
  }
  if (a5)
  {
LABEL_9:
    v14 = MEMORY[0x1E0C9AE50];
    return *(_QWORD *)v14;
  }
  Length = CFDataGetLength(a7);
  CFDataGetBytePtr(a7);
  CFDataGetLength(a6);
  CFDataGetBytePtr(a6);
  if (Length == 64)
  {
    ccsha512_di();
    v17 = cced25519_verify();
    if (!(_DWORD)v17)
      goto LABEL_9;
    SecError(-67808, a8, CFSTR("Ed25519 signature verification failed (ccerr %d)"), v17);
  }
  else
  {
    SecError(-67808, a8, CFSTR("Ed25519 signature verification failed (invalid signature length)"));
  }
  return 0;
}

uint64_t SecCurve25519PrivateKeyInit(uint64_t a1, _OWORD *a2, uint64_t a3, int a4)
{
  _OWORD *v4;
  uint64_t result;
  __int128 v6;
  void *v7;
  int v9;
  int v10;
  NSObject *v11;
  const char *v12;
  int key_pair;
  int v14;
  int v15;
  int v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v4 = *(_OWORD **)(a1 + 24);
  if (a4 != 5)
  {
    if (a4 != 7)
      return 4294899625;
    if (a3 == 32)
    {
      result = 0;
      v6 = a2[1];
      *v4 = *a2;
      v4[1] = v6;
      return result;
    }
    return 4294941021;
  }
  v17 = 0u;
  v18 = 0u;
  v7 = *(void **)(a1 + 16);
  if (v7 != &kSecEd25519PublicKeyDescriptor && v7 != &kSecEd25519PrivateKeyDescriptor)
  {
    ccrng();
    key_pair = cccurve25519_make_key_pair();
    if (!key_pair)
      goto LABEL_15;
    v14 = key_pair;
    _SECKEY_LOG_7721();
    v11 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
LABEL_18:

      return 4294941021;
    }
    v15 = 67109120;
    v16 = v14;
    v12 = "cccurve25519_make_key_pair() failed, error %d";
LABEL_21:
    _os_log_error_impl(&dword_18A900000, v11, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v15, 8u);
    goto LABEL_18;
  }
  ccsha512_di();
  ccrng();
  v9 = cced25519_make_key_pair();
  if (v9)
  {
    v10 = v9;
    _SECKEY_LOG_7721();
    v11 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      goto LABEL_18;
    v15 = 67109120;
    v16 = v10;
    v12 = "cced25519_make_key_pair() failed, error %d";
    goto LABEL_21;
  }
LABEL_15:
  cc_clear();
  return 0;
}

uint64_t SecCurve25519PrivateKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve25519PrivateKeyBlockSize()
{
  return 32;
}

CFDictionaryRef SecCurve25519PrivateKeyCopyAttributeDictionary(_QWORD *a1)
{
  const UInt8 *v2;
  const __CFAllocator *v3;
  const __CFData *v4;
  void *v5;
  const __CFString *v7;
  CFDictionaryRef v8;

  v2 = (const UInt8 *)a1[3];
  v3 = CFGetAllocator(a1);
  v4 = CFDataCreate(v3, v2, 32);
  v5 = (void *)a1[2];
  if (v5 == &kSecEd25519PrivateKeyDescriptor || v5 == &kSecEd25519PublicKeyDescriptor)
    v7 = CFSTR("105");
  else
    v7 = CFSTR("106");
  v8 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v7, v4);
  if (v4)
    CFRelease(v4);
  return v8;
}

CFStringRef SecCurve25519PrivateKeyCopyKeyDescription(uint64_t a1)
{
  void *v2;
  const __CFAllocator *v3;
  uint64_t AlgorithmId;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t);
  BOOL v9;
  const char *v10;

  v2 = *(void **)(a1 + 16);
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  AlgorithmId = SecKeyGetAlgorithmId(a1);
  v5 = *(unsigned int **)(a1 + 16);
  v6 = *((_QWORD *)v5 + 1);
  v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  v8 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 80);
  if (v8)
    v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  v9 = v2 == &kSecEd25519PrivateKeyDescriptor || v2 == &kSecEd25519PublicKeyDescriptor;
  v10 = "kSecX25519";
  if (v9)
    v10 = "kSecEd25519";
  return CFStringCreateWithFormat(v3, 0, CFSTR("<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>"), v10, AlgorithmId, v6, v7, v8, a1);
}

uint64_t SecCurve25519PrivateKeyCopyPublicOctets(_QWORD *a1, CFDataRef *a2)
{
  void *v4;
  const __CFAllocator *v8;
  _OWORD v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  memset(v9, 0, sizeof(v9));
  v4 = (void *)a1[2];
  if (v4 != &kSecEd25519PublicKeyDescriptor && v4 != &kSecEd25519PrivateKeyDescriptor)
  {
    ccrng();
    if (!cccurve25519_make_pub_with_rng())
      goto LABEL_9;
    return 4294941020;
  }
  ccsha512_di();
  ccrng();
  if (cced25519_make_pub_with_rng())
    return 4294941020;
LABEL_9:
  v8 = CFGetAllocator(a1);
  *a2 = CFDataCreate(v8, (const UInt8 *)v9, 32);
  cc_clear();
  if (*a2)
    return 0;
  else
    return 4294941021;
}

uint64_t SecCurve25519KeyCopyUnwrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  SecError(-4, a6, CFSTR("unsupported curve"));
  return 0;
}

CFDataRef SecCurve25519PrivateKeyCopyExternalRepresentation(_QWORD *a1)
{
  const UInt8 *v1;
  const __CFAllocator *v2;

  v1 = (const UInt8 *)a1[3];
  v2 = CFGetAllocator(a1);
  return CFDataCreate(v2, v1, 32);
}

__CFData *SecCurve25519PrivateKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  __CFData *Mutable;
  void *v14;
  BOOL v15;
  uint64_t v16;
  void *v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v21;

  Mutable = (__CFData *)*MEMORY[0x1E0C9B0D0];
  if (a2 != 4)
  {
    if (a2)
      return Mutable;
    v14 = *(void **)(a1 + 16);
    v15 = v14 == &kSecEd25519PublicKeyDescriptor || v14 == &kSecEd25519PrivateKeyDescriptor;
    if (!v15 || !CFEqual(cf1, CFSTR("algid:sign:EdDSA:message-Curve25519:SHA512")))
      return Mutable;
    if (!a5)
    {
      ccsha512_di();
      ccrng();
      if (cced25519_make_pub_with_rng())
      {
        SecError(-2070, a8, CFSTR("%@: Failed to get public key from private key"), a1);
        return Mutable;
      }
      Mutable = CFDataCreateMutable(0, 0);
      CFDataSetLength(Mutable, 64);
      if (!Mutable)
      {
        SecError(-108, a8, CFSTR("%@: Failed to create buffer for a signature"), a1);
        return Mutable;
      }
      CFDataGetLength(a6);
      CFDataGetBytePtr(a6);
      CFDataGetMutableBytePtr(Mutable);
      ccsha512_di();
      ccrng();
      v16 = cced25519_sign_with_rng();
      cc_clear();
      if ((_DWORD)v16)
      {
        CFRelease(Mutable);
        SecError(-50, a8, CFSTR("%@: Ed25519 signing failed (ccerr %d)"), a1, v16, 0, 0, 0, 0);
        return 0;
      }
      return Mutable;
    }
    return (__CFData *)*MEMORY[0x1E0C9AE50];
  }
  v17 = *(void **)(a1 + 16);
  v18 = v17 == &kSecEd25519PublicKeyDescriptor || v17 == &kSecEd25519PrivateKeyDescriptor;
  if (v18 || !CFEqual(cf1, CFSTR("algid:keyexchange:ECDH")) && !CFEqual(cf1, CFSTR("algid:keyexchange:ECDHC")))
    return Mutable;
  if (a5)
    return (__CFData *)*MEMORY[0x1E0C9AE50];
  CFDataGetBytePtr(a6);
  if (CFDataGetLength(a6) == 32)
  {
    if (SecCFAllocatorZeroize_sOnce != -1)
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
    Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
    CFDataSetLength(Mutable, 32);
    ccrng();
    CFDataGetMutableBytePtr(Mutable);
    v19 = cccurve25519_with_rng();
    if ((_DWORD)v19)
    {
      v21 = v19;
      if (Mutable)
        CFRelease(Mutable);
      SecError(-50, a8, CFSTR("%@: X25519 DH failed (ccerr %d)"), a1, v21);
      return 0;
    }
    CFDataSetLength(Mutable, 32);
  }
  else
  {
    SecError(-50, a8, CFSTR("X25519priv sharedsecret: bad public key"));
  }
  return Mutable;
}

id _SECKEY_LOG_7721()
{
  if (_SECKEY_LOG_once_7724 != -1)
    dispatch_once(&_SECKEY_LOG_once_7724, &__block_literal_global_7725);
  return (id)_SECKEY_LOG_log_7726;
}

uint64_t curve25519KeyGeneratePair(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v8;
  void *v9;
  _QWORD *v10;
  const void *v11;
  void *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t result;

  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v8 = SecCFAllocatorZeroize_sAllocator;
  if (a4 == 4)
    v9 = &kSecEd25519PrivateKeyDescriptor;
  else
    v9 = &kSecX25519PrivateKeyDescriptor;
  v10 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)v9, a1, 0, 5);
  if (!v10)
    return 4294967246;
  v11 = v10;
  if (a4 == 4)
    v12 = &kSecEd25519PublicKeyDescriptor;
  else
    v12 = &kSecX25519PublicKeyDescriptor;
  v13 = SecKeyCreate(v8, (uint64_t)v12, v10[3], 32, 6);
  if (!v13)
  {
    v14 = 4294967246;
LABEL_18:
    CFRelease(v11);
    return v14;
  }
  if (a2)
  {
    *a2 = v13;
    v13 = 0;
  }
  if (a3)
  {
    *a3 = v11;
    v11 = 0;
  }
  if (v13)
    CFRelease(v13);
  v14 = 0;
  result = 0;
  if (v11)
    goto LABEL_18;
  return result;
}

CFDataRef SecGenerateCertificateRequestWithParameters(const __CFString ***a1, const __CFDictionary *a2, __SecKey *a3, __SecKey *a4)
{
  const __CFString ***v4;
  _DWORD *v8;
  _QWORD *v9;
  const __CFString **v10;
  unsigned int v11;
  unsigned int v12;
  const __CFString ***v13;
  uint64_t *v14;
  uint64_t v15;
  const __CFString **v16;
  NSObject *v17;
  CFDataRef v18;
  uint64_t v20;
  unsigned int v21;
  char *v22;
  _QWORD *v23;
  char *v24;
  _QWORD *v25;
  int v26;
  uint64_t v27;
  char *v28;
  const __CFString *v29;
  const __CFDictionary *v30;
  const __CFString **v31;
  const __CFString *v32;
  uint64_t v33;
  const __CFString **v34;
  NSObject *v35;
  __SecKey *v36;
  const __CFData *v37;
  const __CFData *v38;
  void *v39;
  NSObject *v40;
  char *v41;
  const __CFData *public_key;
  NSObject *v43;
  const void *Value;
  const __CFData *signature;
  NSObject *v46;
  NSObject *v47;
  CFErrorRef v48;
  NSObject *v49;
  NSObject *v50;
  NSObject *v51;
  __SecKey *cf;
  __SecKey *key;
  char *v54;
  _QWORD *v55;
  CFIndex v56;
  const UInt8 *v57;
  CFIndex v58;
  const UInt8 *v59;
  char v60;
  uint8_t buf[8];
  char *v62;
  _OWORD v63[2];
  void *v64[2];
  __int128 v65;
  DERSize v66[4];
  __int128 v67;
  CFErrorRef error;
  char v69;
  uint8_t v70[4];
  CFErrorRef v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v4 = a1;
  if (!*a1)
    return 0;
  v69 = 0;
  v8 = PORT_NewArena(1024);
  error = 0;
  if (!v8)
  {
    v17 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v17, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", buf, 2u);
    }
    return 0;
  }
  v9 = v8;
  cf = a3;
  v67 = 0u;
  v65 = 0u;
  memset(v66, 0, sizeof(v66));
  *(_OWORD *)v64 = 0u;
  memset(v63, 0, sizeof(v63));
  v60 = 0;
  *(_QWORD *)buf = 1;
  v62 = &v60;
  v10 = *v4;
  if (*v4)
  {
    v11 = 0;
    v12 = 0;
    v13 = v4;
    do
    {
      if (*v10)
      {
        v14 = (uint64_t *)(v10 + 3);
        do
        {
          ++v12;
          v15 = *v14;
          v14 += 3;
        }
        while (v15);
      }
      ++v12;
      ++v11;
      v16 = v13[1];
      ++v13;
      v10 = v16;
    }
    while (v16);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  key = a4;
  if (v12 <= 1)
    v20 = 1;
  else
    v20 = v12;
  if (v11 <= 1)
    v21 = 1;
  else
    v21 = v11;
  v22 = (char *)malloc_type_malloc(8 * (v20 + 4 * v20), 0x10100404675C823uLL);
  v23 = malloc_type_malloc(8 * v20, 0x2004093837F09uLL);
  v24 = (char *)malloc_type_malloc(8 * v21, 0x80040B8603338uLL);
  v25 = malloc_type_malloc(8 * (v11 + 1), 0x2004093837F09uLL);
  if (*v4)
  {
    v26 = 0;
    LODWORD(v27) = 0;
    v54 = v24;
    v55 = v25;
    while (1)
    {
      v28 = &v24[8 * v26];
      *(_QWORD *)v28 = &v23[v27];
      v25[v26] = v28;
      v29 = **v4;
      if (v29)
        break;
      v33 = v27;
LABEL_30:
      ++v26;
      LODWORD(v27) = v27 + 1;
      v23[v33] = 0;
      v34 = v4[1];
      ++v4;
      if (!v34)
        goto LABEL_36;
    }
    v30 = a2;
    v31 = *v4 + 3;
    while ((make_nss_atv((uint64_t)v9, v29, *(v31 - 1), *((unsigned __int8 *)v31 - 16), (uint64_t)&v22[40 * v27], (__CFString **)&error) & 1) != 0)
    {
      v23[v27] = &v22[40 * v27];
      v27 = (v27 + 1);
      v32 = *v31;
      v31 += 3;
      v29 = v32;
      if (!v32)
      {
        v33 = v27;
        v24 = v54;
        v25 = v55;
        a2 = v30;
        goto LABEL_30;
      }
    }
    v35 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v70 = 0;
      _os_log_impl(&dword_18A900000, v35, OS_LOG_TYPE_DEFAULT, "csr: failed to encode atv", v70, 2u);
    }
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v18 = 0;
    v24 = v54;
    v39 = v55;
    goto LABEL_55;
  }
  v26 = 0;
LABEL_36:
  v25[v26] = 0;
  v39 = v25;
  *(_QWORD *)&v63[0] = v25;
  if (!key || (v36 = SecKeyCopyPublicKey(key)) == 0)
  {
    v40 = secLogObjForScope("csr");
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)v70 = 0;
      _os_log_debug_impl(&dword_18A900000, v40, OS_LOG_TYPE_DEBUG, "unable to create public key from private, using input public key", v70, 2u);
    }
    v36 = cf;
    if (!cf)
    {
      v46 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v70 = 0;
        _os_log_impl(&dword_18A900000, v46, OS_LOG_TYPE_DEFAULT, "csr: failed to get public key", v70, 2u);
      }
      v36 = 0;
      v37 = 0;
      v38 = 0;
      v18 = 0;
      goto LABEL_55;
    }
    CFRetain(cf);
  }
  v41 = v24;
  public_key = make_public_key(v36, (uint64_t)v63 + 8, &v69, &error);
  if (!public_key)
  {
    v49 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v70 = 0;
      _os_log_impl(&dword_18A900000, v49, OS_LOG_TYPE_DEFAULT, "csr: failed to encode public key", v70, 2u);
    }
    v37 = 0;
    v38 = 0;
    goto LABEL_76;
  }
  v38 = public_key;
  *((_QWORD *)&v65 + 1) = nss_attributes_from_parameters_dict((uint64_t)v9, a2);
  SecCmsArraySortByDER(*((int8x16_t **)&v65 + 1), (uint64_t)&kSecAsn1AttributeTemplate, 0);
  v58 = 0;
  v59 = 0;
  if (!SEC_ASN1EncodeItem((uint64_t)v9, &v58, (uint64_t)buf, (uint64_t)&kSecAsn1CertRequestInfoTemplate))
  {
    v43 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v70 = 0;
      _os_log_impl(&dword_18A900000, v43, OS_LOG_TYPE_DEFAULT, "csr: failed to encode request info", v70, 2u);
    }
  }
  if (a2)
    Value = CFDictionaryGetValue(a2, (const void *)kSecCMSSignHashAlgorithm);
  else
    Value = 0;
  signature = make_signature(v59, v58, key, Value, v66, (__CFString **)&error);
  if (!signature)
  {
    v50 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v70 = 0;
      _os_log_impl(&dword_18A900000, v50, OS_LOG_TYPE_DEFAULT, "csr: failed to create CSR signature", v70, 2u);
    }
    v37 = 0;
    goto LABEL_76;
  }
  v37 = signature;
  *((_QWORD *)&v67 + 1) = CFDataGetBytePtr(signature);
  *(_QWORD *)&v67 = 8 * CFDataGetLength(v37);
  v56 = 0;
  v57 = 0;
  if (!SEC_ASN1EncodeItem((uint64_t)v9, &v56, (uint64_t)buf, (uint64_t)&kSecAsn1CertRequestTemplate))
  {
    v51 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v70 = 0;
      _os_log_impl(&dword_18A900000, v51, OS_LOG_TYPE_DEFAULT, "csr: failed to encode cert request", v70, 2u);
    }
LABEL_76:
    v18 = 0;
    v24 = v41;
    goto LABEL_55;
  }
  v24 = v41;
  v18 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v57, v56);
LABEL_55:
  if (v69)
    free(v64[0]);
  PORT_FreeArena(v9, 1);
  if (v36)
    CFRelease(v36);
  if (v38)
    CFRelease(v38);
  if (v37)
    CFRelease(v37);
  free(v22);
  free(v23);
  free(v24);
  free(v39);
  if (error)
  {
    v47 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v70 = 138412290;
      v71 = error;
      _os_log_impl(&dword_18A900000, v47, OS_LOG_TYPE_DEFAULT, "csr: cert request encoding failed: %@", v70, 0xCu);
    }
    v48 = error;
    if (error)
    {
      error = 0;
      CFRelease(v48);
    }
  }
  return v18;
}

uint64_t make_nss_atv(uint64_t a1, const __CFString *a2, const __CFString *cf, int a4, uint64_t a5, __CFString **a6)
{
  CFTypeID v12;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  char *v15;
  char v16;
  CFTypeID v17;
  char v18;
  int v19;
  CFTypeID v20;
  size_t v21;
  CFTypeID v22;
  const UInt8 *BytePtr;
  CFTypeID v24;
  const DERItem *v25;
  CFTypeID v26;
  CFIndex v27;
  uint64_t data;
  uint64_t result;
  CFIndex v30;

  v12 = CFGetTypeID(cf);
  if (v12 == CFStringGetTypeID())
  {
    Length = CFStringGetLength(cf);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    v15 = (char *)PORT_ArenaAlloc(a1, MaximumSizeForEncoding);
    if (!CFStringGetCString(cf, v15, MaximumSizeForEncoding, 0x600u))
    {
      if (!CFStringGetCString(cf, v15, MaximumSizeForEncoding, 0x8000100u))
      {
        SecError(-50, a6, CFSTR("ATV value is not a Printable or UTF8 string"));
        return 0;
      }
      v16 = 12;
      if (a4 && a4 != 12)
      {
        SecError(-50, a6, CFSTR("ATV input type does not match value encoding"));
        return 0;
      }
      goto LABEL_26;
    }
    if (a4 != 19)
    {
      v16 = a4;
      if (a4)
      {
LABEL_26:
        v21 = strlen(v15);
        LOBYTE(a4) = v16;
        goto LABEL_27;
      }
    }
    if (!a2)
      goto LABEL_22;
    v17 = CFGetTypeID(a2);
    if (v17 == CFStringGetTypeID())
    {
      if (!CFEqual(CFSTR("1.2.840.113549.1.9.1"), a2) && CFStringCompare(CFSTR("EMAIL"), a2, 1uLL))
      {
LABEL_22:
        v19 = 0;
        v18 = 19;
LABEL_23:
        if (printable_string(cf, v19))
          v16 = v18;
        else
          v16 = 12;
        goto LABEL_26;
      }
    }
    else
    {
      v22 = CFGetTypeID(a2);
      if (v22 != CFDataGetTypeID())
        goto LABEL_22;
      if (CFDataGetLength((CFDataRef)a2) != 9)
        goto LABEL_22;
      BytePtr = CFDataGetBytePtr((CFDataRef)a2);
      if (memcmp(BytePtr, &_oidEmailAddress, 9uLL))
        goto LABEL_22;
    }
    v18 = 22;
    v19 = 1;
    goto LABEL_23;
  }
  v20 = CFGetTypeID(cf);
  if (v20 != CFDataGetTypeID())
  {
    SecError(-50, a6, CFSTR("ATV value of unsupported type"));
    return 0;
  }
  v21 = CFDataGetLength((CFDataRef)cf);
  v15 = (char *)CFDataGetBytePtr((CFDataRef)cf);
LABEL_27:
  v30 = 0;
  v24 = CFGetTypeID(a2);
  if (v24 == CFStringGetTypeID())
  {
    if (CFEqual(CFSTR("CN"), a2))
    {
      v25 = &oidCommonName;
LABEL_46:
      data = (uint64_t)v25->data;
      v27 = v25->length;
      goto LABEL_47;
    }
    if (CFEqual(CFSTR("C"), a2))
    {
      v25 = &oidCountryName;
      goto LABEL_46;
    }
    if (CFEqual(CFSTR("ST"), a2))
    {
      v25 = &oidStateOrProvinceName;
      goto LABEL_46;
    }
    if (CFEqual(CFSTR("L"), a2))
    {
      v25 = &oidLocalityName;
      goto LABEL_46;
    }
    if (CFEqual(CFSTR("O"), a2))
    {
      v25 = &oidOrganizationName;
      goto LABEL_46;
    }
    if (CFEqual(CFSTR("OU"), a2))
    {
      v25 = &oidOrganizationalUnitName;
      goto LABEL_46;
    }
    if (CFEqual(CFSTR("EMAIL"), a2))
    {
      v25 = &oidEmailAddress;
      goto LABEL_46;
    }
    data = oid_der_data(a1, a2, &v30);
    if (data)
    {
      v27 = v30;
      goto LABEL_47;
    }
    SecError(-26276, a6, CFSTR("ATV OID encode failed for %@"), a2);
    return 0;
  }
  v26 = CFGetTypeID(a2);
  if (v26 != CFDataGetTypeID())
  {
    SecError(-50, a6, CFSTR("ATV OID of unsupported type"));
    return 0;
  }
  v27 = CFDataGetLength((CFDataRef)a2);
  data = (uint64_t)CFDataGetBytePtr((CFDataRef)a2);
LABEL_47:
  *(_QWORD *)a5 = v27;
  *(_QWORD *)(a5 + 8) = data;
  *(_QWORD *)(a5 + 16) = v21;
  *(_QWORD *)(a5 + 24) = v15;
  *(_BYTE *)(a5 + 32) = a4;
  *(_DWORD *)(a5 + 33) = -1431655766;
  result = 1;
  *(_DWORD *)(a5 + 36) = -1431655766;
  return result;
}

const __CFData *make_public_key(__SecKey *a1, uint64_t a2, char *a3, CFErrorRef *error)
{
  const __CFData *v8;
  char v9;
  int NamedCurve;
  const DERItem *v11;
  size_t v12;
  uint64_t v13;
  size_t v14;
  malloc_type_id_t v15;
  _BYTE *v16;

  if (!a1)
    return 0;
  v8 = SecKeyCopyExternalRepresentation(a1, error);
  if (v8)
  {
    if (SecKeyGetAlgorithmId((uint64_t)a1) == 1)
    {
      v9 = 0;
      *(_QWORD *)a2 = 9;
      *(_QWORD *)(a2 + 8) = &_oidRsa;
      *(_OWORD *)(a2 + 16) = asn1_null;
LABEL_14:
      *a3 = v9;
      *(_QWORD *)(a2 + 40) = CFDataGetBytePtr(v8);
      *(_QWORD *)(a2 + 32) = 8 * CFDataGetLength(v8);
      return v8;
    }
    if (SecKeyGetAlgorithmId((uint64_t)a1) == 3)
    {
      *(_QWORD *)a2 = 7;
      *(_QWORD *)(a2 + 8) = &_oidEcPubKey;
      NamedCurve = SecECKeyGetNamedCurve(a1);
      switch(NamedCurve)
      {
        case 25:
          v11 = &oidAnsip521r1;
          v12 = 5;
          v13 = 7;
          v14 = 7;
          v15 = 3543760140;
          goto LABEL_13;
        case 24:
          v11 = &oidAnsip384r1;
          v12 = 5;
          v13 = 7;
          v14 = 7;
          v15 = 2957968736;
          goto LABEL_13;
        case 23:
          v11 = &oidEcPrime256v1;
          v12 = 8;
          v13 = 10;
          v14 = 10;
          v15 = 26031547;
LABEL_13:
          v16 = malloc_type_malloc(v14, v15);
          memcpy(v16 + 2, v11->data, v12);
          *v16 = 6;
          v16[1] = v13 - 2;
          *(_QWORD *)(a2 + 16) = v13;
          *(_QWORD *)(a2 + 24) = v16;
          v9 = 1;
          goto LABEL_14;
      }
      SecError(-4, (__CFString **)error, CFSTR("unsupported EC curve"));
    }
    else
    {
      SecError(-4, (__CFString **)error, CFSTR("unsupported key algorithmId"));
    }
    CFRelease(v8);
    return 0;
  }
  return v8;
}

_QWORD *nss_attributes_from_parameters_dict(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFString *Value;
  const __CFString *v5;
  CFIndex Length;
  unint64_t MaximumSizeForEncoding;
  CFIndex v8;
  unint64_t v9;
  char *v10;
  char *v11;
  const SecAsn1Template *v12;
  uint64_t v13;
  void *v14;
  _QWORD *v15;
  unsigned int v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  NSObject *v24;
  const char *v25;
  unint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  unint64_t v29;
  char *v30;
  char *v31;
  uint64_t *v32;
  uint64_t *v33;
  uint8_t *v34;
  uint64_t v36;
  void *v37;
  uint8_t buf[2];
  _QWORD v39[2];

  if (!theDict)
    return 0;
  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("csrChallengePassword"));
  v5 = Value;
  if (Value)
  {
    Length = CFStringGetLength(Value);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    v8 = MaximumSizeForEncoding;
    if (MaximumSizeForEncoding <= 1)
      v9 = 1;
    else
      v9 = MaximumSizeForEncoding;
    v10 = (char *)PORT_ArenaAlloc(a1, v9);
    v11 = v10;
    if (v10)
      bzero(v10, v9);
    if (CFStringGetCString(v5, v11, v8, 0x600u))
    {
      if (printable_string(v5, 0))
        v12 = kSecAsn1PrintableStringTemplate;
      else
        v12 = kSecAsn1UTF8StringTemplate;
    }
    else
    {
      if (!CFStringGetCString(v5, v11, v8, 0x8000100u))
      {
        v24 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v39[0]) = 0;
          v25 = "csr: unable to get challenge bytes";
          v34 = (uint8_t *)v39;
LABEL_51:
          _os_log_impl(&dword_18A900000, v24, OS_LOG_TYPE_DEFAULT, v25, v34, 2u);
          return 0;
        }
        return 0;
      }
      v12 = kSecAsn1UTF8StringTemplate;
    }
    v17 = (_QWORD *)PORT_ArenaAlloc(a1, 0x10uLL);
    v18 = v17;
    if (v17)
    {
      *v17 = 0;
      v17[1] = 0;
    }
    v39[0] = strlen(v11);
    v39[1] = v11;
    if (!SEC_ASN1EncodeItem(a1, v18, (uint64_t)v39, (uint64_t)v12))
    {
      v24 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        return 0;
      *(_WORD *)buf = 0;
      v25 = "csr: failed to encode challenge";
      goto LABEL_50;
    }
    v19 = (_QWORD *)PORT_ArenaAlloc(a1, 0x10uLL);
    v15 = v19;
    if (v19)
      v19[1] = 0;
    *v19 = v18;
    v16 = 1;
    v14 = &pkcs9ChallengePassword_7803;
    v13 = 9;
  }
  else
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
  }
  v39[0] = 0;
  if ((extensions_from_parameters(a1, theDict, v39, 0) & 1) == 0)
  {
    v24 = secLogObjForScope("SecError");
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      return 0;
    *(_WORD *)buf = 0;
    v25 = "csr: failed to encode extensions";
LABEL_50:
    v34 = buf;
    goto LABEL_51;
  }
  v20 = v39[0];
  if (!v39[0])
  {
    v36 = 0;
    v37 = 0;
    v23 = 0;
    goto LABEL_32;
  }
  v21 = (_QWORD *)PORT_ArenaAlloc(a1, 0x10uLL);
  v22 = v21;
  if (v21)
  {
    *v21 = 0;
    v21[1] = 0;
  }
  if (!SEC_ASN1EncodeItem(a1, v21, (uint64_t)v39, (uint64_t)&kSecAsn1SequenceOfCertExtensionTemplate))
  {
    v24 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v25 = "csr: failed to encode extension attributes";
      goto LABEL_50;
    }
    return 0;
  }
  v23 = (_QWORD *)PORT_ArenaAlloc(a1, 0x10uLL);
  *v23 = v22;
  v23[1] = 0;
  ++v16;
  v36 = 9;
  v37 = &pkcs9ExtensionsRequested;
LABEL_32:
  if (8 * (unint64_t)(v16 + 1) <= 1)
    v26 = 1;
  else
    v26 = 8 * (v16 + 1);
  v27 = (_QWORD *)PORT_ArenaAlloc(a1, v26);
  v28 = v27;
  if (v27)
    bzero(v27, v26);
  if (24 * (unint64_t)v16 <= 1)
    v29 = 1;
  else
    v29 = 24 * v16;
  v30 = (char *)PORT_ArenaAlloc(a1, v29);
  v31 = v30;
  if (v30)
    bzero(v30, v29);
  if (v5)
  {
    v32 = (uint64_t *)&v31[24 * --v16];
    *v32 = v13;
    v32[1] = (uint64_t)v14;
    v32[2] = (uint64_t)v15;
    v28[v16] = v32;
  }
  if (v20)
  {
    v33 = (uint64_t *)&v31[24 * v16 - 24];
    *v33 = v36;
    v33[1] = (uint64_t)v37;
    v33[2] = (uint64_t)v23;
    v28[v16 - 1] = v33;
  }
  return v28;
}

CFDataRef make_signature(const UInt8 *a1, CFIndex a2, __SecKey *a3, const void *a4, DERSize *a5, __CFString **a6)
{
  uint64_t AlgorithmId;
  const DERItem *v13;
  const SecKeyAlgorithm *v14;
  const __CFString *v15;
  DERByte *v16;
  const DERItem *v17;
  CFDataRef Signature;
  const __CFData *v19;
  const DERItem *v20;
  const SecKeyAlgorithm *v21;
  DERByte *data;
  const DERItem *v23;

  AlgorithmId = SecKeyGetAlgorithmId((uint64_t)a3);
  if (AlgorithmId == 3)
  {
    if (!a4 || kSecCMSHashingAlgorithmSHA256 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA256))
    {
      v20 = &oidSha256Ecdsa;
      v21 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA256;
    }
    else if (kSecCMSHashingAlgorithmSHA384 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA384))
    {
      v20 = &oidSha384Ecdsa;
      v21 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA384;
    }
    else
    {
      if (!kSecCMSHashingAlgorithmSHA512 || !CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA512))
      {
        v15 = 0;
LABEL_18:
        a5[2] = 0;
        a5[3] = 0;
        if (v15)
          goto LABEL_9;
LABEL_19:
        SecError(-4, a6, CFSTR("unsupported key or hashing algorithm"));
        return 0;
      }
      v20 = &oidSha512Ecdsa;
      v21 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA512;
    }
    v15 = *v21;
    v23 = v20;
    data = v20->data;
    *a5 = v23->length;
    a5[1] = (DERSize)data;
    goto LABEL_18;
  }
  if (AlgorithmId != 1)
    goto LABEL_19;
  if (!a4 || kSecCMSHashingAlgorithmSHA1 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA1))
  {
    v13 = &oidSha1Rsa;
    v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA1;
LABEL_7:
    v15 = *v14;
    v17 = v13;
    v16 = v13->data;
    *a5 = v17->length;
    a5[1] = (DERSize)v16;
    goto LABEL_8;
  }
  if (kSecCMSHashingAlgorithmSHA256 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA256))
  {
    v13 = &oidSha256Rsa;
    v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA256;
    goto LABEL_7;
  }
  if (kSecCMSHashingAlgorithmSHA384 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA384))
  {
    v13 = &oidSha384Rsa;
    v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA384;
    goto LABEL_7;
  }
  if (kSecCMSHashingAlgorithmSHA512 && CFEqual(a4, (CFTypeRef)kSecCMSHashingAlgorithmSHA512))
  {
    v13 = &oidSha512Rsa;
    v14 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA512;
    goto LABEL_7;
  }
  v15 = 0;
LABEL_8:
  *((_OWORD *)a5 + 1) = asn1_null;
  if (!v15)
    goto LABEL_19;
LABEL_9:
  Signature = 0;
  if (a1)
  {
    if (a2)
    {
      v19 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, a2, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
      Signature = SecKeyCreateSignature(a3, v15, v19, (CFErrorRef *)a6);
      if (v19)
        CFRelease(v19);
    }
  }
  return Signature;
}

uint64_t printable_string(const __CFString *a1, int a2)
{
  uint64_t v2;
  const __CFAllocator *v4;
  const __CFCharacterSet *v5;
  const __CFCharacterSet *InvertedSet;
  const __CFCharacterSet *v7;
  CFRange v9;
  CFRange v10;

  LODWORD(v2) = a2;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = CFCharacterSetCreateWithCharactersInString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 '()+,-./:=?@"));
  InvertedSet = CFCharacterSetCreateInvertedSet(v4, v5);
  v7 = CFCharacterSetCreateWithCharactersInString(v4, CFSTR("@"));
  v9.length = CFStringGetLength(a1);
  v9.location = 0;
  if (CFStringFindCharacterFromSet(a1, InvertedSet, v9, 0, 0))
  {
    v2 = 0;
    if (!v5)
      goto LABEL_4;
    goto LABEL_3;
  }
  v10.length = CFStringGetLength(a1);
  v10.location = 0;
  if (CFStringFindCharacterFromSet(a1, v7, v10, 0, 0))
    v2 = v2;
  else
    v2 = 1;
  if (v5)
LABEL_3:
    CFRelease(v5);
LABEL_4:
  if (InvertedSet)
    CFRelease(InvertedSet);
  if (v7)
    CFRelease(v7);
  return v2;
}

uint64_t extensions_from_parameters(uint64_t a1, const __CFDictionary *a2, _QWORD *a3, __CFString **a4)
{
  uint64_t v8;
  _QWORD *v9;
  _OWORD *v10;
  _QWORD *v11;
  unint64_t Value;
  const __CFNumber *v13;
  __int128 *v15;
  unsigned int v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  CFTypeID v19;
  unint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  const __CFArray *v27;
  const __CFArray *v28;
  CFTypeID v29;
  CFIndex Count;
  uint64_t v31;
  unint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  CFIndex v35;
  unsigned int v36;
  const __CFString *ValueAtIndex;
  const __CFString *v38;
  CFTypeID v39;
  const __CFArray *OidDataFromString;
  const __CFData *v41;
  CFIndex Length;
  void *v43;
  const UInt8 *BytePtr;
  CFIndex v45;
  _QWORD *v47;
  const __CFNumber *v48;
  const __CFNumber *v49;
  CFTypeID v50;
  unsigned int v51;
  uint64_t v52;
  int v53;
  unsigned int v54;
  unsigned int i;
  _QWORD *v56;
  unsigned int v57;
  const __CFDictionary *v58;
  const __CFDictionary *v59;
  CFTypeID v60;
  const __CFDictionary *v61;
  const __CFDictionary *v62;
  CFTypeID v63;
  uint64_t v64;
  _QWORD *v65;
  _QWORD *v66;
  uint64_t v67;
  _QWORD *v68;
  const __CFString *v70;
  int v71;
  NSObject *v72;
  __CFString *v73;
  __CFString *v74;
  NSObject *v75;
  unsigned int v76;
  _QWORD *v77;
  __CFString **v78;
  const __CFDictionary *theDict;
  __int128 v80;
  CFTypeRef cf;
  _QWORD *v82;
  __int128 valuePtr;
  __int128 context;
  uint64_t v85;
  __CFString **v86;
  __CFString **v87;
  uint64_t v88;

  v88 = *MEMORY[0x1E0C80C00];
  v8 = PORT_ArenaAlloc(a1, 0x58uLL);
  v9 = (_QWORD *)v8;
  if (v8)
  {
    *(_QWORD *)(v8 + 80) = 0;
    *(_OWORD *)(v8 + 48) = 0u;
    *(_OWORD *)(v8 + 64) = 0u;
    *(_OWORD *)(v8 + 16) = 0u;
    *(_OWORD *)(v8 + 32) = 0u;
    *(_OWORD *)v8 = 0u;
  }
  v10 = (_OWORD *)PORT_ArenaAlloc(a1, 0x1E0uLL);
  v11 = v10;
  if (v10)
  {
    v10[28] = 0u;
    v10[29] = 0u;
    v10[26] = 0u;
    v10[27] = 0u;
    v10[24] = 0u;
    v10[25] = 0u;
    v10[22] = 0u;
    v10[23] = 0u;
    v10[20] = 0u;
    v10[21] = 0u;
    v10[18] = 0u;
    v10[19] = 0u;
    v10[16] = 0u;
    v10[17] = 0u;
    v10[14] = 0u;
    v10[15] = 0u;
    v10[12] = 0u;
    v10[13] = 0u;
    v10[10] = 0u;
    v10[11] = 0u;
    v10[8] = 0u;
    v10[9] = 0u;
    v10[6] = 0u;
    v10[7] = 0u;
    v10[4] = 0u;
    v10[5] = 0u;
    v10[2] = 0u;
    v10[3] = 0u;
    *v10 = 0u;
    v10[1] = 0u;
  }
  cf = 0;
  Value = (unint64_t)CFDictionaryGetValue(a2, CFSTR("basicConstraintsCA"));
  v13 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("basicConstraints"));
  if (Value | (unint64_t)v13)
  {
    if (Value == *MEMORY[0x1E0C9AE40] && v13 != 0)
    {
      SecError(-50, (__CFString **)&cf, CFSTR("non-CA cert does not support path len"));
LABEL_83:
      if (cf)
      {
        v72 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(context) = 138412290;
          *(_QWORD *)((char *)&context + 4) = cf;
          _os_log_impl(&dword_18A900000, v72, OS_LOG_TYPE_DEFAULT, "csr: extension encoding failed: %@", (uint8_t *)&context, 0xCu);
        }
        v73 = (__CFString *)cf;
        if (a4)
        {
          if (cf)
          {
            CFRetain(cf);
            v74 = (__CFString *)cf;
          }
          else
          {
            v74 = 0;
          }
          *a4 = v73;
          v73 = v74;
        }
        if (v73)
        {
          cf = 0;
          CFRelease(v73);
        }
      }
      return 0;
    }
    if (Value == *MEMORY[0x1E0C9AE40])
      v15 = &asn1_false;
    else
      v15 = &asn1_true;
    context = *v15;
    v85 = 0;
    v86 = 0;
    LOBYTE(v82) = -86;
    if (v13)
    {
      LODWORD(valuePtr) = 0;
      if (!CFNumberGetValue(v13, kCFNumberIntType, &valuePtr))
      {
        SecError(-50, (__CFString **)&cf, CFSTR("failed to get basic constraints path length value"));
        goto LABEL_83;
      }
      if (valuePtr <= 0xFF)
      {
        LOBYTE(v82) = valuePtr;
        v85 = 1;
        v86 = (__CFString **)&v82;
      }
    }
    *v11 = 3;
    v11[1] = &_oidBasicConstraints;
    *((_OWORD *)v11 + 1) = asn1_true;
    if (!SEC_ASN1EncodeItem(a1, v11 + 4, (uint64_t)&context, (uint64_t)&kSecAsn1BasicConstraintsTemplate))
    {
      SecError(-50, (__CFString **)&cf, CFSTR("failed to encode basic constraints extension"));
      goto LABEL_83;
    }
    v16 = 1;
  }
  else
  {
    v16 = 0;
  }
  v17 = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("subjectAltName"));
  if (v17)
  {
    v18 = v17;
    v19 = CFGetTypeID(v17);
    if (v19 != CFDictionaryGetTypeID())
    {
      SecError(-50, (__CFString **)&cf, CFSTR("wrong value type for subjectAltName"));
      goto LABEL_83;
    }
    valuePtr = 0uLL;
    context = (unint64_t)a1;
    v85 = 0;
    v86 = a4;
    CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)make_general_names, &context);
    if (8 * (unint64_t)(v85 + 1) <= 1)
      v20 = 1;
    else
      v20 = 8 * (v85 + 1);
    v21 = (_QWORD *)PORT_ArenaAlloc(a1, v20);
    v22 = v21;
    if (v21)
      bzero(v21, v20);
    v23 = &v11[6 * v16];
    if ((_DWORD)v85)
    {
      v24 = 0;
      v25 = 16 * v85;
      v26 = v22;
      do
      {
        *v26++ = *((_QWORD *)&context + 1) + v24;
        v24 += 16;
      }
      while (v25 != v24);
    }
    v82 = v22;
    if (!SEC_ASN1EncodeItem(a1, &valuePtr, (uint64_t)&v82, (uint64_t)kSecAsn1SequenceOfAnyTemplate))
      SecError(-26276, a4, CFSTR("failed to encode SubjectAltName"));
    *((_OWORD *)v23 + 2) = valuePtr;
    *v23 = 3;
    v23[1] = &_oidSubjectAltName;
    ++v16;
  }
  theDict = a2;
  v27 = (const __CFArray *)CFDictionaryGetValue(a2, CFSTR("certificateEKUs"));
  if (v27)
  {
    v28 = v27;
    v29 = CFGetTypeID(v27);
    if (v29 != CFArrayGetTypeID())
    {
      SecError(-50, (__CFString **)&cf, CFSTR("wrong value type for EKU"));
      goto LABEL_83;
    }
    v76 = v16;
    v77 = a3;
    v78 = a4;
    context = 0uLL;
    Count = CFArrayGetCount(v28);
    v31 = Count;
    if ((unint64_t)(8 * Count + 8) <= 1)
      v32 = 1;
    else
      v32 = 8 * Count + 8;
    v33 = (_QWORD *)PORT_ArenaAlloc(a1, v32);
    v34 = v33;
    if (v33)
      bzero(v33, v32);
    if (v31 >= 1)
    {
      v35 = 0;
      v36 = 1;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v28, v35);
        if (!ValueAtIndex
          || (v38 = ValueAtIndex, v39 = CFGetTypeID(ValueAtIndex), v39 != CFStringGetTypeID())
          || !SecCertificateIsOidString(v38))
        {
          v70 = CFSTR("eku is not an OID");
          goto LABEL_80;
        }
        OidDataFromString = SecCertificateCreateOidDataFromString(0, v38);
        if (!OidDataFromString)
          break;
        v41 = OidDataFromString;
        v34[v35] = PORT_ArenaAlloc(a1, 0x10uLL);
        *(_QWORD *)v34[v35] = CFDataGetLength(v41);
        Length = CFDataGetLength(v41);
        *(_QWORD *)(v34[v35] + 8) = PORT_ArenaAlloc(a1, Length);
        v43 = *(void **)(v34[v35] + 8);
        BytePtr = CFDataGetBytePtr(v41);
        v45 = CFDataGetLength(v41);
        memcpy(v43, BytePtr, v45);
        CFRelease(v41);
        v35 = v36;
        if (v31 <= v36++)
          goto LABEL_49;
      }
      v70 = CFSTR("failed to create EKU data");
LABEL_80:
      v71 = -50;
      goto LABEL_81;
    }
LABEL_49:
    *(_QWORD *)&valuePtr = v34;
    if (!SEC_ASN1EncodeItem(a1, &context, (uint64_t)&valuePtr, (uint64_t)kSecAsn1SequenceOfObjectIDTemplate))
    {
      v70 = CFSTR("failed to encode EKUs");
      v71 = -26276;
LABEL_81:
      a4 = v78;
      SecError(v71, v78, v70);
      SecError(-50, (__CFString **)&cf, CFSTR("failed to make EKU extension"));
      goto LABEL_83;
    }
    *(_OWORD *)&v11[6 * v76 + 4] = context;
    v47 = &v11[6 * v76];
    *v47 = 3;
    v47[1] = &_oidExtendedKeyUsage;
    v16 = v76 + 1;
    a3 = v77;
    a4 = v78;
  }
  v48 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("keyUsage"));
  v80 = 0uLL;
  if (v48)
  {
    v49 = v48;
    v50 = CFGetTypeID(v48);
    if (v50 != CFNumberGetTypeID()
      || (LODWORD(valuePtr) = -1431655766, !CFNumberGetValue(v49, kCFNumberIntType, &valuePtr)))
    {
      SecError(-50, (__CFString **)&cf, CFSTR("failed to get key usage value"));
      goto LABEL_83;
    }
    v51 = valuePtr;
    if ((int)valuePtr >= 1)
    {
      LODWORD(v52) = 0;
      v53 = 0;
      v54 = 0x80000000;
      for (i = 1; i != 10; ++i)
      {
        v53 |= ((int)(v51 << 31) >> 31) & v54;
        if ((v51 & 1) != 0)
          v52 = i;
        else
          v52 = v52;
        v51 >>= 1;
        v54 >>= 1;
      }
      LODWORD(valuePtr) = v51;
      LODWORD(v82) = v53;
      *(_QWORD *)&context = v52;
      *((_QWORD *)&context + 1) = (char *)&v82 - (v52 >> 3) + 3;
      if (!SEC_ASN1EncodeItem(a1, &v80, (uint64_t)&context, (uint64_t)kSecAsn1BitStringTemplate))
      {
        SecError(-26276, (__CFString **)&cf, CFSTR("failed to encode keyUsage"));
        goto LABEL_83;
      }
      v56 = &v11[6 * v16];
      *v56 = 3;
      v56[1] = &_oidKeyUsage;
      *((_OWORD *)v56 + 1) = asn1_true;
      *((_OWORD *)v56 + 2) = v80;
      ++v16;
    }
  }
  v57 = v16;
  v58 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("certificateExtensions"));
  if (v58)
  {
    v59 = v58;
    v60 = CFGetTypeID(v58);
    if (v60 != CFDictionaryGetTypeID())
    {
      v75 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(context) = 0;
        _os_log_impl(&dword_18A900000, v75, OS_LOG_TYPE_DEFAULT, "csr: wrong value type for custom extensions", (uint8_t *)&context, 2u);
      }
      goto LABEL_83;
    }
    *(_QWORD *)&context = a1;
    *((_QWORD *)&context + 1) = v11;
    v85 = v16 | 0xA00000000;
    v86 = (__CFString **)0xAAAAAAAAAAAAAA01;
    v87 = a4;
    CFDictionaryApplyFunction(v59, (CFDictionaryApplierFunction)add_custom_extension, &context);
    v57 = v85;
  }
  v61 = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("certificateExtensionsEncoded"));
  if (v61)
  {
    v62 = v61;
    v63 = CFGetTypeID(v61);
    if (v63 != CFDictionaryGetTypeID())
    {
      SecError(-50, (__CFString **)&cf, CFSTR("wrong value type for custom extensions"));
      goto LABEL_83;
    }
    *(_QWORD *)&context = a1;
    *((_QWORD *)&context + 1) = v11;
    v85 = v57 | 0xA00000000;
    v86 = (__CFString **)0xAAAAAAAAAAAAAA00;
    v87 = a4;
    CFDictionaryApplyFunction(v62, (CFDictionaryApplierFunction)add_custom_extension, &context);
    v57 = v85;
  }
  if (v57)
  {
    v64 = v57;
    v65 = v9;
    v66 = v11;
    do
    {
      v67 = *v66;
      v66 += 6;
      if (v67)
        v68 = v11;
      else
        v68 = 0;
      *v65++ = v68;
      v11 = v66;
      --v64;
    }
    while (v64);
  }
  *a3 = v9;
  return 1;
}

void make_general_names(const __CFString *a1, const __CFString *cf, uint64_t a3)
{
  __CFString **v6;
  CFTypeID v7;
  CFIndex Count;
  const __CFString *v9;
  const __CFArray *v10;
  CFTypeID v11;
  CFTypeID v12;
  int v13;
  unsigned int v14;
  unint64_t v15;
  void *v16;
  void *v17;
  const void *v18;
  char v19;
  NSObject *v20;
  CFIndex v21;
  const __CFString *ValueAtIndex;
  CFTypeID v23;
  CFIndex v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  CFIndex v29;
  unint64_t v30;
  unint64_t v31;
  char *v32;
  char *v33;
  CFTypeID v34;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  char *v37;
  uint64_t v38;
  uint64_t *v39;
  size_t v40;
  char *v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int16 v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!cf)
    return;
  v6 = *(__CFString ***)(a3 + 24);
  v7 = CFGetTypeID(cf);
  if (v7 == CFArrayGetTypeID())
  {
    Count = CFArrayGetCount((CFArrayRef)cf);
    v9 = 0;
    v10 = (const __CFArray *)cf;
    if (!a1)
      return;
  }
  else
  {
    v11 = CFGetTypeID(cf);
    if (v11 != CFStringGetTypeID())
    {
      SecError(-50, v6, CFSTR("unsupported subjectAltName value type"));
      return;
    }
    v10 = 0;
    Count = 1;
    v9 = cf;
    if (!a1)
      return;
  }
  if (Count < 1)
    return;
  v12 = CFGetTypeID(a1);
  if (v12 != CFStringGetTypeID())
  {
    SecError(-50, v6, CFSTR("unsupported subjectAltName key type"));
    return;
  }
  if (*(_QWORD *)(a3 + 8))
  {
    v13 = *(_DWORD *)(a3 + 16);
    if (v13 != *(_DWORD *)(a3 + 20))
      goto LABEL_24;
  }
  else
  {
    v13 = *(_DWORD *)(a3 + 20);
  }
  if (v13)
    v14 = 2 * v13;
  else
    v14 = 10;
  if (16 * (unint64_t)v14 <= 1)
    v15 = 1;
  else
    v15 = 16 * v14;
  v16 = (void *)PORT_ArenaAlloc(*(_QWORD *)a3, v15);
  v17 = v16;
  if (v16)
    bzero(v16, v15);
  v18 = *(const void **)(a3 + 8);
  if (v18)
    memcpy(v17, v18, *(unsigned int *)(a3 + 20));
  *(_QWORD *)(a3 + 8) = v17;
  *(_DWORD *)(a3 + 20) = v14;
LABEL_24:
  v42 = xmmword_18AA5EF88;
  v43 = 255;
  if (CFStringCompare(CFSTR("dNSName"), a1, 1uLL))
  {
    v19 = 1;
    if (CFStringCompare(CFSTR("rfc822Name"), a1, 1uLL))
    {
      if (CFStringCompare(CFSTR("uniformResourceIdentifier"), a1, 1uLL))
      {
        if (CFStringCompare(CFSTR("ntPrincipalName"), a1, 1uLL))
        {
          v20 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v38) = 0;
            _os_log_impl(&dword_18A900000, v20, OS_LOG_TYPE_DEFAULT, "csr: unsupported SubjectAltName type, skipping", (uint8_t *)&v38, 2u);
          }
          return;
        }
        v45 = 770;
        v44 = 0x143782010401062BLL;
        if (!v9)
        {
          SecError(-50, v6, CFSTR("NTPrincipalName types do not allow multiple values"));
          return;
        }
        v34 = CFGetTypeID(v9);
        if (v34 == CFStringGetTypeID())
        {
          Length = CFStringGetLength(cf);
          MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
          v37 = (char *)PORT_ArenaAlloc(*(_QWORD *)a3, MaximumSizeForEncoding);
          if (!CFStringGetCString(cf, v37, MaximumSizeForEncoding, 0x8000100u))
          {
            SecError(-50, v6, CFSTR("failed to get NTPrincipalName value bytes"));
            return;
          }
          v38 = 10;
          v39 = &v44;
          v40 = strlen(v37);
          v41 = v37;
          if (!SEC_ASN1EncodeItem(*(_QWORD *)a3, (_QWORD *)(*(_QWORD *)(a3 + 8) + 16 * *(unsigned int *)(a3 + 16)), (uint64_t)&v38, (uint64_t)&my_other_name_template_cons))SecError(-26276, v6, CFSTR("failed to encode NTPrincipalName"), v38, v39);
LABEL_52:
          ++*(_DWORD *)(a3 + 16);
          return;
        }
        return;
      }
      v19 = 6;
    }
  }
  else
  {
    v19 = 2;
  }
  LOBYTE(v43) = v19;
  if (!v10)
  {
    if (!v9)
      return;
    v29 = CFStringGetLength(v9);
    v30 = CFStringGetMaximumSizeForEncoding(v29, 0x8000100u);
    if (v30 <= 1)
      v31 = 1;
    else
      v31 = v30;
    v32 = (char *)PORT_ArenaAlloc(*(_QWORD *)a3, v31);
    v33 = v32;
    if (v32)
      bzero(v32, v31);
    if (!CFStringGetCString(v9, v33, v30, 0x600u))
    {
      SecError(-50, v6, CFSTR("failed to get subjectAltName value bytes"));
      return;
    }
    *((_QWORD *)&v42 + 1) = v33;
    *(_QWORD *)&v42 = strlen(v33);
    SEC_ASN1EncodeItem(*(_QWORD *)a3, (_QWORD *)(*(_QWORD *)(a3 + 8) + 16 * *(unsigned int *)(a3 + 16)), (uint64_t)&v42, (uint64_t)&kSecAsn1GeneralNameTemplate);
    goto LABEL_52;
  }
  v21 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v10, v21);
    v23 = CFGetTypeID(ValueAtIndex);
    if (v23 != CFStringGetTypeID())
    {
      SecError(-50, v6, CFSTR("subjectAltName value is not a string"));
      return;
    }
    v24 = CFStringGetLength(ValueAtIndex);
    v25 = CFStringGetMaximumSizeForEncoding(v24, 0x8000100u);
    if (v25 <= 1)
      v26 = 1;
    else
      v26 = v25;
    v27 = (char *)PORT_ArenaAlloc(*(_QWORD *)a3, v26);
    v28 = v27;
    if (v27)
      bzero(v27, v26);
    if (!CFStringGetCString(ValueAtIndex, v28, v25, 0x600u))
      break;
    *((_QWORD *)&v42 + 1) = v28;
    *(_QWORD *)&v42 = strlen(v28);
    SEC_ASN1EncodeItem(*(_QWORD *)a3, (_QWORD *)(*(_QWORD *)(a3 + 8) + 16 * *(unsigned int *)(a3 + 16)), (uint64_t)&v42, (uint64_t)&kSecAsn1GeneralNameTemplate);
    ++*(_DWORD *)(a3 + 16);
    if (Count == ++v21)
      return;
  }
  SecError(-50, v6, CFSTR("failed to get subjectAltName value bytes"));
}

uint64_t add_custom_extension(CFStringRef theString, const __CFString *a2, uint64_t a3)
{
  __CFString **v3;
  uint64_t v6;
  CFTypeID v7;
  CFIndex Length;
  unint64_t MaximumSizeForEncoding;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t result;
  CFTypeID v14;
  unsigned int v15;
  unint64_t *v16;
  size_t v17;
  const UInt8 *BytePtr;
  __int128 v19;
  unint64_t v20;

  v3 = *(__CFString ***)(a3 + 32);
  if (*(_DWORD *)(a3 + 16) >= *(_DWORD *)(a3 + 20))
    return SecError(-50, v3, CFSTR("too many extensions"));
  v20 = 0xAAAAAAAAAAAAAAAALL;
  v6 = oid_der_data(*(_QWORD *)a3, theString, &v20);
  v19 = 0uLL;
  v7 = CFGetTypeID(a2);
  if (v7 == CFStringGetTypeID())
  {
    if (!*(_BYTE *)(a3 + 24))
      return SecError(-50, v3, CFSTR("encoded extensions must be a data type"));
    Length = CFStringGetLength(a2);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    if (MaximumSizeForEncoding <= 1)
      v10 = 1;
    else
      v10 = MaximumSizeForEncoding;
    v11 = (char *)PORT_ArenaAlloc(*(_QWORD *)a3, v10);
    v12 = v11;
    if (v11)
      bzero(v11, v10);
    if (!CFStringGetCString(a2, v12, MaximumSizeForEncoding, 0x8000100u))
      return SecError(-50, v3, CFSTR("failed to get custom extension string bytes"));
    v17 = strlen(v12);
    BytePtr = (const UInt8 *)v12;
    result = (uint64_t)SEC_ASN1EncodeItem(*(_QWORD *)a3, &v19, (uint64_t)&v17, (uint64_t)kSecAsn1UTF8StringTemplate);
    if (!result)
      result = SecError(-26276, v3, CFSTR("failed to encode extension string"));
  }
  else
  {
    v14 = CFGetTypeID(a2);
    if (v14 != CFDataGetTypeID())
      return SecError(-50, v3, CFSTR("unsupported custom extensions value type"));
    if (!*(_BYTE *)(a3 + 24))
    {
      *(_QWORD *)&v19 = CFDataGetLength((CFDataRef)a2);
      result = (uint64_t)CFDataGetBytePtr((CFDataRef)a2);
      *((_QWORD *)&v19 + 1) = result;
      if (!v6)
        return result;
      goto LABEL_17;
    }
    v17 = CFDataGetLength((CFDataRef)a2);
    BytePtr = CFDataGetBytePtr((CFDataRef)a2);
    result = (uint64_t)SEC_ASN1EncodeItem(*(_QWORD *)a3, &v19, (uint64_t)&v17, (uint64_t)kSecAsn1OctetStringTemplate);
    if (!result)
      result = SecError(-26276, v3, CFSTR("failed to encode extension data"));
  }
  if (!v6)
    return result;
LABEL_17:
  if ((_QWORD)v19)
  {
    *(_OWORD *)(*(_QWORD *)(a3 + 8) + 48 * *(unsigned int *)(a3 + 16) + 32) = v19;
    v15 = *(_DWORD *)(a3 + 16);
    v16 = (unint64_t *)(*(_QWORD *)(a3 + 8) + 48 * v15);
    *v16 = v20;
    v16[1] = v6;
    *(_DWORD *)(a3 + 16) = v15 + 1;
  }
  return result;
}

uint64_t oid_der_data(uint64_t a1, CFStringRef theString, _QWORD *a3)
{
  CFIndex Length;
  uint64_t v7;
  uint64_t v8;
  const __CFArray *ArrayBySeparatingStrings;
  CFIndex Count;
  _BYTE *v11;
  CFIndex v12;
  SInt32 v13;
  CFIndex v14;
  const __CFString *ValueAtIndex;
  SInt32 IntValue;
  SInt32 v17;
  unsigned int v18;

  if ((unint64_t)CFStringGetLength(theString) > 0x3FFFFFFFFFFFFFFELL)
    return 0;
  Length = CFStringGetLength(theString);
  v7 = ((unint64_t)(4 * Length) * (unsigned __int128)0x2492492492492493uLL) >> 64;
  v8 = PORT_ArenaAlloc(a1, ((v7 + ((unint64_t)(4 * Length - v7) >> 1)) >> 2) + 1);
  if (v8)
  {
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theString, CFSTR("."));
    Count = CFArrayGetCount(ArrayBySeparatingStrings);
    v11 = (_BYTE *)v8;
    if (Count >= 1)
    {
      v12 = Count;
      v13 = 0;
      v14 = 0;
      v11 = (_BYTE *)v8;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v14);
        IntValue = CFStringGetIntValue(ValueAtIndex);
        v17 = IntValue >= 0 ? IntValue : -IntValue;
        if (v17 == 0x7FFFFFFF)
          break;
        if (v14)
        {
          if (v14 == 1)
            v18 = IntValue + 40 * v13;
          else
            v18 = IntValue;
          v11 = mod128_oid_encoding_ptr(v11, v18, 1);
        }
        else
        {
          v13 = IntValue;
        }
        if (v12 == ++v14)
          goto LABEL_16;
      }
      if (ArrayBySeparatingStrings)
        CFRelease(ArrayBySeparatingStrings);
      return 0;
    }
LABEL_16:
    if (ArrayBySeparatingStrings)
      CFRelease(ArrayBySeparatingStrings);
    *a3 = &v11[-v8];
  }
  return v8;
}

_BYTE *mod128_oid_encoding_ptr(_BYTE *a1, unsigned int a2, int a3)
{
  char v4;
  char v5;

  v4 = a2;
  if (a2 >= 0x81)
    a1 = (_BYTE *)mod128_oid_encoding_ptr(a1, a2 >> 7, 0);
  if (a3)
    v5 = 0;
  else
    v5 = 0x80;
  *a1 = v5 & 0x80 | v4 & 0x7F;
  return a1 + 1;
}

CFDataRef SecGenerateCertificateRequest(const __CFArray *a1, const __CFDictionary *a2, void *a3, __SecKey *a4)
{
  _DWORD *v8;
  _QWORD *v9;
  __SecKey *v10;
  NSObject *v11;
  const __CFData *public_key;
  const __CFData *v13;
  NSObject *v14;
  const void *Value;
  NSObject *v16;
  CFDataRef v17;
  const __CFData *signature;
  const __CFData *v19;
  char v20;
  NSObject *v21;
  NSObject *v22;
  CFErrorRef v23;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  CFIndex v28;
  const UInt8 *v29;
  CFIndex v30;
  const UInt8 *v31;
  char v32;
  uint8_t v33[8];
  char *v34;
  _QWORD *subject;
  __int128 v36;
  void *v37[2];
  __int128 v38;
  _OWORD v39[2];
  __int128 v40;
  const UInt8 *BytePtr;
  CFErrorRef error;
  char v43;
  uint8_t buf[4];
  CFErrorRef v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v8 = PORT_NewArena(1024);
  v43 = 0;
  error = 0;
  if (v8)
  {
    v9 = v8;
    BytePtr = 0;
    v40 = 0u;
    memset(v39, 0, sizeof(v39));
    v38 = 0u;
    *(_OWORD *)v37 = 0u;
    v36 = 0u;
    v32 = 0;
    *(_QWORD *)v33 = 1;
    v34 = &v32;
    subject = make_subject((uint64_t)v8, a1, (__CFString **)&error);
    if (a4)
    {
      v10 = SecKeyCopyPublicKey(a4);
      if (v10)
      {
LABEL_7:
        public_key = make_public_key(v10, (uint64_t)&v36, &v43, &error);
        if (public_key)
        {
          v13 = public_key;
          *(_QWORD *)&v39[0] = nss_attributes_from_parameters_dict((uint64_t)v9, a2);
          SecCmsArraySortByDER(*(int8x16_t **)&v39[0], (uint64_t)&kSecAsn1AttributeTemplate, 0);
          v30 = 0;
          v31 = 0;
          if (!SEC_ASN1EncodeItem((uint64_t)v9, &v30, (uint64_t)v33, (uint64_t)&kSecAsn1CertRequestInfoTemplate))
          {
            v14 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEFAULT, "csr: failed to encode request info", buf, 2u);
            }
          }
          if (a2)
            Value = CFDictionaryGetValue(a2, (const void *)kSecCMSSignHashAlgorithm);
          else
            Value = 0;
          signature = make_signature(v31, v30, a4, Value, (DERSize *)v39 + 1, (__CFString **)&error);
          if (signature)
          {
            v19 = signature;
            BytePtr = CFDataGetBytePtr(signature);
            *((_QWORD *)&v40 + 1) = 8 * CFDataGetLength(v19);
            v28 = 0;
            v29 = 0;
            if (SEC_ASN1EncodeItem((uint64_t)v9, &v28, (uint64_t)v33, (uint64_t)&kSecAsn1CertRequestTemplate))
            {
              v17 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v29, v28);
              v20 = 0;
LABEL_24:
              if (v43)
                free(v37[1]);
              PORT_FreeArena(v9, 1);
              if ((v20 & 1) == 0)
                CFRelease(v10);
              if (v13)
                CFRelease(v13);
              if (v19)
                CFRelease(v19);
              if (error)
              {
                v22 = secLogObjForScope("SecError");
                if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 138412290;
                  v45 = error;
                  _os_log_impl(&dword_18A900000, v22, OS_LOG_TYPE_DEFAULT, "csr: cert request encoding failed: %@", buf, 0xCu);
                }
                v23 = error;
                if (error)
                {
                  error = 0;
                  CFRelease(v23);
                }
              }
              return v17;
            }
            v27 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18A900000, v27, OS_LOG_TYPE_DEFAULT, "csr: failed to encode cert request", buf, 2u);
            }
            v20 = 0;
          }
          else
          {
            v26 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_18A900000, v26, OS_LOG_TYPE_DEFAULT, "csr: failed to create CSR signature", buf, 2u);
            }
            v20 = 0;
            v19 = 0;
          }
        }
        else
        {
          v25 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_18A900000, v25, OS_LOG_TYPE_DEFAULT, "csr: failed to encode public key", buf, 2u);
          }
          v20 = 0;
          v19 = 0;
          v13 = 0;
        }
        v17 = 0;
        goto LABEL_24;
      }
    }
    v11 = secLogObjForScope("csr");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "unable to create public key from private, using input public key", buf, 2u);
      if (a3)
        goto LABEL_6;
    }
    else if (a3)
    {
LABEL_6:
      CFRetain(a3);
      v10 = (__SecKey *)a3;
      goto LABEL_7;
    }
    v21 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v21, OS_LOG_TYPE_DEFAULT, "csr: failed to get public key", buf, 2u);
    }
    v10 = 0;
    v19 = 0;
    v13 = 0;
    v17 = 0;
    v20 = 1;
    goto LABEL_24;
  }
  v16 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v33 = 0;
    _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", v33, 2u);
  }
  return 0;
}

_QWORD *make_subject(uint64_t a1, CFArrayRef theArray, __CFString **a3)
{
  const __CFArray *v4;
  CFIndex Count;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  char *v13;
  char *v14;
  CFIndex v15;
  char *v16;
  const __CFArray *ValueAtIndex;
  CFIndex v18;
  uint64_t v19;
  unint64_t v20;
  void *v21;
  void *v22;
  unint64_t v23;
  void *v24;
  uint64_t v25;
  CFIndex v26;
  const __CFArray *v27;
  const __CFString *v28;
  const __CFString *v29;
  char *v31;
  uint64_t v32;
  _QWORD *v33;
  const __CFArray *v34;

  if (!theArray)
    return 0;
  v4 = theArray;
  Count = CFArrayGetCount(theArray);
  v7 = Count;
  v8 = 8 * Count;
  if ((unint64_t)(8 * Count + 8) <= 1)
    v9 = 1;
  else
    v9 = 8 * Count + 8;
  v10 = (_QWORD *)PORT_ArenaAlloc(a1, v9);
  v11 = v10;
  if (v10)
    bzero(v10, v9);
  if (v8 <= 1)
    v12 = 1;
  else
    v12 = v8;
  v13 = (char *)PORT_ArenaAlloc(a1, v12);
  v14 = v13;
  if (v13)
    bzero(v13, v12);
  if (v7 >= 1)
  {
    v15 = 0;
    v33 = v11;
    v34 = v4;
    v31 = v14;
    v32 = v7;
    while (1)
    {
      v16 = &v14[8 * v15];
      v11[v15] = v16;
      ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v4, v15);
      v18 = CFArrayGetCount(ValueAtIndex);
      v19 = v18;
      if ((unint64_t)(8 * v18 + 8) <= 1)
        v20 = 1;
      else
        v20 = 8 * v18 + 8;
      v21 = (void *)PORT_ArenaAlloc(a1, v20);
      v22 = v21;
      if (v21)
        bzero(v21, v20);
      *(_QWORD *)v16 = v22;
      v23 = (unint64_t)(40 * v19) <= 1 ? 1 : 40 * v19;
      v24 = (void *)PORT_ArenaAlloc(a1, v23);
      v25 = (uint64_t)v24;
      if (v24)
        bzero(v24, v23);
      if (v19 >= 1)
        break;
LABEL_29:
      ++v15;
      v11 = v33;
      v4 = v34;
      v14 = v31;
      if (v15 == v32)
        return v11;
    }
    v26 = 0;
    while (1)
    {
      *(_QWORD *)(*(_QWORD *)v16 + 8 * v26) = v25;
      v27 = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, v26);
      if (CFArrayGetCount(v27) != 2)
        break;
      v28 = (const __CFString *)CFArrayGetValueAtIndex(v27, 0);
      v29 = (const __CFString *)CFArrayGetValueAtIndex(v27, 1);
      if ((make_nss_atv(a1, v28, v29, 0, v25, a3) & 1) == 0)
        return 0;
      ++v26;
      v25 += 40;
      if (v19 == v26)
        goto LABEL_29;
    }
    SecError(-50, a3, CFSTR("subject input incorrect: 2 values required in ATV array"));
    return 0;
  }
  return v11;
}

uint64_t SecVerifyCertificateRequest(const __CFData *a1, __SecKey **a2, CFStringRef *a3, CFDataRef *a4, CFDataRef *a5)
{
  _QWORD *v10;
  CFIndex v11;
  char *BytePtr;
  size_t v13;
  NSObject *v14;
  uint64_t v15;
  const char *v16;
  int v17;
  __SecKey *v18;
  __SecKey *v19;
  const __CFData *v20;
  __CFDictionary *Mutable;
  SecKeyRef v22;
  __int128 v23;
  const SecKeyAlgorithm *v24;
  NSObject *v25;
  const __CFData *v26;
  const __CFData *v27;
  const __CFString *v28;
  NSObject *v29;
  const __CFAllocator *v30;
  const __CFData *v31;
  __SecKey *v32;
  __CFDictionary *v33;
  const __CFData *v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  const UInt8 *v38;
  CFIndex v39;
  unsigned int v40;
  uint64_t *v41;
  uint64_t v43;
  int v44;
  CFIndex *v46;
  unint64_t *v47;
  NSObject *v48;
  NSObject *v49;
  CFStringRef v50;
  NSObject *v52;
  const char *v53;
  NSObject *v54;
  __SecKey **v55;
  CFStringRef *v56;
  CFDataRef *v57;
  CFDataRef *v58;
  const __CFAllocator *allocator;
  uint8_t v60[16];
  uint8_t buf[8];
  const UInt8 *v62;
  CFIndex length;
  UInt8 *bytes;
  _OWORD v65[3];
  __int128 v66;
  __int128 v67;
  size_t __n[2];
  void *__s2[2];
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;

  v10 = PORT_NewArena(1024);
  v67 = 0u;
  *(_OWORD *)__n = 0u;
  *(_OWORD *)__s2 = 0u;
  v70 = 0u;
  v71 = 0u;
  v72 = 0u;
  v73 = 0u;
  v74 = 0u;
  memset(v65, 0, sizeof(v65));
  v66 = 0u;
  v11 = CFDataGetLength(a1);
  BytePtr = (char *)CFDataGetBytePtr(a1);
  if (SEC_ASN1Decode((uint64_t)v10, (uint64_t)&v67, (uint64_t)&kSecAsn1CertRequestTemplate, BytePtr, v11))
  {
    v14 = secLogObjForScope("SecError");
    v15 = 0;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      goto LABEL_98;
    *(_WORD *)buf = 0;
    v16 = "csr: failed to decode CSR";
    goto LABEL_9;
  }
  if (SEC_ASN1Decode((uint64_t)v10, (uint64_t)v65, (uint64_t)&kSecAsn1SignedCertRequestTemplate, BytePtr, v11))
  {
    v14 = secLogObjForScope("SecError");
    v15 = 0;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      goto LABEL_98;
    *(_WORD *)buf = 0;
    v16 = "csr: failed to decode CSR";
    goto LABEL_9;
  }
  v13 = __n[1];
  if (__n[1] == 9 && !memcmp(&_oidRsa, __s2[0], 9uLL))
  {
    v58 = a4;
    v17 = 1;
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v18 = (__SecKey *)SecKeyCreate(*MEMORY[0x1E0C9AE00], (uint64_t)&kSecRSAPublicKeyDescriptor, v71, *((_QWORD *)&v70 + 1) >> 3, 1);
    if (v18)
    {
      v19 = v18;
      v20 = 0;
      Mutable = 0;
      goto LABEL_14;
    }
    v14 = secLogObjForScope("SecError");
    v15 = 0;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      goto LABEL_98;
    *(_WORD *)buf = 0;
    v16 = "csr: failed to create RSA public key";
LABEL_9:
    _os_log_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEFAULT, v16, buf, 2u);
    v15 = 0;
    goto LABEL_98;
  }
  if (v13 != 7 || memcmp(&_oidEcPubKey, __s2[0], 7uLL))
  {
    v14 = secLogObjForScope("SecError");
    v15 = 0;
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      goto LABEL_98;
    *(_WORD *)buf = 0;
    v16 = "csr: unsupported public key algorithm in CSR";
    goto LABEL_9;
  }
  v58 = a4;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v20 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v71, *((_QWORD *)&v70 + 1) >> 3, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionaryAddValue(Mutable, CFSTR("type"), CFSTR("73"));
  CFDictionaryAddValue(Mutable, CFSTR("kcls"), CFSTR("0"));
  v22 = SecKeyCreateWithData(v20, Mutable, 0);
  if (!v22)
  {
    v54 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v54, OS_LOG_TYPE_DEFAULT, "csr: failed to create EC public key", buf, 2u);
    }
    v15 = 0;
    v26 = 0;
    v27 = 0;
    if (!Mutable)
      goto LABEL_92;
    goto LABEL_91;
  }
  v19 = v22;
  v17 = 0;
LABEL_14:
  v23 = v72;
  if (!(_QWORD)v73)
    goto LABEL_17;
  if ((_QWORD)v73 != 2)
  {
    v25 = secLogObjForScope("SecError");
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
LABEL_30:
      v15 = 0;
      v26 = 0;
      v27 = 0;
      goto LABEL_90;
    }
    *(_WORD *)buf = 0;
LABEL_29:
    _os_log_impl(&dword_18A900000, v25, OS_LOG_TYPE_DEFAULT, "csr: non-empty signature algorithm parameters", buf, 2u);
    goto LABEL_30;
  }
  if (**((_WORD **)&v73 + 1) != 5)
  {
    v25 = secLogObjForScope("SecError");
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      goto LABEL_30;
    *(_WORD *)buf = 0;
    goto LABEL_29;
  }
LABEL_17:
  if (!v17)
  {
    if ((_QWORD)v72 == 8 && !memcmp(&_oidSha256Ecdsa, *((const void **)&v72 + 1), 8uLL))
    {
      v24 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA256;
    }
    else if ((_QWORD)v23 == 8 && !memcmp(&_oidSha384Ecdsa, *((const void **)&v23 + 1), 8uLL))
    {
      v24 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA384;
    }
    else
    {
      if ((_QWORD)v23 != 8 || memcmp(&_oidSha512Ecdsa, *((const void **)&v23 + 1), 8uLL))
        goto LABEL_44;
      v24 = &kSecKeyAlgorithmECDSASignatureMessageX962SHA512;
    }
LABEL_43:
    v28 = *v24;
    if (*v24)
      goto LABEL_47;
    goto LABEL_44;
  }
  if ((_QWORD)v72 == 9 && !memcmp(&_oidSha1Rsa, *((const void **)&v72 + 1), 9uLL))
  {
    v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA1;
    goto LABEL_43;
  }
  if ((_QWORD)v23 == 9 && !memcmp(&_oidSha256Rsa, *((const void **)&v23 + 1), 9uLL))
  {
    v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA256;
    goto LABEL_43;
  }
  if ((_QWORD)v23 == 9 && !memcmp(&_oidSha384Rsa, *((const void **)&v23 + 1), 9uLL))
  {
    v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA384;
    goto LABEL_43;
  }
  if ((_QWORD)v23 == 9 && !memcmp(&_oidSha512Rsa, *((const void **)&v23 + 1), 9uLL))
  {
    v24 = &kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA512;
    goto LABEL_43;
  }
LABEL_44:
  v29 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v29, OS_LOG_TYPE_DEFAULT, "csr: unsupported signature algorithm", buf, 2u);
  }
  v28 = 0;
LABEL_47:
  v57 = a5;
  v30 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
  v27 = CFDataCreateWithBytesNoCopy(allocator, *((const UInt8 **)&v66 + 1), (unint64_t)v66 >> 3, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v31 = CFDataCreateWithBytesNoCopy(allocator, *((const UInt8 **)&v65[0] + 1), *(CFIndex *)&v65[0], v30);
  v26 = v31;
  v15 = 0;
  if (!v28 || !v27 || !v31)
    goto LABEL_90;
  if (!SecKeyVerifySignature(v19, v28, v31, v27, 0))
  {
    v52 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v53 = "csr: failed to verify signature in CSR";
LABEL_109:
      _os_log_impl(&dword_18A900000, v52, OS_LOG_TYPE_DEFAULT, v53, buf, 2u);
    }
LABEL_110:
    v15 = 0;
    goto LABEL_90;
  }
  v55 = a2;
  v56 = a3;
  length = 0;
  bytes = 0;
  if (!SEC_ASN1EncodeItem((uint64_t)v10, &length, (uint64_t)__n, (uint64_t)&kSecAsn1NameTemplate))
  {
    v52 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v53 = "csr: failed to decode CSR subject name";
      goto LABEL_109;
    }
    goto LABEL_110;
  }
  v32 = v19;
  v33 = Mutable;
  v34 = v20;
  v35 = **((_QWORD **)&v71 + 1);
  if (**((_QWORD **)&v71 + 1))
  {
    v36 = 0;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    v40 = 1;
    do
    {
      if (*(_QWORD *)v35 == 9)
      {
        v41 = *(uint64_t **)(v35 + 8);
        if (*v41 == 0x9010DF78648862ALL && *((_BYTE *)v41 + 8) == 7)
        {
          v47 = **(unint64_t ***)(v35 + 16);
          v36 = *v47;
          v37 = (char *)v47[1];
        }
        else
        {
          v43 = *v41;
          v44 = *((unsigned __int8 *)v41 + 8);
          if (v43 == 0x9010DF78648862ALL && v44 == 14)
          {
            v46 = **(CFIndex ***)(v35 + 16);
            v39 = *v46;
            v38 = (const UInt8 *)v46[1];
          }
        }
      }
      v35 = *(_QWORD *)(*((_QWORD *)&v71 + 1) + 8 * v40++);
    }
    while (v35);
  }
  else
  {
    v36 = 0;
    v37 = 0;
    v39 = 0;
    v38 = 0;
  }
  if (v58 && length)
    *v58 = CFDataCreate(allocator, bytes, length);
  if (v57 && v39)
    *v57 = CFDataCreate(allocator, v38, v39);
  v20 = v34;
  Mutable = v33;
  v19 = v32;
  if (v56 && v36)
  {
    *(_QWORD *)buf = 0;
    v62 = 0;
    if (!SEC_ASN1Decode((uint64_t)v10, (uint64_t)buf, (uint64_t)kSecAsn1UTF8StringTemplate, v37, v36))
      goto LABEL_84;
    v48 = secLogObjForScope("csr");
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)v60 = 0;
      _os_log_debug_impl(&dword_18A900000, v48, OS_LOG_TYPE_DEBUG, "challenge failed to decode with UTF8, attempting PrintableString", v60, 2u);
    }
    if (SEC_ASN1Decode((uint64_t)v10, (uint64_t)buf, (uint64_t)kSecAsn1PrintableStringTemplate, v37, v36))
    {
      v49 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v60 = 0;
        _os_log_impl(&dword_18A900000, v49, OS_LOG_TYPE_DEFAULT, "csr: failed to decode challenge", v60, 2u);
      }
      v50 = 0;
    }
    else
    {
LABEL_84:
      v50 = CFStringCreateWithBytes(allocator, v62, *(CFIndex *)buf, 0x8000100u, 0);
    }
    *v56 = v50;
  }
  if (v55)
  {
    *v55 = v32;
    v15 = 1;
    if (!Mutable)
      goto LABEL_92;
    goto LABEL_91;
  }
  v15 = 1;
LABEL_90:
  CFRelease(v19);
  if (Mutable)
LABEL_91:
    CFRelease(Mutable);
LABEL_92:
  if (v20)
    CFRelease(v20);
  if (v26)
    CFRelease(v26);
  if (v27)
    CFRelease(v27);
LABEL_98:
  if (v10)
    PORT_FreeArena(v10, 1);
  return v15;
}

_QWORD *SecGenerateSelfSignedCertificateWithError(const __CFArray *a1, const __CFDictionary *a2, uint64_t a3, __SecKey *a4, __CFString **a5)
{
  _DWORD *v9;
  _QWORD *v10;
  const __CFData *Value;
  CFDataRef v12;
  CFTypeID v13;
  const __CFNumber *v14;
  double Current;
  __SecKey *v16;
  __SecKey *v17;
  const __CFData *public_key;
  CFDataRef signature;
  const __CFData *v20;
  const __CFData *v21;
  _QWORD *v22;
  const __CFString *v23;
  NSObject *v24;
  CFErrorRef v25;
  int64_t v27;
  const void *v28;
  CFIndex v29;
  const UInt8 *v30;
  uint64_t valuePtr;
  char v32;
  _QWORD v33[2];
  __int128 v34;
  _OWORD v35[4];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  void *v39[2];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  DERSize v43[8];
  __int128 v44;
  const UInt8 *BytePtr;
  CFErrorRef error;
  char v47;
  UInt8 bytes[4];
  CFErrorRef v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  v9 = PORT_NewArena(1024);
  v47 = 0;
  error = 0;
  if (!v9)
  {
    SecError(-67672, a5, CFSTR("pool allocation failure"));
    return 0;
  }
  v10 = v9;
  BytePtr = 0;
  v44 = 0u;
  memset(v43, 0, sizeof(v43));
  v42 = 0u;
  v41 = 0u;
  v40 = 0u;
  *(_OWORD *)v39 = 0u;
  v38 = 0u;
  v37 = 0u;
  v36 = 0u;
  memset(v35, 0, sizeof(v35));
  v34 = 0u;
  v32 = 2;
  v33[0] = 1;
  v33[1] = &v32;
  if (a2
    && (Value = (const __CFData *)CFDictionaryGetValue(a2, CFSTR("certificateSerial"))) != 0
    && (v12 = Value, v13 = CFGetTypeID(Value), v13 == CFDataGetTypeID())
    && (unint64_t)(CFDataGetLength(v12) - 21) >= 0xFFFFFFFFFFFFFFECLL)
  {
    CFRetain(v12);
  }
  else
  {
    bytes[0] = 1;
    v12 = CFDataCreate(0, bytes, 1);
    if (!v12)
    {
      SecError(-67672, (__CFString **)&error, CFSTR("failed to allocate serial number"));
      goto LABEL_30;
    }
  }
  *(_QWORD *)&v34 = CFDataGetLength(v12);
  *((_QWORD *)&v34 + 1) = CFDataGetBytePtr(v12);
  *(_QWORD *)&v35[2] = make_subject((uint64_t)v10, a1, (__CFString **)&error);
  *((_QWORD *)&v37 + 1) = *(_QWORD *)&v35[2];
  if (a2)
  {
    v14 = (const __CFNumber *)CFDictionaryGetValue(a2, CFSTR("certificateLifetime"));
    valuePtr = 31536000;
    if (v14)
      CFNumberGetValue(v14, kCFNumberLongLongType, &valuePtr);
  }
  else
  {
    valuePtr = 31536000;
  }
  Current = CFAbsoluteTimeGetCurrent();
  if (SecAsn1EncodeTime((uint64_t)v10, (uint64_t)&v35[2] + 8, Current))
  {
    v23 = CFSTR("failed to encode notBefore");
    goto LABEL_29;
  }
  if (SecAsn1EncodeTime((uint64_t)v10, (uint64_t)&v36, Current + (double)valuePtr))
  {
    v23 = CFSTR("failed to encode notAfter");
    goto LABEL_29;
  }
  if ((extensions_from_parameters((uint64_t)v10, a2, v43, (__CFString **)&error) & 1) == 0)
  {
    v23 = CFSTR("failed to encode extensions");
    goto LABEL_29;
  }
  if (!a4 || (v16 = SecKeyCopyPublicKey(a4)) == 0)
  {
    v23 = CFSTR("failed get public key");
LABEL_29:
    SecError(-26276, (__CFString **)&error, v23);
LABEL_30:
    v22 = 0;
    v21 = 0;
    public_key = 0;
    v17 = 0;
    goto LABEL_31;
  }
  v17 = v16;
  public_key = make_public_key(v16, (uint64_t)&v38, &v47, &error);
  if (!public_key)
  {
    SecError(-26276, (__CFString **)&error, CFSTR("failed to encode public key"));
    v22 = 0;
    v21 = 0;
    goto LABEL_31;
  }
  if (a2)
    a2 = (const __CFDictionary *)CFDictionaryGetValue(a2, (const void *)kSecCMSSignHashAlgorithm);
  signature = make_signature(0, 0, a4, a2, (DERSize *)v35, (__CFString **)&error);
  if (signature)
    CFRelease(signature);
  v29 = 0;
  v30 = 0;
  if (!SEC_ASN1EncodeItem((uint64_t)v10, &v29, (uint64_t)v33, (uint64_t)&kSecAsn1TBSCertificateTemplate))
    SecError(-26276, (__CFString **)&error, CFSTR("failed to encode TBS"));
  v20 = make_signature(v30, v29, a4, a2, &v43[5], (__CFString **)&error);
  v21 = v20;
  if (!v20)
  {
    SecError(-67688, (__CFString **)&error, CFSTR("failed to make signature"));
LABEL_60:
    v22 = 0;
    goto LABEL_31;
  }
  BytePtr = CFDataGetBytePtr(v20);
  *((_QWORD *)&v44 + 1) = 8 * CFDataGetLength(v21);
  v27 = 0;
  v28 = 0;
  if (!SEC_ASN1EncodeItem((uint64_t)v10, &v27, (uint64_t)v33, (uint64_t)&kSecAsn1SignedCertTemplate))
  {
    SecError(-26276, (__CFString **)&error, CFSTR("failed to encode certificate"));
    goto LABEL_60;
  }
  v22 = SecCertificateCreateWithBytes(*MEMORY[0x1E0C9AE00], v28, v27);
  if (!v22)
    SecError(-26276, (__CFString **)&error, CFSTR("failed to decode encoded certificate"));
LABEL_31:
  if (v47)
    free(v39[1]);
  PORT_FreeArena(v10, 1);
  if (v17)
    CFRelease(v17);
  if (public_key)
    CFRelease(public_key);
  if (v21)
    CFRelease(v21);
  if (v12)
    CFRelease(v12);
  if (error)
  {
    v24 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)bytes = 138412290;
      v49 = error;
      _os_log_impl(&dword_18A900000, v24, OS_LOG_TYPE_DEFAULT, "csr: failed to generate self-signed certificate %@", bytes, 0xCu);
    }
    if (v22)
      CFRelease(v22);
    if (a5)
    {
      v25 = error;
      if (*a5)
        CFRelease(*a5);
      v22 = 0;
      *a5 = (__CFString *)v25;
      return v22;
    }
    return 0;
  }
  return v22;
}

_QWORD *SecGenerateSelfSignedCertificate(const __CFArray *a1, const __CFDictionary *a2, uint64_t a3, __SecKey *a4)
{
  return SecGenerateSelfSignedCertificateWithError(a1, a2, a3, a4, 0);
}

_QWORD *SecIdentitySignCertificate(uint64_t a1, const __CFData *a2, __SecKey *a3, const void *a4, const void *a5)
{
  return SecIdentitySignCertificateWithParameters(a1, a2, a3, a4, a5, 0);
}

_QWORD *SecIdentitySignCertificateWithParameters(uint64_t a1, const __CFData *a2, __SecKey *a3, const void *a4, const void *a5, CFDictionaryRef theDict)
{
  const void *Value;
  _DWORD *v13;
  _QWORD *v14;
  CFTypeID v15;
  NSObject *v16;
  _QWORD *v17;
  CFTypeID v18;
  CFIndex Length;
  char *BytePtr;
  const void *v21;
  __CFData *v22;
  CFIndex v23;
  char *v24;
  const __CFNumber *v25;
  NSObject *v26;
  const char *v27;
  void *v28;
  const __CFData *v29;
  const __CFData *v30;
  double Current;
  CFTypeID v32;
  NSObject *v33;
  uint64_t v34;
  const __CFDictionary *v35;
  CFTypeID v36;
  CFTypeID v37;
  CFIndex v38;
  char *v39;
  NSObject *v40;
  CFTypeID v41;
  NSObject *v42;
  NSObject *v43;
  const char *v44;
  NSObject *v45;
  const __CFData *public_key;
  CFDataRef signature;
  NSObject *v48;
  const __CFData *v49;
  _QWORD *v50;
  NSObject *v51;
  CFErrorRef v52;
  NSObject *v54;
  const char *v55;
  NSObject *v56;
  NSObject *v57;
  int64_t v58;
  const void *v59;
  CFIndex v60;
  const UInt8 *v61;
  uint64_t valuePtr;
  char v63;
  uint8_t buf[8];
  char *v65;
  __int128 v66;
  _OWORD v67[2];
  _OWORD v68[2];
  __int128 v69;
  __int128 v70;
  __int128 v71;
  void *v72[2];
  __int128 v73;
  __int128 v74;
  __int128 v75;
  _OWORD v76[4];
  __int128 v77;
  const UInt8 *v78;
  CFErrorRef error;
  char v80;
  uint8_t v81[4];
  CFErrorRef v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  if (theDict)
    Value = CFDictionaryGetValue(theDict, (const void *)kSecCMSSignHashAlgorithm);
  else
    Value = 0;
  v80 = 0;
  error = 0;
  v13 = PORT_NewArena(1024);
  if (v13)
  {
    v14 = v13;
    v78 = 0;
    v77 = 0u;
    v75 = 0u;
    memset(v76, 0, sizeof(v76));
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    *(_OWORD *)v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    memset(v68, 0, sizeof(v68));
    memset(v67, 0, sizeof(v67));
    v66 = 0u;
    v63 = 2;
    *(_QWORD *)buf = 1;
    v65 = &v63;
    *(_QWORD *)&v66 = CFDataGetLength(a2);
    *((_QWORD *)&v66 + 1) = CFDataGetBytePtr(a2);
    if (!a4)
      goto LABEL_19;
    v15 = CFGetTypeID(a4);
    if (v15 == CFArrayGetTypeID())
    {
      *((_QWORD *)&v70 + 1) = make_subject((uint64_t)v14, (CFArrayRef)a4, (__CFString **)&error);
      goto LABEL_13;
    }
    v18 = CFGetTypeID(a4);
    if (v18 == CFDataGetTypeID())
    {
      Length = CFDataGetLength((CFDataRef)a4);
      BytePtr = (char *)CFDataGetBytePtr((CFDataRef)a4);
      if (!SEC_ASN1Decode((uint64_t)v14, (uint64_t)&v70 + 8, (uint64_t)&kSecAsn1NameTemplate, BytePtr, Length))
      {
LABEL_13:
        v21 = *(const void **)(a1 + 16);
        CFRetain(v21);
        v22 = SecDERItemCopySequence((uint64_t)v21 + 184);
        v23 = CFDataGetLength(v22);
        v24 = (char *)CFDataGetBytePtr(v22);
        if (SEC_ASN1Decode((uint64_t)v14, (uint64_t)v68, (uint64_t)&kSecAsn1NameTemplate, v24, v23))
        {
          v56 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v81 = 0;
            _os_log_impl(&dword_18A900000, v56, OS_LOG_TYPE_DEFAULT, "csr: failed to decoder subject name from CA identity", v81, 2u);
          }
          v28 = 0;
          goto LABEL_24;
        }
        if (v22)
          CFRelease(v22);
        if (theDict)
        {
          v25 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("certificateLifetime"));
          valuePtr = 31536000;
          if (v25)
            CFNumberGetValue(v25, kCFNumberLongLongType, &valuePtr);
        }
        else
        {
          valuePtr = 31536000;
        }
        Current = CFAbsoluteTimeGetCurrent();
        if (SecAsn1EncodeTime((uint64_t)v14, (uint64_t)v68 + 8, Current))
        {
          v43 = secLogObjForScope("SecError");
          if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            goto LABEL_53;
          *(_WORD *)v81 = 0;
          v44 = "csr: failed to encode notBefore";
          goto LABEL_52;
        }
        if (SecAsn1EncodeTime((uint64_t)v14, (uint64_t)&v69, Current + (double)valuePtr))
        {
          v43 = secLogObjForScope("SecError");
          if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            goto LABEL_53;
          *(_WORD *)v81 = 0;
          v44 = "csr: failed to encode notBefore";
          goto LABEL_52;
        }
        if (theDict)
        {
          v32 = CFGetTypeID(theDict);
          if (v32 == CFDictionaryGetTypeID() && parameters_contains_extensions(theDict))
          {
            v33 = secLogObjForScope("csr");
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)v81 = 0;
              _os_log_debug_impl(&dword_18A900000, v33, OS_LOG_TYPE_DEBUG, "overriding request extensions with parameters extensions", v81, 2u);
            }
            v34 = (uint64_t)v14;
            v35 = theDict;
LABEL_46:
            if ((extensions_from_parameters(v34, v35, v76, (__CFString **)&error) & 1) == 0)
            {
LABEL_50:
              v43 = secLogObjForScope("SecError");
              if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
              {
LABEL_53:
                v28 = 0;
                goto LABEL_23;
              }
              *(_WORD *)v81 = 0;
              v44 = "csr: failed to encode extensions";
LABEL_52:
              _os_log_impl(&dword_18A900000, v43, OS_LOG_TYPE_DEFAULT, v44, v81, 2u);
              goto LABEL_53;
            }
LABEL_56:
            public_key = make_public_key(a3, (uint64_t)&v71, &v80, &error);
            if (!public_key)
            {
              v43 = secLogObjForScope("SecError");
              if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
                goto LABEL_53;
              *(_WORD *)v81 = 0;
              v44 = "csr: failed to encode public key";
              goto LABEL_52;
            }
            v30 = public_key;
            v28 = *(void **)(a1 + 24);
            CFRetain(v28);
            signature = make_signature(0, 0, (__SecKey *)v28, Value, (DERSize *)v67, (__CFString **)&error);
            if (signature)
              CFRelease(signature);
            v60 = 0;
            v61 = 0;
            if (!SEC_ASN1EncodeItem((uint64_t)v14, &v60, (uint64_t)buf, (uint64_t)&kSecAsn1TBSCertificateTemplate))
            {
              v48 = secLogObjForScope("SecError");
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v81 = 0;
                _os_log_impl(&dword_18A900000, v48, OS_LOG_TYPE_DEFAULT, "csr: failed to encode TBS", v81, 2u);
              }
            }
            v49 = make_signature(v61, v60, (__SecKey *)v28, Value, (DERSize *)&v76[2] + 1, (__CFString **)&error);
            if (!v49)
            {
              v57 = secLogObjForScope("SecError");
              if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v81 = 0;
                _os_log_impl(&dword_18A900000, v57, OS_LOG_TYPE_DEFAULT, "csr: failed to make signature", v81, 2u);
              }
              v22 = 0;
              v29 = 0;
              goto LABEL_25;
            }
            v29 = v49;
            v78 = CFDataGetBytePtr(v49);
            *((_QWORD *)&v77 + 1) = 8 * CFDataGetLength(v29);
            v58 = 0;
            v59 = 0;
            if (SEC_ASN1EncodeItem((uint64_t)v14, &v58, (uint64_t)buf, (uint64_t)&kSecAsn1SignedCertTemplate))
            {
              v50 = SecCertificateCreateWithBytes(*MEMORY[0x1E0C9AE00], v59, v58);
              if (v50)
              {
                v17 = v50;
                v22 = 0;
                goto LABEL_66;
              }
              v54 = secLogObjForScope("SecError");
              if (!os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                goto LABEL_87;
              *(_WORD *)v81 = 0;
              v55 = "csr: failed to decode encoded certificate";
            }
            else
            {
              v54 = secLogObjForScope("SecError");
              if (!os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                goto LABEL_87;
              *(_WORD *)v81 = 0;
              v55 = "csr: failed to encode certificate";
            }
            _os_log_impl(&dword_18A900000, v54, OS_LOG_TYPE_DEFAULT, v55, v81, 2u);
LABEL_87:
            v22 = 0;
            goto LABEL_25;
          }
          if (!a5)
          {
            v36 = CFGetTypeID(theDict);
            if (v36 == CFDictionaryGetTypeID() && !parameters_contains_extensions(theDict))
            {
LABEL_54:
              v45 = secLogObjForScope("csr");
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)v81 = 0;
                _os_log_debug_impl(&dword_18A900000, v45, OS_LOG_TYPE_DEBUG, "no extensions set", v81, 2u);
              }
              goto LABEL_56;
            }
LABEL_48:
            v42 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v81 = 0;
              _os_log_impl(&dword_18A900000, v42, OS_LOG_TYPE_DEFAULT, "csr: extensions or parameters wrong input type", v81, 2u);
            }
            goto LABEL_50;
          }
        }
        else if (!a5)
        {
          goto LABEL_54;
        }
        v37 = CFGetTypeID(a5);
        if (v37 == CFDataGetTypeID())
        {
          v38 = CFDataGetLength((CFDataRef)a5);
          v39 = (char *)CFDataGetBytePtr((CFDataRef)a5);
          if (!SEC_ASN1Decode((uint64_t)v14, (uint64_t)v76, (uint64_t)&kSecAsn1SequenceOfCertExtensionTemplate, v39, v38))goto LABEL_56;
          v40 = secLogObjForScope("SecError");
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v81 = 0;
            _os_log_impl(&dword_18A900000, v40, OS_LOG_TYPE_DEFAULT, "failed to decode requested CSR extensions", v81, 2u);
          }
        }
        else
        {
          v41 = CFGetTypeID(a5);
          if (v41 == CFDictionaryGetTypeID())
          {
            v34 = (uint64_t)v14;
            v35 = (const __CFDictionary *)a5;
            goto LABEL_46;
          }
        }
        goto LABEL_48;
      }
      v26 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v81 = 0;
        v27 = "csr: failed to decode input subject";
        goto LABEL_21;
      }
    }
    else
    {
LABEL_19:
      v26 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v81 = 0;
        v27 = "csr: unsupported subject CFType";
LABEL_21:
        _os_log_impl(&dword_18A900000, v26, OS_LOG_TYPE_DEFAULT, v27, v81, 2u);
      }
    }
    v28 = 0;
    v21 = 0;
LABEL_23:
    v22 = 0;
LABEL_24:
    v29 = 0;
    v30 = 0;
LABEL_25:
    v17 = 0;
LABEL_66:
    if (v80)
      free(v72[1]);
    if (v21)
      CFRelease(v21);
    if (v22)
      CFRelease(v22);
    if (v28)
      CFRelease(v28);
    PORT_FreeArena(v14, 1);
    if (v30)
      CFRelease(v30);
    if (v29)
      CFRelease(v29);
    if (error)
    {
      v51 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v81 = 138412290;
        v82 = error;
        _os_log_impl(&dword_18A900000, v51, OS_LOG_TYPE_DEFAULT, "csr: cert issuance failed: %@", v81, 0xCu);
      }
      v52 = error;
      if (error)
      {
        error = 0;
        CFRelease(v52);
      }
    }
    return v17;
  }
  v16 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", buf, 2u);
  }
  return 0;
}

BOOL parameters_contains_extensions(const __CFDictionary *a1)
{
  return CFDictionaryContainsKey(a1, CFSTR("subjectAltName"))
      || CFDictionaryContainsKey(a1, CFSTR("keyUsage"))
      || CFDictionaryContainsKey(a1, CFSTR("basicConstraintsCA"))
      || CFDictionaryContainsKey(a1, CFSTR("basicConstraints"))
      || CFDictionaryContainsKey(a1, CFSTR("certificateEKUs"))
      || CFDictionaryContainsKey(a1, CFSTR("certificateExtensions"))
      || CFDictionaryContainsKey(a1, CFSTR("certificateExtensionsEncoded")) != 0;
}

_QWORD *SecIdentitySignCertificateWithAlgorithm(uint64_t a1, const __CFData *a2, __SecKey *a3, const void *a4, const void *a5, const void *a6)
{
  __CFDictionary *Mutable;
  _QWORD *v13;

  if (!a6)
    return SecIdentitySignCertificateWithParameters(a1, a2, a3, a4, a5, 0);
  Mutable = CFDictionaryCreateMutable(0, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionaryAddValue(Mutable, (const void *)kSecCMSSignHashAlgorithm, a6);
  v13 = SecIdentitySignCertificateWithParameters(a1, a2, a3, a4, a5, Mutable);
  if (Mutable)
    CFRelease(Mutable);
  return v13;
}

__CFData *SecGenerateCertificateRequestSubject(uint64_t a1, const __CFArray *a2)
{
  _DWORD *v4;
  _QWORD *v5;
  __CFData *v6;
  CFIndex Length;
  const UInt8 *BytePtr;
  CFIndex v9;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  UInt8 *v12;
  UInt8 *v13;
  NSObject *v14;
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  uint8_t v19[8];
  _QWORD *subject;
  uint8_t buf[8];
  const void *v22;

  v4 = PORT_NewArena(1024);
  if (v4)
  {
    v5 = v4;
    v6 = SecDERItemCopySequence(a1 + 184);
    *(_QWORD *)buf = 0;
    v22 = 0;
    Length = CFDataGetLength(v6);
    BytePtr = CFDataGetBytePtr(v6);
    subject = make_subject((uint64_t)v5, a2, 0);
    if (SEC_ASN1EncodeItem((uint64_t)v5, buf, (uint64_t)&subject, (uint64_t)&kSecAsn1NameTemplate))
    {
      v18 = DERLengthOfLength(*(_QWORD *)buf + Length);
      v9 = Length + *(_QWORD *)buf + v18 + 1;
      Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
      CFDataSetLength(Mutable, v9);
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      *MutableBytePtr = 48;
      v12 = MutableBytePtr + 1;
      if (DEREncodeLength(*(_QWORD *)buf + Length, (unint64_t)(MutableBytePtr + 1), (unint64_t *)&v18))
      {
        v17 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v19 = 0;
          _os_log_impl(&dword_18A900000, v17, OS_LOG_TYPE_DEFAULT, "csr: failed to encode outer subject sequence", v19, 2u);
        }
      }
      else
      {
        v13 = &v12[v18];
        memcpy(v13, BytePtr, Length);
        memcpy(&v13[Length], v22, *(size_t *)buf);
      }
    }
    else
    {
      v16 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v19 = 0;
        _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEFAULT, "csr: failed to encode subject", v19, 2u);
      }
      Mutable = 0;
    }
    if (v6)
      CFRelease(v6);
    PORT_FreeArena(v5, 1);
  }
  else
  {
    v14 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEFAULT, "csr: pool allocation failure", buf, 2u);
    }
    return 0;
  }
  return Mutable;
}

uint64_t SecDHGetMaxKeyLength()
{
  return 8 * MEMORY[0x18D76FEE4]();
}

uint64_t SecDHCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  unint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t result;

  v8 = (a3 + 7) & 0xFFFFFFFFFFFFFFF8;
  v9 = ccdh_gp_size();
  v10 = malloc_type_malloc(v9 + 2 * v8 + 23, 0x21E4C0F7uLL);
  cc_clear();
  result = ccdh_init_gp_from_bytes();
  if ((_DWORD)result)
  {
    SecDHDestroy(v10);
    v10 = 0;
    result = 4294941020;
  }
  *a7 = v10;
  return result;
}

void SecDHDestroy(void *a1)
{
  MEMORY[0x18D76FEE4]();
  ccdh_gp_size();
  cc_clear();
  free(a1);
}

uint64_t SecDHCreateFromParameters(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  __int128 v4;
  uint64_t result;
  unint64_t v6;
  size_t v7;
  void *v8;
  void *v9;
  int v10;
  _OWORD v11[2];
  _OWORD v12[2];
  _QWORD v13[2];

  v13[0] = a1;
  v13[1] = a2;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[0] = v4;
  v12[1] = v4;
  v11[0] = v4;
  v11[1] = v4;
  v10 = 0;
  result = DERParseSequence((uint64_t)v13, 4u, (uint64_t)&DER_DHParamsItemSpecs, (unint64_t)v11, 0x40uLL);
  if (!(_DWORD)result)
  {
    if (!*((_QWORD *)&v12[0] + 1) || (result = DERParseInteger((char **)v12, &v10), !(_DWORD)result))
    {
      v6 = (*((_QWORD *)&v11[0] + 1) + 7) & 0xFFFFFFFFFFFFFFF8;
      v7 = ccdh_gp_size() + 2 * v6 + 23;
      v8 = malloc_type_malloc(v7, 0xFBD54782uLL);
      if (v8)
      {
        v9 = v8;
        bzero(v8, v7);
        result = ccdh_init_gp_from_bytes();
        if ((_DWORD)result)
        {
          SecDHDestroy(v9);
          v9 = 0;
          result = 4294941021;
        }
        *a3 = v9;
      }
      else
      {
        return 4294967188;
      }
    }
  }
  return result;
}

uint64_t SecDHCreateFromAlgorithmId(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  __int128 v4;
  int v5;
  uint64_t result;
  _QWORD v7[2];
  __int128 v8;
  __int128 v9;

  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8 = v4;
  v9 = v4;
  v7[0] = a1;
  v7[1] = a2;
  v5 = DERParseSequence((uint64_t)v7, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)&v8, 0x20uLL);
  result = 4294941021;
  switch(v5)
  {
    case 0:
      result = SecDHCreateFromParameters(v9, *((uint64_t *)&v9 + 1), a3);
      break;
    case 1:
    case 2:
    case 3:
    case 5:
      return result;
    case 4:
      result = 4294967292;
      break;
    case 6:
      result = 4294967246;
      break;
    case 7:
      result = 4294941995;
      break;
    default:
      result = 4294941020;
      break;
  }
  return result;
}

uint64_t SecDHGenerateKeypair(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  uint64_t result;
  unint64_t v6;
  unint64_t v7;

  MEMORY[0x18D76FEE4]();
  ccdh_gp_size();
  result = ccdh_generate_key();
  if (!(_DWORD)result)
  {
    MEMORY[0x18D76FEE4](a1);
    v6 = ccn_write_uint_size();
    if (*a3 >= v6)
    {
      v7 = v6;
      MEMORY[0x18D76FEE4](a1);
      ccn_write_uint();
      result = 0;
      *a3 = v7;
    }
    else
    {
      return 4294941995;
    }
  }
  return result;
}

uint64_t dhRngCallback()
{
  return CCRandomCopyBytes();
}

uint64_t SecDHComputeKey(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t *a5)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  size_t v14;
  size_t v15;
  size_t v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x18D76FEE4]();
  ccdh_gp_size();
  v7 = ccdh_ccn_size();
  MEMORY[0x1E0C80A78](v7);
  if (v9 >= 0x10)
  {
    v10 = (size_t *)((char *)v17 - v8);
    do
    {
      *v10 = 0xAAAAAAAAAAAAAAAALL;
      v10[1] = 0xAAAAAAAAAAAAAAAALL;
      v10 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  if (ccdh_import_pub())
    return 4294941021;
  v17[0] = ccdh_ccn_size();
  v12 = malloc_type_calloc(1uLL, v17[0], 0x44DBF668uLL);
  if (!v12)
    return 4294967188;
  v13 = v12;
  if (ccdh_compute_shared_secret())
  {
    v11 = 4294941021;
  }
  else
  {
    v14 = v17[0];
    v15 = *a5;
    if (v17[0] < *a5)
    {
      *a5 = v17[0];
      v15 = v14;
    }
    memcpy(a4, v13, v15);
    v11 = 0;
  }
  free(v13);
  return v11;
}

uint64_t SecECPublicKeyCopyKeyDescription(__SecKey *a1)
{
  unsigned int v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;
  id v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t AlgorithmId;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t (*v17)(uint64_t);
  uint64_t v18;
  uint64_t i;
  const char *v21;
  uint64_t v22;
  id v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  v26 = 0;
  v2 = SecECKeyGetNamedCurve(a1) - 23;
  if (v2 > 2)
    v3 = "kSecECCurveNone";
  else
    v3 = off_1E1FD5C78[v2];
  v21 = v3;
  v22 = (uint64_t)a1;
  v24 = cczp_bitlen() + 7;
  objc_msgSend(MEMORY[0x1E0C99DF0], "dataWithLength:", v24 >> 3);
  v23 = (id)objc_claimAutoreleasedReturnValue();
  v4 = 0;
  if (v24 >> 3 <= 1)
    v5 = 1;
  else
    v5 = v24 >> 3;
  v6 = 1;
  do
  {
    v7 = v6;
    v8 = objc_retainAutorelease(v23);
    objc_msgSend(v8, "mutableBytes");
    ccn_write_uint();
    objc_msgSend(MEMORY[0x1E0CB37A0], "stringWithCapacity:", 2 * (v24 >> 3));
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v10 = (void *)*(&v25 + v4);
    *(&v25 + v4) = (uint64_t)v9;

    if (v24 >= 8)
    {
      v11 = 0;
      do
        objc_msgSend(v9, "appendFormat:", CFSTR("%02X"), *(unsigned __int8 *)(objc_msgSend(objc_retainAutorelease(v8), "bytes") + v11++));
      while (v5 != v11);
    }
    v6 = 0;
    v4 = 1;
  }
  while ((v7 & 1) != 0);
  v12 = (void *)MEMORY[0x1E0CB3940];
  AlgorithmId = SecKeyGetAlgorithmId(v22);
  v14 = *(unsigned int **)(v22 + 16);
  v15 = *((_QWORD *)v14 + 1);
  v16 = *v14;
  _SecKeyCheck(v22, (uint64_t)"SecKeyGetBlockSize");
  v17 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v22 + 16) + 80);
  if (v17)
    v17 = (uint64_t (*)(uint64_t))(8 * v17(v22));
  objc_msgSend(v12, "stringWithFormat:", CFSTR("<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, y: %@, x: %@, addr: %p>"), v21, AlgorithmId, v15, v16, v17, v26, v25, v22);
  v18 = objc_claimAutoreleasedReturnValue();

  for (i = 8; i != -8; i -= 8)
  return v18;
}

__CFData *SecECKeyCopyWrapKey(__SecKey *a1, int a2, const __CFData *a3, const __CFDictionary *a4, uint64_t a5, __CFString **a6)
{
  int NamedCurve;
  uint64_t v10;
  uint64_t v11;
  const __CFNumber *Value;
  const __CFNumber *v13;
  CFTypeID v14;
  const __CFData *v15;
  const __CFData *v16;
  CFTypeID v17;
  __CFData *Mutable;
  const void *v20;
  const void *v21;
  const __CFNumber *v22;
  uint64_t v23;
  CFIndex v24;
  const UInt8 *BytePtr;
  uint64_t v26;
  int v27;
  char valuePtr;

  valuePtr = 0;
  v27 = 0;
  if (a2 != 1)
  {
    SecError(-4, a6, CFSTR("unsupported key wrapping algorithm"));
    return 0;
  }
  NamedCurve = SecECKeyGetNamedCurve(a1);
  v10 = MEMORY[0x1E0C81D60];
  if (NamedCurve != 25)
    v10 = 0;
  if (NamedCurve == 23)
    v11 = MEMORY[0x1E0C81D58];
  else
    v11 = v10;
  if (!v11)
  {
    SecError(-4, a6, CFSTR("unsupported curve"));
    return 0;
  }
  Value = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("kSecKeyWrapPGPSymAlg"));
  if (!Value
    || (v13 = Value, v14 = CFGetTypeID(Value), v14 != CFNumberGetTypeID())
    || !CFNumberGetValue(v13, kCFNumberSInt8Type, &valuePtr))
  {
    SecError(-4, a6, CFSTR("unknown symalg given"));
    return 0;
  }
  v15 = (const __CFData *)CFDictionaryGetValue(a4, CFSTR("kSecKeyWrapPGPFingerprint"));
  if (!v15 || (v16 = v15, v17 = CFGetTypeID(v15), v17 != CFDataGetTypeID()) || CFDataGetLength(v16) <= 19)
  {
    SecError(-4, a6, CFSTR("invalid fingerprint"));
    return 0;
  }
  v20 = CFDictionaryGetValue(a4, CFSTR("kSecKeyWrapPGPWrapAlg"));
  if (!v20)
  {
    SecError(-4, a6, CFSTR("no wrap alg"));
    return 0;
  }
  v21 = v20;
  if (!CFEqual(v20, CFSTR("kSecKeyWrapPGPECWrapDigestSHA256KekAES128"))
    && !CFEqual(v21, CFSTR("kSecKeyWrapPGPECWrapDigestSHA512KekAES256")))
  {
    SecError(-4, a6, CFSTR("unknown wrap alg"));
    return 0;
  }
  v22 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("kSecKeyWrapPGPECFlags"));
  if (isNumber(v22))
  {
    if (!CFNumberGetValue(v22, kCFNumberSInt32Type, &v27))
    {
      SecError(-4, a6, CFSTR("invalid flags: %@"), v22);
      return 0;
    }
  }
  else if (v22)
  {
    SecError(-4, a6, CFSTR("unknown flags"));
    return 0;
  }
  CFDataGetLength(a3);
  v23 = ccec_rfc6637_wrap_key_size();
  if (!v23)
  {
    SecError(-4, a6, CFSTR("can't wrap that key, can't build size"));
    return 0;
  }
  v24 = v23;
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  CFDataSetLength(Mutable, v24);
  if (Mutable)
  {
    CFDataGetMutableBytePtr(Mutable);
    CFDataGetLength(a3);
    CFDataGetBytePtr(a3);
    BytePtr = CFDataGetBytePtr(v16);
    v26 = ccrng();
    if (ccec_rfc6637_wrap_key())
    {
      SecError(-4, a6, CFSTR("Failed to wrap key"), BytePtr, v26);
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

__CFData *SecECPublicKeyCopyExternalRepresentation()
{
  return SecECPublicKeyExport(0);
}

const void *isNumber(const void *result)
{
  CFTypeID v1;

  if (result)
  {
    v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFNumberGetTypeID());
  }
  return result;
}

uint64_t getCPForPublicSize()
{
  ccec_x963_import_pub_size();
  if (ccec_keysize_is_supported())
    return ccec_get_cp();
  else
    return 0;
}

uint64_t SecECPrivateKeyInit(uint64_t a1, CFDictionaryRef theDict, unint64_t a3, int a4)
{
  uint64_t *v6;
  uint64_t v7;
  int key_fips;
  const __CFNumber *Value;
  const __CFNumber *v10;
  CFTypeID v11;
  uint64_t cp;
  uint64_t v13;
  CFTypeID v14;
  NSObject *v16;
  _BYTE valuePtr[24];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v6 = *(uint64_t **)(a1 + 24);
  if (a4 == 7)
  {
    ccec_x963_import_priv_size();
    if (!ccec_keysize_is_supported())
      return 4294967246;
    cp = ccec_get_cp();
    if (!cp)
      return 4294967246;
    *v6 = cp;
    if (a3 <= (((unint64_t)(cczp_bitlen() + 7) >> 2) | 1))
      return 4294967246;
    v13 = 4294941021;
    if (!ccec_import_pub())
    {
      if (ccn_read_uint())
        return 4294941021;
      else
        return 0;
    }
  }
  else
  {
    if (a4 != 5)
    {
      if (a4 == 1)
      {
        *(_QWORD *)valuePtr = 0xAAAAAAAAAAAAAAAALL;
        if (!ccec_der_import_priv_keytype())
        {
          v7 = ccec_cp_for_oid_0(*(uint64_t *)valuePtr);
          if (!v7)
          {
            ccec_cp_192();
            MEMORY[0x18D76FFB0]();
            MEMORY[0x18D76FFBC]();
            MEMORY[0x18D76FFC8]();
            ccec_cp_521();
            v7 = ccec_curve_for_length_lookup();
            if (!v7)
              return 4294941021;
          }
          *v6 = v7;
          key_fips = ccec_der_import_priv();
          goto LABEL_23;
        }
      }
      return 4294967246;
    }
    Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("bsiz"));
    if (Value)
    {
      v10 = Value;
      v11 = CFGetTypeID(Value);
      if (v11 == CFNumberGetTypeID())
      {
        *(_QWORD *)valuePtr = 0xAAAAAAAAAAAAAAAALL;
        CFNumberGetValue(v10, kCFNumberCFIndexType, valuePtr);
      }
      else
      {
        v14 = CFGetTypeID(v10);
        if (v14 == CFStringGetTypeID())
          CFStringGetIntValue((CFStringRef)v10);
      }
    }
    if (ccec_get_cp())
    {
      ccrng();
      key_fips = ccec_generate_key_fips();
LABEL_23:
      if (key_fips)
        return 4294967246;
      else
        return 0;
    }
    secLogObjForScope("SecWarning");
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)valuePtr = 138412290;
      *(_QWORD *)&valuePtr[4] = theDict;
      _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEFAULT, "Invalid or missing key size in: %@", valuePtr, 0xCu);
    }

    return 4294941985;
  }
  return v13;
}

uint64_t SecECPrivateKeyDestroy(uint64_t result)
{
  if (**(_QWORD **)(result + 24))
    return cc_clear();
  return result;
}

unint64_t SecECPrivateKeyBlockSize()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

CFDictionaryRef SecECPrivateKeyCopyAttributeDictionary(const void *a1)
{
  __CFData *v2;
  CFDictionaryRef v3;

  v2 = SecECPrivateKeyCopyExternalRepresentation();
  v3 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)CFSTR("73"), v2);
  if (v2)
    CFRelease(v2);
  return v3;
}

CFStringRef SecECPrivateKeyCopyKeyDescription(__SecKey *a1)
{
  unsigned int v2;
  const char *v3;
  const __CFAllocator *v4;
  uint64_t AlgorithmId;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(__SecKey *);

  v2 = SecECKeyGetNamedCurve(a1) - 23;
  if (v2 > 2)
    v3 = "kSecECCurveNone";
  else
    v3 = off_1E1FD5C78[v2];
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  AlgorithmId = SecKeyGetAlgorithmId((uint64_t)a1);
  v6 = (unsigned int *)*((_QWORD *)a1 + 2);
  v7 = *((_QWORD *)v6 + 1);
  v8 = *v6;
  _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyGetBlockSize");
  v9 = *(uint64_t (**)(__SecKey *))(*((_QWORD *)a1 + 2) + 80);
  if (v9)
    v9 = (uint64_t (*)(__SecKey *))(8 * v9(a1));
  return CFStringCreateWithFormat(v4, 0, CFSTR("<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>"), v3, AlgorithmId, v7, v8, v9, a1);
}

uint64_t SecECPrivateKeyCopyPublicOctets(const void *a1, __CFData **a2)
{
  const __CFAllocator *v3;
  __CFData *v4;

  v3 = CFGetAllocator(a1);
  v4 = SecECPublicKeyExport(v3);
  *a2 = v4;
  if (v4)
    return 0;
  else
    return 4294941021;
}

__CFData *SecECKeyCopyUnwrapKey(__SecKey *a1, uint64_t a2, const __CFData *a3, const __CFDictionary *a4, __CFDictionary **a5, __CFString **a6)
{
  int NamedCurve;
  uint64_t v11;
  uint64_t v12;
  const void *Value;
  const void *v14;
  const __CFData *v15;
  const __CFData *v16;
  CFTypeID v17;
  __CFData *Mutable;
  const __CFNumber *v20;
  const __CFNumber *v21;
  CFTypeID v22;
  unint64_t Length;
  CFMutableDictionaryRef v24;
  __CFDictionary *v25;
  CFNumberRef v26;
  CFNumberRef v27;
  CFIndex v28;
  const UInt8 *BytePtr;
  int valuePtr;
  char v31;

  v31 = 0;
  valuePtr = 0;
  NamedCurve = SecECKeyGetNamedCurve(a1);
  v11 = MEMORY[0x1E0C81D60];
  if (NamedCurve != 25)
    v11 = 0;
  if (NamedCurve == 23)
    v12 = MEMORY[0x1E0C81D58];
  else
    v12 = v11;
  if (!v12)
  {
    SecError(-4, a6, CFSTR("unsupported curve"));
    return 0;
  }
  Value = CFDictionaryGetValue(a4, CFSTR("kSecKeyWrapPGPWrapAlg"));
  if (!Value)
  {
    SecError(-4, a6, CFSTR("no wrap alg"));
    return 0;
  }
  v14 = Value;
  if (!CFEqual(Value, CFSTR("kSecKeyWrapPGPECWrapDigestSHA256KekAES128"))
    && !CFEqual(v14, CFSTR("kSecKeyWrapPGPECWrapDigestSHA512KekAES256")))
  {
    SecError(-4, a6, CFSTR("unknown wrap alg"));
    return 0;
  }
  v15 = (const __CFData *)CFDictionaryGetValue(a4, CFSTR("kSecKeyWrapPGPFingerprint"));
  if (!v15 || (v16 = v15, v17 = CFGetTypeID(v15), v17 != CFDataGetTypeID()) || CFDataGetLength(v16) <= 19)
  {
    SecError(-4, a6, CFSTR("invalid fingerprint"));
    return 0;
  }
  v20 = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("kSecKeyWrapPGPECFlags"));
  if (v20)
  {
    v21 = v20;
    v22 = CFGetTypeID(v20);
    if (v22 != CFNumberGetTypeID())
    {
      SecError(-4, a6, CFSTR("unknown flags"));
      return 0;
    }
    if (!CFNumberGetValue(v21, kCFNumberSInt32Type, &valuePtr))
    {
      SecError(-4, a6, CFSTR("invalid flags: %@"), v21);
      return 0;
    }
  }
  Length = CFDataGetLength(a3);
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  CFDataSetLength(Mutable, Length);
  if (Mutable)
  {
    CFDataGetMutableBytePtr(Mutable);
    CFDataGetBytePtr(v16);
    v28 = CFDataGetLength(a3);
    BytePtr = CFDataGetBytePtr(a3);
    if (ccec_rfc6637_unwrap_key())
    {
      CFRelease(Mutable);
      SecError(-4, a6, CFSTR("failed to wrap key"), v28, BytePtr);
      return 0;
    }
    if (Length > CFDataGetLength(Mutable))
      __security_simulatecrash(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
    CFDataSetLength(Mutable, Length);
    if (a5)
    {
      v24 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v24)
      {
        v25 = v24;
        v26 = CFNumberCreate(0, kCFNumberSInt8Type, &v31);
        if (v26)
        {
          v27 = v26;
          CFDictionarySetValue(v25, CFSTR("kSecKeyWrapPGPSymAlg"), v26);
          CFRelease(v27);
        }
        *a5 = v25;
      }
    }
  }
  return Mutable;
}

__CFData *SecECPrivateKeyCopyExternalRepresentation()
{
  uint64_t v0;
  uint64_t v1;
  __CFData *Mutable;

  v0 = cczp_bitlen();
  v1 = cczp_bitlen();
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  CFDataSetLength(Mutable, (((unint64_t)(v1 + 7) >> 2) | 1) + ((unint64_t)(v0 + 7) >> 3));
  CFDataGetMutableBytePtr(Mutable);
  ccec_export_pub();
  CFDataGetMutableBytePtr(Mutable);
  cczp_bitlen();
  ccn_write_uint_padded();
  return Mutable;
}

__CFData *SecECPrivateKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  __CFData *Mutable;
  uint64_t v14;
  uint64_t CPForPublicSize;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  CFIndex v21;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  Mutable = (__CFData *)*MEMORY[0x1E0C9B0D0];
  if (a2 != 4)
  {
    if (a2 || !CFEqual(cf1, CFSTR("algid:sign:ECDSA:digest-X962")))
      return Mutable;
    if (!a5)
    {
      v26 = (((unint64_t)(cczp_bitlen() + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL) + 9;
      Mutable = CFDataCreateMutable(0, 0);
      CFDataSetLength(Mutable, v26);
      CFDataGetLength(a6);
      CFDataGetBytePtr(a6);
      CFDataGetMutableBytePtr(Mutable);
      ccrng();
      v14 = ccec_sign();
      if ((_DWORD)v14)
      {
        v25 = v14;
        if (Mutable)
          CFRelease(Mutable);
        SecError(-50, a8, CFSTR("%@: X962 signing failed (ccerr %d)"), a1, v25, v26, v27);
        return 0;
      }
      else
      {
        CFDataSetLength(Mutable, v26);
      }
      return Mutable;
    }
    return (__CFData *)*MEMORY[0x1E0C9AE50];
  }
  if (!CFEqual(cf1, CFSTR("algid:keyexchange:ECDH")) && !CFEqual(cf1, CFSTR("algid:keyexchange:ECDHC")))
    return Mutable;
  if (a5)
    return (__CFData *)*MEMORY[0x1E0C9AE50];
  CFDataGetLength(a6);
  CPForPublicSize = getCPForPublicSize();
  if (CPForPublicSize)
  {
    v16 = (_QWORD *)CPForPublicSize;
    MEMORY[0x1E0C80A78](CPForPublicSize);
    if (v18 >= 0x10)
    {
      v19 = (unint64_t *)((char *)&v26 - v17);
      do
      {
        *v19 = 0xAAAAAAAAAAAAAAAALL;
        v19[1] = 0xAAAAAAAAAAAAAAAALL;
        v19 += 2;
        v17 -= 16;
      }
      while (v17);
    }
    CFDataGetLength(a6);
    CFDataGetBytePtr(a6);
    v20 = ccec_import_pub();
    if ((_DWORD)v20)
    {
      SecError(-50, a8, CFSTR("ECpriv sharedsecret: bad public key (err %d)"), v20);
    }
    else
    {
      v21 = 8 * *v16;
      v26 = v21;
      if (SecCFAllocatorZeroize_sOnce != -1)
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
      Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
      CFDataSetLength(Mutable, v21);
      CFDataGetMutableBytePtr(Mutable);
      ccrng();
      v22 = ccecdh_compute_shared_secret();
      if ((_DWORD)v22)
      {
        v24 = v22;
        if (Mutable)
          CFRelease(Mutable);
        SecError(-26275, a8, CFSTR("ECpriv failed to compute shared secret (err %d)"), v24);
        return 0;
      }
      else
      {
        CFDataSetLength(Mutable, v26);
      }
    }
  }
  else
  {
    SecError(-50, a8, CFSTR("ECpriv sharedsecret: bad public key"));
  }
  return Mutable;
}

_QWORD *SecKeyCreateECPublicKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecECPublicKeyDescriptor, a2, a3, a4);
}

_QWORD *SecKeyCreateECPrivateKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecECPrivateKeyDescriptor, a2, a3, a4);
}

uint64_t SecECKeyGeneratePair(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  _QWORD *v7;
  const void *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t result;

  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v6 = SecCFAllocatorZeroize_sAllocator;
  v7 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)&kSecECPrivateKeyDescriptor, a1, 0, 5);
  if (!v7)
    return 4294967246;
  v8 = v7;
  v9 = SecKeyCreate(v6, (uint64_t)&kSecECPublicKeyDescriptor, v7[3], 0, 6);
  if (!v9)
  {
    v10 = 4294967246;
LABEL_12:
    CFRelease(v8);
    return v10;
  }
  if (a2)
  {
    *a2 = v9;
    v9 = 0;
  }
  if (a3)
  {
    *a3 = v8;
    v8 = 0;
  }
  if (v9)
    CFRelease(v9);
  v10 = 0;
  result = 0;
  if (v8)
    goto LABEL_12;
  return result;
}

BOOL SecECDoWithFullKey(uint64_t a1, __CFString **a2, uint64_t a3)
{
  if (*(_UNKNOWN **)(a1 + 16) != &kSecECPrivateKeyDescriptor)
    return SecError(-50, a2, CFSTR("Not an EC Full Key object, sorry can't do."));
  (*(void (**)(uint64_t, _QWORD))(a3 + 16))(a3, *(_QWORD *)(a1 + 24));
  return 1;
}

BOOL SecECDoWithPubKey(uint64_t a1, __CFString **a2, uint64_t a3)
{
  if (*(_UNKNOWN **)(a1 + 16) != &kSecECPublicKeyDescriptor)
    return SecError(-50, a2, CFSTR("Not an EC Public Key object, sorry can't do."));
  (*(void (**)(uint64_t, _QWORD))(a3 + 16))(a3, *(_QWORD *)(a1 + 24));
  return 1;
}

uint64_t SecCurve448PublicKeyInit(uint64_t a1, void *__src, size_t a3, int a4)
{
  void *v4;
  BOOL v5;
  uint64_t v6;
  uint64_t result;
  void *v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  const char *v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a4 != 6)
  {
    if (a4 != 7)
      return 4294967246;
    v4 = *(void **)(a1 + 16);
    v5 = v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor;
    v6 = 56;
    if (v5)
      v6 = 57;
    if (v6 == a3)
    {
      memcpy(*(void **)(a1 + 24), __src, a3);
      return 0;
    }
    return 4294941021;
  }
  v8 = *(void **)(a1 + 16);
  v9 = v8 == &kSecEd448PublicKeyDescriptor || v8 == &kSecEd448PrivateKeyDescriptor;
  v10 = v9;
  v11 = 56;
  if (v9)
    v11 = 57;
  if (v11 != a3)
    return 4294941021;
  ccrng();
  if (v10)
  {
    result = cced448_make_pub();
    if ((_DWORD)result)
    {
      v12 = result;
      _SECKEY_LOG_8044();
      v13 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v16 = 67109120;
        v17 = v12;
        v14 = "cced448_make_pub() failed, error %d";
LABEL_30:
        _os_log_error_impl(&dword_18A900000, v13, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v16, 8u);
        goto LABEL_27;
      }
      goto LABEL_27;
    }
  }
  else
  {
    result = cccurve448_make_pub();
    if ((_DWORD)result)
    {
      v15 = result;
      _SECKEY_LOG_8044();
      v13 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v16 = 67109120;
        v17 = v15;
        v14 = "cccurve448_make_pub() failed, error %d";
        goto LABEL_30;
      }
LABEL_27:

      return 4294941021;
    }
  }
  return result;
}

uint64_t SecCurve448PublicKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve448PublicKeyBlockSize(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor)
    return 57;
  else
    return 56;
}

__CFDictionary *SecCurve448PublicKeyCopyAttributeDictionary(_QWORD *a1)
{
  void *v1;
  const __CFString *v3;
  const __CFDictionary *v4;
  __CFDictionary *MutableCopy;

  v1 = (void *)a1[2];
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor)
    v3 = CFSTR("107");
  else
    v3 = CFSTR("108");
  v4 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v3, 0);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v4);
  CFDictionarySetValue(MutableCopy, CFSTR("drve"), (const void *)*MEMORY[0x1E0C9AE40]);
  if (v4)
    CFRelease(v4);
  return MutableCopy;
}

uint64_t SecCurve448PublicKeyCopyKeyDescription(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t AlgorithmId;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t);
  BOOL v9;
  const char *v10;

  v2 = *(void **)(a1 + 16);
  v3 = (void *)MEMORY[0x1E0CB3940];
  AlgorithmId = SecKeyGetAlgorithmId(a1);
  v5 = *(unsigned int **)(a1 + 16);
  v6 = *((_QWORD *)v5 + 1);
  v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  v8 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 80);
  if (v8)
    v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  v9 = v2 == &kSecEd448PrivateKeyDescriptor || v2 == &kSecEd448PublicKeyDescriptor;
  v10 = "kSecX448";
  if (v9)
    v10 = "kSecEd448";
  objc_msgSend(v3, "stringWithFormat:", CFSTR("<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>"), v10, AlgorithmId, v6, v7, v8, a1);
  return objc_claimAutoreleasedReturnValue();
}

uint64_t SecCurve448KeyGetAlgorithmID(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor)
    return 6;
  else
    return 7;
}

uint64_t SecCurve448PublicKeyCopyPublicOctets(_QWORD *a1, CFDataRef *a2)
{
  const UInt8 *v4;
  const __CFAllocator *v5;
  void *v6;
  CFIndex v8;
  CFDataRef v9;

  v4 = (const UInt8 *)a1[3];
  v5 = CFGetAllocator(a1);
  v6 = (void *)a1[2];
  if (v6 == &kSecEd448PrivateKeyDescriptor || v6 == &kSecEd448PublicKeyDescriptor)
    v8 = 57;
  else
    v8 = 56;
  v9 = CFDataCreate(v5, v4, v8);
  *a2 = v9;
  if (v9)
    return 0;
  else
    return 4294941021;
}

uint64_t SecCurve448KeyCopyWrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  SecError(-4, a6, CFSTR("unsupported curve"));
  return 0;
}

CFDataRef SecCurve448PublicKeyCopyExternalRepresentation(_QWORD *a1)
{
  const UInt8 *v2;
  const __CFAllocator *v3;
  void *v4;
  CFIndex v6;

  v2 = (const UInt8 *)a1[3];
  v3 = CFGetAllocator(a1);
  v4 = (void *)a1[2];
  if (v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor)
    v6 = 57;
  else
    v6 = 56;
  return CFDataCreate(v3, v2, v6);
}

uint64_t SecCurve448PublicKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, const __CFData *a7, __CFString **a8)
{
  void *v8;
  BOOL v9;
  uint64_t v14;
  CFIndex Length;
  uint64_t v17;

  v8 = *(void **)(a1 + 16);
  v9 = v8 == &kSecEd448PublicKeyDescriptor || v8 == &kSecEd448PrivateKeyDescriptor;
  if (!v9 || a2 != 1 || !CFEqual(cf1, CFSTR("algid:sign:EdDSA:message-Curve448:SHAKE256")))
  {
    v14 = MEMORY[0x1E0C9B0D0];
    return *(_QWORD *)v14;
  }
  if (a5)
  {
LABEL_9:
    v14 = MEMORY[0x1E0C9AE50];
    return *(_QWORD *)v14;
  }
  Length = CFDataGetLength(a7);
  CFDataGetBytePtr(a7);
  CFDataGetLength(a6);
  CFDataGetBytePtr(a6);
  if (Length == 114)
  {
    v17 = cced448_verify();
    if (!(_DWORD)v17)
      goto LABEL_9;
    SecError(-67808, a8, CFSTR("Ed448 signature verification failed (ccerr %d)"), v17);
  }
  else
  {
    SecError(-67808, a8, CFSTR("Ed448 signature verification failed (invalid signature length)"));
  }
  return 0;
}

uint64_t SecCurve448PrivateKeyInit(uint64_t a1, const void *a2, size_t a3, int a4)
{
  void *v4;
  BOOL v5;
  uint64_t v6;
  void *v7;
  int key_pair;
  int v11;
  NSObject *v12;
  const char *v13;
  int v14;
  int v15;
  uint8_t buf[4];
  int v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[25];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a4 == 5)
  {
    v7 = *(void **)(a1 + 16);
    if (v7 == &kSecEd448PublicKeyDescriptor || v7 == &kSecEd448PrivateKeyDescriptor)
    {
      v19 = 0u;
      memset(v20, 0, sizeof(v20));
      v18 = 0u;
      ccrng();
      key_pair = cced448_make_key_pair();
      if (!key_pair)
      {
LABEL_19:
        cc_clear();
        return 0;
      }
      v14 = key_pair;
      _SECKEY_LOG_8044();
      v12 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
LABEL_25:

        return 4294941021;
      }
      *(_DWORD *)buf = 67109120;
      v17 = v14;
      v13 = "cced448_make_key_pair() failed, error %d";
    }
    else
    {
      v19 = 0u;
      memset(v20, 0, 24);
      v18 = 0u;
      ccrng();
      v11 = cccurve448_make_key_pair();
      if (!v11)
        goto LABEL_19;
      v15 = v11;
      _SECKEY_LOG_8044();
      v12 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        goto LABEL_25;
      *(_DWORD *)buf = 67109120;
      v17 = v15;
      v13 = "ccec448_make_key_pair() failed, error %d";
    }
    _os_log_error_impl(&dword_18A900000, v12, OS_LOG_TYPE_ERROR, v13, buf, 8u);
    goto LABEL_25;
  }
  if (a4 != 7)
    return 4294899625;
  v4 = *(void **)(a1 + 16);
  v5 = v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor;
  v6 = 56;
  if (v5)
    v6 = 57;
  if (v6 != a3)
    return 4294941021;
  memcpy(*(void **)(a1 + 24), a2, a3);
  return 0;
}

uint64_t SecCurve448PrivateKeyDestroy()
{
  return cc_clear();
}

uint64_t SecCurve448PrivateKeyBlockSize(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 16);
  if (v1 == &kSecEd448PrivateKeyDescriptor || v1 == &kSecEd448PublicKeyDescriptor)
    return 57;
  else
    return 56;
}

CFDictionaryRef SecCurve448PrivateKeyCopyAttributeDictionary(_QWORD *a1)
{
  const UInt8 *v2;
  const __CFAllocator *v3;
  void *v4;
  CFIndex v6;
  const __CFData *v7;
  void *v8;
  const __CFString *v10;
  CFDictionaryRef v11;

  v2 = (const UInt8 *)a1[3];
  v3 = CFGetAllocator(a1);
  v4 = (void *)a1[2];
  if (v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor)
    v6 = 57;
  else
    v6 = 56;
  v7 = CFDataCreate(v3, v2, v6);
  v8 = (void *)a1[2];
  if (v8 == &kSecEd448PrivateKeyDescriptor || v8 == &kSecEd448PublicKeyDescriptor)
    v10 = CFSTR("107");
  else
    v10 = CFSTR("108");
  v11 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)v10, v7);
  if (v7)
    CFRelease(v7);
  return v11;
}

CFStringRef SecCurve448PrivateKeyCopyKeyDescription(uint64_t a1)
{
  void *v2;
  const __CFAllocator *v3;
  uint64_t AlgorithmId;
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t);
  BOOL v9;
  const char *v10;

  v2 = *(void **)(a1 + 16);
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  AlgorithmId = SecKeyGetAlgorithmId(a1);
  v5 = *(unsigned int **)(a1 + 16);
  v6 = *((_QWORD *)v5 + 1);
  v7 = *v5;
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  v8 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 80);
  if (v8)
    v8 = (uint64_t (*)(uint64_t))(8 * v8(a1));
  v9 = v2 == &kSecEd448PrivateKeyDescriptor || v2 == &kSecEd448PublicKeyDescriptor;
  v10 = "kSecX448";
  if (v9)
    v10 = "kSecEd448";
  return CFStringCreateWithFormat(v3, 0, CFSTR("<SecKeyRef curve type: %s, algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>"), v10, AlgorithmId, v6, v7, v8, a1);
}

uint64_t SecCurve448PrivateKeyCopyPublicOctets(_QWORD *a1, CFDataRef *a2)
{
  void *v4;
  const __CFAllocator *v6;
  const __CFAllocator *v9;
  __int128 v10;
  __int128 v11;
  _BYTE v12[25];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = (void *)a1[2];
  if (v4 == &kSecEd448PublicKeyDescriptor || v4 == &kSecEd448PrivateKeyDescriptor)
  {
    v11 = 0u;
    memset(v12, 0, sizeof(v12));
    v10 = 0u;
    ccrng();
    if (cced448_make_pub())
      return 4294941020;
    v6 = CFGetAllocator(a1);
    *a2 = CFDataCreate(v6, (const UInt8 *)&v10, 57);
  }
  else
  {
    v11 = 0u;
    memset(v12, 0, 24);
    v10 = 0u;
    ccrng();
    if (cccurve448_make_pub())
      return 4294941020;
    v9 = CFGetAllocator(a1);
    *a2 = CFDataCreate(v9, (const UInt8 *)&v10, 56);
  }
  cc_clear();
  if (*a2)
    return 0;
  else
    return 4294941021;
}

uint64_t SecCurve448KeyCopyUnwrapKey(int a1, int a2, int a3, int a4, int a5, __CFString **a6)
{
  SecError(-4, a6, CFSTR("unsupported curve"));
  return 0;
}

CFDataRef SecCurve448PrivateKeyCopyExternalRepresentation(_QWORD *a1)
{
  const UInt8 *v2;
  const __CFAllocator *v3;
  void *v4;
  CFIndex v6;

  v2 = (const UInt8 *)a1[3];
  v3 = CFGetAllocator(a1);
  v4 = (void *)a1[2];
  if (v4 == &kSecEd448PrivateKeyDescriptor || v4 == &kSecEd448PublicKeyDescriptor)
    v6 = 57;
  else
    v6 = 56;
  return CFDataCreate(v3, v2, v6);
}

__CFData *SecCurve448PrivateKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  __CFData *Mutable;
  void *v14;
  BOOL v15;
  uint64_t v16;
  void *v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v21;

  Mutable = (__CFData *)*MEMORY[0x1E0C9B0D0];
  if (a2 != 4)
  {
    if (a2)
      return Mutable;
    v14 = *(void **)(a1 + 16);
    v15 = v14 == &kSecEd448PublicKeyDescriptor || v14 == &kSecEd448PrivateKeyDescriptor;
    if (!v15 || !CFEqual(cf1, CFSTR("algid:sign:EdDSA:message-Curve448:SHAKE256")))
      return Mutable;
    if (!a5)
    {
      ccrng();
      if (cced448_make_pub())
      {
        SecError(-2070, a8, CFSTR("%@: Failed to get public key from private key"), a1);
        return Mutable;
      }
      Mutable = CFDataCreateMutable(0, 0);
      CFDataSetLength(Mutable, 114);
      if (!Mutable)
      {
        SecError(-108, a8, CFSTR("%@: Failed to create buffer for a signature"), a1);
        return Mutable;
      }
      CFDataGetLength(a6);
      CFDataGetBytePtr(a6);
      CFDataGetMutableBytePtr(Mutable);
      ccrng();
      v16 = cced448_sign();
      cc_clear();
      if ((_DWORD)v16)
      {
        CFRelease(Mutable);
        SecError(-50, a8, CFSTR("%@: Ed448 signing failed (ccerr %d)"), a1, v16, 0, 0, 0, 0, 0, 0, 0, 0);
        return 0;
      }
      return Mutable;
    }
    return (__CFData *)*MEMORY[0x1E0C9AE50];
  }
  v17 = *(void **)(a1 + 16);
  v18 = v17 == &kSecEd448PublicKeyDescriptor || v17 == &kSecEd448PrivateKeyDescriptor;
  if (v18 || !CFEqual(cf1, CFSTR("algid:keyexchange:ECDH")) && !CFEqual(cf1, CFSTR("algid:keyexchange:ECDHC")))
    return Mutable;
  if (a5)
    return (__CFData *)*MEMORY[0x1E0C9AE50];
  CFDataGetBytePtr(a6);
  if (CFDataGetLength(a6) == 56)
  {
    if (SecCFAllocatorZeroize_sOnce != -1)
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
    Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
    CFDataSetLength(Mutable, 56);
    CFDataSetLength(Mutable, 56);
    ccrng();
    CFDataGetMutableBytePtr(Mutable);
    v19 = cccurve448();
    if ((_DWORD)v19)
    {
      v21 = v19;
      if (Mutable)
        CFRelease(Mutable);
      SecError(-50, a8, CFSTR("%@: X448 DH failed (ccerr %d)"), a1, v21);
      return 0;
    }
  }
  else
  {
    SecError(-50, a8, CFSTR("X448priv sharedsecret: bad public key"));
  }
  return Mutable;
}

id _SECKEY_LOG_8044()
{
  if (_SECKEY_LOG_once_8047 != -1)
    dispatch_once(&_SECKEY_LOG_once_8047, &__block_literal_global_8048);
  return (id)_SECKEY_LOG_log_8049;
}

uint64_t curve448KeyGeneratePair(uint64_t a1, _QWORD *a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v8;
  void *v9;
  _QWORD *v10;
  const void *v11;
  void *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t result;

  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v8 = SecCFAllocatorZeroize_sAllocator;
  if (a4 == 6)
    v9 = &kSecEd448PrivateKeyDescriptor;
  else
    v9 = &kSecX448PrivateKeyDescriptor;
  v10 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)v9, a1, 0, 5);
  if (!v10)
    return 4294967246;
  v11 = v10;
  if (a4 == 6)
    v12 = &kSecEd448PublicKeyDescriptor;
  else
    v12 = &kSecX448PublicKeyDescriptor;
  if (a4 == 6)
    v13 = 57;
  else
    v13 = 56;
  v14 = SecKeyCreate(v8, (uint64_t)v12, v10[3], v13, 6);
  if (!v14)
  {
    v15 = 4294967246;
LABEL_21:
    CFRelease(v11);
    return v15;
  }
  if (a2)
  {
    *a2 = v14;
    v14 = 0;
  }
  if (a3)
  {
    *a3 = v11;
    v11 = 0;
  }
  if (v14)
    CFRelease(v14);
  v15 = 0;
  result = 0;
  if (v11)
    goto LABEL_21;
  return result;
}

id SecEMCSCreateDerivedEMCSKey(void *a1, void *a2)
{
  id v3;
  const __CFDictionary *v4;
  const void *Value;
  const void *v6;
  const void *v7;
  CFTypeID v8;
  void *v9;
  CFTypeID v10;
  CFTypeID v11;
  __CFData *DerivedKey;
  __CFData *v13;
  uint64_t valuePtr;

  v3 = a2;
  valuePtr = 0xAAAAAAAAAAAAAAAALL;
  v4 = a1;
  Value = CFDictionaryGetValue(v4, CFSTR("salt"));
  v6 = CFDictionaryGetValue(v4, CFSTR("iter"));
  v7 = CFDictionaryGetValue(v4, CFSTR("wkey"));

  if (!Value)
    goto LABEL_10;
  v8 = CFGetTypeID(Value);
  v9 = 0;
  if (v8 == CFDataGetTypeID())
  {
    if (v6)
    {
      v10 = CFGetTypeID(v6);
      v9 = 0;
      if (v10 == CFNumberGetTypeID())
      {
        if (v7)
        {
          v11 = CFGetTypeID(v7);
          if (v11 == CFDataGetTypeID())
          {
            if (CFNumberGetValue((CFNumberRef)v6, kCFNumberLongType, &valuePtr))
            {
              DerivedKey = CreateDerivedKey((const __CFData *)Value, valuePtr, v3);
              if (DerivedKey)
              {
                v13 = DerivedKey;
                CopyUnwrappedKey(DerivedKey, (const __CFData *)v7);
                v9 = (void *)objc_claimAutoreleasedReturnValue();
                CFRelease(v13);
                goto LABEL_11;
              }
            }
          }
LABEL_10:
          v9 = 0;
        }
      }
    }
  }
LABEL_11:

  return v9;
}

__CFData *CreateDerivedKey(const __CFData *a1, uint64_t a2, void *a3)
{
  id v5;
  __CFData *Mutable;
  __CFData *v7;
  id v8;

  v5 = a3;
  if (a2 < 1000 || CFDataGetLength(a1) < 16)
    goto LABEL_8;
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 16);
  v7 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, 16);
    ccsha256_di();
    v8 = objc_retainAutorelease(v5);
    strlen((const char *)objc_msgSend(v8, "UTF8String"));
    objc_msgSend(objc_retainAutorelease(v8), "UTF8String");
    CFDataGetLength(a1);
    CFDataGetBytePtr(a1);
    CFDataGetMutableBytePtr(v7);
    if (ccpbkdf2_hmac())
    {
      CFRelease(v7);
LABEL_8:
      v7 = 0;
    }
  }

  return v7;
}

__CFData *CopyUnwrappedKey(const __CFData *a1, const __CFData *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  const __CFAllocator *v8;
  CFIndex v9;
  __CFData *Mutable;
  __CFData *v11;
  uint64_t v12;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  ccaes_ecb_decrypt_mode();
  v4 = ccecb_context_size();
  MEMORY[0x1E0C80A78](v4);
  if (v6 >= 0x10)
  {
    v7 = (_QWORD *)((char *)v14 - v5);
    do
    {
      *v7 = 0xAAAAAAAAAAAAAAAALL;
      v7[1] = 0xAAAAAAAAAAAAAAAALL;
      v7 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  if (CFDataGetLength(a2) < 8 || CFDataGetLength(a1) != 16)
    goto LABEL_11;
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccecb_init();
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v8 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  CFDataGetLength(a2);
  v9 = ccwrap_unwrapped_size();
  Mutable = CFDataCreateMutable(v8, 0);
  CFDataSetLength(Mutable, v9);
  if (!Mutable)
    goto LABEL_11;
  v14[0] = 0;
  CFDataGetLength(a2);
  CFDataGetBytePtr(a2);
  v11 = objc_retainAutorelease(Mutable);
  -[__CFData mutableBytes](v11, "mutableBytes");
  if (ccwrap_auth_decrypt())
  {

LABEL_11:
    v11 = 0;
    goto LABEL_14;
  }
  v12 = v14[0];
  if (v12 != -[__CFData length](v11, "length"))
    __security_simulatecrash(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
LABEL_14:
  ccecb_context_size();
  cc_clear();
  return v11;
}

__CFData *SecEMCSCreateNewiDMSKey(void *a1, void *a2, void *a3, _QWORD *a4)
{
  id v7;
  const __CFData *v8;
  id v9;
  CFTypeID v10;
  __CFData *Mutable;
  __CFData *v12;
  __CFData *v13;
  __CFData *v14;
  CFNumberRef v16;
  CFNumberRef v17;
  __CFData *MutableCopy;
  __CFData *DerivedKey;
  CFDictionaryRef v20;
  uint64_t v21;
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a2;
  v9 = a3;
  v21 = 1000;
  if (a4)
    *a4 = 0;
  if (!v8 || (v10 = CFGetTypeID(v8), v10 == CFDataGetTypeID()) && CFDataGetLength(v8) == 16)
  {
    Mutable = CFDataCreateMutable(0, 0);
    CFDataSetLength(Mutable, 16);
    if (!Mutable)
    {
      v12 = 0;
      goto LABEL_12;
    }
    CFDataGetLength(Mutable);
    CFDataGetMutableBytePtr(Mutable);
    if (CCRandomCopyBytes() || (v16 = CFNumberCreate(0, kCFNumberLongType, &v21)) == 0)
    {
      v12 = 0;
      v13 = Mutable;
LABEL_9:
      CFRelease(v13);
LABEL_12:
      v14 = v12;
      goto LABEL_13;
    }
    v17 = v16;
    if (SecCFAllocatorZeroize_sOnce != -1)
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
    if (v8)
    {
      MutableCopy = CFDataCreateMutableCopy((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0, v8);
    }
    else
    {
      MutableCopy = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
      CFDataSetLength(MutableCopy, 16);
      if (!MutableCopy
        || (CFDataGetLength(MutableCopy), CFDataGetMutableBytePtr(MutableCopy), CCRandomCopyBytes()))
      {
        v13 = 0;
        goto LABEL_27;
      }
    }
    DerivedKey = CreateDerivedKey(Mutable, 1000, v9);
    v12 = DerivedKey;
    if (!DerivedKey)
    {
      v13 = 0;
      goto LABEL_29;
    }
    v13 = CopyWrappedKey(DerivedKey, MutableCopy);
    CFRelease(v12);
    if (v13)
    {
      keys[0] = CFSTR("salt");
      keys[1] = CFSTR("iter");
      keys[2] = CFSTR("wkey");
      values[0] = Mutable;
      values[1] = v17;
      values[2] = v13;
      v20 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      v12 = v20;
      if (a4 && v20)
      {
        CFRetain(MutableCopy);
        *a4 = (id)objc_claimAutoreleasedReturnValue();
      }
LABEL_29:
      CFRelease(Mutable);
      CFRelease(v17);
      if (MutableCopy)
        CFRelease(MutableCopy);
      if (!v13)
        goto LABEL_12;
      goto LABEL_9;
    }
LABEL_27:
    v12 = 0;
    goto LABEL_29;
  }
  v14 = 0;
LABEL_13:

  return v14;
}

__CFData *CopyWrappedKey(const __CFData *a1, const __CFData *a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  CFIndex v8;
  __CFData *Mutable;
  uint64_t v10;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  ccaes_ecb_encrypt_mode();
  v4 = ccecb_context_size();
  MEMORY[0x1E0C80A78](v4);
  if (v6 >= 0x10)
  {
    v7 = (_QWORD *)((char *)v12 - v5);
    do
    {
      *v7 = 0xAAAAAAAAAAAAAAAALL;
      v7[1] = 0xAAAAAAAAAAAAAAAALL;
      v7 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  if (CFDataGetLength(a1) != 16)
    goto LABEL_8;
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccecb_init();
  CFDataGetLength(a2);
  v8 = ccwrap_wrapped_size();
  Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, v8);
  v12[0] = 0;
  CFDataGetLength(a2);
  CFDataGetBytePtr(a2);
  CFDataGetMutableBytePtr(Mutable);
  if (ccwrap_auth_encrypt())
  {
    if (Mutable)
    {
      CFRelease(Mutable);
LABEL_8:
      Mutable = 0;
    }
  }
  else
  {
    v10 = v12[0];
    if (v10 != CFDataGetLength(Mutable))
      __security_simulatecrash(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
  }
  ccecb_context_size();
  cc_clear();
  return Mutable;
}

uint64_t SecKyberPublicKeyInit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  size_t v6;
  int v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  int v12;
  int v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    result = 0;
    *(_QWORD *)(a1 + 24) = a2;
    return result;
  }
  cckem_kyber768();
  if (cckem_pubkey_nbytes_info() == a3)
  {
    cckem_kyber768();
    goto LABEL_7;
  }
  cckem_kyber1024();
  if (cckem_pubkey_nbytes_info() == a3)
  {
    cckem_kyber1024();
LABEL_7:
    v6 = cckem_sizeof_pub_ctx();
    *(_QWORD *)(a1 + 24) = malloc_type_calloc(1uLL, v6, 0x87E28B40uLL);
    result = cckem_import_pubkey();
    if (!(_DWORD)result)
      return result;
    v7 = result;
    secLogObjForScope("SecWarning");
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 67109376;
      v13 = a3;
      v14 = 1024;
      v15 = v7;
      v9 = "Kyber pubkey size=%dbytes import failed: %d";
      v10 = v8;
      v11 = 14;
LABEL_12:
      _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v12, v11);
      goto LABEL_13;
    }
    goto LABEL_13;
  }
  secLogObjForScope("SecWarning");
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    v12 = 67109120;
    v13 = a3;
    v9 = "Kyber pubkey size=%dbytes is invalid";
    v10 = v8;
    v11 = 8;
    goto LABEL_12;
  }
LABEL_13:

  return 4294967246;
}

void SecKyberPublicKeyDestroy(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
  {
    cckem_sizeof_pub_ctx();
    free(v1);
  }
}

uint64_t SecKyberPublicKeyBlockSize()
{
  return cckem_pubkey_nbytes_ctx();
}

uint64_t SecKyberPublicKeyCopyAttributeDictionary(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  __CFString *v3;
  uint64_t v4;
  __CFString *v5;
  NSObject *v6;
  __CFData *v7;
  const __CFAllocator *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v19;
  __CFString *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  __CFData *v25;
  void *v26;
  void *v27;
  void *v28;
  __CFData *v29;
  uint8_t buf[16];
  _QWORD v31[23];
  _QWORD v32[25];

  v32[23] = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 24);
  v2 = cckem_pubkey_nbytes_ctx();
  cckem_kyber768();
  if (v2 == cckem_pubkey_nbytes_info())
  {
    v3 = CFSTR("768");
LABEL_5:
    v5 = v3;
    goto LABEL_9;
  }
  v4 = cckem_pubkey_nbytes_ctx();
  cckem_kyber1024();
  if (v4 == cckem_pubkey_nbytes_info())
  {
    v3 = CFSTR("1024");
    goto LABEL_5;
  }
  secLogObjForScope("SecError");
  v6 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "unknown Kyber type detected", buf, 2u);
  }

  v3 = (__CFString *)&unk_1E1FFEF50;
LABEL_9:
  v20 = v3;
  v7 = SecKyberPublicKeyCopyData(v1, 0);
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v25 = objc_retainAutorelease(v7);
  v29 = SecSHA1DigestCreate(v8, -[__CFData bytes](v25, "bytes"), -[__CFData length](v25, "length"));
  v31[0] = CFSTR("class");
  v31[1] = CFSTR("type");
  v32[0] = CFSTR("keys");
  v32[1] = CFSTR("109");
  v31[2] = CFSTR("bsiz");
  v31[3] = CFSTR("esiz");
  v32[2] = v3;
  v32[3] = v3;
  v31[4] = CFSTR("kcls");
  v31[5] = CFSTR("klbl");
  v32[4] = CFSTR("0");
  v32[5] = v29;
  v31[6] = CFSTR("perm");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 1);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v32[6] = v28;
  v31[7] = CFSTR("priv");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 1);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v32[7] = v27;
  v31[8] = CFSTR("modi");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 1);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v32[8] = v26;
  v31[9] = CFSTR("sens");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v32[9] = v24;
  v31[10] = CFSTR("asen");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v32[10] = v23;
  v31[11] = CFSTR("extr");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 1);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v32[11] = v22;
  v31[12] = CFSTR("next");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v32[12] = v21;
  v31[13] = CFSTR("encr");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v32[13] = v9;
  v31[14] = CFSTR("decr");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v32[14] = v10;
  v31[15] = CFSTR("drve");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v32[15] = v11;
  v31[16] = CFSTR("sign");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v32[16] = v12;
  v31[17] = CFSTR("vrfy");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v32[17] = v13;
  v31[18] = CFSTR("snrc");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v32[18] = v14;
  v31[19] = CFSTR("vyrc");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v32[19] = v15;
  v31[20] = CFSTR("wrap");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v32[20] = v16;
  v31[21] = CFSTR("unwp");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v31[22] = CFSTR("v_Data");
  v32[21] = v17;
  v32[22] = v25;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v32, v31, 23);
  v19 = objc_claimAutoreleasedReturnValue();

  return v19;
}

uint64_t SecKyberPublicKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  const __CFAllocator *v4;
  CFIndex v5;
  __CFData *Mutable;
  __CFData *v7;
  uint64_t i;
  uint64_t v9;
  const __CFString *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  v2 = cckem_pubkey_nbytes_ctx();
  objc_msgSend(MEMORY[0x1E0CB37A0], "stringWithCapacity:", 2 * v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v4 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  v5 = cckem_pubkey_nbytes_ctx();
  Mutable = CFDataCreateMutable(v4, 0);
  CFDataSetLength(Mutable, v5);
  v15 = -[__CFData length](Mutable, "length");
  v7 = objc_retainAutorelease(Mutable);
  -[__CFData mutableBytes](v7, "mutableBytes");
  if (!cckem_export_pubkey())
  {
    -[__CFData setLength:](v7, "setLength:", v15);
    if (v2)
    {
      for (i = 0; i != v2; ++i)
        objc_msgSend(v3, "appendFormat:", CFSTR("%02X"), *(unsigned __int8 *)(-[__CFData bytes](objc_retainAutorelease(v7), "bytes") + i));
    }
  }
  v9 = cckem_pubkey_nbytes_ctx();
  cckem_kyber768();
  if (v9 == cckem_pubkey_nbytes_info())
  {
    v10 = CFSTR("Kyber-768-pubKey");
  }
  else
  {
    v11 = cckem_pubkey_nbytes_ctx();
    cckem_kyber1024();
    v12 = cckem_pubkey_nbytes_info();
    v10 = CFSTR("Kyber");
    if (v11 == v12)
      v10 = CFSTR("Kyber-1024-pubKey");
  }
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("<SecKeyRef %@ algorithm id: %lu, key type: %s, version: %d, bytes: %@, addr: %p>"), v10, 8, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), **(unsigned int **)(a1 + 16), v3, a1);
  v13 = objc_claimAutoreleasedReturnValue();

  return v13;
}

uint64_t SecKyberKeyGetAlgorithmID()
{
  return 8;
}

uint64_t SecKyberPublicKeyCopyPublicOctets(uint64_t a1, __CFData **a2)
{
  __CFData *v3;

  v3 = SecKyberPublicKeyCopyData(*(_QWORD *)(a1 + 24), 0);
  *a2 = v3;
  if (v3)
    return 0;
  else
    return 4294941021;
}

__CFData *SecKyberPublicKeyCopyExternalRepresentation(uint64_t a1, __CFString **a2)
{
  return SecKyberPublicKeyCopyData(*(_QWORD *)(a1 + 24), a2);
}

uint64_t SecKyberPublicKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, __CFString **a8)
{
  uint64_t v11;
  uint64_t v12;
  const __CFAllocator *v14;
  CFIndex v15;
  __CFData *Mutable;
  const __CFAllocator *v17;
  CFIndex v18;
  __CFData *v19;
  __CFData *v20;
  __CFData *v21;
  uint64_t v22;
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  if (a2 != 5 || !CFEqual(cf1, CFSTR("algid:kem:kyber")))
  {
    v11 = MEMORY[0x1E0C9B0D0];
    return *(_QWORD *)v11;
  }
  if (a5)
  {
    v11 = MEMORY[0x1E0C9AE50];
    return *(_QWORD *)v11;
  }
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v14 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  v15 = cckem_shared_key_nbytes_ctx();
  Mutable = CFDataCreateMutable(v14, 0);
  CFDataSetLength(Mutable, v15);
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v17 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  v18 = cckem_encapsulated_key_nbytes_ctx();
  v19 = CFDataCreateMutable(v17, 0);
  CFDataSetLength(v19, v18);
  -[__CFData length](v19, "length");
  v20 = objc_retainAutorelease(v19);
  -[__CFData mutableBytes](v20, "mutableBytes");
  -[__CFData length](Mutable, "length");
  v21 = objc_retainAutorelease(Mutable);
  -[__CFData mutableBytes](v21, "mutableBytes");
  ccrng();
  v22 = cckem_encapsulate();
  if ((_DWORD)v22)
    SecError(-26275, a8, CFSTR("Key encapsulation failed, err=%d for key %@"), v22, a1);
  v23[0] = v20;
  v23[1] = v21;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v23, 2);
  v12 = objc_claimAutoreleasedReturnValue();

  return v12;
}

__CFData *SecKyberPublicKeyCopyData(uint64_t a1, __CFString **a2)
{
  const __CFAllocator *v3;
  CFIndex v4;
  __CFData *Mutable;
  __CFData *v6;
  __CFData *v7;
  uint64_t v9;

  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v3 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  v4 = cckem_pubkey_nbytes_ctx();
  Mutable = CFDataCreateMutable(v3, 0);
  CFDataSetLength(Mutable, v4);
  v9 = -[__CFData length](Mutable, "length");
  v6 = objc_retainAutorelease(Mutable);
  -[__CFData mutableBytes](v6, "mutableBytes");
  if (cckem_export_pubkey())
  {
    SecError(-26275, a2, CFSTR("Failed to export Kyber pubkey"));
    v7 = 0;
  }
  else
  {
    -[__CFData setLength:](v6, "setLength:", v9);
    v7 = v6;
  }

  return v7;
}

uint64_t SecKyberPrivateKeyInit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  size_t v8;
  int v9;
  int v10;
  NSObject *v11;
  const char *v12;
  int v13;
  NSObject *v14;
  uint32_t v15;
  int v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    result = 0;
    *(_QWORD *)(a1 + 24) = a2;
    return result;
  }
  cckem_kyber768();
  v5 = cckem_pubkey_nbytes_info();
  cckem_kyber768();
  if (cckem_privkey_nbytes_info() + v5 == a3)
  {
    cckem_kyber768();
  }
  else
  {
    cckem_kyber1024();
    v7 = cckem_pubkey_nbytes_info();
    cckem_kyber1024();
    if (cckem_privkey_nbytes_info() + v7 != a3)
    {
      secLogObjForScope("SecWarning");
      v11 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v16 = 67109120;
        v17 = a3;
        v12 = "Kyber pubkey size=%dbytes is invalid";
        v14 = v11;
        v15 = 8;
        goto LABEL_16;
      }
      goto LABEL_17;
    }
    cckem_kyber1024();
  }
  v8 = cckem_sizeof_full_ctx();
  *(_QWORD *)(a1 + 24) = malloc_type_calloc(1uLL, v8, 0xC4AA431AuLL);
  cckem_pubkey_nbytes_info();
  v9 = cckem_import_privkey();
  if (v9)
  {
    v10 = v9;
    secLogObjForScope("SecWarning");
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v16 = 67109376;
      v17 = a3;
      v18 = 1024;
      v19 = v10;
      v12 = "Kyber privkey size=%dbytes import or priv part failed: %d";
LABEL_13:
      v14 = v11;
      v15 = 14;
LABEL_16:
      _os_log_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v16, v15);
    }
  }
  else
  {
    cckem_public_ctx();
    result = cckem_import_pubkey();
    if (!(_DWORD)result)
      return result;
    v13 = result;
    secLogObjForScope("SecWarning");
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v16 = 67109376;
      v17 = a3;
      v18 = 1024;
      v19 = v13;
      v12 = "Kyber privkey size=%dbytes import of pub part failed: %d";
      goto LABEL_13;
    }
  }
LABEL_17:

  return 4294967246;
}

void SecKyberPrivateKeyDestroy(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
  {
    cckem_sizeof_full_ctx();
    free(v1);
  }
}

uint64_t SecKyberPrivateKeyBlockSize()
{
  return cckem_privkey_nbytes_ctx();
}

uint64_t SecKyberPrivateKeyCopyAttributeDictionary(uint64_t a1)
{
  uint64_t v2;
  __CFString *v3;
  uint64_t v4;
  __CFString *v5;
  NSObject *v6;
  uint64_t v7;
  __CFData *v8;
  const __CFAllocator *v9;
  __CFData *v10;
  __CFData *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  __CFData *v20;
  void *v21;
  uint64_t v22;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  __CFData *v34;
  __CFString *v35;
  uint8_t buf[16];
  _QWORD v37[23];
  _QWORD v38[25];

  v38[23] = *MEMORY[0x1E0C80C00];
  v2 = cckem_privkey_nbytes_ctx();
  cckem_kyber768();
  if (v2 == cckem_privkey_nbytes_info())
  {
    v3 = CFSTR("768");
LABEL_5:
    v5 = v3;
    goto LABEL_9;
  }
  v4 = cckem_privkey_nbytes_ctx();
  cckem_kyber1024();
  if (v4 == cckem_privkey_nbytes_info())
  {
    v3 = CFSTR("1024");
    goto LABEL_5;
  }
  secLogObjForScope("SecError");
  v6 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "unknown Kyber type detected", buf, 2u);
  }

  v3 = (__CFString *)&unk_1E1FFEF50;
LABEL_9:
  v7 = cckem_public_ctx();
  v8 = SecKyberPublicKeyCopyData(v7, 0);
  if (v8)
  {
    v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v10 = objc_retainAutorelease(v8);
    v11 = SecSHA1DigestCreate(v9, -[__CFData bytes](v10, "bytes"), -[__CFData length](v10, "length"));

  }
  else
  {
    v11 = 0;
  }
  v37[0] = CFSTR("class");
  v37[1] = CFSTR("type");
  v38[0] = CFSTR("keys");
  v38[1] = CFSTR("109");
  v37[2] = CFSTR("bsiz");
  v37[3] = CFSTR("esiz");
  v38[3] = v3;
  v38[4] = CFSTR("1");
  v37[4] = CFSTR("kcls");
  v37[5] = CFSTR("klbl");
  v12 = (uint64_t)v11;
  v38[2] = v3;
  v34 = v11;
  v35 = v3;
  if (!v11)
  {
    objc_msgSend(MEMORY[0x1E0C99D50], "data");
    v12 = objc_claimAutoreleasedReturnValue();
  }
  v38[5] = v12;
  v37[6] = CFSTR("perm");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 1, v12);
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v38[6] = v33;
  v37[7] = CFSTR("priv");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 1);
  v32 = (void *)objc_claimAutoreleasedReturnValue();
  v38[7] = v32;
  v37[8] = CFSTR("modi");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 1);
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v38[8] = v31;
  v37[9] = CFSTR("sens");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v38[9] = v30;
  v37[10] = CFSTR("asen");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v29 = (void *)objc_claimAutoreleasedReturnValue();
  v38[10] = v29;
  v37[11] = CFSTR("extr");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 1);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  v38[11] = v28;
  v37[12] = CFSTR("next");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v27 = (void *)objc_claimAutoreleasedReturnValue();
  v38[12] = v27;
  v37[13] = CFSTR("encr");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v26 = (void *)objc_claimAutoreleasedReturnValue();
  v38[13] = v26;
  v37[14] = CFSTR("decr");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v25 = (void *)objc_claimAutoreleasedReturnValue();
  v38[14] = v25;
  v37[15] = CFSTR("drve");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v38[15] = v13;
  v37[16] = CFSTR("sign");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v38[16] = v14;
  v37[17] = CFSTR("vrfy");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v38[17] = v15;
  v37[18] = CFSTR("snrc");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v38[18] = v16;
  v37[19] = CFSTR("vyrc");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v38[19] = v17;
  v37[20] = CFSTR("wrap");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  v38[20] = v18;
  v37[21] = CFSTR("unwp");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", 0);
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v38[21] = v19;
  v37[22] = CFSTR("v_Data");
  v20 = SecKyberPrivateKeyCopyExternalRepresentation(a1, 0);
  v21 = v20;
  if (!v20)
  {
    objc_msgSend(MEMORY[0x1E0C99DF0], "data");
    v21 = (void *)objc_claimAutoreleasedReturnValue();
  }
  v38[22] = v21;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v38, v37, 23);
  v22 = objc_claimAutoreleasedReturnValue();
  if (!v20)

  if (!v34)
  return v22;
}

uint64_t SecKyberPrivateKeyCopyKeyDescription(uint64_t a1)
{
  uint64_t v2;
  const __CFString *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = cckem_privkey_nbytes_ctx();
  cckem_kyber768();
  if (v2 == cckem_privkey_nbytes_info())
  {
    v3 = CFSTR("Kyber-768-privKey");
  }
  else
  {
    v4 = cckem_privkey_nbytes_ctx();
    cckem_kyber1024();
    v5 = cckem_privkey_nbytes_info();
    v3 = CFSTR("Kyber");
    if (v4 == v5)
      v3 = CFSTR("Kyber-1024-privKey");
  }
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("<SecKeyRef %@ algorithm id: %lu, key type: %s, version: %d, addr: %p>"), v3, 8, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8), **(unsigned int **)(a1 + 16), a1);
  return objc_claimAutoreleasedReturnValue();
}

uint64_t SecKyberPrivateKeyCopyPublicOctets(uint64_t a1, __CFData **a2)
{
  uint64_t v3;
  __CFData *v4;

  v3 = cckem_public_ctx();
  v4 = SecKyberPublicKeyCopyData(v3, 0);
  *a2 = v4;
  if (v4)
    return 0;
  else
    return 4294941021;
}

__CFData *SecKyberPrivateKeyCopyExternalRepresentation(uint64_t a1, __CFString **a2)
{
  uint64_t v4;
  const __CFAllocator *v5;
  CFIndex v6;
  __CFData *Mutable;
  __CFData *v8;
  __CFData *v9;
  __CFData *v10;
  uint64_t v12;
  uint64_t v13;

  cckem_public_ctx();
  v4 = cckem_pubkey_nbytes_ctx();
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v5 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  v6 = cckem_privkey_nbytes_ctx() + v4;
  Mutable = CFDataCreateMutable(v5, 0);
  CFDataSetLength(Mutable, v6);
  v13 = -[__CFData length](Mutable, "length");
  cckem_public_ctx();
  v8 = objc_retainAutorelease(Mutable);
  -[__CFData mutableBytes](v8, "mutableBytes");
  if (cckem_export_pubkey())
  {
    SecError(-26275, a2, CFSTR("Failed to export public part of %@"), a1);
  }
  else
  {
    v12 = -[__CFData length](v8, "length") - v13;
    v9 = objc_retainAutorelease(v8);
    -[__CFData mutableBytes](v9, "mutableBytes");
    if (!cckem_export_privkey())
    {
      -[__CFData setLength:](v9, "setLength:", v12 + v13);
      v10 = v9;
      goto LABEL_8;
    }
    SecError(-26275, a2, CFSTR("Failed to export %@"), a1);
  }
  v10 = 0;
LABEL_8:

  return v10;
}

__CFData *SecKyberPrivateKeyCopyOperationResult(uint64_t a1, uint64_t a2, CFTypeRef cf1, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, __CFString **a8)
{
  uint64_t v12;
  __CFData *v13;
  id v15;
  uint64_t v16;
  const __CFAllocator *v17;
  CFIndex v18;
  __CFData *Mutable;
  uint64_t v20;
  uint64_t v21;

  if (a2 != 6 || !CFEqual(cf1, CFSTR("algid:kem:kyber")))
  {
    v12 = MEMORY[0x1E0C9B0D0];
    return *(__CFData **)v12;
  }
  if (a5)
  {
    v12 = MEMORY[0x1E0C9AE50];
    return *(__CFData **)v12;
  }
  v15 = a6;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    && (v16 = objc_msgSend(v15, "length"), v16 == cckem_encapsulated_key_nbytes_info()))
  {
    if (SecCFAllocatorZeroize_sOnce != -1)
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
    v17 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
    v18 = cckem_shared_key_nbytes_info();
    Mutable = CFDataCreateMutable(v17, 0);
    CFDataSetLength(Mutable, v18);
    objc_msgSend(v15, "length");
    objc_msgSend(objc_retainAutorelease(v15), "bytes");
    -[__CFData length](Mutable, "length");
    v13 = objc_retainAutorelease(Mutable);
    -[__CFData mutableBytes](v13, "mutableBytes");
    v20 = cckem_decapsulate();
    if ((_DWORD)v20)
      SecError(-26275, a8, CFSTR("Key decapsulation failed, err=%d for key %@"), v20, a1);
  }
  else
  {
    v21 = cckem_encapsulated_key_nbytes_info();
    SecError(-50, a8, CFSTR("Kyber decapsulation failed: expecting input data of size %dbytes"), v21);
    v13 = 0;
  }

  return v13;
}

uint64_t SecKyberKeyGeneratePair(void *a1, _QWORD *a2, _QWORD *a3)
{
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  void *v11;
  int key;
  int v13;
  NSObject *v14;
  uint64_t v15;
  _QWORD *v16;
  size_t v17;
  void *v18;
  const void *v19;
  size_t v20;
  _QWORD *v21;
  void *v22;
  NSObject *v23;
  int v25;
  void *v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  cckem_kyber768();
  objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("bsiz"));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = v6;
  if (!v6)
  {
LABEL_6:
    v10 = cckem_sizeof_full_ctx();
    v11 = malloc_type_calloc(1uLL, v10, 0xBEFB4CFFuLL);
    cckem_full_ctx_init();
    ccrng();
    key = cckem_generate_key();
    if (key)
    {
      v13 = key;
      free(v11);
      secLogObjForScope("SecWarning");
      v14 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        v25 = 67109120;
        LODWORD(v26) = v13;
        _os_log_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEFAULT, "Failed to generate Kyber key: err %d", (uint8_t *)&v25, 8u);
      }

      v15 = 4294941021;
    }
    else
    {
      if (SecCFAllocatorZeroize_sOnce != -1)
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
      v16 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)&kSecKyberPrivateKeyDescriptor, (uint64_t)v11, 0, 0);
      if (v16)
      {
        v17 = cckem_sizeof_pub_ctx();
        v18 = malloc_type_calloc(1uLL, v17, 0x31EB0D42uLL);
        v19 = (const void *)cckem_public_ctx();
        v20 = cckem_sizeof_pub_ctx();
        memcpy(v18, v19, v20);
        if (SecCFAllocatorZeroize_sOnce != -1)
          dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
        v21 = SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)&kSecKyberPublicKeyDescriptor, (uint64_t)v18, 0, 0);
        v22 = v21;
        if (v21)
        {
          if (a2)
            *a2 = v21;
          v15 = 0;
          if (a3)
            *a3 = v16;
        }
        else
        {
          v15 = 4294967246;
        }

      }
      else
      {
        v15 = 4294967246;
      }

    }
    goto LABEL_27;
  }
  v8 = objc_msgSend(v6, "integerValue");
  if (v8 == objc_msgSend(CFSTR("768"), "integerValue"))
  {
    cckem_kyber768();
    goto LABEL_6;
  }
  v9 = objc_msgSend(v7, "integerValue");
  if (v9 == objc_msgSend(CFSTR("1024"), "integerValue"))
  {
    cckem_kyber1024();
    goto LABEL_6;
  }
  secLogObjForScope("SecWarning");
  v23 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    v25 = 138412290;
    v26 = v7;
    _os_log_impl(&dword_18A900000, v23, OS_LOG_TYPE_DEFAULT, "Invalid kyber type %@ requested for Kyber key generation", (uint8_t *)&v25, 0xCu);
  }

  v15 = 4294967246;
LABEL_27:

  return v15;
}

uint64_t SecIdentityCompare(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (a1 == a2)
    return 1;
  if (!a2)
    return 0;
  result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
  if ((_DWORD)result)
    return CFEqual(*(CFTypeRef *)(a1 + 24), *(CFTypeRef *)(a2 + 24)) != 0;
  return result;
}

CFHashCode SecIdentityHash(uint64_t a1)
{
  CFHashCode v2;

  v2 = CFHash(*(CFTypeRef *)(a1 + 16));
  return CFHash(*(CFTypeRef *)(a1 + 24)) + v2;
}

CFStringRef SecIdentityCopyFormatDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<SecIdentityRef: %p>"), a1);
}

CFStringRef SecIdentityCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<SecIdentityRef: %p>"), a1);
}

OSStatus SecPKCS12Import(CFDataRef pkcs12_data, CFDictionaryRef options, CFArrayRef *items)
{
  CFIndex Length;
  char *BytePtr;
  int v8;
  int v9;
  _QWORD *v10;
  CCHmacAlgorithm v11;
  unsigned int v12;
  CC_LONG v13;
  unint64_t v14;
  unsigned __int8 *v15;
  void *v16;
  unsigned int v17;
  int v18;
  size_t v19;
  void *v20;
  char *v21;
  uint64_t v22;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  unint64_t *v28;
  unint64_t v29;
  char *v30;
  int v31;
  CFMutableArrayRef Mutable;
  const __CFArray *v33;
  OSStatus v34;
  const void *v35;
  const __CFArray *v36;
  SecAsn1CoderRef coder;
  const __CFString *Value;
  CFDictionaryRef theDict;
  __int128 context;
  uint64_t v42;
  int v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  _QWORD *v47;
  _QWORD *v48;
  unint64_t v49;
  CFRange v50;

  coder = 0;
  Value = 0;
  theDict = 0;
  SecAsn1CoderCreate(&coder);
  if (options)
    Value = (const __CFString *)CFDictionaryGetValue(options, CFSTR("passphrase"));
  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v47 = 0;
  v45 = 0u;
  v46 = 0u;
  v44 = 0u;
  Length = CFDataGetLength(pkcs12_data);
  BytePtr = (char *)CFDataGetBytePtr(pkcs12_data);
  v8 = -50;
  if (coder && BytePtr)
  {
    if (SEC_ASN1Decode(*(_QWORD *)coder, (uint64_t)&v44, (uint64_t)&NSS_P12_DecodedPFXTemplate, BytePtr, Length))v8 = -26275;
    else
      v8 = 0;
  }
  v9 = 1;
  if (v8)
    goto LABEL_22;
  if ((_DWORD)v46 != 1)
    goto LABEL_22;
  v10 = v47;
  if (!v47)
    goto LABEL_22;
  *(_QWORD *)&context = v47[1];
  *((_QWORD *)&context + 1) = *v47;
  if (DEROidCompare((uint64_t)&oidSha1, (uint64_t)&context))
  {
    v11 = 0;
    v12 = 20;
LABEL_15:
    v13 = 64;
    goto LABEL_16;
  }
  if (DEROidCompare((uint64_t)&oidSha256, (uint64_t)&context))
  {
    v11 = 2;
    v12 = 32;
    goto LABEL_15;
  }
  if (DEROidCompare((uint64_t)&oidSha384, (uint64_t)&context))
  {
    v11 = 3;
    v12 = 48;
  }
  else
  {
    if (!DEROidCompare((uint64_t)&oidSha512, (uint64_t)&context))
    {
      if (!DEROidCompare((uint64_t)&oidSha224, (uint64_t)&context))
        goto LABEL_20;
      v11 = 5;
      v12 = 28;
      goto LABEL_15;
    }
    v11 = 4;
    v12 = 64;
  }
  v13 = 128;
LABEL_16:
  if (!*((_QWORD *)&context + 1))
  {
LABEL_20:
    v16 = 0;
LABEL_21:
    free(v16);
    v9 = 2;
LABEL_22:
    LODWORD(v48) = v9;
    goto LABEL_54;
  }
  v14 = v10[8];
  if (!v14)
    goto LABEL_28;
  v15 = (unsigned __int8 *)v10[9];
  if (!v15)
    goto LABEL_28;
  if (v14 > 4)
    goto LABEL_20;
  v17 = 0;
  do
  {
    v18 = *v15++;
    v17 = v18 | (v17 << 8);
    --v14;
  }
  while (v14);
  if (!v17)
LABEL_28:
    v17 = 1;
  v19 = v12;
  v16 = malloc_type_malloc(v12, 0xAF7DDE70uLL);
  if (p12_pbe_gen(Value, (const void *)v10[7], v10[6], v17, 3, v16, v19, v13, v19))
    goto LABEL_21;
  v20 = (void *)0xAAAAAAAAAAAAAAAALL;
  v48 = (_QWORD *)0xAAAAAAAAAAAAAAAALL;
  v49 = 0xAAAAAAAAAAAAAAAALL;
  if (coder)
  {
    v20 = (void *)PORT_ArenaAlloc(*(_QWORD *)coder, v19);
    v49 = (unint64_t)v20;
    if (v20)
      v48 = (_QWORD *)v19;
  }
  CCHmac(v11, v16, v19, *(const void **)(*((_QWORD *)&v46 + 1) + 8), **((_QWORD **)&v46 + 1), v20);
  if (!nssCompareSecAsn1Items((_BOOL8)&v48, (uint64_t)(v10 + 4)))
    goto LABEL_21;
  free(v16);
  v48 = 0;
  if (!coder
    || (v21 = *(char **)(*((_QWORD *)&v46 + 1) + 8)) == 0
    || SEC_ASN1Decode(*(_QWORD *)coder, (uint64_t)&v48, (uint64_t)&NSS_P12_AuthenticatedSafeTemplate, v21, **((_QWORD **)&v46 + 1)))
  {
LABEL_73:
    v9 = 1;
    goto LABEL_22;
  }
  if (v48)
  {
    if (*v48)
    {
      v22 = 0;
      while (v48[++v22])
        ;
      if ((_DWORD)v22)
      {
        v24 = 0;
        v25 = 8 * v22;
        while (1)
        {
          v26 = v48[v24 / 8];
          v27 = *(_DWORD *)(v26 + 16);
          if (v27 == 6)
            break;
          if (v27 == 1)
          {
            v28 = *(unint64_t **)(v26 + 24);
            v29 = *v28;
            v30 = (char *)v28[1];
            goto LABEL_48;
          }
LABEL_49:
          v24 += 8;
          if (v25 == v24)
            goto LABEL_50;
        }
        context = 0uLL;
        p12Decrypt((uint64_t)&coder, (_QWORD *)(*(_QWORD *)(v26 + 24) + 32), *(_QWORD *)(v26 + 24) + 64, &context);
        if (v31)
          goto LABEL_73;
        v30 = (char *)*((_QWORD *)&context + 1);
        v29 = context;
LABEL_48:
        if (safeContentsParse((uint64_t **)&coder, v29, v30))
          goto LABEL_73;
        goto LABEL_49;
      }
    }
  }
LABEL_50:
  LODWORD(v48) = 0;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  *(_QWORD *)&context = Mutable;
  *((_QWORD *)&context + 1) = &v48;
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)collect_certs, &context);
  if (!(_DWORD)v48)
  {
    v33 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
    *(_QWORD *)&v44 = v33;
    *((_QWORD *)&v44 + 1) = Mutable;
    *(_QWORD *)&v45 = &v48;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)build_trust_chains, &v44);
    if (Mutable)
      CFRelease(Mutable);
    *items = v33;
  }
LABEL_54:
  if (theDict)
    CFRelease(theDict);
  SecAsn1CoderRelease(coder);
  if ((_DWORD)v48)
  {
    if ((_DWORD)v48 == 2)
    {
      return -25293;
    }
    else if ((_DWORD)v48 == 1)
    {
      return -26275;
    }
    else
    {
      return -26276;
    }
  }
  else if (options)
  {
    v35 = CFDictionaryGetValue(options, CFSTR("nleg"));
    v34 = 0;
    if (v35 && v35 != (const void *)*MEMORY[0x1E0C9AE40])
    {
      *(_QWORD *)&context = 0;
      *((_QWORD *)&context + 1) = &context;
      v42 = 0x2000000000;
      v43 = 0;
      v36 = *items;
      *(_QWORD *)&v44 = MEMORY[0x1E0C809B0];
      *((_QWORD *)&v44 + 1) = 0x40000000;
      *(_QWORD *)&v45 = __SecPKCS12ImportToModernKeychain_block_invoke;
      *((_QWORD *)&v45 + 1) = &unk_1E1FD5D00;
      *(_QWORD *)&v46 = &context;
      *((_QWORD *)&v46 + 1) = options;
      v50.length = CFArrayGetCount(v36);
      v50.location = 0;
      CFArrayApplyFunction(v36, v50, (CFArrayApplierFunction)apply_block_1_8142, &v44);
      v34 = *(_DWORD *)(*((_QWORD *)&context + 1) + 24);
      _Block_object_dispose(&context, 8);
    }
  }
  else
  {
    return 0;
  }
  return v34;
}

void collect_certs(int a1, CFDictionaryRef theDict, uint64_t a3)
{
  const __CFData *Value;
  SecCertificateRef v6;
  SecCertificateRef v7;

  if (!CFDictionaryContainsKey(theDict, CFSTR("key")))
  {
    Value = (const __CFData *)CFDictionaryGetValue(theDict, CFSTR("cert"));
    if (Value)
    {
      v6 = SecCertificateCreateWithData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Value);
      if (v6)
      {
        v7 = v6;
        CFArrayAppendValue(*(CFMutableArrayRef *)a3, v6);
        CFRelease(v7);
      }
      else
      {
        **(_DWORD **)(a3 + 8) = 1;
      }
    }
  }
}

void build_trust_chains(uint64_t a1, const __CFDictionary *a2, uint64_t a3)
{
  const __CFAllocator *v5;
  __CFDictionary *Mutable;
  const __CFData *Value;
  const __CFData *v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  CFIndex Length;
  void *v12;
  const void *v13;
  __CFArray *v14;
  __CFArray *v15;
  SecPolicyRef BasicX509;
  CFArrayRef v17;
  int v18;
  _QWORD v19[2];
  SecTrustRef trust;
  CFRange v21;

  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  trust = 0;
  Value = (const __CFData *)CFDictionaryGetValue(a2, CFSTR("key"));
  if (!Value)
    goto LABEL_34;
  v8 = (const __CFData *)CFDictionaryGetValue(a2, CFSTR("cert"));
  if (!v8)
  {
    v15 = 0;
    v17 = 0;
    BasicX509 = 0;
    v13 = 0;
    Value = 0;
    goto LABEL_17;
  }
  v9 = (const __CFData *)CFDictionaryGetValue(a2, CFSTR("algid"));
  v19[0] = CFDataGetBytePtr(v9);
  v19[1] = CFDataGetLength(v9);
  if (DEROidCompare((uint64_t)&oidEcPubKey, (uint64_t)v19))
  {
    BytePtr = CFDataGetBytePtr(Value);
    Length = CFDataGetLength(Value);
    v12 = &kSecECPrivateKeyDescriptor;
  }
  else
  {
    if (!DEROidCompare((uint64_t)&oidRsa, (uint64_t)v19))
    {
      v15 = 0;
      v17 = 0;
      BasicX509 = 0;
      v13 = 0;
      v8 = 0;
      Value = 0;
LABEL_16:
      **(_DWORD **)(a3 + 16) = 1;
      goto LABEL_17;
    }
    BytePtr = CFDataGetBytePtr(Value);
    Length = CFDataGetLength(Value);
    v12 = &kSecRSAPrivateKeyDescriptor;
  }
  Value = (const __CFData *)SecKeyCreate((uint64_t)v5, (uint64_t)v12, (uint64_t)BytePtr, Length, 1);
  if (!Value)
  {
LABEL_34:
    v15 = 0;
    v17 = 0;
    BasicX509 = 0;
    v13 = 0;
    v8 = 0;
    goto LABEL_17;
  }
  v8 = SecCertificateCreateWithData(v5, v8);
  if (!v8)
  {
    v15 = 0;
    v17 = 0;
    BasicX509 = 0;
    v13 = 0;
    goto LABEL_16;
  }
  v13 = (const void *)SecIdentityCreate((int)v5, v8, Value);
  if (!v13)
  {
    v15 = 0;
    v17 = 0;
    BasicX509 = 0;
    goto LABEL_16;
  }
  CFDictionarySetValue(Mutable, CFSTR("identity"), v13);
  v14 = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v15 = v14;
  if (v14)
  {
    CFArrayAppendValue(v14, v8);
    v21.length = CFArrayGetCount(*(CFArrayRef *)(a3 + 8));
    v21.location = 0;
    CFArrayAppendArray(v15, *(CFArrayRef *)(a3 + 8), v21);
    BasicX509 = SecPolicyCreateBasicX509();
    if (BasicX509 && (v18 = -1431655766, SecTrustCreateWithCertificates(v15, BasicX509, &trust), trust))
    {
      SecTrustEvaluateInternal(trust, &v18);
      CFDictionarySetValue(Mutable, CFSTR("trust"), trust);
      v17 = SecTrustCopyCertificateChain(trust);
      if (v17)
      {
        CFDictionarySetValue(Mutable, CFSTR("chain"), v17);
        CFArrayAppendValue(*(CFMutableArrayRef *)a3, Mutable);
      }
    }
    else
    {
      v17 = 0;
    }
  }
  else
  {
    v17 = 0;
    BasicX509 = 0;
  }
LABEL_17:
  if (Mutable)
    CFRelease(Mutable);
  if (v13)
    CFRelease(v13);
  if (Value)
    CFRelease(Value);
  if (v8)
    CFRelease(v8);
  if (BasicX509)
    CFRelease(BasicX509);
  if (v17)
    CFRelease(v17);
  if (v15)
    CFRelease(v15);
  if (trust)
    CFRelease(trust);
}

uint64_t apply_block_1_8142(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

__CFDictionary *secItemOptionsFromPKCS12Options(CFDictionaryRef theDict)
{
  __CFDictionary *MutableCopy;

  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  CFDictionaryRemoveValue(MutableCopy, CFSTR("passphrase"));
  CFDictionaryRemoveValue(MutableCopy, CFSTR("memory"));
  return MutableCopy;
}

uint64_t osstatus_for_kern_return(uint64_t a1)
{
  char v1;
  unsigned int v3;

  v1 = a1 + 63;
  if ((unint64_t)(a1 + 536870207) > 0x21)
    goto LABEL_8;
  if (((1 << v1) & 0x20000000DLL) != 0)
    return 4294941988;
  if (((1 << v1) & 0x6000) != 0)
    return 4294942003;
  if (a1 == -536870206)
    return 4294967246;
LABEL_8:
  if (a1)
    v3 = -25291;
  else
    v3 = 0;
  if (a1 == -536870212)
    return 4294941021;
  else
    return v3;
}

const void *SecCopyLastError(int a1)
{
  void *v2;
  const void *v3;

  if (getLastErrorKey_onceToken != -1)
    dispatch_once(&getLastErrorKey_onceToken, &__block_literal_global_81_8204);
  if (getLastErrorKey_haveKey != 1)
    return 0;
  v2 = pthread_getspecific(getLastErrorKey_key);
  v3 = v2;
  if (v2)
  {
    if (!a1 || SecErrorGetOSStatus((uint64_t)v2) == a1)
    {
      CFRetain(v3);
      return v3;
    }
    return 0;
  }
  return v3;
}

void lastErrorReleaseError(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

CFDataRef _SecItemCreatePersistentRef(const __CFString *a1, unint64_t a2, CFDictionaryRef theDict)
{
  __CFData *TokenPersistentRefData;
  const __CFData *v6;
  const __CFAllocator *v7;
  CFIndex Length;
  __CFData *Mutable;
  const UInt8 *BytePtr;
  CFIndex v11;
  char buffer[16];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (theDict && (TokenPersistentRefData = CreateTokenPersistentRefData(a1, theDict)) != 0)
  {
    v6 = TokenPersistentRefData;
    v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Length = CFDataGetLength(TokenPersistentRefData);
    Mutable = CFDataCreateMutable(v7, Length + 4);
    CFDataAppendBytes(Mutable, (const UInt8 *)"tkpr", 4);
    BytePtr = CFDataGetBytePtr(v6);
    v11 = CFDataGetLength(v6);
    CFDataAppendBytes(Mutable, BytePtr, v11);
    CFRelease(v6);
  }
  else
  {
    if ((a2 & 0x8000000000000000) != 0)
      return 0;
    memset(buffer, 170, 12);
    if (!CFStringGetCString(a1, buffer, 5, 0x8000100u))
    {
      return 0;
    }
    else
    {
      *(_QWORD *)&buffer[4] = bswap64(a2);
      return CFDataCreate(0, (const UInt8 *)buffer, 12);
    }
  }
  return Mutable;
}

const __CFDictionary *SecTokenItemValueCopy(const void *a1, CFTypeRef *a2)
{
  CFTypeID v4;
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *v12;
  const void *Value;
  CFTypeID v14;
  const void *v15;
  CFTypeID v16;
  const void *v17;
  CFTypeID v18;
  CFDictionaryRef theDict;

  theDict = 0;
  if (!a1)
    goto LABEL_13;
  v4 = CFGetTypeID(a1);
  if (v4 != CFDataGetTypeID())
    goto LABEL_13;
  BytePtr = CFDataGetBytePtr((CFDataRef)a1);
  Length = CFDataGetLength((CFDataRef)a1);
  v7 = &BytePtr[Length];
  v11 = der_decode_plist(0, (uint64_t)&theDict, a2, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length], v8, v9, v10);
  if (!v11)
  {
LABEL_14:
    v12 = 0;
    goto LABEL_15;
  }
  if ((const UInt8 *)v11 != v7)
  {
    SecError(-26275, (__CFString **)a2, CFSTR("trailing garbage at end of token data field"));
    goto LABEL_14;
  }
  v12 = theDict;
  Value = CFDictionaryGetValue(theDict, CFSTR("oid"));
  if (!Value || (v14 = CFGetTypeID(Value), v14 != CFDataGetTypeID()))
  {
    SecError(-26276, (__CFString **)a2, CFSTR("token based item data does not have OID"));
    goto LABEL_14;
  }
  if ((v15 = CFDictionaryGetValue(v12, CFSTR("ac"))) != 0 && (v16 = CFGetTypeID(v15), v16 != CFDataGetTypeID())
    || (v17 = CFDictionaryGetValue(v12, CFSTR("data"))) != 0 && (v18 = CFGetTypeID(v17), v18 != CFDataGetTypeID()))
  {
LABEL_13:
    SecError(-50, (__CFString **)a2, CFSTR("Unexpected type"));
    goto LABEL_14;
  }
  if (!v12)
    return v12;
  CFRetain(v12);
LABEL_15:
  if (theDict)
    CFRelease(theDict);
  return v12;
}

BOOL _SecItemParsePersistentRef(const void *a1, _QWORD *a2, _QWORD *a3, const void **a4, CFDictionaryRef *a5)
{
  CFTypeID v10;
  const UInt8 *BytePtr;
  unint64_t v12;
  const __CFAllocator *v13;
  CFIndex Length;
  CFStringRef v15;
  const __CFArray *v16;
  _BOOL4 valid;
  _BOOL8 v18;
  const UInt8 *v19;
  const __CFAllocator *v20;
  CFIndex v21;
  CFStringRef v22;
  const __CFString *v23;
  _BOOL4 v24;
  CFIndex v25;
  CFIndex v26;
  CFIndex v27;
  CFDataRef v28;
  const void *v29;
  const void *v30;
  const UInt8 *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  CFTypeID v37;
  const void *ValueAtIndex;
  _BOOL4 v39;
  const __CFAllocator *v40;
  const void *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  CFTypeRef cf;

  v10 = CFGetTypeID(a1);
  if (v10 != CFDataGetTypeID())
    return 0;
  if (CFDataGetLength((CFDataRef)a1) < 5 || *(_DWORD *)CFDataGetBytePtr((CFDataRef)a1) != 1919970164)
  {
    if (CFDataGetLength((CFDataRef)a1) == 12)
    {
      BytePtr = CFDataGetBytePtr((CFDataRef)a1);
      v12 = *(_QWORD *)(BytePtr + 4);
      v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Length = CFStringGetLength(CFSTR("genp"));
      v15 = CFStringCreateWithBytes(v13, BytePtr, Length, 0x8000100u, 1u);
      if (v15)
      {
        v16 = (const __CFArray *)v15;
        valid = isValidClass(v15, a2);
        v18 = valid;
        if (a3 && valid)
          *a3 = bswap64(v12);
        goto LABEL_31;
      }
    }
    else if (SecKeychainIsStaticPersistentRefsEnabled() && CFDataGetLength((CFDataRef)a1) == 20)
    {
      v19 = CFDataGetBytePtr((CFDataRef)a1);
      v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v21 = CFStringGetLength(CFSTR("genp"));
      v22 = CFStringCreateWithBytes(v20, v19, v21, 0x8000100u, 1u);
      if (v22)
      {
        v23 = v22;
        v24 = isValidClass(v22, a2);
        v18 = v24;
        if (a4 && v24)
        {
          v25 = CFStringGetLength(v23);
          v26 = CFDataGetLength((CFDataRef)a1);
          v27 = CFStringGetLength(v23);
          v28 = CFDataCreateWithBytesNoCopy(v20, &v19[v25], v26 - v27, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
          v29 = *a4;
          if (*a4 != v28)
          {
            if (!v28 || (CFRetain(v28), (v29 = *a4) != 0))
              CFRelease(v29);
            *a4 = v28;
          }
          if (v28)
            CFRelease(v28);
        }
        v30 = v23;
        goto LABEL_32;
      }
    }
    return 0;
  }
  cf = 0;
  v31 = CFDataGetBytePtr((CFDataRef)a1);
  v32 = (uint64_t)&v31[CFDataGetLength((CFDataRef)a1)];
  v36 = der_decode_plist(0, (uint64_t)&cf, 0, (uint64_t)(v31 + 4), v32, v33, v34, v35);
  v18 = 0;
  v16 = (const __CFArray *)cf;
  if (v36 && v36 == v32)
  {
    v37 = CFGetTypeID(cf);
    if (v37 != CFArrayGetTypeID() || CFArrayGetCount(v16) != 3)
    {
      v18 = 0;
      if (!v16)
        return v18;
      goto LABEL_31;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(v16, 0);
    v39 = isValidClass(ValueAtIndex, a2);
    v18 = v39;
    if (a5 && v39)
    {
      v40 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v18 = 1;
      v41 = CFArrayGetValueAtIndex(v16, 1);
      CFArrayGetValueAtIndex(v16, 2);
      *a5 = CFDictionaryCreateForCFTypes(v40, v42, v43, v44, v45, v46, v47, v48, (uint64_t)CFSTR("tkid"), (uint64_t)v41);
    }
  }
  if (v16)
  {
LABEL_31:
    v30 = v16;
LABEL_32:
    CFRelease(v30);
  }
  return v18;
}

BOOL isValidClass(CFTypeRef cf2, _QWORD *a2)
{
  unint64_t v4;
  BOOL v5;
  uint64_t v6;
  _QWORD v8[7];

  v4 = 0;
  v8[6] = *MEMORY[0x1E0C80C00];
  v8[0] = CFSTR("genp");
  v8[1] = CFSTR("inet");
  v8[2] = CFSTR("apls");
  v8[3] = CFSTR("cert");
  v8[4] = CFSTR("keys");
  v8[5] = CFSTR("idnt");
  v5 = 1;
  while (1)
  {
    if (cf2)
    {
      v6 = v8[v4];
      if (v6)
      {
        if (CFEqual((CFTypeRef)v8[v4], cf2))
          break;
      }
    }
    v5 = v4++ < 5;
    if (v4 == 6)
      return 0;
  }
  if (a2)
    *a2 = v6;
  return v5;
}

uint64_t apply_block_2_8228(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t __Block_byref_object_copy__8233(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__8234(uint64_t a1)
{

}

uint64_t SecItemShareWithGroup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  NSObject *v7;
  uint64_t v8;
  _QWORD v10[6];
  os_activity_scope_state_s state;
  uint64_t v12;
  CFTypeRef cf;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  v6 = (void *)MEMORY[0x18D770A24]();
  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 0;
  v12 = a1;
  cf = 0;
  v7 = _os_activity_create(&dword_18A900000, "SecItemShareWithGroup", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = __SecItemShareWithGroup_block_invoke;
  v10[3] = &unk_1E1FD5DE8;
  v10[4] = &v14;
  v10[5] = a2;
  SecItemAuthDoQuery(&v12, 0, SecItemShareWithGroup, a3, v10);
  if (cf)
    CFRelease(cf);
  v8 = v15[3];
  os_activity_scope_leave(&state);

  _Block_object_dispose(&v14, 8);
  objc_autoreleasePoolPop(v6);
  return v8;
}

void sub_18A9E680C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state, uint64_t a16, uint64_t a17, char a18)
{
  os_activity_scope_leave(&state);
  _Block_object_dispose(&a18, 8);
  _Unwind_Resume(a1);
}

void SecItemAuthMaxAttemptsReached(const __CFArray *a1, __CFString **a2)
{
  const __CFAllocator *v3;
  __CFString *Mutable;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  const __CFArray *ValueAtIndex;
  const __CFData *v9;
  CFIndex Length;
  __CFString *v11;
  const UInt8 *BytePtr;
  CFIndex v13;
  CFIndex v14;
  unsigned int v15;
  const void *v16;
  const __CFString *v17;
  __CFString *v18;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    v6 = Count;
    for (i = 0; i != v6; ++i)
    {
      ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(a1, i);
      v9 = (const __CFData *)CFArrayGetValueAtIndex(ValueAtIndex, 0);
      Length = CFDataGetLength(v9);
      v11 = CFStringCreateMutable(v3, 2 * Length);
      BytePtr = CFDataGetBytePtr(v9);
      v13 = CFDataGetLength(v9);
      if (v13 >= 1)
      {
        v14 = v13;
        do
        {
          v15 = *BytePtr++;
          CFStringAppendFormat(v11, 0, CFSTR("%02X"), v15);
          --v14;
        }
        while (v14);
      }
      v16 = CFArrayGetValueAtIndex(ValueAtIndex, 1);
      v17 = CFStringCreateWithFormat(v3, 0, CFSTR("operation: %@ acl:%@\n"), v16, v11);
      CFStringAppend(Mutable, v17);
      CFRelease(v11);
      CFRelease(v17);
    }
  }
  v18 = (__CFString *)CFStringCreateWithFormat(v3, 0, CFSTR("Reached maximum count of authentication attempts\n %@"), Mutable);
  SecError(-25293, a2, CFSTR("%@"), v18);
  __security_simulatecrash(v18, 0x53C00006u);
  CFRelease(v18);
  CFRelease(Mutable);
}

id SecTokenSessionCreate(__CFString *theString, CFDictionaryRef *a2, __CFString **a3)
{
  const __CFDictionary **v4;
  void *Value;
  const void *v7;
  __CFDictionary *v8;
  __CFDictionary *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  const __CFDictionary *v14;
  void *v15;
  void *v16;
  id v17;
  void *v18;
  void *v19;
  id v21;
  const void *v22;
  id v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFString *v29;
  const __CFDictionary *v30;
  _QWORD v31[2];

  v4 = a2;
  v31[1] = *MEMORY[0x1E0C80C00];
  if (*a2 && CFDictionaryGetValue(*a2, CFSTR("u_CredRef")) || CFStringHasPrefix(theString, CFSTR("com.apple.setoken")))
    goto LABEL_9;
  if (SecTokenSessionCreate_onceToken != -1)
    goto LABEL_37;
  while (1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&SecTokenSessionCreate_lock);
    Value = (void *)CFDictionaryGetValue((CFDictionaryRef)SecTokenSessionCreate_sharedLAContexts, theString);
    if (Value)
      goto LABEL_6;
    if (!LocalAuthenticationLibraryCore())
    {
      SecError(-26276, a3, CFSTR("LocalAuthentication is not available"));
      return 0;
    }
    v21 = objc_alloc_init((Class)getLAContextClass());
    if (!v21)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&SecTokenSessionCreate_lock);
      SecError(-26276, a3, CFSTR("Failed to create authentication context"));
      return 0;
    }
    v22 = v21;
    CFDictionarySetValue((CFMutableDictionaryRef)SecTokenSessionCreate_sharedLAContexts, theString, v21);
    CFRelease(v22);
    Value = (void *)CFDictionaryGetValue((CFDictionaryRef)SecTokenSessionCreate_sharedLAContexts, theString);
    if (Value)
    {
LABEL_6:
      objc_msgSend(Value, "externalizedContext");
      v7 = (const void *)objc_claimAutoreleasedReturnValue();
      if (v7)
      {
        v8 = SecCFDictionaryCOWGetMutable(v4);
        CFDictionarySetValue(v8, CFSTR("u_AuthCtx"), Value);
        v9 = SecCFDictionaryCOWGetMutable(v4);
        CFDictionarySetValue(v9, CFSTR("u_CredRef"), v7);
        CFRelease(v7);
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&SecTokenSessionCreate_lock);
LABEL_9:
    -[__CFDictionary objectForKey:](*v4, "objectForKey:", CFSTR("u_AuthCtx"));
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v10)
    {
      -[__CFDictionary objectForKey:](*v4, "objectForKey:", CFSTR("u_CredRef"));
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      if (v11)
      {
        if (!LocalAuthenticationLibraryCore())
        {
          SecError(-26276, a3, CFSTR("LocalAuthentication is not available"));

          return 0;
        }
        v10 = (void *)objc_msgSend(objc_alloc((Class)getLAContextClass()), "initWithExternalizedContext:", v11);
      }
      else
      {
        v10 = 0;
      }

    }
    if (!CryptoTokenKitLibraryCore())
    {
      v16 = (void *)MEMORY[0x1E0CB35C8];
      v28 = *MEMORY[0x1E0CB2938];
      v29 = CFSTR("CryptoTokenKit is not available");
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v29, &v28, 1);
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v16, "errorWithDomain:code:userInfo:", *MEMORY[0x1E0CB2F90], -4, v15);
      v17 = (id)objc_claimAutoreleasedReturnValue();
      v18 = 0;
      goto LABEL_24;
    }
    if (!SecCTKIsQueryForSystemKeychain(*v4))
      break;
    v24 = 0;
    v25 = &v24;
    v26 = 0x2020000000;
    v4 = (const __CFDictionary **)getTKClientTokenParameterForceSystemSessionSymbolLoc_ptr_8262;
    v27 = getTKClientTokenParameterForceSystemSessionSymbolLoc_ptr_8262;
    if (!getTKClientTokenParameterForceSystemSessionSymbolLoc_ptr_8262)
    {
      v12 = CryptoTokenKitLibrary();
      v4 = (const __CFDictionary **)dlsym(v12, "TKClientTokenParameterForceSystemSession");
      v25[3] = (uint64_t)v4;
      getTKClientTokenParameterForceSystemSessionSymbolLoc_ptr_8262 = (uint64_t)v4;
    }
    _Block_object_dispose(&v24, 8);
    if (v4)
    {
      v30 = *v4;
      v31[0] = MEMORY[0x1E0C9AAB0];
      v13 = (void *)MEMORY[0x1E0C99D80];
      v14 = v30;
      objc_msgSend(v13, "dictionaryWithObjects:forKeys:count:", v31, &v30, 1);
      v15 = (void *)objc_claimAutoreleasedReturnValue();

      goto LABEL_23;
    }
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    a3 = (__CFString **)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "NSString *getTKClientTokenParameterForceSystemSession(void)");
    theString = (__CFString *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(a3, "handleFailureInFunction:file:lineNumber:description:", theString, CFSTR("SecSoftLink.h"), 41, CFSTR("%s"), dlerror());

    __break(1u);
LABEL_37:
    dispatch_once(&SecTokenSessionCreate_onceToken, &__block_literal_global_130);
  }
  v15 = (void *)MEMORY[0x1E0C9AA70];
LABEL_23:
  v19 = (void *)objc_msgSend(objc_alloc((Class)getTKClientTokenClass()), "initWithTokenID:", theString);
  v23 = 0;
  v18 = (void *)objc_msgSend(objc_alloc((Class)getTKClientTokenSessionClass()), "initWithToken:LAContext:parameters:error:", v19, v10, v15, &v23);
  v17 = v23;

LABEL_24:
  if (a3)
  {
    if (!v18)
      *a3 = (__CFString *)v17;
  }

  return v18;
}

void sub_18A9E6DF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

CFDictionaryRef SecItemCopyAttributeDictionary(_QWORD *a1, int a2)
{
  CFTypeID v4;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  __CFDictionary *v7;
  __CFDictionary *v8;
  void *v10;
  CFDataRef v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  __CFDictionary *MutableCopy;

  v4 = CFGetTypeID(a1);
  if (v4 != SecKeyGetTypeID())
  {
    if (v4 == SecCertificateGetTypeID())
      return SecCertificateCopyAttributeDictionary((uint64_t)a1);
    if (v4 != SecIdentityGetTypeID())
      return 0;
    __security_simulatecrash(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
    v10 = (void *)a1[2];
    CFRetain(v10);
    v6 = (const __CFDictionary *)a1[3];
    CFRetain(v6);
    v11 = SecCertificateCopyData((SecCertificateRef)v10);
    v12 = SecKeyCopyAttributes(v6);
    v13 = v12;
    if (v12 && v11)
    {
      MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v12);
      CFDictionarySetValue(MutableCopy, CFSTR("certdata"), v11);
    }
    else
    {
      MutableCopy = 0;
      v8 = 0;
      if (!v12)
        goto LABEL_16;
    }
    CFRelease(v13);
    v8 = MutableCopy;
LABEL_16:
    if (v11)
      CFRelease(v11);
    if (v10)
      CFRelease(v10);
    if (!v6)
      return v8;
    goto LABEL_21;
  }
  v5 = SecKeyCopyAttributes((SecKeyRef)a1);
  v6 = v5;
  if (v5 && a2)
  {
    v7 = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v5);
    v8 = v7;
    if (v7)
    {
      CFDictionaryRemoveValue(v7, CFSTR("sign"));
      CFDictionaryRemoveValue(v8, CFSTR("vrfy"));
      CFDictionaryRemoveValue(v8, CFSTR("encr"));
      CFDictionaryRemoveValue(v8, CFSTR("decr"));
      CFDictionaryRemoveValue(v8, CFSTR("drve"));
      CFDictionaryRemoveValue(v8, CFSTR("wrap"));
      CFDictionaryRemoveValue(v8, CFSTR("unwp"));
      CFDictionaryRemoveValue(v8, CFSTR("snrc"));
      CFDictionaryRemoveValue(v8, CFSTR("vyrc"));
      CFDictionaryRemoveValue(v8, CFSTR("perm"));
    }
LABEL_21:
    CFRelease(v6);
    return v8;
  }
  return v5;
}

uint64_t SecItemAttributesSpecifySystemKeychain(void *a1)
{
  id v1;
  void *v2;
  char v3;
  char v4;
  void *v5;

  v1 = a1;
  objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("u_SystemKeychainAlways"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "BOOLValue");

  if (SecIsEduMode_once != -1)
    dispatch_once(&SecIsEduMode_once, &__block_literal_global_13303);
  if (v3 & 1 | ((SecIsEduMode_result & 1) == 0))
  {
    v4 = SecIsEduMode_result | v3;
  }
  else
  {
    objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("u_SystemKeychain"));
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = objc_msgSend(v5, "BOOLValue");

  }
  return v4 & 1;
}

BOOL __share_with_group_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL8 v10;

  v5 = a2;
  if (SecXPCDictionarySetPListWithRepair(v5, "query", *(const __CFString **)(a1 + 32), a3, v6, v7, v8, v9))v10 = SecXPCDictionarySetString((uint64_t)v5, (uint64_t)"sharingGroup", *(const __CFString **)(a1 + 40), a3);
  else
    v10 = 0;

  return v10;
}

BOOL __share_with_group_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return SecXPCDictionaryCopyPListOptional(a2, (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a3);
}

uint64_t SecTokenItemForEachMatching(const __CFDictionary *a1, CFTypeRef *a2, void *a3)
{
  __CFDictionary *MutableCopy;
  const void *v6;
  uint64_t (*v7)(__CFDictionary *, uint64_t, CFTypeRef *, CFTypeRef *);
  uint64_t v8;
  __CFDictionary *Mutable;
  const __CFDictionary *v10;
  uint64_t v11;
  CFTypeID v12;
  CFTypeID TypeID;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void *v21;
  CFIndex Count;
  CFIndex v23;
  CFIndex v24;
  const __CFDictionary *v25;
  __CFDictionary *v26;
  const __CFDictionary *ValueAtIndex;
  const void *Value;
  const void *v29;
  const void *v30;
  const __CFDictionary *theDict;
  uint64_t (**v33)(id, const __CFDictionary *, __CFDictionary *, CFTypeRef *);
  CFTypeRef cf;
  _QWORD v35[5];
  _QWORD v36[5];

  v33 = a3;
  cf = 0;
  theDict = a1;
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a1);
  if (!CFDictionaryGetValue(MutableCopy, CFSTR("m_Limit")))
    CFDictionarySetValue(MutableCopy, CFSTR("m_Limit"), CFSTR("m_LimitAll"));
  v6 = (const void *)*MEMORY[0x1E0C9AE50];
  CFDictionarySetValue(MutableCopy, CFSTR("r_Data"), (const void *)*MEMORY[0x1E0C9AE50]);
  CFDictionarySetValue(MutableCopy, CFSTR("r_PersistentRef"), v6);
  if (gSecurityd
    && (v7 = *(uint64_t (**)(__CFDictionary *, uint64_t, CFTypeRef *, CFTypeRef *))(gSecurityd + 8)) != 0)
  {
    v8 = SecSecurityClientGet();
    if ((v7(MutableCopy, v8, &cf, a2) & 1) == 0)
      goto LABEL_6;
  }
  else
  {
    SecSecurityClientGet();
    v36[0] = MEMORY[0x1E0C809B0];
    v36[1] = 3221225472;
    v36[2] = __cftype_to_BOOL_cftype_error_request_block_invoke;
    v36[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v36[4] = MutableCopy;
    v35[0] = MEMORY[0x1E0C809B0];
    v35[1] = 3221225472;
    v35[2] = __cftype_to_BOOL_cftype_error_request_block_invoke_2;
    v35[3] = &__block_descriptor_40_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v35[4] = &cf;
    if (!securityd_send_sync_and_do(1u, a2, (uint64_t)v36, (uint64_t)v35))
    {
LABEL_6:
      Mutable = 0;
      v10 = 0;
      v11 = 0;
      if (!MutableCopy)
        goto LABEL_28;
LABEL_27:
      CFRelease(MutableCopy);
      goto LABEL_28;
    }
  }
  v12 = CFGetTypeID(cf);
  TypeID = CFArrayGetTypeID();
  v21 = cf;
  if (v12 != TypeID)
  {
    v21 = CFArrayCreateForCFTypes(0, v14, v15, v16, v17, v18, v19, v20, (uint64_t)cf);
    if (cf)
      CFRelease(cf);
    cf = v21;
  }
  Count = CFArrayGetCount((CFArrayRef)v21);
  if (Count < 1)
  {
    Mutable = 0;
    v10 = 0;
    v11 = 1;
    if (MutableCopy)
      goto LABEL_27;
  }
  else
  {
    v23 = Count;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)cf, v24);
      Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("v_Data"));
      if (!Value)
      {
        SecError(-26276, (__CFString **)a2, CFSTR("value not present for token item"));
        v11 = 0;
        Mutable = v26;
        v10 = v25;
        goto LABEL_26;
      }
      v10 = SecTokenItemValueCopy(Value, a2);
      if (v25)
        CFRelease(v25);
      if (!v10)
      {
        v11 = 0;
        Mutable = v26;
        goto LABEL_26;
      }
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v26)
        CFRelease(v26);
      v29 = CFDictionaryGetValue(ValueAtIndex, CFSTR("v_PersistentRef"));
      CFDictionarySetValue(Mutable, CFSTR("v_PersistentRef"), v29);
      v30 = CFDictionaryGetValue(theDict, CFSTR("u_SystemKeychain"));
      if (v30)
        CFDictionarySetValue(Mutable, CFSTR("u_SystemKeychain"), v30);
      if ((v33[2](v33, v10, Mutable, a2) & 1) == 0)
        break;
      ++v24;
      v25 = v10;
      v26 = Mutable;
      if (v23 == v24)
      {
        v11 = 1;
        goto LABEL_26;
      }
    }
    v11 = 0;
LABEL_26:
    if (MutableCopy)
      goto LABEL_27;
  }
LABEL_28:
  if (cf)
    CFRelease(cf);
  if (v10)
    CFRelease(v10);
  if (Mutable)
    CFRelease(Mutable);

  return v11;
}

void SecTokenProcessError(uint64_t a1, void *a2, uint64_t a3, CFErrorRef *a4)
{
  id v6;
  CFErrorDomain Domain;
  CFErrorDomain v8;
  void *v9;
  id v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFArrayRef v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFErrorRef v29;
  id v30;
  void *userInfoValues;
  const void *valuePtr[2];

  valuePtr[1] = *(const void **)MEMORY[0x1E0C80C00];
  v6 = a2;
  if (CryptoTokenKitLibraryCore() && getTKErrorDomainSymbolLoc())
  {
    Domain = CFErrorGetDomain(*a4);
    getTKErrorDomain();
    if (Domain && v8)
    {
      if (!CFEqual(Domain, v8))
        goto LABEL_16;
    }
    else if (Domain != v8)
    {
      goto LABEL_16;
    }
    if (CFErrorGetCode(*a4) == -9)
    {
      v30 = 0;
      objc_msgSend(v6, "objectForObjectID:error:", a3, &v30);
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      v10 = v30;
      v11 = v10;
      if (!v9)
        *a4 = (CFErrorRef)v10;
      objc_msgSend(v9, "accessControl");
      v12 = (void *)objc_claimAutoreleasedReturnValue();

      if (v12)
      {
        objc_msgSend(v9, "accessControl");
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        v21 = CFArrayCreateForCFTypes(0, v14, v15, v16, v17, v18, v19, v20, (uint64_t)v13);
        userInfoValues = CFArrayCreateForCFTypes(0, v22, v23, v24, v25, v26, v27, v28, (uint64_t)v21);
        valuePtr[0] = (const void *)-25330;
        valuePtr[0] = CFNumberCreate(0, kCFNumberCFIndexType, valuePtr);
        v29 = CFErrorCreateWithUserInfoKeysAndValues(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -25330, valuePtr, (const void *const *)&userInfoValues, 1);
        if (*a4)
          CFRelease(*a4);
        *a4 = v29;
        CFRelease(valuePtr[0]);
        CFRelease(userInfoValues);
        CFRelease(v21);

      }
    }
  }
LABEL_16:

}

void *SecTokenCopyUpdatedObjectID(void *a1, uint64_t a2, const __CFDictionary *a3, CFErrorRef *a4)
{
  id v7;
  CFDictionaryRef Copy;
  id *v9;
  uint64_t v10;
  void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  const __CFDictionary *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t i;
  void *v22;
  const void *v23;
  void *v24;
  const void *Value;
  int v26;
  int v27;
  int v28;
  int v29;
  __CFData *v30;
  id v32;
  const __CFDictionary *v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE v40[128];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a3);
  if (a2)
  {
    v38 = 0;
    v9 = (id *)&v38;
    objc_msgSend(v7, "objectForObjectID:error:", a2, &v38);
    v10 = objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v39 = 0;
    v9 = (id *)&v39;
    objc_msgSend(v7, "createObjectWithAttributes:error:", a3, &v39);
    v10 = objc_claimAutoreleasedReturnValue();
  }
  v11 = (void *)v10;
  v12 = *v9;
  v13 = v12;
  if (a4 && !v11)
  {
    *a4 = (CFErrorRef)v12;
LABEL_7:
    if (a2)
      v14 = a2;
    else
      v14 = (uint64_t)a3;
    SecTokenProcessError((uint64_t)CFSTR("oe"), v7, v14, a4);
    v15 = 0;
    goto LABEL_28;
  }
  if (!v11)
    goto LABEL_7;
  v32 = v12;
  CFDictionaryRemoveAllValues(a3);
  objc_msgSend(v11, "keychainAttributes");
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  -[__CFDictionary addEntriesFromDictionary:](a3, "addEntriesFromDictionary:", v16);

  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v33 = Copy;
  v17 = Copy;
  v18 = -[__CFDictionary countByEnumeratingWithState:objects:count:](v17, "countByEnumeratingWithState:objects:count:", &v34, v40, 16);
  if (v18)
  {
    v19 = v18;
    v20 = *(_QWORD *)v35;
    do
    {
      for (i = 0; i != v19; ++i)
      {
        if (*(_QWORD *)v35 != v20)
          objc_enumerationMutation(v17);
        v22 = *(void **)(*((_QWORD *)&v34 + 1) + 8 * i);
        if ((objc_msgSend(v22, "isEqualToString:", CFSTR("v_Data"), v32) & 1) == 0)
          CFDictionaryAddValue(a3, v22, (const void *)-[__CFDictionary objectForKey:](v17, "objectForKey:", v22));
      }
      v19 = -[__CFDictionary countByEnumeratingWithState:objects:count:](v17, "countByEnumeratingWithState:objects:count:", &v34, v40, 16);
    }
    while (v19);
  }

  objc_msgSend(v11, "accessControl");
  v23 = (const void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "objectID");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  Value = CFDictionaryGetValue(a3, CFSTR("v_Data"));
  v30 = SecTokenItemValueCreate((uint64_t)v24, (int)v23, Value, (CFTypeRef *)a4, v26, v27, v28, v29);

  if (v30)
  {
    CFDictionarySetValue(a3, CFSTR("v_Data"), v30);
    CFDictionaryRemoveValue(a3, CFSTR("accc"));
    objc_msgSend(v11, "objectID");
    v15 = (void *)objc_claimAutoreleasedReturnValue();

    if (v15)
      CFRetain(v15);
  }
  else
  {
    v15 = 0;
  }
  v13 = v32;
  Copy = v33;
  if (v23)
    CFRelease(v23);
  if (v30)
    CFRelease(v30);
LABEL_28:
  if (Copy)
    CFRelease(Copy);

  return v15;
}

__CFData *SecTokenItemValueCreate(uint64_t a1, int a2, const void *a3, CFTypeRef *a4, int a5, int a6, int a7, int a8)
{
  __CFDictionary *MutableForCFTypesWith_8305;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  __CFData *DERData;

  MutableForCFTypesWith_8305 = CFDictionaryCreateMutableForCFTypesWith_8305(a1, a2, (int)a3, (int)a4, a5, a6, a7, a8, CFSTR("oid"), a1);
  v16 = (const __CFString *)MutableForCFTypesWith_8305;
  if (a3)
    CFDictionarySetValue(MutableForCFTypesWith_8305, CFSTR("data"), a3);
  DERData = CFPropertyListCreateDERData((uint64_t)MutableForCFTypesWith_8305, v16, a4, v11, v12, v13, v14, v15);
  CFRelease(v16);
  return DERData;
}

__CFDictionary *CFDictionaryCreateMutableForCFTypesWith_8305(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *key, uint64_t a10)
{
  __CFDictionary *Mutable;
  const void *v11;
  const void **v12;
  const void **v14;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v14 = (const void **)&a10;
  v11 = key;
  if (key)
  {
    do
    {
      CFDictionarySetValue(Mutable, v11, *v14);
      v12 = v14 + 1;
      v14 += 2;
      v11 = *v12;
    }
    while (*v12);
  }
  return Mutable;
}

uint64_t SecDeleteItemsOnSignOut(CFTypeRef *a1)
{
  void *v2;
  NSObject *v3;
  uint64_t (*v4)(uint64_t, CFTypeRef *);
  uint64_t v5;
  uint64_t v6;
  _QWORD v8[5];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;
  os_activity_scope_state_s state;

  v2 = (void *)MEMORY[0x18D770A24]();
  v3 = _os_activity_create(&dword_18A900000, "SecDeleteItemsOnSignOut", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &state);
  if (gSecurityd)
  {
    v4 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gSecurityd + 104);
    v5 = SecSecurityClientGet();
    v6 = v4(v5, a1);
  }
  else
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2020000000;
    v12 = 0;
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = __SecDeleteItemsOnSignOut_block_invoke;
    v8[3] = &unk_1E1FD5DC0;
    v8[4] = &v9;
    securityd_send_sync_and_do(0x84u, a1, 0, (uint64_t)v8);
    v6 = *((_BYTE *)v10 + 24) != 0;
    _Block_object_dispose(&v9, 8);
  }
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v2);
  return v6;
}

void sub_18A9E807C(_Unwind_Exception *a1)
{
  uint64_t v1;

  os_activity_scope_leave((os_activity_scope_state_t)(v1 - 48));
  _Unwind_Resume(a1);
}

uint64_t _SecKeychainForceUpgradeIfNeeded()
{
  void *v0;
  void *v1;
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = -26276;
  v0 = (void *)MEMORY[0x18D770A24]();
  SecuritydXPCProxyObject(1, &__block_literal_global_35_8313);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = ___SecKeychainForceUpgradeIfNeeded_block_invoke_36;
  v4[3] = &unk_1E1FD5F68;
  v4[4] = &v5;
  objc_msgSend(v1, "secKeychainForceUpgradeIfNeeded:", v4);

  objc_autoreleasePoolPop(v0);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18A9E819C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SecItemDeleteAll()
{
  void *v0;
  uint64_t v1;

  v0 = (void *)MEMORY[0x18D770A24]();
  v1 = SecOSStatusWith((uint64_t)&__block_literal_global_39);
  objc_autoreleasePoolPop(v0);
  return v1;
}

uint64_t SecItemDeleteAllWithAccessGroups()
{
  return 1;
}

uint64_t SecItemUpdateTokenItemsForAccessGroups(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v6;
  NSObject *v7;
  uint64_t v8;
  _QWORD v10[7];
  os_activity_scope_state_s state;

  v6 = (void *)MEMORY[0x18D770A24]();
  v7 = _os_activity_create(&dword_18A900000, "SecItemUpdateTokenItemsForAccessGroups", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v7, &state);
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 3221225472;
  v10[2] = __SecItemUpdateTokenItemsForAccessGroups_block_invoke;
  v10[3] = &__block_descriptor_56_e20_B16__0_____CFError_8l;
  v10[4] = a3;
  v10[5] = a1;
  v10[6] = a2;
  v8 = SecOSStatusWith((uint64_t)v10);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v6);
  return v8;
}

void sub_18A9E84B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

BOOL __cfstring_array_array_to_error_request_block_invoke(_QWORD *a1, void *a2, __CFString **a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  _BOOL8 v14;

  v5 = a2;
  v10 = v5;
  v11 = (const __CFString *)a1[4];
  v14 = 0;
  if (!v11 || SecXPCDictionarySetString((uint64_t)v5, (uint64_t)"cfstring", v11, a3))
  {
    v12 = (const __CFString *)a1[5];
    if (!v12 || SecXPCDictionarySetPListWithRepair(v10, "cfarray", v12, a3, v6, v7, v8, v9))
    {
      v13 = (const __CFString *)a1[6];
      if (!v13 || SecXPCDictionarySetPListWithRepair(v10, "query", v13, a3, v6, v7, v8, v9))
        v14 = 1;
    }
  }

  return v14;
}

uint64_t _SecKeychainSyncUpdateMessage(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  _QWORD activity_block[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;

  v4 = (void *)MEMORY[0x18D770A24]();
  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 3221225472;
  activity_block[2] = ___SecKeychainSyncUpdateMessage_block_invoke;
  activity_block[3] = &unk_1E1FD5FF0;
  activity_block[4] = &v8;
  activity_block[5] = a1;
  activity_block[6] = a2;
  _os_activity_initiate(&dword_18A900000, "_SecKeychainSyncUpdateMessage", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  objc_autoreleasePoolPop(v4);
  return v5;
}

uint64_t _SecKeychainRollKeys(uint64_t a1, CFTypeRef *a2)
{
  void *v4;
  uint64_t (*v5)(uint64_t, CFTypeRef *);
  uint64_t v6;
  _QWORD v8[5];
  _QWORD v9[4];
  char v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;

  v4 = (void *)MEMORY[0x18D770A24]();
  if (gSecurityd && (v5 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gSecurityd + 72)) != 0)
  {
    v6 = v5(a1, a2);
  }
  else
  {
    v11 = 0;
    v12 = &v11;
    v13 = 0x2020000000;
    v14 = 0;
    v8[4] = &v11;
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = ___SecKeychainRollKeys_block_invoke;
    v9[3] = &__block_descriptor_33_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v10 = a1;
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 3221225472;
    v8[2] = ___SecKeychainRollKeys_block_invoke_2;
    v8[3] = &unk_1E1FD5DC0;
    securityd_send_sync_and_do(0x1Du, a2, (uint64_t)v9, (uint64_t)v8);
    v6 = *((_BYTE *)v12 + 24) != 0;
    _Block_object_dispose(&v11, 8);
  }
  objc_autoreleasePoolPop(v4);
  return v6;
}

BOOL __data_array_to_array_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return SecXPCDictionaryCopyArrayOptional(a2, "status", (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a3);
}

uint64_t SecItemCertificateExists(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  void *v8;
  NSObject *v9;
  uint64_t (*v10)(uint64_t, uint64_t, uint64_t, CFTypeRef *);
  uint64_t v11;
  os_activity_scope_state_s v13;
  _QWORD v14[5];
  _QWORD v15[7];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;

  v8 = (void *)MEMORY[0x18D770A24]();
  v9 = _os_activity_create(&dword_18A900000, "SecItemCertificateExists", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v13.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v13.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &v13);
  if (gSecurityd && (v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, CFTypeRef *))(gSecurityd + 48)) != 0)
  {
    v11 = v10(a1, a2, a3, a4);
  }
  else
  {
    v16 = 0;
    v17 = &v16;
    v18 = 0x2020000000;
    v19 = 0;
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = __data_data_array_to_BOOL_error_request_block_invoke;
    v15[3] = &__block_descriptor_56_e48_B24__0__NSObject_OS_xpc_object__8_____CFError_16l;
    v15[4] = a1;
    v15[5] = a2;
    v15[6] = a3;
    v14[0] = MEMORY[0x1E0C809B0];
    v14[1] = 3221225472;
    v14[2] = __data_data_array_to_BOOL_error_request_block_invoke_2;
    v14[3] = &unk_1E1FD5DC0;
    v14[4] = &v16;
    securityd_send_sync_and_do(0x6Eu, a4, (uint64_t)v15, (uint64_t)v14);
    v11 = *((_BYTE *)v17 + 24) != 0;
    _Block_object_dispose(&v16, 8);
  }
  os_activity_scope_leave(&v13);

  objc_autoreleasePoolPop(v8);
  return v11;
}

void sub_18A9E8CE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

uint64_t _SecItemAddAndNotifyOnSync(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  NSObject *v6;
  id v7;
  uint64_t v8;
  const void *v9;
  _QWORD v11[4];
  id v12;
  uint64_t *v13;
  uint64_t v14;
  os_activity_scope_state_s state;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;

  v5 = a3;
  v16 = 0;
  v17 = &v16;
  v18 = 0x3010000000;
  v19 = &unk_18AA98BF6;
  v20 = a1;
  v21 = 0;
  v6 = _os_activity_create(&dword_18A900000, "_SecItemAddAndNotifyOnSync", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = ___SecItemAddAndNotifyOnSync_block_invoke;
  v11[3] = &unk_1E1FD60D8;
  v13 = &v16;
  v7 = v5;
  v12 = v7;
  v14 = a2;
  v8 = SecOSStatusWith((uint64_t)v11);
  v9 = (const void *)v17[5];
  if (v9)
  {
    v17[5] = 0;
    CFRelease(v9);
  }

  os_activity_scope_leave(&state);
  _Block_object_dispose(&v16, 8);

  return v8;
}

void sub_18A9E8ED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
  os_activity_scope_leave(&state);
  _Block_object_dispose(&a18, 8);
  _Unwind_Resume(a1);
}

void sub_18A9E91DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 128), 8);
  _Unwind_Resume(a1);
}

void SecItemSetCurrentItemAcrossAllDevices(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  id v12;
  NSObject *v13;
  void *v14;
  uint64_t v15;
  id v16;
  void *v17;
  id v18;
  _QWORD v22[4];
  id v23;
  _QWORD v24[4];
  id v25;
  os_activity_scope_state_s state;

  v12 = a8;
  v13 = _os_activity_create(&dword_18A900000, "SecItemSetCurrentItemAcrossAllDevices", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v13, &state);
  v14 = (void *)MEMORY[0x18D770A24]();
  v15 = MEMORY[0x1E0C809B0];
  v24[0] = MEMORY[0x1E0C809B0];
  v24[1] = 3221225472;
  v24[2] = __SecItemSetCurrentItemAcrossAllDevices_block_invoke;
  v24[3] = &unk_1E1FD6038;
  v16 = v12;
  v25 = v16;
  SecuritydXPCProxyObject(0, v24);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v22[0] = v15;
  v22[1] = 3221225472;
  v22[2] = __SecItemSetCurrentItemAcrossAllDevices_block_invoke_2;
  v22[3] = &unk_1E1FD6038;
  v18 = v16;
  v23 = v18;
  objc_msgSend(v17, "secItemSetCurrentItemAcrossAllDevices:newCurrentItemHash:accessGroup:identifier:viewHint:oldCurrentItemReference:oldCurrentItemHash:complete:", a4, a5, a1, a2, a3, a6, a7, v22);

  objc_autoreleasePoolPop(v14);
  os_activity_scope_leave(&state);

}

void sub_18A9E9430(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void SecItemUnsetCurrentItemsAcrossAllDevices(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7;
  NSObject *v8;
  void *v9;
  uint64_t v10;
  id v11;
  void *v12;
  id v13;
  _QWORD v14[4];
  id v15;
  _QWORD v16[4];
  id v17;
  os_activity_scope_state_s state;

  v7 = a4;
  v8 = _os_activity_create(&dword_18A900000, "SecItemUnsetCurrentItemsAcrossAllDevices", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  v9 = (void *)MEMORY[0x18D770A24]();
  v10 = MEMORY[0x1E0C809B0];
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3221225472;
  v16[2] = __SecItemUnsetCurrentItemsAcrossAllDevices_block_invoke;
  v16[3] = &unk_1E1FD6038;
  v11 = v7;
  v17 = v11;
  SecuritydXPCProxyObject(0, v16);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v14[0] = v10;
  v14[1] = 3221225472;
  v14[2] = __SecItemUnsetCurrentItemsAcrossAllDevices_block_invoke_2;
  v14[3] = &unk_1E1FD6038;
  v13 = v11;
  v15 = v13;
  objc_msgSend(v12, "secItemUnsetCurrentItemsAcrossAllDevices:identifiers:viewHint:complete:", a1, a2, a3, v14);

  objc_autoreleasePoolPop(v9);
  os_activity_scope_leave(&state);

}

void sub_18A9E95A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void SecItemFetchCurrentItemAcrossAllDevices(void *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9;
  id v10;
  _QWORD v11[4];
  id v12;

  v9 = a5;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = __SecItemFetchCurrentItemAcrossAllDevices_block_invoke;
  v11[3] = &unk_1E1FD6100;
  v12 = v9;
  v10 = v9;
  SecItemFetchCurrentItemDataAcrossAllDevices(a1, a2, a3, a4, v11);

}

void SecItemFetchCurrentItemDataAcrossAllDevices(void *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9;
  id v10;
  id v11;
  id v12;
  NSObject *v13;
  void *v14;
  uint64_t v15;
  id v16;
  void *v17;
  id v18;
  _QWORD v19[4];
  id v20;
  _QWORD v21[4];
  id v22;
  os_activity_scope_state_s state;

  v9 = a1;
  v10 = a2;
  v11 = a3;
  v12 = a5;
  v13 = _os_activity_create(&dword_18A900000, "SecItemFetchCurrentItemDataAcrossAllDevices", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v13, &state);
  v14 = (void *)MEMORY[0x18D770A24]();
  v15 = MEMORY[0x1E0C809B0];
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 3221225472;
  v21[2] = __SecItemFetchCurrentItemDataAcrossAllDevices_block_invoke;
  v21[3] = &unk_1E1FD6038;
  v16 = v12;
  v22 = v16;
  SecuritydXPCProxyObject(0, v21);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v19[0] = v15;
  v19[1] = 3221225472;
  v19[2] = __SecItemFetchCurrentItemDataAcrossAllDevices_block_invoke_2;
  v19[3] = &unk_1E1FD6128;
  v18 = v16;
  v20 = v18;
  objc_msgSend(v17, "secItemFetchCurrentItemAcrossAllDevices:identifier:viewHint:fetchCloudValue:complete:", v9, v10, v11, a4, v19);

  objc_autoreleasePoolPop(v14);
  os_activity_scope_leave(&state);

}

void sub_18A9E9858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void _SecItemFetchDigests(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  NSObject *v8;
  id v9;
  void *v10;
  _QWORD v11[4];
  id v12;
  os_activity_scope_state_s state;

  v5 = a1;
  v6 = a2;
  v7 = a3;
  v8 = _os_activity_create(&dword_18A900000, "_SecItemFetchDigests", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 3221225472;
  v11[2] = ___SecItemFetchDigests_block_invoke;
  v11[3] = &unk_1E1FD6038;
  v9 = v7;
  v12 = v9;
  SecuritydXPCProxyObject(0, v11);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "secItemDigest:accessGroup:complete:", v5, v6, v9);

  os_activity_scope_leave(&state);
}

void sub_18A9E9A2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void _SecKeychainDeleteMultiUser(void *a1, void *a2)
{
  id v3;
  id v4;
  NSObject *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  id v9;
  _QWORD *v10;
  FakeSecuritydXPCClient *v11;
  FakeSecuritydXPCClient *v12;
  id v13;
  void *v14;
  void *v15;
  CFTypeRef v16;
  void *v17;
  void *v18;
  void *v19;
  _QWORD v20[4];
  id v21;
  CFTypeRef *v22;
  _QWORD v23[4];
  id v24;
  _QWORD v25[2];
  uint64_t (*v26)(uint64_t);
  void *v27;
  id v28;
  os_activity_scope_state_s state;
  CFTypeRef cf[5];
  FakeSecuritydXPCClient *v31;
  _QWORD v32[2];
  _QWORD v33[3];

  v33[1] = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  v5 = _os_activity_create(&dword_18A900000, "_SecKeychainDeleteMultiUser", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3A28]), "initWithUUIDString:", v3);
  v7 = v6;
  if (v6)
  {
    v32[0] = 0xAAAAAAAAAAAAAAAALL;
    v32[1] = 0xAAAAAAAAAAAAAAAALL;
    objc_msgSend(v6, "getUUIDBytes:", v32);
    v8 = MEMORY[0x1E0C809B0];
    v25[0] = MEMORY[0x1E0C809B0];
    v25[1] = 3221225472;
    v26 = ___SecKeychainDeleteMultiUser_block_invoke;
    v27 = &unk_1E1FD6038;
    v9 = v4;
    v28 = v9;
    v10 = v25;
    if (gSecurityd && *(_QWORD *)(gSecurityd + 696))
      v11 = objc_alloc_init(FakeSecuritydXPCClient);
    else
      v11 = -[SecuritydXPCClient initTargetingSession:]([SecuritydXPCClient alloc], "initTargetingSession:", 0);
    v12 = v11;
    if (v11)
    {

      v23[0] = v8;
      v23[1] = 3221225472;
      v23[2] = ___SecKeychainDeleteMultiUser_block_invoke_2;
      v23[3] = &unk_1E1FD6038;
      v13 = v9;
      v24 = v13;
      -[FakeSecuritydXPCClient protocolWithSync:errorHandler:](v12, "protocolWithSync:errorHandler:", 0, v23);
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      if (v14)
      {
        cf[0] = 0;
        cf[1] = cf;
        cf[2] = (CFTypeRef)0x3032000000;
        cf[3] = __Block_byref_object_copy__8233;
        cf[4] = __Block_byref_object_dispose__8234;
        v31 = v12;
        objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v32, 16);
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        v20[0] = v8;
        v20[1] = 3221225472;
        v20[2] = ___SecKeychainDeleteMultiUser_block_invoke_74;
        v20[3] = &unk_1E1FD6150;
        v21 = v13;
        v22 = cf;
        objc_msgSend(v14, "secKeychainDeleteMultiuser:complete:", v15, v20);

        _Block_object_dispose(cf, 8);
      }

    }
    else
    {
      v17 = (void *)MEMORY[0x1E0CB35C8];
      v33[0] = *MEMORY[0x1E0CB2D50];
      cf[0] = CFSTR("Could not create SecuritydXPCClientObject");
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", cf, v33, 1);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v17, "errorWithDomain:code:userInfo:", CFSTR("securityd"), -1, v18);
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      ((void (*)(_QWORD *, void *))v26)(v10, v19);

    }
  }
  else
  {
    cf[0] = 0;
    SecError(-50, (__CFString **)cf, CFSTR("_SecKeychainDeleteMultiUser: invalid UUID %@"), v3);
    (*((void (**)(id, _QWORD, CFTypeRef))v4 + 2))(v4, 0, cf[0]);
    v16 = cf[0];
    if (cf[0])
    {
      cf[0] = 0;
      CFRelease(v16);
    }
  }

  os_activity_scope_leave(&state);
}

void sub_18A9E9D9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,os_activity_scope_state_s state,char a27)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t SecItemDeleteKeychainItemsForAppClip(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  _QWORD v6[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = -26276;
  v2 = (void *)MEMORY[0x18D770A24]();
  SecuritydXPCProxyObject(1, &__block_literal_global_75);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 3221225472;
  v6[2] = __SecItemDeleteKeychainItemsForAppClip_block_invoke_76;
  v6[3] = &unk_1E1FD5F68;
  v6[4] = &v7;
  objc_msgSend(v3, "secItemDeleteForAppClipApplicationIdentifier:completion:", a1, v6);

  objc_autoreleasePoolPop(v2);
  v4 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_18A9E9F08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SecItemPersistKeychainWritesAtHighPerformanceCost(_QWORD *a1)
{
  NSObject *v2;
  void *v3;
  NSObject *v4;
  uint64_t v5;
  void *v6;
  uint64_t *v7;
  const void *v8;
  uint64_t v9;
  _QWORD v11[6];
  _QWORD v12[5];
  uint8_t buf[16];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;
  os_activity_scope_state_s state;

  v2 = _os_activity_create(&dword_18A900000, "SecItemPersistKeychainWritesAtHighPerformanceCost", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &state);
  v18 = 0;
  v19 = &v18;
  v20 = 0x2020000000;
  v21 = -26276;
  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 0;
  v3 = (void *)MEMORY[0x18D770A24]();
  secLogObjForScope("xpc");
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "This process is requesting a expensive full keychain database checkpoint", buf, 2u);
  }

  v5 = MEMORY[0x1E0C809B0];
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 3221225472;
  v12[2] = __SecItemPersistKeychainWritesAtHighPerformanceCost_block_invoke;
  v12[3] = &unk_1E1FD8560;
  v12[4] = &v14;
  SecuritydXPCProxyObject(1, v12);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v11[0] = v5;
  v11[1] = 3221225472;
  v11[2] = __SecItemPersistKeychainWritesAtHighPerformanceCost_block_invoke_77;
  v11[3] = &unk_1E1FD6178;
  v11[4] = &v14;
  v11[5] = &v18;
  objc_msgSend(v6, "secItemPersistKeychainWritesAtHighPerformanceCost:", v11);

  objc_autoreleasePoolPop(v3);
  v7 = v15;
  v8 = (const void *)v15[3];
  if (v8)
  {
    if (!a1 || (CFRetain((CFTypeRef)v15[3]), *a1 = v8, v7 = v15, (v8 = (const void *)v15[3]) != 0))
    {
      v7[3] = 0;
      CFRelease(v8);
    }
  }
  v9 = *((unsigned int *)v19 + 6);
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  os_activity_scope_leave(&state);

  return v9;
}

void sub_18A9EA280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  uint64_t v15;
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 128), 8);
  os_activity_scope_leave((os_activity_scope_state_t)(v15 - 96));
  _Unwind_Resume(a1);
}

uint64_t SecItemPromoteAppClipItemsToParentApp(uint64_t a1, uint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD v8[5];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v12 = -26276;
  v4 = (void *)MEMORY[0x18D770A24]();
  SecuritydXPCProxyObject(1, &__block_literal_global_79);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = __SecItemPromoteAppClipItemsToParentApp_block_invoke_80;
  v8[3] = &unk_1E1FD5F68;
  v8[4] = &v9;
  objc_msgSend(v5, "secItemPromoteItemsForAppClip:toParentApp:completion:", a1, a2, v8);

  objc_autoreleasePoolPop(v4);
  v6 = *((unsigned int *)v10 + 6);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_18A9EA598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__loadUIKit_block_invoke()
{
  void *v0;
  int v1;
  const char *v2;
  void *result;

  objc_msgSend(MEMORY[0x1E0CB3898], "processInfo");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = objc_msgSend(v0, "isMacCatalystApp");

  if (v1)
    v2 = "/System/Library/iOSSupport/System/Library/Frameworks/UIKit.framework/UIKit";
  else
    v2 = "/System/Library/Frameworks/UIKit.framework/UIKit";
  result = dlopen(v2, 1);
  if (result)
  {
    result = NSClassFromString(CFSTR("UIApplication"));
    kUIApplicationClass = (uint64_t)result;
  }
  return result;
}

void *__loadAuthenticationServices_block_invoke()
{
  void *v0;
  int v1;
  const char *v2;
  void *result;

  objc_msgSend(MEMORY[0x1E0CB3898], "processInfo");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  v1 = objc_msgSend(v0, "isMacCatalystApp");

  if (v1)
    v2 = "/System/iOSSupport/System/Library/Frameworks/AuthenticationServices.framework/AuthenticationServices";
  else
    v2 = "/System/Library/Frameworks/AuthenticationServices.framework/AuthenticationServices";
  result = dlopen(v2, 1);
  if (result)
  {
    kASAuthorizationControllerClass = (uint64_t)NSClassFromString(CFSTR("ASAuthorizationController"));
    kASAuthorizationPasswordProviderClass = (uint64_t)NSClassFromString(CFSTR("ASAuthorizationPasswordProvider"));
    result = NSClassFromString(CFSTR("ASPasswordCredential"));
    kASPasswordCredentialClass = (uint64_t)result;
  }
  return result;
}

uint64_t _SecKeychainCopyOTABackup()
{
  uint64_t v0;
  _QWORD activity_block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = ___SecKeychainCopyOTABackup_block_invoke;
  activity_block[3] = &unk_1E1FD62F0;
  activity_block[4] = &v3;
  _os_activity_initiate(&dword_18A900000, "_SecKeychainCopyOTABackup", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v0 = v4[3];
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t client_data_data_BOOL_to_data_error_request(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3;
  _QWORD v5[5];
  _QWORD v6[6];
  char v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __client_data_data_BOOL_to_data_error_request_block_invoke;
  v6[3] = &__block_descriptor_tmp_33_8461;
  v6[4] = a1;
  v6[5] = a2;
  v7 = a3;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __client_data_data_BOOL_to_data_error_request_block_invoke_2;
  v5[3] = &unk_1E1FD6700;
  v5[4] = &v8;
  securityd_send_sync_and_do(9u, 0, (uint64_t)v6, (uint64_t)v5);
  v3 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t _SecKeychainCopyBackup(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD activity_block[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = ___SecKeychainCopyBackup_block_invoke;
  activity_block[3] = &unk_1E1FD6318;
  activity_block[4] = &v5;
  activity_block[5] = a1;
  activity_block[6] = a2;
  _os_activity_initiate(&dword_18A900000, "_SecKeychainCopyBackup", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t _SecKeychainCopyEMCSBackup(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0xAAAAAAAAAAAAAAAALL;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = ___SecKeychainCopyEMCSBackup_block_invoke;
  v3[3] = &unk_1E1FD6340;
  v3[4] = &v4;
  v3[5] = a1;
  _os_activity_initiate(&dword_18A900000, "_SecKeychainCopyEMCSBackup", OS_ACTIVITY_FLAG_DEFAULT, v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t _SecKeychainWriteBackupToFileDescriptor(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD activity_block[8];
  int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = ___SecKeychainWriteBackupToFileDescriptor_block_invoke;
  activity_block[3] = &unk_1E1FD63B0;
  activity_block[6] = a1;
  activity_block[7] = a2;
  v7 = a3;
  activity_block[4] = &v8;
  activity_block[5] = a4;
  _os_activity_initiate(&dword_18A900000, "_SecKeychainWriteBackupToFile", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v4 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v4;
}

uint64_t _SecKeychainRestoreBackupFromFileDescriptor(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD activity_block[8];
  int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = -86;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = ___SecKeychainRestoreBackupFromFileDescriptor_block_invoke;
  activity_block[3] = &unk_1E1FD6420;
  v7 = a1;
  activity_block[6] = a2;
  activity_block[7] = a3;
  activity_block[4] = &v8;
  activity_block[5] = a4;
  _os_activity_initiate(&dword_18A900000, "_SecKeychainRestoreBackup", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v4 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v4;
}

uint64_t _SecKeychainCopyKeybagUUIDFromFileDescriptor(int a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD activity_block[6];
  int v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = ___SecKeychainCopyKeybagUUIDFromFileDescriptor_block_invoke;
  activity_block[3] = &unk_1E1FD6490;
  v5 = a1;
  activity_block[4] = &v6;
  activity_block[5] = a2;
  _os_activity_initiate(&dword_18A900000, "_SecKeychainCopyKeybagUUID", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v2 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v2;
}

uint64_t _SecKeychainRestoreBackup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD v5[8];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = -1431655766;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = ___SecKeychainRestoreBackup_block_invoke;
  v5[3] = &unk_1E1FD64D8;
  v5[4] = &v6;
  v5[5] = a1;
  v5[6] = a2;
  v5[7] = a3;
  _os_activity_initiate(&dword_18A900000, "_SecKeychainRestoreBackup", OS_ACTIVITY_FLAG_DEFAULT, v5);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

BOOL __data_client_data_data_to_error_request_block_invoke(CFDataRef *a1, void *a2, __CFString **a3)
{
  _BOOL8 result;
  const __CFData *v7;

  result = SecXPCDictionarySetData(a2, "backup", a1[4], a3);
  if (result)
  {
    result = SecXPCDictionarySetData(a2, "keybag", a1[5], a3);
    if (result)
    {
      v7 = a1[6];
      return !v7 || SecXPCDictionarySetData(a2, "password", v7, a3);
    }
  }
  return result;
}

CFMutableDataRef SecItemBackupCreateManifest(const __CFDictionary *a1)
{
  CFIndex Count;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  CFIndex Length;
  _QWORD context[5];

  if (!a1)
    return CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  Count = CFDictionaryGetCount(a1);
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 20 * Count);
  context[0] = MEMORY[0x1E0C809B0];
  context[1] = 0x40000000;
  context[2] = __SecItemBackupCreateManifest_block_invoke;
  context[3] = &__block_descriptor_tmp_19_8484;
  context[4] = Mutable;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)apply_block_2_8485, context);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  Length = CFDataGetLength(Mutable);
  qsort(MutableBytePtr, Length / 20, 0x14uLL, (int (__cdecl *)(const void *, const void *))compareDigests);
  return Mutable;
}

uint64_t apply_block_2_8485(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t compareDigests(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = bswap64(*(_QWORD *)a1);
  v3 = bswap64(*(_QWORD *)a2);
  if (v2 == v3)
  {
    v2 = bswap64(*(_QWORD *)(a1 + 8));
    v3 = bswap64(*(_QWORD *)(a2 + 8));
    if (v2 == v3)
    {
      v2 = bswap32(*(_DWORD *)(a1 + 16));
      v3 = bswap32(*(_DWORD *)(a2 + 16));
      if (v2 == v3)
        return 0;
    }
  }
  if (v2 < v3)
    return 0xFFFFFFFFLL;
  return 1;
}

uint64_t _SecKeychainBackupSyncable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD v5[8];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = ___SecKeychainBackupSyncable_block_invoke;
  v5[3] = &__block_descriptor_tmp_20;
  v5[4] = a4;
  v5[5] = a3;
  v5[6] = a1;
  v5[7] = a2;
  return SecOSStatusWith((uint64_t)v5);
}

uint64_t __data_data_dict_to_dict_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v11;
  uint64_t result;
  const __CFData *v13;

  v11 = *(const __CFString **)(a1 + 32);
  if (!v11 || (result = SecXPCDictionarySetPListWithRepair(a2, "backup", v11, a3, a5, a6, a7, a8), (_DWORD)result))
  {
    result = SecXPCDictionarySetData(a2, "keybag", *(CFDataRef *)(a1 + 40), a3);
    if ((_DWORD)result)
    {
      v13 = *(const __CFData **)(a1 + 48);
      return !v13 || SecXPCDictionarySetData(a2, "password", v13, a3);
    }
  }
  return result;
}

BOOL __data_data_dict_to_dict_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  const void *v4;

  v4 = SecXPCDictionaryCopyDictionaryAndPossiblyMutateMessage(1, a2, "status", a3);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
  return v4 != 0;
}

uint64_t _SecKeychainRestoreSyncable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD v5[8];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = -1431655766;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = ___SecKeychainRestoreSyncable_block_invoke;
  v5[3] = &unk_1E1FD6560;
  v5[4] = &v6;
  v5[5] = a3;
  v5[6] = a1;
  v5[7] = a2;
  _os_activity_initiate(&dword_18A900000, "_SecKeychainRestoreSyncable", OS_ACTIVITY_FLAG_DEFAULT, v5);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t __dict_data_data_to_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  const __CFData *v12;

  result = SecXPCDictionarySetPListWithRepair(a2, "backup", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    result = SecXPCDictionarySetData(a2, "keybag", *(CFDataRef *)(a1 + 40), a3);
    if ((_DWORD)result)
    {
      v12 = *(const __CFData **)(a1 + 48);
      return !v12 || SecXPCDictionarySetData(a2, "password", v12, a3);
    }
  }
  return result;
}

BOOL SecItemBackupWithRegisteredBackups(uint64_t a1, uint64_t a2)
{
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const void *ValueAtIndex;
  _QWORD v9[6];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  unint64_t v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0xAAAAAAAAAAAAAAAALL;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __SecItemBackupCopyNames_block_invoke;
  v9[3] = &unk_1E1FD67B0;
  v9[4] = &v10;
  v9[5] = a1;
  _os_activity_initiate(&dword_18A900000, "SecItemBackupCopyNames", OS_ACTIVITY_FLAG_DEFAULT, v9);
  v3 = (const __CFArray *)v11[3];
  _Block_object_dispose(&v10, 8);
  if (v3)
  {
    Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      v5 = Count;
      for (i = 0; i != v5; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v3, i);
        (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, ValueAtIndex);
      }
    }
    CFRelease(v3);
  }
  return v3 != 0;
}

BOOL __to_array_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  const void *v4;

  v4 = SecXPCDictionaryCopyArray(a2, "status", a3);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
  return v4 != 0;
}

uint64_t __to_array_error_request_block_invoke()
{
  return 1;
}

BOOL SecItemBackupWithRegisteredViewBackup(uint64_t a1, uint64_t a2)
{
  const void *v2;
  _QWORD activity_block[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecItemBackupViewAndCopyBackupPeerID_block_invoke;
  activity_block[3] = &unk_1E1FD6840;
  activity_block[4] = &v5;
  activity_block[5] = a1;
  activity_block[6] = a2;
  _os_activity_initiate(&dword_18A900000, "SecItemBackupViewAndCopyBackupPeerID", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v2 = (const void *)v6[3];
  _Block_object_dispose(&v5, 8);
  if (v2)
    CFRelease(v2);
  return v2 != 0;
}

BOOL __string_to_string_error_request_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"cfstring", *(const __CFString **)(a1 + 32), a3);
}

BOOL __string_to_string_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  CFStringRef v4;

  v4 = SecXPCDictionaryCopyString(a2, a3);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
  return v4 != 0;
}

uint64_t SecItemBackupWithChanges(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFString *v13;
  NSObject *v14;
  const void *v15;
  FILE *v16;
  FILE *v17;
  timespec v18;
  int v19;
  NSObject *v20;
  _BOOL8 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  int v28;
  uint64_t v29;
  NSObject *v31;
  _BOOL8 v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  NSObject *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  _QWORD v48[7];
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  __darwin_ino64_t v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  char v56;
  stat activity_block;
  _BYTE buf[28];
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v53 = 0;
  v54 = &v53;
  v55 = 0x2000000000;
  v56 = 1;
  v49 = 0;
  v50 = &v49;
  v51 = 0x2000000000;
  v52 = 0;
  v48[0] = MEMORY[0x1E0C809B0];
  v48[1] = 0x40000000;
  v48[2] = __SecItemBackupWithChanges_block_invoke;
  v48[3] = &unk_1E1FD6588;
  v48[5] = &v53;
  v48[6] = &v49;
  v48[4] = a3;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2000000000;
  *(_DWORD *)&buf[24] = -1;
  *(_QWORD *)&activity_block.st_dev = MEMORY[0x1E0C809B0];
  activity_block.st_ino = 0x40000000;
  *(_QWORD *)&activity_block.st_uid = __SecItemBackupHandoffFD_block_invoke;
  *(_QWORD *)&activity_block.st_rdev = &unk_1E1FD68B0;
  activity_block.st_atimespec.tv_sec = (__darwin_time_t)buf;
  activity_block.st_atimespec.tv_nsec = a1;
  activity_block.st_mtimespec.tv_sec = (__darwin_time_t)&v52;
  _os_activity_initiate(&dword_18A900000, "SecItemBackupHandoffFD", OS_ACTIVITY_FLAG_DEFAULT, &activity_block);
  v6 = *(_DWORD *)(*(_QWORD *)&buf[8] + 24);
  _Block_object_dispose(buf, 8);
  if (v6 < 0)
  {
    v14 = secLogObjForScope("backup");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      activity_block.st_dev = 67109378;
      *(_DWORD *)&activity_block.st_mode = v6;
      LOWORD(activity_block.st_ino) = 2112;
      *(__darwin_ino64_t *)((char *)&activity_block.st_ino + 2) = v52;
      _os_log_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEFAULT, "SecItemBackupHandoffFD returned %d: %@", (uint8_t *)&activity_block, 0x12u);
    }
    goto LABEL_7;
  }
  v7 = lseek(v6, 0, 0);
  if (v7)
  {
    v13 = CFSTR("lseek");
    goto LABEL_4;
  }
  v16 = fdopen(v6, "r");
  if (!v16)
  {
    v31 = secLogObjForScope("backup");
    v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
    if (v32)
    {
      v38 = *__error();
      activity_block.st_dev = 138412546;
      *(_QWORD *)&activity_block.st_mode = a1;
      WORD2(activity_block.st_ino) = 1024;
      *(_DWORD *)((char *)&activity_block.st_ino + 6) = v38;
      _os_log_impl(&dword_18A900000, v31, OS_LOG_TYPE_DEFAULT, "Receiving file for %@ failed, %d", (uint8_t *)&activity_block, 0x12u);
    }
    SecCheckErrno(v32, (CFTypeRef *)&v52, CFSTR("fdopen"), v33, v34, v35, v36, v37, v47);
    if (!close(v6))
      goto LABEL_7;
    v39 = secLogObjForScope("backup");
    v7 = os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v7)
    {
      v40 = *__error();
      activity_block.st_dev = 138412546;
      *(_QWORD *)&activity_block.st_mode = a1;
      WORD2(activity_block.st_ino) = 1024;
      *(_DWORD *)((char *)&activity_block.st_ino + 6) = v40;
      _os_log_impl(&dword_18A900000, v39, OS_LOG_TYPE_DEFAULT, "Encountered error closing file %@: %d", (uint8_t *)&activity_block, 0x12u);
    }
    v13 = CFSTR("close");
    goto LABEL_4;
  }
  v17 = v16;
  v18.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v18.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&activity_block.st_blksize = v18;
  *(timespec *)activity_block.st_qspare = v18;
  activity_block.st_birthtimespec = v18;
  *(timespec *)&activity_block.st_size = v18;
  activity_block.st_mtimespec = v18;
  activity_block.st_ctimespec = v18;
  *(timespec *)&activity_block.st_uid = v18;
  activity_block.st_atimespec = v18;
  *(timespec *)&activity_block.st_dev = v18;
  v19 = fstat(v6, &activity_block);
  v20 = secLogObjForScope("backup");
  v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
  if (v19)
  {
    if (v21)
    {
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v6;
      _os_log_impl(&dword_18A900000, v20, OS_LOG_TYPE_DEFAULT, "Unable to get file metadata for %@, fd %d", buf, 0x12u);
    }
    SecCheckErrno(v21, (CFTypeRef *)&v52, CFSTR("fstat"), v22, v23, v24, v25, v26, v47);
    if (!fclose(v17))
      goto LABEL_7;
    v27 = secLogObjForScope("backup");
    v7 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v7)
    {
      v28 = *__error();
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = a1;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v28;
      _os_log_impl(&dword_18A900000, v27, OS_LOG_TYPE_DEFAULT, "Encountered error closing file %@: %d", buf, 0x12u);
    }
    v13 = CFSTR("fclose");
LABEL_4:
    SecCheckErrno(v7, (CFTypeRef *)&v52, v13, v8, v9, v10, v11, v12, v47);
LABEL_7:
    *((_BYTE *)v54 + 24) = 0;
LABEL_8:
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a3 + 16))(a3, 3, 0, 0);
    v15 = (const void *)v50[3];
    if (v15)
    {
      if (a2 && !*a2)
        *a2 = v15;
      else
        CFRelease(v15);
    }
    goto LABEL_21;
  }
  if (v21)
  {
    *(_DWORD *)buf = 138412802;
    *(_QWORD *)&buf[4] = a1;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v6;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = activity_block.st_size;
    _os_log_impl(&dword_18A900000, v20, OS_LOG_TYPE_DEFAULT, "Receiving file for %@ with fd %d of size %llu", buf, 0x1Cu);
  }
  __SecItemBackupWithChanges_block_invoke((uint64_t)v48, v17);
  v41 = fclose(v17);
  if ((_DWORD)v41)
    SecCheckErrno(v41, (CFTypeRef *)&v52, CFSTR("fclose"), v42, v43, v44, v45, v46, v47);
  if (!*((_BYTE *)v54 + 24))
    goto LABEL_8;
LABEL_21:
  v29 = *((unsigned __int8 *)v54 + 24);
  _Block_object_dispose(&v49, 8);
  _Block_object_dispose(&v53, 8);
  return v29;
}

BOOL __string_to_fd_error_request_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"backup", *(const __CFString **)(a1 + 32), a3);
}

uint64_t __string_to_fd_error_request_block_invoke_2(uint64_t a1, xpc_object_t xdict, __CFString **a3)
{
  int v5;

  v5 = xpc_dictionary_dup_fd(xdict, "status");
  if (v5 < 0)
    SecError(-50, a3, CFSTR("missing fd for key %s"), "status");
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v5;
  return 1;
}

uint64_t SecItemBackupSetConfirmedManifest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD activity_block[9];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = -86;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecItemBackupSetConfirmedManifest_block_invoke;
  activity_block[3] = &unk_1E1FD65B0;
  activity_block[4] = &v7;
  activity_block[5] = a1;
  activity_block[6] = a2;
  activity_block[7] = a3;
  activity_block[8] = a4;
  _os_activity_initiate(&dword_18A900000, "SecItemBackupSetConfirmedManifest", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void SecItemBackupRestore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  const void *v7;
  _QWORD v8[10];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __SecItemBackupRestore_block_invoke;
  v8[3] = &unk_1E1FD65D8;
  v8[6] = a2;
  v8[7] = a3;
  v8[8] = a4;
  v8[9] = a5;
  v8[4] = &v9;
  v8[5] = a1;
  _os_activity_initiate(&dword_18A900000, "SecItemBackupRestore", OS_ACTIVITY_FLAG_DEFAULT, v8);
  (*(void (**)(uint64_t, uint64_t))(a6 + 16))(a6, v10[3]);
  v7 = (const void *)v10[3];
  if (v7)
    CFRelease(v7);
  _Block_object_dispose(&v9, 8);
}

uint64_t SecBackupKeybagAdd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD activity_block[9];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecBackupKeybagAdd_block_invoke;
  activity_block[3] = &unk_1E1FD6648;
  activity_block[4] = &v7;
  activity_block[5] = a4;
  activity_block[6] = a1;
  activity_block[7] = a2;
  activity_block[8] = a3;
  _os_activity_initiate(&dword_18A900000, "_SecServerBackupKeybagAdd", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t SecBackupKeybagDelete(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD activity_block[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecBackupKeybagDelete_block_invoke;
  activity_block[3] = &unk_1E1FD66B8;
  activity_block[5] = a2;
  activity_block[6] = a1;
  activity_block[4] = &v5;
  _os_activity_initiate(&dword_18A900000, "_SecBackupKeybagDelete", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

__CFData *SecKeyCopyPublicKeyHash(const void *a1)
{
  int v2;
  __CFData *v3;
  CFDataRef v4;
  const __CFAllocator *v5;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFDataRef theData;

  theData = 0;
  v2 = SecKeyCopyPublicBytes((uint64_t)a1, (uint64_t)&theData);
  v3 = 0;
  v4 = theData;
  if (!v2 && theData)
  {
    v5 = CFGetAllocator(a1);
    BytePtr = CFDataGetBytePtr(theData);
    Length = CFDataGetLength(theData);
    v3 = SecSHA1DigestCreate(v5, (uint64_t)BytePtr, Length);
    v4 = theData;
  }
  if (v4)
  {
    theData = 0;
    CFRelease(v4);
  }
  return v3;
}

uint64_t _SecKeyCheck(uint64_t result, uint64_t a2)
{
  NSObject *v3;
  uint8_t buf[4];
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (!result)
  {
    _SECKEY_LOG_9290();
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136446210;
      v5 = a2;
      _os_log_fault_impl(&dword_18A900000, v3, OS_LOG_TYPE_FAULT, "%{public}s called with NULL SecKeyRef", buf, 0xCu);
    }

    return objc_msgSend(MEMORY[0x1E0C99DA0], "raise:format:", *MEMORY[0x1E0C99778], CFSTR("%s called with NULL SecKeyRef"), a2);
  }
  return result;
}

id _SECKEY_LOG_9290()
{
  if (_SECKEY_LOG_once_9294 != -1)
    dispatch_once(&_SECKEY_LOG_once_9294, &__block_literal_global_9295);
  return (id)_SECKEY_LOG_log_9296;
}

CFDictionaryRef SecKeyGeneratePublicAttributeDictionary(const void *a1, uint64_t a2)
{
  return SecKeyCopyAttributeDictionaryWithLocalKey(a1, a2, 0);
}

uint64_t SecKeyEqual(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t (*v5)(void);
  size_t v6;
  CFDictionaryRef v7;
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  uint64_t v10;

  if (a1 == a2)
    return 1;
  if (!a2)
    return 0;
  v3 = *(_QWORD *)(a1 + 16);
  if (v3 != *(_QWORD *)(a2 + 16))
    return 0;
  if (*(_DWORD *)v3 >= 4u)
  {
    v5 = *(uint64_t (**)(void))(v3 + 160);
    if (v5)
      return v5();
  }
  v6 = *(unsigned int *)(v3 + 16);
  if ((_DWORD)v6)
    return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v6) == 0;
  v7 = SecKeyCopyAttributes((SecKeyRef)a1);
  v8 = SecKeyCopyAttributes((SecKeyRef)a2);
  v9 = v8;
  if (!v7 || !v8)
  {
    if (v7)
      CFRelease(v7);
    if (v9)
      CFRelease(v9);
    return 0;
  }
  v10 = CFEqual(v7, v8);
  CFRelease(v7);
  CFRelease(v9);
  return v10;
}

CFStringRef SecKeyCopyDescription(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 96);
  if (v1)
    return (CFStringRef)v1();
  else
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<SecKeyRef: %p>"), a1);
}

OSStatus SecKeyGeneratePair(CFDictionaryRef parameters, SecKeyRef *publicKey, SecKeyRef *privateKey)
{
  SecKeyRef v5;
  __SecKey *v6;
  OSStatus Code;
  CFErrorRef error;

  error = 0;
  v5 = SecKeyCreateRandomKey(parameters, &error);
  v6 = v5;
  if (v5)
  {
    if (privateKey)
      *privateKey = v5;
    Code = 0;
    if (publicKey)
      *publicKey = SecKeyCopyPublicKey(v6);
  }
  else
  {
    Code = CFErrorGetCode(error);
    if (error)
      CFRelease(error);
  }

  return Code;
}

SecKeyRef SecKeyCreateRandomKey(CFDictionaryRef parameters, CFErrorRef *error)
{
  NSObject *v4;
  __CFDictionary *v5;
  const __CFDictionary *v6;
  const void *Value;
  void *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  id v12;
  void *v13;
  SecCTKKey *v14;
  SecCTKKey *v15;
  id v16;
  void *v17;
  __SecKey *v18;
  int v19;
  int v20;
  NSObject *v21;
  int OSStatus;
  void *v23;
  _BOOL8 v24;
  __SecKey *v25;
  uint64_t v27;
  __SecKey *v28;
  __SecKey *v29;
  _QWORD *v30;
  uint64_t v31;
  const void *v32;
  uint64_t v33;
  SecKeyRef v34;
  void *context;
  void *contexta;
  void *contextb;
  CFTypeRef cf;
  SecKeyRef key;
  __CFString *v40;
  os_activity_scope_state_s state;
  _BYTE buf[12];
  __int16 v43;
  const void *v44;
  __int16 v45;
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  context = (void *)MEMORY[0x18D770A24]();
  v4 = _os_activity_create(&dword_18A900000, "SecKeyCreateRandomKey", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  key = 0;
  v40 = 0;
  cf = 0;
  v5 = merge_params(parameters, CFSTR("public"));
  v6 = merge_params(parameters, CFSTR("private"));
  Value = CFDictionaryGetValue(parameters, CFSTR("type"));
  if (CFDictionaryGetValue(parameters, CFSTR("tkid")))
  {
    v8 = (void *)-[__CFDictionary mutableCopy](parameters, "mutableCopy", context);
    objc_msgSend(v8, "objectForKeyedSubscript:", CFSTR("private"));
    v9 = objc_claimAutoreleasedReturnValue();
    v10 = (void *)v9;
    v11 = (void *)MEMORY[0x1E0C9AA70];
    if (v9)
      v11 = (void *)v9;
    v12 = v11;

    objc_msgSend(v8, "removeObjectForKey:", CFSTR("private"));
    objc_msgSend(v8, "removeObjectForKey:", CFSTR("public"));
    v13 = (void *)objc_msgSend(v12, "mutableCopy");
    objc_msgSend(v13, "addEntriesFromDictionary:", v8);
    v14 = [SecCTKKey alloc];
    *(_QWORD *)buf = 0;
    v15 = -[SecCTKKey initWithAttributes:error:](v14, "initWithAttributes:error:", v13, buf);
    v16 = *(id *)buf;
    v17 = v16;
    if (v15)
    {
      v18 = (__SecKey *)SecKeyCreate(*MEMORY[0x1E0C9AE00], (uint64_t)&kSecCTKKeyDescriptor, 0, 0, 0);
      *((_QWORD *)v18 + 3) = v15;
    }
    else
    {
      v18 = 0;
      v40 = (__CFString *)v16;
    }

    key = v18;
    OSStatus = SecErrorGetOSStatus((uint64_t)v40);
    SecError(OSStatus, &v40, CFSTR("Failed to generate keypair"), contexta);
    goto LABEL_15;
  }
  if (!Value)
    goto LABEL_48;
  if (CFEqual(Value, CFSTR("73")))
  {
    v19 = SecECKeyGeneratePair((uint64_t)parameters, &cf, &key);
    goto LABEL_9;
  }
  if (!CFEqual(Value, CFSTR("42")))
  {
    if (CFEqual(Value, CFSTR("105")))
    {
      v31 = 4;
LABEL_40:
      v19 = curve25519KeyGeneratePair((uint64_t)parameters, &cf, &key, v31);
      goto LABEL_9;
    }
    if (CFEqual(Value, CFSTR("106")))
    {
      v31 = 5;
      goto LABEL_40;
    }
    if (CFEqual(Value, CFSTR("107")))
    {
      v33 = 6;
LABEL_45:
      v19 = curve448KeyGeneratePair((uint64_t)parameters, &cf, &key, v33);
      goto LABEL_9;
    }
    if (CFEqual(Value, CFSTR("108")))
    {
      v33 = 7;
      goto LABEL_45;
    }
    if (CFEqual(Value, CFSTR("109")))
    {
      v19 = SecKyberKeyGeneratePair(parameters, &cf, &key);
LABEL_9:
      v20 = v19;
      if (!v19)
        goto LABEL_16;
      goto LABEL_10;
    }
LABEL_48:
    SecError(-50, (__CFString **)error, CFSTR("incorrect or missing kSecAttrKeyType in key generation request"), context);
LABEL_15:
    v20 = 0;
    goto LABEL_16;
  }
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v27 = SecCFAllocatorZeroize_sAllocator;
  v28 = (__SecKey *)SecKeyCreate(SecCFAllocatorZeroize_sAllocator, (uint64_t)&kSecRSAPrivateKeyDescriptor, (uint64_t)parameters, 0, 5);
  if (v28)
  {
    v29 = v28;
    v30 = SecKeyCreate(v27, (uint64_t)&kSecRSAPublicKeyDescriptor, *((_QWORD *)v28 + 3), 0, 6);
    if (v30)
    {
      v20 = 0;
      cf = v30;
      key = v29;
      goto LABEL_17;
    }
    CFRelease(v29);
  }
  v20 = -50;
LABEL_10:
  _SECKEY_LOG_9290();
  v21 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    v32 = CFDictionaryGetValue(parameters, CFSTR("bsiz"));
    *(_DWORD *)buf = 138543874;
    *(_QWORD *)&buf[4] = Value;
    v43 = 2114;
    v44 = v32;
    v45 = 1024;
    v46 = v20;
    _os_log_error_impl(&dword_18A900000, v21, OS_LOG_TYPE_ERROR, "Failed to generate software key %{public}@:%{public}@, error: %d", buf, 0x1Cu);
  }

LABEL_16:
  if (!key)
    goto LABEL_23;
LABEL_17:
  if (getBoolForKey(v5, 0))
  {
    CFDictionaryRemoveValue(v5, CFSTR("tkid"));
    v23 = (void *)cf;
    if (!cf)
    {
      v23 = SecKeyCopyPublicKey(key);
      cf = v23;
    }
    if (!add_key(v23, v5, &v40))
    {
      v34 = key;
      if (!key)
        goto LABEL_23;
      goto LABEL_50;
    }
  }
  v24 = CFDictionaryContainsKey(v6, CFSTR("tkid")) != 0;
  if (getBoolForKey(v6, v24) && !add_key(key, v6, &v40))
  {
    v34 = key;
    if (key)
    {
LABEL_50:
      key = 0;
      CFRelease(v34);
    }
  }
LABEL_23:
  SecError(v20, &v40, CFSTR("failed to generate key"), context);
  _SecKeyErrorPropagate(key != 0, (uint64_t)"SecKeyCreateRandomKey", v40, error);
  if (v5)
    CFRelease(v5);
  if (v6)
    CFRelease(v6);
  if (cf)
    CFRelease(cf);
  v25 = key;
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(contextb);
  return v25;
}

void sub_18A9EE220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

SecKeyRef SecKeyCopyPublicKey(SecKeyRef key)
{
  void *v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t (*v5)(SecKeyRef);
  __SecKey *v6;
  int v7;
  CFTypeRef v8;
  uint64_t v9;
  uint64_t AlgorithmId;
  CFTypeRef cf;
  os_activity_scope_state_s state;

  v2 = (void *)MEMORY[0x18D770A24]();
  v3 = _os_activity_create(&dword_18A900000, "SecKeyCopyPublicKey", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyCopyPublicKey");
  v4 = *((_QWORD *)key + 2);
  if (*(_DWORD *)v4 < 4u
    || (v5 = *(uint64_t (**)(SecKeyRef))(v4 + 144)) == 0
    || (v6 = (__SecKey *)v5(key)) == 0)
  {
    cf = 0;
    v7 = SecKeyCopyPublicBytes((uint64_t)key, (uint64_t)&cf);
    v6 = 0;
    v8 = cf;
    if (!v7 && cf)
    {
      if (SecCFAllocatorZeroize_sOnce != -1)
        dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
      v9 = SecCFAllocatorZeroize_sAllocator;
      AlgorithmId = SecKeyGetAlgorithmId((uint64_t)key);
      v6 = (__SecKey *)SecKeyCreateFromPublicData(v9, AlgorithmId, (CFDataRef)cf);
      v8 = cf;
    }
    if (v8)
      CFRelease(v8);
  }
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v2);
  return v6;
}

void sub_18A9EE398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

_QWORD *SecKeyCreateFromPublicData(uint64_t a1, uint64_t a2, CFDataRef theData)
{
  const UInt8 *BytePtr;
  CFIndex Length;

  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  return SecKeyCreateFromPublicBytes(a1, a2, (uint64_t)BytePtr, Length);
}

_QWORD *SecKeyCreateFromPublicBytes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v4;
  _QWORD *result;
  uint64_t v6;

  switch(a2)
  {
    case 1:
      v4 = &kSecRSAPublicKeyDescriptor;
      goto LABEL_11;
    case 3:
      v4 = &kSecECPublicKeyDescriptor;
      goto LABEL_11;
    case 4:
      v4 = &kSecEd25519PublicKeyDescriptor;
      goto LABEL_11;
    case 5:
      v4 = &kSecX25519PublicKeyDescriptor;
      goto LABEL_11;
    case 6:
      v4 = &kSecEd448PublicKeyDescriptor;
      goto LABEL_11;
    case 7:
      v4 = &kSecX448PublicKeyDescriptor;
LABEL_11:
      v6 = 7;
      goto LABEL_9;
    case 8:
      v4 = &kSecKyberPublicKeyDescriptor;
      v6 = 0;
LABEL_9:
      result = SecKeyCreate(a1, (uint64_t)v4, a3, a4, v6);
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

CFMutableDictionaryRef merge_params(const __CFDictionary *a1, const void *a2)
{
  const __CFDictionary *Value;
  CFMutableDictionaryRef MutableCopy;

  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, Value);
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)merge_params_applier, MutableCopy);
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a1);
  }
  CFDictionaryRemoveValue(MutableCopy, CFSTR("public"));
  CFDictionaryRemoveValue(MutableCopy, CFSTR("private"));
  CFDictionaryRemoveValue(MutableCopy, CFSTR("type"));
  CFDictionaryRemoveValue(MutableCopy, CFSTR("bsiz"));
  return MutableCopy;
}

BOOL getBoolForKey(const __CFDictionary *a1, uint64_t a2)
{
  const __CFBoolean *Value;
  const __CFBoolean *v4;
  CFTypeID v5;
  NSObject *v6;
  int v8;
  const __CFBoolean *v9;
  __int16 v10;
  const __CFString *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  Value = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("perm"));
  if (Value)
  {
    v4 = Value;
    v5 = CFGetTypeID(Value);
    if (v5 == CFBooleanGetTypeID())
    {
      return CFBooleanGetValue(v4) != 0;
    }
    else
    {
      _SECKEY_LOG_9290();
      v6 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        v8 = 138543618;
        v9 = v4;
        v10 = 2114;
        v11 = CFSTR("perm");
        _os_log_error_impl(&dword_18A900000, v6, OS_LOG_TYPE_ERROR, "Value %{public}@ for key %{public}@ is not BOOL", (uint8_t *)&v8, 0x16u);
      }

    }
  }
  return a2;
}

BOOL add_key(void *value, CFMutableDictionaryRef theDict, __CFString **a3)
{
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  OSStatus v8;

  CFDictionarySetValue(theDict, CFSTR("v_Ref"), value);
  v6 = SecKeyCopyAttributes((SecKeyRef)value);
  if (v6)
  {
    v7 = v6;
    if (CFDictionaryContainsKey(v6, CFSTR("accc")))
      CFDictionaryRemoveValue(theDict, CFSTR("accc"));
    CFRelease(v7);
  }
  CFDictionaryRemoveValue(theDict, CFSTR("applepay"));
  CFDictionaryRemoveValue(theDict, CFSTR("osbound"));
  CFDictionaryRemoveValue(theDict, CFSTR("sealedhashesbound"));
  v8 = SecItemAdd(theDict, 0);
  return SecError(v8, a3, CFSTR("failed to add key to keychain: %@"), value);
}

uint64_t _SecKeyErrorPropagate(uint64_t a1, uint64_t a2, const void *a3, _QWORD *a4)
{
  NSObject *v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  const void *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if ((a1 & 1) == 0)
  {
    _SECKEY_LOG_9290();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v10 = 136446466;
      v11 = a2;
      v12 = 2114;
      v13 = a3;
      _os_log_error_impl(&dword_18A900000, v8, OS_LOG_TYPE_ERROR, "%{public}s failed: %{public}@", (uint8_t *)&v10, 0x16u);
    }

    if (a4)
      *a4 = a3;
    else
      CFRelease(a3);
  }
  return a1;
}

void merge_params_applier(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionaryAddValue(theDict, key, value);
}

CFDictionaryRef CreatePrivateKeyMatchingQuery(const void *a1)
{
  __CFData *v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  CFDictionaryRef v9;

  v1 = SecKeyCopyPublicKeyHash(a1);
  v9 = CFDictionaryCreateForCFTypes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v2, v3, v4, v5, v6, v7, v8, (uint64_t)CFSTR("class"), (uint64_t)CFSTR("keys"));
  if (v1)
    CFRelease(v1);
  return v9;
}

CFTypeRef SecKeyCreatePersistentRefToMatchingPrivateKey(const void *a1, __CFString **a2)
{
  const __CFDictionary *PrivateKeyMatchingQuery;
  OSStatus v5;
  CFTypeRef result;

  result = 0;
  PrivateKeyMatchingQuery = CreatePrivateKeyMatchingQuery(a1);
  v5 = SecItemCopyMatching(PrivateKeyMatchingQuery, &result);
  SecError(v5, a2, CFSTR("Error finding persistent ref to key from public: %@"), a1);
  if (PrivateKeyMatchingQuery)
    CFRelease(PrivateKeyMatchingQuery);
  return result;
}

CFTypeRef SecKeyCopyMatchingPrivateKey(const void *a1, __CFString **a2)
{
  const __CFDictionary *PrivateKeyMatchingQuery;
  OSStatus v5;
  CFTypeID v6;
  CFTypeRef v7;
  CFTypeRef v8;
  CFTypeRef result;

  result = 0;
  if (!a1)
  {
    SecError(-50, a2, CFSTR("Null Public Key"));
    return 0;
  }
  PrivateKeyMatchingQuery = CreatePrivateKeyMatchingQuery(a1);
  v5 = SecItemCopyMatching(PrivateKeyMatchingQuery, &result);
  if (!SecError(v5, a2, CFSTR("Error finding private key from public: %@"), a1)
    || (v6 = CFGetTypeID(result), v6 != SecKeyGetTypeID()))
  {
    v7 = 0;
    if (!PrivateKeyMatchingQuery)
      goto LABEL_8;
    goto LABEL_7;
  }
  v7 = result;
  result = 0;
  if (PrivateKeyMatchingQuery)
LABEL_7:
    CFRelease(PrivateKeyMatchingQuery);
LABEL_8:
  v8 = result;
  if (result)
  {
    result = 0;
    CFRelease(v8);
  }
  return v7;
}

uint64_t SecKeyGetMatchingPrivateKeyStatus(const void *a1, __CFString **a2)
{
  const __CFDictionary *PrivateKeyMatchingQuery;
  uint64_t v3;
  CFTypeID v4;
  CFTypeRef v5;
  CFTypeRef result;

  result = 0;
  if (a1)
  {
    PrivateKeyMatchingQuery = CreatePrivateKeyMatchingQuery(a1);
    v3 = SecItemCopyMatching(PrivateKeyMatchingQuery, &result);
    if (!(_DWORD)v3)
    {
      v4 = CFGetTypeID(result);
      if (v4 == SecKeyGetTypeID())
        v3 = 0;
      else
        v3 = 4294965226;
    }
    if (PrivateKeyMatchingQuery)
      CFRelease(PrivateKeyMatchingQuery);
    v5 = result;
    if (result)
    {
      result = 0;
      CFRelease(v5);
    }
  }
  else
  {
    v3 = 4294967246;
    SecError(-50, a2, 0, CFSTR("Null Public Key"));
  }
  return v3;
}

_QWORD *SecKeyCreatePublicFromDER(uint64_t a1, SecAsn1Oid *oid1, uint64_t *a3, uint64_t *a4)
{
  size_t Length;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (SecAsn1OidCompare(oid1, &CSSMOID_RSA))
    return SecKeyCreate(a1, (uint64_t)&kSecRSAPublicKeyDescriptor, a4[1], *a4, 1);
  if (SecAsn1OidCompare(oid1, &CSSMOID_ecPublicKey))
  {
    Length = oid1->Length;
    v13[0] = oid1->Data;
    v13[1] = Length;
    v14 = 0;
    v15 = 0;
    v10 = *a4;
    v16 = a4[1];
    v17 = v10;
    if (a3)
    {
      v11 = *a3;
      v14 = a3[1];
      v15 = v11;
    }
    return SecKeyCreate(a1, (uint64_t)&kSecECPublicKeyDescriptor, (uint64_t)v13, 48, 4);
  }
  else
  {
    _SECKEY_LOG_9290();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(v13[0]) = 0;
      _os_log_debug_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEBUG, "Unsupported algorithm oid", (uint8_t *)v13, 2u);
    }

    return 0;
  }
}

OSStatus SecKeyRawSign(SecKeyRef key, SecPadding padding, const uint8_t *dataToSign, size_t dataToSignLen, uint8_t *sig, size_t *sigLen)
{
  const __CFString *SignatureAlgorithmForPadding;
  _QWORD v13[6];

  SignatureAlgorithmForPadding = SecKeyGetSignatureAlgorithmForPadding((uint64_t)key, padding, dataToSignLen);
  if (!SignatureAlgorithmForPadding)
    return -50;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __SecKeyRawSign_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  v13[4] = key;
  v13[5] = SignatureAlgorithmForPadding;
  return SecKeyPerformLegacyOperation(dataToSign, dataToSignLen, 0, 0, sig, (CFIndex *)sigLen, v13);
}

const __CFString *SecKeyGetSignatureAlgorithmForPadding(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t AlgorithmId;
  const __CFString *result;
  const __CFString *v7;

  AlgorithmId = SecKeyGetAlgorithmId(a1);
  if (AlgorithmId == 3)
  {
    if (a2 == 0x4000)
      return CFSTR("algid:sign:ECDSA:digest-RFC4754");
    if (a2 != 1)
      return CFSTR("algid:sign:ECDSA:digest-X962");
    if (*(_QWORD *)ccsha1_di() == a3)
      return CFSTR("algid:sign:ECDSA:digest-X962:SHA1");
    if (*(_QWORD *)ccsha224_di() == a3)
      return CFSTR("algid:sign:ECDSA:digest-X962:SHA224");
    if (*(_QWORD *)ccsha256_di() == a3)
      return CFSTR("algid:sign:ECDSA:digest-X962:SHA256");
    if (*(_QWORD *)ccsha384_di() == a3)
      return CFSTR("algid:sign:ECDSA:digest-X962:SHA384");
    if (*(_QWORD *)ccsha512_di() == a3)
      return CFSTR("algid:sign:ECDSA:digest-X962:SHA512");
    else
      return CFSTR("algid:sign:ECDSA:digest-X962");
  }
  else if (AlgorithmId == 1)
  {
    switch(a2)
    {
      case 32770:
        result = CFSTR("algid:sign:RSA:digest-PKCS1v15:SHA1");
        break;
      case 32771:
        result = CFSTR("algid:sign:RSA:digest-PKCS1v15:SHA224");
        break;
      case 32772:
        result = CFSTR("algid:sign:RSA:digest-PKCS1v15:SHA256");
        break;
      case 32773:
        result = CFSTR("algid:sign:RSA:digest-PKCS1v15:SHA384");
        break;
      case 32774:
        result = CFSTR("algid:sign:RSA:digest-PKCS1v15:SHA512");
        break;
      default:
        v7 = CFSTR("algid:sign:RSA:raw");
        if (a2)
          v7 = 0;
        if (a2 == 1)
          result = CFSTR("algid:sign:RSA:digest-PKCS1v15");
        else
          result = v7;
        break;
    }
  }
  else
  {
    return 0;
  }
  return result;
}

OSStatus SecKeyRawVerify(SecKeyRef key, SecPadding padding, const uint8_t *signedData, size_t signedDataLen, const uint8_t *sig, size_t sigLen)
{
  const __CFString *SignatureAlgorithmForPadding;
  _QWORD v13[6];

  SignatureAlgorithmForPadding = SecKeyGetSignatureAlgorithmForPadding((uint64_t)key, padding, signedDataLen);
  if (!SignatureAlgorithmForPadding)
    return -50;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __SecKeyRawVerify_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  v13[4] = key;
  v13[5] = SignatureAlgorithmForPadding;
  return SecKeyPerformLegacyOperation(signedData, signedDataLen, sig, sigLen, 0, 0, v13);
}

CFDataRef SecKeyCreateEncryptedData(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef plaintext, CFErrorRef *error)
{
  return SecKeyCreateEncryptedDataWithParameters((uint64_t)key, algorithm, plaintext, 0, error);
}

OSStatus SecKeyDecrypt(SecKeyRef key, SecPadding padding, const uint8_t *cipherText, size_t cipherTextLen, uint8_t *plainText, size_t *plainTextLen)
{
  uint64_t AlgorithmId;
  OSStatus result;
  uint64_t v14;
  _QWORD v15[6];

  AlgorithmId = SecKeyGetAlgorithmId((uint64_t)key);
  result = -50;
  if (AlgorithmId == 1 && padding <= 2)
  {
    v14 = (uint64_t)*(&off_1E1FDD0D0 + (int)padding);
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 3221225472;
    v15[2] = __SecKeyDecrypt_block_invoke;
    v15[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
    v15[4] = key;
    v15[5] = v14;
    return SecKeyPerformLegacyOperation(cipherText, cipherTextLen, 0, 0, plainText, (CFIndex *)plainTextLen, v15);
  }
  return result;
}

__CFData *SecKeyCreateDecryptedDataWithParameters(uint64_t a1, const void *a2, const __CFData *a3, const __CFData *a4, _QWORD *a5)
{
  void *v10;
  NSObject *v11;
  __CFArray *Mutable;
  __CFData *v13;
  CFTypeRef v14;
  uint64_t v16[2];
  CFTypeRef cf;
  uint64_t v18;
  __CFString *v19;
  os_activity_scope_state_s state;

  v10 = (void *)MEMORY[0x18D770A24]();
  v11 = _os_activity_create(&dword_18A900000, "SecKeyCreateDecryptedDataWithParameters", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v11, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateDecryptedDataWithParameters");
  if (!a3)
    objc_msgSend(MEMORY[0x1E0C99DA0], "raise:format:", *MEMORY[0x1E0C99778], CFSTR("SecKeyCreateDecryptedData() called with NULL ciphertext"));
  v19 = 0;
  v16[0] = a1;
  v16[1] = 3;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue(Mutable, a2);
  cf = Mutable;
  v18 = 0;
  v13 = SecKeyRunAlgorithmAndCopyResult(v16, a3, a4, &v19);
  v14 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v14);
  }
  _SecKeyErrorPropagate(v13 != 0, (uint64_t)"SecKeyCreateDecryptedDataWithParameters", v19, a5);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v10);
  return v13;
}

void sub_18A9EF18C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

CFDataRef SecKeyCreateDecryptedData(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef ciphertext, CFErrorRef *error)
{
  return SecKeyCreateDecryptedDataWithParameters((uint64_t)key, algorithm, ciphertext, 0, error);
}

uint64_t SecKeyDigestAndSign(uint64_t a1, const SecAsn1Oid *a2, const UInt8 *a3, CFIndex a4, UInt8 *a5, CFIndex *a6)
{
  const SecAsn1Oid *AlgorithmForSecAsn1AlgId;
  _QWORD v13[6];

  AlgorithmForSecAsn1AlgId = SecKeyGetAlgorithmForSecAsn1AlgId(a1, a2, 1u);
  if (!AlgorithmForSecAsn1AlgId)
    return 4294967292;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __SecKeyDigestAndSign_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  v13[4] = a1;
  v13[5] = AlgorithmForSecAsn1AlgId;
  return SecKeyPerformLegacyOperation(a3, a4, 0, 0, a5, a6, v13);
}

uint64_t SecKeySignDigest(uint64_t a1, const SecAsn1Oid *a2, const UInt8 *a3, CFIndex a4, UInt8 *a5, CFIndex *a6)
{
  const SecAsn1Oid *AlgorithmForSecAsn1AlgId;
  _QWORD v13[6];

  AlgorithmForSecAsn1AlgId = SecKeyGetAlgorithmForSecAsn1AlgId(a1, a2, 0);
  if (!AlgorithmForSecAsn1AlgId)
    return 4294967292;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v13[2] = __SecKeySignDigest_block_invoke;
  v13[3] = &__block_descriptor_48_e58__v40__0____CFData__8____CFData__16____qq_24_____CFError_32l;
  v13[4] = a1;
  v13[5] = AlgorithmForSecAsn1AlgId;
  return SecKeyPerformLegacyOperation(a3, a4, 0, 0, a5, a6, v13);
}

uint64_t SecKeyFindWithPersistentRef(uint64_t a1, CFTypeRef *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  const __CFDictionary *v9;
  uint64_t v10;
  CFTypeID v11;
  CFTypeRef result;

  v9 = CFDictionaryCreateForCFTypes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (int)a2, a3, a4, a5, a6, a7, a8, (uint64_t)CFSTR("r_Ref"), *MEMORY[0x1E0C9AE50]);
  result = 0;
  v10 = SecItemCopyMatching(v9, &result);
  if (!(_DWORD)v10)
  {
    v11 = CFGetTypeID(result);
    if (v11 == SecKeyGetTypeID())
    {
      v10 = 0;
      *a2 = result;
      result = 0;
      goto LABEL_7;
    }
    v10 = 4294941996;
  }
  if (result)
    CFRelease(result);
LABEL_7:
  if (v9)
    CFRelease(v9);
  return v10;
}

uint64_t SecKeyCopyPersistentRef(uint64_t a1, CFTypeRef *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  const __CFDictionary *v10;
  uint64_t v11;
  NSObject *v12;
  __CFString *v13;
  NSObject *v14;
  __CFString *v15;
  void *v16;
  void *v17;
  NSObject *v18;
  CFTypeID v19;
  NSObject *v20;
  CFTypeID v21;
  void *v23;
  void *v24;
  CFTypeRef result;
  _BYTE buf[24];
  void *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    secLogObjForScope("SecError");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEFAULT, "SecKeyCopyPersistentRef: Need a key reference for this to work", buf, 2u);
    }
    goto LABEL_26;
  }
  if (!a2)
  {
    secLogObjForScope("SecError");
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v18, OS_LOG_TYPE_DEFAULT, "SecKeyCopyPersistentRef: Need a persistentRef pointer for this to work", buf, 2u);
    }
LABEL_26:

    return 4294967246;
  }
  v10 = CFDictionaryCreateForCFTypes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (int)a2, a3, a4, a5, a6, a7, a8, (uint64_t)CFSTR("r_PersistentRef"), *MEMORY[0x1E0C9AE50]);
  result = 0;
  v11 = SecItemCopyMatching(v10, &result);
  if ((_DWORD)v11)
  {
    secLogObjForScope("SecError");
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = v11;
      *(_WORD *)&buf[8] = 2112;
      *(_QWORD *)&buf[10] = a1;
      _os_log_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEFAULT, "SecKeyCopyPersistentRef: received status %i for key %@", buf, 0x12u);
    }

    v13 = (__CFString *)CFStringCreateWithFormat(0, 0, CFSTR("Expected to find persistentref for key %@"), a1);
    secLogObjForScope("SecError");
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = v13;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v11;
      _os_log_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEFAULT, "stackshot report, reason: %@, code=%08x", buf, 0x12u);
    }

    if (__simulate_crash_counter == -1)
      goto LABEL_12;
    if (!CrashReporterSupportLibraryCore_frameworkLibrary)
    {
      *(_OWORD *)buf = xmmword_1E1FDC298;
      *(_QWORD *)&buf[16] = 0;
      CrashReporterSupportLibraryCore_frameworkLibrary = _sl_dlopen();
    }
    if (!CrashReporterSupportLibraryCore_frameworkLibrary)
    {
LABEL_12:
      if (!CrashReporterSupportLibraryCore_frameworkLibrary)
      {
        *(_OWORD *)buf = xmmword_1E1FDC298;
        *(_QWORD *)&buf[16] = 0;
        CrashReporterSupportLibraryCore_frameworkLibrary = _sl_dlopen();
      }
      if (CrashReporterSupportLibraryCore_frameworkLibrary)
      {
        v15 = v13;
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = buf;
        *(_QWORD *)&buf[16] = 0x2020000000;
        v16 = getWriteStackshotReportSymbolLoc_ptr;
        v27 = getWriteStackshotReportSymbolLoc_ptr;
        if (!getWriteStackshotReportSymbolLoc_ptr)
        {
          v17 = CrashReporterSupportLibrary();
          v16 = dlsym(v17, "WriteStackshotReport");
          *(_QWORD *)(*(_QWORD *)&buf[8] + 24) = v16;
          getWriteStackshotReportSymbolLoc_ptr = v16;
        }
        _Block_object_dispose(buf, 8);
        if (!v16)
        {
          objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
          v23 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "BOOL soft_WriteStackshotReport(NSString *__strong, mach_exception_data_type_t)");
          v24 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", v24, CFSTR("simulate_crash.m"), 25, CFSTR("%s"), dlerror());

          __break(1u);
        }
        ((void (*)(__CFString *, _QWORD))v16)(v15, v11);

      }
    }
    if (v13)
      CFRelease(v13);
LABEL_32:
    if (result)
      CFRelease(result);
    goto LABEL_34;
  }
  v19 = CFGetTypeID(result);
  if (v19 != CFDataGetTypeID())
  {
    secLogObjForScope("SecError");
    v20 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      v21 = CFGetTypeID(result);
      *(_DWORD *)buf = 134218242;
      *(_QWORD *)&buf[4] = v21;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = a1;
      _os_log_impl(&dword_18A900000, v20, OS_LOG_TYPE_DEFAULT, "SecKeyCopyPersistentRef: SecItemCopyMatching returned success, but we got type %lu instead of CFData for key %@.", buf, 0x16u);
    }

    v11 = 4294941996;
    goto LABEL_32;
  }
  v11 = 0;
  *a2 = result;
  result = 0;
LABEL_34:
  if (v10)
    CFRelease(v10);
  return v11;
}

void sub_18A9EF8EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t _SecKeyCopyWrapKey(uint64_t a1, int a2, int a3, int a4, _QWORD *a5, __CFString **a6)
{
  uint64_t v6;
  uint64_t (*v7)(void);

  if (a6)
    *a6 = 0;
  if (a5)
    *a5 = 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)v6 >= 3u)
  {
    v7 = *(uint64_t (**)(void))(v6 + 120);
    if (v7)
      return v7();
  }
  SecError(-4, a6, CFSTR("No key wrap supported for key %@"), a1);
  return 0;
}

uint64_t _SecKeyCopyUnwrapKey(uint64_t a1, int a2, int a3, int a4, _QWORD *a5, __CFString **a6)
{
  uint64_t v6;
  uint64_t (*v7)(void);

  if (a6)
    *a6 = 0;
  if (a5)
    *a5 = 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)v6 >= 3u)
  {
    v7 = *(uint64_t (**)(void))(v6 + 128);
    if (v7)
      return v7();
  }
  SecError(-4, a6, CFSTR("No key unwrap for key %@"), a1);
  return 0;
}

CFDataRef SecKeyCopyExternalRepresentation(SecKeyRef key, CFErrorRef *error)
{
  void *v4;
  NSObject *v5;
  uint64_t (*v6)(SecKeyRef, _BYTE *);
  const __CFData *v7;
  NSObject *v8;
  os_activity_scope_state_s state;
  _BYTE buf[12];
  __int16 v12;
  SecKeyRef v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v4 = (void *)MEMORY[0x18D770A24]();
  v5 = _os_activity_create(&dword_18A900000, "SecKeyCopyExternalRepresentation", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v5, &state);
  _SecKeyCheck((uint64_t)key, (uint64_t)"SecKeyCopyExternalRepresentation");
  v6 = *(uint64_t (**)(SecKeyRef, _BYTE *))(*((_QWORD *)key + 2) + 136);
  if (v6)
  {
    *(_QWORD *)buf = 0;
    v7 = (const __CFData *)v6(key, buf);
    _SecKeyErrorPropagate(v7 != 0, (uint64_t)"SecKeyCopyExternalRepresentation", *(const void **)buf, error);
  }
  else
  {
    if (error)
      *error = 0;
    SecError(-4, (__CFString **)error, CFSTR("export not implemented for key %@"), key);
    _SECKEY_LOG_9290();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "SecKeyCopyExternalRepresentation";
      v12 = 2114;
      v13 = key;
      _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%{public}s failed, export not implemented for key %{public}@", buf, 0x16u);
    }

    v7 = 0;
  }
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v4);
  return v7;
}

void sub_18A9EFB6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

CFTypeRef SecKeyCreateDuplicate(_QWORD *a1)
{
  void *v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t (*v5)(_QWORD *);
  CFTypeRef v6;
  CFTypeRef v7;
  os_activity_scope_state_s v9;

  v2 = (void *)MEMORY[0x18D770A24]();
  v3 = _os_activity_create(&dword_18A900000, "SecKeyCreateDuplicate", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v9.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v9.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v3, &v9);
  _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyCreateDuplicate");
  v4 = a1[2];
  if (*(_DWORD *)v4 >= 4u && (v5 = *(uint64_t (**)(_QWORD *))(v4 + 168)) != 0)
    v6 = (CFTypeRef)v5(a1);
  else
    v6 = CFRetain(a1);
  v7 = v6;
  os_activity_scope_leave(&v9);

  objc_autoreleasePoolPop(v2);
  return v7;
}

void sub_18A9EFC4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

BOOL SecKeySetParameter(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  void *v8;
  NSObject *v9;
  uint64_t v10;
  unsigned int (*v11)(uint64_t, uint64_t, uint64_t, const void **);
  _BOOL8 v12;
  const void *v14;
  os_activity_scope_state_s state;

  v8 = (void *)MEMORY[0x18D770A24]();
  v9 = _os_activity_create(&dword_18A900000, "SecKeySetParameter", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeySetParameter");
  v10 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)v10 >= 4u
    && (v11 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, const void **))(v10 + 176)) != 0)
  {
    v14 = 0;
    v12 = v11(a1, a2, a3, &v14) != 0;
    _SecKeyErrorPropagate(v12, (uint64_t)"SecKeySetParameter", v14, a4);
  }
  else
  {
    if (a4)
      *a4 = 0;
    v12 = SecError(-4, a4, CFSTR("setParameter not implemented for %@"), a1);
  }
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v8);
  return v12;
}

void sub_18A9EFD7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

CFDataRef SecKeyCopyKeyExchangeResult(SecKeyRef privateKey, SecKeyAlgorithm algorithm, SecKeyRef publicKey, CFDictionaryRef parameters, CFErrorRef *error)
{
  void *v10;
  NSObject *v11;
  __CFArray *Mutable;
  const __CFData *v13;
  __CFData *v14;
  uint64_t v16[2];
  CFTypeRef cf;
  uint64_t v18;
  __CFString *v19;
  os_activity_scope_state_s state;

  v10 = (void *)MEMORY[0x18D770A24]();
  v11 = _os_activity_create(&dword_18A900000, "SecKeyCopyKeyExchangeResult", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v11, &state);
  _SecKeyCheck((uint64_t)privateKey, (uint64_t)"SecKeyCopyKeyExchangeResult");
  if (!publicKey)
    objc_msgSend(MEMORY[0x1E0C99DA0], "raise:format:", *MEMORY[0x1E0C99778], CFSTR("SecKeyCopyKeyExchangeResult() called with NULL publicKey"));
  v19 = 0;
  v16[0] = (uint64_t)privateKey;
  v16[1] = 4;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue(Mutable, algorithm);
  cf = Mutable;
  v18 = 0;
  v13 = SecKeyCopyExternalRepresentation(publicKey, error);
  if (!v13)
  {
    v14 = 0;
    if (!Mutable)
      goto LABEL_6;
    goto LABEL_5;
  }
  v14 = SecKeyRunAlgorithmAndCopyResult(v16, v13, parameters, &v19);
  _SecKeyErrorPropagate(v14 != 0, (uint64_t)"SecKeyCopyKeyExchangeResult", v19, error);
  CFRelease(v13);
  Mutable = (__CFArray *)cf;
  if (cf)
  {
LABEL_5:
    cf = 0;
    CFRelease(Mutable);
  }
LABEL_6:
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v10);
  return v14;
}

void sub_18A9EFF10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t SecKeyCreateEncapsulatedKey(uint64_t a1, const void *a2, uint64_t *a3, _QWORD *a4)
{
  void *v8;
  NSObject *v9;
  __CFArray *Mutable;
  __CFData *v11;
  CFTypeRef v12;
  uint64_t v13;
  uint64_t v15[2];
  CFTypeRef cf;
  uint64_t v17;
  __CFString *v18;
  os_activity_scope_state_s state;

  v8 = (void *)MEMORY[0x18D770A24]();
  v9 = _os_activity_create(&dword_18A900000, "SecKeyCreateEncapsulatedKey", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateEncapsulatedKey");
  if (!a3)
    objc_msgSend(MEMORY[0x1E0C99DA0], "raise:format:", *MEMORY[0x1E0C99778], CFSTR("SecKeyCreateEncapsulatedKey() requires encapsulatedKey output parameter"));
  v18 = 0;
  v15[0] = a1;
  v15[1] = 5;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue(Mutable, a2);
  cf = Mutable;
  v17 = 0;
  v11 = SecKeyRunAlgorithmAndCopyResult(v15, 0, 0, &v18);
  v12 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v12);
  }
  _SecKeyErrorPropagate(v11 != 0, (uint64_t)"SecKeyCreateEncapsulatedKey", v18, a4);
  if (v11)
  {
    -[__CFData objectAtIndexedSubscript:](v11, "objectAtIndexedSubscript:", 0);
    *a3 = objc_claimAutoreleasedReturnValue();
    -[__CFData objectAtIndexedSubscript:](v11, "objectAtIndexedSubscript:", 1);
    v13 = objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v13 = 0;
  }

  os_activity_scope_leave(&state);
  objc_autoreleasePoolPop(v8);
  return v13;
}

void sub_18A9F00A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

__CFData *SecKeyCreateDecapsulatedKey(uint64_t a1, const void *a2, const __CFData *a3, _QWORD *a4)
{
  void *v8;
  NSObject *v9;
  __CFArray *Mutable;
  __CFData *v11;
  CFTypeRef v12;
  uint64_t v14[2];
  CFTypeRef cf;
  uint64_t v16;
  __CFString *v17;
  os_activity_scope_state_s state;

  v8 = (void *)MEMORY[0x18D770A24]();
  v9 = _os_activity_create(&dword_18A900000, "SecKeyCreateDecapsulatedKey", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v9, &state);
  _SecKeyCheck(a1, (uint64_t)"SecKeyCreateDecapsulatedKey");
  if (!a3)
    objc_msgSend(MEMORY[0x1E0C99DA0], "raise:format:", *MEMORY[0x1E0C99778], CFSTR("SecKeyCreateDecapsulatedKey() requires encapsulatedKey input parameter"));
  v17 = 0;
  v14[0] = a1;
  v14[1] = 6;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue(Mutable, a2);
  cf = Mutable;
  v16 = 0;
  v11 = SecKeyRunAlgorithmAndCopyResult(v14, a3, 0, &v17);
  v12 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v12);
  }
  _SecKeyErrorPropagate(v11 != 0, (uint64_t)"SecKeyCreateDecapsulatedKey", v17, a4);
  os_activity_scope_leave(&state);

  objc_autoreleasePoolPop(v8);
  return v11;
}

void sub_18A9F0208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA1(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:keyexchange:ECDH"));
  v8 = ccsha1_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA224(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:keyexchange:ECDH"));
  v8 = ccsha224_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA256(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:keyexchange:ECDH"));
  v8 = ccsha256_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA384(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:keyexchange:ECDH"));
  v8 = ccsha384_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHStandardX963SHA512(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:keyexchange:ECDH"));
  v8 = ccsha512_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA1(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:keyexchange:ECDHC"));
  v8 = ccsha1_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA224(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:keyexchange:ECDHC"));
  v8 = ccsha224_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA256(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:keyexchange:ECDHC"));
  v8 = ccsha256_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA384(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:keyexchange:ECDHC"));
  v8 = ccsha384_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_KeyExchange_ECDHCofactorX963SHA512(uint64_t a1, const __CFData *a2, const __CFDictionary *a3, __CFString **a4)
{
  uint64_t v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:keyexchange:ECDHC"));
  v8 = ccsha512_di();
  return SecKeyECDHCopyX963Result((uint64_t *)a1, v8, a2, a3, a4);
}

__CFData *SecKeyECDHCopyX963Result(uint64_t *a1, uint64_t a2, const __CFData *a3, const __CFDictionary *a4, __CFString **a5)
{
  __CFData *v8;
  const __CFData *v9;
  __CFData *Mutable;
  const __CFNumber *Value;
  const __CFNumber *v12;
  CFTypeID v13;
  const __CFData *v14;
  const __CFData *v15;
  CFTypeID v16;
  CFIndex v17;
  uint64_t v18;
  uint64_t v20;
  CFIndex valuePtr;

  v8 = SecKeyRunAlgorithmAndCopyResult(a1, a3, 0, a5);
  if (!v8)
    return 0;
  v9 = v8;
  if (!a1[3])
  {
    valuePtr = 0;
    Value = (const __CFNumber *)CFDictionaryGetValue(a4, CFSTR("requestedSize"));
    if (Value
      && (v12 = Value, v13 = CFGetTypeID(Value), v13 == CFNumberGetTypeID())
      && CFNumberGetValue(v12, kCFNumberCFIndexType, &valuePtr))
    {
      v14 = (const __CFData *)CFDictionaryGetValue(a4, CFSTR("sharedInfo"));
      if (!v14)
      {
LABEL_10:
        if (SecCFAllocatorZeroize_sOnce != -1)
          dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
        v17 = valuePtr;
        Mutable = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
        CFDataSetLength(Mutable, v17);
        CFDataGetLength(v9);
        CFDataGetBytePtr(v9);
        CFDataGetMutableBytePtr(Mutable);
        v18 = ccansikdf_x963();
        if (!(_DWORD)v18)
          goto LABEL_13;
        v20 = v18;
        if (Mutable)
          CFRelease(Mutable);
        SecError(-50, a5, CFSTR("ECDHKeyExchange wrong input (%d)"), v20);
        goto LABEL_21;
      }
      v15 = v14;
      v16 = CFGetTypeID(v14);
      if (v16 == CFDataGetTypeID())
      {
        CFDataGetBytePtr(v15);
        CFDataGetLength(v15);
        goto LABEL_10;
      }
      SecError(-50, a5, CFSTR("ECDHKeyExchange wrong sharedInfo type (must be CFData/NSData)"));
    }
    else
    {
      SecError(-50, a5, CFSTR("kSecKeyKeyExchangeParameterRequestedSize is missing"));
    }
LABEL_21:
    Mutable = 0;
    goto LABEL_13;
  }
  CFRetain(v8);
  Mutable = v9;
LABEL_13:
  CFRelease(v9);
  return Mutable;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_EncryptDecrypt_RSAEncryptionRawCCUnit(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:encrypt:RSA:raw"));
  return SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionPKCS1(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSACopyDecryptedWithPadding(a1, 0, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA1(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha1_di();
  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA224(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha224_di();
  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA256(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha256_di();
  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA384(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha384_di();
  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA512(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha512_di();
  return SecKeyRSACopyDecryptedWithPadding(a1, v7, a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA1AESGCM(uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, CFSTR("algid:encrypt:RSA:OAEP:SHA1"), a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA224AESGCM(uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, CFSTR("algid:encrypt:RSA:OAEP:SHA224"), a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA256AESGCM(uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, CFSTR("algid:encrypt:RSA:OAEP:SHA256"), a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA384AESGCM(uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, CFSTR("algid:encrypt:RSA:OAEP:SHA384"), a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Decrypt_RSAEncryptionOAEPSHA512AESGCM(uint64_t *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyDecryptedData(a1, CFSTR("algid:encrypt:RSA:OAEP:SHA512"), a2, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA1(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDH:KDFX963:SHA1"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA224(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDH:KDFX963:SHA224"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA256(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDH:KDFX963:SHA256"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA384(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDH:KDFX963:SHA384"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardX963SHA512(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDH:KDFX963:SHA512"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA1(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA1"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA224(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA224"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA256(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA256"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA384(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA384"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorX963SHA512(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA512"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA224(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDH:KDFX963:SHA224"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA256(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDH:KDFX963:SHA256"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA384(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDH:KDFX963:SHA384"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESStandardVariableIVX963SHA512(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDH:KDFX963:SHA512"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA224(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA224"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA256(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA256"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA384(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA384"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIESCofactorVariableIVX963SHA512(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA512"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeKDFX963CopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESGCMCopyResult, 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Decrypt_ECIES_Standard_SHA256_2PubKeys(_QWORD *a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyECIESCopyDecryptedData(a1, (uint64_t)CFSTR("algid:keyexchange:ECDH"), (uint64_t (*)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **))SecKeyECIESKeyExchangeSHA2562PubKeysCopyResult, (uint64_t (*)(const void *, CFDataRef, uint64_t, __CFString **))SecKeyECIESDecryptAESCBCCopyResult, 0, a2, a3, a4);
}

__CFData *SecKeyECIESKeyExchangeSHA2562PubKeysCopyResult(uint64_t a1, const void *a2, uint64_t a3, const __CFData *a4, const __CFData *a5, uint64_t a6, uint64_t a7, __CFString **a8)
{
  __CFData *v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  char *v16;
  unint64_t v17;
  CFIndex v18;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x1E0C80C00];
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  *(_QWORD *)(a1 + 8) = 4;
  v12 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, a4, 0, a8);
  if (v12 && !*(_QWORD *)(a1 + 24))
  {
    v13 = ccsha256_di();
    MEMORY[0x1E0C80A78](v13);
    v16 = (char *)v22 - v15;
    if (v17 >= 8)
      memset((char *)v22 - v15, 170, v14);
    ccdigest_init();
    CFDataGetLength(v12);
    CFDataGetBytePtr(v12);
    ccdigest_update();
    CFDataGetLength(a4);
    CFDataGetBytePtr(a4);
    ccdigest_update();
    CFDataGetLength(a5);
    CFDataGetBytePtr(a5);
    ccdigest_update();
    v18 = *(_QWORD *)v13;
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    CFDataSetLength(Mutable, v18);
    CFRelease(v12);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    (*(void (**)(uint64_t, char *, UInt8 *))(v13 + 56))(v13, v16, MutableBytePtr);
    return Mutable;
  }
  return v12;
}

__CFData *SecKeyECIESDecryptAESCBCCopyResult(const __CFData *a1, CFDataRef theData)
{
  const __CFAllocator *v4;
  CFIndex Length;
  __CFData *Mutable;

  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v4 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  Length = CFDataGetLength(theData);
  Mutable = CFDataCreateMutable(v4, 0);
  CFDataSetLength(Mutable, Length);
  ccaes_cbc_decrypt_mode();
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  CFDataGetLength(a1);
  CFDataGetBytePtr(theData);
  CFDataGetMutableBytePtr(Mutable);
  cccbc_one_shot();
  return Mutable;
}

CFTypeRef SecKeyECIESCopyDecryptedData(_QWORD *a1, uint64_t a2, uint64_t (*a3)(_QWORD *, uint64_t, _QWORD, CFDataRef, CFDataRef, uint64_t, uint64_t, __CFString **), uint64_t (*a4)(const void *, CFDataRef, uint64_t, __CFString **), uint64_t a5, const __CFData *a6, uint64_t a7, __CFString **a8)
{
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  const void *Value;
  const void *v17;
  const void *v18;
  const void *v19;
  CFIndex v20;
  const UInt8 *v21;
  CFDataRef v22;
  CFDataRef v23;
  const void *v24;
  int v25;
  const __CFString *v26;
  uint64_t CFIndexFromRef;
  uint64_t v28;
  uint64_t v29;
  const UInt8 *BytePtr;
  __SecKey *v31;
  const void *v32;
  const void *v33;
  CFTypeRef v34;
  CFDataRef v35;
  const __CFAllocator *v36;
  CFIndex Length;
  const __CFDictionary *v38;
  const __CFData *theData;
  uint64_t (*v41)(const void *, CFDataRef, uint64_t, __CFString **);
  __SecKey *cf;

  v14 = SecKeyCopyAttributes((SecKeyRef)*a1);
  if (!v14)
  {
    SecError(-50, a8, CFSTR("Unable to export key parameters"));
    return 0;
  }
  v15 = v14;
  Value = CFDictionaryGetValue(v14, CFSTR("type"));
  if (!CFEqual(Value, CFSTR("73"))
    && (v17 = CFDictionaryGetValue(v15, CFSTR("type")), !CFEqual(v17, CFSTR("106")))
    && (v18 = CFDictionaryGetValue(v15, CFSTR("type")), !CFEqual(v18, CFSTR("108")))
    || (v19 = CFDictionaryGetValue(v15, CFSTR("kcls")), !CFEqual(v19, CFSTR("1"))))
  {
    v34 = (CFTypeRef)*MEMORY[0x1E0C9B0D0];
LABEL_37:
    v38 = v15;
    goto LABEL_31;
  }
  theData = a6;
  v41 = a4;
  if (a1[3])
  {
    v20 = 0;
    v21 = 0;
    cf = 0;
    v22 = 0;
    v23 = 0;
    goto LABEL_17;
  }
  v24 = CFDictionaryGetValue(v15, CFSTR("type"));
  v25 = CFEqual(v24, CFSTR("73"));
  v26 = (const __CFString *)CFDictionaryGetValue(v15, CFSTR("bsiz"));
  CFIndexFromRef = SecKeyGetCFIndexFromRef(v26);
  v28 = CFIndexFromRef + 7;
  if (CFIndexFromRef < -7)
    v28 = CFIndexFromRef + 14;
  v29 = v28 >> 3;
  if (v25)
    v20 = (2 * v29) | 1;
  else
    v20 = v29;
  if (CFDataGetLength(a6) < v20)
  {
    SecError(-50, a8, CFSTR("%@: too small input packet for ECIES decrypt"), *a1, a6);
    v34 = 0;
    goto LABEL_37;
  }
  BytePtr = CFDataGetBytePtr(a6);
  v23 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], BytePtr, v20, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v31 = SecKeyCopyPublicKey((SecKeyRef)*a1);
  if (!v31)
  {
    SecError(-50, a8, CFSTR("%@: Unable to get public key"), *a1);
    v35 = 0;
    cf = 0;
    v22 = 0;
LABEL_40:
    v33 = 0;
    goto LABEL_41;
  }
  cf = v31;
  v22 = SecKeyCopyExternalRepresentation(v31, (CFErrorRef *)a8);
  if (!v22)
  {
    v35 = 0;
    goto LABEL_40;
  }
  v21 = &BytePtr[v20];
LABEL_17:
  v32 = (const void *)a3(a1, a2, 0, v23, v22, a5, a7, a8);
  v33 = v32;
  if (!v32)
  {
    v35 = 0;
LABEL_41:
    v34 = 0;
    goto LABEL_21;
  }
  if (a1[3])
  {
    v34 = CFRetain(v32);
    v35 = 0;
  }
  else
  {
    v36 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Length = CFDataGetLength(theData);
    v35 = CFDataCreateWithBytesNoCopy(v36, v21, Length - v20, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    v34 = (CFTypeRef)v41(v33, v35, a7, a8);
  }
LABEL_21:
  CFRelease(v15);
  if (v23)
    CFRelease(v23);
  if (v33)
    CFRelease(v33);
  if (v22)
    CFRelease(v22);
  if (cf)
    CFRelease(cf);
  if (v35)
  {
    v38 = v35;
LABEL_31:
    CFRelease(v38);
  }
  return v34;
}

uint64_t SecKeyGetCFIndexFromRef(const __CFString *a1)
{
  CFTypeID v2;
  CFTypeID v4;
  uint64_t valuePtr;

  valuePtr = 0;
  v2 = CFGetTypeID(a1);
  if (v2 == CFNumberGetTypeID())
  {
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberCFIndexType, &valuePtr))
      return valuePtr;
    else
      return 0;
  }
  else
  {
    v4 = CFGetTypeID(a1);
    if (v4 == CFStringGetTypeID())
      return CFStringGetIntValue(a1);
    else
      return 0;
  }
}

id SecKeyECIESKeyExchangeKDFX963CopyResult(uint64_t a1, const void *a2, int a3, void *a4, const __CFData *a5, int a6, void *a7, __CFString **a8)
{
  id v15;
  const __CFData *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  CFIndex Length;
  uint64_t v21;
  void *v22;
  void *v23;
  const __CFData *v24;
  __CFData *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  id v29;
  int v31[2];
  void *v32;
  _QWORD v33[2];
  _QWORD v34[3];

  v34[2] = *MEMORY[0x1E0C80C00];
  v15 = a7;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  *(_QWORD *)(a1 + 8) = 4;
  if (*(_QWORD *)(a1 + 24))
  {
    v16 = 0;
    v17 = 0;
  }
  else
  {
    *(_QWORD *)v31 = a8;
    v32 = v15;
    objc_msgSend(v15, "objectForKeyedSubscript:", CFSTR("symKeySize"));
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    if (v18)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0)
      {
        SecError(-50, a8, CFSTR("Bad requested kSecKeyEncryptionParameterSymmetricKeySizeInBits: %@"), v18);

        v29 = 0;
        v15 = v32;
        goto LABEL_22;
      }
      v19 = objc_msgSend(v18, "integerValue") / 8;
    }
    else
    {
      Length = CFDataGetLength(a5);
      v19 = 16;
      if (Length > 66)
        v19 = 32;
    }
    if (a6)
      v21 = v19 + 16;
    else
      v21 = v19;
    v17 = (void *)objc_msgSend(a4, "mutableCopy");
    objc_msgSend(v32, "objectForKeyedSubscript:", CFSTR("sharedInfo"));
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    if (v22)
      objc_msgSend(v17, "appendData:", v22);
    v33[0] = CFSTR("sharedInfo");
    v33[1] = CFSTR("requestedSize");
    v34[0] = v17;
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", v21);
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    v34[1] = v23;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v34, v33, 2);
    v16 = (const __CFData *)objc_claimAutoreleasedReturnValue();

    a8 = *(__CFString ***)v31;
    v15 = v32;
  }
  if (a3)
    v24 = a5;
  else
    v24 = (const __CFData *)a4;
  v25 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, v24, v16, a8);
  v26 = v25;
  if (!*(_QWORD *)(a1 + 24) && (a6 & 1) == 0 && v25)
  {
    v27 = (void *)-[__CFData mutableCopy](v25, "mutableCopy");
    objc_msgSend(v27, "appendBytes:length:", &kSecKeyIESIV, 16);
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithData:", v27);
    v28 = objc_claimAutoreleasedReturnValue();

    v26 = (void *)v28;
  }
  v29 = v26;

LABEL_22:
  return v29;
}

CFTypeRef SecKeyECIESDecryptAESGCMCopyResult(const __CFData *a1, CFDataRef theData, const __CFDictionary *a3, __CFString **a4)
{
  const __CFAllocator *v8;
  CFIndex v9;
  __CFData *Mutable;
  __CFData *v11;
  CFIndex v12;
  UInt8 *MutableBytePtr;
  const __CFData *Value;
  UInt8 *v15;
  uint64_t v16;
  CFTypeRef v17;
  UInt8 *v19;
  CFRange v20;

  if (CFDataGetLength(theData) <= 15)
  {
    SecError(-50, a4, CFSTR("ECIES: Input data too short"));
    return 0;
  }
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v8 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
  v9 = CFDataGetLength(theData) - 16;
  Mutable = CFDataCreateMutable(v8, 0);
  CFDataSetLength(Mutable, v9);
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v11 = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  CFDataSetLength(v11, 16);
  v12 = CFDataGetLength(theData) - 16;
  MutableBytePtr = CFDataGetMutableBytePtr(v11);
  v20.location = v12;
  v20.length = 16;
  CFDataGetBytes(theData, v20, MutableBytePtr);
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  if (a3)
    Value = (const __CFData *)CFDictionaryGetValue(a3, CFSTR("aad"));
  else
    Value = 0;
  ccaes_gcm_decrypt_mode();
  CFDataGetBytePtr(a1);
  if (Value)
  {
    CFDataGetLength(Value);
    CFDataGetBytePtr(Value);
  }
  CFDataGetLength(Mutable);
  CFDataGetBytePtr(theData);
  v15 = CFDataGetMutableBytePtr(Mutable);
  v19 = CFDataGetMutableBytePtr(v11);
  v16 = ccgcm_one_shot();
  if (!(_DWORD)v16)
  {
    v17 = CFRetain(Mutable);
    if (!Mutable)
      goto LABEL_14;
    goto LABEL_13;
  }
  SecError(-50, a4, CFSTR("ECIES: Failed to aes-gcm decrypt data (err %d)"), v16, v15, 16, v19);
  v17 = 0;
  if (Mutable)
LABEL_13:
    CFRelease(Mutable);
LABEL_14:
  if (v11)
    CFRelease(v11);
  return v17;
}

void *SecKeyRSAAESGCMCopyDecryptedData(uint64_t *a1, const void *a2, const __CFData *a3, __CFString **a4)
{
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const void *Value;
  const void *v11;
  __SecKey *v12;
  __SecKey *v13;
  SecKeyRef v14;
  uint64_t (*v15)(SecKeyRef);
  CFIndex v16;
  const __CFAllocator *v17;
  const UInt8 *BytePtr;
  const __CFData *v19;
  __CFData *v20;
  const __CFString *v21;
  uint64_t v22;
  const __CFAllocator *v23;
  CFIndex v24;
  __CFData *Mutable;
  __CFData *v26;
  CFIndex v27;
  UInt8 *MutableBytePtr;
  UInt8 *v29;
  uint64_t v30;
  void *v31;
  const __CFDictionary *v32;
  UInt8 *v34;
  const __CFData *v35;
  CFRange v36;

  v8 = SecKeyCopyAttributes((SecKeyRef)*a1);
  if (!v8)
  {
    SecError(-50, a4, CFSTR("Unable to export key parameters"));
    return 0;
  }
  v9 = v8;
  Value = CFDictionaryGetValue(v8, CFSTR("type"));
  if (!CFEqual(Value, CFSTR("42")) || (v11 = CFDictionaryGetValue(v9, CFSTR("kcls")), !CFEqual(v11, CFSTR("1"))))
  {
    v31 = (void *)*MEMORY[0x1E0C9B0D0];
LABEL_34:
    v32 = v9;
    goto LABEL_28;
  }
  CFArrayAppendValue((CFMutableArrayRef)a1[2], a2);
  if (a1[3])
  {
    v31 = SecKeyRunAlgorithmAndCopyResult(a1, 0, 0, a4);
    goto LABEL_34;
  }
  v12 = SecKeyCopyPublicKey((SecKeyRef)*a1);
  if (!v12)
  {
    SecError(-50, a4, CFSTR("%@: unable to get public key"), *a1);
    v31 = 0;
    goto LABEL_34;
  }
  v13 = v12;
  v35 = SecKeyCopyExternalRepresentation(v12, (CFErrorRef *)a4);
  if (!v35)
  {
    CFRelease(v9);
    CFRelease(v13);
    return 0;
  }
  v14 = (SecKeyRef)*a1;
  _SecKeyCheck(*a1, (uint64_t)"SecKeyGetBlockSize");
  v15 = *(uint64_t (**)(SecKeyRef))(*((_QWORD *)v14 + 2) + 80);
  if (v15)
    v16 = v15(v14);
  else
    v16 = 0;
  if (CFDataGetLength(a3) < v16 + 16)
  {
    SecError(-50, a4, CFSTR("RSA-WRAP too short input data"));
LABEL_38:
    Mutable = 0;
    v31 = 0;
LABEL_25:
    CFRelease(v9);
    goto LABEL_26;
  }
  v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  BytePtr = CFDataGetBytePtr(a3);
  v19 = CFDataCreateWithBytesNoCopy(v17, BytePtr, v16, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v20 = SecKeyRunAlgorithmAndCopyResult(a1, v19, 0, a4);
  if (v19)
    CFRelease(v19);
  if (!v20)
    goto LABEL_38;
  v21 = (const __CFString *)CFDictionaryGetValue(v9, CFSTR("bsiz"));
  if (SecKeyGetCFIndexFromRef(v21) <= 4095)
    v22 = 16;
  else
    v22 = 32;
  if (CFDataGetLength(v20) == v22)
  {
    if (SecCFAllocatorZeroize_sOnce != -1)
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
    v23 = (const __CFAllocator *)SecCFAllocatorZeroize_sAllocator;
    v24 = CFDataGetLength(a3) - v16 - 16;
    Mutable = CFDataCreateMutable(v23, 0);
    CFDataSetLength(Mutable, v24);
    if (SecCFAllocatorZeroize_sOnce != -1)
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
    v26 = CFDataCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
    CFDataSetLength(v26, 16);
    v27 = CFDataGetLength(a3) - 16;
    MutableBytePtr = CFDataGetMutableBytePtr(v26);
    v36.location = v27;
    v36.length = 16;
    CFDataGetBytes(a3, v36, MutableBytePtr);
    CFDataGetBytePtr(a3);
    ccaes_gcm_decrypt_mode();
    CFDataGetLength(v20);
    CFDataGetBytePtr(v20);
    CFDataGetLength(v35);
    CFDataGetBytePtr(v35);
    CFDataGetLength(Mutable);
    v29 = CFDataGetMutableBytePtr(Mutable);
    v34 = CFDataGetMutableBytePtr(v26);
    v30 = ccgcm_one_shot();
    if ((_DWORD)v30)
    {
      SecError(-50, a4, CFSTR("RSA-WRAP: Failed to aes-gcm decrypt data (err %d)"), v30, v29, 16, v34);
      v31 = 0;
    }
    else
    {
      v31 = (void *)CFRetain(Mutable);
    }
  }
  else
  {
    SecError(-50, a4, CFSTR("RSA-WRAP bad ciphertext, unexpected session key size"));
    v26 = 0;
    Mutable = 0;
    v31 = 0;
  }
  CFRelease(v9);
  CFRelease(v20);
  v9 = v26;
  if (v26)
    goto LABEL_25;
LABEL_26:
  CFRelease(v35);
  CFRelease(v13);
  if (Mutable)
  {
    v32 = Mutable;
LABEL_28:
    CFRelease(v32);
  }
  return v31;
}

__CFData *SecKeyRSACopyDecryptedWithPadding(uint64_t a1, _QWORD *a2, const __CFData *a3, __CFString **a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t);
  unint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t (*v15)(uint64_t);
  unint64_t v16;
  _QWORD v17[8];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:encrypt:RSA:raw-cc"));
  if (a2)
    v8 = 2 * *a2 + 2;
  else
    v8 = 11;
  v9 = *(_QWORD *)a1;
  _SecKeyCheck(*(_QWORD *)a1, (uint64_t)"SecKeyGetBlockSize");
  v10 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 16) + 80);
  if (v10)
    v11 = v10(v9);
  else
    v11 = 0;
  if (v11 < v8)
    return (__CFData *)*MEMORY[0x1E0C9B0D0];
  if (*(_QWORD *)(a1 + 24) == 1)
    return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0, 0, a4);
  v18 = 0;
  v19 = &v18;
  v20 = 0x2020000000;
  v21 = 0;
  v14 = *(_QWORD *)a1;
  _SecKeyCheck(*(_QWORD *)a1, (uint64_t)"SecKeyGetBlockSize");
  v15 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v14 + 16) + 80);
  if (v15)
    v16 = v15(v14);
  else
    v16 = 0;
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3221225472;
  v17[2] = __SecKeyRSACopyDecryptedWithPadding_block_invoke;
  v17[3] = &unk_1E1FD8218;
  v17[4] = &v18;
  v17[5] = a1;
  v17[6] = a4;
  v17[7] = a2;
  PerformWithBigEndianToCCUnit(a3, v16, v17);
  v12 = v19[3];
  _Block_object_dispose(&v18, 8);
  return (__CFData *)v12;
}

void sub_18A9F334C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__CFData *SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian(uint64_t *a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v9;
  uint64_t (*v10)(uint64_t);
  size_t v11;
  uint64_t v12;
  _QWORD *v13;
  void *v14;
  uint64_t v15;
  _QWORD v16[8];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[4];
  _QWORD *v22;
  uint64_t v23;
  size_t v24;

  if (a1[3] == 1)
    return SecKeyRunAlgorithmAndCopyResult(a1, 0, 0, a4);
  v17 = 0;
  v18 = &v17;
  v19 = 0x2020000000;
  v20 = 0;
  v9 = *a1;
  _SecKeyCheck(*a1, (uint64_t)"SecKeyGetBlockSize");
  v10 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 16) + 80);
  if (v10)
    v11 = v10(v9);
  else
    v11 = 0;
  v12 = MEMORY[0x1E0C809B0];
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 3221225472;
  v16[2] = __SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian_block_invoke;
  v16[3] = &unk_1E1FD8218;
  v16[4] = &v17;
  v16[5] = a1;
  v16[6] = a3;
  v16[7] = a4;
  v13 = v16;
  v14 = v13;
  if (a2)
  {
    v21[0] = v12;
    v21[1] = 3221225472;
    v21[2] = __PerformWithCCUnitToBigEndian_block_invoke;
    v21[3] = &unk_1E1FD8268;
    v23 = a2;
    v24 = v11;
    v22 = v13;
    PerformWithCFDataBuffer(v11, v21);

  }
  else
  {
    __SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian_block_invoke((uint64_t)v13, 0);
  }

  v15 = v18[3];
  _Block_object_dispose(&v17, 8);
  return (__CFData *)v15;
}

void sub_18A9F36A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_list va;

  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha1_di();
  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha224_di();
  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA256(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha256_di();
  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha384_di();
  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha512_di();
  return SecKeyRSACopyEncryptedWithPadding(a1, v7, a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA1AESGCM(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, CFSTR("algid:encrypt:RSA:OAEP:SHA1"), a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA224AESGCM(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, CFSTR("algid:encrypt:RSA:OAEP:SHA224"), a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA256AESGCM(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, CFSTR("algid:encrypt:RSA:OAEP:SHA256"), a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA384AESGCM(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, CFSTR("algid:encrypt:RSA:OAEP:SHA384"), a2, a4);
}

void *SecKeyAlgorithmAdaptorCopyResult_Encrypt_RSAEncryptionOAEPSHA512AESGCM(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSAAESGCMCopyEncryptedData(a1, CFSTR("algid:encrypt:RSA:OAEP:SHA512"), a2, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA1(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDH:KDFX963:SHA1"), 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA224(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDH:KDFX963:SHA224"), 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA256(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDH:KDFX963:SHA256"), 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA384(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDH:KDFX963:SHA384"), 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardX963SHA512(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDH:KDFX963:SHA512"), 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA1(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA1"), 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA224(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA224"), 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA256(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA256"), 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA384(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA384"), 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorX963SHA512(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA512"), 0, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA224(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDH:KDFX963:SHA224"), 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA256(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDH:KDFX963:SHA256"), 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA384(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDH:KDFX963:SHA384"), 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESStandardVariableIVX963SHA512(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDH:KDFX963:SHA512"), 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA224(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA224"), 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA256(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA256"), 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA384(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA384"), 1, a2, a3, a4);
}

CFTypeRef SecKeyAlgorithmAdaptorCopyResult_Encrypt_ECIESCofactorVariableIVX963SHA512(uint64_t a1, const __CFData *a2, void *a3, __CFString **a4)
{
  return SecKeyECIESCopyEncryptedData(a1, CFSTR("algid:keyexchange:ECDHC:KDFX963:SHA512"), 1, a2, a3, a4);
}

CFTypeRef SecKeyECIESCopyEncryptedData(uint64_t a1, const void *a2, int a3, const __CFData *a4, void *a5, __CFString **a6)
{
  SecKeyRef v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  const void *Value;
  const void *v15;
  const void *v16;
  const void *v17;
  const __CFAllocator *v18;
  const void *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  CFDictionaryRef v27;
  const __CFDictionary *v28;
  __SecKey *RandomKey;
  __SecKey *v30;
  __SecKey *v31;
  __SecKey *v32;
  const __CFData *v33;
  CFDataRef v34;
  const __CFData *v35;
  const __CFData *v36;
  CFTypeRef v37;
  const __CFData *MutableCopy;
  const __CFData *v39;
  CFIndex Length;
  CFIndex v41;
  CFIndex v42;
  uint64_t v43;
  const __CFDictionary *v45;
  UInt8 *v46;
  const __CFData *theData;
  __SecKey *v48;
  const __CFData *v50;

  v11 = *(SecKeyRef *)a1;
  v12 = SecKeyCopyAttributes(*(SecKeyRef *)a1);
  if (!v12)
  {
    SecError(-50, a6, CFSTR("Unable to export key parameters"));
    v37 = 0;
    goto LABEL_35;
  }
  v13 = v12;
  theData = a4;
  Value = CFDictionaryGetValue(v12, CFSTR("type"));
  if (!CFEqual(Value, CFSTR("73"))
    && (v15 = CFDictionaryGetValue(v13, CFSTR("type")), !CFEqual(v15, CFSTR("106")))
    && (v16 = CFDictionaryGetValue(v13, CFSTR("type")), !CFEqual(v16, CFSTR("108")))
    || (v17 = CFDictionaryGetValue(v13, CFSTR("kcls")), !CFEqual(v17, CFSTR("0"))))
  {
    v30 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v36 = 0;
    MutableCopy = 0;
    v37 = (CFTypeRef)*MEMORY[0x1E0C9B0D0];
    goto LABEL_22;
  }
  v50 = SecKeyCopyExternalRepresentation(*(SecKeyRef *)a1, (CFErrorRef *)a6);
  if (!v50)
  {
    v30 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v36 = 0;
    v37 = 0;
    MutableCopy = 0;
    goto LABEL_22;
  }
  v48 = v11;
  v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v19 = CFDictionaryGetValue(v13, CFSTR("type"));
  CFDictionaryGetValue(v13, CFSTR("bsiz"));
  v27 = CFDictionaryCreateForCFTypes(v18, v20, v21, v22, v23, v24, v25, v26, (uint64_t)CFSTR("type"), (uint64_t)v19);
  v28 = v13;
  v13 = v27;
  CFRelease(v28);
  RandomKey = SecKeyCreateRandomKey(v13, (CFErrorRef *)a6);
  v30 = RandomKey;
  if (!RandomKey)
  {
    MutableCopy = 0;
    v37 = 0;
    v36 = 0;
    v34 = 0;
    v32 = 0;
    v11 = v48;
    v33 = v50;
    if (!v13)
      goto LABEL_23;
    goto LABEL_22;
  }
  v31 = SecKeyCopyPublicKey(RandomKey);
  v32 = v31;
  v33 = v50;
  if (!v31)
  {
    SecError(-50, a6, CFSTR("Unable to get public key from generated ECkey"));
    MutableCopy = 0;
    v37 = 0;
    v36 = 0;
    v34 = 0;
    goto LABEL_13;
  }
  v34 = SecKeyCopyExternalRepresentation(v31, (CFErrorRef *)a6);
  if (!v34)
  {
    MutableCopy = 0;
    v37 = 0;
    v36 = 0;
    goto LABEL_13;
  }
  *(_QWORD *)a1 = v30;
  v35 = (const __CFData *)SecKeyECIESKeyExchangeKDFX963CopyResult(a1, a2, 1, v34, v50, a3, a5, a6);
  v36 = v35;
  if (!v35)
  {
    MutableCopy = 0;
    v37 = 0;
LABEL_13:
    v11 = v48;
    if (!v13)
      goto LABEL_23;
    goto LABEL_22;
  }
  if (*(_QWORD *)(a1 + 24))
  {
    v37 = CFRetain(v35);
    MutableCopy = 0;
    goto LABEL_13;
  }
  v45 = v13;
  v39 = (const __CFData *)a5;
  MutableCopy = CFDataCreateMutableCopy(v18, 0, v34);
  Length = CFDataGetLength(MutableCopy);
  v41 = CFDataGetLength(theData);
  CFDataSetLength(MutableCopy, Length + v41 + 16);
  v46 = &CFDataGetMutableBytePtr(MutableCopy)[Length];
  v42 = CFDataGetLength(theData);
  CFDataGetLength(v36);
  CFDataGetBytePtr(v36);
  if (a5)
    v39 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a5, CFSTR("aad"));
  ccaes_gcm_encrypt_mode();
  CFDataGetBytePtr(v36);
  if (v39)
  {
    CFDataGetLength(v39);
    CFDataGetBytePtr(v39);
  }
  CFDataGetLength(theData);
  CFDataGetBytePtr(theData);
  v43 = ccgcm_one_shot();
  if ((_DWORD)v43)
  {
    SecError(-50, a6, CFSTR("ECIES: Failed to aes-gcm encrypt data (err %d)"), v43, v46, 16, &v46[v42], 0);
    v37 = 0;
  }
  else
  {
    v37 = CFRetain(MutableCopy);
  }
  v11 = v48;
  v33 = v50;
  v13 = v45;
  if (!v45)
    goto LABEL_23;
LABEL_22:
  CFRelease(v13);
LABEL_23:
  if (v30)
    CFRelease(v30);
  if (v32)
    CFRelease(v32);
  if (v33)
    CFRelease(v33);
  if (v34)
    CFRelease(v34);
  if (v36)
    CFRelease(v36);
  if (MutableCopy)
    CFRelease(MutableCopy);
LABEL_35:
  *(_QWORD *)a1 = v11;
  return v37;
}

void *SecKeyRSAAESGCMCopyEncryptedData(uint64_t a1, const void *a2, const __CFData *a3, __CFString **a4)
{
  const __CFDictionary *v8;
  const __CFDictionary *v9;
  const void *Value;
  const void *v11;
  CFDataRef v12;
  const __CFData *v13;
  const __CFString *v14;
  size_t v15;
  const __CFData *v16;
  __CFData *v17;
  const __CFData *v18;
  const __CFAllocator *v19;
  CFIndex Length;
  CFIndex v21;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  UInt8 *v24;
  CFIndex v25;
  uint64_t v26;
  void *v27;
  const __CFDictionary *v28;
  CFRange v30;

  v8 = SecKeyCopyAttributes(*(SecKeyRef *)a1);
  if (!v8)
  {
    SecError(-50, a4, CFSTR("Unable to export key parameters"));
    return 0;
  }
  v9 = v8;
  Value = CFDictionaryGetValue(v8, CFSTR("type"));
  if (!CFEqual(Value, CFSTR("42")) || (v11 = CFDictionaryGetValue(v9, CFSTR("kcls")), !CFEqual(v11, CFSTR("0"))))
  {
    v27 = (void *)*MEMORY[0x1E0C9B0D0];
LABEL_25:
    v28 = v9;
    goto LABEL_19;
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  if (*(_QWORD *)(a1 + 24))
  {
    v27 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0, 0, a4);
    goto LABEL_25;
  }
  v12 = SecKeyCopyExternalRepresentation(*(SecKeyRef *)a1, (CFErrorRef *)a4);
  if (!v12)
  {
    v27 = 0;
    goto LABEL_25;
  }
  v13 = v12;
  v14 = (const __CFString *)CFDictionaryGetValue(v9, CFSTR("bsiz"));
  if (SecKeyGetCFIndexFromRef(v14) <= 4095)
    v15 = 16;
  else
    v15 = 32;
  v16 = (const __CFData *)CFDataCreateWithRandomBytes(v15);
  if (v16)
  {
    v17 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, v16, 0, a4);
    v18 = v17;
    if (v17)
    {
      v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      Length = CFDataGetLength(v17);
      v21 = Length + CFDataGetLength(a3) + 16;
      Mutable = CFDataCreateMutable(v19, 0);
      CFDataSetLength(Mutable, v21);
      MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
      v30.length = CFDataGetLength(v18);
      v30.location = 0;
      CFDataGetBytes(v18, v30, MutableBytePtr);
      v24 = &MutableBytePtr[CFDataGetLength(v18)];
      v25 = (CFIndex)&v24[CFDataGetLength(a3)];
      ccaes_gcm_encrypt_mode();
      CFDataGetLength(v16);
      CFDataGetBytePtr(v16);
      CFDataGetLength(v13);
      CFDataGetBytePtr(v13);
      CFDataGetLength(a3);
      CFDataGetBytePtr(a3);
      v26 = ccgcm_one_shot();
      if ((_DWORD)v26)
      {
        SecError(-50, a4, CFSTR("RSAWRAP: Failed to aes-gcm encrypt data (err %d)"), v26, v24, 16, v25);
        v27 = 0;
      }
      else
      {
        v27 = (void *)CFRetain(Mutable);
      }
    }
    else
    {
      v27 = 0;
      Mutable = 0;
    }
  }
  else
  {
    SecError(-50, a4, CFSTR("Failed to generate session key"));
    v27 = 0;
    Mutable = 0;
    v18 = 0;
  }
  CFRelease(v9);
  CFRelease(v13);
  if (v18)
    CFRelease(v18);
  if (v16)
    CFRelease(v16);
  if (Mutable)
  {
    v28 = Mutable;
LABEL_19:
    CFRelease(v28);
  }
  return v27;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureRaw(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureRaw_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA224(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA224_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA512(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15SHA512_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15Raw(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15Raw_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15MD5(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[5];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPKCS1v15MD5_block_invoke;
  v5[3] = &__block_descriptor_40_e19_C16__0____CFData__8l;
  v5[4] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA1(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[6];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA1_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  v5[4] = a1;
  v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA224(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[6];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA224_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  v5[4] = a1;
  v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA256(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[6];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA256_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  v5[4] = a1;
  v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA384(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[6];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA384_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  v5[4] = a1;
  v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA512(uint64_t a1, uint64_t a2, const __CFData *a3, __CFString **a4)
{
  _QWORD v5[6];

  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 3221225472;
  v5[2] = __SecKeyAlgorithmAdaptorCopyResult_Verify_RSASignatureDigestPSSSHA512_block_invoke;
  v5[3] = &__block_descriptor_48_e19_C16__0____CFData__8l;
  v5[4] = a1;
  v5[5] = a2;
  return SecKeyRSAVerifyAdaptorCopyResult(a1, a3, a4, v5);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PKCS1v15:SHA224"));
  v8 = (size_t *)ccsha224_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15SHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PKCS1v15:SHA512"));
  v8 = (size_t *)ccsha512_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePKCS1v15MD5(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PKCS1v15:MD5"));
  v8 = (size_t *)ccmd5_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PSS:SHA1:SHA1:20"));
  v8 = (size_t *)ccsha1_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PSS:SHA224:SHA224:24"));
  v8 = (size_t *)ccsha224_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA256(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PSS:SHA256:SHA256:32"));
  v8 = (size_t *)ccsha256_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PSS:SHA384:SHA384:48"));
  v8 = (size_t *)ccsha384_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureMessagePSSSHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:digest-PSS:SHA512:SHA512:64"));
  v8 = (size_t *)ccsha512_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-X962:SHA1"));
  v8 = (size_t *)ccsha1_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-X962:SHA224"));
  v8 = (size_t *)ccsha224_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageX962SHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-X962:SHA512"));
  v8 = (size_t *)ccsha512_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA1(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  _QWORD *v8;

  v8 = (_QWORD *)ccsha1_di();
  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, (uint64_t)CFSTR("algid:sign:ECDSA:digest-X962:SHA1"), v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA224(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  _QWORD *v8;

  v8 = (_QWORD *)ccsha224_di();
  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, (uint64_t)CFSTR("algid:sign:ECDSA:digest-X962:SHA224"), v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureDigestX962SHA512(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  _QWORD *v8;

  v8 = (_QWORD *)ccsha512_di();
  return SecKeyCopyECDSASignatureForDigest(a1, a2, a3, (uint64_t)CFSTR("algid:sign:ECDSA:digest-X962:SHA512"), v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-RFC4754:SHA1"));
  v8 = (size_t *)ccsha1_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-RFC4754:SHA224"));
  v8 = (size_t *)ccsha224_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA256(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-RFC4754:SHA256"));
  v8 = (size_t *)ccsha256_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-RFC4754:SHA384"));
  v8 = (size_t *)ccsha384_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureMessageRFC4754SHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  size_t *v8;

  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-RFC4754:SHA512"));
  v8 = (size_t *)ccsha512_di();
  return SecKeyCopyDigestForMessage((uint64_t *)a1, a2, a3, v8, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA1(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962:SHA1"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA224(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962:SHA224"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA256(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962:SHA256"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA384(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962:SHA384"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureDigestRFC4754SHA512(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962:SHA512"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_ECDSASignatureRFC4754(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:ECDSA:digest-RFC4754"));
  return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Verify_ECDSASignatureRFC4754Converted(uint64_t a1, const void *a2, const __CFData *a3, const __CFData *a4, __CFString **a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  void *v16;
  __CFData *v17;
  CFIndex v18;
  __CFData *Mutable;
  uint64_t v20;
  const __CFData *v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  if (*(_QWORD *)(a1 + 24) == 1)
    return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0, 0, a5);
  v10 = *(_QWORD *)a1;
  v11 = _SecKeyCheck(*(_QWORD *)a1, (uint64_t)"SecKeyGetBlockSize");
  v12 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v10 + 16) + 80);
  v21 = a3;
  if (!v12)
  {
    v13 = 0;
    goto LABEL_7;
  }
  v13 = v12(v10);
  v14 = (8 * ((unint64_t)(v13 + 7) >> 3) + 15) & 0xFFFFFFFFFFFFFFF0;
  v11 = MEMORY[0x1E0C80A78](v13);
  if (v15 <= 7)
  {
LABEL_7:
    MEMORY[0x1E0C80A78](v11);
    goto LABEL_8;
  }
  v16 = memset((char *)&v20 - v14, 170, ((v13 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
  MEMORY[0x1E0C80A78](v16);
  memset((char *)&v20 - v14, 170, ((v13 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
LABEL_8:
  CFDataGetBytePtr(a4);
  if (CFDataGetLength(a4) != 2 * v13 || ccn_read_uint() || ccn_read_uint())
  {
    SecError(-67808, a5, CFSTR("Wrong ECDSA RFC4754 signature"));
  }
  else
  {
    ccder_sizeof_integer();
    ccder_sizeof_integer();
    v18 = ccder_sizeof();
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    CFDataSetLength(Mutable, v18);
    CFDataGetMutableBytePtr(Mutable);
    ccder_encode_integer();
    ccder_encode_integer();
    if (ccder_encode_constructed_tl())
    {
      if (Mutable)
      {
        v17 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, v21, Mutable, a5);
        CFRelease(Mutable);
        return v17;
      }
    }
    else
    {
      SecError(-26276, a5, CFSTR("Failed to encode X962 signature"));
      if (Mutable)
        CFRelease(Mutable);
    }
  }
  return 0;
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha1_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha224_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha384_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15SHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha512_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15Raw(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, 0);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPKCS1v15MD5(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccmd5_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 0, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA1(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha1_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA224(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha224_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA256(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha256_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA384(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha384_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_RSASignatureDigestPSSSHA512(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  _QWORD *v7;

  v7 = (_QWORD *)ccsha512_di();
  return SecKeyRSACopyEMSASignature(a1, a2, a4, 1, v7);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureRaw(uint64_t a1, const __CFData *a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:raw-cc"));
  return SecKeyAlgorithmAdaptorCopyBigEndianToCCUnit((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_SignVerify_RSASignatureRawCCUnit(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), CFSTR("algid:sign:RSA:raw"));
  return SecKeyAlgorithmAdaptorCopyCCUnitToBigEndian((uint64_t *)a1, a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA1(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962:SHA1"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA224(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962:SHA224"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA256(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962:SHA256"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA384(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962:SHA384"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureDigestRFC4754SHA512(uint64_t a1, const __CFData *a2, const __CFData *a3, __CFString **a4)
{
  return SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(a1, CFSTR("algid:sign:ECDSA:digest-X962:SHA512"), a2, a3, a4);
}

__CFData *SecKeyAlgorithmAdaptorCopyResult_Sign_ECDSASignatureRFC4754Converted(uint64_t a1, const void *a2, const __CFData *a3, const __CFData *a4, __CFString **a5)
{
  __CFData *v10;
  const __CFData *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t (*v14)(uint64_t);
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  void *v18;
  const UInt8 *BytePtr;
  const UInt8 *v20;
  __CFData *Mutable;
  _BYTE v22[8];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 16), a2);
  if (*(_QWORD *)(a1 + 24) == 1)
    return SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, 0, 0, a5);
  v10 = SecKeyRunAlgorithmAndCopyResult((uint64_t *)a1, a3, a4, a5);
  v11 = v10;
  if (v10 && !CFEqual(v10, (CFTypeRef)*MEMORY[0x1E0C9B0D0]))
  {
    v12 = *(_QWORD *)a1;
    v13 = _SecKeyCheck(v12, (uint64_t)"SecKeyGetBlockSize");
    v14 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v12 + 16) + 80);
    if (v14)
    {
      v15 = v14(v12);
      v16 = (8 * ((unint64_t)(v15 + 7) >> 3) + 15) & 0xFFFFFFFFFFFFFFF0;
      v13 = MEMORY[0x1E0C80A78](v15);
      if (v17 > 7)
      {
        v18 = memset(&v22[-v16], 170, ((v15 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
        MEMORY[0x1E0C80A78](v18);
        memset(&v22[-v16], 170, ((v15 - 1) & 0xFFFFFFFFFFFFFFF8) + 8);
LABEL_10:
        BytePtr = CFDataGetBytePtr(v11);
        v20 = &BytePtr[CFDataGetLength(v11)];
        if ((const UInt8 *)ccder_decode_seqii() == v20)
        {
          Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
          CFDataSetLength(Mutable, 2 * v15);
          CFDataGetMutableBytePtr(Mutable);
          ccn_write_uint_padded();
          ccn_write_uint_padded();
        }
        else
        {
          SecError(-50, a5, CFSTR("Wrong ECDSA X962 signature"));
          Mutable = 0;
        }
        CFRelease(v11);
        return Mutable;
      }
    }
    else
    {
      v15 = 0;
    }
    MEMORY[0x1E0C80A78](v13);
    goto LABEL_10;
  }
  return v11;
}

uint64_t SecOTRFullDHKeyGetTypeID()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecOTRFullDHKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_9962;
  block[4] = &SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDSingleton;
  if (SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDOnce != -1)
    dispatch_once(&SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDOnce, block);
  return SecOTRFullDHKeyGetTypeID_sSecOTRFullDHKeyGetTypeIDSingleton;
}

double SecOTRFullDHKeyDestroy(_OWORD *a1)
{
  double result;

  result = 0.0;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  a1[1] = 0u;
  return result;
}

BOOL SecOTRFullDHKeyCompare(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a1 + 160) == *(_QWORD *)(a2 + 160)
      && *(_QWORD *)(a1 + 168) == *(_QWORD *)(a2 + 168)
      && *(_DWORD *)(a1 + 176) == (unint64_t)*(unsigned int *)(a2 + 176);
}

uint64_t SecOTRFullDHKeyCopyFormatDescription(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __SecOTRFullDHKeyCopyFormatDescription_block_invoke;
  v3[3] = &unk_1E1FD8390;
  v3[4] = &v4;
  v3[5] = a1;
  withXandY(a1 + 16, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t SecOTRFullDHKeyCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();
  return SecOTRFullDHKeyCopyFormatDescription(a1);
}

void withXandY(uint64_t a1, uint64_t a2)
{
  const void *v3;
  const void *v4;

  v3 = (const void *)CCNCopyAsHex();
  v4 = (const void *)CCNCopyAsHex();
  (*(void (**)(uint64_t, const void *, const void *))(a2 + 16))(a2, v3, v4);
  if (v3)
    CFRelease(v3);
  if (v4)
    CFRelease(v4);
}

uint64_t CCNCopyAsHex()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  UInt8 *v3;
  uint64_t v4;
  _QWORD v6[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v0 = ccn_write_uint_size();
  v1 = MEMORY[0x1E0C80A78](v0);
  v3 = (UInt8 *)v6 - v2;
  if (v1)
    memset((char *)v6 - v2, 170, v0);
  ccn_write_uint();
  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __CCNCopyAsHex_block_invoke;
  v6[3] = &unk_1E1FD83B8;
  v6[4] = &v7;
  BufferPerformWithHexString(v3, v0, (uint64_t)v6);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void BufferPerformWithHexString(UInt8 *bytes, CFIndex length, uint64_t a3)
{
  const __CFAllocator *v4;
  const __CFData *v5;
  const __CFData *v6;
  CFIndex v7;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex v10;
  CFIndex v11;
  unsigned int v12;

  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v5 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, length, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (v5)
  {
    v6 = v5;
    v7 = CFDataGetLength(v5);
    Mutable = CFStringCreateMutable(v4, 2 * v7);
    BytePtr = CFDataGetBytePtr(v6);
    v10 = CFDataGetLength(v6);
    if (v10 >= 1)
    {
      v11 = v10;
      do
      {
        v12 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v12);
        --v11;
      }
      while (v11);
    }
    (*(void (**)(uint64_t, __CFString *))(a3 + 16))(a3, Mutable);
    CFRelease(Mutable);
  }
  else
  {
    v6 = (const __CFData *)CFSTR("(null)");
    (*(void (**)(uint64_t, const __CFString *))(a3 + 16))(a3, CFSTR("(null)"));
  }
  CFRelease(v6);
}

uint64_t SecOTRFullDHKCreate()
{
  uint64_t Instance;

  SecOTRFullDHKeyGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  SecFDHKNewKey();
  return Instance;
}

uint64_t SecFDHKNewKey()
{
  ccrng();
  MEMORY[0x18D76FFBC]();
  ccec_compact_generate_key();
  return GenerateHashForKey();
}

uint64_t GenerateHashForKey()
{
  uint64_t v0;
  void *v1;
  void *v2;

  v0 = cczp_bitlen();
  v1 = malloc_type_malloc(((unint64_t)(v0 + 7) >> 2) | 1, 0x128A99DBuLL);
  if (!v1)
    return 4294899624;
  v2 = v1;
  ccec_export_pub();
  ccsha1_di();
  ccdigest();
  free(v2);
  return 0;
}

_QWORD *SecOTRFullDHKCreateFromBytes(uint64_t a1, unsigned int **a2, unint64_t *a3)
{
  _QWORD *Instance;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int *v9;
  unint64_t v10;
  unint64_t v11;

  SecOTRFullDHKeyGetTypeID();
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  Instance[2] = MEMORY[0x18D76FFBC]();
  if (!a2)
    goto LABEL_10;
  if (!a3)
    goto LABEL_10;
  v6 = *a3 - 4;
  if (*a3 < 4)
    goto LABEL_10;
  v7 = bswap32(*(*a2)++);
  *a3 = v6;
  if (v6 < v7)
    goto LABEL_10;
  if (ccec_import_pub())
    goto LABEL_10;
  v8 = *a3 - v7;
  *a3 = v8;
  v9 = (unsigned int *)((char *)*a2 + v7);
  *a2 = v9;
  if (v8 < 5
    || (v10 = bswap32(*v9), *a2 = v9 + 1, v11 = v8 - 4, *a3 = v11, v11 < v10)
    || (ccn_read_uint(), *a2 = (unsigned int *)((char *)*a2 + v10), *a3 -= v10, GenerateHashForKey()))
  {
LABEL_10:
    CFRelease(Instance);
    return 0;
  }
  return Instance;
}

uint64_t SecFDHKAppendSerialization(uint64_t a1, __CFData *a2)
{
  uint64_t v3;
  UInt8 bytes[4];

  AppendECPublicKeyAsDATA(a2);
  v3 = ccn_write_uint_size();
  *(_DWORD *)bytes = bswap32(v3);
  CFDataAppendBytes(a2, bytes, 4);
  CFDataGetLength(a2);
  CFDataIncreaseLength(a2, v3);
  CFDataGetMutableBytePtr(a2);
  return ccn_write_uint();
}

uint64_t AppendECPublicKeyAsDATA(__CFData *a1)
{
  uint64_t v2;
  CFIndex v3;
  UInt8 bytes[4];

  v2 = cczp_bitlen();
  v3 = ((unint64_t)(v2 + 7) >> 2) | 1;
  bytes[0] = (unint64_t)(v2 + 7) >> 26;
  bytes[1] = (unint64_t)(v2 + 7) >> 18;
  bytes[2] = (unint64_t)(v2 + 7) >> 10;
  bytes[3] = ((unint64_t)(v2 + 7) >> 2) | 1;
  CFDataAppendBytes(a1, bytes, 4);
  CFDataGetLength(a1);
  CFDataIncreaseLength(a1, v3);
  CFDataGetMutableBytePtr(a1);
  return ccec_export_pub();
}

uint64_t SecFDHKAppendPublicSerialization(uint64_t a1, __CFData *a2)
{
  uint64_t result;

  result = cczp_bitlen();
  if (result == 256)
    return AppendECPublicKeyAsDATA(a2);
  return result;
}

uint64_t SecFDHKAppendCompactPublicSerialization(uint64_t a1, const __CFData *a2)
{
  uint64_t result;
  CFIndex v4;

  result = cczp_bitlen();
  if (result == 256)
  {
    v4 = (unint64_t)(cczp_bitlen() + 7) >> 3;
    CFDataGetLength(a2);
    CFDataIncreaseLength(a2, v4);
    CFDataGetMutableBytePtr(a2);
    return ccec_compact_export();
  }
  return result;
}

uint64_t SecFDHKGetHash(uint64_t a1)
{
  return a1 + 160;
}

uint64_t SecOTRPublicDHKeyGetTypeID()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecOTRPublicDHKeyGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_3_9976;
  block[4] = &SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDSingleton;
  if (SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDOnce != -1)
    dispatch_once(&SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDOnce, block);
  return SecOTRPublicDHKeyGetTypeID_sSecOTRPublicDHKeyGetTypeIDSingleton;
}

BOOL SecOTRPublicDHKeyCompare(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a1 + 128) == *(_QWORD *)(a2 + 128)
      && *(_QWORD *)(a1 + 136) == *(_QWORD *)(a2 + 136)
      && *(_DWORD *)(a1 + 144) == (unint64_t)*(unsigned int *)(a2 + 144);
}

uint64_t SecOTRPublicDHKeyCopyFormatDescription(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __SecOTRPublicDHKeyCopyFormatDescription_block_invoke;
  v3[3] = &unk_1E1FD8408;
  v3[4] = &v4;
  v3[5] = a1;
  withXandY(a1 + 16, (uint64_t)v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

uint64_t SecOTRPublicDHKeyCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();
  return SecOTRPublicDHKeyCopyFormatDescription(a1);
}

uint64_t SecOTRPublicDHKCreateFromFullKey(uint64_t a1, uint64_t a2)
{
  uint64_t Instance;
  _QWORD *v4;
  int v5;

  SecOTRPublicDHKeyGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  v4 = *(_QWORD **)(a2 + 16);
  a2 += 16;
  memcpy((void *)(Instance + 16), (const void *)a2, 24 * *v4 + 16);
  v5 = *(_DWORD *)(a2 + 160);
  *(_OWORD *)(Instance + 128) = *(_OWORD *)(a2 + 144);
  *(_DWORD *)(Instance + 144) = v5;
  return Instance;
}

const void *SecOTRPublicDHKCreateFromSerialization(uint64_t a1, unsigned int **a2, unint64_t *a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  unint64_t v9;

  v3 = 0;
  if (a2 && a3)
  {
    v4 = *a3 - 4;
    if (*a3 >= 4 && (v5 = bswap32(**a2), ++*a2, *a3 = v4, v9 = v5, v6 = v4 >= v5, v7 = v4 - v5, v6))
    {
      *a3 = v7;
      return SecOTRPublicDHKCreateFromBytes(a1, a2, &v9);
    }
    else
    {
      return 0;
    }
  }
  return (const void *)v3;
}

const void *SecOTRPublicDHKCreateFromBytes(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  const void *Instance;

  SecOTRPublicDHKeyGetTypeID();
  Instance = (const void *)_CFRuntimeCreateInstance();
  MEMORY[0x18D76FFBC]();
  if (ccec_import_pub() || (*a2 += *a3, *a3 = 0, GenerateHashForKey()))
  {
    if (Instance)
    {
      CFRelease(Instance);
      return 0;
    }
  }
  return Instance;
}

const void *SecOTRPublicDHKCreateFromCompactSerialization(uint64_t a1, _QWORD *a2, unint64_t *a3)
{
  const void *Instance;
  unint64_t v6;

  SecOTRPublicDHKeyGetTypeID();
  Instance = (const void *)_CFRuntimeCreateInstance();
  MEMORY[0x18D76FFBC]();
  v6 = (unint64_t)(cczp_bitlen() + 7) >> 3;
  if (v6 > *a3 || ccec_compact_import_pub() || (*a3 -= v6, *a2 += v6, GenerateHashForKey()))
  {
    if (Instance)
    {
      CFRelease(Instance);
      return 0;
    }
  }
  return Instance;
}

uint64_t SecPDHKAppendSerialization(uint64_t a1, __CFData *a2)
{
  return AppendECPublicKeyAsDATA(a2);
}

uint64_t SecPDHKAppendCompactSerialization(uint64_t a1, __CFData *a2)
{
  return AppendECPublicKeyAsDATA(a2);
}

uint64_t SecPDHKGetHash(uint64_t a1)
{
  return a1 + 128;
}

uint64_t SecPDHKeyGenerateS()
{
  ccn_zero();
  return ccec_compute_key();
}

BOOL SecDHKIsGreater()
{
  size_t v0;
  unint64_t v1;
  NSObject *v2;
  _BOOL4 v3;
  int v4;
  __int128 v5;
  _OWORD v7[4];
  char v8;
  uint8_t buf[16];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v0 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  v1 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  if (v0 == v1)
  {
    if (v0 < 0x42)
    {
      v13 = -86;
      *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v11 = v5;
      v12 = v5;
      *(_OWORD *)buf = v5;
      v10 = v5;
      v8 = -86;
      v7[2] = v5;
      v7[3] = v5;
      v7[0] = v5;
      v7[1] = v5;
      ccec_export_pub();
      ccec_export_pub();
      v4 = memcmp(buf, v7, v0);
    }
    else
    {
      v2 = secLogObjForScope("SecError");
      v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
      v4 = 0;
      if (v3)
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "The size of an SecOTRDHKey is larger than 65 bytes.                      This is not supported in SecOTR and will result in malformed ciphertexts.", buf, 2u);
        v4 = 0;
      }
    }
  }
  else if (v1 < v0)
  {
    v4 = -1;
  }
  else
  {
    v4 = 1;
  }
  return v4 > 0;
}

void SecOTRDHKGenerateOTRKeys(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  __CFData *Mutable;
  __int128 v11;
  UInt8 v12;
  uint64_t v13;
  UInt8 *MutableBytePtr;
  UInt8 bytes[8];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v26 = v11;
  v27 = v11;
  v24 = v11;
  v25 = v11;
  v22 = v11;
  v23 = v11;
  v20 = v11;
  v21 = v11;
  v18 = v11;
  v19 = v11;
  v16 = v11;
  v17 = v11;
  ccn_zero();
  *(_QWORD *)bytes = 192;
  ccec_compute_key();
  if (SecDHKIsGreater())
    v12 = 1;
  else
    v12 = 2;
  bytes[0] = v12;
  CFDataAppendBytes(Mutable, bytes, 1);
  v13 = ccn_write_uint_size();
  *(_DWORD *)bytes = bswap32(v13);
  CFDataAppendBytes(Mutable, bytes, 4);
  CFDataGetLength(Mutable);
  CFDataIncreaseLength(Mutable, v13);
  CFDataGetMutableBytePtr(Mutable);
  ccn_write_uint();
  ccn_zero();
  DeriveKeys((uint64_t)Mutable, a5, a6);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  *MutableBytePtr ^= 3u;
  DeriveKeys((uint64_t)Mutable, a3, a4);
  if (Mutable)
    CFRelease(Mutable);
}

uint64_t DeriveKeys(uint64_t result, unint64_t a2, uint64_t a3)
{
  const __CFData *v5;
  _BYTE v6[20];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (a2 | a3)
  {
    v5 = (const __CFData *)result;
    memset(v6, 170, sizeof(v6));
    ccsha1_di();
    CFDataGetLength(v5);
    CFDataGetBytePtr(v5);
    result = ccdigest();
    if (a2)
      *(_OWORD *)a2 = *(_OWORD *)v6;
    if (a3)
    {
      ccsha1_di();
      return ccdigest();
    }
  }
  return result;
}

uint64_t SecOTRFullIdentityGetTypeID()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecOTRFullIdentityGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_2_9987;
  block[4] = &SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDSingleton;
  if (SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDOnce != -1)
    dispatch_once(&SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDOnce, block);
  return SecOTRFullIdentityGetTypeID_sSecOTRFullIdentityGetTypeIDSingleton;
}

void SecOTRFullIdentityDestroy(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  const void *v4;

  v2 = (const void *)a1[3];
  if (v2)
  {
    a1[3] = 0;
    CFRelease(v2);
  }
  v3 = (const void *)a1[2];
  if (v3)
  {
    a1[2] = 0;
    CFRelease(v3);
  }
  v4 = (const void *)a1[4];
  if (v4)
  {
    a1[4] = 0;
    CFRelease(v4);
  }
}

CFStringRef SecOTRFullIdentityCopyFormatDescription(unsigned __int8 *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<SecOTRPublicIdentity: %p %02x%02x%02x%02x%02x%02x%02x%02x>"), a1, a1[41], a1[42], a1[43], a1[44], a1[45], a1[46], a1[47], a1[48]);
}

CFStringRef SecOTRFullIdentityCopyDescription(unsigned __int8 *a1)
{
  SecGetDebugDescriptionFormatOptions();
  return SecOTRFullIdentityCopyFormatDescription(a1);
}

uint64_t SecOTRFullIdentityCreate(const __CFAllocator *a1, __CFString **a2)
{
  CFNumberRef v4;
  CFDictionaryRef v5;
  SecKeyRef v6;
  uint64_t v7;
  NSObject *v9;
  uint8_t v10[4];
  int valuePtr;
  SecKeyRef privateKey;
  SecKeyRef publicKey;
  void *values[5];
  void *keys[6];

  keys[5] = *(void **)MEMORY[0x1E0C80C00];
  privateKey = 0;
  publicKey = 0;
  valuePtr = 256;
  v4 = CFNumberCreate(a1, kCFNumberIntType, &valuePtr);
  keys[0] = CFSTR("type");
  keys[1] = CFSTR("bsiz");
  keys[2] = CFSTR("perm");
  keys[3] = CFSTR("pdmn");
  keys[4] = CFSTR("labl");
  values[0] = CFSTR("73");
  values[1] = v4;
  values[2] = *(void **)MEMORY[0x1E0C9AE50];
  values[3] = CFSTR("dku");
  values[4] = CFSTR("OTR Signing Key");
  v5 = CFDictionaryCreate(a1, (const void **)keys, (const void **)values, 5, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v4)
    CFRelease(v4);
  if (SecKeyGeneratePair(v5, &publicKey, &privateKey))
  {
    v9 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v10 = 0;
      _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "keygen failed", v10, 2u);
    }
  }
  else
  {
    SecOTRFIPurgeFromKeychainByValue(publicKey);
    if (v5)
      CFRelease(v5);
  }
  v6 = privateKey;
  v7 = SecOTRFullIdentityCreateFromSecKeyRefSOS((uint64_t)a1, privateKey, a2);
  if (v6)
    CFRelease(v6);
  return v7;
}

uint64_t SecOTRFIPurgeFromKeychainByValue(void *a1)
{
  const __CFDictionary *v1;
  uint64_t v2;
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  keys[0] = CFSTR("class");
  keys[1] = CFSTR("labl");
  keys[2] = CFSTR("v_Ref");
  values[0] = CFSTR("keys");
  values[1] = CFSTR("OTR Signing Key");
  values[2] = a1;
  v1 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, 0, 0);
  v2 = SecItemDelete(v1);
  if (v1)
    CFRelease(v1);
  return v2;
}

uint64_t SecOTRFullIdentityCreateFromSecKeyRefSOS(uint64_t a1, void *a2, __CFString **a3)
{
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  CFTypeRef v13;
  CFTypeRef v15;

  v5 = SecOTRFullIdentityCreateFromSecKeyRef(a1, a2, a3);
  v15 = 0;
  v12 = SecKeyCopyPersistentRef((uint64_t)a2, &v15, v6, v7, v8, v9, v10, v11);
  if ((_DWORD)v12)
    SecError(v12, a3, CFSTR("failed to find persistent ref for key: %d"), v12);
  v13 = v15;
  *(_QWORD *)(v5 + 32) = v15;
  if (v13)
  {
    *(_BYTE *)(v5 + 40) = 0;
  }
  else
  {
    CFRelease((CFTypeRef)v5);
    return 0;
  }
  return v5;
}

uint64_t SecOTRFullIdentityCreateFromSecKeyRef(uint64_t a1, void *a2, __CFString **a3)
{
  uint64_t Instance;
  const void *v6;
  SecKeyRef v7;

  SecOTRFullIdentityGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  v6 = *(const void **)(Instance + 24);
  if (v6 != a2)
  {
    if (!a2 || (CFRetain(a2), (v6 = *(const void **)(Instance + 24)) != 0))
      CFRelease(v6);
    *(_QWORD *)(Instance + 24) = a2;
  }
  v7 = SecKeyCopyPublicKey((SecKeyRef)a2);
  *(_QWORD *)(Instance + 16) = v7;
  if (!v7)
  {
    SecError(-2070, a3, CFSTR("Failed to extract public key from private key"));
    goto LABEL_10;
  }
  *(_QWORD *)(Instance + 32) = 0;
  *(_BYTE *)(Instance + 40) = 1;
  if (!SecOTRFICachePublicHash(Instance, (CFErrorRef *)a3))
  {
LABEL_10:
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

BOOL SecOTRFICachePublicHash(uint64_t a1, CFErrorRef *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  __int128 v5;

  v3 = SecOTRPublicIdentityCopyFromPrivate(0, a1, a2);
  v4 = v3;
  if (v3)
  {
    v5 = *(_OWORD *)((char *)v3 + 25);
    *(_DWORD *)(a1 + 57) = *(_DWORD *)((char *)v3 + 41);
    *(_OWORD *)(a1 + 41) = v5;
    CFRelease(v3);
  }
  return v4 != 0;
}

uint64_t SecOTRFullIdentityCreateFromBytes(const __CFAllocator *a1, const UInt8 **a2, unint64_t *a3, __CFString **a4)
{
  uint64_t Instance;
  unint64_t v9;
  const UInt8 *v10;
  int v11;
  uint64_t v12;
  CFErrorRef v13;
  SecKeyRef v14;
  CFDataRef v15;
  BOOL v16;
  unint64_t v17;
  CFIndex v18;
  CFNumberRef v19;
  const __CFData *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  const __CFDictionary *v28;
  __SecKey *v29;
  uint64_t v30;
  _QWORD *ECPublicKeyFrom;
  CFDataRef v32;
  uint64_t v34;
  const void *v35;
  const void *v36;
  const void *v37;
  uint64_t v38;
  const void *v39;
  const void *v40;
  const void *v41;
  CFDataRef valuePtr;
  CFErrorRef error;

  SecOTRFullIdentityGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  if (EnsureOTRAlgIDInited_kSignatureAlgID_ONCE != -1)
    dispatch_once(&EnsureOTRAlgIDInited_kSignatureAlgID_ONCE, &__block_literal_global_9984);
  v9 = *a3;
  if (!*a3)
    goto LABEL_28;
  v10 = *a2;
  v11 = **a2;
  switch(v11)
  {
    case 3:
      *a2 = v10 + 1;
      *a3 = v9 - 1;
      v16 = v9 >= 3;
      v17 = v9 - 3;
      if (v16)
      {
        v18 = __rev16(*(unsigned __int16 *)(v10 + 1));
        *a3 = v17;
        *a2 = v10 + 3;
        LODWORD(valuePtr) = 256;
        v19 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
        v20 = CFDataCreate(a1, *a2, v18);
        v28 = CFDictionaryCreateForCFTypes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v21, v22, v23, v24, v25, v26, v27, (uint64_t)CFSTR("type"), (uint64_t)CFSTR("73"));
        error = (CFErrorRef)0xAAAAAAAAAAAAAAAALL;
        v29 = SecKeyCreateWithData(v20, v28, &error);
        if (v28)
          CFRelease(v28);
        if (v20)
          CFRelease(v20);
        if (v19)
          CFRelease(v19);
        if (v29)
        {
          *(_BYTE *)(Instance + 40) = 1;
          *(_QWORD *)(Instance + 24) = v29;
          *(_QWORD *)(Instance + 32) = 0;
          *(_QWORD *)(Instance + 16) = SecKeyCopyPublicKey(v29);
          goto LABEL_23;
        }
        CFRelease(error);
      }
      SecError(-67673, a4, CFSTR("failed to decode v3 otr session: %d"), 4294899623);
      goto LABEL_28;
    case 2:
      *a2 = v10 + 1;
      *a3 = v9 - 1;
      valuePtr = 0;
      error = 0;
      v30 = SecOTRFICreatePrivateKeyReadPersistentRef(a2, a3, (CFTypeRef *)&error, &valuePtr);
      if ((_DWORD)v30)
      {
        v38 = v30;
      }
      else
      {
        ECPublicKeyFrom = CreateECPublicKeyFrom(a2, a3);
        *(_QWORD *)(Instance + 16) = ECPublicKeyFrom;
        if (ECPublicKeyFrom)
        {
          v32 = valuePtr;
          *(_QWORD *)(Instance + 24) = error;
          *(_QWORD *)(Instance + 32) = v32;
          *(_BYTE *)(Instance + 40) = 0;
LABEL_23:
          if (!SecOTRFICachePublicHash(Instance, (CFErrorRef *)a4))
            goto LABEL_29;
          return Instance;
        }
        v38 = 4294965226;
      }
      if (error)
        CFRelease(error);
      if (valuePtr)
        CFRelease(valuePtr);
      v39 = *(const void **)(Instance + 32);
      if (v39)
      {
        *(_QWORD *)(Instance + 32) = 0;
        CFRelease(v39);
      }
      v40 = *(const void **)(Instance + 16);
      if (v40)
      {
        *(_QWORD *)(Instance + 16) = 0;
        CFRelease(v40);
      }
      v41 = *(const void **)(Instance + 24);
      if (v41)
      {
        *(_QWORD *)(Instance + 24) = 0;
        CFRelease(v41);
      }
      SecError(v38, a4, CFSTR("failed to decode v2 otr session: %d"), v38);
      goto LABEL_29;
    case 1:
      *a2 = v10 + 1;
      *a3 = v9 - 1;
      valuePtr = 0;
      error = 0;
      v12 = SecOTRFICreatePrivateKeyReadPersistentRef(a2, a3, (CFTypeRef *)&error, &valuePtr);
      if ((_DWORD)v12)
      {
        v34 = v12;
        v13 = error;
      }
      else
      {
        v13 = error;
        v14 = SecKeyCopyPublicKey(error);
        *(_QWORD *)(Instance + 16) = v14;
        if (v14)
        {
          v15 = valuePtr;
          *(_QWORD *)(Instance + 24) = v13;
          *(_QWORD *)(Instance + 32) = v15;
          goto LABEL_23;
        }
        v34 = 4294965226;
      }
      if (v13)
        CFRelease(v13);
      if (valuePtr)
        CFRelease(valuePtr);
      v35 = *(const void **)(Instance + 16);
      if (v35)
      {
        *(_QWORD *)(Instance + 16) = 0;
        CFRelease(v35);
      }
      v36 = *(const void **)(Instance + 24);
      if (v36)
      {
        *(_QWORD *)(Instance + 24) = 0;
        CFRelease(v36);
      }
      v37 = *(const void **)(Instance + 32);
      if (v37)
      {
        *(_QWORD *)(Instance + 32) = 0;
        CFRelease(v37);
      }
      SecError(v34, a4, CFSTR("failed to decode v1 otr session: %d"), v34);
      goto LABEL_29;
  }
  SecError(-50, a4, CFSTR("unknown otr session version %hhu"), **a2);
LABEL_28:
  if (Instance)
  {
LABEL_29:
    SecOTRFIPurgeFromKeychain(Instance, 0);
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

uint64_t SecOTRFICreatePrivateKeyReadPersistentRef(const UInt8 **a1, unint64_t *a2, CFTypeRef *a3, CFDataRef *a4)
{
  uint64_t v5;
  unint64_t v7;
  const UInt8 *v8;
  unint64_t v9;
  CFDataRef v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  CFDataRef v19;

  if (!a4)
    return 4294967246;
  v5 = 4294967246;
  if (a1)
  {
    if (a2)
    {
      v7 = *a2 - 2;
      if (*a2 >= 2)
      {
        v8 = *a1 + 2;
        v9 = __rev16(*(unsigned __int16 *)*a1);
        *a2 = v7;
        *a1 = v8;
        if (v7 >= v9)
        {
          v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8, v9);
          if (v12)
          {
            v19 = v12;
            v5 = SecKeyFindWithPersistentRef((uint64_t)v12, a3, v13, v14, v15, v16, v17, v18);
            if ((_DWORD)v5)
            {
              CFRelease(v19);
            }
            else
            {
              *a1 += v9;
              *a2 -= v9;
              *a4 = v19;
            }
          }
        }
      }
    }
  }
  return v5;
}

BOOL SecOTRFIPurgeFromKeychain(uint64_t a1, CFErrorRef *a2)
{
  int v3;
  int v4;

  v3 = SecOTRFIPurgeFromKeychainByValue(*(void **)(a1 + 24));
  v4 = v3;
  if (v3)
    SecOTRCreateError(1, v3, CFSTR("OSStatus returned in error code"), 0, a2);
  return v4 == 0;
}

uint64_t SecOTRFullIdentityCreateFromData(const __CFAllocator *a1, CFDataRef theData, __CFString **a3)
{
  const UInt8 *BytePtr;
  CFIndex Length;

  if (!theData)
    return 0;
  Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  return SecOTRFullIdentityCreateFromBytes(a1, &BytePtr, (unint64_t *)&Length, a3);
}

BOOL SecOTRFIPurgeAllFromKeychain(CFErrorRef *a1)
{
  const __CFDictionary *v2;
  char v3;
  int v4;
  OSStatus v5;
  BOOL v6;
  int v7;
  int v8;
  void *values[3];
  void *keys[4];

  keys[3] = *(void **)MEMORY[0x1E0C80C00];
  keys[0] = CFSTR("class");
  keys[1] = CFSTR("kcls");
  keys[2] = CFSTR("labl");
  values[0] = CFSTR("keys");
  values[1] = CFSTR("1");
  values[2] = CFSTR("OTR Signing Key");
  v2 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 3, 0, 0);
  v3 = 0;
  v4 = 500;
  do
  {
    v5 = SecItemDelete(v2);
    v3 |= v5 == 0;
    v6 = v4-- != 0;
  }
  while (!v5 && v4 != 0 && v6);
  if (v2)
    CFRelease(v2);
  if ((v3 & 1) != 0)
    v7 = 0;
  else
    v7 = -25300;
  if (v5 == -25300)
    v8 = v7;
  else
    v8 = v5;
  if (v8)
    SecOTRCreateError(1, v8, CFSTR("OSStatus returned in error code"), 0, a1);
  return v8 == 0;
}

BOOL SecOTRFIAppendSerialization(uint64_t a1, CFDataRef theData, CFErrorRef *a3)
{
  CFIndex Length;
  const __CFData *v7;
  const __CFData *v8;
  int v9;
  CFErrorRef v11;
  UInt8 bytes;
  UInt8 v13;

  if (!*(_BYTE *)(a1 + 40))
  {
    v13 = 2;
    Length = CFDataGetLength(theData);
    CFDataAppendBytes(theData, &v13, 1);
    appendSizeAndData(*(const __CFData **)(a1 + 32), theData);
    if (!appendPublicOctetsAndSize(*(_QWORD *)(a1 + 16), theData))
      goto LABEL_5;
LABEL_7:
    CFDataSetLength(theData, Length);
    v9 = -50;
    SecOTRCreateError(1, -50, CFSTR("OSStatus returned in error code"), 0, a3);
    return v9 == 0;
  }
  bytes = 3;
  Length = CFDataGetLength(theData);
  CFDataAppendBytes(theData, &bytes, 1);
  v11 = 0;
  v7 = SecKeyCopyExternalRepresentation(*(SecKeyRef *)(a1 + 24), &v11);
  if (!v7)
    goto LABEL_7;
  v8 = v7;
  appendSizeAndData(v7, theData);
  CFRelease(v8);
LABEL_5:
  v9 = 0;
  return v9 == 0;
}

uint64_t AES_CTR_HighHalf_Transform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _BYTE v7[8];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v7[0] = HIBYTE(a3);
  v7[1] = BYTE6(a3);
  v7[2] = BYTE5(a3);
  v7[3] = BYTE4(a3);
  v7[4] = BYTE3(a3);
  v7[5] = BYTE2(a3);
  v7[6] = BYTE1(a3);
  v7[7] = a3;
  v8 = 0;
  return AES_CTR_Transform(a1, a2, (uint64_t)v7, a4, a5, a6);
}

uint64_t AES_CTR_Transform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  char *v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  v12 = ccaes_ctr_crypt_mode();
  MEMORY[0x1E0C80A78](v12);
  v14 = (char *)v18 - v13;
  if (v15 >= 0x10)
  {
    v16 = (_QWORD *)((char *)v18 - v13);
    do
    {
      *v16 = 0xAAAAAAAAAAAAAAAALL;
      v16[1] = 0xAAAAAAAAAAAAAAAALL;
      v16 += 2;
      v13 -= 16;
    }
    while (v13);
  }
  (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t))(v12 + 24))(v12, v14, a1, a2, a3);
  return (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v12 + 40))(v14, a4, a5, a6);
}

uint64_t AES_CTR_IV0_Transform(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return AES_CTR_Transform(a1, a2, (uint64_t)&kIVZero, a3, a4, a5);
}

void DeriveOTR256BitsFromS(UInt8 a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  HashMPIWithPrefix(a1, a2, a3, a5);
}

void HashMPIWithPrefix(UInt8 a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4)
{
  __CFData *Mutable;
  uint64_t v6;
  UInt8 *MutableBytePtr;
  CFIndex Length;
  UInt8 bytes;
  UInt8 v10[4];

  bytes = a1;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFDataAppendBytes(Mutable, &bytes, 1);
  v6 = ccn_write_uint_size();
  *(_DWORD *)v10 = bswap32(v6);
  CFDataAppendBytes(Mutable, v10, 4);
  CFDataGetLength(Mutable);
  CFDataIncreaseLength(Mutable, v6);
  CFDataGetMutableBytePtr(Mutable);
  ccn_write_uint();
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  Length = CFDataGetLength(Mutable);
  CC_SHA256(MutableBytePtr, Length, a4);
  bzero(MutableBytePtr, Length);
  if (Mutable)
    CFRelease(Mutable);
}

void DeriveOTR128BitPairFromS(UInt8 a1, uint64_t a2, uint64_t a3, unint64_t a4, void *a5, unint64_t a6, void *a7)
{
  __int128 v11;
  size_t v12;
  size_t v13;
  _OWORD v14[2];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[0] = v11;
  v14[1] = v11;
  HashMPIWithPrefix(a1, a2, a3, (unsigned __int8 *)v14);
  if (a5)
  {
    if (a4 >= 0x10)
      v12 = 16;
    else
      v12 = a4;
    memcpy(a5, v14, v12);
  }
  if (a7)
  {
    if (a6 >= 0x10)
      v13 = 16;
    else
      v13 = a6;
    memcpy(a7, v14, v13);
  }
}

void *DeriveOTR64BitsFromS(UInt8 a1, uint64_t a2, uint64_t a3, unint64_t a4, void *a5)
{
  __int128 v7;
  size_t v8;
  _OWORD v10[2];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[0] = v7;
  v10[1] = v7;
  HashMPIWithPrefix(a1, a2, a3, (unsigned __int8 *)v10);
  if (a4 >= 0x10)
    v8 = 16;
  else
    v8 = a4;
  return memcpy(a5, v10, v8);
}

void SecOTRAppendDHMessage(uint64_t a1, __CFData *a2)
{
  CFMutableDataRef Mutable;
  __CFData *v5;
  CFIndex Length;
  CFIndex v7;
  const UInt8 *BytePtr;
  CFIndex v9;
  UInt8 *MutableBytePtr;
  UInt8 bytes[2];
  UInt8 v12;
  UInt8 v13[4];
  UInt8 v14[4];

  if (a1)
  {
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
    if (Mutable)
    {
      v5 = Mutable;
      *(_WORD *)bytes = 512;
      CFDataAppendBytes(a2, bytes, 2);
      v12 = 2;
      CFDataAppendBytes(a2, &v12, 1);
      SecFDHKAppendPublicSerialization(*(_QWORD *)(a1 + 80), v5);
      Length = CFDataGetLength(v5);
      if (Length)
      {
        v7 = Length;
        BytePtr = CFDataGetBytePtr(v5);
        *(_DWORD *)v13 = bswap32(v7);
        CFDataAppendBytes(a2, v13, 4);
        v9 = CFDataGetLength(a2);
        CFDataIncreaseLength(a2, v7);
        MutableBytePtr = CFDataGetMutableBytePtr(a2);
        AES_CTR_Transform(16, a1 + 40, (uint64_t)&kIVZero, v7, (uint64_t)BytePtr, (uint64_t)&MutableBytePtr[v9]);
        *(_DWORD *)v14 = 0x20000000;
        CFDataAppendBytes(a2, v14, 4);
        CFDataGetLength(a2);
        CFDataIncreaseLength(a2, 32);
        CFDataGetMutableBytePtr(a2);
        ccsha256_di();
        ccdigest();
      }
      CFRelease(v5);
    }
  }
}

uint64_t SecOTRAppendDHKeyMessage(uint64_t a1, CFMutableDataRef theData)
{
  UInt8 bytes[2];
  UInt8 v6;

  *(_WORD *)bytes = 512;
  CFDataAppendBytes(theData, bytes, 2);
  v6 = 10;
  CFDataAppendBytes(theData, &v6, 1);
  return SecFDHKAppendPublicSerialization(*(_QWORD *)(a1 + 80), theData);
}

void SecOTRAppendRevealSignatureMessage(uint64_t a1, CFMutableDataRef theData)
{
  CFIndex Length;
  UInt8 bytes[2];
  UInt8 v6;
  UInt8 v7[4];

  *(_WORD *)bytes = 512;
  CFDataAppendBytes(theData, bytes, 2);
  v6 = 17;
  CFDataAppendBytes(theData, &v6, 1);
  *(_DWORD *)v7 = 0x10000000;
  CFDataAppendBytes(theData, v7, 4);
  Length = CFDataGetLength(theData);
  CFDataIncreaseLength(theData, 16);
  *(_OWORD *)&CFDataGetMutableBytePtr(theData)[Length] = *(_OWORD *)(a1 + 40);
  AppendMACedEncryptedSignature(a1, 0, theData);
}

void AppendMACedEncryptedSignature(uint64_t a1, int a2, const __CFData *a3)
{
  __int128 v5;
  const __CFAllocator *v6;
  const __CFData *Mutable;
  __CFData *v8;
  const __CFData *v9;
  CFIndex Length;
  _QWORD *v11;
  const __CFData *v12;
  CFIndex v13;
  const UInt8 *BytePtr;
  __int128 v15;
  UInt8 v16;
  uint64_t v17;
  uint64_t Size;
  CFIndex v19;
  const UInt8 *v20;
  CFIndex v21;
  UInt8 *v22;
  uint64_t v23;
  CFIndex v24;
  const UInt8 *v25;
  CFIndex v26;
  CFIndex v27;
  UInt8 *v28;
  __int128 v29;
  const UInt8 *v30;
  __int128 v31;
  UInt8 v32;
  _OWORD v34[12];
  __int128 v35;
  UInt8 bytes[16];
  __int128 v37;
  uint64_t v38;
  CFRange v39;
  CFRange v40;

  v38 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v34[10] = v5;
  v34[11] = v5;
  v34[8] = v5;
  v34[9] = v5;
  v34[6] = v5;
  v34[7] = v5;
  v34[4] = v5;
  v34[5] = v5;
  v34[2] = v5;
  v34[3] = v5;
  v34[0] = v5;
  v34[1] = v5;
  ccn_zero();
  *(_QWORD *)bytes = 192;
  ccec_compute_key();
  CFDataGetLength(a3);
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v8 = CFDataCreateMutable(v6, 0);
  v9 = CFDataCreateMutable(v6, 0);
  SecFDHKAppendPublicSerialization(*(_QWORD *)(a1 + 80), v8);
  AppendECPublicKeyAsDATA(v8);
  Length = CFDataGetLength(v8);
  v11 = SecOTRPublicIdentityCopyFromPrivate((uint64_t)v6, *(_QWORD *)(a1 + 24), 0);
  *(_WORD *)bytes = 240;
  CFDataAppendBytes(v8, bytes, 2);
  v12 = CFDataCreateMutable(v6, 0);
  SecOTRPIAppendSerialization((uint64_t)v11, v12, 0);
  v13 = CFDataGetLength(v12);
  BytePtr = CFDataGetBytePtr(v12);
  *(_DWORD *)bytes = bswap32(v13);
  CFDataAppendBytes(v8, bytes, 4);
  CFDataAppendBytes(v8, BytePtr, v13);
  if (v12)
    CFRelease(v12);
  if (v11)
    CFRelease(v11);
  *(_DWORD *)bytes = bswap32(*(_DWORD *)(a1 + 72));
  CFDataAppendBytes(v8, bytes, 4);
  CFDataGetLength(v8);
  CFDataGetBytePtr(v8);
  *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)bytes = v15;
  v37 = v15;
  if (a2)
    v16 = 4;
  else
    v16 = 2;
  HashMPIWithPrefix(v16, 24, (uint64_t)v34, bytes);
  CFDataGetLength(v9);
  CFDataIncreaseLength(v9, 32);
  CFDataGetMutableBytePtr(v9);
  ccsha256_di();
  cchmac();
  v39.location = 0;
  v39.length = Length;
  CFDataDeleteBytes(v8, v39);
  v17 = *(_QWORD *)(a1 + 24);
  Size = SecKeyGetSize(*(_QWORD *)(v17 + 16), 1);
  v19 = CFDataGetLength(v9);
  v20 = CFDataGetBytePtr(v9);
  v21 = CFDataGetLength(Mutable);
  if ((Size & 0x8000000000000000) == 0)
  {
    CFDataIncreaseLength(Mutable, Size + 1);
    v22 = &CFDataGetMutableBytePtr(Mutable)[v21];
    *(_QWORD *)bytes = Size;
    if (!SecKeyDigestAndSign(*(_QWORD *)(v17 + 24), (const SecAsn1Oid *)kOTRSignatureAlgIDPtr, v20, v19, v22 + 1, (CFIndex *)bytes))
    {
      v23 = *(_QWORD *)bytes;
      if (*(_QWORD *)bytes <= 0xFFuLL)
      {
        *v22 = bytes[0];
        v21 += v23 + 1;
      }
    }
  }
  CFDataSetLength(Mutable, v21);
  if (v9)
    CFRelease(v9);
  v24 = CFDataGetLength(Mutable);
  v25 = CFDataGetBytePtr(Mutable);
  *(_DWORD *)bytes = bswap32(v24);
  CFDataAppendBytes(v8, bytes, 4);
  CFDataAppendBytes(v8, v25, v24);
  if (Mutable)
    CFRelease(Mutable);
  v26 = CFDataGetLength(v8);
  CFDataGetLength(a3);
  *(_DWORD *)bytes = bswap32(v26);
  CFDataAppendBytes(a3, bytes, 4);
  v27 = CFDataGetLength(a3);
  CFDataIncreaseLength(a3, v26);
  v28 = &CFDataGetMutableBytePtr(a3)[v27];
  *(_QWORD *)&v35 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v35 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v29 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)bytes = v29;
  v37 = v29;
  HashMPIWithPrefix(1u, 24, (uint64_t)v34, bytes);
  v35 = *(_OWORD *)bytes;
  v30 = CFDataGetBytePtr(v8);
  AES_CTR_Transform(16, (uint64_t)&v35, (uint64_t)&kIVZero, v26, (uint64_t)v30, (uint64_t)v28);
  v35 = 0uLL;
  if (v8)
    CFRelease(v8);
  CFDataGetMutableBytePtr(a3);
  CFDataGetLength(a3);
  *(_QWORD *)&v31 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)bytes = v31;
  v37 = v31;
  if (a2)
    v32 = 5;
  else
    v32 = 3;
  HashMPIWithPrefix(v32, 24, (uint64_t)v34, bytes);
  CFDataGetLength(a3);
  CFDataIncreaseLength(a3, 32);
  CFDataGetMutableBytePtr(a3);
  ccsha256_di();
  cchmac();
  v40.location = CFDataGetLength(a3) - 12;
  v40.length = 12;
  CFDataDeleteBytes(a3, v40);
}

void SecOTRAppendSignatureMessage(uint64_t a1, CFMutableDataRef theData)
{
  UInt8 bytes[2];
  UInt8 v5;

  *(_WORD *)bytes = 512;
  CFDataAppendBytes(theData, bytes, 2);
  v5 = 18;
  CFDataAppendBytes(theData, &v5, 1);
  AppendMACedEncryptedSignature(a1, 1, theData);
}

uint64_t SecOTRPublicIdentityGetTypeID()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecOTRPublicIdentityGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_10012;
  block[4] = &SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDSingleton;
  if (SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDOnce != -1)
    dispatch_once(&SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDOnce, block);
  return SecOTRPublicIdentityGetTypeID_sSecOTRPublicIdentityGetTypeIDSingleton;
}

void SecOTRPublicIdentityDestroy(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(_QWORD *)(a1 + 16) = 0;
    CFRelease(v2);
  }
}

CFStringRef SecOTRPublicIdentityCopyFormatDescription(unsigned __int8 *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<SecOTRPublicIdentity: %p %02x%02x%02x%02x%02x%02x%02x%02x>"), a1, a1[25], a1[26], a1[27], a1[28], a1[29], a1[30], a1[31], a1[32]);
}

CFStringRef SecOTRPublicIdentityCopyDescription(unsigned __int8 *a1)
{
  SecGetDebugDescriptionFormatOptions();
  return SecOTRPublicIdentityCopyFormatDescription(a1);
}

uint64_t SecOTRAdvertiseHashes(uint64_t result)
{
  sAdvertiseHashes = result;
  return result;
}

_QWORD *SecOTRPublicIdentityCopyFromPrivate(uint64_t a1, uint64_t a2, CFErrorRef *a3)
{
  _QWORD *Instance;
  const void *v6;

  SecOTRPublicIdentityGetTypeID();
  Instance = (_QWORD *)_CFRuntimeCreateInstance();
  if (EnsureOTRAlgIDInited_kSignatureAlgID_ONCE != -1)
    dispatch_once(&EnsureOTRAlgIDInited_kSignatureAlgID_ONCE, &__block_literal_global_9984);
  v6 = *(const void **)(a2 + 16);
  Instance[2] = v6;
  CFRetain(v6);
  if ((SecOTRPICacheHash((uint64_t)Instance, a3) & 1) == 0)
  {
    CFRelease(Instance);
    return 0;
  }
  return Instance;
}

uint64_t SecOTRPICacheHash(uint64_t a1, CFErrorRef *a2)
{
  const __CFData *Mutable;
  uint64_t v5;

  Mutable = CFDataCreateMutable(0, 0);
  v5 = SecOTRPIAppendSerialization(a1, Mutable, a2);
  if ((_DWORD)v5)
  {
    CFDataGetBytePtr(Mutable);
    CFDataGetLength(Mutable);
    CCDigest();
  }
  if (Mutable)
    CFRelease(Mutable);
  return v5;
}

uint64_t SecOTRPIAppendSerialization(uint64_t a1, CFDataRef theData, CFErrorRef *a3)
{
  CFIndex Length;
  __CFData *Mutable;
  CFIndex v8;
  UInt8 *v9;

  Length = CFDataGetLength(theData);
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (appendPublicOctetsAndSize(*(_QWORD *)(a1 + 16), Mutable))
    goto LABEL_10;
  CFDataGetLength(Mutable);
  ccder_sizeof();
  if (sAdvertiseHashes)
    ccder_sizeof();
  v8 = ccder_sizeof();
  CFDataIncreaseLength(theData, v8);
  v9 = &CFDataGetMutableBytePtr(theData)[Length];
  CFDataGetLength(Mutable);
  CFDataGetBytePtr(Mutable);
  if (sAdvertiseHashes)
    ccder_encode_implicit_raw_octet_string();
  ccder_encode_implicit_raw_octet_string();
  if ((UInt8 *)ccder_encode_constructed_tl() != v9)
  {
LABEL_10:
    if (Mutable)
      CFRelease(Mutable);
    CFDataSetLength(theData, Length);
    SecOTRCreateError(0, -10, CFSTR("Unable to create public key bytes"), 0, a3);
    return 0;
  }
  else
  {
    if (Mutable)
      CFRelease(Mutable);
    return 1;
  }
}

CFTypeRef *SecOTRPublicIdentityCreateFromSecKeyRef(uint64_t a1, const void *a2, CFErrorRef *a3)
{
  CFTypeRef *Instance;

  SecOTRPublicIdentityGetTypeID();
  Instance = (CFTypeRef *)_CFRuntimeCreateInstance();
  Instance[2] = a2;
  CFRetain(a2);
  if ((SecOTRPICacheHash((uint64_t)Instance, a3) & 1) == 0)
  {
    CFRelease(Instance[2]);
    CFRelease(Instance);
    return 0;
  }
  return Instance;
}

uint64_t SecOTRPublicIdentityCreateFromBytes(uint64_t a1, uint64_t *a2, _QWORD *a3, CFErrorRef *a4)
{
  uint64_t Instance;
  uint64_t v8;
  _QWORD *v9;
  BOOL v10;
  int v11;
  _QWORD *v12;
  CFTypeRef v14;
  uint64_t v15;
  CFTypeRef cf;
  unint64_t v17;
  const UInt8 *v18;

  cf = 0;
  SecOTRPublicIdentityGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  if (EnsureOTRAlgIDInited_kSignatureAlgID_ONCE != -1)
    dispatch_once(&EnsureOTRAlgIDInited_kSignatureAlgID_ONCE, &__block_literal_global_9984);
  v15 = *a2 + *a3;
  if (!ccder_decode_sequence_tl())
  {
    SecOTRCreateError(0, -9, CFSTR("Error creating public identity from bytes"), 0, a4);
    if (!Instance)
      return Instance;
    goto LABEL_24;
  }
  v8 = *a2;
  v17 = 0xAAAAAAAAAAAAAAAALL;
  v18 = (const UInt8 *)ccder_decode_tl();
  v9 = CreateECPublicKeyFrom(&v18, &v17);
  if (v9)
    v10 = v17 == 0;
  else
    v10 = 0;
  v11 = v10;
  if (v9 && (v11 & 1) == 0)
  {
    CFRelease(v9);
    v14 = 0;
    *(_QWORD *)(Instance + 16) = 0;
LABEL_23:
    SecOTRCreateError(0, -9, CFSTR("Error creating public identity from bytes"), v14, a4);
LABEL_24:
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  if (v11)
    v12 = v9;
  else
    v12 = 0;
  *(_QWORD *)(Instance + 16) = v12;
  if (!v12)
  {
    v14 = 0;
    goto LABEL_23;
  }
  *(_BYTE *)(Instance + 24) = ccder_decode_tl() != 0;
  if ((SecOTRPICacheHash(Instance, (CFErrorRef *)&cf) & 1) == 0)
  {
    v14 = cf;
    goto LABEL_23;
  }
  *a2 += v15 - v8;
  *a3 -= v15 - v8;
  return Instance;
}

uint64_t SecOTRPublicIdentityCreateFromData(uint64_t a1, CFDataRef theData, CFErrorRef *a3)
{
  const UInt8 *BytePtr;
  CFIndex Length;

  if (!theData)
    return 0;
  Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  return SecOTRPublicIdentityCreateFromBytes(a1, (uint64_t *)&BytePtr, &Length, a3);
}

uint64_t SecOTRPIRecreateSignature(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *v8;
  uint64_t v9;
  size_t v10;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t result;
  _QWORD v15[4];

  v15[3] = *MEMORY[0x1E0C80C00];
  v8 = (uint64_t *)MEMORY[0x18D76FFBC]();
  v9 = *v8;
  v10 = 8 * *v8;
  MEMORY[0x1E0C80A78](v8);
  v11 = (v10 + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v9)
  {
    v12 = memset((char *)v15 - v11, 170, v10);
    MEMORY[0x1E0C80A78](v12);
    memset((char *)v15 - v11, 170, v10);
  }
  v15[1] = a1 + a2;
  ccder_decode_sequence_tl();
  mp_decode_forced_uint();
  mp_decode_forced_uint();
  v13 = *a3 + *a4;
  ccder_encode_integer();
  ccder_encode_integer();
  result = ccder_encode_constructed_tl();
  *a3 = result;
  *a4 = (v13 - result) & ~((v13 - result) >> 63);
  return result;
}

uint64_t mp_decode_forced_uint()
{
  uint64_t result;
  uint64_t v1;

  result = ccder_decode_tl();
  if (result)
  {
    v1 = result;
    if ((ccn_read_uint() & 0x80000000) != 0)
      return 0;
    else
      return v1 - 0x5555555555555556;
  }
  return result;
}

void sub_18A9F9E00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_18A9FA1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v12 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__10135(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__10136(uint64_t a1)
{

}

uint64_t SecRemoteKeyInit(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 24) = a2;
  return 0;
}

void SecRemoteKeyDestroy(uint64_t a1)
{
  id v1;

  v1 = *(id *)(a1 + 24);
  objc_msgSend(v1, "invalidate");

}

uint64_t SecRemoteKeyBlockSize(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  +[SecKeyProxy targetForKey:error:](SecKeyProxy, "targetForKey:error:", a1, 0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __SecRemoteKeyBlockSize_block_invoke;
  v4[3] = &unk_1E1FD85B0;
  v4[4] = &v5;
  objc_msgSend(v1, "getBlockSizeWithReply:", v4);

  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18A9FA520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SecRemoteKeyCopyAttributeDictionary(uint64_t a1)
{
  void *v1;
  const __CFData *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  __CFString *v7;
  _QWORD v8[5];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t);
  void (*v13)(uint64_t);
  id v14;

  v9 = 0;
  v10 = &v9;
  v11 = 0x3032000000;
  v12 = __Block_byref_object_copy__10135;
  v13 = __Block_byref_object_dispose__10136;
  v14 = 0;
  +[SecKeyProxy targetForKey:error:](SecKeyProxy, "targetForKey:error:", a1, 0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = __SecRemoteKeyCopyAttributeDictionary_block_invoke;
  v8[3] = &unk_1E1FD85D8;
  v8[4] = &v9;
  objc_msgSend(v1, "getAttributesWithReply:", v8);

  objc_msgSend((id)v10[5], "objectForKeyedSubscript:", CFSTR("accc"));
  v2 = (const __CFData *)objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    v7 = 0;
    v3 = SecAccessControlCreateFromData((const __CFAllocator *)*MEMORY[0x1E0C9AE00], v2, &v7);
    v4 = (void *)v10[5];
    if (v3)
      objc_msgSend(v4, "setObject:forKeyedSubscript:", v3, CFSTR("accc"));
    else
      objc_msgSend(v4, "removeObjectForKey:", CFSTR("accc"));

  }
  v5 = objc_msgSend((id)v10[5], "copy");

  _Block_object_dispose(&v9, 8);
  return v5;
}

void sub_18A9FA680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id SecRemoteKeyCopyDescription(uint64_t a1)
{
  void *v1;
  id v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t);
  void (*v9)(uint64_t);
  id v10;

  v5 = 0;
  v6 = &v5;
  v7 = 0x3032000000;
  v8 = __Block_byref_object_copy__10135;
  v9 = __Block_byref_object_dispose__10136;
  v10 = 0;
  +[SecKeyProxy targetForKey:error:](SecKeyProxy, "targetForKey:error:", a1, 0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __SecRemoteKeyCopyDescription_block_invoke;
  v4[3] = &unk_1E1FD8600;
  v4[4] = &v5;
  objc_msgSend(v1, "getDescriptionWithReply:", v4);

  v2 = (id)v6[5];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_18A9FA76C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SecRemoteKeyGetAlgorithmID(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2020000000;
  v8 = 0;
  +[SecKeyProxy targetForKey:error:](SecKeyProxy, "targetForKey:error:", a1, 0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __SecRemoteKeyGetAlgorithmID_block_invoke;
  v4[3] = &unk_1E1FD8628;
  v4[4] = &v5;
  objc_msgSend(v1, "getAlgorithmIDWithReply:", v4);

  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_18A9FA82C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id SecRemoteKeyCopyExternalRepresentation(uint64_t a1, _QWORD *a2)
{
  void *v3;
  uint64_t *v4;
  void *v5;
  id v6;
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t);
  void (*v13)(uint64_t);
  id v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  void (*v19)(uint64_t);
  id v20;

  v15 = 0;
  v16 = &v15;
  v17 = 0x3032000000;
  v18 = __Block_byref_object_copy__10135;
  v19 = __Block_byref_object_dispose__10136;
  v20 = 0;
  v9 = 0;
  v10 = &v9;
  v11 = 0x3032000000;
  v12 = __Block_byref_object_copy__10135;
  v13 = __Block_byref_object_dispose__10136;
  v14 = 0;
  +[SecKeyProxy targetForKey:error:](SecKeyProxy, "targetForKey:error:", a1, a2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 3221225472;
  v8[2] = __SecRemoteKeyCopyExternalRepresentation_block_invoke;
  v8[3] = &unk_1E1FD8650;
  v8[4] = &v15;
  v8[5] = &v9;
  objc_msgSend(v3, "getExternalRepresentationWithReply:", v8);

  v4 = v16;
  v5 = (void *)v16[5];
  if (a2 && !v5)
  {
    *a2 = (id)v10[5];
    v5 = (void *)v4[5];
  }
  v6 = v5;
  _Block_object_dispose(&v9, 8);

  _Block_object_dispose(&v15, 8);
  return v6;
}

void sub_18A9FA960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 80), 8);
  _Unwind_Resume(a1);
}

id SecRemoteKeyCopyPublicKey(uint64_t a1)
{
  void *v1;
  id v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t);
  void (*v9)(uint64_t);
  id v10;

  v5 = 0;
  v6 = &v5;
  v7 = 0x3032000000;
  v8 = __Block_byref_object_copy__10135;
  v9 = __Block_byref_object_dispose__10136;
  v10 = 0;
  +[SecKeyProxy targetForKey:error:](SecKeyProxy, "targetForKey:error:", a1, 0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 3221225472;
  v4[2] = __SecRemoteKeyCopyPublicKey_block_invoke;
  v4[3] = &unk_1E1FD8678;
  v4[4] = &v5;
  objc_msgSend(v1, "getPublicKey:", v4);

  v2 = (id)v6[5];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_18A9FAA50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id SecRemoteKeyCopyOperationResult(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v15;
  void *v16;
  void *v17;
  id v18;
  _QWORD v20[6];
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t);
  id v26;

  v15 = (void *)objc_msgSend(MEMORY[0x1E0C9AA60], "mutableCopy");
  v16 = v15;
  if (a6)
  {
    objc_msgSend(v15, "addObject:", a6);
    if (a7)
      objc_msgSend(v16, "addObject:", a7);
  }
  v21 = 0;
  v22 = &v21;
  v23 = 0x3032000000;
  v24 = __Block_byref_object_copy__10135;
  v25 = __Block_byref_object_dispose__10136;
  v26 = 0;
  +[SecKeyProxy targetForKey:error:](SecKeyProxy, "targetForKey:error:", a1, a8);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v20[0] = MEMORY[0x1E0C809B0];
  v20[1] = 3221225472;
  v20[2] = __SecRemoteKeyCopyOperationResult_block_invoke;
  v20[3] = &unk_1E1FD86A0;
  v20[4] = &v21;
  v20[5] = a8;
  objc_msgSend(v17, "performOperation:mode:algorithm:parameters:reply:", a2, a5, a3, v16, v20);

  v18 = (id)v22[5];
  _Block_object_dispose(&v21, 8);

  return v18;
}

void sub_18A9FABAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t SecOTRSessionGetTypeID()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecOTRSessionGetTypeID_block_invoke;
  block[3] = &__block_descriptor_tmp_10198;
  block[4] = &SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDSingleton;
  if (SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDOnce != -1)
    dispatch_once(&SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDOnce, block);
  return SecOTRSessionGetTypeID_sSecOTRSessionGetTypeIDSingleton;
}

void SecOTRSessionDestroy(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  const void *v9;
  const void *v10;

  v2 = *(const void **)(a1 + 56);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = 0;
    CFRelease(v2);
  }
  v3 = *(const void **)(a1 + 64);
  if (v3)
  {
    *(_QWORD *)(a1 + 64) = 0;
    CFRelease(v3);
  }
  v4 = *(const void **)(a1 + 24);
  if (v4)
  {
    *(_QWORD *)(a1 + 24) = 0;
    CFRelease(v4);
  }
  v5 = *(const void **)(a1 + 80);
  if (v5)
  {
    *(_QWORD *)(a1 + 80) = 0;
    CFRelease(v5);
  }
  v6 = *(const void **)(a1 + 88);
  if (v6)
  {
    *(_QWORD *)(a1 + 88) = 0;
    CFRelease(v6);
  }
  v7 = *(const void **)(a1 + 32);
  if (v7)
  {
    *(_QWORD *)(a1 + 32) = 0;
    CFRelease(v7);
  }
  v8 = *(const void **)(a1 + 112);
  if (v8)
  {
    *(_QWORD *)(a1 + 112) = 0;
    CFRelease(v8);
  }
  v9 = *(const void **)(a1 + 104);
  if (v9)
  {
    *(_QWORD *)(a1 + 104) = 0;
    CFRelease(v9);
  }
  v10 = *(const void **)(a1 + 120);
  if (v10)
  {
    *(_QWORD *)(a1 + 120) = 0;
    CFRelease(v10);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 128));
}

CFStringRef SecOTRSessionCopyFormatDescription(uint64_t a1)
{
  double Current;
  uint64_t v3;
  const char *v4;
  double v5;
  const char *v6;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  const char *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  const char *v17;
  const char *v18;

  Current = CFAbsoluteTimeGetCurrent();
  v3 = *(unsigned int *)(a1 + 16);
  if (v3 > 4)
    v4 = "InvalidState";
  else
    v4 = off_1E1FD89F0[v3];
  v5 = *(double *)(a1 + 672);
  v6 = "e";
  if (v5 != 0.0 && v5 > Current)
    v6 = "E";
  v8 = "S";
  if (!*(_BYTE *)(a1 + 664))
    v8 = "s";
  v9 = "R";
  v10 = "M";
  if (!*(_BYTE *)(a1 + 681))
    v9 = "r";
  if (!*(_BYTE *)(a1 + 680))
    v10 = "m";
  v11 = "t";
  if (*(_QWORD *)(a1 + 112))
    v11 = "T";
  if (*(_QWORD *)(a1 + 104))
    v12 = "P";
  else
    v12 = "p";
  if (*(_QWORD *)(a1 + 64))
    v13 = "K";
  else
    v13 = "k";
  if (*(_QWORD *)(a1 + 56))
    v14 = "D";
  else
    v14 = "d";
  if (*(_QWORD *)(a1 + 32))
    v15 = "P";
  else
    v15 = "p";
  if (*(_QWORD *)(a1 + 24))
    v16 = "F";
  else
    v16 = "f";
  if (*(_BYTE *)(a1 + 650))
    v17 = "I";
  else
    v17 = "i";
  if (*(_BYTE *)(a1 + 649))
    v18 = "C";
  else
    v18 = "c";
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<%s %s %s %s%s%s%s %d:%d %s%s %llu %s%s%s%s>"), Current, v4, v18, v17, v16, v15, v14, v13, *(unsigned int *)(a1 + 72), *(unsigned int *)(a1 + 96), v12, v11, *(_QWORD *)(a1 + 656), v10, v9, v8,
           v6);
}

CFStringRef SecOTRSessionCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();
  return SecOTRSessionCopyFormatDescription(a1);
}

const char *SecOTRPacketTypeString(const __CFData *a1)
{
  int v1;

  if (!a1)
    return "NoMessage";
  v1 = SecOTRSGetMessageType(a1);
  if (v1 > 0x1F)
  {
    if (v1 <= 47)
    {
      if (v1 == 32)
        return "kEvenCompactDatamessage (0x20)";
      if (v1 == 33)
        return "kOddCompactDataMessage (0x21)";
    }
    else
    {
      switch(v1)
      {
        case 48:
          return "kEvenCompactDatamessage (0x30)";
        case 49:
          return "kOddCompactDataMessage (0x31)";
        case 255:
          return "InvalidMessage (0xFF)";
      }
    }
  }
  else if (v1 <= 9)
  {
    if (v1 == 2)
      return "DHMessage (0x02)";
    if (v1 == 3)
      return "DataMessage (0x03)";
  }
  else
  {
    switch(v1)
    {
      case 10:
        return "DHKeyMessage (0x0A)";
      case 17:
        return "RevealSignatureMessage (0x11)";
      case 18:
        return "SignatureMessage (0x12)";
    }
  }
  return "UnknownMessage";
}

uint64_t SecOTRSGetMessageType(const __CFData *a1)
{
  const __CFData *v1;
  const UInt8 *BytePtr;
  uint64_t v3;

  v1 = (const __CFData *)SecOTRCopyIncomingBytes(a1);
  BytePtr = CFDataGetBytePtr(v1);
  if ((unint64_t)CFDataGetLength(v1) > 2 && __rev16(*(unsigned __int16 *)BytePtr) == 2)
  {
    v3 = BytePtr[2];
  }
  else
  {
    v3 = *CFDataGetBytePtr(v1);
    if (v3 > 0x31 || ((1 << v3) & 0x3000300000000) == 0)
      v3 = 255;
  }
  if (v1)
    CFRelease(v1);
  return v3;
}

uint64_t SecOTRSGetKeyID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t SecOTRSGetTheirKeyID(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

void SecOTRSessionReset(dispatch_queue_t *context)
{
  dispatch_sync_f(context[16], context, (dispatch_function_t)SecOTRSessionResetInternal);
}

double SecOTRSessionResetInternal(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;
  const void *v7;
  const void *v8;
  CFMutableDataRef Mutable;
  double result;
  _OWORD *v11;

  *(_DWORD *)(a1 + 16) = 0;
  v2 = *(const void **)(a1 + 56);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = 0;
    CFRelease(v2);
  }
  v3 = *(const void **)(a1 + 64);
  if (v3)
  {
    *(_QWORD *)(a1 + 64) = 0;
    CFRelease(v3);
  }
  *(_DWORD *)(a1 + 72) = 0;
  v4 = *(const void **)(a1 + 80);
  if (v4)
  {
    *(_QWORD *)(a1 + 80) = 0;
    CFRelease(v4);
  }
  v5 = *(const void **)(a1 + 88);
  if (v5)
  {
    *(_QWORD *)(a1 + 88) = 0;
    CFRelease(v5);
  }
  *(_DWORD *)(a1 + 96) = 0;
  v6 = *(const void **)(a1 + 112);
  if (v6)
  {
    *(_QWORD *)(a1 + 112) = 0;
    CFRelease(v6);
  }
  v7 = *(const void **)(a1 + 104);
  if (v7)
  {
    *(_QWORD *)(a1 + 104) = 0;
    CFRelease(v7);
  }
  v8 = *(const void **)(a1 + 120);
  if (v8)
  {
    *(_QWORD *)(a1 + 120) = 0;
    CFRelease(v8);
  }
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  result = 0.0;
  *(_OWORD *)(a1 + 136) = 0u;
  v11 = (_OWORD *)(a1 + 136);
  *((_QWORD *)v11 - 2) = Mutable;
  v11[1] = 0u;
  v11[2] = 0u;
  v11[3] = 0u;
  v11[4] = 0u;
  v11[5] = 0u;
  v11[6] = 0u;
  v11[7] = 0u;
  v11[8] = 0u;
  v11[9] = 0u;
  v11[10] = 0u;
  v11[11] = 0u;
  v11[12] = 0u;
  v11[13] = 0u;
  v11[14] = 0u;
  v11[15] = 0u;
  v11[16] = 0u;
  v11[17] = 0u;
  v11[18] = 0u;
  v11[19] = 0u;
  v11[20] = 0u;
  v11[21] = 0u;
  v11[22] = 0u;
  v11[23] = 0u;
  v11[24] = 0u;
  v11[25] = 0u;
  v11[26] = 0u;
  v11[27] = 0u;
  v11[28] = 0u;
  v11[29] = 0u;
  v11[30] = 0u;
  v11[31] = 0u;
  return result;
}

uint64_t SecOTRSessionCreateFromID(uint64_t a1, const void *a2, const void *a3)
{
  uint64_t Instance;
  _QWORD *v6;
  _QWORD v8[5];

  SecOTRSessionGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  if (SecOTRGetDefaultsWriteSeconds_sdOnceToken != -1)
    dispatch_once(&SecOTRGetDefaultsWriteSeconds_sdOnceToken, &__block_literal_global_10243);
  *(_QWORD *)(Instance + 128) = dispatch_queue_create("OTRSession", 0);
  if (a2)
    CFRetain(a2);
  *(_QWORD *)(Instance + 24) = a2;
  if (a3)
    CFRetain(a3);
  *(_QWORD *)(Instance + 32) = a3;
  *(_WORD *)(Instance + 648) = 0;
  *(_BYTE *)(Instance + 650) = 0;
  *(_QWORD *)(Instance + 672) = 0;
  *(_BYTE *)(Instance + 664) = 0;
  *(_QWORD *)(Instance + 656) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_QWORD *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 80) = 0;
  *(_QWORD *)(Instance + 88) = 0;
  *(_QWORD *)(Instance + 112) = 0;
  *(_QWORD *)(Instance + 120) = 0;
  *(_QWORD *)(Instance + 104) = 0;
  *(_WORD *)(Instance + 680) = 1;
  SecOTRSessionResetInternal(Instance);
  v6 = SecOTRPublicIdentityCopyFromPrivate(*MEMORY[0x1E0C9AE00], *(_QWORD *)(Instance + 24), 0);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __SecOTRSessionCreateFromID_block_invoke;
  v8[3] = &__block_descriptor_tmp_18_10245;
  v8[4] = Instance;
  SecOTRPIPerformWithSerializationString((uint64_t)v6, (uint64_t)v8);
  if (v6)
    CFRelease(v6);
  return Instance;
}

void SecOTRPIPerformWithSerializationString(uint64_t a1, uint64_t a2)
{
  const __CFAllocator *v4;
  const __CFData *Mutable;
  CFIndex Length;
  __CFString *v7;
  const UInt8 *BytePtr;
  CFIndex v9;
  CFIndex v10;
  unsigned int v11;

  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  SecOTRPIAppendSerialization(a1, Mutable, 0);
  if (Mutable)
  {
    Length = CFDataGetLength(Mutable);
    v7 = CFStringCreateMutable(v4, 2 * Length);
    BytePtr = CFDataGetBytePtr(Mutable);
    v9 = CFDataGetLength(Mutable);
    if (v9 >= 1)
    {
      v10 = v9;
      do
      {
        v11 = *BytePtr++;
        CFStringAppendFormat(v7, 0, CFSTR("%02X"), v11);
        --v10;
      }
      while (v10);
    }
    (*(void (**)(uint64_t, __CFString *))(a2 + 16))(a2, v7);
    CFRelease(v7);
  }
  else
  {
    Mutable = (const __CFData *)CFSTR("(null)");
    (*(void (**)(uint64_t, const __CFString *))(a2 + 16))(a2, CFSTR("(null)"));
  }
  CFRelease(Mutable);
}

uint64_t SecOTRSessionCreateFromIDAndFlags(uint64_t a1, const void *a2, const void *a3, char a4)
{
  uint64_t v8;
  uint64_t result;

  if (SecOTRGetDefaultsWriteSeconds_sdOnceToken != -1)
    dispatch_once(&SecOTRGetDefaultsWriteSeconds_sdOnceToken, &__block_literal_global_10243);
  v8 = SecOTRGetDefaultsWriteSeconds_seconds;
  result = SecOTRSessionCreateFromID(a1, a2, a3);
  if ((a4 & 1) != 0)
  {
    *(_BYTE *)(result + 648) = 1;
    if ((a4 & 2) == 0)
    {
LABEL_5:
      if ((a4 & 4) == 0)
        goto LABEL_6;
      goto LABEL_11;
    }
  }
  else if ((a4 & 2) == 0)
  {
    goto LABEL_5;
  }
  *(_BYTE *)(result + 649) = 1;
  if ((a4 & 4) == 0)
  {
LABEL_6:
    if ((a4 & 8) == 0)
      return result;
    goto LABEL_7;
  }
LABEL_11:
  *(_BYTE *)(result + 650) = 1;
  if ((a4 & 8) == 0)
    return result;
LABEL_7:
  *(_QWORD *)(result + 656) = v8;
  return result;
}

uint64_t SecOTRSessionCreateFromData(uint64_t a1, const __CFData *a2)
{
  uint64_t Instance;
  UInt8 *BytePtr;
  unint64_t Length;
  dispatch_queue_t v6;
  unsigned int v7;
  const __CFAllocator *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  UInt8 *v13;
  int v14;
  UInt8 *v15;
  unint64_t v16;
  __CFData *Mutable;
  UInt8 *v18;
  int v19;
  unint64_t v20;
  BOOL v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  unint64_t v25;
  unsigned int v26;
  _QWORD *v27;
  _QWORD *v28;
  UInt8 *v29;
  int v30;
  unint64_t v31;
  unsigned int v32;
  const void *v33;
  const void *v34;
  unint64_t v35;
  UInt8 *v36;
  unint64_t v37;
  UInt8 *v38;
  unint64_t v39;
  UInt8 *v40;
  unint64_t v41;
  UInt8 *v42;
  unint64_t v43;
  UInt8 *v44;
  unint64_t v45;
  UInt8 *v46;
  unint64_t v47;
  UInt8 *v48;
  unint64_t v49;
  unint64_t v50;
  UInt8 *v51;
  UInt8 *v52;
  unint64_t v53;
  __CFData *v54;
  unint64_t v55;
  UInt8 *v56;
  uint64_t v57;
  int v58;
  int v59;
  int v60;
  int v61;
  unint64_t v62;
  int v63;
  UInt8 *v64;
  __CFData *v66;
  uint64_t *v67;
  unint64_t v68;
  UInt8 *bytes;

  if (!a2)
    return 0;
  SecOTRSessionGetTypeID();
  Instance = _CFRuntimeCreateInstance();
  BytePtr = (UInt8 *)CFDataGetBytePtr(a2);
  bytes = BytePtr;
  Length = CFDataGetLength(a2);
  v68 = Length;
  if (SecOTRGetDefaultsWriteSeconds_sdOnceToken != -1)
    dispatch_once(&SecOTRGetDefaultsWriteSeconds_sdOnceToken, &__block_literal_global_10243);
  v6 = dispatch_queue_create("OTRSession", 0);
  *(_QWORD *)(Instance + 104) = 0;
  *(_QWORD *)(Instance + 128) = v6;
  *(_QWORD *)(Instance + 80) = 0;
  *(_QWORD *)(Instance + 56) = 0;
  *(_WORD *)(Instance + 648) = 0;
  *(_QWORD *)(Instance + 672) = 0;
  *(_BYTE *)(Instance + 664) = 0;
  *(_QWORD *)(Instance + 656) = 0;
  *(_QWORD *)(Instance + 24) = 0;
  *(_QWORD *)(Instance + 32) = 0;
  *(_QWORD *)(Instance + 64) = 0;
  *(_QWORD *)(Instance + 88) = 0;
  *(_QWORD *)(Instance + 112) = 0;
  *(_WORD *)(Instance + 680) = 1;
  *(_OWORD *)(Instance + 232) = 0u;
  *(_OWORD *)(Instance + 248) = 0u;
  *(_OWORD *)(Instance + 200) = 0u;
  *(_OWORD *)(Instance + 216) = 0u;
  *(_OWORD *)(Instance + 168) = 0u;
  *(_OWORD *)(Instance + 184) = 0u;
  *(_OWORD *)(Instance + 152) = 0u;
  *(_OWORD *)(Instance + 136) = 0u;
  *(_OWORD *)(Instance + 616) = 0u;
  *(_OWORD *)(Instance + 632) = 0u;
  *(_OWORD *)(Instance + 584) = 0u;
  *(_OWORD *)(Instance + 600) = 0u;
  *(_OWORD *)(Instance + 552) = 0u;
  *(_OWORD *)(Instance + 568) = 0u;
  *(_OWORD *)(Instance + 520) = 0u;
  *(_OWORD *)(Instance + 536) = 0u;
  *(_OWORD *)(Instance + 488) = 0u;
  *(_OWORD *)(Instance + 504) = 0u;
  *(_OWORD *)(Instance + 456) = 0u;
  *(_OWORD *)(Instance + 472) = 0u;
  *(_OWORD *)(Instance + 424) = 0u;
  *(_OWORD *)(Instance + 440) = 0u;
  *(_OWORD *)(Instance + 392) = 0u;
  *(_OWORD *)(Instance + 408) = 0u;
  *(_OWORD *)(Instance + 360) = 0u;
  *(_OWORD *)(Instance + 376) = 0u;
  *(_OWORD *)(Instance + 328) = 0u;
  *(_OWORD *)(Instance + 344) = 0u;
  *(_OWORD *)(Instance + 296) = 0u;
  *(_OWORD *)(Instance + 312) = 0u;
  *(_OWORD *)(Instance + 264) = 0u;
  *(_OWORD *)(Instance + 280) = 0u;
  if (!Length)
    goto LABEL_76;
  v7 = *BytePtr;
  bytes = BytePtr + 1;
  v68 = Length - 1;
  if (v7 > 6)
    goto LABEL_76;
  if (Length < 5)
    goto LABEL_76;
  *(_DWORD *)(Instance + 16) = bswap32(*(_DWORD *)(BytePtr + 1));
  v68 = Length - 5;
  bytes = BytePtr + 5;
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v9 = SecOTRFullIdentityCreateFromBytes((const __CFAllocator *)*MEMORY[0x1E0C9AE00], (const UInt8 **)&bytes, &v68, 0);
  *(_QWORD *)(Instance + 24) = v9;
  if (!v9)
    goto LABEL_76;
  v10 = SecOTRPublicIdentityCreateFromBytes((uint64_t)v8, (uint64_t *)&bytes, &v68, 0);
  *(_QWORD *)(Instance + 32) = v10;
  if (!v10)
    goto LABEL_76;
  v11 = v68;
  v12 = v68 - 17;
  if (v68 < 0x11)
    goto LABEL_76;
  v13 = bytes;
  *(_OWORD *)(Instance + 40) = *(_OWORD *)bytes;
  v14 = v13[16];
  v15 = v13 + 17;
  v68 = v12;
  bytes = v13 + 17;
  if (v14)
  {
    if (v12 < 4
      || (v16 = bswap32(*(_DWORD *)(v13 + 17)),
          v15 = v13 + 21,
          v12 = v11 - 21,
          v68 = v11 - 21,
          bytes = v13 + 21,
          v11 - 21 < v16))
    {
      Mutable = 0;
    }
    else
    {
      Mutable = CFDataCreateMutable(v8, 0);
      CFDataAppendBytes(Mutable, bytes, v16);
      v15 = &bytes[v16];
      v12 = v68 - v16;
      v68 -= v16;
      bytes += v16;
    }
    *(_QWORD *)(Instance + 56) = Mutable;
  }
  if (v7 < 2)
    goto LABEL_25;
  if (v12)
  {
    v18 = v15 + 1;
    v19 = *v15;
    v20 = v12 - 1;
    v68 = v12 - 1;
    bytes = v15 + 1;
    if (v19)
    {
      v21 = v12 >= 5;
      v22 = v12 - 5;
      if (v21)
      {
        v23 = bswap32(*(_DWORD *)(v15 + 1));
        v18 = v15 + 5;
        v68 = v22;
        bytes = v15 + 5;
        if (v22 < v23)
        {
          v66 = 0;
          v20 = v22;
        }
        else
        {
          v66 = CFDataCreateMutable(v8, 0);
          CFDataAppendBytes(v66, bytes, v23);
          v18 = &bytes[v23];
          v20 = v68 - v23;
          v68 -= v23;
          bytes += v23;
        }
      }
      else
      {
        v66 = 0;
      }
      *(_QWORD *)(Instance + 64) = v66;
    }
    v15 = v18;
  }
  else
  {
    v20 = 0;
  }
  v12 = v20;
  if (v7 <= 2)
  {
LABEL_25:
    if (!v12)
      goto LABEL_76;
    v24 = *v15++;
    v20 = v12 - 1;
    v68 = v12 - 1;
    bytes = v15;
    if (v24 && !*(_DWORD *)(Instance + 16))
      *(_DWORD *)(Instance + 16) = 4;
  }
  v25 = v20 - 4;
  if (v20 < 4)
    goto LABEL_76;
  v26 = bswap32(*(_DWORD *)v15);
  *(_DWORD *)(Instance + 72) = v26;
  v68 = v25;
  bytes = v15 + 4;
  if (v26)
  {
    v27 = SecOTRFullDHKCreateFromBytes((uint64_t)v8, (unsigned int **)&bytes, &v68);
    *(_QWORD *)(Instance + 80) = v27;
    if (!v27)
      goto LABEL_76;
    v28 = SecOTRFullDHKCreateFromBytes((uint64_t)v8, (unsigned int **)&bytes, &v68);
    *(_QWORD *)(Instance + 88) = v28;
    if (!v28)
      goto LABEL_76;
    v25 = v68;
  }
  if (!v25 || (v29 = bytes, v30 = *bytes, ++bytes, v68 = v25 - 1, v31 = v25 - 5, v25 < 5))
  {
LABEL_76:
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  v32 = bswap32(*(_DWORD *)(v29 + 1));
  *(_DWORD *)(Instance + 96) = v32;
  v68 = v31;
  bytes = v29 + 5;
  if (v7 > 4)
  {
    if (!v30)
      goto LABEL_44;
    if (v30 == 1)
      goto LABEL_43;
    goto LABEL_42;
  }
  if (!v32)
    goto LABEL_44;
  if (v32 != 1)
  {
LABEL_42:
    v33 = SecOTRPublicDHKCreateFromSerialization((uint64_t)v8, (unsigned int **)&bytes, &v68);
    *(_QWORD *)(Instance + 104) = v33;
    if (!v33)
      goto LABEL_76;
  }
LABEL_43:
  v34 = SecOTRPublicDHKCreateFromSerialization((uint64_t)v8, (unsigned int **)&bytes, &v68);
  *(_QWORD *)(Instance + 112) = v34;
  if (!v34)
    goto LABEL_76;
LABEL_44:
  v67 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  SecOTRSFindKeysForMessage(Instance, *(_QWORD *)(Instance + 80), *(_QWORD *)(Instance + 112), 0, 0, 0, &v67);
  if (!v67)
    goto LABEL_76;
  v35 = v68 - 8;
  if (v68 < 8)
    goto LABEL_76;
  v36 = bytes + 8;
  *v67 = bswap64(*(_QWORD *)bytes);
  v68 = v35;
  bytes = v36;
  SecOTRSFindKeysForMessage(Instance, *(_QWORD *)(Instance + 80), *(_QWORD *)(Instance + 112), 1, 0, 0, &v67);
  if (!v67)
    goto LABEL_76;
  v37 = v68 - 8;
  if (v68 < 8)
    goto LABEL_76;
  v38 = bytes + 8;
  *v67 = bswap64(*(_QWORD *)bytes);
  v68 = v37;
  bytes = v38;
  SecOTRSFindKeysForMessage(Instance, *(_QWORD *)(Instance + 80), *(_QWORD *)(Instance + 104), 0, 0, 0, &v67);
  if (!v67)
    goto LABEL_76;
  v39 = v68 - 8;
  if (v68 < 8)
    goto LABEL_76;
  v40 = bytes + 8;
  *v67 = bswap64(*(_QWORD *)bytes);
  v68 = v39;
  bytes = v40;
  SecOTRSFindKeysForMessage(Instance, *(_QWORD *)(Instance + 80), *(_QWORD *)(Instance + 104), 1, 0, 0, &v67);
  if (!v67)
    goto LABEL_76;
  v41 = v68 - 8;
  if (v68 < 8)
    goto LABEL_76;
  v42 = bytes + 8;
  *v67 = bswap64(*(_QWORD *)bytes);
  v68 = v41;
  bytes = v42;
  SecOTRSFindKeysForMessage(Instance, *(_QWORD *)(Instance + 88), *(_QWORD *)(Instance + 112), 0, 0, 0, &v67);
  if (!v67)
    goto LABEL_76;
  v43 = v68 - 8;
  if (v68 < 8)
    goto LABEL_76;
  v44 = bytes + 8;
  *v67 = bswap64(*(_QWORD *)bytes);
  v68 = v43;
  bytes = v44;
  SecOTRSFindKeysForMessage(Instance, *(_QWORD *)(Instance + 88), *(_QWORD *)(Instance + 112), 1, 0, 0, &v67);
  if (!v67)
    goto LABEL_76;
  v45 = v68 - 8;
  if (v68 < 8)
    goto LABEL_76;
  v46 = bytes + 8;
  *v67 = bswap64(*(_QWORD *)bytes);
  v68 = v45;
  bytes = v46;
  SecOTRSFindKeysForMessage(Instance, *(_QWORD *)(Instance + 88), *(_QWORD *)(Instance + 104), 0, 0, 0, &v67);
  if (!v67)
    goto LABEL_76;
  v47 = v68 - 8;
  if (v68 < 8)
    goto LABEL_76;
  v48 = bytes + 8;
  *v67 = bswap64(*(_QWORD *)bytes);
  v68 = v47;
  bytes = v48;
  SecOTRSFindKeysForMessage(Instance, *(_QWORD *)(Instance + 88), *(_QWORD *)(Instance + 104), 1, 0, 0, &v67);
  if (!v67)
    goto LABEL_76;
  v49 = v68;
  v50 = v68 - 8;
  if (v68 < 8)
    goto LABEL_76;
  v51 = bytes;
  v52 = bytes + 8;
  *v67 = bswap64(*(_QWORD *)bytes);
  v68 = v50;
  bytes = v52;
  if (v50 < 4 || (v53 = bswap32(*((_DWORD *)v51 + 2)), v68 = v49 - 12, bytes = v51 + 12, v49 - 12 < v53))
  {
    *(_QWORD *)(Instance + 120) = 0;
    goto LABEL_76;
  }
  v54 = CFDataCreateMutable(v8, 0);
  CFDataAppendBytes(v54, bytes, v53);
  v55 = v68;
  v56 = &bytes[v53];
  v57 = v68 - v53;
  v68 -= v53;
  bytes += v53;
  *(_QWORD *)(Instance + 120) = v54;
  if (!v54 || v55 == v53)
    goto LABEL_76;
  v58 = *v56;
  bytes = v56 + 1;
  v68 = v57 - 1;
  *(_BYTE *)(Instance + 648) = v58 != 0;
  if (v7 < 4)
    return Instance;
  if (v57 == 1)
    goto LABEL_76;
  v59 = v56[1];
  bytes = v56 + 2;
  v68 = v57 - 2;
  *(_BYTE *)(Instance + 649) = v59 != 0;
  if (v7 < 5)
    return Instance;
  if (v57 == 2)
    goto LABEL_76;
  v60 = v56[2];
  bytes = v56 + 3;
  v68 = v57 - 3;
  *(_BYTE *)(Instance + 650) = v60 != 0;
  if (v7 >= 6)
  {
    if ((unint64_t)(v57 - 3) >= 8)
    {
      *(_QWORD *)(Instance + 656) = bswap64(*(_QWORD *)(v56 + 3));
      v68 = v57 - 11;
      bytes = v56 + 11;
      if (v57 != 11)
      {
        v61 = v56[11];
        bytes = v56 + 12;
        v68 = v57 - 12;
        *(_BYTE *)(Instance + 664) = v61 != 0;
        if ((unint64_t)(v57 - 12) >= 8)
        {
          v62 = *(_QWORD *)(v56 + 12);
          bytes = v56 + 20;
          v68 = v57 - 20;
          if (v57 != 20)
          {
            v63 = v56[20];
            v64 = v56 + 21;
            *(_BYTE *)(Instance + 680) = v63 != 0;
            v68 = v57 - 21;
            bytes = v64;
            if (v57 != 21)
            {
              *(_BYTE *)(Instance + 681) = *v64 != 0;
              *(double *)(Instance + 672) = (double)bswap64(v62);
              return Instance;
            }
          }
        }
      }
    }
    goto LABEL_76;
  }
  return Instance;
}

void SecOTRSFindKeysForMessage(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _QWORD *a5, _QWORD *a6, uint64_t **a7)
{
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  unint64_t v19;
  char v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t **v31;

  if (a2 && a3)
  {
    v31 = a7;
    v9 = 0;
    v10 = 0;
    v11 = (_DWORD *)(a2 + 160);
    v12 = (_DWORD *)(a3 + 128);
    v13 = a1 + 136;
    v14 = a1 + 156;
    while (1)
    {
      v15 = a1 + (v9 << 7);
      v16 = v15 + 136;
      if (!timingsafe_bcmp((const void *)(v15 + 136), v11, 0x14uLL)
        && !timingsafe_bcmp((const void *)(v15 + 156), v12, 0x14uLL))
      {
        break;
      }
      if (!v10)
      {
        v17 = 0;
        do
        {
          v18 = *(unsigned __int8 *)(v13 + v17);
          if (v17 > 0x12)
            break;
          ++v17;
        }
        while (!v18);
        if (v18)
        {
          v10 = 0;
        }
        else
        {
          v19 = 0;
          do
          {
            v20 = *(_BYTE *)(v14 + v19);
            if (v19 > 0x12)
              break;
            ++v19;
          }
          while (!v20);
          if (v20)
            v10 = 0;
          else
            v10 = v15 + 136;
        }
      }
      ++v9;
      v13 += 128;
      v14 += 128;
      if (v9 == 4)
      {
        if (v10)
          v16 = v10;
        else
          v16 = a1 + 136;
        v21 = *(_OWORD *)v11;
        *(_DWORD *)(v16 + 16) = v11[4];
        *(_OWORD *)v16 = v21;
        v22 = *(_OWORD *)v12;
        *(_DWORD *)(v16 + 36) = v12[4];
        *(_OWORD *)(v16 + 20) = v22;
        *(_QWORD *)(v16 + 112) = 0;
        *(_QWORD *)(v16 + 120) = 0;
        SecOTRDHKGenerateOTRKeys(a2, a3, v16 + 60, v16 + 40, v16 + 96, v16 + 76);
        break;
      }
    }
    a7 = v31;
    if (a5)
    {
      v23 = 96;
      if (a4)
        v23 = 60;
      *a5 = v16 + v23;
    }
    if (a6)
    {
      v24 = 76;
      if (a4)
        v24 = 40;
      *a6 = v16 + v24;
    }
    if (v31)
    {
      v25 = 120;
      if (a4)
        v25 = 112;
      v26 = (uint64_t *)(v16 + v25);
      goto LABEL_41;
    }
  }
  else
  {
    if (a5)
      *a5 = 0;
    if (a6)
      *a6 = 0;
    if (a7)
    {
      v26 = &constant_zero;
LABEL_41:
      *a7 = v26;
    }
  }
}

uint64_t SecOTRSAppendSerialization(uint64_t a1, CFDataRef theData)
{
  uint64_t v2;
  CFIndex Length;
  NSObject *v6;
  _QWORD block[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v2 = 4294967246;
  v12 = -50;
  if (a1 && theData)
  {
    Length = CFDataGetLength(theData);
    v6 = *(NSObject **)(a1 + 128);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SecOTRSAppendSerialization_block_invoke;
    block[3] = &unk_1E1FD8728;
    block[5] = theData;
    block[6] = a1;
    block[4] = &v9;
    dispatch_sync(v6, block);
    if (*((_DWORD *)v10 + 6))
    {
      CFDataSetLength(theData, Length);
      v2 = *((unsigned int *)v10 + 6);
    }
    else
    {
      v2 = 0;
    }
  }
  _Block_object_dispose(&v9, 8);
  return v2;
}

uint64_t SecOTRSIsForKeys(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;
  uint64_t v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v3 = *(NSObject **)(a1 + 128);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __SecOTRSIsForKeys_block_invoke;
  v6[3] = &unk_1E1FD8750;
  v6[4] = &v7;
  v6[5] = a1;
  v6[6] = a2;
  v6[7] = a3;
  dispatch_sync(v3, v6);
  v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t SecOTRSGetIsReadyForMessages(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = -86;
  v1 = *(NSObject **)(a1 + 128);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __SecOTRSGetIsReadyForMessages_block_invoke;
  v4[3] = &unk_1E1FD8778;
  v4[4] = &v5;
  v4[5] = a1;
  dispatch_sync(v1, v4);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t SecOTRSGetIsIdle(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = -86;
  v1 = *(NSObject **)(a1 + 128);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __SecOTRSGetIsIdle_block_invoke;
  v4[3] = &unk_1E1FD87A0;
  v4[4] = &v5;
  v4[5] = a1;
  dispatch_sync(v1, v4);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void SecOTRSPrecalculateKeys(dispatch_queue_t *context)
{
  dispatch_sync_f(context[16], context, (dispatch_function_t)SecOTRSPrecalculateKeysInternal);
}

void SecOTRSPrecalculateKeysInternal(uint64_t *a1)
{
  SecOTRSPrecalculateForPair((uint64_t)a1, a1[10], a1[14]);
  SecOTRSPrecalculateForPair((uint64_t)a1, a1[11], a1[14]);
  SecOTRSPrecalculateForPair((uint64_t)a1, a1[10], a1[13]);
  SecOTRSPrecalculateForPair((uint64_t)a1, a1[11], a1[13]);
}

void SecOTRSPrecalculateForPair(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (a3)
    {
      SecOTRSFindKeysForMessage(a1, a2, a3, 1, 0, 0, 0);
      SecOTRSFindKeysForMessage(a1, a2, a3, 0, 0, 0, 0);
    }
  }
}

uint64_t SecOTRSGetMessageKind(uint64_t a1, const __CFData *a2)
{
  unsigned __int8 v2;

  v2 = SecOTRSGetMessageType(a2);
  if (v2 > 0x31u)
    return 2;
  if (((1 << v2) & 0x3000300000008) != 0)
    return 1;
  if (((1 << v2) & 0x60404) != 0)
    return 0;
  else
    return 2;
}

uint64_t SecOTRSSignAndProtectMessage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *v4;
  _QWORD v6[8];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v3 = 4294967246;
  v10 = -50;
  if (a1 && a2 && a3 && *(_DWORD *)(a1 + 16) == 4)
  {
    v4 = *(NSObject **)(a1 + 128);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __SecOTRSSignAndProtectMessage_block_invoke;
    v6[3] = &unk_1E1FD87C8;
    v6[4] = &v7;
    v6[5] = a1;
    v6[6] = a3;
    v6[7] = a2;
    dispatch_sync(v4, v6);
    v3 = *((unsigned int *)v8 + 6);
  }
  _Block_object_dispose(&v7, 8);
  return v3;
}

void SecOTRSRollIfTime(uint64_t a1)
{
  double Current;
  double v3;
  char v4;

  Current = CFAbsoluteTimeGetCurrent();
  v3 = *(double *)(a1 + 672);
  if (v3 < Current || v3 > Current + (double)*(unint64_t *)(a1 + 656))
  {
    *(_BYTE *)(a1 + 664) = 0;
    if (*(_BYTE *)(a1 + 681))
    {
      SecOTRGenerateNewProposedKey(a1);
      v4 = 0;
      *(_BYTE *)(a1 + 681) = 0;
    }
    else
    {
      v4 = 1;
    }
    *(_BYTE *)(a1 + 680) = v4;
    *(_QWORD *)(a1 + 672) = 0;
  }
}

void SecOTRSSignAndProtectCompact_locked(uint64_t a1, const __CFData *a2, CFDataRef theData, uint64_t a4, uint64_t a5, uint64_t *a6, char a7, uint64_t a8)
{
  int v15;
  char v16;
  unint64_t v17;
  const UInt8 *v18;
  unint64_t v19;
  CFIndex Length;
  CFIndex v21;
  UInt8 *v22;
  uint64_t v23;
  const UInt8 *BytePtr;
  CFIndex v25;
  UInt8 *v26;
  uint64_t v27;
  int v28;
  CFIndex v29;
  UInt8 *v30;
  int v31;
  CFIndex v32;
  UInt8 v33[32];
  uint64_t v34;
  UInt8 bytes[9];
  char v36;
  uint64_t v37;

  v34 = a5;
  v37 = *MEMORY[0x1E0C80C00];
  CFDataGetLength(theData);
  v15 = *(unsigned __int8 *)(a1 + 650);
  if (*(_BYTE *)(a1 + 650))
    v16 = 48;
  else
    v16 = 32;
  bytes[0] = v16 & 0xFE | a7 & 1;
  CFDataAppendBytes(theData, bytes, 1);
  SecFDHKAppendCompactPublicSerialization(*(_QWORD *)(a1 + 88), theData);
  v17 = *a6 + 1;
  *a6 = v17;
  v18 = (const UInt8 *)&v36;
  memset(bytes, 170, sizeof(bytes));
  v36 = v17 & 0x7F;
  if (v17 >= 0x80)
  {
    do
    {
      v19 = v17 >> 14;
      v17 >>= 7;
      *--v18 = v17 | 0x80;
    }
    while (v19);
  }
  CFDataAppendBytes(theData, v18, bytes - v18 + 10);
  Length = CFDataGetLength(a2);
  v21 = CFDataGetLength(theData);
  CFDataIncreaseLength(theData, Length);
  v22 = &CFDataGetMutableBytePtr(theData)[v21];
  v23 = *a6;
  BytePtr = CFDataGetBytePtr(a2);
  AES_CTR_HighHalf_Transform(16, a4, v23, Length, (uint64_t)BytePtr, (uint64_t)v22);
  if (v15)
  {
    v25 = CFDataGetLength(theData);
    CFDataIncreaseLength(theData, 20);
    v26 = &CFDataGetMutableBytePtr(theData)[v25];
    v27 = *(_QWORD *)(a1 + 80);
    v28 = *(_DWORD *)(v27 + 176);
    *(_OWORD *)v26 = *(_OWORD *)(v27 + 160);
    *((_DWORD *)v26 + 4) = v28;
    v29 = CFDataGetLength(theData);
    CFDataIncreaseLength(theData, 20);
    v30 = &CFDataGetMutableBytePtr(theData)[v29];
    v31 = *(_DWORD *)(a8 + 144);
    *(_OWORD *)v30 = *(_OWORD *)(a8 + 128);
    *((_DWORD *)v30 + 4) = v31;
  }
  v32 = CFDataGetLength(theData);
  MEMORY[0x1E0C80A78](v32);
  memset(v33, 170, 20);
  ccsha1_di();
  CFDataGetBytePtr(theData);
  cchmac();
  CFDataAppendBytes(theData, v33, 16);
}

uint64_t SecOTRGenerateNewProposedKey(uint64_t a1)
{
  uint64_t v2;
  const void *v3;
  uint64_t result;

  v2 = 0;
  v3 = (const void *)(*(_QWORD *)(a1 + 80) + 160);
  do
  {
    if (!timingsafe_bcmp((const void *)(a1 + v2 + 136), v3, 0x14uLL))
    {
      CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 120), (const UInt8 *)(a1 + v2 + 212), 20);
      *(_OWORD *)(a1 + v2 + 232) = 0u;
      *(_OWORD *)(a1 + v2 + 248) = 0u;
      *(_OWORD *)(a1 + v2 + 200) = 0u;
      *(_OWORD *)(a1 + v2 + 216) = 0u;
      *(_OWORD *)(a1 + v2 + 168) = 0u;
      *(_OWORD *)(a1 + v2 + 184) = 0u;
      *(_OWORD *)(a1 + v2 + 136) = 0u;
      *(_OWORD *)(a1 + v2 + 152) = 0u;
    }
    v2 += 128;
  }
  while (v2 != 512);
  *(int8x16_t *)(a1 + 80) = vextq_s8(*(int8x16_t *)(a1 + 80), *(int8x16_t *)(a1 + 80), 8uLL);
  result = SecFDHKNewKey();
  ++*(_DWORD *)(a1 + 72);
  return result;
}

void SecOTRSKickTimeToRoll(uint64_t a1)
{
  *(CFAbsoluteTime *)(a1 + 672) = CFAbsoluteTimeGetCurrent();
}

uint64_t SecOTRSetupInitialRemoteKey(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;

  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  v4 = *(const void **)(a1 + 104);
  if (v4)
  {
    *(_QWORD *)(a1 + 104) = 0;
    CFRelease(v4);
  }
  v5 = *(const void **)(a1 + 112);
  if (v5)
    CFRelease(v5);
  *(_QWORD *)(a1 + 112) = a2;
  *(_DWORD *)(a1 + 96) = 1;
  return 0;
}

uint64_t SOSOTRSRoll(uint64_t result)
{
  uint64_t v1;
  char v2;

  v1 = result;
  *(_BYTE *)(result + 664) = 0;
  if (*(_BYTE *)(result + 681))
  {
    result = SecOTRGenerateNewProposedKey(result);
    v2 = 0;
    *(_BYTE *)(v1 + 681) = 0;
  }
  else
  {
    v2 = 1;
  }
  *(_BYTE *)(v1 + 680) = v2;
  return result;
}

uint64_t SecOTRSVerifyAndExposeMessage(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *v6;
  NSObject *v7;
  _QWORD v9[8];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  uint8_t buf[4];
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v3 = 4294967246;
  v13 = -50;
  if (a1 && a2 && a3)
  {
    if (*(_DWORD *)(a1 + 16) == 4)
    {
      v6 = *(NSObject **)(a1 + 128);
      v9[0] = MEMORY[0x1E0C809B0];
      v9[1] = 0x40000000;
      v9[2] = __SecOTRSVerifyAndExposeMessage_block_invoke;
      v9[3] = &unk_1E1FD87F0;
      v9[4] = &v10;
      v9[5] = a2;
      v9[6] = a1;
      v9[7] = a3;
      dispatch_sync(v6, v9);
      v3 = *((unsigned int *)v11 + 6);
    }
    else
    {
      v7 = secLogObjForScope("OTR");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218498;
        v15 = a1;
        v16 = 2112;
        v17 = a2;
        v18 = 2112;
        v19 = a1;
        _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "session[%p]Cannot process message:%@, session is not done negotiating, session state: %@", buf, 0x20u);
      }
      v3 = 4294941965;
      *((_DWORD *)v11 + 6) = -25331;
    }
  }
  _Block_object_dispose(&v10, 8);
  return v3;
}

void SecOTRAcceptNewRemoteKey(uint64_t a1, CFTypeRef cf)
{
  uint64_t v4;
  uint64_t v5;
  const void *v6;
  uint64_t v7;
  const void *v8;
  double v9;
  double v10;

  v4 = *(_QWORD *)(a1 + 104);
  if (v4)
  {
    v5 = 0;
    v6 = (const void *)(v4 + 128);
    do
    {
      v7 = a1 + v5;
      if (!timingsafe_bcmp((const void *)(a1 + v5 + 156), v6, 0x14uLL))
      {
        CFDataAppendBytes(*(CFMutableDataRef *)(a1 + 120), (const UInt8 *)(v7 + 212), 20);
        *(_OWORD *)(v7 + 248) = 0u;
        *(_OWORD *)(v7 + 232) = 0u;
        *(_OWORD *)(v7 + 216) = 0u;
        *(_OWORD *)(v7 + 200) = 0u;
        *(_OWORD *)(v7 + 184) = 0u;
        *(_OWORD *)(v7 + 168) = 0u;
        *(_OWORD *)(v7 + 152) = 0u;
        *(_OWORD *)(v7 + 136) = 0u;
      }
      v5 += 128;
    }
    while (v5 != 512);
    v8 = *(const void **)(a1 + 104);
    if (v8)
    {
      *(_QWORD *)(a1 + 104) = 0;
      CFRelease(v8);
    }
  }
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a1 + 112);
  CFRetain(cf);
  *(_QWORD *)(a1 + 112) = cf;
  *(_BYTE *)(a1 + 664) = 1;
  ++*(_DWORD *)(a1 + 96);
  v9 = CFAbsoluteTimeGetCurrent() + (double)*(unint64_t *)(a1 + 656);
  v10 = *(double *)(a1 + 672);
  if (v10 == 0.0 || v10 > v9)
    *(double *)(a1 + 672) = v9;
}

void SecOTRSHandleProposalAcknowledge(uint64_t a1)
{
  double v2;
  double v3;

  if (*(_BYTE *)(a1 + 680))
  {
    SecOTRGenerateNewProposedKey(a1);
    *(_BYTE *)(a1 + 680) = 0;
  }
  else
  {
    *(_BYTE *)(a1 + 681) = 1;
    v2 = CFAbsoluteTimeGetCurrent() + (double)*(unint64_t *)(a1 + 656);
    v3 = *(double *)(a1 + 672);
    if (v3 == 0.0 || v3 > v2)
      *(double *)(a1 + 672) = v2;
  }
}

uint64_t SecOTRSessionCreateRemote(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD activity_block[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  unint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0xAAAAAAAAAAAAAAAALL;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecOTRSessionCreateRemote_block_invoke;
  activity_block[3] = &unk_1E1FD8818;
  activity_block[4] = &v5;
  activity_block[5] = a1;
  activity_block[6] = a2;
  _os_activity_initiate(&dword_18A900000, "SecOTRSessionCreateRemote", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

BOOL __data_to_data_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  const __CFData *v4;

  v4 = *(const __CFData **)(a1 + 32);
  return !v4 || SecXPCDictionarySetData(a2, "publicPeerId", v4, a3);
}

BOOL __data_to_data_error_request_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  CFDataRef v4;

  v4 = SecXPCDictionaryCopyData(a2, "status", a3);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
  return v4 != 0;
}

uint64_t SecOTRSessionProcessPacketRemote(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  _QWORD activity_block[11];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = -86;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecOTRSessionProcessPacketRemote_block_invoke;
  activity_block[3] = &unk_1E1FD8840;
  activity_block[4] = &v9;
  activity_block[5] = a1;
  activity_block[6] = a2;
  activity_block[7] = a3;
  activity_block[8] = a4;
  activity_block[9] = a5;
  activity_block[10] = a6;
  _os_activity_initiate(&dword_18A900000, "SecOTRSessionProcessPacketRemote", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

uint64_t SecOTRSessionIsSessionInAwaitingState(uint64_t a1)
{
  unsigned int v1;
  uint64_t result;
  NSObject *v3;
  _BOOL4 v4;
  uint8_t v5[16];

  v1 = *(_DWORD *)(a1 + 16);
  if (v1 < 5)
    return (0xFu >> v1) & 1;
  v3 = secLogObjForScope("otrtimer");
  v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v4)
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "unknown otr auth state", v5, 2u);
    return 0;
  }
  return result;
}

uint64_t SecOTRSAppendStartPacket(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD block[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v2 = *(NSObject **)(a1 + 128);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecOTRSAppendStartPacket_block_invoke;
  block[3] = &unk_1E1FD8A40;
  block[4] = &v6;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync(v2, block);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void SecOTRInitMyDHKeys(uint64_t a1)
{
  const void *v2;
  const void *v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = *(const void **)(a1 + 80);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = 0;
    CFRelease(v2);
  }
  *(_QWORD *)(a1 + 80) = SecOTRFullDHKCreate();
  v3 = *(const void **)(a1 + 88);
  if (v3)
  {
    *(_QWORD *)(a1 + 88) = 0;
    CFRelease(v3);
  }
  v4 = SecOTRFullDHKCreate();
  *(_OWORD *)(a1 + 136) = 0u;
  *(_QWORD *)(a1 + 88) = v4;
  *(_DWORD *)(a1 + 72) = 1;
  *(_WORD *)(a1 + 680) = 1;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_OWORD *)(a1 + 584) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_OWORD *)(a1 + 616) = 0u;
  *(_OWORD *)(a1 + 632) = 0u;
  v5 = secLogObjForScope("otr");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_QWORD *)(a1 + 80);
    v7 = 138412546;
    v8 = a1;
    v9 = 2112;
    v10 = v6;
    _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "%@ Reinitializing DH Keys, first: %@", (uint8_t *)&v7, 0x16u);
  }
}

uint64_t SecOTRSAppendRestartPacket(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD block[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v2 = *(NSObject **)(a1 + 128);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecOTRSAppendRestartPacket_block_invoke;
  block[3] = &unk_1E1FD8A88;
  block[4] = &v6;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync(v2, block);
  v3 = *((unsigned int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t SecOTRSProcessPacket(uint64_t a1, CFDataRef theData, uint64_t a3)
{
  NSObject *v6;
  uint64_t v7;
  _QWORD v9[8];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = -50;
  if (CFDataGetLength(theData) >= 1)
  {
    v6 = *(NSObject **)(a1 + 128);
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = __SecOTRSProcessPacket_block_invoke;
    v9[3] = &unk_1E1FD8B00;
    v9[6] = a1;
    v9[7] = a3;
    v9[4] = &v10;
    v9[5] = theData;
    dispatch_sync(v6, v9);
  }
  v7 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v7;
}

const UInt8 *FindGXHash(const __CFData *a1)
{
  const UInt8 *BytePtr;
  unint64_t Length;
  unint64_t v4;
  const UInt8 *result;
  unint64_t v6;
  unint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  const UInt8 *v11;
  unint64_t v12;
  const UInt8 *v13;

  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  if (Length < 2)
    return 0;
  v4 = Length;
  result = 0;
  if (v4 != 2 && __rev16(*(unsigned __int16 *)BytePtr) == 2)
  {
    result = 0;
    if (v4 - 3 >= 4 && BytePtr[2] == 2)
    {
      v6 = bswap32(*(_DWORD *)(BytePtr + 3));
      v7 = v4 - 7;
      v8 = v7 >= v6;
      v9 = v7 - v6;
      if (!v8)
        return 0;
      v8 = v9 >= 4;
      v10 = v9 - 4;
      if (!v8)
        return 0;
      v11 = &BytePtr[v6];
      v12 = bswap32(*(_DWORD *)(v11 + 7));
      v13 = v11 + 11;
      if (v10 >= v12 && (_DWORD)v12 == 32)
        return v13;
      else
        return 0;
    }
  }
  return result;
}

void BufferPerformWithHexString_10309(UInt8 *bytes, uint64_t a2)
{
  const __CFAllocator *v3;
  const __CFData *v4;
  const __CFData *v5;
  CFIndex Length;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex v9;
  CFIndex v10;
  unsigned int v11;

  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 32, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (v4)
  {
    v5 = v4;
    Length = CFDataGetLength(v4);
    Mutable = CFStringCreateMutable(v3, 2 * Length);
    BytePtr = CFDataGetBytePtr(v5);
    v9 = CFDataGetLength(v5);
    if (v9 >= 1)
    {
      v10 = v9;
      do
      {
        v11 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v11);
        --v10;
      }
      while (v10);
    }
    (*(void (**)(uint64_t, __CFString *))(a2 + 16))(a2, Mutable);
    CFRelease(Mutable);
  }
  else
  {
    v5 = (const __CFData *)CFSTR("(null)");
    (*(void (**)(uint64_t, const __CFString *))(a2 + 16))(a2, CFSTR("(null)"));
  }
  CFRelease(v5);
}

uint64_t SecOTRSetupTheirKeyFrom(uint64_t a1, unsigned int **a2, unint64_t *a3)
{
  const void *v4;

  v4 = SecOTRPublicDHKCreateFromSerialization(*MEMORY[0x1E0C9AE00], a2, a3);
  if (!v4)
    return 4294941021;
  SecOTRSetupInitialRemoteKey(a1, (uint64_t)v4);
  return 0;
}

uint64_t SecVerifySignatureAndMac(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  __int128 v4;
  uint64_t v5;
  _QWORD v7[8];
  char v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;
  _QWORD v13[5];
  _OWORD v14[2];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v11 = 0x2000000000;
  v12 = -26275;
  v7[2] = __SecVerifySignatureAndMac_block_invoke;
  v7[3] = &unk_1E1FD8C80;
  v9 = 0;
  v10 = &v9;
  v8 = a2;
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[4] = &v9;
  v7[5] = a1;
  v7[6] = a3;
  v7[7] = a4;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 0x40000000;
  v13[2] = __PerformWithBufferAndClear_block_invoke;
  v13[3] = &unk_1E1FDC2B8;
  v13[4] = v7;
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14[0] = v4;
  v14[1] = v4;
  __PerformWithBufferAndClear_block_invoke((uint64_t)v13, 0x20uLL, v14);
  v5 = *((unsigned int *)v10 + 6);
  _Block_object_dispose(&v9, 8);
  return v5;
}

void SecOTRCreateError(int a1, CFIndex code, void *a3, CFTypeRef cf, CFErrorRef *a5)
{
  void *v6;
  const __CFString *v7;
  CFIndex v8;
  void *userInfoValues[2];
  void *userInfoKeys[3];

  userInfoKeys[2] = *(void **)MEMORY[0x1E0C80C00];
  if (a5 && !*a5)
  {
    v6 = (void *)*MEMORY[0x1E0C9B000];
    userInfoKeys[0] = *(void **)MEMORY[0x1E0C9AFB0];
    userInfoKeys[1] = v6;
    userInfoValues[0] = a3;
    userInfoValues[1] = (void *)cf;
    if (a1)
      v7 = (const __CFString *)*MEMORY[0x1E0C9AFC8];
    else
      v7 = CFSTR("com.apple.security.otr.error");
    if (cf)
      v8 = 2;
    else
      v8 = 1;
    *a5 = CFErrorCreateWithUserInfoKeysAndValues((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v7, code, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, v8);
  }
  else if (cf)
  {
    CFRelease(cf);
  }
}

uint64_t appendSizeAndData(const __CFData *a1, __CFData *a2)
{
  CFIndex Length;
  const UInt8 *BytePtr;
  CFIndex v6;
  UInt8 bytes[2];

  Length = CFDataGetLength(a1);
  if (Length >= 0xFFFF)
    return 4294942005;
  *(_WORD *)bytes = bswap32(Length) >> 16;
  CFDataAppendBytes(a2, bytes, 2);
  BytePtr = CFDataGetBytePtr(a1);
  v6 = CFDataGetLength(a1);
  CFDataAppendBytes(a2, BytePtr, v6);
  return 0;
}

uint64_t appendPublicOctetsAndSize(uint64_t a1, __CFData *a2)
{
  uint64_t appended;
  CFTypeRef v4;
  CFTypeRef cf;

  cf = 0;
  if (SecKeyCopyPublicBytes(a1, (uint64_t)&cf))
  {
    appended = 4294941021;
  }
  else
  {
    if (!cf)
      return 4294941021;
    appended = appendSizeAndData((const __CFData *)cf, a2);
  }
  v4 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v4);
  }
  return appended;
}

_QWORD *CreateECPublicKeyFrom(const UInt8 **a1, unint64_t *a2)
{
  const UInt8 *v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  uint64_t v8;
  const __CFData *v9;
  _QWORD *v10;

  v3 = 0;
  LODWORD(v4) = 0;
  if (a1 && a2)
  {
    v5 = *a2 - 2;
    if (*a2 < 2)
    {
      LODWORD(v4) = 0;
LABEL_9:
      v3 = 0;
      goto LABEL_7;
    }
    v3 = *a1 + 2;
    v4 = __rev16(*(unsigned __int16 *)*a1);
    *a2 = v5;
    *a1 = v3;
    v6 = v5 >= v4;
    v7 = v5 - v4;
    if (!v6)
      goto LABEL_9;
    *a2 = v7;
    *a1 = &v3[v4];
  }
LABEL_7:
  v8 = *MEMORY[0x1E0C9AE00];
  v9 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v3, v4);
  v10 = SecKeyCreateFromPublicData(v8, 3, v9);
  CFRelease(v9);
  return v10;
}

uint64_t SecOTRCopyIncomingBytes(const __CFData *a1)
{
  const __CFAllocator *v2;
  const __CFData *ExternalRepresentation;
  CFRange v4;
  const __CFData *v5;
  CFIndex v6;
  const UInt8 *BytePtr;
  const __CFData *v8;
  unint64_t Length;
  unint64_t v10;
  uint64_t *v11;
  const __CFData *v12;
  uint64_t v13;
  _QWORD v15[6];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  CFRange v20;
  CFRange v21;

  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("?OTR:"), 0x8000100u, 0x3Fu);
  v20.length = CFDataGetLength(a1);
  v20.location = 0;
  v4 = CFDataFind(a1, ExternalRepresentation, v20, 0);
  if (v4.location == -1)
  {
    v11 = v17;
    v12 = (const __CFData *)v17[3];
    if (v12 != a1)
    {
      if (!a1 || (CFRetain(a1), (v12 = (const __CFData *)v11[3]) != 0))
        CFRelease(v12);
      v11[3] = (uint64_t)a1;
    }
  }
  else
  {
    v5 = CFStringCreateExternalRepresentation(v2, CFSTR("."), 0x8000100u, 0x3Fu);
    v21.length = CFDataGetLength(a1);
    v21.location = 0;
    v6 = CFDataFind(a1, v5, v21, 0).location - v4.length;
    BytePtr = CFDataGetBytePtr(a1);
    v8 = CFDataCreateWithBytesNoCopy(v2, &BytePtr[v4.length], v6, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    CFDataGetBytePtr(v8);
    Length = CFDataGetLength(v8);
    v10 = Length >> 2;
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 0x40000000;
    if ((Length & 3) != 0)
      ++v10;
    v15[2] = __SecOTRCopyIncomingBytes_block_invoke;
    v15[3] = &unk_1E1FD8CA8;
    v15[4] = &v16;
    v15[5] = v8;
    PerformWithBuffer(3 * v10, (uint64_t)v15);
    CFRelease(v8);
    CFRelease(v5);
  }
  CFRelease(ExternalRepresentation);
  v13 = v17[3];
  _Block_object_dispose(&v16, 8);
  return v13;
}

void SecOTRPrepareOutgoingBytes(const __CFData *a1, __CFData *a2)
{
  const __CFAllocator *v4;
  const __CFData *ExternalRepresentation;
  const __CFData *v6;
  CFIndex Length;
  size_t v8;
  uint64_t v9;
  const UInt8 *v10;
  const UInt8 *BytePtr;
  CFIndex v12;
  unsigned __int8 *v13;
  UInt8 *v14;
  unint64_t v15;
  const UInt8 *v16;
  const __CFData *v17;
  const UInt8 *v18;
  CFIndex v19;
  const UInt8 *v20;
  CFIndex v21;
  const UInt8 *v22;
  CFIndex v23;
  _BYTE v24[4];
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("?OTR:"), 0x8000100u, 0x3Fu);
  v6 = CFStringCreateExternalRepresentation(v4, CFSTR("."), 0x8000100u, 0x3Fu);
  CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  v8 = (2 * (((unint64_t)(Length + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
  MEMORY[0x1E0C80A78](Length);
  v10 = &v24[-v9];
  if (v8)
  {
    memset(&v24[-v9], 170, v8);
    BytePtr = CFDataGetBytePtr(a1);
    v12 = CFDataGetLength(a1);
    v13 = (unsigned __int8 *)BytePtr;
    v14 = (UInt8 *)v10;
    v15 = v8;
  }
  else
  {
    v16 = CFDataGetBytePtr(a1);
    v12 = CFDataGetLength(a1);
    v13 = (unsigned __int8 *)v16;
    v14 = (UInt8 *)v10;
    v15 = 0;
  }
  SecBase64Encode_(v13, v12, v14, v15, 0, &v25);
  v17 = CFDataCreateWithBytesNoCopy(v4, v10, v8, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v18 = CFDataGetBytePtr(ExternalRepresentation);
  v19 = CFDataGetLength(ExternalRepresentation);
  CFDataAppendBytes(a2, v18, v19);
  v20 = CFDataGetBytePtr(v17);
  v21 = CFDataGetLength(v17);
  CFDataAppendBytes(a2, v20, v21);
  v22 = CFDataGetBytePtr(v6);
  v23 = CFDataGetLength(v6);
  CFDataAppendBytes(a2, v22, v23);
  CFRelease(ExternalRepresentation);
  CFRelease(v6);
  CFRelease(v17);
}

void hmac_sha1_PRF(void *key, size_t keyLength, const void *a3, size_t a4, void *a5)
{
  __int128 v8;
  CCHmacContext v9;

  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v9.ctx[88] = v8;
  *(_OWORD *)&v9.ctx[92] = v8;
  *(_OWORD *)&v9.ctx[80] = v8;
  *(_OWORD *)&v9.ctx[84] = v8;
  *(_OWORD *)&v9.ctx[72] = v8;
  *(_OWORD *)&v9.ctx[76] = v8;
  *(_OWORD *)&v9.ctx[64] = v8;
  *(_OWORD *)&v9.ctx[68] = v8;
  *(_OWORD *)&v9.ctx[56] = v8;
  *(_OWORD *)&v9.ctx[60] = v8;
  *(_OWORD *)&v9.ctx[48] = v8;
  *(_OWORD *)&v9.ctx[52] = v8;
  *(_OWORD *)&v9.ctx[40] = v8;
  *(_OWORD *)&v9.ctx[44] = v8;
  *(_OWORD *)&v9.ctx[32] = v8;
  *(_OWORD *)&v9.ctx[36] = v8;
  *(_OWORD *)&v9.ctx[24] = v8;
  *(_OWORD *)&v9.ctx[28] = v8;
  *(_OWORD *)&v9.ctx[16] = v8;
  *(_OWORD *)&v9.ctx[20] = v8;
  *(_OWORD *)&v9.ctx[8] = v8;
  *(_OWORD *)&v9.ctx[12] = v8;
  *(_OWORD *)v9.ctx = v8;
  *(_OWORD *)&v9.ctx[4] = v8;
  CCHmacInit(&v9, 0, key, keyLength);
  CCHmacUpdate(&v9, a3, a4);
  CCHmacFinal(&v9, a5);
}

void hmac_sha256_PRF(void *key, size_t keyLength, const void *a3, size_t a4, void *a5)
{
  __int128 v8;
  CCHmacContext v9;

  *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v9.ctx[88] = v8;
  *(_OWORD *)&v9.ctx[92] = v8;
  *(_OWORD *)&v9.ctx[80] = v8;
  *(_OWORD *)&v9.ctx[84] = v8;
  *(_OWORD *)&v9.ctx[72] = v8;
  *(_OWORD *)&v9.ctx[76] = v8;
  *(_OWORD *)&v9.ctx[64] = v8;
  *(_OWORD *)&v9.ctx[68] = v8;
  *(_OWORD *)&v9.ctx[56] = v8;
  *(_OWORD *)&v9.ctx[60] = v8;
  *(_OWORD *)&v9.ctx[48] = v8;
  *(_OWORD *)&v9.ctx[52] = v8;
  *(_OWORD *)&v9.ctx[40] = v8;
  *(_OWORD *)&v9.ctx[44] = v8;
  *(_OWORD *)&v9.ctx[32] = v8;
  *(_OWORD *)&v9.ctx[36] = v8;
  *(_OWORD *)&v9.ctx[24] = v8;
  *(_OWORD *)&v9.ctx[28] = v8;
  *(_OWORD *)&v9.ctx[16] = v8;
  *(_OWORD *)&v9.ctx[20] = v8;
  *(_OWORD *)&v9.ctx[8] = v8;
  *(_OWORD *)&v9.ctx[12] = v8;
  *(_OWORD *)v9.ctx = v8;
  *(_OWORD *)&v9.ctx[4] = v8;
  CCHmacInit(&v9, 2u, key, keyLength);
  CCHmacUpdate(&v9, a3, a4);
  CCHmacFinal(&v9, a5);
}

uint64_t pbkdf2_hmac_sha1(uint64_t a1, uint64_t a2, void *a3, size_t a4, unsigned int a5, char *a6, unint64_t a7)
{
  size_t v14;
  char *v15;
  char *v16;

  v14 = a4 + 60;
  v15 = (char *)malloc_type_malloc(a4 + 60, 0x5B5C87F3uLL);
  if (!v15)
    return 4294899624;
  v16 = v15;
  pbkdf2((void (*)(uint64_t, uint64_t, char *, size_t, char *))hmac_sha1_PRF, 0x14uLL, a1, a2, a3, a4, a5, a6, a7, v15);
  bzero(v16, v14);
  return 0;
}

uint64_t pbkdf2_hmac_sha256(uint64_t a1, uint64_t a2, void *a3, size_t a4, unsigned int a5, char *a6, unint64_t a7)
{
  size_t v14;
  char *v15;
  char *v16;

  v14 = a4 + 96;
  v15 = (char *)malloc_type_malloc(a4 + 96, 0xBFDA9C05uLL);
  if (!v15)
    return 4294899624;
  v16 = v15;
  pbkdf2((void (*)(uint64_t, uint64_t, char *, size_t, char *))hmac_sha256_PRF, 0x20uLL, a1, a2, a3, a4, a5, a6, a7, v15);
  bzero(v16, v14);
  return 0;
}

uint64_t SecKeyFromPassphraseDataHMACSHA1(const __CFData *a1, const __CFData *a2, unsigned int a3, __CFData *a4)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  UInt8 *v10;
  CFIndex v11;
  char *MutableBytePtr;
  CFIndex v13;

  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  v10 = (UInt8 *)CFDataGetBytePtr(a2);
  v11 = CFDataGetLength(a2);
  MutableBytePtr = (char *)CFDataGetMutableBytePtr(a4);
  v13 = CFDataGetLength(a4);
  return pbkdf2_hmac_sha1((uint64_t)BytePtr, Length, v10, v11, a3, MutableBytePtr, v13);
}

uint64_t SecKeyFromPassphraseDataHMACSHA256(const __CFData *a1, const __CFData *a2, unsigned int a3, __CFData *a4)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  UInt8 *v10;
  CFIndex v11;
  char *MutableBytePtr;
  CFIndex v13;

  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  v10 = (UInt8 *)CFDataGetBytePtr(a2);
  v11 = CFDataGetLength(a2);
  MutableBytePtr = (char *)CFDataGetMutableBytePtr(a4);
  v13 = CFDataGetLength(a4);
  return pbkdf2_hmac_sha256((uint64_t)BytePtr, Length, v10, v11, a3, MutableBytePtr, v13);
}

uint64_t CryptoTokenKitLibraryCore()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = CryptoTokenKitLibraryCore_frameworkLibrary;
  v6 = CryptoTokenKitLibraryCore_frameworkLibrary;
  if (!CryptoTokenKitLibraryCore_frameworkLibrary)
  {
    v7 = xmmword_1E1FD8CC8;
    v8 = *(_OWORD *)&off_1E1FD8CD8;
    v1 = _sl_dlopen();
    v4[3] = v1;
    CryptoTokenKitLibraryCore_frameworkLibrary = v1;
    v0 = v1;
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_18AA01B94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

void *CryptoTokenKitLibrary()
{
  uint64_t v0;
  void *v1;
  void *v3;
  void *v4;

  v0 = CryptoTokenKitLibraryCore();
  if (v0)
    return (void *)v0;
  objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *CryptoTokenKitLibrary(void)");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("SecSoftLink.m"), 26, CFSTR("%s"), 0);

  __break(1u);
  free(v4);
  return v1;
}

id getTKClientTokenClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getTKClientTokenClass_softClass;
  v7 = getTKClientTokenClass_softClass;
  if (!getTKClientTokenClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getTKClientTokenClass_block_invoke;
    v3[3] = &unk_1E1FD8CF0;
    v3[4] = &v4;
    __getTKClientTokenClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_18AA01CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getTKClientTokenClass_block_invoke(uint64_t a1)
{
  void *v2;
  void *v3;

  CryptoTokenKitLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("TKClientToken");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getTKClientTokenClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getTKClientTokenClass(void)_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("SecSoftLink.m"), 27, CFSTR("Unable to find class %s"), "TKClientToken");

    __break(1u);
  }
}

id getTKClientTokenSessionClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getTKClientTokenSessionClass_softClass;
  v7 = getTKClientTokenSessionClass_softClass;
  if (!getTKClientTokenSessionClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getTKClientTokenSessionClass_block_invoke;
    v3[3] = &unk_1E1FD8CF0;
    v3[4] = &v4;
    __getTKClientTokenSessionClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_18AA01E7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getTKClientTokenSessionClass_block_invoke(uint64_t a1)
{
  void *v2;
  void *v3;

  CryptoTokenKitLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("TKClientTokenSession");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getTKClientTokenSessionClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getTKClientTokenSessionClass(void)_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("SecSoftLink.m"), 28, CFSTR("Unable to find class %s"), "TKClientTokenSession");

    __break(1u);
  }
}

void *getTKErrorDomainSymbolLoc()
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getTKErrorDomainSymbolLoc_ptr;
  v6 = getTKErrorDomainSymbolLoc_ptr;
  if (!getTKErrorDomainSymbolLoc_ptr)
  {
    v1 = CryptoTokenKitLibrary();
    v0 = dlsym(v1, "TKErrorDomain");
    v4[3] = (uint64_t)v0;
    getTKErrorDomainSymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_18AA01FD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

void getTKErrorDomain()
{
  id *TKErrorDomainSymbolLoc;
  id v1;
  void *v2;
  void *v3;

  TKErrorDomainSymbolLoc = (id *)getTKErrorDomainSymbolLoc();
  if (TKErrorDomainSymbolLoc)
  {
    v1 = *TKErrorDomainSymbolLoc;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "typeof (((typeof (TKErrorDomain) (*)(void))0)()) getTKErrorDomain(void)");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("SecSoftLink.m"), 29, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

uint64_t LocalAuthenticationLibraryCore()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = LocalAuthenticationLibraryCore_frameworkLibrary;
  v6 = LocalAuthenticationLibraryCore_frameworkLibrary;
  if (!LocalAuthenticationLibraryCore_frameworkLibrary)
  {
    v7 = xmmword_1E1FD8D10;
    v8 = *(_OWORD *)&off_1E1FD8D20;
    v1 = _sl_dlopen();
    v4[3] = v1;
    LocalAuthenticationLibraryCore_frameworkLibrary = v1;
    v0 = v1;
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_18AA02130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

void *LocalAuthenticationLibrary()
{
  uint64_t v0;
  void *v1;
  void *v3;
  void *v4;

  v0 = LocalAuthenticationLibraryCore();
  if (v0)
    return (void *)v0;
  objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *LocalAuthenticationLibrary(void)");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("SecSoftLink.m"), 30, CFSTR("%s"), 0);

  __break(1u);
  free(v4);
  return v1;
}

id getLAContextClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getLAContextClass_softClass;
  v7 = getLAContextClass_softClass;
  if (!getLAContextClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getLAContextClass_block_invoke;
    v3[3] = &unk_1E1FD8CF0;
    v3[4] = &v4;
    __getLAContextClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_18AA02298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __getLAContextClass_block_invoke(uint64_t a1)
{
  void *v2;
  void *v3;

  LocalAuthenticationLibrary();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_getClass("LAContext");
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    getLAContextClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "Class getLAContextClass(void)_block_invoke");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("SecSoftLink.m"), 31, CFSTR("Unable to find class %s"), "LAContext");

    __break(1u);
  }
}

void *getLAErrorDomainSymbolLoc()
{
  void *v0;
  void *v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = (void *)getLAErrorDomainSymbolLoc_ptr;
  v6 = getLAErrorDomainSymbolLoc_ptr;
  if (!getLAErrorDomainSymbolLoc_ptr)
  {
    v1 = LocalAuthenticationLibrary();
    v0 = dlsym(v1, "LAErrorDomain");
    v4[3] = (uint64_t)v0;
    getLAErrorDomainSymbolLoc_ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_18AA023F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

void getLAErrorDomain()
{
  id *LAErrorDomainSymbolLoc;
  id v1;
  void *v2;
  void *v3;

  LAErrorDomainSymbolLoc = (id *)getLAErrorDomainSymbolLoc();
  if (LAErrorDomainSymbolLoc)
  {
    v1 = *LAErrorDomainSymbolLoc;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "typeof (((typeof (LAErrorDomain) (*)(void))0)()) getLAErrorDomain(void)");
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, CFSTR("SecSoftLink.m"), 32, CFSTR("%s"), dlerror());

    __break(1u);
  }
}

const __CFString *SecPasswordCreateWithRandomDigits(int a1, const __CFDictionary **a2)
{
  CFNumberRef v3;
  CFNumberRef v4;
  __CFDictionary *Mutable;
  const __CFString *v6;
  int v8;
  int valuePtr;

  v8 = a1;
  valuePtr = a1;
  uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
  lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
  decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  punctuationCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  v4 = CFNumberCreate(0, kCFNumberIntType, &v8);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionaryAddValue(Mutable, (const void *)kSecPasswordMinLengthKey, v3);
  CFDictionaryAddValue(Mutable, (const void *)kSecPasswordMaxLengthKey, v4);
  CFDictionaryAddValue(Mutable, (const void *)kSecPasswordAllowedCharactersKey, CFSTR("0123456789"));
  v6 = SecPasswordGenerate(3, a2, Mutable);
  if (v3)
    CFRelease(v3);
  if (v4)
    CFRelease(v4);
  if (Mutable)
    CFRelease(Mutable);
  return v6;
}

const __CFString *SecPasswordGenerate(int a1, const __CFDictionary **a2, CFDictionaryRef theDict)
{
  CFAllocatorRef *v3;
  CFTypeID v6;
  CFTypeID v7;
  CFTypeID v8;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID v11;
  uint64_t v12;
  CFTypeID v13;
  CFTypeID v14;
  CFTypeID v15;
  CFTypeID v16;
  CFTypeID v17;
  CFTypeID v18;
  CFTypeID v19;
  CFTypeID v20;
  uint64_t v21;
  CFTypeID v22;
  CFTypeID v23;
  CFTypeID v24;
  CFTypeID v25;
  CFTypeID v26;
  CFTypeID v27;
  CFTypeID v28;
  CFTypeID v29;
  CFTypeID v30;
  CFTypeID v31;
  CFTypeID v32;
  CFTypeID v33;
  CFTypeID v34;
  CFTypeID v35;
  CFTypeID v36;
  CFTypeID v37;
  CFTypeID v38;
  CFTypeID v39;
  CFTypeID v40;
  CFTypeID v41;
  CFTypeID v42;
  CFTypeID v43;
  CFTypeID v44;
  CFTypeID v45;
  CFTypeID v46;
  CFTypeID v47;
  CFTypeID v48;
  __CFArray *Mutable;
  const __CFNumber *v50;
  const __CFNumber *v51;
  uint64_t v52;
  CFIndex v53;
  int v54;
  const __CFString *v55;
  const __CFAllocator *v56;
  __CFArray *v57;
  CFNumberRef v58;
  CFNumberRef v59;
  CFNumberRef v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  BOOL v68;
  BOOL v69;
  uint64_t v70;
  int v71;
  int v72;
  const __CFString *v73;
  const __CFString *v74;
  const __CFArray *v75;
  const __CFArray *v76;
  CFIndex i;
  const void *ValueAtIndex;
  const void *v79;
  const __CFString *v80;
  const __CFDictionary *v81;
  const __CFString *Copy;
  CFDictionaryRef v83;
  CFNumberRef v84;
  __CFDictionary *v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  BOOL v93;
  CFIndex Length;
  __CFString *MutableCopy;
  CFNumberRef v96;
  const __CFNumber *v97;
  const __CFNumber *v98;
  CFTypeID v99;
  uint64_t v100;
  const __CFNumber *v101;
  const __CFNumber *v102;
  CFTypeID v103;
  int v104;
  unint64_t v105;
  const __CFString *v106;
  unsigned __int8 *v107;
  void *v108;
  void *v109;
  unsigned __int8 v110;
  uint64_t v111;
  UniChar v112;
  const __CFString *v113;
  const __CFCharacterSet *v114;
  int CharacterFromSet;
  unsigned __int8 v116;
  const __CFString *v117;
  CFMutableStringRef v118;
  CFIndex v119;
  CFRange v120;
  const __CFString *v121;
  const __CFString *v122;
  __CFString *v123;
  const __CFString *v124;
  __CFString *Checksum;
  const __CFArray *v126;
  void *v127;
  const __CFString *v128;
  CFCharacterSetRef v129;
  CFIndex v130;
  CFIndex v131;
  CFComparisonResult v132;
  const __CFString *v133;
  CFCharacterSetRef v134;
  CFComparisonResult v135;
  const __CFNumber *v136;
  const __CFString *v137;
  void *v138;
  const __CFCharacterSet *v139;
  CFIndex v140;
  uint64_t v141;
  const __CFNumber *v142;
  const __CFString *v143;
  void *v144;
  const __CFCharacterSet *v145;
  CFIndex v146;
  uint64_t v147;
  uint64_t v148;
  CFIndex j;
  char CharacterAtIndex;
  uint64_t v151;
  uint64_t v152;
  char v153;
  CFIndex v154;
  const __CFCharacterSet *v155;
  const __CFString *v157;
  uint64_t v158;
  const __CFAllocator *alloc;
  const __CFAllocator *alloca;
  const __CFDictionary *theDicta;
  unint64_t v163;
  CFIndex range;
  unint64_t v165;
  CFNumberRef v166;
  CFNumberRef number;
  CFTypeRef v168;
  void *v169;
  _QWORD v170[4];
  void *v171[4];
  void *v172[4];
  void *v173[4];
  void *value[2];
  CFRange v175;
  CFRange v176;
  CFRange v177;
  CFRange v178;
  CFRange v179;
  CFRange v180;
  CFRange v181;
  CFRange v182;
  CFRange v183;
  CFRange v184;

  v168 = 0;
  v169 = 0;
  v166 = 0;
  number = 0;
  range = 0;
  v165 = 0xAAAAAAAAAAAAAAAALL;
  v163 = 0xAAAAAAAAAAAAAAAALL;
  value[0] = 0;
  v3 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (!theDict)
    goto LABEL_121;
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDefaultForType, (const void **)value))
  {
    if (value[0])
    {
      v6 = CFGetTypeID(value[0]);
      if (v6 == CFStringGetTypeID() && CFStringCompare((CFStringRef)value[0], CFSTR("true"), 0) == kCFCompareEqualTo)
      {
LABEL_111:
        if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDefaultForType, &v168)
          || !v168
          || (v48 = CFGetTypeID(v168), v48 != CFStringGetTypeID())
          || CFStringCompare((CFStringRef)v168, CFSTR("true"), 0))
        {
          alloc = *v3;
          Mutable = CFArrayCreateMutable(*v3, 0, MEMORY[0x1E0C9B378]);
          v173[3] = (void *)0xAAAAAAAAAAAAAAAALL;
          memset(v173, 0, 24);
          memset(v172, 0, sizeof(v172));
          v171[2] = 0;
          v171[3] = 0;
          v50 = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordMinLengthKey);
          v51 = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordMaxLengthKey);
          CFNumberGetValue(v50, kCFNumberSInt64Type, &v173[3]);
          v52 = (uint64_t)v173[3];
          CFNumberGetValue(v51, kCFNumberSInt64Type, &v173[3]);
          v53 = (CFIndex)v173[3];
          v54 = a1;
          if (a1 != 3)
          {
            v68 = v173[3] != (void *)20;
            if (v52)
              v69 = v173[3] == (void *)v52;
            else
              v69 = 0;
            if (!v69)
              v68 = 0;
            if ((uint64_t)v173[3] < 20)
              v68 = 1;
            v70 = 20;
            if (v52 > 20)
              v70 = v52;
            v71 = v173[3] != 0 && v68;
            v69 = v71 == 0;
            v72 = v71 | (v52 > 20);
            if (v69)
              v53 = v70;
            if (v72)
              v55 = CFSTR("false");
            else
              v55 = CFSTR("true");
            v73 = (const __CFString *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordAllowedCharactersKey);
            v74 = v73;
            if (v73)
              CFRetain(v73);
            v75 = (const __CFArray *)CFDictionaryGetValue(theDict, (const void *)kSecPasswordRequiredCharactersKey);
            if (v75)
            {
              v76 = v75;
              for (i = 0; i < CFArrayGetCount(v76); ++i)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v76, i);
                if (ValueAtIndex)
                {
                  v79 = ValueAtIndex;
                  v175.length = CFStringGetLength(v74);
                  v175.location = 0;
                  if (CFStringFindCharacterFromSet(v74, (CFCharacterSetRef)v79, v175, 0, 0))
                    CFArrayAppendValue(Mutable, v79);
                }
              }
LABEL_186:
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDisallowedCharacters, (const void **)&v173[2]))v173[2] = 0;
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordCantEndWithChars, (const void **)&v173[1]))v173[1] = 0;
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordCantStartWithChars, (const void **)v173))v173[0] = 0;
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordGroupSize, (const void **)&v172[3]))
                v172[3] = 0;
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordNumberOfGroups, (const void **)&v172[2]))v172[2] = 0;
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordSeparator, (const void **)&v172[1]))
                v172[1] = 0;
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters, (const void **)v172))v172[0] = 0;
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsAtLeastNSpecificCharacters, (const void **)&v171[3]))v171[3] = 0;
              if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters, (const void **)&v171[2]))v171[2] = 0;
              v56 = alloc;
              if (v74)
              {
                v176.length = CFStringGetLength(v74);
                v176.location = 0;
                if (!CFStringFindWithOptions(v74, CFSTR("-"), v176, 1uLL, 0))
                {
LABEL_209:
                  Length = CFStringGetLength(v74);
                  MutableCopy = CFStringCreateMutableCopy(alloc, Length, v74);
                  v184.length = CFStringGetLength(v74);
                  v184.location = 0;
                  CFStringFindAndReplace(MutableCopy, CFSTR("-"), &stru_1E1FDD448, v184, 1uLL);
                  CFRelease(v74);
                  v55 = CFSTR("false");
                  v74 = MutableCopy;
LABEL_210:
                  if (CFArrayGetCount(Mutable) > v53 && Mutable)
                  {
                    CFRelease(Mutable);
                    Mutable = 0;
                  }
                  value[0] = (void *)v53;
                  v96 = CFNumberCreate(alloc, kCFNumberCFIndexType, value);
                  v85 = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                  CFDictionaryAddValue(v85, CFSTR("UseDefaultPasswordFormat"), v55);
                  CFDictionarySetValue(v85, CFSTR("NumberOfRequiredRandomCharacters"), v96);
                  CFDictionaryAddValue(v85, CFSTR("AllowedCharacters"), v74);
                  if (Mutable)
                    CFDictionaryAddValue(v85, CFSTR("RequiredCharacterSets"), Mutable);
                  if (v173[2])
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordDisallowedCharacters, v173[2]);
                  if (v173[1])
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordCantEndWithChars, v173[1]);
                  if (v173[0])
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordCantStartWithChars, v173[0]);
                  if (v172[3])
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordGroupSize, v172[3]);
                  if (v172[2])
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordNumberOfGroups, v172[2]);
                  if (v172[1])
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordSeparator, v172[1]);
                  if (v172[0])
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters, v172[0]);
                  if (v171[3])
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordContainsAtLeastNSpecificCharacters, v171[3]);
                  if (v171[2])
                    CFDictionaryAddValue(v85, (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters, v171[2]);
                  CFRelease(v55);
                  if (v96)
                    CFRelease(v96);
                  if (v74)
                    CFRelease(v74);
                  if (Mutable)
                    CFRelease(Mutable);
                  goto LABEL_239;
                }
              }
              else
              {
                v74 = CFSTR("abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ123456789");
                CFRetain(CFSTR("abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ123456789"));
              }
              if (v55 != CFSTR("false"))
                goto LABEL_210;
              goto LABEL_209;
            }
            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(Mutable, (const void *)uppercaseLetterCharacterSet);
            v54 = a1;
            CFArrayAppendValue(Mutable, (const void *)lowercaseLetterCharacterSet);
LABEL_185:
            CFArrayAppendValue(Mutable, (const void *)decimalDigitCharacterSet);
            goto LABEL_186;
          }
          if (!v173[3] || !v52)
          {
            if (!v173[3] && v52)
            {
              v55 = CFSTR("false");
              v53 = v52;
LABEL_184:
              v74 = CFSTR("0123456789");
              goto LABEL_185;
            }
            if (v173[3])
              v93 = v52 == 0;
            else
              v93 = 0;
            if (!v93)
              v53 = 4;
          }
          v55 = CFSTR("false");
          goto LABEL_184;
        }
LABEL_121:
        v56 = *v3;
        v57 = CFArrayCreateMutable(*v3, 0, MEMORY[0x1E0C9B378]);
        v173[2] = (void *)0xAAAAAAAAAAAAAAAALL;
        v173[3] = (void *)0xAAAAAAAAAAAAAAAALL;
        switch(a1)
        {
          case 1:
            value[0] = (void *)24;
            v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            v173[3] = (void *)4;
            v173[2] = (void *)6;
            v59 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[3]);
            v60 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[2]);
            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)uppercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            goto LABEL_165;
          case 2:
            v173[3] = (void *)4;
            v173[2] = (void *)3;
            v59 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[3]);
            v60 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[2]);
            lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            value[0] = (void *)12;
            v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            CFArrayAppendValue(v57, (const void *)lowercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            goto LABEL_165;
          case 3:
            value[0] = (void *)4;
            v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            v173[2] = (void *)1;
            v173[3] = (void *)4;
            v59 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[3]);
            v60 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[2]);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            goto LABEL_165;
          case 4:
            v173[3] = (void *)4;
            v173[2] = (void *)7;
            value[0] = (void *)26;
            v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            value[0] = (void *)2;
            v84 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
            v59 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[3]);
            v60 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[2]);
            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)uppercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            v83 = CFDictionaryCreateForCFTypes(v56, v86, v87, v88, v89, v90, v91, v92, (uint64_t)CFSTR("UseDefaultPasswordFormat"), (uint64_t)CFSTR("true"));
            if (!v58)
              goto LABEL_167;
            goto LABEL_166;
          default:
            v173[3] = (void *)4;
            v173[2] = (void *)6;
            v59 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[3]);
            v60 = CFNumberCreate(0, kCFNumberCFIndexType, &v173[2]);
            uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
            lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
            decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
            CFArrayAppendValue(v57, (const void *)uppercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)lowercaseLetterCharacterSet);
            CFArrayAppendValue(v57, (const void *)decimalDigitCharacterSet);
            value[0] = (void *)20;
            v58 = CFNumberCreate(v56, kCFNumberCFIndexType, value);
LABEL_165:
            v83 = CFDictionaryCreateForCFTypes(v56, v61, v62, v63, v64, v65, v66, v67, (uint64_t)CFSTR("UseDefaultPasswordFormat"), (uint64_t)CFSTR("true"));
            v84 = 0;
            if (v58)
LABEL_166:
              CFRelease(v58);
LABEL_167:
            v54 = a1;
            if (v57)
              CFRelease(v57);
            if (v59)
              CFRelease(v59);
            if (v60)
              CFRelease(v60);
            if (v84)
              CFRelease(v84);
            v85 = v83;
            break;
        }
LABEL_239:
        if (!v85)
          return 0;
        theDicta = v85;
        v97 = (const __CFNumber *)CFDictionaryGetValue(v85, CFSTR("NumberOfRequiredRandomCharacters"));
        if (v97 && (v98 = v97, v99 = CFGetTypeID(v97), v99 == CFNumberGetTypeID()))
        {
          if (CFNumberGetValue(v98, kCFNumberSInt64Type, &v165))
            v100 = v165;
          else
            v100 = 0;
        }
        else
        {
          v100 = 0;
        }
        v101 = (const __CFNumber *)CFDictionaryGetValue(v85, CFSTR("NumberOfChecksumCharacters"));
        if (v101 && (v102 = v101, v103 = CFGetTypeID(v101), v103 == CFNumberGetTypeID()))
        {
          v104 = CFNumberGetValue(v102, kCFNumberSInt64Type, &v165);
          v105 = v165;
          if (!v104)
            v105 = 0;
          v158 = v105;
        }
        else
        {
          v158 = 0;
        }
        v81 = v85;
        if (CFDictionaryGetValueIfPresent(v85, (const void *)kSecPasswordGroupSize, (const void **)&number))
          CFNumberGetValue(number, kCFNumberSInt64Type, &range);
        else
          number = 0;
        if (CFDictionaryGetValueIfPresent(v85, (const void *)kSecPasswordNumberOfGroups, (const void **)&v166))
        {
          CFNumberGetValue(v166, kCFNumberSInt64Type, &v163);
          if (!v100)
            goto LABEL_358;
        }
        else
        {
          v166 = 0;
          if (!v100)
            goto LABEL_358;
        }
        alloca = v56;
LABEL_260:
        v106 = (const __CFString *)CFDictionaryGetValue(v81, CFSTR("AllowedCharacters"));
        v107 = (unsigned __int8 *)malloc_type_malloc(v100, 0xE2F0E646uLL);
        v108 = malloc_type_malloc(v100, 0xCB6CC926uLL);
        v109 = v108;
        if (!v107 || !v108)
        {
          free(v107);
          free(v109);
          v81 = theDicta;
          goto LABEL_358;
        }
        v110 = CFStringGetLength(v106);
        getUniformRandomNumbers((uint64_t)v107, v100, v110);
        value[0] = 0;
        if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordDisallowedCharacters, (const void **)value))value[0] = 0;
        if (v100 < 1)
        {
LABEL_276:
          v117 = CFStringCreateWithBytes(alloca, (const UInt8 *)v109, v100, 0x8000100u, 0);
          free(v109);
          free(v107);
          if (!v166 || !number)
          {
            Copy = CFStringCreateCopy(alloca, v117);
            goto LABEL_299;
          }
          v118 = CFStringCreateMutable(alloca, 0);
          if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordSeparator, (const void **)&v169)
            || !v169)
          {
            v169 = CFSTR("-");
          }
          v119 = 0;
          v120.length = range;
          while (1)
          {
            if (v120.length + v119 >= v100)
            {
              if (v120.length + v119 != v100)
              {
                v178.length = v100 - v119;
                v178.location = v119;
                v124 = CFStringCreateWithSubstring(alloca, v117, v178);
                CFStringAppend(v118, v124);
                if (v124)
                  CFRelease(v124);
LABEL_294:
                if (v158)
                {
                  Checksum = CreateChecksum(v54, v117, v158, v106);
                  CFStringAppend(v118, Checksum);
                  if (Checksum)
                    CFRelease(Checksum);
                }
                Copy = CFStringCreateCopy(alloca, v118);
                if (v118)
                  CFRelease(v118);
LABEL_299:
                if (v117)
                  CFRelease(v117);
                value[0] = 0;
                v172[3] = (void *)0xAAAAAAAAAAAAAAAALL;
                memset(v173, 0, sizeof(v173));
                v126 = (const __CFArray *)CFDictionaryGetValue(theDicta, CFSTR("RequiredCharacterSets"));
                if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordCantEndWithChars, (const void **)&v173[3]))v173[3] = 0;
                if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordCantStartWithChars, (const void **)&v173[2]))v173[2] = 0;
                if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordContainsAtLeastNSpecificCharacters, (const void **)&v173[1]))v173[1] = 0;
                if (!CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters, (const void **)v173))v173[0] = 0;
                if (CFDictionaryGetValueIfPresent(theDicta, (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters, (const void **)value))
                {
                  CFNumberGetValue((CFNumberRef)value[0], kCFNumberSInt64Type, &v172[3]);
                  v127 = v172[3];
                }
                else
                {
                  v127 = 0;
                  value[0] = 0;
                }
                v128 = (const __CFString *)v173[3];
                if (v173[3])
                {
                  v129 = CFCharacterSetCreateWithCharactersInString(alloca, (CFStringRef)v173[3]);
                  v130 = CFStringGetLength(Copy);
                  v131 = v130 - CFStringGetLength(v128);
                  v179.length = CFStringGetLength(v128);
                  v179.location = v131;
                  v132 = CFStringCompareWithOptions(Copy, v128, v179, 0);
                  if (v129)
                    CFRelease(v129);
                  if (v132 == kCFCompareEqualTo)
                    goto LABEL_351;
                }
                v133 = (const __CFString *)v173[2];
                if (v173[2])
                {
                  v134 = CFCharacterSetCreateWithCharactersInString(alloca, (CFStringRef)v173[2]);
                  v180.length = CFStringGetLength(v133);
                  v180.location = 0;
                  v135 = CFStringCompareWithOptions(Copy, v133, v180, 0);
                  if (v134)
                    CFRelease(v134);
                  if (v135 == kCFCompareEqualTo)
                    goto LABEL_351;
                }
                if (v173[1])
                {
                  v136 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v173[1], (const void *)kSecPasswordCharacterCount);
                  v137 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v173[1], (const void *)kSecPasswordCharacters);
                  CFNumberGetValue(v136, kCFNumberSInt64Type, &v172[3]);
                  v138 = v172[3];
                  v139 = CFCharacterSetCreateWithCharactersInString(alloca, v137);
                  v140 = 0;
                  v141 = 0;
                  while (v140 < CFStringGetLength(Copy))
                  {
                    v181.location = v140;
                    v181.length = 1;
                    if (CFStringFindCharacterFromSet(Copy, v139, v181, 0, 0))
                      ++v141;
                    ++v140;
                  }
                  if (v139)
                    CFRelease(v139);
                  if (v141 < (uint64_t)v138)
                    goto LABEL_351;
                }
                if (!v173[0])
                  goto LABEL_338;
                v142 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v173[0], (const void *)kSecPasswordCharacterCount);
                v143 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v173[0], (const void *)kSecPasswordCharacters);
                CFNumberGetValue(v142, kCFNumberSInt64Type, &v172[3]);
                v144 = v172[3];
                v145 = CFCharacterSetCreateWithCharactersInString(alloca, v143);
                v146 = 0;
                v147 = 0;
                while (v146 < CFStringGetLength(Copy))
                {
                  v182.location = v146;
                  v182.length = 1;
                  if (CFStringFindCharacterFromSet(Copy, v145, v182, 0, 0))
                    ++v147;
                  ++v146;
                }
                if (v145)
                  CFRelease(v145);
                if (v147 > (uint64_t)v144)
                {
LABEL_351:
                  v54 = a1;
                }
                else
                {
LABEL_338:
                  if (value[0])
                  {
                    LODWORD(v148) = 0;
                    for (j = 0; j < CFStringGetLength(Copy); ++j)
                    {
                      CharacterAtIndex = CFStringGetCharacterAtIndex(Copy, j);
                      v151 = 0;
                      v152 = (int)v148;
                      while (1)
                      {
                        v148 = v152 + v151;
                        if (j + v151 >= CFStringGetLength(Copy))
                          break;
                        v153 = CFStringGetCharacterAtIndex(Copy, j + v151);
                        if (v148 > (uint64_t)v127)
                          goto LABEL_351;
                        if (v153 != CharacterAtIndex)
                        {
                          LODWORD(v148) = 0;
                          break;
                        }
                        ++v151;
                      }
                    }
                  }
                  v154 = 0;
                  while (v154 < CFArrayGetCount(v126))
                  {
                    v155 = (const __CFCharacterSet *)CFArrayGetValueAtIndex(v126, v154);
                    v183.length = CFStringGetLength(Copy);
                    v183.location = 0;
                    ++v154;
                    if (!CFStringFindCharacterFromSet(Copy, v155, v183, 0, 0))
                      goto LABEL_351;
                  }
                  v54 = a1;
                  if (!SecPasswordIsPasswordWeak2(a1 == 3, Copy))
                  {
                    CFRelease(theDicta);
                    return Copy;
                  }
                }
                v81 = theDicta;
                if (Copy)
                  CFRelease(Copy);
                goto LABEL_260;
              }
              v120.location = v119;
              v121 = CFStringCreateWithSubstring(alloca, v117, v120);
              v123 = v118;
              v122 = v121;
            }
            else
            {
              v120.location = v119;
              v121 = CFStringCreateWithSubstring(alloca, v117, v120);
              CFStringAppend(v118, v121);
              v122 = (const __CFString *)v169;
              v123 = v118;
            }
            CFStringAppend(v123, v122);
            if (v121)
              CFRelease(v121);
            v120.length = range;
            v119 += range;
            if (v119 == v100)
              goto LABEL_294;
          }
        }
        v111 = 0;
        while (1)
        {
          LOWORD(v173[3]) = -21846;
          v112 = CFStringGetCharacterAtIndex(v106, v107[v111]);
          LOWORD(v173[3]) = v112;
          if (!value[0])
            goto LABEL_274;
          v113 = CFStringCreateWithCharacters(alloca, (const UniChar *)&v173[3], 1);
          v114 = CFCharacterSetCreateWithCharactersInString(alloca, (CFStringRef)value[0]);
          v177.length = CFStringGetLength(v113);
          v177.location = 0;
          CharacterFromSet = CFStringFindCharacterFromSet(v113, v114, v177, 0, 0);
          if (v114)
            CFRelease(v114);
          if (v113)
            CFRelease(v113);
          if (!CharacterFromSet)
            break;
          v116 = CFStringGetLength(v106);
          getUniformRandomNumbers((uint64_t)v107, v100, v116);
          --v111;
LABEL_275:
          if (++v111 >= v100)
            goto LABEL_276;
        }
        LOBYTE(v112) = v173[3];
LABEL_274:
        *((_BYTE *)v109 + v111) = v112;
        goto LABEL_275;
      }
    }
  }
  if (a1 == 3)
  {
    v173[2] = 0;
    v173[3] = 0;
    v173[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDefaultForType, (const void **)value))
    {
      if (value[0])
      {
        v7 = CFGetTypeID(value[0]);
        if (v7 == CFStringGetTypeID()
          && CFStringCompare((CFStringRef)value[0], CFSTR("true"), 0) == kCFCompareEqualTo)
        {
          goto LABEL_111;
        }
      }
    }
    if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordMaxLengthKey, (const void **)&v173[2]))
      goto LABEL_388;
    if (!v173[2])
      goto LABEL_375;
    v8 = CFGetTypeID(v173[2]);
    if (v8 == CFNullGetTypeID())
    {
      v80 = CFSTR("To generate a password, need a max length");
      goto LABEL_158;
    }
    if (v173[2] && (v9 = CFGetTypeID(v173[2]), v9 == CFNumberGetTypeID()))
    {
LABEL_388:
      if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordMinLengthKey, (const void **)&v173[3]))
      {
        if (!v173[3])
          goto LABEL_385;
        v10 = CFGetTypeID(v173[3]);
        if (v10 == CFNullGetTypeID())
        {
          v80 = CFSTR("To generate a password, need a min length");
          goto LABEL_158;
        }
        if (!v173[3] || (v11 = CFGetTypeID(v173[3]), v11 != CFNumberGetTypeID()))
        {
LABEL_385:
          v80 = CFSTR("The password's min length must be a CFNumberRef");
          goto LABEL_158;
        }
      }
      if (v173[2])
      {
        CFNumberGetValue((CFNumberRef)v173[2], kCFNumberSInt64Type, &v173[1]);
        v12 = (uint64_t)v173[1];
      }
      else
      {
        v12 = 0;
      }
      if (v173[3])
      {
        CFNumberGetValue((CFNumberRef)v173[3], kCFNumberSInt64Type, &v173[1]);
        v80 = CFSTR("The password's length parameters make no sense(is max < min ?)");
        if (v173[1])
        {
          if (v12)
          {
            if ((uint64_t)v173[1] <= v12)
            {
              v81 = 0;
              if ((uint64_t)v173[1] > 3 || v12 > 3)
              {
LABEL_159:
                if (v81)
                  goto LABEL_160;
                goto LABEL_111;
              }
            }
          }
        }
      }
      else
      {
        v80 = CFSTR("The password's length parameters make no sense(is max < min ?)");
      }
    }
    else
    {
LABEL_375:
      v80 = CFSTR("The password's max length must be a CFNumberRef");
    }
LABEL_158:
    v81 = CFErrorCreate(*v3, v80, -909, 0);
    goto LABEL_159;
  }
  memset(v173, 170, sizeof(v173));
  memset(v172, 170, sizeof(v172));
  memset(v171, 170, sizeof(v171));
  memset(v170, 170, sizeof(v170));
  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordAllowedCharactersKey, (const void **)&v173[3]))
    goto LABEL_364;
  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordMaxLengthKey, (const void **)&v173[2]))
    goto LABEL_373;
  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordMinLengthKey, (const void **)&v173[1]))
  {
LABEL_374:
    v157 = CFSTR("To generate a password, need a min length");
    goto LABEL_381;
  }
  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordRequiredCharactersKey, (const void **)v173))
  {
LABEL_365:
    v157 = CFSTR("Need an array of character sets, password must have at least 1 character from each set");
    goto LABEL_381;
  }
  if (v173[3])
  {
    v13 = CFGetTypeID(v173[3]);
    if (v13 == CFNullGetTypeID())
    {
LABEL_364:
      v157 = CFSTR("Need a string of characters; password must only contain characters in this string");
      goto LABEL_381;
    }
  }
  if (v173[2])
  {
    v14 = CFGetTypeID(v173[2]);
    if (v14 == CFNullGetTypeID())
    {
LABEL_373:
      v157 = CFSTR("To generate a password, need a max length");
      goto LABEL_381;
    }
  }
  if (v173[1])
  {
    v15 = CFGetTypeID(v173[1]);
    if (v15 == CFNullGetTypeID())
      goto LABEL_374;
  }
  if (v173[0])
  {
    v16 = CFGetTypeID(v173[0]);
    if (v16 == CFNullGetTypeID())
      goto LABEL_365;
  }
  if (!v173[3] || (v17 = CFGetTypeID(v173[3]), v17 != CFStringGetTypeID()))
  {
    v157 = CFSTR("The password's allowed characters must be a CFStringRef");
    goto LABEL_381;
  }
  if (!v173[2] || (v18 = CFGetTypeID(v173[2]), v18 != CFNumberGetTypeID()))
  {
    v157 = CFSTR("The password's max length must be a CFNumberRef");
    goto LABEL_381;
  }
  if (!v173[1] || (v19 = CFGetTypeID(v173[1]), v19 != CFNumberGetTypeID()))
  {
    v157 = CFSTR("The password's min length must be a CFNumberRef");
    goto LABEL_381;
  }
  if (!v173[0] || (v20 = CFGetTypeID(v173[0]), v20 != CFArrayGetTypeID()))
  {
    v157 = CFSTR("The password's required characters must be an array of CFCharacterSetRefs");
    goto LABEL_381;
  }
  CFNumberGetValue((CFNumberRef)v173[1], kCFNumberSInt64Type, v170);
  v21 = v170[0];
  CFNumberGetValue((CFNumberRef)v173[2], kCFNumberSInt64Type, v170);
  if (v21 > v170[0])
  {
    v157 = CFSTR("The password's length parameters make no sense(is max < min ?)");
    goto LABEL_381;
  }
  if (!CFStringGetLength((CFStringRef)v173[3]))
    goto LABEL_364;
  if (!CFArrayGetCount((CFArrayRef)v173[0]))
    goto LABEL_365;
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordDisallowedCharacters, (const void **)&v172[3]))
  {
    if (!v172[3]
      || (v22 = CFGetTypeID(v172[3]), v22 == CFNullGetTypeID())
      || !v172[3]
      || (v23 = CFGetTypeID(v172[3]), v23 != CFStringGetTypeID()))
    {
      v157 = CFSTR("Disallowed Characters dictionary parameter is either null or not a string");
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordCantEndWithChars, (const void **)&v172[2]))
  {
    if (!v172[2]
      || (v24 = CFGetTypeID(v172[2]), v24 == CFNullGetTypeID())
      || !v172[2]
      || (v25 = CFGetTypeID(v172[2]), v25 != CFStringGetTypeID()))
    {
      v157 = CFSTR("The dictionary parameter 'EndWith' is either null or not a string");
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordCantStartWithChars, (const void **)&v172[1]))
  {
    if (!v172[1]
      || (v26 = CFGetTypeID(v172[1]), v26 == CFNullGetTypeID())
      || !v172[1]
      || (v27 = CFGetTypeID(v172[1]), v27 != CFStringGetTypeID()))
    {
      v157 = CFSTR("The dictionary parameter 'StartWith' is either null or not a string");
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordGroupSize, (const void **)v172))
  {
    if (!v172[0]
      || (v28 = CFGetTypeID(v172[0]), v28 == CFNullGetTypeID())
      || !v172[0]
      || (v29 = CFGetTypeID(v172[0]), v29 != CFNumberGetTypeID()))
    {
      v157 = CFSTR("The dictionary parameter 'groupsize' is either null or not a number");
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordNumberOfGroups, (const void **)&v171[3]))
  {
    if (!v171[3]
      || (v30 = CFGetTypeID(v171[3]), v30 == CFNullGetTypeID())
      || !v171[3]
      || (v31 = CFGetTypeID(v171[3]), v31 != CFNumberGetTypeID()))
    {
      v157 = CFSTR("The dictionary parameter 'number of groupds' is either null or not a number");
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordSeparator, (const void **)&v171[2]))
  {
    if (!v171[2]
      || (v32 = CFGetTypeID(v171[2]), v32 == CFNullGetTypeID())
      || !v171[2]
      || (v33 = CFGetTypeID(v171[2]), v33 != CFStringGetTypeID()))
    {
      v157 = CFSTR("The dictionary parameter 'password separator character' is either null or not a string");
      goto LABEL_381;
    }
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsNoMoreThanNSpecificCharacters, (const void **)&v171[1]))
  {
    if (!v171[1])
      goto LABEL_362;
    v34 = CFGetTypeID(v171[1]);
    if (v34 == CFNullGetTypeID())
      goto LABEL_362;
    if (!v171[1])
      goto LABEL_362;
    v35 = CFGetTypeID(v171[1]);
    if (v35 != CFDictionaryGetTypeID()
      || !CFDictionaryGetValueIfPresent((CFDictionaryRef)v171[1], (const void *)kSecPasswordCharacterCount, (const void **)&v170[3]))
    {
      goto LABEL_362;
    }
    if (!v170[3])
      goto LABEL_360;
    v36 = CFGetTypeID((CFTypeRef)v170[3]);
    if (v36 == CFNullGetTypeID())
      goto LABEL_360;
    if (!v170[3])
      goto LABEL_360;
    v37 = CFGetTypeID((CFTypeRef)v170[3]);
    if (v37 != CFNumberGetTypeID())
      goto LABEL_360;
    if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)v171[1], (const void *)kSecPasswordCharacters, (const void **)&v170[1]))
    {
LABEL_362:
      v157 = CFSTR("The dictionary parameter 'At Most N Characters' is either null or not a string");
      goto LABEL_381;
    }
    if (!v170[1])
      goto LABEL_361;
    v38 = CFGetTypeID((CFTypeRef)v170[1]);
    if (v38 == CFNullGetTypeID())
      goto LABEL_361;
    if (!v170[1])
      goto LABEL_361;
    v39 = CFGetTypeID((CFTypeRef)v170[1]);
    if (v39 != CFStringGetTypeID())
      goto LABEL_361;
  }
  if (CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsAtLeastNSpecificCharacters, (const void **)v171))
  {
    if (!v171[0])
      goto LABEL_363;
    v40 = CFGetTypeID(v171[0]);
    if (v40 == CFNullGetTypeID())
      goto LABEL_363;
    if (!v171[0])
      goto LABEL_363;
    v41 = CFGetTypeID(v171[0]);
    if (v41 != CFDictionaryGetTypeID()
      || !CFDictionaryGetValueIfPresent((CFDictionaryRef)v171[0], (const void *)kSecPasswordCharacterCount, (const void **)&v170[3]))
    {
      goto LABEL_363;
    }
    if (v170[3])
    {
      v42 = CFGetTypeID((CFTypeRef)v170[3]);
      if (v42 != CFNullGetTypeID())
      {
        if (v170[3])
        {
          v43 = CFGetTypeID((CFTypeRef)v170[3]);
          if (v43 == CFNumberGetTypeID())
          {
            if (CFDictionaryGetValueIfPresent((CFDictionaryRef)v171[0], (const void *)kSecPasswordCharacters, (const void **)&v170[1]))
            {
              if (v170[1])
              {
                v44 = CFGetTypeID((CFTypeRef)v170[1]);
                if (v44 != CFNullGetTypeID())
                {
                  if (v170[1])
                  {
                    v45 = CFGetTypeID((CFTypeRef)v170[1]);
                    if (v45 == CFStringGetTypeID())
                      goto LABEL_106;
                  }
                }
              }
LABEL_361:
              v157 = CFSTR("The dictionary parameter 'Characters' is either null or not a string");
              goto LABEL_381;
            }
LABEL_363:
            v157 = CFSTR("The dictionary parameter 'At Least N Characters' is either null or not a string");
            goto LABEL_381;
          }
        }
      }
    }
LABEL_360:
    v157 = CFSTR("The dictionary parameter 'characters' is either null or not a number");
    goto LABEL_381;
  }
LABEL_106:
  if (!CFDictionaryGetValueIfPresent(theDict, (const void *)kSecPasswordContainsNoMoreThanNConsecutiveIdenticalCharacters, (const void **)&v170[2]))goto LABEL_111;
  if (v170[2])
  {
    v46 = CFGetTypeID((CFTypeRef)v170[2]);
    if (v46 != CFNullGetTypeID())
    {
      if (v170[2])
      {
        v47 = CFGetTypeID((CFTypeRef)v170[2]);
        if (v47 == CFNumberGetTypeID())
          goto LABEL_111;
      }
    }
  }
  v157 = CFSTR("The dictionary parameter 'Identical Consecutive Characters' is either null or not a number");
LABEL_381:
  v81 = CFErrorCreate(*v3, v157, -909, 0);
  if (!v81)
    goto LABEL_111;
LABEL_160:
  CFRetain(v81);
  CFRelease(v81);
  if (!a2)
  {
LABEL_358:
    CFRelease(v81);
    return 0;
  }
  Copy = 0;
  *a2 = v81;
  return Copy;
}

uint64_t getUniformRandomNumbers(uint64_t a1, unint64_t a2, unsigned int a3)
{
  unint64_t v6;
  unsigned int v7;
  uint64_t result;
  unint64_t v9;
  unsigned __int8 *v10;
  unsigned int v11;
  unsigned int v12;

  v6 = 0;
  v7 = (0xFF % a3) ^ 0xFF;
  do
  {
    do
      result = CCRandomCopyBytes();
    while ((_DWORD)result == -1);
    v9 = a2 - v6;
    if (a2 > v6)
    {
      v10 = (unsigned __int8 *)(a1 + v6);
      do
      {
        v12 = *v10++;
        v11 = v12;
        if (v12 < v7)
          *(_BYTE *)(a1 + v6++) = v11 % a3;
        --v9;
      }
      while (v9);
    }
  }
  while (a2 > v6);
  return result;
}

__CFString *CreateChecksum(int a1, CFStringRef theString, uint64_t a3, const __CFString *a4)
{
  uint64_t v4;
  __int128 v5;
  CFDataRef ExternalRepresentation;
  const __CFData *v9;
  CFIndex Length;
  __CFString *Mutable;
  unsigned __int8 *v12;
  unsigned int v13;
  UniChar chars;
  _OWORD v16[2];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a1 != 4)
    return 0;
  v4 = a3;
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[0] = v5;
  v16[1] = v5;
  if (a3 > 32)
    return 0;
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, theString, 0x8000100u, 0);
  if (!ExternalRepresentation)
    return 0;
  v9 = ExternalRepresentation;
  ccsha256_di();
  CFDataGetLength(v9);
  CFDataGetBytePtr(v9);
  ccdigest();
  CFRelease(v9);
  Length = CFStringGetLength(a4);
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  Mutable = CFStringCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  if (v4 >= 1)
  {
    v12 = (unsigned __int8 *)v16;
    do
    {
      v13 = *v12++;
      chars = -21846;
      chars = CFStringGetCharacterAtIndex(a4, v13 % Length);
      CFStringAppendCharacters(Mutable, &chars, 1);
      --v4;
    }
    while (v4);
  }
  return Mutable;
}

BOOL SecPasswordIsPasswordWeak2(int a1, const __CFString *a2)
{
  CFIndex v4;
  int v5;
  int v6;
  int v7;
  CFIndex v8;
  int v9;
  CFIndex Length;
  CFIndex v11;
  char *v12;
  CFIndex v13;
  CFIndex v14;
  int v15;
  int v16;
  double v17;
  CFIndex v19;
  CFIndex v20;
  CFIndex v21;
  const __CFAllocator *v22;
  __CFArray *Mutable;
  CFIndex i;
  int CharacterAtIndex;
  int v26;
  int v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFIndex v30;
  const __CFNumber *v31;
  const __CFNumber *ValueAtIndex;
  uint64_t v33;
  CFIndex v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  int v46;
  uint64_t v47;
  CFIndex v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned __int8 *v56;
  int v57;
  int v58;
  int valuePtr;
  CFRange v60;
  CFRange v61;
  CFRange v62;
  CFRange v63;
  CFRange v64;

  uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
  lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
  decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  punctuationCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  if (CFStringGetLength(a2) < 4)
    return 1;
  v4 = 0;
  do
  {
    if (v4 >= CFStringGetLength(a2))
    {
      if (a1)
      {
        if (CFStringGetLength(a2) == 4)
        {
          if (a2)
          {
            CFRetain(a2);
            Length = CFStringGetLength(a2);
            v11 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
            v12 = (char *)malloc_type_malloc(v11, 0x5ECC0363uLL);
            if (!CFStringGetCString(a2, v12, v11, 0x8000100u))
              *v12 = 0;
            CFRelease(a2);
          }
          else
          {
            v12 = strdup((const char *)&unk_18AA61AAF);
          }
          if (!in_word_set((unsigned __int8 *)v12))
          {
            v43 = *v12;
            v44 = v12[1];
            if (((v43 == v44) == v12[2]) != v12[3])
            {
              v45 = v12[2];
              v46 = v12[3];
              if ((v43 != v44 || v45 != v46) && (v43 != v45 || v44 != v46))
              {
                v47 = 0;
                while (strcmp(blacklist[v47], v12))
                {
                  if (++v47 == 7)
                    goto LABEL_100;
                }
              }
            }
          }
          goto LABEL_98;
        }
        if (CFStringGetLength(a2) != 6)
          return 0;
        if (a2)
        {
          CFRetain(a2);
          v19 = CFStringGetLength(a2);
          v20 = CFStringGetMaximumSizeForEncoding(v19, 0x8000100u) + 1;
          v12 = (char *)malloc_type_malloc(v20, 0x5ECC0363uLL);
          if (!CFStringGetCString(a2, v12, v20, 0x8000100u))
            *v12 = 0;
          CFRelease(a2);
        }
        else
        {
          v12 = strdup((const char *)&unk_18AA61AAF);
        }
        v48 = 0;
        do
        {
          if (CFStringGetLength(a2) <= v48)
            break;
          if (v48 == CFStringGetLength(a2) - 1)
            goto LABEL_98;
          v56 = (unsigned __int8 *)&v12[v48];
          v57 = v12[v48++];
        }
        while (v57 == v56[1]);
        if (isTopTenSixDigitPasscode(a2, v49, v50, v51, v52, v53, v54, v55)
          || SecPasswordIsPalindrome(a2)
          || SecPasswordHasRepeatingGroups(a2))
        {
LABEL_98:
          free(v12);
          return 1;
        }
      }
      else
      {
        if (a2)
        {
          CFRetain(a2);
          v13 = CFStringGetLength(a2);
          v14 = CFStringGetMaximumSizeForEncoding(v13, 0x8000100u) + 1;
          v12 = (char *)malloc_type_malloc(v14, 0x5ECC0363uLL);
          if (!CFStringGetCString(a2, v12, v14, 0x8000100u))
            *v12 = 0;
          CFRelease(a2);
        }
        else
        {
          v12 = strdup((const char *)&unk_18AA61AAF);
        }
        valuePtr = 1;
        v21 = CFStringGetLength(a2);
        v22 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        if (v21 > 0)
        {
          if (v21 != 1)
          {
            for (i = 1; i != v21; ++i)
            {
              CharacterAtIndex = CFStringGetCharacterAtIndex(a2, i - 1);
              v26 = CFStringGetCharacterAtIndex(a2, i);
              v27 = valuePtr;
              if (CharacterAtIndex == v26)
              {
                v27 = valuePtr + 1;
              }
              else if (valuePtr != 1)
              {
                v28 = CFNumberCreate(v22, kCFNumberIntType, &valuePtr);
                CFArrayAppendValue(Mutable, v28);
                if (v28)
                  CFRelease(v28);
                v27 = 1;
              }
              valuePtr = v27;
            }
          }
          v29 = CFNumberCreate(v22, kCFNumberIntType, &valuePtr);
          CFArrayAppendValue(Mutable, v29);
          if (v29)
            CFRelease(v29);
        }
        v30 = 0;
        v31 = 0;
        while (CFArrayGetCount(Mutable) > v30)
        {
          if (v30)
          {
            ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(Mutable, v30);
            if (CFNumberCompare(ValueAtIndex, v31, 0) == kCFCompareGreaterThan)
              v31 = ValueAtIndex;
          }
          else
          {
            v31 = (const __CFNumber *)CFArrayGetValueAtIndex(Mutable, 0);
          }
          ++v30;
        }
        v58 = 0;
        if (v31)
          CFNumberGetValue(v31, kCFNumberIntType, &v58);
        if (Mutable)
          CFRelease(Mutable);
        v33 = v58;
        v34 = CFStringGetLength(a2);
        if (v34 >= 0)
          v35 = v34;
        else
          v35 = v34 + 1;
        if (v33 >= v35 >> 1
          || SecPasswordIsPalindrome(a2)
          || isTopTenSixDigitPasscode(a2, v36, v37, v38, v39, v40, v41, v42)
          || SecPasswordHasRepeatingGroups(a2) && CFStringGetLength(a2) >= 6)
        {
          goto LABEL_98;
        }
      }
      if (!SecPasswordIsPasscodeIncrementingOrDecrementingDigits(a2)
        && !SecPasswordIsPasswordRepeatingTwoNumbers(a2))
      {
LABEL_100:
        if (v12)
          free(v12);
        return 0;
      }
      goto LABEL_98;
    }
    v60.location = v4;
    v60.length = 1;
    ++v4;
  }
  while (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)decimalDigitCharacterSet, v60, 0, 0));
  if ((a1 & 1) != 0)
    return 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  while (v8 < CFStringGetLength(a2))
  {
    v61.location = v8;
    v61.length = 1;
    if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)uppercaseLetterCharacterSet, v61, 4uLL, 0))
    {
      ++v9;
    }
    else
    {
      v62.location = v8;
      v62.length = 1;
      if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)lowercaseLetterCharacterSet, v62, 4uLL, 0))
      {
        ++v5;
      }
      else
      {
        v63.location = v8;
        v63.length = 1;
        if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)decimalDigitCharacterSet, v63, 4uLL, 0))
        {
          ++v6;
        }
        else
        {
          v64.location = v8;
          v64.length = 1;
          if (CFStringFindCharacterFromSet(a2, (CFCharacterSetRef)punctuationCharacterSet, v64, 4uLL, 0))
            ++v7;
        }
      }
    }
    ++v8;
  }
  if (v9 <= 0)
    v15 = 0;
  else
    v15 = 26;
  if (v5 > 0)
    v15 += 26;
  if (v6 > 0)
    v15 += 10;
  if (v7 <= 0)
    v16 = v15;
  else
    v16 = v15 + 33;
  v17 = (double)CFStringGetLength(a2);
  return log2((double)v16) * v17 < 35.0;
}

const char *in_word_set(unsigned __int8 *a1)
{
  int v1;
  int v2;
  uint64_t v3;
  const char *v4;
  unsigned int v5;
  unsigned int v6;
  const char *v7;

  v1 = pinhash_asso_values[a1[3] + 9];
  v2 = pinhash_asso_values[a1[2]];
  v3 = *a1;
  v5 = a1[1];
  v4 = (const char *)(a1 + 1);
  v6 = v1 + v2 + pinhash_asso_values[v5] + pinhash_asso_values[v3 + 3] + 4;
  if (v6 > 0x113)
    return 0;
  v7 = (const char *)*(&in_word_set_wordlist + v6);
  if ((_DWORD)v3 != *(unsigned __int8 *)v7 || strcmp(v4, v7 + 1))
    return 0;
  return v7;
}

BOOL isTopTenSixDigitPasscode(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFArray *MutableForCFTypesWith;
  CFIndex i;
  CFIndex Count;
  const void *ValueAtIndex;

  MutableForCFTypesWith = CFArrayCreateMutableForCFTypesWith((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2, a3, a4, a5, a6, a7, a8, CFSTR("030379"), (uint64_t)CFSTR("101471"));
  for (i = 0; ; ++i)
  {
    Count = CFArrayGetCount(MutableForCFTypesWith);
    if (i >= Count)
      break;
    ValueAtIndex = CFArrayGetValueAtIndex(MutableForCFTypesWith, i);
    if (a1 && ValueAtIndex)
    {
      if (CFEqual(a1, ValueAtIndex))
        break;
    }
    else if (ValueAtIndex == a1)
    {
      break;
    }
  }
  if (MutableForCFTypesWith)
    CFRelease(MutableForCFTypesWith);
  return i < Count;
}

uint64_t SecPasswordIsPalindrome(const __CFString *cf)
{
  CFIndex Length;
  CFIndex v3;
  char *v4;
  CFIndex v5;
  CFIndex v6;
  CFIndex v7;
  CFIndex v8;
  int v9;
  int v10;

  if (cf)
  {
    CFRetain(cf);
    Length = CFStringGetLength(cf);
    v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    v4 = (char *)malloc_type_malloc(v3, 0x5ECC0363uLL);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u))
      *v4 = 0;
    CFRelease(cf);
  }
  else
  {
    v4 = strdup((const char *)&unk_18AA61AAF);
  }
  v5 = CFStringGetLength(cf);
  v6 = 0;
  if (v5 >= 0)
    v7 = v5 & 1;
  else
    v7 = -(v5 & 1);
  v8 = v5 - 1;
  while (CFStringGetLength(cf) > v6)
  {
    if (v7 == 1 && v8 == v6)
      goto LABEL_18;
    v9 = v4[v6];
    v10 = v4[v8];
    if (!v7 && v8 - 1 == v6)
    {
      if (v9 == v10)
      {
LABEL_18:
        free(v4);
        return 1;
      }
      break;
    }
    ++v6;
    --v8;
    if (v9 != v10)
      break;
  }
  free(v4);
  return 0;
}

uint64_t SecPasswordHasRepeatingGroups(const __CFString *cf)
{
  CFIndex Length;
  CFIndex v3;
  char *v4;
  CFIndex i;
  CFIndex v6;
  int v7;

  if (cf)
  {
    CFRetain(cf);
    Length = CFStringGetLength(cf);
    v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    v4 = (char *)malloc_type_malloc(v3, 0x5ECC0363uLL);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u))
      *v4 = 0;
    CFRelease(cf);
  }
  else
  {
    v4 = strdup((const char *)&unk_18AA61AAF);
  }
  for (i = 0; CFStringGetLength(cf) > i; ++i)
  {
    v6 = CFStringGetLength(cf);
    v7 = v4[i];
    if (v6 == i + 4)
    {
      if (v7 == v4[(i + 3)])
      {
        free(v4);
        return 1;
      }
      break;
    }
    if (v7 != v4[i + 3])
      break;
  }
  free(v4);
  return 0;
}

uint64_t SecPasswordIsPasscodeIncrementingOrDecrementingDigits(const __CFString *cf)
{
  CFIndex Length;
  CFIndex v3;
  char *v4;
  CFIndex v5;
  char *v6;
  int v7;
  CFIndex i;
  uint64_t v9;

  if (cf)
  {
    CFRetain(cf);
    Length = CFStringGetLength(cf);
    v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    v4 = (char *)malloc_type_malloc(v3, 0x5ECC0363uLL);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u))
      *v4 = 0;
    CFRelease(cf);
  }
  else
  {
    v4 = strdup((const char *)&unk_18AA61AAF);
  }
  v5 = 0;
  do
  {
    if (CFStringGetLength(cf) <= v5)
      break;
    if (v5 == CFStringGetLength(cf) - 1)
    {
LABEL_18:
      v9 = 1;
      goto LABEL_20;
    }
    v6 = &v4[v5];
    v7 = v4[v5++] + 1;
  }
  while (v7 == v6[1]);
  for (i = 0; CFStringGetLength(cf) > i; ++i)
  {
    if (i == CFStringGetLength(cf) - 1)
      goto LABEL_18;
    if (v4[i + 1] + 1 != v4[i])
    {
      v9 = 0;
      if (i || *v4 != 48 || v4[i + 1] != 57)
        goto LABEL_20;
    }
  }
  v9 = 0;
LABEL_20:
  free(v4);
  return v9;
}

uint64_t SecPasswordIsPasswordRepeatingTwoNumbers(const __CFString *cf)
{
  CFIndex Length;
  CFIndex v3;
  char *v4;
  CFIndex v5;
  int v6;
  int v7;
  uint64_t v8;

  if (cf)
  {
    CFRetain(cf);
    Length = CFStringGetLength(cf);
    v3 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    v4 = (char *)malloc_type_malloc(v3, 0x5ECC0363uLL);
    if (!CFStringGetCString(cf, v4, v3, 0x8000100u))
      *v4 = 0;
    CFRelease(cf);
  }
  else
  {
    v4 = strdup((const char *)&unk_18AA61AAF);
  }
  v5 = 0;
  while (1)
  {
    if (CFStringGetLength(cf) <= v5)
    {
LABEL_10:
      v8 = 0;
      goto LABEL_12;
    }
    if (CFStringGetLength(cf) == v5 + 3)
      break;
    v6 = v4[v5];
    v7 = v4[v5++ + 2];
    if (v6 != v7)
      goto LABEL_10;
  }
  v8 = 1;
LABEL_12:
  free(v4);
  return v8;
}

__CFArray *CFArrayCreateMutableForCFTypesWith(const __CFAllocator *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10)
{
  CFIndex v10;
  const void *v11;
  uint64_t *v12;
  __CFArray *Mutable;
  const void **v14;
  uint64_t *v16;
  const void **v17;

  v16 = &a10;
  v10 = 0;
  v11 = a9;
  if (a9)
  {
    do
    {
      v12 = v16++;
      ++v10;
    }
    while (*v12);
  }
  Mutable = CFArrayCreateMutable(a1, v10, MEMORY[0x1E0C9B378]);
  v17 = (const void **)&a10;
  if (a9)
  {
    do
    {
      CFArrayAppendValue(Mutable, v11);
      v14 = v17++;
      v11 = *v14;
    }
    while (*v14);
  }
  return Mutable;
}

BOOL SecPasswordIsPasswordWeak(const __CFString *a1)
{
  CFIndex i;
  int v3;
  int v4;
  int v5;
  int v6;
  CFIndex j;
  CFIndex v8;
  CFIndex v9;
  char *v10;
  int v11;
  int v12;
  double Length;
  CFIndex v15;
  CFIndex v16;
  int v17;
  int v18;
  int v19;
  int v20;
  CFIndex v21;
  int v22;
  int v23;
  CFIndex v24;
  unsigned __int8 *v25;
  int v26;
  CFIndex m;
  CFIndex v28;
  unsigned __int8 *v29;
  int v30;
  CFIndex k;
  uint64_t v32;
  CFRange v33;
  CFRange v34;
  CFRange v35;
  CFRange v36;
  CFRange v37;

  uppercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetUppercaseLetter);
  lowercaseLetterCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetLowercaseLetter);
  decimalDigitCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetDecimalDigit);
  punctuationCharacterSet = (uint64_t)CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  if (CFStringGetLength(a1) < 4)
    return 1;
  for (i = 0; i < CFStringGetLength(a1); ++i)
  {
    v33.location = i;
    v33.length = 1;
    if (!CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)decimalDigitCharacterSet, v33, 0, 0))
    {
      v3 = 0;
      v4 = 0;
      v5 = 0;
      v6 = 0;
      for (j = 0; j < CFStringGetLength(a1); ++j)
      {
        v34.location = j;
        v34.length = 1;
        if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)uppercaseLetterCharacterSet, v34, 4uLL, 0))
        {
          ++v3;
        }
        else
        {
          v35.location = j;
          v35.length = 1;
          if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)lowercaseLetterCharacterSet, v35, 4uLL, 0))
          {
            ++v4;
          }
          else
          {
            v36.location = j;
            v36.length = 1;
            if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)decimalDigitCharacterSet, v36, 4uLL, 0))
            {
              ++v5;
            }
            else
            {
              v37.location = j;
              v37.length = 1;
              if (CFStringFindCharacterFromSet(a1, (CFCharacterSetRef)punctuationCharacterSet, v37, 4uLL, 0))
                ++v6;
            }
          }
        }
      }
      if (v3 <= 0)
        v11 = 0;
      else
        v11 = 26;
      if (v4 > 0)
        v11 += 26;
      if (v5 > 0)
        v11 += 10;
      if (v6 <= 0)
        v12 = v11;
      else
        v12 = v11 + 33;
      Length = (double)CFStringGetLength(a1);
      return log2((double)v12) * Length < 35.0;
    }
  }
  if (CFStringGetLength(a1) == 4)
  {
    if (a1)
    {
      CFRetain(a1);
      v8 = CFStringGetLength(a1);
      v9 = CFStringGetMaximumSizeForEncoding(v8, 0x8000100u) + 1;
      v10 = (char *)malloc_type_malloc(v9, 0x5ECC0363uLL);
      if (!CFStringGetCString(a1, v10, v9, 0x8000100u))
        *v10 = 0;
      CFRelease(a1);
    }
    else
    {
      v10 = strdup((const char *)&unk_18AA61AAF);
    }
    if (!in_word_set((unsigned __int8 *)v10))
    {
      v17 = *v10;
      v18 = v10[1];
      if (((v17 == v18) == v10[2]) != v10[3])
      {
        v19 = v10[2];
        v20 = v10[3];
        if ((v17 != v18 || v19 != v20) && (v17 != v19 || v18 != v20))
        {
          v28 = 0;
          do
          {
            if (CFStringGetLength(a1) <= v28)
              break;
            if (v28 == CFStringGetLength(a1) - 1)
              goto LABEL_43;
            v29 = (unsigned __int8 *)&v10[v28];
            v30 = v10[v28++] + 1;
          }
          while (v30 == (char)v29[1]);
          for (k = 0; CFStringGetLength(a1) > k; ++k)
          {
            if (k == CFStringGetLength(a1) - 1)
              goto LABEL_43;
            if (v10[k + 1] + 1 != v10[k] && (k || v10[k] != 48 || v10[k + 1] != 57))
              break;
          }
          v32 = 0;
          while (strcmp(blacklist[v32], v10))
          {
            if (++v32 == 7)
              goto LABEL_77;
          }
        }
      }
    }
LABEL_43:
    free(v10);
    return 1;
  }
  if (a1)
  {
    CFRetain(a1);
    v15 = CFStringGetLength(a1);
    v16 = CFStringGetMaximumSizeForEncoding(v15, 0x8000100u) + 1;
    v10 = (char *)malloc_type_malloc(v16, 0x5ECC0363uLL);
    if (!CFStringGetCString(a1, v10, v16, 0x8000100u))
      *v10 = 0;
    CFRelease(a1);
  }
  else
  {
    v10 = strdup((const char *)&unk_18AA61AAF);
  }
  v21 = 0;
  do
  {
    if (CFStringGetLength(a1) <= v21)
      break;
    if (CFStringGetLength(a1) <= v21 + 1)
      goto LABEL_43;
    v22 = v10[v21];
    v23 = v10[++v21];
  }
  while (v22 == v23);
  v24 = 0;
  do
  {
    if (CFStringGetLength(a1) <= v24)
      break;
    if (v24 == CFStringGetLength(a1) - 1)
      goto LABEL_43;
    v25 = (unsigned __int8 *)&v10[v24];
    v26 = v10[v24++] + 1;
  }
  while (v26 == (char)v25[1]);
  for (m = 0; CFStringGetLength(a1) > m; ++m)
  {
    if (m == CFStringGetLength(a1) - 1)
      goto LABEL_43;
    if (v10[m + 1] + 1 != v10[m] && (m || v10[m] != 48 || v10[m + 1] != 57))
      goto LABEL_78;
  }
LABEL_77:
  if (!v10)
    return 0;
LABEL_78:
  free(v10);
  return 0;
}

CFDictionaryRef SecPasswordCopyDefaultPasswordLength(int a1, __CFString **a2)
{
  uint64_t v2;
  CFDictionaryRef Copy;
  const __CFAllocator *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  __CFDictionary *Mutable;
  uint64_t v9;
  uint64_t valuePtr;

  switch(a1)
  {
    case 0:
      valuePtr = 4;
      v2 = 5;
      goto LABEL_8;
    case 1:
      valuePtr = 4;
      v2 = 6;
      goto LABEL_8;
    case 2:
      valuePtr = 4;
      v2 = 3;
      goto LABEL_8;
    case 3:
      valuePtr = 4;
      v2 = 1;
      goto LABEL_8;
    case 4:
      valuePtr = 4;
      v2 = 7;
LABEL_8:
      v9 = v2;
      v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, &valuePtr);
      v6 = CFNumberCreate(v4, kCFNumberCFIndexType, &v9);
      Mutable = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionaryAddValue(Mutable, (const void *)kSecPasswordGroupSize, v5);
      CFDictionaryAddValue(Mutable, (const void *)kSecPasswordNumberOfGroups, v6);
      Copy = CFDictionaryCreateCopy(v4, Mutable);
      if (v5)
        CFRelease(v5);
      if (v6)
        CFRelease(v6);
      if (Mutable)
        CFRelease(Mutable);
      break;
    default:
      SecError(-909, a2, CFSTR("Password type does not exist."));
      Copy = 0;
      break;
  }
  return Copy;
}

BOOL SecPasswordValidatePasswordFormat(int a1, CFStringRef theString, __CFString **a3)
{
  const __CFString *v5;
  int v6;
  uint64_t v7;
  CFMutableStringRef Mutable;
  __CFString *v9;
  CFIndex v10;
  uint64_t v11;
  uint64_t v12;
  CFIndex v13;
  const __CFString *v14;
  _BOOL8 v15;
  CFIndex v16;
  CFStringRef v17;
  CFStringRef v18;
  const __CFString *v19;
  const __CFString *v20;
  __CFString *Checksum;
  __CFString *v22;
  __CFString *v23;
  const __CFString *v25;
  CFIndex range;
  CFRange v27;
  CFRange v28;
  CFRange v29;

  switch(a1)
  {
    case 4:
      v6 = 0;
      v7 = 7;
      range = 2;
      v5 = CFSTR("ABCDEFGHJKLMNPQRSTUVWXYZ23456789");
      break;
    case 3:
      v5 = 0;
      range = 0;
      v6 = 1;
      v7 = 1;
      break;
    case 1:
      v5 = 0;
      range = 0;
      v6 = 1;
      v7 = 6;
      break;
    default:
      SecError(-909, a3, CFSTR("Password type does not exist."));
      return 0;
  }
  if (CFStringGetLength(theString) != 5 * v7 - 1)
    return 0;
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  Mutable = CFStringCreateMutable((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, 0);
  if (!Mutable)
    return 0;
  v9 = Mutable;
  v25 = v5;
  v10 = 0;
  v11 = 4 * v7;
  v12 = 5 * v7;
  do
  {
    if (v10)
    {
      v13 = v10;
      if (CFStringGetCharacterAtIndex(theString, v10 - 1) != 45)
        goto LABEL_33;
    }
    else
    {
      v13 = 0;
    }
    if (SecCFAllocatorZeroize_sOnce != -1)
      dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
    v27.location = v13;
    v27.length = 4;
    v14 = CFStringCreateWithSubstring((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, theString, v27);
    CFStringAppend(v9, v14);
    if (v14)
      CFRelease(v14);
    v10 += 5;
  }
  while (v12 != v10);
  if (v6)
  {
    CFRelease(v9);
    return 1;
  }
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v28.length = range;
  v16 = v11 - range;
  v28.location = v16;
  v17 = CFStringCreateWithSubstring((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v9, v28);
  if (!v17)
  {
LABEL_33:
    v23 = v9;
LABEL_34:
    CFRelease(v23);
    return 0;
  }
  v18 = v17;
  if (SecCFAllocatorZeroize_sOnce != -1)
    dispatch_once(&SecCFAllocatorZeroize_sOnce, &__block_literal_global_7146);
  v29.location = 0;
  v29.length = v16;
  v19 = CFStringCreateWithSubstring((CFAllocatorRef)SecCFAllocatorZeroize_sAllocator, v9, v29);
  if (!v19)
  {
    CFRelease(v9);
    v23 = (__CFString *)v18;
    goto LABEL_34;
  }
  v20 = v19;
  Checksum = CreateChecksum(a1, v19, range, v25);
  if (Checksum)
  {
    v22 = Checksum;
    v15 = CFEqual(Checksum, v18) != 0;
    CFRelease(v9);
    v9 = v22;
  }
  else
  {
    v15 = 0;
  }
  CFRelease(v9);
  CFRelease(v18);
  CFRelease(v20);
  return v15;
}

uint64_t SecPolicyCompare(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const void *v5;
  const void *v6;

  if (*(_QWORD *)(a1 + 24) && *(_QWORD *)(a2 + 24))
  {
    result = CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16));
    if (!(_DWORD)result)
      return result;
    v5 = *(const void **)(a1 + 24);
    v6 = *(const void **)(a2 + 24);
  }
  else
  {
    v5 = *(const void **)(a1 + 16);
    v6 = *(const void **)(a2 + 16);
  }
  result = CFEqual(v5, v6);
  if ((_DWORD)result)
    return CFEqual(*(CFTypeRef *)(a1 + 32), *(CFTypeRef *)(a2 + 32)) != 0;
  return result;
}

CFHashCode SecPolicyHash(CFTypeRef *a1)
{
  CFTypeRef v2;
  CFHashCode v3;
  CFHashCode v4;

  v2 = a1[3];
  v3 = CFHash(a1[2]);
  if (v2)
  {
    v4 = CFHash(a1[3]) + v3;
    v3 = CFHash(a1[4]);
  }
  else
  {
    v4 = CFHash(a1[4]);
  }
  return v4 + v3;
}

__CFString *SecPolicyCopyFormatDescription(_QWORD *a1)
{
  __CFString *Mutable;
  CFTypeID v3;
  CFStringRef v4;
  CFStringRef v5;
  const __CFString *v6;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  v3 = CFGetTypeID(a1);
  v4 = CFCopyTypeIDDescription(v3);
  v5 = v4;
  v6 = (const __CFString *)a1[3];
  if (!v6)
    v6 = &stru_1E1FDD448;
  CFStringAppendFormat(Mutable, 0, CFSTR("<%@: oid: %@ name: %@ options %@"), v4, a1[2], v6, a1[4]);
  CFRelease(v5);
  CFStringAppend(Mutable, CFSTR(" >"));
  return Mutable;
}

__CFString *SecPolicyCopyDescription(_QWORD *a1)
{
  SecGetDebugDescriptionFormatOptions();
  return SecPolicyCopyFormatDescription(a1);
}

_QWORD *SecPolicyCreateSMIME(char a1, const void *a2)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v5;
  __CFArray *v6;
  CFDateRef v7;
  CFNumberRef v8;
  __CFArray *v9;
  _QWORD *v10;
  uint64_t valuePtr;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v5 = Mutable;
  if ((a1 & 0x40) != 0)
  {
    SecPolicyAddBasicCertOptions(Mutable);
    if ((a1 & 1) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
  SecPolicyAddBasicX509Options(Mutable);
  if ((a1 & 1) != 0)
  {
LABEL_6:
    add_ku(v5, 0);
    add_ku(v5, 1);
  }
LABEL_7:
  if ((a1 & 2) != 0)
  {
    add_ku(v5, 4);
    if ((a1 & 4) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
  if ((a1 & 4) != 0)
LABEL_9:
    add_ku(v5, 8);
LABEL_10:
  if ((a1 & 0x38) != 0)
    add_ku(v5, 16);
  if (a2)
    CFDictionaryAddValue(v5, CFSTR("Email"), a2);
  add_eku(v5, 0);
  add_eku(v5, (const UInt8 *)&oidExtendedKeyUsageEmailProtection);
  CFDictionaryAddValue(v5, CFSTR("EmailProtectionEKU"), (const void *)*MEMORY[0x1E0C9AE50]);
  v6 = CFArrayCreateMutable(0, 2, MEMORY[0x1E0C9B378]);
  v7 = CFDateCreate(0, 670464000.0);
  valuePtr = 0x4198690600000000;
  v8 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  CFArrayAppendValue(v6, v7);
  CFArrayAppendValue(v6, v8);
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  v9 = CFArrayCreateMutable(0, 1, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue(v9, v6);
  if (v6)
    CFRelease(v6);
  CFDictionaryAddValue(v5, CFSTR("SystemTrustValidityPeriod"), v9);
  if (v9)
    CFRelease(v9);
  if (SecPolicyAddStrongKeySizeOptions(v5) && SecPolicyRemoveWeakHashOptions(v5))
    v10 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.8"), CFSTR("SMIME"), v5);
  else
    v10 = 0;
  CFRelease(v5);
  return v10;
}

__CFDictionary *SecPolicyCreateEAP(int a1, const void *a2)
{
  __CFDictionary *result;
  __CFDictionary *v5;
  const void *v6;
  _BOOL4 v7;
  const __CFString *v8;
  _QWORD *v9;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (result)
  {
    v5 = result;
    SecPolicyAddBasicX509Options(result);
    v6 = (const void *)*MEMORY[0x1E0C9AE50];
    CFDictionaryAddValue(v5, CFSTR("NoNetworkAccess"), (const void *)*MEMORY[0x1E0C9AE50]);
    if (a2)
      CFDictionaryAddValue(v5, CFSTR("EAPTrustedServerNames"), a2);
    if (a1)
    {
      CFDictionaryAddValue(v5, CFSTR("SystemTrustedWeakHash"), v6);
      CFDictionaryAddValue(v5, CFSTR("SystemTrustedWeakKey"), v6);
    }
    v7 = a1 != 0;
    if (a1)
      v8 = CFSTR("eapServer");
    else
      v8 = CFSTR("eapClient");
    set_ssl_ekus(v5, v7);
    v9 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.9"), v8, v5);
    CFRelease(v5);
    return (__CFDictionary *)v9;
  }
  return result;
}

__CFDictionary *SecPolicyCreateIPSec(int a1, const void *a2)
{
  __CFDictionary *result;
  __CFDictionary *v5;
  const __CFString *v6;
  _QWORD *v7;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (result)
  {
    v5 = result;
    SecPolicyAddBasicX509Options(result);
    if (a2)
      CFDictionaryAddValue(v5, CFSTR("SSLHostname"), a2);
    if (a1)
      v6 = CFSTR("ipsecServer");
    else
      v6 = CFSTR("ipsecClient");
    v7 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.11"), v6, v5);
    CFRelease(v5);
    return (__CFDictionary *)v7;
  }
  return result;
}

_QWORD *SecPolicyCreateMacAppStoreReceipt()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_element(v1, CFSTR("CertificatePolicy"), CFSTR("1.2.840.113635.100.5.6.1"));
    add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.1"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.11.1"));
    CFDictionaryAddValue(v1, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.19"), CFSTR("MacAppStoreReceipt"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

SecPolicyRef SecPolicyCreateRevocation(CFOptionFlags revocationFlags)
{
  CFOptionFlags v1;
  __CFDictionary *Mutable;
  __CFDictionary *v3;
  const void **v4;
  const __CFString *v5;
  const void *v6;
  const void *v7;

  v1 = revocationFlags;
  if (!revocationFlags)
    return (SecPolicyRef)v1;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  v4 = (const void **)MEMORY[0x1E0C9AE50];
  if ((v1 & 0x40) != 0)
  {
    CFDictionaryAddValue(Mutable, CFSTR("RevocationIfTrusted"), (const void *)*MEMORY[0x1E0C9AE50]);
    CFDictionaryAddValue(v3, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
  }
  if ((v1 & 0x20) != 0)
  {
    CFDictionaryAddValue(v3, CFSTR("RevocationOnline"), *v4);
    CFDictionaryAddValue(v3, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
  }
  if ((v1 & 3) == 3)
  {
    v5 = CFSTR("AnyRevocationMethod");
  }
  else
  {
    if ((v1 & 1) != 0)
      v5 = CFSTR("OCSP");
    else
      v5 = CFSTR("CRL");
    if ((v1 & 3) == 0)
      goto LABEL_14;
  }
  CFDictionaryAddValue(v3, CFSTR("Revocation"), v5);
LABEL_14:
  v6 = *v4;
  if ((v1 & 8) != 0)
    CFDictionaryAddValue(v3, CFSTR("RevocationResponseRequired"), v6);
  if ((v1 & 0x10) != 0)
    v7 = v6;
  else
    v7 = (const void *)*MEMORY[0x1E0C9AE40];
  CFDictionaryAddValue(v3, CFSTR("NoNetworkAccess"), v7);
  if (v1 > 0x7F)
    v1 = 0;
  else
    v1 = (CFOptionFlags)SecPolicyCreate(CFSTR("1.2.840.113635.100.1.21"), CFSTR("revocation"), v3);
  CFRelease(v3);
  return (SecPolicyRef)v1;
}

_QWORD *SecPolicyCreateApplePinned(const void *a1, const __CFString *a2, const __CFString *a3)
{
  _QWORD *v3;
  __CFDictionary *Mutable;
  const __CFDictionary *v8;
  NSObject *v9;
  NSObject *v10;
  int v12;
  const __CFString *v13;
  uint64_t v14;

  v3 = 0;
  v14 = *MEMORY[0x1E0C80C00];
  if (a1 && a2 && a3)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (Mutable)
    {
      v8 = Mutable;
      SecPolicyAddBasicX509Options(Mutable);
      if (!SecPolicyAddAppleAnchorOptions(v8) || !SecPolicyAddChainLengthOptions(v8, 3))
        goto LABEL_17;
      if ((isAppleOid(a2) & 1) == 0)
      {
        v9 = secLogObjForScope("SecWarning");
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          v12 = 138412290;
          v13 = a2;
          _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "creating an Apple pinning policy with a non-Apple OID: %@", (uint8_t *)&v12, 0xCu);
        }
      }
      add_element(v8, CFSTR("IntermediateMarkerOid"), a2);
      if ((isAppleOid(a3) & 1) == 0)
      {
        v10 = secLogObjForScope("SecWarning");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          v12 = 138412290;
          v13 = a3;
          _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, "creating an Apple pinning policy with a non-Apple OID: %@", (uint8_t *)&v12, 0xCu);
        }
      }
      add_element(v8, CFSTR("LeafMarkerOid"), a3);
      add_element(v8, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
      if (SecPolicyAddStrongKeySizeOptions(v8))
        v3 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.62"), a1, v8);
      else
LABEL_17:
        v3 = 0;
      CFRelease(v8);
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

_QWORD *SecPolicyCreateAppleSSLPinned(const void *a1, const __CFString *a2, const __CFString *a3, __CFString *a4)
{
  _QWORD *SSL_internal;
  __CFDictionary *Mutable;
  const __CFDictionary *v10;
  NSObject *v11;
  const __CFDictionary *v12;
  const __CFString *v13;
  NSObject *v14;
  int v16;
  const __CFString *v17;
  uint64_t v18;

  SSL_internal = 0;
  v18 = *MEMORY[0x1E0C80C00];
  if (a1 && a2 && a4)
  {
    if (requireUATPinning((uint64_t)a1))
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Mutable)
      {
        v10 = Mutable;
        SecPolicyAddBasicX509Options(Mutable);
        if (!SecPolicyAddAppleAnchorOptions(v10) || !SecPolicyAddChainLengthOptions(v10, 3))
          goto LABEL_23;
        if (a3)
        {
          if ((isAppleOid(a3) & 1) == 0)
          {
            v11 = secLogObjForScope("SecWarning");
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              v16 = 138412290;
              v17 = a3;
              _os_log_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEFAULT, "creating an Apple pinning policy with a non-Apple OID: %@", (uint8_t *)&v16, 0xCu);
            }
          }
          v12 = v10;
          v13 = a3;
        }
        else
        {
          v13 = CFSTR("1.2.840.113635.100.6.2.12");
          v12 = v10;
        }
        add_element(v12, CFSTR("IntermediateMarkerOid"), v13);
        if ((isAppleOid(a4) & 1) == 0)
        {
          v14 = secLogObjForScope("SecWarning");
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            v16 = 138412290;
            v17 = a4;
            _os_log_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEFAULT, "creating an Apple pinning policy with a non-Apple OID: %@", (uint8_t *)&v16, 0xCu);
          }
        }
        add_element(v10, CFSTR("LeafMarkerOid"), a4);
        add_leaf_marker_value_string(v10, CFSTR("1.2.840.113635.100.6.48.1"), a4);
        add_element(v10, CFSTR("ExtendedKeyUsage"), CFSTR("1.3.6.1.5.5.7.3.1"));
        add_element(v10, CFSTR("SSLHostname"), a2);
        if (SecPolicyAddStrongKeySizeOptions(v10) && SecPolicyRemoveWeakHashOptions(v10))
        {
          add_element(v10, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
          SSL_internal = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.63"), a1, v10);
        }
        else
        {
LABEL_23:
          SSL_internal = 0;
        }
        CFRelease(v10);
      }
      else
      {
        return 0;
      }
    }
    else
    {
      SSL_internal = SecPolicyCreateSSL_internal(1, a2, 0, 0);
      SecPolicySetOid((uint64_t)SSL_internal, CFSTR("1.2.840.113635.100.1.63"));
      SecPolicySetName((uint64_t)SSL_internal, a1);
    }
  }
  return SSL_internal;
}

_QWORD *SecPolicyCreateAppleUniqueDeviceCertificate(const void *a1)
{
  const __CFAllocator *v2;
  __CFDictionary *Mutable;
  const __CFDictionary *v4;
  CFDictionaryRef v5;
  CFDictionaryRef v6;
  const __CFDictionary *v7;
  _QWORD *v8;
  CFTypeRef cf;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  cf = 0;
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v4 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAnchorSHA256Options(v4, SEPRootCA_SHA256))
    goto LABEL_16;
  if (a1 && os_variant_allows_internal_security_policies() && CFDataGetLength((CFDataRef)a1) == 32)
    add_element(v4, CFSTR("AnchorSHA256"), a1);
  if (!SecPolicyAddChainLengthOptions(v4, 3))
    goto LABEL_16;
  values = CFSTR("ucrt");
  keys[0] = CFSTR("1.2.840.113635.100.6.44");
  v5 = CFDictionaryCreate(v2, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  add_element(v4, CFSTR("IntermediateMarkerOid"), v5);
  if (v5)
    CFRelease(v5);
  add_element(v4, CFSTR("LeafMarkerOidWithoutValueCheck"), CFSTR("1.2.840.113635.100.10.1"));
  keys[0] = (void *)256;
  cf = CFNumberCreate(0, kCFNumberCFIndexType, keys);
  if (cf
    && (v6 = CFDictionaryCreate(0, (const void **)&kSecAttrKeyTypeEC, &cf, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0])) != 0)
  {
    v7 = v6;
    add_element(v4, CFSTR("KeySize"), v6);
    v8 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.72"), CFSTR("UCRT"), v4);
    CFRelease(v4);
    v4 = v7;
  }
  else
  {
LABEL_16:
    v8 = 0;
  }
  CFRelease(v4);
  if (cf)
    CFRelease(cf);
  return v8;
}

_QWORD *SecPolicyCreateAppleBasicAttestationSystem(const void *a1)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v3;
  _QWORD *v4;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  SecPolicyAddAnchorSHA256Options(v3, BASystemRootCA_SHA256);
  if (a1 && os_variant_allows_internal_security_policies() && CFDataGetLength((CFDataRef)a1) == 32)
    add_element(v3, CFSTR("AnchorSHA256"), a1);
  if (SecPolicyAddChainLengthOptions(v3, 3))
    v4 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.84"), CFSTR("BAA-SCRT"), v3);
  else
    v4 = 0;
  CFRelease(v3);
  return v4;
}

_QWORD *SecPolicyCreateAppleBasicAttestationUser(const void *a1)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v3;
  _QWORD *v4;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  SecPolicyAddAnchorSHA256Options(v3, BAUserRootCA_SHA256);
  if (a1 && os_variant_allows_internal_security_policies() && CFDataGetLength((CFDataRef)a1) == 32)
    add_element(v3, CFSTR("AnchorSHA256"), a1);
  if (SecPolicyAddChainLengthOptions(v3, 3))
    v4 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.85"), CFSTR("BAA-UCRT"), v3);
  else
    v4 = 0;
  CFRelease(v3);
  return v4;
}

_QWORD *SecPolicyCreateAppleComponentCertificate(const void *a1)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v3;
  _QWORD *v4;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  SecPolicyAddAnchorSHA256Options(v3, ComponentRootCA_SHA256);
  if (a1 && os_variant_allows_internal_security_policies() && CFDataGetLength((CFDataRef)a1) == 32)
    add_element(v3, CFSTR("AnchorSHA256"), a1);
  if (SecPolicyAddChainLengthOptions(v3, 3))
  {
    add_element(v3, CFSTR("LeafMarkerOidWithoutValueCheck"), CFSTR("1.2.840.113635.100.11.1"));
    add_element(v3, CFSTR("IntermediateMarkerOidWithoutValueCheck"), CFSTR("1.2.840.113635.100.11.1"));
    v4 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.92"), CFSTR("Component"), v3);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

_QWORD *SecPolicyCreateAggregateMetricTransparency(int a1)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v3;
  const __CFString *v4;
  _QWORD *v5;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3)
    && ((add_element(v3, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.26")), !a1)
      ? (v4 = CFSTR("1.2.840.113635.100.12.18"))
      : (v4 = CFSTR("1.2.840.113635.100.12.17")),
        add_element(v3, CFSTR("LeafMarkerOidWithoutValueCheck"), v4),
        add_element(v3, CFSTR("Revocation"), CFSTR("AnyRevocationMethod")),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    if (!os_variant_allows_internal_security_policies()
      || !CFPreferencesGetAppBooleanValue(CFSTR("disableAggregateMetricsCTCheck"), CFSTR("com.apple.security"), 0))
    {
      add_element(v3, CFSTR("CTRequired"), (const void *)*MEMORY[0x1E0C9AE50]);
    }
    v5 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.102"), CFSTR("AggregateMetricTransparency"), v3);
  }
  else
  {
    v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

_QWORD *SecPolicyCreateAggregateMetricEncryption(int a1)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v3;
  const __CFString *v4;
  _QWORD *v5;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3)
    && ((add_element(v3, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.26")), !a1)
      ? (v4 = CFSTR("1.2.840.113635.100.15.3"))
      : (v4 = CFSTR("1.2.840.113635.100.15.2")),
        add_element(v3, CFSTR("LeafMarkerOid"), v4),
        add_element(v3, CFSTR("Revocation"), CFSTR("AnyRevocationMethod")),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    if (!os_variant_allows_internal_security_policies()
      || !CFPreferencesGetAppBooleanValue(CFSTR("disableAggregateMetricsCTCheck"), CFSTR("com.apple.security"), 0))
    {
      add_element(v3, CFSTR("NonTlsCTRequired"), (const void *)*MEMORY[0x1E0C9AE50]);
    }
    v5 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.106"), CFSTR("AggregateMetricEncryption"), v3);
  }
  else
  {
    v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

_QWORD *SecPolicyCreateApplePayModelSigning(int a1)
{
  __CFDictionary *Mutable;
  __CFDictionary *v3;
  _QWORD *v4;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  if (a1)
    SecPolicyAddBasicX509Options(Mutable);
  else
    SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3)
    && (add_element(v3, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.17")),
        add_element(v3, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.12.20")),
        add_element(v3, CFSTR("Revocation"), CFSTR("AnyRevocationMethod")),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    v4 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.107"), CFSTR("ApplePayModelSigning"), v3);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

_QWORD *SecPolicyCreateMDLTerminalAuth(int a1, int a2)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v5;
  __CFArray *Value;
  _QWORD *v7;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v5 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  add_ku(v5, 1);
  if (a1)
    add_element(v5, CFSTR("ExtendedKeyUsage"), CFSTR("1.0.18013.5.1.6"));
  if (a2)
    add_element(v5, CFSTR("BasicConstraintsCA"), (const void *)*MEMORY[0x1E0C9AE50]);
  if (SecPolicyAddStrongKeySizeOptions(v5)
    && SecPolicyRemoveWeakHashOptions(v5)
    && (Value = (__CFArray *)CFDictionaryGetValue(v5, CFSTR("SignatureHashAlgorithms"))) != 0)
  {
    CFArrayAppendValue(Value, CFSTR("SignatureDigestSHA224"));
    v7 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.108"), CFSTR("MDLTerminalAuth"), v5);
  }
  else
  {
    v7 = 0;
  }
  CFRelease(v5);
  return v7;
}

_QWORD *SecPolicyCreatePPMAggregatorConfigSigning(int a1)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v3;
  const __CFString *v4;
  _QWORD *v5;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3)
    && ((add_element(v3, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.26")), !a1)
      ? (v4 = CFSTR("1.2.840.113635.100.14.3"))
      : (v4 = CFSTR("1.2.840.113635.100.12.44")),
        add_element(v3, CFSTR("LeafMarkerOid"), v4),
        add_element(v3, CFSTR("Revocation"), CFSTR("AnyRevocationMethod")),
        SecPolicyAddStrongKeySizeOptions(v3)))
  {
    if (!os_variant_allows_internal_security_policies()
      || !CFPreferencesGetAppBooleanValue(CFSTR("disableAggregateMetricsCTCheck"), CFSTR("com.apple.security"), 0))
    {
      add_element(v3, CFSTR("NonTlsCTRequired"), (const void *)*MEMORY[0x1E0C9AE50]);
    }
    v5 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.112"), CFSTR("PPMAggregatorConfigSigning"), v3);
  }
  else
  {
    v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

_QWORD *SecPolicyCreateiAPAuthV4(int a1)
{
  __CFDictionary *Mutable;
  __CFDictionary *v3;
  const __CFString *v4;
  _QWORD *v5;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  switch(a1)
  {
    case 1:
      v4 = CFSTR("Apple Accessories Certification Authority - ");
      break;
    case 3:
      CFDictionaryAddValue(v3, CFSTR("IssuerCommonNamePrefix"), CFSTR("Apple Accessories Provisioning Authority - "));
      goto LABEL_9;
    case 2:
      v4 = CFSTR("Apple Accessory Host Attestation Authority - ");
      break;
    default:
      v5 = 0;
      goto LABEL_11;
  }
  CFDictionaryAddValue(v3, CFSTR("IssuerCommonNamePrefix"), v4);
  add_element(v3, CFSTR("LeafMarkerOidWithoutValueCheck"), CFSTR("1.2.840.113635.100.6.71.1"));
LABEL_9:
  v5 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.117"), CFSTR("iAPAuthV4"), v3);
LABEL_11:
  CFRelease(v3);
  return v5;
}

_QWORD *SecPolicyCreateParakeetCommon(const void *a1, const void *a2, const void *a3, const void *a4)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v9;
  CFDictionaryRef v10;
  CFDictionaryRef v11;
  __CFArray *Value;
  const void *v13;
  const CFArrayCallBacks *v14;
  __CFArray *v15;
  __CFArray *v16;
  CFDateRef v17;
  CFNumberRef v18;
  CFTypeID v19;
  double Current;
  const void *v21;
  const void *v22;
  CFTypeID v23;
  const void *v24;
  CFDateRef v25;
  _QWORD *v26;
  void *v27;
  const void *v29;
  void *values;
  uint64_t valuePtr;

  values = 0;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v9 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v9, 3))
  {
    valuePtr = 256;
    values = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
    if (values)
    {
      v10 = CFDictionaryCreate(0, (const void **)&kSecAttrKeyTypeEC, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v10)
      {
        v11 = v10;
        add_element(v9, CFSTR("KeySize"), v10);
        if (!SecPolicyRemoveWeakHashOptions(v9)
          || (Value = (__CFArray *)CFDictionaryGetValue(v9, CFSTR("SignatureHashAlgorithms"))) == 0)
        {
          v26 = 0;
          goto LABEL_30;
        }
        v29 = a3;
        CFArrayAppendValue(Value, CFSTR("SignatureDigestSHA224"));
        add_ku(v9, 16);
        v13 = (const void *)*MEMORY[0x1E0C9AE50];
        CFDictionarySetValue(v9, CFSTR("NotCA"), (const void *)*MEMORY[0x1E0C9AE50]);
        v14 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
        v15 = CFArrayCreateMutable(0, 1, MEMORY[0x1E0C9B378]);
        v16 = CFArrayCreateMutable(0, 2, v14);
        valuePtr = 0x4158674400000000;
        v17 = CFDateCreate(0, 0.0);
        v18 = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
        CFArrayAppendValue(v16, v17);
        CFArrayAppendValue(v16, v18);
        if (v17)
          CFRelease(v17);
        if (v18)
          CFRelease(v18);
        CFArrayAppendValue(v15, v16);
        if (v16)
          CFRelease(v16);
        CFDictionaryAddValue(v9, CFSTR("SystemTrustValidityPeriod"), v15);
        CFDictionaryAddValue(v9, CFSTR("OtherTrustValidityPeriod"), v15);
        if (v15)
          CFRelease(v15);
        CFDictionaryAddValue(v9, CFSTR("NoNetworkAccess"), v13);
        if (a1)
          CFDictionaryAddValue(v9, CFSTR("SSLHostname"), a1);
        if (a2)
        {
          v19 = CFGetTypeID(a2);
          if (v19 == CFDictionaryGetTypeID())
          {
            Current = CFAbsoluteTimeGetCurrent();
            v21 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("verify"));
            if (v21)
            {
              v22 = v21;
              v23 = CFGetTypeID(v21);
              if (v23 == CFDateGetTypeID())
                Current = MEMORY[0x18D76F188](v22);
            }
            v24 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("fresh"));
            if (v13 && v24)
            {
              if (!CFEqual(v24, v13))
                goto LABEL_29;
LABEL_27:
              v25 = CFDateCreate(0, Current + -172800.0);
              CFDictionaryAddValue(v9, CFSTR("NotValidBefore"), v25);
              if (v25)
                CFRelease(v25);
              goto LABEL_29;
            }
            if (v24 == v13)
              goto LABEL_27;
          }
        }
LABEL_29:
        v26 = SecPolicyCreate(v29, a4, v9);
LABEL_30:
        CFRelease(v9);
        goto LABEL_31;
      }
    }
  }
  v26 = 0;
  v11 = v9;
LABEL_31:
  CFRelease(v11);
  v27 = values;
  if (values)
  {
    values = 0;
    CFRelease(v27);
  }
  return v26;
}

_QWORD *SecPolicyCreateAppleSWUpdateSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_eku(v1, oidAppleExtendedKeyUsageCodeSigning);
    add_oid(v1, CFSTR("IntermediateEKU"), _oidAppleExtendedKeyUsageCodeSigning, 9);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.10"), CFSTR("AppleSWUpdateSigning"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateCodeSigning()
{
  __CFDictionary *result;
  const __CFDictionary *v1;
  _QWORD *v2;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (result)
  {
    v1 = result;
    SecPolicyAddBasicX509Options(result);
    add_ku(v1, 1);
    add_ku(v1, 2);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.16"), CFSTR("CodeSigning"), v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

_QWORD *SecPolicyCreateApplePackageSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_ku(v1, 1);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.17"), CFSTR("PackageSigning"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateAppleIDAuthorityPolicy()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1))
  {
    add_leaf_marker_value(v1, (uint64_t)&oidAppleExtendedKeyUsageAppleID, 0);
    add_oid(v1, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleID, 10);
    add_oid(v1, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleID2, 10);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.61"), CFSTR("AppleIDAuthority"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateAppleTimeStamping()
{
  __CFDictionary *result;
  const __CFDictionary *v1;
  _QWORD *v2;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (result)
  {
    v1 = result;
    SecPolicyAddBasicX509Options(result);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageTimeStamping);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.20"), CFSTR("AppleTimeStamping"), v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

_QWORD *CreateMobileStoreSigner(int a1)
{
  const __CFAllocator *v2;
  __CFDictionary *Mutable;
  __CFDictionary *v4;
  const __CFString *v5;
  const UInt8 **v6;
  CFIndex *v7;
  CFDataRef v8;
  CFDataRef v9;
  const __CFString *v10;
  _QWORD *v11;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v4 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (a1)
    v5 = CFSTR("AppleTestMobileStore");
  else
    v5 = CFSTR("AppleMobileStore");
  if (SecPolicyAddAppleAnchorOptions(v4) && SecPolicyAddChainLengthOptions(v4, 3))
  {
    CFDictionaryAddValue(v4, CFSTR("IssuerCommonName"), CFSTR("Apple System Integration 2 Certification Authority"));
    add_ku(v4, 1);
    v6 = (const UInt8 **)&oidApplePolicyMobileStore;
    v7 = (CFIndex *)&unk_1E1FCB4C0;
    if (a1)
      v7 = (CFIndex *)&unk_1E1FCB4D0;
    if ((*v7 & 0x8000000000000000) == 0)
    {
      if (a1)
        v6 = (const UInt8 **)&oidApplePolicyMobileStoreProdQA;
      v8 = CFDataCreate(v2, *v6, *v7);
      if (v8)
      {
        v9 = v8;
        add_element(v4, CFSTR("CertificatePolicy"), v8);
        CFRelease(v9);
      }
    }
    if (a1)
      v10 = CFSTR("1.2.840.113635.100.1.27");
    else
      v10 = CFSTR("1.2.840.113635.100.1.23");
    v11 = SecPolicyCreate(v10, v5, v4);
  }
  else
  {
    v11 = 0;
  }
  CFRelease(v4);
  return v11;
}

_QWORD *SecPolicyCreateEscrowServiceSigner()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 4);
  add_element(v1, CFSTR("LeafMarkerOidWithoutValueCheck"), CFSTR("1.2.840.113635.100.6.23.1"));
  if (SecPolicyAddChainLengthOptions(v1, 2))
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.24"), CFSTR("AppleEscrowService"), v1);
  else
    v2 = 0;
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateConfigurationProfileSigner()
{
  const void *v0;
  const void *v1;

  v0 = (const void *)MGCopyAnswer();
  v1 = v0;
  if (v0)
    CFRelease(v0);
  return SecPolicyCreatePrivacyConfigurationProfileSigner(1, v1 != 0);
}

_QWORD *SecPolicyCreateAppleIDValidationRecordSigningPolicy()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1))
  {
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtensionAppleIDRecordValidationSigning, 0);
    add_oid(v1, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleID, 10);
    add_oid(v1, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleSystemIntg2, 10);
    CFDictionaryAddValue(v1, CFSTR("Revocation"), CFSTR("OCSP"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.30"), CFSTR("AppleIDValidationRecordSigningPolicy"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateAppleIDValidationShortcutSigningPolicy()
{
  _QWORD *AppleIDValidationRecordSigningPolicy;
  _QWORD *v1;
  __CFDictionary *v2;

  AppleIDValidationRecordSigningPolicy = SecPolicyCreateAppleIDValidationRecordSigningPolicy();
  v1 = AppleIDValidationRecordSigningPolicy;
  if (AppleIDValidationRecordSigningPolicy)
  {
    v2 = (__CFDictionary *)AppleIDValidationRecordSigningPolicy[4];
    if (v2)
      CFDictionaryRemoveValue(v2, CFSTR("TemporalValidity"));
  }
  return v1;
}

_QWORD *SecPolicyCreateAppleSMPEncryption()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtAppleSMPEncryption, 0);
    add_oid(v1, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleSystemIntgG3, 10);
    add_ku(v1, 4);
    CFDictionaryAddValue(v1, CFSTR("Revocation"), CFSTR("OCSP"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.31"), CFSTR("AppleSMPEncryption"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateTestAppleSMPEncryption()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  SecPolicyAddAnchorSHA256Options(v1, kTestAppleRootCA_ECC_SHA256);
  if (SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, CFSTR("IssuerCommonName"), CFSTR("Test Apple System Integration CA - ECC"));
    add_ku(v1, 4);
    CFDictionaryAddValue(v1, CFSTR("Revocation"), CFSTR("OCSP"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.32"), CFSTR("AppleTestSMPEncryption"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

const void *SecPolicyCreateAppleSSLService(const __CFString *a1)
{
  _QWORD *SSL_internal;
  const void *v2;
  const __CFDictionary *v3;

  SSL_internal = SecPolicyCreateSSL_internal(1, a1, 0, 0);
  v2 = SSL_internal;
  if (SSL_internal)
  {
    v3 = (const __CFDictionary *)SSL_internal[4];
    if (v3)
    {
      if (SecPolicyAddAppleAnchorOptions((const __CFDictionary *)SSL_internal[4]))
      {
        add_leaf_marker_value(v3, (uint64_t)&oidAppleCertExtAppleServerAuthentication, 0);
        add_oid(v3, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleServerAuthentication, 10);
        if (SecPolicyRemoveWeakHashOptions(v3))
        {
          CFDictionaryAddValue(v3, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
          SecPolicySetOid((uint64_t)v2, CFSTR("1.2.840.113635.100.1.33"));
          SecPolicySetName((uint64_t)v2, CFSTR("AppleSSLService"));
          return v2;
        }
      }
      CFRelease(v3);
    }
    CFRelease(v2);
    return 0;
  }
  return v2;
}

_QWORD *SecPolicyCreatePCSEscrowServiceSigner()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 4);
  add_element(v1, CFSTR("LeafMarkerOidWithoutValueCheck"), CFSTR("1.2.840.113635.100.6.23.1"));
  if (SecPolicyAddChainLengthOptions(v1, 2))
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.34"), CFSTR("ApplePCSEscrowService"), v1);
  else
    v2 = 0;
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateApplePPQSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  SecPolicyAddAppleAnchorOptions(v1);
  if (SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, CFSTR("IssuerCommonName"), CFSTR("Apple System Integration 2 Certification Authority"));
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtApplePPQSigningProd, 0);
    add_oid(v1, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleSystemIntg2, 10);
    add_ku(v1, 1);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.35"), CFSTR("ApplePPQSigning"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateTestApplePPQSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  if ((os_variant_allows_internal_security_policies() & 1) == 0)
    return SecPolicyCreateApplePPQSigning();
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  SecPolicyAddAppleAnchorOptions(v1);
  if (SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, CFSTR("IssuerCommonName"), CFSTR("Apple System Integration 2 Certification Authority"));
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtApplePPQSigningProdQA, 0);
    add_oid(v1, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleSystemIntg2, 10);
    add_ku(v1, 1);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.36"), CFSTR("AppleTestPPQSigning"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateApplePayIssuerEncryption()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, CFSTR("IssuerCommonName"), CFSTR("Apple Worldwide Developer Relations CA - G2"));
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtCryptoServicesExtEncryption, 0);
    add_ku(v1, 4);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.39"), CFSTR("ApplePayIssuerEncryption"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateOSXProvisioningProfileSigning()
{
  __CFDictionary *result;
  const __CFDictionary *v1;
  _QWORD *v2;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (result)
  {
    v1 = result;
    SecPolicyAddBasicX509Options(result);
    SecPolicyAddAppleAnchorOptions(v1);
    add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtOSXProvisioningProfileSigning, 0);
    add_oid(v1, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleWWDR, 10);
    add_ku(v1, 1);
    CFDictionaryAddValue(v1, CFSTR("Revocation"), CFSTR("OCSP"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.40"), CFSTR("AppleOSXProvisioningProfileSigning"), v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

_QWORD *SecPolicyCreateAppleATVVPNProfileSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  CFMutableDictionaryRef v2;
  __CFDictionary *v3;
  _QWORD *v4;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  v2 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v2)
  {
    v3 = v2;
    if (os_variant_allows_internal_security_policies())
      CFDictionarySetValue(v3, CFSTR("AnchorAppleTestRoots"), (const void *)*MEMORY[0x1E0C9AE50]);
    add_element(v1, CFSTR("AnchorApple"), v3);
    if (SecPolicyAddChainLengthOptions(v1, 3))
    {
      add_leaf_marker_value(v1, (uint64_t)&oidAppleCertExtATVVPNProfileSigning, 0);
      add_oid(v1, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleSystemIntg2, 10);
      CFDictionaryAddValue(v1, CFSTR("Revocation"), CFSTR("OCSP"));
      v4 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.41"), CFSTR("AppleATVVPNProfileSigning"), v1);
    }
    else
    {
      v4 = 0;
    }
    CFRelease(v1);
  }
  else
  {
    v4 = 0;
    v3 = v1;
  }
  CFRelease(v3);
  return v4;
}

_QWORD *SecPolicyCreateAppleHomeKitServerAuth(const void *a1)
{
  __CFDictionary *Mutable;
  __CFDictionary *v3;
  _QWORD *v4;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  CFDictionaryAddValue(v3, CFSTR("SSLHostname"), a1);
  add_eku(v3, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
  if (requireUATPinning((uint64_t)CFSTR("HomeKit")))
  {
    if (!SecPolicyAddChainLengthOptions(v3, 3))
    {
LABEL_10:
      v4 = 0;
      goto LABEL_8;
    }
    SecPolicyAddAppleAnchorOptions(v3);
    add_leaf_marker_value(v3, (uint64_t)&oidAppleCertExtHomeKitServerAuth, 0);
    add_oid(v3, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleHomeKitServerCA, 10);
  }
  if (!SecPolicyRemoveWeakHashOptions(v3) || !SecPolicyAddStrongKeySizeOptions(v3))
    goto LABEL_10;
  CFDictionaryAddValue(v3, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
  v4 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.48"), CFSTR("HomeKit"), v3);
LABEL_8:
  CFRelease(v3);
  return v4;
}

_QWORD *SecPolicyCreateiPhoneActivation()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, CFSTR("IssuerCommonName"), CFSTR("Apple iPhone Certification Authority"));
  CFDictionaryAddValue(v1, CFSTR("SubjectCommonName"), CFSTR("Apple iPhone Activation"));
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    CFDictionaryAddValue(v1, CFSTR("RevocationDbIgnored"), (const void *)*MEMORY[0x1E0C9AE50]);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.49"), CFSTR("iPhoneActivation"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateiPhoneDeviceCertificate()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, CFSTR("IssuerCommonName"), CFSTR("Apple iPhone Device CA"));
  if (SecPolicyAddChainLengthOptions(v1, 4) && SecPolicyAddAppleAnchorOptions(v1))
  {
    CFDictionaryAddValue(v1, CFSTR("RevocationDbIgnored"), (const void *)*MEMORY[0x1E0C9AE50]);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.50"), CFSTR("iPhoneDeviceCertificate"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateFactoryDeviceCertificate()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAnchorSHA256Options(v1, kFactoryDeviceCASHA256))
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.51"), CFSTR("FactoryDeviceCertificate"), v1);
  else
    v2 = 0;
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateiAP()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  CFDateRef v2;
  _QWORD *v3;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, CFSTR("SubjectCommonNamePrefix"), CFSTR("IPA_"));
  v2 = CFDateCreate(0, 170726400.0);
  CFDictionaryAddValue(v1, CFSTR("NotValidBefore"), v2);
  CFDictionaryAddValue(v1, CFSTR("RevocationDbIgnored"), (const void *)*MEMORY[0x1E0C9AE50]);
  v3 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.52"), CFSTR("iAP"), v1);
  if (v2)
    CFRelease(v2);
  CFRelease(v1);
  return v3;
}

_QWORD *SecPolicyCreateiTunesStoreURLBag()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, CFSTR("SubjectOrganization"), CFSTR("Apple Inc."));
  CFDictionaryAddValue(v1, CFSTR("SubjectCommonName"), CFSTR("iTunes Store URL Bag"));
  if (SecPolicyAddChainLengthOptions(v1, 2) && SecPolicyAddAnchorSHA256Options(v1, kITMS_CA_SHA256))
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.53"), CFSTR("iTunesStoreURLBag"), v1);
  else
    v2 = 0;
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateiPhoneProfileApplicationSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_element(v1, CFSTR("ExtendedKeyUsage"), CFSTR("1.3.6.1.5.5.7.3.3"));
    add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.1"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.2"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.4"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.25.1"));
    if (os_variant_allows_internal_security_policies())
      add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.25.2"));
    CFDictionaryAddValue(v1, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.55"), CFSTR("iPhoneProfileApplicationSigning"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateiPhoneProvisioningProfileSigning()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  const __CFString *v2;
  _QWORD *v3;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  CFDictionaryAddValue(v1, CFSTR("IssuerCommonName"), CFSTR("Apple iPhone Certification Authority"));
  if (os_variant_allows_internal_security_policies())
    v2 = CFSTR("SubjectCommonNameTEST");
  else
    v2 = CFSTR("SubjectCommonName");
  CFDictionaryAddValue(v1, v2, CFSTR("Apple iPhone OS Provisioning Profile Signing"));
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    CFDictionaryAddValue(v1, CFSTR("NoNetworkAccess"), (const void *)*MEMORY[0x1E0C9AE50]);
    v3 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.56"), CFSTR("iPhoneProvisioningProfileSigning"), v1);
  }
  else
  {
    v3 = 0;
  }
  CFRelease(v1);
  return v3;
}

__CFDictionary *SecPolicyCreateURLBag()
{
  __CFDictionary *result;
  const __CFDictionary *v1;
  _QWORD *v2;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (result)
  {
    v1 = result;
    SecPolicyAddBasicCertOptions(result);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.58"), CFSTR("URLBag"), v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

_QWORD *SecPolicyCreateOTATasking()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, CFSTR("IssuerCommonName"), CFSTR("Apple iPhone Certification Authority"));
    CFDictionaryAddValue(v1, CFSTR("SubjectCommonName"), CFSTR("OTA Task Signing"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.59"), CFSTR("OTATasking"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateMobileAsset()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, CFSTR("IssuerCommonName"), CFSTR("Apple iPhone Certification Authority"));
    CFDictionaryAddValue(v1, CFSTR("SubjectCommonName"), CFSTR("Asset Manifest Signing"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.60"), CFSTR("MobileAsset"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateAppleExternalDeveloperOptionalExpiry(int a1)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v3;
  _QWORD *v4;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  if (a1)
    SecPolicyAddBasicX509Options(Mutable);
  else
    SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v3))
    goto LABEL_11;
  if (!SecPolicyAddChainLengthOptions(v3, 3))
    goto LABEL_11;
  add_element(v3, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.1"));
  add_element(v3, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.6"));
  add_element(v3, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.2"));
  add_element(v3, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.4"));
  add_element(v3, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.5"));
  add_element(v3, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.7"));
  add_element(v3, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.8"));
  add_element(v3, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.12"));
  add_element(v3, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.13"));
  add_element(v3, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.14"));
  add_element(v3, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.35"));
  add_element(v3, CFSTR("ExtendedKeyUsage"), CFSTR("1.3.6.1.5.5.7.3.3"));
  add_element(v3, CFSTR("ExtendedKeyUsage"), CFSTR("1.2.840.113635.100.4.8"));
  add_element(v3, CFSTR("ExtendedKeyUsage"), CFSTR("1.2.840.113635.100.4.9"));
  add_element(v3, CFSTR("ExtendedKeyUsage"), CFSTR("1.2.840.113635.100.4.13"));
  add_element(v3, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
  if (SecPolicyAddStrongKeySizeOptions(v3))
    v4 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.65"), CFSTR("Developer"), v3);
  else
LABEL_11:
    v4 = 0;
  CFRelease(v3);
  return v4;
}

_QWORD *SecPolicyCreateApplePushServiceLegacy(const void *a1)
{
  const __CFAllocator *v2;
  CFDataRef v3;
  CFDataRef v4;
  __CFDictionary *Mutable;
  __CFDictionary *v6;
  const void *v7;
  _QWORD *v8;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], entrustSPKIL1C, 32, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (!v3)
    return 0;
  v4 = v3;
  Mutable = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v6 = Mutable;
    SecPolicyAddBasicX509Options(Mutable);
    CFDictionaryAddValue(v6, CFSTR("SSLHostname"), a1);
    v7 = (const void *)*MEMORY[0x1E0C9AE50];
    CFDictionaryAddValue(v6, CFSTR("BlackListedLeaf"), (const void *)*MEMORY[0x1E0C9AE50]);
    CFDictionaryAddValue(v6, CFSTR("GrayListedLeaf"), v7);
    CFDictionaryAddValue(v6, CFSTR("IntermediateSPKISHA256"), v4);
    add_eku(v6, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
    if (SecPolicyRemoveWeakHashOptions(v6) && SecPolicyAddStrongKeySizeOptions(v6))
    {
      CFDictionaryAddValue(v6, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
      v8 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.70"), CFSTR("AppleLegacyPushService"), v6);
    }
    else
    {
      v8 = 0;
    }
    CFRelease(v4);
  }
  else
  {
    v8 = 0;
    v6 = v4;
  }
  CFRelease(v6);
  return v8;
}

_QWORD *SecPolicyCreateAppleTVOSApplicationSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_oid(v1, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleWWDR, 10);
    add_ku(v1, 1);
    add_leaf_marker_value(v1, (uint64_t)&oidAppleTVOSApplicationSigningProd, 0);
    add_leaf_marker_value(v1, (uint64_t)&oidAppleTVOSApplicationSigningProdQA, 0);
    CFDictionaryAddValue(v1, CFSTR("NoNetworkAccess"), (const void *)*MEMORY[0x1E0C9AE50]);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.71"), CFSTR("AppleTVApplicationSigning"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateAppleGeoTrustServerAuthCommon(const void *a1, const void *a2, const void *a3, void *a4, void *a5)
{
  __CFDictionary *Mutable;
  __CFDictionary *v11;
  _QWORD *v12;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v11 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (!a1)
    goto LABEL_13;
  CFDictionaryAddValue(v11, CFSTR("SSLHostname"), a1);
  add_eku(v11, (const UInt8 *)&oidExtendedKeyUsageServerAuth);
  if (requireUATPinning((uint64_t)a3))
  {
    SecPolicyAddAnchorSHA256Options(v11, GeoTrust_Global_CA_sha256);
    add_element(v11, CFSTR("IntermediateCountry"), CFSTR("US"));
    add_element(v11, CFSTR("IntermediateOrganization"), CFSTR("Apple Inc."));
    if (!SecPolicyAddChainLengthOptions(v11, 3))
    {
LABEL_13:
      v12 = 0;
      goto LABEL_11;
    }
    if (a5)
    {
      add_leaf_prod_qa_element(v11, a4, a5);
      add_leaf_prod_qa_markers_value_string(v11, a4, a5);
    }
    else
    {
      add_element(v11, CFSTR("LeafMarkerOid"), a4);
      add_leaf_marker_value_string(v11, CFSTR("1.2.840.113635.100.6.48.1"), a4);
    }
  }
  if (!SecPolicyRemoveWeakHashOptions(v11) || !SecPolicyAddStrongKeySizeOptions(v11))
    goto LABEL_13;
  v12 = SecPolicyCreate(a2, a3, v11);
LABEL_11:
  CFRelease(v11);
  return v12;
}

_QWORD *SecPolicyCreateAppleSecureIOStaticAsset()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.10")),
        add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.50")),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.75"), CFSTR("SecureIOStaticAsset"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateAppleWarsaw()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.14")),
        add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.29")),
        add_element(v1, CFSTR("Revocation"), CFSTR("AnyRevocationMethod")),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.76"), CFSTR("Warsaw"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

__CFArray *SecPolicyCreateAppleAppTransportSecurity()
{
  const __CFDictionary *Mutable;
  const __CFDictionary *v1;
  __CFArray *v2;
  __CFArray *v3;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  if (SecPolicyAddStrongKeySizeOptions(Mutable))
  {
    v2 = CFArrayCreateMutable(0, 5, MEMORY[0x1E0C9B378]);
    v3 = v2;
    if (v2)
    {
      CFArrayAppendValue(v2, CFSTR("SignatureDigestMD2"));
      CFArrayAppendValue(v3, CFSTR("SignatureDigestMD4"));
      CFArrayAppendValue(v3, CFSTR("SignatureDigestMD5"));
      CFArrayAppendValue(v3, CFSTR("SignatureDigestSHA1"));
      CFArrayAppendValue(v3, CFSTR("SignatureDigestSHA224"));
      add_element(v1, CFSTR("SignatureHashAlgorithms"), v3);
      v3 = (__CFArray *)SecPolicyCreate(CFSTR("1.2.840.113635.100.1.80"), CFSTR("ATS"), v1);
    }
  }
  else
  {
    v3 = 0;
  }
  CFRelease(v1);
  return v3;
}

_QWORD *SecPolicyCreateMacOSProfileApplicationSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_element(v1, CFSTR("ExtendedKeyUsage"), CFSTR("1.3.6.1.5.5.7.3.3"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.12"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.7"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.13"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.22"));
    CFDictionaryAddValue(v1, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.81"), CFSTR("macOSProfileApplicationSigning"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateMobileSoftwareUpdate()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1) || !SecPolicyAddChainLengthOptions(v1, 3))
    goto LABEL_10;
  add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.18"));
  add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.57.2"));
  if (os_variant_allows_internal_security_policies())
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.57.1"));
  if (SecPolicyAddStrongKeySizeOptions(v1))
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.82"), CFSTR("MobileSoftwareUpdate"), v1);
  else
LABEL_10:
    v2 = 0;
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateMobileAssetDevelopment()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1) && SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.18"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.55.1"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.83"), CFSTR("MobileAsset"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateiPhoneVPNApplicationSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1))
    goto LABEL_10;
  if (os_variant_allows_internal_security_policies())
  {
    CFDictionaryAddValue(v1, CFSTR("SubjectCommonNameTEST"), CFSTR("Apple iPhone OS Application Signing"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.6.1"));
  }
  else
  {
    CFDictionaryAddValue(v1, CFSTR("SubjectCommonName"), CFSTR("Apple iPhone OS Application Signing"));
  }
  add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.6"));
  add_eku(v1, 0);
  add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
  add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
  CFDictionaryAddValue(v1, CFSTR("IssuerCommonName"), CFSTR("Apple iPhone Certification Authority"));
  if (SecPolicyAddChainLengthOptions(v1, 3))
  {
    CFDictionaryAddValue(v1, CFSTR("NoNetworkAccess"), (const void *)*MEMORY[0x1E0C9AE50]);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.86"), CFSTR("iPhoneVPNApplicationSigning"), v1);
  }
  else
  {
LABEL_10:
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateiAPSWAuthWithExpiration(int a1)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v3;
  _QWORD *v4;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  if (a1)
    SecPolicyAddBasicX509Options(Mutable);
  else
    SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v3, 2))
  {
    add_element(v3, CFSTR("LeafMarkerOidWithoutValueCheck"), CFSTR("1.2.840.113635.100.6.59.1"));
    CFDictionaryAddValue(v3, CFSTR("RevocationDbIgnored"), (const void *)*MEMORY[0x1E0C9AE50]);
    v4 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.87"), CFSTR("iAPSWAuth"), v3);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

_QWORD *SecPolicyCreateDemoDigitalCatalogSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3))
  {
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.60"));
    add_element(v1, CFSTR("IssuerCommonName"), CFSTR("DemoUnit CA"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.88"), CFSTR("DemoCatalog"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateAppleAssetReceipt()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.10")),
        add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.61")),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.89"), CFSTR("AssetReceipt"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateAppleDeveloperIDPlusTicket()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.17")),
        add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.30")),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.90"), CFSTR("DeveloperIDPlusTicket"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

__CFDictionary *SecPolicyCreateAppleFDRProvisioning()
{
  __CFDictionary *result;
  __CFDictionary *v1;
  _QWORD *v2;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (result)
  {
    v1 = result;
    SecPolicyAddBasicCertOptions(result);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.91"), CFSTR("FDRProvisioning"), v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

_QWORD *SecPolicyCreateAppleKeyTransparency(void *a1)
{
  __CFDictionary *Mutable;
  __CFDictionary *v3;
  _QWORD *v4;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3)
    && SecPolicyAddChainLengthOptions(v3, 3)
    && (add_element(v3, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.3")),
        add_leaf_marker_value_string(v3, CFSTR("1.2.840.113635.100.12.4"), a1),
        SecPolicyAddStrongKeySizeOptions(v3))
    && SecPolicyRemoveWeakHashOptions(v3))
  {
    v4 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.93"), CFSTR("KT"), v3);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

_QWORD *SecPolicyCreateAlisha()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  CFDictionaryRef v2;
  CFDictionaryRef v3;
  _QWORD *v4;
  const void *v5;
  uint64_t valuePtr;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  valuePtr = 256;
  valuePtr = (uint64_t)CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
  if (valuePtr
    && (v2 = CFDictionaryCreate(0, (const void **)&kSecAttrKeyTypeEC, (const void **)&valuePtr, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0])) != 0)
  {
    v3 = v2;
    add_element(v1, CFSTR("KeySize"), v2);
    if (SecPolicyRemoveWeakHashOptions(v1))
      v4 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.95"), CFSTR("Alisha"), v1);
    else
      v4 = 0;
    CFRelease(v1);
  }
  else
  {
    v4 = 0;
    v3 = v1;
  }
  CFRelease(v3);
  v5 = (const void *)valuePtr;
  if (valuePtr)
  {
    valuePtr = 0;
    CFRelease(v5);
  }
  return v4;
}

_QWORD *SecPolicyCreateMeasuredBootPolicySigning()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.24.17")),
        add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.26.6.1")),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.96"), CFSTR("MeasuredBootPolicySigning"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateApplePayQRCodeEncryption()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.22")),
        add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.13.3")),
        SecPolicyAddStrongKeySizeOptions(v1))
    && SecPolicyAddAnchorSHA256Options(v1, AppleExternalECRoot_SHA256)
    && (!os_variant_allows_internal_security_policies()
     || SecPolicyAddAnchorSHA256Options(v1, TestAppleExternalECRoot_SHA256)))
  {
    add_element(v1, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.97"), CFSTR("ApplePayQRCodeEncryption"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateApplePayQRCodeSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.22")),
        add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.12.12")),
        SecPolicyAddStrongKeySizeOptions(v1))
    && SecPolicyAddAnchorSHA256Options(v1, AppleExternalECRoot_SHA256)
    && (!os_variant_allows_internal_security_policies()
     || SecPolicyAddAnchorSHA256Options(v1, TestAppleExternalECRoot_SHA256)))
  {
    add_element(v1, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.98"), CFSTR("ApplePayQRCodeSigning"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateAppleAccessoryUpdateSigning()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddChainLengthOptions(v1, 3) || !SecPolicyAddAppleAnchorOptions(v1))
    goto LABEL_10;
  add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.17"));
  add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.12.9"));
  if (CFPreferencesGetAppBooleanValue(CFSTR("AllowAccessoryUpdateSigningBeta"), CFSTR("com.apple.security"), 0))
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.12.10"));
  if (SecPolicyAddStrongKeySizeOptions(v1))
  {
    add_element(v1, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.99"), CFSTR("AccessoryUpdateSigning"), v1);
  }
  else
  {
LABEL_10:
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateEscrowServiceIdKeySigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 1);
  CFDictionaryAddValue(v1, CFSTR("SubjectCommonName"), CFSTR("Escrow Service ID Key"));
  if (SecPolicyAddChainLengthOptions(v1, 2))
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.100"), CFSTR("AppleEscrowServiceIdKeySigning"), v1);
  else
    v2 = 0;
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreatePCSEscrowServiceIdKeySigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  add_ku(v1, 1);
  CFDictionaryAddValue(v1, CFSTR("SubjectCommonName"), CFSTR("Effaceable Service ID Key"));
  if (SecPolicyAddChainLengthOptions(v1, 2))
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.101"), CFSTR("ApplePCSEscrowServiceIdKeySigning"), v1);
  else
    v2 = 0;
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateDeveloperIDInstaller()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.6")),
        add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.14")),
        add_element(v1, CFSTR("ExtendedKeyUsage"), CFSTR("1.2.840.113635.100.4.13")),
        add_element(v1, CFSTR("Revocation"), CFSTR("AnyRevocationMethod")),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.103"), CFSTR("DeveloperIDInstaller"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateMacAppStoreInstaller()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v1)
    && SecPolicyAddChainLengthOptions(v1, 3)
    && (add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.1")),
        add_leaf_prod_qa_element(v1, CFSTR("1.2.840.113635.100.6.1.10"), CFSTR("1.2.840.113635.100.6.1.10.1")),
        add_element(v1, CFSTR("ExtendedKeyUsage"), CFSTR("1.2.840.113635.100.4.10")),
        add_element(v1, CFSTR("Revocation"), CFSTR("AnyRevocationMethod")),
        SecPolicyAddStrongKeySizeOptions(v1)))
  {
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.104"), CFSTR("MacAppStoreInstaller"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateAppleCHIPUpdateSigning()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddChainLengthOptions(v1, 3) || !SecPolicyAddAppleAnchorOptions(v1))
    goto LABEL_10;
  add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.17"));
  add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.12.25"));
  if (CFPreferencesGetAppBooleanValue(CFSTR("AllowCHIPUpdateSigningBeta"), CFSTR("com.apple.security"), 0))
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.12.26"));
  if (SecPolicyAddStrongKeySizeOptions(v1))
  {
    add_element(v1, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.109"), CFSTR("CHIPUpdateSigning"), v1);
  }
  else
  {
LABEL_10:
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateOrderBundleSigner(void *a1)
{
  __CFDictionary *Mutable;
  const __CFDictionary *v3;
  _QWORD *v4;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v3 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v3) && SecPolicyAddChainLengthOptions(v3, 3))
  {
    add_leaf_marker_value_string(v3, CFSTR("1.2.840.113635.100.14.2"), a1);
    add_element(v3, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.1"));
    add_element(v3, CFSTR("ExtendedKeyUsage"), CFSTR("1.2.840.113635.100.4.19"));
    add_element(v3, CFSTR("Revocation"), CFSTR("AnyRevocationMethod"));
    v4 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.110"), CFSTR("OrderBundleSigner"), v3);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

__CFDictionary *SecPolicyCreateQiSigning()
{
  __CFDictionary *result;
  __CFDictionary *v1;
  _QWORD *v2;

  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (result)
  {
    v1 = result;
    SecPolicyAddBasicCertOptions(result);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.111"), CFSTR("QiSigning"), v1);
    CFRelease(v1);
    return (__CFDictionary *)v2;
  }
  return result;
}

_QWORD *SecPolicyCreateAppleXROSApplicationSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (SecPolicyAddChainLengthOptions(v1, 3) && SecPolicyAddAppleAnchorOptions(v1))
  {
    add_oid(v1, CFSTR("IntermediateMarkerOid"), _oidAppleIntmMarkerAppleWWDR, 10);
    add_ku(v1, 1);
    add_eku(v1, (const UInt8 *)&oidAnyExtendedKeyUsage);
    add_eku(v1, (const UInt8 *)&oidExtendedKeyUsageCodeSigning);
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.36"));
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.6.1.36.1"));
    CFDictionaryAddValue(v1, CFSTR("NoNetworkAccess"), (const void *)*MEMORY[0x1E0C9AE50]);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.113"), CFSTR("AppleXROSApplicationSigning"), v1);
  }
  else
  {
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

_QWORD *SecPolicyCreateEDPSigning()
{
  __CFDictionary *Mutable;
  const __CFDictionary *v1;
  _QWORD *v2;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v1 = Mutable;
  SecPolicyAddBasicCertOptions(Mutable);
  if (!SecPolicyAddAppleAnchorOptions(v1) || !SecPolicyAddChainLengthOptions(v1, 3))
    goto LABEL_10;
  add_element(v1, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.17"));
  if (os_variant_allows_internal_security_policies())
    add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.12.48"));
  add_element(v1, CFSTR("LeafMarkerOid"), CFSTR("1.2.840.113635.100.12.47"));
  if (SecPolicyAddStrongKeySizeOptions(v1))
  {
    CFDictionaryAddValue(v1, CFSTR("NoNetworkAccess"), (const void *)*MEMORY[0x1E0C9AE50]);
    v2 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.114"), CFSTR("EDPSigning"), v1);
  }
  else
  {
LABEL_10:
    v2 = 0;
  }
  CFRelease(v1);
  return v2;
}

void add_leaf_marker_value_string(const __CFDictionary *a1, void *a2, void *a3)
{
  CFDictionaryRef v4;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  if (a3)
  {
    values = a3;
    keys[0] = a2;
    v4 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    add_element(a1, CFSTR("LeafMarkerOid"), v4);
    if (v4)
      CFRelease(v4);
  }
  else
  {
    add_element(a1, CFSTR("LeafMarkerOid"), a2);
  }
}

BOOL SecPolicyAddAnchorSHA256Options(const __CFDictionary *a1, const UInt8 *a2)
{
  CFDataRef v3;

  v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, 32);
  if (v3)
  {
    add_element(a1, CFSTR("AnchorSHA256"), v3);
    CFRelease(v3);
  }
  return v3 != 0;
}

void SecPolicySetOid(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  if (a1 && cf)
  {
    v4 = *(const void **)(a1 + 16);
    CFRetain(cf);
    *(_QWORD *)(a1 + 16) = cf;
    if (v4)
      CFRelease(v4);
  }
}

_QWORD *SecPolicyCreatePrivacyConfigurationProfileSigner(int a1, int a2)
{
  __CFDictionary *Mutable;
  __CFDictionary *v5;
  _BOOL4 v6;
  _QWORD *v7;

  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v5 = Mutable;
  SecPolicyAddBasicX509Options(Mutable);
  if (SecPolicyAddAppleAnchorOptions(v5))
  {
    v6 = SecPolicyAddChainLengthOptions(v5, 3);
    v7 = 0;
    if ((a1 | a2) == 1 && v6)
    {
      if (a1)
        add_eku(v5, oidAppleExtendedKeyUsageProfileSigning);
      if (a2)
        add_eku(v5, oidAppleExtendedKeyUsageQAProfileSigning);
      add_element(v5, CFSTR("IntermediateMarkerOid"), CFSTR("1.2.840.113635.100.6.2.3"));
      v7 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.25"), CFSTR("AppleProfileSigner"), v5);
    }
  }
  else
  {
    v7 = 0;
  }
  CFRelease(v5);
  return v7;
}

const __CFString *isAppleOid(const __CFString *a1)
{
  const __CFString *result;

  result = SecCertificateIsOidString(a1);
  if ((_DWORD)result)
    return (const __CFString *)(CFStringHasPrefix(a1, CFSTR("1.2.840.113635")) != 0);
  return result;
}

void add_ats_options_from_dict(const __CFDictionary *a1, const __CFString *a2, CFDictionaryRef theDict)
{
  const __CFDictionary *Value;
  const __CFDictionary *v6;
  CFTypeID v7;
  CFMutableArrayRef v8;
  CFMutableArrayRef v9;

  if (a2 && theDict)
  {
    Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("NSPinnedDomains"));
    if (Value)
    {
      v6 = Value;
      v7 = CFGetTypeID(Value);
      if (v7 == CFDictionaryGetTypeID())
      {
        v8 = parseNSPinnedDomains(v6, a2, (uint64_t)CFSTR("NSPinnedLeafIdentities"));
        if (v8)
          add_element(a1, CFSTR("LeafSPKISHA256"), v8);
        v9 = parseNSPinnedDomains(v6, a2, (uint64_t)CFSTR("NSPinnedCAIdentities"));
        if (v9)
          add_element(a1, CFSTR("CAspkiSHA256"), v9);
      }
    }
    SecPolicyReconcilePinningRequiredIfInfoSpecified(a1);
  }
}

CFMutableArrayRef parseNSPinnedDomains(const __CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  CFMutableArrayRef Mutable;
  CFIndex Length;
  CFIndex v8;
  _QWORD v10[8];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  CFRange v15;

  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  Length = CFStringGetLength(a2);
  v8 = Length - 1;
  if (Length >= 1 && CFStringGetCharacterAtIndex(a2, v8) == 46)
  {
    v15.location = 0;
    v15.length = v8;
    a2 = CFStringCreateWithSubstring(0, a2, v15);
    if (!a2)
      goto LABEL_9;
  }
  else if (a2)
  {
    CFRetain(a2);
  }
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __parseNSPinnedDomains_block_invoke;
  v10[3] = &unk_1E1FD9B18;
  v10[4] = &v11;
  v10[5] = a2;
  v10[6] = a3;
  v10[7] = Mutable;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)apply_block_2_11134, v10);
  if (a2)
    CFRelease(a2);
LABEL_9:
  if (!*((_BYTE *)v12 + 24) && Mutable)
  {
    CFRelease(Mutable);
    Mutable = 0;
  }
  _Block_object_dispose(&v11, 8);
  return Mutable;
}

void __parseNSPinnedDomains_block_invoke(uint64_t a1, const __CFString *cf, const void *a3)
{
  CFTypeID v6;
  CFTypeID TypeID;
  CFTypeID v8;
  const __CFString *v9;
  CFIndex Length;
  CFIndex v11;
  CFIndex location;
  const __CFString *v13;
  const __CFString *v14;
  const __CFArray *Value;
  const __CFArray *v16;
  CFTypeID v17;
  _QWORD context[5];
  CFRange v19;
  CFRange v20;

  if (cf)
  {
    v6 = CFGetTypeID(cf);
    TypeID = CFStringGetTypeID();
    if (a3)
    {
      if (v6 == TypeID)
      {
        v8 = CFGetTypeID(a3);
        if (v8 == CFDictionaryGetTypeID())
        {
          if (CFStringCompare(cf, *(CFStringRef *)(a1 + 40), 1uLL))
          {
            if (CFDictionaryGetValue((CFDictionaryRef)a3, CFSTR("NSIncludesSubdomains")) != (const void *)*MEMORY[0x1E0C9AE50])
              return;
            v9 = *(const __CFString **)(a1 + 40);
            if (!v9)
              return;
            Length = CFStringGetLength(*(CFStringRef *)(a1 + 40));
            if (!Length)
              return;
            v11 = Length;
            location = CFStringFind(v9, CFSTR("."), 0).location;
            if (location == -1)
              return;
            if (location >= v11 - 1)
              return;
            v20.location = location + 1;
            v20.length = v11 + ~location;
            v13 = CFStringCreateWithSubstring(0, v9, v20);
            if (!v13)
              return;
            v14 = v13;
            if (CFStringCompare(cf, v13, 1uLL))
            {
LABEL_19:
              CFRelease(v14);
              return;
            }
          }
          else
          {
            v14 = 0;
          }
          Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)a3, *(const void **)(a1 + 48));
          if (Value)
          {
            v16 = Value;
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
            v17 = CFGetTypeID(Value);
            if (v17 == CFArrayGetTypeID())
            {
              context[0] = MEMORY[0x1E0C809B0];
              context[1] = 0x40000000;
              context[2] = __parseNSPinnedDomains_block_invoke_2;
              context[3] = &__block_descriptor_tmp_489;
              context[4] = *(_QWORD *)(a1 + 56);
              v19.length = CFArrayGetCount(v16);
              v19.location = 0;
              CFArrayApplyFunction(v16, v19, (CFArrayApplierFunction)apply_block_1_11135, context);
            }
          }
          if (v14)
            goto LABEL_19;
        }
      }
    }
  }
}

uint64_t apply_block_2_11134(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void __parseNSPinnedDomains_block_invoke_2(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  const __CFString *Value;
  const __CFString *v6;
  CFTypeID v7;
  const void *CFDataFromBase64CFString;
  const void *v9;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFDictionaryGetTypeID())
    {
      Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("SPKI-SHA256-BASE64"));
      if (Value)
      {
        v6 = Value;
        v7 = CFGetTypeID(Value);
        if (v7 == CFStringGetTypeID())
        {
          CFDataFromBase64CFString = (const void *)CreateCFDataFromBase64CFString(v6);
          if (CFDataFromBase64CFString)
          {
            v9 = CFDataFromBase64CFString;
            CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), CFDataFromBase64CFString);
            CFRelease(v9);
          }
        }
      }
    }
  }
}

uint64_t apply_block_1_11135(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t CreateCFDataFromBase64CFString(const __CFString *a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  if (a1)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 0x40000000;
    v3[2] = __CreateCFDataFromBase64CFString_block_invoke;
    v3[3] = &unk_1E1FD9AD0;
    v3[4] = &v4;
    CFStringPerformWithCStringAndLength(a1, (uint64_t)v3);
    v1 = v5[3];
  }
  else
  {
    v1 = 0;
  }
  _Block_object_dispose(&v4, 8);
  return v1;
}

_QWORD *SecPolicyCreateAppleAST2Service(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.42"), CFSTR("AST2"), (uint64_t)&oidAppleCertExtAST2DiagnosticsServerAuthProd, (uint64_t)&oidAppleCertExtAST2DiagnosticsServerAuthProdQA);
}

_QWORD *SecPolicyCreateAppleEscrowProxyService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.43"), CFSTR("Escrow"), (uint64_t)&oidAppleCertExtEscrowProxyServerAuthProd, (uint64_t)&oidAppleCertExtEscrowProxyServerAuthProdQA);
}

_QWORD *SecPolicyCreateAppleFMiPService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.44"), CFSTR("FMiP"), (uint64_t)&oidAppleCertExtFMiPServerAuthProd, (uint64_t)&oidAppleCertExtFMiPServerAuthProdQA);
}

_QWORD *SecPolicyCreateAppleMMCSService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.45"), CFSTR("MMCS"), (uint64_t)&oidAppleCertExtAppleServerAuthenticationMMCSProd, (uint64_t)&oidAppleCertExtAppleServerAuthenticationMMCSProdQA);
}

_QWORD *SecPolicyCreateAppleGSService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.46"), CFSTR("GS"), (uint64_t)&oidAppleCertExtAppleServerAuthenticationGS, 0);
}

_QWORD *SecPolicyCreateApplePPQService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.47"), CFSTR("PPQ"), (uint64_t)&oidAppleCertExtAppleServerAuthenticationPPQProd, (uint64_t)&oidAppleCertExtAppleServerAuthenticationPPQProdQA);
}

_QWORD *SecPolicyCreateAppleIDSServiceContext(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.68"), CFSTR("IDS"), (uint64_t)&oidAppleCertExtAppleServerAuthenticationIDSProd, (uint64_t)&oidAppleCertExtAppleServerAuthenticationIDSProdQA);
}

_QWORD *SecPolicyCreateApplePushService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.69"), CFSTR("APN"), (uint64_t)&oidAppleCertExtAppleServerAuthenticationAPNProd, (uint64_t)&oidAppleCertExtAppleServerAuthenticationAPNProdQA);
}

_QWORD *SecPolicyCreateAppleiCloudSetupService(const void *a1)
{
  return SecPolicyCreateAppleServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.77"), CFSTR("iCloudSetup"), (uint64_t)&oidAppleCertExtAppleServerAuthenticationiCloudSetupProd, (uint64_t)&oidAppleCertExtAppleServerAuthenticationiCloudSetupProdQA);
}

_QWORD *SecPolicyCreateParakeetService(const void *a1, const void *a2)
{
  return SecPolicyCreateParakeetCommon(a1, a2, CFSTR("1.2.840.113635.100.1.118"), CFSTR("ParakeetService"));
}

_QWORD *SecPolicyCreateMobileStoreSigner()
{
  return CreateMobileStoreSigner(0);
}

_QWORD *SecPolicyCreateTestMobileStoreSigner()
{
  return CreateMobileStoreSigner(1);
}

_QWORD *SecPolicyCreateAppleExternalDeveloper()
{
  return SecPolicyCreateAppleExternalDeveloperOptionalExpiry(1);
}

_QWORD *SecPolicyCreateAppleCompatibilityEscrowProxyService(const void *a1)
{
  return SecPolicyCreateAppleGeoTrustServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.73"), CFSTR("Escrow"), CFSTR("1.2.840.113635.100.6.27.7.2"), CFSTR("1.2.840.113635.100.6.27.7.1"));
}

_QWORD *SecPolicyCreateAppleCompatibilityMMCSService(const void *a1)
{
  return SecPolicyCreateAppleGeoTrustServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.74"), CFSTR("MMCS"), CFSTR("1.2.840.113635.100.6.27.11.2"), CFSTR("1.2.840.113635.100.6.27.11.1"));
}

_QWORD *SecPolicyCreateAppleCompatibilityiCloudSetupService(const void *a1)
{
  return SecPolicyCreateAppleGeoTrustServerAuthCommon(a1, CFSTR("1.2.840.113635.100.1.78"), CFSTR("iCloudSetup"), CFSTR("1.2.840.113635.100.6.27.15.2"), CFSTR("1.2.840.113635.100.6.27.15.1"));
}

_QWORD *SecPolicyCreateiAPSWAuth()
{
  return SecPolicyCreateiAPSWAuthWithExpiration(0);
}

_QWORD *SecPolicyCreateMacDistributionInstaller()
{
  return SecPolicyCreateApplePinned(CFSTR("MacDistributionInstaller"), CFSTR("1.2.840.113635.100.6.2.1"), CFSTR("1.2.840.113635.100.6.1.8"));
}

_QWORD *SecPolicyCreateParakeetSigning()
{
  return SecPolicyCreateParakeetCommon(0, 0, CFSTR("1.2.840.113635.100.1.116"), CFSTR("ParakeetSigning"));
}

uint64_t SecPolicyGetOidString(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void SecPolicySetOptionsValue_internal(uint64_t a1, const void *a2, const void *a3)
{
  const __CFDictionary *v6;
  __CFDictionary *MutableCopy;
  const void *v8;
  const void *v9;

  if (a1 && a2 && a3)
  {
    v6 = *(const __CFDictionary **)(a1 + 32);
    if (v6)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v6);
    }
    else
    {
      MutableCopy = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (!MutableCopy)
        return;
    }
    v8 = *(const void **)(a1 + 32);
    if (v8)
    {
      *(_QWORD *)(a1 + 32) = 0;
      CFRelease(v8);
    }
    if (CFEqual(a2, CFSTR("TemporalValidity")) && CFEqual(a3, (CFTypeRef)*MEMORY[0x1E0C9AE40]))
      CFDictionaryRemoveValue(MutableCopy, a2);
    else
      CFDictionarySetValue(MutableCopy, a2, a3);
    v9 = *(const void **)(a1 + 32);
    if (v9)
      CFRelease(v9);
    *(_QWORD *)(a1 + 32) = MutableCopy;
  }
}

void SecPolicySetSHA256Pins(uint64_t a1, const void *a2, const void *a3)
{
  __CFDictionary *v6;
  CFMutableDictionaryRef Mutable;

  if (a1)
  {
    v6 = *(__CFDictionary **)(a1 + 32);
    if (!v6)
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (!Mutable)
        return;
      v6 = Mutable;
      *(_QWORD *)(a1 + 32) = Mutable;
    }
    CFDictionaryRemoveValue(v6, CFSTR("LeafSPKISHA256"));
    if (a2)
      add_element(v6, CFSTR("LeafSPKISHA256"), a2);
    CFDictionaryRemoveValue(v6, CFSTR("CAspkiSHA256"));
    if (a3)
      add_element(v6, CFSTR("CAspkiSHA256"), a3);
  }
}

uint64_t SecPolicySetSSLHostname(uint64_t a1, const void *a2)
{
  BOOL v2;
  uint64_t v3;

  if (a1)
    v2 = a2 == 0;
  else
    v2 = 1;
  v3 = !v2;
  if (!v2)
    SecPolicySetOptionsValue_internal(a1, CFSTR("SSLHostname"), a2);
  return v3;
}

uint64_t SecPolicySetATSPinning(uint64_t result, const __CFDictionary *a2)
{
  uint64_t v3;
  const __CFString *Value;
  CFTypeID v5;
  const __CFDictionary *MutableCopy;
  const void *v7;
  const void *v8;

  if (result)
  {
    v3 = result;
    Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(result + 32), CFSTR("SSLHostname"));
    result = 0;
    if (a2)
    {
      if (Value)
      {
        v5 = CFGetTypeID(Value);
        if (v5 == CFStringGetTypeID())
        {
          MutableCopy = CFDictionaryCreateMutableCopy(0, 0, *(CFDictionaryRef *)(v3 + 32));
          v7 = *(const void **)(v3 + 32);
          if (v7)
          {
            *(_QWORD *)(v3 + 32) = 0;
            CFRelease(v7);
          }
          add_ats_options_from_dict(MutableCopy, Value, a2);
          v8 = *(const void **)(v3 + 32);
          if (v8)
            CFRelease(v8);
          *(_QWORD *)(v3 + 32) = MutableCopy;
          return 1;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

_QWORD *SecPolicyCreateVerifiedMark(const void *a1, const __CFData *a2)
{
  const __CFAllocator *v4;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v6;
  CFMutableDictionaryRef v7;
  __CFDictionary *v8;
  const UInt8 *BytePtr;
  CFIndex Length;
  __CFData *v11;
  const UInt8 *v12;
  CFIndex v13;
  __CFData *v14;
  _QWORD *v15;

  if (!a2)
    return 0;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0;
  v6 = Mutable;
  v7 = CFDictionaryCreateMutable(v4, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v7)
  {
    v15 = 0;
    v14 = v6;
LABEL_14:
    CFRelease(v14);
    return v15;
  }
  v8 = v7;
  SecPolicyAddBasicX509Options(v6);
  if (a1)
    CFDictionaryAddValue(v6, CFSTR("SSLHostname"), a1);
  if (SecPolicyRemoveWeakHashOptions(v6) && SecPolicyAddStrongKeySizeOptions(v6))
  {
    add_element(v6, CFSTR("CertificatePolicy"), CFSTR("1.3.6.1.4.1.53087.1.1"));
    CFDictionaryAddValue(v6, CFSTR("SinglePurposeChainEKU"), CFSTR("1.3.6.1.5.5.7.3.31"));
    BytePtr = CFDataGetBytePtr(a2);
    Length = CFDataGetLength(a2);
    v11 = SecSHA1DigestCreate(v4, (uint64_t)BytePtr, Length);
    if (v11)
    {
      v12 = CFDataGetBytePtr(a2);
      v13 = CFDataGetLength(a2);
      v14 = SecSHA256DigestCreate(v4, (uint64_t)v12, v13);
      if (v14)
      {
        CFDictionaryAddValue(v8, CFSTR("sha1"), v11);
        CFDictionaryAddValue(v8, CFSTR("sha256"), v14);
        add_element(v6, CFSTR("MarkRepresentation"), v8);
        v15 = SecPolicyCreate(CFSTR("1.2.840.113635.100.1.115"), a1, v6);
      }
      else
      {
        v15 = 0;
      }
    }
    else
    {
      v15 = 0;
      v14 = 0;
    }
  }
  else
  {
    v15 = 0;
    v14 = 0;
    v11 = 0;
  }
  CFRelease(v6);
  CFRelease(v8);
  if (v11)
    CFRelease(v11);
  if (v14)
    goto LABEL_14;
  return v15;
}

BOOL SecPolicyCheckCertCriticalExtensions(uint64_t a1)
{
  return !a1 || *(_BYTE *)(a1 + 296) == 0;
}

BOOL SecPolicyCheckCertEmailSAN(uint64_t a1, const __CFString *cf, int a3)
{
  CFTypeID v6;
  const __CFArray *v7;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  BOOL v12;
  const __CFString *ValueAtIndex;

  if (cf
    && (v6 = CFGetTypeID(cf), v6 == CFStringGetTypeID())
    && (!a3 ? (v7 = SecCertificateCopyRFC822Names(a1)) : (v7 = SecCertificateCopyRFC822NamesFromSAN(a1)),
        (v8 = v7) != 0))
  {
    Count = CFArrayGetCount(v7);
    if (Count < 1)
    {
      v12 = 0;
    }
    else
    {
      v10 = Count;
      v11 = 0;
      v12 = 1;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, v11);
        if (CFStringCompare(cf, ValueAtIndex, 1uLL) == kCFCompareEqualTo)
          break;
        v12 = ++v11 < v10;
      }
      while (v10 != v11);
    }
    CFRelease(v8);
  }
  else
  {
    return 0;
  }
  return v12;
}

BOOL SecPolicyCheckCertEmail(uint64_t a1, const __CFString *a2)
{
  return SecPolicyCheckCertEmailSAN(a1, a2, 0);
}

BOOL SecPolicyCheckCertTemporalValidity(uint64_t a1, uint64_t a2)
{
  double v3;

  MEMORY[0x18D76F188](a2);
  return a1 && *(double *)(a1 + 168) <= v3 && *(double *)(a1 + 176) >= v3;
}

const __CFString *SecPolicyCheckCertSubjectCommonNamePrefix(uint64_t a1, const __CFString *cf)
{
  const __CFString *v2;
  CFTypeID v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const __CFString *ValueAtIndex;

  v2 = cf;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (v5 = SecCertificateCopyCommonNames(a1)) != 0)
    {
      v6 = v5;
      v2 = (const __CFString *)(CFArrayGetCount(v5) == 1
                             && (ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v6, 0),
                                 CFStringHasPrefix(ValueAtIndex, v2)));
      CFRelease(v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

BOOL SecPolicyCheckCertNotValidBefore(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;

  if (!cf)
    return 0;
  v4 = CFGetTypeID(cf);
  return v4 == CFDateGetTypeID() && *(double *)(a1 + 168) > MEMORY[0x18D76F188](cf);
}

CFTypeRef SecPolicyCheckCertSubjectOrganizationalUnit(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2;
  CFTypeID v4;
  const __CFArray *v5;
  const __CFArray *v6;
  const void *ValueAtIndex;

  v2 = cf;
  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (v5 = SecCertificateCopyOrganizationalUnit(a1)) != 0)
    {
      v6 = v5;
      v2 = (CFTypeRef)(CFArrayGetCount(v5) == 1
                    && (ValueAtIndex = CFArrayGetValueAtIndex(v6, 0), CFEqual(v2, ValueAtIndex)));
      CFRelease(v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t SecPolicyCheckCertEAPTrustedServerNames(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  CFIndex Count;
  const __CFArray *v6;
  const __CFArray *v7;
  CFIndex v8;
  CFIndex v9;
  CFIndex v10;
  const __CFString *ValueAtIndex;
  const __CFString *v12;
  CFIndex v13;
  const __CFString *v14;
  const __CFString *v15;
  CFTypeID v16;
  uint64_t v17;

  if (!cf)
    return 1;
  v4 = CFGetTypeID(cf);
  if (v4 != CFArrayGetTypeID())
    return 0;
  Count = CFArrayGetCount((CFArrayRef)cf);
  v6 = SecCertificateCopyDNSNames(a1);
  if (!v6)
    return 0;
  v7 = v6;
  v8 = CFArrayGetCount(v6);
  if (v8 >= 1)
  {
    v9 = v8;
    v10 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, v10);
      if (Count >= 1)
        break;
LABEL_12:
      if (++v10 == v9)
        goto LABEL_13;
    }
    v12 = ValueAtIndex;
    v13 = 0;
    while (1)
    {
      v14 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, v13);
      if (!v14)
        break;
      v15 = v14;
      v16 = CFGetTypeID(v14);
      if (v16 != CFStringGetTypeID())
        break;
      if ((SecDNSMatch(v12, v15) & 1) != 0)
      {
        v17 = 1;
        goto LABEL_17;
      }
      if (Count == ++v13)
        goto LABEL_12;
    }
  }
LABEL_13:
  v17 = 0;
LABEL_17:
  CFRelease(v7);
  return v17;
}

uint64_t SecPolicyCheckCertLeafMarkerOidWithoutValueCheck(uint64_t a1, const __CFString *a2)
{
  CFTypeID v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const void *ValueAtIndex;
  uint64_t result;
  CFTypeID v11;
  CFTypeID v12;

  v4 = CFGetTypeID(a2);
  if (v4 != CFArrayGetTypeID())
  {
    v11 = CFGetTypeID(a2);
    if (v11 == CFDataGetTypeID())
      return SecCertificateGetExtensionValue(a1, a2) != 0;
    v12 = CFGetTypeID(a2);
    if (v12 == CFStringGetTypeID())
      return SecCertificateGetExtensionValue(a1, a2) != 0;
    return 0;
  }
  Count = CFArrayGetCount((CFArrayRef)a2);
  v6 = Count - 1;
  if (Count < 1)
    return 0;
  v7 = 0;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v7);
    result = SecPolicyCheckCertLeafMarkerOidWithoutValueCheck(a1, ValueAtIndex);
    if ((result & 1) != 0)
      break;
  }
  while (v6 != v7++);
  return result;
}

uint64_t SecPolicyCheckCertLeafMarkersProdAndQA(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFString *Value;
  uint64_t result;
  const __CFString *v6;

  Value = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("ProdMarker"));
  if (Value && (SecCertificateHasMarkerExtension(a1, Value) & 1) != 0)
    return 1;
  result = os_variant_allows_internal_security_policies();
  if (!(_DWORD)result)
    return result;
  v6 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("QAMarker"));
  return v6 && (SecCertificateHasMarkerExtension(a1, v6) & 1) != 0;
}

BOOL SecPolicyCheckCertCertificatePolicy(uint64_t a1, const __CFString *cf)
{
  CFTypeID v4;
  CFTypeID v6;
  const __CFArray *OidDataFromString;
  const __CFArray *v8;
  _BOOL8 v9;

  v4 = CFGetTypeID(cf);
  if (v4 == CFDataGetTypeID())
    return checkPolicyOidData(a1, cf);
  v6 = CFGetTypeID(cf);
  if (v6 != CFStringGetTypeID())
    return 0;
  OidDataFromString = SecCertificateCreateOidDataFromString(0, cf);
  if (!OidDataFromString)
    return 0;
  v8 = OidDataFromString;
  v9 = checkPolicyOidData(a1, OidDataFromString);
  CFRelease(v8);
  return v9;
}

BOOL checkPolicyOidData(uint64_t a1, const void *a2)
{
  CFMutableSetRef Mutable;
  __CFSet *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFAllocator *v9;
  uint64_t v10;
  CFIndex v11;
  CFDataRef v12;
  _BOOL8 v13;

  Mutable = CFSetCreateMutable(0, 0, MEMORY[0x1E0C9B3B0]);
  if (!Mutable)
    return 0;
  v5 = Mutable;
  if (*(_BYTE *)(a1 + 352))
    v6 = a1 + 352;
  else
    v6 = 0;
  if (*(_BYTE *)(a1 + 352))
  {
    v7 = *(_QWORD *)(v6 + 8);
    if (v7)
    {
      v8 = 0;
      v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      do
      {
        v10 = *(_QWORD *)(v6 + 16) + v8;
        v11 = *(_QWORD *)(v10 + 8);
        if ((v11 & 0x8000000000000000) == 0)
        {
          v12 = CFDataCreate(v9, *(const UInt8 **)v10, v11);
          CFSetAddValue(v5, v12);
          if (v12)
            CFRelease(v12);
        }
        v8 += 32;
        --v7;
      }
      while (v7);
    }
  }
  v13 = CFSetContainsValue(v5, a2) != 0;
  CFRelease(v5);
  return v13;
}

BOOL SecPolicyCheckCertWeakKeySize(__SecCertificate *a1)
{
  return !a1 || (SecCertificateIsWeakKey(a1) & 1) == 0;
}

uint64_t SecPolicyCheckCertNotCA(uint64_t a1)
{
  return SecCertificateIsCA(a1) ^ 1;
}

void SecLeafPVCValidateKey(void *key, uint64_t a2, CFAbsoluteTime *a3)
{
  uint64_t (*Value)(_QWORD, CFDateRef);
  uint64_t (*v6)(_QWORD, CFDateRef);
  CFDateRef v7;
  CFDictionaryRef *ValueAtIndex;
  const __CFDate *v9;

  if (*((_BYTE *)a3 + 56) || *((_QWORD *)a3 + 3))
  {
    Value = (uint64_t (*)(_QWORD, CFDateRef))CFDictionaryGetValue(*((CFDictionaryRef *)a3 + 5), key);
    if (Value)
    {
      v6 = Value;
      if (CFEqual(key, CFSTR("TemporalValidity")))
      {
        v7 = CFDateCreate(0, a3[2]);
        if ((v6(*(_QWORD *)a3, v7) & 1) == 0)
          SecLeafPVCSetResult((uint64_t)a3, key, (const void *)*MEMORY[0x1E0C9AE40]);
        if (v7)
          CFRelease(v7);
      }
      else
      {
        ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*((CFArrayRef *)a3 + 1), *((_QWORD *)a3 + 6));
        if (ValueAtIndex)
        {
          v9 = (const __CFDate *)CFDictionaryGetValue(ValueAtIndex[4], key);
          if ((v6(*(_QWORD *)a3, v9) & 1) == 0)
            SecLeafPVCSetResult((uint64_t)a3, key, (const void *)*MEMORY[0x1E0C9AE40]);
        }
        else
        {
          *((_BYTE *)a3 + 56) = 0;
        }
      }
    }
  }
}

void SecLeafPVCSetResult(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryRef *ValueAtIndex;
  const __CFArray *v7;
  __CFDictionary *v8;

  ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), *(_QWORD *)(a1 + 48));
  if (!ValueAtIndex || CFDictionaryContainsKey(ValueAtIndex[4], a2))
  {
    *(_BYTE *)(a1 + 56) = 0;
    v7 = *(const __CFArray **)(a1 + 24);
    if (v7)
    {
      v8 = (__CFDictionary *)CFArrayGetValueAtIndex(v7, 0);
      CFDictionarySetValue(v8, a2, a3);
    }
  }
}

__CFDictionary *SecRSAPublicKeyCopyAttributeDictionary(const void *a1)
{
  const __CFDictionary *v1;
  __CFDictionary *MutableCopy;
  CFNumberRef v3;
  uint64_t valuePtr;

  v1 = SecKeyCopyAttributeDictionaryWithLocalKey(a1, (uint64_t)CFSTR("42"), 0);
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v1);
  CFDictionarySetValue(MutableCopy, CFSTR("decr"), (const void *)*MEMORY[0x1E0C9AE50]);
  CFDictionarySetValue(MutableCopy, CFSTR("drve"), (const void *)*MEMORY[0x1E0C9AE40]);
  valuePtr = cczp_bitlen();
  v3 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, &valuePtr);
  CFDictionarySetValue(MutableCopy, CFSTR("bsiz"), v3);
  CFDictionarySetValue(MutableCopy, CFSTR("esiz"), v3);
  if (v3)
    CFRelease(v3);
  if (v1)
    CFRelease(v1);
  return MutableCopy;
}

CFStringRef SecRSAPublicKeyCopyDescription(_QWORD *a1)
{
  __CFData *v2;
  _QWORD *v3;
  const __CFAllocator *v4;
  CFIndex Length;
  __CFString *Mutable;
  const UInt8 *BytePtr;
  CFIndex v8;
  CFIndex v9;
  unsigned int v10;
  uint64_t AlgorithmId;
  unsigned int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(_QWORD *);
  uint64_t v17;
  CFStringRef v18;
  uint64_t v20;
  unsigned int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t (*v24)(_QWORD *);

  v2 = SecKeyCopyModulus(a1);
  v3 = (_QWORD *)a1[3];
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Length = CFDataGetLength(v2);
  Mutable = CFStringCreateMutable(v4, 2 * Length);
  BytePtr = CFDataGetBytePtr(v2);
  v8 = CFDataGetLength(v2);
  if (v8 >= 1)
  {
    v9 = v8;
    do
    {
      v10 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0, CFSTR("%02X"), v10);
      --v9;
    }
    while (v9);
  }
  if (Mutable)
  {
    AlgorithmId = SecKeyGetAlgorithmId((uint64_t)a1);
    v12 = (unsigned int *)a1[2];
    v13 = *((_QWORD *)v12 + 1);
    v14 = *v12;
    v15 = cczp_bitlen();
    _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyGetBlockSize");
    v16 = *(uint64_t (**)(_QWORD *))(a1[2] + 80);
    if (v16)
      v17 = v16(a1);
    else
      v17 = 0;
    v18 = CFStringCreateWithFormat(v4, 0, CFSTR("<SecKeyRef algorithm id: %lu, key type: %s, version: %d, %d bits (block size: %zu), exponent: {hex: %llx, decimal: %lld}, modulus: %@, addr: %p>"), AlgorithmId, v13, v14, v15, v17, v3[2 * *v3 + 4], v3[2 * *v3 + 4], Mutable, a1);
    if (v2)
      goto LABEL_9;
  }
  else
  {
    v18 = 0;
    if (v2)
LABEL_9:
      CFRelease(v2);
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v18)
    return v18;
  v20 = SecKeyGetAlgorithmId((uint64_t)a1);
  v21 = (unsigned int *)a1[2];
  v22 = *((_QWORD *)v21 + 1);
  v23 = *v21;
  _SecKeyCheck((uint64_t)a1, (uint64_t)"SecKeyGetBlockSize");
  v24 = *(uint64_t (**)(_QWORD *))(a1[2] + 80);
  if (v24)
    v24 = (uint64_t (*)(_QWORD *))(8 * v24(a1));
  return CFStringCreateWithFormat(v4, 0, CFSTR("<SecKeyRef algorithm id: %lu, key type: %s, version: %d, block size: %zu bits, addr: %p>"), v20, v22, v23, v24, a1);
}

__CFData *SecRSAPublicKeyCopyExternalRepresentation(const void *a1)
{
  const __CFAllocator *v1;

  v1 = CFGetAllocator(a1);
  return SecRSAPublicKeyCreatePKCS1(v1);
}

uint64_t ccrsa_pub_init(unint64_t *a1, uint64_t a2, _BYTE *a3)
{
  uint64_t i;
  unint64_t v5;

  for (i = a2; i; --i)
  {
    if (*a3)
      break;
    ++a3;
  }
  v5 = (unint64_t)(i + 7) >> 3;
  if (v5 > *a1)
    return 0xFFFFFFFFLL;
  *a1 = v5;
  return ccrsa_make_pub();
}

CFStringRef SecRSAPrivateKeyCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  uint64_t AlgorithmId;
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t);
  uint64_t v9;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  AlgorithmId = SecKeyGetAlgorithmId(a1);
  v4 = *(unsigned int **)(a1 + 16);
  v5 = *((_QWORD *)v4 + 1);
  v6 = *v4;
  v7 = cczp_bitlen();
  _SecKeyCheck(a1, (uint64_t)"SecKeyGetBlockSize");
  v8 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 80);
  if (v8)
    v9 = v8(a1);
  else
    v9 = 0;
  return CFStringCreateWithFormat(v2, 0, CFSTR("<SecKeyRef algorithm id: %lu, key type: %s, version: %d, %d bits (block size: %zu), addr: %p>"), AlgorithmId, v5, v6, v7, v9, a1);
}

_QWORD *SecKeyCreateRSAPublicKey_ios(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecRSAPublicKeyDescriptor, a2, a3, a4);
}

_QWORD *SecKeyCreateRSAPublicKey(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SecKeyCreate(a1, (uint64_t)&kSecRSAPublicKeyDescriptor, a2, a3, a4);
}

uint64_t SecSCEPCreateTemporaryIdentity(uint64_t a1, __SecKey *a2)
{
  const __CFAllocator *v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFDictionaryRef v6;
  const __CFDictionary *v7;
  CFStringRef v8;
  CFStringRef v9;
  const __CFArray *v10;
  uint64_t v11;
  const __CFArray *v12;
  _QWORD *SelfSignedCertificateWithError;
  uint64_t v14;
  CFTypeRef cf;
  CFTypeRef v17;
  int valuePtr;
  void *v19[2];
  uuid_t out;
  char cStr[40];
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  valuePtr = 5;
  cf = 0;
  v17 = 0;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  if (!v4)
  {
    v9 = 0;
    v14 = 0;
    goto LABEL_13;
  }
  v5 = v4;
  values = v4;
  keys[0] = CFSTR("keyUsage");
  v6 = CFDictionaryCreate(v3, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!v6)
  {
    v9 = 0;
    v14 = 0;
    v12 = v5;
LABEL_12:
    CFRelease(v12);
    goto LABEL_13;
  }
  v7 = v6;
  memset(cStr, 0, 37);
  memset(out, 170, sizeof(out));
  uuid_generate_random(out);
  uuid_unparse(out, cStr);
  v8 = CFStringCreateWithCString(v3, cStr, 0x600u);
  v9 = v8;
  if (!v8
    || (v19[0] = CFSTR("CN"), v19[1] = (void *)v8, (v17 = CFArrayCreate(v3, (const void **)v19, 2, 0)) == 0)
    || (cf = CFArrayCreate(v3, &v17, 1, 0)) == 0)
  {
    v12 = 0;
    goto LABEL_21;
  }
  v10 = CFArrayCreate(v3, &cf, 1, 0);
  v12 = v10;
  if (!v10)
  {
LABEL_21:
    v14 = 0;
    SelfSignedCertificateWithError = 0;
    goto LABEL_9;
  }
  SelfSignedCertificateWithError = SecGenerateSelfSignedCertificateWithError(v10, v7, v11, a2, 0);
  if (SelfSignedCertificateWithError)
    v14 = SecIdentityCreate((int)v3, SelfSignedCertificateWithError, a2);
  else
    v14 = 0;
LABEL_9:
  CFRelease(v5);
  CFRelease(v7);
  if (SelfSignedCertificateWithError)
    CFRelease(SelfSignedCertificateWithError);
  if (v12)
    goto LABEL_12;
LABEL_13:
  if (cf)
    CFRelease(cf);
  if (v17)
    CFRelease(v17);
  if (v9)
    CFRelease(v9);
  return v14;
}

CFDictionaryRef SecSCEPGenerateCertificateRequest(const __CFArray *a1, const __CFDictionary *a2, CFMutableDataRef Mutable, __SecKey *a4, void *a5, const void *a6)
{
  const __CFArray *v11;
  CFTypeID v12;
  __SecCertificate *ValueAtIndex;
  CFTypeID v14;
  SecKeyRef v15;
  SecKeyRef v16;
  CFDataRef CertificateRequest;
  __CFDictionary *v18;
  const __CFDictionary *v19;
  const __CFDictionary *v20;
  const void *Value;
  const __CFData *v22;
  const __CFData *v23;
  const __CFData *v24;
  CFIndex Length;
  const UInt8 *BytePtr;
  UInt8 *v27;
  const UInt8 *v28;
  __CFDictionary *v29;
  __CFData *v30;
  const __CFArray *v31;
  CFIndex v32;
  char *v33;
  int v34;
  const __CFData *v35;
  CFDataRef v36;
  CFIndex v37;
  const UInt8 *v38;
  __CFData *v39;
  CFDataRef v40;
  __CFData *v41;
  __CFData *v42;
  uint64_t sender_nonce;
  CFDictionaryRef v44;
  __SecKey *v46;
  const __CFDictionary *theDict;
  void *v48;
  __SecKey *v49;
  __SecKey *v50;
  const __CFAllocator *allocator;
  void *values;
  UInt8 bytes[24];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  values = 0;
  v11 = filterRecipients(a6);
  v12 = CFGetTypeID(v11);
  ValueAtIndex = v11;
  if (v12 != SecCertificateGetTypeID())
  {
    v14 = CFGetTypeID(v11);
    if (v14 != CFArrayGetTypeID())
    {
LABEL_38:
      v16 = 0;
      v44 = 0;
      CertificateRequest = 0;
      v15 = 0;
LABEL_39:
      Mutable = 0;
      goto LABEL_54;
    }
    ValueAtIndex = (__SecCertificate *)CFArrayGetValueAtIndex(v11, 0);
  }
  if (!ValueAtIndex)
    goto LABEL_38;
  v15 = SecCertificateCopyKey(ValueAtIndex);
  if (SecKeyGetAlgorithmId((uint64_t)v15) != 1)
  {
    v16 = 0;
    v44 = 0;
    CertificateRequest = 0;
    goto LABEL_39;
  }
  v16 = SecKeyCopyPublicKey(a4);
  if (!v16)
  {
    if (!Mutable)
    {
      v16 = 0;
      v44 = 0;
LABEL_53:
      CertificateRequest = 0;
      goto LABEL_54;
    }
    CFRetain(Mutable);
    v16 = Mutable;
  }
  v46 = a4;
  CertificateRequest = SecGenerateCertificateRequest(a1, a2, v16, a4);
  if (!CertificateRequest)
  {
    v44 = 0;
    goto LABEL_39;
  }
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (Mutable && !SecCMSCreateEnvelopedData(ValueAtIndex, a2, CertificateRequest, (uint64_t)Mutable))
  {
    CFRelease(CertificateRequest);
    v18 = CFDictionaryCreateMutable(allocator, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    memset(bytes, 170, 20);
    v19 = SecKeyCopyAttributes(v16);
    v50 = v15;
    theDict = a2;
    if (v19)
    {
      v20 = v19;
      Value = CFDictionaryGetValue(v19, CFSTR("kcls"));
      if (Value
        && CFEqual(Value, CFSTR("0"))
        && (v22 = (const __CFData *)CFDictionaryGetValue(v20, CFSTR("v_Data"))) != 0
        && (v23 = v22, !((unint64_t)CFDataGetLength(v22) >> 32)))
      {
        CFDataGetBytePtr(v23);
        CFDataGetLength(v23);
        CCDigest();
        v24 = CFDataCreate(allocator, bytes, 20);
      }
      else
      {
        v24 = 0;
      }
      CFRelease(v20);
    }
    else
    {
      v24 = 0;
    }
    Length = CFDataGetLength(v24);
    BytePtr = CFDataGetBytePtr(v24);
    v27 = (UInt8 *)malloc_type_calloc(1uLL, (2 * Length) | 1, 0x71F4B16FuLL);
    v28 = v27;
    v49 = v16;
    if (Length && BytePtr && v27)
    {
      v48 = a5;
      v29 = v18;
      v30 = Mutable;
      v31 = v11;
      v32 = 2 * Length;
      if (Length >= 1)
      {
        v33 = (char *)v27;
        do
        {
          v34 = *BytePtr++;
          snprintf(v33, 3uLL, "%02X", v34);
          v33 += 2;
          --Length;
        }
        while (Length);
      }
      v35 = CFDataCreateWithBytesNoCopy(allocator, v28, v32, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
      v11 = v31;
      Mutable = v30;
      v18 = v29;
      a5 = v48;
      if (v24)
LABEL_26:
        CFRelease(v24);
    }
    else
    {
      if (v27)
        free(v27);
      v35 = 0;
      if (v24)
        goto LABEL_26;
    }
    *(_WORD *)&bytes[8] = 1801;
    v36 = CFDataCreate(allocator, bytes, 10);
    v37 = CFDataGetLength(v35);
    v38 = CFDataGetBytePtr(v35);
    v39 = printable_string_data(v37, v38);
    if (v35)
      CFRelease(v35);
    CFDictionarySetValue(v18, v36, v39);
    if (v36)
      CFRelease(v36);
    if (v39)
      CFRelease(v39);
    *(_WORD *)&bytes[8] = 521;
    v40 = CFDataCreate(allocator, bytes, 10);
    v16 = v49;
    if (!v40)
    {
      v44 = 0;
      v15 = v50;
      goto LABEL_48;
    }
    v41 = printable_string_data(2uLL, &PKCSReq);
    v15 = v50;
    if (!v41)
    {
      v44 = 0;
      goto LABEL_48;
    }
    v42 = v41;
    CFDictionarySetValue(v18, v40, v41);
    CFRelease(v40);
    CFRelease(v42);
    sender_nonce = generate_sender_nonce(v18);
    if (!(_DWORD)sender_nonce)
    {
      if (a5)
      {
        values = a5;
        CFRetain(a5);
        goto LABEL_46;
      }
      values = (void *)SecSCEPCreateTemporaryIdentity(sender_nonce, v46);
      if (values)
      {
        v44 = CFDictionaryCreate(0, (const void **)&kSecValueRef, (const void **)&values, 1, 0, 0);
        if (SecItemAdd(v44, 0))
        {
LABEL_69:
          if (!v44)
            goto LABEL_47;
          CFRelease(v44);
          goto LABEL_45;
        }
        if (v44)
          CFRelease(v44);
        if (values)
        {
LABEL_46:
          v44 = CFDataCreateMutable(allocator, 0);
          if (!SecCMSCreateSignedData((uint64_t)values, Mutable, theDict, v18, (uint64_t)v44))
            goto LABEL_47;
          goto LABEL_69;
        }
      }
    }
LABEL_45:
    v44 = 0;
LABEL_47:
    v40 = 0;
LABEL_48:
    if (v18)
      CFRelease(v18);
    if (v40)
      CFRelease(v40);
    goto LABEL_53;
  }
  v44 = 0;
LABEL_54:
  if (values)
    CFRelease(values);
  if (Mutable)
    CFRelease(Mutable);
  if (CertificateRequest)
    CFRelease(CertificateRequest);
  if (v16)
    CFRelease(v16);
  if (v15)
    CFRelease(v15);
  if (v11)
    CFRelease(v11);
  return v44;
}

const __CFArray *filterRecipients(const void *a1)
{
  const void *v1;
  CFTypeID TypeID;
  CFTypeID v3;
  const __CFArray *Mutable;
  _QWORD context[5];
  CFRange v7;

  v1 = a1;
  if (a1)
  {
    TypeID = SecCertificateGetTypeID();
    if (TypeID != CFGetTypeID(v1))
    {
      v3 = CFGetTypeID(v1);
      if (v3 != CFArrayGetTypeID())
        return 0;
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      context[0] = MEMORY[0x1E0C809B0];
      context[1] = 0x40000000;
      context[2] = __filterRecipients_block_invoke;
      context[3] = &__block_descriptor_tmp_11190;
      context[4] = Mutable;
      v7.length = CFArrayGetCount((CFArrayRef)v1);
      v7.location = 0;
      CFArrayApplyFunction((CFArrayRef)v1, v7, (CFArrayApplierFunction)apply_block_1_11191, context);
      if (CFArrayGetCount(Mutable))
        return Mutable;
      if (Mutable)
        CFRelease(Mutable);
    }
    CFRetain(v1);
  }
  return (const __CFArray *)v1;
}

__CFData *printable_string_data(unint64_t a1, const void *a2)
{
  CFIndex v4;
  __CFData *Mutable;
  UInt8 *BytePtr;
  UInt8 *v7;
  uint64_t v9;

  v9 = DERLengthOfLength(a1);
  v4 = a1 + v9 + 1;
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4);
  CFDataSetLength(Mutable, v4);
  BytePtr = (UInt8 *)CFDataGetBytePtr(Mutable);
  *BytePtr = 19;
  v7 = BytePtr + 1;
  DEREncodeLength(a1, (unint64_t)(BytePtr + 1), (unint64_t *)&v9);
  memcpy(&v7[v9], a2, a1);
  return Mutable;
}

uint64_t generate_sender_nonce(__CFDictionary *a1)
{
  const __CFAllocator *v2;
  CFDataRef v3;
  uint64_t v4;
  CFDataRef v5;
  CFDataRef v6;
  BOOL v7;
  __int128 v9;
  __int16 v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  WORD4(v9) = 1289;
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)&v9, 10);
  v9 = xmmword_18AA5F457;
  v10 = 0;
  v4 = CCRandomCopyBytes();
  v5 = CFDataCreate(v2, (const UInt8 *)&v9, 18);
  v6 = v5;
  if (v3)
    v7 = v5 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    CFDictionarySetValue(a1, v3, v5);
    goto LABEL_10;
  }
  if (v3)
  {
LABEL_10:
    CFRelease(v3);
    if (!v6)
      return v4;
    goto LABEL_8;
  }
  if (v5)
LABEL_8:
    CFRelease(v6);
  return v4;
}

void __filterRecipients_block_invoke(uint64_t a1, _DWORD *a2)
{
  CFTypeID TypeID;
  int v5;

  TypeID = SecCertificateGetTypeID();
  if (TypeID == CFGetTypeID(a2) && (!a2 || (v5 = a2[96]) == 0 || (v5 & 4) != 0))
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), a2);
}

uint64_t apply_block_1_11191(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFMutableDataRef SecSCEPCertifyRequest(const __CFData *a1, uint64_t a2, const __CFData *a3, char a4)
{
  return SecSCEPCertifyRequestWithAlgorithms(a1, a2, a3, a4, 0, 0);
}

CFMutableDataRef SecSCEPCertifyRequestWithAlgorithms(const __CFData *a1, uint64_t a2, const __CFData *a3, char a4, const void *a5, void *a6)
{
  void *v10;
  __SecKey *v11;
  _QWORD *v12;
  _QWORD *v13;
  int IsSignedBy;
  const __CFAllocator *v15;
  CFDataRef v16;
  void *v17;
  CFDataRef v18;
  __CFData *Mutable;
  CFMutableDataRef v20;
  CFTypeID TypeID;
  const __CFData *v22;
  const void *v23;
  _QWORD *v24;
  const __CFData *v25;
  const __CFDictionary *v26;
  CFDataRef v27;
  __CFData *v28;
  CFDataRef v29;
  __CFData *v30;
  __CFDictionary *v31;
  SecPolicyRef v32;
  CFTypeRef v34;
  SecPolicyRef BasicX509;
  CFDataRef v36;
  __SecKey *v37;
  int v39;
  CFTypeRef v40;
  CFTypeRef v41;
  CFTypeRef cf;
  CFTypeRef v43;
  CFTypeRef v44;
  CFTypeRef v45;
  CFTypeRef v46;
  CFTypeRef v47;
  void *values;
  void *v49[3];
  void *keys[3];
  UInt8 bytes[8];
  __int16 v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v47 = 0;
  values = a6;
  v45 = 0;
  v46 = 0;
  v43 = 0;
  v44 = 0;
  v41 = 0;
  cf = 0;
  v40 = 0;
  v10 = *(void **)(a2 + 16);
  CFRetain(v10);
  v34 = v10;
  v11 = SecCertificateCopyKey((SecCertificateRef)v10);
  BasicX509 = SecPolicyCreateBasicX509();
  v37 = v11;
  if (SecCMSVerifySignedData_internal(a1, 0, BasicX509, (SecTrustRef *)&v47, 0, (uint64_t *)&v46, (const __CFDictionary **)&v45)|| (v39 = -1431655766, SecTrustEvaluateInternal((__SecTrust *)v47, &v39)))
  {
    v20 = 0;
    v25 = 0;
    v24 = 0;
    Mutable = 0;
    v31 = 0;
    v36 = 0;
    v16 = 0;
    v13 = 0;
LABEL_89:
    v22 = 0;
    v17 = 0;
    goto LABEL_44;
  }
  v12 = copySignerCert((__SecTrust *)v47);
  v13 = v12;
  if (!v12
    || (IsSignedBy = SecCertificateIsSignedBy(v12, v11),
        !scep_attr_has_val((const __CFDictionary *)v45, "19")))
  {
    v20 = 0;
    v25 = 0;
    v24 = 0;
    Mutable = 0;
    v31 = 0;
    v36 = 0;
    v16 = 0;
    goto LABEL_89;
  }
  v52 = 1801;
  v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v16 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 10);
  if (!v16)
    goto LABEL_90;
  v17 = (void *)dictionary_array_value_1((const __CFDictionary *)v45, v16);
  if (!v17)
  {
    v20 = 0;
    v25 = 0;
    v24 = 0;
    Mutable = 0;
    v31 = 0;
    v36 = 0;
    v22 = 0;
    goto LABEL_44;
  }
  v52 = 1289;
  v18 = CFDataCreate(v15, bytes, 10);
  if (!v18)
  {
LABEL_90:
    v20 = 0;
    v25 = 0;
    v24 = 0;
    Mutable = 0;
    v31 = 0;
    v36 = 0;
LABEL_96:
    v22 = 0;
LABEL_104:
    v17 = 0;
    goto LABEL_44;
  }
  v36 = v18;
  if (!dictionary_array_value_1((const __CFDictionary *)v45, v18))
    goto LABEL_86;
  Mutable = CFDataCreateMutable(v15, 0);
  v20 = 0;
  if (SecCMSDecryptEnvelopedData((const __CFData *)v46, Mutable, &v40) || !v40)
  {
    v25 = 0;
    v24 = 0;
    v31 = 0;
    v22 = 0;
    v17 = 0;
    goto LABEL_44;
  }
  if (!SecVerifyCertificateRequest(Mutable, (__SecKey **)&v41, (CFStringRef *)&cf, (CFDataRef *)&v44, (CFDataRef *)&v43))
  {
    v20 = 0;
    v25 = 0;
    v24 = 0;
    goto LABEL_95;
  }
  if (Mutable)
    CFRelease(Mutable);
  if (IsSignedBy)
  {
    if (!cf || (TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(cf)) || !CFEqual(CFSTR("magic"), cf))
    {
LABEL_86:
      v20 = 0;
      v25 = 0;
      v24 = 0;
      Mutable = 0;
LABEL_95:
      v31 = 0;
      goto LABEL_96;
    }
  }
  v22 = CFDataCreateMutable(v15, 0);
  if (!v22)
    goto LABEL_92;
  if ((a4 & 1) != 0)
  {
    v23 = &PKIStatusPENDING;
    goto LABEL_32;
  }
  if (SecKeyGetAlgorithmId((uint64_t)v41) != 1)
  {
LABEL_92:
    v20 = 0;
    v25 = 0;
LABEL_102:
    v24 = 0;
    goto LABEL_103;
  }
  v24 = SecIdentitySignCertificateWithAlgorithm(a2, a3, (__SecKey *)v41, v44, v43, a5);
  v25 = SecCMSCreateCertificatesOnlyMessage(v24);
  if (!v25)
  {
    v20 = 0;
LABEL_103:
    Mutable = 0;
    v31 = 0;
    goto LABEL_104;
  }
  if (v24)
    CFRelease(v24);
  if (values)
    v26 = CFDictionaryCreate(0, (const void **)&kSecCMSBulkEncryptionAlgorithm, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  else
    v26 = 0;
  if (SecCMSCreateEnvelopedData(v13, v26, v25, (uint64_t)v22))
  {
    v20 = 0;
    goto LABEL_102;
  }
  CFRelease(v25);
  if (v26)
    CFRelease(v26);
  v23 = &PKIStatusSUCCESS;
LABEL_32:
  v52 = 777;
  v27 = CFDataCreate(v15, bytes, 10);
  v28 = printable_string_data(1uLL, v23);
  v52 = 521;
  v29 = CFDataCreate(v15, bytes, 10);
  v30 = printable_string_data(1uLL, &CertRep);
  keys[0] = v16;
  keys[1] = v27;
  keys[2] = v29;
  v49[0] = v17;
  v49[1] = v28;
  v49[2] = v30;
  v17 = CFDictionaryCreate(v15, (const void **)keys, (const void **)v49, 3, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v27)
    CFRelease(v27);
  if (v28)
    CFRelease(v28);
  if (v29)
    CFRelease(v29);
  if (v30)
    CFRelease(v30);
  v20 = CFDataCreateMutable(v15, 0);
  v31 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionaryAddValue(v31, (const void *)kSecCMSCertChainMode, (const void *)kSecCMSCertChainModeNone);
  if (a5)
    CFDictionaryAddValue(v31, (const void *)kSecCMSSignHashAlgorithm, a5);
  if (!SecCMSCreateSignedData(a2, v22, v31, (const __CFDictionary *)v17, (uint64_t)v20))
  {
    v25 = 0;
    v24 = 0;
    Mutable = 0;
LABEL_44:
    v32 = BasicX509;
    goto LABEL_45;
  }
  v32 = BasicX509;
  if (v20)
  {
    CFRelease(v20);
    v20 = 0;
  }
  v25 = 0;
  v24 = 0;
  Mutable = 0;
LABEL_45:
  if (v34)
    CFRelease(v34);
  if (v37)
    CFRelease(v37);
  if (v24)
    CFRelease(v24);
  if (v25)
    CFRelease(v25);
  if (v22)
    CFRelease(v22);
  if (v47)
    CFRelease(v47);
  if (v32)
    CFRelease(v32);
  if (v46)
    CFRelease(v46);
  if (v45)
    CFRelease(v45);
  if (v16)
    CFRelease(v16);
  if (v36)
    CFRelease(v36);
  if (v44)
    CFRelease(v44);
  if (v43)
    CFRelease(v43);
  if (cf)
    CFRelease(cf);
  if (v41)
    CFRelease(v41);
  if (Mutable)
    CFRelease(Mutable);
  if (v17)
    CFRelease(v17);
  if (v40)
    CFRelease(v40);
  if (v31)
    CFRelease(v31);
  if (v13)
    CFRelease(v13);
  return v20;
}

const void *copySignerCert(__SecTrust *a1)
{
  const __CFArray *v1;
  const __CFArray *v2;
  const void *ValueAtIndex;
  const void *v4;

  v1 = SecTrustCopyCertificateChain(a1);
  if (!v1)
    return 0;
  v2 = v1;
  ValueAtIndex = CFArrayGetValueAtIndex(v1, 0);
  v4 = ValueAtIndex;
  if (ValueAtIndex)
    CFRetain(ValueAtIndex);
  CFRelease(v2);
  return v4;
}

unint64_t scep_attr_has_val(const __CFDictionary *a1, char *__s)
{
  size_t v4;
  const __CFAllocator *v5;
  CFArrayRef v6;
  CFDataRef v7;
  unint64_t Value;
  CFTypeRef cf;
  UInt8 bytes[8];
  __int16 v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v4 = strlen(__s);
  cf = printable_string_data(v4, __s);
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &cf, 1, MEMORY[0x1E0C9B378]);
  CFRelease(cf);
  v12 = 521;
  v7 = CFDataCreate(v5, bytes, 10);
  Value = (unint64_t)CFDictionaryGetValue(a1, v7);
  CFRelease(v7);
  if (Value)
    Value = CFEqual(v6, (CFTypeRef)Value) != 0;
  CFRelease(v6);
  return Value;
}

const void *dictionary_array_value_1(const __CFDictionary *a1, const void *a2)
{
  const __CFArray *Value;
  const __CFArray *v3;

  Value = (const __CFArray *)CFDictionaryGetValue(a1, a2);
  if (Value && (v3 = Value, CFArrayGetCount(Value) == 1))
    return CFArrayGetValueAtIndex(v3, 0);
  else
    return 0;
}

BOOL SecSCEPVerifyGetCertInitial(const __CFData *a1, uint64_t a2)
{
  void *v3;
  SecKeyRef v4;
  SecPolicyRef BasicX509;
  const __CFAllocator *v6;
  CFDataRef v7;
  CFDataRef v8;
  const __CFData *Mutable;
  _BOOL8 v10;
  CFTypeRef v12;
  CFTypeRef v13;
  CFTypeRef v14;
  CFTypeRef cf;
  UInt8 bytes[8];
  __int16 v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  cf = 0;
  v12 = 0;
  v13 = 0;
  v3 = *(void **)(a2 + 16);
  CFRetain(v3);
  v4 = SecCertificateCopyKey((SecCertificateRef)v3);
  BasicX509 = SecPolicyCreateBasicX509();
  if (SecCMSVerifySignedData_internal(a1, 0, BasicX509, (SecTrustRef *)&cf, 0, (uint64_t *)&v14, (const __CFDictionary **)&v13)|| !scep_attr_has_val((const __CFDictionary *)v13, "20"))
  {
    v10 = 0;
    Mutable = 0;
    v8 = 0;
    v7 = 0;
  }
  else
  {
    v17 = 1801;
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v7 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 10);
    if (v7 && dictionary_array_value_1((const __CFDictionary *)v13, v7))
    {
      v17 = 1289;
      v8 = CFDataCreate(v6, bytes, 10);
      if (v8 && dictionary_array_value_1((const __CFDictionary *)v13, v8))
      {
        Mutable = CFDataCreateMutable(v6, 0);
        v10 = 0;
        if (!SecCMSDecryptEnvelopedData((const __CFData *)v14, Mutable, &v12) && v12)
          v10 = CFDataGetLength(Mutable) > 0;
      }
      else
      {
        v10 = 0;
        Mutable = 0;
      }
    }
    else
    {
      v10 = 0;
      Mutable = 0;
      v8 = 0;
    }
  }
  if (v3)
    CFRelease(v3);
  if (v4)
    CFRelease(v4);
  if (cf)
    CFRelease(cf);
  if (BasicX509)
    CFRelease(BasicX509);
  if (v14)
    CFRelease(v14);
  if (v13)
    CFRelease(v13);
  if (v7)
    CFRelease(v7);
  if (v8)
    CFRelease(v8);
  if (Mutable)
    CFRelease(Mutable);
  if (v12)
    CFRelease(v12);
  return v10;
}

const __CFArray *SecSCEPVerifyReply(int a1, const __CFData *a2, CFTypeRef cf, CFErrorRef *a4)
{
  void *ValueAtIndex;
  CFTypeID v7;
  CFTypeID v8;
  CFIndex Count;
  const __CFArray *v10;
  CFIndex v11;
  const __CFAllocator *v12;
  const __CFArray *v13;
  const __CFDictionary *v14;
  const __CFArray *v15;
  const __CFArray *v16;
  const __CFArray *v17;
  __CFData *Mutable;
  const void *v19;
  CFDataRef v20;
  const __CFDictionary *v21;
  const __CFDictionary *v22;
  const void *v24;
  int v25;
  void *values;
  CFTypeRef v27;
  CFDictionaryRef theDict;
  CFTypeRef v29;
  CFTypeRef cfa;
  UInt8 bytes[8];
  __int16 v32;
  uint64_t v33;

  ValueAtIndex = (void *)cf;
  v33 = *MEMORY[0x1E0C80C00];
  v29 = 0;
  cfa = 0;
  v27 = 0;
  theDict = 0;
  values = 0;
  v7 = CFGetTypeID(cf);
  if (v7 == SecCertificateGetTypeID())
  {
    values = ValueAtIndex;
    if (!ValueAtIndex)
      goto LABEL_61;
    goto LABEL_10;
  }
  v8 = CFGetTypeID(ValueAtIndex);
  if (v8 != CFArrayGetTypeID())
    goto LABEL_15;
  Count = CFArrayGetCount((CFArrayRef)ValueAtIndex);
  if (Count >= 2)
  {
    v10 = (const __CFArray *)ValueAtIndex;
    v11 = 1;
    goto LABEL_9;
  }
  if (Count != 1)
  {
LABEL_15:
    v15 = 0;
    v16 = 0;
    v17 = 0;
    Mutable = 0;
    v19 = 0;
    ValueAtIndex = 0;
    goto LABEL_42;
  }
  v10 = (const __CFArray *)ValueAtIndex;
  v11 = 0;
LABEL_9:
  ValueAtIndex = (void *)CFArrayGetValueAtIndex(v10, v11);
  values = ValueAtIndex;
  if (!ValueAtIndex)
  {
LABEL_61:
    v15 = 0;
    v16 = 0;
    v17 = 0;
    Mutable = 0;
    v19 = 0;
    goto LABEL_42;
  }
LABEL_10:
  ValueAtIndex = SecPolicyCreateBasicX509();
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v13 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, MEMORY[0x1E0C9B378]);
  if (SecCMSVerifySignedData(a2, 0, ValueAtIndex, (SecTrustRef *)&cfa, v13, (uint64_t *)&v29, &theDict))
    goto LABEL_61;
  if (v13)
    CFRelease(v13);
  v14 = theDict ? (const __CFDictionary *)CFDictionaryGetValue(theDict, (const void *)kSecCMSSignedAttributes) : 0;
  v25 = -1431655766;
  if (SecTrustEvaluateInternal((__SecTrust *)cfa, &v25))
    goto LABEL_61;
  v19 = copySignerCert((__SecTrust *)cfa);
  if (!v19)
  {
    v15 = 0;
    v16 = 0;
    goto LABEL_26;
  }
  v15 = 0;
  if (!CFEqual(values, v19) || !v14)
  {
    v16 = 0;
    v17 = 0;
    Mutable = 0;
    goto LABEL_42;
  }
  v16 = copy_signed_attr_printable_string_value(v14, 2u);
  v15 = copy_signed_attr_printable_string_value(v14, 3u);
  if ((unint64_t)v16 | (unint64_t)v15)
  {
    if (!v16 || !CFEqual(v16, CFSTR("3")) || !v15 || CFEqual(v15, CFSTR("2")))
      goto LABEL_26;
    if (CFEqual(v15, CFSTR("3")))
    {
      v32 = 1801;
      v20 = CFDataCreate(v12, bytes, 10);
      *(_QWORD *)bytes = v20;
      if (v20)
      {
        v24 = dictionary_array_value_1(v14, v20);
        if (v24)
        {
          v21 = CFDictionaryCreate(v12, (const void **)bytes, &v24, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          if (a4)
            *a4 = CFErrorCreate(v12, CFSTR("PENDING"), 3, v21);
          if (v21)
            CFRelease(v21);
        }
        if (*(_QWORD *)bytes)
          CFRelease(*(CFTypeRef *)bytes);
      }
      goto LABEL_26;
    }
    if (!CFEqual(v15, CFSTR("0")))
    {
LABEL_26:
      v17 = 0;
      Mutable = 0;
      goto LABEL_42;
    }
  }
  Mutable = CFDataCreateMutable(v12, 0);
  v17 = 0;
  if (!SecCMSDecryptEnvelopedData((const __CFData *)v29, Mutable, &v27))
  {
    if (v27)
    {
      v17 = SecCMSCertificatesOnlyMessageCopyCertificates((uint64_t)Mutable);
      if (v17)
      {
        v22 = CFDictionaryCreate(0, (const void **)&kSecValueRef, &v27, 1, 0, 0);
        SecItemDelete(v22);
        if (v22)
          CFRelease(v22);
      }
    }
  }
LABEL_42:
  if (cfa)
    CFRelease(cfa);
  if (ValueAtIndex)
    CFRelease(ValueAtIndex);
  if (v29)
    CFRelease(v29);
  if (Mutable)
    CFRelease(Mutable);
  if (v27)
    CFRelease(v27);
  if (v16)
    CFRelease(v16);
  if (v15)
    CFRelease(v15);
  if (theDict)
    CFRelease(theDict);
  if (v19)
    CFRelease(v19);
  return v17;
}

const __CFArray *copy_signed_attr_printable_string_value(const __CFDictionary *a1, UInt8 a2)
{
  const __CFAllocator *v3;
  CFDataRef v4;
  CFDataRef v5;
  const __CFArray *Value;
  const __CFArray *v7;
  CFTypeID v8;
  const __CFData *ValueAtIndex;
  const UInt8 *BytePtr;
  unint64_t Length;
  UInt8 bytes[16];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  bytes[9] = a2;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, 10);
  if (!v4)
    return 0;
  v5 = v4;
  Value = (const __CFArray *)CFDictionaryGetValue(a1, v4);
  v7 = Value;
  if (Value)
  {
    v8 = CFGetTypeID(Value);
    if (v8 == CFArrayGetTypeID()
      && CFArrayGetCount(v7) == 1
      && (ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v7, 0),
          BytePtr = CFDataGetBytePtr(ValueAtIndex),
          Length = CFDataGetLength(ValueAtIndex),
          Length >= 2)
      && *BytePtr == 19)
    {
      v7 = 0;
      if (((char)BytePtr[1] & 0x80000000) == 0 && Length - 2 == BytePtr[1])
        v7 = (const __CFArray *)CFStringCreateWithBytes(v3, BytePtr + 2, BytePtr[1], 0x600u, 0);
    }
    else
    {
      v7 = 0;
    }
  }
  CFRelease(v5);
  return v7;
}

uint64_t SecSCEPValidateCACertMessage(CFArrayRef theArray, CFDataRef theData, __CFData **a3, _QWORD *a4, _QWORD *a5)
{
  CFIndex v7;
  uint64_t v8;
  __int128 v9;
  __CFData *ValueAtIndex;
  NSObject *v11;
  const void *v12;
  uint64_t v13;
  CFIndex v15;
  NSObject *v16;
  __CFData *SHA1Digest;
  __CFData *v18;
  NSObject *v19;
  const void *v20;
  uint64_t v21;
  NSObject *v23;
  __CFData *v24;
  NSObject *v25;
  const void *v26;
  uint64_t v27;
  __int128 v29;
  NSObject *v30;
  const void *v31;
  uint64_t v32;
  __int128 v34;
  uint64_t v35;
  NSObject *v36;
  CFIndex Count;
  const CFArrayCallBacks *v38;
  CFMutableArrayRef Mutable;
  CFIndex v40;
  CFMutableArrayRef v41;
  CFIndex v42;
  CFMutableArrayRef v43;
  const __CFArray *v44;
  BOOL v45;
  NSObject *v47;
  const __CFArray *v48;
  CFIndex v49;
  const void *v50;
  const void *v51;
  int v52;
  __CFArray *v53;
  __CFArray *ra_chain;
  __CFArray *v55;
  const void *v56;
  const __CFArray *v57;
  const void *v58;
  const void *v59;
  const void *v60;
  void *v61;
  NSObject *v62;
  CFIndex v63;
  CFIndex v64;
  void *v65;
  NSObject *v66;
  NSObject *v67;
  __CFArray *v68;
  const __CFArray *v69;
  CFIndex v70;
  __CFData *v71;
  const void *v72;
  const void *v73;
  CFArrayRef theArraya;
  const __CFArray *theArrayb;
  _BYTE md[32];
  __int128 v81;
  __int128 v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  if (!theData)
  {
    ValueAtIndex = 0;
    goto LABEL_54;
  }
  v7 = 0;
  theArraya = (CFArrayRef)CFDataGetLength(theData);
  *((_QWORD *)&v9 + 1) = theArraya;
  *(_QWORD *)&v9 = (char *)theArraya - 16;
  v8 = v9 >> 2;
  while (2)
  {
    if (v7 >= CFArrayGetCount(theArray))
    {
      v35 = 4294899453;
LABEL_49:
      v36 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)md = 138412290;
        *(_QWORD *)&md[4] = theData;
        _os_log_impl(&dword_18A900000, v36, OS_LOG_TYPE_DEFAULT, "SCEP failed to find certificate matching CA fingerprint: %@", md, 0xCu);
      }
      return v35;
    }
    ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(theArray, v7);
    switch(v8)
    {
      case 0:
        v11 = secLogObjForScope("scep");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)md = 0;
          _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "MD5 fingerprint digest", md, 2u);
        }
        memset(md, 170, 16);
        v12 = (const void *)*((_QWORD *)ValueAtIndex + 2);
        v13 = *((_QWORD *)ValueAtIndex + 3);
        if ((unint64_t)(v13 - 0xFFFFFFFFLL) < 0xFFFFFFFF00000002 || v12 == 0)
          goto LABEL_46;
        CC_MD5(v12, v13, md);
        v15 = 16;
        goto LABEL_40;
      case 1:
        v16 = secLogObjForScope("scep");
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)md = 0;
          _os_log_debug_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEBUG, "SHA1 fingerprint digest", md, 2u);
        }
        SHA1Digest = SecCertificateGetSHA1Digest(ValueAtIndex);
        if (!SHA1Digest)
          goto LABEL_45;
        v18 = SHA1Digest;
        CFRetain(SHA1Digest);
        goto LABEL_43;
      case 3:
        v19 = secLogObjForScope("scep");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)md = 0;
          _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "SHA224 fingerprint digest", md, 2u);
        }
        memset(md, 170, 28);
        v20 = (const void *)*((_QWORD *)ValueAtIndex + 2);
        v21 = *((_QWORD *)ValueAtIndex + 3);
        if ((unint64_t)(v21 - 0xFFFFFFFFLL) < 0xFFFFFFFF00000002 || v20 == 0)
          goto LABEL_46;
        CC_SHA224(v20, v21, md);
        v15 = 28;
        goto LABEL_40;
      case 4:
        v23 = secLogObjForScope("scep");
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)md = 0;
          _os_log_debug_impl(&dword_18A900000, v23, OS_LOG_TYPE_DEBUG, "SHA256 fingerprint digest", md, 2u);
        }
        v24 = SecCertificateCopySHA256Digest(ValueAtIndex);
        goto LABEL_41;
      case 8:
        v25 = secLogObjForScope("scep");
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)md = 0;
          _os_log_debug_impl(&dword_18A900000, v25, OS_LOG_TYPE_DEBUG, "SHA384 fingerprint digest", md, 2u);
        }
        v26 = (const void *)*((_QWORD *)ValueAtIndex + 2);
        v27 = *((_QWORD *)ValueAtIndex + 3);
        if ((unint64_t)(v27 - 0xFFFFFFFFLL) < 0xFFFFFFFF00000002 || v26 == 0)
          goto LABEL_46;
        *(_QWORD *)&v29 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&md[16] = v29;
        v81 = v29;
        *(_OWORD *)md = v29;
        CC_SHA384(v26, v27, md);
        v15 = 48;
        goto LABEL_40;
      case 12:
        v30 = secLogObjForScope("scep");
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)md = 0;
          _os_log_debug_impl(&dword_18A900000, v30, OS_LOG_TYPE_DEBUG, "SHA512 fingerprint digest", md, 2u);
        }
        v31 = (const void *)*((_QWORD *)ValueAtIndex + 2);
        v32 = *((_QWORD *)ValueAtIndex + 3);
        if ((unint64_t)(v32 - 0xFFFFFFFFLL) < 0xFFFFFFFF00000002 || v31 == 0)
        {
LABEL_46:
          v18 = 0;
        }
        else
        {
          *(_QWORD *)&v34 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v81 = v34;
          v82 = v34;
          *(_OWORD *)md = v34;
          *(_OWORD *)&md[16] = v34;
          CC_SHA512(v31, v32, md);
          v15 = 64;
LABEL_40:
          v24 = CFDataCreate(0, md, v15);
LABEL_41:
          v18 = v24;
        }
        if (!v18)
          goto LABEL_45;
LABEL_43:
        if (!CFEqual(v18, theData))
        {
          CFRelease(v18);
LABEL_45:
          ++v7;
          continue;
        }
        if (ValueAtIndex)
          CFRetain(ValueAtIndex);
        CFRelease(v18);
LABEL_54:
        Count = CFArrayGetCount(theArray);
        v38 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
        Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E0C9B378]);
        v40 = CFArrayGetCount(theArray);
        v41 = CFArrayCreateMutable(0, v40, v38);
        v42 = CFArrayGetCount(theArray);
        v43 = CFArrayCreateMutable(0, v42, v38);
        v44 = v43;
        if (Mutable)
          v45 = v41 == 0;
        else
          v45 = 1;
        if (v45 || v43 == 0)
        {
          v35 = 4294899624;
          goto LABEL_63;
        }
        v49 = 0;
        while (2)
        {
          if (v49 < CFArrayGetCount(theArray))
          {
            v50 = CFArrayGetValueAtIndex(theArray, v49);
            if (v50)
            {
              v51 = v50;
              v52 = *((_DWORD *)v50 + 96) & 5;
              if (v52 == 1)
              {
                v53 = v41;
              }
              else
              {
                v53 = Mutable;
                if (v52 != 5)
                {
                  v53 = v44;
                  if (v52 != 4)
                    goto LABEL_81;
                }
              }
              CFArrayAppendValue(v53, v51);
            }
LABEL_81:
            ++v49;
            continue;
          }
          break;
        }
        if (!CFArrayGetCount(Mutable))
        {
          v35 = 4294899565;
          if (!CFArrayGetCount(v41) || !CFArrayGetCount(v44))
          {
LABEL_63:
            v47 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)md = 0;
              _os_log_impl(&dword_18A900000, v47, OS_LOG_TYPE_DEFAULT, "SCEP failed to find candidate RA certificates", md, 2u);
            }
            if (ValueAtIndex)
              CFRelease(ValueAtIndex);
            if (Mutable)
              CFRelease(Mutable);
            if (v41)
              CFRelease(v41);
            if (v44)
            {
              v48 = v44;
              goto LABEL_150;
            }
            return v35;
          }
        }
        ra_chain = scep_find_ra_chain(v41, theArray, ValueAtIndex);
        v55 = scep_find_ra_chain(v44, theArray, ValueAtIndex);
        v56 = 0;
        v35 = 4294941020;
        theArrayb = v55;
        if (!ra_chain)
        {
          v58 = 0;
          goto LABEL_105;
        }
        v57 = v55;
        v58 = 0;
        if (!v55)
          goto LABEL_105;
        v59 = CFArrayGetValueAtIndex(ra_chain, 0);
        v58 = v59;
        if (v59)
          CFRetain(v59);
        v60 = CFArrayGetValueAtIndex(v57, 0);
        v56 = v60;
        if (v60)
          CFRetain(v60);
        if (ValueAtIndex)
        {
          v61 = ValueAtIndex;
          goto LABEL_127;
        }
        v63 = CFArrayGetCount(ra_chain);
        v61 = (void *)CFArrayGetValueAtIndex(ra_chain, v63 - 1);
        v64 = CFArrayGetCount(theArrayb);
        v65 = (void *)CFArrayGetValueAtIndex(theArrayb, v64 - 1);
        if (!v61 || !v65)
        {
          if (v61 != v65)
            goto LABEL_102;
          if (!v61)
          {
            if (!a3)
              goto LABEL_130;
            goto LABEL_129;
          }
LABEL_126:
          CFRetain(v61);
LABEL_127:
          if (!a3)
            goto LABEL_130;
          CFRetain(v61);
LABEL_129:
          *a3 = (__CFData *)v61;
LABEL_130:
          if (a4)
          {
            if (v58)
              CFRetain(v58);
            *a4 = v58;
          }
          if (a5)
          {
            if (v56)
              CFRetain(v56);
            v35 = 0;
            v73 = 0;
            *a5 = v56;
          }
          else
          {
            v35 = 0;
            v73 = 0;
          }
LABEL_139:
          CFRelease(ra_chain);
          ValueAtIndex = (__CFData *)v61;
          goto LABEL_140;
        }
        if (CFEqual(v61, v65))
          goto LABEL_126;
LABEL_102:
        v66 = secLogObjForScope("scep");
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)md = 0;
          _os_log_impl(&dword_18A900000, v66, OS_LOG_TYPE_DEFAULT, "signing/encryption CAs do not match", md, 2u);
        }
        v35 = 4294899453;
LABEL_105:
        v67 = secLogObjForScope("scep");
        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)md = 0;
          _os_log_debug_impl(&dword_18A900000, v67, OS_LOG_TYPE_DEBUG, "SCEP did not find different RA certificates for signing/encryption; looking for one cert",
            md,
            2u);
        }
        v68 = scep_find_ra_chain(Mutable, theArray, ValueAtIndex);
        if (v68)
        {
          v69 = v68;
          if (!ValueAtIndex)
          {
            v70 = CFArrayGetCount(v68);
            v71 = (__CFData *)CFArrayGetValueAtIndex(v69, v70 - 1);
            ValueAtIndex = v71;
            if (v71)
              CFRetain(v71);
          }
          v72 = CFArrayGetValueAtIndex(v69, 0);
          v73 = v72;
          if (v72)
            CFRetain(v72);
          CFRelease(v69);
          if (a3)
          {
            if (ValueAtIndex)
              CFRetain(ValueAtIndex);
            *a3 = ValueAtIndex;
          }
          if (a4)
          {
            if (v73)
              CFRetain(v73);
            v35 = 0;
            *a4 = v73;
          }
          else
          {
            v35 = 0;
          }
        }
        else
        {
          v73 = 0;
        }
        v61 = ValueAtIndex;
        if (ra_chain)
          goto LABEL_139;
LABEL_140:
        if (theArrayb)
          CFRelease(theArrayb);
        CFRelease(Mutable);
        CFRelease(v41);
        CFRelease(v44);
        if (ValueAtIndex)
          CFRelease(ValueAtIndex);
        if (v73)
          CFRelease(v73);
        if (v58)
          CFRelease(v58);
        if (v56)
        {
          v48 = (const __CFArray *)v56;
LABEL_150:
          CFRelease(v48);
        }
        return v35;
      default:
        v62 = secLogObjForScope("SecError");
        v35 = 4294899481;
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)md = 134217984;
          *(_QWORD *)&md[4] = theArraya;
          _os_log_impl(&dword_18A900000, v62, OS_LOG_TYPE_DEFAULT, "SCEP failed to find algorithm to match CA fingerprint length: %ld", md, 0xCu);
        }
        goto LABEL_49;
    }
  }
}

__CFArray *scep_find_ra_chain(CFArrayRef theArray, const __CFArray *a2, void *a3)
{
  CFIndex v5;
  const CFArrayCallBacks *v6;
  CFIndex Count;
  __CFArray *Mutable;
  const void *ValueAtIndex;
  NSObject *v10;
  const __CFArray *v11;
  const __CFArray *v12;
  void *v13;
  CFIndex v14;
  const void *v15;
  NSObject *v16;
  NSObject *v17;
  SecTrustRef trust;
  void *values;
  uint8_t buf[4];
  const void *v22;
  __int16 v23;
  void *v24;
  uint64_t v25;
  CFRange v26;

  v5 = 0;
  v25 = *MEMORY[0x1E0C80C00];
  v6 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  values = a3;
  while (v5 < CFArrayGetCount(theArray))
  {
    Count = CFArrayGetCount(a2);
    Mutable = CFArrayCreateMutable(0, Count + 1, v6);
    ValueAtIndex = CFArrayGetValueAtIndex(theArray, v5);
    CFArrayAppendValue(Mutable, ValueAtIndex);
    v26.length = CFArrayGetCount(a2);
    v26.location = 0;
    CFArrayAppendArray(Mutable, a2, v26);
    trust = 0;
    if (SecTrustCreateWithCertificates(Mutable, 0, &trust))
    {
      v10 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v22 = ValueAtIndex;
        _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, "SCEP failed to create trust for %@", buf, 0xCu);
      }
      if (Mutable)
        goto LABEL_19;
    }
    else
    {
      if (Mutable)
        CFRelease(Mutable);
      if (values)
      {
        v11 = CFArrayCreate(0, (const void **)&values, 1, v6);
        SecTrustSetAnchorCertificates(trust, v11);
        if (v11)
          CFRelease(v11);
      }
      v12 = SecTrustCopyCertificateChain(trust);
      if (v12)
      {
        Mutable = v12;
        v13 = values;
        if (!values)
          return Mutable;
        v14 = CFArrayGetCount(v12);
        v15 = CFArrayGetValueAtIndex(Mutable, v14 - 1);
        if (v15)
        {
          if (CFEqual(v13, v15))
            return Mutable;
        }
        v16 = secLogObjForScope("scep");
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          v22 = ValueAtIndex;
          v23 = 2112;
          v24 = values;
          _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEFAULT, "failed to create chain from %@ to ca cert %@", buf, 0x16u);
        }
LABEL_19:
        CFRelease(Mutable);
        goto LABEL_20;
      }
      v17 = secLogObjForScope("scep");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v22 = ValueAtIndex;
        _os_log_impl(&dword_18A900000, v17, OS_LOG_TYPE_DEFAULT, "failed to create chain %@", buf, 0xCu);
      }
    }
LABEL_20:
    ++v5;
  }
  return 0;
}

CFMutableDataRef SecSCEPGetCertInitial(uint64_t a1, const __CFArray *a2, const __CFDictionary *a3, const __CFDictionary *a4, uint64_t a5, const void *a6)
{
  __CFData *CertificateRequestSubject;
  __CFData *v11;
  const __CFAllocator *v12;
  CFMutableDataRef Mutable;
  const __CFData *v14;
  const __CFArray *v15;
  __CFDictionary *MutableCopy;
  CFDataRef v17;
  __CFData *v18;
  __CFData *v19;
  CFMutableDataRef v20;
  UInt8 bytes[8];
  __int16 v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a4)
    return 0;
  CertificateRequestSubject = SecGenerateCertificateRequestSubject(a1, a2);
  if (!CertificateRequestSubject)
    return 0;
  v11 = CertificateRequestSubject;
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  if (!Mutable)
  {
    CFRelease(v11);
    return 0;
  }
  v14 = Mutable;
  v15 = filterRecipients(a6);
  if (SecCMSCreateEnvelopedData(v15, a3, v11, (uint64_t)v14))
  {
    v20 = 0;
    v17 = 0;
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutableCopy(v12, 3, a4);
    v23 = 521;
    v17 = CFDataCreate(v12, bytes, 10);
    if (v17 && (v18 = printable_string_data(2uLL, "20")) != 0)
    {
      v19 = v18;
      CFDictionarySetValue(MutableCopy, v17, v18);
      CFRelease(v17);
      CFRelease(v19);
      generate_sender_nonce(MutableCopy);
      v20 = CFDataCreateMutable(v12, 0);
      if (SecCMSCreateSignedData(a5, v14, a3, MutableCopy, (uint64_t)v20) && v20)
      {
        CFRelease(v20);
        v20 = 0;
      }
      v17 = 0;
      if (!MutableCopy)
        goto LABEL_10;
    }
    else
    {
      v20 = 0;
      if (!MutableCopy)
        goto LABEL_10;
    }
    CFRelease(MutableCopy);
  }
LABEL_10:
  CFRelease(v11);
  CFRelease(v14);
  if (v17)
    CFRelease(v17);
  if (v15)
    CFRelease(v15);
  return v20;
}

uint64_t SecCopyEncryptedToServerKey(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v3;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __SecCopyEncryptedToServerKey_block_invoke;
  v5[3] = &unk_1E1FD9C88;
  v5[5] = a2;
  v5[6] = a3;
  v5[4] = &v6;
  if (*(_UNKNOWN **)(a1 + 16) == &kSecECPublicKeyDescriptor)
    __SecCopyEncryptedToServerKey_block_invoke((uint64_t)v5);
  else
    SecError(-50, a3, CFSTR("Not an EC Public Key object, sorry can't do."));
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t InitServerECIES()
{
  ccsha256_di();
  ccrng();
  return ccecies_encrypt_gcm_setup();
}

uint64_t SecCopyDecryptedForServer(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v3;
  _QWORD v5[7];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __SecCopyDecryptedForServer_block_invoke;
  v5[3] = &unk_1E1FD9CB0;
  v5[5] = a2;
  v5[6] = a3;
  v5[4] = &v6;
  if (*(_UNKNOWN **)(a1 + 16) == &kSecECPrivateKeyDescriptor)
    __SecCopyDecryptedForServer_block_invoke((uint64_t)v5);
  else
    SecError(-50, a3, CFSTR("Not an EC Full Key object, sorry can't do."));
  v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

uint64_t SecCopyEncryptedToServer(__SecTrust *a1, uint64_t a2, __CFString **a3)
{
  SecKeyRef v5;
  SecKeyRef v6;
  uint64_t v7;

  v5 = SecTrustCopyKey(a1);
  if (v5)
  {
    v6 = v5;
    v7 = SecCopyEncryptedToServerKey((uint64_t)v5, a2, a3);
    CFRelease(v6);
    return v7;
  }
  else
  {
    SecError(-25308, a3, CFSTR("Failed to get key out of trust ref, was it evaluated?"));
    return 0;
  }
}

void SecAddSharedWebCredential(CFStringRef fqdn, CFStringRef account, CFStringRef password, void *completionHandler)
{
  CFTypeID v8;
  CFIndex Length;
  const __CFString *v10;
  CFTypeID v11;
  CFTypeID v12;
  NSObject *v13;
  NSObject *v14;
  _QWORD block[10];
  _QWORD v16[3];
  CFStringRef v17;
  _QWORD v18[3];
  CFStringRef v19;
  _QWORD v20[3];
  CFStringRef v21;
  _QWORD v22[6];
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  dispatch_queue_global_t global_queue;
  uint64_t v27;
  __CFString **v28;
  uint64_t v29;
  uint64_t v30;

  v27 = 0;
  v28 = (__CFString **)&v27;
  v29 = 0x2000000000;
  v30 = 0;
  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  global_queue = dispatch_get_global_queue(0, 0);
  if (!fqdn)
    goto LABEL_12;
  v8 = CFGetTypeID(fqdn);
  if (v8 != CFStringGetTypeID())
    goto LABEL_12;
  Length = CFStringGetLength(fqdn);
  v10 = CFSTR("fqdn or account was not of type CFString, or not provided");
  if (!account || !Length)
    goto LABEL_13;
  v11 = CFGetTypeID(account);
  if (v11 != CFStringGetTypeID() || !CFStringGetLength(account))
  {
LABEL_12:
    v10 = CFSTR("fqdn or account was not of type CFString, or not provided");
LABEL_13:
    SecError(-50, v28 + 3, CFSTR("%@"), v10);
    v14 = v24[3];
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 0x40000000;
    v22[2] = __SecAddSharedWebCredential_block_invoke;
    v22[3] = &unk_1E1FD9D18;
    v22[4] = completionHandler;
    v22[5] = &v27;
    dispatch_async(v14, v22);
    goto LABEL_14;
  }
  if (password)
  {
    v12 = CFGetTypeID(password);
    if (v12 != CFStringGetTypeID())
    {
      v10 = CFSTR("non-nil password was not of type CFString");
      goto LABEL_13;
    }
  }
  v20[0] = 0;
  v20[1] = v20;
  v20[2] = 0x2000000000;
  v21 = (CFStringRef)0xAAAAAAAAAAAAAAAALL;
  CFRetain(fqdn);
  v21 = fqdn;
  v18[0] = 0;
  v18[1] = v18;
  v18[2] = 0x2000000000;
  v19 = (CFStringRef)0xAAAAAAAAAAAAAAAALL;
  CFRetain(account);
  v19 = account;
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x2000000000;
  v17 = (CFStringRef)0xAAAAAAAAAAAAAAAALL;
  if (password)
    CFRetain(password);
  v17 = password;
  v13 = v24[3];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecAddSharedWebCredential_block_invoke_2;
  block[3] = &unk_1E1FD9D68;
  block[6] = v18;
  block[7] = v16;
  block[8] = &v27;
  block[9] = &v23;
  block[4] = completionHandler;
  block[5] = v20;
  dispatch_async(v13, block);
  _Block_object_dispose(v16, 8);
  _Block_object_dispose(v18, 8);
  _Block_object_dispose(v20, 8);
LABEL_14:
  _Block_object_dispose(&v23, 8);
  _Block_object_dispose(&v27, 8);
}

void SecRequestSharedWebCredential(CFStringRef fqdn, CFStringRef account, void *completionHandler)
{
  CFTypeID v6;
  __SecTask *v7;
  __SecTask *v8;
  const __CFArray *v9;
  const __CFArray *v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  void *ValueAtIndex;
  void *v15;
  id v16;
  const void *v18;
  CFTypeID v19;
  const void *v20;
  CFTypeID v21;
  NSObject *v22;
  _QWORD *v23;
  const __CFString *v24;
  const void *v25;
  const void *v26;
  _QWORD v27[10];
  _QWORD block[7];
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  CFStringRef v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  CFStringRef v36;
  _QWORD v37[4];
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  dispatch_queue_global_t global_queue;
  uint64_t v42;
  __CFString **v43;
  uint64_t v44;
  uint64_t v45;

  v42 = 0;
  v43 = (__CFString **)&v42;
  v44 = 0x2000000000;
  v45 = 0;
  v38 = 0;
  v39 = &v38;
  v40 = 0x2000000000;
  global_queue = dispatch_get_global_queue(0, 0);
  v37[0] = 0;
  v37[1] = v37;
  v37[2] = 0x2000000000;
  v37[3] = 0;
  v33 = 0;
  v34 = &v33;
  v35 = 0x2000000000;
  v36 = (CFStringRef)0xAAAAAAAAAAAAAAAALL;
  if (fqdn)
    CFRetain(fqdn);
  v36 = fqdn;
  v29 = 0;
  v30 = &v29;
  v31 = 0x2000000000;
  v32 = (CFStringRef)0xAAAAAAAAAAAAAAAALL;
  if (account)
    CFRetain(account);
  v32 = account;
  if (fqdn)
  {
    v6 = CFGetTypeID(fqdn);
    if (v6 != CFStringGetTypeID() || !CFStringGetLength(fqdn))
    {
LABEL_31:
      v24 = CFSTR("fqdn was empty or not a CFString");
      goto LABEL_33;
    }
  }
  else
  {
    v7 = SecTaskCreateFromSelf(0);
    if (v7)
    {
      v8 = v7;
      v9 = (const __CFArray *)SecTaskCopyValueForEntitlement(v7, CFSTR("com.apple.developer.associated-domains"), 0);
      if (v9)
      {
        v10 = v9;
        Count = CFArrayGetCount(v9);
        v12 = Count - 1;
        if (Count >= 1)
        {
          v13 = 0;
          do
          {
            ValueAtIndex = (void *)CFArrayGetValueAtIndex(v10, v13);
            if (objc_msgSend(ValueAtIndex, "hasPrefix:", CFSTR("webcredentials:")))
            {
              objc_msgSend(ValueAtIndex, "substringFromIndex:", objc_msgSend(CFSTR("webcredentials:"), "length"));
              v15 = (void *)objc_claimAutoreleasedReturnValue();
              if (objc_msgSend(v15, "length"))
                v16 = v15;
              else
                v16 = 0;

            }
            else
            {
              v16 = 0;
            }
            v34[3] = (uint64_t)v16;
            if (v16)
              break;
          }
          while (v12 != v13++);
        }
        CFRelease(v10);
      }
      CFRelease(v8);
    }
  }
  v18 = (const void *)v34[3];
  if (!v18)
  {
    v24 = CFSTR("fqdn was NULL, and no associated domains found");
    goto LABEL_33;
  }
  v19 = CFGetTypeID(v18);
  if (v19 != CFStringGetTypeID() || !CFStringGetLength((CFStringRef)v34[3]))
    goto LABEL_31;
  v20 = (const void *)v30[3];
  if (!v20 || (v21 = CFGetTypeID(v20), v21 == CFStringGetTypeID()) && CFStringGetLength((CFStringRef)v30[3]))
  {
    v22 = v39[3];
    v27[0] = MEMORY[0x1E0C809B0];
    v27[1] = 0x40000000;
    v27[2] = __SecRequestSharedWebCredential_block_invoke_2;
    v27[3] = &unk_1E1FD9DE0;
    v27[6] = &v29;
    v27[7] = v37;
    v27[8] = &v42;
    v27[9] = &v38;
    v27[4] = completionHandler;
    v27[5] = &v33;
    v23 = v27;
    goto LABEL_38;
  }
  v24 = CFSTR("account was empty or not a CFString");
LABEL_33:
  v25 = (const void *)v34[3];
  if (v25)
    CFRelease(v25);
  v26 = (const void *)v30[3];
  if (v26)
    CFRelease(v26);
  SecError(-50, v43 + 3, CFSTR("%@"), v24);
  v22 = v39[3];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecRequestSharedWebCredential_block_invoke;
  block[3] = &unk_1E1FD9D90;
  block[4] = completionHandler;
  block[5] = v37;
  block[6] = &v42;
  v23 = block;
LABEL_38:
  dispatch_async(v22, v23);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
  _Block_object_dispose(v37, 8);
  _Block_object_dispose(&v38, 8);
  _Block_object_dispose(&v42, 8);
}

CFStringRef SecCreateSharedWebCredentialPassword(void)
{
  CFCharacterSetRef v0;
  CFCharacterSetRef v1;
  CFCharacterSetRef v2;
  CFNumberRef v3;
  CFNumberRef v4;
  CFNumberRef v5;
  __CFArray *Mutable;
  __CFDictionary *v7;
  const __CFString *v8;
  NSObject *v9;
  uint8_t v11[12];
  int v12;
  int v13;
  int valuePtr;
  const __CFDictionary *v15;

  v15 = 0;
  v0 = CFCharacterSetCreateWithCharactersInString(0, CFSTR("abcdefghkmnopqrstuvwxyz"));
  v1 = CFCharacterSetCreateWithCharactersInString(0, CFSTR("ABCDEFGHJKLMNPQRSTUVWXYZ"));
  v2 = CFCharacterSetCreateWithCharactersInString(0, CFSTR("3456789"));
  v13 = 4;
  valuePtr = 3;
  v12 = 12;
  v3 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  v4 = CFNumberCreate(0, kCFNumberIntType, &v13);
  v5 = CFNumberCreate(0, kCFNumberIntType, &v12);
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  CFArrayAppendValue(Mutable, v0);
  CFArrayAppendValue(Mutable, v1);
  CFArrayAppendValue(Mutable, v2);
  v7 = CFDictionaryCreateMutable(0, 0, 0, 0);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordAllowedCharactersKey, CFSTR("abcdefghkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ23456789"));
  CFDictionaryAddValue(v7, (const void *)kSecPasswordRequiredCharactersKey, Mutable);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordGroupSize, v3);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordNumberOfGroups, v4);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordSeparator, CFSTR("-"));
  CFDictionaryAddValue(v7, (const void *)kSecPasswordMaxLengthKey, v5);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordMinLengthKey, v5);
  CFDictionaryAddValue(v7, (const void *)kSecPasswordDefaultForType, CFSTR("false"));
  CFRelease(v0);
  CFRelease(v1);
  CFRelease(v2);
  CFRelease(v3);
  CFRelease(v4);
  CFRelease(v5);
  v8 = SecPasswordGenerate(0, &v15, v7);
  CFRelease(Mutable);
  CFRelease(v7);
  if (v15 || !v8)
  {
    if (v8)
      CFRelease(v8);
    v9 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v11 = 0;
      _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "SecPasswordGenerate failed to generate a password for SecCreateSharedWebCredentialPassword.", v11, 2u);
    }
    return 0;
  }
  return v8;
}

__CFData *SecRecreateSignatureWithDERAlgorithmId(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  __CFData *Mutable;
  uint64_t v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  CFIndex v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  Mutable = 0;
  v19 = *MEMORY[0x1E0C80C00];
  if (a1 && a2)
  {
    if (SecKeyGetAlgorithmId(a1) == 3)
    {
      v7 = *(_QWORD *)MEMORY[0x18D76FFBC]();
      v8 = 8 * v7;
      ((void (*)(void))MEMORY[0x1E0C80A78])();
      v9 = (8 * v7 + 15) & 0xFFFFFFFFFFFFFFF0;
      if (v7)
      {
        v10 = memset((char *)&v17 - v9, 170, v8);
        MEMORY[0x1E0C80A78](v10);
        memset((char *)&v17 - v9, 170, v8);
      }
      v18 = a3 + a4;
      ccder_decode_sequence_tl();
      mp_decode_forced_uint();
      v11 = mp_decode_forced_uint();
      if (v11)
        v12 = v18 == v11;
      else
        v12 = 0;
      if (!v12)
        return 0;
      ccder_sizeof_integer();
      ccder_sizeof_integer();
      v13 = ccder_sizeof();
      if (v13 < a4 || v13 > a4 + 5)
        return 0;
      v16 = v13;
      Mutable = CFDataCreateMutable(0, v13);
      CFDataSetLength(Mutable, v16);
      CFDataGetMutableBytePtr(Mutable);
      ccder_encode_integer();
      ccder_encode_integer();
      if (!ccder_encode_constructed_tl() && Mutable)
      {
        CFRelease(Mutable);
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return Mutable;
}

CFStringRef SecTrustCopyFormatDescription(uint64_t a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<SecTrustRef: %p>"), a1);
}

CFStringRef SecTrustCopyDescription(uint64_t a1)
{
  SecGetDebugDescriptionFormatOptions();
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<SecTrustRef: %p>"), a1);
}

uint64_t SecTrustAddToInputCertificates(uint64_t a1, const void *a2)
{
  uint64_t v2;
  NSObject *v5;
  uint64_t v6;
  CFTypeID v7;
  CFIndex Count;
  CFIndex v9;
  CFTypeID v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  const void *v14;
  _QWORD v16[6];
  _QWORD context[5];
  _QWORD block[6];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint8_t buf[8];
  uint64_t v24;
  uint64_t (*v25)(uint64_t);
  void *v26;
  uint64_t v27;
  CFRange v28;

  v2 = 4294967246;
  if (a1 && a2)
  {
    v19 = 0;
    v20 = &v19;
    v21 = 0x2000000000;
    v22 = 0;
    v5 = *(NSObject **)(a1 + 136);
    v6 = MEMORY[0x1E0C809B0];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SecTrustAddToInputCertificates_block_invoke;
    block[3] = &unk_1E1FD9F90;
    block[4] = &v19;
    block[5] = a1;
    dispatch_sync(v5, block);
    v7 = CFGetTypeID(a2);
    if (v7 == CFArrayGetTypeID())
    {
      Count = CFArrayGetCount((CFArrayRef)v20[3]);
      context[0] = v6;
      context[1] = 0x40000000;
      context[2] = __SecTrustAddToInputCertificates_block_invoke_2;
      context[3] = &unk_1E1FD9FB8;
      context[4] = &v19;
      v28.length = CFArrayGetCount((CFArrayRef)a2);
      v28.location = 0;
      CFArrayApplyFunction((CFArrayRef)a2, v28, (CFArrayApplierFunction)apply_block_1_11511, context);
      v9 = CFArrayGetCount((CFArrayRef)v20[3]);
      if (v9 != CFArrayGetCount((CFArrayRef)a2) + Count)
      {
LABEL_11:
        v14 = (const void *)v20[3];
        if (v14)
        {
          v20[3] = 0;
          CFRelease(v14);
        }
        v2 = 4294967246;
        goto LABEL_14;
      }
    }
    else
    {
      v10 = CFGetTypeID(a2);
      if (v10 != SecCertificateGetTypeID())
      {
        v13 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, "BUG IN SECURITY CLIENT: certificates contains unsupported value type", buf, 2u);
        }
        goto LABEL_11;
      }
      CFArrayAppendValue((CFMutableArrayRef)v20[3], a2);
    }
    v11 = *(NSObject **)(a1 + 136);
    v16[0] = v6;
    v16[1] = 0x40000000;
    v16[2] = __SecTrustAddToInputCertificates_block_invoke_47;
    v16[3] = &unk_1E1FD9FE0;
    v16[4] = &v19;
    v16[5] = a1;
    dispatch_sync(v11, v16);
    v12 = *(NSObject **)(a1 + 136);
    *(_QWORD *)buf = v6;
    v24 = 0x40000000;
    v25 = __SecTrustSetNeedsEvaluation_block_invoke;
    v26 = &__block_descriptor_tmp_49_11514;
    v27 = a1;
    dispatch_sync(v12, buf);
    v2 = 0;
LABEL_14:
    _Block_object_dispose(&v19, 8);
  }
  return v2;
}

uint64_t apply_block_1_11511(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void SecTrustSetNeedsEvaluation(uint64_t a1)
{
  NSObject *v1;
  _QWORD block[5];

  if (a1)
  {
    v1 = *(NSObject **)(a1 + 136);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
    block[3] = &__block_descriptor_tmp_49_11514;
    block[4] = a1;
    dispatch_sync(v1, block);
  }
}

OSStatus SecTrustSetAnchorCertificatesOnly(SecTrustRef trust, Boolean anchorCertificatesOnly)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD v8[5];
  Boolean v9;
  _QWORD block[5];

  if (!trust)
    return -50;
  v4 = MEMORY[0x1E0C809B0];
  v5 = *((_QWORD *)trust + 17);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11514;
  block[4] = trust;
  dispatch_sync(v5, block);
  v6 = *((_QWORD *)trust + 17);
  v8[0] = v4;
  v8[1] = 0x40000000;
  v8[2] = __SecTrustSetAnchorCertificatesOnly_block_invoke;
  v8[3] = &__block_descriptor_tmp_50_11519;
  v8[4] = trust;
  v9 = anchorCertificatesOnly;
  dispatch_sync(v6, v8);
  return 0;
}

OSStatus SecTrustCopyCustomAnchorCertificates(SecTrustRef trust, CFArrayRef *anchors)
{
  OSStatus v2;
  NSObject *v4;
  _QWORD v6[6];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v2 = -50;
  if (trust && anchors)
  {
    v7 = 0;
    v8 = &v7;
    v9 = 0x2000000000;
    v10 = 0;
    v4 = *((_QWORD *)trust + 17);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __SecTrustCopyCustomAnchorCertificates_block_invoke;
    v6[3] = &unk_1E1FDA070;
    v6[4] = &v7;
    v6[5] = trust;
    dispatch_sync(v4, v6);
    *anchors = (CFArrayRef)v8[3];
    _Block_object_dispose(&v7, 8);
    return 0;
  }
  return v2;
}

uint64_t SecTrustFlushResponseCache(CFTypeRef *a1)
{
  return SecTrustResetSettings(2, a1);
}

uint64_t SecTrustResetSettings(uint64_t a1, CFTypeRef *a2)
{
  NSObject *v4;
  uint64_t (*v5)(uint64_t, CFTypeRef *);
  uint64_t v6;
  os_activity_scope_state_s state;
  CFTypeRef cf;
  _QWORD v10[5];
  _QWORD v11[4];
  int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;

  cf = 0;
  v4 = _os_activity_create(&dword_18A900000, "SecTrustResetSettings", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  if (gTrustd && (v5 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gTrustd + 240)) != 0)
  {
    v6 = v5(a1, &cf);
  }
  else
  {
    v13 = 0;
    v14 = &v13;
    v15 = 0x2000000000;
    v16 = 0;
    v10[4] = &v13;
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 0x40000000;
    v11[2] = __int_to_BOOL_error_request_block_invoke;
    v11[3] = &__block_descriptor_tmp_453;
    v12 = a1;
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 0x40000000;
    v10[2] = __int_to_BOOL_error_request_block_invoke_2;
    v10[3] = &unk_1E1FDB560;
    securityd_send_sync_and_do(0x82u, &cf, (uint64_t)v11, (uint64_t)v10);
    v6 = *((_BYTE *)v14 + 24) != 0;
    _Block_object_dispose(&v13, 8);
  }
  os_release(v4);
  if (a2)
  {
    *a2 = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  os_activity_scope_leave(&state);
  return v6;
}

OSStatus SecTrustSetSignedCertificateTimestamps(SecTrustRef trust, CFArrayRef sctArray)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD v8[6];
  _QWORD block[5];

  if (!trust)
    return -50;
  v4 = MEMORY[0x1E0C809B0];
  v5 = *((_QWORD *)trust + 17);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11514;
  block[4] = trust;
  dispatch_sync(v5, block);
  v6 = *((_QWORD *)trust + 17);
  v8[0] = v4;
  v8[1] = 0x40000000;
  v8[2] = __SecTrustSetSignedCertificateTimestamps_block_invoke;
  v8[3] = &__block_descriptor_tmp_54_11529;
  v8[4] = trust;
  v8[5] = sctArray;
  dispatch_sync(v6, v8);
  return 0;
}

uint64_t SecTrustSetTrustedLogs(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD v8[6];
  _QWORD block[5];

  if (!a1)
    return 4294967246;
  v4 = MEMORY[0x1E0C809B0];
  v5 = *(NSObject **)(a1 + 136);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11514;
  block[4] = a1;
  dispatch_sync(v5, block);
  v6 = *(NSObject **)(a1 + 136);
  v8[0] = v4;
  v8[1] = 0x40000000;
  v8[2] = __SecTrustSetTrustedLogs_block_invoke;
  v8[3] = &__block_descriptor_tmp_55_11530;
  v8[4] = a1;
  v8[5] = a2;
  dispatch_sync(v6, v8);
  return 0;
}

uint64_t SecTrustSetKeychainsAllowed(uint64_t a1, char a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD v8[5];
  char v9;
  _QWORD block[5];

  if (!a1)
    return 4294967246;
  v4 = MEMORY[0x1E0C809B0];
  v5 = *(NSObject **)(a1 + 136);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustSetNeedsEvaluation_block_invoke;
  block[3] = &__block_descriptor_tmp_49_11514;
  block[4] = a1;
  dispatch_sync(v5, block);
  v6 = *(NSObject **)(a1 + 136);
  v8[0] = v4;
  v8[1] = 0x40000000;
  v8[2] = __SecTrustSetKeychainsAllowed_block_invoke;
  v8[3] = &__block_descriptor_tmp_61_11541;
  v8[4] = a1;
  v9 = a2;
  dispatch_sync(v6, v8);
  return 0;
}

uint64_t SecTrustGetKeychainsAllowed(uint64_t a1, _BYTE *a2)
{
  uint64_t result;

  result = 4294967246;
  if (a1)
  {
    if (a2)
    {
      result = 0;
      *a2 = *(_BYTE *)(a1 + 117);
    }
  }
  return result;
}

uint64_t SecTrustRemoveOptionInPolicies(const void *a1, const void *a2)
{
  CFTypeID v4;
  CFIndex i;
  CFDictionaryRef *ValueAtIndex;
  CFDictionaryRef *v7;
  __CFDictionary *MutableCopy;
  __CFDictionary *v9;
  CFDictionaryRef v10;

  if (a1)
  {
    v4 = CFGetTypeID(a1);
    if (v4 != CFArrayGetTypeID())
      return 4294941020;
    for (i = 0; ; ++i)
    {
      if (CFArrayGetCount((CFArrayRef)a1) <= i)
        return 0;
      ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)a1, i);
      if (!ValueAtIndex)
        return 4294941020;
      v7 = ValueAtIndex;
      if (CFDictionaryGetValue(ValueAtIndex[4], a2))
      {
        MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v7[4]);
        if (!MutableCopy)
          return 4294967188;
        v9 = MutableCopy;
        CFDictionaryRemoveValue(MutableCopy, a2);
        v10 = v7[4];
        if (v10)
        {
          v7[4] = 0;
          CFRelease(v10);
        }
        v7[4] = v9;
      }
    }
  }
  return 4294941020;
}

OSStatus SecTrustGetNetworkFetchAllowed(SecTrustRef trust, Boolean *allowFetch)
{
  OSStatus v2;
  NSObject *v4;
  uint64_t v5;
  uint64_t *v6;
  const __CFArray *v7;
  const void *v8;
  _QWORD context[5];
  _QWORD block[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  CFRange v16;

  v2 = -50;
  if (trust && allowFetch)
  {
    v12 = 0;
    v13 = &v12;
    v14 = 0x2000000000;
    v15 = 0;
    v4 = *((_QWORD *)trust + 17);
    v5 = MEMORY[0x1E0C809B0];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SecTrustGetNetworkFetchAllowed_block_invoke;
    block[3] = &unk_1E1FDA200;
    block[4] = &v12;
    block[5] = trust;
    dispatch_sync(v4, block);
    v6 = v13;
    v7 = (const __CFArray *)v13[3];
    if (v7)
    {
      context[0] = v5;
      context[1] = 0x40000000;
      context[2] = __SecTrustGetNetworkFetchAllowed_block_invoke_2;
      context[3] = &__block_descriptor_tmp_66_11547;
      context[4] = allowFetch;
      v16.length = CFArrayGetCount(v7);
      v16.location = 0;
      CFArrayApplyFunction(v7, v16, (CFArrayApplierFunction)apply_block_1_11511, context);
      v6 = v13;
    }
    else
    {
      *allowFetch = 1;
    }
    v8 = (const void *)v6[3];
    if (v8)
    {
      v6[3] = 0;
      CFRelease(v8);
    }
    _Block_object_dispose(&v12, 8);
    return 0;
  }
  return v2;
}

uint64_t SecTrustSetPinningException(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;

  if (!a1)
    return 4294967246;
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v1 = *(NSObject **)(a1 + 136);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __SecTrustSetPinningException_block_invoke;
  v4[3] = &unk_1E1FDA250;
  v4[4] = &v5;
  v4[5] = a1;
  dispatch_sync(v1, v4);
  v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(&v5, 8);
  return v2;
}

__SecTrust *SecTrustGetDetails(__SecTrust *result)
{
  __SecTrust *v1;

  if (result)
  {
    v1 = result;
    SecTrustEvaluateIfNecessary(result);
    return (__SecTrust *)*((_QWORD *)v1 + 11);
  }
  return result;
}

__SecTrust *SecTrustCopyFilteredDetails(__SecTrust *a1)
{
  __SecTrust *v1;
  NSObject *v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v1 = a1;
  if (a1)
  {
    SecTrustEvaluateIfNecessary(a1);
    v5 = 0;
    v6 = &v5;
    v7 = 0x2000000000;
    v8 = 0;
    v2 = *((_QWORD *)v1 + 17);
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __SecTrustCopyFilteredDetails_block_invoke;
    v4[3] = &unk_1E1FDA2C0;
    v4[4] = &v5;
    v4[5] = v1;
    dispatch_sync(v2, v4);
    v1 = (__SecTrust *)v6[3];
    _Block_object_dispose(&v5, 8);
  }
  return v1;
}

uint64_t SecTrustIsExpiredOnly(__SecTrust *a1)
{
  __SecTrust *v1;
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v4;
  CFIndex v5;
  unsigned __int8 v6;
  const void *v7;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v9;
  CFIndex v10;
  const void *Value;
  const void *v12;
  CFTypeID v13;

  v1 = SecTrustCopyFilteredDetails(a1);
  if (v1)
  {
    v2 = v1;
    Count = CFArrayGetCount(v1);
    if (Count >= 1)
    {
      v4 = Count;
      v5 = 0;
      v6 = 0;
      v7 = (const void *)*MEMORY[0x1E0C9AE40];
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, v5);
        if (ValueAtIndex)
        {
          v9 = ValueAtIndex;
          v10 = CFDictionaryGetCount(ValueAtIndex);
          if (v10 > 1)
            break;
          if (v10)
          {
            Value = CFDictionaryGetValue(v9, CFSTR("TemporalValidity"));
            if (!Value)
              break;
            v12 = Value;
            v13 = CFGetTypeID(Value);
            if (v13 != CFBooleanGetTypeID() || !CFEqual(v12, v7))
              break;
            v6 = 1;
          }
        }
        if (v4 == ++v5)
          goto LABEL_14;
      }
    }
    v6 = 0;
LABEL_14:
    CFRelease(v2);
  }
  else
  {
    return 0;
  }
  return v6;
}

__CFString *SecTrustCopyFailureDescription(__SecTrust *a1)
{
  __CFString *Mutable;
  NSObject *v3;
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  const __CFDictionary *ValueAtIndex;
  CFIndex v8;
  size_t v9;
  __CFString *v10;
  const __CFString *v11;
  uint64_t v12;
  size_t v13;
  const void **v14;
  const void *v15;
  const void *v16;
  const __CFString *Value;
  CFTypeID v18;
  const __CFString *v19;
  const void *v20;
  CFIndex v22;
  CFIndex v23;
  CFIndex *v24;
  _QWORD block[6];
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  Mutable = CFStringCreateMutable(0, 0);
  SecTrustEvaluateIfNecessary(a1);
  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v29 = 0;
  v3 = *((_QWORD *)a1 + 17);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecTrustCopyFailureDescription_block_invoke;
  block[3] = &unk_1E1FDA868;
  block[4] = &v26;
  block[5] = a1;
  dispatch_sync(v3, block);
  v4 = (const __CFArray *)v27[3];
  if (v4)
  {
    Count = CFArrayGetCount(v4);
    v22 = Count - 1;
    v23 = Count;
    if (Count >= 1)
    {
      v6 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v27[3], v6);
        v8 = CFDictionaryGetCount(ValueAtIndex);
        if (v8 >= 1)
          break;
LABEL_18:
        if (++v6 == v23)
          goto LABEL_19;
      }
      v9 = v8;
      if (v6)
      {
        if (v6 != v22)
        {
          CFStringAppendFormat(Mutable, 0, CFSTR(" [ca%ld"), v6);
LABEL_12:
          v24 = &v22;
          MEMORY[0x1E0C80A78](v12);
          v14 = (const void **)((char *)&v22 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0));
          memset(v14, 170, v13);
          CFDictionaryGetKeysAndValues(ValueAtIndex, v14, 0);
          qsort(v14, v9, 8uLL, (int (__cdecl *)(const void *, const void *))compare_strings);
          do
          {
            v16 = *v14++;
            v15 = v16;
            Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, v16);
            v18 = CFGetTypeID(Value);
            if (v18 == CFBooleanGetTypeID())
              v19 = &stru_1E1FDD448;
            else
              v19 = Value;
            CFStringAppendFormat(Mutable, 0, CFSTR(" %@%@"), v15, v19);
            --v9;
          }
          while (v9);
          CFStringAppend(Mutable, CFSTR("]"));
          goto LABEL_18;
        }
        v10 = Mutable;
        v11 = CFSTR(" [root");
      }
      else
      {
        v10 = Mutable;
        v11 = CFSTR(" [leaf");
      }
      CFStringAppend(v10, v11);
      goto LABEL_12;
    }
  }
LABEL_19:
  v20 = (const void *)v27[3];
  if (v20)
    CFRelease(v20);
  _Block_object_dispose(&v26, 8);
  return Mutable;
}

CFComparisonResult compare_strings(CFStringRef *a1, CFStringRef *a2)
{
  return CFStringCompare(*a1, *a2, 0x200uLL);
}

CFErrorRef SecTrustCopyError(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  CFErrorRef v4;
  int v5;
  NSObject *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  void *v12;
  __SecCertificate *v13;
  CFStringRef v14;
  const __CFString *v15;
  const void *v16;
  CFIndex v17;
  __SecCertificate *v18;
  CFStringRef v19;
  const __CFString *v20;
  const void *v21;
  void *v22;
  __CFString *v23;
  OSStatus v24;
  const __CFString *v25;
  __CFString *v26;
  NSObject *v27;
  CFIndex v28;
  CFIndex v29;
  CFIndex j;
  __SecCertificate *v31;
  CFStringRef v32;
  CFStringRef v33;
  const void *v34;
  void *v35;
  const void **v36;
  const __CFDictionary *v37;
  const __CFString *v38;
  CFIndex v39;
  CFErrorRef v40;
  void *v41;
  uint64_t v42;
  const __CFDictionary *v43;
  void *values;
  _QWORD block[6];
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  CFMutableStringRef Mutable;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  uint64_t v81;
  void *v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  const void *context;
  uint64_t v90;
  void (*v91)(_QWORD *, const void *);
  void *v92;
  uint64_t *v93;
  uint64_t *v94;
  uint64_t *v95;
  uint64_t *v96;
  void **v97;
  uint64_t *v98;
  void *v99;
  uint64_t v100;
  _QWORD *(*v101)(_QWORD *);
  void *v102;
  uint64_t *v103;
  uint64_t *v104;
  uint64_t v105;
  uint64_t v106;

  v106 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v47 = 0;
    v48 = &v47;
    v49 = 0x2000000000;
    v50 = 0;
    v2 = *(NSObject **)(a1 + 136);
    v3 = (void *)MEMORY[0x1E0C809B0];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SecTrustCopyError_block_invoke;
    block[3] = &unk_1E1FDAD50;
    block[4] = &v47;
    block[5] = a1;
    dispatch_sync(v2, block);
    v4 = 0;
    v5 = *((_DWORD *)v48 + 6);
    if (v5 == 1 || v5 == 4)
    {
LABEL_71:
      _Block_object_dispose(&v47, 8);
      return v4;
    }
    values = 0;
    v75 = 0;
    v76 = &v75;
    v77 = 0x2000000000;
    v78 = 0;
    v71 = 0;
    v72 = &v71;
    v73 = 0x2000000000;
    v74 = 0;
    v7 = *(NSObject **)(a1 + 136);
    v99 = v3;
    v100 = 0x40000000;
    v101 = __SecTrustCopyErrorStrings_block_invoke;
    v102 = &unk_1E1FDAD78;
    v104 = &v71;
    v105 = a1;
    v103 = &v75;
    dispatch_sync(v7, &v99);
    if (v76[3])
    {
      if (SecTrustCopyErrorStrings_onceToken != -1)
        dispatch_once(&SecTrustCopyErrorStrings_onceToken, &__block_literal_global_283);
      v67 = 0;
      v68 = &v67;
      v69 = 0x2000000000;
      Mutable = (CFMutableStringRef)0xAAAAAAAAAAAAAAAALL;
      Mutable = CFStringCreateMutable(0, 0);
      v63 = 0;
      v64 = &v63;
      v65 = 0x2000000000;
      v66 = 11;
      v59 = 0;
      v60 = &v59;
      v61 = 0x2000000000;
      v62 = -67671;
      v55 = 0;
      v56 = &v55;
      v57 = 0x2000000000;
      v58 = -1;
      v51 = 0;
      v52 = &v51;
      v53 = 0x2000000000;
      v54 = 0xAAAAAAAAAAAAAAAALL;
      Count = CFArrayGetCount((CFArrayRef)v76[3]);
      v52[3] = 0;
      if (Count >= 1)
      {
        v9 = Count;
        for (i = 0; i < v9; v52[3] = i)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v76[3], i);
          if (CFDictionaryGetCount(ValueAtIndex))
          {
            v12 = v3;
            v13 = (__SecCertificate *)CFArrayGetValueAtIndex((CFArrayRef)v72[3], v52[3]);
            v14 = SecCertificateCopySubjectSummary(v13);
            v15 = SecFrameworkCopyLocalizedString(CFSTR("Certificate %ld %@ has errors: "), CFSTR("Trust"));
            CFStringAppendFormat((CFMutableStringRef)v68[3], 0, v15, v52[3], v14);
            if (v14)
              CFRelease(v14);
            if (v15)
              CFRelease(v15);
            v79 = 0;
            v80 = (uint64_t)&v79;
            v81 = 0x2000000000;
            LOBYTE(v82) = 1;
            v3 = v12;
            context = v12;
            v90 = 0x40000000;
            v91 = __SecTrustCopyErrorStrings_block_invoke_3;
            v92 = &unk_1E1FDB000;
            v93 = &v63;
            v94 = &v55;
            v95 = &v51;
            v96 = &v59;
            v97 = &v79;
            v98 = &v67;
            CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)apply_block_2_11625, &context);
            CFStringAppend((CFMutableStringRef)v68[3], CFSTR(";"));
            _Block_object_dispose(&v79, 8);
          }
          i = v52[3] + 1;
        }
      }
      v16 = (const void *)v76[3];
      if (v16)
      {
        v76[3] = 0;
        CFRelease(v16);
      }
      v17 = v56[3];
      if (v17 == -1)
      {
        v17 = 0;
        v56[3] = 0;
      }
      v18 = (__SecCertificate *)CFArrayGetValueAtIndex((CFArrayRef)v72[3], v17);
      v19 = SecCertificateCopySubjectSummary(v18);
      switch(*((_DWORD *)v64 + 6))
      {
        case 0:
          v20 = CFSTR("%@ certificate is blocked");
          goto LABEL_48;
        case 1:
          v20 = CFSTR("%@ certificate is revoked");
          goto LABEL_48;
        case 2:
          v20 = CFSTR("%@ certificate is using a broken key size");
          goto LABEL_48;
        case 3:
          v20 = CFSTR("%@ certificate is using a broken signature algorithm");
          goto LABEL_48;
        case 4:
          v20 = CFSTR("User or administrator set %@ certificate as distrusted");
          goto LABEL_48;
        case 5:
          v20 = CFSTR("%@ certificate is not standards compliant");
          goto LABEL_48;
        case 6:
          v25 = SecFrameworkCopyLocalizedString(CFSTR("%@ certificates do not meet pinning requirements"), CFSTR("Trust"));
          v26 = CFStringCreateMutable(0, 0);
          v85 = 0;
          v86 = &v85;
          v87 = 0x2000000000;
          v88 = 0;
          v27 = *(NSObject **)(a1 + 136);
          v79 = v3;
          v80 = 0x40000000;
          v81 = (uint64_t)__SecTrustCopyChainSummary_block_invoke;
          v82 = &unk_1E1FDB028;
          v83 = &v85;
          v84 = a1;
          dispatch_sync(v27, &v79);
          v28 = CFArrayGetCount((CFArrayRef)v86[3]);
          if (v28 >= 1)
          {
            v29 = v28;
            for (j = 0; j != v29; ++j)
            {
              if (j)
                CFStringAppend(v26, CFSTR(","));
              v31 = (__SecCertificate *)CFArrayGetValueAtIndex((CFArrayRef)v86[3], j);
              v32 = SecCertificateCopySubjectSummary(v31);
              CFStringAppendFormat(v26, 0, CFSTR("\"%@\""), v32);
              if (v32)
                CFRelease(v32);
            }
          }
          _Block_object_dispose(&v85, 8);
          if (v19)
            CFRelease(v19);
          v19 = v26;
          goto LABEL_49;
        case 7:
          v20 = CFSTR("%@ certificate is not trusted");
          goto LABEL_48;
        case 8:
          v20 = CFSTR("%@ certificate is not permitted for this usage");
          goto LABEL_48;
        case 9:
          v20 = CFSTR("%@ certificate name does not match input");
          goto LABEL_48;
        case 0xA:
          v20 = CFSTR("%@ certificate is expired");
          goto LABEL_48;
        default:
          v20 = CFSTR("Unknown trust error for %@ certificate");
LABEL_48:
          v25 = SecFrameworkCopyLocalizedString(v20, CFSTR("Trust"));
LABEL_49:
          if (v25 && v19)
          {
            v33 = CFStringCreateWithFormat(0, 0, v25, v19);
          }
          else
          {
            v33 = 0;
            v23 = 0;
            if (!v25)
              goto LABEL_54;
          }
          CFRelease(v25);
          v23 = (__CFString *)v33;
LABEL_54:
          if (v19)
            CFRelease(v19);
          v34 = (const void *)v72[3];
          if (v34)
          {
            v72[3] = 0;
            CFRelease(v34);
          }
          v22 = (void *)v68[3];
          values = v22;
          v24 = *((_DWORD *)v60 + 6);
          _Block_object_dispose(&v51, 8);
          _Block_object_dispose(&v55, 8);
          _Block_object_dispose(&v59, 8);
          _Block_object_dispose(&v63, 8);
          _Block_object_dispose(&v67, 8);
          break;
      }
    }
    else
    {
      v21 = (const void *)v72[3];
      if (v21)
      {
        v72[3] = 0;
        CFRelease(v21);
      }
      v22 = 0;
      v23 = 0;
      v24 = -26276;
    }
    _Block_object_dispose(&v71, 8);
    _Block_object_dispose(&v75, 8);
    if (v23)
    {
      if (v22)
      {
LABEL_61:
        v36 = (const void **)MEMORY[0x1E0C9AFE0];
        v37 = CFDictionaryCreate(0, MEMORY[0x1E0C9AFE0], (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v38 = (const __CFString *)*MEMORY[0x1E0C9AFC8];
        v39 = v24;
        v40 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v24, v37);
        if (v37)
          CFRelease(v37);
        v41 = values;
        if (values)
        {
          values = 0;
          CFRelease(v41);
        }
        v42 = *MEMORY[0x1E0C9B000];
        context = *v36;
        v90 = v42;
        v99 = v23;
        v100 = (uint64_t)v40;
        v43 = CFDictionaryCreate(0, &context, (const void **)&v99, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        v4 = CFErrorCreate(0, v38, v39, v43);
        if (v43)
          CFRelease(v43);
        if (v23)
          CFRelease(v23);
        if (v40)
          CFRelease(v40);
        goto LABEL_71;
      }
    }
    else
    {
      v23 = (__CFString *)SecCopyErrorMessageString(v24, v35);
      if (v22)
        goto LABEL_61;
    }
    values = (void *)SecCopyErrorMessageString(v24, v35);
    goto LABEL_61;
  }
  return 0;
}

uint64_t apply_block_2_11625(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

OSStatus SecTrustEvaluateAsync(SecTrustRef trust, dispatch_queue_t queue, SecTrustCallback result)
{
  _QWORD v7[6];

  if (trust)
    CFRetain(trust);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[2] = __SecTrustEvaluateAsync_block_invoke;
  v7[3] = &unk_1E1FDA7A0;
  v7[4] = result;
  v7[5] = trust;
  dispatch_async(queue, v7);
  return 0;
}

OSStatus SecTrustEvaluateAsyncWithError(SecTrustRef trust, dispatch_queue_t queue, SecTrustWithErrorCallback result)
{
  OSStatus v4;
  _QWORD v7[6];

  v4 = -50;
  if (trust && queue)
  {
    if (result)
    {
      dispatch_assert_queue_V2(queue);
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 0x40000000;
      v7[2] = __SecTrustEvaluateAsyncWithError_block_invoke;
      v7[3] = &unk_1E1FDA840;
      v7[4] = result;
      v7[5] = trust;
      SecTrustEvaluateIfNecessaryFastAsync((dispatch_queue_t *)trust, queue, (uint64_t)v7);
      return 0;
    }
  }
  return v4;
}

__SecTrust *SecTrustCopyInfo(__SecTrust *a1)
{
  __SecTrust *v1;
  NSObject *v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v1 = a1;
  if (a1)
  {
    SecTrustEvaluateIfNecessary(a1);
    v5 = 0;
    v6 = &v5;
    v7 = 0x2000000000;
    v8 = 0;
    v2 = *((_QWORD *)v1 + 17);
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __SecTrustCopyInfo_block_invoke;
    v4[3] = &unk_1E1FDA980;
    v4[4] = &v5;
    v4[5] = v1;
    dispatch_sync(v2, v4);
    v1 = (__SecTrust *)v6[3];
    _Block_object_dispose(&v5, 8);
  }
  return v1;
}

uint64_t SecTrustGetTrustExceptionsArray(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  if (!a1)
    return 0;
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v1 = *(NSObject **)(a1 + 136);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __SecTrustGetTrustExceptionsArray_block_invoke;
  v4[3] = &unk_1E1FDA9A8;
  v4[4] = &v5;
  v4[5] = a1;
  dispatch_sync(v1, v4);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

BOOL SecTrustSetExceptions(SecTrustRef trust, CFDataRef exceptions)
{
  SecTrustRef v2;
  CFPropertyListRef v3;
  const void *v4;
  CFTypeID v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  const __CFArray *v10;
  const __CFArray *v11;
  __CFData *ValueAtIndex;
  __CFData *v13;
  const void *v14;
  CFTypeID v15;
  const void *v16;
  __CFData *SHA1Digest;
  const void *v18;
  const __CFArray *v19;
  CFTypeRef v20;
  const void *v21;
  CFTypeID v22;
  const __CFDictionary *v23;
  const __CFDictionary *v24;
  CFTypeID v25;
  uint64_t ExceptionResetCount;
  NSObject *v27;
  NSObject *v28;
  CFTypeRef v29;
  NSObject *v30;
  NSObject *v31;
  const char *v32;
  NSObject *v33;
  uint32_t v34;
  const __CFNumber *Value;
  const __CFNumber *v36;
  CFTypeID v37;
  NSObject *v38;
  const char *v39;
  NSObject *v40;
  _QWORD v42[5];
  _QWORD block[6];
  unint64_t valuePtr;
  unint64_t *p_valuePtr;
  uint64_t v46;
  uint64_t v47;
  CFTypeRef cf;
  CFTypeRef *p_cf;
  uint64_t v50;
  uint64_t v51;
  _BYTE buf[24];
  void *v53;
  CFTypeRef *v54;
  unint64_t *v55;
  SecTrustRef v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (trust)
  {
    v2 = trust;
    if (exceptions)
    {
      v3 = CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], exceptions, 0, 0, 0);
      v4 = v3;
      if (!v3 || (v5 = CFGetTypeID(v3), v5 == CFArrayGetTypeID()))
      {
LABEL_7:
        v6 = *((_QWORD *)v2 + 17);
        v7 = MEMORY[0x1E0C809B0];
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = __SecTrustSetExceptions_block_invoke;
        block[3] = &__block_descriptor_tmp_220;
        block[4] = v2;
        block[5] = v4;
        dispatch_sync(v6, block);
        v8 = *((_QWORD *)v2 + 17);
        *(_QWORD *)buf = v7;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = __SecTrustSetNeedsEvaluation_block_invoke;
        v53 = &__block_descriptor_tmp_49_11514;
        v54 = (CFTypeRef *)v2;
        dispatch_sync(v8, buf);
        cf = 0;
        p_cf = &cf;
        v50 = 0x2000000000;
        v51 = 0;
        valuePtr = 0;
        p_valuePtr = &valuePtr;
        v46 = 0x2000000000;
        v47 = 0;
        v9 = *((_QWORD *)v2 + 17);
        *(_QWORD *)buf = v7;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = __SecTrustGetExceptionForCertificateAtIndex_block_invoke;
        v53 = &unk_1E1FDB430;
        v55 = &valuePtr;
        v56 = v2;
        v54 = &cf;
        dispatch_sync(v9, buf);
        v10 = (const __CFArray *)p_cf[3];
        if (!v10 || CFArrayGetCount(v10) < 1)
          goto LABEL_18;
        v11 = (const __CFArray *)p_valuePtr[3];
        if (!v11)
        {
          v19 = SecTrustCopyCertificateChain(v2);
          p_valuePtr[3] = (unint64_t)v19;
          if (!v19 || CFArrayGetCount(v19) < 1)
            goto LABEL_18;
          v11 = (const __CFArray *)p_valuePtr[3];
        }
        ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(v11, 0);
        if (ValueAtIndex)
        {
          v13 = ValueAtIndex;
          v14 = CFArrayGetValueAtIndex((CFArrayRef)p_cf[3], 0);
          v15 = CFGetTypeID(v14);
          v16 = 0;
          if (v15 != CFDictionaryGetTypeID()
            || (SHA1Digest = SecCertificateGetSHA1Digest(v13),
                (v18 = CFDictionaryGetValue((CFDictionaryRef)v14, CFSTR("SHA1Digest"))) != 0)
            && (v16 = v14, CFEqual(SHA1Digest, v18)))
          {
LABEL_19:
            v20 = p_cf[3];
            if (v20)
              CFRelease(v20);
            v21 = (const void *)p_valuePtr[3];
            if (v21)
              CFRelease(v21);
            _Block_object_dispose(&valuePtr, 8);
            _Block_object_dispose(&cf, 8);
            if (v16)
            {
              if (v4)
              {
                v22 = CFGetTypeID(v4);
                if (v22 != CFArrayGetTypeID() || CFArrayGetCount((CFArrayRef)v4) < 1)
                  goto LABEL_36;
                v23 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v4, 0);
                if (v23 && (v24 = v23, v25 = CFGetTypeID(v23), v25 == CFDictionaryGetTypeID()))
                {
                  cf = 0;
                  ExceptionResetCount = SecTrustGetExceptionResetCount(&cf);
                  v27 = secLogObjForScope("trust");
                  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
                  {
                    v39 = "Error";
                    if (!cf)
                      v39 = "OK";
                    *(_DWORD *)buf = 134218242;
                    *(_QWORD *)&buf[4] = ExceptionResetCount;
                    *(_WORD *)&buf[12] = 2082;
                    *(_QWORD *)&buf[14] = v39;
                    _os_log_debug_impl(&dword_18A900000, v27, OS_LOG_TYPE_DEBUG, "The current exceptions epoch is %llu. (%{public}s)", buf, 0x16u);
                  }
                  if (cf)
                  {
                    v28 = secLogObjForScope("SecError");
                    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_impl(&dword_18A900000, v28, OS_LOG_TYPE_DEFAULT, "Failed to get the current exceptions epoch.", buf, 2u);
                    }
                    v29 = cf;
                    if (cf)
                    {
                      cf = 0;
                      CFRelease(v29);
                    }
                    goto LABEL_36;
                  }
                  if (!ExceptionResetCount)
                    goto LABEL_50;
                  Value = (const __CFNumber *)CFDictionaryGetValue(v24, CFSTR("ExceptionResetCount"));
                  if (Value && (v36 = Value, v37 = CFGetTypeID(Value), v37 == CFNumberGetTypeID()))
                  {
                    valuePtr = 0xAAAAAAAAAAAAAAAALL;
                    if (CFNumberGetValue(v36, kCFNumberSInt64Type, &valuePtr))
                    {
                      if (valuePtr == ExceptionResetCount)
                      {
                        v38 = secLogObjForScope("trust");
                        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
                        {
                          *(_DWORD *)buf = 134217984;
                          *(_QWORD *)&buf[4] = ExceptionResetCount;
                          _os_log_debug_impl(&dword_18A900000, v38, OS_LOG_TYPE_DEBUG, "Exceptions are valid for the current exceptions epoch. (%llu)", buf, 0xCu);
                        }
LABEL_50:
                        CFRelease(v4);
                        LOBYTE(trust) = 1;
                        return (char)trust;
                      }
                      v40 = secLogObjForScope("SecError");
                      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 134218240;
                        *(_QWORD *)&buf[4] = valuePtr;
                        *(_WORD *)&buf[12] = 2048;
                        *(_QWORD *)&buf[14] = ExceptionResetCount;
                        v32 = "The current exception's epoch (%llu) is not the current epoch. (%llu)";
                        v33 = v40;
                        v34 = 22;
                        goto LABEL_42;
                      }
LABEL_36:
                      CFRelease(v4);
                      goto LABEL_37;
                    }
                    v31 = secLogObjForScope("SecError");
                    if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_36;
                    *(_WORD *)buf = 0;
                    v32 = "Failed to parse the current exceptions epoch as a uint64.";
                  }
                  else
                  {
                    v31 = secLogObjForScope("SecError");
                    if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_36;
                    *(_WORD *)buf = 0;
                    v32 = "Failed to get the exception's epoch.";
                  }
                }
                else
                {
                  v31 = secLogObjForScope("SecError");
                  if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                    goto LABEL_36;
                  *(_WORD *)buf = 0;
                  v32 = "Failed to get exception for epoch check.";
                }
                v33 = v31;
                v34 = 2;
LABEL_42:
                _os_log_impl(&dword_18A900000, v33, OS_LOG_TYPE_DEFAULT, v32, buf, v34);
                goto LABEL_36;
              }
            }
            else if (v4)
            {
              goto LABEL_36;
            }
LABEL_37:
            v30 = *((_QWORD *)v2 + 17);
            v42[0] = v7;
            v42[1] = 0x40000000;
            v42[2] = __SecTrustSetExceptions_block_invoke_2;
            v42[3] = &__block_descriptor_tmp_221;
            v42[4] = v2;
            dispatch_sync(v30, v42);
            LOBYTE(trust) = 0;
            return (char)trust;
          }
        }
LABEL_18:
        v16 = 0;
        goto LABEL_19;
      }
      CFRelease(v4);
    }
    v4 = 0;
    goto LABEL_7;
  }
  return (char)trust;
}

const __CFArray *SecTrustCopySummaryPropertiesAtIndex(__SecTrust *a1, CFIndex a2)
{
  const __CFArray *result;
  const __CFArray *v5;
  double *ValueAtIndex;
  double VerifyTime;
  CFMutableArrayRef v8;

  result = SecTrustCopyCertificateChain(a1);
  if (result)
  {
    v5 = result;
    ValueAtIndex = (double *)CFArrayGetValueAtIndex(result, a2);
    VerifyTime = SecTrustGetVerifyTime(a1);
    v8 = SecCertificateCopySummaryProperties(ValueAtIndex, VerifyTime);
    CFRelease(v5);
    return v8;
  }
  return result;
}

const __CFArray *SecTrustCopyDetailedPropertiesAtIndex(__SecTrust *a1, CFIndex a2)
{
  const __CFArray *result;
  const __CFArray *v4;
  unsigned __int8 *ValueAtIndex;
  uint64_t v6;

  result = SecTrustCopyCertificateChain(a1);
  if (result)
  {
    v4 = result;
    ValueAtIndex = (unsigned __int8 *)CFArrayGetValueAtIndex(result, a2);
    v6 = CopyProperties(ValueAtIndex, 1);
    CFRelease(v4);
    return (const __CFArray *)v6;
  }
  return result;
}

CFArrayRef SecTrustCopyProperties(SecTrustRef trust)
{
  SecTrustRef v1;
  NSObject *v2;
  const __CFArray *v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  CFMutableArrayRef Mutable;
  __int16 v9;
  const __CFString *v10;
  const void *v11;
  __int16 context;
  _QWORD block[6];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  v1 = trust;
  if (trust)
  {
    SecTrustEvaluateIfNecessary(trust);
    v15 = 0;
    v16 = &v15;
    v17 = 0x2000000000;
    v18 = 0;
    v2 = *((_QWORD *)v1 + 17);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SecTrustCopyProperties_block_invoke;
    block[3] = &unk_1E1FDAA88;
    block[4] = &v15;
    block[5] = v1;
    dispatch_sync(v2, block);
    v3 = (const __CFArray *)v16[3];
    if (!v3)
    {
      v1 = 0;
LABEL_34:
      _Block_object_dispose(&v15, 8);
      return v1;
    }
    context = 0;
    Count = CFArrayGetCount(v3);
    if (Count >= 1)
    {
      v5 = Count;
      for (i = 0; i != v5; ++i)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v16[3], i);
        CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)applyDetailProperty, &context);
      }
    }
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    v1 = Mutable;
    v9 = context;
    if ((context & 1) != 0)
    {
      v10 = CFSTR("Invalid certificate chain linkage.");
    }
    else
    {
      if ((context & 2) == 0)
      {
        if ((context & 4) != 0)
        {
          appendError(Mutable, CFSTR("Root certificate is not trusted."));
          v9 = context;
          if ((context & 8) == 0)
          {
LABEL_10:
            if ((v9 & 0x10) == 0)
              goto LABEL_11;
            goto LABEL_22;
          }
        }
        else if ((context & 8) == 0)
        {
          goto LABEL_10;
        }
        appendError(v1, CFSTR("Unable to build chain to root certificate."));
        v9 = context;
        if ((context & 0x10) == 0)
        {
LABEL_11:
          if ((v9 & 0x20) == 0)
            goto LABEL_12;
          goto LABEL_23;
        }
LABEL_22:
        appendError(v1, CFSTR("Hostname mismatch."));
        v9 = context;
        if ((context & 0x20) == 0)
        {
LABEL_12:
          if ((v9 & 0x40) == 0)
            goto LABEL_13;
          goto LABEL_24;
        }
LABEL_23:
        appendError(v1, CFSTR("Policy requirements not met."));
        v9 = context;
        if ((context & 0x40) == 0)
        {
LABEL_13:
          if ((v9 & 0x80) == 0)
            goto LABEL_14;
          goto LABEL_25;
        }
LABEL_24:
        appendError(v1, CFSTR("One or more certificates have expired or are not valid yet."));
        v9 = context;
        if ((context & 0x80) == 0)
        {
LABEL_14:
          if ((v9 & 0x100) == 0)
            goto LABEL_15;
          goto LABEL_26;
        }
LABEL_25:
        appendError(v1, CFSTR("One or more certificates is using a weak key size."));
        v9 = context;
        if ((context & 0x100) == 0)
        {
LABEL_15:
          if ((v9 & 0x200) == 0)
          {
LABEL_29:
            if (!CFArrayGetCount(v1) && v1)
            {
              CFRelease(v1);
              v1 = 0;
            }
            v11 = (const void *)v16[3];
            if (v11)
            {
              v16[3] = 0;
              CFRelease(v11);
            }
            goto LABEL_34;
          }
          goto LABEL_27;
        }
LABEL_26:
        appendError(v1, CFSTR("One or more certificates is using a weak signature algorithm."));
        if ((context & 0x200) == 0)
          goto LABEL_29;
LABEL_27:
        v10 = CFSTR("One or more certificates have been revoked.");
        goto LABEL_28;
      }
      v10 = CFSTR("One or more unsupported critical extensions found.");
    }
LABEL_28:
    appendError(v1, v10);
    goto LABEL_29;
  }
  return v1;
}

const __CFNumber *applyDetailProperty(void *key, uint64_t a2, _WORD *a3)
{
  const __CFNumber *result;
  __int16 valuePtr;

  if (applyDetailProperty_onceToken != -1)
    dispatch_once(&applyDetailProperty_onceToken, &__block_literal_global_412);
  result = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)applyDetailProperty_policyChecks, key);
  valuePtr = 0;
  if (result)
  {
    result = (const __CFNumber *)CFNumberGetValue(result, kCFNumberSInt16Type, &valuePtr);
    if (a3)
    {
      if ((_DWORD)result)
        *a3 |= valuePtr;
    }
  }
  return result;
}

void appendError(void *a1, const __CFString *a2)
{
  const __CFString *v3;

  if (a2)
  {
    v3 = SecFrameworkCopyLocalizedString(a2, CFSTR("SecCertificate"));
    appendProperty(a1, CFSTR("error"), 0, 0, v3, 1);
    if (v3)
      CFRelease(v3);
  }
}

void __applyDetailProperty_block_invoke()
{
  __CFDictionary *Mutable;
  CFNumberRef v1;
  CFNumberRef v2;
  CFNumberRef v3;
  CFNumberRef v4;
  CFNumberRef v5;
  CFNumberRef v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFNumberRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFNumberRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFNumberRef v26;
  CFNumberRef v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFNumberRef v30;
  CFNumberRef v31;
  CFNumberRef v32;
  CFNumberRef v33;
  CFNumberRef v34;
  CFNumberRef v35;
  CFNumberRef v36;
  CFNumberRef v37;
  CFNumberRef v38;
  CFNumberRef v39;
  CFNumberRef v40;
  CFNumberRef v41;
  CFNumberRef v42;
  CFNumberRef v43;
  CFNumberRef v44;
  CFNumberRef v45;
  CFNumberRef v46;
  CFNumberRef v47;
  CFNumberRef v48;
  CFNumberRef v49;
  CFNumberRef v50;
  CFNumberRef v51;
  CFNumberRef v52;
  CFNumberRef v53;
  CFNumberRef v54;
  CFNumberRef v55;
  CFNumberRef v56;
  CFNumberRef v57;
  CFNumberRef v58;
  CFNumberRef v59;
  CFNumberRef v60;
  CFNumberRef v61;
  CFNumberRef v62;
  CFNumberRef v63;
  CFNumberRef v64;
  CFNumberRef v65;
  CFNumberRef v66;
  CFNumberRef v67;
  CFNumberRef v68;
  CFNumberRef v69;
  CFNumberRef v70;
  CFNumberRef v71;
  CFNumberRef v72;
  CFNumberRef v73;
  CFNumberRef v74;
  CFNumberRef v75;
  __int16 valuePtr;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  valuePtr = 16;
  v1 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SSLHostname"), v1);
  if (v1)
    CFRelease(v1);
  valuePtr = 16;
  v2 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("Email"), v2);
  if (v2)
    CFRelease(v2);
  valuePtr = 64;
  v3 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("TemporalValidity"), v3);
  if (v3)
    CFRelease(v3);
  valuePtr = 128;
  v4 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("WeakKeySize"), v4);
  if (v4)
    CFRelease(v4);
  valuePtr = 256;
  v5 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("WeakSignature"), v5);
  if (v5)
    CFRelease(v5);
  valuePtr = 32;
  v6 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("KeyUsage"), v6);
  if (v6)
    CFRelease(v6);
  valuePtr = 32;
  v7 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("ExtendedKeyUsage"), v7);
  if (v7)
    CFRelease(v7);
  valuePtr = 32;
  v8 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SubjectCommonName"), v8);
  if (v8)
    CFRelease(v8);
  valuePtr = 32;
  v9 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SubjectCommonNamePrefix"), v9);
  if (v9)
    CFRelease(v9);
  valuePtr = 32;
  v10 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SubjectCommonNameTEST"), v10);
  if (v10)
    CFRelease(v10);
  valuePtr = 32;
  v11 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SubjectOrganization"), v11);
  if (v11)
    CFRelease(v11);
  valuePtr = 32;
  v12 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SubjectOrganizationalUnit"), v12);
  if (v12)
    CFRelease(v12);
  valuePtr = 32;
  v13 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("NotValidBefore"), v13);
  if (v13)
    CFRelease(v13);
  valuePtr = 16;
  v14 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("EAPTrustedServerNames"), v14);
  if (v14)
    CFRelease(v14);
  valuePtr = 32;
  v15 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("LeafMarkerOid"), v15);
  if (v15)
    CFRelease(v15);
  valuePtr = 32;
  v16 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("LeafMarkerOidWithoutValueCheck"), v16);
  if (v16)
    CFRelease(v16);
  valuePtr = 32;
  v17 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("LeafMarkersProdAndQA"), v17);
  if (v17)
    CFRelease(v17);
  valuePtr = 512;
  v18 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("BlackListedLeaf"), v18);
  if (v18)
    CFRelease(v18);
  valuePtr = 512;
  v19 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("GrayListedLeaf"), v19);
  if (v19)
    CFRelease(v19);
  valuePtr = 32;
  v20 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("LeafSPKISHA256"), v20);
  if (v20)
    CFRelease(v20);
  valuePtr = 32;
  v21 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("NotCA"), v21);
  if (v21)
    CFRelease(v21);
  valuePtr = 32;
  v22 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("MarkRepresentation"), v22);
  if (v22)
    CFRelease(v22);
  valuePtr = 32;
  v23 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("IssuerCommonName"), v23);
  if (v23)
    CFRelease(v23);
  valuePtr = 32;
  v24 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("IssuerCommonNamePrefix"), v24);
  if (v24)
    CFRelease(v24);
  valuePtr = 64;
  v25 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("BasicConstraints"), v25);
  if (v25)
    CFRelease(v25);
  valuePtr = 64;
  v26 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("BasicConstraintsCA"), v26);
  if (v26)
    CFRelease(v26);
  valuePtr = 64;
  v27 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("BasicConstraintsPathLen"), v27);
  if (v27)
    CFRelease(v27);
  valuePtr = 32;
  v28 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("IntermediateSPKISHA256"), v28);
  if (v28)
    CFRelease(v28);
  valuePtr = 32;
  v29 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("IntermediateEKU"), v29);
  if (v29)
    CFRelease(v29);
  valuePtr = 32;
  v30 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("IntermediateMarkerOid"), v30);
  if (v30)
    CFRelease(v30);
  valuePtr = 32;
  v31 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("IntermediateMarkerOidWithoutValueCheck"), v31);
  if (v31)
    CFRelease(v31);
  valuePtr = 32;
  v32 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("IntermediateOrganization"), v32);
  if (v32)
    CFRelease(v32);
  valuePtr = 32;
  v33 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("IntermediateCountry"), v33);
  if (v33)
    CFRelease(v33);
  valuePtr = 4;
  v34 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("AnchorSHA256"), v34);
  if (v34)
    CFRelease(v34);
  valuePtr = 4;
  v35 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("AnchorTrusted"), v35);
  if (v35)
    CFRelease(v35);
  valuePtr = 8;
  v36 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("MissingIntermediate"), v36);
  if (v36)
    CFRelease(v36);
  valuePtr = 4;
  v37 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("AnchorApple"), v37);
  if (v37)
    CFRelease(v37);
  valuePtr = 32;
  v38 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("CAspkiSHA256"), v38);
  if (v38)
    CFRelease(v38);
  valuePtr = 64;
  v39 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("NonEmptySubject"), v39);
  if (v39)
    CFRelease(v39);
  valuePtr = 1;
  v40 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("IdLinkage"), v40);
  if (v40)
    CFRelease(v40);
  valuePtr = 128;
  v41 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("KeySize"), v41);
  if (v41)
    CFRelease(v41);
  valuePtr = 256;
  v42 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SignatureHashAlgorithms"), v42);
  if (v42)
    CFRelease(v42);
  valuePtr = 32;
  v43 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("CertificatePolicy"), v43);
  if (v43)
    CFRelease(v43);
  valuePtr = 64;
  v44 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("ValidRoot"), v44);
  if (v44)
    CFRelease(v44);
  valuePtr = 2;
  v45 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("CriticalExtensions"), v45);
  if (v45)
    CFRelease(v45);
  valuePtr = 32;
  v46 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("ChainLength"), v46);
  if (v46)
    CFRelease(v46);
  valuePtr = 64;
  v47 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("BasicCertificateProcessing"), v47);
  if (v47)
    CFRelease(v47);
  valuePtr = 64;
  v48 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("NameConstraints"), v48);
  if (v48)
    CFRelease(v48);
  valuePtr = 64;
  v49 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("PolicyConstraints"), v49);
  if (v49)
    CFRelease(v49);
  valuePtr = 512;
  v50 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("GrayListedKey"), v50);
  if (v50)
    CFRelease(v50);
  valuePtr = 512;
  v51 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("BlackListedKey"), v51);
  if (v51)
    CFRelease(v51);
  valuePtr = 4;
  v52 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("UsageConstraints"), v52);
  if (v52)
    CFRelease(v52);
  valuePtr = 256;
  v53 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SystemTrustedWeakHash"), v53);
  if (v53)
    CFRelease(v53);
  valuePtr = 128;
  v54 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SystemTrustedWeakKey"), v54);
  if (v54)
    CFRelease(v54);
  valuePtr = 32;
  v55 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("PinningRequired"), v55);
  if (v55)
    CFRelease(v55);
  valuePtr = 512;
  v56 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("Revocation"), v56);
  if (v56)
    CFRelease(v56);
  valuePtr = 32;
  v57 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("RevocationResponseRequired"), v57);
  if (v57)
    CFRelease(v57);
  valuePtr = 32;
  v58 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("CTRequired"), v58);
  if (v58)
    CFRelease(v58);
  valuePtr = 32;
  v59 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SystemTrustedCTRequired"), v59);
  if (v59)
    CFRelease(v59);
  valuePtr = 512;
  v60 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("IssuerPolicyConstraints"), v60);
  if (v60)
    CFRelease(v60);
  valuePtr = 512;
  v61 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("IssuerNameConstraints"), v61);
  if (v61)
    CFRelease(v61);
  valuePtr = 32;
  v62 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("ValidityPeriodMaximums"), v62);
  if (v62)
    CFRelease(v62);
  valuePtr = 32;
  v63 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SystemTrustValidityPeriod"), v63);
  if (v63)
    CFRelease(v63);
  valuePtr = 32;
  v64 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("OtherTrustValidityPeriod"), v64);
  if (v64)
    CFRelease(v64);
  valuePtr = 32;
  v65 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("ServerAuthEKU"), v65);
  if (v65)
    CFRelease(v65);
  valuePtr = 32;
  v66 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("EmailProtectionEKU"), v66);
  if (v66)
    CFRelease(v66);
  valuePtr = 32;
  v67 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("SinglePurposeChainEKU"), v67);
  if (v67)
    CFRelease(v67);
  valuePtr = 64;
  v68 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("UnparseableExtension"), v68);
  if (v68)
    CFRelease(v68);
  valuePtr = 32;
  v69 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("NonTlsCTRequired"), v69);
  if (v69)
    CFRelease(v69);
  valuePtr = 64;
  v70 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("DuplicateExtension"), v70);
  if (v70)
    CFRelease(v70);
  valuePtr = 32;
  v71 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("NoNetworkAccess"), v71);
  if (v71)
    CFRelease(v71);
  valuePtr = 32;
  v72 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("ExtendedValidation"), v72);
  if (v72)
    CFRelease(v72);
  valuePtr = 32;
  v73 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("RevocationOnline"), v73);
  if (v73)
    CFRelease(v73);
  valuePtr = 32;
  v74 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("RevocationIfTrusted"), v74);
  if (v74)
    CFRelease(v74);
  valuePtr = 32;
  v75 = CFNumberCreate(0, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(Mutable, CFSTR("RevocationDbIgnored"), v75);
  if (v75)
    CFRelease(v75);
  applyDetailProperty_policyChecks = (uint64_t)Mutable;
}

CFDictionaryRef SecTrustCopyResult(SecTrustRef trust)
{
  SecTrustRef v1;
  NSObject *v2;
  uint64_t v3;
  unint64_t v4;
  NSObject *v5;
  _QWORD v7[7];
  _QWORD v8[3];
  unint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  CFMutableDictionaryRef Mutable;
  _QWORD block[6];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  v1 = trust;
  if (trust)
  {
    v10 = 0;
    v11 = &v10;
    v12 = 0x2000000000;
    Mutable = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    SecTrustEvaluateIfNecessary(v1);
    v8[0] = 0;
    v8[1] = v8;
    v8[2] = 0x2000000000;
    v9 = 0xAAAAAAAAAAAAAAAALL;
    v15 = 0;
    v16 = &v15;
    v17 = 0x2000000000;
    v18 = 0;
    v2 = *((_QWORD *)v1 + 17);
    v3 = MEMORY[0x1E0C809B0];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SecTrustCopyDetails_block_invoke;
    block[3] = &unk_1E1FDB4A0;
    block[4] = &v15;
    block[5] = v1;
    dispatch_sync(v2, block);
    v4 = v16[3];
    _Block_object_dispose(&v15, 8);
    v9 = v4;
    v5 = *((_QWORD *)v1 + 17);
    v7[0] = v3;
    v7[1] = 0x40000000;
    v7[2] = __SecTrustCopyResult_block_invoke;
    v7[3] = &unk_1E1FDAAB0;
    v7[4] = v8;
    v7[5] = &v10;
    v7[6] = v1;
    dispatch_sync(v5, v7);
    v1 = (SecTrustRef)v11[3];
    _Block_object_dispose(v8, 8);
    _Block_object_dispose(&v10, 8);
  }
  return v1;
}

uint64_t SecTrustCopyTrustStoreContentDigest(CFTypeRef *a1)
{
  uint64_t (*v2)(CFTypeRef *);
  uint64_t v3;
  NSObject *v4;
  _QWORD v6[5];
  os_activity_scope_state_s state;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  if (gTrustd && (v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 56)) != 0)
  {
    v3 = v2(a1);
  }
  else
  {
    v4 = _os_activity_create(&dword_18A900000, "SecTrustCopyTrustStoreContentDigest", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v4, &state);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __SecTrustCopyTrustStoreContentDigest_block_invoke_2;
    v6[3] = &unk_1E1FDAB18;
    v6[4] = &v8;
    securityd_send_sync_and_do(0x86u, a1, (uint64_t)&__block_literal_global_11712, (uint64_t)v6);
    os_release(v4);
    v3 = v9[3];
    os_activity_scope_leave(&state);
  }
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t SecTrustCopyTrustStoreAssetVersion(CFTypeRef *a1)
{
  uint64_t (*v2)(CFTypeRef *);
  uint64_t v3;
  NSObject *v4;
  _QWORD v6[5];
  os_activity_scope_state_s state;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  if (gTrustd && (v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 48)) != 0)
  {
    v3 = v2(a1);
  }
  else
  {
    v4 = _os_activity_create(&dword_18A900000, "SecTrustCopyTrustStoreAssetVersion", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v4, &state);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __SecTrustCopyTrustStoreAssetVersion_block_invoke_2;
    v6[3] = &unk_1E1FDAB80;
    v6[4] = &v8;
    securityd_send_sync_and_do(0x87u, a1, (uint64_t)&__block_literal_global_250, (uint64_t)v6);
    os_release(v4);
    v3 = v9[3];
    os_activity_scope_leave(&state);
  }
  _Block_object_dispose(&v8, 8);
  return v3;
}

uint64_t SecTrustGetTrustStoreVersionNumber(CFTypeRef *a1)
{
  uint64_t (*v2)(CFTypeRef *);
  NSObject *v4;
  uint64_t v5;
  os_activity_scope_state_s v6;

  if (gTrustd)
  {
    v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 64);
    if (v2)
      return v2(a1);
  }
  v4 = _os_activity_create(&dword_18A900000, "SecTrustGetTrustStoreVersionNumber", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &v6);
  v5 = do_ota_pki_op(0x13u, a1);
  os_release(v4);
  os_activity_scope_leave(&v6);
  return v5;
}

uint64_t do_ota_pki_op(unsigned int a1, CFTypeRef *a2)
{
  xpc_object_t message;
  void *v4;
  void *v5;
  void *v6;
  uint64_t uint64;
  xpc_object_t value;

  message = securityd_create_message(a1, a2);
  if (message)
  {
    v4 = message;
    v5 = (void *)securityd_message_with_reply_sync(message, (uint64_t)a2);
    if (!v5)
    {
      uint64 = 0;
      v6 = v4;
LABEL_15:
      xpc_release(v6);
      return uint64;
    }
    v6 = v5;
    if (xpc_dictionary_get_value(v5, "status") && MEMORY[0x18D7718B8]() == MEMORY[0x1E0C81398])
    {
      uint64 = xpc_dictionary_get_uint64(v6, "status");
      if (!a2)
      {
LABEL_14:
        xpc_release(v4);
        goto LABEL_15;
      }
    }
    else
    {
      uint64 = 0;
      if (!a2)
        goto LABEL_14;
    }
    if (xpc_dictionary_get_value(v6, "error"))
    {
      if (MEMORY[0x18D7718B8]() == MEMORY[0x1E0C812F8])
      {
        value = xpc_dictionary_get_value(v6, "error");
        if (value)
          *a2 = SecCreateCFErrorWithXPCObject(value);
      }
    }
    goto LABEL_14;
  }
  return 0;
}

uint64_t SecTrustGetAssetVersionNumber(CFTypeRef *a1)
{
  uint64_t (*v2)(CFTypeRef *);
  NSObject *v4;
  uint64_t v5;
  os_activity_scope_state_s v6;

  if (gTrustd)
  {
    v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 72);
    if (v2)
      return v2(a1);
  }
  v4 = _os_activity_create(&dword_18A900000, "SecTrustGetAssetVersionNumber", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &v6);
  v5 = do_ota_pki_op(0x14u, a1);
  os_release(v4);
  os_activity_scope_leave(&v6);
  return v5;
}

uint64_t SecTrustOTAPKIGetUpdatedAsset(CFTypeRef *a1)
{
  uint64_t (*v2)(CFTypeRef *);
  NSObject *v4;
  uint64_t v5;
  os_activity_scope_state_s v6;

  if (gTrustd)
  {
    v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 80);
    if (v2)
      return v2(a1);
  }
  v4 = _os_activity_create(&dword_18A900000, "SecTrustOTAPKIGetUpdatedAsset", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &v6);
  v5 = do_ota_pki_op(0x17u, a1);
  os_release(v4);
  os_activity_scope_leave(&v6);
  return v5;
}

uint64_t SecTrustOTASecExperimentGetUpdatedAsset(CFTypeRef *a1)
{
  uint64_t (*v2)(CFTypeRef *);
  NSObject *v4;
  uint64_t v5;
  os_activity_scope_state_s v6;

  if (gTrustd)
  {
    v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 88);
    if (v2)
      return v2(a1);
  }
  v4 = _os_activity_create(&dword_18A900000, "SecTrustOTASecExperimentGetUpdatedAsset", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &v6);
  v5 = do_ota_pki_op(0x77u, a1);
  os_release(v4);
  os_activity_scope_leave(&v6);
  return v5;
}

uint64_t SecTrustOTASecExperimentCopyAsset(CFTypeRef *a1)
{
  uint64_t (*v1)(CFTypeRef *);
  uint64_t v2;
  _QWORD v4[5];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  if (gTrustd && (v1 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 96)) != 0)
  {
    v2 = v1(a1);
  }
  else
  {
    v4[0] = MEMORY[0x1E0C809B0];
    v4[1] = 0x40000000;
    v4[2] = __SecTrustOTASecExperimentCopyAsset_block_invoke_2;
    v4[3] = &unk_1E1FDABE8;
    v4[4] = &v5;
    securityd_send_sync_and_do(0x76u, a1, (uint64_t)&__block_literal_global_255, (uint64_t)v4);
    v2 = v6[3];
  }
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t SecTrustTriggerValidUpdate(CFTypeRef *a1)
{
  uint64_t (*v2)(CFTypeRef *);
  NSObject *v4;
  uint64_t v5;
  os_activity_scope_state_s v6;

  if (gTrustd)
  {
    v2 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 200);
    if (v2)
      return v2(a1);
  }
  v4 = _os_activity_create(&dword_18A900000, "SecTrustTriggerValidUpdate", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v6.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v6.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &v6);
  v5 = do_ota_pki_op(0x7Cu, a1);
  os_release(v4);
  os_activity_scope_leave(&v6);
  return v5 != 0;
}

uint64_t SecTrustReportTLSAnalytics(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  _BOOL8 v3;
  uint64_t (*v7)(uint64_t, uint64_t, CFTypeRef *);
  NSObject *v9;
  _QWORD v10[5];
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;
  os_activity_scope_state_s state;

  v3 = 0;
  if (a1 && a2)
  {
    if (gTrustd)
    {
      v7 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef *))(gTrustd + 144);
      if (v7)
        return v7(a1, a2, a3);
    }
    v9 = _os_activity_create(&dword_18A900000, "SecTrustReportTLSAnalytics", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
    state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
    state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
    os_activity_scope_enter(v9, &state);
    v12 = 0;
    v13 = &v12;
    v14 = 0x2000000000;
    v15 = 0;
    v10[4] = &v12;
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 0x40000000;
    v11[2] = __SecTrustReportTLSAnalytics_block_invoke;
    v11[3] = &__block_descriptor_tmp_261;
    v11[4] = a1;
    v11[5] = a2;
    v10[0] = MEMORY[0x1E0C809B0];
    v10[1] = 0x40000000;
    v10[2] = __SecTrustReportTLSAnalytics_block_invoke_2;
    v10[3] = &unk_1E1FDAC30;
    securityd_send_sync_and_do(0x73u, a3, (uint64_t)v11, (uint64_t)v10);
    os_release(v9);
    v3 = *((_BYTE *)v13 + 24) != 0;
    _Block_object_dispose(&v12, 8);
    os_activity_scope_leave(&state);
  }
  return v3;
}

uint64_t SecTrustEvaluateLeafOnly(__SecTrust *a1, int *a2)
{
  uint64_t result;
  NSObject *v5;
  uint64_t v6;
  const void *v7;
  const void *v8;
  CFAbsoluteTime VerifyTime;
  const __CFAllocator *v10;
  const CFDictionaryKeyCallBacks *v11;
  __CFDictionary *Mutable;
  BOOL v13;
  CFIndex Count;
  CFIndex v15;
  CFIndex i;
  CFDictionaryRef *ValueAtIndex;
  BOOL v18;
  int v19;
  double v20;
  double v21;
  double Current;
  CFDateRef v24;
  CFDateRef v25;
  NSObject *v26;
  const void *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  __CFString *v31;
  NSObject *v32;
  const void *v33;
  const void *v34;
  _QWORD v35[5];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  CFDateRef v40;
  CFDateRef v41;
  int v42;
  _QWORD block[7];
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  __int128 context;
  __int128 v53;
  _OWORD v54[2];
  _BYTE values[24];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 4294967246;
  result = SecTrustValidateInput(a1);
  if (!(_DWORD)result)
  {
    context = xmmword_18AA5F478;
    v53 = unk_18AA5F488;
    memset(v54, 170, sizeof(v54));
    v48 = 0;
    v49 = &v48;
    v50 = 0x2000000000;
    v51 = 0;
    v44 = 0;
    v45 = &v44;
    v46 = 0x2000000000;
    v47 = 0;
    v5 = *((_QWORD *)a1 + 17);
    v6 = MEMORY[0x1E0C809B0];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SecTrustEvaluateLeafOnly_block_invoke;
    block[3] = &unk_1E1FDACA0;
    block[5] = &v44;
    block[6] = a1;
    block[4] = &v48;
    dispatch_sync(v5, block);
    v7 = (const void *)v49[3];
    v8 = (const void *)v45[3];
    VerifyTime = SecTrustGetVerifyTime(a1);
    if (v7)
      CFRetain(v7);
    *(_QWORD *)&context = v7;
    if (v8)
      CFRetain(v8);
    *((_QWORD *)&context + 1) = v8;
    *(CFAbsoluteTime *)&v53 = VerifyTime;
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v11 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], 0);
    CFDictionaryAddValue(Mutable, CFSTR("SSLHostname"), SecPolicyCheckCertSSLHostname);
    CFDictionaryAddValue(Mutable, CFSTR("Email"), SecPolicyCheckCertEmail);
    CFDictionaryAddValue(Mutable, CFSTR("TemporalValidity"), SecPolicyCheckCertTemporalValidity);
    CFDictionaryAddValue(Mutable, CFSTR("WeakKeySize"), SecPolicyCheckCertWeakKeySize);
    CFDictionaryAddValue(Mutable, CFSTR("WeakSignature"), SecPolicyCheckCertWeakSignature);
    CFDictionaryAddValue(Mutable, CFSTR("KeyUsage"), SecPolicyCheckCertKeyUsage);
    CFDictionaryAddValue(Mutable, CFSTR("ExtendedKeyUsage"), SecPolicyCheckCertExtendedKeyUsage);
    CFDictionaryAddValue(Mutable, CFSTR("SubjectCommonName"), SecPolicyCheckCertSubjectCommonName);
    CFDictionaryAddValue(Mutable, CFSTR("SubjectCommonNamePrefix"), SecPolicyCheckCertSubjectCommonNamePrefix);
    CFDictionaryAddValue(Mutable, CFSTR("SubjectCommonNameTEST"), SecPolicyCheckCertSubjectCommonNameTEST);
    CFDictionaryAddValue(Mutable, CFSTR("SubjectOrganization"), SecPolicyCheckCertSubjectOrganization);
    CFDictionaryAddValue(Mutable, CFSTR("SubjectOrganizationalUnit"), SecPolicyCheckCertSubjectOrganizationalUnit);
    CFDictionaryAddValue(Mutable, CFSTR("NotValidBefore"), SecPolicyCheckCertNotValidBefore);
    CFDictionaryAddValue(Mutable, CFSTR("EAPTrustedServerNames"), SecPolicyCheckCertEAPTrustedServerNames);
    CFDictionaryAddValue(Mutable, CFSTR("LeafMarkerOid"), SecPolicyCheckCertLeafMarkerOid);
    CFDictionaryAddValue(Mutable, CFSTR("LeafMarkerOidWithoutValueCheck"), SecPolicyCheckCertLeafMarkerOidWithoutValueCheck);
    CFDictionaryAddValue(Mutable, CFSTR("LeafMarkersProdAndQA"), SecPolicyCheckCertLeafMarkersProdAndQA);
    CFDictionaryAddValue(Mutable, CFSTR("NotCA"), SecPolicyCheckCertNotCA);
    CFDictionaryAddValue(Mutable, CFSTR("NonEmptySubject"), SecPolicyCheckCertNonEmptySubject);
    CFDictionaryAddValue(Mutable, CFSTR("KeySize"), SecPolicyCheckCertKeySize);
    CFDictionaryAddValue(Mutable, CFSTR("SignatureHashAlgorithms"), SecPolicyCheckCertSignatureHashAlgorithms);
    CFDictionaryAddValue(Mutable, CFSTR("CertificatePolicy"), SecPolicyCheckCertCertificatePolicy);
    CFDictionaryAddValue(Mutable, CFSTR("CriticalExtensions"), SecPolicyCheckCertCriticalExtensions);
    CFDictionaryAddValue(Mutable, CFSTR("UnparseableExtension"), SecPolicyCheckCertUnparseableExtension);
    CFDictionaryAddValue(Mutable, CFSTR("DuplicateExtension"), SecPolicyCheckCertDuplicateExtension);
    *((_QWORD *)&v54[0] + 1) = Mutable;
    *(_QWORD *)&v54[1] = 0;
    *(_QWORD *)values = CFDictionaryCreateMutable(v10, 0, v11, MEMORY[0x1E0C9B3A0]);
    v13 = 1;
    *((_QWORD *)&v53 + 1) = CFArrayCreate(v10, (const void **)values, 1, MEMORY[0x1E0C9B378]);
    CFRelease(*(CFTypeRef *)values);
    BYTE8(v54[1]) = 1;
    Count = CFArrayGetCount((CFArrayRef)v8);
    if (Count < 1)
    {
      v19 = 4;
    }
    else
    {
      v15 = Count;
      for (i = 0; i != v15; ++i)
      {
        ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex((CFArrayRef)v8, i);
        *(_QWORD *)&v54[1] = i;
        CFDictionaryApplyFunction(ValueAtIndex[4], (CFDictionaryApplierFunction)SecLeafPVCValidateKey, &context);
        if (BYTE8(v54[1]))
          v18 = 0;
        else
          v18 = *((_QWORD *)&v53 + 1) == 0;
        if (v18)
        {
          v13 = 0;
          v19 = 5;
          goto LABEL_20;
        }
      }
      v13 = BYTE8(v54[1]) != 0;
      if (BYTE8(v54[1]))
        v19 = 4;
      else
        v19 = 5;
    }
LABEL_20:
    v20 = SecTrustGetVerifyTime(a1);
    v21 = *(double *)(v49[3] + 176);
    Current = CFAbsoluteTimeGetCurrent();
    if (v21 >= v20 + 4500.0 || v21 <= Current)
      v21 = v20 + 4500.0;
    v24 = CFDateCreate(0, v20);
    v25 = CFDateCreate(0, v21);
    v35[1] = 0x40000000;
    v36 = context;
    v37 = v53;
    v38 = v54[0];
    v39 = v54[1];
    v26 = *((_QWORD *)a1 + 17);
    v35[0] = v6;
    v35[2] = __SecTrustEvaluateLeafOnly_block_invoke_2;
    v35[3] = &__block_descriptor_tmp_266;
    v35[4] = a1;
    v42 = v19;
    v40 = v24;
    v41 = v25;
    dispatch_sync(v26, v35);
    v27 = (const void *)*((_QWORD *)&context + 1);
    if (*((_QWORD *)&context + 1))
    {
      *((_QWORD *)&context + 1) = 0;
      CFRelease(v27);
    }
    v28 = (const void *)*((_QWORD *)&v53 + 1);
    if (*((_QWORD *)&v53 + 1))
    {
      *((_QWORD *)&v53 + 1) = 0;
      CFRelease(v28);
    }
    v29 = (const void *)*((_QWORD *)&v54[0] + 1);
    if (*((_QWORD *)&v54[0] + 1))
    {
      *((_QWORD *)&v54[0] + 1) = 0;
      CFRelease(v29);
    }
    v30 = (const void *)context;
    if ((_QWORD)context)
    {
      *(_QWORD *)&context = 0;
      CFRelease(v30);
    }
    if (!v13)
    {
      v31 = SecTrustCopyFailureDescription(a1);
      v32 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)values = 138412290;
        *(_QWORD *)&values[4] = v31;
        _os_log_impl(&dword_18A900000, v32, OS_LOG_TYPE_DEFAULT, "%@", values, 0xCu);
      }
      CFRelease(v31);
    }
    if (a2)
      *a2 = v19;
    v33 = (const void *)v49[3];
    if (v33)
      CFRelease(v33);
    v34 = (const void *)v45[3];
    if (v34)
      CFRelease(v34);
    if (v24)
      CFRelease(v24);
    if (v25)
      CFRelease(v25);
    _Block_object_dispose(&v44, 8);
    _Block_object_dispose(&v48, 8);
    return 0;
  }
  return result;
}

uint64_t SecTrustIncrementExceptionResetCount(CFTypeRef *a1)
{
  NSObject *v2;
  uint64_t (*v3)(CFTypeRef *);
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  os_activity_scope_state_s v9;
  uint8_t buf[8];
  uint64_t v11;
  uint64_t (*v12)(uint64_t, uint64_t, _QWORD *);
  void *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char v18;

  v2 = _os_activity_create(&dword_18A900000, "SecTrustIncrementExceptionResetCount", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  v9.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  v9.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &v9);
  if (gTrustd && (v3 = *(uint64_t (**)(CFTypeRef *))(gTrustd + 168)) != 0)
  {
    v4 = v3(a1);
  }
  else
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2000000000;
    v18 = 0;
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    v11 = 0x40000000;
    v12 = __to_BOOL_error_request_block_invoke;
    v13 = &unk_1E1FDB518;
    v14 = &v15;
    securityd_send_sync_and_do(0x79u, a1, 0, (uint64_t)buf);
    v4 = *((_BYTE *)v16 + 24) != 0;
    _Block_object_dispose(&v15, 8);
  }
  os_release(v2);
  if (a1)
  {
    if (*a1)
      v5 = 0;
    else
      v5 = v4;
    if ((v5 & 1) != 0)
      goto LABEL_10;
  }
  else if ((v4 & 1) != 0)
  {
LABEL_10:
    v6 = 0;
    goto LABEL_15;
  }
  v7 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "Failed to increment the exceptions epoch.", buf, 2u);
  }
  v6 = 4294941020;
LABEL_15:
  os_activity_scope_leave(&v9);
  return v6;
}

uint64_t SecTrustGetAppleAnchors()
{
  _QWORD block[4];
  char v2;

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecGetAppleTrustAnchors_block_invoke;
  block[3] = &__block_descriptor_tmp_1_13104;
  v2 = 0;
  if (SecGetAppleTrustAnchors_onceToken != -1)
    dispatch_once(&SecGetAppleTrustAnchors_onceToken, block);
  return SecGetAppleTrustAnchors_anchors;
}

const __CFString *SecTrustStoreDomainName(CFTypeRef cf)
{
  CFTypeRef v1;
  const __CFString *v2;
  CFTypeID v3;

  v1 = cf;
  if (cf)
  {
    if (gTrustd)
    {
      v2 = CFSTR("user");
      if ((CFTypeRef)(*(uint64_t (**)(const __CFString *, _QWORD))gTrustd)(CFSTR("user"), 0) == cf)
        return v2;
      v2 = CFSTR("admin");
      if ((CFTypeRef)(*(uint64_t (**)(const __CFString *, _QWORD))gTrustd)(CFSTR("admin"), 0) == v1)
        return v2;
      v2 = CFSTR("system");
      if ((CFTypeRef)(*(uint64_t (**)(const __CFString *, _QWORD))gTrustd)(CFSTR("system"), 0) == v1)
        return v2;
    }
    else
    {
      v3 = CFGetTypeID(cf);
      if (v3 == CFStringGetTypeID())
        return (const __CFString *)v1;
    }
    return 0;
  }
  return (const __CFString *)v1;
}

__CFString *SecTrustSettingsDomainName(unsigned int a1)
{
  if (a1 > 2)
    return 0;
  else
    return off_1E1FDB9F8[a1];
}

uint64_t SecTrustSettingsDomainForName(CFTypeRef cf2)
{
  if (!cf2)
    return 0xFFFFFFFFLL;
  if (CFEqual(CFSTR("user"), cf2))
    return 0;
  if (CFEqual(CFSTR("admin"), cf2))
    return 1;
  if (CFEqual(CFSTR("system"), cf2))
    return 2;
  return 0xFFFFFFFFLL;
}

BOOL SecXPCDictionarySetCertificate(void *a1, uint64_t a2, __CFString **a3)
{
  int64_t v3;

  if (!a2)
    return SecError(-50, a3, CFSTR("NULL certificate"));
  v3 = *(_QWORD *)(a2 + 24);
  if (v3 < 1)
    return SecError(-50, a3, CFSTR("NULL certificate"));
  xpc_dictionary_set_data(a1, "cert", *(const void **)(a2 + 16), v3);
  return 1;
}

uint64_t SecTrustStoreSetTrustSettings(uint64_t a1, _QWORD *a2, const __CFArray *a3)
{
  _BOOL8 IsSelfSigned;
  int v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  NSObject *v12;
  int v13;
  __CFArray *v14;
  uint64_t v15;
  _QWORD v17[8];
  uint64_t v18;
  __CFArray **v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  int v25;
  uint8_t buf[4];
  uint64_t v27;
  __int16 v28;
  _QWORD *v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v22 = 0;
  v23 = &v22;
  v24 = 0x2000000000;
  v25 = -1431655766;
  v18 = 0;
  v19 = (__CFArray **)&v18;
  v20 = 0x2000000000;
  v21 = 0;
  if ((SecCertificateIsCertificate(a2) & 1) != 0)
  {
    IsSelfSigned = _SecCertificateIsSelfSigned((uint64_t)a2);
    *((_DWORD *)v23 + 6) = 0;
    v7 = validateTrustSettings(IsSelfSigned, a3, v19 + 3);
    *((_DWORD *)v23 + 6) = v7;
    if (!v7)
    {
      v17[0] = MEMORY[0x1E0C809B0];
      v17[1] = 0x40000000;
      v17[2] = __SecTrustStoreSetTrustSettings_block_invoke;
      v17[3] = &unk_1E1FDB5D8;
      v17[6] = a1;
      v17[7] = a2;
      v17[4] = &v22;
      v17[5] = &v18;
      _os_activity_initiate(&dword_18A900000, "SecTrustStoreSetTrustSettings", OS_ACTIVITY_FLAG_DEFAULT, v17);
      if (!*((_DWORD *)v23 + 6))
      {
        v8 = secLogObjForScope("truststore");
        if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          goto LABEL_10;
        *(_DWORD *)buf = 141558274;
        v27 = 1752392040;
        v28 = 2112;
        v29 = a2;
        v9 = "Set TrustSettings for %{mask.hash}@";
        v10 = v8;
        v11 = 22;
        goto LABEL_9;
      }
    }
  }
  else
  {
    *((_DWORD *)v23 + 6) = -26275;
  }
  v12 = secLogObjForScope("SecError");
  if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    goto LABEL_10;
  v13 = *((_DWORD *)v23 + 6);
  *(_DWORD *)buf = 141558530;
  v27 = 1752392040;
  v28 = 2112;
  v29 = a2;
  v30 = 1024;
  v31 = v13;
  v9 = "Failed set trust settings for %{mask.hash}@, %d";
  v10 = v12;
  v11 = 28;
LABEL_9:
  _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
LABEL_10:
  v14 = v19[3];
  if (v14)
  {
    v19[3] = 0;
    CFRelease(v14);
  }
  v15 = *((unsigned int *)v23 + 6);
  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v22, 8);
  return v15;
}

uint64_t validateTrustSettings(uint64_t a1, const __CFArray *a2, __CFArray **a3)
{
  uint64_t v6;
  CFTypeID TypeID;
  __CFArray *MutableCopy;
  const void *v9;
  const void *v10;
  CFTypeID v11;
  CFTypeID v12;
  CFTypeID v13;
  CFTypeID v14;
  CFMutableArrayRef Mutable;
  CFIndex Count;
  CFIndex v17;
  CFIndex v18;
  const void *ValueAtIndex;
  uint64_t v20;
  void *v21;
  const void *v22;
  const void *v23;
  void *value;
  int valuePtr;

  if ((_DWORD)a1 && !a2)
    return 0;
  if (!(_DWORD)a1 && !a2)
    return 4294967246;
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a2))
  {
    v14 = CFArrayGetTypeID();
    if (v14 == CFGetTypeID(a2))
    {
      Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
      if (!Mutable)
        return 4294967188;
      MutableCopy = Mutable;
      Count = CFArrayGetCount(a2);
      if (Count < 1)
      {
        v6 = 4294967246;
      }
      else
      {
        v17 = Count;
        v18 = 0;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a2, v18);
          value = 0;
          v20 = validateTrustSettings(a1, ValueAtIndex, &value);
          if ((_DWORD)v20)
            break;
          CFArrayAppendValue(MutableCopy, value);
          v21 = value;
          if (value)
          {
            value = 0;
            CFRelease(v21);
          }
          if (v17 == ++v18)
            goto LABEL_31;
        }
        v6 = v20;
      }
      goto LABEL_38;
    }
    return 4294967246;
  }
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a2);
  v9 = CFDictionaryGetValue(MutableCopy, CFSTR("kSecTrustSettingsResult"));
  valuePtr = 0;
  if (v9)
  {
    v10 = v9;
    v11 = CFGetTypeID(v9);
    v12 = CFNumberGetTypeID();
    if (!(_DWORD)a1 && v11 != v12)
      goto LABEL_16;
    v13 = CFGetTypeID(v10);
    if (v13 == CFNumberGetTypeID()
      && CFNumberGetValue((CFNumberRef)v10, kCFNumberSInt32Type, &valuePtr)
      && ((_DWORD)a1 && valuePtr == 2 || !(_DWORD)a1 && valuePtr == 1))
    {
      goto LABEL_16;
    }
  }
  else if (!(_DWORD)a1)
  {
LABEL_16:
    v6 = 4294967246;
    goto LABEL_32;
  }
  v22 = CFDictionaryGetValue(MutableCopy, CFSTR("kSecTrustSettingsPolicy"));
  if (v22)
  {
    v23 = (const void *)*((_QWORD *)v22 + 3);
    CFDictionarySetValue(MutableCopy, CFSTR("kSecTrustSettingsPolicy"), *((const void **)v22 + 2));
    if (v23)
      CFDictionaryAddValue(MutableCopy, CFSTR("kSecTrustSettingsPolicyName"), v23);
  }
LABEL_31:
  v6 = 0;
LABEL_32:
  if (a3 && !(_DWORD)v6)
  {
    if (MutableCopy)
      CFRetain(MutableCopy);
    v6 = 0;
    *a3 = MutableCopy;
  }
  if (MutableCopy)
LABEL_38:
    CFRelease(MutableCopy);
  return v6;
}

size_t __string_cert_cftype_to_error_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  size_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const __CFString *v11;

  result = SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
  if ((_DWORD)result)
  {
    result = SecXPCDictionarySetCertificate(a2, *(_QWORD *)(a1 + 40), a3);
    if ((_DWORD)result)
    {
      v11 = *(const __CFString **)(a1 + 48);
      if (v11)
        return SecXPCDictionarySetPListWithRepair(a2, "settings", v11, a3, v7, v8, v9, v10);
      else
        return 1;
    }
  }
  return result;
}

uint64_t SecTrustStoreRemoveCertificate(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD v9[6];
  os_activity_scope_state_s state;
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = _os_activity_create(&dword_18A900000, "SecTrustStoreRemoveCertificate", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  if (!a1)
  {
    v5 = 4294967246;
LABEL_3:
    v6 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 141558530;
      v12 = 1752392040;
      v13 = 2112;
      v14 = a2;
      v15 = 1024;
      v16 = v5;
      _os_log_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEFAULT, "Failed to remove trust settings for %{mask.hash}@, %d", buf, 0x1Cu);
    }
    goto LABEL_7;
  }
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __SecTrustStoreRemoveCertificate_block_invoke;
  v9[3] = &__block_descriptor_tmp_8_11788;
  v9[4] = a1;
  v9[5] = a2;
  v5 = SecOSStatusWith((uint64_t)v9);
  if ((_DWORD)v5)
    goto LABEL_3;
  v7 = secLogObjForScope("truststore");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 141558274;
    v12 = 1752392040;
    v13 = 2112;
    v14 = a2;
    _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "Removed TrustSettings for %{mask.hash}@", buf, 0x16u);
    v5 = 0;
  }
LABEL_7:
  os_release(v4);
  os_activity_scope_leave(&state);
  return v5;
}

uint64_t SecTrustStoreGetSettingsVersionNumber(_DWORD *a1)
{
  CFIndex Code;
  CFErrorRef err;

  if (!a1)
    return 4294967246;
  err = 0;
  *a1 = SecTrustGetTrustStoreVersionNumber((CFTypeRef *)&err);
  if (!err)
    return 0;
  Code = CFErrorGetCode(err);
  if (err)
    CFRelease(err);
  return Code;
}

uint64_t SecTrustStoreGetSettingsAssetVersionNumber(_DWORD *a1)
{
  CFIndex Code;
  CFErrorRef err;

  if (!a1)
    return 4294967246;
  err = 0;
  *a1 = SecTrustGetAssetVersionNumber((CFTypeRef *)&err);
  if (!err)
    return 0;
  Code = CFErrorGetCode(err);
  if (err)
    CFRelease(err);
  return Code;
}

uint64_t SecTrustStoreCopyAll(uint64_t a1, _QWORD *a2)
{
  NSObject *v4;
  uint64_t v5;
  _QWORD v7[6];
  os_activity_scope_state_s state;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  v4 = _os_activity_create(&dword_18A900000, "SecTrustStoreCopyAll", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v4, &state);
  if (a1)
  {
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = __SecTrustStoreCopyAll_block_invoke;
    v7[3] = &unk_1E1FDB620;
    v7[4] = &v9;
    v7[5] = a1;
    v5 = SecOSStatusWith((uint64_t)v7);
    *a2 = v10[3];
  }
  else
  {
    v5 = 4294967246;
  }
  os_release(v4);
  os_activity_scope_leave(&state);
  _Block_object_dispose(&v9, 8);
  return v5;
}

BOOL __string_to_array_error_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
}

BOOL __string_to_array_error_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  _BOOL8 result;

  result = 1;
  if (*(_QWORD *)(a1 + 32))
  {
    **(_QWORD **)(a1 + 32) = SecXPCDictionaryCopyArray(a2, "status", a3);
    if (!**(_QWORD **)(a1 + 32))
      return 0;
  }
  return result;
}

uint64_t SecTrustStoreCopyUsageConstraints(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t *v8;
  NSObject *v9;
  const __CFArray *v10;
  CFIndex Count;
  NSObject *v12;
  _BOOL4 v13;
  const char *v14;
  NSObject *v15;
  NSObject *v16;
  _QWORD v18[7];
  os_activity_scope_state_s state;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v20 = 0;
  v21 = &v20;
  v22 = 0x2000000000;
  v23 = 0;
  v6 = _os_activity_create(&dword_18A900000, "SecTrustStoreCopyUsageConstraints", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  v7 = 4294967246;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        v18[0] = MEMORY[0x1E0C809B0];
        v18[1] = 0x40000000;
        v18[2] = __SecTrustStoreCopyUsageConstraints_block_invoke;
        v18[3] = &unk_1E1FDB648;
        v18[5] = a1;
        v18[6] = a2;
        v18[4] = &v20;
        v7 = SecOSStatusWith((uint64_t)v18);
        v8 = v21;
        *a3 = v21[3];
        if (!(_DWORD)v7)
        {
          v10 = (const __CFArray *)v8[3];
          if (!v10)
          {
            v15 = secLogObjForScope("truststore");
            v7 = 0;
            if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              goto LABEL_18;
            *(_DWORD *)buf = 141558274;
            v25 = 1752392040;
            v26 = 2112;
            v27 = a2;
            v14 = "Found no trust settings for %{mask.hash}@";
            v16 = v15;
            goto LABEL_16;
          }
          Count = CFArrayGetCount(v10);
          v12 = secLogObjForScope("truststore");
          v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
          if (Count)
          {
            if (v13)
            {
              *(_DWORD *)buf = 141558274;
              v25 = 1752392040;
              v26 = 2112;
              v27 = a2;
              v14 = "Found usage constraints for %{mask.hash}@";
LABEL_15:
              v16 = v12;
LABEL_16:
              _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEFAULT, v14, buf, 0x16u);
            }
          }
          else if (v13)
          {
            *(_DWORD *)buf = 141558274;
            v25 = 1752392040;
            v26 = 2112;
            v27 = a2;
            v14 = "Found no usage constraints for %{mask.hash}@";
            goto LABEL_15;
          }
          v7 = 0;
          goto LABEL_18;
        }
      }
    }
  }
  v9 = secLogObjForScope("SecError");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 141558530;
    v25 = 1752392040;
    v26 = 2112;
    v27 = a2;
    v28 = 1024;
    v29 = v7;
    _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "Failed to get usage contraints for %{mask.hash}@, %d", buf, 0x1Cu);
  }
LABEL_18:
  os_release(v6);
  os_activity_scope_leave(&state);
  _Block_object_dispose(&v20, 8);
  return v7;
}

BOOL __string_cert_to_array_error_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  _BOOL8 result;

  result = SecXPCDictionarySetString((uint64_t)a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
  if ((_DWORD)result)
    return SecXPCDictionarySetCertificate(a2, *(_QWORD *)(a1 + 40), a3);
  return result;
}

BOOL __string_cert_to_array_error_block_invoke_2(uint64_t a1, void *a2, __CFString **a3)
{
  return SecXPCDictionaryCopyArrayOptional(a2, "status", *(_QWORD **)(a1 + 32), a3);
}

uint64_t SecTrustStoreRemoveAll(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  _QWORD v7[5];
  os_activity_scope_state_s state;
  uint8_t buf[4];
  int v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = _os_activity_create(&dword_18A900000, "SecTrustStoreRemoveAll", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v2, &state);
  if (!a1)
  {
    v3 = 4294967246;
LABEL_3:
    v4 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v10 = v3;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "Failed to remove all trust settings, %d", buf, 8u);
    }
    goto LABEL_7;
  }
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[2] = __SecTrustStoreRemoveAll_block_invoke;
  v7[3] = &__block_descriptor_tmp_11_11805;
  v7[4] = a1;
  v3 = SecOSStatusWith((uint64_t)v7);
  if ((_DWORD)v3)
    goto LABEL_3;
  v5 = secLogObjForScope("truststore");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEFAULT, "Removed all trust settings", buf, 2u);
    v3 = 0;
  }
LABEL_7:
  os_release(v2);
  os_activity_scope_leave(&state);
  return v3;
}

BOOL __string_to_error_block_invoke(uint64_t a1, uint64_t a2, __CFString **a3)
{
  return SecXPCDictionarySetString(a2, (uint64_t)"domain", *(const __CFString **)(a1 + 32), a3);
}

uint64_t __string_to_error_block_invoke_2()
{
  return 1;
}

uint64_t SecTrustStoreSetCTExceptions(const __CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  const __CFString *v5;
  uint64_t (*v6)(const __CFString *, uint64_t, CFTypeRef *);
  NSObject *v8;
  uint64_t v9;
  _QWORD v10[5];
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;
  os_activity_scope_state_s state;

  v5 = a1;
  if (a1 && gTrustd)
  {
    v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 152);
    if (v6)
      return v6(a1, a2, a3);
  }
  else if (gTrustd)
  {
    v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 152);
    if (v6)
    {
      a1 = CFSTR("com.apple.trusttests");
      return v6(a1, a2, a3);
    }
  }
  v8 = _os_activity_create(&dword_18A900000, "SecTrustStoreSetCTExceptions", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v10[4] = &v12;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = __SecTrustStoreSetCTExceptions_block_invoke;
  v11[3] = &__block_descriptor_tmp_24_11813;
  v11[4] = a2;
  v11[5] = v5;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __SecTrustStoreSetCTExceptions_block_invoke_2;
  v10[3] = &unk_1E1FDB6E0;
  securityd_send_sync_and_do(0x74u, a3, (uint64_t)v11, (uint64_t)v10);
  os_release(v8);
  v9 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  os_activity_scope_leave(&state);
  return v9;
}

uint64_t SecTrustStoreCopyCTExceptions(uint64_t a1, CFTypeRef *a2)
{
  uint64_t (*v4)(uint64_t, CFTypeRef *);
  NSObject *v6;
  uint64_t v7;
  _QWORD v8[5];
  _QWORD v9[5];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  os_activity_scope_state_s state;

  if (gTrustd)
  {
    v4 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gTrustd + 160);
    if (v4)
      return v4(a1, a2);
  }
  v6 = _os_activity_create(&dword_18A900000, "SecTrustStoreCopyCTExceptions", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v8[4] = &v10;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __SecTrustStoreCopyCTExceptions_block_invoke;
  v9[3] = &__block_descriptor_tmp_26_11819;
  v9[4] = a1;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __SecTrustStoreCopyCTExceptions_block_invoke_2;
  v8[3] = &unk_1E1FDB728;
  securityd_send_sync_and_do(0x75u, a2, (uint64_t)v9, (uint64_t)v8);
  os_release(v6);
  v7 = v11[3];
  _Block_object_dispose(&v10, 8);
  os_activity_scope_leave(&state);
  return v7;
}

uint64_t SecTrustStoreSetCARevocationAdditions(const __CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  const __CFString *v5;
  uint64_t (*v6)(const __CFString *, uint64_t, CFTypeRef *);
  NSObject *v8;
  uint64_t v9;
  _QWORD v10[5];
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;
  os_activity_scope_state_s state;

  v5 = a1;
  if (a1 && gTrustd)
  {
    v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 184);
    if (v6)
      return v6(a1, a2, a3);
  }
  else if (gTrustd)
  {
    v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 184);
    if (v6)
    {
      a1 = CFSTR("com.apple.trusttests");
      return v6(a1, a2, a3);
    }
  }
  v8 = _os_activity_create(&dword_18A900000, "SecTrustStoreSetCARevocationAdditions", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v10[4] = &v12;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = __SecTrustStoreSetCARevocationAdditions_block_invoke;
  v11[3] = &__block_descriptor_tmp_31_11822;
  v11[4] = a2;
  v11[5] = v5;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __SecTrustStoreSetCARevocationAdditions_block_invoke_2;
  v10[3] = &unk_1E1FDB788;
  securityd_send_sync_and_do(0x7Au, a3, (uint64_t)v11, (uint64_t)v10);
  os_release(v8);
  v9 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  os_activity_scope_leave(&state);
  return v9;
}

uint64_t SecTrustStoreCopyCARevocationAdditions(uint64_t a1, CFTypeRef *a2)
{
  uint64_t (*v4)(uint64_t, CFTypeRef *);
  NSObject *v6;
  uint64_t v7;
  _QWORD v8[5];
  _QWORD v9[5];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  os_activity_scope_state_s state;

  if (gTrustd)
  {
    v4 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gTrustd + 192);
    if (v4)
      return v4(a1, a2);
  }
  v6 = _os_activity_create(&dword_18A900000, "SecTrustStoreCopyCARevocationAdditions", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v8[4] = &v10;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __SecTrustStoreCopyCARevocationAdditions_block_invoke;
  v9[3] = &__block_descriptor_tmp_33_11826;
  v9[4] = a1;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __SecTrustStoreCopyCARevocationAdditions_block_invoke_2;
  v8[3] = &unk_1E1FDB7D0;
  securityd_send_sync_and_do(0x7Bu, a2, (uint64_t)v9, (uint64_t)v8);
  os_release(v6);
  v7 = v11[3];
  _Block_object_dispose(&v10, 8);
  os_activity_scope_leave(&state);
  return v7;
}

uint64_t SecTrustStoreSetTransparentConnectionPins(const __CFString *a1, uint64_t a2, CFTypeRef *a3)
{
  const __CFString *v5;
  uint64_t (*v6)(const __CFString *, uint64_t, CFTypeRef *);
  NSObject *v8;
  uint64_t v9;
  _QWORD v10[5];
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;
  os_activity_scope_state_s state;

  v5 = a1;
  if (a1 && gTrustd)
  {
    v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 208);
    if (v6)
      return v6(a1, a2, a3);
  }
  else if (gTrustd)
  {
    v6 = *(uint64_t (**)(const __CFString *, uint64_t, CFTypeRef *))(gTrustd + 208);
    if (v6)
    {
      a1 = CFSTR("com.apple.trusttests");
      return v6(a1, a2, a3);
    }
  }
  v8 = _os_activity_create(&dword_18A900000, "SecTrustStoreSetTransparentConnectionPins", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v8, &state);
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v10[4] = &v12;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 0x40000000;
  v11[2] = __SecTrustStoreSetTransparentConnectionPins_block_invoke;
  v11[3] = &__block_descriptor_tmp_36_11829;
  v11[4] = a2;
  v11[5] = v5;
  v10[0] = MEMORY[0x1E0C809B0];
  v10[1] = 0x40000000;
  v10[2] = __SecTrustStoreSetTransparentConnectionPins_block_invoke_2;
  v10[3] = &unk_1E1FDB818;
  securityd_send_sync_and_do(0x7Du, a3, (uint64_t)v11, (uint64_t)v10);
  os_release(v8);
  v9 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  os_activity_scope_leave(&state);
  return v9;
}

uint64_t SecTrustStoreCopyTransparentConnectionPins(uint64_t a1, CFTypeRef *a2)
{
  uint64_t (*v4)(uint64_t, CFTypeRef *);
  NSObject *v6;
  uint64_t v7;
  _QWORD v8[5];
  _QWORD v9[5];
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  os_activity_scope_state_s state;

  if (gTrustd)
  {
    v4 = *(uint64_t (**)(uint64_t, CFTypeRef *))(gTrustd + 216);
    if (v4)
      return v4(a1, a2);
  }
  v6 = _os_activity_create(&dword_18A900000, "SecTrustStoreCopyTransparentConnectionPins", MEMORY[0x1E0C80FC8], OS_ACTIVITY_FLAG_DEFAULT);
  state.opaque[0] = 0xAAAAAAAAAAAAAAAALL;
  state.opaque[1] = 0xAAAAAAAAAAAAAAAALL;
  os_activity_scope_enter(v6, &state);
  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v8[4] = &v10;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __SecTrustStoreCopyTransparentConnectionPins_block_invoke;
  v9[3] = &__block_descriptor_tmp_38_11833;
  v9[4] = a1;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __SecTrustStoreCopyTransparentConnectionPins_block_invoke_2;
  v8[3] = &unk_1E1FDB860;
  securityd_send_sync_and_do(0x7Eu, a2, (uint64_t)v9, (uint64_t)v8);
  os_release(v6);
  v7 = v11[3];
  _Block_object_dispose(&v10, 8);
  os_activity_scope_leave(&state);
  return v7;
}

CFDataRef SecXPCDictionaryCopyData(void *a1, const char *a2, __CFString **a3)
{
  const UInt8 *data;
  CFDataRef result;
  size_t length;

  length = 0;
  data = (const UInt8 *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    if ((length & 0x8000000000000000) != 0)
    {
      SecError(-50, a3, CFSTR("too large data for key %s"), a2);
    }
    else
    {
      result = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], data, length);
      if (result)
        return result;
      SecError(-50, a3, CFSTR("failed to create data for key %s"), a2);
    }
  }
  else
  {
    SecError(-50, a3, CFSTR("no data for key %s"), a2);
  }
  return 0;
}

CFStringRef SecXPCDictionaryCopyString(void *a1, __CFString **a2)
{
  const char *string;
  const char *v4;
  CFStringRef result;

  string = xpc_dictionary_get_string(a1, "status");
  if (string)
  {
    v4 = string;
    result = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], string, 0x8000100u);
    if (result)
      return result;
    SecError(-108, a2, CFSTR("object for key %s failed to convert %s to CFString"), "status", v4);
  }
  else
  {
    SecError(-50, a2, CFSTR("object for key %s not string"), "status");
  }
  return 0;
}

uint64_t safeContentsParse(uint64_t **a1, unint64_t a2, char *a3)
{
  BOOL v3;
  uint64_t v5;
  unint64_t v7;
  const __CFAllocator *v8;
  const __CFAllocator *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  const DERItem *v15;
  _BOOL4 v16;
  CFDataRef v17;
  int v18;
  int v19;
  CFDataRef v20;
  _QWORD *v22;
  _QWORD v23[2];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  __int128 v29;

  v22 = 0;
  if (*a1)
    v3 = a3 == 0;
  else
    v3 = 1;
  if (v3 || SEC_ASN1Decode(**a1, (uint64_t)&v22, (uint64_t)&NSS_P12_SafeContentsTemplate, a3, a2))
    return 0xFFFFFFFFLL;
  if (!v22)
    return 0;
  if (!*v22)
    return 0;
  v5 = 0;
  while (v22[++v5])
    ;
  if (!(_DWORD)v5)
    return 0;
  v7 = 0;
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v9 = (const __CFAllocator *)*MEMORY[0x1E0C9AE20];
  v10 = 8 * v5;
  while (2)
  {
    v11 = v22[v7 / 8];
    v12 = *(_QWORD *)(v11 + 24);
    if (!v12)
      return 0xFFFFFFFFLL;
    switch(*(_DWORD *)(v11 + 16))
    {
      case 1:
      case 4:
      case 5:
      case 6:
        goto LABEL_14;
      case 2:
        v29 = 0uLL;
        p12Decrypt((uint64_t)a1, (_QWORD *)v12, v12 + 32, &v29);
        if (v13)
          return 0xFFFFFFFFLL;
        v28 = 0;
        v26 = 0u;
        v27 = 0u;
        v24 = 0u;
        v25 = 0u;
        if (!*a1)
          return 0xFFFFFFFFLL;
        if (!*((_QWORD *)&v29 + 1))
          return 0xFFFFFFFFLL;
        if (SEC_ASN1Decode(**a1, (uint64_t)&v24, (uint64_t)&kSecAsn1PrivateKeyInfoTemplate, *((char **)&v29 + 1), v29))return 0xFFFFFFFFLL;
        v23[0] = *((_QWORD *)&v25 + 1);
        v23[1] = v25;
        v14 = DEROidCompare((uint64_t)&oidEcPubKey, (uint64_t)v23);
        v15 = &oidEcPubKey;
        if (!v14)
        {
          v16 = DEROidCompare((uint64_t)&oidRsa, (uint64_t)v23);
          v15 = &oidRsa;
          if (!v16)
            return 0xFFFFFFFFLL;
        }
        v17 = CFDataCreateWithBytesNoCopy(v8, v15->data, v15->length, v9);
        if (emit_item((uint64_t)a1, *(_QWORD **)(v11 + 32), CFSTR("algid"), v17))
        {
          if (!v17)
            return 0xFFFFFFFFLL;
          v18 = -1;
LABEL_29:
          CFRelease(v17);
          goto LABEL_30;
        }
        if (v17)
          CFRelease(v17);
        v17 = CFDataCreate(v8, *((const UInt8 **)&v27 + 1), v27);
        if (emit_item((uint64_t)a1, *(_QWORD **)(v11 + 32), CFSTR("key"), v17))
          v18 = -1;
        else
          v18 = 0;
        if (v17)
          goto LABEL_29;
LABEL_30:
        if (v18)
          return 0xFFFFFFFFLL;
        goto LABEL_14;
      case 3:
        v19 = *(_DWORD *)(v12 + 16);
        if (v19 == 2)
          goto LABEL_14;
        if (v19 != 1)
          return 0xFFFFFFFFLL;
        v20 = CFDataCreate(v8, *(const UInt8 **)(v12 + 32), *(_QWORD *)(v12 + 24));
        if (!emit_item((uint64_t)a1, *(_QWORD **)(v11 + 32), CFSTR("cert"), v20))
        {
          CFRelease(v20);
LABEL_14:
          v7 += 8;
          if (v10 == v7)
            return 0;
          continue;
        }
        if (v20)
          CFRelease(v20);
        return 0xFFFFFFFFLL;
      default:
        return 0xFFFFFFFFLL;
    }
  }
}

double p12Decrypt(uint64_t a1, _QWORD *a2, uint64_t a3, _OWORD *a4)
{
  unint64_t v8;
  uint64_t *v9;
  char *v10;
  uint64_t v11;
  double result;
  uint64_t v13;
  char *v15;
  CCAlgorithm v16;
  unsigned int v17;
  CCOptions v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  unsigned __int8 *v22;
  unsigned int v23;
  int v24;
  unint64_t v25;
  void *v26;
  const __CFString *v27;
  int v28;
  void *v29;
  size_t v30;
  uint64_t *v31;
  size_t dataOutAvailable;
  void *dataOut;
  _OWORD *v34;
  __int128 v35;
  _QWORD v36[5];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  unint64_t v47;
  void *v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  int v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t (*v66)(uint64_t);
  void *v67;
  _QWORD *v68;

  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v8 = a2[2];
  if (v8)
  {
    v62 = 0uLL;
    v63 = 0uLL;
    v60 = 0uLL;
    v61 = 0uLL;
    v58 = 0uLL;
    v59 = 0uLL;
    v56 = 0uLL;
    v57 = 0uLL;
    v54 = 0uLL;
    v55 = 0uLL;
    v9 = *(uint64_t **)a1;
    v10 = (char *)a2[3];
    if (*(_QWORD *)a1 && v10)
    {
      if (!SEC_ASN1Decode(*v9, (uint64_t)&v54, (uint64_t)&NSS_P12_PBE_ParamsTemplate, v10, v8))
        goto LABEL_10;
      v9 = *(uint64_t **)a1;
      v10 = (char *)a2[3];
    }
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    v54 = 0u;
    v55 = 0u;
    if (v9
      && v10
      && !SEC_ASN1Decode(*v9, (uint64_t)&v54, (uint64_t)&NSS_P12_PBE2_ParamsTemplate, v10, a2[2]))
    {
      v54 = v57;
      v55 = v58;
    }
  }
LABEL_10:
  v11 = *a2 - 1;
  v64 = a2[1];
  v65 = v11;
  if (DEROidCompare((uint64_t)&OID_PKCS12_pbep, (uint64_t)&v64))
  {
    v13 = *(unsigned __int8 *)(*a2 + a2[1] - 1);
    if (v13 > 7 || (_DWORD)v13 == 4)
      return result;
    v15 = (char *)&pkcsOidInfos + 16 * v13;
    v16 = *((_DWORD *)v15 - 4);
    v17 = *((_DWORD *)v15 - 3);
    v19 = *((_DWORD *)v15 - 2);
    v18 = *((_DWORD *)v15 - 1);
    v20 = 20;
  }
  else
  {
    if (!DEROidCompare((uint64_t)&OID_PKCS5_pbep2, (uint64_t)&v64))
      return result;
    v16 = 0;
    v20 = 32;
    v18 = 1;
    v19 = 16;
    v17 = 256;
  }
  v21 = v55;
  if ((_QWORD)v55 && (v22 = (unsigned __int8 *)*((_QWORD *)&v55 + 1)) != 0)
  {
    if ((unint64_t)v55 > 4)
      return result;
    v23 = 0;
    do
    {
      v24 = *v22++;
      v23 = v24 | (v23 << 8);
      --v21;
    }
    while (v21);
  }
  else
  {
    v23 = 0;
  }
  v34 = a4;
  if (v17 && *(_QWORD *)a1)
  {
    v25 = (v17 + 7) >> 3;
    v26 = (void *)PORT_ArenaAlloc(**(_QWORD **)a1, v25);
    if (!v26)
      v25 = 0;
    if (!v16)
    {
LABEL_30:
      v50 = 0;
      v51 = &v50;
      v52 = 0x2000000000;
      v53 = 0;
      v25 = v17 >> 3;
      v27 = *(const __CFString **)(a1 + 8);
      v36[0] = MEMORY[0x1E0C809B0];
      v43 = v60;
      v44 = v61;
      v45 = v62;
      v46 = v63;
      v39 = v56;
      v40 = v57;
      v41 = v58;
      v42 = v59;
      v37 = v54;
      v36[1] = 0x40000000;
      v36[2] = __p12Decrypt_block_invoke;
      v36[3] = &unk_1E1FDBB88;
      v36[4] = &v50;
      v38 = v55;
      v49 = v23;
      v47 = v25;
      v48 = v26;
      v64 = MEMORY[0x1E0C809B0];
      v65 = 0x40000000;
      v66 = __CFStringPerformWithCString_block_invoke;
      v67 = &unk_1E1FDBF70;
      v68 = v36;
      CFStringPerformWithCStringAndLength(v27, (uint64_t)&v64);
      v28 = *((_DWORD *)v51 + 6);
      _Block_object_dispose(&v50, 8);
      if (v28)
        return result;
      goto LABEL_34;
    }
  }
  else
  {
    v25 = 0;
    v26 = 0;
    if (!v16)
      goto LABEL_30;
  }
  if (p12_pbe_gen(*(const __CFString **)(a1 + 8), *((const void **)&v54 + 1), v54, v23, 1, v26, v25, 0x40u, v20))return result;
LABEL_34:
  v29 = (void *)*((_QWORD *)&v63 + 1);
  if (*((_QWORD *)&v63 + 1) && (_QWORD)v63)
  {
LABEL_44:
    v35 = 0uLL;
    v31 = *(uint64_t **)a1;
    if (*(_QWORD *)a1)
    {
      dataOutAvailable = *(_QWORD *)a3;
      dataOut = (void *)PORT_ArenaAlloc(*v31, *(_QWORD *)a3);
      *((_QWORD *)&v35 + 1) = dataOut;
      if (dataOut)
        *(_QWORD *)&v35 = dataOutAvailable;
      else
        dataOutAvailable = 0;
    }
    else
    {
      dataOutAvailable = 0;
      dataOut = 0;
    }
    if (!CCCrypt(1u, v16, v18, v26, v25, v29, *(const void **)(a3 + 8), *(_QWORD *)a3, dataOut, dataOutAvailable, (size_t *)&v35))
    {
      result = *(double *)&v35;
      *v34 = v35;
    }
    return result;
  }
  if (!v19)
  {
    v29 = 0;
    goto LABEL_44;
  }
  if (*(_QWORD *)a1)
  {
    v29 = (void *)PORT_ArenaAlloc(**(_QWORD **)a1, v19);
    if (v29)
      v30 = v19;
    else
      v30 = 0;
  }
  else
  {
    v30 = 0;
    v29 = 0;
  }
  if (!p12_pbe_gen(*(const __CFString **)(a1 + 8), *((const void **)&v54 + 1), v54, v23, 2, v29, v30, 0x40u, v20))goto LABEL_44;
  return result;
}

uint64_t __p12Decrypt_block_invoke(uint64_t a1, char *__s)
{
  size_t v4;
  uint64_t result;

  v4 = strlen(__s);
  result = CCKeyDerivationPBKDF(2u, __s, v4, *(const uint8_t **)(a1 + 48), *(_QWORD *)(a1 + 40), 3u, *(_DWORD *)(a1 + 216), *(uint8_t **)(a1 + 208), *(_QWORD *)(a1 + 200));
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t emit_item(uint64_t a1, _QWORD *a2, void *a3, const void *a4)
{
  const __CFAllocator *v8;
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t *v20;
  char *v21;
  CFStringRef v22;
  const void *v23;
  __CFDictionary *v24;
  const __CFString *v25;
  unint64_t *v26;
  char *v27;
  CFDataRef v28;
  const void *Value;
  const void *v30;
  __CFDictionary *v31;
  const void *v32;
  const __CFDictionary *v33;
  uint64_t v34;
  void *key;
  CFIndex v37;
  const UInt8 *v38;
  unint64_t v39;
  unint64_t v40;

  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (!Mutable)
    return 0xFFFFFFFFLL;
  v10 = Mutable;
  key = a3;
  if (a2)
  {
    if (*a2)
    {
      v11 = 0;
      while (a2[++v11])
        ;
      if ((_DWORD)v11)
      {
        v13 = 0;
        v14 = v11;
        do
        {
          v15 = (unint64_t *)a2[v13];
          v16 = (_QWORD *)v15[2];
          if (v16 && *v16)
          {
            v17 = 0;
            v18 = v16 + 1;
            while (v18[v17++])
              ;
          }
          else
          {
            LODWORD(v17) = 0;
          }
          v39 = 0xAAAAAAAAAAAAAAAALL;
          v40 = 0xAAAAAAAAAAAAAAAALL;
          v39 = v15[1];
          v40 = *v15;
          if (DEROidCompare((uint64_t)&v39, (uint64_t)&oidFriendlyName))
          {
            if ((_DWORD)v17 != 1)
              goto LABEL_41;
            v37 = 0xAAAAAAAAAAAAAAAALL;
            v38 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL;
            if (!*(_QWORD *)a1)
              goto LABEL_41;
            v20 = *(unint64_t **)v15[2];
            v21 = (char *)v20[1];
            if (!v21
              || SEC_ASN1Decode(**(_QWORD **)a1, (uint64_t)&v37, (uint64_t)kSecAsn1BMPStringTemplate, v21, *v20))
            {
              goto LABEL_41;
            }
            v22 = CFStringCreateWithBytes(v8, v38, v37, 0x100u, 1u);
            if (v22)
            {
              v23 = v22;
              v24 = v10;
              v25 = CFSTR("label");
LABEL_28:
              CFDictionarySetValue(v24, v25, v23);
              CFRelease(v23);
            }
          }
          else if (DEROidCompare((uint64_t)&v39, (uint64_t)&oidLocalKeyId))
          {
            if ((_DWORD)v17 != 1
              || (v37 = 0xAAAAAAAAAAAAAAAALL, v38 = (const UInt8 *)0xAAAAAAAAAAAAAAAALL, !*(_QWORD *)a1)
              || (v26 = *(unint64_t **)v15[2], (v27 = (char *)v26[1]) == 0)
              || SEC_ASN1Decode(**(_QWORD **)a1, (uint64_t)&v37, (uint64_t)kSecAsn1OctetStringTemplate, v27, *v26))
            {
LABEL_41:
              v34 = 0xFFFFFFFFLL;
              goto LABEL_39;
            }
            v28 = CFDataCreate(v8, v38, v37);
            if (v28)
            {
              v23 = v28;
              v24 = v10;
              v25 = CFSTR("keyid");
              goto LABEL_28;
            }
          }
          ++v13;
        }
        while (v13 != v14);
      }
    }
  }
  Value = CFDictionaryGetValue(v10, CFSTR("keyid"));
  if (!Value)
    Value = CFDictionaryGetValue(v10, CFSTR("label"));
  if (Value)
    v30 = Value;
  else
    v30 = a4;
  v31 = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v30);
  v32 = key;
  if (v31)
  {
    v33 = (const __CFDictionary *)a4;
  }
  else
  {
    CFDictionarySetValue(v10, key, a4);
    v31 = *(__CFDictionary **)(a1 + 16);
    v32 = v30;
    v33 = v10;
  }
  CFDictionarySetValue(v31, v32, v33);
  v34 = 0;
LABEL_39:
  CFRelease(v10);
  return v34;
}

void sub_18AA1AABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18AA1ABC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18AA1AC80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18AA1AD60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_18AA1B510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__12571(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__12572(uint64_t a1)
{

}

void _getAppAttestInternalSymbol(_QWORD *a1, char *__symbol)
{
  void *v4;

  if (_initAppAttestInternal_onceToken == -1)
  {
    if (!a1)
      return;
  }
  else
  {
    dispatch_once(&_initAppAttestInternal_onceToken, &__block_literal_global_489);
    if (!a1)
      return;
  }
  if (!*a1)
  {
    v4 = dlsym((void *)appAttestInternal, __symbol);
    *a1 = v4;
    if (!v4)
    {
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "symbol %s is missing", __symbol);
      abort();
    }
  }
}

void *___initAppAttestInternal_block_invoke()
{
  void *result;

  result = dlopen("/System/Library/PrivateFrameworks/AppAttestInternal.framework/AppAttestInternal", 5);
  appAttestInternal = (uint64_t)result;
  return result;
}

void SecRequestClientIdentity(const void *a1, const void *a2, void *a3, void *a4)
{
  NSObject *v7;
  id v8;
  void (**v9)(_QWORD, _QWORD, _QWORD);
  const char *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  uint64_t v14;
  void *v15;
  NSObject *v16;
  _QWORD block[4];
  void (**v18)(_QWORD, _QWORD, _QWORD);
  __int128 *p_buf;
  const void *v20;
  const void *v21;
  __int128 buf;
  uint64_t v23;
  uint64_t (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t);
  id v26;
  uint64_t v27;
  _QWORD v28[2];

  v28[1] = *MEMORY[0x1E0C80C00];
  v7 = a3;
  v8 = a4;
  v9 = (void (**)(_QWORD, _QWORD, _QWORD))v8;
  v10 = "subject";
  if (a1)
    v10 = 0;
  if (!a2)
    v10 = "parameters";
  if (!v7)
    v10 = "queue";
  if (!v8)
    v10 = "result block";
  if (v10)
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("SecRequestClientIdentity was called with NULL %s"), v10);
    v11 = objc_claimAutoreleasedReturnValue();
    v12 = (void *)v11;
    if (v9)
    {
      v13 = (void *)MEMORY[0x1E0CB35C8];
      v14 = *MEMORY[0x1E0CB2F90];
      v27 = *MEMORY[0x1E0CB2D50];
      v28[0] = v11;
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v28, &v27, 1);
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v13, "errorWithDomain:code:userInfo:", v14, -50, v15);
      v16 = objc_claimAutoreleasedReturnValue();

      ((void (**)(_QWORD, _QWORD, NSObject *))v9)[2](v9, 0, v16);
    }
    else
    {
      secLogObjForScope("SecError");
      v16 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(_QWORD *)((char *)&buf + 4) = v12;
        _os_log_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
      }
    }

  }
  else
  {
    if (a1)
      CFRetain(a1);
    if (a2)
      CFRetain(a2);
    *(_QWORD *)&buf = 0;
    *((_QWORD *)&buf + 1) = &buf;
    v23 = 0x3032000000;
    v24 = __Block_byref_object_copy__12571;
    v25 = __Block_byref_object_dispose__12572;
    v26 = (id)0xAAAAAAAAAAAAAAAALL;
    v26 = (id)os_transaction_create();
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __SecRequestClientIdentity_block_invoke;
    block[3] = &unk_1E1FDBE58;
    v20 = a1;
    v21 = a2;
    v18 = v9;
    p_buf = &buf;
    dispatch_async(v7, block);

    _Block_object_dispose(&buf, 8);
  }

}

uint64_t SecAreQARootCertificatesEnabled()
{
  if (SecAreQARootCertificatesEnabled_onceToken != -1)
    dispatch_once(&SecAreQARootCertificatesEnabled_onceToken, &__block_literal_global_12660);
  return SecAreQARootCertificatesEnabled_sQACertsEnabled;
}

uint64_t p12_pbe_gen(const __CFString *a1, const void *a2, size_t a3, unsigned int a4, uint64_t a5, void *a6, size_t a7, CC_LONG a8, unsigned int a9)
{
  size_t v16;
  int v17;
  const __CFData *ExternalRepresentation;
  const __CFData *v19;
  __CFData *MutableCopy;
  CFIndex Length;
  const UInt8 *BytePtr;
  char *v23;
  char *v24;
  char *v25;
  size_t v26;
  int64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  size_t v32;
  int64_t v33;
  unsigned __int8 *v34;
  unsigned int v35;
  unint64_t v36;
  const void *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  unsigned int v43;
  char *v44;
  char *v45;
  CC_LONG64 v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  unsigned int i;
  void *v52;
  char *v54;
  void *v55;
  uint64_t v56;
  void *v57;
  size_t v58;
  uint64_t *v59;
  char *v60;
  unsigned int v61;
  uint64_t v62;
  unsigned __int8 *v63;
  size_t v64;
  size_t v65;
  unsigned int v66;
  char *v67;
  char *v68;
  size_t v69;
  int64_t v70;
  __int16 bytes;
  CC_SHA512_CTX c;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0xFFFFFFFFLL;
  v16 = a8;
  MEMORY[0x1E0C80A78](a1);
  memset((char *)&v56 - ((v16 + 15) & 0x1FFFFFFF0), v17, v16);
  ExternalRepresentation = CFStringCreateExternalRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, 0x10000100u, 0);
  if (!ExternalRepresentation)
    return 0xFFFFFFFFLL;
  v19 = ExternalRepresentation;
  v67 = (char *)&v56 - ((v16 + 15) & 0x1FFFFFFF0);
  bytes = 0;
  MutableCopy = CFDataCreateMutableCopy(0, 0, ExternalRepresentation);
  CFRelease(v19);
  if (!MutableCopy)
    return 0xFFFFFFFFLL;
  CFDataAppendBytes(MutableCopy, (const UInt8 *)&bytes, 2);
  v70 = 0;
  Length = CFDataGetLength(MutableCopy);
  BytePtr = CFDataGetBytePtr(MutableCopy);
  v23 = concatenate_to_blocksize(BytePtr, Length, v16, &v70);
  CFRelease(MutableCopy);
  if (!v23)
    return 0xFFFFFFFFLL;
  v69 = 0;
  if (!a3)
    goto LABEL_36;
  v24 = concatenate_to_blocksize(a2, a3, v16, (int64_t *)&v69);
  if (!v24)
    goto LABEL_36;
  v25 = v24;
  v66 = a4;
  v26 = v69;
  v27 = v70;
  v28 = v70 + v69;
  v29 = (char *)malloc_type_malloc(v70 + v69, 0xCF5D87EFuLL);
  if (!v29)
  {
    free(v25);
LABEL_36:
    v54 = v23;
LABEL_37:
    free(v54);
    return 0xFFFFFFFFLL;
  }
  v65 = a9;
  v64 = v27;
  v30 = v29;
  memcpy(v29, v25, v26);
  v68 = v30;
  v31 = &v30[v26];
  v32 = v65;
  memcpy(v31, v23, v64);
  free(v25);
  free(v23);
  v33 = (a7 + v32 - 1) / v32 * v32;
  v60 = (char *)malloc_type_malloc(v33, 0x41DF80B2uLL);
  if (!v60)
  {
    v54 = v68;
    goto LABEL_37;
  }
  v57 = a6;
  v58 = a7;
  v59 = &v56;
  if (v33 < 1)
  {
LABEL_33:
    v52 = v60;
    memmove(v57, v60, v58);
    free(v52);
    free(v68);
    return 0;
  }
  else
  {
    v34 = (unsigned __int8 *)v60;
    v63 = (unsigned __int8 *)&v60[v33];
    HIDWORD(v36) = v32;
    LODWORD(v36) = v32 - 20;
    v35 = v36 >> 2;
    v64 = (v16 + 7) >> 3;
    v61 = v66 - 1;
    v62 = v35;
    while (1)
    {
      v37 = v67;
      switch(v35)
      {
        case 0u:
          *(_QWORD *)&v38 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v38 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.hash[6] = v38;
          *(_OWORD *)c.wbuf = v38;
          *(_OWORD *)&c.hash[4] = v38;
          *(_OWORD *)&c.hash[2] = v38;
          *(_OWORD *)c.hash = v38;
          *(_OWORD *)c.count = v38;
          CC_SHA1_Init((CC_SHA1_CTX *)&c);
          CC_SHA1_Update((CC_SHA1_CTX *)&c, v37, a8);
          CC_SHA1_Update((CC_SHA1_CTX *)&c, v68, v28);
          CC_SHA1_Final(v34, (CC_SHA1_CTX *)&c);
          break;
        case 2u:
          c.wbuf[2] = 0xAAAAAAAAAAAAAAAALL;
          *(_QWORD *)&v39 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.hash[6] = v39;
          *(_OWORD *)c.wbuf = v39;
          *(_OWORD *)&c.hash[4] = v39;
          *(_OWORD *)&c.hash[2] = v39;
          *(_OWORD *)c.hash = v39;
          *(_OWORD *)c.count = v39;
          CC_SHA224_Init((CC_SHA256_CTX *)&c);
          CC_SHA224_Update((CC_SHA256_CTX *)&c, v37, a8);
          CC_SHA224_Update((CC_SHA256_CTX *)&c, v68, v28);
          CC_SHA224_Final(v34, (CC_SHA256_CTX *)&c);
          break;
        case 3u:
          c.wbuf[2] = 0xAAAAAAAAAAAAAAAALL;
          *(_QWORD *)&v40 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v40 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.hash[6] = v40;
          *(_OWORD *)c.wbuf = v40;
          *(_OWORD *)&c.hash[4] = v40;
          *(_OWORD *)&c.hash[2] = v40;
          *(_OWORD *)c.hash = v40;
          *(_OWORD *)c.count = v40;
          CC_SHA256_Init((CC_SHA256_CTX *)&c);
          CC_SHA256_Update((CC_SHA256_CTX *)&c, v37, a8);
          CC_SHA256_Update((CC_SHA256_CTX *)&c, v68, v28);
          CC_SHA256_Final(v34, (CC_SHA256_CTX *)&c);
          break;
        case 7u:
          *(_QWORD *)&v41 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.wbuf[12] = v41;
          *(_OWORD *)&c.wbuf[14] = v41;
          *(_OWORD *)&c.wbuf[8] = v41;
          *(_OWORD *)&c.wbuf[10] = v41;
          *(_OWORD *)&c.wbuf[4] = v41;
          *(_OWORD *)&c.wbuf[6] = v41;
          *(_OWORD *)c.wbuf = v41;
          *(_OWORD *)&c.wbuf[2] = v41;
          *(_OWORD *)&c.hash[6] = v41;
          *(_OWORD *)&c.hash[4] = v41;
          *(_OWORD *)&c.hash[2] = v41;
          *(_OWORD *)c.hash = v41;
          *(_OWORD *)c.count = v41;
          CC_SHA384_Init(&c);
          CC_SHA384_Update(&c, v37, a8);
          CC_SHA384_Update(&c, v68, v28);
          CC_SHA384_Final(v34, &c);
          break;
        case 0xBu:
          *(_QWORD *)&v42 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v42 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&c.wbuf[12] = v42;
          *(_OWORD *)&c.wbuf[14] = v42;
          *(_OWORD *)&c.wbuf[8] = v42;
          *(_OWORD *)&c.wbuf[10] = v42;
          *(_OWORD *)&c.wbuf[4] = v42;
          *(_OWORD *)&c.wbuf[6] = v42;
          *(_OWORD *)c.wbuf = v42;
          *(_OWORD *)&c.wbuf[2] = v42;
          *(_OWORD *)&c.hash[6] = v42;
          *(_OWORD *)&c.hash[4] = v42;
          *(_OWORD *)&c.hash[2] = v42;
          *(_OWORD *)c.hash = v42;
          *(_OWORD *)c.count = v42;
          CC_SHA512_Init(&c);
          CC_SHA512_Update(&c, v37, a8);
          CC_SHA512_Update(&c, v68, v28);
          CC_SHA512_Final(v34, &c);
          break;
        default:
          break;
      }
      if (v66 >= 2)
      {
        v43 = v61;
        do
        {
          CCDigest();
          --v43;
        }
        while (v43);
      }
      c.count[0] = 0;
      v44 = concatenate_to_blocksize(v34, v32, v16, (int64_t *)&c);
      if (!v44)
        goto LABEL_41;
      v45 = v44;
      if ((c.count[0] + 8) >> 3 <= v64)
        v46 = v64;
      else
        v46 = (c.count[0] + 8) >> 3;
      v47 = malloc_type_malloc(8 * v46, 0x100004000313F17uLL);
      if (!v47)
      {
        free(v45);
LABEL_41:
        free(v68);
        v55 = v60;
        goto LABEL_43;
      }
      v48 = v47;
      ccn_read_uint();
      ccn_add1();
      free(v45);
      v49 = malloc_type_malloc(8 * v46, 0x100004000313F17uLL);
      if (!v49)
        break;
      v50 = v49;
      if (v28)
      {
        for (i = 0; i < v28; i += a8)
        {
          ccn_read_uint();
          ccn_add();
          while (ccn_bitlen() > (unint64_t)(8 * a8))
            ccn_set_bit();
          ccn_write_uint_padded();
        }
      }
      v32 = v65;
      v34 += v65;
      free(v48);
      free(v50);
      v35 = v62;
      if (v34 >= v63)
        goto LABEL_33;
    }
    free(v68);
    free(v60);
    v55 = v48;
LABEL_43:
    free(v55);
    return 0xFFFFFFFFLL;
  }
}

char *concatenate_to_blocksize(const void *a1, size_t a2, unint64_t a3, int64_t *a4)
{
  int64_t v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  size_t v12;

  v7 = (a2 + a3 - 1) / a3 * a3;
  v8 = (char *)malloc_type_malloc(v7, 0x2D286B2EuLL);
  v9 = v8;
  if (v8)
  {
    if (v7 >= 1)
    {
      v10 = &v8[v7];
      v11 = v8;
      do
      {
        if (v10 - v11 >= a2)
          v12 = a2;
        else
          v12 = v10 - v11;
        memcpy(v11, a1, v12);
        v11 += a2;
      }
      while (v11 < v10);
    }
    *a4 = v7;
  }
  return v9;
}

void (*pbkdf2(void (*result)(uint64_t, uint64_t, char *, size_t, char *), size_t a2, uint64_t a3, uint64_t a4, void *__src, size_t __n, unint64_t a7, char *a8, unint64_t a9, char *a10))(uint64_t, uint64_t, char *, size_t, char *)
{
  unint64_t v16;
  unsigned int v17;
  void (*v18)(uint64_t, uint64_t, char *, size_t, char *);
  unint64_t v19;
  unint64_t v20;
  char *v21;

  v16 = a9 / a2;
  v20 = a9 / a2 * a2;
  if ((a9 / a2))
  {
    v21 = &a10[a2];
    v17 = 1;
    do
    {
      v18 = result;
      v19 = a7;
      F(result, a2, a3, a4, __src, __n, a7, v17, a8, v21);
      result = v18;
      a7 = v19;
      a8 += a2;
      ++v17;
    }
    while (v17 <= v16);
  }
  else
  {
    v17 = 1;
  }
  if (a9 != v20)
  {
    F(result, a2, a3, a4, __src, __n, a7, v17, a10, &a10[a2]);
    return (void (*)(uint64_t, uint64_t, char *, size_t, char *))memcpy(a8, a10, a9 - v20);
  }
  return result;
}

void *F(void (*a1)(uint64_t, uint64_t, char *, size_t, char *), size_t a2, uint64_t a3, uint64_t a4, void *__src, size_t __n, unint64_t a7, unsigned int a8, void *a9, char *a10)
{
  char *v17;
  char *v18;
  void *result;
  unint64_t v20;
  char *v21;
  uint64_t v22;

  v17 = a10;
  v18 = &a10[a2];
  memcpy(&a10[a2], __src, __n);
  *(_DWORD *)&v18[__n] = bswap32(a8);
  a1(a3, a4, v18, __n + 4, a10);
  result = memcpy(a9, a10, a2);
  if (a7 >= 2)
  {
    v20 = 2;
    do
    {
      v21 = v18;
      result = (void *)((uint64_t (*)(uint64_t, uint64_t, char *, size_t, char *))a1)(a3, a4, v17, a2, v18);
      if (a2)
      {
        v22 = 0;
        do
        {
          *((_BYTE *)a9 + v22) ^= v18[v22];
          ++v22;
        }
        while (a2 > v22);
      }
      ++v20;
      v18 = v17;
      v17 = v21;
    }
    while (v20 <= a7);
  }
  return result;
}

__CFString *SecLogAPICreate(uint64_t a1, const char *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const __CFAllocator *v11;
  __CFString *Mutable;
  const __CFString *v13;
  __int128 v14;
  char __str[16];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  const void **vars0;

  v21 = *MEMORY[0x1E0C80C00];
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppend(Mutable, CFSTR("SecAPITrace "));
  CFStringAppendCString(Mutable, a2, 0x600u);
  CFStringAppendCString(Mutable, "ENTER", 0x600u);
  if (a3)
  {
    v13 = CFStringCreateWithFormatAndArguments(v11, 0, a3, &a9);
    CFStringAppend(Mutable, v13);
    if (v13)
      CFRelease(v13);
  }
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v19 = v14;
  v20 = v14;
  v17 = v14;
  v18 = v14;
  *(_OWORD *)__str = v14;
  snprintf(__str, 0x50uLL, "C%p F%p", vars0[1], *vars0);
  CFStringAppend(Mutable, CFSTR("CALLER "));
  CFStringAppendCString(Mutable, __str, 0x600u);
  return Mutable;
}

uint64_t SecGetDebugDescriptionFormatOptions()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SecGetDebugDescriptionFormatOptions_block_invoke;
  block[3] = &__block_descriptor_tmp_12768;
  block[4] = &SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsSingleton;
  if (SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsOnce != -1)
    dispatch_once(&SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsOnce, block);
  return SecGetDebugDescriptionFormatOptions_sSecGetDebugDescriptionFormatOptionsSingleton;
}

uint64_t apply_block_1_12775(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void CFStringSetPerformWithDescription(const __CFSet *a1, uint64_t a2)
{
  CFIndex Count;
  const __CFArray *Mutable;
  const void *v6;
  _QWORD v7[6];
  _QWORD v8[4];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  CFMutableStringRef MutableCopy;
  CFRange v13;
  CFRange v14;

  if (a1
    && (Count = CFSetGetCount(a1),
        Mutable = CFArrayCreateMutable(0, Count, MEMORY[0x1E0C9B378]),
        CFSetApplyFunction(a1, (CFSetApplierFunction)appendDescriptionToArray, Mutable),
        v13.length = CFArrayGetCount(Mutable),
        v13.location = 0,
        CFArraySortValues(Mutable, v13, (CFComparatorFunction)MEMORY[0x1E0C98F10], 0),
        Mutable))
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2000000000;
    MutableCopy = (CFMutableStringRef)0xAAAAAAAAAAAAAAAALL;
    MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("{("));
    v8[0] = 0;
    v8[1] = v8;
    v8[2] = 0x2000000000;
    v8[3] = &stru_1E1FDD448;
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = __CFStringArrayPerformWithDelimiterWithDescription_block_invoke;
    v7[3] = &unk_1E1FDC050;
    v7[4] = &v9;
    v7[5] = v8;
    v14.length = CFArrayGetCount(Mutable);
    v14.location = 0;
    CFArrayApplyFunction(Mutable, v14, (CFArrayApplierFunction)apply_block_1_12775, v7);
    CFStringAppend((CFMutableStringRef)v10[3], CFSTR(")}"));
    (*(void (**)(uint64_t, uint64_t))(a2 + 16))(a2, v10[3]);
    v6 = (const void *)v10[3];
    if (v6)
    {
      v10[3] = 0;
      CFRelease(v6);
    }
    _Block_object_dispose(v8, 8);
    _Block_object_dispose(&v9, 8);
    CFRelease(Mutable);
  }
  else
  {
    (*(void (**)(uint64_t, const __CFString *))(a2 + 16))(a2, CFSTR("null"));
  }
}

void appendDescriptionToArray(const __CFString *a1, __CFArray *a2)
{
  CFTypeID v4;
  __CFArray *v5;
  const __CFString *v6;
  CFStringRef v7;
  CFStringRef v8;

  v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    v5 = a2;
    v6 = a1;
  }
  else
  {
    v7 = CFCopyDescription(a1);
    if (v7)
    {
      v8 = v7;
      CFArrayAppendValue(a2, v7);
      CFRelease(v8);
      return;
    }
    v6 = CFSTR("null");
    v5 = a2;
  }
  CFArrayAppendValue(v5, v6);
}

uint64_t apply_block_2_12810(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t CFDataCreateWithRandomBytes(size_t a1)
{
  uint64_t v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[5];

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __CFDataCreateWithRandomBytes_block_invoke;
  v3[3] = &unk_1E1FDBFC0;
  v3[4] = &v4;
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __PerformWithBufferAndClear_block_invoke;
  v8[3] = &unk_1E1FDC2B8;
  v8[4] = v3;
  PerformWithBuffer(a1, (uint64_t)v8);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

CFStringRef __withStringOfAbsoluteTime_block_invoke(uint64_t a1, __CFDateFormatter *a2)
{
  CFStringRef result;

  result = CFDateFormatterCreateStringWithAbsoluteTime((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, *(CFAbsoluteTime *)(a1 + 40));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t __withShortDateFormatter_block_invoke(uint64_t a1)
{
  uint64_t v1;
  _QWORD block[5];

  v1 = *(_QWORD *)(a1 + 32);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __GetShortDateFormatter_block_invoke;
  block[3] = &__block_descriptor_tmp_39_12831;
  block[4] = &GetShortDateFormatter_sGetShortDateFormatterSingleton;
  if (GetShortDateFormatter_sGetShortDateFormatterOnce != -1)
    dispatch_once(&GetShortDateFormatter_sGetShortDateFormatterOnce, block);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v1 + 16))(v1, GetShortDateFormatter_sGetShortDateFormatterSingleton);
}

void der_encode_date(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  double v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v11 = MEMORY[0x18D76F188]();
  der_encode_generalizedtime_body_repair(0, 0, a2, a3, v11);
  if (!ccder_encode_constructed_tl())
    SecCFCreateErrorWithFormat(-7, (const __CFString *)sSecDERErrorDomain, 0, 0, v12, CFSTR("ccder failed to encode"), v13, v14, a9);
}

void __getAnchors_block_invoke()
{
  const __CFDictionary *Mutable;

  Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  addAnchor(Mutable, AppleRootCAHash, 1);
  addAnchor(Mutable, AppleRootG2Hash, 1);
  addAnchor(Mutable, AppleRootG3Hash, 1);
  addAnchor(Mutable, TestAppleRootCAHash, 0);
  addAnchor(Mutable, TestAppleRootG2Hash, 0);
  addAnchor(Mutable, TestAppleRootG3Hash, 0);
  getAnchors_anchors = (uint64_t)Mutable;
}

void addAnchor(const __CFDictionary *a1, const UInt8 *a2, int a3)
{
  CFDataRef v5;
  const void **v6;

  v5 = CFDataCreateWithBytesNoCopy(0, a2, 32, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (CFDictionaryGetValue(a1, v5))
    abort();
  v6 = (const void **)MEMORY[0x1E0C9AE50];
  if (!a3)
    v6 = (const void **)MEMORY[0x1E0C9AE40];
  CFDictionarySetValue(a1, v5, *v6);
  if (v5)
    CFRelease(v5);
}

uint64_t SecIsAppleTrustAnchor(_QWORD *a1, char a2)
{
  __CFData *v3;
  __CFData *v4;
  const void *Value;
  uint64_t v6;
  CFTypeID v7;
  int v8;
  int v9;
  unsigned int v10;

  v3 = SecCertificateCopySHA256Digest(a1);
  if (!v3)
    return 0;
  v4 = v3;
  if (getAnchors_onceToken != -1)
    dispatch_once(&getAnchors_onceToken, &__block_literal_global_3_13097);
  if (!getAnchors_anchors)
  {
LABEL_13:
    v6 = 0;
    goto LABEL_11;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)getAnchors_anchors, v4);
  v6 = (uint64_t)Value;
  if (Value)
  {
    v7 = CFGetTypeID(Value);
    if (v7 == CFBooleanGetTypeID())
    {
      v8 = CFBooleanGetValue((CFBooleanRef)v6);
      v6 = v8 != 0;
      if ((a2 & 1) != 0)
      {
        v9 = v8;
        v10 = os_variant_allows_internal_security_policies() | ((a2 & 2) >> 1);
        if (v9)
          v6 = 1;
        else
          v6 = v10;
      }
      goto LABEL_11;
    }
    goto LABEL_13;
  }
LABEL_11:
  CFRelease(v4);
  return v6;
}

void addCertificate(const __CFArray *a1, const void *a2, int64_t a3)
{
  _QWORD *v4;
  CFRange v5;

  v4 = SecCertificateCreateWithBytes(0, a2, a3);
  v5.length = CFArrayGetCount(a1);
  v5.location = 0;
  if (CFArrayContainsValue(a1, v5, v4))
    abort();
  CFArrayAppendValue(a1, v4);
  if (v4)
    CFRelease(v4);
}

BOOL SecKernError(int a1, CFTypeRef *a2, CFStringRef format, ...)
{
  __CFString *v5;
  va_list va;

  va_start(va, format);
  if (a1 && a2)
  {
    v5 = (__CFString *)*a2;
    *a2 = 0;
    SecCFCreateErrorWithFormatAndArguments(a1, (const __CFString *)*MEMORY[0x1E0C9AFC0], v5, a2, 0, format, va);
  }
  return a1 == 0;
}

void SecCFCreateErrorWithFormatAndArguments(CFIndex a1, const __CFString *a2, __CFString *cf, CFTypeRef *a4, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  const __CFString *v11;
  const void **v12;
  const __CFDictionary *v13;
  const __CFString *Value;
  _BOOL4 v15;
  CFIndex Code;
  const __CFString *Domain;
  CFComparisonResult v18;
  _BOOL4 v20;
  __CFString *v21;
  const __CFString *v22;
  const __CFDictionary *v23;
  const __CFDictionary *v24;
  const __CFNumber *v25;
  const __CFAllocator *v26;
  CFNumberRef v27;
  __CFDictionary *Mutable;
  __CFDictionary *v29;
  uint64_t v30;
  uint64_t valuePtr;

  if (!a4)
    return;
  if (*a4)
  {
    if (cf)
    {
      if (*a4 != cf)
        CFRelease(cf);
    }
    return;
  }
  v11 = CFStringCreateWithFormatAndArguments(0, formatOptions, format, arguments);
  v30 = 0;
  v12 = (const void **)MEMORY[0x1E0C9AFB0];
  if (!cf)
    goto LABEL_28;
  v13 = CFErrorCopyUserInfo((CFErrorRef)cf);
  Value = (const __CFString *)CFDictionaryGetValue(v13, *v12);
  if (Value)
  {
    v15 = CFStringCompare(v11, Value, 0) == kCFCompareEqualTo;
    if (!v13)
      goto LABEL_10;
    goto LABEL_9;
  }
  v15 = 0;
  if (v13)
LABEL_9:
    CFRelease(v13);
LABEL_10:
  Code = CFErrorGetCode((CFErrorRef)cf);
  Domain = CFErrorGetDomain((CFErrorRef)cf);
  v18 = CFStringCompare(a2, Domain, 0);
  v20 = Code == a1 && v18 == kCFCompareEqualTo && v15;
  v21 = cf;
  if (v20)
    goto LABEL_17;
  v23 = CFErrorCopyUserInfo((CFErrorRef)cf);
  if (v23)
  {
    v24 = v23;
    if (CFDictionaryContainsKey(v23, CFSTR("numberOfErrorsDeep")) == 1)
    {
      v25 = (const __CFNumber *)CFDictionaryGetValue(v24, CFSTR("numberOfErrorsDeep"));
      if (v25)
      {
        valuePtr = 0;
        CFNumberGetValue(v25, kCFNumberLongType, &valuePtr);
        if (valuePtr > 199)
        {
          CFRelease(v24);
          v21 = cf;
LABEL_17:
          CFRetain(v21);
          *a4 = cf;
          CFRelease(cf);
          if (!v11)
            return;
          v22 = v11;
          goto LABEL_42;
        }
        v30 = valuePtr + 1;
      }
    }
    CFRelease(v24);
  }
LABEL_28:
  v26 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v27 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberLongType, &v30);
  Mutable = CFDictionaryCreateMutable(v26, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  v29 = Mutable;
  if (cf)
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0C9B000], cf);
  if (v27)
    CFDictionaryAddValue(v29, CFSTR("numberOfErrorsDeep"), v27);
  if (v11)
    CFDictionaryAddValue(v29, *v12, v11);
  *a4 = CFErrorCreate(v26, a2, a1, v29);
  if (v27)
    CFRelease(v27);
  if (v11)
    CFRelease(v11);
  if (v29)
    CFRelease(v29);
  if (cf)
  {
    v22 = cf;
LABEL_42:
    CFRelease(v22);
  }
}

void SecCheckErrno(uint64_t a1, CFTypeRef *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFIndex v11;
  __CFString *v12;
  CFStringRef v13;
  const __CFString *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (a2)
  {
    v11 = *__error();
    v12 = (__CFString *)*a2;
    *a2 = 0;
    v13 = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, a3, &a9);
    v14 = (const __CFString *)*MEMORY[0x1E0C9AFD0];
    strerror(v11);
    SecCFCreateErrorWithFormat(v11, v14, v12, a2, v15, CFSTR("%@: [%d] %s"), v16, v17, (char)v13);
    if (v13)
      CFRelease(v13);
  }
}

void SecCFCreateErrorWithFormat(CFIndex a1, const __CFString *a2, __CFString *a3, CFTypeRef *a4, uint64_t a5, const __CFString *a6, uint64_t a7, uint64_t a8, char a9)
{
  SecCFCreateErrorWithFormatAndArguments(a1, a2, a3, a4, 0, a6, &a9);
}

BOOL SecError(int a1, __CFString **a2, CFStringRef format, ...)
{
  const __CFString *v5;
  CFTypeRef v6;
  CFTypeRef cf;
  va_list va;

  va_start(va, format);
  if (a1)
  {
    cf = 0;
    v5 = (const __CFString *)*MEMORY[0x1E0C9AFC8];
    if (a2)
    {
      SecCFCreateErrorWithFormatAndArguments(a1, v5, *a2, &cf, 0, format, va);
      *a2 = (__CFString *)cf;
    }
    else
    {
      SecCFCreateErrorWithFormatAndArguments(a1, v5, 0, &cf, 0, format, va);
      v6 = cf;
      if (cf)
      {
        cf = 0;
        CFRelease(v6);
      }
    }
  }
  return a1 == 0;
}

uint64_t SecRequirementError(uint64_t a1, CFTypeRef *a2, CFStringRef format, ...)
{
  __CFString *v5;
  va_list va;

  va_start(va, format);
  if (a2 && (a1 & 1) == 0)
  {
    v5 = (__CFString *)*a2;
    *a2 = 0;
    SecCFCreateErrorWithFormatAndArguments(-50, (const __CFString *)*MEMORY[0x1E0C9AFC8], v5, a2, 0, format, va);
  }
  return a1;
}

BOOL SecAllocationError(uint64_t a1, CFTypeRef *a2, CFStringRef format, ...)
{
  __CFString *v5;
  va_list va;

  va_start(va, format);
  if (!a1 && a2)
  {
    v5 = (__CFString *)*a2;
    *a2 = 0;
    SecCFCreateErrorWithFormatAndArguments(-108, (const __CFString *)*MEMORY[0x1E0C9AFC8], v5, a2, 0, format, va);
  }
  return a1 != 0;
}

uint64_t der_encode_plist(const __CFString *a1, CFTypeRef *a2, UInt8 *a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return der_encode_plist_repair(a1, a2, 0, a3, a4, a6, a7, a8);
}

uint64_t der_encode_null(CFTypeRef *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v7;

  v5 = ccder_encode_tl();
  if (!v5)
    SecCFCreateErrorWithFormat(-7, (const __CFString *)sSecDERErrorDomain, 0, a1, v2, CFSTR("ccder failed to encode"), v3, v4, v7);
  return v5;
}

uint64_t der_sizeof_set(const __CFSet *a1, uint64_t a2)
{
  __int128 v3;
  uint64_t v4;

  v3 = xmmword_18AA61B50;
  LOBYTE(v3) = 1;
  v4 = a2;
  CFSetApplyFunction(a1, (CFSetApplierFunction)add_value_size, &v3);
  if ((_BYTE)v3)
    return ccder_sizeof();
  else
    return 0;
}

uint64_t add_value_size(uint64_t result, uint64_t a2)
{
  if (*(_BYTE *)a2)
  {
    result = der_sizeof_plist(result, *(_QWORD *)(a2 + 16));
    if (result)
      *(_QWORD *)(a2 + 8) += result;
    else
      *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t der_encode_set_repair(const __CFSet *a1, CFTypeRef *a2, char a3)
{
  CFMutableArrayRef Mutable;
  CFIndex Count;
  unint64_t v8;
  const __CFData *ValueAtIndex;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[4];
  CFRange v15;

  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  v14[0] = 0xAAAAAAAAAAAAAA01;
  v14[1] = a2;
  BYTE1(v14[0]) = a3;
  v14[2] = Mutable;
  v14[3] = 0;
  CFSetApplyFunction(a1, (CFSetApplierFunction)add_sequence_to_array_13255, v14);
  if (!LOBYTE(v14[0]))
  {
    if (Mutable)
      CFRelease(Mutable);
    return 0;
  }
  v15.length = CFArrayGetCount(Mutable);
  v15.location = 0;
  CFArraySortValues(Mutable, v15, (CFComparatorFunction)cfdata_compare_der_contents_13256, 0);
  Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    v8 = Count + 1;
    do
    {
      ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v8 - 2);
      CFDataGetLength(ValueAtIndex);
      CFDataGetBytePtr(ValueAtIndex);
      ccder_encode_body();
      --v8;
    }
    while (v8 > 1);
  }
  if (Mutable)
    CFRelease(Mutable);
  result = ccder_encode_constructed_tl();
  if (!result)
  {
    SecCFCreateErrorWithFormat(-7, (const __CFString *)sSecDERErrorDomain, 0, a2, v11, CFSTR("ccder failed to encode"), v12, v13, v14[0]);
    return 0;
  }
  return result;
}

void add_sequence_to_array_13255(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex v10;
  CFIndex v11;
  __CFData *Mutable;
  UInt8 *MutableBytePtr;
  uint64_t v14;
  CFRange v15;

  if (*(_BYTE *)a2)
  {
    v10 = der_sizeof_plist(a1, *(CFTypeRef **)(a2 + 8), a3, a4, a5, a6, a7, a8);
    if (!v10)
    {
      *(_BYTE *)a2 = 0;
      return;
    }
    v11 = v10;
    Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a2 + 24), v10);
    CFDataSetLength(Mutable, v11);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    v14 = der_encode_plist_repair(a1, *(_QWORD *)(a2 + 8), *(unsigned __int8 *)(a2 + 1), MutableBytePtr, &MutableBytePtr[v11]);
    if (v14)
    {
      v15.length = v14 - (_QWORD)MutableBytePtr;
      v15.location = 0;
      CFDataDeleteBytes(Mutable, v15);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 16), Mutable);
      if (!Mutable)
        return;
    }
    else
    {
      *(_BYTE *)a2 = 0;
      if (!Mutable)
        return;
    }
    CFRelease(Mutable);
  }
}

uint64_t cfdata_compare_der_contents_13256(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length;
  CFIndex v5;
  unint64_t v6;
  size_t v7;
  const UInt8 *BytePtr;
  const UInt8 *v9;
  int v10;
  uint64_t v12;
  uint64_t v13;

  Length = CFDataGetLength(a1);
  v5 = CFDataGetLength(a2);
  v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5)
      v12 = 0;
    else
      v12 = -1;
    if (Length <= v5)
      return v12;
    else
      return 1;
  }
  else
  {
    if (Length >= v5)
      v7 = v5;
    else
      v7 = Length;
    BytePtr = CFDataGetBytePtr(a1);
    v9 = CFDataGetBytePtr(a2);
    v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6)
        LODWORD(v13) = 0;
      if (v10 < 0)
        v13 = 1;
      else
        v13 = v13;
      return v13 << 63 >> 63;
    }
    else
    {
      return 1;
    }
  }
}

uint64_t GetKeybagAssertionQueue()
{
  _QWORD block[5];

  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __GetKeybagAssertionQueue_block_invoke;
  block[3] = &__block_descriptor_tmp_13260;
  block[4] = &GetKeybagAssertionQueue_sGetKeybagAssertionQueueSingleton;
  if (GetKeybagAssertionQueue_sGetKeybagAssertionQueueOnce != -1)
    dispatch_once(&GetKeybagAssertionQueue_sGetKeybagAssertionQueueOnce, block);
  return GetKeybagAssertionQueue_sGetKeybagAssertionQueueSingleton;
}

uint64_t MobileKeyBagLibrary()
{
  uint64_t v0;
  void *v2;

  if (MobileKeyBagLibraryCore_frameworkLibrary)
    return MobileKeyBagLibraryCore_frameworkLibrary;
  MobileKeyBagLibraryCore_frameworkLibrary = _sl_dlopen();
  v0 = MobileKeyBagLibraryCore_frameworkLibrary;
  if (!MobileKeyBagLibraryCore_frameworkLibrary)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

CFURLRef SecCopyURLForFileInBaseDirectory(const __CFString *a1, uint64_t a2)
{
  const __CFURL *v4;
  const __CFAllocator *v5;
  const __CFString *Copy;
  const __CFString *v7;
  CFURLRef v8;

  v4 = SecCopyBaseFilesURL(1);
  if (a2)
  {
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Copy = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@/%@"), a1, a2);
  }
  else
  {
    if (!a1)
      goto LABEL_10;
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Copy = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1);
  }
  v7 = Copy;
  if (v4 && Copy)
  {
    v8 = CFURLCreateCopyAppendingPathComponent(v5, v4, Copy, a2 == 0);
    CFRelease(v7);
LABEL_11:
    CFRelease(v4);
    return v8;
  }
  if (Copy)
    CFRelease(Copy);
LABEL_10:
  v8 = 0;
  if (v4)
    goto LABEL_11;
  return v8;
}

void WithPathInDirectory(const __CFURL *a1, uint64_t a2)
{
  UInt8 __b[1024];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    memset(__b, 170, sizeof(__b));
    CFURLGetFileSystemRepresentation(a1, 0, __b, 1024);
    (*(void (**)(uint64_t, UInt8 *))(a2 + 16))(a2, __b);
    CFRelease(a1);
  }
}

void WithPathInKeychainDirectory(uint64_t a1, uint64_t a2)
{
  const __CFURL *v4;

  syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0);
  v4 = SecCopyURLForFileInBaseDirectory(CFSTR("Library/Keychains"), a1);
  WithPathInDirectory(v4, a2);
}

void __security_simulatecrash(void *a1, unsigned int a2)
{
  NSObject *v4;
  int v5;
  uint64_t v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  _BYTE buf[24];
  void *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  secLogObjForScope("SecError");
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = a1;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "Simulating crash, reason: %@, code=%08x", buf, 0x12u);
  }

  v5 = __simulate_crash_counter;
  if (__simulate_crash_counter != -1)
    goto LABEL_4;
  if (!CrashReporterSupportLibraryCore_frameworkLibrary)
  {
    *(_OWORD *)buf = xmmword_1E1FDC298;
    *(_QWORD *)&buf[16] = 0;
    CrashReporterSupportLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  if (!CrashReporterSupportLibraryCore_frameworkLibrary)
  {
    v5 = __simulate_crash_counter;
LABEL_4:
    __simulate_crash_counter = v5 + 1;
    return;
  }
  v6 = getpid();
  v7 = a1;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = buf;
  *(_QWORD *)&buf[16] = 0x2020000000;
  v8 = getSimulateCrashSymbolLoc_ptr;
  v13 = getSimulateCrashSymbolLoc_ptr;
  if (!getSimulateCrashSymbolLoc_ptr)
  {
    v9 = CrashReporterSupportLibrary();
    v8 = dlsym(v9, "SimulateCrash");
    *(_QWORD *)(*(_QWORD *)&buf[8] + 24) = v8;
    getSimulateCrashSymbolLoc_ptr = v8;
  }
  _Block_object_dispose(buf, 8);
  if (!v8)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "BOOL soft_SimulateCrash(pid_t, mach_exception_data_type_t, NSString *__strong)");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "handleFailureInFunction:file:lineNumber:description:", v11, CFSTR("simulate_crash.m"), 22, CFSTR("%s"), dlerror());

    __break(1u);
  }
  ((void (*)(uint64_t, _QWORD, id))v8)(v6, a2, v7);

}

void sub_18AA2228C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *CrashReporterSupportLibrary()
{
  void *v0;
  void *v2;
  void *v3;

  if (!CrashReporterSupportLibraryCore_frameworkLibrary)
    CrashReporterSupportLibraryCore_frameworkLibrary = _sl_dlopen();
  v0 = (void *)CrashReporterSupportLibraryCore_frameworkLibrary;
  if (!CrashReporterSupportLibraryCore_frameworkLibrary)
  {
    objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v0 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *CrashReporterSupportLibrary(void)");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", v2, CFSTR("simulate_crash.m"), 18, CFSTR("%s"), 0);

    __break(1u);
    free(v3);
  }
  return v0;
}

xpc_object_t SecCreateXPCObjectWithCFError(__CFError *a1)
{
  xpc_object_t v2;
  const __CFString *Domain;
  int64_t Code;
  const __CFString *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  size_t v13;
  UInt8 *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  _QWORD v21[6];
  _QWORD v22[5];

  v2 = xpc_dictionary_create(0, 0, 0);
  Domain = CFErrorGetDomain(a1);
  v21[0] = MEMORY[0x1E0C809B0];
  v21[1] = 0x40000000;
  v21[2] = __SecXPCDictionarySetCFString_block_invoke;
  v21[3] = &__block_descriptor_tmp_13381;
  v21[4] = v2;
  v21[5] = "domain";
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 0x40000000;
  v22[2] = __CFStringPerformWithCString_block_invoke;
  v22[3] = &unk_1E1FDBF70;
  v22[4] = v21;
  CFStringPerformWithCStringAndLength(Domain, (uint64_t)v22);
  Code = CFErrorGetCode(a1);
  xpc_dictionary_set_int64(v2, "code", Code);
  v5 = (const __CFString *)CFErrorCopyUserInfo(a1);
  v12 = der_sizeof_plist(v5, 0, v6, v7, v8, v9, v10, v11);
  if (v12)
  {
    v13 = v12;
    v14 = (UInt8 *)malloc_type_malloc(v12, 0x4ABABCFuLL);
    v15 = (unint64_t)&v14[v13];
    v19 = (const void *)der_encode_plist_repair(v5, 0, 0, v14, v15, v16, v17, v18);
    if (v19)
      xpc_dictionary_set_data(v2, "userinfo", v19, v15 - (_QWORD)v19);
    free(v14);
  }
  CFRelease(v5);
  return v2;
}

uint64_t SecGetCurrentServerLoggingInfo(uint64_t a1)
{
  uint64_t v1;
  _QWORD v3[6];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0xAAAAAAAAAAAAAAAALL;
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __SecGetCurrentServerLoggingInfo_block_invoke;
  v3[3] = &unk_1E1FDC300;
  v3[4] = &v4;
  v3[5] = a1;
  _os_activity_initiate(&dword_18A900000, "SecGetCurrentServerLoggingInfo", OS_ACTIVITY_FLAG_DEFAULT, v3);
  v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

BOOL __void_to_dict_error_request_block_invoke(uint64_t a1, void *a2, __CFString **a3)
{
  CFTypeRef v4;

  v4 = SecXPCDictionaryCopyPListAndPossiblyMutateMessage(1, a2, "status", a3);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
  return v4 != 0;
}

uint64_t SecSetLoggingInfoForXPCScope(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD activity_block[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = -86;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecSetLoggingInfoForXPCScope_block_invoke;
  activity_block[3] = &unk_1E1FDC328;
  activity_block[4] = &v5;
  activity_block[5] = a1;
  activity_block[6] = a2;
  _os_activity_initiate(&dword_18A900000, "SecSetLoggingInfoForXPCScope", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

size_t __dict_to_error_request_block_invoke_13392(uint64_t a1, void *a2, __CFString **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return SecXPCDictionarySetPListWithRepair(a2, "query", *(const __CFString **)(a1 + 32), a3, a5, a6, a7, a8);
}

uint64_t SecSetLoggingInfoForCircleScope(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD activity_block[7];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  char v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = -86;
  activity_block[0] = MEMORY[0x1E0C809B0];
  activity_block[1] = 0x40000000;
  activity_block[2] = __SecSetLoggingInfoForCircleScope_block_invoke;
  activity_block[3] = &unk_1E1FDC350;
  activity_block[4] = &v5;
  activity_block[5] = a1;
  activity_block[6] = a2;
  _os_activity_initiate(&dword_18A900000, "SecSetLoggingInfoForCircleScope", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

char *Security::CFMake::makestring(CFAllocatorRef *this)
{
  CFAllocatorRef v2;
  char *result;
  char *v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;

  v2 = *this;
  if (*(_BYTE *)*this == 39)
  {
    v2 = (CFAllocatorRef)((char *)v2 + 1);
    *this = v2;
    result = strchr((char *)v2, 39);
    if (!result)
      return result;
    v4 = result + 1;
  }
  else
  {
    v5 = MEMORY[0x1E0C80978];
    v4 = (char *)*this;
    do
    {
      while (1)
      {
        v7 = *++v4;
        v6 = v7;
        if ((v7 & 0x80000000) != 0)
          break;
        if ((*(_DWORD *)(v5 + 4 * v6 + 60) & 0x500) == 0)
          goto LABEL_9;
      }
    }
    while (__maskrune(v6, 0x500uLL));
LABEL_9:
    result = v4;
  }
  *this = (CFAllocatorRef)v4;
  return (char *)CFStringCreateWithBytes(this[2], (const UInt8 *)v2, result - (char *)v2, 0x8000100u, 0);
}

uint64_t Security::CFScan::scan(Security::CFScan *this, const __CFString *a2)
{
  uint64_t v4;
  int v5;
  _QWORD **v6;
  _QWORD *v7;
  _DWORD **v8;
  _DWORD *v9;
  int v10;
  CFDataRef v11;
  _BOOL8 v12;
  CFTypeID v13;
  CFTypeID v15;
  uint64_t v16;
  int v17;
  _QWORD ***v18;
  const __CFString ***v19;
  CFTypeID v20;
  int v21;
  CFTypeID TypeID;
  int v23;
  int **v24;
  int *v25;
  int v26;
  _DWORD ***v27;
  int **v28;
  int *v29;
  int v30;
  CFTypeID v31;
  CFTypeID v32;
  int v33;
  std::string ***v34;
  std::string **v35;
  CFTypeID v36;
  _DWORD ***v37;
  _DWORD **v38;
  int ***v39;
  int **v40;
  std::string __str;

  while (Security::CFMunge::next(this) == 64)
  {
    v4 = (*(_QWORD *)this)++;
    v5 = *(char *)(v4 + 1);
    if (v5 == 69)
    {
      *(_QWORD *)this = v4 + 2;
      v8 = (_DWORD **)*((_QWORD *)this + 1);
      v9 = *v8;
      *v8 += 2;
      *((_DWORD *)this + 6) = *v9;
    }
    else if (v5 == 65)
    {
      *(_QWORD *)this = v4 + 2;
      v6 = (_QWORD **)*((_QWORD *)this + 1);
      v7 = (*v6)++;
      *((_QWORD *)this + 2) = *v7;
    }
  }
  v10 = Security::CFMunge::next(this);
  if (v10 > 90)
  {
    if (v10 > 122)
    {
      if (v10 == 123)
      {
        if (!a2)
          return (uint64_t)Security::CFScan::scandictionary(this, 0);
        v13 = CFGetTypeID(a2);
        if (v13 == CFDictionaryGetTypeID())
          return (uint64_t)Security::CFScan::scandictionary(this, (const __CFDictionary *)a2);
      }
    }
    else if (v10 == 91)
    {
      if (!a2)
        return Security::CFScan::scanarray(this, 0);
      v15 = CFGetTypeID(a2);
      if (v15 == CFArrayGetTypeID())
        return Security::CFScan::scanarray(this, (CFArrayRef)a2);
    }
    return 0;
  }
  if (!v10)
    return 1;
  if (v10 == 37)
  {
    v12 = 0;
    v16 = (*(_QWORD *)this)++;
    v17 = *(char *)(v16 + 1);
    if (v17 <= 82)
    {
      if (v17 <= 67)
      {
        if (v17 != 65)
        {
          if (v17 != 66)
            return v12;
          TypeID = CFBooleanGetTypeID();
          v23 = Security::CFScan::typescan(this, a2, TypeID);
          v12 = v23 == 1;
          if (v23)
            return v12;
          if (**(_BYTE **)this == 102)
          {
            v24 = (int **)*((_QWORD *)this + 1);
            v25 = *v24;
            *v24 += 2;
            v26 = *v25;
            v27 = (_DWORD ***)*((_QWORD *)this + 1);
            v28 = (*v27)++;
            if ((const __CFString *)*MEMORY[0x1E0C9AE50] != a2 || *((_BYTE *)this + 28))
              return 1;
            v29 = *v28;
            v30 = *v29 | v26;
          }
          else
          {
            if (*((_BYTE *)this + 28))
              return 1;
            v30 = *MEMORY[0x1E0C9AE50] == (_QWORD)a2;
            v39 = (int ***)*((_QWORD *)this + 1);
            v40 = (*v39)++;
            v29 = *v40;
          }
          *v29 = v30;
          return 1;
        }
        v31 = CFArrayGetTypeID();
      }
      else
      {
        switch(v17)
        {
          case 'D':
            v31 = CFDictionaryGetTypeID();
            break;
          case 'N':
            v31 = CFNumberGetTypeID();
            break;
          case 'O':
            if (!*((_BYTE *)this + 28))
            {
              v18 = (_QWORD ***)*((_QWORD *)this + 1);
              v19 = (const __CFString ***)(*v18)++;
              **v19 = a2;
            }
            return 1;
          default:
            return v12;
        }
      }
      return Security::CFScan::typescan(this, a2, v31) == 1;
    }
    if (v17 <= 99)
    {
      if (v17 != 83)
      {
        if (v17 != 88)
          return v12;
        v31 = CFDataGetTypeID();
        return Security::CFScan::typescan(this, a2, v31) == 1;
      }
    }
    else
    {
      if (v17 == 100)
      {
        *(_QWORD *)this = v16 + 2;
        if (!a2)
          return 1;
        v36 = CFGetTypeID(a2);
        if (v36 != CFNumberGetTypeID())
          return 0;
        v21 = Security::cfNumber<int>((const __CFNumber *)a2);
        goto LABEL_57;
      }
      if (v17 != 115)
      {
        if (v17 != 117)
          return v12;
        *(_QWORD *)this = v16 + 2;
        if (!a2)
          return 1;
        v20 = CFGetTypeID(a2);
        if (v20 != CFNumberGetTypeID())
          return 0;
        v21 = Security::cfNumber<unsigned int>((const __CFNumber *)a2);
LABEL_57:
        if (!*((_BYTE *)this + 28))
        {
          v37 = (_DWORD ***)*((_QWORD *)this + 1);
          v38 = (*v37)++;
          **v38 = v21;
        }
        return 1;
      }
    }
    v32 = CFStringGetTypeID();
    v33 = Security::CFScan::typescan(this, a2, v32);
    v12 = v33 == 1;
    if (v33)
      return v12;
    Security::cfString(&__str, a2);
    if (!*((_BYTE *)this + 28))
    {
      v34 = (std::string ***)*((_QWORD *)this + 1);
      v35 = (*v34)++;
      std::string::operator=(*v35, &__str);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    return 1;
  }
  if (v10 != 61)
    return 0;
  ++*(_QWORD *)this;
  v11 = Security::CFMake::make(this);
  v12 = CFEqual(a2, v11) != 0;
  CFRelease(v11);
  return v12;
}

void sub_18AA22E38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFDataRef Security::CFScan::scandictionary(Security::CFScan *this, const __CFDictionary *a2)
{
  BOOL v4;
  CFDataRef result;
  int v6;
  CFDataRef v7;
  char v8;
  const void *Value;

  ++*(_QWORD *)this;
  while (1)
  {
    v4 = Security::CFMunge::next(this) == 125;
    result = (CFDataRef)v4;
    if (v4)
      break;
    v6 = Security::CFMunge::next(this);
    if (v6 == 63)
      ++*(_QWORD *)this;
    result = Security::CFMake::make(this);
    if (!result)
      break;
    v7 = result;
    v8 = *((_BYTE *)this + 28);
    if (a2)
      Value = CFDictionaryGetValue(a2, result);
    else
      Value = 0;
    if (v6 != 63 && !Value
      || (*((_BYTE *)this + 28) |= Value == 0, Security::CFMunge::next(this) != 61)
      || (++*(_QWORD *)this, (Security::CFScan::scan(this, Value) & 1) == 0))
    {
      CFRelease(v7);
      return 0;
    }
    *((_BYTE *)this + 28) = v8;
    CFRelease(v7);
  }
  return result;
}

uint64_t Security::CFScan::scanarray(Security::CFScan *this, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  BOOL v7;
  const void *ValueAtIndex;
  char v9;
  char v10;

  ++*(_QWORD *)this;
  Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
    v10 = 0;
  }
  else
  {
    v5 = Count;
    v6 = 0;
    v7 = 1;
    while (1)
    {
      if (Security::CFMunge::next(this) == 93)
      {
        v9 = 1;
        goto LABEL_10;
      }
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, v6);
      if ((Security::CFScan::scan(this, ValueAtIndex) & 1) == 0)
        break;
      v7 = v5 > ++v6;
      if (v5 == v6)
        goto LABEL_10;
    }
    v9 = 0;
LABEL_10:
    v10 = v7 & v9;
  }
  return v10 & 1;
}

uint64_t Security::CFScan::typescan(Security::CFScan *this, CFTypeRef cf, uint64_t a3)
{
  uint64_t v5;
  int v6;
  _QWORD ***v7;
  _QWORD **v8;

  if (cf && CFGetTypeID(cf) != a3)
    return 0xFFFFFFFFLL;
  v5 = (*(_QWORD *)this)++;
  v6 = *(char *)(v5 + 1);
  if (v6 == 110)
  {
    *(_QWORD *)this = v5 + 2;
    return 1;
  }
  if (v6 == 79)
  {
    *(_QWORD *)this = v5 + 2;
    if (!*((_BYTE *)this + 28))
    {
      v7 = (_QWORD ***)*((_QWORD *)this + 1);
      v8 = (*v7)++;
      **v8 = cf;
    }
    return 1;
  }
  return 0;
}

uint64_t Security::cfNumber<unsigned int>(const __CFNumber *a1)
{
  Security::CFError *Value;
  unint64_t valuePtr;

  valuePtr = 0xAAAAAAAAAAAAAAAALL;
  Value = (Security::CFError *)CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr);
  if (!(_DWORD)Value)
    Security::CFError::throwMe(Value);
  return valuePtr;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

uint64_t Security::cfNumber<int>(const __CFNumber *a1)
{
  Security::CFError *Value;
  unsigned int valuePtr;

  valuePtr = -1431655766;
  Value = (Security::CFError *)CFNumberGetValue(a1, kCFNumberIntType, &valuePtr);
  if (!(_DWORD)Value)
    Security::CFError::throwMe(Value);
  return valuePtr;
}

__CFDictionary *Security::cfadd(Security *this, __CFDictionary *a2, const char *a3, ...)
{
  __CFDictionary *result;
  _QWORD v5[3];
  int v6;
  va_list v7;
  va_list va;

  va_start(va, a3);
  va_copy(v7, va);
  v5[0] = a2;
  v5[1] = &v7;
  v5[2] = 0;
  v6 = 0;
  result = (__CFDictionary *)Security::CFMunge::next((Security::CFMunge *)v5);
  if ((_DWORD)result == 123)
  {
    ++v5[0];
    return Security::CFMake::add((Security::CFMake *)v5, this);
  }
  return result;
}

uint64_t Security::cfscan(const __CFString *this, const void *a2, const char *a3, ...)
{
  va_list v4;
  _QWORD v5[3];
  int v6;
  char v7;
  va_list va;

  va_start(va, a3);
  va_copy(v4, va);
  v5[0] = a2;
  v5[1] = &v4;
  v5[2] = 0;
  v6 = 0;
  v7 = 0;
  return Security::CFScan::scan((Security::CFScan *)v5, this);
}

BOOL Security::SecCFObject::equal(Security::SecCFObject *this, Security::SecCFObject *a2)
{
  return this == a2;
}

uint64_t Security::SecCFObject::copyFormattingDesc(Security::SecCFObject *this, const __CFDictionary *a2)
{
  return 0;
}

uint64_t Security::SecCFObject::copyDebugDesc(Security::SecCFObject *this)
{
  return 0;
}

void DYLDCache::~DYLDCache(DYLDCache *this)
{
  DYLDCache::~DYLDCache(this);
  JUMPOUT(0x18D76FAA0);
}

{
  *(_QWORD *)this = &off_1E1FC7FA8;
  munmap(*((void **)this + 2), *((_QWORD *)this + 3));
  Security::UnixPlusPlus::FileDesc::closeAndLog((DYLDCache *)((char *)this + 8));
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

const char *DYLDCache::matchArchitecture(char *__s1)
{
  const char *v2;
  int v3;
  int v4;
  void *v5;

  v2 = "\a";
  while (1)
  {
    v3 = strcmp(__s1, v2 + 8);
    if (!v3)
      break;
    v4 = *((_DWORD *)v2 + 9);
    v2 += 36;
    if (!v4)
    {
      v2 = (const char *)&unk_18AA61038;
      break;
    }
  }
  if (*(_QWORD *)__s1 == 0x2031765F646C7964)
    v5 = &DYLDCache::defaultArchitecture;
  else
    v5 = 0;
  if (v3)
    return (const char *)v5;
  else
    return v2;
}

void Security::Syslog::warning(Security::Syslog *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  vsyslog(4, (const char *)this, va);
}

void Security::Syslog::notice(Security::Syslog *this, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  vsyslog(5, (const char *)this, va);
}

Security::UnixError *Security::Mutex::lock(pthread_mutex_t *this)
{
  Security::UnixError *result;

  result = (Security::UnixError *)pthread_mutex_lock(this);
  if ((_DWORD)result)
    Security::UnixError::throwMe(result);
  return result;
}

CFDataRef Security::CFMallocData::operator __CFData const*(uint64_t a1)
{
  CFDataRef result;

  result = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)a1, *(_QWORD *)(a1 + 8), (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
  if (!result)
    Security::CFError::throwMe(0);
  *(_QWORD *)a1 = 0;
  return result;
}

uint64_t Security::cfarrayApplyBlock_func(Security *this, uint64_t (**a2)(_QWORD, _QWORD), const void *a3)
{
  return ((uint64_t (**)(_QWORD, Security *))a2)[2](a2, this);
}

void Security::cfString(std::string *this, CFStringRef theString)
{
  const char *CStringPtr;
  char *v5;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  size_t v8;
  void *v9;

  if (!theString)
  {
    v5 = (char *)&unk_18AA61AAF;
    goto LABEL_5;
  }
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  if (CStringPtr)
  {
    v5 = (char *)CStringPtr;
LABEL_5:
    std::string::basic_string[abi:ne180100]<0>(this, v5);
    return;
  }
  this->__r_.__value_.__r.__words[0] = 0;
  this->__r_.__value_.__l.__size_ = 0;
  this->__r_.__value_.__r.__words[2] = 0;
  Length = CFStringGetLength(theString);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  if (MaximumSizeForEncoding <= -2)
    std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
  v8 = MaximumSizeForEncoding + 1;
  v9 = operator new(MaximumSizeForEncoding + 1);
  bzero(v9, v8);
  if (CFStringGetCString(theString, (char *)v9, v8, 0x8000100u))
    std::string::__assign_external(this, (const std::string::value_type *)v9);
  operator delete(v9);
}

void sub_18AA2353C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v2;

  operator delete(v2);
  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(a1);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  std::string::size_type v4;

  v4 = strlen(__s);
  return std::string::__assign_external(this, __s, v4);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  unint64_t v6;
  std::string *v7;
  std::string::size_type size;
  unint64_t v9;
  unint64_t v10;

  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    v10 = this->__r_.__value_.__r.__words[2];
    v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    v6 = HIBYTE(v10);
    v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    v7 = this;
    if (__n > 0x16)
    {
      size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((_BYTE *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0)
    this->__r_.__value_.__l.__size_ = __n;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

void Security::cfString(std::string *this, __CFString *cf)
{
  CFTypeID v4;
  const __CFURL *v5;
  const __CFString *v6;

  if (!cf)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA13);
  v4 = CFGetTypeID(cf);
  if (v4 == CFStringGetTypeID())
  {
    Security::cfString(this, cf);
  }
  else if (v4 == CFURLGetTypeID())
  {
    Security::cfString((Security *)this, (const __CFURL *)cf);
  }
  else if (v4 == CFBundleGetTypeID())
  {
    v5 = CFBundleCopyBundleURL((CFBundleRef)cf);
    Security::cfStringRelease((Security *)this, v5);
  }
  else
  {
    v6 = CFCopyDescription(cf);
    Security::cfString(this, v6);
    Security::CFRef<__CFString const*>::~CFRef((const void **)&v6);
  }
}

void sub_18AA23748(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFString const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t Security::mmapDeallocatorAllocate(Security *this, uint64_t a2, unint64_t a3, void *a4)
{
  return 0;
}

uint64_t Security::mmapPreferredSize(Security *this, uint64_t a2, unint64_t a3, void *a4)
{
  return (uint64_t)this + 8;
}

uint64_t std::string::basic_string[abi:ne180100](uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;

  if (a2 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (a2 > 0x16)
  {
    v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17)
      v4 = a2 | 7;
    v5 = v4 + 1;
    v6 = operator new(v4 + 1);
    *(_QWORD *)(a1 + 8) = a2;
    *(_QWORD *)(a1 + 16) = v5 | 0x8000000000000000;
    *(_QWORD *)a1 = v6;
  }
  else
  {
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 23) = a2;
  }
  return a1;
}

void Security::Dispatch::Group::~Group(Security::Dispatch::Group *this)
{
  Security::Dispatch::Group::~Group(this);
  JUMPOUT(0x18D76FAA0);
}

{
  *(_QWORD *)this = &off_1E1FC93A0;
  dispatch_group_wait(*((dispatch_group_t *)this + 11), 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(*((dispatch_object_t *)this + 11));
  std::exception_ptr::~exception_ptr((std::exception_ptr *)this + 10);
  Security::Mutex::~Mutex((pthread_mutex_t *)((char *)this + 8));
}

void Security::Dispatch::Semaphore::~Semaphore(dispatch_object_t *this)
{
  *this = (dispatch_object_t)&off_1E1FC93E0;
  dispatch_release(this[1]);
}

{
  *this = (dispatch_object_t)&off_1E1FC93E0;
  dispatch_release(this[1]);
  JUMPOUT(0x18D76FAA0);
}

void Security::Dispatch::SemaphoreWait::~SemaphoreWait(Security::Dispatch::SemaphoreWait *this)
{
  *(_QWORD *)this = &off_1E1FC9380;
  if (*((_BYTE *)this + 16))
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*((_QWORD *)this + 1) + 8));
}

{
  *(_QWORD *)this = &off_1E1FC9380;
  if (*((_BYTE *)this + 16))
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*((_QWORD *)this + 1) + 8));
  JUMPOUT(0x18D76FAA0);
}

uint64_t ___ZN8Security8Dispatch23ExceptionAwareEnqueuing21enqueueWithDispatcherEU13block_pointerFvU13block_pointerFvvEES3__block_invoke(uint64_t result)
{
  if (!*(_BYTE *)(*(_QWORD *)(result + 40) + 64))
    return (*(uint64_t (**)(void))(*(_QWORD *)(result + 32) + 16))();
  return result;
}

void sub_18AA239D0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;

  __cxa_begin_catch(a1);
  a11 = v12;
  a12 = 0xAAAAAAAAAAAAAA01;
  Security::Mutex::lock((pthread_mutex_t *)v12);
  *(_BYTE *)(v12 + 64) = 1;
  std::current_exception();
  std::exception_ptr::operator=((std::exception_ptr *)(v12 + 72), &a10);
  std::exception_ptr::~exception_ptr(&a10);
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&a11);
  __cxa_end_catch();
  JUMPOUT(0x18AA239C0);
}

void sub_18AA23A1C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void Security::Dispatch::Group::wait(Security::Dispatch::Group *this)
{
  std::exception_ptr v2;
  std::exception_ptr v3;

  dispatch_group_wait(*((dispatch_group_t *)this + 11), 0xFFFFFFFFFFFFFFFFLL);
  if (*((_BYTE *)this + 72))
  {
    *((_BYTE *)this + 72) = 0;
    std::exception_ptr::exception_ptr(&v3, (const std::exception_ptr *)this + 10);
    v2.__ptr_ = &v3;
    std::rethrow_exception(v2);
    __break(1u);
  }
}

void sub_18AA23A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
  std::exception_ptr::~exception_ptr(&a10);
  _Unwind_Resume(a1);
}

_DWORD *Security::BlobWrapper::alloc(Security::BlobWrapper *this, unint64_t a2)
{
  _DWORD *v2;
  unsigned int v4;
  _DWORD *v5;

  if (a2 > 0xFFFFFFFFFFFFFFF7)
    return 0;
  v4 = a2 + 8;
  v5 = malloc_type_malloc(a2 + 8, 0x154CD2DFuLL);
  v2 = v5;
  if (v5)
  {
    *v5 = 17555194;
    v5[1] = bswap32(v4);
    memcpy(v5 + 2, this, v4 - 8);
  }
  return v2;
}

void Security::UnixError::~UnixError(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x18D76FAA0);
}

uint64_t Security::UnixError::what(Security::UnixError *this)
{
  return (uint64_t)this + 8;
}

uint64_t Security::UnixError::osStatus(Security::UnixError *this)
{
  return (*((_DWORD *)this + 36) + 100000);
}

uint64_t Security::UnixError::unixError(Security::UnixError *this)
{
  return *((unsigned int *)this + 36);
}

void Security::MacOSError::~MacOSError(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x18D76FAA0);
}

uint64_t Security::MacOSError::what(Security::MacOSError *this)
{
  return (uint64_t)this + 8;
}

uint64_t Security::MacOSError::osStatus(Security::MacOSError *this)
{
  return *((unsigned int *)this + 36);
}

uint64_t Security::MacOSError::unixError(Security::MacOSError *this)
{
  unsigned int v1;

  v1 = *((_DWORD *)this + 36) - 100000;
  if (v1 >= 0x100)
    return 0xFFFFFFFFLL;
  else
    return v1;
}

void Security::CFError::~CFError(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x18D76FAA0);
}

const char *Security::CFError::what(Security::CFError *this)
{
  return "CoreFoundation error";
}

uint64_t Security::CFError::osStatus(Security::CFError *this)
{
  return 4294962336;
}

uint64_t Security::CFError::unixError(Security::CFError *this)
{
  return 14;
}

void Security::ModuleNexusError::~ModuleNexusError(std::exception *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x18D76FAA0);
}

uint64_t Security::ModuleNexusError::osStatus(Security::ModuleNexusError *this)
{
  return 4294967246;
}

uint64_t Security::ModuleNexusError::unixError(Security::ModuleNexusError *this)
{
  return 22;
}

void Security::CommonError::LogBacktrace(Security::CommonError *this)
{
  NSObject *v1;
  __int128 v2;
  int v3;
  char **v4;
  char **v5;
  uint64_t i;
  std::string *v7;
  char *v8;
  const char *v9;
  char *v10;
  std::string::value_type *v11;
  std::string::size_type v12;
  std::string::size_type v13;
  NSObject *v14;
  std::string *v15;
  int v16;
  char *__stringp;
  std::string v18;
  int status;
  std::string *v20;
  void *v21[2];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v1 = secLogObjForScope("security_exception");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v35 = v2;
    v36 = v2;
    v33 = v2;
    v34 = v2;
    v31 = v2;
    v32 = v2;
    v29 = v2;
    v30 = v2;
    v27 = v2;
    v28 = v2;
    v25 = v2;
    v26 = v2;
    v23 = v2;
    v24 = v2;
    *(_OWORD *)v21 = v2;
    v22 = v2;
    v3 = backtrace(v21, 32);
    v4 = backtrace_symbols(v21, v3);
    v5 = v4;
    memset(&v18, 0, sizeof(v18));
    if (v3 < 1)
    {
      free(v4);
    }
    else
    {
      for (i = 0; i != v3; ++i)
      {
        if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
        {
          v18.__r_.__value_.__l.__size_ = 0;
          v7 = (std::string *)v18.__r_.__value_.__r.__words[0];
        }
        else
        {
          *((_BYTE *)&v18.__r_.__value_.__s + 23) = 0;
          v7 = &v18;
        }
        v7->__r_.__value_.__s.__data_[0] = 0;
        __stringp = v5[i];
        while (1)
        {
          v8 = strsep(&__stringp, " ");
          v9 = v8;
          if (!v8)
            break;
          if (*v8)
          {
            status = 0;
            v10 = __cxa_demangle(v8, 0, 0, &status);
            v11 = v10;
            if (status)
            {
              v12 = strlen(v9);
              std::string::append(&v18, v9, v12);
            }
            else
            {
              v13 = strlen(v10);
              std::string::append(&v18, v11, v13);
            }
            std::string::append(&v18, " ", 1uLL);
            if (v11)
              free(v11);
          }
          else
          {
            std::string::append(&v18, " ", 1uLL);
          }
        }
        v14 = secLogObjForScope("security_exception");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v15 = &v18;
          else
            v15 = (std::string *)v18.__r_.__value_.__r.__words[0];
          status = 136315138;
          v20 = v15;
          _os_log_debug_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEBUG, "%s", (uint8_t *)&status, 0xCu);
        }
      }
      v16 = SHIBYTE(v18.__r_.__value_.__r.__words[2]);
      free(v5);
      if (v16 < 0)
        operator delete(v18.__r_.__value_.__l.__data_);
    }
  }
}

void sub_18AA23E8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _Unwind_Resume(exception_object);
}

Security::UnixError *Security::UnixError::UnixError(Security::UnixError *this, int a2)
{
  NSObject *v3;
  _BOOL8 v4;
  uint64_t v5;
  uint8_t buf[4];
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)((char *)this + 72) = xmmword_18AA61186;
  *(_OWORD *)((char *)this + 88) = unk_18AA61196;
  *(_OWORD *)((char *)this + 104) = xmmword_18AA611A6;
  *(_OWORD *)((char *)this + 120) = unk_18AA611B6;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)((char *)this + 24) = unk_18AA61156;
  *(_OWORD *)((char *)this + 40) = xmmword_18AA61166;
  *(_OWORD *)((char *)this + 56) = unk_18AA61176;
  *((_QWORD *)this + 17) = 128;
  *(_QWORD *)this = &off_1E1FC9400;
  *((_DWORD *)this + 36) = a2;
  snprintf((char *)this + 8, *((_QWORD *)this + 17), "UNIX error exception: %d", *((_DWORD *)this + 36));
  v3 = secLogObjForScope("security_exception");
  v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    v5 = (*(uint64_t (**)(Security::UnixError *))(*(_QWORD *)this + 16))(this);
    *(_DWORD *)buf = 136315138;
    v8 = v5;
    _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
  }
  Security::CommonError::LogBacktrace((Security::CommonError *)v4);
  return this;
}

void sub_18AA23FDC(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void Security::UnixError::throwMe(Security::UnixError *this)
{
  int v1;
  Security::UnixError *exception;

  v1 = (int)this;
  exception = (Security::UnixError *)__cxa_allocate_exception(0x98uLL);
  Security::UnixError::UnixError(exception, v1);
}

void sub_18AA2402C(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

Security::MacOSError *Security::MacOSError::MacOSError(Security::MacOSError *this, int a2)
{
  NSObject *v4;
  _BOOL8 v5;
  uint64_t v6;
  uint8_t buf[4];
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)((char *)this + 72) = xmmword_18AA61186;
  *(_OWORD *)((char *)this + 88) = unk_18AA61196;
  *(_OWORD *)((char *)this + 104) = xmmword_18AA611A6;
  *(_OWORD *)((char *)this + 120) = unk_18AA611B6;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)((char *)this + 24) = unk_18AA61156;
  *(_OWORD *)((char *)this + 40) = xmmword_18AA61166;
  *(_OWORD *)((char *)this + 56) = unk_18AA61176;
  *((_QWORD *)this + 17) = 128;
  *(_QWORD *)this = &off_1E1FC82F0;
  *((_DWORD *)this + 36) = a2;
  snprintf((char *)this + 8, *((_QWORD *)this + 17), "MacOS error: %d", *((_DWORD *)this + 36));
  if (a2 != -67050)
  {
    v4 = secLogObjForScope("security_exception");
    v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      v6 = (*(uint64_t (**)(Security::MacOSError *))(*(_QWORD *)this + 16))(this);
      *(_DWORD *)buf = 136315138;
      v9 = v6;
      _os_log_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
    }
    Security::CommonError::LogBacktrace((Security::CommonError *)v5);
  }
  return this;
}

void sub_18AA2417C(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void Security::MacOSError::throwMe(Security::MacOSError *this, uint64_t a2, const char *a3, ...)
{
  int v3;
  Security::MacOSError *exception;

  v3 = (int)this;
  exception = (Security::MacOSError *)__cxa_allocate_exception(0x98uLL);
  Security::MacOSError::MacOSError(exception, v3);
}

void sub_18AA241D0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

Security::CFError *Security::CFError::CFError(Security::CFError *this)
{
  NSObject *v2;
  _BOOL8 v3;
  uint8_t v5[16];

  *(_OWORD *)((char *)this + 72) = xmmword_18AA61186;
  *(_OWORD *)((char *)this + 88) = unk_18AA61196;
  *(_OWORD *)((char *)this + 104) = xmmword_18AA611A6;
  *(_OWORD *)((char *)this + 120) = unk_18AA611B6;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)((char *)this + 24) = unk_18AA61156;
  *(_OWORD *)((char *)this + 40) = xmmword_18AA61166;
  *(_OWORD *)((char *)this + 56) = unk_18AA61176;
  *((_QWORD *)this + 17) = 128;
  *(_QWORD *)this = &off_1E1FC9348;
  v2 = secLogObjForScope("security_exception");
  v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEFAULT, "CFError", v5, 2u);
  }
  Security::CommonError::LogBacktrace((Security::CommonError *)v3);
  return this;
}

void sub_18AA242A4(_Unwind_Exception *a1)
{
  std::exception *v1;

  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void Security::CFError::throwMe(Security::CFError *this)
{
  Security::CFError *exception;

  exception = (Security::CFError *)__cxa_allocate_exception(0x90uLL);
  Security::CFError::CFError(exception);
}

void sub_18AA242EC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void Security::ModuleNexusError::throwMe(Security::ModuleNexusError *this)
{
  char *exception;

  exception = (char *)__cxa_allocate_exception(0x90uLL);
  *(_OWORD *)(exception + 72) = xmmword_18AA61186;
  *(_OWORD *)(exception + 88) = unk_18AA61196;
  *(_OWORD *)(exception + 104) = xmmword_18AA611A6;
  *(_OWORD *)(exception + 120) = unk_18AA611B6;
  *(_OWORD *)(exception + 8) = *(_OWORD *)"CommonError";
  *(_OWORD *)(exception + 24) = unk_18AA61156;
  *(_OWORD *)(exception + 40) = xmmword_18AA61166;
  *(_OWORD *)(exception + 56) = unk_18AA61176;
  *((_QWORD *)exception + 17) = 128;
  *(_QWORD *)exception = &off_1E1FC92B0;
}

void Security::UnixPlusPlus::FileDesc::close(Security::UnixPlusPlus::FileDesc *this)
{
  int v2;
  NSObject *v3;
  int v4;
  int *v5;
  _DWORD v6[2];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v2 = *(_DWORD *)this;
  if ((v2 & 0x80000000) == 0)
  {
    if (close(v2) == -1)
    {
      v5 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v5);
    }
    v3 = secLogObjForScope("unixio");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      v4 = *(_DWORD *)this;
      v6[0] = 67109120;
      v6[1] = v4;
      _os_log_debug_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEBUG, "close(%d)", (uint8_t *)v6, 8u);
    }
    *(_DWORD *)this = -1;
  }
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__dst, void *__src, size_t __len)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *__dst = v6;
  }
  else
  {
    *((_BYTE *)__dst + 23) = __len;
    v6 = __dst;
    if (!__len)
      goto LABEL_9;
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

ssize_t Security::UnixPlusPlus::FileDesc::writeAll(ssize_t this, char *__buf, size_t __nbyte)
{
  size_t v3;
  int *v5;
  int *v6;

  if (__nbyte)
  {
    v3 = __nbyte;
    v5 = (int *)this;
    do
    {
      this = write(*v5, __buf, v3);
      if (this == -1)
      {
        if (*__error() != 35)
        {
          v6 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v6);
        }
        this = 0;
      }
      __buf += this;
      v3 -= this;
    }
    while (v3);
  }
  return this;
}

off_t Security::UnixPlusPlus::FileDesc::seek(Security::UnixPlusPlus::FileDesc *this, off_t a2)
{
  off_t result;
  int *v3;

  result = lseek((int)this, a2, 0);
  if (result == -1)
  {
    v3 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v3);
  }
  return result;
}

float Security::UnixPlusPlus::FileDesc::fcntl(Security::UnixPlusPlus::FileDesc *this, int a2, void *a3)
{
  int v4;
  NSObject *v5;
  float result;
  int v7;
  int *v8;
  uint8_t buf[4];
  int v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = fcntl(*(_DWORD *)this, 48, a3, 1);
  v5 = secLogObjForScope("unixio");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    v7 = *(_DWORD *)this;
    *(_DWORD *)buf = 67109888;
    v10 = v7;
    v11 = 1024;
    v12 = 48;
    v13 = 2048;
    v14 = 1;
    v15 = 1024;
    v16 = v4;
    _os_log_debug_impl(&dword_18A900000, v5, OS_LOG_TYPE_DEBUG, "%d fcntl(%d,%p) = %d", buf, 0x1Eu);
  }
  if (v4 == -1)
  {
    v8 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v8);
  }
  return result;
}

int *Security::UnixPlusPlus::FileDesc::removeAttr(Security::UnixPlusPlus::FileDesc *this, const char *a2)
{
  int *result;
  int *v3;

  result = (int *)fremovexattr((int)this, a2, 0);
  if ((_DWORD)result)
  {
    result = __error();
    if (*result != 93)
    {
      v3 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v3);
    }
  }
  return result;
}

ssize_t Security::UnixPlusPlus::FileDesc::listAttr(Security::UnixPlusPlus::FileDesc *this, char *a2, size_t a3)
{
  ssize_t result;
  int *v4;

  result = flistxattr((int)this, a2, a3, 0);
  if (result == -1)
  {
    v4 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v4);
  }
  return result;
}

const void **Security::UnixPlusPlus::FileDesc::mediumType(std::string *this, Security::UnixPlusPlus::FileDesc *a2)
{
  timespec v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  mach_port_t v10;
  const __CFDictionary *v11;
  io_service_t MatchingService;
  io_object_t v13;
  const __CFDictionary *v14;
  const __CFString *Value;
  unint64_t v17;
  CFDictionaryRef matching;
  stat v19;

  v17 = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v19.st_blksize = v3;
  *(timespec *)v19.st_qspare = v3;
  v19.st_birthtimespec = v3;
  *(timespec *)&v19.st_size = v3;
  v19.st_mtimespec = v3;
  v19.st_ctimespec = v3;
  *(timespec *)&v19.st_uid = v3;
  v19.st_atimespec = v3;
  *(timespec *)&v19.st_dev = v3;
  Security::UnixPlusPlus::FileDesc::fstat(a2, &v19);
  matching = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  Security::CFTemp<__CFDictionary const*>::CFTemp((CFTypeRef *)&matching, (uint64_t)"{%s=%d,%s=%d}", v4, v5, v6, v7, v8, v9, (uint64_t)"BSD Major");
  v10 = *MEMORY[0x1E0CBBAA8];
  v11 = matching;
  matching = 0;
  MatchingService = IOServiceGetMatchingService(v10, v11);
  v13 = MatchingService;
  if (!MatchingService)
  {
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&matching);
    v17 = 0;
LABEL_6:
    this->__r_.__value_.__r.__words[0] = 0;
    this->__r_.__value_.__l.__size_ = 0;
    this->__r_.__value_.__r.__words[2] = 0;
    return Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v17);
  }
  v14 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", CFSTR("Device Characteristics"), 0, 3u);
  IOObjectRelease(v13);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&matching);
  v17 = (unint64_t)v14;
  if (!v14)
    goto LABEL_6;
  Value = (const __CFString *)CFDictionaryGetValue(v14, CFSTR("Medium Type"));
  if (!Value)
    goto LABEL_6;
  Security::cfString(this, Value);
  return Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v17);
}

void sub_18AA24818(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

CFTypeRef *Security::CFTemp<__CFDictionary const*>::CFTemp(CFTypeRef *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFDataRef v10;
  uint64_t *v12;
  _QWORD v13[3];
  int v14;

  *a1 = 0;
  v12 = &a9;
  v13[0] = a2;
  v13[1] = &v12;
  v13[2] = 0;
  v14 = 0;
  v10 = Security::CFMake::make((Security::CFMake *)v13);
  if (*a1)
    CFRelease(*a1);
  *a1 = v10;
  return a1;
}

void sub_18AA24898(_Unwind_Exception *a1)
{
  const void **v1;

  Security::CFRef<__CFDictionary const*>::~CFRef(v1);
  _Unwind_Resume(a1);
}

BOOL Security::Allocator::operator==(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

void DefaultAllocator::~DefaultAllocator(DefaultAllocator *this)
{
  JUMPOUT(0x18D76FAA0);
}

void *DefaultAllocator::malloc(DefaultAllocator *this, size_t size)
{
  void *result;
  std::bad_alloc *exception;
  std::bad_alloc *v4;

  result = malloc_type_malloc(size, 0x3885DBC7uLL);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v4 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v4, MEMORY[0x1E0DE4EA8], MEMORY[0x1E0DE4DC0]);
  }
  return result;
}

void DefaultAllocator::free(DefaultAllocator *this, void *a2)
{
  free(a2);
}

void *DefaultAllocator::realloc(DefaultAllocator *this, void *ptr, size_t size)
{
  void *result;
  std::bad_alloc *exception;
  std::bad_alloc *v5;

  result = malloc_type_realloc(ptr, size, 0x70F28E8uLL);
  if (!result)
  {
    exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
    v5 = std::bad_alloc::bad_alloc(exception);
    __cxa_throw(v5, MEMORY[0x1E0DE4EA8], MEMORY[0x1E0DE4DC0]);
  }
  return result;
}

void SensitiveAllocator::~SensitiveAllocator(SensitiveAllocator *this)
{
  JUMPOUT(0x18D76FAA0);
}

void SensitiveAllocator::free(SensitiveAllocator *this, void *ptr)
{
  size_t v3;

  v3 = malloc_size(ptr);
  memset_s(ptr, v3, 0, v3);
  free(ptr);
}

void *SensitiveAllocator::realloc(SensitiveAllocator *this, char *ptr, size_t a3)
{
  size_t v5;

  v5 = malloc_size(ptr);
  if (v5 > a3)
    v5 = memset_s(&ptr[a3], v5 - a3, 0, v5 - a3);
  return DefaultAllocator::realloc((DefaultAllocator *)v5, ptr, a3);
}

uint64_t Security::Allocator::standard(Security::Allocator *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EDF7AB78);
  if (!defaultAllocators)
    defaultAllocators = Security::ModuleNexusCommon::create((Security::ModuleNexusCommon *)&defaultAllocators, (void *(*)(void))Security::ModuleNexus<DefaultAllocators>::make);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EDF7AB78);
  return defaultAllocators;
}

void sub_18AA24A60(void *a1)
{
  __cxa_begin_catch(a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EDF7AB78);
  __cxa_rethrow();
}

void sub_18AA24A78(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *Security::ModuleNexus<DefaultAllocators>::make()
{
  _QWORD *result;

  result = (_QWORD *)operator new();
  *result = &off_1E1FC7F28;
  result[1] = &off_1E1FC7F68;
  return result;
}

uint64_t Security::CFClass::equalType(Security::CFClass *this, char *a2, const void *a3)
{
  char *v3;
  char *v4;

  if (this)
    v3 = (char *)this + 24;
  else
    v3 = 0;
  if (a2)
    v4 = a2 + 24;
  else
    v4 = 0;
  return (*(uint64_t (**)(char *, char *, const void *))(*(_QWORD *)v3 + 24))(v3, v4, a3);
}

void sub_18AA24AFC(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18AA24AF4);
}

uint64_t Security::CFClass::hashType(Security::CFClass *this, const void *a2)
{
  char *v2;

  if (this)
    v2 = (char *)this + 24;
  else
    v2 = 0;
  return (*(uint64_t (**)(char *, const void *))(*(_QWORD *)v2 + 32))(v2, a2);
}

void sub_18AA24B38(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18AA24B30);
}

uint64_t Security::CFClass::copyFormattingDescType(Security::CFClass *this, const void *a2, const __CFDictionary *a3)
{
  char *v3;

  if (this)
    v3 = (char *)this + 24;
  else
    v3 = 0;
  return (*(uint64_t (**)(char *, const void *, const __CFDictionary *))(*(_QWORD *)v3 + 40))(v3, a2, a3);
}

void sub_18AA24B74(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18AA24B6CLL);
}

uint64_t Security::CFClass::copyDebugDescType(Security::CFClass *this, const void *a2)
{
  char *v2;

  if (this)
    v2 = (char *)this + 24;
  else
    v2 = 0;
  return (*(uint64_t (**)(char *, const void *))(*(_QWORD *)v2 + 48))(v2, a2);
}

void sub_18AA24BB4(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18AA24BACLL);
}

Security::MainMachOImage *Security::MainMachOImage::MainMachOImage(Security::MainMachOImage *this)
{
  const mach_header *image_header;
  uint64_t v3;

  image_header = _dyld_get_image_header(0);
  *(_QWORD *)this = &off_1E1FC8328;
  Security::MachOBase::initHeader((uint64_t)this, image_header);
  v3 = 32;
  if (!*((_BYTE *)this + 32))
    v3 = 28;
  Security::MachOBase::initCommands((uint64_t)this, (const load_command *)((char *)image_header + v3));
  *(_QWORD *)this = &off_1E1FDC478;
  return this;
}

uint64_t Security::MachOBase::initCommands(uint64_t this, const load_command *a2)
{
  uint64_t v2;
  unsigned int v3;
  const load_command *v4;

  LODWORD(v2) = *(_DWORD *)(*(_QWORD *)(this + 8) + 20);
  v3 = bswap32(v2);
  if (*(_BYTE *)(this + 33))
    v2 = v3;
  else
    v2 = v2;
  v4 = (const load_command *)((char *)a2 + v2);
  *(_QWORD *)(this + 16) = a2;
  *(_QWORD *)(this + 24) = v4;
  if (&a2[1] > v4)
    Security::UnixError::throwMe((Security::UnixError *)8);
  return this;
}

void Security::MainMachOImage::~MainMachOImage(Security::MainMachOImage *this)
{
  JUMPOUT(0x18D76FAA0);
}

void Security::MachOImage::~MachOImage(Security::MachOImage *this)
{
  JUMPOUT(0x18D76FAA0);
}

unint64_t Security::MachOBase::findSegment(Security::MachOBase *this, const char *a2)
{
  unint64_t i;
  unsigned int v4;
  unsigned int v5;
  unsigned int v7;
  unsigned int v8;

  for (i = *((_QWORD *)this + 2); i; i = Security::MachOBase::nextCommand(this, (const load_command *)i))
  {
    v4 = *(_DWORD *)i;
    v5 = bswap32(*(_DWORD *)i);
    if (*((_BYTE *)this + 33))
      v4 = v5;
    if (v4 == 25 || v4 == 1)
    {
      v7 = bswap32(*(_DWORD *)(i + 4));
      v8 = *((_BYTE *)this + 33) ? v7 : *(_DWORD *)(i + 4);
      if (v8 <= 0x37)
        Security::UnixError::throwMe((Security::UnixError *)8);
      if (!strncmp((const char *)(i + 8), "__TEXT", 0x10uLL))
        break;
    }
  }
  return i;
}

uint64_t Security::MachO::signingExtent(Security::MachO *this)
{
  const load_command *CodeSignature;
  unsigned int cmd;
  unsigned int v4;
  uint64_t result;

  CodeSignature = Security::MachOBase::findCodeSignature(this);
  if (!CodeSignature)
    return *((_QWORD *)this + 7);
  cmd = CodeSignature[1].cmd;
  v4 = bswap32(cmd);
  result = *((_BYTE *)this + 33) ? v4 : cmd;
  if (!(_DWORD)result)
    return *((_QWORD *)this + 7);
  return result;
}

CFDataRef Security::MachO::dataAt(Security::MachO *this, uint64_t a2, size_t size)
{
  CFDataRef v6;
  int *v8;
  void *v9[2];

  v9[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  v9[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  Security::CFMallocData::CFMallocData((Security::CFMallocData *)v9, size);
  if (Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*((unsigned int *)this + 9), v9[0], size, *((_QWORD *)this + 6) + a2) != size)
  {
    v8 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v8);
  }
  v6 = Security::CFMallocData::operator __CFData const*((uint64_t)v9);
  if (v9[0])
    free(v9[0]);
  return v6;
}

void sub_18AA24E58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9)
{
  if (a9)
    free(a9);
  _Unwind_Resume(exception_object);
}

Security::CFMallocData *Security::CFMallocData::CFMallocData(Security::CFMallocData *this, size_t size)
{
  void *v4;
  int *v6;

  v4 = malloc_type_malloc(size, 0x164E539BuLL);
  *(_QWORD *)this = v4;
  *((_QWORD *)this + 1) = size;
  if (!v4)
  {
    v6 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v6);
  }
  return this;
}

uint64_t *std::list<fat_arch *>::__sort<BOOL({block_pointer})(fat_arch const*,fat_arch const*)>(uint64_t **a1, uint64_t **a2, unint64_t a3, uint64_t a4)
{
  uint64_t **v4;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  unint64_t v11;
  unint64_t v12;
  uint64_t **v13;
  uint64_t **v14;
  uint64_t *i;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *j;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;

  v4 = a1;
  if (a3 >= 2)
  {
    if (a3 == 2)
    {
      v7 = *a2;
      if ((*(unsigned int (**)(void))(*(_QWORD *)a4 + 16))())
      {
        v8 = *v7;
        *(_QWORD *)(v8 + 8) = v7[1];
        *(_QWORD *)v7[1] = v8;
        v9 = *v4;
        v9[1] = (uint64_t)v7;
        *v7 = (uint64_t)v9;
        *v4 = v7;
        v7[1] = (uint64_t)v4;
        return v7;
      }
    }
    else
    {
      v11 = a3 >> 1;
      v12 = (a3 >> 1) + 1;
      v13 = a1;
      do
      {
        v13 = (uint64_t **)v13[1];
        --v12;
      }
      while (v12 > 1);
      v14 = (uint64_t **)std::list<fat_arch *>::__sort<BOOL({block_pointer})(fat_arch const*,fat_arch const*)>(a1, v13, a3 >> 1, a4);
      v4 = (uint64_t **)std::list<fat_arch *>::__sort<BOOL({block_pointer})(fat_arch const*,fat_arch const*)>(v13, a2, a3 - v11, a4);
      if ((*(unsigned int (**)(void))(*(_QWORD *)a4 + 16))())
      {
        for (i = v4[1]; i != (uint64_t *)a2; i = (uint64_t *)i[1])
        {
          if (!(*(unsigned int (**)(void))(*(_QWORD *)a4 + 16))())
            goto LABEL_14;
        }
        i = (uint64_t *)a2;
LABEL_14:
        v17 = *i;
        v18 = *v4;
        v18[1] = *(_QWORD *)(*i + 8);
        **(_QWORD **)(v17 + 8) = v18;
        v19 = *v14;
        v16 = v14[1];
        v19[1] = (uint64_t)v4;
        *v4 = v19;
        *v14 = (uint64_t *)v17;
        *(_QWORD *)(v17 + 8) = v14;
      }
      else
      {
        v16 = v14[1];
        i = (uint64_t *)v4;
        v4 = v14;
      }
      if (v16 != i && i != (uint64_t *)a2)
      {
        v20 = i;
        do
        {
          if ((*(unsigned int (**)(void))(*(_QWORD *)a4 + 16))())
          {
            for (j = (uint64_t *)i[1]; j != (uint64_t *)a2; j = (uint64_t *)j[1])
            {
              if (!(*(unsigned int (**)(void))(*(_QWORD *)a4 + 16))())
                goto LABEL_25;
            }
            j = (uint64_t *)a2;
LABEL_25:
            v23 = *j;
            v24 = *i;
            *(_QWORD *)(v24 + 8) = *(_QWORD *)(*j + 8);
            **(_QWORD **)(v23 + 8) = v24;
            if (v20 == i)
              v20 = j;
            v25 = *v16;
            v22 = (uint64_t *)v16[1];
            *(_QWORD *)(v25 + 8) = i;
            *i = v25;
            *v16 = v23;
            *(_QWORD *)(v23 + 8) = v16;
            i = j;
          }
          else
          {
            v22 = (uint64_t *)v16[1];
          }
          v26 = v22 == v20 || i == (uint64_t *)a2;
          v16 = v22;
        }
        while (!v26);
      }
    }
  }
  return (uint64_t *)v4;
}

_QWORD *std::__list_imp<fat_arch *>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  if (result[2])
  {
    v1 = result;
    result = (_QWORD *)result[1];
    v2 = *v1;
    v3 = *result;
    *(_QWORD *)(v3 + 8) = *(_QWORD *)(*v1 + 8);
    **(_QWORD **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        v4 = (_QWORD *)result[1];
        operator delete(result);
        result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

BOOL ___ZN8Security9UniversalC2ENS_12UnixPlusPlus8FileDescEmm_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(_DWORD *)(a2 + 8) < *(_DWORD *)(a3 + 8);
}

unint64_t Security::Universal::bestNativeArch(Security::Universal *this)
{
  unsigned int v2;
  unsigned int v3;
  cpu_type_t v4;
  unsigned int v5;
  fat_arch *v6;
  unsigned int cputype;
  uint64_t cpusubtype;
  unsigned int *v9;
  char v11[8];
  uint64_t v12;
  char v13;

  if (*((_QWORD *)this + 1))
  {
    Security::MainMachOImage::MainMachOImage((Security::MainMachOImage *)v11);
    v2 = *(_DWORD *)(v12 + 8);
    v3 = bswap32(*(_DWORD *)(v12 + 4));
    if (v13)
      v4 = v3;
    else
      v4 = *(_DWORD *)(v12 + 4);
    v5 = bswap32(v2);
    if (v13)
      v2 = v5;
    v6 = NXFindBestFatArch(v4, v2 & 0xFFFFFF, *((fat_arch **)this + 1), *((_DWORD *)this + 4));
    if (v6)
    {
      cputype = v6->cputype;
      cpusubtype = v6->cpusubtype;
    }
    else
    {
      v9 = (unsigned int *)*((_QWORD *)this + 1);
      cputype = *v9;
      cpusubtype = v9[1];
    }
  }
  else
  {
    cputype = *((_DWORD *)this + 5);
    cpusubtype = *((unsigned int *)this + 6);
  }
  return cputype | (unint64_t)(cpusubtype << 32);
}

uint64_t Security::Universal::findImage(Security::Universal **this, const Security::Architecture *a2, int a3)
{
  Security::Universal *Arch;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v10;
  char v11;

  Arch = Security::Universal::findArch(this[1], (const Security::Architecture *)*((unsigned int *)this + 4), (int)a2, a3);
  v5 = operator new();
  v10 = *(_DWORD *)this;
  v11 = *((_BYTE *)this + 4);
  Security::MachO::MachO(v5, &v10, (off_t)this[4] + *((unsigned int *)Arch + 2), *((unsigned int *)Arch + 3));
  v6 = *(_DWORD *)(*(_QWORD *)(v5 + 8) + 12);
  v7 = bswap32(v6);
  if (*(_BYTE *)(v5 + 33))
    v6 = v7;
  if (!v6 || (v8 = *((_DWORD *)this + 18)) != 0 && v8 != v6)
    Security::UnixError::throwMe((Security::UnixError *)8);
  *((_DWORD *)this + 18) = v6;
  return v5;
}

void sub_18AA25424(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x10E1C40592D68B5);
  _Unwind_Resume(a1);
}

Security::Universal *Security::Universal::findArch(Security::Universal *this, const Security::Architecture *a2, int a3, int a4)
{
  Security::Universal *v4;
  Security::Universal *v5;

  if (!(_DWORD)a2)
LABEL_19:
    Security::UnixError::throwMe((Security::UnixError *)8);
  v4 = (Security::Universal *)((char *)this + 20 * a2);
  v5 = this;
  while (*(_DWORD *)v5 != a3 || *((_DWORD *)v5 + 1) != a4)
  {
    v5 = (Security::Universal *)((char *)v5 + 20);
    if (v5 >= v4)
    {
      v5 = this;
      while (*(_DWORD *)v5 != a3 || ((*((_DWORD *)v5 + 1) ^ a4) & 0xFFFFFF) != 0)
      {
        v5 = (Security::Universal *)((char *)v5 + 20);
        if (v5 >= v4)
        {
          v5 = this;
          while (*(_DWORD *)v5 != a3 || (*((_DWORD *)v5 + 1) & 0xFFFFFF) != 0)
          {
            v5 = (Security::Universal *)((char *)v5 + 20);
            if (v5 >= v4)
            {
              while (*(_DWORD *)this != a3)
              {
                this = (Security::Universal *)((char *)this + 20);
                if (this >= v4)
                  goto LABEL_19;
              }
              return this;
            }
          }
          return v5;
        }
      }
      return v5;
    }
  }
  return v5;
}

uint64_t Security::Universal::architecture(Security::Universal *this, const Security::Architecture *a2, int a3)
{
  uint64_t v5;
  unsigned int v6;
  char v7;

  if (*((_QWORD *)this + 1))
    return Security::Universal::findImage((Security::Universal **)this, a2, a3);
  if (*((_DWORD *)this + 5) != (_DWORD)a2 || a3 != -1 && ((*((_DWORD *)this + 6) ^ a3) & 0xFFFFFF) != 0)
    Security::UnixError::throwMe((Security::UnixError *)8);
  v5 = operator new();
  v6 = *(_DWORD *)this;
  v7 = *((_BYTE *)this + 4);
  Security::MachO::MachO(v5, &v6, *((_QWORD *)this + 4), *((_QWORD *)this + 5));
  return v5;
}

void sub_18AA255CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x10E1C40592D68B5);
  _Unwind_Resume(a1);
}

uint64_t Security::Universal::archOffset(Security::Universal *this, const Security::Architecture *a2, int a3)
{
  uint64_t v3;

  if (*((_QWORD *)this + 1))
  {
    v3 = *((_QWORD *)this + 4);
    return v3
         + *((unsigned int *)Security::Universal::findArch(*((Security::Universal **)this + 1), (const Security::Architecture *)*((unsigned int *)this + 4), (int)a2, a3)+ 2);
  }
  else
  {
    if (*((_DWORD *)this + 5) != (_DWORD)a2 || a3 != -1 && ((*((_DWORD *)this + 6) ^ a3) & 0xFFFFFF) != 0)
      Security::UnixError::throwMe((Security::UnixError *)8);
    return 0;
  }
}

void Security::Bundle::~Bundle(Security::Bundle *this)
{
  Security::Bundle::~Bundle(this);
  JUMPOUT(0x18D76FAA0);
}

{
  const void *v2;

  *(_QWORD *)this = &off_1E1FC9308;
  v2 = (const void *)*((_QWORD *)this + 8);
  if (v2)
    CFRelease(v2);
  if (*((char *)this + 63) < 0)
    operator delete(*((void **)this + 5));
  if (*((char *)this + 39) < 0)
    operator delete(*((void **)this + 2));
}

void Security::Bundle::canonicalPath(Security::Bundle *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 39) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 2), *((_QWORD *)this + 3));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *((_OWORD *)this + 1);
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)this + 4);
  }
}

void Security::Bundle::executablePath(Security::Bundle *this@<X0>, std::string *a2@<X8>)
{
  char *v4;
  std::string::size_type v5;
  __CFBundle *v6;
  const __CFURL *v7;
  void *__p[2];
  uint64_t v9;

  v4 = (char *)this + 40;
  if (*((char *)this + 63) < 0)
  {
    v5 = *((_QWORD *)this + 6);
    if (v5)
    {
      std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)v4, v5);
      return;
    }
  }
  else if (*((_BYTE *)this + 63))
  {
LABEL_9:
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)v4;
    a2->__r_.__value_.__r.__words[2] = *((_QWORD *)v4 + 2);
    return;
  }
  v6 = (__CFBundle *)Security::Bundle::cfBundle(this);
  v7 = CFBundleCopyExecutableURL(v6);
  Security::cfStringRelease((Security *)__p, v7);
  if (*((char *)this + 63) < 0)
    operator delete(*(void **)v4);
  *((_QWORD *)v4 + 2) = v9;
  *(_OWORD *)v4 = *(_OWORD *)__p;
  HIBYTE(v9) = 0;
  LOBYTE(__p[0]) = 0;
  if ((*((char *)this + 63) & 0x80000000) == 0)
    goto LABEL_9;
  std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 5), *((_QWORD *)this + 6));
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
}

void sub_18AA25798(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

SecStaticCodeRef Security::OSXCode::codeRef(Security::OSXCode *this)
{
  const __CFURL *v1;
  void **v2;
  Security::MacOSError *v3;
  void *__p[2];
  char v6;
  const __CFURL *CFURL;
  SecStaticCodeRef staticCode;

  staticCode = (SecStaticCodeRef)0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(void **__return_ptr))(*(_QWORD *)this + 16))(__p);
  if (v6 >= 0)
    v2 = __p;
  else
    v2 = (void **)__p[0];
  CFURL = Security::makeCFURL((Security *)v2, 0, 0, v1);
  v3 = (Security::MacOSError *)SecStaticCodeCreateWithPath(CFURL, 0, &staticCode);
  if ((_DWORD)v3)
    Security::MacOSError::throwMe(v3);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&CFURL);
  if (v6 < 0)
    operator delete(__p[0]);
  return staticCode;
}

void sub_18AA25844(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *Security::Bundle::lookupSymbol(Security::Bundle *this, const char *a2)
{
  __CFBundle *v3;
  void *FunctionPointerForName;
  CFStringRef functionName;

  functionName = CFStringCreateWithCString(0, a2, 0);
  if (!functionName)
    Security::UnixError::throwMe((Security::UnixError *)0x55);
  v3 = (__CFBundle *)Security::Bundle::cfBundle(this);
  FunctionPointerForName = CFBundleGetFunctionPointerForName(v3, functionName);
  if (!FunctionPointerForName)
    Security::UnixError::throwMe((Security::UnixError *)0x55);
  Security::CFRef<__CFString const*>::~CFRef((const void **)&functionName);
  return FunctionPointerForName;
}

void sub_18AA258E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFString const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t Security::Bundle::cfBundle(Security::Bundle *this)
{
  uint64_t result;
  NSObject *v3;
  const UInt8 *v4;
  CFIndex v5;
  Security::CFError *v6;
  _QWORD *v7;
  _BYTE v8[24];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  result = *((_QWORD *)this + 8);
  if (!result)
  {
    v3 = secLogObjForScope("bundle");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      v7 = (_QWORD *)((char *)this + 16);
      if (*((char *)this + 39) < 0)
        v7 = (_QWORD *)*v7;
      *(_DWORD *)v8 = 136315138;
      *(_QWORD *)&v8[4] = v7;
      _os_log_debug_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEBUG, "instantiating CFBundle for %s", v8, 0xCu);
    }
    if (*((char *)this + 39) < 0)
    {
      v4 = (const UInt8 *)*((_QWORD *)this + 2);
      v5 = *((_QWORD *)this + 3);
    }
    else
    {
      v4 = (const UInt8 *)this + 16;
      v5 = *((unsigned __int8 *)this + 39);
    }
    v6 = CFURLCreateFromFileSystemRepresentation(0, v4, v5, 1u);
    *(_QWORD *)v8 = v6;
    if (!v6 || (v6 = CFBundleCreate(0, v6), (*((_QWORD *)this + 8) = v6) == 0))
      Security::CFError::throwMe(v6);
    Security::CFRef<__CFURL const*>::~CFRef((const void **)v8);
    return *((_QWORD *)this + 8);
  }
  return result;
}

void sub_18AA25A0C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void Security::LoadableBundle::~LoadableBundle(Security::LoadableBundle *this)
{
  Security::Bundle::~Bundle(this);
  JUMPOUT(0x18D76FAA0);
}

BOOL Security::LoadableBundle::isLoaded(Security::LoadableBundle *this)
{
  __CFBundle *v1;

  v1 = (__CFBundle *)Security::Bundle::cfBundle(this);
  return CFBundleIsExecutableLoaded(v1) != 0;
}

void Security::LoadableBundle::load(Security::LoadableBundle *this)
{
  __CFBundle *v2;
  Security::CFError *Executable;
  NSObject *v4;
  std::string *p_p;
  std::string __p;
  uint8_t buf[4];
  Security::LoadableBundle *v8;
  __int16 v9;
  std::string *v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v2 = (__CFBundle *)Security::Bundle::cfBundle(this);
  Executable = (Security::CFError *)CFBundleLoadExecutable(v2);
  if (!(_DWORD)Executable)
    Security::CFError::throwMe(Executable);
  v4 = secLogObjForScope("bundle");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)this + 39) < 0)
      std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 2), *((_QWORD *)this + 3));
    else
      __p = *(std::string *)((char *)this + 16);
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 134218242;
    v8 = this;
    v9 = 2080;
    v10 = p_p;
    _os_log_debug_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEBUG, "%p (%s) loaded", buf, 0x16u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void Security::LoadableBundle::unload(Security::LoadableBundle *this)
{
  NSObject *v2;
  __CFBundle *v3;
  std::string *p_p;
  std::string __p;
  uint8_t buf[4];
  Security::LoadableBundle *v7;
  __int16 v8;
  std::string *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = secLogObjForScope("bundle");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)this + 39) < 0)
      std::string::__init_copy_ctor_external(&__p, *((const std::string::value_type **)this + 2), *((_QWORD *)this + 3));
    else
      __p = *(std::string *)((char *)this + 16);
    p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 134218242;
    v7 = this;
    v8 = 2080;
    v9 = p_p;
    _os_log_debug_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEBUG, "%p (%s) unloaded", buf, 0x16u);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  v3 = (__CFBundle *)Security::Bundle::cfBundle(this);
  CFBundleUnloadExecutable(v3);
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("basic_string");
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E1FC5C60, (void (*)(void *))MEMORY[0x1E0DE42E0]);
}

void sub_18AA25D40(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
  return result;
}

uint64_t Security::ModuleNexusCommon::create(Security::ModuleNexusCommon *this, void *(*a2)(void))
{
  dispatch_once_t *v3;
  uint64_t v4;
  uint64_t result;
  _QWORD v6[6];

  v4 = *((_QWORD *)this + 1);
  v3 = (dispatch_once_t *)((char *)this + 8);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = ___ZN8Security17ModuleNexusCommon6createEPFPvvE_block_invoke;
  v6[3] = &__block_descriptor_tmp_13544;
  v6[4] = this;
  v6[5] = a2;
  if (v4 != -1)
    dispatch_once(v3, v6);
  result = *(_QWORD *)this;
  if (!*(_QWORD *)this)
    Security::ModuleNexusError::throwMe(0);
  return result;
}

uint64_t ___ZN8Security17ModuleNexusCommon6createEPFPvvE_block_invoke(uint64_t a1)
{
  uint64_t *v1;
  uint64_t result;

  v1 = *(uint64_t **)(a1 + 32);
  result = (*(uint64_t (**)(void))(a1 + 40))();
  *v1 = result;
  return result;
}

void sub_18AA25E14(void *a1)
{
  _QWORD *v1;

  __cxa_begin_catch(a1);
  *v1 = 0;
  __cxa_end_catch();
}

void Security::CodeSigning::DetachedRep::~DetachedRep(Security::CodeSigning::DetachedRep *this)
{
  *(_QWORD *)this = off_1E1FC8460;
  if (*((char *)this + 151) < 0)
    operator delete(*((void **)this + 16));
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 12);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 11);
  *(_QWORD *)this = off_1E1FC9108;
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((_QWORD *)this + 2);
  Security::CodeSigning::DiskRep::~DiskRep(this);
}

{
  *(_QWORD *)this = off_1E1FC8460;
  if (*((char *)this + 151) < 0)
    operator delete(*((void **)this + 16));
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 12);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 11);
  *(_QWORD *)this = off_1E1FC9108;
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((_QWORD *)this + 2);
  Security::CodeSigning::DiskRep::~DiskRep(this);
  JUMPOUT(0x18D76FAA0);
}

uint64_t Security::CodeSigning::FilterRep::base(Security::CodeSigning::FilterRep *this)
{
  return *((_QWORD *)this + 2);
}

CFDataRef Security::CodeSigning::DetachedRep::component(Security::CodeSigning::EmbeddedSignatureBlob **this, Security::CodeSigning::EmbeddedSignatureBlob *a2, const Security::BlobCore *a3)
{
  CFDataRef result;
  const Security::BlobCore *v6;
  Security::CodeSigning::EmbeddedSignatureBlob *v7;
  uint64_t v8;

  result = Security::CodeSigning::EmbeddedSignatureBlob::component(this[14], a2, a3);
  if (!result)
  {
    v7 = this[15];
    if (!v7 || (result = Security::CodeSigning::EmbeddedSignatureBlob::component(v7, a2, v6)) == 0)
    {
      v8 = (*((uint64_t (**)(Security::CodeSigning::EmbeddedSignatureBlob **))*this + 2))(this);
      return (CFDataRef)(*(uint64_t (**)(uint64_t, Security::CodeSigning::EmbeddedSignatureBlob *))(*(_QWORD *)v8 + 24))(v8, a2);
    }
  }
  return result;
}

uint64_t Security::CodeSigning::FilterRep::identification(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 32))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::mainExecutablePath(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 40))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::copyCanonicalPath(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 48))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::resourcesRootPath(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 56))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::adjustResources(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 64))(*(_QWORD *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::mainExecutableImage(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 80))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::signingBase(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 88))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::signingLimit(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 96))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::execSegBase(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 104))(*(_QWORD *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::execSegLimit(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 112))(*(_QWORD *)(a1 + 16));
}

uint64_t Security::CodeSigning::DiskRep::platformType()
{
  return 0;
}

uint64_t Security::CodeSigning::FilterRep::format(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 128))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::modifiedFiles(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 136))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::fd(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 144))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::flush(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 152))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::FilterRep::recommendedIdentifier(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 184))(*(_QWORD *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::defaultResourceRules(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 200))(*(_QWORD *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::defaultRequirements(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 208))(*(_QWORD *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::pageSize(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 216))(*(_QWORD *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::strictValidate(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 224))(*(_QWORD *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::strictValidateStructure(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 232))(*(_QWORD *)(a1 + 16));
}

uint64_t Security::CodeSigning::FilterRep::allowedResourceOmissions(Security::CodeSigning::FilterRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 240))(*((_QWORD *)this + 2));
}

uint64_t Security::CodeSigning::DiskRep::appleInternalForcePlatform(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

_DWORD *Security::Blob<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u>::specific(_DWORD *result)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  int *v4;
  unint64_t v5;
  unsigned int v6;
  unint64_t v7;
  BOOL v8;

  if (result)
  {
    if (*result == -1072898310
      && (v1 = bswap32(result[2]), v2 = 8 * v1 + 12, v3 = bswap32(result[1]), v2 <= v3))
    {
      v5 = (unint64_t)&result[2 * v1 + 3];
      while (1)
      {
        v5 -= 8;
        if (v5 < (unint64_t)(result + 3))
          break;
        v6 = *(_DWORD *)(v5 + 4);
        if (v6)
        {
          v7 = bswap32(v6);
          v8 = v2 > v7 || v7 + 8 > v3;
          if (v8 || bswap32(*(_DWORD *)((char *)result + v7 + 4)) + v7 > v3)
            return 0;
        }
      }
    }
    else
    {
      v4 = __error();
      result = 0;
      *v4 = 22;
    }
  }
  return result;
}

uint64_t Security::SuperBlobCore<Security::SuperBlob<4208856257u,unsigned int>,4208856257u,unsigned int>::find(uint64_t a1, int a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;

  v2 = *(_DWORD *)(a1 + 8);
  if (!v2)
    return 0;
  v3 = 0;
  LODWORD(v4) = bswap32(v2);
  v4 = v4 <= 1 ? 1 : v4;
  v5 = (unsigned int *)(a1 + 12);
  while (1)
  {
    v6 = *v5;
    v5 += 2;
    if (bswap32(v6) == a2)
      break;
    if (v4 == ++v3)
      return 0;
  }
  v7 = *(_DWORD *)(a1 + 8 * v3 + 16);
  if (v7)
    return bswap32(v7) + a1;
  else
    return 0;
}

void Security::CodeSigning::DYLDCacheRep::~DYLDCacheRep(void **this)
{
  *this = off_1E1FC8788;
  DYLDCache::~DYLDCache((DYLDCache *)(this + 6));
  *this = off_1E1FC8C10;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);
}

{
  *this = off_1E1FC8788;
  DYLDCache::~DYLDCache((DYLDCache *)(this + 6));
  *this = off_1E1FC8C10;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);
  JUMPOUT(0x18D76FAA0);
}

Security::CodeSigning::EmbeddedSignatureBlob *Security::CodeSigning::DYLDCacheRep::component(Security::CodeSigning::DYLDCacheRep *this, Security::CodeSigning::EmbeddedSignatureBlob *a2, const Security::BlobCore *a3)
{
  Security::CodeSigning::EmbeddedSignatureBlob *result;

  result = (Security::CodeSigning::EmbeddedSignatureBlob *)*((_QWORD *)this + 15);
  if (result)
    return Security::CodeSigning::EmbeddedSignatureBlob::component(result, a2, a3);
  return result;
}

uint64_t Security::CodeSigning::DYLDCacheRep::signingLimit(Security::CodeSigning::DYLDCacheRep *this)
{
  return *((_QWORD *)this + 13);
}

_QWORD *Security::CodeSigning::DYLDCacheRep::format@<X0>(Security::CodeSigning::DYLDCacheRep *this@<X0>, _QWORD *a2@<X8>)
{
  const NXArchInfo *v4;
  const char *name;
  __int128 v6;
  unint64_t v7;
  unint64_t v8;
  char __str[16];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v4 = NXGetArchInfoFromCpuType(**((_DWORD **)this + 11), *(_DWORD *)(*((_QWORD *)this + 11) + 4) & 0xFFFFFF);
  if (!v4)
    return std::string::basic_string[abi:ne180100]<0>(a2, "OS X Shared Library Cache (unknown type)");
  name = v4->name;
  if (!v4->name)
    return std::string::basic_string[abi:ne180100]<0>(a2, "OS X Shared Library Cache (unknown type)");
  v16 = -1431655766;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v14 = v6;
  v15 = v6;
  v12 = v6;
  v13 = v6;
  *(_OWORD *)__str = v6;
  v11 = v6;
  v7 = *(_QWORD *)(*((_QWORD *)this + 10) + 32);
  v8 = bswap64(v7);
  if (*((_BYTE *)this + 96))
    v7 = v8;
  snprintf(__str, 0x64uLL, "OS X Shared Library Cache (%s @ 0x%llx)", name, v7);
  return std::string::basic_string[abi:ne180100]<0>(a2, __str);
}

uint64_t Security::CodeSigning::DYLDCacheRep::pageSize()
{
  return 4096;
}

Security::CodeSigning::SingleDiskRep::Writer *Security::CodeSigning::DYLDCacheRep::writer(Security::CodeSigning::DYLDCacheRep *this)
{
  Security::CodeSigning::SingleDiskRep::Writer *v2;

  v2 = (Security::CodeSigning::SingleDiskRep::Writer *)operator new();
  Security::CodeSigning::SingleDiskRep::Writer::Writer(v2, this, 2);
  *((_QWORD *)v2 + 14) = 0;
  *((_QWORD *)v2 + 13) = (char *)v2 + 112;
  *(_QWORD *)v2 = &off_1E1FC8740;
  *((_QWORD *)v2 + 15) = 0;
  *((_QWORD *)v2 + 16) = this;
  *((_QWORD *)v2 + 17) = 0;
  return v2;
}

void sub_18AA26420(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x10A1C4069E8879DLL);
  _Unwind_Resume(a1);
}

Security::CodeSigning::SingleDiskRep::Writer *Security::CodeSigning::SingleDiskRep::Writer::Writer(Security::CodeSigning::SingleDiskRep::Writer *this, Security::CodeSigning::SingleDiskRep *a2, int a3)
{
  unsigned int *v5;
  unsigned int v6;

  *((_DWORD *)this + 2) = 0;
  *(_QWORD *)((char *)this + 12) = -1;
  *((_DWORD *)this + 5) = a3;
  *(_QWORD *)this = off_1E1FC8BC8;
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)this + 32));
  if (a2)
  {
    v5 = (unsigned int *)((char *)a2 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  *((_QWORD *)this + 3) = a2;
  *((_DWORD *)this + 24) = -1;
  *((_BYTE *)this + 100) = 0;
  return this;
}

void Security::CodeSigning::DYLDCacheRep::Writer::~Writer(Security::CodeSigning::DYLDCacheRep::Writer *this)
{
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 104);
  *(_QWORD *)this = off_1E1FC8BC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::DYLDCacheRep::Writer *)((char *)this + 96));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer((_QWORD *)this + 3);
}

{
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 104);
  *(_QWORD *)this = off_1E1FC8BC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::DYLDCacheRep::Writer *)((char *)this + 96));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer((_QWORD *)this + 3);
  JUMPOUT(0x18D76FAA0);
}

void Security::CodeSigning::DYLDCacheRep::Writer::component(uint64_t **this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
  Security::CodeSigning::EmbeddedSignatureBlob::Maker::component(this + 13, a2, a3);
}

void Security::CodeSigning::DYLDCacheRep::Writer::addDiscretionary(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  size_t v8;
  void *v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  unsigned int v13;
  int32x2_t v14;
  _QWORD *v15;
  int64x2_t v16;
  int8x16_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  int64x2_t v21;
  int v22;

  v4 = *(_QWORD *)(a1 + 128);
  v5 = *(_DWORD *)(*(_QWORD *)(v4 + 80) + 20);
  v6 = bswap32(v5);
  if (*(_BYTE *)(v4 + 96))
    v7 = v6;
  else
    v7 = v5;
  v8 = 24 * (v7 + 1);
  *(_QWORD *)(a2 + 160) = v8;
  v9 = malloc_type_realloc(*(void **)(a2 + 152), v8, 0x372C092CuLL);
  *(_QWORD *)(a2 + 152) = v9;
  if (!v9)
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  bzero(v9, *(_QWORD *)(a2 + 160));
  if ((_DWORD)v7)
  {
    v10 = *(_QWORD *)(a1 + 128);
    v11 = *(_QWORD *)(v10 + 72);
    v12 = *(unsigned __int8 *)(v10 + 96);
    v13 = bswap32(*(_DWORD *)(*(_QWORD *)(v10 + 80) + 16));
    if (!*(_BYTE *)(v10 + 96))
      v13 = *(_DWORD *)(*(_QWORD *)(v10 + 80) + 16);
    v14 = vdup_n_s32(*(_BYTE *)(v10 + 96) == 0);
    v15 = (_QWORD *)(*(_QWORD *)(a2 + 152) + 8);
    v16.i64[0] = v14.u32[0];
    v16.i64[1] = v14.u32[1];
    v17 = (int8x16_t)vcltzq_s64(vshlq_n_s64(v16, 0x3FuLL));
    do
    {
      if ((unint64_t)v13 + 32 > v11)
        Security::UnixError::throwMe((Security::UnixError *)8);
      v18 = *(_QWORD *)(v10 + 64) + v13;
      v19 = *(_QWORD *)v18;
      v20 = bswap64(*(_QWORD *)v18);
      if (v12)
        v19 = v20;
      *v15 = bswap64(v19);
      v21 = (int64x2_t)vbslq_s8(v17, *(int8x16_t *)(v18 + 8), vrev64q_s8(*(int8x16_t *)(v18 + 8)));
      *(v15 - 1) = vrev32_s8((int8x8_t)vshrn_n_s64(v21, 0xCuLL));
      v22 = *(_DWORD *)(v18 + 24);
      if (v12)
        LOBYTE(v22) = HIBYTE(v22);
      if ((v22 & 4) != 0)
      {
        *(int8x16_t *)(a2 + 168) = vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL);
        *(_QWORD *)(a2 + 184) = 0;
      }
      v15 += 3;
      v13 += 32;
      --v7;
    }
    while (v7);
  }
}

ssize_t Security::CodeSigning::DYLDCacheRep::Writer::flush(Security::CodeSigning::DYLDCacheRep::Writer *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  Security::UnixPlusPlus::FileDesc *v10;
  Security::UnixPlusPlus::FileDesc *v11;

  v9 = *((_QWORD *)this + 17);
  if (v9)
    MEMORY[0x18D76FAA0](v9, 0x1000C403E1C8BA9);
  *((_QWORD *)this + 17) = Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make((uint64_t)this + 104, a2, a3, a4, a5, a6, a7, a8);
  v10 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  Security::UnixPlusPlus::FileDesc::seek((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v10, *(_QWORD *)(*((_QWORD *)this + 16) + 104));
  v11 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  return Security::UnixPlusPlus::FileDesc::writeAll((ssize_t)v11, *((char **)this + 17), bswap32(*(_DWORD *)(*((_QWORD *)this + 17) + 4)));
}

_DWORD *Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  unsigned int v10;
  _DWORD *v11;
  _DWORD *v12;
  unsigned int v13;
  _QWORD *v14;
  int v15;
  unsigned int v16;
  _DWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  BOOL v21;
  __int128 v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  NSObject *v27;
  void **v29;
  char v30;
  void *__dst[2];
  char v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  void *__p[2];
  __int128 v38;
  __int128 v39;
  _OWORD v40[9];
  unint64_t v41;
  uint8_t buf[4];
  void **v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v9 = *(_DWORD *)(a1 + 16);
  v33 = 0uLL;
  *(_QWORD *)&v34 = 0;
  v10 = Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::size((_QWORD *)a1, (uint64_t **)&v33, 0, a4, a5, a6, a7, a8, v30);
  v11 = malloc_type_malloc(v10, 0x79CB62BEuLL);
  if (!v11)
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  v12 = v11;
  v13 = *(_DWORD *)(a1 + 16);
  *v11 = -1072898310;
  v11[1] = bswap32(v10);
  v11[2] = bswap32(v13);
  v14 = *(_QWORD **)a1;
  if (*(_QWORD *)a1 != a1 + 8)
  {
    v15 = 0;
    v16 = 8 * v9 + 12;
    do
    {
      v17 = &v12[2 * v15];
      v17[3] = bswap32(*((_DWORD *)v14 + 8));
      v17[4] = bswap32(v16);
      memcpy((char *)v12 + v16, (const void *)v14[5], bswap32(*(_DWORD *)(v14[5] + 4)));
      v18 = (_QWORD *)v14[1];
      v19 = v14;
      if (v18)
      {
        do
        {
          v20 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v20 = (_QWORD *)v19[2];
          v21 = *v20 == (_QWORD)v19;
          v19 = v20;
        }
        while (!v21);
      }
      v16 += bswap32(*(_DWORD *)(v14[5] + 4));
      ++v15;
      v14 = v20;
    }
    while (v20 != (_QWORD *)(a1 + 8));
  }
  v41 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v22 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v40[7] = v22;
  v40[8] = v22;
  v40[5] = v22;
  v40[6] = v22;
  v40[3] = v22;
  v40[4] = v22;
  v40[1] = v22;
  v40[2] = v22;
  v40[0] = v22;
  v38 = v22;
  v39 = v22;
  v36 = v22;
  *(_OWORD *)__p = v22;
  v34 = v22;
  v35 = v22;
  v33 = v22;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v33);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v33, (uint64_t)"Maker ", 6);
  v23 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)" assembles ", 11);
  v24 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)" blob(s) into ", 14);
  v25 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)" (size=", 7);
  v26 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)")", 1);
  v27 = secLogObjForScope("superblob");
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)&v33 + 8);
    v29 = v32 >= 0 ? __dst : (void **)__dst[0];
    *(_DWORD *)buf = 136315138;
    v43 = v29;
    _os_log_debug_impl(&dword_18A900000, v27, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
    if (v32 < 0)
      operator delete(__dst[0]);
  }
  *(_QWORD *)&v33 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)&v33 + *(_QWORD *)(v33 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  *((_QWORD *)&v33 + 1) = MEMORY[0x1E0DE4FB8] + 16;
  if (SHIBYTE(v38) < 0)
    operator delete(__p[1]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18D76FA34](v40);
  return v12;
}

void sub_18AA269F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::size(_QWORD *a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  char *v21;

  v9 = (_QWORD *)*a1;
  if ((_QWORD *)*a1 == a1 + 1)
  {
    v10 = 0;
  }
  else
  {
    v10 = 0;
    do
    {
      v11 = (_QWORD *)v9[1];
      v12 = v9;
      if (v11)
      {
        do
        {
          v13 = v11;
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          v13 = (_QWORD *)v12[2];
          v14 = *v13 == (_QWORD)v12;
          v12 = v13;
        }
        while (!v14);
      }
      v10 += bswap32(*(_DWORD *)(v9[5] + 4));
      v9 = v13;
    }
    while (v13 != a1 + 1);
  }
  v15 = a2[1];
  if (*a2 != v15)
  {
    v16 = *a2;
    do
    {
      v17 = *v16++;
      v10 += v17;
    }
    while (v16 != v15);
  }
  v18 = a1[2] + v15 - *a2;
  if (a3)
  {
    v21 = &a9;
    do
    {
      ++v18;
      v10 += a3;
      v19 = (uint64_t *)v21;
      v21 += 8;
      a3 = *v19;
    }
    while (*v19);
  }
  return v10 + 8 * v18 + 12;
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;

  v2 = MEMORY[0x1E0DE4FE0];
  v3 = MEMORY[0x1E0DE4FE0] + 64;
  *(_QWORD *)(a1 + 112) = MEMORY[0x1E0DE4FE0] + 64;
  v4 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_18AA26BAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x18D76FA34](v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  size_t v16;
  std::locale::__imp *v17;
  uint64_t v18;
  uint64_t v19;
  std::locale *v20;
  uint64_t v21;
  _QWORD v23[2];
  std::locale __b[3];

  v23[0] = 0xAAAAAAAAAAAAAAAALL;
  v23[1] = 0xAAAAAAAAAAAAAAAALL;
  MEMORY[0x18D76F998](v23, a1);
  if (LOBYTE(v23[0]))
  {
    v6 = (char *)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *((_QWORD *)v6 + 5);
    v8 = *((_DWORD *)v6 + 2);
    v9 = *((_DWORD *)v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(__b, MEMORY[0x1E0DE4A90]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(__b);
      *((_DWORD *)v6 + 36) = v9;
    }
    v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20)
      v12 = a2 + a3;
    else
      v12 = a2;
    if (!v7)
      goto LABEL_29;
    v13 = *((_QWORD *)v6 + 3);
    v14 = v13 <= a3;
    v15 = v13 - a3;
    v16 = v14 ? 0 : v15;
    if (v12 - a2 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_29;
    }
    if ((uint64_t)v16 >= 1)
    {
      memset(__b, 170, sizeof(__b));
      if (v16 >= 0x7FFFFFFFFFFFFFF8)
        std::string::__throw_length_error[abi:ne180100]();
      if (v16 >= 0x17)
      {
        v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v16 | 7) != 0x17)
          v18 = v16 | 7;
        v19 = v18 + 1;
        v17 = (std::locale::__imp *)operator new(v18 + 1);
        __b[1].__locale_ = (std::locale::__imp *)v16;
        __b[2].__locale_ = (std::locale::__imp *)(v19 | 0x8000000000000000);
        __b[0].__locale_ = v17;
      }
      else
      {
        HIBYTE(__b[2].__locale_) = v16;
        v17 = (std::locale::__imp *)__b;
      }
      memset(v17, v9, v16);
      *((_BYTE *)v17 + v16) = 0;
      v20 = SHIBYTE(__b[2].__locale_) >= 0 ? __b : (std::locale *)__b[0].__locale_;
      v21 = (*(uint64_t (**)(uint64_t, std::locale *, size_t))(*(_QWORD *)v7 + 96))(v7, v20, v16);
      if (SHIBYTE(__b[2].__locale_) < 0)
        operator delete(__b[0].__locale_);
      if (v21 != v16)
        goto LABEL_29;
    }
    if (v11 - v12 < 1
      || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, v12, v11 - v12) == v11 - v12)
    {
      *((_QWORD *)v6 + 3) = 0;
    }
    else
    {
LABEL_29:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x18D76F9A4](v23);
  return a1;
}

void sub_18AA26E08(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _QWORD *v17;

  if (a17 < 0)
    operator delete(__p);
  MEMORY[0x18D76F9A4](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(_QWORD *)(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x18AA26DDCLL);
}

void sub_18AA26E68(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *std::stringbuf::str[abi:ne180100]<std::allocator<char>>(_QWORD *__dst, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  size_t v4;
  unint64_t v5;
  unint64_t v6;
  const void **v7;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;

  v2 = __dst;
  v3 = *(_DWORD *)(a2 + 96);
  if ((v3 & 0x10) != 0)
  {
    v5 = *(_QWORD *)(a2 + 88);
    v6 = *(_QWORD *)(a2 + 48);
    if (v5 < v6)
    {
      *(_QWORD *)(a2 + 88) = v6;
      v5 = v6;
    }
    v7 = (const void **)(a2 + 40);
  }
  else
  {
    if ((v3 & 8) == 0)
    {
      v4 = 0;
      *((_BYTE *)__dst + 23) = 0;
      goto LABEL_16;
    }
    v7 = (const void **)(a2 + 16);
    v5 = *(_QWORD *)(a2 + 32);
  }
  v8 = *v7;
  v4 = v5 - (_QWORD)*v7;
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (v4 >= 0x17)
  {
    v9 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v9 = v4 | 7;
    v10 = v9 + 1;
    v11 = operator new(v9 + 1);
    v2[1] = v4;
    v2[2] = v10 | 0x8000000000000000;
    *v2 = v11;
    v2 = v11;
  }
  else
  {
    *((_BYTE *)__dst + 23) = v4;
    if (!v4)
      goto LABEL_16;
  }
  __dst = memmove(v2, v8, v4);
LABEL_16:
  *((_BYTE *)v2 + v4) = 0;
  return __dst;
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F60];
  v3 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18D76FA34](a1 + 112);
  return a1;
}

uint64_t Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)a1;
  if (*(_QWORD *)a1 != a1 + 8)
  {
    do
    {
      free((void *)v3[5]);
      v4 = (_QWORD *)v3[1];
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = (_QWORD *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          v5 = (_QWORD *)v3[2];
          v6 = *v5 == (_QWORD)v3;
          v3 = v5;
        }
        while (!v6);
      }
      v3 = v5;
    }
    while (v5 != v2);
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)(a1 + 8));
  return a1;
}

_QWORD *Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer(_QWORD *a1)
{
  pthread_mutex_t *v2;
  Security::UnixError *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  _QWORD v8[2];

  v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01;
  v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3)
    Security::UnixError::throwMe(v3);
  if (*a1)
  {
    v4 = (unsigned int *)(*a1 + 8);
    do
    {
      v5 = __ldxr(v4);
      v6 = v5 - 1;
    }
    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1)
        (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 8))(*a1);
      *a1 = 0;
    }
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

uint64_t Security::CodeSigning::DirScanner::DirScanner(uint64_t a1, const std::string *a2)
{
  const char *v3;
  DIR *v4;
  char v5;
  int *v7;

  *(_BYTE *)(a1 + 1080) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  std::string::operator=((std::string *)a1, a2);
  if (*(_QWORD *)(a1 + 24))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEF7A9);
  *__error() = 0;
  v3 = (const char *)a1;
  if (*(char *)(a1 + 23) < 0)
    v3 = *(const char **)a1;
  v4 = opendir(v3);
  *(_QWORD *)(a1 + 24) = v4;
  if (v4)
  {
    v5 = 1;
  }
  else
  {
    if (*__error() != 2)
    {
      v7 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v7);
    }
    v5 = 0;
  }
  *(_BYTE *)(a1 + 1080) = v5;
  return a1;
}

void sub_18AA27190(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::DirScanner::~DirScanner(Security::CodeSigning::DirScanner *this)
{
  DIR *v2;

  v2 = (DIR *)*((_QWORD *)this + 3);
  if (v2)
    closedir(v2);
  if (*((char *)this + 23) < 0)
    operator delete(*(void **)this);
}

dirent *Security::CodeSigning::DirScanner::getNext(DIR **this)
{
  dirent *v2;
  Security::UnixError *v3;
  dirent *v4;
  dirent *v6;

  v6 = (dirent *)0xAAAAAAAAAAAAAAAALL;
  v2 = (dirent *)(this + 4);
  do
  {
    v3 = (Security::UnixError *)readdir_r(this[3], v2, &v6);
    if ((_DWORD)v3)
      Security::UnixError::throwMe(v3);
    v4 = v6;
  }
  while (v6 && (!strcmp(v6->d_name, ".") || !strcmp(v4->d_name, "..")));
  return v4;
}

BOOL Security::CodeSigning::DirScanner::isRegularFile(Security::CodeSigning::DirScanner *this, dirent *a2)
{
  timespec v5;
  size_t v6;
  std::string *v7;
  Security::CodeSigning::DirScanner *v8;
  char *d_name;
  std::string::size_type v10;
  std::string *v11;
  __int128 v12;
  void **v13;
  Security::MacOSError *v14;
  std::string v15;
  void *__p[2];
  int64_t v17;
  stat v18;

  if (a2->d_type)
    return a2->d_type == 8;
  v5.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v5.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v18.st_blksize = v5;
  *(timespec *)v18.st_qspare = v5;
  v18.st_birthtimespec = v5;
  *(timespec *)&v18.st_size = v5;
  v18.st_mtimespec = v5;
  v18.st_ctimespec = v5;
  *(timespec *)&v18.st_uid = v5;
  v18.st_atimespec = v5;
  *(timespec *)&v18.st_dev = v5;
  if (*((char *)this + 23) >= 0)
    v6 = *((unsigned __int8 *)this + 23);
  else
    v6 = *((_QWORD *)this + 1);
  memset(&v15, 170, sizeof(v15));
  v7 = &v15;
  std::string::basic_string[abi:ne180100]((uint64_t)&v15, v6 + 1);
  if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v7 = (std::string *)v15.__r_.__value_.__r.__words[0];
  if (v6)
  {
    if (*((char *)this + 23) >= 0)
      v8 = this;
    else
      v8 = *(Security::CodeSigning::DirScanner **)this;
    memmove(v7, v8, v6);
  }
  *(_WORD *)((char *)&v7->__r_.__value_.__l.__data_ + v6) = 47;
  d_name = a2->d_name;
  v10 = strlen(d_name);
  v11 = std::string::append(&v15, d_name, v10);
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v17 = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (v17 >= 0)
    v13 = __p;
  else
    v13 = (void **)__p[0];
  v14 = (Security::MacOSError *)stat((const char *)v13, &v18);
  if ((_DWORD)v14)
    Security::MacOSError::throwMe(v14);
  if (SHIBYTE(v17) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v15.__r_.__value_.__l.__data_);
  return (v18.st_mode & 0xF000) == 0x8000;
}

void sub_18AA273E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::DirValidator::~DirValidator(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  const void *v5;

  v3 = *this;
  v2 = this[1];
  if (*this != v2)
  {
    do
    {
      v4 = *v3;
      if (*v3)
      {
        v5 = *(const void **)(v4 + 64);
        if (v5)
          _Block_release(v5);
        Security::CodeSigning::ResourceBuilder::Rule::~Rule((void **)v4);
        MEMORY[0x18D76FAA0]();
        v2 = this[1];
      }
      ++v3;
    }
    while (v3 != v2);
    v3 = *this;
  }
  if (v3)
  {
    this[1] = v3;
    operator delete(v3);
  }
}

void Security::CodeSigning::DirValidator::validate(uint64_t a1, uint64_t a2, unsigned int a3)
{
  char *v5;
  FTS *v6;
  FTSENT *v7;
  FTSENT *v8;
  uint64_t v9;
  char *v10;
  int v11;
  unsigned int fts_info;
  NSObject *v13;
  char *v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  const regex_t *v18;
  const char *v19;
  NSObject *v20;
  const regex_t *v21;
  const regex_t *v22;
  int v23;
  uint64_t *v24;
  uint64_t **v25;
  uint64_t **v26;
  unint64_t v27;
  uint64_t *v28;
  NSObject *v29;
  ssize_t v30;
  Security::CodeSigning *v31;
  int IsValidXattrFile;
  char v33;
  NSObject *v34;
  char *v35;
  char *v36;
  char *v37;
  char *fts_path;
  __int128 v39;
  _QWORD *v40;
  _QWORD *v41;
  NSObject *v42;
  void **v43;
  int *v44;
  NSObject *v45;
  int v46;
  int fts_errno;
  char *v48;
  int *v49;
  void *__dst[2];
  char v52;
  void *__p[2];
  char v54;
  uint64_t **v55;
  uint64_t *v56;
  uint64_t v57;
  uint8_t buf[4];
  void **v59;
  char *__b[132];

  __b[129] = *(char **)MEMORY[0x1E0C80C00];
  v56 = 0;
  v57 = 0;
  v55 = &v56;
  if (*(char *)(a2 + 23) >= 0)
    v5 = (char *)a2;
  else
    v5 = *(char **)a2;
  __b[0] = v5;
  __b[1] = 0;
  v6 = fts_open(__b, 21, 0);
  if (!v6)
  {
    v49 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v49);
  }
  while (1)
  {
    v7 = fts_read(v6);
    v8 = v7;
    if (!v7)
      break;
    v9 = *(unsigned __int8 *)(a2 + 23);
    if ((v9 & 0x80u) != 0)
      v9 = *(_QWORD *)(a2 + 8);
    v10 = &v7->fts_path[v9 + 1];
    v11 = v7->fts_statp->st_mode & 0x49;
    fts_info = v7->fts_info;
    if (fts_info > 7)
    {
      if (fts_info == 12)
      {
        v29 = secLogObjForScope("dirval");
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          fts_path = v8->fts_path;
          LODWORD(__b[0]) = 136315138;
          *(char **)((char *)__b + 4) = fts_path;
          _os_log_debug_impl(&dword_18A900000, v29, OS_LOG_TYPE_DEBUG, "symlink %s", (uint8_t *)__b, 0xCu);
        }
        memset(__b, 170, 0x400uLL);
        v30 = readlink(v8->fts_accpath, (char *)__b, 0x3FFuLL);
        if (v30 < 0)
        {
          v44 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v44);
        }
        *((_BYTE *)__b + v30) = 0;
        v18 = Security::CodeSigning::DirValidator::match((const regex_t ***)a1, v10, 4, v11 != 0, (char *)__b);
      }
      else
      {
        if (fts_info != 8)
        {
LABEL_64:
          v45 = secLogObjForScope("dirval");
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          {
            v46 = v8->fts_info;
            fts_errno = v8->fts_errno;
            v48 = v8->fts_path;
            LODWORD(__b[0]) = 67109634;
            HIDWORD(__b[0]) = v46;
            LOWORD(__b[1]) = 1024;
            *(_DWORD *)((char *)&__b[1] + 2) = fts_errno;
            HIWORD(__b[1]) = 2080;
            __b[2] = v48;
            _os_log_debug_impl(&dword_18A900000, v45, OS_LOG_TYPE_DEBUG, "type %d (errno %d): %s", (uint8_t *)__b, 0x18u);
          }
          Security::MacOSError::throwMe((Security::MacOSError *)a3);
        }
        v17 = secLogObjForScope("dirval");
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
        {
          v36 = v8->fts_path;
          LODWORD(__b[0]) = 136315138;
          *(char **)((char *)__b + 4) = v36;
          _os_log_debug_impl(&dword_18A900000, v17, OS_LOG_TYPE_DEBUG, "file %s", (uint8_t *)__b, 0xCu);
        }
        v18 = Security::CodeSigning::DirValidator::match((const regex_t ***)a1, v10, 1, v11 != 0, 0);
      }
      v22 = v18;
      if (v18)
        goto LABEL_24;
LABEL_41:
      if (v8->fts_info != 8
        || (*(char *)(a2 + 23) >= 0 ? (v31 = (Security::CodeSigning *)a2) : (v31 = *(Security::CodeSigning **)a2),
            !Security::CodeSigning::pathFileSystemUsesXattrFiles(v31, v19)))
      {
LABEL_62:
        Security::MacOSError::throwMe((Security::MacOSError *)a3);
      }
      std::string::basic_string[abi:ne180100]<0>(__p, v8->fts_path);
      IsValidXattrFile = Security::CodeSigning::pathIsValidXattrFile((char *)__p, "csutilities");
      v33 = IsValidXattrFile;
      if (v54 < 0)
      {
        operator delete(__p[0]);
        if ((v33 & 1) == 0)
          goto LABEL_62;
      }
      else if (!IsValidXattrFile)
      {
        goto LABEL_62;
      }
      v34 = secLogObjForScope("dirval");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        v35 = v8->fts_path;
        LODWORD(__b[0]) = 136315138;
        *(char **)((char *)__b + 4) = v35;
        v15 = v34;
        v16 = "skipping file due to xattr: %s";
LABEL_52:
        _os_log_debug_impl(&dword_18A900000, v15, OS_LOG_TYPE_DEBUG, v16, (uint8_t *)__b, 0xCu);
      }
    }
    else if (fts_info == 1)
    {
      v20 = secLogObjForScope("dirval");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        v37 = v8->fts_path;
        LODWORD(__b[0]) = 136315138;
        *(char **)((char *)__b + 4) = v37;
        _os_log_debug_impl(&dword_18A900000, v20, OS_LOG_TYPE_DEBUG, "entering %s", (uint8_t *)__b, 0xCu);
      }
      if (v8->fts_level)
      {
        v21 = Security::CodeSigning::DirValidator::match((const regex_t ***)a1, v10, 2, v11 != 0, 0);
        v22 = v21;
        if (v21)
        {
          v23 = *(&v21[1].re_magic + 1);
          if ((v23 & 0x20) != 0)
            goto LABEL_25;
        }
        fts_set(v6, v8, 4);
        if (!v22)
          goto LABEL_41;
LABEL_24:
        v23 = *(&v22[1].re_magic + 1);
LABEL_25:
        if ((v23 & 0x10) != 0)
        {
          v24 = v56;
          v25 = &v56;
          v26 = &v56;
          if (v56)
          {
            while (1)
            {
              while (1)
              {
                v26 = (uint64_t **)v24;
                v27 = v24[4];
                if ((unint64_t)v22 >= v27)
                  break;
                v24 = *v26;
                v25 = v26;
                if (!*v26)
                  goto LABEL_33;
              }
              if (v27 >= (unint64_t)v22)
                break;
              v24 = v26[1];
              if (!v24)
              {
                v25 = v26 + 1;
                goto LABEL_33;
              }
            }
          }
          else
          {
LABEL_33:
            v28 = (uint64_t *)operator new(0x28uLL);
            v28[4] = (uint64_t)v22;
            *v28 = 0;
            v28[1] = 0;
            v28[2] = (uint64_t)v26;
            *v25 = v28;
            if (*v55)
            {
              v55 = (uint64_t **)*v55;
              v28 = *v25;
            }
            std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v56, v28);
            ++v57;
          }
        }
      }
    }
    else
    {
      if (fts_info != 6)
        goto LABEL_64;
      v13 = secLogObjForScope("dirval");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v14 = v8->fts_path;
        LODWORD(__b[0]) = 136315138;
        *(char **)((char *)__b + 4) = v14;
        v15 = v13;
        v16 = "leaving %s";
        goto LABEL_52;
      }
    }
  }
  if (v57 != *(_DWORD *)(a1 + 24))
  {
    __b[32] = (char *)0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v39 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&__b[28] = v39;
    *(_OWORD *)&__b[30] = v39;
    *(_OWORD *)&__b[24] = v39;
    *(_OWORD *)&__b[26] = v39;
    *(_OWORD *)&__b[20] = v39;
    *(_OWORD *)&__b[22] = v39;
    *(_OWORD *)&__b[16] = v39;
    *(_OWORD *)&__b[18] = v39;
    *(_OWORD *)&__b[12] = v39;
    *(_OWORD *)&__b[14] = v39;
    *(_OWORD *)&__b[8] = v39;
    *(_OWORD *)&__b[10] = v39;
    *(_OWORD *)&__b[6] = v39;
    *(_OWORD *)&__b[2] = v39;
    *(_OWORD *)&__b[4] = v39;
    *(_OWORD *)__b = v39;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)__b);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(__b, (uint64_t)"matched ", 8);
    v40 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)" of ", 4);
    v41 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)" required rules", 15);
    v42 = secLogObjForScope("dirval");
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)&__b[1]);
      v43 = v52 >= 0 ? __dst : (void **)__dst[0];
      *(_DWORD *)buf = 136315138;
      v59 = v43;
      _os_log_debug_impl(&dword_18A900000, v42, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
      if (v52 < 0)
        operator delete(__dst[0]);
    }
    Security::MacOSError::throwMe((Security::MacOSError *)a3);
  }
  fts_close(v6);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v56);
}

void sub_18AA27AE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,_QWORD *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45)
{
  FTS *v45;

  a28 = *MEMORY[0x1E0DE4F60];
  *(uint64_t *)((char *)&a28 + *(_QWORD *)(a28 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  a29 = MEMORY[0x1E0DE4FB8] + 16;
  if (a42 < 0)
    operator delete(__p);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18D76FA34](&a45);
  fts_close(v45);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a24);
  _Unwind_Resume(a1);
}

const regex_t *Security::CodeSigning::DirValidator::match(const regex_t ***this, char *a2, int a3, char a4, char *a5)
{
  const regex_t **v5;
  const regex_t *v11;
  int v12;
  const char *v13;
  uint64_t v14;
  void *v15;
  NSObject *v16;
  __int128 v17;
  void **v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  char v22;
  void **v23;
  void *__p[2];
  char v26;
  void *v27[3];
  regex_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v5 = *this;
  if (*this != this[1])
  {
    while (1)
    {
      v11 = *v5;
      v12 = *(&(*v5)[1].re_magic + 1);
      if ((v12 & a3) != 0 && ((v12 & 8) == 0 || (a4 & 1) == 0))
      {
        if (Security::CodeSigning::ResourceBuilder::Rule::match(*v5, a2))
          break;
      }
LABEL_29:
      if (++v5 == this[1])
        return 0;
    }
    if (!a5)
      return v11;
    v14 = *(_QWORD *)&v11[2].re_magic;
    if (!v14)
    {
      Security::Syslog::notice((Security::Syslog *)"code signing internal problem: !mTargetBlock", v13);
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
    }
    memset(v27, 170, sizeof(v27));
    std::string::basic_string[abi:ne180100]<0>(&v28, a2);
    std::string::basic_string[abi:ne180100]<0>(__p, a5);
    (*(void (**)(void **__return_ptr, uint64_t, regex_t *, void **))(v14 + 16))(v27, v14, &v28, __p);
    if (v26 < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v28.re_endp) < 0)
      operator delete(*(void **)&v28.re_magic);
    v15 = (void *)HIBYTE(v27[2]);
    if (SHIBYTE(v27[2]) < 0)
      v15 = v27[1];
    if (v15)
    {
      v16 = secLogObjForScope("dirval");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        if (SHIBYTE(v27[2]) >= 0)
          v23 = v27;
        else
          v23 = (void **)v27[0];
        v28.re_magic = 136315650;
        *(_QWORD *)(&v28.re_magic + 1) = a2;
        WORD2(v28.re_nsub) = 2080;
        *(size_t *)((char *)&v28.re_nsub + 6) = (size_t)a5;
        HIWORD(v28.re_endp) = 2080;
        v28.re_g = (re_guts *)v23;
        _os_log_debug_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEBUG, "%s: match target %s against %s", (uint8_t *)&v28, 0x20u);
      }
      *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v28.re_magic = v17;
      *(_OWORD *)&v28.re_endp = v17;
      if (SHIBYTE(v27[2]) >= 0)
        v18 = v27;
      else
        v18 = (void **)v27[0];
      if (regcomp(&v28, (const char *)v18, 5))
      {
        Security::Syslog::notice((Security::Syslog *)"code signing internal problem: failed to compile internal RE", v19);
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
      }
      v20 = regexec(&v28, a5, 0, 0, 0);
      MEMORY[0x18D770EEC](&v28);
      if ((_DWORD)v20)
      {
        if ((_DWORD)v20 != 1)
        {
          Security::Syslog::notice((Security::Syslog *)"code signing internal error: regexec failed error=%d", v21, v20);
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
        }
        v22 = 0;
      }
      else
      {
        v22 = 1;
      }
      if ((HIBYTE(v27[2]) & 0x80) == 0)
      {
LABEL_28:
        if ((v22 & 1) != 0)
          return v11;
        goto LABEL_29;
      }
    }
    else
    {
      v22 = 1;
      if ((HIBYTE(v27[2]) & 0x80) == 0)
        goto LABEL_28;
    }
    operator delete(v27[0]);
    goto LABEL_28;
  }
  return 0;
}

void sub_18AA27E70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::DirValidator::Rule::Rule(uint64_t a1, __int128 *a2, int a3, const void *a4)
{
  *(_QWORD *)&Security::CodeSigning::ResourceBuilder::Rule::Rule((regex_t *)a1, a2, 0, a3)[2].re_magic = 0;
  if (a4)
    *(_QWORD *)(a1 + 64) = _Block_copy(a4);
  return a1;
}

void sub_18AA27F10(_Unwind_Exception *a1)
{
  void **v1;

  Security::CodeSigning::ResourceBuilder::Rule::~Rule(v1);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::registerStapledTicketWithSystem(Security::CodeSigning *this, const __CFData *a2)
{
  NSObject *v2;
  uint8_t v3[16];

  if (this)
  {
    v2 = secLogObjForScope("notarization");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)v3 = 0;
      _os_log_debug_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEBUG, "Registering stapled ticket with system", v3, 2u);
    }
  }
}

const void **Security::CFRef<__CFError *>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t SecCodeSignerGetTypeID()
{
  return *(_QWORD *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 408);
}

void sub_18AA27FD8(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18AA27FD0);
}

_QWORD *Security::ModuleNexus<Security::CodeSigning::CFObjects>::make()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  Security::UnixError *v5;

  v0 = (_QWORD *)operator new();
  v0[2] = 0;
  v0[3] = 0;
  v0[4] = Security::CFClass::finalizeType;
  v0[5] = Security::CFClass::equalType;
  v0[6] = Security::CFClass::hashType;
  v0[7] = Security::CFClass::copyFormattingDescType;
  v0[8] = Security::CFClass::copyDebugDescType;
  *v0 = 8;
  v0[1] = "SecCode";
  v0[10] = Security::CFClass::refCountForType;
  v1 = _CFRuntimeRegisterClass();
  v0[13] = 8;
  v0[12] = v1;
  v0[14] = "SecStaticCode";
  v0[15] = 0;
  v0[16] = 0;
  v0[17] = Security::CFClass::finalizeType;
  v0[18] = Security::CFClass::equalType;
  v0[19] = Security::CFClass::hashType;
  v0[20] = Security::CFClass::copyFormattingDescType;
  v0[21] = Security::CFClass::copyDebugDescType;
  v0[23] = Security::CFClass::refCountForType;
  v2 = _CFRuntimeRegisterClass();
  v0[26] = 8;
  v0[25] = v2;
  v0[27] = "SecRequirements";
  v0[28] = 0;
  v0[29] = 0;
  v0[30] = Security::CFClass::finalizeType;
  v0[31] = Security::CFClass::equalType;
  v0[32] = Security::CFClass::hashType;
  v0[33] = Security::CFClass::copyFormattingDescType;
  v0[34] = Security::CFClass::copyDebugDescType;
  v0[36] = Security::CFClass::refCountForType;
  v3 = _CFRuntimeRegisterClass();
  v0[40] = "SecCodeSigner";
  v0[41] = 0;
  v0[42] = 0;
  v0[43] = Security::CFClass::finalizeType;
  v0[44] = Security::CFClass::equalType;
  v0[45] = Security::CFClass::hashType;
  v0[46] = Security::CFClass::copyFormattingDescType;
  v0[47] = Security::CFClass::copyDebugDescType;
  v0[38] = v3;
  v0[39] = 8;
  v0[49] = Security::CFClass::refCountForType;
  v4 = _CFRuntimeRegisterClass();
  v0[53] = "SecCodeSignerRemote";
  v0[54] = 0;
  v0[55] = 0;
  v0[56] = Security::CFClass::finalizeType;
  v0[57] = Security::CFClass::equalType;
  v0[58] = Security::CFClass::hashType;
  v0[59] = Security::CFClass::copyFormattingDescType;
  v0[60] = Security::CFClass::copyDebugDescType;
  v0[51] = v4;
  v0[52] = 8;
  v0[62] = Security::CFClass::refCountForType;
  v0[64] = _CFRuntimeRegisterClass();
  v5 = (Security::UnixError *)pthread_key_create(v0 + 65, (void (__cdecl *)(void *))Security::PerThreadPointer<Security::CodeSigning::PerThread>::destructor);
  if ((_DWORD)v5)
    Security::UnixError::throwMe(v5);
  return v0;
}

void sub_18AA28178(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x10D0C40CB15CC2FLL);
  _Unwind_Resume(a1);
}

uint64_t SecCodeSignerCreate(const __CFDictionary *a1, int a2, _QWORD *a3)
{
  uint64_t v6;
  const Security::CFClass *v7;
  uint64_t v8;
  Security::SecCFObject *v9;
  unsigned __int8 *v10;
  unsigned __int8 v11;
  const void *v12;
  const void *v13;
  Security::SecCFObject *v15;

  if ((a2 & 0xFEFFF000) != 0)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v15 = (Security::SecCFObject *)0xAAAAAAAAAAAAAAAALL;
  v6 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  v8 = Security::SecCFObject::allocate((Security::SecCFObject *)0x140, *(_QWORD *)(v6 + 408), v7);
  v9 = (Security::SecCFObject *)v8;
  *(_QWORD *)(v8 + 8) = 1;
  *(_QWORD *)v8 = off_1E1FC8A78;
  *(_DWORD *)(v8 + 16) = a2;
  *(_QWORD *)(v8 + 168) = 0;
  *(_QWORD *)(v8 + 160) = 0;
  *(_OWORD *)(v8 + 24) = 0u;
  *(_OWORD *)(v8 + 40) = 0u;
  *(_OWORD *)(v8 + 56) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_QWORD *)(v8 + 152) = v8 + 160;
  *(_QWORD *)(v8 + 288) = 0;
  *(_DWORD *)(v8 + 296) = 0;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 192) = 0u;
  *(_OWORD *)(v8 + 208) = 0u;
  *(_OWORD *)(v8 + 224) = 0u;
  *(_QWORD *)(v8 + 240) = 0;
  *(_QWORD *)(v8 + 256) = 0;
  *(_QWORD *)(v8 + 264) = 0;
  *(_QWORD *)(v8 + 272) = 0;
  v10 = (unsigned __int8 *)(v8 - 8);
  *(_QWORD *)(v8 + 304) = 0;
  *(_QWORD *)(v8 + 312) = 0;
  do
    v11 = __ldaxr(v10);
  while (__stlxr(1u, v10));
  if ((v11 & 1) != 0)
  {
    v12 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 16))(v8);
    CFRetain(v12);
  }
  v15 = v9;
  Security::CodeSigning::SecCodeSigner::parameters(v9, a1);
  v13 = Security::SecCFObject::handle(v9, 1);
  if (!a3)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  *a3 = v13;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v15);
  return 0;
}

void sub_18AA282E0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  _DWORD *v11;
  void *v12;
  unsigned int v13;
  int v14;
  const char *v15;

  switch(a2)
  {
    case 6:
      v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8)
        break;
LABEL_6:
      (*(void (**)(_DWORD *))(*(_QWORD *)v11 + 24))(v11);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      v11 = __cxa_begin_catch(a1);
      v13 = v11[36];
      if (v13 > 0x1A)
        goto LABEL_6;
      v14 = 1 << v13;
      if ((v14 & 0x800108) == 0 && (v14 & 0x4014000) == 0)
        goto LABEL_6;
      break;
    case 3:
LABEL_5:
      v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v12 + 24))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA282A8);
}

void sub_18AA28414(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t SecCodeSignerAddSignature(uint64_t a1, Security::CodeSigning::SecStaticCode *a2, int a3)
{
  return SecCodeSignerAddSignatureWithErrors(a1, a2, a3);
}

uint64_t SecCodeSignerAddSignatureWithErrors(uint64_t a1, Security::CodeSigning::SecStaticCode *a2, int a3)
{
  uint64_t v3;
  Security::CodeSigning::SecCodeSigner *v6;
  const __SecCode *v7;
  Security::CodeSigning::SecCodeSigner *v8;
  Security::CodeSigning::SecStaticCode *v9;

  if ((a3 & 0xEFFFFFFF) != 0)
  {
    v3 = 4294900226;
    goto LABEL_6;
  }
  v3 = 4294900225;
  if (!a1
  {
LABEL_6:
    Security::MacOSError::throwMe((Security::MacOSError *)v3);
  }
  v8 = v6;
  v9 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::required(a2, v7);
  Security::CodeSigning::SecCodeSigner::sign(v8, v9, a3);
  return 0;
}

void *Security::CodeSigning::SecStaticCode::required(Security::CodeSigning::SecStaticCode *this, const __SecCode *a2)
{
  void *result;

  if (!this
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  return result;
}

CFDateRef Security::CodeSigning::copyCutOffDate(const __CFString *this, const __CFString *a2, CFAbsoluteTime a3)
{
  CFDateRef v4;
  const __CFDate *v5;
  const __CFDate *v6;
  CFTypeID v7;
  CFDateRef v8;

  v4 = CFDateCreate(0, a3);
  v5 = (const __CFDate *)CFPreferencesCopyValue(this, CFSTR("com.apple.security.syspolicy"), (CFStringRef)*MEMORY[0x1E0C9B260], (CFStringRef)*MEMORY[0x1E0C9B230]);
  if (!v5)
  {
    CFRetain(v4);
    v8 = v4;
    if (!v4)
      return v8;
    goto LABEL_7;
  }
  v6 = v5;
  v7 = CFGetTypeID(v5);
  v8 = v4;
  if (v7 == CFDateGetTypeID())
  {
    if (CFDateCompare(v4, v6, 0) <= kCFCompareEqualTo)
      v8 = v4;
    else
      v8 = v6;
  }
  CFRetain(v8);
  CFRelease(v6);
  if (v4)
LABEL_7:
    CFRelease(v4);
  return v8;
}

void Security::CodeSigning::SecCode::checkValidity(Security::CodeSigning::SecCode *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  Security::CodeSigning::SecStaticCode *v6;
  uint64_t v7;
  const UInt8 *v8;
  uint64_t v9;
  const UInt8 *v10;
  int v11;
  char v12;
  char v13;
  const void *v14;
  CFDataRef v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  CFDataRef v19;
  _BYTE __p[24];
  CFDataRef v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 2))
    return;
  Security::CodeSigning::SecCode::checkValidity(*((Security::CodeSigning::SecCode **)this + 2), a2);
  if (!*((_BYTE *)this + 24))
  {
    (*(void (**)(Security::CodeSigning::SecCode *))(*(_QWORD *)this + 80))(this);
    *((_BYTE *)this + 24) = 1;
  }
  v4 = *((_QWORD *)this + 4);
  *(_DWORD *)(v4 + 208) = a2;
  v5 = *((_QWORD *)this + 2);
  if (!*(_BYTE *)(v5 + 24))
  {
    (*(void (**)(_QWORD))(*(_QWORD *)v5 + 80))(*((_QWORD *)this + 2));
    *(_BYTE *)(v5 + 24) = 1;
  }
  v6 = *(Security::CodeSigning::SecStaticCode **)(v5 + 32);
  Security::CodeSigning::SecStaticCode::validateNonResourceComponents((UInt8 *)v4);
  if ((a2 & 0x10) != 0)
  {
    v9 = *(_QWORD *)(v4 + 32);
    v10 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v4, 1);
    *(_QWORD *)&__p[8] = 0;
    *(_QWORD *)&__p[16] = 0;
    *(_QWORD *)__p = &__p[8];
    (*(void (**)(uint64_t, const UInt8 *, _BYTE *, uint64_t))(*(_QWORD *)v9 + 224))(v9, v10, __p, a2);
  }
  else
  {
    if ((a2 & 0x2000) == 0)
      goto LABEL_12;
    v7 = *(_QWORD *)(v4 + 32);
    v8 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v4, 1);
    *(_QWORD *)&__p[8] = 0;
    *(_QWORD *)&__p[16] = 0;
    *(_QWORD *)__p = &__p[8];
    (*(void (**)(uint64_t, const UInt8 *, _BYTE *, uint64_t))(*(_QWORD *)v7 + 232))(v7, v8, __p, a2);
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)&__p[8]);
LABEL_12:
  v11 = (*(uint64_t (**)(_QWORD, Security::CodeSigning::SecCode *))(**((_QWORD **)this + 2) + 104))(*((_QWORD *)this + 2), this);
  if ((v11 & 1) == 0)
  {
    v12 = os_variant_allows_internal_security_policies();
    v13 = (v11 & 0x4000000) != 0 ? v12 : 1;
    if ((v11 & 0x10000000) == 0 || (v13 & 1) == 0)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA09);
  }
  if (!*((_BYTE *)this + 24))
  {
    (*(void (**)(Security::CodeSigning::SecCode *))(*(_QWORD *)this + 80))(this);
    *((_BYTE *)this + 24) = 1;
  }
  v14 = (const void *)*((_QWORD *)this + 5);
  if (v14)
  {
    v15 = Security::CodeSigning::SecStaticCode::cdHash((CFDataRef *)v4);
    if (!CFEqual(v14, v15))
    {
      v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v4 + 32) + 48))(*(_QWORD *)(v4 + 32));
      v17 = secLogObjForScope("SecCode");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        if (!*((_BYTE *)this + 24))
        {
          (*(void (**)(Security::CodeSigning::SecCode *))(*(_QWORD *)this + 80))(this);
          *((_BYTE *)this + 24) = 1;
        }
        v18 = *((_QWORD *)this + 5);
        v19 = Security::CodeSigning::SecStaticCode::cdHash((CFDataRef *)v4);
        *(_DWORD *)__p = 138412802;
        *(_QWORD *)&__p[4] = v16;
        *(_WORD *)&__p[12] = 2112;
        *(_QWORD *)&__p[14] = v18;
        *(_WORD *)&__p[22] = 2112;
        v21 = v19;
        _os_log_impl(&dword_18A900000, v17, OS_LOG_TYPE_DEFAULT, "cdhash mismatch: %@, %@, %@", __p, 0x20u);
      }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA26);
    }
  }
  if (*(_QWORD *)(*((_QWORD *)this + 2) + 16))
  {
    Security::CodeSigning::SecStaticCode::validateRequirements((Security::CodeSigning::SecStaticCode *)v4, 1, v6, 4294900249);
    Security::CodeSigning::SecStaticCode::validateRequirements(v6, 2, (Security::CodeSigning::SecStaticCode *)v4, 0);
  }
  Security::CodeSigning::SecCode::checkValidity::_DTFrameCODESIGN_EVAL_DYNAMIC::~_DTFrameCODESIGN_EVAL_DYNAMIC();
}

void sub_18AA28BB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&a9);
  Security::CodeSigning::SecCode::checkValidity::_DTFrameCODESIGN_EVAL_DYNAMIC::~_DTFrameCODESIGN_EVAL_DYNAMIC();
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SecCode::autoLocateGuest(Security::CodeSigning::SecCode *this, const __CFDictionary *a2)
{
  Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA07);
}

uint64_t Security::CodeSigning::BundleDiskRep::identification(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 32))(*((_QWORD *)this + 13));
}

const void **Security::CodeSigning::BundleDiskRep::resourcesRootPath@<X0>(CFBundleRef *this@<X0>, Security *a2@<X8>)
{
  const __CFURL *v3;

  v3 = CFBundleCopySupportFilesDirectoryURL(this[3]);
  return Security::cfStringRelease(a2, v3);
}

void Security::CodeSigning::BundleDiskRep::adjustResources(Security::CodeSigning::BundleDiskRep *this, Security::CodeSigning::ResourceBuilder *a2)
{
  std::string::size_type size;
  std::string::size_type v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;
  std::string::size_type v9;
  std::string *p_p;
  std::string::size_type v11;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  std::string v16;
  std::string __p;
  std::string v18;
  std::string v19;
  __int128 v20;
  std::string::size_type v21;
  std::string v22;
  std::string __str;
  char v24;

  std::string::basic_string[abi:ne180100]<0>(&__str, "^_CodeSignature$");
  Security::CodeSigning::ResourceBuilder::addExclusion(a2, (__int128 *)&__str, 0);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  std::string::basic_string[abi:ne180100]<0>(&__str, "^CodeResources$");
  Security::CodeSigning::ResourceBuilder::addExclusion(a2, (__int128 *)&__str, 0);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  std::string::basic_string[abi:ne180100]<0>(&__str, "^_MASReceipt$");
  Security::CodeSigning::ResourceBuilder::addExclusion(a2, (__int128 *)&__str, 0);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  memset(&__str, 170, sizeof(__str));
  (*(void (**)(std::string *__return_ptr, Security::CodeSigning::BundleDiskRep *))(*(_QWORD *)this + 56))(&__str, this);
  size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __str.__r_.__value_.__l.__size_;
  if (!std::string::compare(&__str, size - 2, 2uLL, "/."))
  {
    v5 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v5 = __str.__r_.__value_.__l.__size_;
    std::string::basic_string(&v22, &__str, 0, v5 - 2, (std::allocator<char> *)&v20);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__str.__r_.__value_.__l.__data_);
    __str = v22;
  }
  memset(&v22, 170, sizeof(v22));
  (*(void (**)(std::string *__return_ptr, Security::CodeSigning::BundleDiskRep *))(*(_QWORD *)this + 40))(&v22, this);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v6 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  else
    v6 = __str.__r_.__value_.__l.__size_;
  if (!std::string::compare(&v22, 0, v6, &__str, 0, v6))
  {
    v7 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v7 = __str.__r_.__value_.__l.__size_;
    v8 = &v22;
    if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v8 = (std::string *)v22.__r_.__value_.__r.__words[0];
    if (v8->__r_.__value_.__s.__data_[v7] == 47)
    {
      std::string::basic_string[abi:ne180100]<0>(&v18, "^");
      v9 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v9 = __str.__r_.__value_.__l.__size_;
      std::string::basic_string(&v16, &v22, v9 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v24);
      Security::CodeSigning::ResourceBuilder::escapeRE(&__p, (std::string::value_type *)&v16);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v11 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      else
        v11 = __p.__r_.__value_.__l.__size_;
      v12 = std::string::append(&v18, (const std::string::value_type *)p_p, v11);
      v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
      v19.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v13;
      v12->__r_.__value_.__l.__size_ = 0;
      v12->__r_.__value_.__r.__words[2] = 0;
      v12->__r_.__value_.__r.__words[0] = 0;
      v14 = std::string::append(&v19, "$", 1uLL);
      v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v21 = v14->__r_.__value_.__r.__words[2];
      v20 = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      Security::CodeSigning::ResourceBuilder::addExclusion(a2, &v20, 32);
      if (SHIBYTE(v21) < 0)
        operator delete((void *)v20);
      if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v19.__r_.__value_.__l.__data_);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v16.__r_.__value_.__l.__data_);
      if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v18.__r_.__value_.__l.__data_);
    }
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
}

void sub_18AA28FAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  if (*(char *)(v33 - 73) < 0)
    operator delete(*(void **)(v33 - 96));
  if (a33 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a15 < 0)
    operator delete(a10);
  if (a27 < 0)
    operator delete(a22);
  if (*(char *)(v33 - 49) < 0)
    operator delete(*(void **)(v33 - 72));
  if (*(char *)(v33 - 25) < 0)
    operator delete(*(void **)(v33 - 48));
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::BundleDiskRep::prepareForSigning(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 104) + 72))(*(_QWORD *)(a1 + 104));
}

uint64_t Security::CodeSigning::BundleDiskRep::signingLimit(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 96))(*((_QWORD *)this + 13));
}

uint64_t Security::CodeSigning::BundleDiskRep::execSegBase(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 104) + 104))(*(_QWORD *)(a1 + 104));
}

uint64_t Security::CodeSigning::BundleDiskRep::execSegLimit(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 104) + 112))(*(_QWORD *)(a1 + 104));
}

__CFArray *Security::CodeSigning::BundleDiskRep::modifiedFiles(Security::CodeSigning::BundleDiskRep *this)
{
  uint64_t v2;
  __CFArray *v3;
  __CFArray *MutableCopy;
  const __CFArray *v6;

  v6 = (const __CFArray *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 136))(*((_QWORD *)this + 13));
  MutableCopy = CFArrayCreateMutableCopy(0, 0, v6);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, 0);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)0x10000);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)3);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)4);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)5);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)7);
  Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)6);
  v2 = 4096;
  do
  {
    Security::CodeSigning::BundleDiskRep::checkModifiedFile(this, MutableCopy, (Security::CodeSigning::CodeDirectory *)v2);
    v2 = (v2 + 1);
  }
  while ((_DWORD)v2 != 4101);
  v3 = MutableCopy;
  MutableCopy = 0;
  Security::CFRef<__CFArray *>::~CFRef((const void **)&MutableCopy);
  Security::CFRef<__CFArray const*>::~CFRef((const void **)&v6);
  return v3;
}

void sub_18AA291B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFArray const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::BundleDiskRep::fd(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 144))(*((_QWORD *)this + 13));
}

uint64_t Security::CodeSigning::BundleDiskRep::flush(Security::CodeSigning::BundleDiskRep *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 13) + 152))(*((_QWORD *)this + 13));
}

const void **Security::CodeSigning::BundleDiskRep::registerStapledTicket(Security::CodeSigning::BundleDiskRep *this)
{
  const __CFData *v1;
  Security::CodeSigning *v3;

  v3 = (Security::CodeSigning *)(*(uint64_t (**)(Security::CodeSigning::BundleDiskRep *))(*(_QWORD *)this
                                                                                                  + 176))(this);
  Security::CodeSigning::registerStapledTicketWithSystem(v3, v1);
  return Security::CFRef<__CFData const*>::~CFRef((const void **)&v3);
}

CFTypeRef Security::CodeSigning::BundleDiskRep::copyStapledTicket(Security::CodeSigning::BundleDiskRep *this)
{
  const __CFURL *v1;
  timespec v2;
  size_t v3;
  void **v4;
  void **v5;
  NSObject *v6;
  void **v7;
  int v8;
  int v9;
  NSObject *v10;
  int v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  NSObject *v15;
  int v16;
  NSObject *v17;
  CFTypeRef v18;
  off_t st_size;
  UInt8 *v21;
  CFDataRef v22;
  void **v23;
  NSObject *v24;
  void *v25[3];
  void *__p[2];
  int64_t v27;
  CFTypeRef cf;
  stat v29;
  uint8_t buf[4];
  off_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  memset(v25, 170, sizeof(v25));
  v1 = (const __CFURL *)(*(uint64_t (**)(Security::CodeSigning::BundleDiskRep *))(*(_QWORD *)this + 48))(this);
  Security::cfStringRelease((Security *)v25, v1);
  v2.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v29.st_blksize = v2;
  *(timespec *)v29.st_qspare = v2;
  v29.st_birthtimespec = v2;
  *(timespec *)&v29.st_size = v2;
  v29.st_mtimespec = v2;
  v29.st_ctimespec = v2;
  *(timespec *)&v29.st_uid = v2;
  v29.st_atimespec = v2;
  *(timespec *)&v29.st_dev = v2;
  v27 = 0xAAAAAAAAAAAAAAAALL;
  cf = 0;
  if (SHIBYTE(v25[2]) >= 0)
    v3 = HIBYTE(v25[2]);
  else
    v3 = (size_t)v25[1];
  __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  __p[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  v4 = __p;
  std::string::basic_string[abi:ne180100]((uint64_t)__p, v3 + 23);
  if (v27 < 0)
    v4 = (void **)__p[0];
  if (v3)
  {
    if (SHIBYTE(v25[2]) >= 0)
      v5 = v25;
    else
      v5 = (void **)v25[0];
    memmove(v4, v5, v3);
  }
  strcpy((char *)v4 + v3, "/Contents/CodeResources");
  v6 = secLogObjForScope("notarization");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    v23 = v25;
    if (SHIBYTE(v25[2]) < 0)
      v23 = (void **)v25[0];
    *(_DWORD *)buf = 136315138;
    v31 = (off_t)v23;
    _os_log_debug_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEBUG, "Extracting ticket from bundle: %s", buf, 0xCu);
  }
  if (v27 >= 0)
    v7 = __p;
  else
    v7 = (void **)__p[0];
  v8 = open((const char *)v7, 0);
  v9 = v8;
  if (v8 > 0)
  {
    if (fstat(v8, &v29))
    {
      v10 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v11 = *__error();
        *(_DWORD *)buf = 67109120;
        LODWORD(v31) = v11;
        v12 = "unable to stat stapling file: %d";
        v13 = v10;
        v14 = 8;
LABEL_28:
        _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
      }
LABEL_29:
      close(v9);
      goto LABEL_30;
    }
    if ((__int16)v29.st_mode < 0)
    {
      st_size = v29.st_size;
      if (v29.st_size > 0x7FFFFFFF)
      {
        v24 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          goto LABEL_29;
        *(_DWORD *)buf = 134217984;
        v31 = v29.st_size;
        v12 = "ticket size was too large: %lld";
        v13 = v24;
        v14 = 12;
        goto LABEL_28;
      }
      v21 = (UInt8 *)malloc_type_malloc(v29.st_size, 0xA9C3E540uLL);
      if (v21)
      {
        if (read(v9, v21, st_size) == st_size)
        {
          v22 = CFDataCreateWithBytesNoCopy(0, v21, st_size, (CFAllocatorRef)*MEMORY[0x1E0C9AE10]);
          if (cf)
            CFRelease(cf);
          cf = v22;
          if (v22)
            goto LABEL_29;
          v17 = secLogObjForScope("SecError");
          if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            goto LABEL_29;
          *(_WORD *)buf = 0;
          v12 = "unable to create cfdata for notarization";
        }
        else
        {
          v17 = secLogObjForScope("SecError");
          if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            goto LABEL_29;
          *(_WORD *)buf = 0;
          v12 = "unable to read entire ticket from bundle";
        }
      }
      else
      {
        v17 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          goto LABEL_29;
        *(_WORD *)buf = 0;
        v12 = "unable to allocate data for ticket";
      }
    }
    else
    {
      v17 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        goto LABEL_29;
      *(_WORD *)buf = 0;
      v12 = "stapling is not a regular file";
    }
    v13 = v17;
    v14 = 2;
    goto LABEL_28;
  }
  if (*__error() != 2)
  {
    v15 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *__error();
      *(_DWORD *)buf = 67109120;
      LODWORD(v31) = v16;
      _os_log_impl(&dword_18A900000, v15, OS_LOG_TYPE_DEFAULT, "cannot open stapled file for reading: %d", buf, 8u);
    }
  }
  if (v9)
    goto LABEL_29;
LABEL_30:
  v18 = cf;
  cf = 0;
  if (SHIBYTE(v27) < 0)
    operator delete(__p[0]);
  Security::CFRef<__CFData const*>::~CFRef(&cf);
  if (SHIBYTE(v25[2]) < 0)
    operator delete(v25[0]);
  return v18;
}

void sub_18AA29698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,const void *a22)
{
  if (a21 < 0)
    operator delete(__p);
  Security::CFRef<__CFData const*>::~CFRef(&a22);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::BundleDiskRep::recommendedIdentifier(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  void *v4;
  const __CFURL *v5;
  void *__p[2];
  char v7;
  void *v8[3];

  memset(v8, 170, sizeof(v8));
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1 + 192))(v8);
  v4 = (void *)HIBYTE(v8[2]);
  if (SHIBYTE(v8[2]) < 0)
    v4 = v8[1];
  if (v4)
  {
    *(_OWORD *)a2 = *(_OWORD *)v8;
    *(void **)(a2 + 16) = v8[2];
  }
  else
  {
    v5 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
    Security::cfStringRelease((Security *)__p, v5);
    Security::CodeSigning::DiskRep::canonicalIdentifier((std::string *)a2, (uint64_t)__p);
    if (v7 < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v8[2]) < 0)
      operator delete(v8[0]);
  }
}

void sub_18AA2979C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::BundleDiskRep::explicitIdentifier(CFBundleRef *this@<X0>, std::string *a2@<X8>)
{
  const __CFString *Identifier;
  const __CFDictionary *InfoDictionary;

  Identifier = CFBundleGetIdentifier(this[3]);
  if (Identifier
    || (InfoDictionary = CFBundleGetInfoDictionary(this[3])) != 0
    && (Identifier = (const __CFString *)CFDictionaryGetValue(InfoDictionary, (const void *)*MEMORY[0x1E0C9AE88])) != 0)
  {
    Security::cfString(a2, Identifier);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(a2, (char *)&unk_18AA61AAF);
  }
}

CFDataRef Security::CodeSigning::BundleDiskRep::defaultResourceRules(uint64_t a1, uint64_t a2)
{
  std::string *v4;
  const std::string::value_type *v5;
  std::string::size_type v6;
  std::string *v7;
  __int128 v8;
  std::string *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 *v18;
  CFDataRef v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  std::string *v29;
  const std::string::value_type *v30;
  std::string::size_type v31;
  std::string *v32;
  __int128 v33;
  __int128 *v34;
  std::string *v35;
  const std::string::value_type *v36;
  std::string::size_type v37;
  std::string *v38;
  __int128 v39;
  std::string *v40;
  __int128 v41;
  const std::string::value_type *v42;
  std::string::size_type v43;
  std::string *v44;
  __int128 v45;
  std::string *v46;
  __int128 v47;
  const std::string::value_type *v48;
  std::string::size_type v49;
  std::string *v50;
  __int128 v51;
  std::string *v52;
  __int128 v53;
  const std::string::value_type *v54;
  std::string::size_type v55;
  std::string *v56;
  __int128 v57;
  const std::string::value_type *v58;
  std::string::size_type v59;
  std::string *v60;
  __int128 v61;
  std::string *v62;
  __int128 v63;
  const std::string::value_type *v64;
  std::string::size_type v65;
  std::string *v66;
  __int128 v67;
  std::string *v68;
  __int128 v69;
  const std::string::value_type *v70;
  std::string::size_type v71;
  std::string *v72;
  __int128 v73;
  std::string *v74;
  __int128 v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  std::string *v83;
  const std::string::value_type *v84;
  std::string::size_type v85;
  std::string *v86;
  __int128 v87;
  __int128 *v88;
  std::string *v89;
  const std::string::value_type *v90;
  std::string::size_type v91;
  std::string *v92;
  __int128 v93;
  std::string *v94;
  __int128 v95;
  const std::string::value_type *v96;
  std::string::size_type v97;
  std::string *v98;
  __int128 v99;
  std::string *v100;
  __int128 v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  const char *v109;
  uint64_t v111;
  std::string v112;
  std::string v113;
  void *__p[2];
  std::string::size_type v115;
  std::string v116;
  std::string v117;
  __int128 v118;
  std::string::size_type v119;
  std::string v120;
  std::string v121;
  __int128 v122;
  std::string::size_type v123;
  std::string v124;
  __int128 v125;
  std::string::size_type v126;
  std::string v127;
  std::string v128;
  __int128 v129;
  std::string::size_type v130;
  std::string v131;
  std::string v132;
  __int128 v133;
  std::string::size_type v134;
  void *v135[2];
  char v136;
  std::string v137;
  __int128 v138;
  std::string::size_type v139;
  std::string v140;
  __int128 v141;
  int64_t v142;
  void *v143[3];

  memset(v143, 170, sizeof(v143));
  Security::CodeSigning::BundleDiskRep::resourcesRelativePath((Security::CodeSigning::BundleDiskRep *)v143, (CFBundleRef *)a1);
  if (*(_BYTE *)(a1 + 72))
  {
    v4 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v138, "^");
    if (SHIBYTE(v143[2]) >= 0)
      v5 = (const std::string::value_type *)v143;
    else
      v5 = (const std::string::value_type *)v143[0];
    if (SHIBYTE(v143[2]) >= 0)
      v6 = HIBYTE(v143[2]);
    else
      v6 = (std::string::size_type)v143[1];
    v7 = std::string::append(v4, v5, v6);
    v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    v9 = std::string::append(&v140, ".*\\.lproj/", 0xAuLL);
    v17 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v142 = v9->__r_.__value_.__r.__words[2];
    v141 = v17;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    v18 = &v141;
    if (v142 < 0)
      v18 = (__int128 *)v141;
    v19 = Security::cfmake<__CFDictionary const*>((uint64_t)"{rules={'^.*' = #T%s = {optional=#T, weight=1000}'^.*/.*\\.pkg/' = {omit=#T, weight=10000}}}", v10, v11, v12, v13, v14, v15, v16, (uint64_t)v18);
    if (SHIBYTE(v142) < 0)
      operator delete((void *)v141);
    if (SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v140.__r_.__value_.__l.__data_);
    if (SHIBYTE(v139) < 0)
    {
      v20 = (void *)v138;
LABEL_138:
      operator delete(v20);
      goto LABEL_142;
    }
    goto LABEL_142;
  }
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2) & 0x10) != 0)
  {
    v83 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v140, "^");
    if (SHIBYTE(v143[2]) >= 0)
      v84 = (const std::string::value_type *)v143;
    else
      v84 = (const std::string::value_type *)v143[0];
    if (SHIBYTE(v143[2]) >= 0)
      v85 = HIBYTE(v143[2]);
    else
      v85 = (std::string::size_type)v143[1];
    v86 = std::string::append(v83, v84, v85);
    v87 = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
    v142 = v86->__r_.__value_.__r.__words[2];
    v141 = v87;
    v86->__r_.__value_.__l.__size_ = 0;
    v86->__r_.__value_.__r.__words[2] = 0;
    v86->__r_.__value_.__r.__words[0] = 0;
    if (v142 >= 0)
      v88 = &v141;
    else
      v88 = (__int128 *)v141;
    v89 = (std::string *)std::string::basic_string[abi:ne180100]<0>(v135, "^");
    if (SHIBYTE(v143[2]) >= 0)
      v90 = (const std::string::value_type *)v143;
    else
      v90 = (const std::string::value_type *)v143[0];
    if (SHIBYTE(v143[2]) >= 0)
      v91 = HIBYTE(v143[2]);
    else
      v91 = (std::string::size_type)v143[1];
    v92 = std::string::append(v89, v90, v91);
    v93 = *(_OWORD *)&v92->__r_.__value_.__l.__data_;
    v137.__r_.__value_.__r.__words[2] = v92->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v93;
    v92->__r_.__value_.__l.__size_ = 0;
    v92->__r_.__value_.__r.__words[2] = 0;
    v92->__r_.__value_.__r.__words[0] = 0;
    v94 = std::string::append(&v137, ".*\\.lproj/", 0xAuLL);
    v95 = *(_OWORD *)&v94->__r_.__value_.__l.__data_;
    v139 = v94->__r_.__value_.__r.__words[2];
    v138 = v95;
    v94->__r_.__value_.__l.__size_ = 0;
    v94->__r_.__value_.__r.__words[2] = 0;
    v94->__r_.__value_.__r.__words[0] = 0;
    std::string::basic_string[abi:ne180100]<0>(&v131, "^");
    if (SHIBYTE(v143[2]) >= 0)
      v96 = (const std::string::value_type *)v143;
    else
      v96 = (const std::string::value_type *)v143[0];
    if (SHIBYTE(v143[2]) >= 0)
      v97 = HIBYTE(v143[2]);
    else
      v97 = (std::string::size_type)v143[1];
    v98 = std::string::append(&v131, v96, v97);
    v99 = *(_OWORD *)&v98->__r_.__value_.__l.__data_;
    v132.__r_.__value_.__r.__words[2] = v98->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v132.__r_.__value_.__l.__data_ = v99;
    v98->__r_.__value_.__l.__size_ = 0;
    v98->__r_.__value_.__r.__words[2] = 0;
    v98->__r_.__value_.__r.__words[0] = 0;
    v100 = std::string::append(&v132, ".*\\.lproj/locversion.plist$", 0x1BuLL);
    v101 = *(_OWORD *)&v100->__r_.__value_.__l.__data_;
    v134 = v100->__r_.__value_.__r.__words[2];
    v133 = v101;
    v100->__r_.__value_.__l.__size_ = 0;
    v100->__r_.__value_.__r.__words[2] = 0;
    v100->__r_.__value_.__r.__words[0] = 0;
    v19 = Security::cfmake<__CFDictionary const*>((uint64_t)"{rules={'^version.plist$' = #T%s = #T%s = {optional=#T, weight=1000}%s = {omit=#T, weight=1100}}}", v102, v103, v104, v105, v106, v107, v108, (uint64_t)v88);
    goto LABEL_122;
  }
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2) & 8) != 0)
  {
    v109 = "{rules={'^.*' = #T'^Info\\.plist$' = {omit=#T,weight=10}}}";
LABEL_141:
    v19 = Security::cfmake<__CFDictionary const*>((uint64_t)v109, v21, v22, v23, v24, v25, v26, v27, v111);
    goto LABEL_142;
  }
  v28 = (void *)HIBYTE(v143[2]);
  if (SHIBYTE(v143[2]) < 0)
    v28 = v143[1];
  if (!v28)
  {
    v109 = "{rules={'^version.plist$' = #T'^.*' = #T'^.*\\.lproj/' = {optional=#T, weight=1000}'^Base\\.lproj/' = {weight"
           "=1010}'^.*\\.lproj/locversion.plist$' = {omit=#T, weight=1100}},rules2={'^.*' = #T'.*\\.dSYM($|/)' = {weight="
           "11}'^(.*/)?\\.DS_Store$' = {omit=#T,weight=2000}'^Info\\.plist$' = {omit=#T, weight=20}'^version\\.plist$' = "
           "{weight=20}'^embedded\\.provisionprofile$' = {weight=20}'^PkgInfo$' = {omit=#T, weight=20}'^.*\\.lproj/' = {o"
           "ptional=#T, weight=1000}'^Base\\.lproj/' = {weight=1010}'^.*\\.lproj/locversion.plist$' = {omit=#T, weight=1100}}}";
    goto LABEL_141;
  }
  v29 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v140, "^");
  if (SHIBYTE(v143[2]) >= 0)
    v30 = (const std::string::value_type *)v143;
  else
    v30 = (const std::string::value_type *)v143[0];
  if (SHIBYTE(v143[2]) >= 0)
    v31 = HIBYTE(v143[2]);
  else
    v31 = (std::string::size_type)v143[1];
  v32 = std::string::append(v29, v30, v31);
  v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  v142 = v32->__r_.__value_.__r.__words[2];
  v141 = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  if (v142 >= 0)
    v34 = &v141;
  else
    v34 = (__int128 *)v141;
  v35 = (std::string *)std::string::basic_string[abi:ne180100]<0>(v135, "^");
  if (SHIBYTE(v143[2]) >= 0)
    v36 = (const std::string::value_type *)v143;
  else
    v36 = (const std::string::value_type *)v143[0];
  if (SHIBYTE(v143[2]) >= 0)
    v37 = HIBYTE(v143[2]);
  else
    v37 = (std::string::size_type)v143[1];
  v38 = std::string::append(v35, v36, v37);
  v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  v137.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v39;
  v38->__r_.__value_.__l.__size_ = 0;
  v38->__r_.__value_.__r.__words[2] = 0;
  v38->__r_.__value_.__r.__words[0] = 0;
  v40 = std::string::append(&v137, ".*\\.lproj/", 0xAuLL);
  v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  v139 = v40->__r_.__value_.__r.__words[2];
  v138 = v41;
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v131, "^");
  if (SHIBYTE(v143[2]) >= 0)
    v42 = (const std::string::value_type *)v143;
  else
    v42 = (const std::string::value_type *)v143[0];
  if (SHIBYTE(v143[2]) >= 0)
    v43 = HIBYTE(v143[2]);
  else
    v43 = (std::string::size_type)v143[1];
  v44 = std::string::append(&v131, v42, v43);
  v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
  v132.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v132.__r_.__value_.__l.__data_ = v45;
  v44->__r_.__value_.__l.__size_ = 0;
  v44->__r_.__value_.__r.__words[2] = 0;
  v44->__r_.__value_.__r.__words[0] = 0;
  v46 = std::string::append(&v132, "Base\\.lproj/", 0xCuLL);
  v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
  v134 = v46->__r_.__value_.__r.__words[2];
  v133 = v47;
  v46->__r_.__value_.__l.__size_ = 0;
  v46->__r_.__value_.__r.__words[2] = 0;
  v46->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v127, "^");
  if (SHIBYTE(v143[2]) >= 0)
    v48 = (const std::string::value_type *)v143;
  else
    v48 = (const std::string::value_type *)v143[0];
  if (SHIBYTE(v143[2]) >= 0)
    v49 = HIBYTE(v143[2]);
  else
    v49 = (std::string::size_type)v143[1];
  v50 = std::string::append(&v127, v48, v49);
  v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
  v128.__r_.__value_.__r.__words[2] = v50->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v128.__r_.__value_.__l.__data_ = v51;
  v50->__r_.__value_.__l.__size_ = 0;
  v50->__r_.__value_.__r.__words[2] = 0;
  v50->__r_.__value_.__r.__words[0] = 0;
  v52 = std::string::append(&v128, ".*\\.lproj/locversion.plist$", 0x1BuLL);
  v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
  v130 = v52->__r_.__value_.__r.__words[2];
  v129 = v53;
  v52->__r_.__value_.__l.__size_ = 0;
  v52->__r_.__value_.__r.__words[2] = 0;
  v52->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v124, "^");
  if (SHIBYTE(v143[2]) >= 0)
    v54 = (const std::string::value_type *)v143;
  else
    v54 = (const std::string::value_type *)v143[0];
  if (SHIBYTE(v143[2]) >= 0)
    v55 = HIBYTE(v143[2]);
  else
    v55 = (std::string::size_type)v143[1];
  v56 = std::string::append(&v124, v54, v55);
  v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
  v126 = v56->__r_.__value_.__r.__words[2];
  v125 = v57;
  v56->__r_.__value_.__l.__size_ = 0;
  v56->__r_.__value_.__r.__words[2] = 0;
  v56->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v120, "^");
  if (SHIBYTE(v143[2]) >= 0)
    v58 = (const std::string::value_type *)v143;
  else
    v58 = (const std::string::value_type *)v143[0];
  if (SHIBYTE(v143[2]) >= 0)
    v59 = HIBYTE(v143[2]);
  else
    v59 = (std::string::size_type)v143[1];
  v60 = std::string::append(&v120, v58, v59);
  v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
  v121.__r_.__value_.__r.__words[2] = v60->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v121.__r_.__value_.__l.__data_ = v61;
  v60->__r_.__value_.__l.__size_ = 0;
  v60->__r_.__value_.__r.__words[2] = 0;
  v60->__r_.__value_.__r.__words[0] = 0;
  v62 = std::string::append(&v121, ".*\\.lproj/", 0xAuLL);
  v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
  v123 = v62->__r_.__value_.__r.__words[2];
  v122 = v63;
  v62->__r_.__value_.__l.__size_ = 0;
  v62->__r_.__value_.__r.__words[2] = 0;
  v62->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v116, "^");
  if (SHIBYTE(v143[2]) >= 0)
    v64 = (const std::string::value_type *)v143;
  else
    v64 = (const std::string::value_type *)v143[0];
  if (SHIBYTE(v143[2]) >= 0)
    v65 = HIBYTE(v143[2]);
  else
    v65 = (std::string::size_type)v143[1];
  v66 = std::string::append(&v116, v64, v65);
  v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
  v117.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v117.__r_.__value_.__l.__data_ = v67;
  v66->__r_.__value_.__l.__size_ = 0;
  v66->__r_.__value_.__r.__words[2] = 0;
  v66->__r_.__value_.__r.__words[0] = 0;
  v68 = std::string::append(&v117, "Base\\.lproj/", 0xCuLL);
  v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
  v119 = v68->__r_.__value_.__r.__words[2];
  v118 = v69;
  v68->__r_.__value_.__l.__size_ = 0;
  v68->__r_.__value_.__r.__words[2] = 0;
  v68->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string[abi:ne180100]<0>(&v112, "^");
  if (SHIBYTE(v143[2]) >= 0)
    v70 = (const std::string::value_type *)v143;
  else
    v70 = (const std::string::value_type *)v143[0];
  if (SHIBYTE(v143[2]) >= 0)
    v71 = HIBYTE(v143[2]);
  else
    v71 = (std::string::size_type)v143[1];
  v72 = std::string::append(&v112, v70, v71);
  v73 = *(_OWORD *)&v72->__r_.__value_.__l.__data_;
  v113.__r_.__value_.__r.__words[2] = v72->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v113.__r_.__value_.__l.__data_ = v73;
  v72->__r_.__value_.__l.__size_ = 0;
  v72->__r_.__value_.__r.__words[2] = 0;
  v72->__r_.__value_.__r.__words[0] = 0;
  v74 = std::string::append(&v113, ".*\\.lproj/locversion.plist$", 0x1BuLL);
  v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
  v115 = v74->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v75;
  v74->__r_.__value_.__l.__size_ = 0;
  v74->__r_.__value_.__r.__words[2] = 0;
  v74->__r_.__value_.__r.__words[0] = 0;
  v19 = Security::cfmake<__CFDictionary const*>((uint64_t)"{rules={'^version.plist$' = #T%s = #T%s = {optional=#T, weight=1000}%s = {weight=1010}%s = {omit=#T, weight=1100}},rules2={'^.*' = #T'^[^/]+$' = {nested=#T, weight=10}'^(Frameworks|SharedFrameworks|PlugIns|Plug-ins|XPCServices|Helpers|MacOS|Library/(Automator|Spotlight|LoginItems))/' = {nested=#T, weight=10}'.*\\.dSYM($|/)' = {weight=11}'^(.*/)?\\.DS_Store$' = {omit=#T,weight=2000}'^Info\\.plist$' = {omit=#T, weight=20}'^version\\.plist$' = {weight=20}'^embedded\\.provisionprofile$' = {weight=20}'^PkgInfo$' = {omit=#T, weight=20}%s = {weight=20}%s = {optional=#T, weight=1000}%s = {weight=1010}%s = {omit=#T, weight=1100}}}", v76, v77, v78, v79, v80, v81, v82, (uint64_t)v34);
  if (SHIBYTE(v115) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v113.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v113.__r_.__value_.__l.__data_);
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v112.__r_.__value_.__l.__data_);
  if (SHIBYTE(v119) < 0)
    operator delete((void *)v118);
  if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v117.__r_.__value_.__l.__data_);
  if (SHIBYTE(v116.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v116.__r_.__value_.__l.__data_);
  if (SHIBYTE(v123) < 0)
    operator delete((void *)v122);
  if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v121.__r_.__value_.__l.__data_);
  if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v120.__r_.__value_.__l.__data_);
  if (SHIBYTE(v126) < 0)
    operator delete((void *)v125);
  if (SHIBYTE(v124.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v124.__r_.__value_.__l.__data_);
  if (SHIBYTE(v130) < 0)
    operator delete((void *)v129);
  if (SHIBYTE(v128.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v128.__r_.__value_.__l.__data_);
  if (SHIBYTE(v127.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v127.__r_.__value_.__l.__data_);
LABEL_122:
  if (SHIBYTE(v134) < 0)
    operator delete((void *)v133);
  if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v132.__r_.__value_.__l.__data_);
  if (SHIBYTE(v131.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v131.__r_.__value_.__l.__data_);
  if (SHIBYTE(v139) < 0)
    operator delete((void *)v138);
  if (SHIBYTE(v137.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v137.__r_.__value_.__l.__data_);
  if (v136 < 0)
    operator delete(v135[0]);
  if (SHIBYTE(v142) < 0)
    operator delete((void *)v141);
  if (SHIBYTE(v140.__r_.__value_.__r.__words[2]) < 0)
  {
    v20 = (void *)v140.__r_.__value_.__r.__words[0];
    goto LABEL_138;
  }
LABEL_142:
  if (SHIBYTE(v143[2]) < 0)
    operator delete(v143[0]);
  return v19;
}

void sub_18AA2A0EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,void *a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,void *a62,uint64_t a63)
{
  char a67;
  void *a69;
  char a72;
  void *a73;
  char a74;
  void *a75;
  char a76;
  void *a77;
  char a78;
  void *a79;
  char a80;
  void *a81;
  char a82;
  void *a83;
  char a84;
  void *a85;
  char a86;
  uint64_t v86;

  if (a36 < 0)
    operator delete(__p);
  if (a29 < 0)
    operator delete(a24);
  if (a23 < 0)
    operator delete(a18);
  if (a55 < 0)
    operator delete(a50);
  if (a48 < 0)
    operator delete(a43);
  if (a42 < 0)
    operator delete(a37);
  if (a72 < 0)
    operator delete(a69);
  if (a67 < 0)
    operator delete(a62);
  if (a61 < 0)
    operator delete(a56);
  if (a76 < 0)
    operator delete(a75);
  if (a74 < 0)
    operator delete(a73);
  if (a82 < 0)
    operator delete(a81);
  if (a80 < 0)
    operator delete(a79);
  if (a78 < 0)
    operator delete(a77);
  if (*(char *)(v86 - 233) < 0)
    operator delete(*(void **)(v86 - 256));
  if (a86 < 0)
    operator delete(a85);
  if (a84 < 0)
    operator delete(a83);
  if (*(char *)(v86 - 153) < 0)
    operator delete(*(void **)(v86 - 176));
  if (*(char *)(v86 - 185) < 0)
    operator delete(*(void **)(v86 - 208));
  if (*(char *)(v86 - 209) < 0)
    operator delete(*(void **)(v86 - 232));
  if (*(char *)(v86 - 89) < 0)
    operator delete(*(void **)(v86 - 112));
  if (*(char *)(v86 - 121) < 0)
    operator delete(*(void **)(v86 - 144));
  if (*(char *)(v86 - 65) < 0)
    operator delete(*(void **)(v86 - 88));
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::BundleDiskRep::defaultRequirements(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 104) + 208))(*(_QWORD *)(a1 + 104));
}

uint64_t Security::CodeSigning::BundleDiskRep::pageSize(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 104) + 216))(*(_QWORD *)(a1 + 104));
}

uint64_t Security::CodeSigning::BundleDiskRep::strictValidate(_QWORD **a1, uint64_t a2, uint64_t a3, int a4)
{
  ((void (*)(_QWORD **))(*a1)[29])(a1);
  return (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, _QWORD))(*a1[13] + 224))(a1[13], a2, a3, a4 & 0xFFFFFEFF);
}

void Security::CodeSigning::BundleDiskRep::strictValidateStructure(uint64_t a1, Security::CodeSigning::CodeDirectory *this, _QWORD *a3, int a4)
{
  const char *v7;
  _QWORD *v8;
  Security::CodeSigning::CodeDirectory *v9;
  char *v10;
  _QWORD *v11;
  _QWORD *v12;
  BOOL v13;
  Security::CodeSigning **v14;
  Security::CodeSigning *v15;
  _BOOL4 v16;
  dirent *Next;
  const char *d_name;
  char **v19;
  size_t v20;
  stat *v21;
  const void *v22;
  std::string::size_type v23;
  std::string *v24;
  __int128 v25;
  int IsValidXattrFile;
  stat *v27;
  timespec v28;
  off_t st_size;
  NSObject *v30;
  const __CFURL *v31;
  void **v32;
  Security::UnixPlusPlus::FileDesc *v33;
  Security::UnixPlusPlus::FileDesc *v34;
  _QWORD *v35;
  _QWORD *v36;
  int *v37;
  int *v38;
  int *v39;
  uint64_t *v40;
  int v41;
  int v42;
  _QWORD *v43;
  _QWORD *v44;
  int *v45;
  int *v46;
  _QWORD *v47;
  _QWORD *v48;
  int *v49;
  int *v50;
  _QWORD *v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  int *v55;
  int v56;
  BOOL v57;
  uint64_t *v58;
  void **v59;
  const __CFString *v60;
  const void *v61;
  void **v62;
  const __CFString *v63;
  const void *v64;
  Security::UnixPlusPlus::FileDesc *v65[2];
  std::string::size_type v66;
  Security::UnixPlusPlus::FileDesc *v67;
  std::string v68;
  char **v69;
  char *v70[2];
  void *__p[136];
  stat v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  if ((a4 & 0x4000000) == 0)
  {
    if (Security::CodeSigning::CodeDirectory::slotIsPresent(this, -3))
      std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)(a1 + 184), 3u, 3);
    v70[0] = 0;
    v70[1] = 0;
    v69 = v70;
    v8 = *(_QWORD **)(a1 + 184);
    if (v8 != (_QWORD *)(a1 + 192))
    {
      do
      {
        v9 = (Security::CodeSigning::CodeDirectory *)*((unsigned int *)v8 + 7);
        if ((_DWORD)v9 != 1)
        {
          v10 = (char *)Security::CodeSigning::CodeDirectory::canonicalSlotName(v9);
          if (v10)
          {
            std::string::basic_string[abi:ne180100]<0>(__p, v10);
            std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>((uint64_t **)&v69, __p, (uint64_t)__p);
            if (SHIBYTE(__p[2]) < 0)
              operator delete(__p[0]);
          }
        }
        v11 = (_QWORD *)v8[1];
        if (v11)
        {
          do
          {
            v12 = v11;
            v11 = (_QWORD *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            v12 = (_QWORD *)v8[2];
            v13 = *v12 == (_QWORD)v8;
            v8 = v12;
          }
          while (!v13);
        }
        v8 = v12;
      }
      while (v12 != (_QWORD *)(a1 + 192));
    }
    v14 = (Security::CodeSigning **)(a1 + 32);
    v15 = (Security::CodeSigning *)(a1 + 32);
    if (*(char *)(a1 + 55) < 0)
      v15 = *v14;
    v16 = Security::CodeSigning::pathFileSystemUsesXattrFiles(v15, v7);
    memset(__p, 170, sizeof(__p));
    if (*(char *)(a1 + 55) < 0)
    {
      std::string::__init_copy_ctor_external(&v68, *(const std::string::value_type **)(a1 + 32), *(_QWORD *)(a1 + 40));
    }
    else
    {
      *(_OWORD *)&v68.__r_.__value_.__l.__data_ = *(_OWORD *)v14;
      v68.__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 48);
    }
    Security::CodeSigning::DirScanner::DirScanner((uint64_t)__p, &v68);
    if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v68.__r_.__value_.__l.__data_);
    if (LOBYTE(__p[135]))
    {
      while (1)
      {
        while (1)
        {
          do
          {
            Next = Security::CodeSigning::DirScanner::getNext((DIR **)__p);
            if (!Next)
              goto LABEL_57;
            if (!Security::CodeSigning::DirScanner::isRegularFile((Security::CodeSigning::DirScanner *)__p, Next))
              Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA3ALL);
            d_name = Next->d_name;
            std::string::basic_string[abi:ne180100]<0>(&v72, Next->d_name);
            v19 = (char **)std::__tree<std::string>::find<std::string>((uint64_t)&v69, &v72);
            if (SHIBYTE(v72.st_gid) < 0)
              operator delete(*(void **)&v72.st_dev);
          }
          while (v70 != v19);
          if (!strcmp(d_name, "CodeSignature"))
            break;
          if (!v16)
            goto LABEL_56;
          if (*(char *)(a1 + 55) >= 0)
            v20 = *(unsigned __int8 *)(a1 + 55);
          else
            v20 = *(_QWORD *)(a1 + 40);
          memset(&v72, 170, 24);
          std::string::basic_string[abi:ne180100]((uint64_t)&v72, v20 + 1);
          if ((v72.st_gid & 0x80000000) == 0)
            v21 = &v72;
          else
            v21 = *(stat **)&v72.st_dev;
          if (v20)
          {
            if (*(char *)(a1 + 55) >= 0)
              v22 = (const void *)(a1 + 32);
            else
              v22 = *(const void **)(a1 + 32);
            memmove(v21, v22, v20);
          }
          *(_WORD *)((char *)&v21->st_dev + v20) = 47;
          v23 = strlen(d_name);
          v24 = std::string::append((std::string *)&v72, d_name, v23);
          v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
          v66 = v24->__r_.__value_.__r.__words[2];
          *(_OWORD *)v65 = v25;
          v24->__r_.__value_.__l.__size_ = 0;
          v24->__r_.__value_.__r.__words[2] = 0;
          v24->__r_.__value_.__r.__words[0] = 0;
          IsValidXattrFile = Security::CodeSigning::pathIsValidXattrFile((char *)v65, "bundlediskrep");
          if (SHIBYTE(v66) < 0)
            operator delete(v65[0]);
          if (SHIBYTE(v72.st_gid) < 0)
          {
            operator delete(*(void **)&v72.st_dev);
            if (!IsValidXattrFile)
              goto LABEL_56;
          }
          else if (!IsValidXattrFile)
          {
            goto LABEL_56;
          }
          v30 = secLogObjForScope("bundlediskrep");
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
          {
            v72.st_dev = 136315138;
            *(_QWORD *)&v72.st_mode = d_name;
            _os_log_debug_impl(&dword_18A900000, v30, OS_LOG_TYPE_DEBUG, "meta directory validation on xattr file skipped: %s", (uint8_t *)&v72, 0xCu);
          }
        }
        v67 = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAFFFFFFFFLL;
        Security::CodeSigning::BundleDiskRep::metaPath((std::string *)&v72, (const char *)a1, "CodeSignature");
        if ((v72.st_gid & 0x80000000) == 0)
          v27 = &v72;
        else
          v27 = *(stat **)&v72.st_dev;
        Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v67, (const char *)v27, 0, 438);
        if (SHIBYTE(v72.st_gid) < 0)
          operator delete(*(void **)&v72.st_dev);
        v28.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v28.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        *(timespec *)&v72.st_blksize = v28;
        *(timespec *)v72.st_qspare = v28;
        v72.st_birthtimespec = v28;
        *(timespec *)&v72.st_size = v28;
        v72.st_mtimespec = v28;
        v72.st_ctimespec = v28;
        *(timespec *)&v72.st_uid = v28;
        v72.st_atimespec = v28;
        *(timespec *)&v72.st_dev = v28;
        Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)v67, &v72);
        st_size = v72.st_size;
        Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v67);
        if (st_size)
LABEL_56:
          std::__tree<int>::__emplace_unique_key_args<int,int const&>((uint64_t *)(a1 + 208), -67014, -67014);
      }
    }
LABEL_57:
    Security::CodeSigning::DirScanner::~DirScanner((Security::CodeSigning::DirScanner *)__p);
    std::__tree<std::string>::destroy(v70[0]);
  }
  memset(__p, 170, 24);
  v31 = (const __CFURL *)(*(uint64_t (**)(uint64_t, Security::CodeSigning::CodeDirectory *))(*(_QWORD *)a1 + 48))(a1, this);
  Security::cfStringRelease((Security *)__p, v31);
  v65[0] = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAFFFFFFFFLL;
  if (SHIBYTE(__p[2]) >= 0)
    v32 = __p;
  else
    v32 = (void **)__p[0];
  Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)v65, (const char *)v32, 0, 438);
  if ((a4 & 0x1000000) != 0)
  {
    v33 = (Security::UnixPlusPlus::FileDesc *)LODWORD(v65[0]);
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute((Security::UnixPlusPlus::FileDesc *)LODWORD(v65[0]), "com.apple.ResourceFork"))
    {
      Security::UnixPlusPlus::FileDesc::removeAttr(v33, "com.apple.ResourceFork");
    }
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute(v33, "com.apple.FinderInfo"))
      Security::UnixPlusPlus::FileDesc::removeAttr(v33, "com.apple.FinderInfo");
  }
  if ((a4 & 0x200) != 0)
  {
    v34 = (Security::UnixPlusPlus::FileDesc *)LODWORD(v65[0]);
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute((Security::UnixPlusPlus::FileDesc *)LODWORD(v65[0]), "com.apple.ResourceFork"))
    {
      v59 = __p;
      if (SHIBYTE(__p[2]) < 0)
        v59 = (void **)__p[0];
      v60 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Disallowed xattr %s found on %s"), "com.apple.ResourceFork", v59);
      Security::CodeSigning::CSError::throwMe((Security::CodeSigning::CSError *)0xFFFEFA49, (uint64_t)CFSTR("SecCSResourceHasSidebandData"), v60, v61);
    }
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute(v34, "com.apple.FinderInfo"))
    {
      v62 = __p;
      if (SHIBYTE(__p[2]) < 0)
        v62 = (void **)__p[0];
      v63 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Disallowed xattr %s found on %s"), "com.apple.FinderInfo", v62);
      Security::CodeSigning::CSError::throwMe((Security::CodeSigning::CSError *)0xFFFEFA49, (uint64_t)CFSTR("SecCSResourceHasSidebandData"), v63, v64);
    }
  }
  memset(&v72, 0, 24);
  v35 = *(_QWORD **)(a1 + 208);
  v36 = (_QWORD *)(a1 + 216);
  v39 = (int *)*a3;
  v37 = (int *)(a3 + 1);
  v38 = v39;
  v40 = (uint64_t *)&v72;
  v68.__r_.__value_.__r.__words[0] = (std::string::size_type)&v72;
  if (v35 != (_QWORD *)(a1 + 216))
  {
    if (v38 == v37)
    {
LABEL_96:
      v69 = (char **)v40;
      if (v35 != v36)
      {
        do
        {
          std::back_insert_iterator<std::vector<int>>::operator=[abi:ne180100]((uint64_t *)&v69, *((_DWORD *)v35 + 7));
          v51 = (_QWORD *)v35[1];
          if (v51)
          {
            do
            {
              v52 = v51;
              v51 = (_QWORD *)*v51;
            }
            while (v51);
          }
          else
          {
            do
            {
              v52 = (_QWORD *)v35[2];
              v13 = *v52 == (_QWORD)v35;
              v35 = v52;
            }
            while (!v13);
          }
          v35 = v52;
        }
        while (v52 != v36);
      }
    }
    else
    {
      while (1)
      {
        v41 = *((_DWORD *)v35 + 7);
        v42 = v38[7];
        if (v41 >= v42)
        {
          if (v42 >= v41)
          {
            v47 = (_QWORD *)v35[1];
            if (v47)
            {
              do
              {
                v48 = v47;
                v47 = (_QWORD *)*v47;
              }
              while (v47);
            }
            else
            {
              do
              {
                v48 = (_QWORD *)v35[2];
                v13 = *v48 == (_QWORD)v35;
                v35 = v48;
              }
              while (!v13);
            }
            v49 = (int *)*((_QWORD *)v38 + 1);
            if (v49)
            {
              do
              {
                v38 = v49;
                v49 = *(int **)v49;
              }
              while (v49);
            }
            else
            {
              do
              {
                v50 = v38;
                v38 = (int *)*((_QWORD *)v38 + 2);
              }
              while (*(int **)v38 != v50);
            }
            v35 = v48;
          }
          else
          {
            v45 = (int *)*((_QWORD *)v38 + 1);
            if (v45)
            {
              do
              {
                v38 = v45;
                v45 = *(int **)v45;
              }
              while (v45);
            }
            else
            {
              do
              {
                v46 = v38;
                v38 = (int *)*((_QWORD *)v38 + 2);
              }
              while (*(int **)v38 != v46);
            }
          }
        }
        else
        {
          std::back_insert_iterator<std::vector<int>>::operator=[abi:ne180100]((uint64_t *)&v68, v41);
          v43 = (_QWORD *)v35[1];
          if (v43)
          {
            do
            {
              v35 = v43;
              v43 = (_QWORD *)*v43;
            }
            while (v43);
          }
          else
          {
            do
            {
              v44 = v35;
              v35 = (_QWORD *)v35[2];
            }
            while ((_QWORD *)*v35 != v44);
          }
        }
        if (v35 == v36)
          break;
        if (v38 == v37)
        {
          v40 = (uint64_t *)v68.__r_.__value_.__r.__words[0];
          goto LABEL_96;
        }
      }
    }
  }
  if (*(_QWORD *)&v72.st_dev != v72.st_ino)
  {
    v53 = **(unsigned int **)&v72.st_dev;
    goto LABEL_123;
  }
  if ((a4 & 0x100) != 0 && !*(_BYTE *)(a1 + 73))
  {
    v53 = 4294900294;
    v54 = *(_QWORD *)v37;
    if (!*(_QWORD *)v37)
      goto LABEL_123;
    v55 = v37;
    do
    {
      v56 = *(_DWORD *)(v54 + 28);
      v57 = v56 < 256;
      if (v56 >= 256)
        v58 = (uint64_t *)v54;
      else
        v58 = (uint64_t *)(v54 + 8);
      if (!v57)
        v55 = (int *)v54;
      v54 = *v58;
    }
    while (*v58);
    if (v55 == v37 || v55[7] >= 257)
LABEL_123:
      Security::MacOSError::throwMe((Security::MacOSError *)v53);
  }
  if (*(_QWORD *)&v72.st_dev)
  {
    v72.st_ino = *(_QWORD *)&v72.st_dev;
    operator delete(*(void **)&v72.st_dev);
  }
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)v65);
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
}

void sub_18AA2ABA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,char *a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  std::__tree<std::string>::destroy(a29);
  _Unwind_Resume(a1);
}

CFDataRef Security::CodeSigning::BundleDiskRep::allowedResourceOmissions(CFBundleRef *this)
{
  void **v2;
  std::string::size_type v3;
  std::string *v4;
  __int128 v5;
  std::string *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 *v15;
  CFDataRef v16;
  void *__p[2];
  unsigned __int8 v19;
  std::string v20;
  std::string v21;
  __int128 v22;
  int64_t v23;

  std::string::basic_string[abi:ne180100]<0>(&v20, "^");
  Security::CodeSigning::BundleDiskRep::resourcesRelativePath((Security::CodeSigning::BundleDiskRep *)__p, this);
  if ((v19 & 0x80u) == 0)
    v2 = __p;
  else
    v2 = (void **)__p[0];
  if ((v19 & 0x80u) == 0)
    v3 = v19;
  else
    v3 = (std::string::size_type)__p[1];
  v4 = std::string::append(&v20, (const std::string::value_type *)v2, v3);
  v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  v6 = std::string::append(&v21, ".*\\.lproj/locversion.plist$", 0x1BuLL);
  v14 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v23 = v6->__r_.__value_.__r.__words[2];
  v22 = v14;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  v15 = &v22;
  if (v23 < 0)
    v15 = (__int128 *)v22;
  v16 = Security::cfmake<__CFArray const*>((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13, (uint64_t)v15);
  if (SHIBYTE(v23) < 0)
    operator delete((void *)v22);
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
  if ((char)v19 < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v20.__r_.__value_.__l.__data_);
  return v16;
}

void sub_18AA2ADCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  uint64_t v28;

  if (*(char *)(v28 - 25) < 0)
    operator delete(*(void **)(v28 - 48));
  if (a28 < 0)
    operator delete(__p);
  if (a16 < 0)
    operator delete(a11);
  if (a22 < 0)
    operator delete(a17);
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::BundleDiskRep::appleInternalForcePlatform(Security::CodeSigning::BundleDiskRep *this)
{
  return *((unsigned __int8 *)this + 232);
}

uint64_t Security::CodeSigning::BundleDiskRep::writer(Security::CodeSigning::BundleDiskRep *this)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  _QWORD *v5;
  uint64_t v6;
  Security::UnixError *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  _QWORD v14[2];

  v2 = operator new();
  *(_DWORD *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 12) = -1;
  *(_DWORD *)(v2 + 20) = 0;
  *(_QWORD *)v2 = &off_1E1FC88C0;
  Security::Mutex::Mutex((pthread_mutex_t *)(v2 + 32));
  if (this)
  {
    v3 = (unsigned int *)((char *)this + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  *(_QWORD *)(v2 + 96) = 0;
  v5 = (_QWORD *)(v2 + 96);
  *(_QWORD *)(v2 + 24) = this;
  Security::Mutex::Mutex((pthread_mutex_t *)(v2 + 104));
  *(_QWORD *)(v2 + 184) = 0;
  *(_BYTE *)(v2 + 168) = 0;
  *(_QWORD *)(v2 + 192) = 0;
  *(_QWORD *)(v2 + 176) = v2 + 184;
  v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*(_QWORD *)(v2 + 24) + 104) + 256))(*(_QWORD *)(*(_QWORD *)(v2 + 24) + 104));
  v14[0] = v2 + 104;
  v14[1] = 0xAAAAAAAAAAAAAA01;
  v7 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(v2 + 104));
  if ((_DWORD)v7)
    Security::UnixError::throwMe(v7);
  if (v6)
  {
    v8 = (unsigned int *)(v6 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  if (*v5)
  {
    v10 = (unsigned int *)(*v5 + 8);
    do
    {
      v11 = __ldxr(v10);
      v12 = v11 - 1;
    }
    while (__stxr(v12, v10));
    if (!v12 && *v5)
      (*(void (**)(_QWORD))(*(_QWORD *)*v5 + 8))(*v5);
  }
  *(_QWORD *)(v2 + 96) = v6;
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v14);
  return v2;
}

void sub_18AA2AF80(_Unwind_Exception *a1)
{
  uint64_t v1;

  Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer((_QWORD *)(v1 + 24));
  MEMORY[0x18D76FAA0](v1, 0x10A1C4026A71BB4);
  _Unwind_Resume(a1);
}

const void **Security::CodeSigning::BundleDiskRep::createRawComponents@<X0>(Security::CodeSigning::BundleDiskRep *this@<X0>, uint64_t a2@<X8>)
{
  Security::CodeSigning::CodeDirectory *v4;
  const char *v5;
  uint64_t **v6;
  uint64_t v7;
  const char *v8;
  uint64_t **v9;
  const void **result;
  CFDataRef v11;
  int v12;

  v4 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = a2 + 8;
  v12 = 0;
  do
  {
    v11 = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
    v5 = Security::CodeSigning::CodeDirectory::canonicalSlotName(v4);
    if (v5)
    {
      v11 = Security::CodeSigning::BundleDiskRep::metaData(this, v5);
      if (v11)
      {
        v6 = std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t **)a2, (int)v4, &v12);
        Security::CFRef<__CFData const*>::operator=((CFTypeRef *)v6 + 5, (CFTypeRef *)&v11);
      }
    }
    else
    {
      v11 = 0;
    }
    Security::CFRef<__CFData const*>::~CFRef((const void **)&v11);
    v4 = (Security::CodeSigning::CodeDirectory *)((_DWORD)v4 + 1);
    v12 = (int)v4;
  }
  while ((_DWORD)v4 != 11);
  v7 = 4096;
  v12 = 4096;
  do
  {
    v11 = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
    v8 = Security::CodeSigning::CodeDirectory::canonicalSlotName((Security::CodeSigning::CodeDirectory *)v7);
    if (v8)
    {
      v11 = Security::CodeSigning::BundleDiskRep::metaData(this, v8);
      if (v11)
      {
        v9 = std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t **)a2, v7, &v12);
        Security::CFRef<__CFData const*>::operator=((CFTypeRef *)v9 + 5, (CFTypeRef *)&v11);
      }
    }
    else
    {
      v11 = 0;
    }
    result = Security::CFRef<__CFData const*>::~CFRef((const void **)&v11);
    v7 = (v7 + 1);
    v12 = v7;
  }
  while ((_DWORD)v7 != 4101);
  return result;
}

void sub_18AA2B0F0(_Unwind_Exception *a1)
{
  const void ***v1;

  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

const void **`non-virtual thunk to'Security::CodeSigning::BundleDiskRep::createRawComponents@<X0>(Security::CodeSigning::BundleDiskRep *this@<X0>, uint64_t a2@<X8>)
{
  return Security::CodeSigning::BundleDiskRep::createRawComponents((Security::CodeSigning::BundleDiskRep *)((char *)this - 16), a2);
}

uint64_t **std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  int v9;
  _DWORD *v10;
  _QWORD v12[3];

  v6 = a1 + 1;
  v5 = a1[1];
  v7 = a1 + 1;
  v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2)
          break;
        v5 = *v8;
        v7 = v8;
        if (!*v8)
          goto LABEL_8;
      }
      if (v9 >= a2)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v12[2] = 0xAAAAAAAAAAAAAA01;
    v10 = operator new(0x30uLL);
    v12[1] = v6;
    v10[8] = *a3;
    *((_QWORD *)v10 + 5) = 0;
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
    return (uint64_t **)v10;
  }
  return v8;
}

void std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  const void **v1;

  v1 = *(const void ***)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      Security::CFRef<__CFData const*>::~CFRef(v1 + 5);
    operator delete(v1);
  }
}

void std::__tree<std::string>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::string>::destroy(*(_QWORD *)a1);
    std::__tree<std::string>::destroy(*((_QWORD *)a1 + 1));
    if (a1[55] < 0)
      operator delete(*((void **)a1 + 4));
    operator delete(a1);
  }
}

_QWORD *Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(_QWORD *a1)
{
  pthread_mutex_t *v2;
  Security::UnixError *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  _QWORD v8[2];

  v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01;
  v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3)
    Security::UnixError::throwMe(v3);
  if (*a1)
  {
    v4 = (unsigned int *)(*a1 + 8);
    do
    {
      v5 = __ldxr(v4);
      v6 = v5 - 1;
    }
    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1)
        (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 8))(*a1);
      *a1 = 0;
    }
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

_QWORD *Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(_QWORD *a1)
{
  pthread_mutex_t *v2;
  Security::UnixError *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  _QWORD v8[2];

  v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01;
  v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3)
    Security::UnixError::throwMe(v3);
  if (*a1)
  {
    v4 = (unsigned int *)(*a1 + 8);
    do
    {
      v5 = __ldxr(v4);
      v6 = v5 - 1;
    }
    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1)
        (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 8))(*a1);
      *a1 = 0;
    }
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

void Security::CodeSigning::BundleDiskRep::Writer::~Writer(char **this)
{
  *this = (char *)&off_1E1FC88C0;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(this + 12);
  Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(this + 3);
}

{
  *this = (char *)&off_1E1FC88C0;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(this + 12);
  Security::RefPointer<Security::CodeSigning::BundleDiskRep>::~RefPointer(this + 3);
  JUMPOUT(0x18D76FAA0);
}

void Security::CodeSigning::BundleDiskRep::Writer::component(Security::CodeSigning::BundleDiskRep::Writer *this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
  char *v5;
  _BYTE *v6;
  uint64_t v7;
  std::string *p_str;
  int *v9;
  const __CFURL *v10;
  void **v11;
  std::string *v12;
  std::string *v13;
  char *BytePtr;
  CFIndex Length;
  unint64_t v16;
  void *__p[2];
  char v18;
  std::string __str;

  if ((_DWORD)a2 == 3)
  {
    v5 = "CodeResources";
  }
  else
  {
    v6 = (_BYTE *)*((_QWORD *)this + 12);
    if ((v6[20] & 1) == 0)
    {
      (*(void (**)(_BYTE *))(*(_QWORD *)v6 + 16))(v6);
      return;
    }
    v5 = (char *)Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
    if (!v5)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
  }
  v7 = *((_QWORD *)this + 3);
  memset(&__str, 170, sizeof(__str));
  Security::CodeSigning::BundleDiskRep::metaPath(&__str, (const char *)v7, 0);
  if (!*(_BYTE *)(v7 + 56))
  {
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_str = &__str;
    else
      p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
    if (mkdir((const char *)p_str, 0x1EDu))
    {
      if (*__error() != 17)
      {
        v9 = __error();
        Security::UnixError::throwMe((Security::UnixError *)*v9);
      }
    }
    else
    {
      v10 = (const __CFURL *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 48))(v7);
      Security::cfStringRelease((Security *)__p, v10);
      if (v18 >= 0)
        v11 = __p;
      else
        v11 = (void **)__p[0];
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v12 = &__str;
      else
        v12 = (std::string *)__str.__r_.__value_.__r.__words[0];
      copyfile((const char *)v11, (const char *)v12, 0, 3u);
      if (v18 < 0)
        operator delete(__p[0]);
      std::string::operator=((std::string *)(v7 + 32), &__str);
      *(_BYTE *)(v7 + 56) = 1;
    }
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  memset(&__str, 170, sizeof(__str));
  Security::CodeSigning::BundleDiskRep::metaPath(&__str, *((const char **)this + 3), v5);
  v16 = 0xAAAAAAAAFFFFFFFFLL;
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v13 = &__str;
  else
    v13 = (std::string *)__str.__r_.__value_.__r.__words[0];
  Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v16, (const char *)v13, 1537, 420);
  BytePtr = (char *)CFDataGetBytePtr(a3);
  Length = CFDataGetLength(a3);
  Security::UnixPlusPlus::FileDesc::writeAll((ssize_t)&v16, BytePtr, Length);
  Security::UnixPlusPlus::FileDesc::close((Security::UnixPlusPlus::FileDesc *)&v16);
  std::string::basic_string[abi:ne180100]<0>(__p, v5);
  std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>((uint64_t **)this + 22, __p, (uint64_t)__p);
  if (v18 < 0)
    operator delete(__p[0]);
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v16);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
}

void sub_18AA2B684(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0)
    operator delete(__p);
  if (a22 < 0)
    operator delete(a17);
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::BundleDiskRep::Writer::remove(Security::CodeSigning::BundleDiskRep::Writer *this)
{
  Security::CodeSigning::CodeDirectory *v2;

  (*(void (**)(_QWORD))(**((_QWORD **)this + 12) + 40))(*((_QWORD *)this + 12));
  v2 = 0;
  do
  {
    Security::CodeSigning::BundleDiskRep::Writer::remove((const char **)this, v2);
    v2 = (Security::CodeSigning::CodeDirectory *)((_DWORD)v2 + 1);
  }
  while ((_DWORD)v2 != 12);
  Security::CodeSigning::BundleDiskRep::Writer::remove((const char **)this, (Security::CodeSigning::CodeDirectory *)0x10000);
}

void Security::CodeSigning::BundleDiskRep::Writer::flush(Security::CodeSigning::BundleDiskRep::Writer *this)
{
  uint64_t v2;
  char *v3;
  char *v4;
  dirent *Next;
  char *d_name;
  char *v7;
  int v8;
  int *v9;
  void *__p[2];
  char v11;
  std::string v12;
  DIR *__b[137];

  __b[136] = *(DIR **)MEMORY[0x1E0C80C00];
  (*(void (**)(_QWORD))(**((_QWORD **)this + 12) + 48))(*((_QWORD *)this + 12));
  memset(__b, 170, 0x440uLL);
  v2 = *((_QWORD *)this + 3);
  if (*(char *)(v2 + 55) < 0)
    std::string::__init_copy_ctor_external(&v12, *(const std::string::value_type **)(v2 + 32), *(_QWORD *)(v2 + 40));
  else
    v12 = *(std::string *)(v2 + 32);
  Security::CodeSigning::DirScanner::DirScanner((uint64_t)__b, &v12);
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v12.__r_.__value_.__l.__data_);
  if (LOBYTE(__b[135]))
  {
    v3 = (char *)this + 176;
    v4 = (char *)this + 184;
    while (1)
    {
      Next = Security::CodeSigning::DirScanner::getNext(__b);
      if (!Next)
        break;
      if (!Security::CodeSigning::DirScanner::isRegularFile((Security::CodeSigning::DirScanner *)__b, Next))
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA3ALL);
      d_name = Next->d_name;
      std::string::basic_string[abi:ne180100]<0>(__p, d_name);
      v7 = (char *)std::__tree<std::string>::find<std::string>((uint64_t)v3, __p);
      if (v11 < 0)
        operator delete(__p[0]);
      if (v4 == v7)
      {
        v8 = dirfd(__b[3]);
        if (unlinkat(v8, d_name, 0) == -1)
        {
          v9 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v9);
        }
      }
    }
  }
  Security::CodeSigning::DirScanner::~DirScanner((Security::CodeSigning::DirScanner *)__b);
}

void sub_18AA2B8B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  _Unwind_Resume(exception_object);
}

_QWORD *std::__tree<std::string>::find<std::string>(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  char v6;
  _QWORD *v7;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = (_QWORD *)(a1 + 8);
  do
  {
    v6 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v3 + 4, a2);
    if (v6 >= 0)
      v7 = v3;
    else
      v7 = v3 + 1;
    if (v6 >= 0)
      v5 = v3;
    v3 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v5 == v2
    || (std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v5 + 4) & 0x80) != 0)
  {
    return v2;
  }
  return v5;
}

uint64_t std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, _QWORD *a2)
{
  size_t v2;
  size_t v3;
  size_t v4;
  size_t v5;
  size_t v6;
  int v7;

  v2 = a1[1];
  if (*((char *)a1 + 23) >= 0)
  {
    v3 = *((unsigned __int8 *)a1 + 23);
  }
  else
  {
    a1 = (_QWORD *)*a1;
    v3 = v2;
  }
  v4 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    v5 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (_QWORD *)*a2;
    v5 = v4;
  }
  if (v5 >= v3)
    v6 = v3;
  else
    v6 = v5;
  v7 = memcmp(a1, a2, v6);
  if (v7)
  {
    if ((v7 & 0x80000000) == 0)
      return 1;
  }
  else
  {
    if (v3 == v5)
      return 0;
    if (v3 >= v5)
      return 1;
  }
  return 255;
}

void Security::CodeSigning::BundleDiskRep::Writer::remove(const char **this, Security::CodeSigning::CodeDirectory *a2)
{
  const char *v3;
  int v4;
  void *v5;
  std::string *v6;
  int v7;
  int v8;
  int *v9;
  std::string v10;

  v3 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
  if (v3)
  {
    Security::CodeSigning::BundleDiskRep::metaPath(&v10, this[3], v3);
    v4 = SHIBYTE(v10.__r_.__value_.__r.__words[2]);
    v5 = (void *)v10.__r_.__value_.__r.__words[0];
    if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v6 = &v10;
    else
      v6 = (std::string *)v10.__r_.__value_.__r.__words[0];
    v7 = unlink((const char *)v6);
    v8 = v7;
    if (v4 < 0)
    {
      operator delete(v5);
      if (!v8)
        return;
    }
    else if (!v7)
    {
      return;
    }
    if (*__error() != 2)
    {
      v9 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v9);
    }
  }
}

uint64_t *std::__tree<std::string>::__emplace_unique_key_args<std::string,std::string>(uint64_t **a1, _QWORD *a2, uint64_t a3)
{
  uint64_t *result;
  uint64_t **v6;
  _OWORD *v7;
  uint64_t v8;

  v8 = 0xAAAAAAAAAAAAAAAALL;
  result = std::__tree<std::string>::__find_equal<std::string>((uint64_t)a1, &v8, a2);
  if (!*result)
  {
    v6 = (uint64_t **)result;
    v7 = operator new(0x38uLL);
    v7[2] = *(_OWORD *)a3;
    *((_QWORD *)v7 + 6) = *(_QWORD *)(a3 + 16);
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    return std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(a1, v8, v6, (uint64_t *)v7);
  }
  return result;
}

_QWORD *std::__tree<std::string>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = v4 + 4;
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a3, v4 + 4) & 0x80) == 0)
          break;
        v4 = (_QWORD *)*v7;
        v5 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a3) & 0x80) == 0)
        break;
      v5 = v7 + 1;
      v4 = (_QWORD *)v7[1];
    }
    while (v4);
  }
  else
  {
    v7 = (_QWORD *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

void Security::CodeSigning::BundleDiskRep::resourcesRelativePath(Security::CodeSigning::BundleDiskRep *this, CFBundleRef *a2)
{
  std::string *p_str;
  int64_t size;
  char *v6;
  int64_t v7;
  std::string *v8;
  char *v9;
  std::string::size_type v11;
  std::string *v12;
  std::string *v13;
  char *v14;
  int64_t v15;
  std::string *v16;
  char *v17;
  std::string::size_type v19;
  std::string *v20;
  _BOOL4 v21;
  std::string::size_type v22;
  _QWORD *v23;
  const __CFURL *v24;
  uint64_t v25;
  uint64_t v26;
  std::string::size_type v27;
  std::string *v28;
  Security::CodeSigning::BundleDiskRep *v29;
  Security::CodeSigning::BundleDiskRep *v30;
  std::string::size_type v31;
  std::string *v32;
  std::string::size_type v33;
  char v34;
  std::string v35;
  std::string __str;
  char v37;
  _BYTE v38[15];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  p_str = &__str;
  memset(&__str, 170, sizeof(__str));
  (*((void (**)(std::string *__return_ptr, CFBundleRef *))*a2 + 7))(&__str, a2);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  else
    size = __str.__r_.__value_.__l.__size_;
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  if (size >= 3)
  {
    v6 = (char *)p_str + size;
    v7 = size;
    v8 = p_str;
    do
    {
      v9 = (char *)memchr(v8, 47, v7 - 2);
      if (!v9)
        break;
      if (*(_WORD *)v9 == 11823 && v9[2] == 47)
      {
        if (v9 != v6)
        {
          v11 = v9 - (char *)p_str;
          if (v9 - (char *)p_str != -1)
          {
LABEL_17:
            v12 = std::string::replace(&__str, v11, 2uLL, (const std::string::value_type *)&unk_18AA61AAF, 0);
            std::string::operator=(&__str, v12);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            else
              size = __str.__r_.__value_.__l.__size_;
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v13 = &__str;
            else
              v13 = (std::string *)__str.__r_.__value_.__r.__words[0];
            if (size >= 3)
            {
              v14 = (char *)v13 + size;
              v15 = size;
              v16 = v13;
              while (1)
              {
                v17 = (char *)memchr(v16, 47, v15 - 2);
                if (!v17)
                  break;
                if (*(_WORD *)v17 == 11823 && v17[2] == 47)
                {
                  if (v17 != v14)
                  {
                    v11 = v17 - (char *)v13;
                    if (v17 - (char *)v13 != -1)
                      goto LABEL_17;
                  }
                  goto LABEL_34;
                }
                v16 = (std::string *)(v17 + 1);
                v15 = v14 - (char *)v16;
                if (v14 - (char *)v16 < 3)
                  goto LABEL_34;
              }
            }
          }
        }
        break;
      }
      v8 = (std::string *)(v9 + 1);
      v7 = v6 - (char *)v8;
    }
    while (v6 - (char *)v8 >= 3);
  }
LABEL_34:
  std::string::basic_string(&v35, &__str, size - 2, 2uLL, (std::allocator<char> *)v38);
  v19 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
  if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v19 = v35.__r_.__value_.__l.__size_;
  if (v19 != 2)
  {
    v21 = 0;
    if ((SHIBYTE(v35.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_40;
LABEL_43:
    operator delete(v35.__r_.__value_.__l.__data_);
    if (!v21)
      goto LABEL_49;
    goto LABEL_44;
  }
  v20 = (std::string *)v35.__r_.__value_.__r.__words[0];
  if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v20 = &v35;
  v21 = LOWORD(v20->__r_.__value_.__l.__data_) == 11823;
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_43;
LABEL_40:
  if (!v21)
    goto LABEL_49;
LABEL_44:
  v22 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v22 = __str.__r_.__value_.__l.__size_;
  std::string::basic_string(&v35, &__str, 0, v22 - 2, (std::allocator<char> *)v38);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  __str = v35;
LABEL_49:
  *((_QWORD *)this + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23 = (_QWORD *)((char *)this + 8);
  *((_QWORD *)this + 2) = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)this = 0xAAAAAAAAAAAAAAAALL;
  v24 = CFBundleCopyResourcesDirectoryURL(a2[3]);
  Security::cfStringRelease(this, v24);
  v25 = *((unsigned __int8 *)this + 23);
  if ((v25 & 0x80u) == 0)
    v26 = *((unsigned __int8 *)this + 23);
  else
    v26 = *((_QWORD *)this + 1);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v27 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  else
    v27 = __str.__r_.__value_.__l.__size_;
  if (v26 == v27)
  {
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v28 = &__str;
    else
      v28 = (std::string *)__str.__r_.__value_.__r.__words[0];
    if ((v25 & 0x80) == 0)
    {
      if (*((_BYTE *)this + 23))
      {
        v29 = this;
        while (*(unsigned __int8 *)v29 == v28->__r_.__value_.__s.__data_[0])
        {
          v29 = (Security::CodeSigning::BundleDiskRep *)((char *)v29 + 1);
          v28 = (std::string *)((char *)v28 + 1);
          if (!--v25)
            goto LABEL_64;
        }
        goto LABEL_66;
      }
LABEL_64:
      *((_BYTE *)this + 23) = 0;
LABEL_74:
      *(_BYTE *)this = 0;
      goto LABEL_75;
    }
    v30 = *(Security::CodeSigning::BundleDiskRep **)this;
    if (!memcmp(*(const void **)this, v28, *((_QWORD *)this + 1)))
    {
      *v23 = 0;
      this = v30;
      goto LABEL_74;
    }
  }
LABEL_66:
  if (std::string::compare((const std::string *)this, 0, v27, &__str, 0, v27))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
  v31 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v31 = __str.__r_.__value_.__l.__size_;
  std::string::basic_string(&v35, (const std::string *)this, v31 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v37);
  v32 = std::string::append(&v35, "/", 1uLL);
  v33 = v32->__r_.__value_.__r.__words[0];
  *(_QWORD *)v38 = v32->__r_.__value_.__l.__size_;
  *(_QWORD *)&v38[7] = *(std::string::size_type *)((char *)&v32->__r_.__value_.__r.__words[1] + 7);
  v34 = HIBYTE(v32->__r_.__value_.__r.__words[2]);
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  if (*((char *)this + 23) < 0)
    operator delete(*(void **)this);
  *(_QWORD *)this = v33;
  *v23 = *(_QWORD *)v38;
  *(_QWORD *)((char *)this + 15) = *(_QWORD *)&v38[7];
  *((_BYTE *)this + 23) = v34;
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
LABEL_75:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
}

void sub_18AA2BFC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFDataRef Security::cfmake<__CFArray const*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t *v10;
  _QWORD v11[3];
  int v12;

  v10 = &a9;
  v11[0] = "['^(.*/)?\\.DS_Store$''^Info\\.plist$''^PkgInfo$'%s]";
  v11[1] = &v10;
  v11[2] = 0;
  v12 = 0;
  return Security::CFMake::make((Security::CFMake *)v11);
}

uint64_t *std::back_insert_iterator<std::vector<int>>::operator=[abi:ne180100](uint64_t *a1, int a2)
{
  uint64_t v4;
  unint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  int v15;

  v4 = *a1;
  v6 = *(_DWORD **)(*a1 + 8);
  v5 = *(_QWORD *)(*a1 + 16);
  if ((unint64_t)v6 >= v5)
  {
    v8 = *(_DWORD **)v4;
    v9 = ((uint64_t)v6 - *(_QWORD *)v4) >> 2;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62)
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    v11 = v5 - (_QWORD)v8;
    if (v11 >> 1 > v10)
      v10 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      if (v12 >> 62)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v13 = (char *)operator new(4 * v12);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[4 * v9];
    *(_DWORD *)v14 = a2;
    v7 = v14 + 4;
    while (v6 != v8)
    {
      v15 = *--v6;
      *((_DWORD *)v14 - 1) = v15;
      v14 -= 4;
    }
    *(_QWORD *)v4 = v14;
    *(_QWORD *)(v4 + 8) = v7;
    *(_QWORD *)(v4 + 16) = &v13[4 * v12];
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v6 = a2;
    v7 = v6 + 1;
  }
  *(_QWORD *)(v4 + 8) = v7;
  return a1;
}

uint64_t *std::__tree<int>::__emplace_unique_key_args<int,int const&>(uint64_t *result, int a2, int a3)
{
  uint64_t **v4;
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  uint64_t *v9;

  v4 = (uint64_t **)result;
  v6 = (uint64_t **)(result + 1);
  v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = (uint64_t **)(result + 1);
LABEL_9:
    v9 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v9 + 7) = a3;
    return std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(v4, (uint64_t)v7, v6, v9);
  }
  return result;
}

void Security::CodeSigning::BundleDiskRep::checkModifiedFile(Security::CodeSigning::BundleDiskRep *this, __CFArray *a2, Security::CodeSigning::CodeDirectory *a3)
{
  const void *v6;
  const char *v7;
  int v8;
  std::string::value_type *v9;
  std::string *p_sz;
  const __CFURL *v11;
  Security *p_p;
  std::string __p;
  CFURLRef CFURL;
  std::string __sz;

  v6 = (const void *)(*(uint64_t (**)(_QWORD, Security::CodeSigning::CodeDirectory *))(**((_QWORD **)this + 13)
                                                                                               + 24))(*((_QWORD *)this + 13), a3);
  if (v6)
  {
    CFRelease(v6);
  }
  else
  {
    v7 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a3);
    if (v7)
    {
      memset(&__sz, 170, sizeof(__sz));
      Security::CodeSigning::BundleDiskRep::metaPath(&__sz, (const char *)this, v7);
      v8 = SHIBYTE(__sz.__r_.__value_.__r.__words[2]);
      v9 = (std::string::value_type *)__sz.__r_.__value_.__r.__words[0];
      if ((__sz.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_sz = &__sz;
      else
        p_sz = (std::string *)__sz.__r_.__value_.__r.__words[0];
      if (!access((const char *)p_sz, 0))
      {
        if (v8 < 0)
          std::string::__init_copy_ctor_external(&__p, v9, __sz.__r_.__value_.__l.__size_);
        else
          __p = __sz;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_p = (Security *)&__p;
        else
          p_p = (Security *)__p.__r_.__value_.__r.__words[0];
        CFURL = Security::makeCFURL(p_p, 0, 0, v11);
        CFArrayAppendValue(a2, CFURL);
        Security::CFRef<__CFURL const*>::~CFRef((const void **)&CFURL);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (v8 < 0)
        operator delete(v9);
    }
  }
}

void sub_18AA2C314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
  void *v16;

  operator delete(v16);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::ResourceBuilder::addExclusion(_QWORD *a1, __int128 *a2, int a3)
{
  regex_t **v6;
  regex_t *v7;
  char *v8;
  unint64_t v9;
  char *v10;
  char *v11;
  _QWORD *v12;
  uint64_t v13;
  char *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  char *v21;
  regex_t **v22;
  char *v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  regex_t **v29;
  regex_t **v30;
  regex_t *v31;
  char *v32;
  int64_t v33;
  void *v34;

  v6 = (regex_t **)a1[8];
  v7 = (regex_t *)operator new();
  Security::CodeSigning::ResourceBuilder::Rule::Rule(v7, a2, 0, a3 | 0x10);
  v8 = (char *)a1[9];
  v9 = a1[10];
  if ((unint64_t)v8 >= v9)
  {
    v14 = (char *)a1[8];
    v15 = ((v8 - v14) >> 3) + 1;
    if (v15 >> 61)
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    v16 = (char *)v6 - v14;
    v17 = ((char *)v6 - v14) >> 3;
    v18 = v9 - (_QWORD)v14;
    if (v18 >> 2 > v15)
      v15 = v18 >> 2;
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8)
      v19 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v19 = v15;
    if (v19)
    {
      v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>(v19);
    }
    else
    {
      v21 = 0;
      v20 = 0;
    }
    v22 = (regex_t **)&v21[8 * v17];
    v23 = &v21[8 * v20];
    if (v17 == v20)
    {
      if (v16 < 1)
      {
        if (v6 == (regex_t **)v14)
          v25 = 1;
        else
          v25 = v16 >> 2;
        v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>(v25);
        v22 = (regex_t **)&v26[8 * (v25 >> 2)];
        v23 = &v26[8 * v27];
        if (v21)
          operator delete(v21);
      }
      else
      {
        v24 = v17 + 2;
        if (v17 >= -1)
          v24 = v17 + 1;
        v22 -= v24 >> 1;
      }
    }
    *v22 = v7;
    v28 = (char *)(v22 + 1);
    v29 = (regex_t **)a1[8];
    if (v29 != v6)
    {
      v30 = v6;
      do
      {
        v31 = *--v30;
        *--v22 = v31;
      }
      while (v30 != v29);
    }
    v32 = (char *)a1[9];
    v33 = v32 - (char *)v6;
    if (v32 != (char *)v6)
      memmove(v28, v6, v32 - (char *)v6);
    v34 = (void *)a1[8];
    a1[8] = v22;
    a1[9] = &v28[v33];
    a1[10] = v23;
    if (v34)
      operator delete(v34);
  }
  else if (v6 == (regex_t **)v8)
  {
    *v6 = v7;
    a1[9] = v6 + 1;
  }
  else
  {
    v10 = (char *)(v6 + 1);
    v11 = v8 - 8;
    v12 = (_QWORD *)a1[9];
    while (v11 < v8)
    {
      v13 = *(_QWORD *)v11;
      v11 += 8;
      *v12++ = v13;
    }
    a1[9] = v12;
    if (v8 != v10)
      memmove(&v8[-8 * ((v8 - v10) >> 3)], v6, v8 - v10);
    *v6 = v7;
  }
}

void sub_18AA2C55C(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>(unint64_t a1)
{
  if (a1 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a1);
}

void Security::CodeSigning::DirValidator::require(uint64_t a1, __int128 *a2, int a3, const void *a4)
{
  uint64_t v8;

  v8 = operator new();
  Security::CodeSigning::DirValidator::Rule::Rule(v8, a2, a3 | 0x10, a4);
  Security::CodeSigning::DirValidator::addRule((char **)a1, v8);
  ++*(_DWORD *)(a1 + 24);
}

void sub_18AA2C644(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x10F2C405152D04CLL);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::DirValidator::allow(char **a1, __int128 *a2, int a3, const void *a4)
{
  uint64_t v8;

  v8 = operator new();
  Security::CodeSigning::DirValidator::Rule::Rule(v8, a2, a3, a4);
  Security::CodeSigning::DirValidator::addRule(a1, v8);
}

void sub_18AA2C6D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x10F2C405152D04CLL);
  _Unwind_Resume(a1);
}

void ___ZN8Security11CodeSigning13BundleDiskRep21validateFrameworkRootENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEE_block_invoke(uint64_t a1@<X0>, std::string::value_type *a2@<X1>, std::string *a3@<X8>)
{
  const std::string::value_type *v6;
  uint64_t v7;
  const std::string::value_type *v8;
  int v9;
  const std::string::value_type *v10;
  std::string::size_type v11;
  std::string *v12;
  __int128 v13;
  std::string *v14;
  __int128 v15;
  std::string *p_p;
  std::string::size_type size;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  std::string __p;
  std::string v22;
  std::string v23;
  std::string v24;
  std::string v25;

  std::string::basic_string[abi:ne180100]<0>(&v22, "^(\\./)?Versions/");
  v8 = *(const std::string::value_type **)(a1 + 32);
  v7 = a1 + 32;
  v6 = v8;
  v9 = *(char *)(v7 + 23);
  if (v9 >= 0)
    v10 = (const std::string::value_type *)v7;
  else
    v10 = v6;
  if (v9 >= 0)
    v11 = *(unsigned __int8 *)(v7 + 23);
  else
    v11 = *(_QWORD *)(v7 + 8);
  v12 = std::string::append(&v22, v10, v11);
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  v14 = std::string::append(&v23, "/", 1uLL);
  v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  Security::CodeSigning::ResourceBuilder::escapeRE(&__p, a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v18 = std::string::append(&v24, (const std::string::value_type *)p_p, size);
  v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  v20 = std::string::append(&v25, "$", 1uLL);
  *a3 = *v20;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v25.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
}

void sub_18AA2C868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  if (*(char *)(v33 - 41) < 0)
    operator delete(*(void **)(v33 - 64));
  if (a14 < 0)
    operator delete(__p);
  if (a33 < 0)
    operator delete(a28);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void ___ZN8Security11CodeSigning12DirValidator5allowERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjS8__block_invoke(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 32), *(_QWORD *)(a1 + 40));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 32);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 48);
  }
}

void __copy_helper_block_e8_32c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  std::string *v2;
  __int128 v3;

  v2 = (std::string *)(a1 + 32);
  if (*(char *)(a2 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 32), *(_QWORD *)(a2 + 40));
  }
  else
  {
    v3 = *(_OWORD *)(a2 + 32);
    v2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 48);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void __destroy_helper_block_e8_32c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0)
    operator delete(*(void **)(a1 + 32));
}

void ___ZN8Security11CodeSigning12DirValidator7requireERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjS8__block_invoke(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 32), *(_QWORD *)(a1 + 40));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 32);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 48);
  }
}

void Security::CodeSigning::DirValidator::addRule(char **a1, uint64_t a2)
{
  unint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;

  v5 = a1[1];
  v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    v7 = *a1;
    v8 = (v5 - *a1) >> 3;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    v10 = v4 - (_QWORD)v7;
    if (v10 >> 2 > v9)
      v9 = v10 >> 2;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
    {
      if (v11 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v12 = (char *)operator new(8 * v11);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[8 * v8];
    *(_QWORD *)v13 = a2;
    v6 = v13 + 8;
    if (v5 != v7)
    {
      do
      {
        v14 = *((_QWORD *)v5 - 1);
        v5 -= 8;
        *((_QWORD *)v13 - 1) = v14;
        v13 -= 8;
      }
      while (v5 != v7);
      v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v6;
    a1[2] = &v12[8 * v11];
    if (v5)
      operator delete(v5);
  }
  else
  {
    *(_QWORD *)v5 = a2;
    v6 = v5 + 8;
  }
  a1[1] = v6;
}

Security::CodeSigning::CodeDirectory::Builder *Security::CodeSigning::CodeDirectory::Builder::Builder(Security::CodeSigning::CodeDirectory::Builder *this, Security::CodeSigning::CodeDirectory *a2)
{
  Security::CCHashInstance *v3;
  unsigned int *v4;
  unsigned int v5;
  Security::CCHashInstance *v7;
  pthread_mutex_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)this = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = (char *)this + 24;
  *((_DWORD *)this + 10) = -1;
  *((_BYTE *)this + 44) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_DWORD *)this + 19) = (_DWORD)a2;
  *((_BYTE *)this + 80) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_QWORD *)this + 27) = 0;
  *((_QWORD *)this + 26) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 177) = 0u;
  *((_QWORD *)this + 25) = (char *)this + 208;
  *((_DWORD *)this + 56) = 0;
  *((_QWORD *)this + 29) = 0;
  v3 = Security::CodeSigning::CodeDirectory::hashFor(a2);
  Security::Mutex::Mutex(&v8);
  v4 = (unsigned int *)((char *)v3 + 8);
  do
    v5 = __ldxr(v4);
  while (__stxr(v5 + 1, v4));
  v7 = v3;
  *((_DWORD *)this + 21) = (*(uint64_t (**)(Security::CCHashInstance *))(*(_QWORD *)v3 + 16))(v3);
  Security::RefPointer<Security::DynamicHash>::~RefPointer(&v7);
  *((_QWORD *)this + 1) = malloc_type_calloc(0xBuLL, *((unsigned int *)this + 21), 0xB51D5EAAuLL);
  return this;
}

void sub_18AA2CB98(_Unwind_Exception *a1)
{
  uint64_t v1;
  Security::UnixPlusPlus::FileDesc *v2;
  _QWORD **v3;
  void **v4;

  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*(const void ***)(v1 + 208));
  if (*(char *)(v1 + 135) < 0)
    operator delete(*(void **)(v1 + 112));
  if (*(char *)(v1 + 111) < 0)
    operator delete(*v4);
  Security::UnixPlusPlus::FileDesc::closeAndLog(v2);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*v3);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::CodeDirectory::Builder::~Builder(Security::CodeSigning::CodeDirectory::Builder *this)
{
  free(*((void **)this + 1));
  free(*((void **)this + 19));
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*((const void ***)this + 26));
  if (*((char *)this + 135) < 0)
    operator delete(*((void **)this + 14));
  if (*((char *)this + 111) < 0)
    operator delete(*((void **)this + 11));
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::CodeDirectory::Builder *)((char *)this + 40));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)this + 3));
}

_QWORD *Security::CodeSigning::CodeDirectory::Builder::specialSlot(Security::CodeSigning::CodeDirectory::Builder *this, unsigned int a2, const __CFData *a3)
{
  __int128 v6;
  Security::CCHashInstance *v7;
  unsigned int *v8;
  unsigned int v9;
  const UInt8 *BytePtr;
  CFIndex Length;
  _OWORD v13[4];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v13[2] = v6;
  v13[3] = v6;
  v13[0] = v6;
  v13[1] = v6;
  v7 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)*((unsigned int *)this + 19));
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)v13 + 8));
  v8 = (unsigned int *)((char *)v7 + 8);
  do
    v9 = __ldxr(v8);
  while (__stxr(v9 + 1, v8));
  *(_QWORD *)&v13[0] = v7;
  BytePtr = CFDataGetBytePtr(a3);
  Length = CFDataGetLength(a3);
  (*(void (**)(Security::CCHashInstance *, const UInt8 *, CFIndex))(*(_QWORD *)v7 + 24))(v7, BytePtr, Length);
  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)&v13[0] + 32))(*(_QWORD *)&v13[0], *((_QWORD *)this + 1) + *((_DWORD *)this + 21) * (a2 - 1));
  std::__tree<int>::__emplace_unique_key_args<int,int const&>((uint64_t *)this + 2, a2, a2);
  if (*((_QWORD *)this + 17) <= (unint64_t)a2)
    *((_QWORD *)this + 17) = a2;
  return Security::RefPointer<Security::DynamicHash>::~RefPointer(v13);
}

void sub_18AA2CD98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  Security::RefPointer<Security::DynamicHash>::~RefPointer(&a9);
  _Unwind_Resume(a1);
}

unint64_t Security::CodeSigning::CodeDirectory::Builder::size(Security::CodeSigning::CodeDirectory::Builder *this, unsigned int a2)
{
  unint64_t v4;
  timespec v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t result;
  stat v15;

  v4 = *((_QWORD *)this + 7);
  if (v4)
    goto LABEL_3;
  v5.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v5.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v15.st_blksize = v5;
  *(timespec *)v15.st_qspare = v5;
  v15.st_birthtimespec = v5;
  *(timespec *)&v15.st_size = v5;
  v15.st_mtimespec = v5;
  v15.st_ctimespec = v5;
  *(timespec *)&v15.st_uid = v5;
  v15.st_atimespec = v5;
  *(timespec *)&v15.st_dev = v5;
  Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*((unsigned int *)this + 10), &v15);
  v6 = *((_QWORD *)this + 6);
  v4 = v15.st_size - v6;
  v7 = v15.st_size == v6;
  *((_QWORD *)this + 7) = v15.st_size - v6;
  if (!v7)
LABEL_3:
    v4 = (v4 - 1) / *((_QWORD *)this + 8) + 1;
  *((_QWORD *)this + 18) = v4;
  v8 = 96;
  if (a2 < 0x20500)
    v8 = 88;
  if (a2 < 0x20400)
    v8 -= 24;
  if (a2 >= 0x20300)
    v9 = v8;
  else
    v9 = v8 - 12;
  if (a2 >> 9 < 0x101)
    v9 -= 4;
  if (*((char *)this + 111) < 0)
    v10 = *((_QWORD *)this + 12);
  else
    v10 = *((unsigned __int8 *)this + 111);
  v11 = v9 + *((_QWORD *)this + 20) + v10 + 1;
  if (*((char *)this + 135) < 0)
  {
    v12 = *((_QWORD *)this + 15);
    if (!v12)
      goto LABEL_19;
    goto LABEL_18;
  }
  v12 = *((unsigned __int8 *)this + 135);
  if (*((_BYTE *)this + 135))
LABEL_18:
    v11 += v12 + 1;
LABEL_19:
  v13 = *((unsigned int *)this + 21);
  result = v11 + (*((_QWORD *)this + 17) + v4) * v13;
  if (*((_BYTE *)this + 192) || *((_QWORD *)this + 27))
    result += v4 * v13;
  if (result <= v9)
    Security::UnixError::throwMe((Security::UnixError *)8);
  return result;
}

uint64_t Security::CodeSigning::CodeDirectory::Builder::build(Security::CodeSigning::CodeDirectory::Builder *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  size_t v6;
  unsigned int v7;
  int8x8_t *v8;
  int8x16_t *v9;
  unint64_t v10;
  unsigned int v11;
  size_t v12;
  unint64_t v13;
  __int8 v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  _QWORD *v18;
  uint64_t v19;
  size_t v20;
  _QWORD *v21;
  uint64_t v22;
  unsigned int v23;
  BOOL v24;
  void *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  size_t v30;
  unsigned int v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  size_t v35;
  size_t v36;
  size_t v37;
  size_t v38;
  __int128 v39;
  Security::CCHashInstance *v40;
  unsigned int *v41;
  unsigned int v42;
  char v43;
  uint64_t v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  unsigned int v48;
  void *v49;
  char *v50;
  char *v51;
  unsigned int v52;
  char *v53;
  unsigned int v54;
  BOOL v55;
  char **v56;
  uint64_t v57;
  unsigned int v58;
  uint64_t v59;
  void *v60;
  const UInt8 *BytePtr;
  char *v62;
  unsigned int v63;
  char *v64;
  char *v65;
  unsigned int v66;
  BOOL v67;
  char **v68;
  char *v69;
  char *v70;
  char *v71;
  uint64_t v72;
  char *v73;
  char *v74;
  int v75;
  char **v76;
  char *v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  char *v85;
  char *v86;
  char *v87;
  uint64_t v88;
  char *v89;
  char *v90;
  BOOL v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int __e;
  _QWORD v100[5];
  int v101;
  char v102;
  _OWORD v103[4];
  unint64_t v104;
  uint64_t v105;

  v105 = *MEMORY[0x1E0C80C00];
  if (*((char *)this + 111) < 0)
    v2 = *((_QWORD *)this + 12);
  else
    v2 = *((unsigned __int8 *)this + 111);
  v3 = *((unsigned __int8 *)this + 135);
  if (*((char *)this + 135) < 0)
    v4 = *((_QWORD *)this + 15);
  else
    v4 = *((unsigned __int8 *)this + 135);
  if (*((_BYTE *)this + 192) || *((_QWORD *)this + 27))
  {
    v5 = 132352;
  }
  else
  {
    v5 = 132352;
    if (!*((_DWORD *)this + 56))
    {
      if (*((_QWORD *)this + 22))
      {
        v5 = 132096;
      }
      else if (*((_DWORD *)this + 15))
      {
        v5 = 131840;
      }
      else
      {
        if ((v3 & 0x80) != 0)
          v3 = *((_QWORD *)this + 15);
        if (v3)
          v5 = 131584;
        else
          v5 = 131328;
      }
    }
  }
  if (*((_DWORD *)this + 37))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA44);
  v6 = Security::CodeSigning::CodeDirectory::Builder::size(this, v5);
  v7 = v6;
  v8 = (int8x8_t *)malloc_type_calloc(1uLL, v6, 0x39C17D27uLL);
  *((_QWORD *)this + 29) = v8;
  if (!v8)
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  v9 = (int8x16_t *)v8;
  v8->i32[0] = 34397946;
  v8->i32[1] = bswap32(v7);
  v8[1].i32[0] = bswap32(v5);
  v8[1].i32[1] = bswap32(*((_DWORD *)this + 18));
  v8[3] = vrev32_s8((int8x8_t)vmovn_s64(*(int64x2_t *)((char *)this + 136)));
  v10 = *((_QWORD *)this + 7);
  if (HIDWORD(v10))
  {
    v8[7] = (int8x8_t)bswap64(v10);
    v11 = -1;
  }
  else
  {
    v11 = bswap32(v10);
  }
  v12 = v2 + 1;
  v8[4].i32[0] = v11;
  v8[4].i8[5] = *((_DWORD *)this + 19);
  v8[4].i8[6] = *((_BYTE *)this + 80);
  v8[4].i8[4] = *((_DWORD *)this + 21);
  v13 = *((_QWORD *)this + 8);
  frexp((double)v13, &__e);
  v14 = __e - 1;
  if (!v13)
    v14 = 0;
  v9[2].i8[7] = v14;
  v9[4] = vrev64q_s8(*(int8x16_t *)((char *)this + 168));
  v9[5].i64[0] = bswap64(*((_QWORD *)this + 23));
  v9[5].i32[2] = bswap32(*((_DWORD *)this + 56));
  v15 = 96;
  if (v5 < 0x20500)
    v15 = 88;
  if (v5 < 0x20400)
    v15 -= 24;
  if (v5 < 0x20300)
    v15 -= 12;
  if (v5 >= 0x20200)
    v16 = v15;
  else
    v16 = v15 - 4;
  v17 = (const void *)*((_QWORD *)this + 19);
  if (v17)
  {
    v9[2].i32[3] = bswap32(v16);
    memcpy(&v9->i8[v16], v17, *((_QWORD *)this + 20));
    v16 += *((_QWORD *)this + 20);
  }
  v18 = (_QWORD *)((char *)this + 88);
  v19 = *((_QWORD *)this + 29);
  *(_DWORD *)(v19 + 20) = bswap32(v16);
  if (*((char *)this + 111) < 0)
    v18 = (_QWORD *)*v18;
  memcpy((void *)(v19 + v16), v18, v12);
  v20 = v16 + v12;
  if (*((char *)this + 135) < 0)
  {
    if (!*((_QWORD *)this + 15))
      goto LABEL_43;
  }
  else if (!*((_BYTE *)this + 135))
  {
    goto LABEL_43;
  }
  v21 = (_QWORD *)((char *)this + 112);
  v22 = *((_QWORD *)this + 29);
  *(_DWORD *)(v22 + 48) = bswap32(v20);
  v23 = bswap32(*(_DWORD *)(v22 + 8));
  if ((_DWORD)v20)
    v24 = v23 >= 0x20200;
  else
    v24 = 0;
  v25 = (void *)(v22 + v20);
  if (v24)
    v26 = v25;
  else
    v26 = 0;
  if (*((char *)this + 135) < 0)
    v21 = (_QWORD *)*v21;
  memcpy(v26, v21, v4 + 1);
  v20 += v4 + 1;
LABEL_43:
  if (*((_BYTE *)this + 192) || *((_QWORD *)this + 27))
  {
    v27 = *((_QWORD *)this + 29);
    *(_DWORD *)(v27 + 92) = bswap32(v20);
    v28 = *((unsigned int *)this + 21);
    v20 += *((_QWORD *)this + 18) * v28;
  }
  else
  {
    v28 = *((unsigned int *)this + 21);
    v27 = *((_QWORD *)this + 29);
  }
  v29 = *((_QWORD *)this + 17);
  v30 = v29 * v28;
  v31 = v29 * v28 + v20;
  *(_DWORD *)(v27 + 16) = bswap32(v31);
  bzero((void *)(v27 + v31 + -((_DWORD)v29 * *(unsigned __int8 *)(v27 + 36))), v30);
  if (*((_QWORD *)this + 17))
  {
    v32 = 1;
    v33 = 0xFFFFFFFF00000000;
    do
    {
      memcpy((void *)(bswap32(*(_DWORD *)(*((_QWORD *)this + 29) + 16))+ *((_QWORD *)this + 29)+ ((uint64_t)(v33 * *(unsigned __int8 *)(*((_QWORD *)this + 29) + 36)) >> 32)), (const void *)(*((_QWORD *)this + 1) + (*((_DWORD *)this + 21) * (v32++ - 1))), *((unsigned int *)this + 21));
      v33 -= 0x100000000;
    }
    while (v32 <= *((_QWORD *)this + 17));
  }
  Security::UnixPlusPlus::FileDesc::seek((Security::UnixPlusPlus::FileDesc *)*((unsigned int *)this + 10), *((_QWORD *)this + 6));
  if (*((_QWORD *)this + 18))
  {
    LODWORD(v34) = 0;
    v35 = *((_QWORD *)this + 7);
    do
    {
      v36 = *((_QWORD *)this + 8);
      if (v36 >= v35)
        v37 = v35;
      else
        v37 = *((_QWORD *)this + 8);
      if (v36)
        v38 = v37;
      else
        v38 = v35;
      v104 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v39 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v103[2] = v39;
      v103[3] = v39;
      v103[0] = v39;
      v103[1] = v39;
      v40 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)*((unsigned int *)this
                                                                                                  + 19));
      Security::Mutex::Mutex((pthread_mutex_t *)((char *)v103 + 8));
      v41 = (unsigned int *)((char *)v40 + 8);
      do
        v42 = __ldxr(v41);
      while (__stxr(v42 + 1, v41));
      *(_QWORD *)&v103[0] = v40;
      v43 = *((_BYTE *)this + 44);
      v44 = *((_QWORD *)this + 29);
      v45 = *(_DWORD *)(v44 + 16);
      v46 = *(unsigned __int8 *)(v44 + 36);
      v101 = *((_DWORD *)this + 10);
      v102 = v43;
      v100[0] = MEMORY[0x1E0C809B0];
      v100[1] = 0x40000000;
      v100[2] = ___ZN8Security11CodeSigning12hashFileDataINS_11DynamicHashEEEmNS_12UnixPlusPlus8FileDescEPT_m_block_invoke;
      v100[3] = &__block_descriptor_tmp_36_13803;
      v100[4] = v40;
      Security::CodeSigning::scanFileData(&v101, v38, (uint64_t)v100);
      (*(void (**)(Security::CCHashInstance *, uint64_t))(*(_QWORD *)v40 + 32))(v40, bswap32(v45) + v44 + v46 * (uint64_t)(int)v34);
      if (*((_BYTE *)this + 192) && !*((_QWORD *)this + 27))
      {
        v47 = *((_QWORD *)this + 29);
        if (bswap32(*(_DWORD *)(v47 + 8)) > 0x204FF && (v48 = *(_DWORD *)(v47 + 92)) != 0)
          v49 = (void *)(bswap32(v48) + v47 + *(unsigned __int8 *)(v47 + 36) * (uint64_t)(int)v34);
        else
          v49 = 0;
        memcpy(v49, (const void *)(bswap32(*(_DWORD *)(v47 + 16)) + v47 + *(unsigned __int8 *)(v47 + 36) * (uint64_t)(int)v34), *(unsigned __int8 *)(v47 + 36));
      }
      v35 -= v38;
      Security::RefPointer<Security::DynamicHash>::~RefPointer(v103);
      v34 = (v34 + 1);
    }
    while (*((_QWORD *)this + 18) > v34);
  }
  v51 = (char *)this + 208;
  v50 = (char *)*((_QWORD *)this + 26);
  if (!v50)
    return *((_QWORD *)this + 29);
  v52 = *((_DWORD *)this + 19);
  v53 = (char *)this + 208;
  do
  {
    v54 = *((_DWORD *)v50 + 8);
    v55 = v54 >= v52;
    if (v54 >= v52)
      v56 = (char **)v50;
    else
      v56 = (char **)(v50 + 8);
    if (v55)
      v53 = v50;
    v50 = *v56;
  }
  while (*v56);
  if (v53 == v51 || v52 < *((_DWORD *)v53 + 8))
    return *((_QWORD *)this + 29);
  v57 = *((_QWORD *)this + 29);
  if (bswap32(*(_DWORD *)(v57 + 8)) <= 0x204FF)
  {
    v60 = 0;
  }
  else
  {
    v58 = *(_DWORD *)(v57 + 92);
    v59 = bswap32(v58) + v57;
    v60 = v58 ? (void *)v59 : 0;
  }
  BytePtr = CFDataGetBytePtr(*((CFDataRef *)v53 + 5));
  memcpy(v60, BytePtr, *((_QWORD *)this + 18) * *((unsigned int *)this + 21));
  v62 = (char *)*((_QWORD *)this + 26);
  if (!v62)
    return *((_QWORD *)this + 29);
  v63 = *((_DWORD *)v53 + 8);
  v64 = (char *)this + 208;
  v65 = (char *)*((_QWORD *)this + 26);
  do
  {
    v66 = *((_DWORD *)v65 + 8);
    v67 = v66 >= v63;
    if (v66 >= v63)
      v68 = (char **)v65;
    else
      v68 = (char **)(v65 + 8);
    if (v67)
      v64 = v65;
    v65 = *v68;
  }
  while (*v68);
  if (v64 == v51 || v63 < *((_DWORD *)v64 + 8))
    return *((_QWORD *)this + 29);
  v69 = (char *)*((_QWORD *)v64 + 1);
  if (v69)
  {
    do
    {
      v70 = v69;
      v69 = *(char **)v69;
    }
    while (v69);
  }
  else
  {
    v71 = v64;
    do
    {
      v70 = (char *)*((_QWORD *)v71 + 2);
      v91 = *(_QWORD *)v70 == (_QWORD)v71;
      v71 = v70;
    }
    while (!v91);
  }
  if (*((char **)this + 25) == v64)
    *((_QWORD *)this + 25) = v70;
  --*((_QWORD *)this + 27);
  v72 = *(_QWORD *)v64;
  v73 = v64;
  if (*(_QWORD *)v64)
  {
    v74 = (char *)*((_QWORD *)v64 + 1);
    if (!v74)
    {
      v73 = v64;
      goto LABEL_119;
    }
    do
    {
      v73 = v74;
      v74 = *(char **)v74;
    }
    while (v74);
  }
  v72 = *((_QWORD *)v73 + 1);
  if (v72)
  {
LABEL_119:
    v75 = 0;
    *(_QWORD *)(v72 + 16) = *((_QWORD *)v73 + 2);
    goto LABEL_120;
  }
  v75 = 1;
LABEL_120:
  v76 = (char **)*((_QWORD *)v73 + 2);
  v77 = *v76;
  if (*v76 == v73)
  {
    *v76 = (char *)v72;
    if (v73 == v62)
    {
      v77 = 0;
      v62 = (char *)v72;
    }
    else
    {
      v77 = v76[1];
    }
  }
  else
  {
    v76[1] = (char *)v72;
  }
  v78 = v73[24];
  if (v73 != v64)
  {
    v79 = *((_QWORD *)v64 + 2);
    *((_QWORD *)v73 + 2) = v79;
    *(_QWORD *)(v79 + 8 * (**((_QWORD **)v64 + 2) != (_QWORD)v64)) = v73;
    v80 = *(_QWORD *)v64;
    *(_QWORD *)v73 = *(_QWORD *)v64;
    *(_QWORD *)(v80 + 16) = v73;
    v81 = *((_QWORD *)v64 + 1);
    *((_QWORD *)v73 + 1) = v81;
    if (v81)
      *(_QWORD *)(v81 + 16) = v73;
    v73[24] = v64[24];
    if (v62 == v64)
      v62 = v73;
  }
  if (!v78 || !v62)
    goto LABEL_184;
  if (!v75)
  {
    *(_BYTE *)(v72 + 24) = 1;
    goto LABEL_184;
  }
  while (1)
  {
    v82 = *((_QWORD *)v77 + 2);
    if (*(char **)v82 != v77)
      break;
    if (!v77[24])
    {
      v77[24] = 1;
      *(_BYTE *)(v82 + 24) = 0;
      v88 = *((_QWORD *)v77 + 1);
      *(_QWORD *)v82 = v88;
      if (v88)
        *(_QWORD *)(v88 + 16) = v82;
      *((_QWORD *)v77 + 2) = *(_QWORD *)(v82 + 16);
      *(_QWORD *)(*(_QWORD *)(v82 + 16) + 8 * (**(_QWORD **)(v82 + 16) != v82)) = v77;
      *((_QWORD *)v77 + 1) = v82;
      *(_QWORD *)(v82 + 16) = v77;
      if (v62 == (char *)v82)
        v62 = v77;
      v77 = *(char **)v82;
    }
    v89 = *(char **)v77;
    if (*(_QWORD *)v77 && !v89[24])
      goto LABEL_179;
    v90 = (char *)*((_QWORD *)v77 + 1);
    if (v90 && !v90[24])
    {
      if (v89 && !v89[24])
      {
LABEL_179:
        v90 = v77;
      }
      else
      {
        v90[24] = 1;
        v77[24] = 0;
        v96 = *(_QWORD *)v90;
        *((_QWORD *)v77 + 1) = *(_QWORD *)v90;
        if (v96)
          *(_QWORD *)(v96 + 16) = v77;
        *((_QWORD *)v90 + 2) = *((_QWORD *)v77 + 2);
        *(_QWORD *)(*((_QWORD *)v77 + 2) + 8 * (**((_QWORD **)v77 + 2) != (_QWORD)v77)) = v90;
        *(_QWORD *)v90 = v77;
        *((_QWORD *)v77 + 2) = v90;
        v89 = v77;
      }
      v93 = *((_QWORD *)v90 + 2);
      v90[24] = *(_BYTE *)(v93 + 24);
      *(_BYTE *)(v93 + 24) = 1;
      v89[24] = 1;
      v94 = *(uint64_t **)v93;
      v97 = *(_QWORD *)(*(_QWORD *)v93 + 8);
      *(_QWORD *)v93 = v97;
      if (v97)
        *(_QWORD *)(v97 + 16) = v93;
      v94[2] = *(_QWORD *)(v93 + 16);
      *(_QWORD *)(*(_QWORD *)(v93 + 16) + 8 * (**(_QWORD **)(v93 + 16) != v93)) = v94;
      v94[1] = v93;
      goto LABEL_183;
    }
    v77[24] = 0;
    v87 = (char *)*((_QWORD *)v77 + 2);
    if (v87[24])
      v91 = v87 == v62;
    else
      v91 = 1;
    if (v91)
      goto LABEL_164;
LABEL_161:
    v77 = *(char **)(*((_QWORD *)v87 + 2) + 8 * (**((_QWORD **)v87 + 2) == (_QWORD)v87));
  }
  if (!v77[24])
  {
    v77[24] = 1;
    *(_BYTE *)(v82 + 24) = 0;
    v83 = *(uint64_t **)(v82 + 8);
    v84 = *v83;
    *(_QWORD *)(v82 + 8) = *v83;
    if (v84)
      *(_QWORD *)(v84 + 16) = v82;
    v83[2] = *(_QWORD *)(v82 + 16);
    *(_QWORD *)(*(_QWORD *)(v82 + 16) + 8 * (**(_QWORD **)(v82 + 16) != v82)) = v83;
    *v83 = v82;
    *(_QWORD *)(v82 + 16) = v83;
    if (v62 == *(char **)v77)
      v62 = v77;
    v77 = *(char **)(*(_QWORD *)v77 + 8);
  }
  v85 = *(char **)v77;
  if (!*(_QWORD *)v77 || v85[24])
  {
    v86 = (char *)*((_QWORD *)v77 + 1);
    if (v86 && !v86[24])
      goto LABEL_170;
    v77[24] = 0;
    v87 = (char *)*((_QWORD *)v77 + 2);
    if (v87 == v62)
    {
      v87 = v62;
LABEL_164:
      v87[24] = 1;
      goto LABEL_184;
    }
    if (!v87[24])
      goto LABEL_164;
    goto LABEL_161;
  }
  v86 = (char *)*((_QWORD *)v77 + 1);
  if (v86 && !v86[24])
  {
LABEL_170:
    v85 = v77;
  }
  else
  {
    v85[24] = 1;
    v77[24] = 0;
    v92 = *((_QWORD *)v85 + 1);
    *(_QWORD *)v77 = v92;
    if (v92)
      *(_QWORD *)(v92 + 16) = v77;
    *((_QWORD *)v85 + 2) = *((_QWORD *)v77 + 2);
    *(_QWORD *)(*((_QWORD *)v77 + 2) + 8 * (**((_QWORD **)v77 + 2) != (_QWORD)v77)) = v85;
    *((_QWORD *)v85 + 1) = v77;
    *((_QWORD *)v77 + 2) = v85;
    v86 = v77;
  }
  v93 = *((_QWORD *)v85 + 2);
  v85[24] = *(_BYTE *)(v93 + 24);
  *(_BYTE *)(v93 + 24) = 1;
  v86[24] = 1;
  v94 = *(uint64_t **)(v93 + 8);
  v95 = *v94;
  *(_QWORD *)(v93 + 8) = *v94;
  if (v95)
    *(_QWORD *)(v95 + 16) = v93;
  v94[2] = *(_QWORD *)(v93 + 16);
  *(_QWORD *)(*(_QWORD *)(v93 + 16) + 8 * (**(_QWORD **)(v93 + 16) != v93)) = v94;
  *v94 = v93;
LABEL_183:
  *(_QWORD *)(v93 + 16) = v94;
LABEL_184:
  Security::CFRef<__CFData const*>::~CFRef((const void **)v64 + 5);
  operator delete(v64);
  return *((_QWORD *)this + 29);
}

void sub_18AA2D914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  Security::RefPointer<Security::DynamicHash>::~RefPointer((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN8Security11CodeSigning12hashFileDataINS_11DynamicHashEEEmNS_12UnixPlusPlus8FileDescEPT_m_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
}

void Security::CodeSigning::scanFileData(int *a1, size_t a2, uint64_t a3)
{
  timespec v6;
  size_t st_blksize;
  void *v8;
  size_t v9;
  size_t v11;
  ssize_t v12;
  ssize_t v13;
  NSObject *v14;
  int v15;
  int *v16;
  stat v17;
  uint8_t buf[4];
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v17.st_blksize = v6;
  *(timespec *)v17.st_qspare = v6;
  v17.st_birthtimespec = v6;
  *(timespec *)&v17.st_size = v6;
  v17.st_mtimespec = v6;
  v17.st_ctimespec = v6;
  *(timespec *)&v17.st_uid = v6;
  v17.st_atimespec = v6;
  *(timespec *)&v17.st_dev = v6;
  Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)*a1, &v17);
  if (v17.st_blksize <= 0x10000)
    st_blksize = 0x10000;
  else
    st_blksize = v17.st_blksize;
  v8 = malloc_type_valloc(st_blksize, 0x261F55AFuLL);
  if (v8)
  {
    while (1)
    {
      v9 = a2;
      if (a2 >= st_blksize || a2 == 0)
        v11 = st_blksize;
      else
        v11 = a2;
      v12 = read(*a1, v8, v11);
      v13 = v12;
      if (v12 == -1)
      {
        if (*__error() != 35)
        {
          v16 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v16);
        }
      }
      else
      {
        if (v12)
          goto LABEL_17;
        *((_BYTE *)a1 + 4) = 1;
        v14 = secLogObjForScope("unixio");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          v15 = *a1;
          *(_DWORD *)buf = 67109120;
          v19 = v15;
          _os_log_debug_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEBUG, "%d end of data", buf, 8u);
        }
      }
      v13 = 0;
LABEL_17:
      if (!*((_BYTE *)a1 + 4))
      {
        (*(void (**)(uint64_t, void *, ssize_t))(a3 + 16))(a3, v8, v13);
        a2 = 0;
        if (!v9)
          continue;
        a2 = v9 - v13;
        if (v9 != v13)
          continue;
      }
      free(v8);
      return;
    }
  }
}

void sub_18AA2DAF8(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_18AA2DB34(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_18AA2DB40(void *a1, int a2)
{
  if (!a2)
    JUMPOUT(0x18AA2DB48);
  __clang_call_terminate(a1);
}

void Security::CodeSigning::CodeDirectory::multipleHashFileData(uint64_t a1, size_t a2, _QWORD *a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *v6;
  Security::CodeSigning::CodeDirectory *v7;
  int *v8;
  int v9;
  int v10;
  BOOL v11;
  Security::CCHashInstance *v12;
  uint64_t *v13;
  uint64_t **v14;
  uint64_t **v15;
  unsigned int v16;
  unsigned int v17;
  _QWORD *v18;
  Security::UnixError *v19;
  unsigned int *v20;
  unsigned int v21;
  uint64_t *v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t *v26;
  _QWORD *v27;
  _QWORD *v28;
  Security *v29;
  uint64_t **v30;
  uint64_t *v31;
  uint64_t **v32;
  _QWORD v35[4];
  _QWORD *v36[3];
  int v37;
  char v38;
  uint64_t **v39;
  uint64_t *v40;
  uint64_t v41;
  CFMutableDictionaryRef CFMutableDictionary;
  uint64_t **v43;
  unint64_t v44;

  v40 = 0;
  v41 = 0;
  v39 = &v40;
  v6 = a3 + 1;
  v5 = (_QWORD *)*a3;
  if ((_QWORD *)*a3 != a3 + 1)
  {
    do
    {
      v7 = (Security::CodeSigning::CodeDirectory *)*((unsigned int *)v5 + 7);
      v8 = &Security::CodeSigning::hashPriorities;
      do
      {
        v10 = *v8++;
        v9 = v10;
        v11 = v10 == (_DWORD)v7 || v9 == 0;
      }
      while (!v11);
      if (v9)
      {
        v12 = Security::CodeSigning::CodeDirectory::hashFor(v7);
        v13 = v40;
        v14 = &v40;
        v15 = &v40;
        if (v40)
        {
          v16 = *((_DWORD *)v5 + 7);
          while (1)
          {
            while (1)
            {
              v15 = (uint64_t **)v13;
              v17 = *((_DWORD *)v13 + 8);
              if (v16 >= v17)
                break;
              v13 = *v15;
              v14 = v15;
              if (!*v15)
                goto LABEL_17;
            }
            if (v17 >= v16)
              break;
            v13 = v15[1];
            if (!v13)
            {
              v14 = v15 + 1;
              goto LABEL_17;
            }
          }
        }
        else
        {
LABEL_17:
          v44 = 0xAAAAAAAAAAAAAAAALL;
          v18 = operator new(0x70uLL);
          CFMutableDictionary = (CFMutableDictionaryRef)v18;
          v43 = &v40;
          LOBYTE(v44) = 0;
          *((_DWORD *)v18 + 8) = *((_DWORD *)v5 + 7);
          v18[5] = 0;
          Security::Mutex::Mutex((pthread_mutex_t *)(v18 + 6));
          LOBYTE(v44) = 1;
          *v18 = 0;
          v18[1] = 0;
          v18[2] = v15;
          *v14 = v18;
          if (*v39)
          {
            v39 = (uint64_t **)*v39;
            v18 = *v14;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v40, v18);
          v15 = (uint64_t **)CFMutableDictionary;
          ++v41;
          CFMutableDictionary = 0;
          std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>>>>::reset[abi:ne180100]((uint64_t)&CFMutableDictionary);
        }
        CFMutableDictionary = (CFMutableDictionaryRef)(v15 + 6);
        v43 = (uint64_t **)0xAAAAAAAAAAAAAAAALL;
        v19 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(v15 + 6));
        if ((_DWORD)v19)
          Security::UnixError::throwMe(v19);
        LOBYTE(v43) = 1;
        v20 = (unsigned int *)((char *)v12 + 8);
        do
          v21 = __ldxr(v20);
        while (__stxr(v21 + 1, v20));
        v22 = v15[5];
        if (v22)
        {
          v23 = (unsigned int *)(v22 + 1);
          do
          {
            v24 = __ldxr(v23);
            v25 = v24 - 1;
          }
          while (__stxr(v25, v23));
          if (!v25)
          {
            v26 = v15[5];
            if (v26)
              (*(void (**)(uint64_t *))(*v26 + 8))(v26);
          }
        }
        v15[5] = (uint64_t *)v12;
        Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&CFMutableDictionary);
      }
      v27 = (_QWORD *)v5[1];
      if (v27)
      {
        do
        {
          v28 = v27;
          v27 = (_QWORD *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          v28 = (_QWORD *)v5[2];
          v11 = *v28 == (_QWORD)v5;
          v5 = v28;
        }
        while (!v11);
      }
      v5 = v28;
    }
    while (v28 != v6);
  }
  v37 = *(_DWORD *)a1;
  v38 = *(_BYTE *)(a1 + 4);
  v35[0] = MEMORY[0x1E0C809B0];
  v35[1] = 1174405120;
  v35[2] = ___ZN8Security11CodeSigning13CodeDirectory20multipleHashFileDataENS_12UnixPlusPlus8FileDescEmNSt3__13setIjNS4_4lessIjEENS4_9allocatorIjEEEEU13block_pointerFvjPNS_11DynamicHashEE_block_invoke;
  v35[3] = &__block_descriptor_tmp_13809;
  std::map<unsigned int,Security::RefPointer<Security::DynamicHash>>::map[abi:ne180100]((uint64_t)v36, &v39);
  Security::CodeSigning::scanFileData(&v37, a2, (uint64_t)v35);
  CFMutableDictionary = Security::makeCFMutableDictionary(v29);
  v30 = v39;
  if (v39 != &v40)
  {
    do
    {
      (*(void (**)(uint64_t, _QWORD, uint64_t *))(a4 + 16))(a4, *((unsigned int *)v30 + 8), v30[5]);
      v31 = v30[1];
      if (v31)
      {
        do
        {
          v32 = (uint64_t **)v31;
          v31 = (uint64_t *)*v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          v32 = (uint64_t **)v30[2];
          v11 = *v32 == (uint64_t *)v30;
          v30 = v32;
        }
        while (!v11);
      }
      v30 = v32;
    }
    while (v32 != &v40);
  }
  Security::CFRef<__CFDictionary *>::~CFRef((const void **)&CFMutableDictionary);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(v36[1]);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(v40);
}

void sub_18AA2DE28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, _QWORD *a16, uint64_t a17, uint64_t a18, uint64_t a19, _QWORD *a20)
{
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(a16);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(a20);
  _Unwind_Resume(a1);
}

uint64_t ___ZN8Security11CodeSigning13CodeDirectory20multipleHashFileDataENS_12UnixPlusPlus8FileDescEmNSt3__13setIjNS4_4lessIjEENS4_9allocatorIjEEEEU13block_pointerFvjPNS_11DynamicHashEE_block_invoke(uint64_t result, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  v3 = *(_QWORD **)(result + 32);
  v4 = (_QWORD *)(result + 40);
  if (v3 != (_QWORD *)(result + 40))
  {
    do
    {
      result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(*(_QWORD *)v3[5] + 24))(v3[5], a2, a3);
      v7 = (_QWORD *)v3[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v3[2];
          v9 = *v8 == (_QWORD)v3;
          v3 = v8;
        }
        while (!v9);
      }
      v3 = v8;
    }
    while (v8 != v4);
  }
  return result;
}

uint64_t std::map<unsigned int,Security::RefPointer<Security::DynamicHash>>::map[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  uint64_t **v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t **v9;
  BOOL v10;
  unsigned int v11;
  uint64_t **v12;
  uint64_t **v13;
  char *v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  _QWORD *v18;
  _QWORD *v19;
  unsigned int v20;
  _QWORD v22[2];
  unint64_t v23;

  *(_QWORD *)(a1 + 8) = 0;
  v3 = (uint64_t **)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      v6 = *(uint64_t **)(a1 + 8);
      v7 = v3;
      if (*(uint64_t ***)a1 == v3)
        goto LABEL_8;
      v8 = *(_QWORD *)(a1 + 8);
      v9 = v3;
      if (v6)
      {
        do
        {
          v7 = (uint64_t **)v8;
          v8 = *(_QWORD *)(v8 + 8);
        }
        while (v8);
      }
      else
      {
        do
        {
          v7 = (uint64_t **)v9[2];
          v10 = *v7 == (uint64_t *)v9;
          v9 = v7;
        }
        while (v10);
      }
      v11 = *((_DWORD *)v5 + 8);
      if (*((_DWORD *)v7 + 8) < v11)
      {
LABEL_8:
        if (v6)
          v12 = v7;
        else
          v12 = v3;
        if (v6)
          v13 = v7 + 1;
        else
          v13 = v3;
      }
      else
      {
        v12 = v3;
        v13 = v3;
        if (v6)
        {
          v13 = v3;
          while (1)
          {
            while (1)
            {
              v12 = (uint64_t **)v6;
              v20 = *((_DWORD *)v6 + 8);
              if (v11 >= v20)
                break;
              v6 = *v12;
              v13 = v12;
              if (!*v12)
                goto LABEL_15;
            }
            if (v20 >= v11)
              break;
            v13 = v12 + 1;
            v6 = v12[1];
            if (!v6)
              goto LABEL_15;
          }
        }
      }
      if (!*v13)
      {
LABEL_15:
        v23 = 0xAAAAAAAAAAAAAAAALL;
        v14 = (char *)operator new(0x70uLL);
        v22[0] = v14;
        v22[1] = v3;
        LOBYTE(v23) = 0;
        *((_DWORD *)v14 + 8) = *((_DWORD *)v5 + 8);
        Security::Mutex::Mutex((pthread_mutex_t *)(v14 + 48));
        v15 = v5[5];
        if (v15)
        {
          v16 = (unsigned int *)(v15 + 8);
          do
            v17 = __ldxr(v16);
          while (__stxr(v17 + 1, v16));
          v15 = v5[5];
        }
        *((_QWORD *)v14 + 5) = v15;
        LOBYTE(v23) = 1;
        std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v12, v13, (uint64_t *)v14);
        v22[0] = 0;
        std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>>>>::reset[abi:ne180100]((uint64_t)v22);
      }
      v18 = (_QWORD *)v5[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (_QWORD *)v5[2];
          v10 = *v19 == (_QWORD)v5;
          v5 = v19;
        }
        while (!v10);
      }
      v5 = v19;
    }
    while (v19 != v4);
  }
  return a1;
}

void sub_18AA2E0CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  _QWORD **v2;
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(*v2);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(a1[1]);
    Security::RefPointer<Security::DynamicHash>::~RefPointer(a1 + 5);
    operator delete(a1);
  }
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  _QWORD *v1;

  v1 = *(_QWORD **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      Security::RefPointer<Security::DynamicHash>::~RefPointer(v1 + 5);
    operator delete(v1);
  }
}

uint64_t __copy_helper_block_e8_32c106_ZTSNSt3__13mapIjN8Security10RefPointerINS1_11DynamicHashEEENS_4lessIjEENS_9allocatorINS_4pairIKjS4_EEEEEE(uint64_t a1, uint64_t a2)
{
  return std::map<unsigned int,Security::RefPointer<Security::DynamicHash>>::map[abi:ne180100](a1 + 32, (_QWORD *)(a2 + 32));
}

void __destroy_helper_block_e8_32c106_ZTSNSt3__13mapIjN8Security10RefPointerINS1_11DynamicHashEEENS_4lessIjEENS_9allocatorINS_4pairIKjS4_EEEEEE(uint64_t a1)
{
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::DynamicHash>>>>::destroy(*(_QWORD **)(a1 + 40));
}

BOOL Security::DynamicHash::verify(Security::DynamicHash *this, const unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t v5;
  size_t v6;
  uint64_t v7;
  char *v8;
  size_t v9;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  v4 = (*(uint64_t (**)(Security::DynamicHash *))(*(_QWORD *)this + 16))(this);
  v5 = MEMORY[0x1E0C80A78](v4);
  v8 = (char *)v11 - v7;
  if (v5)
    memset((char *)v11 - v7, 170, v6);
  (*(void (**)(Security::DynamicHash *, char *))(*(_QWORD *)this + 32))(this, v8);
  v9 = (*(uint64_t (**)(Security::DynamicHash *))(*(_QWORD *)this + 16))(this);
  return memcmp(v8, a2, v9) == 0;
}

SecTaskRef SecTaskCreateWithXPCMessage(SecTaskRef result)
{
  __int128 v1;
  audit_token_t v2;
  audit_token_t v3;

  *(_QWORD *)&v1 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v3.val = v1;
  *(_OWORD *)&v3.val[4] = v1;
  if (result)
  {
    if (MEMORY[0x18D7718B8]() == MEMORY[0x1E0C812F8])
    {
      xpc_dictionary_get_audit_token();
      v2 = v3;
      return SecTaskCreateWithAuditToken(0, &v2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SecTaskEntitlementsValidated(uint64_t a1)
{
  if (csops_task(a1) == -1)
    return 0;
  else
    return 0;
}

uint64_t SecTaskValidateForLightweightCodeRequirementData(_OWORD *a1, const __CFData *a2, CFErrorRef *a3)
{
  CFTypeID TypeID;
  const UInt8 *BytePtr;
  CFIndex Length;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  CFStringRef v12;
  const __CFString *v13;
  const __CFString *v14;
  int v15;
  _OWORD v17[2];
  unsigned int v18;
  char v19[1024];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  TypeID = SecTaskGetTypeID();
  if (TypeID != CFGetTypeID(a1))
  {
    if (a3)
    {
      v13 = (const __CFString *)*MEMORY[0x1E0C9AFC8];
      v14 = CFSTR("Invalid task reference");
      v15 = -67675;
LABEL_13:
      v11 = 0;
      *a3 = createError(v13, v15, v14);
      return v11;
    }
    return 0;
  }
  if (!a2 || !CFDataGetLength(a2))
  {
    if (a3)
    {
      v13 = (const __CFString *)*MEMORY[0x1E0C9AFC8];
      v14 = CFSTR("Invalid requirement");
      v15 = -50;
      goto LABEL_13;
    }
    return 0;
  }
  bzero(&v18, 0x404uLL);
  BytePtr = CFDataGetBytePtr(a2);
  Length = CFDataGetLength(a2);
  v9 = a1[2];
  v17[0] = a1[1];
  v17[1] = v9;
  v10 = amfi_launch_constraint_matches_process((uint64_t)v17, (uint64_t)BytePtr, Length, (uint64_t)&v18);
  v11 = v10;
  if (a3 && (v10 & 1) == 0)
  {
    v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v19, 0x8000100u);
    if (v18 <= 5)
      *a3 = createError(**((const __CFString ***)&unk_1E1FDC600 + v18), dword_18AA6146C[v18], v12);
    CFRelease(v12);
  }
  return v11;
}

CFErrorRef createError(const __CFString *a1, int a2, const void *a3)
{
  const __CFAllocator *v6;
  __CFDictionary *Mutable;

  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0C9AFB0], a3);
  return CFErrorCreate(v6, a1, a2, Mutable);
}

uint64_t Security::PerThreadPointer<Security::CodeSigning::PerThread>::destructor(uint64_t result)
{
  if (result)
    JUMPOUT(0x18D76FAA0);
  return result;
}

CFTypeID SecCodeGetTypeID(void)
{
  return *(_QWORD *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 96);
}

void sub_18AA2E578(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18AA2E570);
}

OSStatus SecCodeCopySelf(SecCSFlags flags, SecCodeRef *self)
{
  Security *v2;
  void *v3;
  const void *v4;
  const void **v5;
  const __CFDictionary *v6;
  const void *v7;
  __CFDictionary *valuePtr;

  if (!flags)
  {
    LODWORD(valuePtr) = getpid();
    v2 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    valuePtr = Security::makeCFMutableDictionary(v2, v3, v4, CFSTR("pid"), v2, v2);
    v5 = Security::CFRef<__CFNumber const*>::~CFRef(&v7);
    Security::CodeSigning::SecCode::autoLocateGuest((Security::CodeSigning::SecCode *)v5, v6);
  }
  Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
}

uint64_t sub_18AA2E5EC(void *a1, int a2)
{
  _DWORD *v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  unsigned int v9;
  int v10;
  const char *v11;
  const void *v12;

  Security::CFRef<__CFDictionary *>::~CFRef(&v12);
  switch(a2)
  {
    case 6:
      v4 = __cxa_begin_catch(a1);
      if (v4[36] == 8)
      {
        v5 = 4294900247;
        goto LABEL_8;
      }
      goto LABEL_6;
    case 5:
      goto LABEL_5;
    case 4:
      v4 = __cxa_begin_catch(a1);
      v9 = v4[36];
      if (v9 <= 0x1A)
      {
        v5 = 4294900263;
        v10 = 1 << v9;
        if ((v10 & 0x800108) != 0)
          goto LABEL_8;
        if ((v10 & 0x4014000) != 0)
        {
          v5 = 4294900264;
          goto LABEL_8;
        }
      }
LABEL_6:
      v7 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v4 + 24))(v4);
      goto LABEL_7;
    case 3:
LABEL_5:
      v6 = __cxa_begin_catch(a1);
      v7 = (*(uint64_t (**)(void *))(*(_QWORD *)v6 + 24))(v6);
LABEL_7:
      v5 = v7;
      goto LABEL_8;
  }
  __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    v5 = 4294967188;
  }
  else
  {
    Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v11);
    v5 = 4294900248;
  }
LABEL_8:
  __cxa_end_catch();
  return v5;
}

void sub_18AA2E73C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t SecCodeGetStatus(Security::CodeSigning::SecCode *a1, __SecCode *a2, int *a3)
{
  uint64_t v4;
  int v5;
  uint64_t v7;

  if ((_DWORD)a2)
  {
    v7 = 4294900226;
LABEL_8:
    Security::MacOSError::throwMe((Security::MacOSError *)v7);
  }
  v4 = *((_QWORD *)Security::CodeSigning::SecCode::required(a1, a2) + 2);
  if (!v4)
  {
    v5 = 1;
    if (a3)
      goto LABEL_4;
    goto LABEL_6;
  }
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 104))(v4);
  if (!a3)
  {
LABEL_6:
    v7 = 4294900227;
    goto LABEL_8;
  }
LABEL_4:
  *a3 = v5;
  return 0;
}

void *Security::CodeSigning::SecCode::required(Security::CodeSigning::SecCode *this, __SecCode *a2)
{
  void *result;

  if (!this
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  return result;
}

uint64_t SecCodeSetStatus(Security::CodeSigning::SecCode *a1, __SecCode *a2, uint64_t a3, int a4)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v9;

  if (a4)
  {
    v9 = 4294900226;
    goto LABEL_6;
  }
  v6 = Security::CodeSigning::SecCode::required(a1, a2);
  v7 = v6[2];
  if (!v7)
  {
    v9 = 4294900256;
LABEL_6:
    Security::MacOSError::throwMe((Security::MacOSError *)v9);
  }
  (*(void (**)(uint64_t, _QWORD *, __SecCode *, uint64_t))(*(_QWORD *)v7 + 112))(v7, v6, a2, a3);
  return 0;
}

OSStatus SecCodeCopyStaticCode(SecCodeRef code, SecCSFlags flags, SecStaticCodeRef *staticCode)
{
  _BYTE *v5;
  _BYTE *v6;
  Security::SecCFObject *v7;
  unsigned __int8 *v8;
  unsigned __int8 v9;
  const void *v10;
  uint64_t v11;
  __int128 v12;
  char *v13;
  Security::CodeSigning::DiskRep *v14;
  unsigned int *v15;
  unsigned int v16;
  uint64_t v17;
  const Security::CFClass *v18;
  Security::CodeSigning::SecStaticCode *v19;
  unsigned __int8 *v20;
  unsigned __int8 v21;
  const void *v22;
  const void *v23;
  const __SecCode *v24;
  void *__p[2];
  char v27;
  Security::SecCFObject *v28;
  Security::CodeSigning::DiskRep *v29[2];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (flags >= 2)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v28 = (Security::SecCFObject *)0xAAAAAAAAAAAAAAAALL;
  v5 = Security::CodeSigning::SecCode::required(code, *(__SecCode **)&flags);
  v6 = v5;
  if (!v5[24])
  {
    (*(void (**)(_BYTE *))(*(_QWORD *)v5 + 80))(v5);
    v6[24] = 1;
  }
  v7 = (Security::SecCFObject *)*((_QWORD *)v6 + 4);
  if (v7)
  {
    v8 = (unsigned __int8 *)v7 - 8;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(1u, v8));
    if ((v9 & 1) != 0)
    {
      v10 = (const void *)(*(uint64_t (**)(Security::SecCFObject *))(*(_QWORD *)v7 + 16))(v7);
      CFRetain(v10);
    }
  }
  v28 = v7;
  if (flags)
  {
    v11 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)v7 + 4) + 80))(*((_QWORD *)v7 + 4));
    if (v11 && *(_QWORD *)(v11 + 32))
    {
      v33 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v12 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v31 = v12;
      v32 = v12;
      *(_OWORD *)v29 = v12;
      v30 = v12;
      (*(void (**)(void **__return_ptr))(**((_QWORD **)v28 + 4) + 40))(__p);
      if (v27 >= 0)
        v13 = (char *)__p;
      else
        v13 = (char *)__p[0];
      v14 = (Security::CodeSigning::DiskRep *)Security::CodeSigning::DiskRep::bestGuess(v13, 0);
      Security::Mutex::Mutex((pthread_mutex_t *)&v29[1]);
      if (v14)
      {
        v15 = (unsigned int *)((char *)v14 + 8);
        do
          v16 = __ldxr(v15);
        while (__stxr(v16 + 1, v15));
      }
      v29[0] = v14;
      if (v27 < 0)
        operator delete(__p[0]);
      v17 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
      v19 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate((Security::SecCFObject *)0x288, *(_QWORD *)(v17 + 200), v18);
      Security::CodeSigning::SecStaticCode::SecStaticCode(v19, v29[0], 0);
      v20 = (unsigned __int8 *)v19 - 8;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(1u, v20));
      if ((v21 & 1) != 0)
      {
        v22 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)v19 + 16))(v19);
        CFRetain(v22);
      }
      if (v28)
      {
        v23 = (const void *)(*(uint64_t (**)(Security::SecCFObject *))(*(_QWORD *)v28 + 16))(v28);
        CFRelease(v23);
      }
      v28 = v19;
      Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(v29);
    }
    v7 = v28;
  }
  if (!v7)
  {
    v24 = 0;
    if (staticCode)
      goto LABEL_30;
LABEL_32:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  }
  v24 = (const __SecCode *)Security::SecCFObject::handle(v7, 1);
  if (!staticCode)
    goto LABEL_32;
LABEL_30:
  *staticCode = v24;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v28);
  return 0;
}

void sub_18AA2ED50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, uint64_t a17)
{
  char *v17;
  _DWORD *v20;
  void *v21;
  unsigned int v22;
  int v23;
  const char *v24;

  if (!a2)
    _Unwind_Resume(exception_object);
  Security::SecCFObject::operator delete(v17);
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(&a17);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a15);
  if (a2 == 6)
  {
    v20 = __cxa_begin_catch(exception_object);
    if (v20[36] == 8)
      goto LABEL_17;
    goto LABEL_16;
  }
  if (a2 != 5)
  {
    if (a2 == 4)
    {
      v20 = __cxa_begin_catch(exception_object);
      v22 = v20[36];
      if (v22 <= 0x1A)
      {
        v23 = 1 << v22;
        if ((v23 & 0x800108) != 0 || (v23 & 0x4014000) != 0)
          goto LABEL_17;
      }
LABEL_16:
      (*(void (**)(_DWORD *))(*(_QWORD *)v20 + 24))(v20);
LABEL_17:
      __cxa_end_catch();
LABEL_19:
      JUMPOUT(0x18AA2ECF4);
    }
    if (a2 != 3)
    {
      __cxa_begin_catch(exception_object);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v24);
      goto LABEL_17;
    }
  }
  v21 = __cxa_begin_catch(exception_object);
  (*(void (**)(void *))(*(_QWORD *)v21 + 24))(v21);
  __cxa_end_catch();
  goto LABEL_19;
}

OSStatus SecCodeCopyHost(SecCodeRef guest, SecCSFlags flags, SecCodeRef *host)
{
  Security::SecCFObject *v4;
  unsigned __int8 *v5;
  unsigned __int8 v6;
  const void *v7;
  __SecCode *v8;
  unint64_t v10;

  if (flags)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v10 = 0xAAAAAAAAAAAAAAAALL;
  v4 = (Security::SecCFObject *)*((_QWORD *)Security::CodeSigning::SecCode::required(guest, *(__SecCode **)&flags) + 2);
  if (!v4)
  {
    v8 = 0;
    v10 = 0;
    if (host)
      goto LABEL_8;
LABEL_10:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  }
  v5 = (unsigned __int8 *)v4 - 8;
  do
    v6 = __ldaxr(v5);
  while (__stlxr(1u, v5));
  if ((v6 & 1) != 0)
  {
    v7 = (const void *)(*(uint64_t (**)(Security::SecCFObject *))(*(_QWORD *)v4 + 16))(v4);
    CFRetain(v7);
  }
  v10 = (unint64_t)v4;
  v8 = (__SecCode *)Security::SecCFObject::handle(v4, 1);
  if (!host)
    goto LABEL_10;
LABEL_8:
  *host = v8;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v10);
  return 0;
}

void sub_18AA2F028(void *a1, int a2, uint64_t a3, ...)
{
  _DWORD *v5;
  void *v6;
  unsigned int v7;
  int v8;
  const char *v9;
  va_list va;

  va_start(va, a3);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)va);
  switch(a2)
  {
    case 6:
      v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8)
        break;
LABEL_6:
      (*(void (**)(_DWORD *))(*(_QWORD *)v5 + 24))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      v5 = __cxa_begin_catch(a1);
      v7 = v5[36];
      if (v7 > 0x1A)
        goto LABEL_6;
      v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0)
        goto LABEL_6;
      break;
    case 3:
LABEL_5:
      v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v6 + 24))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA2EFECLL);
}

void sub_18AA2F160(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

OSStatus SecCodeCheckValidity(SecCodeRef code, SecCSFlags flags, SecRequirementRef requirement)
{
  return SecCodeCheckValidityWithErrors(code, flags, requirement, 0);
}

OSStatus SecCodeCheckValidityWithErrors(SecCodeRef code, SecCSFlags flags, SecRequirementRef requirement, CFErrorRef *errors)
{
  uint64_t v5;
  Security::CodeSigning::SecCode *v6;
  Security::CodeSigning::SecCode *v7;
  unsigned __int8 *v8;
  unsigned __int8 v9;
  const void *v10;
  __SecRequirement *v11;
  char *v12;
  unint64_t v13;
  unint64_t v15;

  if ((flags & 0x1F7EDDEF) != 0)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v5 = *(_QWORD *)&flags;
  v15 = 0xAAAAAAAAAAAAAAAALL;
  v6 = (Security::CodeSigning::SecCode *)Security::CodeSigning::SecCode::required(code, *(__SecCode **)&flags);
  v7 = v6;
  if (v6)
  {
    v8 = (unsigned __int8 *)v6 - 8;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(1u, v8));
    if ((v9 & 1) != 0)
    {
      v10 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecCode *))(*(_QWORD *)v6 + 16))(v6);
      CFRetain(v10);
    }
  }
  v15 = (unint64_t)v7;
  Security::CodeSigning::SecCode::checkValidity(v7, v5);
  v12 = Security::CodeSigning::SecRequirement::optional((char *)requirement, v11);
  if (v12)
  {
    v13 = v15;
    if ((v5 & 0x800000) != 0)
    {
      (*(void (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(v15 + 16) + 120))(*(_QWORD *)(v15 + 16), v15, *((_QWORD *)v12 + 2));
    }
    else
    {
      if (!*(_BYTE *)(v15 + 24))
      {
        (*(void (**)(unint64_t))(*(_QWORD *)v15 + 80))(v15);
        *(_BYTE *)(v15 + 24) = 1;
      }
      if (!Security::CodeSigning::SecStaticCode::satisfiesRequirement(*(_QWORD *)(v13 + 32), *((Security::CodeSigning::Requirement **)v12 + 2)))Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA16);
    }
  }
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v15);
  return 0;
}

void sub_18AA2F2D8(void *a1, int a2, uint64_t a3, ...)
{
  __CFError **v3;
  CFDictionaryRef *v6;
  _DWORD *v7;
  int v8;
  void *v9;
  int v10;
  CFErrorRef v11;
  _DWORD *v12;
  unsigned int v13;
  int v14;
  void *v15;
  int v16;
  const char *v17;
  va_list va;

  va_start(va, a3);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)va);
  switch(a2)
  {
    case 7:
      v6 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v6, v3);
      goto LABEL_32;
    case 6:
      v7 = __cxa_begin_catch(a1);
      if (v7[36] == 8)
        v8 = -67049;
      else
        v8 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v7 + 24))(v7);
      if (v3)
      {
LABEL_30:
        v11 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v8, 0);
        goto LABEL_31;
      }
LABEL_32:
      __cxa_end_catch();
      JUMPOUT(0x18AA2F2B0);
    case 5:
      v9 = __cxa_begin_catch(a1);
      v10 = (*(uint64_t (**)(void *))(*(_QWORD *)v9 + 24))(v9);
      if (!v3)
        goto LABEL_32;
      v11 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v10, 0);
LABEL_31:
      *v3 = v11;
      goto LABEL_32;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      v15 = __cxa_begin_catch(a1);
      v16 = (*(uint64_t (**)(void *))(*(_QWORD *)v15 + 24))(v15);
      if (v3)
        *v3 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v16, 0);
    }
    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v3)
          *v3 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -108, 0);
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v17);
        if (v3)
          *v3 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -67048, 0);
      }
    }
    goto LABEL_32;
  }
  v12 = __cxa_begin_catch(a1);
  v13 = v12[36];
  if (v13 > 0x1A)
    goto LABEL_28;
  v8 = -67033;
  v14 = 1 << v13;
  if ((v14 & 0x800108) != 0)
    goto LABEL_29;
  if ((v14 & 0x4014000) != 0)
    v8 = -67032;
  else
LABEL_28:
    v8 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v12 + 24))(v12);
LABEL_29:
  if (!v3)
    goto LABEL_32;
  goto LABEL_30;
}

void sub_18AA2F518(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

CFTypeID SecStaticCodeGetTypeID(void)
{
  return *(_QWORD *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 200);
}

void sub_18AA2F58C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18AA2F584);
}

OSStatus SecStaticCodeCreateWithPath(CFURLRef path, SecCSFlags flags, SecStaticCodeRef *staticCode)
{
  uint64_t v6;
  const Security::CFClass *v7;
  Security::CodeSigning::SecStaticCode *v8;
  char *v9;
  Security::CodeSigning::DiskRep *v10;
  const __SecCode *v11;
  void *__p[2];
  char v14;

  if (flags >= 2)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v6 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  v8 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate((Security::SecCFObject *)0x288, *(_QWORD *)(v6 + 200), v7);
  Security::cfString((Security *)__p, path);
  if (v14 >= 0)
    v9 = (char *)__p;
  else
    v9 = (char *)__p[0];
  v10 = (Security::CodeSigning::DiskRep *)Security::CodeSigning::DiskRep::bestGuess(v9, 0);
  Security::CodeSigning::SecStaticCode::SecStaticCode(v8, v10, flags);
  v11 = (const __SecCode *)Security::SecCFObject::handle(v8, 1);
  if (!staticCode)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  *staticCode = v11;
  if (v14 < 0)
    operator delete(__p[0]);
  return 0;
}

void sub_18AA2F680(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  char *v15;
  _DWORD *v18;
  void *v19;
  unsigned int v20;
  int v21;
  const char *v22;

  Security::SecCFObject::operator delete(v15);
  switch(a2)
  {
    case 6:
      v18 = __cxa_begin_catch(a1);
      if (v18[36] == 8)
        break;
LABEL_6:
      (*(void (**)(_DWORD *))(*(_QWORD *)v18 + 24))(v18);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      v18 = __cxa_begin_catch(a1);
      v20 = v18[36];
      if (v20 > 0x1A)
        goto LABEL_6;
      v21 = 1 << v20;
      if ((v21 & 0x800108) == 0 && (v21 & 0x4014000) == 0)
        goto LABEL_6;
      break;
    case 3:
LABEL_5:
      v19 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v19 + 24))(v19);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v22);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA2F640);
}

void sub_18AA2F7D8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

OSStatus SecStaticCodeCheckValidity(SecStaticCodeRef staticCode, SecCSFlags flags, SecRequirementRef requirement)
{
  return SecStaticCodeCheckValidityWithErrors(staticCode, flags, requirement, 0);
}

uint64_t SecStaticCodeValidateResourceWithErrors(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, int a3)
{
  Security::CodeSigning::SecStaticCode *v5;
  Security::CodeSigning::SecStaticCode *v6;
  unsigned __int8 *v7;
  unsigned __int8 v8;
  const void *v9;
  void *__p[2];
  char v12;
  unint64_t v13;

  if ((a3 & 0x1FFC9DAE) != 0)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v13 = 0xAAAAAAAAAAAAAAAALL;
  v5 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  v6 = v5;
  if (v5)
  {
    v7 = (unsigned __int8 *)v5 - 8;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(1u, v7));
    if ((v8 & 1) != 0)
    {
      v9 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)v5 + 16))(v5);
      CFRetain(v9);
    }
  }
  v13 = (unint64_t)v6;
  *((_DWORD *)v6 + 52) = a3;
  Security::cfString((Security *)__p, a2);
  Security::CodeSigning::SecStaticCode::staticValidateResource(v6, (std::string::size_type)__p, a3, 0);
  if (v12 < 0)
    operator delete(__p[0]);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v13);
  return 0;
}

void sub_18AA2F900(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  __CFError **v15;
  CFDictionaryRef *v18;
  _DWORD *v19;
  int v20;
  void *v21;
  int v22;
  CFErrorRef v23;
  _DWORD *v24;
  unsigned int v25;
  int v26;
  void *v27;
  int v28;
  const char *v29;

  if (a14 < 0)
    operator delete(__p);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a15);
  switch(a2)
  {
    case 7:
      v18 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v18, v15);
      goto LABEL_34;
    case 6:
      v19 = __cxa_begin_catch(a1);
      if (v19[36] == 8)
        v20 = -67049;
      else
        v20 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v19 + 24))(v19);
      if (v15)
      {
LABEL_32:
        v23 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v20, 0);
        goto LABEL_33;
      }
LABEL_34:
      __cxa_end_catch();
      JUMPOUT(0x18AA2F8D8);
    case 5:
      v21 = __cxa_begin_catch(a1);
      v22 = (*(uint64_t (**)(void *))(*(_QWORD *)v21 + 24))(v21);
      if (!v15)
        goto LABEL_34;
      v23 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v22, 0);
LABEL_33:
      *v15 = v23;
      goto LABEL_34;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      v27 = __cxa_begin_catch(a1);
      v28 = (*(uint64_t (**)(void *))(*(_QWORD *)v27 + 24))(v27);
      if (v15)
        *v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v28, 0);
    }
    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v15)
          *v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -108, 0);
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v29);
        if (v15)
          *v15 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -67048, 0);
      }
    }
    goto LABEL_34;
  }
  v24 = __cxa_begin_catch(a1);
  v25 = v24[36];
  if (v25 > 0x1A)
    goto LABEL_30;
  v20 = -67033;
  v26 = 1 << v25;
  if ((v26 & 0x800108) != 0)
    goto LABEL_31;
  if ((v26 & 0x4014000) != 0)
    v20 = -67032;
  else
LABEL_30:
    v20 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v24 + 24))(v24);
LABEL_31:
  if (!v15)
    goto LABEL_34;
  goto LABEL_32;
}

void sub_18AA2FB58(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

OSStatus SecCodeCopyPath(SecStaticCodeRef staticCode, SecCSFlags flags, CFURLRef *path)
{
  char *v4;
  char *v5;
  unsigned __int8 *v6;
  unsigned __int8 v7;
  const void *v8;
  const __CFURL *v9;
  unint64_t v11;

  if (flags)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v11 = 0xAAAAAAAAAAAAAAAALL;
  v4 = (char *)Security::CodeSigning::SecStaticCode::requiredStatic(staticCode, *(const __SecCode **)&flags);
  v5 = v4;
  if (v4)
  {
    v6 = (unsigned __int8 *)(v4 - 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(1u, v6));
    if ((v7 & 1) != 0)
    {
      v8 = (const void *)(*(uint64_t (**)(char *))(*(_QWORD *)v4 + 16))(v4);
      CFRetain(v8);
    }
  }
  v11 = (unint64_t)v5;
  v9 = (const __CFURL *)(*(uint64_t (**)(_QWORD *))(**((_QWORD **)v5 + 4) + 48))(*((_QWORD **)v5 + 4));
  if (!path)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  *path = v9;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v11);
  return 0;
}

void sub_18AA2FC64(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  _DWORD *v11;
  void *v12;
  unsigned int v13;
  int v14;
  const char *v15;

  switch(a2)
  {
    case 6:
      v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8)
        break;
LABEL_6:
      (*(void (**)(_DWORD *))(*(_QWORD *)v11 + 24))(v11);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      v11 = __cxa_begin_catch(a1);
      v13 = v11[36];
      if (v13 > 0x1A)
        goto LABEL_6;
      v14 = 1 << v13;
      if ((v14 & 0x800108) == 0 && (v14 & 0x4014000) == 0)
        goto LABEL_6;
      break;
    case 3:
LABEL_5:
      v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v12 + 24))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA2FC34);
}

void sub_18AA2FD9C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

OSStatus SecCodeCopyDesignatedRequirement(SecStaticCodeRef code, SecCSFlags flags, SecRequirementRef *requirement)
{
  Security::CodeSigning::SecStaticCode *v4;
  unsigned int *v5;
  uint64_t v6;
  const Security::CFClass *v7;
  Security::SecCFObject *v8;
  __SecRequirement *v9;
  __SecRequirement *v10;
  OSStatus result;

  if (flags)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v4 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(code, *(const __SecCode **)&flags);
  v5 = (unsigned int *)Security::CodeSigning::SecStaticCode::designatedRequirement(v4);
  v6 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  v8 = (Security::SecCFObject *)Security::SecCFObject::allocate((Security::SecCFObject *)0x18, *(_QWORD *)(v6 + 304), v7);
  Security::CodeSigning::SecRequirement::SecRequirement(v8, v5, 0);
  v9 = (__SecRequirement *)Security::SecCFObject::handle(v8, 1);
  if (!requirement)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  v10 = v9;
  result = 0;
  *requirement = v10;
  return result;
}

void sub_18AA2FE70(void *a1, int a2)
{
  char *v2;
  _DWORD *v5;
  void *v6;
  unsigned int v7;
  int v8;
  const char *v9;

  Security::SecCFObject::operator delete(v2);
  switch(a2)
  {
    case 6:
      v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8)
        break;
LABEL_6:
      (*(void (**)(_DWORD *))(*(_QWORD *)v5 + 24))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      v5 = __cxa_begin_catch(a1);
      v7 = v5[36];
      if (v7 > 0x1A)
        goto LABEL_6;
      v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0)
        goto LABEL_6;
      break;
    case 3:
LABEL_5:
      v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v6 + 24))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA2FE40);
}

void sub_18AA2FFA8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t SecCodeCopyInternalRequirement(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, int a3, _QWORD *a4)
{
  int v5;
  Security::CodeSigning::SecStaticCode *v6;
  unsigned int *v7;
  unsigned int *v8;
  uint64_t v9;
  const Security::CFClass *v10;
  Security::SecCFObject *v11;
  const void *v12;
  uint64_t result;

  if (a3)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v5 = (int)a2;
  v6 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  v7 = Security::CodeSigning::SecStaticCode::internalRequirements(v6);
  if (v7
    && (v8 = Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::find<Security::CodeSigning::Requirement>((uint64_t)v7, v5)) != 0)
  {
    v9 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
    v11 = (Security::SecCFObject *)Security::SecCFObject::allocate((Security::SecCFObject *)0x18, *(_QWORD *)(v9 + 304), v10);
    Security::CodeSigning::SecRequirement::SecRequirement(v11, v8, 0);
    v12 = Security::SecCFObject::handle(v11, 1);
  }
  else
  {
    v12 = 0;
  }
  if (!a4)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  result = 0;
  *a4 = v12;
  return result;
}

void sub_18AA30098(void *a1, int a2)
{
  char *v2;
  _DWORD *v5;
  void *v6;
  unsigned int v7;
  int v8;
  const char *v9;

  Security::SecCFObject::operator delete(v2);
  switch(a2)
  {
    case 6:
      v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8)
        break;
LABEL_6:
      (*(void (**)(_DWORD *))(*(_QWORD *)v5 + 24))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      v5 = __cxa_begin_catch(a1);
      v7 = v5[36];
      if (v7 > 0x1A)
        goto LABEL_6;
      v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0)
        goto LABEL_6;
      break;
    case 3:
LABEL_5:
      v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v6 + 24))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA30068);
}

void sub_18AA301D0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t SecCodeSetDetachedSignature(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, int a3)
{
  Security::CodeSigning::SecStaticCode *v4;
  Security::CodeSigning::SecStaticCode *v5;
  unsigned __int8 *v6;
  unsigned __int8 v7;
  const void *v8;
  Security::CodeSigning::SecStaticCode *v10;

  if (a3)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v10 = (Security::CodeSigning::SecStaticCode *)0xAAAAAAAAAAAAAAAALL;
  v4 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  v5 = v4;
  if (v4)
  {
    v6 = (unsigned __int8 *)v4 - 8;
    do
      v7 = __ldaxr(v6);
    while (__stlxr(1u, v6));
    if ((v7 & 1) != 0)
    {
      v8 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)v4 + 16))(v4);
      CFRetain(v8);
    }
  }
  v10 = v5;
  Security::CodeSigning::SecStaticCode::detachedSignature(v5, a2);
  Security::CodeSigning::SecStaticCode::resetValidity(v5);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v10);
  return 0;
}

void sub_18AA302B0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  _DWORD *v11;
  void *v12;
  unsigned int v13;
  int v14;
  const char *v15;

  switch(a2)
  {
    case 6:
      v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8)
        break;
LABEL_6:
      (*(void (**)(_DWORD *))(*(_QWORD *)v11 + 24))(v11);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      v11 = __cxa_begin_catch(a1);
      v13 = v11[36];
      if (v13 > 0x1A)
        goto LABEL_6;
      v14 = 1 << v13;
      if ((v14 & 0x800108) == 0 && (v14 & 0x4014000) == 0)
        goto LABEL_6;
      break;
    case 3:
LABEL_5:
      v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v12 + 24))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA30290);
}

void sub_18AA303E8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

OSStatus SecCodeMapMemory(SecStaticCodeRef code, SecCSFlags flags)
{
  Security::CodeSigning::SecStaticCode *v2;
  Security::CodeSigning::SecStaticCode *v3;
  unsigned __int8 *v4;
  unsigned __int8 v5;
  const void *v6;
  const UInt8 *v7;
  __int128 v8;
  int *v9;
  int *v10;
  off_t *v11;
  Security::MachOBase *v12;
  const load_command *CodeSignature;
  unsigned int cmd;
  unsigned int v15;
  uint64_t v16;
  const load_command *v17;
  unsigned int cmdsize;
  unsigned int v19;
  uint64_t v20;
  __int128 v21;
  int *v22;
  int *v24;
  unint64_t v25;
  __int128 v26;
  _BYTE v27[40];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (flags)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v25 = 0xAAAAAAAAAAAAAAAALL;
  v2 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(code, *(const __SecCode **)&flags);
  v3 = v2;
  if (v2)
  {
    v4 = (unsigned __int8 *)v2 - 8;
    do
      v5 = __ldaxr(v4);
    while (__stlxr(1u, v4));
    if ((v5 & 1) != 0)
    {
      v6 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)v2 + 16))(v2);
      CFRetain(v6);
    }
  }
  v25 = (unint64_t)v3;
  v7 = Security::CodeSigning::SecStaticCode::codeDirectory(v3, 0);
  if (!v7)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ALL);
  if ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(v25 + 32) + 16))(*(_QWORD *)(v25 + 32)) != *(_QWORD *)(v25 + 32))
  {
    *(_QWORD *)&v27[32] = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v8 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)v27 = v8;
    *(_OWORD *)&v27[16] = v8;
    v26 = v8;
    *(_QWORD *)&v26 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v25 + 32) + 88))(*(_QWORD *)(v25 + 32));
    *((_QWORD *)&v26 + 1) = v7;
    *(_QWORD *)v27 = bswap32(*((_DWORD *)v7 + 1));
    memset(&v27[8], 0, 32);
    v9 = (int *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v25 + 32) + 144))(*(_QWORD *)(v25 + 32));
    if (fcntl(*v9, 59, &v26) == -1)
    {
      v10 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v10);
    }
    goto LABEL_24;
  }
  v11 = (off_t *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v25 + 32) + 80))(*(_QWORD *)(v25 + 32));
  if (!v11)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2BLL);
  v12 = (Security::MachOBase *)Security::Universal::architecture(v11);
  CodeSignature = Security::MachOBase::findCodeSignature(v12);
  if (CodeSignature)
  {
    cmd = CodeSignature[1].cmd;
    v15 = bswap32(cmd);
    if (*((_BYTE *)v12 + 33))
      v16 = v15;
    else
      v16 = cmd;
  }
  else
  {
    v16 = 0;
  }
  v17 = Security::MachOBase::findCodeSignature(v12);
  if (v17)
  {
    cmdsize = v17[1].cmdsize;
    v19 = bswap32(cmdsize);
    if (*((_BYTE *)v12 + 33))
      v20 = v19;
    else
      v20 = cmdsize;
    if (v16)
      goto LABEL_22;
LABEL_26:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ALL);
  }
  v20 = 0;
  if (!v16)
    goto LABEL_26;
LABEL_22:
  *(_QWORD *)&v27[32] = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v21 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)v27 = v21;
  *(_OWORD *)&v27[16] = v21;
  v26 = v21;
  *(_QWORD *)&v26 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v25 + 32) + 88))(*(_QWORD *)(v25 + 32));
  *((_QWORD *)&v26 + 1) = v16;
  *(_QWORD *)v27 = v20;
  memset(&v27[8], 0, 32);
  v22 = (int *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v25 + 32) + 144))(*(_QWORD *)(v25 + 32));
  if (fcntl(*v22, 61, &v26) == -1)
  {
    v24 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v24);
  }
  (*(void (**)(Security::MachOBase *))(*(_QWORD *)v12 + 8))(v12);
LABEL_24:
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v25);
  return 0;
}

void sub_18AA306CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  _DWORD *v13;
  void *v14;
  unsigned int v15;
  int v16;
  const char *v17;

  if (!a2)
    _Unwind_Resume(exception_object);
  (*(void (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a10);
  if (a2 == 6)
  {
    v13 = __cxa_begin_catch(exception_object);
    if (v13[36] == 8)
      goto LABEL_17;
    goto LABEL_16;
  }
  if (a2 != 5)
  {
    if (a2 == 4)
    {
      v13 = __cxa_begin_catch(exception_object);
      v15 = v13[36];
      if (v15 <= 0x1A)
      {
        v16 = 1 << v15;
        if ((v16 & 0x800108) != 0 || (v16 & 0x4014000) != 0)
          goto LABEL_17;
      }
LABEL_16:
      (*(void (**)(_DWORD *))(*(_QWORD *)v13 + 24))(v13);
LABEL_17:
      __cxa_end_catch();
LABEL_19:
      JUMPOUT(0x18AA30640);
    }
    if (a2 != 3)
    {
      __cxa_begin_catch(exception_object);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v17);
      goto LABEL_17;
    }
  }
  v14 = __cxa_begin_catch(exception_object);
  (*(void (**)(void *))(*(_QWORD *)v14 + 24))(v14);
  __cxa_end_catch();
  goto LABEL_19;
}

uint64_t SecStaticCodeSetCallback(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, _QWORD *a3, uint64_t a4)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t result;

  if ((_DWORD)a2)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v6 = Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  v7 = v6;
  if (a3)
    *a3 = v6[72];
  result = 0;
  v7[72] = a4;
  return result;
}

void sub_18AA30924(void *a1, int a2)
{
  _DWORD *v3;
  void *v4;
  unsigned int v5;
  int v6;
  const char *v7;

  switch(a2)
  {
    case 6:
      v3 = __cxa_begin_catch(a1);
      if (v3[36] == 8)
        break;
LABEL_6:
      (*(void (**)(_DWORD *))(*(_QWORD *)v3 + 24))(v3);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      v3 = __cxa_begin_catch(a1);
      v5 = v3[36];
      if (v5 > 0x1A)
        goto LABEL_6;
      v6 = 1 << v5;
      if ((v6 & 0x800108) == 0 && (v6 & 0x4014000) == 0)
        goto LABEL_6;
      break;
    case 3:
LABEL_5:
      v4 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v4 + 24))(v4);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v7);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA30908);
}

void sub_18AA30A40(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t SecStaticCodeSetValidationConditions(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  CFTypeRef *v3;
  CFTypeRef *v4;
  const void *v5;
  const __CFArray *v6;
  const __CFArray *v7;
  unint64_t v9;
  unint64_t v10;
  CFRange v11;

  v3 = (CFTypeRef *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  if (a2)
  {
    v4 = v3;
    v9 = 0xAAAAAAAAAAAAAAAALL;
    v10 = 0xAAAAAAAAAAAAAAAALL;
    Security::CFCopyRef<__CFDictionary const*>::CFCopyRef(&v9, a2);
    LODWORD(v10) = -67024;
    v5 = Security::CFDictionary::get<__CFArray const*>((uint64_t)&v9, "omissions");
    Security::CFRef<__CFArray const*>::operator=(v4 + 21, v5);
    v6 = (const __CFArray *)Security::CFDictionary::get<__CFArray const*>((uint64_t)&v9, "errors");
    v7 = v6;
    if (v6)
    {
      v11.length = CFArrayGetCount(v6);
      v11.location = 0;
      CFArrayApplyFunction(v7, v11, (CFArrayApplierFunction)Security::CodeSigning::addError, v4 + 18);
    }
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v9);
  }
  return 0;
}

void sub_18AA30B40(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  _DWORD *v11;
  void *v12;
  unsigned int v13;
  int v14;
  const char *v15;

  Security::CFRef<__CFDictionary const*>::~CFRef(&a9);
  switch(a2)
  {
    case 6:
      v11 = __cxa_begin_catch(a1);
      if (v11[36] == 8)
        break;
      goto LABEL_6;
    case 5:
      goto LABEL_5;
    case 4:
      v11 = __cxa_begin_catch(a1);
      v13 = v11[36];
      if (v13 > 0x1A || (v14 = 1 << v13, (v14 & 0x800108) == 0) && (v14 & 0x4014000) == 0)
LABEL_6:
        (*(void (**)(_DWORD *))(*(_QWORD *)v11 + 24))(v11);
      break;
    case 3:
LABEL_5:
      v12 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v12 + 24))(v12);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v15);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA30B2CLL);
}

void sub_18AA30C6C(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t SecStaticCodeCancelValidation(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  dispatch_queue_t *v2;
  dispatch_queue_t *v3;
  uint64_t result;

  v2 = (dispatch_queue_t *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  v3 = v2;
  if ((*((_BYTE *)v2 + 211) & 0x10) == 0)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  dispatch_assert_queue_V2(v2[39]);
  result = 0;
  *((_BYTE *)v3 + 220) = 1;
  return result;
}

unint64_t SecCodeCopyComponent(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2, const __CFData *a3)
{
  Security::CodeSigning::SecStaticCode *v5;
  const UInt8 *v6;
  const void *v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t v10;
  const UInt8 *BytePtr;
  CFIndex Length;
  const char *v13;
  unint64_t v15;

  v5 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  v6 = Security::CodeSigning::SecStaticCode::codeDirectory(v5, 1);
  v15 = 0xAAAAAAAAAAAAAAAALL;
  v7 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *, const __SecCode *, uint64_t))(*(_QWORD *)v5 + 80))(v5, a2, 4294900235);
  Security::CFCopyRef<__CFData const*>::CFCopyRef(&v15, v7);
  v8 = v15;
  if (v15)
  {
    if (a3)
    {
      v9 = *((_DWORD *)v6 + 4);
      v10 = v6[36];
      if (CFDataGetLength(a3) != v10
        || (BytePtr = CFDataGetBytePtr(a3), memcmp(&v6[bswap32(v9) + (int)v10 * (uint64_t)(int)a2], BytePtr, v6[36])))
      {
        Length = CFDataGetLength(a3);
        Security::Syslog::notice((Security::Syslog *)"copyComponent hash mismatch slot %d length %d", v13, a2, Length);
        v8 = 0;
        goto LABEL_8;
      }
      v8 = v15;
    }
    v15 = 0;
  }
LABEL_8:
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v15);
  return v8;
}

void sub_18AA30F6C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18AA30F50);
}

uint64_t SecStaticCodeEnableOnlineNotarizationCheck(Security::CodeSigning::SecStaticCode *a1, const __SecCode *a2)
{
  int v2;
  _DWORD *v3;
  uint64_t result;

  v2 = (int)a2;
  v3 = Security::CodeSigning::SecStaticCode::requiredStatic(a1, a2);
  result = 0;
  v3[148] = v3[148] & 0xFFFFFFFE | (v2 != 0);
  return result;
}

OSStatus SecCodeValidateFileResource(SecStaticCodeRef code, CFStringRef relativePath, CFDataRef fileData, SecCSFlags flags)
{
  Security::CodeSigning::SecStaticCode *v6;
  __CFDictionary *v7;
  const void *Value;
  uint64_t v9;
  __int128 v10;
  const UInt8 *v11;
  const unsigned __int8 *v12;
  const UInt8 *v13;
  __int128 v14;
  Security::CCHashInstance *v15;
  unsigned int *v16;
  unsigned int v17;
  const UInt8 *BytePtr;
  CFIndex Length;
  BOOL v20;
  std::string __p;
  _OWORD v23[2];
  std::string v24;
  unsigned int v25;
  __CFDictionary *v26;
  __CFDictionary *v27;
  void *key[2];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  unint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (!fileData)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  v6 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::requiredStatic(code, (const __SecCode *)relativePath);
  Security::cfString(&__p, relativePath);
  v26 = (__CFDictionary *)0xAAAAAAAAAAAAAAAALL;
  v27 = (__CFDictionary *)0xAAAAAAAAAAAAAAAALL;
  if (!Security::CodeSigning::SecStaticCode::loadResources(v6, &v27, &v26, &v25))
  {
    v9 = 4294900240;
    goto LABEL_19;
  }
  v7 = v26;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v24, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  else
    v24 = __p;
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)key, (char *)&v24);
  Value = CFDictionaryGetValue(v7, key[0]);
  Security::CFRef<__CFString const*>::~CFRef((const void **)key);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  v9 = 4294900242;
  if (!Value)
LABEL_19:
    Security::MacOSError::throwMe((Security::MacOSError *)v9);
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[0] = v10;
  v23[1] = v10;
  Security::CodeSigning::ResourceSeal::ResourceSeal((Security::CodeSigning::ResourceSeal *)v23, Value);
  v11 = Security::CodeSigning::SecStaticCode::codeDirectory(v6, 1);
  v12 = Security::CodeSigning::ResourceSeal::hash((CFDictionaryRef *)v23, v11[37]);
  if (!v12)
    goto LABEL_16;
  v13 = Security::CodeSigning::SecStaticCode::codeDirectory(v6, 1);
  v32 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v14 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v30 = v14;
  v31 = v14;
  *(_OWORD *)key = v14;
  v29 = v14;
  v15 = Security::CodeSigning::CodeDirectory::hashFor((Security::CodeSigning::CodeDirectory *)v13[37]);
  Security::Mutex::Mutex((pthread_mutex_t *)&key[1]);
  v16 = (unsigned int *)((char *)v15 + 8);
  do
    v17 = __ldxr(v16);
  while (__stxr(v17 + 1, v16));
  key[0] = v15;
  BytePtr = CFDataGetBytePtr(fileData);
  Length = CFDataGetLength(fileData);
  (*(void (**)(Security::CCHashInstance *, const UInt8 *, CFIndex))(*(_QWORD *)v15 + 24))(v15, BytePtr, Length);
  v20 = Security::DynamicHash::verify((Security::DynamicHash *)key[0], v12);
  Security::RefPointer<Security::DynamicHash>::~RefPointer(key);
  if (!v20)
  {
LABEL_16:
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)v23);
    goto LABEL_19;
  }
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)v23);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return 0;
}

void sub_18AA31360(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,const void *a29)
{
  _DWORD *v31;
  void *v32;
  unsigned int v33;
  int v34;
  const char *v35;

  if (!a2)
    _Unwind_Resume(exception_object);
  Security::CFRef<__CFString const*>::~CFRef(&a29);
  if (a25 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  if (a2 == 6)
  {
    v31 = __cxa_begin_catch(exception_object);
    if (v31[36] == 8)
      goto LABEL_21;
    goto LABEL_20;
  }
  if (a2 != 5)
  {
    if (a2 == 4)
    {
      v31 = __cxa_begin_catch(exception_object);
      v33 = v31[36];
      if (v33 <= 0x1A)
      {
        v34 = 1 << v33;
        if ((v34 & 0x800108) != 0 || (v34 & 0x4014000) != 0)
          goto LABEL_21;
      }
LABEL_20:
      (*(void (**)(_DWORD *))(*(_QWORD *)v31 + 24))(v31);
LABEL_21:
      __cxa_end_catch();
LABEL_23:
      JUMPOUT(0x18AA312F8);
    }
    if (a2 != 3)
    {
      __cxa_begin_catch(exception_object);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v35);
      goto LABEL_21;
    }
  }
  v32 = __cxa_begin_catch(exception_object);
  (*(void (**)(void *))(*(_QWORD *)v32 + 24))(v32);
  __cxa_end_catch();
  goto LABEL_23;
}

CFTypeID SecRequirementGetTypeID(void)
{
  return *(_QWORD *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 304);
}

void sub_18AA3157C(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18AA31574);
}

OSStatus SecRequirementCreateWithData(CFDataRef data, SecCSFlags flags, SecRequirementRef *requirement)
{
  uint64_t v5;
  const Security::CFClass *v6;
  Security::SecCFObject *v7;
  unsigned int *BytePtr;
  unint64_t Length;
  unsigned int v10;
  __SecRequirement *v11;
  uint64_t v13;

  if (flags)
  {
    v13 = 4294900226;
    goto LABEL_12;
  }
  v5 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  v7 = (Security::SecCFObject *)Security::SecCFObject::allocate((Security::SecCFObject *)0x18, *(_QWORD *)(v5 + 304), v6);
  BytePtr = (unsigned int *)CFDataGetBytePtr(data);
  Length = CFDataGetLength(data);
  *((_QWORD *)v7 + 1) = 1;
  *(_QWORD *)v7 = off_1E1FC8D28;
  *((_QWORD *)v7 + 2) = 0;
  if (Length < 0xC)
LABEL_10:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14);
  if (*BytePtr != 843514 || (v10 = bswap32(BytePtr[1]), v10 <= 0xB))
  {
    *__error() = 22;
    goto LABEL_10;
  }
  if (Length != v10)
    goto LABEL_10;
  *((_QWORD *)v7 + 2) = Security::Blob<Security::CodeSigning::Requirement,4208856064u>::clone((Security::BlobCore *)BytePtr);
  v11 = (__SecRequirement *)Security::SecCFObject::handle(v7, 1);
  if (!requirement)
  {
    v13 = 4294900227;
LABEL_12:
    Security::MacOSError::throwMe((Security::MacOSError *)v13);
  }
  *requirement = v11;
  return 0;
}

void sub_18AA31694(void *a1, int a2)
{
  char *v2;
  _DWORD *v5;
  void *v6;
  unsigned int v7;
  int v8;
  const char *v9;

  Security::SecCFObject::operator delete(v2);
  switch(a2)
  {
    case 6:
      v5 = __cxa_begin_catch(a1);
      if (v5[36] == 8)
        break;
LABEL_6:
      (*(void (**)(_DWORD *))(*(_QWORD *)v5 + 24))(v5);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      v5 = __cxa_begin_catch(a1);
      v7 = v5[36];
      if (v7 > 0x1A)
        goto LABEL_6;
      v8 = 1 << v7;
      if ((v8 & 0x800108) == 0 && (v8 & 0x4014000) == 0)
        goto LABEL_6;
      break;
    case 3:
LABEL_5:
      v6 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v6 + 24))(v6);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v9);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA3164CLL);
}

void sub_18AA317B0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

OSStatus SecRequirementCreateWithString(CFStringRef text, SecCSFlags flags, SecRequirementRef *requirement)
{
  return SecRequirementCreateWithStringAndErrors(text, flags, 0, requirement);
}

OSStatus SecRequirementCreateWithStringAndErrors(CFStringRef text, SecCSFlags flags, CFErrorRef *errors, SecRequirementRef *requirement)
{
  uint64_t v6;
  const Security::CFClass *v7;
  Security::SecCFObject *v8;
  uint64_t (*v9)(std::string *, std::string *);
  int v10;
  unsigned int *v11;
  __SecRequirement *v12;
  const void *v14;
  std::string __p;
  std::string v16;
  std::string v17;
  __CFString *v18;
  std::string v19;
  std::string v20;

  if (flags)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v6 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  v8 = (Security::SecCFObject *)Security::SecCFObject::allocate((Security::SecCFObject *)0x18, *(_QWORD *)(v6 + 304), v7);
  Security::cfString(&__p, text);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v16, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  else
    v16 = __p;
  memset(&v20, 0, sizeof(v20));
  v9 = *(uint64_t (**)(std::string *, std::string *))(*(_QWORD *)(Security::ModuleNexus<Security::CodeSigning::PluginHost>::operator()()
                                                                          + 72)
                                                              + 24);
  v10 = SHIBYTE(v16.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v19, v16.__r_.__value_.__l.__data_, v16.__r_.__value_.__l.__size_);
  else
    v19 = v16;
  v11 = (unsigned int *)v9(&v19, &v20);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v19.__r_.__value_.__l.__data_);
  if (!v11)
  {
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&v17, v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
    else
      v17 = v20;
    Security::CFTempString::CFTempString<std::string>((CFStringRef *)&v18, (char *)&v17);
    Security::CodeSigning::CSError::throwMe((Security::CodeSigning::CSError *)0xFFFEFA14, (uint64_t)CFSTR("SecRequirementSyntax"), v18, v14);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v20.__r_.__value_.__l.__data_);
    if ((v10 & 0x80000000) == 0)
      goto LABEL_13;
  }
  else if ((v10 & 0x80000000) == 0)
  {
    goto LABEL_13;
  }
  operator delete(v16.__r_.__value_.__l.__data_);
LABEL_13:
  Security::CodeSigning::SecRequirement::SecRequirement(v8, v11, 1);
  v12 = (__SecRequirement *)Security::SecCFObject::handle(v8, 1);
  if (!requirement)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  *requirement = v12;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return 0;
}

void sub_18AA319C4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  __CFError **v35;
  char *v36;
  uint64_t v37;
  CFDictionaryRef *v40;
  _DWORD *v41;
  int v42;
  void *v43;
  int v44;
  CFErrorRef v45;
  _DWORD *v46;
  unsigned int v47;
  int v48;
  void *v49;
  int v50;
  const char *v51;

  if (*(char *)(v37 - 49) < 0)
    operator delete(*(void **)(v37 - 72));
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  Security::SecCFObject::operator delete(v36);
  switch(a2)
  {
    case 7:
      v40 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v40, v35);
      goto LABEL_38;
    case 6:
      v41 = __cxa_begin_catch(a1);
      if (v41[36] == 8)
        v42 = -67049;
      else
        v42 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v41 + 24))(v41);
      if (v35)
      {
LABEL_36:
        v45 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v42, 0);
        goto LABEL_37;
      }
LABEL_38:
      __cxa_end_catch();
      JUMPOUT(0x18AA3191CLL);
    case 5:
      v43 = __cxa_begin_catch(a1);
      v44 = (*(uint64_t (**)(void *))(*(_QWORD *)v43 + 24))(v43);
      if (!v35)
        goto LABEL_38;
      v45 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v44, 0);
LABEL_37:
      *v35 = v45;
      goto LABEL_38;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      v49 = __cxa_begin_catch(a1);
      v50 = (*(uint64_t (**)(void *))(*(_QWORD *)v49 + 24))(v49);
      if (v35)
        *v35 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v50, 0);
    }
    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v35)
          *v35 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -108, 0);
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v51);
        if (v35)
          *v35 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -67048, 0);
      }
    }
    goto LABEL_38;
  }
  v46 = __cxa_begin_catch(a1);
  v47 = v46[36];
  if (v47 > 0x1A)
    goto LABEL_34;
  v42 = -67033;
  v48 = 1 << v47;
  if ((v48 & 0x800108) != 0)
    goto LABEL_35;
  if ((v48 & 0x4014000) != 0)
    v42 = -67032;
  else
LABEL_34:
    v42 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v46 + 24))(v46);
LABEL_35:
  if (!v35)
    goto LABEL_38;
  goto LABEL_36;
}

void sub_18AA31CA0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

OSStatus SecRequirementCopyData(SecRequirementRef requirement, SecCSFlags flags, CFDataRef *data)
{
  const UInt8 **v5;
  uint64_t v7;

  v5 = (const UInt8 **)Security::CodeSigning::SecRequirement::required(requirement, *(__SecRequirement **)&flags);
  if (flags)
  {
    v7 = 4294900226;
    goto LABEL_6;
  }
  if (!data)
  {
    v7 = 4294900227;
LABEL_6:
    Security::MacOSError::throwMe((Security::MacOSError *)v7);
  }
  *data = CFDataCreate(0, v5[2], bswap32(*((_DWORD *)v5[2] + 1)));
  return 0;
}

void *Security::CodeSigning::SecRequirement::required(Security::CodeSigning::SecRequirement *this, __SecRequirement *a2)
{
  void *result;

  if (!this
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  return result;
}

OSStatus SecRequirementCopyString(SecRequirementRef requirement, SecCSFlags flags, CFStringRef *text)
{
  _QWORD *v5;
  std::string *p_cStr;
  const __CFString *v7;
  int v8;
  void *v9;
  uint64_t v11;
  std::string cStr;

  v5 = Security::CodeSigning::SecRequirement::required(requirement, *(__SecRequirement **)&flags);
  if (flags)
  {
    v11 = 4294900226;
    goto LABEL_15;
  }
  if (!text)
  {
    v11 = 4294900227;
LABEL_15:
    Security::MacOSError::throwMe((Security::MacOSError *)v11);
  }
  Security::CodeSigning::Dumper::dump(&cStr, v5[2]);
  if (SHIBYTE(cStr.__r_.__value_.__r.__words[2]) < 0)
  {
    p_cStr = (std::string *)cStr.__r_.__value_.__r.__words[0];
    if (!cStr.__r_.__value_.__r.__words[0])
    {
      v9 = 0;
      *text = 0;
      goto LABEL_11;
    }
  }
  else
  {
    p_cStr = &cStr;
  }
  v7 = CFStringCreateWithCString(0, (const char *)p_cStr, 0x8000100u);
  if (!v7)
  {
    v7 = CFStringCreateWithCString(0, (const char *)p_cStr, 0x600u);
    if (!v7)
      Security::CFError::throwMe(0);
  }
  v8 = SHIBYTE(cStr.__r_.__value_.__r.__words[2]);
  *text = v7;
  if (v8 < 0)
  {
    v9 = (void *)cStr.__r_.__value_.__r.__words[0];
LABEL_11:
    operator delete(v9);
  }
  return 0;
}

void sub_18AA31FC0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  _DWORD *v16;
  void *v17;
  unsigned int v18;
  int v19;
  const char *v20;

  switch(a2)
  {
    case 6:
      v16 = __cxa_begin_catch(a1);
      if (v16[36] == 8)
        break;
LABEL_6:
      (*(void (**)(_DWORD *))(*(_QWORD *)v16 + 24))(v16);
      break;
    case 5:
      goto LABEL_5;
    case 4:
      v16 = __cxa_begin_catch(a1);
      v18 = v16[36];
      if (v18 > 0x1A)
        goto LABEL_6;
      v19 = 1 << v18;
      if ((v19 & 0x800108) == 0 && (v19 & 0x4014000) == 0)
        goto LABEL_6;
      break;
    case 3:
LABEL_5:
      v17 = __cxa_begin_catch(a1);
      (*(void (**)(void *))(*(_QWORD *)v17 + 24))(v17);
      break;
    default:
      __cxa_begin_catch(a1);
      if (a2 != 2)
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v20);
      break;
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA31F8CLL);
}

void sub_18AA320E4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_DWORD *Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::make(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  int v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;
  unsigned int v10;
  _DWORD *v11;
  _DWORD *v12;
  unsigned int v13;
  _QWORD *v14;
  int v15;
  unsigned int v16;
  _DWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  __int128 v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  NSObject *v26;
  void **v28;
  void *__dst[2];
  char v30;
  _OWORD v31[4];
  void *__p[2];
  __int128 v33;
  __int128 v34;
  _OWORD v35[9];
  unint64_t v36;
  uint8_t buf[4];
  void **v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v2 = a1[2];
  v3 = (_QWORD *)*a1;
  v4 = a1 + 1;
  if ((_QWORD *)*a1 == a1 + 1)
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    do
    {
      v6 = (_QWORD *)v3[1];
      v7 = v3;
      if (v6)
      {
        do
        {
          v8 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v7[2];
          v9 = *v8 == (_QWORD)v7;
          v7 = v8;
        }
        while (!v9);
      }
      v5 += bswap32(*(_DWORD *)(v3[5] + 4));
      v3 = v8;
    }
    while (v8 != v4);
  }
  v10 = v5 + 8 * v2 + 12;
  v11 = malloc_type_malloc(v10, 0x79CB62BEuLL);
  if (!v11)
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  v12 = v11;
  v13 = *((_DWORD *)a1 + 4);
  *v11 = 17620730;
  v11[1] = bswap32(v10);
  v11[2] = bswap32(v13);
  v14 = (_QWORD *)*a1;
  if ((_QWORD *)*a1 != v4)
  {
    v15 = 0;
    v16 = 8 * v2 + 12;
    do
    {
      v17 = &v12[2 * v15];
      v17[3] = bswap32(*((_DWORD *)v14 + 8));
      v17[4] = bswap32(v16);
      memcpy((char *)v12 + v16, (const void *)v14[5], bswap32(*(_DWORD *)(v14[5] + 4)));
      v18 = (_QWORD *)v14[1];
      v19 = v14;
      if (v18)
      {
        do
        {
          v20 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v20 = (_QWORD *)v19[2];
          v9 = *v20 == (_QWORD)v19;
          v19 = v20;
        }
        while (!v9);
      }
      v16 += bswap32(*(_DWORD *)(v14[5] + 4));
      ++v15;
      v14 = v20;
    }
    while (v20 != v4);
  }
  v36 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v21 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v35[7] = v21;
  v35[8] = v21;
  v35[5] = v21;
  v35[6] = v21;
  v35[3] = v21;
  v35[4] = v21;
  v35[1] = v21;
  v35[2] = v21;
  v35[0] = v21;
  v33 = v21;
  v34 = v21;
  v31[3] = v21;
  *(_OWORD *)__p = v21;
  v31[1] = v21;
  v31[2] = v21;
  v31[0] = v21;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v31);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)"Maker ", 6);
  v22 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)" assembles ", 11);
  v23 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)" blob(s) into ", 14);
  v24 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)" (size=", 7);
  v25 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)")", 1);
  v26 = secLogObjForScope("superblob");
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)v31 + 8);
    v28 = v30 >= 0 ? __dst : (void **)__dst[0];
    *(_DWORD *)buf = 136315138;
    v38 = v28;
    _os_log_debug_impl(&dword_18A900000, v26, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
    if (v30 < 0)
      operator delete(__dst[0]);
  }
  *(_QWORD *)&v31[0] = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)v31 + *(_QWORD *)(*(_QWORD *)&v31[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  *((_QWORD *)&v31[0] + 1) = MEMORY[0x1E0DE4FB8] + 16;
  if (SHIBYTE(v33) < 0)
    operator delete(__p[1]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18D76FA34](v35);
  return v12;
}

void sub_18AA32478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

_DWORD *Security::Blob<Security::CodeSigning::Requirement,4208856064u>::clone(Security::BlobCore *a1)
{
  _DWORD *result;
  unsigned int v2;
  int *v4;

  result = Security::BlobCore::clone(a1);
  v2 = bswap32(result[1]);
  if (*result != 843514 || v2 <= 0xB)
  {
    v4 = __error();
    result = 0;
    *v4 = 22;
  }
  return result;
}

void Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add(uint64_t **a1, unsigned int a2, uint64_t *a3)
{
  uint64_t **v6;
  char v7;
  uint64_t **v8;
  NSObject *v9;
  int v10;
  uint64_t **v11;
  __int16 v12;
  unsigned int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v6 = std::__tree<std::__value_type<unsigned int,Security::BlobCore *>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::BlobCore *>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::BlobCore *>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,Security::BlobCore *>>(a1, a2, a2, a3);
  if (!v7)
  {
    v8 = v6;
    v9 = secLogObjForScope("superblob");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      v10 = 134218240;
      v11 = a1;
      v12 = 1024;
      v13 = a2;
      _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "Maker %p replaces type=%d", (uint8_t *)&v10, 0x12u);
    }
    free(v8[5]);
    v8[5] = a3;
  }
}

uint64_t **std::__tree<std::__value_type<unsigned int,Security::BlobCore *>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::BlobCore *>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::BlobCore *>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,Security::BlobCore *>>(uint64_t **a1, unsigned int a2, int a3, uint64_t *a4)
{
  uint64_t *v7;
  uint64_t **v8;
  uint64_t **v9;
  unsigned int v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;

  v8 = a1 + 1;
  v7 = a1[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v7;
        v10 = *((_DWORD *)v7 + 8);
        if (v10 <= a2)
          break;
        v7 = *v9;
        v8 = v9;
        if (!*v9)
          goto LABEL_9;
      }
      if (v10 >= a2)
        break;
      v7 = v9[1];
      if (!v7)
      {
        v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_9:
    v11 = (uint64_t *)v9;
    v9 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v9 + 8) = a3;
    v9[5] = a4;
    *v9 = 0;
    v9[1] = 0;
    v9[2] = v11;
    *v8 = (uint64_t *)v9;
    v12 = (uint64_t *)**a1;
    v13 = (uint64_t *)v9;
    if (v12)
    {
      *a1 = v12;
      v13 = *v8;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v9;
}

void *Security::BlobCore::clone(Security::BlobCore *this)
{
  void *v2;

  v2 = malloc_type_malloc(bswap32(*((_DWORD *)this + 1)), 0x18E3CB5FuLL);
  if (!v2)
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  return memcpy(v2, this, bswap32(*((_DWORD *)this + 1)));
}

const void **Security::CFRef<__SecRequirement *>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t SecRequirementCreateWithLightweightCodeRequirementData(const __CFData *a1, int a2, _QWORD *a3)
{
  uint64_t result;
  unsigned int *v6;
  const UInt8 *BytePtr;
  CFIndex Length;
  void *v9;
  uint64_t v10;
  const Security::CFClass *v11;
  Security::SecCFObject *v12;
  unsigned int *v13;
  const void *v14;
  unsigned int *v15;
  int v16;
  unsigned int v17;

  if (a2)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  result = 4294900227;
  if (a1 && a3)
  {
    v16 = 1024;
    v6 = (unsigned int *)malloc_type_malloc(0x400uLL, 0x96562061uLL);
    v15 = v6;
    *(_QWORD *)v6 = 843514;
    v6[2] = 0x2000000;
    v17 = 12;
    BytePtr = CFDataGetBytePtr(a1);
    Length = CFDataGetLength(a1);
    makeLightweightCodeRequirement(a1);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v9)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFC73);

    Security::CodeSigning::Requirement::Maker::putData((Security::CodeSigning::Requirement::Maker *)&v15, BytePtr, Length);
    v10 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
    v12 = (Security::SecCFObject *)Security::SecCFObject::allocate((Security::SecCFObject *)0x18, *(_QWORD *)(v10 + 304), v11);
    v13 = v15;
    v15[1] = bswap32(v17);
    Security::CodeSigning::SecRequirement::SecRequirement(v12, v13, 1);
    v14 = Security::SecCFObject::handle(v12, 1);
    result = 0;
    *a3 = v14;
  }
  return result;
}

void sub_18AA32844(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  __CFError **v9;
  char *v10;
  int v11;
  CFDictionaryRef *v14;
  _DWORD *v15;
  int v16;
  void *v17;
  int v18;
  CFErrorRef v19;
  _DWORD *v20;
  unsigned int v21;
  int v22;
  void *v23;
  int v24;
  const char *v25;

  Security::SecCFObject::operator delete(v10);
  free(0);
  switch(a2)
  {
    case 7:
      v14 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v14, v9);
      __cxa_end_catch();
      goto LABEL_33;
    case 6:
      v15 = __cxa_begin_catch(a1);
      if (v15[36] == 8)
        v16 = v11 - 16;
      else
        v16 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v15 + 24))(v15);
      if (!v9)
        goto LABEL_32;
      goto LABEL_30;
    case 5:
      v17 = __cxa_begin_catch(a1);
      v18 = (*(uint64_t (**)(void *))(*(_QWORD *)v17 + 24))(v17);
      if (v9)
      {
        v19 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v18, 0);
LABEL_31:
        *v9 = v19;
        goto LABEL_32;
      }
      goto LABEL_32;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      v23 = __cxa_begin_catch(a1);
      v24 = (*(uint64_t (**)(void *))(*(_QWORD *)v23 + 24))(v23);
      if (v9)
        *v9 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v24, 0);
    }
    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v9)
          *v9 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -108, 0);
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v25);
        if (v9)
          *v9 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -67048, 0);
      }
    }
    goto LABEL_32;
  }
  v20 = __cxa_begin_catch(a1);
  v21 = v20[36];
  if (v21 > 0x1A)
    goto LABEL_28;
  v22 = 1 << v21;
  v16 = -67033;
  if ((v22 & 0x800108) != 0)
    goto LABEL_29;
  if ((v22 & 0x4014000) != 0)
    v16 = v11 + 1;
  else
LABEL_28:
    v16 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v20 + 24))(v20);
LABEL_29:
  if (v9)
  {
LABEL_30:
    v19 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v16, 0);
    goto LABEL_31;
  }
LABEL_32:
  __cxa_end_catch();
LABEL_33:
  JUMPOUT(0x18AA32810);
}

void sub_18AA32AA8(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t mapFile(const char *a1, const void **a2, off_t *a3, char **a4)
{
  timespec v7;
  int v8;
  int v9;
  void *v10;
  const void *v11;
  stat v13;

  v7.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v7.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v13.st_blksize = v7;
  *(timespec *)v13.st_qspare = v7;
  v13.st_birthtimespec = v7;
  *(timespec *)&v13.st_size = v7;
  v13.st_mtimespec = v7;
  v13.st_ctimespec = v7;
  *(timespec *)&v13.st_uid = v7;
  v13.st_atimespec = v7;
  *(timespec *)&v13.st_dev = v7;
  v8 = open(a1, 0, 0);
  if (v8 == -1)
  {
    __error();
    log_error(a4, "cannot open file %s, errno=%d\n");
  }
  else
  {
    v9 = v8;
    if (fstat(v8, &v13))
    {
      __error();
      log_error(a4, "fstat(%s) failed, errno=%d\n");
    }
    else
    {
      v10 = mmap(0, v13.st_size, 1, 8194, v9, 0);
      if (v10 != (void *)-1)
      {
        v11 = v10;
        close(v9);
        *a2 = v11;
        *a3 = v13.st_size;
        return 1;
      }
      log_error(a4, "cannot mmap file %s\n");
    }
  }
  return 0;
}

uint64_t log_error(char **a1, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  return vasprintf(a1, a2, va);
}

BOOL vm_alloc(vm_address_t *a1, vm_size_t size, char **a3)
{
  kern_return_t v5;
  vm_address_t address;

  address = 0;
  v5 = vm_allocate(*MEMORY[0x1E0C83DA0], &address, size, 1);
  if (v5)
    log_error(a3, "failed to allocate memory\n");
  else
    *a1 = address;
  return v5 == 0;
}

uint64_t assure_signature_space(_DWORD *a1, unsigned int a2, unsigned int a3, unsigned int *a4, char **a5)
{
  int v5;
  BOOL v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  int *v22;
  char *v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  BOOL v32;
  unsigned int v33;
  unsigned int *v34;
  unsigned int v35;
  _DWORD *v36;
  unsigned int v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  int v50;
  BOOL v51;
  unint64_t v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unsigned int v78;
  uint64_t v79;
  char **v84;

  v5 = *a1;
  v6 = *a1 == -822415874 || v5 == -805638658;
  v7 = v6;
  v8 = a1[3];
  v9 = bswap32(v8);
  if (v6)
    v8 = v9;
  if (v8 > 0xB || ((1 << v8) & 0x9C4) == 0)
  {
    log_error(a5, "mach-o filetype (%d) does not support code signing\n");
    return 0;
  }
  v11 = v5 == -805638658 || v5 == -17958193;
  v12 = 7;
  if (v11)
    v12 = 8;
  v13 = a1[5];
  v14 = bswap32(a1[4]);
  if (v7)
    v15 = v14;
  else
    v15 = a1[4];
  LODWORD(v16) = bswap32(v13);
  if (v7)
    v16 = v16;
  else
    v16 = v13;
  if (!v15)
    goto LABEL_68;
  v84 = a5;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = (char *)&a1[v12];
  v79 = v16;
  v22 = (_DWORD *)((char *)&a1[v12] + v16);
  v23 = (char *)&a1[v12];
  do
  {
    v24 = *(_DWORD *)v23;
    v25 = bswap32(*(_DWORD *)v23);
    if (v7)
      v24 = v25;
    v26 = bswap32(*((_DWORD *)v23 + 1));
    if (v7)
      v27 = v26;
    else
      v27 = *((_DWORD *)v23 + 1);
    switch(v24)
    {
      case 1u:
        if (!strcmp(v23 + 8, "__LINKEDIT"))
          v19 = v23;
        break;
      case 0x19u:
        if (!strcmp(v23 + 8, "__LINKEDIT"))
          v18 = v23;
        break;
      case 0x1Du:
        v20 = v23;
        break;
    }
    v23 += v27;
    if (v23 > (char *)v22)
    {
      log_error(v84, "malformed mach-o file, load command #%d is outside size of load commands\n");
      return 0;
    }
    ++v17;
  }
  while (v15 != v17);
  if (!v19)
  {
    v34 = a4;
    a5 = v84;
    v35 = a2;
    v36 = a1;
    v37 = a3;
    v38 = v79;
    if (v18)
    {
      v39 = *((_QWORD *)v18 + 5);
      v40 = *((_QWORD *)v18 + 6);
      v41 = bswap64(v39);
      if (v7)
        v39 = v41;
      v42 = bswap64(v40);
      if (v7)
        v40 = v42;
      v32 = __CFADD__(v39, v40);
      v43 = v39 + v40;
      if (!v32 && v43 <= a3)
        goto LABEL_60;
LABEL_69:
      log_error(a5, "malformed mach-o file, __LINKEDIT segment extends past end of file\n");
      return 0;
    }
LABEL_68:
    log_error(a5, "malformed mach-o file, no __LINKEDIT segment\n");
    return 0;
  }
  v28 = *((_DWORD *)v19 + 8);
  v29 = *((_DWORD *)v19 + 9);
  v30 = bswap32(v28);
  if (v7)
    v28 = v30;
  v31 = bswap32(v29);
  if (v7)
    v29 = v31;
  v32 = __CFADD__(v28, v29);
  v33 = v28 + v29;
  v34 = a4;
  a5 = v84;
  v35 = a2;
  v36 = a1;
  v37 = a3;
  v38 = v79;
  if (v32 || v33 > a3)
    goto LABEL_69;
LABEL_60:
  if (v20)
  {
    v44 = *((_DWORD *)v20 + 2);
    v45 = *((_DWORD *)v20 + 3);
    v46 = bswap32(v44);
    if (v7)
      v44 = v46;
    v47 = bswap32(v45);
    if (v7)
      v45 = v47;
    v32 = __CFADD__(v44, v45);
    v48 = v44 + v45;
    if (v32)
    {
      log_error(a5, "malformed mach-o file, LC_CODE_SIGNATURE offset + size overflows\n");
    }
    else if (v48 >= v37 - 7)
    {
      v64 = bswap32(v35);
      if (!v7)
        v64 = v35;
      *((_DWORD *)v20 + 3) = v64;
      v65 = *v34;
      v32 = __CFADD__(v44, v35);
      v63 = v44 + v35;
      *v34 = v63;
      if (!v32)
      {
        if (v65 > v63)
        {
          bzero((char *)v36 + v63, v65 - v63);
          v63 = *v34;
        }
        goto LABEL_112;
      }
      log_error(a5, "mew sigSpace causes overflow\n");
    }
    else
    {
      log_error(a5, "malformed mach-o file, LC_CODE_SIGNATURE does not point to end of file\n");
    }
    return 0;
  }
  v50 = 0;
  v51 = 1;
  v52 = 96;
  while (2)
  {
    v53 = bswap32(*(_DWORD *)v21);
    if (!v7)
      v53 = *(_DWORD *)v21;
    v54 = bswap32(*((_DWORD *)v21 + 1));
    if (!v7)
      v54 = *((_DWORD *)v21 + 1);
    if (v53 != 25)
    {
      if (v53 == 1 && !*((_DWORD *)v21 + 8) && *((_DWORD *)v21 + 9) && *((_DWORD *)v21 + 12))
        goto LABEL_129;
      goto LABEL_85;
    }
    if (*((_QWORD *)v21 + 5) || !*((_QWORD *)v21 + 6) || !*((_DWORD *)v21 + 16))
    {
LABEL_85:
      v21 += v54;
      v51 = ++v50 < v15;
      if (v15 == v50)
        goto LABEL_86;
      continue;
    }
    break;
  }
  v52 = 120;
LABEL_129:
  LODWORD(v52) = *(_DWORD *)&v21[v52];
  v78 = bswap32(v52);
  if (v7)
    v52 = v78;
  else
    v52 = v52;
  if (v51 && v38 + 16 > v52)
  {
    log_error(a5, "not enough room in load commands to add LC_CODE_SIGNATURE\n");
    return 0;
  }
LABEL_86:
  v55 = v38 + 16;
  v56 = bswap32(v38 + 16);
  if (v7)
    v55 = v56;
  v57 = bswap32(v15 + 1);
  if (!v7)
    v57 = v15 + 1;
  v36[4] = v57;
  v36[5] = v55;
  if (v7)
    v58 = 486539264;
  else
    v58 = 29;
  if (v7)
    v59 = 0x10000000;
  else
    v59 = 16;
  *v22 = v58;
  v22[1] = v59;
  v60 = (v37 + 15) & 0xFFFFFFF0;
  v61 = bswap32(v60);
  if (!v7)
    v61 = (v37 + 15) & 0xFFFFFFF0;
  v62 = bswap32(v35);
  if (!v7)
    v62 = v35;
  v22[2] = v61;
  v22[3] = v62;
  v32 = __CFADD__(v60, v35);
  v63 = v60 + v35;
  *v34 = v63;
  if (v32)
  {
    log_error(a5, "sigSpace + appendOffset overflows\n");
    return 0;
  }
LABEL_112:
  if (v19)
  {
    v66 = *((_DWORD *)v19 + 8);
    v67 = bswap32(v66);
    if (v7)
      v66 = v67;
    v68 = v63 - v66;
    v69 = (v68 + 0x3FFF) & 0xFFFFC000;
    v70 = bswap32(v68);
    if (v7)
      v68 = v70;
    *((_DWORD *)v19 + 9) = v68;
    v71 = bswap32(v69);
    if (!v7)
      v71 = v69;
    *((_DWORD *)v19 + 7) = v71;
  }
  else
  {
    v72 = *((_QWORD *)v18 + 5);
    v73 = bswap64(v72);
    if (v7)
      v72 = v73;
    v74 = v63 - v72;
    v75 = (v74 + 0x3FFF) & 0xFFFFFFFFFFFFC000;
    v76 = bswap64(v74);
    if (v7)
      v74 = v76;
    *((_QWORD *)v18 + 6) = v74;
    v77 = bswap64(v75);
    if (!v7)
      v77 = v75;
    *((_QWORD *)v18 + 4) = v77;
  }
  return 1;
}

uint64_t writeFile(const char *a1, char *a2, unsigned int a3, char **a4)
{
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  size_t v11;
  ssize_t v12;

  v7 = open(a1, 1537, 511);
  if (v7 == -1)
  {
    __error();
    log_error(a4, "can't open output file for writing: %s, errno=%d\n");
  }
  else
  {
    v8 = v7;
    v9 = 0;
    if (a3)
    {
      v10 = a3;
      while (1)
      {
        v11 = v10 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : v10;
        v12 = write(v8, a2, v11);
        if (v12 == -1)
          break;
        if (v12)
        {
          a2 += v12;
          v9 += v12;
          v10 -= v12;
          if (v10)
            continue;
        }
        goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      if (v9 == a3)
      {
        close(v8);
        return 1;
      }
    }
    __error();
    log_error(a4, "can't write to output file (len: %d): %s, errno=%d\n");
  }
  return 0;
}

BOOL vm_dealloc(void **a1, uint64_t a2, char **a3)
{
  int v5;

  v5 = MEMORY[0x18D771618](*MEMORY[0x1E0C83DA0], *a1, a2);
  if (v5)
    log_error(a3, "failed to deallocate memory\n");
  else
    *a1 = 0;
  return v5 == 0;
}

uint64_t remove_signature_space(_DWORD *a1, unsigned int a2, unsigned int *a3, char **a4)
{
  int v4;
  BOOL v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  BOOL v30;
  unsigned int v31;
  unsigned int *v32;
  _DWORD *v33;
  unsigned int v34;
  int v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  size_t v45;
  unsigned int v46;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  int v60;
  char **v64;

  v4 = *a1;
  v5 = *a1 == -822415874 || v4 == -805638658;
  v6 = v5;
  v7 = a1[3];
  v8 = bswap32(v7);
  if (v5)
    v7 = v8;
  if (v7 > 0xB || ((1 << v7) & 0x9C4) == 0)
  {
    log_error(a4, "mach-o filetype (%d) does not support code signing");
    return 0;
  }
  v10 = v4 == -805638658 || v4 == -17958193;
  v11 = 7;
  if (v10)
    v11 = 8;
  v12 = a1[5];
  v13 = bswap32(a1[4]);
  if (v6)
    v14 = v13;
  else
    v14 = a1[4];
  LODWORD(v15) = bswap32(v12);
  if (v6)
    v15 = v15;
  else
    v15 = v12;
  if (!v14)
    goto LABEL_70;
  v64 = a4;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = (char *)&a1[v11];
  v60 = v15;
  v21 = (char *)&a1[v11] + v15;
  do
  {
    v22 = *(_DWORD *)v20;
    v23 = bswap32(*(_DWORD *)v20);
    if (v6)
      v22 = v23;
    v24 = bswap32(*((_DWORD *)v20 + 1));
    if (v6)
      v25 = v24;
    else
      v25 = *((_DWORD *)v20 + 1);
    switch(v22)
    {
      case 1u:
        if (!strcmp(v20 + 8, "__LINKEDIT"))
          v18 = v20;
        break;
      case 0x19u:
        if (!strcmp(v20 + 8, "__LINKEDIT"))
          v17 = v20;
        break;
      case 0x1Du:
        v19 = v20;
        break;
    }
    v20 += v25;
    if (v20 > v21)
    {
      log_error(v64, "malformed mach-o file, load command #%d is outside size of load commands\n");
      return 0;
    }
    ++v16;
  }
  while (v14 != v16);
  if (!v18)
  {
    v32 = a3;
    a4 = v64;
    v33 = a1;
    v34 = a2;
    v35 = v60;
    if (v17)
    {
      v36 = *((_QWORD *)v17 + 5);
      v37 = *((_QWORD *)v17 + 6);
      v38 = bswap64(v36);
      if (v6)
        v36 = v38;
      v39 = bswap64(v37);
      if (v6)
        v37 = v39;
      v30 = __CFADD__(v36, v37);
      v40 = v36 + v37;
      if (v30 || v40 > a2)
        goto LABEL_71;
      goto LABEL_60;
    }
LABEL_70:
    log_error(a4, "malformed mach-o file, no __LINKEDIT segment\n");
    return 0;
  }
  v26 = *((_DWORD *)v18 + 8);
  v27 = *((_DWORD *)v18 + 9);
  v28 = bswap32(v26);
  if (v6)
    v26 = v28;
  v29 = bswap32(v27);
  if (v6)
    v27 = v29;
  v30 = __CFADD__(v26, v27);
  v31 = v26 + v27;
  v32 = a3;
  a4 = v64;
  v33 = a1;
  v34 = a2;
  v35 = v60;
  if (v30 || v31 > a2)
  {
LABEL_71:
    log_error(a4, "malformed mach-o file, __LINKEDIT segment extends past end of file\n");
    return 0;
  }
LABEL_60:
  if (!v19)
    return 1;
  v41 = *((_DWORD *)v19 + 3);
  v42 = bswap32(*((_DWORD *)v19 + 2));
  if (v6)
    v43 = v42;
  else
    v43 = *((_DWORD *)v19 + 2);
  v44 = bswap32(v41);
  if (v6)
    v45 = v44;
  else
    v45 = v41;
  v46 = v43 + v45;
  if (__CFADD__(v43, (_DWORD)v45))
  {
    log_error(a4, "malformed mach-o file, LC_CODE_SIGNATURE wraps around\n");
    return 0;
  }
  if (v46 < v34 - 7)
  {
    log_error(a4, "malformed mach-o file, LC_CODE_SIGNATURE does not point to end of file\n");
    return 0;
  }
  if (v46 > *v32)
  {
    log_error(a4, "malformed mach-o file, LC_CODE_SIGNATURE points past the end of the mach-o\n");
    return 0;
  }
  bzero((char *)v33 + v43, v45);
  *v32 = v43;
  v48 = v14 - 1;
  v49 = bswap32(v14 - 1);
  if (v6)
    v48 = v49;
  *(_QWORD *)v19 = 0;
  *((_QWORD *)v19 + 1) = 0;
  v50 = bswap32(v35 - 16);
  if (!v6)
    v50 = v35 - 16;
  v33[4] = v48;
  v33[5] = v50;
  if (v19 + 16 < v21)
  {
    memmove(v19, v19 + 16, v21 - (v19 + 16));
    *((_QWORD *)v21 - 2) = 0;
    *((_QWORD *)v21 - 1) = 0;
  }
  v51 = *v32;
  if (v18)
  {
    v52 = *((_DWORD *)v18 + 8);
    v53 = bswap32(v52);
    if (v6)
      v52 = v53;
    v54 = v51 - v52;
    v55 = bswap32(v54);
    if (v6)
      v54 = v55;
    *((_DWORD *)v18 + 9) = v54;
  }
  else
  {
    v56 = *((_QWORD *)v17 + 5);
    v57 = bswap64(v56);
    if (v6)
      v56 = v57;
    v58 = v51 - v56;
    v59 = bswap64(v58);
    if (v6)
      v58 = v59;
    *((_QWORD *)v17 + 6) = v58;
  }
  return 1;
}

_QWORD *Security::CodeSigning::DiskRep::resourcesRootPath@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18AA61AAF);
}

uint64_t Security::CodeSigning::DiskRep::mainExecutableImage(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

uint64_t Security::CodeSigning::DiskRep::signingBase(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

uint64_t Security::CodeSigning::DiskRep::execSegBase()
{
  return 0;
}

CFArrayRef Security::CodeSigning::DiskRep::modifiedFiles(Security::CodeSigning::DiskRep *this)
{
  const __CFURL *v1;
  void **v2;
  CFURLRef CFURL;
  const void *v4;
  CFURLRef v5;
  CFArrayRef CFArray;
  void *__p[2];
  char v9;
  CFURLRef v10;

  (*(void (**)(void **__return_ptr))(*(_QWORD *)this + 40))(__p);
  if (v9 >= 0)
    v2 = __p;
  else
    v2 = (void **)__p[0];
  CFURL = Security::makeCFURL((Security *)v2, 0, 0, v1);
  v5 = CFURL;
  v10 = CFURL;
  if (v9 < 0)
    operator delete(__p[0]);
  CFArray = Security::makeCFArray(CFURL, v4, v5);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v10);
  return CFArray;
}

void sub_18AA33684(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  uint64_t v16;

  Security::CFRef<__CFURL const*>::~CFRef((const void **)(v16 - 24));
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::DiskRep::copyDiskRepInformation(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

uint64_t Security::CodeSigning::DiskRep::copyStapledTicket(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

_QWORD *Security::CodeSigning::DiskRep::explicitIdentifier@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18AA61AAF);
}

uint64_t Security::CodeSigning::DiskRep::defaultResourceRules()
{
  return 0;
}

uint64_t Security::CodeSigning::DiskRep::defaultRequirements()
{
  return 0;
}

uint64_t Security::CodeSigning::DiskRep::pageSize()
{
  return 0;
}

void Security::CodeSigning::DiskRep::strictValidate(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  BOOL v9;
  uint64_t *v10;

  if ((a4 & 0x100) != 0)
  {
    v6 = *(_QWORD *)(a3 + 8);
    v4 = a3 + 8;
    v5 = v6;
    if (!v6)
      goto LABEL_13;
    v7 = v4;
    do
    {
      v8 = *(_DWORD *)(v5 + 28);
      v9 = v8 < -67002;
      if (v8 >= -67002)
        v10 = (uint64_t *)v5;
      else
        v10 = (uint64_t *)(v5 + 8);
      if (!v9)
        v7 = v5;
      v5 = *v10;
    }
    while (*v10);
    if (v7 == v4 || *(int *)(v7 + 28) > -67002)
LABEL_13:
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA46);
  }
}

uint64_t Security::CodeSigning::DiskRep::allowedResourceOmissions(Security::CodeSigning::DiskRep *this)
{
  return 0;
}

void Security::CodeSigning::DiskRep::writer(Security::CodeSigning::DiskRep *this)
{
  Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA00);
}

uint64_t Security::CodeSigning::DiskRep::Writer::attributes(Security::CodeSigning::DiskRep::Writer *this)
{
  return *((unsigned int *)this + 5);
}

void Security::CodeSigning::DiskRep::Writer::remove(Security::CodeSigning::DiskRep::Writer *this)
{
  Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA23);
}

void Security::CodeSigning::DiskRep::canonicalIdentifier(std::string *a1, uint64_t a2)
{
  std::string::size_type v3;
  unsigned __int8 v4;
  std::string *v5;
  std::string::size_type size;
  std::string *p_str;
  std::string::size_type v8;
  int v9;
  int v10;
  char *v11;
  std::string::size_type v12;
  std::string::size_type v13;
  std::string *v14;
  std::string::size_type v15;
  _BOOL8 v16;
  std::string::size_type v17;
  std::string::size_type v18;
  uint64_t v19;
  std::string v20;
  std::string __str;
  char v22;

  memset(&__str, 170, sizeof(__str));
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __str = *(std::string *)a2;
  v3 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  v4 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  size = __str.__r_.__value_.__l.__size_;
  v5 = (std::string *)__str.__r_.__value_.__r.__words[0];
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_str = &__str;
  else
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v8 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  else
    v8 = __str.__r_.__value_.__l.__size_;
  if (v8)
  {
    while (v8)
    {
      v9 = p_str->__r_.__value_.__s.__data_[--v8];
      if (v9 == 47)
      {
        if (v8 != -1)
        {
          std::string::basic_string(&v20, &__str, v8 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v22);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__str.__r_.__value_.__l.__data_);
          __str = v20;
          v3 = HIBYTE(v20.__r_.__value_.__r.__words[2]);
          size = v20.__r_.__value_.__l.__size_;
          v5 = (std::string *)v20.__r_.__value_.__r.__words[0];
          v4 = HIBYTE(v20.__r_.__value_.__r.__words[2]);
        }
        break;
      }
    }
  }
  if ((v4 & 0x80u) != 0)
    v3 = size;
  else
    v5 = &__str;
  if (v3)
  {
    while (v3)
    {
      v10 = v5->__r_.__value_.__s.__data_[--v3];
      if (v10 == 46)
      {
        v11 = (char *)v5 + v3;
        v12 = v11 - (char *)v5;
        if (v11 - (char *)v5 == -1 || memchr("0123456789", v11[1], 0xBuLL))
          break;
        std::string::basic_string(&v20, &__str, 0, v12, (std::allocator<char> *)&v22);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__str.__r_.__value_.__l.__data_);
        __str = v20;
        v4 = HIBYTE(v20.__r_.__value_.__r.__words[2]);
        if ((*((_BYTE *)&v20.__r_.__value_.__s + 23) & 0x80) == 0)
          goto LABEL_26;
        goto LABEL_31;
      }
    }
  }
  if ((v4 & 0x80) != 0)
  {
LABEL_31:
    v14 = (std::string *)__str.__r_.__value_.__r.__words[0];
    if (!memchr("0123456789.", *__str.__r_.__value_.__l.__data_, 0xCuLL))
    {
      v13 = __str.__r_.__value_.__l.__size_;
      goto LABEL_34;
    }
LABEL_32:
    *a1 = __str;
    return;
  }
LABEL_26:
  if (memchr("0123456789.", __str.__r_.__value_.__s.__data_[0], 0xCuLL))
    goto LABEL_32;
  v13 = v4;
  v14 = &__str;
  do
LABEL_34:
    v15 = v13--;
  while (memchr("0123456789.", v14->__r_.__value_.__s.__data_[v13], 0xCuLL));
  v16 = v14->__r_.__value_.__s.__data_[v15] == 46;
  if (v14->__r_.__value_.__s.__data_[v15] == 46)
    v17 = v15 + 1;
  else
    v17 = v15;
  if ((v4 & 0x80u) == 0)
    v18 = v4;
  else
    v18 = __str.__r_.__value_.__l.__size_;
  if (v17 < v18)
  {
    v19 = (uint64_t)v14->__r_.__value_.__r.__words + v16 + 1;
    while (memchr("0123456789", *(char *)(v19 + v13), 0xBuLL))
    {
      ++v19;
      if (++v17 >= v18)
      {
        v17 = v18;
        break;
      }
    }
  }
  std::string::basic_string(a1, &__str, 0, v17, (std::allocator<char> *)&v20);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
}

void sub_18AA33A34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::FileDiskRep::~FileDiskRep(void **this)
{
  *this = off_1E1FC8C10;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);
}

{
  *this = off_1E1FC8C10;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 5));
  if (*((char *)this + 39) < 0)
    operator delete(this[2]);
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)this);
  JUMPOUT(0x18D76FAA0);
}

CFDataRef Security::CodeSigning::FileDiskRep::component(Security::CodeSigning::FileDiskRep *this, Security::CodeSigning::CodeDirectory *a2)
{
  const char *v3;
  int *v4;
  std::string *p_p;
  ssize_t v6;
  size_t v7;
  int *v8;
  std::string *v9;
  CFDataRef v10;
  int *v12;
  int *v13;
  void *value[2];
  std::string __p;

  v3 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
  if (!v3)
    return 0;
  memset(&__p, 170, sizeof(__p));
  Security::CodeSigning::FileDiskRep::attrName(&__p, v3);
  v4 = (int *)(*(uint64_t (**)(Security::CodeSigning::FileDiskRep *))(*(_QWORD *)this + 144))(this);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  v6 = fgetxattr(*v4, (const char *)p_p, 0, 0, 0, 0);
  v7 = v6;
  if (v6 == -1)
  {
    if (*__error() != 93)
    {
      v12 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v12);
    }
  }
  else if ((v6 & 0x8000000000000000) == 0)
  {
    value[0] = (void *)0xAAAAAAAAAAAAAAAALL;
    value[1] = (void *)0xAAAAAAAAAAAAAAAALL;
    Security::CFMallocData::CFMallocData((Security::CFMallocData *)value, v6);
    v8 = (int *)(*(uint64_t (**)(Security::CodeSigning::FileDiskRep *))(*(_QWORD *)this + 144))(this);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v9 = &__p;
    else
      v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
    if (fgetxattr(*v8, (const char *)v9, value[0], v7, 0, 0) == -1 && *__error() != 93)
    {
      v13 = __error();
      Security::UnixError::throwMe((Security::UnixError *)*v13);
    }
    v10 = Security::CFMallocData::operator __CFData const*((uint64_t)value);
    if (value[0])
      free(value[0]);
    goto LABEL_17;
  }
  v10 = 0;
LABEL_17:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v10;
}

void sub_18AA33C5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  int v18;

  if (a2 == 1)
  {
    v18 = *((_DWORD *)__cxa_begin_catch(exception_object) + 36);
    if (v18 != 45 && v18 != 1)
      __cxa_rethrow();
    __cxa_end_catch();
    JUMPOUT(0x18AA33C14);
  }
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_18AA33CB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  __cxa_end_catch();
  if (a17 < 0)
    operator delete(a12);
  _Unwind_Resume(a1);
}

_QWORD *Security::CodeSigning::FileDiskRep::format@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, "generic");
}

_DWORD *Security::CodeSigning::FileDiskRep::defaultRequirements(uint64_t a1, uint64_t a2, void (***a3)(void **__return_ptr, _QWORD, void **))
{
  __int128 v4;
  unsigned int *v5;
  unint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  NSObject *v9;
  __int128 v10;
  char *v11;
  unsigned int *v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  const Security::CFClass *v16;
  Security::CodeSigning::SecStaticCode *v17;
  unsigned __int8 *v18;
  unsigned __int8 v19;
  const void *v20;
  Security::BlobCore *v21;
  uint64_t *v22;
  char v23;
  unint64_t v25;
  void *v26[3];
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *__p[2];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  unint64_t v37;
  _OWORD v38[16];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v4 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v38[14] = v4;
  v38[15] = v4;
  v38[12] = v4;
  v38[13] = v4;
  v38[10] = v4;
  v38[11] = v4;
  v38[8] = v4;
  v38[9] = v4;
  v38[6] = v4;
  v38[7] = v4;
  v38[4] = v4;
  v38[5] = v4;
  v38[2] = v4;
  v38[3] = v4;
  v38[0] = v4;
  v38[1] = v4;
  v5 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 144))(a1);
  v6 = Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*v5, v38, 0x100uLL, 0);
  v7 = 0;
  if (v6 < 4 || LOBYTE(v38[0]) != 35 || BYTE1(v38[0]) != 33 || BYTE2(v38[0]) != 47)
    return v7;
  v7 = (_DWORD *)((char *)v38 + 2);
  v8 = 255;
  if (v6 != 256)
    v8 = v6;
  *((_BYTE *)v38 + v8) = 0;
  *((_BYTE *)v38 + strcspn((const char *)v38 + 2, " \t\n\r\f") + 2) = 0;
  v9 = secLogObjForScope("filediskrep");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(__p[0]) = 136315138;
    *(void **)((char *)__p + 4) = (char *)v38 + 2;
    _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "looks like a script for %s", (uint8_t *)__p, 0xCu);
  }
  if (!BYTE3(v38[0]))
    return 0;
  memset(v26, 170, sizeof(v26));
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)v38 + 2);
  (**a3)(v26, a3, __p);
  if (SBYTE7(v34) < 0)
    operator delete(__p[0]);
  v37 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v35 = v10;
  v36 = v10;
  *(_OWORD *)__p = v10;
  v34 = v10;
  if (SHIBYTE(v26[2]) >= 0)
    v11 = (char *)v26;
  else
    v11 = (char *)v26[0];
  v27 = (uint64_t *)0xFFFFFFFF00000000;
  v28 = 0;
  v29 = 0;
  v31 = 0;
  v32 = 0;
  v30 = 0xAAAAAAAAAAAAAA01;
  v12 = (unsigned int *)Security::CodeSigning::DiskRep::bestGuess(v11, (unsigned int *)&v27);
  Security::Mutex::Mutex((pthread_mutex_t *)&__p[1]);
  if (v12)
  {
    v13 = v12 + 2;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    __p[0] = v12;
    v25 = 0xAAAAAAAAAAAAAAAALL;
    v15 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
    v17 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate((Security::SecCFObject *)0x288, *(_QWORD *)(v15 + 200), v16);
    Security::CodeSigning::SecStaticCode::SecStaticCode(v17, (Security::CodeSigning::DiskRep *)__p[0], 0);
    v18 = (unsigned __int8 *)v17 - 8;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(1u, v18));
    if ((v19 & 1) != 0)
    {
      v20 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)v17 + 16))(v17);
      CFRetain(v20);
    }
    v25 = (unint64_t)v17;
    v21 = (Security::BlobCore *)Security::CodeSigning::SecStaticCode::designatedRequirement(v17);
    if (v21)
    {
      v28 = 0;
      v29 = 0;
      v27 = &v28;
      v22 = (uint64_t *)Security::Blob<Security::CodeSigning::Requirement,4208856064u>::clone(v21);
      Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add(&v27, 1u, v22);
      v7 = Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::make(&v27);
      Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)&v27);
      Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v25);
      v23 = 0;
      goto LABEL_27;
    }
    Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v25);
  }
  else
  {
    __p[0] = 0;
  }
  v23 = 1;
LABEL_27:
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(__p);
  if (SHIBYTE(v26[2]) < 0)
    operator delete(v26[0]);
  if ((v23 & 1) != 0)
    return 0;
  return v7;
}

void sub_18AA34004(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t buf,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  char *v27;
  NSObject *v29;

  if (a2)
  {
    Security::SecCFObject::operator delete(v27);
    Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(&buf);
    if (a15 < 0)
      operator delete(__p);
    __cxa_begin_catch(exception_object);
    v29 = secLogObjForScope("filediskrep");
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf) = 0;
      _os_log_debug_impl(&dword_18A900000, v29, OS_LOG_TYPE_DEBUG, "exception getting host requirement (ignored)", (uint8_t *)&buf, 2u);
    }
    __cxa_end_catch();
    JUMPOUT(0x18AA33F90);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::FileDiskRep::writer(Security::CodeSigning::FileDiskRep *this)
{
  uint64_t v2;

  v2 = operator new();
  Security::CodeSigning::SingleDiskRep::Writer::Writer((Security::CodeSigning::SingleDiskRep::Writer *)v2, this, 1);
  *(_QWORD *)v2 = &off_1E1FC8578;
  *(_QWORD *)(v2 + 104) = 0;
  Security::Mutex::Mutex((pthread_mutex_t *)(v2 + 112));
  *(_QWORD *)(v2 + 192) = 0;
  *(_QWORD *)(v2 + 184) = 0;
  *(_QWORD *)(v2 + 176) = v2 + 184;
  return v2;
}

void sub_18AA34164(_Unwind_Exception *a1)
{
  Security::CodeSigning::SingleDiskRep::Writer *v1;

  Security::CodeSigning::SingleDiskRep::Writer::~Writer(v1);
  MEMORY[0x18D76FAA0](v1, 0x10A1C40DCF3D2E7);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SingleDiskRep::Writer::~Writer(Security::CodeSigning::SingleDiskRep::Writer *this)
{
  *(_QWORD *)this = off_1E1FC8BC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::SingleDiskRep::Writer *)((char *)this + 96));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer((_QWORD *)this + 3);
}

void Security::CodeSigning::FileDiskRep::Writer::~Writer(char **this)
{
  *this = (char *)&off_1E1FC8578;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::FileDiskRep>::~RefPointer(this + 13);
  *this = (char *)off_1E1FC8BC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 12));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer(this + 3);
}

{
  *this = (char *)&off_1E1FC8578;
  std::__tree<std::string>::destroy(this[23]);
  Security::RefPointer<Security::CodeSigning::FileDiskRep>::~RefPointer(this + 13);
  *this = (char *)off_1E1FC8BC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(this + 12));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer(this + 3);
  JUMPOUT(0x18D76FAA0);
}

void Security::CodeSigning::FileDiskRep::Writer::component(Security::CodeSigning::FileDiskRep::Writer *this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
  const char *v5;
  int *v6;
  const UInt8 *BytePtr;
  CFIndex Length;
  std::string *p_p;
  uint64_t **v10;
  uint64_t **v11;
  uint64_t **v12;
  uint64_t *v13;
  std::string *v14;
  int *v15;
  std::string __p;
  uint64_t v17;

  memset(&__p, 170, sizeof(__p));
  v5 = Security::CodeSigning::CodeDirectory::canonicalSlotName(a2);
  Security::CodeSigning::FileDiskRep::attrName(&__p, v5);
  v6 = (int *)Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  BytePtr = CFDataGetBytePtr(a3);
  Length = CFDataGetLength(a3);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if (fsetxattr(*v6, (const char *)p_p, BytePtr, Length, 0, 0) == -1)
  {
    v15 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v15);
  }
  v10 = (uint64_t **)((char *)this + 176);
  v17 = 0xAAAAAAAAAAAAAAAALL;
  v11 = (uint64_t **)std::__tree<std::string>::__find_equal<std::string>((uint64_t)v10, &v17, &__p);
  if (!*v11)
  {
    v12 = v11;
    v13 = (uint64_t *)operator new(0x38uLL);
    v14 = (std::string *)(v13 + 4);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(v14, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else
    {
      *(_OWORD *)&v14->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      v13[6] = __p.__r_.__value_.__r.__words[2];
    }
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(v10, v17, v12, v13);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_18AA343CC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __break(1u);
}

void sub_18AA3443C()
{
  __cxa_end_catch();
  JUMPOUT(0x18AA34444);
}

void Security::CodeSigning::FileDiskRep::Writer::remove(Security::CodeSigning::FileDiskRep::Writer *this)
{
  Security::CodeSigning::CodeDirectory *v2;
  const char *v3;
  const char *v4;
  Security::UnixPlusPlus::FileDesc *v5;
  std::string *v6;
  Security::UnixPlusPlus::FileDesc *v7;
  std::string *p_p;
  std::string __p;

  v2 = 0;
  do
  {
    v3 = Security::CodeSigning::CodeDirectory::canonicalSlotName(v2);
    if (v3)
    {
      v4 = v3;
      v5 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
      Security::CodeSigning::FileDiskRep::attrName(&__p, v4);
      v6 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &__p
         : (std::string *)__p.__r_.__value_.__r.__words[0];
      Security::UnixPlusPlus::FileDesc::removeAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v5, (const char *)v6);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    v2 = (Security::CodeSigning::CodeDirectory *)((_DWORD)v2 + 1);
  }
  while ((_DWORD)v2 != 12);
  v7 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  Security::CodeSigning::FileDiskRep::attrName(&__p, "CodeSignature");
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  Security::UnixPlusPlus::FileDesc::removeAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v7, (const char *)p_p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_18AA34530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::FileDiskRep::Writer::flush(Security::CodeSigning::FileDiskRep::Writer *this)
{
  Security::UnixPlusPlus::FileDesc *v2;
  ssize_t v3;
  int64_t v4;
  char *v5;
  Security::UnixPlusPlus::FileDesc *v6;
  char *v7;
  size_t v8;
  Security::UnixPlusPlus::FileDesc *v9;
  std::string *v10;
  std::string v11;

  v2 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  v3 = Security::UnixPlusPlus::FileDesc::listAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v2, 0, 0);
  v4 = v3;
  if (v3)
  {
    if (v3 < 0)
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    v5 = (char *)operator new(v3);
    bzero(v5, v4);
  }
  else
  {
    v5 = 0;
  }
  v6 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
  Security::UnixPlusPlus::FileDesc::listAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v6, v5, v4);
  if (v4 >= 1)
  {
    v7 = v5;
    do
    {
      memset(&v11, 170, sizeof(v11));
      std::string::basic_string[abi:ne180100]<0>(&v11, v7);
      v8 = strlen(v7);
      if (!std::string::compare(&v11, 0, 0xDuLL, "com.apple.cs.")
        && (_QWORD *)((char *)this + 184) == std::__tree<std::string>::find<std::string>((uint64_t)this + 176, &v11))
      {
        v9 = Security::CodeSigning::SingleDiskRep::Writer::fd(this);
        if ((v11.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v10 = &v11;
        else
          v10 = (std::string *)v11.__r_.__value_.__r.__words[0];
        Security::UnixPlusPlus::FileDesc::removeAttr((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)v9, (const char *)v10);
      }
      if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v11.__r_.__value_.__l.__data_);
      v7 += v8 + 1;
    }
    while (v7 < &v5[v4]);
  }
  if (v5)
    operator delete(v5);
}

void sub_18AA346AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;

  if (v15)
    operator delete(v15);
  _Unwind_Resume(exception_object);
}

void Security::CodeSigning::FileDiskRep::attrName(std::string *this, const char *a2)
{
  std::string::size_type v4;
  std::string *v5;
  std::string v6;

  std::string::basic_string[abi:ne180100]<0>(&v6, "com.apple.cs.");
  v4 = strlen(a2);
  v5 = std::string::append(&v6, a2, v4);
  *this = *v5;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v6.__r_.__value_.__l.__data_);
}

void sub_18AA34758(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *Security::RefPointer<Security::CodeSigning::FileDiskRep>::~RefPointer(_QWORD *a1)
{
  pthread_mutex_t *v2;
  Security::UnixError *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  _QWORD v8[2];

  v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01;
  v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3)
    Security::UnixError::throwMe(v3);
  if (*a1)
  {
    v4 = (unsigned int *)(*a1 + 8);
    do
    {
      v5 = __ldxr(v4);
      v6 = v5 - 1;
    }
    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1)
        (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 8))(*a1);
      *a1 = 0;
    }
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

Security::CodeSigning::FileDiskRep *Security::CodeSigning::FileDiskRep::FileDiskRep(Security::CodeSigning::FileDiskRep *this, char *a2)
{
  void *__p[2];
  char v5;

  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  Security::CodeSigning::SingleDiskRep::SingleDiskRep((uint64_t)this, (__int128 *)__p);
  if (v5 < 0)
    operator delete(__p[0]);
  *(_QWORD *)this = off_1E1FC85C0;
  return this;
}

void sub_18AA34874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  *(_QWORD *)v15 = off_1E1FC8C10;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)(v15 + 40));
  if (*(char *)(v15 + 39) < 0)
    operator delete(*(void **)(v15 + 16));
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)v15);
  _Unwind_Resume(a1);
}

const void **Security::CFRef<__SecCertificate *>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void Security::CodeSigning::BlobEditor::~BlobEditor(Security::CodeSigning::BlobEditor *this)
{
  char *v2;

  *(_QWORD *)this = &off_1E1FC83F8;
  v2 = (char *)this + 56;
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 80);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)v2);
  Security::CodeSigning::ArchEditor::~ArchEditor(this);
}

{
  char *v2;

  *(_QWORD *)this = &off_1E1FC83F8;
  v2 = (char *)this + 56;
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 80);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)v2);
  Security::CodeSigning::ArchEditor::~ArchEditor(this);
  JUMPOUT(0x18D76FAA0);
}

void Security::CodeSigning::BlobEditor::component(uint64_t **this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
  Security::CodeSigning::EmbeddedSignatureBlob::Maker::component(this + 10, a2, a3);
}

void Security::CodeSigning::BlobEditor::write(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add((uint64_t **)(a1 + 56), *(_DWORD *)(a2 + 48), a3);
}

void Security::CodeSigning::BlobEditor::commit(Security::CodeSigning::BlobEditor *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  int v14;
  char *v15;
  char *v16;
  char *v17;
  BOOL v18;
  unsigned int v19;
  Security::BlobCore *v20;
  Security::BlobCore *v21;
  unsigned int v22;
  char *v23;
  unsigned int v24;
  unsigned int v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  __int128 v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  NSObject *v35;
  Security::CodeSigning::SecCodeSigner::Signer *v36;
  void **v37;
  void *__dst[2];
  char v39;
  _OWORD v40[4];
  void *__p[2];
  __int128 v42;
  __int128 v43;
  _OWORD v44[9];
  unint64_t v45;
  uint8_t buf[4];
  void **v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  v9 = (uint64_t **)((char *)this + 56);
  v10 = (uint64_t *)Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make((uint64_t)this + 80, a2, a3, a4, a5, a6, a7, a8);
  Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add(v9, 0, v10);
  v11 = *((_QWORD *)this + 9);
  v12 = (char *)*((_QWORD *)this + 7);
  v13 = (char *)this + 64;
  if (v12 == (char *)this + 64)
  {
    v14 = 0;
  }
  else
  {
    v14 = 0;
    do
    {
      v15 = (char *)*((_QWORD *)v12 + 1);
      v16 = v12;
      if (v15)
      {
        do
        {
          v17 = v15;
          v15 = *(char **)v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          v17 = (char *)*((_QWORD *)v16 + 2);
          v18 = *(_QWORD *)v17 == (_QWORD)v16;
          v16 = v17;
        }
        while (!v18);
      }
      v14 += bswap32(*(_DWORD *)(*((_QWORD *)v12 + 5) + 4));
      v12 = v17;
    }
    while (v17 != v13);
  }
  v19 = v14 + 8 * v11 + 12;
  v20 = (Security::BlobCore *)malloc_type_malloc(v19, 0x79CB62BEuLL);
  if (!v20)
    Security::UnixError::throwMe((Security::UnixError *)0xC);
  v21 = v20;
  v22 = *((_DWORD *)this + 18);
  *(_DWORD *)v20 = -1056121094;
  *((_DWORD *)v20 + 1) = bswap32(v19);
  *((_DWORD *)v20 + 2) = bswap32(v22);
  v23 = (char *)*((_QWORD *)this + 7);
  if (v23 != v13)
  {
    v24 = 0;
    v25 = 8 * v11 + 12;
    do
    {
      v26 = (char *)v21 + 8 * v24;
      *((_DWORD *)v26 + 3) = bswap32(*((_DWORD *)v23 + 8));
      *((_DWORD *)v26 + 4) = bswap32(v25);
      memcpy((char *)v21 + v25, *((const void **)v23 + 5), bswap32(*(_DWORD *)(*((_QWORD *)v23 + 5) + 4)));
      v27 = (char *)*((_QWORD *)v23 + 1);
      v28 = v23;
      if (v27)
      {
        do
        {
          v29 = v27;
          v27 = *(char **)v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          v29 = (char *)*((_QWORD *)v28 + 2);
          v18 = *(_QWORD *)v29 == (_QWORD)v28;
          v28 = v29;
        }
        while (!v18);
      }
      v25 += bswap32(*(_DWORD *)(*((_QWORD *)v23 + 5) + 4));
      ++v24;
      v23 = v29;
    }
    while (v29 != v13);
  }
  v45 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v30 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v44[7] = v30;
  v44[8] = v30;
  v44[5] = v30;
  v44[6] = v30;
  v44[3] = v30;
  v44[4] = v30;
  v44[1] = v30;
  v44[2] = v30;
  v44[0] = v30;
  v42 = v30;
  v43 = v30;
  v40[3] = v30;
  *(_OWORD *)__p = v30;
  v40[1] = v30;
  v40[2] = v30;
  v40[0] = v30;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v40);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)"Maker ", 6);
  v31 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)" assembles ", 11);
  v32 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v32, (uint64_t)" blob(s) into ", 14);
  v33 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)" (size=", 7);
  v34 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, (uint64_t)")", 1);
  v35 = secLogObjForScope("superblob");
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(__dst, (uint64_t)v40 + 8);
    v37 = v39 >= 0 ? __dst : (void **)__dst[0];
    *(_DWORD *)buf = 136315138;
    v47 = v37;
    _os_log_debug_impl(&dword_18A900000, v35, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
    if (v39 < 0)
      operator delete(__dst[0]);
  }
  *(_QWORD *)&v40[0] = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)v40 + *(_QWORD *)(*(_QWORD *)&v40[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  *((_QWORD *)&v40[0] + 1) = MEMORY[0x1E0DE4FB8] + 16;
  if (SHIBYTE(v42) < 0)
    operator delete(__p[1]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18D76FA34](v44);
  Security::CodeSigning::SecCodeSigner::returnDetachedSignature(*(CFTypeRef **)(*((_QWORD *)this + 6) + 8), v21, v36);
  free(v21);
}

void sub_18AA34D2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  a13 = *MEMORY[0x1E0DE4F60];
  *(uint64_t *)((char *)&a13 + *(_QWORD *)(a13 - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  a14 = MEMORY[0x1E0DE4FB8] + 16;
  if (a27 < 0)
    operator delete(__p);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18D76FA34](&a30);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::ArchEditor::~ArchEditor(Security::CodeSigning::ArchEditor *this)
{
  char *v2;
  char *v3;
  uint64_t v4;
  char *v5;
  char *v6;
  BOOL v7;

  *(_QWORD *)this = off_1E1FC8390;
  v2 = (char *)*((_QWORD *)this + 3);
  v3 = (char *)this + 32;
  if (v2 != (char *)this + 32)
  {
    do
    {
      v4 = *((_QWORD *)v2 + 5);
      if (v4)
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
      v5 = (char *)*((_QWORD *)v2 + 1);
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (char *)*((_QWORD *)v2 + 2);
          v7 = *(_QWORD *)v6 == (_QWORD)v2;
          v2 = v6;
        }
        while (!v7);
      }
      v2 = v6;
    }
    while (v6 != v3);
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)this + 4));
}

void Security::CodeSigning::MachOEditor::~MachOEditor(Security::CodeSigning::MachOEditor *this, std::error_code *a2)
{
  Security::CodeSigning::MachOEditor::~MachOEditor(this, a2);
  JUMPOUT(0x18D76FAA0);
}

{
  uint64_t v3;
  const std::__fs::filesystem::path *v4;

  *(_QWORD *)this = &off_1E1FC86D8;
  v3 = *((_QWORD *)this + 24);
  if (v3)
  {
    free(*(void **)(v3 + 8));
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)(v3 + 56));
    MEMORY[0x18D76FAA0](v3, 0x1020C4076728D04);
  }
  if (*((_BYTE *)this + 208))
  {
    v4 = (const std::__fs::filesystem::path *)((char *)this + 144);
    if (*((char *)this + 167) < 0)
      v4 = (const std::__fs::filesystem::path *)v4->__pn_.__r_.__value_.__r.__words[0];
    remove(v4, a2);
  }
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::MachOEditor *)((char *)this + 200));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)this + 22));
  if (*((char *)this + 167) < 0)
    operator delete(*((void **)this + 18));
  if (*((char *)this + 143) < 0)
    operator delete(*((void **)this + 15));
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer((_QWORD *)this + 6);
  Security::CodeSigning::ArchEditor::~ArchEditor(this);
}

uint64_t Security::CodeSigning::MachOEditor::component(Security::CodeSigning::MachOEditor *this, uint64_t a2, const __CFData *a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, const __CFData *))(**((_QWORD **)this + 6) + 16))(*((_QWORD *)this + 6), a2, a3);
}

uint64_t Security::CodeSigning::MachOEditor::allocate(Security::CodeSigning::MachOEditor *this)
{
  Security::CodeSigning::MachOEditor *v2;
  char v3;
  uint64_t v4;
  BOOL v5;
  Security::CodeSigning::MachOEditor *v6;
  Security::CodeSigning::MachOEditor *v7;
  const char *v8;
  const char *v9;
  _QWORD *v10;
  vm_size_t v11;
  char *v12;
  unsigned int v13;
  int v14;
  vm_size_t v15;
  const char *v16;
  const char *v17;
  unsigned int *v18;
  vm_size_t v19;
  _DWORD *v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  BOOL v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  uint64_t v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  size_t v40;
  _DWORD *v41;
  const char *v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int *v45;
  const char *v46;
  int v47;
  _BOOL4 v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  char *v53;
  __int128 v54;
  size_t v55;
  unint64_t v56;
  char *v57;
  unsigned int v58;
  unsigned int v59;
  uint64_t v60;
  char *v61;
  unsigned int *v62;
  _DWORD *v63;
  __int128 v64;
  size_t v65;
  unsigned int v66;
  unint64_t v67;
  unsigned int v68;
  unsigned int v69;
  _BOOL4 v70;
  const char *v71;
  uint64_t v72;
  uint64_t result;
  NSObject *v74;
  NSObject *v75;
  NSObject *v76;
  const char *v77;
  uint64_t v78;
  unsigned int *v79;
  unsigned int v80;
  char v81;
  _QWORD v82[2];
  unint64_t (*v83)(uint64_t, int, int);
  void *v84;
  Security::CodeSigning::MachOEditor *v85;
  char *v86;
  unsigned int v87;
  unsigned int v88;
  void *__dst;
  vm_size_t size;
  _BYTE buf[12];
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  v86 = 0;
  *((_BYTE *)this + 208) = 1;
  v2 = (Security::CodeSigning::MachOEditor *)*((_QWORD *)this + 3);
  if (v2 == (Security::CodeSigning::MachOEditor *)((char *)this + 32))
    goto LABEL_23;
  v3 = 0;
  do
  {
    v4 = *(_QWORD *)(*((_QWORD *)v2 + 5) + 120);
    v5 = v4 == 0;
    if (v4 && (v3 & 1) != 0)
    {
      v74 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_18A900000, v74, OS_LOG_TYPE_DEFAULT, "codesign allocate error: one architecture signaled removal while another signaled signing", buf, 2u);
      }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
    }
    v6 = (Security::CodeSigning::MachOEditor *)*((_QWORD *)v2 + 1);
    if (v6)
    {
      do
      {
        v7 = v6;
        v6 = *(Security::CodeSigning::MachOEditor **)v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        v7 = (Security::CodeSigning::MachOEditor *)*((_QWORD *)v2 + 2);
        v28 = *(_QWORD *)v7 == (_QWORD)v2;
        v2 = v7;
      }
      while (!v28);
    }
    v3 |= v5;
    v2 = v7;
  }
  while (v7 != (Security::CodeSigning::MachOEditor *)((char *)this + 32));
  if ((v3 & 1) == 0)
  {
LABEL_23:
    v16 = (char *)this + 120;
    if (*((char *)this + 143) < 0)
      v16 = *(const char **)v16;
    v17 = (char *)this + 144;
    if (*((char *)this + 167) < 0)
      v17 = *(const char **)v17;
    v82[0] = MEMORY[0x1E0C809B0];
    v82[1] = 0x40000000;
    v83 = ___ZN8Security11CodeSigning11MachOEditor8allocateEv_block_invoke;
    v84 = &__block_descriptor_tmp_14203;
    v85 = this;
    v86 = 0;
    *(_QWORD *)buf = 0;
    __dst = 0;
    size = 0;
    if ((mapFile(v16, (const void **)buf, (off_t *)&size, &v86) & 1) == 0)
      goto LABEL_110;
    v18 = *(unsigned int **)buf;
    v19 = size;
    if (HIDWORD(size))
    {
      log_error(&v86, "input file too large: %lld bytes\n", size);
      LODWORD(v19) = 0;
      goto LABEL_109;
    }
    v20 = 0;
    v21 = 0;
    v22 = **(_DWORD **)buf;
    if ((int)**(_DWORD **)buf > -17958195)
    {
      v23 = 0;
      if ((v22 + 17958194) < 2)
      {
LABEL_35:
        v24 = v22 & 0xFEFFFFFF;
        v25 = *(_DWORD *)(*(_QWORD *)buf + 4);
        v26 = *(_DWORD *)(*(_QWORD *)buf + 8);
        v27 = bswap32(v25);
        v28 = v24 == -822415874;
        if (v24 == -822415874)
          v29 = v27;
        else
          v29 = v25;
        v30 = bswap32(v26);
        if (v28)
          v31 = v30;
        else
          v31 = v26;
        v32 = v83((uint64_t)v82, v29, v31);
        v33 = v32;
        if (v32 == -1)
        {
          log_error(&v86, "requested signature size is too long for slice");
        }
        else
        {
          if ((v32 & 0xF) != 0)
          {
            log_error(&v86, "signature size not a multiple of 16\n");
            v34 = 0;
            v23 = 0;
            goto LABEL_89;
          }
          v35 = v19 + v32;
          v36 = __CFADD__((_DWORD)v19, v32);
          v37 = v35 + 15;
          v38 = (v35 + 15) << 31 >> 31;
          v88 = v37;
          if (v36 || v38 != v37 || v38 < 0)
          {
            log_error(&v86, "overflow calculating output size (%u + %d + 15)", v19, v32);
          }
          else
          {
            v23 = v38 & 0x1FFFFFFFFLL;
            if (vm_alloc((vm_address_t *)&__dst, v38 & 0x1FFFFFFFFLL, &v86))
            {
              v20 = __dst;
              memcpy(__dst, v18, v19);
              if (!assure_signature_space(v20, v33, v19, &v88, &v86))
              {
                v34 = 0;
                goto LABEL_89;
              }
              v21 = v88;
              goto LABEL_88;
            }
          }
        }
LABEL_109:
        munmap(v18, v19);
        goto LABEL_110;
      }
    }
    else
    {
      if (v22 != -1095041334)
      {
        if (v22 != -822415874)
        {
          v23 = 0;
          if (v22 != -805638658)
            goto LABEL_88;
        }
        goto LABEL_35;
      }
      v21 = *(_DWORD *)(*(_QWORD *)buf + 4);
      v40 = bswap32(v21);
      v41 = malloc_type_calloc(v40, 4uLL, 0x100004052888210uLL);
      v79 = v18;
      if (v21)
      {
        v42 = v17;
        v43 = 0;
        LODWORD(v44) = 0;
        v45 = v18 + 3;
        v46 = "requested signature size is too long for slice: %d\n";
        while (1)
        {
          if (bswap32(v45[2]) + bswap32(v45[1]) > v19)
          {
            log_error(&v86, "malformed fat file, slice %d extends past end of file\n", v43);
            v18 = v79;
            goto LABEL_108;
          }
          v47 = v83((uint64_t)v82, bswap32(*(v45 - 1)), bswap32(*v45));
          if (v47 == -1)
            goto LABEL_107;
          if ((v47 & 0xF) != 0)
            break;
          v41[v43] = v47;
          v44 = (v47 + v44);
          ++v43;
          v45 += 5;
          if (v40 == v43)
          {
            v18 = v79;
            v17 = v42;
            goto LABEL_78;
          }
        }
        v46 = "signature size not a multiple of 16 in slice %d\n";
LABEL_107:
        log_error(&v86, v46, v43);
        v18 = v79;
LABEL_108:
        free(v41);
        goto LABEL_109;
      }
      v44 = 0;
LABEL_78:
      v23 = (16399 * v40) + (unint64_t)v19 + v44;
      if (!vm_alloc((vm_address_t *)&__dst, v23, &v86))
        goto LABEL_108;
      v20 = __dst;
      *(_QWORD *)__dst = *(_QWORD *)v18;
      if (v21)
      {
        v77 = v17;
        v78 = (16399 * v40) + (unint64_t)v19 + v44;
        v60 = 0;
        v61 = (char *)(v20 + 4096);
        v62 = v18 + 5;
        v63 = v20 + 6;
        while (1)
        {
          v64 = *(_OWORD *)(v62 - 3);
          *v63 = v62[1];
          *((_OWORD *)v63 - 1) = v64;
          v65 = bswap32(*v62);
          memcpy(v61, (char *)v79 + bswap32(*(v62 - 1)), v65);
          v66 = v41[v60];
          v87 = v66 + v65;
          if ((assure_signature_space(v61, v66, v65, &v87, &v86) & 1) == 0)
            break;
          v67 = v61 - (char *)v20;
          if (v61 < (char *)v20)
          {
            log_error(&v86, "new architecture offset underflows");
            break;
          }
          if (HIDWORD(v67))
          {
            log_error(&v86, "new architecture offset is too large");
            break;
          }
          v68 = v87;
          v69 = bswap32(v87);
          *(v63 - 2) = bswap32(v67);
          *(v63 - 1) = v69;
          *v63 = 234881024;
          v21 = v67 + v68;
          if (__CFADD__((_DWORD)v67, v68))
          {
            log_error(&v86, "new outputsize overflows: newOffset(%d) newSliceSize(%d)\n", (_DWORD)v61 - (_DWORD)v20, v68);
            break;
          }
          v61 += (v68 + 0x3FFF) & 0xFFFFC000;
          ++v60;
          v62 += 5;
          v63 += 5;
          if (v40 == v60)
          {
            v23 = v78;
            v18 = v79;
            v17 = v77;
            goto LABEL_87;
          }
        }
        free(v41);
        v34 = 0;
        v23 = v78;
        v18 = v79;
LABEL_89:
        v70 = vm_dealloc(&__dst, v23, &v86);
        munmap(v18, v19);
        if ((v70 & v34 & 1) != 0)
          goto LABEL_90;
LABEL_110:
        v75 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v86;
          _os_log_impl(&dword_18A900000, v75, OS_LOG_TYPE_DEFAULT, "codesign allocation failed: %s", buf, 0xCu);
        }
        free(v86);
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
      }
LABEL_87:
      free(v41);
    }
LABEL_88:
    v34 = writeFile(v17, (char *)v20, v21, &v86);
    goto LABEL_89;
  }
  v8 = (char *)this + 120;
  if (*((char *)this + 143) < 0)
    v8 = *(const char **)v8;
  v9 = (char *)this + 144;
  if (*((char *)this + 167) < 0)
    v9 = *(const char **)v9;
  *(_QWORD *)buf = 0;
  __dst = 0;
  size = 0;
  if ((mapFile(v8, (const void **)buf, (off_t *)&size, &v86) & 1) == 0)
  {
LABEL_117:
    v76 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v86;
      _os_log_impl(&dword_18A900000, v76, OS_LOG_TYPE_DEFAULT, "codesign deallocation failed: %s", buf, 0xCu);
    }
    free(v86);
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
  }
  v10 = *(_QWORD **)buf;
  v11 = size;
  if (HIDWORD(size))
  {
    log_error(&v86, "input file is too big: %lld\n", size);
    LODWORD(v11) = 0;
    goto LABEL_116;
  }
  v12 = 0;
  v13 = 0;
  v14 = **(_DWORD **)buf;
  if ((int)**(_DWORD **)buf > -17958195)
  {
    v15 = 0;
    if ((v14 + 17958194) >= 2)
    {
LABEL_57:
      v39 = writeFile(v9, v12, v13, &v86);
      goto LABEL_66;
    }
  }
  else
  {
    if (v14 == -1095041334)
    {
      v49 = *(_DWORD *)(*(_QWORD *)buf + 4);
      v50 = bswap32(v49);
      v15 = (size + ((_DWORD)v50 << 14));
      if (vm_alloc((vm_address_t *)&__dst, v15, &v86))
      {
        v12 = (char *)__dst;
        *(_QWORD *)__dst = *v10;
        if (!v49)
        {
          v13 = 0;
          goto LABEL_57;
        }
        v51 = 0;
        v52 = v12 + 0x4000;
        while (1)
        {
          v53 = &v12[v51];
          v54 = *(_OWORD *)((char *)v10 + v51 + 8);
          *((_DWORD *)v53 + 6) = *(_DWORD *)((char *)v10 + v51 + 24);
          *(_OWORD *)(v53 + 8) = v54;
          v55 = bswap32(*(_DWORD *)((char *)v10 + v51 + 20));
          memcpy(v52, (char *)v10 + bswap32(*(_DWORD *)((char *)v10 + v51 + 16)), v55);
          v87 = v55;
          if (!remove_signature_space(v52, v55, &v87, &v86))
            break;
          v56 = v52 - v12;
          if (v52 < v12)
          {
            log_error(&v86, "new architecture offset underflows");
            break;
          }
          if (HIDWORD(v56))
          {
            log_error(&v86, "new architecture offset is too large");
            break;
          }
          v57 = &v12[v51];
          v58 = v87;
          v59 = bswap32(v87);
          *((_DWORD *)v57 + 4) = bswap32(v56);
          *((_DWORD *)v57 + 5) = v59;
          *((_DWORD *)v57 + 6) = 234881024;
          v52 += (v58 + 0x3FFF) & 0xFFFFC000;
          v51 += 20;
          if (!--v50)
          {
            v13 = v58 + v56;
            goto LABEL_57;
          }
        }
        v39 = 0;
        goto LABEL_66;
      }
LABEL_116:
      munmap(v10, v11);
      goto LABEL_117;
    }
    if (v14 != -822415874)
    {
      v15 = 0;
      if (v14 != -805638658)
        goto LABEL_57;
    }
  }
  v88 = size;
  if (!vm_alloc((vm_address_t *)&__dst, size, &v86))
    goto LABEL_116;
  v12 = (char *)__dst;
  memcpy(__dst, v10, v11);
  if (remove_signature_space(v12, v11, &v88, &v86))
  {
    v13 = v88;
    v15 = v11;
    goto LABEL_57;
  }
  v39 = 0;
  v15 = v11;
LABEL_66:
  v48 = vm_dealloc(&__dst, v15, &v86);
  munmap(v10, v11);
  if ((v48 & v39 & 1) == 0)
    goto LABEL_117;
LABEL_90:
  *(_DWORD *)buf = -1;
  Security::CodeSigning::UidGuard::seteuid((Security::CodeSigning::UidGuard *)buf, 0);
  if (*((char *)this + 167) >= 0)
    v71 = (char *)this + 144;
  else
    v71 = (const char *)*((_QWORD *)this + 18);
  Security::UnixPlusPlus::FileDesc::open((Security::CodeSigning::MachOEditor *)((char *)this + 200), v71, 2, 438);
  Security::CodeSigning::UidGuard::~UidGuard((uid_t *)buf);
  v72 = operator new();
  v80 = *((_DWORD *)this + 50);
  v81 = *((_BYTE *)this + 204);
  result = Security::Universal::Universal(v72, &v80, 0, 0);
  *((_QWORD *)this + 24) = v72;
  return result;
}

void sub_18AA35820(_Unwind_Exception *a1)
{
  void *v1;

  free(v1);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::MachOEditor::reset(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t result;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;
  _QWORD v11[6];

  v4 = Security::Universal::architecture(*(Security::Universal **)(a1 + 192), (const Security::Architecture *)*(unsigned int *)(a2 + 48), *(_DWORD *)(a2 + 52));
  result = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = v4;
  if (result)
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  v6 = *(_QWORD **)(a1 + 168);
  if (v6 != (_QWORD *)(a1 + 176))
  {
    v7 = MEMORY[0x1E0C809B0];
    do
    {
      v11[0] = v7;
      v11[1] = 0x40000000;
      v11[2] = ___ZN8Security11CodeSigning11MachOEditor5resetERNS0_10ArchEditor4ArchE_block_invoke;
      v11[3] = &__block_descriptor_tmp_4_14198;
      v11[4] = a1;
      v11[5] = a2;
      result = Security::CodeSigning::ArchEditor::Arch::eachDigest(a2, (uint64_t)v11);
      v8 = (_QWORD *)v6[1];
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = (_QWORD *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v9 = (_QWORD *)v6[2];
          v10 = *v9 == (_QWORD)v6;
          v6 = v9;
        }
        while (!v10);
      }
      v6 = v9;
    }
    while (v9 != (_QWORD *)(a1 + 176));
  }
  return result;
}

void Security::CodeSigning::MachOEditor::write(uint64_t a1, uint64_t a2, uint64_t a3)
{
  Security::MachOBase *v6;
  const load_command *CodeSignature;
  unsigned int cmd;
  unsigned int v9;
  uint64_t v10;
  Security::MachOBase *v11;
  const load_command *v12;
  unsigned int cmdsize;
  unsigned int v14;
  unint64_t v15;
  NSObject *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v6 = *(Security::MachOBase **)(a2 + 56);
  CodeSignature = Security::MachOBase::findCodeSignature(v6);
  if (!CodeSignature
    || ((cmd = CodeSignature[1].cmd, v9 = bswap32(cmd), *((_BYTE *)v6 + 33)) ? (v10 = v9) : (v10 = cmd), !(_DWORD)v10))
  {
    v16 = secLogObjForScope("signer");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      v17 = 134217984;
      v18 = a1;
      _os_log_debug_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEBUG, "%p cannot find CODESIGNING data in Mach-O", (uint8_t *)&v17, 0xCu);
    }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
  }
  v11 = *(Security::MachOBase **)(a2 + 56);
  v12 = Security::MachOBase::findCodeSignature(v11);
  if (v12)
  {
    cmdsize = v12[1].cmdsize;
    v14 = bswap32(cmdsize);
    if (*((_BYTE *)v11 + 33))
      v15 = v14;
    else
      v15 = cmdsize;
  }
  else
  {
    v15 = 0;
  }
  NXGetArchInfoFromCpuType(*(_DWORD *)(a2 + 48), *(_DWORD *)(a2 + 52) & 0xFFFFFF);
  if (v15 < bswap32(*(_DWORD *)(a3 + 4)))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA24);
  Security::UnixPlusPlus::FileDesc::seek((Security::UnixPlusPlus::FileDesc *)*(unsigned int *)(*(_QWORD *)(a2 + 56) + 36), *(_QWORD *)(*(_QWORD *)(a2 + 56) + 48) + v10);
  Security::UnixPlusPlus::FileDesc::writeAll(*(_QWORD *)(a2 + 56) + 36, (char *)a3, bswap32(*(_DWORD *)(a3 + 4)));
  free((void *)a3);
}

uint64_t Security::CodeSigning::MachOEditor::commit(Security::CodeSigning::MachOEditor *this)
{
  const std::__fs::filesystem::path *v2;
  int v3;
  const char *v4;
  timespec v5;
  _copyfile_state *v6;
  _copyfile_state *v7;
  const char *v8;
  std::error_code *v9;
  const std::__fs::filesystem::path *v10;
  int v11;
  int *v13;
  int *v14;
  int *v15;
  int *v16;
  char __buf;
  uid_t v18;
  int src;
  stat v20;

  v2 = (const std::__fs::filesystem::path *)((char *)this + 120);
  v3 = *((char *)this + 143);
  v4 = (char *)this + 120;
  if (v3 < 0)
    v4 = (const char *)v2->__pn_.__r_.__value_.__r.__words[0];
  v5.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v5.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v20.st_blksize = v5;
  *(timespec *)v20.st_qspare = v5;
  v20.st_birthtimespec = v5;
  *(timespec *)&v20.st_size = v5;
  v20.st_mtimespec = v5;
  v20.st_ctimespec = v5;
  *(timespec *)&v20.st_uid = v5;
  v20.st_atimespec = v5;
  *(timespec *)&v20.st_dev = v5;
  if (stat(v4, &v20) == -1 || (v6 = copyfile_state_alloc()) == 0)
  {
    v13 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v13);
  }
  v7 = v6;
  src = *((_DWORD *)this + 50);
  if (copyfile_state_set(v6, 3u, &src) < 0)
  {
    v15 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v15);
  }
  v18 = -1;
  if (!Security::CodeSigning::UidGuard::seteuid((Security::CodeSigning::UidGuard *)&v18, 0))
    Security::CodeSigning::UidGuard::seteuid((Security::CodeSigning::UidGuard *)&v18, v20.st_uid);
  v8 = (const char *)v2;
  if (*((char *)this + 143) < 0)
    v8 = (const char *)v2->__pn_.__r_.__value_.__r.__words[0];
  if (copyfile(v8, 0, v7, 7u) < 0)
  {
    v16 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v16);
  }
  __buf = -86;
  Security::UnixPlusPlus::FileDesc::read((Security::UnixPlusPlus::FileDesc *)*((unsigned int *)this + 50), &__buf, 1uLL, 0);
  if (pwrite(*((_DWORD *)this + 50), &__buf, 1uLL, 0) == -1)
    goto LABEL_19;
  v10 = (const std::__fs::filesystem::path *)((char *)this + 144);
  if (*((char *)this + 167) < 0)
    v10 = (const std::__fs::filesystem::path *)v10->__pn_.__r_.__value_.__r.__words[0];
  if (*((char *)this + 143) < 0)
    v2 = (const std::__fs::filesystem::path *)v2->__pn_.__r_.__value_.__r.__words[0];
  rename(v10, v2, v9);
  if (v11 == -1)
  {
LABEL_19:
    v14 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v14);
  }
  *((_BYTE *)this + 208) = 0;
  Security::CodeSigning::UidGuard::~UidGuard(&v18);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 6) + 48))(*((_QWORD *)this + 6));
  return copyfile_state_free(v7);
}

void sub_18AA35CA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  _copyfile_state *v10;

  copyfile_state_free(v10);
  _Unwind_Resume(a1);
}

BOOL Security::CodeSigning::UidGuard::seteuid(Security::CodeSigning::UidGuard *this, uid_t a2)
{
  if (geteuid() == a2)
    return 1;
  if (*(_DWORD *)this == -1)
    *(_DWORD *)this = geteuid();
  return seteuid(a2) == 0;
}

void Security::CodeSigning::UidGuard::~UidGuard(uid_t *this)
{
  uid_t v1;
  int *v2;

  v1 = *this;
  if (v1 != -1 && seteuid(v1) == -1)
  {
    v2 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v2);
  }
}

void ___ZN8Security11CodeSigning11MachOEditor5resetERNS0_10ArchEditor4ArchE_block_invoke(uint64_t a1, _QWORD *a2)
{
  Security::UnixPlusPlus::FileDesc *v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const load_command *CodeSignature;
  unsigned int cmd;
  unsigned int v10;
  uint64_t v11;
  std::string *p_p;
  std::string __p;

  v2 = (Security::UnixPlusPlus::FileDesc *)(a2 + 5);
  if (*((_DWORD *)a2 + 10) != -1)
  {
    v5 = *(_QWORD *)(a1 + 32);
    if (*(char *)(v5 + 167) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(v5 + 144), *(_QWORD *)(v5 + 152));
    else
      __p = *(std::string *)(v5 + 144);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 56);
    v7 = *(_QWORD *)(v6 + 48);
    CodeSignature = Security::MachOBase::findCodeSignature((Security::MachOBase *)v6);
    if (CodeSignature)
    {
      cmd = CodeSignature[1].cmd;
      v10 = bswap32(cmd);
      if (*(_BYTE *)(v6 + 33))
        v11 = v10;
      else
        v11 = cmd;
    }
    else
    {
      v11 = 0;
    }
    Security::UnixPlusPlus::FileDesc::close(v2);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    Security::UnixPlusPlus::FileDesc::open(v2, (const char *)p_p, 0, 438);
    a2[6] = v7;
    a2[7] = v11;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_18AA35E50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::ArchEditor::Arch::eachDigest(uint64_t result, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  v2 = *(_QWORD **)(result + 64);
  v3 = (_QWORD *)(result + 72);
  if (v2 != (_QWORD *)(result + 72))
  {
    do
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD))(a2 + 16))(a2, v2[5]);
      v5 = (_QWORD *)v2[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v2[2];
          v7 = *v6 == (_QWORD)v2;
          v2 = v6;
        }
        while (!v7);
      }
      v2 = v6;
    }
    while (v6 != v3);
  }
  return result;
}

unint64_t ___ZN8Security11CodeSigning11MachOEditor8allocateEv_block_invoke(uint64_t a1, int a2, int a3)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD **)(v3 + 24);
  v5 = (_QWORD *)(v3 + 32);
  v6 = 0xFFFFFFFFLL;
  if (v4 != v5)
  {
    do
    {
      if (*((_DWORD *)v4 + 8) == a2 && (a3 == -1 || ((*((_DWORD *)v4 + 9) ^ a3) & 0xFFFFFF) == 0))
        v6 = *(_QWORD *)(v4[5] + 120);
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != v5);
  }
  if (((v6 - 1) & 0xFFFFFFFFFFFFFFF0) + 16 >= 0xFFFFFFFF)
    return 0xFFFFFFFFLL;
  else
    return ((v6 - 1) & 0xFFFFFFFFFFFFFFF0) + 16;
}

void Security::CodeSigning::BlobWriter::component(uint64_t **this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
  Security::CodeSigning::EmbeddedSignatureBlob::Maker::component(this + 3, a2, a3);
}

void Security::CodeSigning::DetachedBlobWriter::~DetachedBlobWriter(Security::CodeSigning::DetachedBlobWriter *this)
{
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 24);
}

{
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)this + 24);
  JUMPOUT(0x18D76FAA0);
}

void Security::CodeSigning::DetachedBlobWriter::flush(Security::CodeSigning::DetachedBlobWriter *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  UInt8 *v9;
  Security::CodeSigning::SecStaticCode *v10;
  Security::CodeSigning::SecCodeSigner::Signer *v11;
  const __CFData *v12;

  v9 = (UInt8 *)Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make((uint64_t)this + 24, a2, a3, a4, a5, a6, a7, a8);
  v10 = *(Security::CodeSigning::SecStaticCode **)(*((_QWORD *)this + 6) + 16);
  v12 = CFDataCreate(0, v9, bswap32(*((_DWORD *)v9 + 1)));
  Security::CodeSigning::SecStaticCode::detachedSignature(v10, v12);
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v12);
  Security::CodeSigning::SecCodeSigner::returnDetachedSignature(*(CFTypeRef **)(*((_QWORD *)this + 6) + 8), (Security::BlobCore *)v9, v11);
  free(v9);
}

void sub_18AA36120(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::ArchEditor::ArchEditor(uint64_t a1, Security::Universal *this, _QWORD *a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char **v8;
  _QWORD **v9;
  Security::CodeSigning::CodeDirectory::Builder *v10;
  unsigned int v11;
  char *v12;
  char **v13;
  char **v14;
  unsigned int v15;
  char *v16;
  unsigned int v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD **v20;
  BOOL v21;
  uint64_t **v22;
  uint64_t *v23;
  _QWORD *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  _BOOL4 v29;
  _BOOL4 v30;
  int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t *v34;
  _QWORD *v35;
  _QWORD **v36;
  uint64_t v38;
  uint64_t **v40;
  _QWORD **v41;
  _QWORD *v42[2];
  _QWORD **v43;
  _QWORD *v44[2];
  _QWORD v45[2];
  unint64_t v46;

  v4 = a1;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 12) = -1;
  *(_DWORD *)(a1 + 20) = a4;
  *(_QWORD *)a1 = off_1E1FC8390;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v40 = (uint64_t **)(a1 + 32);
  *(_QWORD *)(a1 + 24) = a1 + 32;
  v44[0] = 0;
  v44[1] = 0;
  v43 = v44;
  Security::Universal::architectures((uint64_t *)this, (uint64_t *)&v43);
  v5 = (uint64_t)v43;
  if (v43 != v44)
  {
    v38 = v4;
    do
    {
      v6 = operator new();
      std::set<unsigned int>::set[abi:ne180100]((uint64_t)&v41, a3);
      *(_DWORD *)(v6 + 8) = 0;
      *(_QWORD *)(v6 + 12) = -1;
      *(_DWORD *)(v6 + 20) = 0;
      *(_QWORD *)(v6 + 40) = 0;
      *(_QWORD *)(v6 + 32) = 0;
      *(_QWORD *)(v6 + 24) = v6 + 32;
      *(_QWORD *)v6 = &off_1E1FC8348;
      v7 = *(_QWORD *)(v5 + 28);
      *(_QWORD *)(v6 + 96) = 0;
      *(_QWORD *)(v6 + 48) = v7;
      *(_QWORD *)(v6 + 56) = 0;
      *(_QWORD *)(v6 + 72) = 0;
      v8 = (char **)(v6 + 72);
      *(_QWORD *)(v6 + 64) = v6 + 72;
      *(_QWORD *)(v6 + 80) = 0;
      *(_QWORD *)(v6 + 88) = v6 + 96;
      *(_QWORD *)(v6 + 112) = 0;
      *(_QWORD *)(v6 + 120) = 0;
      *(_QWORD *)(v6 + 104) = 0;
      v9 = v41;
      if (v41 != v42)
      {
        do
        {
          v10 = (Security::CodeSigning::CodeDirectory::Builder *)operator new();
          Security::CodeSigning::CodeDirectory::Builder::Builder(v10, (Security::CodeSigning::CodeDirectory *)*((unsigned int *)v9 + 7));
          v11 = *((_DWORD *)v9 + 7);
          v12 = *v8;
          v13 = (char **)(v6 + 72);
          v14 = (char **)(v6 + 72);
          if (*v8)
          {
            while (1)
            {
              while (1)
              {
                v14 = (char **)v12;
                v15 = *((_DWORD *)v12 + 8);
                if (v11 >= v15)
                  break;
                v12 = *v14;
                v13 = v14;
                if (!*v14)
                  goto LABEL_11;
              }
              if (v15 >= v11)
                break;
              v12 = v14[1];
              if (!v12)
              {
                v13 = v14 + 1;
                goto LABEL_11;
              }
            }
          }
          else
          {
LABEL_11:
            v46 = 0xAAAAAAAAAAAAAAAALL;
            v16 = (char *)operator new(0x70uLL);
            v45[0] = v16;
            v45[1] = v6 + 72;
            LOBYTE(v46) = 0;
            *((_DWORD *)v16 + 8) = v11;
            Security::Mutex::Mutex((pthread_mutex_t *)(v16 + 48));
            do
              v17 = __ldxr((unsigned int *)v10);
            while (__stxr(v17 + 1, (unsigned int *)v10));
            *((_QWORD *)v16 + 5) = v10;
            LOBYTE(v46) = 1;
            *(_QWORD *)v16 = 0;
            *((_QWORD *)v16 + 1) = 0;
            *((_QWORD *)v16 + 2) = v14;
            *v13 = v16;
            v18 = **(_QWORD **)(v6 + 64);
            if (v18)
            {
              *(_QWORD *)(v6 + 64) = v18;
              v16 = *v13;
            }
            std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v6 + 72), (uint64_t *)v16);
            ++*(_QWORD *)(v6 + 80);
            v45[0] = 0;
            std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,void *>>>>::reset[abi:ne180100]((uint64_t)v45);
          }
          v19 = v9[1];
          if (v19)
          {
            do
            {
              v20 = (_QWORD **)v19;
              v19 = (_QWORD *)*v19;
            }
            while (v19);
          }
          else
          {
            do
            {
              v20 = (_QWORD **)v9[2];
              v21 = *v20 == v9;
              v9 = v20;
            }
            while (!v21);
          }
          v9 = v20;
        }
        while (v20 != v42);
      }
      v22 = v40;
      v23 = *v40;
      v24 = v40;
      if (*v40)
      {
        v25 = *(_DWORD *)(v5 + 28);
        v26 = *(_DWORD *)(v5 + 32);
        while (1)
        {
          while (1)
          {
            v24 = v23;
            v27 = *((_DWORD *)v23 + 8);
            v28 = *((_DWORD *)v24 + 9);
            v29 = v26 < v28;
            if (v25 != v27)
              v29 = v25 < v27;
            if (!v29)
              break;
            v23 = (uint64_t *)*v24;
            v22 = (uint64_t **)v24;
            if (!*v24)
              goto LABEL_34;
          }
          v30 = v28 < v26;
          v31 = v25 == v27 ? v30 : v27 < v25;
          if (v31 != 1)
            break;
          v22 = (uint64_t **)(v24 + 1);
          v23 = (uint64_t *)v24[1];
          if (!v23)
            goto LABEL_34;
        }
        v32 = v24;
        v4 = v38;
      }
      else
      {
LABEL_34:
        v32 = (uint64_t *)operator new(0x30uLL);
        v32[4] = *(_QWORD *)(v5 + 28);
        v32[5] = 0;
        *v32 = 0;
        v32[1] = 0;
        v32[2] = (uint64_t)v24;
        *v22 = v32;
        v4 = v38;
        v33 = **(_QWORD **)(v38 + 24);
        v34 = v32;
        if (v33)
        {
          *(_QWORD *)(v38 + 24) = v33;
          v34 = *v22;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v38 + 32), v34);
        ++*(_QWORD *)(v38 + 40);
      }
      v32[5] = v6;
      std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v42[0]);
      v35 = *(_QWORD **)(v5 + 8);
      if (v35)
      {
        do
        {
          v36 = (_QWORD **)v35;
          v35 = (_QWORD *)*v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          v36 = *(_QWORD ***)(v5 + 16);
          v21 = *v36 == (_QWORD *)v5;
          v5 = (uint64_t)v36;
        }
        while (!v21);
      }
      v5 = (uint64_t)v36;
    }
    while (v36 != v44);
  }
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v44[0]);
  return v4;
}

void sub_18AA364BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, _QWORD **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _QWORD *a18)
{
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a18);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*a13);
  _Unwind_Resume(a1);
}

uint64_t std::set<unsigned int>::set[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;

  *(_QWORD *)(a1 + 8) = 0;
  v3 = (uint64_t *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    do
    {
      std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>((uint64_t **)a1, v3, *((_DWORD *)v5 + 7), *((_DWORD *)v5 + 7));
      v6 = (_QWORD *)v5[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v5[2];
          v8 = *v7 == (_QWORD)v5;
          v5 = v7;
        }
        while (!v8);
      }
      v5 = v7;
    }
    while (v7 != v4);
  }
  return a1;
}

void sub_18AA36634(_Unwind_Exception *a1)
{
  _QWORD **v1;

  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>>>::destroy(a1[1]);
    Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>::~RefPointer((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

uint64_t Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>::~RefPointer(uint64_t a1)
{
  pthread_mutex_t *v2;
  Security::UnixError *v3;
  Security::CodeSigning::CodeDirectory::Builder *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  _QWORD v9[2];

  v2 = (pthread_mutex_t *)(a1 + 8);
  v9[0] = a1 + 8;
  v9[1] = 0xAAAAAAAAAAAAAA01;
  v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if ((_DWORD)v3)
    Security::UnixError::throwMe(v3);
  v4 = *(Security::CodeSigning::CodeDirectory::Builder **)a1;
  if (*(_QWORD *)a1)
  {
    do
    {
      v5 = __ldxr((unsigned int *)v4);
      v6 = v5 - 1;
    }
    while (__stxr(v6, (unsigned int *)v4));
    if (!v6)
    {
      if (*(_QWORD *)a1)
      {
        Security::CodeSigning::CodeDirectory::Builder::~Builder(*(Security::CodeSigning::CodeDirectory::Builder **)a1);
        MEMORY[0x18D76FAA0](v7, 0x1032C4080168F4FLL);
      }
      *(_QWORD *)a1 = 0;
    }
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v9);
  Security::Mutex::~Mutex(v2);
  return a1;
}

void std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>::~RefPointer((uint64_t)v1 + 40);
    operator delete(v1);
  }
}

void Security::CodeSigning::ArchEditor::Arch::~Arch(void **this)
{
  char *v2;
  void *v3;

  *this = &off_1E1FC8348;
  v2 = (char *)(this + 11);
  free(this[14]);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)v2);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>>>::destroy(this[9]);
  v3 = this[7];
  this[7] = 0;
  if (v3)
    (*(void (**)(void *))(*(_QWORD *)v3 + 8))(v3);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)(this + 3));
}

{
  char *v2;
  void *v3;

  *this = &off_1E1FC8348;
  v2 = (char *)(this + 11);
  free(this[14]);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)v2);
  std::__tree<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::RefPointer<Security::CodeSigning::CodeDirectory::Builder>>>>::destroy(this[9]);
  v3 = this[7];
  this[7] = 0;
  if (v3)
    (*(void (**)(void *))(*(_QWORD *)v3 + 8))(v3);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)(this + 3));
  JUMPOUT(0x18D76FAA0);
}

uint64_t Security::CodeSigning::MachOEditor::MachOEditor(uint64_t a1, unsigned int *a2, Security::Universal *a3, _QWORD *a4, __int128 *a5)
{
  int v10;
  unsigned int *v11;
  unsigned int v12;
  __int128 v13;
  size_t v14;
  void *v15;
  const std::string::value_type *v16;
  _QWORD v18[3];

  std::set<unsigned int>::set[abi:ne180100]((uint64_t)v18, a4);
  v10 = (*(uint64_t (**)(unsigned int *))(*(_QWORD *)a2 + 24))(a2);
  Security::CodeSigning::ArchEditor::ArchEditor(a1, a3, v18, v10);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((_QWORD *)v18[1]);
  *(_QWORD *)a1 = &off_1E1FC86D8;
  Security::Mutex::Mutex((pthread_mutex_t *)(a1 + 56));
  v11 = a2 + 2;
  do
    v12 = __ldxr(v11);
  while (__stxr(v12 + 1, v11));
  *(_QWORD *)(a1 + 48) = a2;
  if (*((char *)a5 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 120), *(const std::string::value_type **)a5, *((_QWORD *)a5 + 1));
  }
  else
  {
    v13 = *a5;
    *(_QWORD *)(a1 + 136) = *((_QWORD *)a5 + 2);
    *(_OWORD *)(a1 + 120) = v13;
  }
  *(_QWORD *)(a1 + 144) = 0xAAAAAAAAAAAAAAAALL;
  if (*((char *)a5 + 23) >= 0)
    v14 = *((unsigned __int8 *)a5 + 23);
  else
    v14 = *((_QWORD *)a5 + 1);
  *(_QWORD *)(a1 + 152) = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)(a1 + 160) = 0xAAAAAAAAAAAAAAAALL;
  std::string::basic_string[abi:ne180100](a1 + 144, v14 + 7);
  if (*(char *)(a1 + 167) >= 0)
    v15 = (void *)(a1 + 144);
  else
    v15 = *(void **)(a1 + 144);
  if (v14)
  {
    if (*((char *)a5 + 23) >= 0)
      v16 = (const std::string::value_type *)a5;
    else
      v16 = *(const std::string::value_type **)a5;
    memmove(v15, v16, v14);
  }
  strcpy((char *)v15 + v14, ".cstemp");
  std::set<unsigned int>::set[abi:ne180100](a1 + 168, a4);
  *(_QWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 200) = -1;
  *(_BYTE *)(a1 + 204) = 0;
  *(_BYTE *)(a1 + 208) = 0;
  return a1;
}

void sub_18AA369D0(_Unwind_Exception *a1)
{
  Security::CodeSigning::ArchEditor *v1;
  _QWORD *v2;

  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(v2);
  Security::CodeSigning::ArchEditor::~ArchEditor(v1);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::InternalRequirements::operator()(uint64_t a1)
{
  NSObject *v2;
  uint8_t v3[16];

  v2 = secLogObjForScope("signer");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v3 = 0;
    _os_log_debug_impl(&dword_18A900000, v2, OS_LOG_TYPE_DEBUG, "Platform does not support signing internal requirements", v3, 2u);
  }
  *(_QWORD *)(a1 + 24) = 0;
}

void Security::CodeSigning::CodeDirectorySet::add(Security::CodeSigning::CodeDirectorySet *this, const Security::CodeSigning::CodeDirectory *a2)
{
  unsigned int v4;
  _DWORD *v5;
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  unsigned int v9;

  v4 = *((unsigned __int8 *)a2 + 37);
  v5 = operator new(0x30uLL);
  v5[8] = v4;
  *((_QWORD *)v5 + 5) = a2;
  v6 = (uint64_t **)((char *)this + 8);
  v7 = (uint64_t *)*((_QWORD *)this + 1);
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v7;
        v9 = *((_DWORD *)v7 + 8);
        if (v9 <= v4)
          break;
        v7 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_9;
      }
      if (v9 >= v4)
        break;
      v7 = v8[1];
      if (!v7)
      {
        v6 = v8 + 1;
        goto LABEL_9;
      }
    }
    operator delete(v5);
  }
  else
  {
    v8 = (uint64_t **)((char *)this + 8);
LABEL_9:
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at((uint64_t **)this, (uint64_t)v8, v6, (uint64_t *)v5);
  }
  if (*((_BYTE *)a2 + 37) == 1)
    *((_QWORD *)this + 3) = a2;
}

const void **Security::CodeSigning::CodeDirectorySet::populate(const void **this, Security::CodeSigning::DiskRep::Writer *a2)
{
  const void **v3;
  const void **v4;
  const void **v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int *v8;
  uint64_t v9;
  const void **v10;
  const void **v11;
  BOOL v12;
  CFDataRef v13;

  v3 = this;
  v4 = (const void **)*this;
  if (!this[3])
    this[3] = v4[5];
  v5 = this + 1;
  if (v4 != this + 1)
  {
    v6 = 4096;
    do
    {
      v7 = (unsigned int *)v4[5];
      v8 = (unsigned int *)v3[3];
      if (v7 == v8)
        v9 = 0;
      else
        v9 = v6;
      if (v7 != v8)
        ++v6;
      v13 = CFDataCreate(0, (const UInt8 *)v7, bswap32(v7[1]));
      (*(void (**)(Security::CodeSigning::DiskRep::Writer *, uint64_t, CFDataRef))(*(_QWORD *)a2 + 16))(a2, v9, v13);
      this = Security::CFRef<__CFData const*>::~CFRef((const void **)&v13);
      v10 = (const void **)v4[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = (const void **)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v11 = (const void **)v4[2];
          v12 = *v11 == v4;
          v4 = v11;
        }
        while (!v12);
      }
      v4 = v11;
    }
    while (v11 != v5);
  }
  return this;
}

void sub_18AA36C28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

CFMutableArrayRef Security::CodeSigning::CodeDirectorySet::hashList(Security::CodeSigning::CodeDirectorySet *this, uint64_t a2)
{
  __CFArray *CFMutableArray;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  BOOL v9;
  CFMutableArrayRef v10;
  CFDataRef v12;
  CFMutableArrayRef theArray;

  CFMutableArray = Security::makeCFMutableArray(this, a2);
  theArray = CFMutableArray;
  v6 = *(char **)this;
  v4 = (char *)this + 8;
  v5 = v6;
  if (v6 == v4)
  {
    v10 = CFMutableArray;
  }
  else
  {
    do
    {
      v12 = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
      v12 = Security::CodeSigning::CodeDirectory::cdhash(*((Security::CodeSigning::CodeDirectory **)v5 + 5), 1);
      CFArrayAppendValue(theArray, v12);
      Security::CFRef<__CFData const*>::~CFRef((const void **)&v12);
      v7 = (char *)*((_QWORD *)v5 + 1);
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *(char **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (char *)*((_QWORD *)v5 + 2);
          v9 = *(_QWORD *)v8 == (_QWORD)v5;
          v5 = v8;
        }
        while (!v9);
      }
      v5 = v8;
    }
    while (v8 != v4);
    v10 = theArray;
  }
  theArray = 0;
  Security::CFRef<__CFArray *>::~CFRef((const void **)&theArray);
  return v10;
}

void sub_18AA36CFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  Security::CFRef<__CFData const*>::~CFRef(&a9);
  Security::CFRef<__CFArray *>::~CFRef(&a10);
  _Unwind_Resume(a1);
}

__CFDictionary *Security::CodeSigning::CodeDirectorySet::hashDict(Security::CodeSigning::CodeDirectorySet *this)
{
  CFMutableDictionaryRef CFMutableDictionary;
  char *v3;
  char *v4;
  char *v5;
  unsigned int v6;
  int v7;
  CFNumberRef v8;
  char *v9;
  char *v10;
  BOOL v11;
  __CFDictionary *v12;
  CFDataRef valuePtr;
  CFNumberRef v15;
  __CFDictionary *v16;

  CFMutableDictionary = Security::makeCFMutableDictionary(this);
  v16 = CFMutableDictionary;
  v5 = *(char **)this;
  v3 = (char *)this + 8;
  v4 = v5;
  if (v5 == v3)
  {
    v12 = CFMutableDictionary;
  }
  else
  {
    do
    {
      v6 = *((_DWORD *)v4 + 8) - 1;
      if (v6 >= 4)
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA48);
      v7 = dword_18AA61BD0[v6];
      v15 = (CFNumberRef)0xAAAAAAAAAAAAAAAALL;
      LODWORD(valuePtr) = v7;
      v8 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
      valuePtr = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
      v15 = v8;
      valuePtr = Security::CodeSigning::CodeDirectory::cdhash(*((Security::CodeSigning::CodeDirectory **)v4 + 5), 0);
      CFDictionarySetValue(v16, v15, valuePtr);
      Security::CFRef<__CFData const*>::~CFRef((const void **)&valuePtr);
      Security::CFRef<__CFNumber const*>::~CFRef((const void **)&v15);
      v9 = (char *)*((_QWORD *)v4 + 1);
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = *(char **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (char *)*((_QWORD *)v4 + 2);
          v11 = *(_QWORD *)v10 == (_QWORD)v4;
          v4 = v10;
        }
        while (!v11);
      }
      v4 = v10;
    }
    while (v10 != v3);
    v12 = v16;
  }
  v16 = 0;
  Security::CFRef<__CFDictionary *>::~CFRef((const void **)&v16);
  return v12;
}

void sub_18AA36E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  Security::CFRef<__CFDictionary *>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SecCodeSigner::~SecCodeSigner(Security::CodeSigning::SecCodeSigner *this)
{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = off_1E1FC8A78;
  v2 = *((_QWORD *)this + 36);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 39);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)this + 34);
  Security::CFRef<__SecIdentity *>::~CFRef((const void **)this + 33);
  Security::CFRef<__CFNumber const*>::~CFRef((const void **)this + 32);
  if (*((char *)this + 247) < 0)
    operator delete(*((void **)this + 28));
  if (*((char *)this + 223) < 0)
    operator delete(*((void **)this + 25));
  if (*((char *)this + 199) < 0)
    operator delete(*((void **)this + 22));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)this + 20));
  Security::CFRef<void const*>::~CFRef((const void **)this + 15);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)this + 14);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 13);
  v3 = (void **)((char *)this + 80);
  std::vector<Security::CFRef<__CFData const*>>::__destroy_vector::operator()[abi:ne180100](&v3);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 8);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 7);
  Security::CFRef<__CFDate const*>::~CFRef((const void **)this + 6);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 5);
  Security::CFRef<void const*>::~CFRef((const void **)this + 4);
  Security::CFRef<__SecIdentity *>::~CFRef((const void **)this + 3);
}

{
  char *v1;

  Security::CodeSigning::SecCodeSigner::~SecCodeSigner(this);
  Security::SecCFObject::operator delete(v1);
}

{
  uint64_t v2;
  void **v3;

  *(_QWORD *)this = off_1E1FC8A78;
  v2 = *((_QWORD *)this + 36);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 39);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)this + 34);
  Security::CFRef<__SecIdentity *>::~CFRef((const void **)this + 33);
  Security::CFRef<__CFNumber const*>::~CFRef((const void **)this + 32);
  if (*((char *)this + 247) < 0)
    operator delete(*((void **)this + 28));
  if (*((char *)this + 223) < 0)
    operator delete(*((void **)this + 25));
  if (*((char *)this + 199) < 0)
    operator delete(*((void **)this + 22));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)this + 20));
  Security::CFRef<void const*>::~CFRef((const void **)this + 15);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)this + 14);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 13);
  v3 = (void **)((char *)this + 80);
  std::vector<Security::CFRef<__CFData const*>>::__destroy_vector::operator()[abi:ne180100](&v3);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 8);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 7);
  Security::CFRef<__CFDate const*>::~CFRef((const void **)this + 6);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 5);
  Security::CFRef<void const*>::~CFRef((const void **)this + 4);
  Security::CFRef<__SecIdentity *>::~CFRef((const void **)this + 3);
}

BOOL Security::CodeSigning::SecCodeSigner::valid(Security::CodeSigning::SecCodeSigner *this)
{
  return (*((_WORD *)this + 8) & 0x401) != 0 || *((_QWORD *)this + 3) != 0;
}

const void **Security::CFRef<__SecIdentity *>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

void std::vector<Security::CFRef<__CFData const*>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  const void **v2;
  const void **v4;
  void *v5;

  v1 = *a1;
  v2 = (const void **)**a1;
  if (v2)
  {
    v4 = (const void **)v1[1];
    v5 = v2;
    if (v4 != v2)
    {
      do
        v4 = Security::CFRef<__CFData const*>::~CFRef(v4 - 1);
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t Security::CodeSigning::SecCodeSigner::parameters(Security::CodeSigning::SecCodeSigner *this, const __CFDictionary *a2)
{
  uint64_t v3;
  const void *Value;
  const void *v5;
  int v6;
  int v7;
  const void *v8;
  const void *v9;
  CFTypeRef v10;
  CFTypeRef v11;
  BOOL v12;
  char v13;
  const void *v14;
  const void *v15;
  CFTypeRef v16;
  BOOL v17;
  char v18;
  const void *v19;
  CFTypeID v20;
  const void *v21;
  const __CFNumber *v22;
  const void *v23;
  CFArrayRef v24;
  CFTypeID v25;
  unsigned int Count;
  uint64_t v27;
  CFIndex i;
  const __CFNumber *ValueAtIndex;
  unsigned int *v30;
  uint64_t *v31;
  unsigned int *v32;
  uint64_t *v33;
  uint64_t *v34;
  const void *v35;
  const __CFNumber *v36;
  unint64_t v37;
  const void *v38;
  const __CFNumber *v39;
  const void *v40;
  const void *v41;
  CFTypeID v42;
  const void *v43;
  const __CFString *v44;
  void **v45;
  const __CFString *v46;
  void **v47;
  const void *v48;
  const __CFNumber *v49;
  Security::CFError *v50;
  const __CFString *v51;
  void **v52;
  const void *v53;
  const void *v54;
  CFTypeID v55;
  CFTypeID v56;
  const void *v57;
  const void *v58;
  CFTypeRef v59;
  BOOL v60;
  char v61;
  const void *v62;
  const void *v63;
  const void *v64;
  CFTypeRef v65;
  CFTypeID v66;
  const void *v67;
  const void *v68;
  CFTypeID v69;
  const void *v70;
  const void *v71;
  const void *v72;
  CFTypeRef v73;
  BOOL v74;
  char v75;
  uint64_t v76;
  const void **v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  char *v87;
  uint64_t v88;
  char *v89;
  char *v90;
  uint64_t v91;
  const void **v92;
  __int128 v93;
  const void **v94;
  const void **v95;
  const void *v96;
  const void *v97;
  const void *v98;
  const void *v99;
  const void *v100;
  CFTypeRef v101;
  uint64_t v102;
  uint64_t v103;
  const __CFString *v104;
  const __CFString *v105;
  CFDataRef v106;
  _BOOL4 v107;
  const void *v108;
  const void *v109;
  CFTypeID v110;
  const void *v111;
  const void *v112;
  CFTypeRef v113;
  BOOL v114;
  char v115;
  const __CFString *v116;
  std::string::size_type size;
  int v118;
  std::string *v119;
  std::string *v120;
  uint64_t v121;
  uint64_t v122;
  _BYTE *v123;
  uint64_t v124;
  const void *v125;
  CFTypeRef v126;
  BOOL v127;
  char v128;
  uint64_t result;
  NSObject *v130;
  CFDictionaryRef theDict;
  unsigned int v132;
  std::string values;
  unint64_t v134;
  CFTypeRef cf[2];

  v3 = 4294900225;
  Security::CFDictionary::CFDictionary((Security::CFDictionary *)&theDict, a2, (Security::MacOSError *)0xFFFEFA0ELL);
  Value = CFDictionaryGetValue(theDict, CFSTR("edit-cpu-type"));
  Security::CFRef<__CFNumber const*>::check<void const*>(Value, (Security::MacOSError *)v132);
  v5 = CFDictionaryGetValue(theDict, CFSTR("edit-cpu-subtype"));
  Security::CFRef<__CFNumber const*>::check<void const*>(v5, (Security::MacOSError *)v132);
  if (Value && v5)
  {
    v6 = Security::cfNumber<unsigned int>((const __CFNumber *)Value);
    v7 = Security::cfNumber<unsigned int>((const __CFNumber *)v5);
    *((_DWORD *)this + 76) = v6;
    *((_DWORD *)this + 77) = v7;
  }
  v8 = CFDictionaryGetValue(theDict, CFSTR("edit-cms"));
  Security::CFRef<__CFData const*>::check<void const*>(v8, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 39, v8);
  v9 = CFDictionaryGetValue(theDict, CFSTR("dryrun"));
  v10 = Security::CFRef<__CFBoolean const*>::check<void const*>(v9, (Security::MacOSError *)v132);
  v11 = (CFTypeRef)*MEMORY[0x1E0C9AE50];
  if (v10)
    v12 = v10 == v11;
  else
    v12 = 0;
  v13 = v12;
  *((_BYTE *)this + 250) = v13;
  v14 = CFDictionaryGetValue(theDict, CFSTR("sdkroot"));
  Security::CFRef<__CFURL const*>::check<void const*>(v14, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 14, v14);
  v15 = CFDictionaryGetValue(theDict, CFSTR("preserve-afsc"));
  v16 = Security::CFRef<__CFBoolean const*>::check<void const*>(v15, (Security::MacOSError *)v132);
  if (v16)
    v17 = v16 == v11;
  else
    v17 = 0;
  v18 = v17;
  *((_BYTE *)this + 300) = v18;
  if ((*((_BYTE *)this + 17) & 4) != 0)
    goto LABEL_165;
  v19 = CFDictionaryGetValue(theDict, CFSTR("signer"));
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 3, v19);
  if (*((_QWORD *)this + 3))
  {
    v20 = CFGetTypeID(*((CFTypeRef *)this + 3));
    if (v20 != SecIdentityGetTypeID() && !CFEqual(*((CFTypeRef *)this + 3), (CFTypeRef)*MEMORY[0x1E0C9B0D0]))
LABEL_167:
      Security::MacOSError::throwMe((Security::MacOSError *)v3);
  }
  v21 = CFDictionaryGetValue(theDict, CFSTR("flags"));
  v22 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v21, (Security::MacOSError *)v132);
  if (v22)
  {
    *((_BYTE *)this + 144) = 1;
    *((_DWORD *)this + 34) = Security::cfNumber<unsigned int>(v22);
  }
  else
  {
    *((_BYTE *)this + 144) = 0;
  }
  cf[0] = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  v23 = CFDictionaryGetValue(theDict, CFSTR("digest-algorithm"));
  Security::CFCopyRef<void const*>::CFCopyRef(cf, v23);
  v24 = (CFArrayRef)cf[0];
  if (cf[0])
  {
    v134 = 0xAAAAAAAAAAAAAAAALL;
    values.__r_.__value_.__l.__data_ = (std::string::pointer)cf[0];
    v25 = CFGetTypeID(cf[0]);
    if (v25 == CFArrayGetTypeID())
    {
      CFRetain(v24);
      v134 = (unint64_t)v24;
    }
    else
    {
      v24 = CFArrayCreate(0, (const void **)&values.__r_.__value_.__l.__data_, 1, MEMORY[0x1E0C9B378]);
      v134 = (unint64_t)v24;
      if (!v24)
      {
LABEL_38:
        Security::CFRef<__CFArray const*>::~CFRef((const void **)&v134);
        goto LABEL_39;
      }
    }
    Count = CFArrayGetCount(v24);
    v27 = operator new[]();
    if (Count)
    {
      for (i = 0; i != Count; *(_DWORD *)(v27 + 4 * i++) = Security::cfNumber<unsigned int>(ValueAtIndex))
        ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v24, i);
      v30 = (unsigned int *)(v27 + 4 * Count);
      v31 = (uint64_t *)*((_QWORD *)this + 19);
      v32 = (unsigned int *)v27;
      do
      {
        v33 = std::__tree<unsigned int>::__emplace_hint_unique_key_args<unsigned int,unsigned int const&>((uint64_t **)this + 19, v31, *v32, *v32);
        v34 = (uint64_t *)v33[1];
        if (v34)
        {
          do
          {
            v31 = v34;
            v34 = (uint64_t *)*v34;
          }
          while (v34);
        }
        else
        {
          do
          {
            v31 = (uint64_t *)v33[2];
            v12 = *v31 == (_QWORD)v33;
            v33 = v31;
          }
          while (!v12);
        }
        ++v32;
      }
      while (v32 != v30);
    }
    MEMORY[0x18D76FA88](v27, 0x1000C8052888210);
    goto LABEL_38;
  }
LABEL_39:
  Security::CFRef<void const*>::~CFRef(cf);
  v35 = CFDictionaryGetValue(theDict, CFSTR("cmssize"));
  v36 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v35, (Security::MacOSError *)v132);
  if (v36)
    v37 = Security::cfNumber<unsigned long>(v36);
  else
    v37 = 18000;
  *((_QWORD *)this + 16) = v37;
  v38 = CFDictionaryGetValue(theDict, CFSTR("preserve-metadata"));
  v39 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v38, (Security::MacOSError *)v132);
  if (v39)
    LODWORD(v39) = Security::cfNumber<unsigned int>(v39);
  *((_DWORD *)this + 35) = (_DWORD)v39;
  v40 = CFDictionaryGetValue(theDict, CFSTR("signing-time"));
  v41 = v40;
  if (v40)
  {
    v42 = CFGetTypeID(v40);
    if (v42 != CFDateGetTypeID() && v41 != (const void *)*MEMORY[0x1E0C9B0D0])
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
    CFRetain(v41);
    v43 = (const void *)*((_QWORD *)this + 6);
    if (v43)
      CFRelease(v43);
    *((_QWORD *)this + 6) = v41;
  }
  v44 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("identifier"));
  Security::CFRef<__CFString const*>::check<void const*>(v44, (Security::MacOSError *)v132);
  if (v44)
  {
    Security::cfString(&values, v44);
    v45 = (void **)((char *)this + 176);
    if (*((char *)this + 199) < 0)
      operator delete(*v45);
    *(_OWORD *)v45 = *(_OWORD *)&values.__r_.__value_.__l.__data_;
    *((_QWORD *)this + 24) = *((_QWORD *)&values.__r_.__value_.__l + 2);
  }
  v46 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("teamidentifier"));
  Security::CFRef<__CFString const*>::check<void const*>(v46, (Security::MacOSError *)v132);
  if (v46)
  {
    Security::cfString(&values, v46);
    v47 = (void **)((char *)this + 224);
    if (*((char *)this + 247) < 0)
      operator delete(*v47);
    *(_OWORD *)v47 = *(_OWORD *)&values.__r_.__value_.__l.__data_;
    *((_QWORD *)this + 30) = *((_QWORD *)&values.__r_.__value_.__l + 2);
  }
  v48 = CFDictionaryGetValue(theDict, CFSTR("platform-identifier"));
  v49 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v48, (Security::MacOSError *)v132);
  if (v49)
  {
    values.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
    v50 = (Security::CFError *)CFNumberGetValue(v49, kCFNumberLongLongType, &values);
    if (!(_DWORD)v50)
      Security::CFError::throwMe(v50);
    if (values.__r_.__value_.__r.__words[0] >= 0x100)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA43);
    *((_BYTE *)this + 248) = values.__r_.__value_.__s.__data_[0];
  }
  v51 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("identifier-prefix"));
  Security::CFRef<__CFString const*>::check<void const*>(v51, (Security::MacOSError *)v132);
  if (v51)
  {
    Security::cfString(&values, v51);
    v52 = (void **)((char *)this + 200);
    if (*((char *)this + 223) < 0)
      operator delete(*v52);
    *(_OWORD *)v52 = *(_OWORD *)&values.__r_.__value_.__l.__data_;
    *((_QWORD *)this + 27) = *((_QWORD *)&values.__r_.__value_.__l + 2);
  }
  v53 = CFDictionaryGetValue(theDict, CFSTR("requirements"));
  v54 = v53;
  if (v53)
  {
    v55 = CFGetTypeID(v53);
    if (v55 != CFDataGetTypeID())
    {
      v56 = CFGetTypeID(v54);
      if (v56 != CFStringGetTypeID())
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
    }
    Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 15, v54);
  }
  else
  {
    v57 = (const void *)*((_QWORD *)this + 15);
    if (v57)
      CFRelease(v57);
    *((_QWORD *)this + 15) = 0;
  }
  v58 = CFDictionaryGetValue(theDict, CFSTR("no-macho"));
  v59 = Security::CFRef<__CFBoolean const*>::check<void const*>(v58, (Security::MacOSError *)v132);
  if (v59)
    v60 = v59 == v11;
  else
    v60 = 0;
  v61 = v60;
  *((_BYTE *)this + 249) = v61;
  v62 = CFDictionaryGetValue(theDict, CFSTR("pagesize"));
  Security::CFRef<__CFNumber const*>::check<void const*>(v62, (Security::MacOSError *)v132);
  if (v62)
    CFRetain(v62);
  v63 = (const void *)*((_QWORD *)this + 32);
  if (v63)
    CFRelease(v63);
  *((_QWORD *)this + 32) = v62;
  v64 = CFDictionaryGetValue(theDict, CFSTR("detached"));
  v65 = *Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 4, v64);
  if (v65)
  {
    v66 = CFGetTypeID(v65);
    if (v66 != CFURLGetTypeID() && v66 != CFDataGetTypeID() && v66 != CFNullGetTypeID())
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  v67 = CFDictionaryGetValue(theDict, CFSTR("resource-rules"));
  v68 = v67;
  if (v67)
  {
    v3 = v132;
    v69 = CFGetTypeID(v67);
    if (v69 != CFDictionaryGetTypeID())
      goto LABEL_167;
  }
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 5, v68);
  v70 = CFDictionaryGetValue(theDict, CFSTR("application-specific"));
  Security::CFRef<__CFData const*>::check<void const*>(v70, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 7, v70);
  v71 = CFDictionaryGetValue(theDict, CFSTR("entitlements"));
  Security::CFRef<__CFData const*>::check<void const*>(v71, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 8, v71);
  v72 = CFDictionaryGetValue(theDict, CFSTR("force-library-entitlements"));
  v73 = Security::CFRef<__CFBoolean const*>::check<void const*>(v72, (Security::MacOSError *)v132);
  if (v73)
    v74 = v73 == v11;
  else
    v74 = 0;
  v75 = v74;
  *((_BYTE *)this + 72) = v75;
  v76 = *((_QWORD *)this + 10);
  v77 = (const void **)*((_QWORD *)this + 11);
  v78 = (uint64_t)v77 - v76;
  if ((unint64_t)v77 - v76 > 0x17)
  {
    if (v78 != 24)
    {
      v92 = (const void **)(v76 + 24);
      while (v77 != v92)
        Security::CFRef<__CFData const*>::~CFRef(--v77);
      *((_QWORD *)this + 11) = v92;
    }
  }
  else
  {
    v79 = 3 - (v78 >> 3);
    v80 = *((_QWORD *)this + 12);
    if (v79 <= (v80 - (uint64_t)v77) >> 3)
    {
      bzero(*((void **)this + 11), 8 * v79);
      *((_QWORD *)this + 11) = &v77[v79];
    }
    else
    {
      v81 = v80 - v76;
      v82 = v81 >> 2;
      if ((unint64_t)(v81 >> 2) <= 3)
        v82 = 3;
      if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFF8)
        v83 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v83 = v82;
      v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>(v83);
      v86 = *((_QWORD *)this + 10);
      v85 = *((_QWORD *)this + 11);
      v87 = &v84[8 * (v78 >> 3)];
      v89 = &v84[8 * v88];
      bzero(v87, 8 * v79);
      v90 = &v87[8 * v79];
      while (v85 != v86)
      {
        v91 = *(_QWORD *)(v85 - 8);
        v85 -= 8;
        *((_QWORD *)v87 - 1) = v91;
        v87 -= 8;
      }
      v93 = *((_OWORD *)this + 5);
      *((_QWORD *)this + 10) = v87;
      *((_QWORD *)this + 11) = v90;
      *((_QWORD *)this + 12) = v89;
      v94 = (const void **)*((_QWORD *)&v93 + 1);
      v95 = (const void **)v93;
      while (v94 != v95)
        v94 = Security::CFRef<__CFData const*>::~CFRef(v94 - 1);
      if (v95)
        operator delete(v95);
    }
  }
  v96 = CFDictionaryGetValue(theDict, CFSTR("lwcr-self"));
  Security::CFRef<__CFData const*>::check<void const*>(v96, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=(*((CFTypeRef **)this + 10), v96);
  v97 = CFDictionaryGetValue(theDict, CFSTR("lwcr-parent"));
  Security::CFRef<__CFData const*>::check<void const*>(v97, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)(*((_QWORD *)this + 10) + 8), v97);
  v98 = CFDictionaryGetValue(theDict, CFSTR("lwcr-responsible"));
  Security::CFRef<__CFData const*>::check<void const*>(v98, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)(*((_QWORD *)this + 10) + 16), v98);
  v99 = CFDictionaryGetValue(theDict, CFSTR("lwcr-library"));
  Security::CFRef<__CFData const*>::check<void const*>(v99, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 13, v99);
  v100 = CFDictionaryGetValue(theDict, CFSTR("timestamp-required"));
  v101 = Security::CFRef<__CFBoolean const*>::check<void const*>(v100, (Security::MacOSError *)v132);
  if (v101)
  {
    *((_BYTE *)this + 280) = v101 == v11;
    goto LABEL_129;
  }
  *((_BYTE *)this + 280) = 0;
  v102 = *((_QWORD *)this + 3);
  if (v102 && v102 != *MEMORY[0x1E0C9B0D0])
  {
    values.__r_.__value_.__r.__words[0] = *(_QWORD *)(v102 + 16);
    CFRetain(values.__r_.__value_.__l.__data_);
    v103 = values.__r_.__value_.__r.__words[0];
    LOBYTE(cf[0]) = 0;
    v104 = (const __CFString *)CFDataCreateWithBytesNoCopy(0, Security::CodeSigning::caspianLeafMarker, 10, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    v105 = v104;
    if (v103 && v104)
    {
      v106 = SecCertificateCopyExtensionValue(v103, v104, cf);
      v107 = v106 != 0;
      if (v106)
      {
        CFRelease(v106);
        v107 = 1;
      }
    }
    else
    {
      if (!v104)
        goto LABEL_127;
      v107 = 0;
    }
    CFRelease(v105);
    if (v107)
    {
      *((_BYTE *)this + 280) = 1;
      goto LABEL_174;
    }
LABEL_127:
    if (!*((_BYTE *)this + 280))
    {
      Security::CFRef<__SecCertificate *>::~CFRef((const void **)&values.__r_.__value_.__l.__data_);
      goto LABEL_129;
    }
LABEL_174:
    v130 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(cf[0]) = 0;
      _os_log_impl(&dword_18A900000, v130, OS_LOG_TYPE_DEFAULT, "Platform does not support signing secure timestamps", (uint8_t *)cf, 2u);
    }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFFCLL);
  }
LABEL_129:
  v108 = CFDictionaryGetValue(theDict, CFSTR("timestamp-authentication"));
  v109 = v108;
  if (v108)
  {
    v3 = v132;
    v110 = CFGetTypeID(v108);
    if (v110 != SecIdentityGetTypeID())
      goto LABEL_167;
  }
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 33, v109);
  v111 = CFDictionaryGetValue(theDict, CFSTR("timestamp-url"));
  Security::CFRef<__CFURL const*>::check<void const*>(v111, (Security::MacOSError *)v132);
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 34, v111);
  v112 = CFDictionaryGetValue(theDict, CFSTR("timestamp-omit-certificates"));
  v113 = Security::CFRef<__CFBoolean const*>::check<void const*>(v112, (Security::MacOSError *)v132);
  if (v113)
    v114 = v113 == v11;
  else
    v114 = 0;
  v115 = v114;
  *((_BYTE *)this + 281) = v115;
  v116 = (const __CFString *)CFDictionaryGetValue(theDict, CFSTR("runtime-version"));
  Security::CFRef<__CFString const*>::check<void const*>(v116, (Security::MacOSError *)v132);
  if (v116)
  {
    memset(&values, 170, sizeof(values));
    Security::cfString(&values, v116);
    size = HIBYTE(values.__r_.__value_.__r.__words[2]);
    if ((values.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      size = values.__r_.__value_.__l.__size_;
    if (!size)
      goto LABEL_154;
    v118 = 0;
    v119 = (values.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &values
         : (std::string *)values.__r_.__value_.__r.__words[0];
    v120 = (std::string *)((char *)v119 + size);
    v121 = 16;
    while (v119 < v120)
    {
      cf[0] = 0;
      *__error() = 0;
      v122 = strtol((const char *)v119, (char **)cf, 10);
      v123 = cf[0];
      if (v119 != cf[0])
      {
        v124 = v122;
        if (!*__error() && (v124 & 0x8000000000000000) == 0 && v124 <= 255)
        {
          v118 |= v124 << v121;
          if (!*v123)
            break;
          if (*v123 == 46)
          {
            if (v121)
            {
              v121 -= 8;
              v119 = (std::string *)(v123 + 1);
              if (v123 + 1 != (_BYTE *)v120)
                continue;
            }
          }
        }
      }
      goto LABEL_154;
    }
    if (!v118)
LABEL_154:
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA4FLL);
    *((_DWORD *)this + 74) = v118;
    if (SHIBYTE(values.__r_.__value_.__r.__words[2]) < 0)
      operator delete(values.__r_.__value_.__l.__data_);
  }
  v125 = CFDictionaryGetValue(theDict, CFSTR("omit-adhoc-flag"));
  v126 = Security::CFRef<__CFBoolean const*>::check<void const*>(v125, (Security::MacOSError *)v132);
  if (v126)
    v127 = v126 == v11;
  else
    v127 = 0;
  v128 = v127;
  *((_BYTE *)this + 301) = v128;
LABEL_165:
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&theDict);
  result = (*(uint64_t (**)(Security::CodeSigning::SecCodeSigner *))(*(_QWORD *)this + 80))(this);
  if ((result & 1) == 0)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  return result;
}

void sub_18AA37D3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21)
{
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&a9);
  _Unwind_Resume(a1);
}

Security::CFDictionary *Security::CFDictionary::CFDictionary(Security::CFDictionary *this, const __CFDictionary *a2, Security::MacOSError *a3)
{
  *((_DWORD *)Security::CFCopyRef<__CFDictionary const*>::CFCopyRef(this, a2) + 2) = (_DWORD)a3;
  if (!a2)
    Security::MacOSError::throwMe(a3);
  return this;
}

void sub_18AA37E58(_Unwind_Exception *a1)
{
  const void **v1;

  Security::CFRef<__CFDictionary const*>::~CFRef(v1);
  _Unwind_Resume(a1);
}

CFTypeRef Security::CFRef<__CFNumber const*>::check<void const*>(CFTypeRef cf, Security::MacOSError *a2)
{
  CFTypeID v4;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 != CFNumberGetTypeID())
      Security::MacOSError::throwMe(a2);
  }
  return cf;
}

CFTypeRef Security::CFRef<__CFData const*>::check<void const*>(CFTypeRef cf, Security::MacOSError *a2)
{
  CFTypeID v4;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 != CFDataGetTypeID())
      Security::MacOSError::throwMe(a2);
  }
  return cf;
}

CFTypeRef Security::CFRef<__CFBoolean const*>::check<void const*>(CFTypeRef cf, Security::MacOSError *a2)
{
  CFTypeID v4;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 != CFBooleanGetTypeID())
      Security::MacOSError::throwMe(a2);
  }
  return cf;
}

CFTypeRef Security::CFRef<__CFURL const*>::check<void const*>(CFTypeRef cf, Security::MacOSError *a2)
{
  CFTypeID v4;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 != CFURLGetTypeID())
      Security::MacOSError::throwMe(a2);
  }
  return cf;
}

_QWORD *Security::CFCopyRef<void const*>::CFCopyRef(_QWORD *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf)
    CFRetain(cf);
  return a1;
}

void sub_18AA37FDC(_Unwind_Exception *a1)
{
  const void **v1;

  Security::CFRef<void const*>::~CFRef(v1);
  _Unwind_Resume(a1);
}

unint64_t Security::cfNumber<unsigned long>(const __CFNumber *a1)
{
  Security::CFError *Value;
  unint64_t valuePtr;

  valuePtr = 0xAAAAAAAAAAAAAAAALL;
  Value = (Security::CFError *)CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr);
  if (!(_DWORD)Value)
    Security::CFError::throwMe(Value);
  return valuePtr;
}

CFTypeRef Security::CFRef<__CFString const*>::check<void const*>(CFTypeRef cf, Security::MacOSError *a2)
{
  CFTypeID v4;

  if (cf)
  {
    v4 = CFGetTypeID(cf);
    if (v4 != CFStringGetTypeID())
      Security::MacOSError::throwMe(a2);
  }
  return cf;
}

_QWORD *Security::CFCopyRef<__CFDictionary const*>::CFCopyRef(_QWORD *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf)
    CFRetain(cf);
  return a1;
}

void sub_18AA380A8(_Unwind_Exception *a1)
{
  const void **v1;

  Security::CFRef<__CFDictionary const*>::~CFRef(v1);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SecCodeSigner::sign(Security::CodeSigning::SecCodeSigner *this, Security::CodeSigning::SecStaticCode *a2, int a3)
{
  const UInt8 *v6;
  const UInt8 *v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  __int128 v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  BOOL v27;
  Security::Universal *v28;
  __int128 v29;
  unsigned int *v30;
  _QWORD *v31;
  std::error_code *v32;
  Security::Universal *v33;
  __int128 v34;
  uint64_t v35;
  unsigned int *v36;
  unsigned int v37;
  uint64_t v38;
  unsigned int *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  _QWORD *v47;
  _QWORD *v48;
  _QWORD *v49;
  _QWORD *v50;
  _QWORD *v51;
  Security::MachOBase *v52;
  const load_command *CodeSignature;
  uint64_t v54;
  unsigned int v55;
  _QWORD *v56;
  _QWORD *v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _DWORD *v67;
  _QWORD *v68;
  _QWORD *v69;
  uint64_t v70;
  void *__p[2];
  char v72;
  uint64_t v73;
  _QWORD *v74;
  _QWORD __dst[55];
  _BYTE buf[32];
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  unint64_t v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v6 = Security::CodeSigning::SecStaticCode::codeDirectory(a2, 0);
  if ((a3 & 2) == 0
    || !v6
    || (v7 = Security::CodeSigning::SecStaticCode::codeDirectory(a2, 0)) != 0 && (v7[13] & 2) != 0)
  {
    *((_DWORD *)a2 + 52) = a3;
    memcpy(__dst, &unk_18AA617B8, sizeof(__dst));
    Security::CodeSigning::SecCodeSigner::Signer::Signer((Security::CodeSigning::SecCodeSigner::Signer *)__dst, this, a2);
    v8 = *((_DWORD *)this + 4) | a3;
    if ((v8 & 1) != 0)
    {
      v10 = secLogObjForScope("signer");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = this;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = a2;
        _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, "%p will remove signature from %p", buf, 0x16u);
      }
      if (*(_QWORD *)(__dst[1] + 32))
      {
        v70 = 4294900259;
        goto LABEL_93;
      }
      Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer(&__dst[3], *(_QWORD *)(__dst[2] + 32));
      if (*(_BYTE *)(__dst[1] + 300))
      {
        (*(void (**)(_QWORD))(*(_QWORD *)__dst[3] + 256))(__dst[3]);
        v70 = 4294967292;
        goto LABEL_93;
      }
      if (!*(_BYTE *)(__dst[1] + 249))
      {
        v28 = (Security::Universal *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)__dst[3] + 80))(__dst[3]);
        if (v28)
        {
          v88 = 0xAAAAAAAAAAAAAAAALL;
          *(_QWORD *)&v29 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v86 = v29;
          v87 = v29;
          v84 = v29;
          v85 = v29;
          v82 = v29;
          v83 = v29;
          v80 = v29;
          v81 = v29;
          v78 = v29;
          v79 = v29;
          *(_OWORD *)&buf[16] = v29;
          v77 = v29;
          *(_OWORD *)buf = v29;
          v30 = (unsigned int *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)__dst[3] + 256))(__dst[3]);
          v31 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(__dst[0] + 24))(__dst);
          std::set<unsigned int>::set[abi:ne180100]((uint64_t)&v73, v31);
          (*(void (**)(void **__return_ptr))(*(_QWORD *)__dst[3] + 40))(__p);
          Security::CodeSigning::MachOEditor::MachOEditor((uint64_t)buf, v30, v28, &v73, (__int128 *)__p);
          if (v72 < 0)
            operator delete(__p[0]);
          std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v74);
          Security::CodeSigning::MachOEditor::allocate((Security::CodeSigning::MachOEditor *)buf);
          Security::CodeSigning::MachOEditor::commit((Security::CodeSigning::MachOEditor *)buf);
          Security::CodeSigning::MachOEditor::~MachOEditor((Security::CodeSigning::MachOEditor *)buf, v32);
          goto LABEL_21;
        }
      }
      *(_QWORD *)&v79 = 0xAAAAAAAAAAAAAAAALL;
      *(_QWORD *)&v11 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v77 = v11;
      v78 = v11;
      *(_OWORD *)buf = v11;
      *(_OWORD *)&buf[16] = v11;
      v12 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)__dst[3] + 256))(__dst[3]);
      Security::Mutex::Mutex((pthread_mutex_t *)&buf[8]);
      if (v12)
      {
        v13 = (unsigned int *)(v12 + 8);
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      *(_QWORD *)buf = v12;
      (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
      (*(void (**)(_QWORD))(**(_QWORD **)buf + 48))(*(_QWORD *)buf);
      goto LABEL_20;
    }
    if ((v8 & 0x400) == 0)
    {
      if ((*(unsigned int (**)(Security::CodeSigning::SecCodeSigner *))(*(_QWORD *)this + 80))(this))
      {
        v9 = secLogObjForScope("signer");
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 134218496;
          *(_QWORD *)&buf[4] = this;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = a2;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&buf[24] = a3;
          _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "%p will sign %p (flags 0x%x)", buf, 0x1Cu);
        }
        Security::CodeSigning::SecCodeSigner::Signer::sign((Security::CodeSigning::SecCodeSigner::Signer *)__dst, *((_DWORD *)this + 4) & 0x1000000 | a3);
        goto LABEL_21;
      }
      v70 = 4294900225;
LABEL_93:
      Security::MacOSError::throwMe((Security::MacOSError *)v70);
    }
    v15 = secLogObjForScope("signer");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = this;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = a2;
      _os_log_debug_impl(&dword_18A900000, v15, OS_LOG_TYPE_DEBUG, "%p will edit signature of %p", buf, 0x16u);
    }
    v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(__dst[2] + 32) + 16))(*(_QWORD *)(__dst[2] + 32));
    Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer(&__dst[3], v16);
    if (*(_BYTE *)(__dst[1] + 249))
    {
      Security::CodeSigning::SecCodeSigner::Signer::prepareForEdit((Security::CodeSigning::SecCodeSigner::Signer *)__dst);
    }
    else
    {
      v33 = (Security::Universal *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)__dst[3] + 80))(__dst[3]);
      Security::CodeSigning::SecCodeSigner::Signer::prepareForEdit((Security::CodeSigning::SecCodeSigner::Signer *)__dst);
      if (v33)
      {
        *(_QWORD *)&v79 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v34 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v34 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v77 = v34;
        v78 = v34;
        *(_OWORD *)buf = v34;
        *(_OWORD *)&buf[16] = v34;
        v35 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)__dst[3] + 256))(__dst[3]);
        Security::Mutex::Mutex((pthread_mutex_t *)&buf[8]);
        if (v35)
        {
          v36 = (unsigned int *)(v35 + 8);
          do
            v37 = __ldxr(v36);
          while (__stxr(v37 + 1, v36));
        }
        *(_QWORD *)buf = v35;
        if (*(_BYTE *)(__dst[1] + 300))
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFFCLL);
        v38 = operator new();
        v39 = *(unsigned int **)buf;
        v40 = (_QWORD *)(*(uint64_t (**)(_QWORD *))(__dst[0] + 24))(__dst);
        std::set<unsigned int>::set[abi:ne180100]((uint64_t)&v73, v40);
        (*(void (**)(void **__return_ptr))(*(_QWORD *)__dst[3] + 40))(__p);
        Security::CodeSigning::MachOEditor::MachOEditor(v38, v39, v33, &v73, (__int128 *)__p);
        if (v72 < 0)
          operator delete(__p[0]);
        std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v74);
        if (__dst[13] && (*(_BYTE *)(v38 + 20) & 2) == 0)
          (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v38 + 16))(v38, 3);
        v41 = *(_QWORD **)(v38 + 24);
        v42 = (_QWORD *)(v38 + 32);
        if (v41 != (_QWORD *)(v38 + 32))
        {
          do
          {
            v43 = (uint64_t *)v41[5];
            v44 = Security::Universal::architecture(v33, (const Security::Architecture *)*((unsigned int *)v41 + 8), *((_DWORD *)v41 + 9));
            v45 = v43[7];
            v43[7] = v44;
            if (v45)
              (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
            if (__dst[13] && (*(_BYTE *)(v38 + 20) & 2) != 0)
              (*(void (**)(uint64_t *, uint64_t))(*v43 + 16))(v43, 3);
            v46 = (_QWORD *)*((_QWORD *)std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>((uint64_t **)&__dst[44], v43[6], v43 + 6)+ 5);
            v49 = (_QWORD *)*v46;
            v47 = v46 + 1;
            v48 = v49;
            if (v49 != v47)
            {
              do
              {
                (*(void (**)(uint64_t *, _QWORD, _QWORD))(*v43 + 16))(v43, *((unsigned int *)v48 + 8), v48[5]);
                v50 = (_QWORD *)v48[1];
                if (v50)
                {
                  do
                  {
                    v51 = v50;
                    v50 = (_QWORD *)*v50;
                  }
                  while (v50);
                }
                else
                {
                  do
                  {
                    v51 = (_QWORD *)v48[2];
                    v27 = *v51 == (_QWORD)v48;
                    v48 = v51;
                  }
                  while (!v27);
                }
                v48 = v51;
              }
              while (v51 != v47);
            }
            v52 = (Security::MachOBase *)v43[7];
            CodeSignature = Security::MachOBase::findCodeSignature(v52);
            if (CodeSignature)
            {
              LODWORD(v54) = CodeSignature[1].cmdsize;
              v55 = bswap32(v54);
              if (*((_BYTE *)v52 + 33))
                v54 = v55;
              else
                v54 = v54;
            }
            else
            {
              v54 = 0;
            }
            v43[15] = v54;
            v56 = (_QWORD *)v41[1];
            if (v56)
            {
              do
              {
                v57 = v56;
                v56 = (_QWORD *)*v56;
              }
              while (v56);
            }
            else
            {
              do
              {
                v57 = (_QWORD *)v41[2];
                v27 = *v57 == (_QWORD)v41;
                v41 = v57;
              }
              while (!v27);
            }
            v41 = v57;
          }
          while (v57 != v42);
        }
        (*(void (**)(uint64_t))(*(_QWORD *)v38 + 56))(v38);
        v58 = *(_QWORD **)(v38 + 24);
        if (v58 != v42)
        {
          do
          {
            v59 = v58[5];
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v38 + 64))(v38, v59);
            if (!*(_BYTE *)(__dst[1] + 250))
            {
              v67 = Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make(v59 + 24, v60, v61, v62, v63, v64, v65, v66);
              (*(void (**)(uint64_t, uint64_t, _DWORD *))(*(_QWORD *)v38 + 72))(v38, v59, v67);
            }
            v68 = (_QWORD *)v58[1];
            if (v68)
            {
              do
              {
                v69 = v68;
                v68 = (_QWORD *)*v68;
              }
              while (v68);
            }
            else
            {
              do
              {
                v69 = (_QWORD *)v58[2];
                v27 = *v69 == (_QWORD)v58;
                v58 = v69;
              }
              while (!v27);
            }
            v58 = v69;
          }
          while (v69 != v42);
        }
        if (!*(_BYTE *)(__dst[1] + 250))
          (*(void (**)(uint64_t))(*(_QWORD *)v38 + 80))(v38);
        (*(void (**)(uint64_t))(*(_QWORD *)v38 + 8))(v38);
        goto LABEL_20;
      }
    }
    if (*(_BYTE *)(__dst[1] + 250))
      goto LABEL_21;
    *(_QWORD *)&v79 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v17 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v77 = v17;
    v78 = v17;
    *(_OWORD *)buf = v17;
    *(_OWORD *)&buf[16] = v17;
    v18 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)__dst[3] + 256))(__dst[3]);
    Security::Mutex::Mutex((pthread_mutex_t *)&buf[8]);
    if (v18)
    {
      v19 = (unsigned int *)(v18 + 8);
      do
        v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }
    *(_QWORD *)buf = v18;
    if (*(_BYTE *)(__dst[1] + 300))
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFFCLL);
    v21 = (_QWORD *)*((_QWORD *)std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>((uint64_t **)&__dst[44], __dst[43], &__dst[43])+ 5);
    v24 = (_QWORD *)*v21;
    v22 = v21 + 1;
    v23 = v24;
    if (v24 != v22)
    {
      do
      {
        (*(void (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)buf + 16))(*(_QWORD *)buf, *((unsigned int *)v23 + 8), v23[5]);
        v25 = (_QWORD *)v23[1];
        if (v25)
        {
          do
          {
            v26 = v25;
            v25 = (_QWORD *)*v25;
          }
          while (v25);
        }
        else
        {
          do
          {
            v26 = (_QWORD *)v23[2];
            v27 = *v26 == (_QWORD)v23;
            v23 = v26;
          }
          while (!v27);
        }
        v23 = v26;
      }
      while (v26 != v22);
    }
    (*(void (**)(_QWORD))(**(_QWORD **)buf + 48))(*(_QWORD *)buf);
LABEL_20:
    Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(buf);
LABEL_21:
    Security::CodeSigning::SecStaticCode::resetValidity(a2);
    Security::CodeSigning::SecCodeSigner::Signer::~Signer((Security::CodeSigning::SecCodeSigner::Signer *)__dst);
  }
}

void sub_18AA38924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, _QWORD *a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t a72;
  uint64_t v72;

  if (a15 < 0)
    operator delete(__p);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a17);
  MEMORY[0x18D76FAA0](v72, 0x10B3C408FE6E862);
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(&a72);
  Security::CodeSigning::SecCodeSigner::Signer::~Signer((Security::CodeSigning::SecCodeSigner::Signer *)&a19);
  _Unwind_Resume(a1);
}

Security::CodeSigning::SecCodeSigner::Signer *Security::CodeSigning::SecCodeSigner::Signer::Signer(Security::CodeSigning::SecCodeSigner::Signer *this, Security::CodeSigning::SecCodeSigner *a2, Security::CodeSigning::SecStaticCode *a3)
{
  *(_QWORD *)this = &off_1E1FC8A40;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0;
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)this + 32));
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = (char *)this + 120;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_QWORD *)this + 31) = 0;
  *((_QWORD *)this + 32) = 0;
  *((_QWORD *)this + 30) = 0;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *((_QWORD *)this + 29) = (char *)this + 240;
  *((_QWORD *)this + 34) = 0;
  *((_QWORD *)this + 35) = 0;
  *((_QWORD *)this + 33) = (char *)this + 272;
  *((_QWORD *)this + 37) = 0;
  *((_BYTE *)this + 322) = 0;
  *((_QWORD *)this + 45) = 0;
  *((_QWORD *)this + 46) = 0;
  *((_QWORD *)this + 43) = 0;
  *((_QWORD *)this + 44) = (char *)this + 360;
  *((_QWORD *)this + 41) = 0;
  *((_QWORD *)this + 42) = 0;
  Security::Mutex::Mutex((pthread_mutex_t *)((char *)this + 376));
  *((_BYTE *)this + 321) = ((*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 16))(this) & 0x80) != 0;
  return this;
}

void sub_18AA38B08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;
  const void **v12;
  const void **v13;
  pthread_mutex_t *v14;
  const void **v15;
  uint64_t v16;
  void **v17;
  pthread_mutex_t *v18;

  v18 = v14;
  Security::Mutex::~Mutex(v18);
  std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::destroy(*(_QWORD **)(v11 + 360));
  Security::CFRef<__CFArray const*>::~CFRef((const void **)(v16 + 216));
  std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>>>::destroy(*(_QWORD **)(v11 + 272));
  std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::destroy(*(_QWORD **)(v11 + 240));
  Security::CFRef<__CFData const*>::~CFRef(v15);
  a10 = v16 + 72;
  std::vector<Security::CFRef<__CFData const*>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  Security::CFRef<__CFData const*>::~CFRef(v13);
  if (*(char *)(v11 + 183) < 0)
    operator delete(*(void **)(v11 + 160));
  if (*(char *)(v11 + 159) < 0)
    operator delete(*v17);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)(v11 + 120));
  Security::CFRef<__CFData const*>::~CFRef((const void **)(v11 + 104));
  Security::CFRef<__CFDictionary const*>::~CFRef(v12);
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(v10);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SecCodeSigner::Signer::~Signer(Security::CodeSigning::SecCodeSigner::Signer *this)
{
  void **v2;

  *(_QWORD *)this = &off_1E1FC8A40;
  free(*((void **)this + 37));
  Security::Mutex::~Mutex((pthread_mutex_t *)((char *)this + 376));
  std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::destroy(*((_QWORD **)this + 45));
  Security::CFRef<__CFArray const*>::~CFRef((const void **)this + 42);
  std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>>>::destroy(*((_QWORD **)this + 34));
  std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::destroy(*((_QWORD **)this + 30));
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 27);
  v2 = (void **)((char *)this + 192);
  std::vector<Security::CFRef<__CFData const*>>::__destroy_vector::operator()[abi:ne180100](&v2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 23);
  if (*((char *)this + 183) < 0)
    operator delete(*((void **)this + 20));
  if (*((char *)this + 159) < 0)
    operator delete(*((void **)this + 17));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)this + 15));
  Security::CFRef<__CFData const*>::~CFRef((const void **)this + 13);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 12);
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer((_QWORD *)this + 3);
}

void std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::destroy(*a1);
    std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::destroy(a1[1]);
    std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>::reset[abi:ne180100](a1 + 5, 0);
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>>>::destroy(*a1);
    std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,unsigned int>>>>::destroy(a1[1]);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((_QWORD *)a1[6]);
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::destroy(*a1);
    std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::destroy(a1[1]);
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy((const void **)a1[6]);
    operator delete(a1);
  }
}

uint64_t *std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*(const void ***)(v2 + 8));
    JUMPOUT(0x18D76FAA0);
  }
  return result;
}

void Security::CodeSigning::SecCodeSigner::returnDetachedSignature(CFTypeRef *this, Security::BlobCore *a2, Security::CodeSigning::SecCodeSigner::Signer *a3)
{
  CFTypeID v5;
  void **v6;
  CFTypeID v7;
  CFTypeID TypeID;
  __CFData *v9;
  CFTypeID v10;
  NSObject *v11;
  void *__p[2];
  char v13;
  unint64_t v14;

  v5 = CFGetTypeID(this[4]);
  if (v5 == CFURLGetTypeID())
  {
    Security::cfString((Security *)__p, (const __CFURL *)this[4]);
    v14 = 0xAAAAAAAAFFFFFFFFLL;
    if (v13 >= 0)
      v6 = __p;
    else
      v6 = (void **)__p[0];
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v14, (const char *)v6, 1537, 438);
    if (v13 < 0)
      operator delete(__p[0]);
    Security::UnixPlusPlus::FileDesc::writeAll((ssize_t)&v14, (char *)a2, bswap32(*((_DWORD *)a2 + 1)));
    Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v14);
  }
  else
  {
    v7 = CFGetTypeID(this[4]);
    TypeID = CFDataGetTypeID();
    v9 = (__CFData *)this[4];
    if (v7 == TypeID)
    {
      CFDataAppendBytes(v9, (const UInt8 *)a2, bswap32(*((_DWORD *)a2 + 1)));
    }
    else
    {
      v10 = CFGetTypeID(v9);
      if (v10 == CFNullGetTypeID())
      {
        v11 = secLogObjForScope("SecError");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEFAULT, "Platform does not support the detached signature database", (uint8_t *)__p, 2u);
        }
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFFCLL);
      }
    }
  }
}

void sub_18AA38EE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&a15);
  _Unwind_Resume(a1);
}

BOOL Security::CodeSigning::SecStaticCode::equal(CFDataRef *this, CFDataRef *a2)
{
  CFDataRef v4;
  CFDataRef v5;
  _BOOL8 v6;
  const void *v8;
  const void *v9;

  v4 = Security::CodeSigning::SecStaticCode::cdHash(this);
  v5 = Security::CodeSigning::SecStaticCode::cdHash(a2);
  if ((unint64_t)v4 | (unint64_t)v5)
  {
    v6 = 0;
    if (v4 && v5)
      return CFEqual(v4, v5) != 0;
  }
  else
  {
    v9 = (const void *)(*(uint64_t (**)(CFDataRef))(*(_QWORD *)this[4] + 48))(this[4]);
    v8 = (const void *)(*(uint64_t (**)(CFDataRef))(*(_QWORD *)a2[4] + 48))(a2[4]);
    v6 = CFEqual(v9, v8) != 0;
    Security::CFRef<__CFURL const*>::~CFRef(&v8);
    Security::CFRef<__CFURL const*>::~CFRef(&v9);
  }
  return v6;
}

void sub_18AA38FD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  Security::CFRef<__CFURL const*>::~CFRef(&a9);
  Security::CFRef<__CFURL const*>::~CFRef(&a10);
  _Unwind_Resume(a1);
}

CFHashCode Security::CodeSigning::SecStaticCode::hash(CFDataRef *this)
{
  CFDataRef v2;
  CFHashCode v4;
  const void *v5;

  v2 = Security::CodeSigning::SecStaticCode::cdHash(this);
  if (v2)
    return CFHash(v2);
  v5 = (const void *)(*(uint64_t (**)(CFDataRef))(*(_QWORD *)this[4] + 48))(this[4]);
  v4 = CFHash(v5);
  Security::CFRef<__CFURL const*>::~CFRef(&v5);
  return v4;
}

void sub_18AA39060(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

_QWORD *__Block_byref_object_copy__14246(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  result[5] = a2[5];
  v2 = a2 + 6;
  v3 = a2[6];
  result[6] = v3;
  v4 = result + 6;
  v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(_QWORD *)(v3 + 16) = v4;
    a2[5] = v2;
    *v2 = 0;
    a2[7] = 0;
  }
  else
  {
    result[5] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__14247(uint64_t a1)
{
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*(const void ***)(a1 + 48));
}

_QWORD *__Block_byref_object_copy__13(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  result[5] = a2[5];
  v2 = a2 + 6;
  v3 = a2[6];
  result[6] = v3;
  v4 = result + 6;
  v5 = a2[7];
  result[7] = v5;
  if (v5)
  {
    *(_QWORD *)(v3 + 16) = v4;
    a2[5] = v2;
    *v2 = 0;
    a2[7] = 0;
  }
  else
  {
    result[5] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__14(uint64_t a1)
{
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)(a1 + 48));
}

uint64_t __Block_byref_object_copy__15(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

const void **__Block_byref_object_dispose__16(uint64_t a1)
{
  return Security::CFRef<__CFData const*>::~CFRef((const void **)(a1 + 40));
}

__CFData *Security::Blob<Security::CodeSigning::EntitlementDERBlob,4208882034u>::blobify(const __CFData *a1)
{
  __CFData *Mutable;
  CFIndex Length;
  UInt8 *MutableBytePtr;
  int v5;
  const UInt8 *BytePtr;
  CFIndex v7;

  Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  Length = CFDataGetLength(a1);
  CFDataSetLength(Mutable, Length + 8);
  if (!Mutable)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFF94);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  v5 = CFDataGetLength(a1);
  *(_DWORD *)MutableBytePtr = 1920065274;
  *((_DWORD *)MutableBytePtr + 1) = bswap32(v5 + 8);
  BytePtr = CFDataGetBytePtr(a1);
  v7 = CFDataGetLength(a1);
  memcpy(MutableBytePtr + 8, BytePtr, v7);
  return Mutable;
}

void Security::CodeSigning::SecStaticCode::ValidationContext::~ValidationContext(Security::CodeSigning::SecStaticCode::ValidationContext *this)
{
  JUMPOUT(0x18D76FAA0);
}

void Security::CodeSigning::SecStaticCode::ValidationContext::reportProblem(Security::CodeSigning::SecStaticCode::ValidationContext *this, Security::CodeSigning::CSError *a2, const __CFString *a3, const __CFString *a4)
{
  Security::CodeSigning::CSError::throwMe(a2, (uint64_t)a3, a4, a4);
}

uint64_t Security::CodeSigning::SecStaticCode::ValidationContext::osStatus(Security::CodeSigning::SecStaticCode::ValidationContext *this)
{
  return 0;
}

void Security::CodeSigning::SecStaticCode::CollectingContext::~CollectingContext(Security::CodeSigning::SecStaticCode::CollectingContext *this)
{
  const void **v1;

  *(_QWORD *)this = &off_1E1FC8AE0;
  v1 = (const void **)((char *)this + 16);
  Security::Mutex::~Mutex((pthread_mutex_t *)((char *)this + 32));
  Security::CFRef<__CFDictionary *>::~CFRef(v1);
}

{
  const void **v1;

  *(_QWORD *)this = &off_1E1FC8AE0;
  v1 = (const void **)((char *)this + 16);
  Security::Mutex::~Mutex((pthread_mutex_t *)((char *)this + 32));
  Security::CFRef<__CFDictionary *>::~CFRef(v1);
  JUMPOUT(0x18D76FAA0);
}

uint64_t Security::CodeSigning::SecStaticCode::CollectingContext::reportProblem(Security::CodeSigning::SecStaticCode::CollectingContext *this, int a2, const __CFString *a3, const void *a4)
{
  Security::UnixError *v8;
  const __CFDictionary *CFMutableDictionary;
  const void *v10;
  uint64_t v11;
  void *Value;
  char *v14;
  unint64_t v15;

  v14 = (char *)this + 32;
  v15 = 0xAAAAAAAAAAAAAA01;
  v8 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  if ((_DWORD)v8)
    Security::UnixError::throwMe(v8);
  if (*((_DWORD *)this + 6))
  {
    if (!a3)
      return Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&v14);
  }
  else
  {
    *((_DWORD *)this + 6) = a2;
    if (!a3)
      return Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&v14);
  }
  CFMutableDictionary = (const __CFDictionary *)*((_QWORD *)this + 2);
  if (!CFMutableDictionary)
  {
    CFMutableDictionary = Security::makeCFMutableDictionary(v8);
    v10 = (const void *)*((_QWORD *)this + 2);
    if (v10)
      CFRelease(v10);
    *((_QWORD *)this + 2) = CFMutableDictionary;
  }
  Value = (void *)CFDictionaryGetValue(CFMutableDictionary, a3);
  if (!Value)
  {
    Value = Security::makeCFMutableArray(0, v11, v14, v15);
    if (!Value)
      Security::CFError::throwMe(0);
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 2), a3, Value);
    CFRelease(Value);
  }
  CFArrayAppendValue((CFMutableArrayRef)Value, a4);
  return Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&v14);
}

void sub_18AA39368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::SecStaticCode::CollectingContext::osStatus(Security::CodeSigning::SecStaticCode::CollectingContext *this)
{
  return *((unsigned int *)this + 6);
}

void Security::CodeSigning::SecStaticCode::CollectingContext::throwMe(Security::CodeSigning::SecStaticCode::CollectingContext *this)
{
  Security::CodeSigning::CSError *exception;
  int v3;
  const void *v4;
  const __CFDictionary *v5;

  exception = (Security::CodeSigning::CSError *)__cxa_allocate_exception(0xA0uLL);
  v3 = *((_DWORD *)this + 6);
  v4 = (const void *)*((_QWORD *)this + 2);
  if (v4)
  {
    CFRetain(v4);
    v5 = (const __CFDictionary *)*((_QWORD *)this + 2);
  }
  else
  {
    v5 = 0;
  }
  Security::CodeSigning::CSError::CSError(exception, v3, v5);
}

void sub_18AA393E8(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

Security::MacOSError *Security::CodeSigning::CSError::CSError(Security::CodeSigning::CSError *this, int a2, const __CFDictionary *a3)
{
  Security::MacOSError *result;

  result = Security::MacOSError::MacOSError(this, a2);
  *(_QWORD *)result = &off_1E1FC8E38;
  *((_QWORD *)result + 19) = a3;
  return result;
}

void Security::CodeSigning::SecStaticCode::initializeFromParent(Security::CodeSigning::SecStaticCode *this, const Security::CodeSigning::SecStaticCode *a2)
{
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  NSObject *v7;

  *((_QWORD *)this + 40) = a2;
  *((_QWORD *)this + 72) = *((_QWORD *)a2 + 72);
  if (*((_QWORD *)a2 + 73))
  {
    v4 = (_QWORD *)operator new();
    v5 = *((_QWORD *)a2 + 73);
    *v4 = &off_1E1FC88A0;
    v6 = (_QWORD *)operator new();
    v7 = *(NSObject **)(*(_QWORD *)(v5 + 8) + 8);
    *v6 = &off_1E1FC93E0;
    v6[1] = v7;
    dispatch_retain(v7);
    v4[1] = v6;
    *((_QWORD *)this + 73) = v4;
  }
}

void sub_18AA394D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SecStaticCode::prepareProgress(Security::CodeSigning::SecStaticCode *this, int a2)
{
  NSObject *v4;
  _QWORD block[5];

  v4 = *((_QWORD *)this + 39);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN8Security11CodeSigning13SecStaticCode15prepareProgressEj_block_invoke;
  block[3] = &__block_descriptor_tmp_14262;
  block[4] = this;
  dispatch_sync(v4, block);
  if ((*((_BYTE *)this + 211) & 0x10) != 0)
  {
    *((_DWORD *)this + 53) = a2;
    *((_DWORD *)this + 54) = 0;
  }
}

uint64_t ___ZN8Security11CodeSigning13SecStaticCode15prepareProgressEj_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 32) + 220) = 0;
  return result;
}

void sub_18AA39618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

const void *Security::CFDictionary::get<__CFArray const*>(uint64_t a1, const char *a2)
{
  const void *Value;
  const void *v4;
  Security::MacOSError *v5;
  CFTypeID v6;
  void *key;

  Security::CFTempString::CFTempString<char const*>((CFStringRef *)&key, a2);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)a1, key);
  v4 = Value;
  if (Value)
  {
    v5 = (Security::MacOSError *)*(unsigned int *)(a1 + 8);
    v6 = CFGetTypeID(Value);
    if (v6 != CFArrayGetTypeID())
      Security::MacOSError::throwMe(v5);
  }
  Security::CFRef<__CFString const*>::~CFRef((const void **)&key);
  return v4;
}

void sub_18AA396A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFString const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t *Security::CodeSigning::addError(Security::CodeSigning *this, uint64_t *a2, void *a3)
{
  CFTypeID v5;
  uint64_t *result;
  unint64_t valuePtr;

  v5 = CFGetTypeID(this);
  result = (uint64_t *)CFNumberGetTypeID();
  if ((uint64_t *)v5 == result)
  {
    valuePtr = 0xAAAAAAAAAAAAAAAALL;
    CFNumberGetValue(this, kCFNumberSInt64Type, &valuePtr);
    return std::__tree<int>::__emplace_unique_key_args<int,int const&>(a2, valuePtr, valuePtr);
  }
  return result;
}

Security::CodeSigning::SecStaticCode *Security::CodeSigning::SecStaticCode::detachedSignature(Security::CodeSigning::SecStaticCode *this, const __CFData *a2)
{
  CFTypeRef *v3;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  CFTypeRef v9;
  uint64_t v10;
  UInt8 *BytePtr;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int v19;
  unint64_t v20;
  BOOL v21;
  Security::Universal *v22;
  int v23;
  _DWORD *v24;
  _DWORD *v25;
  _DWORD *v26;
  _DWORD *v27;
  void *__p[2];
  uint64_t v29;

  v3 = (CFTypeRef *)((char *)this + 136);
  if (a2)
  {
    Security::CFRef<__CFArray const*>::operator=(v3, a2);
    v5 = operator new();
    v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 16))(*((_QWORD *)this + 4));
    std::string::basic_string[abi:ne180100]<0>(__p, "explicit detached");
    *(_DWORD *)(v5 + 8) = 0;
    *(_QWORD *)v5 = off_1E1FC9108;
    Security::Mutex::Mutex((pthread_mutex_t *)(v5 + 24));
    if (v6)
    {
      v7 = (unsigned int *)(v6 + 8);
      do
        v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
    *(_QWORD *)(v5 + 16) = v6;
    *(_QWORD *)v5 = off_1E1FC8460;
    Security::CFCopyRef<__CFData const*>::CFCopyRef((_QWORD *)(v5 + 88), a2);
    *(_QWORD *)(v5 + 96) = 0;
    *(_BYTE *)(v5 + 104) = 1;
    if (SHIBYTE(v29) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)(v5 + 128), (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
    }
    else
    {
      *(_OWORD *)(v5 + 128) = *(_OWORD *)__p;
      *(_QWORD *)(v5 + 144) = v29;
    }
    BytePtr = (UInt8 *)CFDataGetBytePtr(a2);
    v13 = (uint64_t)BytePtr;
    if (*(_DWORD *)BytePtr == -1056121094)
    {
      v15 = bswap32(*((_DWORD *)BytePtr + 2));
      v16 = 8 * v15 + 12;
      v17 = bswap32(*((_DWORD *)BytePtr + 1));
      if (v16 > v17)
      {
        *__error() = 22;
      }
      else
      {
        v18 = (unint64_t)&BytePtr[8 * v15 + 12];
        while (1)
        {
          v18 -= 8;
          if (v18 < (unint64_t)(BytePtr + 12))
            break;
          v19 = *(_DWORD *)(v18 + 4);
          if (v19)
          {
            v20 = bswap32(v19);
            v21 = v16 > v20 || v20 + 8 > v17;
            if (v21 || bswap32(*(_DWORD *)&BytePtr[v20 + 4]) + v20 > v17)
              goto LABEL_24;
          }
        }
        v22 = (Security::Universal *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 80))(v6);
        if (v22)
        {
          v23 = Security::Universal::bestNativeArch(v22);
          v24 = (_DWORD *)Security::SuperBlobCore<Security::SuperBlob<4208856257u,unsigned int>,4208856257u,unsigned int>::find(v13, v23);
          if (v24)
          {
            v25 = Security::Blob<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u>::specific(v24);
            *(_QWORD *)(v5 + 112) = v25;
            if (v25)
            {
              v26 = (_DWORD *)Security::SuperBlobCore<Security::SuperBlob<4208856257u,unsigned int>,4208856257u,unsigned int>::find(v13, 0);
              v27 = Security::Blob<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u>::specific(v26);
              *(_QWORD *)(v5 + 120) = v27;
              if (v27)
                goto LABEL_29;
            }
          }
        }
      }
    }
    else if (*(_DWORD *)BytePtr == -1072898310)
    {
      v14 = Security::Blob<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u>::specific(BytePtr);
      *(_QWORD *)(v5 + 112) = v14;
      if (v14)
      {
        *(_QWORD *)(v5 + 120) = 0;
LABEL_29:
        Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((_QWORD *)this + 4, v5);
        if (SHIBYTE(v29) < 0)
          operator delete(__p[0]);
        return this;
      }
    }
LABEL_24:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA1BLL);
  }
  v9 = *v3;
  if (v9)
    CFRelease(v9);
  *((_QWORD *)this + 17) = 0;
  v10 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 16))(*((_QWORD *)this + 4));
  Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((_QWORD *)this + 4, v10);
  return this;
}

void sub_18AA39A18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  char *v15;
  _QWORD *v16;
  const void **v17;
  const void **v18;
  void **v19;
  uint64_t v20;

  if (v15[151] < 0)
    operator delete(*v19);
  Security::CFRef<__CFData const*>::~CFRef(v18);
  Security::CFRef<__CFData const*>::~CFRef(v17);
  *(_QWORD *)v15 = v20;
  Security::RefPointer<Security::CodeSigning::DiskRep>::~RefPointer(v16);
  Security::CodeSigning::DiskRep::~DiskRep((Security::CodeSigning::DiskRep *)v15);
  if (a15 < 0)
    operator delete(__p);
  MEMORY[0x18D76FAA0](v15, 0x10F3C404880461CLL);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::SecStaticCode::resetValidity(Security::CodeSigning::SecStaticCode *this)
{
  uint64_t v2;
  const void *v3;
  const void **v4;
  const void *v5;
  uint64_t v6;
  char *v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;

  *((_BYTE *)this + 176) = 0;
  *((_BYTE *)this + 192) = 0;
  *((_BYTE *)this + 185) = 0;
  v2 = *((_QWORD *)this + 25);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    *((_QWORD *)this + 25) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 42);
  if (v3)
    CFRelease(v3);
  v4 = (const void **)*((_QWORD *)this + 14);
  *((_QWORD *)this + 42) = 0;
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(v4);
  *((_QWORD *)this + 13) = (char *)this + 112;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0;
  v5 = (const void *)*((_QWORD *)this + 46);
  if (v5)
    CFRelease(v5);
  v6 = 0;
  *((_QWORD *)this + 46) = 0;
  v7 = (char *)this + 392;
  do
  {
    v8 = *(const void **)&v7[v6];
    if (v8)
      CFRelease(v8);
    *(_QWORD *)&v7[v6] = 0;
    v6 += 8;
  }
  while (v6 != 96);
  v9 = (const void *)*((_QWORD *)this + 61);
  if (v9)
    CFRelease(v9);
  *((_QWORD *)this + 61) = 0;
  v10 = (const void *)*((_QWORD *)this + 62);
  if (v10)
    CFRelease(v10);
  *((_QWORD *)this + 62) = 0;
  v11 = (const void *)*((_QWORD *)this + 63);
  if (v11)
    CFRelease(v11);
  *((_QWORD *)this + 63) = 0;
  *((_QWORD *)this + 64) = 0;
  v12 = (const void *)*((_QWORD *)this + 65);
  if (v12)
    CFRelease(v12);
  *((_QWORD *)this + 65) = 0;
  *((_BYTE *)this + 560) = 0;
  v13 = (const void *)*((_QWORD *)this + 77);
  if (v13)
    CFRelease(v13);
  *((_QWORD *)this + 77) = 0;
  v14 = (const void *)*((_QWORD *)this + 78);
  if (v14)
    CFRelease(v14);
  *((_QWORD *)this + 78) = 0;
  *((_WORD *)this + 298) = 0;
  *((_QWORD *)this + 75) = 0x7FF8000000000000;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 4) + 152))(*((_QWORD *)this + 4));
  v15 = (const void *)*((_QWORD *)this + 69);
  if (v15)
    CFRelease(v15);
  *((_QWORD *)this + 69) = 0;
  return CEReleaseManagedContext();
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(unint64_t a1)
{
  if (a1 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a1);
}

BOOL ___ZN8Security11CodeSigning13SecStaticCode18validateExecutableEv_block_invoke(uint64_t a1, unsigned int a2, Security::DynamicHash *a3)
{
  uint64_t v5;
  uint64_t **v6;
  const UInt8 *BytePtr;
  unsigned int v8;
  const unsigned __int8 *v9;
  _BOOL8 result;
  unsigned int v11;

  v11 = a2;
  v5 = *(_QWORD *)(a1 + 40);
  v6 = std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t **)(v5 + 104), a2, &v11);
  BytePtr = CFDataGetBytePtr((CFDataRef)v6[5]);
  if ((*(_BYTE *)(v5 + 209) & 8) == 0)
  {
    v8 = *((_DWORD *)BytePtr + 4);
LABEL_5:
    v9 = &BytePtr[bswap32(v8) + *(int *)(a1 + 48) * (unint64_t)BytePtr[36]];
    goto LABEL_7;
  }
  if (bswap32(*((_DWORD *)BytePtr + 2)) >> 8 >= 0x205)
  {
    v8 = *((_DWORD *)BytePtr + 23);
    if (v8)
      goto LABEL_5;
  }
  v9 = 0;
LABEL_7:
  result = Security::DynamicHash::verify(a3, v9);
  if (!result)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

uint64_t **std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t **v8;
  unsigned int v9;
  _DWORD *v10;
  _QWORD v12[3];

  v6 = a1 + 1;
  v5 = a1[1];
  v7 = a1 + 1;
  v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 8);
        if (v9 <= a2)
          break;
        v5 = *v8;
        v7 = v8;
        if (!*v8)
          goto LABEL_8;
      }
      if (v9 >= a2)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    v12[2] = 0xAAAAAAAAAAAAAA01;
    v10 = operator new(0x30uLL);
    v12[1] = v6;
    v10[8] = *a3;
    *((_QWORD *)v10 + 5) = 0;
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(a1, (uint64_t)v8, v7, (uint64_t *)v10);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v12);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t Security::CodeSigning::SecStaticCode::resourceDictionary(Security::CodeSigning::SecStaticCode *this, int a2)
{
  uint64_t v2;
  const __CFString *Dictionary;
  const char *v5;
  NSObject *v6;
  uint64_t v8;
  const __CFString *v9;
  uint8_t buf[4];
  Security::CodeSigning::SecStaticCode *v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = *((_QWORD *)this + 63);
  if (!v2)
  {
    Dictionary = (const __CFString *)Security::CodeSigning::SecStaticCode::getDictionary((UInt8 *)this, 3, a2);
    v9 = Dictionary;
    if (Dictionary && Security::cfscan(Dictionary, "{rules=%Dn,files=%Dn}", v5))
    {
      v6 = secLogObjForScope("staticCode");
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        v8 = *((_QWORD *)this + 63);
        *(_DWORD *)buf = 134218240;
        v11 = this;
        v12 = 2048;
        v13 = v8;
        _os_log_debug_impl(&dword_18A900000, v6, OS_LOG_TYPE_DEBUG, "%p loaded ResourceDict %p", buf, 0x16u);
      }
      Security::CFRef<__CFData const*>::operator=((CFTypeRef *)this + 63, (CFTypeRef *)&v9);
      v2 = *((_QWORD *)this + 63);
      Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v9);
    }
    else
    {
      Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v9);
      return 0;
    }
  }
  return v2;
}

void sub_18AA39EF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

const void *Security::cfget<__CFDictionary const*>(const void *Value, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFTypeID v10;
  CFDataRef v11;
  CFTypeID v12;
  uint64_t *v14;
  _QWORD v15[3];
  int v16;
  char v17;

  v14 = &a9;
  v15[0] = a2;
  v15[1] = &v14;
  v15[2] = 0;
  v16 = 0;
  v17 = 0;
  while (Security::CFMunge::next((Security::CFMunge *)v15))
  {
    if (Security::CFMunge::next((Security::CFMunge *)v15) == 46)
      ++v15[0];
    if (!Value)
      return 0;
    v10 = CFGetTypeID(Value);
    if (v10 != CFDictionaryGetTypeID())
      return 0;
    v11 = Security::CFMake::make((Security::CFMake *)v15);
    Value = CFDictionaryGetValue((CFDictionaryRef)Value, v11);
    CFRelease(v11);
  }
  if (!Value)
    return 0;
  v12 = CFGetTypeID(Value);
  if (v12 == CFDictionaryGetTypeID())
    return Value;
  else
    return 0;
}

BOOL Security::CodeSigning::itemQualifiesForResourceExemption(char *a1, const char *a2)
{
  char *v2;
  char isPathPrefix;
  std::string __p;
  void *v6[2];
  char v7;
  std::string v8;
  void *v9[2];
  char v10;
  std::string v11;
  void *v12[2];
  char v13;
  std::string v14;
  void *v15[2];
  char v16;
  std::string __s;
  void *v18[2];
  char v19;

  v2 = a1;
  if (a1[23] < 0)
    a1 = *(char **)a1;
  if ((Security::CodeSigning::isOnRootFilesystem((Security::CodeSigning *)a1, a2) & 1) != 0)
    return 1;
  if (!os_variant_allows_internal_security_policies())
    return 0;
  std::string::basic_string[abi:ne180100]<0>(v18, "/AppleInternal/");
  if (v2[23] < 0)
    std::string::__init_copy_ctor_external(&__s, *(const std::string::value_type **)v2, *((_QWORD *)v2 + 1));
  else
    __s = *(std::string *)v2;
  if ((Security::CodeSigning::isPathPrefix((char *)v18, &__s) & 1) != 0)
  {
    isPathPrefix = 1;
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(v15, "/System/Volumes/Data/AppleInternal/");
    if (v2[23] < 0)
      std::string::__init_copy_ctor_external(&v14, *(const std::string::value_type **)v2, *((_QWORD *)v2 + 1));
    else
      v14 = *(std::string *)v2;
    if ((Security::CodeSigning::isPathPrefix((char *)v15, &v14) & 1) != 0)
    {
      isPathPrefix = 1;
    }
    else
    {
      std::string::basic_string[abi:ne180100]<0>(v12, "/System/AppleInternal/");
      if (v2[23] < 0)
        std::string::__init_copy_ctor_external(&v11, *(const std::string::value_type **)v2, *((_QWORD *)v2 + 1));
      else
        v11 = *(std::string *)v2;
      if ((Security::CodeSigning::isPathPrefix((char *)v12, &v11) & 1) != 0)
      {
        isPathPrefix = 1;
      }
      else
      {
        std::string::basic_string[abi:ne180100]<0>(v9, "/usr/local/");
        if (v2[23] < 0)
          std::string::__init_copy_ctor_external(&v8, *(const std::string::value_type **)v2, *((_QWORD *)v2 + 1));
        else
          v8 = *(std::string *)v2;
        if ((Security::CodeSigning::isPathPrefix((char *)v9, &v8) & 1) != 0)
        {
          isPathPrefix = 1;
        }
        else
        {
          std::string::basic_string[abi:ne180100]<0>(v6, "/usr/appleinternal/");
          if (v2[23] < 0)
            std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v2, *((_QWORD *)v2 + 1));
          else
            __p = *(std::string *)v2;
          isPathPrefix = Security::CodeSigning::isPathPrefix((char *)v6, &__p);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
          if (v7 < 0)
            operator delete(v6[0]);
        }
        if (SHIBYTE(v8.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v8.__r_.__value_.__l.__data_);
        if (v10 < 0)
          operator delete(v9[0]);
      }
      if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v11.__r_.__value_.__l.__data_);
      if (v13 < 0)
        operator delete(v12[0]);
    }
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v14.__r_.__value_.__l.__data_);
    if (v16 < 0)
      operator delete(v15[0]);
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__s.__r_.__value_.__l.__data_);
  if (v19 < 0)
    operator delete(v18[0]);
  return (isPathPrefix & 1) != 0;
}

void sub_18AA3A25C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44)
{
  uint64_t v44;

  if (a20 < 0)
    operator delete(__p);
  if (a26 < 0)
    operator delete(a21);
  if (a32 < 0)
    operator delete(a27);
  if (a38 < 0)
    operator delete(a33);
  if (a44 < 0)
    operator delete(a39);
  if (*(char *)(v44 - 89) < 0)
    operator delete(*(void **)(v44 - 112));
  if (*(char *)(v44 - 65) < 0)
    operator delete(*(void **)(v44 - 88));
  if (*(char *)(v44 - 41) < 0)
    operator delete(*(void **)(v44 - 64));
  if (*(char *)(v44 - 17) < 0)
    operator delete(*(void **)(v44 - 40));
  _Unwind_Resume(exception_object);
}

BOOL Security::CodeSigning::SecStaticCode::loadResources(Security::CodeSigning::SecStaticCode *this, const __CFDictionary **a2, const __CFDictionary **a3, unsigned int *a4)
{
  const __CFDictionary *v8;
  uint64_t v9;
  const void *Value;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  const char *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  uint64_t v28;

  v8 = (const __CFDictionary *)Security::CodeSigning::SecStaticCode::resourceDictionary(this, 1);
  v9 = Security::CodeSigning::SecStaticCode::resourceBase(this);
  if (!v9)
  {
    if (!v8)
      return v9 != 0;
LABEL_17:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA10);
  }
  if (!v8)
    goto LABEL_17;
  Value = CFDictionaryGetValue(v8, CFSTR("files2"));
  if (Value)
    v17 = "rules2";
  else
    v17 = "rules";
  if (Value)
    v18 = "files2";
  else
    v18 = "files";
  if (Value)
    v19 = 2;
  else
    v19 = 1;
  *a2 = (const __CFDictionary *)Security::cfget<__CFDictionary const*>(v8, (uint64_t)v17, v11, v12, v13, v14, v15, v16, v27);
  *a3 = (const __CFDictionary *)Security::cfget<__CFDictionary const*>(v8, (uint64_t)v18, v20, v21, v22, v23, v24, v25, v28);
  *a4 = v19;
  if (!*a2 || !*a3)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA11);
  return v9 != 0;
}

uint64_t __Block_byref_object_copy__27(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

const void **__Block_byref_object_dispose__28(uint64_t a1)
{
  return Security::CFRef<__CFDictionary *>::~CFRef((const void **)(a1 + 40));
}

uint64_t Security::CodeSigning::SecStaticCode::resourceBase(Security::CodeSigning::SecStaticCode *this)
{
  const __CFURL *v2;
  void *v3;
  char v4;
  void **v5;
  CFURLRef CFURL;
  const void *v7;
  void *__p[3];

  if (!*((_BYTE *)this + 560))
  {
    memset(__p, 170, sizeof(__p));
    (*(void (**)(void **__return_ptr))(**((_QWORD **)this + 4) + 56))(__p);
    v3 = (void *)HIBYTE(__p[2]);
    v4 = HIBYTE(__p[2]);
    if (SHIBYTE(__p[2]) < 0)
      v3 = __p[1];
    if (v3)
    {
      if (SHIBYTE(__p[2]) >= 0)
        v5 = __p;
      else
        v5 = (void **)__p[0];
      CFURL = Security::makeCFURL((Security *)v5, (const char *)1, 0, v2);
      v7 = (const void *)*((_QWORD *)this + 71);
      if (v7)
        CFRelease(v7);
      *((_QWORD *)this + 71) = CFURL;
      v4 = HIBYTE(__p[2]);
    }
    *((_BYTE *)this + 560) = 1;
    if (v4 < 0)
      operator delete(__p[0]);
  }
  return *((_QWORD *)this + 71);
}

void sub_18AA3A50C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke(uint64_t a1, uint64_t a2, char a3, char *a4)
{
  Security::CodeSigning::SecStaticCode *v7;
  unsigned int v8;
  NSObject *v9;
  int v10;
  const __CFURL *v11;
  NSObject *v12;
  void *CFURL;
  uint64_t v14;
  const __CFURL *v15;
  Security *v16;
  NSObject *v17;
  int v18;
  const char *v19;
  uint8_t *v20;
  NSObject *v21;
  uint32_t v22;
  NSObject *v23;
  int v24;
  char *v25;
  _QWORD v26[6];
  int v27;
  CFTypeRef cf;
  uint8_t buf[4];
  _DWORD *v30;
  _DWORD __b[258];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v7 = *(Security::CodeSigning::SecStaticCode **)(a1 + 32);
  v8 = a3 & 0x40;
  v9 = secLogObjForScope("staticCode");
  if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    if (!v8)
      return;
LABEL_3:
    cf = 0;
    v10 = *(unsigned __int16 *)(a2 + 88);
    if (v10 != 8)
    {
      if (v10 == 12)
      {
        memset(__b, 170, 0x400uLL);
        if (realpath_DARWIN_EXTSN(*(const char **)(a2 + 48), (char *)__b))
        {
          cf = Security::makeCFURL((Security *)__b, 0, 0, v11);
          v12 = secLogObjForScope("staticCode");
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315138;
            v30 = __b;
            _os_log_debug_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEBUG, "Checking symlink target: %s", buf, 0xCu);
          }
          CFURL = (void *)cf;
LABEL_13:
          cf = 0;
          v26[0] = MEMORY[0x1E0C809B0];
          v26[1] = 0x40000000;
          v26[2] = ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke_30;
          v26[3] = &__block_descriptor_tmp_31_14356;
          v26[4] = v7;
          v26[5] = CFURL;
          v27 = *(_DWORD *)(a1 + 48);
          Security::CodeSigning::LimitedAsync::perform(*(_QWORD *)(*((_QWORD *)v7 + 73) + 8), *(_QWORD *)(a1 + 40), (uint64_t)v26);
LABEL_21:
          Security::CFRef<__CFURL const*>::~CFRef(&cf);
          return;
        }
        v23 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          goto LABEL_21;
        v24 = *__error();
        *(_DWORD *)buf = 67109120;
        LODWORD(v30) = v24;
        v19 = "realpath failed checking symlink: %d";
        v20 = buf;
        v21 = v23;
        v22 = 8;
      }
      else
      {
        v17 = secLogObjForScope("SecError");
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          goto LABEL_21;
        v18 = *(unsigned __int16 *)(a2 + 88);
        if (a4[23] < 0)
          a4 = *(char **)a4;
        __b[0] = 67109378;
        __b[1] = v18;
        LOWORD(__b[2]) = 2080;
        *(_QWORD *)((char *)&__b[2] + 2) = a4;
        v19 = "Unexpected scan input: %d, %s";
        v20 = (uint8_t *)__b;
        v21 = v17;
        v22 = 18;
      }
      _os_log_impl(&dword_18A900000, v21, OS_LOG_TYPE_DEFAULT, v19, v20, v22);
      goto LABEL_21;
    }
    v14 = Security::CodeSigning::SecStaticCode::resourceBase(v7);
    if (a4[23] >= 0)
      v16 = (Security *)a4;
    else
      v16 = *(Security **)a4;
    CFURL = Security::makeCFURL(v16, 0, v14, v15);
    goto LABEL_13;
  }
  v25 = a4;
  if (a4[23] < 0)
    v25 = *(char **)a4;
  __b[0] = 67109378;
  __b[1] = v8 >> 6;
  LOWORD(__b[2]) = 2080;
  *(_QWORD *)((char *)&__b[2] + 2) = v25;
  _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "Visiting unhandled file: %d, %s", (uint8_t *)__b, 0x12u);
  if (v8)
    goto LABEL_3;
}

void sub_18AA3A82C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

void ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  __CFDictionary *v8;
  BOOL v9;
  uint64_t v10;
  _QWORD v11[5];
  std::string __p;
  uint64_t v13;
  uint64_t v14;
  char v15;
  char v16;
  BOOL v17;
  std::string v18;
  const void *v19;

  v7 = *(_QWORD *)(a1 + 40);
  v8 = *(__CFDictionary **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&v18, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    v18 = *(std::string *)a4;
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)&v19, (char *)&v18);
  CFDictionaryRemoveValue(v8, v19);
  Security::CFRef<__CFString const*>::~CFRef(&v19);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v18.__r_.__value_.__l.__data_);
  v9 = *(unsigned __int16 *)(a2 + 88) == 12;
  v11[0] = MEMORY[0x1E0C809B0];
  v11[1] = 1174405120;
  v11[2] = ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke_3;
  v11[3] = &__block_descriptor_tmp_35_14305;
  v11[4] = v7;
  v15 = *(_BYTE *)(a1 + 72);
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    __p = *(std::string *)a4;
  v16 = *(_BYTE *)(a1 + 73);
  v10 = *(_QWORD *)(a1 + 56);
  v13 = *(_QWORD *)(a1 + 48);
  v17 = v9;
  v14 = *(_QWORD *)(a1 + 64);
  Security::CodeSigning::LimitedAsync::perform(*(_QWORD *)(*(_QWORD *)(v7 + 584) + 8), v10, (uint64_t)v11);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_18AA3A994(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

const void **Security::CodeSigning::SecStaticCode::checkOptionalResource(const __CFString *this, const void *a2, Security::CodeSigning::SecStaticCode **a3, void *a4)
{
  __int128 v6;
  CFTypeID v7;
  uint64_t v8;
  CFURLRef v9;
  uint64_t v10;
  const __CFString *v11;
  const __CFString *v12;
  CFURLRef v14;
  __int128 v15;
  __int128 v16;

  *(_QWORD *)&v6 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v15 = v6;
  v16 = v6;
  Security::CodeSigning::ResourceSeal::ResourceSeal((Security::CodeSigning::ResourceSeal *)&v15, a2);
  if ((BYTE8(v16) & 1) == 0)
  {
    if (this && (v7 = CFGetTypeID(this), v7 == CFStringGetTypeID()))
    {
      v8 = Security::CodeSigning::SecStaticCode::resourceBase(a3[1]);
      if (v8)
        v9 = (CFURLRef)MEMORY[0x18D76F668](0, this, 0, 0, v8);
      else
        v9 = CFURLCreateWithFileSystemPath(0, this, kCFURLPOSIXPathStyle, 0);
      v14 = v9;
      if (v9)
        v10 = 4294900242;
      else
        v10 = 4294900238;
      if (v9)
        v11 = (const __CFString *)v9;
      else
        v11 = this;
      if (v9)
        v12 = CFSTR("SecCSResourceMissing");
      else
        v12 = CFSTR("SecCSResourceSeal");
      (*((void (**)(Security::CodeSigning::SecStaticCode **, uint64_t, const __CFString *, const __CFString *))*a3
       + 2))(a3, v10, v12, v11);
      Security::CFRef<__CFURL const*>::~CFRef((const void **)&v14);
    }
    else
    {
      (*((void (**)(Security::CodeSigning::SecStaticCode **, uint64_t, const __CFString *, const __CFString *))*a3
       + 2))(a3, 4294900242, CFSTR("SecCSResourceSeal"), this);
    }
  }
  return Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v15);
}

void sub_18AA3AAEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  const void *v3;
  va_list va;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, const void *);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)va);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)va1);
  _Unwind_Resume(a1);
}

void ___ZN8Security11CodeSigning13SecStaticCode17validateResourcesEj_block_invoke_3(uint64_t a1)
{
  Security::CodeSigning::SecStaticCode *v2;
  const __CFURL *v3;
  std::string *v4;
  __int128 v5;
  _QWORD *v6;
  int v7;
  const std::string::value_type *v8;
  std::string::size_type v9;
  std::string *v10;
  __int128 v11;
  int IsValidXattrFile;
  NSObject *v13;
  int v14;
  uint64_t v15;
  const __CFURL *v16;
  Security *v17;
  const char *v18;
  NSObject *v19;
  NSObject *v20;
  _QWORD *v21;
  std::string *v22;
  std::string v23;
  const __CFURL *CFURL;
  void *__p[2];
  std::string::size_type v26;
  std::string v27;
  std::string v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v2 = *(Security::CodeSigning::SecStaticCode **)(a1 + 32);
  if (!*(_BYTE *)(a1 + 80))
    goto LABEL_17;
  v3 = (const __CFURL *)Security::CodeSigning::SecStaticCode::resourceBase(*(Security::CodeSigning::SecStaticCode **)(a1 + 32));
  Security::cfString((Security *)&v27, v3);
  v4 = std::string::append(&v27, "/", 1uLL);
  v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v28.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  v6 = (_QWORD *)(a1 + 40);
  v7 = *(char *)(a1 + 63);
  if (v7 >= 0)
    v8 = (const std::string::value_type *)(a1 + 40);
  else
    v8 = *(const std::string::value_type **)(a1 + 40);
  if (v7 >= 0)
    v9 = *(unsigned __int8 *)(a1 + 63);
  else
    v9 = *(_QWORD *)(a1 + 48);
  v10 = std::string::append(&v28, v8, v9);
  v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v26 = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  IsValidXattrFile = Security::CodeSigning::pathIsValidXattrFile((char *)__p, "staticCode");
  if (SHIBYTE(v26) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v28.__r_.__value_.__l.__data_);
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v27.__r_.__value_.__l.__data_);
    if (IsValidXattrFile)
      goto LABEL_14;
LABEL_17:
    v14 = 1;
    goto LABEL_18;
  }
  if (!IsValidXattrFile)
    goto LABEL_17;
LABEL_14:
  v13 = secLogObjForScope("staticCode");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    if (*(char *)(a1 + 63) < 0)
      v6 = (_QWORD *)*v6;
    LODWORD(v28.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v28.__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
    _os_log_debug_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEBUG, "resource validation on xattr file skipped: %s", (uint8_t *)&v28, 0xCu);
  }
  v14 = 0;
LABEL_18:
  if (!*(_BYTE *)(a1 + 81))
  {
    if (!v14)
      goto LABEL_36;
    goto LABEL_30;
  }
  v15 = Security::CodeSigning::SecStaticCode::resourceBase(v2);
  if (*(char *)(a1 + 63) >= 0)
    v17 = (Security *)(a1 + 40);
  else
    v17 = *(Security **)(a1 + 40);
  CFURL = Security::makeCFURL(v17, 0, v15, v16);
  memset(&v28, 170, sizeof(v28));
  Security::cfString((Security *)&v28, CFURL);
  if (Security::CodeSigning::itemQualifiesForResourceExemption((char *)&v28, v18))
  {
    v19 = secLogObjForScope("staticCode");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      v22 = &v28;
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v22 = (std::string *)v28.__r_.__value_.__r.__words[0];
      LODWORD(v27.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v27.__r_.__value_.__r.__words + 4) = (std::string::size_type)v22;
      _os_log_debug_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEBUG, "resource validation on root volume skipped: %s", (uint8_t *)&v27, 0xCu);
    }
    LOBYTE(v14) = 0;
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v28.__r_.__value_.__l.__data_);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&CFURL);
  if ((v14 & 1) != 0)
  {
LABEL_30:
    v20 = secLogObjForScope("staticCode");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      v21 = (_QWORD *)(a1 + 40);
      if (*(char *)(a1 + 63) < 0)
        v21 = (_QWORD *)*v21;
      LODWORD(v28.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v28.__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
      _os_log_debug_impl(&dword_18A900000, v20, OS_LOG_TYPE_DEBUG, "performing resource validation on item: %s", (uint8_t *)&v28, 0xCu);
    }
    if (*(char *)(a1 + 63) < 0)
      std::string::__init_copy_ctor_external(&v23, *(const std::string::value_type **)(a1 + 40), *(_QWORD *)(a1 + 48));
    else
      v23 = *(std::string *)(a1 + 40);
    Security::CodeSigning::SecStaticCode::validateResource((uint64_t)v2);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v23.__r_.__value_.__l.__data_);
  }
LABEL_36:
  Security::CodeSigning::SecStaticCode::reportProgress(v2);
}

void sub_18AA3AE8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void __copy_helper_block_e8_40c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  std::string *v2;
  __int128 v3;

  v2 = (std::string *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 40), *(_QWORD *)(a2 + 48));
  }
  else
  {
    v3 = *(_OWORD *)(a2 + 40);
    v2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 56);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void __destroy_helper_block_e8_40c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0)
    operator delete(*(void **)(a1 + 40));
}

const void **Security::CodeSigning::SecStaticCode::validateResource(uint64_t a1)
{
  Security::CodeSigning::SecStaticCode *v1;
  unsigned int v2;
  unsigned int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  std::string::size_type v10;
  std::string::size_type v11;
  const __CFDictionary *v12;
  const __CFDictionary *v13;
  uint64_t v14;
  uint64_t v15;
  const __CFURL *v16;
  std::string::value_type *v17;
  __CFURL *CFURL;
  void **v19;
  Security::UnixPlusPlus::FileDesc *data_low;
  void **v21;
  CFStringRef v22;
  void **v23;
  CFStringRef v24;
  char v25;
  void *v26;
  std::string::size_type size;
  int v28;
  std::string *v29;
  uint64_t v30;
  void **v31;
  int v32;
  int v33;
  int v34;
  int v35;
  BOOL v37;
  _BOOL4 v38;
  const void *Value;
  __int128 v40;
  std::string *p_str;
  ssize_t v42;
  std::string::size_type v43;
  std::string *v44;
  int v45;
  std::string::size_type v46;
  std::string *v47;
  ssize_t v48;
  size_t v49;
  _BOOL4 v50;
  size_t v51;
  size_t v52;
  const UInt8 *v53;
  void **v54;
  size_t v55;
  _QWORD *v56;
  BOOL v57;
  __CFURL *v58;
  int v59;
  uint64_t v60;
  const Security::CFClass *v61;
  Security::CodeSigning::SecStaticCode *v62;
  char *v63;
  Security::CodeSigning::DiskRep *v64;
  unsigned __int8 *v65;
  unsigned __int8 v66;
  const void *v67;
  Security::CodeSigning::SecStaticCode *v68;
  __SecRequirement *v69;
  const Security::CodeSigning::SecRequirement *v70;
  char v71;
  const __CFURL *v72;
  void **v73;
  __int128 v74;
  void **v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  dirent *Next;
  __int128 v81;
  const char *d_name;
  void **v83;
  uint64_t v84;
  size_t v85;
  void **v86;
  char *v87;
  uint64_t v88;
  const Security::CFClass *v89;
  Security::CodeSigning::SecStaticCode *v90;
  Security::CodeSigning::DiskRep *v91;
  unsigned __int8 *v92;
  unsigned __int8 v93;
  const void *v94;
  Security::CodeSigning::SecStaticCode *v95;
  __SecRequirement *v96;
  const Security::CodeSigning::SecRequirement *v97;
  void *v98;
  int v99;
  char v100;
  NSObject *v101;
  uint64_t v102;
  const __CFURL *v103;
  std::string *v104;
  std::string::size_type v105;
  std::string *v106;
  void *v107;
  char v108;
  std::string::size_type v109;
  std::string *v110;
  void *v111;
  void **v112;
  size_t v113;
  size_t v114;
  const char *v115;
  char **v116;
  size_t v117;
  const char *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  void *v122;
  int v123;
  char v124;
  NSObject *v125;
  uint64_t v126;
  uint64_t v127;
  char v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  BOOL v134;
  uint64_t *v135;
  int *v137;
  int *v138;
  SecRequirementRef v139;
  unsigned int v140;
  char *v141;
  std::string v142;
  std::string v143;
  std::string v144;
  _QWORD v145[6];
  _QWORD v146[3];
  int v147;
  char v148;
  std::string v149;
  std::string __str;
  _QWORD v151[3];
  CFStringRef text[2];
  CFStringRef theString[2];
  std::string v154;
  __CFURL *v155;
  unint64_t v156;
  SecRequirementRef requirement;
  void *v158[2];
  char v159;
  std::string __dst;
  _BYTE v161[32];
  __int128 v162;
  __int128 v163;
  void *v164[2];
  __int128 v165;
  __int128 v166;
  _OWORD v167[9];
  unint64_t v168;
  void *v169[3];
  void *v170[128];
  _BYTE v171[32];
  __int128 v172;
  __int128 v173;
  void *v174[2];
  __int128 v175;
  __int128 v176;
  _OWORD v177[9];
  unint64_t v178;
  void *__p[136];
  std::string __b[43];
  uint64_t v181;

  v1 = (Security::CodeSigning::SecStaticCode *)MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v14 = (uint64_t)v1;
  v181 = *MEMORY[0x1E0C80C00];
  if (!Security::CodeSigning::SecStaticCode::resourceBase(v1))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA10);
  v15 = Security::CodeSigning::SecStaticCode::resourceBase((Security::CodeSigning::SecStaticCode *)v14);
  if (*(char *)(v11 + 23) >= 0)
    v17 = (std::string::value_type *)v11;
  else
    v17 = *(std::string::value_type **)v11;
  CFURL = Security::makeCFURL((Security *)v17, 0, v15, v16);
  v155 = CFURL;
  if (v3 >= 2 && (v5 & 0x210) == 0x210)
  {
    __b[0].__r_.__value_.__r.__words[0] = 0xAAAAAAAAFFFFFFFFLL;
    Security::cfString((Security *)__p, CFURL);
    if (SHIBYTE(__p[2]) >= 0)
      v19 = __p;
    else
      v19 = (void **)__p[0];
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)__b, (const char *)v19, 0, 438);
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
    data_low = (Security::UnixPlusPlus::FileDesc *)LODWORD(__b[0].__r_.__value_.__l.__data_);
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute((Security::UnixPlusPlus::FileDesc *)LODWORD(__b[0].__r_.__value_.__l.__data_), "com.apple.ResourceFork"))
    {
      Security::cfString((Security *)__p, v155);
      if (SHIBYTE(__p[2]) >= 0)
        v21 = __p;
      else
        v21 = (void **)__p[0];
      v22 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Disallowed xattr %s found on %s"), "com.apple.ResourceFork", v21);
      if (SHIBYTE(__p[2]) < 0)
        operator delete(__p[0]);
      (*(void (**)(uint64_t, uint64_t, const __CFString *, CFStringRef))(*(_QWORD *)v7 + 16))(v7, 4294900297, CFSTR("SecCSResourceHasSidebandData"), v22);
    }
    if (Security::UnixPlusPlus::FileDesc::hasExtendedAttribute(data_low, "com.apple.FinderInfo"))
    {
      Security::cfString((Security *)__p, v155);
      if (SHIBYTE(__p[2]) >= 0)
        v23 = __p;
      else
        v23 = (void **)__p[0];
      v24 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("Disallowed xattr %s found on %s"), "com.apple.FinderInfo", v23);
      if (SHIBYTE(__p[2]) < 0)
        operator delete(__p[0]);
      (*(void (**)(uint64_t, uint64_t, const __CFString *, CFStringRef))(*(_QWORD *)v7 + 16))(v7, 4294900297, CFSTR("SecCSResourceHasSidebandData"), v24);
    }
    Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)__b);
  }
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(v14 + 32) + 40))(__p);
  Security::cfString((Security *)__b, v155);
  v25 = HIBYTE(__p[2]);
  if (SHIBYTE(__p[2]) >= 0)
    v26 = (void *)HIBYTE(__p[2]);
  else
    v26 = __p[1];
  size = HIBYTE(__b[0].__r_.__value_.__r.__words[2]);
  v28 = SHIBYTE(__b[0].__r_.__value_.__r.__words[2]);
  if ((__b[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __b[0].__r_.__value_.__l.__size_;
  if (v26 == (void *)size)
  {
    if ((__b[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v29 = __b;
    else
      v29 = (std::string *)__b[0].__r_.__value_.__r.__words[0];
    if (SHIBYTE(__p[2]) < 0)
    {
      v38 = memcmp(__p[0], v29, (size_t)__p[1]) == 0;
      if ((v28 & 0x80000000) == 0)
        goto LABEL_45;
    }
    else if (HIBYTE(__p[2]))
    {
      v30 = HIBYTE(__p[2]) - 1;
      v31 = __p;
      do
      {
        v33 = *(unsigned __int8 *)v31;
        v31 = (void **)((char *)v31 + 1);
        v32 = v33;
        v35 = v29->__r_.__value_.__s.__data_[0];
        v29 = (std::string *)((char *)v29 + 1);
        v34 = v35;
        v37 = v30-- != 0;
        v38 = v32 == v34;
      }
      while (v32 == v34 && v37);
      if ((SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_45:
        if ((v25 & 0x80) == 0)
          goto LABEL_46;
LABEL_50:
        operator delete(__p[0]);
        if (v38)
          goto LABEL_47;
        goto LABEL_51;
      }
    }
    else
    {
      v38 = 1;
      if ((SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_45;
    }
  }
  else
  {
    v38 = 0;
    if ((SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_45;
  }
  operator delete(__b[0].__r_.__value_.__l.__data_);
  if ((HIBYTE(__p[2]) & 0x80) != 0)
    goto LABEL_50;
LABEL_46:
  if (v38)
  {
LABEL_47:
    (*(void (**)(uint64_t, uint64_t, const __CFString *, __CFURL *))(*(_QWORD *)v7 + 16))(v7, 4294900242, CFSTR("SecCSResourceRecursive"), v155);
    return Security::CFRef<__CFURL const*>::~CFRef((const void **)&v155);
  }
LABEL_51:
  if (*(char *)(v11 + 23) < 0)
    std::string::__init_copy_ctor_external(&v154, *(const std::string::value_type **)v11, *(_QWORD *)(v11 + 8));
  else
    v154 = *(std::string *)v11;
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)__p, (char *)&v154);
  Value = CFDictionaryGetValue(v13, __p[0]);
  Security::CFRef<__CFString const*>::~CFRef((const void **)__p);
  if ((SHIBYTE(v154.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (Value)
      goto LABEL_58;
LABEL_73:
    if (v3 != 2)
    {
      if (v3 == 1)
      {
        memset(__p, 170, 0x400uLL);
        Security::cfString((Security *)__b, v155);
        if ((__b[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v47 = __b;
        else
          v47 = (std::string *)__b[0].__r_.__value_.__r.__words[0];
        v48 = readlink((const char *)v47, (char *)__p, 0x400uLL);
        if (SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) < 0)
          operator delete(__b[0].__r_.__value_.__l.__data_);
        if (v48 >= 1)
          return Security::CFRef<__CFURL const*>::~CFRef((const void **)&v155);
      }
LABEL_189:
      if (*(char *)(v11 + 23) < 0)
        std::string::__init_copy_ctor_external(&v142, *(const std::string::value_type **)v11, *(_QWORD *)(v11 + 8));
      else
        v142 = *(std::string *)v11;
      v102 = Security::CodeSigning::SecStaticCode::resourceBase((Security::CodeSigning::SecStaticCode *)v14);
      if ((v142.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v104 = &v142;
      else
        v104 = (std::string *)v142.__r_.__value_.__r.__words[0];
      __p[0] = Security::makeCFURL((Security *)v104, 0, v102, v103);
      (*(void (**)(uint64_t, uint64_t, const __CFString *, void *))(*(_QWORD *)v7 + 16))(v7, 4294900242, CFSTR("SecCSResourceAdded"), __p[0]);
      Security::CFRef<__CFURL const*>::~CFRef((const void **)__p);
      if (SHIBYTE(v142.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v142.__r_.__value_.__l.__data_);
      return Security::CFRef<__CFURL const*>::~CFRef((const void **)&v155);
    }
    if (*(char *)(v11 + 23) < 0)
      std::string::__init_copy_ctor_external(&v143, *(const std::string::value_type **)v11, *(_QWORD *)(v11 + 8));
    else
      v143 = *(std::string *)v11;
    v99 = Security::CodeSigning::SecStaticCode::checkfix30814861(v14, (const std::string::value_type *)&v143, 1);
    v100 = v99;
    if (SHIBYTE(v143.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v143.__r_.__value_.__l.__data_);
      if ((v100 & 1) == 0)
        goto LABEL_189;
    }
    else if (!v99)
    {
      goto LABEL_189;
    }
    v101 = secLogObjForScope("validateResource");
    if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
    {
      if (*(char *)(v11 + 23) < 0)
        v11 = *(_QWORD *)v11;
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v11;
      _os_log_debug_impl(&dword_18A900000, v101, OS_LOG_TYPE_DEBUG, "%s check-fixed (added).", (uint8_t *)__p, 0xCu);
    }
    return Security::CFRef<__CFURL const*>::~CFRef((const void **)&v155);
  }
  operator delete(v154.__r_.__value_.__l.__data_);
  if (!Value)
    goto LABEL_73;
LABEL_58:
  *(_QWORD *)&v40 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v40 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)text = v40;
  *(_OWORD *)theString = v40;
  Security::CodeSigning::ResourceSeal::ResourceSeal((Security::CodeSigning::ResourceSeal *)text, Value);
  if (((uint64_t)theString[1] & 4) == 0)
  {
    if (theString[0])
    {
      if (v9)
      {
        Security::cfString((Security *)&__str, v155);
        Security::cfString(&v149, theString[0]);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          p_str = &__str;
        else
          p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        memset(__p, 170, 0x400uLL);
        v42 = readlink((const char *)p_str, (char *)__p, 0x3FFuLL);
        if (v42 < 0)
        {
          v138 = __error();
          Security::UnixError::throwMe((Security::UnixError *)*v138);
        }
        *((_BYTE *)__p + v42) = 0;
        memset(v170, 170, 24);
        std::string::basic_string[abi:ne180100]<0>(v170, (char *)__p);
        if (LOBYTE(__p[0]) != 47)
        {
          v43 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          v44 = &__str;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
          {
            v43 = __str.__r_.__value_.__l.__size_;
            v44 = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          if (v43)
          {
            do
            {
              if (!v43)
                goto LABEL_197;
              v45 = v44->__r_.__value_.__s.__data_[--v43];
            }
            while (v45 != 47);
            v46 = v43;
          }
          else
          {
LABEL_197:
            v46 = -1;
          }
          std::string::basic_string((std::string *)v161, &__str, 0, v46, (std::allocator<char> *)v169);
          std::string::push_back((std::string *)v161, 47);
          __b[0] = *(std::string *)v161;
          memset(v161, 0, 24);
          v105 = strlen((const char *)__p);
          v106 = std::string::append(__b, (const std::string::value_type *)__p, v105);
          v107 = (void *)v106->__r_.__value_.__r.__words[0];
          *(_QWORD *)v171 = v106->__r_.__value_.__l.__size_;
          *(_QWORD *)&v171[7] = *(std::string::size_type *)((char *)&v106->__r_.__value_.__r.__words[1] + 7);
          v108 = HIBYTE(v106->__r_.__value_.__r.__words[2]);
          v106->__r_.__value_.__l.__size_ = 0;
          v106->__r_.__value_.__r.__words[2] = 0;
          v106->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(v170[2]) < 0)
            operator delete(v170[0]);
          v170[0] = v107;
          v170[1] = *(void **)v171;
          *(void **)((char *)&v170[1] + 7) = *(void **)&v171[7];
          HIBYTE(v170[2]) = v108;
          if (SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) < 0)
            operator delete(__b[0].__r_.__value_.__l.__data_);
          if ((v161[23] & 0x80000000) != 0)
            operator delete(*(void **)v161);
        }
        if ((v149.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v109 = HIBYTE(v149.__r_.__value_.__r.__words[2]);
        else
          v109 = v149.__r_.__value_.__l.__size_;
        if (v109 != strlen((const char *)__p)
          || ((v149.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? (v110 = &v149)
            : (v110 = (std::string *)v149.__r_.__value_.__r.__words[0]),
              memcmp(v110, __p, v109)))
        {
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
            std::string::__init_copy_ctor_external(__b, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
          else
            __b[0] = __str;
          Security::CFTempString::CFTempString<std::string>((CFStringRef *)v161, (char *)__b);
          (*(void (**)(uint64_t, uint64_t, const __CFString *, _QWORD))(*(_QWORD *)v7 + 16))(v7, 4294900242, CFSTR("SecCSResourceAltered"), *(_QWORD *)v161);
          Security::CFRef<__CFString const*>::~CFRef((const void **)v161);
          if ((SHIBYTE(__b[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_273;
          v111 = (void *)__b[0].__r_.__value_.__r.__words[0];
          goto LABEL_217;
        }
        if ((~*(_DWORD *)(v14 + 208) & 0x90) != 0)
          goto LABEL_273;
        memset(__b, 170, 0x400uLL);
        if (SHIBYTE(v170[2]) >= 0)
          v112 = v170;
        else
          v112 = (void **)v170[0];
        if (!realpath_DARWIN_EXTSN((const char *)v112, (char *)__b))
          goto LABEL_259;
        v113 = strlen((const char *)__b);
        if (LOBYTE(__p[0]) == 47)
        {
          v114 = v113;
          v115 = "/System/";
          v116 = &off_1E1FDCA40;
          while (1)
          {
            v117 = strlen(v115);
            if (v114 > v117 && !strncmp((const char *)__b, v115, v117))
              goto LABEL_273;
            v118 = *v116++;
            v115 = v118;
            if (!v118)
              goto LABEL_259;
          }
        }
        v119 = v14;
        while (1)
        {
          memset(v161, 170, 24);
          v120 = *(_QWORD *)(v119 + 328);
          if (*(char *)(v120 + 23) < 0)
          {
            std::string::__init_copy_ctor_external((std::string *)v161, *(const std::string::value_type **)v120, *(_QWORD *)(v120 + 8));
          }
          else
          {
            *(_OWORD *)v161 = *(_OWORD *)v120;
            *(_QWORD *)&v161[16] = *(_QWORD *)(v120 + 16);
          }
          v121 = v161[23];
          if ((v161[23] & 0x80000000) != 0)
          {
            v126 = *(_QWORD *)&v161[8];
            v122 = *(void **)v161;
            if (!strncmp((const char *)__b, *(const char **)v161, *(size_t *)&v161[8]))
              goto LABEL_254;
            operator delete(v122);
          }
          else if (!strncmp((const char *)__b, v161, v161[23]))
          {
            v126 = v121;
LABEL_254:
            v127 = *(_QWORD *)(v119 + 328);
            std::string::basic_string[abi:ne180100]<0>(v171, (char *)&__b[0].__r_.__value_.__l.__data_ + v126 + 1);
            v128 = Security::CodeSigning::ResourceBuilder::includes(v127, (std::string *)v171);
            if ((v171[23] & 0x80000000) != 0)
              operator delete(*(void **)v171);
            if ((v121 & 0x80) != 0)
              operator delete(*(void **)v161);
            if ((v128 & 1) == 0)
            {
LABEL_259:
              v131 = *(_QWORD *)(v14 + 152);
              v130 = v14 + 152;
              v129 = v131;
              if (v131)
              {
                v132 = v130;
                do
                {
                  v133 = *(_DWORD *)(v129 + 28);
                  v134 = v133 < -67003;
                  if (v133 >= -67003)
                    v135 = (uint64_t *)v129;
                  else
                    v135 = (uint64_t *)(v129 + 8);
                  if (!v134)
                    v132 = v129;
                  v129 = *v135;
                }
                while (*v135);
                if (v132 != v130 && *(int *)(v132 + 28) <= -67003)
                  goto LABEL_273;
              }
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
                std::string::__init_copy_ctor_external((std::string *)v161, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
              else
                *(std::string *)v161 = __str;
              Security::CFTempString::CFTempString<std::string>((CFStringRef *)v169, v161);
              (*(void (**)(uint64_t, uint64_t, const __CFString *, void *))(*(_QWORD *)v7 + 16))(v7, 4294900293, CFSTR("SecCSResourceAltered"), v169[0]);
              Security::CFRef<__CFString const*>::~CFRef((const void **)v169);
              if ((v161[23] & 0x80000000) == 0)
                goto LABEL_273;
              v111 = *(void **)v161;
LABEL_217:
              operator delete(v111);
            }
LABEL_273:
            if (SHIBYTE(v170[2]) < 0)
              operator delete(v170[0]);
            if (SHIBYTE(v149.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v149.__r_.__value_.__l.__data_);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
            {
              v98 = (void *)__str.__r_.__value_.__r.__words[0];
LABEL_279:
              operator delete(v98);
            }
            goto LABEL_280;
          }
          v119 = *(_QWORD *)(v119 + 320);
          if (!v119)
            goto LABEL_259;
        }
      }
LABEL_83:
      (*(void (**)(uint64_t, uint64_t, const __CFString *, __CFURL *))(*(_QWORD *)v7 + 16))(v7, 4294900242, CFSTR("SecCSResourceAltered"), v155);
      goto LABEL_280;
    }
    v53 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)v14, 1);
    if (!Security::CodeSigning::ResourceSeal::hash((CFDictionaryRef *)text, v53[37]) || (v9 & 1) != 0)
      goto LABEL_83;
    v170[0] = (void *)0xAAAAAAAAFFFFFFFFLL;
    Security::cfString((Security *)__p, v155);
    if (SHIBYTE(__p[2]) >= 0)
      v54 = __p;
    else
      v54 = (void **)__p[0];
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)v170, (const char *)v54, 0, 4096);
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
    if (LODWORD(v170[0]) == -1)
    {
      if (((uint64_t)theString[1] & 1) != 0)
      {
        Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)v170);
        goto LABEL_280;
      }
      (*(void (**)(uint64_t, uint64_t, const __CFString *, __CFURL *))(*(_QWORD *)v7 + 16))(v7, 4294900242, CFSTR("SecCSResourceMissing"), v155);
      goto LABEL_253;
    }
    __p[0] = 0;
    __p[1] = __p;
    __p[2] = (void *)0x2000000000;
    LOBYTE(__p[3]) = 1;
    v147 = (int)v170[0];
    v148 = BYTE4(v170[0]);
    std::set<unsigned int>::set[abi:ne180100]((uint64_t)v146, (_QWORD *)(v14 + 344));
    v145[0] = MEMORY[0x1E0C809B0];
    v145[1] = 0x40000000;
    v145[2] = ___ZN8Security11CodeSigning13SecStaticCode16validateResourceEPK14__CFDictionaryNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEEbRNS1_17ValidationContextEjj_block_invoke;
    v145[3] = &unk_1E1FDCA10;
    v145[4] = __p;
    v145[5] = text;
    Security::CodeSigning::CodeDirectory::multipleHashFileData((uint64_t)&v147, 0, v146, (uint64_t)v145);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((_QWORD *)v146[1]);
    if (!*((_BYTE *)__p[1] + 24))
    {
      if (v3 == 2)
      {
        if (*(char *)(v11 + 23) < 0)
          std::string::__init_copy_ctor_external(&v144, *(const std::string::value_type **)v11, *(_QWORD *)(v11 + 8));
        else
          v144 = *(std::string *)v11;
        v123 = Security::CodeSigning::SecStaticCode::checkfix30814861(v14, (const std::string::value_type *)&v144, 0);
        v124 = v123;
        if (SHIBYTE(v144.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v144.__r_.__value_.__l.__data_);
          if ((v124 & 1) != 0)
          {
LABEL_246:
            v125 = secLogObjForScope("validateResource");
            if (os_log_type_enabled(v125, OS_LOG_TYPE_DEBUG))
            {
              if (*(char *)(v11 + 23) < 0)
                v11 = *(_QWORD *)v11;
              LODWORD(__b[0].__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)__b[0].__r_.__value_.__r.__words + 4) = v11;
              _os_log_debug_impl(&dword_18A900000, v125, OS_LOG_TYPE_DEBUG, "%s check-fixed (altered).", (uint8_t *)__b, 0xCu);
            }
            goto LABEL_252;
          }
        }
        else if (v123)
        {
          goto LABEL_246;
        }
      }
      (*(void (**)(uint64_t, uint64_t, const __CFString *, __CFURL *))(*(_QWORD *)v7 + 16))(v7, 4294900242, CFSTR("SecCSResourceAltered"), v155);
    }
LABEL_252:
    _Block_object_dispose(__p, 8);
LABEL_253:
    Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)v170);
    goto LABEL_280;
  }
  if ((v9 & 1) != 0)
    goto LABEL_83;
  memset(v151, 170, sizeof(v151));
  std::string::basic_string[abi:ne180100]<0>(v151, ".framework");
  if (*(char *)(v11 + 23) < 0)
  {
    v55 = *(_QWORD *)(v11 + 8);
    v50 = v151[2] < 0;
    if (v151[2] >= 0)
      v51 = HIBYTE(v151[2]);
    else
      v51 = v151[1];
    v134 = v55 > v51;
    v52 = v55 - v51;
    if (!v134)
      goto LABEL_116;
    v11 = *(_QWORD *)v11;
LABEL_112:
    if (v50)
      v56 = (_QWORD *)v151[0];
    else
      v56 = v151;
    v57 = memcmp((const void *)(v11 + v52), v56, v51) == 0;
    goto LABEL_117;
  }
  v49 = *(unsigned __int8 *)(v11 + 23);
  v50 = v151[2] < 0;
  if (v151[2] >= 0)
    v51 = HIBYTE(v151[2]);
  else
    v51 = v151[1];
  v134 = v49 > v51;
  v52 = v49 - v51;
  if (v134)
    goto LABEL_112;
LABEL_116:
  v57 = 0;
LABEL_117:
  v58 = v155;
  requirement = 0;
  if (SecRequirementCreateWithStringAndErrors(text[1], 0, 0, &requirement))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA11);
  if ((v5 & 8) != 0)
    v59 = v5;
  else
    v59 = v5 | 0x4000006;
  v156 = 0xAAAAAAAAAAAAAAAALL;
  v60 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  v62 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate((Security::SecCFObject *)0x288, *(_QWORD *)(v60 + 200), v61);
  Security::cfString((Security *)__p, v58);
  if (SHIBYTE(__p[2]) >= 0)
    v63 = (char *)__p;
  else
    v63 = (char *)__p[0];
  v64 = (Security::CodeSigning::DiskRep *)Security::CodeSigning::DiskRep::bestGuess(v63, 0);
  Security::CodeSigning::SecStaticCode::SecStaticCode(v62, v64, 0);
  v65 = (unsigned __int8 *)v62 - 8;
  do
    v66 = __ldaxr(v65);
  while (__stlxr(1u, v65));
  if ((v66 & 1) != 0)
  {
    v67 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)v62 + 16))(v62);
    CFRetain(v67);
  }
  v156 = (unint64_t)v62;
  if (SHIBYTE(__p[2]) < 0)
  {
    operator delete(__p[0]);
    v62 = (Security::CodeSigning::SecStaticCode *)v156;
  }
  Security::CodeSigning::SecStaticCode::initializeFromParent(v62, (const Security::CodeSigning::SecStaticCode *)v14);
  v68 = (Security::CodeSigning::SecStaticCode *)v156;
  v70 = (const Security::CodeSigning::SecRequirement *)Security::CodeSigning::SecRequirement::required(requirement, v69);
  v140 = v59 & 0xFFFFFEFF;
  Security::CodeSigning::SecStaticCode::staticValidate(v68, v59 & 0xFFFFFEFF, v70);
  v71 = !v57;
  if ((v59 & 0x10) == 0)
    v71 = 1;
  if ((v71 & 1) == 0)
  {
    v139 = requirement;
    memset(v169, 170, sizeof(v169));
    v72 = (const __CFURL *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(v156 + 32) + 48))(*(_QWORD *)(v156 + 32));
    Security::cfStringRelease((Security *)v169, v72);
    memset(__b, 170, 0x400uLL);
    if (SHIBYTE(v169[2]) >= 0)
      v73 = v169;
    else
      v73 = (void **)v169[0];
    v141 = realpath_DARWIN_EXTSN((const char *)v73, (char *)__b);
    v168 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v74 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v74 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v167[7] = v74;
    v167[8] = v74;
    v167[5] = v74;
    v167[6] = v74;
    v167[3] = v74;
    v167[4] = v74;
    v167[1] = v74;
    v167[2] = v74;
    v166 = v74;
    v167[0] = v74;
    *(_OWORD *)v164 = v74;
    v165 = v74;
    v162 = v74;
    v163 = v74;
    *(_OWORD *)v161 = v74;
    *(_OWORD *)&v161[16] = v74;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v161);
    Security::cfString((Security *)__p, v58);
    if (SHIBYTE(__p[2]) >= 0)
      v75 = __p;
    else
      v75 = (void **)__p[0];
    if (SHIBYTE(__p[2]) >= 0)
      v76 = HIBYTE(__p[2]);
    else
      v76 = (uint64_t)__p[1];
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v161, (uint64_t)v75, v76);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v161, (uint64_t)"/Versions/", 10);
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
    memset(__p, 170, sizeof(__p));
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>(&__dst, (uint64_t)&v161[8]);
    Security::CodeSigning::DirScanner::DirScanner((uint64_t)__p, &__dst);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__dst.__r_.__value_.__l.__data_);
    v77 = *MEMORY[0x1E0DE4F60];
    v78 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
    if (LOBYTE(__p[135]))
    {
      v79 = MEMORY[0x1E0DE4FB8] + 16;
      while (1)
      {
        Next = Security::CodeSigning::DirScanner::getNext((DIR **)__p);
        if (!Next)
          break;
        v178 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)&v81 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v81 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v177[8] = v81;
        v177[7] = v81;
        v177[6] = v81;
        v177[5] = v81;
        v177[4] = v81;
        v177[3] = v81;
        v177[2] = v81;
        v177[1] = v81;
        v177[0] = v81;
        v176 = v81;
        v175 = v81;
        *(_OWORD *)v174 = v81;
        v173 = v81;
        v172 = v81;
        *(_OWORD *)&v171[16] = v81;
        *(_OWORD *)v171 = v81;
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v171);
        if (Next->d_type == 4)
        {
          d_name = Next->d_name;
          if (strcmp(d_name, "Current"))
          {
            std::stringbuf::str[abi:ne180100]<std::allocator<char>>(v170, (uint64_t)&v161[8]);
            if (SHIBYTE(v170[2]) >= 0)
              v83 = v170;
            else
              v83 = (void **)v170[0];
            if (SHIBYTE(v170[2]) >= 0)
              v84 = HIBYTE(v170[2]);
            else
              v84 = (uint64_t)v170[1];
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v171, (uint64_t)v83, v84);
            v85 = strlen(d_name);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v171, (uint64_t)d_name, v85);
            if (SHIBYTE(v170[2]) < 0)
              operator delete(v170[0]);
            memset(v170, 170, sizeof(v170));
            std::stringbuf::str[abi:ne180100]<std::allocator<char>>(v158, (uint64_t)&v171[8]);
            if (v159 >= 0)
              v86 = v158;
            else
              v86 = (void **)v158[0];
            v87 = realpath_DARWIN_EXTSN((const char *)v86, (char *)v170);
            if (v159 < 0)
              operator delete(v158[0]);
            if (!v87)
            {
              v137 = __error();
              Security::UnixError::throwMe((Security::UnixError *)*v137);
            }
            if (!v141 || strcmp((const char *)__b, (const char *)v170))
            {
              v158[0] = (void *)0xAAAAAAAAAAAAAAAALL;
              v88 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
              v90 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate((Security::SecCFObject *)0x288, *(_QWORD *)(v88 + 200), v89);
              v91 = (Security::CodeSigning::DiskRep *)Security::CodeSigning::DiskRep::bestGuess((char *)v170, 0);
              Security::CodeSigning::SecStaticCode::SecStaticCode(v90, v91, 0);
              v92 = (unsigned __int8 *)v90 - 8;
              do
                v93 = __ldaxr(v92);
              while (__stlxr(1u, v92));
              if ((v93 & 1) != 0)
              {
                v94 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)v90 + 16))(v90);
                CFRetain(v94);
              }
              v158[0] = v90;
              Security::CodeSigning::SecStaticCode::initializeFromParent(v90, (const Security::CodeSigning::SecStaticCode *)v14);
              v95 = (Security::CodeSigning::SecStaticCode *)v158[0];
              v97 = (const Security::CodeSigning::SecRequirement *)Security::CodeSigning::SecRequirement::required(v139, v96);
              Security::CodeSigning::SecStaticCode::staticValidate(v95, v140, v97);
              Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)v158);
            }
          }
        }
        *(_QWORD *)v171 = v77;
        *(_QWORD *)&v171[*(_QWORD *)(v77 - 24)] = v78;
        *(_QWORD *)&v171[8] = v79;
        if (SHIBYTE(v175) < 0)
          operator delete(v174[1]);
        std::streambuf::~streambuf();
        std::ostream::~ostream();
        MEMORY[0x18D76FA34](v177);
      }
    }
    Security::CodeSigning::DirScanner::~DirScanner((Security::CodeSigning::DirScanner *)__p);
    *(_QWORD *)v161 = v77;
    *(_QWORD *)&v161[*(_QWORD *)(v77 - 24)] = v78;
    *(_QWORD *)&v161[8] = MEMORY[0x1E0DE4FB8] + 16;
    if (SHIBYTE(v165) < 0)
      operator delete(v164[1]);
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x18D76FA34](v167);
    if (SHIBYTE(v169[2]) < 0)
      operator delete(v169[0]);
  }
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v156);
  Security::CFRef<__SecRequirement *>::~CFRef((const void **)&requirement);
  if (SHIBYTE(v151[2]) < 0)
  {
    v98 = (void *)v151[0];
    goto LABEL_279;
  }
LABEL_280:
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)text);
  return Security::CFRef<__CFURL const*>::~CFRef((const void **)&v155);
}

void sub_18AA3C234(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, __CFString *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43,void *a44,uint64_t a45,int a46,__int16 a47,char a48,char a49,void *a50,uint64_t a51,uint64_t a52,const void *a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *a63)
{
  void *a69;
  char v69;

  if (SLOBYTE(STACK[0x6E7]) < 0)
    operator delete((void *)STACK[0x6D0]);
  if (v69 < 0)
    operator delete(a69);
  if (SLOBYTE(STACK[0x2E7]) < 0)
    operator delete((void *)STACK[0x2D0]);
  if (a43 < 0)
    operator delete(a38);
  if (a49 < 0)
    operator delete(a44);
  Security::CFRef<__CFDictionary const*>::~CFRef(&a53);
  JUMPOUT(0x18AA3C748);
}

void sub_18AA3C514()
{
  char *v0;

  Security::SecCFObject::operator delete(v0);
  std::ostringstream::~ostringstream((uint64_t)&STACK[0x6D0]);
  Security::CodeSigning::DirScanner::~DirScanner((Security::CodeSigning::DirScanner *)&STACK[0x7E0]);
  JUMPOUT(0x18AA3C5B4);
}

void sub_18AA3C534()
{
  if (SLOBYTE(STACK[0x2E7]) < 0)
    JUMPOUT(0x18AA3C548);
  std::ostringstream::~ostringstream(&STACK[0x6D0]);
  JUMPOUT(0x18AA3C5ACLL);
}

void sub_18AA3C550(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  Security::CFRef<__CFString const*>::~CFRef((const void **)&STACK[0x7E0]);
  if (a56 < 0)
    operator delete(__p);
  JUMPOUT(0x18AA3C748);
}

void sub_18AA3C584(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a57);
  JUMPOUT(0x18AA3C594);
}

void sub_18AA3C5A0()
{
  JUMPOUT(0x18AA3C5ACLL);
}

void sub_18AA3C6E0()
{
  __cxa_end_catch();
  JUMPOUT(0x18AA3C5DCLL);
}

void sub_18AA3C6F0()
{
  __cxa_end_catch();
  JUMPOUT(0x18AA3C5DCLL);
}

void sub_18AA3C700()
{
  __cxa_end_catch();
  JUMPOUT(0x18AA3C438);
}

void sub_18AA3C70C()
{
  __cxa_end_catch();
  JUMPOUT(0x18AA3C438);
}

void sub_18AA3C71C()
{
  if (SLOBYTE(STACK[0x7F7]) < 0)
    JUMPOUT(0x18AA3C72CLL);
  JUMPOUT(0x18AA3C748);
}

void sub_18AA3C734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,const void *a54)
{
  Security::CFRef<__CFURL const*>::~CFRef(&a54);
  _Unwind_Resume(a1);
}

void sub_18AA3C758(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x18AA3C750);
}

BOOL ___ZN8Security11CodeSigning13SecStaticCode16validateResourceEPK14__CFDictionaryNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEEbRNS1_17ValidationContextEjj_block_invoke(uint64_t a1, int a2, Security::DynamicHash *a3)
{
  const unsigned __int8 *v5;
  _BOOL8 result;

  v5 = Security::CodeSigning::ResourceSeal::hash(*(CFDictionaryRef **)(a1 + 40), a2);
  result = Security::DynamicHash::verify(a3, v5);
  if (!result)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

uint64_t Security::CodeSigning::SecStaticCode::checkfix30814861(uint64_t a1, const std::string::value_type *a2, int a3)
{
  const void *Value;
  const __CFNumber *v7;
  int v8;
  unsigned int v9;
  const void *v10;
  const __CFNumber *v11;
  BOOL v12;
  char v13;
  uint64_t v14;
  const regex_t *v15;
  const char *v16;
  int v17;
  int v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t Rule;
  uint64_t v23;
  std::string __p;
  _QWORD block[5];
  const __CFDictionary *v27;
  unsigned int valuePtr;
  CFDictionaryRef theDict;
  _QWORD v30[3];

  v30[2] = *MEMORY[0x1E0C80C00];
  v27 = (const __CFDictionary *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 160))(*(_QWORD *)(a1 + 32));
  theDict = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  v30[0] = 0xAAAAAAAAAAAAAAAALL;
  Security::CFDictionary::CFDictionary((Security::CFDictionary *)&theDict, v27, (Security::MacOSError *)0xFFFEFA23);
  Value = CFDictionaryGetValue(theDict, CFSTR("VersionPlatform"));
  v7 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(Value, (Security::MacOSError *)0xFFFEFA23);
  valuePtr = -1431655766;
  v8 = CFNumberGetValue(v7, kCFNumberIntType, &valuePtr);
  v9 = valuePtr;
  v10 = CFDictionaryGetValue(theDict, CFSTR("VersionSDK"));
  v11 = (const __CFNumber *)Security::CFRef<__CFNumber const*>::check<void const*>(v10, (Security::MacOSError *)0xFFFEFA23);
  valuePtr = -1431655766;
  if (CFNumberGetValue(v11, kCFNumberIntType, &valuePtr))
    v12 = valuePtr >= 0x90000;
  else
    v12 = 0;
  v13 = !v12;
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&theDict);
  v14 = 0;
  if (!v8 || v9 != 2 || (v13 & 1) == 0)
    goto LABEL_34;
  if (Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::once != -1)
    dispatch_once(&Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::once, &__block_literal_global_14320);
  if (a3)
    v15 = (const regex_t *)&Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::pathre_sinf;
  else
    v15 = (const regex_t *)&Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::pathre_supp_supf;
  v16 = a2;
  if (a2[23] < 0)
    v16 = *(const char **)a2;
  v17 = regexec(v15, v16, 0, 0, 0);
  v18 = v17;
  if (!v17)
  {
    v20 = *(_QWORD *)(a1 + 24);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___ZN8Security11CodeSigning13SecStaticCode16checkfix30814861ENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb_block_invoke_51;
    block[3] = &__block_descriptor_tmp_52_14323;
    block[4] = a1;
    if (v20 != -1)
      dispatch_once((dispatch_once_t *)(a1 + 24), block);
    v21 = *(_QWORD *)(a1 + 16);
    if (a2[23] < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    else
      __p = *(std::string *)a2;
    Rule = Security::CodeSigning::ResourceBuilder::findRule(v21, (uint64_t)&__p);
    v23 = Rule;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if (!v23)
        goto LABEL_33;
    }
    else if (!Rule)
    {
      goto LABEL_33;
    }
    v14 = (*(unsigned __int8 *)(v23 + 36) >> 1) & 1;
    goto LABEL_34;
  }
  if (v17 == 1)
  {
LABEL_33:
    v14 = 0;
    goto LABEL_34;
  }
  v19 = secLogObjForScope("SecError");
  v14 = 0;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[23] < 0)
      a2 = *(const std::string::value_type **)a2;
    LODWORD(theDict) = 67109378;
    HIDWORD(theDict) = v18;
    LOWORD(v30[0]) = 2080;
    *(_QWORD *)((char *)v30 + 2) = a2;
    _os_log_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEFAULT, "unexpected regexec result %d for path '%s'", (uint8_t *)&theDict, 0x12u);
    goto LABEL_33;
  }
LABEL_34:
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v27);
  return v14;
}

void ___ZN8Security11CodeSigning13SecStaticCode16checkfix30814861ENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb_block_invoke_51(uint64_t a1)
{
  Security::CodeSigning::SecStaticCode *v1;
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  const __CFURL *v10;
  std::string::size_type v11;
  uint64_t v12;
  void *__p[3];

  v1 = *(Security::CodeSigning::SecStaticCode **)(a1 + 32);
  v2 = (const void *)Security::CodeSigning::SecStaticCode::resourceDictionary(v1, 1);
  v9 = Security::cfget<__CFDictionary const*>(v2, (uint64_t)"rules", v3, v4, v5, v6, v7, v8, v12);
  memset(__p, 170, sizeof(__p));
  v10 = (const __CFURL *)Security::CodeSigning::SecStaticCode::resourceBase(v1);
  Security::cfString((Security *)__p, v10);
  v11 = operator new();
  Security::CodeSigning::ResourceBuilder::ResourceBuilder(v11, (uint64_t)__p, (uint64_t)__p, v9, 0, (uint64_t)v1 + 144);
  *((_QWORD *)v1 + 2) = v11;
  if (SHIBYTE(__p[2]) < 0)
    operator delete(__p[0]);
}

void sub_18AA3CB98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  MEMORY[0x18D76FAA0](v15, 0x10F2C40CEC4FCADLL);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t ___ZN8Security11CodeSigning13SecStaticCode16checkfix30814861ENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEb_block_invoke()
{
  uint64_t result;

  if (regcomp(&Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::pathre_sinf, "^(Frameworks/[^/]+\\.framework/|PlugIns/[^/]+\\.appex/|())SC_Info/[^/]+\\.sinf$", 5))
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_5;
  }
  result = regcomp(&Security::CodeSigning::SecStaticCode::checkfix30814861(std::string,BOOL)::pathre_supp_supf, "^(Frameworks/[^/]+\\.framework/|PlugIns/[^/]+\\.appex/|())SC_Info/[^/]+\\.(supf|supp)$", 5);
  if ((_DWORD)result)
  {
LABEL_5:
    _os_assert_log();
    result = _os_crash();
    __break(1u);
  }
  return result;
}

void ___ZN8Security11CodeSigning13SecStaticCode14staticValidateEjPKNS0_14SecRequirementE_block_invoke(uint64_t a1, Security::CodeSigning::SecStaticCode *this)
{
  uint64_t v4;
  Security::Universal *v5;

  v4 = *(_QWORD *)(a1 + 32);
  if ((*(_BYTE *)(a1 + 48) & 0x41) == 0
    || (v5 = (Security::Universal *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 80))(*((_QWORD *)this + 4)),
        (Security::Universal::bestNativeArch(v5) & 0xFFFFFF) != 0x12))
  {
    Security::CodeSigning::SecStaticCode::detachedSignature(this, *(const __CFData **)(v4 + 136));
    Security::CodeSigning::SecStaticCode::staticValidateCore((UInt8 *)this, *(_DWORD *)(a1 + 48), *(Security::CodeSigning::Requirement ***)(a1 + 40));
  }
}

uint64_t ___ZN8Security11CodeSigning13SecStaticCode24handleOtherArchitecturesEU13block_pointerFvPS1_E_block_invoke(uint64_t a1, Security::CodeSigning::SecStaticCode *a2)
{
  Security::CodeSigning::SecStaticCode *v4;
  const char *v5;
  const char *v6;
  const UInt8 *v7;

  v4 = *(Security::CodeSigning::SecStaticCode **)(a1 + 40);
  if (Security::CodeSigning::SecStaticCode::teamID(v4) && Security::CodeSigning::SecStaticCode::teamID(a2))
  {
    v5 = (const char *)Security::CodeSigning::SecStaticCode::teamID(v4);
    v6 = (const char *)Security::CodeSigning::SecStaticCode::teamID(a2);
    if (strcmp(v5, v6))
      goto LABEL_4;
  }
  else
  {
    v7 = Security::CodeSigning::SecStaticCode::teamID(v4);
    if (v7 != Security::CodeSigning::SecStaticCode::teamID(a2))
LABEL_4:
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA1BLL);
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

BOOL Security::CodeSigning::SecStaticCode::satisfiesRequirement(uint64_t a1, Security::CodeSigning::Requirement *a2)
{
  double v4;
  Security::Universal *v5;
  char v6;
  BOOL v7;
  char v8;
  const char *v9;
  int v10;
  const char *v11;
  Security::CodeSigning *v12;
  Security::CodeSigning::CodeDirectory *v13;
  Security::CodeSigning::CodeDirectory *v14;
  Security::CodeSigning::CodeDirectory *v15;
  const UInt8 *v16;
  const UInt8 *v17;
  char v18;
  CFDateRef v19;
  const UInt8 *v20;
  _BOOL8 v21;
  Security::CodeSigning::Requirement *v23;
  int v24;
  std::string v25;
  Security::CodeSigning::CodeDirectory *v26[3];
  std::string __p;
  const UInt8 *v28;
  uint64_t v29;
  int v30;
  char v31;
  CFDateRef v32;
  const UInt8 *v33;
  char v34;
  char v35;
  BOOL v36;
  char v37;
  int v38;
  void *v39[3];
  const __CFURL *v40;
  CFDateRef v41;

  Security::CodeSigning::SecStaticCode::validateDirectory((UInt8 *)a1);
  v41 = 0;
  Security::CodeSigning::SecStaticCode::validateDirectory((UInt8 *)a1);
  v4 = *(double *)(a1 + 384);
  if (v4 != 0.0)
    v41 = CFDateCreate(0, v4);
  v40 = (const __CFURL *)0xAAAAAAAAAAAAAAAALL;
  v40 = (const __CFURL *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 48))(*(_QWORD *)(a1 + 32));
  memset(v39, 170, sizeof(v39));
  Security::cfString((Security *)v39, v40);
  if (*((_DWORD *)a2 + 2) == 0x2000000)
  {
    v5 = (Security::Universal *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 80))(*(_QWORD *)(a1 + 32));
    if (v5)
    {
      v26[0] = (Security::CodeSigning::CodeDirectory *)Security::Universal::bestNativeArch(v5);
      v6 = (*(uint64_t (**)(_QWORD, Security::CodeSigning::CodeDirectory **))(**(_QWORD **)(a1 + 32) + 120))(*(_QWORD *)(a1 + 32), v26);
    }
    else
    {
      v6 = 0;
    }
    if (SHIBYTE(v39[2]) >= 0)
      v9 = (const char *)v39;
    else
      v9 = (const char *)v39[0];
    v10 = openat_authenticated_np(-2, v9, 0, -1);
    v7 = v10 != -1;
    if (v10 != -1)
      close(v10);
    if (SHIBYTE(v39[2]) >= 0)
      v12 = (Security::CodeSigning *)v39;
    else
      v12 = (Security::CodeSigning *)v39[0];
    v8 = Security::CodeSigning::isOnRootFilesystem(v12, v11);
    v24 = Security::CodeSigning::SecStaticCode::validationCategory((CFDataRef *)a1);
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v24 = 0;
  }
  v13 = *(Security::CodeSigning::CodeDirectory **)(a1 + 624);
  v14 = (Security::CodeSigning::CodeDirectory *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1);
  v15 = (Security::CodeSigning::CodeDirectory *)Security::CodeSigning::SecStaticCode::entitlements((UInt8 *)a1);
  v23 = a2;
  v16 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)a1, 1);
  std::string::basic_string[abi:ne180100]<0>(&v25, (char *)&v16[bswap32(*((_DWORD *)v16 + 5))]);
  v17 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)a1, 1);
  v18 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 248))(*(_QWORD *)(a1 + 32));
  v19 = v41;
  v20 = Security::CodeSigning::SecStaticCode::teamID((Security::CodeSigning::SecStaticCode *)a1);
  v26[0] = v13;
  v26[1] = v14;
  v26[2] = v15;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, v25.__r_.__value_.__l.__data_, v25.__r_.__value_.__l.__size_);
  else
    __p = v25;
  v28 = v17;
  v29 = 0;
  v30 = 0;
  v31 = v18;
  v32 = v19;
  v33 = v20;
  v34 = v6;
  v35 = 0;
  v36 = v7;
  v37 = v8;
  v38 = v24;
  v21 = Security::CodeSigning::Requirement::validates(v23, v26);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v25.__r_.__value_.__l.__data_);
  if (SHIBYTE(v39[2]) < 0)
    operator delete(v39[0]);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v40);
  Security::CFRef<__CFDate const*>::~CFRef((const void **)&v41);
  return v21;
}

void sub_18AA3D000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  uint64_t v26;

  if (*(char *)(v26 - 105) < 0)
    operator delete(*(void **)(v26 - 128));
  Security::CFRef<__CFURL const*>::~CFRef((const void **)(v26 - 104));
  Security::CFRef<__CFDate const*>::~CFRef((const void **)(v26 - 96));
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::SecStaticCode::validationCategory(CFDataRef *this)
{
  uint64_t result;
  const __CFData *v3;
  const UInt8 *BytePtr;
  CFIndex Length;
  const __CFData *v6;
  const UInt8 *v7;
  char v8;
  const UInt8 *v9;
  CFIndex v10;
  int v11;
  char v12;
  uint64_t v13;

  result = *((unsigned int *)this + 159);
  if (!(_DWORD)result)
  {
    v3 = Security::CodeSigning::SecStaticCode::cdHash(this);
    v13 = 0;
    BytePtr = CFDataGetBytePtr(v3);
    Length = CFDataGetLength(v3);
    if (!amfi_interface_cdhash_in_trustcache((uint64_t)BytePtr, Length, &v13) && v13 == 1)
    {
      result = 1;
LABEL_27:
      *((_DWORD *)this + 159) = result;
      return result;
    }
    v6 = (const __CFData *)Security::CodeSigning::SecStaticCode::signature((Security::CodeSigning::SecStaticCode *)this);
    v7 = Security::CodeSigning::SecStaticCode::codeDirectory((Security::CodeSigning::SecStaticCode *)this, 0);
    if (v7 && (v7[15] & 2) != 0)
    {
      result = 10;
      goto LABEL_27;
    }
    v13 = 0;
    if ((os_variant_allows_internal_security_policies() & 1) != 0)
    {
      v8 = 1;
    }
    else
    {
      if (SecAreQARootCertificatesEnabled_onceToken != -1)
        dispatch_once(&SecAreQARootCertificatesEnabled_onceToken, &__block_literal_global_12660);
      v8 = SecAreQARootCertificatesEnabled_sQACertsEnabled != 0;
    }
    v9 = CFDataGetBytePtr(v6);
    v10 = CFDataGetLength(v6);
    v11 = CTVerifyAmfiCertificateChain((uint64_t)v9, v10, v8, 16, &v13);
    result = 10;
    *((_DWORD *)this + 159) = 10;
    if (!v11)
    {
      if ((v13 & 0x80000001140) != 0 || ((v13 & 0x100000002200) != 0 ? (v12 = v8) : (v12 = 0), (v12 & 1) != 0))
      {
        result = 4;
        goto LABEL_27;
      }
      if ((v13 & 0x90) != 0)
      {
        result = 3;
        goto LABEL_27;
      }
      if ((v13 & 0x10000) != 0)
      {
        result = 5;
        goto LABEL_27;
      }
      if ((v13 & 0x400) == 0 && (v13 & 0xC000) != 0)
      {
        result = 2;
        goto LABEL_27;
      }
    }
  }
  return result;
}

void sub_18AA3D2A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)(v15 - 24));
  _Unwind_Resume(a1);
}

void ___ZN8Security11CodeSigning13SecStaticCode20hasWeakResourceRulesEPK14__CFDictionaryjPK9__CFArray_block_invoke(uint64_t a1, __CFString *a2, const void *a3)
{
  uint64_t v6;
  std::string::size_type size;
  uint64_t v8;
  int v9;
  unsigned __int8 *v10;
  std::string *p_s1;
  _BOOL4 v12;
  const void *v13;
  CFTypeID v14;
  const void *v15;
  std::string __s1;
  const void *v17[2];

  memset(&__s1, 170, sizeof(__s1));
  Security::cfString(&__s1, a2);
  v6 = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
  if ((__s1.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__s1.__r_.__value_.__r.__words[2]);
  else
    size = __s1.__r_.__value_.__l.__size_;
  v8 = *(unsigned __int8 *)(a1 + 71);
  v9 = (char)v8;
  if ((v8 & 0x80u) != 0)
    v8 = *(_QWORD *)(a1 + 56);
  if (size != v8)
  {
LABEL_16:
    v13 = (const void *)*MEMORY[0x1E0C9AE50];
    goto LABEL_17;
  }
  if (v9 >= 0)
    v10 = (unsigned __int8 *)(a1 + 48);
  else
    v10 = *(unsigned __int8 **)(a1 + 48);
  if ((*((_BYTE *)&__s1.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    v12 = memcmp(__s1.__r_.__value_.__l.__data_, v10, __s1.__r_.__value_.__l.__size_) == 0;
  }
  else
  {
    if (*((_BYTE *)&__s1.__r_.__value_.__s + 23))
    {
      p_s1 = &__s1;
      while (p_s1->__r_.__value_.__s.__data_[0] == *v10)
      {
        p_s1 = (std::string *)((char *)p_s1 + 1);
        ++v10;
        if (!--v6)
          goto LABEL_15;
      }
      goto LABEL_16;
    }
LABEL_15:
    v12 = 1;
  }
  v13 = (const void *)*MEMORY[0x1E0C9AE50];
  if (v12 && v13 == a3)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    goto LABEL_26;
  }
LABEL_17:
  v14 = CFGetTypeID(a3);
  if (v14 == CFBooleanGetTypeID())
  {
    if ((const void *)*MEMORY[0x1E0C9AE40] != a3)
      goto LABEL_26;
  }
  else
  {
    v17[0] = (const void *)0xAAAAAAAAAAAAAAAALL;
    v17[1] = (const void *)0xAAAAAAAAAAAAAAAALL;
    Security::CFDictionary::CFDictionary((Security::CFDictionary *)v17, a3);
    v15 = Security::CFDictionary::get<__CFBoolean const*>((uint64_t)v17, "omit");
    Security::CFRef<__CFDictionary const*>::~CFRef(v17);
    if (v15 != v13)
      goto LABEL_26;
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) |= CFArrayContainsValue(*(CFArrayRef *)(a1 + 72), *(CFRange *)(a1 + 80), a2) == 0;
LABEL_26:
  if (SHIBYTE(__s1.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__s1.__r_.__value_.__l.__data_);
}

void sub_18AA3D484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16)
{
  Security::CFRef<__CFDictionary const*>::~CFRef(&a16);
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t Security::CFDictionary::BlockApplier<__CFString const*,void const*>::apply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)a3 + 16))();
}

void __copy_helper_block_e8_48c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(std::string *a1, uint64_t a2)
{
  std::string *v2;
  __int128 v3;

  v2 = a1 + 2;
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 48), *(_QWORD *)(a2 + 56));
  }
  else
  {
    v3 = *(_OWORD *)(a2 + 48);
    v2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 64);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void __destroy_helper_block_e8_48c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
}

Security::CFDictionary *Security::CFDictionary::CFDictionary(Security::CFDictionary *this, CFTypeRef cf)
{
  CFTypeID v3;

  *(_QWORD *)this = cf;
  if (!cf)
  {
    *((_DWORD *)this + 2) = -67053;
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA13);
  }
  v3 = CFGetTypeID(cf);
  if (v3 != CFDictionaryGetTypeID())
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA13);
  if (*(_QWORD *)this)
    CFRetain(*(CFTypeRef *)this);
  *((_DWORD *)this + 2) = -67053;
  return this;
}

void sub_18AA3D58C(_Unwind_Exception *a1)
{
  const void **v1;

  Security::CFRef<__CFDictionary const*>::~CFRef(v1);
  _Unwind_Resume(a1);
}

const void *Security::CFDictionary::get<__CFBoolean const*>(uint64_t a1, const char *a2)
{
  const void *Value;
  void *key;

  Security::CFTempString::CFTempString<char const*>((CFStringRef *)&key, a2);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)a1, key);
  Security::CFRef<__CFBoolean const*>::check<void const*>(Value, (Security::MacOSError *)*(unsigned int *)(a1 + 8));
  Security::CFRef<__CFString const*>::~CFRef((const void **)&key);
  return Value;
}

void sub_18AA3D5F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFString const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

unsigned int *Security::CodeSigning::SecStaticCode::internalRequirements(Security::CodeSigning::SecStaticCode *this)
{
  unsigned int *result;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unsigned int v6;
  unint64_t v7;
  BOOL v8;

  result = (unsigned int *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *, uint64_t, uint64_t))(*(_QWORD *)this + 80))(this, 2, 4294900235);
  if (result)
  {
    result = (unsigned int *)CFDataGetBytePtr((CFDataRef)result);
    if (*result != 17620730
      || (v2 = bswap32(result[2]), v3 = 8 * v2 + 12, v4 = bswap32(result[1]), v3 > v4))
    {
      *__error() = 22;
LABEL_12:
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14);
    }
    v5 = (unint64_t)&result[2 * v2 + 3];
    while (1)
    {
      v5 -= 8;
      if (v5 < (unint64_t)(result + 3))
        break;
      v6 = *(_DWORD *)(v5 + 4);
      if (v6)
      {
        v7 = bswap32(v6);
        v8 = v3 > v7 || v7 + 8 > v4;
        if (v8 || bswap32(*(unsigned int *)((char *)result + v7 + 4)) + v7 > v4)
          goto LABEL_12;
      }
    }
  }
  return result;
}

_DWORD *Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::find<Security::CodeSigning::Requirement>(uint64_t a1, int a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  _DWORD *result;
  unsigned int v9;
  int *v11;

  v2 = *(_DWORD *)(a1 + 8);
  if (!v2)
    return 0;
  v3 = 0;
  LODWORD(v4) = bswap32(v2);
  v4 = v4 <= 1 ? 1 : v4;
  v5 = (unsigned int *)(a1 + 12);
  while (1)
  {
    v6 = *v5;
    v5 += 2;
    if (bswap32(v6) == a2)
      break;
    if (v4 == ++v3)
      return 0;
  }
  v7 = *(_DWORD *)(a1 + 8 * v3 + 16);
  if (!v7)
    return 0;
  result = (_DWORD *)(bswap32(v7) + a1);
  if (result)
  {
    v9 = bswap32(result[1]);
    if (*result != 843514 || v9 <= 0xB)
    {
      v11 = __error();
      result = 0;
      *v11 = 22;
    }
  }
  return result;
}

void *Security::CodeSigning::SecStaticCode::designatedRequirement(Security::CodeSigning::SecStaticCode *this)
{
  unsigned int *v2;
  void *v3;
  const UInt8 *v4;
  _DWORD *v5;
  uint64_t v6;
  const __CFArray *v7;
  CFIndex Count;
  CFIndex i;
  const __CFData *ValueAtIndex;
  uint64_t v11;
  const UInt8 *BytePtr;
  CFIndex Length;
  _QWORD v15[5];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t (*v19)(uint64_t, uint64_t);
  const void **(*v20)(uint64_t);
  CFMutableArrayRef MutableCopy;
  _QWORD v22[3];
  void *v23;
  uint64_t v24;
  _QWORD v25[6];

  v2 = Security::CodeSigning::SecStaticCode::internalRequirements(this);
  if (!v2
    || (v3 = Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::find<Security::CodeSigning::Requirement>((uint64_t)v2, 3)) == 0)
  {
    v3 = (void *)*((_QWORD *)this + 64);
    if (!v3)
    {
      v4 = Security::CodeSigning::SecStaticCode::codeDirectory(this, 0);
      if (!v4 || (v4[15] & 2) == 0)
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA00);
      v5 = malloc_type_malloc(0x400uLL, 0x96562061uLL);
      v23 = v5;
      *(_QWORD *)v5 = 843514;
      v5[2] = 0x1000000;
      v24 = 0xC00000400;
      v22[0] = 0xAAAAAAAA0000000CLL;
      v22[1] = &v23;
      v22[2] = 7;
      v16 = 0;
      v17 = &v16;
      v18 = 0x3002000000;
      v19 = __Block_byref_object_copy__64;
      v20 = __Block_byref_object_dispose__65;
      MutableCopy = (CFMutableArrayRef)0xAAAAAAAAAAAAAAAALL;
      v7 = (const __CFArray *)Security::CodeSigning::SecStaticCode::cdHashes(this, v6);
      MutableCopy = CFArrayCreateMutableCopy(0, 0, v7);
      v15[0] = MEMORY[0x1E0C809B0];
      v15[1] = 0x40000000;
      v15[2] = ___ZN8Security11CodeSigning13SecStaticCode28defaultDesignatedRequirementEv_block_invoke;
      v15[3] = &unk_1E1FDCA58;
      v15[4] = &v16;
      v25[0] = MEMORY[0x1E0C809B0];
      v25[1] = 0x40000000;
      v25[2] = ___ZN8Security11CodeSigning13SecStaticCode24handleOtherArchitecturesEU13block_pointerFvPS1_E_block_invoke;
      v25[3] = &unk_1E1FDCC70;
      v25[4] = v15;
      v25[5] = this;
      Security::CodeSigning::SecStaticCode::visitOtherArchitectures((uint64_t)this, (uint64_t)v25);
      Count = CFArrayGetCount((CFArrayRef)v17[5]);
      if (Count >= 1)
      {
        for (i = 0; i != Count; ++i)
        {
          Security::CodeSigning::Requirement::Maker::Chain::add(v22);
          ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)v17[5], i);
          Security::CodeSigning::Requirement::Maker::require(&v23, 4);
          v11 = HIDWORD(v24);
          HIDWORD(v24) += 4;
          *(_DWORD *)((char *)v23 + v11) = 0x8000000;
          BytePtr = CFDataGetBytePtr(ValueAtIndex);
          Length = CFDataGetLength(ValueAtIndex);
          Security::CodeSigning::Requirement::Maker::putData((Security::CodeSigning::Requirement::Maker *)&v23, BytePtr, Length);
        }
      }
      v3 = v23;
      *((_DWORD *)v23 + 1) = bswap32(HIDWORD(v24));
      v23 = 0;
      _Block_object_dispose(&v16, 8);
      Security::CFRef<__CFArray *>::~CFRef((const void **)&MutableCopy);
      free(v23);
      *((_QWORD *)this + 64) = v3;
    }
  }
  return v3;
}

void sub_18AA3D9C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  const void **v23;

  _Block_object_dispose(&a14, 8);
  Security::CFRef<__CFArray *>::~CFRef(v23);
  free(a23);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__64(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

const void **__Block_byref_object_dispose__65(uint64_t a1)
{
  return Security::CFRef<__CFArray *>::~CFRef((const void **)(a1 + 40));
}

void ___ZN8Security11CodeSigning13SecStaticCode28defaultDesignatedRequirementEv_block_invoke(uint64_t a1, Security::CodeSigning::SecStaticCode *this)
{
  const __CFArray *v3;
  __CFArray *v4;
  CFRange v5;

  v3 = (const __CFArray *)Security::CodeSigning::SecStaticCode::cdHashes(this, (uint64_t)this);
  v4 = *(__CFArray **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v5.length = CFArrayGetCount(v3);
  v5.location = 0;
  CFArrayAppendArray(v4, v3, v5);
}

_DWORD *Security::CodeSigning::Requirement::Maker::Chain::add(_DWORD *this)
{
  int v1;
  _DWORD *v2;
  unsigned int v3;
  uint64_t v4;

  v1 = this[5];
  this[5] = v1 + 1;
  if (v1)
  {
    v2 = this;
    v3 = this[4];
    v4 = *((_QWORD *)this + 1);
    Security::CodeSigning::Requirement::Maker::require((_QWORD *)v4, 4);
    this = memmove((void *)(*v2 + *(_QWORD *)v4 + 4), (const void *)(*v2 + *(_QWORD *)v4), (*(_DWORD *)(v4 + 12) - *v2));
    *(_DWORD *)(v4 + 12) += 4;
    *(_DWORD *)(*v2 + *(_QWORD *)v4) = bswap32(v3);
  }
  return this;
}

uint64_t Security::CodeSigning::SecStaticCode::defaultDesignatedLightWeightCodeRequirement(Security::CodeSigning::SecStaticCode *this)
{
  uint64_t result;
  const UInt8 *v3;
  const UInt8 *v4;
  uint64_t v5;
  const __CFArray *v6;
  int v7;
  void **v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, Security::CodeSigning::SecStaticCode *);
  void *v12;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  NSObject *v17;
  uint64_t (*v18)(uint64_t, Security::CodeSigning::SecStaticCode *);
  const char *v19;
  const char *v20;
  const char *v21;
  const void *v22;
  _QWORD v23[5];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t (*v27)(uint64_t, uint64_t);
  const void **(*v28)(uint64_t);
  CFMutableArrayRef MutableCopy;
  void *__p[3];
  __int128 buf;
  uint64_t (*v32)(uint64_t, Security::CodeSigning::SecStaticCode *);
  void *v33;
  _QWORD *v34;
  Security::CodeSigning::SecStaticCode *v35;
  _QWORD v36[2];
  _QWORD v37[2];
  _QWORD v38[2];
  _QWORD v39[2];
  const __CFString *v40;
  const __CFString *v41;
  const __CFString *v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  result = *((_QWORD *)this + 80);
  if (!result)
  {
    memset(__p, 170, sizeof(__p));
    v3 = Security::CodeSigning::SecStaticCode::codeDirectory(this, 1);
    std::string::basic_string[abi:ne180100]<0>(__p, (char *)&v3[bswap32(*((_DWORD *)v3 + 5))]);
    v4 = Security::CodeSigning::SecStaticCode::teamID(this);
    v24 = 0;
    v25 = &v24;
    v26 = 0x3002000000;
    v27 = __Block_byref_object_copy__64;
    v28 = __Block_byref_object_dispose__65;
    MutableCopy = (CFMutableArrayRef)0xAAAAAAAAAAAAAAAALL;
    v6 = (const __CFArray *)Security::CodeSigning::SecStaticCode::cdHashes(this, v5);
    MutableCopy = CFArrayCreateMutableCopy(0, 0, v6);
    v23[0] = MEMORY[0x1E0C809B0];
    v23[1] = 0x40000000;
    v23[2] = ___ZN8Security11CodeSigning13SecStaticCode43defaultDesignatedLightWeightCodeRequirementEv_block_invoke;
    v23[3] = &unk_1E1FDCA80;
    v23[4] = &v24;
    *(_QWORD *)&buf = MEMORY[0x1E0C809B0];
    *((_QWORD *)&buf + 1) = 0x40000000;
    v32 = ___ZN8Security11CodeSigning13SecStaticCode24handleOtherArchitecturesEU13block_pointerFvPS1_E_block_invoke;
    v33 = &unk_1E1FDCC70;
    v34 = v23;
    v35 = this;
    Security::CodeSigning::SecStaticCode::visitOtherArchitectures((uint64_t)this, (uint64_t)&buf);
    v7 = Security::CodeSigning::SecStaticCode::validationCategory((CFDataRef *)this);
    if (SHIBYTE(__p[2]) >= 0)
      v8 = __p;
    else
      v8 = (void **)__p[0];
    switch(v7)
    {
      case 1:
        if (v8)
        {
          *(_QWORD *)&buf = &unk_1E1FFEEC0;
          v40 = CFSTR("validation-category");
          v41 = CFSTR("signing-identifier");
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v8);
          v9 = objc_claimAutoreleasedReturnValue();
          *((_QWORD *)&buf + 1) = v9;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &buf, &v40, 2);
          v10 = objc_claimAutoreleasedReturnValue();
        }
        else
        {
          secLogObjForScope("SecError");
          v9 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136315138;
            *(_QWORD *)((char *)&buf + 4) = "defaultPlatformLWCR";
            _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "%s: signing identifier is NULL, cannot generate a LWCR", (uint8_t *)&buf, 0xCu);
          }
          v10 = 0;
        }
        goto LABEL_50;
      case 2:
        if (v8)
        {
          *(_QWORD *)&buf = &unk_1E1FFEED8;
          v40 = CFSTR("validation-category");
          v41 = CFSTR("signing-identifier");
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v8);
          v9 = objc_claimAutoreleasedReturnValue();
          *((_QWORD *)&buf + 1) = v9;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &buf, &v40, 2);
          v10 = objc_claimAutoreleasedReturnValue();
        }
        else
        {
          secLogObjForScope("SecError");
          v9 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136315138;
            *(_QWORD *)((char *)&buf + 4) = "defaultTestflightLWCR";
            _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, "%s: signing identifier is NULL, cannot generate a LWCR", (uint8_t *)&buf, 0xCu);
          }
          v10 = 0;
        }
        goto LABEL_50;
      case 3:
        if (!v8)
        {
          secLogObjForScope("SecError");
          v9 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            goto LABEL_41;
          LODWORD(buf) = 136315138;
          *(_QWORD *)((char *)&buf + 4) = "defaultDevelopmentLWCR";
          v19 = "%s: signing identifier is NULL, cannot generate a LWCR";
          goto LABEL_40;
        }
        if (v4)
        {
          *(_QWORD *)&buf = &unk_1E1FFEEF0;
          v40 = CFSTR("validation-category");
          v41 = CFSTR("signing-identifier");
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v8);
          v9 = objc_claimAutoreleasedReturnValue();
          *((_QWORD *)&buf + 1) = v9;
          v42 = CFSTR("team-identifier");
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v4);
          v11 = (uint64_t (*)(uint64_t, Security::CodeSigning::SecStaticCode *))objc_claimAutoreleasedReturnValue();
          v32 = v11;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &buf, &v40, 3);
          v10 = objc_claimAutoreleasedReturnValue();

          goto LABEL_50;
        }
        secLogObjForScope("SecError");
        v9 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 136315138;
          *(_QWORD *)((char *)&buf + 4) = "defaultDevelopmentLWCR";
          v19 = "%s: team identifier is NULL, cannot generate a LWCR";
LABEL_40:
          _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&buf, 0xCu);
        }
LABEL_41:
        v10 = 0;
        goto LABEL_50;
      case 4:
        if (!v8)
        {
          secLogObjForScope("SecError");
          v9 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            goto LABEL_45;
          LODWORD(buf) = 136315138;
          *(_QWORD *)((char *)&buf + 4) = "defaultAppStoreLWCR";
          v20 = "%s: signing identifier is NULL, cannot generate a LWCR";
          goto LABEL_44;
        }
        if (v4)
        {
          v40 = CFSTR("$or");
          v38[1] = CFSTR("$and");
          v39[0] = &unk_1E1FFEF08;
          v38[0] = CFSTR("validation-category");
          v37[0] = &unk_1E1FFEF20;
          v36[0] = CFSTR("validation-category");
          v36[1] = CFSTR("team-identifier");
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v4);
          v9 = objc_claimAutoreleasedReturnValue();
          v37[1] = v9;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v37, v36, 2);
          v12 = (void *)objc_claimAutoreleasedReturnValue();
          v39[1] = v12;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v39, v38, 2);
          v13 = (void *)objc_claimAutoreleasedReturnValue();
          *(_QWORD *)&buf = v13;
          v41 = CFSTR("signing-identifier");
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v8);
          v14 = (void *)objc_claimAutoreleasedReturnValue();
          *((_QWORD *)&buf + 1) = v14;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &buf, &v40, 2);
          v10 = objc_claimAutoreleasedReturnValue();

          goto LABEL_50;
        }
        secLogObjForScope("SecError");
        v9 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 136315138;
          *(_QWORD *)((char *)&buf + 4) = "defaultAppStoreLWCR";
          v20 = "%s: team identifier is NULL, cannot generate a LWCR";
LABEL_44:
          _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&buf, 0xCu);
        }
LABEL_45:
        v10 = 0;
        goto LABEL_50;
      case 6:
        if (!v8)
        {
          secLogObjForScope("SecError");
          v9 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            goto LABEL_49;
          LODWORD(buf) = 136315138;
          *(_QWORD *)((char *)&buf + 4) = "defaultDeveloperIDLWCR";
          v21 = "%s: signing identifier is NULL, cannot generate a LWCR";
          goto LABEL_48;
        }
        if (v4)
        {
          *(_QWORD *)&buf = &unk_1E1FFEF20;
          v40 = CFSTR("validation-category");
          v41 = CFSTR("signing-identifier");
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v8);
          v9 = objc_claimAutoreleasedReturnValue();
          *((_QWORD *)&buf + 1) = v9;
          v42 = CFSTR("team-identifier");
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v4);
          v18 = (uint64_t (*)(uint64_t, Security::CodeSigning::SecStaticCode *))objc_claimAutoreleasedReturnValue();
          v32 = v18;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &buf, &v40, 3);
          v10 = objc_claimAutoreleasedReturnValue();

          goto LABEL_50;
        }
        secLogObjForScope("SecError");
        v9 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 136315138;
          *(_QWORD *)((char *)&buf + 4) = "defaultDeveloperIDLWCR";
          v21 = "%s: team identifier is NULL, cannot generate a LWCR";
LABEL_48:
          _os_log_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEFAULT, v21, (uint8_t *)&buf, 0xCu);
        }
LABEL_49:
        v10 = 0;
LABEL_50:

LABEL_51:
        v22 = (const void *)*((_QWORD *)this + 80);
        if (v22)
          CFRelease(v22);
        *((_QWORD *)this + 80) = v10;
        _Block_object_dispose(&v24, 8);
        Security::CFRef<__CFArray *>::~CFRef((const void **)&MutableCopy);
        if (SHIBYTE(__p[2]) < 0)
          operator delete(__p[0]);
        result = *((_QWORD *)this + 80);
        break;
      default:
        v15 = (id)v25[5];
        v16 = v15;
        if (v15 && objc_msgSend(v15, "count"))
        {
          v40 = CFSTR("cdhash");
          v38[0] = CFSTR("$in");
          v39[0] = v16;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v39, v38, 1);
          v17 = objc_claimAutoreleasedReturnValue();
          *(_QWORD *)&buf = v17;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &buf, &v40, 1);
          v10 = objc_claimAutoreleasedReturnValue();
        }
        else
        {
          secLogObjForScope("SecError");
          v17 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136315138;
            *(_QWORD *)((char *)&buf + 4) = "defaultAdhocLWCR";
            _os_log_impl(&dword_18A900000, v17, OS_LOG_TYPE_DEFAULT, "%s: no cdhashes for code, cannot generate a LWCR", (uint8_t *)&buf, 0xCu);
          }
          v10 = 0;
        }

        goto LABEL_51;
    }
  }
  return result;
}

void sub_18AA3E368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  const void **v25;
  void *v26;
  void *v27;

  _Block_object_dispose(&a14, 8);
  Security::CFRef<__CFArray *>::~CFRef(v25);
  if (a25 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void ___ZN8Security11CodeSigning13SecStaticCode43defaultDesignatedLightWeightCodeRequirementEv_block_invoke(uint64_t a1, Security::CodeSigning::SecStaticCode *this)
{
  const __CFArray *v3;
  __CFArray *v4;
  CFRange v5;

  v3 = (const __CFArray *)Security::CodeSigning::SecStaticCode::cdHashes(this, (uint64_t)this);
  v4 = *(__CFArray **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v5.length = CFArrayGetCount(v3);
  v5.location = 0;
  CFArrayAppendArray(v4, v3, v5);
}

void Security::CodeSigning::SecStaticCode::validateRequirements(Security::CodeSigning::SecStaticCode *this, int a2, Security::CodeSigning::SecStaticCode *a3, uint64_t a4)
{
  unsigned int *v7;
  Security::CodeSigning::Requirement *v8;

  v7 = Security::CodeSigning::SecStaticCode::internalRequirements(this);
  if (v7
    && (v8 = (Security::CodeSigning::Requirement *)Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::find<Security::CodeSigning::Requirement>((uint64_t)v7, a2)) != 0)
  {
    if ((_DWORD)a4)
      a4 = a4;
    else
      a4 = 4294900246;
    if (!Security::CodeSigning::SecStaticCode::satisfiesRequirement((uint64_t)a3, v8))
LABEL_7:
      Security::MacOSError::throwMe((Security::MacOSError *)a4);
  }
  else if ((_DWORD)a4)
  {
    goto LABEL_7;
  }
  Security::CodeSigning::SecStaticCode::validateRequirements(SecRequirementType,Security::CodeSigning::SecStaticCode*,int)::_DTFrameCODESIGN_EVAL_STATIC_INTREQ::~_DTFrameCODESIGN_EVAL_STATIC_INTREQ();
}

void sub_18AA3E50C(_Unwind_Exception *a1)
{
  Security::CodeSigning::SecStaticCode::validateRequirements(SecRequirementType,Security::CodeSigning::SecStaticCode*,int)::_DTFrameCODESIGN_EVAL_STATIC_INTREQ::~_DTFrameCODESIGN_EVAL_STATIC_INTREQ();
  _Unwind_Resume(a1);
}

void Security::CodeSigning::SecStaticCode::staticValidateResource(Security::CodeSigning::SecStaticCode *a1, std::string::size_type a2, int a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  const std::string::value_type *v11;
  uint64_t v12;
  int v13;
  int v14;
  void *v16;
  int v17;
  const __CFURL *v18;
  uint64_t v19;
  std::string *v20;
  std::string::size_type size;
  int v22;
  std::string::size_type v23;
  std::string::size_type v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unsigned __int8 *v29;
  uint64_t v30;
  int v31;
  int v32;
  void *v34;
  std::string *v35;
  char *v36;
  NSObject *v37;
  void *v38;
  int v39;
  std::string::size_type v40;
  std::string::size_type v41;
  const char *v42;
  char *v43;
  char *v44;
  void *v45;
  const char *v46;
  NSObject *v47;
  std::string::size_type v48;
  NSObject *v49;
  std::string::size_type v50;
  const char *v51;
  int v52;
  std::string::size_type v53;
  std::string *v54;
  unint64_t v55;
  unint64_t v56;
  int v57;
  const char *v58;
  NSObject *v59;
  __int128 v60;
  uint64_t Rule;
  uint64_t v62;
  const __CFDictionary *v63;
  const void *Value;
  const char *v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  const Security::CFClass *v69;
  uint64_t v70;
  char *v71;
  Security::CodeSigning::DiskRep *v72;
  unsigned __int8 *v73;
  unsigned __int8 v74;
  const void *v75;
  __SecRequirement *v76;
  void *v77;
  std::string::size_type v78;
  char v79;
  std::string *v80;
  unint64_t v81;
  int v82;
  std::string *v83;
  int v84;
  int v85;
  NSObject *v86;
  std::string *v87;
  NSObject *v88;
  int v89;
  NSObject *v90;
  _QWORD v91[2];
  uint64_t (*v92)(uint64_t, uint64_t);
  void *v93;
  _BYTE *v94;
  Security::CodeSigning::SecStaticCode *v95;
  const __CFDictionary *v96;
  std::string v97;
  int v98;
  unsigned int v99;
  std::string v100;
  std::string v101;
  void *v102[2];
  char v103;
  unint64_t v104;
  Security::UnixPlusPlus::FileDesc *v105;
  std::string v106;
  std::string v107;
  _QWORD **v108;
  _QWORD *v109[2];
  unsigned int v110[5];
  void *v111[2];
  char v112;
  void *v113[2];
  char v114;
  void *v115[2];
  char v116;
  std::string v117;
  std::string v118;
  std::string v119;
  std::string __s;
  std::string v121;
  _BYTE __b[1024];
  _BYTE __p[1024];
  std::string buf;
  uint64_t v125;

  v125 = *MEMORY[0x1E0C80C00];
  memset(&v121, 0, sizeof(v121));
  memset(&__s, 0, sizeof(__s));
  (*(void (**)(_BYTE *__return_ptr))(**((_QWORD **)a1 + 4) + 40))(__p);
  if (__p[23] >= 0)
    v8 = __p[23];
  else
    v8 = *(_QWORD *)&__p[8];
  v9 = *(unsigned __int8 *)(a2 + 23);
  v10 = (char)v9;
  if ((v9 & 0x80u) != 0)
    v9 = *(_QWORD *)(a2 + 8);
  if (v8 == v9)
  {
    if (v10 >= 0)
      v11 = (const std::string::value_type *)a2;
    else
      v11 = *(const std::string::value_type **)a2;
    if ((__p[23] & 0x80) != 0)
    {
      v16 = *(void **)__p;
      v17 = memcmp(*(const void **)__p, v11, *(size_t *)&__p[8]);
      operator delete(v16);
      if (!v17)
      {
LABEL_28:
        size = 0;
        LOBYTE(v22) = 0;
LABEL_46:
        LODWORD(v25) = a3 | 2;
        goto LABEL_47;
      }
    }
    else
    {
      if (!__p[23])
        goto LABEL_28;
      v12 = 0;
      do
      {
        v13 = __p[v12];
        v14 = v11[v12];
      }
      while (v13 == v14 && __p[23] - 1 != v12++);
      if (v13 == v14)
        goto LABEL_28;
    }
  }
  else if ((__p[23] & 0x80) != 0)
  {
    operator delete(*(void **)__p);
  }
  v18 = (const __CFURL *)Security::CodeSigning::SecStaticCode::resourceBase(a1);
  Security::cfString((Security *)__p, v18);
  if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v121.__r_.__value_.__l.__data_);
  v121 = *(std::string *)__p;
  if ((__p[23] & 0x80000000) != 0)
  {
    v20 = (std::string *)v121.__r_.__value_.__r.__words[0];
    if (*(_BYTE *)(v121.__r_.__value_.__r.__words[0] + v121.__r_.__value_.__l.__size_ - 1) != 46)
      goto LABEL_32;
    v19 = --v121.__r_.__value_.__l.__size_;
  }
  else
  {
    if (v121.__r_.__value_.__s.__data_[__p[23] - 1] != 46)
      goto LABEL_32;
    v19 = __p[23] - 1;
    *((_BYTE *)&v121.__r_.__value_.__s + 23) = (__p[23] - 1) & 0x7F;
    v20 = &v121;
  }
  v20->__r_.__value_.__s.__data_[v19] = 0;
LABEL_32:
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v119, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v119 = *(std::string *)a2;
  if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v118, v121.__r_.__value_.__l.__data_, v121.__r_.__value_.__l.__size_);
  else
    v118 = v121;
  Security::CodeSigning::pathRemaining((std::string *)__p, (uint64_t)&v119, (uint64_t *)&v118);
  __s = *(std::string *)__p;
  __p[23] = 0;
  __p[0] = 0;
  if (SHIBYTE(v118.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v118.__r_.__value_.__l.__data_);
  if (SHIBYTE(v119.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v119.__r_.__value_.__l.__data_);
  v23 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
  v22 = SHIBYTE(__s.__r_.__value_.__r.__words[2]);
  size = __s.__r_.__value_.__l.__size_;
  if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v24 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
  else
    v24 = __s.__r_.__value_.__l.__size_;
  if (v24)
    goto LABEL_46;
  v34 = (void *)__s.__r_.__value_.__r.__words[0];
  memset(__p, 170, sizeof(__p));
  if ((v121.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v35 = &v121;
  else
    v35 = (std::string *)v121.__r_.__value_.__r.__words[0];
  v36 = realpath_DARWIN_EXTSN((const char *)v35, __p);
  if (v36)
  {
    v37 = secLogObjForScope("staticCode");
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__b = 136315138;
      *(_QWORD *)&__b[4] = __p;
      _os_log_debug_impl(&dword_18A900000, v37, OS_LOG_TYPE_DEBUG, "Checking resolved path for containment: %s", __b, 0xCu);
    }
    if (*(char *)(a2 + 23) < 0)
      std::string::__init_copy_ctor_external(&v117, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    else
      v117 = *(std::string *)a2;
    std::string::basic_string[abi:ne180100]<0>(v115, __p);
    Security::CodeSigning::pathRemaining((std::string *)__b, (uint64_t)&v117, (uint64_t *)v115);
    if (v22 < 0)
      operator delete(v34);
    __s = *(std::string *)__b;
    __b[23] = 0;
    __b[0] = 0;
    if (v116 < 0)
      operator delete(v115[0]);
    if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v117.__r_.__value_.__l.__data_);
    v23 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
    size = __s.__r_.__value_.__l.__size_;
    LOBYTE(v22) = *((_BYTE *)&__s.__r_.__value_.__s + 23);
  }
  if ((v22 & 0x80u) == 0)
    v40 = v23;
  else
    v40 = size;
  if (!v40)
  {
    v45 = (void *)__s.__r_.__value_.__r.__words[0];
    memset(__b, 170, sizeof(__b));
    v46 = (const char *)a2;
    if (*(char *)(a2 + 23) < 0)
      v46 = *(const char **)a2;
    if (realpath_DARWIN_EXTSN(v46, __b))
    {
      v47 = secLogObjForScope("staticCode");
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)__b;
        _os_log_debug_impl(&dword_18A900000, v47, OS_LOG_TYPE_DEBUG, "Checking resolved resource path for containment: %s", (uint8_t *)&buf, 0xCu);
      }
      std::string::basic_string[abi:ne180100]<0>(v113, __b);
      std::string::basic_string[abi:ne180100]<0>(v111, __p);
      Security::CodeSigning::pathRemaining(&buf, (uint64_t)v113, (uint64_t *)v111);
      if ((v22 & 0x80) != 0)
        operator delete(v45);
      __s = buf;
      *((_BYTE *)&buf.__r_.__value_.__s + 23) = 0;
      buf.__r_.__value_.__s.__data_[0] = 0;
      if (v112 < 0)
        operator delete(v111[0]);
      if (v114 < 0)
        operator delete(v113[0]);
      v23 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
      LOBYTE(v22) = *((_BYTE *)&__s.__r_.__value_.__s + 23);
      size = __s.__r_.__value_.__l.__size_;
      if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v48 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
      else
        v48 = __s.__r_.__value_.__l.__size_;
      if (v48)
      {
        std::string::__assign_external((std::string *)a2, __b);
        v49 = secLogObjForScope("staticCode");
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
        {
          v50 = a2;
          if (*(char *)(a2 + 23) < 0)
            v50 = *(_QWORD *)a2;
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v50;
          _os_log_debug_impl(&dword_18A900000, v49, OS_LOG_TYPE_DEBUG, "Updated resource path: %s", (uint8_t *)&buf, 0xCu);
        }
      }
    }
  }
  if ((v22 & 0x80u) == 0)
    v41 = v23;
  else
    v41 = size;
  if (!v41)
  {
    v86 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
    {
      if (*(char *)(a2 + 23) < 0)
        a2 = *(_QWORD *)a2;
      v87 = &v121;
      if ((v121.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v87 = (std::string *)v121.__r_.__value_.__r.__words[0];
      *(_DWORD *)__p = 136315394;
      *(_QWORD *)&__p[4] = a2;
      *(_WORD *)&__p[12] = 2080;
      *(_QWORD *)&__p[14] = v87;
      _os_log_impl(&dword_18A900000, v86, OS_LOG_TYPE_DEFAULT, "Requested resource was not within the code object: %s, %s", __p, 0x16u);
    }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFCELL);
  }
  LODWORD(v25) = a3 | 2;
  if (v36)
  {
    memset(__p, 170, sizeof(__p));
    (*(void (**)(_BYTE *__return_ptr))(**((_QWORD **)a1 + 4) + 40))(__b);
    if (__b[23] >= 0)
      v42 = __b;
    else
      v42 = *(const char **)__b;
    v43 = realpath_DARWIN_EXTSN(v42, __p);
    v44 = v43;
    if ((__b[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)__b);
      if (!v44)
        goto LABEL_124;
    }
    else if (!v43)
    {
      goto LABEL_124;
    }
    v51 = (const char *)a2;
    if (*(char *)(a2 + 23) < 0)
      v51 = *(const char **)a2;
    if (!strcmp(__p, v51))
      goto LABEL_125;
LABEL_124:
    v52 = 1;
    goto LABEL_127;
  }
LABEL_47:
  (*(void (**)(_BYTE *__return_ptr))(**((_QWORD **)a1 + 4) + 40))(__p);
  if (__p[23] >= 0)
    v26 = __p[23];
  else
    v26 = *(_QWORD *)&__p[8];
  v27 = *(unsigned __int8 *)(a2 + 23);
  v28 = (char)v27;
  if ((v27 & 0x80u) != 0)
    v27 = *(_QWORD *)(a2 + 8);
  if (v26 != v27)
  {
    if ((__p[23] & 0x80) != 0)
      operator delete(*(void **)__p);
    goto LABEL_124;
  }
  if (v28 >= 0)
    v29 = (unsigned __int8 *)a2;
  else
    v29 = *(unsigned __int8 **)a2;
  if ((__p[23] & 0x80) != 0)
  {
    v38 = *(void **)__p;
    v39 = memcmp(*(const void **)__p, v29, *(size_t *)&__p[8]);
    operator delete(v38);
    if (!v39)
      goto LABEL_125;
    goto LABEL_124;
  }
  if (__p[23])
  {
    v30 = 0;
    do
    {
      v31 = __p[v30];
      v32 = v29[v30];
    }
    while (v31 == v32 && __p[23] - 1 != v30++);
    if (v31 != v32)
      goto LABEL_124;
  }
LABEL_125:
  v52 = 0;
  if ((v25 & 0x20000) == 0)
    LODWORD(v25) = v25 & 0xFFFFFFFD;
LABEL_127:
  v53 = v22;
  if ((v22 & 0x80u) != 0)
    v53 = size;
  if (v53 == 10)
  {
    v54 = (v22 & 0x80u) == 0 ? &__s : (std::string *)__s.__r_.__value_.__r.__words[0];
    v55 = 0x496E666F2E706C69;
    v56 = bswap64(v54->__r_.__value_.__r.__words[0]);
    if (v56 == 0x496E666F2E706C69
      && (v56 = bswap32(LOWORD(v54->__r_.__value_.__r.__words[1])) >> 16, v55 = 29556, (_DWORD)v56 == 29556))
    {
      v57 = 0;
    }
    else
    {
      v57 = v56 < v55 ? -1 : 1;
    }
    if (!v57)
      v52 = 0;
  }
  Security::CodeSigning::SecStaticCode::staticValidateCore((UInt8 *)a1, v25, 0);
  if (a4
    && !Security::CodeSigning::SecStaticCode::satisfiesRequirement((uint64_t)a1, *(Security::CodeSigning::Requirement **)(a4 + 16)))
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA12);
  }
  if (v52)
  {
    if ((v25 & 0x4000) == 0 && Security::CodeSigning::itemQualifiesForResourceExemption((char *)a2, v58))
    {
      v59 = secLogObjForScope("staticCode");
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
        if (*(char *)(a2 + 23) < 0)
          a2 = *(_QWORD *)a2;
        *(_DWORD *)__p = 136315138;
        *(_QWORD *)&__p[4] = a2;
        _os_log_debug_impl(&dword_18A900000, v59, OS_LOG_TYPE_DEBUG, "Requested resource was on root filesystem: %s", __p, 0xCu);
      }
      goto LABEL_225;
    }
    memset(v110, 170, sizeof(v110));
    if (!Security::CodeSigning::SecStaticCode::loadResources(a1, (const __CFDictionary **)&v110[3], (const __CFDictionary **)&v110[1], v110))Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA10);
    v109[0] = 0;
    v109[1] = 0;
    v108 = v109;
    *(_QWORD *)&v60 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v60 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&__b[64] = v60;
    *(_OWORD *)&__b[80] = v60;
    *(_OWORD *)&__b[32] = v60;
    *(_OWORD *)&__b[48] = v60;
    *(_OWORD *)__b = v60;
    *(_OWORD *)&__b[16] = v60;
    Security::CodeSigning::ResourceBuilder::ResourceBuilder((std::string::size_type)__b, (uint64_t)&v121, (uint64_t)&v121, *(const void **)&v110[3], (v25 & 0x10) != 0, (uint64_t)&v108);
    (*(void (**)(_QWORD *, _BYTE *))(**((_QWORD **)a1 + 4) + 64))(*((_QWORD **)a1 + 4), __b);
    if ((v22 & 0x80) != 0)
      std::string::__init_copy_ctor_external(&v107, __s.__r_.__value_.__l.__data_, size);
    else
      v107 = __s;
    Rule = Security::CodeSigning::ResourceBuilder::findRule((uint64_t)__b, (uint64_t)&v107);
    v62 = Rule;
    if (SHIBYTE(v107.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v107.__r_.__value_.__l.__data_);
      if (!v62)
        goto LABEL_159;
    }
    else if (!Rule)
    {
      goto LABEL_159;
    }
    if ((*(_BYTE *)(v62 + 36) & 0x12) != 0)
    {
      v88 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
      {
        v89 = *(_DWORD *)(v62 + 36);
        *(_DWORD *)__p = 67109120;
        *(_DWORD *)&__p[4] = v89;
        _os_log_impl(&dword_18A900000, v88, OS_LOG_TYPE_DEFAULT, "Requested resource was not sealed: %d", __p, 8u);
      }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0FLL);
    }
LABEL_159:
    v63 = *(const __CFDictionary **)&v110[1];
    if ((v22 & 0x80) != 0)
      std::string::__init_copy_ctor_external(&v106, __s.__r_.__value_.__l.__data_, size);
    else
      v106 = __s;
    Security::CFTempString::CFTempString<std::string>((CFStringRef *)__p, (char *)&v106);
    Value = CFDictionaryGetValue(v63, *(const void **)__p);
    Security::CFRef<__CFString const*>::~CFRef((const void **)__p);
    if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v106.__r_.__value_.__l.__data_);
      if (Value)
        goto LABEL_164;
    }
    else if (Value)
    {
LABEL_164:
      v105 = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAFFFFFFFFLL;
      if (*(char *)(a2 + 23) >= 0)
        v65 = (const char *)a2;
      else
        v65 = *(const char **)a2;
      Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v105, v65, 0x200000, 438);
      *(_QWORD *)&v66 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v66 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&__p[112] = v66;
      *(_OWORD *)&__p[128] = v66;
      *(_OWORD *)&__p[80] = v66;
      *(_OWORD *)&__p[96] = v66;
      *(_OWORD *)&__p[48] = v66;
      *(_OWORD *)&__p[64] = v66;
      *(_OWORD *)&__p[16] = v66;
      *(_OWORD *)&__p[32] = v66;
      *(_OWORD *)__p = v66;
      Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)v105, (stat *)__p);
      if ((v25 & 0x20000) != 0)
        v25 = v25;
      else
        v25 = v25 & 0xFFFFFFFD;
      *(_QWORD *)&v67 = 0xAAAAAAAAAAAAAAAALL;
      *((_QWORD *)&v67 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)__p = v67;
      *(_OWORD *)&__p[16] = v67;
      Security::CodeSigning::ResourceSeal::ResourceSeal((Security::CodeSigning::ResourceSeal *)__p, Value);
      if ((__p[24] & 4) != 0)
      {
        buf.__r_.__value_.__r.__words[0] = 0;
        if (SecRequirementCreateWithStringAndErrors(*(CFStringRef *)&__p[8], 0, 0, (SecRequirementRef *)&buf))
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA11);
        v104 = 0xAAAAAAAAAAAAAAAALL;
        v68 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
        v70 = Security::SecCFObject::allocate((Security::SecCFObject *)0x288, *(_QWORD *)(v68 + 200), v69);
        if (*(char *)(a2 + 23) >= 0)
          v71 = (char *)a2;
        else
          v71 = *(char **)a2;
        v72 = (Security::CodeSigning::DiskRep *)Security::CodeSigning::DiskRep::bestGuess(v71, 0);
        Security::CodeSigning::SecStaticCode::SecStaticCode((Security::CodeSigning::SecStaticCode *)v70, v72, 0);
        v73 = (unsigned __int8 *)(v70 - 8);
        do
          v74 = __ldaxr(v73);
        while (__stlxr(1u, v73));
        if ((v74 & 1) != 0)
        {
          v75 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v70 + 16))(v70);
          CFRetain(v75);
        }
        v104 = v70;
        Security::CodeSigning::SecStaticCode::initializeFromParent((Security::CodeSigning::SecStaticCode *)v70, a1);
        *(_DWORD *)(v70 + 208) = v25;
        (*(void (**)(void **__return_ptr))(**(_QWORD **)(v70 + 32) + 40))(v102);
        v77 = Security::CodeSigning::SecRequirement::required((Security::CodeSigning::SecRequirement *)buf.__r_.__value_.__l.__data_, v76);
        Security::CodeSigning::SecStaticCode::staticValidateResource(v70, v102, v25, v77);
        if (v103 < 0)
          operator delete(v102[0]);
        Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v104);
        Security::CFRef<__SecRequirement *>::~CFRef((const void **)&buf.__r_.__value_.__l.__data_);
      }
      else
      {
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1E1FC8B18;
        buf.__r_.__value_.__l.__size_ = (std::string::size_type)a1;
        if ((v22 & 0x80) != 0)
          std::string::__init_copy_ctor_external(&v101, __s.__r_.__value_.__l.__data_, size);
        else
          v101 = __s;
        Security::CodeSigning::SecStaticCode::validateResource((uint64_t)a1);
        if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v101.__r_.__value_.__l.__data_);
      }
      Security::CFRef<__CFDictionary const*>::~CFRef((const void **)__p);
      Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v105);
LABEL_224:
      Security::CodeSigning::ResourceBuilder::~ResourceBuilder((Security::CodeSigning::ResourceBuilder *)__b);
      std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v109[0]);
      goto LABEL_225;
    }
    *(_QWORD *)__p = 0;
    *(_QWORD *)&__p[8] = __p;
    *(_QWORD *)&__p[16] = 0x2000000000;
    __p[24] = 0;
    if ((v22 & 0x80) != 0)
      std::string::__init_copy_ctor_external(&v100, __s.__r_.__value_.__l.__data_, size);
    else
      v100 = __s;
    v91[0] = MEMORY[0x1E0C809B0];
    v91[1] = 1174405120;
    v92 = ___ZN8Security11CodeSigning13SecStaticCode22staticValidateResourceENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjPKNS0_14SecRequirementE_block_invoke;
    v93 = &unk_1E1FDCC38;
    v95 = a1;
    v96 = v63;
    v94 = __p;
    v98 = v25;
    if (*(char *)(a2 + 23) < 0)
      std::string::__init_copy_ctor_external(&v97, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    else
      v97 = *(std::string *)a2;
    v99 = v110[0];
    if ((v100.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v78 = HIBYTE(v100.__r_.__value_.__r.__words[2]);
    else
      v78 = v100.__r_.__value_.__l.__size_;
    while (1)
    {
      v79 = HIBYTE(v100.__r_.__value_.__r.__words[2]);
      v81 = v100.__r_.__value_.__l.__size_;
      v80 = (std::string *)v100.__r_.__value_.__r.__words[0];
      if ((v100.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      {
        v80 = &v100;
        v81 = HIBYTE(v100.__r_.__value_.__r.__words[2]);
      }
      if (v81 > v78)
        v81 = v78 + 1;
      do
      {
        if (!v81)
          goto LABEL_214;
        v82 = v80->__r_.__value_.__s.__data_[--v81];
      }
      while (v82 != 47);
      v78 = v81 - 1;
      if (v81 - 1 > 0xFFFFFFFFFFFFFFFDLL)
        break;
      if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0)
      {
        if (v100.__r_.__value_.__l.__size_ < v81)
LABEL_247:
          std::string::__throw_out_of_range[abi:ne180100]();
        v83 = (std::string *)v100.__r_.__value_.__r.__words[0];
        v100.__r_.__value_.__l.__size_ = v81;
      }
      else
      {
        if (v81 > HIBYTE(v100.__r_.__value_.__r.__words[2]))
          goto LABEL_247;
        *((_BYTE *)&v100.__r_.__value_.__s + 23) = v81 & 0x7F;
        v83 = &v100;
      }
      v83->__r_.__value_.__s.__data_[v81] = 0;
      if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0)
        std::string::__init_copy_ctor_external(&buf, v100.__r_.__value_.__l.__data_, v100.__r_.__value_.__l.__size_);
      else
        buf = v100;
      v84 = v92((uint64_t)v91, (uint64_t)&buf);
      v85 = v84;
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(buf.__r_.__value_.__l.__data_);
        if (v85)
        {
LABEL_213:
          v79 = HIBYTE(v100.__r_.__value_.__r.__words[2]);
          break;
        }
      }
      else if (v84)
      {
        goto LABEL_213;
      }
    }
LABEL_214:
    if (v79 < 0)
      operator delete(v100.__r_.__value_.__l.__data_);
    if (!*(_BYTE *)(*(_QWORD *)&__p[8] + 24))
    {
      v90 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(a2 + 23) < 0)
          a2 = *(_QWORD *)a2;
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = a2;
        _os_log_impl(&dword_18A900000, v90, OS_LOG_TYPE_DEFAULT, "Requested resource was not found: %s", (uint8_t *)&buf, 0xCu);
      }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA12);
    }
    if (SHIBYTE(v97.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v97.__r_.__value_.__l.__data_);
    _Block_object_dispose(__p, 8);
    goto LABEL_224;
  }
LABEL_225:
  if ((v22 & 0x80) != 0)
    operator delete(__s.__r_.__value_.__l.__data_);
  if (SHIBYTE(v121.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v121.__r_.__value_.__l.__data_);
}

void sub_18AA3F418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,__int16 a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *__p;
  void *a71;
  char v71;

  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&STACK[0x610]);
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&a32);
  Security::CodeSigning::ResourceBuilder::~ResourceBuilder((Security::CodeSigning::ResourceBuilder *)&STACK[0x210]);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((_QWORD *)a41);
  if (v71 < 0)
    operator delete(__p);
  if (SLOBYTE(STACK[0x207]) < 0)
    operator delete(a71);
  _Unwind_Resume(a1);
}

uint64_t ___ZN8Security11CodeSigning13SecStaticCode22staticValidateResourceENSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEjPKNS0_14SecRequirementE_block_invoke(uint64_t a1, uint64_t a2)
{
  Security::CodeSigning::SecStaticCode *v4;
  const __CFDictionary *v5;
  const void *Value;
  uint64_t v7;
  const __CFURL *v8;
  Security *v9;
  __int128 v10;
  unsigned int v11;
  uint64_t v12;
  const Security::CFClass *v13;
  Security::CodeSigning::SecStaticCode *v14;
  char *v15;
  Security::CodeSigning::DiskRep *v16;
  unsigned __int8 *v17;
  unsigned __int8 v18;
  const void *v19;
  __SecRequirement *v20;
  uint64_t v21;
  _QWORD *v22;
  void **v23;
  timespec v24;
  uint64_t v25;
  void *v26;
  NSObject *v28;
  std::string __p;
  std::string v30;
  Security::UnixPlusPlus::FileDesc *v31;
  CFStringRef text[2];
  __int128 v33;
  void *v34[3];
  const __CFURL *CFURL;
  std::string v36;
  stat key;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v4 = *(Security::CodeSigning::SecStaticCode **)(a1 + 40);
  v5 = *(const __CFDictionary **)(a1 + 48);
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&v36, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    v36 = *(std::string *)a2;
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)&key, (char *)&v36);
  Value = CFDictionaryGetValue(v5, *(const void **)&key.st_dev);
  Security::CFRef<__CFString const*>::~CFRef((const void **)&key);
  if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v36.__r_.__value_.__l.__data_);
    if (Value)
      goto LABEL_6;
    return 0;
  }
  if (!Value)
    return 0;
LABEL_6:
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  CFURL = (const __CFURL *)0xAAAAAAAAAAAAAAAALL;
  v7 = Security::CodeSigning::SecStaticCode::resourceBase(v4);
  if (*(char *)(a2 + 23) >= 0)
    v9 = (Security *)a2;
  else
    v9 = *(Security **)a2;
  CFURL = Security::makeCFURL(v9, 0, v7, v8);
  memset(v34, 170, sizeof(v34));
  Security::cfString((Security *)v34, CFURL);
  *(_QWORD *)&v10 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)text = v10;
  v33 = v10;
  Security::CodeSigning::ResourceSeal::ResourceSeal((Security::CodeSigning::ResourceSeal *)text, Value);
  v11 = DWORD2(v33);
  if ((BYTE8(v33) & 4) != 0)
  {
    *(_QWORD *)&key.st_dev = 0;
    if (SecRequirementCreateWithStringAndErrors(text[1], 0, 0, (SecRequirementRef *)&key))
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA11);
    v31 = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAAAAAAAAALL;
    v12 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
    v14 = (Security::CodeSigning::SecStaticCode *)Security::SecCFObject::allocate((Security::SecCFObject *)0x288, *(_QWORD *)(v12 + 200), v13);
    if (SHIBYTE(v34[2]) >= 0)
      v15 = (char *)v34;
    else
      v15 = (char *)v34[0];
    v16 = (Security::CodeSigning::DiskRep *)Security::CodeSigning::DiskRep::bestGuess(v15, 0);
    Security::CodeSigning::SecStaticCode::SecStaticCode(v14, v16, 0);
    v17 = (unsigned __int8 *)v14 - 8;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(1u, v17));
    if ((v18 & 1) != 0)
    {
      v19 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecStaticCode *))(*(_QWORD *)v14 + 16))(v14);
      CFRetain(v19);
    }
    v31 = v14;
    Security::CodeSigning::SecStaticCode::initializeFromParent(v14, v4);
    *((_DWORD *)v14 + 52) = *(_DWORD *)(a1 + 80);
    if (*(char *)(a1 + 79) < 0)
      std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(a1 + 56), *(_QWORD *)(a1 + 64));
    else
      v30 = *(std::string *)(a1 + 56);
    v25 = *(unsigned int *)(a1 + 80);
    v26 = Security::CodeSigning::SecRequirement::required(*(Security::CodeSigning::SecRequirement **)&key.st_dev, v20);
    Security::CodeSigning::SecStaticCode::staticValidateResource(v14, &v30, v25, v26);
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v30.__r_.__value_.__l.__data_);
    Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v31);
    Security::CFRef<__SecRequirement *>::~CFRef((const void **)&key);
  }
  else
  {
    if (!(_QWORD)v33)
    {
      v28 = secLogObjForScope("SecError");
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        key.st_dev = 138412290;
        *(_QWORD *)&key.st_mode = Value;
        _os_log_impl(&dword_18A900000, v28, OS_LOG_TYPE_DEFAULT, "Unexpected item hit traversing resource: %@", (uint8_t *)&key, 0xCu);
      }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA12);
    }
    v22 = (_QWORD *)operator new();
    *v22 = &off_1E1FC8B18;
    v22[1] = v4;
    v31 = (Security::UnixPlusPlus::FileDesc *)0xAAAAAAAAFFFFFFFFLL;
    if (SHIBYTE(v34[2]) >= 0)
      v23 = v34;
    else
      v23 = (void **)v34[0];
    Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)&v31, (const char *)v23, 0x200000, 438);
    v24.tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v24.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&key.st_blksize = v24;
    *(timespec *)key.st_qspare = v24;
    key.st_birthtimespec = v24;
    *(timespec *)&key.st_size = v24;
    key.st_mtimespec = v24;
    key.st_ctimespec = v24;
    *(timespec *)&key.st_uid = v24;
    key.st_atimespec = v24;
    *(timespec *)&key.st_dev = v24;
    Security::UnixPlusPlus::FileDesc::fstat((Security::UnixPlusPlus::FileDesc *)v31, &key);
    if (*(char *)(a2 + 23) < 0)
      std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    else
      __p = *(std::string *)a2;
    Security::CodeSigning::SecStaticCode::validateResource((uint64_t)v4);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&v31);
  }
  v21 = (v11 >> 2) & 1;
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)text);
  if (SHIBYTE(v34[2]) < 0)
    operator delete(v34[0]);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&CFURL);
  return v21;
}

void sub_18AA3FA74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,char a44)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void __copy_helper_block_e8_56c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  std::string *v2;
  __int128 v3;

  v2 = (std::string *)(a1 + 56);
  if (*(char *)(a2 + 79) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a2 + 56), *(_QWORD *)(a2 + 64));
  }
  else
  {
    v3 = *(_OWORD *)(a2 + 56);
    v2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 72);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

void __destroy_helper_block_e8_56c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0)
    operator delete(*(void **)(a1 + 56));
}

BOOL Security::CodeSigning::Requirement::validates(Security::CodeSigning::Requirement *this, Security::CodeSigning::CodeDirectory **a2)
{
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  CFDataRef v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  CFDataRef v10;
  void *v11;
  _BOOL8 v12;
  void *v13;
  Security::CodeSigning::CodeDirectory *v14;
  uint64_t v15;
  int v16;
  void *v17;
  void *v18;
  NSObject *v19;
  int *v20;
  char *v21;
  id v22;
  void *v23;
  NSObject *v24;
  int *v25;
  char *v26;
  void *v27;
  Security::CodeSigning::CodeDirectory *v28;
  uint64_t v29;
  void *v30;
  void *v31;
  void *context;
  CFDataRef v34;
  unint64_t v35;
  size_t size;
  _BYTE buf[24];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v3 = *((_DWORD *)this + 2);
  v4 = bswap32(v3);
  if (v4 != 2)
  {
    if (v4 != 1)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA15);
    *(_QWORD *)buf = this;
    *(_DWORD *)&buf[8] = 12;
    *(_QWORD *)&buf[16] = a2;
    return Security::CodeSigning::Requirement::Interpreter::eval((Security::CodeSigning::Requirement::Interpreter *)buf, 1000) != 0;
  }
  if (v3 != 0x2000000)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14);
  *(_QWORD *)buf = this;
  *(_QWORD *)&buf[8] = 0xAAAAAAAA0000000CLL;
  v35 = 0;
  size = 0;
  Security::CodeSigning::Requirement::Reader::getData((Security::CodeSigning::Requirement::Reader *)buf, (const void **)&size, &v35);
  v6 = CFDataCreate(0, (const UInt8 *)size, v35);
  v34 = v6;
  v7 = MEMORY[0x18D770A24]();
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  context = (void *)v7;
  v9 = os_variant_allows_internal_security_policies();
  bindAndAddBoolFact(v8, "apple-internal", v9);
  v10 = Security::CodeSigning::CodeDirectory::cdhash(a2[6], 1);
  +[sec_LWCRFact dataFact:](sec_LWCRFact, "dataFact:", v10);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  bindAndAdd(v8, "cdhash", v11);
  bindAndAddIntegerFact(v8, "code-signing-flags", bswap32(*((_DWORD *)a2[6] + 3)));
  v12 = amfi_developer_mode_status();
  bindAndAddBoolFact(v8, "developer-mode", v12);
  +[sec_LWCRFact entitlementsFact:](sec_LWCRFact, "entitlementsFact:", a2[2]);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  bindAndAdd(v8, "entitlements", v13);
  v14 = a2[6];
  v15 = *((unsigned __int8 *)v14 + 36);
  if ((int)(bswap32(*((_DWORD *)v14 + 6)) - 1) < 0
    || (v16 = *((unsigned __int8 *)v14 + 36), (*((_BYTE *)v14 + 28) & 0x80) != 0))
  {
    __security_simulatecrash(CFSTR("Execution has encountered an unexpected state"), 0x53C0000Eu);
    v16 = *((unsigned __int8 *)v14 + 36);
  }
  objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", (char *)v14 + bswap32(*((_DWORD *)v14 + 4)) - v16, v15);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  +[sec_LWCRFact dataFact:](sec_LWCRFact, "dataFact:", v17);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  bindAndAdd(v8, "info-plist-hash", v18);
  bindAndAddBoolFact(v8, "is-main-binary", HIBYTE(*((_QWORD *)a2[6] + 10)) & 1);
  bindAndAddBoolFact(v8, "is-sip-protected", *((unsigned __int8 *)a2 + 89));
  bindAndAddBoolFact(v8, "on-authorized-authapfs-volume", *((unsigned __int8 *)a2 + 90));
  bindAndAddBoolFact(v8, "on-system-volume", *((unsigned __int8 *)a2 + 91));
  size = 0;
  if (sysctlbyname("hw.osenvironment", 0, &size, 0, 0))
  {
    secLogObjForScope("SecError");
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = __error();
      v21 = strerror(*v20);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "getOSEnvironment";
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v21;
      _os_log_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEFAULT, "%s: failed to query hw.osenvironment sysctl (error: %s)", buf, 0x16u);
    }

    goto LABEL_12;
  }
  if (size)
  {
    v23 = malloc_type_malloc(size, 0x1E16DF46uLL);
    if (sysctlbyname("hw.osenvironment", v23, &size, 0, 0))
    {
      secLogObjForScope("SecError");
      v24 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        v25 = __error();
        v26 = strerror(*v25);
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "getOSEnvironment";
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v26;
        _os_log_impl(&dword_18A900000, v24, OS_LOG_TYPE_DEFAULT, "%s: failed to retrieve hw.osenvironment (error: %s)", buf, 0x16u);
      }

      v27 = 0;
    }
    else
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithCString:encoding:", v23, 4);
      v27 = (void *)objc_claimAutoreleasedReturnValue();
    }
    free(v23);
    if (!v27)
      goto LABEL_12;
LABEL_22:
    v22 = objc_retainAutorelease(v27);
    bindAndAddStringFact(v8, "os-environment", objc_msgSend(v22, "UTF8String"));
    goto LABEL_23;
  }
  v27 = (void *)objc_opt_new();
  if (v27)
    goto LABEL_22;
LABEL_12:
  v22 = 0;
  bindAndAddStringFact(v8, "os-environment", (uint64_t)&unk_18AA61AAF);
LABEL_23:
  bindAndAddIntegerFact(v8, "platform", *((unsigned __int8 *)a2 + 88));
  bindAndAddIntegerFact(v8, "platform-identifier", *((unsigned __int8 *)a2[6] + 38));
  if (*((char *)a2 + 47) >= 0)
    v28 = (Security::CodeSigning::CodeDirectory *)(a2 + 3);
  else
    v28 = a2[3];
  bindAndAddStringFact(v8, "signing-identifier", (uint64_t)v28);
  v29 = (uint64_t)a2[10];
  if (v29)
    bindAndAddStringFact(v8, "team-identifier", v29);
  bindAndAddIntegerFact(v8, "validation-category", *((unsigned int *)a2 + 23));

  makeLightweightCodeRequirement(v6);
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v30)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFC73);
  +[sec_LWCRExecutor executor](sec_LWCRExecutor, "executor");
  v31 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v31, "evaluateRequirements:withFacts:", v30, v8);

  objc_autoreleasePoolPop(context);
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v34);
  return v5;
}

void sub_18AA401B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  va_list va;

  va_start(va, a4);

  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

const void *Security::CodeSigning::Requirement::Context::cert(CFArrayRef *this, int a2)
{
  const __CFArray *v3;
  int v4;
  const void *result;

  v3 = *this;
  if (!v3)
    return 0;
  v4 = a2;
  if (a2 < 0)
  {
    v4 = CFArrayGetCount(v3) + a2;
    v3 = *this;
  }
  if (CFArrayGetCount(v3) <= v4)
    return 0;
  result = CFArrayGetValueAtIndex(*this, v4);
  if (!result)
    return 0;
  return result;
}

void Security::CodeSigning::SecRequirement::~SecRequirement(void **this)
{
  *this = off_1E1FC8D28;
  free(this[2]);
}

{
  *this = off_1E1FC8D28;
  free(this[2]);
  Security::SecCFObject::operator delete((char *)this);
}

BOOL Security::CodeSigning::SecRequirement::equal(const void **this, const void **a2)
{
  return memcmp(this[2], a2[2], bswap32(*((_DWORD *)this[2] + 1))) == 0;
}

CFHashCode Security::CodeSigning::SecRequirement::hash(const UInt8 **this)
{
  CFHashCode v1;
  CFDataRef v3;

  v3 = CFDataCreateWithBytesNoCopy(0, this[2], bswap32(*((_DWORD *)this[2] + 1)), (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  v1 = CFHash(v3);
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v3);
  return v1;
}

void sub_18AA403BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

_QWORD *Security::CodeSigning::SecRequirement::SecRequirement(_QWORD *a1, unsigned int *a2, char a3)
{
  unsigned int v3;

  a1[1] = 1;
  *a1 = off_1E1FC8D28;
  a1[2] = 0;
  v3 = bswap32(a2[1]);
  if (*a2 != 843514 || v3 <= 0xB)
  {
    *__error() = 22;
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14);
  }
  if ((a3 & 1) == 0)
    a2 = Security::Blob<Security::CodeSigning::Requirement,4208856064u>::clone((Security::BlobCore *)a2);
  a1[2] = a2;
  return a1;
}

_QWORD *Security::RefPointer<Security::LoadableBundle>::~RefPointer(_QWORD *a1)
{
  pthread_mutex_t *v2;
  Security::UnixError *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  _QWORD v8[2];

  v2 = (pthread_mutex_t *)(a1 + 1);
  v8[0] = a1 + 1;
  v8[1] = 0xAAAAAAAAAAAAAA01;
  v3 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 1));
  if ((_DWORD)v3)
    Security::UnixError::throwMe(v3);
  if (*a1)
  {
    v4 = (unsigned int *)(*a1 + 8);
    do
    {
      v5 = __ldxr(v4);
      v6 = v5 - 1;
    }
    while (__stxr(v6, v4));
    if (!v6)
    {
      if (*a1)
        (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 8))(*a1);
      *a1 = 0;
    }
  }
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)v8);
  Security::Mutex::~Mutex(v2);
  return a1;
}

uint64_t Security::ModuleNexus<Security::CodeSigning::PluginHost>::operator()()
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EDF7AB28);
  if (!Security::CodeSigning::plugin)
    Security::CodeSigning::plugin = Security::ModuleNexusCommon::create((Security::ModuleNexusCommon *)&Security::CodeSigning::plugin, (void *(*)(void))Security::ModuleNexus<Security::CodeSigning::PluginHost>::make);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EDF7AB28);
  return Security::CodeSigning::plugin;
}

void sub_18AA40548(void *a1)
{
  __cxa_begin_catch(a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EDF7AB28);
  __cxa_rethrow();
}

void sub_18AA40560(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

_QWORD *Security::ModuleNexus<Security::CodeSigning::PluginHost>::make()
{
  _QWORD *v0;
  __CFBundle *Bundle;
  const char *v2;
  CFURLRef v3;
  const __CFURL *v4;
  uint64_t v5;
  char *v6;
  unsigned int *v7;
  NSObject *v8;
  Security::UnixError *v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t (*v14)(void);
  void **v16;
  void *__p[2];
  char v18;
  __CFURL *CFURL;
  CFURLRef v20;
  void *v21[2];
  char v22;
  _BYTE buf[22];
  __int16 v24;
  void **v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v0 = (_QWORD *)operator new();
  *v0 = 0;
  Security::Mutex::Mutex((pthread_mutex_t *)(v0 + 1));
  Bundle = (__CFBundle *)SecFrameworkGetBundle();
  if (!Bundle)
  {
LABEL_26:
    Security::Syslog::warning((Security::Syslog *)"code signing problem: unable to load csparser plug-in", v2);
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
  }
  v3 = CFBundleCopyBuiltInPlugInsURL(Bundle);
  v20 = v3;
  if (!v3)
  {
LABEL_25:
    Security::CFRef<__CFURL const*>::~CFRef((const void **)&v20);
    goto LABEL_26;
  }
  CFURL = Security::makeCFURL((Security *)"csparser.bundle", (const char *)1, (uint64_t)v3, v4);
  if (!CFURL)
  {
    Security::CFRef<__CFURL const*>::~CFRef((const void **)&CFURL);
    goto LABEL_25;
  }
  v5 = operator new();
  v6 = (char *)__p;
  Security::cfString((Security *)__p, CFURL);
  if (v18 < 0)
    v6 = (char *)__p[0];
  *(_DWORD *)(v5 + 8) = 0;
  v7 = (unsigned int *)(v5 + 8);
  *(_QWORD *)v5 = &off_1E1FC9308;
  std::string::basic_string[abi:ne180100]<0>((_QWORD *)(v5 + 16), v6);
  *(_OWORD *)(v5 + 40) = 0u;
  *(_OWORD *)(v5 + 56) = 0u;
  v8 = secLogObjForScope("bundle");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    (*(void (**)(void **__return_ptr, uint64_t))(*(_QWORD *)v5 + 24))(v21, v5);
    v16 = v22 >= 0 ? v21 : (void **)v21[0];
    *(_DWORD *)buf = 134218498;
    *(_QWORD *)&buf[4] = v5;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v6;
    v24 = 2080;
    v25 = v16;
    _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "%p Bundle from path %s(%s)", buf, 0x20u);
    if (v22 < 0)
      operator delete(v21[0]);
  }
  *(_QWORD *)v5 = &off_1E1FC9258;
  *(_QWORD *)buf = v0 + 1;
  *(_QWORD *)&buf[8] = 0xAAAAAAAAAAAAAAAALL;
  v9 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(v0 + 1));
  if ((_DWORD)v9)
    Security::UnixError::throwMe(v9);
  buf[8] = 1;
  do
    v10 = __ldxr(v7);
  while (__stxr(v10 + 1, v7));
  if (*v0)
  {
    v11 = (unsigned int *)(*v0 + 8);
    do
    {
      v12 = __ldxr(v11);
      v13 = v12 - 1;
    }
    while (__stxr(v13, v11));
    if (!v13 && *v0)
      (*(void (**)(_QWORD))(*(_QWORD *)*v0 + 8))(*v0);
  }
  *v0 = v5;
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)buf);
  if (v18 < 0)
    operator delete(__p[0]);
  (*(void (**)(_QWORD))(*(_QWORD *)*v0 + 56))(*v0);
  v14 = (uint64_t (*)(void))(*(uint64_t (**)(_QWORD, const char *))(*(_QWORD *)*v0 + 40))(*v0, "findAntlrPlugin");
  v0[9] = v14();
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&CFURL);
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v20);
  return v0;
}

void sub_18AA4085C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15, const void *a16)
{
  _QWORD *v16;
  uint64_t v17;
  void **v18;
  void **v19;

  if (*(char *)(v17 + 63) < 0)
    operator delete(*v19);
  if (*(char *)(v17 + 39) < 0)
    operator delete(*v18);
  if (a14 < 0)
    operator delete(__p);
  MEMORY[0x18D76FAA0](v17, 0x10B3C40C4AD4AC1);
  Security::CFRef<__CFURL const*>::~CFRef(&a15);
  Security::CFRef<__CFURL const*>::~CFRef(&a16);
  Security::RefPointer<Security::LoadableBundle>::~RefPointer(v16);
  MEMORY[0x18D76FAA0](v16, 0x1020C40482925CDLL);
  _Unwind_Resume(a1);
}

std::string *Security::CodeSigning::Dumper::print(Security::CodeSigning::Dumper *this, const char *__format, ...)
{
  __int128 v3;
  std::string::size_type v4;
  char __str[16];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  va_list va;

  va_start(va, __format);
  v22 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20 = v3;
  v21 = v3;
  v18 = v3;
  v19 = v3;
  v16 = v3;
  v17 = v3;
  v14 = v3;
  v15 = v3;
  v12 = v3;
  v13 = v3;
  v10 = v3;
  v11 = v3;
  v8 = v3;
  v9 = v3;
  *(_OWORD *)__str = v3;
  v7 = v3;
  vsnprintf(__str, 0x100uLL, __format, va);
  v4 = strlen(__str);
  return std::string::append((std::string *)((char *)this + 16), __str, v4);
}

std::string *Security::CodeSigning::Dumper::expr(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;
  const char *v6;
  const char *v8;
  uint64_t v9;
  uint64_t v10;

  while (2)
  {
    if (*(_BYTE *)(a1 + 40))
      Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "/*@0x%x*/", *(_DWORD *)(a1 + 8));
    v4 = Security::CodeSigning::Requirement::Reader::get<unsigned int>((unsigned int *)a1);
    LODWORD(v5) = 0;
    v6 = "! ";
    switch(v4 & 0xFFFFFF)
    {
      case 0:
        v8 = "never";
        return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, v8);
      case 1:
        v8 = "always";
        return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, v8);
      case 2:
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "identifier ");
        return Security::CodeSigning::Dumper::data((Security::CodeSigning::Requirement::Reader *)a1, 0);
      case 3:
        v8 = "anchor apple";
        return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, v8);
      case 4:
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "certificate");
        Security::CodeSigning::Dumper::certSlot((Security::CodeSigning::Dumper *)a1);
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, " = ");
        return Security::CodeSigning::Dumper::hashData((Security::CodeSigning::Dumper *)a1);
      case 5:
        if (*(_BYTE *)(a1 + 40))
          Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "/*legacy*/");
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "info[");
        Security::CodeSigning::Dumper::data((Security::CodeSigning::Requirement::Reader *)a1, 1);
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "] = ");
        return Security::CodeSigning::Dumper::data((Security::CodeSigning::Requirement::Reader *)a1, 0);
      case 6:
        if (a2 > 0)
        {
          v5 = 1;
          v6 = " and ";
LABEL_8:
          Security::CodeSigning::Dumper::expr(a1, v5);
LABEL_9:
          Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, v6);
          a2 = v5;
          continue;
        }
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "(");
        Security::CodeSigning::Dumper::expr(a1, 1);
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, " and ");
        v9 = a1;
        v10 = 1;
LABEL_40:
        Security::CodeSigning::Dumper::expr(v9, v10);
LABEL_41:
        v8 = ")";
        return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, v8);
      case 7:
        if (a2 <= 1)
        {
          Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "(");
          Security::CodeSigning::Dumper::expr(a1, 2);
          Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, " or ");
          v9 = a1;
          v10 = 2;
          goto LABEL_40;
        }
        v5 = 2;
        v6 = " or ";
        goto LABEL_8;
      case 8:
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "cdhash ");
        return Security::CodeSigning::Dumper::hashData((Security::CodeSigning::Dumper *)a1);
      case 9:
        goto LABEL_9;
      case 0xA:
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "info[");
        goto LABEL_30;
      case 0xB:
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "certificate");
        Security::CodeSigning::Dumper::certSlot((Security::CodeSigning::Dumper *)a1);
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "[");
        goto LABEL_30;
      case 0xC:
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "certificate");
        Security::CodeSigning::Dumper::certSlot((Security::CodeSigning::Dumper *)a1);
        v8 = "trusted";
        return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, v8);
      case 0xD:
        v8 = "anchor trusted";
        return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, v8);
      case 0xE:
      case 0x11:
      case 0x16:
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "certificate");
        Security::CodeSigning::Dumper::certSlot((Security::CodeSigning::Dumper *)a1);
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "[");
        goto LABEL_31;
      case 0xF:
        v8 = "anchor apple generic";
        return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, v8);
      case 0x10:
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "entitlement[");
LABEL_30:
        Security::CodeSigning::Dumper::data((Security::CodeSigning::Requirement::Reader *)a1, 1);
LABEL_31:
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "]");
        return Security::CodeSigning::Dumper::match((Security::CodeSigning::Dumper *)a1);
      case 0x12:
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "anchor apple ");
        return Security::CodeSigning::Dumper::data((Security::CodeSigning::Requirement::Reader *)a1, 0);
      case 0x13:
        Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "(");
        Security::CodeSigning::Dumper::data((Security::CodeSigning::Requirement::Reader *)a1, 0);
        goto LABEL_41;
      case 0x14:
        Security::CodeSigning::Requirement::Reader::get<unsigned int>((unsigned int *)a1);
        return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "platform = %d");
      case 0x15:
        v8 = "notarized";
        return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, v8);
      case 0x17:
        v8 = "legacy";
        return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, v8);
      default:
        if (v4 < 0)
          return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, " false /* opcode %d */");
        if ((v4 & 0x40000000) != 0)
          return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, " /* opcode %d */");
        return Security::CodeSigning::Dumper::print((Security::CodeSigning::Dumper *)a1, "OPCODE %d NOT UNDERSTOOD (ending print)");
    }
  }
}

uint64_t Security::CodeSigning::Requirement::Reader::get<unsigned int>(unsigned int *a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = a1[2];
  v2 = *(_QWORD *)a1;
  if (v1 + 4 > (unint64_t)bswap32(*(_DWORD *)(*(_QWORD *)a1 + 4)))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14);
  a1[2] = v1 + 4;
  return bswap32(*(_DWORD *)(v2 + v1));
}

std::string *Security::CodeSigning::Dumper::data(Security::CodeSigning::Requirement::Reader *a1, int a2)
{
  unsigned __int8 *v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  BOOL v14;
  size_t v15;
  _QWORD *v16;
  int v17;
  void *v18;
  size_t v19;
  const char *v20;
  char **v21;
  const char *v22;
  int v23;
  std::string *result;
  uint64_t v25;
  unsigned int v26;
  int v27;
  uint64_t v29;
  unsigned int v30;
  _QWORD __dst[3];
  unint64_t v32;
  void *v33;

  v32 = 0xAAAAAAAAAAAAAAAALL;
  v33 = (void *)0xAAAAAAAAAAAAAAAALL;
  Security::CodeSigning::Requirement::Reader::getData(a1, (const void **)&v33, &v32);
  v5 = v32;
  v4 = (unsigned __int8 *)v33;
  if (v32)
  {
    v6 = 0;
    v7 = 0;
    v8 = 1;
    v9 = MEMORY[0x1E0C80978];
    while (1)
    {
      v10 = v4[v6];
      if ((char)v4[v6] < 0)
      {
        if (__maskrune(v10, 0x500uLL))
          goto LABEL_15;
      }
      else if ((*(_DWORD *)(v9 + 4 * v10 + 60) & 0x500) != 0)
      {
        goto LABEL_15;
      }
      v11 = v4[v6];
      if (v11 == 46 && a2 != 0)
      {
LABEL_15:
        if (v8 == 1 && (*(_DWORD *)(v9 + 4 * v4[v6] + 60) & 0x400) != 0)
          v7 = 1;
        goto LABEL_24;
      }
      if ((v11 & 0x80) != 0)
      {
        if (!__maskrune(v11, 0x800uLL))
        {
LABEL_19:
          v13 = v4[v6];
          if ((char)v4[v6] < 0)
          {
            if (!__maskrune(v13, 0x4000uLL))
            {
LABEL_52:
              Security::CodeSigning::Dumper::print(a1, "0x");
              v29 = 0;
              v30 = 1;
              do
              {
                result = Security::CodeSigning::Dumper::print(a1, "%02.2x", v4[v29]);
                v29 = v30;
                v14 = v5 > v30++;
              }
              while (v14);
              return result;
            }
          }
          else if ((*(_DWORD *)(v9 + 4 * v13 + 60) & 0x4000) == 0)
          {
            goto LABEL_52;
          }
        }
      }
      else if ((*(_DWORD *)(v9 + 4 * v11 + 60) & 0x800) == 0)
      {
        goto LABEL_19;
      }
      v7 = 1;
LABEL_24:
      v6 = v8;
      v14 = v5 > v8++;
      if (!v14)
      {
        v15 = v5;
        if (!v7)
          goto LABEL_28;
        Security::CodeSigning::Dumper::print(a1, "\"", v5);
        goto LABEL_43;
      }
    }
  }
  v15 = 0;
LABEL_28:
  memset(__dst, 170, sizeof(__dst));
  v16 = __dst;
  std::string::basic_string[abi:ne180100](__dst, v4, v15);
  v17 = SHIBYTE(__dst[2]);
  v18 = (void *)__dst[0];
  if (__dst[2] >= 0)
    v19 = HIBYTE(__dst[2]);
  else
    v19 = __dst[1];
  if (__dst[2] < 0)
    v16 = (_QWORD *)__dst[0];
  v20 = "guest";
  v21 = off_1E1FDCCA0;
  while (v19 != strlen(v20) || memcmp(v16, v20, v19))
  {
    v22 = *v21++;
    v20 = v22;
    if (!v22)
    {
      v23 = 1;
      if ((v17 & 0x80000000) == 0)
        goto LABEL_38;
LABEL_41:
      operator delete(v18);
      if (!v23)
        goto LABEL_42;
      return Security::CodeSigning::Dumper::print(a1, "%.*s");
    }
  }
  v23 = 0;
  if (v17 < 0)
    goto LABEL_41;
LABEL_38:
  if (v23)
    return Security::CodeSigning::Dumper::print(a1, "%.*s");
LABEL_42:
  Security::CodeSigning::Dumper::print(a1, "\"");
  if (v5)
  {
LABEL_43:
    v25 = 0;
    v26 = 1;
    do
    {
      v27 = v4[v25];
      if (v27 == 34 || v27 == 92)
        Security::CodeSigning::Dumper::print(a1, "\\%c");
      else
        Security::CodeSigning::Dumper::print(a1, "%c");
      v25 = v26;
      v14 = v5 > v26++;
    }
    while (v14);
  }
  return Security::CodeSigning::Dumper::print(a1, "\"");
}

std::string *Security::CodeSigning::Dumper::certSlot(Security::CodeSigning::Dumper *this)
{
  int v2;
  const char *v3;

  v2 = Security::CodeSigning::Requirement::Reader::get<unsigned int>((unsigned int *)this);
  if (!v2)
  {
    v3 = " leaf";
    return Security::CodeSigning::Dumper::print(this, v3);
  }
  if (v2 == -1)
  {
    v3 = " root";
    return Security::CodeSigning::Dumper::print(this, v3);
  }
  return Security::CodeSigning::Dumper::print(this, " %d", v2);
}

std::string *Security::CodeSigning::Dumper::hashData(Security::CodeSigning::Dumper *this)
{
  unint64_t v2;
  uint64_t v3;
  unsigned __int8 *v4;
  unsigned int v5;
  unint64_t v8;
  void *v9;

  Security::CodeSigning::Dumper::print(this, "H\"");
  v8 = 0xAAAAAAAAAAAAAAAALL;
  v9 = (void *)0xAAAAAAAAAAAAAAAALL;
  Security::CodeSigning::Requirement::Reader::getData(this, (const void **)&v9, &v8);
  v2 = v8;
  if (v8)
  {
    v3 = 0;
    v4 = (unsigned __int8 *)v9;
    v5 = 1;
    do
    {
      Security::CodeSigning::Dumper::print(this, "%02.2x", v4[v3]);
      v3 = v5;
    }
    while (v2 > v5++);
  }
  return Security::CodeSigning::Dumper::print(this, "\"");
}

std::string *Security::CodeSigning::Dumper::match(Security::CodeSigning::Dumper *this)
{
  int v2;
  const char *v3;
  std::string *result;

  v2 = Security::CodeSigning::Requirement::Reader::get<unsigned int>((unsigned int *)this);
  switch(v2)
  {
    case 0:
      v3 = " /* exists */";
      goto LABEL_20;
    case 1:
      Security::CodeSigning::Dumper::print(this, " = ");
      return Security::CodeSigning::Dumper::data(this, 0);
    case 2:
      Security::CodeSigning::Dumper::print(this, " ~ ");
      return Security::CodeSigning::Dumper::data(this, 0);
    case 3:
      Security::CodeSigning::Dumper::print(this, " = ");
      Security::CodeSigning::Dumper::data(this, 0);
      v3 = "*";
      goto LABEL_20;
    case 4:
      Security::CodeSigning::Dumper::print(this, " = *");
      return Security::CodeSigning::Dumper::data(this, 0);
    case 5:
      Security::CodeSigning::Dumper::print(this, " < ");
      return Security::CodeSigning::Dumper::data(this, 0);
    case 6:
      Security::CodeSigning::Dumper::print(this, " > ");
      return Security::CodeSigning::Dumper::data(this, 0);
    case 7:
      Security::CodeSigning::Dumper::print(this, " <= ");
      return Security::CodeSigning::Dumper::data(this, 0);
    case 8:
      Security::CodeSigning::Dumper::print(this, " >= ");
      return Security::CodeSigning::Dumper::data(this, 0);
    case 9:
      Security::CodeSigning::Dumper::print(this, " = ");
      goto LABEL_18;
    case 10:
      Security::CodeSigning::Dumper::print(this, " < ");
      goto LABEL_18;
    case 11:
      Security::CodeSigning::Dumper::print(this, " > ");
      goto LABEL_18;
    case 12:
      Security::CodeSigning::Dumper::print(this, " <= ");
      goto LABEL_18;
    case 13:
      Security::CodeSigning::Dumper::print(this, " >= ");
LABEL_18:
      result = (std::string *)Security::CodeSigning::Dumper::timestamp(this);
      break;
    case 14:
      v3 = " absent ";
LABEL_20:
      result = Security::CodeSigning::Dumper::print(this, v3);
      break;
    default:
      result = Security::CodeSigning::Dumper::print(this, "MATCH OPCODE %d NOT UNDERSTOOD", v2);
      break;
  }
  return result;
}

const void **Security::CodeSigning::Dumper::timestamp(Security::CodeSigning::Dumper *this)
{
  int64_t v2;
  std::string *p_p;
  std::string __p;
  const __CFString *v6;
  CFDateRef v7;

  v2 = Security::CodeSigning::Requirement::Reader::get<long long>((unsigned int *)this);
  v7 = CFDateCreate(0, (double)v2);
  v6 = CFCopyDescription(v7);
  Security::cfString(&__p, v6);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  Security::CodeSigning::Dumper::print(this, "<%s>", (const char *)p_p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  Security::CFRef<__CFString const*>::~CFRef((const void **)&v6);
  return Security::CFRef<__CFDate const*>::~CFRef((const void **)&v7);
}

void sub_18AA413F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16)
{
  uint64_t v16;

  if (a15 < 0)
    operator delete(__p);
  Security::CFRef<__CFString const*>::~CFRef(&a16);
  Security::CFRef<__CFDate const*>::~CFRef((const void **)(v16 - 24));
  _Unwind_Resume(a1);
}

unint64_t Security::CodeSigning::Requirement::Reader::get<long long>(unsigned int *a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = a1[2];
  v2 = *(_QWORD *)a1;
  if (v1 + 8 > (unint64_t)bswap32(*(_DWORD *)(*(_QWORD *)a1 + 4)))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14);
  a1[2] = v1 + 8;
  return bswap64(*(_QWORD *)(v2 + v1));
}

void Security::CodeSigning::Dumper::dump(std::string *a1, uint64_t a2)
{
  __int128 v2;
  char v4;
  _BYTE *v5;
  uint64_t v6;
  _BYTE __p[32];
  unint64_t v8;
  std::string v9;
  char v10;

  *(_QWORD *)&v2 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__p = v2;
  v8 = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&__p[16] = v2;
  v6 = a2;
  *(_DWORD *)__p = 12;
  if (bswap32(*(_DWORD *)(a2 + 8)) - 1 >= 2)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA15);
  memset(&__p[8], 0, 24);
  LOBYTE(v8) = 0;
  Security::CodeSigning::Dumper::expr((uint64_t)&v6, 3);
  v4 = __p[31];
  v5 = *(_BYTE **)&__p[8];
  if (__p[31] >= 0)
    v5 = &__p[8];
  if (*v5 == 32)
  {
    std::string::basic_string(&v9, (const std::string *)&__p[8], 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v10);
    if ((__p[31] & 0x80000000) != 0)
      operator delete(*(void **)&__p[8]);
    *(std::string *)&__p[8] = v9;
    v4 = HIBYTE(v9.__r_.__value_.__r.__words[2]);
  }
  if (v4 < 0)
  {
    std::string::__init_copy_ctor_external(a1, *(const std::string::value_type **)&__p[8], *(std::string::size_type *)&__p[16]);
    if ((__p[31] & 0x80000000) != 0)
      operator delete(*(void **)&__p[8]);
  }
  else
  {
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)&__p[8];
    a1->__r_.__value_.__r.__words[2] = *(_QWORD *)&__p[24];
  }
}

void Security::CodeSigning::SecCodeSignerRemote::~SecCodeSignerRemote(const void **this)
{
  *this = off_1E1FC8DD0;
  Security::CFRef<__CFArray const*>::~CFRef(this + 41);
  Security::CodeSigning::SecCodeSigner::~SecCodeSigner((Security::CodeSigning::SecCodeSigner *)this);
}

{
  char *v2;

  *this = off_1E1FC8DD0;
  Security::CFRef<__CFArray const*>::~CFRef(this + 41);
  Security::CodeSigning::SecCodeSigner::~SecCodeSigner((Security::CodeSigning::SecCodeSigner *)this);
  Security::SecCFObject::operator delete(v2);
}

uint64_t Security::CodeSigning::SecCodeSignerRemote::valid(Security::CodeSigning::SecCodeSignerRemote *this)
{
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v4;
  BOOL v5;
  CFIndex i;
  const void *ValueAtIndex;
  CFTypeID TypeID;
  uint64_t result;
  NSObject *v10;
  _BOOL4 v11;
  uint64_t v12;
  int v13;
  Security::CodeSigning::SecCodeSignerRemote *v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = (const __CFArray *)*((_QWORD *)this + 41);
  if (v2)
  {
    Count = CFArrayGetCount(v2);
    if (Count >= 1)
    {
      v4 = Count;
      v5 = 0;
      for (i = 0; i != v4; v5 = i >= v4)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)this + 41), i);
        TypeID = SecCertificateGetTypeID();
        if (TypeID != CFGetTypeID(ValueAtIndex))
          break;
        ++i;
      }
      if (v5)
        return 1;
    }
  }
  v10 = secLogObjForScope("SecError");
  v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v11)
  {
    v12 = *((_QWORD *)this + 41);
    v13 = 134218242;
    v14 = this;
    v15 = 2112;
    v16 = v12;
    _os_log_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEFAULT, "Invalid remote signing operation: %p, %@", (uint8_t *)&v13, 0x16u);
    return 0;
  }
  return result;
}

uint64_t Security::CodeSigning::Requirement::Interpreter::eval(Security::CodeSigning::Requirement::Interpreter *this, int a2)
{
  unsigned int v2;
  int v4;
  unsigned int v5;
  CC_LONG v6;
  CC_LONG v7;
  unsigned int v8;
  uint64_t v9;
  CFArrayRef *v11;
  int v12;
  size_t v13;
  uint64_t v14;
  __int128 v15;
  BOOL v17;
  const __CFDictionary *v18;
  uint64_t v19;
  Security::CodeSigning::CodeDirectory *v20;
  CFDataRef v21;
  CC_LONG v22;
  Security::CodeSigning::CodeDirectory *v23;
  const void **v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  CFArrayRef *v29;
  int v30;
  const UInt8 *BytePtr;
  CFIndex Length;
  BOOL v33;
  uint64_t v34;
  const void *v35;
  int Nl_high;
  CC_SHA1_CTX *p_c;
  void *v38;
  int v39;
  const __CFArray *v40;
  const __CFArray *v41;
  int v42;
  int v43;
  BOOL v44;
  uint64_t v45;
  const void *v46;
  const __CFDate *v47;
  const __CFString *v48;
  NSObject *v49;
  NSObject *v50;
  NSObject *v51;
  int v52;
  uint64_t v53;
  __int128 v54;
  _QWORD *v55;
  const __CFArray *v56;
  const __CFString *v57;
  CFIndex Code;
  NSObject *v59;
  const char *v60;
  NSObject *v61;
  uint32_t v62;
  NSObject *v63;
  NSObject *v64;
  const __CFString *Value;
  int v66;
  NSObject *v67;
  NSObject *v68;
  NSObject *v69;
  Security::CodeSigning::CodeDirectory *v70;
  CC_LONG v71;
  uint64_t v72;
  const char *v73;
  __CFString *v74;
  NSObject *v75;
  NSObject *v76;
  uint64_t v78;
  uint64_t v79;
  NSObject *v80;
  CFTypeRef cf1[2];
  void *__p[2];
  char v83;
  const __CFDate *v84;
  CFDateRef otherDate;
  CFAbsoluteTime at;
  void *key;
  unsigned __int8 md[24];
  CC_SHA1_CTX c;
  uint64_t v90;
  CFRange v91;

  v90 = *MEMORY[0x1E0C80C00];
  if (a2 < 2)
LABEL_157:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14);
  v2 = a2;
  v4 = 0;
  while (2)
  {
    v5 = v2;
LABEL_4:
    v2 = v5 - 1;
    v6 = Security::CodeSigning::Requirement::Reader::get<unsigned int>((unsigned int *)this);
    v7 = v6;
    switch(v6 & 0xFFFFFF)
    {
      case 0u:
        goto LABEL_112;
      case 1u:
        goto LABEL_122;
      case 2u:
        if (!*(_QWORD *)(*((_QWORD *)this + 2) + 48))
          goto LABEL_112;
        Security::CodeSigning::Requirement::Reader::getString((Security::CodeSigning::Requirement::Reader *)&c, this);
        v35 = (const void *)(bswap32(*(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 48) + 20))
                           + *(_QWORD *)(*((_QWORD *)this + 2) + 48));
        Nl_high = SHIBYTE(c.Nl);
        if ((c.Nl & 0x80000000) == 0)
          v13 = HIBYTE(c.Nl);
        else
          v13 = *(_QWORD *)&c.h2;
        if (v13 == strlen((const char *)v35))
        {
          if ((c.Nl & 0x80000000) == 0)
            p_c = &c;
          else
            p_c = *(CC_SHA1_CTX **)&c.h0;
          LODWORD(v13) = memcmp(p_c, v35, v13) == 0;
        }
        else
        {
          LODWORD(v13) = 0;
        }
        if (Nl_high < 0)
          goto LABEL_57;
        return (v4 ^ v13) & 1;
      case 3u:
        *(_QWORD *)md = Security::CodeSigning::CodeDirectory::cdhash(*(Security::CodeSigning::CodeDirectory **)(*((_QWORD *)this + 2) + 48), 1);
        BytePtr = CFDataGetBytePtr(*(CFDataRef *)md);
        Length = CFDataGetLength(*(CFDataRef *)md);
        if (BytePtr)
          v33 = Length == 20;
        else
          v33 = 0;
        if (v33)
        {
          c.Nl = -1431655766;
          v54 = *(_OWORD *)BytePtr;
          c.h4 = *((_DWORD *)BytePtr + 4);
          *(_OWORD *)&c.h0 = v54;
          *(_QWORD *)&c.Nh = 0;
          if (__sandbox_ms())
            __error();
        }
        Security::CFRef<__CFData const*>::~CFRef((const void **)md);
        if (Security::CodeSigning::Requirement::Interpreter::appleAnchored(*((CFArrayRef **)this + 2)))
        {
          if (Security::CodeSigning::Requirement::Context::cert(*((CFArrayRef **)this + 2), -2))
          {
            std::string::basic_string[abi:ne180100]<0>(&c, "subject.CN");
            *(_QWORD *)md = CFSTR("Apple Code Signing Certification Authority");
            CFRetain(CFSTR("Apple Code Signing Certification Authority"));
            *(_DWORD *)&md[8] = 1;
LABEL_34:
            Security::CFRef<void const*>::~CFRef((const void **)md);
            if (SHIBYTE(c.Nl) < 0)
              operator delete(*(void **)&c.h0);
          }
        }
        else
        {
          if (csr_check())
            goto LABEL_112;
          if (*(_BYTE *)(*((_QWORD *)this + 2) + 68))
            goto LABEL_122;
          *(_QWORD *)&c.h0 = MEMORY[0x1E0C809B0];
          *(_QWORD *)&c.h2 = 0x40000000;
          *(_QWORD *)&c.h4 = ___ZN8Security11CodeSigning11Requirement11Interpreter18appleLocalAnchoredEv_block_invoke;
          *(_QWORD *)&c.Nh = &__block_descriptor_tmp_7_14570;
          *(_QWORD *)&c.data[1] = this;
          if (Security::CodeSigning::Requirement::Interpreter::appleLocalAnchored(void)::onceToken != -1)
            dispatch_once(&Security::CodeSigning::Requirement::Interpreter::appleLocalAnchored(void)::onceToken, &c);
          if (Security::CodeSigning::Requirement::Interpreter::appleLocalAnchored(void)::additionalTrustedCertificates)
          {
            v55 = Security::CodeSigning::Requirement::Context::cert(*((CFArrayRef **)this + 2), 0);
            *(_QWORD *)md = SecCertificateCopySHA256Digest(v55);
            if (!*(_QWORD *)md)
              goto LABEL_111;
            v56 = (const __CFArray *)Security::CodeSigning::Requirement::Interpreter::appleLocalAnchored(void)::additionalTrustedCertificates;
            v91.length = CFArrayGetCount((CFArrayRef)Security::CodeSigning::Requirement::Interpreter::appleLocalAnchored(void)::additionalTrustedCertificates);
            v91.location = 0;
            LODWORD(v56) = CFArrayContainsValue(v56, v91, *(const void **)md);
            Security::CFRef<__CFData const*>::~CFRef((const void **)md);
            if ((_DWORD)v56)
            {
LABEL_122:
              LODWORD(v13) = 1;
              return (v4 ^ v13) & 1;
            }
          }
        }
        goto LABEL_112;
      case 4u:
        v11 = (CFArrayRef *)*((_QWORD *)this + 2);
        v12 = Security::CodeSigning::Requirement::Reader::get<unsigned int>((unsigned int *)this);
        v13 = (size_t)Security::CodeSigning::Requirement::Context::cert(v11, v12);
        *(_QWORD *)&c.h0 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)md = 0xAAAAAAAAAAAAAAAALL;
        Security::CodeSigning::Requirement::Reader::getData(this, (const void **)&c, (unint64_t *)md);
        if (*(_QWORD *)md != 20)
          goto LABEL_157;
        if (!v13)
          return (v4 ^ v13) & 1;
        v14 = *(_QWORD *)&c.h0;
        *(_QWORD *)&v15 = 0xAAAAAAAAAAAAAAAALL;
        *((_QWORD *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&c.data[9] = v15;
        *(_OWORD *)&c.data[13] = v15;
        *(_OWORD *)&c.data[1] = v15;
        *(_OWORD *)&c.data[5] = v15;
        *(_OWORD *)&c.h0 = v15;
        *(_OWORD *)&c.h4 = v15;
        CC_SHA1_Init(&c);
        CC_SHA1_Update(&c, *(const void **)(v13 + 16), *(_DWORD *)(v13 + 24));
        memset(md, 170, 20);
        CC_SHA1_Final(md, &c);
        v17 = *(_QWORD *)md == *(_QWORD *)v14
           && *(_QWORD *)&md[8] == *(_QWORD *)(v14 + 8)
           && *(unsigned int *)&md[16] == (unint64_t)*(unsigned int *)(v14 + 16);
        goto LABEL_84;
      case 5u:
        memset(&c, 170, 24);
        Security::CodeSigning::Requirement::Reader::getString((Security::CodeSigning::Requirement::Reader *)&c, this);
        Security::CodeSigning::Requirement::Reader::getString((Security::CodeSigning::Requirement::Reader *)__p, this);
        Security::CFTempString::CFTempString<std::string>((CFStringRef *)cf1, (char *)__p);
        Security::CFCopyRef<void const*>::CFCopyRef(md, cf1[0]);
        *(_DWORD *)&md[8] = 1;
        LODWORD(v13) = Security::CodeSigning::Requirement::Interpreter::infoKeyValue(*(const __CFDictionary **)(*((_QWORD *)this + 2) + 8), (uint64_t)&c, (uint64_t)md);
        Security::CFRef<void const*>::~CFRef((const void **)md);
        Security::CFRef<__CFString const*>::~CFRef(cf1);
        if (v83 < 0)
          operator delete(__p[0]);
        goto LABEL_56;
      case 6u:
        v26 = Security::CodeSigning::Requirement::Interpreter::eval(this, v5 - 1);
        LODWORD(v13) = v26 & Security::CodeSigning::Requirement::Interpreter::eval(this, v5 - 1);
        return (v4 ^ v13) & 1;
      case 7u:
        v25 = Security::CodeSigning::Requirement::Interpreter::eval(this, v5 - 1);
        LODWORD(v13) = v25 | Security::CodeSigning::Requirement::Interpreter::eval(this, v5 - 1);
        return (v4 ^ v13) & 1;
      case 8u:
        v23 = *(Security::CodeSigning::CodeDirectory **)(*((_QWORD *)this + 2) + 48);
        if (!v23)
          goto LABEL_112;
        cf1[0] = Security::CodeSigning::CodeDirectory::cdhash(v23, 1);
        *(_QWORD *)&c.h0 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)md = 0xAAAAAAAAAAAAAAAALL;
        Security::CodeSigning::Requirement::Reader::getData(this, (const void **)&c, (unint64_t *)md);
        key = CFDataCreate(0, *(const UInt8 **)&c.h0, *(CFIndex *)md);
        LODWORD(v13) = CFEqual(cf1[0], key) != 0;
        Security::CFRef<__CFData const*>::~CFRef((const void **)&key);
        v24 = cf1;
        goto LABEL_155;
      case 9u:
        v4 ^= 1u;
        if (v5 < 3)
          goto LABEL_157;
        continue;
      case 0xAu:
        memset(&c, 170, 24);
        Security::CodeSigning::Requirement::Reader::getString((Security::CodeSigning::Requirement::Reader *)&c, this);
        memset(md, 170, 16);
        Security::CodeSigning::Requirement::Interpreter::Match::Match((Security::CodeSigning::Requirement::Interpreter::Match *)md, this);
        LODWORD(v13) = Security::CodeSigning::Requirement::Interpreter::infoKeyValue(*(const __CFDictionary **)(*((_QWORD *)this + 2) + 8), (uint64_t)&c, (uint64_t)md);
        Security::CFRef<void const*>::~CFRef((const void **)md);
        goto LABEL_56;
      case 0xBu:
        v29 = (CFArrayRef *)*((_QWORD *)this + 2);
        v30 = Security::CodeSigning::Requirement::Reader::get<unsigned int>((unsigned int *)this);
        Security::CodeSigning::Requirement::Context::cert(v29, v30);
        memset(&c, 170, 24);
        Security::CodeSigning::Requirement::Reader::getString((Security::CodeSigning::Requirement::Reader *)&c, this);
        memset(md, 170, 16);
        Security::CodeSigning::Requirement::Interpreter::Match::Match((Security::CodeSigning::Requirement::Interpreter::Match *)md, this);
        goto LABEL_34;
      case 0xCu:
        v39 = Security::CodeSigning::Requirement::Reader::get<unsigned int>((unsigned int *)this);
        if (Security::CodeSigning::Requirement::Context::cert(*((CFArrayRef **)this + 2), v39))
        {
          v40 = (const __CFArray *)**((_QWORD **)this + 2);
          if (v40)
            CFArrayGetCount(v40);
        }
        goto LABEL_112;
      case 0xDu:
        v41 = (const __CFArray *)**((_QWORD **)this + 2);
        if (!v41)
          goto LABEL_112;
        v42 = CFArrayGetCount(v41) - 1;
        if (v42 < 0)
          goto LABEL_112;
        v43 = 0;
        do
        {
          LODWORD(v13) = 0;
          if (Security::CodeSigning::Requirement::Context::cert(*((CFArrayRef **)this + 2), v43))
            v44 = v42 == v43;
          else
            v44 = 1;
          ++v43;
        }
        while (!v44);
        return (v4 ^ v13) & 1;
      case 0xFu:
        LODWORD(v13) = Security::CodeSigning::Requirement::Interpreter::appleAnchored(*((CFArrayRef **)this + 2));
        return (v4 ^ v13) & 1;
      case 0x10u:
        memset(md, 170, sizeof(md));
        Security::CodeSigning::Requirement::Reader::getString((Security::CodeSigning::Requirement::Reader *)md, this);
        cf1[0] = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
        cf1[1] = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
        Security::CodeSigning::Requirement::Interpreter::Match::Match((Security::CodeSigning::Requirement::Interpreter::Match *)cf1, this);
        v18 = *(const __CFDictionary **)(*((_QWORD *)this + 2) + 16);
        if (!v18)
          goto LABEL_118;
        if ((char)md[23] < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)&c, *(const std::string::value_type **)md, *(std::string::size_type *)&md[8]);
        }
        else
        {
          *(_OWORD *)&c.h0 = *(_OWORD *)md;
          *(_QWORD *)&c.h4 = *(_QWORD *)&md[16];
        }
        Security::CFTempString::CFTempString<std::string>((CFStringRef *)&key, (char *)&c);
        Value = (const __CFString *)CFDictionaryGetValue(v18, key);
        Security::CFRef<__CFString const*>::~CFRef((const void **)&key);
        if (SHIBYTE(c.Nl) < 0)
          operator delete(*(void **)&c.h0);
        if (Value)
          v66 = Security::CodeSigning::Requirement::Interpreter::Match::operator()((uint64_t)cf1, Value);
        else
LABEL_118:
          v66 = Security::CodeSigning::Requirement::Interpreter::Match::operator()((uint64_t)cf1, (const __CFString *)*MEMORY[0x1E0C9B0D0]);
        LODWORD(v13) = v66;
        Security::CFRef<void const*>::~CFRef(cf1);
        if (((char)md[23] & 0x80000000) == 0)
          return (v4 ^ v13) & 1;
        v38 = *(void **)md;
        goto LABEL_58;
      case 0x12u:
        v27 = Security::ModuleNexus<Security::CodeSigning::Fragments>::operator()();
        Security::CodeSigning::Requirement::Reader::getString((Security::CodeSigning::Requirement::Reader *)&c, this);
        v28 = Security::CodeSigning::Fragments::evalNamed(v27, "anchorreq", (uint64_t)&c, *((const Security::CodeSigning::Requirement::Context **)this + 2));
        goto LABEL_44;
      case 0x13u:
        v34 = Security::ModuleNexus<Security::CodeSigning::Fragments>::operator()();
        Security::CodeSigning::Requirement::Reader::getString((Security::CodeSigning::Requirement::Reader *)&c, this);
        v28 = Security::CodeSigning::Fragments::evalNamed(v34, "subreq", (uint64_t)&c, *((const Security::CodeSigning::Requirement::Context **)this + 2));
LABEL_44:
        LODWORD(v13) = v28;
LABEL_56:
        if (SHIBYTE(c.Nl) < 0)
        {
LABEL_57:
          v38 = *(void **)&c.h0;
LABEL_58:
          operator delete(v38);
        }
        return (v4 ^ v13) & 1;
      case 0x14u:
        v52 = Security::CodeSigning::Requirement::Reader::get<unsigned int>((unsigned int *)this);
        v53 = *(_QWORD *)(*((_QWORD *)this + 2) + 48);
        if (!v53)
          goto LABEL_112;
        v17 = v52 == *(unsigned __int8 *)(v53 + 38);
LABEL_84:
        LODWORD(v13) = v17;
        return (v4 ^ v13) & 1;
      case 0x15u:
        v19 = *((_QWORD *)this + 2);
        *(_QWORD *)md = 0;
        cf1[0] = 0;
        if (!v19)
          goto LABEL_108;
        v20 = *(Security::CodeSigning::CodeDirectory **)(v19 + 48);
        if (v20)
        {
          v21 = Security::CodeSigning::CodeDirectory::cdhash(v20, 1);
          *(_QWORD *)md = v21;
          if (!v21)
            goto LABEL_108;
          v22 = *(unsigned __int8 *)(*(_QWORD *)(v19 + 48) + 37);
        }
        else
        {
          v21 = *(CFDataRef *)(v19 + 56);
          if (!v21)
            goto LABEL_108;
          CFRetain(*(CFTypeRef *)(v19 + 56));
          *(_QWORD *)md = v21;
          v22 = *(_DWORD *)(v19 + 64);
        }
        v63 = secLogObjForScope("notarization");
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
        {
          c.h0 = 67109378;
          c.h1 = v22;
          LOWORD(c.h2) = 2112;
          *(_QWORD *)((char *)&c.h2 + 2) = v21;
          _os_log_debug_impl(&dword_18A900000, v63, OS_LOG_TYPE_DEBUG, "checking notarization on %d, %@", (uint8_t *)&c, 0x12u);
        }
LABEL_108:
        v64 = secLogObjForScope("notarization");
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
        {
          c.h0 = 67109120;
          c.h1 = 0;
          _os_log_debug_impl(&dword_18A900000, v64, OS_LOG_TYPE_DEBUG, "isNotarized = %d", (uint8_t *)&c, 8u);
        }
        Security::CFRef<__CFError *>::~CFRef(cf1);
LABEL_111:
        Security::CFRef<__CFData const*>::~CFRef((const void **)md);
LABEL_112:
        LODWORD(v13) = 0;
        return (v4 ^ v13) & 1;
      case 0x17u:
        v45 = *((_QWORD *)this + 2);
        key = 0;
        *(_QWORD *)md = 0;
        cf1[0] = 0;
        at = 0.0;
        if (!v45)
          goto LABEL_151;
        v46 = Security::CodeSigning::Requirement::Context::cert((CFArrayRef *)v45, 0);
        cf1[0] = 0;
        if (SecCertificateGetDeveloperIDDate((uint64_t)v46, &at, (__CFString **)cf1))
        {
          otherDate = (CFDateRef)0xAAAAAAAAAAAAAAAALL;
          v47 = CFDateCreate(0, at);
          v84 = (const __CFDate *)0xAAAAAAAAAAAAAAAALL;
          otherDate = v47;
          v84 = Security::CodeSigning::copyCutOffDate(CFSTR("AccountCreationCutOffDate"), v48, 576374400.0);
          v49 = secLogObjForScope("meetsDeveloperIDLegacyAllowedPolicy");
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
          {
            c.h0 = 138412290;
            *(_QWORD *)&c.h1 = v84;
            _os_log_debug_impl(&dword_18A900000, v49, OS_LOG_TYPE_DEBUG, "Account Creation Date Cutoff: %@", (uint8_t *)&c, 0xCu);
          }
          v50 = secLogObjForScope("meetsDeveloperIDLegacyAllowedPolicy");
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            c.h0 = 138412290;
            *(_QWORD *)&c.h1 = otherDate;
            _os_log_debug_impl(&dword_18A900000, v50, OS_LOG_TYPE_DEBUG, "Account Creation date: %@", (uint8_t *)&c, 0xCu);
          }
          if ((CFDateCompare(otherDate, v84, 0) & 0x8000000000000000) == 0)
          {
            v51 = secLogObjForScope("meetsDeveloperIDLegacyAllowedPolicy");
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
            {
              c.h0 = 138412546;
              *(_QWORD *)&c.h1 = otherDate;
              LOWORD(c.h3) = 2112;
              *(_QWORD *)((char *)&c.h3 + 2) = v84;
              _os_log_debug_impl(&dword_18A900000, v51, OS_LOG_TYPE_DEBUG, "Account creation date %@ is after cut-off %@", (uint8_t *)&c, 0x16u);
            }
            Security::CFRef<__CFDate const*>::~CFRef((const void **)&v84);
            Security::CFRef<__CFDate const*>::~CFRef((const void **)&otherDate);
            goto LABEL_151;
          }
          Security::CFRef<__CFDate const*>::~CFRef((const void **)&v84);
          Security::CFRef<__CFDate const*>::~CFRef((const void **)&otherDate);
        }
        else
        {
          Code = CFErrorGetCode((CFErrorRef)cf1[0]);
          if (Code != -67880)
          {
            v59 = secLogObjForScope("SecError");
            LODWORD(v13) = 0;
            if (!os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
              goto LABEL_152;
            c.h0 = 134217984;
            *(_QWORD *)&c.h1 = Code;
            v60 = "Unexpected error checking account creation date: %ld";
            v61 = v59;
            v62 = 12;
            goto LABEL_150;
          }
        }
        if (*(_QWORD *)(v45 + 72))
        {
          otherDate = (CFDateRef)0xAAAAAAAAAAAAAAAALL;
          otherDate = Security::CodeSigning::copyCutOffDate(CFSTR("SecureTimestampCutOffDate"), v57, 581040000.0);
          v67 = secLogObjForScope("meetsDeveloperIDLegacyAllowedPolicy");
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
          {
            c.h0 = 138412290;
            *(_QWORD *)&c.h1 = otherDate;
            _os_log_debug_impl(&dword_18A900000, v67, OS_LOG_TYPE_DEBUG, "Secure Timestamp Cutoff Date cutoff: %@", (uint8_t *)&c, 0xCu);
          }
          v68 = secLogObjForScope("meetsDevleoperIDLegacyAllowedPolicy");
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
          {
            v78 = *(_QWORD *)(v45 + 72);
            c.h0 = 138412290;
            *(_QWORD *)&c.h1 = v78;
            _os_log_debug_impl(&dword_18A900000, v68, OS_LOG_TYPE_DEBUG, "Secure Timestamp: %@", (uint8_t *)&c, 0xCu);
          }
          if (CFDateCompare(*(CFDateRef *)(v45 + 72), otherDate, 0) < 0)
          {
            Security::CFRef<__CFDate const*>::~CFRef((const void **)&otherDate);
            LODWORD(v13) = 1;
            goto LABEL_152;
          }
          v69 = secLogObjForScope("meetsDeveloperIDLegacyAllowedPolicy");
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
          {
            v79 = *(_QWORD *)(v45 + 72);
            c.h0 = 138412546;
            *(_QWORD *)&c.h1 = v79;
            LOWORD(c.h3) = 2112;
            *(_QWORD *)((char *)&c.h3 + 2) = otherDate;
            _os_log_debug_impl(&dword_18A900000, v69, OS_LOG_TYPE_DEBUG, "Secure timestamp %@ is after cut-off %@", (uint8_t *)&c, 0x16u);
          }
          Security::CFRef<__CFDate const*>::~CFRef((const void **)&otherDate);
        }
        v70 = *(Security::CodeSigning::CodeDirectory **)(v45 + 48);
        if (!v70)
        {
          v72 = *(_QWORD *)(v45 + 56);
          if (v72)
          {
            CFRetain(*(CFTypeRef *)(v45 + 56));
            if (*(_QWORD *)md)
              CFRelease(*(CFTypeRef *)md);
            *(_QWORD *)md = v72;
            v71 = *(_DWORD *)(v45 + 64);
          }
          else
          {
            v71 = 0;
            LODWORD(v13) = *(_DWORD *)md;
            if (!*(_QWORD *)md)
              goto LABEL_152;
          }
          goto LABEL_144;
        }
        v13 = (size_t)Security::CodeSigning::CodeDirectory::cdhash(v70, 1);
        if (*(_QWORD *)md)
          CFRelease(*(CFTypeRef *)md);
        *(_QWORD *)md = v13;
        v71 = *(unsigned __int8 *)(*(_QWORD *)(v45 + 48) + 37);
        if (v13)
        {
LABEL_144:
          v73 = *(const char **)(v45 + 80);
          if (v73)
          {
            v74 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v73, 0x8000100u);
            if (key)
              CFRelease(key);
            key = v74;
          }
          v75 = secLogObjForScope("legacy_list");
          LODWORD(v13) = 0;
          if (!os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
            goto LABEL_152;
          c.h0 = 67109634;
          c.h1 = v71;
          LOWORD(c.h2) = 2112;
          *(_QWORD *)((char *)&c.h2 + 2) = *(_QWORD *)md;
          HIWORD(c.h4) = 2112;
          *(_QWORD *)&c.Nl = key;
          v60 = "checking the legacy list for %d, %@, %@";
          v61 = v75;
          v62 = 28;
LABEL_150:
          _os_log_impl(&dword_18A900000, v61, OS_LOG_TYPE_DEFAULT, v60, (uint8_t *)&c, v62);
LABEL_151:
          LODWORD(v13) = 0;
        }
LABEL_152:
        v76 = secLogObjForScope("legacy_list");
        if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
        {
          c.h0 = 67109120;
          c.h1 = v13;
          _os_log_impl(&dword_18A900000, v76, OS_LOG_TYPE_DEFAULT, "meetsDeveloperIDLegacyAllowedPolicy = %d", (uint8_t *)&c, 8u);
        }
        Security::CFRef<__CFString const*>::~CFRef((const void **)&key);
        Security::CFRef<__CFError *>::~CFRef(cf1);
        v24 = (const void **)md;
LABEL_155:
        Security::CFRef<__CFData const*>::~CFRef(v24);
        return (v4 ^ v13) & 1;
      default:
        if (!(v6 >> 30))
        {
          v80 = secLogObjForScope("csinterp");
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
          {
            c.h0 = 67109120;
            c.h1 = v7;
            _os_log_debug_impl(&dword_18A900000, v80, OS_LOG_TYPE_DEBUG, "opcode 0x%x cannot be handled; aborting",
              (uint8_t *)&c,
              8u);
          }
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA00);
        }
        v8 = Security::CodeSigning::Requirement::Reader::get<unsigned int>((unsigned int *)this);
        v9 = *((unsigned int *)this + 2);
        if (v9 + (unint64_t)v8 > bswap32(*(_DWORD *)(*(_QWORD *)this + 4)))
          goto LABEL_157;
        *((_DWORD *)this + 2) = v9 + v8;
        if ((v7 & 0x80000000) != 0)
        {
          LODWORD(v13) = 0;
          return (v4 ^ v13) & 1;
        }
        if (v5-- < 3)
          goto LABEL_157;
        goto LABEL_4;
    }
  }
}

void sub_18AA425EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  Security::CFRef<__CFData const*>::~CFRef((const void **)&a24);
  _Unwind_Resume(a1);
}

BOOL Security::CodeSigning::Requirement::Interpreter::appleAnchored(CFArrayRef *this)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  char v4;

  v1 = Security::CodeSigning::Requirement::Context::cert(this, -1);
  if (!v1)
    return 0;
  v2 = v1;
  if ((os_variant_allows_internal_security_policies() & 1) != 0)
    goto LABEL_6;
  if (SecAreQARootCertificatesEnabled_onceToken != -1)
    dispatch_once(&SecAreQARootCertificatesEnabled_onceToken, &__block_literal_global_12660);
  if (SecAreQARootCertificatesEnabled_sQACertsEnabled)
  {
LABEL_6:
    v3 = v2;
    v4 = 3;
  }
  else
  {
    v3 = v2;
    v4 = 0;
  }
  return (SecIsAppleTrustAnchor(v3, v4) & 1) != 0;
}

uint64_t Security::CodeSigning::Requirement::Interpreter::infoKeyValue(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  const __CFString *Value;
  uint64_t v6;
  const __CFString *v7;
  std::string __p;
  void *key;

  if (!a1)
    goto LABEL_9;
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    __p = *(std::string *)a2;
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)&key, (char *)&__p);
  Value = (const __CFString *)CFDictionaryGetValue(a1, key);
  Security::CFRef<__CFString const*>::~CFRef((const void **)&key);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (Value)
      goto LABEL_7;
LABEL_9:
    v7 = (const __CFString *)*MEMORY[0x1E0C9B0D0];
    v6 = a3;
    return Security::CodeSigning::Requirement::Interpreter::Match::operator()(v6, v7);
  }
  if (!Value)
    goto LABEL_9;
LABEL_7:
  v6 = a3;
  v7 = Value;
  return Security::CodeSigning::Requirement::Interpreter::Match::operator()(v6, v7);
}

void sub_18AA428E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, const void *a15)
{
  Security::CFRef<__CFString const*>::~CFRef(&a15);
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

Security::CodeSigning::Requirement::Interpreter::Match *Security::CodeSigning::Requirement::Interpreter::Match::Match(Security::CodeSigning::Requirement::Interpreter::Match *this, Security::CodeSigning::Requirement::Interpreter *a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  int v6;
  char *v7;
  int64_t v8;
  CFDateRef v9;
  CFStringRef v10;
  char *v11;
  char *v13;
  char v14;
  char cStr[8];
  char v16;

  *(_QWORD *)this = 0;
  v3 = *((unsigned int *)a2 + 2);
  v4 = *(_QWORD *)a2;
  if (v3 + 4 > (unint64_t)bswap32(*(_DWORD *)(*(_QWORD *)a2 + 4)))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14);
  *((_DWORD *)a2 + 2) = v3 + 4;
  v5 = bswap32(*(_DWORD *)(v4 + v3));
  *((_DWORD *)this + 2) = v5;
  if (v5 > 0xE)
  {
    Security::CodeSigning::Requirement::Reader::getString((Security::CodeSigning::Requirement::Reader *)&v13, a2);
    if ((v14 & 0x80000000) == 0)
      return this;
    v11 = v13;
    goto LABEL_19;
  }
  v6 = 1 << v5;
  if ((v6 & 0x1FE) == 0)
  {
    if ((v6 & 0x3E00) != 0)
    {
      v8 = Security::CodeSigning::Requirement::Reader::get<long long>((unsigned int *)a2);
      v9 = CFDateCreate(0, (double)v8);
      if (*(_QWORD *)this)
        CFRelease(*(CFTypeRef *)this);
      *(_QWORD *)this = v9;
    }
    return this;
  }
  Security::CodeSigning::Requirement::Reader::getString((Security::CodeSigning::Requirement::Reader *)cStr, a2);
  if (v16 < 0)
  {
    v7 = *(char **)cStr;
    if (!*(_QWORD *)cStr)
    {
      v10 = 0;
      goto LABEL_15;
    }
  }
  else
  {
    v7 = cStr;
  }
  v10 = CFStringCreateWithCString(0, v7, 0x8000100u);
  if (!v10)
  {
    v10 = CFStringCreateWithCString(0, v7, 0x600u);
    if (!v10)
      Security::CFError::throwMe(0);
  }
LABEL_15:
  if (*(_QWORD *)this)
    CFRelease(*(CFTypeRef *)this);
  *(_QWORD *)this = v10;
  if (v16 < 0)
  {
    v11 = *(char **)cStr;
LABEL_19:
    operator delete(v11);
  }
  return this;
}

void sub_18AA42A6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  const void **v17;

  Security::CFRef<void const*>::~CFRef(v17);
  _Unwind_Resume(a1);
}

uint64_t Security::ModuleNexus<Security::CodeSigning::Fragments>::operator()()
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EDF7B2F0);
  if (!Security::CodeSigning::fragments)
    Security::CodeSigning::fragments = Security::ModuleNexusCommon::create((Security::ModuleNexusCommon *)&Security::CodeSigning::fragments, (void *(*)(void))Security::ModuleNexus<Security::CodeSigning::Fragments>::make);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EDF7B2F0);
  return Security::CodeSigning::fragments;
}

void sub_18AA42AF8(void *a1)
{
  __cxa_begin_catch(a1);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EDF7B2F0);
  __cxa_rethrow();
}

void sub_18AA42B10(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::Fragments::evalNamed(uint64_t a1, const char *a2, uint64_t a3, const Security::CodeSigning::Requirement::Context *a4)
{
  size_t v8;
  std::string *v9;
  const std::string::value_type *v10;
  std::string::size_type v11;
  std::string *v12;
  Security::UnixError *v13;
  _QWORD *v14;
  uint64_t **v15;
  uint64_t **v16;
  char v17;
  _QWORD *v18;
  const __CFData *v19;
  __CFBundle *v20;
  const __CFString *v21;
  const __CFURL *v22;
  const __CFString *File;
  const UInt8 *BytePtr;
  unint64_t Length;
  unsigned int v26;
  const char *v27;
  std::string *v28;
  uint64_t *v29;
  uint64_t **v30;
  uint64_t **v31;
  _QWORD *v32;
  char *v33;
  std::string *v34;
  uint64_t v35;
  uint64_t *v36;
  Security::CodeSigning::Requirement *v37;
  CFStringRef subDirName;
  std::string v40;
  __CFURL *v41;
  CFDataRef theData;
  uint64_t v43;
  unint64_t v44;
  std::string __p;
  std::string v46;

  if (*(char *)(a3 + 23) >= 0)
    v8 = *(unsigned __int8 *)(a3 + 23);
  else
    v8 = *(_QWORD *)(a3 + 8);
  memset(&v46, 170, sizeof(v46));
  v9 = &v46;
  std::string::basic_string[abi:ne180100]((uint64_t)&v46, v8 + 2);
  if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v9 = (std::string *)v46.__r_.__value_.__r.__words[0];
  if (v8)
  {
    if (*(char *)(a3 + 23) >= 0)
      v10 = (const std::string::value_type *)a3;
    else
      v10 = *(const std::string::value_type **)a3;
    memmove(v9, v10, v8);
  }
  strcpy((char *)v9 + v8, "!!");
  v11 = strlen(a2);
  v12 = std::string::append(&v46, a2, v11);
  __p = *v12;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v46.__r_.__value_.__l.__data_);
  v43 = a1 + 8;
  v44 = 0xAAAAAAAAAAAAAAAALL;
  v13 = (Security::UnixError *)pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if ((_DWORD)v13)
    Security::UnixError::throwMe(v13);
  LOBYTE(v44) = 1;
  v15 = (uint64_t **)(a1 + 80);
  v14 = *(_QWORD **)(a1 + 80);
  if (v14)
  {
    v16 = (uint64_t **)(a1 + 80);
    do
    {
      v17 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v14 + 4, &__p);
      if (v17 >= 0)
        v18 = v14;
      else
        v18 = v14 + 1;
      if (v17 >= 0)
        v16 = (uint64_t **)v14;
      v14 = (_QWORD *)*v18;
    }
    while (*v18);
    if (v16 != v15
      && (std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&__p, v16 + 4) & 0x80) == 0)
    {
      v19 = (const __CFData *)v16[7];
      goto LABEL_58;
    }
  }
  v41 = (__CFURL *)0xAAAAAAAAAAAAAAAALL;
  theData = 0;
  v20 = *(__CFBundle **)a1;
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&v40, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    v40 = *(std::string *)a3;
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)&v46, (char *)&v40);
  v21 = (const __CFString *)v46.__r_.__value_.__r.__words[0];
  Security::CFTempString::CFTempString<char const*>(&subDirName, a2);
  v41 = CFBundleCopyResourceURL(v20, v21, CFSTR("csreq"), subDirName);
  Security::CFRef<__CFString const*>::~CFRef((const void **)&subDirName);
  Security::CFRef<__CFString const*>::~CFRef((const void **)&v46.__r_.__value_.__l.__data_);
  if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v40.__r_.__value_.__l.__data_);
  if (v41)
  {
    subDirName = (CFStringRef)0xAAAAAAAAAAAAAAAALL;
    File = (const __CFString *)Security::cfLoadFile(v41, v22);
    subDirName = File;
    if (File)
    {
      BytePtr = CFDataGetBytePtr((CFDataRef)File);
      Length = CFDataGetLength((CFDataRef)subDirName);
      if (Length >= 0xC)
      {
        if (*(_DWORD *)BytePtr == 843514 && (v26 = bswap32(*((_DWORD *)BytePtr + 1)), v26 > 0xB))
        {
          if (Length == v26)
          {
            Security::CFRef<__CFData const*>::operator=((CFTypeRef *)&theData, (CFTypeRef *)&subDirName);
            goto LABEL_43;
          }
        }
        else
        {
          *__error() = 22;
        }
      }
      Security::cfString((Security *)&v46, v41);
      if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v28 = &v46;
      else
        v28 = (std::string *)v46.__r_.__value_.__r.__words[0];
      Security::Syslog::warning((Security::Syslog *)"Invalid sub-requirement at %s", v27, v28);
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v46.__r_.__value_.__l.__data_);
    }
LABEL_43:
    Security::CFRef<__CFData const*>::~CFRef((const void **)&subDirName);
  }
  Security::CFRef<__CFURL const*>::~CFRef((const void **)&v41);
  v29 = *v15;
  v30 = (uint64_t **)(a1 + 80);
  v31 = (uint64_t **)(a1 + 80);
  if (*v15)
  {
    while (1)
    {
      while (1)
      {
        v30 = (uint64_t **)v29;
        v32 = v29 + 4;
        if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(&__p, v29 + 4) & 0x80) == 0)
          break;
        v29 = *v30;
        v31 = v30;
        if (!*v30)
          goto LABEL_50;
      }
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v32, &__p) & 0x80) == 0)
        break;
      v31 = v30 + 1;
      v29 = v30[1];
      if (!v29)
        goto LABEL_50;
    }
    v33 = (char *)v30;
  }
  else
  {
LABEL_50:
    v46.__r_.__value_.__r.__words[2] = 0xAAAAAAAAAAAAAAAALL;
    v33 = (char *)operator new(0x40uLL);
    v46.__r_.__value_.__r.__words[0] = (std::string::size_type)v33;
    v46.__r_.__value_.__l.__size_ = a1 + 80;
    v46.__r_.__value_.__s.__data_[16] = 0;
    v34 = (std::string *)(v33 + 32);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(v34, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else
    {
      *(_OWORD *)&v34->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *((_QWORD *)v33 + 6) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
    }
    *((_QWORD *)v33 + 7) = 0;
    v46.__r_.__value_.__s.__data_[16] = 1;
    *(_QWORD *)v33 = 0;
    *((_QWORD *)v33 + 1) = 0;
    *((_QWORD *)v33 + 2) = v30;
    *v31 = (uint64_t *)v33;
    v35 = **(_QWORD **)(a1 + 72);
    v36 = (uint64_t *)v33;
    if (v35)
    {
      *(_QWORD *)(a1 + 72) = v35;
      v36 = *v31;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 80), v36);
    ++*(_QWORD *)(a1 + 88);
    v46.__r_.__value_.__r.__words[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,Security::CFRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,Security::CFRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v46);
  }
  Security::CFRef<__CFData const*>::operator=((CFTypeRef *)v33 + 7, (CFTypeRef *)&theData);
  v19 = theData;
  Security::CFRef<__CFData const*>::~CFRef((const void **)&theData);
LABEL_58:
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&v43);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v19)
      goto LABEL_60;
  }
  else if (v19)
  {
LABEL_60:
    v37 = (Security::CodeSigning::Requirement *)CFDataGetBytePtr(v19);
    return Security::CodeSigning::Requirement::validates(v37, a4, -67050);
  }
  return 0;
}

void sub_18AA42F9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, int a19, const void *a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;

  std::unique_ptr<std::__tree_node<std::__value_type<std::string,Security::CFRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,Security::CFRef<__CFData const*>>,void *>>>>::reset[abi:ne180100](v30 - 88);
  Security::CFRef<__CFData const*>::~CFRef(&a20);
  Security::StLock<Security::Mutex,&Security::Mutex::lock,&Security::Mutex::unlock>::~StLock((uint64_t)&a21);
  if (a30 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,Security::CFRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,Security::CFRef<__CFData const*>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,Security::CFRef<__CFData const*>>,0>((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,Security::CFRef<__CFData const*>>,0>(uint64_t a1)
{
  Security::CFRef<__CFData const*>::~CFRef((const void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t Security::ModuleNexus<Security::CodeSigning::Fragments>::make()
{
  uint64_t v0;

  v0 = operator new();
  Security::Mutex::Mutex((pthread_mutex_t *)(v0 + 8));
  *(_QWORD *)(v0 + 88) = 0;
  *(_QWORD *)(v0 + 80) = 0;
  *(_QWORD *)(v0 + 72) = v0 + 80;
  *(_QWORD *)v0 = SecFrameworkGetBundle();
  return v0;
}

void sub_18AA43150(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x1020C4000DB49F0);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::Requirement::Interpreter::Match::operator()(uint64_t a1, const __CFString *a2)
{
  CFTypeID v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  const void *ValueAtIndex;
  CFTypeID v9;
  CFTypeID v10;
  CFTypeID v11;
  const __CFDate *v12;
  uint64_t result;
  CFTypeID v15;
  CFTypeID v16;
  const __CFString *v17;
  CFRange v18;
  const __CFString *v19;
  const __CFString *v20;
  CFTypeID v21;
  CFTypeID v22;
  const __CFString *v23;
  CFIndex Length;
  CFIndex v25;
  CFTypeID v26;
  CFTypeID v27;
  const __CFString *v28;
  const __CFString *v29;
  CFTypeRef *v30;
  const __CFString *v31;
  uint64_t v32;
  CFComparisonResult v33;
  CFComparisonResult v34;

  if (!a2)
    return 0;
  if ((const __CFString *)*MEMORY[0x1E0C9B0D0] == a2)
  {
    return *(_DWORD *)(a1 + 8) == 14;
  }
  else
  {
    v4 = CFGetTypeID(a2);
    if (v4 == CFArrayGetTypeID() && (Count = CFArrayGetCount((CFArrayRef)a2), Count >= 1))
    {
      v6 = Count;
      v7 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v7);
        if ((Security::CodeSigning::Requirement::Interpreter::Match::operator()(a1, ValueAtIndex) & 1) != 0)
          return 1;
        if (v6 == ++v7)
          goto LABEL_8;
      }
    }
    else
    {
LABEL_8:
      switch(*(_DWORD *)(a1 + 8))
      {
        case 0:
          return CFEqual(a2, (CFTypeRef)*MEMORY[0x1E0C9AE40]) == 0;
        case 1:
          return CFEqual(a2, *(CFTypeRef *)a1) != 0;
        case 2:
          v15 = CFGetTypeID(*(CFTypeRef *)a1);
          if (v15 != CFStringGetTypeID())
            return 0;
          v16 = CFGetTypeID(a2);
          if (v16 != CFStringGetTypeID())
            return 0;
          v17 = (const __CFString *)Security::CodeSigning::Requirement::Interpreter::Match::cfStringValue((CFTypeRef *)a1);
          v18.length = CFStringGetLength(a2);
          v19 = a2;
          v20 = v17;
          goto LABEL_29;
        case 3:
          v26 = CFGetTypeID(*(CFTypeRef *)a1);
          if (v26 != CFStringGetTypeID())
            return 0;
          v27 = CFGetTypeID(a2);
          if (v27 != CFStringGetTypeID())
            return 0;
          v28 = (const __CFString *)Security::CodeSigning::Requirement::Interpreter::Match::cfStringValue((CFTypeRef *)a1);
          v29 = (const __CFString *)Security::CodeSigning::Requirement::Interpreter::Match::cfStringValue((CFTypeRef *)a1);
          v18.length = CFStringGetLength(v29);
          v19 = a2;
          v20 = v28;
LABEL_29:
          v18.location = 0;
          return CFStringFindWithOptions(v19, v20, v18, 0, 0) != 0;
        case 4:
          v21 = CFGetTypeID(*(CFTypeRef *)a1);
          if (v21 != CFStringGetTypeID())
            return 0;
          v22 = CFGetTypeID(a2);
          if (v22 != CFStringGetTypeID())
            return 0;
          v23 = (const __CFString *)Security::CodeSigning::Requirement::Interpreter::Match::cfStringValue((CFTypeRef *)a1);
          Length = CFStringGetLength(v23);
          v25 = CFStringGetLength(a2) - Length;
          if (v25 < 0)
            return 0;
          v20 = (const __CFString *)Security::CodeSigning::Requirement::Interpreter::Match::cfStringValue((CFTypeRef *)a1);
          v19 = a2;
          v18.location = v25;
          v18.length = Length;
          return CFStringFindWithOptions(v19, v20, v18, 0, 0) != 0;
        case 5:
          v30 = (CFTypeRef *)a1;
          v31 = a2;
          v32 = -1;
          goto LABEL_36;
        case 6:
          v30 = (CFTypeRef *)a1;
          v31 = a2;
          v32 = 1;
LABEL_36:
          v33 = kCFCompareGreaterThan;
          goto LABEL_40;
        case 7:
          v30 = (CFTypeRef *)a1;
          v31 = a2;
          v32 = 1;
          goto LABEL_39;
        case 8:
          v30 = (CFTypeRef *)a1;
          v31 = a2;
          v32 = -1;
LABEL_39:
          v33 = kCFCompareEqualTo;
LABEL_40:
          result = Security::CodeSigning::Requirement::Interpreter::Match::inequality(v30, v31, v32, v33);
          break;
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
          v9 = CFGetTypeID(*(CFTypeRef *)a1);
          if (v9 == CFDateGetTypeID())
          {
            v10 = CFGetTypeID(a2);
            if (v10 == CFDateGetTypeID())
            {
              v11 = CFGetTypeID(*(CFTypeRef *)a1);
              if (v11 == CFDateGetTypeID())
                v12 = *(const __CFDate **)a1;
              else
                v12 = 0;
              v34 = CFDateCompare((CFDateRef)a2, v12, 0);
              switch(*(_DWORD *)(a1 + 8))
              {
                case 9:
                  return v34 == kCFCompareEqualTo;
                case 0xA:
                  return (unint64_t)v34 >> 63;
                case 0xB:
                  return v34 > kCFCompareEqualTo;
                case 0xC:
                  return v34 < kCFCompareGreaterThan;
                case 0xD:
                  return v34 >= kCFCompareEqualTo;
                default:
                  abort();
              }
            }
          }
          return 0;
        default:
          return 0;
      }
    }
  }
  return result;
}

CFTypeRef Security::CodeSigning::Requirement::Interpreter::Match::cfStringValue(CFTypeRef *this)
{
  CFTypeID v2;

  v2 = CFGetTypeID(*this);
  if (v2 == CFStringGetTypeID())
    return *this;
  else
    return 0;
}

BOOL Security::CodeSigning::Requirement::Interpreter::Match::inequality(CFTypeRef *this, const __CFString *a2, uint64_t a3, CFComparisonResult a4)
{
  int v4;
  CFTypeID v8;
  CFTypeID v9;
  const __CFString *v10;
  _BOOL8 result;

  v4 = a4;
  v8 = CFGetTypeID(*this);
  result = 0;
  if (v8 == CFStringGetTypeID())
  {
    v9 = CFGetTypeID(a2);
    if (v9 == CFStringGetTypeID())
    {
      v10 = (const __CFString *)Security::CodeSigning::Requirement::Interpreter::Match::cfStringValue(this);
      if ((CFStringCompare(a2, v10, 0x40uLL) == a3) == v4)
        return 1;
    }
  }
  return result;
}

void sub_18AA43768(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18AA43704);
}

void sub_18AA437A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  const void **v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  Security::CFRef<__CFArray *>::~CFRef(v9);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__14572(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

const void **__Block_byref_object_dispose__14573(uint64_t a1)
{
  return Security::CFRef<__CFArray *>::~CFRef((const void **)(a1 + 40));
}

void ___ZN8Security11CodeSigning11Requirement11Interpreter27getAdditionalTrustedAnchorsEv_block_invoke(uint64_t a1, CFDictionaryRef theDict)
{
  CFTypeID v4;
  const void *Value;
  CFTypeID v6;

  if (theDict || (v4 = CFGetTypeID(0), v4 == CFDictionaryGetTypeID()))
  {
    Value = CFDictionaryGetValue(theDict, CFSTR("certDigest"));
    if (Value || (v6 = CFGetTypeID(0), v6 == CFDataGetTypeID()))
      CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), Value);
  }
}

_QWORD *Security::CodeSigning::Requirement::Maker::require(_QWORD *this, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  size_t v6;

  v2 = *((unsigned int *)this + 2);
  v3 = *((unsigned int *)this + 3) + a2;
  if (v3 > v2)
  {
    v4 = this;
    v5 = (2 * v2);
    if (v3 <= v5)
      v6 = v5;
    else
      v6 = v3;
    *((_DWORD *)this + 2) = v6;
    this = malloc_type_realloc((void *)*this, v6, 0xE7A31E20uLL);
    *v4 = this;
    if (!this)
      Security::UnixError::throwMe((Security::UnixError *)0xC);
  }
  return this;
}

uint64_t Security::CodeSigning::Requirement::Maker::alloc(Security::CodeSigning::Requirement::Maker *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int __src;

  v4 = (a2 - 1) & 0xFFFFFFFFFFFFFFFCLL;
  Security::CodeSigning::Requirement::Maker::require(this, v4 + 4);
  v5 = *(_QWORD *)this;
  v6 = *((unsigned int *)this + 3);
  v7 = v6 + *(_QWORD *)this;
  v8 = (v6 + v4 + 4);
  *((_DWORD *)this + 3) = v8;
  __src = 0;
  memcpy((void *)(a2 - v4 + v5 + v8 - 4), &__src, v4 + 4 - a2);
  return v7;
}

void *Security::CodeSigning::Requirement::Maker::putData(Security::CodeSigning::Requirement::Maker *this, const void *a2, size_t a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;

  Security::CodeSigning::Requirement::Maker::require(this, 4);
  v6 = *(_QWORD *)this;
  v7 = *((unsigned int *)this + 3);
  *((_DWORD *)this + 3) = v7 + 4;
  *(_DWORD *)(v7 + v6) = bswap32(a3);
  v8 = (void *)Security::CodeSigning::Requirement::Maker::alloc(this, a3);
  return memcpy(v8, a2, a3);
}

void Security::CodeSigning::SecCodeSigner::Signer::sdkPath(uint64_t a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  const __CFURL *v5;
  int v6;
  const std::string::value_type *v7;
  std::string::size_type v8;
  std::string *v9;
  std::string v10;

  v5 = *(const __CFURL **)(*(_QWORD *)(a1 + 8) + 112);
  if (v5)
  {
    Security::cfString((Security *)&v10, v5);
    v6 = *(char *)(a2 + 23);
    if (v6 >= 0)
      v7 = (const std::string::value_type *)a2;
    else
      v7 = *(const std::string::value_type **)a2;
    if (v6 >= 0)
      v8 = *(unsigned __int8 *)(a2 + 23);
    else
      v8 = *(_QWORD *)(a2 + 8);
    v9 = std::string::append(&v10, v7, v8);
    *a3 = *v9;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v10.__r_.__value_.__l.__data_);
  }
  else if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a3, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&a3->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    a3->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 16);
  }
}

void sub_18AA43A60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL Security::CodeSigning::SecCodeSigner::Signer::isAdhoc(Security::CodeSigning::SecCodeSigner::Signer *this)
{
  return *(_QWORD *)(*((_QWORD *)this + 1) + 24) == *MEMORY[0x1E0C9B0D0];
}

uint64_t Security::CodeSigning::SecCodeSigner::Signer::signingFlags(Security::CodeSigning::SecCodeSigner::Signer *this)
{
  return *(unsigned int *)(*((_QWORD *)this + 1) + 16);
}

uint64_t Security::CodeSigning::SecCodeSigner::Signer::digestAlgorithms(Security::CodeSigning::SecCodeSigner::Signer *this)
{
  return (uint64_t)this + 112;
}

void Security::CodeSigning::SecCodeSigner::Signer::setDigestAlgorithms(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a1 + 112;
  if (v2 != a2)
    std::__tree<unsigned int>::__assign_multi<std::__tree_const_iterator<unsigned int,std::__tree_node<unsigned int,void *> *,long>>(v2, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
}

void std::__tree<unsigned int>::__assign_multi<std::__tree_const_iterator<unsigned int,std::__tree_node<unsigned int,void *> *,long>>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  _QWORD *v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t **v15;
  uint64_t **v16;
  _QWORD *v17;
  BOOL v18;
  uint64_t *i;
  uint64_t *v20;
  uint64_t **v21;
  uint64_t *v22;
  unsigned int v23;
  uint64_t *v24;
  uint64_t **v25;
  uint64_t **v26;
  _QWORD *v27;
  _QWORD *v28;

  if (*(_QWORD *)(a1 + 16))
  {
    v6 = *(uint64_t **)a1;
    v8 = (uint64_t **)(a1 + 8);
    v7 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)a1 = a1 + 8;
    *(_QWORD *)(v7 + 16) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    if (v6[1])
      v9 = (uint64_t *)v6[1];
    else
      v9 = v6;
    if (!v9)
    {
      v20 = 0;
LABEL_29:
      std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v20);
      goto LABEL_30;
    }
    v10 = std::__tree<unsigned int>::_DetachedTreeCache::__detach_next((uint64_t)v9);
    if (a2 != a3)
    {
      v11 = v9;
      v12 = a2;
      do
      {
        v9 = v10;
        v13 = *((_DWORD *)v12 + 7);
        *((_DWORD *)v11 + 7) = v13;
        v14 = *v8;
        v15 = (uint64_t **)(a1 + 8);
        v16 = (uint64_t **)(a1 + 8);
        if (*v8)
        {
          do
          {
            while (1)
            {
              v15 = (uint64_t **)v14;
              if (v13 >= *((_DWORD *)v14 + 7))
                break;
              v14 = (uint64_t *)*v14;
              v16 = v15;
              if (!*v15)
                goto LABEL_14;
            }
            v14 = (uint64_t *)v14[1];
          }
          while (v14);
          v16 = v15 + 1;
        }
LABEL_14:
        std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v15, v16, v11);
        if (v10)
          v10 = std::__tree<unsigned int>::_DetachedTreeCache::__detach_next((uint64_t)v10);
        else
          v10 = 0;
        v17 = (_QWORD *)v12[1];
        if (v17)
        {
          do
          {
            a2 = v17;
            v17 = (_QWORD *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            a2 = (_QWORD *)v12[2];
            v18 = *a2 == (_QWORD)v12;
            v12 = a2;
          }
          while (!v18);
        }
        if (!v9)
          break;
        v11 = v9;
        v12 = a2;
      }
      while (a2 != a3);
    }
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v9);
    if (v10)
    {
      for (i = (uint64_t *)v10[2]; i; i = (uint64_t *)i[2])
        v10 = i;
      v20 = v10;
      goto LABEL_29;
    }
  }
LABEL_30:
  if (a2 != a3)
  {
    v21 = (uint64_t **)(a1 + 8);
    do
    {
      v22 = (uint64_t *)operator new(0x20uLL);
      v23 = *((_DWORD *)a2 + 7);
      *((_DWORD *)v22 + 7) = v23;
      v24 = *v21;
      v25 = (uint64_t **)(a1 + 8);
      v26 = (uint64_t **)(a1 + 8);
      if (*v21)
      {
        do
        {
          while (1)
          {
            v25 = (uint64_t **)v24;
            if (v23 >= *((_DWORD *)v24 + 7))
              break;
            v24 = (uint64_t *)*v24;
            v26 = v25;
            if (!*v25)
              goto LABEL_38;
          }
          v24 = (uint64_t *)v24[1];
        }
        while (v24);
        v26 = v25 + 1;
      }
LABEL_38:
      std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at((uint64_t **)a1, (uint64_t)v25, v26, v22);
      v27 = (_QWORD *)a2[1];
      if (v27)
      {
        do
        {
          v28 = v27;
          v27 = (_QWORD *)*v27;
        }
        while (v27);
      }
      else
      {
        do
        {
          v28 = (_QWORD *)a2[2];
          v18 = *v28 == (_QWORD)a2;
          a2 = v28;
        }
        while (!v18);
      }
      a2 = v28;
    }
    while (v28 != a3);
  }
}

_QWORD *std::__tree<unsigned int>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  _QWORD *result;
  _QWORD *v3;
  _QWORD *v4;

  result = *(_QWORD **)(a1 + 16);
  if (result)
  {
    v3 = (_QWORD *)*result;
    if (*result == a1)
    {
      *result = 0;
      while (1)
      {
        v4 = (_QWORD *)result[1];
        if (!v4)
          break;
        do
        {
          result = v4;
          v4 = (_QWORD *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; v3 = (_QWORD *)result[1])
      {
        do
        {
          result = v3;
          v3 = (_QWORD *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

void Security::CodeSigning::SecCodeSigner::Signer::sign(Security::CodeSigning::SecCodeSigner::Signer *this, int a2)
{
  uint64_t v4;
  __int128 v5;
  const void *v6;
  _QWORD *v7;
  NSObject *v8;
  NSObject *v9;
  Security::MacOSError *v10;
  NSObject *v11;
  __SecTrust *v12;
  CFArrayRef Copy;
  uint64_t v14;
  __SecTrust *v15;
  Security::MacOSError *v16;
  const __CFString *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  const std::string *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void **v25;
  unsigned __int8 *v26;
  size_t v27;
  uint64_t v28;
  unsigned __int8 *v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  unsigned int *v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  unsigned int *v40;
  unsigned int v41;
  _QWORD *v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  char *v49;
  int v50;
  const Security::CodeSigning::CodeDirectory *v51;
  _QWORD *v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  __SecTrust *v56;
  const Security::CodeSigning::CodeDirectory *v57;
  unsigned int *v58;
  unsigned int *v59;
  _QWORD *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  BOOL v67;
  uint64_t v68;
  unsigned int v69;
  unsigned int v70;
  BOOL v71;
  unsigned int v72;
  _QWORD *v73;
  Security::MachO *v74;
  unsigned int v75;
  uint64_t *v76;
  uint64_t v77;
  unint64_t v78;
  int v79;
  int v80;
  BOOL v81;
  _BOOL4 v82;
  int v83;
  _QWORD *v84;
  _QWORD *v85;
  uint64_t *v86;
  unsigned int v87;
  unsigned int v88;
  char *v89;
  Security::BlobWrapper *BytePtr;
  CFIndex Length;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  _QWORD *v98;
  _QWORD *v99;
  _QWORD *v100;
  uint64_t **v101;
  __CFDictionary *v102;
  uint64_t v103;
  CFMutableArrayRef v104;
  const Security::CodeSigning::CodeDirectory *v105;
  Security::BlobWrapper *v106;
  CFIndex v107;
  uint64_t *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  _DWORD *v116;
  _QWORD *v117;
  _QWORD *v118;
  uint64_t v119;
  NSObject *v120;
  NSObject *v121;
  uint64_t v122;
  NSObject *v123;
  const char *v124;
  Security::Universal *v125;
  _QWORD *v126;
  _QWORD *v127;
  uint64_t **v128;
  CFArrayRef v129;
  void *__p[2];
  __int128 v131;
  __int128 v132;
  __int128 v133;
  CFTypeRef cf[2];
  CFDataRef theData;
  unint64_t v136;
  __CFDictionary *v137;
  CFTypeRef v138[6];
  SecTrustRef v139;
  uint64_t v140;
  void (*v141)(uint64_t, Security::CodeSigning::CodeDirectory::Builder *);
  void *v142;
  unsigned int *v143;
  SecTrustRef trust;
  uint64_t v145;
  uint64_t (*v146)(uint64_t, uint64_t);
  const Security::CodeSigning::CodeDirectory *v147;
  Security::CodeSigning::SecCodeSigner::Signer *v148;
  uint64_t v149;
  unsigned int v150;
  BOOL v151;
  void *v152[2];
  char v153;
  _QWORD buf[4];
  _BYTE certificates[32];
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  unsigned int v169[4];
  __int128 v170;
  __int128 v171;
  __int128 v172;
  unint64_t v173;
  uint64_t v174;

  v174 = *MEMORY[0x1E0C80C00];
  v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 2) + 32) + 16))(*(_QWORD *)(*((_QWORD *)this + 2) + 32));
  v127 = (_QWORD *)((char *)this + 24);
  Security::RefPointer<Security::CodeSigning::DiskRep>::setPointer((_QWORD *)this + 3, v4);
  Security::CodeSigning::SecCodeSigner::Signer::prepare(this, a2);
  *(_QWORD *)&v5 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)cf = v5;
  v133 = v5;
  v132 = v5;
  v131 = v5;
  *(_OWORD *)__p = v5;
  v129 = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, (char *)&unk_18AA61AAF);
  *((_QWORD *)&v131 + 1) = 0;
  *(_QWORD *)&v132 = 0;
  *(_QWORD *)((char *)&v132 + 5) = 0;
  v133 = 0u;
  *(_OWORD *)cf = 0u;
  v6 = (const void *)*((_QWORD *)this + 42);
  v7 = (_QWORD *)MEMORY[0x1E0C9B0D0];
  if (!v6)
  {
    if (*(_QWORD *)(*((_QWORD *)this + 1) + 24) == *MEMORY[0x1E0C9B0D0])
      goto LABEL_19;
    v9 = secLogObjForScope("signer");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      v119 = *(_QWORD *)(*((_QWORD *)this + 1) + 24);
      *(_DWORD *)certificates = 138412290;
      *(_QWORD *)&certificates[4] = v119;
      _os_log_debug_impl(&dword_18A900000, v9, OS_LOG_TYPE_DEBUG, "looking at identity to create cert chain: %@", certificates, 0xCu);
    }
    *(_QWORD *)certificates = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 24) + 16);
    CFRetain(*(CFTypeRef *)certificates);
    *(_QWORD *)v169 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)v169 = SecPolicyCreateWithProperties(CFSTR("1.2.840.113635.100.1.16"), 0);
    trust = 0;
    v10 = (Security::MacOSError *)SecTrustCreateWithCertificates(*(CFTypeRef *)certificates, *(CFTypeRef *)v169, &trust);
    if ((_DWORD)v10)
      Security::MacOSError::throwMe(v10);
    if (!SecTrustEvaluateWithError(trust, 0))
    {
      v11 = secLogObjForScope("signer");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v139) = 0;
        _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "SecTrust evaluation of signing certificate failed - not fatal", (uint8_t *)&v139, 2u);
      }
    }
    v139 = (SecTrustRef)0xAAAAAAAAAAAAAAAALL;
    v12 = SecTrustCopyCertificateChain(trust);
    v139 = v12;
    if (v12)
    {
      Copy = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v12);
      if (cf[1])
        CFRelease(cf[1]);
      cf[1] = Copy;
      if (Copy)
      {
        v129 = Copy;
        Security::CFRef<__CFArray const*>::~CFRef((const void **)&v139);
        Security::CFRef<__SecTrust *>::~CFRef((const void **)&trust);
        Security::CFRef<__SecPolicy *>::~CFRef((const void **)v169);
        Security::CFRef<__SecCertificate *>::~CFRef((const void **)certificates);
        goto LABEL_19;
      }
      v123 = secLogObjForScope("SecError");
      v122 = 4294900248;
      if (!os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
LABEL_211:
        Security::MacOSError::throwMe((Security::MacOSError *)v122);
      LOWORD(v138[0]) = 0;
      v124 = "Unable to copy certChain array";
    }
    else
    {
      v122 = 4294900225;
      v123 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
        goto LABEL_211;
      LOWORD(v138[0]) = 0;
      v124 = "Certificate chain is NULL";
    }
    _os_log_impl(&dword_18A900000, v123, OS_LOG_TYPE_DEFAULT, v124, (uint8_t *)v138, 2u);
    goto LABEL_211;
  }
  CFRetain(*((CFTypeRef *)this + 42));
  if (cf[1])
    CFRelease(cf[1]);
  cf[1] = v6;
  v8 = secLogObjForScope("signer");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)certificates = 138412290;
    *(CFTypeRef *)&certificates[4] = cf[1];
    _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "signing context setup with existing cert chain: %@", certificates, 0xCu);
  }
  v129 = (CFArrayRef)cf[1];
LABEL_19:
  if (*((char *)this + 159) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)certificates, *((const std::string::value_type **)this + 17), *((_QWORD *)this + 18));
  }
  else
  {
    *(_OWORD *)certificates = *(_OWORD *)((char *)this + 136);
    *(_QWORD *)&certificates[16] = *((_QWORD *)this + 19);
  }
  if (SBYTE7(v131) < 0)
    operator delete(__p[0]);
  *(_OWORD *)__p = *(_OWORD *)certificates;
  *(_QWORD *)&v131 = *(_QWORD *)&certificates[16];
  memset(certificates, 170, 24);
  v14 = *(_QWORD *)(*((_QWORD *)this + 1) + 24);
  if (!v14 || v14 == *v7)
    goto LABEL_34;
  *(_QWORD *)v169 = *(_QWORD *)(v14 + 16);
  CFRetain(*(CFTypeRef *)v169);
  trust = (SecTrustRef)0xAAAAAAAAAAAAAAAALL;
  v15 = (__SecTrust *)SecPolicyCreateiPhoneProfileApplicationSigning();
  trust = v15;
  if (!v15)
  {
    v120 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v139) = 0;
      _os_log_impl(&dword_18A900000, v120, OS_LOG_TYPE_DEFAULT, "Unable to create iPhoneProfileApplicationSigning SecPolicy", (uint8_t *)&v139, 2u);
    }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
  }
  v139 = 0;
  v16 = (Security::MacOSError *)SecTrustCreateWithCertificates(v129, v15, &v139);
  if ((_DWORD)v16)
    Security::MacOSError::throwMe(v16);
  if (!SecTrustEvaluateWithError(v139, 0))
  {
    Security::CFRef<__SecTrust *>::~CFRef((const void **)&v139);
    Security::CFRef<__SecPolicy *>::~CFRef((const void **)&trust);
    Security::CFRef<__SecCertificate *>::~CFRef((const void **)v169);
LABEL_34:
    std::string::basic_string[abi:ne180100]<0>(certificates, (char *)&unk_18AA61AAF);
    goto LABEL_35;
  }
  v138[0] = 0;
  v17 = (const __CFString *)SecCertificateCopySubjectAttributeValue(*(uint64_t *)v169, (uint64_t)&oidOrganizationalUnitName);
  if (v138[0])
    CFRelease(v138[0]);
  v138[0] = v17;
  if (!v17)
  {
    v121 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v121, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl(&dword_18A900000, v121, OS_LOG_TYPE_DEFAULT, "Unable to get team ID (OrganizationalUnitName) from Apple signed certificate", (uint8_t *)buf, 2u);
    }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA4ALL);
  }
  Security::cfString((std::string *)certificates, v17);
  Security::CFRef<__CFString const*>::~CFRef(v138);
  Security::CFRef<__SecTrust *>::~CFRef((const void **)&v139);
  Security::CFRef<__SecPolicy *>::~CFRef((const void **)&trust);
  Security::CFRef<__SecCertificate *>::~CFRef((const void **)v169);
LABEL_35:
  v18 = *((_QWORD *)this + 1);
  v19 = certificates[23];
  v20 = *(_QWORD *)&certificates[8];
  if (certificates[23] >= 0)
    v20 = certificates[23];
  if ((*(_BYTE *)(v18 + 140) & 0x20) != 0)
  {
    if (!v20)
      goto LABEL_72;
    v23 = *((unsigned __int8 *)this + 183);
    if ((v23 & 0x80u) == 0)
      v24 = *((unsigned __int8 *)this + 183);
    else
      v24 = *((_QWORD *)this + 21);
    if (v24 == v20)
    {
      v25 = (const void **)((char *)this + 160);
      if (certificates[23] >= 0)
        v26 = certificates;
      else
        v26 = *(unsigned __int8 **)certificates;
      if ((v23 & 0x80) != 0)
      {
        if (!memcmp(*v25, v26, *((_QWORD *)this + 21)))
          goto LABEL_72;
      }
      else
      {
        if (!*((_BYTE *)this + 183))
          goto LABEL_72;
        while (*(unsigned __int8 *)v25 == *v26)
        {
          v25 = (const void **)((char *)v25 + 1);
          ++v26;
          if (!--v23)
            goto LABEL_72;
        }
      }
    }
LABEL_196:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  }
  v21 = (const std::string *)(v18 + 224);
  if (v20)
  {
    v22 = *(unsigned __int8 *)(v18 + 247);
    if (*(char *)(v18 + 247) < 0)
    {
      if (!*(_QWORD *)(v18 + 232))
        goto LABEL_70;
    }
    else if (!*(_BYTE *)(v18 + 247))
    {
      goto LABEL_70;
    }
    v27 = *(_QWORD *)(v18 + 232);
    if ((v22 & 0x80u) == 0)
      v28 = *(unsigned __int8 *)(v18 + 247);
    else
      v28 = *(_QWORD *)(v18 + 232);
    if (v28 != v20)
      goto LABEL_196;
    v29 = *(unsigned __int8 **)certificates;
    if (certificates[23] >= 0)
      v29 = certificates;
    if ((v22 & 0x80) != 0)
    {
      if (memcmp(v21->__r_.__value_.__l.__data_, v29, v27))
        goto LABEL_196;
    }
    else if ((_DWORD)v22)
    {
      while (v21->__r_.__value_.__s.__data_[0] == *v29)
      {
        v21 = (const std::string *)((char *)v21 + 1);
        ++v29;
        if (!--v22)
          goto LABEL_70;
      }
      goto LABEL_196;
    }
LABEL_70:
    v21 = (const std::string *)certificates;
  }
  std::string::operator=((std::string *)((char *)this + 160), v21);
  v19 = certificates[23];
LABEL_72:
  if (v19 < 0)
    operator delete(*(void **)certificates);
  v30 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v30 + 249))
  {
LABEL_75:
    v173 = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)&v31 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v171 = v31;
    v172 = v31;
    *(_OWORD *)v169 = v31;
    v170 = v31;
    if (*(_QWORD *)(v30 + 32))
    {
      v32 = operator new();
      *(_DWORD *)(v32 + 8) = 0;
      *(_QWORD *)(v32 + 12) = -1;
      *(_DWORD *)(v32 + 20) = 0;
      *(_QWORD *)(v32 + 32) = 0;
      *(_QWORD *)(v32 + 24) = v32 + 32;
      *(_QWORD *)v32 = &off_1E1FC8D88;
      *(_QWORD *)(v32 + 40) = 0;
      *(_QWORD *)(v32 + 48) = this;
      Security::Mutex::Mutex((pthread_mutex_t *)&v169[2]);
    }
    else
    {
      v32 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v127 + 256))(*v127);
      Security::Mutex::Mutex((pthread_mutex_t *)&v169[2]);
      if (!v32)
      {
LABEL_87:
        *(_QWORD *)v169 = v32;
        if (*(_BYTE *)(*((_QWORD *)this + 1) + 300))
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFFCLL);
        trust = (SecTrustRef)&v145;
        v145 = 0;
        v146 = 0;
        v147 = 0;
        v42 = *(_QWORD **)(*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 24))(this);
        while (v42 != (_QWORD *)((*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 24))(this)
                                + 8))
        {
          *(_QWORD *)&v43 = 0xAAAAAAAAAAAAAAAALL;
          *((_QWORD *)&v43 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v167 = v43;
          v168 = v43;
          v165 = v43;
          v166 = v43;
          v163 = v43;
          v164 = v43;
          v161 = v43;
          v162 = v43;
          v159 = v43;
          v160 = v43;
          v157 = v43;
          v158 = v43;
          *(_OWORD *)&certificates[16] = v43;
          v156 = v43;
          *(_OWORD *)certificates = v43;
          Security::CodeSigning::CodeDirectory::Builder::Builder((Security::CodeSigning::CodeDirectory::Builder *)certificates, (Security::CodeSigning::CodeDirectory *)*((unsigned int *)v42 + 7));
          v140 = 0;
          v141 = 0;
          v139 = (SecTrustRef)&v140;
          v142 = 0;
          (*(void (**)(_QWORD, _QWORD, Security::CodeSigning::SecCodeSigner::Signer *))(**((_QWORD **)this + 3)
                                                                                                 + 208))(*((_QWORD *)this + 3), 0, this);
          Security::CodeSigning::InternalRequirements::operator()((uint64_t)&v139);
          v44 = *(_QWORD *)v169;
          if (*((_QWORD *)this + 12) && !*(_BYTE *)(*((_QWORD *)this + 1) + 250))
          {
            (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)v169 + 16))(*(_QWORD *)v169, 3, *((_QWORD *)this + 13));
            v44 = *(_QWORD *)v169;
          }
          v45 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v127 + 88))(*v127);
          v46 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v127 + 96))(*v127);
          v47 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v127 + 104))(*v127, 0);
          v48 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v127 + 112))(*v127, 0);
          (*(void (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 24))(this);
          v49 = std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>((uint64_t **)this + 29, *((_QWORD *)this + 28), (uint64_t *)this + 28);
          if ((*((_BYTE *)this + 290) & 1) != 0)
            v50 = *(_DWORD *)(*((_QWORD *)this + 1) + 296);
          else
            v50 = 0;
          Security::CodeSigning::SecCodeSigner::Signer::populate((uint64_t)this, (uint64_t)certificates, v44, (uint64_t)&v139, v45, v46, 0, v47, v48, (_QWORD *)v49 + 5, v50);
          v51 = (const Security::CodeSigning::CodeDirectory *)Security::CodeSigning::CodeDirectory::Builder::build((Security::CodeSigning::CodeDirectory::Builder *)certificates);
          if (!*(_BYTE *)(*((_QWORD *)this + 1) + 250))
            Security::CodeSigning::CodeDirectorySet::add((Security::CodeSigning::CodeDirectorySet *)&trust, v51);
          free(v142);
          Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)&v139);
          Security::CodeSigning::CodeDirectory::Builder::~Builder((Security::CodeSigning::CodeDirectory::Builder *)certificates);
          v52 = (_QWORD *)v42[1];
          v53 = v42;
          if (v52)
          {
            do
            {
              v42 = v52;
              v52 = (_QWORD *)*v52;
            }
            while (v52);
          }
          else
          {
            do
            {
              v42 = (_QWORD *)v53[2];
              v67 = *v42 == (_QWORD)v53;
              v53 = v42;
            }
            while (!v67);
          }
        }
        v54 = *((_QWORD *)this + 1);
        if (*(_QWORD *)(v54 + 32))
        {
          *(_QWORD *)certificates = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v127 + 32))(*v127);
          (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)v169 + 16))(*(_QWORD *)v169, 65537, *(_QWORD *)certificates);
          Security::CFRef<__CFData const*>::~CFRef((const void **)certificates);
          v54 = *((_QWORD *)this + 1);
        }
        if (!*(_BYTE *)(v54 + 250))
          Security::CodeSigning::CodeDirectorySet::populate((const void **)&trust, *(Security::CodeSigning::DiskRep::Writer **)v169);
        *(_QWORD *)certificates = Security::CodeSigning::CodeDirectorySet::hashDict((Security::CodeSigning::CodeDirectorySet *)&trust);
        v56 = Security::CodeSigning::CodeDirectorySet::hashList((Security::CodeSigning::CodeDirectorySet *)&trust, v55);
        v139 = v56;
        v57 = v147;
        if (!v147)
        {
          v57 = (const Security::CodeSigning::CodeDirectory *)*((_QWORD *)trust + 5);
          v147 = v57;
        }
        v138[0] = Security::CodeSigning::SecCodeSigner::Signer::signCodeDirectory(this, v57, *(const __CFDictionary **)certificates, v56);
        (*(void (**)(_QWORD, uint64_t, CFTypeRef))(**(_QWORD **)v169 + 16))(*(_QWORD *)v169, 0x10000, v138[0]);
        (*(void (**)(_QWORD))(**(_QWORD **)v169 + 48))(*(_QWORD *)v169);
        Security::CFRef<__CFData const*>::~CFRef(v138);
        Security::CFRef<__CFArray const*>::~CFRef((const void **)&v139);
        Security::CFRef<__CFDictionary const*>::~CFRef((const void **)certificates);
        Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)&trust);
        v58 = v169;
        goto LABEL_193;
      }
    }
    v40 = (unsigned int *)(v32 + 8);
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
    goto LABEL_87;
  }
  v125 = (Security::Universal *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*v127 + 80))(*v127);
  if (!v125)
  {
    v30 = *((_QWORD *)this + 1);
    goto LABEL_75;
  }
  *(_QWORD *)&v158 = 0xAAAAAAAAAAAAAAAALL;
  *(_QWORD *)&v33 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v156 = v33;
  v157 = v33;
  *(_OWORD *)certificates = v33;
  *(_OWORD *)&certificates[16] = v33;
  v34 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v127 + 256))(*v127);
  Security::Mutex::Mutex((pthread_mutex_t *)&certificates[8]);
  if (v34)
  {
    v35 = (unsigned int *)(v34 + 8);
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
  }
  *(_QWORD *)certificates = v34;
  v37 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v37 + 300))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFFCLL);
  if (*(_QWORD *)(v37 + 32))
  {
    v38 = operator new();
    v39 = (_QWORD *)(*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 24))(this);
    std::set<unsigned int>::set[abi:ne180100]((uint64_t)v169, v39);
    Security::CodeSigning::ArchEditor::ArchEditor(v38, v125, v169, 0);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)&v169[2]);
    *(_QWORD *)v38 = &off_1E1FC83F8;
    *(_QWORD *)(v38 + 64) = 0;
    *(_QWORD *)(v38 + 48) = this;
    *(_QWORD *)(v38 + 56) = v38 + 64;
    *(_QWORD *)(v38 + 96) = 0;
    *(_QWORD *)(v38 + 88) = 0;
    *(_QWORD *)(v38 + 72) = 0;
    *(_QWORD *)(v38 + 80) = v38 + 88;
  }
  else
  {
    v38 = operator new();
    v59 = *(unsigned int **)certificates;
    v60 = (_QWORD *)(*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 24))(this);
    std::set<unsigned int>::set[abi:ne180100]((uint64_t)buf, v60);
    (*(void (**)(void **__return_ptr))(*(_QWORD *)*v127 + 40))(v152);
    Security::CodeSigning::MachOEditor::MachOEditor(v38, v59, v125, buf, (__int128 *)v152);
    if (v153 < 0)
      operator delete(v152[0]);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((_QWORD *)buf[1]);
  }
  if ((*(_BYTE *)(v38 + 20) & 2) == 0 && *((_QWORD *)this + 12) && !*(_BYTE *)(*((_QWORD *)this + 1) + 250))
    (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v38 + 16))(v38, 3, *((_QWORD *)this + 13));
  v61 = *(_QWORD **)(v38 + 24);
  v126 = (_QWORD *)(v38 + 32);
  v62 = v38;
  if (v61 != (_QWORD *)(v38 + 32))
  {
    v128 = (uint64_t **)((char *)this + 264);
    do
    {
      v63 = v61[5];
      v64 = Security::Universal::architecture(v125, (const Security::Architecture *)*((unsigned int *)v61 + 8), *((_DWORD *)v61 + 9));
      v65 = *(_QWORD *)(v63 + 56);
      *(_QWORD *)(v63 + 56) = v64;
      if (v65)
        (*(void (**)(uint64_t))(*(_QWORD *)v65 + 8))(v65);
      v66 = (uint64_t *)(v63 + 48);
      v67 = *(_DWORD *)(v63 + 48) != 7 || (*((_DWORD *)this + 72) & 0x2000) == 0;
      if (!v67)
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA37);
      v68 = *(_QWORD *)(v63 + 56);
      v69 = *(_DWORD *)(*(_QWORD *)(v68 + 8) + 12);
      v70 = bswap32(v69);
      if (*(_BYTE *)(v68 + 33))
        v69 = v70;
      v71 = v69 == 2;
      if ((*((_DWORD *)this + 72) & 0x10000) != 0)
      {
        v72 = *(_DWORD *)(*((_QWORD *)this + 1) + 296);
        if (!v72)
        {
          v169[0] = -1431655766;
          if (Security::MachOBase::version((Security::MachOBase *)v68, 0, 0, v169))
            v72 = v169[0];
          else
            v72 = 0;
        }
      }
      else
      {
        v72 = 0;
      }
      (*(void (**)(_QWORD, uint64_t, Security::CodeSigning::SecCodeSigner::Signer *))(**((_QWORD **)this + 3)
                                                                                              + 208))(*((_QWORD *)this + 3), v63 + 48, this);
      Security::CodeSigning::InternalRequirements::operator()(v63 + 88);
      if ((*(_BYTE *)(v38 + 20) & 2) != 0 && *((_QWORD *)this + 12) && !*(_BYTE *)(*((_QWORD *)this + 1) + 250))
        (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v63 + 16))(v63, 3, *((_QWORD *)this + 13));
      v73 = *(_QWORD **)(*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this
                                                                                                  + 24))(this);
      while (v73 != (_QWORD *)((*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 24))(this)
                              + 8))
      {
        v75 = v72;
        if ((*((_BYTE *)this + 290) & 1) == 0)
          goto LABEL_155;
        v76 = (uint64_t *)*((_QWORD *)this + 34);
        v75 = v72;
        if (!v76)
          goto LABEL_155;
        v77 = *v66;
        v78 = HIDWORD(*v66);
        while (1)
        {
          v79 = *((_DWORD *)v76 + 8);
          v80 = *((_DWORD *)v76 + 9);
          v81 = (int)v78 < v80;
          if ((_DWORD)v77 != v79)
            v81 = (int)v77 < v79;
          if (v81)
            goto LABEL_153;
          v82 = v80 < (int)v78;
          v83 = (_DWORD)v77 == v79 ? v82 : v79 < (int)v77;
          if (v83 != 1)
            break;
          ++v76;
LABEL_153:
          v76 = (uint64_t *)*v76;
          if (!v76)
          {
LABEL_154:
            v75 = v72;
            goto LABEL_155;
          }
        }
        v86 = (uint64_t *)*((_QWORD *)std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>(v128, v77, (uint64_t *)(v63 + 48))+ 6);
        v75 = v72;
        if (v86)
        {
          v87 = *((_DWORD *)v73 + 7);
          while (1)
          {
            v88 = *((_DWORD *)v86 + 7);
            if (v87 >= v88)
            {
              if (v88 >= v87)
              {
                v89 = std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>(v128, *v66, (uint64_t *)(v63 + 48));
                v75 = *((_DWORD *)std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t **)v89 + 5, *((_DWORD *)v73 + 7), (_DWORD *)v73 + 7)+ 8);
                break;
              }
              ++v86;
            }
            v86 = (uint64_t *)*v86;
            if (!v86)
              goto LABEL_154;
          }
        }
LABEL_155:
        trust = (SecTrustRef)MEMORY[0x1E0C809B0];
        v145 = 0x40000000;
        v146 = ___ZN8Security11CodeSigning13SecCodeSigner6Signer9signMachOEPNS_9UniversalERKNS0_11Requirement7ContextE_block_invoke;
        v147 = (const Security::CodeSigning::CodeDirectory *)&__block_descriptor_tmp_39_14641;
        v148 = this;
        v149 = v63;
        v151 = v71;
        v150 = v75;
        Security::CodeSigning::ArchEditor::Arch::eachDigest(v63, (uint64_t)&trust);
        v84 = (_QWORD *)v73[1];
        v85 = v73;
        v38 = v62;
        if (v84)
        {
          do
          {
            v73 = v84;
            v84 = (_QWORD *)*v84;
          }
          while (v84);
        }
        else
        {
          do
          {
            v73 = (_QWORD *)v85[2];
            v67 = *v73 == (_QWORD)v85;
            v85 = v73;
          }
          while (!v67);
        }
      }
      if (*(_QWORD *)(*((_QWORD *)this + 1) + 32))
      {
        *(_QWORD *)v169 = 0xAAAAAAAAAAAAAAAALL;
        *(_QWORD *)v169 = Security::CodeSigning::MachORep::identificationFor(*(const void ***)(v63 + 56), v74);
        BytePtr = (Security::BlobWrapper *)CFDataGetBytePtr(*(CFDataRef *)v169);
        Length = CFDataGetLength(*(CFDataRef *)v169);
        v92 = (uint64_t *)Security::BlobWrapper::alloc(BytePtr, Length);
        Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add((uint64_t **)(v63 + 24), 0x10001u, v92);
        Security::CFRef<__CFData const*>::~CFRef((const void **)v169);
      }
      *(_QWORD *)v169 = 0;
      *(_QWORD *)&v169[2] = v169;
      *(_QWORD *)&v170 = 0x4002000000;
      *((_QWORD *)&v170 + 1) = __Block_byref_object_copy__40;
      *(_QWORD *)&v171 = __Block_byref_object_dispose__41;
      v172 = 0uLL;
      *((_QWORD *)&v171 + 1) = 0;
      v139 = (SecTrustRef)MEMORY[0x1E0C809B0];
      v140 = 0x40000000;
      v141 = ___ZN8Security11CodeSigning13SecCodeSigner6Signer9signMachOEPNS_9UniversalERKNS0_11Requirement7ContextE_block_invoke_42;
      v142 = &unk_1E1FDCEC0;
      v143 = v169;
      Security::CodeSigning::ArchEditor::Arch::eachDigest(v63, (uint64_t)&v139);
      *(_QWORD *)(v63 + 120) = Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::size((_QWORD *)(v63 + 24), (uint64_t **)(*(_QWORD *)&v169[2] + 40), *(_QWORD *)(*((_QWORD *)this + 1) + 128), v93, v94, v95, v96, v97, 0);
      _Block_object_dispose(v169, 8);
      if (*((_QWORD *)&v171 + 1))
      {
        *(_QWORD *)&v172 = *((_QWORD *)&v171 + 1);
        operator delete(*((void **)&v171 + 1));
      }
      v98 = (_QWORD *)v61[1];
      if (v98)
      {
        do
        {
          v99 = v98;
          v98 = (_QWORD *)*v98;
        }
        while (v98);
      }
      else
      {
        do
        {
          v99 = (_QWORD *)v61[2];
          v67 = *v99 == (_QWORD)v61;
          v61 = v99;
        }
        while (!v67);
      }
      v61 = v99;
    }
    while (v99 != v126);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v38 + 56))(v38);
  v100 = *(_QWORD **)(v38 + 24);
  if (v100 != v126)
  {
    do
    {
      v101 = (uint64_t **)v100[5];
      (*(void (**)(uint64_t, uint64_t **))(*(_QWORD *)v62 + 64))(v62, v101);
      *(_QWORD *)v169 = 0;
      *(_QWORD *)&v169[2] = v169;
      *(_QWORD *)&v170 = 0x4802000000;
      *((_QWORD *)&v170 + 1) = __Block_byref_object_copy__44;
      *(_QWORD *)&v171 = __Block_byref_object_dispose__45;
      v172 = 0uLL;
      *((_QWORD *)&v171 + 1) = &v172;
      v173 = 0;
      v138[0] = (CFTypeRef)MEMORY[0x1E0C809B0];
      v138[1] = (CFTypeRef)0x40000000;
      v138[2] = ___ZN8Security11CodeSigning13SecCodeSigner6Signer9signMachOEPNS_9UniversalERKNS0_11Requirement7ContextE_block_invoke_46;
      v138[3] = &unk_1E1FDCEE8;
      v138[4] = v169;
      Security::CodeSigning::ArchEditor::Arch::eachDigest((uint64_t)v101, (uint64_t)v138);
      v137 = (__CFDictionary *)0xAAAAAAAAAAAAAAAALL;
      v102 = Security::CodeSigning::CodeDirectorySet::hashDict((Security::CodeSigning::CodeDirectorySet *)(*(_QWORD *)&v169[2] + 40));
      v136 = 0xAAAAAAAAAAAAAAAALL;
      v137 = v102;
      v104 = Security::CodeSigning::CodeDirectorySet::hashList((Security::CodeSigning::CodeDirectorySet *)(*(_QWORD *)&v169[2] + 40), v103);
      theData = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
      v136 = (unint64_t)v104;
      v105 = *(const Security::CodeSigning::CodeDirectory **)(*(_QWORD *)&v169[2] + 64);
      if (!v105)
      {
        v105 = *(const Security::CodeSigning::CodeDirectory **)(*(_QWORD *)(*(_QWORD *)&v169[2] + 40) + 40);
        *(_QWORD *)(*(_QWORD *)&v169[2] + 64) = v105;
      }
      theData = Security::CodeSigning::SecCodeSigner::Signer::signCodeDirectory(this, v105, v137, v104);
      Security::CodeSigning::CodeDirectorySet::populate((const void **)(*(_QWORD *)&v169[2] + 40), (Security::CodeSigning::DiskRep::Writer *)v101);
      v106 = (Security::BlobWrapper *)CFDataGetBytePtr(theData);
      v107 = CFDataGetLength(theData);
      v108 = (uint64_t *)Security::BlobWrapper::alloc(v106, v107);
      Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add(v101 + 3, 0x10000u, v108);
      if (!*(_BYTE *)(*((_QWORD *)this + 1) + 250))
      {
        v116 = Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::make((uint64_t)(v101 + 3), v109, v110, v111, v112, v113, v114, v115);
        (*(void (**)(uint64_t, uint64_t **, _DWORD *))(*(_QWORD *)v62 + 72))(v62, v101, v116);
      }
      Security::CFRef<__CFData const*>::~CFRef((const void **)&theData);
      Security::CFRef<__CFArray const*>::~CFRef((const void **)&v136);
      Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&v137);
      _Block_object_dispose(v169, 8);
      Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)&v171 + 8);
      v117 = (_QWORD *)v100[1];
      if (v117)
      {
        do
        {
          v118 = v117;
          v117 = (_QWORD *)*v117;
        }
        while (v117);
      }
      else
      {
        do
        {
          v118 = (_QWORD *)v100[2];
          v67 = *v118 == (_QWORD)v100;
          v100 = v118;
        }
        while (!v67);
      }
      v100 = v118;
    }
    while (v118 != v126);
  }
  if (!*(_BYTE *)(*((_QWORD *)this + 1) + 250))
    (*(void (**)(uint64_t))(*(_QWORD *)v62 + 80))(v62);
  (*(void (**)(uint64_t))(*(_QWORD *)v62 + 8))(v62);
  v58 = (unsigned int *)certificates;
LABEL_193:
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(v58);
  Security::CFRef<__CFArray const*>::~CFRef(&cf[1]);
  if (SBYTE7(v131) < 0)
    operator delete(__p[0]);
}

void sub_18AA44FD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *__p,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *a62)
{
  uint64_t v62;

  if (a57 < 0)
    operator delete(__p);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((_QWORD *)a59);
  MEMORY[0x18D76FAA0](v62, 0x10B3C408FE6E862);
  Security::RefPointer<Security::CodeSigning::DiskRep::Writer>::~RefPointer(&a62);
  Security::CodeSigning::PreSigningContext::~PreSigningContext((Security::CodeSigning::PreSigningContext *)&a17);
  _Unwind_Resume(a1);
}

const void **Security::CodeSigning::SecCodeSigner::Signer::prepare(Security::CodeSigning::SecCodeSigner::Signer *this, int a2)
{
  uint64_t v3;
  const __CFData *v4;
  const __CFData *v5;
  int v6;
  void **v7;
  uint64_t v8;
  const UInt8 *v9;
  NSObject *v10;
  char *v11;
  const char *v12;
  uint64_t v13;
  size_t v14;
  size_t v15;
  _BYTE *v16;
  const void *v17;
  _BYTE *v18;
  char *v19;
  uint64_t v20;
  size_t v21;
  _BYTE *v22;
  char *v23;
  const UInt8 *BytePtr;
  CFIndex Length;
  int v26;
  std::string::size_type v27;
  const std::string::value_type *v28;
  std::string::size_type v29;
  std::string *v30;
  std::string::size_type v31;
  char v32;
  const std::string::value_type *v33;
  uint64_t v34;
  char *v35;
  _QWORD *v36;
  uint64_t v37;
  const void *v38;
  uint64_t v39;
  CFTypeRef **v40;
  CFTypeRef *v41;
  CFTypeRef *v42;
  unint64_t v43;
  uint64_t v44;
  CFTypeRef *v45;
  const void **v46;
  CFTypeRef *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  CFTypeRef v51;
  const void **v52;
  int64_t v53;
  unint64_t v54;
  CFTypeRef *v55;
  CFTypeRef *v56;
  CFTypeRef *v57;
  const void *v58;
  CFTypeRef *i;
  CFTypeRef *v60;
  const void *v61;
  const void *v62;
  const void *v63;
  const void *v64;
  uint64_t v65;
  NSObject *v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  const void *v70;
  CFTypeID v71;
  CFTypeID TypeID;
  const __CFData *v73;
  unsigned int *v74;
  uint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unsigned int v79;
  unint64_t v80;
  BOOL v81;
  const __CFNumber *v82;
  const __CFNumber *v83;
  CFTypeID v84;
  int v85;
  const char *v86;
  CFTypeID v87;
  CFIndex v88;
  __CFString *v89;
  _DWORD *v90;
  NSObject *v91;
  int v92;
  uint64_t (*v93)(_BYTE *, _BYTE *);
  int v94;
  uint64_t v95;
  std::string::size_type v96;
  CFTypeRef v97;
  const void *v98;
  const void *v99;
  CFTypeID v100;
  const __CFString *v101;
  const __CFString *v102;
  CFTypeID v103;
  std::string::size_type v104;
  _BYTE *v105;
  std::string *p_str;
  std::string *p_p;
  std::string::size_type v108;
  std::string *v109;
  const __CFURL *v110;
  std::string::size_type v111;
  std::string::value_type *v112;
  int v113;
  std::string::value_type *v114;
  char v115;
  CFTypeID v116;
  char v117;
  std::string::size_type size;
  std::string *v119;
  _BYTE *v120;
  std::string::size_type v121;
  const void *v122;
  const __CFURL *v123;
  uint64_t v124;
  uint64_t v125;
  double v126;
  const __CFNumber *v127;
  unint64_t v128;
  std::string::size_type v129;
  CFTypeRef v130;
  NSObject *v131;
  _BOOL8 v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  const void *v139;
  Security::CodeSigning::LimitedAsync *v140;
  unsigned int *v141;
  uint64_t v142;
  uint64_t *v143;
  uint64_t v144;
  uint64_t v145;
  unsigned __int8 v147;
  Security::CodeSigning::LimitedAsync *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  const void *v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  CFDataRef v163;
  __int128 v164;
  CFMutableDictionaryRef CFMutableDictionary;
  __int128 v166;
  char v167;
  CFMutableDictionaryRef v168;
  Security *v169;
  CFMutableDictionaryRef v170;
  __int128 v171;
  char v172;
  CFTypeRef *v173;
  CFDataRef Data;
  const void *v175;
  Security::Universal *v176;
  unint64_t v177;
  uint64_t v178;
  unsigned int v179;
  unsigned int v180;
  uint64_t v181;
  unsigned int v182;
  char *v183;
  uint64_t v184;
  Security::Universal *v185;
  unint64_t v186;
  uint64_t v187;
  unsigned int v188;
  unsigned int v189;
  uint64_t v190;
  unsigned int v191;
  char *v192;
  uint64_t v193;
  int v195;
  int v196;
  int v197;
  void *v198;
  size_t v199;
  _BYTE *v200;
  const char *v201;
  char **j;
  const char *v203;
  int v204;
  unint64_t v205;
  std::string::size_type v206;
  std::string::size_type v207;
  std::string *v208;
  _BYTE *v209;
  int v210;
  void *v211;
  Security *v212;
  const __CFURL *v213;
  __CFDictionary *File;
  const __CFData *v215;
  CFPropertyListRef CFDictionaryFrom;
  const void *v217;
  uint64_t v218;
  uint64_t v219;
  __int16 v220;
  void **v221;
  uint64_t *v222;
  _QWORD v223[5];
  _QWORD v224[5];
  std::string v225;
  std::string v226;
  CFTypeRef v227;
  std::string v228;
  std::string __str;
  std::string v230;
  std::string v231;
  CFTypeRef cf;
  std::string theData;
  uint64_t (*v234)(uint64_t, uint64_t);
  const void **(*v235)(uint64_t);
  unint64_t v236;
  _BYTE v237[32];
  __int128 v238;
  void *value[2];
  __int128 v240;
  __int128 v241;
  CFMutableDictionaryRef v242;
  CFMutableDictionaryRef theDict;
  std::string __p;
  void *v245;
  Security::CodeSigning::SecCodeSigner::Signer *v246;
  CFMutableDictionaryRef v247;
  _BYTE *v248;
  _BYTE *v249;
  _BYTE v250[96];
  uint64_t v251;
  CFRange v252;

  v251 = *MEMORY[0x1E0C80C00];
  if (*((_BYTE *)this + 321))
  {
    v3 = *((_QWORD *)this + 3);
    *(_OWORD *)&v250[8] = 0uLL;
    *(_QWORD *)v250 = &v250[8];
    (*(void (**)(uint64_t, _QWORD, _BYTE *, _QWORD))(*(_QWORD *)v3 + 224))(v3, 0, v250, a2 | 0x4000200u);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)&v250[8]);
  }
  Security::CodeSigning::SecStaticCode::prepareProgress(*((Security::CodeSigning::SecStaticCode **)this + 2), 0);
  cf = 0;
  *(_QWORD *)v250 = 0xAAAAAAAAAAAAAAAALL;
  v4 = (const __CFData *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 3) + 24))(*((_QWORD *)this + 3), 1);
  *(_QWORD *)v250 = v4;
  if (v4)
    cf = Security::makeCFDictionaryFrom(v4, v5);
  Security::CFRef<__CFData const*>::~CFRef((const void **)v250);
  if (!Security::CodeSigning::SecStaticCode::codeDirectory(*((Security::CodeSigning::SecStaticCode **)this + 2), 0)
    || (Security::CodeSigning::SecStaticCode::codeDirectory(*((Security::CodeSigning::SecStaticCode **)this + 2), 0)[13] & 2) != 0)
  {
    LOWORD(v6) = 0;
  }
  else
  {
    v6 = *(_DWORD *)(*((_QWORD *)this + 1) + 140);
  }
  v7 = (void **)((char *)this + 136);
  std::string::operator=((std::string *)((char *)this + 136), (const std::string *)(*((_QWORD *)this + 1) + 176));
  LODWORD(v8) = *((char *)this + 159);
  if ((v8 & 0x80000000) != 0)
  {
    if (*((_QWORD *)this + 18))
      goto LABEL_17;
  }
  else if (*((_BYTE *)this + 159))
  {
    goto LABEL_17;
  }
  if ((v6 & 1) != 0)
  {
    v9 = Security::CodeSigning::SecStaticCode::codeDirectory(*((Security::CodeSigning::SecStaticCode **)this + 2), 1);
    std::string::basic_string[abi:ne180100]<0>(v250, (char *)&v9[bswap32(*((_DWORD *)v9 + 5))]);
    if (*((char *)this + 159) < 0)
      operator delete(*v7);
    *(_OWORD *)v7 = *(_OWORD *)v250;
    *((_QWORD *)this + 19) = *(_QWORD *)&v250[16];
    LOBYTE(v8) = *((_BYTE *)this + 159);
  }
LABEL_17:
  if ((v8 & 0x80) != 0)
    v8 = *((_QWORD *)this + 18);
  else
    v8 = v8;
  v221 = (void **)((char *)this + 136);
  if (v8)
  {
    v10 = secLogObjForScope("signer");
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      goto LABEL_83;
    v11 = (char *)this + 136;
    if (*((char *)this + 159) < 0)
      v11 = (char *)*v7;
    *(_DWORD *)v250 = 136315138;
    *(_QWORD *)&v250[4] = v11;
    v12 = "using explicit identifier=%s";
    goto LABEL_389;
  }
  (*(void (**)(_BYTE *__return_ptr, _QWORD, Security::CodeSigning::SecCodeSigner::Signer *))(**((_QWORD **)this + 3) + 184))(v250, *((_QWORD *)this + 3), this);
  if (*((char *)this + 159) < 0)
    operator delete(*v7);
  *(_OWORD *)v7 = *(_OWORD *)v250;
  *((_QWORD *)this + 19) = *(_QWORD *)&v250[16];
  if (std::string::find((const std::string *)((char *)this + 136), 46, 0) == -1)
  {
    v13 = *((_QWORD *)this + 1);
    if (*(char *)(v13 + 223) >= 0)
      v14 = *(unsigned __int8 *)(v13 + 223);
    else
      v14 = *(_QWORD *)(v13 + 208);
    if (*((char *)this + 159) >= 0)
      v15 = *((unsigned __int8 *)this + 159);
    else
      v15 = *((_QWORD *)this + 18);
    memset(v250, 170, 24);
    v16 = v250;
    std::string::basic_string[abi:ne180100]((uint64_t)v250, v15 + v14);
    if (v250[23] < 0)
      v16 = *(_BYTE **)v250;
    if (v14)
    {
      if (*(char *)(v13 + 223) >= 0)
        v17 = (const void *)(v13 + 200);
      else
        v17 = *(const void **)(v13 + 200);
      memmove(v16, v17, v14);
    }
    v18 = &v16[v14];
    if (v15)
    {
      if (*((char *)this + 159) >= 0)
        v19 = (char *)this + 136;
      else
        v19 = (char *)*((_QWORD *)this + 17);
      memmove(v18, v19, v15);
    }
    v18[v15] = 0;
    if (*((char *)this + 159) < 0)
      operator delete(*v7);
    *(_OWORD *)v7 = *(_OWORD *)v250;
    *((_QWORD *)this + 19) = *(_QWORD *)&v250[16];
  }
  if (std::string::find((const std::string *)((char *)this + 136), 46, 0) == -1
    && (*(unsigned int (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 8))(this))
  {
    (*(void (**)(_BYTE *__return_ptr))(**((_QWORD **)this + 3) + 192))(v250);
    if (v250[23] >= 0)
      v20 = v250[23];
    else
      v20 = *(_QWORD *)&v250[8];
    if ((v250[23] & 0x80000000) != 0)
      operator delete(*(void **)v250);
    if (!v20)
    {
      if (*((char *)this + 159) >= 0)
        v21 = *((unsigned __int8 *)this + 159);
      else
        v21 = *((_QWORD *)this + 18);
      memset(v250, 170, 24);
      std::string::basic_string[abi:ne180100]((uint64_t)v250, v21 + 1);
      if (v250[23] >= 0)
        v22 = v250;
      else
        v22 = *(_BYTE **)v250;
      if (v21)
      {
        if (*((char *)this + 159) >= 0)
          v23 = (char *)this + 136;
        else
          v23 = (char *)*((_QWORD *)this + 17);
        memmove(v22, v23, v21);
      }
      *(_WORD *)&v22[v21] = 45;
      theData.__r_.__value_.__r.__words[0] = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 32))(*((_QWORD *)this + 3));
      BytePtr = CFDataGetBytePtr((CFDataRef)theData.__r_.__value_.__l.__data_);
      Length = CFDataGetLength((CFDataRef)theData.__r_.__value_.__l.__data_);
      memset(v237, 0, 24);
      if (Length >= 1)
      {
        do
        {
          memset(&__str, 170, 3);
          v26 = *BytePtr++;
          snprintf((char *)&__str, 3uLL, "%02x", v26);
          v27 = strlen((const char *)&__str);
          std::string::append((std::string *)v237, (const std::string::value_type *)&__str, v27);
          --Length;
        }
        while (Length);
      }
      Security::CFRef<__CFData const*>::~CFRef((const void **)&theData.__r_.__value_.__l.__data_);
      if (v237[23] >= 0)
        v28 = v237;
      else
        v28 = *(const std::string::value_type **)v237;
      if (v237[23] >= 0)
        v29 = v237[23];
      else
        v29 = *(_QWORD *)&v237[8];
      v30 = std::string::append((std::string *)v250, v28, v29);
      v31 = v30->__r_.__value_.__r.__words[0];
      __p.__r_.__value_.__r.__words[0] = v30->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v30->__r_.__value_.__r.__words[1] + 7);
      v32 = HIBYTE(v30->__r_.__value_.__r.__words[2]);
      v30->__r_.__value_.__l.__size_ = 0;
      v30->__r_.__value_.__r.__words[2] = 0;
      v30->__r_.__value_.__r.__words[0] = 0;
      if (*((char *)this + 159) < 0)
        operator delete(*v221);
      *((_QWORD *)this + 17) = v31;
      *((_QWORD *)this + 18) = __p.__r_.__value_.__r.__words[0];
      *(_QWORD *)((char *)this + 151) = *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 7);
      *((_BYTE *)this + 159) = v32;
      if ((v237[23] & 0x80000000) != 0)
        operator delete(*(void **)v237);
      v7 = (void **)((char *)this + 136);
      if ((v250[23] & 0x80000000) != 0)
        operator delete(*(void **)v250);
    }
  }
  v10 = secLogObjForScope("signer");
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    v211 = v7;
    if (*((char *)this + 159) < 0)
      v211 = *v7;
    *(_DWORD *)v250 = 136315138;
    *(_QWORD *)&v250[4] = v211;
    v12 = "using default identifier=%s";
LABEL_389:
    _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, v12, v250, 0xCu);
  }
LABEL_83:
  std::string::operator=((std::string *)((char *)this + 160), (const std::string *)(*((_QWORD *)this + 1) + 224));
  if (*((char *)this + 183) < 0)
  {
    if (*((_QWORD *)this + 21))
      goto LABEL_90;
  }
  else if (*((_BYTE *)this + 183))
  {
    goto LABEL_90;
  }
  if ((v6 & 0x20) != 0)
  {
    v33 = (const std::string::value_type *)Security::CodeSigning::SecStaticCode::teamID(*((Security::CodeSigning::SecStaticCode **)this
                                                                                        + 2));
    if (v33)
      std::string::__assign_external((std::string *)((char *)this + 160), v33);
  }
LABEL_90:
  v34 = *((_QWORD *)this + 1);
  if ((Security::CodeSigning::SecCodeSigner::Signer *)((char *)this + 112) != (Security::CodeSigning::SecCodeSigner::Signer *)(v34 + 152))
    std::__tree<unsigned int>::__assign_multi<std::__tree_const_iterator<unsigned int,std::__tree_node<unsigned int,void *> *,long>>((uint64_t)this + 112, *(_QWORD **)(v34 + 152), (_QWORD *)(v34 + 160));
  if (!*((_QWORD *)this + 16) && (v6 & 0x40) != 0)
  {
    std::set<unsigned int>::set[abi:ne180100]((uint64_t)v250, (_QWORD *)(*((_QWORD *)this + 2) + 344));
    v35 = (char *)this + 120;
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*((_QWORD **)this + 15));
    v36 = *(_QWORD **)&v250[8];
    *((_QWORD *)this + 14) = *(_QWORD *)v250;
    *((_QWORD *)this + 15) = v36;
    v37 = *(_QWORD *)&v250[16];
    *((_QWORD *)this + 16) = *(_QWORD *)&v250[16];
    if (v37)
    {
      v36[2] = v35;
      *(_QWORD *)v250 = &v250[8];
      *(_OWORD *)&v250[8] = 0uLL;
      v36 = 0;
    }
    else
    {
      *((_QWORD *)this + 14) = v35;
    }
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v36);
  }
  Security::CFRef<__CFData const*>::operator=((CFTypeRef *)this + 23, (CFTypeRef *)(*((_QWORD *)this + 1) + 64));
  if (!*((_QWORD *)this + 23) && (v6 & 4) != 0)
  {
    v38 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 2) + 80))(*((_QWORD *)this + 2), 5, 4294900235);
    Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 23, v38);
  }
  v39 = *((_QWORD *)this + 1);
  v40 = (CFTypeRef **)((char *)this + 192);
  v222 = (uint64_t *)((char *)this + 112);
  if ((Security::CodeSigning::SecCodeSigner::Signer *)((char *)this + 192) == (Security::CodeSigning::SecCodeSigner::Signer *)(v39 + 80))
  {
    v45 = (CFTypeRef *)*((_QWORD *)this + 25);
  }
  else
  {
    v41 = *(CFTypeRef **)(v39 + 80);
    v42 = *(CFTypeRef **)(v39 + 88);
    v43 = v42 - v41;
    v44 = *((_QWORD *)this + 26);
    v45 = (CFTypeRef *)*((_QWORD *)this + 24);
    if (v43 <= (v44 - (uint64_t)v45) >> 3)
    {
      v52 = (const void **)*((_QWORD *)this + 25);
      v53 = (char *)v52 - (char *)v45;
      v54 = v52 - v45;
      if (v54 >= v43)
      {
        if (v41 != v42)
        {
          do
            Security::CFRef<__CFData const*>::operator=(v45++, v41++);
          while (v41 != v42);
          v52 = (const void **)*((_QWORD *)this + 25);
        }
        while (v52 != v45)
          v52 = Security::CFRef<__CFData const*>::~CFRef(v52 - 1);
      }
      else
      {
        if (v52 != v45)
        {
          v55 = v41;
          do
          {
            Security::CFRef<__CFData const*>::operator=(v45++, v55++);
            v53 -= 8;
          }
          while (v53);
          v45 = (CFTypeRef *)*((_QWORD *)this + 25);
        }
        v56 = &v41[v54];
        v57 = v45;
        if (v56 != v42)
        {
          v57 = v45;
          do
          {
            v58 = *v56++;
            *v57++ = v58;
          }
          while (v56 != v42);
        }
        v45 = v57;
      }
    }
    else
    {
      if (v45)
      {
        v46 = (const void **)*((_QWORD *)this + 25);
        v47 = (CFTypeRef *)*((_QWORD *)this + 24);
        if (v46 != v45)
        {
          do
            v46 = Security::CFRef<__CFData const*>::~CFRef(v46 - 1);
          while (v46 != v45);
          v47 = *v40;
        }
        *((_QWORD *)this + 25) = v45;
        operator delete(v47);
        v44 = 0;
        *v40 = 0;
        *((_QWORD *)this + 25) = 0;
        *((_QWORD *)this + 26) = 0;
      }
      if ((char *)v42 - (char *)v41 < 0)
        goto LABEL_411;
      v48 = v44 >> 2;
      if (v44 >> 2 <= v43)
        v48 = v42 - v41;
      v49 = (unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v48;
      if (v49 >> 61)
LABEL_411:
        std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
      v45 = (CFTypeRef *)std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>(v49);
      *((_QWORD *)this + 24) = v45;
      *((_QWORD *)this + 25) = v45;
      *((_QWORD *)this + 26) = &v45[v50];
      while (v41 != v42)
      {
        v51 = *v41++;
        *v45++ = v51;
      }
    }
    *((_QWORD *)this + 25) = v45;
  }
  for (i = *v40; i != v45; ++i)
  {
    if (*i)
      CFRetain(*i);
  }
  if ((v6 & 0x200) != 0)
  {
    v60 = *v40;
    if (!**v40 && !v60[1] && !v60[2])
    {
      v61 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 2) + 80))(*((_QWORD *)this + 2), 8, 4294900235);
      if (v61)
        Security::CFRef<__CFArray const*>::operator=(*v40, v61);
      v62 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 2) + 80))(*((_QWORD *)this + 2), 9, 4294900235);
      if (v62)
        Security::CFRef<__CFArray const*>::operator=(*v40 + 1, v62);
      v63 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 2) + 80))(*((_QWORD *)this + 2), 10, 4294900235);
      if (v63)
        Security::CFRef<__CFArray const*>::operator=(*v40 + 2, v63);
    }
  }
  Security::CFRef<__CFData const*>::operator=((CFTypeRef *)this + 27, (CFTypeRef *)(*((_QWORD *)this + 1) + 104));
  if ((v6 & 0x400) != 0 && !*((_QWORD *)this + 27))
  {
    v64 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 2) + 80))(*((_QWORD *)this + 2), 11, 4294900235);
    if (v64)
      Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 27, v64);
  }
  *((_DWORD *)this + 72) = 0;
  v65 = *((_QWORD *)this + 1);
  if (*(_BYTE *)(v65 + 144))
  {
    *((_DWORD *)this + 72) = *(_DWORD *)(v65 + 136);
    v66 = secLogObjForScope("signer");
    if (!os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
    {
LABEL_155:
      v67 = (v6 & 0x100) == 0;
      goto LABEL_156;
    }
    v195 = *((_DWORD *)this + 72);
    *(_DWORD *)v250 = 67109120;
    *(_DWORD *)&v250[4] = v195;
    v86 = "using explicit cdFlags=0x%x";
LABEL_346:
    _os_log_debug_impl(&dword_18A900000, v66, OS_LOG_TYPE_DEBUG, v86, v250, 8u);
    goto LABEL_155;
  }
  if (cf)
  {
    v82 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("CSFlags"));
    v83 = v82;
    if (v82)
    {
      v84 = CFGetTypeID(v82);
      if (v84 == CFNumberGetTypeID())
      {
        *((_DWORD *)this + 72) = Security::cfNumber<unsigned int>(v83);
        v66 = secLogObjForScope("signer");
        if (!os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
          goto LABEL_155;
        v85 = *((_DWORD *)this + 72);
        *(_DWORD *)v250 = 67109120;
        *(_DWORD *)&v250[4] = v85;
        v86 = "using numeric cdFlags=0x%x from Info.plist";
      }
      else
      {
        v116 = CFGetTypeID(v83);
        if (v116 != CFStringGetTypeID())
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ELL);
        Security::cfString(&v231, (CFStringRef)v83);
        v117 = HIBYTE(v231.__r_.__value_.__r.__words[2]);
        if ((v231.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(v231.__r_.__value_.__r.__words[2]);
        else
          size = v231.__r_.__value_.__l.__size_;
        v220 = v6;
        if (size)
        {
          if ((v231.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v119 = &v231;
          else
            v119 = (std::string *)v231.__r_.__value_.__r.__words[0];
          v120 = memchr(v119, 44, size);
          if (v120)
            v121 = v120 - (_BYTE *)v119;
          else
            v121 = -1;
        }
        else
        {
          v121 = -1;
        }
        v196 = 0;
        while (1)
        {
          memset(v250, 170, 24);
          if (v121 == -1)
          {
            if (v117 < 0)
              std::string::__init_copy_ctor_external((std::string *)v250, v231.__r_.__value_.__l.__data_, v231.__r_.__value_.__l.__size_);
            else
              *(std::string *)v250 = v231;
          }
          else
          {
            std::string::basic_string((std::string *)v250, &v231, 0, v121, (std::allocator<char> *)v237);
          }
          v197 = v250[23];
          v198 = *(void **)v250;
          if (v250[23] >= 0)
            v199 = v250[23];
          else
            v199 = *(_QWORD *)&v250[8];
          if (v250[23] >= 0)
            v200 = v250;
          else
            v200 = *(_BYTE **)v250;
          v201 = "host";
          for (j = &kSecCodeDirectoryFlagTable;
                !*((_BYTE *)j + 12) || v199 != strlen(v201) || memcmp(v200, v201, v199);
                j += 2)
          {
            v203 = j[2];
            v201 = v203;
            if (!v203)
              Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
          }
          v204 = *((_DWORD *)j + 2);
          if (v197 < 0)
            operator delete(v198);
          v196 |= v204;
          if (v121 == -1)
            break;
          std::string::basic_string((std::string *)v250, &v231, v121 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)v237);
          if (SHIBYTE(v231.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v231.__r_.__value_.__l.__data_);
          v231 = *(std::string *)v250;
          v205 = *(_QWORD *)&v250[16];
          v250[23] = 0;
          v250[0] = 0;
          v206 = HIBYTE(v205);
          v117 = v206;
          if ((v206 & 0x80u) == 0)
            v207 = v206;
          else
            v207 = v231.__r_.__value_.__l.__size_;
          if (v207)
          {
            if ((v206 & 0x80u) == 0)
              v208 = &v231;
            else
              v208 = (std::string *)v231.__r_.__value_.__r.__words[0];
            v209 = memchr(v208, 44, v207);
            if (v209)
              v121 = v209 - (_BYTE *)v208;
            else
              v121 = -1;
          }
          else
          {
            v121 = -1;
          }
        }
        *((_DWORD *)this + 72) = v196;
        if (SHIBYTE(v231.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v231.__r_.__value_.__l.__data_);
        v66 = secLogObjForScope("signer");
        LOWORD(v6) = v220;
        if (!os_log_type_enabled(v66, OS_LOG_TYPE_DEBUG))
          goto LABEL_155;
        v210 = *((_DWORD *)this + 72);
        *(_DWORD *)v250 = 67109120;
        *(_DWORD *)&v250[4] = v210;
        v86 = "using text cdFlags=0x%x from Info.plist";
      }
      goto LABEL_346;
    }
  }
  v67 = (v6 & 0x100) == 0;
  if ((v6 & 0x100) != 0)
    *((_DWORD *)this + 72) |= (*((_DWORD *)Security::CodeSigning::SecStaticCode::codeDirectory(*((Security::CodeSigning::SecStaticCode **)this + 2), 0)+ 3) << 8) & 0x10000;
  if ((v6 & 0x10) != 0)
  {
    *((_DWORD *)this + 72) = bswap32(*((_DWORD *)Security::CodeSigning::SecStaticCode::codeDirectory(*((Security::CodeSigning::SecStaticCode **)this + 2), 0)+ 3) & 0xFDFFFFFF);
    v91 = secLogObjForScope("signer");
    if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
    {
      v92 = *((_DWORD *)this + 72);
      *(_DWORD *)v250 = 67109120;
      *(_DWORD *)&v250[4] = v92;
      _os_log_debug_impl(&dword_18A900000, v91, OS_LOG_TYPE_DEBUG, "using inherited cdFlags=0x%x", v250, 8u);
    }
  }
LABEL_156:
  v68 = *((_QWORD *)this + 1);
  v69 = *MEMORY[0x1E0C9B0D0];
  if (*(_QWORD *)(v68 + 24) == *MEMORY[0x1E0C9B0D0] && !*(_BYTE *)(v68 + 301))
    *((_DWORD *)this + 72) |= 2u;
  v70 = *(const void **)(v68 + 120);
  if (v70)
  {
    v71 = CFGetTypeID(v70);
    TypeID = CFDataGetTypeID();
    v73 = *(const __CFData **)(*((_QWORD *)this + 1) + 120);
    if (v71 == TypeID)
    {
      v74 = (unsigned int *)CFDataGetBytePtr(v73);
      if (*v74 != 17620730
        || (v75 = bswap32(v74[2]), v76 = 8 * v75 + 12, v77 = bswap32(v74[1]), v76 > v77))
      {
        *__error() = 22;
LABEL_171:
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA14);
      }
      v78 = (unint64_t)&v74[2 * v75 + 3];
      while (1)
      {
        v78 -= 8;
        if (v78 < (unint64_t)(v74 + 3))
          goto LABEL_183;
        v79 = *(_DWORD *)(v78 + 4);
        if (v79)
        {
          v80 = bswap32(v79);
          v81 = v76 > v80 || v80 + 8 > v77;
          if (v81 || bswap32(*(unsigned int *)((char *)v74 + v80 + 4)) + v80 > v77)
            goto LABEL_171;
        }
      }
    }
    v87 = CFGetTypeID(v73);
    if (v87 != CFStringGetTypeID())
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
    theDict = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    theDict = (CFMutableDictionaryRef)CFStringCreateMutableCopy(0, 0, *(CFStringRef *)(*((_QWORD *)this + 1) + 120));
    v88 = CFStringGetLength((CFStringRef)theDict);
    v89 = (__CFString *)theDict;
    if (*((char *)this + 159) < 0)
    {
      std::string::__init_copy_ctor_external(&v230, *((const std::string::value_type **)this + 17), *((_QWORD *)this + 18));
    }
    else
    {
      *(_OWORD *)&v230.__r_.__value_.__l.__data_ = *(_OWORD *)v221;
      v230.__r_.__value_.__r.__words[2] = *((_QWORD *)this + 19);
    }
    Security::CFTempString::CFTempString<std::string>((CFStringRef *)v250, (char *)&v230);
    v252.location = 0;
    v252.length = v88;
    CFStringFindAndReplace(v89, CFSTR("$self.identifier"), *(CFStringRef *)v250, v252, 0);
    Security::CFRef<__CFString const*>::~CFRef((const void **)v250);
    if (SHIBYTE(v230.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v230.__r_.__value_.__l.__data_);
    Security::cfString(&__str, (CFStringRef)theDict);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&theData, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
    else
      theData = __str;
    memset(v250, 0, 24);
    v93 = *(uint64_t (**)(_BYTE *, _BYTE *))(*(_QWORD *)(Security::ModuleNexus<Security::CodeSigning::PluginHost>::operator()()
                                                                 + 72)
                                                     + 32);
    v94 = SHIBYTE(theData.__r_.__value_.__r.__words[2]);
    if (SHIBYTE(theData.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external((std::string *)v237, theData.__r_.__value_.__l.__data_, theData.__r_.__value_.__l.__size_);
    else
      *(std::string *)v237 = theData;
    v95 = v93(v237, v250);
    if ((v237[23] & 0x80000000) != 0)
      operator delete(*(void **)v237);
    if (!v95)
    {
      if ((v250[23] & 0x80000000) != 0)
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v250, *(std::string::size_type *)&v250[8]);
      else
        __p = *(std::string *)v250;
      Security::CFTempString::CFTempString<std::string>((CFStringRef *)&v228, (char *)&__p);
      Security::CodeSigning::CSError::throwMe((Security::CodeSigning::CSError *)0xFFFEFA14, (uint64_t)CFSTR("SecRequirementSyntax"), (const __CFString *)v228.__r_.__value_.__l.__data_, v217);
    }
    if ((v250[23] & 0x80000000) != 0)
    {
      operator delete(*(void **)v250);
      if ((v94 & 0x80000000) == 0)
        goto LABEL_203;
    }
    else if ((v94 & 0x80000000) == 0)
    {
LABEL_203:
      *((_QWORD *)this + 37) = v95;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
      Security::CFRef<__CFString *>::~CFRef((const void **)&theDict);
      goto LABEL_206;
    }
    operator delete(theData.__r_.__value_.__l.__data_);
    goto LABEL_203;
  }
  if ((v6 & 2) != 0)
  {
    v74 = Security::CodeSigning::SecStaticCode::internalRequirements(*((Security::CodeSigning::SecStaticCode **)this + 2));
    if (v74)
    {
LABEL_183:
      v90 = Security::BlobCore::clone((Security::BlobCore *)v74);
      *((_QWORD *)this + 37) = Security::Blob<Security::SuperBlob<4208856065u,unsigned int>,4208856065u>::specific(v90);
    }
  }
LABEL_206:
  memset(&__str, 170, sizeof(__str));
  (*(void (**)(std::string *__return_ptr))(**((_QWORD **)this + 3) + 56))(&__str);
  memset(&v228, 0, sizeof(v228));
  v227 = 0;
  v96 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v96 = __str.__r_.__value_.__l.__size_;
  if (v96)
  {
    Security::CFRef<__CFData const*>::operator=(&v227, (CFTypeRef *)(*((_QWORD *)this + 1) + 40));
    v97 = v227;
    if (!v227 && (v6 & 8) != 0)
    {
      v98 = (const void *)Security::CodeSigning::SecStaticCode::resourceDictionary(*((Security::CodeSigning::SecStaticCode **)this + 2), 0);
      v97 = v98;
      if (v98)
      {
        CFRetain(v98);
        if (v227)
          CFRelease(v227);
        v227 = v97;
        goto LABEL_219;
      }
      v97 = v227;
    }
    if (v97)
      goto LABEL_219;
    if (cf)
    {
      v101 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, (const void *)*MEMORY[0x1E0C9AAE8]);
      v102 = v101;
      if (v101)
      {
        v103 = CFGetTypeID(v101);
        if (v103 == CFStringGetTypeID())
        {
          theDict = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v104 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          else
            v104 = __str.__r_.__value_.__l.__size_;
          memset(v237, 170, 24);
          std::string::basic_string[abi:ne180100]((uint64_t)v237, v104 + 1);
          if (v237[23] >= 0)
            v105 = v237;
          else
            v105 = *(_BYTE **)v237;
          if (v104)
          {
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              p_str = &__str;
            else
              p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
            memmove(v105, p_str, v104);
          }
          *(_WORD *)&v105[v104] = 47;
          Security::cfString(&__p, v102);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            p_p = &__p;
          else
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v108 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          else
            v108 = __p.__r_.__value_.__l.__size_;
          v109 = std::string::append((std::string *)v237, (const std::string::value_type *)p_p, v108);
          v112 = (std::string::value_type *)v109->__r_.__value_.__r.__words[0];
          v111 = v109->__r_.__value_.__l.__size_;
          LODWORD(v242) = v109->__r_.__value_.__r.__words[2];
          *(_DWORD *)((char *)&v242 + 3) = *(_DWORD *)((char *)&v109->__r_.__value_.__r.__words[2] + 3);
          v113 = SHIBYTE(v109->__r_.__value_.__r.__words[2]);
          v109->__r_.__value_.__l.__size_ = 0;
          v109->__r_.__value_.__r.__words[2] = 0;
          v109->__r_.__value_.__r.__words[0] = 0;
          if (v113 < 0)
          {
            std::string::__init_copy_ctor_external((std::string *)v250, v112, v111);
            v115 = v250[23];
            v114 = *(std::string::value_type **)v250;
          }
          else
          {
            *(_QWORD *)v250 = v112;
            *(_QWORD *)&v250[8] = v111;
            *(_DWORD *)&v250[16] = (_DWORD)v242;
            *(_DWORD *)&v250[19] = *(_DWORD *)((char *)&v242 + 3);
            v250[23] = v113;
            v114 = v112;
            v115 = v113;
          }
          if (v115 >= 0)
            v212 = (Security *)v250;
          else
            v212 = (Security *)v114;
          theData.__r_.__value_.__r.__words[0] = (std::string::size_type)Security::makeCFURL(v212, 0, 0, v110);
          File = Security::cfLoadFile((Security *)theData.__r_.__value_.__l.__data_, v213);
          Security::CFRef<__CFURL const*>::~CFRef((const void **)&theData.__r_.__value_.__l.__data_);
          if ((v250[23] & 0x80000000) != 0)
            operator delete(*(void **)v250);
          theDict = File;
          if (v113 < 0)
            operator delete(v112);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p.__r_.__value_.__l.__data_);
          if ((v237[23] & 0x80000000) != 0)
            operator delete(*(void **)v237);
          if (theDict)
          {
            CFDictionaryFrom = Security::makeCFDictionaryFrom(theDict, v215);
            if (CFDictionaryFrom)
            {
              if (v227)
                CFRelease(v227);
              v227 = CFDictionaryFrom;
            }
          }
          Security::CFRef<__CFData const*>::~CFRef((const void **)&theDict);
        }
        v97 = v227;
        if (!v227)
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA13);
LABEL_219:
        v99 = CFDictionaryGetValue((CFDictionaryRef)v97, CFSTR("rules"));
        if (!v99 || (v100 = CFGetTypeID(v99), v100 != CFDictionaryGetTypeID()))
          Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA13);
        if (v227)
          goto LABEL_260;
        goto LABEL_257;
      }
      v97 = v227;
      if (v227)
        goto LABEL_219;
    }
LABEL_257:
    v122 = (const void *)(*(uint64_t (**)(_QWORD, Security::CodeSigning::SecCodeSigner::Signer *))(**((_QWORD **)this + 3) + 200))(*((_QWORD *)this + 3), this);
    if (v227)
      CFRelease(v227);
    v227 = v122;
LABEL_260:
    std::string::operator=(&v228, &__str);
    if (((*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 16))(this) & 0x40) != 0)
    {
      v123 = (const __CFURL *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 48))(*((_QWORD *)this + 3));
      Security::cfStringRelease((Security *)v250, v123);
      if (SHIBYTE(v228.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v228.__r_.__value_.__l.__data_);
      v228 = *(std::string *)v250;
    }
  }
  v124 = *((_QWORD *)this + 1);
  v125 = *(_QWORD *)(v124 + 48);
  if (v125 == v69)
  {
    *((_BYTE *)this + 320) = 0;
  }
  else if (v125)
  {
    v126 = MEMORY[0x18D76F188]();
    if (v126 > CFAbsoluteTimeGetCurrent())
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ELL);
    *((_BYTE *)this + 320) = 1;
    *((double *)this + 39) = v126;
    v124 = *((_QWORD *)this + 1);
  }
  else
  {
    *((_BYTE *)this + 320) = 1;
    *((_QWORD *)this + 39) = 0;
  }
  v127 = *(const __CFNumber **)(v124 + 256);
  if (v127)
    v128 = Security::cfNumber<unsigned long>(v127);
  else
    v128 = (*(uint64_t (**)(_QWORD, Security::CodeSigning::SecCodeSigner::Signer *))(**((_QWORD **)this + 3)
                                                                                             + 216))(*((_QWORD *)this + 3), this);
  *((_QWORD *)this + 38) = v128;
  (*(void (**)(_QWORD, Security::CodeSigning::SecCodeSigner::Signer *))(**((_QWORD **)this + 3) + 72))(*((_QWORD *)this + 3), this);
  if (!*((_QWORD *)this + 16))
  {
    std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>(v222, 1u, 1);
    std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>(v222, 2u, 2);
  }
  v129 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v129 = __str.__r_.__value_.__l.__size_;
  if (!v129)
    goto LABEL_316;
  if (SHIBYTE(v228.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(&v226, v228.__r_.__value_.__l.__data_, v228.__r_.__value_.__l.__size_);
    if ((*((_BYTE *)&__str.__r_.__value_.__s + 23) & 0x80) == 0)
      goto LABEL_280;
  }
  else
  {
    v226 = v228;
    if ((*((_BYTE *)&__str.__r_.__value_.__s + 23) & 0x80) == 0)
    {
LABEL_280:
      v225 = __str;
      goto LABEL_283;
    }
  }
  std::string::__init_copy_ctor_external(&v225, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
LABEL_283:
  v130 = v227;
  v131 = secLogObjForScope("codesign");
  v132 = os_log_type_enabled(v131, OS_LOG_TYPE_DEBUG);
  if (v132)
  {
    *(_WORD *)v250 = 0;
    _os_log_debug_impl(&dword_18A900000, v131, OS_LOG_TYPE_DEBUG, "start building resource directory", v250, 2u);
  }
  theDict = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  theDict = Security::makeCFMutableDictionary((Security *)v132);
  v139 = Security::cfget<__CFDictionary const*>(v130, (uint64_t)"rules", v133, v134, v135, v136, v137, v138, v218);
  if (!*(_QWORD *)(*((_QWORD *)this + 1) + 288))
  {
    if (((*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 16))(this) & 0x800) != 0)
    {
      v148 = (Security::CodeSigning::LimitedAsync *)operator new();
      Security::CodeSigning::LimitedAsync::LimitedAsync(v148, 0);
      *(_QWORD *)(*((_QWORD *)this + 1) + 288) = v148;
    }
    else
    {
      v140 = (Security::CodeSigning::LimitedAsync *)operator new();
      v141 = (unsigned int *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 3) + 144))(*((_QWORD *)this + 3));
      Security::UnixPlusPlus::FileDesc::mediumType((std::string *)v250, (Security::UnixPlusPlus::FileDesc *)*v141);
      v142 = v250[23];
      if (v250[23] < 0)
        v142 = *(_QWORD *)&v250[8];
      if (v142 == 11)
      {
        v143 = (uint64_t *)v250;
        if (v250[23] < 0)
          v143 = *(uint64_t **)v250;
        v144 = *v143;
        v145 = *(uint64_t *)((char *)v143 + 3);
        v147 = v144 == 0x74532064696C6F53 && v145 == 0x6574617453206469;
      }
      else
      {
        v147 = 0;
      }
      Security::CodeSigning::LimitedAsync::LimitedAsync(v140, v147);
      *(_QWORD *)(*((_QWORD *)this + 1) + 288) = v140;
      if ((v250[23] & 0x80000000) != 0)
        operator delete(*(void **)v250);
    }
  }
  if (((*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 16))(this) & 0x10) != 0)
  {
    v168 = 0;
  }
  else
  {
    theData.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
    v155 = Security::cfget<__CFDictionary const*>(v130, (uint64_t)"rules2", v149, v150, v151, v152, v153, v154, v219);
    Security::CFCopyRef<__CFDictionary const*>::CFCopyRef(&theData, v155);
    if (!theData.__r_.__value_.__r.__words[0])
    {
      v163 = Security::cfmake<__CFDictionary const*>((uint64_t)"{+%O'^(Frameworks|SharedFrameworks|PlugIns|Plug-ins|XPCServices|Helpers|MacOS|Library/(Automator|Spotlight|LoginItems))/' = {nested=#T, weight=0}}", v156, v157, v158, v159, v160, v161, v162, (uint64_t)v139);
      if (theData.__r_.__value_.__r.__words[0])
        CFRelease(theData.__r_.__value_.__l.__data_);
      theData.__r_.__value_.__r.__words[0] = (std::string::size_type)v163;
    }
    *(_QWORD *)&v164 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v164 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v250[72] = v164;
    *(_OWORD *)&v250[56] = v164;
    *(_OWORD *)&v250[40] = v164;
    *(_OWORD *)&v250[24] = v164;
    *(_OWORD *)&v250[8] = v164;
    *(_QWORD *)&v250[88] = 0xAAAAAAAAAAAAAAAALL;
    *(_QWORD *)v250 = &off_1E1FC93A0;
    Security::Mutex::Mutex((pthread_mutex_t *)&v250[8]);
    v250[72] = 0;
    *(_QWORD *)&v250[80] = 0;
    *(_QWORD *)&v250[88] = dispatch_group_create();
    v242 = (CFMutableDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableDictionary = Security::makeCFMutableDictionary(*(Security **)&v250[88]);
    v242 = CFMutableDictionary;
    *(_QWORD *)&v166 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v166 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v240 = v166;
    v241 = v166;
    v238 = v166;
    *(_OWORD *)value = v166;
    *(_OWORD *)v237 = v166;
    *(_OWORD *)&v237[16] = v166;
    v167 = *((_BYTE *)this + 321);
    *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
    Security::CodeSigning::ResourceBuilder::ResourceBuilder((std::string::size_type)v237, (uint64_t)&v226, (uint64_t)&v225, theData.__r_.__value_.__l.__data_, v167, (uint64_t)&__p);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy((_QWORD *)__p.__r_.__value_.__l.__size_);
    (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 3) + 64))(*((_QWORD *)this + 3), v237);
    __p.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
    __p.__r_.__value_.__l.__size_ = 0x40000000;
    __p.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN8Security11CodeSigning13SecCodeSigner6Signer14buildResourcesENSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEES9_PK14__CFDictionary_block_invoke;
    v245 = &__block_descriptor_tmp_26_14666;
    v246 = this;
    v247 = CFMutableDictionary;
    v248 = v250;
    v249 = v237;
    Security::CodeSigning::ResourceBuilder::scan((uint64_t)v237, (uint64_t)&__p, 0);
    Security::Dispatch::Group::wait((Security::Dispatch::Group *)v250);
    CFDictionaryAddValue(theDict, CFSTR("rules2"), value[1]);
    v168 = v242;
    CFDictionaryAddValue(theDict, CFSTR("files2"), v242);
    Security::CodeSigning::ResourceBuilder::~ResourceBuilder((Security::CodeSigning::ResourceBuilder *)v237);
    Security::CFRef<__CFDictionary *>::~CFRef((const void **)&v242);
    Security::Dispatch::Group::~Group((Security::Dispatch::Group *)v250);
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&theData.__r_.__value_.__l.__data_);
  }
  CFDictionaryAddValue(theDict, CFSTR("rules"), v139);
  v169 = (Security *)(*(uint64_t (**)(Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)this + 16))(this);
  if ((v169 & 0x20) == 0)
  {
    theData.__r_.__value_.__r.__words[0] = 0;
    theData.__r_.__value_.__l.__size_ = (std::string::size_type)&theData;
    theData.__r_.__value_.__r.__words[2] = 0x3002000000;
    v234 = __Block_byref_object_copy__14669;
    v235 = __Block_byref_object_dispose__14670;
    v236 = 0xAAAAAAAAAAAAAAAALL;
    v170 = Security::makeCFMutableDictionary(v169);
    *(_QWORD *)&v171 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v171 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v250[64] = v171;
    *(_OWORD *)&v250[80] = v171;
    *(_OWORD *)&v250[32] = v171;
    *(_OWORD *)&v250[48] = v171;
    *(_OWORD *)v250 = v171;
    *(_OWORD *)&v250[16] = v171;
    v172 = *((_BYTE *)this + 321);
    *(_OWORD *)&v237[8] = 0uLL;
    v236 = (unint64_t)v170;
    *(_QWORD *)v237 = &v237[8];
    Security::CodeSigning::ResourceBuilder::ResourceBuilder((std::string::size_type)v250, (uint64_t)&v226, (uint64_t)&v225, v139, v172, (uint64_t)v237);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)&v237[8]);
    (*(void (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 3) + 64))(*((_QWORD *)this + 3), v250);
    *(_QWORD *)v237 = MEMORY[0x1E0C809B0];
    *(_QWORD *)&v237[8] = 0x40000000;
    *(_QWORD *)&v237[16] = ___ZN8Security11CodeSigning13SecCodeSigner6Signer14buildResourcesENSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEES9_PK14__CFDictionary_block_invoke_31;
    *(_QWORD *)&v237[24] = &unk_1E1FDCE70;
    *((_QWORD *)&v238 + 1) = v168;
    value[0] = v250;
    *(_QWORD *)&v238 = &theData;
    Security::CodeSigning::ResourceBuilder::scan((uint64_t)v250, (uint64_t)v237, 0);
    CFDictionaryAddValue(theDict, CFSTR("files"), *(const void **)(theData.__r_.__value_.__l.__size_ + 40));
    Security::CodeSigning::ResourceBuilder::~ResourceBuilder((Security::CodeSigning::ResourceBuilder *)v250);
    _Block_object_dispose(&theData, 8);
    Security::CFRef<__CFDictionary *>::~CFRef((const void **)&v236);
  }
  v173 = Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 12, theDict);
  Data = CFPropertyListCreateData(0, *v173, kCFPropertyListXMLFormat_v1_0, 0, 0);
  v175 = (const void *)*((_QWORD *)this + 13);
  if (v175)
    CFRelease(v175);
  *((_QWORD *)this + 13) = Data;
  Security::CFRef<__CFDictionary *>::~CFRef((const void **)&theDict);
  if (SHIBYTE(v225.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v225.__r_.__value_.__l.__data_);
  if (SHIBYTE(v226.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v226.__r_.__value_.__l.__data_);
    if ((v6 & 0x80) == 0)
      goto LABEL_329;
    goto LABEL_317;
  }
LABEL_316:
  if ((v6 & 0x80) == 0)
    goto LABEL_329;
LABEL_317:
  if ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 2) + 32) + 80))(*(_QWORD *)(*((_QWORD *)this + 2) + 32)))
  {
    v176 = (Security::Universal *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 2) + 32) + 80))(*(_QWORD *)(*((_QWORD *)this + 2) + 32));
    v177 = Security::Universal::bestNativeArch(v176);
  }
  else
  {
    Security::MainMachOImage::MainMachOImage((Security::MainMachOImage *)v250);
    v179 = *(_DWORD *)(*(_QWORD *)&v250[8] + 4);
    LODWORD(v178) = *(_DWORD *)(*(_QWORD *)&v250[8] + 8);
    v180 = bswap32(v179);
    if (v250[33])
      v181 = v180;
    else
      v181 = v179;
    v182 = bswap32(v178);
    if (v250[33])
      v178 = v182;
    else
      v178 = v178;
    v177 = v181 | (v178 << 32);
  }
  *((_QWORD *)this + 28) = v177;
  v183 = std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>((uint64_t **)this + 29, v177, (uint64_t *)this + 28);
  Security::CodeSigning::SecCodeSigner::Signer::addPreEncryptHashes((uint64_t **)v183 + 5, *((Security::CodeSigning::SecStaticCode **)this + 2));
  v184 = *((_QWORD *)this + 2);
  v224[0] = MEMORY[0x1E0C809B0];
  v224[1] = 0x40000000;
  v224[2] = ___ZN8Security11CodeSigning13SecCodeSigner6Signer7prepareEj_block_invoke;
  v224[3] = &__block_descriptor_tmp_14658;
  v224[4] = this;
  *(_QWORD *)v250 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v250[8] = 0x40000000;
  *(_QWORD *)&v250[16] = ___ZN8Security11CodeSigning13SecStaticCode24handleOtherArchitecturesEU13block_pointerFvPS1_E_block_invoke;
  *(_QWORD *)&v250[24] = &unk_1E1FDCC70;
  *(_QWORD *)&v250[32] = v224;
  *(_QWORD *)&v250[40] = v184;
  Security::CodeSigning::SecStaticCode::visitOtherArchitectures(v184, (uint64_t)v250);
LABEL_329:
  if (!v67)
  {
    if ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 2) + 32) + 80))(*(_QWORD *)(*((_QWORD *)this + 2) + 32)))
    {
      v185 = (Security::Universal *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 2) + 32)
                                                                      + 80))(*(_QWORD *)(*((_QWORD *)this + 2) + 32));
      v186 = Security::Universal::bestNativeArch(v185);
    }
    else
    {
      Security::MainMachOImage::MainMachOImage((Security::MainMachOImage *)v250);
      v188 = *(_DWORD *)(*(_QWORD *)&v250[8] + 4);
      LODWORD(v187) = *(_DWORD *)(*(_QWORD *)&v250[8] + 8);
      v189 = bswap32(v188);
      if (v250[33])
        v190 = v189;
      else
        v190 = v188;
      v191 = bswap32(v187);
      if (v250[33])
        v187 = v191;
      else
        v187 = v187;
      v186 = v190 | (v187 << 32);
    }
    *((_QWORD *)this + 32) = v186;
    v192 = std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>((uint64_t **)this + 33, v186, (uint64_t *)this + 32);
    Security::CodeSigning::SecCodeSigner::Signer::addRuntimeVersions((uint64_t **)v192 + 5, *((Security::CodeSigning::SecStaticCode **)this + 2));
    v193 = *((_QWORD *)this + 2);
    v223[0] = MEMORY[0x1E0C809B0];
    v223[1] = 0x40000000;
    v223[2] = ___ZN8Security11CodeSigning13SecCodeSigner6Signer7prepareEj_block_invoke_2;
    v223[3] = &__block_descriptor_tmp_9_14659;
    v223[4] = this;
    *(_QWORD *)v250 = MEMORY[0x1E0C809B0];
    *(_QWORD *)&v250[8] = 0x40000000;
    *(_QWORD *)&v250[16] = ___ZN8Security11CodeSigning13SecStaticCode24handleOtherArchitecturesEU13block_pointerFvPS1_E_block_invoke;
    *(_QWORD *)&v250[24] = &unk_1E1FDCC70;
    *(_QWORD *)&v250[32] = v223;
    *(_QWORD *)&v250[40] = v193;
    Security::CodeSigning::SecStaticCode::visitOtherArchitectures(v193, (uint64_t)v250);
  }
  Security::CFRef<__CFDictionary const*>::~CFRef(&v227);
  if (SHIBYTE(v228.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v228.__r_.__value_.__l.__data_);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  return Security::CFRef<__CFDictionary const*>::~CFRef(&cf);
}

void sub_18AA46E30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,const void *a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,const void *a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,int a59,__int16 a60,char a61,char a62,uint64_t a63)
{
  void *__p;
  char a73;
  void *v73;

  operator delete(v73);
  if (a73 < 0)
    operator delete(__p);
  if (a62 < 0)
    operator delete(a57);
  Security::CFRef<__CFDictionary const*>::~CFRef(&a30);
  if (a36 < 0)
    operator delete(a31);
  if (a42 < 0)
    operator delete(a37);
  Security::CFRef<__CFDictionary const*>::~CFRef(&a50);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::PreSigningContext::~PreSigningContext(Security::CodeSigning::PreSigningContext *this)
{
  Security::CFRef<__CFArray const*>::~CFRef((const void **)this + 12);
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
}

char *std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t *a3)
{
  int *v5;
  char *v6;
  int v7;
  int v8;
  _BOOL4 v9;
  uint64_t **v10;
  _BOOL4 v11;
  int v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;

  v6 = (char *)(a1 + 1);
  v5 = (int *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v6 = (char *)v5;
        v7 = v5[8];
        v8 = *((_DWORD *)v6 + 9);
        v9 = SHIDWORD(a2) < v8;
        if ((_DWORD)a2 != v7)
          v9 = (int)a2 < v7;
        if (!v9)
          break;
        v5 = *(int **)v6;
        v10 = (uint64_t **)v6;
        if (!*(_QWORD *)v6)
          goto LABEL_14;
      }
      v11 = v8 < SHIDWORD(a2);
      v12 = (_DWORD)a2 == v7 ? v11 : v7 < (int)a2;
      if (v12 != 1)
        break;
      v10 = (uint64_t **)(v6 + 8);
      v5 = (int *)*((_QWORD *)v6 + 1);
      if (!v5)
        goto LABEL_14;
    }
  }
  else
  {
    v10 = a1 + 1;
LABEL_14:
    v13 = v6;
    v6 = (char *)operator new(0x40uLL);
    v14 = *a3;
    *((_QWORD *)v6 + 7) = 0;
    *((_QWORD *)v6 + 6) = 0;
    *((_QWORD *)v6 + 4) = v14;
    *((_QWORD *)v6 + 5) = v6 + 48;
    *(_QWORD *)v6 = 0;
    *((_QWORD *)v6 + 1) = 0;
    *((_QWORD *)v6 + 2) = v13;
    *v10 = (uint64_t *)v6;
    v15 = (uint64_t *)**a1;
    v16 = (uint64_t *)v6;
    if (v15)
    {
      *a1 = v15;
      v16 = *v10;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v16);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6;
}

uint64_t Security::CodeSigning::SecCodeSigner::Signer::populate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, uint64_t a8, uint64_t a9, _QWORD *a10, int a11)
{
  uint64_t v19;
  void **v20;
  _QWORD *v21;
  uint64_t *v22;
  uint64_t **v23;
  uint64_t *v24;
  uint64_t **v25;
  BOOL v26;
  unsigned int v27;
  uint64_t **v28;
  uint64_t **v29;
  uint64_t *v30;
  _QWORD *v31;
  _QWORD *v32;
  unsigned int v33;
  uint64_t **v34;
  uint64_t v35;
  uint64_t **v36;
  Security::CodeSigning::SecCodeSigner::Signer **v37;
  Security::CodeSigning::SecCodeSigner::Signer *v38;
  uint64_t **v39;
  uint64_t *v40;
  uint64_t **v41;
  uint64_t **v42;
  uint64_t *v43;
  uint64_t **v44;
  uint64_t *v45;
  uint64_t **v46;
  uint64_t **v47;
  uint64_t *v48;
  uint64_t **v49;
  Security::CodeSigning::SecCodeSigner::Signer *v50;
  uint64_t v51;
  const __CFData **v52;
  const __CFData **v53;
  uint64_t v54;
  const __CFData *v55;
  unsigned int *BytePtr;
  unint64_t Length;
  unsigned int v58;
  Security::CodeSigning::SecCodeSigner::Signer *v59;
  const __CFData *v60;
  __CFData *Mutable;
  CFIndex v62;
  UInt8 *MutableBytePtr;
  int v64;
  const UInt8 *v65;
  CFIndex v66;
  const __CFString *v67;
  unsigned int v68;
  const __CFString *v69;
  unsigned int v70;
  const __CFString *v71;
  unsigned int v72;
  const __CFString *v73;
  unsigned int v74;
  const __CFString *v75;
  unsigned int v76;
  const __CFString *v77;
  unsigned int v78;
  const __CFString *v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  __CFData *v90;
  Security::CodeSigning::SecCodeSigner::Signer *v91;
  uint64_t v93;
  NSObject *v94;
  uint64_t v95;
  char v96;
  __CFData *v97;
  uint64_t **v98;
  uint64_t *v99;
  uint64_t v100;
  void *__p[2];
  char v102;
  uint8_t buf[16];
  CFTypeRef cf;
  const void *v105;
  Security::CodeSigning::SecCodeSigner::Signer *v106[6];

  v106[4] = *(Security::CodeSigning::SecCodeSigner::Signer **)MEMORY[0x1E0C80C00];
  (*(void (**)(void **__return_ptr))(**(_QWORD **)(a1 + 24) + 40))(__p);
  v19 = *(_QWORD *)(a1 + 304);
  Security::UnixPlusPlus::FileDesc::close((Security::UnixPlusPlus::FileDesc *)(a2 + 40));
  if (v102 >= 0)
    v20 = __p;
  else
    v20 = (void **)__p[0];
  Security::UnixPlusPlus::FileDesc::open((Security::UnixPlusPlus::FileDesc *)(a2 + 40), (const char *)v20, 0, 438);
  *(_QWORD *)(a2 + 56) = a6;
  *(_QWORD *)(a2 + 64) = v19;
  *(_QWORD *)(a2 + 48) = a5;
  if (v102 < 0)
    operator delete(__p[0]);
  *(_DWORD *)(a2 + 72) = *(_DWORD *)(a1 + 288);
  std::string::operator=((std::string *)(a2 + 88), (const std::string *)(a1 + 136));
  std::string::operator=((std::string *)(a2 + 112), (const std::string *)(a1 + 160));
  *(_BYTE *)(a2 + 80) = *(_BYTE *)(*(_QWORD *)(a1 + 8) + 248);
  *(_QWORD *)(a2 + 168) = a8;
  *(_QWORD *)(a2 + 176) = a9;
  *(_QWORD *)(a2 + 184) = a7;
  v95 = a4;
  v96 = a7;
  *(_BYTE *)(a2 + 192) = ((*(unsigned __int16 (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1) >> 8) & 1;
  v99 = 0;
  v100 = 0;
  v98 = &v99;
  v21 = (_QWORD *)*a10;
  if ((_QWORD *)*a10 != a10 + 1)
  {
    do
    {
      v22 = v99;
      v23 = &v99;
      if (v98 == &v99)
        goto LABEL_13;
      v24 = v99;
      v25 = &v99;
      if (v99)
      {
        do
        {
          v23 = (uint64_t **)v24;
          v24 = (uint64_t *)v24[1];
        }
        while (v24);
      }
      else
      {
        do
        {
          v23 = (uint64_t **)v25[2];
          v26 = *v23 == (uint64_t *)v25;
          v25 = v23;
        }
        while (v26);
      }
      v27 = *((_DWORD *)v21 + 8);
      if (*((_DWORD *)v23 + 8) < v27)
      {
LABEL_13:
        if (v99)
          v28 = v23;
        else
          v28 = &v99;
        if (v99)
          v29 = v23 + 1;
        else
          v29 = &v99;
      }
      else
      {
        v28 = &v99;
        v29 = &v99;
        if (v99)
        {
          v29 = &v99;
          while (1)
          {
            while (1)
            {
              v28 = (uint64_t **)v22;
              v33 = *((_DWORD *)v22 + 8);
              if (v27 >= v33)
                break;
              v22 = *v28;
              v29 = v28;
              if (!*v28)
                goto LABEL_20;
            }
            if (v33 >= v27)
              break;
            v29 = v28 + 1;
            v22 = v28[1];
            if (!v22)
              goto LABEL_20;
          }
        }
      }
      if (!*v29)
      {
LABEL_20:
        memset(v106, 170, 24);
        std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::__construct_node<std::pair<unsigned int const,Security::CFCopyRef<__CFData const*>> const&>(v106, (uint64_t)&v98, *((_DWORD *)v21 + 8), (const void *)v21[5]);
        v30 = (uint64_t *)v106[0];
        *(_QWORD *)v106[0] = 0;
        v30[1] = 0;
        v30[2] = (uint64_t)v28;
        *v29 = v30;
        if (*v98)
        {
          v98 = (uint64_t **)*v98;
          v30 = *v29;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v99, v30);
        ++v100;
        v106[0] = 0;
        std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v106);
      }
      v31 = (_QWORD *)v21[1];
      if (v31)
      {
        do
        {
          v32 = v31;
          v31 = (_QWORD *)*v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          v32 = (_QWORD *)v21[2];
          v26 = *v32 == (_QWORD)v21;
          v21 = v32;
        }
        while (!v26);
      }
      v21 = v32;
    }
    while (v32 != a10 + 1);
  }
  if ((uint64_t ***)(a2 + 200) != &v98)
  {
    v34 = v98;
    if (*(_QWORD *)(a2 + 216))
    {
      v36 = (uint64_t **)(a2 + 208);
      v35 = *(_QWORD *)(a2 + 208);
      v37 = *(Security::CodeSigning::SecCodeSigner::Signer ***)(a2 + 200);
      *(_QWORD *)(a2 + 200) = a2 + 208;
      *(_QWORD *)(v35 + 16) = 0;
      *(_QWORD *)(a2 + 208) = 0;
      *(_QWORD *)(a2 + 216) = 0;
      if (v37[1])
        v38 = v37[1];
      else
        v38 = (Security::CodeSigning::SecCodeSigner::Signer *)v37;
      v106[0] = (Security::CodeSigning::SecCodeSigner::Signer *)(a2 + 200);
      v106[1] = v38;
      v106[2] = v38;
      if (v38)
      {
        v106[1] = (Security::CodeSigning::SecCodeSigner::Signer *)std::__tree<unsigned int>::_DetachedTreeCache::__detach_next((uint64_t)v38);
        v39 = &v99;
        if (v34 != &v99)
        {
          do
          {
            *((_DWORD *)v38 + 8) = *((_DWORD *)v34 + 8);
            Security::CFRef<__CFData const*>::operator=((CFTypeRef *)v38 + 5, (CFTypeRef *)v34 + 5);
            v40 = *v36;
            v41 = (uint64_t **)(a2 + 208);
            v42 = (uint64_t **)(a2 + 208);
            if (*v36)
            {
              do
              {
                while (1)
                {
                  v41 = (uint64_t **)v40;
                  if (*((_DWORD *)v106[2] + 8) >= *((_DWORD *)v40 + 8))
                    break;
                  v40 = (uint64_t *)*v40;
                  v42 = v41;
                  if (!*v41)
                    goto LABEL_51;
                }
                v40 = (uint64_t *)v40[1];
              }
              while (v40);
              v42 = v41 + 1;
            }
LABEL_51:
            std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at((uint64_t **)(a2 + 200), (uint64_t)v41, v42, (uint64_t *)v106[2]);
            v38 = v106[1];
            v106[2] = v106[1];
            if (v106[1])
              v106[1] = (Security::CodeSigning::SecCodeSigner::Signer *)std::__tree<unsigned int>::_DetachedTreeCache::__detach_next((uint64_t)v106[1]);
            v43 = v34[1];
            if (v43)
            {
              do
              {
                v39 = (uint64_t **)v43;
                v43 = (uint64_t *)*v43;
              }
              while (v43);
            }
            else
            {
              do
              {
                v39 = (uint64_t **)v34[2];
                v26 = *v39 == (uint64_t *)v34;
                v34 = v39;
              }
              while (!v26);
            }
            if (!v38)
              break;
            v34 = v39;
          }
          while (v39 != &v99);
        }
      }
      else
      {
        v39 = v34;
      }
      std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)v106);
      v34 = v39;
    }
    if (v34 != &v99)
    {
      v44 = (uint64_t **)(a2 + 208);
      do
      {
        memset(v106, 170, 24);
        std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::__construct_node<std::pair<unsigned int const,Security::CFCopyRef<__CFData const*>> const&>(v106, a2 + 200, *((_DWORD *)v34 + 8), v34[5]);
        v45 = *v44;
        v46 = (uint64_t **)(a2 + 208);
        v47 = (uint64_t **)(a2 + 208);
        if (*v44)
        {
          do
          {
            while (1)
            {
              v46 = (uint64_t **)v45;
              if (*((_DWORD *)v106[0] + 8) >= *((_DWORD *)v45 + 8))
                break;
              v45 = (uint64_t *)*v45;
              v47 = v46;
              if (!*v46)
                goto LABEL_71;
            }
            v45 = (uint64_t *)v45[1];
          }
          while (v45);
          v47 = v46 + 1;
        }
LABEL_71:
        std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at((uint64_t **)(a2 + 200), (uint64_t)v46, v47, (uint64_t *)v106[0]);
        v106[0] = 0;
        std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)v106);
        v48 = v34[1];
        if (v48)
        {
          do
          {
            v49 = (uint64_t **)v48;
            v48 = (uint64_t *)*v48;
          }
          while (v48);
        }
        else
        {
          do
          {
            v49 = (uint64_t **)v34[2];
            v26 = *v49 == (uint64_t *)v34;
            v34 = v49;
          }
          while (!v26);
        }
        v34 = v49;
      }
      while (v49 != &v99);
    }
  }
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy((const void **)v99);
  *(_DWORD *)(a2 + 224) = a11;
  v50 = (Security::CodeSigning::SecCodeSigner::Signer *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 24) + 24))(*(_QWORD *)(a1 + 24), 1);
  v106[0] = v50;
  if (v50)
    Security::CodeSigning::CodeDirectory::Builder::specialSlot((Security::CodeSigning::CodeDirectory::Builder *)a2, 1u, v50);
  Security::CFRef<__CFData const*>::~CFRef((const void **)v106);
  v51 = *(_QWORD *)(v95 + 24);
  if (v51)
  {
    v106[0] = CFDataCreate(0, (const UInt8 *)v51, bswap32(*(_DWORD *)(v51 + 4)));
    (*(void (**)(uint64_t, uint64_t, Security::CodeSigning::SecCodeSigner::Signer *))(*(_QWORD *)a3 + 16))(a3, 2, v106[0]);
    Security::CodeSigning::CodeDirectory::Builder::specialSlot((Security::CodeSigning::CodeDirectory::Builder *)a2, 2u, v106[0]);
    Security::CFRef<__CFData const*>::~CFRef((const void **)v106);
  }
  if (*(_QWORD *)(a1 + 96))
    Security::CodeSigning::CodeDirectory::Builder::specialSlot((Security::CodeSigning::CodeDirectory::Builder *)a2, 3u, *(const __CFData **)(a1 + 104));
  v52 = *(const __CFData ***)(a1 + 192);
  v53 = *(const __CFData ***)(a1 + 200);
  if (v52 != v53)
  {
    v54 = 8;
    do
    {
      if (*v52)
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3, v54);
        Security::CodeSigning::CodeDirectory::Builder::specialSlot((Security::CodeSigning::CodeDirectory::Builder *)a2, v54, *v52);
      }
      v54 = (v54 + 1);
      ++v52;
    }
    while (v52 != v53);
  }
  if (*(_QWORD *)(a1 + 216))
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3, 11);
    Security::CodeSigning::CodeDirectory::Builder::specialSlot((Security::CodeSigning::CodeDirectory::Builder *)a2, 0xBu, *(const __CFData **)(a1 + 216));
  }
  if (*(_QWORD *)(a1 + 184) && ((v96 & 1) != 0 || *(_BYTE *)(*(_QWORD *)(a1 + 8) + 72)))
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 16))(a3, 5);
    Security::CodeSigning::CodeDirectory::Builder::specialSlot((Security::CodeSigning::CodeDirectory::Builder *)a2, 5u, *(const __CFData **)(a1 + 184));
    v55 = *(const __CFData **)(a1 + 184);
    v97 = 0;
    if (v55)
    {
      BytePtr = (unsigned int *)CFDataGetBytePtr(v55);
      if (BytePtr)
      {
        Length = CFDataGetLength(v55);
        if (Length >= 8)
        {
          if (*BytePtr == 1903288058 && (v58 = bswap32(BytePtr[1]), v58 > 7))
          {
            if (Length == v58)
            {
              v106[0] = (Security::CodeSigning::SecCodeSigner::Signer *)0xAAAAAAAAAAAAAAAALL;
              v59 = (Security::CodeSigning::SecCodeSigner::Signer *)Security::CodeSigning::EntitlementBlob::entitlements((Security::CodeSigning::EntitlementBlob *)BytePtr);
              v105 = 0;
              v106[0] = v59;
              cf = 0;
              if (CESerializeCFDictionary() == *MEMORY[0x1E0DDFFA0])
              {
                v60 = (const __CFData *)cf;
                Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
                v62 = CFDataGetLength(v60);
                CFDataSetLength(Mutable, v62 + 8);
                if (Mutable)
                {
                  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
                  v64 = CFDataGetLength(v60);
                  *(_DWORD *)MutableBytePtr = 1920065274;
                  *((_DWORD *)MutableBytePtr + 1) = bswap32(v64 + 8);
                  v65 = CFDataGetBytePtr(v60);
                  v66 = CFDataGetLength(v60);
                  memcpy(MutableBytePtr + 8, v65, v66);
                  v97 = Mutable;
                  CFRelease(cf);
                  Security::CFRef<__CFError *>::~CFRef(&v105);
                  v68 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement(v106[0], (const __CFDictionary *)CFSTR("get-task-allow"), v67);
                  v70 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement(v106[0], (const __CFDictionary *)CFSTR("run-unsigned-code"), v69);
                  v72 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement(v106[0], (const __CFDictionary *)CFSTR("com.apple.private.cs.debugger"), v71);
                  v74 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement(v106[0], (const __CFDictionary *)CFSTR("dynamic-codesigning"), v73);
                  v76 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement(v106[0], (const __CFDictionary *)CFSTR("com.apple.private.skip-library-validation"), v75);
                  v78 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement(v106[0], (const __CFDictionary *)CFSTR("com.apple.private.amfi.can-load-cdhash"), v77);
                  v80 = Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement(v106[0], (const __CFDictionary *)CFSTR("com.apple.private.amfi.can-execute-cdhash"), v79);
                  v81 = 16;
                  if (!(v68 | v70))
                    v81 = 0;
                  v82 = 32;
                  if (!v72)
                    v82 = 0;
                  v83 = 64;
                  if (!v74)
                    v83 = 0;
                  v84 = v82 | v83 | v81;
                  v85 = 128;
                  if (!v76)
                    v85 = 0;
                  v86 = 256;
                  if (!v78)
                    v86 = 0;
                  v87 = v85 | v86;
                  v88 = 512;
                  if (!v80)
                    v88 = 0;
                  v89 = v84 | v87 | v88;
                  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)v106);
                  v90 = v97;
                  goto LABEL_115;
                }
                v93 = 4294967188;
              }
              else
              {
                v93 = 4294900302;
                v94 = secLogObjForScope("SecError");
                if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl(&dword_18A900000, v94, OS_LOG_TYPE_DEFAULT, "Serializing DER entitlements failed", buf, 2u);
                }
              }
              Security::MacOSError::throwMe((Security::MacOSError *)v93);
            }
          }
          else
          {
            *__error() = 22;
          }
        }
      }
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA4ELL);
    }
    v90 = 0;
    v89 = 0;
LABEL_115:
    (*(void (**)(uint64_t, uint64_t, __CFData *))(*(_QWORD *)a3 + 16))(a3, 7, v90);
    Security::CodeSigning::CodeDirectory::Builder::specialSlot((Security::CodeSigning::CodeDirectory::Builder *)a2, 7u, v97);
    *(_QWORD *)(a2 + 184) |= v89;
    Security::CFRef<__CFData const*>::~CFRef((const void **)&v97);
  }
  v91 = (Security::CodeSigning::SecCodeSigner::Signer *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 24) + 24))(*(_QWORD *)(a1 + 24), 6);
  v106[0] = v91;
  if (v91)
    Security::CodeSigning::CodeDirectory::Builder::specialSlot((Security::CodeSigning::CodeDirectory::Builder *)a2, 6u, v91);
  Security::CFRef<__CFData const*>::~CFRef((const void **)v106);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a3 + 32))(a3, a2);
}

void sub_18AA47C3C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, const void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,__int128 buf)
{
  void *v24;
  NSObject *v25;
  uint64_t v26;

  if (a2 == 1)
  {
    v24 = __cxa_begin_catch(a1);
    v25 = secLogObjForScope("SecWarning");
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      v26 = (*(uint64_t (**)(void *))(*(_QWORD *)v24 + 16))(v24);
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v26;
      _os_log_impl(&dword_18A900000, v25, OS_LOG_TYPE_DEFAULT, "failed to parse entitlements: %s", (uint8_t *)&buf, 0xCu);
    }
    __cxa_rethrow();
  }
  Security::CFRef<__CFData const*>::~CFRef(&a12);
  _Unwind_Resume(a1);
}

void sub_18AA47D20()
{
  __cxa_end_catch();
  JUMPOUT(0x18AA47D28);
}

void sub_18AA47D34(_Unwind_Exception *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  _Unwind_Resume(a1);
}

void sub_18AA47D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void **a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)va);
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(a7);
  _Unwind_Resume(a1);
}

CFDataRef Security::CodeSigning::SecCodeSigner::Signer::signCodeDirectory(Security::CodeSigning::SecCodeSigner::Signer *this, const Security::CodeSigning::CodeDirectory *a2, const __CFDictionary *a3, const __CFArray *a4)
{
  double v8;
  uint64_t updated;
  CMSEncoderRef v10;
  double Current;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFDataRef Data;
  CFDataRef v19;
  CMSEncoderRef v20;
  Security::MacOSError *v21;
  CFDataRef v22;
  void *v23;
  const __CFArray *v24;
  id v25;
  const void *ValueAtIndex;
  const void *v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  void *v42;
  _CMSEncoder *v43;
  void *v44;
  const __CFDictionary *v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  uint64_t i;
  void *v51;
  int v52;
  void *v53;
  id v54;
  void *v55;
  id v56;
  const char *v57;
  NSObject *v58;
  uint32_t v59;
  uint64_t v60;
  NSObject *v62;
  NSObject *v63;
  NSObject *v64;
  CFTypeRef v65;
  void *v66;
  NSObject *v67;
  NSObject *v68;
  void *v69;
  _CMSEncoder *v70;
  void *v71;
  void *v72;
  NSObject *v73;
  id v74;
  void *v75;
  id v76;
  uint64_t v77;
  NSObject *v78;
  NSObject *v79;
  NSObject *v80;
  void *v81;
  NSObject *v82;
  NSObject *v83;
  NSObject *v84;
  int v85;
  void *v86;
  void *v87;
  NSObject *v88;
  const __CFDictionary *v89;
  NSObject *v90;
  void *v91;
  void *v92;
  NSObject *v93;
  NSObject *v94;
  void *v95;
  void *v96;
  void *v97;
  void *v98;
  void *v99;
  void *v100;
  uint64_t (**v101)(_QWORD, _QWORD, _QWORD);
  NSObject *v102;
  id v103;
  id v104;
  NSObject *v105;
  id v106;
  CFTypeRef cf;
  CMSEncoderRef cmsEncoderOut[2];
  __int128 v109;
  __int128 v110;
  __int128 v111;
  _BYTE propertyList[12];
  _BYTE v113[22];
  __int16 v114;
  NSObject *v115;
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  if (!*((_BYTE *)this + 322))
  {
    *(_QWORD *)v113 = 0;
    if (*(_QWORD *)(*((_QWORD *)this + 1) + 24) != *MEMORY[0x1E0C9B0D0])
    {
      cmsEncoderOut[0] = 0;
      updated = CMSEncoderCreate(cmsEncoderOut);
      if (!(_DWORD)updated)
      {
        v10 = cmsEncoderOut[0];
        if (!cmsEncoderOut[0]
          || *((_DWORD *)cmsEncoderOut[0] + 4)
          || (*((_DWORD *)cmsEncoderOut[0] + 30) = 4,
              CMSEncoderAddSigners(v10, *(CFTypeRef *)(*((_QWORD *)this + 1) + 24)),
              CMSEncoderSetSignerAlgorithm(v10, CFSTR("sha256")),
              *((_DWORD *)v10 + 4)))
        {
          updated = 4294967246;
        }
        else
        {
          *((_BYTE *)v10 + 24) = 1;
          if (*((_BYTE *)this + 320))
          {
            *((_DWORD *)v10 + 18) |= 8u;
            Current = *((double *)this + 39);
            if (Current == 0.0 && (Current = CFAbsoluteTimeGetCurrent(), (v10 = cmsEncoderOut[0]) == 0)
              || *((_DWORD *)v10 + 4))
            {
              Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFCELL);
            }
            *((double *)v10 + 10) = Current;
          }
          if (a3)
          {
            *((_DWORD *)v10 + 18) |= 0x20u;
            CFRetain(a3);
            *((_QWORD *)v10 + 17) = a3;
            *(_QWORD *)propertyList = 0xAAAAAAAAAAAAAAAALL;
            Security::CFTemp<__CFDictionary const*>::CFTemp((CFTypeRef *)propertyList, (uint64_t)"{cdhashes=%O}", v12, v13, v14, v15, v16, v17, (uint64_t)a4);
            Data = CFPropertyListCreateData(0, *(CFPropertyListRef *)propertyList, kCFPropertyListXMLFormat_v1_0, 0, 0);
            v19 = Data;
            cf = Data;
            v20 = cmsEncoderOut[0];
            if (!cmsEncoderOut[0] || *((_DWORD *)cmsEncoderOut[0] + 4))
              Security::MacOSError::throwMe((Security::MacOSError *)0xFFFFFFCELL);
            *((_DWORD *)cmsEncoderOut[0] + 18) |= 0x10u;
            if (Data)
              CFRetain(Data);
            *((_QWORD *)v20 + 16) = v19;
            Security::CFRef<__CFData const*>::~CFRef(&cf);
            Security::CFRef<__CFDictionary const*>::~CFRef((const void **)propertyList);
            v10 = cmsEncoderOut[0];
          }
          updated = CMSEncoderUpdateContent(v10, a2, bswap32(*((_DWORD *)a2 + 1)));
          if (!(_DWORD)updated)
          {
            if (!*(_BYTE *)(*((_QWORD *)this + 1) + 280))
            {
              *(_QWORD *)propertyList = 0xAAAAAAAAAAAAAAAALL;
              v21 = (Security::MacOSError *)CMSEncoderCopyEncodedContent(cmsEncoderOut[0], (CFDataRef *)propertyList);
              if ((_DWORD)v21)
                Security::MacOSError::throwMe(v21);
              v22 = *(CFDataRef *)propertyList;
              Security::CFRef<_CMSEncoder *>::~CFRef((const void **)cmsEncoderOut);
              goto LABEL_64;
            }
            v88 = secLogObjForScope("SecError");
            if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)propertyList = 0;
              _os_log_impl(&dword_18A900000, v88, OS_LOG_TYPE_DEFAULT, "Platform does not support signing secure timestamps", propertyList, 2u);
            }
            updated = 4294967292;
          }
        }
      }
      Security::MacOSError::throwMe((Security::MacOSError *)updated);
    }
    v22 = CFDataCreate(0, 0, 0);
LABEL_64:
    Security::CFRef<__CFDictionary *>::~CFRef((const void **)v113);
    return v22;
  }
  if (*((_BYTE *)this + 320))
  {
    v8 = *((double *)this + 39);
    if (v8 == 0.0)
      v8 = CFAbsoluteTimeGetCurrent();
  }
  else
  {
    v8 = 0.0;
  }
  v23 = (void *)*((_QWORD *)this + 41);
  v24 = (const __CFArray *)*((_QWORD *)this + 42);
  v102 = 0;
  v25 = v23;
  cf = 0;
  v101 = (uint64_t (**)(_QWORD, _QWORD, _QWORD))v25;
  if (!a2 || !*((_DWORD *)a2 + 1))
  {
    secLogObjForScope("SecError");
    v30 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      goto LABEL_60;
    *(_WORD *)v113 = 0;
    v57 = "Remote signing requires valid code directory.";
LABEL_58:
    v58 = v30;
    v59 = 2;
LABEL_59:
    _os_log_impl(&dword_18A900000, v58, OS_LOG_TYPE_DEFAULT, v57, v113, v59);
    goto LABEL_60;
  }
  if (!a3)
  {
    secLogObjForScope("SecError");
    v30 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      goto LABEL_60;
    *(_WORD *)v113 = 0;
    v57 = "Remote signing requires hash dictionary.";
    goto LABEL_58;
  }
  if (!a4)
  {
    secLogObjForScope("SecError");
    v30 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      goto LABEL_60;
    *(_WORD *)v113 = 0;
    v57 = "Remote signing requires hash list.";
    goto LABEL_58;
  }
  if (!v25)
  {
    secLogObjForScope("SecError");
    v30 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      goto LABEL_60;
    *(_WORD *)v113 = 0;
    v57 = "Remote signing requires signing block.";
    goto LABEL_58;
  }
  if (v24 && CFArrayGetCount(v24))
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v24, 0);
    v27 = ValueAtIndex;
    if (ValueAtIndex)
      CFRetain(ValueAtIndex);
    cf = v27;
    v28 = *MEMORY[0x1E0D4D738];
    v106 = 0;
    objc_msgSend(MEMORY[0x1E0D4D7B8], "OIDWithString:error:", v28, &v106);
    v29 = objc_claimAutoreleasedReturnValue();
    v30 = v106;
    v98 = (void *)v29;
    if (!v29)
    {
      secLogObjForScope("SecError");
      v62 = objc_claimAutoreleasedReturnValue();
      v60 = 4294899624;
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v113 = 138412290;
        *(_QWORD *)&v113[4] = v30;
        _os_log_impl(&dword_18A900000, v62, OS_LOG_TYPE_DEFAULT, "Unable to create signing algorithm: %@", v113, 0xCu);
      }
      goto LABEL_119;
    }
    v31 = objc_alloc(MEMORY[0x1E0D4D7A0]);
    if ((objc_opt_respondsToSelector() & 1) == 0)
    {
      secLogObjForScope("SecError");
      v63 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v113 = 0;
        _os_log_impl(&dword_18A900000, v63, OS_LOG_TYPE_DEFAULT, "Unable to create signer due to old CMS interfaces", v113, 2u);
      }

      v60 = 4294966387;
      v62 = v31;
      goto LABEL_119;
    }
    v32 = v31;
    v105 = v30;
    v94 = -[NSObject initWithCertificate:signatureAlgorithm:useIssuerAndSerialNumber:error:](v32, "initWithCertificate:signatureAlgorithm:useIssuerAndSerialNumber:error:", cf, v29, 1, &v105);
    v33 = v105;

    if (!v94 || v33)
    {
      secLogObjForScope("SecError");
      v64 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        v65 = cf;
        objc_msgSend(v98, "OIDString");
        v66 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)v113 = 138412802;
        *(_QWORD *)&v113[4] = v65;
        *(_WORD *)&v113[12] = 2112;
        *(_QWORD *)&v113[14] = v66;
        v114 = 2112;
        v115 = v33;
        _os_log_impl(&dword_18A900000, v64, OS_LOG_TYPE_DEFAULT, "Unable to create signer info: %@, %@, %@", v113, 0x20u);

      }
      v60 = 4294900305;
      v62 = v94;
      v30 = v33;
      goto LABEL_119;
    }
    objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", a2, bswap32(*((_DWORD *)a2 + 1)));
    v92 = (void *)objc_claimAutoreleasedReturnValue();
    v104 = 0;
    v34 = objc_msgSend(objc_alloc(MEMORY[0x1E0D4D798]), "initWithDataContent:isDetached:signer:additionalCertificates:error:", v92, 1, v94, v24, &v104);
    v30 = v104;
    v93 = v34;
    if (!v34)
    {
      v60 = 4294900305;
      secLogObjForScope("SecError");
      v67 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v113 = 138412290;
        *(_QWORD *)&v113[4] = v30;
        _os_log_impl(&dword_18A900000, v67, OS_LOG_TYPE_DEFAULT, "Unable to create signed data: %@", v113, 0xCu);
      }
      goto LABEL_118;
    }
    if (v8 != 0.0)
    {
      objc_msgSend(MEMORY[0x1E0C99D68], "dateWithTimeIntervalSinceReferenceDate:", v8);
      v41 = (void *)objc_claimAutoreleasedReturnValue();
      v42 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0D4D7A8]), "initWithSigningTime:", v41);
      -[NSObject addProtectedAttribute:](v94, "addProtectedAttribute:", v42);

    }
    *(_QWORD *)v113 = 0xAAAAAAAAAAAAAAAALL;
    Security::CFTemp<__CFDictionary const*>::CFTemp((CFTypeRef *)v113, (uint64_t)"{cdhashes=%O}", v35, v36, v37, v38, v39, v40, (uint64_t)a4);
    cmsEncoderOut[0] = CFPropertyListCreateData(0, *(CFPropertyListRef *)v113, kCFPropertyListXMLFormat_v1_0, 0, 0);
    v43 = cmsEncoderOut[0];
    Security::CFRef<__CFData const*>::~CFRef((const void **)cmsEncoderOut);
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)v113);
    v90 = v43;
    v91 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0D4D750]), "initWithHashAgilityValue:", v43);
    -[NSObject addProtectedAttribute:](v94, "addProtectedAttribute:", v91);
    v89 = a3;
    objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
    v44 = (void *)objc_claimAutoreleasedReturnValue();
    v110 = 0u;
    v111 = 0u;
    *(_OWORD *)cmsEncoderOut = 0u;
    v109 = 0u;
    v45 = v89;
    v46 = v44;
    v47 = -[__CFDictionary countByEnumeratingWithState:objects:count:](v45, "countByEnumeratingWithState:objects:count:", cmsEncoderOut, v113, 16);
    if (v47)
    {
      v48 = *(_QWORD *)v109;
      v96 = (void *)*MEMORY[0x1E0D4D700];
      v99 = (void *)*MEMORY[0x1E0D4D6F8];
      v95 = (void *)*MEMORY[0x1E0D4D6F0];
      v49 = (void *)*MEMORY[0x1E0D4D6E8];
      while (2)
      {
        for (i = 0; i != v47; ++i)
        {
          if (*(_QWORD *)v109 != v48)
            objc_enumerationMutation(v45);
          v51 = (void *)*((_QWORD *)cmsEncoderOut[1] + i);
          v52 = objc_msgSend(v51, "intValue");
          if (v52 > 192)
          {
            v53 = v99;
            if (v52 != 193)
            {
              v53 = v96;
              if (v52 != 194)
              {
LABEL_84:
                secLogObjForScope("SecError");
                v68 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)propertyList = 138412290;
                  *(_QWORD *)&propertyList[4] = v51;
                  _os_log_impl(&dword_18A900000, v68, OS_LOG_TYPE_DEFAULT, "Unexpected digest algorithm: %@", propertyList, 0xCu);
                }

                v44 = v46;
                v56 = 0;
                goto LABEL_87;
              }
            }
          }
          else
          {
            v53 = v49;
            if (v52 != 4)
            {
              v53 = v95;
              if (v52 != 192)
                goto LABEL_84;
            }
          }
          v54 = v53;
          -[__CFDictionary objectForKeyedSubscript:](v45, "objectForKeyedSubscript:", v51);
          v55 = (void *)objc_claimAutoreleasedReturnValue();
          v44 = v46;
          objc_msgSend(v46, "setObject:forKeyedSubscript:", v55, v54);

        }
        v47 = -[__CFDictionary countByEnumeratingWithState:objects:count:](v45, "countByEnumeratingWithState:objects:count:", cmsEncoderOut, v113, 16);
        if (v47)
          continue;
        break;
      }
    }

    v56 = v44;
LABEL_87:

    v97 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0D4D758]), "initWithHashAgilityValues:", v56);
    -[NSObject addProtectedAttribute:](v94, "addProtectedAttribute:", v97);
    v100 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0D4D770]), "initWithEmbeddedContent:", v93);
    cmsEncoderOut[0] = (CMSEncoderRef)v30;
    -[NSObject calculateSignerInfoDigest:](v94, "calculateSignerInfoDigest:", cmsEncoderOut);
    v69 = (void *)objc_claimAutoreleasedReturnValue();
    v70 = cmsEncoderOut[0];

    if (!v69)
    {
      v60 = 4294900305;
      secLogObjForScope("SecError");
      v73 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v113 = 138412546;
        *(_QWORD *)&v113[4] = v94;
        *(_WORD *)&v113[12] = 2112;
        *(_QWORD *)&v113[14] = v70;
        _os_log_impl(&dword_18A900000, v73, OS_LOG_TYPE_DEFAULT, "Unable to create signature digest: %@, %@", v113, 0x16u);
      }
      goto LABEL_117;
    }
    v71 = (void *)MEMORY[0x1E0D4D740];
    -[NSObject signatureAlgorithm](v94, "signatureAlgorithm");
    v72 = (void *)objc_claimAutoreleasedReturnValue();
    *(_QWORD *)propertyList = v70;
    objc_msgSend(v71, "digestAlgorithmWithSignatureAlgorithm:error:", v72, propertyList);
    v73 = objc_claimAutoreleasedReturnValue();
    v74 = *(id *)propertyList;

    if (!v73)
    {
      v60 = 4294900305;
      secLogObjForScope("SecError");
      v78 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v113 = 138412546;
        *(_QWORD *)&v113[4] = v94;
        *(_WORD *)&v113[12] = 2112;
        *(_QWORD *)&v113[14] = v74;
        _os_log_impl(&dword_18A900000, v78, OS_LOG_TYPE_DEFAULT, "Unable to create digest algorithm: %@, %@", v113, 0x16u);
      }
      goto LABEL_116;
    }
    -[NSObject algorithm](v73, "algorithm");
    v75 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v75, "OIDString");
    v76 = (id)objc_claimAutoreleasedReturnValue();
    if ((objc_msgSend(v76, "isEqualToString:", *MEMORY[0x1E0D4D6E8]) & 1) != 0)
    {
      v77 = 1;
    }
    else if ((objc_msgSend(v76, "isEqualToString:", *MEMORY[0x1E0D4D6F0]) & 1) != 0)
    {
      v77 = 2;
    }
    else
    {
      if ((objc_msgSend(v76, "isEqualToString:", *MEMORY[0x1E0D4D6F8]) & 1) == 0)
      {
        v85 = objc_msgSend(v76, "isEqualToString:", *MEMORY[0x1E0D4D700]);
        if (v85)
          v77 = 5;
        else
          v77 = 0;

        if (v85 != 1)
        {
          secLogObjForScope("SecError");
          v78 = objc_claimAutoreleasedReturnValue();
          v60 = 4294900296;
          if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
          {
            -[NSObject algorithm](v73, "algorithm");
            v86 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v86, "OIDString");
            v87 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)v113 = 138412290;
            *(_QWORD *)&v113[4] = v87;
            _os_log_impl(&dword_18A900000, v78, OS_LOG_TYPE_DEFAULT, "Unable to map digest algorithm: %@", v113, 0xCu);

          }
          goto LABEL_116;
        }
LABEL_100:
        secLogObjForScope("remotesigner");
        v79 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v79, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)v113 = 67109378;
          *(_DWORD *)&v113[4] = v77;
          *(_WORD *)&v113[8] = 2112;
          *(_QWORD *)&v113[10] = v69;
          _os_log_debug_impl(&dword_18A900000, v79, OS_LOG_TYPE_DEBUG, "Passing out external digest: %d, %@", v113, 0x12u);
        }

        v78 = ((uint64_t (**)(_QWORD, void *, uint64_t))v101)[2](v101, v69, v77);
        if (v78)
        {
          secLogObjForScope("remotesigner");
          v80 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v113 = 138412290;
            *(_QWORD *)&v113[4] = v78;
            _os_log_debug_impl(&dword_18A900000, v80, OS_LOG_TYPE_DEBUG, "Got external signature blob: %@", v113, 0xCu);
          }

          -[NSObject setSignature:](v94, "setSignature:", v78);
          v81 = v74;
          v103 = v74;
          objc_msgSend(v100, "encodeMessageSecurityObject:", &v103);
          v82 = objc_claimAutoreleasedReturnValue();
          v74 = v103;

          if (!v82 || v74)
          {
            secLogObjForScope("SecError");
            v84 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v113 = 138412290;
              *(_QWORD *)&v113[4] = v74;
              _os_log_impl(&dword_18A900000, v84, OS_LOG_TYPE_DEFAULT, "Failed to encode signature: %@", v113, 0xCu);
            }

            v60 = 4294900305;
          }
          else
          {
            secLogObjForScope("remotesigner");
            v83 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v113 = 138412290;
              *(_QWORD *)&v113[4] = v82;
              _os_log_debug_impl(&dword_18A900000, v83, OS_LOG_TYPE_DEBUG, "Encoded CMS signature: %@", v113, 0xCu);
            }

            v82 = v82;
            v74 = 0;
            v60 = 0;
            v102 = v82;
          }
        }
        else
        {
          secLogObjForScope("SecError");
          v82 = objc_claimAutoreleasedReturnValue();
          v60 = 4294900306;
          if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v113 = 0;
            _os_log_impl(&dword_18A900000, v82, OS_LOG_TYPE_DEFAULT, "External block did not provide a signature, failing.", v113, 2u);
          }
        }

LABEL_116:
        v70 = (_CMSEncoder *)v74;
LABEL_117:

        v30 = v70;
        v67 = v90;
LABEL_118:

        v62 = v93;
LABEL_119:

        goto LABEL_61;
      }
      v77 = 4;
    }

    goto LABEL_100;
  }
  secLogObjForScope("SecError");
  v30 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v113 = 138412290;
    *(_QWORD *)&v113[4] = v24;
    v57 = "Unable to perform remote signing with no certificates: %@";
    v58 = v30;
    v59 = 12;
    goto LABEL_59;
  }
LABEL_60:
  v60 = 4294967246;
LABEL_61:

  Security::CFRef<__SecCertificate *>::~CFRef(&cf);
  if ((_DWORD)v60)
    Security::MacOSError::throwMe((Security::MacOSError *)v60);
  v22 = (CFDataRef)v102;
  v102 = 0;
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v102);
  return v22;
}

void sub_18AA48D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, _Unwind_Exception *exception_object, void *a17, void *a18, void *a19, void *a20,const void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,const void *a26,__int16 a27,char a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,char a39)
{
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;

  Security::CFRef<__SecCertificate *>::~CFRef(&a26);
  Security::CFRef<__CFData const*>::~CFRef(&a21);
  _Unwind_Resume(a1);
}

const void **Security::CFRef<_CMSEncoder *>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const __CFBoolean *Security::CodeSigning::SecCodeSigner::Signer::BOOLeanEntitlement(Security::CodeSigning::SecCodeSigner::Signer *this, const __CFDictionary *a2, const __CFString *a3)
{
  const __CFBoolean *result;
  const __CFBoolean *v4;
  CFTypeID v5;

  result = (const __CFBoolean *)CFDictionaryGetValue(this, a2);
  if (result)
  {
    v4 = result;
    v5 = CFGetTypeID(result);
    if (v5 == CFBooleanGetTypeID())
      return (const __CFBoolean *)(CFBooleanGetValue(v4) != 0);
    else
      return 0;
  }
  return result;
}

uint64_t std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*(const void ***)(a1 + 16));
  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3)
    {
      do
      {
        v2 = v3;
        v3 = *(_QWORD *)(v3 + 16);
      }
      while (v3);
      *(_QWORD *)(a1 + 8) = v2;
    }
    std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy((const void **)v2);
  }
  return a1;
}

_DWORD *std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::__construct_node<std::pair<unsigned int const,Security::CFCopyRef<__CFData const*>> const&>(_QWORD *a1, uint64_t a2, int a3, const void *a4)
{
  uint64_t v7;
  _DWORD *result;

  v7 = a2 + 8;
  memset(a1, 170, 24);
  result = operator new(0x30uLL);
  *a1 = result;
  a1[1] = v7;
  *((_BYTE *)a1 + 16) = 0;
  result[8] = a3;
  *((_QWORD *)result + 5) = a4;
  if (a4)
    result = CFRetain(a4);
  *((_BYTE *)a1 + 16) = 1;
  return result;
}

void sub_18AA490E4(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void **v2;

  Security::CFRef<__CFData const*>::~CFRef(v2);
  std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  unsigned int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v7 + 7) = *a3;
    *((_DWORD *)v7 + 8) = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t ___ZN8Security11CodeSigning13SecCodeSigner6Signer9signMachOEPNS_9UniversalERKNS0_11Requirement7ContextE_block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD **v4;
  uint64_t v5;
  Security::MachO *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;

  v4 = *(_QWORD ***)(a1 + 32);
  v5 = *(_QWORD *)(a1 + 40);
  v6 = *(Security::MachO **)(v5 + 56);
  v7 = *((_QWORD *)v6 + 6);
  v8 = Security::MachO::signingExtent(v6);
  v9 = *(unsigned __int8 *)(a1 + 52);
  v10 = (*(uint64_t (**)(_QWORD *, uint64_t))(*v4[3] + 104))(v4[3], *(_QWORD *)(a1 + 40) + 48);
  v11 = (*(uint64_t (**)(_QWORD *, uint64_t))(*v4[3] + 112))(v4[3], *(_QWORD *)(a1 + 40) + 48);
  ((void (*)(_QWORD **))(*v4)[3])(v4);
  v12 = std::__tree<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::map<unsigned int,Security::CFCopyRef<__CFData const*>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>(v4 + 29, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 48), (uint64_t *)(*(_QWORD *)(a1 + 40) + 48));
  return Security::CodeSigning::SecCodeSigner::Signer::populate((uint64_t)v4, a2, v5, v5 + 88, v7, v8, v9, v10, v11, (_QWORD *)v12 + 5, *(_DWORD *)(a1 + 48));
}

__n128 __Block_byref_object_copy__40(_QWORD *a1, uint64_t a2)
{
  __n128 result;

  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__41(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void ___ZN8Security11CodeSigning13SecCodeSigner6Signer9signMachOEPNS_9UniversalERKNS0_11Requirement7ContextE_block_invoke_42(uint64_t a1, Security::CodeSigning::CodeDirectory::Builder *this)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  _QWORD *v7;
  unint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  unint64_t *v14;
  unint64_t v15;

  v2 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8);
  v3 = Security::CodeSigning::CodeDirectory::Builder::size(this, 0x20500u);
  v4 = v3;
  v6 = (unint64_t *)v2[6];
  v5 = v2[7];
  if ((unint64_t)v6 >= v5)
  {
    v8 = (unint64_t *)v2[5];
    v9 = v6 - v8;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    v11 = v5 - (_QWORD)v8;
    if (v11 >> 2 > v10)
      v10 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      if (v12 >> 61)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v13 = (char *)operator new(8 * v12);
    }
    else
    {
      v13 = 0;
    }
    v14 = (unint64_t *)&v13[8 * v9];
    *v14 = v4;
    v7 = v14 + 1;
    while (v6 != v8)
    {
      v15 = *--v6;
      *--v14 = v15;
    }
    v2[5] = v14;
    v2[6] = v7;
    v2[7] = &v13[8 * v12];
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v6 = v3;
    v7 = v6 + 1;
  }
  v2[6] = v7;
}

uint64_t *__Block_byref_object_copy__44(uint64_t *result, _QWORD *a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t **v5;
  _QWORD *v6;
  _QWORD *v7;
  unsigned int *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  BOOL v13;
  unsigned int v14;
  uint64_t **v15;
  uint64_t **v16;
  uint64_t *v17;
  _QWORD *v18;
  _QWORD *v19;
  unsigned int v20;

  v3 = result;
  result[6] = 0;
  v4 = result + 6;
  result[5] = (uint64_t)(result + 6);
  v5 = (uint64_t **)(result + 5);
  result[7] = 0;
  v6 = (_QWORD *)a2[5];
  v7 = a2 + 6;
  if (v6 != a2 + 6)
  {
    do
    {
      v8 = (unsigned int *)(v6 + 4);
      v9 = (uint64_t *)*v4;
      v10 = v4;
      if (*v5 == v4)
        goto LABEL_8;
      v11 = (uint64_t *)*v4;
      v12 = v4;
      if (v9)
      {
        do
        {
          v10 = v11;
          v11 = (uint64_t *)v11[1];
        }
        while (v11);
      }
      else
      {
        do
        {
          v10 = (uint64_t *)v12[2];
          v13 = *v10 == (_QWORD)v12;
          v12 = v10;
        }
        while (v13);
      }
      v14 = *v8;
      if (*((_DWORD *)v10 + 8) < *v8)
      {
LABEL_8:
        if (v9)
          v15 = (uint64_t **)v10;
        else
          v15 = (uint64_t **)v4;
        if (v9)
          v16 = (uint64_t **)(v10 + 1);
        else
          v16 = (uint64_t **)v4;
      }
      else
      {
        v15 = (uint64_t **)v4;
        v16 = (uint64_t **)v4;
        if (v9)
        {
          v16 = (uint64_t **)v4;
          while (1)
          {
            while (1)
            {
              v15 = (uint64_t **)v9;
              v20 = *((_DWORD *)v9 + 8);
              if (v14 >= v20)
                break;
              v9 = *v15;
              v16 = v15;
              if (!*v15)
                goto LABEL_15;
            }
            if (v20 >= v14)
              break;
            v16 = v15 + 1;
            v9 = v15[1];
            if (!v9)
              goto LABEL_15;
          }
        }
      }
      if (!*v16)
      {
LABEL_15:
        v17 = (uint64_t *)operator new(0x30uLL);
        *((_OWORD *)v17 + 2) = *(_OWORD *)v8;
        result = std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(v5, (uint64_t)v15, v16, v17);
      }
      v18 = (_QWORD *)v6[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (_QWORD *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (_QWORD *)v6[2];
          v13 = *v19 == (_QWORD)v6;
          v6 = v19;
        }
        while (!v13);
      }
      v6 = v19;
    }
    while (v19 != v7);
  }
  v3[8] = a2[8];
  return result;
}

void sub_18AA4956C(_Unwind_Exception *a1)
{
  _QWORD **v1;

  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_dispose__45(uint64_t a1)
{
  return Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker(a1 + 40);
}

void ___ZN8Security11CodeSigning13SecCodeSigner6Signer9signMachOEPNS_9UniversalERKNS0_11Requirement7ContextE_block_invoke_46(uint64_t a1, Security::CodeSigning::CodeDirectory::Builder *this)
{
  const Security::CodeSigning::CodeDirectory *v3;

  v3 = (const Security::CodeSigning::CodeDirectory *)Security::CodeSigning::CodeDirectory::Builder::build(this);
  Security::CodeSigning::CodeDirectorySet::add((Security::CodeSigning::CodeDirectorySet *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), v3);
}

_DWORD *Security::Blob<Security::SuperBlob<4208856065u,unsigned int>,4208856065u>::specific(_DWORD *result)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  int *v4;
  unint64_t v5;
  unsigned int v6;
  unint64_t v7;
  BOOL v8;

  if (*result == 17620730
    && (v1 = bswap32(result[2]), v2 = 8 * v1 + 12, v3 = bswap32(result[1]), v2 <= v3))
  {
    v5 = (unint64_t)&result[2 * v1 + 3];
    while (1)
    {
      v5 -= 8;
      if (v5 < (unint64_t)(result + 3))
        break;
      v6 = *(_DWORD *)(v5 + 4);
      if (v6)
      {
        v7 = bswap32(v6);
        v8 = v2 > v7 || v7 + 8 > v3;
        if (v8 || bswap32(*(_DWORD *)((char *)result + v7 + 4)) + v7 > v3)
          return 0;
      }
    }
  }
  else
  {
    v4 = __error();
    result = 0;
    *v4 = 22;
  }
  return result;
}

const void **Security::CFRef<__CFString *>::~CFRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

_DWORD *Security::CodeSigning::SecCodeSigner::Signer::addPreEncryptHashes(uint64_t **a1, Security::CodeSigning::SecStaticCode *this)
{
  _DWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  BOOL v9;
  uint64_t **v10;
  _QWORD *v11;
  _QWORD *v12;
  CFDataRef v13;
  unsigned int v14;

  result = Security::CodeSigning::SecStaticCode::codeDirectories(this, 1);
  if (result)
  {
    v4 = result + 2;
    v5 = *(_QWORD **)result;
    if (*(_DWORD **)result != result + 2)
    {
      do
      {
        v6 = *((_DWORD *)v5 + 8);
        v14 = v6;
        result = CFDataGetBytePtr((CFDataRef)v5[5]);
        if (bswap32(result[2]) >> 8 >= 0x205)
        {
          v7 = result[23];
          v9 = v7 == 0;
          v8 = bswap32(v7);
          v9 = v9 || (_DWORD *)((char *)result + v8) == 0;
          if (!v9)
          {
            v13 = (CFDataRef)0xAAAAAAAAAAAAAAAALL;
            v13 = CFDataCreate(0, (const UInt8 *)result + v8, bswap32(result[7]) * *((unsigned __int8 *)result + 36));
            v10 = std::__tree<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(a1, v6, &v14);
            Security::CFRef<__CFData const*>::operator=((CFTypeRef *)v10 + 5, (CFTypeRef *)&v13);
            result = Security::CFRef<__CFData const*>::~CFRef((const void **)&v13);
          }
        }
        v11 = (_QWORD *)v5[1];
        if (v11)
        {
          do
          {
            v12 = v11;
            v11 = (_QWORD *)*v11;
          }
          while (v11);
        }
        else
        {
          do
          {
            v12 = (_QWORD *)v5[2];
            v9 = *v12 == (_QWORD)v5;
            v5 = v12;
          }
          while (!v9);
        }
        v5 = v12;
      }
      while (v12 != v4);
    }
  }
  return result;
}

void sub_18AA497A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  Security::CFRef<__CFData const*>::~CFRef(&a9);
  _Unwind_Resume(a1);
}

_DWORD *Security::CodeSigning::SecCodeSigner::Signer::addRuntimeVersions(uint64_t **a1, Security::CodeSigning::SecStaticCode *this)
{
  _DWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  unsigned int v12;

  result = Security::CodeSigning::SecStaticCode::codeDirectories(this, 1);
  if (result)
  {
    v4 = result + 2;
    v5 = *(_QWORD **)result;
    if (*(_DWORD **)result != result + 2)
    {
      do
      {
        v6 = *((_DWORD *)v5 + 8);
        v12 = v6;
        result = CFDataGetBytePtr((CFDataRef)v5[5]);
        if (bswap32(result[2]) >> 8 >= 0x205)
        {
          v7 = result[22];
          if (v7)
          {
            v8 = bswap32(v7);
            result = std::__tree<std::__value_type<unsigned int,unsigned int>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,unsigned int>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(a1, v6, &v12);
            result[8] = v8;
          }
        }
        v9 = (_QWORD *)v5[1];
        if (v9)
        {
          do
          {
            v10 = v9;
            v9 = (_QWORD *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            v10 = (_QWORD *)v5[2];
            v11 = *v10 == (_QWORD)v5;
            v5 = v10;
          }
          while (!v11);
        }
        v5 = v10;
      }
      while (v10 != v4);
    }
  }
  return result;
}

void ___ZN8Security11CodeSigning13SecCodeSigner6Signer14buildResourcesENSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEES9_PK14__CFDictionary_block_invoke(_QWORD *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8;
  BOOL v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[6];
  std::string v15;
  std::string v16;
  std::string __p;
  uint64_t v18;
  int v19;
  BOOL v20;
  BOOL v21;
  const void *v22;
  std::string v23;
  std::string v24;

  v8 = a1[4];
  v9 = *(unsigned __int16 *)(a2 + 88) == 12;
  memset(&v24, 170, sizeof(v24));
  std::string::basic_string[abi:ne180100]<0>(&v24, *(char **)(a2 + 48));
  memset(&v23, 170, sizeof(v23));
  std::string::basic_string[abi:ne180100]<0>(&v23, *(char **)(a2 + 40));
  v22 = 0;
  v10 = (const void *)a1[5];
  if (v10)
    CFRetain(v10);
  v22 = 0;
  v11 = *(_QWORD *)(*(_QWORD *)(v8 + 8) + 288);
  v14[0] = MEMORY[0x1E0C809B0];
  v14[1] = 1174405120;
  v14[2] = ___ZN8Security11CodeSigning13SecCodeSigner6Signer14buildResourcesENSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEES9_PK14__CFDictionary_block_invoke_2;
  v14[3] = &__block_descriptor_tmp_24_14684;
  v12 = a1[5];
  v13 = a1[6];
  v14[4] = v8;
  v14[5] = v12;
  v20 = (a3 & 4) != 0;
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v15, v24.__r_.__value_.__l.__data_, v24.__r_.__value_.__l.__size_);
  else
    v15 = v24;
  if (*(char *)(a4 + 23) < 0)
    std::string::__init_copy_ctor_external(&v16, *(const std::string::value_type **)a4, *(_QWORD *)(a4 + 8));
  else
    v16 = *(std::string *)a4;
  v21 = v9;
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, v23.__r_.__value_.__l.__data_, v23.__r_.__value_.__l.__size_);
  else
    __p = v23;
  v18 = a1[7];
  v19 = a3;
  Security::CodeSigning::LimitedAsync::perform(*(_QWORD *)(v11 + 8), v13, (uint64_t)v14);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v16.__r_.__value_.__l.__data_);
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v15.__r_.__value_.__l.__data_);
  Security::CFRef<__CFDictionary *>::~CFRef(&v22);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
}

void sub_18AA49B20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  uint64_t v32;

  if (a26 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  Security::CFRef<__CFDictionary *>::~CFRef((const void **)(v32 - 120));
  if (*(char *)(v32 - 89) < 0)
    operator delete(*(void **)(v32 - 112));
  if (*(char *)(v32 - 65) < 0)
    operator delete(*(void **)(v32 - 88));
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__14669(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  return result;
}

const void **__Block_byref_object_dispose__14670(uint64_t a1)
{
  return Security::CFRef<__CFDictionary *>::~CFRef((const void **)(a1 + 40));
}

void sub_18AA49F60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, const void *a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  Security::CFRef<__CFData const*>::~CFRef(&a20);
  _Unwind_Resume(a1);
}

void sub_18AA4A684(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,_QWORD *a22,uint64_t a23,char a24,int a25,__int16 a26,char a27,char a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,int a37,__int16 a38,char a39,char a40,int a41,__int16 a42,char a43,char a44)
{
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::UnixPlusPlus::FileDesc *)&a38);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a22);
  JUMPOUT(0x18AA4A8A8);
}

void sub_18AA4A724(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,char a23,std::string *a24,uint64_t a25,void *__pa,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,char a34,__int128 a35,uint64_t a36)
{
  uint64_t v36;
  __int128 *v37;
  void *v40;
  const __CFURL *v41;
  Security::CodeSigning::CSError *v42;
  Security *v43;
  const void *v44;
  const __CFString *__pb;

  if (a31 < 0)
    operator delete(__pa);
  if (SHIBYTE(a36) < 0)
    operator delete((void *)a35);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&a34);
  if (a2 == 1)
  {
    v40 = __cxa_begin_catch(a1);
    v42 = (Security::CodeSigning::CSError *)(*(uint64_t (**)(void *))(*(_QWORD *)v40 + 24))(v40);
    if (*(char *)(v36 + 71) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)&a35, *(const std::string::value_type **)(v36 + 48), *(_QWORD *)(v36 + 56));
    }
    else
    {
      a35 = *v37;
      a36 = *((_QWORD *)v37 + 2);
    }
    if (a36 >= 0)
      v43 = (Security *)&a35;
    else
      v43 = (Security *)a35;
    __pb = (const __CFString *)Security::makeCFURL(v43, 0, 0, v41);
    Security::CodeSigning::CSError::throwMe(v42, (uint64_t)CFSTR("SecComponentPath"), __pb, v44);
  }
  JUMPOUT(0x18AA4A8A8);
}

void sub_18AA4A748(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, __int16 a6, char a7, char a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_list va;

  va_start(va, a17);
  Security::CFRef<__CFString const*>::~CFRef((const void **)va);
  if (a8 < 0)
    JUMPOUT(0x18AA4A768);
  JUMPOUT(0x18AA4A8A0);
}

void sub_18AA4A770()
{
  JUMPOUT(0x18AA4A778);
}

void sub_18AA4A78C()
{
  JUMPOUT(0x18AA4A798);
}

void sub_18AA4A7A4(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,__int128 a29,uint64_t a30)
{
  uint64_t v30;
  char *v31;
  __int128 *v32;
  char *v33;
  void *v36;
  const __CFURL *v37;
  Security::CodeSigning::CSError *v38;
  Security *v39;
  const void *v40;
  const __CFString *CFURL;

  v33 = v31;
  Security::SecCFObject::operator delete(v33);
  if (a2 == 1)
  {
    v36 = __cxa_begin_catch(a1);
    v38 = (Security::CodeSigning::CSError *)(*(uint64_t (**)(void *))(*(_QWORD *)v36 + 24))(v36);
    if (*(char *)(v30 + 71) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)&a29, *(const std::string::value_type **)(v30 + 48), *(_QWORD *)(v30 + 56));
    }
    else
    {
      a29 = *v32;
      a30 = *((_QWORD *)v32 + 2);
    }
    if (a30 >= 0)
      v39 = (Security *)&a29;
    else
      v39 = (Security *)a29;
    CFURL = (const __CFString *)Security::makeCFURL(v39, 0, 0, v37);
    Security::CodeSigning::CSError::throwMe(v38, (uint64_t)CFSTR("SecComponentPath"), CFURL, v40);
  }
  JUMPOUT(0x18AA4A8A8);
}

void sub_18AA4A7BC()
{
  JUMPOUT(0x18AA4A7C4);
}

void sub_18AA4A848(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  __cxa_end_catch();
  JUMPOUT(0x18AA4A8A8);
}

void sub_18AA4A884(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  if (a2)
    __clang_call_terminate(exception_object);
  _Unwind_Resume(exception_object);
}

void __copy_helper_block_e8_48c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE72c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE96c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(std::string *a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  std::string *v6;
  __int128 v7;

  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(a1 + 2, *(const std::string::value_type **)(a2 + 48), *(_QWORD *)(a2 + 56));
  }
  else
  {
    v4 = *(_OWORD *)(a2 + 48);
    a1[2].__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 64);
    *(_OWORD *)&a1[2].__r_.__value_.__l.__data_ = v4;
  }
  if (*(char *)(a2 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(a1 + 3, *(const std::string::value_type **)(a2 + 72), *(_QWORD *)(a2 + 80));
  }
  else
  {
    v5 = *(_OWORD *)(a2 + 72);
    a1[3].__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 88);
    *(_OWORD *)&a1[3].__r_.__value_.__l.__data_ = v5;
  }
  v6 = a1 + 4;
  if (*(char *)(a2 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 96), *(_QWORD *)(a2 + 104));
  }
  else
  {
    v7 = *(_OWORD *)(a2 + 96);
    a1[4].__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 112);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
}

void sub_18AA4A974(_Unwind_Exception *exception_object)
{
  void **v1;
  uint64_t v2;
  void **v3;

  if (*(char *)(v2 + 95) < 0)
    operator delete(*v3);
  if (*(char *)(v2 + 71) < 0)
    operator delete(*v1);
  _Unwind_Resume(exception_object);
}

void __destroy_helper_block_e8_48c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE72c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE96c67_ZTSKNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 119) < 0)
    operator delete(*(void **)(a1 + 96));
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
}

CFTypeRef *Security::CodeSigning::SecCodeSigner::Signer::prepareForEdit(Security::CodeSigning::SecCodeSigner::Signer *this)
{
  Security::Universal *v2;
  Security::Universal *v3;
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  _QWORD v12[5];
  _QWORD v13[5];
  _BYTE v14[8];
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, Security::CodeSigning::SecStaticCode *);
  void *v19;
  _QWORD *v20;
  uint64_t v21;

  std::set<unsigned int>::set[abi:ne180100]((uint64_t)v14, (_QWORD *)(*((_QWORD *)this + 2) + 344));
  (*(void (**)(Security::CodeSigning::SecCodeSigner::Signer *, _BYTE *))(*(_QWORD *)this + 32))(this, v14);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v15);
  if ((*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 2) + 32) + 80))(*(_QWORD *)(*((_QWORD *)this + 2) + 32))
    && (v2 = (Security::Universal *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(*((_QWORD *)this + 2) + 32)
                                                                      + 80))(*(_QWORD *)(*((_QWORD *)this + 2) + 32))) != 0)
  {
    v3 = v2;
    *((_QWORD *)this + 43) = Security::Universal::bestNativeArch(v2);
    if (*((_QWORD *)v3 + 4))
      goto LABEL_9;
    v6 = *((_QWORD *)this + 1);
    v7 = *(_DWORD *)(v6 + 304);
    if (v7 && !*((_QWORD *)v3 + 1))
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02, v4, v5);
    if (*(_QWORD *)(v6 + 312) && !v7 && *((_QWORD *)v3 + 1))
LABEL_9:
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA23, v4, v5);
  }
  else
  {
    Security::MainMachOImage::MainMachOImage((Security::MainMachOImage *)&v16);
    *((int8x8_t *)this + 43) = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(BYTE1(v20) == 0), 0x1FuLL)), *(int8x8_t *)(v17 + 4), vrev32_s8(*(int8x8_t *)(v17 + 4)));
  }
  v8 = MEMORY[0x1E0C809B0];
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 0x40000000;
  v13[2] = ___ZN8Security11CodeSigning13SecCodeSigner6Signer14prepareForEditEj_block_invoke;
  v13[3] = &__block_descriptor_tmp_70_14706;
  v13[4] = this;
  ___ZN8Security11CodeSigning13SecCodeSigner6Signer14prepareForEditEj_block_invoke((uint64_t)v13, *((_QWORD *)this + 2), *((const char **)this + 43));
  v9 = *((_QWORD *)this + 2);
  v12[0] = v8;
  v12[1] = 0x40000000;
  v12[2] = ___ZN8Security11CodeSigning13SecCodeSigner6Signer14prepareForEditEj_block_invoke_2;
  v12[3] = &unk_1E1FDCFE8;
  v12[4] = v13;
  v16 = v8;
  v17 = 0x40000000;
  v18 = ___ZN8Security11CodeSigning13SecStaticCode24handleOtherArchitecturesEU13block_pointerFvPS1_E_block_invoke;
  v19 = &unk_1E1FDCC70;
  v20 = v12;
  v21 = v9;
  Security::CodeSigning::SecStaticCode::visitOtherArchitectures(v9, (uint64_t)&v16);
  v10 = (const void *)(*(uint64_t (**)(_QWORD, uint64_t))(**((_QWORD **)this + 3) + 24))(*((_QWORD *)this + 3), 3);
  return Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this + 13, v10);
}

void sub_18AA4ABCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,_QWORD *a21)
{
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a21);
  _Unwind_Resume(a1);
}

char *std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, _QWORD *a3)
{
  int *v5;
  char *v6;
  int v7;
  int v8;
  _BOOL4 v9;
  uint64_t **v10;
  _BOOL4 v11;
  int v12;
  char *v13;
  uint64_t *v14;
  uint64_t *v15;

  v6 = (char *)(a1 + 1);
  v5 = (int *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v6 = (char *)v5;
        v7 = v5[8];
        v8 = *((_DWORD *)v6 + 9);
        v9 = SHIDWORD(a2) < v8;
        if ((_DWORD)a2 != v7)
          v9 = (int)a2 < v7;
        if (!v9)
          break;
        v5 = *(int **)v6;
        v10 = (uint64_t **)v6;
        if (!*(_QWORD *)v6)
          goto LABEL_14;
      }
      v11 = v8 < SHIDWORD(a2);
      v12 = (_DWORD)a2 == v7 ? v11 : v7 < (int)a2;
      if (v12 != 1)
        break;
      v10 = (uint64_t **)(v6 + 8);
      v5 = (int *)*((_QWORD *)v6 + 1);
      if (!v5)
        goto LABEL_14;
    }
  }
  else
  {
    v10 = a1 + 1;
LABEL_14:
    v13 = v6;
    v6 = (char *)operator new(0x30uLL);
    *((_QWORD *)v6 + 4) = *a3;
    *((_QWORD *)v6 + 5) = 0;
    *(_QWORD *)v6 = 0;
    *((_QWORD *)v6 + 1) = 0;
    *((_QWORD *)v6 + 2) = v13;
    *v10 = (uint64_t *)v6;
    v14 = (uint64_t *)**a1;
    v15 = (uint64_t *)v6;
    if (v14)
    {
      *a1 = v14;
      v15 = *v10;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v15);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6;
}

void ___ZN8Security11CodeSigning13SecCodeSigner6Signer14prepareForEditEj_block_invoke(uint64_t a1, uint64_t a2, const char *a3)
{
  const void *v3;
  uint64_t v5;
  void (***v6)(_QWORD *__return_ptr);
  void (***v7)(_QWORD *__return_ptr);
  void (***v8)(_QWORD *__return_ptr);
  _QWORD *v9;
  uint64_t v10;
  const void **v11;
  _QWORD *v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  int v16;
  _BOOL4 v17;
  const void *v18;
  uint64_t **v19;
  uint64_t v20;
  uint64_t **v21;
  uint64_t v22;
  int v23;
  _DWORD *v24;
  uint64_t v25;
  const char *v26;
  const void ***v27;
  const void **v28;
  unint64_t v29;

  v26 = a3;
  v3 = *(const void **)(a2 + 32);
  if (!v3
    || (v5 = *(_QWORD *)(a1 + 32),
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA23, a2, a3);
  }
  v7 = v6;
  if (v8)
  {
    v8 = (void (***)(_QWORD *__return_ptr))v8[13];
    if (v8)
  }
  if (!v8)
    v8 = v7;
  (**v8)(&v27);
  v9 = (_QWORD *)operator new();
  v10 = (uint64_t)v9;
  v11 = v28;
  *v9 = v27;
  v9[1] = v11;
  v12 = v9 + 1;
  v13 = v29;
  v9[2] = v29;
  if (v13)
  {
    v11[2] = v12;
    v27 = &v28;
    v28 = 0;
    v29 = 0;
  }
  else
  {
    *v9 = v12;
  }
  v14 = std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>((uint64_t **)(v5 + 352), (uint64_t)a3, &v26);
  v25 = 0;
  std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>::reset[abi:ne180100]((uint64_t *)v14 + 5, v10);
  std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>::reset[abi:ne180100](&v25, 0);
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(v28);
  v15 = *(_QWORD *)(v5 + 8);
  v16 = *(_DWORD *)(v15 + 304);
  if (v16 != (_DWORD)a3)
  {
    v17 = 0;
    if (!v16)
      goto LABEL_16;
LABEL_15:
    if (!v17)
      return;
    goto LABEL_16;
  }
  v17 = ((*(_DWORD *)(v15 + 308) ^ HIDWORD(a3)) & 0xFFFFFF) == 0;
  if (v16)
    goto LABEL_15;
LABEL_16:
  v18 = *(const void **)(v15 + 312);
  if (v18)
  {
    v19 = (uint64_t **)*((_QWORD *)std::__tree<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::__map_value_compare<Security::Architecture,std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>,std::less<Security::Architecture>,true>,std::allocator<std::__value_type<Security::Architecture,std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>>>>::__emplace_unique_key_args<Security::Architecture,std::piecewise_construct_t const&,std::tuple<Security::Architecture const&>,std::tuple<>>((uint64_t **)(v5 + 352), (uint64_t)a3, &v26)+ 5);
    v20 = (uint64_t)v19[1];
    v21 = v19 + 1;
    v22 = (uint64_t)(v19 + 1);
    if (v20)
    {
      while (1)
      {
        while (1)
        {
          v22 = v20;
          v23 = *(_DWORD *)(v20 + 32);
          if (v23 <= 0x10000)
            break;
          v20 = *(_QWORD *)v22;
          v21 = (uint64_t **)v22;
          if (!*(_QWORD *)v22)
            goto LABEL_24;
        }
        if (v23 == 0x10000)
          break;
        v20 = *(_QWORD *)(v22 + 8);
        if (!v20)
        {
          v21 = (uint64_t **)(v22 + 8);
          goto LABEL_24;
        }
      }
    }
    else
    {
LABEL_24:
      v29 = 0xAAAAAAAAAAAAAA01;
      v24 = operator new(0x30uLL);
      v28 = (const void **)(v19 + 1);
      v24[8] = 0x10000;
      *((_QWORD *)v24 + 5) = 0;
      std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__insert_node_at(v19, v22, v21, (uint64_t *)v24);
      v27 = 0;
      std::unique_ptr<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,void *>>>>::reset[abi:ne180100]((uint64_t)&v27);
      v22 = (uint64_t)v24;
    }
    Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)(v22 + 40), v18);
  }
}

void sub_18AA4AF2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, const void **a13)
{
  std::unique_ptr<std::map<int,Security::CFCopyRef<__CFData const*>>>::reset[abi:ne180100](&a10, 0);
  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(a13);
  _Unwind_Resume(a1);
}

uint64_t ___ZN8Security11CodeSigning13SecCodeSigner6Signer14prepareForEditEj_block_invoke_2(uint64_t a1, uint64_t a2)
{
  Security::Universal *v3;

  v3 = (Security::Universal *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a2 + 32) + 80))(*(_QWORD *)(a2 + 32));
  Security::Universal::bestNativeArch(v3);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

CFDataRef Security::CodeSigning::MachORep::identification(Security::CodeSigning::MachORep *this)
{
  off_t *v1;
  const void **v2;
  Security::MachO *v3;
  CFDataRef v4;

  v1 = (off_t *)(*(uint64_t (**)(Security::CodeSigning::MachORep *))(*(_QWORD *)this + 80))(this);
  v2 = (const void **)Security::Universal::architecture(v1);
  v4 = Security::CodeSigning::MachORep::identificationFor(v2, v3);
  (*((void (**)(const void **))*v2 + 1))(v2);
  return v4;
}

void sub_18AA4AFE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::MachORep::prepareForSigning(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  Security::MachOBase *v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  _QWORD **v13;
  BOOL v14;
  _QWORD **v15;
  _QWORD *v16[2];
  _BYTE v17[8];
  _QWORD *v18;
  unsigned int v19[2];
  _QWORD *v20[2];

  if (!*(_QWORD *)((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2) + 16))
  {
    v16[0] = 0;
    v16[1] = 0;
    v15 = v16;
    Security::Universal::architectures(*(uint64_t **)(a1 + 56), (uint64_t *)&v15);
    v4 = (uint64_t)v15;
    if (v15 == v16)
      goto LABEL_19;
    v5 = 0;
    do
    {
      v6 = (Security::MachOBase *)Security::Universal::architecture(*(Security::Universal **)(a1 + 56), (const Security::Architecture *)*(unsigned int *)(v4 + 28), *(_DWORD *)(v4 + 32));
      v19[0] = -1431655766;
      v7 = Security::MachOBase::version(v6, v19, 0, 0);
      v8 = v19[0];
      if (!v7)
        v8 = 0;
      v9 = 658180;
      v10 = 1;
      switch(v8)
      {
        case 0u:
        case 4u:
          break;
        case 1u:
          goto LABEL_8;
        case 2u:
        case 3u:
          v9 = 720896;
LABEL_8:
          v19[0] = -1431655766;
          v11 = Security::MachOBase::version(v6, 0, v19, 0) ^ 1;
          if (v19[0] < v9)
            v11 = 1;
          v10 = v11 | v5;
          break;
        default:
          v10 = v5;
          break;
      }
      (*(void (**)(Security::MachOBase *))(*(_QWORD *)v6 + 8))(v6);
      v12 = *(_QWORD **)(v4 + 8);
      if (v12)
      {
        do
        {
          v13 = (_QWORD **)v12;
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          v13 = *(_QWORD ***)(v4 + 16);
          v14 = *v13 == (_QWORD *)v4;
          v4 = (uint64_t)v13;
        }
        while (!v14);
      }
      v5 = v10;
      v4 = (uint64_t)v13;
    }
    while (v13 != v16);
    if ((v10 & 1) == 0)
    {
LABEL_19:
      v20[0] = 0;
      v20[1] = 0;
      *(_QWORD *)v19 = v20;
      std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)v19, 2u, 2);
      std::set<unsigned int>::set[abi:ne180100]((uint64_t)v17, v19);
      (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)a2 + 32))(a2, v17);
      std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v18);
      std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v20[0]);
    }
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v16[0]);
  }
}

void sub_18AA4B1CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11, uint64_t a12, uint64_t a13, _QWORD *a14, uint64_t a15, uint64_t a16, _QWORD *a17)
{
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a14);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a17);
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a11);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::MachORep::signingLimit(off_t **this)
{
  Security::MachO *v1;
  uint64_t v2;

  v1 = (Security::MachO *)Security::Universal::architecture(this[7]);
  v2 = Security::MachO::signingExtent(v1);
  (*(void (**)(Security::MachO *))(*(_QWORD *)v1 + 8))(v1);
  return v2;
}

void sub_18AA4B25C(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::MachORep::execSegBase(Security::CodeSigning::MachORep *this, const Security::Architecture *a2)
{
  Security::Universal *v2;
  Security::MachOBase *v3;
  Security::MachOBase *v4;
  char v5;
  const char *v6;
  char v7;
  unint64_t Segment;
  uint64_t v9;
  unsigned int v11;

  v2 = (Security::Universal *)*((_QWORD *)this + 7);
  if (a2)
    v3 = (Security::MachOBase *)Security::Universal::architecture(v2, (const Security::Architecture *)*(unsigned int *)a2, *((_DWORD *)a2 + 1));
  else
    v3 = (Security::MachOBase *)Security::Universal::architecture((off_t *)v2);
  v4 = v3;
  v11 = -1431655766;
  v5 = Security::MachOBase::version(v3, &v11, 0, 0);
  if (v11)
    v7 = v5;
  else
    v7 = 0;
  if ((v7 & 1) != 0 && (Segment = Security::MachOBase::findSegment(v4, v6)) != 0)
  {
    if (*((_BYTE *)v4 + 32))
      v9 = *(_QWORD *)(Segment + 40);
    else
      v9 = *(unsigned int *)(Segment + 32);
  }
  else
  {
    v9 = 0;
  }
  (*(void (**)(Security::MachOBase *))(*(_QWORD *)v4 + 8))(v4);
  return v9;
}

void sub_18AA4B31C(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::MachORep::execSegLimit(Security::CodeSigning::MachORep *this, const Security::Architecture *a2)
{
  Security::Universal *v2;
  Security::MachOBase *v3;
  Security::MachOBase *v4;
  char v5;
  const char *v6;
  char v7;
  unint64_t Segment;
  uint64_t v9;
  unsigned int v11;

  v2 = (Security::Universal *)*((_QWORD *)this + 7);
  if (a2)
    v3 = (Security::MachOBase *)Security::Universal::architecture(v2, (const Security::Architecture *)*(unsigned int *)a2, *((_DWORD *)a2 + 1));
  else
    v3 = (Security::MachOBase *)Security::Universal::architecture((off_t *)v2);
  v4 = v3;
  v11 = -1431655766;
  v5 = Security::MachOBase::version(v3, &v11, 0, 0);
  if (v11)
    v7 = v5;
  else
    v7 = 0;
  if ((v7 & 1) != 0 && (Segment = Security::MachOBase::findSegment(v4, v6)) != 0)
  {
    if (*((_BYTE *)v4 + 32))
      v9 = *(_QWORD *)(Segment + 48);
    else
      v9 = *(unsigned int *)(Segment + 36);
  }
  else
  {
    v9 = 0;
  }
  (*(void (**)(Security::MachOBase *))(*(_QWORD *)v4 + 8))(v4);
  return v9;
}

void sub_18AA4B3E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::MachORep::platformType(Security::CodeSigning::MachORep *this, const Security::Architecture *a2)
{
  Security::Universal *v2;
  Security::MachOBase *v3;
  Security::MachOBase *v4;
  int v5;
  unsigned int v6;
  unsigned int v8;
  unsigned int v9[2];

  v2 = (Security::Universal *)*((_QWORD *)this + 7);
  if (a2)
    v3 = (Security::MachOBase *)Security::Universal::architecture(v2, (const Security::Architecture *)*(unsigned int *)a2, *((_DWORD *)a2 + 1));
  else
    v3 = (Security::MachOBase *)Security::Universal::architecture((off_t *)v2);
  v4 = v3;
  *(_QWORD *)v9 = 0;
  v8 = 0;
  v5 = Security::MachOBase::version(v3, &v9[1], v9, &v8);
  v6 = v9[1];
  (*(void (**)(Security::MachOBase *))(*(_QWORD *)v4 + 8))(v4);
  if (v5)
    return v6;
  else
    return 0;
}

void sub_18AA4B480(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t Security::CodeSigning::MachORep::flush(Security::CodeSigning::MachORep *this)
{
  uint64_t v2;
  off_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  unsigned int v8;
  char v9;

  v2 = *((_QWORD *)this + 7);
  v3 = *(_QWORD *)(v2 + 32);
  v4 = *(_QWORD *)(v2 + 40);
  free(*(void **)(v2 + 8));
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(*(_QWORD **)(v2 + 56));
  MEMORY[0x18D76FAA0](v2, 0x1020C4076728D04);
  *((_QWORD *)this + 7) = 0;
  free(*((void **)this + 8));
  *((_QWORD *)this + 8) = 0;
  Security::UnixPlusPlus::FileDesc::close((Security::CodeSigning::MachORep *)((char *)this + 40));
  v5 = operator new();
  v6 = (*(uint64_t (**)(Security::CodeSigning::MachORep *))(*(_QWORD *)this + 144))(this);
  v8 = *(_DWORD *)v6;
  v9 = *(_BYTE *)(v6 + 4);
  result = Security::Universal::Universal(v5, &v8, v3, v4);
  *((_QWORD *)this + 7) = v5;
  return result;
}

void sub_18AA4B564(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x1020C4076728D04);
  _Unwind_Resume(a1);
}

const void **Security::CodeSigning::MachORep::registerStapledTicket(Security::CodeSigning::MachORep *this)
{
  const __CFData *v1;
  Security::CodeSigning *v3;

  v3 = (Security::CodeSigning *)(*(uint64_t (**)(Security::CodeSigning::MachORep *))(*(_QWORD *)this + 176))(this);
  Security::CodeSigning::registerStapledTicketWithSystem(v3, v1);
  return Security::CFRef<__CFData const*>::~CFRef((const void **)&v3);
}

CFDataRef Security::CodeSigning::MachORep::copyStapledTicket(Security::CodeSigning::MachORep *this, uint64_t a2, const Security::BlobCore *a3)
{
  Security::CodeSigning::EmbeddedSignatureBlob *v3;
  CFDataRef v4;
  CFTypeRef cf;

  cf = 0;
  v3 = (Security::CodeSigning::EmbeddedSignatureBlob *)*((_QWORD *)this + 8);
  if (v3)
    v4 = Security::CodeSigning::EmbeddedSignatureBlob::component(v3, (Security::CodeSigning::EmbeddedSignatureBlob *)0x10002, a3);
  else
    v4 = 0;
  cf = 0;
  Security::CFRef<__CFData const*>::~CFRef(&cf);
  return v4;
}

void sub_18AA4B61C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::MachORep::recommendedIdentifier(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  void *v4;
  void *__p[3];

  memset(__p, 170, sizeof(__p));
  (*(void (**)(void **__return_ptr))(*(_QWORD *)a1 + 192))(__p);
  v4 = (void *)HIBYTE(__p[2]);
  if (SHIBYTE(__p[2]) < 0)
    v4 = __p[1];
  if (v4)
  {
    *(_OWORD *)a2 = *(_OWORD *)__p;
    *(void **)(a2 + 16) = __p[2];
  }
  else
  {
    Security::CodeSigning::DiskRep::canonicalIdentifier((std::string *)a2, a1 + 16);
    if (SHIBYTE(__p[2]) < 0)
      operator delete(__p[0]);
  }
}

void sub_18AA4B6BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

const void **Security::CodeSigning::MachORep::explicitIdentifier@<X0>(Security::CodeSigning::MachORep *this@<X0>, std::string *a2@<X8>)
{
  const __CFData *v3;
  const __CFData *v4;
  CFPropertyListRef CFDictionaryFrom;
  const __CFString *Value;
  const __CFString *v7;
  CFTypeID v8;
  const void *v10;

  v3 = (const __CFData *)Security::CodeSigning::MachORep::infoPlist(this);
  if (!v3)
    return (const void **)std::string::basic_string[abi:ne180100]<0>(a2, (char *)&unk_18AA61AAF);
  CFDictionaryFrom = Security::makeCFDictionaryFrom(v3, v4);
  v10 = CFDictionaryFrom;
  if (!CFDictionaryFrom)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ELL);
  Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)CFDictionaryFrom, (const void *)*MEMORY[0x1E0C9AE78]);
  v7 = Value;
  if (!Value)
  {
    Security::CFRef<__CFDictionary const*>::~CFRef(&v10);
    return (const void **)std::string::basic_string[abi:ne180100]<0>(a2, (char *)&unk_18AA61AAF);
  }
  v8 = CFGetTypeID(Value);
  if (v8 != CFStringGetTypeID())
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ELL);
  Security::cfString(a2, v7);
  return Security::CFRef<__CFDictionary const*>::~CFRef(&v10);
}

void sub_18AA4B798(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

_DWORD *Security::CodeSigning::MachORep::defaultRequirements(uint64_t a1, unsigned int *a2)
{
  Security::Universal *v4;
  uint64_t v5;
  _DWORD *v6;
  const load_command *Command;
  unsigned int cmdsize;
  unsigned int v9;
  unsigned int cmd;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  size_t v15;
  _DWORD *Blob;
  _DWORD *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t *v21;
  void *v22;
  _DWORD *v23;
  unint64_t v25;
  unsigned int v26;
  unint64_t v27;
  BOOL v28;
  NSObject *v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int *v36;
  BOOL v37;
  NSObject *v38;
  NSObject *v39;
  const char *v40;
  uint32_t v41;
  unsigned int v42;
  unsigned int v44;
  NSObject *v46;
  unsigned int v47;
  const __CFString *v48;
  Security::MacOSError *v49;
  Security::MacOSError *v50;
  const UInt8 *BytePtr;
  uint64_t v52;
  void *v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  std::string *v57;
  uint64_t v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  cpu_type_t v62;
  unsigned int v63;
  const NXArchInfo *v64;
  uint64_t v65;
  unsigned int v66;
  const char *name;
  uint64_t *v68;
  _QWORD v69[2];
  CFDataRef data;
  SecRequirementRef requirement;
  std::string v72;
  _QWORD v73[2];
  uint64_t v74;
  void *v75;
  unint64_t v76;
  _BYTE buf[28];
  __int16 v78;
  const char *v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v69[0] = 0;
  v69[1] = 0;
  v68 = v69;
  v4 = (Security::Universal *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 80))(a1);
  v5 = Security::Universal::architecture(v4, (const Security::Architecture *)*a2, a2[1]);
  v75 = (void *)0xAAAAAAAAAAAAAAAALL;
  v76 = 0xAAAAAAAA00000400;
  v6 = malloc_type_malloc(0x400uLL, 0x96562061uLL);
  v75 = v6;
  *(_QWORD *)v6 = 843514;
  v6[2] = 0x1000000;
  HIDWORD(v76) = 12;
  v73[0] = 0xAAAAAAAA0000000CLL;
  v73[1] = &v75;
  v74 = 7;
  Command = Security::MachOBase::findCommand((Security::MachOBase *)v5, 43);
  if (!Command)
    goto LABEL_16;
  cmdsize = Command->cmdsize;
  v9 = bswap32(cmdsize);
  if (*(_BYTE *)(v5 + 33))
    cmdsize = v9;
  if (cmdsize <= 0xF)
    Security::UnixError::throwMe((Security::UnixError *)8);
  cmd = Command[1].cmd;
  v11 = Command[1].cmdsize;
  v12 = bswap32(cmd);
  v13 = *(_BYTE *)(v5 + 33) ? v12 : cmd;
  v14 = bswap32(v11);
  v15 = *(_BYTE *)(v5 + 33) ? v14 : v11;
  Blob = Security::BlobCore::readBlob((Security::BlobCore *)*(unsigned int *)(v5 + 36), *(_QWORD *)(v5 + 48) + v13, -86111227, v15);
  v17 = Blob;
  if (!Blob)
    goto LABEL_16;
  if (*Blob != 84729594
    || (v18 = bswap32(Blob[2]), v19 = 8 * v18 + 12, v20 = bswap32(Blob[1]), v19 > v20))
  {
    *__error() = 22;
LABEL_15:
    free(v17);
LABEL_16:
    v21 = 0;
    v22 = v75;
    goto LABEL_17;
  }
  v25 = (unint64_t)&Blob[2 * v18 + 3];
  while (1)
  {
    v25 -= 8;
    if (v25 < (unint64_t)(Blob + 3))
      break;
    v26 = *(_DWORD *)(v25 + 4);
    if (v26)
    {
      v27 = bswap32(v26);
      v28 = v19 > v27 || v27 + 8 > v20;
      if (v28 || bswap32(*(_DWORD *)((char *)Blob + v27 + 4)) + v27 > v20)
        goto LABEL_15;
    }
  }
  v29 = secLogObjForScope("machorep");
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
  {
    v56 = v17[1];
    v55 = v17[2];
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(_QWORD *)a1 + 40))(&v72, a1);
    if ((v72.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v57 = &v72;
    else
      v57 = (std::string *)v72.__r_.__value_.__r.__words[0];
    v58 = *(_QWORD *)(v5 + 8);
    v60 = *(_DWORD *)(v58 + 4);
    v59 = *(_DWORD *)(v58 + 8);
    v61 = bswap32(v60);
    if (*(_BYTE *)(v5 + 33))
      v62 = v61;
    else
      v62 = v60;
    v63 = bswap32(v59);
    if (*(_BYTE *)(v5 + 33))
      v59 = v63;
    v64 = NXGetArchInfoFromCpuType(v62, v59 & 0xFFFFFF);
    v65 = bswap32(v56);
    v66 = bswap32(v55);
    if (v64)
      name = v64->name;
    else
      name = 0;
    *(_DWORD *)buf = 134218754;
    *(_QWORD *)&buf[4] = v65;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v66;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = v57;
    v78 = 2080;
    v79 = name;
    _os_log_debug_impl(&dword_18A900000, v29, OS_LOG_TYPE_DEBUG, "%zd library dependency bytes in %d blob(s) from %s(%s)", buf, 0x26u);
    if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v72.__r_.__value_.__l.__data_);
  }
  v30 = v17[2];
  if (!v30)
    goto LABEL_15;
  v31 = 0;
  v32 = bswap32(v30);
  if (v32 <= 1)
    v33 = 1;
  else
    v33 = v32;
  v34 = 4;
  do
  {
    v35 = v17[v34];
    v36 = (_DWORD *)((char *)v17 + bswap32(v35));
    if (v35)
      v37 = v36 == 0;
    else
      v37 = 1;
    if (v37)
    {
      v38 = secLogObjForScope("machorep");
      if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
        goto LABEL_70;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v31;
      v39 = v38;
      v40 = "missing DR info for library index %d";
      v41 = 8;
      goto LABEL_42;
    }
    v42 = bswap32(v36[1]);
    if (*v36 == 843514 && v42 > 0xB)
      goto LABEL_68;
    *__error() = 22;
    v44 = bswap32(v36[1]);
    if (*v36 == 17555194 && v44 > 7)
    {
      memset(buf, 170, 24);
      std::string::basic_string[abi:ne180100](buf, v36 + 2, bswap32(v36[1]) - 8);
      requirement = 0;
      if ((buf[23] & 0x80000000) != 0)
        std::string::__init_copy_ctor_external(&v72, *(const std::string::value_type **)buf, *(std::string::size_type *)&buf[8]);
      else
        v72 = *(std::string *)buf;
      Security::CFTempString::CFTempString<std::string>((CFStringRef *)&data, (char *)&v72);
      v48 = (const __CFString *)data;
      if (requirement)
        CFRelease(requirement);
      requirement = 0;
      v49 = (Security::MacOSError *)SecRequirementCreateWithStringAndErrors(v48, 0, 0, &requirement);
      if ((_DWORD)v49)
        Security::MacOSError::throwMe(v49);
      Security::CFRef<__CFString const*>::~CFRef((const void **)&data);
      if (SHIBYTE(v72.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v72.__r_.__value_.__l.__data_);
      data = 0;
      v50 = (Security::MacOSError *)SecRequirementCopyData(requirement, 0, &data);
      if ((_DWORD)v50)
        Security::MacOSError::throwMe(v50);
      BytePtr = CFDataGetBytePtr(data);
      v36 = (unsigned int *)BytePtr;
      if (BytePtr && (*(_DWORD *)BytePtr != 843514 || bswap32(*((_DWORD *)BytePtr + 1)) <= 0xB))
      {
        v36 = 0;
        *__error() = 22;
      }
      Security::CFRef<__CFData const*>::~CFRef((const void **)&data);
      Security::CFRef<__SecRequirement *>::~CFRef((const void **)&requirement);
      if ((buf[23] & 0x80000000) != 0)
        operator delete(*(void **)buf);
LABEL_68:
      Security::CodeSigning::Requirement::Maker::Chain::add(v73);
      if (v36[2] != 0x1000000)
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA15);
      v52 = bswap32(v36[1]) - 12;
      v53 = (void *)Security::CodeSigning::Requirement::Maker::alloc((Security::CodeSigning::Requirement::Maker *)&v75, v52);
      memcpy(v53, v36 + 3, v52);
      goto LABEL_70;
    }
    *__error() = 22;
    v46 = secLogObjForScope("machorep");
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
    {
      v47 = bswap32(*v36);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v47;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v31;
      v39 = v46;
      v40 = "unexpected blob type 0x%x in slot %d of binary dependencies";
      v41 = 14;
LABEL_42:
      _os_log_debug_impl(&dword_18A900000, v39, OS_LOG_TYPE_DEBUG, v40, buf, v41);
    }
LABEL_70:
    ++v31;
    v34 += 2;
  }
  while (v33 != v31);
  v54 = HIDWORD(v74);
  free(v17);
  v21 = (uint64_t *)v75;
  if (v54)
  {
    v22 = 0;
    *((_DWORD *)v75 + 1) = bswap32(HIDWORD(v76));
    v75 = 0;
  }
  else
  {
    v22 = v75;
    v21 = 0;
  }
LABEL_17:
  free(v22);
  (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  if (v21)
    Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add(&v68, 4u, v21);
  v23 = Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::make(&v68);
  Security::SuperBlobCore<Security::CodeSigning::EmbeddedSignatureBlob,4208856256u,unsigned int>::Maker::~Maker((uint64_t)&v68);
  return v23;
}

void sub_18AA4BDD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17, int a18, const void *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  void *v36;

  if (a2)
  {
    Security::CFRef<__SecRequirement *>::~CFRef(&a19);
    if (a36 < 0)
      operator delete(__p);
    __cxa_begin_catch(exception_object);
    free(v36);
    __cxa_rethrow();
  }
  _Unwind_Resume(exception_object);
}

void sub_18AA4BEA8()
{
  __cxa_end_catch();
  JUMPOUT(0x18AA4BEB0);
}

void sub_18AA4BECC(void *a1, int a2)
{
  if (a2)
    __clang_call_terminate(a1);
  JUMPOUT(0x18AA4BEE8);
}

uint64_t Security::CodeSigning::MachORep::pageSize()
{
  return 4096;
}

void Security::CodeSigning::MachORep::strictValidate(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  BOOL v12;
  uint64_t *v13;
  uint64_t v14;
  unsigned __int8 *v15;
  int v16;
  _QWORD *v17;
  _QWORD **v18;
  BOOL v19;
  _QWORD **v20;
  _QWORD *v21[2];

  Security::CodeSigning::SingleDiskRep::strictValidate((char *)a1, a2, a3, a4);
  v6 = *(_QWORD *)(a1 + 56);
  if (!*(_BYTE *)(v6 + 76))
  {
    v21[0] = 0;
    v21[1] = 0;
    v20 = v21;
    Security::Universal::architectures((uint64_t *)v6, (uint64_t *)&v20);
    v14 = (uint64_t)v20;
    if (v20 == v21)
    {
LABEL_21:
      std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v21[0]);
      return;
    }
    while (1)
    {
      v15 = (unsigned __int8 *)Security::Universal::architecture((Security::Universal *)v6, (const Security::Architecture *)*(unsigned int *)(v14 + 28), *(_DWORD *)(v14 + 32));
      v16 = v15[104];
      (*(void (**)(unsigned __int8 *))(*(_QWORD *)v15 + 8))(v15);
      if (v16)
        break;
      v17 = *(_QWORD **)(v14 + 8);
      if (v17)
      {
        do
        {
          v18 = (_QWORD **)v17;
          v17 = (_QWORD *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          v18 = *(_QWORD ***)(v14 + 16);
          v19 = *v18 == (_QWORD *)v14;
          v14 = (uint64_t)v18;
        }
        while (!v19);
      }
      v14 = (uint64_t)v18;
      if (v18 == v21)
        goto LABEL_21;
    }
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(v21[0]);
  }
  v9 = *(_QWORD *)(a3 + 8);
  v8 = a3 + 8;
  v7 = v9;
  if (!v9)
    goto LABEL_12;
  v10 = v8;
  do
  {
    v11 = *(_DWORD *)(v7 + 28);
    v12 = v11 < -67010;
    if (v11 >= -67010)
      v13 = (uint64_t *)v7;
    else
      v13 = (uint64_t *)(v7 + 8);
    if (!v12)
      v10 = v7;
    v7 = *v13;
  }
  while (*v13);
  if (v10 == v8 || *(int *)(v10 + 28) > -67010)
LABEL_12:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA3ELL);
}

void sub_18AA4C024(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, _QWORD *a11)
{
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::destroy(a11);
  _Unwind_Resume(a1);
}

Security::CodeSigning::SingleDiskRep::Writer *Security::CodeSigning::MachORep::writer(Security::CodeSigning::MachORep *this)
{
  Security::CodeSigning::SingleDiskRep::Writer *v2;

  v2 = (Security::CodeSigning::SingleDiskRep::Writer *)operator new();
  Security::CodeSigning::SingleDiskRep::Writer::Writer(v2, this, 2);
  *(_QWORD *)v2 = &off_1E1FC8F88;
  return v2;
}

void sub_18AA4C090(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x18D76FAA0](v1, 0x10A1C40A67EDFA3);
  _Unwind_Resume(a1);
}

CFTypeRef *Security::CodeSigning::MachORep::createRawComponents@<X0>(Security::CodeSigning::MachORep *this@<X0>, uint64_t a2@<X8>)
{
  CFTypeRef *result;
  const Security::BlobCore *v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int *v8;
  Security::CodeSigning::EmbeddedSignatureBlob *v9;
  const UInt8 *v10;
  const UInt8 *v11;
  CFDataRef v12;
  uint64_t **v13;
  int v14;

  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = a2 + 8;
  if (!Security::CodeSigning::MachORep::signingData(this))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA0ALL);
  result = (CFTypeRef *)Security::CodeSigning::MachORep::signingData(this);
  v6 = (uint64_t)result;
  if (*((_DWORD *)result + 2))
  {
    v7 = 0;
    v8 = (unsigned int *)(result + 2);
    do
    {
      v9 = (Security::CodeSigning::EmbeddedSignatureBlob *)bswap32(*(v8 - 1));
      v14 = (int)v9;
      v10 = (const UInt8 *)(bswap32(*v8) + v6);
      if (*v8)
        v11 = v10;
      else
        v11 = 0;
      v12 = Security::CodeSigning::EmbeddedSignatureBlob::blobData(v9, v11, v5);
      v13 = std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t **)a2, (int)v9, &v14);
      result = Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)v13 + 5, v12);
      v8 += 2;
      ++v7;
    }
    while (v7 < bswap32(*(_DWORD *)(v6 + 8)));
  }
  return result;
}

void sub_18AA4C198(_Unwind_Exception *a1)
{
  const void ***v1;

  std::__tree<std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::__map_value_compare<int,std::__value_type<int,Security::CFCopyRef<__CFData const*>>,std::less<int>,true>,std::allocator<std::__value_type<int,Security::CFCopyRef<__CFData const*>>>>::destroy(*v1);
  _Unwind_Resume(a1);
}

CFTypeRef *`non-virtual thunk to'Security::CodeSigning::MachORep::createRawComponents@<X0>(Security::CodeSigning::MachORep *this@<X0>, uint64_t a2@<X8>)
{
  return Security::CodeSigning::MachORep::createRawComponents((Security::CodeSigning::MachORep *)((char *)this - 48), a2);
}

void Security::CodeSigning::MachORep::Writer::~Writer(Security::CodeSigning::MachORep::Writer *this)
{
  *(_QWORD *)this = off_1E1FC8BC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::MachORep::Writer *)((char *)this + 96));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer((_QWORD *)this + 3);
}

{
  *(_QWORD *)this = off_1E1FC8BC8;
  Security::UnixPlusPlus::FileDesc::closeAndLog((Security::CodeSigning::MachORep::Writer *)((char *)this + 96));
  Security::RefPointer<Security::CodeSigning::SingleDiskRep>::~RefPointer((_QWORD *)this + 3);
  JUMPOUT(0x18D76FAA0);
}

void Security::CodeSigning::MachORep::Writer::component(Security::CodeSigning::MachORep::Writer *this, const char *a2, const __CFData *a3)
{
  Security::Syslog::notice((Security::Syslog *)"code signing internal error: trying to write Mach-O component directly", a2, a3);
  Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA18);
}

CFTypeRef Security::CodeSigning::MachORep::infoPlist(Security::CodeSigning::MachORep *this)
{
  off_t *v1;
  unsigned __int8 *v2;
  const char *v3;
  unsigned int *Segment;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  size_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  CFTypeRef v26;
  CFTypeRef cf;

  cf = 0;
  v1 = (off_t *)(*(uint64_t (**)(Security::CodeSigning::MachORep *))(*(_QWORD *)this + 80))(this);
  v2 = (unsigned __int8 *)Security::Universal::architecture(v1);
  Segment = (unsigned int *)Security::MachOBase::findSegment((Security::MachOBase *)v2, v3);
  if (!Segment)
    goto LABEL_41;
  v5 = v2[32];
  if (!v2[32])
  {
    v12 = Segment[12];
    LODWORD(v13) = Segment[1];
    v6 = v2[33];
    v14 = bswap32(v13);
    if (v2[33])
      v13 = v14;
    else
      v13 = v13;
    if (68 * (unint64_t)v12 + 56 > v13)
      goto LABEL_41;
    v15 = bswap32(v12);
    v16 = v2[33] ? v15 : Segment[12];
    if (!v16)
      goto LABEL_41;
    v11 = Segment + 14;
    while (strncmp((const char *)v11, "__info_plist", 0x10uLL))
    {
      v11 += 17;
      if (!--v16)
        goto LABEL_41;
    }
    goto LABEL_27;
  }
  v6 = v2[33];
  v7 = bswap32(Segment[1]);
  if (!v2[33])
    v7 = Segment[1];
  if (v7 <= 0x47)
    Security::UnixError::throwMe((Security::UnixError *)8);
  v8 = Segment[16];
  if (80 * (unint64_t)v8 + 72 <= v7)
  {
    v9 = bswap32(v8);
    v10 = v2[33] ? v9 : Segment[16];
    if (v10)
    {
      v11 = Segment + 18;
      while (strncmp((const char *)v11, "__info_plist", 0x10uLL))
      {
        v11 += 20;
        if (!--v10)
          goto LABEL_41;
      }
LABEL_27:
      if (v5)
      {
        v17 = v11[12];
        v18 = bswap32(v17);
        if (v6)
          v19 = v18;
        else
          v19 = v17;
        v20 = bswap64(*((_QWORD *)v11 + 5));
        if (v6)
          v21 = v20;
        else
          v21 = *((_QWORD *)v11 + 5);
      }
      else
      {
        v23 = v11[9];
        v22 = v11[10];
        v24 = bswap32(v22);
        if (v6)
          v19 = v24;
        else
          v19 = v22;
        v25 = bswap32(v23);
        if (v6)
          v21 = v25;
        else
          v21 = v23;
      }
      cf = Security::MachO::dataAt((Security::MachO *)v2, v19, v21);
    }
  }
LABEL_41:
  (*(void (**)(unsigned __int8 *))(*(_QWORD *)v2 + 8))(v2);
  v26 = cf;
  cf = 0;
  Security::CFRef<__CFData const*>::~CFRef(&cf);
  return v26;
}

void sub_18AA4C43C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  uint64_t v9;
  NSObject *v11;

  (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  __cxa_begin_catch(a1);
  v11 = secLogObjForScope("machorep");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    a9 = 0;
    _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, "exception reading embedded Info.plist", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x18AA4C404);
}

void sub_18AA4C4B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

CFDataRef Security::CodeSigning::MachORep::identificationFor(const void **this, Security::MachO *a2)
{
  const load_command *Command;
  unsigned int cmdsize;
  unsigned int v5;
  const UInt8 *p_c;
  __int128 v7;
  unsigned int v8;
  CC_LONG v9;
  unsigned __int8 md[24];
  CC_SHA1_CTX c;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  Command = Security::MachOBase::findCommand((Security::MachOBase *)this, 27);
  if (Command)
  {
    cmdsize = Command->cmdsize;
    v5 = bswap32(cmdsize);
    if (*((_BYTE *)this + 33))
      cmdsize = v5;
    if (cmdsize != 24)
      Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA1BLL);
    c.h0 = 1145656661;
    *(_OWORD *)&c.h1 = *(_OWORD *)&Command[1].cmd;
    p_c = (const UInt8 *)&c;
  }
  else
  {
    *(_QWORD *)&v7 = 0xAAAAAAAAAAAAAAAALL;
    *((_QWORD *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&c.data[9] = v7;
    *(_OWORD *)&c.data[13] = v7;
    *(_OWORD *)&c.data[1] = v7;
    *(_OWORD *)&c.data[5] = v7;
    *(_OWORD *)&c.h0 = v7;
    *(_OWORD *)&c.h4 = v7;
    CC_SHA1_Init(&c);
    CC_SHA1_Update(&c, this[1], 0x1Cu);
    v8 = bswap32(*((_DWORD *)this[1] + 5));
    if (*((_BYTE *)this + 33))
      v9 = v8;
    else
      v9 = *((_DWORD *)this[1] + 5);
    CC_SHA1_Update(&c, this[2], v9);
    memset(md, 170, 20);
    CC_SHA1_Final(md, &c);
    p_c = md;
  }
  return CFDataCreate(0, p_c, 20);
}

void Security::CodeSigning::EmbeddedSignatureBlob::Maker::component(uint64_t **this, Security::CodeSigning::CodeDirectory *a2, const __CFData *a3)
{
  unsigned int v4;
  unsigned int v6;
  Security::BlobCore *BytePtr;
  Security::BlobWrapper *v8;
  CFIndex Length;
  uint64_t *v10;

  v4 = a2;
  v6 = Security::CodeSigning::CodeDirectory::slotAttributes(a2);
  BytePtr = (Security::BlobCore *)CFDataGetBytePtr(a3);
  v8 = BytePtr;
  if (v6 >= 2)
  {
    v10 = (uint64_t *)Security::BlobCore::clone(BytePtr);
  }
  else
  {
    Length = CFDataGetLength(a3);
    v10 = (uint64_t *)Security::BlobWrapper::alloc(v8, Length);
  }
  Security::SuperBlobCore<Security::SuperBlob<4208856065u,unsigned int>,4208856065u,unsigned int>::Maker::add(this, v4, v10);
}

CFPropertyListRef Security::CodeSigning::EntitlementBlob::entitlements(Security::CodeSigning::EntitlementBlob *this)
{
  const __CFData *v1;
  CFPropertyListRef CFDictionaryFrom;
  const __CFData *v4;

  v4 = CFDataCreate(0, (const UInt8 *)this + 8, bswap32(*((_DWORD *)this + 1)) - 8);
  CFDictionaryFrom = Security::makeCFDictionaryFrom(v4, v1);
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v4);
  return CFDictionaryFrom;
}

void sub_18AA4C6AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  Security::CFRef<__CFData const*>::~CFRef((const void **)va);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::ResourceBuilder::addRule(Security::CodeSigning::ResourceBuilder *this, __CFString *a2, const void *a3)
{
  CFTypeID v5;
  int v6;
  int v7;
  const void *Value;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  BOOL v13;
  int v14;
  int v16;
  int v17;
  regex_t *v19;
  unint64_t v20;
  regex_t **v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  regex_t **v29;
  unint64_t v30;
  char *v31;
  char *v32;
  regex_t *v33;
  CFDictionaryRef theDict;
  unint64_t v35;
  std::string __p;
  void *key;

  memset(&__p, 170, sizeof(__p));
  Security::cfString(&__p, a2);
  v5 = CFGetTypeID(a3);
  if (v5 == CFBooleanGetTypeID())
  {
    v6 = 2 * (*MEMORY[0x1E0C9AE40] == (_QWORD)a3);
    v7 = 1;
  }
  else
  {
    theDict = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
    v35 = 0xAAAAAAAAAAAAAAAALL;
    Security::CFDictionary::CFDictionary((Security::CFDictionary *)&theDict, a3);
    Security::CFTempString::CFTempString<char const*>((CFStringRef *)&key, "weight");
    Value = CFDictionaryGetValue(theDict, key);
    Security::CFRef<__CFNumber const*>::check<void const*>(Value, (Security::MacOSError *)v35);
    Security::CFRef<__CFString const*>::~CFRef((const void **)&key);
    if (Value)
      v7 = Security::cfNumber<unsigned int>((const __CFNumber *)Value);
    else
      v7 = 1;
    v9 = Security::CFDictionary::get<__CFBoolean const*>((uint64_t)&theDict, "omit");
    v10 = Security::CFDictionary::get<__CFBoolean const*>((uint64_t)&theDict, "optional");
    v11 = Security::CFDictionary::get<__CFBoolean const*>((uint64_t)&theDict, "nested");
    v12 = (const void *)*MEMORY[0x1E0C9AE50];
    if (v10)
      v13 = v10 == v12;
    else
      v13 = 0;
    v14 = v13;
    if (v9 != v12 || v9 == 0)
      v16 = 0;
    else
      v16 = 2;
    v17 = v16 | v14;
    if (v11 != v12 || v11 == 0)
      v6 = v17;
    else
      v6 = v17 | 4;
    Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&theDict);
  }
  v19 = (regex_t *)operator new();
  Security::CodeSigning::ResourceBuilder::Rule::Rule(v19, (__int128 *)&__p, v7, v6 | 0x40);
  v21 = (regex_t **)*((_QWORD *)this + 9);
  v20 = *((_QWORD *)this + 10);
  if ((unint64_t)v21 >= v20)
  {
    v23 = *((_QWORD *)this + 8);
    v24 = ((uint64_t)v21 - v23) >> 3;
    if ((unint64_t)(v24 + 1) >> 61)
      std::vector<CESerializedElement>::__throw_length_error[abi:ne180100]();
    v25 = v20 - v23;
    v26 = v25 >> 2;
    if (v25 >> 2 <= (unint64_t)(v24 + 1))
      v26 = v24 + 1;
    if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8)
      v27 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v27 = v26;
    if (v27)
      v27 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<Security::CodeSigning::ResourceBuilder::Rule *>>(v27);
    else
      v28 = 0;
    v29 = (regex_t **)(v27 + 8 * v24);
    v30 = v27 + 8 * v28;
    *v29 = v19;
    v22 = v29 + 1;
    v32 = (char *)*((_QWORD *)this + 8);
    v31 = (char *)*((_QWORD *)this + 9);
    if (v31 != v32)
    {
      do
      {
        v33 = (regex_t *)*((_QWORD *)v31 - 1);
        v31 -= 8;
        *--v29 = v33;
      }
      while (v31 != v32);
      v31 = (char *)*((_QWORD *)this + 8);
    }
    *((_QWORD *)this + 8) = v29;
    *((_QWORD *)this + 9) = v22;
    *((_QWORD *)this + 10) = v30;
    if (v31)
      operator delete(v31);
  }
  else
  {
    *v21 = v19;
    v22 = v21 + 1;
  }
  *((_QWORD *)this + 9) = v22;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_18AA4C8F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)&a9);
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t Security::CFDictionary::Applier<Security::CodeSigning::ResourceBuilder>::apply(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t (*v5)(_QWORD *, uint64_t, uint64_t);
  uint64_t v6;
  _QWORD *v7;

  v5 = (uint64_t (*)(_QWORD *, uint64_t, uint64_t))a3[1];
  v6 = a3[2];
  v7 = (_QWORD *)(*a3 + (v6 >> 1));
  if ((v6 & 1) != 0)
    v5 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t))(*v7 + v5);
  return v5(v7, a1, a2);
}

regex_t *Security::CodeSigning::ResourceBuilder::Rule::Rule(regex_t *a1, __int128 *a2, int a3, int a4)
{
  __int128 v8;
  const char *v9;
  NSObject *v10;
  const std::string::value_type *v12;
  int v13;
  regex_t *v14;
  __int16 v15;
  const std::string::value_type *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  a1[1].re_magic = a3;
  *(&a1[1].re_magic + 1) = a4;
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)&a1[1].re_nsub, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v8 = *a2;
    a1[1].re_g = (re_guts *)*((_QWORD *)a2 + 2);
    *(_OWORD *)&a1[1].re_nsub = v8;
  }
  if (*((char *)a2 + 23) >= 0)
    v9 = (const char *)a2;
  else
    v9 = *(const char **)a2;
  if (regcomp(a1, v9, 5))
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA13);
  v10 = secLogObjForScope("csresource");
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)a2 + 23) >= 0)
      v12 = (const std::string::value_type *)a2;
    else
      v12 = *(const std::string::value_type **)a2;
    v13 = 134218754;
    v14 = a1;
    v15 = 2080;
    v16 = v12;
    v17 = 1024;
    v18 = a3;
    v19 = 1024;
    v20 = a4;
    _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, "%p rule %s added (weight %d, flags 0x%x)", (uint8_t *)&v13, 0x22u);
  }
  return a1;
}

void sub_18AA4CAE0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 63) < 0)
    operator delete(*v2);
  _Unwind_Resume(exception_object);
}

std::string::size_type Security::CodeSigning::ResourceBuilder::ResourceBuilder(std::string::size_type a1, uint64_t a2, uint64_t a3, const void *a4, char a5, uint64_t a6)
{
  CFTypeRef *v10;
  std::string *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  BOOL v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;
  BOOL v22;
  uint64_t *v23;
  BOOL v24;
  const char *v25;
  std::string::size_type size;
  std::string::size_type v27;
  std::string *p_context;
  _BOOL4 v29;
  std::string::size_type v30;
  std::string::size_type v31;
  std::string::size_type v32;
  std::string *v33;
  _BOOL4 v34;
  std::string::size_type v35;
  std::string *v36;
  char *v37;
  uint64_t v38;
  char v39;
  size_t v40;
  uint64_t v41;
  int v42;
  std::string *v43;
  unsigned __int8 *v44;
  const void *v45;
  std::string *v46;
  const void *v47;
  uint64_t v48;
  uint64_t v49;
  std::string::size_type v50;
  int v51;
  std::string *v52;
  uint64_t v53;
  std::string *v54;
  int v55;
  int v56;
  int v57;
  BOOL v58;
  FTS *v60;
  int *v62;
  int *v63;
  CFDictionaryRef theDict[2];
  std::string __str;
  std::string context;
  std::string v67;
  std::string::value_type __b[1024];
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)(a1 + 56) = 0u;
  v10 = (CFTypeRef *)(a1 + 56);
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  v11 = (std::string *)(a1 + 24);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  if ((a5 & 1) != 0)
  {
    v14 = *(_QWORD *)(a6 + 8);
    v12 = a6 + 8;
    v13 = v14;
    if (!v14)
      goto LABEL_12;
    v15 = v12;
    v16 = v13;
    do
    {
      v17 = *(_DWORD *)(v16 + 28);
      v18 = v17 < -67060;
      if (v17 >= -67060)
        v19 = (uint64_t *)v16;
      else
        v19 = (uint64_t *)(v16 + 8);
      if (!v18)
        v15 = v16;
      v16 = *v19;
    }
    while (*v19);
    if (v15 == v12 || *(int *)(v15 + 28) > -67060)
LABEL_12:
      v15 = v12;
    *(_BYTE *)(a1 + 88) = v15 == v12;
    if (!v13)
      goto LABEL_23;
    v20 = v12;
    do
    {
      v21 = *(_DWORD *)(v13 + 28);
      v22 = v21 < -67016;
      if (v21 >= -67016)
        v23 = (uint64_t *)v13;
      else
        v23 = (uint64_t *)(v13 + 8);
      if (!v22)
        v20 = v13;
      v13 = *v23;
    }
    while (*v23);
    if (v20 == v12 || *(int *)(v20 + 28) > -67016)
LABEL_23:
      v20 = v12;
    v24 = v20 == v12;
  }
  else
  {
    v24 = 0;
    *(_BYTE *)(a1 + 88) = 0;
  }
  *(_BYTE *)(a1 + 89) = v24;
  memset(__b, 170, sizeof(__b));
  if (*(char *)(a2 + 23) >= 0)
    v25 = (const char *)a2;
  else
    v25 = *(const char **)a2;
  if (!realpath_DARWIN_EXTSN(v25, __b))
  {
LABEL_130:
    v62 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v62);
  }
  std::string::__assign_external((std::string *)a1, __b);
  if (*(char *)(a3 + 23) < 0)
    std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)a3, *(_QWORD *)(a3 + 8));
  else
    __str = *(std::string *)a3;
  size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __str.__r_.__value_.__l.__size_;
  std::string::basic_string(&context, &__str, size - 2, 2uLL, (std::allocator<char> *)theDict);
  v27 = HIBYTE(context.__r_.__value_.__r.__words[2]);
  if ((context.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v27 = context.__r_.__value_.__l.__size_;
  if (v27 != 2)
  {
    v29 = 0;
    if ((SHIBYTE(context.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_41;
LABEL_46:
    operator delete(context.__r_.__value_.__l.__data_);
    if (v29)
      goto LABEL_42;
    goto LABEL_47;
  }
  p_context = (std::string *)context.__r_.__value_.__r.__words[0];
  if ((context.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_context = &context;
  v29 = LOWORD(p_context->__r_.__value_.__l.__data_) == 11823;
  if (SHIBYTE(context.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_46;
LABEL_41:
  if (v29)
  {
LABEL_42:
    v30 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v30 = __str.__r_.__value_.__l.__size_;
    std::string::basic_string(&v67, &__str, 0, v30 - 2, (std::allocator<char> *)&context);
    goto LABEL_62;
  }
LABEL_47:
  v31 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v31 = __str.__r_.__value_.__l.__size_;
  std::string::basic_string(&context, &__str, v31 - 1, 1uLL, (std::allocator<char> *)theDict);
  v32 = HIBYTE(context.__r_.__value_.__r.__words[2]);
  if ((context.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v32 = context.__r_.__value_.__l.__size_;
  if (v32 != 1)
  {
    v34 = 0;
    if ((SHIBYTE(context.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_55;
LABEL_60:
    operator delete(context.__r_.__value_.__l.__data_);
    if (v34)
      goto LABEL_56;
LABEL_61:
    v67 = __str;
    memset(&__str, 0, sizeof(__str));
    goto LABEL_62;
  }
  v33 = (std::string *)context.__r_.__value_.__r.__words[0];
  if ((context.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v33 = &context;
  v34 = v33->__r_.__value_.__s.__data_[0] == 47;
  if (SHIBYTE(context.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_60;
LABEL_55:
  if (!v34)
    goto LABEL_61;
LABEL_56:
  v35 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v35 = __str.__r_.__value_.__l.__size_;
  std::string::basic_string(&v67, &__str, 0, v35 - 1, (std::allocator<char> *)&context);
LABEL_62:
  if ((v67.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v36 = &v67;
  else
    v36 = (std::string *)v67.__r_.__value_.__r.__words[0];
  v37 = realpath_DARWIN_EXTSN((const char *)v36, __b);
  if (SHIBYTE(v67.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v67.__r_.__value_.__l.__data_);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  if (!v37)
    goto LABEL_130;
  std::string::__assign_external(v11, __b);
  v38 = *(unsigned __int8 *)(a1 + 23);
  v39 = v38;
  if ((v38 & 0x80u) == 0)
    v40 = *(unsigned __int8 *)(a1 + 23);
  else
    v40 = *(_QWORD *)(a1 + 8);
  v41 = *(unsigned __int8 *)(a1 + 47);
  v42 = (char)v41;
  if ((v41 & 0x80u) != 0)
    v41 = *(_QWORD *)(a1 + 32);
  if (v40 == v41)
  {
    if (v42 >= 0)
      v43 = v11;
    else
      v43 = (std::string *)v11->__r_.__value_.__r.__words[0];
    if ((char)v38 < 0)
    {
      v45 = *(const void **)a1;
      if (!memcmp(*(const void **)a1, v43, *(_QWORD *)(a1 + 8)))
      {
        v67.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
        goto LABEL_124;
      }
    }
    else
    {
      if (!(_BYTE)v38)
      {
        v67.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
        v45 = (const void *)a1;
        goto LABEL_124;
      }
      v44 = (unsigned __int8 *)a1;
      while (*v44 == v43->__r_.__value_.__s.__data_[0])
      {
        ++v44;
        v43 = (std::string *)((char *)v43 + 1);
        if (!--v38)
          goto LABEL_113;
      }
    }
  }
  memset(&context, 170, sizeof(context));
  v46 = &context;
  std::string::basic_string[abi:ne180100]((uint64_t)&context, v40 + 9);
  if ((context.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v46 = (std::string *)context.__r_.__value_.__r.__words[0];
  if (v40)
  {
    if (*(char *)(a1 + 23) >= 0)
      v47 = (const void *)a1;
    else
      v47 = *(const void **)a1;
    memmove(v46, v47, v40);
  }
  strcpy((char *)v46 + v40, "/Contents");
  v48 = *(unsigned __int8 *)(a1 + 47);
  if ((v48 & 0x80u) == 0)
    v49 = *(unsigned __int8 *)(a1 + 47);
  else
    v49 = *(_QWORD *)(a1 + 32);
  v50 = HIBYTE(context.__r_.__value_.__r.__words[2]);
  v51 = SHIBYTE(context.__r_.__value_.__r.__words[2]);
  if ((context.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    v50 = context.__r_.__value_.__l.__size_;
  if (v49 == v50)
  {
    if ((context.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v52 = &context;
    else
      v52 = (std::string *)context.__r_.__value_.__r.__words[0];
    if ((v48 & 0x80) != 0)
    {
      v58 = memcmp(v11->__r_.__value_.__l.__data_, v52, *(_QWORD *)(a1 + 32)) != 0;
      if ((v51 & 0x80000000) == 0)
        goto LABEL_111;
    }
    else if (*(_BYTE *)(a1 + 47))
    {
      v53 = v48 - 1;
      v54 = v11;
      do
      {
        v56 = v54->__r_.__value_.__s.__data_[0];
        v54 = (std::string *)((char *)v54 + 1);
        v55 = v56;
        v57 = v52->__r_.__value_.__s.__data_[0];
        v52 = (std::string *)((char *)v52 + 1);
        v58 = v55 != v57;
      }
      while (v55 == v57 && v53-- != 0);
      if ((SHIBYTE(context.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_111:
        if (!v58)
          goto LABEL_112;
LABEL_117:
        Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA2CLL);
      }
    }
    else
    {
      v58 = 0;
      if ((SHIBYTE(context.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_111;
    }
  }
  else
  {
    v58 = 1;
    if ((SHIBYTE(context.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_111;
  }
  operator delete(context.__r_.__value_.__l.__data_);
  if (v58)
    goto LABEL_117;
LABEL_112:
  v39 = *(_BYTE *)(a1 + 23);
LABEL_113:
  v67.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  v45 = (const void *)a1;
  if (v39 < 0)
    v45 = *(const void **)a1;
LABEL_124:
  *(_OWORD *)&v67.__r_.__value_.__l.__data_ = (unint64_t)v45;
  v60 = fts_open(&v67.__r_.__value_.__l.__data_, 21, 0);
  *(_QWORD *)(a1 + 48) = v60;
  if (!v60)
  {
    v63 = __error();
    Security::UnixError::throwMe((Security::UnixError *)*v63);
  }
  if (a4)
    CFRetain(a4);
  if (*v10)
    CFRelease(*v10);
  *v10 = a4;
  theDict[0] = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  theDict[1] = (CFDictionaryRef)0xAAAAAAAAAAAAAAAALL;
  Security::CFDictionary::CFDictionary((Security::CFDictionary *)theDict, (const __CFDictionary *)a4, (Security::MacOSError *)0xFFFEFA13);
  context.__r_.__value_.__r.__words[0] = a1;
  context.__r_.__value_.__l.__size_ = (std::string::size_type)Security::CodeSigning::ResourceBuilder::addRule;
  context.__r_.__value_.__r.__words[2] = 0;
  CFDictionaryApplyFunction(theDict[0], (CFDictionaryApplierFunction)Security::CFDictionary::Applier<Security::CodeSigning::ResourceBuilder>::apply, &context);
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)theDict);
  return a1;
}

void sub_18AA4D0E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;
  void **v26;
  const void **v27;
  void *v29;

  v29 = *(void **)(v25 + 64);
  if (v29)
  {
    *(_QWORD *)(v25 + 72) = v29;
    operator delete(v29);
  }
  Security::CFRef<__CFDictionary const*>::~CFRef(v27);
  if (*(char *)(v25 + 47) < 0)
    operator delete(*v26);
  if (*(char *)(v25 + 23) < 0)
    operator delete(*(void **)v25);
  _Unwind_Resume(a1);
}

void Security::CodeSigning::ResourceBuilder::Rule::~Rule(void **this)
{
  MEMORY[0x18D770EEC]();
  if (*((char *)this + 63) < 0)
    operator delete(this[5]);
}

void Security::CodeSigning::ResourceBuilder::~ResourceBuilder(Security::CodeSigning::ResourceBuilder *this)
{
  void ***v2;
  void ***v3;
  void *v4;

  v3 = (void ***)*((_QWORD *)this + 8);
  v2 = (void ***)*((_QWORD *)this + 9);
  while (v3 != v2)
  {
    if (*v3)
    {
      Security::CodeSigning::ResourceBuilder::Rule::~Rule(*v3);
      MEMORY[0x18D76FAA0]();
      v2 = (void ***)*((_QWORD *)this + 9);
    }
    ++v3;
  }
  fts_close(*((FTS **)this + 6));
  v4 = (void *)*((_QWORD *)this + 8);
  if (v4)
  {
    *((_QWORD *)this + 9) = v4;
    operator delete(v4);
  }
  Security::CFRef<__CFDictionary const*>::~CFRef((const void **)this + 7);
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
  if (*((char *)this + 23) < 0)
    operator delete(*(void **)this);
}

void Security::CodeSigning::ResourceBuilder::scan(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  FTSENT *v6;
  FTSENT *v7;
  char v8;
  uint64_t v9;
  char *v10;
  std::string *v11;
  int v12;
  std::string *p_str;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  const void **v17;
  std::string *v18;
  std::string *v19;
  std::string::size_type v20;
  char v21;
  std::string::size_type size;
  std::string *v23;
  std::string::size_type v24;
  int v25;
  _BOOL4 v27;
  NSObject *v28;
  uint64_t Rule;
  uint64_t v30;
  NSObject *v31;
  NSObject *v32;
  std::string::size_type v33;
  std::string *v34;
  NSObject *v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  NSObject *v46;
  void *v47;
  const char *fts_name;
  size_t v49;
  NSObject *v50;
  int fts_info;
  int fts_errno;
  std::string::size_type v53;
  std::string::size_type v54;
  std::string::size_type fts_path;
  std::string::size_type v56;
  std::string::size_type v57;
  std::string::size_type v58;
  std::string *v59;
  std::string *v60;
  int v61;
  unsigned int v62;
  int v64;
  const void **v65;
  void *v66[2];
  char v67;
  void *v68[2];
  char v69;
  void *v70[2];
  char v71;
  void *v72[2];
  char v73;
  void *__p[2];
  char v75;
  _QWORD v76[2];
  char v77;
  _QWORD v78[2];
  char v79;
  void *v80[2];
  char v81;
  std::string __str;
  std::string v83;
  std::string v84;
  _BYTE v85[15];
  uint64_t v86;

  v5 = 0;
  v86 = *MEMORY[0x1E0C80C00];
  v62 = -67060;
  memset(&v83, 0, sizeof(v83));
  v65 = (const void **)(a1 + 24);
  v64 = 1;
  while (1)
  {
    v6 = fts_read(*(FTS **)(a1 + 48));
    v7 = v6;
    if (!v6)
      break;
    v8 = *(_BYTE *)(a1 + 23);
    if (v8 < 0)
      v9 = *(_QWORD *)(a1 + 8);
    else
      v9 = *(unsigned __int8 *)(a1 + 23);
    v10 = &v6->fts_path[v9];
    v12 = *v10;
    v11 = (std::string *)(v10 + 1);
    if (v12)
      p_str = v11;
    else
      p_str = (std::string *)&v6->fts_path[v9];
    memset(&__str, 0, sizeof(__str));
    v14 = *(unsigned __int8 *)(a1 + 47);
    if ((v14 & 0x80u) == 0)
      v15 = *(unsigned __int8 *)(a1 + 47);
    else
      v15 = *(_QWORD *)(a1 + 32);
    if (v15 != v9)
      goto LABEL_23;
    if (v8 >= 0)
      v16 = (unsigned __int8 *)a1;
    else
      v16 = *(unsigned __int8 **)a1;
    if ((v14 & 0x80) != 0)
    {
      if (memcmp(*v65, v16, *(_QWORD *)(a1 + 32)))
        goto LABEL_23;
    }
    else if (*(_BYTE *)(a1 + 47))
    {
      v17 = v65;
      while (*(unsigned __int8 *)v17 == *v16)
      {
        v17 = (const void **)((char *)v17 + 1);
        ++v16;
        if (!--v14)
          goto LABEL_49;
      }
LABEL_23:
      v18 = (std::string *)std::string::basic_string[abi:ne180100]<0>(&v84, (char *)p_str);
      v19 = std::string::insert(v18, 0, "../", 3uLL);
      v20 = v19->__r_.__value_.__r.__words[0];
      *(_QWORD *)v85 = v19->__r_.__value_.__l.__size_;
      *(_QWORD *)&v85[7] = *(std::string::size_type *)((char *)&v19->__r_.__value_.__r.__words[1] + 7);
      v21 = HIBYTE(v19->__r_.__value_.__r.__words[2]);
      v19->__r_.__value_.__l.__size_ = 0;
      v19->__r_.__value_.__r.__words[2] = 0;
      v19->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__str.__r_.__value_.__l.__data_);
      __str.__r_.__value_.__r.__words[0] = v20;
      __str.__r_.__value_.__l.__size_ = *(_QWORD *)v85;
      *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)&v85[7];
      *((_BYTE *)&__str.__r_.__value_.__s + 23) = v21;
      if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v84.__r_.__value_.__l.__data_);
      std::string::basic_string(&v84, &__str, 0, 0xCuLL, (std::allocator<char> *)v85);
      size = HIBYTE(v84.__r_.__value_.__r.__words[2]);
      if ((v84.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        size = v84.__r_.__value_.__l.__size_;
      if (size == 12)
      {
        v23 = (std::string *)v84.__r_.__value_.__r.__words[0];
        if ((v84.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v23 = &v84;
        v24 = v23->__r_.__value_.__r.__words[0];
        v25 = v23->__r_.__value_.__r.__words[1];
        v27 = v24 == 0x65746E6F432F2E2ELL && v25 == 796095598;
        if ((SHIBYTE(v84.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_39:
          if (v27)
          {
LABEL_43:
            std::string::basic_string(&v84, &__str, 0xCuLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)v85);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__str.__r_.__value_.__l.__data_);
            __str = v84;
          }
LABEL_46:
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            p_str = &__str;
          else
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          goto LABEL_49;
        }
      }
      else
      {
        v27 = 0;
        if ((SHIBYTE(v84.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_39;
      }
      operator delete(v84.__r_.__value_.__l.__data_);
      if (v27)
        goto LABEL_43;
      goto LABEL_46;
    }
LABEL_49:
    switch(v7->fts_info)
    {
      case 1u:
        v28 = secLogObjForScope("rdirenum");
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          fts_path = (std::string::size_type)v7->fts_path;
          LODWORD(v84.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v84.__r_.__value_.__r.__words + 4) = fts_path;
          _os_log_debug_impl(&dword_18A900000, v28, OS_LOG_TYPE_DEBUG, "entering %s", (uint8_t *)&v84, 0xCu);
        }
        ++GKBIS_Num_dirs;
        if (((v64 | v5) & 1) != 0)
          goto LABEL_122;
        std::string::basic_string[abi:ne180100]<0>(v68, (char *)p_str);
        Rule = Security::CodeSigning::ResourceBuilder::findRule(a1, (uint64_t)v68);
        v30 = Rule;
        if (v69 < 0)
        {
          operator delete(v68[0]);
          if (!v30)
            goto LABEL_121;
        }
        else if (!Rule)
        {
          goto LABEL_121;
        }
        v45 = *(unsigned int *)(v30 + 36);
        if ((v45 & 4) != 0)
        {
          if (strchr(v7->fts_name, 46))
          {
            std::string::basic_string[abi:ne180100]<0>(v66, (char *)p_str);
            (*(void (**)(uint64_t, FTSENT *, uint64_t, void **, uint64_t))(a2 + 16))(a2, v7, v45, v66, v30);
            if (v67 < 0)
              operator delete(v66[0]);
LABEL_120:
            fts_set(*(FTS **)(a1 + 48), v7, 4);
          }
LABEL_121:
          v5 = 0;
          goto LABEL_122;
        }
        if ((v45 & 0x10) == 0)
          goto LABEL_121;
        if (!a3)
          goto LABEL_120;
        std::string::__assign_external(&v83, (const std::string::value_type *)p_str);
        v46 = secLogObjForScope("rdirenum");
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
        {
          v60 = &v83;
          if ((v83.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
            v60 = (std::string *)v83.__r_.__value_.__r.__words[0];
          LODWORD(v84.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v84.__r_.__value_.__r.__words + 4) = (std::string::size_type)v60;
          _os_log_debug_impl(&dword_18A900000, v46, OS_LOG_TYPE_DEBUG, "entering excluded path: %s", (uint8_t *)&v84, 0xCu);
        }
        v5 = 1;
LABEL_122:
        fts_name = v7->fts_name;
        v49 = strlen(fts_name);
        if (v49 >= 6 && !strcasecmp(&fts_name[v49 - 6], ".lproj"))
        {
          v64 = 0;
          ++GKBIS_Num_localizations;
        }
        else
        {
          v64 = 0;
        }
LABEL_125:
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__str.__r_.__value_.__l.__data_);
        break;
      case 4u:
        v35 = secLogObjForScope("rdirenum");
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          v56 = (std::string::size_type)v7->fts_path;
          LODWORD(v84.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v84.__r_.__value_.__r.__words + 4) = v56;
          _os_log_debug_impl(&dword_18A900000, v35, OS_LOG_TYPE_DEBUG, "cannot read directory %s", (uint8_t *)&v84, 0xCu);
        }
        if (*(_BYTE *)(a1 + 88))
          goto LABEL_145;
        goto LABEL_125;
      case 6u:
        v32 = secLogObjForScope("rdirenum");
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          v54 = (std::string::size_type)v7->fts_path;
          LODWORD(v84.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v84.__r_.__value_.__r.__words + 4) = v54;
          _os_log_debug_impl(&dword_18A900000, v32, OS_LOG_TYPE_DEBUG, "leaving %s", (uint8_t *)&v84, 0xCu);
          if ((v5 & 1) == 0)
            goto LABEL_116;
        }
        else if ((v5 & 1) == 0)
        {
          goto LABEL_116;
        }
        if ((v83.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v33 = HIBYTE(v83.__r_.__value_.__r.__words[2]);
        else
          v33 = v83.__r_.__value_.__l.__size_;
        if (v33 == strlen((const char *)p_str)
          && ((v83.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? (v34 = &v83)
            : (v34 = (std::string *)v83.__r_.__value_.__r.__words[0]),
              !memcmp(v34, p_str, v33)))
        {
          v50 = secLogObjForScope("rdirenum");
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          {
            v59 = &v83;
            if ((v83.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              v59 = (std::string *)v83.__r_.__value_.__r.__words[0];
            LODWORD(v84.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)v84.__r_.__value_.__r.__words + 4) = (std::string::size_type)v59;
            _os_log_debug_impl(&dword_18A900000, v50, OS_LOG_TYPE_DEBUG, "exiting excluded path: %s", (uint8_t *)&v84, 0xCu);
          }
          v5 = 0;
          if (SHIBYTE(v83.__r_.__value_.__r.__words[2]) < 0)
          {
            *v83.__r_.__value_.__l.__data_ = 0;
            v83.__r_.__value_.__l.__size_ = 0;
          }
          else
          {
            v83.__r_.__value_.__s.__data_[0] = 0;
            *((_BYTE *)&v83.__r_.__value_.__s + 23) = 0;
          }
        }
        else
        {
          v5 = 1;
        }
        goto LABEL_125;
      case 8u:
        v36 = secLogObjForScope("rdirenum");
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        {
          v57 = (std::string::size_type)v7->fts_path;
          LODWORD(v84.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v84.__r_.__value_.__r.__words + 4) = v57;
          _os_log_debug_impl(&dword_18A900000, v36, OS_LOG_TYPE_DEBUG, "file %s", (uint8_t *)&v84, 0xCu);
        }
        ++GKBIS_Num_files;
        if (!strncasecmp(v7->fts_name, "._", 2uLL))
          ++GKBIS_Dot_underbar_Present;
        if (!strcasecmp(v7->fts_name, ".DS_Store"))
          ++GKBIS_DS_Store_Present;
        std::string::basic_string[abi:ne180100]<0>(v80, (char *)p_str);
        v37 = Security::CodeSigning::ResourceBuilder::findRule(a1, (uint64_t)v80);
        if (v81 < 0)
          operator delete(v80[0]);
        if ((v37 == 0) | v5 & 1 || (v38 = *(unsigned int *)(v37 + 36), (v38 & 0x12) != 0))
        {
          if (a3)
          {
            v39 = v37 ? *(unsigned int *)(v37 + 36) : 0;
            std::string::basic_string[abi:ne180100]<0>(v76, (char *)p_str);
            (*(void (**)(uint64_t, FTSENT *, uint64_t, _QWORD *, uint64_t))(a3 + 16))(a3, v7, v39, v76, v37);
            if (v77 < 0)
            {
              v44 = (void *)v76[0];
              goto LABEL_104;
            }
          }
          goto LABEL_125;
        }
        std::string::basic_string[abi:ne180100]<0>(v78, (char *)p_str);
        (*(void (**)(uint64_t, FTSENT *, uint64_t, _QWORD *, uint64_t))(a2 + 16))(a2, v7, v38, v78, v37);
        if ((v79 & 0x80000000) == 0)
          goto LABEL_116;
        v47 = (void *)v78[0];
        goto LABEL_115;
      case 0xCu:
        v40 = secLogObjForScope("rdirenum");
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
        {
          v58 = (std::string::size_type)v7->fts_path;
          LODWORD(v84.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)v84.__r_.__value_.__r.__words + 4) = v58;
          _os_log_debug_impl(&dword_18A900000, v40, OS_LOG_TYPE_DEBUG, "symlink %s", (uint8_t *)&v84, 0xCu);
        }
        ++GKBIS_Num_symlinks;
        if (!strcasecmp(v7->fts_name, ".DS_Store"))
        {
          v61 = -67012;
LABEL_144:
          v62 = v61;
LABEL_145:
          Security::MacOSError::throwMe((Security::MacOSError *)v62);
        }
        std::string::basic_string[abi:ne180100]<0>(__p, (char *)p_str);
        v41 = Security::CodeSigning::ResourceBuilder::findRule(a1, (uint64_t)__p);
        if (v75 < 0)
          operator delete(__p[0]);
        if ((v41 == 0) | v5 & 1 || (v42 = *(_DWORD *)(v41 + 36), (v42 & 0x12) != 0))
        {
          if (a3)
          {
            v43 = v41 ? *(unsigned int *)(v41 + 36) : 0;
            std::string::basic_string[abi:ne180100]<0>(v70, (char *)p_str);
            (*(void (**)(uint64_t, FTSENT *, uint64_t, void **, uint64_t))(a3 + 16))(a3, v7, v43, v70, v41);
            if (v71 < 0)
            {
              v44 = v70[0];
LABEL_104:
              operator delete(v44);
            }
          }
        }
        else
        {
          std::string::basic_string[abi:ne180100]<0>(v72, (char *)p_str);
          (*(void (**)(uint64_t, FTSENT *, _QWORD, void **, uint64_t))(a2 + 16))(a2, v7, v42 & 0xFFFFFFFB, v72, v41);
          if (v73 < 0)
          {
            v47 = v72[0];
LABEL_115:
            operator delete(v47);
          }
LABEL_116:
          v5 = 0;
        }
        goto LABEL_125;
      default:
        v31 = secLogObjForScope("rdirenum");
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          fts_info = v7->fts_info;
          fts_errno = v7->fts_errno;
          v53 = (std::string::size_type)v7->fts_path;
          LODWORD(v84.__r_.__value_.__l.__data_) = 67109634;
          HIDWORD(v84.__r_.__value_.__r.__words[0]) = fts_info;
          LOWORD(v84.__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&v84.__r_.__value_.__r.__words[1] + 2) = fts_errno;
          HIWORD(v84.__r_.__value_.__r.__words[1]) = 2080;
          v84.__r_.__value_.__r.__words[2] = v53;
          _os_log_debug_impl(&dword_18A900000, v31, OS_LOG_TYPE_DEBUG, "type %d (errno %d): %s", (uint8_t *)&v84, 0x18u);
        }
        if (!*(_BYTE *)(a1 + 89))
          goto LABEL_125;
        v61 = -67016;
        goto LABEL_144;
    }
  }
  if (SHIBYTE(v83.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v83.__r_.__value_.__l.__data_);
}

void sub_18AA4DC38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  uint64_t v60;

  if (a24 < 0)
    operator delete(__p);
  if (*(char *)(v60 - 169) < 0)
    operator delete(*(void **)(v60 - 192));
  if (*(char *)(v60 - 145) < 0)
    operator delete(*(void **)(v60 - 168));
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::ResourceBuilder::findRule(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  int v13;
  int v14;
  const char *v15;
  NSObject *v16;
  const char *v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = secLogObjForScope("rscan");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    v18 = (const char *)a2;
    if (*(char *)(a2 + 23) < 0)
      v18 = *(const char **)a2;
    *(_DWORD *)buf = 136315138;
    v20 = v18;
    _os_log_debug_impl(&dword_18A900000, v4, OS_LOG_TYPE_DEBUG, "test %s", buf, 0xCu);
  }
  v5 = *(uint64_t **)(a1 + 64);
  if (v5 != *(uint64_t **)(a1 + 72))
  {
    v6 = 0;
    while (1)
    {
      v7 = *v5;
      v8 = secLogObjForScope("rscan");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        v11 = (const char *)(v7 + 40);
        if (*(char *)(v7 + 63) < 0)
          v11 = *(const char **)v11;
        *(_DWORD *)buf = 136315138;
        v20 = v11;
        _os_log_debug_impl(&dword_18A900000, v8, OS_LOG_TYPE_DEBUG, "try %s", buf, 0xCu);
      }
      v9 = (const char *)a2;
      if (*(char *)(a2 + 23) < 0)
        v9 = *(const char **)a2;
      if (Security::CodeSigning::ResourceBuilder::Rule::match((const regex_t *)v7, v9))
      {
        v10 = secLogObjForScope("rscan");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)buf = 0;
          _os_log_debug_impl(&dword_18A900000, v10, OS_LOG_TYPE_DEBUG, "match", buf, 2u);
        }
        if ((*(_BYTE *)(v7 + 36) & 0x10) != 0)
        {
          v16 = secLogObjForScope("rscan");
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_debug_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEBUG, "excluded", buf, 2u);
          }
          return v7;
        }
        if (!v6 || *(_DWORD *)(v7 + 32) > *(_DWORD *)(v6 + 32))
          v6 = v7;
      }
      if (++v5 == *(uint64_t **)(a1 + 72))
        goto LABEL_20;
    }
  }
  v6 = 0;
LABEL_20:
  v12 = secLogObjForScope("rscan");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
  {
    if (v6)
    {
      v15 = (const char *)(v6 + 40);
      if (*(char *)(v6 + 63) < 0)
        v15 = *(const char **)v15;
      v13 = *(_DWORD *)(v6 + 32);
      v14 = *(_DWORD *)(v6 + 36);
    }
    else
    {
      v13 = 0;
      v14 = 0;
      v15 = "NOTHING";
    }
    *(_DWORD *)buf = 136315650;
    v20 = v15;
    v21 = 1024;
    v22 = v13;
    v23 = 1024;
    v24 = v14;
    _os_log_debug_impl(&dword_18A900000, v12, OS_LOG_TYPE_DEBUG, "choosing %s (%d,0x%x)", buf, 0x18u);
  }
  return v6;
}

uint64_t Security::CodeSigning::ResourceBuilder::Rule::match(const regex_t *this, const char *a2)
{
  int v2;

  v2 = regexec(this, a2, 0, 0, 0);
  if (!v2)
    return 1;
  if (v2 != 1)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA13);
  return 0;
}

uint64_t Security::CodeSigning::ResourceBuilder::includes(uint64_t a1, std::string *this)
{
  std::string::size_type v4;
  uint64_t Rule;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  std::string __p;
  std::string v12;
  char v13;

  v4 = std::string::find(this, 47, 0);
  if (v4 == -1)
    goto LABEL_7;
  std::string::basic_string(&v12, this, 0, v4, (std::allocator<char> *)&v13);
  Rule = Security::CodeSigning::ResourceBuilder::findRule(a1, (uint64_t)&v12);
  v6 = Rule;
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v12.__r_.__value_.__l.__data_);
    if (!v6)
      goto LABEL_7;
  }
  else if (!Rule)
  {
    goto LABEL_7;
  }
  v7 = *(_DWORD *)(v6 + 36);
  if ((v7 & 0x10) != 0)
    return (v7 >> 5) & 1;
LABEL_7:
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, this->__r_.__value_.__l.__data_, this->__r_.__value_.__l.__size_);
  else
    __p = *this;
  v8 = Security::CodeSigning::ResourceBuilder::findRule(a1, (uint64_t)&__p);
  v9 = v8;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v8)
      goto LABEL_12;
    return 0;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!v9)
    return 0;
LABEL_12:
  if ((*(_DWORD *)(v9 + 36) & 0x12) != 0)
    return (*(_DWORD *)(v9 + 36) >> 5) & 1;
  else
    return 1;
}

void sub_18AA4E160(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN8Security11CodeSigning12hashFileDataINS_11DynamicHashEEEmNS_12UnixPlusPlus8FileDescEPT_m_block_invoke_14810(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 24))(*(_QWORD *)(a1 + 32));
}

void ___ZN8Security11CodeSigning15ResourceBuilder8hashFileEPKcNSt3__13setIjNS4_4lessIjEENS4_9allocatorIjEEEEb_block_invoke(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  __CFDictionary *v7;
  const void *v8;
  CFDataRef v9;
  void *__p[2];
  char v11;
  const void *v12;
  void *v13[3];

  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 16))(a3);
  memset(v13, 170, sizeof(v13));
  std::vector<unsigned char>::vector(v13, v6);
  (*(void (**)(uint64_t, void *))(*(_QWORD *)a3 + 32))(a3, v13[0]);
  v7 = *(__CFDictionary **)(a1 + 32);
  Security::CodeSigning::ResourceBuilder::hashName((Security::CodeSigning::ResourceBuilder *)__p, a2);
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)&v12, (char *)__p);
  v8 = v12;
  v9 = CFDataCreate(0, (const UInt8 *)v13[0], v6);
  CFDictionaryAddValue(v7, v8, v9);
  Security::CFRef<__CFData const*>::~CFRef((const void **)&v9);
  Security::CFRef<__CFString const*>::~CFRef(&v12);
  if (v11 < 0)
    operator delete(__p[0]);
  if (v13[0])
  {
    v13[1] = v13[0];
    operator delete(v13[0]);
  }
}

void sub_18AA4E288(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, const void *a16, void *a17, uint64_t a18)
{
  Security::CFRef<__CFData const*>::~CFRef((const void **)&a9);
  Security::CFRef<__CFString const*>::~CFRef(&a16);
  if (a15 < 0)
    operator delete(__p);
  if (a17)
  {
    a18 = (uint64_t)a17;
    operator delete(a17);
  }
  _Unwind_Resume(a1);
}

_QWORD *Security::CodeSigning::ResourceBuilder::hashName(Security::CodeSigning::ResourceBuilder *this, int a2)
{
  char __str[24];
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a2 == 1)
    return std::string::basic_string[abi:ne180100]<0>(this, "hash");
  memset(__str, 170, 20);
  snprintf(__str, 0x14uLL, "hash%d", a2);
  return std::string::basic_string[abi:ne180100]<0>(this, __str);
}

void Security::CodeSigning::ResourceBuilder::escapeRE(std::string *a1, std::string::value_type *a2)
{
  uint64_t v2;
  int v3;
  std::string::value_type *v6;
  std::string::value_type v7;
  uint64_t v8;
  std::string::value_type *v9;

  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  v2 = a2[23];
  v3 = (char)v2;
  if ((v2 & 0x80u) != 0)
    v2 = *((_QWORD *)a2 + 1);
  if (v2)
  {
    if (v3 >= 0)
      v6 = a2;
    else
      v6 = *(std::string::value_type **)a2;
    do
    {
      v7 = *v6;
      if (memchr("\\[]{}().+*?^$|", *v6, 0xFuLL))
        std::string::push_back(a1, 92);
      std::string::push_back(a1, v7);
      ++v6;
      v8 = a2[23];
      if ((v8 & 0x80u) == 0)
        v9 = a2;
      else
        v9 = *(std::string::value_type **)a2;
      if ((v8 & 0x80u) != 0)
        v8 = *((_QWORD *)a2 + 1);
    }
    while (v6 != &v9[v8]);
  }
}

void sub_18AA4E458(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

Security::CodeSigning::ResourceSeal *Security::CodeSigning::ResourceSeal::ResourceSeal(Security::CodeSigning::ResourceSeal *this, CFTypeRef cf)
{
  char *v3;
  char *v4;
  CFTypeID v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFDictionary *v14;
  CFTypeID v15;
  const char *v16;
  const void *Value;
  const __CFString *v18;
  const char *v19;
  const void *v20;
  char v21;
  int v23;

  *((_QWORD *)this + 1) = 0;
  v3 = (char *)this + 8;
  *((_QWORD *)this + 2) = 0;
  v4 = (char *)this + 16;
  *(_QWORD *)this = 0;
  *((_DWORD *)this + 6) = 0;
  if (!cf)
    goto LABEL_20;
  v6 = CFGetTypeID(cf);
  if (v6 != CFDataGetTypeID())
  {
    v15 = CFGetTypeID(cf);
    if (v15 == CFDictionaryGetTypeID())
    {
      Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)this, cf);
      v14 = *(const __CFDictionary **)this;
      goto LABEL_8;
    }
LABEL_20:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA11);
  }
  v14 = Security::cfmake<__CFDictionary const*>((uint64_t)"{hash=%O}", v7, v8, v9, v10, v11, v12, v13, (uint64_t)cf);
  if (*(_QWORD *)this)
    CFRelease(*(CFTypeRef *)this);
  *(_QWORD *)this = v14;
LABEL_8:
  v23 = 0;
  Value = CFDictionaryGetValue(v14, CFSTR("requirement"));
  v18 = *(const __CFString **)this;
  if (Value)
  {
    v19 = "{requirement=%SO,?optional=%B}";
    v4 = v3;
LABEL_12:
    v21 = Security::cfscan(v18, v19, v16, v4, &v23);
    goto LABEL_13;
  }
  v20 = CFDictionaryGetValue((CFDictionaryRef)v18, CFSTR("symlink"));
  v18 = *(const __CFString **)this;
  if (v20)
  {
    v19 = "{symlink=%SO,?optional=%B}";
    goto LABEL_12;
  }
  v21 = Security::cfscan(v18, "{?optional=%B}", v16, &v23);
LABEL_13:
  if ((v21 & 1) == 0)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA11);
  if (v23)
    *((_DWORD *)this + 6) |= 1u;
  if (*(_QWORD *)v3)
    *((_DWORD *)this + 6) |= 4u;
  return this;
}

void sub_18AA4E5F4(_Unwind_Exception *a1)
{
  const void **v1;

  Security::CFRef<__CFDictionary const*>::~CFRef(v1);
  _Unwind_Resume(a1);
}

const UInt8 *Security::CodeSigning::ResourceSeal::hash(CFDictionaryRef *this, int a2)
{
  const __CFDictionary *v3;
  const void *Value;
  CFTypeID v5;
  const UInt8 *BytePtr;
  std::string __p;
  void *key;
  std::string v10;

  memset(&v10, 170, sizeof(v10));
  Security::CodeSigning::ResourceBuilder::hashName((Security::CodeSigning::ResourceBuilder *)&v10, a2);
  v3 = *this;
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, v10.__r_.__value_.__l.__data_, v10.__r_.__value_.__l.__size_);
  else
    __p = v10;
  Security::CFTempString::CFTempString<std::string>((CFStringRef *)&key, (char *)&__p);
  Value = CFDictionaryGetValue(v3, key);
  Security::CFRef<__CFString const*>::~CFRef((const void **)&key);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (Value)
      goto LABEL_9;
  }
  else if (Value)
  {
    goto LABEL_9;
  }
  Value = CFDictionaryGetValue(*this, CFSTR("hash"));
  if (!Value)
    goto LABEL_13;
LABEL_9:
  v5 = CFGetTypeID(Value);
  if (v5 != CFDataGetTypeID())
LABEL_13:
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA11);
  BytePtr = CFDataGetBytePtr((CFDataRef)Value);
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v10.__r_.__value_.__l.__data_);
  return BytePtr;
}

void sub_18AA4E710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SecCodeSignerRemoteGetTypeID()
{
  return *(_QWORD *)(Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()() + 512);
}

void sub_18AA4E770(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18AA4E768);
}

uint64_t SecCodeSignerRemoteCreate(const __CFDictionary *a1, const void *a2, int a3, _QWORD *a4)
{
  uint64_t v8;
  const Security::CFClass *v9;
  Security::SecCFObject *v10;
  unsigned __int8 *v11;
  unsigned __int8 v12;
  const void *v13;
  const void *v14;
  Security::SecCFObject *v16;

  if ((a3 & 0xFFFFFC0D) != 0)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v16 = (Security::SecCFObject *)0xAAAAAAAAAAAAAAAALL;
  v8 = Security::ModuleNexus<Security::CodeSigning::CFObjects>::operator()();
  v10 = (Security::SecCFObject *)Security::SecCFObject::allocate((Security::SecCFObject *)0x150, *(_QWORD *)(v8 + 512), v9);
  *((_QWORD *)v10 + 1) = 1;
  *((_DWORD *)v10 + 4) = a3;
  *((_QWORD *)v10 + 21) = 0;
  *((_QWORD *)v10 + 20) = 0;
  *(_OWORD *)((char *)v10 + 24) = 0u;
  *(_OWORD *)((char *)v10 + 40) = 0u;
  *(_OWORD *)((char *)v10 + 56) = 0u;
  *((_OWORD *)v10 + 5) = 0u;
  *((_OWORD *)v10 + 6) = 0u;
  *((_OWORD *)v10 + 7) = 0u;
  *((_QWORD *)v10 + 19) = (char *)v10 + 160;
  *((_QWORD *)v10 + 36) = 0;
  *((_DWORD *)v10 + 74) = 0;
  *((_OWORD *)v10 + 11) = 0u;
  *((_OWORD *)v10 + 12) = 0u;
  *((_OWORD *)v10 + 13) = 0u;
  *((_OWORD *)v10 + 14) = 0u;
  *((_QWORD *)v10 + 30) = 0;
  *((_QWORD *)v10 + 32) = 0;
  *((_QWORD *)v10 + 33) = 0;
  *((_QWORD *)v10 + 34) = 0;
  *((_QWORD *)v10 + 38) = 0;
  *((_QWORD *)v10 + 39) = 0;
  *(_QWORD *)v10 = off_1E1FC8DD0;
  *((_QWORD *)v10 + 41) = 0;
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)v10 + 41, a2);
  v11 = (unsigned __int8 *)v10 - 8;
  do
    v12 = __ldaxr(v11);
  while (__stlxr(1u, v11));
  if ((v12 & 1) != 0)
  {
    v13 = (const void *)(*(uint64_t (**)(Security::SecCFObject *))(*(_QWORD *)v10 + 16))(v10);
    CFRetain(v13);
  }
  v16 = v10;
  Security::CodeSigning::SecCodeSigner::parameters(v10, a1);
  v14 = Security::SecCFObject::handle(v10, 1);
  if (!a4)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA03);
  *a4 = v14;
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v16);
  return 0;
}

void sub_18AA4E8E4(void *a1, int a2)
{
  __CFError **v2;
  Security::CodeSigning::SecCodeSigner *v3;
  const void **v4;
  char *v7;
  CFDictionaryRef *v8;
  _DWORD *v9;
  int v10;
  void *v11;
  int v12;
  CFErrorRef v13;
  _DWORD *v14;
  unsigned int v15;
  int v16;
  void *v17;
  int v18;
  const char *v19;

  Security::CFRef<__CFArray const*>::~CFRef(v4);
  Security::CodeSigning::SecCodeSigner::~SecCodeSigner(v3);
  Security::SecCFObject::operator delete(v7);
  switch(a2)
  {
    case 7:
      v8 = (CFDictionaryRef *)__cxa_begin_catch(a1);
      Security::CodeSigning::CSError::cfError(v8, v2);
      goto LABEL_32;
    case 6:
      v9 = __cxa_begin_catch(a1);
      if (v9[36] == 8)
        v10 = -67049;
      else
        v10 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v9 + 24))(v9);
      if (v2)
      {
LABEL_30:
        v13 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v10, 0);
        goto LABEL_31;
      }
LABEL_32:
      __cxa_end_catch();
      JUMPOUT(0x18AA4E8A8);
    case 5:
      v11 = __cxa_begin_catch(a1);
      v12 = (*(uint64_t (**)(void *))(*(_QWORD *)v11 + 24))(v11);
      if (!v2)
        goto LABEL_32;
      v13 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v12, 0);
LABEL_31:
      *v2 = v13;
      goto LABEL_32;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      v17 = __cxa_begin_catch(a1);
      v18 = (*(uint64_t (**)(void *))(*(_QWORD *)v17 + 24))(v17);
      if (v2)
        *v2 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v18, 0);
    }
    else
    {
      __cxa_begin_catch(a1);
      if (a2 == 2)
      {
        if (v2)
          *v2 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -108, 0);
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v19);
        if (v2)
          *v2 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -67048, 0);
      }
    }
    goto LABEL_32;
  }
  v14 = __cxa_begin_catch(a1);
  v15 = v14[36];
  if (v15 > 0x1A)
    goto LABEL_28;
  v10 = -67033;
  v16 = 1 << v15;
  if ((v16 & 0x800108) != 0)
    goto LABEL_29;
  if ((v16 & 0x4014000) != 0)
    v10 = -67032;
  else
LABEL_28:
    v10 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v14 + 24))(v14);
LABEL_29:
  if (!v2)
    goto LABEL_32;
  goto LABEL_30;
}

void sub_18AA4EB40(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t SecCodeSignerRemoteAddSignature(uint64_t a1, Security::CodeSigning::SecStaticCode *a2, int a3, uint64_t a4)
{
  Security::CodeSigning::SecCodeSigner *v6;
  const __SecCode *v7;
  Security::CodeSigning::SecCodeSigner *v8;
  unsigned __int8 *v9;
  unsigned __int8 v10;
  const void *v11;
  Security::CodeSigning::SecStaticCode *v12;
  NSObject *v13;
  NSObject *v14;
  Security::CodeSigning::SecCodeSigner *v15;
  NSObject *v16;
  uint64_t v18;
  NSObject *v19;
  unint64_t v20;
  uint8_t buf[4];
  Security::CodeSigning::SecCodeSigner *v22;
  __int16 v23;
  Security::CodeSigning::SecStaticCode *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;
  _QWORD __dst[56];

  __dst[55] = *MEMORY[0x1E0C80C00];
  if (a3)
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA02);
  v20 = 0xAAAAAAAAAAAAAAAALL;
  if (!a1
  {
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  v8 = v6;
  v9 = (unsigned __int8 *)v6 - 8;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(1u, v9));
  if ((v10 & 1) != 0)
  {
    v11 = (const void *)(*(uint64_t (**)(Security::CodeSigning::SecCodeSigner *))(*(_QWORD *)v6 + 16))(v6);
    CFRetain(v11);
  }
  v20 = (unint64_t)v8;
  v12 = (Security::CodeSigning::SecStaticCode *)Security::CodeSigning::SecStaticCode::required(a2, v7);
  Security::CodeSigning::SecStaticCode::codeDirectory(v12, 0);
  v13 = secLogObjForScope("remotesigner");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(__dst[0]) = 134218496;
    *(_QWORD *)((char *)__dst + 4) = v8;
    WORD2(__dst[1]) = 2048;
    *(_QWORD *)((char *)&__dst[1] + 6) = v12;
    HIWORD(__dst[2]) = 2048;
    __dst[3] = a4;
    _os_log_debug_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEBUG, "%p will start remote signature from %p with block %p", (uint8_t *)__dst, 0x20u);
  }
  *((_DWORD *)v12 + 52) = 0;
  memcpy(__dst, &unk_18AA617B8, 0x1B8uLL);
  Security::CodeSigning::SecCodeSigner::Signer::Signer((Security::CodeSigning::SecCodeSigner::Signer *)__dst, v8, v12);
  if (((*(uint64_t (**)(Security::CodeSigning::SecCodeSigner *))(*(_QWORD *)v8 + 80))(v8) & 1) == 0)
  {
    v19 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_18A900000, v19, OS_LOG_TYPE_DEFAULT, "Invalid signing operation, bailing.", buf, 2u);
    }
    Security::MacOSError::throwMe((Security::MacOSError *)0xFFFEFA01);
  }
  v14 = secLogObjForScope("remotesigner");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    v18 = *((_QWORD *)v8 + 41);
    *(_DWORD *)buf = 134218754;
    v22 = v8;
    v23 = 2048;
    v24 = v12;
    v25 = 1024;
    v26 = 0;
    v27 = 2112;
    v28 = v18;
    _os_log_debug_impl(&dword_18A900000, v14, OS_LOG_TYPE_DEBUG, "%p will sign %p (flags 0x%x) with certs: %@", buf, 0x26u);
  }
  v15 = (Security::CodeSigning::SecCodeSigner *)*((_QWORD *)v8 + 41);
  v16 = secLogObjForScope("signer");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 138412290;
    v22 = v15;
    _os_log_debug_impl(&dword_18A900000, v16, OS_LOG_TYPE_DEBUG, "configuring remote signing with cert chain: %@", buf, 0xCu);
  }
  BYTE2(__dst[40]) = 1;
  __dst[41] = a4;
  Security::CFRef<__CFArray const*>::operator=((CFTypeRef *)&__dst[42], v15);
  Security::CodeSigning::SecCodeSigner::Signer::sign((Security::CodeSigning::SecCodeSigner::Signer *)__dst, 0);
  Security::CodeSigning::SecStaticCode::resetValidity(v12);
  Security::CodeSigning::SecCodeSigner::Signer::~Signer((Security::CodeSigning::SecCodeSigner::Signer *)__dst);
  Security::SecPointerBase::~SecPointerBase((Security::SecPointerBase *)&v20);
  return 0;
}

void sub_18AA4EEB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  __CFError **v17;
  CFDictionaryRef *v19;
  _DWORD *v20;
  int v21;
  void *v22;
  int v23;
  _DWORD *v24;
  unsigned int v25;
  int v26;
  int v27;
  void *v28;
  int v29;
  const char *v30;

  if (!a2)
    _Unwind_Resume(exception_object);
  switch(a2)
  {
    case 7:
      v19 = (CFDictionaryRef *)__cxa_begin_catch(exception_object);
      Security::CodeSigning::CSError::cfError(v19, v17);
      __cxa_end_catch();
      goto LABEL_36;
    case 6:
      v20 = __cxa_begin_catch(exception_object);
      if (v20[36] == 8)
        v21 = -67049;
      else
        v21 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v20 + 24))(v20);
      if (v17)
        *v17 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v21, 0);
LABEL_23:
      __cxa_end_catch();
LABEL_36:
      JUMPOUT(0x18AA4ED20);
    case 5:
      v22 = __cxa_begin_catch(exception_object);
      v23 = (*(uint64_t (**)(void *))(*(_QWORD *)v22 + 24))(v22);
      if (v17)
        *v17 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v23, 0);
      goto LABEL_23;
  }
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      v28 = __cxa_begin_catch(exception_object);
      v29 = (*(uint64_t (**)(void *))(*(_QWORD *)v28 + 24))(v28);
      if (v17)
        *v17 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v29, 0);
    }
    else
    {
      __cxa_begin_catch(exception_object);
      if (a2 == 2)
      {
        if (v17)
          *v17 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -108, 0);
      }
      else
      {
        Security::Syslog::notice((Security::Syslog *)"unknown exception in CSAPI", v30);
        if (v17)
          *v17 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], -67048, 0);
      }
    }
    goto LABEL_23;
  }
  v24 = __cxa_begin_catch(exception_object);
  v25 = v24[36];
  if (v25 > 0x1A)
    goto LABEL_31;
  v26 = -67033;
  v27 = 1 << v25;
  if ((v27 & 0x800108) != 0)
    goto LABEL_32;
  if ((v27 & 0x4014000) != 0)
    v26 = -67032;
  else
LABEL_31:
    v26 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v24 + 24))(v24);
LABEL_32:
  if (v17)
    *v17 = CFErrorCreate(0, (CFErrorDomain)*MEMORY[0x1E0C9AFC8], v26, 0);
  goto LABEL_23;
}

void Security::CodeSigning::LimitedAsync::~LimitedAsync(Security::CodeSigning::LimitedAsync *this)
{
  uint64_t v1;

  *(_QWORD *)this = &off_1E1FC88A0;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
}

{
  uint64_t v1;

  *(_QWORD *)this = &off_1E1FC88A0;
  v1 = *((_QWORD *)this + 1);
  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  JUMPOUT(0x18D76FAA0);
}

Security::CodeSigning::LimitedAsync *Security::CodeSigning::LimitedAsync::LimitedAsync(Security::CodeSigning::LimitedAsync *this, unsigned __int8 a2)
{
  uint64_t v4;
  intptr_t v5;
  _QWORD *v6;

  *(_QWORD *)this = &off_1E1FC88A0;
  v4 = sysconf(58);
  if ((a2 & (v4 > 0)) != 0)
    v5 = v4 - 1;
  else
    v5 = 0;
  v6 = (_QWORD *)operator new();
  *v6 = &off_1E1FC93E0;
  v6[1] = dispatch_semaphore_create(v5);
  *((_QWORD *)this + 1) = v6;
  return this;
}

void Security::CodeSigning::LimitedAsync::perform(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *global_queue;
  _QWORD v7[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t);
  intptr_t (*v12)(intptr_t);
  void (**v13)(Security::Dispatch::SemaphoreWait *__hidden);
  uint64_t v14;
  unint64_t v15;
  _QWORD block[6];

  v8 = 0;
  v9 = &v8;
  v10 = 0x4002000000;
  v11 = __Block_byref_object_copy__14870;
  v12 = __Block_byref_object_dispose__14871;
  v14 = a1;
  v15 = 0xAAAAAAAAAAAAAAAALL;
  v13 = &off_1E1FC9380;
  LOBYTE(v15) = dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 8), 0) == 0;
  if (*((_BYTE *)v9 + 56))
  {
    v5 = MEMORY[0x1E0C809B0];
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = ___ZN8Security11CodeSigning12LimitedAsync7performERNS_8Dispatch5GroupEU13block_pointerFvvE_block_invoke;
    v7[3] = &unk_1E1FDD070;
    v7[4] = a3;
    v7[5] = &v8;
    if (!*(_BYTE *)(a2 + 72))
    {
      global_queue = dispatch_get_global_queue(0, 0);
      block[0] = v5;
      block[1] = 0x40000000;
      block[2] = ___ZN8Security8Dispatch23ExceptionAwareEnqueuing21enqueueWithDispatcherEU13block_pointerFvU13block_pointerFvvEES3__block_invoke;
      block[3] = &unk_1E1FDC408;
      block[4] = v7;
      block[5] = a2 + 8;
      dispatch_group_async(*(dispatch_group_t *)(a2 + 88), global_queue, block);
    }
  }
  else
  {
    (*(void (**)(uint64_t))(a3 + 16))(a3);
  }
  _Block_object_dispose(&v8, 8);
  v13 = &off_1E1FC9380;
  if ((_BYTE)v15)
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v14 + 8));
}

void sub_18AA4F408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  _Block_object_dispose(&a15, 8);
  if (a22)
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a21 + 8));
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__14870(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 40) = &off_1E1FC9380;
  *(_QWORD *)(result + 48) = v2;
  *(_BYTE *)(result + 56) = *(_BYTE *)(a2 + 56);
  *(_BYTE *)(a2 + 56) = 0;
  return result;
}

intptr_t __Block_byref_object_dispose__14871(intptr_t result)
{
  *(_QWORD *)(result + 40) = &off_1E1FC9380;
  if (*(_BYTE *)(result + 56))
    return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(_QWORD *)(result + 48) + 8));
  return result;
}

intptr_t ___ZN8Security11CodeSigning12LimitedAsync7performERNS_8Dispatch5GroupEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  intptr_t result;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v2 = *(_QWORD *)(v1 + 48);
  v3 = *(unsigned __int8 *)(v1 + 56);
  *(_BYTE *)(v1 + 56) = 0;
  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (v3)
    return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v2 + 8));
  return result;
}

void sub_18AA4F4C8(_Unwind_Exception *exception_object)
{
  int v1;
  uint64_t v2;

  if (v1)
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v2 + 8));
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::isOnRootFilesystem(Security::CodeSigning *this, const char *a2)
{
  NSObject *v3;
  _BOOL4 v4;
  uint64_t result;
  int v6;
  _DWORD v7[2];
  __int16 v8;
  Security::CodeSigning *v9;
  statfs __b;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  memset(&__b, 170, sizeof(__b));
  if (!statfs((const char *)this, &__b))
    return (BYTE1(__b.f_flags) >> 6) & 1;
  v3 = secLogObjForScope("SecError");
  v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v4)
  {
    v6 = *__error();
    v7[0] = 67109378;
    v7[1] = v6;
    v8 = 2080;
    v9 = this;
    _os_log_impl(&dword_18A900000, v3, OS_LOG_TYPE_DEFAULT, "Unable to check if path is on rootfs: %d, %s", (uint8_t *)v7, 0x12u);
    return 0;
  }
  return result;
}

BOOL Security::CodeSigning::pathFileSystemUsesXattrFiles(Security::CodeSigning *this, const char *a2)
{
  __int128 v3;
  NSObject *v4;
  _BOOL4 v5;
  _BOOL8 result;
  int v7;
  int *v8;
  char *v9;
  const char *v10;
  NSObject *v11;
  _BOOL4 v12;
  NSObject *v13;
  uint32_t v14;
  _BOOL4 v15;
  int v16;
  int *v17;
  char *v18;
  NSObject *v19;
  _BOOL4 v20;
  __int128 v21;
  __int128 v22;
  int v23;
  _QWORD v24[3];
  uint8_t buf[4];
  uint64_t f_mntonname;
  __int16 v27;
  int v28;
  __int16 v29;
  char *v30;
  statfs __b;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v23 = -1431655766;
  *(_QWORD *)&v3 = 0xAAAAAAAAAAAAAAAALL;
  *((_QWORD *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v21 = v3;
  v22 = v3;
  memset(&__b, 170, sizeof(__b));
  if (!this)
  {
    v11 = secLogObjForScope("SecError");
    v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v12)
      return result;
    *(_WORD *)buf = 0;
    v10 = "path is NULL";
    v13 = v11;
    v14 = 2;
    goto LABEL_11;
  }
  if (statfs((const char *)this, &__b))
  {
    v4 = secLogObjForScope("SecError");
    v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v5)
      return result;
    v7 = *__error();
    v8 = __error();
    v9 = strerror(*v8);
    *(_DWORD *)buf = 136315650;
    f_mntonname = (uint64_t)this;
    v27 = 1024;
    v28 = v7;
    v29 = 2080;
    v30 = v9;
    v10 = "Unable to convert %s to its filesystem mount [statfs failed]: %d [%s]";
LABEL_10:
    v13 = v4;
    v14 = 28;
LABEL_11:
    _os_log_impl(&dword_18A900000, v13, OS_LOG_TYPE_DEFAULT, v10, buf, v14);
    return 0;
  }
  v24[2] = 0;
  v24[0] = 5;
  v24[1] = 2147614720;
  if (getattrlist(__b.f_mntonname, v24, &v21, 0x24uLL, 0))
  {
    v4 = secLogObjForScope("SecError");
    v15 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v15)
      return result;
    v16 = *__error();
    v17 = __error();
    v18 = strerror(*v17);
    *(_DWORD *)buf = 136315650;
    f_mntonname = (uint64_t)__b.f_mntonname;
    v27 = 1024;
    v28 = v16;
    v29 = 2080;
    v30 = v18;
    v10 = "Unable to get volume capabilities from %s: %d [%s]";
    goto LABEL_10;
  }
  if ((_DWORD)v21 == 36)
  {
    return (BYTE9(v21) & 0x40) == 0 || (BYTE9(v22) & 0x40) == 0;
  }
  else
  {
    v19 = secLogObjForScope("SecError");
    v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v20)
    {
      *(_DWORD *)buf = 134218240;
      f_mntonname = 36;
      v27 = 1024;
      v28 = v21;
      v10 = "getattrlist return length incorrect, expected %lu, got %u";
      v13 = v19;
      v14 = 18;
      goto LABEL_11;
    }
  }
  return result;
}

uint64_t Security::CodeSigning::pathIsValidXattrFile(char *a1, const char *a2)
{
  char *v3;
  int v4;
  const char *v5;
  timespec v6;
  NSObject *v7;
  int v8;
  int *v9;
  char *v10;
  NSObject *v11;
  const char *v12;
  uint64_t v13;
  const char *v15;
  size_t v16;
  char *v17;
  unsigned __int8 *v18;
  int v19;
  std::string::size_type v20;
  char *v21;
  NSObject *v22;
  int v23;
  int *v24;
  char *v25;
  const char *v26;
  NSObject *v27;
  uint32_t v28;
  NSObject *v29;
  int v30;
  int *v31;
  char *v32;
  NSObject *v33;
  int v34;
  std::string::size_type v35;
  std::string *v36;
  __int128 v37;
  std::string *v38;
  std::string::size_type size;
  std::string *v40;
  __int128 v41;
  stat *v42;
  NSObject *v43;
  int v44;
  const char *v45;
  NSObject *v46;
  uint32_t v47;
  NSObject *v48;
  NSObject *v49;
  stat *v50;
  ssize_t v51;
  NSObject *v52;
  const char *v53;
  NSObject *v54;
  uint32_t v55;
  NSObject *v56;
  stat *v57;
  const char *v58;
  stat *v59;
  std::string v60;
  std::string v61;
  char v62;
  _BYTE buf[28];
  stat v64;
  uint64_t v65;

  v3 = a1;
  v65 = *MEMORY[0x1E0C80C00];
  if (a1[23] < 0)
  {
    v5 = *(const char **)a1;
    v4 = **(unsigned __int8 **)a1;
  }
  else
  {
    v4 = *a1;
    v5 = a1;
  }
  if (v4 != 47)
  {
    v11 = secLogObjForScope(a2);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      return 0;
    if (v3[23] < 0)
      v3 = *(char **)v3;
    v64.st_dev = 136315138;
    *(_QWORD *)&v64.st_mode = v3;
    v12 = "%s isn't a full path, but a relative path";
LABEL_28:
    _os_log_debug_impl(&dword_18A900000, v11, OS_LOG_TYPE_DEBUG, v12, (uint8_t *)&v64, 0xCu);
    return 0;
  }
  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v64.st_blksize = v6;
  *(timespec *)v64.st_qspare = v6;
  v64.st_birthtimespec = v6;
  *(timespec *)&v64.st_size = v6;
  v64.st_mtimespec = v6;
  v64.st_ctimespec = v6;
  *(timespec *)&v64.st_uid = v6;
  v64.st_atimespec = v6;
  *(timespec *)&v64.st_dev = v6;
  if (stat(v5, &v64))
  {
    v7 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *__error();
      v9 = __error();
      v10 = strerror(*v9);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v5;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = v10;
      _os_log_impl(&dword_18A900000, v7, OS_LOG_TYPE_DEFAULT, "Unable to stat %s: %d [%s]", buf, 0x1Cu);
    }
    goto LABEL_13;
  }
  if (((__int16)v64.st_mode & 0x80000000) == 0)
  {
LABEL_13:
    v11 = secLogObjForScope(a2);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      return 0;
    if (v3[23] < 0)
      v3 = *(char **)v3;
    v64.st_dev = 136315138;
    *(_QWORD *)&v64.st_mode = v3;
    v12 = "%s isn't a regular file";
    goto LABEL_28;
  }
  v15 = v3;
  if (v3[23] < 0)
  {
    v15 = *(const char **)v3;
    if (!*(_QWORD *)v3)
    {
      v33 = secLogObjForScope("SecError");
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        goto LABEL_37;
      LOWORD(v64.st_dev) = 0;
      v26 = "path is NULL";
      v27 = v33;
      v28 = 2;
      goto LABEL_36;
    }
  }
  v16 = strlen(v15);
  v17 = (char *)malloc_type_malloc(v16 + 1, 0x45AEB810uLL);
  if (!v17)
  {
    v22 = secLogObjForScope("SecError");
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      goto LABEL_37;
    v23 = *__error();
    v24 = __error();
    v25 = strerror(*v24);
    v64.st_dev = 67109378;
    *(_DWORD *)&v64.st_mode = v23;
    LOWORD(v64.st_ino) = 2080;
    *(__darwin_ino64_t *)((char *)&v64.st_ino + 2) = (__darwin_ino64_t)v25;
    v26 = "Unable to allocate space for storing basename: %d [%s]";
    v27 = v22;
    v28 = 18;
LABEL_36:
    _os_log_impl(&dword_18A900000, v27, OS_LOG_TYPE_DEFAULT, v26, (uint8_t *)&v64, v28);
    goto LABEL_37;
  }
  v18 = (unsigned __int8 *)v17;
  if (!basename_r(v15, v17))
  {
    v29 = secLogObjForScope("SecError");
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      v30 = *__error();
      v31 = __error();
      v32 = strerror(*v31);
      v64.st_dev = 136315650;
      *(_QWORD *)&v64.st_mode = v15;
      WORD2(v64.st_ino) = 1024;
      *(_DWORD *)((char *)&v64.st_ino + 6) = v30;
      HIWORD(v64.st_uid) = 2080;
      *(_QWORD *)&v64.st_gid = v32;
      _os_log_impl(&dword_18A900000, v29, OS_LOG_TYPE_DEFAULT, "Could not get basename of %s: %d [%s]", (uint8_t *)&v64, 0x1Cu);
    }
    goto LABEL_33;
  }
  if (strlen((const char *)v18) < 3 || *v18 != 46)
  {
LABEL_33:
    free(v18);
    goto LABEL_37;
  }
  v19 = v18[1];
  free(v18);
  if (v19 != 95)
  {
LABEL_37:
    v11 = secLogObjForScope(a2);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      return 0;
    if (v3[23] < 0)
      v3 = *(char **)v3;
    v64.st_dev = 136315138;
    *(_QWORD *)&v64.st_mode = v3;
    v12 = "%s doesn't match Xattr file path spec";
    goto LABEL_28;
  }
  if (v3[23] < 0)
  {
    v21 = *(char **)v3;
    v20 = *((_QWORD *)v3 + 1);
  }
  else
  {
    v20 = v3[23];
    v21 = v3;
  }
  while (v20)
  {
    v34 = v21[--v20];
    if (v34 == 47)
    {
      v35 = v20;
      goto LABEL_46;
    }
  }
  v35 = -1;
LABEL_46:
  std::string::basic_string(&v61, (const std::string *)v3, 0, v35, (std::allocator<char> *)&v60);
  v36 = std::string::append(&v61, "/", 1uLL);
  v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
  *(_QWORD *)&buf[16] = *((_QWORD *)&v36->__r_.__value_.__l + 2);
  *(_OWORD *)buf = v37;
  v36->__r_.__value_.__l.__size_ = 0;
  v36->__r_.__value_.__r.__words[2] = 0;
  v36->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string(&v60, (const std::string *)v3, v35 + 3, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v62);
  if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v38 = &v60;
  else
    v38 = (std::string *)v60.__r_.__value_.__r.__words[0];
  if ((v60.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v60.__r_.__value_.__r.__words[2]);
  else
    size = v60.__r_.__value_.__l.__size_;
  v40 = std::string::append((std::string *)buf, (const std::string::value_type *)v38, size);
  v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  *(_QWORD *)&v64.st_uid = *((_QWORD *)&v40->__r_.__value_.__l + 2);
  *(_OWORD *)&v64.st_dev = v41;
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v60.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v60.__r_.__value_.__l.__data_);
  if ((buf[23] & 0x80000000) != 0)
    operator delete(*(void **)buf);
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v61.__r_.__value_.__l.__data_);
  if ((v64.st_gid & 0x80000000) == 0)
    v42 = &v64;
  else
    v42 = *(stat **)&v64.st_dev;
  if (!v42)
  {
    v48 = secLogObjForScope("SecError");
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
LABEL_69:
      v49 = secLogObjForScope(a2);
      if (!os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      {
LABEL_70:
        v13 = 0;
        goto LABEL_71;
      }
      v59 = &v64;
      if ((v64.st_gid & 0x80000000) != 0)
        v59 = *(stat **)&v64.st_dev;
      if (v3[23] < 0)
        v3 = *(char **)v3;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v59;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v3;
      v58 = "%s does not exist, forcing resource validation on %s";
LABEL_96:
      _os_log_debug_impl(&dword_18A900000, v49, OS_LOG_TYPE_DEBUG, v58, buf, 0x16u);
      goto LABEL_70;
    }
    *(_WORD *)buf = 0;
    v45 = "path is NULL";
    v46 = v48;
    v47 = 2;
LABEL_68:
    _os_log_impl(&dword_18A900000, v46, OS_LOG_TYPE_DEFAULT, v45, buf, v47);
    goto LABEL_69;
  }
  if (access((const char *)v42, 0))
  {
    if (*__error() == 2)
      goto LABEL_69;
    v43 = secLogObjForScope("SecError");
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      goto LABEL_69;
    v44 = *__error();
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v44;
    *(_WORD *)&buf[8] = 2080;
    *(_QWORD *)&buf[10] = v42;
    v45 = "Unable to check if path exists: %d, %s";
    v46 = v43;
    v47 = 18;
    goto LABEL_68;
  }
  if ((v64.st_gid & 0x80000000) == 0)
    v50 = &v64;
  else
    v50 = *(stat **)&v64.st_dev;
  if (!v50)
  {
    v52 = secLogObjForScope("SecError");
    if (!os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      goto LABEL_85;
    *(_WORD *)buf = 0;
    v53 = "path is NULL";
    v54 = v52;
    v55 = 2;
LABEL_84:
    _os_log_impl(&dword_18A900000, v54, OS_LOG_TYPE_DEFAULT, v53, buf, v55);
    goto LABEL_85;
  }
  v51 = listxattr((const char *)v50, 0, 0, 0);
  if (v51 == -1)
  {
    v56 = secLogObjForScope("SecError");
    if (!os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      goto LABEL_85;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v50;
    v53 = "Unable to acquire the xattr list from %s";
    v54 = v56;
    v55 = 12;
    goto LABEL_84;
  }
  if (v51 <= 0)
  {
LABEL_85:
    v49 = secLogObjForScope(a2);
    if (!os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      goto LABEL_70;
    v57 = &v64;
    if ((v64.st_gid & 0x80000000) != 0)
      v57 = *(stat **)&v64.st_dev;
    if (v3[23] < 0)
      v3 = *(char **)v3;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v57;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v3;
    v58 = "%s does not contain xattrs, forcing resource validation on %s";
    goto LABEL_96;
  }
  v13 = 1;
LABEL_71:
  if (SHIBYTE(v64.st_gid) < 0)
    operator delete(*(void **)&v64.st_dev);
  return v13;
}

void sub_18AA50020(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

std::string *Security::CodeSigning::pathRemaining(std::string *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t *v3;
  int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char isPathPrefix;
  std::string::size_type v11;
  uint64_t *v12;
  std::string::size_type v13;
  std::string::size_type v14;
  std::string __p;
  std::string v17;
  char v18;

  v3 = a3;
  v6 = *(char *)(a2 + 23);
  if (v6 < 0)
    v7 = *(_QWORD *)(a2 + 8);
  else
    v7 = *(unsigned __int8 *)(a2 + 23);
  v8 = *((unsigned __int8 *)a3 + 23);
  if (*((char *)a3 + 23) < 0)
  {
    v9 = a3[1];
    if (v7 < v9)
      return (std::string *)std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18AA61AAF);
  }
  else
  {
    v9 = *((unsigned __int8 *)a3 + 23);
    if (v7 < v8)
      return (std::string *)std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18AA61AAF);
  }
  if (!v9)
    return (std::string *)std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18AA61AAF);
  if (v6 < 0)
  {
    if (!*(_QWORD *)(a2 + 8))
      return (std::string *)std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18AA61AAF);
  }
  else if (!*(_BYTE *)(a2 + 23))
  {
    return (std::string *)std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18AA61AAF);
  }
  if ((v8 & 0x80) != 0)
  {
    std::string::__init_copy_ctor_external(&v17, (const std::string::value_type *)*a3, a3[1]);
    if ((*(_BYTE *)(a2 + 23) & 0x80) == 0)
      goto LABEL_15;
LABEL_17:
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
    goto LABEL_18;
  }
  v17 = *(std::string *)a3;
  if ((v6 & 0x80) != 0)
    goto LABEL_17;
LABEL_15:
  __p = *(std::string *)a2;
LABEL_18:
  isPathPrefix = Security::CodeSigning::isPathPrefix((char *)&v17, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v17.__r_.__value_.__l.__data_);
    if ((isPathPrefix & 1) == 0)
      return (std::string *)std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18AA61AAF);
  }
  else if ((isPathPrefix & 1) == 0)
  {
    return (std::string *)std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18AA61AAF);
  }
  if (*((char *)v3 + 23) < 0)
  {
    v12 = v3;
    v3 = (uint64_t *)*v3;
    v11 = v12[1];
  }
  else
  {
    v11 = *((unsigned __int8 *)v3 + 23);
  }
  if (*((_BYTE *)v3 + v11 - 1) == 47)
    v13 = v11;
  else
    v13 = v11 + 1;
  if (*(char *)(a2 + 23) < 0)
    v14 = *(_QWORD *)(a2 + 8);
  else
    v14 = *(unsigned __int8 *)(a2 + 23);
  if (v13 < v14)
    return std::string::basic_string(a1, (const std::string *)a2, v13, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v18);
  return (std::string *)std::string::basic_string[abi:ne180100]<0>(a1, (char *)&unk_18AA61AAF);
}

void sub_18AA50204(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t Security::CodeSigning::isPathPrefix(char *a1, _QWORD *__s)
{
  _QWORD *v2;
  unint64_t v4;
  _QWORD *v5;
  int64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  int64_t v11;
  char *v12;
  int v13;
  void *v14;
  int64_t v15;
  uint64_t result;
  uint64_t v17;
  unint64_t v18;
  int v19;
  _QWORD *v20;
  unint64_t v21;

  v2 = __s;
  v4 = *((unsigned __int8 *)__s + 23);
  if (*((char *)__s + 23) < 0)
  {
    v5 = (_QWORD *)*__s;
    v6 = __s[1];
  }
  else
  {
    v5 = __s;
    v6 = *((unsigned __int8 *)__s + 23);
  }
  v7 = a1[23];
  v9 = *(_QWORD *)a1;
  v8 = *((_QWORD *)a1 + 1);
  if ((v7 & 0x80u) == 0)
    v10 = a1;
  else
    v10 = *(char **)a1;
  if ((v7 & 0x80u) == 0)
    v11 = a1[23];
  else
    v11 = *((_QWORD *)a1 + 1);
  if (!v11)
    goto LABEL_20;
  if (v6 < v11)
    return 0;
  v20 = v5;
  v21 = *((unsigned __int8 *)__s + 23);
  v12 = (char *)v5 + v6;
  v13 = *v10;
  v14 = v5;
  while (1)
  {
    v15 = v6 - v11;
    if (v15 == -1)
      return 0;
    result = (uint64_t)memchr(v14, v13, v15 + 1);
    if (!result)
      return result;
    v17 = result;
    result = memcmp((const void *)result, v10, v11);
    if (!(_DWORD)result)
      break;
    v14 = (void *)(v17 + 1);
    v6 = (int64_t)&v12[-v17 - 1];
    if (v6 < v11)
      return 0;
  }
  if ((char *)v17 != v12)
  {
    v4 = v21;
    if ((_QWORD *)v17 == v20)
    {
LABEL_20:
      if ((v4 & 0x80) != 0)
        v18 = v2[1];
      else
        v18 = v4;
      if (v11 == v18)
        return 0;
      if ((v7 & 0x80) != 0)
      {
        v19 = *(unsigned __int8 *)(v9 + v8 - 1);
        v7 = v8;
      }
      else
      {
        v19 = a1[v7 - 1];
      }
      if (v19 == 47)
        return 1;
      if ((v4 & 0x80) != 0)
      {
        if (v2[1] <= v7)
          goto LABEL_37;
        v2 = (_QWORD *)*v2;
      }
      else if (v7 >= v4)
      {
LABEL_37:
        std::string::__throw_out_of_range[abi:ne180100]();
      }
      return *((unsigned __int8 *)v2 + v7) == 47;
    }
  }
  return result;
}

